Typesafe helpers for nsCSSDataBlock::StorageFor.  (Bug 475214)  r+sr=bzbarsky

diff --git a/layout/style/nsCSSDataBlock.h b/layout/style/nsCSSDataBlock.h
--- a/layout/style/nsCSSDataBlock.h
+++ b/layout/style/nsCSSDataBlock.h
@@ -38,16 +38,17 @@
  * compact representation of the property-value pairs within a CSS
  * declaration, and the code for expanding and compacting it
  */
 
 #ifndef nsCSSDataBlock_h__
 #define nsCSSDataBlock_h__
 
 #include "nsCSSStruct.h"
+#include "nsCSSProps.h"
 
 struct nsRuleData;
 
 class nsCSSExpandedDataBlock;
 
 /**
  * An |nsCSSCompressedDataBlock| holds an immutable chunk of
  * property-value data for a CSS declaration block (which we misname a
@@ -70,16 +71,52 @@ public:
      * property.  This is either an |nsCSSValue*|, |nsCSSRect*|, or an
      * |nsCSSValueList**|, etc.
      *
      * Inefficient (by design).
      */
     const void* StorageFor(nsCSSProperty aProperty) const;
 
     /**
+     * A set of slightly more typesafe helpers for the above.  All
+     * return null if the value is not present.
+     */
+    const nsCSSValue* ValueStorageFor(nsCSSProperty aProperty) const {
+      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
+                        "type mismatch");
+      return static_cast<const nsCSSValue*>(StorageFor(aProperty));
+    }
+    const nsCSSRect* RectStorageFor(nsCSSProperty aProperty) const {
+      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Rect,
+                        "type mismatch");
+      return static_cast<const nsCSSRect*>(StorageFor(aProperty));
+    }
+    const nsCSSValuePair* ValuePairStorageFor(nsCSSProperty aProperty) const {
+      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
+                          eCSSType_ValuePair,
+                        "type mismatch");
+      return static_cast<const nsCSSValuePair*>(StorageFor(aProperty));
+    }
+    const nsCSSValueList*const*
+    ValueListStorageFor(nsCSSProperty aProperty) const {
+      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
+                          eCSSType_ValueList,
+                        "type mismatch");
+      return static_cast<const nsCSSValueList*const*>(StorageFor(aProperty));
+    }
+    const nsCSSValuePairList*const*
+    ValuePairListStorageFor(nsCSSProperty aProperty) const {
+      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
+                          eCSSType_ValuePairList,
+                        "type mismatch");
+      return static_cast<const nsCSSValuePairList*const*>(
+               StorageFor(aProperty));
+    }
+
+    /**
      * Clone this block, or return null on out-of-memory.
      */
     nsCSSCompressedDataBlock* Clone() const;
 
     /**
      * Delete all the data stored in this block, and the block itself.
      */
     void Destroy();
diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -601,24 +601,20 @@ nsCSSDeclaration::GetValue(nsCSSProperty
       NS_ASSERTION(nsCSSProps::GetStringValue(subprops[0]).Find("-top") !=
                      kNotFound, "first subprop must be top");
       NS_ASSERTION(nsCSSProps::GetStringValue(subprops[1]).Find("-right") !=
                      kNotFound, "second subprop must be right");
       NS_ASSERTION(nsCSSProps::GetStringValue(subprops[2]).Find("-bottom") !=
                      kNotFound, "third subprop must be bottom");
       NS_ASSERTION(nsCSSProps::GetStringValue(subprops[3]).Find("-left") !=
                      kNotFound, "fourth subprop must be left");
-      const nsCSSValue &topValue =
-        *static_cast<const nsCSSValue*>(data->StorageFor(subprops[0]));
-      const nsCSSValue &rightValue =
-        *static_cast<const nsCSSValue*>(data->StorageFor(subprops[1]));
-      const nsCSSValue &bottomValue =
-        *static_cast<const nsCSSValue*>(data->StorageFor(subprops[2]));
-      const nsCSSValue &leftValue =
-        *static_cast<const nsCSSValue*>(data->StorageFor(subprops[3]));
+      const nsCSSValue &topValue = *data->ValueStorageFor(subprops[0]);
+      const nsCSSValue &rightValue = *data->ValueStorageFor(subprops[1]);
+      const nsCSSValue &bottomValue = *data->ValueStorageFor(subprops[2]);
+      const nsCSSValue &leftValue = *data->ValueStorageFor(subprops[3]);
       PRBool haveValue;
       haveValue = AppendCSSValueToString(subprops[0], topValue, aValue);
       NS_ASSERTION(haveValue, "should have bailed before");
       if (topValue != rightValue || topValue != leftValue ||
           topValue != bottomValue) {
         aValue.Append(PRUnichar(' '));
         haveValue = AppendCSSValueToString(subprops[1], rightValue, aValue);
         NS_ASSERTION(haveValue, "should have bailed before");
@@ -640,20 +636,20 @@ nsCSSDeclaration::GetValue(nsCSSProperty
       const nsCSSProperty* subprops =
         nsCSSProps::SubpropertyEntryFor(aProperty);
       NS_ASSERTION(nsCSSProps::kTypeTable[subprops[0]] == eCSSType_ValuePair &&
                    nsCSSProps::kTypeTable[subprops[1]] == eCSSType_ValuePair &&
                    nsCSSProps::kTypeTable[subprops[2]] == eCSSType_ValuePair &&
                    nsCSSProps::kTypeTable[subprops[3]] == eCSSType_ValuePair,
                    "type mismatch");
       const nsCSSValuePair* vals[4] = {
-        static_cast<const nsCSSValuePair*>(data->StorageFor(subprops[0])),
-        static_cast<const nsCSSValuePair*>(data->StorageFor(subprops[1])),
-        static_cast<const nsCSSValuePair*>(data->StorageFor(subprops[2])),
-        static_cast<const nsCSSValuePair*>(data->StorageFor(subprops[3]))
+        data->ValuePairStorageFor(subprops[0]),
+        data->ValuePairStorageFor(subprops[1]),
+        data->ValuePairStorageFor(subprops[2]),
+        data->ValuePairStorageFor(subprops[3])
       };
 
       AppendCSSValueToString(aProperty, vals[0]->mXValue, aValue);
       aValue.Append(PRUnichar(' '));
       AppendCSSValueToString(aProperty, vals[1]->mXValue, aValue);
       aValue.Append(PRUnichar(' '));
       AppendCSSValueToString(aProperty, vals[2]->mXValue, aValue);
       aValue.Append(PRUnichar(' '));
@@ -683,21 +679,20 @@ nsCSSDeclaration::GetValue(nsCSSProperty
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_width)
       };
       PRBool match = PR_TRUE;
       for (const nsCSSProperty** subprops = subproptables,
                **subprops_end = subproptables + NS_ARRAY_LENGTH(subproptables);
            subprops < subprops_end; ++subprops) {
         // Check only the first four subprops in each table, since the
         // others are extras for dimensional box properties.
-        const nsCSSValue *firstSide =
-          static_cast<const nsCSSValue*>(data->StorageFor((*subprops)[0]));
+        const nsCSSValue *firstSide = data->ValueStorageFor((*subprops)[0]);
         for (PRInt32 side = 1; side < 4; ++side) {
           const nsCSSValue *otherSide =
-            static_cast<const nsCSSValue*>(data->StorageFor((*subprops)[side]));
+            data->ValueStorageFor((*subprops)[side]);
           if (*firstSide != *otherSide)
             match = PR_FALSE;
         }
       }
       if (!match) {
         // We can't express what we have in the border shorthand
         break;
       }
@@ -718,18 +713,17 @@ nsCSSDeclaration::GetValue(nsCSSProperty
                    nsCSSProps::kTypeTable[subprops[1]] == eCSSType_Value &&
                    nsCSSProps::kTypeTable[subprops[2]] == eCSSType_Value,
                    "type mismatch");
       NS_ASSERTION(StringEndsWith(nsCSSProps::GetStringValue(subprops[2]),
                                   NS_LITERAL_CSTRING("-color")) ||
                    StringEndsWith(nsCSSProps::GetStringValue(subprops[2]),
                                   NS_LITERAL_CSTRING("-color-value")),
                    "third subprop must be the color property");
-      const nsCSSValue *colorValue =
-        static_cast<const nsCSSValue*>(data->StorageFor(subprops[2]));
+      const nsCSSValue *colorValue = data->ValueStorageFor(subprops[2]);
       PRBool isMozUseTextColor =
         colorValue->GetUnit() == eCSSUnit_Enumerated &&
         colorValue->GetIntValue() == NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR;
       if (!AppendValueToString(subprops[0], aValue) ||
           !(aValue.Append(PRUnichar(' ')),
             AppendValueToString(subprops[1], aValue)) ||
           // Don't output a third value when it's -moz-use-text-color.
           !(isMozUseTextColor ||
@@ -819,34 +813,34 @@ nsCSSDeclaration::GetValue(nsCSSProperty
         if (!AppendValueToString(eCSSProperty_cue_after, aValue))
           aValue.Truncate();
       }
       break;
     }
     case eCSSProperty_font: {
       // systemFont might not be present; the others are guaranteed to be
       // based on the shorthand check at the beginning of the function
-      const nsCSSValue *systemFont = static_cast<const nsCSSValue*>(
-        data->StorageFor(eCSSProperty__x_system_font));
-      const nsCSSValue &style = *static_cast<const nsCSSValue*>(
-        data->StorageFor(eCSSProperty_font_style));
-      const nsCSSValue &variant = *static_cast<const nsCSSValue*>(
-        data->StorageFor(eCSSProperty_font_variant));
-      const nsCSSValue &weight = *static_cast<const nsCSSValue*>(
-        data->StorageFor(eCSSProperty_font_weight));
-      const nsCSSValue &size = *static_cast<const nsCSSValue*>(
-        data->StorageFor(eCSSProperty_font_size));
-      const nsCSSValue &lh = *static_cast<const nsCSSValue*>(
-        data->StorageFor(eCSSProperty_line_height));
-      const nsCSSValue &family = *static_cast<const nsCSSValue*>(
-        data->StorageFor(eCSSProperty_font_family));
-      const nsCSSValue &stretch = *static_cast<const nsCSSValue*>(
-        data->StorageFor(eCSSProperty_font_stretch));
-      const nsCSSValue &sizeAdjust = *static_cast<const nsCSSValue*>(
-        data->StorageFor(eCSSProperty_font_size_adjust));
+      const nsCSSValue *systemFont =
+        data->ValueStorageFor(eCSSProperty__x_system_font);
+      const nsCSSValue &style =
+        *data->ValueStorageFor(eCSSProperty_font_style);
+      const nsCSSValue &variant =
+        *data->ValueStorageFor(eCSSProperty_font_variant);
+      const nsCSSValue &weight =
+        *data->ValueStorageFor(eCSSProperty_font_weight);
+      const nsCSSValue &size =
+        *data->ValueStorageFor(eCSSProperty_font_size);
+      const nsCSSValue &lh =
+        *data->ValueStorageFor(eCSSProperty_line_height);
+      const nsCSSValue &family =
+        *data->ValueStorageFor(eCSSProperty_font_family);
+      const nsCSSValue &stretch =
+        *data->ValueStorageFor(eCSSProperty_font_stretch);
+      const nsCSSValue &sizeAdjust =
+        *data->ValueStorageFor(eCSSProperty_font_size_adjust);
 
       if (systemFont &&
           systemFont->GetUnit() != eCSSUnit_None &&
           systemFont->GetUnit() != eCSSUnit_Null) {
         if (style.GetUnit() != eCSSUnit_System_Font ||
             variant.GetUnit() != eCSSUnit_System_Font ||
             weight.GetUnit() != eCSSUnit_System_Font ||
             size.GetUnit() != eCSSUnit_System_Font ||
@@ -893,40 +887,40 @@ nsCSSDeclaration::GetValue(nsCSSProperty
     case eCSSProperty_list_style:
       if (AppendValueToString(eCSSProperty_list_style_type, aValue))
         aValue.Append(PRUnichar(' '));
       if (AppendValueToString(eCSSProperty_list_style_position, aValue))
         aValue.Append(PRUnichar(' '));
       AppendValueToString(eCSSProperty_list_style_image, aValue);
       break;
     case eCSSProperty_overflow: {
-      const nsCSSValue &xValue = *static_cast<const nsCSSValue*>(
-        data->StorageFor(eCSSProperty_overflow_x));
-      const nsCSSValue &yValue = *static_cast<const nsCSSValue*>(
-        data->StorageFor(eCSSProperty_overflow_y));
+      const nsCSSValue &xValue =
+        *data->ValueStorageFor(eCSSProperty_overflow_x);
+      const nsCSSValue &yValue =
+        *data->ValueStorageFor(eCSSProperty_overflow_y);
       if (xValue == yValue)
         AppendCSSValueToString(eCSSProperty_overflow_x, xValue, aValue);
       break;
     }
     case eCSSProperty_pause: {
       if (AppendValueToString(eCSSProperty_pause_before, aValue)) {
         aValue.Append(PRUnichar(' '));
         if (!AppendValueToString(eCSSProperty_pause_after, aValue))
           aValue.Truncate();
       }
       break;
     }
 #ifdef MOZ_SVG
     case eCSSProperty_marker: {
-      const nsCSSValue &endValue = *static_cast<const nsCSSValue*>(
-        data->StorageFor(eCSSProperty_marker_end));
-      const nsCSSValue &midValue = *static_cast<const nsCSSValue*>(
-        data->StorageFor(eCSSProperty_marker_mid));
-      const nsCSSValue &startValue = *static_cast<const nsCSSValue*>(
-        data->StorageFor(eCSSProperty_marker_start));
+      const nsCSSValue &endValue =
+        *data->ValueStorageFor(eCSSProperty_marker_end);
+      const nsCSSValue &midValue =
+        *data->ValueStorageFor(eCSSProperty_marker_mid);
+      const nsCSSValue &startValue =
+        *data->ValueStorageFor(eCSSProperty_marker_start);
       if (endValue == midValue && midValue == startValue)
         AppendValueToString(eCSSProperty_marker_end, aValue);
       break;
     }
 #endif
     default:
       NS_NOTREACHED("no other shorthands");
       break;
@@ -996,18 +990,18 @@ nsCSSDeclaration::AppendPropertyAndValue
   aResult.AppendLiteral("; ");
 }
 
 nsresult
 nsCSSDeclaration::ToString(nsAString& aString) const
 {
   nsCSSCompressedDataBlock *systemFontData =
     GetValueIsImportant(eCSSProperty__x_system_font) ? mImportantData : mData;
-  const nsCSSValue *systemFont = static_cast<const nsCSSValue*>(
-    systemFontData->StorageFor(eCSSProperty__x_system_font));
+  const nsCSSValue *systemFont = 
+    systemFontData->ValueStorageFor(eCSSProperty__x_system_font);
   const PRBool haveSystemFont = systemFont &&
                                 systemFont->GetUnit() != eCSSUnit_None &&
                                 systemFont->GetUnit() != eCSSUnit_Null;
   PRBool didSystemFont = PR_FALSE;
 
   PRInt32 count = mOrder.Length();
   PRInt32 index;
   nsAutoTArray<nsCSSProperty, 16> shorthandsUsed;
@@ -1065,18 +1059,18 @@ nsCSSDeclaration::ToString(nsAString& aS
         }
 
         // That we output the system font is enough for this property if:
         //   (1) it's the hidden system font subproperty, or
         //   (2) its value is the hidden system font value and it matches
         //       the hidden system font subproperty in importance.
         NS_ASSERTION(nsCSSProps::kTypeTable[property] == eCSSType_Value,
                      "not a value typed subproperty");
-        const nsCSSValue *val = static_cast<const nsCSSValue*>(
-          systemFontData->StorageFor(property));
+        const nsCSSValue *val =
+          systemFontData->ValueStorageFor(property);
         if (property == eCSSProperty__x_system_font ||
             (val && val->GetUnit() == eCSSUnit_System_Font)) {
           doneProperty = PR_TRUE;
         }
       }
     }
     if (doneProperty)
       continue;
