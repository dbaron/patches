From: L. David Baron <dbaron@dbaron.org>

Bug 1221436 patch 3 - Remove Rule::SetHTMLCSSStyleSheet and related code, now unused.

This was made unused by patch 2.

diff --git a/layout/style/Rule.h b/layout/style/Rule.h
--- a/layout/style/Rule.h
+++ b/layout/style/Rule.h
@@ -28,17 +28,17 @@ class GroupRule;
 #define DECL_STYLE_RULE_INHERIT                            \
   DECL_STYLE_RULE_INHERIT_NO_DOMRULE                       \
   virtual nsIDOMCSSRule* GetDOMRule() override;        \
   virtual nsIDOMCSSRule* GetExistingDOMRule() override;
 
 class Rule : public nsISupports {
 protected:
   Rule(uint32_t aLineNumber, uint32_t aColumnNumber)
-    : mSheet(0),
+    : mSheet(nullptr),
       mParentRule(nullptr),
       mLineNumber(aLineNumber),
       mColumnNumber(aColumnNumber)
   {
   }
 
   Rule(const Rule& aCopy)
     : mSheet(aCopy.mSheet),
@@ -75,30 +75,26 @@ public:
     DOCUMENT_RULE,
     SUPPORTS_RULE,
     FONT_FEATURE_VALUES_RULE,
     COUNTER_STYLE_RULE
   };
 
   virtual int32_t GetType() const = 0;
 
-  CSSStyleSheet* GetStyleSheet() const;
-  nsHTMLCSSStyleSheet* GetHTMLCSSStyleSheet() const;
+  CSSStyleSheet* GetStyleSheet() const { return mSheet; }
 
   // Return the document the rule lives in, if any
   nsIDocument* GetDocument() const
   {
     CSSStyleSheet* sheet = GetStyleSheet();
     return sheet ? sheet->GetDocument() : nullptr;
   }
 
   virtual void SetStyleSheet(CSSStyleSheet* aSheet);
-  // This does not need to be virtual, because GroupRule and MediaRule are not
-  // used for inline style.
-  void SetHTMLCSSStyleSheet(nsHTMLCSSStyleSheet* aSheet);
 
   void SetParentRule(GroupRule* aRule) {
     // We don't reference count this up reference. The group rule
     // will tell us when it's going away or when we're detached from
     // it.
     mParentRule = aRule;
   }
 
@@ -128,19 +124,18 @@ public:
     const MOZ_MUST_OVERRIDE = 0;
 
   // This is used to measure nsCOMArray<Rule>s.
   static size_t SizeOfCOMArrayElementIncludingThis(css::Rule* aElement,
                                                    mozilla::MallocSizeOf aMallocSizeOf,
                                                    void* aData);
 
 protected:
-  // This is either a CSSStyleSheet* or an nsHTMLStyleSheet*.  The former
-  // if the low bit is 0, the latter if the low bit is 1.
-  uintptr_t         mSheet;
+  // This is sometimes null (e.g., for style attributes).
+  CSSStyleSheet*    mSheet;
   // When the parent GroupRule is destroyed, it will call SetParentRule(nullptr)
   // on this object. (Through SetParentRuleReference);
   GroupRule* MOZ_NON_OWNING_REF mParentRule;
 
   // Keep the same type so that MSVC packs them.
   uint32_t          mLineNumber;
   uint32_t          mColumnNumber;
 };
diff --git a/layout/style/nsCSSRules.cpp b/layout/style/nsCSSRules.cpp
--- a/layout/style/nsCSSRules.cpp
+++ b/layout/style/nsCSSRules.cpp
@@ -50,53 +50,23 @@ using namespace mozilla::dom;
 #define IMPL_STYLE_RULE_INHERIT(class_, super_) \
 IMPL_STYLE_RULE_INHERIT_GET_DOM_RULE_WEAK(class_, super_)
 
 // base class for all rule types in a CSS style sheet
 
 namespace mozilla {
 namespace css {
 
-CSSStyleSheet*
-Rule::GetStyleSheet() const
-{
-  if (!(mSheet & 0x1)) {
-    return reinterpret_cast<CSSStyleSheet*>(mSheet);
-  }
-
-  return nullptr;
-}
-
-nsHTMLCSSStyleSheet*
-Rule::GetHTMLCSSStyleSheet() const
-{
-  if (mSheet & 0x1) {
-    return reinterpret_cast<nsHTMLCSSStyleSheet*>(mSheet & ~uintptr_t(0x1));
-  }
-
-  return nullptr;
-}
-
 /* virtual */ void
 Rule::SetStyleSheet(CSSStyleSheet* aSheet)
 {
   // We don't reference count this up reference. The style sheet
   // will tell us when it's going away or when we're detached from
   // it.
-  mSheet = reinterpret_cast<uintptr_t>(aSheet);
-}
-
-void
-Rule::SetHTMLCSSStyleSheet(nsHTMLCSSStyleSheet* aSheet)
-{
-  // We don't reference count this up reference. The style sheet
-  // will tell us when it's going away or when we're detached from
-  // it.
-  mSheet = reinterpret_cast<uintptr_t>(aSheet);
-  mSheet |= 0x1;
+  mSheet = aSheet;
 }
 
 nsresult
 Rule::GetParentRule(nsIDOMCSSRule** aParentRule)
 {
   if (mParentRule) {
     NS_IF_ADDREF(*aParentRule = mParentRule->GetDOMRule());
   } else {
