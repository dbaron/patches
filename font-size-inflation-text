From: L. David Baron <dbaron@dbaron.org>

Apply font size inflation to text.  (Bug 627842, patch 3)

This applies the font size inflation to reflow and painting of text
frames.  However, it does not (by design) apply to intrinsic width
computation, since the inflation is itself a function of the containers
width, which can depend on the intrinsic width.

diff --git a/layout/generic/nsLineLayout.h b/layout/generic/nsLineLayout.h
--- a/layout/generic/nsLineLayout.h
+++ b/layout/generic/nsLineLayout.h
@@ -363,16 +363,19 @@ public:
   }
 
   /**
    * This can't be null. It usually returns a block frame but may return
    * some other kind of frame when inline frames are reflowed in a non-block
    * context (e.g. MathML or floating first-letter).
    */
   nsIFrame* GetLineContainerFrame() const { return mBlockReflowState->frame; }
+  const nsHTMLReflowState* GetLineContainerRS() const {
+    return mBlockReflowState;
+  }
   const nsLineList::iterator* GetLine() const {
     return GetFlag(LL_GOTLINEBOX) ? &mLineBox : nsnull;
   }
   nsLineList::iterator* GetLine() {
     return GetFlag(LL_GOTLINEBOX) ? &mLineBox : nsnull;
   }
   
   /**
diff --git a/layout/generic/nsTextFrame.h b/layout/generic/nsTextFrame.h
--- a/layout/generic/nsTextFrame.h
+++ b/layout/generic/nsTextFrame.h
@@ -293,17 +293,17 @@ public:
                               PropertyProvider& aProvider,
                               nscoord aLeftEdge, nscoord aRightEdge,
                               PRUint32* aStartOffset, PRUint32* aMaxLength,
                               nscoord* aSnappedLeftEdge,
                               nscoord* aSnappedRightEdge);
   // primary frame paint method called from nsDisplayText
   // The private DrawText() is what applies the text to a graphics context
   void PaintText(nsRenderingContext* aRenderingContext, nsPoint aPt,
-                 const nsRect& aDirtyRect, const nsCharClipDisplayItem& aItem);
+                 nsRect& aDirtyRect, const nsCharClipDisplayItem& aItem);
   // helper: paint text frame when we're impacted by at least one selection.
   // Return false if the text was not painted and we should continue with
   // the fast path.
   bool PaintTextWithSelection(gfxContext* aCtx,
                               const gfxPoint& aFramePt,
                               const gfxPoint& aTextBaselinePt,
                               const gfxRect& aDirtyRect,
                               PropertyProvider& aProvider,
@@ -421,16 +421,17 @@ protected:
   // the frames always map the text node without overlapping or leaving any gaps.
   PRInt32     mContentOffset;
   // This does *not* indicate the length of text currently mapped by the frame;
   // instead it's a hint saying that this frame *wants* to map this much text
   // so if we create a new continuation, this is where that continuation should
   // start.
   PRInt32     mContentLengthHint;
   nscoord     mAscent;
+  float       mFontSizeInflation;
   gfxTextRun* mTextRun;
 
   // The caller of this method must call DestroySelectionDetails() on the
   // return value, if that return value is not null.  Calling
   // DestroySelectionDetails() on a null value is still OK, just not necessary.
   SelectionDetails* GetSelectionDetails();
 
   void UnionAdditionalOverflow(nsPresContext* aPresContext,
diff --git a/layout/generic/nsTextFrameThebes.cpp b/layout/generic/nsTextFrameThebes.cpp
--- a/layout/generic/nsTextFrameThebes.cpp
+++ b/layout/generic/nsTextFrameThebes.cpp
@@ -4265,17 +4265,17 @@ nsTextFrame::GetTextDecorations(nsPresCo
   bool useOverride = false;
   nscolor overrideColor;
 
   // frameTopOffset represents the offset to f's top from our baseline in our
   // coordinate space
   // baselineOffset represents the offset from our baseline to f's baseline or
   // the nearest block's baseline, in our coordinate space, whichever is closest
   // during the particular iteration
-  nscoord frameTopOffset = mAscent,
+  nscoord frameTopOffset = mAscent, // FIXME: wants uninflated
           baselineOffset = 0;
 
   bool nearestBlockFound = false;
 
   for (nsIFrame* f = this, *fChild = nsnull;
        f;
        fChild = f,
        f = nsLayoutUtils::GetParentOrPlaceholderFor(
@@ -4367,16 +4367,17 @@ nsTextFrame::GetTextDecorations(nsPresCo
       // absolutely-positioned element or a floating element, we're done.
       if (disp->IsFloating() || disp->IsAbsolutelyPositioned()) {
         break;
       }
     }
   }
 }
 
+// FIXME: inflation clearly incorrect in many ways
 void
 nsTextFrame::UnionAdditionalOverflow(nsPresContext* aPresContext,
                                      PropertyProvider& aProvider,
                                      nsRect* aVisualOverflowRect,
                                      bool aIncludeTextDecorations)
 {
   // Text-shadow overflows
   nsRect shadowRect =
@@ -5014,29 +5015,31 @@ nsTextFrame::PaintTextSelectionDecoratio
 
   gfxFloat startXOffset = aTextBaselinePt.x - aFramePt.x;
   SelectionIterator iterator(selectedChars, aContentOffset, aContentLength,
                              aProvider, mTextRun, startXOffset);
   gfxFloat xOffset, hyphenWidth;
   PRUint32 offset, length;
   PRInt32 app = aTextPaintStyle.PresContext()->AppUnitsPerDevPixel();
   // XXX aTextBaselinePt is in AppUnits, shouldn't it be nsFloatPoint?
+  // FIXME: wants uninflated mAscent
   gfxPoint pt(0.0, (aTextBaselinePt.y - mAscent) / app);
   gfxRect dirtyRect(aDirtyRect.x / app, aDirtyRect.y / app,
                     aDirtyRect.width / app, aDirtyRect.height / app);
   SelectionType type;
   nsTextRangeStyle selectedStyle;
   while (iterator.GetNextSegment(&xOffset, &offset, &length, &hyphenWidth,
                                  &type, &selectedStyle)) {
     gfxFloat advance = hyphenWidth +
       mTextRun->GetAdvanceWidth(offset, length, &aProvider);
     if (type == aSelectionType) {
       pt.x = (aFramePt.x + xOffset -
              (mTextRun->IsRightToLeft() ? advance : 0)) / app;
       gfxFloat width = NS_ABS(advance) / app;
+      // FIXME: wants uninflated mAscent
       DrawSelectionDecorations(aCtx, dirtyRect, aSelectionType, this, aTextPaintStyle,
                                selectedStyle,
                                pt, width, mAscent / app, decorationMetrics);
     }
     iterator.UpdateWithAdvance(advance);
   }
 }
 
@@ -5150,25 +5153,36 @@ nsTextFrame::MeasureCharClippedText(gfxC
 {
   // Don't pass in aRenderingContext here, because we need a *reference*
   // context and aRenderingContext might have some transform in it
   // XXX get the block and line passed to us somehow! This is slow!
   gfxSkipCharsIterator iter = EnsureTextRun();
   if (!mTextRun)
     return false;
 
+  float fontSizeInflation = mFontSizeInflation;
+  if (fontSizeInflation != 1.0f) {
+    aLeftEdge /= fontSizeInflation;
+    aRightEdge /= fontSizeInflation;
+  }
+
   PropertyProvider provider(this, iter);
   // Trim trailing whitespace
   provider.InitializeForDisplay(PR_TRUE);
 
   PRUint32 startOffset = provider.GetStart().GetSkippedOffset();
   PRUint32 maxLength = ComputeTransformedLength(provider);
-  return MeasureCharClippedText(aCtx, provider, aLeftEdge, aRightEdge,
-                                &startOffset, &maxLength,
-                                aSnappedLeftEdge, aSnappedRightEdge);
+  bool result = MeasureCharClippedText(aCtx, provider, aLeftEdge, aRightEdge,
+                                       &startOffset, &maxLength,
+                                       aSnappedLeftEdge, aSnappedRightEdge);
+  if (fontSizeInflation != 1.0f) {
+    *aSnappedLeftEdge *= fontSizeInflation;
+    *aSnappedRightEdge *= fontSizeInflation;
+  }
+  return result;
 }
 
 static PRUint32 GetClusterLength(gfxTextRun* aTextRun,
                                  PRUint32    aStartOffset,
                                  PRUint32    aMaxLength,
                                  bool        aIsRTL)
 {
   PRUint32 clusterLength = aIsRTL ? 0 : 1;
@@ -5244,34 +5258,45 @@ nsTextFrame::MeasureCharClippedText(gfxC
     *snappedEndEdge = NSToCoordFloor(gfxFloat(frameWidth) - advanceWidth);
   }
   *aMaxLength = maxLength;
   return maxLength != 0;
 }
 
 void
 nsTextFrame::PaintText(nsRenderingContext* aRenderingContext, nsPoint aPt,
-                       const nsRect& aDirtyRect,
+                       nsRect& aDirtyRect,
                        const nsCharClipDisplayItem& aItem)
 {
   // Don't pass in aRenderingContext here, because we need a *reference*
   // context and aRenderingContext might have some transform in it
   // XXX get the block and line passed to us somehow! This is slow!
   gfxSkipCharsIterator iter = EnsureTextRun();
   if (!mTextRun)
     return;
 
+  gfxContext* ctx = aRenderingContext->ThebesContext();
+
+  gfxContextMatrixAutoSaveRestore savematrix(ctx);
+  float fontSizeInflation = mFontSizeInflation;
+  if (fontSizeInflation != 1.0f) {
+    ctx->Scale(fontSizeInflation, fontSizeInflation);
+    aPt.x /= fontSizeInflation;
+    aPt.y /= fontSizeInflation;
+    aDirtyRect.ScaleRoundOut(1.0f / fontSizeInflation);
+  }
+
   PropertyProvider provider(this, iter);
   // Trim trailing whitespace
   provider.InitializeForDisplay(PR_TRUE);
 
-  gfxContext* ctx = aRenderingContext->ThebesContext();
   const bool rtl = mTextRun->IsRightToLeft();
   const nscoord frameWidth = GetSize().width;
   gfxPoint framePt(aPt.x, aPt.y);
+  // FIXME: wants uninflated mAscent
   gfxPoint textBaselinePt(rtl ? gfxFloat(aPt.x + frameWidth) : framePt.x,
              nsLayoutUtils::GetSnappedBaselineY(this, ctx, aPt.y, mAscent));
   PRUint32 startOffset = provider.GetStart().GetSkippedOffset();
   PRUint32 maxLength = ComputeTransformedLength(provider);
   nscoord snappedLeftEdge, snappedRightEdge;
   if (!MeasureCharClippedText(ctx, provider, aItem.mLeftEdge, aItem.mRightEdge,
          &startOffset, &maxLength, &snappedLeftEdge, &snappedRightEdge)) {
     return;
@@ -5360,16 +5385,17 @@ nsTextFrame::DrawTextRunAndDecorations(
 
     // XXX aFramePt is in AppUnits, shouldn't it be nsFloatPoint?
     nscoord x = NSToCoordRound(aFramePt.x);
     nscoord width = GetRect().width;
     aClipEdges.Intersect(&x, &width);
 
     gfxPoint decPt(x / app, 0);
     gfxSize decSize(width / app, 0);
+    // FIXME: wants uninflated mAscent
     const gfxFloat ascent = gfxFloat(mAscent) / app;
     const gfxFloat frameTop = aFramePt.y;
 
     gfxRect dirtyRect(aDirtyRect.x / app, aDirtyRect.y / app,
                       aDirtyRect.Width() / app, aDirtyRect.Height() / app);
 
     // Underlines
     for (PRUint32 i = aDecorations.mUnderlines.Length(); i-- > 0; ) {
@@ -5539,21 +5565,22 @@ nsIFrame::ContentOffsets
 nsTextFrame::GetCharacterOffsetAtFramePointInternal(const nsPoint &aPoint,
                                                     bool aForInsertionPoint)
 {
   ContentOffsets offsets;
   
   gfxSkipCharsIterator iter = EnsureTextRun();
   if (!mTextRun)
     return offsets;
-  
+
   PropertyProvider provider(this, iter);
   // Trim leading but not trailing whitespace if possible
   provider.InitializeForDisplay(PR_FALSE);
   gfxFloat width = mTextRun->IsRightToLeft() ? mRect.width - aPoint.x : aPoint.x;
+  width /= mFontSizeInflation;
   gfxFloat fitWidth;
   PRUint32 skippedLength = ComputeTransformedLength(provider);
 
   PRUint32 charsFit = CountCharsFit(mTextRun,
       provider.GetStart().GetSkippedOffset(), skippedLength, width, &provider, &fitWidth);
 
   PRInt32 selectedOffset;
   if (charsFit < skippedLength) {
@@ -5591,16 +5618,17 @@ nsTextFrame::GetCharacterOffsetAtFramePo
   }
 
   offsets.content = GetContent();
   offsets.offset = offsets.secondaryOffset = selectedOffset;
   offsets.associateWithNext = mContentOffset == offsets.offset;
   return offsets;
 }
 
+// FIXME: what's the right inflation?
 bool
 nsTextFrame::CombineSelectionUnderlineRect(nsPresContext* aPresContext,
                                            nsRect& aRect)
 {
   if (aRect.IsEmpty())
     return PR_FALSE;
 
   nsRect givenRect = aRect;
@@ -5608,16 +5636,17 @@ nsTextFrame::CombineSelectionUnderlineRe
   nsRefPtr<nsFontMetrics> fm;
   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
   gfxFontGroup* fontGroup = fm->GetThebesFontGroup();
   gfxFont* firstFont = fontGroup->GetFontAt(0);
   if (!firstFont)
     return PR_FALSE; // OOM
   const gfxFont::Metrics& metrics = firstFont->GetMetrics();
   gfxFloat underlineOffset = fontGroup->GetUnderlineOffset();
+  // FIXME: inflation and mAscent?
   gfxFloat ascent = aPresContext->AppUnitsToGfxUnits(mAscent);
   gfxFloat descentLimit =
     ComputeDescentLimitForSelectionUnderline(aPresContext, this, metrics);
 
   SelectionDetails *details = GetSelectionDetails();
   for (SelectionDetails *sd = details; sd; sd = sd->mNext) {
     if (sd->mStart == sd->mEnd || !(sd->mType & SelectionTypesWithDecorations))
       continue;
@@ -5802,17 +5831,17 @@ nsTextFrame::GetPointFromOffset(PRInt32 
     NS_WARNING("GetPointFromOffset called for non-cluster boundary");
     FindClusterStart(mTextRun, trimmedOffset, &iter);
   }
 
   gfxFloat advanceWidth =
     mTextRun->GetAdvanceWidth(properties.GetStart().GetSkippedOffset(),
                               GetSkippedDistance(properties.GetStart(), iter),
                               &properties);
-  nscoord width = NSToCoordCeilClamped(advanceWidth);
+  nscoord width = NSToCoordCeilClamped(advanceWidth * mFontSizeInflation);
 
   if (mTextRun->IsRightToLeft()) {
     outPoint->x = mRect.width - width;
   } else {
     outPoint->x = width;
   }
   outPoint->y = 0;
 
@@ -6648,16 +6677,17 @@ nsTextFrame::ComputeTightBounds(gfxConte
   // Trim trailing whitespace
   provider.InitializeForDisplay(PR_TRUE);
 
   gfxTextRun::Metrics metrics =
         mTextRun->MeasureText(provider.GetStart().GetSkippedOffset(),
                               ComputeTransformedLength(provider),
                               gfxFont::TIGHT_HINTED_OUTLINE_EXTENTS,
                               aContext, &provider);
+  metrics.mBoundingBox.Scale(mFontSizeInflation);
   // mAscent should be the same as metrics.mAscent, but it's what we use to
   // paint so that's the one we'll use.
   return RoundOut(metrics.mBoundingBox) + nsPoint(0, mAscent);
 }
 
 static bool
 HasSoftHyphenBefore(const nsTextFragment* aFrag, gfxTextRun* aTextRun,
                     PRInt32 aStartOffset, const gfxSkipCharsIterator& aIter)
@@ -7101,16 +7131,25 @@ nsTextFrame::ReflowText(nsLineLayout& aL
     (aLineLayout.GetCurrentFrameXDistanceFromBlock() -
        lineContainer->GetUsedBorderAndPadding().left)
     : -1;
   PropertyProvider provider(mTextRun, textStyle, frag, this, iter, length,
       lineContainer, xOffsetForTabs);
 
   PRUint32 transformedOffset = provider.GetStart().GetSkippedOffset();
 
+  // REVIEW: He're we're assuming that drawing text with a transform
+  // scales it up by exactly the scale in the transform.  Given hinting,
+  // is that a safe assumption?  (It drastically simplifies this code,
+  // since we don't need two different text runs to implement font size
+  // inflation.)
+  float fontSizeInflation =
+    nsLayoutUtils::FontSizeInflationFor(aLineLayout.GetLineContainerRS());
+  mFontSizeInflation = fontSizeInflation;
+
   // The metrics for the text go in here
   gfxTextRun::Metrics textMetrics;
   gfxFont::BoundingBoxType boundingBoxType = IsFloatingFirstLetterChild() ?
                                                gfxFont::TIGHT_HINTED_OUTLINE_EXTENTS :
                                                gfxFont::LOOSE_INK_EXTENTS;
   NS_ASSERTION(!(NS_REFLOW_CALC_BOUNDING_METRICS & aMetrics.mFlags),
                "We shouldn't be passed NS_REFLOW_CALC_BOUNDING_METRICS anymore");
 
@@ -7148,17 +7187,17 @@ nsTextFrame::ReflowText(nsLineLayout& aL
   gfxFloat availWidth = aAvailableWidth;
   bool canTrimTrailingWhitespace = !textStyle->WhiteSpaceIsSignificant();
   PRInt32 unusedOffset;  
   gfxBreakPriority breakPriority;
   aLineLayout.GetLastOptionalBreakPosition(&unusedOffset, &breakPriority);
   PRUint32 transformedCharsFit =
     mTextRun->BreakAndMeasureText(transformedOffset, transformedLength,
                                   (GetStateBits() & TEXT_START_OF_LINE) != 0,
-                                  availWidth,
+                                  availWidth / fontSizeInflation,
                                   &provider, !aLineLayout.LineIsBreakable(),
                                   canTrimTrailingWhitespace ? &trimmedWidth : nsnull,
                                   &textMetrics, boundingBoxType, ctx,
                                   &usedHyphenation, &transformedLastBreak,
                                   textStyle->WordCanWrap(), &breakPriority);
   if (!length && !textMetrics.mAscent && !textMetrics.mDescent) {
     // If we're measuring a zero-length piece of text, update
     // the height manually.
@@ -7229,16 +7268,24 @@ nsTextFrame::ReflowText(nsLineLayout& aL
       if (mTextRun->IsRightToLeft()) {
         // Space comes before text, so the bounding box is moved to the
         // right by trimmdWidth
         textMetrics.mBoundingBox.MoveBy(gfxPoint(trimmedWidth, 0));
       }
     }
   }
 
+  if (fontSizeInflation != 1.0) {
+    // REVIEW: bad to be multiplying all these doubles by a float?
+    textMetrics.mAdvanceWidth *= fontSizeInflation;
+    textMetrics.mAscent *= fontSizeInflation;
+    textMetrics.mDescent *= fontSizeInflation;
+    textMetrics.mBoundingBox.Scale(fontSizeInflation);
+  }
+
   if (!brokeText && lastBreak >= 0) {
     // Since everything fit and no break was forced,
     // record the last break opportunity
     NS_ASSERTION(textMetrics.mAdvanceWidth - trimmableWidth <= aAvailableWidth,
                  "If the text doesn't fit, and we have a break opportunity, why didn't MeasureText use it?");
     aLineLayout.NotifyOptionalBreakPosition(mContent, lastBreak, PR_TRUE, breakPriority);
   }
 
@@ -7498,17 +7545,18 @@ nsTextFrame::TrimTrailingWhiteSpace(nsRe
                           &advanceDelta, ctx);
   if (advanceDelta != 0) {
     result.mChanged = PR_TRUE;
   }
 
   // aDeltaWidth is *subtracted* from our width.
   // If advanceDelta is positive then setting the line break made us longer,
   // so aDeltaWidth could go negative.
-  result.mDeltaWidth = NSToCoordFloor(delta - advanceDelta);
+  result.mDeltaWidth = NSToCoordFloor((delta - advanceDelta) *
+                                      mFontSizeInflation);
   // If aDeltaWidth goes negative, that means this frame might not actually fit
   // anymore!!! We need higher level line layout to recover somehow.
   // If it's because the frame has a soft hyphen that is now being displayed,
   // this should actually be OK, because our reflow recorded the break
   // opportunity that allowed the soft hyphen to be used, and we wouldn't
   // have recorded the opportunity unless the hyphen fit (or was the first
   // opportunity on the line).
   // Otherwise this can/ really only happen when we have glyphs with special
@@ -7541,16 +7589,17 @@ nsTextFrame::RecomputeOverflow()
   PropertyProvider provider(this, iter);
   provider.InitializeForDisplay(PR_TRUE);
 
   gfxTextRun::Metrics textMetrics =
     mTextRun->MeasureText(provider.GetStart().GetSkippedOffset(),
                           ComputeTransformedLength(provider),
                           gfxFont::LOOSE_INK_EXTENTS, nsnull,
                           &provider);
+  textMetrics.mBoundingBox.Scale(mFontSizeInflation);
   nsRect &vis = result.VisualOverflow();
   vis.UnionRect(vis, RoundOut(textMetrics.mBoundingBox) + nsPoint(0, mAscent));
   UnionAdditionalOverflow(PresContext(), provider, &vis, true);
   return result;
 }
 static PRUnichar TransformChar(const nsStyleText* aStyle, gfxTextRun* aTextRun,
                                PRUint32 aSkippedOffset, PRUnichar aChar)
 {
