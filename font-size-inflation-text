From: L. David Baron <dbaron@dbaron.org>

Apply font size inflation to text.  (Bug 627842, patch 3)

FIXME: Lots of issues with nsTextFrame::mAscent!

diff --git a/layout/generic/nsLineLayout.h b/layout/generic/nsLineLayout.h
--- a/layout/generic/nsLineLayout.h
+++ b/layout/generic/nsLineLayout.h
@@ -363,16 +363,19 @@ public:
   }
 
   /**
    * This can't be null. It usually returns a block frame but may return
    * some other kind of frame when inline frames are reflowed in a non-block
    * context (e.g. MathML or floating first-letter).
    */
   nsIFrame* GetLineContainerFrame() const { return mBlockReflowState->frame; }
+  const nsHTMLReflowState* GetLineContainerRS() const {
+    return mBlockReflowState;
+  }
   const nsLineList::iterator* GetLine() const {
     return GetFlag(LL_GOTLINEBOX) ? &mLineBox : nsnull;
   }
   nsLineList::iterator* GetLine() {
     return GetFlag(LL_GOTLINEBOX) ? &mLineBox : nsnull;
   }
   
   /**
diff --git a/layout/generic/nsTextFrame.h b/layout/generic/nsTextFrame.h
--- a/layout/generic/nsTextFrame.h
+++ b/layout/generic/nsTextFrame.h
@@ -293,17 +293,17 @@ public:
                               PropertyProvider& aProvider,
                               nscoord aLeftEdge, nscoord aRightEdge,
                               PRUint32* aStartOffset, PRUint32* aMaxLength,
                               nscoord* aSnappedLeftEdge,
                               nscoord* aSnappedRightEdge);
   // primary frame paint method called from nsDisplayText
   // The private DrawText() is what applies the text to a graphics context
   void PaintText(nsRenderingContext* aRenderingContext, nsPoint aPt,
-                 const nsRect& aDirtyRect, const nsCharClipDisplayItem& aItem);
+                 nsRect& aDirtyRect, const nsCharClipDisplayItem& aItem);
   // helper: paint text frame when we're impacted by at least one selection.
   // Return false if the text was not painted and we should continue with
   // the fast path.
   bool PaintTextWithSelection(gfxContext* aCtx,
                               const gfxPoint& aFramePt,
                               const gfxPoint& aTextBaselinePt,
                               const gfxRect& aDirtyRect,
                               PropertyProvider& aProvider,
@@ -421,16 +421,17 @@ protected:
   // the frames always map the text node without overlapping or leaving any gaps.
   PRInt32     mContentOffset;
   // This does *not* indicate the length of text currently mapped by the frame;
   // instead it's a hint saying that this frame *wants* to map this much text
   // so if we create a new continuation, this is where that continuation should
   // start.
   PRInt32     mContentLengthHint;
   nscoord     mAscent;
+  float       mFontSizeInflation;
   gfxTextRun* mTextRun;
 
   // The caller of this method must call DestroySelectionDetails() on the
   // return value, if that return value is not null.  Calling
   // DestroySelectionDetails() on a null value is still OK, just not necessary.
   SelectionDetails* GetSelectionDetails();
 
   void UnionAdditionalOverflow(nsPresContext* aPresContext,
diff --git a/layout/generic/nsTextFrameThebes.cpp b/layout/generic/nsTextFrameThebes.cpp
--- a/layout/generic/nsTextFrameThebes.cpp
+++ b/layout/generic/nsTextFrameThebes.cpp
@@ -5150,25 +5150,36 @@ nsTextFrame::MeasureCharClippedText(gfxC
 {
   // Don't pass in aRenderingContext here, because we need a *reference*
   // context and aRenderingContext might have some transform in it
   // XXX get the block and line passed to us somehow! This is slow!
   gfxSkipCharsIterator iter = EnsureTextRun();
   if (!mTextRun)
     return false;
 
+  float fontSizeInflation = mFontSizeInflation;
+  if (fontSizeInflation != 1.0f) {
+    aLeftEdge /= fontSizeInflation;
+    aRightEdge /= fontSizeInflation;
+  }
+
   PropertyProvider provider(this, iter);
   // Trim trailing whitespace
   provider.InitializeForDisplay(PR_TRUE);
 
   PRUint32 startOffset = provider.GetStart().GetSkippedOffset();
   PRUint32 maxLength = ComputeTransformedLength(provider);
-  return MeasureCharClippedText(aCtx, provider, aLeftEdge, aRightEdge,
-                                &startOffset, &maxLength,
-                                aSnappedLeftEdge, aSnappedRightEdge);
+  bool result = MeasureCharClippedText(aCtx, provider, aLeftEdge, aRightEdge,
+                                       &startOffset, &maxLength,
+                                       aSnappedLeftEdge, aSnappedRightEdge);
+  if (fontSizeInflation != 1.0f) {
+    *aSnappedLeftEdge *= fontSizeInflation;
+    *aSnappedRightEdge *= fontSizeInflation;
+  }
+  return result;
 }
 
 static PRUint32 GetClusterLength(gfxTextRun* aTextRun,
                                  PRUint32    aStartOffset,
                                  PRUint32    aMaxLength,
                                  bool        aIsRTL)
 {
   PRUint32 clusterLength = aIsRTL ? 0 : 1;
@@ -5244,31 +5255,41 @@ nsTextFrame::MeasureCharClippedText(gfxC
     *snappedEndEdge = NSToCoordFloor(gfxFloat(frameWidth) - advanceWidth);
   }
   *aMaxLength = maxLength;
   return maxLength != 0;
 }
 
 void
 nsTextFrame::PaintText(nsRenderingContext* aRenderingContext, nsPoint aPt,
-                       const nsRect& aDirtyRect,
+                       nsRect& aDirtyRect,
                        const nsCharClipDisplayItem& aItem)
 {
   // Don't pass in aRenderingContext here, because we need a *reference*
   // context and aRenderingContext might have some transform in it
   // XXX get the block and line passed to us somehow! This is slow!
   gfxSkipCharsIterator iter = EnsureTextRun();
   if (!mTextRun)
     return;
 
+  gfxContext* ctx = aRenderingContext->ThebesContext();
+
+  gfxContextMatrixAutoSaveRestore savematrix(ctx);
+  float fontSizeInflation = mFontSizeInflation;
+  if (fontSizeInflation != 1.0f) {
+    ctx->Scale(fontSizeInflation, fontSizeInflation);
+    aPt.x /= fontSizeInflation;
+    aPt.y /= fontSizeInflation;
+    aDirtyRect.ScaleRoundOut(1.0f / fontSizeInflation);
+  }
+
   PropertyProvider provider(this, iter);
   // Trim trailing whitespace
   provider.InitializeForDisplay(PR_TRUE);
 
-  gfxContext* ctx = aRenderingContext->ThebesContext();
   const bool rtl = mTextRun->IsRightToLeft();
   const nscoord frameWidth = GetSize().width;
   gfxPoint framePt(aPt.x, aPt.y);
   gfxPoint textBaselinePt(rtl ? gfxFloat(aPt.x + frameWidth) : framePt.x,
              nsLayoutUtils::GetSnappedBaselineY(this, ctx, aPt.y, mAscent));
   PRUint32 startOffset = provider.GetStart().GetSkippedOffset();
   PRUint32 maxLength = ComputeTransformedLength(provider);
   nscoord snappedLeftEdge, snappedRightEdge;
@@ -5539,21 +5560,22 @@ nsIFrame::ContentOffsets
 nsTextFrame::GetCharacterOffsetAtFramePointInternal(const nsPoint &aPoint,
                                                     bool aForInsertionPoint)
 {
   ContentOffsets offsets;
   
   gfxSkipCharsIterator iter = EnsureTextRun();
   if (!mTextRun)
     return offsets;
-  
+
   PropertyProvider provider(this, iter);
   // Trim leading but not trailing whitespace if possible
   provider.InitializeForDisplay(PR_FALSE);
   gfxFloat width = mTextRun->IsRightToLeft() ? mRect.width - aPoint.x : aPoint.x;
+  width /= mFontSizeInflation;
   gfxFloat fitWidth;
   PRUint32 skippedLength = ComputeTransformedLength(provider);
 
   PRUint32 charsFit = CountCharsFit(mTextRun,
       provider.GetStart().GetSkippedOffset(), skippedLength, width, &provider, &fitWidth);
 
   PRInt32 selectedOffset;
   if (charsFit < skippedLength) {
@@ -5802,17 +5824,17 @@ nsTextFrame::GetPointFromOffset(PRInt32 
     NS_WARNING("GetPointFromOffset called for non-cluster boundary");
     FindClusterStart(mTextRun, trimmedOffset, &iter);
   }
 
   gfxFloat advanceWidth =
     mTextRun->GetAdvanceWidth(properties.GetStart().GetSkippedOffset(),
                               GetSkippedDistance(properties.GetStart(), iter),
                               &properties);
-  nscoord width = NSToCoordCeilClamped(advanceWidth);
+  nscoord width = NSToCoordCeilClamped(advanceWidth * mFontSizeInflation);
 
   if (mTextRun->IsRightToLeft()) {
     outPoint->x = mRect.width - width;
   } else {
     outPoint->x = width;
   }
   outPoint->y = 0;
 
@@ -6648,16 +6670,17 @@ nsTextFrame::ComputeTightBounds(gfxConte
   // Trim trailing whitespace
   provider.InitializeForDisplay(PR_TRUE);
 
   gfxTextRun::Metrics metrics =
         mTextRun->MeasureText(provider.GetStart().GetSkippedOffset(),
                               ComputeTransformedLength(provider),
                               gfxFont::TIGHT_HINTED_OUTLINE_EXTENTS,
                               aContext, &provider);
+  metrics.mBoundingBox.Scale(mFontSizeInflation);
   // mAscent should be the same as metrics.mAscent, but it's what we use to
   // paint so that's the one we'll use.
   return RoundOut(metrics.mBoundingBox) + nsPoint(0, mAscent);
 }
 
 static bool
 HasSoftHyphenBefore(const nsTextFragment* aFrag, gfxTextRun* aTextRun,
                     PRInt32 aStartOffset, const gfxSkipCharsIterator& aIter)
@@ -7101,16 +7124,25 @@ nsTextFrame::ReflowText(nsLineLayout& aL
     (aLineLayout.GetCurrentFrameXDistanceFromBlock() -
        lineContainer->GetUsedBorderAndPadding().left)
     : -1;
   PropertyProvider provider(mTextRun, textStyle, frag, this, iter, length,
       lineContainer, xOffsetForTabs);
 
   PRUint32 transformedOffset = provider.GetStart().GetSkippedOffset();
 
+  // REVIEW: He're we're assuming that drawing text with a transform
+  // scales it up by exactly the scale in the transform.  Given hinting,
+  // is that a safe assumption?  (It drastically simplifies this code,
+  // since we don't need two different text runs to implement font size
+  // inflation.)
+  float fontSizeInflation =
+    nsLayoutUtils::FontSizeInflationFor(aLineLayout.GetLineContainerRS());
+  mFontSizeInflation = fontSizeInflation;
+
   // The metrics for the text go in here
   gfxTextRun::Metrics textMetrics;
   gfxFont::BoundingBoxType boundingBoxType = IsFloatingFirstLetterChild() ?
                                                gfxFont::TIGHT_HINTED_OUTLINE_EXTENTS :
                                                gfxFont::LOOSE_INK_EXTENTS;
   NS_ASSERTION(!(NS_REFLOW_CALC_BOUNDING_METRICS & aMetrics.mFlags),
                "We shouldn't be passed NS_REFLOW_CALC_BOUNDING_METRICS anymore");
 
@@ -7148,17 +7180,17 @@ nsTextFrame::ReflowText(nsLineLayout& aL
   gfxFloat availWidth = aAvailableWidth;
   bool canTrimTrailingWhitespace = !textStyle->WhiteSpaceIsSignificant();
   PRInt32 unusedOffset;  
   gfxBreakPriority breakPriority;
   aLineLayout.GetLastOptionalBreakPosition(&unusedOffset, &breakPriority);
   PRUint32 transformedCharsFit =
     mTextRun->BreakAndMeasureText(transformedOffset, transformedLength,
                                   (GetStateBits() & TEXT_START_OF_LINE) != 0,
-                                  availWidth,
+                                  availWidth / fontSizeInflation,
                                   &provider, !aLineLayout.LineIsBreakable(),
                                   canTrimTrailingWhitespace ? &trimmedWidth : nsnull,
                                   &textMetrics, boundingBoxType, ctx,
                                   &usedHyphenation, &transformedLastBreak,
                                   textStyle->WordCanWrap(), &breakPriority);
   if (!length && !textMetrics.mAscent && !textMetrics.mDescent) {
     // If we're measuring a zero-length piece of text, update
     // the height manually.
@@ -7229,16 +7261,24 @@ nsTextFrame::ReflowText(nsLineLayout& aL
       if (mTextRun->IsRightToLeft()) {
         // Space comes before text, so the bounding box is moved to the
         // right by trimmdWidth
         textMetrics.mBoundingBox.MoveBy(gfxPoint(trimmedWidth, 0));
       }
     }
   }
 
+  if (fontSizeInflation != 1.0) {
+    // REVIEW: bad to be multiplying all these doubles by a float?
+    textMetrics.mAdvanceWidth *= fontSizeInflation;
+    textMetrics.mAscent *= fontSizeInflation;
+    textMetrics.mDescent *= fontSizeInflation;
+    textMetrics.mBoundingBox.Scale(fontSizeInflation);
+  }
+
   if (!brokeText && lastBreak >= 0) {
     // Since everything fit and no break was forced,
     // record the last break opportunity
     NS_ASSERTION(textMetrics.mAdvanceWidth - trimmableWidth <= aAvailableWidth,
                  "If the text doesn't fit, and we have a break opportunity, why didn't MeasureText use it?");
     aLineLayout.NotifyOptionalBreakPosition(mContent, lastBreak, PR_TRUE, breakPriority);
   }
 
@@ -7498,17 +7538,18 @@ nsTextFrame::TrimTrailingWhiteSpace(nsRe
                           &advanceDelta, ctx);
   if (advanceDelta != 0) {
     result.mChanged = PR_TRUE;
   }
 
   // aDeltaWidth is *subtracted* from our width.
   // If advanceDelta is positive then setting the line break made us longer,
   // so aDeltaWidth could go negative.
-  result.mDeltaWidth = NSToCoordFloor(delta - advanceDelta);
+  result.mDeltaWidth = NSToCoordFloor((delta - advanceDelta) *
+                                      mFontSizeInflation);
   // If aDeltaWidth goes negative, that means this frame might not actually fit
   // anymore!!! We need higher level line layout to recover somehow.
   // If it's because the frame has a soft hyphen that is now being displayed,
   // this should actually be OK, because our reflow recorded the break
   // opportunity that allowed the soft hyphen to be used, and we wouldn't
   // have recorded the opportunity unless the hyphen fit (or was the first
   // opportunity on the line).
   // Otherwise this can/ really only happen when we have glyphs with special
@@ -7541,16 +7582,17 @@ nsTextFrame::RecomputeOverflow()
   PropertyProvider provider(this, iter);
   provider.InitializeForDisplay(PR_TRUE);
 
   gfxTextRun::Metrics textMetrics =
     mTextRun->MeasureText(provider.GetStart().GetSkippedOffset(),
                           ComputeTransformedLength(provider),
                           gfxFont::LOOSE_INK_EXTENTS, nsnull,
                           &provider);
+  textMetrics.mBoundingBox.Scale(mFontSizeInflation);
   nsRect &vis = result.VisualOverflow();
   vis.UnionRect(vis, RoundOut(textMetrics.mBoundingBox) + nsPoint(0, mAscent));
   UnionAdditionalOverflow(PresContext(), provider, &vis, true);
   return result;
 }
 static PRUnichar TransformChar(const nsStyleText* aStyle, gfxTextRun* aTextRun,
                                PRUint32 aSkippedOffset, PRUnichar aChar)
 {
