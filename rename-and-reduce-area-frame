Stop using nsAreaFrame for anything other than xul:label, which is the only thing for which it does anything different from nsBlockFrame, and rename it accordingly.  (Bug 471356)

diff --git a/content/base/src/nsGkAtomList.h b/content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h
+++ b/content/base/src/nsGkAtomList.h
@@ -1477,17 +1477,16 @@ GK_ATOM(cdataTagName, "#cdata-section")
 GK_ATOM(commentTagName, "#comment")
 GK_ATOM(documentNodeName, "#document")
 GK_ATOM(documentFragmentNodeName, "#document-fragment")
 GK_ATOM(documentTypeNodeName, "#document-type")
 GK_ATOM(processingInstructionTagName, "#processing-instruction")
 GK_ATOM(textTagName, "#text")
 
 // Frame types
-GK_ATOM(areaFrame, "AreaFrame")
 GK_ATOM(bcTableCellFrame, "BCTableCellFrame") // table cell in border collapsing model
 GK_ATOM(blockFrame, "BlockFrame")
 GK_ATOM(boxFrame, "BoxFrame")
 GK_ATOM(brFrame, "BRFrame")
 GK_ATOM(bulletFrame, "BulletFrame")
 GK_ATOM(columnSetFrame, "ColumnSetFrame")
 GK_ATOM(comboboxControlFrame, "ComboboxControlFrame")
 GK_ATOM(comboboxDisplayFrame, "ComboboxDisplayFrame")
@@ -1530,16 +1529,19 @@ GK_ATOM(tableColFrame, "TableColFrame")
 GK_ATOM(tableColGroupFrame, "TableColGroupFrame")
 GK_ATOM(tableFrame, "TableFrame")
 GK_ATOM(tableOuterFrame, "TableOuterFrame")
 GK_ATOM(tableRowGroupFrame, "TableRowGroupFrame")
 GK_ATOM(tableRowFrame, "TableRowFrame")
 GK_ATOM(textInputFrame,"TextInputFrame")
 GK_ATOM(textFrame, "TextFrame")
 GK_ATOM(viewportFrame, "ViewportFrame")
+#ifdef MOZ_XUL
+GK_ATOM(XULLabelFrame, "XULLabelFrame")
+#endif
 #ifdef MOZ_SVG
 GK_ATOM(svgAFrame, "SVGAFrame")
 GK_ATOM(svgClipPathFrame, "SVGClipPathFrame")
 GK_ATOM(svgDefsFrame, "SVGDefsFrame")
 GK_ATOM(svgFilterFrame, "SVGFilterFrame")
 GK_ATOM(svgForeignObjectFrame, "SVGForeignObjectFrame")
 GK_ATOM(svgGenericContainerFrame, "SVGGenericContainerFrame")
 GK_ATOM(svgGFrame, "SVGGFrame")
diff --git a/content/xul/content/src/nsXULElement.cpp b/content/xul/content/src/nsXULElement.cpp
--- a/content/xul/content/src/nsXULElement.cpp
+++ b/content/xul/content/src/nsXULElement.cpp
@@ -1337,17 +1337,17 @@ nsXULElement::UnsetAttr(PRInt32 aNameSpa
         if ((aName == nsGkAtoms::activetitlebarcolor ||
              aName == nsGkAtoms::inactivetitlebarcolor) &&
             doc && doc->GetRootContent() == this) {
             // Use 0, 0, 0, 0 as the "none" color.
             SetTitlebarColor(NS_RGBA(0, 0, 0, 0), aName == nsGkAtoms::activetitlebarcolor);
         }
 
         // If the accesskey attribute is removed, unregister it here
-        // Also see nsAreaFrame, nsBoxFrame and nsTextBoxFrame's AttributeChanged
+        // Also see nsXULLabelFrame, nsBoxFrame and nsTextBoxFrame's AttributeChanged
         if (aName == nsGkAtoms::accesskey || aName == nsGkAtoms::control) {
             UnregisterAccessKey(oldValue);
         }
 
         // Check to see if the OBSERVES attribute is being unset.  If so, we
         // need to remove our broadcaster goop completely.
         if (doc && (aName == nsGkAtoms::observes ||
                           aName == nsGkAtoms::command)) {
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -394,17 +394,17 @@ SVG_GetFirstNonAAncestorFrame(nsIFrame *
       return ancestorFrame;
     }
   }
   return nsnull;
 }
 #endif
 
 static inline nsIFrame*
-GetFieldSetAreaFrame(nsIFrame* aFieldsetFrame)
+GetFieldSetBlockFrame(nsIFrame* aFieldsetFrame)
 {
   // Depends on the fieldset child frame order - see ConstructFieldSetFrame() below.
   nsIFrame* firstChild = aFieldsetFrame->GetFirstChild(nsnull);
   return firstChild && firstChild->GetNextSibling() ? firstChild->GetNextSibling() : firstChild;
 }
 
 //----------------------------------------------------------------------
 
@@ -4818,77 +4818,78 @@ nsCSSFrameConstructor::ConstructButtonFr
 
   
   
   nsRefPtr<nsStyleContext> styleContext;
   styleContext = mPresShell->StyleSet()->ResolvePseudoStyleFor(aContent,
                                                                nsCSSAnonBoxes::buttonContent,
                                                                aStyleContext);
                                                                
-  nsIFrame* areaFrame = NS_NewAreaFrame(mPresShell, styleContext,
-                                        NS_BLOCK_SPACE_MGR);
-
-  if (NS_UNLIKELY(!areaFrame)) {
+  nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, styleContext,
+                                          NS_BLOCK_SPACE_MGR);
+
+  if (NS_UNLIKELY(!blockFrame)) {
     buttonFrame->Destroy();
     return NS_ERROR_OUT_OF_MEMORY;
   }
-  rv = InitAndRestoreFrame(aState, aContent, buttonFrame, nsnull, areaFrame);
+  rv = InitAndRestoreFrame(aState, aContent, buttonFrame, nsnull, blockFrame);
   if (NS_FAILED(rv)) {
-    areaFrame->Destroy();
+    blockFrame->Destroy();
     buttonFrame->Destroy();
     return rv;
   }
 
   rv = aState.AddChild(buttonFrame, aFrameItems, aContent, aStyleContext,
                        aParentFrame);
   if (NS_FAILED(rv)) {
-    areaFrame->Destroy();
+    blockFrame->Destroy();
     buttonFrame->Destroy();
     return rv;
   }
 
   
   if (!buttonFrame->IsLeaf()) { 
     // input type="button" have only anonymous content
     // The area frame is a float container
     PRBool haveFirstLetterStyle, haveFirstLineStyle;
     ShouldHaveSpecialBlockStyle(aContent, aStyleContext,
                                 &haveFirstLetterStyle, &haveFirstLineStyle);
     nsFrameConstructorSaveState floatSaveState;
-    aState.PushFloatContainingBlock(areaFrame, floatSaveState,
+    aState.PushFloatContainingBlock(blockFrame, floatSaveState,
                                     haveFirstLetterStyle,
                                     haveFirstLineStyle);
 
     // Process children
     nsFrameConstructorSaveState absoluteSaveState;
     nsFrameItems                childItems;
 
     if (aStyleDisplay->IsPositioned()) {
       // The area frame becomes a container for child frames that are
       // absolutely positioned
-      aState.PushAbsoluteContainingBlock(areaFrame, absoluteSaveState);
-    }
-
-    rv = ProcessChildren(aState, aContent, areaFrame, PR_TRUE, childItems,
+      aState.PushAbsoluteContainingBlock(blockFrame, absoluteSaveState);
+    }
+
+    rv = ProcessChildren(aState, aContent, blockFrame, PR_TRUE, childItems,
                          buttonFrame->GetStyleDisplay()->IsBlockOutside());
     if (NS_FAILED(rv)) return rv;
   
     // Set the areas frame's initial child lists
-    areaFrame->SetInitialChildList(nsnull, childItems.childList);
-  }
-
-  buttonFrame->SetInitialChildList(nsnull, areaFrame);
+    blockFrame->SetInitialChildList(nsnull, childItems.childList);
+  }
+
+  buttonFrame->SetInitialChildList(nsnull, blockFrame);
 
   nsFrameItems  anonymousChildItems;
   // if there are any anonymous children create frames for them
   CreateAnonymousFrames(aTag, aState, aContent, buttonFrame,
                           PR_FALSE, anonymousChildItems);
   if (anonymousChildItems.childList) {
     // the anonymous content is already parented to the area frame
-    aState.mFrameManager->AppendFrames(areaFrame, nsnull, anonymousChildItems.childList);
+    aState.mFrameManager->AppendFrames(blockFrame, nsnull,
+                                       anonymousChildItems.childList);
   }
 
   // our new button frame returned is the top frame. 
   *aNewFrame = buttonFrame; 
 
   return NS_OK;  
 }
 
@@ -5159,47 +5160,48 @@ nsCSSFrameConstructor::ConstructFieldSet
   nsHTMLContainerFrame::CreateViewForFrame(newFrame, aParentFrame, PR_FALSE);
 
   // Resolve style and initialize the frame
   nsRefPtr<nsStyleContext> styleContext;
   styleContext = mPresShell->StyleSet()->ResolvePseudoStyleFor(aContent,
                                                                nsCSSAnonBoxes::fieldsetContent,
                                                                aStyleContext);
   
-  nsIFrame* areaFrame = NS_NewAreaFrame(mPresShell, styleContext,
-                                     NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT);
-  InitAndRestoreFrame(aState, aContent, newFrame, nsnull, areaFrame);
+  nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, styleContext,
+                                          NS_BLOCK_SPACE_MGR |
+                                          NS_BLOCK_MARGIN_ROOT);
+  InitAndRestoreFrame(aState, aContent, newFrame, nsnull, blockFrame);
 
   nsresult rv = aState.AddChild(newFrame, aFrameItems, aContent, aStyleContext,
                                 aParentFrame);
   if (NS_FAILED(rv)) {
     return rv;
   }
   
 
   // The area frame is a float container
   PRBool haveFirstLetterStyle, haveFirstLineStyle;
   ShouldHaveSpecialBlockStyle(aContent, aStyleContext,
                               &haveFirstLetterStyle, &haveFirstLineStyle);
   nsFrameConstructorSaveState floatSaveState;
-  aState.PushFloatContainingBlock(areaFrame, floatSaveState,
+  aState.PushFloatContainingBlock(blockFrame, floatSaveState,
                                   haveFirstLetterStyle,
                                   haveFirstLineStyle);
 
   // Process children
   nsFrameConstructorSaveState absoluteSaveState;
   nsFrameItems                childItems;
 
   if (aStyleDisplay->IsPositioned()) {
     // The area frame becomes a container for child frames that are
     // absolutely positioned
-    aState.PushAbsoluteContainingBlock(areaFrame, absoluteSaveState);
-  }
-
-  ProcessChildren(aState, aContent, areaFrame, PR_TRUE,
+    aState.PushAbsoluteContainingBlock(blockFrame, absoluteSaveState);
+  }
+
+  ProcessChildren(aState, aContent, blockFrame, PR_TRUE,
                   childItems, PR_TRUE);
 
   static NS_DEFINE_IID(kLegendFrameCID, NS_LEGEND_FRAME_CID);
   nsIFrame * child      = childItems.childList;
   nsIFrame * previous   = nsnull;
   nsIFrame* legendFrame = nsnull;
   while (nsnull != child) {
     nsresult result = child->QueryInterface(kLegendFrameCID, (void**)&legendFrame);
@@ -5209,29 +5211,29 @@ nsCSSFrameConstructor::ConstructFieldSet
       // from a selection point within the legend (bug 236071), which is
       // used for implementing legend access keys (bug 81481).
       // GetAdjustedParentFrame() below depends on this frame order.
       if (nsnull != previous) {
         previous->SetNextSibling(legendFrame->GetNextSibling());
       } else {
         childItems.childList = legendFrame->GetNextSibling();
       }
-      legendFrame->SetNextSibling(areaFrame);
+      legendFrame->SetNextSibling(blockFrame);
       legendFrame->SetParent(newFrame);
       break;
     }
     previous = child;
     child = child->GetNextSibling();
   }
 
   // Set the scrolled frame's initial child lists
-  areaFrame->SetInitialChildList(nsnull, childItems.childList);
+  blockFrame->SetInitialChildList(nsnull, childItems.childList);
 
   // Set the scroll frame's initial child list
-  newFrame->SetInitialChildList(nsnull, legendFrame ? legendFrame : areaFrame);
+  newFrame->SetInitialChildList(nsnull, legendFrame ? legendFrame : blockFrame);
 
   // our new frame returned is the top frame which is the list frame. 
   aNewFrame = newFrame; 
 
   // yes we have already initialized our frame 
   aFrameHasBeenInitialized = PR_TRUE; 
 
   return NS_OK;
@@ -5880,18 +5882,25 @@ nsCSSFrameConstructor::ConstructXULFrame
       }
       // TEXT CONSTRUCTION
       else if (aTag == nsGkAtoms::text || aTag == nsGkAtoms::label ||
                aTag == nsGkAtoms::description) {
         if ((aTag == nsGkAtoms::label || aTag == nsGkAtoms::description) && 
             (! aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::value))) {
           // XXX we should probably be calling ConstructBlock here to handle
           // things like columns etc
-          newFrame = NS_NewAreaFrame(mPresShell, aStyleContext,
-                                     NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT);
+          if (aTag == nsGkAtoms::label) {
+            newFrame = NS_NewXULLabelFrame(mPresShell, aStyleContext,
+                                           NS_BLOCK_SPACE_MGR |
+                                           NS_BLOCK_MARGIN_ROOT);
+          } else {
+            newFrame = NS_NewBlockFrame(mPresShell, aStyleContext,
+                                        NS_BLOCK_SPACE_MGR |
+                                        NS_BLOCK_MARGIN_ROOT);
+          }
         }
         else {
           newFrame = NS_NewTextBoxFrame(mPresShell, aStyleContext);
         }
       }
       // End of TEXT CONSTRUCTION logic
 
        // Menu Construction    
@@ -6165,17 +6174,17 @@ nsCSSFrameConstructor::ConstructXULFrame
       
       /*
       // if our parent is a block frame then do things the way html likes it
       // if not then we are in a box so do what boxes like. On example is boxes
       // do not support the absolute positioning of their children. While html blocks
       // that's why we call different things here.
       nsIAtom* frameType = geometricParent->GetType();
       if ((frameType == nsGkAtoms::blockFrame) ||
-          (frameType == nsGkAtoms::areaFrame)) {
+          (frameType == nsGkAtoms::XULLabelFrame)) {
       */
         // See if we need to create a view, e.g. the frame is absolutely positioned
         nsHTMLContainerFrame::CreateViewForFrame(newFrame, aParentFrame, PR_FALSE);
 
       /*
       } else {
           // we are in a box so do the box thing.
         nsBoxFrame::CreateViewForFrame(aState.mPresContext, newFrame,
@@ -6452,18 +6461,18 @@ nsCSSFrameConstructor::ConstructFrameByD
                                  aState.GetGeometricParent(aDisplay, aParentFrame),
                                  aParentFrame,
                                  nsCSSAnonBoxes::scrolledContent,
                                  PR_FALSE, newFrame);
     
     // Initialize it
     // pass a temporary stylecontext, the correct one will be set later
     nsIFrame* scrolledFrame =
-        NS_NewAreaFrame(mPresShell, aStyleContext,
-                        NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT);
+        NS_NewBlockFrame(mPresShell, aStyleContext,
+                         NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT);
 
     nsFrameItems blockItem;
     rv = ConstructBlock(aState,
                         scrolledContentStyle->GetStyleDisplay(), aContent,
                         newFrame, newFrame, scrolledContentStyle,
                         &scrolledFrame, blockItem, aDisplay->IsPositioned());
     NS_ASSERTION(blockItem.childList == scrolledFrame,
                  "Scrollframe's frameItems should be exactly the scrolled frame");
@@ -7733,24 +7742,26 @@ nsCSSFrameConstructor::GetAbsoluteContai
     // positioned child frames.
     const nsStyleDisplay* disp = frame->GetStyleDisplay();
 
     if (disp->IsPositioned() && !IsTableRelated(disp->mDisplay, PR_TRUE)) {
       // Find the outermost wrapped block under this frame
       for (nsIFrame* wrappedFrame = aFrame; wrappedFrame != frame->GetParent();
            wrappedFrame = wrappedFrame->GetParent()) {
         nsIAtom* frameType = wrappedFrame->GetType();
-        if (nsGkAtoms::areaFrame == frameType ||
-            nsGkAtoms::blockFrame == frameType ||
+        if (nsGkAtoms::blockFrame == frameType ||
+#ifdef MOZ_XUL
+            nsGkAtoms::XULLabelFrame == frameType ||
+#endif
             nsGkAtoms::positionedInlineFrame == frameType) {
           containingBlock = wrappedFrame;
         } else if (nsGkAtoms::fieldSetFrame == frameType) {
           // If the positioned frame is a fieldset, use the area frame inside it.
           // We don't use GetContentInsertionFrame for fieldsets yet.
-          containingBlock = GetFieldSetAreaFrame(wrappedFrame);
+          containingBlock = GetFieldSetBlockFrame(wrappedFrame);
         }
       }
 
 #ifdef DEBUG
       if (!containingBlock)
         NS_WARNING("Positioned frame that does not handle positioned kids; looking further up the parent chain");
 #endif
     }
@@ -8156,17 +8167,17 @@ nsCSSFrameConstructor::IsValidSibling(ns
       return (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == aDisplay) ||
              (NS_STYLE_DISPLAY_TABLE_ROW_GROUP    == aDisplay) ||
              (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == aDisplay) ||
              (NS_STYLE_DISPLAY_TABLE_CAPTION      == aDisplay);
     }
   }
   else if (nsGkAtoms::fieldSetFrame == parentType ||
            (nsGkAtoms::fieldSetFrame == grandparentType &&
-            nsGkAtoms::areaFrame == parentType)) {
+            nsGkAtoms::blockFrame == parentType)) {
     // Legends can be sibling of legends but not of other content in the fieldset
     nsIAtom* sibType = aSibling->GetType();
     nsCOMPtr<nsIDOMHTMLLegendElement> legendContent(do_QueryInterface(aContent));
 
     if ((legendContent  && (nsGkAtoms::legendFrame != sibType)) ||
         (!legendContent && (nsGkAtoms::legendFrame == sibType)))
       return PR_FALSE;
   }
@@ -8338,17 +8349,17 @@ GetAdjustedParentFrame(nsIFrame*       a
   nsIContent *childContent = aParentContent->GetChildAt(aChildIndex);
   nsIFrame* newParent = nsnull;
 
   if (nsGkAtoms::fieldSetFrame == aParentFrameType) {
     // If the parent is a fieldSet, use the fieldSet's area frame as the
     // parent unless the new content is a legend. 
     nsCOMPtr<nsIDOMHTMLLegendElement> legendContent(do_QueryInterface(childContent));
     if (!legendContent) {
-      newParent = GetFieldSetAreaFrame(aParentFrame);
+      newParent = GetFieldSetBlockFrame(aParentFrame);
     }
   }
   return (newParent) ? newParent : aParentFrame;
 }
 
 static void
 InvalidateCanvasIfNeeded(nsIFrame* aFrame);
 
@@ -10406,25 +10417,26 @@ nsCSSFrameConstructor::CreateContinuingF
     newFrame = NS_NewBlockFrame(shell, styleContext);
 
     if (newFrame) {
       newFrame->Init(content, aParentFrame, aFrame);
       // XXXbz should we be passing in a non-null aContentParentFrame?
       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
     }
   
-  } else if (nsGkAtoms::areaFrame == frameType) {
-    newFrame = NS_NewAreaFrame(shell, styleContext, 0);
+#ifdef MOZ_XUL
+  } else if (nsGkAtoms::XULLabelFrame == frameType) {
+    newFrame = NS_NewXULLabelFrame(shell, styleContext, 0);
 
     if (newFrame) {
       newFrame->Init(content, aParentFrame, aFrame);
       // XXXbz should we be passing in a non-null aContentParentFrame?
       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
     }
-  
+#endif  
   } else if (nsGkAtoms::columnSetFrame == frameType) {
     newFrame = NS_NewColumnSetFrame(shell, styleContext, 0);
 
     if (newFrame) {
       newFrame->Init(content, aParentFrame, aFrame);
       // XXXbz should we be passing in a non-null aContentParentFrame?
       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
     }
@@ -10500,18 +10512,18 @@ nsCSSFrameConstructor::CreateContinuingF
 
     if (newFrame) {
       newFrame->Init(content, aParentFrame, aFrame);
       // XXXbz should we be passing in a non-null aContentParentFrame?
       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
 
       // Create a continuing area frame
       nsIFrame* continuingAreaFrame;
-      nsIFrame* areaFrame = aFrame->GetFirstChild(nsnull);
-      rv = CreateContinuingFrame(aPresContext, areaFrame, newFrame,
+      nsIFrame* blockFrame = aFrame->GetFirstChild(nsnull);
+      rv = CreateContinuingFrame(aPresContext, blockFrame, newFrame,
                                  &continuingAreaFrame);
       if (NS_FAILED(rv)) {
         newFrame->Destroy();
         *aContinuingFrame = nsnull;
         return rv;
       }
 
       // Set the table cell's initial child list
@@ -10572,18 +10584,18 @@ nsCSSFrameConstructor::CreateContinuingF
       newFrame->Init(content, aParentFrame, aFrame);
 
       // XXXbz should we be passing in a non-null aContentParentFrame?
       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
 
       // Create a continuing area frame
       // XXXbz we really shouldn't have to do this by hand!
       nsIFrame* continuingAreaFrame;
-      nsIFrame* areaFrame = GetFieldSetAreaFrame(aFrame);
-      rv = CreateContinuingFrame(aPresContext, areaFrame, newFrame,
+      nsIFrame* blockFrame = GetFieldSetBlockFrame(aFrame);
+      rv = CreateContinuingFrame(aPresContext, blockFrame, newFrame,
                                  &continuingAreaFrame);
       if (NS_FAILED(rv)) {
         newFrame->Destroy();
         *aContinuingFrame = nsnull;
         return rv;
       }
       // Set the fieldset's initial child list
       newFrame->SetInitialChildList(nsnull, continuingAreaFrame);
diff --git a/layout/forms/nsComboboxControlFrame.cpp b/layout/forms/nsComboboxControlFrame.cpp
--- a/layout/forms/nsComboboxControlFrame.cpp
+++ b/layout/forms/nsComboboxControlFrame.cpp
@@ -259,17 +259,17 @@ static PRInt32 gReflowInx = -1;
 #define PX(__v) __v 
 #endif
 
 //------------------------------------------------------
 //-- Done with macros
 //------------------------------------------------------
 
 nsComboboxControlFrame::nsComboboxControlFrame(nsStyleContext* aContext)
-  : nsAreaFrame(aContext),
+  : nsBlockFrame(aContext),
     mDisplayWidth(0)
 {
   mListControlFrame            = nsnull;
   mDroppedDown                 = PR_FALSE;
   mDisplayFrame                = nsnull;
   mButtonFrame                 = nsnull;
   mDropdownFrame               = nsnull;
 
@@ -311,17 +311,17 @@ nsComboboxControlFrame::QueryInterface(c
   } else if (aIID.Equals(NS_GET_IID(nsIRollupListener))) {
     *aInstancePtr = static_cast<nsIRollupListener*>(this);
     return NS_OK;
   } else if (aIID.Equals(NS_GET_IID(nsIScrollableViewProvider))) {
     *aInstancePtr = static_cast<nsIScrollableViewProvider*>(this);
     return NS_OK;
   } 
   
-  return nsAreaFrame::QueryInterface(aIID, aInstancePtr);
+  return nsBlockFrame::QueryInterface(aIID, aInstancePtr);
 }
 
 #ifdef ACCESSIBILITY
 NS_IMETHODIMP nsComboboxControlFrame::GetAccessible(nsIAccessible** aAccessible)
 {
   nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
 
   if (accService) {
@@ -684,17 +684,17 @@ nsComboboxControlFrame::Reflow(nsPresCon
                                            aReflowState.rendContext).LeftRight();
     if (buttonWidth > aReflowState.ComputedWidth()) {
       buttonWidth = 0;
     }
   }
 
   mDisplayWidth = aReflowState.ComputedWidth() - buttonWidth;
 
-  nsresult rv = nsAreaFrame::Reflow(aPresContext, aDesiredSize, aReflowState,
+  nsresult rv = nsBlockFrame::Reflow(aPresContext, aDesiredSize, aReflowState,
                                     aStatus);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Now set the correct width and height on our button.  The width we need to
   // set always, the height only if we had an auto height.
   nsRect buttonRect = mButtonFrame->GetRect();
   // If we have a non-intrinsic computed height, our kids should have sized
   // themselves properly on their own.
@@ -963,17 +963,17 @@ nsComboboxControlFrame::HandleEvent(nsPr
   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::disabled)) {
     return NS_OK;
   }
 
   // If we have style that affects how we are selected, feed event down to
   // nsFrame::HandleEvent so that selection takes place when appropriate.
   const nsStyleUserInterface* uiStyle = GetStyleUserInterface();
   if (uiStyle->mUserInput == NS_STYLE_USER_INPUT_NONE || uiStyle->mUserInput == NS_STYLE_USER_INPUT_DISABLED)
-    return nsAreaFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
+    return nsBlockFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
     
   return NS_OK;
 }
 
 
 nsresult
 nsComboboxControlFrame::SetFormProperty(nsIAtom* aName, const nsAString& aValue)
 {
@@ -1240,38 +1240,38 @@ nsComboboxControlFrame::Destroy()
       }
     }
   }
 
   // Cleanup frames in popup child list
   mPopupFrames.DestroyFrames();
   nsContentUtils::DestroyAnonymousContent(&mDisplayContent);
   nsContentUtils::DestroyAnonymousContent(&mButtonContent);
-  nsAreaFrame::Destroy();
+  nsBlockFrame::Destroy();
 }
 
 
 nsIFrame*
 nsComboboxControlFrame::GetFirstChild(nsIAtom* aListName) const
 {
   if (nsGkAtoms::selectPopupList == aListName) {
     return mPopupFrames.FirstChild();
   }
-  return nsAreaFrame::GetFirstChild(aListName);
+  return nsBlockFrame::GetFirstChild(aListName);
 }
 
 NS_IMETHODIMP
 nsComboboxControlFrame::SetInitialChildList(nsIAtom*        aListName,
                                             nsIFrame*       aChildList)
 {
   nsresult rv = NS_OK;
   if (nsGkAtoms::selectPopupList == aListName) {
     mPopupFrames.SetFrames(aChildList);
   } else {
-    rv = nsAreaFrame::SetInitialChildList(aListName, aChildList);
+    rv = nsBlockFrame::SetInitialChildList(aListName, aChildList);
 
     for (nsIFrame * child = aChildList; child;
          child = child->GetNextSibling()) {
       nsCOMPtr<nsIFormControl> formControl = do_QueryInterface(child->GetContent());
       if (formControl && formControl->GetType() == NS_FORM_INPUT_BUTTON) {
         mButtonFrame = child;
         break;
       }
@@ -1286,17 +1286,17 @@ nsComboboxControlFrame::SetInitialChildL
 nsIAtom*
 nsComboboxControlFrame::GetAdditionalChildListName(PRInt32 aIndex) const
 {
    // Maintain a separate child list for the dropdown list (i.e. popup listbox)
    // This is necessary because we don't want the listbox to be included in the layout
    // of the combox's children because it would take up space, when it is suppose to
    // be floating above the display.
   if (aIndex < NS_BLOCK_LIST_COUNT) {
-    return nsAreaFrame::GetAdditionalChildListName(aIndex);
+    return nsBlockFrame::GetAdditionalChildListName(aIndex);
   }
   
   if (NS_COMBO_FRAME_POPUP_LIST_INDEX == aIndex) {
     return nsGkAtoms::selectPopupList;
   }
   return nsnull;
 }
 
@@ -1375,17 +1375,17 @@ nsComboboxControlFrame::BuildDisplayList
   if (aBuilder->IsForEventDelivery()) {
     // Don't allow children to receive events.
     // REVIEW: following old GetFrameForPoint
     nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
     NS_ENSURE_SUCCESS(rv, rv);
   } else {
     // REVIEW: Our in-flow child frames are inline-level so they will paint in our
     // content list, so we don't need to mess with layers.
-    nsresult rv = nsAreaFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
+    nsresult rv = nsBlockFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   nsPresContext *presContext = PresContext();
   const nsStyleDisplay *disp = GetStyleDisplay();
   if ((!IsThemed(disp) ||
        !presContext->GetTheme()->ThemeDrawsFocusForWidget(presContext, this, disp->mAppearance)) &&
       mDisplayFrame && IsVisibleForPainting(aBuilder)) {
diff --git a/layout/forms/nsComboboxControlFrame.h b/layout/forms/nsComboboxControlFrame.h
--- a/layout/forms/nsComboboxControlFrame.h
+++ b/layout/forms/nsComboboxControlFrame.h
@@ -50,17 +50,17 @@
 //#define DO_UNCONSTRAINED_CHECK
 //#define DO_PIXELS
 //#define DO_NEW_REFLOW
 #endif
 
 //Mark used to indicate when onchange has been fired for current combobox item
 #define NS_SKIP_NOTIFY_INDEX -2
 
-#include "nsAreaFrame.h"
+#include "nsBlockFrame.h"
 #include "nsIFormControlFrame.h"
 #include "nsIComboboxControlFrame.h"
 #include "nsIAnonymousContentCreator.h"
 #include "nsISelectControlFrame.h"
 #include "nsIRollupListener.h"
 #include "nsPresState.h"
 #include "nsCSSFrameConstructor.h"
 #include "nsIScrollableViewProvider.h"
@@ -75,17 +75,17 @@ class nsIScrollableView;
 class nsComboboxDisplayFrame;
 
 /**
  * Child list name indices
  * @see #GetAdditionalChildListName()
  */
 #define NS_COMBO_LIST_COUNT   (NS_BLOCK_LIST_COUNT + 1)
 
-class nsComboboxControlFrame : public nsAreaFrame,
+class nsComboboxControlFrame : public nsBlockFrame,
                                public nsIFormControlFrame,
                                public nsIComboboxControlFrame,
                                public nsIAnonymousContentCreator,
                                public nsISelectControlFrame,
                                public nsIRollupListener,
                                public nsIScrollableViewProvider,
                                public nsIStatefulFrame
 {
@@ -128,17 +128,17 @@ public:
 
   // XXXbz this is only needed to prevent the quirk percent height stuff from
   // leaking out of the combobox.  We may be able to get rid of this as more
   // things move to IsFrameOfType.
   virtual nsIAtom* GetType() const;
 
   virtual PRBool IsFrameOfType(PRUint32 aFlags) const
   {
-    return nsAreaFrame::IsFrameOfType(aFlags &
+    return nsBlockFrame::IsFrameOfType(aFlags &
       ~(nsIFrame::eReplaced | nsIFrame::eReplacedContainsBlock));
   }
 
 #ifdef NS_DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const;
 #endif
   virtual void Destroy();
   virtual nsIFrame* GetFirstChild(nsIAtom* aListName) const;
diff --git a/layout/forms/nsFileControlFrame.cpp b/layout/forms/nsFileControlFrame.cpp
--- a/layout/forms/nsFileControlFrame.cpp
+++ b/layout/forms/nsFileControlFrame.cpp
@@ -83,17 +83,17 @@
 
 nsIFrame*
 NS_NewFileControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 {
   return new (aPresShell) nsFileControlFrame(aContext);
 }
 
 nsFileControlFrame::nsFileControlFrame(nsStyleContext* aContext):
-  nsAreaFrame(aContext),
+  nsBlockFrame(aContext),
   mTextFrame(nsnull), 
   mCachedState(nsnull)
 {
 }
 
 nsFileControlFrame::~nsFileControlFrame()
 {
   if (mCachedState) {
@@ -102,17 +102,17 @@ nsFileControlFrame::~nsFileControlFrame(
   }
 }
 
 NS_IMETHODIMP
 nsFileControlFrame::Init(nsIContent* aContent,
                          nsIFrame*   aParent,
                          nsIFrame*   aPrevInFlow)
 {
-  nsresult rv = nsAreaFrame::Init(aContent, aParent, aPrevInFlow);
+  nsresult rv = nsBlockFrame::Init(aContent, aParent, aPrevInFlow);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mMouseListener = new MouseListener(this);
   NS_ENSURE_TRUE(mMouseListener, NS_ERROR_OUT_OF_MEMORY);
 
   return rv;
 }
 
@@ -138,17 +138,17 @@ nsFileControlFrame::Destroy()
     do_QueryInterface(mTextContent);
   if (dom3TextContent) {
     dom3TextContent->RemoveGroupedEventListener(click, mMouseListener, PR_FALSE,
                                                 systemGroup);
     nsContentUtils::DestroyAnonymousContent(&mTextContent);
   }
 
   mMouseListener->ForgetFrame();
-  nsAreaFrame::Destroy();
+  nsBlockFrame::Destroy();
 }
 
 nsresult
 nsFileControlFrame::CreateAnonymousContent(nsTArray<nsIContent*>& aElements)
 {
   // Get the NodeInfoManager and tag necessary to create input elements
   nsCOMPtr<nsIDocument> doc = mContent->GetDocument();
 
@@ -238,17 +238,17 @@ nsFileControlFrame::QueryInterface(const
     *aInstancePtr = static_cast<nsIAnonymousContentCreator*>(this);
     return NS_OK;
   }
   if (aIID.Equals(NS_GET_IID(nsIFormControlFrame))) {
     *aInstancePtr = static_cast<nsIFormControlFrame*>(this);
     return NS_OK;
   }
 
-  return nsAreaFrame::QueryInterface(aIID, aInstancePtr);
+  return nsBlockFrame::QueryInterface(aIID, aInstancePtr);
 }
 
 void 
 nsFileControlFrame::SetFocus(PRBool aOn, PRBool aRepaint)
 {
   // Fix for Bug 6133 
   if (mTextFrame) {
     nsIContent* content = mTextFrame->GetContent();
@@ -416,26 +416,26 @@ NS_IMETHODIMP nsFileControlFrame::Reflow
     if (mCachedState) {
       mTextFrame->SetFormProperty(nsGkAtoms::value, *mCachedState);
       delete mCachedState;
       mCachedState = nsnull;
     }
   }
 
   // The Areaframe takes care of all our reflow
-  return nsAreaFrame::Reflow(aPresContext, aDesiredSize, aReflowState,
+  return nsBlockFrame::Reflow(aPresContext, aDesiredSize, aReflowState,
                              aStatus);
 }
 
 /*
 NS_IMETHODIMP
 nsFileControlFrame::SetInitialChildList(nsIAtom*        aListName,
                                         nsIFrame*       aChildList)
 {
-  nsAreaFrame::SetInitialChildList(aListName, aChildList);
+  nsBlockFrame::SetInitialChildList(aListName, aChildList);
 
   // given that the CSS frame constructor created all our frames. We need to find the text field
   // so we can get info from it.
   mTextFrame = GetTextControlFrame(this);
 }
 */
 
 nsNewFrame*
@@ -509,17 +509,17 @@ nsFileControlFrame::AttributeChanged(PRI
     // propagate size to text
     } else if (aAttribute == nsGkAtoms::size) {
       SyncAttr(aNameSpaceID, aAttribute, SYNC_TEXT);
     } else if (aAttribute == nsGkAtoms::tabindex) {
       SyncAttr(aNameSpaceID, aAttribute, SYNC_BUTTON);
     }
   }
 
-  return nsAreaFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);
+  return nsBlockFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);
 }
 
 PRBool
 nsFileControlFrame::IsLeaf() const
 {
   return PR_TRUE;
 }
 
@@ -573,17 +573,17 @@ nsFileControlFrame::BuildDisplayList(nsD
                                      const nsRect&           aDirtyRect,
                                      const nsDisplayListSet& aLists)
 {
   // Our background is inherited to the text input, and we don't really want to
   // paint it or out padding and borders (which we never have anyway, per
   // styles in forms.css) -- doing it just makes us look ugly in some cases and
   // has no effect in others.
   nsDisplayListCollection tempList;
-  nsresult rv = nsAreaFrame::BuildDisplayList(aBuilder, aDirtyRect, tempList);
+  nsresult rv = nsBlockFrame::BuildDisplayList(aBuilder, aDirtyRect, tempList);
   if (NS_FAILED(rv))
     return rv;
 
   tempList.BorderBackground()->DeleteAll();
 
   // Clip height only
   nsRect clipRect(aBuilder->ToReferenceFrame(this), GetSize());
   clipRect.width = GetOverflowRect().XMost();
diff --git a/layout/forms/nsFileControlFrame.h b/layout/forms/nsFileControlFrame.h
--- a/layout/forms/nsFileControlFrame.h
+++ b/layout/forms/nsFileControlFrame.h
@@ -33,26 +33,26 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsFileControlFrame_h___
 #define nsFileControlFrame_h___
 
-#include "nsAreaFrame.h"
+#include "nsBlockFrame.h"
 #include "nsIFormControlFrame.h"
 #include "nsIDOMMouseListener.h"
 #include "nsIAnonymousContentCreator.h"
 #include "nsCOMPtr.h"
 
 #include "nsTextControlFrame.h"
 typedef   nsTextControlFrame nsNewFrame;
 
-class nsFileControlFrame : public nsAreaFrame,
+class nsFileControlFrame : public nsBlockFrame,
                            public nsIFormControlFrame,
                            public nsIAnonymousContentCreator
 {
 public:
   nsFileControlFrame(nsStyleContext* aContext);
   virtual ~nsFileControlFrame();
 
   NS_IMETHOD Init(nsIContent* aContent,
@@ -123,17 +123,17 @@ protected:
     NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent) { return NS_OK; }
 
   private:
     nsFileControlFrame* mFrame;
   };
   
   virtual PRBool IsFrameOfType(PRUint32 aFlags) const
   {
-    return nsAreaFrame::IsFrameOfType(aFlags &
+    return nsBlockFrame::IsFrameOfType(aFlags &
       ~(nsIFrame::eReplaced | nsIFrame::eReplacedContainsBlock));
   }
 
   virtual PRIntn GetSkipSides() const;
 
   /**
    * The text frame (populated on initial reflow).
    * @see nsFileControlFrame::Reflow
diff --git a/layout/forms/nsIsIndexFrame.cpp b/layout/forms/nsIsIndexFrame.cpp
--- a/layout/forms/nsIsIndexFrame.cpp
+++ b/layout/forms/nsIsIndexFrame.cpp
@@ -80,17 +80,17 @@
 
 nsIFrame*
 NS_NewIsIndexFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 {
   return new (aPresShell) nsIsIndexFrame(aContext);
 }
 
 nsIsIndexFrame::nsIsIndexFrame(nsStyleContext* aContext) :
-  nsAreaFrame(aContext)
+  nsBlockFrame(aContext)
 {
   SetFlags(NS_BLOCK_SPACE_MGR);
 }
 
 nsIsIndexFrame::~nsIsIndexFrame()
 {
 }
 
@@ -100,20 +100,20 @@ nsIsIndexFrame::Destroy()
   // remove ourself as a listener of the text control (bug 40533)
   if (mInputContent) {
     mInputContent->RemoveEventListenerByIID(this, NS_GET_IID(nsIDOMKeyListener));
     nsContentUtils::DestroyAnonymousContent(&mInputContent);
   }
   nsContentUtils::DestroyAnonymousContent(&mTextContent);
   nsContentUtils::DestroyAnonymousContent(&mPreHr);
   nsContentUtils::DestroyAnonymousContent(&mPostHr);
-  nsAreaFrame::Destroy();
+  nsBlockFrame::Destroy();
 }
 
-// REVIEW: We don't need to override BuildDisplayList, nsAreaFrame will honour
+// REVIEW: We don't need to override BuildDisplayList, nsBlockFrame will honour
 // our visibility setting
 
 nsresult
 nsIsIndexFrame::UpdatePromptLabel(PRBool aNotify)
 {
   if (!mTextContent) return NS_ERROR_UNEXPECTED;
 
   nsresult result = NS_OK;
@@ -251,27 +251,27 @@ nsIsIndexFrame::QueryInterface(const nsI
     *aInstancePtr = static_cast<nsIDOMKeyListener*>(this);
     return NS_OK;
   }
   if (aIID.Equals(NS_GET_IID(nsIDOMEventListener))) {
     *aInstancePtr = static_cast<nsIDOMEventListener*>(this);
     return NS_OK;
   }
 
-  return nsAreaFrame::QueryInterface(aIID, aInstancePtr);
+  return nsBlockFrame::QueryInterface(aIID, aInstancePtr);
 }
 
 nscoord
 nsIsIndexFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
 {
   nscoord result;
   DISPLAY_MIN_WIDTH(this, result);
 
   // Our min width is our pref width; the rest of our reflow is
-  // happily handled by nsAreaFrame
+  // happily handled by nsBlockFrame
   result = GetPrefWidth(aRenderingContext);
   return result;
 }
 
 PRBool
 nsIsIndexFrame::IsLeaf() const
 {
   return PR_TRUE;
@@ -281,17 +281,17 @@ NS_IMETHODIMP
 nsIsIndexFrame::AttributeChanged(PRInt32         aNameSpaceID,
                                  nsIAtom*        aAttribute,
                                  PRInt32         aModType)
 {
   nsresult rv = NS_OK;
   if (nsGkAtoms::prompt == aAttribute) {
     rv = UpdatePromptLabel(PR_TRUE);
   } else {
-    rv = nsAreaFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);
+    rv = nsBlockFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);
   }
   return rv;
 }
 
 
 nsresult 
 nsIsIndexFrame::KeyPress(nsIDOMEvent* aEvent)
 {
diff --git a/layout/forms/nsIsIndexFrame.h b/layout/forms/nsIsIndexFrame.h
--- a/layout/forms/nsIsIndexFrame.h
+++ b/layout/forms/nsIsIndexFrame.h
@@ -33,27 +33,27 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsIsIndexFrame_h___
 #define nsIsIndexFrame_h___
 
-#include "nsAreaFrame.h"
+#include "nsBlockFrame.h"
 #include "nsIFormControlFrame.h"
 #include "nsIAnonymousContentCreator.h"
 #include "nsIStatefulFrame.h"
 #include "nsIUnicodeEncoder.h"
 #include "nsIDOMKeyListener.h"
 
 #include "nsTextControlFrame.h"
 typedef   nsTextControlFrame nsNewFrame;
 
-class nsIsIndexFrame : public nsAreaFrame,
+class nsIsIndexFrame : public nsBlockFrame,
                        public nsIAnonymousContentCreator,
                        public nsIDOMKeyListener,
                        public nsIStatefulFrame
 {
 public:
   nsIsIndexFrame(nsStyleContext* aContext);
   virtual ~nsIsIndexFrame();
 
diff --git a/layout/forms/nsLegendFrame.cpp b/layout/forms/nsLegendFrame.cpp
--- a/layout/forms/nsLegendFrame.cpp
+++ b/layout/forms/nsLegendFrame.cpp
@@ -69,48 +69,48 @@ nsLegendFrame::GetType() const
 {
   return nsGkAtoms::legendFrame; 
 }
 
 void
 nsLegendFrame::Destroy()
 {
   nsFormControlFrame::RegUnRegAccessKey(static_cast<nsIFrame*>(this), PR_FALSE);
-  nsAreaFrame::Destroy();
+  nsBlockFrame::Destroy();
 }
 
 // Frames are not refcounted, no need to AddRef
 NS_IMETHODIMP
 nsLegendFrame::QueryInterface(REFNSIID aIID, void** aInstancePtr)
 {
   NS_PRECONDITION(aInstancePtr, "null out param");
 
   if (aIID.Equals(kLegendFrameCID)) {
     *aInstancePtr = this;
     return NS_OK;
   }
 
-  return nsAreaFrame::QueryInterface(aIID, aInstancePtr);
+  return nsBlockFrame::QueryInterface(aIID, aInstancePtr);
 }
 
 NS_IMETHODIMP 
 nsLegendFrame::Reflow(nsPresContext*          aPresContext,
                      nsHTMLReflowMetrics&     aDesiredSize,
                      const nsHTMLReflowState& aReflowState,
                      nsReflowStatus&          aStatus)
 {
   DO_GLOBAL_REFLOW_COUNT("nsLegendFrame");
   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
   if (mState & NS_FRAME_FIRST_REFLOW) {
     nsFormControlFrame::RegUnRegAccessKey(static_cast<nsIFrame*>(this), PR_TRUE);
   }
-  return nsAreaFrame::Reflow(aPresContext, aDesiredSize, aReflowState, aStatus);
+  return nsBlockFrame::Reflow(aPresContext, aDesiredSize, aReflowState, aStatus);
 }
 
-// REVIEW: We don't need to override BuildDisplayList, nsAreaFrame will honour
+// REVIEW: We don't need to override BuildDisplayList, nsBlockFrame will honour
 // our visibility setting
 PRInt32 nsLegendFrame::GetAlign()
 {
   PRInt32 intValue = NS_STYLE_TEXT_ALIGN_LEFT;
 #ifdef IBMBIDI
   if (mParent && NS_STYLE_DIRECTION_RTL == mParent->GetStyleVisibility()->mDirection) {
     intValue = NS_STYLE_TEXT_ALIGN_RIGHT;
   }
diff --git a/layout/forms/nsLegendFrame.h b/layout/forms/nsLegendFrame.h
--- a/layout/forms/nsLegendFrame.h
+++ b/layout/forms/nsLegendFrame.h
@@ -33,33 +33,33 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsLegendFrame_h___
 #define nsLegendFrame_h___
 
-#include "nsAreaFrame.h"
+#include "nsBlockFrame.h"
 #include "nsPresContext.h"
 #include "nsCOMPtr.h"
 
 class  nsIContent;
 class  nsIFrame;
 class  nsPresContext;
 struct nsHTMLReflowMetrics;
 class  nsIRenderingContext;
 struct nsRect;
 
 #define NS_LEGEND_FRAME_CID \
 { 0x73805d40, 0x5a24, 0x11d2, { 0x80, 0x46, 0x0, 0x60, 0x8, 0x15, 0xa7, 0x91 } }
 
-class nsLegendFrame : public nsAreaFrame {
+class nsLegendFrame : public nsBlockFrame {
 public:
-  nsLegendFrame(nsStyleContext* aContext) : nsAreaFrame(aContext) {}
+  nsLegendFrame(nsStyleContext* aContext) : nsBlockFrame(aContext) {}
 
   NS_IMETHOD QueryInterface(const nsIID& aIID, void** aInstancePtr);
 
   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
                     nsHTMLReflowMetrics&     aDesiredSize,
                     const nsHTMLReflowState& aReflowState,
                     nsReflowStatus&          aStatus);
 
diff --git a/layout/forms/nsSelectsAreaFrame.cpp b/layout/forms/nsSelectsAreaFrame.cpp
--- a/layout/forms/nsSelectsAreaFrame.cpp
+++ b/layout/forms/nsSelectsAreaFrame.cpp
@@ -196,17 +196,17 @@ nsSelectsAreaFrame::BuildDisplayList(nsD
   return wrapper.WrapLists(aBuilder, this, set, aLists);
 }
 
 nsresult
 nsSelectsAreaFrame::BuildDisplayListInternal(nsDisplayListBuilder*   aBuilder,
                                              const nsRect&           aDirtyRect,
                                              const nsDisplayListSet& aLists)
 {
-  nsresult rv = nsAreaFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
+  nsresult rv = nsBlockFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsListControlFrame* listFrame = GetEnclosingListFrame(this);
   if (listFrame && listFrame->IsFocused()) {
     // we can't just associate the display item with the list frame,
     // because then the list's scrollframe won't clip it (the scrollframe
     // only clips contained descendants).
     return aLists.Outlines()->AppendNewToTop(new (aBuilder)
@@ -229,25 +229,25 @@ nsSelectsAreaFrame::Reflow(nsPresContext
   
   PRBool isInDropdownMode = list->IsInDropDownMode();
   
   // See similar logic in nsListControlFrame::Reflow and
   // nsListControlFrame::ReflowAsDropdown.  We need to match it here.
   nscoord oldHeight;
   if (isInDropdownMode) {
     // Store the height now in case it changes during
-    // nsAreaFrame::Reflow for some odd reason.
+    // nsBlockFrame::Reflow for some odd reason.
     if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
       oldHeight = GetSize().height;
     } else {
       oldHeight = NS_UNCONSTRAINEDSIZE;
     }
   }
   
-  nsresult rv = nsAreaFrame::Reflow(aPresContext, aDesiredSize,
+  nsresult rv = nsBlockFrame::Reflow(aPresContext, aDesiredSize,
                                     aReflowState, aStatus);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Check whether we need to suppress scrolbar updates.  We want to do that if
   // we're in a possible first pass and our height of a row has changed.
   if (list->MightNeedSecondPass()) {
     nscoord newHeightOfARow = list->CalcHeightOfARow();
     // We'll need a second pass if our height of a row changed.  For
diff --git a/layout/forms/nsSelectsAreaFrame.h b/layout/forms/nsSelectsAreaFrame.h
--- a/layout/forms/nsSelectsAreaFrame.h
+++ b/layout/forms/nsSelectsAreaFrame.h
@@ -32,26 +32,20 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 #ifndef nsSelectsAreaFrame_h___
 #define nsSelectsAreaFrame_h___
 
-#include "nsAreaFrame.h"
+#include "nsBlockFrame.h"
 class nsIContent;
 
-/**
- * The area frame has an additional named child list:
- * - "Absolute-list" which contains the absolutely positioned frames
- *
- * @see nsGkAtoms::absoluteList
- */
-class nsSelectsAreaFrame : public nsAreaFrame
+class nsSelectsAreaFrame : public nsBlockFrame
 {
 public:
   friend nsIFrame* NS_NewSelectsAreaFrame(nsIPresShell* aShell, nsStyleContext* aContext, PRUint32 aFlags);
 
   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists);
 
@@ -66,17 +60,17 @@ public:
 
   static PRBool IsOptionElement(nsIContent* aContent);
   static PRBool IsOptionElementFrame(nsIFrame *aFrame);
   
   nscoord HeightOfARow() const { return mHeightOfARow; }
   
 protected:
   nsSelectsAreaFrame(nsStyleContext* aContext) :
-    nsAreaFrame(aContext),
+    nsBlockFrame(aContext),
     mHeightOfARow(0)
   {}
 
   // We cache the height of a single row so that changes to the "size"
   // attribute, padding, etc. can all be handled with only one reflow.  We'll
   // have to reflow twice if someone changes our font size or something like
   // that, so that the heights of our options will change.
   nscoord mHeightOfARow;
diff --git a/layout/forms/nsTextControlFrame.h b/layout/forms/nsTextControlFrame.h
--- a/layout/forms/nsTextControlFrame.h
+++ b/layout/forms/nsTextControlFrame.h
@@ -34,17 +34,17 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsTextControlFrame_h___
 #define nsTextControlFrame_h___
 
 #include "nsStackFrame.h"
-#include "nsAreaFrame.h"
+#include "nsBlockFrame.h"
 #include "nsIFormControlFrame.h"
 #include "nsIDOMMouseListener.h"
 #include "nsIAnonymousContentCreator.h"
 #include "nsIEditor.h"
 #include "nsITextControlFrame.h"
 #include "nsIFontMetrics.h"
 #include "nsWeakReference.h" //for service and presshell pointers
 #include "nsIScrollableViewProvider.h"
diff --git a/layout/generic/Makefile.in b/layout/generic/Makefile.in
--- a/layout/generic/Makefile.in
+++ b/layout/generic/Makefile.in
@@ -107,17 +107,16 @@ ifdef IBMBIDI
 EXPORTS		+= \
 		nsBidiFrames.h      \
 		$(NULL)
 endif
 
 
 CPPSRCS		= \
 		nsAbsoluteContainingBlock.cpp \
-		nsAreaFrame.cpp \
 		nsBRFrame.cpp \
 		nsBlockBandData.cpp \
 		nsBlockFrame.cpp \
 		nsBlockReflowContext.cpp \
 		nsBlockReflowState.cpp \
 		nsBulletFrame.cpp \
 		nsColumnSetFrame.cpp \
 		nsContainerFrame.cpp \
@@ -147,16 +146,17 @@ CPPSRCS		= \
 		nsSimplePageSequence.cpp \
 		nsSpaceManager.cpp \
 		nsSpacerFrame.cpp \
 		nsSplittableFrame.cpp \
 		nsTextFrameThebes.cpp \
 		nsTextFrameUtils.cpp \
 		nsTextRunTransformations.cpp \
 		nsViewportFrame.cpp \
+		nsXULLabelFrame.cpp \
 		$(NULL)
 
 ifdef MOZ_MEDIA
 CPPSRCS		+= \
 		nsVideoFrame.cpp \
 		$(NULL)
 endif
 
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -7376,17 +7376,17 @@ DR_FrameTypeInfo* DR_State::GetFrameType
       return info;
     }
   }
   return (DR_FrameTypeInfo*)mFrameTypeTable.ElementAt(numEntries - 1); // return unknown frame type
 }
 
 void DR_State::InitFrameTypeTable()
 {  
-  AddFrameTypeInfo(nsGkAtoms::areaFrame,             "area",      "area");
+  AddFrameTypeInfo(nsGkAtoms::XULLabelFrame,         "XULLabel",  "XULLabel");
   AddFrameTypeInfo(nsGkAtoms::blockFrame,            "block",     "block");
   AddFrameTypeInfo(nsGkAtoms::brFrame,               "br",        "br");
   AddFrameTypeInfo(nsGkAtoms::bulletFrame,           "bullet",    "bullet");
   AddFrameTypeInfo(nsGkAtoms::gfxButtonControlFrame, "button",    "gfxButtonControl");
   AddFrameTypeInfo(nsGkAtoms::HTMLButtonControlFrame, "HTMLbutton",    "HTMLButtonControl");
   AddFrameTypeInfo(nsGkAtoms::HTMLCanvasFrame,       "HTMLCanvas","HTMLCanvas");
   AddFrameTypeInfo(nsGkAtoms::subDocumentFrame,      "subdoc",    "subDocument");
   AddFrameTypeInfo(nsGkAtoms::imageFrame,            "img",       "image");
diff --git a/layout/generic/nsHTMLParts.h b/layout/generic/nsHTMLParts.h
--- a/layout/generic/nsHTMLParts.h
+++ b/layout/generic/nsHTMLParts.h
@@ -77,19 +77,16 @@ class nsTableColFrame;
 #define NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET   0x40000000
 #define NS_BLOCK_HAS_FIRST_LETTER_CHILD     0x80000000
 // These are the bits that get inherited from a block frame to its
 // next-in-flows and are not private to blocks
 #define NS_BLOCK_FLAGS_MASK                 0xF0E00000 
 
 // Factory methods for creating html layout objects
 
-// These are variations on AreaFrame with slightly different layout
-// policies.
-
 // Create a frame that supports "display: block" layout behavior
 nsIFrame*
 NS_NewBlockFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags = 0);
 
 // Special Generated Content Node. It contains text taken from an
 // attribute of its *grandparent* content node. 
 nsresult
 NS_NewAttributeContent(nsNodeInfoManager *aNodeInfoManager,
@@ -98,19 +95,20 @@ NS_NewAttributeContent(nsNodeInfoManager
 
 // Create a basic area frame but the GetFrameForPoint is overridden to always
 // return the option frame 
 // By default, area frames will extend
 // their height to cover any children that "stick out".
 nsIFrame*
 NS_NewSelectsAreaFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
 
-// Create a basic area frame.
+#ifdef MOZ_XUL
 nsIFrame*
-NS_NewAreaFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
+NS_NewXULLabelFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
+#endif
 
 // These AreaFrame's shrink wrap around their contents
 inline nsIFrame*
 NS_NewTableCellInnerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
   return NS_NewBlockFrame(aPresShell, aContext);
 }
 
 // This type of BlockFrame is a margin root, but does not shrink wrap
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -326,17 +326,19 @@ void nsHTMLReflowState::InitCBReflowStat
  * XXX Maybe refactor CalcQuirkContainingBlockHeight so it uses 
  * this function as well
  */
 static PRBool
 IsQuirkContainingBlockHeight(const nsHTMLReflowState* rs) 
 {
   nsIAtom* frameType = rs->frame->GetType();
   if (nsGkAtoms::blockFrame == frameType ||
-      nsGkAtoms::areaFrame == frameType ||
+#ifdef MOZ_XUL
+      nsGkAtoms::XULLabelFrame == frameType ||
+#endif
       nsGkAtoms::scrollFrame == frameType) {
     // Note: This next condition could change due to a style change,
     // but that would cause a style reflow anyway, which means we're ok.
     if (NS_AUTOHEIGHT == rs->ComputedHeight()) {
       if (!rs->frame->GetStyleDisplay()->IsAbsolutelyPositioned()) {
         return PR_FALSE;
       }
     }
@@ -1429,17 +1431,19 @@ CalcQuirkContainingBlockHeight(const nsH
   nscoord result = NS_AUTOHEIGHT; 
                              
   const nsHTMLReflowState* rs = aCBReflowState;
   for (; rs; rs = (nsHTMLReflowState *)(rs->parentReflowState)) { 
     nsIAtom* frameType = rs->frame->GetType();
     // if the ancestor is auto height then skip it and continue up if it 
     // is the first block/area frame and possibly the body/html
     if (nsGkAtoms::blockFrame == frameType ||
-        nsGkAtoms::areaFrame == frameType ||
+#ifdef MOZ_XUL
+        nsGkAtoms::XULLabelFrame == frameType ||
+#endif
         nsGkAtoms::scrollFrame == frameType) {
 
       secondAncestorRS = firstAncestorRS;
       firstAncestorRS = (nsHTMLReflowState*)rs;
 
       // If the current frame we're looking at is positioned, we don't want to
       // go any further (see bug 221784).  The behavior we want here is: 1) If
       // not auto-height, use this as the percentage base.  2) If auto-height,
@@ -1494,24 +1498,28 @@ CalcQuirkContainingBlockHeight(const nsH
         if (frameContent) {
           nsIAtom *contentTag = frameContent->Tag();
           NS_ASSERTION(contentTag == nsGkAtoms::body, "Second ancestor is not BODY");
         }
       }
 #endif
       
     }
+    // This code is commented out since it hasn't been executed since
+    // we stopped creating area frames for the root (bug 243519).
+#if 0
     // if we got to the html frame, then subtract out 
     // margin/border/padding for the BODY element
     else if (nsGkAtoms::areaFrame == frameType) {
       // make sure it is the body
       if (nsGkAtoms::canvasFrame == rs->parentReflowState->frame->GetType()) {
         result -= GetVerticalMarginBorderPadding(secondAncestorRS);
       }
     }
+#endif
     break;
   }
 
   // Make sure not to return a negative height here!
   return PR_MAX(result, 0);
 }
 // Called by InitConstraints() to compute the containing block rectangle for
 // the element. Handles the special logic for absolutely positioned elements
diff --git a/layout/generic/nsAreaFrame.cpp b/layout/generic/nsXULLabelFrame.cpp
rename from layout/generic/nsAreaFrame.cpp
rename to layout/generic/nsXULLabelFrame.cpp
--- a/layout/generic/nsAreaFrame.cpp
+++ b/layout/generic/nsXULLabelFrame.cpp
@@ -30,61 +30,45 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-/* derived class of nsBlockFrame; distinction barely relevant anymore */
-
-#include "nsAreaFrame.h"
-#include "nsBlockBandData.h"
-#include "nsStyleContext.h"
-#include "nsStyleConsts.h"
-#include "nsPresContext.h"
-#include "nsINodeInfo.h"
-#include "nsGkAtoms.h"
-#include "nsHTMLParts.h"
+/* derived class of nsBlockFrame used for xul:label elements */
 
 #ifdef MOZ_XUL
+
+#include "nsXULLabelFrame.h"
+#include "nsHTMLParts.h"
 #include "nsINameSpaceManager.h"
 #include "nsIEventStateManager.h"
-#endif
-
-#undef NOISY_MAX_ELEMENT_SIZE
-#undef NOISY_FINAL_SIZE
 
 nsIFrame*
-NS_NewAreaFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags)
+NS_NewXULLabelFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags)
 {
-  nsAreaFrame* it = new (aPresShell) nsAreaFrame(aContext);
+  nsXULLabelFrame* it = new (aPresShell) nsXULLabelFrame(aContext);
   
   if (it != nsnull)
     it->SetFlags(aFlags);
 
   return it;
 }
 
-#ifdef MOZ_XUL
-
 // If you make changes to this function, check its counterparts 
 // in nsBoxFrame and nsTextBoxFrame
 nsresult
-nsAreaFrame::RegUnregAccessKey(PRBool aDoReg)
+nsXULLabelFrame::RegUnregAccessKey(PRBool aDoReg)
 {
   // if we have no content, we can't do anything
   if (!mContent)
     return NS_ERROR_FAILURE;
 
-  // only support accesskeys for the following elements
-  if (!mContent->NodeInfo()->Equals(nsGkAtoms::label, kNameSpaceID_XUL))
-    return NS_OK;
-
   // To filter out <label>s without a control attribute.
   // XXXjag a side-effect is that we filter out anonymous <label>s
   // in e.g. <menu>, <menuitem>, <button>. These <label>s inherit
   // |accesskey| and would otherwise register themselves, overwriting
   // the content we really meant to be registered.
   if (!mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::control))
     return NS_OK;
 
@@ -102,68 +86,67 @@ nsAreaFrame::RegUnregAccessKey(PRBool aD
   PRUint32 key = accessKey.First();
   if (aDoReg)
     rv = esm->RegisterAccessKey(mContent, key);
   else
     rv = esm->UnregisterAccessKey(mContent, key);
 
   return rv;
 }
-#endif
 
 /////////////////////////////////////////////////////////////////////////////
 // nsIFrame
 
-#ifdef MOZ_XUL
 NS_IMETHODIMP
-nsAreaFrame::Init(nsIContent*      aContent,
-                  nsIFrame*        aParent,
-                  nsIFrame*        aPrevInFlow)
+nsXULLabelFrame::Init(nsIContent*      aContent,
+                      nsIFrame*        aParent,
+                      nsIFrame*        aPrevInFlow)
 {
   nsresult rv = nsBlockFrame::Init(aContent, aParent, aPrevInFlow);
   if (NS_FAILED(rv))
     return rv;
 
   // register access key
   return RegUnregAccessKey(PR_TRUE);
 }
 
 void
-nsAreaFrame::Destroy()
+nsXULLabelFrame::Destroy()
 {
   // unregister access key
   RegUnregAccessKey(PR_FALSE);
   nsBlockFrame::Destroy();
 } 
 
 NS_IMETHODIMP
-nsAreaFrame::AttributeChanged(PRInt32 aNameSpaceID,
-                              nsIAtom* aAttribute,
-                              PRInt32 aModType)
+nsXULLabelFrame::AttributeChanged(PRInt32 aNameSpaceID,
+                                  nsIAtom* aAttribute,
+                                  PRInt32 aModType)
 {
   nsresult rv = nsBlockFrame::AttributeChanged(aNameSpaceID, 
                                                aAttribute, aModType);
 
   // If the accesskey changed, register for the new value
   // The old value has been unregistered in nsXULElement::SetAttr
   if (aAttribute == nsGkAtoms::accesskey || aAttribute == nsGkAtoms::control)
     RegUnregAccessKey(PR_TRUE);
 
   return rv;
 }
-#endif
 
 nsIAtom*
-nsAreaFrame::GetType() const
+nsXULLabelFrame::GetType() const
 {
-  return nsGkAtoms::areaFrame;
+  return nsGkAtoms::XULLabelFrame;
 }
 
 /////////////////////////////////////////////////////////////////////////////
 // Diagnostics
 
 #ifdef NS_DEBUG
 NS_IMETHODIMP
-nsAreaFrame::GetFrameName(nsAString& aResult) const
+nsXULLabelFrame::GetFrameName(nsAString& aResult) const
 {
-  return MakeFrameName(NS_LITERAL_STRING("Area"), aResult);
+  return MakeFrameName(NS_LITERAL_STRING("XULLabel"), aResult);
 }
 #endif
+
+#endif /* defined(MOZ_XUL) */
diff --git a/layout/generic/nsAreaFrame.h b/layout/generic/nsXULLabelFrame.h
rename from layout/generic/nsAreaFrame.h
rename to layout/generic/nsXULLabelFrame.h
--- a/layout/generic/nsAreaFrame.h
+++ b/layout/generic/nsXULLabelFrame.h
@@ -30,65 +30,53 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-/* derived class of nsBlockFrame; distinction barely relevant anymore */
+/* derived class of nsBlockFrame used for xul:label elements */
 
-#ifndef nsAreaFrame_h___
-#define nsAreaFrame_h___
+#ifndef nsXULLabelFrame_h_
+#define nsXULLabelFrame_h_
 
 #include "nsBlockFrame.h"
-#include "nsAbsoluteContainingBlock.h"
 
-struct nsStyleDisplay;
-struct nsStylePosition;
+#ifdef MOZ_XUL
 
-
-/**
- * The area frame has an additional named child list:
- * - "Absolute-list" which contains the absolutely positioned frames
- *
- * @see nsGkAtoms::absoluteList
- */
-class nsAreaFrame : public nsBlockFrame
+class nsXULLabelFrame : public nsBlockFrame
 {
 public:
-  friend nsIFrame* NS_NewAreaFrame(nsIPresShell* aPresShell, nsStyleContext *aContext, PRUint32 aFlags);
+  friend nsIFrame* NS_NewXULLabelFrame(nsIPresShell* aPresShell, nsStyleContext *aContext, PRUint32 aFlags);
   
   // nsIFrame
-
-#ifdef MOZ_XUL
   NS_IMETHOD Init(nsIContent*      aContent,
                   nsIFrame*        aParent,
                   nsIFrame*        aPrevInFlow);
 
   virtual void Destroy();
 
   NS_IMETHOD AttributeChanged(PRInt32 aNameSpaceID,
                               nsIAtom* aAttribute,
                               PRInt32 aModType);
-#endif
 
   /**
    * Get the "type" of the frame
    *
-   * @see nsGkAtoms::areaFrame
+   * @see nsGkAtoms::XULLabelFrame
    */
   virtual nsIAtom* GetType() const;
   
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const;
 #endif
 
 protected:
-  nsAreaFrame(nsStyleContext *aContext) : nsBlockFrame(aContext) {}
+  nsXULLabelFrame(nsStyleContext *aContext) : nsBlockFrame(aContext) {}
 
-#ifdef MOZ_XUL
   nsresult RegUnregAccessKey(PRBool aDoReg);
-#endif
 };
 
-#endif /* nsAreaFrame_h___ */
+#endif /* defined(MOZ_XUL) */
+
+#endif /* !defined(nsXULLabelFrame_h_) */
diff --git a/layout/mathml/base/src/nsMathMLForeignFrameWrapper.cpp b/layout/mathml/base/src/nsMathMLForeignFrameWrapper.cpp
--- a/layout/mathml/base/src/nsMathMLForeignFrameWrapper.cpp
+++ b/layout/mathml/base/src/nsMathMLForeignFrameWrapper.cpp
@@ -39,17 +39,17 @@
 //
 // a helper frame class to wrap non-MathML frames so that foreign elements 
 // (e.g., html:img) can mix better with other surrounding MathML markups
 //
 
 #include "nsCOMPtr.h"
 #include "nsHTMLParts.h"
 #include "nsFrame.h"
-#include "nsAreaFrame.h"
+#include "nsBlockFrame.h"
 #include "nsLineLayout.h"
 #include "nsPresContext.h"
 #include "nsStyleContext.h"
 #include "nsStyleConsts.h"
 #include "nsIRenderingContext.h"
 #include "nsIFontMetrics.h"
 
 #include "nsMathMLForeignFrameWrapper.h"
diff --git a/layout/mathml/base/src/nsMathMLmtableFrame.cpp b/layout/mathml/base/src/nsMathMLmtableFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmtableFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmtableFrame.cpp
@@ -33,17 +33,17 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsCOMPtr.h"
 #include "nsFrame.h"
-#include "nsAreaFrame.h"
+#include "nsBlockFrame.h"
 #include "nsPresContext.h"
 #include "nsStyleContext.h"
 #include "nsStyleConsts.h"
 #include "nsINameSpaceManager.h"
 #include "nsIRenderingContext.h"
 #include "nsIFontMetrics.h"
 
 #include "nsVoidArray.h"
diff --git a/layout/xul/base/src/nsBoxFrame.cpp b/layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp
+++ b/layout/xul/base/src/nsBoxFrame.cpp
@@ -1862,17 +1862,17 @@ nsBoxFrame::CreateViewForFrame(nsPresCon
       if (!view)
         return NS_ERROR_OUT_OF_MEMORY;
     }
   }
   return NS_OK;
 }
 
 // If you make changes to this function, check its counterparts
-// in nsTextBoxFrame and nsAreaFrame
+// in nsTextBoxFrame and nsXULLabelFrame
 nsresult
 nsBoxFrame::RegUnregAccessKey(PRBool aDoReg)
 {
   // if we have no content, we can't do anything
   if (!mContent)
     return NS_ERROR_FAILURE;
 
   // find out what type of element this is
diff --git a/layout/xul/base/src/nsTextBoxFrame.cpp b/layout/xul/base/src/nsTextBoxFrame.cpp
--- a/layout/xul/base/src/nsTextBoxFrame.cpp
+++ b/layout/xul/base/src/nsTextBoxFrame.cpp
@@ -1095,17 +1095,17 @@ nsTextBoxFrame::GetFrameName(nsAString& 
 {
     MakeFrameName(NS_LITERAL_STRING("TextBox"), aResult);
     aResult += NS_LITERAL_STRING("[value=") + mTitle + NS_LITERAL_STRING("]");
     return NS_OK;
 }
 #endif
 
 // If you make changes to this function, check its counterparts 
-// in nsBoxFrame and nsAreaFrame
+// in nsBoxFrame and nsXULLabelFrame
 nsresult
 nsTextBoxFrame::RegUnregAccessKey(PRBool aDoReg)
 {
     // if we have no content, we can't do anything
     if (!mContent)
         return NS_ERROR_FAILURE;
 
     // check if we have a |control| attribute
