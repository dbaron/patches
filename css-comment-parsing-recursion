Avoid recursion after parsing CSS comments.  (Bug 473914)

diff --git a/layout/style/crashtests/473914-1.html b/layout/style/crashtests/473914-1.html
new file mode 100644
--- /dev/null
+++ b/layout/style/crashtests/473914-1.html
@@ -0,0 +1,23 @@
+<!DOCTYPE html>
+<html>
+<head>
+<style id="s"></style>
+<script type="text/javascript">
+
+// Duplicates the string 2^n times
+function exp(s, n)
+{
+  for (var i = 0; i < n; ++i)
+    s += s;
+  return s;
+}
+
+var stylesheet = exp("/**/", 20);
+document.getElementById("s").textContent = stylesheet;
+
+</script>
+</head>
+<body>
+<div></div>
+</body>
+</html>
diff --git a/layout/style/crashtests/crashtests.list b/layout/style/crashtests/crashtests.list
--- a/layout/style/crashtests/crashtests.list
+++ b/layout/style/crashtests/crashtests.list
@@ -22,8 +22,9 @@ load 447776-1.html
 load 447783-1.html
 load 448161-1.html
 load 448161-2.html
 load 456196.html
 load 460217-1.html
 load 466845-1.html
 HTTP(..) load 472237-1.html
 load 473720-1.html
+load 473914-1.html
diff --git a/layout/style/nsCSSScanner.cpp b/layout/style/nsCSSScanner.cpp
--- a/layout/style/nsCSSScanner.cpp
+++ b/layout/style/nsCSSScanner.cpp
@@ -702,140 +702,145 @@ nsCSSScanner::EatNewline()
     Pushback(ch);
   }
   return eaten;
 }
 
 PRBool
 nsCSSScanner::Next(nsCSSToken& aToken)
 {
-  PRInt32 ch = Read();
-  if (ch < 0) {
-    return PR_FALSE;
-  }
+  for (;;) { // Infinite loop so we can restart after comments.
+    PRInt32 ch = Read();
+    if (ch < 0) {
+      return PR_FALSE;
+    }
 
-  // IDENT
-  if (StartsIdent(ch, Peek()))
-    return ParseIdent(ch, aToken);
+    // IDENT
+    if (StartsIdent(ch, Peek()))
+      return ParseIdent(ch, aToken);
 
-  // AT_KEYWORD
-  if (ch == '@') {
-    PRInt32 nextChar = Read();
-    if (nextChar >= 0) {
-      PRInt32 followingChar = Peek();
-      Pushback(nextChar);
-      if (StartsIdent(nextChar, followingChar))
-        return ParseAtKeyword(ch, aToken);
+    // AT_KEYWORD
+    if (ch == '@') {
+      PRInt32 nextChar = Read();
+      if (nextChar >= 0) {
+        PRInt32 followingChar = Peek();
+        Pushback(nextChar);
+        if (StartsIdent(nextChar, followingChar))
+          return ParseAtKeyword(ch, aToken);
+      }
     }
-  }
 
-  // NUMBER or DIM
-  if ((ch == '.') || (ch == '+') || (ch == '-')) {
-    PRInt32 nextChar = Peek();
-    if (IsDigit(nextChar)) {
+    // NUMBER or DIM
+    if ((ch == '.') || (ch == '+') || (ch == '-')) {
+      PRInt32 nextChar = Peek();
+      if (IsDigit(nextChar)) {
+        return ParseNumber(ch, aToken);
+      }
+      else if (('.' == nextChar) && ('.' != ch)) {
+        nextChar = Read();
+        PRInt32 followingChar = Peek();
+        Pushback(nextChar);
+        if (IsDigit(followingChar))
+          return ParseNumber(ch, aToken);
+      }
+    }
+    if (IsDigit(ch)) {
       return ParseNumber(ch, aToken);
     }
-    else if (('.' == nextChar) && ('.' != ch)) {
-      nextChar = Read();
-      PRInt32 followingChar = Peek();
-      Pushback(nextChar);
-      if (IsDigit(followingChar))
-        return ParseNumber(ch, aToken);
+
+    // ID
+    if (ch == '#') {
+      return ParseRef(ch, aToken);
     }
-  }
-  if (IsDigit(ch)) {
-    return ParseNumber(ch, aToken);
-  }
 
-  // ID
-  if (ch == '#') {
-    return ParseRef(ch, aToken);
-  }
+    // STRING
+    if ((ch == '"') || (ch == '\'')) {
+      return ParseString(ch, aToken);
+    }
 
-  // STRING
-  if ((ch == '"') || (ch == '\'')) {
-    return ParseString(ch, aToken);
-  }
-
-  // WS
-  if (IsWhitespace(ch)) {
-    aToken.mType = eCSSToken_WhiteSpace;
-    aToken.mIdent.Assign(PRUnichar(ch));
-    (void) EatWhiteSpace();
-    return PR_TRUE;
-  }
-  if (ch == '/') {
-    PRInt32 nextChar = Peek();
-    if (nextChar == '*') {
-      (void) Read();
+    // WS
+    if (IsWhitespace(ch)) {
+      aToken.mType = eCSSToken_WhiteSpace;
+      aToken.mIdent.Assign(PRUnichar(ch));
+      (void) EatWhiteSpace();
+      return PR_TRUE;
+    }
+    if (ch == '/') {
+      PRInt32 nextChar = Peek();
+      if (nextChar == '*') {
+        (void) Read();
 #if 0
-      // If we change our storage data structures such that comments are
-      // stored (for Editor), we should reenable this code, condition it
-      // on being in editor mode, and apply glazou's patch from bug
-      // 60290.
-      aToken.mIdent.SetCapacity(2);
-      aToken.mIdent.Assign(PRUnichar(ch));
-      aToken.mIdent.Append(PRUnichar(nextChar));
-      return ParseCComment(aToken);
+        // If we change our storage data structures such that comments are
+        // stored (for Editor), we should reenable this code, condition it
+        // on being in editor mode, and apply glazou's patch from bug
+        // 60290.
+        aToken.mIdent.SetCapacity(2);
+        aToken.mIdent.Assign(PRUnichar(ch));
+        aToken.mIdent.Append(PRUnichar(nextChar));
+        return ParseCComment(aToken);
 #endif
-      return SkipCComment() && Next(aToken);
+        if (!SkipCComment()) {
+          return PR_FALSE;
+        }
+        continue; // start again at the beginning
+      }
     }
-  }
-  if (ch == '<') {  // consume HTML comment tags
-    if (LookAhead('!')) {
+    if (ch == '<') {  // consume HTML comment tags
+      if (LookAhead('!')) {
+        if (LookAhead('-')) {
+          if (LookAhead('-')) {
+            aToken.mType = eCSSToken_HTMLComment;
+            aToken.mIdent.AssignLiteral("<!--");
+            return PR_TRUE;
+          }
+          Pushback('-');
+        }
+        Pushback('!');
+      }
+    }
+    if (ch == '-') {  // check for HTML comment end
       if (LookAhead('-')) {
-        if (LookAhead('-')) {
+        if (LookAhead('>')) {
           aToken.mType = eCSSToken_HTMLComment;
-          aToken.mIdent.AssignLiteral("<!--");
+          aToken.mIdent.AssignLiteral("-->");
           return PR_TRUE;
         }
         Pushback('-');
       }
-      Pushback('!');
     }
+
+    // INCLUDES ("~=") and DASHMATCH ("|=")
+    if (( ch == '|' ) || ( ch == '~' ) || ( ch == '^' ) ||
+        ( ch == '$' ) || ( ch == '*' )) {
+      PRInt32 nextChar = Read();
+      if ( nextChar == '=' ) {
+        if (ch == '~') {
+          aToken.mType = eCSSToken_Includes;
+        }
+        else if (ch == '|') {
+          aToken.mType = eCSSToken_Dashmatch;
+        }
+        else if (ch == '^') {
+          aToken.mType = eCSSToken_Beginsmatch;
+        }
+        else if (ch == '$') {
+          aToken.mType = eCSSToken_Endsmatch;
+        }
+        else if (ch == '*') {
+          aToken.mType = eCSSToken_Containsmatch;
+        }
+        return PR_TRUE;
+      } else if (nextChar >= 0) {
+        Pushback(nextChar);
+      }
+    }
+    aToken.mType = eCSSToken_Symbol;
+    aToken.mSymbol = ch;
+    return PR_TRUE;
   }
-  if (ch == '-') {  // check for HTML comment end
-    if (LookAhead('-')) {
-      if (LookAhead('>')) {
-        aToken.mType = eCSSToken_HTMLComment;
-        aToken.mIdent.AssignLiteral("-->");
-        return PR_TRUE;
-      }
-      Pushback('-');
-    }
-  }
-
-  // INCLUDES ("~=") and DASHMATCH ("|=")
-  if (( ch == '|' ) || ( ch == '~' ) || ( ch == '^' ) ||
-      ( ch == '$' ) || ( ch == '*' )) {
-    PRInt32 nextChar = Read();
-    if ( nextChar == '=' ) {
-      if (ch == '~') {
-        aToken.mType = eCSSToken_Includes;
-      }
-      else if (ch == '|') {
-        aToken.mType = eCSSToken_Dashmatch;
-      }
-      else if (ch == '^') {
-        aToken.mType = eCSSToken_Beginsmatch;
-      }
-      else if (ch == '$') {
-        aToken.mType = eCSSToken_Endsmatch;
-      }
-      else if (ch == '*') {
-        aToken.mType = eCSSToken_Containsmatch;
-      }
-      return PR_TRUE;
-    } else if (nextChar >= 0) {
-      Pushback(nextChar);
-    }
-  }
-  aToken.mType = eCSSToken_Symbol;
-  aToken.mSymbol = ch;
-  return PR_TRUE;
 }
 
 PRBool
 nsCSSScanner::NextURL(nsCSSToken& aToken)
 {
   PRInt32 ch = Read();
   if (ch < 0) {
     return PR_FALSE;
@@ -848,33 +853,16 @@ nsCSSScanner::NextURL(nsCSSToken& aToken
 
   // WS
   if (IsWhitespace(ch)) {
     aToken.mType = eCSSToken_WhiteSpace;
     aToken.mIdent.Assign(PRUnichar(ch));
     (void) EatWhiteSpace();
     return PR_TRUE;
   }
-  if (ch == '/') {
-    PRInt32 nextChar = Peek();
-    if (nextChar == '*') {
-      (void) Read();
-#if 0
-      // If we change our storage data structures such that comments are
-      // stored (for Editor), we should reenable this code, condition it
-      // on being in editor mode, and apply glazou's patch from bug
-      // 60290.
-      aToken.mIdent.SetCapacity(2);
-      aToken.mIdent.Assign(PRUnichar(ch));
-      aToken.mIdent.Append(PRUnichar(nextChar));
-      return ParseCComment(aToken);
-#endif
-      return SkipCComment() && Next(aToken);
-    }
-  }
 
   // Process a url lexical token. A CSS1 url token can contain
   // characters beyond identifier characters (e.g. '/', ':', etc.)
   // Because of this the normal rules for tokenizing the input don't
   // apply very well. To simplify the parser and relax some of the
   // requirements on the scanner we parse url's here. If we find a
   // malformed URL then we emit a token of type "InvalidURL" so that
   // the CSS1 parser can ignore the invalid input. We attempt to eat
