From: L. David Baron <dbaron@dbaron.org>

Correct handling of unitless zero in calc() expressions.  (Bug 595648)

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -4359,16 +4359,28 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
         PRInt32 value;
         if (nsCSSProps::FindKeyword(keyword, aKeywordTable, value)) {
           aValue.SetIntValue(value, eCSSUnit_Enumerated);
           return PR_TRUE;
         }
       }
     }
   }
+  // Check VARIANT_NUMBER and VARIANT_INTEGER before VARIANT_LENGTH or
+  // VARIANT_ZERO_ANGLE.
+  if (((aVariantMask & VARIANT_NUMBER) != 0) &&
+      (eCSSToken_Number == tk->mType)) {
+    aValue.SetFloatValue(tk->mNumber, eCSSUnit_Number);
+    return PR_TRUE;
+  }
+  if (((aVariantMask & VARIANT_INTEGER) != 0) &&
+      (eCSSToken_Number == tk->mType) && tk->mIntegerValid) {
+    aValue.SetIntValue(tk->mInteger, eCSSUnit_Integer);
+    return PR_TRUE;
+  }
   if (((aVariantMask & (VARIANT_LENGTH | VARIANT_ANGLE |
                         VARIANT_FREQUENCY | VARIANT_TIME)) != 0 &&
        eCSSToken_Dimension == tk->mType) ||
       ((aVariantMask & (VARIANT_LENGTH | VARIANT_ZERO_ANGLE)) != 0 &&
        eCSSToken_Number == tk->mType &&
        tk->mNumber == 0.0f)) {
     if (TranslateDimension(aValue, aVariantMask, tk->mNumber, tk->mIdent)) {
       return PR_TRUE;
@@ -4377,26 +4389,16 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
     UngetToken();
     return PR_FALSE;
   }
   if (((aVariantMask & VARIANT_PERCENT) != 0) &&
       (eCSSToken_Percentage == tk->mType)) {
     aValue.SetPercentValue(tk->mNumber);
     return PR_TRUE;
   }
-  if (((aVariantMask & VARIANT_NUMBER) != 0) &&
-      (eCSSToken_Number == tk->mType)) {
-    aValue.SetFloatValue(tk->mNumber, eCSSUnit_Number);
-    return PR_TRUE;
-  }
-  if (((aVariantMask & VARIANT_INTEGER) != 0) &&
-      (eCSSToken_Number == tk->mType) && tk->mIntegerValid) {
-    aValue.SetIntValue(tk->mInteger, eCSSUnit_Integer);
-    return PR_TRUE;
-  }
   if (mNavQuirkMode && !IsParsingCompoundProperty()) { // NONSTANDARD: Nav interprets unitless numbers as px
     if (((aVariantMask & VARIANT_LENGTH) != 0) &&
         (eCSSToken_Number == tk->mType)) {
       aValue.SetFloatValue(tk->mNumber, eCSSUnit_Pixel);
       return PR_TRUE;
     }
   }
 
@@ -7134,17 +7136,23 @@ CSSParserImpl::ParseCalcTerm(nsCSSValue&
         !ExpectSymbol(')', PR_TRUE)) {
       SkipUntil(')');
       return PR_FALSE;
     }
     return PR_TRUE;
   }
   // ... or just a value
   UngetToken();
-  if (!ParseVariant(aValue, aVariantMask, nsnull)) {
+  // Always pass VARIANT_NUMBER to ParseVariant so that unitless zero
+  // always gets picked up 
+  if (!ParseVariant(aValue, aVariantMask | VARIANT_NUMBER, nsnull)) {
+    return PR_FALSE;
+  }
+  // ...and do the VARIANT_NUMBER check ourselves.
+  if (!(aVariantMask & VARIANT_NUMBER) && aValue.GetUnit() == eCSSUnit_Number) {
     return PR_FALSE;
   }
   // If we did the value parsing, we need to adjust aVariantMask to
   // reflect which option we took (see above).
   if (aVariantMask & VARIANT_NUMBER) {
     if (aValue.GetUnit() == eCSSUnit_Number) {
       aVariantMask = VARIANT_NUMBER;
     } else {
diff --git a/layout/style/test/property_database.js b/layout/style/test/property_database.js
--- a/layout/style/test/property_database.js
+++ b/layout/style/test/property_database.js
@@ -524,16 +524,32 @@ var gCSSProperties = {
 			"-moz-calc((4 / 3) * 2em)",
 
 			"-moz-calc(2em / (4 * 3))",
 			"-moz-calc(2em * (4 / 3))",
 			"-moz-calc(2em * (4 * 3))",
 			"-moz-calc(2em / (4 / 3))",
 			"-moz-calc(4 * (2em / 3))",
 
+			// Valid cases with unitless zero (which is never
+			// a length).
+			"-moz-calc(0 * 2em)",
+			"-moz-calc(2em * 0)",
+			"-moz-calc(3em + 0 * 2em)",
+			"-moz-calc(3em + 2em * 0)",
+			"-moz-calc((0 + 2) * 2em)",
+			"-moz-calc((2 + 0) * 2em)",
+			// And test zero lengths while we're here.
+			"-moz-calc(2 * 0px)",
+			"-moz-calc(0 * 0px)",
+			"-moz-calc(2 * 0em)",
+			"-moz-calc(0 * 0em)",
+			"-moz-calc(0px * 0)",
+			"-moz-calc(0px * 2)",
+
 		],
 		invalid_values: [ "20", "-1px", "red", "50%",
 			/* invalid calc() values */
 			"-moz-calc(2em+ 2px)",
 			"-moz-calc(2em +2px)",
 			"-moz-calc(2em+2px)",
 			"-moz-calc(2em- 2px)",
 			"-moz-calc(2em -2px)",
@@ -555,16 +571,30 @@ var gCSSProperties = {
 			"-moz-calc(5 * 5)",
 			"-moz-calc(5em * 5em)",
 			"-moz-calc(5em / 5em * 5em)",
 
 			"-moz-calc(4 * 3 / 2em)",
 			"-moz-calc((4 * 3) / 2em)",
 			"-moz-calc(4 * (3 / 2em))",
 			"-moz-calc(4 / (3 * 2em))",
+
+			// Tests for handling of unitless zero, which cannot
+			// be a length inside calc().
+			"-moz-calc(0)",
+			"-moz-calc(0 + 2em)",
+			"-moz-calc(2em + 0)",
+			"-moz-calc(0 * 2)",
+			"-moz-calc(2 * 0)",
+			"-moz-calc(1 * (2em + 0))",
+			"-moz-calc((2em + 0))",
+			"-moz-calc((2em + 0) * 1)",
+			"-moz-calc(1 * (0 + 2em))",
+			"-moz-calc((0 + 2em))",
+			"-moz-calc((0 + 2em) * 1)",
 		]
 	},
 	"-moz-column-rule-style": {
 		domProp: "MozColumnRuleStyle",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "none" ],
 		other_values: [ "solid", "hidden", "ridge", "groove", "inset", "outset", "double", "dotted", "dashed" ],
