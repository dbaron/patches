From: L. David Baron <dbaron@dbaron.org>

Correct handling of unitless zero in calc() expressions.  (Bug 595648)

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -4359,16 +4359,28 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
         PRInt32 value;
         if (nsCSSProps::FindKeyword(keyword, aKeywordTable, value)) {
           aValue.SetIntValue(value, eCSSUnit_Enumerated);
           return PR_TRUE;
         }
       }
     }
   }
+  // Check VARIANT_NUMBER and VARIANT_INTEGER before VARIANT_LENGTH or
+  // VARIANT_ZERO_ANGLE.
+  if (((aVariantMask & VARIANT_NUMBER) != 0) &&
+      (eCSSToken_Number == tk->mType)) {
+    aValue.SetFloatValue(tk->mNumber, eCSSUnit_Number);
+    return PR_TRUE;
+  }
+  if (((aVariantMask & VARIANT_INTEGER) != 0) &&
+      (eCSSToken_Number == tk->mType) && tk->mIntegerValid) {
+    aValue.SetIntValue(tk->mInteger, eCSSUnit_Integer);
+    return PR_TRUE;
+  }
   if (((aVariantMask & (VARIANT_LENGTH | VARIANT_ANGLE |
                         VARIANT_FREQUENCY | VARIANT_TIME)) != 0 &&
        eCSSToken_Dimension == tk->mType) ||
       ((aVariantMask & (VARIANT_LENGTH | VARIANT_ZERO_ANGLE)) != 0 &&
        eCSSToken_Number == tk->mType &&
        tk->mNumber == 0.0f)) {
     if (TranslateDimension(aValue, aVariantMask, tk->mNumber, tk->mIdent)) {
       return PR_TRUE;
@@ -4377,26 +4389,16 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
     UngetToken();
     return PR_FALSE;
   }
   if (((aVariantMask & VARIANT_PERCENT) != 0) &&
       (eCSSToken_Percentage == tk->mType)) {
     aValue.SetPercentValue(tk->mNumber);
     return PR_TRUE;
   }
-  if (((aVariantMask & VARIANT_NUMBER) != 0) &&
-      (eCSSToken_Number == tk->mType)) {
-    aValue.SetFloatValue(tk->mNumber, eCSSUnit_Number);
-    return PR_TRUE;
-  }
-  if (((aVariantMask & VARIANT_INTEGER) != 0) &&
-      (eCSSToken_Number == tk->mType) && tk->mIntegerValid) {
-    aValue.SetIntValue(tk->mInteger, eCSSUnit_Integer);
-    return PR_TRUE;
-  }
   if (mNavQuirkMode && !IsParsingCompoundProperty()) { // NONSTANDARD: Nav interprets unitless numbers as px
     if (((aVariantMask & VARIANT_LENGTH) != 0) &&
         (eCSSToken_Number == tk->mType)) {
       aValue.SetFloatValue(tk->mNumber, eCSSUnit_Pixel);
       return PR_TRUE;
     }
   }
 
@@ -7134,17 +7136,23 @@ CSSParserImpl::ParseCalcTerm(nsCSSValue&
         !ExpectSymbol(')', PR_TRUE)) {
       SkipUntil(')');
       return PR_FALSE;
     }
     return PR_TRUE;
   }
   // ... or just a value
   UngetToken();
-  if (!ParseVariant(aValue, aVariantMask, nsnull)) {
+  // Always pass VARIANT_NUMBER to ParseVariant so that unitless zero
+  // always gets picked up 
+  if (!ParseVariant(aValue, aVariantMask | VARIANT_NUMBER, nsnull)) {
+    return PR_FALSE;
+  }
+  // ...and do the VARIANT_NUMBER check ourselves.
+  if (!(aVariantMask & VARIANT_NUMBER) && aValue.GetUnit() == eCSSUnit_Number) {
     return PR_FALSE;
   }
   // If we did the value parsing, we need to adjust aVariantMask to
   // reflect which option we took (see above).
   if (aVariantMask & VARIANT_NUMBER) {
     if (aValue.GetUnit() == eCSSUnit_Number) {
       aVariantMask = VARIANT_NUMBER;
     } else {
