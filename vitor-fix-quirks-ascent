From: Vitor Menezes <vmenezes@mozilla.com>

Bug 223764: Inlines inside inlines that draw text-decorations shouldn't alter the baseline. (r=dbaron)

We add a baseline field to nsInlineFrame and modify nsLineLayout::BeginSpan to
take a pointer to a baseline to update. This also means that nsFirstLetterFrame
no longer needs to update its own baseline, and instead should just pass its own
field along.

diff --git a/layout/generic/nsFirstLetterFrame.cpp b/layout/generic/nsFirstLetterFrame.cpp
--- a/layout/generic/nsFirstLetterFrame.cpp
+++ b/layout/generic/nsFirstLetterFrame.cpp
@@ -221,39 +221,42 @@ nsFirstLetterFrame::Reflow(nsPresContext
     ll.SetInFirstLetter(PR_TRUE);
     ll.SetFirstLetterStyleOK(PR_TRUE);
 
     kid->WillReflow(aPresContext);
     kid->Reflow(aPresContext, aMetrics, rs, aReflowStatus);
 
     ll.EndLineReflow();
     ll.SetInFirstLetter(PR_FALSE);
+
+    // In the floating first-letter case, we need to set this ourselves;
+    // nsLineLayout::BeginSpan will set it in the other case
+    mBaseline = aMetrics.ascent;
   }
   else {
     // Pretend we are a span and reflow the child frame
     nsLineLayout* ll = aReflowState.mLineLayout;
     PRBool        pushedFrame;
 
     ll->SetInFirstLetter(
       mStyleContext->GetPseudo() == nsCSSPseudoElements::firstLetter);
-    ll->BeginSpan(this, &aReflowState, bp.left, availSize.width);
+    ll->BeginSpan(this, &aReflowState, bp.left, availSize.width, &mBaseline);
     ll->ReflowFrame(kid, aReflowStatus, &aMetrics, pushedFrame);
     ll->EndSpan(this);
     ll->SetInFirstLetter(PR_FALSE);
   }
 
   // Place and size the child and update the output metrics
   kid->SetRect(nsRect(bp.left, bp.top, aMetrics.width, aMetrics.height));
   kid->FinishAndStoreOverflow(&aMetrics);
   kid->DidReflow(aPresContext, nsnull, NS_FRAME_REFLOW_FINISHED);
 
   aMetrics.width += lr;
   aMetrics.height += tb;
   aMetrics.ascent += bp.top;
-  mBaseline = aMetrics.ascent;
 
   // Ensure that the overflow rect contains the child textframe's overflow rect.
   // Note that if this is floating, the overline/underline drawable area is in
   // the overflow rect of the child textframe.
   aMetrics.UnionOverflowAreasWithDesiredBounds();
   ConsiderChildOverflow(aMetrics.mOverflowAreas, kid);
 
   if (!NS_INLINE_IS_BREAK_BEFORE(aReflowStatus)) {
diff --git a/layout/generic/nsInlineFrame.cpp b/layout/generic/nsInlineFrame.cpp
--- a/layout/generic/nsInlineFrame.cpp
+++ b/layout/generic/nsInlineFrame.cpp
@@ -469,17 +469,18 @@ nsInlineFrame::ReflowFrames(nsPresContex
   }
   nscoord availableWidth = aReflowState.availableWidth;
   NS_ASSERTION(availableWidth != NS_UNCONSTRAINEDSIZE,
                "should no longer use available widths");
   // Subtract off left and right border+padding from availableWidth
   availableWidth -= leftEdge;
   availableWidth -= ltr ? aReflowState.mComputedBorderPadding.right
                         : aReflowState.mComputedBorderPadding.left;
-  lineLayout->BeginSpan(this, &aReflowState, leftEdge, leftEdge + availableWidth);
+  lineLayout->BeginSpan(this, &aReflowState, leftEdge,
+                        leftEdge + availableWidth, &mBaseline);
 
   // First reflow our current children
   nsIFrame* frame = mFrames.FirstChild();
   PRBool done = PR_FALSE;
   while (nsnull != frame) {
     PRBool reflowingFirstLetter = lineLayout->GetFirstLetterStyleOK();
 
     // Check if we should lazily set the child frame's parent pointer
@@ -908,23 +909,17 @@ nsInlineFrame::GetSkipSides() const
   }
 
   return skip;
 }
 
 nscoord
 nsInlineFrame::GetBaseline() const
 {
-  nscoord ascent = 0;
-  nsRefPtr<nsFontMetrics> fm;
-  nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
-  if (fm) {
-    ascent = fm->MaxAscent();
-  }
-  return NS_MIN(mRect.height, ascent + GetUsedBorderAndPadding().top);
+  return mBaseline;
 }
 
 #ifdef ACCESSIBILITY
 already_AddRefed<nsAccessible>
 nsInlineFrame::CreateAccessible()
 {
   // Broken image accessibles are created here, because layout
   // replaces the image or image control frame with an inline frame
diff --git a/layout/generic/nsInlineFrame.h b/layout/generic/nsInlineFrame.h
--- a/layout/generic/nsInlineFrame.h
+++ b/layout/generic/nsInlineFrame.h
@@ -189,16 +189,18 @@ protected:
   virtual nsIFrame* PullOneFrame(nsPresContext* aPresContext,
                                  InlineReflowState& rs,
                                  PRBool* aIsComplete);
 
   virtual void PushFrames(nsPresContext* aPresContext,
                           nsIFrame* aFromChild,
                           nsIFrame* aPrevSibling,
                           InlineReflowState& aState);
+
+  nscoord mBaseline;
 };
 
 //----------------------------------------------------------------------
 
 /**
  * Variation on inline-frame used to manage lines for line layout in
  * special situations (:first-line style in particular).
  */
diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -397,17 +397,18 @@ nsLineLayout::NewPerSpanData(PerSpanData
   *aResult = psd;
   return NS_OK;
 }
 
 nsresult
 nsLineLayout::BeginSpan(nsIFrame* aFrame,
                         const nsHTMLReflowState* aSpanReflowState,
                         nscoord aLeftEdge,
-                        nscoord aRightEdge)
+                        nscoord aRightEdge,
+                        nscoord* aBaseline)
 {
   NS_ASSERTION(aRightEdge != NS_UNCONSTRAINEDSIZE,
                "should no longer be using unconstrained sizes");
 #ifdef NOISY_REFLOW
   nsFrame::IndentBy(stdout, mSpanDepth+1);
   nsFrame::ListTag(stdout, aFrame);
   printf(": BeginSpan leftEdge=%d rightEdge=%d\n", aLeftEdge, aRightEdge);
 #endif
@@ -422,16 +423,17 @@ nsLineLayout::BeginSpan(nsIFrame* aFrame
 
     // Init new span
     psd->mFrame = pfd;
     psd->mParent = mCurrentSpan;
     psd->mReflowState = aSpanReflowState;
     psd->mLeftEdge = aLeftEdge;
     psd->mX = aLeftEdge;
     psd->mRightEdge = aRightEdge;
+    psd->mBaseline = aBaseline;
 
     psd->mNoWrap =
       !aSpanReflowState->frame->GetStyleText()->WhiteSpaceCanWrap();
     psd->mDirection = aSpanReflowState->mStyleVisibility->mDirection;
     psd->mChangedFrameDirection = PR_FALSE;
 
     // Switch to new span
     mCurrentSpan = psd;
@@ -1758,17 +1760,17 @@ nsLineLayout::VerticalAlignFrames(PerSpa
       // height that is outside this range.
       minY = spanFramePFD->mBorderPadding.top - psd->mTopLeading;
       maxY = minY + psd->mLogicalHeight;
     }
 
     // This is the distance from the top edge of the parents visual
     // box to the baseline. The span already computed this for us,
     // so just use it.
-    baselineY = spanFramePFD->mAscent;
+    *psd->mBaseline = baselineY = spanFramePFD->mAscent;
 
 
 #ifdef NOISY_VERTICAL_ALIGN
     printf("[%sSpan]", (psd == mRootSpan)?"Root":"");
     nsFrame::ListTag(stdout, spanFrame);
     printf(": baseLine=%d logicalHeight=%d topLeading=%d h=%d bp=%d,%d zeroEffectiveSpanBox=%s\n",
            baselineY, psd->mLogicalHeight, psd->mTopLeading,
            spanFramePFD->mBounds.height,
@@ -2135,16 +2137,17 @@ nsLineLayout::VerticalAlignFrames(PerSpa
     if (minY > 0) {
 
       // shrink the content by moving its top down.  This is tricky, since
       // the top is the 0 for many coordinates, so what we do is
       // move everything else up.
       spanFramePFD->mAscent -= minY; // move the baseline up
       spanFramePFD->mBounds.height -= minY; // move the bottom up
       psd->mTopLeading += minY;
+      *psd->mBaseline -= minY;
 
       pfd = psd->mFirstFrame;
       while (nsnull != pfd) {
         pfd->mBounds.y -= minY; // move all the children back up
         pfd->mFrame->SetRect(pfd->mBounds);
         pfd = pfd->mNext;
       }
       maxY -= minY; // since minY is in the frame's own coordinate system
diff --git a/layout/generic/nsLineLayout.h b/layout/generic/nsLineLayout.h
--- a/layout/generic/nsLineLayout.h
+++ b/layout/generic/nsLineLayout.h
@@ -98,17 +98,18 @@ public:
    * @param aFloatFrame the float frame that was placed.
    */
   void UpdateBand(const nsRect& aNewAvailableSpace,
                   nsIFrame* aFloatFrame);
 
   nsresult BeginSpan(nsIFrame* aFrame,
                      const nsHTMLReflowState* aSpanReflowState,
                      nscoord aLeftEdge,
-                     nscoord aRightEdge);
+                     nscoord aRightEdge,
+                     nscoord* aBaseline);
 
   // Returns the width of the span
   nscoord EndSpan(nsIFrame* aFrame);
 
   PRInt32 GetCurrentSpanCount() const;
 
   void SplitLineTo(PRInt32 aNewCount);
 
@@ -501,16 +502,17 @@ protected:
 
     nscoord mLeftEdge;
     nscoord mX;
     nscoord mRightEdge;
 
     nscoord mTopLeading, mBottomLeading;
     nscoord mLogicalHeight;
     nscoord mMinY, mMaxY;
+    nscoord* mBaseline;
 
     void AppendFrame(PerFrameData* pfd) {
       if (nsnull == mLastFrame) {
         mFirstFrame = pfd;
       }
       else {
         mLastFrame->mNext = pfd;
         pfd->mPrev = mLastFrame;
diff --git a/layout/reftests/text-decoration/inline-baseline-almost-standards-ref.html b/layout/reftests/text-decoration/inline-baseline-almost-standards-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/text-decoration/inline-baseline-almost-standards-ref.html
@@ -0,0 +1,10 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
+	"http://www.w3.org/TR/html4/loose.dtd">
+<html>
+	<title>test for bug 223764 (Almost-standards)</title>
+	<body>
+		<p style="overflow: hidden; padding-bottom: 20px;">
+			<span style="font-size: 100px;"><span style="font-size: 20px">hello</span></span>
+		</p>
+	</body>
+</html>
diff --git a/layout/reftests/text-decoration/inline-baseline-almost-standards.html b/layout/reftests/text-decoration/inline-baseline-almost-standards.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/text-decoration/inline-baseline-almost-standards.html
@@ -0,0 +1,10 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
+	"http://www.w3.org/TR/html4/loose.dtd">
+<html>
+	<title>test for bug 223764 (Almost-standards)</title>
+	<body>
+		<p style="overflow: hidden; padding-bottom: 20px;">
+			<span style="font-size: 100px; text-decoration:underline"><span style="font-size: 20px">hello</span></span>
+		</p>
+	</body>
+</html>
diff --git a/layout/reftests/text-decoration/inline-baseline-quirks-ref.html b/layout/reftests/text-decoration/inline-baseline-quirks-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/text-decoration/inline-baseline-quirks-ref.html
@@ -0,0 +1,8 @@
+<html>
+	<title>test for bug 223764 (Quirks)</title>
+	<body>
+		<p style="overflow: hidden; padding-bottom: 20px;">
+			<span style="font-size: 100px;"><span style="font-size: 20px">hello</span></span>
+		</p>
+	</body>
+</html>
diff --git a/layout/reftests/text-decoration/inline-baseline-quirks.html b/layout/reftests/text-decoration/inline-baseline-quirks.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/text-decoration/inline-baseline-quirks.html
@@ -0,0 +1,8 @@
+<html>
+	<title>test for bug 223764 (Quirks)</title>
+	<body>
+		<p style="overflow: hidden; padding-bottom: 20px;">
+			<span style="font-size: 100px; text-decoration:underline"><span style="font-size: 20px">hello</span></span>
+		</p>
+	</body>
+</html>
diff --git a/layout/reftests/text-decoration/reftest.list b/layout/reftests/text-decoration/reftest.list
--- a/layout/reftests/text-decoration/reftest.list
+++ b/layout/reftests/text-decoration/reftest.list
@@ -88,9 +88,11 @@ fails-if(Android) == underline-block-pro
 == table-quirk-2.html table-quirk-2-ref.html
 == text-decoration-propagation-1-quirks.html text-decoration-propagation-1-quirks-ref.html
 == text-decoration-propagation-1-standards.html text-decoration-propagation-1-standards-ref.html
 == 641444-1.html 641444-1-ref.html
 == decoration-css21.html decoration-css21-ref.html
 == decoration-color-override-quirks.html decoration-color-override-quirks-ref.html
 == decoration-color-override-standards.html decoration-color-override-standards-ref.html
 != decoration-color-override-standards-ref.html decoration-color-override-quirks-ref.html
-== decoration-css21-block.html decoration-css21-block-ref.html # bug 403524
+== decoration-css21-block.html decoration-css21-block-ref.html
+!= inline-baseline-almost-standards.html inline-baseline-almost-standards-ref.html
+!= inline-baseline-quirks.html inline-baseline-quirks-ref.html
