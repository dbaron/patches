From: L. David Baron <dbaron@dbaron.org>

Weaken the quirks mode inline box model zeroing-of-containers when those containers have children that are vertical-align: top or bottom.  (Bug 714519)

diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -2125,16 +2125,61 @@ nsLineLayout::VerticalAlignFrames(PerSpa
     printf("   [span]adjusting for zeroEffectiveSpanBox\n");
     printf("     Original: minY=%d, maxY=%d, height=%d, ascent=%d, logicalHeight=%d, topLeading=%d, bottomLeading=%d\n",
            minY, maxY, spanFramePFD->mBounds.height,
            spanFramePFD->mAscent,
            psd->mLogicalHeight, psd->mTopLeading, psd->mBottomLeading);
 #endif
     nscoord goodMinY = spanFramePFD->mBorderPadding.top - psd->mTopLeading;
     nscoord goodMaxY = goodMinY + psd->mLogicalHeight;
+
+    // For cases like the one in bug 714519 (text-decoration placement
+    // or making nsLineLayout::IsZeroHeight() handle
+    // vertical-align:top/bottom on a descendant of the line that's not
+    // a child of it), we want to treat elements that are
+    // vertical-align: top or bottom somewhat like children for the
+    // purposes of this quirk.  To some extent, this is guessing, since
+    // they might end up being aligned anywhere.  However, we'll guess
+    // that they'll be placed aligned with the top or bottom of this
+    // frame (as though this frame is the only thing in the line).
+    // (Guessing isn't crazy, since all we're doing is reducing the
+    // scope of a quirk and making the behavior more standards-like.)
+    if (maxTopBoxHeight > maxY - minY) {
+      // Distribute maxTopBoxHeight to ascent (baselineY - minY), and
+      // then to descent (maxY - baselineY) by adjusting minY or maxY,
+      // but not to exceed goodMinY and goodMaxY.
+      nscoord distribute = maxTopBoxHeight - (maxY - minY);
+      if (distribute > minY - goodMinY) {
+        distribute -= minY - goodMinY;
+        minY = goodMinY;
+        if (distribute > goodMaxY - maxY) {
+          maxY = goodMaxY;
+        } else {
+          maxY += distribute;
+        }
+      } else {
+        minY -= distribute;
+      }
+    }
+    if (maxBottomBoxHeight > maxY - minY) {
+      // Likewise, but preferring descent to ascent.
+      nscoord distribute = maxBottomBoxHeight - (maxY - minY);
+      if (distribute > goodMaxY - maxY) {
+        distribute -= goodMaxY - maxY;
+        maxY = goodMaxY;
+        if (distribute > minY - goodMinY) {
+          minY = goodMinY;
+        } else {
+          minY -= distribute;
+        }
+      } else {
+        maxY += distribute;
+      }
+    }
+
     if (minY > goodMinY) {
       nscoord adjust = minY - goodMinY; // positive
 
       // shrink the logical extents
       psd->mLogicalHeight -= adjust;
       psd->mTopLeading -= adjust;
     }
     if (maxY < goodMaxY) {
