Make GTK2 checkbox and radio widgets put their indicator spacing in GetWidgetOverflow rather than inside their size.  b=402940

diff --git a/widget/src/gtk2/gtk2drawing.c b/widget/src/gtk2/gtk2drawing.c
--- a/widget/src/gtk2/gtk2drawing.c
+++ b/widget/src/gtk2/gtk2drawing.c
@@ -47,6 +47,7 @@
 #include <gdk/gdkprivate.h>
 #include <string.h>
 #include "gtkdrawing.h"
+#include "nsDebug.h"
 
 #include <math.h>
 
@@ -797,6 +798,7 @@ moz_gtk_toggle_paint(GdkDrawable* drawab
     GtkShadowType shadow_type = (selected)?GTK_SHADOW_IN:GTK_SHADOW_OUT;
     gint indicator_size, indicator_spacing;
     gint x, y, width, height;
+    gint focus_x, focus_y, focus_width, focus_height;
     GtkWidget *w;
     GtkStyle *style;
 
@@ -808,11 +810,19 @@ moz_gtk_toggle_paint(GdkDrawable* drawab
         w = gCheckboxWidget;
     }
 
-    /* offset by indicator_spacing, and centered vertically within the rect */
-    x = rect->x + indicator_spacing;
-    y = rect->y + (rect->height - indicator_size) / 2;
+    /* centered vertically within the rect */
+    NS_ASSERTION(rect->height == indicator_size &&
+                 rect->width == indicator_size,
+                 "GetMinimumWidgetSize was ignored");
+    x = rect->x;
+    y = rect->y;
     width = indicator_size;
     height = indicator_size;
+
+    focus_x = x - indicator_spacing;
+    focus_y = y - indicator_spacing;
+    focus_width = width + 2 * indicator_spacing;
+    focus_height = height + 2 * indicator_spacing;
   
     style = w->style;
     TSOffsetStyleGCs(style, x, y);
@@ -827,8 +837,8 @@ moz_gtk_toggle_paint(GdkDrawable* drawab
                          width, height);
         if (state->focused) {
             gtk_paint_focus(style, drawable, GTK_STATE_ACTIVE, cliprect,
-                            gRadiobuttonWidget, "radiobutton", rect->x, rect->y,
-                            rect->width, rect->height);
+                            gRadiobuttonWidget, "radiobutton", focus_x, focus_y,
+                            focus_width, focus_height);
         }
     }
     else {
@@ -836,8 +846,8 @@ moz_gtk_toggle_paint(GdkDrawable* drawab
                         gCheckboxWidget, "checkbutton", x, y, width, height);
         if (state->focused) {
             gtk_paint_focus(style, drawable, GTK_STATE_ACTIVE, cliprect,
-                            gCheckboxWidget, "checkbutton", rect->x, rect->y,
-                            rect->width, rect->height);
+                            gCheckboxWidget, "checkbutton", focus_x, focus_y,
+                            focus_width, focus_height);
         }
     }
 
diff --git a/widget/src/gtk2/nsNativeThemeGTK.cpp b/widget/src/gtk2/nsNativeThemeGTK.cpp
--- a/widget/src/gtk2/nsNativeThemeGTK.cpp
+++ b/widget/src/gtk2/nsNativeThemeGTK.cpp
@@ -685,6 +685,27 @@ GetExtraSizeForWidget(PRUint8 aWidgetTyp
   case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
     aExtra->left = aExtra->right = 1;
     return PR_TRUE;
+
+  // Include the indicator spacing (the padding around the control).
+  case NS_THEME_CHECKBOX:
+  case NS_THEME_CHECKBOX_SMALL:
+  case NS_THEME_RADIO:
+  case NS_THEME_RADIO_SMALL:
+    {
+      gint indicator_size, indicator_spacing;
+
+      if (IsCheckboxWidgetType(aWidgetType)) {
+        moz_gtk_checkbox_get_metrics(&indicator_size, &indicator_spacing);
+      } else {
+        moz_gtk_radio_get_metrics(&indicator_size, &indicator_spacing);
+      }
+
+      aExtra->top = indicator_spacing;
+      aExtra->right = indicator_spacing;
+      aExtra->bottom = indicator_spacing;
+      aExtra->left = indicator_spacing;
+      return PR_TRUE;
+    }
   default:
     return PR_FALSE;
   }
@@ -777,7 +798,7 @@ nsNativeThemeGTK::DrawWidgetBackground(n
   // need to draw outside this rect if you don't feel like it!"
   GdkRectangle gdk_rect, gdk_clip;
   gfxRect gfx_rect = ConvertToGfxRect(aRect - drawingRect.TopLeft(), p2a);
-  gfxRect gfx_clip = ConvertToGfxRect(aClipRect - drawingRect.TopLeft(), p2a);
+  gfxRect gfx_clip = ConvertToGfxRect(drawingRect - drawingRect.TopLeft(), p2a);
   if (ctx->UserToDevicePixelSnapped(gfx_rect) &&
       ctx->UserToDevicePixelSnapped(gfx_clip)) {
     gfxPoint currentTranslation = current.GetTranslation();
@@ -786,7 +807,7 @@ nsNativeThemeGTK::DrawWidgetBackground(n
   }
   else {
     gdk_rect = ConvertToGdkRect(aRect - drawingRect.TopLeft(), p2a);
-    gdk_clip = ConvertToGdkRect(aClipRect - drawingRect.TopLeft(), p2a);
+    gdk_clip = ConvertToGdkRect(drawingRect - drawingRect.TopLeft(), p2a);
   }
   ThemeRenderer renderer(state, gtkWidgetType, flags, direction, gdk_rect, gdk_clip);
 
@@ -1088,8 +1109,8 @@ nsNativeThemeGTK::GetMinimumWidgetSize(n
       }
 
       // Include space for the indicator and the padding around it.
-      aResult->width = indicator_size + 2 * indicator_spacing;
-      aResult->height = indicator_size + 2 * indicator_spacing;
+      aResult->width = indicator_size;
+      aResult->height = indicator_size;
       *aIsOverridable = PR_FALSE;
     }
     break;
