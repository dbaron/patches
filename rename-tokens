From: L. David Baron <dbaron@dbaron.org>

Rename CSS tokens to be closer to the names of newly-added tokens (BAD_STRING, BAD_URI) in the CSS 2.1 tokenization.  (Bug 604179, patch 2)  r=bzbarsky

diff --git a/layout/style/nsCSSScanner.cpp b/layout/style/nsCSSScanner.cpp
--- a/layout/style/nsCSSScanner.cpp
+++ b/layout/style/nsCSSScanner.cpp
@@ -191,17 +191,17 @@ nsCSSToken::AppendToString(nsString& aBu
 {
   switch (mType) {
     case eCSSToken_AtKeyword:
       aBuffer.Append(PRUnichar('@')); // fall through intentional
     case eCSSToken_Ident:
     case eCSSToken_WhiteSpace:
     case eCSSToken_Function:
     case eCSSToken_URL:
-    case eCSSToken_InvalidURL:
+    case eCSSToken_Bad_URL:
     case eCSSToken_HTMLComment:
     case eCSSToken_URange:
       aBuffer.Append(mIdent);
       if (mType == eCSSToken_Function)
         aBuffer.Append(PRUnichar('('));
       break;
     case eCSSToken_Number:
       if (mIntegerValid) {
@@ -246,17 +246,17 @@ nsCSSToken::AppendToString(nsString& aBu
       aBuffer.AppendLiteral("^=");
       break;
     case eCSSToken_Endsmatch:
       aBuffer.AppendLiteral("$=");
       break;
     case eCSSToken_Containsmatch:
       aBuffer.AppendLiteral("*=");
       break;
-    case eCSSToken_Error:
+    case eCSSToken_Bad_String:
       aBuffer.Append(mSymbol);
       aBuffer.Append(mIdent);
       break;
     default:
       NS_ERROR("invalid token type");
       break;
   }
 }
@@ -906,22 +906,22 @@ nsCSSScanner::NextURL(nsCSSToken& aToken
     return PR_TRUE;
   }
 
   // Process a url lexical token. A CSS1 url token can contain
   // characters beyond identifier characters (e.g. '/', ':', etc.)
   // Because of this the normal rules for tokenizing the input don't
   // apply very well. To simplify the parser and relax some of the
   // requirements on the scanner we parse url's here. If we find a
-  // malformed URL then we emit a token of type "InvalidURL" so that
+  // malformed URL then we emit a token of type "Bad_URL" so that
   // the CSS1 parser can ignore the invalid input.  The parser must
-  // treat an InvalidURL token like a Function token, and process
+  // treat a Bad_URL token like a Function token, and process
   // tokens until a matching parenthesis.
 
-  aToken.mType = eCSSToken_InvalidURL;
+  aToken.mType = eCSSToken_Bad_URL;
   nsString& ident = aToken.mIdent;
   ident.SetLength(0);
 
   Pushback(ch);
 
   // start of a non-quoted url (which may be empty)
   PRBool ok = PR_TRUE;
   for (;;) {
@@ -1314,17 +1314,17 @@ nsCSSScanner::ParseString(PRInt32 aStop,
         mOffset = n;
       }
     }
     PRInt32 ch = Read();
     if (ch < 0 || ch == aStop) {
       break;
     }
     if (ch == '\n') {
-      aToken.mType = eCSSToken_Error;
+      aToken.mType = eCSSToken_Bad_String;
 #ifdef CSS_REPORT_PARSE_ERRORS
       ReportUnexpectedToken(aToken, "SEUnterminatedString");
 #endif
       break;
     }
     if (ch == CSS_ESCAPE) {
       ParseAndAppendEscape(aToken.mIdent);
     } else {
diff --git a/layout/style/nsCSSScanner.h b/layout/style/nsCSSScanner.h
--- a/layout/style/nsCSSScanner.h
+++ b/layout/style/nsCSSScanner.h
@@ -86,34 +86,33 @@ enum nsCSSTokenType {
   // Just like eCSSToken_ID, except the part following the '#' is not
   // a valid CSS identifier (eg. starts with a digit, is the empty
   // string, etc).
   eCSSToken_Ref,            // mIdent
 
   eCSSToken_Function,       // mIdent
 
   eCSSToken_URL,            // mIdent
-  eCSSToken_InvalidURL,     // doesn't matter
+  eCSSToken_Bad_URL,        // doesn't matter
 
   eCSSToken_HTMLComment,    // "<!--" or "-->"
 
   eCSSToken_Includes,       // "~="
   eCSSToken_Dashmatch,      // "|="
   eCSSToken_Beginsmatch,    // "^="
   eCSSToken_Endsmatch,      // "$="
   eCSSToken_Containsmatch,  // "*="
 
   eCSSToken_URange,         // Low in mInteger, high in mInteger2;
                             // mIntegerValid is true if the token is a
                             // valid range; mIdent preserves the textual
                             // form of the token for error reporting
 
-  // A special token indicating that there was an error in tokenization.
-  // It's always an unterminated string.
-  eCSSToken_Error           // mSymbol + mIdent
+  // An unterminated string, which is always an error.
+  eCSSToken_Bad_String      // mSymbol + mIdent
 };
 
 struct nsCSSToken {
   nsAutoString    mIdent NS_OKONHEAP;
   float           mNumber;
   PRInt32         mInteger;
   PRInt32         mInteger2;
   nsCSSTokenType  mType;
