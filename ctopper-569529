From: Craig Topper <craig.topper@gmail.com>

Make some methods of nsROCSSPrimitiveValue non-inline, and remove two unneeded QueryInterface calls.  (Bug 569529)  r=dbaron

diff --git a/layout/style/nsROCSSPrimitiveValue.cpp b/layout/style/nsROCSSPrimitiveValue.cpp
--- a/layout/style/nsROCSSPrimitiveValue.cpp
+++ b/layout/style/nsROCSSPrimitiveValue.cpp
@@ -34,24 +34,20 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* DOM object representing values in DOM computed style */
 
 #include "nsROCSSPrimitiveValue.h"
 
-#include "nsCOMPtr.h"
-#include "nsDOMError.h"
-#include "prprf.h"
-#include "nsContentUtils.h"
-#include "nsXPIDLString.h"
-#include "nsCRT.h"
 #include "nsPresContext.h"
 #include "nsStyleUtil.h"
+#include "nsDOMCSSRGBColor.h"
+#include "nsIDOMRect.h"
 
 nsROCSSPrimitiveValue::nsROCSSPrimitiveValue(PRInt32 aAppUnitsPerInch)
   : mType(CSS_PX), mAppUnitsPerInch(aAppUnitsPerInch)
 {
   mValue.mAppUnits = 0;
 }
 
 
@@ -65,17 +61,17 @@ NS_IMPL_RELEASE(nsROCSSPrimitiveValue)
 
 
 DOMCI_DATA(ROCSSPrimitiveValue, nsROCSSPrimitiveValue)
 
 // QueryInterface implementation for nsROCSSPrimitiveValue
 NS_INTERFACE_MAP_BEGIN(nsROCSSPrimitiveValue)
   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSPrimitiveValue)
   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSValue)
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMCSSPrimitiveValue)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(ROCSSPrimitiveValue)
 NS_INTERFACE_MAP_END
 
 
 // nsIDOMCSSValue
 
 
 NS_IMETHODIMP
@@ -418,23 +414,183 @@ nsROCSSPrimitiveValue::GetCounterValue(n
 NS_IMETHODIMP
 nsROCSSPrimitiveValue::GetRectValue(nsIDOMRect** aReturn)
 {
   if (mType != CSS_RECT) {
     *aReturn = nsnull;
     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
   }
   NS_ASSERTION(mValue.mRect, "mValue.mRect should never be null");
-  return CallQueryInterface(mValue.mRect, aReturn);
+  NS_ADDREF(*aReturn = mValue.mRect);
+  return NS_OK;
 }
 
 
 NS_IMETHODIMP 
 nsROCSSPrimitiveValue::GetRGBColorValue(nsIDOMRGBColor** aReturn)
 {
   if (mType != CSS_RGBCOLOR) {
     *aReturn = nsnull;
     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
   }
   NS_ASSERTION(mValue.mColor, "mValue.mColor should never be null");
-  return CallQueryInterface(mValue.mColor, aReturn);
+  NS_ADDREF(*aReturn = mValue.mColor);
+  return NS_OK;
 }
 
+void
+nsROCSSPrimitiveValue::SetNumber(float aValue)
+{
+    Reset();
+    mValue.mFloat = aValue;
+    mType = CSS_NUMBER;
+}
+
+void
+nsROCSSPrimitiveValue::SetNumber(PRInt32 aValue)
+{
+  Reset();
+  mValue.mFloat = float(aValue);
+  mType = CSS_NUMBER;
+}
+
+void
+nsROCSSPrimitiveValue::SetNumber(PRUint32 aValue)
+{
+  Reset();
+  mValue.mFloat = float(aValue);
+  mType = CSS_NUMBER;
+}
+
+void
+nsROCSSPrimitiveValue::SetPercent(float aValue)
+{
+  Reset();
+  mValue.mFloat = aValue;
+  mType = CSS_PERCENTAGE;
+}
+
+void
+nsROCSSPrimitiveValue::SetAppUnits(nscoord aValue)
+{
+  Reset();
+  mValue.mAppUnits = aValue;
+  mType = CSS_PX;
+}
+
+void
+nsROCSSPrimitiveValue::SetAppUnits(float aValue)
+{
+  SetAppUnits(NSToCoordRound(aValue));
+}
+
+void
+nsROCSSPrimitiveValue::SetIdent(nsCSSKeyword aKeyword)
+{
+  NS_PRECONDITION(aKeyword != eCSSKeyword_UNKNOWN &&
+                  0 <= aKeyword && aKeyword < eCSSKeyword_COUNT,
+                  "bad keyword");
+  Reset();
+  mValue.mKeyword = aKeyword;
+  mType = CSS_IDENT;
+}
+
+// FIXME: CSS_STRING should imply a string with "" and a need for escaping.
+void
+nsROCSSPrimitiveValue::SetString(const nsACString& aString, PRUint16 aType)
+{
+  Reset();
+  mValue.mString = ToNewUnicode(aString);
+  if (mValue.mString) {
+    mType = aType;
+  } else {
+    // XXXcaa We should probably let the caller know we are out of memory
+    mType = CSS_UNKNOWN;
+  }
+}
+
+// FIXME: CSS_STRING should imply a string with "" and a need for escaping.
+void
+nsROCSSPrimitiveValue::SetString(const nsAString& aString, PRUint16 aType)
+{
+  Reset();
+  mValue.mString = ToNewUnicode(aString);
+  if (mValue.mString) {
+    mType = aType;
+  } else {
+    // XXXcaa We should probably let the caller know we are out of memory
+    mType = CSS_UNKNOWN;
+  }
+}
+
+void
+nsROCSSPrimitiveValue::SetURI(nsIURI *aURI)
+{
+  Reset();
+  mValue.mURI = aURI;
+  NS_IF_ADDREF(mValue.mURI);
+  mType = CSS_URI;
+}
+
+void
+nsROCSSPrimitiveValue::SetColor(nsDOMCSSRGBColor* aColor)
+{
+  NS_PRECONDITION(aColor, "Null RGBColor being set!");
+  Reset();
+  mValue.mColor = aColor;
+  if (mValue.mColor) {
+    NS_ADDREF(mValue.mColor);
+    mType = CSS_RGBCOLOR;
+  }
+  else {
+    mType = CSS_UNKNOWN;
+  }
+}
+
+void
+nsROCSSPrimitiveValue::SetRect(nsIDOMRect* aRect)
+{
+  NS_PRECONDITION(aRect, "Null rect being set!");
+  Reset();
+  mValue.mRect = aRect;
+  if (mValue.mRect) {
+    NS_ADDREF(mValue.mRect);
+    mType = CSS_RECT;
+  }
+  else {
+    mType = CSS_UNKNOWN;
+  }
+}
+
+void
+nsROCSSPrimitiveValue::SetTime(float aValue)
+{
+  Reset();
+  mValue.mFloat = aValue;
+  mType = CSS_S;
+}
+
+void
+nsROCSSPrimitiveValue::Reset()
+{
+  switch (mType) {
+    case CSS_IDENT:
+      break;
+    case CSS_STRING:
+    case CSS_ATTR:
+    case CSS_COUNTER: // FIXME: Counter should use an object
+      NS_ASSERTION(mValue.mString, "Null string should never happen");
+      nsMemory::Free(mValue.mString);
+      mValue.mString = nsnull;
+      break;
+    case CSS_URI:
+      NS_IF_RELEASE(mValue.mURI);
+      break;
+    case CSS_RECT:
+      NS_ASSERTION(mValue.mRect, "Null Rect should never happen");
+      NS_RELEASE(mValue.mRect);
+      break;
+    case CSS_RGBCOLOR:
+      NS_ASSERTION(mValue.mColor, "Null RGBColor should never happen");
+      NS_RELEASE(mValue.mColor);
+      break;
+  }
+}
diff --git a/layout/style/nsROCSSPrimitiveValue.h b/layout/style/nsROCSSPrimitiveValue.h
--- a/layout/style/nsROCSSPrimitiveValue.h
+++ b/layout/style/nsROCSSPrimitiveValue.h
@@ -36,189 +36,53 @@
  * ***** END LICENSE BLOCK ***** */
 
 /* DOM object representing values in DOM computed style */
 
 #ifndef nsROCSSPrimitiveValue_h___
 #define nsROCSSPrimitiveValue_h___
 
 #include "nsIDOMCSSPrimitiveValue.h"
-#include "nsString.h"
 #include "nsCoord.h"
-#include "nsReadableUtils.h"
-#include "nsIURI.h"
-#include "nsIAtom.h"
 #include "nsCSSKeywords.h"
 
-#include "nsCOMPtr.h"
-#include "nsDOMError.h"
-#include "nsDOMCSSRect.h"
-#include "nsDOMCSSRGBColor.h"
+class nsIURI;
+class nsDOMCSSRGBColor;
 
 class nsROCSSPrimitiveValue : public nsIDOMCSSPrimitiveValue
 {
 public:
   NS_DECL_ISUPPORTS
 
   // nsIDOMCSSPrimitiveValue
   NS_DECL_NSIDOMCSSPRIMITIVEVALUE
 
   // nsIDOMCSSValue
   NS_DECL_NSIDOMCSSVALUE
 
   // nsROCSSPrimitiveValue
   nsROCSSPrimitiveValue(PRInt32 aAppUnitsPerInch);
   virtual ~nsROCSSPrimitiveValue();
 
-  // FIXME Many of these methods should be out-of-line.
-
-  void SetNumber(float aValue)
-  {
-    Reset();
-    mValue.mFloat = aValue;
-    mType = CSS_NUMBER;
-  }
-
-  void SetNumber(PRInt32 aValue)
-  {
-    Reset();
-    mValue.mFloat = float(aValue);
-    mType = CSS_NUMBER;
-  }
-
-  void SetNumber(PRUint32 aValue)
-  {
-    Reset();
-    mValue.mFloat = float(aValue);
-    mType = CSS_NUMBER;
-  }
-
-  void SetPercent(float aValue)
-  {
-    Reset();
-    mValue.mFloat = aValue;
-    mType = CSS_PERCENTAGE;
-  }
-
-  void SetAppUnits(nscoord aValue)
-  {
-    Reset();
-    mValue.mAppUnits = aValue;
-    mType = CSS_PX;
-  }
-
-  void SetAppUnits(float aValue)
-  {
-    SetAppUnits(NSToCoordRound(aValue));
-  }
-
-  void SetIdent(nsCSSKeyword aKeyword)
-  {
-    NS_PRECONDITION(aKeyword != eCSSKeyword_UNKNOWN &&
-                    0 <= aKeyword && aKeyword < eCSSKeyword_COUNT,
-                    "bad keyword");
-    Reset();
-    mValue.mKeyword = aKeyword;
-    mType = CSS_IDENT;
-  }
-
+  void SetNumber(float aValue);
+  void SetNumber(PRInt32 aValue);
+  void SetNumber(PRUint32 aValue);
+  void SetPercent(float aValue);
+  void SetAppUnits(nscoord aValue);
+  void SetAppUnits(float aValue);
+  void SetIdent(nsCSSKeyword aKeyword);
   // FIXME: CSS_STRING should imply a string with "" and a need for escaping.
-  void SetString(const nsACString& aString, PRUint16 aType = CSS_STRING)
-  {
-    Reset();
-    mValue.mString = ToNewUnicode(aString);
-    if (mValue.mString) {
-      mType = aType;
-    } else {
-      // XXXcaa We should probably let the caller know we are out of memory
-      mType = CSS_UNKNOWN;
-    }
-  }
-
+  void SetString(const nsACString& aString, PRUint16 aType = CSS_STRING);
   // FIXME: CSS_STRING should imply a string with "" and a need for escaping.
-  void SetString(const nsAString& aString, PRUint16 aType = CSS_STRING)
-  {
-    Reset();
-    mValue.mString = ToNewUnicode(aString);
-    if (mValue.mString) {
-      mType = aType;
-    } else {
-      // XXXcaa We should probably let the caller know we are out of memory
-      mType = CSS_UNKNOWN;
-    }
-  }
-
-  void SetURI(nsIURI *aURI)
-  {
-    Reset();
-    mValue.mURI = aURI;
-    NS_IF_ADDREF(mValue.mURI);
-    mType = CSS_URI;
-  }
-
-  void SetColor(nsDOMCSSRGBColor* aColor)
-  {
-    NS_PRECONDITION(aColor, "Null RGBColor being set!");
-    Reset();
-    mValue.mColor = aColor;
-    if (mValue.mColor) {
-      NS_ADDREF(mValue.mColor);
-      mType = CSS_RGBCOLOR;
-    }
-    else {
-      mType = CSS_UNKNOWN;
-    }
-  }
-
-  void SetRect(nsIDOMRect* aRect)
-  {
-    NS_PRECONDITION(aRect, "Null rect being set!");
-    Reset();
-    mValue.mRect = aRect;
-    if (mValue.mRect) {
-      NS_ADDREF(mValue.mRect);
-      mType = CSS_RECT;
-    }
-    else {
-      mType = CSS_UNKNOWN;
-    }
-  }
-
-  void SetTime(float aValue)
-  {
-    Reset();
-    mValue.mFloat = aValue;
-    mType = CSS_S;
-  }
-
-  void Reset(void)
-  {
-    switch (mType) {
-      case CSS_IDENT:
-        break;
-      case CSS_STRING:
-      case CSS_ATTR:
-      case CSS_COUNTER: // FIXME: Counter should use an object
-        NS_ASSERTION(mValue.mString, "Null string should never happen");
-        nsMemory::Free(mValue.mString);
-        mValue.mString = nsnull;
-        break;
-      case CSS_URI:
-        NS_IF_RELEASE(mValue.mURI);
-        break;
-      case CSS_RECT:
-        NS_ASSERTION(mValue.mRect, "Null Rect should never happen");
-        NS_RELEASE(mValue.mRect);
-        break;
-      case CSS_RGBCOLOR:
-        NS_ASSERTION(mValue.mColor, "Null RGBColor should never happen");
-        NS_RELEASE(mValue.mColor);
-        break;
-    }
-  }
+  void SetString(const nsAString& aString, PRUint16 aType = CSS_STRING);
+  void SetURI(nsIURI *aURI);
+  void SetColor(nsDOMCSSRGBColor* aColor);
+  void SetRect(nsIDOMRect* aRect);
+  void SetTime(float aValue);
+  void Reset();
 
 private:
   PRUint16 mType;
 
   union {
     nscoord         mAppUnits;
     float           mFloat;
     nsDOMCSSRGBColor* mColor;
