From: L. David Baron <dbaron@dbaron.org>

Add comment about ways we could do blitting in more cases involving SVG and SVG effects.

diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -1631,16 +1631,36 @@ static void AdjustViews(nsIFrame* aFrame
 static bool
 CanScrollWithBlitting(nsIFrame* aFrame)
 {
   if (aFrame->GetStateBits() & NS_SCROLLFRAME_INVALIDATE_CONTENTS_ON_SCROLL)
     return false;
 
   for (nsIFrame* f = aFrame; f;
        f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
+    // FIXME: This makes us avoid blitting in a number of cases where we
+    // really could blit.  For example:
+    //  (1) something inside HTML using an SVG filter that makes only
+    //      color transformations
+    //  (2) something inside an svg:foreignObject that is
+    //      non-transformed (i.e., in an SVG without a viewBox, and with
+    //      no transforms)
+    // We could optimize a number of these cases by, instead of doing
+    // this, searching for any frames that have a:
+    //   (a) mask or clip-path (SVG or non-SVG)
+    //   (b) SVG filter that makes transformations that move pixels
+    //   (c) anything with a transform or a transform implied by a
+    //       viewBox
+    // However, we can't quite do much of this yet because we don't
+    // actually do display list analysis on SVG content, and therefore
+    // we don't know if content inside of SVG is on top of a non-uniform
+    // background.
+    //
+    // However, we could fix it for color-only filters in non-SVG
+    // content.
     if (nsSVGIntegrationUtils::UsingEffectsForFrame(f) ||
         f->IsFrameOfType(nsIFrame::eSVG)) {
       return false;
     }
     nsIScrollableFrame* sf = do_QueryFrame(f);
     if ((sf || f->IsFrameOfType(nsIFrame::eReplaced)) &&
         nsLayoutUtils::HasNonZeroCorner(f->GetStyleBorder()->mBorderRadius))
       return false;
