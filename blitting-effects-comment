From: L. David Baron <dbaron@dbaron.org>

Add comment about ways we could do blitting in more cases involving SVG and SVG effects.

diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -1502,16 +1502,36 @@ static PRBool
 CanScrollWithBlitting(nsIFrame* aFrame, nsIFrame* aDisplayRoot)
 {
   for (nsIFrame* f = aFrame; f;
        f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
     if (f->GetStyleDisplay()->HasTransform()) {
       return PR_FALSE;
     }
 #ifdef MOZ_SVG
+    // FIXME: This makes us avoid blitting in a number of cases where we
+    // really could blit.  For example:
+    //  (1) something inside HTML using an SVG filter that makes only
+    //      color transformations
+    //  (2) something inside an svg:foreignObject that is
+    //      non-transformed (i.e., in an SVG without a viewBox, and with
+    //      no transforms)
+    // We could optimize a number of these cases by, instead of doing
+    // this, searching for any frames that have a:
+    //   (a) mask or clip-path (SVG or non-SVG)
+    //   (b) SVG filter that makes transformations that move pixels
+    //   (c) anything with a transform or a transform implied by a
+    //       viewBox
+    // However, we can't quite do much of this yet because we don't
+    // actually do display list analysis on SVG content, and therefore
+    // we don't know if content inside of SVG is on top of a non-uniform
+    // background.
+    //
+    // However, we could fix it for color-only filters in non-SVG
+    // content.
     if (nsSVGIntegrationUtils::UsingEffectsForFrame(f) ||
         f->IsFrameOfType(nsIFrame::eSVG)) {
       return PR_FALSE;
     }
 #endif
     if (f == aDisplayRoot)
       break;
   }
