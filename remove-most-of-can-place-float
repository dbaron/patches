From: L. David Baron <dbaron@dbaron.org>

Most of CanPlaceFloat is unnecessary given the float placement rules and the fact that we now split floats.  (Bug 563584)  (FIXME:  Needs better comments, and a check through the removed code)  (FIXME: add tests)

diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -620,112 +620,21 @@ nsBlockReflowState::AddFloat(nsLineLayou
 
   // Restore coordinate system
   mFloatManager->Translate(dx, dy);
 
   return placed;
 }
 
 PRBool
-nsBlockReflowState::CanPlaceFloat(const nsSize& aFloatSize, PRUint8 aFloats,
+nsBlockReflowState::CanPlaceFloat(nscoord aFloatWidth,
                                   const nsFlowAreaRect& aFloatAvailableSpace)
 {
-  // If the current Y coordinate is not impacted by any floats
-  // then by definition the float fits.
-  PRBool result = PR_TRUE;
-  if (aFloatAvailableSpace.mHasFloats) {
-    // XXX We should allow overflow by up to half a pixel here (bug 21193).
-    if (aFloatAvailableSpace.mRect.width < aFloatSize.width) {
-      // The available width is too narrow (and it's been impacted by a
-      // prior float)
-      result = PR_FALSE;
-    }
-  }
-
-  if (!result)
-    return result;
-
-  // At this point we know that there is enough horizontal space for
-  // the float (somewhere). Lets see if there is enough vertical
-  // space.
-  if (NSCoordGreaterThan(aFloatSize.height,
-                         aFloatAvailableSpace.mRect.height)) {
-    // The available height is too short. However, it's possible that
-    // there is enough open space below which is not impacted by a
-    // float.
-    //
-    // Compute the X coordinate for the float based on its float
-    // type, assuming it's placed on the current line. This is
-    // where the float will be placed horizontally if it can go
-    // here.
-    nscoord xa;
-    if (NS_STYLE_FLOAT_LEFT == aFloats) {
-      xa = aFloatAvailableSpace.mRect.x;
-    }
-    else {
-      xa = aFloatAvailableSpace.mRect.XMost() - aFloatSize.width;
-
-      // In case the float is too big, don't go past the left edge
-      // XXXldb This seems wrong, but we might want to fix bug 6976
-      // first.
-      if (xa < aFloatAvailableSpace.mRect.x) {
-        xa = aFloatAvailableSpace.mRect.x;
-      }
-    }
-    nscoord xb = xa + aFloatSize.width;
-
-    // Calculate the top and bottom y coordinates, again assuming
-    // that the float is placed on the current line.
-    const nsMargin& borderPadding = BorderPadding();
-    nscoord ya = mY - borderPadding.top;
-    if (ya < 0) {
-      // CSS2 spec, 9.5.1 rule [4]: "A floating box's outer top may not
-      // be higher than the top of its containing block."  (Since the
-      // containing block is the content edge of the block box, this
-      // means the margin edge of the float can't be higher than the
-      // content edge of the block that contains it.)
-      ya = 0;
-    }
-    nscoord yb = ya + aFloatSize.height;
-
-    nscoord saveY = mY;
-    nsFlowAreaRect floatAvailableSpace(aFloatAvailableSpace);
-    for (;;) {
-      // Get the available space at the new Y coordinate
-      if (floatAvailableSpace.mRect.height <= 0) {
-        // there is no more available space. We lose.
-        result = PR_FALSE;
-        break;
-      }
-
-      mY += floatAvailableSpace.mRect.height;
-      floatAvailableSpace = GetFloatAvailableSpace(mY);
-
-      if (floatAvailableSpace.mHasFloats) {
-        if (xa < floatAvailableSpace.mRect.x ||
-            xb > floatAvailableSpace.mRect.XMost()) {
-          // The float can't go here.
-          result = PR_FALSE;
-          break;
-        }
-      }
-
-      // See if there is now enough height for the float.
-      if (yb <= mY + floatAvailableSpace.mRect.height) {
-        // Winner. The bottom Y coordinate of the float is in
-        // this band.
-        break;
-      }
-    }
-
-    // Restore Y coordinate
-    mY = saveY;
-  }
-
-  return result;
+  return !aFloatAvailableSpace.mHasFloats ||
+         aFloatAvailableSpace.mRect.width >= aFloatWidth;
 }
 
 PRBool
 nsBlockReflowState::FlowAndPlaceFloat(nsIFrame*       aFloat,
                                       nsReflowStatus& aReflowStatus)
 {
   aReflowStatus = NS_FRAME_COMPLETE;
   // Save away the Y coordinate before placing the float. We will
@@ -786,18 +695,17 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
   // block if possible (CSS2 spec section 9.5.1, see the rule list).
   NS_ASSERTION((NS_STYLE_FLOAT_LEFT == floatDisplay->mFloats) ||
 	       (NS_STYLE_FLOAT_RIGHT == floatDisplay->mFloats),
 	       "invalid float type");
 
   // Can the float fit here?
   PRBool keepFloatOnSameLine = PR_FALSE;
 
-  while (!CanPlaceFloat(floatSize, floatDisplay->mFloats,
-                        floatAvailableSpace)) {
+  while (!CanPlaceFloat(floatSize.width, floatAvailableSpace)) {
     if (floatAvailableSpace.mRect.height <= 0) {
       // No space, nowhere to put anything.
       mY = saveY;
       return PR_FALSE;
     }
 
     // Nope. try to advance to the next band.
     if (NS_STYLE_DISPLAY_TABLE != floatDisplay->mDisplay ||
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -103,17 +103,17 @@ public:
    * space.
    * aLineLayout is null when we are reflowing float continuations (because
    * they are not associated with a line box).
    */
   PRBool AddFloat(nsLineLayout*       aLineLayout,
                   nsIFrame*           aFloat,
                   nscoord             aAvailableWidth,
                   nsReflowStatus&     aReflowStatus);
-  PRBool CanPlaceFloat(const nsSize& aFloatSize, PRUint8 aFloats,
+  PRBool CanPlaceFloat(nscoord aFloatWidth,
                        const nsFlowAreaRect& aFloatAvailableSpace);
   PRBool FlowAndPlaceFloat(nsIFrame*       aFloat,
                            nsReflowStatus& aReflowStatus);
   PRBool PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aFloats);
 
   // Returns the first coordinate >= aY that clears the
   // floats indicated by aBreakType and has enough width between floats
   // (or no floats remaining) to accomodate aReplacedBlock.
