From: L. David Baron <dbaron@dbaron.org>

Make gAliases be just an array of ids.  (Bug 849656, patch 4)  r=bzbarsky

diff --git a/layout/style/nsCSSProps.cpp b/layout/style/nsCSSProps.cpp
--- a/layout/style/nsCSSProps.cpp
+++ b/layout/style/nsCSSProps.cpp
@@ -78,24 +78,20 @@ SortPropertyAndCount(const void* s1, con
 }
 
 // We need eCSSAliasCount so we can make gAliases nonzero size when there
 // are no aliases.
 enum {
   eCSSAliasCount = eCSSProperty_COUNT_with_aliases - eCSSProperty_COUNT
 };
 
-struct CSSPropertyAlias {
-  const nsCSSProperty id;
-};
-
 // The names are in kCSSRawProperties.
-static CSSPropertyAlias gAliases[eCSSAliasCount != 0 ? eCSSAliasCount : 1] = {
+static nsCSSProperty gAliases[eCSSAliasCount != 0 ? eCSSAliasCount : 1] = {
 #define CSS_PROP_ALIAS(aliasname_, propid_, aliasmethod_, pref_)  \
-  { eCSSProperty_##propid_ },
+  eCSSProperty_##propid_ ,
 #include "nsCSSPropAliasList.h"
 #undef CSS_PROP_ALIAS
 };
 
 void
 nsCSSProps::AddRefTable(void)
 {
   if (0 == gTableRefCount++) {
@@ -357,19 +353,20 @@ nsCSSProps::LookupProperty(const nsACStr
   NS_ABORT_IF_FALSE(gPropertyTable, "no lookup table, needs addref");
 
   nsCSSProperty res = nsCSSProperty(gPropertyTable->Lookup(aProperty));
   // Check eCSSAliasCount against 0 to make it easy for the
   // compiler to optimize away the 0-aliases case.
   if (eCSSAliasCount != 0 && res >= eCSSProperty_COUNT) {
     MOZ_STATIC_ASSERT(eCSSProperty_UNKNOWN < eCSSProperty_COUNT,
                       "assuming eCSSProperty_UNKNOWN doesn't hit this code");
-    const CSSPropertyAlias &alias = gAliases[res - eCSSProperty_COUNT];
     if (IsEnabled(res) || aEnabled == eAny) {
-      res = alias.id;
+      res = gAliases[res - eCSSProperty_COUNT];
+      NS_ABORT_IF_FALSE(0 <= res && res < eCSSProperty_COUNT,
+                        "aliases must not point to other aliases");
     } else {
       res = eCSSProperty_UNKNOWN;
     }
   }
   if (res != eCSSProperty_UNKNOWN && aEnabled == eEnabled && !IsEnabled(res)) {
     res = eCSSProperty_UNKNOWN;
   }
   return res;
@@ -383,19 +380,20 @@ nsCSSProps::LookupProperty(const nsAStri
   // converting and avoid a PromiseFlatCString() call.
   NS_ABORT_IF_FALSE(gPropertyTable, "no lookup table, needs addref");
   nsCSSProperty res = nsCSSProperty(gPropertyTable->Lookup(aProperty));
   // Check eCSSAliasCount against 0 to make it easy for the
   // compiler to optimize away the 0-aliases case.
   if (eCSSAliasCount != 0 && res >= eCSSProperty_COUNT) {
     MOZ_STATIC_ASSERT(eCSSProperty_UNKNOWN < eCSSProperty_COUNT,
                       "assuming eCSSProperty_UNKNOWN doesn't hit this code");
-    const CSSPropertyAlias &alias = gAliases[res - eCSSProperty_COUNT];
     if (IsEnabled(res) || aEnabled == eAny) {
-      res = alias.id;
+      res = gAliases[res - eCSSProperty_COUNT];
+      NS_ABORT_IF_FALSE(0 <= res && res < eCSSProperty_COUNT,
+                        "aliases must not point to other aliases");
     } else {
       res = eCSSProperty_UNKNOWN;
     }
   }
   if (res != eCSSProperty_UNKNOWN && aEnabled == eEnabled && !IsEnabled(res)) {
     res = eCSSProperty_UNKNOWN;
   }
   return res;
