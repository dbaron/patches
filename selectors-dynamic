Fix handling of dynamic changes for advanced CSS selectors (and avoid the cost of doing so in the normal case).  b=401291, 75386, 98997, 229915, 404418 (blocking1.9+)

diff --git a/content/base/public/nsINode.h b/content/base/public/nsINode.h
--- a/content/base/public/nsINode.h
+++ b/content/base/public/nsINode.h
@@ -101,9 +101,30 @@ enum {
 
   NODE_SCRIPT_TYPE_SIZE =                  4,
 
+  // Node has an :empty or :-moz-only-whitespace selector
+  NODE_HAS_EMPTY_SELECTOR =      0x00010000U,
+
+  // A child of the node has a selector such that any insertion,
+  // removal, or appending of children requires restyling the parent.
+  NODE_HAS_SLOW_SELECTOR =       0x00020000U,
+
+  // A child of the node has a :first-child, :-moz-first-node,
+  // :only-child, :last-child or :-moz-last-node selector.
+  NODE_HAS_EDGE_CHILD_SELECTOR = 0x00040000U,
+
+  // A child of the node has a selector such that any insertion or
+  // removal of children requires restyling the parent (but append is
+  // OK).
+  NODE_HAS_SLOW_SELECTOR_NOAPPEND
+                               = 0x00080000U,
+
+  NODE_ALL_SELECTOR_FLAGS =      NODE_HAS_EMPTY_SELECTOR |
+                                 NODE_HAS_SLOW_SELECTOR |
+                                 NODE_HAS_EDGE_CHILD_SELECTOR |
+                                 NODE_HAS_SLOW_SELECTOR_NOAPPEND,
+
   // Remaining bits are node type specific.
-  NODE_TYPE_SPECIFIC_BITS_OFFSET =
-    NODE_SCRIPT_TYPE_OFFSET + NODE_SCRIPT_TYPE_SIZE
+  NODE_TYPE_SPECIFIC_BITS_OFFSET = 20
 };
 
 // Useful inline function for getting a node given an nsIContent and an
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -120,6 +120,7 @@
 #include "nsContentErrors.h"
 #include "nsIPrincipal.h"
 #include "nsIDOMWindowInternal.h"
+#include "nsStyleUtil.h"
 
 #include "nsBox.h"
 
@@ -152,7 +153,6 @@ NS_NewHTMLCanvasFrame (nsIPresShell* aPr
 
 #ifdef MOZ_SVG
 #include "nsISVGTextContentMetrics.h"
-#include "nsStyleUtil.h"
 
 PRBool
 NS_SVGEnabled();
@@ -8533,6 +8533,8 @@ nsCSSFrameConstructor::ContentAppended(n
   }
 #endif
 
+  RestyleForAppend(aContainer, aNewIndexInContainer);
+
 #ifdef MOZ_XUL
   if (aContainer) {
     PRInt32 namespaceID;
@@ -8906,6 +8908,8 @@ nsCSSFrameConstructor::ContentInserted(n
   }
 #endif
 
+  RestyleForInsertOrChange(aContainer, aChild);
+
   nsresult rv = NS_OK;
 
 #ifdef MOZ_XUL
@@ -9476,6 +9480,8 @@ nsCSSFrameConstructor::ContentRemoved(ns
   }
 #endif
 
+  RestyleForRemove(aContainer, aChild, aIndexInContainer);
+
   nsFrameManager *frameManager = mPresShell->FrameManager();
   nsPresContext *presContext = mPresShell->GetPresContext();
   nsresult                  rv = NS_OK;
@@ -9900,6 +9906,19 @@ nsCSSFrameConstructor::CharacterDataChan
 {
   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
   nsresult      rv = NS_OK;
+
+  nsIContent *container = aContent->GetParent();
+  PRUint32 selectorFlags =
+    container ? (container->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
+  if (selectorFlags != 0) {
+    PRUint32 index;
+    if (aAppend &&
+        container->GetChildAt((index = container->GetChildCount() - 1)) ==
+          aContent)
+      RestyleForAppend(container, index);
+    else
+      RestyleForInsertOrChange(container, aContent);
+  }
 
   // Find the child frame
   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(aContent);
@@ -13135,6 +13154,178 @@ nsresult nsCSSFrameConstructor::RemoveFi
   return rv;
 }
 
+void
+nsCSSFrameConstructor::RestyleForAppend(nsIContent* aContainer,
+                                        PRInt32 aNewIndexInContainer)
+{
+  PRUint32 selectorFlags = aContainer ?
+    (aContainer->GetFlags() & (NODE_ALL_SELECTOR_FLAGS &
+                               ~NODE_HAS_SLOW_SELECTOR_NOAPPEND)) : 0;
+  if (selectorFlags != 0) {
+    if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
+      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+    } else {
+      if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
+        // see if we need to restyle the container
+        PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
+        for (PRInt32 index = 0; index < aNewIndexInContainer; ++index) {
+          if (nsStyleUtil::IsSignificantChild(aContainer->GetChildAt(index),
+                                              PR_TRUE, PR_FALSE)) {
+            wasEmpty = PR_FALSE;
+            break;
+          }
+        }
+        if (wasEmpty) {
+          PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+        }
+      }
+      if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
+        // restyle the last element child before this node
+        for (PRInt32 index = aNewIndexInContainer - 1; index >= 0; --index) {
+          nsIContent *content = aContainer->GetChildAt(index);
+          if (content->IsNodeOfType(nsINode::eELEMENT)) {
+            PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
+            break;
+          }
+        }
+      }
+    }
+  }
+}
+
+// Restyling for a ContentInserted or CharacterDataChanged notification.
+// This could be used for ContentRemoved as well if we got the
+// notification before the removal happened (and sometimes
+// CharacterDataChanged is more like a removal than an addition).
+// The comments are written and variables are named in terms of it being
+// a ContentInserted notification.
+void
+nsCSSFrameConstructor::RestyleForInsertOrChange(nsIContent* aContainer,
+                                                nsIContent* aChild)
+{
+  PRUint32 selectorFlags =
+    aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
+  if (selectorFlags != 0) {
+    if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
+                         NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
+      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+    } else {
+      if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
+        // see if we need to restyle the container
+        PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
+        for (PRInt32 index = 0; ; ++index) {
+          nsIContent *child = aContainer->GetChildAt(index);
+          if (!child) // last child
+            break;
+          if (child == aChild)
+            continue;
+          if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
+            wasEmpty = PR_FALSE;
+            break;
+          }
+        }
+        if (wasEmpty) {
+          PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+        }
+      }
+      if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
+        // restyle the previously-first element child if it is after this node
+        PRBool passedChild = PR_FALSE;
+        for (PRInt32 index = 0; ; ++index) {
+          nsIContent *content = aContainer->GetChildAt(index);
+          if (!content)
+            break; // went through all children
+          if (content == aChild) {
+            passedChild = PR_TRUE;
+            continue;
+          }
+          if (content->IsNodeOfType(nsINode::eELEMENT)) {
+            if (passedChild) {
+              PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
+            }
+            break;
+          }
+        }
+        // restyle the previously-last element child if it is before this node
+        passedChild = PR_FALSE;
+        for (PRInt32 index = aContainer->GetChildCount() - 1;
+             index >= 0; --index) {
+          nsIContent *content = aContainer->GetChildAt(index);
+          if (content == aChild) {
+            passedChild = PR_TRUE;
+            continue;
+          }
+          if (content->IsNodeOfType(nsINode::eELEMENT)) {
+            if (passedChild) {
+              PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
+            }
+            break;
+          }
+        }
+      }
+    }
+  }
+}
+
+void
+nsCSSFrameConstructor::RestyleForRemove(nsIContent* aContainer,
+                                        nsIContent* aOldChild,
+                                        PRInt32 aIndexInContainer)
+{
+  PRUint32 selectorFlags =
+    aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
+  if (selectorFlags != 0) {
+    if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
+                         NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
+      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+    } else {
+      if ((selectorFlags & NODE_HAS_EMPTY_SELECTOR) &&
+          nsStyleUtil::IsSignificantChild(aOldChild, PR_TRUE, PR_FALSE)) {
+        // see if we need to restyle the container
+        PRBool isEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
+        for (PRInt32 index = 0; ; ++index) {
+          nsIContent *child = aContainer->GetChildAt(index);
+          if (!child) // last child
+            break;
+          if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
+            isEmpty = PR_FALSE;
+            break;
+          }
+        }
+        if (isEmpty) {
+          PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+        }
+      }
+      if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
+        // restyle the previously-first element child if it is after aOldChild
+        for (PRInt32 index = 0; ; ++index) {
+          nsIContent *content = aContainer->GetChildAt(index);
+          if (!content)
+            break; // went through all children
+          if (content->IsNodeOfType(nsINode::eELEMENT)) {
+            if (index >= aIndexInContainer) {
+              PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
+            }
+            break;
+          }
+        }
+        // restyle the previously-last element child if it is before aOldChild
+        for (PRInt32 index = aContainer->GetChildCount() - 1;
+             index >= 0; --index) {
+          nsIContent *content = aContainer->GetChildAt(index);
+          if (content->IsNodeOfType(nsINode::eELEMENT)) {
+            if (index < aIndexInContainer) {
+              PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
+            }
+            break;
+          }
+        }
+      }
+    }
+  }
+}
+
+
 PR_STATIC_CALLBACK(PLDHashOperator)
 CollectRestyles(nsISupports* aContent,
                 nsCSSFrameConstructor::RestyleData& aData,
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -169,6 +169,19 @@ private:
   // itself.
   void ProcessOneRestyle(nsIContent* aContent, nsReStyleHint aRestyleHint,
                          nsChangeHint aChangeHint);
+
+  // Restyling for a ContentInserted (notification after insertion) or
+  // for a CharacterDataChanged.
+  void RestyleForInsertOrChange(nsIContent* aContainer,
+                                nsIContent* aChild);
+  // This would be the same as RestyleForInsertOrChange if we got the
+  // notification before the removal.  However, we get it after, so we
+  // have to use the index.
+  void RestyleForRemove(nsIContent* aContainer, nsIContent* aOldChild,
+                        PRInt32 aIndexInContainer);
+  // Same for a ContentAppended.
+  void RestyleForAppend(nsIContent* aContainer,
+                        PRInt32 aNewIndexInContainer);
 
 public:
   // Note: It's the caller's responsibility to make sure to wrap a
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -986,21 +986,12 @@ inline PRBool IsQuirkEventSensitive(nsIA
 }
 
 
-static PRBool IsSignificantChild(nsIContent* aChild, PRBool aTextIsSignificant, PRBool aWhitespaceIsSignificant)
+static inline PRBool
+IsSignificantChild(nsIContent* aChild, PRBool aTextIsSignificant,
+                   PRBool aWhitespaceIsSignificant)
 {
-  NS_ASSERTION(!aWhitespaceIsSignificant || aTextIsSignificant,
-               "Nonsensical arguments");
-
-  PRBool isText = aChild->IsNodeOfType(nsINode::eTEXT);
-
-  if (!isText && !aChild->IsNodeOfType(nsINode::eCOMMENT) &&
-      !aChild->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION)) {
-    return PR_TRUE;
-  }
-
-  return aTextIsSignificant && isText && aChild->TextLength() != 0 &&
-         (aWhitespaceIsSignificant ||
-          !aChild->TextIsOnlyWhitespace());
+  return nsStyleUtil::IsSignificantChild(aChild, aTextIsSignificant,
+                                         aWhitespaceIsSignificant);
 }
 
 // This function is to be called once we have fetched a value for an attribute
@@ -1064,6 +1055,12 @@ static PRBool SelectorMatches(RuleProces
 
   PRBool result = PR_TRUE;
   const PRBool isNegated = (aDependence != nsnull);
+  // The selectors for which we set node bits are, unfortunately, early
+  // in this function (because they're pseudo-classes, which are
+  // generally quick to test, and thus earlier).  If they were later,
+  // we'd probably avoid setting those bits in more cases where setting
+  // them is unnecessary.
+  const PRBool setNodeFlags = aStateMask == 0 && !aAttribute;
 
   // test for pseudo class match
   // first-child, root, lang, active, focus, hover, link, visited...
@@ -1076,6 +1073,9 @@ static PRBool SelectorMatches(RuleProces
       nsIContent *firstChild = nsnull;
       nsIContent *parent = data.mParentContent;
       if (parent) {
+        if (setNodeFlags)
+          parent->SetFlags(NODE_HAS_EDGE_CHILD_SELECTOR);
+
         PRBool acceptNonWhitespace =
           nsCSSPseudoClasses::firstNode == pseudoClass->mAtom;
         PRInt32 index = -1;
@@ -1093,6 +1093,9 @@ static PRBool SelectorMatches(RuleProces
       nsIContent *lastChild = nsnull;
       nsIContent *parent = data.mParentContent;
       if (parent) {
+        if (setNodeFlags)
+          parent->SetFlags(NODE_HAS_EDGE_CHILD_SELECTOR);
+
         PRBool acceptNonWhitespace =
           nsCSSPseudoClasses::lastNode == pseudoClass->mAtom;
         PRUint32 index = parent->GetChildCount();
@@ -1110,6 +1113,9 @@ static PRBool SelectorMatches(RuleProces
       nsIContent *moreChild = nsnull;
       nsIContent *parent = data.mParentContent;
       if (parent) {
+        if (setNodeFlags)
+          parent->SetFlags(NODE_HAS_EDGE_CHILD_SELECTOR);
+
         PRInt32 index = -1;
         do {
           onlyChild = parent->GetChildAt(++index);
@@ -1133,6 +1139,9 @@ static PRBool SelectorMatches(RuleProces
         nsCSSPseudoClasses::empty == pseudoClass->mAtom;
       PRInt32 index = -1;
 
+      if (setNodeFlags)
+        element->SetFlags(NODE_HAS_EMPTY_SELECTOR);
+
       do {
         child = element->GetChildAt(++index);
         // stop at first non-comment (and non-whitespace for
@@ -1145,6 +1154,9 @@ static PRBool SelectorMatches(RuleProces
       nsIContent *child = nsnull;
       nsIContent *element = data.mContent;
       PRInt32 index = -1;
+
+      if (setNodeFlags)
+        element->SetFlags(NODE_HAS_SLOW_SELECTOR);
 
       do {
         child = element->GetChildAt(++index);
@@ -1566,6 +1578,8 @@ static PRBool SelectorMatchesTree(RulePr
         nsIContent* content = prevdata->mContent;
         nsIContent* parent = content->GetParent();
         if (parent) {
+          parent->SetFlags(NODE_HAS_SLOW_SELECTOR_NOAPPEND);
+
           PRInt32 index = parent->IndexOf(content);
           while (0 <= --index) {
             content = parent->GetChildAt(index);
diff --git a/layout/style/nsStyleUtil.cpp b/layout/style/nsStyleUtil.cpp
--- a/layout/style/nsStyleUtil.cpp
+++ b/layout/style/nsStyleUtil.cpp
@@ -568,3 +568,23 @@ nsStyleUtil::ColorComponentToFloat(PRUin
   }
   return rounded;
 }
+
+/* static */ PRBool
+nsStyleUtil::IsSignificantChild(nsIContent* aChild, PRBool aTextIsSignificant,
+                                PRBool aWhitespaceIsSignificant)
+{
+  NS_ASSERTION(!aWhitespaceIsSignificant || aTextIsSignificant,
+               "Nonsensical arguments");
+
+  PRBool isText = aChild->IsNodeOfType(nsINode::eTEXT);
+
+  if (!isText && !aChild->IsNodeOfType(nsINode::eCOMMENT) &&
+      !aChild->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION)) {
+    return PR_TRUE;
+  }
+
+  return aTextIsSignificant && isText && aChild->TextLength() != 0 &&
+         (aWhitespaceIsSignificant ||
+          !aChild->TextIsOnlyWhitespace());
+}
+
diff --git a/layout/style/nsStyleUtil.h b/layout/style/nsStyleUtil.h
--- a/layout/style/nsStyleUtil.h
+++ b/layout/style/nsStyleUtil.h
@@ -97,6 +97,12 @@ public:
    */
   static float ColorComponentToFloat(PRUint8 aAlpha);
 
+  /*
+   * Does this child count as significant for selector matching?
+   */
+  static PRBool IsSignificantChild(nsIContent* aChild,
+                                   PRBool aTextIsSignificant,
+                                   PRBool aWhitespaceIsSignificant);
 };
 
 
diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -68,8 +68,11 @@ css_properties.js: host_ListCSSPropertie
 
 GARBAGE += css_properties.js
 
-_TEST_FILES =	test_bug74880.html \
+_TEST_FILES =	test_bug73586.html \
+		test_bug74880.html \
+		test_bug98997.html \
 		test_bug221428.html \
+		test_bug229915.html \
 		test_bug302186.html \
 		test_bug319381.html \
 		test_bug357614.html \
diff --git a/layout/style/test/test_bug229915.html b/layout/style/test/test_bug229915.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_bug229915.html
@@ -0,0 +1,84 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=229915
+-->
+<head>
+  <title>Test for Bug 229915</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+  <style type="text/css">
+
+  p { color: black; }
+  p.prev + p { color: green; }
+
+  </style>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=229915">Mozilla Bug 229915</a>
+<div id="display">
+
+<div>
+  <p id="toinsertbefore">After testing, this should turn green.</p>
+</div>
+
+<div>
+  <p id="toreplace">To be replaced.</p>
+  <p id="replacecolor">After testing, this should turn green.</p>
+</div>
+
+<div>
+  <p class="prev">Previous paragraph.</p>
+  <p id="toremove">To be removed.</p>
+  <p id="removecolor">After testing, this should turn green.</p>
+</div>
+
+</div>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 229915 **/
+
+const GREEN = "rgb(0, 128, 0)";
+const BLACK = "rgb(0, 0, 0)";
+
+function make_prev() {
+  var result = document.createElement("p");
+  result.setAttribute("class", "prev");
+  var t = document.createTextNode("Dynamically created previous paragraph.");
+  result.appendChild(t);
+  return result;
+}
+
+function color(id) {
+  return getComputedStyle(document.getElementById(id), "").color;
+}
+
+var node;
+
+// test insert
+is(color("toinsertbefore"), BLACK, "initial state (insertion test)");
+node = document.getElementById("toinsertbefore");
+node.parentNode.insertBefore(make_prev(), node);
+is(color("toinsertbefore"), GREEN, "inserting should turn node green");
+
+// test replace
+is(color("replacecolor"), BLACK, "initial state (replacement test)");
+node = document.getElementById("toreplace");
+node.parentNode.replaceChild(make_prev(), node);
+is(color("replacecolor"), GREEN, "replacing should turn node green");
+
+// test remove
+is(color("removecolor"), BLACK, "initial state (removal test)");
+node = document.getElementById("toremove");
+node.parentNode.removeChild(node);
+is(color("removecolor"), GREEN, "removing should turn node green");
+
+</script>
+</pre>
+</body>
+</html>
diff --git a/layout/style/test/test_bug302186.html b/layout/style/test/test_bug302186.html
--- a/layout/style/test/test_bug302186.html
+++ b/layout/style/test/test_bug302186.html
@@ -359,7 +359,7 @@ function dynamicDefault6() {
   var but = document.createElement("input");
   but.setAttribute("type", "submit");
   $('div6').insertBefore(but, $('div6').firstChild);
-  todo(idColor("6a") == "rgb(0,128,0)", "CSS dynamic-default 6a");
+  is(idColor("6a"),"rgb(0,128,0)", "CSS dynamic-default 6a");
   is(idColor("6b"),"rgb(0,128,0)", "CSS dynamic-default 6b");
 }
 
@@ -375,7 +375,7 @@ function dynamicDefault8() {
   var but = document.createElement("input");
   but.setAttribute("type", "image");
   $('div8').insertBefore(but, $('div8').firstChild);
-  todo(idColor("8a") == "rgb(0,128,0)", "CSS dynamic-default 8a");
+  is(idColor("8a"),"rgb(0,128,0)", "CSS dynamic-default 8a");
   is(idColor("8b"),"rgb(0,128,0)", "CSS dynamic-default 8b");
 }
 
@@ -390,7 +390,7 @@ function dynamicDefault10() {
 function dynamicDefault10() {
   var inputs = $('div10').getElementsByTagName("input");
   $('div10').removeChild(inputs[0]);
-  todo(idColor("10a") == "rgb(0,128,0)", "CSS dynamic-default 10a");
+  is(idColor("10a"),"rgb(0,128,0)", "CSS dynamic-default 10a");
   is(idColor("10b"),"rgb(0,128,0)", "CSS dynamic-default 10b");
 }
 
@@ -404,7 +404,7 @@ function dynamicDefault12() {
 function dynamicDefault12() {
   var inputs = $('div12').getElementsByTagName("input");
   $('div12').removeChild(inputs[0]);
-  todo(idColor("12a") == "rgb(0,128,0)", "CSS dynamic-default 12a");
+  is(idColor("12a"),"rgb(0,128,0)", "CSS dynamic-default 12a");
   is(idColor("12b"),"rgb(0,128,0)", "CSS dynamic-default 12b");
 }
 
@@ -464,7 +464,7 @@ function dynamicDefault19() {
   newSubmit.setAttribute("type", "submit");
   var div1 = document.getElementById("div19");
   div1.insertBefore(newSubmit, div1.firstChild);
-  todo(idColor("19a") == "rgb(0,128,0)", "CSS dynamic-default 19a");
+  is(idColor("19a"),"rgb(0,128,0)", "CSS dynamic-default 19a");
 }
 
 function dynamicDefault20() {
@@ -472,7 +472,7 @@ function dynamicDefault20() {
   newSubmit.setAttribute("type", "image");
   var div1 = document.getElementById("div20");
   div1.insertBefore(newSubmit, div1.firstChild);
-  todo(idColor("20a") == "rgb(0,128,0)", "CSS dynamic-default 20a");
+  is(idColor("20a"),"rgb(0,128,0)", "CSS dynamic-default 20a");
 }
 
 addLoadEvent(dynamicDefault1);
diff --git a/layout/style/test/test_bug73586.html b/layout/style/test/test_bug73586.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_bug73586.html
@@ -0,0 +1,77 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=73586
+-->
+<head>
+  <title>Test for Bug 73586</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+  <style type="text/css">
+
+  span { background: white; color: black; border: medium solid black; }
+
+  span:first-child { background: lime; }
+  span:last-child { color: green; }
+  span:only-child { border: medium solid green; }
+
+  </style>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=73586">Mozilla Bug 73586</a>
+<p id="display"><span></span><span></span></p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 73586 **/
+
+const GREEN = "rgb(0, 128, 0)";
+const LIME = "rgb(0, 255, 0)";
+const BLACK = "rgb(0, 0, 0)";
+const WHITE = "rgb(255, 255, 255)";
+
+var p = document.getElementById("display");
+function cs(elt) { return getComputedStyle(elt, ""); }
+
+function check_children() {
+    var last = p.childNodes.length - 1;
+    for (var i = 0; i <= last; ++i) {
+        is(cs(p.childNodes[i]).backgroundColor, (i == 0) ? LIME : WHITE,
+           "child " + i + " should " + ((i == 0) ? "" : "NOT ") +
+           " match :first-child");
+        is(cs(p.childNodes[i]).color, (i == last) ? GREEN : BLACK,
+           "child " + i + " should " + ((i == last) ? "" : "NOT ") +
+           " match :last-child");
+        is(cs(p.childNodes[i]).borderTopColor, (last == 0) ? GREEN : BLACK,
+           "child " + i + " should " + ((last == 0) ? "" : "NOT ") +
+           " match :only-child");
+    }
+}
+
+check_children();
+var span = p.removeChild(p.childNodes[0]);
+check_children();
+p.appendChild(span);
+check_children();
+p.removeChild(span);
+check_children();
+p.insertBefore(span, p.childNodes[0]);
+check_children();
+p.removeChild(span);
+check_children();
+p.insertBefore(span, null);
+check_children();
+p.appendChild(document.createElement("span"));
+check_children();
+p.insertBefore(document.createElement("span"), p.childNodes[2]);
+check_children();
+
+</script>
+</pre>
+</body>
+</html>
+
diff --git a/layout/style/test/test_bug98997.html b/layout/style/test/test_bug98997.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_bug98997.html
@@ -0,0 +1,131 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=98997
+-->
+<head>
+  <title>Test for Bug 98997</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+  <style type="text/css">
+
+  div.test { width: 200px; height: 30px; margin: 5px 0; }
+  div.test.to, div.test.from:empty { background: orange; }
+  div.test.to:empty, div.test.from { background: green; }
+
+  </style>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=98997">Mozilla Bug 98997</a>
+<div id="display">
+<div class="test to" onclick="testReplaceChild(this, '')">x</div>
+<div class="test to" onclick="testReplaceChild(this, '')"><span>x</span></div>
+<div class="test to" onclick="testReplaceChild(this, '')">x<!-- comment --></div>
+<div class="test to" onclick="testRemoveChild(this)">x</div>
+<div class="test to" onclick="testRemoveChild(this)"><span>x</span></div>
+<div class="test to" onclick="testRemoveChild(this)">x<!-- comment --></div>
+<div class="test to" onclick="testChangeData(this, '')">x</div>
+<div class="test to" onclick="testChangeData(this, '')">x<!-- comment --></div>
+<div class="test to" onclick="testDeleteData(this)">x</div>
+<div class="test to" onclick="testDeleteData(this)">x<!-- comment --></div>
+<div class="test to" onclick="testReplaceData(this, '')">x</div>
+<div class="test to" onclick="testReplaceData(this, '')">x<!-- comment --></div>
+
+<div class="test from makeemptytext" onclick="testReplaceChild(this, 'x')"></div>
+<div class="test from makeemptytext" onclick="testReplaceChild(this, 'x')"><!-- comment --></div>
+<div class="test from" onclick="testReplaceChild(this, 'x')"><!-- comment --></div>
+<div class="test from" onclick="testInsertBefore(this, 'x')"></div>
+<div class="test from" onclick="testInsertBefore(this, 'x')"><!-- comment --></div>
+<div class="test from" onclick="testAppendChild(this, 'x')"></div>
+<div class="test from" onclick="testAppendChild(this, 'x')"><!-- comment --></div>
+<div class="test from makeemptytext" onclick="testChangeData(this, 'x')"></div>
+<div class="test from makeemptytext" onclick="testChangeData(this, 'x')"><!-- comment --></div>
+<div class="test from makeemptytext" onclick="testAppendData(this, 'x')"></div>
+<div class="test from makeemptytext" onclick="testAppendData(this, 'x')"><!-- comment --></div>
+<div class="test from makeemptytext" onclick="testReplaceData(this, 'x')"></div>
+<div class="test from makeemptytext" onclick="testReplaceData(this, 'x')"><!-- comment --></div>
+</div>
+
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 98997 **/
+
+function testInsertBefore(elt, text) {
+  elt.insertBefore(document.createTextNode(text), elt.firstChild);
+}
+
+function testAppendChild(elt, text) {
+  elt.appendChild(document.createTextNode(text));
+}
+
+function testReplaceChild(elt, text) {
+  elt.replaceChild(document.createTextNode(text), elt.firstChild);
+}
+
+function testRemoveChild(elt) {
+  elt.removeChild(elt.firstChild);
+}
+
+function testChangeData(elt, text) {
+  elt.firstChild.data = text;
+}
+
+function testAppendData(elt, text) {
+  elt.firstChild.appendData(text);
+}
+
+function testDeleteData(elt) {
+  elt.firstChild.deleteData(0, elt.firstChild.length);
+}
+
+function testReplaceData(elt, text) {
+  elt.firstChild.replaceData(0, elt.firstChild.length, text);
+}
+
+var cnodes = document.getElementById("display").childNodes;
+var divs = [];
+var i;
+for (i = 0; i < cnodes.length; ++i) {
+  if (cnodes[i].nodeName == "DIV")
+    divs.push(cnodes[i]);
+}
+
+for (i in divs) {
+  var div = divs[i];
+  if (div.className.match(/makeemptytext/))
+    div.insertBefore(document.createTextNode(""), div.firstChild);
+}
+
+const ORANGE = "rgb(255, 165, 0)";
+const GREEN = "rgb(0, 128, 0)";
+
+function color(div) {
+  return getComputedStyle(div, "").backgroundColor;
+}
+
+for (i in divs) {
+  var div = divs[i];
+  is(color(div), ORANGE, "should be orange");
+}
+
+for (i in divs) {
+  var div = divs[i];
+  var e = document.createEvent("MouseEvents");
+  e.initEvent("click", true, true);
+  div.dispatchEvent(e);
+}
+
+for (i in divs) {
+  var div = divs[i];
+  is(color(div), GREEN, "should be green");
+}
+
+</script>
+</pre>
+</body>
+</html>
