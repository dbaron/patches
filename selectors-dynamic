Fix handling of dynamic changes for advanced CSS selectors (and avoid the cost of doing so in the normal case).  b=401291, 75386, 98997, 229915, 404418 (blocking1.9+)

diff --git a/content/base/public/nsINode.h b/content/base/public/nsINode.h
--- a/content/base/public/nsINode.h
+++ b/content/base/public/nsINode.h
@@ -101,9 +101,30 @@ enum {
 
   NODE_SCRIPT_TYPE_SIZE =                  4,
 
+  // Node has an :empty or :-moz-only-whitespace selector
+  NODE_HAS_EMPTY_SELECTOR =      0x00010000U,
+
+  // A child of the node has a selector such that any insertion,
+  // removal, or appending of children requires restyling the parent.
+  NODE_HAS_SLOW_SELECTOR =       0x00020000U,
+
+  // A child of the node has a :first-child, :-moz-first-node,
+  // :only-child, :last-child or :-moz-last-node selector.
+  NODE_HAS_EDGE_CHILD_SELECTOR = 0x00040000U,
+
+  // A child of the node has a selector such that any insertion or
+  // removal of children requires restyling the parent (but append is
+  // OK).
+  NODE_HAS_SLOW_SELECTOR_NOAPPEND
+                               = 0x00080000U,
+
+  NODE_ALL_SELECTOR_FLAGS =      NODE_HAS_EMPTY_SELECTOR |
+                                 NODE_HAS_SLOW_SELECTOR |
+                                 NODE_HAS_EDGE_CHILD_SELECTOR |
+                                 NODE_HAS_SLOW_SELECTOR_NOAPPEND,
+
   // Remaining bits are node type specific.
-  NODE_TYPE_SPECIFIC_BITS_OFFSET =
-    NODE_SCRIPT_TYPE_OFFSET + NODE_SCRIPT_TYPE_SIZE
+  NODE_TYPE_SPECIFIC_BITS_OFFSET = 20
 };
 
 // Useful inline function for getting a node given an nsIContent and an
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -120,6 +120,7 @@
 #include "nsContentErrors.h"
 #include "nsIPrincipal.h"
 #include "nsIDOMWindowInternal.h"
+#include "nsStyleUtil.h"
 
 #include "nsBox.h"
 
@@ -152,7 +153,6 @@ NS_NewHTMLCanvasFrame (nsIPresShell* aPr
 
 #ifdef MOZ_SVG
 #include "nsISVGTextContentMetrics.h"
-#include "nsStyleUtil.h"
 
 PRBool
 NS_SVGEnabled();
@@ -8533,6 +8533,8 @@ nsCSSFrameConstructor::ContentAppended(n
   }
 #endif
 
+  RestyleForAppend(aContainer, aNewIndexInContainer);
+
 #ifdef MOZ_XUL
   if (aContainer) {
     PRInt32 namespaceID;
@@ -8906,6 +8908,8 @@ nsCSSFrameConstructor::ContentInserted(n
   }
 #endif
 
+  RestyleForInsertOrRemove(aContainer, aChild);
+
   nsresult rv = NS_OK;
 
 #ifdef MOZ_XUL
@@ -9476,6 +9480,8 @@ nsCSSFrameConstructor::ContentRemoved(ns
   }
 #endif
 
+  RestyleForInsertOrRemove(aContainer, aChild);
+
   nsFrameManager *frameManager = mPresShell->FrameManager();
   nsPresContext *presContext = mPresShell->GetPresContext();
   nsresult                  rv = NS_OK;
@@ -9900,6 +9906,19 @@ nsCSSFrameConstructor::CharacterDataChan
 {
   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
   nsresult      rv = NS_OK;
+
+  nsIContent *container = aContent->GetParent();
+  PRUint32 selectorFlags =
+    container ? (container->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
+  if (selectorFlags != 0) {
+    PRUint32 index;
+    if (aAppend &&
+        container->GetChildAt((index = container->GetChildCount() - 1)) ==
+          aContent)
+      RestyleForAppend(container, index);
+    else
+      RestyleForInsertOrRemove(container, aContent);
+  }
 
   // Find the child frame
   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(aContent);
@@ -13135,6 +13154,118 @@ nsresult nsCSSFrameConstructor::RemoveFi
   return rv;
 }
 
+void
+nsCSSFrameConstructor::RestyleForAppend(nsIContent* aContainer,
+                                        PRInt32 aNewIndexInContainer)
+{
+  PRUint32 selectorFlags = aContainer ?
+    (aContainer->GetFlags() & (NODE_ALL_SELECTOR_FLAGS &
+                               ~NODE_HAS_SLOW_SELECTOR_NOAPPEND)) : 0;
+  if (selectorFlags != 0) {
+    if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
+      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+    } else {
+      if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
+        // see if we need to restyle the container
+        PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
+        for (PRInt32 index = 0; index < aNewIndexInContainer; ++index) {
+          if (nsStyleUtil::IsSignificantChild(aContainer->GetChildAt(index),
+                                              PR_TRUE, PR_FALSE)) {
+            wasEmpty = PR_FALSE;
+            break;
+          }
+        }
+        if (wasEmpty) {
+          PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+        }
+      }
+      if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
+        // restyle the last element child before this node
+        for (PRInt32 index = aNewIndexInContainer - 1; index >= 0; --index) {
+          nsIContent *content = aContainer->GetChildAt(index);
+          if (content->IsNodeOfType(nsINode::eELEMENT)) {
+            PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
+            break;
+          }
+        }
+      }
+    }
+  }
+}
+
+// Restyling for a ContentInserted (notification after insertion) or
+// for a ContentRemoved (notification before removal) is exactly the
+// same; this is the shared code.
+// The comments are written and variables are named in terms of it being
+// a ContentInserted notification.
+void
+nsCSSFrameConstructor::RestyleForInsertOrRemove(nsIContent* aContainer,
+                                                nsIContent* aChild)
+{
+  PRUint32 selectorFlags =
+    aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
+  if (selectorFlags != 0) {
+    if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
+                         NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
+      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+    } else {
+      if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
+        // see if we need to restyle the container
+        PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
+        for (PRInt32 index = 0; ; ++index) {
+          nsIContent *child = aContainer->GetChildAt(index);
+          if (!child) // last child
+            break;
+          if (child == aChild)
+            continue;
+          if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
+            wasEmpty = PR_FALSE;
+            break;
+          }
+        }
+        if (wasEmpty) {
+          PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+        }
+      }
+      if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
+        // restyle the previously-first element child if it is after this node
+        PRBool passedChild = PR_FALSE;
+        for (PRInt32 index = 0; ; ++index) {
+          nsIContent *content = aContainer->GetChildAt(index);
+          if (!content)
+            break; // went through all children
+          if (content == aChild) {
+            passedChild = PR_TRUE;
+            continue;
+          }
+          if (content->IsNodeOfType(nsINode::eELEMENT)) {
+            if (passedChild) {
+              PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
+            }
+            break;
+          }
+        }
+        // restyle the previously-last element child if it is before this node
+        passedChild = PR_FALSE;
+        for (PRInt32 index = aContainer->GetChildCount() - 1;
+             index >= 0; --index) {
+          nsIContent *content = aContainer->GetChildAt(index);
+          if (content == aChild) {
+            passedChild = PR_TRUE;
+            continue;
+          }
+          if (content->IsNodeOfType(nsINode::eELEMENT)) {
+            if (passedChild) {
+              PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
+            }
+            break;
+          }
+        }
+      }
+    }
+  }
+}
+
 PR_STATIC_CALLBACK(PLDHashOperator)
 CollectRestyles(nsISupports* aContent,
                 nsCSSFrameConstructor::RestyleData& aData,
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -169,6 +169,15 @@ private:
   // itself.
   void ProcessOneRestyle(nsIContent* aContent, nsReStyleHint aRestyleHint,
                          nsChangeHint aChangeHint);
+
+  // Restyling for a ContentInserted (notification after insertion) or
+  // for a ContentRemoved (notification before removal) is exactly the
+  // same; this is the shared code.
+  void RestyleForInsertOrRemove(nsIContent* aContainer,
+                                nsIContent* aChild);
+  // Same for a ContentAppended.
+  void RestyleForAppend(nsIContent* aContainer,
+                        PRInt32 aNewIndexInContainer);
 
 public:
   // Note: It's the caller's responsibility to make sure to wrap a
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -986,21 +986,12 @@ inline PRBool IsQuirkEventSensitive(nsIA
 }
 
 
-static PRBool IsSignificantChild(nsIContent* aChild, PRBool aTextIsSignificant, PRBool aWhitespaceIsSignificant)
+static inline PRBool
+IsSignificantChild(nsIContent* aChild, PRBool aTextIsSignificant,
+                   PRBool aWhitespaceIsSignificant)
 {
-  NS_ASSERTION(!aWhitespaceIsSignificant || aTextIsSignificant,
-               "Nonsensical arguments");
-
-  PRBool isText = aChild->IsNodeOfType(nsINode::eTEXT);
-
-  if (!isText && !aChild->IsNodeOfType(nsINode::eCOMMENT) &&
-      !aChild->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION)) {
-    return PR_TRUE;
-  }
-
-  return aTextIsSignificant && isText && aChild->TextLength() != 0 &&
-         (aWhitespaceIsSignificant ||
-          !aChild->TextIsOnlyWhitespace());
+  return nsStyleUtil::IsSignificantChild(aChild, aTextIsSignificant,
+                                         aWhitespaceIsSignificant);
 }
 
 // This function is to be called once we have fetched a value for an attribute
@@ -1064,6 +1055,12 @@ static PRBool SelectorMatches(RuleProces
 
   PRBool result = PR_TRUE;
   const PRBool isNegated = (aDependence != nsnull);
+  // The selectors for which we set node bits are, unfortunately, early
+  // in this function (because they're pseudo-classes, which are
+  // generally quick to test, and thus earlier).  If they were later,
+  // we'd probably avoid setting those bits in more cases where setting
+  // them is unnecessary.
+  const PRBool setNodeFlags = aStateMask == 0 && !aAttribute;
 
   // test for pseudo class match
   // first-child, root, lang, active, focus, hover, link, visited...
@@ -1076,6 +1073,9 @@ static PRBool SelectorMatches(RuleProces
       nsIContent *firstChild = nsnull;
       nsIContent *parent = data.mParentContent;
       if (parent) {
+        if (setNodeFlags)
+          parent->SetFlags(NODE_HAS_EDGE_CHILD_SELECTOR);
+
         PRBool acceptNonWhitespace =
           nsCSSPseudoClasses::firstNode == pseudoClass->mAtom;
         PRInt32 index = -1;
@@ -1093,6 +1093,9 @@ static PRBool SelectorMatches(RuleProces
       nsIContent *lastChild = nsnull;
       nsIContent *parent = data.mParentContent;
       if (parent) {
+        if (setNodeFlags)
+          parent->SetFlags(NODE_HAS_EDGE_CHILD_SELECTOR);
+
         PRBool acceptNonWhitespace =
           nsCSSPseudoClasses::lastNode == pseudoClass->mAtom;
         PRUint32 index = parent->GetChildCount();
@@ -1110,6 +1113,9 @@ static PRBool SelectorMatches(RuleProces
       nsIContent *moreChild = nsnull;
       nsIContent *parent = data.mParentContent;
       if (parent) {
+        if (setNodeFlags)
+          parent->SetFlags(NODE_HAS_EDGE_CHILD_SELECTOR);
+
         PRInt32 index = -1;
         do {
           onlyChild = parent->GetChildAt(++index);
@@ -1133,6 +1139,9 @@ static PRBool SelectorMatches(RuleProces
         nsCSSPseudoClasses::empty == pseudoClass->mAtom;
       PRInt32 index = -1;
 
+      if (setNodeFlags)
+        element->SetFlags(NODE_HAS_EMPTY_SELECTOR);
+
       do {
         child = element->GetChildAt(++index);
         // stop at first non-comment (and non-whitespace for
@@ -1145,6 +1154,9 @@ static PRBool SelectorMatches(RuleProces
       nsIContent *child = nsnull;
       nsIContent *element = data.mContent;
       PRInt32 index = -1;
+
+      if (setNodeFlags)
+        element->SetFlags(NODE_HAS_SLOW_SELECTOR);
 
       do {
         child = element->GetChildAt(++index);
@@ -1566,6 +1578,8 @@ static PRBool SelectorMatchesTree(RulePr
         nsIContent* content = prevdata->mContent;
         nsIContent* parent = content->GetParent();
         if (parent) {
+          parent->SetFlags(NODE_HAS_SLOW_SELECTOR_NOAPPEND);
+
           PRInt32 index = parent->IndexOf(content);
           while (0 <= --index) {
             content = parent->GetChildAt(index);
diff --git a/layout/style/nsStyleUtil.cpp b/layout/style/nsStyleUtil.cpp
--- a/layout/style/nsStyleUtil.cpp
+++ b/layout/style/nsStyleUtil.cpp
@@ -568,3 +568,23 @@ nsStyleUtil::ColorComponentToFloat(PRUin
   }
   return rounded;
 }
+
+/* static */ PRBool
+nsStyleUtil::IsSignificantChild(nsIContent* aChild, PRBool aTextIsSignificant,
+                                PRBool aWhitespaceIsSignificant)
+{
+  NS_ASSERTION(!aWhitespaceIsSignificant || aTextIsSignificant,
+               "Nonsensical arguments");
+
+  PRBool isText = aChild->IsNodeOfType(nsINode::eTEXT);
+
+  if (!isText && !aChild->IsNodeOfType(nsINode::eCOMMENT) &&
+      !aChild->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION)) {
+    return PR_TRUE;
+  }
+
+  return aTextIsSignificant && isText && aChild->TextLength() != 0 &&
+         (aWhitespaceIsSignificant ||
+          !aChild->TextIsOnlyWhitespace());
+}
+
diff --git a/layout/style/nsStyleUtil.h b/layout/style/nsStyleUtil.h
--- a/layout/style/nsStyleUtil.h
+++ b/layout/style/nsStyleUtil.h
@@ -97,6 +97,12 @@ public:
    */
   static float ColorComponentToFloat(PRUint8 aAlpha);
 
+  /*
+   * Does this child count as significant for selector matching?
+   */
+  static PRBool IsSignificantChild(nsIContent* aChild,
+                                   PRBool aTextIsSignificant,
+                                   PRBool aWhitespaceIsSignificant);
 };
 
 
