From: L. David Baron <dbaron@dbaron.org>

Bug 1115812 patch 8 - Move ProcessRestyles from RestyleTracker to RestyleManager.

This is needed for the following patch.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1560,17 +1560,17 @@ RestyleManager::ProcessPendingRestyles()
     // post a change hint for the root frame.
     // Note that we can ignore the return value of ComputeStyleChangeFor
     // because we never need to reframe the root frame.
     ComputeAndProcessStyleChange(mPresContext->PresShell()->GetRootFrame(),
                                  nsChangeHint(0), mPendingRestyles,
                                  eRestyle_ForceDescendants);
   }
 
-  mPendingRestyles.ProcessRestyles();
+  ProcessRestyles(mPendingRestyles);
 
   if (mInRebuildAllStyleData) {
     // We might not have gotten to the FlushOverflowChangedTracker call
     // in the ProcessRestyles() call above.
     FlushOverflowChangedTracker();
 
     // Tell the style set it's safe to destroy the old rule tree.  We
     // must do this after the ProcessRestyledFrames call in case the
@@ -1592,17 +1592,17 @@ RestyleManager::ProcessPendingRestyles()
   // first set of restyles (e.g., CSS transitions with negative
   // transition-delay), and because we need to immediately
   // restyle-with-animation any just-restyled elements that are
   // mid-transition (since processing the non-animation restyle ignores
   // the running transition so it can check for a new change on the same
   // property, and then posts an immediate animation style change).
   MOZ_ASSERT(!mIsProcessingAnimationStyleChange, "nesting forbidden");
   mIsProcessingAnimationStyleChange = true;
-  mPendingAnimationRestyles.ProcessRestyles();
+  ProcessRestyles(mPendingAnimationRestyles);
   MOZ_ASSERT(mIsProcessingAnimationStyleChange, "nesting forbidden");
   mIsProcessingAnimationStyleChange = false;
 
 #ifdef DEBUG
   mIsProcessingRestyles = false;
 #endif
   NS_POSTCONDITION(mPendingRestyles.Count() == oldPendingRestyleCount,
                    "We should not have posted new non-animation restyles while "
@@ -1662,17 +1662,17 @@ RestyleManager::UpdateOnlyAnimationStyle
 
   // FIXME:  We should have the transition manager and animation manager
   // add only the elements for which animations are currently throttled
   // (i.e., animating on the compositor with main-thread style updates
   // suppressed).
   transitionManager->AddStyleUpdatesTo(tracker);
   animationManager->AddStyleUpdatesTo(tracker);
 
-  tracker.ProcessRestyles();
+  ProcessRestyles(tracker);
 
   transitionManager->SetInAnimationOnlyStyleUpdate(false);
 }
 
 void
 RestyleManager::PostRestyleEventCommon(Element* aElement,
                                        nsRestyleHint aRestyleHint,
                                        nsChangeHint aMinChangeHint,
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -454,16 +454,24 @@ private:
   // Recursively add all the given frame and all children to the tracker.
   void AddSubtreeToOverflowTracker(nsIFrame* aFrame);
 
   // Returns true if this function managed to successfully move a frame, and
   // false if it could not process the position change, and a reflow should
   // be performed instead.
   bool RecomputePosition(nsIFrame* aFrame);
 
+  void ProcessRestyles(RestyleTracker& aRestyleTracker) {
+    // Fast-path the common case (esp. for the animation restyle
+    // tracker) of not having anything to do.
+    if (aRestyleTracker.mPendingRestyles.Count()) {
+      aRestyleTracker.DoProcessRestyles();
+    }
+  }
+
 private:
   nsPresContext* mPresContext; // weak, disconnected in Disconnect
 
   bool mDoRebuildAllStyleData : 1;
   bool mInRebuildAllStyleData : 1;
   // True if we're already waiting for a refresh notification
   bool mObservingRefreshDriver : 1;
   // True if we're in the middle of a nsRefreshDriver refresh
diff --git a/layout/base/RestyleTracker.h b/layout/base/RestyleTracker.h
--- a/layout/base/RestyleTracker.h
+++ b/layout/base/RestyleTracker.h
@@ -271,23 +271,17 @@ public:
    * Call AddPendingRestyle for the root element, if any.
    */
   void AddPendingRestyleToRoot(nsRestyleHint aRestyleHint,
                                nsChangeHint aChangeHint);
 
   /**
    * Process the restyles we've been tracking.
    */
-  void ProcessRestyles() {
-    // Fast-path the common case (esp. for the animation restyle
-    // tracker) of not having anything to do.
-    if (mPendingRestyles.Count()) {
-      DoProcessRestyles();
-    }
-  }
+  void DoProcessRestyles();
 
   // Return our ELEMENT_HAS_PENDING_(ANIMATION_)RESTYLE bit
   uint32_t RestyleBit() const {
     return mRestyleBits & ELEMENT_PENDING_RESTYLE_FLAGS;
   }
 
   // Return our ELEMENT_IS_POTENTIAL_(ANIMATION_)RESTYLE_ROOT bit
   Element::FlagsType RootBit() const {
@@ -363,21 +357,16 @@ private:
    * Handle a single mPendingRestyles entry.  aRestyleHint must not
    * include eRestyle_LaterSiblings; that needs to be dealt with
    * before calling this function.
    */
   inline void ProcessOneRestyle(Element* aElement,
                                 nsRestyleHint aRestyleHint,
                                 nsChangeHint aChangeHint);
 
-  /**
-   * The guts of our restyle processing.
-   */
-  void DoProcessRestyles();
-
   typedef nsClassHashtable<nsISupportsHashKey, RestyleData> PendingRestyleTable;
   typedef nsAutoTArray< nsRefPtr<Element>, 32> RestyleRootArray;
   // Our restyle bits.  These will be a subset of ELEMENT_ALL_RESTYLE_FLAGS, and
   // will include one flag from ELEMENT_PENDING_RESTYLE_FLAGS and one flag
   // that's not in ELEMENT_PENDING_RESTYLE_FLAGS.
   Element::FlagsType mRestyleBits;
   RestyleManager* mRestyleManager; // Owns us
   // A hashtable that maps elements to pointers to RestyleData structs.  The
