Redesign font fallback on Linux, v. 0.75.  Patch from Stuart.  b=362682

diff --git a/gfx/thebes/public/gfxPangoFonts.h b/gfx/thebes/public/gfxPangoFonts.h
--- a/gfx/thebes/public/gfxPangoFonts.h
+++ b/gfx/thebes/public/gfxPangoFonts.h
@@ -140,7 +140,7 @@ protected:
     // ****** Textrun glyph conversion helpers ******
 
     void InitTextRun(gfxTextRun *aTextRun, const gchar *aUTF8Text,
-                     PRUint32 aUTF8Length, PRUint32 aUTF8HeaderLength);
+                     PRUint32 aUTF8Length);
     // Returns NS_ERROR_FAILURE if there's a missing glyph
     nsresult SetGlyphs(gfxTextRun *aTextRun, gfxPangoFont *aFont,
                        const gchar *aUTF8, PRUint32 aUTF8Length,
@@ -151,8 +151,7 @@ protected:
                               const gchar *aUTF8, PRUint32 aUTF8Length,
                               PRUint32 *aUTF16Offset);
     void CreateGlyphRunsItemizing(gfxTextRun *aTextRun,
-                                  const gchar *aUTF8, PRUint32 aUTF8Length,
-                                  PRUint32 aUTF8HeaderLength);
+                                  const gchar *aUTF8, PRUint32 aUTF8Length);
 #if defined(ENABLE_XFT_FAST_PATH_8BIT) || defined(ENABLE_XFT_FAST_PATH_ALWAYS)
     void CreateGlyphRunsXft(gfxTextRun *aTextRun,
                             const gchar *aUTF8, PRUint32 aUTF8Length);
diff --git a/gfx/thebes/src/gfxPangoFonts.cpp b/gfx/thebes/src/gfxPangoFonts.cpp
--- a/gfx/thebes/src/gfxPangoFonts.cpp
+++ b/gfx/thebes/src/gfxPangoFonts.cpp
@@ -797,19 +797,6 @@ GetCJKLangGroupIndex(const char *aLangGr
  * 
  **/
 
-/**
- * We use this to append an LTR or RTL Override character to the start of the
- * string. This forces Pango to honour our direction even if there are neutral characters
- * in the string.
- */
-static PRInt32 AppendDirectionalIndicatorUTF8(PRBool aIsRTL, nsACString& aString)
-{
-    static const PRUnichar overrides[2][2] =
-      { { 0x202d, 0 }, { 0x202e, 0 }}; // LRO, RLO
-    AppendUTF16toUTF8(overrides[aIsRTL], aString);
-    return 3; // both overrides map to 3 bytes in UTF8
-}
-
 gfxTextRun *
 gfxPangoFontGroup::MakeTextRun(const PRUint8 *aString, PRUint32 aLength,
                                const Parameters *aParams, PRUint32 aFlags)
@@ -821,22 +808,16 @@ gfxPangoFontGroup::MakeTextRun(const PRU
 
     PRBool isRTL = run->IsRightToLeft();
     if ((aFlags & TEXT_IS_ASCII) && !isRTL) {
-        // We don't need to send an override character here, the characters must be all
-        // LTR
         const gchar *utf8Chars = reinterpret_cast<const gchar*>(aString);
-        InitTextRun(run, utf8Chars, aLength, 0);
+        InitTextRun(run, utf8Chars, aLength);
     } else {
+        // this is really gross...
         const char *chars = reinterpret_cast<const char*>(aString);
-        // XXX this could be more efficient.
-        // Although chars in not necessarily ASCII (as it may point to the low
-        // bytes of any UCS-2 characters < 256), NS_ConvertASCIItoUTF16 seems
-        // to DTRT.
         NS_ConvertASCIItoUTF16 unicodeString(chars, aLength);
-        nsCAutoString utf8;
-        PRInt32 headerLen = AppendDirectionalIndicatorUTF8(isRTL, utf8);
-        AppendUTF16toUTF8(unicodeString, utf8);
-        InitTextRun(run, utf8.get(), utf8.Length(), headerLen);
-    }
+        NS_ConvertUTF16toUTF8 utf8String(unicodeString);
+        InitTextRun(run, utf8String.get(), utf8String.Length());
+    }
+
     return run;
 }
 
@@ -850,23 +831,21 @@ gfxPangoFontGroup::MakeTextRun(const PRU
 
     run->RecordSurrogates(aString);
 
-    nsCAutoString utf8;
-    PRInt32 headerLen = AppendDirectionalIndicatorUTF8(run->IsRightToLeft(), utf8);
-    AppendUTF16toUTF8(Substring(aString, aString + aLength), utf8);
-    InitTextRun(run, utf8.get(), utf8.Length(), headerLen);
+    NS_ConvertUTF16toUTF8 utf8String(aString, aLength);
+    InitTextRun(run, utf8String.get(), utf8String.Length());
     return run;
 }
 
 void
 gfxPangoFontGroup::InitTextRun(gfxTextRun *aTextRun, const gchar *aUTF8Text,
-                               PRUint32 aUTF8Length, PRUint32 aUTF8HeaderLength)
+                               PRUint32 aUTF8Length)
 {
 #if defined(ENABLE_XFT_FAST_PATH_ALWAYS)
-    CreateGlyphRunsXft(aTextRun, aUTF8Text + aUTF8HeaderLength, aUTF8Length - aUTF8HeaderLength);
+    CreateGlyphRunsXft(aTextRun, aUTF8Text, aUTF8Length);
 #else
 #if defined(ENABLE_XFT_FAST_PATH_8BIT)
     if (aTextRun->GetFlags() & gfxTextRunFactory::TEXT_IS_8BIT) {
-        CreateGlyphRunsXft(aTextRun, aUTF8Text + aUTF8HeaderLength, aUTF8Length - aUTF8HeaderLength);
+        CreateGlyphRunsXft(aTextRun, aUTF8Text, aUTF8Length);
         return;
     }
 #endif
@@ -875,7 +854,7 @@ gfxPangoFontGroup::InitTextRun(gfxTextRu
                                (aTextRun->IsRightToLeft()
                                   ? PANGO_DIRECTION_RTL : PANGO_DIRECTION_LTR));
 
-    CreateGlyphRunsItemizing(aTextRun, aUTF8Text, aUTF8Length, aUTF8HeaderLength);
+    CreateGlyphRunsItemizing(aTextRun, aUTF8Text, aUTF8Length);
 #endif
 }
 
@@ -1308,319 +1287,107 @@ gfxPangoFontGroup::CreateGlyphRunsXft(gf
 }
 #endif
 
-class FontSelector
-{
-public:
-    FontSelector(const gchar *aString, PRInt32 aLength,
-                 gfxPangoFontGroup *aGroup, gfxTextRun *aTextRun,
-                 PangoItem *aItem, PRUint32 aUTF16Offset, PRPackedBool aIsRTL) :
-        mItem(aItem),
-        mGroup(aGroup), mTextRun(aTextRun), mString(aString),
-        mFontIndex(0), mLength(aLength), mUTF16Offset(aUTF16Offset),
-        mTriedPrefFonts(0), mTriedOtherFonts(0), mIsRTL(aIsRTL)
-    {
-        for (PRUint32 i = 0; i < mGroup->FontListLength(); ++i)
-            mFonts.AppendElement(mGroup->GetFontAt(i));
-        mSpaceWidth = NS_lround(mGroup->GetFontAt(0)->GetMetrics().spaceWidth * FLOAT_PANGO_SCALE);
-    }
-    
-    nsresult Run()
-    {
-        return InitSegments(mString, mLength);
-    }
-
-    PRUint32 GetUTF16Offset() { return mUTF16Offset; }
-
-    static PRBool ExistsFont(FontSelector *aFs,
-                             const nsAString &aName) {
-        PRUint32 len = aFs->mFonts.Length();
-        for (PRUint32 i = 0; i < len; ++i) {
-            if (aName.Equals(aFs->mFonts[i]->GetName()))
-                return PR_TRUE;
-        }
-        return PR_FALSE;
-    }
-
-    static PRBool AddFontCallback(const nsAString &aName,
-                                  const nsACString &aGenericName,
-                                  void *closure) {
-        if (aName.IsEmpty())
-            return PR_TRUE;
-
-        FontSelector *fs = static_cast<FontSelector*>(closure);
-
-        // XXX do something better than this to remove dups
-        if (ExistsFont(fs, aName))
-            return PR_TRUE;
-
-        nsRefPtr<gfxPangoFont> font = GetOrMakeFont(aName, fs->mGroup->GetStyle());
-        if (font) {
-            fs->mFonts.AppendElement(font);
-        }
-
-        return PR_TRUE;
-    }
-
-private:
-    PangoItem *mItem;
-
-    nsTArray< nsRefPtr<gfxPangoFont> > mFonts;
-
-    gfxPangoFontGroup *mGroup;
-    gfxTextRun   *mTextRun;
-    const char        *mString; // UTF-8
-    PRUint32           mFontIndex;
-    PRInt32            mLength;
-    PRUint32           mUTF16Offset;
-    PRUint32           mSpaceWidth;
-
-    PRPackedBool mTriedPrefFonts;
-    PRPackedBool mTriedOtherFonts;
-    PRPackedBool mIsRTL;
-
-    nsresult InitSegments(const gchar *aUTF8, PRUint32 aLength) {
-        if (aLength == 0)
-            return NS_OK;
-        const gchar *start = aUTF8;
-        const gchar *last = start + aLength;
-
-RetryNextFont:
-        nsRefPtr<gfxPangoFont> font = GetNextFont();
-
-        // If we cannot found the font that has the current character glyph,
-        // we should return default font's missing data.
-        if (!font)
-            return AppendMissingSegment(start, last - start);
-
-        nsresult rv;
-        for (const gchar *c = start; c < last;) {
-            // find the first missing glyph
-            gunichar u = g_utf8_get_char(c);
-            if (font->HasGlyph(PRUint32(u))) {
-                c = g_utf8_next_char(c);
-                continue;
-            }
-
-            // find the next point that can be renderd with current font
-            const gchar *missingStart = c;
-            const gchar *next;
-            for (next = g_utf8_next_char(missingStart); next < last; next = g_utf8_next_char(next)) {
-                u = g_utf8_get_char(next);
-                if (font->HasGlyph(PRUint32(u)))
-                    break;
-            }
-
-            // current font has 0 glyphs for current segment, try with next font
-            if (missingStart == start && next == last)
-                goto RetryNextFont;
-
-            // create the segment for found glyphs
-            rv = AppendSegment(font, start, missingStart - start);
-            NS_ENSURE_SUCCESS(rv, rv);
-
-            // init the missing glyphs with remains fonts.
-            PRUint32 fontIndex = mFontIndex;
-            rv = InitSegments(missingStart, next - missingStart);
-            mFontIndex = fontIndex;
-            NS_ENSURE_SUCCESS(rv, rv);
-
-            start = c = next;
-        }
-
-        rv = AppendSegment(font, start, last - start);
-        NS_ENSURE_SUCCESS(rv, rv);
-        return NS_OK;
-    }
-
-    nsresult AppendSegment(gfxPangoFont* aFont, const gchar *aUTF8, PRUint32 aLength) {
-        if (aLength == 0)
-            return NS_OK;
-
-        PangoFont* pf = aFont->GetPangoFont();
-
-        PangoGlyphString *glyphString = pango_glyph_string_new();
-        if (!glyphString)
-            return NS_ERROR_OUT_OF_MEMORY;
-        PangoFont *tmpFont = mItem->analysis.font;
-        mItem->analysis.font = pf;
-        pango_shape(aUTF8, aLength, &mItem->analysis, glyphString);
-        mItem->analysis.font = tmpFont;
-
-        nsresult rv = mTextRun->AddGlyphRun(aFont, mUTF16Offset);
-        if (NS_FAILED(rv)) {
-            NS_ERROR("AddGlyphRun Failed");
-            pango_glyph_string_free(glyphString);
-            return rv;
-        }
-        PRUint32 utf16Offset = mUTF16Offset;
-        rv = mGroup->SetGlyphs(mTextRun, aFont, aUTF8, aLength,
-                               &utf16Offset, glyphString, mSpaceWidth, PR_FALSE);
-        pango_glyph_string_free(glyphString);
-        NS_ENSURE_SUCCESS(rv, rv);
-
-        mUTF16Offset = utf16Offset;
-        return NS_OK;
-    }
-
-    nsresult AppendMissingSegment(const gchar *aUTF8, PRUint32 aLength) {
-        if (aLength == 0)
-            return NS_OK;
-
-        nsresult rv = mTextRun->AddGlyphRun(mFonts[0], mUTF16Offset);
-        NS_ENSURE_SUCCESS(rv, rv);
-        PRUint32 utf16Offset = mUTF16Offset;
-        rv = mGroup->SetMissingGlyphs(mTextRun, aUTF8, aLength, &utf16Offset);
-        NS_ENSURE_SUCCESS(rv, rv);
-
-        mUTF16Offset = utf16Offset;
-        return NS_OK;
-    }
-
-    gfxPangoFont *GetNextFont() {
-TRY_AGAIN_HOPE_FOR_THE_BEST_2:
-        if (mFontIndex < mFonts.Length()) {
-            return mFonts[mFontIndex++];
-        } else if (!mTriedPrefFonts) {
-            mTriedPrefFonts = PR_TRUE;
-            nsCAutoString mozLang;
-            GetMozLanguage(mItem->analysis.language, mozLang);
-            if (!mozLang.IsEmpty()) {
-                PRInt32 index = GetCJKLangGroupIndex(mozLang.get());
-                if (index >= 0)
-                    AppendCJKPrefFonts();
-                else
-                    AppendPrefFonts(mozLang.get());
-            } else {
-                NS_ConvertUTF8toUTF16 str(mString);
-                PRBool appenedCJKFonts = PR_FALSE;
-                for (PRUint32 i = 0; i < str.Length(); ++i) {
-                    const PRUnichar ch = str[i];
-                    PRUint32 unicodeRange = FindCharUnicodeRange(ch);
-
-                    /* special case CJK */
-                    if (unicodeRange == kRangeSetCJK) {
-                        if (!appenedCJKFonts) {
-                            appenedCJKFonts = PR_TRUE;
-                            AppendCJKPrefFonts();
-                        }
-                    } else {
-                        const char *langGroup =
-                            LangGroupFromUnicodeRange(unicodeRange);
-                        if (langGroup)
-                            AppendPrefFonts(langGroup);
-                    }
-                }
-            }
-            goto TRY_AGAIN_HOPE_FOR_THE_BEST_2;
-        } else if (!mTriedOtherFonts) {
-            mTriedOtherFonts = PR_TRUE;
-            // XXX we should try by all system fonts
-            goto TRY_AGAIN_HOPE_FOR_THE_BEST_2;
-        }
-        return nsnull;
-    }
-
-    void AppendPrefFonts(const char *aLangGroup) {
-        NS_ASSERTION(aLangGroup, "aLangGroup is null");
-        gfxPlatform *platform = gfxPlatform::GetPlatform();
-        nsString fonts;
-        platform->GetPrefFonts(aLangGroup, fonts);
-        if (fonts.IsEmpty())
-            return;
-        gfxFontGroup::ForEachFont(fonts, nsDependentCString(aLangGroup),
-                                  FontSelector::AddFontCallback, this);
-        return;
-   }
-
-   void AppendCJKPrefFonts() {
-       nsCOMPtr<nsIPrefService> prefs =
-           do_GetService(NS_PREFSERVICE_CONTRACTID);
-       if (!prefs)
-           return;
-
-       nsCOMPtr<nsIPrefBranch> prefBranch;
-       prefs->GetBranch(0, getter_AddRefs(prefBranch));
-       if (!prefBranch)
-           return;
-
-       // Add the accept languages.
-       nsXPIDLCString list;
-       nsresult rv = prefBranch->GetCharPref("intl.accept_languages",
-                                             getter_Copies(list));
-       if (NS_SUCCEEDED(rv) && !list.IsEmpty()) {
-           const char kComma = ',';
-           const char *p, *p_end;
-           list.BeginReading(p);
-           list.EndReading(p_end);
-           while (p < p_end) {
-               while (nsCRT::IsAsciiSpace(*p)) {
-                   if (++p == p_end)
-                       break;
-               }
-               if (p == p_end)
-                   break;
-               const char *start = p;
-               while (++p != p_end && *p != kComma)
-                   /* nothing */ ;
-               nsCAutoString lang(Substring(start, p));
-               lang.CompressWhitespace(PR_FALSE, PR_TRUE);
-               PRInt32 index = GetCJKLangGroupIndex(lang.get());
-               if (index >= 0)
-                   AppendPrefFonts(sCJKLangGroup[index]);
-               p++;
-           }
-       }
-
-       // XXX I think that we should append system locale here if it is CJK.
-
-       // last resort...
-       AppendPrefFonts(CJK_LANG_JA);
-       AppendPrefFonts(CJK_LANG_KO);
-       AppendPrefFonts(CJK_LANG_ZH_CN);
-       AppendPrefFonts(CJK_LANG_ZH_HK);
-       AppendPrefFonts(CJK_LANG_ZH_TW);
-    }
-};
-
 void 
 gfxPangoFontGroup::CreateGlyphRunsItemizing(gfxTextRun *aTextRun,
-                                            const gchar *aUTF8, PRUint32 aUTF8Length,
-                                            PRUint32 aUTF8HeaderLen)
-{
-    GList *items = pango_itemize(GetFontAt(0)->GetPangoContext(), aUTF8, 0,
-                                 aUTF8Length, nsnull, nsnull);
-    
-    PRUint32 utf16Offset = 0;
-    PRBool isRTL = aTextRun->IsRightToLeft();
-    GList *pos = items;
-    for (; pos && pos->data; pos = pos->next) {
-        PangoItem *item = (PangoItem *)pos->data;
-        NS_ASSERTION(isRTL == item->analysis.level % 2, "RTL assumption mismatch");
-
-        PRUint32 offset = item->offset;
-        PRUint32 length = item->length;
-        if (offset < aUTF8HeaderLen) {
-            if (offset + length <= aUTF8HeaderLen) {
-                pango_item_free(item);
-                continue;
+                                            const gchar *aUTF8, PRUint32 aUTF8Length)
+{
+    PangoScriptIter *scriptIter = pango_script_iter_new(aUTF8, aUTF8Length);
+
+    do {
+        const char *start;
+        const char *end;
+        PangoScript script;
+        pango_script_iter_get_range(scriptIter, &start, &end, &script);
+        const PRUint32 len = end - start;
+
+        // apparently this is a static pointer so we don't have to free it
+        PangoLanguage *lang = pango_script_get_sample_language(script);
+
+        PangoFontDescription *fontDesc = pango_font_description_new();
+
+        // these should be FontEntries or something similar rather than gfxPangoFonts...
+        nsString fontList;
+        for (PRUint32 i = 0; i < mFonts.Length(); i++) {
+            fontList.Append(mFonts[i]->GetName());
+            fontList.Append(NS_LITERAL_STRING(", "));
+        }
+
+
+        // XXX which lang group do we want to use here?
+        // XXX do we need to resolve these first or are they already resolved?
+        nsString prefFonts;
+        nsCString langGroup;
+        GetMozLanguage(lang, langGroup);
+        gfxPlatform::GetPlatform()->GetPrefFonts(langGroup.get(), prefFonts);
+        fontList.Append(prefFonts);
+
+        pango_font_description_set_family(fontDesc, NS_ConvertUTF16toUTF8(fontList).get());
+        gfxFloat size = GetStyle()->size;
+        MOZ_pango_font_description_set_absolute_size(fontDesc, size * PANGO_SCALE);
+        pango_font_description_set_style(fontDesc, ThebesStyleToPangoStyle(GetStyle()));
+        pango_font_description_set_weight(fontDesc, ThebesStyleToPangoWeight(GetStyle()));
+
+        PangoContext *context = GetFontAt(0)->GetPangoContext();
+        pango_context_set_font_description(context, fontDesc);
+
+        // we should set this to null if we don't have a text language from the page...
+        // except that we almost always have something...
+        pango_context_set_language(context, lang);
+
+
+        PangoDirection dir = aTextRun->IsRightToLeft() ? PANGO_DIRECTION_RTL : PANGO_DIRECTION_LTR;
+        GList *items = pango_itemize_with_base_dir(context, dir, start, 0, len, nsnull, nsnull);
+
+        PRUint32 utf16Offset = 0;
+        PRBool isRTL = aTextRun->IsRightToLeft();
+        GList *pos = items;
+        for (; pos && pos->data; pos = pos->next) {
+            PangoItem *item = (PangoItem *)pos->data;
+            NS_ASSERTION(isRTL == item->analysis.level % 2, "RTL assumption mismatch");
+
+            PRUint32 offset = item->offset;
+            PRUint32 length = item->length;
+
+            // need to append glyph runs here.
+            PangoGlyphString *glyphString = pango_glyph_string_new();
+            if (!glyphString)
+                return; // OOM
+
+            pango_shape(start + offset, length, &item->analysis, glyphString);
+
+            /* look up the gfxPangoFont from the PangoFont */
+            // XXX we need a function to do this.. until then do this
+            PangoFontDescription *d = pango_font_describe(item->analysis.font);
+            nsRefPtr<gfxPangoFont> font = GetOrMakeFont(NS_ConvertUTF8toUTF16(pango_font_description_get_family(d)), GetStyle());
+            pango_font_description_free(d);
+
+            SetupClusterBoundaries(aTextRun, start + offset, length, utf16Offset, &item->analysis);
+
+            nsresult rv = aTextRun->AddGlyphRun(font, utf16Offset);
+            if (NS_FAILED(rv)) {
+                NS_ERROR("AddGlyphRun Failed");
+                pango_glyph_string_free(glyphString);
+                return;
             }
-            length -= aUTF8HeaderLen - offset;
-            offset = aUTF8HeaderLen;
-        }
-        
-        SetupClusterBoundaries(aTextRun, aUTF8 + offset, length, utf16Offset, &item->analysis);
-        FontSelector fs(aUTF8 + offset, length, this, aTextRun, item, utf16Offset, isRTL);
-        fs.Run(); // appends GlyphRuns
-        utf16Offset = fs.GetUTF16Offset();
-        pango_item_free(item);
-    }
-
-    NS_ASSERTION(utf16Offset == aTextRun->GetLength(),
-                 "Didn't resolve all characters");
-  
-    if (items)
-        g_list_free(items);
-}
+
+            PRUint32 spaceWidth = NS_lround(font->GetMetrics().spaceWidth * FLOAT_PANGO_SCALE);
+
+            rv = SetGlyphs(aTextRun, font, start + offset, length, &utf16Offset, glyphString, spaceWidth, PR_FALSE);
+
+            pango_glyph_string_free(glyphString);
+        }
+
+        if (items)
+            g_list_free(items);
+
+        pango_font_description_free(fontDesc);
+
+    } while(pango_script_iter_next(scriptIter));
+
+    pango_script_iter_free(scriptIter);
+}
+
+
 
 /**
  ** language group helpers
