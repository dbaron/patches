From: L. David Baron <dbaron@dbaron.org>

Bug 898329 patch 5:  Create and use ElementRestyler::mResolvedChild.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1924,16 +1924,17 @@ ElementRestyler::ElementRestyler(nsPresC
   , mContent(mFrame->GetContent() ? mFrame->GetContent() : mParentContent)
   , mChangeList(aChangeList)
   , mMinChange(NS_SubtractHint(aMinChange,
                NS_HintsNotHandledForDescendantsIn(aMinChange)))
   , mParentFrameHintsNotHandledForDescendants(nsChangeHint(0))
   , mHintsNotHandledForDescendants(nsChangeHint(0))
   , mRestyleTracker(aRestyleTracker)
   , mTreeMatchContext(aTreeMatchContext)
+  , mResolvedChild(nullptr)
   , mDesiredA11yNotifications(eSendAllNotifications)
   , mKidsDesiredA11yNotifications(mDesiredA11yNotifications)
   , mOurA11yNotification(eDontNotify)
   , mVisibleKidsOfHiddenElement(aVisibleKidsOfHiddenElement)
 {
 }
 
 ElementRestyler::ElementRestyler(const ElementRestyler& aParentRestyler,
@@ -1948,16 +1949,17 @@ ElementRestyler::ElementRestyler(const E
   , mChangeList(aParentRestyler.mChangeList)
   , mMinChange(NS_SubtractHint(aParentRestyler.mMinChange,
                NS_HintsNotHandledForDescendantsIn(aParentRestyler.mMinChange)))
   , mParentFrameHintsNotHandledForDescendants(
       aParentRestyler.mHintsNotHandledForDescendants)
   , mHintsNotHandledForDescendants(nsChangeHint(0))
   , mRestyleTracker(aParentRestyler.mRestyleTracker)
   , mTreeMatchContext(aParentRestyler.mTreeMatchContext)
+  , mResolvedChild(nullptr)
   , mDesiredA11yNotifications(aParentRestyler.mKidsDesiredA11yNotifications)
   , mKidsDesiredA11yNotifications(mDesiredA11yNotifications)
   , mOurA11yNotification(eDontNotify)
   , mVisibleKidsOfHiddenElement(aParentRestyler.mVisibleKidsOfHiddenElement)
 {
   if (aConstructorFlags & FOR_OUT_OF_FLOW_CHILD) {
     mMinChange = NS_SubtractHint(mMinChange, nsChangeHint_AllReflowHints);
   }
@@ -1976,16 +1978,17 @@ ElementRestyler::ElementRestyler(ParentC
   , mMinChange(NS_SubtractHint(aParentRestyler.mMinChange,
                NS_HintsNotHandledForDescendantsIn(aParentRestyler.mMinChange)))
   , mParentFrameHintsNotHandledForDescendants(
       // assume the worst
       nsChangeHint_Hints_NotHandledForDescendants)
   , mHintsNotHandledForDescendants(nsChangeHint(0))
   , mRestyleTracker(aParentRestyler.mRestyleTracker)
   , mTreeMatchContext(aParentRestyler.mTreeMatchContext)
+  , mResolvedChild(nullptr)
   , mDesiredA11yNotifications(aParentRestyler.mDesiredA11yNotifications)
   , mKidsDesiredA11yNotifications(mDesiredA11yNotifications)
   , mOurA11yNotification(eDontNotify)
   , mVisibleKidsOfHiddenElement(aParentRestyler.mVisibleKidsOfHiddenElement)
 {
 }
 
 void
@@ -2071,17 +2074,16 @@ ElementRestyler::Restyle(nsRestyleHint a
 
     nsRestyleHint childRestyleHint = aRestyleHint;
 
     if (childRestyleHint == eRestyle_Self) {
       childRestyleHint = nsRestyleHint(0);
     }
 
     nsStyleContext* parentContext;
-    nsIFrame* resolvedChild = nullptr;
     // Get the frame providing the parent style context.  If it is a
     // child, then resolve the provider first.
     nsIFrame* providerFrame = mFrame->GetParentStyleContextFrame();
     bool isChild = providerFrame && providerFrame->GetParent() == mFrame;
     if (!isChild) {
       if (providerFrame)
         parentContext = providerFrame->StyleContext();
       else
@@ -2105,19 +2107,19 @@ ElementRestyler::Restyle(nsRestyleHint a
       ElementRestyler providerRestyler(PARENT_CONTEXT_FROM_CHILD_FRAME,
                                        *this, providerFrame);
       providerRestyler.Restyle(aRestyleHint);
       assumeDifferenceHint = providerRestyler.MinChange();
 
       // The provider's new context becomes the parent context of
       // mFrame's context.
       parentContext = providerFrame->StyleContext();
-      // Set |resolvedChild| so we don't bother resolving the
+      // Set |mResolvedChild| so we don't bother resolving the
       // provider again.
-      resolvedChild = providerFrame;
+      mResolvedChild = providerFrame;
     }
 
     if (providerFrame != mFrame->GetParent()) {
       // We don't actually know what the parent style context's
       // non-inherited hints were, so assume the worst.
       mParentFrameHintsNotHandledForDescendants =
         nsChangeHint_Hints_NotHandledForDescendants;
     }
@@ -2550,17 +2552,17 @@ ElementRestyler::Restyle(nsRestyleHint a
                                    parent && parent->IsElement() ? parent->AsElement() : nullptr);
 
             // only do frames that are in flow
             if (nsGkAtoms::placeholderFrame == child->GetType()) { // placeholder
               // get out of flow frame and recur there
               nsIFrame* outOfFlowFrame =
                 nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
               NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
-              NS_ASSERTION(outOfFlowFrame != resolvedChild,
+              NS_ASSERTION(outOfFlowFrame != mResolvedChild,
                            "out-of-flow frame not a true descendant");
 
               // Note that the out-of-flow may not be a geometric descendant of
               // the frame where we started the reresolve.  Therefore, even if
               // mMinChange already includes nsChangeHint_AllReflowHints we don't
               // want to pass that on to the out-of-flow reresolve, since that
               // can lead to the out-of-flow not getting reflowed when it should
               // be (eg a reresolve starting at <body> that involves reflowing
@@ -2578,17 +2580,17 @@ ElementRestyler::Restyle(nsRestyleHint a
               } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
 
               // reresolve placeholder's context under the same parent
               // as the out-of-flow frame
               ElementRestyler phRestyler(*this, child, 0);
               phRestyler.Restyle(childRestyleHint);
             }
             else {  // regular child frame
-              if (child != resolvedChild) {
+              if (child != mResolvedChild) {
                 ElementRestyler childRestyler(*this, child, 0);
                 childRestyler.Restyle(childRestyleHint);
               }
             }
           }
         }
       }
       // XXX need to do overflow frames???
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -341,16 +341,17 @@ private:
   // We need to generate a new change list entry for every frame whose
   // style comparision returns a hint other than one of these hints.
   nsChangeHint mMinChange;
   // See nsStyleContext::CalcStyleDifference
   nsChangeHint mParentFrameHintsNotHandledForDescendants;
   nsChangeHint mHintsNotHandledForDescendants;
   RestyleTracker& mRestyleTracker;
   TreeMatchContext& mTreeMatchContext;
+  nsIFrame* mResolvedChild; // child that provides our parent style context
 
   const DesiredA11yNotifications mDesiredA11yNotifications;
   DesiredA11yNotifications mKidsDesiredA11yNotifications;
   A11yNotificationType mOurA11yNotification;
   nsTArray<nsIContent*>& mVisibleKidsOfHiddenElement;
   bool mWasFrameVisible;
 };
 
