
# HG changeset patch
# User Lars T Hansen <lhansen@mozilla.com>
# Date 1410966659 -7200
# Node ID 98dd1d0aba486102e124eaee91e4b0f2c3943b04
# Parent  512ef66a96b88a5041c27e92881b2f5304a92cc7
Bug 1068539 - Keep the serialization format compatible, increment the version number. r=jorendorff,khuey

diff --git a/dom/indexedDB/ActorsParent.cpp b/dom/indexedDB/ActorsParent.cpp
--- a/dom/indexedDB/ActorsParent.cpp
+++ b/dom/indexedDB/ActorsParent.cpp
@@ -118,21 +118,21 @@ class TransactionBase;
 class VersionChangeTransaction;
 
 /*******************************************************************************
  * Constants
  ******************************************************************************/
 
 // If JS_STRUCTURED_CLONE_VERSION changes then we need to update our major
 // schema version.
-static_assert(JS_STRUCTURED_CLONE_VERSION == 4,
+static_assert(JS_STRUCTURED_CLONE_VERSION == 5,
               "Need to update the major schema version.");
 
 // Major schema version. Bump for almost everything.
-const uint32_t kMajorSchemaVersion = 16;
+const uint32_t kMajorSchemaVersion = 17;
 
 // Minor schema version. Should almost always be 0 (maybe bump on release
 // branches if we have to).
 const uint32_t kMinorSchemaVersion = 0;
 
 // The schema version we store in the SQLite database is a (signed) 32-bit
 // integer. The major version is left-shifted 4 bits so the max value is
 // 0xFFFFFFF. The minor version occupies the lower 4 bits and its max is 0xF.
@@ -2132,16 +2132,29 @@ UpgradeSchemaFrom15_0To16_0(mozIStorageC
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   return NS_OK;
 }
 
 nsresult
+UpgradeSchemaFrom16_0To17_0(mozIStorageConnection* aConnection)
+{
+  // The only change between 16 and 17 was a different structured
+  // clone format, but it's backwards-compatible.
+  nsresult rv = aConnection->SetSchemaVersion(MakeSchemaVersion(17, 0));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  return NS_OK;
+}
+
+nsresult
 GetDatabaseFileURL(nsIFile* aDatabaseFile,
                    PersistenceType aPersistenceType,
                    const nsACString& aGroup,
                    const nsACString& aOrigin,
                    nsIFileURL** aResult)
 {
   MOZ_ASSERT(aDatabaseFile);
   MOZ_ASSERT(aResult);
@@ -2365,17 +2378,17 @@ CreateDatabaseConnection(nsIFile* aDBFil
       }
 
       rv = stmt->Execute();
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
     } else  {
       // This logic needs to change next time we change the schema!
-      static_assert(kSQLiteSchemaVersion == int32_t((16 << 4) + 0),
+      static_assert(kSQLiteSchemaVersion == int32_t((17 << 4) + 0),
                     "Upgrade function needed due to schema version increase.");
 
       while (schemaVersion != kSQLiteSchemaVersion) {
         if (schemaVersion == 4) {
           rv = UpgradeSchemaFrom4To5(connection);
         } else if (schemaVersion == 5) {
           rv = UpgradeSchemaFrom5To6(connection);
         } else if (schemaVersion == 6) {
@@ -2394,16 +2407,18 @@ CreateDatabaseConnection(nsIFile* aDBFil
         } else if (schemaVersion == MakeSchemaVersion(12, 0)) {
           rv = UpgradeSchemaFrom12_0To13_0(connection, &vacuumNeeded);
         } else if (schemaVersion == MakeSchemaVersion(13, 0)) {
           rv = UpgradeSchemaFrom13_0To14_0(connection);
         } else if (schemaVersion == MakeSchemaVersion(14, 0)) {
           rv = UpgradeSchemaFrom14_0To15_0(connection);
         } else if (schemaVersion == MakeSchemaVersion(15, 0)) {
           rv = UpgradeSchemaFrom15_0To16_0(connection);
+        } else if (schemaVersion == MakeSchemaVersion(16, 0)) {
+          rv = UpgradeSchemaFrom16_0To17_0(connection);
         } else {
           IDB_WARNING("Unable to open IndexedDB database, no upgrade path is "
                       "available!");
           return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
         }
 
         if (NS_WARN_IF(NS_FAILED(rv))) {
           return rv;
diff --git a/js/public/StructuredClone.h b/js/public/StructuredClone.h
--- a/js/public/StructuredClone.h
+++ b/js/public/StructuredClone.h
@@ -58,22 +58,23 @@ enum TransferableOwnership {
 // tag and data are the pair of uint32_t values from the header. The callback
 // may use the JS_Read* APIs to read any other relevant parts of the object
 // from the reader r. closure is any value passed to the JS_ReadStructuredClone
 // function. Return the new object on success, nullptr on error/exception.
 typedef JSObject *(*ReadStructuredCloneOp)(JSContext *cx, JSStructuredCloneReader *r,
                                            uint32_t tag, uint32_t data, void *closure);
 
 // Structured data serialization hook. The engine can write primitive values,
-// Objects, Arrays, Dates, RegExps, TypedArrays, and ArrayBuffers. Any other
-// type of object requires application support. This callback must first use
-// the JS_WriteUint32Pair API to write an object header, passing a value
-// greater than JS_SCTAG_USER to the tag parameter. Then it can use the
-// JS_Write* APIs to write any other relevant parts of the value v to the
-// writer w. closure is any value passed to the JS_WriteStructuredCLone function.
+// Objects, Arrays, Dates, RegExps, TypedArrays, ArrayBuffers, Sets, Maps,
+// and SharedTypedArrays. Any other type of object requires application support.
+// This callback must first use the JS_WriteUint32Pair API to write an object
+// header, passing a value greater than JS_SCTAG_USER to the tag parameter.
+// Then it can use the JS_Write* APIs to write any other relevant parts of
+// the value v to the writer w. closure is any value passed to the
+// JS_WriteStructuredClone function.
 //
 // Return true on success, false on error/exception.
 typedef bool (*WriteStructuredCloneOp)(JSContext *cx, JSStructuredCloneWriter *w,
                                        JS::HandleObject obj, void *closure);
 
 // This is called when JS_WriteStructuredClone is given an invalid transferable.
 // To follow HTML5, the application must throw a DATA_CLONE_ERR DOMException
 // with error set to one of the JS_SCERR_* values.
@@ -113,20 +114,21 @@ typedef bool (*TransferStructuredCloneOp
                                           uint64_t *extraData);
 
 // Called when JS_ClearStructuredClone has to free an unknown transferable
 // object. Note that it should never trigger a garbage collection (and will
 // assert in a debug build if it does.)
 typedef void (*FreeTransferStructuredCloneOp)(uint32_t tag, JS::TransferableOwnership ownership,
                                               void *content, uint64_t extraData, void *closure);
 
-// The maximum supported structured-clone serialization format version. Note
-// that this does not need to be bumped for Transferable-only changes, since
-// they are never saved to persistent storage.
-#define JS_STRUCTURED_CLONE_VERSION 4
+// The maximum supported structured-clone serialization format version.
+// Increment this when anything at all changes in the serialization format.
+// (Note that this does not need to be bumped for Transferable-only changes,
+// since they are never saved to persistent storage.)
+#define JS_STRUCTURED_CLONE_VERSION 5
 
 struct JSStructuredCloneCallbacks {
     ReadStructuredCloneOp read;
     WriteStructuredCloneOp write;
     StructuredCloneErrorOp reportError;
     ReadTransferStructuredCloneOp readTransfer;
     TransferStructuredCloneOp writeTransfer;
     FreeTransferStructuredCloneOp freeTransfer;
diff --git a/js/src/vm/StructuredClone.cpp b/js/src/vm/StructuredClone.cpp
--- a/js/src/vm/StructuredClone.cpp
+++ b/js/src/vm/StructuredClone.cpp
@@ -50,16 +50,25 @@
 
 using namespace js;
 
 using mozilla::IsNaN;
 using mozilla::LittleEndian;
 using mozilla::NativeEndian;
 using JS::CanonicalizeNaN;
 
+// When you make updates here, make sure you consider whether you need to bump the
+// value of JS_STRUCTURED_CLONE_VERSION in js/public/StructuredClone.h.  You will
+// likely need to increment the version if anything at all changes in the serialization
+// format.
+//
+// Note that SCTAG_END_OF_KEYS is written into the serialized form and should have
+// a stable ID, it need not be at the end of the list and should not be used for
+// sizing data structures.
+
 enum StructuredDataType MOZ_ENUM_TYPE(uint32_t) {
     /* Structured data types provided by the engine */
     SCTAG_FLOAT_MAX = 0xFFF00000,
     SCTAG_NULL = 0xFFFF0000,
     SCTAG_UNDEFINED,
     SCTAG_BOOLEAN,
     SCTAG_INT32,
     SCTAG_STRING,
@@ -72,18 +81,18 @@ enum StructuredDataType MOZ_ENUM_TYPE(ui
     SCTAG_STRING_OBJECT,
     SCTAG_NUMBER_OBJECT,
     SCTAG_BACK_REFERENCE_OBJECT,
     SCTAG_DO_NOT_USE_1, // Required for backwards compatibility
     SCTAG_DO_NOT_USE_2, // Required for backwards compatibility
     SCTAG_TYPED_ARRAY_OBJECT,
     SCTAG_MAP_OBJECT,
     SCTAG_SET_OBJECT,
+    SCTAG_END_OF_KEYS,
     SCTAG_SHARED_TYPED_ARRAY_OBJECT,
-    SCTAG_END_OF_KEYS,
 
     SCTAG_TYPED_ARRAY_V1_MIN = 0xFFFF0100,
     SCTAG_TYPED_ARRAY_V1_INT8 = SCTAG_TYPED_ARRAY_V1_MIN + Scalar::Int8,
     SCTAG_TYPED_ARRAY_V1_UINT8 = SCTAG_TYPED_ARRAY_V1_MIN + Scalar::Uint8,
     SCTAG_TYPED_ARRAY_V1_INT16 = SCTAG_TYPED_ARRAY_V1_MIN + Scalar::Int16,
     SCTAG_TYPED_ARRAY_V1_UINT16 = SCTAG_TYPED_ARRAY_V1_MIN + Scalar::Uint16,
     SCTAG_TYPED_ARRAY_V1_INT32 = SCTAG_TYPED_ARRAY_V1_MIN + Scalar::Int32,
     SCTAG_TYPED_ARRAY_V1_UINT32 = SCTAG_TYPED_ARRAY_V1_MIN + Scalar::Uint32,
