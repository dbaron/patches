From: L. David Baron <dbaron@dbaron.org>

Add bit to lines indicating that they may have a placeholder for a float that was pushed to the next line (and bump the child count up to 32 bits).  (Bug 563584)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -4209,17 +4209,17 @@ nsBlockFrame::PlaceLine(nsBlockReflowSta
   
   // Add the already placed current-line floats to the line
   aLine->AppendFloats(aState.mCurrentLineFloats);
 
   // Any below current line floats to place?
   if (aState.mBelowCurrentLineFloats.NotEmpty()) {
     // Reflow the below-current-line floats, which places on the line's
     // float list.
-    aState.PlaceBelowCurrentLineFloats(aState.mBelowCurrentLineFloats);
+    aState.PlaceBelowCurrentLineFloats(aState.mBelowCurrentLineFloats, aLine);
     aLine->AppendFloats(aState.mBelowCurrentLineFloats);
   }
 
   // When a line has floats, factor them into the combined-area
   // computations.
   if (aLine->HasFloats()) {
     // Combine the float combined area (stored in aState) and the
     // value computed by the line layout code.
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -608,16 +608,18 @@ nsBlockReflowState::AddFloat(nsLineLayou
       // Pass on updated available space to the current inline reflow engine
       nsFlowAreaRect floatAvailSpace = GetFloatAvailableSpace(mY);
       nsRect availSpace(nsPoint(floatAvailSpace.mRect.x + BorderPadding().left,
                                 mY),
                         floatAvailSpace.mRect.Size());
       aLineLayout->UpdateBand(availSpace, aFloat);
       // Record this float in the current-line list
       mCurrentLineFloats.Append(mFloatCacheFreeList.Alloc(aFloat));
+    } else {
+      (*aLineLayout->GetLine())->SetHadFloatPushed();
     }
   }
   else {
     // Always claim to be placed; we don't know whether we fit yet, so we
     // deal with this in PlaceBelowCurrentLineFloats
     placed = PR_TRUE;
     // This float will be placed after the line is done (it is a
     // below-current-line float).
@@ -942,33 +944,35 @@ nsBlockReflowState::PushFloatPastBreak(n
 
   NS_FRAME_SET_OVERFLOW_INCOMPLETE(mReflowStatus);
 }
 
 /**
  * Place below-current-line floats.
  */
 void
-nsBlockReflowState::PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aList)
+nsBlockReflowState::PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aList,
+                                                nsLineBox* aLine)
 {
   nsFloatCache* fc = aList.Head();
   while (fc) {
 #ifdef DEBUG
     if (nsBlockFrame::gNoisyReflow) {
       nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
       printf("placing bcl float: ");
       nsFrame::ListTag(stdout, fc->mFloat);
       printf("\n");
     }
 #endif
     // Place the float
     PRBool placed = FlowAndPlaceFloat(fc->mFloat);
     nsFloatCache *next = fc->Next();
     if (!placed) {
       aList.Remove(fc);
+      aLine->SetHadFloatPushed();
     }
     fc = next;
   }
 }
 
 nscoord
 nsBlockReflowState::ClearFloats(nscoord aY, PRUint8 aBreakType,
                                 nsIFrame *aReplacedBlock)
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -110,17 +110,18 @@ public:
 private:
   PRBool CanPlaceFloat(nscoord aFloatWidth,
                        const nsFlowAreaRect& aFloatAvailableSpace);
 public:
   PRBool FlowAndPlaceFloat(nsIFrame* aFloat);
 private:
   void PushFloatPastBreak(nsIFrame* aFloat);
 public:
-  void PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aFloats);
+  void PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aFloats,
+                                   nsLineBox* aLine);
 
   // Returns the first coordinate >= aY that clears the
   // floats indicated by aBreakType and has enough width between floats
   // (or no floats remaining) to accomodate aReplacedBlock.
   nscoord ClearFloats(nscoord aY, PRUint8 aBreakType,
                       nsIFrame *aReplacedBlock = nsnull);
 
   PRBool IsAdjacentWithTop() const {
diff --git a/layout/generic/nsLineBox.h b/layout/generic/nsLineBox.h
--- a/layout/generic/nsLineBox.h
+++ b/layout/generic/nsLineBox.h
@@ -169,17 +169,17 @@ protected:
   nsFloatCache* mTail;
 
   friend class nsFloatCacheList;
 };
 
 //----------------------------------------------------------------------
 
 #define LINE_MAX_BREAK_TYPE  ((1 << 4) - 1)
-#define LINE_MAX_CHILD_COUNT ((1 << 20) - 1)
+#define LINE_MAX_CHILD_COUNT PR_INT32_MAX
 
 #if NS_STYLE_CLEAR_LAST_VALUE > 15
 need to rearrange the mBits bitfield;
 #endif
 
 // Funtion to create a line box
 nsLineBox* NS_NewLineBox(nsIPresShell* aPresShell, nsIFrame* aFrame,
                          PRInt32 aCount, PRBool aIsBlock);
@@ -325,18 +325,29 @@ public:
   }
   void ClearHasBullet() {
     mFlags.mHasBullet = PR_FALSE;
     InvalidateCachedIsEmpty();
   }
   PRBool HasBullet() const {
     return mFlags.mHasBullet;
   }
-  
-  
+
+  // mHadFloatPushed bit
+  void SetHadFloatPushed() {
+    mFlags.mHadFloatPushed = PR_TRUE;
+  }
+  void ClearHadFloatPushed() {
+    mFlags.mHadFloatPushed = PR_FALSE;
+  }
+  PRBool HadFloatPushed() const {
+    return mFlags.mHadFloatPushed;
+  }
+
+
   // mChildCount value
   PRInt32 GetChildCount() const {
     return (PRInt32) mFlags.mChildCount;
   }
   void SetChildCount(PRInt32 aNewCount) {
     if (aNewCount < 0) {
       NS_WARNING("negative child count");
       aNewCount = 0;
@@ -496,19 +507,23 @@ public:
     PRUint32 mLineWrapped: 1;
     PRUint32 mInvalidateTextRuns : 1;
     PRUint32 mResizeReflowOptimizationDisabled: 1;  // default 0 = means that the opt potentially applies to this line. 1 = never skip reflowing this line for a resize reflow
     PRUint32 mEmptyCacheValid: 1;
     PRUint32 mEmptyCacheState: 1;
     // mHasBullet indicates that this is an inline line whose block's
     // bullet is adjacent to this line and non-empty.
     PRUint32 mHasBullet : 1;
+    // Indicates that this line *may* have a placeholder for a float
+    // that was pushed to a later column or page.
+    PRUint32 mHadFloatPushed : 1;
     PRUint32 mBreakType : 4;
 
-    PRUint32 mChildCount : 17;
+    // FIXME: Move this out of FlagBits
+    PRUint32 mChildCount;
   };
 
   struct ExtraData {
     ExtraData(const nsRect& aBounds) : mCombinedArea(aBounds) {
     }
     nsRect mCombinedArea;
   };
 
