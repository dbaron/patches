From: L. David Baron <dbaron@dbaron.org>

Add calc() support for lengths in text-shadow and -moz-box-shadow.  (Bug 363249)

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -9269,32 +9269,32 @@ CSSParserImpl::ParseCSSShadowList(PRBool
     if (aIsBoxShadow) {
       // Optional inset keyword (ignore errors)
       ParseVariant(isInset, VARIANT_KEYWORD,
                    nsCSSProps::kBoxShadowTypeKTable);
     }
 
     PRBool isFirstToken = (cur == list && isInset.GetUnit() == eCSSUnit_Null);
     if (!ParseVariant(cur->mValue,
-                      isFirstToken ? VARIANT_HC | VARIANT_LENGTH | VARIANT_NONE
-                                   : VARIANT_COLOR | VARIANT_LENGTH,
+                      ( isFirstToken ? VARIANT_INHERIT | VARIANT_NONE : 0) |
+                      VARIANT_COLOR | VARIANT_LENGTH | VARIANT_CALC,
                       nsnull)) {
       break;
     }
 
     nsCSSUnit unit = cur->mValue.GetUnit();
     if (unit != eCSSUnit_None && unit != eCSSUnit_Inherit &&
         unit != eCSSUnit_Initial) {
       nsRefPtr<nsCSSValue::Array> val = nsCSSValue::Array::Create(6);
       if (!val) {
         mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
         break;
       }
       PRBool haveColor = PR_FALSE;
-      if (cur->mValue.IsLengthUnit()) {
+      if (cur->mValue.IsLengthUnit() || cur->mValue.IsCalcUnit()) {
         val->Item(IndexX) = cur->mValue;
       } else {
         // Must be a color (as string or color value)
         NS_ASSERTION(unit == eCSSUnit_Ident || unit == eCSSUnit_Color ||
                      unit == eCSSUnit_EnumColor,
                      "Must be a color value (named color, numeric color, "
                      "or system color)");
         haveColor = PR_TRUE;
@@ -9304,32 +9304,34 @@ CSSParserImpl::ParseCSSShadowList(PRBool
         if (!ParseVariant(val->Item(IndexX), VARIANT_LENGTH,
                           nsnull)) {
           break;
         }
       }
       cur->mValue.SetArrayValue(val, eCSSUnit_Array);
 
       // Y coordinate; this one is not optional
-      if (!ParseVariant(val->Item(IndexY), VARIANT_LENGTH, nsnull)) {
+      if (!ParseVariant(val->Item(IndexY), VARIANT_LENGTH | VARIANT_CALC,
+                        nsnull)) {
         break;
       }
 
       // Optional radius. Ignore errors except if they pass a negative
       // value which we must reject. If we use ParseNonNegativeVariant we can't
       // tell the difference between an unspecified radius and a negative
       // radius, so that's why we don't use it.
-      if (ParseVariant(val->Item(IndexRadius), VARIANT_LENGTH, nsnull) &&
+      if (ParseVariant(val->Item(IndexRadius), VARIANT_LENGTH | VARIANT_CALC,
+                       nsnull) &&
           val->Item(IndexRadius).GetFloatValue() < 0) {
         break;
       }
 
       if (aIsBoxShadow) {
         // Optional spread (ignore errors)
-        ParseVariant(val->Item(IndexSpread), VARIANT_LENGTH,
+        ParseVariant(val->Item(IndexSpread), VARIANT_LENGTH | VARIANT_CALC,
                      nsnull);
       }
 
       if (!haveColor) {
         // Optional color (ignore errors)
         ParseVariant(val->Item(IndexColor), VARIANT_COLOR,
                      nsnull);
       }
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -3252,43 +3252,44 @@ nsRuleNode::GetShadowData(nsCSSValueList
   nsStyleCoord tempCoord;
   PRBool unitOK;
   for (nsCSSShadowItem* item = shadowList->ShadowAt(0);
        aList;
        aList = aList->mNext, ++item) {
     nsCSSValue::Array *arr = aList->mValue.GetArrayValue();
     // OK to pass bad aParentCoord since we're not passing SETCOORD_INHERIT
     unitOK = SetCoord(arr->Item(0), tempCoord, nsStyleCoord(),
-                      SETCOORD_LENGTH, aContext, mPresContext,
-                      canStoreInRuleTree);
+                      SETCOORD_LENGTH | SETCOORD_CALC_LENGTH_ONLY,
+                      aContext, mPresContext, canStoreInRuleTree);
     NS_ASSERTION(unitOK, "unexpected unit");
     item->mXOffset = tempCoord.GetCoordValue();
 
     unitOK = SetCoord(arr->Item(1), tempCoord, nsStyleCoord(),
-                      SETCOORD_LENGTH, aContext, mPresContext,
-                      canStoreInRuleTree);
+                      SETCOORD_LENGTH | SETCOORD_CALC_LENGTH_ONLY,
+                      aContext, mPresContext, canStoreInRuleTree);
     NS_ASSERTION(unitOK, "unexpected unit");
     item->mYOffset = tempCoord.GetCoordValue();
 
     // Blur radius is optional in the current box-shadow spec
     if (arr->Item(2).GetUnit() != eCSSUnit_Null) {
       unitOK = SetCoord(arr->Item(2), tempCoord, nsStyleCoord(),
-                        SETCOORD_LENGTH, aContext, mPresContext,
-                        canStoreInRuleTree);
+                        SETCOORD_LENGTH | SETCOORD_CALC_LENGTH_ONLY |
+                          SETCOORD_CALC_CLAMP_NONNEGATIVE,
+                        aContext, mPresContext, canStoreInRuleTree);
       NS_ASSERTION(unitOK, "unexpected unit");
       item->mRadius = tempCoord.GetCoordValue();
     } else {
       item->mRadius = 0;
     }
 
     // Find the spread radius
     if (aIsBoxShadow && arr->Item(3).GetUnit() != eCSSUnit_Null) {
       unitOK = SetCoord(arr->Item(3), tempCoord, nsStyleCoord(),
-                        SETCOORD_LENGTH, aContext, mPresContext,
-                        canStoreInRuleTree);
+                        SETCOORD_LENGTH | SETCOORD_CALC_LENGTH_ONLY,
+                        aContext, mPresContext, canStoreInRuleTree);
       NS_ASSERTION(unitOK, "unexpected unit");
       item->mSpread = tempCoord.GetCoordValue();
     } else {
       item->mSpread = 0;
     }
 
     if (arr->Item(4).GetUnit() != eCSSUnit_Null) {
       item->mHasColor = PR_TRUE;
