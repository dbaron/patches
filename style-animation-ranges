From: L. David Baron <dbaron@dbaron.org>

Ensure nsStyleAnimation doesn't produce values outside valid ranges.  (Bug 653842, patch 3)

diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -792,16 +792,17 @@ AddShadowItems(double aCoeff1, const nsC
                     "wrong unit");
   NS_ABORT_IF_FALSE(aValue2.GetUnit() == eCSSUnit_Array,
                     "wrong unit");
   nsCSSValue::Array *array1 = aValue1.GetArrayValue();
   nsCSSValue::Array *array2 = aValue2.GetArrayValue();
   nsRefPtr<nsCSSValue::Array> resultArray = nsCSSValue::Array::Create(6);
 
   for (size_t i = 0; i < 4; ++i) {
+    // FIXME: blur radius (item 3) must be nonnegative!
     AddCSSValuePixel(aCoeff1, array1->Item(i), aCoeff2, array2->Item(i),
                      resultArray->Item(i));
   }
 
   const nsCSSValue& color1 = array1->Item(4);
   const nsCSSValue& color2 = array2->Item(4);
   const nsCSSValue& inset1 = array1->Item(5);
   const nsCSSValue& inset2 = array2->Item(5);
@@ -1327,16 +1328,41 @@ AddTransformLists(const nsCSSValueList* 
     aList1 = aList1->mNext;
     aList2 = aList2->mNext;
   } while (aList1);
   NS_ABORT_IF_FALSE(!aList2, "list length mismatch");
 
   return result.forget();
 }
 
+template <typename T>
+T
+RestrictValue(nsCSSProperty aProperty, T aValue)
+{
+  T result = aValue;
+  switch (nsCSSProps::ValueRestrictions(aProperty)) {
+    case 0:
+      break;
+    case CSS_PROPERTY_VALUE_NONNEGATIVE:
+      if (result < 0) {
+        result = 0;
+      }
+      break;
+    case CSS_PROPERTY_VALUE_AT_LEAST_ONE:
+      if (result < 1) {
+        result = 1;
+      }
+      break;
+    default:
+      NS_ABORT_IF_FALSE(PR_FALSE, "bad value restriction");
+      break;
+  }
+  return result;
+}
+
 PRBool
 nsStyleAnimation::AddWeighted(nsCSSProperty aProperty,
                               double aCoeff1, const Value& aValue1,
                               double aCoeff2, const Value& aValue2,
                               Value& aResultValue)
 {
   Unit commonUnit =
     GetCommonUnit(aProperty, aValue1.GetUnit(), aValue2.GetUnit());
@@ -1354,16 +1380,21 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
       return PR_FALSE;
 
     case eUnit_Enumerated:
       switch (aProperty) {
         case eCSSProperty_font_stretch: {
           // Animate just like eUnit_Integer.
           PRInt32 result = NS_floor(aCoeff1 * double(aValue1.GetIntValue()) +
                                     aCoeff2 * double(aValue2.GetIntValue()));
+          if (result < NS_STYLE_FONT_STRETCH_ULTRA_CONDENSED) {
+            result = NS_STYLE_FONT_STRETCH_ULTRA_CONDENSED;
+          } else if (result > NS_STYLE_FONT_STRETCH_ULTRA_EXPANDED) {
+            result = NS_STYLE_FONT_STRETCH_ULTRA_EXPANDED;
+          }
           aResultValue.SetIntValue(result, eUnit_Enumerated);
           return PR_TRUE;
         }
         default:
           return PR_FALSE;
       }
     case eUnit_Visibility: {
       PRInt32 val1 = aValue1.GetIntValue() == NS_STYLE_VISIBILITY_VISIBLE;
@@ -1377,36 +1408,43 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
     case eUnit_Integer: {
       // http://dev.w3.org/csswg/css3-transitions/#animation-of-property-types-
       // says we should use floor
       PRInt32 result = NS_floor(aCoeff1 * double(aValue1.GetIntValue()) +
                                 aCoeff2 * double(aValue2.GetIntValue()));
       if (aProperty == eCSSProperty_font_weight) {
         NS_ASSERTION(result > 0, "unexpected value");
         result -= result % 100;
+        if (result < 100) {
+          result = 100;
+        } else if (result > 900) {
+          result = 900;
+        }
+      } else {
+        result = RestrictValue(aProperty, result);
       }
       aResultValue.SetIntValue(result, eUnit_Integer);
       return PR_TRUE;
     }
     case eUnit_Coord: {
-      aResultValue.SetCoordValue(NSToCoordRound(
+      aResultValue.SetCoordValue(RestrictValue(aProperty, NSToCoordRound(
         aCoeff1 * aValue1.GetCoordValue() +
-        aCoeff2 * aValue2.GetCoordValue()));
+        aCoeff2 * aValue2.GetCoordValue())));
       return PR_TRUE;
     }
     case eUnit_Percent: {
-      aResultValue.SetPercentValue(
+      aResultValue.SetPercentValue(RestrictValue(aProperty,
         aCoeff1 * aValue1.GetPercentValue() +
-        aCoeff2 * aValue2.GetPercentValue());
+        aCoeff2 * aValue2.GetPercentValue()));
       return PR_TRUE;
     }
     case eUnit_Float: {
-      aResultValue.SetFloatValue(
+      aResultValue.SetFloatValue(RestrictValue(aProperty,
         aCoeff1 * aValue1.GetFloatValue() +
-        aCoeff2 * aValue2.GetFloatValue());
+        aCoeff2 * aValue2.GetFloatValue()));
       return PR_TRUE;
     }
     case eUnit_Color: {
       nscolor color1 = aValue1.GetColorValue();
       nscolor color2 = aValue2.GetColorValue();
       // FIXME (spec): The CSS transitions spec doesn't say whether
       // colors are premultiplied, but things work better when they are,
       // so use premultiplication.  Spec issue is still open per
@@ -1477,20 +1515,22 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
       nsAutoPtr<nsCSSValuePair> result(new nsCSSValuePair);
       static nsCSSValue nsCSSValuePair::* const pairValues[2] = {
         &nsCSSValuePair::mXValue, &nsCSSValuePair::mYValue
       };
       for (PRUint32 i = 0; i < 2; ++i) {
         nsCSSValue nsCSSValuePair::*member = pairValues[i];
         switch (unit[i]) {
           case eCSSUnit_Pixel:
+            // FIXME: value restrictions!
             AddCSSValuePixel(aCoeff1, pair1->*member, aCoeff2, pair2->*member,
                              result->*member);
             break;
           case eCSSUnit_Percent:
+            // FIXME: value restrictions!
             AddCSSValuePercent(aCoeff1, pair1->*member,
                                aCoeff2, pair2->*member,
                                result->*member);
             break;
           case eCSSUnit_Calc:
             AddCSSValueCanonicalCalc(aCoeff1, pair1->*member,
                                      aCoeff2, pair2->*member,
                                      result->*member);
@@ -1501,16 +1541,18 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
         }
       }
 
       aResultValue.SetAndAdoptCSSValuePairValue(result.forget(),
                                                 eUnit_CSSValuePair);
       return PR_TRUE;
     }
     case eUnit_CSSRect: {
+      NS_ABORT_IF_FALSE(nsCSSProps::ValueRestrictions(aProperty) == 0,
+                        "must add code for handling value restrictions");
       const nsCSSRect *rect1 = aValue1.GetCSSRectValue();
       const nsCSSRect *rect2 = aValue2.GetCSSRectValue();
       if (rect1->mTop.GetUnit() != rect2->mTop.GetUnit() ||
           rect1->mRight.GetUnit() != rect2->mRight.GetUnit() ||
           rect1->mBottom.GetUnit() != rect2->mBottom.GetUnit() ||
           rect1->mLeft.GetUnit() != rect2->mLeft.GetUnit()) {
         // At least until we have calc()
         return PR_FALSE;
@@ -1539,16 +1581,17 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
             NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
             return PR_FALSE;
         }
       }
 
       aResultValue.SetAndAdoptCSSRectValue(result.forget(), eUnit_CSSRect);
       return PR_TRUE;
     }
+    // TODO: Up to here...
     case eUnit_Dasharray: {
       const nsCSSValueList *list1 = aValue1.GetCSSValueListValue();
       const nsCSSValueList *list2 = aValue2.GetCSSValueListValue();
 
       PRUint32 len1 = 0, len2 = 0;
       for (const nsCSSValueList *v = list1; v; v = v->mNext) {
         ++len1;
       }
@@ -1583,18 +1626,20 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
         nsCSSValueList *item = new nsCSSValueList;
         if (!item) {
           return PR_FALSE;
         }
         *resultTail = item;
         resultTail = &item->mNext;
 
         if (v1.GetUnit() == eCSSUnit_Number) {
+          // FIXME: nonnegative!
           AddCSSValueNumber(aCoeff1, v1, aCoeff2, v2, item->mValue);
         } else {
+          // FIXME: nonnegative!
           AddCSSValuePercent(aCoeff1, v1, aCoeff2, v2, item->mValue);
         }
 
         list1 = list1->mNext;
         if (!list1) {
           list1 = aValue1.GetCSSValueListValue();
         }
         list2 = list2->mNext;
@@ -1741,22 +1786,25 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
           nsCSSValue &vr = item->*(pairListValues[i]);
           nsCSSUnit unit =
             GetCommonUnit(aProperty, v1.GetUnit(), v2.GetUnit());
           if (unit == eCSSUnit_Null) {
             return PR_FALSE;
           }
           switch (unit) {
             case eCSSUnit_Pixel:
+              // FIXME: value restrictions
               AddCSSValuePixel(aCoeff1, v1, aCoeff2, v2, vr);
               break;
             case eCSSUnit_Percent:
+              // FIXME: value restrictions
               AddCSSValuePercent(aCoeff1, v1, aCoeff2, v2, vr);
               break;
             case eCSSUnit_Calc:
+              // FIXME: value restrictions
               AddCSSValueCanonicalCalc(aCoeff1, v1, aCoeff2, v2, vr);
               break;
             default:
               if (v1 != v2) {
                 return PR_FALSE;
               }
               vr = v1;
               break;
