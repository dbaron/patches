From: L. David Baron <dbaron@dbaron.org>

Ensure nsStyleAnimation doesn't produce values outside valid ranges.

diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -1327,16 +1327,41 @@ AddTransformLists(const nsCSSValueList* 
     aList1 = aList1->mNext;
     aList2 = aList2->mNext;
   } while (aList1);
   NS_ABORT_IF_FALSE(!aList2, "list length mismatch");
 
   return result.forget();
 }
 
+template <typename T>
+T
+RestrictValue(nsCSSProperty aProperty, T aValue)
+{
+  T result = aValue;
+  switch (nsCSSProps::ValueRestrictions(aProperty)) {
+    case 0:
+      break;
+    case CSS_PROPERTY_VALUE_NONNEGATIVE:
+      if (result < 0) {
+        result = 0;
+      }
+      break;
+    case CSS_PROPERTY_VALUE_AT_LEAST_ONE:
+      if (result < 1) {
+        result = 1;
+      }
+      break;
+    default:
+      NS_ABORT_IF_FALSE(PR_FALSE, "bad value restriction");
+      break;
+  }
+  return result;
+}
+
 PRBool
 nsStyleAnimation::AddWeighted(nsCSSProperty aProperty,
                               double aCoeff1, const Value& aValue1,
                               double aCoeff2, const Value& aValue2,
                               Value& aResultValue)
 {
   Unit commonUnit =
     GetCommonUnit(aProperty, aValue1.GetUnit(), aValue2.GetUnit());
@@ -1354,16 +1379,21 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
       return PR_FALSE;
 
     case eUnit_Enumerated:
       switch (aProperty) {
         case eCSSProperty_font_stretch: {
           // Animate just like eUnit_Integer.
           PRInt32 result = NS_floor(aCoeff1 * double(aValue1.GetIntValue()) +
                                     aCoeff2 * double(aValue2.GetIntValue()));
+          if (result < NS_STYLE_FONT_STRETCH_ULTRA_CONDENSED) {
+            result = NS_STYLE_FONT_STRETCH_ULTRA_CONDENSED;
+          } else if (result > NS_STYLE_FONT_STRETCH_ULTRA_EXPANDED) {
+            result = NS_STYLE_FONT_STRETCH_ULTRA_EXPANDED;
+          }
           aResultValue.SetIntValue(result, eUnit_Enumerated);
           return PR_TRUE;
         }
         default:
           return PR_FALSE;
       }
     case eUnit_Visibility: {
       PRInt32 val1 = aValue1.GetIntValue() == NS_STYLE_VISIBILITY_VISIBLE;
@@ -1377,36 +1407,43 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
     case eUnit_Integer: {
       // http://dev.w3.org/csswg/css3-transitions/#animation-of-property-types-
       // says we should use floor
       PRInt32 result = NS_floor(aCoeff1 * double(aValue1.GetIntValue()) +
                                 aCoeff2 * double(aValue2.GetIntValue()));
       if (aProperty == eCSSProperty_font_weight) {
         NS_ASSERTION(result > 0, "unexpected value");
         result -= result % 100;
+        if (result < 100) {
+          result = 100;
+        } else if (result > 900) {
+          result = 900;
+        }
+      } else {
+        result = RestrictValue(aProperty, result);
       }
       aResultValue.SetIntValue(result, eUnit_Integer);
       return PR_TRUE;
     }
     case eUnit_Coord: {
-      aResultValue.SetCoordValue(NSToCoordRound(
+      aResultValue.SetCoordValue(RestrictValue(aProperty, NSToCoordRound(
         aCoeff1 * aValue1.GetCoordValue() +
-        aCoeff2 * aValue2.GetCoordValue()));
+        aCoeff2 * aValue2.GetCoordValue())));
       return PR_TRUE;
     }
     case eUnit_Percent: {
-      aResultValue.SetPercentValue(
+      aResultValue.SetPercentValue(RestrictValue(aProperty,
         aCoeff1 * aValue1.GetPercentValue() +
-        aCoeff2 * aValue2.GetPercentValue());
+        aCoeff2 * aValue2.GetPercentValue()));
       return PR_TRUE;
     }
     case eUnit_Float: {
-      aResultValue.SetFloatValue(
+      aResultValue.SetFloatValue(RestrictValue(aProperty,
         aCoeff1 * aValue1.GetFloatValue() +
-        aCoeff2 * aValue2.GetFloatValue());
+        aCoeff2 * aValue2.GetFloatValue()));
       return PR_TRUE;
     }
     case eUnit_Color: {
       nscolor color1 = aValue1.GetColorValue();
       nscolor color2 = aValue2.GetColorValue();
       // FIXME (spec): The CSS transitions spec doesn't say whether
       // colors are premultiplied, but things work better when they are,
       // so use premultiplication.  Spec issue is still open per
@@ -1477,25 +1514,28 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
       nsAutoPtr<nsCSSValuePair> result(new nsCSSValuePair);
       static nsCSSValue nsCSSValuePair::* const pairValues[2] = {
         &nsCSSValuePair::mXValue, &nsCSSValuePair::mYValue
       };
       for (PRUint32 i = 0; i < 2; ++i) {
         nsCSSValue nsCSSValuePair::*member = pairValues[i];
         switch (unit[i]) {
           case eCSSUnit_Pixel:
+            // FIXME: value restrictions?
             AddCSSValuePixel(aCoeff1, pair1->*member, aCoeff2, pair2->*member,
                              result->*member);
             break;
           case eCSSUnit_Percent:
+            // FIXME: value restrictions?
             AddCSSValuePercent(aCoeff1, pair1->*member,
                                aCoeff2, pair2->*member,
                                result->*member);
             break;
           case eCSSUnit_Calc:
+            // FIXME: value restrictions?
             AddCSSValueCanonicalCalc(aCoeff1, pair1->*member,
                                      aCoeff2, pair2->*member,
                                      result->*member);
             break;
           default:
             NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
             return PR_FALSE;
         }
@@ -1519,16 +1559,17 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
       nsAutoPtr<nsCSSRect> result(new nsCSSRect);
       for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(nsCSSRect::sides); ++i) {
         nsCSSValue nsCSSRect::*member = nsCSSRect::sides[i];
         NS_ABORT_IF_FALSE((rect1->*member).GetUnit() ==
                             (rect2->*member).GetUnit(),
                           "should have returned above");
         switch ((rect1->*member).GetUnit()) {
           case eCSSUnit_Pixel:
+            // FIXME: value restrictions?
             AddCSSValuePixel(aCoeff1, rect1->*member, aCoeff2, rect2->*member,
                              result->*member);
             break;
           case eCSSUnit_Auto:
             if (float(aCoeff1 + aCoeff2) != 1.0f) {
               // Interpolating between two auto values makes sense;
               // adding in other ratios does not.
               return PR_FALSE;
@@ -1539,16 +1580,17 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
             NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
             return PR_FALSE;
         }
       }
 
       aResultValue.SetAndAdoptCSSRectValue(result.forget(), eUnit_CSSRect);
       return PR_TRUE;
     }
+    // TODO: Up to here...
     case eUnit_Dasharray: {
       const nsCSSValueList *list1 = aValue1.GetCSSValueListValue();
       const nsCSSValueList *list2 = aValue2.GetCSSValueListValue();
 
       PRUint32 len1 = 0, len2 = 0;
       for (const nsCSSValueList *v = list1; v; v = v->mNext) {
         ++len1;
       }
