From: L. David Baron <dbaron@dbaron.org>

Add mechanism for computation of calc() in the cases where the arguments are only lengths (i.e., where computed style can contain a simple result rather than a calc tree).  (Bug 363249)

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -74,16 +74,17 @@
 #include "nsUnicharUtils.h"
 #include "nsStyleStructInlines.h"
 #include "nsStyleTransformMatrix.h"
 #include "nsCSSKeywords.h"
 #include "nsCSSProps.h"
 #include "nsTArray.h"
 #include "nsContentUtils.h"
 #include "Element.h"
+#include "CSSCalc.h"
 
 using namespace mozilla::dom;
 
 #define NS_SET_IMAGE_REQUEST(method_, context_, request_)                   \
   if ((context_)->PresContext()->IsDynamic()) {                               \
     method_(request_);                                                      \
   } else {                                                                  \
     nsCOMPtr<imgIRequest> req = nsContentUtils::GetStaticRequest(request_); \
@@ -164,16 +165,64 @@ static void EnsureBlockDisplay(PRUint8& 
     break;
 
   default :
     // make it a block
     display = NS_STYLE_DISPLAY_BLOCK;
   }
 }
 
+static nscoord CalcLengthWith(const nsCSSValue& aValue,
+                              nscoord aFontSize,
+                              const nsStyleFont* aStyleFont,
+                              nsStyleContext* aStyleContext,
+                              nsPresContext* aPresContext,
+                              PRBool aUseProvidedRootEmSize,
+                              PRBool aUseUserFontSet,
+                              PRBool& aCanStoreInRuleTree);
+
+struct CalcLengthCalcOps : public mozilla::css::BasicCoordCalcOps,
+                           public mozilla::css::NumbersAlreadyNormalizedOps
+{
+  struct ComputeData {
+    // All of the parameters to CalcLengthWith except aValue.
+    nscoord mFontSize;
+    const nsStyleFont* mStyleFont;
+    nsStyleContext* mStyleContext;
+    nsPresContext* mPresContext;
+    PRBool mUseProvidedRootEmSize;
+    PRBool mUseUserFontSet;
+    PRBool& mCanStoreInRuleTree;
+
+    ComputeData(nscoord aFontSize, const nsStyleFont* aStyleFont,
+                nsStyleContext* aStyleContext, nsPresContext* aPresContext,
+                PRBool aUseProvidedRootEmSize, PRBool aUseUserFontSet,
+                PRBool& aCanStoreInRuleTree)
+      : mFontSize(aFontSize),
+        mStyleFont(aStyleFont),
+        mStyleContext(aStyleContext),
+        mPresContext(aPresContext),
+        mUseProvidedRootEmSize(aUseProvidedRootEmSize),
+        mUseUserFontSet(aUseUserFontSet),
+        mCanStoreInRuleTree(aCanStoreInRuleTree)
+    {
+    }
+  };
+
+  static result_type ComputeLeafValue(const nsCSSValue& aValue,
+                                      const ComputeData& aClosure)
+  {
+    return CalcLengthWith(aValue, aClosure.mFontSize, aClosure.mStyleFont,
+                          aClosure.mStyleContext, aClosure.mPresContext,
+                          aClosure.mUseProvidedRootEmSize,
+                          aClosure.mUseUserFontSet,
+                          aClosure.mCanStoreInRuleTree);
+  }
+};
+
 static inline nscoord ScaleCoord(const nsCSSValue &aValue, float factor)
 {
   return NSToCoordRoundWithClamp(aValue.GetFloatValue() * factor);
 }
 
 static nscoord CalcLengthWith(const nsCSSValue& aValue,
                               nscoord aFontSize,
                               const nsStyleFont* aStyleFont,
@@ -181,37 +230,37 @@ static nscoord CalcLengthWith(const nsCS
                               nsPresContext* aPresContext,
                               PRBool aUseProvidedRootEmSize,
                               // aUseUserFontSet should always be PR_TRUE
                               // except when called from
                               // CalcLengthWithInitialFont.
                               PRBool aUseUserFontSet,
                               PRBool& aCanStoreInRuleTree)
 {
-  NS_ASSERTION(aValue.IsLengthUnit(), "not a length unit");
+  NS_ASSERTION(aValue.IsLengthUnit() || aValue.IsCalcUnit(),
+               "not a length or calc unit");
   NS_ASSERTION(aStyleFont || aStyleContext, "Must have style data");
   NS_ASSERTION(!aStyleFont || !aStyleContext, "Duplicate sources of data");
   NS_ASSERTION(aPresContext, "Must have prescontext");
 
   if (aValue.IsFixedLengthUnit()) {
     return aPresContext->TwipsToAppUnits(aValue.GetLengthTwips());
   }
   nsCSSUnit unit = aValue.GetUnit();
   if (unit == eCSSUnit_Pixel) {
     return nsPresContext::CSSPixelsToAppUnits(aValue.GetFloatValue());
   }
   // Common code for all units other than pixels:
   aCanStoreInRuleTree = PR_FALSE;
-  if (!aStyleFont) {
-    aStyleFont = aStyleContext->GetStyleFont();
-  }
+  const nsStyleFont *styleFont =
+    aStyleFont ? aStyleFont : aStyleContext->GetStyleFont();
   if (aFontSize == -1) {
-    // XXX Should this be aStyleFont->mSize instead to avoid taking minfontsize
+    // XXX Should this be styleFont->mSize instead to avoid taking minfontsize
     // prefs into account?
-    aFontSize = aStyleFont->mFont.size;
+    aFontSize = styleFont->mFont.size;
   }
   switch (unit) {
     case eCSSUnit_RootEM: {
       nscoord rootFontSize;
 
       if (aUseProvidedRootEmSize) {
         // We should use the provided aFontSize as the reference length to
         // scale. This only happens when we are calculating font-size or
@@ -219,22 +268,22 @@ static nscoord CalcLengthWith(const nsCS
         // the root element, in which case aFontSize is already the
         // value we want.
         rootFontSize = aFontSize;
       } else if (aStyleContext && !aStyleContext->GetParent()) {
         // This is the root element (XXX we don't really know this, but
         // nsRuleNode::SetFont makes the same assumption!), so we should
         // use GetStyleFont on this context to get the root element's
         // font size.
-        rootFontSize = aStyleFont->mFont.size;
+        rootFontSize = styleFont->mFont.size;
       } else {
         // This is not the root element or we are calculating something other
         // than font size, so rem is relative to the root element's font size.
         nsRefPtr<nsStyleContext> rootStyle;
-        const nsStyleFont *rootStyleFont = aStyleFont;
+        const nsStyleFont *rootStyleFont = styleFont;
         Element* docElement = aPresContext->Document()->GetRootElement();
 
         rootStyle = aPresContext->StyleSet()->ResolveStyleFor(docElement,
                                                               nsnull);
         if (rootStyle) {
           rootStyleFont = rootStyle->GetStyleFont();
           rootFontSize = rootStyleFont->mFont.size;
         }
@@ -242,36 +291,55 @@ static nscoord CalcLengthWith(const nsCS
 
       return ScaleCoord(aValue, float(rootFontSize));
     }
     case eCSSUnit_EM: {
       return ScaleCoord(aValue, float(aFontSize));
       // XXX scale against font metrics height instead?
     }
     case eCSSUnit_XHeight: {
-      nsFont font = aStyleFont->mFont;
+      nsFont font = styleFont->mFont;
       font.size = aFontSize;
       nsCOMPtr<nsIFontMetrics> fm =
         aPresContext->GetMetricsFor(font, aUseUserFontSet);
       nscoord xHeight;
       fm->GetXHeight(xHeight);
       return ScaleCoord(aValue, float(xHeight));
     }
     case eCSSUnit_Char: {
-      nsFont font = aStyleFont->mFont;
+      nsFont font = styleFont->mFont;
       font.size = aFontSize;
       nsCOMPtr<nsIFontMetrics> fm =
         aPresContext->GetMetricsFor(font, aUseUserFontSet);
       nsCOMPtr<nsIThebesFontMetrics> tfm(do_QueryInterface(fm));
       gfxFloat zeroWidth = (tfm->GetThebesFontGroup()->GetFontAt(0)
                             ->GetMetrics().zeroOrAveCharWidth);
 
       return ScaleCoord(aValue, NS_ceil(aPresContext->AppUnitsPerDevPixel() *
                                         zeroWidth));
     }
+    // For properties for which lengths are the *only* units accepted in
+    // calc(), we can handle calc() here and just compute a final
+    // result.  We ensure that we don't get to this code for other
+    // properties by not calling CalcLength in those cases:  SetCoord
+    // only calls CalcLength for a calc when it is appropriate to do so.
+    case eCSSUnit_Calc:
+    case eCSSUnit_Calc_Plus:
+    case eCSSUnit_Calc_Minus:
+    case eCSSUnit_Calc_Times_L:
+    case eCSSUnit_Calc_Times_R:
+    case eCSSUnit_Calc_Divided:
+    case eCSSUnit_Calc_Modulus:
+    case eCSSUnit_Calc_Minimum:
+    case eCSSUnit_Calc_Maximum: {
+      CalcLengthCalcOps::ComputeData
+        data(aFontSize, aStyleFont, aStyleContext, aPresContext,
+             aUseProvidedRootEmSize, aUseUserFontSet, aCanStoreInRuleTree);
+      return mozilla::css::ComputeCalc<CalcLengthCalcOps>(aValue, data);
+    }
     default:
       NS_NOTREACHED("unexpected unit");
       break;
   }
   return 0;
 }
 
 /* static */ nscoord
@@ -315,16 +383,17 @@ nsRuleNode::CalcLengthWithInitialFont(ns
 #define SETCOORD_INTEGER                0x40   // I
 #define SETCOORD_ENUMERATED             0x80   // E
 #define SETCOORD_NONE                   0x100  // O
 #define SETCOORD_INITIAL_ZERO           0x200
 #define SETCOORD_INITIAL_AUTO           0x400
 #define SETCOORD_INITIAL_NONE           0x800
 #define SETCOORD_INITIAL_NORMAL         0x1000
 #define SETCOORD_INITIAL_HALF           0x2000
+#define SETCOORD_CALC_LENGTH_ONLY       0x4000
 
 #define SETCOORD_LP     (SETCOORD_LENGTH | SETCOORD_PERCENT)
 #define SETCOORD_LH     (SETCOORD_LENGTH | SETCOORD_INHERIT)
 #define SETCOORD_AH     (SETCOORD_AUTO | SETCOORD_INHERIT)
 #define SETCOORD_LAH    (SETCOORD_AUTO | SETCOORD_LENGTH | SETCOORD_INHERIT)
 #define SETCOORD_LPH    (SETCOORD_LP | SETCOORD_INHERIT)
 #define SETCOORD_LPAH   (SETCOORD_LP | SETCOORD_AH)
 #define SETCOORD_LPEH   (SETCOORD_LP | SETCOORD_ENUMERATED | SETCOORD_INHERIT)
@@ -343,18 +412,20 @@ static PRBool SetCoord(const nsCSSValue&
                        PRInt32 aMask, nsStyleContext* aStyleContext,
                        nsPresContext* aPresContext,
                        PRBool& aCanStoreInRuleTree)
 {
   PRBool  result = PR_TRUE;
   if (aValue.GetUnit() == eCSSUnit_Null) {
     result = PR_FALSE;
   }
-  else if (((aMask & SETCOORD_LENGTH) != 0) &&
-           aValue.IsLengthUnit()) {
+  else if ((((aMask & SETCOORD_LENGTH) != 0) &&
+            aValue.IsLengthUnit()) ||
+           (((aMask & SETCOORD_CALC_LENGTH_ONLY) != 0) &&
+            aValue.IsCalcUnit())) {
     aCoord.SetCoordValue(CalcLength(aValue, aStyleContext, aPresContext,
                                     aCanStoreInRuleTree));
   }
   else if (((aMask & SETCOORD_PERCENT) != 0) &&
            (aValue.GetUnit() == eCSSUnit_Percent)) {
     aCoord.SetPercentValue(aValue.GetPercentValue());
   }
   else if (((aMask & SETCOORD_INTEGER) != 0) &&
