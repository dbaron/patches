From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::GetPrefSize to GetXULPrefSize.

Written purely with sed, over .h and .cpp files in layout/.

MozReview-Commit-ID: yvcAZ8rndu

diff --git a/layout/forms/nsTextControlFrame.cpp b/layout/forms/nsTextControlFrame.cpp
--- a/layout/forms/nsTextControlFrame.cpp
+++ b/layout/forms/nsTextControlFrame.cpp
@@ -472,17 +472,17 @@ nsTextControlFrame::ComputeAutoSize(nsRe
     const nsStyleCoord& inlineStyleCoord =
       aWM.IsVertical() ? StylePosition()->mHeight : StylePosition()->mWidth;
     if (inlineStyleCoord.GetUnit() == eStyleUnit_Auto) {
       LogicalSize ancestorAutoSize =
         nsContainerFrame::ComputeAutoSize(aRenderingContext, aWM,
                                           aCBSize, aAvailableISize,
                                           aMargin, aBorder,
                                           aPadding, aShrinkWrap);
-      // Disabled when there's inflation; see comment in GetPrefSize.
+      // Disabled when there's inflation; see comment in GetXULPrefSize.
       MOZ_ASSERT(inflation != 1.0f ||
                  ancestorAutoSize.ISize(aWM) == autoSize.ISize(aWM),
                  "Incorrect size computed by ComputeAutoSize?");
     }
   }
 #endif
 
   return autoSize;
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -8688,17 +8688,17 @@ nsFrame::RefreshSizeCache(nsBoxLayoutSta
 
 /* virtual */ nsILineIterator*
 nsFrame::GetLineIterator()
 {
   return nullptr;
 }
 
 nsSize
-nsFrame::GetPrefSize(nsBoxLayoutState& aState)
+nsFrame::GetXULPrefSize(nsBoxLayoutState& aState)
 {
   nsSize size(0,0);
   DISPLAY_PREF_SIZE(this, size);
   // If the size is cached, and there are no HTML constraints that we might
   // be depending on, then we just return the cached size.
   nsBoxLayoutMetrics *metrics = BoxMetrics();
   if (!DoesNeedRecalc(metrics->mPrefSize)) {
     return metrics->mPrefSize;
diff --git a/layout/generic/nsFrame.h b/layout/generic/nsFrame.h
--- a/layout/generic/nsFrame.h
+++ b/layout/generic/nsFrame.h
@@ -403,17 +403,17 @@ public:
                                nsSelectionAmount aEndAmountType,
                                uint32_t aSelectFlags);
 
   // Helper for GetContentAndOffsetsFromPoint; calculation of content offsets
   // in this function assumes there is no child frame that can be targeted.
   virtual ContentOffsets CalcContentOffsetsFromFramePoint(nsPoint aPoint);
 
   // Box layout methods
-  virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetFlex() override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
 
   // We compute and store the HTML content's overflow area. So don't
   // try to compute it in the box code.
   virtual bool ComputesOwnOverflowArea() override { return true; }
diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -274,17 +274,17 @@ GetScrollbarMetrics(nsBoxLayoutState& aS
       aMin->width = 0;
     }
     if (aMin->height < 0) {
       aMin->height = 0;
     }
   }
 
   if (aPref) {
-    *aPref = aBox->GetPrefSize(aState);
+    *aPref = aBox->GetXULPrefSize(aState);
     nsBox::AddMargin(aBox, *aPref);
     if (aPref->width < 0) {
       aPref->width = 0;
     }
     if (aPref->height < 0) {
       aPref->height = 0;
     }
   }
@@ -1033,26 +1033,26 @@ ScrollFrameHelper::GetDesiredScrollbarSi
 {
   NS_ASSERTION(aState && aState->GetRenderingContext(),
                "Must have rendering context in layout state for size "
                "computations");
 
   nsMargin result(0, 0, 0, 0);
 
   if (mVScrollbarBox) {
-    nsSize size = mVScrollbarBox->GetPrefSize(*aState);
+    nsSize size = mVScrollbarBox->GetXULPrefSize(*aState);
     nsBox::AddMargin(mVScrollbarBox, size);
     if (IsScrollbarOnRight())
       result.left = size.width;
     else
       result.right = size.width;
   }
 
   if (mHScrollbarBox) {
-    nsSize size = mHScrollbarBox->GetPrefSize(*aState);
+    nsSize size = mHScrollbarBox->GetXULPrefSize(*aState);
     nsBox::AddMargin(mHScrollbarBox, size);
     // We don't currently support any scripts that would require a scrollbar
     // at the top. (Are there any?)
     result.bottom = size.height;
   }
 
   return result;
 }
@@ -1391,38 +1391,38 @@ nsXULScrollFrame::GetBoxAscent(nsBoxLayo
   ascent += m.top;
   GetMargin(m);
   ascent += m.top;
 
   return ascent;
 }
 
 nsSize
-nsXULScrollFrame::GetPrefSize(nsBoxLayoutState& aState)
+nsXULScrollFrame::GetXULPrefSize(nsBoxLayoutState& aState)
 {
 #ifdef DEBUG_LAYOUT
   PropagateDebug(aState);
 #endif
 
-  nsSize pref = mHelper.mScrolledFrame->GetPrefSize(aState);
+  nsSize pref = mHelper.mScrolledFrame->GetXULPrefSize(aState);
 
   ScrollbarStyles styles = GetScrollbarStyles();
 
   // scrolled frames don't have their own margins
 
   if (mHelper.mVScrollbarBox &&
       styles.mVertical == NS_STYLE_OVERFLOW_SCROLL) {
-    nsSize vSize = mHelper.mVScrollbarBox->GetPrefSize(aState);
+    nsSize vSize = mHelper.mVScrollbarBox->GetXULPrefSize(aState);
     nsBox::AddMargin(mHelper.mVScrollbarBox, vSize);
     pref.width += vSize.width;
   }
 
   if (mHelper.mHScrollbarBox &&
       styles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL) {
-    nsSize hSize = mHelper.mHScrollbarBox->GetPrefSize(aState);
+    nsSize hSize = mHelper.mHScrollbarBox->GetXULPrefSize(aState);
     nsBox::AddMargin(mHelper.mHScrollbarBox, hSize);
     pref.height += hSize.height;
   }
 
   AddBorderAndPadding(pref);
   bool widthSet, heightSet;
   nsIFrame::AddCSSPrefSize(this, pref, widthSet, heightSet);
   return pref;
@@ -4575,17 +4575,17 @@ nsXULScrollFrame::RemoveVerticalScrollba
 bool
 nsXULScrollFrame::AddRemoveScrollbar(nsBoxLayoutState& aState,
                                      bool aOnRightOrBottom, bool aHorizontal, bool aAdd)
 {
   if (aHorizontal) {
      if (mHelper.mNeverHasHorizontalScrollbar || !mHelper.mHScrollbarBox)
        return false;
 
-     nsSize hSize = mHelper.mHScrollbarBox->GetPrefSize(aState);
+     nsSize hSize = mHelper.mHScrollbarBox->GetXULPrefSize(aState);
      nsBox::AddMargin(mHelper.mHScrollbarBox, hSize);
 
      mHelper.SetScrollbarVisibility(mHelper.mHScrollbarBox, aAdd);
 
      bool hasHorizontalScrollbar;
      bool fit = AddRemoveScrollbar(hasHorizontalScrollbar,
                                      mHelper.mScrollPort.y,
                                      mHelper.mScrollPort.height,
@@ -4594,17 +4594,17 @@ nsXULScrollFrame::AddRemoveScrollbar(nsB
      if (!fit)
         mHelper.SetScrollbarVisibility(mHelper.mHScrollbarBox, !aAdd);
 
      return fit;
   } else {
      if (mHelper.mNeverHasVerticalScrollbar || !mHelper.mVScrollbarBox)
        return false;
 
-     nsSize vSize = mHelper.mVScrollbarBox->GetPrefSize(aState);
+     nsSize vSize = mHelper.mVScrollbarBox->GetXULPrefSize(aState);
      nsBox::AddMargin(mHelper.mVScrollbarBox, vSize);
 
      mHelper.SetScrollbarVisibility(mHelper.mVScrollbarBox, aAdd);
 
      bool hasVerticalScrollbar;
      bool fit = AddRemoveScrollbar(hasVerticalScrollbar,
                                      mHelper.mScrollPort.x,
                                      mHelper.mScrollPort.width,
@@ -5322,24 +5322,24 @@ ScrollFrameHelper::LayoutScrollbars(nsBo
     }
 
     if (hasResizer) {
       // if a resizer is present, get its size. Assume a default size of 15 pixels.
       nscoord defaultSize = nsPresContext::CSSPixelsToAppUnits(15);
       nsSize resizerMinSize = mResizerBox->GetXULMinSize(aState);
 
       nscoord vScrollbarWidth = mVScrollbarBox ?
-        mVScrollbarBox->GetPrefSize(aState).width : defaultSize;
+        mVScrollbarBox->GetXULPrefSize(aState).width : defaultSize;
       r.width = std::max(std::max(r.width, vScrollbarWidth), resizerMinSize.width);
       if (aContentArea.x == mScrollPort.x && !scrollbarOnLeft) {
         r.x = aContentArea.XMost() - r.width;
       }
 
       nscoord hScrollbarHeight = mHScrollbarBox ?
-        mHScrollbarBox->GetPrefSize(aState).height : defaultSize;
+        mHScrollbarBox->GetXULPrefSize(aState).height : defaultSize;
       r.height = std::max(std::max(r.height, hScrollbarHeight), resizerMinSize.height);
       if (aContentArea.y == mScrollPort.y) {
         r.y = aContentArea.YMost() - r.height;
       }
 
       nsBoxFrame::LayoutChildAt(aState, mResizerBox, r);
     }
     else if (mResizerBox) {
diff --git a/layout/generic/nsGfxScrollFrame.h b/layout/generic/nsGfxScrollFrame.h
--- a/layout/generic/nsGfxScrollFrame.h
+++ b/layout/generic/nsGfxScrollFrame.h
@@ -1120,17 +1120,17 @@ public:
   }
 
   // nsIAnonymousContentCreator
   virtual nsresult CreateAnonymousContent(nsTArray<ContentInfo>& aElements) override;
   virtual void AppendAnonymousContentTo(nsTArray<nsIContent*>& aElements,
                                         uint32_t aFilter) override;
 
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
 
   NS_IMETHOD DoLayout(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsresult GetPadding(nsMargin& aPadding) override;
 
   virtual bool GetBorderRadii(const nsSize& aFrameSize, const nsSize& aBorderArea,
                               Sides aSkipSides, nscoord aRadii[8]) const override {
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2875,17 +2875,17 @@ public:
    */
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) = 0;
 
   /**
    * This calculates the preferred size of a box based on its state
    * @param[in] aBoxLayoutState The desired state to calculate for
    * @return The preferred size
    */
-  virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) = 0;
+  virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) = 0;
 
   /**
    * This calculates the maximum size for a box based on its state
    * @param[in] aBoxLayoutState The desired state to calculate for
    * @return The maximum size
    */    
   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState) = 0;
 
diff --git a/layout/generic/nsPlaceholderFrame.cpp b/layout/generic/nsPlaceholderFrame.cpp
--- a/layout/generic/nsPlaceholderFrame.cpp
+++ b/layout/generic/nsPlaceholderFrame.cpp
@@ -41,17 +41,17 @@ NS_QUERYFRAME_TAIL_INHERITING(nsFrame)
 nsPlaceholderFrame::GetXULMinSize(nsBoxLayoutState& aBoxLayoutState)
 {
   nsSize size(0, 0);
   DISPLAY_MIN_SIZE(this, size);
   return size;
 }
 
 /* virtual */ nsSize
-nsPlaceholderFrame::GetPrefSize(nsBoxLayoutState& aBoxLayoutState)
+nsPlaceholderFrame::GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState)
 {
   nsSize size(0, 0);
   DISPLAY_PREF_SIZE(this, size);
   return size;
 }
 
 /* virtual */ nsSize
 nsPlaceholderFrame::GetMaxSize(nsBoxLayoutState& aBoxLayoutState)
diff --git a/layout/generic/nsPlaceholderFrame.h b/layout/generic/nsPlaceholderFrame.h
--- a/layout/generic/nsPlaceholderFrame.h
+++ b/layout/generic/nsPlaceholderFrame.h
@@ -83,24 +83,24 @@ public:
   nsIFrame*  GetOutOfFlowFrame() const { return mOutOfFlowFrame; }
   void       SetOutOfFlowFrame(nsIFrame* aFrame) {
                NS_ASSERTION(!aFrame || !aFrame->GetPrevContinuation(),
                             "OOF must be first continuation");
                mOutOfFlowFrame = aFrame;
              }
 
   // nsIFrame overrides
-  // We need to override GetXULMinSize and GetPrefSize because XUL uses
+  // We need to override GetXULMinSize and GetXULPrefSize because XUL uses
   // placeholders not within lines.
   virtual void AddInlineMinISize(nsRenderingContext* aRenderingContext,
                                  InlineMinISizeData* aData) override;
   virtual void AddInlinePrefISize(nsRenderingContext* aRenderingContext,
                                   InlinePrefISizeData* aData) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual void Reflow(nsPresContext* aPresContext,
                       nsHTMLReflowMetrics& aDesiredSize,
                       const nsHTMLReflowState& aReflowState,
                       nsReflowStatus& aStatus) override;
 
   virtual void DestroyFrom(nsIFrame* aDestructRoot) override;
diff --git a/layout/generic/nsVideoFrame.cpp b/layout/generic/nsVideoFrame.cpp
--- a/layout/generic/nsVideoFrame.cpp
+++ b/layout/generic/nsVideoFrame.cpp
@@ -562,17 +562,17 @@ nsVideoFrame::GetVideoIntrinsicSize(nsRe
 
   if (!HasVideoElement()) {
     if (!mFrames.FirstChild()) {
       return nsSize(0, 0);
     }
 
     // Ask the controls frame what its preferred height is
     nsBoxLayoutState boxState(PresContext(), aRenderingContext, 0);
-    nscoord prefHeight = mFrames.LastChild()->GetPrefSize(boxState).height;
+    nscoord prefHeight = mFrames.LastChild()->GetXULPrefSize(boxState).height;
     return nsSize(nsPresContext::CSSPixelsToAppUnits(size.width), prefHeight);
   }
 
   HTMLVideoElement* element = static_cast<HTMLVideoElement*>(GetContent());
   if (NS_FAILED(element->GetVideoSize(&size)) && ShouldDisplayPoster()) {
     // Use the poster image frame's size.
     nsIFrame *child = mPosterImage->GetPrimaryFrame();
     nsImageFrame* imageFrame = do_QueryFrame(child);
diff --git a/layout/xul/grid/nsGrid.cpp b/layout/xul/grid/nsGrid.cpp
--- a/layout/xul/grid/nsGrid.cpp
+++ b/layout/xul/grid/nsGrid.cpp
@@ -821,17 +821,17 @@ nsGrid::GetPrefRowHeight(nsBoxLayoutStat
 
   // is the row bogus? If so then just ask it for its size
   // it should not be affected by cells in the grid. 
   if (row->mIsBogus)
   {
      nsSize size(0,0);
      if (box) 
      {
-       size = box->GetPrefSize(aState);
+       size = box->GetXULPrefSize(aState);
        nsBox::AddMargin(box, size);
        nsGridLayout2::AddOffset(box, size);
      }
 
      row->mPref = GET_HEIGHT(size, aIsHorizontal);
      return row->mPref;
   }
 
@@ -846,17 +846,17 @@ nsGrid::GetPrefRowHeight(nsBoxLayoutStat
     if (aIsHorizontal)
      child = GetCellAt(i,aIndex);
     else
      child = GetCellAt(aIndex,i);
 
     // ignore collapsed children
     if (!child->IsCollapsed())
     {
-      nsSize childSize = child->GetPrefSize(aState);
+      nsSize childSize = child->GetXULPrefSize(aState);
 
       nsSprocketLayout::AddLargestSize(size, childSize, aIsHorizontal);
     }
   }
 
   row->mPref = GET_HEIGHT(size, aIsHorizontal) + top + bottom;
 
   return row->mPref;
@@ -896,17 +896,17 @@ nsGrid::GetMinRowHeight(nsBoxLayoutState
   GetRowOffsets(aIndex, top, bottom, aIsHorizontal);
 
   // is the row bogus? If so then just ask it for its size
   // it should not be affected by cells in the grid. 
   if (row->mIsBogus)
   {
      nsSize size(0,0);
      if (box) {
-       size = box->GetPrefSize(aState);
+       size = box->GetXULPrefSize(aState);
        nsBox::AddMargin(box, size);
        nsGridLayout2::AddOffset(box, size);
      }
 
      row->mMin = GET_HEIGHT(size, aIsHorizontal) + top + bottom;
      return row->mMin;
   }
 
@@ -971,17 +971,17 @@ nsGrid::GetMaxRowHeight(nsBoxLayoutState
   GetRowOffsets(aIndex, top, bottom, aIsHorizontal);
 
   // is the row bogus? If so then just ask it for its size
   // it should not be affected by cells in the grid. 
   if (row->mIsBogus)
   {
      nsSize size(NS_INTRINSICSIZE,NS_INTRINSICSIZE);
      if (box) {
-       size = box->GetPrefSize(aState);
+       size = box->GetXULPrefSize(aState);
        nsBox::AddMargin(box, size);
        nsGridLayout2::AddOffset(box, size);
      }
 
      row->mMax = GET_HEIGHT(size, aIsHorizontal);
      return row->mMax;
   }
 
diff --git a/layout/xul/grid/nsGridCell.cpp b/layout/xul/grid/nsGridCell.cpp
--- a/layout/xul/grid/nsGridCell.cpp
+++ b/layout/xul/grid/nsGridCell.cpp
@@ -22,35 +22,35 @@ nsGridCell::nsGridCell():mBoxInColumn(nu
 }                                               
         
 nsGridCell::~nsGridCell()
 {
     MOZ_COUNT_DTOR(nsGridCell);
 }
 
 nsSize
-nsGridCell::GetPrefSize(nsBoxLayoutState& aState)
+nsGridCell::GetXULPrefSize(nsBoxLayoutState& aState)
 {
   nsSize sum(0,0);
 
   // take our 2 children and add them up.
   // we are as wide as the widest child plus its left offset
   // we are tall as the tallest child plus its top offset
 
   if (mBoxInColumn) {
-    nsSize pref = mBoxInColumn->GetPrefSize(aState);
+    nsSize pref = mBoxInColumn->GetXULPrefSize(aState);
 
     nsBox::AddMargin(mBoxInColumn, pref);
     nsGridLayout2::AddOffset(mBoxInColumn, pref);
 
     nsBoxLayout::AddLargestSize(sum, pref);
   }
 
   if (mBoxInRow) {
-    nsSize pref = mBoxInRow->GetPrefSize(aState);
+    nsSize pref = mBoxInRow->GetXULPrefSize(aState);
 
     nsBox::AddMargin(mBoxInRow, pref);
     nsGridLayout2::AddOffset(mBoxInRow, pref);
 
     nsBoxLayout::AddLargestSize(sum, pref);
   }
 
   return sum;
diff --git a/layout/xul/grid/nsGridCell.h b/layout/xul/grid/nsGridCell.h
--- a/layout/xul/grid/nsGridCell.h
+++ b/layout/xul/grid/nsGridCell.h
@@ -28,17 +28,17 @@ class nsIFrame;
  */
 
 class nsGridCell final
 {
 public:
     nsGridCell();
     ~nsGridCell();
 
-    nsSize      GetPrefSize(nsBoxLayoutState& aBoxLayoutState);
+    nsSize      GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState);
     nsSize      GetXULMinSize(nsBoxLayoutState& aBoxLayoutState);
     nsSize      GetMaxSize(nsBoxLayoutState& aBoxLayoutState);
     bool        IsCollapsed();
 
 // accessors
     nsIFrame*   GetBoxInColumn()               { return mBoxInColumn; }
     nsIFrame*   GetBoxInRow()                  { return mBoxInRow; }
     void        SetBoxInRow(nsIFrame* aBox)    { mBoxInRow = aBox; }
diff --git a/layout/xul/grid/nsGridLayout2.cpp b/layout/xul/grid/nsGridLayout2.cpp
--- a/layout/xul/grid/nsGridLayout2.cpp
+++ b/layout/xul/grid/nsGridLayout2.cpp
@@ -127,19 +127,19 @@ nsGridLayout2::GetXULMinSize(nsIFrame* a
     AddOffset(aBox, total);
     AddLargestSize(minSize, total);
   }
   
   return minSize;
 }
 
 nsSize
-nsGridLayout2::GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aState)
+nsGridLayout2::GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
-  nsSize pref = nsStackLayout::GetPrefSize(aBox, aState); 
+  nsSize pref = nsStackLayout::GetXULPrefSize(aBox, aState); 
 
   // if there are no <rows> tags that will sum up our columns,
   // sum up our columns here.
   nsSize total(0,0);
   nsIFrame* rowsBox = mGrid.GetRowsBox();
   nsIFrame* columnsBox = mGrid.GetColumnsBox();
   if (!rowsBox || !columnsBox) {
     if (!rowsBox) {
diff --git a/layout/xul/grid/nsGridLayout2.h b/layout/xul/grid/nsGridLayout2.h
--- a/layout/xul/grid/nsGridLayout2.h
+++ b/layout/xul/grid/nsGridLayout2.h
@@ -36,17 +36,17 @@ public:
   virtual nsGridRowGroupLayout* CastToRowGroupLayout() override { return nullptr; }
   virtual nsGridLayout2* CastToGridLayout() override { return this; }
   virtual nsGrid* GetGrid(nsIFrame* aBox, int32_t* aIndex, nsGridRowLayout* aRequestor=nullptr) override;
   virtual nsIGridPart* GetParentGridPart(nsIFrame* aBox, nsIFrame** aParentBox) override {
     NS_NOTREACHED("Should not be called"); return nullptr;
   }
   virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual void CountRowsColumns(nsIFrame* aBox, int32_t& aRowCount, int32_t& aComputedColumnCount) override { aRowCount++; }
   virtual void DirtyRows(nsIFrame* aBox, nsBoxLayoutState& aState) override { }
   virtual int32_t BuildRows(nsIFrame* aBox, nsGridRow* aRows) override;
   virtual nsMargin GetTotalMargin(nsIFrame* aBox, bool aIsHorizontal) override;
   virtual Type GetType() override { return eGrid; }
   virtual void ChildrenInserted(nsIFrame* aBox, nsBoxLayoutState& aState,
                                 nsIFrame* aPrevBox,
                                 const nsFrameList::Slice& aNewChildren) override;
diff --git a/layout/xul/grid/nsGridRowGroupLayout.cpp b/layout/xul/grid/nsGridRowGroupLayout.cpp
--- a/layout/xul/grid/nsGridRowGroupLayout.cpp
+++ b/layout/xul/grid/nsGridRowGroupLayout.cpp
@@ -56,19 +56,19 @@ nsGridRowGroupLayout::AddWidth(nsSize& a
 
   if (size == NS_INTRINSICSIZE || aSize2 == NS_INTRINSICSIZE)
     size = NS_INTRINSICSIZE;
   else
     size += aSize2;
 }
 
 nsSize
-nsGridRowGroupLayout::GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aState)
+nsGridRowGroupLayout::GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 { 
-  nsSize vpref = nsGridRowLayout::GetPrefSize(aBox, aState); 
+  nsSize vpref = nsGridRowLayout::GetXULPrefSize(aBox, aState); 
 
 
  /* It is possible that we could have some extra columns. This is when less columns in XUL were 
   * defined that needed. And example might be a grid with 3 defined columns but a row with 4 cells in 
   * it. We would need an extra column to make the grid work. But because that extra column does not 
   * have a box associated with it we must add its size in manually. Remember we could have extra rows
   * as well.
   */
diff --git a/layout/xul/grid/nsGridRowGroupLayout.h b/layout/xul/grid/nsGridRowGroupLayout.h
--- a/layout/xul/grid/nsGridRowGroupLayout.h
+++ b/layout/xul/grid/nsGridRowGroupLayout.h
@@ -22,17 +22,17 @@
 class nsGridRowGroupLayout : public nsGridRowLayout
 {
 public:
 
   friend already_AddRefed<nsBoxLayout> NS_NewGridRowGroupLayout();
 
   virtual nsGridRowGroupLayout* CastToRowGroupLayout() override { return this; }
   virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual void CountRowsColumns(nsIFrame* aBox, int32_t& aRowCount, int32_t& aComputedColumnCount) override;
   virtual void DirtyRows(nsIFrame* aBox, nsBoxLayoutState& aState) override;
   virtual int32_t BuildRows(nsIFrame* aBox, nsGridRow* aRows) override;
   virtual nsMargin GetTotalMargin(nsIFrame* aBox, bool aIsHorizontal) override;
   virtual int32_t GetRowCount() override { return mRowCount; }
   virtual Type GetType() override { return eRowGroup; }
 
diff --git a/layout/xul/grid/nsGridRowLeafLayout.cpp b/layout/xul/grid/nsGridRowLeafLayout.cpp
--- a/layout/xul/grid/nsGridRowLeafLayout.cpp
+++ b/layout/xul/grid/nsGridRowLeafLayout.cpp
@@ -30,26 +30,26 @@ nsGridRowLeafLayout::nsGridRowLeafLayout
 {
 }
 
 nsGridRowLeafLayout::~nsGridRowLeafLayout()
 {
 }
 
 nsSize
-nsGridRowLeafLayout::GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aState)
+nsGridRowLeafLayout::GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   int32_t index = 0;
   nsGrid* grid = GetGrid(aBox, &index);
   bool isHorizontal = IsHorizontal(aBox);
 
   // If we are not in a grid. Then we just work like a box. But if we are in a grid
   // ask the grid for our size.
   if (!grid) {
-    return nsGridRowLayout::GetPrefSize(aBox, aState); 
+    return nsGridRowLayout::GetXULPrefSize(aBox, aState); 
   }
   else {
     return grid->GetPrefRowSize(aState, index, isHorizontal);
     //AddBorderAndPadding(aBox, pref);
   }
 }
 
 nsSize
diff --git a/layout/xul/grid/nsGridRowLeafLayout.h b/layout/xul/grid/nsGridRowLeafLayout.h
--- a/layout/xul/grid/nsGridRowLeafLayout.h
+++ b/layout/xul/grid/nsGridRowLeafLayout.h
@@ -23,17 +23,17 @@
 // XXXldb This needs a better name that indicates that it's for any grid
 // row.
 class nsGridRowLeafLayout final : public nsGridRowLayout
 {
 public:
 
   friend already_AddRefed<nsBoxLayout> NS_NewGridRowLeafLayout();
 
-  virtual nsSize GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual void ChildAddedOrRemoved(nsIFrame* aBox, nsBoxLayoutState& aState) override;
   NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual void CountRowsColumns(nsIFrame* aBox, int32_t& aRowCount, int32_t& aComputedColumnCount) override;
   virtual void DirtyRows(nsIFrame* aBox, nsBoxLayoutState& aState) override;
   virtual int32_t BuildRows(nsIFrame* aBox, nsGridRow* aRows) override;
   virtual Type GetType() override { return eRowLeaf; }
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -387,17 +387,17 @@ nsBox::DoesNeedRecalc(const nsSize& aSiz
 
 bool
 nsBox::DoesNeedRecalc(nscoord aCoord)
 {
   return (aCoord == -1);
 }
 
 nsSize
-nsBox::GetPrefSize(nsBoxLayoutState& aState)
+nsBox::GetXULPrefSize(nsBoxLayoutState& aState)
 {
   NS_ASSERTION(aState.GetRenderingContext(), "must have rendering context");
 
   nsSize pref(0,0);
   DISPLAY_PREF_SIZE(this, pref);
 
   if (IsCollapsed())
     return pref;
@@ -482,17 +482,17 @@ nsIFrame::GetOrdinal()
 }
 
 nscoord
 nsBox::GetBoxAscent(nsBoxLayoutState& aState)
 {
   if (IsCollapsed())
     return 0;
 
-  return GetPrefSize(aState).height;
+  return GetXULPrefSize(aState).height;
 }
 
 bool
 nsBox::IsCollapsed()
 {
   return StyleVisibility()->mVisible == NS_STYLE_VISIBILITY_COLLAPSE;
 }
 
@@ -601,17 +601,17 @@ nsIFrame::AddCSSPrefSize(nsIFrame* aBox,
     aHeightSet = false;
 
     // add in the css min, max, pref
     const nsStylePosition* position = aBox->StylePosition();
 
     // see if the width or height was specifically set
     // XXX Handle eStyleUnit_Enumerated?
     // (Handling the eStyleUnit_Enumerated types requires
-    // GetPrefSize/GetXULMinSize methods that don't consider
+    // GetXULPrefSize/GetXULMinSize methods that don't consider
     // (min-/max-/)(width/height) properties.)
     const nsStyleCoord &width = position->mWidth;
     if (width.GetUnit() == eStyleUnit_Coord) {
         aSize.width = width.GetCoordValue();
         aWidthSet = true;
     } else if (width.IsCalcUnit()) {
         if (!width.CalcHasPercent()) {
             // pass 0 for percentage basis since we know there are no %s
@@ -713,17 +713,17 @@ nsIFrame::AddCSSMinSize(nsBoxLayoutState
         NS_ASSERTION(minWidth.GetPercentValue() == 0.0f,
           "Non-zero percentage values not currently supported");
         aSize.width = 0;
         aWidthSet = true; // FIXME: should we really do this for
                              // nonzero values?
     }
     // XXX Handle eStyleUnit_Enumerated?
     // (Handling the eStyleUnit_Enumerated types requires
-    // GetPrefSize/GetXULMinSize methods that don't consider
+    // GetXULPrefSize/GetXULMinSize methods that don't consider
     // (min-/max-/)(width/height) properties.
     // calc() with percentage is treated like '0' (unset)
 
     const nsStyleCoord &minHeight = position->mMinHeight;
     if ((minHeight.GetUnit() == eStyleUnit_Coord &&
          minHeight.GetCoordValue() != 0) ||
         (minHeight.IsCalcUnit() && !minHeight.CalcHasPercent())) {
         nscoord min = nsRuleNode::ComputeCoordPercentCalc(minHeight, 0);
@@ -782,17 +782,17 @@ nsIFrame::AddCSSMaxSize(nsIFrame* aBox, 
 
     // add in the css min, max, pref
     const nsStylePosition* position = aBox->StylePosition();
 
     // and max
     // see if the width or height was specifically set
     // XXX Handle eStyleUnit_Enumerated?
     // (Handling the eStyleUnit_Enumerated types requires
-    // GetPrefSize/GetXULMinSize methods that don't consider
+    // GetXULPrefSize/GetXULMinSize methods that don't consider
     // (min-/max-/)(width/height) properties.)
     const nsStyleCoord maxWidth = position->mMaxWidth;
     if (maxWidth.ConvertsToLength()) {
         aSize.width = nsRuleNode::ComputeCoordPercentCalc(maxWidth, 0);
         aWidthSet = true;
     }
     // percentages and calc() with percentages are treated like 'none'
 
diff --git a/layout/xul/nsBox.h b/layout/xul/nsBox.h
--- a/layout/xul/nsBox.h
+++ b/layout/xul/nsBox.h
@@ -14,17 +14,17 @@ class nsITheme;
 class nsBox : public nsIFrame {
 
 public:
 
   friend class nsIFrame;
 
   static void Shutdown();
 
-  virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetFlex() override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual nsSize GetMinSizeForScrollArea(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual bool IsCollapsed() override;
diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -607,21 +607,21 @@ nsBoxFrame::GetMinISize(nsRenderingConte
 
 /* virtual */ nscoord
 nsBoxFrame::GetPrefISize(nsRenderingContext *aRenderingContext)
 {
   nscoord result;
   DISPLAY_PREF_WIDTH(this, result);
 
   nsBoxLayoutState state(PresContext(), aRenderingContext);
-  nsSize prefSize = GetPrefSize(state);
+  nsSize prefSize = GetXULPrefSize(state);
 
-  // GetPrefSize returns border-box width, and we want to return content
+  // GetXULPrefSize returns border-box width, and we want to return content
   // width.  Since Reflow uses the reflow state's border and padding, we
-  // actually just want to subtract what GetPrefSize added, which is the
+  // actually just want to subtract what GetXULPrefSize added, which is the
   // result of GetBorderAndPadding.
   nsMargin bp;
   GetBorderAndPadding(bp);
 
   result = prefSize.width - bp.LeftRight();
   result = std::max(result, 0);
 
   return result;
@@ -670,20 +670,20 @@ nsBoxFrame::Reflow(nsPresContext*       
   // GetBorderAndPadding(m);
 
   LogicalSize prefSize(wm);
 
   // if we are told to layout intrinsic then get our preferred size.
   NS_ASSERTION(computedSize.ISize(wm) != NS_INTRINSICSIZE,
                "computed inline size should always be computed");
   if (computedSize.BSize(wm) == NS_INTRINSICSIZE) {
-    nsSize physicalPrefSize = GetPrefSize(state);
+    nsSize physicalPrefSize = GetXULPrefSize(state);
     nsSize minSize = GetXULMinSize(state);
     nsSize maxSize = GetMaxSize(state);
-    // XXXbz isn't GetPrefSize supposed to bounds-check for us?
+    // XXXbz isn't GetXULPrefSize supposed to bounds-check for us?
     physicalPrefSize = BoundsCheck(minSize, physicalPrefSize, maxSize);
     prefSize = LogicalSize(wm, physicalPrefSize);
   }
 
   // get our desiredSize
   computedSize.ISize(wm) += m.IStart(wm) + m.IEnd(wm);
 
   if (aReflowState.ComputedBSize() == NS_INTRINSICSIZE) {
@@ -739,17 +739,17 @@ nsBoxFrame::Reflow(nsPresContext*       
 #endif
 
   ReflowAbsoluteFrames(aPresContext, aDesiredSize, aReflowState, aStatus);
 
   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
 }
 
 nsSize
-nsBoxFrame::GetPrefSize(nsBoxLayoutState& aBoxLayoutState)
+nsBoxFrame::GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState)
 {
   NS_ASSERTION(aBoxLayoutState.GetRenderingContext(),
                "must have rendering context");
 
   nsSize size(0,0);
   DISPLAY_PREF_SIZE(this, size);
   if (!DoesNeedRecalc(mPrefSize)) {
      return mPrefSize;
@@ -762,24 +762,24 @@ nsBoxFrame::GetPrefSize(nsBoxLayoutState
   if (IsCollapsed())
     return size;
 
   // if the size was not completely redefined in CSS then ask our children
   bool widthSet, heightSet;
   if (!nsIFrame::AddCSSPrefSize(this, size, widthSet, heightSet))
   {
     if (mLayoutManager) {
-      nsSize layoutSize = mLayoutManager->GetPrefSize(this, aBoxLayoutState);
+      nsSize layoutSize = mLayoutManager->GetXULPrefSize(this, aBoxLayoutState);
       if (!widthSet)
         size.width = layoutSize.width;
       if (!heightSet)
         size.height = layoutSize.height;
     }
     else {
-      size = nsBox::GetPrefSize(aBoxLayoutState);
+      size = nsBox::GetXULPrefSize(aBoxLayoutState);
     }
   }
 
   nsSize minSize = GetXULMinSize(aBoxLayoutState);
   nsSize maxSize = GetMaxSize(aBoxLayoutState);
   mPrefSize = BoundsCheck(minSize, size, maxSize);
  
   return mPrefSize;
@@ -1781,17 +1781,17 @@ nsBoxFrame::DisplayDebugInfoFor(nsIFrame
                     nscoord flexCSS = NS_INTRINSICSIZE;
 
                     bool widthSet, heightSet;
                     nsIFrame::AddCSSPrefSize(child, prefSizeCSS, widthSet, heightSet);
                     nsIFrame::AddCSSMinSize (state, child, minSizeCSS, widthSet, heightSet);
                     nsIFrame::AddCSSMaxSize (child, maxSizeCSS, widthSet, heightSet);
                     nsIFrame::AddCSSFlex    (child, flexCSS);
 
-                    nsSize prefSize = child->GetPrefSize(state);
+                    nsSize prefSize = child->GetXULPrefSize(state);
                     nsSize minSize = child->GetXULMinSize(state);
                     nsSize maxSize = child->GetMaxSize(state);
                     nscoord flexSize = child->GetFlex();
                     nscoord ascentSize = child->GetBoxAscent(state);
 
                     char min[100];
                     char pref[100];
                     char max[100];
diff --git a/layout/xul/nsBoxFrame.h b/layout/xul/nsBoxFrame.h
--- a/layout/xul/nsBoxFrame.h
+++ b/layout/xul/nsBoxFrame.h
@@ -56,17 +56,17 @@ public:
   // gets the rect inside our border and debug border. If you wish to paint inside a box
   // call this method to get the rect so you don't draw on the debug border or outer border.
 
   virtual void SetLayoutManager(nsBoxLayout* aLayout) override { mLayoutManager = aLayout; }
   virtual nsBoxLayout* GetLayoutManager() override { return mLayoutManager; }
 
   virtual nsresult RelayoutChildAtOrdinal(nsIFrame* aChild) override;
 
-  virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetFlex() override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
 #ifdef DEBUG_LAYOUT
   virtual nsresult SetDebug(nsBoxLayoutState& aBoxLayoutState, bool aDebug) override;
   virtual nsresult GetDebug(bool& aDebug) override;
 #endif
diff --git a/layout/xul/nsBoxLayout.cpp b/layout/xul/nsBoxLayout.cpp
--- a/layout/xul/nsBoxLayout.cpp
+++ b/layout/xul/nsBoxLayout.cpp
@@ -29,17 +29,17 @@ nsBoxLayout::AddMargin(nsIFrame* aBox, n
 
 void
 nsBoxLayout::AddMargin(nsSize& aSize, const nsMargin& aMargin)
 {
   nsBox::AddMargin(aSize, aMargin);
 }
 
 nsSize
-nsBoxLayout::GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
+nsBoxLayout::GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
 {
   nsSize pref (0, 0);
   AddBorderAndPadding(aBox, pref);
 
   return pref;
 }
 
 nsSize
diff --git a/layout/xul/nsBoxLayout.h b/layout/xul/nsBoxLayout.h
--- a/layout/xul/nsBoxLayout.h
+++ b/layout/xul/nsBoxLayout.h
@@ -31,17 +31,17 @@ public:
   nsBoxLayout() {}
 
   NS_DECL_ISUPPORTS
 
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_BOX_LAYOUT_IID)
 
   NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aState);
 
-  virtual nsSize GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState);
+  virtual nsSize GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState);
   virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState);
   virtual nsSize GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState);
   virtual nscoord GetAscent(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState);
   virtual void ChildrenInserted(nsIFrame* aBox, nsBoxLayoutState& aState,
                                 nsIFrame* aPrevBox,
                                 const nsFrameList::Slice& aNewChildren) {}
   virtual void ChildrenAppended(nsIFrame* aBox, nsBoxLayoutState& aState,
                                 const nsFrameList::Slice& aNewChildren) {}
diff --git a/layout/xul/nsImageBoxFrame.cpp b/layout/xul/nsImageBoxFrame.cpp
--- a/layout/xul/nsImageBoxFrame.cpp
+++ b/layout/xul/nsImageBoxFrame.cpp
@@ -540,17 +540,17 @@ nsImageBoxFrame::GetImageSize()
     mImageSize.height = 0;
   }
 }
 
 /**
  * Ok return our dimensions
  */
 nsSize
-nsImageBoxFrame::GetPrefSize(nsBoxLayoutState& aState)
+nsImageBoxFrame::GetXULPrefSize(nsBoxLayoutState& aState)
 {
   nsSize size(0,0);
   DISPLAY_PREF_SIZE(this, size);
   if (DoesNeedRecalc(mImageSize))
      GetImageSize();
 
   if (!mUseSrcAttr && (mSubRect.width > 0 || mSubRect.height > 0))
     size = mSubRect.Size();
@@ -632,17 +632,17 @@ nsImageBoxFrame::GetXULMinSize(nsBoxLayo
   bool widthSet, heightSet;
   nsIFrame::AddCSSMinSize(aState, this, size, widthSet, heightSet);
   return size;
 }
 
 nscoord
 nsImageBoxFrame::GetBoxAscent(nsBoxLayoutState& aState)
 {
-  return GetPrefSize(aState).height;
+  return GetXULPrefSize(aState).height;
 }
 
 nsIAtom*
 nsImageBoxFrame::GetType() const
 {
   return nsGkAtoms::imageBoxFrame;
 }
 
diff --git a/layout/xul/nsImageBoxFrame.h b/layout/xul/nsImageBoxFrame.h
--- a/layout/xul/nsImageBoxFrame.h
+++ b/layout/xul/nsImageBoxFrame.h
@@ -42,17 +42,17 @@ class nsImageBoxFrame final : public nsL
 public:
   typedef mozilla::image::DrawResult DrawResult;
   typedef mozilla::layers::ImageContainer ImageContainer;
   typedef mozilla::layers::LayerManager LayerManager;
 
   friend class nsDisplayXULImage;
   NS_DECL_FRAMEARENA_HELPERS
 
-  virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
   virtual void MarkIntrinsicISizesDirty() override;
 
   nsresult Notify(imgIRequest *aRequest, int32_t aType, const nsIntRect* aData);
 
   friend nsIFrame* NS_NewImageBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 
diff --git a/layout/xul/nsLeafBoxFrame.cpp b/layout/xul/nsLeafBoxFrame.cpp
--- a/layout/xul/nsLeafBoxFrame.cpp
+++ b/layout/xul/nsLeafBoxFrame.cpp
@@ -148,21 +148,21 @@ nsLeafBoxFrame::GetMinISize(nsRenderingC
 /* virtual */ nscoord
 nsLeafBoxFrame::GetPrefISize(nsRenderingContext *aRenderingContext)
 {
   nscoord result;
   DISPLAY_PREF_WIDTH(this, result);
   nsBoxLayoutState state(PresContext(), aRenderingContext);
 
   WritingMode wm = GetWritingMode();
-  LogicalSize prefSize(wm, GetPrefSize(state));
+  LogicalSize prefSize(wm, GetXULPrefSize(state));
 
-  // GetPrefSize returns border-box size, and we want to return content
+  // GetXULPrefSize returns border-box size, and we want to return content
   // inline-size.  Since Reflow uses the reflow state's border and padding, we
-  // actually just want to subtract what GetPrefSize added, which is the
+  // actually just want to subtract what GetXULPrefSize added, which is the
   // result of GetBorderAndPadding.
   nsMargin bp;
   GetBorderAndPadding(bp);
 
   result = prefSize.ISize(wm) - LogicalMargin(wm, bp).IStartEnd(wm);
 
   return result;
 }
@@ -252,17 +252,17 @@ nsLeafBoxFrame::Reflow(nsPresContext*   
     nsSize minSize = GetXULMinSize(state);
     computedSize.height = minSize.height - m.top - m.bottom;
   }
 
   nsSize prefSize(0,0);
 
   // if we are told to layout intrinic then get our preferred size.
   if (computedSize.width == NS_INTRINSICSIZE || computedSize.height == NS_INTRINSICSIZE) {
-     prefSize = GetPrefSize(state);
+     prefSize = GetXULPrefSize(state);
      nsSize minSize = GetXULMinSize(state);
      nsSize maxSize = GetMaxSize(state);
      prefSize = BoundsCheck(minSize, prefSize, maxSize);
   }
 
   // get our desiredSize
   if (aReflowState.ComputedWidth() == NS_INTRINSICSIZE) {
     computedSize.width = prefSize.width;
@@ -342,19 +342,19 @@ nsLeafBoxFrame::GetType() const
 nsresult
 nsLeafBoxFrame::CharacterDataChanged(CharacterDataChangeInfo* aInfo)
 {
   MarkIntrinsicISizesDirty();
   return nsLeafFrame::CharacterDataChanged(aInfo);
 }
 
 /* virtual */ nsSize
-nsLeafBoxFrame::GetPrefSize(nsBoxLayoutState& aState)
+nsLeafBoxFrame::GetXULPrefSize(nsBoxLayoutState& aState)
 {
-    return nsBox::GetPrefSize(aState);
+    return nsBox::GetXULPrefSize(aState);
 }
 
 /* virtual */ nsSize
 nsLeafBoxFrame::GetXULMinSize(nsBoxLayoutState& aState)
 {
     return nsBox::GetXULMinSize(aState);
 }
 
diff --git a/layout/xul/nsLeafBoxFrame.h b/layout/xul/nsLeafBoxFrame.h
--- a/layout/xul/nsLeafBoxFrame.h
+++ b/layout/xul/nsLeafBoxFrame.h
@@ -11,17 +11,17 @@
 
 class nsLeafBoxFrame : public nsLeafFrame
 {
 public:
   NS_DECL_FRAMEARENA_HELPERS
 
   friend nsIFrame* NS_NewLeafBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 
-  virtual nsSize GetPrefSize(nsBoxLayoutState& aState) override;
+  virtual nsSize GetXULPrefSize(nsBoxLayoutState& aState) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aState) override;
   virtual nsSize GetMaxSize(nsBoxLayoutState& aState) override;
   virtual nscoord GetFlex() override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aState) override;
 
   virtual nsIAtom* GetType() const override;
   virtual bool IsFrameOfType(uint32_t aFlags) const override
   {
diff --git a/layout/xul/nsListBoxBodyFrame.cpp b/layout/xul/nsListBoxBodyFrame.cpp
--- a/layout/xul/nsListBoxBodyFrame.cpp
+++ b/layout/xul/nsListBoxBodyFrame.cpp
@@ -263,17 +263,17 @@ nsListBoxBodyFrame::DoLayout(nsBoxLayout
   nsOverflowAreas overflow(rect, rect);
   if (mLayoutManager) {
     nsIFrame* childFrame = mFrames.FirstChild();
     while (childFrame) {
       ConsiderChildOverflow(overflow, childFrame);
       childFrame = childFrame->GetNextSibling();
     }
 
-    nsSize prefSize = mLayoutManager->GetPrefSize(this, aBoxLayoutState);
+    nsSize prefSize = mLayoutManager->GetXULPrefSize(this, aBoxLayoutState);
     NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
       nsRect& o = overflow.Overflow(otype);
       o.height = std::max(o.height, prefSize.height);
     }
   }
   FinishAndStoreOverflow(overflow, GetSize());
 
   if (mScrolling)
@@ -288,33 +288,33 @@ nsListBoxBodyFrame::DoLayout(nsBoxLayout
 }
 
 nsSize
 nsListBoxBodyFrame::GetMinSizeForScrollArea(nsBoxLayoutState& aBoxLayoutState)
 {
   nsSize result(0, 0);
   if (nsContentUtils::HasNonEmptyAttr(GetContent(), kNameSpaceID_None,
                                       nsGkAtoms::sizemode)) {
-    result = GetPrefSize(aBoxLayoutState);
+    result = GetXULPrefSize(aBoxLayoutState);
     result.height = 0;
     nsIScrollableFrame* scrollFrame = nsLayoutUtils::GetScrollableFrameFor(this);
     if (scrollFrame &&
         scrollFrame->GetScrollbarStyles().mVertical == NS_STYLE_OVERFLOW_AUTO) {
       nsMargin scrollbars =
         scrollFrame->GetDesiredScrollbarSizes(&aBoxLayoutState);
       result.width += scrollbars.left + scrollbars.right;
     }
   }
   return result;
 }
 
 nsSize
-nsListBoxBodyFrame::GetPrefSize(nsBoxLayoutState& aBoxLayoutState)
+nsListBoxBodyFrame::GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState)
 {  
-  nsSize pref = nsBoxFrame::GetPrefSize(aBoxLayoutState);
+  nsSize pref = nsBoxFrame::GetXULPrefSize(aBoxLayoutState);
 
   int32_t size = GetFixedRowSize();
   if (size > -1)
     pref.height = size*GetRowHeightAppUnits();
 
   nsIScrollableFrame* scrollFrame = nsLayoutUtils::GetScrollableFrameFor(this);
   if (scrollFrame &&
       scrollFrame->GetScrollbarStyles().mVertical == NS_STYLE_OVERFLOW_AUTO) {
diff --git a/layout/xul/nsListBoxBodyFrame.h b/layout/xul/nsListBoxBodyFrame.h
--- a/layout/xul/nsListBoxBodyFrame.h
+++ b/layout/xul/nsListBoxBodyFrame.h
@@ -83,17 +83,17 @@ public:
   // nsIReflowCallback
   virtual bool ReflowFinished() override;
   virtual void ReflowCallbackCanceled() override;
 
   NS_IMETHOD DoLayout(nsBoxLayoutState& aBoxLayoutState) override;
   virtual void MarkIntrinsicISizesDirty() override;
 
   virtual nsSize GetMinSizeForScrollArea(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
 
   // size calculation 
   int32_t GetRowCount();
   int32_t GetRowHeightAppUnits() { return mRowHeight; }
   int32_t GetFixedRowSize();
   void SetRowHeight(nscoord aRowHeight);
   nscoord GetYPosition();
   nscoord GetAvailableHeight();
diff --git a/layout/xul/nsListBoxLayout.cpp b/layout/xul/nsListBoxLayout.cpp
--- a/layout/xul/nsListBoxLayout.cpp
+++ b/layout/xul/nsListBoxLayout.cpp
@@ -16,19 +16,19 @@
 
 nsListBoxLayout::nsListBoxLayout() : nsGridRowGroupLayout()
 {
 }
 
 ////////// nsBoxLayout //////////////
 
 nsSize
-nsListBoxLayout::GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
+nsListBoxLayout::GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
 {
-  nsSize pref = nsGridRowGroupLayout::GetPrefSize(aBox, aBoxLayoutState);
+  nsSize pref = nsGridRowGroupLayout::GetXULPrefSize(aBox, aBoxLayoutState);
 
   nsListBoxBodyFrame* frame = static_cast<nsListBoxBodyFrame*>(aBox);
   if (frame) {
     nscoord rowheight = frame->GetRowHeightAppUnits();
     pref.height = frame->GetRowCount() * rowheight;
     // Pad the height.
     nscoord y = frame->GetAvailableHeight();
     if (pref.height > y && y > 0 && rowheight > 0) {
@@ -150,17 +150,17 @@ nsListBoxLayout::LayoutInternal(nsIFrame
     // relayout if we must or we are dirty or some of our children are dirty
     //   or the client area is wider than us
     // XXXldb There should probably be a resize check here too!
     if (NS_SUBTREE_DIRTY(box) || childRect.width < clientRect.width) {
       childRect.x = 0;
       childRect.y = yOffset;
       childRect.width = clientRect.width;
       
-      nsSize size = box->GetPrefSize(aState);
+      nsSize size = box->GetXULPrefSize(aState);
       body->SetRowHeight(size.height);
       
       childRect.height = rowHeight;
 
       childRect.Deflate(margin);
       box->SetBounds(aState, childRect);
       box->Layout(aState);
     } else {
diff --git a/layout/xul/nsListBoxLayout.h b/layout/xul/nsListBoxLayout.h
--- a/layout/xul/nsListBoxLayout.h
+++ b/layout/xul/nsListBoxLayout.h
@@ -15,17 +15,17 @@ class nsBoxLayoutState;
 
 class nsListBoxLayout : public nsGridRowGroupLayout
 {
 public:
   nsListBoxLayout();
 
   // nsBoxLayout
   NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aState) override;
-  virtual nsSize GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
 
 protected:
   NS_IMETHOD LayoutInternal(nsIFrame* aBox, nsBoxLayoutState& aState);
 };
 
 #endif
diff --git a/layout/xul/nsListItemFrame.cpp b/layout/xul/nsListItemFrame.cpp
--- a/layout/xul/nsListItemFrame.cpp
+++ b/layout/xul/nsListItemFrame.cpp
@@ -21,19 +21,19 @@ nsListItemFrame::nsListItemFrame(nsStyle
 {
 }
 
 nsListItemFrame::~nsListItemFrame()
 {
 }
 
 nsSize
-nsListItemFrame::GetPrefSize(nsBoxLayoutState& aState)
+nsListItemFrame::GetXULPrefSize(nsBoxLayoutState& aState)
 {
-  nsSize size = nsBoxFrame::GetPrefSize(aState);  
+  nsSize size = nsBoxFrame::GetXULPrefSize(aState);  
   DISPLAY_PREF_SIZE(this, size);
 
   // guarantee that our preferred height doesn't exceed the standard
   // listbox row height
   size.height = std::max(mRect.height, size.height);
   return size;
 }
 
diff --git a/layout/xul/nsListItemFrame.h b/layout/xul/nsListItemFrame.h
--- a/layout/xul/nsListItemFrame.h
+++ b/layout/xul/nsListItemFrame.h
@@ -18,17 +18,17 @@ public:
                                        nsStyleContext *aContext);
 
   // overridden so that children of listitems don't handle mouse events,
   // unless allowevents="true" is specified on the listitem
   virtual void BuildDisplayListForChildren(nsDisplayListBuilder*   aBuilder,
                                            const nsRect&           aDirtyRect,
                                            const nsDisplayListSet& aLists) override;
 
-  virtual nsSize GetPrefSize(nsBoxLayoutState& aState) override;
+  virtual nsSize GetXULPrefSize(nsBoxLayoutState& aState) override;
 
 protected:
   explicit nsListItemFrame(nsStyleContext *aContext,
                            bool aIsRoot = false,
                            nsBoxLayout* aLayoutManager = nullptr);
   virtual ~nsListItemFrame();
 
 }; // class nsListItemFrame
diff --git a/layout/xul/nsMenuFrame.cpp b/layout/xul/nsMenuFrame.cpp
--- a/layout/xul/nsMenuFrame.cpp
+++ b/layout/xul/nsMenuFrame.cpp
@@ -1345,17 +1345,17 @@ nsMenuFrame::SizeToPopup(nsBoxLayoutStat
   if (!IsCollapsed()) {
     bool widthSet, heightSet;
     nsSize tmpSize(-1, 0);
     nsIFrame::AddCSSPrefSize(this, tmpSize, widthSet, heightSet);
     if (!widthSet && GetFlex() == 0) {
       nsMenuPopupFrame* popupFrame = GetPopup();
       if (!popupFrame)
         return false;
-      tmpSize = popupFrame->GetPrefSize(aState);
+      tmpSize = popupFrame->GetXULPrefSize(aState);
 
       // Produce a size such that:
       //  (1) the menu and its popup can be the same width
       //  (2) there's enough room in the menu for the content and its
       //      border-padding
       //  (3) there's enough room in the popup for the content and its
       //      scrollbar
       nsMargin borderPadding;
@@ -1375,19 +1375,19 @@ nsMenuFrame::SizeToPopup(nsBoxLayoutStat
       return true;
     }
   }
 
   return false;
 }
 
 nsSize
-nsMenuFrame::GetPrefSize(nsBoxLayoutState& aState)
+nsMenuFrame::GetXULPrefSize(nsBoxLayoutState& aState)
 {
-  nsSize size = nsBoxFrame::GetPrefSize(aState);
+  nsSize size = nsBoxFrame::GetXULPrefSize(aState);
   DISPLAY_PREF_SIZE(this, size);
 
   // If we are using sizetopopup="always" then
   // nsBoxFrame will already have enforced the minimum size
   if (!IsSizedToPopup(mContent, true) &&
       IsSizedToPopup(mContent, false) &&
       SizeToPopup(aState, size)) {
     // We now need to ensure that size is within the min - max range.
diff --git a/layout/xul/nsMenuFrame.h b/layout/xul/nsMenuFrame.h
--- a/layout/xul/nsMenuFrame.h
+++ b/layout/xul/nsMenuFrame.h
@@ -77,17 +77,17 @@ public:
   explicit nsMenuFrame(nsStyleContext* aContext);
 
   NS_DECL_QUERYFRAME_TARGET(nsMenuFrame)
   NS_DECL_QUERYFRAME
   NS_DECL_FRAMEARENA_HELPERS
 
   NS_IMETHOD DoLayout(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual void Init(nsIContent*       aContent,
                     nsContainerFrame* aParent,
                     nsIFrame*         aPrevInFlow) override;
 
 #ifdef DEBUG_LAYOUT
   virtual nsresult SetDebug(nsBoxLayoutState& aState, bool aDebug) override;
 #endif
diff --git a/layout/xul/nsMenuPopupFrame.cpp b/layout/xul/nsMenuPopupFrame.cpp
--- a/layout/xul/nsMenuPopupFrame.cpp
+++ b/layout/xul/nsMenuPopupFrame.cpp
@@ -452,17 +452,17 @@ nsMenuPopupFrame::LayoutPopup(nsBoxLayou
       if (!weakFrame.IsAlive()) {
         return;
       }
     }
   }
 
   // get the preferred, minimum and maximum size. If the menu is sized to the
   // popup, then the popup's width is the menu's width.
-  nsSize prefSize = GetPrefSize(aState);
+  nsSize prefSize = GetXULPrefSize(aState);
   nsSize minSize = GetXULMinSize(aState); 
   nsSize maxSize = GetMaxSize(aState);
 
   if (aSizedToPopup) {
     prefSize.width = aParentMenu->GetRect().width;
   }
   prefSize = BoundsCheck(minSize, prefSize, maxSize);
 
diff --git a/layout/xul/nsSliderFrame.cpp b/layout/xul/nsSliderFrame.cpp
--- a/layout/xul/nsSliderFrame.cpp
+++ b/layout/xul/nsSliderFrame.cpp
@@ -413,17 +413,17 @@ nsSliderFrame::DoLayout(nsBoxLayoutState
   GetClientRect(clientRect);
 
   // get the scrollbar
   nsIFrame* scrollbarBox = GetScrollbar();
   nsCOMPtr<nsIContent> scrollbar;
   scrollbar = GetContentOfBox(scrollbarBox);
 
   // get the thumb's pref size
-  nsSize thumbSize = thumbBox->GetPrefSize(aState);
+  nsSize thumbSize = thumbBox->GetXULPrefSize(aState);
 
   if (IsHorizontal())
     thumbSize.height = clientRect.height;
   else
     thumbSize.width = clientRect.width;
 
   int32_t curPos = GetCurrentPosition(scrollbar);
   int32_t minPos = GetMinPosition(scrollbar);
@@ -1331,20 +1331,20 @@ nsSliderFrame::DestroyFrom(nsIFrame* aDe
   }
   StopRepeat();
 
   // call base class Destroy()
   nsBoxFrame::DestroyFrom(aDestructRoot);
 }
 
 nsSize
-nsSliderFrame::GetPrefSize(nsBoxLayoutState& aState)
+nsSliderFrame::GetXULPrefSize(nsBoxLayoutState& aState)
 {
   EnsureOrient();
-  return nsBoxFrame::GetPrefSize(aState);
+  return nsBoxFrame::GetXULPrefSize(aState);
 }
 
 nsSize
 nsSliderFrame::GetXULMinSize(nsBoxLayoutState& aState)
 {
   EnsureOrient();
 
   // our min size is just our borders and padding
diff --git a/layout/xul/nsSliderFrame.h b/layout/xul/nsSliderFrame.h
--- a/layout/xul/nsSliderFrame.h
+++ b/layout/xul/nsSliderFrame.h
@@ -50,17 +50,17 @@ public:
   virtual ~nsSliderFrame();
 
 #ifdef DEBUG_FRAME_DUMP
   virtual nsresult GetFrameName(nsAString& aResult) const override {
     return MakeFrameName(NS_LITERAL_STRING("SliderFrame"), aResult);
   }
 #endif
 
-  virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
   NS_IMETHOD DoLayout(nsBoxLayoutState& aBoxLayoutState) override;
 
   // nsIFrame overrides
   virtual void DestroyFrom(nsIFrame* aDestructRoot) override;
 
   virtual void BuildDisplayListForChildren(nsDisplayListBuilder*   aBuilder,
diff --git a/layout/xul/nsSplitterFrame.cpp b/layout/xul/nsSplitterFrame.cpp
--- a/layout/xul/nsSplitterFrame.cpp
+++ b/layout/xul/nsSplitterFrame.cpp
@@ -663,17 +663,17 @@ nsSplitterFrameInner::MouseDown(nsIDOMEv
   { 
     nsIContent* content = childBox->GetContent();
     nsIDocument* doc = content->OwnerDoc();
     int32_t dummy;
     nsIAtom* atom = doc->BindingManager()->ResolveTag(content, &dummy);
 
     // skip over any splitters
     if (atom != nsGkAtoms::splitter) { 
-        nsSize prefSize = childBox->GetPrefSize(state);
+        nsSize prefSize = childBox->GetXULPrefSize(state);
         nsSize minSize = childBox->GetXULMinSize(state);
         nsSize maxSize = nsBox::BoundsCheckMinMax(minSize, childBox->GetMaxSize(state));
         prefSize = nsBox::BoundsCheck(minSize, prefSize, maxSize);
 
         mOuter->AddMargin(childBox, minSize);
         mOuter->AddMargin(childBox, prefSize);
         mOuter->AddMargin(childBox, maxSize);
 
diff --git a/layout/xul/nsSprocketLayout.cpp b/layout/xul/nsSprocketLayout.cpp
--- a/layout/xul/nsSprocketLayout.cpp
+++ b/layout/xul/nsSprocketLayout.cpp
@@ -315,17 +315,17 @@ nsSprocketLayout::Layout(nsIFrame* aBox,
       nscoord height = clientRect.height;
 
       if (!childBoxSize->bogus) {
         // We have a valid box size entry.  This entry already contains information about our
         // sizes along the axis of the box (e.g., widths in a horizontal box).  If our default
         // ALIGN is not stretch, however, then we also need to know the child's size along the
         // opposite axis.
         if (!(frameState & NS_STATE_AUTO_STRETCH)) {
-           nsSize prefSize = child->GetPrefSize(aState);
+           nsSize prefSize = child->GetXULPrefSize(aState);
            nsSize minSize = child->GetXULMinSize(aState);
            nsSize maxSize = child->GetMaxSize(aState);
            prefSize = nsBox::BoundsCheck(minSize, prefSize, maxSize);
        
            AddMargin(child, prefSize);
            width = std::min(prefSize.width, originalClientRect.width);
            height = std::min(prefSize.height, originalClientRect.height);
         }
@@ -739,17 +739,17 @@ nsSprocketLayout::PopulateBoxSizes(nsIFr
     nscoord ascent = 0;
     bool collapsed = child->IsCollapsed();
 
     if (!collapsed) {
     // only one flexible child? Cool we will just make its preferred size
     // 0 then and not even have to ask for it.
     //if (flexes != 1)  {
 
-      pref = child->GetPrefSize(aState);
+      pref = child->GetXULPrefSize(aState);
       minSize = child->GetXULMinSize(aState);
       maxSize = nsBox::BoundsCheckMinMax(minSize, child->GetMaxSize(aState));
       ascent = child->GetBoxAscent(aState);
       nsMargin margin;
       child->GetMargin(margin);
       ascent += margin.top;
     //}
 
@@ -1299,17 +1299,17 @@ nsSprocketLayout::ComputeChildSizes(nsIF
 
     boxSizes         = boxSizes->next;
     computedBoxSizes = computedBoxSizes->next;
   }
 }
 
 
 nsSize
-nsSprocketLayout::GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aState)
+nsSprocketLayout::GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
    nsSize vpref (0, 0); 
    bool isHorizontal = IsHorizontal(aBox);
 
    nscoord biggestPref = 0;
 
    // run through all the children and get their min, max, and preferred sizes
    // return us the size of the box
@@ -1320,17 +1320,17 @@ nsSprocketLayout::GetPrefSize(nsIFrame* 
    bool isEqual = !!(frameState & NS_STATE_EQUAL_SIZE);
    int32_t count = 0;
    
    while (child) 
    {  
       // ignore collapsed children
       if (!child->IsCollapsed())
       {
-        nsSize pref = child->GetPrefSize(aState);
+        nsSize pref = child->GetXULPrefSize(aState);
         AddMargin(child, pref);
 
         if (isEqual) {
           if (isHorizontal)
           {
             if (pref.width > biggestPref)
               biggestPref = pref.width;
           } else {
@@ -1383,17 +1383,17 @@ nsSprocketLayout::GetXULMinSize(nsIFrame
       if (!child->IsCollapsed())
       {
         nsSize min = child->GetXULMinSize(aState);
         nsSize pref(0,0);
         
         // if the child is not flexible then
         // its min size is its pref size.
         if (child->GetFlex() == 0) {
-            pref = child->GetPrefSize(aState);
+            pref = child->GetXULPrefSize(aState);
             if (isHorizontal)
                min.width = pref.width;
             else
                min.height = pref.height;
         }
 
         if (isEqual) {
           if (isHorizontal)
diff --git a/layout/xul/nsSprocketLayout.h b/layout/xul/nsSprocketLayout.h
--- a/layout/xul/nsSprocketLayout.h
+++ b/layout/xul/nsSprocketLayout.h
@@ -65,17 +65,17 @@ class nsSprocketLayout : public nsBoxLay
 
 public:
 
   friend nsresult NS_NewSprocketLayout(nsCOMPtr<nsBoxLayout>& aNewLayout);
   static void Shutdown();
 
   NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aState) override;
 
-  virtual nsSize GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetAscent(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
 
   nsSprocketLayout();
 
   static bool IsHorizontal(nsIFrame* aBox);
 
diff --git a/layout/xul/nsStackLayout.cpp b/layout/xul/nsStackLayout.cpp
--- a/layout/xul/nsStackLayout.cpp
+++ b/layout/xul/nsStackLayout.cpp
@@ -54,24 +54,24 @@ nsStackLayout::nsStackLayout()
  * Sizing: we are as wide as the widest child plus its left offset
  * we are tall as the tallest child plus its top offset.
  *
  * Only children which have -moz-stack-sizing set to stretch-to-fit
  * (the default) will be included in the size computations.
  */
 
 nsSize
-nsStackLayout::GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aState)
+nsStackLayout::GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   nsSize prefSize (0, 0);
 
   nsIFrame* child = nsBox::GetChildBox(aBox);
   while (child) {
     if (child->StyleXUL()->mStretchStack) {
-      nsSize pref = child->GetPrefSize(aState);
+      nsSize pref = child->GetXULPrefSize(aState);
 
       AddMargin(child, pref);
       nsMargin offset;
       GetOffset(child, offset);
       pref.width += offset.LeftRight();
       pref.height += offset.TopBottom();
       AddLargestSize(prefSize, pref);
     }
@@ -302,39 +302,39 @@ nsStackLayout::Layout(nsIFrame* aBox, ns
             nsSize max = child->GetMaxSize(aState);
             if (offsetSpecified & SPECIFIED_LEFT) {
               childRect.x = clientRect.x + offset.left + margin.left;
               if (offsetSpecified & SPECIFIED_RIGHT) {
                 nscoord width = clientRect.width - offset.LeftRight() - margin.LeftRight();
                 childRect.width = clamped(width, min.width, max.width);
               }
               else {
-                nscoord width = child->GetPrefSize(aState).width;
+                nscoord width = child->GetXULPrefSize(aState).width;
                 childRect.width = clamped(width, min.width, max.width);
               }
             }
             else if (offsetSpecified & SPECIFIED_RIGHT) {
-              nscoord width = child->GetPrefSize(aState).width;
+              nscoord width = child->GetXULPrefSize(aState).width;
               childRect.width = clamped(width, min.width, max.width);
               childRect.x = clientRect.XMost() - offset.right - margin.right - childRect.width;
             }
 
             if (offsetSpecified & SPECIFIED_TOP) {
               childRect.y = clientRect.y + offset.top + margin.top;
               if (offsetSpecified & SPECIFIED_BOTTOM) {
                 nscoord height = clientRect.height - offset.TopBottom() - margin.TopBottom();
                 childRect.height = clamped(height, min.height, max.height);
               }
               else {
-                nscoord height = child->GetPrefSize(aState).height;
+                nscoord height = child->GetXULPrefSize(aState).height;
                 childRect.height = clamped(height, min.height, max.height);
               }
             }
             else if (offsetSpecified & SPECIFIED_BOTTOM) {
-              nscoord height = child->GetPrefSize(aState).height;
+              nscoord height = child->GetXULPrefSize(aState).height;
               childRect.height = clamped(height, min.height, max.height);
               childRect.y = clientRect.YMost() - offset.bottom - margin.bottom - childRect.height;
             }
           }
 
           // Now place the child.
           child->SetBounds(aState, childRect);
 
diff --git a/layout/xul/nsStackLayout.h b/layout/xul/nsStackLayout.h
--- a/layout/xul/nsStackLayout.h
+++ b/layout/xul/nsStackLayout.h
@@ -29,17 +29,17 @@ public:
 
   friend nsresult NS_NewStackLayout(nsCOMPtr<nsBoxLayout>& aNewLayout);
   static void Shutdown();
 
   nsStackLayout();
 
   NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aState) override;
 
-  virtual nsSize GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetAscent(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
 
   // get the child offsets for aChild and set them in aMargin. Returns a
   // bitfield mask of the SPECIFIED_LEFT, SPECIFIED_RIGHT, SPECIFIED_TOP and
   // SPECIFIED_BOTTOM offsets indicating which sides have been specified by
   // attributes.
diff --git a/layout/xul/nsTextBoxFrame.cpp b/layout/xul/nsTextBoxFrame.cpp
--- a/layout/xul/nsTextBoxFrame.cpp
+++ b/layout/xul/nsTextBoxFrame.cpp
@@ -1103,17 +1103,17 @@ nsTextBoxFrame::CalcDrawRect(nsRendering
 
     mTextDrawRect = textRect.GetPhysicalRect(wm, GetSize());
 }
 
 /**
  * Ok return our dimensions
  */
 nsSize
-nsTextBoxFrame::GetPrefSize(nsBoxLayoutState& aBoxLayoutState)
+nsTextBoxFrame::GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState)
 {
     CalcTextSize(aBoxLayoutState);
 
     nsSize size = mTextSize;
     DISPLAY_PREF_SIZE(this, size);
 
     AddBorderAndPadding(size);
     bool widthSet, heightSet;
diff --git a/layout/xul/nsTextBoxFrame.h b/layout/xul/nsTextBoxFrame.h
--- a/layout/xul/nsTextBoxFrame.h
+++ b/layout/xul/nsTextBoxFrame.h
@@ -14,17 +14,17 @@ class nsFontMetrics;
 
 class nsTextBoxFrame : public nsLeafBoxFrame
 {
 public:
   NS_DECL_QUERYFRAME_TARGET(nsTextBoxFrame)
   NS_DECL_QUERYFRAME
   NS_DECL_FRAMEARENA_HELPERS
 
-  virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
   NS_IMETHOD DoLayout(nsBoxLayoutState& aBoxLayoutState) override;
   virtual void MarkIntrinsicISizesDirty() override;
 
   enum CroppingStyle { CropNone, CropLeft, CropRight, CropCenter, CropAuto };
 
   friend nsIFrame* NS_NewTextBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
