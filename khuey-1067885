# HG changeset patch
# Parent 0e0557be01ee9d618fb6b145efd293c11d4a1632
# User Kyle Huey <khuey@kylehuey.com>

Bug 1067885: Honor the unlimited storage permission. r=bent

diff --git a/dom/indexedDB/ActorsParent.cpp b/dom/indexedDB/ActorsParent.cpp
--- a/dom/indexedDB/ActorsParent.cpp
+++ b/dom/indexedDB/ActorsParent.cpp
@@ -35,16 +35,17 @@
 #include "mozilla/dom/indexedDB/PBackgroundIDBDatabaseFileParent.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBFactoryParent.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBFactoryRequestParent.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBRequestParent.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBTransactionParent.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBVersionChangeTransactionParent.h"
 #include "mozilla/dom/indexedDB/PIndexedDBPermissionRequestParent.h"
 #include "mozilla/dom/ipc/BlobParent.h"
+#include "CheckQuotaHelper.h"
 #include "mozilla/dom/quota/Client.h"
 #include "mozilla/dom/quota/FileStreams.h"
 #include "mozilla/dom/quota/OriginOrPatternString.h"
 #include "mozilla/dom/quota/QuotaManager.h"
 #include "mozilla/dom/quota/StoragePrivilege.h"
 #include "mozilla/dom/quota/UsageInfo.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/BackgroundUtils.h"
@@ -3876,16 +3877,17 @@ protected:
   nsTArray<MaybeBlockedDatabaseInfo> mMaybeBlockedDatabases;
 
   const CommonFactoryRequestParams mCommonParams;
   nsCString mGroup;
   nsCString mOrigin;
   nsCString mDatabaseId;
   State mState;
   StoragePrivilege mStoragePrivilege;
+  bool mEnforcingQuota;
   const bool mDeleting;
   bool mBlockedQuotaManager;
   bool mChromeWriteAccessAllowed;
 
 public:
   void
   NoteDatabaseBlocked(Database* aDatabase);
 
@@ -3905,16 +3907,17 @@ protected:
             already_AddRefed<ContentParent> aContentParent,
             const CommonFactoryRequestParams& aCommonParams,
             bool aDeleting)
     : mFactory(aFactory)
     , mContentParent(Move(aContentParent))
     , mCommonParams(aCommonParams)
     , mState(State_Initial)
     , mStoragePrivilege(mozilla::dom::quota::Content)
+    , mEnforcingQuota(true)
     , mDeleting(aDeleting)
     , mBlockedQuotaManager(false)
     , mChromeWriteAccessAllowed(false)
   {
     AssertIsOnBackgroundThread();
     MOZ_ASSERT(aFactory);
   }
 
@@ -10740,16 +10743,18 @@ FactoryOp::CheckPermission(ContentParent
       mChromeWriteAccessAllowed = canWrite;
     } else {
       mChromeWriteAccessAllowed = true;
     }
 
     if (State_Initial == mState) {
       QuotaManager::GetInfoForChrome(&mGroup, &mOrigin, &mStoragePrivilege,
                                      nullptr);
+      MOZ_ASSERT(mStoragePrivilege == mozilla::dom::quota::Chrome);
+      mEnforcingQuota = false;
     }
 
     *aPermission = PermissionRequestBase::kPermissionAllowed;
     return NS_OK;
   }
 
   MOZ_ASSERT(principalInfo.type() == PrincipalInfo::TContentPrincipalInfo);
 
@@ -10794,16 +10799,31 @@ FactoryOp::CheckPermission(ContentParent
 
   if (permission != PermissionRequestBase::kPermissionDenied &&
       State_Initial == mState) {
     rv = QuotaManager::GetInfoFromPrincipal(principal, &mGroup, &mOrigin,
                                             &mStoragePrivilege, nullptr);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
     }
+
+    if (mStoragePrivilege == mozilla::dom::quota::Chrome) {
+      mEnforcingQuota = false;
+    }
+  }
+
+  if (permission == PermissionRequestBase::kPermissionAllowed &&
+      mEnforcingQuota)
+  {
+    // If we're running from a window then we should check the quota permission
+    // as well.
+    uint32_t quotaPermission = CheckQuotaHelper::GetQuotaPermission(principal);
+    if (quotaPermission == nsIPermissionManager::ALLOW_ACTION) {
+      mEnforcingQuota = false;
+    }
   }
 
   *aPermission = permission;
   return NS_OK;
 }
 
 nsresult
 FactoryOp::SendVersionChangeMessages(DatabaseActorInfo* aDatabaseActorInfo,
@@ -11199,17 +11219,17 @@ OpenDatabaseOp::DoDatabaseWork()
   MOZ_ASSERT(quotaManager);
 
   nsCOMPtr<nsIFile> dbDirectory;
 
   nsresult rv =
     quotaManager->EnsureOriginIsInitialized(persistenceType,
                                             mGroup,
                                             mOrigin,
-                                            mStoragePrivilege != Chrome,
+                                            mEnforcingQuota,
                                             getter_AddRefs(dbDirectory));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   rv = dbDirectory->Append(NS_LITERAL_STRING(IDB_DIRECTORY_NAME));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
diff --git a/dom/indexedDB/test/test_disabled_quota_prompt.html b/dom/indexedDB/test/test_disabled_quota_prompt.html
--- a/dom/indexedDB/test/test_disabled_quota_prompt.html
+++ b/dom/indexedDB/test/test_disabled_quota_prompt.html
@@ -108,11 +108,11 @@
         yield undefined;
       }
     </script>
 
     <script type="text/javascript;version=1.7" src="helpers.js"></script>
 
   </head>
 
-  <body onload="runTest();"></body>
+  <body onload="runTest(true);"></body>
 
 </html>
diff --git a/dom/indexedDB/test/test_persistenceType.html b/dom/indexedDB/test/test_persistenceType.html
--- a/dom/indexedDB/test/test_persistenceType.html
+++ b/dom/indexedDB/test/test_persistenceType.html
@@ -109,11 +109,11 @@
       finishTest();
       yield undefined;
     }
   </script>
   <script type="text/javascript;version=1.7" src="helpers.js"></script>
 
 </head>
 
-<body onload="runTest();"></body>
+<body onload="runTest(true);"></body>
 
 </html>
diff --git a/dom/quota/QuotaManager.cpp b/dom/quota/QuotaManager.cpp
--- a/dom/quota/QuotaManager.cpp
+++ b/dom/quota/QuotaManager.cpp
@@ -1729,17 +1729,17 @@ QuotaManager::InitializeOrigin(Persisten
       // Temporary storage has no limit for origin usage (there's a group and
       // the global limit though).
       quotaMaxBytes = 0;
     }
     else {
       quotaMaxBytes = GetStorageQuotaMB() * 1024 * 1024;
       if (totalUsageBytes > quotaMaxBytes) {
         NS_WARNING("Origin is already using more storage than allowed!");
-        return NS_ERROR_UNEXPECTED;
+        return NS_ERROR_FILE_NO_DEVICE_SPACE;
       }
     }
 
     InitQuotaForOrigin(aPersistenceType, aGroup, aOrigin, quotaMaxBytes,
                        totalUsageBytes, aAccessTime);
   }
 
   return NS_OK;
