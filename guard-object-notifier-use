From: L. David Baron <dbaron@dbaron.org>

Fire assertions when guard objects are used as temporaries.  (FIXME:  Is NS_STACK_CLASS needed when deriving from something that already has it?  FIXME:  Add NS_NONTEMPORARY_CLASS.)  (Bug 531460)

diff --git a/content/base/public/nsContentUtils.h b/content/base/public/nsContentUtils.h
--- a/content/base/public/nsContentUtils.h
+++ b/content/base/public/nsContentUtils.h
@@ -55,16 +55,17 @@
 #include "nsIDOM3Node.h"
 #include "nsDataHashtable.h"
 #include "nsIScriptRuntime.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIDOMEvent.h"
 #include "nsTArray.h"
 #include "nsTextFragment.h"
 #include "nsReadableUtils.h"
+#include "mozilla/AutoRestore.h"
 
 struct nsNativeKeyEvent; // Don't include nsINativeKeyBindings.h here: it will force strange compilation error!
 
 class nsIDOMScriptObjectFactory;
 class nsIXPConnect;
 class nsINode;
 class nsIContent;
 class nsIDOMNode;
@@ -1638,36 +1639,42 @@ private:
   nsCOMPtr<nsIScriptContext> mScx;
   PRBool mScriptIsRunning;
   PRBool mPushedSomething;
 #ifdef DEBUG
   JSContext* mPushedContext;
 #endif
 };
 
-class nsAutoGCRoot {
+class NS_STACK_CLASS nsAutoGCRoot {
 public:
   // aPtr should be the pointer to the jsval we want to protect
-  nsAutoGCRoot(jsval* aPtr, nsresult* aResult) :
+  nsAutoGCRoot(jsval* aPtr, nsresult* aResult
+               MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM) :
     mPtr(aPtr)
   {
+    MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
     mResult = *aResult = AddJSGCRoot(aPtr, "nsAutoGCRoot");
   }
 
   // aPtr should be the pointer to the JSObject* we want to protect
-  nsAutoGCRoot(JSObject** aPtr, nsresult* aResult) :
+  nsAutoGCRoot(JSObject** aPtr, nsresult* aResult
+               MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM) :
     mPtr(aPtr)
   {
+    MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
     mResult = *aResult = AddJSGCRoot(aPtr, "nsAutoGCRoot");
   }
 
   // aPtr should be the pointer to the thing we want to protect
-  nsAutoGCRoot(void* aPtr, nsresult* aResult) :
+  nsAutoGCRoot(void* aPtr, nsresult* aResult
+               MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM) :
     mPtr(aPtr)
   {
+    MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
     mResult = *aResult = AddJSGCRoot(aPtr, "nsAutoGCRoot");
   }
 
   ~nsAutoGCRoot() {
     if (NS_SUCCEEDED(mResult)) {
       RemoveJSGCRoot(mPtr);
     }
   }
@@ -1678,38 +1685,44 @@ private:
   static nsresult AddJSGCRoot(void *aPtr, const char* aName);
   static nsresult RemoveJSGCRoot(void *aPtr);
 
   static nsIJSRuntimeService* sJSRuntimeService;
   static JSRuntime* sJSScriptRuntime;
 
   void* mPtr;
   nsresult mResult;
+  MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
-class nsAutoScriptBlocker {
+class NS_STACK_CLASS nsAutoScriptBlocker {
 public:
-  nsAutoScriptBlocker() {
+  nsAutoScriptBlocker(MOZILLA_GUARD_OBJECT_NOTIFIER_ONLY_PARAM) {
+    MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
     nsContentUtils::AddScriptBlocker();
   }
   ~nsAutoScriptBlocker() {
     nsContentUtils::RemoveScriptBlocker();
   }
+private:
+  MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
-class mozAutoRemovableBlockerRemover
+class NS_STACK_CLASS mozAutoRemovableBlockerRemover
 {
 public:
-  mozAutoRemovableBlockerRemover(nsIDocument* aDocument);
+  mozAutoRemovableBlockerRemover(nsIDocument* aDocument
+                                 MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM);
   ~mozAutoRemovableBlockerRemover();
 
 private:
   PRUint32 mNestingLevel;
   nsCOMPtr<nsIDocument> mDocument;
   nsCOMPtr<nsIDocumentObserver> mObserver;
+  MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 #define NS_AUTO_GCROOT_PASTE2(tok,line) tok##line
 #define NS_AUTO_GCROOT_PASTE(tok,line) \
   NS_AUTO_GCROOT_PASTE2(tok,line)
 #define NS_AUTO_GCROOT(ptr, result) \ \
   nsAutoGCRoot NS_AUTO_GCROOT_PASTE(_autoGCRoot_, __LINE__) \
   (ptr, result)
diff --git a/content/base/src/nsContentUtils.cpp b/content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp
+++ b/content/base/src/nsContentUtils.cpp
@@ -5296,18 +5296,19 @@ nsContentUtils::CheckCCWrapperTraversal(
   callback.mFound = PR_FALSE;
   participant->Trace(aScriptObjectHolder, DebugWrapperTraceCallback, &callback);
   NS_ASSERTION(callback.mFound,
                "Cycle collection participant didn't trace preserved wrapper! "
                "This will probably crash.");
 }
 #endif
 
-mozAutoRemovableBlockerRemover::mozAutoRemovableBlockerRemover(nsIDocument* aDocument)
+mozAutoRemovableBlockerRemover::mozAutoRemovableBlockerRemover(nsIDocument* aDocument MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM_IN_IMPL)
 {
+  MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
   mNestingLevel = nsContentUtils::GetRemovableScriptBlockerLevel();
   mDocument = aDocument;
   nsISupports* sink = aDocument ? aDocument->GetCurrentContentSink() : nsnull;
   mObserver = do_QueryInterface(sink);
   for (PRUint32 i = 0; i < mNestingLevel; ++i) {
     if (mObserver) {
       mObserver->EndUpdate(mDocument, UPDATE_CONTENT_MODEL);
     }
diff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h
--- a/js/src/xpconnect/src/xpcprivate.h
+++ b/js/src/xpconnect/src/xpcprivate.h
@@ -91,16 +91,17 @@
 #include "prlong.h"
 #include "prmem.h"
 #include "prenv.h"
 #include "prclist.h"
 #include "nsString.h"
 #include "nsReadableUtils.h"
 #include "nsXPIDLString.h"
 #include "nsAutoJSValHolder.h"
+#include "mozilla/AutoRestore.h"
 
 #include "nsThreadUtils.h"
 #include "nsIJSContextStack.h"
 #include "nsDeque.h"
 
 #include "nsIConsoleService.h"
 #include "nsIScriptError.h"
 #include "nsIExceptionService.h"
@@ -300,32 +301,33 @@ static inline void xpc_NotifyAll(XPCLock
 // a null monitor in without things blowing up. This is used for wrappers that
 // are guaranteed to be used only on one thread. We avoid lock overhead by
 // using a null monitor. By changing this class we can avoid having multiplte
 // code paths or (conditional) manual calls to PR_{Enter,Exit}Monitor.
 //
 // Note that xpconnect only makes *one* monitor and *mostly* holds it locked
 // only through very small critical sections.
 
-class XPCAutoLock : public nsAutoLockBase {
+class NS_STACK_CLASS XPCAutoLock : public nsAutoLockBase {
 public:
 
     static XPCLock* NewLock(const char* name)
                         {return nsAutoMonitor::NewMonitor(name);}
     static void     DestroyLock(XPCLock* lock)
                         {nsAutoMonitor::DestroyMonitor(lock);}
 
-    XPCAutoLock(XPCLock* lock)
+    XPCAutoLock(XPCLock* lock MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
 #ifdef DEBUG_jband
         : nsAutoLockBase(lock ? (void*) lock : (void*) this, eAutoMonitor),
 #else
         : nsAutoLockBase(lock, eAutoMonitor),
 #endif
           mLock(lock)
     {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         if(mLock)
             PR_EnterMonitor(mLock);
     }
 
     ~XPCAutoLock()
     {
         if(mLock)
         {
@@ -334,16 +336,17 @@ public:
 #endif
                 PR_ExitMonitor(mLock);
             NS_ASSERTION(status == PR_SUCCESS, "PR_ExitMonitor failed");
         }
     }
 
 private:
     XPCLock*  mLock;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 
     // Not meant to be implemented. This makes it a compiler error to
     // construct or assign an XPCAutoLock object incorrectly.
     XPCAutoLock(void) {}
     XPCAutoLock(XPCAutoLock& /*aMon*/) {}
     XPCAutoLock& operator =(XPCAutoLock& /*aMon*/) {
         return *this;
     }
@@ -353,22 +356,23 @@ private:
     static void* operator new(size_t /*size*/) CPP_THROW_NEW {
         return nsnull;
     }
     static void operator delete(void* /*memory*/) {}
 };
 
 /************************************************/
 
-class XPCAutoUnlock : public nsAutoUnlockBase {
+class NS_STACK_CLASS XPCAutoUnlock : public nsAutoUnlockBase {
 public:
-    XPCAutoUnlock(XPCLock* lock)
+    XPCAutoUnlock(XPCLock* lock MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
         : nsAutoUnlockBase(lock),
           mLock(lock)
     {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         if(mLock)
         {
 #ifdef DEBUG
             PRStatus status =
 #endif
                 PR_ExitMonitor(mLock);
             NS_ASSERTION(status == PR_SUCCESS, "PR_ExitMonitor failed");
         }
@@ -377,16 +381,17 @@ public:
     ~XPCAutoUnlock()
     {
         if(mLock)
             PR_EnterMonitor(mLock);
     }
 
 private:
     XPCLock*  mLock;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 
     // Not meant to be implemented. This makes it a compiler error to
     // construct or assign an XPCAutoUnlock object incorrectly.
     XPCAutoUnlock(void) {}
     XPCAutoUnlock(XPCAutoUnlock& /*aMon*/) {}
     XPCAutoUnlock& operator =(XPCAutoUnlock& /*aMon*/) {
         return *this;
     }
@@ -396,22 +401,24 @@ private:
     static void* operator new(size_t /*size*/) CPP_THROW_NEW {
         return nsnull;
     }
     static void operator delete(void* /*memory*/) {}
 };
 
 // A helper class to deal with temporary JS contexts. It destroys the context
 // when it goes out of scope.
-class XPCAutoJSContext
+class NS_STACK_CLASS XPCAutoJSContext
 {
 public:
-    XPCAutoJSContext(JSContext *aContext, PRBool aGCOnDestroy)
+    XPCAutoJSContext(JSContext *aContext, PRBool aGCOnDestroy
+                     MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
         : mContext(aContext), mGCOnDestroy(aGCOnDestroy)
     {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
     }
 
     ~XPCAutoJSContext()
     {
         if(!mContext)
             return;
 
         if(mGCOnDestroy)
@@ -420,16 +427,17 @@ public:
             JS_DestroyContextNoGC(mContext);
     }
 
     operator JSContext * () {return mContext;}
 
 private:
     JSContext *mContext;
     PRBool mGCOnDestroy;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 /***************************************************************************
 ****************************************************************************
 *
 * Core runtime and context classes...
 *
 ****************************************************************************
@@ -3774,21 +3782,24 @@ private:
     PRUint32 mColumnNumber;
     PRUint32 mFlags;
     nsCString mCategory;
 };
 
 /***************************************************************************/
 // XXX allowing for future notifications to XPCCallContext
 
-class AutoJSRequest
+class NS_STACK_CLASS AutoJSRequest
 {
 public:
-    AutoJSRequest(XPCCallContext& aCCX)
-      : mCCX(aCCX), mCX(aCCX.GetJSContext()) {BeginRequest();}
+    AutoJSRequest(XPCCallContext& aCCX MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
+      : mCCX(aCCX), mCX(aCCX.GetJSContext()) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+        BeginRequest();
+    }
     ~AutoJSRequest() {EndRequest();}
 
     void EndRequest() {
         if(mCX) {
             JS_EndRequest(mCX);
             mCX = nsnull;
         }
     }
@@ -3797,23 +3808,28 @@ private:
         if(JS_GetContextThread(mCX))
             JS_BeginRequest(mCX);
         else
             mCX = nsnull;
     }
 private:
     XPCCallContext& mCCX;
     JSContext* mCX;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
-class AutoJSSuspendRequest
+class NS_STACK_CLASS AutoJSSuspendRequest
 {
 public:
-    AutoJSSuspendRequest(XPCCallContext& aCCX)
-      : mCX(aCCX.GetJSContext()) {SuspendRequest();}
+    AutoJSSuspendRequest(XPCCallContext& aCCX
+                         MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
+      : mCX(aCCX.GetJSContext()) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+        SuspendRequest();
+    }
     ~AutoJSSuspendRequest() {ResumeRequest();}
 
     void ResumeRequest() {
         if(mCX) {
             JS_ResumeRequest(mCX, mDepth);
             mCX = nsnull;
         }
     }
@@ -3822,23 +3838,28 @@ private:
         if(JS_GetContextThread(mCX))
             mDepth = JS_SuspendRequest(mCX);
         else
             mCX = nsnull;
     }
 private:
     JSContext* mCX;
     jsrefcount mDepth;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
-class AutoJSSuspendRequestWithNoCallContext
+class NS_STACK_CLASS AutoJSSuspendRequestWithNoCallContext
 {
 public:
-    AutoJSSuspendRequestWithNoCallContext(JSContext *aCX)
-      : mCX(aCX) {SuspendRequest();}
+    AutoJSSuspendRequestWithNoCallContext(JSContext *aCX
+                                          MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
+      : mCX(aCX) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+        SuspendRequest();
+    }
     ~AutoJSSuspendRequestWithNoCallContext() {ResumeRequest();}
 
     void ResumeRequest() {
         if(mCX) {
             JS_ResumeRequest(mCX, mDepth);
             mCX = nsnull;
         }
     }
@@ -3847,23 +3868,28 @@ private:
         if(JS_GetContextThread(mCX))
             mDepth = JS_SuspendRequest(mCX);
         else
             mCX = nsnull;
     }
 private:
     JSContext* mCX;
     jsrefcount mDepth;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
-class AutoJSSuspendNonMainThreadRequest
+class NS_STACK_CLASS AutoJSSuspendNonMainThreadRequest
 {
 public:
-    AutoJSSuspendNonMainThreadRequest(JSContext *aCX)
-        : mCX(aCX) {SuspendRequest();}
+    AutoJSSuspendNonMainThreadRequest(JSContext *aCX
+                                      MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
+        : mCX(aCX) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+        SuspendRequest();
+    }
     ~AutoJSSuspendNonMainThreadRequest() {ResumeRequest();}
 
     void ResumeRequest() {
         if (mCX) {
             JS_ResumeRequest(mCX, mDepth);
             mCX = nsnull;
         }
     }
@@ -3873,25 +3899,31 @@ private:
         if (mCX && !XPCPerThreadData::IsMainThread(mCX))
             mDepth = JS_SuspendRequest(mCX);
         else
             mCX = nsnull;
     }
 
     JSContext *mCX;
     jsrefcount mDepth;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
         
 
 /*****************************************/
 
-class AutoJSRequestWithNoCallContext
+class NS_STACK_CLASS AutoJSRequestWithNoCallContext
 {
 public:
-    AutoJSRequestWithNoCallContext(JSContext* aCX) : mCX(aCX) {BeginRequest();}
+    AutoJSRequestWithNoCallContext(JSContext* aCX
+                                   MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
+        : mCX(aCX) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+        BeginRequest();
+    }
     ~AutoJSRequestWithNoCallContext() {EndRequest();}
 
     void EndRequest() {
         if(mCX) {
             JS_EndRequest(mCX);
             mCX = nsnull;
         }
     }
@@ -3899,51 +3931,58 @@ private:
     void BeginRequest() {
         if(JS_GetContextThread(mCX))
             JS_BeginRequest(mCX);
         else
             mCX = nsnull;
     }
 private:
     JSContext* mCX;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 /***************************************************************************/
-class AutoJSErrorAndExceptionEater
+class NS_STACK_CLASS AutoJSErrorAndExceptionEater
 {
 public:
-    AutoJSErrorAndExceptionEater(JSContext* aCX)
+    AutoJSErrorAndExceptionEater(JSContext* aCX
+                                 MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
         : mCX(aCX),
           mOldErrorReporter(JS_SetErrorReporter(mCX, nsnull)),
-          mOldExceptionState(JS_SaveExceptionState(mCX)) {}
+          mOldExceptionState(JS_SaveExceptionState(mCX)) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+    }
     ~AutoJSErrorAndExceptionEater()
     {
         JS_SetErrorReporter(mCX, mOldErrorReporter);
         JS_RestoreExceptionState(mCX, mOldExceptionState);
     }
 private:
     JSContext*        mCX;
     JSErrorReporter   mOldErrorReporter;
     JSExceptionState* mOldExceptionState;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 /******************************************************************************
  * Handles pre/post script processing and the setting/resetting the error
  * reporter
  */
-class AutoScriptEvaluate
+class NS_STACK_CLASS AutoScriptEvaluate
 {
 public:
     /**
      * Saves the JSContext as well as initializing our state
      * @param cx The JSContext, this can be null, we don't do anything then
      */
-    AutoScriptEvaluate(JSContext * cx)
+    AutoScriptEvaluate(JSContext * cx MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
          : mJSContext(cx), mState(0), mErrorReporterSet(PR_FALSE),
-           mEvaluated(PR_FALSE), mContextHasThread(0) {}
+           mEvaluated(PR_FALSE), mContextHasThread(0) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+    }
 
     /**
      * Does the pre script evaluation and sets the error reporter if given
      * This function should only be called once, and will assert if called
      * more than once
      * @param errorReporter the error reporter callback function to set
      */
 
@@ -3953,43 +3992,48 @@ public:
      */
     ~AutoScriptEvaluate();
 private:
     JSContext* mJSContext;
     JSExceptionState* mState;
     PRBool mErrorReporterSet;
     PRBool mEvaluated;
     jsword mContextHasThread;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 
     // No copying or assignment allowed
     AutoScriptEvaluate(const AutoScriptEvaluate &);
     AutoScriptEvaluate & operator =(const AutoScriptEvaluate &);
 };
 
 /***************************************************************************/
-class AutoResolveName
+class NS_STACK_CLASS AutoResolveName
 {
 public:
-    AutoResolveName(XPCCallContext& ccx, jsval name)
+    AutoResolveName(XPCCallContext& ccx, jsval name
+                    MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
         : mTLS(ccx.GetThreadData()),
           mOld(mTLS->SetResolveName(name)),
-          mCheck(name) {}
+          mCheck(name) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+    }
     ~AutoResolveName()
         {
 #ifdef DEBUG
             jsval old = 
 #endif
             mTLS->SetResolveName(mOld);
             NS_ASSERTION(old == mCheck, "Bad Nesting!");
         }
 
 private:
     XPCPerThreadData* mTLS;
     jsval mOld;
     jsval mCheck;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 /***************************************************************************/
 class XPCMarkableJSVal
 {
 public:
     XPCMarkableJSVal(jsval val) : mVal(val), mValPtr(&mVal) {}
     XPCMarkableJSVal(jsval *pval) : mVal(0), mValPtr(pval) {}
diff --git a/layout/base/nsLayoutUtils.h b/layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h
+++ b/layout/base/nsLayoutUtils.h
@@ -1122,31 +1122,33 @@ public:
     /* Whether the element was "write only", that is, the bits should not be exposed to content */
     PRBool mIsWriteOnly;
   };
 
   static SurfaceFromElementResult SurfaceFromElement(nsIDOMElement *aElement,
                                                      PRUint32 aSurfaceFlags = 0);
 };
 
-class nsAutoDisableGetUsedXAssertions
+class NS_STACK_CLASS nsAutoDisableGetUsedXAssertions
 {
 public:
-  nsAutoDisableGetUsedXAssertions()
+  nsAutoDisableGetUsedXAssertions(MOZILLA_GUARD_OBJECT_NOTIFIER_ONLY_PARAM)
     : mOldValue(nsLayoutUtils::sDisableGetUsedXAssertions)
   {
+    MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
     nsLayoutUtils::sDisableGetUsedXAssertions = PR_TRUE;
   }
   ~nsAutoDisableGetUsedXAssertions()
   {
     nsLayoutUtils::sDisableGetUsedXAssertions = mOldValue;
   }
 
 private:
   PRBool mOldValue;
+  MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 class nsSetAttrRunnable : public nsRunnable
 {
 public:
   nsSetAttrRunnable(nsIContent* aContent, nsIAtom* aAttrName,
                     const nsAString& aValue);
 
diff --git a/xpcom/glue/AutoRestore.h b/xpcom/glue/AutoRestore.h
--- a/xpcom/glue/AutoRestore.h
+++ b/xpcom/glue/AutoRestore.h
@@ -165,21 +165,26 @@ namespace mozilla {
    *     mIsPainting = PR_TRUE;
    *     
    *     // ... your code here ...
    *
    *     // mIsPainting is reset to its old value at the end of this block
    *   }
    */
   template <class T>
-  class AutoRestore
+  class NS_STACK_CLASS AutoRestore
   {
   private:
     T& mLocation;
     T mValue;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
   public:
-    AutoRestore(T& aValue) : mLocation(aValue), mValue(aValue) {}
+    AutoRestore(T& aValue MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
+      : mLocation(aValue), mValue(aValue)
+    {
+      MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+    }
     ~AutoRestore() { mLocation = mValue; }
   };
 
 }
 
 #endif /* !defined(mozilla_AutoRestore_h_) */
diff --git a/xpcom/glue/Mutex.h b/xpcom/glue/Mutex.h
--- a/xpcom/glue/Mutex.h
+++ b/xpcom/glue/Mutex.h
@@ -36,16 +36,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef mozilla_Mutex_h
 #define mozilla_Mutex_h
 
 #include "prlock.h"
 
+#include "mozilla/AutoRestore.h"
 #include "mozilla/BlockingResourceBase.h"
 
 //
 // Provides:
 //
 //  - Mutex, a non-recursive mutex
 //  - MutexAutoLock, an RAII class for ensuring that Mutexes are properly 
 //    locked and unlocked
@@ -168,51 +169,54 @@ public:
     /**
      * Constructor
      * The constructor aquires the given lock.  The destructor
      * releases the lock.
      * 
      * @param aLock A valid mozilla::Mutex* returned by 
      *              mozilla::Mutex::NewMutex. 
      **/
-    MutexAutoLock(mozilla::Mutex& aLock) :
+    MutexAutoLock(mozilla::Mutex& aLock MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM) :
         mLock(&aLock)
     {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         NS_ASSERTION(mLock, "null mutex");
         mLock->Lock();
     }
     
     ~MutexAutoLock(void) {
         mLock->Unlock();
     }
  
 private:
     MutexAutoLock();
     MutexAutoLock(MutexAutoLock&);
     MutexAutoLock& operator=(MutexAutoLock&);
     static void* operator new(size_t) CPP_THROW_NEW;
     static void operator delete(void*);
 
     mozilla::Mutex* mLock;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 
 /**
  * MutexAutoUnlock
  * Releases the Mutex when it enters scope, and re-acquires it when it leaves 
  * scope.
  *
  * MUCH PREFERRED to bare calls to Mutex.Unlock and Lock.
  */ 
 class NS_COM_GLUE NS_STACK_CLASS MutexAutoUnlock 
 {
 public:
-    MutexAutoUnlock(mozilla::Mutex& aLock) :
+    MutexAutoUnlock(mozilla::Mutex& aLock MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM) :
         mLock(&aLock)
     {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         NS_ASSERTION(mLock, "null lock");
         mLock->Unlock();
     }
 
     ~MutexAutoUnlock() 
     {
         mLock->Lock();
     }
@@ -220,15 +224,16 @@ public:
 private:
     MutexAutoUnlock();
     MutexAutoUnlock(MutexAutoUnlock&);
     MutexAutoUnlock& operator =(MutexAutoUnlock&);
     static void* operator new(size_t) CPP_THROW_NEW;
     static void operator delete(void*);
      
     mozilla::Mutex* mLock;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 
 } // namespace mozilla
 
 
 #endif // ifndef mozilla_Mutex_h
diff --git a/xpcom/glue/nsAutoLock.h b/xpcom/glue/nsAutoLock.h
--- a/xpcom/glue/nsAutoLock.h
+++ b/xpcom/glue/nsAutoLock.h
@@ -104,23 +104,24 @@
  */
 
 #ifndef nsAutoLock_h__
 #define nsAutoLock_h__
 
 #include "nscore.h"
 #include "prlock.h"
 #include "prlog.h"
+#include "mozilla/AutoRestore.h"
 
 /**
  * nsAutoLockBase
  * This is the base class for the stack-based locking objects.
  * Clients of derived classes need not play with this superclass.
  **/
-class NS_COM_GLUE nsAutoLockBase {
+class NS_COM_GLUE NS_STACK_CLASS nsAutoLockBase {
     friend class nsAutoUnlockBase;
 
 protected:
     nsAutoLockBase() {}
     enum nsAutoLockType {eAutoLock, eAutoMonitor, eAutoCMonitor};
 
 #ifdef DEBUG
     nsAutoLockBase(void* addr, nsAutoLockType type);
@@ -141,17 +142,17 @@ protected:
 #endif
 };
 
 /**
  * nsAutoUnlockBase
  * This is the base class for stack-based unlocking objects.
  * It unlocks locking objects based on nsAutoLockBase.
  **/
-class NS_COM_GLUE nsAutoUnlockBase {
+class NS_COM_GLUE NS_STACK_CLASS nsAutoUnlockBase {
 protected:
     nsAutoUnlockBase() {}
 
 #ifdef DEBUG
     nsAutoUnlockBase(void* addr);
     ~nsAutoUnlockBase();
 
     nsAutoLockBase* mLock;
@@ -160,20 +161,21 @@ protected:
     ~nsAutoUnlockBase() {}
 #endif
 };
 
 /** 
  * nsAutoLock
  * Stack-based locking object for PRLock.
  **/
-class NS_COM_GLUE nsAutoLock : public nsAutoLockBase {
+class NS_COM_GLUE NS_STACK_CLASS nsAutoLock : public nsAutoLockBase {
 private:
     PRLock* mLock;
     PRBool mLocked;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 
     // Not meant to be implemented. This makes it a compiler error to
     // construct or assign an nsAutoLock object incorrectly.
     nsAutoLock(void) {}
     nsAutoLock(nsAutoLock& /*aLock*/) {}
     nsAutoLock& operator =(nsAutoLock& /*aLock*/) {
         return *this;
     }
@@ -203,20 +205,21 @@ public:
     /**
      * Constructor
      * The constructor aquires the given lock.  The destructor
      * releases the lock.
      * 
      * @param aLock A valid PRLock* returned from the NSPR's 
      * PR_NewLock() function.
      **/
-    nsAutoLock(PRLock* aLock)
+    nsAutoLock(PRLock* aLock MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
         : nsAutoLockBase(aLock, eAutoLock),
           mLock(aLock),
           mLocked(PR_TRUE) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         PR_ASSERT(mLock);
 
         // This will assert deep in the bowels of NSPR if you attempt
         // to re-enter the lock.
         PR_Lock(mLock);
     }
     
     ~nsAutoLock(void) {
@@ -245,39 +248,41 @@ public:
      void unlock() {
         PR_ASSERT(mLocked);
         PR_Unlock(mLock);
         mLocked = PR_FALSE;
         Hide();
     }
 };
 
-class nsAutoUnlock : private nsAutoUnlockBase
+class NS_STACK_CLASS nsAutoUnlock : private nsAutoUnlockBase
 {
 private:
     PRLock *mLock;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
      
 public:
-    nsAutoUnlock(PRLock *lock) : 
+    nsAutoUnlock(PRLock *lock MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM) : 
         nsAutoUnlockBase(lock),
         mLock(lock)
     {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         PR_Unlock(mLock);
     }
 
     ~nsAutoUnlock() {
         PR_Lock(mLock);
     }
 };
 
 #include "prcmon.h"
 #include "nsError.h"
 #include "nsDebug.h"
 
-class NS_COM_GLUE nsAutoMonitor : public nsAutoLockBase {
+class NS_COM_GLUE NS_STACK_CLASS nsAutoMonitor : public nsAutoLockBase {
 public:
 
     /**
      * NewMonitor
      * Allocates a new PRMonitor for use with nsAutoMonitor.
      * @param name A (unique /be?) name which can reference this monitor
      * @returns nsnull if failure
      *          A valid PRMonitor* is successful while must be destroyed
@@ -290,20 +295,21 @@ public:
     /**
      * Constructor
      * The constructor locks the given monitor.  During destruction
      * the monitor will be unlocked.
      * 
      * @param mon A valid PRMonitor* returned from 
      *        nsAutoMonitor::NewMonitor().
      **/
-    nsAutoMonitor(PRMonitor* mon)
+    nsAutoMonitor(PRMonitor* mon MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
         : nsAutoLockBase((void*)mon, eAutoMonitor),
           mMonitor(mon), mLockCount(0)
     {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         NS_ASSERTION(mMonitor, "null monitor");
         if (mMonitor) {
             PR_EnterMonitor(mMonitor);
             mLockCount = 1;
         }
     }
 
     ~nsAutoMonitor() {
@@ -356,16 +362,17 @@ public:
     nsresult NotifyAll() {
         return PR_NotifyAll(mMonitor) == PR_SUCCESS
             ? NS_OK : NS_ERROR_FAILURE;
     }
 
 private:
     PRMonitor*  mMonitor;
     PRInt32     mLockCount;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 
     // Not meant to be implemented. This makes it a compiler error to
     // construct or assign an nsAutoLock object incorrectly.
     nsAutoMonitor(void) {}
     nsAutoMonitor(nsAutoMonitor& /*aMon*/) {}
     nsAutoMonitor& operator =(nsAutoMonitor& /*aMon*/) {
         return *this;
     }
@@ -381,22 +388,23 @@ private:
 ////////////////////////////////////////////////////////////////////////////////
 // Once again, this time with a cache...
 // (Using this avoids the need to allocate a PRMonitor, which may be useful when
 // a large number of objects of the same class need associated monitors.)
 
 #include "prcmon.h"
 #include "nsError.h"
 
-class NS_COM_GLUE nsAutoCMonitor : public nsAutoLockBase {
+class NS_COM_GLUE NS_STACK_CLASS nsAutoCMonitor : public nsAutoLockBase {
 public:
-    nsAutoCMonitor(void* lockObject)
+    nsAutoCMonitor(void* lockObject MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
         : nsAutoLockBase(lockObject, eAutoCMonitor),
           mLockObject(lockObject), mLockCount(0)
     {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         NS_ASSERTION(lockObject, "null lock object");
         PR_CEnterMonitor(mLockObject);
         mLockCount = 1;
     }
 
     ~nsAutoCMonitor() {
         if (mLockCount) {
 #ifdef DEBUG
@@ -423,16 +431,17 @@ public:
     nsresult NotifyAll() {
         return PR_CNotifyAll(mLockObject) == PR_SUCCESS
             ? NS_OK : NS_ERROR_FAILURE;
     }
 
 private:
     void*   mLockObject;
     PRInt32 mLockCount;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 
     // Not meant to be implemented. This makes it a compiler error to
     // construct or assign an nsAutoLock object incorrectly.
     nsAutoCMonitor(void) {}
     nsAutoCMonitor(nsAutoCMonitor& /*aMon*/) {}
     nsAutoCMonitor& operator =(nsAutoCMonitor& /*aMon*/) {
         return *this;
     }
