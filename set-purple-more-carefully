Don't set the purple bit when suspect calls are dropped on the floor.  b=385548

diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -835,7 +835,7 @@ struct nsCycleCollector
     nsCycleCollector();
     ~nsCycleCollector();
 
-    void Suspect(nsISupports *n, PRBool current = PR_FALSE);
+    PRBool Suspect(nsISupports *n, PRBool current = PR_FALSE);
     void Forget(nsISupports *n);
     void Allocated(void *n, size_t sz);
     void Freed(void *n);
@@ -1832,7 +1832,7 @@ nsCycleCollector_isScanSafe(nsISupports 
 }
 #endif
 
-void 
+PRBool
 nsCycleCollector::Suspect(nsISupports *n, PRBool current)
 {
     // Re-entering ::Suspect during collection used to be a fault, but
@@ -1840,20 +1840,20 @@ nsCycleCollector::Suspect(nsISupports *n
     // see some spurious refcount traffic here. 
 
     if (mScanInProgress)
-        return;
+        return PR_FALSE;
 
     NS_ASSERTION(nsCycleCollector_isScanSafe(n),
                  "suspected a non-scansafe pointer");
     NS_ASSERTION(NS_IsMainThread(), "trying to suspect from non-main thread");
 
     if (mParams.mDoNothing)
-        return;
+        return PR_FALSE;
 
 #ifdef DEBUG_CC
     mStats.mSuspectNode++;
 
     if (nsCycleCollector_shouldSuppress(n))
-        return;
+        return PR_FALSE;
 
 #ifndef __MINGW32__
     if (mParams.mHookMalloc)
@@ -1871,6 +1871,8 @@ nsCycleCollector::Suspect(nsISupports *n
         mBuf.Push(n);
     else
         mPurpleBuf.Put(n);
+
+    return PR_TRUE;
 }
 
 
@@ -2372,19 +2374,22 @@ nsCycleCollector_forgetRuntime(PRUint32 
 }
 
 
-void 
+PRBool
 nsCycleCollector_suspect(nsISupports *n)
 {
     if (sCollector)
-        sCollector->Suspect(n);
+        return sCollector->Suspect(n);
+    return PR_FALSE;
 }
 
 
 void 
 nsCycleCollector_suspectCurrent(nsISupports *n)
 {
-    if (sCollector)
-        sCollector->Suspect(n, PR_TRUE);
+    if (sCollector) {
+        PRBool res = sCollector->Suspect(n, PR_TRUE);
+        NS_ASSERTION(res, "suspectCurrent should not fail");
+    }
 }
 
 
diff --git a/xpcom/base/nsCycleCollector.h b/xpcom/base/nsCycleCollector.h
--- a/xpcom/base/nsCycleCollector.h
+++ b/xpcom/base/nsCycleCollector.h
@@ -51,7 +51,7 @@ struct nsCycleCollectionLanguageRuntime
     virtual nsCycleCollectionParticipant *ToParticipant(void *p) = 0;
 };
 
-NS_COM void nsCycleCollector_suspect(nsISupports *n);
+NS_COM PRBool nsCycleCollector_suspect(nsISupports *n);
 NS_COM void nsCycleCollector_suspectCurrent(nsISupports *n);
 NS_COM void nsCycleCollector_forget(nsISupports *n);
 nsresult nsCycleCollector_startup();
diff --git a/xpcom/glue/nsISupportsImpl.h b/xpcom/glue/nsISupportsImpl.h
--- a/xpcom/glue/nsISupportsImpl.h
+++ b/xpcom/glue/nsISupportsImpl.h
@@ -154,7 +154,8 @@ public:
     PRBool shouldBePurple = tmp > 1;
 
     if (NS_UNLIKELY(shouldBePurple && !purple)) {
-      nsCycleCollector_suspect(owner);
+      if (!nsCycleCollector_suspect(owner))
+        shouldBePurple = PR_FALSE;
     } else if (NS_UNLIKELY(tmp == 1 && purple)) {
       nsCycleCollector_forget(owner);
     }
