Add tests for code I'm going to change, and fix crash when running those tests.  (Bug 475215)  r+sr=bzbarsky

diff --git a/layout/style/nsCSSStyleRule.cpp b/layout/style/nsCSSStyleRule.cpp
--- a/layout/style/nsCSSStyleRule.cpp
+++ b/layout/style/nsCSSStyleRule.cpp
@@ -526,16 +526,21 @@ void nsCSSSelector::ToStringInternal(nsA
         wroteNamespace = PR_TRUE;
       }
     } else if (sheetNS->FindNameSpaceID(nsnull) == mNameSpace) {
       // We have the default namespace (possibly including the wildcard
       // namespace).  Do nothing.
       NS_ASSERTION(mNameSpace == kNameSpaceID_Unknown ||
                    CanBeNamespaced(aIsNegated),
                    "How did we end up with this namespace?");
+    } else if (mNameSpace == kNameSpaceID_None) {
+      NS_ASSERTION(CanBeNamespaced(aIsNegated),
+                   "How did we end up with this namespace?");
+      aString.Append(PRUnichar('|'));
+      wroteNamespace = PR_TRUE;
     } else if (mNameSpace != kNameSpaceID_Unknown) {
       NS_ASSERTION(CanBeNamespaced(aIsNegated),
                    "How did we end up with this namespace?");
       nsIAtom *prefixAtom = sheetNS->FindPrefix(mNameSpace);
       NS_ASSERTION(prefixAtom, "how'd we get a non-default namespace "
                    "without a prefix?");
       nsAutoString prefix;
       prefixAtom->ToString(prefix);
diff --git a/layout/style/test/test_selectors.html b/layout/style/test/test_selectors.html
--- a/layout/style/test/test_selectors.html
+++ b/layout/style/test/test_selectors.html
@@ -34,28 +34,32 @@ function run() {
 
     /*
      * selector: the selector to test
      * body_contents: what to set the body's innerHTML to
      * match_fn: a function that, given the document object into which
      *   body_contents has been inserted, produces an array of nodes that
      *   should match selector
      * notmatch_fn: likewise, but for nodes that should not match
+     * namespaces (optional): @namespace rules to be included in the sheet
      */
-    function test_selector_in_html(selector, body_contents, match_fn, notmatch_fn)
+    function test_selector_in_html(selector, body_contents, match_fn, notmatch_fn, namespaces)
     {
         var zi = ++gCounter;
         if (typeof(body_contents) == "string") {
             ifdoc.body.innerHTML = body_contents;
         } else {
             // It's a function.
             ifdoc.body.innerHTML = "";
             body_contents(ifdoc.body);
         }
-        style_text.data = selector + "{ z-index: " + zi + " }";
+        if (!namespaces) {
+            namespaces = "";
+        }
+        style_text.data = namespaces + selector + "{ z-index: " + zi + " }";
         var should_match = match_fn(ifdoc);
         var should_not_match = notmatch_fn(ifdoc);
         if (should_match.length + should_not_match.length == 0) {
             ok(false, "nothing to check");
         }
 
         for (var i = 0; i < should_match.length; ++i) {
             var e = should_match[i];
@@ -68,41 +72,54 @@ function run() {
                "element in " + body_contents + " did not match " + selector);
         }
 
         // Now, since we're here, may as well make sure serialization
         // works correctly.  It need not produce the exact same text,
         // but it should produce a selector that matches the same
         // elements.
         zi = ++gCounter;
-        var ser1 = style_text.parentNode.sheet.cssRules[0].selectorText;
-        style_text.data = ser1 + "{ z-index: " + zi + " }";
+        var idx = style_text.parentNode.sheet.cssRules.length - 1;
+        if (namespaces == "") {
+            is(idx, 0, "unexpected rule index");
+        }
+        var ser1 = style_text.parentNode.sheet.cssRules[idx].selectorText;
+        style_text.data = namespaces + ser1 + "{ z-index: " + zi + " }";
         for (var i = 0; i < should_match.length; ++i) {
             var e = should_match[i];
             is(ifwin.getComputedStyle(e, "").zIndex, zi,
                "element in " + body_contents + " matched " + ser1 +
                " which is the reserialization of " + selector);
         }
         for (var i = 0; i < should_not_match.length; ++i) {
             var e = should_not_match[i];
             is(ifwin.getComputedStyle(e, "").zIndex, "auto",
                "element in " + body_contents + " did not match " + ser1 +
                " which is the reserialization of " + selector);
         }
 
         // But when we serialize the serialized result, we should get
         // the same text.
-        var ser2 = style_text.parentNode.sheet.cssRules[0].selectorText;
+        var ser2 = style_text.parentNode.sheet.cssRules[idx].selectorText;
         is(ser2, ser1, "parse+serialize of selector \"" + selector +
                        "\" is idempotent");
 
         ifdoc.body.innerHTML = "";
         style_text.data = "";
     }
 
+    function should_serialize_to(selector, serialization)
+    {
+        style_text.data = selector + "{ z-index: 0 }";
+        is(style_text.parentNode.sheet.cssRules[0].selectorText,
+           serialization,
+           "selector '" + selector + "' should serialize to '" +
+             serialization + "'.");
+    }
+
     function test_parseable(selector)
     {
         var zi = ++gCounter;
         ifdoc.body.innerHTML = "<p></p>";
         style_text.data = "p, " + selector + "{ z-index: " + zi + " }";
         var should_match = ifdoc.getElementsByTagName("p")[0];
         is(ifwin.getComputedStyle(should_match, "").zIndex, zi,
            "selector " + selector + " was parsed");
@@ -454,16 +471,86 @@ function run() {
                           pdaset([2], [2], []));
     test_selector_in_html(":nth-of-type(2n-0)", mixed_elements,
                           pdaset([2], [2], []),
                           pdaset([1, 3, 4], [1], [1, 2]));
     test_selector_in_html(":nth-last-of-type(even)", mixed_elements,
                           pdaset([2], [1], []),
                           pdaset([1, 3, 4], [2], [1, 2]));
 
+    // Test greediness of descendant combinators.
+    var four_children="<div id='a'><div id='b'><div id='c'><div id='d'><\/div><\/div><\/div><\/div>";
+    test_selector_in_html("#a > div div", four_children,
+                          idset(["c", "d"]), idset(["a", "b"]));
+    test_selector_in_html("#a > #b div", four_children,
+                          idset(["c", "d"]), idset(["a", "b"]));
+    test_selector_in_html("#a div > div", four_children,
+                          idset(["c", "d"]), idset(["a", "b"]));
+    test_selector_in_html("#a #b > div", four_children,
+                          idset(["c"]), idset(["a", "b", "d"]));
+    test_selector_in_html("#a > #b div", four_children,
+                          idset(["c", "d"]), idset(["a", "b"]));
+    test_selector_in_html("#a #c > div", four_children,
+                          idset(["d"]), idset(["a", "b", "c"]));
+    test_selector_in_html("#a > #c div", four_children,
+                          idset([]), idset(["a", "b", "c", "d"]));
+
+    // Test serialization of pseudo-elements.
+    should_serialize_to("p:first-letter", "p:first-letter");
+    should_serialize_to("div>p:first-letter", "div > p:first-letter");
+    should_serialize_to("span +div:first-line", "span + div:first-line");
+
+    // Test default namespaces, including inside :not().
+    var html_default_ns = "@namespace url(http://www.w3.org/1999/xhtml);";
+    var html_ns = "@namespace html url(http://www.w3.org/1999/xhtml);";
+    var xul_default_ns = "@namespace url(http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul);";
+    var single_a = "<a id='a' href='data:text/plain,this_better_be_unvisited'></a>";
+    var set_single = idset(['a']);
+    var empty_set = idset([]);
+    test_selector_in_html("a", single_a, set_single, empty_set,
+                          html_default_ns);
+    test_selector_in_html("a", single_a, empty_set, set_single,
+                          xul_default_ns);
+    test_selector_in_html("*|a", single_a, set_single, empty_set,
+                          xul_default_ns);
+    test_selector_in_html("html|a", single_a, set_single, empty_set,
+                          xul_default_ns + html_ns);
+	// Type selectors inside :not() bring in default namespaces, but
+	// non-type selectors don't.
+    test_selector_in_html("*|a:not(*)", single_a, set_single, empty_set,
+                          xul_default_ns);
+    test_selector_in_html("*|a:not(a)", single_a, set_single, empty_set,
+                          xul_default_ns);
+    test_selector_in_html("*|a:not(*|*)", single_a, empty_set, set_single,
+                          xul_default_ns);
+    test_selector_in_html("*|a:not(*|a)", single_a, empty_set, set_single,
+                          xul_default_ns);
+    test_selector_in_html("*|a:not(:link)", single_a + "<a id='b'></a>",
+                          idset(["b"]), set_single,
+                          xul_default_ns);
+    test_selector_in_html("*|a:not(:visited)", single_a + "<a id='b'></a>",
+                          idset(["a", "b"]), empty_set,
+                          xul_default_ns);
+    test_selector_in_html("*|a:not(html|*)", single_a, empty_set, set_single,
+                          xul_default_ns + html_ns);
+    test_selector_in_html("*|a:not(html|a)", single_a, empty_set, set_single,
+                          xul_default_ns + html_ns);
+    test_selector_in_html("*|a:not(|*)", single_a, set_single, empty_set,
+                          xul_default_ns + html_ns);
+    test_selector_in_html("*|a:not(|a)", single_a, set_single, empty_set,
+                          xul_default_ns + html_ns);
+    test_selector_in_html("html|a:not(|*)", single_a, set_single, empty_set,
+                          xul_default_ns + html_ns);
+    test_selector_in_html("html|a:not(|a)", single_a, set_single, empty_set,
+                          xul_default_ns + html_ns);
+    test_selector_in_html("html|a:not(*|*)", single_a, empty_set, set_single,
+                          xul_default_ns + html_ns);
+    test_selector_in_html("html|a:not(*|a)", single_a, empty_set, set_single,
+                          xul_default_ns + html_ns);
+
     SimpleTest.finish();
 }
 
 </script>
 </pre>
 </body>
 </html>
 
