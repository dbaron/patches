From: L. David Baron <dbaron@dbaron.org>

Bug 1432341 - Draw column-rules with border-code in box-decoration-break: clone mode, rather than slice.

This fixes the bug.  The underlying problem was that we were hitting the
case where ConstructBorderRenderer sets aNeedsClip to true, but nothing
in the column-rule drawing path was honoring that.

(Choosing clone rather than slice may make a difference for dotted and
dashed column-rules, but I think the clone behavior is preferable.)

MozReview-Commit-ID: 7YYzyxYjhsV

diff --git a/layout/generic/nsColumnSetFrame.cpp b/layout/generic/nsColumnSetFrame.cpp
--- a/layout/generic/nsColumnSetFrame.cpp
+++ b/layout/generic/nsColumnSetFrame.cpp
@@ -269,16 +269,23 @@ nsColumnSetFrame::CreateBorderRenderers(
     skipSides |= mozilla::eSideBitsBottom;
   } else {
     border.SetBorderWidth(eSideLeft, ruleWidth);
     border.SetBorderStyle(eSideLeft, ruleStyle);
     border.mBorderLeftColor = StyleComplexColor::FromColor(ruleColor);
     skipSides |= mozilla::eSideBitsTopBottom;
     skipSides |= mozilla::eSideBitsRight;
   }
+  // If we use box-decoration-break: slice (the default), the border
+  // renderers will require clipping if we have continuations (see the
+  // aNeedsClip parameter to ConstructBorderRenderer in nsCSSRendering).
+  //
+  // Since it doesn't matter which box-decoration-break we use since
+  // we're only drawing borders (and not border-images), use 'clone'.
+  border.mBoxDecorationBreak = StyleBoxDecorationBreak::Clone;
 
   ForEachColumnRule([&]
                     (const nsRect& aLineRect)
                     {
                       // Assert that we're not drawing a border-image here; if we were, we
                       // couldn't ignore the ImgDrawResult that PaintBorderWithStyleBorder returns.
                       MOZ_ASSERT(border.mBorderImageSource.GetType() == eStyleImageType_Null);
 
diff --git a/layout/painting/nsCSSRendering.cpp b/layout/painting/nsCSSRendering.cpp
--- a/layout/painting/nsCSSRendering.cpp
+++ b/layout/painting/nsCSSRendering.cpp
@@ -831,21 +831,23 @@ ConstructBorderRenderer(nsPresContext* a
       // We're drawing borders around the joined continuation boxes so we need
       // to clip that to the slice that we want for this frame.
       *aNeedsClip = true;
     }
   } else {
     MOZ_ASSERT(joinedBorderArea.IsEqualEdges(aBorderArea),
                "Should use aBorderArea for box-decoration-break:clone");
     MOZ_ASSERT(aForFrame->GetSkipSides().IsEmpty() ||
-               IS_TRUE_OVERFLOW_CONTAINER(aForFrame),
+               IS_TRUE_OVERFLOW_CONTAINER(aForFrame) ||
+               aForFrame->IsColumnSetFrame(), // a little broader than column-rule
                "Should not skip sides for box-decoration-break:clone except "
                "::first-letter/line continuations or other frame types that "
                "don't have borders but those shouldn't reach this point. "
-               "Overflow containers do reach this point though.");
+               "Overflow containers do reach this point though, as does "
+               "column-rule drawing (which always involves a columnset).");
     border.ApplySkipSides(aSkipSides);
   }
 
   // Convert to dev pixels.
   nscoord oneDevPixel = aPresContext->DevPixelsToAppUnits(1);
   Rect joinedBorderAreaPx = NSRectToRect(joinedBorderArea, oneDevPixel);
   Float borderWidths[4] = { Float(border.top) / oneDevPixel,
                                    Float(border.right) / oneDevPixel,
