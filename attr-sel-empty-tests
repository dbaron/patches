From: Elika J. Etemad (fantasai) <fantasai@inkedblade.net>, Michael Ventnor <ventnor.bugzilla@yahoo.com.au>

Make empty string in ^= $= *= attribute selectors match nothing (and check for ~= although it already works).  (Bug 420245)  r+sr=dbaron (tests)

diff --git a/layout/style/test/test_selectors.html b/layout/style/test/test_selectors.html
--- a/layout/style/test/test_selectors.html
+++ b/layout/style/test/test_selectors.html
@@ -122,22 +122,99 @@ function run() {
         is(ifwin.getComputedStyle(should_not_match, "").zIndex, "auto",
            "selector " + selector + " was a parser error");
         is(ifwin.getComputedStyle(should_match, "").zIndex, zi2,
            "selector " + selector + " error was recovered from");
         ifdoc.body.innerHTML = "";
         style_text.data = "";
     }
 
+    // [attr= ] selector
+    test_parseable("[attr=\"x\"]");
+    test_parseable("[attr='x']");
+    test_parseable("[attr=x]");
+    test_parseable("[attr=\"\"]");
+    test_parseable("[attr=\"foo bar\"]");
+
+    test_balanced_unparseable("[attr=]");
+    test_balanced_unparseable("[attr=foo bar]");
+
+    // [attr$= ] selector
+    test_parseable("[attr$=\"x\"]");
+    test_parseable("[attr$='x']");
+    test_parseable("[attr$=x]");
+    test_parseable("[attr$=\"\"]");
+    test_parseable("[attr$=\"foo bar\"]");
+
+    test_balanced_unparseable("[attr$=]");
+    test_balanced_unparseable("[attr$=foo bar]");
+
+    // [attr~= ] selector
+    test_parseable("[attr~=\"x\"]");
+    test_parseable("[attr~='x']");
+    test_parseable("[attr~=x]");
+    test_parseable("[attr~=\"\"]");
+    test_parseable("[attr~=\"foo bar\"]");
+
+    test_balanced_unparseable("[attr~=]");
+    test_balanced_unparseable("[attr~=foo bar]");
+
+    // [attr^= ] selector
+    test_parseable("[attr^=\"x\"]");
+    test_parseable("[attr^='x']");
+    test_parseable("[attr^=x]");
+    test_parseable("[attr^=\"\"]");
+    test_parseable("[attr^=\"foo bar\"]");
+
+    test_balanced_unparseable("[attr^=]");
+    test_balanced_unparseable("[attr^=foo bar]");
+
+    // attr[*= ] selector
+    test_parseable("[attr*=\"x\"]");
+    test_parseable("[attr*='x']");
+    test_parseable("[attr*=x]");
+    test_parseable("[attr*=\"\"]");
+    test_parseable("[attr*=\"foo bar\"]");
+
+    test_balanced_unparseable("[attr*=]");
+    test_balanced_unparseable("[attr*=foo bar]");
+
+
     // Bug 420814
     test_selector_in_html(
         "div ~ div p",
         "<div></div><div><div><p>match</p></div></div>",
         function(doc) { return doc.getElementsByTagName("p"); },
         function(doc) { return []; }
+    );
+
+    // Bug 420245
+    test_selector_in_html(
+        "p[attr$=\"\"]",
+        "<p attr=\"foo\">This should not match</p>",
+        function(doc) { return []; },
+        function(doc) { return doc.getElementsByTagName("p"); }
+    );
+    test_selector_in_html(
+        "div + p[attr~=\"\"]",
+        "<div>Dummy</div><p attr=\"foo\">This should not match</p>",
+        function(doc) { return []; },
+        function(doc) { return doc.getElementsByTagName("p"); }
+    );
+    test_selector_in_html(
+        "div[attr^=\"\"]",
+        "<div attr=\"dummy1\">Dummy</div><div attr=\"dummy2\">Dummy</div>",
+        function(doc) { return []; },
+        function(doc) { return doc.getElementsByTagName("div"); }
+    );
+    test_selector_in_html(
+        "div[attr*=\"\"]",
+        "<div attr=\"dummy1\">Dummy</div><div attr=\"dummy2\">Dummy</div>",
+        function(doc) { return []; },
+        function(doc) { return doc.getElementsByTagName("div"); }
     );
 
     // :nth-child(), etc.
     // Follow the whitespace rules as proposed in
     // http://lists.w3.org/Archives/Public/www-style/2008Mar/0121.html
     test_balanced_unparseable(":nth-child()");
     test_balanced_unparseable(":nth-of-type( )");
     test_parseable(":nth-last-child( odd)");
