From: Ben Karel <eschew@gmail.com>

Fixup URIs in CSS style sheets during "Save Page As, Complete" by serializing the style sheets from our data structures and performing URI fixup on URIs in them.  (Bug 115107)

diff --git a/content/base/public/nsIDocumentEncoder.idl b/content/base/public/nsIDocumentEncoder.idl
--- a/content/base/public/nsIDocumentEncoder.idl
+++ b/content/base/public/nsIDocumentEncoder.idl
@@ -38,32 +38,41 @@
 
 #include "nsISupports.idl"
 
 interface nsIDOMDocument;
 interface nsIDOMRange;
 interface nsISelection;
 interface nsIDOMNode;
 interface nsIOutputStream;
+interface nsIURI;
 
-[scriptable, uuid(3c556e41-0f73-4e1d-b724-1474884fe2e3)]
-interface nsIDocumentEncoderNodeFixup : nsISupports
+[scriptable, uuid(24cf5707-3805-4b65-a85d-ea80f5665659)]
+interface nsIDocumentEncoderFixup : nsISupports
 {
   /**
    * Create a fixed up version of a node. This method is called before
    * each node in a document is about to be persisted. The implementor
    * may return a new node with fixed up attributes or null. If null is
    * returned the node should be used as-is.
    * @param aNode Node to fixup.
    * @param [OUT] aSerializeCloneKids True if the document encoder should
    * apply recursive serialization to the children of the fixed up node
    * instead of the children of the original node.
    * @return The resulting fixed up node.
    */
   nsIDOMNode fixupNode(in nsIDOMNode aNode, out boolean aSerializeCloneKids);
+  /**
+   * Determine better URI to use when persisting linked content.
+   * @param aURI URI to fixup.
+   * @param aMimeType A mime type to use as a suggestion for determining
+     the file extension to use when persisting aURI.
+   * @return A string to be serialized in place of aURI's spec.
+   */
+  AString fixupURI(in nsIURI aURI, in ACString aMimeType);
 };
 
 [scriptable, uuid(f85c5a20-258d-11db-a98b-0800200c9a66)]
 interface nsIDocumentEncoder : nsISupports
 {
   // Output methods flag bits. There are a frightening number of these,
   // because everyone wants something a little bit different
    
@@ -304,10 +313,10 @@ interface nsIDocumentEncoder : nsISuppor
    */
   AString encodeToStringWithContext( out AString aContextString,
                                      out AString aInfoString);
 
   /**
    * Set the fixup object associated with node persistence.
    * @param aFixup The fixup object.
    */
-  void setNodeFixup(in nsIDocumentEncoderNodeFixup aFixup);
+  void setNodeFixup(in nsIDocumentEncoderFixup aFixup);
 };
diff --git a/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp b/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp
--- a/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp
+++ b/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp
@@ -59,16 +59,17 @@
 #include "nsEscape.h"
 #include "nsUnicharUtils.h"
 #include "nsIStringEnumerator.h"
 #include "nsCRT.h"
 #include "nsSupportsArray.h"
 #include "nsInt64.h"
 #include "nsContentCID.h"
 #include "nsStreamUtils.h"
+#include "nsIConverterOutputStream.h"
 
 #include "nsCExternalHandlerService.h"
 
 #include "nsIURL.h"
 #include "nsIFileURL.h"
 #include "nsIDocument.h"
 #include "nsIDOMDocument.h"
 #include "nsIDOMXMLDocument.h"
@@ -104,16 +105,25 @@
 #include "nsIDOMHTMLInputElement.h"
 #include "nsIDOMHTMLEmbedElement.h"
 #include "nsIDOMHTMLObjectElement.h"
 #include "nsIDOMHTMLAppletElement.h"
 #include "nsIDOMHTMLOptionElement.h"
 #include "nsIDOMHTMLTextAreaElement.h"
 #include "nsIDOMHTMLDocument.h"
 #include "nsIDOMText.h"
+
+#include "nsIDOMHTMLStyleElement.h"
+#include "nsIStyleSheet.h"
+#include "nsIDOMCSSStyleSheet.h"
+#include "nsICSSStyleSheet.h"
+#include "nsIDOMLinkStyle.h"
+#include "nsIDOMStyleSheet.h"
+#include "nsIStyleSheetLinkingElement.h"
+
 #ifdef MOZ_SVG
 #include "nsIDOMSVGImageElement.h"
 #include "nsIDOMSVGScriptElement.h"
 #endif // MOZ_SVG
 
 #include "nsIImageLoadingContent.h"
 
 #include "ftpCore.h"
@@ -150,16 +160,19 @@ struct URIData
     PRPackedBool mDataPathIsRelative;
     PRPackedBool mNeedsFixup;
     nsString mFilename;
     nsString mSubFrameExt;
     nsCOMPtr<nsIURI> mFile;
     nsCOMPtr<nsIURI> mDataPath;
     nsCString mRelativePathToData;
     nsCString mCharset;
+    // mContents and mContentsType should be set together.
+    nsString mContents; // possibly pre-serialized file contents
+    nsCString mContentsType; // possibly a mime type, to get file extension
 };
 
 // Information about the output stream
 struct OutputData
 {
     nsCOMPtr<nsIURI> mFile;
     nsCOMPtr<nsIURI> mOriginalLocation;
     nsCOMPtr<nsIOutputStream> mStream;
@@ -236,16 +249,18 @@ nsWebBrowserPersist::nsWebBrowserPersist
     mStartSaving(PR_FALSE),
     mReplaceExisting(PR_TRUE),
     mSerializingOutput(PR_FALSE),
     mPersistFlags(kDefaultPersistFlags),
     mPersistResult(NS_OK),
     mWrapColumn(72),
     mEncodingFlags(0)
 {
+    mFixup = new nsEncoderFixup;
+    mFixup->mWebBrowserPersist = this;
 }
 
 nsWebBrowserPersist::~nsWebBrowserPersist()
 {
     Cleanup();
 }
 
 //*****************************************************************************
@@ -1681,19 +1696,16 @@ nsresult nsWebBrowserPersist::SaveDocume
                     mCurrentBaseURI->GetSpec(url);
                     localFileOS2->SetFileSource(url);
                 }
 #endif
             }
         }
 
         mCurrentThingsToPersist = oldThingsToPersist;
-        mCurrentDataPath = oldDataPath;
-        mCurrentDataPathIsRelative = oldDataPathIsRelative;
-        mCurrentRelativePathToData = oldCurrentRelativePathToData;
     }
     else
     {
         // Set the document base to ensure relative links still work
         SetDocumentBase(aDocument, mCurrentBaseURI);
 
         // Get the content type to save with
         nsXPIDLString realContentType;
@@ -1740,35 +1752,30 @@ nsresult nsWebBrowserPersist::SaveDocume
             rv = NS_ERROR_FAILURE;
             break;
         }
 
         mCurrentBaseURI = docData->mBaseURI;
         mCurrentCharset = docData->mCharset;
 
         // Save the document, fixing it up with the new URIs as we do
-        
-        nsEncoderNodeFixup *nodeFixup;
-        nodeFixup = new nsEncoderNodeFixup;
-        if (nodeFixup)
-            nodeFixup->mWebBrowserPersist = this;
 
         // Get the content type
         nsXPIDLString realContentType;
         GetDocEncoderContentType(docData->mDocument,
             !mContentType.IsEmpty() ? mContentType.get() : nsnull,
             getter_Copies(realContentType));
 
         nsCAutoString contentType; contentType.AssignWithConversion(realContentType.get());
         nsCAutoString charType; // Empty
 
         // Save the document, fixing up the links as it goes out
         rv = SaveDocumentWithFixup(
             docData->mDocument,
-            nodeFixup,
+            mFixup,
             docData->mFile,
             mReplaceExisting,
             contentType,
             charType,
             mEncodingFlags);
 
         if (NS_FAILED(rv))
             break;
@@ -1790,16 +1797,19 @@ nsresult nsWebBrowserPersist::SaveDocume
         }
     }
 
     if (!mSerializingOutput)
     {
         mDocList.Clear();
     }
 
+    // In case anything was queued for persisting from node/URI fixup...
+    rv = SaveGatheredURIs(nsnull);
+
     return rv;
 }
 
 void nsWebBrowserPersist::Cleanup()
 {
     mURIMap.Enumerate(EnumCleanupURIMap, this);
     mURIMap.Reset();
     mOutputMap.Enumerate(EnumCleanupOutputMap, this);
@@ -2174,16 +2184,30 @@ nsWebBrowserPersist::CalculateAndAppendF
     // Get the content type from the MIME service
     if (contentType.IsEmpty())
     {
         nsCOMPtr<nsIURI> uri;
         aChannel->GetOriginalURI(getter_AddRefs(uri));
         mMIMEService->GetTypeFromURI(uri, contentType);
     }
 
+    return AppendFileExt(contentType, aURI, aOriginalURIWithExtension);
+}
+
+nsresult
+nsWebBrowserPersist::AppendFileExt(nsACString& contentType, nsIURI *aURI, nsIURI *aOriginalURIWithExtension)
+{
+    nsresult rv;
+
+    if (!mMIMEService)
+    {
+        mMIMEService = do_GetService(NS_MIMESERVICE_CONTRACTID, &rv);
+        NS_ENSURE_TRUE(mMIMEService, NS_ERROR_FAILURE);
+    }
+
     // Append the extension onto the file
     if (!contentType.IsEmpty())
     {
         nsCOMPtr<nsIMIMEInfo> mimeInfo;
         mMIMEService->GetFromTypeAndExtension(
             contentType, EmptyCString(), getter_AddRefs(mimeInfo));
 
         nsCOMPtr<nsILocalFile> localFile;
@@ -2206,22 +2230,25 @@ nsWebBrowserPersist::CalculateAndAppendF
             }
 
             // Append the mime file extension
             nsCAutoString fileExt;
             if (!hasExtension)
             {
                 // Test if previous extension is acceptable
                 nsCOMPtr<nsIURL> oldurl(do_QueryInterface(aOriginalURIWithExtension));
-                NS_ENSURE_TRUE(oldurl, NS_ERROR_FAILURE);
-                oldurl->GetFileExtension(fileExt);
+                          
                 PRBool useOldExt = PR_FALSE;
-                if (!fileExt.IsEmpty())
-                {
-                    mimeInfo->ExtensionExists(fileExt, &useOldExt);
+                if (oldurl)
+                {
+                  oldurl->GetFileExtension(fileExt);
+                  if (!fileExt.IsEmpty())
+                  {
+                      mimeInfo->ExtensionExists(fileExt, &useOldExt);
+                  }
                 }
 
                 // can't use old extension so use primary extension
                 if (!useOldExt)
                 {
                     mimeInfo->GetPrimaryExtension(fileExt);
                 } 
 
@@ -2517,17 +2544,38 @@ nsWebBrowserPersist::EnumPersistURIs(nsH
 
     // Make a URI to save the data to
     nsCOMPtr<nsIURI> fileAsURI;
     rv = data->mDataPath->Clone(getter_AddRefs(fileAsURI));
     NS_ENSURE_SUCCESS(rv, PR_FALSE);
     rv = pthis->AppendPathToURI(fileAsURI, data->mFilename);
     NS_ENSURE_SUCCESS(rv, PR_FALSE);
 
-    rv = pthis->SaveURIInternal(uri, nsnull, nsnull, nsnull, nsnull, fileAsURI, PR_TRUE);
+    // Common case: no pre-serialized content, so persist by downloading from URL
+    if (data->mContents.IsEmpty())
+        rv = pthis->SaveURIInternal(uri, nsnull, nsnull, nsnull, nsnull, fileAsURI, PR_TRUE);
+    else {
+        // flush string to stream
+        nsCOMPtr<nsIOutputStream> outputStream;
+        rv = pthis->MakeOutputStream(fileAsURI, getter_AddRefs(outputStream));
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        nsCOMPtr<nsIConverterOutputStream> cos
+          = do_CreateInstance("@mozilla.org/intl/converter-output-stream;1", &rv);
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        rv = cos->Init(outputStream, nsnull, 0, 0);
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        PRBool wroteFullString = PR_FALSE;
+        cos->WriteString(data->mContents, &wroteFullString);
+        cos->Flush();
+        outputStream->Flush();
+        cos->Close();
+    }
     // if SaveURIInternal fails, then it will have called EndDownload,
     // which means that |aData| is no longer valid memory.  we MUST bail.
     NS_ENSURE_SUCCESS(rv, PR_FALSE);
 
     if (rv == NS_OK)
     {
         // Store the actual object because once it's persisted this
         // will be fixed up with the right file extension.
@@ -2831,22 +2879,19 @@ nsresult nsWebBrowserPersist::OnWalkDOMN
     if (nodeAsApplet)
     {
         // For an applet, relative URIs are resolved relative to the
         // codebase (which is resolved relative to the base URI).
         nsCOMPtr<nsIURI> oldBase = mCurrentBaseURI;
         nsAutoString codebase;
         nodeAsApplet->GetCodeBase(codebase);
         if (!codebase.IsEmpty()) {
-            nsCOMPtr<nsIURI> baseURI;
-            NS_NewURI(getter_AddRefs(baseURI), codebase,
-                      mCurrentCharset.get(), mCurrentBaseURI);
-            if (baseURI) {
+            nsCOMPtr<nsIURI> baseURI = ResolveSpec(codebase);
+            if (baseURI)
                 mCurrentBaseURI = baseURI;
-            }
         }
 
         URIData *archiveURIData = nsnull;
         StoreURIAttribute(aNode, "archive", PR_TRUE, &archiveURIData);
         // We only store 'code' locally if there is no 'archive',
         // otherwise we assume the archive file(s) contains it (bug 430283).
         if (!archiveURIData)
             StoreURIAttribute(aNode, "code");
@@ -2883,17 +2928,64 @@ nsresult nsWebBrowserPersist::OnWalkDOMN
                     ++current;
                 } while (current != end && !nsCRT::IsAsciiSpace(*current));
 
                 // Store the link for fix up if it says "stylesheet"
                 if (Substring(startWord, current)
                         .LowerCaseEqualsLiteral("stylesheet"))
                 {
                     StoreURIAttribute(aNode, "href");
-                    return NS_OK;
+                    
+                    // Instead of just (re-)downloading the linked file directly,
+                    // we want to let the link's stylesheet serialize itself
+                    // (with URI fixup from us) to a string.
+
+                    nsCOMPtr<nsIDOMLinkStyle> domlink = do_QueryInterface(aNode);
+                    if (!domlink) return NS_OK;
+
+                    nsCOMPtr<nsIDOMStyleSheet> domss;
+                    domlink->GetSheet(getter_AddRefs(domss));
+                    if (!domss) return NS_OK; // No DOM stylesheet means nothing to serialize 
+                    
+                    nsCOMPtr<nsICSSStyleSheet> ss = do_QueryInterface(domss);
+                    if (!ss) return NS_OK;
+
+                    // Set the node's file contents in the URI map
+                    nsAutoString href;
+                    nodeAsLink->GetHref(href);
+                    URIData *data = GetDataForURI(href);
+                    if (!data) return NS_OK;
+
+                    ss->Serialize(data->mContents, mFixup);
+
+                    // Literal type OK if we only serialize CSS stylesheets.
+                    // This MIME type will eventually be used to get the
+                    // right extension when we need a filename to return
+                    // to serialized content through FixupURI.
+                    data->mContentsType.AssignLiteral("text/css");
+
+                    // We won't get a chance to call FixupURI before we
+                    // persist the link (from SaveGatheredURIs) so instead,
+                    // since we know the proper file extension already,
+                    // we'll just append it by hand.
+                    // Yes, this is a hack, but it's easier than tearing
+                    // apart and rewriting all of webbrowserpersist...
+                    nsXPIDLString ext;
+                    GetExtensionForContentType(NS_LITERAL_STRING("text/css").get(),
+                                               getter_Copies(ext));
+                    // At this point, data->mFilename has no extension, and we
+                    // need it to have the right extension when it is persisted.
+                    // For downloaded content like images, the extension is
+                    // derived from the channel MIME type and added to the
+                    // filename when it is being downloaded.
+                    // We don't download stylesheets, we fix up their in-memory
+                    // representation and persist that; therefore, we need to
+                    // add the correct extension to the 
+                    data->mFilename.AppendLiteral(".");
+                    data->mFilename.Append(ext);
                 }
                 if (current == end)
                     break;
             }
         }
         return NS_OK;
     }
 
@@ -3193,22 +3285,19 @@ nsWebBrowserPersist::CloneNodeWithFixedU
             nsCOMPtr<nsIDOMHTMLAppletElement> newApplet =
                 do_QueryInterface(*aNodeOut);
             // For an applet, relative URIs are resolved relative to the
             // codebase (which is resolved relative to the base URI).
             nsCOMPtr<nsIURI> oldBase = mCurrentBaseURI;
             nsAutoString codebase;
             nodeAsApplet->GetCodeBase(codebase);
             if (!codebase.IsEmpty()) {
-                nsCOMPtr<nsIURI> baseURI;
-                NS_NewURI(getter_AddRefs(baseURI), codebase,
-                          mCurrentCharset.get(), mCurrentBaseURI);
-                if (baseURI) {
+                nsCOMPtr<nsIURI> baseURI = ResolveSpec(codebase);
+                if (baseURI)
                     mCurrentBaseURI = baseURI;
-                }
             }
             // Unset the codebase too, since we'll correctly relativize the
             // code and archive paths.
             newApplet->RemoveAttribute(NS_LITERAL_STRING("codebase"));
             FixupNodeAttribute(*aNodeOut, "code");
             FixupNodeAttribute(*aNodeOut, "archive");
             // restore the base URI we really want to have
             mCurrentBaseURI = oldBase;
@@ -3224,18 +3313,16 @@ nsWebBrowserPersist::CloneNodeWithFixedU
         {
             // First see if the link represents linked content
             rv = FixupNodeAttribute(*aNodeOut, "href");
             if (NS_FAILED(rv))
             {
                 // Perhaps this link is actually an anchor to related content
                 FixupAnchor(*aNodeOut);
             }
-            // TODO if "type" attribute == "text/css"
-            //        fixup stylesheet
         }
         return rv;
     }
 
     nsCOMPtr<nsIDOMHTMLFrameElement> nodeAsFrame = do_QueryInterface(aNodeIn);
     if (nodeAsFrame)
     {
         rv = GetNodeToFixup(aNodeIn, aNodeOut);
@@ -3325,32 +3412,56 @@ nsWebBrowserPersist::CloneNodeWithFixedU
             nsCOMPtr<nsIDOMHTMLOptionElement> outElt = do_QueryInterface(*aNodeOut);
             PRBool selected;
             nodeAsOption->GetSelected(&selected);
             outElt->SetDefaultSelected(selected);
         }
         return rv;
     }
 
+    nsCOMPtr<nsIDOMHTMLStyleElement> nodeAsStyle = do_QueryInterface(aNodeIn);
+    if (nodeAsStyle)
+    {
+        rv = GetNodeToFixup(aNodeIn, aNodeOut);
+        if (NS_SUCCEEDED(rv) && *aNodeOut)
+        {
+            // Tell the document encoder to serialize the text child we create below
+            *aSerializeCloneKids = PR_TRUE;
+
+            nsCOMPtr<nsIDOMLinkStyle> domlink(do_QueryInterface(aNodeIn));
+            nsCOMPtr<nsIDOMStyleSheet> domss;
+            if (!domlink)
+              return NS_OK;
+            domlink->GetSheet(getter_AddRefs(domss));
+            nsCOMPtr<nsICSSStyleSheet> ss(do_QueryInterface(domss));
+       
+            nsAutoString content;
+            ss->Serialize(content, mFixup);
+
+            nsCOMPtr<nsIDOM3Node> out = do_QueryInterface(*aNodeOut);
+            if (!out)
+              return NS_ERROR_FAILURE;
+            out->SetTextContent(content);
+        }
+    }
+
     return NS_OK;
 }
 
 nsresult
 nsWebBrowserPersist::StoreURI(
     const char *aURI, PRBool aNeedsPersisting, URIData **aData)
 {
     NS_ENSURE_ARG_POINTER(aURI);
 
     nsCOMPtr<nsIURI> uri;
     nsresult rv = NS_NewURI(getter_AddRefs(uri),
                             nsDependentCString(aURI),
                             mCurrentCharset.get(),
                             mCurrentBaseURI);
-    NS_ENSURE_SUCCESS(rv, rv);
-
     return StoreURI(uri, aNeedsPersisting, aData);
 }
 
 nsresult
 nsWebBrowserPersist::StoreURI(
     nsIURI *aURI, PRBool aNeedsPersisting, URIData **aData)
 {
     NS_ENSURE_ARG_POINTER(aURI);
@@ -3416,87 +3527,121 @@ nsWebBrowserPersist::StoreURIAttributeNS
             NS_ConvertUTF16toUTF8 oldCValue(oldValue);
             return StoreURI(oldCValue.get(), aNeedsPersisting, aData);
         }
     }
 
     return NS_OK;
 }
 
-nsresult
-nsWebBrowserPersist::FixupURI(nsAString &aURI)
+already_AddRefed<nsIURI>
+nsWebBrowserPersist::ResolveSpec(nsAString& aSpec)
+{
+    nsIURI *result = nsnull;
+    nsresult rv = NS_NewURI(&result, aSpec, 
+                            mCurrentCharset.get(), mCurrentBaseURI);
+    return result;
+}
+
+URIData*
+nsWebBrowserPersist::GetDataForURI(nsAString &aURI)
 {
     // get the current location of the file (absolutized)
-    nsCOMPtr<nsIURI> uri;
-    nsresult rv = NS_NewURI(getter_AddRefs(uri), aURI, 
-                            mCurrentCharset.get(), mCurrentBaseURI);
-    NS_ENSURE_SUCCESS(rv, rv);
+    nsCOMPtr<nsIURI> uri = ResolveSpec(aURI);
+    return GetDataForURI(uri);
+}
+
+URIData*
+nsWebBrowserPersist::GetDataForURI(nsIURI* aURI)
+{
     nsCAutoString spec;
-    rv = uri->GetSpec(spec);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    // Search for the URI in the map and replace it with the local file
+    nsresult rv = aURI->GetSpec(spec);
+    NS_ENSURE_SUCCESS(rv, nsnull);
+
     nsCStringKey key(spec.get());
     if (!mURIMap.Exists(&key))
     {
-        return NS_ERROR_FAILURE;
-    }
-    URIData *data = (URIData *) mURIMap.Get(&key);
-    if (!data->mNeedsFixup)
-    {
-        return NS_OK;
-    }
-    nsCOMPtr<nsIURI> fileAsURI;
-    if (data->mFile)
-    {
-        rv = data->mFile->Clone(getter_AddRefs(fileAsURI)); 
-        NS_ENSURE_SUCCESS(rv, rv);
-    }
-    else
-    {
-        rv = data->mDataPath->Clone(getter_AddRefs(fileAsURI));
-        NS_ENSURE_SUCCESS(rv, rv);
-        rv = AppendPathToURI(fileAsURI, data->mFilename);
-        NS_ENSURE_SUCCESS(rv, rv);
+        return nsnull;
+    }
+    return (URIData *) mURIMap.Get(&key);
+}
+
+nsresult
+nsWebBrowserPersist::FixupURI(nsAString &aSpec)
+{
+    URIData *data = GetDataForURI(aSpec);
+    return FixupURIData(data, nsnull, aSpec);
+}
+
+nsresult
+nsWebBrowserPersist::FixupURIData(URIData *aData, nsIURI *aOriginalURI, nsAString &aSpec)
+{
+    nsresult rv;
+
+    if (!aData)
+        return NS_ERROR_FAILURE;
+
+    if (!aData->mNeedsFixup)
+        return NS_OK;
+
+    // Replace the URI from the map with the local file
+    nsCOMPtr<nsIURI> fileAsURI;
+    if (aData->mFile)
+    {
+        rv = aData->mFile->Clone(getter_AddRefs(fileAsURI)); 
+        NS_ENSURE_SUCCESS(rv, rv);
+    }
+    else
+    {
+        rv = aData->mDataPath->Clone(getter_AddRefs(fileAsURI));
+        NS_ENSURE_SUCCESS(rv, rv);
+        rv = AppendPathToURI(fileAsURI, aData->mFilename);
+        NS_ENSURE_SUCCESS(rv, rv);
+        // This doesn't affect the the downloaded file name, it only affects the
+        // out string
+        if (!aData->mContentsType.IsEmpty()) {
+          rv = AppendFileExt(aData->mContentsType, fileAsURI, aOriginalURI);
+          NS_ENSURE_SUCCESS(rv, rv);
+        }
     }
     nsAutoString newValue;
 
     // remove username/password if present
     fileAsURI->SetUserPass(EmptyCString());
 
     // reset node attribute 
     // Use relative or absolute links
-    if (data->mDataPathIsRelative)
+    if (aData->mDataPathIsRelative)
     {
         nsCOMPtr<nsIURL> url(do_QueryInterface(fileAsURI));
         if (!url)
           return NS_ERROR_FAILURE;
           
         nsCAutoString filename;
         url->GetFileName(filename);
 
-        nsCAutoString rawPathURL(data->mRelativePathToData);
+        nsCAutoString rawPathURL(aData->mRelativePathToData);
         rawPathURL.Append(filename);
 
         nsCAutoString buf;
         AppendUTF8toUTF16(NS_EscapeURL(rawPathURL, esc_FilePath, buf),
                           newValue);
     }
     else
     {
         nsCAutoString fileurl;
         fileAsURI->GetSpec(fileurl);
         AppendUTF8toUTF16(fileurl, newValue);
     }
-    if (data->mIsSubFrame)
-    {
-        newValue.Append(data->mSubFrameExt);
-    }
-
-    aURI = newValue;
+    if (aData->mIsSubFrame)
+    {
+        newValue.Append(aData->mSubFrameExt);
+    }
+
+    aSpec = newValue;
     return NS_OK;
 }
 
 nsresult
 nsWebBrowserPersist::FixupNodeAttributeNS(nsIDOMNode *aNode,
                                         const char *aNamespaceURI,
                                         const char *aAttribute)
 {
@@ -3520,16 +3665,18 @@ nsWebBrowserPersist::FixupNodeAttributeN
     if (attrNode)
     {
         nsString uri;
         attrNode->GetNodeValue(uri);
         rv = FixupURI(uri);
         if (NS_SUCCEEDED(rv))
         {
             attrNode->SetNodeValue(uri);
+        } else {
+            attrNode = nsnull; // URI not in map?
         }
     }
 
     return rv;
 }
 
 nsresult
 nsWebBrowserPersist::FixupAnchor(nsIDOMNode *aNode)
@@ -3722,17 +3869,17 @@ nsWebBrowserPersist::CreateChannelFromUR
 
     rv = (*aChannel)->SetNotificationCallbacks(static_cast<nsIInterfaceRequestor *>(this));
     NS_ENSURE_SUCCESS(rv, rv);
     return NS_OK;
 } 
 
 nsresult
 nsWebBrowserPersist::SaveDocumentWithFixup(
-    nsIDOMDocument *aDocument, nsIDocumentEncoderNodeFixup *aNodeFixup,
+    nsIDOMDocument *aDocument, nsIDocumentEncoderFixup *aNodeFixup,
     nsIURI *aFile, PRBool aReplaceExisting, const nsACString &aFormatType,
     const nsCString &aSaveCharset, PRUint32 aFlags)
 {
     NS_ENSURE_ARG_POINTER(aFile);
     
     nsresult  rv = NS_OK;
     nsCOMPtr<nsILocalFile> localFile;
     GetLocalFileFromURI(aFile, getter_AddRefs(localFile));
@@ -3851,25 +3998,30 @@ nsWebBrowserPersist::MakeAndStoreLocalFi
     nsString filename;
     rv = MakeFilenameFromURI(aURI, filename);
     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
 
     // Store the file name
     data = new URIData;
     NS_ENSURE_TRUE(data, NS_ERROR_OUT_OF_MEMORY);
 
+    nsString contents;
+    nsCString contentsType;
+
     data->mNeedsPersisting = aNeedsPersisting;
     data->mNeedsFixup = PR_TRUE;
     data->mFilename = filename;
     data->mSaved = PR_FALSE;
     data->mIsSubFrame = PR_FALSE;
     data->mDataPath = mCurrentDataPath;
     data->mDataPathIsRelative = mCurrentDataPathIsRelative;
     data->mRelativePathToData = mCurrentRelativePathToData;
     data->mCharset = mCurrentCharset;
+    data->mContents = contents;
+    data->mContentsType = contentsType;
 
     if (aNeedsPersisting)
         mCurrentThingsToPersist++;
 
     mURIMap.Put(&key, data);
     if (aData)
     {
         *aData = data;
@@ -4137,37 +4289,28 @@ void nsWebBrowserPersist::SetApplyConver
                 encChannel->SetApplyConversion(applyConversion);
         }
     }
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 
 
-nsEncoderNodeFixup::nsEncoderNodeFixup() : mWebBrowserPersist(nsnull)
-{
-}
-
-
-nsEncoderNodeFixup::~nsEncoderNodeFixup()
-{
-}
-
-
-NS_IMPL_ADDREF(nsEncoderNodeFixup)
-NS_IMPL_RELEASE(nsEncoderNodeFixup)
-
-
-NS_INTERFACE_MAP_BEGIN(nsEncoderNodeFixup)
-    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDocumentEncoderNodeFixup)
-    NS_INTERFACE_MAP_ENTRY(nsIDocumentEncoderNodeFixup)
-NS_INTERFACE_MAP_END
-
-
-NS_IMETHODIMP nsEncoderNodeFixup::FixupNode(
+nsEncoderFixup::nsEncoderFixup() : mWebBrowserPersist(nsnull)
+{
+}
+
+
+nsEncoderFixup::~nsEncoderFixup()
+{
+}
+
+NS_IMPL_ISUPPORTS1(nsEncoderFixup, nsIDocumentEncoderFixup)
+
+NS_IMETHODIMP nsEncoderFixup::FixupNode(
     nsIDOMNode *aNode, PRBool *aSerializeCloneKids, nsIDOMNode **aOutNode)
 {
     NS_ENSURE_ARG_POINTER(aNode);
     NS_ENSURE_ARG_POINTER(aOutNode);
     NS_ENSURE_TRUE(mWebBrowserPersist, NS_ERROR_FAILURE);
 
     *aOutNode = nsnull;
     
@@ -4177,8 +4320,18 @@ NS_IMETHODIMP nsEncoderNodeFixup::FixupN
     if (type == nsIDOMNode::ELEMENT_NODE ||
         type == nsIDOMNode::PROCESSING_INSTRUCTION_NODE)
     {
         return mWebBrowserPersist->CloneNodeWithFixedUpAttributes(aNode, aSerializeCloneKids, aOutNode);
     }
 
     return NS_OK;
 }
+
+NS_IMETHODIMP
+nsEncoderFixup::FixupURI(nsIURI *aURI, const nsACString& aMimeType,
+                         nsAString& aSpec)
+{
+    URIData *data;
+    mWebBrowserPersist->StoreURI(aURI, PR_TRUE, &data);
+    data->mContentsType.Assign(aMimeType);
+    return mWebBrowserPersist->FixupURIData(data, aURI, aSpec);
+}
diff --git a/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.h b/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.h
--- a/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.h
+++ b/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.h
@@ -57,30 +57,30 @@
 #include "nsIWebProgressListener2.h"
 
 #include "nsHashtable.h"
 #include "nsTArray.h"
 #include "nsInt64.h"
 
 #include "nsCWebBrowserPersist.h"
 
-class nsEncoderNodeFixup;
+class nsEncoderFixup;
 class nsIStorageStream;
 
 struct URIData;
 struct CleanupData;
 struct DocData;
 
 class nsWebBrowserPersist : public nsIInterfaceRequestor,
                             public nsIWebBrowserPersist,
                             public nsIStreamListener,
                             public nsIProgressEventSink,
                             public nsSupportsWeakReference
 {
-    friend class nsEncoderNodeFixup;
+    friend class nsEncoderFixup;
 
 // Public members
 public:
     nsWebBrowserPersist();
     
     NS_DECL_ISUPPORTS
     NS_DECL_NSIINTERFACEREQUESTOR
     NS_DECL_NSICANCELABLE
@@ -124,16 +124,18 @@ private:
     nsresult MakeOutputStreamFromFile(
         nsILocalFile *aFile, nsIOutputStream **aOutputStream);
     nsresult MakeOutputStreamFromURI(nsIURI *aURI, nsIOutputStream  **aOutStream);
     nsresult CreateChannelFromURI(nsIURI *aURI, nsIChannel **aChannel);
     nsresult StartUpload(nsIStorageStream *aOutStream, nsIURI *aDestinationURI,
         const nsACString &aContentType);
     nsresult CalculateAndAppendFileExt(nsIURI *aURI, nsIChannel *aChannel,
         nsIURI *aOriginalURIWithExtension);
+    nsresult AppendFileExt(nsACString& contentType, nsIURI *aURI,
+        nsIURI *aOriginalURIWithExtension);
     nsresult CalculateUniqueFilename(nsIURI *aURI);
     nsresult MakeFilenameFromURI(
         nsIURI *aURI, nsString &aFilename);
     nsresult StoreURI(
         const char *aURI,
         PRBool aNeedsPersisting = PR_TRUE,
         URIData **aData = nsnull);
     nsresult StoreURI(
@@ -151,29 +153,33 @@ private:
     {
         return StoreURIAttributeNS(aNode, "", aAttribute, aNeedsPersisting, aData);
     }
     PRBool GetQuotedAttributeValue(
     const nsAString &aSource, const nsAString &aAttribute, nsAString &aValue);
     PRBool DocumentEncoderExists(const PRUnichar *aContentType);
 
     nsresult GetNodeToFixup(nsIDOMNode *aNodeIn, nsIDOMNode **aNodeOut);
+    already_AddRefed<nsIURI> ResolveSpec(nsAString& aSpec);
+    URIData* GetDataForURI(nsAString &aURI);
+    URIData* GetDataForURI(nsIURI* aURI);
     nsresult FixupURI(nsAString &aURI);
+    nsresult FixupURIData(URIData *aData, nsIURI *aOriginalURI, nsAString &aSpec);
     nsresult FixupNodeAttributeNS(nsIDOMNode *aNode, const char *aNamespaceURI, const char *aAttribute);
     nsresult FixupNodeAttribute(nsIDOMNode *aNode, const char *aAttribute)
     {
         return FixupNodeAttributeNS(aNode, "", aAttribute);
     }
     nsresult FixupAnchor(nsIDOMNode *aNode);
     nsresult FixupXMLStyleSheetLink(nsIDOMProcessingInstruction *aPI, const nsAString &aHref);
     nsresult GetXMLStyleSheetLink(nsIDOMProcessingInstruction *aPI, nsAString &aHref);
 
     nsresult StoreAndFixupStyleSheet(nsIStyleSheet *aStyleSheet);
     nsresult SaveDocumentWithFixup(
-        nsIDOMDocument *pDocument, nsIDocumentEncoderNodeFixup *pFixup,
+        nsIDOMDocument *pDocument, nsIDocumentEncoderFixup *pFixup,
         nsIURI *aFile, PRBool aReplaceExisting, const nsACString &aFormatType,
         const nsCString &aSaveCharset, PRUint32  aFlags);
     nsresult SaveSubframeContent(
         nsIDOMDocument *aFrameContent, URIData *aData);
     nsresult SetDocumentBase(nsIDOMDocument *aDocument, nsIURI *aBaseURI);
     nsresult SendErrorStatusChange(
         PRBool aIsReadError, nsresult aResult, nsIRequest *aRequest, nsIURI *aURI);
     nsresult OnWalkDOMNode(nsIDOMNode *aNode);
@@ -238,26 +244,27 @@ private:
     PRPackedBool              mSerializingOutput;
     PRUint32                  mPersistFlags;
     PRUint32                  mPersistResult;
     nsInt64                   mTotalCurrentProgress;
     nsInt64                   mTotalMaxProgress;
     PRInt16                   mWrapColumn;
     PRUint32                  mEncodingFlags;
     nsString                  mContentType;
+    nsRefPtr<nsEncoderFixup>  mFixup;
 };
 
 // Helper class does node fixup during persistence
-class nsEncoderNodeFixup : public nsIDocumentEncoderNodeFixup
+class nsEncoderFixup : public nsIDocumentEncoderFixup
 {
 public:
-    nsEncoderNodeFixup();
+    nsEncoderFixup();
     
     NS_DECL_ISUPPORTS
-    NS_IMETHOD FixupNode(nsIDOMNode *aNode, PRBool *aSerializeCloneKids, nsIDOMNode **aOutNode);
+    NS_DECL_NSIDOCUMENTENCODERFIXUP
     
     nsWebBrowserPersist *mWebBrowserPersist;
 
 protected:    
-    virtual ~nsEncoderNodeFixup();
+    virtual ~nsEncoderFixup();
 };
 
 #endif
diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -49,18 +49,20 @@
 #include "nsIAtom.h"
 #include "nsUnicharUtils.h"
 #include "nsReadableUtils.h"
 #include "nsCRT.h"
 #include "nsCSSProps.h"
 #include "nsFont.h"
 #include "nsReadableUtils.h"
 #include "nsStyleUtil.h"
+#include "imgIRequest.h"
 
 #include "nsStyleConsts.h"
+#include "nsIDocumentEncoder.h"
 
 #include "nsCOMPtr.h"
 
 nsCSSDeclaration::nsCSSDeclaration() 
   : mData(nsnull),
     mImportantData(nsnull)
 {
   // check that we can fit all the CSS properties into a PRUint8
@@ -124,101 +126,103 @@ nsCSSDeclaration::RemoveProperty(nsCSSPr
 }
 
 nsresult
 nsCSSDeclaration::AppendComment(const nsAString& aComment)
 {
   return /* NS_ERROR_NOT_IMPLEMENTED, or not any longer that is */ NS_OK;
 }
 
-PRBool nsCSSDeclaration::AppendValueToString(nsCSSProperty aProperty, nsAString& aResult) const
+PRBool nsCSSDeclaration::AppendValueToString(nsCSSProperty aProperty,
+                                             nsIDocumentEncoderFixup *aFixup,
+                                             nsAString& aResult) const
 {
   nsCSSCompressedDataBlock *data = GetValueIsImportant(aProperty)
                                       ? mImportantData : mData;
   const void *storage = data->StorageFor(aProperty);
   if (storage) {
     switch (nsCSSProps::kTypeTable[aProperty]) {
       case eCSSType_Value: {
         const nsCSSValue *val = static_cast<const nsCSSValue*>(storage);
-        AppendCSSValueToString(aProperty, *val, aResult);
+        AppendCSSValueToString(aProperty, *val, aFixup, aResult);
       } break;
       case eCSSType_Rect: {
         const nsCSSRect *rect = static_cast<const nsCSSRect*>(storage);
         const nsCSSUnit topUnit = rect->mTop.GetUnit();
         if (topUnit == eCSSUnit_Inherit ||
             topUnit == eCSSUnit_Initial ||
             topUnit == eCSSUnit_RectIsAuto) {
           NS_ASSERTION(rect->mRight.GetUnit() == topUnit &&
                        rect->mBottom.GetUnit() == topUnit &&
                        rect->mLeft.GetUnit() == topUnit,
                        "parser should make all sides have the same unit");
           if (topUnit == eCSSUnit_RectIsAuto)
             aResult.AppendLiteral("auto");
           else
-            AppendCSSValueToString(aProperty, rect->mTop, aResult);
+            AppendCSSValueToString(aProperty, rect->mTop, aFixup, aResult);
         } else {
           aResult.AppendLiteral("rect(");
-          AppendCSSValueToString(aProperty, rect->mTop, aResult);
+          AppendCSSValueToString(aProperty, rect->mTop, aFixup, aResult);
           NS_NAMED_LITERAL_STRING(comma, ", ");
           aResult.Append(comma);
-          AppendCSSValueToString(aProperty, rect->mRight, aResult);
+          AppendCSSValueToString(aProperty, rect->mRight, aFixup, aResult);
           aResult.Append(comma);
-          AppendCSSValueToString(aProperty, rect->mBottom, aResult);
+          AppendCSSValueToString(aProperty, rect->mBottom, aFixup, aResult);
           aResult.Append(comma);
-          AppendCSSValueToString(aProperty, rect->mLeft, aResult);
+          AppendCSSValueToString(aProperty, rect->mLeft, aFixup, aResult);
           aResult.Append(PRUnichar(')'));
         }
       } break;
       case eCSSType_ValuePair: {
         const nsCSSValuePair *pair = static_cast<const nsCSSValuePair*>(storage);
-        AppendCSSValueToString(aProperty, pair->mXValue, aResult);
+        AppendCSSValueToString(aProperty, pair->mXValue, aFixup, aResult);
         if (pair->mYValue != pair->mXValue ||
             ((aProperty == eCSSProperty_background_position ||
               aProperty == eCSSProperty__moz_transform_origin) &&
              pair->mXValue.GetUnit() != eCSSUnit_Inherit &&
              pair->mXValue.GetUnit() != eCSSUnit_Initial) ||
             (aProperty == eCSSProperty__moz_background_size &&
              pair->mXValue.GetUnit() != eCSSUnit_Inherit &&
              pair->mXValue.GetUnit() != eCSSUnit_Initial &&
              pair->mXValue.GetUnit() != eCSSUnit_Enumerated)) {
           // Only output a Y value if it's different from the X value,
           // or if it's a background-position value other than 'initial'
           // or 'inherit', or if it's a -moz-transform-origin value other
           // than 'initial' or 'inherit', or if it's a -moz-background-size
           // value other than 'initial' or 'inherit' or 'contain' or 'cover'.
           aResult.Append(PRUnichar(' '));
-          AppendCSSValueToString(aProperty, pair->mYValue, aResult);
+          AppendCSSValueToString(aProperty, pair->mYValue, aFixup, aResult);
         }
       } break;
       case eCSSType_ValueList: {
         const nsCSSValueList* val =
             *static_cast<nsCSSValueList*const*>(storage);
         do {
-          AppendCSSValueToString(aProperty, val->mValue, aResult);
+          AppendCSSValueToString(aProperty, val->mValue, aFixup, aResult);
           val = val->mNext;
           if (val) {
             if (nsCSSProps::PropHasFlags(aProperty,
                                          CSS_PROPERTY_VALUE_LIST_USES_COMMAS))
               aResult.Append(PRUnichar(','));
             aResult.Append(PRUnichar(' '));
           }
         } while (val);
       } break;
       case eCSSType_ValuePairList: {
         const nsCSSValuePairList* item =
             *static_cast<nsCSSValuePairList*const*>(storage);
         do {
           NS_ASSERTION(item->mXValue.GetUnit() != eCSSUnit_Null,
                        "unexpected null unit");
-          AppendCSSValueToString(aProperty, item->mXValue, aResult);
+          AppendCSSValueToString(aProperty, item->mXValue, aFixup, aResult);
           if (item->mXValue.GetUnit() != eCSSUnit_Inherit &&
               item->mXValue.GetUnit() != eCSSUnit_Initial &&
               item->mYValue.GetUnit() != eCSSUnit_Null) {
             aResult.Append(PRUnichar(' '));
-            AppendCSSValueToString(aProperty, item->mYValue, aResult);
+            AppendCSSValueToString(aProperty, item->mYValue, aFixup, aResult);
           }
           item = item->mNext;
           if (item) {
             if (nsCSSProps::PropHasFlags(aProperty,
                                          CSS_PROPERTY_VALUE_LIST_USES_COMMAS))
               aResult.Append(PRUnichar(','));
             aResult.Append(PRUnichar(' '));
           }
@@ -227,16 +231,17 @@ PRBool nsCSSDeclaration::AppendValueToSt
     }
   }
   return storage != nsnull;
 }
 
 /* static */ PRBool
 nsCSSDeclaration::AppendCSSValueToString(nsCSSProperty aProperty,
                                          const nsCSSValue& aValue,
+                                         nsIDocumentEncoderFixup *aFixup,
                                          nsAString& aResult)
 {
   nsCSSUnit unit = aValue.GetUnit();
 
   if (eCSSUnit_Null == unit) {
     return PR_FALSE;
   }
 
@@ -275,35 +280,35 @@ nsCSSDeclaration::AppendCSSValueToString
           aResult.AppendLiteral(" ");
         else
           aResult.AppendLiteral(", ");
       }
       nsCSSProperty prop =
         ((eCSSUnit_Counter <= unit && unit <= eCSSUnit_Counters) &&
          i == array->Count() - 1)
         ? eCSSProperty_list_style_type : aProperty;
-      if (AppendCSSValueToString(prop, array->Item(i), aResult)) {
+      if (AppendCSSValueToString(prop, array->Item(i), aFixup, aResult)) {
         mark = PR_TRUE;
       }
     }
   }
   /* Although Function is backed by an Array, we'll handle it separately
    * because it's a bit quirky.
    */
   else if (eCSSUnit_Function == unit) {
     const nsCSSValue::Array* array = aValue.GetArrayValue();
     NS_ASSERTION(array->Count() >= 1, "Functions must have at least one element for the name.");
 
     /* Append the function name. */
-    AppendCSSValueToString(aProperty, array->Item(0), aResult);
+    AppendCSSValueToString(aProperty, array->Item(0), aFixup, aResult);
     aResult.AppendLiteral("(");
 
     /* Now, step through the function contents, writing each of them as we go. */
     for (PRUint16 index = 1; index < array->Count(); ++index) {
-      AppendCSSValueToString(aProperty, array->Item(index), aResult);
+      AppendCSSValueToString(aProperty, array->Item(index), aFixup, aResult);
 
       /* If we're not at the final element, append a comma. */
       if (index + 1 != array->Count())
         aResult.AppendLiteral(", ");
     }
 
     /* Finally, append the closing parenthesis. */
     aResult.AppendLiteral(")");
@@ -394,18 +399,37 @@ nsCSSDeclaration::AppendCSSValueToString
       }
       tmpStr.Append(PRUnichar(')'));
 
       aResult.Append(tmpStr);
     }
   }
   else if (eCSSUnit_URL == unit || eCSSUnit_Image == unit) {
     aResult.Append(NS_LITERAL_STRING("url("));
-    nsStyleUtil::AppendEscapedCSSString(
-      nsDependentString(aValue.GetOriginalURLValue()), aResult);
+
+    if (aFixup) {
+      nsXPIDLCString type;
+      if (eCSSUnit_Image == unit) {
+        imgIRequest *req = aValue.GetImageValue();
+        if (req) {
+          req->GetMimeType(getter_Copies(type));
+        }
+      }
+
+      nsIURI *uri = aValue.GetURLValue();
+      nsAutoString fixedSpec;
+      nsresult rv = aFixup->FixupURI(uri, type, fixedSpec);
+      NS_ENSURE_SUCCESS(rv, rv);
+                    
+      nsStyleUtil::AppendEscapedCSSString(fixedSpec, aResult);
+    } else {
+      nsStyleUtil::AppendEscapedCSSString(
+        nsDependentString(aValue.GetOriginalURLValue()), aResult);
+    }
+
     aResult.Append(NS_LITERAL_STRING(")"));
   }
   else if (eCSSUnit_Percent == unit) {
     nsAutoString tmpStr;
     tmpStr.AppendFloat(aValue.GetPercentValue() * 100.0f);
     aResult.Append(tmpStr);
   }
   else if (eCSSUnit_Percent < unit) {  // length unit
@@ -417,45 +441,49 @@ nsCSSDeclaration::AppendCSSValueToString
     nsCSSValueGradient* gradient = aValue.GetGradientValue();
 
     if (gradient->mIsRadial)
       aResult.AppendLiteral("-moz-radial-gradient(");
     else
       aResult.AppendLiteral("-moz-linear-gradient(");
 
     AppendCSSValueToString(eCSSProperty_background_position,
-                           gradient->mStartX, aResult);
+                           gradient->mStartX, aFixup, aResult);
     aResult.AppendLiteral(" ");
 
     AppendCSSValueToString(eCSSProperty_background_position,
-                           gradient->mStartY, aResult);
+                           gradient->mStartY, aFixup, aResult);
     aResult.AppendLiteral(", ");
 
     if (gradient->mIsRadial) {
-      AppendCSSValueToString(aProperty, gradient->mStartRadius, aResult);
+      AppendCSSValueToString(aProperty, gradient->mStartRadius, aFixup,
+                             aResult);
       aResult.AppendLiteral(", ");
     }
 
     AppendCSSValueToString(eCSSProperty_background_position,
-                           gradient->mEndX, aResult);
+                           gradient->mEndX, aFixup, aResult);
     aResult.AppendLiteral(" ");
 
     AppendCSSValueToString(eCSSProperty_background_position,
-                           gradient->mEndY, aResult);
+                           gradient->mEndY, aFixup, aResult);
 
     if (gradient->mIsRadial) {
       aResult.AppendLiteral(", ");
-      AppendCSSValueToString(aProperty, gradient->mEndRadius, aResult);
+      AppendCSSValueToString(aProperty, gradient->mEndRadius, aFixup,
+                             aResult);
     }
 
     for (PRUint32 i = 0; i < gradient->mStops.Length(); i++) {
       aResult.AppendLiteral(", color-stop(");
-      AppendCSSValueToString(aProperty, gradient->mStops[i].mLocation, aResult);
+      AppendCSSValueToString(aProperty, gradient->mStops[i].mLocation,
+                             aFixup, aResult);
       aResult.AppendLiteral(", ");
-      AppendCSSValueToString(aProperty, gradient->mStops[i].mColor, aResult);
+      AppendCSSValueToString(aProperty, gradient->mStops[i].mColor,
+                             aFixup, aResult);
       aResult.AppendLiteral(")");
     }
 
     aResult.AppendLiteral(")");
   }
 
   switch (unit) {
     case eCSSUnit_Null:         break;
@@ -515,23 +543,24 @@ nsCSSDeclaration::AppendCSSValueToString
     case eCSSUnit_Milliseconds: aResult.AppendLiteral("ms");   break;
   }
 
   return PR_TRUE;
 }
 
 nsresult
 nsCSSDeclaration::GetValue(nsCSSProperty aProperty,
+                           nsIDocumentEncoderFixup *aFixup,
                            nsAString& aValue) const
 {
   aValue.Truncate(0);
 
   // simple properties are easy.
   if (!nsCSSProps::IsShorthand(aProperty)) {
-    AppendValueToString(aProperty, aValue);
+    AppendValueToString(aProperty, aFixup, aValue);
     return NS_OK;
   }
 
   // DOM Level 2 Style says (when describing CSS2Properties, although
   // not CSSStyleDeclaration.getPropertyValue):
   //   However, if there is no shorthand declaration that could be added
   //   to the ruleset without changing in any way the rules already
   //   declared in the ruleset (i.e., by adding longhand rules that were
@@ -606,23 +635,23 @@ nsCSSDeclaration::GetValue(nsCSSProperty
   }
   if (importantCount != 0 && importantCount != totalCount) {
     // Case (3), no consistent importance.
     return NS_OK;
   }
   if (initialCount == totalCount) {
     // Simplify serialization below by serializing initial up-front.
     AppendCSSValueToString(eCSSProperty_UNKNOWN, nsCSSValue(eCSSUnit_Initial),
-                           aValue);
+                           aFixup, aValue);
     return NS_OK;
   }
   if (inheritCount == totalCount) {
     // Simplify serialization below by serializing inherit up-front.
     AppendCSSValueToString(eCSSProperty_UNKNOWN, nsCSSValue(eCSSUnit_Inherit),
-                           aValue);
+                           aFixup, aValue);
     return NS_OK;
   }
   if (initialCount != 0 || inheritCount != 0) {
     // Case (2): partially initial or inherit.
     return NS_OK;
   }
 
   nsCSSCompressedDataBlock *data = importantCount ? mImportantData : mData;
@@ -647,30 +676,34 @@ nsCSSDeclaration::GetValue(nsCSSProperty
                      kNotFound, "third subprop must be bottom");
       NS_ASSERTION(nsCSSProps::GetStringValue(subprops[3]).Find("-left") !=
                      kNotFound, "fourth subprop must be left");
       const nsCSSValue &topValue = *data->ValueStorageFor(subprops[0]);
       const nsCSSValue &rightValue = *data->ValueStorageFor(subprops[1]);
       const nsCSSValue &bottomValue = *data->ValueStorageFor(subprops[2]);
       const nsCSSValue &leftValue = *data->ValueStorageFor(subprops[3]);
       PRBool haveValue;
-      haveValue = AppendCSSValueToString(subprops[0], topValue, aValue);
+      haveValue = AppendCSSValueToString(subprops[0], topValue, aFixup,
+                                         aValue);
       NS_ASSERTION(haveValue, "should have bailed before");
       if (topValue != rightValue || topValue != leftValue ||
           topValue != bottomValue) {
         aValue.Append(PRUnichar(' '));
-        haveValue = AppendCSSValueToString(subprops[1], rightValue, aValue);
+        haveValue = AppendCSSValueToString(subprops[1], rightValue, aFixup,
+                                           aValue);
         NS_ASSERTION(haveValue, "should have bailed before");
         if (topValue != bottomValue || rightValue != leftValue) {
           aValue.Append(PRUnichar(' '));
-          haveValue = AppendCSSValueToString(subprops[2], bottomValue, aValue);
+          haveValue = AppendCSSValueToString(subprops[2], bottomValue, aFixup,
+                                             aValue);
           NS_ASSERTION(haveValue, "should have bailed before");
           if (rightValue != leftValue) {
             aValue.Append(PRUnichar(' '));
-            haveValue = AppendCSSValueToString(subprops[3], leftValue, aValue);
+            haveValue = AppendCSSValueToString(subprops[3], leftValue, aFixup,
+                                               aValue);
             NS_ASSERTION(haveValue, "should have bailed before");
           }
         }
       }
       break;
     }
     case eCSSProperty__moz_border_radius: 
     case eCSSProperty__moz_outline_radius: {
@@ -683,38 +716,38 @@ nsCSSDeclaration::GetValue(nsCSSProperty
                    "type mismatch");
       const nsCSSValuePair* vals[4] = {
         data->ValuePairStorageFor(subprops[0]),
         data->ValuePairStorageFor(subprops[1]),
         data->ValuePairStorageFor(subprops[2]),
         data->ValuePairStorageFor(subprops[3])
       };
 
-      AppendCSSValueToString(aProperty, vals[0]->mXValue, aValue);
+      AppendCSSValueToString(aProperty, vals[0]->mXValue, aFixup, aValue);
       aValue.Append(PRUnichar(' '));
-      AppendCSSValueToString(aProperty, vals[1]->mXValue, aValue);
+      AppendCSSValueToString(aProperty, vals[1]->mXValue, aFixup, aValue);
       aValue.Append(PRUnichar(' '));
-      AppendCSSValueToString(aProperty, vals[2]->mXValue, aValue);
+      AppendCSSValueToString(aProperty, vals[2]->mXValue, aFixup, aValue);
       aValue.Append(PRUnichar(' '));
-      AppendCSSValueToString(aProperty, vals[3]->mXValue, aValue);
+      AppendCSSValueToString(aProperty, vals[3]->mXValue, aFixup, aValue);
         
       // For compatibility, only write a slash and the y-values
       // if they're not identical to the x-values.
       if (vals[0]->mXValue != vals[0]->mYValue ||
           vals[1]->mXValue != vals[1]->mYValue ||
           vals[2]->mXValue != vals[2]->mYValue ||
           vals[3]->mXValue != vals[3]->mYValue) {
         aValue.AppendLiteral(" / ");
-        AppendCSSValueToString(aProperty, vals[0]->mYValue, aValue);
+        AppendCSSValueToString(aProperty, vals[0]->mYValue, aFixup, aValue);
         aValue.Append(PRUnichar(' '));
-        AppendCSSValueToString(aProperty, vals[1]->mYValue, aValue);
+        AppendCSSValueToString(aProperty, vals[1]->mYValue, aFixup, aValue);
         aValue.Append(PRUnichar(' '));
-        AppendCSSValueToString(aProperty, vals[2]->mYValue, aValue);
+        AppendCSSValueToString(aProperty, vals[2]->mYValue, aFixup, aValue);
         aValue.Append(PRUnichar(' '));
-        AppendCSSValueToString(aProperty, vals[3]->mYValue, aValue);
+        AppendCSSValueToString(aProperty, vals[3]->mYValue, aFixup, aValue);
       }
       break;
     }
     case eCSSProperty_border: {
       const nsCSSProperty* subproptables[3] = {
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_color),
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_style),
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_width)
@@ -758,23 +791,23 @@ nsCSSDeclaration::GetValue(nsCSSProperty
                                   NS_LITERAL_CSTRING("-color")) ||
                    StringEndsWith(nsCSSProps::GetStringValue(subprops[2]),
                                   NS_LITERAL_CSTRING("-color-value")),
                    "third subprop must be the color property");
       const nsCSSValue *colorValue = data->ValueStorageFor(subprops[2]);
       PRBool isMozUseTextColor =
         colorValue->GetUnit() == eCSSUnit_Enumerated &&
         colorValue->GetIntValue() == NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR;
-      if (!AppendValueToString(subprops[0], aValue) ||
+      if (!AppendValueToString(subprops[0], aFixup, aValue) ||
           !(aValue.Append(PRUnichar(' ')),
-            AppendValueToString(subprops[1], aValue)) ||
+            AppendValueToString(subprops[1], aFixup, aValue)) ||
           // Don't output a third value when it's -moz-use-text-color.
           !(isMozUseTextColor ||
             (aValue.Append(PRUnichar(' ')),
-             AppendValueToString(subprops[2], aValue)))) {
+             AppendValueToString(subprops[2], aFixup, aValue)))) {
         aValue.Truncate();
       }
       break;
     }
     case eCSSProperty_margin_left:
     case eCSSProperty_margin_right:
     case eCSSProperty_margin_start:
     case eCSSProperty_margin_end:
@@ -793,17 +826,17 @@ nsCSSDeclaration::GetValue(nsCSSProperty
     case eCSSProperty_border_start_width:
     case eCSSProperty_border_end_color:
     case eCSSProperty_border_end_style:
     case eCSSProperty_border_end_width: {
       const nsCSSProperty* subprops =
         nsCSSProps::SubpropertyEntryFor(aProperty);
       NS_ASSERTION(subprops[3] == eCSSProperty_UNKNOWN,
                    "not box property with physical vs. logical cascading");
-      AppendValueToString(subprops[0], aValue);
+      AppendValueToString(subprops[0], aFixup, aValue);
       break;
     }
     case eCSSProperty_background: {
       // We know from above that all subproperties were specified.
       // However, we still can't represent that in the shorthand unless
       // they're all lists of the same length.  So if they're different
       // lengths, we need to bail out.
       // We also need to bail out if an item has background-clip and
@@ -820,29 +853,29 @@ nsCSSDeclaration::GetValue(nsCSSProperty
       const nsCSSValueList *clip =
         * data->ValueListStorageFor(eCSSProperty__moz_background_clip);
       const nsCSSValueList *origin =
         * data->ValueListStorageFor(eCSSProperty__moz_background_origin);
       const nsCSSValuePairList *size =
         * data->ValuePairListStorageFor(eCSSProperty__moz_background_size);
       for (;;) {
         AppendCSSValueToString(eCSSProperty_background_image,
-                               image->mValue, aValue);
+                               image->mValue, aFixup, aValue);
         aValue.Append(PRUnichar(' '));
         AppendCSSValueToString(eCSSProperty_background_repeat,
-                               repeat->mValue, aValue);
+                               repeat->mValue, aFixup, aValue);
         aValue.Append(PRUnichar(' '));
         AppendCSSValueToString(eCSSProperty_background_attachment,
-                               attachment->mValue, aValue);
+                               attachment->mValue, aFixup, aValue);
         aValue.Append(PRUnichar(' '));
         AppendCSSValueToString(eCSSProperty_background_position,
-                               position->mXValue, aValue);
+                               position->mXValue, aFixup, aValue);
         aValue.Append(PRUnichar(' '));
         AppendCSSValueToString(eCSSProperty_background_position,
-                               position->mYValue, aValue);
+                               position->mYValue, aFixup, aValue);
         NS_ASSERTION(clip->mValue.GetUnit() == eCSSUnit_Enumerated &&
                      origin->mValue.GetUnit() == eCSSUnit_Enumerated,
                      "should not be inherit/initial within list and "
                      "should have returned early for real inherit/initial");
         if (clip->mValue.GetIntValue() != NS_STYLE_BG_CLIP_BORDER ||
             origin->mValue.GetIntValue() != NS_STYLE_BG_ORIGIN_PADDING) {
 #if 0
     // This is commented out for now until we change
@@ -857,17 +890,17 @@ nsCSSDeclaration::GetValue(nsCSSProperty
           //                  NS_STYLE_BG_ORIGIN_CONTENT);
           if (clip->mValue != origin->mValue) {
             aValue.Truncate();
             return NS_OK;
           }
 
           aValue.Append(PRUnichar(' '));
           AppendCSSValueToString(eCSSProperty__moz_background_clip,
-                                 clip->mValue, aValue);
+                                 clip->mValue, aFixup, aValue);
 #else
           aValue.Truncate();
           return NS_OK;
 #endif
         }
 
         image = image->mNext;
         repeat = repeat->mNext;
@@ -890,23 +923,23 @@ nsCSSDeclaration::GetValue(nsCSSProperty
           aValue.Truncate();
           return NS_OK;
         }
         aValue.Append(PRUnichar(','));
         aValue.Append(PRUnichar(' '));
       }
 
       aValue.Append(PRUnichar(' '));
-      AppendValueToString(eCSSProperty_background_color, aValue);
+      AppendValueToString(eCSSProperty_background_color, aFixup, aValue);
       break;
     }
     case eCSSProperty_cue: {
-      if (AppendValueToString(eCSSProperty_cue_before, aValue)) {
+      if (AppendValueToString(eCSSProperty_cue_before, aFixup, aValue)) {
         aValue.Append(PRUnichar(' '));
-        if (!AppendValueToString(eCSSProperty_cue_after, aValue))
+        if (!AppendValueToString(eCSSProperty_cue_after, aFixup, aValue))
           aValue.Truncate();
       }
       break;
     }
     case eCSSProperty_font: {
       // systemFont might not be present; the others are guaranteed to be
       // based on the shorthand check at the beginning of the function
       const nsCSSValue *systemFont =
@@ -938,82 +971,89 @@ nsCSSDeclaration::GetValue(nsCSSProperty
             lh.GetUnit() != eCSSUnit_System_Font ||
             family.GetUnit() != eCSSUnit_System_Font ||
             stretch.GetUnit() != eCSSUnit_System_Font ||
             sizeAdjust.GetUnit() != eCSSUnit_System_Font) {
           // This can't be represented as a shorthand.
           return NS_OK;
         }
         AppendCSSValueToString(eCSSProperty__x_system_font, *systemFont,
-                               aValue);
+                               aFixup, aValue);
       } else {
         // The font-stretch and font-size-adjust
         // properties are reset by this shorthand property to their
         // initial values, but can't be represented in its syntax.
         if (stretch != nsCSSValue(eCSSUnit_Normal) ||
             sizeAdjust != nsCSSValue(eCSSUnit_None)) {
           return NS_OK;
         }
 
         if (style.GetUnit() != eCSSUnit_Normal) {
-          AppendCSSValueToString(eCSSProperty_font_style, style, aValue);
+          AppendCSSValueToString(eCSSProperty_font_style, style, aFixup,
+                                 aValue);
           aValue.Append(PRUnichar(' '));
         }
         if (variant.GetUnit() != eCSSUnit_Normal) {
-          AppendCSSValueToString(eCSSProperty_font_variant, variant, aValue);
+          AppendCSSValueToString(eCSSProperty_font_variant, variant, aFixup,
+                                 aValue);
           aValue.Append(PRUnichar(' '));
         }
         if (weight.GetUnit() != eCSSUnit_Normal) {
-          AppendCSSValueToString(eCSSProperty_font_weight, weight, aValue);
+          AppendCSSValueToString(eCSSProperty_font_weight, weight, aFixup,
+                                 aValue);
           aValue.Append(PRUnichar(' '));
         }
-        AppendCSSValueToString(eCSSProperty_font_size, size, aValue);
+        AppendCSSValueToString(eCSSProperty_font_size, size, aFixup, aValue);
         if (lh.GetUnit() != eCSSUnit_Normal) {
           aValue.Append(PRUnichar('/'));
-          AppendCSSValueToString(eCSSProperty_line_height, lh, aValue);
+          AppendCSSValueToString(eCSSProperty_line_height, lh, aFixup,
+                                 aValue);
         }
         aValue.Append(PRUnichar(' '));
-        AppendCSSValueToString(eCSSProperty_font_family, family, aValue);
+        AppendCSSValueToString(eCSSProperty_font_family, family, aFixup,
+                               aValue);
       }
       break;
     }
     case eCSSProperty_list_style:
-      if (AppendValueToString(eCSSProperty_list_style_type, aValue))
+      if (AppendValueToString(eCSSProperty_list_style_type, aFixup, aValue))
         aValue.Append(PRUnichar(' '));
-      if (AppendValueToString(eCSSProperty_list_style_position, aValue))
+      if (AppendValueToString(eCSSProperty_list_style_position, aFixup,
+                              aValue))
         aValue.Append(PRUnichar(' '));
-      AppendValueToString(eCSSProperty_list_style_image, aValue);
+      AppendValueToString(eCSSProperty_list_style_image, aFixup, aValue);
       break;
     case eCSSProperty_overflow: {
       const nsCSSValue &xValue =
         *data->ValueStorageFor(eCSSProperty_overflow_x);
       const nsCSSValue &yValue =
         *data->ValueStorageFor(eCSSProperty_overflow_y);
       if (xValue == yValue)
-        AppendCSSValueToString(eCSSProperty_overflow_x, xValue, aValue);
+        AppendCSSValueToString(eCSSProperty_overflow_x, xValue, aFixup,
+                               aValue);
       break;
     }
     case eCSSProperty_pause: {
-      if (AppendValueToString(eCSSProperty_pause_before, aValue)) {
+      if (AppendValueToString(eCSSProperty_pause_before, aFixup, aValue)) {
         aValue.Append(PRUnichar(' '));
-        if (!AppendValueToString(eCSSProperty_pause_after, aValue))
+        if (!AppendValueToString(eCSSProperty_pause_after, aFixup, aValue))
           aValue.Truncate();
       }
       break;
     }
 #ifdef MOZ_SVG
     case eCSSProperty_marker: {
       const nsCSSValue &endValue =
         *data->ValueStorageFor(eCSSProperty_marker_end);
       const nsCSSValue &midValue =
         *data->ValueStorageFor(eCSSProperty_marker_mid);
       const nsCSSValue &startValue =
         *data->ValueStorageFor(eCSSProperty_marker_start);
       if (endValue == midValue && midValue == startValue)
-        AppendValueToString(eCSSProperty_marker_end, aValue);
+        AppendValueToString(eCSSProperty_marker_end, aFixup, aValue);
       break;
     }
 #endif
     default:
       NS_NOTREACHED("no other shorthands");
       break;
   }
   return NS_OK;
@@ -1058,36 +1098,39 @@ nsCSSDeclaration::AppendImportanceToStri
   if (aIsImportant) {
    aString.AppendLiteral(" ! important");
   }
 }
 
 void
 nsCSSDeclaration::AppendPropertyAndValueToString(nsCSSProperty aProperty,
                                                  nsAutoString& aValue,
+                                                 nsIDocumentEncoderFixup
+                                                                      *aFixup,
                                                  nsAString& aResult) const
 {
   NS_ASSERTION(0 <= aProperty && aProperty < eCSSProperty_COUNT,
                "property enum out of range");
   NS_ASSERTION((aProperty < eCSSProperty_COUNT_no_shorthands) ==
                  aValue.IsEmpty(),
                "aValue should be given for shorthands but not longhands");
   AppendASCIItoUTF16(nsCSSProps::GetStringValue(aProperty), aResult);
   aResult.AppendLiteral(": ");
   if (aValue.IsEmpty())
-    AppendValueToString(aProperty, aResult);
+    AppendValueToString(aProperty, aFixup, aResult);
   else
     aResult.Append(aValue);
   PRBool  isImportant = GetValueIsImportant(aProperty);
   AppendImportanceToString(isImportant, aResult);
   aResult.AppendLiteral("; ");
 }
 
 nsresult
-nsCSSDeclaration::ToString(nsAString& aString) const
+nsCSSDeclaration::ToString(nsIDocumentEncoderFixup *aFixup,
+                           nsAString& aString) const
 {
   nsCSSCompressedDataBlock *systemFontData =
     GetValueIsImportant(eCSSProperty__x_system_font) ? mImportantData : mData;
   const nsCSSValue *systemFont = 
     systemFontData->ValueStorageFor(eCSSProperty__x_system_font);
   const PRBool haveSystemFont = systemFont &&
                                 systemFont->GetUnit() != eCSSUnit_None &&
                                 systemFont->GetUnit() != eCSSUnit_Null;
@@ -1121,35 +1164,36 @@ nsCSSDeclaration::ToString(nsAString& aS
          *shorthands != eCSSProperty_UNKNOWN; ++shorthands) {
       // ShorthandsContaining returns the shorthands in order from those
       // that contain the most subproperties to those that contain the
       // least, which is exactly the order we want to test them.
       nsCSSProperty shorthand = *shorthands;
 
       // If GetValue gives us a non-empty string back, we can use that
       // value; otherwise it's not possible to use this shorthand.
-      GetValue(shorthand, value);
+      GetValue(shorthand, aFixup, value);
       if (!value.IsEmpty()) {
-        AppendPropertyAndValueToString(shorthand, value, aString);
+        AppendPropertyAndValueToString(shorthand, value, aFixup, aString);
         shorthandsUsed.AppendElement(shorthand);
         doneProperty = PR_TRUE;
         break;
       }
 
       NS_ASSERTION(shorthand != eCSSProperty_font ||
                    *(shorthands + 1) == eCSSProperty_UNKNOWN,
                    "font should always be the only containing shorthand");
       if (shorthand == eCSSProperty_font) {
         if (haveSystemFont && !didSystemFont) {
           // Output the shorthand font declaration that we will
           // partially override later.  But don't add it to
           // |shorthandsUsed|, since we will have to override it.
           AppendCSSValueToString(eCSSProperty__x_system_font, *systemFont,
-                                 value);
-          AppendPropertyAndValueToString(eCSSProperty_font, value, aString);
+                                 aFixup, value);
+          AppendPropertyAndValueToString(eCSSProperty_font, value,
+                                         aFixup, aString);
           value.Truncate();
           didSystemFont = PR_TRUE;
         }
 
         // That we output the system font is enough for this property if:
         //   (1) it's the hidden system font subproperty (which either
         //       means we output it or we don't have it), or
         //   (2) its value is the hidden system font value and it matches
@@ -1164,33 +1208,33 @@ nsCSSDeclaration::ToString(nsAString& aS
           doneProperty = PR_TRUE;
         }
       }
     }
     if (doneProperty)
       continue;
     
     NS_ASSERTION(value.IsEmpty(), "value should be empty now");
-    AppendPropertyAndValueToString(property, value, aString);
+    AppendPropertyAndValueToString(property, value, aFixup, aString);
   }
   if (! aString.IsEmpty()) {
     // if the string is not empty, we have a trailing whitespace we should remove
     aString.Truncate(aString.Length() - 1);
   }
   return NS_OK;
 }
 
 #ifdef DEBUG
 void nsCSSDeclaration::List(FILE* out, PRInt32 aIndent) const
 {
   for (PRInt32 index = aIndent; --index >= 0; ) fputs("  ", out);
 
   fputs("{ ", out);
   nsAutoString s;
-  ToString(s);
+  ToString(nsnull, s);
   fputs(NS_ConvertUTF16toUTF8(s).get(), out);
   fputs("}", out);
 }
 #endif
 
 nsresult
 nsCSSDeclaration::GetNthProperty(PRUint32 aIndex, nsAString& aReturn) const
 {
diff --git a/layout/style/nsCSSDeclaration.h b/layout/style/nsCSSDeclaration.h
--- a/layout/style/nsCSSDeclaration.h
+++ b/layout/style/nsCSSDeclaration.h
@@ -50,16 +50,18 @@
 #include "nsString.h"
 #include "nsCoord.h"
 #include "nsCSSValue.h"
 #include "nsCSSProps.h"
 #include "nsTArray.h"
 #include "nsCSSDataBlock.h"
 #include "nsCSSStruct.h"
 
+class nsIDocumentEncoderFixup;
+
 class nsCSSDeclaration {
 public:
   /**
    * Construct an |nsCSSDeclaration| that is in an invalid state (null
    * |mData|) and cannot be used until its |CompressFrom| method or
    * |InitializeEmpty| method is called.
    */
   nsCSSDeclaration();
@@ -71,28 +73,31 @@ public:
    * |mOrder| whenever a property is parsed into an expanded data block
    * for this declaration.  aProperty must not be a shorthand.
    */
   nsresult ValueAppended(nsCSSProperty aProperty);
 
   nsresult AppendComment(const nsAString& aComment);
   nsresult RemoveProperty(nsCSSProperty aProperty);
 
-  nsresult GetValue(nsCSSProperty aProperty, nsAString& aValue) const;
+  nsresult GetValue(nsCSSProperty aProperty,
+                    nsIDocumentEncoderFixup *aFixup,
+                    nsAString& aValue) const;
 
   PRBool HasImportantData() const { return mImportantData != nsnull; }
   PRBool GetValueIsImportant(nsCSSProperty aProperty) const;
   PRBool GetValueIsImportant(const nsAString& aProperty) const;
 
   PRUint32 Count() const {
     return mOrder.Length(); 
   }
   nsresult GetNthProperty(PRUint32 aIndex, nsAString& aReturn) const;
 
-  nsresult ToString(nsAString& aString) const;
+  nsresult ToString(nsIDocumentEncoderFixup *aFixup,
+                    nsAString& aString) const;
 
   nsCSSDeclaration* Clone() const;
 
   nsresult MapRuleInfoInto(nsRuleData *aRuleData) const {
     return mData->MapRuleInfoInto(aRuleData);
   }
 
   nsresult MapImportantRuleInfoInto(nsRuleData *aRuleData) const {
@@ -168,29 +173,33 @@ public:
 
 #ifdef DEBUG
   void List(FILE* out = stdout, PRInt32 aIndent = 0) const;
 #endif
   
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
   static PRBool AppendCSSValueToString(nsCSSProperty aProperty,
                                        const nsCSSValue& aValue,
+                                       nsIDocumentEncoderFixup *aFixup,
                                        nsAString& aResult);
 
 private:
   // Not implemented, and not supported.
   nsCSSDeclaration& operator=(const nsCSSDeclaration& aCopy);
   PRBool operator==(const nsCSSDeclaration& aCopy) const;
 
   static void AppendImportanceToString(PRBool aIsImportant, nsAString& aString);
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
-  PRBool   AppendValueToString(nsCSSProperty aProperty, nsAString& aResult) const;
+  PRBool   AppendValueToString(nsCSSProperty aProperty,
+                               nsIDocumentEncoderFixup *aFixup,
+                               nsAString& aResult) const;
   // Helper for ToString with strange semantics regarding aValue.
   void     AppendPropertyAndValueToString(nsCSSProperty aProperty,
                                           nsAutoString& aValue,
+                                          nsIDocumentEncoderFixup *aFixup,
                                           nsAString& aResult) const;
 
 private:
     //
     // Specialized ref counting.
     // We do not want everyone to ref count us, only the rules which hold
     //  onto us (our well defined lifetime is when the last rule releases
     //  us).
diff --git a/layout/style/nsCSSRules.cpp b/layout/style/nsCSSRules.cpp
--- a/layout/style/nsCSSRules.cpp
+++ b/layout/style/nsCSSRules.cpp
@@ -1583,30 +1583,35 @@ nsCSSFontFaceStyleDecl::GetPropertyValue
       NS_ASSERTION(val.GetUnit() == eCSSUnit_String, "unexpected unit");
       nsDependentString family(val.GetStringBufferValue());
       nsStyleUtil::AppendEscapedCSSString(family, aResult);
       return NS_OK;
     }
 
   case eCSSFontDesc_Style:
     nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_font_style, val,
-                                             aResult);
+                                             nsnull, aResult);
     return NS_OK;
 
   case eCSSFontDesc_Weight:
     nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_font_weight, val,
-                                             aResult);
+                                             nsnull, aResult);
     return NS_OK;
     
   case eCSSFontDesc_Stretch:
     nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_font_stretch, val,
-                                             aResult);
+                                             nsnull, aResult);
     return NS_OK;
 
   case eCSSFontDesc_Src:
+    // FIXME: When we're serializing for save page as, complete, we need
+    // to get the nsIDocumentEncoderFixup passed through to here so we
+    // can give it to AppendSerializedFontSrc (at which point we could
+    // pass it to the AppendCSSValueToString calls above, for
+    // completeness).
     AppendSerializedFontSrc(val, aResult);
     return NS_OK;
 
   case eCSSFontDesc_UnicodeRange:
     // these are not implemented, so always return an empty string
     return NS_OK;
 
   case eCSSFontDesc_UNKNOWN:
diff --git a/layout/style/nsCSSStyleRule.cpp b/layout/style/nsCSSStyleRule.cpp
--- a/layout/style/nsCSSStyleRule.cpp
+++ b/layout/style/nsCSSStyleRule.cpp
@@ -1484,21 +1484,20 @@ CSSStyleRuleImpl::List(FILE* out, PRInt3
 CSSStyleRuleImpl::GetCssText(nsAString& aCssText)
 {
   if (mSelector) {
     mSelector->ToString(aCssText, mSheet);
     aCssText.Append(PRUnichar(' '));
   }
   aCssText.Append(PRUnichar('{'));
   aCssText.Append(PRUnichar(' '));
-  if (mDeclaration)
-  {
-    nsAutoString   tempString;
-    mDeclaration->ToString( tempString );
-    aCssText.Append( tempString );
+  if (mDeclaration) {
+    nsAutoString tempString;
+    mDeclaration->ToString(nsnull, tempString);
+    aCssText.Append(tempString);
   }
   aCssText.Append(PRUnichar(' '));
   aCssText.Append(PRUnichar('}'));
   return NS_OK;
 }
 
 /* virtual */ nsresult    
 CSSStyleRuleImpl::SetCssText(const nsAString& aCssText)
diff --git a/layout/style/nsCSSStyleSheet.cpp b/layout/style/nsCSSStyleSheet.cpp
--- a/layout/style/nsCSSStyleSheet.cpp
+++ b/layout/style/nsCSSStyleSheet.cpp
@@ -412,42 +412,46 @@ nsMediaQuery::AppendToString(nsAString& 
     if (expr.mValue.GetUnit() != eCSSUnit_Null) {
       aString.AppendLiteral(": ");
       switch (feature->mValueType) {
         case nsMediaFeature::eLength:
           NS_ASSERTION(expr.mValue.IsLengthUnit(), "bad unit");
           // Use 'width' as a property that takes length values
           // written in the normal way.
           nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_width,
-                                                   expr.mValue, aString);
+                                                   expr.mValue, nsnull,
+                                                   aString);
           break;
         case nsMediaFeature::eInteger:
         case nsMediaFeature::eBoolInteger:
           NS_ASSERTION(expr.mValue.GetUnit() == eCSSUnit_Integer,
                        "bad unit");
           // Use 'z-index' as a property that takes integer values
           // written without anything extra.
           nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
-                                                   expr.mValue, aString);
+                                                   expr.mValue, nsnull,
+                                                   aString);
           break;
         case nsMediaFeature::eIntRatio:
           {
             NS_ASSERTION(expr.mValue.GetUnit() == eCSSUnit_Array,
                          "bad unit");
             nsCSSValue::Array *array = expr.mValue.GetArrayValue();
             NS_ASSERTION(array->Count() == 2, "unexpected length");
             NS_ASSERTION(array->Item(0).GetUnit() == eCSSUnit_Integer,
                          "bad unit");
             NS_ASSERTION(array->Item(1).GetUnit() == eCSSUnit_Integer,
                          "bad unit");
             nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
-                                                     array->Item(0), aString);
+                                                     array->Item(0), nsnull,
+                                                     aString);
             aString.AppendLiteral("/");
             nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
-                                                     array->Item(1), aString);
+                                                     array->Item(1), nsnull,
+                                                     aString);
           }
           break;
         case nsMediaFeature::eResolution:
           buffer.AppendFloat(expr.mValue.GetFloatValue());
           aString.Append(buffer);
           buffer.Truncate();
           if (expr.mValue.GetUnit() == eCSSUnit_Inch) {
             aString.AppendLiteral("dpi");
@@ -1259,16 +1263,39 @@ nsCSSStyleSheet::SetOwningDocument(nsIDo
     if (child->mParent == this) {
       child->SetOwningDocument(aDocument);
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
+nsCSSStyleSheet::Serialize(nsAString& aContent, nsIDocumentEncoderFixup *aFixup)
+{
+  nsresult rv;
+
+  PRInt32 styleRules = 0;
+  StyleRuleCount(styleRules);
+  for (PRInt32 i = 0; i < styleRules; ++i) {
+    nsCOMPtr<nsICSSRule> rule;
+    rv = GetStyleRuleAt(i, *getter_AddRefs(rule));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsICSSStyleRule> srule = do_QueryInterface(rule);
+    if (srule) {
+      nsAutoString ruleText;
+      srule->Serialize(ruleText, aFixup);
+      aContent.Append(ruleText);
+      aContent.Append(NS_LITERAL_STRING("\n"));
+    }
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsCSSStyleSheet::SetOwningNode(nsIDOMNode* aOwningNode)
 { // not ref counted
   mOwningNode = aOwningNode;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSStyleSheet::SetOwnerRule(nsICSSImportRule* aOwnerRule)
diff --git a/layout/style/nsCSSStyleSheet.h b/layout/style/nsCSSStyleSheet.h
--- a/layout/style/nsCSSStyleSheet.h
+++ b/layout/style/nsCSSStyleSheet.h
@@ -52,16 +52,17 @@
 #include "nsICSSLoaderObserver.h"
 #include "nsTArray.h"
 #include "nsCOMArray.h"
 
 class nsIURI;
 class nsMediaList;
 class nsMediaQueryResultCacheKey;
 class nsCSSStyleSheet;
+class nsIDocumentEncoderFixup;
 
 // -------------------------------
 // CSS Style Sheet Inner Data Container
 //
 
 class nsCSSStyleSheetInner {
 public:
   nsCSSStyleSheetInner(nsICSSStyleSheet* aPrimarySheet);
@@ -162,16 +163,17 @@ public:
                    nsICSSStyleSheet** aClone) const;
   NS_IMETHOD IsModified(PRBool* aSheetModified) const;
   NS_IMETHOD SetModified(PRBool aModified);
   NS_IMETHOD AddRuleProcessor(nsCSSRuleProcessor* aProcessor);
   NS_IMETHOD DropRuleProcessor(nsCSSRuleProcessor* aProcessor);
   NS_IMETHOD InsertRuleInternal(const nsAString& aRule,
                                 PRUint32 aIndex, PRUint32* aReturn);
   NS_IMETHOD_(nsIURI*) GetOriginalURI() const;
+  NS_IMETHOD Serialize(nsAString& aContent, nsIDocumentEncoderFixup *aFixup);
 
   // nsICSSLoaderObserver interface
   NS_IMETHOD StyleSheetLoaded(nsICSSStyleSheet* aSheet, PRBool aWasAlternate,
                               nsresult aStatus);
   
   nsresult EnsureUniqueInner();
 
   PRBool UseForPresentation(nsPresContext* aPresContext,
diff --git a/layout/style/nsDOMCSSDeclaration.cpp b/layout/style/nsDOMCSSDeclaration.cpp
--- a/layout/style/nsDOMCSSDeclaration.cpp
+++ b/layout/style/nsDOMCSSDeclaration.cpp
@@ -81,17 +81,17 @@ nsDOMCSSDeclaration::GetPropertyValue(co
   NS_PRECONDITION(aPropID != eCSSProperty_UNKNOWN,
                   "Should never pass eCSSProperty_UNKNOWN around");
   
   nsCSSDeclaration *decl;
   nsresult result = GetCSSDeclaration(&decl, PR_FALSE);
 
   aValue.Truncate();
   if (decl) {
-    result = decl->GetValue(aPropID, aValue);
+    result = decl->GetValue(aPropID, nsnull, aValue);
   }
 
   return result;
 }
 
 NS_IMETHODIMP
 nsDOMCSSDeclaration::SetPropertyValue(const nsCSSProperty aPropID,
                                       const nsAString& aValue)
@@ -109,17 +109,17 @@ nsDOMCSSDeclaration::SetPropertyValue(co
 NS_IMETHODIMP
 nsDOMCSSDeclaration::GetCssText(nsAString& aCssText)
 {
   nsCSSDeclaration* decl;
   aCssText.Truncate();
   GetCSSDeclaration(&decl, PR_FALSE);
 
   if (decl) {
-    decl->ToString(aCssText);
+    decl->ToString(nsnull, aCssText);
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMCSSDeclaration::SetCssText(const nsAString& aCssText)
 {
diff --git a/layout/style/nsICSSStyleSheet.h b/layout/style/nsICSSStyleSheet.h
--- a/layout/style/nsICSSStyleSheet.h
+++ b/layout/style/nsICSSStyleSheet.h
@@ -46,22 +46,22 @@
 class nsICSSRule;
 class nsIDOMNode;
 class nsXMLNameSpaceMap;
 class nsCSSRuleProcessor;
 class nsMediaList;
 class nsICSSGroupRule;
 class nsICSSImportRule;
 class nsIPrincipal;
+class nsIDocumentEncoderFixup;
 
-// IID for the nsICSSStyleSheet interface
-// ba09b3a4-4a29-495d-987b-cfbb58c5c6ec
+// dd024df4-d23b-4be5-a6fa-d4a192c88857
 #define NS_ICSS_STYLE_SHEET_IID     \
-{ 0xba09b3a4, 0x4a29, 0x495d, \
- { 0x98, 0x7b, 0xcf, 0xbb, 0x58, 0xc5, 0xc6, 0xec } }
+{ 0xdd024df4, 0xd23b, 0x4be5, \
+  { 0xa6, 0xfa, 0xd4, 0xa1, 0x92, 0xc8, 0x88, 0x57 } }
 
 class nsICSSStyleSheet : public nsIStyleSheet {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICSS_STYLE_SHEET_IID)
 
   NS_IMETHOD  AppendStyleSheet(nsICSSStyleSheet* aSheet) = 0;
   NS_IMETHOD  InsertStyleSheetAt(nsICSSStyleSheet* aSheet, PRInt32 aIndex) = 0;
 
@@ -124,16 +124,19 @@ public:
    * Like the DOM insertRule() method, but doesn't do any security checks
    */
   NS_IMETHOD InsertRuleInternal(const nsAString& aRule,
                                 PRUint32 aIndex, PRUint32* aReturn) = 0;
 
   /* Get the URI this sheet was originally loaded from, if any.  Can
      return null */
   NS_IMETHOD_(nsIURI*) GetOriginalURI() const = 0;
+
+  NS_IMETHOD Serialize(nsAString& aContent,
+                       nsIDocumentEncoderFixup *aFixup) = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsICSSStyleSheet, NS_ICSS_STYLE_SHEET_IID)
 
 nsresult
 NS_NewCSSStyleSheet(nsICSSStyleSheet** aInstancePtrResult);
 
 #endif /* nsICSSStyleSheet_h___ */
