From: L. David Baron <dbaron@dbaron.org>

Implement '-moz-color-correction' for colors specified in markup and style.

diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -1257,17 +1257,73 @@ PRBool nsDisplayClip::TryMerge(nsDisplay
 }
 
 nsDisplayWrapList* nsDisplayClip::WrapWithClone(nsDisplayListBuilder* aBuilder,
                                                 nsDisplayItem* aItem) {
   return new (aBuilder)
     nsDisplayClip(aItem->GetUnderlyingFrame(), mClippingFrame, aItem, mClip);
 }
 
+nsDisplayChangeColorCorrection::nsDisplayChangeColorCorrection(
+        nsIFrame* aFrame, nsDisplayItem* aItem, PRUint8 aColorCorrection)
+    : nsDisplayWrapList(aFrame, aItem),
+      mColorCorrection(aColorCorrection)
+{
+  MOZ_COUNT_CTOR(nsDisplayChangeColorCorrection);
+}
 
+nsDisplayChangeColorCorrection::nsDisplayChangeColorCorrection(
+        nsIFrame* aFrame, nsDisplayList* aList, PRUint8 aColorCorrection)
+    : nsDisplayWrapList(aFrame, aList),
+      mColorCorrection(aColorCorrection)
+{
+  MOZ_COUNT_CTOR(nsDisplayChangeColorCorrection);
+}
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+nsDisplayChangeColorCorrection::~nsDisplayChangeColorCorrection()
+{
+  MOZ_COUNT_DTOR(nsDisplayChangeColorCorrection);
+}
+#endif
+
+void
+nsDisplayChangeColorCorrection::Paint(nsDisplayListBuilder* aBuilder,
+                                      nsIRenderingContext* aCtx)
+{
+  PRUint8 colorCorr = GetColorCorrection();
+
+  nsCOMPtr<nsIDeviceContext> devCtx;
+  aCtx->GetDeviceContext(*getter_AddRefs(devCtx));
+
+  gfxContext* ctx = aCtx->ThebesContext();
+
+  // FIXME: Set color correction on ctx.
+
+  nsDisplayWrapList::Paint(aBuilder, aCtx);
+
+  // FIXME: Restore color correction on ctx.
+}
+
+PRBool
+nsDisplayChangeColorCorrection::TryMerge(nsDisplayListBuilder* aBuilder,
+                                         nsDisplayItem* aItem)
+{
+  if (aItem->GetType() != TYPE_CHANGE_COLOR_CORRECTION)
+    return PR_FALSE;
+  nsDisplayChangeColorCorrection* other =
+    static_cast<nsDisplayChangeColorCorrection*>(aItem);
+  // aItem->GetUnderlyingFrame() returns non-null because it's
+  // nsDisplayChangeColorCorrection
+  // We can merge anytime the frames are changing to the same value.
+  if (other->GetColorCorrection() != GetColorCorrection())
+    return PR_FALSE;
+  mList.AppendToBottom(&other->mList);
+  return PR_TRUE;
+}
 
 ///////////////////////////////////////////////////
 // nsDisplayTransform Implementation
 //
 
 // Write #define UNIFIED_CONTINUATIONS here to have the transform property try
 // to transform content with continuations as one unified block instead of
 // several smaller ones.  This is currently disabled because it doesn't work
diff --git a/layout/base/nsDisplayList.h b/layout/base/nsDisplayList.h
--- a/layout/base/nsDisplayList.h
+++ b/layout/base/nsDisplayList.h
@@ -470,16 +470,17 @@ public:
    * For items whose type never gets checked, TYPE_GENERIC will suffice.
    */
   enum Type {
     TYPE_GENERIC,
 
     TYPE_BORDER,
     TYPE_CLIP,
     TYPE_OPACITY,
+    TYPE_CHANGE_COLOR_CORRECTION,
     TYPE_OUTLINE,
     TYPE_PLUGIN,
 #ifdef MOZ_SVG
     TYPE_SVG_EFFECTS,
 #endif
     TYPE_TRANSFORM,
     TYPE_WRAPLIST
   };
@@ -571,17 +572,18 @@ public:
    */
   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
                                    nsRegion* aVisibleRegion,
                                    nsRegion* aVisibleRegionBeforeMove)
   { return PR_TRUE; }
 
   /**
    * Try to merge with the other item (which is below us in the display
-   * list). This gets used by nsDisplayClip to coalesce clipping operations
+   * list). This gets used by nsDisplayClip and
+   * nsDisplayChangeColorCorrection to coalesce clipping operations
    * (optimization), by nsDisplayOpacity to merge rendering for the same
    * content element into a single opacity group (correctness), and will be
    * used by nsDisplayOutline to merge multiple outlines for the same element
    * (also for correctness).
    * @return PR_TRUE if the merge was successful and the other item should be deleted
    */
   virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem) {
     return PR_FALSE;
@@ -1440,16 +1442,39 @@ private:
   // The frame that is responsible for the clipping. This may be different
   // from mFrame because mFrame represents the content that is being
   // clipped, and for example may be used to obtain the z-index of the
   // content.
   nsIFrame* mClippingFrame;
   nsRect    mClip;
 };
 
+/**
+ * The standard display item to paint a stacking context with translucency
+ * set by the stacking context root frame's 'opacity' style.
+ */
+class nsDisplayChangeColorCorrection : public nsDisplayWrapList {
+public:
+  nsDisplayChangeColorCorrection(nsIFrame* aFrame, nsDisplayItem* aItem,
+                                 PRUint8 aColorCorrection);
+  nsDisplayChangeColorCorrection(nsIFrame* aFrame, nsDisplayList* aList,
+                                 PRUint8 aColorCorrection);
+#ifdef NS_BUILD_REFCNT_LOGGING
+  virtual ~nsDisplayChangeColorCorrection();
+#endif
+  
+  virtual Type GetType() { return TYPE_CHANGE_COLOR_CORRECTION; }
+  virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx);
+  virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
+  NS_DISPLAY_DECL_NAME("ChangeColorCorrection")
+private:
+  PRUint8 mColorCorrection;
+  PRUint8 GetColorCorrection() { return mColorCorrection; }
+};
+
 #ifdef MOZ_SVG
 /**
  * A display item to paint a stacking context with effects
  * set by the stacking context root frame's style.
  */
 class nsDisplaySVGEffects : public nsDisplayWrapList {
 public:
   nsDisplaySVGEffects(nsIFrame* aFrame, nsDisplayList* aList);
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -1137,16 +1137,37 @@ public:
     return new (aBuilder) nsDisplayClip(aItem->GetUnderlyingFrame(),
             mContainer, aItem, mRect);
   }
 protected:
   nsIFrame* mContainer;
   nsRect    mRect;
 };
 
+class nsChangeColorCorrectionWrapper : public nsDisplayWrapper
+{
+public:
+  nsChangeColorCorrectionWrapper(PRUint8 aColorCorrection)
+    : mColorCorrection(aColorCorrection) {}
+  virtual nsDisplayItem* WrapList(nsDisplayListBuilder* aBuilder,
+                                  nsIFrame* aFrame, nsDisplayList* aList) {
+    // We are not a stacking context root. There is no valid underlying
+    // frame for the whole list.
+    return new (aBuilder) nsDisplayChangeColorCorrection(
+      nsnull, aList, mColorCorrection);
+  }
+  virtual nsDisplayItem* WrapItem(nsDisplayListBuilder* aBuilder,
+                                  nsDisplayItem* aItem) {
+    return new (aBuilder) nsDisplayChangeColorCorrection(
+      aItem->GetUnderlyingFrame(), aItem, mColorCorrection);
+  }
+protected:
+  PRUint8 mColorCorrection;
+};
+
 nsresult
 nsIFrame::OverflowClip(nsDisplayListBuilder*   aBuilder,
                        const nsDisplayListSet& aFromSet,
                        const nsDisplayListSet& aToSet,
                        const nsRect&           aClipRect,
                        PRBool                  aClipBorderBackground,
                        PRBool                  aClipAll)
 {
@@ -1160,27 +1181,49 @@ nsIFrame::Clip(nsDisplayListBuilder*   a
                const nsDisplayListSet& aToSet,
                const nsRect&           aClipRect)
 {
   nsAbsPosClipWrapper wrapper(this, aClipRect);
   return wrapper.WrapLists(aBuilder, this, aFromSet, aToSet);
 }
 
 static nsresult
-BuildDisplayListWithOverflowClip(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+BuildDisplayListWithWrappers(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
     const nsRect& aDirtyRect, const nsDisplayListSet& aSet,
-    const nsRect& aClipRect)
-{
+    const nsRect& aClipRect, PRBool aApplyOverflowClip,
+    PRBool aChangeColorCorrection)
+{
+  NS_PRECONDITION(aApplyOverflowClip || aChangeColorCorrection,
+                  "shouldn't have been called");
   nsDisplayListCollection set;
   nsresult rv = aFrame->BuildDisplayList(aBuilder, aDirtyRect, set);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = aBuilder->DisplayCaret(aFrame, aDirtyRect, aSet);
   NS_ENSURE_SUCCESS(rv, rv);
+
+  // REVIEW: Are there any other callers (e.g., other callers of
+  // nsIFrame::OverflowClip()) that need to do this wrapping for
+  // color-correction?
+  if (aApplyOverflowClip && aChangeColorCorrection) {
+    nsDisplayListCollection set2;
+    rv = aFrame->OverflowClip(aBuilder, set, set2, aClipRect);
+    NS_ENSURE_SUCCESS(rv, rv);
+    nsChangeColorCorrectionWrapper
+      ccWrap(aFrame->GetStyleVisibility()->mColorCorrection);
+    rv = ccWrap.WrapLists(aBuilder, aFrame, set2, aSet);
+  } else if (aApplyOverflowClip) {
+    rv = aFrame->OverflowClip(aBuilder, set, aSet, aClipRect);
+  } else {
+    NS_ASSERTION(aChangeColorCorrection, "unexpected");
+    nsChangeColorCorrectionWrapper
+      ccWrap(aFrame->GetStyleVisibility()->mColorCorrection);
+    rv = ccWrap.WrapLists(aBuilder, aFrame, set, aSet);
+  }
   
-  return aFrame->OverflowClip(aBuilder, set, aSet, aClipRect);
+  return rv;
 }
 
 #ifdef NS_DEBUG
 static void PaintDebugBorder(nsIFrame* aFrame, nsIRenderingContext* aCtx,
      const nsRect& aDirtyRect, nsPoint aPt) {
   nsRect r(aPt, aFrame->GetSize());
   if (aFrame->HasView()) {
     aCtx->SetColor(NS_RGB(0,0,255));
@@ -1487,32 +1530,36 @@ nsIFrame::BuildDisplayListForChild(nsDis
       (aFlags & DISPLAY_CHILD_FORCE_STACKING_CONTEXT)) {
     // If you change this, also change IsPseudoStackingContextFromStyle()
     pseudoStackingContext = PR_TRUE;
   }
   
   nsRect overflowClip;
   PRBool applyOverflowClip =
     ApplyOverflowClipping(aBuilder, aChild, disp, &overflowClip);
+  PRBool changeColorCorrection =
+    aChild->GetStyleVisibility()->mColorCorrection != 
+    GetStyleVisibility()->mColorCorrection;
   // Don't use overflowClip to restrict the dirty rect, since some of the
   // descendants may not be clipped by it. Even if we end up with unnecessary
   // display items, they'll be pruned during ComputeVisibility. Note that
   // this overflow-clipping here only applies to overflow:-moz-hidden-unscrollable;
   // overflow:hidden etc creates an nsHTML/XULScrollFrame which does its own
   // clipping.
 
   nsDisplayListBuilder::AutoIsRootSetter rootSetter(aBuilder, pseudoStackingContext);
   nsresult rv;
   if (!pseudoStackingContext) {
     // THIS IS THE COMMON CASE.
     // Not a pseudo or real stacking context. Do the simple thing and
     // return early.
-    if (applyOverflowClip) {
-      rv = BuildDisplayListWithOverflowClip(aBuilder, aChild, dirty, aLists,
-                                            overflowClip);
+    if (applyOverflowClip || changeColorCorrection) {
+      rv = BuildDisplayListWithWrappers(aBuilder, aChild, dirty, aLists,
+                                        overflowClip, applyOverflowClip,
+                                        changeColorCorrection);
     } else {
       rv = aChild->BuildDisplayList(aBuilder, dirty, aLists);
       if (NS_SUCCEEDED(rv)) {
         rv = aBuilder->DisplayCaret(aChild, dirty, aLists);
       }
     }
 #ifdef NS_DEBUG
     DisplayDebugBorders(aBuilder, aChild, aLists);
@@ -1542,19 +1589,21 @@ nsIFrame::BuildDisplayListForChild(nsDis
     nsRect clippedDirtyRect = dirty;
     if (applyAbsPosClipping) {
       // clipRect is in builder-reference-frame coordinates,
       // dirty/clippedDirtyRect are in aChild coordinates
       clippedDirtyRect.IntersectRect(clippedDirtyRect,
                                      clipRect - aBuilder->ToReferenceFrame(aChild));
     }
     
-    if (applyOverflowClip) {
-      rv = BuildDisplayListWithOverflowClip(aBuilder, aChild, clippedDirtyRect,
-                                            pseudoStack, overflowClip);
+    if (applyOverflowClip || changeColorCorrection) {
+      rv = BuildDisplayListWithWrappers(aBuilder, aChild, clippedDirtyRect,
+                                        pseudoStack, overflowClip,
+                                        applyOverflowClip,
+                                        changeColorCorrection);
     } else {
       rv = aChild->BuildDisplayList(aBuilder, clippedDirtyRect, pseudoStack);
       if (NS_SUCCEEDED(rv)) {
         rv = aBuilder->DisplayCaret(aChild, dirty, aLists);
       }
     }
     
     if (NS_SUCCEEDED(rv)) {
