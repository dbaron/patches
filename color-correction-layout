From: L. David Baron <dbaron@dbaron.org>

Implement '-moz-color-correction' for colors specified in markup and style.

diff --git a/layout/base/nsDisplayItemTypes.h b/layout/base/nsDisplayItemTypes.h
--- a/layout/base/nsDisplayItemTypes.h
+++ b/layout/base/nsDisplayItemTypes.h
@@ -53,16 +53,17 @@ enum Type {
   TYPE_BULLET,
   TYPE_BUTTON_BORDER_BACKGROUND,
   TYPE_BUTTON_BOX_SHADOW_OUTER,
   TYPE_BUTTON_FOREGROUND,
   TYPE_CANVAS,
   TYPE_CANVAS_BACKGROUND,
   TYPE_CANVAS_FOCUS,
   TYPE_CARET,
+  TYPE_CHANGE_COLOR_CORRECTION,
   TYPE_CHECKED_CHECKBOX,
   TYPE_CHECKED_RADIOBUTTON,
   TYPE_CLIP,
   TYPE_CLIP_ROUNDED_RECT,
   TYPE_COLUMN_RULE,
   TYPE_COMBOBOX_FOCUS,
   TYPE_EVENT_RECEIVER,
   TYPE_FIELDSET_BORDER_BACKGROUND,
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -2312,16 +2312,73 @@ bool nsDisplayZoom::ComputeVisibility(ns
   removed = removed.ConvertAppUnitsRoundIn(mAPD, mParentAPD);
   // aVisibleRegion = aVisibleRegion - removed (modulo any simplifications
   // SubtractFromVisibleRegion does)
   aBuilder->SubtractFromVisibleRegion(aVisibleRegion, removed);
 
   return retval;
 }
 
+nsDisplayChangeColorCorrection::nsDisplayChangeColorCorrection(
+        nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+        nsDisplayItem* aItem, PRUint8 aColorCorrection)
+    : nsDisplayWrapList(aBuilder, aFrame, aItem),
+      mColorCorrection(aColorCorrection)
+{
+  MOZ_COUNT_CTOR(nsDisplayChangeColorCorrection);
+}
+
+nsDisplayChangeColorCorrection::nsDisplayChangeColorCorrection(
+        nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+        nsDisplayList* aList, PRUint8 aColorCorrection)
+    : nsDisplayWrapList(aBuilder, aFrame, aList),
+      mColorCorrection(aColorCorrection)
+{
+  MOZ_COUNT_CTOR(nsDisplayChangeColorCorrection);
+}
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+nsDisplayChangeColorCorrection::~nsDisplayChangeColorCorrection()
+{
+  MOZ_COUNT_DTOR(nsDisplayChangeColorCorrection);
+}
+#endif
+
+void
+nsDisplayChangeColorCorrection::Paint(nsDisplayListBuilder* aBuilder,
+                                      nsRenderingContext* aCtx)
+{
+  PRUint8 colorCorr = GetColorCorrection();
+
+  gfxContext* ctx = aCtx->ThebesContext();
+
+  // FIXME: Set color correction on ctx.
+
+  nsDisplayWrapList::Paint(aBuilder, aCtx);
+
+  // FIXME: Restore color correction on ctx.
+}
+
+bool
+nsDisplayChangeColorCorrection::TryMerge(nsDisplayListBuilder* aBuilder,
+                                         nsDisplayItem* aItem)
+{
+  if (aItem->GetType() != TYPE_CHANGE_COLOR_CORRECTION)
+    return false;
+  nsDisplayChangeColorCorrection* other =
+    static_cast<nsDisplayChangeColorCorrection*>(aItem);
+  // aItem->GetUnderlyingFrame() returns non-null because it's
+  // nsDisplayChangeColorCorrection
+  // We can merge anytime the frames are changing to the same value.
+  if (other->GetColorCorrection() != GetColorCorrection())
+    return false;
+  mList.AppendToBottom(&other->mList);
+  return true;
+}
+
 ///////////////////////////////////////////////////
 // nsDisplayTransform Implementation
 //
 
 // Write #define UNIFIED_CONTINUATIONS here to have the transform property try
 // to transform content with continuations as one unified block instead of
 // several smaller ones.  This is currently disabled because it doesn't work
 // correctly, since when the frames are initially being reflowed, their
diff --git a/layout/base/nsDisplayList.h b/layout/base/nsDisplayList.h
--- a/layout/base/nsDisplayList.h
+++ b/layout/base/nsDisplayList.h
@@ -756,17 +756,18 @@ public:
    */
   virtual bool ComputeVisibility(nsDisplayListBuilder* aBuilder,
                                    nsRegion* aVisibleRegion,
                                    const nsRect& aAllowVisibleRegionExpansion)
   { return !mVisibleRect.IsEmpty(); }
 
   /**
    * Try to merge with the other item (which is below us in the display
-   * list). This gets used by nsDisplayClip to coalesce clipping operations
+   * list). This gets used by nsDisplayClip and
+   * nsDisplayChangeColorCorrection to coalesce clipping operations
    * (optimization), by nsDisplayOpacity to merge rendering for the same
    * content element into a single opacity group (correctness), and will be
    * used by nsDisplayOutline to merge multiple outlines for the same element
    * (also for correctness).
    * @return true if the merge was successful and the other item should be deleted
    */
   virtual bool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem) {
     return false;
@@ -2020,16 +2021,40 @@ public:
   // Get the app units per dev pixel ratio of the parent document.
   PRInt32 GetParentAppUnitsPerDevPixel() { return mParentAPD; }
 
 private:
   PRInt32 mAPD, mParentAPD;
 };
 
 /**
+ * The standard display item to paint a stacking context with translucency
+ * set by the stacking context root frame's 'opacity' style.
+ */
+class nsDisplayChangeColorCorrection : public nsDisplayWrapList {
+public:
+  nsDisplayChangeColorCorrection(nsDisplayListBuilder* aBuilder,
+                                 nsIFrame* aFrame, nsDisplayItem* aItem,
+                                 PRUint8 aColorCorrection);
+  nsDisplayChangeColorCorrection(nsDisplayListBuilder* aBuilder,
+                                 nsIFrame* aFrame, nsDisplayList* aList,
+                                 PRUint8 aColorCorrection);
+#ifdef NS_BUILD_REFCNT_LOGGING
+  virtual ~nsDisplayChangeColorCorrection();
+#endif
+
+  virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx);
+  virtual bool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
+  NS_DISPLAY_DECL_NAME("ChangeColorCorrection", TYPE_CHANGE_COLOR_CORRECTION)
+private:
+  PRUint8 mColorCorrection;
+  PRUint8 GetColorCorrection() { return mColorCorrection; }
+};
+
+/**
  * A display item to paint a stacking context with effects
  * set by the stacking context root frame's style.
  */
 class nsDisplaySVGEffects : public nsDisplayWrapList {
 public:
   nsDisplaySVGEffects(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
                       nsDisplayList* aList);
 #ifdef NS_BUILD_REFCNT_LOGGING
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -1509,42 +1509,85 @@ public:
                                   nsDisplayItem* aItem) {
     return new (aBuilder) nsDisplayClip(aBuilder, aItem->GetUnderlyingFrame(),
                                         aItem, mRect);
   }
 protected:
   nsRect    mRect;
 };
 
+class nsChangeColorCorrectionWrapper : public nsDisplayWrapper
+{
+public:
+  nsChangeColorCorrectionWrapper(PRUint8 aColorCorrection)
+    : mColorCorrection(aColorCorrection) {}
+  virtual nsDisplayItem* WrapList(nsDisplayListBuilder* aBuilder,
+                                  nsIFrame* aFrame, nsDisplayList* aList) {
+    // We are not a stacking context root. There is no valid underlying
+    // frame for the whole list.
+    return new (aBuilder) nsDisplayChangeColorCorrection(
+      aBuilder, nsnull, aList, mColorCorrection);
+  }
+  virtual nsDisplayItem* WrapItem(nsDisplayListBuilder* aBuilder,
+                                  nsDisplayItem* aItem) {
+    return new (aBuilder) nsDisplayChangeColorCorrection(
+      aBuilder, aItem->GetUnderlyingFrame(), aItem, mColorCorrection);
+  }
+protected:
+  PRUint8 mColorCorrection;
+};
+
 nsresult
 nsIFrame::OverflowClip(nsDisplayListBuilder*   aBuilder,
                        const nsDisplayListSet& aFromSet,
                        const nsDisplayListSet& aToSet,
                        const nsRect&           aClipRect,
                        const nscoord           aClipRadii[8],
                        bool                    aClipBorderBackground,
                        bool                    aClipAll)
 {
   nsOverflowClipWrapper wrapper(this, aClipRect, aClipRadii,
                                 aClipBorderBackground, aClipAll);
   return wrapper.WrapLists(aBuilder, this, aFromSet, aToSet);
 }
 
 static nsresult
-BuildDisplayListWithOverflowClip(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+BuildDisplayListWithWrappers(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
     const nsRect& aDirtyRect, const nsDisplayListSet& aSet,
-    const nsRect& aClipRect, const nscoord aClipRadii[8])
-{
+    const nsRect& aClipRect, const nscoord aClipRadii[8],
+    bool aApplyOverflowClip, bool aChangeColorCorrection)
+{
+  NS_PRECONDITION(aApplyOverflowClip || aChangeColorCorrection,
+                  "shouldn't have been called");
   nsDisplayListCollection set;
   nsresult rv = aFrame->BuildDisplayList(aBuilder, aDirtyRect, set);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = aBuilder->DisplayCaret(aFrame, aDirtyRect, aSet.Content());
   NS_ENSURE_SUCCESS(rv, rv);
 
-  return aFrame->OverflowClip(aBuilder, set, aSet, aClipRect, aClipRadii);
+  // REVIEW: Are there any other callers (e.g., other callers of
+  // nsIFrame::OverflowClip()) that need to do this wrapping for
+  // color-correction?
+  if (aApplyOverflowClip && aChangeColorCorrection) {
+    nsDisplayListCollection set2;
+    rv = aFrame->OverflowClip(aBuilder, set, set2, aClipRect, aClipRadii);
+    NS_ENSURE_SUCCESS(rv, rv);
+    nsChangeColorCorrectionWrapper
+      ccWrap(aFrame->GetStyleVisibility()->mColorCorrection);
+    rv = ccWrap.WrapLists(aBuilder, aFrame, set2, aSet);
+  } else if (aApplyOverflowClip) {
+    rv = aFrame->OverflowClip(aBuilder, set, aSet, aClipRect, aClipRadii);
+  } else {
+    NS_ASSERTION(aChangeColorCorrection, "unexpected");
+    nsChangeColorCorrectionWrapper
+      ccWrap(aFrame->GetStyleVisibility()->mColorCorrection);
+    rv = ccWrap.WrapLists(aBuilder, aFrame, set, aSet);
+  }
+
+  return rv;
 }
 
 #ifdef NS_DEBUG
 static void PaintDebugBorder(nsIFrame* aFrame, nsRenderingContext* aCtx,
      const nsRect& aDirtyRect, nsPoint aPt) {
   nsRect r(aPt, aFrame->GetSize());
   if (aFrame->HasView()) {
     aCtx->SetColor(NS_RGB(0,0,255));
@@ -1965,32 +2008,37 @@ nsIFrame::BuildDisplayListForChild(nsDis
   
   nsRect overflowClip;
   nscoord overflowClipRadii[8];
   bool applyOverflowClip =
     ApplyOverflowClipping(aBuilder, aChild, disp, &overflowClip);
   if (applyOverflowClip) {
     aChild->GetPaddingBoxBorderRadii(overflowClipRadii);
   }
+  bool changeColorCorrection =
+    aChild->GetStyleVisibility()->mColorCorrection != 
+    GetStyleVisibility()->mColorCorrection;
   // Don't use overflowClip to restrict the dirty rect, since some of the
   // descendants may not be clipped by it. Even if we end up with unnecessary
   // display items, they'll be pruned during ComputeVisibility. Note that
   // this overflow-clipping here only applies to overflow:-moz-hidden-unscrollable;
   // overflow:hidden etc creates an nsHTML/XULScrollFrame which does its own
   // clipping.
 
   nsDisplayListBuilder::AutoIsRootSetter rootSetter(aBuilder, pseudoStackingContext);
   nsresult rv;
   if (!pseudoStackingContext) {
     // THIS IS THE COMMON CASE.
     // Not a pseudo or real stacking context. Do the simple thing and
     // return early.
-    if (applyOverflowClip) {
-      rv = BuildDisplayListWithOverflowClip(aBuilder, aChild, dirty, aLists,
-                                            overflowClip, overflowClipRadii);
+    if (applyOverflowClip || changeColorCorrection) {
+      rv = BuildDisplayListWithWrappers(aBuilder, aChild, dirty, aLists,
+                                        overflowClip, overflowClipRadii,
+                                        applyOverflowClip,
+                                        changeColorCorrection);
     } else {
       rv = aChild->BuildDisplayList(aBuilder, dirty, aLists);
       if (NS_SUCCEEDED(rv)) {
         rv = aBuilder->DisplayCaret(aChild, dirty, aLists.Content());
       }
     }
 #ifdef NS_DEBUG
     DisplayDebugBorders(aBuilder, aChild, aLists);
@@ -2020,20 +2068,22 @@ nsIFrame::BuildDisplayListForChild(nsDis
     nsRect clippedDirtyRect = dirty;
     if (applyAbsPosClipping) {
       // clipRect is in builder-reference-frame coordinates,
       // dirty/clippedDirtyRect are in aChild coordinates
       clippedDirtyRect.IntersectRect(clippedDirtyRect,
                                      clipRect - aBuilder->ToReferenceFrame(aChild));
     }
     
-    if (applyOverflowClip) {
-      rv = BuildDisplayListWithOverflowClip(aBuilder, aChild, clippedDirtyRect,
-                                            pseudoStack, overflowClip,
-                                            overflowClipRadii);
+    if (applyOverflowClip || changeColorCorrection) {
+      rv = BuildDisplayListWithWrappers(aBuilder, aChild, clippedDirtyRect,
+                                        pseudoStack, overflowClip,
+                                        overflowClipRadii,
+                                        applyOverflowClip,
+                                        changeColorCorrection);
     } else {
       rv = aChild->BuildDisplayList(aBuilder, clippedDirtyRect, pseudoStack);
       if (NS_SUCCEEDED(rv)) {
         rv = aBuilder->DisplayCaret(aChild, dirty, pseudoStack.Content());
       }
     }
     
     if (NS_SUCCEEDED(rv)) {
