From: L. David Baron <dbaron@dbaron.org>

Implement '-moz-color-correction' for colors specified in markup and style.

diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -1189,17 +1189,73 @@ PRBool nsDisplayClip::TryMerge(nsDisplay
 }
 
 nsDisplayWrapList* nsDisplayClip::WrapWithClone(nsDisplayListBuilder* aBuilder,
                                                 nsDisplayItem* aItem) {
   return new (aBuilder)
     nsDisplayClip(aItem->GetUnderlyingFrame(), mClippingFrame, aItem, mClip);
 }
 
+nsDisplayChangeColorCorrection::nsDisplayChangeColorCorrection(
+        nsIFrame* aFrame, nsDisplayItem* aItem, PRUint8 aColorCorrection)
+    : nsDisplayWrapList(aFrame, aItem),
+      mColorCorrection(aColorCorrection)
+{
+  MOZ_COUNT_CTOR(nsDisplayChangeColorCorrection);
+}
 
+nsDisplayChangeColorCorrection::nsDisplayChangeColorCorrection(
+        nsIFrame* aFrame, nsDisplayList* aList, PRUint8 aColorCorrection)
+    : nsDisplayWrapList(aFrame, aList),
+      mColorCorrection(aColorCorrection)
+{
+  MOZ_COUNT_CTOR(nsDisplayChangeColorCorrection);
+}
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+nsDisplayChangeColorCorrection::~nsDisplayChangeColorCorrection()
+{
+  MOZ_COUNT_DTOR(nsDisplayChangeColorCorrection);
+}
+#endif
+
+void
+nsDisplayChangeColorCorrection::Paint(nsDisplayListBuilder* aBuilder,
+                                      nsIRenderingContext* aCtx)
+{
+  PRUint8 colorCorr = GetColorCorrection();
+
+  nsCOMPtr<nsIDeviceContext> devCtx;
+  aCtx->GetDeviceContext(*getter_AddRefs(devCtx));
+
+  gfxContext* ctx = aCtx->ThebesContext();
+
+  // FIXME: Set color correction on ctx.
+
+  nsDisplayWrapList::Paint(aBuilder, aCtx);
+
+  // FIXME: Restore color correction on ctx.
+}
+
+PRBool
+nsDisplayChangeColorCorrection::TryMerge(nsDisplayListBuilder* aBuilder,
+                                         nsDisplayItem* aItem)
+{
+  if (aItem->GetType() != TYPE_CHANGE_COLOR_CORRECTION)
+    return PR_FALSE;
+  nsDisplayChangeColorCorrection* other =
+    static_cast<nsDisplayChangeColorCorrection*>(aItem);
+  // aItem->GetUnderlyingFrame() returns non-null because it's
+  // nsDisplayChangeColorCorrection
+  // We can merge anytime the frames are changing to the same value.
+  if (other->GetColorCorrection() != GetColorCorrection())
+    return PR_FALSE;
+  mList.AppendToBottom(&other->mList);
+  return PR_TRUE;
+}
 
 ///////////////////////////////////////////////////
 // nsDisplayTransform Implementation
 //
 
 // Write #define UNIFIED_CONTINUATIONS here to have the transform property try
 // to transform content with continuations as one unified block instead of
 // several smaller ones.  This is currently disabled because it doesn't work
diff --git a/layout/base/nsDisplayList.h b/layout/base/nsDisplayList.h
--- a/layout/base/nsDisplayList.h
+++ b/layout/base/nsDisplayList.h
@@ -470,16 +470,17 @@ public:
    * For items whose type never gets checked, TYPE_GENERIC will suffice.
    */
   enum Type {
     TYPE_GENERIC,
 
     TYPE_BORDER,
     TYPE_CLIP,
     TYPE_OPACITY,
+    TYPE_CHANGE_COLOR_CORRECTION,
     TYPE_OUTLINE,
     TYPE_PLUGIN,
 #ifdef MOZ_SVG
     TYPE_SVG_EFFECTS,
 #endif
     TYPE_TRANSFORM,
     TYPE_WRAPLIST
   };
@@ -571,17 +572,18 @@ public:
    */
   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
                                    nsRegion* aVisibleRegion,
                                    nsRegion* aVisibleRegionBeforeMove)
   { return PR_TRUE; }
 
   /**
    * Try to merge with the other item (which is below us in the display
-   * list). This gets used by nsDisplayClip to coalesce clipping operations
+   * list). This gets used by nsDisplayClip and
+   * nsDisplayChangeColorCorrection to coalesce clipping operations
    * (optimization), by nsDisplayOpacity to merge rendering for the same
    * content element into a single opacity group (correctness), and will be
    * used by nsDisplayOutline to merge multiple outlines for the same element
    * (also for correctness).
    * @return PR_TRUE if the merge was successful and the other item should be deleted
    */
   virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem) {
     return PR_FALSE;
@@ -1431,16 +1433,39 @@ private:
   // The frame that is responsible for the clipping. This may be different
   // from mFrame because mFrame represents the content that is being
   // clipped, and for example may be used to obtain the z-index of the
   // content.
   nsIFrame* mClippingFrame;
   nsRect    mClip;
 };
 
+/**
+ * The standard display item to paint a stacking context with translucency
+ * set by the stacking context root frame's 'opacity' style.
+ */
+class nsDisplayChangeColorCorrection : public nsDisplayWrapList {
+public:
+  nsDisplayChangeColorCorrection(nsIFrame* aFrame, nsDisplayItem* aItem,
+                                 PRUint8 aColorCorrection);
+  nsDisplayChangeColorCorrection(nsIFrame* aFrame, nsDisplayList* aList,
+                                 PRUint8 aColorCorrection);
+#ifdef NS_BUILD_REFCNT_LOGGING
+  virtual ~nsDisplayChangeColorCorrection();
+#endif
+  
+  virtual Type GetType() { return TYPE_CHANGE_COLOR_CORRECTION; }
+  virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx);
+  virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
+  NS_DISPLAY_DECL_NAME("ChangeColorCorrection")
+private:
+  PRUint8 mColorCorrection;
+  PRUint8 GetColorCorrection() { return mColorCorrection; }
+};
+
 #ifdef MOZ_SVG
 /**
  * A display item to paint a stacking context with effects
  * set by the stacking context root frame's style.
  */
 class nsDisplaySVGEffects : public nsDisplayWrapList {
 public:
   nsDisplaySVGEffects(nsIFrame* aFrame, nsDisplayList* aList);
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -1133,16 +1133,37 @@ public:
     return new (aBuilder) nsDisplayClip(aItem->GetUnderlyingFrame(),
             mContainer, aItem, mRect);
   }
 protected:
   nsIFrame* mContainer;
   nsRect    mRect;
 };
 
+class nsChangeColorCorrectionWrapper : public nsDisplayWrapper
+{
+public:
+  nsChangeColorCorrectionWrapper(PRUint8 aColorCorrection)
+    : mColorCorrection(aColorCorrection) {}
+  virtual nsDisplayItem* WrapList(nsDisplayListBuilder* aBuilder,
+                                  nsIFrame* aFrame, nsDisplayList* aList) {
+    // We are not a stacking context root. There is no valid underlying
+    // frame for the whole list.
+    return new (aBuilder) nsDisplayChangeColorCorrection(
+      nsnull, aList, mColorCorrection);
+  }
+  virtual nsDisplayItem* WrapItem(nsDisplayListBuilder* aBuilder,
+                                  nsDisplayItem* aItem) {
+    return new (aBuilder) nsDisplayChangeColorCorrection(
+      aItem->GetUnderlyingFrame(), aItem, mColorCorrection);
+  }
+protected:
+  PRUint8 mColorCorrection;
+};
+
 nsresult
 nsIFrame::OverflowClip(nsDisplayListBuilder*   aBuilder,
                        const nsDisplayListSet& aFromSet,
                        const nsDisplayListSet& aToSet,
                        const nsRect&           aClipRect,
                        PRBool                  aClipBorderBackground,
                        PRBool                  aClipAll)
 {
