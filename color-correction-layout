From: L. David Baron <dbaron@dbaron.org>

Implement '-moz-color-correction' for colors specified in markup and style.

diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -1189,17 +1189,63 @@ PRBool nsDisplayClip::TryMerge(nsDisplay
 }
 
 nsDisplayWrapList* nsDisplayClip::WrapWithClone(nsDisplayListBuilder* aBuilder,
                                                 nsDisplayItem* aItem) {
   return new (aBuilder)
     nsDisplayClip(aItem->GetUnderlyingFrame(), mClippingFrame, aItem, mClip);
 }
 
+nsDisplayChangeColorCorrection::nsDisplayChangeColorCorrection(
+                                        nsIFrame* aFrame, nsDisplayList* aList)
+    : nsDisplayWrapList(aFrame, aList)
+{
+  MOZ_COUNT_CTOR(nsDisplayChangeColorCorrection);
+}
 
+#ifdef NS_BUILD_REFCNT_LOGGING
+nsDisplayChangeColorCorrection::~nsDisplayChangeColorCorrection()
+{
+  MOZ_COUNT_DTOR(nsDisplayChangeColorCorrection);
+}
+#endif
+
+void
+nsDisplayChangeColorCorrection::Paint(nsDisplayListBuilder* aBuilder,
+                                      nsIRenderingContext* aCtx)
+{
+  PRUint8 colorCorr = mFrame->GetStyleVisibility()->mColorCorrection;
+
+  nsCOMPtr<nsIDeviceContext> devCtx;
+  aCtx->GetDeviceContext(*getter_AddRefs(devCtx));
+
+  gfxContext* ctx = aCtx->ThebesContext();
+
+  // FIXME: Set color correction on ctx.
+
+  nsDisplayWrapList::Paint(aBuilder, aCtx);
+
+  // FIXME: Restore color correction on ctx.
+}
+
+PRBool
+nsDisplayChangeColorCorrection::TryMerge(nsDisplayListBuilder* aBuilder,
+                                         nsDisplayItem* aItem)
+{
+  if (aItem->GetType() != TYPE_CHANGE_COLOR_CORRECTION)
+    return PR_FALSE;
+  nsDisplayChangeColorCorrection* other =
+    static_cast<nsDisplayChangeColorCorrection*>(aItem);
+  // aItem->GetUnderlyingFrame() returns non-null because it's
+  // nsDisplayChangeColorCorrection
+  if (other->GetUnderlyingFrame()->GetContent() != mFrame->GetContent())
+    return PR_FALSE;
+  mList.AppendToBottom(&other->mList);
+  return PR_TRUE;
+}
 
 ///////////////////////////////////////////////////
 // nsDisplayTransform Implementation
 //
 
 // Write #define UNIFIED_CONTINUATIONS here to have the transform property try
 // to transform content with continuations as one unified block instead of
 // several smaller ones.  This is currently disabled because it doesn't work
diff --git a/layout/base/nsDisplayList.h b/layout/base/nsDisplayList.h
--- a/layout/base/nsDisplayList.h
+++ b/layout/base/nsDisplayList.h
@@ -470,16 +470,17 @@ public:
    * For items whose type never gets checked, TYPE_GENERIC will suffice.
    */
   enum Type {
     TYPE_GENERIC,
 
     TYPE_BORDER,
     TYPE_CLIP,
     TYPE_OPACITY,
+    TYPE_CHANGE_COLOR_CORRECTION,
     TYPE_OUTLINE,
     TYPE_PLUGIN,
 #ifdef MOZ_SVG
     TYPE_SVG_EFFECTS,
 #endif
     TYPE_TRANSFORM,
     TYPE_WRAPLIST
   };
@@ -571,17 +572,18 @@ public:
    */
   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
                                    nsRegion* aVisibleRegion,
                                    nsRegion* aVisibleRegionBeforeMove)
   { return PR_TRUE; }
 
   /**
    * Try to merge with the other item (which is below us in the display
-   * list). This gets used by nsDisplayClip to coalesce clipping operations
+   * list). This gets used by nsDisplayClip and
+   * nsDisplayChangeColorCorrection to coalesce clipping operations
    * (optimization), by nsDisplayOpacity to merge rendering for the same
    * content element into a single opacity group (correctness), and will be
    * used by nsDisplayOutline to merge multiple outlines for the same element
    * (also for correctness).
    * @return PR_TRUE if the merge was successful and the other item should be deleted
    */
   virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem) {
     return PR_FALSE;
@@ -1431,16 +1433,33 @@ private:
   // The frame that is responsible for the clipping. This may be different
   // from mFrame because mFrame represents the content that is being
   // clipped, and for example may be used to obtain the z-index of the
   // content.
   nsIFrame* mClippingFrame;
   nsRect    mClip;
 };
 
+/**
+ * The standard display item to paint a stacking context with translucency
+ * set by the stacking context root frame's 'opacity' style.
+ */
+class nsDisplayChangeColorCorrection : public nsDisplayWrapList {
+public:
+  nsDisplayChangeColorCorrection(nsIFrame* aFrame, nsDisplayList* aList);
+#ifdef NS_BUILD_REFCNT_LOGGING
+  virtual ~nsDisplayChangeColorCorrection();
+#endif
+  
+  virtual Type GetType() { return TYPE_CHANGE_COLOR_CORRECTION; }
+  virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx);
+  virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
+  NS_DISPLAY_DECL_NAME("ChangeColorCorrection")
+};
+
 #ifdef MOZ_SVG
 /**
  * A display item to paint a stacking context with effects
  * set by the stacking context root frame's style.
  */
 class nsDisplaySVGEffects : public nsDisplayWrapList {
 public:
   nsDisplaySVGEffects(nsIFrame* aFrame, nsDisplayList* aList);
