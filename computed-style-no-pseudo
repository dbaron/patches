From: L. David Baron <dbaron@dbaron.org>

Make computed style (and canvas text styling, which shares the same code) avoid using style data that was influenced by pseudo-elements.  (Bug 505515)  r=bzbarsky

diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -90,18 +90,16 @@
 
 static nsComputedDOMStyle *sCachedComputedDOMStyle;
 
 nsresult
 NS_NewComputedDOMStyle(nsIDOMElement *aElement, const nsAString &aPseudoElt,
                        nsIPresShell *aPresShell,
                        nsComputedDOMStyle **aComputedStyle)
 {
-  NS_ENSURE_ARG_POINTER(aComputedStyle);
-
   nsRefPtr<nsComputedDOMStyle> computedStyle;
   if (sCachedComputedDOMStyle) {
     // There's an unused nsComputedDOMStyle cached, use it.
     // But before we use it, re-initialize the object.
 
     // Oh yeah baby, placement new!
     computedStyle = new (sCachedComputedDOMStyle) nsComputedDOMStyle();
 
@@ -297,17 +295,16 @@ nsComputedDOMStyle::GetLength(PRUint32* 
 
   return NS_OK;
 }
 
 
 NS_IMETHODIMP
 nsComputedDOMStyle::GetParentRule(nsIDOMCSSRule** aParentRule)
 {
-  NS_ENSURE_ARG_POINTER(aParentRule);
   *aParentRule = nsnull;
 
   return NS_OK;
 }
 
 
 NS_IMETHODIMP
 nsComputedDOMStyle::GetPropertyValue(const nsAString& aPropertyName,
@@ -327,17 +324,18 @@ nsComputedDOMStyle::GetPropertyValue(con
   return rv;
 }
 
 
 NS_IMETHODIMP
 nsComputedDOMStyle::GetPropertyCSSValue(const nsAString& aPropertyName,
                                         nsIDOMCSSValue** aReturn)
 {
-  NS_ENSURE_ARG_POINTER(aReturn);
+  NS_ASSERTION(!mStyleContextHolder, "bad state");
+
   *aReturn = nsnull;
 
   nsCOMPtr<nsIDocument> document = do_QueryReferent(mDocumentWeak);
   NS_ENSURE_TRUE(document, NS_ERROR_NOT_AVAILABLE);
 
   nsCSSProperty prop = nsCSSProps::LookupProperty(aPropertyName);
 
   const ComputedStyleMapEntry* propEntry = nsnull;
@@ -372,39 +370,59 @@ nsComputedDOMStyle::GetPropertyCSSValue(
 #endif
 
   mPresShell = document->GetPrimaryShell();
   NS_ENSURE_TRUE(mPresShell && mPresShell->GetPresContext(),
                  NS_ERROR_NOT_AVAILABLE);
 
   mOuterFrame = mPresShell->GetPrimaryFrameFor(mContent);
   mInnerFrame = mOuterFrame;
-  if (!mOuterFrame || mPseudo) {
-    // Need to resolve a style context
-    mStyleContextHolder =
-      nsInspectorCSSUtils::GetStyleContextForContent(mContent,
-                                                     mPseudo,
-                                                     mPresShell);
-    NS_ENSURE_TRUE(mStyleContextHolder, NS_ERROR_OUT_OF_MEMORY);
-  } else {
+  if (mOuterFrame && !mPseudo) {
     nsIAtom* type = mOuterFrame->GetType();
     if (type == nsGkAtoms::tableOuterFrame) {
       // If the frame is an outer table frame then we should get the style
       // from the inner table frame.
       mInnerFrame = mOuterFrame->GetFirstChild(nsnull);
       NS_ASSERTION(mInnerFrame, "Outer table must have an inner");
       NS_ASSERTION(!mInnerFrame->GetNextSibling(),
                    "Outer table frames should have just one child, the inner "
                    "table");
     }
 
     mStyleContextHolder = mInnerFrame->GetStyleContext();
     NS_ASSERTION(mStyleContextHolder, "Frame without style context?");
   }
 
+  if (!mStyleContextHolder || mStyleContextHolder->HasPseudoElementData()) {
+#ifdef DEBUG
+    if (mStyleContextHolder) {
+      // We want to check that going through this path because of
+      // HasPseudoElementData is rare, because it slows us down a good
+      // bit.  So check that we're really inside something associated
+      // with a pseudo-element that contains elements.
+      nsStyleContext *topWithPseudoElementData = mStyleContextHolder;
+      while (topWithPseudoElementData->GetParent()->HasPseudoElementData()) {
+        topWithPseudoElementData = topWithPseudoElementData->GetParent();
+      }
+      NS_ASSERTION(nsCSSPseudoElements::PseudoElementContainsElements(
+                     topWithPseudoElementData->GetPseudoType()),
+                   "we should be in a pseudo-element that is expected to "
+                   "contain elements");
+    }
+#endif
+    // Need to resolve a style context
+    mStyleContextHolder =
+      nsInspectorCSSUtils::GetStyleContextForContent(mContent,
+                                                     mPseudo,
+                                                     mPresShell);
+    NS_ENSURE_TRUE(mStyleContextHolder, NS_ERROR_OUT_OF_MEMORY);
+    NS_ASSERTION(mPseudo || !mStyleContextHolder->HasPseudoElementData(),
+                 "should not have pseudo-element data");
+  }
+
   // Call our pointer-to-member-function.
   nsresult rv = (this->*(propEntry->mGetter))(aReturn);
 
   if (NS_FAILED(rv)) {
     *aReturn = nsnull;
   }
 
   mOuterFrame = nsnull;
diff --git a/layout/style/nsInspectorCSSUtils.cpp b/layout/style/nsInspectorCSSUtils.cpp
--- a/layout/style/nsInspectorCSSUtils.cpp
+++ b/layout/style/nsInspectorCSSUtils.cpp
@@ -96,18 +96,16 @@ nsInspectorCSSUtils::IsRuleNodeRoot(nsRu
     return NS_OK;
 }
 
 /* static */
 nsStyleContext*
 nsInspectorCSSUtils::GetStyleContextForFrame(nsIFrame* aFrame)
 {
     nsStyleContext* styleContext = aFrame->GetStyleContext();
-    if (!styleContext)
-        return nsnull;
 
     /* For tables the primary frame is the "outer frame" but the style
      * rules are applied to the "inner frame".  Luckily, the "outer
      * frame" actually inherits style from the "inner frame" so we can
      * just move one level up in the style context hierarchy....
      */
     if (aFrame->GetType() == nsGkAtoms::tableOuterFrame)
         return styleContext->GetParent();
@@ -121,20 +119,24 @@ nsInspectorCSSUtils::GetStyleContextForC
                                                nsIAtom* aPseudo,
                                                nsIPresShell* aPresShell)
 {
     if (!aPseudo) {
         aPresShell->FlushPendingNotifications(Flush_Style);
         nsIFrame* frame = aPresShell->GetPrimaryFrameFor(aContent);
         if (frame) {
             nsStyleContext* result = GetStyleContextForFrame(frame);
-            // this function returns an addrefed style context
-            if (result)
+            // Don't use the style context if it was influenced by
+            // pseudo-elements, since then it's not the primary style
+            // for this element.
+            if (!result->HasPseudoElementData()) {
+                // this function returns an addrefed style context
                 result->AddRef();
-            return result;
+                return result;
+            }
         }
     }
 
     // No frame has been created or we have a pseudo, so resolve the
     // style ourselves
     nsRefPtr<nsStyleContext> parentContext;
     nsIContent* parent = aPseudo ? aContent : aContent->GetParent();
     if (parent)
diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -100,16 +100,17 @@ _TEST_FILES =	test_acid3_test46.html \
 		test_bug437915.html \
 		test_bug450191.html \
 		test_bug453896_deck.html \
 		test_bug470769.html \
 		test_bug499655.html \
 		test_bug499655.xhtml \
 		test_cascade.html \
 		test_compute_data_with_start_struct.html \
+		test_computed_style_no_pseudo.html \
 		test_css_eof_handling.html \
 		test_descriptor_storage.html \
 		test_descriptor_syntax_errors.html \
 		test_dont_use_document_colors.html \
 		test_font_face_parser.html \
 		test_garbage_at_end_of_declarations.html \
 		test_hover.html \
 		test_inherit_computation.html \
diff --git a/layout/style/test/test_computed_style_no_pseudo.html b/layout/style/test/test_computed_style_no_pseudo.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_computed_style_no_pseudo.html
@@ -0,0 +1,45 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=505515
+-->
+<head>
+  <title>Test for Bug 505515</title>
+  <script type="application/javascript" src="/MochiKit/packed.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+  <style type="text/css">
+
+  #display { color: black; background: white; }
+  #display:first-line { color: blue; }
+
+  </style>
+</head>
+<body onload="run()">
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=505515">Mozilla Bug 505515</a>
+<p id="display" style="width: 30em">This <span id="sp">is</span> some text in which the first line is in a different color.</p>
+<pre id="test">
+<script type="application/javascript">
+
+SimpleTest.waitForExplicitFinish();
+
+/** Test for Bug 505515 **/
+
+function run() {
+  var p = document.getElementById("display");
+  var span = document.getElementById("sp");
+
+  isnot(span.offsetWidth, 0,
+        "span should have width (and we flushed layout)");
+  is(getComputedStyle(span, "").color, "rgb(0, 0, 0)",
+     "span should be black");
+  is(getComputedStyle(p, "").color, "rgb(0, 0, 0)",
+     "p should be black too");
+
+  SimpleTest.finish();
+}
+
+</script>
+</pre>
+</body>
+</html>
