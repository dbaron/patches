From: L. David Baron <dbaron@dbaron.org>

Bug 781360 patch 1:  Rename nsStyleContext::GetRuleNode to RuleNode, since it can never return null.

This makes it conform to our convention that getters returning pointers
that can never be null do not begin with "Get".

nsStyleContext's rule node is never null because we require a rule node
in order to construct a style context.

diff --git a/layout/base/nsFrameManager.cpp b/layout/base/nsFrameManager.cpp
--- a/layout/base/nsFrameManager.cpp
+++ b/layout/base/nsFrameManager.cpp
@@ -614,17 +614,17 @@ VerifyContextParent(nsPresContext* aPres
     }
   }
 
   nsStyleContext* childStyleIfVisited = aContext->GetStyleIfVisited();
   // Either childStyleIfVisited has aContext->GetParent()->GetStyleIfVisited()
   // as the parent or it has a different rulenode from aContext _and_ has
   // aContext->GetParent() as the parent.
   if (childStyleIfVisited &&
-      !((childStyleIfVisited->GetRuleNode() != aContext->GetRuleNode() &&
+      !((childStyleIfVisited->RuleNode() != aContext->RuleNode() &&
          childStyleIfVisited->GetParent() == aContext->GetParent()) ||
         childStyleIfVisited->GetParent() ==
           aContext->GetParent()->GetStyleIfVisited())) {
     NS_ERROR("Visited style has wrong parent");
     DumpContext(aFrame, aContext);
     fputs("\n", stdout);
   }
 }
@@ -1273,17 +1273,17 @@ nsFrameManager::ReResolveStyleContext(ns
         newContext = styleSet->ResolveStyleFor(element, parentContext,
                                                aTreeMatchContext);
       }
     }
 
     NS_ASSERTION(newContext, "failed to get new style context");
     if (newContext) {
       if (!parentContext) {
-        if (oldContext->GetRuleNode() == newContext->GetRuleNode() &&
+        if (oldContext->RuleNode() == newContext->RuleNode() &&
             oldContext->IsLinkContext() == newContext->IsLinkContext() &&
             oldContext->RelevantLinkVisited() ==
               newContext->RelevantLinkVisited()) {
           // We're the root of the style context tree and the new style
           // context returned has the same rule node.  This means that
           // we can use FindChildWithRules to keep a lot of the old
           // style contexts around.  However, we need to start from the
           // same root.
diff --git a/layout/generic/nsFirstLetterFrame.cpp b/layout/generic/nsFirstLetterFrame.cpp
--- a/layout/generic/nsFirstLetterFrame.cpp
+++ b/layout/generic/nsFirstLetterFrame.cpp
@@ -61,17 +61,17 @@ nsFirstLetterFrame::Init(nsIContent*    
 {
   nsRefPtr<nsStyleContext> newSC;
   if (aPrevInFlow) {
     // Get proper style context for ourselves.  We're creating the frame
     // that represents everything *except* the first letter, so just create
     // a style context like we would for a text node.
     nsStyleContext* parentStyleContext = mStyleContext->GetParent();
     if (parentStyleContext) {
-      newSC = mStyleContext->GetRuleNode()->GetPresContext()->StyleSet()->
+      newSC = mStyleContext->RuleNode()->GetPresContext()->StyleSet()->
         ResolveStyleForNonElement(parentStyleContext);
       if (newSC)
         SetStyleContextWithoutNotification(newSC);
     }
   }
 
   return nsContainerFrame::Init(aContent, aParent, aPrevInFlow);
 }
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -561,17 +561,17 @@ public:
   typedef mozilla::layout::FrameChildListID ChildListID;
   typedef mozilla::layout::FrameChildListIDs ChildListIDs;
   typedef mozilla::layout::FrameChildListIterator ChildListIterator;
   typedef mozilla::layout::FrameChildListArrayIterator ChildListArrayIterator;
 
   NS_DECL_QUERYFRAME_TARGET(nsIFrame)
 
   nsPresContext* PresContext() const {
-    return StyleContext()->GetRuleNode()->GetPresContext();
+    return StyleContext()->RuleNode()->GetPresContext();
   }
 
   /**
    * Called to initialize the frame. This is called immediately after creating
    * the frame.
    *
    * If the frame is a continuing frame, then aPrevInFlow indicates the previous
    * frame (the frame that was split).
diff --git a/layout/inspector/src/inDOMUtils.cpp b/layout/inspector/src/inDOMUtils.cpp
--- a/layout/inspector/src/inDOMUtils.cpp
+++ b/layout/inspector/src/inDOMUtils.cpp
@@ -425,17 +425,17 @@ inDOMUtils::GetRuleNodeForContent(nsICon
   NS_ENSURE_TRUE(presContext, NS_ERROR_UNEXPECTED);
 
   bool safe = presContext->EnsureSafeToHandOutCSSRules();
   NS_ENSURE_TRUE(safe, NS_ERROR_OUT_OF_MEMORY);
 
   nsRefPtr<nsStyleContext> sContext =
     nsComputedDOMStyle::GetStyleContextForElement(aContent->AsElement(), aPseudo, presShell);
   if (sContext) {
-    *aRuleNode = sContext->GetRuleNode();
+    *aRuleNode = sContext->RuleNode();
     sContext.forget(aStyleContext);
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 inDOMUtils::GetUsedFontFaces(nsIDOMRange* aRange,
                              nsIDOMFontFaceList** aFontFaceList)
diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -359,17 +359,17 @@ nsComputedDOMStyle::GetStyleContextForEl
     sc = styleSet->ResolvePseudoElementStyle(aElement, type, parentContext);
   } else {
     sc = styleSet->ResolveStyleFor(aElement, parentContext);
   }
 
   if (aStyleType == eDefaultOnly) {
     // We really only want the user and UA rules.  Filter out the other ones.
     nsTArray< nsCOMPtr<nsIStyleRule> > rules;
-    for (nsRuleNode* ruleNode = sc->GetRuleNode();
+    for (nsRuleNode* ruleNode = sc->RuleNode();
          !ruleNode->IsRoot();
          ruleNode = ruleNode->GetParent()) {
       if (ruleNode->GetLevel() == nsStyleSet::eAgentSheet ||
           ruleNode->GetLevel() == nsStyleSet::eUserSheet) {
         rules.AppendElement(ruleNode->GetRule());
       }
     }
 
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -3422,17 +3422,17 @@ nsRuleNode::SetGenericFont(nsPresContext
     nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Font), dataArray.get(),
                         aPresContext, context);
     ruleData.mValueOffsets[eStyleStruct_Font] = 0;
 
     // Trimmed down version of ::WalkRuleTree() to re-apply the style rules
     // Note that we *do* need to do this for our own data, since what is
     // in |fontData| in ComputeFontData is only for the rules below
     // aStartStruct.
-    for (nsRuleNode* ruleNode = context->GetRuleNode(); ruleNode;
+    for (nsRuleNode* ruleNode = context->RuleNode(); ruleNode;
          ruleNode = ruleNode->GetParent()) {
       if (ruleNode->mNoneBits & fontBit)
         // no more font rules on this branch, get out
         break;
 
       nsIStyleRule *rule = ruleNode->GetRule();
       if (rule) {
         ruleData.mLevel = ruleNode->GetLevel();
@@ -7937,17 +7937,17 @@ nsRuleNode::HasAuthorSpecifiedRules(nsSt
   // UA-important declarations.  But we do want to catch explicit inherit
   // styling in those and check our parent style context to see whether we have
   // user styling for those properties.  Note that we don't care here about
   // inheritance due to lack of a specified value, since all the properties we
   // care about are reset properties.
   bool haveExplicitUAInherit;
   do {
     haveExplicitUAInherit = false;
-    for (nsRuleNode* ruleNode = styleContext->GetRuleNode(); ruleNode;
+    for (nsRuleNode* ruleNode = styleContext->RuleNode(); ruleNode;
          ruleNode = ruleNode->GetParent()) {
       nsIStyleRule *rule = ruleNode->GetRule();
       if (rule) {
         ruleData.mLevel = ruleNode->GetLevel();
         ruleData.mIsImportantRule = ruleNode->IsImportantRule();
 
         rule->MapRuleInfoInto(&ruleData);
 
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -2324,17 +2324,17 @@ nsStyleAnimation::ComputeValue(nsCSSProp
     // Force walk of rule tree
     nsStyleStructID sid = nsCSSProps::kSIDTable[aProperty];
     tmpStyleContext->GetStyleData(sid);
 
     // If the rule node will have cached style data if the value is not
     // context-sensitive. So if there's nothing cached, it's not context
     // sensitive.
     *aIsContextSensitive =
-      !tmpStyleContext->GetRuleNode()->NodeHasCachedData(sid);
+      !tmpStyleContext->RuleNode()->NodeHasCachedData(sid);
   }
 
   // If we're not concerned whether the property is context sensitive then just
   // add the rule to a new temporary style context alongside the target
   // element's style context.
   // Also, if we previously discovered that this property IS context-sensitive
   // then we need to throw the temporary style context out since the property's
   // value may have been biased by the 'initial' values supplied.
diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -52,17 +52,17 @@ nsStyleContext::nsStyleContext(nsStyleCo
                     "pseudo element bits no longer fit in a uint32_t");
 
   mNextSibling = this;
   mPrevSibling = this;
   if (mParent) {
     mParent->AddRef();
     mParent->AddChild(this);
 #ifdef DEBUG
-    nsRuleNode *r1 = mParent->GetRuleNode(), *r2 = aRuleNode;
+    nsRuleNode *r1 = mParent->RuleNode(), *r2 = aRuleNode;
     while (r1->GetParent())
       r1 = r1->GetParent();
     while (r2->GetParent())
       r2 = r2->GetParent();
     NS_ASSERTION(r1 == r2, "must be in the same rule tree as parent");
 #endif
   }
 
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -97,19 +97,19 @@ public:
   nsCSSPseudoElements::Type GetPseudoType() const {
     return static_cast<nsCSSPseudoElements::Type>(mBits >>
                                                   NS_STYLE_CONTEXT_TYPE_SHIFT);
   }
 
   // Find, if it already exists *and is easily findable* (i.e., near the
   // start of the child list), a style context whose:
   //  * GetPseudo() matches aPseudoTag
-  //  * GetRuleNode() matches aRules
+  //  * RuleNode() matches aRules
   //  * !GetStyleIfVisited() == !aRulesIfVisited, and, if they're
-  //    non-null, GetStyleIfVisited()->GetRuleNode() == aRulesIfVisited
+  //    non-null, GetStyleIfVisited()->RuleNode() == aRulesIfVisited
   //  * RelevantLinkVisited() == aRelevantLinkVisited
   already_AddRefed<nsStyleContext>
   FindChildWithRules(const nsIAtom* aPseudoTag, nsRuleNode* aRules,
                      nsRuleNode* aRulesIfVisited,
                      bool aRelevantLinkVisited);
 
   // Does this style context or any of its ancestors have text
   // decoration lines?
@@ -200,17 +200,17 @@ public:
                    "Going to leak styledata");                              \
       slot = aStruct;                                                       \
     }
 #define STYLE_STRUCT_RESET(name_, checkdata_cb_, ctor_args_) /* nothing */
   #include "nsStyleStructList.h"
   #undef STYLE_STRUCT_RESET
   #undef STYLE_STRUCT_INHERITED
 
-  nsRuleNode* GetRuleNode() { return mRuleNode; }
+  nsRuleNode* RuleNode() { return mRuleNode; }
   void AddStyleBit(const uint32_t& aBit) { mBits |= aBit; }
 
   /*
    * Mark this style context's rule node (and its ancestors) to prevent
    * it from being garbage collected.
    */
   void Mark();
 
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -184,17 +184,17 @@ nsStyleSet::BeginReconstruct()
 
 void
 nsStyleSet::EndReconstruct()
 {
   NS_ASSERTION(mInReconstruct, "Unmatched begin/end?");
   mInReconstruct = false;
 #ifdef DEBUG
   for (int32_t i = mRoots.Length() - 1; i >= 0; --i) {
-    nsRuleNode *n = mRoots[i]->GetRuleNode();
+    nsRuleNode *n = mRoots[i]->RuleNode();
     while (n->GetParent()) {
       n = n->GetParent();
     }
     // Since nsStyleContext's mParent and mRuleNode are immutable, and
     // style contexts own their parents, and nsStyleContext asserts in
     // its constructor that the style context and its parent are in the
     // same rule tree, we don't need to check any of the children of
     // mRoots; we only need to check the rule nodes of mRoots
@@ -803,22 +803,22 @@ nsStyleSet::GetContext(nsStyleContext* a
   if (aFlags & eDoAnimation) {
     // Normally the animation manager has already added the correct
     // style rule.  However, if the animation-name just changed, it
     // might have been wrong.  So ask it to double-check based on the
     // resulting style context.
     nsIStyleRule *oldAnimRule = GetAnimationRule(aRuleNode);
     nsIStyleRule *animRule = PresContext()->AnimationManager()->
       CheckAnimationRule(result, aElementForAnimation);
-    NS_ABORT_IF_FALSE(result->GetRuleNode() == aRuleNode,
+    NS_ABORT_IF_FALSE(result->RuleNode() == aRuleNode,
                       "unexpected rule node");
     NS_ABORT_IF_FALSE(!result->GetStyleIfVisited() == !aVisitedRuleNode,
                       "unexpected visited rule node");
     NS_ABORT_IF_FALSE(!aVisitedRuleNode ||
-                      result->GetStyleIfVisited()->GetRuleNode() ==
+                      result->GetStyleIfVisited()->RuleNode() ==
                         aVisitedRuleNode,
                       "unexpected visited rule node");
     if (oldAnimRule != animRule) {
       nsRuleNode *ruleNode =
         ReplaceAnimationRule(aRuleNode, oldAnimRule, animRule);
       nsRuleNode *visitedRuleNode = aVisitedRuleNode
         ? ReplaceAnimationRule(aVisitedRuleNode, oldAnimRule, animRule)
         : nullptr;
@@ -1225,29 +1225,29 @@ nsStyleSet::ResolveStyleForRules(nsStyle
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleByAddingRules(nsStyleContext* aBaseContext,
                                       const nsCOMArray<nsIStyleRule> &aRules)
 {
   NS_ENSURE_FALSE(mInShutdown, nullptr);
 
   nsRuleWalker ruleWalker(mRuleTree);
-  ruleWalker.SetCurrentNode(aBaseContext->GetRuleNode());
+  ruleWalker.SetCurrentNode(aBaseContext->RuleNode());
   // FIXME: Perhaps this should be passed in, but it probably doesn't
   // matter.
   ruleWalker.SetLevel(eDocSheet, false, false);
   for (int32_t i = 0; i < aRules.Count(); i++) {
     ruleWalker.ForwardOnPossiblyCSSRule(aRules.ObjectAt(i));
   }
 
   nsRuleNode *ruleNode = ruleWalker.CurrentNode();
   nsRuleNode *visitedRuleNode = nullptr;
 
   if (aBaseContext->GetStyleIfVisited()) {
-    ruleWalker.SetCurrentNode(aBaseContext->GetStyleIfVisited()->GetRuleNode());
+    ruleWalker.SetCurrentNode(aBaseContext->GetStyleIfVisited()->RuleNode());
     for (int32_t i = 0; i < aRules.Count(); i++) {
       ruleWalker.ForwardOnPossiblyCSSRule(aRules.ObjectAt(i));
     }
     visitedRuleNode = ruleWalker.CurrentNode();
   }
 
   uint32_t flags = eNoFlags;
   if (aBaseContext->IsLinkContext()) {
@@ -1658,17 +1658,17 @@ nsStyleSet::ReparentStyleContext(nsStyle
   // during style reresolution if the style context pointer hasn't changed.
   if (aStyleContext->GetParent() == aNewParentContext) {
     aStyleContext->AddRef();
     return aStyleContext;
   }
 
   nsIAtom* pseudoTag = aStyleContext->GetPseudo();
   nsCSSPseudoElements::Type pseudoType = aStyleContext->GetPseudoType();
-  nsRuleNode* ruleNode = aStyleContext->GetRuleNode();
+  nsRuleNode* ruleNode = aStyleContext->RuleNode();
 
   // Skip transition rules as needed just like
   // nsTransitionManager::WalkTransitionRule would.
   bool skipAnimationRules = PresContext()->IsProcessingRestyles() &&
     !PresContext()->IsProcessingAnimationStyleChange();
   if (skipAnimationRules) {
     // Make sure that we're not using transition rules or animation rules for
     // our new style context.  If we need them, an animation restyle will
@@ -1681,17 +1681,17 @@ nsStyleSet::ReparentStyleContext(nsStyle
 
   nsRuleNode* visitedRuleNode = nullptr;
   nsStyleContext* visitedContext = aStyleContext->GetStyleIfVisited();
   // Reparenting a style context just changes where we inherit from,
   // not what rules we match or what our DOM looks like.  In
   // particular, it doesn't change whether this is a style context for
   // a link.
   if (visitedContext) {
-     visitedRuleNode = visitedContext->GetRuleNode();
+     visitedRuleNode = visitedContext->RuleNode();
      // Again, skip transition rules as needed
      if (skipAnimationRules) {
       // FIXME do something here for animations?
        visitedRuleNode =
          SkipAnimationRules(visitedRuleNode, aElement,
                             pseudoType !=
                               nsCSSPseudoElements::ePseudo_NotPseudoElement);
      }
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -260,17 +260,17 @@ nsTransitionManager::UpdateThrottledStyl
                                      false), "element not transitioning");
 
   nsIFrame* primaryFrame = aElement->GetPrimaryFrame();
   if (!primaryFrame) {
     return nullptr;
   }
 
   nsStyleContext* oldStyle = primaryFrame->StyleContext();
-  nsRuleNode* ruleNode = oldStyle->GetRuleNode();
+  nsRuleNode* ruleNode = oldStyle->RuleNode();
   nsTArray<nsStyleSet::RuleAndLevel> rules;
   do {
     if (ruleNode->IsRoot()) {
       break;
     }
 
     nsStyleSet::RuleAndLevel curRule;
     curRule.mLevel = ruleNode->GetLevel();
diff --git a/widget/xpwidgets/nsNativeTheme.cpp b/widget/xpwidgets/nsNativeTheme.cpp
--- a/widget/xpwidgets/nsNativeTheme.cpp
+++ b/widget/xpwidgets/nsNativeTheme.cpp
@@ -34,17 +34,17 @@ NS_IMPL_ISUPPORTS1(nsNativeTheme, nsITim
 nsIPresShell *
 nsNativeTheme::GetPresShell(nsIFrame* aFrame)
 {
   if (!aFrame)
     return nullptr;
 
   // this is a workaround for the egcs 1.1.2 not inliningg
   // aFrame->GetPresContext(), which causes an undefined symbol
-  nsPresContext *context = aFrame->StyleContext()->GetRuleNode()->GetPresContext();
+  nsPresContext *context = aFrame->StyleContext()->RuleNode()->GetPresContext();
   return context ? context->GetPresShell() : nullptr;
 }
 
 nsEventStates
 nsNativeTheme::GetContentState(nsIFrame* aFrame, uint8_t aWidgetType)
 {
   if (!aFrame)
     return nsEventStates();
