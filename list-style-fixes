Fix parsing of 'none' values in 'list-style' shorthand.  (Bug 474135)

diff --git a/layout/style/test/property_database.js b/layout/style/test/property_database.js
--- a/layout/style/test/property_database.js
+++ b/layout/style/test/property_database.js
@@ -1120,19 +1120,30 @@ var gCSSProperties = {
 		other_values: [ "1.0", "1", "1em", "47px" ],
 		invalid_values: []
 	},
 	"list-style": {
 		domProp: "listStyle",
 		inherited: true,
 		type: CSS_TYPE_TRUE_SHORTHAND,
 		subproperties: [ "list-style-type", "list-style-position", "list-style-image" ],
-		initial_values: [ "outside", "disc", "none disc outside" ],
-		other_values: [ "inside none", "none inside", "none none inside", "none outside none", "square", 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==")', "none" ],
-		invalid_values: []
+		initial_values: [ "outside", "disc", "disc outside", "outside disc", "disc none", "none disc", "none disc outside", "none outside disc", "disc none outside", "disc outside none", "outside none disc", "outside disc none" ],
+		other_values: [ "inside none", "none inside", "none none inside", "square", 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==")', "none", "none none", "outside none none", "none outside none", "none none outside", "none outside", "outside none",
+			'none url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==")',
+			'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==") none',
+			'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==")',
+			'outside url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==")',
+			'outside none url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==") outside',
+			'outside url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==") none',
+			'none url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==") outside',
+			'none outside url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==")',
+			'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==") outside none',
+			'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==") none outside'
+		],
+		invalid_values: [ "outside outside", "disc disc", "unknown value", "none none none", "none disc url(404.png)", "none url(404.png) disc", "disc none url(404.png)", "disc url(404.png) none", "url(404.png) none disc", "url(404.png) disc none", "none disc outside url(404.png)" ]
 	},
 	"list-style-image": {
 		domProp: "listStyleImage",
 		inherited: true,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "none" ],
 		other_values: [ 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==")' ],
 		invalid_values: []
diff --git a/layout/style/test/test_value_computation.html b/layout/style/test/test_value_computation.html
--- a/layout/style/test/test_value_computation.html
+++ b/layout/style/test/test_value_computation.html
@@ -30,20 +30,16 @@
 
   
 </div>
 <pre id="test">
 <script class="testbody" type="text/javascript">
 
 /** Test for computation of values in property database **/
 
-var gNotAccepted = {
-  "list-style": [ "none disc outside" ],
-};
-
 var gBadComputed = {
   // The 'medium' keyword should be computing to '3px', not 'medium'.
   "outline-width": [ "3px" ],
 
   // These values are treated as auto.
   "page-break-after": [ "avoid" ],
   "page-break-before": [ "avoid" ],
 
@@ -70,20 +66,16 @@ var gBadComputedNoFrame = {
   "padding": [ "0% 0px 0em 0pt" ],
   "padding-bottom": [ "0%" ],
   "padding-left": [ "0%" ],
   "padding-right": [ "0%" ],
   "padding-top": [ "0%" ],
 };
 
 function xfail_value(property, value, is_initial, has_frame) {
-  if ((property in gNotAccepted) &&
-      gNotAccepted[property].indexOf(value) != -1)
-    return true;
-
   if ((property in gBadComputed) &&
       gBadComputed[property].indexOf(value) != -1)
     return true;
 
   if (!has_frame && (property in gBadComputedNoFrame) &&
       gBadComputedNoFrame[property].indexOf(value) != -1)
     return true;
 
diff --git a/layout/style/test/test_value_storage.html b/layout/style/test/test_value_storage.html
--- a/layout/style/test/test_value_storage.html
+++ b/layout/style/test/test_value_storage.html
@@ -41,151 +41,94 @@
  * operation twice.  Likewise for parse + compute + cserialize.
  *
  * Slightly more interestingly, we test that serialize + parse is the
  * identity transform by comparing the output of parse + compute +
  * cserialize to the output of parse + serialize + parse + compute +
  * cserialize.
  */
 
-var gNotAccepted = {
-  "list-style": [ "none disc outside" ],
-};
-
 var gSystemFont = {
   "caption": true,
   "icon": true,
   "menu": true,
   "message-box": true,
   "small-caption": true,
   "status-bar": true,
 };
 
 var gBadCompute = {
   // output wrapped around to positive, in exponential notation
   "-moz-box-ordinal-group": [ "-1", "-1000" ],
 };
 
-function xfail_accepted(property, value)
-{
-  if (property in gNotAccepted &&
-      gNotAccepted[property].indexOf(value) != -1)
-    return true;
-
-  return false;
-}
-
-function xfail_accepted_split(property, subprop, value)
-{
-  if (property in gNotAccepted &&
-      gNotAccepted[property].indexOf(value) != -1)
-    return true;
-
-  return false;
-}
-
-function xfail_idparseser(property, value)
-{
-  if (property != "font" && xfail_accepted(property, value))
-    // We already failed the first test, which will make us always pass this
-    // one.
-    return false;
-
-  return false;
-}
-
-function xfail_idserparse_compute(property, value)
-{
-  return false;
-}
-
-function xfail_idsersplitparse_compute(property, subprop, value, step1subcomp)
-{
-  return false;
-}
-
-function xfail_idparsesplitser(property, value)
-{
-  return false;
-}
-
 function xfail_compute(property, value)
 {
   if (property in gBadCompute &&
       gBadCompute[property].indexOf(value) != -1)
     return true;
 
   return false;
 }
 
-function xfail_split_compute(property, value)
-{
-  return false;
-}
-
 var gElement = document.getElementById("testnode");
 var gDeclaration = gElement.style;
 var gComputedStyle = window.getComputedStyle(gElement, "");
 
 function test_property(property)
 {
   var info = gCSSProperties[property];
 
   var test_computed = !("backend_only" in info);
 
   function test_value(value) {
     gDeclaration.setProperty(property, value, "");
 
-    var idx, func;
+    var idx;
 
     var step1val = gDeclaration.getPropertyValue(property);
     var step1vals = [];
     var step1ser = gDeclaration.cssText;
     if ("subproperties" in info)
       for (idx in info.subproperties)
         step1vals.push(gDeclaration.getPropertyValue(info.subproperties[idx]));
     var step1comp;
     var step1comps = [];
     if (test_computed && info.type != CSS_TYPE_TRUE_SHORTHAND)
       step1comp = gComputedStyle.getPropertyValue(property);
     if (test_computed && "subproperties" in info)
       for (idx in info.subproperties)
         step1comps.push(gComputedStyle.getPropertyValue(info.subproperties[idx]));
 
-    func = xfail_accepted(property, value) ? todo_isnot : isnot;
-    func(step1val, "", "setting '" + value + "' on '" + property + "'");
+    isnot(step1val, "", "setting '" + value + "' on '" + property + "'");
     if ("subproperties" in info)
       for (idx in info.subproperties) {
         var subprop = info.subproperties[idx];
-        func = xfail_accepted_split(property, subprop, value)
-                 ? todo_isnot : isnot;
-        func(gDeclaration.getPropertyValue(subprop), "",
-             "setting '" + value + "' on '" + property + "'");
+        isnot(gDeclaration.getPropertyValue(subprop), "",
+              "setting '" + value + "' on '" + property + "'");
       }
 
     // We don't care particularly about the whitespace or the placement of
     // semicolons, but for simplicity we'll test the current behavior.
     var expected_serialization = "";
     if (step1val != "")
       expected_serialization = property + ": " + step1val + ";";
     is(step1ser, expected_serialization,
        "serialization should match property value");
 
     gDeclaration.removeProperty(property);
     gDeclaration.setProperty(property, step1val, "");
 
-    func = xfail_idparseser(property, value) ? todo_is : is;
-    func(gDeclaration.getPropertyValue(property), step1val,
-         "parse+serialize should be idempotent for '" +
+    is(gDeclaration.getPropertyValue(property), step1val,
+       "parse+serialize should be idempotent for '" +
          property + ": " + value + "'");
     if (test_computed && info.type != CSS_TYPE_TRUE_SHORTHAND) {
-      func = xfail_idserparse_compute(property, value) ? todo_is : is;
-      func(gComputedStyle.getPropertyValue(property), step1comp,
-           "serialize+parse should be identity transform for '" +
-           property + ": " + value + "'");
+      is(gComputedStyle.getPropertyValue(property), step1comp,
+         "serialize+parse should be identity transform for '" +
+         property + ": " + value + "'");
     }
 
     if ("subproperties" in info &&
         // Using setProperty over subproperties is not sufficient for
         // system fonts, since the shorthand does more than its parts.
         (property != "font" || !(value in gSystemFont))) {
       gDeclaration.removeProperty(property);
       for (idx in info.subproperties) {
@@ -194,58 +137,53 @@ function test_property(property)
       }
 
       // Now that all the subprops are set, check their values.  Note that we
       // need this in a separate loop, in case parts of the shorthand affect
       // the computed values of other parts.
       for (idx in info.subproperties) {
         var subprop = info.subproperties[idx];
         if (test_computed && !("backend_only" in gCSSProperties[subprop])) {
-          func =
-            xfail_idsersplitparse_compute(property, subprop, value, step1comps[idx])
-              ? todo_is : is;
-          func(gComputedStyle.getPropertyValue(subprop), step1comps[idx],
-               "serialize(" + subprop + ")+parse should be the identity " +
-               "transform for '" + property + ": " + value + "'");
+          is(gComputedStyle.getPropertyValue(subprop), step1comps[idx],
+             "serialize(" + subprop + ")+parse should be the identity " +
+             "transform for '" + property + ": " + value + "'");
         }
       }
-      func = xfail_idparsesplitser(property, value) ? todo_is : is;
-      func(gDeclaration.getPropertyValue(property), step1val,
-           "parse+split+serialize should be idempotent for '" +
-           property + ": " + value + "'");
+      is(gDeclaration.getPropertyValue(property), step1val,
+         "parse+split+serialize should be idempotent for '" +
+         property + ": " + value + "'");
     }
 
     if (test_computed && info.type != CSS_TYPE_TRUE_SHORTHAND) {
       gDeclaration.removeProperty(property);
       gDeclaration.setProperty(property, step1comp, "");
-      func = xfail_compute(property, value) ? todo_is : is;
+      var func = xfail_compute(property, value) ? todo_is : is;
       func(gComputedStyle.getPropertyValue(property), step1comp,
            "parse+compute+serialize should be idempotent for '" +
            property + ": " + value + "'");
     }
     if (test_computed && "subproperties" in info) {
       gDeclaration.removeProperty(property);
       for (idx in info.subproperties) {
         var subprop = info.subproperties[idx];
         if ("backend_only" in gCSSProperties[subprop])
           continue;
         gDeclaration.setProperty(subprop, step1comps[idx], "");
       }
 
       // Now that all the subprops are set, check their values.  Note that we
       // need this in a separate loop, in case parts of the shorthand affect
       // the computed values of other parts.
-      func = xfail_split_compute(property, value) ? todo_is : is;
       for (idx in info.subproperties) {
         var subprop = info.subproperties[idx];
         if ("backend_only" in gCSSProperties[subprop])
           continue;
-        func(gComputedStyle.getPropertyValue(subprop), step1comps[idx],
-             "parse+compute+serialize(" + subprop + ") should be idempotent for '" +
-             property + ": " + value + "'");
+        is(gComputedStyle.getPropertyValue(subprop), step1comps[idx],
+           "parse+compute+serialize(" + subprop + ") should be idempotent for '" +
+           property + ": " + value + "'");
       }
     }
 
     gDeclaration.removeProperty(property);
   }
 
   var idx;
   for (idx in info.initial_values)
