From: L. David Baron <dbaron@dbaron.org>

Bug 1089417 patch 8 - Only drop MediumFeaturesChanged on the floor if we've never computed style before, rather than never computed style using this rule processor.

This depends on patches 4 and 7.

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -2912,27 +2912,49 @@ nsCSSRuleProcessor::HasAttributeDependen
   }
 
   return data.change;
 }
 
 /* virtual */ bool
 nsCSSRuleProcessor::MediumFeaturesChanged(nsPresContext* aPresContext)
 {
+  // We don't want to do anything if there aren't any sets of rules
+  // cached yet, since we should not build the rule cascade too early
+  // (e.g., before we know whether the quirk style sheet should be
+  // enabled).  And if there's nothing cached, it doesn't matter if
+  // anything changed.  But in the cases where it does matter, we've
+  // cached a previous cache key to test against, instead of our current
+  // rule cascades.  See bug 448281 and bug 1089417.
+  MOZ_ASSERT(!mRuleCascades || !mPreviousCacheKey);
   RuleCascadeData *old = mRuleCascades;
-  // We don't want to do anything if there aren't any sets of rules
-  // cached yet (or somebody cleared them and is thus responsible for
-  // rebuilding things), since we should not build the rule cascade too
-  // early (e.g., before we know whether the quirk style sheet should be
-  // enabled).  And if there's nothing cached, it doesn't matter if
-  // anything changed.  See bug 448281.
   if (old) {
     RefreshRuleCascade(aPresContext);
+    return (old != mRuleCascades);
   }
-  return (old != mRuleCascades);
+
+  if (mPreviousCacheKey) {
+    // RefreshRuleCascade will get rid of mPreviousCacheKey anyway to
+    // maintain the invariant that we can't have both an mRuleCascades
+    // and an mPreviousCacheKey.  But we need to hold it a little
+    // longer.
+    UniquePtr<nsMediaQueryResultCacheKey> previousCacheKey(
+      Move(mPreviousCacheKey));
+    RefreshRuleCascade(aPresContext);
+
+    // This test is a bit pessimistic since the cache key's operator==
+    // just does list comparison rather than set comparison, but it
+    // should catch all the cases we care about (i.e., where the cascade
+    // order hasn't changed).  Other cases will do a restyle anyway, so
+    // we shouldn't need to worry about posting a second.
+    return !mRuleCascades || // all sheets gone, but we had sheets before
+           mRuleCascades->mCacheKey != *previousCacheKey;
+  }
+
+  return false;
 }
 
 UniquePtr<nsMediaQueryResultCacheKey>
 nsCSSRuleProcessor::CloneMQCacheKey()
 {
   RuleCascadeData* c = mRuleCascades;
   if (!c || !c->mCacheKey.HasFeatureConditions()) {
     return nullptr;
diff --git a/layout/style/test/test_bug1089417.html b/layout/style/test/test_bug1089417.html
--- a/layout/style/test/test_bug1089417.html
+++ b/layout/style/test/test_bug1089417.html
@@ -16,17 +16,17 @@ https://bugzilla.mozilla.org/show_bug.cg
 
   function run() {
     var f = document.getElementById("f");
     var fwin = f.contentWindow;
     var fdoc = f.contentDocument;
 
     f.height = "400";
     fdoc.getElementById("s").disabled = false;
-    todo_is(fwin.getComputedStyle(fdoc.documentElement).backgroundColor,
+    is(fwin.getComputedStyle(fdoc.documentElement).backgroundColor,
        "rgb(0, 128, 0)",
        "media query change should have restyled");
     SimpleTest.finish();
   }
 
   </script>
 </head>
 <body onload="run()">
