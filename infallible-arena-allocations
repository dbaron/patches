From: L. David Baron <dbaron@dbaron.org>

Bug 809533, patch 1:  Make allocation in the frame arena and the display list arena infallible.  r=roc

diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -805,16 +805,19 @@ nsDisplayListBuilder::MarkPreserve3DFram
     }
   }
 }
 
 void*
 nsDisplayListBuilder::Allocate(size_t aSize) {
   void *tmp;
   PL_ARENA_ALLOCATE(tmp, &mPool, aSize);
+  if (!tmp) {
+    NS_RUNTIMEABORT("out of memory");
+  }
   return tmp;
 }
 
 void nsDisplayListSet::MoveTo(const nsDisplayListSet& aDestination) const
 {
   aDestination.BorderBackground()->AppendToTop(BorderBackground());
   aDestination.BlockBorderBackgrounds()->AppendToTop(BlockBorderBackgrounds());
   aDestination.Floats()->AppendToTop(Floats());
diff --git a/layout/base/nsPresArena.cpp b/layout/base/nsPresArena.cpp
--- a/layout/base/nsPresArena.cpp
+++ b/layout/base/nsPresArena.cpp
@@ -335,16 +335,19 @@ struct nsPresArena::State {
       }
 #endif
       return result;
     }
 
     // Allocate a new chunk from the arena
     list->mEntriesEverAllocated++;
     PL_ARENA_ALLOCATE(result, &mPool, aSize);
+    if (!result) {
+      NS_RUNTIMEABORT("out of memory");
+    }
     return result;
   }
 
   void Free(uint32_t aCode, void* aPtr)
   {
     // Try to recycle this entry.
     FreeList* list = mFreeLists.GetEntry(aCode);
     NS_ABORT_IF_FALSE(list, "no free list for pres arena object");
