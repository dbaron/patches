From: L. David Baron <dbaron@dbaron.org>

Fix variable shadowing that would become noisy with -Wshadow enabled.  (Bug 563195)

diff --git a/js/public/CharacterEncoding.h b/js/public/CharacterEncoding.h
--- a/js/public/CharacterEncoding.h
+++ b/js/public/CharacterEncoding.h
@@ -23,40 +23,40 @@ namespace JS {
  * string containing characters beyond U+00FF.
  */
 class Latin1Chars : public mozilla::Range<unsigned char>
 {
     typedef mozilla::Range<unsigned char> Base;
 
   public:
     Latin1Chars() : Base() {}
-    Latin1Chars(char *bytes, size_t length) : Base(reinterpret_cast<unsigned char *>(bytes), length) {}
-    Latin1Chars(const char *bytes, size_t length)
-      : Base(reinterpret_cast<unsigned char *>(const_cast<char *>(bytes)), length)
+    Latin1Chars(char *bytesarg, size_t lengtharg) : Base(reinterpret_cast<unsigned char *>(bytesarg), lengtharg) {}
+    Latin1Chars(const char *bytesarg, size_t lengtharg)
+      : Base(reinterpret_cast<unsigned char *>(const_cast<char *>(bytesarg)), lengtharg)
     {}
 };
 
 /*
  * A Latin1Chars, but with \0 termination for C compatibility.
  */
 class Latin1CharsZ : public mozilla::RangedPtr<unsigned char>
 {
     typedef mozilla::RangedPtr<unsigned char> Base;
 
   public:
     Latin1CharsZ() : Base(NULL, 0) {}
 
-    Latin1CharsZ(char *bytes, size_t length)
-      : Base(reinterpret_cast<unsigned char *>(bytes), length)
+    Latin1CharsZ(char *bytesarg, size_t lengtharg)
+      : Base(reinterpret_cast<unsigned char *>(bytesarg), lengtharg)
     {
         JS_ASSERT(bytes[length] == '\0');
     }
 
-    Latin1CharsZ(unsigned char *bytes, size_t length)
-      : Base(bytes, length)
+    Latin1CharsZ(unsigned char *bytesarg, size_t lengtharg)
+      : Base(bytesarg, lengtharg)
     {
         JS_ASSERT(bytes[length] == '\0');
     }
 
     char *c_str() { return reinterpret_cast<char *>(get()); }
 };
 
 /*
@@ -64,18 +64,18 @@ class Latin1CharsZ : public mozilla::Ran
  */
 class UTF8CharsZ : public mozilla::RangedPtr<unsigned char>
 {
     typedef mozilla::RangedPtr<unsigned char> Base;
 
   public:
     UTF8CharsZ() : Base(NULL, 0) {}
 
-    UTF8CharsZ(char *bytes, size_t length)
-      : Base(reinterpret_cast<unsigned char *>(bytes), length)
+    UTF8CharsZ(char *bytesarg, size_t lengtharg)
+      : Base(reinterpret_cast<unsigned char *>(bytesarg), lengtharg)
     {
         JS_ASSERT(bytes[length] == '\0');
     }
 };
 
 /*
  * SpiderMonkey uses a 2-byte character representation: it is a
  * 2-byte-at-a-time view of a UTF-16 byte stream. This is similar to UCS-2,
@@ -85,33 +85,33 @@ class UTF8CharsZ : public mozilla::Range
  * string.
  */
 class TwoByteChars : public mozilla::Range<jschar>
 {
     typedef mozilla::Range<jschar> Base;
 
   public:
     TwoByteChars() : Base() {}
-    TwoByteChars(jschar *chars, size_t length) : Base(chars, length) {}
-    TwoByteChars(const jschar *chars, size_t length) : Base(const_cast<jschar *>(chars), length) {}
+    TwoByteChars(jschar *charsarg, size_t lengtharg) : Base(charsarg, lengtharg) {}
+    TwoByteChars(const jschar *charsarg, size_t lengtharg) : Base(const_cast<jschar *>(charsarg), lengtharg) {}
 };
 
 /*
  * A non-convertible variant of TwoByteChars that does not refer to characters
  * inlined inside a JSShortString or a JSInlineString. StableTwoByteChars are
  * thus safe to hold across a GC.
  */
 class StableTwoByteChars : public mozilla::Range<jschar>
 {
     typedef mozilla::Range<jschar> Base;
 
   public:
     StableTwoByteChars() : Base() {}
-    StableTwoByteChars(jschar *chars, size_t length) : Base(chars, length) {}
-    StableTwoByteChars(const jschar *chars, size_t length) : Base(const_cast<jschar *>(chars), length) {}
+    StableTwoByteChars(jschar *charsarg, size_t lengtharg) : Base(charsarg, lengtharg) {}
+    StableTwoByteChars(const jschar *charsarg, size_t lengtharg) : Base(const_cast<jschar *>(charsarg), lengtharg) {}
 };
 
 /*
  * A TwoByteChars, but \0 terminated for compatibility with JSFlatString.
  */
 class TwoByteCharsZ : public mozilla::RangedPtr<jschar>
 {
     typedef mozilla::RangedPtr<jschar> Base;
diff --git a/js/public/HashTable.h b/js/public/HashTable.h
--- a/js/public/HashTable.h
+++ b/js/public/HashTable.h
@@ -662,17 +662,17 @@ class HashTable : private AllocPolicy
     {
         friend class HashTable;
         typedef void (Ptr::* ConvertibleToBool)();
         void nonNull() {}
 
         Entry *entry;
 
       protected:
-        Ptr(Entry &entry) : entry(&entry) {}
+        Ptr(Entry &entryarg) : entry(&entryarg) {}
 
       public:
         // Leaves Ptr uninitialized.
         Ptr() {
 #ifdef DEBUG
             entry = (Entry *)0xbad;
 #endif
         }
@@ -688,17 +688,17 @@ class HashTable : private AllocPolicy
 
     // A Ptr that can be used to add a key after a failed lookup.
     class AddPtr : public Ptr
     {
         friend class HashTable;
         HashNumber keyHash;
         mozilla::DebugOnly<uint64_t> mutationCount;
 
-        AddPtr(Entry &entry, HashNumber hn) : Ptr(entry), keyHash(hn) {}
+        AddPtr(Entry &entryarg, HashNumber hn) : Ptr(entryarg), keyHash(hn) {}
       public:
         // Leaves AddPtr uninitialized.
         AddPtr() {}
     };
 
     // A collection of hash table entries. The collection is enumerated by
     // calling |front()| followed by |popFront()| as long as |!empty()|. As
     // with Ptr/AddPtr, Range objects must not be used after any mutating hash
@@ -919,32 +919,32 @@ class HashTable : private AllocPolicy
         JS_ASSERT(!initialized());
 
         // Correct for sMaxAlphaFrac such that the table will not resize
         // when adding 'length' entries.
         if (length > sMaxInit) {
             this->reportAllocOverflow();
             return false;
         }
-        uint32_t capacity = (length * sInvMaxAlpha) >> 7;
+        uint32_t newcapacity = (length * sInvMaxAlpha) >> 7;
 
-        if (capacity < sMinCapacity)
-            capacity = sMinCapacity;
+        if (newcapacity < sMinCapacity)
+            newcapacity = sMinCapacity;
 
         // FIXME: use JS_CEILING_LOG2 when PGO stops crashing (bug 543034).
         uint32_t roundUp = sMinCapacity, roundUpLog2 = sMinCapacityLog2;
-        while (roundUp < capacity) {
+        while (roundUp < newcapacity) {
             roundUp <<= 1;
             ++roundUpLog2;
         }
 
-        capacity = roundUp;
-        JS_ASSERT(capacity <= sMaxCapacity);
+        newcapacity = roundUp;
+        JS_ASSERT(newcapacity <= sMaxCapacity);
 
-        table = createTable(*this, capacity);
+        table = createTable(*this, newcapacity);
         if (!table)
             return false;
 
         setTableSizeLog2(roundUpLog2);
         METER(memset(&stats, 0, sizeof(stats)));
         return true;
     }
 
diff --git a/js/public/Vector.h b/js/public/Vector.h
--- a/js/public/Vector.h
+++ b/js/public/Vector.h
@@ -374,17 +374,17 @@ class Vector : private AllocPolicy
     const T &back() const {
         JS_ASSERT(!entered && !empty());
         return *(end() - 1);
     }
 
     class Range {
         friend class Vector;
         T *cur, *end;
-        Range(T *cur, T *end) : cur(cur), end(end) {}
+        Range(T *curarg, T *endarg) : cur(curarg), end(endarg) {}
       public:
         Range() {}
         bool empty() const { return cur == end; }
         size_t remain() const { return end - cur; }
         T &front() const { return *cur; }
         void popFront() { JS_ASSERT(!empty()); ++cur; }
         T popCopyFront() { JS_ASSERT(!empty()); return *cur++; }
     };
@@ -442,21 +442,21 @@ class Vector : private AllocPolicy
      * memory has been pre-reserved.
      */
     void infallibleAppend(const T &t) {
         internalAppend(t);
     }
     void infallibleAppendN(const T &t, size_t n) {
         internalAppendN(t, n);
     }
-    template <class U> void infallibleAppend(const U *begin, const U *end) {
-        internalAppend(begin, mozilla::PointerRangeSize(begin, end));
+    template <class U> void infallibleAppend(const U *beginarg, const U *endarg) {
+        internalAppend(beginarg, mozilla::PointerRangeSize(beginarg, endarg));
     }
-    template <class U> void infallibleAppend(const U *begin, size_t length) {
-        internalAppend(begin, length);
+    template <class U> void infallibleAppend(const U *beginarg, size_t lengtharg) {
+        internalAppend(beginarg, lengtharg);
     }
     template <class U, size_t O, class BP> void infallibleAppend(const Vector<U,O,BP> &other) {
         internalAppend(other);
     }
 
     void popBack();
 
     T popCopy();
@@ -911,22 +911,22 @@ Vector<T,N,AP>::append(const U *insBegin
 #endif
     internalAppend(insBegin, needed);
     return true;
 }
 
 template <class T, size_t N, class AP>
 template <class U>
 JS_ALWAYS_INLINE void
-Vector<T,N,AP>::internalAppend(const U *insBegin, size_t length)
+Vector<T,N,AP>::internalAppend(const U *insBegin, size_t insLength)
 {
-    JS_ASSERT(mLength + length <= mReserved);
+    JS_ASSERT(mLength + insLength <= mReserved);
     JS_ASSERT(mReserved <= mCapacity);
-    Impl::copyConstruct(endNoCheck(), insBegin, insBegin + length);
-    mLength += length;
+    Impl::copyConstruct(endNoCheck(), insBegin, insBegin + insLength);
+    mLength += insLength;
 }
 
 template <class T, size_t N, class AP>
 template <class U, size_t O, class BP>
 inline bool
 Vector<T,N,AP>::append(const Vector<U,O,BP> &other)
 {
     return append(other.begin(), other.end());
@@ -938,19 +938,19 @@ inline void
 Vector<T,N,AP>::internalAppend(const Vector<U,O,BP> &other)
 {
     internalAppend(other.begin(), other.length());
 }
 
 template <class T, size_t N, class AP>
 template <class U>
 JS_ALWAYS_INLINE bool
-Vector<T,N,AP>::append(const U *insBegin, size_t length)
+Vector<T,N,AP>::append(const U *insBegin, size_t insLength)
 {
-    return this->append(insBegin, insBegin + length);
+    return this->append(insBegin, insBegin + insLength);
 }
 
 template <class T, size_t N, class AP>
 JS_ALWAYS_INLINE void
 Vector<T,N,AP>::popBack()
 {
     REENTRANCY_GUARD_ET_AL;
     JS_ASSERT(!empty());
@@ -989,45 +989,45 @@ Vector<T,N,AP>::extractRawBuffer()
         mReserved = 0;
 #endif
     }
     return ret;
 }
 
 template <class T, size_t N, class AP>
 inline void
-Vector<T,N,AP>::replaceRawBuffer(T *p, size_t length)
+Vector<T,N,AP>::replaceRawBuffer(T *p, size_t lengtharg)
 {
     REENTRANCY_GUARD_ET_AL;
 
     /* Destroy what we have. */
     Impl::destroy(beginNoCheck(), endNoCheck());
     if (!usingInlineStorage())
         this->free_(beginNoCheck());
 
     /* Take in the new buffer. */
-    if (length <= sInlineCapacity) {
+    if (lengtharg <= sInlineCapacity) {
         /*
          * We convert to inline storage if possible, even though p might
          * otherwise be acceptable.  Maybe this behaviour should be
          * specifiable with an argument to this function.
          */
         mBegin = (T *)storage.addr();
-        mLength = length;
+        mLength = lengtharg;
         mCapacity = sInlineCapacity;
-        Impl::moveConstruct(mBegin, p, p + length);
-        Impl::destroy(p, p + length);
+        Impl::moveConstruct(mBegin, p, p + lengtharg);
+        Impl::destroy(p, p + lengtharg);
         this->free_(p);
     } else {
         mBegin = p;
-        mLength = length;
-        mCapacity = length;
+        mLength = lengtharg;
+        mCapacity = lengtharg;
     }
 #ifdef DEBUG
-    mReserved = length;
+    mReserved = lengtharg;
 #endif
 }
 
 template <class T, size_t N, class AP>
 inline size_t
 Vector<T,N,AP>::sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf) const
 {
     return usingInlineStorage() ? 0 : mallocSizeOf(beginNoCheck());
diff --git a/js/src/gc/Root.h b/js/src/gc/Root.h
--- a/js/src/gc/Root.h
+++ b/js/src/gc/Root.h
@@ -1052,17 +1052,17 @@ inline void MaybeCheckStackRoots(JSConte
 namespace gc {
 struct Cell;
 } /* namespace gc */
 
 /* Base class for automatic read-only object rooting during compilation. */
 class CompilerRootNode
 {
   protected:
-    CompilerRootNode(js::gc::Cell *ptr) : next(NULL), ptr(ptr) {}
+    CompilerRootNode(js::gc::Cell *ptrarg) : next(NULL), ptr(ptrarg) {}
 
   public:
     void **address() { return (void **)&ptr; }
 
   public:
     CompilerRootNode *next;
 
   protected:
diff --git a/js/src/jsalloc.h b/js/src/jsalloc.h
--- a/js/src/jsalloc.h
+++ b/js/src/jsalloc.h
@@ -55,17 +55,17 @@ class TempAllocPolicy
 
     /*
      * Non-inline helper to call JSRuntime::onOutOfMemory with minimal
      * code bloat.
      */
     JS_FRIEND_API(void *) onOutOfMemory(void *p, size_t nbytes);
 
   public:
-    TempAllocPolicy(JSContext *cx) : cx(cx) {}
+    TempAllocPolicy(JSContext *cxarg) : cx(cxarg) {}
 
     JSContext *context() const {
         return cx;
     }
 
     void *malloc_(size_t bytes) {
         void *p = js_malloc(bytes);
         if (JS_UNLIKELY(!p))
diff --git a/js/src/jsapi.h b/js/src/jsapi.h
--- a/js/src/jsapi.h
+++ b/js/src/jsapi.h
@@ -4994,17 +4994,17 @@ JS_ClearRuntimeThread(JSRuntime *rt);
 extern JS_PUBLIC_API(void)
 JS_SetRuntimeThread(JSRuntime *rt);
 
 class JSAutoSetRuntimeThread
 {
     JSRuntime *runtime;
 
   public:
-    JSAutoSetRuntimeThread(JSRuntime *runtime) : runtime(runtime) {
+    JSAutoSetRuntimeThread(JSRuntime *runtimearg) : runtime(runtimearg) {
         JS_SetRuntimeThread(runtime);
     }
 
     ~JSAutoSetRuntimeThread() {
         JS_ClearRuntimeThread(runtime);
     }
 };
 
diff --git a/js/src/jscntxt.h b/js/src/jscntxt.h
--- a/js/src/jscntxt.h
+++ b/js/src/jscntxt.h
@@ -2237,26 +2237,26 @@ class RuntimeAllocPolicy
     void reportAllocOverflow() const {}
 };
 
 /*
  * FIXME bug 647103 - replace these *AllocPolicy names.
  */
 class ContextAllocPolicy
 {
-    JSContext *const cx;
+    JSContext *const mContext;
 
   public:
-    ContextAllocPolicy(JSContext *cx) : cx(cx) {}
-    JSContext *context() const { return cx; }
-    void *malloc_(size_t bytes) { return cx->malloc_(bytes); }
-    void *calloc_(size_t bytes) { return cx->calloc_(bytes); }
-    void *realloc_(void *p, size_t oldBytes, size_t bytes) { return cx->realloc_(p, oldBytes, bytes); }
+    ContextAllocPolicy(JSContext *cx) : mContext(cx) {}
+    JSContext *context() const { return mContext; }
+    void *malloc_(size_t bytes) { return mContext->malloc_(bytes); }
+    void *calloc_(size_t bytes) { return mContext->calloc_(bytes); }
+    void *realloc_(void *p, size_t oldBytes, size_t bytes) { return mContext->realloc_(p, oldBytes, bytes); }
     void free_(void *p) { js_free(p); }
-    void reportAllocOverflow() const { js_ReportAllocationOverflow(cx); }
+    void reportAllocOverflow() const { js_ReportAllocationOverflow(mContext); }
 };
 
 JSBool intrinsic_ThrowError(JSContext *cx, unsigned argc, Value *vp);
 JSBool intrinsic_NewDenseArray(JSContext *cx, unsigned argc, Value *vp);
 JSBool intrinsic_UnsafeSetElement(JSContext *cx, unsigned argc, Value *vp);
 JSBool intrinsic_ForceSequential(JSContext *cx, unsigned argc, Value *vp);
 JSBool intrinsic_NewParallelArray(JSContext *cx, unsigned argc, Value *vp);
 
diff --git a/js/src/jsutil.h b/js/src/jsutil.h
--- a/js/src/jsutil.h
+++ b/js/src/jsutil.h
@@ -49,19 +49,19 @@ struct AlignmentTestStruct
   (sizeof(js::AlignmentTestStruct<t_>) - sizeof(t_))
 
 template <class T>
 class AlignedPtrAndFlag
 {
     uintptr_t bits;
 
   public:
-    AlignedPtrAndFlag(T *t, bool flag) {
+    AlignedPtrAndFlag(T *t, bool flagarg) {
         JS_ASSERT((uintptr_t(t) & 1) == 0);
-        bits = uintptr_t(t) | uintptr_t(flag);
+        bits = uintptr_t(t) | uintptr_t(flagarg);
     }
 
     T *ptr() const {
         return (T *)(bits & ~uintptr_t(1));
     }
 
     bool flag() const {
         return (bits & 1) != 0;
@@ -75,19 +75,19 @@ class AlignedPtrAndFlag
     void setFlag() {
         bits |= 1;
     }
 
     void unsetFlag() {
         bits &= ~uintptr_t(1);
     }
 
-    void set(T *t, bool flag) {
+    void set(T *t, bool flagarg) {
         JS_ASSERT((uintptr_t(t) & 1) == 0);
-        bits = uintptr_t(t) | flag;
+        bits = uintptr_t(t) | flagarg;
     }
 };
 
 template <class T>
 static inline void
 Reverse(T *beg, T *end)
 {
     while (beg != end) {
@@ -155,19 +155,19 @@ ImplicitCast(U &u)
     T &t = u;
     return t;
 }
 
 template<typename T>
 class AutoScopedAssign
 {
   public:
-    AutoScopedAssign(T *addr, const T &value
+    AutoScopedAssign(T *addrarg, const T &value
                      MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
-        : addr(addr), old(*addr)
+        : addr(addrarg), old(*addr)
     {
         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
         *addr = value;
     }
 
     ~AutoScopedAssign() { *addr = old; }
 
   private:
