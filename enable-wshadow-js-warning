From: L. David Baron <dbaron@dbaron.org>

Fix variable shadowing that would become noisy with -Wshadow enabled.  (Bug 563195)

diff --git a/js/public/CharacterEncoding.h b/js/public/CharacterEncoding.h
--- a/js/public/CharacterEncoding.h
+++ b/js/public/CharacterEncoding.h
@@ -23,40 +23,40 @@ namespace JS {
  * string containing characters beyond U+00FF.
  */
 class Latin1Chars : public mozilla::Range<unsigned char>
 {
     typedef mozilla::Range<unsigned char> Base;
 
   public:
     Latin1Chars() : Base() {}
-    Latin1Chars(char *bytes, size_t length) : Base(reinterpret_cast<unsigned char *>(bytes), length) {}
-    Latin1Chars(const char *bytes, size_t length)
-      : Base(reinterpret_cast<unsigned char *>(const_cast<char *>(bytes)), length)
+    Latin1Chars(char *bytesarg, size_t lengtharg) : Base(reinterpret_cast<unsigned char *>(bytesarg), lengtharg) {}
+    Latin1Chars(const char *bytesarg, size_t lengtharg)
+      : Base(reinterpret_cast<unsigned char *>(const_cast<char *>(bytesarg)), lengtharg)
     {}
 };
 
 /*
  * A Latin1Chars, but with \0 termination for C compatibility.
  */
 class Latin1CharsZ : public mozilla::RangedPtr<unsigned char>
 {
     typedef mozilla::RangedPtr<unsigned char> Base;
 
   public:
     Latin1CharsZ() : Base(NULL, 0) {}
 
-    Latin1CharsZ(char *bytes, size_t length)
-      : Base(reinterpret_cast<unsigned char *>(bytes), length)
+    Latin1CharsZ(char *bytesarg, size_t lengtharg)
+      : Base(reinterpret_cast<unsigned char *>(bytesarg), lengtharg)
     {
         JS_ASSERT(bytes[length] == '\0');
     }
 
-    Latin1CharsZ(unsigned char *bytes, size_t length)
-      : Base(bytes, length)
+    Latin1CharsZ(unsigned char *bytesarg, size_t lengtharg)
+      : Base(bytesarg, lengtharg)
     {
         JS_ASSERT(bytes[length] == '\0');
     }
 
     char *c_str() { return reinterpret_cast<char *>(get()); }
 };
 
 /*
@@ -64,18 +64,18 @@ class Latin1CharsZ : public mozilla::Ran
  */
 class UTF8CharsZ : public mozilla::RangedPtr<unsigned char>
 {
     typedef mozilla::RangedPtr<unsigned char> Base;
 
   public:
     UTF8CharsZ() : Base(NULL, 0) {}
 
-    UTF8CharsZ(char *bytes, size_t length)
-      : Base(reinterpret_cast<unsigned char *>(bytes), length)
+    UTF8CharsZ(char *bytesarg, size_t lengtharg)
+      : Base(reinterpret_cast<unsigned char *>(bytesarg), lengtharg)
     {
         JS_ASSERT(bytes[length] == '\0');
     }
 };
 
 /*
  * SpiderMonkey uses a 2-byte character representation: it is a
  * 2-byte-at-a-time view of a UTF-16 byte stream. This is similar to UCS-2,
@@ -85,33 +85,33 @@ class UTF8CharsZ : public mozilla::Range
  * string.
  */
 class TwoByteChars : public mozilla::Range<jschar>
 {
     typedef mozilla::Range<jschar> Base;
 
   public:
     TwoByteChars() : Base() {}
-    TwoByteChars(jschar *chars, size_t length) : Base(chars, length) {}
-    TwoByteChars(const jschar *chars, size_t length) : Base(const_cast<jschar *>(chars), length) {}
+    TwoByteChars(jschar *charsarg, size_t lengtharg) : Base(charsarg, lengtharg) {}
+    TwoByteChars(const jschar *charsarg, size_t lengtharg) : Base(const_cast<jschar *>(charsarg), lengtharg) {}
 };
 
 /*
  * A non-convertible variant of TwoByteChars that does not refer to characters
  * inlined inside a JSShortString or a JSInlineString. StableTwoByteChars are
  * thus safe to hold across a GC.
  */
 class StableTwoByteChars : public mozilla::Range<jschar>
 {
     typedef mozilla::Range<jschar> Base;
 
   public:
     StableTwoByteChars() : Base() {}
-    StableTwoByteChars(jschar *chars, size_t length) : Base(chars, length) {}
-    StableTwoByteChars(const jschar *chars, size_t length) : Base(const_cast<jschar *>(chars), length) {}
+    StableTwoByteChars(jschar *charsarg, size_t lengtharg) : Base(charsarg, lengtharg) {}
+    StableTwoByteChars(const jschar *charsarg, size_t lengtharg) : Base(const_cast<jschar *>(charsarg), lengtharg) {}
 };
 
 /*
  * A TwoByteChars, but \0 terminated for compatibility with JSFlatString.
  */
 class TwoByteCharsZ : public mozilla::RangedPtr<jschar>
 {
     typedef mozilla::RangedPtr<jschar> Base;
diff --git a/js/public/GCAPI.h b/js/public/GCAPI.h
--- a/js/public/GCAPI.h
+++ b/js/public/GCAPI.h
@@ -118,18 +118,18 @@ enum GCProgress {
     GC_SLICE_BEGIN,
     GC_SLICE_END,
     GC_CYCLE_END
 };
 
 struct JS_FRIEND_API(GCDescription) {
     bool isCompartment;
 
-    GCDescription(bool isCompartment)
-      : isCompartment(isCompartment) {}
+    GCDescription(bool isCompartmentArg)
+      : isCompartment(isCompartmentArg) {}
 
     jschar *formatMessage(JSRuntime *rt) const;
     jschar *formatJSON(JSRuntime *rt, uint64_t timestamp) const;
 };
 
 typedef void
 (* GCSliceCallback)(JSRuntime *rt, GCProgress progress, const GCDescription &desc);
 
diff --git a/js/public/HashTable.h b/js/public/HashTable.h
--- a/js/public/HashTable.h
+++ b/js/public/HashTable.h
@@ -662,17 +662,17 @@ class HashTable : private AllocPolicy
     {
         friend class HashTable;
         typedef void (Ptr::* ConvertibleToBool)();
         void nonNull() {}
 
         Entry *entry;
 
       protected:
-        Ptr(Entry &entry) : entry(&entry) {}
+        Ptr(Entry &entryarg) : entry(&entryarg) {}
 
       public:
         // Leaves Ptr uninitialized.
         Ptr() {
 #ifdef DEBUG
             entry = (Entry *)0xbad;
 #endif
         }
@@ -688,17 +688,17 @@ class HashTable : private AllocPolicy
 
     // A Ptr that can be used to add a key after a failed lookup.
     class AddPtr : public Ptr
     {
         friend class HashTable;
         HashNumber keyHash;
         mozilla::DebugOnly<uint64_t> mutationCount;
 
-        AddPtr(Entry &entry, HashNumber hn) : Ptr(entry), keyHash(hn) {}
+        AddPtr(Entry &entryarg, HashNumber hn) : Ptr(entryarg), keyHash(hn) {}
       public:
         // Leaves AddPtr uninitialized.
         AddPtr() {}
     };
 
     // A collection of hash table entries. The collection is enumerated by
     // calling |front()| followed by |popFront()| as long as |!empty()|. As
     // with Ptr/AddPtr, Range objects must not be used after any mutating hash
@@ -919,32 +919,32 @@ class HashTable : private AllocPolicy
         JS_ASSERT(!initialized());
 
         // Correct for sMaxAlphaFrac such that the table will not resize
         // when adding 'length' entries.
         if (length > sMaxInit) {
             this->reportAllocOverflow();
             return false;
         }
-        uint32_t capacity = (length * sInvMaxAlpha) >> 7;
+        uint32_t newcapacity = (length * sInvMaxAlpha) >> 7;
 
-        if (capacity < sMinCapacity)
-            capacity = sMinCapacity;
+        if (newcapacity < sMinCapacity)
+            newcapacity = sMinCapacity;
 
         // FIXME: use JS_CEILING_LOG2 when PGO stops crashing (bug 543034).
         uint32_t roundUp = sMinCapacity, roundUpLog2 = sMinCapacityLog2;
-        while (roundUp < capacity) {
+        while (roundUp < newcapacity) {
             roundUp <<= 1;
             ++roundUpLog2;
         }
 
-        capacity = roundUp;
-        JS_ASSERT(capacity <= sMaxCapacity);
+        newcapacity = roundUp;
+        JS_ASSERT(newcapacity <= sMaxCapacity);
 
-        table = createTable(*this, capacity);
+        table = createTable(*this, newcapacity);
         if (!table)
             return false;
 
         setTableSizeLog2(roundUpLog2);
         METER(memset(&stats, 0, sizeof(stats)));
         return true;
     }
 
diff --git a/js/public/MemoryMetrics.h b/js/public/MemoryMetrics.h
--- a/js/public/MemoryMetrics.h
+++ b/js/public/MemoryMetrics.h
@@ -300,29 +300,29 @@ struct CompartmentStats
     }
 
     // The size of all the live things in the GC heap.
     size_t gcHeapThingsSize();
 };
 
 struct RuntimeStats
 {
-    RuntimeStats(JSMallocSizeOfFun mallocSizeOf)
+    RuntimeStats(JSMallocSizeOfFun mallocSizeOfArg)
       : runtime()
       , gcHeapChunkTotal(0)
       , gcHeapDecommittedArenas(0)
       , gcHeapUnusedChunks(0)
       , gcHeapUnusedArenas(0)
       , gcHeapUnusedGcThings(0)
       , gcHeapChunkAdmin(0)
       , gcHeapGcThings(0)
       , totals()
       , compartmentStatsVector()
       , currCompartmentStats(NULL)
-      , mallocSizeOf(mallocSizeOf)
+      , mallocSizeOf(mallocSizeOfArg)
     {}
 
     RuntimeSizes runtime;
 
     // If you add a new number, remember to update the constructor!
 
     // Here's a useful breakdown of the GC heap.
     //
@@ -371,18 +371,18 @@ public:
     // that has an nsISupports pointer.
     virtual size_t sizeOfIncludingThis(nsISupports *aSupports) = 0;
 
     // A callback that gets a JSObject's nsISupports pointer, if it has one.
     // Note: this function does *not* addref |iface|.
     typedef JSBool(*GetISupportsFun)(JSObject *obj, nsISupports **iface);
     GetISupportsFun getISupports;
 
-    ObjectPrivateVisitor(GetISupportsFun getISupports)
-      : getISupports(getISupports)
+    ObjectPrivateVisitor(GetISupportsFun getISupportsArg)
+      : getISupports(getISupportsArg)
     {}
 };
 
 extern JS_PUBLIC_API(bool)
 CollectRuntimeStats(JSRuntime *rt, RuntimeStats *rtStats, ObjectPrivateVisitor *opv);
 
 extern JS_PUBLIC_API(int64_t)
 GetExplicitNonHeapForRuntime(JSRuntime *rt, JSMallocSizeOfFun mallocSizeOf);
diff --git a/js/public/Vector.h b/js/public/Vector.h
--- a/js/public/Vector.h
+++ b/js/public/Vector.h
@@ -374,17 +374,17 @@ class Vector : private AllocPolicy
     const T &back() const {
         JS_ASSERT(!entered && !empty());
         return *(end() - 1);
     }
 
     class Range {
         friend class Vector;
         T *cur, *end;
-        Range(T *cur, T *end) : cur(cur), end(end) {}
+        Range(T *curarg, T *endarg) : cur(curarg), end(endarg) {}
       public:
         Range() {}
         bool empty() const { return cur == end; }
         size_t remain() const { return end - cur; }
         T &front() const { return *cur; }
         void popFront() { JS_ASSERT(!empty()); ++cur; }
         T popCopyFront() { JS_ASSERT(!empty()); return *cur++; }
     };
@@ -442,21 +442,21 @@ class Vector : private AllocPolicy
      * memory has been pre-reserved.
      */
     void infallibleAppend(const T &t) {
         internalAppend(t);
     }
     void infallibleAppendN(const T &t, size_t n) {
         internalAppendN(t, n);
     }
-    template <class U> void infallibleAppend(const U *begin, const U *end) {
-        internalAppend(begin, mozilla::PointerRangeSize(begin, end));
+    template <class U> void infallibleAppend(const U *beginarg, const U *endarg) {
+        internalAppend(beginarg, mozilla::PointerRangeSize(beginarg, endarg));
     }
-    template <class U> void infallibleAppend(const U *begin, size_t length) {
-        internalAppend(begin, length);
+    template <class U> void infallibleAppend(const U *beginarg, size_t lengtharg) {
+        internalAppend(beginarg, lengtharg);
     }
     template <class U, size_t O, class BP> void infallibleAppend(const Vector<U,O,BP> &other) {
         internalAppend(other);
     }
 
     void popBack();
 
     T popCopy();
@@ -911,22 +911,22 @@ Vector<T,N,AP>::append(const U *insBegin
 #endif
     internalAppend(insBegin, needed);
     return true;
 }
 
 template <class T, size_t N, class AP>
 template <class U>
 JS_ALWAYS_INLINE void
-Vector<T,N,AP>::internalAppend(const U *insBegin, size_t length)
+Vector<T,N,AP>::internalAppend(const U *insBegin, size_t insLength)
 {
-    JS_ASSERT(mLength + length <= mReserved);
+    JS_ASSERT(mLength + insLength <= mReserved);
     JS_ASSERT(mReserved <= mCapacity);
-    Impl::copyConstruct(endNoCheck(), insBegin, insBegin + length);
-    mLength += length;
+    Impl::copyConstruct(endNoCheck(), insBegin, insBegin + insLength);
+    mLength += insLength;
 }
 
 template <class T, size_t N, class AP>
 template <class U, size_t O, class BP>
 inline bool
 Vector<T,N,AP>::append(const Vector<U,O,BP> &other)
 {
     return append(other.begin(), other.end());
@@ -938,19 +938,19 @@ inline void
 Vector<T,N,AP>::internalAppend(const Vector<U,O,BP> &other)
 {
     internalAppend(other.begin(), other.length());
 }
 
 template <class T, size_t N, class AP>
 template <class U>
 JS_ALWAYS_INLINE bool
-Vector<T,N,AP>::append(const U *insBegin, size_t length)
+Vector<T,N,AP>::append(const U *insBegin, size_t insLength)
 {
-    return this->append(insBegin, insBegin + length);
+    return this->append(insBegin, insBegin + insLength);
 }
 
 template <class T, size_t N, class AP>
 JS_ALWAYS_INLINE void
 Vector<T,N,AP>::popBack()
 {
     REENTRANCY_GUARD_ET_AL;
     JS_ASSERT(!empty());
@@ -989,45 +989,45 @@ Vector<T,N,AP>::extractRawBuffer()
         mReserved = 0;
 #endif
     }
     return ret;
 }
 
 template <class T, size_t N, class AP>
 inline void
-Vector<T,N,AP>::replaceRawBuffer(T *p, size_t length)
+Vector<T,N,AP>::replaceRawBuffer(T *p, size_t lengtharg)
 {
     REENTRANCY_GUARD_ET_AL;
 
     /* Destroy what we have. */
     Impl::destroy(beginNoCheck(), endNoCheck());
     if (!usingInlineStorage())
         this->free_(beginNoCheck());
 
     /* Take in the new buffer. */
-    if (length <= sInlineCapacity) {
+    if (lengtharg <= sInlineCapacity) {
         /*
          * We convert to inline storage if possible, even though p might
          * otherwise be acceptable.  Maybe this behaviour should be
          * specifiable with an argument to this function.
          */
         mBegin = (T *)storage.addr();
-        mLength = length;
+        mLength = lengtharg;
         mCapacity = sInlineCapacity;
-        Impl::moveConstruct(mBegin, p, p + length);
-        Impl::destroy(p, p + length);
+        Impl::moveConstruct(mBegin, p, p + lengtharg);
+        Impl::destroy(p, p + lengtharg);
         this->free_(p);
     } else {
         mBegin = p;
-        mLength = length;
-        mCapacity = length;
+        mLength = lengtharg;
+        mCapacity = lengtharg;
     }
 #ifdef DEBUG
-    mReserved = length;
+    mReserved = lengtharg;
 #endif
 }
 
 template <class T, size_t N, class AP>
 inline size_t
 Vector<T,N,AP>::sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf) const
 {
     return usingInlineStorage() ? 0 : mallocSizeOf(beginNoCheck());
diff --git a/js/src/gc/Root.h b/js/src/gc/Root.h
--- a/js/src/gc/Root.h
+++ b/js/src/gc/Root.h
@@ -1052,17 +1052,17 @@ inline void MaybeCheckStackRoots(JSConte
 namespace gc {
 struct Cell;
 } /* namespace gc */
 
 /* Base class for automatic read-only object rooting during compilation. */
 class CompilerRootNode
 {
   protected:
-    CompilerRootNode(js::gc::Cell *ptr) : next(NULL), ptr(ptr) {}
+    CompilerRootNode(js::gc::Cell *ptrarg) : next(NULL), ptr(ptrarg) {}
 
   public:
     void **address() { return (void **)&ptr; }
 
   public:
     CompilerRootNode *next;
 
   protected:
diff --git a/js/src/jsalloc.h b/js/src/jsalloc.h
--- a/js/src/jsalloc.h
+++ b/js/src/jsalloc.h
@@ -55,17 +55,17 @@ class TempAllocPolicy
 
     /*
      * Non-inline helper to call JSRuntime::onOutOfMemory with minimal
      * code bloat.
      */
     JS_FRIEND_API(void *) onOutOfMemory(void *p, size_t nbytes);
 
   public:
-    TempAllocPolicy(JSContext *cx) : cx(cx) {}
+    TempAllocPolicy(JSContext *cxarg) : cx(cxarg) {}
 
     JSContext *context() const {
         return cx;
     }
 
     void *malloc_(size_t bytes) {
         void *p = js_malloc(bytes);
         if (JS_UNLIKELY(!p))
diff --git a/js/src/jsapi.h b/js/src/jsapi.h
--- a/js/src/jsapi.h
+++ b/js/src/jsapi.h
@@ -206,25 +206,25 @@ class AutoValueRooter : private AutoGCRo
   private:
     Value val;
     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 class AutoObjectRooter : private AutoGCRooter
 {
   public:
-    AutoObjectRooter(JSContext *cx, JSObject *obj = NULL
+    AutoObjectRooter(JSContext *cxarg, JSObject *objarg = NULL
                      MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
-      : AutoGCRooter(cx, OBJECT), obj(obj)
+      : AutoGCRooter(cxarg, OBJECT), obj(objarg)
     {
         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
     }
 
-    void setObject(JSObject *obj) {
-        this->obj = obj;
+    void setObject(JSObject *objarg) {
+        this->obj = objarg;
     }
 
     JSObject * object() const {
         return obj;
     }
 
     JSObject ** addr() {
         return &obj;
@@ -234,25 +234,25 @@ class AutoObjectRooter : private AutoGCR
 
   private:
     JSObject *obj;
     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 class AutoStringRooter : private AutoGCRooter {
   public:
-    AutoStringRooter(JSContext *cx, JSString *str = NULL
+    AutoStringRooter(JSContext *cxarg, JSString *strarg = NULL
                      MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
-      : AutoGCRooter(cx, STRING), str(str)
+      : AutoGCRooter(cxarg, STRING), str(strarg)
     {
         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
     }
 
-    void setString(JSString *str) {
-        this->str = str;
+    void setString(JSString *strarg) {
+        this->str = strarg;
     }
 
     JSString * string() const {
         return str;
     }
 
     JSString ** addr() {
         return &str;
@@ -309,19 +309,19 @@ class AutoArrayRooter : private AutoGCRo
 
     js::SkipRoot skip;
 };
 
 template<class T>
 class AutoVectorRooter : protected AutoGCRooter
 {
   public:
-    explicit AutoVectorRooter(JSContext *cx, ptrdiff_t tag
+    explicit AutoVectorRooter(JSContext *cxarg, ptrdiff_t tagarg
                               MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
-      : AutoGCRooter(cx, tag), vector(cx), vectorRoot(cx, &vector)
+      : AutoGCRooter(cxarg, tagarg), vector(cxarg), vectorRoot(cxarg, &vector)
     {
         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
     }
 
     typedef T ElementType;
 
     size_t length() const { return vector.length(); }
     bool empty() const { return vector.empty(); }
@@ -397,19 +397,19 @@ class AutoVectorRooter : protected AutoG
 
 template<class Key, class Value>
 class AutoHashMapRooter : protected AutoGCRooter
 {
   private:
     typedef js::HashMap<Key, Value> HashMapImpl;
 
   public:
-    explicit AutoHashMapRooter(JSContext *cx, ptrdiff_t tag
+    explicit AutoHashMapRooter(JSContext *cxarg, ptrdiff_t tagarg
                                MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
-      : AutoGCRooter(cx, tag), map(cx)
+      : AutoGCRooter(cxarg, tagarg), map(cxarg)
     {
         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
     }
 
     typedef Key KeyType;
     typedef Value ValueType;
     typedef typename HashMapImpl::Lookup Lookup;
     typedef typename HashMapImpl::Ptr Ptr;
@@ -520,19 +520,19 @@ class AutoHashMapRooter : protected Auto
 
 template<class T>
 class AutoHashSetRooter : protected AutoGCRooter
 {
   private:
     typedef js::HashSet<T> HashSetImpl;
 
   public:
-    explicit AutoHashSetRooter(JSContext *cx, ptrdiff_t tag
+    explicit AutoHashSetRooter(JSContext *cxarg, ptrdiff_t tagarg
                                MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
-      : AutoGCRooter(cx, tag), set(cx)
+      : AutoGCRooter(cxarg, tagarg), set(cxarg)
     {
         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
     }
 
     typedef typename HashSetImpl::Lookup Lookup;
     typedef typename HashSetImpl::Ptr Ptr;
     typedef typename HashSetImpl::AddPtr AddPtr;
 
@@ -702,23 +702,23 @@ class CallReceiver
         return JS::MutableHandleValue::fromMarkedLocation(&argv_[-2]);
     }
 
     Value *spAfterCall() const {
         setUsedRval();
         return argv_ - 1;
     }
 
-    void setCallee(Value calleev) const {
+    void setCallee(Value calleevarg) const {
         clearUsedRval();
-        argv_[-2] = calleev;
+        argv_[-2] = calleevarg;
     }
 
-    void setThis(Value thisv) const {
-        argv_[-1] = thisv;
+    void setThis(Value thisvarg) const {
+        argv_[-1] = thisvarg;
     }
 };
 
 JS_ALWAYS_INLINE CallReceiver
 CallReceiverFromArgv(Value *argv)
 {
     CallReceiver receiver;
     receiver.clearUsedRval();
@@ -1504,19 +1504,19 @@ JSVAL_IS_UNIVERSAL(jsval v)
     return !JSVAL_IS_GCTHING(v);
 }
 
 namespace JS {
 
 class AutoIdRooter : private AutoGCRooter
 {
   public:
-    explicit AutoIdRooter(JSContext *cx, jsid id = INT_TO_JSID(0)
+    explicit AutoIdRooter(JSContext *cx, jsid idarg = INT_TO_JSID(0)
                           MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
-      : AutoGCRooter(cx, ID), id_(id)
+      : AutoGCRooter(cx, ID), id_(idarg)
     {
         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
     }
 
     jsid id() {
         return id_;
     }
 
@@ -4994,17 +4994,17 @@ JS_ClearRuntimeThread(JSRuntime *rt);
 extern JS_PUBLIC_API(void)
 JS_SetRuntimeThread(JSRuntime *rt);
 
 class JSAutoSetRuntimeThread
 {
     JSRuntime *runtime;
 
   public:
-    JSAutoSetRuntimeThread(JSRuntime *runtime) : runtime(runtime) {
+    JSAutoSetRuntimeThread(JSRuntime *runtimearg) : runtime(runtimearg) {
         JS_SetRuntimeThread(runtime);
     }
 
     ~JSAutoSetRuntimeThread() {
         JS_ClearRuntimeThread(runtime);
     }
 };
 
diff --git a/js/src/jsclass.h b/js/src/jsclass.h
--- a/js/src/jsclass.h
+++ b/js/src/jsclass.h
@@ -45,17 +45,17 @@ class SpecialId
     /* Needs access to raw bits. */
     friend JS_ALWAYS_INLINE jsid SPECIALID_TO_JSID(const SpecialId &sid);
     friend class PropertyId;
 
     static const uintptr_t TYPE_VOID = JSID_TYPE_VOID;
     static const uintptr_t TYPE_OBJECT = JSID_TYPE_OBJECT;
     static const uintptr_t TYPE_MASK = JSID_TYPE_MASK;
 
-    SpecialId(uintptr_t bits) : bits(bits) { }
+    SpecialId(uintptr_t bitsarg) : bits(bitsarg) { }
 
   public:
     SpecialId() : bits(TYPE_VOID) { }
 
     /* Object-valued */
 
     SpecialId(JSObject &obj)
       : bits(uintptr_t(&obj) | TYPE_OBJECT)
diff --git a/js/src/jscntxt.h b/js/src/jscntxt.h
--- a/js/src/jscntxt.h
+++ b/js/src/jscntxt.h
@@ -2237,26 +2237,26 @@ class RuntimeAllocPolicy
     void reportAllocOverflow() const {}
 };
 
 /*
  * FIXME bug 647103 - replace these *AllocPolicy names.
  */
 class ContextAllocPolicy
 {
-    JSContext *const cx;
+    JSContext *const mContext;
 
   public:
-    ContextAllocPolicy(JSContext *cx) : cx(cx) {}
-    JSContext *context() const { return cx; }
-    void *malloc_(size_t bytes) { return cx->malloc_(bytes); }
-    void *calloc_(size_t bytes) { return cx->calloc_(bytes); }
-    void *realloc_(void *p, size_t oldBytes, size_t bytes) { return cx->realloc_(p, oldBytes, bytes); }
+    ContextAllocPolicy(JSContext *cx) : mContext(cx) {}
+    JSContext *context() const { return mContext; }
+    void *malloc_(size_t bytes) { return mContext->malloc_(bytes); }
+    void *calloc_(size_t bytes) { return mContext->calloc_(bytes); }
+    void *realloc_(void *p, size_t oldBytes, size_t bytes) { return mContext->realloc_(p, oldBytes, bytes); }
     void free_(void *p) { js_free(p); }
-    void reportAllocOverflow() const { js_ReportAllocationOverflow(cx); }
+    void reportAllocOverflow() const { js_ReportAllocationOverflow(mContext); }
 };
 
 JSBool intrinsic_ThrowError(JSContext *cx, unsigned argc, Value *vp);
 JSBool intrinsic_NewDenseArray(JSContext *cx, unsigned argc, Value *vp);
 JSBool intrinsic_UnsafeSetElement(JSContext *cx, unsigned argc, Value *vp);
 JSBool intrinsic_ForceSequential(JSContext *cx, unsigned argc, Value *vp);
 JSBool intrinsic_NewParallelArray(JSContext *cx, unsigned argc, Value *vp);
 
diff --git a/js/src/jsfriendapi.h b/js/src/jsfriendapi.h
--- a/js/src/jsfriendapi.h
+++ b/js/src/jsfriendapi.h
@@ -650,20 +650,20 @@ class ProfileEntry
         return sp == NULL;
     }
 
     uint32_t line() volatile { JS_ASSERT(!js()); return idx; }
     JSScript *script() volatile { JS_ASSERT(js()); return script_; }
     void *stackAddress() volatile { return sp; }
     const char *label() volatile { return string; }
 
-    void setLine(uint32_t line) volatile { JS_ASSERT(!js()); idx = line; }
-    void setLabel(const char *string) volatile { this->string = string; }
-    void setStackAddress(void *sp) volatile { this->sp = sp; }
-    void setScript(JSScript *script) volatile { script_ = script; }
+    void setLine(uint32_t linearg) volatile { JS_ASSERT(!js()); idx = linearg; }
+    void setLabel(const char *stringarg) volatile { this->string = stringarg; }
+    void setStackAddress(void *sparg) volatile { this->sp = sparg; }
+    void setScript(JSScript *scriptarg) volatile { script_ = scriptarg; }
 
     /* we can't know the layout of JSScript, so look in vm/SPSProfiler.cpp */
     JS_FRIEND_API(jsbytecode *) pc() volatile;
     JS_FRIEND_API(void) setPC(jsbytecode *pc) volatile;
 
     static size_t offsetOfString() { return offsetof(ProfileEntry, string); }
     static size_t offsetOfStackAddress() { return offsetof(ProfileEntry, sp); }
     static size_t offsetOfPCIdx() { return offsetof(ProfileEntry, idx); }
diff --git a/js/src/jsproxy.h b/js/src/jsproxy.h
--- a/js/src/jsproxy.h
+++ b/js/src/jsproxy.h
@@ -48,17 +48,17 @@ class JS_FRIEND_API(Wrapper);
  * the derived traps in terms of the fundamental ones. This allows consumers of
  * this class to define any custom behavior they want.
  */
 class JS_FRIEND_API(BaseProxyHandler) {
     void *mFamily;
     bool mHasPrototype;
   protected:
     // Subclasses may set this in their constructor.
-    void setHasPrototype(bool hasPrototype) { mHasPrototype = hasPrototype; }
+    void setHasPrototype(bool hasPrototypeArg) { mHasPrototype = hasPrototypeArg; }
 
   public:
     explicit BaseProxyHandler(void *family);
     virtual ~BaseProxyHandler();
 
     bool hasPrototype() {
         return mHasPrototype;
     }
diff --git a/js/src/jsutil.h b/js/src/jsutil.h
--- a/js/src/jsutil.h
+++ b/js/src/jsutil.h
@@ -49,19 +49,19 @@ struct AlignmentTestStruct
   (sizeof(js::AlignmentTestStruct<t_>) - sizeof(t_))
 
 template <class T>
 class AlignedPtrAndFlag
 {
     uintptr_t bits;
 
   public:
-    AlignedPtrAndFlag(T *t, bool flag) {
+    AlignedPtrAndFlag(T *t, bool flagarg) {
         JS_ASSERT((uintptr_t(t) & 1) == 0);
-        bits = uintptr_t(t) | uintptr_t(flag);
+        bits = uintptr_t(t) | uintptr_t(flagarg);
     }
 
     T *ptr() const {
         return (T *)(bits & ~uintptr_t(1));
     }
 
     bool flag() const {
         return (bits & 1) != 0;
@@ -75,19 +75,19 @@ class AlignedPtrAndFlag
     void setFlag() {
         bits |= 1;
     }
 
     void unsetFlag() {
         bits &= ~uintptr_t(1);
     }
 
-    void set(T *t, bool flag) {
+    void set(T *t, bool flagarg) {
         JS_ASSERT((uintptr_t(t) & 1) == 0);
-        bits = uintptr_t(t) | flag;
+        bits = uintptr_t(t) | flagarg;
     }
 };
 
 template <class T>
 static inline void
 Reverse(T *beg, T *end)
 {
     while (beg != end) {
@@ -155,19 +155,19 @@ ImplicitCast(U &u)
     T &t = u;
     return t;
 }
 
 template<typename T>
 class AutoScopedAssign
 {
   public:
-    AutoScopedAssign(T *addr, const T &value
+    AutoScopedAssign(T *addrarg, const T &value
                      MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
-        : addr(addr), old(*addr)
+        : addr(addrarg), old(*addr)
     {
         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
         *addr = value;
     }
 
     ~AutoScopedAssign() { *addr = old; }
 
   private:
