From: L. David Baron <dbaron@dbaron.org>

Fix variable shadowing that would become noisy with -Wshadow enabled.  (Bug 563195)

diff --git a/js/src/jsapi.h b/js/src/jsapi.h
--- a/js/src/jsapi.h
+++ b/js/src/jsapi.h
@@ -3364,40 +3364,40 @@ class JSAutoStructuredCloneBuffer {
         : cx_(NULL), data_(NULL), nbytes_(0), version_(JS_STRUCTURED_CLONE_VERSION) {}
 
     ~JSAutoStructuredCloneBuffer() { clear(); }
 
     JSContext *cx() const { return cx_; }
     uint64 *data() const { return data_; }
     size_t nbytes() const { return nbytes_; }
 
-    void clear(JSContext *cx=NULL) {
+    void clear(JSContext *cxarg=NULL) {
         if (data_) {
-            if (!cx)
-                cx = cx_;
-            JS_ASSERT(cx);
-            JS_free(cx, data_);
+            if (!cxarg)
+                cxarg = cx_;
+            JS_ASSERT(cxarg);
+            JS_free(cxarg, data_);
             cx_ = NULL;
             data_ = NULL;
             nbytes_ = 0;
             version_ = 0;
         }
     }
 
     /*
      * Adopt some memory. It will be automatically freed by the destructor.
      * data must have been allocated using JS_malloc.
      */
-    void adopt(JSContext *cx, uint64 *data, size_t nbytes,
-               uint32 version=JS_STRUCTURED_CLONE_VERSION) {
-        clear(cx);
-        cx_ = cx;
-        data_ = data;
-        nbytes_ = nbytes;
-        version_ = version;
+    void adopt(JSContext *cxarg, uint64 *dataarg, size_t nbytesarg,
+               uint32 versionarg=JS_STRUCTURED_CLONE_VERSION) {
+        clear(cxarg);
+        cx_ = cxarg;
+        data_ = dataarg;
+        nbytes_ = nbytesarg;
+        version_ = versionarg;
     }
 
     /*
      * Remove the buffer so that it will not be automatically freed.
      * After this, the caller is responsible for calling JS_free(*datap).
      */
     void steal(uint64 **datap, size_t *nbytesp, JSContext **cxp=NULL,
                uint32 *versionp=NULL) {
@@ -3409,60 +3409,60 @@ class JSAutoStructuredCloneBuffer {
             *versionp = version_;
 
         cx_ = NULL;
         data_ = NULL;
         nbytes_ = 0;
         version_ = 0;
     }
 
-    bool read(jsval *vp, JSContext *cx=NULL,
+    bool read(jsval *vp, JSContext *cxarg=NULL,
               const JSStructuredCloneCallbacks *optionalCallbacks=NULL,
               void *closure=NULL) const {
-        if (!cx)
-            cx = cx_;
-        JS_ASSERT(cx);
+        if (!cxarg)
+            cxarg = cx_;
+        JS_ASSERT(cxarg);
         JS_ASSERT(data_);
-        return !!JS_ReadStructuredClone(cx, data_, nbytes_, version_, vp,
+        return !!JS_ReadStructuredClone(cxarg, data_, nbytes_, version_, vp,
                                         optionalCallbacks, closure);
     }
 
-    bool write(JSContext *cx, jsval v,
+    bool write(JSContext *cxarg, jsval v,
                const JSStructuredCloneCallbacks *optionalCallbacks=NULL,
                void *closure=NULL) {
-        clear(cx);
-        cx_ = cx;
-        bool ok = !!JS_WriteStructuredClone(cx, v, &data_, &nbytes_,
+        clear(cxarg);
+        cx_ = cxarg;
+        bool ok = !!JS_WriteStructuredClone(cxarg, v, &data_, &nbytes_,
                                             optionalCallbacks, closure);
         if (!ok) {
             data_ = NULL;
             nbytes_ = 0;
             version_ = JS_STRUCTURED_CLONE_VERSION;
         }
         return ok;
     }
 
     /**
      * Swap ownership with another JSAutoStructuredCloneBuffer.
      */
     void swap(JSAutoStructuredCloneBuffer &other) {
-        JSContext *cx = other.cx_;
-        uint64 *data = other.data_;
-        size_t nbytes = other.nbytes_;
-        uint32 version = other.version_;
+        JSContext *tmpcx = other.cx_;
+        uint64 *tmpdata = other.data_;
+        size_t tmpnbytes = other.nbytes_;
+        uint32 tmpversion = other.version_;
 
         other.cx_ = this->cx_;
         other.data_ = this->data_;
         other.nbytes_ = this->nbytes_;
         other.version_ = this->version_;
 
-        this->cx_ = cx;
-        this->data_ = data;
-        this->nbytes_ = nbytes;
-        this->version_ = version;
+        this->cx_ = tmpcx;
+        this->data_ = tmpdata;
+        this->nbytes_ = tmpnbytes;
+        this->version_ = tmpversion;
     }
 
   private:
     /* Copy and assignment are not supported. */
     JSAutoStructuredCloneBuffer(const JSAutoStructuredCloneBuffer &other);
     JSAutoStructuredCloneBuffer &operator=(const JSAutoStructuredCloneBuffer &other);
 };
 #endif
diff --git a/js/src/jscntxt.h b/js/src/jscntxt.h
--- a/js/src/jscntxt.h
+++ b/js/src/jscntxt.h
@@ -2491,25 +2491,25 @@ class RuntimeAllocPolicy
     void reportAllocOverflow() const {}
 };
 
 /*
  * FIXME bug 647103 - replace these *AllocPolicy names.
  */
 class ContextAllocPolicy
 {
-    JSContext *const cx;
+    JSContext *const mContext;
 
   public:
-    ContextAllocPolicy(JSContext *cx) : cx(cx) {}
-    JSContext *context() const { return cx; }
-    void *malloc_(size_t bytes) { return cx->malloc_(bytes); }
-    void *realloc_(void *p, size_t oldBytes, size_t bytes) { return cx->realloc_(p, oldBytes, bytes); }
-    void free_(void *p) { cx->free_(p); }
-    void reportAllocOverflow() const { js_ReportAllocationOverflow(cx); }
+    ContextAllocPolicy(JSContext *cx) : mContext(cx) {}
+    JSContext *context() const { return mContext; }
+    void *malloc_(size_t bytes) { return mContext->malloc_(bytes); }
+    void *realloc_(void *p, size_t oldBytes, size_t bytes) { return mContext->realloc_(p, oldBytes, bytes); }
+    void free_(void *p) { mContext->free_(p); }
+    void reportAllocOverflow() const { js_ReportAllocationOverflow(mContext); }
 };
 
 } /* namespace js */
 
 #ifdef _MSC_VER
 #pragma warning(pop)
 #pragma warning(pop)
 #endif
diff --git a/js/src/jshashtable.h b/js/src/jshashtable.h
--- a/js/src/jshashtable.h
+++ b/js/src/jshashtable.h
@@ -125,17 +125,17 @@ class HashTable : private AllocPolicy
     {
         friend class HashTable;
         typedef void (Ptr::* ConvertibleToBool)();
         void nonNull() {}
 
         Entry *entry;
 
       protected:
-        Ptr(Entry &entry) : entry(&entry) {}
+        Ptr(Entry &entryarg) : entry(&entryarg) {}
 
       public:
         /* Leaves Ptr uninitialized. */
         Ptr() {
 #ifdef DEBUG
             entry = (Entry *)0xbad;
 #endif
         }
@@ -152,20 +152,20 @@ class HashTable : private AllocPolicy
     /* A Ptr that can be used to add a key after a failed lookup. */
     class AddPtr : public Ptr
     {
         friend class HashTable;
         HashNumber keyHash;
 #ifdef DEBUG
         uint64 mutationCount;
 
-        AddPtr(Entry &entry, HashNumber hn, uint64 mutationCount)
-            : Ptr(entry), keyHash(hn), mutationCount(mutationCount) {}
+        AddPtr(Entry &entryarg, HashNumber hn, uint64 mutationCount)
+            : Ptr(entryarg), keyHash(hn), mutationCount(mutationCount) {}
 #else
-        AddPtr(Entry &entry, HashNumber hn) : Ptr(entry), keyHash(hn) {}
+        AddPtr(Entry &entryarg, HashNumber hn) : Ptr(entryarg), keyHash(hn) {}
 #endif
       public:
         /* Leaves AddPtr uninitialized. */
         AddPtr() {}
     };
 
     /*
      * A collection of hash table entries. The collection is enumerated by
diff --git a/js/src/jstl.h b/js/src/jstl.h
--- a/js/src/jstl.h
+++ b/js/src/jstl.h
@@ -225,19 +225,19 @@ RoundUpPow2(size_t x)
 }
 
 template <class T>
 class AlignedPtrAndFlag
 {
     uintptr_t bits;
 
   public:
-    AlignedPtrAndFlag(T *t, bool flag) {
+    AlignedPtrAndFlag(T *t, bool flagarg) {
         JS_ASSERT((uintptr_t(t) & 1) == 0);
-        bits = uintptr_t(t) | uintptr_t(flag);
+        bits = uintptr_t(t) | uintptr_t(flagarg);
     }
 
     T *ptr() const {
         return (T *)(bits & ~uintptr_t(1));
     }
 
     bool flag() const {
         return (bits & 1) != 0;
@@ -251,19 +251,19 @@ class AlignedPtrAndFlag
     void setFlag() {
         bits |= 1;
     }
 
     void unsetFlag() {
         bits &= ~uintptr_t(1);
     }
 
-    void set(T *t, bool flag) {
+    void set(T *t, bool flagarg) {
         JS_ASSERT((uintptr_t(t) & 1) == 0);
-        bits = uintptr_t(t) | flag;
+        bits = uintptr_t(t) | flagarg;
     }
 };
 
 template <class T>
 static inline void
 Reverse(T *beg, T *end)
 {
     while (beg != end) {
