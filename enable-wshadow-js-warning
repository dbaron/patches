From: L. David Baron <dbaron@dbaron.org>

Bug 563195:  Fix -Wshadow warnings in public JS API headers (those used from layout/style/).

diff --git a/dom/base/nsJSEnvironment.cpp b/dom/base/nsJSEnvironment.cpp
--- a/dom/base/nsJSEnvironment.cpp
+++ b/dom/base/nsJSEnvironment.cpp
@@ -3235,17 +3235,17 @@ DOMGCSliceCallback(JSRuntime *aRt, JS::G
     nsJSContext::KillInterSliceGCTimer();
 
     sCCollectedWaitingForGC = 0;
     sCleanupsSinceLastGC = 0;
     sNeedsFullCC = true;
     sHasRunGC = true;
     nsJSContext::MaybePokeCC();
 
-    if (aDesc.isCompartment) {
+    if (aDesc.isCompartment_) {
       ++sCompartmentGCCount;
       if (!sFullGCTimer && !sShuttingDown) {
         CallCreateInstance("@mozilla.org/timer;1", &sFullGCTimer);
         JS::gcreason::Reason reason = JS::gcreason::FULL_GC_TIMER;
         sFullGCTimer->InitWithFuncCallback(FullGCTimerFired,
                                            reinterpret_cast<void *>(reason),
                                            NS_FULL_GC_DELAY,
                                            nsITimer::TYPE_ONE_SHOT);
diff --git a/js/public/CharacterEncoding.h b/js/public/CharacterEncoding.h
--- a/js/public/CharacterEncoding.h
+++ b/js/public/CharacterEncoding.h
@@ -23,61 +23,61 @@ namespace JS {
  * string containing characters beyond U+00FF.
  */
 class Latin1Chars : public mozilla::Range<unsigned char>
 {
     typedef mozilla::Range<unsigned char> Base;
 
   public:
     Latin1Chars() : Base() {}
-    Latin1Chars(char *bytes, size_t length) : Base(reinterpret_cast<unsigned char *>(bytes), length) {}
-    Latin1Chars(const char *bytes, size_t length)
-      : Base(reinterpret_cast<unsigned char *>(const_cast<char *>(bytes)), length)
+    Latin1Chars(char *aBytes, size_t aLength) : Base(reinterpret_cast<unsigned char *>(aBytes), aLength) {}
+    Latin1Chars(const char *aBytes, size_t aLength)
+      : Base(reinterpret_cast<unsigned char *>(const_cast<char *>(aBytes)), aLength)
     {}
 };
 
 /*
  * A Latin1Chars, but with \0 termination for C compatibility.
  */
 class Latin1CharsZ : public mozilla::RangedPtr<unsigned char>
 {
     typedef mozilla::RangedPtr<unsigned char> Base;
 
   public:
     Latin1CharsZ() : Base(NULL, 0) {}
 
-    Latin1CharsZ(char *bytes, size_t length)
-      : Base(reinterpret_cast<unsigned char *>(bytes), length)
+    Latin1CharsZ(char *aBytes, size_t aLength)
+      : Base(reinterpret_cast<unsigned char *>(aBytes), aLength)
     {
-        JS_ASSERT(bytes[length] == '\0');
+        JS_ASSERT(aBytes[aLength] == '\0');
     }
 
-    Latin1CharsZ(unsigned char *bytes, size_t length)
-      : Base(bytes, length)
+    Latin1CharsZ(unsigned char *aBytes, size_t aLength)
+      : Base(aBytes, aLength)
     {
-        JS_ASSERT(bytes[length] == '\0');
+        JS_ASSERT(aBytes[aLength] == '\0');
     }
 
     char *c_str() { return reinterpret_cast<char *>(get()); }
 };
 
 /*
  * SpiderMonkey also deals directly with UTF-8 encoded text in some places.
  */
 class UTF8CharsZ : public mozilla::RangedPtr<unsigned char>
 {
     typedef mozilla::RangedPtr<unsigned char> Base;
 
   public:
     UTF8CharsZ() : Base(NULL, 0) {}
 
-    UTF8CharsZ(char *bytes, size_t length)
-      : Base(reinterpret_cast<unsigned char *>(bytes), length)
+    UTF8CharsZ(char *aBytes, size_t aLength)
+      : Base(reinterpret_cast<unsigned char *>(aBytes), aLength)
     {
-        JS_ASSERT(bytes[length] == '\0');
+        JS_ASSERT(aBytes[aLength] == '\0');
     }
 };
 
 /*
  * SpiderMonkey uses a 2-byte character representation: it is a
  * 2-byte-at-a-time view of a UTF-16 byte stream. This is similar to UCS-2,
  * but unlike UCS-2, we do not strip UTF-16 extension bytes. This allows a
  * sufficiently dedicated JavaScript program to be fully unicode-aware by
@@ -85,33 +85,33 @@ class UTF8CharsZ : public mozilla::Range
  * string.
  */
 class TwoByteChars : public mozilla::Range<jschar>
 {
     typedef mozilla::Range<jschar> Base;
 
   public:
     TwoByteChars() : Base() {}
-    TwoByteChars(jschar *chars, size_t length) : Base(chars, length) {}
-    TwoByteChars(const jschar *chars, size_t length) : Base(const_cast<jschar *>(chars), length) {}
+    TwoByteChars(jschar *charsarg, size_t aLength) : Base(charsarg, aLength) {}
+    TwoByteChars(const jschar *charsarg, size_t aLength) : Base(const_cast<jschar *>(charsarg), aLength) {}
 };
 
 /*
  * A non-convertible variant of TwoByteChars that does not refer to characters
  * inlined inside a JSShortString or a JSInlineString. StableTwoByteChars are
  * thus safe to hold across a GC.
  */
 class StableTwoByteChars : public mozilla::Range<jschar>
 {
     typedef mozilla::Range<jschar> Base;
 
   public:
     StableTwoByteChars() : Base() {}
-    StableTwoByteChars(jschar *chars, size_t length) : Base(chars, length) {}
-    StableTwoByteChars(const jschar *chars, size_t length) : Base(const_cast<jschar *>(chars), length) {}
+    StableTwoByteChars(jschar *charsarg, size_t aLength) : Base(charsarg, aLength) {}
+    StableTwoByteChars(const jschar *charsarg, size_t aLength) : Base(const_cast<jschar *>(charsarg), aLength) {}
 };
 
 /*
  * A TwoByteChars, but \0 terminated for compatibility with JSFlatString.
  */
 class TwoByteCharsZ : public mozilla::RangedPtr<jschar>
 {
     typedef mozilla::RangedPtr<jschar> Base;
diff --git a/js/public/GCAPI.h b/js/public/GCAPI.h
--- a/js/public/GCAPI.h
+++ b/js/public/GCAPI.h
@@ -116,20 +116,20 @@ enum GCProgress {
 
     GC_CYCLE_BEGIN,
     GC_SLICE_BEGIN,
     GC_SLICE_END,
     GC_CYCLE_END
 };
 
 struct JS_FRIEND_API(GCDescription) {
-    bool isCompartment;
+    bool isCompartment_;
 
     GCDescription(bool isCompartment)
-      : isCompartment(isCompartment) {}
+      : isCompartment_(isCompartment) {}
 
     jschar *formatMessage(JSRuntime *rt) const;
     jschar *formatJSON(JSRuntime *rt, uint64_t timestamp) const;
 };
 
 typedef void
 (* GCSliceCallback)(JSRuntime *rt, GCProgress progress, const GCDescription &desc);
 
diff --git a/js/public/HashTable.h b/js/public/HashTable.h
--- a/js/public/HashTable.h
+++ b/js/public/HashTable.h
@@ -659,36 +659,36 @@ class HashTable : private AllocPolicy
     // |if (p) p->...|. Ptr objects must not be used after any mutating hash
     // table operations unless |generation()| is tested.
     class Ptr
     {
         friend class HashTable;
         typedef void (Ptr::* ConvertibleToBool)();
         void nonNull() {}
 
-        Entry *entry;
+        Entry *entry_;
 
       protected:
-        Ptr(Entry &entry) : entry(&entry) {}
+        Ptr(Entry &entry) : entry_(&entry) {}
 
       public:
         // Leaves Ptr uninitialized.
         Ptr() {
 #ifdef DEBUG
-            entry = (Entry *)0xbad;
+            entry_ = (Entry *)0xbad;
 #endif
         }
 
-        bool found() const                    { return entry->isLive(); }
+        bool found() const                    { return entry_->isLive(); }
         operator ConvertibleToBool() const    { return found() ? &Ptr::nonNull : 0; }
-        bool operator==(const Ptr &rhs) const { JS_ASSERT(found() && rhs.found()); return entry == rhs.entry; }
+        bool operator==(const Ptr &rhs) const { JS_ASSERT(found() && rhs.found()); return entry_ == rhs.entry_; }
         bool operator!=(const Ptr &rhs) const { return !(*this == rhs); }
 
-        T &operator*() const                  { return entry->get(); }
-        T *operator->() const                 { return &entry->get(); }
+        T &operator*() const                  { return entry_->get(); }
+        T *operator->() const                 { return &entry_->get(); }
     };
 
     // A Ptr that can be used to add a key after a failed lookup.
     class AddPtr : public Ptr
     {
         friend class HashTable;
         HashNumber keyHash;
         mozilla::DebugOnly<uint64_t> mutationCount;
@@ -919,32 +919,32 @@ class HashTable : private AllocPolicy
         JS_ASSERT(!initialized());
 
         // Correct for sMaxAlphaFrac such that the table will not resize
         // when adding 'length' entries.
         if (length > sMaxInit) {
             this->reportAllocOverflow();
             return false;
         }
-        uint32_t capacity = (length * sInvMaxAlpha) >> 7;
+        uint32_t newCapacity = (length * sInvMaxAlpha) >> 7;
 
-        if (capacity < sMinCapacity)
-            capacity = sMinCapacity;
+        if (newCapacity < sMinCapacity)
+            newCapacity = sMinCapacity;
 
         // FIXME: use JS_CEILING_LOG2 when PGO stops crashing (bug 543034).
         uint32_t roundUp = sMinCapacity, roundUpLog2 = sMinCapacityLog2;
-        while (roundUp < capacity) {
+        while (roundUp < newCapacity) {
             roundUp <<= 1;
             ++roundUpLog2;
         }
 
-        capacity = roundUp;
-        JS_ASSERT(capacity <= sMaxCapacity);
+        newCapacity = roundUp;
+        JS_ASSERT(newCapacity <= sMaxCapacity);
 
-        table = createTable(*this, capacity);
+        table = createTable(*this, newCapacity);
         if (!table)
             return false;
 
         setTableSizeLog2(roundUpLog2);
         METER(memset(&stats, 0, sizeof(stats)));
         return true;
     }
 
diff --git a/js/public/MemoryMetrics.h b/js/public/MemoryMetrics.h
--- a/js/public/MemoryMetrics.h
+++ b/js/public/MemoryMetrics.h
@@ -312,17 +312,17 @@ struct RuntimeStats
       , gcHeapUnusedChunks(0)
       , gcHeapUnusedArenas(0)
       , gcHeapUnusedGcThings(0)
       , gcHeapChunkAdmin(0)
       , gcHeapGcThings(0)
       , totals()
       , compartmentStatsVector()
       , currCompartmentStats(NULL)
-      , mallocSizeOf(mallocSizeOf)
+      , mallocSizeOf_(mallocSizeOf)
     {}
 
     RuntimeSizes runtime;
 
     // If you add a new number, remember to update the constructor!
 
     // Here's a useful breakdown of the GC heap.
     //
@@ -352,37 +352,37 @@ struct RuntimeStats
     size_t gcHeapGcThings;
 
     // The sum of all compartment's measurements.
     CompartmentStats totals;
  
     js::Vector<CompartmentStats, 0, js::SystemAllocPolicy> compartmentStatsVector;
     CompartmentStats *currCompartmentStats;
 
-    JSMallocSizeOfFun mallocSizeOf;
+    JSMallocSizeOfFun mallocSizeOf_;
 
     virtual void initExtraCompartmentStats(JSCompartment *c, CompartmentStats *cstats) = 0;
 };
 
 #ifdef JS_THREADSAFE
 
 class ObjectPrivateVisitor
 {
 public:
     // Within CollectRuntimeStats, this method is called for each JS object
     // that has an nsISupports pointer.
     virtual size_t sizeOfIncludingThis(nsISupports *aSupports) = 0;
 
     // A callback that gets a JSObject's nsISupports pointer, if it has one.
     // Note: this function does *not* addref |iface|.
     typedef JSBool(*GetISupportsFun)(JSObject *obj, nsISupports **iface);
-    GetISupportsFun getISupports;
+    GetISupportsFun getISupports_;
 
     ObjectPrivateVisitor(GetISupportsFun getISupports)
-      : getISupports(getISupports)
+      : getISupports_(getISupports)
     {}
 };
 
 extern JS_PUBLIC_API(bool)
 CollectRuntimeStats(JSRuntime *rt, RuntimeStats *rtStats, ObjectPrivateVisitor *opv);
 
 extern JS_PUBLIC_API(int64_t)
 GetExplicitNonHeapForRuntime(JSRuntime *rt, JSMallocSizeOfFun mallocSizeOf);
diff --git a/js/public/Vector.h b/js/public/Vector.h
--- a/js/public/Vector.h
+++ b/js/public/Vector.h
@@ -374,17 +374,17 @@ class Vector : private AllocPolicy
     const T &back() const {
         JS_ASSERT(!entered && !empty());
         return *(end() - 1);
     }
 
     class Range {
         friend class Vector;
         T *cur, *end;
-        Range(T *cur, T *end) : cur(cur), end(end) {}
+        Range(T *curarg, T *endarg) : cur(curarg), end(endarg) {}
       public:
         Range() {}
         bool empty() const { return cur == end; }
         size_t remain() const { return end - cur; }
         T &front() const { return *cur; }
         void popFront() { JS_ASSERT(!empty()); ++cur; }
         T popCopyFront() { JS_ASSERT(!empty()); return *cur++; }
     };
@@ -442,21 +442,21 @@ class Vector : private AllocPolicy
      * memory has been pre-reserved.
      */
     void infallibleAppend(const T &t) {
         internalAppend(t);
     }
     void infallibleAppendN(const T &t, size_t n) {
         internalAppendN(t, n);
     }
-    template <class U> void infallibleAppend(const U *begin, const U *end) {
-        internalAppend(begin, mozilla::PointerRangeSize(begin, end));
+    template <class U> void infallibleAppend(const U *aBegin, const U *endarg) {
+        internalAppend(aBegin, mozilla::PointerRangeSize(aBegin, endarg));
     }
-    template <class U> void infallibleAppend(const U *begin, size_t length) {
-        internalAppend(begin, length);
+    template <class U> void infallibleAppend(const U *aBegin, size_t aLength) {
+        internalAppend(aBegin, aLength);
     }
     template <class U, size_t O, class BP> void infallibleAppend(const Vector<U,O,BP> &other) {
         internalAppend(other);
     }
 
     void popBack();
 
     T popCopy();
@@ -911,22 +911,22 @@ Vector<T,N,AP>::append(const U *insBegin
 #endif
     internalAppend(insBegin, needed);
     return true;
 }
 
 template <class T, size_t N, class AP>
 template <class U>
 JS_ALWAYS_INLINE void
-Vector<T,N,AP>::internalAppend(const U *insBegin, size_t length)
+Vector<T,N,AP>::internalAppend(const U *insBegin, size_t insLength)
 {
-    JS_ASSERT(mLength + length <= mReserved);
+    JS_ASSERT(mLength + insLength <= mReserved);
     JS_ASSERT(mReserved <= mCapacity);
-    Impl::copyConstruct(endNoCheck(), insBegin, insBegin + length);
-    mLength += length;
+    Impl::copyConstruct(endNoCheck(), insBegin, insBegin + insLength);
+    mLength += insLength;
 }
 
 template <class T, size_t N, class AP>
 template <class U, size_t O, class BP>
 inline bool
 Vector<T,N,AP>::append(const Vector<U,O,BP> &other)
 {
     return append(other.begin(), other.end());
@@ -938,19 +938,19 @@ inline void
 Vector<T,N,AP>::internalAppend(const Vector<U,O,BP> &other)
 {
     internalAppend(other.begin(), other.length());
 }
 
 template <class T, size_t N, class AP>
 template <class U>
 JS_ALWAYS_INLINE bool
-Vector<T,N,AP>::append(const U *insBegin, size_t length)
+Vector<T,N,AP>::append(const U *insBegin, size_t insLength)
 {
-    return this->append(insBegin, insBegin + length);
+    return this->append(insBegin, insBegin + insLength);
 }
 
 template <class T, size_t N, class AP>
 JS_ALWAYS_INLINE void
 Vector<T,N,AP>::popBack()
 {
     REENTRANCY_GUARD_ET_AL;
     JS_ASSERT(!empty());
@@ -989,45 +989,45 @@ Vector<T,N,AP>::extractRawBuffer()
         mReserved = 0;
 #endif
     }
     return ret;
 }
 
 template <class T, size_t N, class AP>
 inline void
-Vector<T,N,AP>::replaceRawBuffer(T *p, size_t length)
+Vector<T,N,AP>::replaceRawBuffer(T *p, size_t aLength)
 {
     REENTRANCY_GUARD_ET_AL;
 
     /* Destroy what we have. */
     Impl::destroy(beginNoCheck(), endNoCheck());
     if (!usingInlineStorage())
         this->free_(beginNoCheck());
 
     /* Take in the new buffer. */
-    if (length <= sInlineCapacity) {
+    if (aLength <= sInlineCapacity) {
         /*
          * We convert to inline storage if possible, even though p might
          * otherwise be acceptable.  Maybe this behaviour should be
          * specifiable with an argument to this function.
          */
         mBegin = (T *)storage.addr();
-        mLength = length;
+        mLength = aLength;
         mCapacity = sInlineCapacity;
-        Impl::moveConstruct(mBegin, p, p + length);
-        Impl::destroy(p, p + length);
+        Impl::moveConstruct(mBegin, p, p + aLength);
+        Impl::destroy(p, p + aLength);
         this->free_(p);
     } else {
         mBegin = p;
-        mLength = length;
-        mCapacity = length;
+        mLength = aLength;
+        mCapacity = aLength;
     }
 #ifdef DEBUG
-    mReserved = length;
+    mReserved = aLength;
 #endif
 }
 
 template <class T, size_t N, class AP>
 inline size_t
 Vector<T,N,AP>::sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf) const
 {
     return usingInlineStorage() ? 0 : mallocSizeOf(beginNoCheck());
diff --git a/js/src/gc/Root.h b/js/src/gc/Root.h
--- a/js/src/gc/Root.h
+++ b/js/src/gc/Root.h
@@ -1052,26 +1052,26 @@ inline void MaybeCheckStackRoots(JSConte
 namespace gc {
 struct Cell;
 } /* namespace gc */
 
 /* Base class for automatic read-only object rooting during compilation. */
 class CompilerRootNode
 {
   protected:
-    CompilerRootNode(js::gc::Cell *ptr) : next(NULL), ptr(ptr) {}
+    CompilerRootNode(js::gc::Cell *ptr) : next(NULL), ptr_(ptr) {}
 
   public:
-    void **address() { return (void **)&ptr; }
+    void **address() { return (void **)&ptr_; }
 
   public:
     CompilerRootNode *next;
 
   protected:
-    js::gc::Cell *ptr;
+    js::gc::Cell *ptr_;
 };
 
 }  /* namespace js */
 
 ForwardDeclareJS(Script);
 ForwardDeclareJS(Function);
 ForwardDeclareJS(Object);
 
diff --git a/js/src/jsalloc.h b/js/src/jsalloc.h
--- a/js/src/jsalloc.h
+++ b/js/src/jsalloc.h
@@ -46,29 +46,29 @@ class SystemAllocPolicy
  * the lifetime of the container, this policy may only be used for containers
  * whose lifetime is a shorter than the given JSContext.
  *
  * FIXME bug 647103 - rewrite this in terms of temporary allocation functions,
  * not the system ones.
  */
 class TempAllocPolicy
 {
-    JSContext *const cx;
+    JSContext *const cx_;
 
     /*
      * Non-inline helper to call JSRuntime::onOutOfMemory with minimal
      * code bloat.
      */
     JS_FRIEND_API(void *) onOutOfMemory(void *p, size_t nbytes);
 
   public:
-    TempAllocPolicy(JSContext *cx) : cx(cx) {}
+    TempAllocPolicy(JSContext *cx) : cx_(cx) {}
 
     JSContext *context() const {
-        return cx;
+        return cx_;
     }
 
     void *malloc_(size_t bytes) {
         void *p = js_malloc(bytes);
         if (JS_UNLIKELY(!p))
             p = onOutOfMemory(NULL, bytes);
         return p;
     }
diff --git a/js/src/jsapi.h b/js/src/jsapi.h
--- a/js/src/jsapi.h
+++ b/js/src/jsapi.h
@@ -103,17 +103,17 @@ class JS_PUBLIC_API(AutoGCRooter) {
 
     /*
      * Discriminates actual subclass of this being used.  If non-negative, the
      * subclass roots an array of values of the length stored in this field.
      * If negative, meaning is indicated by the corresponding value in the enum
      * below.  Any other negative value indicates some deeper problem such as
      * memory corruption.
      */
-    ptrdiff_t tag;
+    ptrdiff_t tag_;
 
     enum {
         JSVAL =        -1, /* js::AutoValueRooter */
         VALARRAY =     -2, /* js::AutoValueArray */
         PARSER =       -3, /* js::frontend::Parser */
         SHAPEVECTOR =  -4, /* js::AutoShapeVector */
         IDARRAY =      -6, /* js::AutoIdArray */
         DESCRIPTORS =  -7, /* js::AutoPropDescArrayRooter */
@@ -172,138 +172,138 @@ class AutoValueRooter : private AutoGCRo
 
     /*
      * If you are looking for Object* overloads, use AutoObjectRooter instead;
      * rooting Object*s as a js::Value requires discerning whether or not it is
      * a function object. Also, AutoObjectRooter is smaller.
      */
 
     void set(Value v) {
-        JS_ASSERT(tag == JSVAL);
+        JS_ASSERT(tag_ == JSVAL);
         val = v;
     }
 
     const Value &value() const {
-        JS_ASSERT(tag == JSVAL);
+        JS_ASSERT(tag_ == JSVAL);
         return val;
     }
 
     Value *addr() {
-        JS_ASSERT(tag == JSVAL);
+        JS_ASSERT(tag_ == JSVAL);
         return &val;
     }
 
     const Value &jsval_value() const {
-        JS_ASSERT(tag == JSVAL);
+        JS_ASSERT(tag_ == JSVAL);
         return val;
     }
 
     Value *jsval_addr() {
-        JS_ASSERT(tag == JSVAL);
+        JS_ASSERT(tag_ == JSVAL);
         return &val;
     }
 
     friend void AutoGCRooter::trace(JSTracer *trc);
 
   private:
     Value val;
     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 class AutoObjectRooter : private AutoGCRooter
 {
   public:
     AutoObjectRooter(JSContext *cx, JSObject *obj = NULL
                      MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
-      : AutoGCRooter(cx, OBJECT), obj(obj)
+      : AutoGCRooter(cx, OBJECT), obj_(obj)
     {
         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
     }
 
     void setObject(JSObject *obj) {
-        this->obj = obj;
+        obj_ = obj;
     }
 
     JSObject * object() const {
-        return obj;
+        return obj_;
     }
 
     JSObject ** addr() {
-        return &obj;
+        return &obj_;
     }
 
     friend void AutoGCRooter::trace(JSTracer *trc);
 
   private:
-    JSObject *obj;
+    JSObject *obj_;
     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 class AutoStringRooter : private AutoGCRooter {
   public:
     AutoStringRooter(JSContext *cx, JSString *str = NULL
                      MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
-      : AutoGCRooter(cx, STRING), str(str)
+      : AutoGCRooter(cx, STRING), str_(str)
     {
         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
     }
 
     void setString(JSString *str) {
-        this->str = str;
+        str_ = str;
     }
 
     JSString * string() const {
-        return str;
+        return str_;
     }
 
     JSString ** addr() {
-        return &str;
+        return &str_;
     }
 
     JSString * const * addr() const {
-        return &str;
+        return &str_;
     }
 
     friend void AutoGCRooter::trace(JSTracer *trc);
 
   private:
-    JSString *str;
+    JSString *str_;
     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 class AutoArrayRooter : private AutoGCRooter {
   public:
     AutoArrayRooter(JSContext *cx, size_t len, Value *vec
                     MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
       : AutoGCRooter(cx, len), array(vec), skip(cx, array, len)
     {
         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
-        JS_ASSERT(tag >= 0);
+        JS_ASSERT(tag_ >= 0);
     }
 
     void changeLength(size_t newLength) {
-        tag = ptrdiff_t(newLength);
-        JS_ASSERT(tag >= 0);
+        tag_ = ptrdiff_t(newLength);
+        JS_ASSERT(tag_ >= 0);
     }
 
     void changeArray(Value *newArray, size_t newLength) {
         changeLength(newLength);
         array = newArray;
     }
 
     Value *array;
 
     MutableHandleValue handleAt(size_t i)
     {
-        JS_ASSERT(i < size_t(tag));
+        JS_ASSERT(i < size_t(tag_));
         return MutableHandleValue::fromMarkedLocation(&array[i]);
     }
     HandleValue handleAt(size_t i) const
     {
-        JS_ASSERT(i < size_t(tag));
+        JS_ASSERT(i < size_t(tag_));
         return HandleValue::fromMarkedLocation(&array[i]);
     }
 
     friend void AutoGCRooter::trace(JSTracer *trc);
 
   private:
     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
 
@@ -702,23 +702,23 @@ class CallReceiver
         return JS::MutableHandleValue::fromMarkedLocation(&argv_[-2]);
     }
 
     Value *spAfterCall() const {
         setUsedRval();
         return argv_ - 1;
     }
 
-    void setCallee(Value calleev) const {
+    void setCallee(Value aCalleev) const {
         clearUsedRval();
-        argv_[-2] = calleev;
+        argv_[-2] = aCalleev;
     }
 
-    void setThis(Value thisv) const {
-        argv_[-1] = thisv;
+    void setThis(Value aThisv) const {
+        argv_[-1] = aThisv;
     }
 };
 
 JS_ALWAYS_INLINE CallReceiver
 CallReceiverFromArgv(Value *argv)
 {
     CallReceiver receiver;
     receiver.clearUsedRval();
@@ -1504,19 +1504,19 @@ JSVAL_IS_UNIVERSAL(jsval v)
     return !JSVAL_IS_GCTHING(v);
 }
 
 namespace JS {
 
 class AutoIdRooter : private AutoGCRooter
 {
   public:
-    explicit AutoIdRooter(JSContext *cx, jsid id = INT_TO_JSID(0)
+    explicit AutoIdRooter(JSContext *cx, jsid aId = INT_TO_JSID(0)
                           MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
-      : AutoGCRooter(cx, ID), id_(id)
+      : AutoGCRooter(cx, ID), id_(aId)
     {
         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
     }
 
     jsid id() {
         return id_;
     }
 
@@ -4991,25 +4991,25 @@ JS_AbortIfWrongThread(JSRuntime *rt);
 extern JS_PUBLIC_API(void)
 JS_ClearRuntimeThread(JSRuntime *rt);
 
 extern JS_PUBLIC_API(void)
 JS_SetRuntimeThread(JSRuntime *rt);
 
 class JSAutoSetRuntimeThread
 {
-    JSRuntime *runtime;
+    JSRuntime *runtime_;
 
   public:
-    JSAutoSetRuntimeThread(JSRuntime *runtime) : runtime(runtime) {
-        JS_SetRuntimeThread(runtime);
+    JSAutoSetRuntimeThread(JSRuntime *runtime) : runtime_(runtime) {
+        JS_SetRuntimeThread(runtime_);
     }
 
     ~JSAutoSetRuntimeThread() {
-        JS_ClearRuntimeThread(runtime);
+        JS_ClearRuntimeThread(runtime_);
     }
 };
 
 /************************************************************************/
 
 /*
  * JS_IsConstructing must be called from within a native given the
  * native's original cx and vp arguments. If JS_IsConstructing is true,
diff --git a/js/src/jsclass.h b/js/src/jsclass.h
--- a/js/src/jsclass.h
+++ b/js/src/jsclass.h
@@ -35,79 +35,79 @@ SPECIALID_TO_JSID(const SpecialId &sid);
  * Special values are encoded using SpecialId, which is layout-compatible but
  * non-interconvertible with jsid.  A SpecialId is used for JSID_VOID, which
  * does not occur in JS scripts but may be used to indicate the absence of a
  * valid identifier.  In the future, a SpecialId may also be an object used by
  * Harmony-proposed private names.
  */
 class SpecialId
 {
-    uintptr_t bits;
+    uintptr_t bits_;
 
     /* Needs access to raw bits. */
     friend JS_ALWAYS_INLINE jsid SPECIALID_TO_JSID(const SpecialId &sid);
     friend class PropertyId;
 
     static const uintptr_t TYPE_VOID = JSID_TYPE_VOID;
     static const uintptr_t TYPE_OBJECT = JSID_TYPE_OBJECT;
     static const uintptr_t TYPE_MASK = JSID_TYPE_MASK;
 
-    SpecialId(uintptr_t bits) : bits(bits) { }
+    SpecialId(uintptr_t bits) : bits_(bits) { }
 
   public:
-    SpecialId() : bits(TYPE_VOID) { }
+    SpecialId() : bits_(TYPE_VOID) { }
 
     /* Object-valued */
 
     SpecialId(JSObject &obj)
-      : bits(uintptr_t(&obj) | TYPE_OBJECT)
+      : bits_(uintptr_t(&obj) | TYPE_OBJECT)
     {
         JS_ASSERT(&obj != NULL);
         JS_ASSERT((uintptr_t(&obj) & TYPE_MASK) == 0);
     }
 
     bool isObject() const {
-        return (bits & TYPE_MASK) == TYPE_OBJECT && bits != TYPE_OBJECT;
+        return (bits_ & TYPE_MASK) == TYPE_OBJECT && bits_ != TYPE_OBJECT;
     }
 
     JSObject *toObject() const {
         JS_ASSERT(isObject());
-        return reinterpret_cast<JSObject *>(bits & ~TYPE_MASK);
+        return reinterpret_cast<JSObject *>(bits_ & ~TYPE_MASK);
     }
 
     /* Empty */
 
     static SpecialId empty() {
         SpecialId sid(TYPE_OBJECT);
         JS_ASSERT(sid.isEmpty());
         return sid;
     }
 
     bool isEmpty() const {
-        return bits == TYPE_OBJECT;
+        return bits_ == TYPE_OBJECT;
     }
 
     /* Void */
 
     static SpecialId voidId() {
         SpecialId sid(TYPE_VOID);
         JS_ASSERT(sid.isVoid());
         return sid;
     }
 
     bool isVoid() const {
-        return bits == TYPE_VOID;
+        return bits_ == TYPE_VOID;
     }
 };
 
 static JS_ALWAYS_INLINE jsid
 SPECIALID_TO_JSID(const SpecialId &sid)
 {
     jsid id;
-    JSID_BITS(id) = sid.bits;
+    JSID_BITS(id) = sid.bits_;
     JS_ASSERT_IF(sid.isObject(), JSID_IS_OBJECT(id) && JSID_TO_OBJECT(id) == sid.toObject());
     JS_ASSERT_IF(sid.isVoid(), JSID_IS_VOID(id));
     JS_ASSERT_IF(sid.isEmpty(), JSID_IS_EMPTY(id));
     return id;
 }
 
 static JS_ALWAYS_INLINE bool
 JSID_IS_SPECIAL(jsid id)
diff --git a/js/src/jscntxt.h b/js/src/jscntxt.h
--- a/js/src/jscntxt.h
+++ b/js/src/jscntxt.h
@@ -2237,26 +2237,26 @@ class RuntimeAllocPolicy
     void reportAllocOverflow() const {}
 };
 
 /*
  * FIXME bug 647103 - replace these *AllocPolicy names.
  */
 class ContextAllocPolicy
 {
-    JSContext *const cx;
+    JSContext *const cx_;
 
   public:
-    ContextAllocPolicy(JSContext *cx) : cx(cx) {}
-    JSContext *context() const { return cx; }
-    void *malloc_(size_t bytes) { return cx->malloc_(bytes); }
-    void *calloc_(size_t bytes) { return cx->calloc_(bytes); }
-    void *realloc_(void *p, size_t oldBytes, size_t bytes) { return cx->realloc_(p, oldBytes, bytes); }
+    ContextAllocPolicy(JSContext *cx) : cx_(cx) {}
+    JSContext *context() const { return cx_; }
+    void *malloc_(size_t bytes) { return cx_->malloc_(bytes); }
+    void *calloc_(size_t bytes) { return cx_->calloc_(bytes); }
+    void *realloc_(void *p, size_t oldBytes, size_t bytes) { return cx_->realloc_(p, oldBytes, bytes); }
     void free_(void *p) { js_free(p); }
-    void reportAllocOverflow() const { js_ReportAllocationOverflow(cx); }
+    void reportAllocOverflow() const { js_ReportAllocationOverflow(cx_); }
 };
 
 JSBool intrinsic_ThrowError(JSContext *cx, unsigned argc, Value *vp);
 JSBool intrinsic_NewDenseArray(JSContext *cx, unsigned argc, Value *vp);
 JSBool intrinsic_UnsafeSetElement(JSContext *cx, unsigned argc, Value *vp);
 JSBool intrinsic_ForceSequential(JSContext *cx, unsigned argc, Value *vp);
 JSBool intrinsic_NewParallelArray(JSContext *cx, unsigned argc, Value *vp);
 
diff --git a/js/src/jsfriendapi.h b/js/src/jsfriendapi.h
--- a/js/src/jsfriendapi.h
+++ b/js/src/jsfriendapi.h
@@ -627,50 +627,50 @@ class ProfileEntry
      * If the size modification were somehow reordered before the stores, then
      * if a sample were taken it would be examining bogus information.
      *
      * A ProfileEntry represents both a C++ profile entry and a JS one. Both use
      * the string as a description, but JS uses the sp as NULL to indicate that
      * it is a JS entry. The script_ is then only ever examined for a JS entry,
      * and the idx is used by both, but with different meanings.
      */
-    const char * volatile string; // Descriptive string of this entry
-    void * volatile sp;           // Relevant stack pointer for the entry
-    JSScript * volatile script_;  // if js(), non-null script which is running
-    int32_t volatile idx;         // if js(), idx of pc, otherwise line number
+    const char * volatile string_; // Descriptive string of this entry
+    void * volatile sp_;           // Relevant stack pointer for the entry
+    JSScript * volatile script_;   // if js(), non-null script which is running
+    int32_t volatile idx;          // if js(), idx of pc, otherwise line number
 
   public:
     /*
      * All of these methods are marked with the 'volatile' keyword because SPS's
      * representation of the stack is stored such that all ProfileEntry
      * instances are volatile. These methods would not be available unless they
      * were marked as volatile as well
      */
 
     bool js() volatile {
-        JS_ASSERT_IF(sp == NULL, script_ != NULL);
-        return sp == NULL;
+        JS_ASSERT_IF(sp_ == NULL, script_ != NULL);
+        return sp_ == NULL;
     }
 
     uint32_t line() volatile { JS_ASSERT(!js()); return idx; }
     JSScript *script() volatile { JS_ASSERT(js()); return script_; }
-    void *stackAddress() volatile { return sp; }
-    const char *label() volatile { return string; }
+    void *stackAddress() volatile { return sp_; }
+    const char *label() volatile { return string_; }
 
     void setLine(uint32_t line) volatile { JS_ASSERT(!js()); idx = line; }
-    void setLabel(const char *string) volatile { this->string = string; }
-    void setStackAddress(void *sp) volatile { this->sp = sp; }
+    void setLabel(const char *string) volatile { string_ = string; }
+    void setStackAddress(void *sp) volatile { sp_ = sp; }
     void setScript(JSScript *script) volatile { script_ = script; }
 
     /* we can't know the layout of JSScript, so look in vm/SPSProfiler.cpp */
     JS_FRIEND_API(jsbytecode *) pc() volatile;
     JS_FRIEND_API(void) setPC(jsbytecode *pc) volatile;
 
-    static size_t offsetOfString() { return offsetof(ProfileEntry, string); }
-    static size_t offsetOfStackAddress() { return offsetof(ProfileEntry, sp); }
+    static size_t offsetOfString() { return offsetof(ProfileEntry, string_); }
+    static size_t offsetOfStackAddress() { return offsetof(ProfileEntry, sp_); }
     static size_t offsetOfPCIdx() { return offsetof(ProfileEntry, idx); }
     static size_t offsetOfScript() { return offsetof(ProfileEntry, script_); }
 
     /*
      * The index used in the entry can either be a line number or the offset of
      * a pc into a script's code. To signify a NULL pc, use a -1 index. This is
      * checked against in pc() and setPC() to set/get the right pc.
      */
diff --git a/js/src/jsproxy.h b/js/src/jsproxy.h
--- a/js/src/jsproxy.h
+++ b/js/src/jsproxy.h
@@ -48,17 +48,17 @@ class JS_FRIEND_API(Wrapper);
  * the derived traps in terms of the fundamental ones. This allows consumers of
  * this class to define any custom behavior they want.
  */
 class JS_FRIEND_API(BaseProxyHandler) {
     void *mFamily;
     bool mHasPrototype;
   protected:
     // Subclasses may set this in their constructor.
-    void setHasPrototype(bool hasPrototype) { mHasPrototype = hasPrototype; }
+    void setHasPrototype(bool aHasPrototype) { mHasPrototype = aHasPrototype; }
 
   public:
     explicit BaseProxyHandler(void *family);
     virtual ~BaseProxyHandler();
 
     bool hasPrototype() {
         return mHasPrototype;
     }
diff --git a/js/src/jsutil.h b/js/src/jsutil.h
--- a/js/src/jsutil.h
+++ b/js/src/jsutil.h
@@ -49,19 +49,19 @@ struct AlignmentTestStruct
   (sizeof(js::AlignmentTestStruct<t_>) - sizeof(t_))
 
 template <class T>
 class AlignedPtrAndFlag
 {
     uintptr_t bits;
 
   public:
-    AlignedPtrAndFlag(T *t, bool flag) {
+    AlignedPtrAndFlag(T *t, bool aFlag) {
         JS_ASSERT((uintptr_t(t) & 1) == 0);
-        bits = uintptr_t(t) | uintptr_t(flag);
+        bits = uintptr_t(t) | uintptr_t(aFlag);
     }
 
     T *ptr() const {
         return (T *)(bits & ~uintptr_t(1));
     }
 
     bool flag() const {
         return (bits & 1) != 0;
@@ -75,19 +75,19 @@ class AlignedPtrAndFlag
     void setFlag() {
         bits |= 1;
     }
 
     void unsetFlag() {
         bits &= ~uintptr_t(1);
     }
 
-    void set(T *t, bool flag) {
+    void set(T *t, bool aFlag) {
         JS_ASSERT((uintptr_t(t) & 1) == 0);
-        bits = uintptr_t(t) | flag;
+        bits = uintptr_t(t) | aFlag;
     }
 };
 
 template <class T>
 static inline void
 Reverse(T *beg, T *end)
 {
     while (beg != end) {
@@ -157,27 +157,27 @@ ImplicitCast(U &u)
 }
 
 template<typename T>
 class AutoScopedAssign
 {
   public:
     AutoScopedAssign(T *addr, const T &value
                      MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
-        : addr(addr), old(*addr)
+        : addr_(addr), old(*addr_)
     {
         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
-        *addr = value;
+        *addr_ = value;
     }
 
-    ~AutoScopedAssign() { *addr = old; }
+    ~AutoScopedAssign() { *addr_ = old; }
 
   private:
     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
-    T *addr;
+    T *addr_;
     T old;
 };
 
 template <class T>
 JS_ALWAYS_INLINE static void
 PodZero(T *t)
 {
     memset(t, 0, sizeof(T));
