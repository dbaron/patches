From: L. David Baron <dbaron@dbaron.org>

Bug 879255:  Refactor fix for bug 613888, step 2:  consolidate oldPT variable.

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -689,23 +689,25 @@ nsTransitionManager::ConsiderStartingTra
     // Check that we can interpolate between these values
     // (If this is ever a performance problem, we could add a
     // CanInterpolate method, but it seems fine for now.)
     nsStyleAnimation::Interpolate(aProperty, pt.mStartValue, pt.mEndValue,
                                   0.5, dummyValue);
 
   bool haveCurrentTransition = false;
   uint32_t currentIndex = nsTArray<ElementPropertyTransition>::NoIndex;
+  const ElementPropertyTransition *oldPT = nullptr;
   if (aElementTransitions) {
     nsTArray<ElementPropertyTransition> &pts =
       aElementTransitions->mPropertyTransitions;
     for (uint32_t i = 0, i_end = pts.Length(); i < i_end; ++i) {
       if (pts[i].mProperty == aProperty) {
         haveCurrentTransition = true;
         currentIndex = i;
+        oldPT = &aElementTransitions->mPropertyTransitions[currentIndex];
         break;
       }
     }
   }
 
   nsPresContext *presContext = aNewStyleContext->PresContext();
 
   if (!shouldAnimate) {
@@ -746,36 +748,33 @@ nsTransitionManager::ConsiderStartingTra
     duration = 0.0;
   }
   pt.mStartForReversingTest = pt.mStartValue;
   pt.mReversePortion = 1.0;
 
   // We need to check two things if we have a currently running
   // transition for this property.
   if (haveCurrentTransition) {
-    const ElementPropertyTransition &oldPT =
-      aElementTransitions->mPropertyTransitions[currentIndex];
-
-    if (oldPT.mEndValue == pt.mEndValue) {
+    if (oldPT->mEndValue == pt.mEndValue) {
       // If we got a style change that changed the value to the endpoint
       // of the currently running transition, we don't want to interrupt
       // its timing function.
       // WalkTransitionRule already called RestyleForAnimation.
       return;
     }
 
     // If the new transition reverses the old one, we'll need to handle
     // the timing differently.
-    if (!oldPT.IsRemovedSentinel() &&
-        oldPT.mStartForReversingTest == pt.mEndValue) {
+    if (!oldPT->IsRemovedSentinel() &&
+        oldPT->mStartForReversingTest == pt.mEndValue) {
       // Compute the appropriate negative transition-delay such that right
       // now we'd end up at the current position.
       double valuePortion =
-        oldPT.ValuePortionFor(mostRecentRefresh) * oldPT.mReversePortion +
-        (1.0 - oldPT.mReversePortion);
+        oldPT->ValuePortionFor(mostRecentRefresh) * oldPT->mReversePortion +
+        (1.0 - oldPT->mReversePortion);
       // A timing function with negative y1 (or y2!) might make
       // valuePortion negative.  In this case, we still want to apply our
       // reversing logic based on relative distances, not make duration
       // negative.
       if (valuePortion < 0.0)
         valuePortion = -valuePortion;
       // A timing function with y2 (or y1!) greater than one might
       // advance past its terminal value.  It's probably a good idea to
@@ -788,17 +787,17 @@ nsTransitionManager::ConsiderStartingTra
       // Negative delays are essentially part of the transition
       // function, so reduce them along with the duration, but don't
       // reduce positive delays.
       if (delay < 0.0f)
         delay *= valuePortion;
 
       duration *= valuePortion;
 
-      pt.mStartForReversingTest = oldPT.mEndValue;
+      pt.mStartForReversingTest = oldPT->mEndValue;
       pt.mReversePortion = valuePortion;
     }
   }
 
   pt.mProperty = aProperty;
   pt.mStartTime = mostRecentRefresh + TimeDuration::FromMilliseconds(delay);
   pt.mDuration = TimeDuration::FromMilliseconds(duration);
   pt.mTimingFunction.Init(tf);
