From: Robert O'Callahan <roc@ocallahan.org>

Bug 594774. Detect DOM changes during painting, and abort painting ASAP when that happens. r=dbaron  a2.0=blocking2.0:beta7

diff --git a/layout/base/FrameLayerBuilder.cpp b/layout/base/FrameLayerBuilder.cpp
--- a/layout/base/FrameLayerBuilder.cpp
+++ b/layout/base/FrameLayerBuilder.cpp
@@ -39,16 +39,17 @@
 
 #include "nsDisplayList.h"
 #include "nsPresContext.h"
 #include "nsLayoutUtils.h"
 #include "Layers.h"
 #include "BasicLayers.h"
 #include "nsSubDocumentFrame.h"
 #include "nsCSSRendering.h"
+#include "nsCSSFrameConstructor.h"
 
 #ifdef DEBUG
 #include <stdio.h>
 #endif
 
 using namespace mozilla::layers;
 
 namespace mozilla {
@@ -355,16 +356,25 @@ PRUint8 gColorLayerUserData;
  * The address of gLayerManagerUserData is used as the user
  * data key for retained LayerManagers managed by FrameLayerBuilder.
  * The user data is a LayerManagerData.
  */
 PRUint8 gLayerManagerUserData;
 
 } // anonymous namespace
 
+void
+FrameLayerBuilder::Init(nsDisplayListBuilder* aBuilder)
+{
+  mRootPresContext = aBuilder->ReferenceFrame()->PresContext()->GetRootPresContext();
+  if (mRootPresContext) {
+    mInitialDOMGeneration = mRootPresContext->GetDOMGeneration();
+  }
+}
+
 PRBool
 FrameLayerBuilder::DisplayItemDataEntry::HasContainerLayer()
 {
   for (PRUint32 i = 0; i < mData.Length(); ++i) {
     if (mData[i].mLayer->GetType() == Layer::TYPE_CONTAINER)
       return PR_TRUE;
   }
   return PR_FALSE;
@@ -1535,16 +1545,20 @@ FrameLayerBuilder::HasDedicatedLayer(nsI
 FrameLayerBuilder::DrawThebesLayer(ThebesLayer* aLayer,
                                    gfxContext* aContext,
                                    const nsIntRegion& aRegionToDraw,
                                    const nsIntRegion& aRegionToInvalidate,
                                    void* aCallbackData)
 {
   nsDisplayListBuilder* builder = static_cast<nsDisplayListBuilder*>
     (aCallbackData);
+
+  if (builder->LayerBuilder()->CheckDOMModified())
+    return;
+
   nsTArray<ClippedDisplayItem> items;
   nsIFrame* containerLayerFrame;
   {
     ThebesLayerItemsEntry* entry =
       builder->LayerBuilder()->mThebesLayerItems.GetEntry(aLayer);
     NS_ASSERTION(entry, "We shouldn't be drawing into a layer with no items!");
     items.SwapElements(entry->mItems);
     containerLayerFrame = entry->mContainerLayerFrame;
@@ -1664,23 +1678,44 @@ FrameLayerBuilder::DrawThebesLayer(Thebe
     if (cdi->mTempLayerManager) {
       // This item has an inactive layer. Render it to the ThebesLayer
       // using the temporary BasicLayerManager.
       cdi->mTempLayerManager->BeginTransactionWithTarget(aContext);
       cdi->mTempLayerManager->EndTransaction(DrawThebesLayer, builder);
     } else {
       cdi->mItem->Paint(builder, rc);
     }
+
+    if (builder->LayerBuilder()->CheckDOMModified())
+      break;
   }
 
   if (setClipRect) {
     aContext->Restore();
   }
 }
 
+PRBool
+FrameLayerBuilder::CheckDOMModified()
+{
+  if (mRootPresContext &&
+      mInitialDOMGeneration == mRootPresContext->GetDOMGeneration())
+    return PR_FALSE;
+  if (mDetectedDOMModification) {
+    // Don't spam the console with extra warnings
+    return PR_TRUE;
+  }
+  mDetectedDOMModification = PR_TRUE;
+  // Painting is not going to complete properly. There's not much
+  // we can do here though. Invalidating the window to get another repaint
+  // is likely to lead to an infinite repaint loop.
+  NS_WARNING("Detected DOM modification during paint, bailing out!");
+  return PR_TRUE;
+}
+
 #ifdef DEBUG
 void
 FrameLayerBuilder::DumpRetainedLayerTree()
 {
   if (mRetainingManager) {
     mRetainingManager->Dump(stderr);
   }
 }
diff --git a/layout/base/FrameLayerBuilder.h b/layout/base/FrameLayerBuilder.h
--- a/layout/base/FrameLayerBuilder.h
+++ b/layout/base/FrameLayerBuilder.h
@@ -44,16 +44,17 @@
 #include "nsRegion.h"
 #include "nsIFrame.h"
 #include "Layers.h"
 
 class nsDisplayListBuilder;
 class nsDisplayList;
 class nsDisplayItem;
 class gfxContext;
+class nsRootPresContext;
 
 namespace mozilla {
 
 enum LayerState {
   LAYER_NONE,
   LAYER_INACTIVE,
   LAYER_ACTIVE
 };
@@ -92,23 +93,26 @@ class FrameLayerBuilder {
 public:
   typedef layers::ContainerLayer ContainerLayer; 
   typedef layers::Layer Layer; 
   typedef layers::ThebesLayer ThebesLayer;
   typedef layers::LayerManager LayerManager;
 
   FrameLayerBuilder() :
     mRetainingManager(nsnull),
+    mDetectedDOMModification(PR_FALSE),
     mInvalidateAllThebesContent(PR_FALSE),
     mInvalidateAllLayers(PR_FALSE)
   {
     mNewDisplayItemData.Init();
     mThebesLayerItems.Init();
   }
 
+  void Init(nsDisplayListBuilder* aBuilder);
+
   /**
    * Call this to notify that we are about to start a transaction on the
    * retained layer manager aManager.
    */
   void WillBeginRetainedLayerTransaction(LayerManager* aManager);
 
   /**
    * Call this just before we end a transaction on aManager. If aManager
@@ -407,31 +411,51 @@ protected:
   void RemoveThebesItemsForLayerSubtree(Layer* aLayer);
 
   static PLDHashOperator UpdateDisplayItemDataForFrame(nsPtrHashKey<nsIFrame>* aEntry,
                                                        void* aUserArg);
   static PLDHashOperator StoreNewDisplayItemData(DisplayItemDataEntry* aEntry,
                                                  void* aUserArg);
 
   /**
+   * Returns true if the DOM has been modified since we started painting,
+   * in which case we should bail out and not paint anymore. This should
+   * never happen, but plugins can trigger it in some cases.
+   */
+  PRBool CheckDOMModified();
+
+  /**
    * The layer manager belonging to the widget that is being retained
    * across paints.
    */
   LayerManager*                       mRetainingManager;
   /**
+   * The root prescontext for the display list builder reference frame
+   */
+  nsRootPresContext*                  mRootPresContext;
+  /**
    * A map from frames to a list of (display item key, layer) pairs that
    * describes what layers various parts of the frame are assigned to.
    */
   nsTHashtable<DisplayItemDataEntry>  mNewDisplayItemData;
   /**
    * A map from ThebesLayers to the list of display items (plus
    * clipping data) to be rendered in the layer.
    */
   nsTHashtable<ThebesLayerItemsEntry> mThebesLayerItems;
   /**
+   * Saved generation counter so we can detect DOM changes.
+   */
+  PRUint32                            mInitialDOMGeneration;
+  /**
+   * Set to true if we have detected and reported DOM modification during
+   * the current paint.
+   */
+  PRPackedBool                        mDetectedDOMModification;
+  /**
    * Indicates that the contents of all ThebesLayers should be rerendered
    * during this paint.
    */
   PRPackedBool                        mInvalidateAllThebesContent;
   /**
    * Indicates that the entire layer tree should be rerendered
    * during this paint.
    */
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -8183,16 +8183,22 @@ nsCSSFrameConstructor::AttributeChanged(
   PostRestyleEvent(aElement, rshint, hint);
 }
 
 void
 nsCSSFrameConstructor::BeginUpdate() {
   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
                "Someone forgot a script blocker");
 
+  nsRootPresContext* rootPresContext =
+    mPresShell->GetPresContext()->GetRootPresContext();
+  if (rootPresContext) {
+    rootPresContext->IncrementDOMGeneration();
+  }
+
   ++mUpdateCount;
 }
 
 void
 nsCSSFrameConstructor::EndUpdate()
 {
   if (mUpdateCount == 1) {
     // This is the end of our last update.  Before we decrement
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -91,16 +91,18 @@ nsDisplayListBuilder::nsDisplayListBuild
   if (pc->IsRenderingOnlySelection()) {
     nsCOMPtr<nsISelectionController> selcon(do_QueryInterface(shell));
     if (selcon) {
       selcon->GetSelection(nsISelectionController::SELECTION_NORMAL,
                            getter_AddRefs(mBoundingSelection));
     }
   }
 
+  LayerBuilder()->Init(this);
+
   PR_STATIC_ASSERT(nsDisplayItem::TYPE_MAX < (1 << nsDisplayItem::TYPE_BITS));
 }
 
 static void MarkFrameForDisplay(nsIFrame* aFrame, nsIFrame* aStopAtFrame) {
   nsFrameManager* frameManager = aFrame->PresContext()->PresShell()->FrameManager();
 
   for (nsIFrame* f = aFrame; f;
        f = nsLayoutUtils::GetParentOrPlaceholderFor(frameManager, f)) {
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -2418,16 +2418,17 @@ nsPresContext::IsRootContentDocument()
   nsIFrame* f = static_cast<nsIFrame*>(view->GetClientData());
   return (f && f->PresContext()->IsChrome());
 }
 
 nsRootPresContext::nsRootPresContext(nsIDocument* aDocument,
                                      nsPresContextType aType)
   : nsPresContext(aDocument, aType),
     mUpdatePluginGeometryForFrame(nsnull),
+    mDOMGeneration(0),
     mNeedsToUpdatePluginGeometry(PR_FALSE)
 {
   mRegisteredPlugins.Init();
 }
 
 nsRootPresContext::~nsRootPresContext()
 {
   NS_ASSERTION(mRegisteredPlugins.Count() == 0,
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -1262,22 +1262,35 @@ public:
   void RequestUpdatePluginGeometry(nsIFrame* aFrame);
 
   /**
    * Call this when a frame is being destroyed and
    * mContainsUpdatePluginGeometryFrame is set in the frame's prescontext.
    */
   void RootForgetUpdatePluginGeometryFrame(nsIFrame* aFrame);
 
+  /**
+   * Increment DOM-modification generation counter to indicate that
+   * the DOM has changed in a way that might lead to style changes/
+   * reflows/frame creation and destruction.
+   */
+  void IncrementDOMGeneration() { mDOMGeneration++; }
+
+  /**
+   * Get the current DOM generation counter.
+   */
+  PRUint32 GetDOMGeneration() { return mDOMGeneration; }
+
 private:
   nsTHashtable<nsPtrHashKey<nsObjectFrame> > mRegisteredPlugins;
   // if mNeedsToUpdatePluginGeometry is set, then this is the frame to
   // use as the root of the subtree to search for plugin updates, or
   // null to use the root frame of this prescontext
   nsIFrame* mUpdatePluginGeometryForFrame;
+  PRUint32 mDOMGeneration;
   PRPackedBool mNeedsToUpdatePluginGeometry;
 };
 
 inline void
 nsPresContext::ForgetUpdatePluginGeometryFrame(nsIFrame* aFrame)
 {
   if (mContainsUpdatePluginGeometryFrame) {
     nsRootPresContext* rootPC = GetRootPresContext();
