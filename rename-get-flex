From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::GetFlex to GetXULFlex.  r=dholbert

Written purely with sed, over .h and .cpp files in layout/.

MozReview-Commit-ID: DNL01eSXB73

diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -8780,23 +8780,23 @@ nsFrame::GetXULMaxSize(nsBoxLayoutState&
 
   size = nsBox::GetXULMaxSize(aState);
   metrics->mMaxSize = size;
 
   return size;
 }
 
 nscoord
-nsFrame::GetFlex()
+nsFrame::GetXULFlex()
 {
   nsBoxLayoutMetrics *metrics = BoxMetrics();
   if (!DoesNeedRecalc(metrics->mFlex))
      return metrics->mFlex;
 
-  metrics->mFlex = nsBox::GetFlex();
+  metrics->mFlex = nsBox::GetXULFlex();
 
   return metrics->mFlex;
 }
 
 nscoord
 nsFrame::GetBoxAscent(nsBoxLayoutState& aState)
 {
   nsBoxLayoutMetrics *metrics = BoxMetrics();
diff --git a/layout/generic/nsFrame.h b/layout/generic/nsFrame.h
--- a/layout/generic/nsFrame.h
+++ b/layout/generic/nsFrame.h
@@ -406,17 +406,17 @@ public:
   // Helper for GetContentAndOffsetsFromPoint; calculation of content offsets
   // in this function assumes there is no child frame that can be targeted.
   virtual ContentOffsets CalcContentOffsetsFromFramePoint(nsPoint aPoint);
 
   // Box layout methods
   virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nscoord GetFlex() override;
+  virtual nscoord GetXULFlex() override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
 
   // We compute and store the HTML content's overflow area. So don't
   // try to compute it in the box code.
   virtual bool ComputesOwnOverflowArea() override { return true; }
 
   //--------------------------------------------------
   // Additional methods
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2893,17 +2893,17 @@ public:
    * This returns the minimum size for the scroll area if this frame is
    * being scrolled. Usually it's (0,0).
    */
   virtual nsSize GetXULMinSizeForScrollArea(nsBoxLayoutState& aBoxLayoutState) = 0;
 
   // Implemented in nsBox, used in nsBoxFrame
   uint32_t GetXULOrdinal();
 
-  virtual nscoord GetFlex() = 0;
+  virtual nscoord GetXULFlex() = 0;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) = 0;
   virtual bool IsCollapsed() = 0;
   // This does not alter the overflow area. If the caller is changing
   // the box size, the caller is responsible for updating the overflow
   // area. It's enough to just call Layout or SyncLayout on the
   // box. You can pass true to aRemoveOverflowArea as a
   // convenience.
   virtual void SetBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
diff --git a/layout/xul/grid/nsGrid.cpp b/layout/xul/grid/nsGrid.cpp
--- a/layout/xul/grid/nsGrid.cpp
+++ b/layout/xul/grid/nsGrid.cpp
@@ -1100,31 +1100,31 @@ nsGrid::GetRowFlex(int32_t aIndex, bool 
       parent = GetScrollBox(parent);
       parentsParent = nsBox::GetParentBox(parent);
 
       // if our parents parent is not a grid
       // the get its flex. If its 0 then we are
       // not flexible.
       if (parentsParent) {
         if (!IsGrid(parentsParent)) {
-          nscoord flex = parent->GetFlex();
+          nscoord flex = parent->GetXULFlex();
           nsIFrame::AddCSSFlex(parent, flex);
           if (flex == 0) {
             row->mFlex = 0;
             return row->mFlex;
           }
         } else 
           break;
       }
 
       parent = parentsParent;
     }
     
     // get the row flex.
-    row->mFlex = box->GetFlex();
+    row->mFlex = box->GetXULFlex();
     nsIFrame::AddCSSFlex(box, row->mFlex);
   }
 
   return row->mFlex;
 }
 
 void
 nsGrid::SetLargestSize(nsSize& aSize, nscoord aHeight, bool aIsHorizontal)
diff --git a/layout/xul/grid/nsGridRowGroupFrame.cpp b/layout/xul/grid/nsGridRowGroupFrame.cpp
--- a/layout/xul/grid/nsGridRowGroupFrame.cpp
+++ b/layout/xul/grid/nsGridRowGroupFrame.cpp
@@ -29,34 +29,34 @@ NS_NewGridRowGroupFrame(nsIPresShell* aP
 NS_IMPL_FRAMEARENA_HELPERS(nsGridRowGroupFrame)
 
 
 /**
  * This is redefined because row groups have a funny property. If they are flexible
  * then their flex must be equal to the sum of their children's flexes.
  */
 nscoord
-nsGridRowGroupFrame::GetFlex()
+nsGridRowGroupFrame::GetXULFlex()
 {
   // if we are flexible out flexibility is determined by our columns.
   // so first get the our flex. If not 0 then our flex is the sum of
   // our columns flexes.
 
   if (!DoesNeedRecalc(mFlex))
      return mFlex;
 
-  if (nsBoxFrame::GetFlex() == 0)
+  if (nsBoxFrame::GetXULFlex() == 0)
     return 0;
 
   // ok we are flexible add up our children
   nscoord totalFlex = 0;
   nsIFrame* child = nsBox::GetChildBox(this);
   while (child)
   {
-    totalFlex += child->GetFlex();
+    totalFlex += child->GetXULFlex();
     child = GetNextBox(child);
   }
 
   mFlex = totalFlex;
 
   return totalFlex;
 }
 
diff --git a/layout/xul/grid/nsGridRowGroupFrame.h b/layout/xul/grid/nsGridRowGroupFrame.h
--- a/layout/xul/grid/nsGridRowGroupFrame.h
+++ b/layout/xul/grid/nsGridRowGroupFrame.h
@@ -34,16 +34,16 @@ public:
       return MakeFrameName(NS_LITERAL_STRING("nsGridRowGroup"), aResult);
   }
 #endif
 
   nsGridRowGroupFrame(nsStyleContext* aContext,
                       nsBoxLayout* aLayoutManager):
     nsBoxFrame(aContext, false, aLayoutManager) {}
 
-  virtual nscoord GetFlex() override;
+  virtual nscoord GetXULFlex() override;
 
 }; // class nsGridRowGroupFrame
 
 
 
 #endif
 
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -447,17 +447,17 @@ nsBox::GetXULMaxSize(nsBoxLayoutState& a
 
   AddBorderAndPadding(maxSize);
   bool widthSet, heightSet;
   nsIFrame::AddCSSMaxSize(this, maxSize, widthSet, heightSet);
   return maxSize;
 }
 
 nscoord
-nsBox::GetFlex()
+nsBox::GetXULFlex()
 {
   nscoord flex = 0;
 
   nsIFrame::AddCSSFlex(this, flex);
 
   return flex;
 }
 
diff --git a/layout/xul/nsBox.h b/layout/xul/nsBox.h
--- a/layout/xul/nsBox.h
+++ b/layout/xul/nsBox.h
@@ -17,17 +17,17 @@ public:
 
   friend class nsIFrame;
 
   static void Shutdown();
 
   virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nscoord GetFlex() override;
+  virtual nscoord GetXULFlex() override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual nsSize GetXULMinSizeForScrollArea(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual bool IsCollapsed() override;
 
   virtual void SetBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
                          bool aRemoveOverflowAreas = false) override;
diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -882,22 +882,22 @@ nsBoxFrame::GetXULMaxSize(nsBoxLayoutSta
   }
 
   mMaxSize = size;
 
   return size;
 }
 
 nscoord
-nsBoxFrame::GetFlex()
+nsBoxFrame::GetXULFlex()
 {
   if (!DoesNeedRecalc(mFlex))
      return mFlex;
 
-  mFlex = nsBox::GetFlex();
+  mFlex = nsBox::GetXULFlex();
 
   return mFlex;
 }
 
 /**
  * If subclassing please subclass this method not layout. 
  * layout will call this method.
  */
@@ -1494,17 +1494,17 @@ nsBoxFrame::PaintXULDebugOverlay(DrawTar
         spacerSize = debugBorder.top - onePixel*4;
     } else {
         cr.x = inner.x;
         x = cr.y;
         y = cr.x + onePixel;
         spacerSize = debugBorder.left - onePixel*4;
     }
 
-    nscoord flex = kid->GetFlex();
+    nscoord flex = kid->GetXULFlex();
 
     if (!kid->IsCollapsed()) {
       if (isHorizontal) 
           borderSize = cr.width;
       else 
           borderSize = cr.height;
 
       DrawSpacer(GetPresContext(), aDrawTarget, isHorizontal, flex, x, y, borderSize, spacerSize);
@@ -1784,17 +1784,17 @@ nsBoxFrame::DisplayDebugInfoFor(nsIFrame
                     nsIFrame::AddCSSPrefSize(child, prefSizeCSS, widthSet, heightSet);
                     nsIFrame::AddCSSMinSize (state, child, minSizeCSS, widthSet, heightSet);
                     nsIFrame::AddCSSMaxSize (child, maxSizeCSS, widthSet, heightSet);
                     nsIFrame::AddCSSFlex    (child, flexCSS);
 
                     nsSize prefSize = child->GetXULPrefSize(state);
                     nsSize minSize = child->GetXULMinSize(state);
                     nsSize maxSize = child->GetXULMaxSize(state);
-                    nscoord flexSize = child->GetFlex();
+                    nscoord flexSize = child->GetXULFlex();
                     nscoord ascentSize = child->GetBoxAscent(state);
 
                     char min[100];
                     char pref[100];
                     char max[100];
                     char calc[100];
                     char flex[100];
                     char ascent[100];
diff --git a/layout/xul/nsBoxFrame.h b/layout/xul/nsBoxFrame.h
--- a/layout/xul/nsBoxFrame.h
+++ b/layout/xul/nsBoxFrame.h
@@ -59,17 +59,17 @@ public:
   virtual void SetLayoutManager(nsBoxLayout* aLayout) override { mLayoutManager = aLayout; }
   virtual nsBoxLayout* GetLayoutManager() override { return mLayoutManager; }
 
   virtual nsresult RelayoutChildAtOrdinal(nsIFrame* aChild) override;
 
   virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nscoord GetFlex() override;
+  virtual nscoord GetXULFlex() override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
 #ifdef DEBUG_LAYOUT
   virtual nsresult SetDebug(nsBoxLayoutState& aBoxLayoutState, bool aDebug) override;
   virtual nsresult GetDebug(bool& aDebug) override;
 #endif
   virtual Valignment GetVAlign() const override { return mValign; }
   virtual Halignment GetHAlign() const override { return mHalign; }
   NS_IMETHOD DoLayout(nsBoxLayoutState& aBoxLayoutState) override;
diff --git a/layout/xul/nsLeafBoxFrame.cpp b/layout/xul/nsLeafBoxFrame.cpp
--- a/layout/xul/nsLeafBoxFrame.cpp
+++ b/layout/xul/nsLeafBoxFrame.cpp
@@ -360,19 +360,19 @@ nsLeafBoxFrame::GetXULMinSize(nsBoxLayou
 
 /* virtual */ nsSize
 nsLeafBoxFrame::GetXULMaxSize(nsBoxLayoutState& aState)
 {
     return nsBox::GetXULMaxSize(aState);
 }
 
 /* virtual */ nscoord
-nsLeafBoxFrame::GetFlex()
+nsLeafBoxFrame::GetXULFlex()
 {
-    return nsBox::GetFlex();
+    return nsBox::GetXULFlex();
 }
 
 /* virtual */ nscoord
 nsLeafBoxFrame::GetBoxAscent(nsBoxLayoutState& aState)
 {
     return nsBox::GetBoxAscent(aState);
 }
 
diff --git a/layout/xul/nsLeafBoxFrame.h b/layout/xul/nsLeafBoxFrame.h
--- a/layout/xul/nsLeafBoxFrame.h
+++ b/layout/xul/nsLeafBoxFrame.h
@@ -14,17 +14,17 @@ class nsLeafBoxFrame : public nsLeafFram
 public:
   NS_DECL_FRAMEARENA_HELPERS
 
   friend nsIFrame* NS_NewLeafBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 
   virtual nsSize GetXULPrefSize(nsBoxLayoutState& aState) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aState) override;
   virtual nsSize GetXULMaxSize(nsBoxLayoutState& aState) override;
-  virtual nscoord GetFlex() override;
+  virtual nscoord GetXULFlex() override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aState) override;
 
   virtual nsIAtom* GetType() const override;
   virtual bool IsFrameOfType(uint32_t aFlags) const override
   {
     // This is bogus, but it's what we've always done.
     // Note that nsLeafFrame is also eReplacedContainsBlock.
     return nsLeafFrame::IsFrameOfType(aFlags &
diff --git a/layout/xul/nsMenuFrame.cpp b/layout/xul/nsMenuFrame.cpp
--- a/layout/xul/nsMenuFrame.cpp
+++ b/layout/xul/nsMenuFrame.cpp
@@ -1341,17 +1341,17 @@ nsMenuFrame::AppendFrames(ChildListID   
 
 bool
 nsMenuFrame::SizeToPopup(nsBoxLayoutState& aState, nsSize& aSize)
 {
   if (!IsCollapsed()) {
     bool widthSet, heightSet;
     nsSize tmpSize(-1, 0);
     nsIFrame::AddCSSPrefSize(this, tmpSize, widthSet, heightSet);
-    if (!widthSet && GetFlex() == 0) {
+    if (!widthSet && GetXULFlex() == 0) {
       nsMenuPopupFrame* popupFrame = GetPopup();
       if (!popupFrame)
         return false;
       tmpSize = popupFrame->GetXULPrefSize(aState);
 
       // Produce a size such that:
       //  (1) the menu and its popup can be the same width
       //  (2) there's enough room in the menu for the content and its
diff --git a/layout/xul/nsSliderFrame.cpp b/layout/xul/nsSliderFrame.cpp
--- a/layout/xul/nsSliderFrame.cpp
+++ b/layout/xul/nsSliderFrame.cpp
@@ -431,17 +431,17 @@ nsSliderFrame::DoLayout(nsBoxLayoutState
   int32_t pageIncrement = GetPageIncrement(scrollbar);
 
   maxPos = std::max(minPos, maxPos);
   curPos = clamped(curPos, minPos, maxPos);
 
   nscoord& availableLength = IsHorizontal() ? clientRect.width : clientRect.height;
   nscoord& thumbLength = IsHorizontal() ? thumbSize.width : thumbSize.height;
 
-  if ((pageIncrement + maxPos - minPos) > 0 && thumbBox->GetFlex() > 0) {
+  if ((pageIncrement + maxPos - minPos) > 0 && thumbBox->GetXULFlex() > 0) {
     float ratio = float(pageIncrement) / float(maxPos - minPos + pageIncrement);
     thumbLength = std::max(thumbLength, NSToCoordRound(availableLength * ratio));
   }
 
   // Round the thumb's length to device pixels.
   nsPresContext* presContext = PresContext();
   thumbLength = presContext->DevPixelsToAppUnits(
                   presContext->AppUnitsToDevPixels(thumbLength));
diff --git a/layout/xul/nsSplitterFrame.cpp b/layout/xul/nsSplitterFrame.cpp
--- a/layout/xul/nsSplitterFrame.cpp
+++ b/layout/xul/nsSplitterFrame.cpp
@@ -672,17 +672,17 @@ nsSplitterFrameInner::MouseDown(nsIDOMEv
         nsSize minSize = childBox->GetXULMinSize(state);
         nsSize maxSize = nsBox::BoundsCheckMinMax(minSize, childBox->GetXULMaxSize(state));
         prefSize = nsBox::BoundsCheck(minSize, prefSize, maxSize);
 
         mOuter->AddMargin(childBox, minSize);
         mOuter->AddMargin(childBox, prefSize);
         mOuter->AddMargin(childBox, maxSize);
 
-        nscoord flex = childBox->GetFlex();
+        nscoord flex = childBox->GetXULFlex();
 
         nsMargin margin(0,0,0,0);
         childBox->GetMargin(margin);
         nsRect r(childBox->GetRect());
         r.Inflate(margin);
 
         // We need to check for hidden attribute too, since treecols with
         // the hidden="true" attribute are not really hidden, just collapsed
diff --git a/layout/xul/nsSprocketLayout.cpp b/layout/xul/nsSprocketLayout.cpp
--- a/layout/xul/nsSprocketLayout.cpp
+++ b/layout/xul/nsSprocketLayout.cpp
@@ -697,17 +697,17 @@ nsSprocketLayout::PopulateBoxSizes(nsIFr
         aBoxSizes      = new (aState) nsBoxSize();
         currentBox      = aBoxSizes;
       } else {
         currentBox->next      = new (aState) nsBoxSize();
         currentBox      = currentBox->next;
       }
     
 
-      flex = child->GetFlex();
+      flex = child->GetXULFlex();
 
       currentBox->flex = flex;
       currentBox->collapsed = child->IsCollapsed();
     } else {
       flex = start->flex;
       start = start->next;
     }
     
@@ -781,17 +781,17 @@ nsSprocketLayout::PopulateBoxSizes(nsIFr
           maxWidth  = maxSize.width;
           prefWidth = pref.width;
       } else {
           minWidth = minSize.height;
           maxWidth = maxSize.height;
           prefWidth = pref.height;
       }
 
-      nscoord flex = child->GetFlex();
+      nscoord flex = child->GetXULFlex();
 
       // set them if you collapsed you are not flexible.
       if (collapsed) {
         currentBox->flex = 0;
       }
       else {
         if (flex > maxFlex) {
           maxFlex = flex;
@@ -1382,17 +1382,17 @@ nsSprocketLayout::GetXULMinSize(nsIFrame
        // ignore collapsed children
       if (!child->IsCollapsed())
       {
         nsSize min = child->GetXULMinSize(aState);
         nsSize pref(0,0);
         
         // if the child is not flexible then
         // its min size is its pref size.
-        if (child->GetFlex() == 0) {
+        if (child->GetXULFlex() == 0) {
             pref = child->GetXULPrefSize(aState);
             if (isHorizontal)
                min.width = pref.width;
             else
                min.height = pref.height;
         }
 
         if (isEqual) {
