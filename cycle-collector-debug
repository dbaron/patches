Debugging memory leaks caused by cycle collection patch.

diff -r 4c541a1d7390 dom/src/base/nsGlobalWindow.cpp
--- a/dom/src/base/nsGlobalWindow.cpp	Mon Jan 15 16:17:58 2007 -0800
+++ b/dom/src/base/nsGlobalWindow.cpp	Mon Jan 15 16:18:02 2007 -0800
@@ -720,13 +720,9 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(
                                      tmp->GetCurrentInnerWindowInternal()));
   }
 
-  // FIXME: somewhere in these commented lines lies a bug that causes
-  // a segfault. So we have disabled them, even though it seems wrong
-  // to do so. Other matters are more pressing at the moment.
-
   // Traverse stuff from nsPIDOMWindow
-  // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChromeEventHandler)
-  // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDocument)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChromeEventHandler)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDocument)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsGlobalWindow, nsIScriptGlobalObject)
diff -r 4c541a1d7390 js/src/xpconnect/src/xpcwrappedjs.cpp
--- a/js/src/xpconnect/src/xpcwrappedjs.cpp	Mon Jan 15 16:17:58 2007 -0800
+++ b/js/src/xpconnect/src/xpcwrappedjs.cpp	Mon Jan 15 16:18:02 2007 -0800
@@ -92,6 +92,7 @@ NS_CYCLE_COLLECTION_CLASSNAME(nsXPCWrapp
     // just means that we rely on the cycle being broken by some of
     // the external XPCOM objects' unlink() methods, not our
     // own. Typically *any* unlinking will break the cycle.
+    printf("Unlink for nsXPCWrappedJS %p\n", s);
     return NS_OK;
 }
 
diff -r 4c541a1d7390 js/src/xpconnect/src/xpcwrappednative.cpp
--- a/js/src/xpconnect/src/xpcwrappednative.cpp	Mon Jan 15 16:17:58 2007 -0800
+++ b/js/src/xpconnect/src/xpcwrappednative.cpp	Mon Jan 15 16:18:02 2007 -0800
@@ -89,6 +89,7 @@ NS_CYCLE_COLLECTION_CLASSNAME(XPCWrapped
     // just means that we rely on the cycle being broken by some of
     // the external XPCOM objects' unlink() methods, not our
     // own. Typically *any* unlinking will break the cycle.
+    printf("Unlink for nsXPCWrappedNative %p\n", s);
     return NS_OK;
 }
 
diff -r 4c541a1d7390 xpcom/base/nsCycleCollectionParticipant.h
--- a/xpcom/base/nsCycleCollectionParticipant.h	Mon Jan 15 16:17:58 2007 -0800
+++ b/xpcom/base/nsCycleCollectionParticipant.h	Mon Jan 15 16:18:02 2007 -0800
@@ -107,6 +107,7 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsCycleCol
   NS_IMETHODIMP                                                                \
   NS_CYCLE_COLLECTION_CLASSNAME(_class)::Unlink(nsISupports *s)                \
   {                                                                            \
+    printf("Unlink for %s %p\n", #_class, s);                                  \
     NS_ASSERTION(nsCOMPtr<nsISupports>(do_QueryInterface(s)) == s,             \
                  "not canonical nsISupports pointer");                         \
     _class *tmp = NS_STATIC_CAST(_class*, NS_STATIC_CAST(_base*, s));
diff -r 4c541a1d7390 xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp	Mon Jan 15 16:17:58 2007 -0800
+++ b/xpcom/base/nsCycleCollector.cpp	Mon Jan 15 16:18:02 2007 -0800
@@ -1056,7 +1056,7 @@ nsCycleCollector::ForgetAll()
     mBufs[0]->Empty();
 }
 
-
+// XXXldb #ifdef DEBUG?
 struct graphVizWalker : public GraphWalker
 {
     // We can't just use _popen here because graphviz-for-windows
@@ -1407,6 +1407,7 @@ nsCycleCollector::ForgetRuntime(PRUint32
 }
 
 
+// XXXldb #ifdef DEBUG?
 void 
 nsCycleCollector::MaybeDrawGraphs()
 {
@@ -1593,6 +1594,7 @@ void
 void
 nsCycleCollector::Collect()
 {
+    printf("Doing cycle collection.\n");
     // This triggers a JS GC. Our caller assumes we always trigger at
     // least one JS GC -- they rely on this fact to avoid redundant JS
     // GC calls -- so it's essential that we actually execute this
