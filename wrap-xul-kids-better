Move wrapping of blocks inside XUL into ProcessChildren to catch more callers.  (Bug 421203)

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -6211,57 +6211,16 @@ nsCSSFrameConstructor::ConstructXULFrame
     // Process the child content if requested
     nsFrameItems childItems;
     if (!newFrame->IsLeaf()) {
       // XXXbz don't we need calls to ShouldBuildChildFrames
       // elsewhere too?  Why only for XUL?
       if (mDocument->BindingManager()->ShouldBuildChildFrames(aContent)) {
         rv = ProcessChildren(aState, aContent, newFrame, PR_FALSE,
                              childItems, PR_FALSE);
-        nsIContent *badKid;
-        if (newFrame->IsBoxFrame() &&
-            (badKid = AnyKidsNeedBlockParent(childItems.childList))) {
-          nsAutoString parentTag, kidTag;
-          aContent->Tag()->ToString(parentTag);
-          badKid->Tag()->ToString(kidTag);
-          const PRUnichar* params[] = { parentTag.get(), kidTag.get() };
-          const char *message =
-            (display->mDisplay == NS_STYLE_DISPLAY_INLINE_BOX)
-              ? "NeededToWrapXULInlineBox" : "NeededToWrapXUL";
-          nsContentUtils::ReportToConsole(nsContentUtils::eXUL_PROPERTIES,
-                                          message,
-                                          params, NS_ARRAY_LENGTH(params),
-                                          mDocument->GetDocumentURI(),
-                                          EmptyString(), 0, 0, // not useful
-                                          nsIScriptError::warningFlag,
-                                          "FrameConstructor");
-
-          nsRefPtr<nsStyleContext> blockSC = mPresShell->StyleSet()->
-            ResolvePseudoStyleFor(aContent,
-                                  nsCSSAnonBoxes::mozXULAnonymousBlock,
-                                  aStyleContext);
-          nsIFrame *blockFrame = NS_NewBlockFrame(mPresShell, blockSC);
-          // We might, in theory, want to set NS_BLOCK_SPACE_MGR and
-          // NS_BLOCK_MARGIN_ROOT, but I think it's a bad idea given that
-          // a real block placed here wouldn't get those set on it.
-
-          InitAndRestoreFrame(aState, aContent, newFrame, nsnull,
-                              blockFrame, PR_FALSE);
-
-          NS_ASSERTION(!blockFrame->HasView(), "need to do view reparenting");
-          for (nsIFrame *f = childItems.childList; f; f = f->GetNextSibling()) {
-            ReparentFrame(aState.mFrameManager, blockFrame, f);
-          }
-
-          blockFrame->AppendFrames(nsnull, childItems.childList);
-          childItems = nsFrameItems();
-          childItems.AddChild(blockFrame);
-
-          newFrame->AddStateBits(NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK);
-        }
       }
     }
       
     // XXX These should go after the wrapper!
     CreateAnonymousFrames(aTag, aState, aContent, newFrame, PR_FALSE,
                           childItems);
 
     // Set the frame's initial child list
@@ -11368,23 +11327,68 @@ nsCSSFrameConstructor::ProcessChildren(n
   // process the current pseudo frame state
   if (!aState.mPseudoFrames.IsEmpty()) {
     ProcessPseudoFrames(aState, aFrameItems);
   }
 
   // restore the incoming pseudo frame state
   aState.mPseudoFrames = priorPseudoFrames;
 
+  NS_ASSERTION(!aParentIsBlock || !aFrame->IsBoxFrame(),
+               "can't be both block and box");
+
   if (aParentIsBlock) {
     if (aState.mFirstLetterStyle) {
       rv = WrapFramesInFirstLetterFrame(aState, aContent, aFrame, aFrameItems);
     }
     if (aState.mFirstLineStyle) {
       rv = WrapFramesInFirstLineFrame(aState, aContent, aFrame, aFrameItems);
     }
+  }
+
+  nsIContent *badKid;
+  if (aFrame->IsBoxFrame() &&
+      (badKid = AnyKidsNeedBlockParent(childItems.childList))) {
+    nsAutoString parentTag, kidTag;
+    aContent->Tag()->ToString(parentTag);
+    badKid->Tag()->ToString(kidTag);
+    const PRUnichar* params[] = { parentTag.get(), kidTag.get() };
+    const char *message =
+      (display->mDisplay == NS_STYLE_DISPLAY_INLINE_BOX)
+        ? "NeededToWrapXULInlineBox" : "NeededToWrapXUL";
+    nsContentUtils::ReportToConsole(nsContentUtils::eXUL_PROPERTIES,
+                                    message,
+                                    params, NS_ARRAY_LENGTH(params),
+                                    mDocument->GetDocumentURI(),
+                                    EmptyString(), 0, 0, // not useful
+                                    nsIScriptError::warningFlag,
+                                    "FrameConstructor");
+
+    nsRefPtr<nsStyleContext> blockSC = mPresShell->StyleSet()->
+      ResolvePseudoStyleFor(aContent,
+                            nsCSSAnonBoxes::mozXULAnonymousBlock,
+                            aStyleContext);
+    nsIFrame *blockFrame = NS_NewBlockFrame(mPresShell, blockSC);
+    // We might, in theory, want to set NS_BLOCK_SPACE_MGR and
+    // NS_BLOCK_MARGIN_ROOT, but I think it's a bad idea given that
+    // a real block placed here wouldn't get those set on it.
+
+    InitAndRestoreFrame(aState, aContent, aFrame, nsnull,
+                        blockFrame, PR_FALSE);
+
+    NS_ASSERTION(!blockFrame->HasView(), "need to do view reparenting");
+    for (nsIFrame *f = childItems.childList; f; f = f->GetNextSibling()) {
+      ReparentFrame(aState.mFrameManager, blockFrame, f);
+    }
+
+    blockFrame->AppendFrames(nsnull, childItems.childList);
+    childItems = nsFrameItems();
+    childItems.AddChild(blockFrame);
+
+    aFrame->AddStateBits(NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK);
   }
 
   return rv;
 }
 
 //----------------------------------------------------------------------
 
 // Support for :first-line style
