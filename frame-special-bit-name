From: L. David Baron <dbaron@dbaron.org>

Bug 91419 patch 1:  Rename NS_FRAME_IS_SPECIAL to NS_FRAME_PART_OF_IB_SPLIT.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1779,17 +1779,18 @@ GetPrevContinuationWithPossiblySameStyle
   // In particular, if aFrame is the first continuation of an inline part
   // of an {ib} split then its special prevsibling is a block, and the
   // special prevsibling of _that_ is an inline, just like aFrame.
   // Similarly, if aFrame is the first continuation of a block part of an
   // {ib} split (an {ib} wrapper block), then its special prevsibling is
   // an inline and the special prevsibling of that is either another {ib}
   // wrapper block block or null.
   nsIFrame *prevContinuation = aFrame->GetPrevContinuation();
-  if (!prevContinuation && (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
+  if (!prevContinuation &&
+      (aFrame->GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT)) {
     // We're the first continuation, so we can just get the frame
     // property directly
     prevContinuation = static_cast<nsIFrame*>(
       aFrame->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
     if (prevContinuation) {
       prevContinuation = static_cast<nsIFrame*>(
         prevContinuation->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
     }
@@ -1839,17 +1840,18 @@ GetPrevContinuationWithSameStyle(nsIFram
  */
 static nsIFrame*
 GetNextContinuationWithSameStyle(nsIFrame* aFrame,
                                  nsStyleContext* aOldStyleContext)
 {
   // See GetPrevContinuationWithSameStyle about {ib} splits.
 
   nsIFrame *nextContinuation = aFrame->GetNextContinuation();
-  if (!nextContinuation && (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
+  if (!nextContinuation &&
+      (aFrame->GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT)) {
     // We're the last continuation, so we have to hop back to the first
     // before getting the frame property
     nextContinuation = static_cast<nsIFrame*>(aFrame->FirstContinuation()->
       Properties().Get(nsIFrame::IBSplitSpecialSibling()));
     if (nextContinuation) {
       nextContinuation = static_cast<nsIFrame*>(
         nextContinuation->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
     }
@@ -2011,17 +2013,17 @@ RestyleManager::ReparentStyleContext(nsI
       }
 
       // If this frame is part of an IB split, then the style context of
       // the next part of the split might be a child of our style context.
       // Reparent its style context just in case one of our ancestors
       // (split or not) hasn't done so already). It's not a problem to
       // reparent the same frame twice because the "if (newContext !=
       // oldContext)" check will prevent us from redoing work.
-      if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
+      if ((aFrame->GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT) &&
           !aFrame->GetPrevContinuation()) {
         nsIFrame* sib = static_cast<nsIFrame*>
           (aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
         if (sib) {
           ReparentStyleContext(sib);
         }
       }
 
@@ -2834,17 +2836,17 @@ ElementRestyler::SendAccessibilityNotifi
 }
 
 static inline nsIFrame*
 GetNextBlockInInlineSibling(FramePropertyTable* aPropTable, nsIFrame* aFrame)
 {
   NS_ASSERTION(!aFrame->GetPrevContinuation(),
                "must start with the first continuation");
   // Might we have special siblings?
-  if (!(aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
+  if (!(aFrame->GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT)) {
     // nothing more to do here
     return nullptr;
   }
 
   return static_cast<nsIFrame*>
     (aPropTable->Get(aFrame, nsIFrame::IBSplitSpecialSibling()));
 }
 
diff --git a/layout/base/nsBidiPresUtils.cpp b/layout/base/nsBidiPresUtils.cpp
--- a/layout/base/nsBidiPresUtils.cpp
+++ b/layout/base/nsBidiPresUtils.cpp
@@ -1329,17 +1329,17 @@ nsBidiPresUtils::IsLeftOrRightMost(nsIFr
     firstFrameState = aContinuationStates->GetEntry(frameState->mFirstVisualFrame);
   }
 
   aIsRightMost = (firstFrameState->mFrameCount == 1) &&
                  (isLTR ? !firstFrameState->mHasContOnNextLines
                         : !firstFrameState->mHasContOnPrevLines);
 
   if ((aIsLeftMost || aIsRightMost) &&
-      (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
+      (aFrame->GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT)) {
     // For ib splits, don't treat anything except the last part as
     // endmost or anything except the first part as startmost.
     // As an optimization, only get the first continuation once.
     nsIFrame* firstContinuation = aFrame->FirstContinuation();
     if (firstContinuation->FrameIsNonLastInIBSplit()) {
       // We are not endmost
       if (isLTR) {
         aIsRightMost = false;
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -408,17 +408,17 @@ ReparentFrames(nsCSSFrameConstructor* aF
 //
 // When inline frames get weird and have block frames in them, we
 // annotate them to help us respond to incremental content changes
 // more easily.
 
 static inline bool
 IsFrameSpecial(nsIFrame* aFrame)
 {
-  return (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) != 0;
+  return (aFrame->GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT) != 0;
 }
 
 static nsIFrame* GetSpecialSibling(nsIFrame* aFrame)
 {
   NS_PRECONDITION(IsFrameSpecial(aFrame), "Shouldn't call this");
 
   // We only store the "special sibling" annotation with the first
   // frame in the continuation chain. Walk back to find that frame now.
@@ -463,17 +463,17 @@ SetFrameIsSpecial(nsIFrame* aFrame, nsIF
   // We should be the only continuation
   NS_ASSERTION(!aFrame->GetPrevContinuation(),
                "assigning special sibling to other than first continuation!");
   NS_ASSERTION(!aFrame->GetNextContinuation() ||
                IsFrameSpecial(aFrame->GetNextContinuation()),
                "should have no non-special continuations here");
 
   // Mark the frame as "special".
-  aFrame->AddStateBits(NS_FRAME_IS_SPECIAL);
+  aFrame->AddStateBits(NS_FRAME_PART_OF_IB_SPLIT);
 
   if (aSpecialSibling) {
     NS_ASSERTION(!aSpecialSibling->GetPrevContinuation(),
                  "assigning something other than the first continuation as the "
                  "special sibling");
 
     // Store the "special sibling" (if we were given one) with the
     // first frame in the flow.
@@ -10396,17 +10396,18 @@ nsCSSFrameConstructor::ConstructInline(n
   // into runs of blocks and runs of inlines, create anonymous block frames to
   // contain the runs of blocks, inline frames with our style context for the
   // runs of inlines, and put all these frames, in order, into aFrameItems.  We
   // return the the first one.  The whole setup is called an {ib}
   // split; in what follows "frames in the split" refers to the anonymous blocks
   // and inlines that contain our children.
   //
   // {ib} splits maintain the following invariants:
-  // 1) All frames in the split have the NS_FRAME_IS_SPECIAL bit set.
+  // 1) All frames in the split have the NS_FRAME_PART_OF_IB_SPLIT bit
+  //    set.
   // 2) Each frame in the split has the nsIFrame::IBSplitSpecialSibling
   //    property pointing to the next frame in the split, except for the last
   //    one, which does not have it set.
   // 3) Each frame in the split has the nsIFrame::IBSplitSpecialPrevSibling
   //    property pointing to the previous frame in the split, except for the
   //    first one, which does not have it set.
   // 4) The first and last frame in the split are always inlines.
   //
diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -195,17 +195,18 @@ protected:
     }
 
     mFrame = aFrame;
   }
 
   nsIFrame* GetPrevContinuation(nsIFrame* aFrame)
   {
     nsIFrame* prevCont = aFrame->GetPrevContinuation();
-    if (!prevCont && (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
+    if (!prevCont &&
+        (aFrame->GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT)) {
       nsIFrame* block = static_cast<nsIFrame*>
         (aFrame->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
       if (block) {
         // The {ib} properties are only stored on first continuations
         NS_ASSERTION(!block->GetPrevContinuation(),
                      "Incorrect value for IBSplitSpecialPrevSibling");
         prevCont = static_cast<nsIFrame*>
           (block->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
@@ -213,17 +214,18 @@ protected:
       }
     }
     return prevCont;
   }
 
   nsIFrame* GetNextContinuation(nsIFrame* aFrame)
   {
     nsIFrame* nextCont = aFrame->GetNextContinuation();
-    if (!nextCont && (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
+    if (!nextCont &&
+        (aFrame->GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT)) {
       // The {ib} properties are only stored on first continuations
       aFrame = aFrame->FirstContinuation();
       nsIFrame* block = static_cast<nsIFrame*>
         (aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
       if (block) {
         nextCont = static_cast<nsIFrame*>
           (block->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
         NS_ASSERTION(nextCont, "How did that happen?");
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -2722,33 +2722,33 @@ nsLayoutUtils::GetParentOrPlaceholderFor
 
 nsIFrame*
 nsLayoutUtils::GetNextContinuationOrSpecialSibling(nsIFrame *aFrame)
 {
   nsIFrame *result = aFrame->GetNextContinuation();
   if (result)
     return result;
 
-  if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) != 0) {
+  if ((aFrame->GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT) != 0) {
     // We only store the "special sibling" annotation with the first
     // frame in the continuation chain. Walk back to find that frame now.
     aFrame = aFrame->FirstContinuation();
 
     void* value = aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling());
     return static_cast<nsIFrame*>(value);
   }
 
   return nullptr;
 }
 
 nsIFrame*
 nsLayoutUtils::FirstContinuationOrSpecialSibling(nsIFrame *aFrame)
 {
   nsIFrame *result = aFrame->FirstContinuation();
-  if (result->GetStateBits() & NS_FRAME_IS_SPECIAL) {
+  if (result->GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT) {
     while (true) {
       nsIFrame *f = static_cast<nsIFrame*>
         (result->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
       if (!f)
         break;
       result = f;
     }
   }
@@ -2757,17 +2757,17 @@ nsLayoutUtils::FirstContinuationOrSpecia
 }
 
 bool
 nsLayoutUtils::IsFirstContinuationOrSpecialSibling(nsIFrame *aFrame)
 {
   if (aFrame->GetPrevContinuation()) {
     return false;
   }
-  if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
+  if ((aFrame->GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT) &&
       aFrame->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling())) {
     return false;
   }
 
   return true;
 }
 
 bool
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -469,17 +469,17 @@ nsFrame::Init(nsIContent*      aContent,
   }
 
   if (aPrevInFlow) {
     // Make sure the general flags bits are the same
     nsFrameState state = aPrevInFlow->GetStateBits();
 
     // Make bits that are currently off (see constructor) the same:
     mState |= state & (NS_FRAME_INDEPENDENT_SELECTION |
-                       NS_FRAME_IS_SPECIAL |
+                       NS_FRAME_PART_OF_IB_SPLIT |
                        NS_FRAME_MAY_BE_TRANSFORMED |
                        NS_FRAME_MAY_HAVE_GENERATED_CONTENT |
                        NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN);
   }
   if (mParent) {
     nsFrameState state = mParent->GetStateBits();
 
     // Make bits that are currently off (see constructor) the same:
@@ -617,17 +617,17 @@ nsFrame::DestroyFrom(nsIFrame* aDestruct
       shell->FrameManager()->UnregisterPlaceholderFrame(placeholder);
       placeholder->SetOutOfFlowFrame(nullptr);
     }
   }
 
   // If we have any IB split special siblings, clear their references to us.
   // (Note: This has to happen before we call shell->NotifyDestroyingFrame,
   // because that clears our Properties() table.)
-  if (mState & NS_FRAME_IS_SPECIAL) {
+  if (mState & NS_FRAME_PART_OF_IB_SPLIT) {
     // Delete previous sibling's reference to me.
     nsIFrame* prevSib = static_cast<nsIFrame*>
       (Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
     if (prevSib) {
       NS_WARN_IF_FALSE(this ==
          prevSib->Properties().Get(nsIFrame::IBSplitSpecialSibling()),
          "IB sibling chain is inconsistent");
       prevSib->Properties().Delete(nsIFrame::IBSplitSpecialSibling());
@@ -6019,17 +6019,18 @@ FindBlockFrameOrBR(nsIFrame* aFrame, nsD
   nsIFormControlFrame* fcf = do_QueryFrame(aFrame);
   if (fcf)
     return result;
   
   // Check the frame itself
   // Fall through "special" block frames because their mContent is the content
   // of the inline frames they were created from. The first/last child of
   // such frames is the real block frame we're looking for.
-  if ((nsLayoutUtils::GetAsBlock(aFrame) && !(aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) ||
+  if ((nsLayoutUtils::GetAsBlock(aFrame) &&
+       !(aFrame->GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT)) ||
       aFrame->GetType() == nsGkAtoms::brFrame) {
     nsIContent* content = aFrame->GetContent();
     result.mContent = content->GetParent();
     // In some cases (bug 310589, bug 370174) we end up here with a null content.
     // This probably shouldn't ever happen, but since it sometimes does, we want
     // to avoid crashing here.
     NS_ASSERTION(result.mContent, "Unexpected orphan content");
     if (result.mContent)
@@ -7167,17 +7168,17 @@ nsFrame::ConsiderChildOverflow(nsOverflo
  * anonymous block's style context.
  *
  * If aFrame is not an anonymous block, null is returned.
  */
 static nsIFrame*
 GetIBSpecialSiblingForAnonymousBlock(const nsIFrame* aFrame)
 {
   NS_PRECONDITION(aFrame, "Must have a non-null frame!");
-  NS_ASSERTION(aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL,
+  NS_ASSERTION(aFrame->GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT,
                "GetIBSpecialSibling should not be called on a non-special frame");
 
   nsIAtom* type = aFrame->StyleContext()->GetPseudo();
   if (type != nsCSSAnonBoxes::mozAnonymousBlock &&
       type != nsCSSAnonBoxes::mozAnonymousPositionedBlock) {
     // it's not an anonymous block
     return nullptr;
   }
@@ -7232,27 +7233,27 @@ nsFrame::CorrectStyleParentFrame(nsIFram
   NS_PRECONDITION(aProspectiveParent, "Must have a prospective parent");
 
   // Anon boxes are parented to their actual parent already, except
   // for non-elements.  Those should not be treated as an anon box.
   if (aChildPseudo && aChildPseudo != nsCSSAnonBoxes::mozNonElement &&
       nsCSSAnonBoxes::IsAnonBox(aChildPseudo)) {
     NS_ASSERTION(aChildPseudo != nsCSSAnonBoxes::mozAnonymousBlock &&
                  aChildPseudo != nsCSSAnonBoxes::mozAnonymousPositionedBlock,
-                 "Should have dealt with kids that have NS_FRAME_IS_SPECIAL "
-                 "elsewhere");
+                 "Should have dealt with kids that have "
+                 "NS_FRAME_PART_OF_IB_SPLIT elsewhere");
     return aProspectiveParent;
   }
 
   // Otherwise, walk up out of all anon boxes.  For placeholder frames, walk out
   // of all pseudo-elements as well.  Otherwise ReparentStyleContext could cause
   // style data to be out of sync with the frame tree.
   nsIFrame* parent = aProspectiveParent;
   do {
-    if (parent->GetStateBits() & NS_FRAME_IS_SPECIAL) {
+    if (parent->GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT) {
       nsIFrame* sibling = GetIBSpecialSiblingForAnonymousBlock(parent);
 
       if (sibling) {
         // |parent| was a block in an {ib} split; use the inline as
         // |the style parent.
         parent = sibling;
       }
     }
@@ -7296,17 +7297,17 @@ nsFrame::DoGetParentStyleContextFrame() 
   }
   
   if (!(mState & NS_FRAME_OUT_OF_FLOW)) {
     /*
      * If this frame is an anonymous block created when an inline with a block
      * inside it got split, then the parent style context is on its preceding
      * inline. We can get to it using GetIBSpecialSiblingForAnonymousBlock.
      */
-    if (mState & NS_FRAME_IS_SPECIAL) {
+    if (mState & NS_FRAME_PART_OF_IB_SPLIT) {
       nsIFrame* specialSibling = GetIBSpecialSiblingForAnonymousBlock(this);
       if (specialSibling) {
         return specialSibling;
       }
     }
 
     // If this frame is one of the blocks that split an inline, we must
     // return the "special" inline parent, i.e., the parent that this
diff --git a/layout/generic/nsFrameStateBits.h b/layout/generic/nsFrameStateBits.h
--- a/layout/generic/nsFrameStateBits.h
+++ b/layout/generic/nsFrameStateBits.h
@@ -130,17 +130,17 @@ FRAME_STATE_BIT(Generic, 13, NS_FRAME_HA
 // If this bit is set, the frame was created from anonymous content.
 FRAME_STATE_BIT(Generic, 14, NS_FRAME_INDEPENDENT_SELECTION)
 
 // If this bit is set, the frame is "special" (lame term, I know),
 // which means that it is part of the mangled frame hierarchy that
 // results when an inline has been split because of a nested block.
 // See the comments in nsCSSFrameConstructor::ConstructInline for
 // more details.
-FRAME_STATE_BIT(Generic, 15, NS_FRAME_IS_SPECIAL)
+FRAME_STATE_BIT(Generic, 15, NS_FRAME_PART_OF_IB_SPLIT)
 
 // If this bit is set, then transforms (e.g. CSS or SVG transforms) are allowed
 // to affect the frame, and a transform may currently be in affect. If this bit
 // is not set, then any transforms on the frame will be ignored.
 // This is used primarily in GetTransformMatrix to optimize for the
 // common case.
 FRAME_STATE_BIT(Generic, 16, NS_FRAME_MAY_BE_TRANSFORMED)
 
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -889,17 +889,17 @@ nsHTMLReflowState::ApplyRelativePosition
   }
 
   const nsStyleDisplay* display = aFrame->StyleDisplay();
   if (NS_STYLE_POSITION_RELATIVE == display->mPosition) {
     *aPosition += nsPoint(aComputedOffsets.left, aComputedOffsets.top);
   } else if (NS_STYLE_POSITION_STICKY == display->mPosition &&
              !aFrame->GetNextContinuation() &&
              !aFrame->GetPrevContinuation() &&
-             !(aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
+             !(aFrame->GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT)) {
     // Sticky positioning for elements with multiple frames needs to be
     // computed all at once. We can't safely do that here because we might be
     // partway through (re)positioning the frames, so leave it until the scroll
     // container reflows and calls StickyScrollContainer::UpdatePositions.
     // For single-frame sticky positioned elements, though, go ahead and apply
     // it now to avoid unnecessary overflow updates later.
     StickyScrollContainer* ssc =
       StickyScrollContainer::GetStickyScrollContainerForFrame(aFrame);
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2803,26 +2803,26 @@ NS_PTR_TO_INT32(frame->Properties().Get(
   template<bool IsLessThanOrEqual(nsIFrame*, nsIFrame*)>
   static bool IsFrameListSorted(nsFrameList& aFrameList);
 
   /**
    * Return true if aFrame is in an {ib} split and is NOT one of the
    * continuations of the first inline in it.
    */
   bool FrameIsNonFirstInIBSplit() const {
-    return (GetStateBits() & NS_FRAME_IS_SPECIAL) &&
+    return (GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT) &&
       FirstContinuation()->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling());
   }
 
   /**
    * Return true if aFrame is in an {ib} split and is NOT one of the
    * continuations of the last inline in it.
    */
   bool FrameIsNonLastInIBSplit() const {
-    return (GetStateBits() & NS_FRAME_IS_SPECIAL) &&
+    return (GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT) &&
       FirstContinuation()->Properties().Get(nsIFrame::IBSplitSpecialSibling());
   }
 
   /**
    * Return whether this is a frame whose width is used when computing
    * the font size inflation of its descendants.
    */
   bool IsContainerForFontSizeInflation() const {
diff --git a/layout/generic/nsInlineFrame.cpp b/layout/generic/nsInlineFrame.cpp
--- a/layout/generic/nsInlineFrame.cpp
+++ b/layout/generic/nsInlineFrame.cpp
@@ -110,17 +110,17 @@ nsInlineFrame::IsSelfEmpty()
     border->GetComputedBorderWidth(NS_SIDE_RIGHT) != 0 ||
     !nsLayoutUtils::IsPaddingZero(padding->mPadding.GetRight()) ||
     !IsMarginZero(margin->mMargin.GetRight());
   bool haveLeft =
     border->GetComputedBorderWidth(NS_SIDE_LEFT) != 0 ||
     !nsLayoutUtils::IsPaddingZero(padding->mPadding.GetLeft()) ||
     !IsMarginZero(margin->mMargin.GetLeft());
   if (haveLeft || haveRight) {
-    if (GetStateBits() & NS_FRAME_IS_SPECIAL) {
+    if (GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT) {
       bool haveStart, haveEnd;
       if (NS_STYLE_DIRECTION_LTR == StyleVisibility()->mDirection) {
         haveStart = haveLeft;
         haveEnd = haveRight;
       } else {
         haveStart = haveRight;
         haveEnd = haveLeft;
       }
@@ -897,17 +897,17 @@ nsInlineFrame::GetSkipSides(const nsHTML
       skip |= 1 << NS_SIDE_RIGHT;
     }
     else {
       // If the next continuation is empty, then go ahead and let our right
       // edge border render.
     }
   }
 
-  if (GetStateBits() & NS_FRAME_IS_SPECIAL) {
+  if (GetStateBits() & NS_FRAME_PART_OF_IB_SPLIT) {
     // All but the last part of an {ib} split should skip the "end" side (as
     // determined by this frame's direction) and all but the first part of such
     // a split should skip the "start" side.  But figuring out which part of
     // the split we are involves getting our first continuation, which might be
     // expensive.  So don't bother if we already have the relevant bits set.
     bool ltr = (NS_STYLE_DIRECTION_LTR == StyleVisibility()->mDirection);
     int startBit = (1 << (ltr ? NS_SIDE_LEFT : NS_SIDE_RIGHT));
     int endBit = (1 << (ltr ? NS_SIDE_RIGHT : NS_SIDE_LEFT));
