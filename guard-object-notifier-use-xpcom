From: L. David Baron <dbaron@dbaron.org>

Fire assertions when guard objects are used as temporaries.  (Bug 531460)  r=cjones

diff --git a/xpcom/glue/AutoRestore.h b/xpcom/glue/AutoRestore.h
--- a/xpcom/glue/AutoRestore.h
+++ b/xpcom/glue/AutoRestore.h
@@ -168,21 +168,26 @@ namespace mozilla {
    *     mIsPainting = PR_TRUE;
    *     
    *     // ... your code here ...
    *
    *     // mIsPainting is reset to its old value at the end of this block
    *   }
    */
   template <class T>
-  class AutoRestore
+  class NS_STACK_CLASS AutoRestore
   {
   private:
     T& mLocation;
     T mValue;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
   public:
-    AutoRestore(T& aValue) : mLocation(aValue), mValue(aValue) {}
+    AutoRestore(T& aValue MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
+      : mLocation(aValue), mValue(aValue)
+    {
+      MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+    }
     ~AutoRestore() { mLocation = mValue; }
   };
 
 }
 
 #endif /* !defined(mozilla_AutoRestore_h_) */
diff --git a/xpcom/glue/Mutex.h b/xpcom/glue/Mutex.h
--- a/xpcom/glue/Mutex.h
+++ b/xpcom/glue/Mutex.h
@@ -36,16 +36,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef mozilla_Mutex_h
 #define mozilla_Mutex_h
 
 #include "prlock.h"
 
+#include "mozilla/AutoRestore.h"
 #include "mozilla/BlockingResourceBase.h"
 
 //
 // Provides:
 //
 //  - Mutex, a non-recursive mutex
 //  - MutexAutoLock, an RAII class for ensuring that Mutexes are properly 
 //    locked and unlocked
@@ -168,51 +169,54 @@ public:
     /**
      * Constructor
      * The constructor aquires the given lock.  The destructor
      * releases the lock.
      * 
      * @param aLock A valid mozilla::Mutex* returned by 
      *              mozilla::Mutex::NewMutex. 
      **/
-    MutexAutoLock(mozilla::Mutex& aLock) :
+    MutexAutoLock(mozilla::Mutex& aLock MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM) :
         mLock(&aLock)
     {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         NS_ASSERTION(mLock, "null mutex");
         mLock->Lock();
     }
     
     ~MutexAutoLock(void) {
         mLock->Unlock();
     }
  
 private:
     MutexAutoLock();
     MutexAutoLock(MutexAutoLock&);
     MutexAutoLock& operator=(MutexAutoLock&);
     static void* operator new(size_t) CPP_THROW_NEW;
     static void operator delete(void*);
 
     mozilla::Mutex* mLock;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 
 /**
  * MutexAutoUnlock
  * Releases the Mutex when it enters scope, and re-acquires it when it leaves 
  * scope.
  *
  * MUCH PREFERRED to bare calls to Mutex.Unlock and Lock.
  */ 
 class NS_COM_GLUE NS_STACK_CLASS MutexAutoUnlock 
 {
 public:
-    MutexAutoUnlock(mozilla::Mutex& aLock) :
+    MutexAutoUnlock(mozilla::Mutex& aLock MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM) :
         mLock(&aLock)
     {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         NS_ASSERTION(mLock, "null lock");
         mLock->Unlock();
     }
 
     ~MutexAutoUnlock() 
     {
         mLock->Lock();
     }
@@ -220,15 +224,16 @@ public:
 private:
     MutexAutoUnlock();
     MutexAutoUnlock(MutexAutoUnlock&);
     MutexAutoUnlock& operator =(MutexAutoUnlock&);
     static void* operator new(size_t) CPP_THROW_NEW;
     static void operator delete(void*);
      
     mozilla::Mutex* mLock;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 
 } // namespace mozilla
 
 
 #endif // ifndef mozilla_Mutex_h
diff --git a/xpcom/glue/nsAutoLock.h b/xpcom/glue/nsAutoLock.h
--- a/xpcom/glue/nsAutoLock.h
+++ b/xpcom/glue/nsAutoLock.h
@@ -104,23 +104,24 @@
  */
 
 #ifndef nsAutoLock_h__
 #define nsAutoLock_h__
 
 #include "nscore.h"
 #include "prlock.h"
 #include "prlog.h"
+#include "mozilla/AutoRestore.h"
 
 /**
  * nsAutoLockBase
  * This is the base class for the stack-based locking objects.
  * Clients of derived classes need not play with this superclass.
  **/
-class NS_COM_GLUE nsAutoLockBase {
+class NS_COM_GLUE NS_STACK_CLASS nsAutoLockBase {
     friend class nsAutoUnlockBase;
 
 protected:
     nsAutoLockBase() {}
     enum nsAutoLockType {eAutoLock, eAutoMonitor, eAutoCMonitor};
 
 #ifdef DEBUG
     nsAutoLockBase(void* addr, nsAutoLockType type);
@@ -141,17 +142,17 @@ protected:
 #endif
 };
 
 /**
  * nsAutoUnlockBase
  * This is the base class for stack-based unlocking objects.
  * It unlocks locking objects based on nsAutoLockBase.
  **/
-class NS_COM_GLUE nsAutoUnlockBase {
+class NS_COM_GLUE NS_STACK_CLASS nsAutoUnlockBase {
 protected:
     nsAutoUnlockBase() {}
 
 #ifdef DEBUG
     nsAutoUnlockBase(void* addr);
     ~nsAutoUnlockBase();
 
     nsAutoLockBase* mLock;
@@ -160,20 +161,21 @@ protected:
     ~nsAutoUnlockBase() {}
 #endif
 };
 
 /** 
  * nsAutoLock
  * Stack-based locking object for PRLock.
  **/
-class NS_COM_GLUE nsAutoLock : public nsAutoLockBase {
+class NS_COM_GLUE NS_STACK_CLASS nsAutoLock : public nsAutoLockBase {
 private:
     PRLock* mLock;
     PRBool mLocked;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 
     // Not meant to be implemented. This makes it a compiler error to
     // construct or assign an nsAutoLock object incorrectly.
     nsAutoLock(void) {}
     nsAutoLock(nsAutoLock& /*aLock*/) {}
     nsAutoLock& operator =(nsAutoLock& /*aLock*/) {
         return *this;
     }
@@ -203,20 +205,21 @@ public:
     /**
      * Constructor
      * The constructor aquires the given lock.  The destructor
      * releases the lock.
      * 
      * @param aLock A valid PRLock* returned from the NSPR's 
      * PR_NewLock() function.
      **/
-    nsAutoLock(PRLock* aLock)
+    nsAutoLock(PRLock* aLock MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
         : nsAutoLockBase(aLock, eAutoLock),
           mLock(aLock),
           mLocked(PR_TRUE) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         PR_ASSERT(mLock);
 
         // This will assert deep in the bowels of NSPR if you attempt
         // to re-enter the lock.
         PR_Lock(mLock);
     }
     
     ~nsAutoLock(void) {
@@ -245,39 +248,41 @@ public:
      void unlock() {
         PR_ASSERT(mLocked);
         PR_Unlock(mLock);
         mLocked = PR_FALSE;
         Hide();
     }
 };
 
-class nsAutoUnlock : private nsAutoUnlockBase
+class NS_STACK_CLASS nsAutoUnlock : private nsAutoUnlockBase
 {
 private:
     PRLock *mLock;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
      
 public:
-    nsAutoUnlock(PRLock *lock) : 
+    nsAutoUnlock(PRLock *lock MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM) : 
         nsAutoUnlockBase(lock),
         mLock(lock)
     {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         PR_Unlock(mLock);
     }
 
     ~nsAutoUnlock() {
         PR_Lock(mLock);
     }
 };
 
 #include "prcmon.h"
 #include "nsError.h"
 #include "nsDebug.h"
 
-class NS_COM_GLUE nsAutoMonitor : public nsAutoLockBase {
+class NS_COM_GLUE NS_STACK_CLASS nsAutoMonitor : public nsAutoLockBase {
 public:
 
     /**
      * NewMonitor
      * Allocates a new PRMonitor for use with nsAutoMonitor.
      * @param name A (unique /be?) name which can reference this monitor
      * @returns nsnull if failure
      *          A valid PRMonitor* is successful while must be destroyed
@@ -290,20 +295,21 @@ public:
     /**
      * Constructor
      * The constructor locks the given monitor.  During destruction
      * the monitor will be unlocked.
      * 
      * @param mon A valid PRMonitor* returned from 
      *        nsAutoMonitor::NewMonitor().
      **/
-    nsAutoMonitor(PRMonitor* mon)
+    nsAutoMonitor(PRMonitor* mon MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
         : nsAutoLockBase((void*)mon, eAutoMonitor),
           mMonitor(mon), mLockCount(0)
     {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         NS_ASSERTION(mMonitor, "null monitor");
         if (mMonitor) {
             PR_EnterMonitor(mMonitor);
             mLockCount = 1;
         }
     }
 
     ~nsAutoMonitor() {
@@ -356,16 +362,17 @@ public:
     nsresult NotifyAll() {
         return PR_NotifyAll(mMonitor) == PR_SUCCESS
             ? NS_OK : NS_ERROR_FAILURE;
     }
 
 private:
     PRMonitor*  mMonitor;
     PRInt32     mLockCount;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 
     // Not meant to be implemented. This makes it a compiler error to
     // construct or assign an nsAutoLock object incorrectly.
     nsAutoMonitor(void) {}
     nsAutoMonitor(nsAutoMonitor& /*aMon*/) {}
     nsAutoMonitor& operator =(nsAutoMonitor& /*aMon*/) {
         return *this;
     }
@@ -381,22 +388,23 @@ private:
 ////////////////////////////////////////////////////////////////////////////////
 // Once again, this time with a cache...
 // (Using this avoids the need to allocate a PRMonitor, which may be useful when
 // a large number of objects of the same class need associated monitors.)
 
 #include "prcmon.h"
 #include "nsError.h"
 
-class NS_COM_GLUE nsAutoCMonitor : public nsAutoLockBase {
+class NS_COM_GLUE NS_STACK_CLASS nsAutoCMonitor : public nsAutoLockBase {
 public:
-    nsAutoCMonitor(void* lockObject)
+    nsAutoCMonitor(void* lockObject MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
         : nsAutoLockBase(lockObject, eAutoCMonitor),
           mLockObject(lockObject), mLockCount(0)
     {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         NS_ASSERTION(lockObject, "null lock object");
         PR_CEnterMonitor(mLockObject);
         mLockCount = 1;
     }
 
     ~nsAutoCMonitor() {
         if (mLockCount) {
 #ifdef DEBUG
@@ -423,16 +431,17 @@ public:
     nsresult NotifyAll() {
         return PR_CNotifyAll(mLockObject) == PR_SUCCESS
             ? NS_OK : NS_ERROR_FAILURE;
     }
 
 private:
     void*   mLockObject;
     PRInt32 mLockCount;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 
     // Not meant to be implemented. This makes it a compiler error to
     // construct or assign an nsAutoLock object incorrectly.
     nsAutoCMonitor(void) {}
     nsAutoCMonitor(nsAutoCMonitor& /*aMon*/) {}
     nsAutoCMonitor& operator =(nsAutoCMonitor& /*aMon*/) {
         return *this;
     }
