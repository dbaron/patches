From: L. David Baron <dbaron@dbaron.org>

Convert attribute mapping functions to property getters instead of accessing struct members.

diff --git a/content/html/content/src/nsGenericHTMLElement.cpp b/content/html/content/src/nsGenericHTMLElement.cpp
--- a/content/html/content/src/nsGenericHTMLElement.cpp
+++ b/content/html/content/src/nsGenericHTMLElement.cpp
@@ -1643,54 +1643,54 @@ nsGenericHTMLElement::ParseScrollingValu
 /**
  * Handle attributes common to all html elements
  */
 void
 nsGenericHTMLElement::MapCommonAttributesExceptHiddenInto(const nsMappedAttributes* aAttributes,
                                                           nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(UserInterface)) {
-    nsRuleDataUserInterface *ui = aData->mUserInterfaceData;
-    if (ui->mUserModify.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* userModify = aData->ValueForMozUserModify();
+    if (userModify->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value =
         aAttributes->GetAttr(nsGkAtoms::contenteditable);
       if (value) {
         if (value->Equals(nsGkAtoms::_empty, eCaseMatters) ||
             value->Equals(nsGkAtoms::_true, eIgnoreCase)) {
-          ui->mUserModify.SetIntValue(NS_STYLE_USER_MODIFY_READ_WRITE,
-                                      eCSSUnit_Enumerated);
+          userModify->SetIntValue(NS_STYLE_USER_MODIFY_READ_WRITE,
+                                  eCSSUnit_Enumerated);
         }
         else if (value->Equals(nsGkAtoms::_false, eIgnoreCase)) {
-            ui->mUserModify.SetIntValue(NS_STYLE_USER_MODIFY_READ_ONLY,
-                                        eCSSUnit_Enumerated);
+            userModify->SetIntValue(NS_STYLE_USER_MODIFY_READ_ONLY,
+                                    eCSSUnit_Enumerated);
         }
       }
     }
   }
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Visibility)) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::lang);
     if (value && value->Type() == nsAttrValue::eString) {
-      aData->mDisplayData->mLang.SetStringValue(value->GetStringValue(),
-                                                eCSSUnit_Ident);
+      aData->ValueForLang()->SetStringValue(value->GetStringValue(),
+                                            eCSSUnit_Ident);
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapCommonAttributesInto(const nsMappedAttributes* aAttributes,
                                               nsRuleData* aData)
 {
   nsGenericHTMLElement::MapCommonAttributesExceptHiddenInto(aAttributes, aData);
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) {
-    nsRuleDataDisplay* disp = aData->mDisplayData;
-    if (disp->mDisplay.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* display = aData->ValueForDisplay();
+    if (display->GetUnit() == eCSSUnit_Null) {
       if (aAttributes->IndexOfAttr(nsGkAtoms::hidden, kNameSpaceID_None) >= 0) {
-        disp->mDisplay.SetIntValue(NS_STYLE_DISPLAY_NONE, eCSSUnit_Enumerated);
+        display->SetIntValue(NS_STYLE_DISPLAY_NONE, eCSSUnit_Enumerated);
       }
     }
   }
 }
 
 void
 nsGenericHTMLFormElement::UpdateEditableFormControlState()
 {
@@ -1782,48 +1782,54 @@ void
 nsGenericHTMLElement::MapImageAlignAttributeInto(const nsMappedAttributes* aAttributes,
                                                  nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & (NS_STYLE_INHERIT_BIT(Display) |
                           NS_STYLE_INHERIT_BIT(TextReset))) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
     if (value && value->Type() == nsAttrValue::eEnum) {
       PRInt32 align = value->GetEnumValue();
-      if ((aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) &&
-          aRuleData->mDisplayData->mFloat.GetUnit() == eCSSUnit_Null) {
-        if (align == NS_STYLE_TEXT_ALIGN_LEFT)
-          aRuleData->mDisplayData->mFloat.SetIntValue(NS_STYLE_FLOAT_LEFT, eCSSUnit_Enumerated);
-        else if (align == NS_STYLE_TEXT_ALIGN_RIGHT)
-          aRuleData->mDisplayData->mFloat.SetIntValue(NS_STYLE_FLOAT_RIGHT, eCSSUnit_Enumerated);
+      if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) {
+        nsCSSValue* cssFloat = aRuleData->ValueForCssFloat();
+        if (cssFloat->GetUnit() == eCSSUnit_Null) {
+          if (align == NS_STYLE_TEXT_ALIGN_LEFT) {
+            cssFloat->SetIntValue(NS_STYLE_FLOAT_LEFT, eCSSUnit_Enumerated);
+          } else if (align == NS_STYLE_TEXT_ALIGN_RIGHT) {
+            cssFloat->SetIntValue(NS_STYLE_FLOAT_RIGHT, eCSSUnit_Enumerated);
+          }
+        }
       }
-      if ((aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) &&
-          aRuleData->mTextData->mVerticalAlign.GetUnit() == eCSSUnit_Null) {
-        switch (align) {
-        case NS_STYLE_TEXT_ALIGN_LEFT:
-        case NS_STYLE_TEXT_ALIGN_RIGHT:
-          break;
-        default:
-          aRuleData->mTextData->mVerticalAlign.SetIntValue(align, eCSSUnit_Enumerated);
-          break;
+      if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
+        nsCSSValue* verticalAlign = aRuleData->ValueForVerticalAlign();
+        if (verticalAlign->GetUnit() == eCSSUnit_Null) {
+          switch (align) {
+          case NS_STYLE_TEXT_ALIGN_LEFT:
+          case NS_STYLE_TEXT_ALIGN_RIGHT:
+            break;
+          default:
+            verticalAlign->SetIntValue(align, eCSSUnit_Enumerated);
+            break;
+          }
         }
       }
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapDivAlignAttributeInto(const nsMappedAttributes* aAttributes,
                                                nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
-    if (aRuleData->mTextData->mTextAlign.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* textAlign = aRuleData->ValueForTextAlign();
+    if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aRuleData->mTextData->mTextAlign.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 }
 
 
 void
 nsGenericHTMLElement::MapImageMarginAttributeInto(const nsMappedAttributes* aAttributes,
                                                   nsRuleData* aData)
@@ -1838,66 +1844,70 @@ nsGenericHTMLElement::MapImageMarginAttr
   if (value) {
     nsCSSValue hval;
     if (value->Type() == nsAttrValue::eInteger)
       hval.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     else if (value->Type() == nsAttrValue::ePercent)
       hval.SetPercentValue(value->GetPercentValue());
 
     if (hval.GetUnit() != eCSSUnit_Null) {
-      nsCSSRect& margin = aData->mMarginData->mMargin;
-      if (margin.mLeft.GetUnit() == eCSSUnit_Null)
-        margin.mLeft = hval;
-      if (margin.mRight.GetUnit() == eCSSUnit_Null)
-        margin.mRight = hval;
+      nsCSSValue* left = aData->ValueForMarginLeft();
+      if (left->GetUnit() == eCSSUnit_Null)
+        *left = hval;
+      nsCSSValue* right = aData->ValueForMarginRight();
+      if (right->GetUnit() == eCSSUnit_Null)
+        *right = hval;
     }
   }
 
   // vspace: value
   value = aAttributes->GetAttr(nsGkAtoms::vspace);
   if (value) {
     nsCSSValue vval;
     if (value->Type() == nsAttrValue::eInteger)
       vval.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     else if (value->Type() == nsAttrValue::ePercent)
       vval.SetPercentValue(value->GetPercentValue());
   
     if (vval.GetUnit() != eCSSUnit_Null) {
-      nsCSSRect& margin = aData->mMarginData->mMargin;
-      if (margin.mTop.GetUnit() == eCSSUnit_Null)
-        margin.mTop = vval;
-      if (margin.mBottom.GetUnit() == eCSSUnit_Null)
-        margin.mBottom = vval;
+      nsCSSValue* top = aData->ValueForMarginTop();
+      if (top->GetUnit() == eCSSUnit_Null)
+        *top = vval;
+      nsCSSValue* bottom = aData->ValueForMarginBottom();
+      if (bottom->GetUnit() == eCSSUnit_Null)
+        *bottom = vval;
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapImageSizeAttributesInto(const nsMappedAttributes* aAttributes,
                                                  nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)))
     return;
 
   // width: value
-  if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
+  nsCSSValue* width = aData->ValueForWidth();
+  if (width->GetUnit() == eCSSUnit_Null) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
     if (value && value->Type() == nsAttrValue::eInteger)
-      aData->mPositionData->mWidth.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+      width->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     else if (value && value->Type() == nsAttrValue::ePercent)
-      aData->mPositionData->mWidth.SetPercentValue(value->GetPercentValue());
+      width->SetPercentValue(value->GetPercentValue());
   }
 
   // height: value
-  if (aData->mPositionData->mHeight.GetUnit() == eCSSUnit_Null) {
+  nsCSSValue* height = aData->ValueForHeight();
+  if (height->GetUnit() == eCSSUnit_Null) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::height);
     if (value && value->Type() == nsAttrValue::eInteger)
-      aData->mPositionData->mHeight.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
+      height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
     else if (value && value->Type() == nsAttrValue::ePercent)
-      aData->mPositionData->mHeight.SetPercentValue(value->GetPercentValue());    
+      height->SetPercentValue(value->GetPercentValue());
   }
 }
 
 void
 nsGenericHTMLElement::MapImageBorderAttributeInto(const nsMappedAttributes* aAttributes,
                                                   nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Border)))
@@ -1907,56 +1917,66 @@ nsGenericHTMLElement::MapImageBorderAttr
   const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::border);
   if (!value)
     return;
   
   nscoord val = 0;
   if (value->Type() == nsAttrValue::eInteger)
     val = value->GetIntegerValue();
 
-  nsCSSRect& borderWidth = aData->mMarginData->mBorderWidth;
-  if (borderWidth.mLeft.GetUnit() == eCSSUnit_Null)
-    borderWidth.mLeft.SetFloatValue((float)val, eCSSUnit_Pixel);
-  if (borderWidth.mTop.GetUnit() == eCSSUnit_Null)
-    borderWidth.mTop.SetFloatValue((float)val, eCSSUnit_Pixel);
-  if (borderWidth.mRight.GetUnit() == eCSSUnit_Null)
-    borderWidth.mRight.SetFloatValue((float)val, eCSSUnit_Pixel);
-  if (borderWidth.mBottom.GetUnit() == eCSSUnit_Null)
-    borderWidth.mBottom.SetFloatValue((float)val, eCSSUnit_Pixel);
-
-  nsCSSRect& borderStyle = aData->mMarginData->mBorderStyle;
-  if (borderStyle.mLeft.GetUnit() == eCSSUnit_Null)
-    borderStyle.mLeft.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
-  if (borderStyle.mTop.GetUnit() == eCSSUnit_Null)
-    borderStyle.mTop.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
-  if (borderStyle.mRight.GetUnit() == eCSSUnit_Null)
-    borderStyle.mRight.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
-  if (borderStyle.mBottom.GetUnit() == eCSSUnit_Null)
-    borderStyle.mBottom.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
-
-  nsCSSRect& borderColor = aData->mMarginData->mBorderColor;
-  if (borderColor.mLeft.GetUnit() == eCSSUnit_Null)
-    borderColor.mLeft.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
-  if (borderColor.mTop.GetUnit() == eCSSUnit_Null)
-    borderColor.mTop.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
-  if (borderColor.mRight.GetUnit() == eCSSUnit_Null)
-    borderColor.mRight.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
-  if (borderColor.mBottom.GetUnit() == eCSSUnit_Null)
-    borderColor.mBottom.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
+  nsCSSValue* borderLeftWidth = aData->ValueForBorderLeftWidth();
+  if (borderLeftWidth->GetUnit() == eCSSUnit_Null)
+    borderLeftWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
+  nsCSSValue* borderTopWidth = aData->ValueForBorderTopWidth();
+  if (borderTopWidth->GetUnit() == eCSSUnit_Null)
+    borderTopWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
+  nsCSSValue* borderRightWidth = aData->ValueForBorderRightWidth();
+  if (borderRightWidth->GetUnit() == eCSSUnit_Null)
+    borderRightWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
+  nsCSSValue* borderBottomWidth = aData->ValueForBorderBottomWidth();
+  if (borderBottomWidth->GetUnit() == eCSSUnit_Null)
+    borderBottomWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
+
+  nsCSSValue* borderLeftStyle = aData->ValueForBorderLeftStyle();
+  if (borderLeftStyle->GetUnit() == eCSSUnit_Null)
+    borderLeftStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
+  nsCSSValue* borderTopStyle = aData->ValueForBorderTopStyle();
+  if (borderTopStyle->GetUnit() == eCSSUnit_Null)
+    borderTopStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
+  nsCSSValue* borderRightStyle = aData->ValueForBorderRightStyle();
+  if (borderRightStyle->GetUnit() == eCSSUnit_Null)
+    borderRightStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
+  nsCSSValue* borderBottomStyle = aData->ValueForBorderBottomStyle();
+  if (borderBottomStyle->GetUnit() == eCSSUnit_Null)
+    borderBottomStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
+
+  nsCSSValue* borderLeftColor = aData->ValueForBorderLeftColor();
+  if (borderLeftColor->GetUnit() == eCSSUnit_Null)
+    borderLeftColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
+  nsCSSValue* borderTopColor = aData->ValueForBorderTopColor();
+  if (borderTopColor->GetUnit() == eCSSUnit_Null)
+    borderTopColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
+  nsCSSValue* borderRightColor = aData->ValueForBorderRightColor();
+  if (borderRightColor->GetUnit() == eCSSUnit_Null)
+    borderRightColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
+  nsCSSValue* borderBottomColor = aData->ValueForBorderBottomColor();
+  if (borderBottomColor->GetUnit() == eCSSUnit_Null)
+    borderBottomColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
 }
 
 void
 nsGenericHTMLElement::MapBackgroundInto(const nsMappedAttributes* aAttributes,
                                         nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
     return;
 
   nsPresContext* presContext = aData->mPresContext;
-  if (aData->mColorData->mBackImage.GetUnit() == eCSSUnit_Null &&
+  nsCSSValue* backImage = aData->ValueForBackgroundImage();
+  if (backImage->GetUnit() == eCSSUnit_Null &&
       presContext->UseDocumentColors()) {
     // background
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::background);
     if (value && value->Type() == nsAttrValue::eString) {
       const nsString& spec = value->GetStringValue();
       if (!spec.IsEmpty()) {
         // Resolve url to an absolute url
         // XXX this breaks if the HTML element has an xml:base
@@ -1976,46 +1996,46 @@ nsGenericHTMLElement::MapBackgroundInto(
           if (NS_LIKELY(buffer)) {
             // XXXbz it would be nice to assert that doc->NodePrincipal() is
             // the same as the principal of the node (which we'd need to store
             // in the mapped attrs or something?)
             nsCSSValue::Image *img =
               new nsCSSValue::Image(uri, buffer, doc->GetDocumentURI(),
                                     doc->NodePrincipal(), doc);
             if (NS_LIKELY(img)) {
-              nsCSSValueList* list =
-                aData->mColorData->mBackImage.SetListValue();
+              nsCSSValueList* list = backImage->SetListValue();
               list->mValue.SetImageValue(img);
             }
           }
         }
       }
       else if (presContext->CompatibilityMode() == eCompatibility_NavQuirks) {
         // in NavQuirks mode, allow the empty string to set the
         // background to empty
-        nsCSSValueList* list = aData->mColorData->mBackImage.SetListValue();
+        nsCSSValueList* list = backImage->SetListValue();
         list->mValue.SetNoneValue();
       }
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapBGColorInto(const nsMappedAttributes* aAttributes,
                                      nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
     return;
 
-  if (aData->mColorData->mBackColor.GetUnit() == eCSSUnit_Null &&
+  nsCSSValue* backColor = aData->ValueForBackgroundColor();
+  if (backColor->GetUnit() == eCSSUnit_Null &&
       aData->mPresContext->UseDocumentColors()) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::bgcolor);
     nscolor color;
     if (value && value->GetColorValue(color)) {
-      aData->mColorData->mBackColor.SetColorValue(color);
+      backColor->SetColorValue(color);
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapBackgroundAttributesInto(const nsMappedAttributes* aAttributes,
                                                   nsRuleData* aData)
 {
@@ -2027,18 +2047,18 @@ void
 nsGenericHTMLElement::MapScrollingAttributeInto(const nsMappedAttributes* aAttributes,
                                                 nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)))
     return;
 
   // scrolling
   nsCSSValue* overflowValues[2] = {
-    &aData->mDisplayData->mOverflowX,
-    &aData->mDisplayData->mOverflowY,
+    aData->ValueForOverflowX(),
+    aData->ValueForOverflowY(),
   };
   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(overflowValues); ++i) {
     if (overflowValues[i]->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::scrolling);
       if (value && value->Type() == nsAttrValue::eEnum) {
         PRInt32 mappedValue;
         switch (value->GetEnumValue()) {
           case NS_STYLE_FRAME_ON:
