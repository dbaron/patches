From: L. David Baron <dbaron@dbaron.org>

Convert attribute mapping functions to property getters instead of accessing struct members.

diff --git a/content/html/content/src/nsGenericHTMLElement.cpp b/content/html/content/src/nsGenericHTMLElement.cpp
--- a/content/html/content/src/nsGenericHTMLElement.cpp
+++ b/content/html/content/src/nsGenericHTMLElement.cpp
@@ -1643,54 +1643,54 @@ nsGenericHTMLElement::ParseScrollingValu
 /**
  * Handle attributes common to all html elements
  */
 void
 nsGenericHTMLElement::MapCommonAttributesExceptHiddenInto(const nsMappedAttributes* aAttributes,
                                                           nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(UserInterface)) {
-    nsRuleDataUserInterface *ui = aData->mUserInterfaceData;
-    if (ui->mUserModify.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* userModify = aData->ValueForMozUserModify();
+    if (userModify->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value =
         aAttributes->GetAttr(nsGkAtoms::contenteditable);
       if (value) {
         if (value->Equals(nsGkAtoms::_empty, eCaseMatters) ||
             value->Equals(nsGkAtoms::_true, eIgnoreCase)) {
-          ui->mUserModify.SetIntValue(NS_STYLE_USER_MODIFY_READ_WRITE,
-                                      eCSSUnit_Enumerated);
+          userModify->SetIntValue(NS_STYLE_USER_MODIFY_READ_WRITE,
+                                  eCSSUnit_Enumerated);
         }
         else if (value->Equals(nsGkAtoms::_false, eIgnoreCase)) {
-            ui->mUserModify.SetIntValue(NS_STYLE_USER_MODIFY_READ_ONLY,
-                                        eCSSUnit_Enumerated);
+            userModify->SetIntValue(NS_STYLE_USER_MODIFY_READ_ONLY,
+                                    eCSSUnit_Enumerated);
         }
       }
     }
   }
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Visibility)) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::lang);
     if (value && value->Type() == nsAttrValue::eString) {
-      aData->mDisplayData->mLang.SetStringValue(value->GetStringValue(),
-                                                eCSSUnit_Ident);
+      aData->ValueForLang()->SetStringValue(value->GetStringValue(),
+                                            eCSSUnit_Ident);
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapCommonAttributesInto(const nsMappedAttributes* aAttributes,
                                               nsRuleData* aData)
 {
   nsGenericHTMLElement::MapCommonAttributesExceptHiddenInto(aAttributes, aData);
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) {
-    nsRuleDataDisplay* disp = aData->mDisplayData;
-    if (disp->mDisplay.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* display = aData->ValueForDisplay();
+    if (display->GetUnit() == eCSSUnit_Null) {
       if (aAttributes->IndexOfAttr(nsGkAtoms::hidden, kNameSpaceID_None) >= 0) {
-        disp->mDisplay.SetIntValue(NS_STYLE_DISPLAY_NONE, eCSSUnit_Enumerated);
+        display->SetIntValue(NS_STYLE_DISPLAY_NONE, eCSSUnit_Enumerated);
       }
     }
   }
 }
 
 void
 nsGenericHTMLFormElement::UpdateEditableFormControlState()
 {
@@ -1782,48 +1782,54 @@ void
 nsGenericHTMLElement::MapImageAlignAttributeInto(const nsMappedAttributes* aAttributes,
                                                  nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & (NS_STYLE_INHERIT_BIT(Display) |
                           NS_STYLE_INHERIT_BIT(TextReset))) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
     if (value && value->Type() == nsAttrValue::eEnum) {
       PRInt32 align = value->GetEnumValue();
-      if ((aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) &&
-          aRuleData->mDisplayData->mFloat.GetUnit() == eCSSUnit_Null) {
-        if (align == NS_STYLE_TEXT_ALIGN_LEFT)
-          aRuleData->mDisplayData->mFloat.SetIntValue(NS_STYLE_FLOAT_LEFT, eCSSUnit_Enumerated);
-        else if (align == NS_STYLE_TEXT_ALIGN_RIGHT)
-          aRuleData->mDisplayData->mFloat.SetIntValue(NS_STYLE_FLOAT_RIGHT, eCSSUnit_Enumerated);
+      if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) {
+        nsCSSValue* cssFloat = aRuleData->ValueForCssFloat();
+        if (cssFloat->GetUnit() == eCSSUnit_Null) {
+          if (align == NS_STYLE_TEXT_ALIGN_LEFT) {
+            cssFloat->SetIntValue(NS_STYLE_FLOAT_LEFT, eCSSUnit_Enumerated);
+          } else if (align == NS_STYLE_TEXT_ALIGN_RIGHT) {
+            cssFloat->SetIntValue(NS_STYLE_FLOAT_RIGHT, eCSSUnit_Enumerated);
+          }
+        }
       }
-      if ((aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) &&
-          aRuleData->mTextData->mVerticalAlign.GetUnit() == eCSSUnit_Null) {
-        switch (align) {
-        case NS_STYLE_TEXT_ALIGN_LEFT:
-        case NS_STYLE_TEXT_ALIGN_RIGHT:
-          break;
-        default:
-          aRuleData->mTextData->mVerticalAlign.SetIntValue(align, eCSSUnit_Enumerated);
-          break;
+      if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
+        nsCSSValue* verticalAlign = aRuleData->ValueForVerticalAlign();
+        if (verticalAlign->GetUnit() == eCSSUnit_Null) {
+          switch (align) {
+          case NS_STYLE_TEXT_ALIGN_LEFT:
+          case NS_STYLE_TEXT_ALIGN_RIGHT:
+            break;
+          default:
+            verticalAlign->SetIntValue(align, eCSSUnit_Enumerated);
+            break;
+          }
         }
       }
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapDivAlignAttributeInto(const nsMappedAttributes* aAttributes,
                                                nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
-    if (aRuleData->mTextData->mTextAlign.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* textAlign = aRuleData->ValueForTextAlign();
+    if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aRuleData->mTextData->mTextAlign.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 }
 
 
 void
 nsGenericHTMLElement::MapImageMarginAttributeInto(const nsMappedAttributes* aAttributes,
                                                   nsRuleData* aData)
@@ -1838,66 +1844,70 @@ nsGenericHTMLElement::MapImageMarginAttr
   if (value) {
     nsCSSValue hval;
     if (value->Type() == nsAttrValue::eInteger)
       hval.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     else if (value->Type() == nsAttrValue::ePercent)
       hval.SetPercentValue(value->GetPercentValue());
 
     if (hval.GetUnit() != eCSSUnit_Null) {
-      nsCSSRect& margin = aData->mMarginData->mMargin;
-      if (margin.mLeft.GetUnit() == eCSSUnit_Null)
-        margin.mLeft = hval;
-      if (margin.mRight.GetUnit() == eCSSUnit_Null)
-        margin.mRight = hval;
+      nsCSSValue* left = aData->ValueForMarginLeft();
+      if (left->GetUnit() == eCSSUnit_Null)
+        *left = hval;
+      nsCSSValue* right = aData->ValueForMarginRight();
+      if (right->GetUnit() == eCSSUnit_Null)
+        *right = hval;
     }
   }
 
   // vspace: value
   value = aAttributes->GetAttr(nsGkAtoms::vspace);
   if (value) {
     nsCSSValue vval;
     if (value->Type() == nsAttrValue::eInteger)
       vval.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     else if (value->Type() == nsAttrValue::ePercent)
       vval.SetPercentValue(value->GetPercentValue());
   
     if (vval.GetUnit() != eCSSUnit_Null) {
-      nsCSSRect& margin = aData->mMarginData->mMargin;
-      if (margin.mTop.GetUnit() == eCSSUnit_Null)
-        margin.mTop = vval;
-      if (margin.mBottom.GetUnit() == eCSSUnit_Null)
-        margin.mBottom = vval;
+      nsCSSValue* top = aData->ValueForMarginTop();
+      if (top->GetUnit() == eCSSUnit_Null)
+        *top = vval;
+      nsCSSValue* bottom = aData->ValueForMarginBottom();
+      if (bottom->GetUnit() == eCSSUnit_Null)
+        *bottom = vval;
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapImageSizeAttributesInto(const nsMappedAttributes* aAttributes,
                                                  nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)))
     return;
 
   // width: value
-  if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
+  nsCSSValue* width = aData->ValueForWidth();
+  if (width->GetUnit() == eCSSUnit_Null) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
     if (value && value->Type() == nsAttrValue::eInteger)
-      aData->mPositionData->mWidth.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+      width->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     else if (value && value->Type() == nsAttrValue::ePercent)
-      aData->mPositionData->mWidth.SetPercentValue(value->GetPercentValue());
+      width->SetPercentValue(value->GetPercentValue());
   }
 
   // height: value
-  if (aData->mPositionData->mHeight.GetUnit() == eCSSUnit_Null) {
+  nsCSSValue* height = aData->ValueForHeight();
+  if (height->GetUnit() == eCSSUnit_Null) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::height);
     if (value && value->Type() == nsAttrValue::eInteger)
-      aData->mPositionData->mHeight.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
+      height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
     else if (value && value->Type() == nsAttrValue::ePercent)
-      aData->mPositionData->mHeight.SetPercentValue(value->GetPercentValue());    
+      height->SetPercentValue(value->GetPercentValue());
   }
 }
 
 void
 nsGenericHTMLElement::MapImageBorderAttributeInto(const nsMappedAttributes* aAttributes,
                                                   nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Border)))
@@ -1907,56 +1917,66 @@ nsGenericHTMLElement::MapImageBorderAttr
   const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::border);
   if (!value)
     return;
   
   nscoord val = 0;
   if (value->Type() == nsAttrValue::eInteger)
     val = value->GetIntegerValue();
 
-  nsCSSRect& borderWidth = aData->mMarginData->mBorderWidth;
-  if (borderWidth.mLeft.GetUnit() == eCSSUnit_Null)
-    borderWidth.mLeft.SetFloatValue((float)val, eCSSUnit_Pixel);
-  if (borderWidth.mTop.GetUnit() == eCSSUnit_Null)
-    borderWidth.mTop.SetFloatValue((float)val, eCSSUnit_Pixel);
-  if (borderWidth.mRight.GetUnit() == eCSSUnit_Null)
-    borderWidth.mRight.SetFloatValue((float)val, eCSSUnit_Pixel);
-  if (borderWidth.mBottom.GetUnit() == eCSSUnit_Null)
-    borderWidth.mBottom.SetFloatValue((float)val, eCSSUnit_Pixel);
-
-  nsCSSRect& borderStyle = aData->mMarginData->mBorderStyle;
-  if (borderStyle.mLeft.GetUnit() == eCSSUnit_Null)
-    borderStyle.mLeft.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
-  if (borderStyle.mTop.GetUnit() == eCSSUnit_Null)
-    borderStyle.mTop.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
-  if (borderStyle.mRight.GetUnit() == eCSSUnit_Null)
-    borderStyle.mRight.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
-  if (borderStyle.mBottom.GetUnit() == eCSSUnit_Null)
-    borderStyle.mBottom.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
-
-  nsCSSRect& borderColor = aData->mMarginData->mBorderColor;
-  if (borderColor.mLeft.GetUnit() == eCSSUnit_Null)
-    borderColor.mLeft.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
-  if (borderColor.mTop.GetUnit() == eCSSUnit_Null)
-    borderColor.mTop.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
-  if (borderColor.mRight.GetUnit() == eCSSUnit_Null)
-    borderColor.mRight.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
-  if (borderColor.mBottom.GetUnit() == eCSSUnit_Null)
-    borderColor.mBottom.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
+  nsCSSValue* borderLeftWidth = aData->ValueForBorderLeftWidth();
+  if (borderLeftWidth->GetUnit() == eCSSUnit_Null)
+    borderLeftWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
+  nsCSSValue* borderTopWidth = aData->ValueForBorderTopWidth();
+  if (borderTopWidth->GetUnit() == eCSSUnit_Null)
+    borderTopWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
+  nsCSSValue* borderRightWidth = aData->ValueForBorderRightWidth();
+  if (borderRightWidth->GetUnit() == eCSSUnit_Null)
+    borderRightWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
+  nsCSSValue* borderBottomWidth = aData->ValueForBorderBottomWidth();
+  if (borderBottomWidth->GetUnit() == eCSSUnit_Null)
+    borderBottomWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
+
+  nsCSSValue* borderLeftStyle = aData->ValueForBorderLeftStyle();
+  if (borderLeftStyle->GetUnit() == eCSSUnit_Null)
+    borderLeftStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
+  nsCSSValue* borderTopStyle = aData->ValueForBorderTopStyle();
+  if (borderTopStyle->GetUnit() == eCSSUnit_Null)
+    borderTopStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
+  nsCSSValue* borderRightStyle = aData->ValueForBorderRightStyle();
+  if (borderRightStyle->GetUnit() == eCSSUnit_Null)
+    borderRightStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
+  nsCSSValue* borderBottomStyle = aData->ValueForBorderBottomStyle();
+  if (borderBottomStyle->GetUnit() == eCSSUnit_Null)
+    borderBottomStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
+
+  nsCSSValue* borderLeftColor = aData->ValueForBorderLeftColor();
+  if (borderLeftColor->GetUnit() == eCSSUnit_Null)
+    borderLeftColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
+  nsCSSValue* borderTopColor = aData->ValueForBorderTopColor();
+  if (borderTopColor->GetUnit() == eCSSUnit_Null)
+    borderTopColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
+  nsCSSValue* borderRightColor = aData->ValueForBorderRightColor();
+  if (borderRightColor->GetUnit() == eCSSUnit_Null)
+    borderRightColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
+  nsCSSValue* borderBottomColor = aData->ValueForBorderBottomColor();
+  if (borderBottomColor->GetUnit() == eCSSUnit_Null)
+    borderBottomColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
 }
 
 void
 nsGenericHTMLElement::MapBackgroundInto(const nsMappedAttributes* aAttributes,
                                         nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
     return;
 
   nsPresContext* presContext = aData->mPresContext;
-  if (aData->mColorData->mBackImage.GetUnit() == eCSSUnit_Null &&
+  nsCSSValue* backImage = aData->ValueForBackgroundImage();
+  if (backImage->GetUnit() == eCSSUnit_Null &&
       presContext->UseDocumentColors()) {
     // background
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::background);
     if (value && value->Type() == nsAttrValue::eString) {
       const nsString& spec = value->GetStringValue();
       if (!spec.IsEmpty()) {
         // Resolve url to an absolute url
         // XXX this breaks if the HTML element has an xml:base
@@ -1976,46 +1996,46 @@ nsGenericHTMLElement::MapBackgroundInto(
           if (NS_LIKELY(buffer)) {
             // XXXbz it would be nice to assert that doc->NodePrincipal() is
             // the same as the principal of the node (which we'd need to store
             // in the mapped attrs or something?)
             nsCSSValue::Image *img =
               new nsCSSValue::Image(uri, buffer, doc->GetDocumentURI(),
                                     doc->NodePrincipal(), doc);
             if (NS_LIKELY(img)) {
-              nsCSSValueList* list =
-                aData->mColorData->mBackImage.SetListValue();
+              nsCSSValueList* list = backImage->SetListValue();
               list->mValue.SetImageValue(img);
             }
           }
         }
       }
       else if (presContext->CompatibilityMode() == eCompatibility_NavQuirks) {
         // in NavQuirks mode, allow the empty string to set the
         // background to empty
-        nsCSSValueList* list = aData->mColorData->mBackImage.SetListValue();
+        nsCSSValueList* list = backImage->SetListValue();
         list->mValue.SetNoneValue();
       }
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapBGColorInto(const nsMappedAttributes* aAttributes,
                                      nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
     return;
 
-  if (aData->mColorData->mBackColor.GetUnit() == eCSSUnit_Null &&
+  nsCSSValue* backColor = aData->ValueForBackgroundColor();
+  if (backColor->GetUnit() == eCSSUnit_Null &&
       aData->mPresContext->UseDocumentColors()) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::bgcolor);
     nscolor color;
     if (value && value->GetColorValue(color)) {
-      aData->mColorData->mBackColor.SetColorValue(color);
+      backColor->SetColorValue(color);
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapBackgroundAttributesInto(const nsMappedAttributes* aAttributes,
                                                   nsRuleData* aData)
 {
@@ -2027,18 +2047,18 @@ void
 nsGenericHTMLElement::MapScrollingAttributeInto(const nsMappedAttributes* aAttributes,
                                                 nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)))
     return;
 
   // scrolling
   nsCSSValue* overflowValues[2] = {
-    &aData->mDisplayData->mOverflowX,
-    &aData->mDisplayData->mOverflowY,
+    aData->ValueForOverflowX(),
+    aData->ValueForOverflowY(),
   };
   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(overflowValues); ++i) {
     if (overflowValues[i]->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::scrolling);
       if (value && value->Type() == nsAttrValue::eEnum) {
         PRInt32 mappedValue;
         switch (value->GetEnumValue()) {
           case NS_STYLE_FRAME_ON:
diff --git a/content/html/content/src/nsHTMLBRElement.cpp b/content/html/content/src/nsHTMLBRElement.cpp
--- a/content/html/content/src/nsHTMLBRElement.cpp
+++ b/content/html/content/src/nsHTMLBRElement.cpp
@@ -128,20 +128,21 @@ nsHTMLBRElement::ParseAttribute(PRInt32 
                                               aResult);
 }
 
 static void
 MapAttributesIntoRule(const nsMappedAttributes* aAttributes,
                       nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) {
-    if (aData->mDisplayData->mClear.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* clear = aData->ValueForClear();
+    if (clear->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::clear);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aData->mDisplayData->mClear.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        clear->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
 nsHTMLBRElement::IsAttributeMapped(const nsIAtom* aAttribute) const
diff --git a/content/html/content/src/nsHTMLBodyElement.cpp b/content/html/content/src/nsHTMLBodyElement.cpp
--- a/content/html/content/src/nsHTMLBodyElement.cpp
+++ b/content/html/content/src/nsHTMLBodyElement.cpp
@@ -384,23 +384,24 @@ void MapAttributesIntoRule(const nsMappe
             styleSheet->SetVisitedLinkColor(color);
           }
         }
       }
     }
   }
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Color)) {
-    if (aData->mColorData->mColor.GetUnit() == eCSSUnit_Null &&
+    nsCSSValue *color = aData->ValueForColor();
+    if (color->GetUnit() == eCSSUnit_Null &&
         aData->mPresContext->UseDocumentColors()) {
       // color: color
       nscolor color;
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::text);
       if (value && value->GetColorValue(color))
-        aData->mColorData->mColor.SetColorValue(color);
+        color->SetColorValue(color);
     }
   }
 
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 nsMapRuleToAttributesFunc
diff --git a/content/html/content/src/nsHTMLFontElement.cpp b/content/html/content/src/nsHTMLFontElement.cpp
--- a/content/html/content/src/nsHTMLFontElement.cpp
+++ b/content/html/content/src/nsHTMLFontElement.cpp
@@ -181,82 +181,84 @@ nsHTMLFontElement::ParseAttribute(PRInt3
                                               aResult);
 }
 
 static void
 MapAttributesIntoRule(const nsMappedAttributes* aAttributes,
                       nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Font)) {
-    nsRuleDataFont& font = *(aData->mFontData);
-    
     // face: string list
-    if (font.mFamily.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* family = aData->ValueForFontFamily();
+    if (family->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::face);
       if (value && value->Type() == nsAttrValue::eString &&
           !value->IsEmptyString()) {
-        font.mFamily.SetStringValue(value->GetStringValue(), eCSSUnit_Families);
+        family->SetStringValue(value->GetStringValue(), eCSSUnit_Families);
       }
     }
 
     // pointSize: int
-    if (font.mSize.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* fontSize = aData->ValueForFontSize();
+    if (fontSize->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::pointSize);
       if (value && value->Type() == nsAttrValue::eInteger)
-        font.mSize.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Point);
+        fontSize->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Point);
       else {
         // size: int, enum , 
         value = aAttributes->GetAttr(nsGkAtoms::size);
         if (value) {
           nsAttrValue::ValueType unit = value->Type();
           if (unit == nsAttrValue::eInteger || unit == nsAttrValue::eEnum) { 
             PRInt32 size;
             if (unit == nsAttrValue::eEnum) // int (+/-)
               size = value->GetEnumValue() + 3;
             else
               size = value->GetIntegerValue();
 
             size = ((0 < size) ? ((size < 8) ? size : 7) : 1); 
-            font.mSize.SetIntValue(size, eCSSUnit_Enumerated);
+            fontSize->SetIntValue(size, eCSSUnit_Enumerated);
           }
         }
       }
     }
 
     // fontWeight: int
-    if (font.mWeight.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* weight = aData->ValueForFontWeight();
+    if (fontWeight->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::fontWeight);
       if (value && value->Type() == nsAttrValue::eInteger) // +/-
-        font.mWeight.SetIntValue(value->GetIntegerValue(), eCSSUnit_Integer);
+        fontWeight->SetIntValue(value->GetIntegerValue(), eCSSUnit_Integer);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Color)) {
-    if (aData->mColorData->mColor.GetUnit() == eCSSUnit_Null &&
+    nsCSSValue* color = aData->ValueForColor();
+    if (color->GetUnit() == eCSSUnit_Null &&
         aData->mPresContext->UseDocumentColors()) {
       // color: color
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::color);
       nscolor color;
       if (value && value->GetColorValue(color)) {
-        aData->mColorData->mColor.SetColorValue(color);
+        color->SetColorValue(color);
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
     // Make <a><font color="red">text</font></a> give the text a red underline
     // in quirks mode.  The NS_STYLE_TEXT_DECORATION_OVERRIDE_ALL flag only
     // affects quirks mode rendering.
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::color);
     nscolor color;
     if (value && value->GetColorValue(color)) {
-      nsCSSValue& decoration = aData->mTextData->mDecoration;
+      nsCSSValue* decoration = aData->ValueForTextDecoration();
       PRInt32 newValue = NS_STYLE_TEXT_DECORATION_OVERRIDE_ALL;
-      if (decoration.GetUnit() == eCSSUnit_Enumerated) {
-        newValue |= decoration.GetIntValue();
+      if (decoration->GetUnit() == eCSSUnit_Enumerated) {
+        newValue |= decoration->GetIntValue();
       }
-      decoration.SetIntValue(newValue, eCSSUnit_Enumerated);
+      decoration->SetIntValue(newValue, eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
 nsHTMLFontElement::IsAttributeMapped(const nsIAtom* aAttribute) const
diff --git a/content/html/content/src/nsHTMLHRElement.cpp b/content/html/content/src/nsHTMLHRElement.cpp
--- a/content/html/content/src/nsHTMLHRElement.cpp
+++ b/content/html/content/src/nsHTMLHRElement.cpp
@@ -170,63 +170,66 @@ MapAttributesIntoRule(const nsMappedAttr
     }
   }
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Margin)) {
     // align: enum
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
     if (value && value->Type() == nsAttrValue::eEnum) {
       // Map align attribute into auto side margins
-      nsCSSRect& margin = aData->mMarginData->mMargin;
+      nsCSSValue* marginLeft = aData->ValueForMarginLeft();
+      nsCSSValue* marginRight = aData->ValueForMarginRight();
       switch (value->GetEnumValue()) {
       case NS_STYLE_TEXT_ALIGN_LEFT:
-        if (margin.mLeft.GetUnit() == eCSSUnit_Null)
-          margin.mLeft.SetFloatValue(0.0f, eCSSUnit_Pixel);
-        if (margin.mRight.GetUnit() == eCSSUnit_Null)
-          margin.mRight.SetAutoValue();
+        if (marginLeft->GetUnit() == eCSSUnit_Null)
+          marginLeft->SetFloatValue(0.0f, eCSSUnit_Pixel);
+        if (marginRight->GetUnit() == eCSSUnit_Null)
+          marginRight->SetAutoValue();
         break;
       case NS_STYLE_TEXT_ALIGN_RIGHT:
-        if (margin.mLeft.GetUnit() == eCSSUnit_Null)
-          margin.mLeft.SetAutoValue();
-        if (margin.mRight.GetUnit() == eCSSUnit_Null)
-          margin.mRight.SetFloatValue(0.0f, eCSSUnit_Pixel);
+        if (marginLeft->GetUnit() == eCSSUnit_Null)
+          marginLeft->SetAutoValue();
+        if (marginRight->GetUnit() == eCSSUnit_Null)
+          marginRight->SetFloatValue(0.0f, eCSSUnit_Pixel);
         break;
       case NS_STYLE_TEXT_ALIGN_CENTER:
-        if (margin.mLeft.GetUnit() == eCSSUnit_Null)
-          margin.mLeft.SetAutoValue();
-        if (margin.mRight.GetUnit() == eCSSUnit_Null)
-          margin.mRight.SetAutoValue();
+        if (marginLeft->GetUnit() == eCSSUnit_Null)
+          marginLeft->SetAutoValue();
+        if (marginRight->GetUnit() == eCSSUnit_Null)
+          marginRight->SetAutoValue();
         break;
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)) {
     // width: integer, percent
-    if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* width = aData->ValueForWidth();
+    if (width->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
       if (value && value->Type() == nsAttrValue::eInteger) {
-        aData->mPositionData->mWidth.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+        width->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
       } else if (value && value->Type() == nsAttrValue::ePercent) {
-        aData->mPositionData->mWidth.SetPercentValue(value->GetPercentValue());
+        width->SetPercentValue(value->GetPercentValue());
       }
     }
 
-    if (aData->mPositionData->mHeight.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* height = aData->ValueForHeight();
+    if (height->GetUnit() == eCSSUnit_Null) {
       // size: integer
       if (noshade) {
         // noshade case: size is set using the border
-        aData->mPositionData->mHeight.SetAutoValue();
+        height->SetAutoValue();
       } else {
         // normal case
         // the height includes the top and bottom borders that are initially 1px.
         // for size=1, html.css has a special case rule that makes this work by
         // removing all but the top border.
         const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::size);
         if (value && value->Type() == nsAttrValue::eInteger) {
-          aData->mPositionData->mHeight.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+          height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
         } // else use default value from html.css
       }
     }
   }
   if ((aData->mSIDs & NS_STYLE_INHERIT_BIT(Border)) && noshade) { // if not noshade, border styles are dealt with by html.css
     // size: integer
     // if a size is set, use half of it per side, otherwise, use 1px per side
     float sizePerSide;
@@ -239,72 +242,80 @@ MapAttributesIntoRule(const nsMappedAttr
         // subpixel borders should be removed.
         // In the meantime, this makes http://www.microsoft.com/ look right.
         sizePerSide = 1.0f;
         allSides = PR_FALSE;
       }
     } else {
       sizePerSide = 1.0f; // default to a 2px high line
     }
-    nsCSSRect& borderWidth = aData->mMarginData->mBorderWidth;
-    if (borderWidth.mTop.GetUnit() == eCSSUnit_Null) {
-      borderWidth.mTop.SetFloatValue(sizePerSide, eCSSUnit_Pixel);
+    nsCSSValue* borderTopWidth = aData->ValueForBorderTopWidth();
+    if (borderTopWidth->GetUnit() == eCSSUnit_Null) {
+      borderTopWidth->SetFloatValue(sizePerSide, eCSSUnit_Pixel);
     }
     if (allSides) {
-      if (borderWidth.mRight.GetUnit() == eCSSUnit_Null) {
-        borderWidth.mRight.SetFloatValue(sizePerSide, eCSSUnit_Pixel);
+      nsCSSValue* borderRightWidth = aData->ValueForBorderRightWidth();
+      if (borderRightWidth->GetUnit() == eCSSUnit_Null) {
+        borderRightWidth->SetFloatValue(sizePerSide, eCSSUnit_Pixel);
       }
-      if (borderWidth.mBottom.GetUnit() == eCSSUnit_Null) {
-        borderWidth.mBottom.SetFloatValue(sizePerSide, eCSSUnit_Pixel);
+      nsCSSValue* borderBottomWidth = aData->ValueForBorderBottomWidth();
+      if (borderBottomWidth->GetUnit() == eCSSUnit_Null) {
+        borderBottomWidth->SetFloatValue(sizePerSide, eCSSUnit_Pixel);
       }
-      if (borderWidth.mLeft.GetUnit() == eCSSUnit_Null) {
-        borderWidth.mLeft.SetFloatValue(sizePerSide, eCSSUnit_Pixel);
+      nsCSSValue* borderLeftWidth = aData->ValueForBorderLeftWidth();
+      if (borderLeftWidth->GetUnit() == eCSSUnit_Null) {
+        borderLeftWidth->SetFloatValue(sizePerSide, eCSSUnit_Pixel);
       }
     }
 
-    nsCSSRect& borderStyle = aData->mMarginData->mBorderStyle;
-    if (borderStyle.mTop.GetUnit() == eCSSUnit_Null) {
-      borderStyle.mTop.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
-                                   eCSSUnit_Enumerated);
+    nsCSSValue* borderTopStyle = aData->ValueForBorderTopStyle();
+    if (borderTopStyle->GetUnit() == eCSSUnit_Null) {
+      borderTopStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
+                                  eCSSUnit_Enumerated);
     }
     if (allSides) {
-      if (borderStyle.mRight.GetUnit() == eCSSUnit_Null) {
-        borderStyle.mRight.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
+      nsCSSValue* borderRightStyle = aData->ValueForBorderRightStyle();
+      if (borderRightStyle->GetUnit() == eCSSUnit_Null) {
+        borderRightStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
+                                      eCSSUnit_Enumerated);
+      }
+      nsCSSValue* borderBottomStyle = aData->ValueForBorderBottomStyle();
+      if (borderBottomStyle->GetUnit() == eCSSUnit_Null) {
+        borderBottomStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
                                        eCSSUnit_Enumerated);
       }
-      if (borderStyle.mBottom.GetUnit() == eCSSUnit_Null) {
-        borderStyle.mBottom.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
-                                        eCSSUnit_Enumerated);
-      }
-      if (borderStyle.mLeft.GetUnit() == eCSSUnit_Null) {
-        borderStyle.mLeft.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
-                                      eCSSUnit_Enumerated);
+      nsCSSValue* borderLeftStyle = aData->ValueForBorderLeftStyle();
+      if (borderLeftStyle->GetUnit() == eCSSUnit_Null) {
+        borderLeftStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
+                                     eCSSUnit_Enumerated);
       }
 
       // If it would be noticeable, set the border radius to
       // 10000px on all corners; this triggers the clamping to make
       // circular ends.  This assumes the <hr> isn't larger than
       // that in *both* dimensions.
+      // FIXME!!!
       nsCSSCornerSizes& corners = aData->mMarginData->mBorderRadius;
 
       NS_FOR_CSS_FULL_CORNERS(c) {
         nsCSSValue& dimen = corners.GetCorner(c);
         if (dimen.GetUnit() == eCSSUnit_Null) {
           dimen.SetFloatValue(10000.0f, eCSSUnit_Pixel);
         }
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Color)) {
     // color: a color
     // (we got the color attribute earlier)
+    nsCSSValue* color = aData->ValueForColor();
     if (colorIsSet &&
-        aData->mColorData->mColor.GetUnit() == eCSSUnit_Null &&
+        color->GetUnit() == eCSSUnit_Null &&
         aData->mPresContext->UseDocumentColors()) {
-      aData->mColorData->mColor.SetColorValue(color);
+      color->SetColorValue(color);
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
 nsHTMLHRElement::IsAttributeMapped(const nsIAtom* aAttribute) const
diff --git a/content/html/content/src/nsHTMLIFrameElement.cpp b/content/html/content/src/nsHTMLIFrameElement.cpp
--- a/content/html/content/src/nsHTMLIFrameElement.cpp
+++ b/content/html/content/src/nsHTMLIFrameElement.cpp
@@ -197,44 +197,50 @@ MapAttributesIntoRule(const nsMappedAttr
     // If frameborder is 0 or No, set border to 0
     // else leave it as the value set in html.css
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::frameborder);
     if (value && value->Type() == nsAttrValue::eEnum) {
       PRInt32 frameborder = value->GetEnumValue();
       if (NS_STYLE_FRAME_0 == frameborder ||
           NS_STYLE_FRAME_NO == frameborder ||
           NS_STYLE_FRAME_OFF == frameborder) {
-        if (aData->mMarginData->mBorderWidth.mLeft.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderWidth.mLeft.SetFloatValue(0.0f, eCSSUnit_Pixel);
-        if (aData->mMarginData->mBorderWidth.mRight.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderWidth.mRight.SetFloatValue(0.0f, eCSSUnit_Pixel);
-        if (aData->mMarginData->mBorderWidth.mTop.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderWidth.mTop.SetFloatValue(0.0f, eCSSUnit_Pixel);
-        if (aData->mMarginData->mBorderWidth.mBottom.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderWidth.mBottom.SetFloatValue(0.0f, eCSSUnit_Pixel);
+        nsCSSValue* borderLeftWidth = aData->ValueForBorderLeftWidth();
+        if (borderLeftWidth->GetUnit() == eCSSUnit_Null)
+          borderLeftWidth->SetFloatValue(0.0f, eCSSUnit_Pixel);
+        nsCSSValue* borderRightWidth = aData->ValueForBorderRightWidth();
+        if (borderRightWidth->GetUnit() == eCSSUnit_Null)
+          borderRightWidth->SetFloatValue(0.0f, eCSSUnit_Pixel);
+        nsCSSValue* borderTopWidth = aData->ValueForBorderTopWidth();
+        if (borderTopWidth->GetUnit() == eCSSUnit_Null)
+          borderTopWidth->SetFloatValue(0.0f, eCSSUnit_Pixel);
+        nsCSSValue* borderBottomWidth = aData->ValueForBorderBottomWidth();
+        if (borderBottomWidth->GetUnit() == eCSSUnit_Null)
+          borderBottomWidth->SetFloatValue(0.0f, eCSSUnit_Pixel);
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)) {
     // width: value
-    if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* width = aData->ValueForWidth();
+    if (width->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
       if (value && value->Type() == nsAttrValue::eInteger)
-        aData->mPositionData->mWidth.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+        width->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
       else if (value && value->Type() == nsAttrValue::ePercent)
-        aData->mPositionData->mWidth.SetPercentValue(value->GetPercentValue());
+        width->SetPercentValue(value->GetPercentValue());
     }
 
     // height: value
-    if (aData->mPositionData->mHeight.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* height = aData->ValueForHeight();
+    if (height->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::height);
       if (value && value->Type() == nsAttrValue::eInteger)
-        aData->mPositionData->mHeight.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+        height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
       else if (value && value->Type() == nsAttrValue::ePercent)
-        aData->mPositionData->mHeight.SetPercentValue(value->GetPercentValue());
+        height->SetPercentValue(value->GetPercentValue());
     }
   }
 
   nsGenericHTMLElement::MapScrollingAttributeInto(aAttributes, aData);
   nsGenericHTMLElement::MapImageAlignAttributeInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
diff --git a/content/html/content/src/nsHTMLLIElement.cpp b/content/html/content/src/nsHTMLLIElement.cpp
--- a/content/html/content/src/nsHTMLLIElement.cpp
+++ b/content/html/content/src/nsHTMLLIElement.cpp
@@ -147,21 +147,22 @@ nsHTMLLIElement::ParseAttribute(PRInt32 
                                               aResult);
 }
 
 static void
 MapAttributesIntoRule(const nsMappedAttributes* aAttributes,
                       nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(List)) {
-    if (aData->mListData->mType.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* listStyleType = aData->ValueForListStyleType();
+    if (listStyleType->GetUnit() == eCSSUnit_Null) {
       // type: enum
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::type);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aData->mListData->mType.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        listStyleType->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
 nsHTMLLIElement::IsAttributeMapped(const nsIAtom* aAttribute) const
diff --git a/content/html/content/src/nsHTMLOListElement.cpp b/content/html/content/src/nsHTMLOListElement.cpp
--- a/content/html/content/src/nsHTMLOListElement.cpp
+++ b/content/html/content/src/nsHTMLOListElement.cpp
@@ -194,24 +194,25 @@ nsHTMLSharedListElement::ParseAttribute(
   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
                                               aResult);
 }
 
 static void
 MapAttributesIntoRule(const nsMappedAttributes* aAttributes, nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(List)) {
-    if (aData->mListData->mType.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* listStyleType = aData->ValueForListStyleType();
+    if (listStyleType->GetUnit() == eCSSUnit_Null) {
       // type: enum
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::type);
       if (value) {
         if (value->Type() == nsAttrValue::eEnum)
-          aData->mListData->mType.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+          listStyleType->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
         else
-          aData->mListData->mType.SetIntValue(NS_STYLE_LIST_STYLE_DECIMAL, eCSSUnit_Enumerated);
+          listStyleType->SetIntValue(NS_STYLE_LIST_STYLE_DECIMAL, eCSSUnit_Enumerated);
       }
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
diff --git a/content/html/content/src/nsHTMLPreElement.cpp b/content/html/content/src/nsHTMLPreElement.cpp
--- a/content/html/content/src/nsHTMLPreElement.cpp
+++ b/content/html/content/src/nsHTMLPreElement.cpp
@@ -135,52 +135,54 @@ nsHTMLPreElement::ParseAttribute(PRInt32
 }
 
 static void
 MapAttributesIntoRule(const nsMappedAttributes* aAttributes,
                       nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Font)) {
     // variable
+    nsCSSValue* family = aData->ValueForFontFamily();
     if (aAttributes->GetAttr(nsGkAtoms::variable) &&
-        aData->mFontData->mFamily.GetUnit() == eCSSUnit_Null) {
-      aData->mFontData->mFamily.SetStringValue(NS_LITERAL_STRING("serif"),
-                                               eCSSUnit_Families);
+        family->GetUnit() == eCSSUnit_Null) {
+      family->SetStringValue(NS_LITERAL_STRING("serif"), eCSSUnit_Families);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)) {
-    if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* width = aData->ValueForWidth();
+    if (width->GetUnit() == eCSSUnit_Null) {
       // width: int (html4 attribute == nav4 cols)
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
       if (!value || value->Type() != nsAttrValue::eInteger) {
         // cols: int (nav4 attribute)
         value = aAttributes->GetAttr(nsGkAtoms::cols);
       }
 
       if (value && value->Type() == nsAttrValue::eInteger)
-        aData->mPositionData->mWidth.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Char);
+        width->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Char);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
-    if (aData->mTextData->mWhiteSpace.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* whiteSpace = aData->ValueForWhiteSpace();
+    if (whiteSpace->GetUnit() == eCSSUnit_Null) {
       // wrap: empty
       if (aAttributes->GetAttr(nsGkAtoms::wrap))
-        aData->mTextData->mWhiteSpace.SetIntValue(NS_STYLE_WHITESPACE_PRE_WRAP, eCSSUnit_Enumerated);
+        whiteSpace->SetIntValue(NS_STYLE_WHITESPACE_PRE_WRAP, eCSSUnit_Enumerated);
 
       // width: int (html4 attribute == nav4 cols)
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
       if (!value || value->Type() != nsAttrValue::eInteger) {
         // cols: int (nav4 attribute)
         value = aAttributes->GetAttr(nsGkAtoms::cols);
       }
 
       if (value && value->Type() == nsAttrValue::eInteger) {
         // Force wrap property on since we want to wrap at a width
         // boundary not just a newline.
-        aData->mTextData->mWhiteSpace.SetIntValue(NS_STYLE_WHITESPACE_PRE_WRAP, eCSSUnit_Enumerated);
+        whiteSpace->SetIntValue(NS_STYLE_WHITESPACE_PRE_WRAP, eCSSUnit_Enumerated);
       }
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
diff --git a/content/html/content/src/nsHTMLSharedElement.cpp b/content/html/content/src/nsHTMLSharedElement.cpp
--- a/content/html/content/src/nsHTMLSharedElement.cpp
+++ b/content/html/content/src/nsHTMLSharedElement.cpp
@@ -335,24 +335,25 @@ nsHTMLSharedElement::ParseAttribute(PRIn
                                               aResult);
 }
 
 static void
 DirectoryMenuMapAttributesIntoRule(const nsMappedAttributes* aAttributes,
                                nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(List)) {
-    if (aData->mListData->mType.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* listStyleType = aData->ValueForListStyleType();
+    if (listStyleType->GetUnit() == eCSSUnit_Null) {
       // type: enum
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::type);
       if (value) {
         if (value->Type() == nsAttrValue::eEnum) {
-          aData->mListData->mType.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+          listStyleType->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
         } else {
-          aData->mListData->mType.SetIntValue(NS_STYLE_LIST_STYLE_DISC, eCSSUnit_Enumerated);
+          listStyleType->SetIntValue(NS_STYLE_LIST_STYLE_DISC, eCSSUnit_Enumerated);
         }
       }
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
diff --git a/content/html/content/src/nsHTMLTableCaptionElement.cpp b/content/html/content/src/nsHTMLTableCaptionElement.cpp
--- a/content/html/content/src/nsHTMLTableCaptionElement.cpp
+++ b/content/html/content/src/nsHTMLTableCaptionElement.cpp
@@ -132,20 +132,21 @@ nsHTMLTableCaptionElement::ParseAttribut
   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
                                               aResult);
 }
 
 static 
 void MapAttributesIntoRule(const nsMappedAttributes* aAttributes, nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TableBorder)) {
-    if (aData->mTableData->mCaptionSide.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* captionSide = aData->ValueForCaptionSide();
+    if (captionSide->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aData->mTableData->mCaptionSide.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        captionSide->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
 nsHTMLTableCaptionElement::IsAttributeMapped(const nsIAtom* aAttribute) const
diff --git a/content/html/content/src/nsHTMLTableCellElement.cpp b/content/html/content/src/nsHTMLTableCellElement.cpp
--- a/content/html/content/src/nsHTMLTableCellElement.cpp
+++ b/content/html/content/src/nsHTMLTableCellElement.cpp
@@ -388,58 +388,60 @@ nsHTMLTableCellElement::ParseAttribute(P
 }
 
 static 
 void MapAttributesIntoRule(const nsMappedAttributes* aAttributes,
                            nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)) {
     // width: value
-    if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* width = aData->ValueForWidth();
+    if (width->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
       if (value && value->Type() == nsAttrValue::eInteger) {
         if (value->GetIntegerValue() > 0)
-          aData->mPositionData->mWidth.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
+          width->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
         // else 0 implies auto for compatibility.
       }
       else if (value && value->Type() == nsAttrValue::ePercent) {
         if (value->GetPercentValue() > 0.0f)
-          aData->mPositionData->mWidth.SetPercentValue(value->GetPercentValue());
+          width->SetPercentValue(value->GetPercentValue());
         // else 0 implies auto for compatibility
       }
     }
 
     // height: value
-    if (aData->mPositionData->mHeight.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* height = aData->ValueForHeight();
+    if (height->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::height);
       if (value && value->Type() == nsAttrValue::eInteger) {
         if (value->GetIntegerValue() > 0)
-          aData->mPositionData->mHeight.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+          height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
         // else 0 implies auto for compatibility.
       }
       else if (value && value->Type() == nsAttrValue::ePercent) {
         if (value->GetPercentValue() > 0.0f)
-          aData->mPositionData->mHeight.SetPercentValue(value->GetPercentValue());
+          height->SetPercentValue(value->GetPercentValue());
         // else 0 implies auto for compatibility
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
-    if (aData->mTextData->mWhiteSpace.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* whiteSpace = aData->ValueForWhiteSpace();
+    if (whiteSpace->GetUnit() == eCSSUnit_Null) {
       // nowrap: enum
       if (aAttributes->GetAttr(nsGkAtoms::nowrap)) {
         // See if our width is not a nonzero integer width.
         const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
         nsCompatibility mode = aData->mPresContext->CompatibilityMode();
         if (!value || value->Type() != nsAttrValue::eInteger ||
             value->GetIntegerValue() == 0 ||
             eCompatibility_NavQuirks != mode) {
-          aData->mTextData->mWhiteSpace.SetIntValue(NS_STYLE_WHITESPACE_NOWRAP, eCSSUnit_Enumerated);
+          whiteSpace->SetIntValue(NS_STYLE_WHITESPACE_NOWRAP, eCSSUnit_Enumerated);
         }
-        
       }
     }
   }
   
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
@@ -478,29 +480,31 @@ nsHTMLTableCellElement::GetAttributeMapp
   return &MapAttributesIntoRule;
 }
 
 static void
 MapInheritedTableAttributesIntoRule(const nsMappedAttributes* aAttributes,
                                     nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
-    if (aData->mTextData->mTextAlign.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* textAlign = aData->ValueForTextAlign();
+    if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aData->mTextData->mTextAlign.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
-    if (aData->mTextData->mVerticalAlign.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
+    if (verticalAlign->GetUnit() == eCSSUnit_Null) {
       // valign: enum
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aData->mTextData->mVerticalAlign.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 }
 
 #define INHERIT_ELEMENTS (6)
 
 /* static */ const nsAttrValue*
 nsHTMLTableCellElement::FindInheritedAttr(nsIAtom *aAttribute,
diff --git a/content/html/content/src/nsHTMLTableColElement.cpp b/content/html/content/src/nsHTMLTableColElement.cpp
--- a/content/html/content/src/nsHTMLTableColElement.cpp
+++ b/content/html/content/src/nsHTMLTableColElement.cpp
@@ -151,68 +151,73 @@ nsHTMLTableColElement::ParseAttribute(PR
 
   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
                                               aResult);
 }
 
 static 
 void MapAttributesIntoRule(const nsMappedAttributes* aAttributes, nsRuleData* aData)
 {
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Table) && 
-      aData->mTableData->mSpan.GetUnit() == eCSSUnit_Null) {
-    // span: int
-    const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::span);
-    if (value && value->Type() == nsAttrValue::eInteger) {
-      PRInt32 val = value->GetIntegerValue();
-      // Note: Do NOT use this code for table cells!  The value "0"
-      // means something special for colspan and rowspan, but for <col
-      // span> and <colgroup span> it's just disallowed.
-      if (val > 0) {
-        aData->mTableData->mSpan.SetIntValue(value->GetIntegerValue(),
-                                             eCSSUnit_Integer);
+  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Table)) {
+    nsCSSValue *span = aData->ValueForSpan();
+    if (span->GetUnit() == eCSSUnit_Null) {
+      // span: int
+      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::span);
+      if (value && value->Type() == nsAttrValue::eInteger) {
+        PRInt32 val = value->GetIntegerValue();
+        // Note: Do NOT use this code for table cells!  The value "0"
+        // means something special for colspan and rowspan, but for <col
+        // span> and <colgroup span> it's just disallowed.
+        if (val > 0) {
+          span->SetIntValue(value->GetIntegerValue(), eCSSUnit_Integer);
+        }
       }
     }
   }
-  if ((aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)) &&
-      aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
-    // width
-    const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
-    if (value) {
-      switch (value->Type()) {
-      case nsAttrValue::ePercent: {
-        aData->mPositionData->mWidth.SetPercentValue(value->GetPercentValue());
-        break;
-      }
-      case nsAttrValue::eInteger: {
-        aData->mPositionData->mWidth.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
-        break;
-      }
-      default:
-        break;
+  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)) {
+    nsCSSValue* width = aData->ValueForWidth();
+    if (width->GetUnit() == eCSSUnit_Null) {
+      // width
+      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
+      if (value) {
+        switch (value->Type()) {
+        case nsAttrValue::ePercent: {
+          width->SetPercentValue(value->GetPercentValue());
+          break;
+        }
+        case nsAttrValue::eInteger: {
+          width->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+          break;
+        }
+        default:
+          break;
+        }
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
-    if (aData->mTextData->mTextAlign.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* textAlign = aData->ValueForTextAlign();
+    if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
       // XXX Should we be doing this only for computed style now that
       // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aData->mTextData->mTextAlign.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
-    if (aData->mTextData->mVerticalAlign.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
+    if (verticalAlign->GetUnit() == eCSSUnit_Null) {
       // valign: enum
       // XXX Should we be doing this only for computed style now that
       // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aData->mTextData->mVerticalAlign.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
 nsHTMLTableColElement::IsAttributeMapped(const nsIAtom* aAttribute) const
diff --git a/content/html/content/src/nsHTMLTableElement.cpp b/content/html/content/src/nsHTMLTableElement.cpp
--- a/content/html/content/src/nsHTMLTableElement.cpp
+++ b/content/html/content/src/nsHTMLTableElement.cpp
@@ -1064,92 +1064,98 @@ MapAttributesIntoRule(const nsMappedAttr
   nsPresContext* presContext = aData->mPresContext;
   nsCompatibility mode = presContext->CompatibilityMode();
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TableBorder)) {
     const nsStyleDisplay* readDisplay = aData->mStyleContext->GetStyleDisplay();
     if (readDisplay->mDisplay != NS_STYLE_DISPLAY_TABLE_CELL) {
       // cellspacing
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::cellspacing);
+      nsCSSValue* borderSpacing = aData->ValueForBorderSpacing();
       if (value && value->Type() == nsAttrValue::eInteger) {
-        if (aData->mTableData->mBorderSpacing.GetUnit() == eCSSUnit_Null)
-          aData->mTableData->mBorderSpacing.
+        if (borderSpacing->GetUnit() == eCSSUnit_Null)
+          borderSpacing->
             SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
       }
       else if (value && value->Type() == nsAttrValue::ePercent &&
                eCompatibility_NavQuirks == mode) {
         // in quirks mode, treat a % cellspacing value a pixel value.
-        if (aData->mTableData->mBorderSpacing.GetUnit() == eCSSUnit_Null)
-          aData->mTableData->mBorderSpacing.
+        if (borderSpacing->GetUnit() == eCSSUnit_Null)
+          borderSpacing->
             SetFloatValue(100.0f * value->GetPercentValue(), eCSSUnit_Pixel);
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Table)) {
     const nsStyleDisplay* readDisplay = aData->mStyleContext->GetStyleDisplay();
     if (readDisplay->mDisplay != NS_STYLE_DISPLAY_TABLE_CELL) {
       const nsAttrValue* value;
       // layout
-      if (aData->mTableData->mLayout.GetUnit() == eCSSUnit_Null) {
+      nsCSSValue* tableLayout = aData->ValueForTableLayout();
+      if (tableLayout->GetUnit() == eCSSUnit_Null) {
         value = aAttributes->GetAttr(nsGkAtoms::layout);
         if (value && value->Type() == nsAttrValue::eEnum)
-          aData->mTableData->mLayout.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+          tableLayout->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
       }
       
       // cols
       value = aAttributes->GetAttr(nsGkAtoms::cols);
       if (value) {
+        nsCSSValue* cols = aData->ValueForCols();
         if (value->Type() == nsAttrValue::eInteger) 
-          aData->mTableData->mCols.SetIntValue(value->GetIntegerValue(), eCSSUnit_Integer);
+          cols->SetIntValue(value->GetIntegerValue(), eCSSUnit_Integer);
         else // COLS had no value, so it refers to all columns
-          aData->mTableData->mCols.SetIntValue(NS_STYLE_TABLE_COLS_ALL, eCSSUnit_Enumerated);
+          cols->SetIntValue(NS_STYLE_TABLE_COLS_ALL, eCSSUnit_Enumerated);
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Margin)) {
     const nsStyleDisplay* readDisplay = aData->mStyleContext->GetStyleDisplay();
   
     if (readDisplay->mDisplay != NS_STYLE_DISPLAY_TABLE_CELL) {
       // align; Check for enumerated type (it may be another type if
       // illegal)
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
 
       if (value && value->Type() == nsAttrValue::eEnum) {
         if (value->GetEnumValue() == NS_STYLE_TEXT_ALIGN_CENTER ||
             value->GetEnumValue() == NS_STYLE_TEXT_ALIGN_MOZ_CENTER) {
-          nsCSSRect& margin = aData->mMarginData->mMargin;
-          if (margin.mLeft.GetUnit() == eCSSUnit_Null)
-            margin.mLeft.SetAutoValue();
-          if (margin.mRight.GetUnit() == eCSSUnit_Null)
-            margin.mRight.SetAutoValue();
+          nsCSSValue* marginLeft = aData->ValueForMarginLeft();
+          if (marginLeft->GetUnit() == eCSSUnit_Null)
+            marginLeft->SetAutoValue();
+          nsCSSValue* marginRight = aData->ValueForMarginRight();
+          if (marginRight->GetUnit() == eCSSUnit_Null)
+            marginRight->SetAutoValue();
         }
       }
 
       // hspace is mapped into left and right margin, 
       // vspace is mapped into top and bottom margins
       // - *** Quirks Mode only ***
       if (eCompatibility_NavQuirks == mode) {
         value = aAttributes->GetAttr(nsGkAtoms::hspace);
 
         if (value && value->Type() == nsAttrValue::eInteger) {
-          nsCSSRect& margin = aData->mMarginData->mMargin;
-          if (margin.mLeft.GetUnit() == eCSSUnit_Null)
-            margin.mLeft.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
-          if (margin.mRight.GetUnit() == eCSSUnit_Null)
-            margin.mRight.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+          nsCSSValue* marginLeft = aData->ValueForMarginLeft();
+          if (marginLeft->GetUnit() == eCSSUnit_Null)
+            marginLeft->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
+          nsCSSValue* marginRight = aData->ValueForMarginRight();
+          if (marginRight->GetUnit() == eCSSUnit_Null)
+            marginRight->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
         }
 
         value = aAttributes->GetAttr(nsGkAtoms::vspace);
 
         if (value && value->Type() == nsAttrValue::eInteger) {
-          nsCSSRect& margin = aData->mMarginData->mMargin;
-          if (margin.mTop.GetUnit() == eCSSUnit_Null)
-            margin.mTop.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
-          if (margin.mBottom.GetUnit() == eCSSUnit_Null)
-            margin.mBottom.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
+          nsCSSValue* marginTop = aData->ValueForMarginTop();
+          if (marginTop->GetUnit() == eCSSUnit_Null)
+            marginTop->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
+          nsCSSValue* marginBottom = aData->ValueForMarginBottom();
+          if (marginBottom->GetUnit() == eCSSUnit_Null)
+            marginBottom->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
         }
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Padding)) {
     const nsStyleDisplay* readDisplay = aData->mStyleContext->GetStyleDisplay();
     if (readDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE_CELL) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::cellpadding);
@@ -1167,48 +1173,54 @@ MapAttributesIntoRule(const nsMappedAttr
             //if (eCompatibility_NavQuirks == mode) {
               // in quirks mode treat a pct cellpadding value as a pixel value
               padVal.SetFloatValue(100.0f * pctVal, eCSSUnit_Pixel);
             //}
             //else {
             //  padVal.SetPercentValue(pctVal);
             //}
           }
-          if (aData->mMarginData->mPadding.mLeft.GetUnit() == eCSSUnit_Null)
-            aData->mMarginData->mPadding.mLeft = padVal;
-          if (aData->mMarginData->mPadding.mRight.GetUnit() == eCSSUnit_Null)
-            aData->mMarginData->mPadding.mRight = padVal;
-          if (aData->mMarginData->mPadding.mTop.GetUnit() == eCSSUnit_Null)
-            aData->mMarginData->mPadding.mTop = padVal;
-          if (aData->mMarginData->mPadding.mBottom.GetUnit() == eCSSUnit_Null)
-            aData->mMarginData->mPadding.mBottom = padVal;
+          nsCSSValue* paddingLeft = aData->ValueForPaddingLeft();
+          if (paddingLeft->GetUnit() == eCSSUnit_Null)
+            *paddingLeft = padVal;
+          nsCSSValue* paddingRight = aData->ValueForPaddingRight();
+          if (paddingRight->GetUnit() == eCSSUnit_Null)
+            *paddingRight = padVal;
+          nsCSSValue* paddingTop = aData->ValueForPaddingTop();
+          if (paddingTop->GetUnit() == eCSSUnit_Null)
+            *paddingTop = padVal;
+          nsCSSValue* paddingBottom = aData->ValueForPaddingBottom();
+          if (paddingBottom->GetUnit() == eCSSUnit_Null)
+            *paddingBottom = padVal;
         }
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)) {
     const nsStyleDisplay* readDisplay = aData->mStyleContext->GetStyleDisplay();
   
     if (readDisplay->mDisplay != NS_STYLE_DISPLAY_TABLE_CELL) {
       // width: value
-      if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
+      nsCSSValue* width = aData->ValueForWidth();
+      if (width->GetUnit() == eCSSUnit_Null) {
         const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
         if (value && value->Type() == nsAttrValue::eInteger) 
-          aData->mPositionData->mWidth.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+          width->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
         else if (value && value->Type() == nsAttrValue::ePercent)
-          aData->mPositionData->mWidth.SetPercentValue(value->GetPercentValue());
+          width->SetPercentValue(value->GetPercentValue());
       }
 
       // height: value
-      if (aData->mPositionData->mHeight.GetUnit() == eCSSUnit_Null) {
+      nsCSSValue* height = aData->ValueForHeight();
+      if (height->GetUnit() == eCSSUnit_Null) {
         const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::height);
         if (value && value->Type() == nsAttrValue::eInteger) 
-          aData->mPositionData->mHeight.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+          height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
         else if (value && value->Type() == nsAttrValue::ePercent)
-          aData->mPositionData->mHeight.SetPercentValue(value->GetPercentValue()); 
+          height->SetPercentValue(value->GetPercentValue()); 
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Visibility)) {
     const nsStyleDisplay* readDisplay = aData->mStyleContext->GetStyleDisplay();
   
     if (readDisplay->mDisplay != NS_STYLE_DISPLAY_TABLE_CELL)
       nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
@@ -1216,44 +1228,52 @@ MapAttributesIntoRule(const nsMappedAttr
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Border)) {
     const nsStyleDisplay* readDisplay = aData->mStyleContext->GetStyleDisplay();
     if (readDisplay->mDisplay != NS_STYLE_DISPLAY_TABLE_CELL) {
       // bordercolor
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::bordercolor);
       nscolor color;
       if (value && presContext->UseDocumentColors() &&
           value->GetColorValue(color)) {
-        if (aData->mMarginData->mBorderColor.mLeft.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderColor.mLeft.SetColorValue(color);
-        if (aData->mMarginData->mBorderColor.mRight.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderColor.mRight.SetColorValue(color);
-        if (aData->mMarginData->mBorderColor.mTop.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderColor.mTop.SetColorValue(color);
-        if (aData->mMarginData->mBorderColor.mBottom.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderColor.mBottom.SetColorValue(color);
+        nsCSSValue* borderLeftColor = aData->ValueForBorderLeftColor();
+        if (borderLeftColor->GetUnit() == eCSSUnit_Null)
+          borderLeftColor->SetColorValue(color);
+        nsCSSValue* borderRightColor = aData->ValueForBorderRightColor();
+        if (borderRightColor->GetUnit() == eCSSUnit_Null)
+          borderRightColor->SetColorValue(color);
+        nsCSSValue* borderTopColor = aData->ValueForBorderTopColor();
+        if (borderTopColor->GetUnit() == eCSSUnit_Null)
+          borderTopColor->SetColorValue(color);
+        nsCSSValue* borderBottomColor = aData->ValueForBorderBottomColor();
+        if (borderBottomColor->GetUnit() == eCSSUnit_Null)
+          borderBottomColor->SetColorValue(color);
       }
 
       // border
       const nsAttrValue* borderValue = aAttributes->GetAttr(nsGkAtoms::border);
       if (borderValue) {
         // border = 1 pixel default
         PRInt32 borderThickness = 1;
 
         if (borderValue->Type() == nsAttrValue::eInteger)
           borderThickness = borderValue->GetIntegerValue();
 
         // by default, set all border sides to the specified width
-        if (aData->mMarginData->mBorderWidth.mLeft.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderWidth.mLeft.SetFloatValue((float)borderThickness, eCSSUnit_Pixel);
-        if (aData->mMarginData->mBorderWidth.mRight.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderWidth.mRight.SetFloatValue((float)borderThickness, eCSSUnit_Pixel);
-        if (aData->mMarginData->mBorderWidth.mTop.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderWidth.mTop .SetFloatValue((float)borderThickness, eCSSUnit_Pixel);
-        if (aData->mMarginData->mBorderWidth.mBottom.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderWidth.mBottom.SetFloatValue((float)borderThickness, eCSSUnit_Pixel);
+        nsCSSValue* borderLeftWidth = aData->ValueForBorderLeftWidth();
+        if (borderLeftWidth->GetUnit() == eCSSUnit_Null)
+          borderLeftWidth->SetFloatValue((float)borderThickness, eCSSUnit_Pixel);
+        nsCSSValue* borderRightWidth = aData->ValueForBorderRightWidth();
+        if (borderRightWidth->GetUnit() == eCSSUnit_Null)
+          borderRightWidth->SetFloatValue((float)borderThickness, eCSSUnit_Pixel);
+        nsCSSValue* borderTopWidth = aData->ValueForBorderTopWidth();
+        if (borderTopWidth->GetUnit() == eCSSUnit_Null)
+          borderTop Width->SetFloatValue((float)borderThickness, eCSSUnit_Pixel);
+        nsCSSValue* borderBottomWidth = aData->ValueForBorderBottomWidth();
+        if (borderBottomWidth->GetUnit() == eCSSUnit_Null)
+          borderBottomWidth->SetFloatValue((float)borderThickness, eCSSUnit_Pixel);
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)) {
     const nsStyleDisplay* readDisplay = aData->mStyleContext->GetStyleDisplay();
   
     if (readDisplay->mDisplay != NS_STYLE_DISPLAY_TABLE_CELL)
       nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
diff --git a/content/html/content/src/nsHTMLTableRowElement.cpp b/content/html/content/src/nsHTMLTableRowElement.cpp
--- a/content/html/content/src/nsHTMLTableRowElement.cpp
+++ b/content/html/content/src/nsHTMLTableRowElement.cpp
@@ -407,42 +407,45 @@ nsHTMLTableRowElement::ParseAttribute(PR
                                               aResult);
 }
 
 static 
 void MapAttributesIntoRule(const nsMappedAttributes* aAttributes, nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)) {
     // height: value
-    if (aData->mPositionData->mHeight.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* height = aData->ValueForHeight();
+    if (height->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::height);
       if (value && value->Type() == nsAttrValue::eInteger)
-        aData->mPositionData->mHeight.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+        height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
       else if (value && value->Type() == nsAttrValue::ePercent)
-        aData->mPositionData->mHeight.SetPercentValue(value->GetPercentValue());
+        height->SetPercentValue(value->GetPercentValue());
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
-    if (aData->mTextData->mTextAlign.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* textAlign = aData->ValueForTextAlign();
+    if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
       // XXX Should we be doing this only for computed style now that
       // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aData->mTextData->mTextAlign.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
-    if (aData->mTextData->mVerticalAlign.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
+    if (verticalAlign->GetUnit() == eCSSUnit_Null) {
       // valign: enum
       // XXX Should we be doing this only for computed style now that
       // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aData->mTextData->mVerticalAlign.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
diff --git a/content/html/content/src/nsHTMLTableSectionElement.cpp b/content/html/content/src/nsHTMLTableSectionElement.cpp
--- a/content/html/content/src/nsHTMLTableSectionElement.cpp
+++ b/content/html/content/src/nsHTMLTableSectionElement.cpp
@@ -273,40 +273,43 @@ nsHTMLTableSectionElement::ParseAttribut
                                               aResult);
 }
 
 static 
 void MapAttributesIntoRule(const nsMappedAttributes* aAttributes, nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)) {
     // height: value
-    if (aData->mPositionData->mHeight.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* height = aData->ValueForHeight();
+    if (height->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::height);
       if (value && value->Type() == nsAttrValue::eInteger)
-        aData->mPositionData->mHeight.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);   
+        height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
-    if (aData->mTextData->mTextAlign.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* textAlign = aData->ValueForTextAlign();
+    if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
       // XXX Should we be doing this only for computed style now that
       // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aData->mTextData->mTextAlign.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
-    if (aData->mTextData->mVerticalAlign.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
+    if (verticalAlign->GetUnit() == eCSSUnit_Null) {
       // valign: enum
       // XXX Should we be doing this only for computed style now that
       // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aData->mTextData->mVerticalAlign.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
