From: L. David Baron <dbaron@dbaron.org>

Convert attribute mapping functions to property getters instead of accessing struct members.

diff --git a/content/html/content/src/nsGenericHTMLElement.cpp b/content/html/content/src/nsGenericHTMLElement.cpp
--- a/content/html/content/src/nsGenericHTMLElement.cpp
+++ b/content/html/content/src/nsGenericHTMLElement.cpp
@@ -1643,54 +1643,54 @@ nsGenericHTMLElement::ParseScrollingValu
 /**
  * Handle attributes common to all html elements
  */
 void
 nsGenericHTMLElement::MapCommonAttributesExceptHiddenInto(const nsMappedAttributes* aAttributes,
                                                           nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(UserInterface)) {
-    nsRuleDataUserInterface *ui = aData->mUserInterfaceData;
-    if (ui->mUserModify.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* userModify = aData->ValueForMozUserModify();
+    if (userModify->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value =
         aAttributes->GetAttr(nsGkAtoms::contenteditable);
       if (value) {
         if (value->Equals(nsGkAtoms::_empty, eCaseMatters) ||
             value->Equals(nsGkAtoms::_true, eIgnoreCase)) {
-          ui->mUserModify.SetIntValue(NS_STYLE_USER_MODIFY_READ_WRITE,
-                                      eCSSUnit_Enumerated);
+          userModify->SetIntValue(NS_STYLE_USER_MODIFY_READ_WRITE,
+                                  eCSSUnit_Enumerated);
         }
         else if (value->Equals(nsGkAtoms::_false, eIgnoreCase)) {
-            ui->mUserModify.SetIntValue(NS_STYLE_USER_MODIFY_READ_ONLY,
-                                        eCSSUnit_Enumerated);
+            userModify->SetIntValue(NS_STYLE_USER_MODIFY_READ_ONLY,
+                                    eCSSUnit_Enumerated);
         }
       }
     }
   }
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Visibility)) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::lang);
     if (value && value->Type() == nsAttrValue::eString) {
-      aData->mDisplayData->mLang.SetStringValue(value->GetStringValue(),
-                                                eCSSUnit_Ident);
+      aData->ValueForLang()->SetStringValue(value->GetStringValue(),
+                                            eCSSUnit_Ident);
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapCommonAttributesInto(const nsMappedAttributes* aAttributes,
                                               nsRuleData* aData)
 {
   nsGenericHTMLElement::MapCommonAttributesExceptHiddenInto(aAttributes, aData);
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) {
-    nsRuleDataDisplay* disp = aData->mDisplayData;
-    if (disp->mDisplay.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* display = aData->ValueForDisplay();
+    if (display->GetUnit() == eCSSUnit_Null) {
       if (aAttributes->IndexOfAttr(nsGkAtoms::hidden, kNameSpaceID_None) >= 0) {
-        disp->mDisplay.SetIntValue(NS_STYLE_DISPLAY_NONE, eCSSUnit_Enumerated);
+        display->SetIntValue(NS_STYLE_DISPLAY_NONE, eCSSUnit_Enumerated);
       }
     }
   }
 }
 
 void
 nsGenericHTMLFormElement::UpdateEditableFormControlState()
 {
@@ -1782,48 +1782,54 @@ void
 nsGenericHTMLElement::MapImageAlignAttributeInto(const nsMappedAttributes* aAttributes,
                                                  nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & (NS_STYLE_INHERIT_BIT(Display) |
                           NS_STYLE_INHERIT_BIT(TextReset))) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
     if (value && value->Type() == nsAttrValue::eEnum) {
       PRInt32 align = value->GetEnumValue();
-      if ((aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) &&
-          aRuleData->mDisplayData->mFloat.GetUnit() == eCSSUnit_Null) {
-        if (align == NS_STYLE_TEXT_ALIGN_LEFT)
-          aRuleData->mDisplayData->mFloat.SetIntValue(NS_STYLE_FLOAT_LEFT, eCSSUnit_Enumerated);
-        else if (align == NS_STYLE_TEXT_ALIGN_RIGHT)
-          aRuleData->mDisplayData->mFloat.SetIntValue(NS_STYLE_FLOAT_RIGHT, eCSSUnit_Enumerated);
+      if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) {
+        nsCSSValue* cssFloat = aRuleData->ValueForCssFloat();
+        if (cssFloat->GetUnit() == eCSSUnit_Null) {
+          if (align == NS_STYLE_TEXT_ALIGN_LEFT) {
+            cssFloat->SetIntValue(NS_STYLE_FLOAT_LEFT, eCSSUnit_Enumerated);
+          } else if (align == NS_STYLE_TEXT_ALIGN_RIGHT) {
+            cssFloat->SetIntValue(NS_STYLE_FLOAT_RIGHT, eCSSUnit_Enumerated);
+          }
+        }
       }
-      if ((aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) &&
-          aRuleData->mTextData->mVerticalAlign.GetUnit() == eCSSUnit_Null) {
-        switch (align) {
-        case NS_STYLE_TEXT_ALIGN_LEFT:
-        case NS_STYLE_TEXT_ALIGN_RIGHT:
-          break;
-        default:
-          aRuleData->mTextData->mVerticalAlign.SetIntValue(align, eCSSUnit_Enumerated);
-          break;
+      if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
+        nsCSSValue* verticalAlign = aRuleData->ValueForVerticalAlign();
+        if (verticalAlign->GetUnit() == eCSSUnit_Null) {
+          switch (align) {
+          case NS_STYLE_TEXT_ALIGN_LEFT:
+          case NS_STYLE_TEXT_ALIGN_RIGHT:
+            break;
+          default:
+            verticalAlign->SetIntValue(align, eCSSUnit_Enumerated);
+            break;
+          }
         }
       }
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapDivAlignAttributeInto(const nsMappedAttributes* aAttributes,
                                                nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
-    if (aRuleData->mTextData->mTextAlign.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* textAlign = aRuleData->ValueForTextAlign();
+    if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aRuleData->mTextData->mTextAlign.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 }
 
 
 void
 nsGenericHTMLElement::MapImageMarginAttributeInto(const nsMappedAttributes* aAttributes,
                                                   nsRuleData* aData)
@@ -1838,66 +1844,70 @@ nsGenericHTMLElement::MapImageMarginAttr
   if (value) {
     nsCSSValue hval;
     if (value->Type() == nsAttrValue::eInteger)
       hval.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     else if (value->Type() == nsAttrValue::ePercent)
       hval.SetPercentValue(value->GetPercentValue());
 
     if (hval.GetUnit() != eCSSUnit_Null) {
-      nsCSSRect& margin = aData->mMarginData->mMargin;
-      if (margin.mLeft.GetUnit() == eCSSUnit_Null)
-        margin.mLeft = hval;
-      if (margin.mRight.GetUnit() == eCSSUnit_Null)
-        margin.mRight = hval;
+      nsCSSValue* left = aData->ValueForMarginLeft();
+      if (left->GetUnit() == eCSSUnit_Null)
+        *left = hval;
+      nsCSSValue* right = aData->ValueForMarginRight();
+      if (right->GetUnit() == eCSSUnit_Null)
+        *right = hval;
     }
   }
 
   // vspace: value
   value = aAttributes->GetAttr(nsGkAtoms::vspace);
   if (value) {
     nsCSSValue vval;
     if (value->Type() == nsAttrValue::eInteger)
       vval.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     else if (value->Type() == nsAttrValue::ePercent)
       vval.SetPercentValue(value->GetPercentValue());
   
     if (vval.GetUnit() != eCSSUnit_Null) {
-      nsCSSRect& margin = aData->mMarginData->mMargin;
-      if (margin.mTop.GetUnit() == eCSSUnit_Null)
-        margin.mTop = vval;
-      if (margin.mBottom.GetUnit() == eCSSUnit_Null)
-        margin.mBottom = vval;
+      nsCSSValue* top = aData->ValueForMarginTop();
+      if (top->GetUnit() == eCSSUnit_Null)
+        *top = vval;
+      nsCSSValue* bottom = aData->ValueForMarginBottom();
+      if (bottom->GetUnit() == eCSSUnit_Null)
+        *bottom = vval;
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapImageSizeAttributesInto(const nsMappedAttributes* aAttributes,
                                                  nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)))
     return;
 
   // width: value
-  if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
+  nsCSSValue* width = aData->ValueForWidth();
+  if (width->GetUnit() == eCSSUnit_Null) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
     if (value && value->Type() == nsAttrValue::eInteger)
-      aData->mPositionData->mWidth.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+      width->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     else if (value && value->Type() == nsAttrValue::ePercent)
-      aData->mPositionData->mWidth.SetPercentValue(value->GetPercentValue());
+      width->SetPercentValue(value->GetPercentValue());
   }
 
   // height: value
-  if (aData->mPositionData->mHeight.GetUnit() == eCSSUnit_Null) {
+  nsCSSValue* height = aData->ValueForHeight();
+  if (height->GetUnit() == eCSSUnit_Null) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::height);
     if (value && value->Type() == nsAttrValue::eInteger)
-      aData->mPositionData->mHeight.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
+      height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
     else if (value && value->Type() == nsAttrValue::ePercent)
-      aData->mPositionData->mHeight.SetPercentValue(value->GetPercentValue());    
+      height->SetPercentValue(value->GetPercentValue());
   }
 }
 
 void
 nsGenericHTMLElement::MapImageBorderAttributeInto(const nsMappedAttributes* aAttributes,
                                                   nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Border)))
@@ -1907,56 +1917,66 @@ nsGenericHTMLElement::MapImageBorderAttr
   const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::border);
   if (!value)
     return;
   
   nscoord val = 0;
   if (value->Type() == nsAttrValue::eInteger)
     val = value->GetIntegerValue();
 
-  nsCSSRect& borderWidth = aData->mMarginData->mBorderWidth;
-  if (borderWidth.mLeft.GetUnit() == eCSSUnit_Null)
-    borderWidth.mLeft.SetFloatValue((float)val, eCSSUnit_Pixel);
-  if (borderWidth.mTop.GetUnit() == eCSSUnit_Null)
-    borderWidth.mTop.SetFloatValue((float)val, eCSSUnit_Pixel);
-  if (borderWidth.mRight.GetUnit() == eCSSUnit_Null)
-    borderWidth.mRight.SetFloatValue((float)val, eCSSUnit_Pixel);
-  if (borderWidth.mBottom.GetUnit() == eCSSUnit_Null)
-    borderWidth.mBottom.SetFloatValue((float)val, eCSSUnit_Pixel);
-
-  nsCSSRect& borderStyle = aData->mMarginData->mBorderStyle;
-  if (borderStyle.mLeft.GetUnit() == eCSSUnit_Null)
-    borderStyle.mLeft.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
-  if (borderStyle.mTop.GetUnit() == eCSSUnit_Null)
-    borderStyle.mTop.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
-  if (borderStyle.mRight.GetUnit() == eCSSUnit_Null)
-    borderStyle.mRight.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
-  if (borderStyle.mBottom.GetUnit() == eCSSUnit_Null)
-    borderStyle.mBottom.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
-
-  nsCSSRect& borderColor = aData->mMarginData->mBorderColor;
-  if (borderColor.mLeft.GetUnit() == eCSSUnit_Null)
-    borderColor.mLeft.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
-  if (borderColor.mTop.GetUnit() == eCSSUnit_Null)
-    borderColor.mTop.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
-  if (borderColor.mRight.GetUnit() == eCSSUnit_Null)
-    borderColor.mRight.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
-  if (borderColor.mBottom.GetUnit() == eCSSUnit_Null)
-    borderColor.mBottom.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
+  nsCSSValue* borderLeftWidth = aData->ValueForBorderLeftWidth();
+  if (borderLeftWidth->GetUnit() == eCSSUnit_Null)
+    borderLeftWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
+  nsCSSValue* borderTopWidth = aData->ValueForBorderTopWidth();
+  if (borderTopWidth->GetUnit() == eCSSUnit_Null)
+    borderTopWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
+  nsCSSValue* borderRightWidth = aData->ValueForBorderRightWidth();
+  if (borderRightWidth->GetUnit() == eCSSUnit_Null)
+    borderRightWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
+  nsCSSValue* borderBottomWidth = aData->ValueForBorderBottomWidth();
+  if (borderBottomWidth->GetUnit() == eCSSUnit_Null)
+    borderBottomWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
+
+  nsCSSValue* borderLeftStyle = aData->ValueForBorderLeftStyle();
+  if (borderLeftStyle->GetUnit() == eCSSUnit_Null)
+    borderLeftStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
+  nsCSSValue* borderTopStyle = aData->ValueForBorderTopStyle();
+  if (borderTopStyle->GetUnit() == eCSSUnit_Null)
+    borderTopStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
+  nsCSSValue* borderRightStyle = aData->ValueForBorderRightStyle();
+  if (borderRightStyle->GetUnit() == eCSSUnit_Null)
+    borderRightStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
+  nsCSSValue* borderBottomStyle = aData->ValueForBorderBottomStyle();
+  if (borderBottomStyle->GetUnit() == eCSSUnit_Null)
+    borderBottomStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
+
+  nsCSSValue* borderLeftColor = aData->ValueForBorderLeftColor();
+  if (borderLeftColor->GetUnit() == eCSSUnit_Null)
+    borderLeftColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
+  nsCSSValue* borderTopColor = aData->ValueForBorderTopColor();
+  if (borderTopColor->GetUnit() == eCSSUnit_Null)
+    borderTopColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
+  nsCSSValue* borderRightColor = aData->ValueForBorderRightColor();
+  if (borderRightColor->GetUnit() == eCSSUnit_Null)
+    borderRightColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
+  nsCSSValue* borderBottomColor = aData->ValueForBorderBottomColor();
+  if (borderBottomColor->GetUnit() == eCSSUnit_Null)
+    borderBottomColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
 }
 
 void
 nsGenericHTMLElement::MapBackgroundInto(const nsMappedAttributes* aAttributes,
                                         nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
     return;
 
   nsPresContext* presContext = aData->mPresContext;
-  if (aData->mColorData->mBackImage.GetUnit() == eCSSUnit_Null &&
+  nsCSSValue* backImage = aData->ValueForBackgroundImage();
+  if (backImage->GetUnit() == eCSSUnit_Null &&
       presContext->UseDocumentColors()) {
     // background
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::background);
     if (value && value->Type() == nsAttrValue::eString) {
       const nsString& spec = value->GetStringValue();
       if (!spec.IsEmpty()) {
         // Resolve url to an absolute url
         // XXX this breaks if the HTML element has an xml:base
@@ -1976,46 +1996,46 @@ nsGenericHTMLElement::MapBackgroundInto(
           if (NS_LIKELY(buffer)) {
             // XXXbz it would be nice to assert that doc->NodePrincipal() is
             // the same as the principal of the node (which we'd need to store
             // in the mapped attrs or something?)
             nsCSSValue::Image *img =
               new nsCSSValue::Image(uri, buffer, doc->GetDocumentURI(),
                                     doc->NodePrincipal(), doc);
             if (NS_LIKELY(img)) {
-              nsCSSValueList* list =
-                aData->mColorData->mBackImage.SetListValue();
+              nsCSSValueList* list = backImage->SetListValue();
               list->mValue.SetImageValue(img);
             }
           }
         }
       }
       else if (presContext->CompatibilityMode() == eCompatibility_NavQuirks) {
         // in NavQuirks mode, allow the empty string to set the
         // background to empty
-        nsCSSValueList* list = aData->mColorData->mBackImage.SetListValue();
+        nsCSSValueList* list = backImage->SetListValue();
         list->mValue.SetNoneValue();
       }
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapBGColorInto(const nsMappedAttributes* aAttributes,
                                      nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
     return;
 
-  if (aData->mColorData->mBackColor.GetUnit() == eCSSUnit_Null &&
+  nsCSSValue* backColor = aData->ValueForBackgroundColor();
+  if (backColor->GetUnit() == eCSSUnit_Null &&
       aData->mPresContext->UseDocumentColors()) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::bgcolor);
     nscolor color;
     if (value && value->GetColorValue(color)) {
-      aData->mColorData->mBackColor.SetColorValue(color);
+      backColor->SetColorValue(color);
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapBackgroundAttributesInto(const nsMappedAttributes* aAttributes,
                                                   nsRuleData* aData)
 {
@@ -2027,18 +2047,18 @@ void
 nsGenericHTMLElement::MapScrollingAttributeInto(const nsMappedAttributes* aAttributes,
                                                 nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)))
     return;
 
   // scrolling
   nsCSSValue* overflowValues[2] = {
-    &aData->mDisplayData->mOverflowX,
-    &aData->mDisplayData->mOverflowY,
+    aData->ValueForOverflowX(),
+    aData->ValueForOverflowY(),
   };
   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(overflowValues); ++i) {
     if (overflowValues[i]->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::scrolling);
       if (value && value->Type() == nsAttrValue::eEnum) {
         PRInt32 mappedValue;
         switch (value->GetEnumValue()) {
           case NS_STYLE_FRAME_ON:
diff --git a/content/html/content/src/nsHTMLBRElement.cpp b/content/html/content/src/nsHTMLBRElement.cpp
--- a/content/html/content/src/nsHTMLBRElement.cpp
+++ b/content/html/content/src/nsHTMLBRElement.cpp
@@ -128,20 +128,21 @@ nsHTMLBRElement::ParseAttribute(PRInt32 
                                               aResult);
 }
 
 static void
 MapAttributesIntoRule(const nsMappedAttributes* aAttributes,
                       nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) {
-    if (aData->mDisplayData->mClear.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* clear = aData->ValueForClear();
+    if (clear->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::clear);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aData->mDisplayData->mClear.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        clear->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
 nsHTMLBRElement::IsAttributeMapped(const nsIAtom* aAttribute) const
diff --git a/content/html/content/src/nsHTMLBodyElement.cpp b/content/html/content/src/nsHTMLBodyElement.cpp
--- a/content/html/content/src/nsHTMLBodyElement.cpp
+++ b/content/html/content/src/nsHTMLBodyElement.cpp
@@ -384,23 +384,24 @@ void MapAttributesIntoRule(const nsMappe
             styleSheet->SetVisitedLinkColor(color);
           }
         }
       }
     }
   }
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Color)) {
-    if (aData->mColorData->mColor.GetUnit() == eCSSUnit_Null &&
+    nsCSSValue *color = aData->ValueForColor();
+    if (color->GetUnit() == eCSSUnit_Null &&
         aData->mPresContext->UseDocumentColors()) {
       // color: color
       nscolor color;
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::text);
       if (value && value->GetColorValue(color))
-        aData->mColorData->mColor.SetColorValue(color);
+        color->SetColorValue(color);
     }
   }
 
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 nsMapRuleToAttributesFunc
diff --git a/content/html/content/src/nsHTMLFontElement.cpp b/content/html/content/src/nsHTMLFontElement.cpp
--- a/content/html/content/src/nsHTMLFontElement.cpp
+++ b/content/html/content/src/nsHTMLFontElement.cpp
@@ -181,83 +181,85 @@ nsHTMLFontElement::ParseAttribute(PRInt3
                                               aResult);
 }
 
 static void
 MapAttributesIntoRule(const nsMappedAttributes* aAttributes,
                       nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Font)) {
-    nsRuleDataFont& font = *(aData->mFontData);
-    
     // face: string list
-    if (font.mFamily.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* family = aData->ValueForFontFamily();
+    if (family->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::face);
       if (value && value->Type() == nsAttrValue::eString &&
           !value->IsEmptyString()) {
-        font.mFamily.SetStringValue(value->GetStringValue(), eCSSUnit_Families);
-        font.mFamilyFromHTML = PR_TRUE;
+        family->SetStringValue(value->GetStringValue(), eCSSUnit_Families);
+        aData->mFontData->mFamilyFromHTML = PR_TRUE;
       }
     }
 
     // pointSize: int
-    if (font.mSize.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* fontSize = aData->ValueForFontSize();
+    if (fontSize->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::pointSize);
       if (value && value->Type() == nsAttrValue::eInteger)
-        font.mSize.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Point);
+        fontSize->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Point);
       else {
         // size: int, enum , 
         value = aAttributes->GetAttr(nsGkAtoms::size);
         if (value) {
           nsAttrValue::ValueType unit = value->Type();
           if (unit == nsAttrValue::eInteger || unit == nsAttrValue::eEnum) { 
             PRInt32 size;
             if (unit == nsAttrValue::eEnum) // int (+/-)
               size = value->GetEnumValue() + 3;
             else
               size = value->GetIntegerValue();
 
             size = ((0 < size) ? ((size < 8) ? size : 7) : 1); 
-            font.mSize.SetIntValue(size, eCSSUnit_Enumerated);
+            fontSize->SetIntValue(size, eCSSUnit_Enumerated);
           }
         }
       }
     }
 
     // fontWeight: int
-    if (font.mWeight.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* weight = aData->ValueForFontWeight();
+    if (fontWeight->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::fontWeight);
       if (value && value->Type() == nsAttrValue::eInteger) // +/-
-        font.mWeight.SetIntValue(value->GetIntegerValue(), eCSSUnit_Integer);
+        fontWeight->SetIntValue(value->GetIntegerValue(), eCSSUnit_Integer);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Color)) {
-    if (aData->mColorData->mColor.GetUnit() == eCSSUnit_Null &&
+    nsCSSValue* color = aData->ValueForColor();
+    if (color->GetUnit() == eCSSUnit_Null &&
         aData->mPresContext->UseDocumentColors()) {
       // color: color
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::color);
       nscolor color;
       if (value && value->GetColorValue(color)) {
-        aData->mColorData->mColor.SetColorValue(color);
+        color->SetColorValue(color);
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
     // Make <a><font color="red">text</font></a> give the text a red underline
     // in quirks mode.  The NS_STYLE_TEXT_DECORATION_OVERRIDE_ALL flag only
     // affects quirks mode rendering.
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::color);
     nscolor color;
     if (value && value->GetColorValue(color)) {
-      nsCSSValue& decoration = aData->mTextData->mDecoration;
+      nsCSSValue* decoration = aData->ValueForTextDecoration();
       PRInt32 newValue = NS_STYLE_TEXT_DECORATION_OVERRIDE_ALL;
-      if (decoration.GetUnit() == eCSSUnit_Enumerated) {
-        newValue |= decoration.GetIntValue();
+      if (decoration->GetUnit() == eCSSUnit_Enumerated) {
+        newValue |= decoration->GetIntValue();
       }
-      decoration.SetIntValue(newValue, eCSSUnit_Enumerated);
+      decoration->SetIntValue(newValue, eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
 nsHTMLFontElement::IsAttributeMapped(const nsIAtom* aAttribute) const
diff --git a/content/html/content/src/nsHTMLHRElement.cpp b/content/html/content/src/nsHTMLHRElement.cpp
--- a/content/html/content/src/nsHTMLHRElement.cpp
+++ b/content/html/content/src/nsHTMLHRElement.cpp
@@ -170,63 +170,66 @@ MapAttributesIntoRule(const nsMappedAttr
     }
   }
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Margin)) {
     // align: enum
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
     if (value && value->Type() == nsAttrValue::eEnum) {
       // Map align attribute into auto side margins
-      nsCSSRect& margin = aData->mMarginData->mMargin;
+      nsCSSValue* marginLeft = aData->ValueForMarginLeft();
+      nsCSSValue* marginRight = aData->ValueForMarginRight();
       switch (value->GetEnumValue()) {
       case NS_STYLE_TEXT_ALIGN_LEFT:
-        if (margin.mLeft.GetUnit() == eCSSUnit_Null)
-          margin.mLeft.SetFloatValue(0.0f, eCSSUnit_Pixel);
-        if (margin.mRight.GetUnit() == eCSSUnit_Null)
-          margin.mRight.SetAutoValue();
+        if (marginLeft->GetUnit() == eCSSUnit_Null)
+          marginLeft->SetFloatValue(0.0f, eCSSUnit_Pixel);
+        if (marginRight->GetUnit() == eCSSUnit_Null)
+          marginRight->SetAutoValue();
         break;
       case NS_STYLE_TEXT_ALIGN_RIGHT:
-        if (margin.mLeft.GetUnit() == eCSSUnit_Null)
-          margin.mLeft.SetAutoValue();
-        if (margin.mRight.GetUnit() == eCSSUnit_Null)
-          margin.mRight.SetFloatValue(0.0f, eCSSUnit_Pixel);
+        if (marginLeft->GetUnit() == eCSSUnit_Null)
+          marginLeft->SetAutoValue();
+        if (marginRight->GetUnit() == eCSSUnit_Null)
+          marginRight->SetFloatValue(0.0f, eCSSUnit_Pixel);
         break;
       case NS_STYLE_TEXT_ALIGN_CENTER:
-        if (margin.mLeft.GetUnit() == eCSSUnit_Null)
-          margin.mLeft.SetAutoValue();
-        if (margin.mRight.GetUnit() == eCSSUnit_Null)
-          margin.mRight.SetAutoValue();
+        if (marginLeft->GetUnit() == eCSSUnit_Null)
+          marginLeft->SetAutoValue();
+        if (marginRight->GetUnit() == eCSSUnit_Null)
+          marginRight->SetAutoValue();
         break;
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)) {
     // width: integer, percent
-    if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* width = aData->ValueForWidth();
+    if (width->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
       if (value && value->Type() == nsAttrValue::eInteger) {
-        aData->mPositionData->mWidth.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+        width->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
       } else if (value && value->Type() == nsAttrValue::ePercent) {
-        aData->mPositionData->mWidth.SetPercentValue(value->GetPercentValue());
+        width->SetPercentValue(value->GetPercentValue());
       }
     }
 
-    if (aData->mPositionData->mHeight.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* height = aData->ValueForHeight();
+    if (height->GetUnit() == eCSSUnit_Null) {
       // size: integer
       if (noshade) {
         // noshade case: size is set using the border
-        aData->mPositionData->mHeight.SetAutoValue();
+        height->SetAutoValue();
       } else {
         // normal case
         // the height includes the top and bottom borders that are initially 1px.
         // for size=1, html.css has a special case rule that makes this work by
         // removing all but the top border.
         const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::size);
         if (value && value->Type() == nsAttrValue::eInteger) {
-          aData->mPositionData->mHeight.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+          height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
         } // else use default value from html.css
       }
     }
   }
   if ((aData->mSIDs & NS_STYLE_INHERIT_BIT(Border)) && noshade) { // if not noshade, border styles are dealt with by html.css
     // size: integer
     // if a size is set, use half of it per side, otherwise, use 1px per side
     float sizePerSide;
@@ -239,72 +242,80 @@ MapAttributesIntoRule(const nsMappedAttr
         // subpixel borders should be removed.
         // In the meantime, this makes http://www.microsoft.com/ look right.
         sizePerSide = 1.0f;
         allSides = PR_FALSE;
       }
     } else {
       sizePerSide = 1.0f; // default to a 2px high line
     }
-    nsCSSRect& borderWidth = aData->mMarginData->mBorderWidth;
-    if (borderWidth.mTop.GetUnit() == eCSSUnit_Null) {
-      borderWidth.mTop.SetFloatValue(sizePerSide, eCSSUnit_Pixel);
+    nsCSSValue* borderTopWidth = aData->ValueForBorderTopWidth();
+    if (borderTopWidth->GetUnit() == eCSSUnit_Null) {
+      borderTopWidth->SetFloatValue(sizePerSide, eCSSUnit_Pixel);
     }
     if (allSides) {
-      if (borderWidth.mRight.GetUnit() == eCSSUnit_Null) {
-        borderWidth.mRight.SetFloatValue(sizePerSide, eCSSUnit_Pixel);
+      nsCSSValue* borderRightWidth = aData->ValueForBorderRightWidth();
+      if (borderRightWidth->GetUnit() == eCSSUnit_Null) {
+        borderRightWidth->SetFloatValue(sizePerSide, eCSSUnit_Pixel);
       }
-      if (borderWidth.mBottom.GetUnit() == eCSSUnit_Null) {
-        borderWidth.mBottom.SetFloatValue(sizePerSide, eCSSUnit_Pixel);
+      nsCSSValue* borderBottomWidth = aData->ValueForBorderBottomWidth();
+      if (borderBottomWidth->GetUnit() == eCSSUnit_Null) {
+        borderBottomWidth->SetFloatValue(sizePerSide, eCSSUnit_Pixel);
       }
-      if (borderWidth.mLeft.GetUnit() == eCSSUnit_Null) {
-        borderWidth.mLeft.SetFloatValue(sizePerSide, eCSSUnit_Pixel);
+      nsCSSValue* borderLeftWidth = aData->ValueForBorderLeftWidth();
+      if (borderLeftWidth->GetUnit() == eCSSUnit_Null) {
+        borderLeftWidth->SetFloatValue(sizePerSide, eCSSUnit_Pixel);
       }
     }
 
-    nsCSSRect& borderStyle = aData->mMarginData->mBorderStyle;
-    if (borderStyle.mTop.GetUnit() == eCSSUnit_Null) {
-      borderStyle.mTop.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
-                                   eCSSUnit_Enumerated);
+    nsCSSValue* borderTopStyle = aData->ValueForBorderTopStyle();
+    if (borderTopStyle->GetUnit() == eCSSUnit_Null) {
+      borderTopStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
+                                  eCSSUnit_Enumerated);
     }
     if (allSides) {
-      if (borderStyle.mRight.GetUnit() == eCSSUnit_Null) {
-        borderStyle.mRight.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
+      nsCSSValue* borderRightStyle = aData->ValueForBorderRightStyle();
+      if (borderRightStyle->GetUnit() == eCSSUnit_Null) {
+        borderRightStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
+                                      eCSSUnit_Enumerated);
+      }
+      nsCSSValue* borderBottomStyle = aData->ValueForBorderBottomStyle();
+      if (borderBottomStyle->GetUnit() == eCSSUnit_Null) {
+        borderBottomStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
                                        eCSSUnit_Enumerated);
       }
-      if (borderStyle.mBottom.GetUnit() == eCSSUnit_Null) {
-        borderStyle.mBottom.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
-                                        eCSSUnit_Enumerated);
-      }
-      if (borderStyle.mLeft.GetUnit() == eCSSUnit_Null) {
-        borderStyle.mLeft.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
-                                      eCSSUnit_Enumerated);
+      nsCSSValue* borderLeftStyle = aData->ValueForBorderLeftStyle();
+      if (borderLeftStyle->GetUnit() == eCSSUnit_Null) {
+        borderLeftStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
+                                     eCSSUnit_Enumerated);
       }
 
       // If it would be noticeable, set the border radius to
       // 10000px on all corners; this triggers the clamping to make
       // circular ends.  This assumes the <hr> isn't larger than
       // that in *both* dimensions.
+      // FIXME!!!
       nsCSSCornerSizes& corners = aData->mMarginData->mBorderRadius;
 
       NS_FOR_CSS_FULL_CORNERS(c) {
         nsCSSValue& dimen = corners.GetCorner(c);
         if (dimen.GetUnit() == eCSSUnit_Null) {
           dimen.SetFloatValue(10000.0f, eCSSUnit_Pixel);
         }
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Color)) {
     // color: a color
     // (we got the color attribute earlier)
+    nsCSSValue* color = aData->ValueForColor();
     if (colorIsSet &&
-        aData->mColorData->mColor.GetUnit() == eCSSUnit_Null &&
+        color->GetUnit() == eCSSUnit_Null &&
         aData->mPresContext->UseDocumentColors()) {
-      aData->mColorData->mColor.SetColorValue(color);
+      color->SetColorValue(color);
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
 nsHTMLHRElement::IsAttributeMapped(const nsIAtom* aAttribute) const
diff --git a/content/html/content/src/nsHTMLIFrameElement.cpp b/content/html/content/src/nsHTMLIFrameElement.cpp
--- a/content/html/content/src/nsHTMLIFrameElement.cpp
+++ b/content/html/content/src/nsHTMLIFrameElement.cpp
@@ -197,44 +197,50 @@ MapAttributesIntoRule(const nsMappedAttr
     // If frameborder is 0 or No, set border to 0
     // else leave it as the value set in html.css
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::frameborder);
     if (value && value->Type() == nsAttrValue::eEnum) {
       PRInt32 frameborder = value->GetEnumValue();
       if (NS_STYLE_FRAME_0 == frameborder ||
           NS_STYLE_FRAME_NO == frameborder ||
           NS_STYLE_FRAME_OFF == frameborder) {
-        if (aData->mMarginData->mBorderWidth.mLeft.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderWidth.mLeft.SetFloatValue(0.0f, eCSSUnit_Pixel);
-        if (aData->mMarginData->mBorderWidth.mRight.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderWidth.mRight.SetFloatValue(0.0f, eCSSUnit_Pixel);
-        if (aData->mMarginData->mBorderWidth.mTop.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderWidth.mTop.SetFloatValue(0.0f, eCSSUnit_Pixel);
-        if (aData->mMarginData->mBorderWidth.mBottom.GetUnit() == eCSSUnit_Null)
-          aData->mMarginData->mBorderWidth.mBottom.SetFloatValue(0.0f, eCSSUnit_Pixel);
+        nsCSSValue* borderLeftWidth = aData->ValueForBorderLeftWidth();
+        if (borderLeftWidth->GetUnit() == eCSSUnit_Null)
+          borderLeftWidth->SetFloatValue(0.0f, eCSSUnit_Pixel);
+        nsCSSValue* borderRightWidth = aData->ValueForBorderRightWidth();
+        if (borderRightWidth->GetUnit() == eCSSUnit_Null)
+          borderRightWidth->SetFloatValue(0.0f, eCSSUnit_Pixel);
+        nsCSSValue* borderTopWidth = aData->ValueForBorderTopWidth();
+        if (borderTopWidth->GetUnit() == eCSSUnit_Null)
+          borderTopWidth->SetFloatValue(0.0f, eCSSUnit_Pixel);
+        nsCSSValue* borderBottomWidth = aData->ValueForBorderBottomWidth();
+        if (borderBottomWidth->GetUnit() == eCSSUnit_Null)
+          borderBottomWidth->SetFloatValue(0.0f, eCSSUnit_Pixel);
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)) {
     // width: value
-    if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* width = aData->ValueForWidth();
+    if (width->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
       if (value && value->Type() == nsAttrValue::eInteger)
-        aData->mPositionData->mWidth.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+        width->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
       else if (value && value->Type() == nsAttrValue::ePercent)
-        aData->mPositionData->mWidth.SetPercentValue(value->GetPercentValue());
+        width->SetPercentValue(value->GetPercentValue());
     }
 
     // height: value
-    if (aData->mPositionData->mHeight.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* height = aData->ValueForHeight();
+    if (height->GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::height);
       if (value && value->Type() == nsAttrValue::eInteger)
-        aData->mPositionData->mHeight.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+        height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
       else if (value && value->Type() == nsAttrValue::ePercent)
-        aData->mPositionData->mHeight.SetPercentValue(value->GetPercentValue());
+        height->SetPercentValue(value->GetPercentValue());
     }
   }
 
   nsGenericHTMLElement::MapScrollingAttributeInto(aAttributes, aData);
   nsGenericHTMLElement::MapImageAlignAttributeInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
diff --git a/content/html/content/src/nsHTMLLIElement.cpp b/content/html/content/src/nsHTMLLIElement.cpp
--- a/content/html/content/src/nsHTMLLIElement.cpp
+++ b/content/html/content/src/nsHTMLLIElement.cpp
@@ -147,21 +147,22 @@ nsHTMLLIElement::ParseAttribute(PRInt32 
                                               aResult);
 }
 
 static void
 MapAttributesIntoRule(const nsMappedAttributes* aAttributes,
                       nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(List)) {
-    if (aData->mListData->mType.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* listStyleType = aData->ValueForListStyleType();
+    if (listStyleType->GetUnit() == eCSSUnit_Null) {
       // type: enum
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::type);
       if (value && value->Type() == nsAttrValue::eEnum)
-        aData->mListData->mType.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+        listStyleType->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
 nsHTMLLIElement::IsAttributeMapped(const nsIAtom* aAttribute) const
diff --git a/content/html/content/src/nsHTMLOListElement.cpp b/content/html/content/src/nsHTMLOListElement.cpp
--- a/content/html/content/src/nsHTMLOListElement.cpp
+++ b/content/html/content/src/nsHTMLOListElement.cpp
@@ -194,24 +194,25 @@ nsHTMLSharedListElement::ParseAttribute(
   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
                                               aResult);
 }
 
 static void
 MapAttributesIntoRule(const nsMappedAttributes* aAttributes, nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(List)) {
-    if (aData->mListData->mType.GetUnit() == eCSSUnit_Null) {
+    nsCSSValue* listStyleType = aData->ValueForListStyleType();
+    if (listStyleType->GetUnit() == eCSSUnit_Null) {
       // type: enum
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::type);
       if (value) {
         if (value->Type() == nsAttrValue::eEnum)
-          aData->mListData->mType.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+          listStyleType->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
         else
-          aData->mListData->mType.SetIntValue(NS_STYLE_LIST_STYLE_DECIMAL, eCSSUnit_Enumerated);
+          listStyleType->SetIntValue(NS_STYLE_LIST_STYLE_DECIMAL, eCSSUnit_Enumerated);
       }
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
