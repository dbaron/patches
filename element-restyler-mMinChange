From: L. David Baron <dbaron@dbaron.org>

Move into ElementRestyler::mMinChange.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1931,30 +1931,33 @@ RestyleManager::ReparentStyleContext(nsI
         VerifyStyleTree(mPresContext, aFrame, newParentContext);
 #endif
       }
     }
   }
   return NS_OK;
 }
 
-ElementRestyler::ElementRestyler()
+ElementRestyler::ElementRestyler(nsChangeHint aMinChange)
+  : mMinChange(NS_SubtractHint(aMinChange,
+               NS_HintsNotHandledForDescendantsIn(aMinChange)))
 {
 }
 
 ElementRestyler::ElementRestyler(const ElementRestyler& aParentRestyler)
+  , mMinChange(NS_SubtractHint(aParentRestyler.mMinChange,
+               NS_HintsNotHandledForDescendantsIn(aParentRestyler.mMinChange)))
 {
 }
 
 void
 ElementRestyler::CaptureChange(nsStyleContext* aOldContext,
                                nsStyleContext* aNewContext,
                                nsIFrame* aFrame, nsIContent* aContent,
                                nsStyleChangeList* aChangeList,
-                               /*inout*/nsChangeHint &aMinChange,
                                /*in*/nsChangeHint aParentHintsNotHandledForDescendants,
                                /*out*/nsChangeHint &aHintsNotHandledForDescendants,
                                nsChangeHint aChangeToAssume)
 {
   nsChangeHint ourChange = aOldContext->CalcStyleDifference(aNewContext,
                              aParentHintsNotHandledForDescendants);
   NS_ASSERTION(!(ourChange & nsChangeHint_AllReflowHints) ||
                (ourChange & nsChangeHint_NeedReflow),
@@ -1964,53 +1967,47 @@ ElementRestyler::CaptureChange(nsStyleCo
   // in inherited properties (fill and stroke).  Avoid propagating it into
   // text nodes.
   if ((ourChange & nsChangeHint_UpdateEffects) &&
       aContent && !aContent->IsElement()) {
     ourChange = NS_SubtractHint(ourChange, nsChangeHint_UpdateEffects);
   }
 
   NS_UpdateHint(ourChange, aChangeToAssume);
-  if (NS_UpdateHint(aMinChange, ourChange)) {
+  if (NS_UpdateHint(mMinChange, ourChange)) {
     if (!(ourChange & nsChangeHint_ReconstructFrame) || aContent) {
       aChangeList->AppendChange(aFrame, aContent, ourChange);
     }
   }
   aHintsNotHandledForDescendants = NS_HintsNotHandledForDescendantsIn(ourChange);
 }
 
 /**
  * Recompute style for aFrame and accumulate changes into aChangeList
- * given that aMinChange is already accumulated for an ancestor.
+ * given that mMinChange is already accumulated for an ancestor.
  * aParentContent is the content node used to resolve the parent style
  * context.  This means that, for pseudo-elements, it is the content
  * that should be used for selector matching (rather than the fake
  * content node attached to the frame).
  *
  * For aParentFrameHintsNotHandledForDescendants, see
  * nsStyleContext::CalcStyleDifference.
  */
-nsChangeHint
+void
 ElementRestyler::Restyle(nsPresContext     *aPresContext,
                          nsIFrame          *aFrame,
                          nsIContent        *aParentContent,
                          nsStyleChangeList *aChangeList,
-                         nsChangeHint       aMinChange,
                          nsChangeHint       aParentFrameHintsNotHandledForDescendants,
                          nsRestyleHint      aRestyleHint,
                          RestyleTracker&    aRestyleTracker,
                          DesiredA11yNotifications aDesiredA11yNotifications,
                          nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
                          TreeMatchContext &aTreeMatchContext)
 {
-  // We need to generate a new change list entry for every frame whose style
-  // comparision returns one of these hints. These hints don't automatically
-  // update all their descendant frames.
-  aMinChange = NS_SubtractHint(aMinChange, NS_HintsNotHandledForDescendantsIn(aMinChange));
-
   // It would be nice if we could make stronger assertions here; they
   // would let us simplify the ?: expressions below setting |content|
   // and |pseudoContent| in sensible ways as well as making what
   // |localContent|, |content|, and |pseudoContent| mean make more
   // sense.  However, we can't, because of frame trees like the one in
   // https://bugzilla.mozilla.org/show_bug.cgi?id=472353#c14 .  Once we
   // fix bug 242277 we should be able to make this make more sense.
   NS_ASSERTION(aFrame->GetContent() || !aParentContent ||
@@ -2048,17 +2045,17 @@ ElementRestyler::Restyle(nsPresContext  
     // XXXldb Why does it make sense to use aParentContent?  (See
     // comment above assertion at start of function.)
     nsIContent* content = localContent ? localContent : aParentContent;
 
     if (content && content->IsElement()) {
       content->OwnerDoc()->FlushPendingLinkUpdates();
       RestyleTracker::RestyleData restyleData;
       if (aRestyleTracker.GetRestyleData(content->AsElement(), &restyleData)) {
-        if (NS_UpdateHint(aMinChange, restyleData.mChangeHint)) {
+        if (NS_UpdateHint(mMinChange, restyleData.mChangeHint)) {
           aChangeList->AppendChange(aFrame, content, restyleData.mChangeHint);
         }
         aRestyleHint = nsRestyleHint(aRestyleHint | restyleData.mRestyleHint);
       }
     }
 
     nsRestyleHint childRestyleHint = aRestyleHint;
 
@@ -2091,17 +2088,16 @@ ElementRestyler::Restyle(nsPresContext  
       // nsStyleContext::CalcStyleDifference says. CalcStyleDifference
       // can't be trusted because it assumes any changes to the parent
       // style context provider will be automatically propagated to
       // the frame(s) with child style contexts.
 
       ElementRestyler providerRestyler(*this);
       assumeDifferenceHint = providerRestyler.Restyle(aPresContext, providerFrame,
                                                    aParentContent, aChangeList,
-                                                   aMinChange,
                                                    nsChangeHint_Hints_NotHandledForDescendants,
                                                    aRestyleHint,
                                                    aRestyleTracker,
                                                    aDesiredA11yNotifications,
                                                    aVisibleKidsOfHiddenElement,
                                                    aTreeMatchContext);
 
       // The provider's new context becomes the parent context of
@@ -2215,17 +2211,17 @@ ElementRestyler::Restyle(nsPresContext  
             pseudoTag == nsCSSPseudoElements::after) {
           // XXX what other pseudos do we need to treat like this?
           newContext = styleSet->ProbePseudoElementStyle(element,
                                                          pseudoType,
                                                          parentContext,
                                                          aTreeMatchContext);
           if (!newContext) {
             // This pseudo should no longer exist; gotta reframe
-            NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
+            NS_UpdateHint(mMinChange, nsChangeHint_ReconstructFrame);
             aChangeList->AppendChange(aFrame, element,
                                       nsChangeHint_ReconstructFrame);
             // We're reframing anyway; just keep the same context
             newContext = oldContext;
           }
         } else {
           // Don't expect XUL tree stuff here, since it needs a comparator and
           // all.
@@ -2267,19 +2263,19 @@ ElementRestyler::Restyle(nsPresContext  
 
       if (newContext != oldContext) {
         if (!copyFromContinuation) {
           TryStartingTransition(aPresContext, aFrame->GetContent(),
                                 oldContext, &newContext);
         }
 
         CaptureChange(oldContext, newContext, aFrame, content, aChangeList,
-                      aMinChange, aParentFrameHintsNotHandledForDescendants,
+                      aParentFrameHintsNotHandledForDescendants,
                       nonInheritedHints, assumeDifferenceHint);
-        if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
+        if (!(mMinChange & nsChangeHint_ReconstructFrame)) {
           // if frame gets regenerated, let it keep old context
           aFrame->SetStyleContext(newContext);
         }
       }
       oldContext->Release();
     }
     else {
       NS_ERROR("resolve style context failed");
@@ -2314,22 +2310,22 @@ ElementRestyler::Restyle(nsPresContext  
           newExtraContext = styleSet->ResolvePseudoElementStyle(content->AsElement(),
                                                                 extraPseudoType,
                                                                 newContext);
         }
         if (newExtraContext) {
           if (oldExtraContext != newExtraContext) {
             nsChangeHint extraHintsNotHandledForDescendants = nsChangeHint(0);
             CaptureChange(oldExtraContext, newExtraContext, aFrame, content,
-                          aChangeList, aMinChange,
+                          aChangeList,
                           aParentFrameHintsNotHandledForDescendants,
                           extraHintsNotHandledForDescendants,
                           assumeDifferenceHint);
             NS_UpdateHint(nonInheritedHints, extraHintsNotHandledForDescendants);
-            if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
+            if (!(mMinChange & nsChangeHint_ReconstructFrame)) {
               aFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
             }
           }
         }
       }
       else {
         break;
       }
@@ -2410,17 +2406,17 @@ ElementRestyler::Restyle(nsPresContext  
           }
         }
       }
     }
 
     // Check whether we might need to create a new ::before frame.
     // There's no need to do this if we're planning to reframe already
     // or if we're not forcing restyles on kids.
-    if (!(aMinChange & nsChangeHint_ReconstructFrame) &&
+    if (!(mMinChange & nsChangeHint_ReconstructFrame) &&
         childRestyleHint) {
       // Make sure not to do this for pseudo-frames or frames that
       // can't have generated content.
       if (!pseudoTag &&
           ((aFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
            // Our content insertion frame might have gotten flagged
            (aFrame->GetContentInsertionFrame()->GetStateBits() &
             NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
@@ -2430,28 +2426,28 @@ ElementRestyler::Restyle(nsPresContext  
         if (!prevContinuation) {
           // Checking for a :before frame is cheaper than getting the
           // :before style context.
           if (!nsLayoutUtils::GetBeforeFrame(aFrame) &&
               nsLayoutUtils::HasPseudoStyle(localContent, newContext,
                                             nsCSSPseudoElements::ePseudo_before,
                                             aPresContext)) {
             // Have to create the new :before frame
-            NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
+            NS_UpdateHint(mMinChange, nsChangeHint_ReconstructFrame);
             aChangeList->AppendChange(aFrame, content,
                                       nsChangeHint_ReconstructFrame);
           }
         }
       }
     }
 
     // Check whether we might need to create a new ::after frame.
     // There's no need to do this if we're planning to reframe already
     // or if we're not forcing restyles on kids.
-    if (!(aMinChange & nsChangeHint_ReconstructFrame) &&
+    if (!(mMinChange & nsChangeHint_ReconstructFrame) &&
         childRestyleHint) {
       // Make sure not to do this for pseudo-frames or frames that
       // can't have generated content.
       if (!pseudoTag &&
           ((aFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
            // Our content insertion frame might have gotten flagged
            (aFrame->GetContentInsertionFrame()->GetStateBits() &
             NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
@@ -2462,30 +2458,30 @@ ElementRestyler::Restyle(nsPresContext  
         if (!nextContinuation) {
           // Getting the :after frame is more expensive than getting the pseudo
           // context, so get the pseudo context first.
           if (nsLayoutUtils::HasPseudoStyle(localContent, newContext,
                                             nsCSSPseudoElements::ePseudo_after,
                                             aPresContext) &&
               !nsLayoutUtils::GetAfterFrame(aFrame)) {
             // have to create the new :after frame
-            NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
+            NS_UpdateHint(mMinChange, nsChangeHint_ReconstructFrame);
             aChangeList->AppendChange(aFrame, content,
                                       nsChangeHint_ReconstructFrame);
           }
         }
       }
     }
 
     // There is no need to waste time crawling into a frame's children
     // on a frame change.  The act of reconstructing frames will force
     // new style contexts to be resolved on all of this frame's
     // descendants anyway, so we want to avoid wasting time processing
     // style contexts that we're just going to throw away anyway. - dwh
-    if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
+    if (!(mMinChange & nsChangeHint_ReconstructFrame)) {
 
       DesiredA11yNotifications kidsDesiredA11yNotification =
         aDesiredA11yNotifications;
 #ifdef ACCESSIBILITY
       A11yNotificationType ourA11yNotification = eDontNotify;
       // Notify a11y for primary frame only if it's a root frame of visibility
       // changes or its parent frame was hidden while it stays visible and
       // it is not inside a {ib} split or is the first frame of {ib} split.
@@ -2551,58 +2547,59 @@ ElementRestyler::Restyle(nsPresContext  
               nsIFrame* outOfFlowFrame =
                 nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
               NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
               NS_ASSERTION(outOfFlowFrame != resolvedChild,
                            "out-of-flow frame not a true descendant");
 
               // Note that the out-of-flow may not be a geometric descendant of
               // the frame where we started the reresolve.  Therefore, even if
-              // aMinChange already includes nsChangeHint_AllReflowHints we don't
+              // mMinChange already includes nsChangeHint_AllReflowHints we don't
               // want to pass that on to the out-of-flow reresolve, since that
               // can lead to the out-of-flow not getting reflowed when it should
               // be (eg a reresolve starting at <body> that involves reflowing
               // the <body> would miss reflowing fixed-pos nodes that also need
               // reflow).  In the cases when the out-of-flow _is_ a geometric
               // descendant of a frame we already have a reflow hint for,
               // reflow coalescing should keep us from doing the work twice.
 
               // |nsFrame::GetParentStyleContextFrame| checks being out
               // of flow so that this works correctly.
               do {
                 ElementRestyler oofRestyler(*this);
+                oofRestyler.mMinChange =
+                  NS_SubtractHint(oofRestyler.mMinChange,
+                                  nsChangeHint_AllReflowHints);
                 oofRestyler.Restyle(aPresContext, outOfFlowFrame,
                                       content, aChangeList,
-                                      NS_SubtractHint(aMinChange,
-                                                      nsChangeHint_AllReflowHints),
                                       nonInheritedHints,
                                       childRestyleHint,
                                       aRestyleTracker,
                                       kidsDesiredA11yNotification,
                                       aVisibleKidsOfHiddenElement,
                                       aTreeMatchContext);
               } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
 
               // reresolve placeholder's context under the same parent
               // as the out-of-flow frame
               ElementRestyler phRestyler(*this);
               phRestyler.Restyle(aPresContext, child, content,
-                                    aChangeList, aMinChange,
+                                    aChangeList,
                                     nonInheritedHints,
                                     childRestyleHint,
                                     aRestyleTracker,
                                     kidsDesiredA11yNotification,
                                     aVisibleKidsOfHiddenElement,
                                     aTreeMatchContext);
             }
             else {  // regular child frame
               if (child != resolvedChild) {
                 ElementRestyler childRestyler(*this);
                 childRestyler.Restyle(aPresContext, child, content,
-                                      aChangeList, aMinChange,
+                                      aChangeList,
                                       nonInheritedHints,
                                       childRestyleHint,
                                       aRestyleTracker,
                                       kidsDesiredA11yNotification,
                                       aVisibleKidsOfHiddenElement,
                                       aTreeMatchContext);
               }
             }
@@ -2638,18 +2635,16 @@ ElementRestyler::Restyle(nsPresContext  
                                              content, content->GetNextSibling());
           }
           aVisibleKidsOfHiddenElement.Clear();
         }
       }
 #endif
     }
   }
-
-  return aMinChange;
 }
 
 void
 RestyleManager::ComputeStyleChangeFor(nsIFrame*          aFrame,
                                       nsStyleChangeList* aChangeList,
                                       nsChangeHint       aMinChange,
                                       RestyleTracker&    aRestyleTracker,
                                       bool               aRestyleDescendants)
@@ -2681,27 +2676,26 @@ RestyleManager::ComputeStyleChangeFor(ns
   treeMatchContext.InitAncestors(parentElement);
   nsTArray<nsIContent*> visibleKidsOfHiddenElement;
   do {
     // Outer loop over special siblings
     do {
       // Inner loop over next-in-flows of the current frame
       ElementRestyler restyler;
 
-      nsChangeHint frameChange =
-        restyler.Restyle(mPresContext, frame, nullptr,
+      restyler.Restyle(mPresContext, frame, nullptr,
                               aChangeList, aMinChange, nsChangeHint(0),
                               aRestyleDescendants ?
                                 eRestyle_Subtree : eRestyle_Self,
                               aRestyleTracker,
                               eSendAllNotifications,
                               visibleKidsOfHiddenElement,
                               treeMatchContext);
 
-      if (frameChange & nsChangeHint_ReconstructFrame) {
+      if (restyler.mMinChange & nsChangeHint_ReconstructFrame) {
         // If it's going to cause a framechange, then don't bother
         // with the continuations or special siblings since they'll be
         // clobbered by the frame reconstruct anyway.
         NS_ASSERTION(!frame->GetPrevContinuation(),
                      "continuing frame had more severe impact than first-in-flow");
         return;
       }
 
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -270,41 +270,40 @@ private:
 
 /**
  * An ElementRestyler is created for *each* element in a subtree that we
  * recompute styles for.
  */
 class ElementRestyler MOZ_FINAL {
 public:
   // Construct for the root of the subtree that we're restyling.
-  ElementRestyler();
+  ElementRestyler(nsChangeHint aMinChange);
 
   // Construct for an element whose parent is being restyled.
   ElementRestyler(const ElementRestyler& aParentRestyler);
 
   /**
    * Restyle our frame's element and its subtree.
    *
    * Use eRestyle_Self for the aRestyleHint argument to mean
    * "reresolve our style context but not kids", use eRestyle_Subtree
    * to mean "reresolve our style context and kids", and use
    * nsRestyleHint(0) to mean recompute a new style context for our
    * current parent and existing rulenode, and the same for kids.
    */
-  nsChangeHint Restyle(nsPresContext     *aPresContext,
-                       nsIFrame          *aFrame,
-                       nsIContent        *aParentContent,
-                       nsStyleChangeList *aChangeList,
-                       nsChangeHint       aMinChange,
-                       nsChangeHint       aParentFrameHintsNotHandledForDescendants,
-                       nsRestyleHint      aRestyleHint,
-                       RestyleTracker&    aRestyleTracker,
-                       DesiredA11yNotifications aDesiredA11yNotifications,
-                       nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
-                       TreeMatchContext &aTreeMatchContext);
+  void Restyle(nsPresContext     *aPresContext,
+               nsIFrame          *aFrame,
+               nsIContent        *aParentContent,
+               nsStyleChangeList *aChangeList,
+               nsChangeHint       aParentFrameHintsNotHandledForDescendants,
+               nsRestyleHint      aRestyleHint,
+               RestyleTracker&    aRestyleTracker,
+               DesiredA11yNotifications aDesiredA11yNotifications,
+               nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
+               TreeMatchContext &aTreeMatchContext);
 
 private:
   enum DesiredA11yNotifications {
     eSkipNotifications,
     eSendAllNotifications,
     eNotifyIfShown
   };
 
@@ -313,18 +312,21 @@ private:
     eNotifyShown,
     eNotifyHidden
   };
 
   void CaptureChange(nsStyleContext* aOldContext,
                      nsStyleContext* aNewContext,
                      nsIFrame* aFrame, nsIContent* aContent,
                      nsStyleChangeList* aChangeList,
-                     /*inout*/nsChangeHint &aMinChange,
                      /*in*/nsChangeHint aParentHintsNotHandledForDescendants,
                      /*out*/nsChangeHint &aHintsNotHandledForDescendants,
                      nsChangeHint aChangeToAssume);
 
+private:
+  // We need to generate a new change list entry for every frame whose
+  // style comparision returns a hint other than one of these hints.
+  nsChangeHint mMinChange;
 };
 
 } // namespace mozilla
 
 #endif /* mozilla_RestyleManager_h */
