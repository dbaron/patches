From: L. David Baron <dbaron@dbaron.org>

Handle failure of GatherIdent, which can happen (starting with the next patch) fail when the character sequence is not an identifier.  Additionally, change the tokenization of a hash (#) followed by a non-name character or EOF to tokenize as DELIM (eCSSToken_Symbol) rather than as eCSSToken_Hash.  This only changes the behavior in the EOF case, because the only caller (color parsing) that accepts eCSSToken_Hash (rather than only eCSSToken_ID) checks the length. (Bug 384672, patch 2)

diff --git a/layout/style/nsCSSScanner.cpp b/layout/style/nsCSSScanner.cpp
--- a/layout/style/nsCSSScanner.cpp
+++ b/layout/style/nsCSSScanner.cpp
@@ -1066,16 +1066,20 @@ nsCSSScanner::ParseAndAppendEscape(nsStr
 }
 
 /**
  * Gather up the characters in an identifier. The identfier was
  * started by "aChar" which will be appended to aIdent. The result
  * will be aIdent with all of the identifier characters appended
  * until the first non-identifier character is seen. The termination
  * character is unread for the future re-reading.
+ *
+ * Returns failure when the character sequence does not form an ident at
+ * all, in which case the caller is responsible for pushing back or
+ * otherwise handling aChar.  (This occurs only when aChar is '\'.)
  */
 PRBool
 nsCSSScanner::GatherIdent(PRInt32 aChar, nsString& aIdent)
 {
   if (aChar == CSS_ESCAPE) {
     ParseAndAppendEscape(aIdent, false);
   }
   else if (0 < aChar) {
@@ -1112,43 +1116,50 @@ nsCSSScanner::GatherIdent(PRInt32 aChar,
     }
   }
   return PR_TRUE;
 }
 
 PRBool
 nsCSSScanner::ParseRef(PRInt32 aChar, nsCSSToken& aToken)
 {
-  aToken.mIdent.SetLength(0);
-  aToken.mType = eCSSToken_Ref;
+  // Fall back for when we don't have name characters following:
+  aToken.mType = eCSSToken_Symbol;
+  aToken.mSymbol = aChar;
+
   PRInt32 ch = Read();
   if (ch < 0) {
-    return PR_FALSE;
+    return PR_TRUE;
   }
   if (IsIdent(ch) || ch == CSS_ESCAPE) {
     // First char after the '#' is a valid ident char (or an escape),
     // so it makes sense to keep going
-    if (StartsIdent(ch, Peek())) {
-      aToken.mType = eCSSToken_ID;
+    nsCSSTokenType type =
+      StartsIdent(ch, Peek()) ? eCSSToken_ID : eCSSToken_Ref;
+    aToken.mIdent.SetLength(0);
+    if (GatherIdent(ch, aToken.mIdent)) {
+      aToken.mType = type;
+      return PR_TRUE;
     }
-    return GatherIdent(ch, aToken.mIdent);
   }
 
   // No ident chars after the '#'.  Just unread |ch| and get out of here.
   Pushback(ch);
   return PR_TRUE;
 }
 
 PRBool
 nsCSSScanner::ParseIdent(PRInt32 aChar, nsCSSToken& aToken)
 {
   nsString& ident = aToken.mIdent;
   ident.SetLength(0);
   if (!GatherIdent(aChar, ident)) {
-    return PR_FALSE;
+    aToken.mType = eCSSToken_Symbol;
+    aToken.mSymbol = aChar;
+    return PR_TRUE;
   }
 
   nsCSSTokenType tokenType = eCSSToken_Ident;
   // look for functions (ie: "ident(")
   if (Peek() == PRUnichar('(')) {
     Read();
     tokenType = eCSSToken_Function;
 
@@ -1162,17 +1173,21 @@ nsCSSScanner::ParseIdent(PRInt32 aChar, 
   return PR_TRUE;
 }
 
 PRBool
 nsCSSScanner::ParseAtKeyword(PRInt32 aChar, nsCSSToken& aToken)
 {
   aToken.mIdent.SetLength(0);
   aToken.mType = eCSSToken_AtKeyword;
-  return GatherIdent(0, aToken.mIdent);
+  if (!GatherIdent(0, aToken.mIdent)) {
+    aToken.mType = eCSSToken_Symbol;
+    aToken.mSymbol = PRUnichar('@');
+  }
+  return PR_TRUE;
 }
 
 PRBool
 nsCSSScanner::ParseNumber(PRInt32 c, nsCSSToken& aToken)
 {
   NS_PRECONDITION(c == '.' || c == '+' || c == '-' || IsDigit(c),
                   "Why did we get called?");
   aToken.mHasSign = (c == '+' || c == '-');
@@ -1282,20 +1297,19 @@ nsCSSScanner::ParseNumber(PRInt32 c, nsC
   }
 
   nsString& ident = aToken.mIdent;
   ident.Truncate();
 
   // Look at character that terminated the number
   if (c >= 0) {
     if (StartsIdent(c, Peek())) {
-      if (!GatherIdent(c, ident)) {
-        return PR_FALSE;
+      if (GatherIdent(c, ident)) {
+        type = eCSSToken_Dimension;
       }
-      type = eCSSToken_Dimension;
     } else if ('%' == c) {
       type = eCSSToken_Percentage;
       value = value / 100.0f;
       aToken.mIntegerValid = PR_FALSE;
     } else {
       // Put back character that stopped numeric scan
       Pushback(c);
     }
diff --git a/layout/style/test/test_selectors.html b/layout/style/test/test_selectors.html
--- a/layout/style/test/test_selectors.html
+++ b/layout/style/test/test_selectors.html
@@ -228,46 +228,60 @@ function run() {
             is(clonewin.getComputedStyle(should_match, "").zIndex, zi,
                "selector " + selector + " was cloned correctly");
             var ser3 = links[0].sheet.cssRules[1].selectorText;
             is(ser3, ser1,
                "selector " + selector + " serializes correctly after cloning");
         });
     }
 
+    function test_unparseable_via_api(selector)
+    {
+        try {
+          // Test that it is also unparseable when followed by EOF.
+          ifdoc.body.mozMatchesSelector(selector);
+          ok(false, "selector '" + selector + "' plus EOF is parse error");
+        } catch(ex) {
+          is(ex.code, DOMException.SYNTAX_ERR,
+             "selector '" + selector + "' plus EOF is parse error");
+        }
+    }
+
     function test_balanced_unparseable(selector)
     {
         var zi1 = ++gCounter;
         var zi2 = ++gCounter;
         ifdoc.body.innerHTML = "<p></p><div></div>";
         style_text.data = "p, " + selector + "{ z-index: " + zi1 + " }" +
                           "div { z-index: " + zi2 + " }";
         var should_not_match = ifdoc.getElementsByTagName("p")[0];
         var should_match = ifdoc.getElementsByTagName("div")[0];
         is(ifwin.getComputedStyle(should_not_match, "").zIndex, "auto",
            "selector " + selector + " was a parser error");
         is(ifwin.getComputedStyle(should_match, "").zIndex, zi2,
            "selector " + selector + " error was recovered from");
         ifdoc.body.innerHTML = "";
         style_text.data = "";
+        test_unparseable_via_api(selector);
     }
 
     function test_unbalanced_unparseable(selector)
     {
         var zi1 = ++gCounter;
         var zi2 = ++gCounter;
         ifdoc.body.innerHTML = "<p></p>";
         style_text.data = "p, " + selector + "{ z-index: " + zi1 + " }";
         var should_not_match = ifdoc.getElementsByTagName("p")[0];
         is(ifwin.getComputedStyle(should_not_match, "").zIndex, "auto",
            "selector " + selector + " was a parser error");
         is(style_text.parentNode.sheet.cssRules.length, 0,
            "sheet should have no rules since " + selector + " is parse error");
         ifdoc.body.innerHTML = "";
         style_text.data = "";
+        test_unparseable_via_api(selector);
     }
 
 
     // [attr= ] selector
     test_parseable("[attr=\"x\"]");
     test_parseable("[attr='x']");
     test_parseable("[attr=x]");
     test_parseable("[attr=\"\"]");
@@ -886,16 +900,26 @@ function run() {
                           "<table></table>" +
                           "<table frame='border'></table>" +
                           "<table border='0'></table>" +
                           "<table border='0pt'></table>" +
                           "<table border='3pt'></table>",
                           bodychildset([2, 3, 8]),
                           bodychildset([0, 1, 4, 5, 6, 7]));
 
+    // Test that we don't tokenize an empty HASH.
+    test_balanced_unparseable("#");
+    test_balanced_unparseable("# ");
+    test_balanced_unparseable("#, p");
+    test_balanced_unparseable("# , p");
+    test_balanced_unparseable("p #");
+    test_balanced_unparseable("p # ");
+    test_balanced_unparseable("p #, p");
+    test_balanced_unparseable("p # , p");
+
     run_deferred_tests();
 }
 
 var deferred_tests = [];
 
 function defer_clonedoc_tests(docurl, onloadfunc)
 {
     deferred_tests.push( { docurl: docurl, onloadfunc: onloadfunc } );
