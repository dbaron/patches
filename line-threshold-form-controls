From: L. David Baron <dbaron@dbaron.org>

Make effect of form controls on font size inflation text threshold not depend on user changes to their value.  (Bug 747857)

diff --git a/layout/forms/nsListControlFrame.h b/layout/forms/nsListControlFrame.h
--- a/layout/forms/nsListControlFrame.h
+++ b/layout/forms/nsListControlFrame.h
@@ -401,20 +401,22 @@ protected:
   bool     SingleSelection(PRInt32 aClickedIndex, bool aDoToggle);
   bool     ExtendedSelection(PRInt32 aStartIndex, PRInt32 aEndIndex,
                              bool aClearAll);
   bool     PerformSelection(PRInt32 aClickedIndex, bool aIsShift,
                             bool aIsControl);
   bool     HandleListSelection(nsIDOMEvent * aDOMEvent, PRInt32 selectedIndex);
   void     InitSelectionRange(PRInt32 aClickedIndex);
 
+public:
   nsSelectsAreaFrame* GetOptionsContainer() const {
     return static_cast<nsSelectsAreaFrame*>(GetScrolledFrame());
   }
 
+protected:
   nscoord HeightOfARow() {
     return GetOptionsContainer()->HeightOfARow();
   }
   
   // Data Members
   PRInt32      mStartSelectionIndex;
   PRInt32      mEndSelectionIndex;
 
diff --git a/layout/generic/nsFontInflationData.cpp b/layout/generic/nsFontInflationData.cpp
--- a/layout/generic/nsFontInflationData.cpp
+++ b/layout/generic/nsFontInflationData.cpp
@@ -36,16 +36,19 @@
  * ***** END LICENSE BLOCK ***** */
 
 /* Per-block-formatting-context manager of font size inflation for pan and zoom UI. */
 
 #include "nsFontInflationData.h"
 #include "FramePropertyTable.h"
 #include "nsTextFragment.h"
 #include "nsIFormControlFrame.h"
+#include "nsTextControlFrame.h"
+#include "nsListControlFrame.h"
+#include "nsComboboxControlFrame.h"
 #include "nsHTMLReflowState.h"
 #include "nsTextFrameUtils.h"
 
 using namespace mozilla;
 using namespace mozilla::layout;
 
 static void
 DestroyFontInflationData(void *aPropertyValue)
@@ -294,16 +297,50 @@ void
 nsFontInflationData::ScanText()
 {
   mTextDirty = false;
   mTextAmount = 0;
   ScanTextIn(mBFCFrame);
   mInflationEnabled = mTextAmount >= mTextThreshold;
 }
 
+static PRUint32
+DoCharCountOfLargestOption(nsIFrame *aContainer)
+{
+  PRUint32 result = 0;
+  for (nsIFrame* option = aContainer->GetFirstPrincipalChild();
+       option; option = option->GetNextSibling()) {
+    PRUint32 optionResult;
+    if (option->GetContent()->IsHTML(nsGkAtoms::optgroup)) {
+      optionResult = DoCharCountOfLargestOption(option);
+    } else {
+      // REVIEW: Check the frame structure for this!
+      nsIFrame *optionChild = option->GetFirstPrincipalChild();
+      if (optionChild && optionChild->GetType() == nsGkAtoms::textFrame) {
+        optionResult = nsTextFrameUtils::
+          ComputeApproximateLengthWithWhitespaceCompression(
+            optionChild->GetContent(), optionChild->GetStyleText());
+      } else {
+        optionResult = 0;
+      }
+    }
+    if (optionResult > result) {
+      result = optionResult;
+    }
+  }
+  return result;
+}
+
+static PRUint32
+CharCountOfLargestOption(nsIFrame *aListControlFrame)
+{
+  return DoCharCountOfLargestOption(
+    static_cast<nsListControlFrame*>(aListControlFrame)->GetOptionsContainer());
+}
+
 void
 nsFontInflationData::ScanTextIn(nsIFrame *aFrame)
 {
   // NOTE: This function has a similar structure to FindEdgeInflatableFrameIn!
 
   // FIXME: Should probably only scan the text that's actually going to
   // be inflated!
 
@@ -312,29 +349,47 @@ nsFontInflationData::ScanTextIn(nsIFrame
     nsFrameList::Enumerator kids(lists.CurrentList());
     for (; !kids.AtEnd(); kids.Next()) {
       nsIFrame *kid = kids.get();
       if (kid->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT) {
         // Goes in a different set of inflation data.
         continue;
       }
 
-      if (kid->GetType() == nsGkAtoms::textFrame) {
+      nsIAtom *fType = kid->GetType();
+      if (fType == nsGkAtoms::textFrame) {
         nsIContent *content = kid->GetContent();
         if (content && kid == content->GetPrimaryFrame()) {
           PRUint32 len = nsTextFrameUtils::
             ComputeApproximateLengthWithWhitespaceCompression(
               content, kid->GetStyleText());
           if (len != 0) {
             nscoord fontSize = kid->GetStyleFont()->mFont.size;
             if (fontSize > 0) {
               mTextAmount += fontSize * len;
             }
           }
         }
+      } else if (fType == nsGkAtoms::textInputFrame) {
+        // We don't want changes to the amount of text in a text input
+        // to change what we count towards inflation.
+        nscoord fontSize = kid->GetStyleFont()->mFont.size;
+        PRInt32 charCount = static_cast<nsTextControlFrame*>(kid)->GetCols();
+        mTextAmount += charCount * fontSize;
+      } else if (fType == nsGkAtoms::comboboxControlFrame) {
+        // Don't just recurse down to the list control inside, since we
+        // need to exclude the display frame.
+        nscoord fontSize = kid->GetStyleFont()->mFont.size;
+        PRInt32 charCount = CharCountOfLargestOption(
+          static_cast<nsComboboxControlFrame*>(kid)->GetDropDown());
+        mTextAmount += charCount * fontSize;
+      } else if (fType == nsGkAtoms::listControlFrame) {
+        nscoord fontSize = kid->GetStyleFont()->mFont.size;
+        PRInt32 charCount = CharCountOfLargestOption(kid);
+        mTextAmount += charCount * fontSize;
       } else {
         // recursive step
         ScanTextIn(kid);
       }
 
       if (mTextAmount >= mTextThreshold) {
         return;
       }
