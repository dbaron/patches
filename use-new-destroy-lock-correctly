From: L. David Baron <dbaron@dbaron.org>

Use nsAutoLock::NewLock, nsAutoLock::DestroyLock, nsAutoMonitor::NewMonitor, and nsAutoMonitor::DestroyMonitor as required by the API.  (Bug 594666)

diff --git a/content/media/nsMediaDecoder.cpp b/content/media/nsMediaDecoder.cpp
--- a/content/media/nsMediaDecoder.cpp
+++ b/content/media/nsMediaDecoder.cpp
@@ -84,26 +84,26 @@ nsMediaDecoder::nsMediaDecoder() :
   mShuttingDown(PR_FALSE)
 {
   MOZ_COUNT_CTOR(nsMediaDecoder);
 }
 
 nsMediaDecoder::~nsMediaDecoder()
 {
   if (mVideoUpdateLock) {
-    PR_DestroyLock(mVideoUpdateLock);
+    nsAutoLock::DestroyLock(mVideoUpdateLock);
     mVideoUpdateLock = nsnull;
   }
   MOZ_COUNT_DTOR(nsMediaDecoder);
 }
 
 PRBool nsMediaDecoder::Init(nsHTMLMediaElement* aElement)
 {
   mElement = aElement;
-  mVideoUpdateLock = PR_NewLock();
+  mVideoUpdateLock = nsAutoLock::NewLock("nsMediaDecoder::mVideoUpdateLock");
 
   return mVideoUpdateLock != nsnull;
 }
 
 void nsMediaDecoder::Shutdown()
 {
   StopProgress();
   mElement = nsnull;
diff --git a/embedding/components/windowwatcher/src/nsWindowWatcher.cpp b/embedding/components/windowwatcher/src/nsWindowWatcher.cpp
--- a/embedding/components/windowwatcher/src/nsWindowWatcher.cpp
+++ b/embedding/components/windowwatcher/src/nsWindowWatcher.cpp
@@ -344,23 +344,23 @@ nsWindowWatcher::nsWindowWatcher() :
 
 nsWindowWatcher::~nsWindowWatcher()
 {
   // delete data
   while (mOldestWindow)
     RemoveWindow(mOldestWindow);
 
   if (mListLock)
-    PR_DestroyLock(mListLock);
+    nsAutoLock::DestroyLock(mListLock);
 }
 
 nsresult
 nsWindowWatcher::Init()
 {
-  mListLock = PR_NewLock();
+  mListLock = nsAutoLock::NewLock("nsWindowWatcher::mListLock");
   if (!mListLock)
     return NS_ERROR_OUT_OF_MEMORY;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindowWatcher::OpenWindow(nsIDOMWindow *aParent,
                             const char *aUrl,
diff --git a/extensions/java/xpcom/src/nsJavaXPCOMBindingUtils.cpp b/extensions/java/xpcom/src/nsJavaXPCOMBindingUtils.cpp
--- a/extensions/java/xpcom/src/nsJavaXPCOMBindingUtils.cpp
+++ b/extensions/java/xpcom/src/nsJavaXPCOMBindingUtils.cpp
@@ -329,17 +329,17 @@ InitializeJavaGlobals(JNIEnv *env)
       }
     }
     if (NS_FAILED(rv)) {
       NS_WARNING("Failed to populate JavaKeywords hash");
       goto init_error;
     }
   }
 
-  gJavaXPCOMLock = PR_NewLock();
+  gJavaXPCOMLock = nsAutoLock::NewLock("gJavaXPCOMLock");
   gJavaXPCOMInitialized = PR_TRUE;
   return PR_TRUE;
 
 init_error:
   // If we encounter an error during initialization, then free any globals that
   // were allocated, and return false.
   FreeJavaGlobals(env);
   return PR_FALSE;
@@ -435,17 +435,17 @@ FreeJavaGlobals(JNIEnv* env)
 
   if (gJavaKeywords) {
     delete gJavaKeywords;
     gJavaKeywords = nsnull;
   }
 
   if (tempLock) {
     PR_Unlock(tempLock);
-    PR_DestroyLock(tempLock);
+    nsAutoLock::DestroyLock(tempLock);
   }
 }
 
 
 /**************************************
  *  Java<->XPCOM object mappings
  **************************************/
 
diff --git a/intl/strres/src/nsStringBundle.cpp b/intl/strres/src/nsStringBundle.cpp
--- a/intl/strres/src/nsStringBundle.cpp
+++ b/intl/strres/src/nsStringBundle.cpp
@@ -76,17 +76,17 @@
 #include "nsCRT.h"
 
 static NS_DEFINE_CID(kErrorServiceCID, NS_ERRORSERVICE_CID);
 static NS_DEFINE_CID(kPersistentPropertiesCID, NS_IPERSISTENTPROPERTIES_CID);
 
 nsStringBundle::~nsStringBundle()
 {
   if (mMonitor)
-    PR_DestroyMonitor(mMonitor);
+    nsAutoMonitor::DestroyMonitor(mMonitor);
 }
 
 nsStringBundle::nsStringBundle(const char* aURLSpec,
                                nsIStringBundleOverride* aOverrideStrings) :
   mPropertiesURL(aURLSpec),
   mOverrideStrings(aOverrideStrings),
   mMonitor(0),
   mAttemptedLoad(PR_FALSE),
diff --git a/js/src/xpconnect/src/xpcthreadcontext.cpp b/js/src/xpconnect/src/xpcthreadcontext.cpp
--- a/js/src/xpconnect/src/xpcthreadcontext.cpp
+++ b/js/src/xpconnect/src/xpcthreadcontext.cpp
@@ -414,17 +414,17 @@ XPCPerThreadData::~XPCPerThreadData()
             }
         }
         if (!gThreads)
             doDestroyLock = PR_TRUE;
     }
 
     if(gLock && doDestroyLock)
     {
-        PR_DestroyLock(gLock);
+        nsAutoLock::DestroyLock(gLock);
         gLock = nsnull;
     }
 }
 
 static void
 xpc_ThreadDataDtorCB(void* ptr)
 {
     XPCPerThreadData* data = (XPCPerThreadData*) ptr;
@@ -460,17 +460,17 @@ void XPCPerThreadData::MarkAutoRootsAfte
 // static
 XPCPerThreadData*
 XPCPerThreadData::GetDataImpl(JSContext *cx)
 {
     XPCPerThreadData* data;
 
     if(!gLock)
     {
-        gLock = PR_NewLock();
+        gLock = nsAutoLock::NewLock("XPCPerThreadData::gLock");
         if(!gLock)
             return nsnull;
     }
 
     if(gTLSIndex == BAD_TLS_INDEX)
     {
         nsAutoLock lock(gLock);
         // check again now that we have the lock...
diff --git a/modules/libjar/nsJAR.cpp b/modules/libjar/nsJAR.cpp
--- a/modules/libjar/nsJAR.cpp
+++ b/modules/libjar/nsJAR.cpp
@@ -167,17 +167,17 @@ nsrefcnt nsJAR::Release(void)
 NS_IMETHODIMP
 nsJAR::Open(nsIFile* zipFile)
 {
   NS_ENSURE_ARG_POINTER(zipFile);
   if (mLock) return NS_ERROR_FAILURE; // Already open!
 
   mZipFile = zipFile;
 
-  mLock = PR_NewLock();
+  mLock = nsAutoLock::NewLock("nsJAR::mLock");
   NS_ENSURE_TRUE(mLock, NS_ERROR_OUT_OF_MEMORY);
   
 #ifdef MOZ_OMNIJAR
   // The omnijar is special, it is opened early on and closed late
   // this avoids reopening it
   PRBool equals;
   nsresult rv = zipFile->Equals(mozilla::OmnijarPath(), &equals);
   if (NS_SUCCEEDED(rv) && equals) {
@@ -198,17 +198,17 @@ nsJAR::OpenInner(nsIZipReader *aZipReade
   PRBool exist;
   nsresult rv = aZipReader->HasEntry(nsDependentCString(aZipEntry), &exist);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exist, NS_ERROR_FILE_NOT_FOUND);
 
   rv = aZipReader->GetFile(getter_AddRefs(mZipFile));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  mLock = PR_NewLock();
+  mLock = nsAutoLock::NewLock("nsJAR::mLock");
   NS_ENSURE_TRUE(mLock, NS_ERROR_OUT_OF_MEMORY);
 
   mOuterZipEntry.Assign(aZipEntry);
 
   nsRefPtr<nsZipHandle> handle;
   rv = nsZipHandle::Init(static_cast<nsJAR*>(aZipReader)->mZip.get(), aZipEntry,
                          getter_AddRefs(handle));
   if (NS_FAILED(rv))
@@ -224,17 +224,17 @@ nsJAR::GetFile(nsIFile* *result)
   NS_IF_ADDREF(*result);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsJAR::Close()
 {
   if (mLock) {
-    PR_DestroyLock(mLock);
+    nsAutoLock::DestroyLock(mLock);
     mLock = nsnull;
   }
 
   mParsedManifest = PR_FALSE;
   mManifestData.Reset();
   mGlobalStatus = JAR_MANIFEST_NOT_PARSED;
   mTotalItemsInManifest = 0;
   mOuterZipEntry.Truncate(0);
@@ -1083,32 +1083,32 @@ nsZipReaderCache::Init(PRUint32 cacheSiz
   if (os)
   {
     os->AddObserver(this, "memory-pressure", PR_TRUE);
     os->AddObserver(this, "chrome-flush-caches", PR_TRUE);
     os->AddObserver(this, "flush-cache-entry", PR_TRUE);
   }
 // ignore failure of the observer registration.
 
-  mLock = PR_NewLock();
+  mLock = nsAutoLock::NewLock("nsZipReaderCache::mLock");
   return mLock ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 }
 
 static PRBool
 DropZipReaderCache(nsHashKey *aKey, void *aData, void* closure)
 {
   nsJAR* zip = (nsJAR*)aData;
   zip->SetZipReaderCache(nsnull);
   return PR_TRUE;
 }
 
 nsZipReaderCache::~nsZipReaderCache()
 {
   if (mLock)
-    PR_DestroyLock(mLock);
+    nsAutoLock::DestroyLock(mLock);
   mZips.Enumerate(DropZipReaderCache, nsnull);
 
 #ifdef ZIP_CACHE_HIT_RATE
   printf("nsZipReaderCache size=%d hits=%d lookups=%d rate=%f%% flushes=%d missed %d\n",
          mCacheSize, mZipCacheHits, mZipCacheLookups, 
          (float)mZipCacheHits / mZipCacheLookups, 
          mZipCacheFlushes, mZipSyncMisses);
 #endif
diff --git a/netwerk/base/src/nsAsyncStreamCopier.cpp b/netwerk/base/src/nsAsyncStreamCopier.cpp
--- a/netwerk/base/src/nsAsyncStreamCopier.cpp
+++ b/netwerk/base/src/nsAsyncStreamCopier.cpp
@@ -67,17 +67,17 @@ nsAsyncStreamCopier::nsAsyncStreamCopier
 #endif
     LOG(("Creating nsAsyncStreamCopier @%x\n", this));
 }
 
 nsAsyncStreamCopier::~nsAsyncStreamCopier()
 {
     LOG(("Destroying nsAsyncStreamCopier @%x\n", this));
     if (mLock)
-        PR_DestroyLock(mLock);
+        nsAutoLock::DestroyLock(mLock);
 }
 
 PRBool
 nsAsyncStreamCopier::IsComplete(nsresult *status)
 {
     nsAutoLock lock(mLock);
     if (status)
         *status = mStatus;
@@ -225,17 +225,17 @@ nsAsyncStreamCopier::Init(nsIInputStream
                           PRBool sinkBuffered,
                           PRUint32 chunkSize,
                           PRBool closeSource,
                           PRBool closeSink)
 {
     NS_ASSERTION(sourceBuffered || sinkBuffered, "at least one stream must be buffered");
 
     NS_ASSERTION(!mLock, "already initialized");
-    mLock = PR_NewLock();
+    mLock = nsAutoLock::NewLock("nsAsyncStreamCopier::mLock");
     if (!mLock)
         return NS_ERROR_OUT_OF_MEMORY;
 
     if (chunkSize == 0)
         chunkSize = nsIOService::gDefaultSegmentSize;
     mChunkSize = chunkSize;
 
     mSource = source;
diff --git a/netwerk/base/src/nsIOThreadPool.cpp b/netwerk/base/src/nsIOThreadPool.cpp
--- a/netwerk/base/src/nsIOThreadPool.cpp
+++ b/netwerk/base/src/nsIOThreadPool.cpp
@@ -106,17 +106,17 @@ nsIOThreadPool::Init()
     if (!gIOThreadPoolLog)
         gIOThreadPoolLog = PR_NewLogModule("nsIOThreadPool");
 #endif
 
     mNumThreads = 0;
     mNumIdleThreads = 0;
     mShutdown = PR_FALSE;
 
-    mLock = PR_NewLock();
+    mLock = nsAutoLock::NewLock("nsIOThreadPool::mLock");
     if (!mLock)
         return NS_ERROR_OUT_OF_MEMORY;
 
     mIdleThreadCV = PR_NewCondVar(mLock);
     if (!mIdleThreadCV)
         return NS_ERROR_OUT_OF_MEMORY;
 
     mExitThreadCV = PR_NewCondVar(mLock);
@@ -141,17 +141,17 @@ nsIOThreadPool::~nsIOThreadPool()
     NS_ASSERTION(mNumThreads == 0, "leaking thread(s)");
 #endif
 
     if (mIdleThreadCV)
         PR_DestroyCondVar(mIdleThreadCV);
     if (mExitThreadCV)
         PR_DestroyCondVar(mExitThreadCV);
     if (mLock)
-        PR_DestroyLock(mLock);
+        nsAutoLock::DestroyLock(mLock);
 }
 
 void
 nsIOThreadPool::Shutdown()
 {
     LOG(("nsIOThreadPool::Shutdown\n"));
 
     // synchronize with background threads...
diff --git a/netwerk/base/src/nsServerSocket.cpp b/netwerk/base/src/nsServerSocket.cpp
--- a/netwerk/base/src/nsServerSocket.cpp
+++ b/netwerk/base/src/nsServerSocket.cpp
@@ -87,17 +87,17 @@ nsServerSocket::nsServerSocket()
   NS_IF_ADDREF(gSocketTransportService);
 }
 
 nsServerSocket::~nsServerSocket()
 {
   Close(); // just in case :)
 
   if (mLock)
-    PR_DestroyLock(mLock);
+    nsAutoLock::DestroyLock(mLock);
 
   // release our reference to the STS
   nsSocketTransportService *serv = gSocketTransportService;
   NS_IF_RELEASE(serv);
 }
 
 void
 nsServerSocket::OnMsgClose()
@@ -287,17 +287,17 @@ nsServerSocket::Init(PRInt32 aPort, PRBo
 
 NS_IMETHODIMP
 nsServerSocket::InitWithAddress(const PRNetAddr *aAddr, PRInt32 aBackLog)
 {
   NS_ENSURE_TRUE(mFD == nsnull, NS_ERROR_ALREADY_INITIALIZED);
 
   if (!mLock)
   {
-    mLock = PR_NewLock();
+    mLock = nsAutoLock::NewLock("nsServerSocket::mLock");
     if (!mLock)
       return NS_ERROR_OUT_OF_MEMORY;
   }
 
   //
   // configure listening socket...
   //
 
diff --git a/netwerk/base/src/nsSocketTransport2.cpp b/netwerk/base/src/nsSocketTransport2.cpp
--- a/netwerk/base/src/nsSocketTransport2.cpp
+++ b/netwerk/base/src/nsSocketTransport2.cpp
@@ -708,17 +708,17 @@ nsSocketTransport::nsSocketTransport()
     , mProxyTransparent(PR_FALSE)
     , mProxyTransparentResolvesHost(PR_FALSE)
     , mConnectionFlags(0)
     , mState(STATE_CLOSED)
     , mAttached(PR_FALSE)
     , mInputClosed(PR_TRUE)
     , mOutputClosed(PR_TRUE)
     , mResolving(PR_FALSE)
-    , mLock(PR_NewLock())
+    , mLock(nsAutoLock::NewLock("nsSocketTransport::mLock"))
     , mFD(nsnull)
     , mFDref(0)
     , mFDconnected(PR_FALSE)
     , mInput(this)
     , mOutput(this)
     , mQoSBits(0x00)
 {
     SOCKET_LOG(("creating nsSocketTransport @%x\n", this));
@@ -737,17 +737,17 @@ nsSocketTransport::~nsSocketTransport()
     if (mTypes) {
         PRUint32 i;
         for (i=0; i<mTypeCount; ++i)
             PL_strfree(mTypes[i]);
         free(mTypes);
     }
 
     if (mLock)
-        PR_DestroyLock(mLock);
+        nsAutoLock::DestroyLock(mLock);
  
     nsSocketTransportService *serv = gSocketTransportService;
     NS_RELEASE(serv); // nulls argument
 }
 
 nsresult
 nsSocketTransport::Init(const char **types, PRUint32 typeCount,
                         const nsACString &host, PRUint16 port,
diff --git a/netwerk/base/src/nsTransportUtils.cpp b/netwerk/base/src/nsTransportUtils.cpp
--- a/netwerk/base/src/nsTransportUtils.cpp
+++ b/netwerk/base/src/nsTransportUtils.cpp
@@ -52,27 +52,27 @@ public:
     NS_DECL_ISUPPORTS
     NS_DECL_NSITRANSPORTEVENTSINK
 
     nsTransportEventSinkProxy(nsITransportEventSink *sink,
                               nsIEventTarget *target,
                               PRBool coalesceAll)
         : mSink(sink)
         , mTarget(target)
-        , mLock(PR_NewLock())
+        , mLock(nsAutoLock::NewLock("nsTransportEventSinkProxy::mLock"))
         , mLastEvent(nsnull)
         , mCoalesceAll(coalesceAll)
     {
         NS_ADDREF(mSink);
     }
 
     virtual ~nsTransportEventSinkProxy()
     {
         if (mLock)
-            PR_DestroyLock(mLock);
+            nsAutoLock::DestroyLock(mLock);
     
         // our reference to mSink could be the last, so be sure to release
         // it on the target thread.  otherwise, we could get into trouble.
         NS_ProxyRelease(mTarget, mSink);
     }
 
     nsITransportEventSink           *mSink;
     nsCOMPtr<nsIEventTarget>         mTarget;
diff --git a/netwerk/dns/nsDNSService2.cpp b/netwerk/dns/nsDNSService2.cpp
--- a/netwerk/dns/nsDNSService2.cpp
+++ b/netwerk/dns/nsDNSService2.cpp
@@ -308,17 +308,17 @@ nsDNSSyncRequest::OnLookupComplete(nsHos
 nsDNSService::nsDNSService()
     : mLock(nsnull)
 {
 }
 
 nsDNSService::~nsDNSService()
 {
     if (mLock)
-        PR_DestroyLock(mLock);
+        nsAutoLock::DestroyLock(mLock);
 }
 
 NS_IMPL_THREADSAFE_ISUPPORTS3(nsDNSService, nsIDNSService, nsPIDNSService,
                               nsIObserver)
 
 NS_IMETHODIMP
 nsDNSService::Init()
 {
@@ -353,17 +353,17 @@ nsDNSService::Init()
         prefs->GetCharPref(kPrefIPv4OnlyDomains, getter_Copies(ipv4OnlyDomains));
         prefs->GetBoolPref(kPrefDisablePrefetch, &disablePrefetch);
 
         // If a manual proxy is in use, disable prefetch implicitly
         prefs->GetIntPref("network.proxy.type", &proxyType);
     }
 
     if (firstTime) {
-        mLock = PR_NewLock();
+        mLock = nsAutoLock::NewLock("nsDNSService::mLock");
         if (!mLock)
             return NS_ERROR_OUT_OF_MEMORY;
 
         // register as prefs observer
         if (prefs) {
             prefs->AddObserver(kPrefDnsCacheEntries, this, PR_FALSE);
             prefs->AddObserver(kPrefDnsCacheExpiration, this, PR_FALSE);
             prefs->AddObserver(kPrefEnableIDN, this, PR_FALSE);
diff --git a/netwerk/dns/nsHostResolver.cpp b/netwerk/dns/nsHostResolver.cpp
--- a/netwerk/dns/nsHostResolver.cpp
+++ b/netwerk/dns/nsHostResolver.cpp
@@ -350,27 +350,27 @@ nsHostResolver::nsHostResolver(PRUint32 
 }
 
 nsHostResolver::~nsHostResolver()
 {
     if (mIdleThreadCV)
         PR_DestroyCondVar(mIdleThreadCV);
 
     if (mLock)
-        PR_DestroyLock(mLock);
+        nsAutoLock::DestroyLock(mLock);
 
     PL_DHashTableFinish(&mDB);
 }
 
 nsresult
 nsHostResolver::Init()
 {
     NS_TIME_FUNCTION;
 
-    mLock = PR_NewLock();
+    mLock = nsAutoLock::NewLock("nsHostResolver::mLock");
     if (!mLock)
         return NS_ERROR_OUT_OF_MEMORY;
 
     mIdleThreadCV = PR_NewCondVar(mLock);
     if (!mIdleThreadCV)
         return NS_ERROR_OUT_OF_MEMORY;
 
     PL_DHashTableInit(&mDB, &gHostDB_ops, nsnull, sizeof(nsHostDBEnt), 0);
diff --git a/netwerk/protocol/http/nsHttp.cpp b/netwerk/protocol/http/nsHttp.cpp
--- a/netwerk/protocol/http/nsHttp.cpp
+++ b/netwerk/protocol/http/nsHttp.cpp
@@ -124,17 +124,17 @@ static const PLDHashTableOps ops = {
 
 // We put the atoms in a hash table for speedy lookup.. see ResolveAtom.
 nsresult
 nsHttp::CreateAtomTable()
 {
     NS_ASSERTION(!sAtomTable.ops, "atom table already initialized");
 
     if (!sLock) {
-        sLock = PR_NewLock();
+        sLock = nsAutoLock::NewLock("nsHttp::sLock");
         if (!sLock)
             return NS_ERROR_OUT_OF_MEMORY;
     }
 
     // The capacity for this table is initialized to a value greater than the
     // number of known atoms (NUM_HTTP_ATOMS) because we expect to encounter a
     // few random headers right off the bat.
     if (!PL_DHashTableInit(&sAtomTable, &ops, nsnull, sizeof(PLDHashEntryStub),
@@ -174,17 +174,17 @@ nsHttp::DestroyAtomTable()
 
     while (sHeapAtoms) {
         HttpHeapAtom *next = sHeapAtoms->next;
         free(sHeapAtoms);
         sHeapAtoms = next;
     }
 
     if (sLock) {
-        PR_DestroyLock(sLock);
+        nsAutoLock::DestroyLock(sLock);
         sLock = nsnull;
     }
 }
 
 // this function may be called from multiple threads
 nsHttpAtom
 nsHttp::ResolveAtom(const char *str)
 {
diff --git a/netwerk/protocol/http/nsHttpActivityDistributor.cpp b/netwerk/protocol/http/nsHttpActivityDistributor.cpp
--- a/netwerk/protocol/http/nsHttpActivityDistributor.cpp
+++ b/netwerk/protocol/http/nsHttpActivityDistributor.cpp
@@ -93,17 +93,17 @@ NS_IMPL_THREADSAFE_ISUPPORTS2(nsHttpActi
 nsHttpActivityDistributor::nsHttpActivityDistributor()
     : mLock(nsnull)
 {
 }
 
 nsHttpActivityDistributor::~nsHttpActivityDistributor()
 {
     if (mLock)
-        PR_DestroyLock(mLock);
+        nsAutoLock::DestroyLock(mLock);
 }
 
 NS_IMETHODIMP
 nsHttpActivityDistributor::ObserveActivity(nsISupports *aHttpChannel,
                                            PRUint32 aActivityType,
                                            PRUint32 aActivitySubtype,
                                            PRTime aTimestamp,
                                            PRUint64 aExtraSizeData,
@@ -156,14 +156,14 @@ nsHttpActivityDistributor::RemoveObserve
     return NS_OK;
 }
 
 nsresult
 nsHttpActivityDistributor::Init()
 {
     NS_ENSURE_TRUE(!mLock, NS_ERROR_ALREADY_INITIALIZED);
 
-    mLock = PR_NewLock();
+    mLock = nsAutoLock::NewLock("nsHttpActivityDistributor::mLock");
     if (!mLock)
         return NS_ERROR_OUT_OF_MEMORY;
 
     return NS_OK;
 }
diff --git a/netwerk/test/TestStreamTransport.cpp b/netwerk/test/TestStreamTransport.cpp
--- a/netwerk/test/TestStreamTransport.cpp
+++ b/netwerk/test/TestStreamTransport.cpp
@@ -85,17 +85,17 @@ public:
         : mLock(nsnull)
         , mInputCondition(NS_OK)
     {
     }
 
     virtual ~MyCopier()
     {
         if (mLock)
-            PR_DestroyLock(mLock);
+            nsAutoLock::DestroyLock(mLock);
         if (mInput)
             mInput->Close();
         if (mOutput)
             mOutput->Close();
     }
 
     // called on any thread
     NS_IMETHOD OnInputStreamReady(nsIAsyncInputStream *inStr)
@@ -146,17 +146,17 @@ public:
                     Close_Locked();
                 break;
             }
         }
     }
 
     nsresult AsyncCopy(nsITransport *srcTrans, nsITransport *destTrans)
     {
-        mLock = PR_NewLock();
+        mLock = nsAutoLock::NewLock("MyCopier::mLock");
         if (!mLock)
             return NS_ERROR_OUT_OF_MEMORY;
 
         nsresult rv;
 
         nsCOMPtr<nsIInputStream> inStr;
         rv = srcTrans->OpenInputStream(0, 0, 0, getter_AddRefs(inStr));
         if (NS_FAILED(rv)) return rv;
diff --git a/security/manager/ssl/src/nsNSSCallbacks.cpp b/security/manager/ssl/src/nsNSSCallbacks.cpp
--- a/security/manager/ssl/src/nsNSSCallbacks.cpp
+++ b/security/manager/ssl/src/nsNSSCallbacks.cpp
@@ -563,41 +563,41 @@ nsHTTPListener::nsHTTPListener()
   mResponsibleForDoneSignal(PR_FALSE),
   mLoadGroup(nsnull),
   mLoadGroupOwnerThread(nsnull)
 {
 }
 
 nsresult nsHTTPListener::InitLocks()
 {
-  mLock = PR_NewLock();
+  mLock = nsAutoLock::NewLock("nsHttpListener::mLock");
   if (!mLock)
     return NS_ERROR_OUT_OF_MEMORY;
   
   mCondition = PR_NewCondVar(mLock);
   if (!mCondition)
   {
-    PR_DestroyLock(mLock);
+    nsAutoLock::DestroyLock(mLock);
     mLock = nsnull;
     return NS_ERROR_OUT_OF_MEMORY;
   }
   
   return NS_OK;
 }
 
 nsHTTPListener::~nsHTTPListener()
 {
   if (mResponsibleForDoneSignal)
     send_done_signal();
 
   if (mCondition)
     PR_DestroyCondVar(mCondition);
   
   if (mLock)
-    PR_DestroyLock(mLock);
+    nsAutoLock::DestroyLock(mLock);
 
   if (mLoader) {
     nsCOMPtr<nsIThread> mainThread(do_GetMainThread());
     NS_ProxyRelease(mainThread, mLoader);
   }
 }
 
 NS_IMPL_THREADSAFE_ISUPPORTS1(nsHTTPListener, nsIStreamLoaderObserver)
diff --git a/security/manager/ssl/src/nsNSSCertCache.cpp b/security/manager/ssl/src/nsNSSCertCache.cpp
--- a/security/manager/ssl/src/nsNSSCertCache.cpp
+++ b/security/manager/ssl/src/nsNSSCertCache.cpp
@@ -42,17 +42,17 @@
 #include "nsIInterfaceRequestor.h"
 #include "nsNSSHelper.h"
 
 NS_IMPL_THREADSAFE_ISUPPORTS1(nsNSSCertCache, nsINSSCertCache)
 
 nsNSSCertCache::nsNSSCertCache()
 :mCertList(nsnull)
 {
-  mutex = PR_NewLock();
+  mutex = nsAutoLock::NewLock("nsNSSCertCache::mutex");
 }
 
 nsNSSCertCache::~nsNSSCertCache()
 {
   nsNSSShutDownPreventionLock locker;
   if (isAlreadyShutDown())
     return;
 
@@ -66,17 +66,17 @@ void nsNSSCertCache::virtualDestroyNSSRe
 }
 
 void nsNSSCertCache::destructorSafeDestroyNSSReference()
 {
   if (isAlreadyShutDown())
     return;
 
   if (mutex) {
-    PR_DestroyLock(mutex);
+    nsAutoLock::DestroyLock(mutex);
     mutex = nsnull;
   }
 }
 
 NS_IMETHODIMP
 nsNSSCertCache::CacheAllCerts()
 {
   nsNSSShutDownPreventionLock locker;
diff --git a/security/manager/ssl/src/nsNSSComponent.cpp b/security/manager/ssl/src/nsNSSComponent.cpp
--- a/security/manager/ssl/src/nsNSSComponent.cpp
+++ b/security/manager/ssl/src/nsNSSComponent.cpp
@@ -366,17 +366,17 @@ PRBool EnsureNSSInitialized(EnsureNSSOpe
     return PR_FALSE;
   }
 }
 
 nsNSSComponent::nsNSSComponent()
   :mNSSInitialized(PR_FALSE), mThreadList(nsnull),
    mSSLThread(NULL), mCertVerificationThread(NULL)
 {
-  mutex = PR_NewLock();
+  mutex = nsAutoLock::NewLock("nsNSSComponent::mutex");
   
 #ifdef PR_LOGGING
   if (!gPIPNSSLog)
     gPIPNSSLog = PR_NewLogModule("pipnss");
 #endif
   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent::ctor\n"));
   mUpdateTimerInitialized = PR_FALSE;
   crlDownloadTimerOn = PR_FALSE;
@@ -433,17 +433,17 @@ nsNSSComponent::~nsNSSComponent()
   // All cleanup code requiring services needs to happen in xpcom_shutdown
 
   ShutdownNSS();
   nsSSLIOLayerHelpers::Cleanup();
   --mInstanceCount;
   delete mShutdownObjectList;
 
   if (mutex) {
-    PR_DestroyLock(mutex);
+    nsAutoLock::DestroyLock(mutex);
     mutex = nsnull;
   }
 
   // We are being freed, drop the haveLoaded flag to re-enable
   // potential nss initialization later.
   EnsureNSSInitialized(nssShutdown);
 
   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent::dtor finished\n"));
diff --git a/security/manager/ssl/src/nsNSSIOLayer.cpp b/security/manager/ssl/src/nsNSSIOLayer.cpp
--- a/security/manager/ssl/src/nsNSSIOLayer.cpp
+++ b/security/manager/ssl/src/nsNSSIOLayer.cpp
@@ -931,17 +931,17 @@ void nsSSLIOLayerHelpers::Cleanup()
     delete mRenegoUnrestrictedSites;
     mRenegoUnrestrictedSites = nsnull;
   }
 
   if (mSharedPollableEvent)
     PR_DestroyPollableEvent(mSharedPollableEvent);
 
   if (mutex) {
-    PR_DestroyLock(mutex);
+    nsAutoLock::DestroyLock(mutex);
     mutex = nsnull;
   }
 
   if (mHostsWithCertErrors) {
     delete mHostsWithCertErrors;
     mHostsWithCertErrors = nsnull;
   }
 }
@@ -2270,17 +2270,17 @@ nsresult nsSSLIOLayerHelpers::Init()
 
     nsSSLIOLayerMethods.connect = nsSSLIOLayerConnect;
     nsSSLIOLayerMethods.close = nsSSLIOLayerClose;
     nsSSLIOLayerMethods.write = nsSSLIOLayerWrite;
     nsSSLIOLayerMethods.read = nsSSLIOLayerRead;
     nsSSLIOLayerMethods.poll = nsSSLIOLayerPoll;
   }
 
-  mutex = PR_NewLock();
+  mutex = nsAutoLock::NewLock("nsSSLIOLayerHelpers::mutex");
   if (!mutex)
     return NS_ERROR_OUT_OF_MEMORY;
 
   mSharedPollableEvent = PR_NewPollableEvent();
 
   // if we can not get a pollable event, we'll have to do busy waiting
 
   mTLSIntolerantSites = new nsCStringHashSet();
diff --git a/security/manager/ssl/src/nsPSMBackgroundThread.cpp b/security/manager/ssl/src/nsPSMBackgroundThread.cpp
--- a/security/manager/ssl/src/nsPSMBackgroundThread.cpp
+++ b/security/manager/ssl/src/nsPSMBackgroundThread.cpp
@@ -45,17 +45,17 @@ void PR_CALLBACK nsPSMBackgroundThread::
 }
 
 nsPSMBackgroundThread::nsPSMBackgroundThread()
 : mThreadHandle(nsnull),
   mMutex(nsnull),
   mCond(nsnull),
   mExitRequested(PR_FALSE)
 {
-  mMutex = PR_NewLock();
+  mMutex = nsAutoLock::NewLock("nsPSMBackgroundThread::mMutex");
   mCond = PR_NewCondVar(mMutex);
 }
 
 nsresult nsPSMBackgroundThread::startThread()
 {
   if (!mMutex || !mCond)
     return NS_ERROR_OUT_OF_MEMORY;
 
@@ -71,17 +71,17 @@ nsresult nsPSMBackgroundThread::startThr
 }
 
 nsPSMBackgroundThread::~nsPSMBackgroundThread()
 {
   if (mCond)
     PR_DestroyCondVar(mCond);
 
   if (mMutex)
-    PR_DestroyLock(mMutex);
+    nsAutoLock::DestroyLock(mMutex);
 }
 
 void nsPSMBackgroundThread::requestExit()
 {
   if (!mThreadHandle)
     return;
 
   {
diff --git a/toolkit/components/url-classifier/nsUrlClassifierDBService.cpp b/toolkit/components/url-classifier/nsUrlClassifierDBService.cpp
--- a/toolkit/components/url-classifier/nsUrlClassifierDBService.cpp
+++ b/toolkit/components/url-classifier/nsUrlClassifierDBService.cpp
@@ -1347,20 +1347,20 @@ nsUrlClassifierDBServiceWorker::nsUrlCla
 
 nsUrlClassifierDBServiceWorker::~nsUrlClassifierDBServiceWorker()
 {
   NS_ASSERTION(!mConnection,
                "Db connection not closed, leaking memory!  Call CloseDb "
                "to close the connection.");
 
   if (mCleanHostKeysLock)
-    PR_DestroyLock(mCleanHostKeysLock);
+    nsAutoLock::DestroyLock(mCleanHostKeysLock);
 
   if (mPendingLookupLock)
-    PR_DestroyLock(mPendingLookupLock);
+    nsAutoLock::DestroyLock(mPendingLookupLock);
 }
 
 nsresult
 nsUrlClassifierDBServiceWorker::Init(PRInt32 gethashNoise)
 {
   mGethashNoise = gethashNoise;
 
   // Compute database filename
@@ -1375,27 +1375,29 @@ nsUrlClassifierDBServiceWorker::Init(PRI
                                 getter_AddRefs(mDBFile));
   }
 
   if (NS_FAILED(rv)) return NS_ERROR_NOT_AVAILABLE;
 
   rv = mDBFile->Append(NS_LITERAL_STRING(DATABASE_FILENAME));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  mCleanHostKeysLock = PR_NewLock();
+  mCleanHostKeysLock =
+    nsAutoLock::NewLock("nsUrlClassifierDBServiceWorker::mCleanHostKeysLock");
   if (!mCleanHostKeysLock)
     return NS_ERROR_OUT_OF_MEMORY;
 
   if (!mCleanHostKeys.Init(CLEAN_HOST_KEYS_SIZE))
     return NS_ERROR_OUT_OF_MEMORY;
 
   if (!mCleanFragments.Init(CLEAN_FRAGMENTS_SIZE))
     return NS_ERROR_OUT_OF_MEMORY;
 
-  mPendingLookupLock = PR_NewLock();
+  mPendingLookupLock =
+    nsAutoLock::NewLock("nsUrlClassifierDBServiceWorker::mPendingLookupLock");
   if (!mPendingLookupLock)
     return NS_ERROR_OUT_OF_MEMORY;
 
   ResetUpdate();
 
   mTableFreshness.Init();
 
   return NS_OK;
diff --git a/xpcom/base/nsConsoleService.cpp b/xpcom/base/nsConsoleService.cpp
--- a/xpcom/base/nsConsoleService.cpp
+++ b/xpcom/base/nsConsoleService.cpp
@@ -84,31 +84,31 @@ nsConsoleService::~nsConsoleService()
             mListeners.Count());
     }
     
 #endif
 
     if (mMessages)
         nsMemory::Free(mMessages);
     if (mLock)
-        PR_DestroyLock(mLock);
+        nsAutoLock::DestroyLock(mLock);
 }
 
 nsresult
 nsConsoleService::Init()
 {
     mMessages = (nsIConsoleMessage **)
         nsMemory::Alloc(mBufferSize * sizeof(nsIConsoleMessage *));
     if (!mMessages)
         return NS_ERROR_OUT_OF_MEMORY;
 
     // Array elements should be 0 initially for circular buffer algorithm.
     memset(mMessages, 0, mBufferSize * sizeof(nsIConsoleMessage *));
 
-    mLock = PR_NewLock();
+    mLock = nsAutoLock::NewLock("nsConsoleService::mLock");
     if (!mLock)
         return NS_ERROR_OUT_OF_MEMORY;
 
     return NS_OK;
 }
 
 static PRBool snapshot_enum_func(nsHashKey *key, void *data, void* closure)
 {
diff --git a/xpcom/base/nsUUIDGenerator.cpp b/xpcom/base/nsUUIDGenerator.cpp
--- a/xpcom/base/nsUUIDGenerator.cpp
+++ b/xpcom/base/nsUUIDGenerator.cpp
@@ -57,24 +57,24 @@ NS_IMPL_THREADSAFE_ISUPPORTS1(nsUUIDGene
 nsUUIDGenerator::nsUUIDGenerator()
     : mLock(nsnull)
 {
 }
 
 nsUUIDGenerator::~nsUUIDGenerator()
 {
     if (mLock) {
-        PR_DestroyLock(mLock);
+        nsAutoLock::DestroyLock(mLock);
     }
 }
 
 nsresult
 nsUUIDGenerator::Init()
 {
-    mLock = PR_NewLock();
+    mLock = nsAutoLock::NewLock("nsUUIDGenerator::mLock");
 
     NS_ENSURE_TRUE(mLock, NS_ERROR_OUT_OF_MEMORY);
 
     // We're a service, so we're guaranteed that Init() is not going
     // to be reentered while we're inside Init().
     
 #if !defined(XP_WIN) && !defined(XP_MACOSX) && !defined(ANDROID)
     /* initialize random number generator using NSPR random noise */
diff --git a/xpcom/ds/nsRecyclingAllocator.cpp b/xpcom/ds/nsRecyclingAllocator.cpp
--- a/xpcom/ds/nsRecyclingAllocator.cpp
+++ b/xpcom/ds/nsRecyclingAllocator.cpp
@@ -73,17 +73,17 @@ nsRecyclingAllocator::nsRecycleTimerCall
 
 nsRecyclingAllocator::nsRecyclingAllocator(PRUint32 nbucket, PRUint32 recycleAfter, const char *id) :
     mMaxBlocks(nbucket), mFreeListCount(0), mFreeList(nsnull),
     mRecycleTimer(nsnull), mRecycleAfter(recycleAfter), mTouched(PR_FALSE)
 #ifdef DEBUG
     , mId(id), mNAllocated(0)
 #endif
 {
-    mLock = PR_NewLock();
+    mLock = nsAutoLock::NewLock("nsRecyclingAllocatior::mLock");
     NS_ASSERTION(mLock, "Recycling allocator cannot get lock");
 }
 
 nsresult
 nsRecyclingAllocator::Init(PRUint32 nbucket, PRUint32 recycleAfter, const char *id)
 {
     nsAutoLock lock(mLock);
 
@@ -100,17 +100,17 @@ nsRecyclingAllocator::Init(PRUint32 nbuc
 }
 
 nsRecyclingAllocator::~nsRecyclingAllocator()
 {
     ClearFreeList();
 
     if (mLock)
     {
-        PR_DestroyLock(mLock);
+        nsAutoLock::DestroyLock(mLock);
         mLock = nsnull;
     }
 }
 
 // Allocation and free routines
 void*
 nsRecyclingAllocator::Malloc(PRSize bytes, PRBool zeroit)
 {
diff --git a/xpcom/io/nsFastLoadService.cpp b/xpcom/io/nsFastLoadService.cpp
--- a/xpcom/io/nsFastLoadService.cpp
+++ b/xpcom/io/nsFastLoadService.cpp
@@ -71,31 +71,31 @@ nsFastLoadService::~nsFastLoadService()
     if (mInputStream)
         mInputStream->Close();
     if (mOutputStream)
         mOutputStream->Close();
 
     if (mFastLoadPtrMap)
         PL_DHashTableDestroy(mFastLoadPtrMap);
     if (mLock)
-        PR_DestroyLock(mLock);
+        nsAutoLock::DestroyLock(mLock);
 }
 
 nsresult
 nsFastLoadService::Create(nsISupports *aOuter, REFNSIID aIID, void **aResult)
 {
     *aResult = nsnull;
     if (aOuter)
         return NS_ERROR_NO_AGGREGATION;
 
     nsFastLoadService* fastLoadService = new nsFastLoadService();
     if (!fastLoadService)
         return NS_ERROR_OUT_OF_MEMORY;
 
-    fastLoadService->mLock = PR_NewLock();
+    fastLoadService->mLock = nsAutoLock::NewLock("nsFastLoadService::mLock");
     if (!fastLoadService->mLock) {
         delete fastLoadService;
         return NS_ERROR_OUT_OF_MEMORY;
     }
 
     NS_ADDREF(fastLoadService);
     nsresult rv = fastLoadService->QueryInterface(aIID, aResult);
     NS_RELEASE(fastLoadService);
diff --git a/xpcom/io/nsInputStreamTee.cpp b/xpcom/io/nsInputStreamTee.cpp
--- a/xpcom/io/nsInputStreamTee.cpp
+++ b/xpcom/io/nsInputStreamTee.cpp
@@ -63,17 +63,17 @@ public:
     NS_DECL_NSIINPUTSTREAM
     NS_DECL_NSIINPUTSTREAMTEE
 
     nsInputStreamTee();
     bool SinkIsValid();
     void InvalidateSink();
 
 private:
-    ~nsInputStreamTee() { if (mLock) PR_DestroyLock(mLock); }
+    ~nsInputStreamTee() { if (mLock) nsAutoLock::DestroyLock(mLock); }
 
     nsresult TeeSegment(const char *buf, PRUint32 count);
     
     static NS_METHOD WriteSegmentFun(nsIInputStream *, void *, const char *,
                                      PRUint32, PRUint32, PRUint32 *);
 
 private:
     nsCOMPtr<nsIInputStream>  mSource;
@@ -319,17 +319,17 @@ nsInputStreamTee::GetSink(nsIOutputStrea
 }
 
 NS_IMETHODIMP
 nsInputStreamTee::SetEventTarget(nsIEventTarget *anEventTarget)
 {
     mEventTarget = anEventTarget;
     if (mEventTarget) {
         // Only need synchronization if this is an async tee
-        mLock = PR_NewLock();
+        mLock = nsAutoLock::NewLock("nsInputStreamTee::mLock");
         if (!mLock) {
             NS_ERROR("Failed to allocate lock for nsInputStreamTee");
             return NS_ERROR_OUT_OF_MEMORY;
         }
     }
     return NS_OK;
 }
 
diff --git a/xpcom/io/nsLocalFileWin.cpp b/xpcom/io/nsLocalFileWin.cpp
--- a/xpcom/io/nsLocalFileWin.cpp
+++ b/xpcom/io/nsLocalFileWin.cpp
@@ -167,17 +167,17 @@ ShortcutResolver::ShortcutResolver()
     mLock = nsnull;
     mPersistFile = nsnull;
     mShellLink  = nsnull;
 }
 
 ShortcutResolver::~ShortcutResolver()
 {
     if (mLock)
-        PR_DestroyLock(mLock);
+        nsAutoLock::DestroyLock(mLock);
 
     // Release the pointer to the IPersistFile interface.
     if (mPersistFile)
         mPersistFile->Release();
 
     // Release the pointer to the IShellLink interface.
     if (mShellLink)
         mShellLink->Release();
@@ -185,17 +185,17 @@ ShortcutResolver::~ShortcutResolver()
     CoUninitialize();
 }
 
 nsresult
 ShortcutResolver::Init()
 {
     CoInitialize(NULL);  // FIX: we should probably move somewhere higher up during startup
 
-    mLock = PR_NewLock();
+    mLock = nsAutoLock::NewLock("ShortcutResolver::mLock");
     if (!mLock)
         return NS_ERROR_FAILURE;
 
     HRESULT hres; 
     hres = CoCreateInstance(CLSID_ShellLink,
                             NULL,
                             CLSCTX_INPROC_SERVER,
                             IID_IShellLinkW,
diff --git a/xpcom/io/nsStreamUtils.cpp b/xpcom/io/nsStreamUtils.cpp
--- a/xpcom/io/nsStreamUtils.cpp
+++ b/xpcom/io/nsStreamUtils.cpp
@@ -257,17 +257,17 @@ public:
         , mCancelStatus(NS_OK)
     {
     }
 
     // virtual since subclasses call superclass Release()
     virtual ~nsAStreamCopier()
     {
         if (mLock)
-            PR_DestroyLock(mLock);
+            nsAutoLock::DestroyLock(mLock);
     }
 
     // kick off the async copy...
     nsresult Start(nsIInputStream *source,
                    nsIOutputStream *sink,
                    nsIEventTarget *target,
                    nsAsyncCopyCallbackFun callback,
                    void *closure,
@@ -279,17 +279,17 @@ public:
         mSink = sink;
         mTarget = target;
         mCallback = callback;
         mClosure = closure;
         mChunkSize = chunksize;
         mCloseSource = closeSource;
         mCloseSink = closeSink;
 
-        mLock = PR_NewLock();
+        mLock = nsAutoLock::NewLock("nsAStreamCopier::mLock");
         if (!mLock)
             return NS_ERROR_OUT_OF_MEMORY;
 
         mAsyncSource = do_QueryInterface(mSource);
         mAsyncSink = do_QueryInterface(mSink);
 
         return PostContinuationEvent();
     }
diff --git a/xpcom/proxy/src/nsProxyObjectManager.cpp b/xpcom/proxy/src/nsProxyObjectManager.cpp
--- a/xpcom/proxy/src/nsProxyObjectManager.cpp
+++ b/xpcom/proxy/src/nsProxyObjectManager.cpp
@@ -110,26 +110,27 @@ NS_IMETHODIMP_(nsrefcnt)
 nsProxyObjectManager::Release()
 {
     return 1;
 }
 
 nsProxyObjectManager::nsProxyObjectManager()
     : mProxyObjectMap(256, PR_FALSE)
 {
-    mProxyCreationLock = PR_NewLock();
+    mProxyCreationLock =
+        nsAutoLock::NewLock("nsProxyObjectManager::mProxyCreationLock");
     mProxyClassMap.Init(256);
 }
 
 nsProxyObjectManager::~nsProxyObjectManager()
 {
     mProxyClassMap.Clear();
 
     if (mProxyCreationLock)
-        PR_DestroyLock(mProxyCreationLock);
+        nsAutoLock::DestroyLock(mProxyCreationLock);
 
     nsProxyObjectManager::gInstance = nsnull;
 }
 
 PRBool
 nsProxyObjectManager::IsManagerShutdown()
 {
     return gInstance == nsnull;
diff --git a/xpcom/reflect/xptinfo/src/xptiInterfaceInfoManager.cpp b/xpcom/reflect/xptinfo/src/xptiInterfaceInfoManager.cpp
--- a/xpcom/reflect/xptinfo/src/xptiInterfaceInfoManager.cpp
+++ b/xpcom/reflect/xptinfo/src/xptiInterfaceInfoManager.cpp
@@ -75,33 +75,34 @@ xptiInterfaceInfoManager::FreeInterfaceI
     NS_IF_RELEASE(gInterfaceInfoManager);
 }
 
 xptiInterfaceInfoManager::xptiInterfaceInfoManager()
     :   mWorkingSet(),
         mResolveLock(PR_NewLock()),
         mAutoRegLock(PR_NewLock()),
         mInfoMonitor(nsAutoMonitor::NewMonitor("xptiInfoMonitor")),
-        mAdditionalManagersLock(PR_NewLock())
+        mAdditionalManagersLock(nsAutoLock::NewLock(
+            "xptiInterfaceInfoManager::mAdditionalManagersLock"))
 {
 }
 
 xptiInterfaceInfoManager::~xptiInterfaceInfoManager()
 {
     // We only do this on shutdown of the service.
     mWorkingSet.InvalidateInterfaceInfos();
 
     if (mResolveLock)
         PR_DestroyLock(mResolveLock);
     if (mAutoRegLock)
         PR_DestroyLock(mAutoRegLock);
     if (mInfoMonitor)
         nsAutoMonitor::DestroyMonitor(mInfoMonitor);
     if (mAdditionalManagersLock)
-        PR_DestroyLock(mAdditionalManagersLock);
+        nsAutoLock::DestroyLock(mAdditionalManagersLock);
 
     gInterfaceInfoManager = nsnull;
 #ifdef DEBUG
     gCallCount = 0;
 #endif
 }
 
 namespace {
diff --git a/xpcom/threads/TimerThread.cpp b/xpcom/threads/TimerThread.cpp
--- a/xpcom/threads/TimerThread.cpp
+++ b/xpcom/threads/TimerThread.cpp
@@ -67,28 +67,28 @@ TimerThread::TimerThread() :
 {
 }
 
 TimerThread::~TimerThread()
 {
   if (mCondVar)
     PR_DestroyCondVar(mCondVar);
   if (mLock)
-    PR_DestroyLock(mLock);
+    nsAutoLock::DestroyLock(mLock);
 
   mThread = nsnull;
 
   NS_ASSERTION(mTimers.IsEmpty(), "Timers remain in TimerThread::~TimerThread");
 }
 
 nsresult
 TimerThread::InitLocks()
 {
   NS_ASSERTION(!mLock, "InitLocks called twice?");
-  mLock = PR_NewLock();
+  mLock = nsAutoLock::NewLock("TimerThread::mLock");
   if (!mLock)
     return NS_ERROR_OUT_OF_MEMORY;
 
   mCondVar = PR_NewCondVar(mLock);
   if (!mCondVar)
     return NS_ERROR_OUT_OF_MEMORY;
 
   return NS_OK;
diff --git a/xpcom/threads/nsEnvironment.cpp b/xpcom/threads/nsEnvironment.cpp
--- a/xpcom/threads/nsEnvironment.cpp
+++ b/xpcom/threads/nsEnvironment.cpp
@@ -60,33 +60,33 @@ nsEnvironment::Create(nsISupports *aOute
         return NS_ERROR_NO_AGGREGATION;
     }
 
     nsEnvironment* obj = new nsEnvironment();
     if (!obj) {
         return NS_ERROR_OUT_OF_MEMORY;
     }
 
-    obj->mLock = PR_NewLock();
+    obj->mLock = nsAutoLock::NewLock("nsEnvironment::mLock");
     if (!obj->mLock) {
         delete obj;
         return NS_ERROR_OUT_OF_MEMORY;
     }
 
     rv = obj->QueryInterface(aIID, aResult);
     if (NS_FAILED(rv)) {
       delete obj;
     }
     return rv;
 }
 
 nsEnvironment::~nsEnvironment()
 {
     if (mLock)
-        PR_DestroyLock(mLock);
+        nsAutoLock::DestroyLock(mLock);
 }
 
 NS_IMETHODIMP
 nsEnvironment::Exists(const nsAString& aName, PRBool *aOutValue)
 {
     nsCAutoString nativeName;
     nsresult rv = NS_CopyUnicodeToNative(aName, nativeName);
     NS_ENSURE_SUCCESS(rv, rv);
diff --git a/xpcom/threads/nsProcessCommon.cpp b/xpcom/threads/nsProcessCommon.cpp
--- a/xpcom/threads/nsProcessCommon.cpp
+++ b/xpcom/threads/nsProcessCommon.cpp
@@ -100,32 +100,32 @@ cpu_type_t pref_cpu_types[2] = {
 // nsIProcess implementation
 //-------------------------------------------------------------------//
 NS_IMPL_THREADSAFE_ISUPPORTS2(nsProcess, nsIProcess,
                                          nsIObserver)
 
 //Constructor
 nsProcess::nsProcess()
     : mThread(nsnull)
-    , mLock(PR_NewLock())
+    , mLock(nsAutoLock::NewLock("nsProcess::mLock"))
     , mShutdown(PR_FALSE)
     , mPid(-1)
     , mObserver(nsnull)
     , mWeakObserver(nsnull)
     , mExitValue(-1)
 #if !defined(XP_MACOSX)
     , mProcess(nsnull)
 #endif
 {
 }
 
 //Destructor
 nsProcess::~nsProcess()
 {
-    PR_DestroyLock(mLock);
+    nsAutoLock::DestroyLock(mLock);
 }
 
 NS_IMETHODIMP
 nsProcess::Init(nsIFile* executable)
 {
     if (mExecutable)
         return NS_ERROR_ALREADY_INITIALIZED;
 
diff --git a/xpcom/threads/nsThread.cpp b/xpcom/threads/nsThread.cpp
--- a/xpcom/threads/nsThread.cpp
+++ b/xpcom/threads/nsThread.cpp
@@ -308,31 +308,31 @@ nsThread::ThreadFunc(void *arg)
   self->SetObserver(nsnull);
 
   NS_RELEASE(self);
 }
 
 //-----------------------------------------------------------------------------
 
 nsThread::nsThread()
-  : mLock(PR_NewLock())
+  : mLock(nsAutoLock::NewLock("nsThread::mLock"))
   , mEvents(&mEventsRoot)
   , mPriority(PRIORITY_NORMAL)
   , mThread(nsnull)
   , mRunningEvent(0)
   , mShutdownContext(nsnull)
   , mShutdownRequired(PR_FALSE)
   , mEventsAreDoomed(PR_FALSE)
 {
 }
 
 nsThread::~nsThread()
 {
   if (mLock)
-    PR_DestroyLock(mLock);
+    nsAutoLock::DestroyLock(mLock);
 }
 
 nsresult
 nsThread::Init()
 {
   NS_ENSURE_TRUE(mLock, NS_ERROR_OUT_OF_MEMORY);
 
   // spawn thread and wait until it is fully setup
diff --git a/xpcom/threads/nsThreadManager.cpp b/xpcom/threads/nsThreadManager.cpp
--- a/xpcom/threads/nsThreadManager.cpp
+++ b/xpcom/threads/nsThreadManager.cpp
@@ -83,17 +83,17 @@ NS_IMPL_CLASSINFO(nsThreadManager, NULL,
 NS_IMPL_QUERY_INTERFACE1_CI(nsThreadManager, nsIThreadManager)
 NS_IMPL_CI_INTERFACE_GETTER1(nsThreadManager, nsIThreadManager)
 
 //-----------------------------------------------------------------------------
 
 nsresult
 nsThreadManager::Init()
 {
-  mLock = PR_NewLock();
+  mLock = nsAutoLock::NewLock("nsThreadManager::mLock");
   if (!mLock)
     return NS_ERROR_OUT_OF_MEMORY;
 
   if (!mThreadsByPRThread.Init())
     return NS_ERROR_OUT_OF_MEMORY;
 
   if (PR_NewThreadPrivateIndex(&mCurThreadIndex, ReleaseObject) == PR_FAILURE)
     return NS_ERROR_FAILURE;
@@ -180,17 +180,17 @@ nsThreadManager::Shutdown()
 
   // Release main thread object.
   mMainThread = nsnull;
 
   // Remove the TLS entry for the main thread.
   PR_SetThreadPrivate(mCurThreadIndex, nsnull);
 
   // We don't need this lock anymore.
-  PR_DestroyLock(mLock);
+  nsAutoLock::DestroyLock(mLock);
   mLock = nsnull;
 }
 
 void
 nsThreadManager::RegisterCurrentThread(nsThread *thread)
 {
   NS_ASSERTION(thread->GetPRThread() == PR_GetCurrentThread(), "bad thread");
 
diff --git a/xpfe/appshell/src/nsWindowMediator.cpp b/xpfe/appshell/src/nsWindowMediator.cpp
--- a/xpfe/appshell/src/nsWindowMediator.cpp
+++ b/xpfe/appshell/src/nsWindowMediator.cpp
@@ -94,22 +94,22 @@ nsWindowMediator::nsWindowMediator() :
 }
 
 nsWindowMediator::~nsWindowMediator()
 {
   while (mOldestWindow)
     UnregisterWindow(mOldestWindow);
   
   if (mListLock)
-    PR_DestroyLock(mListLock);
+    nsAutoLock::DestroyLock(mListLock);
 }
 
 nsresult nsWindowMediator::Init()
 {
-  mListLock = PR_NewLock();
+  mListLock = nsAutoLock::NewLock("nsWindowMediator::mListLock");
   if (!mListLock)
     return NS_ERROR_OUT_OF_MEMORY;
 
   nsresult rv;
   nsCOMPtr<nsIObserverService> obsSvc =
     do_GetService("@mozilla.org/observer-service;1", &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = obsSvc->AddObserver(this, "xpcom-shutdown", PR_TRUE);
