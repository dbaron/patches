From: L. David Baron <dbaron@dbaron.org>

Use nsAutoLock::NewLock and nsAutoLock::DestroyLock correctly in xpcom/threads.  (Bug 594666)

diff --git a/xpcom/threads/TimerThread.cpp b/xpcom/threads/TimerThread.cpp
--- a/xpcom/threads/TimerThread.cpp
+++ b/xpcom/threads/TimerThread.cpp
@@ -67,28 +67,28 @@ TimerThread::TimerThread() :
 {
 }
 
 TimerThread::~TimerThread()
 {
   if (mCondVar)
     PR_DestroyCondVar(mCondVar);
   if (mLock)
-    PR_DestroyLock(mLock);
+    nsAutoLock::DestroyLock(mLock);
 
   mThread = nsnull;
 
   NS_ASSERTION(mTimers.IsEmpty(), "Timers remain in TimerThread::~TimerThread");
 }
 
 nsresult
 TimerThread::InitLocks()
 {
   NS_ASSERTION(!mLock, "InitLocks called twice?");
-  mLock = PR_NewLock();
+  mLock = nsAutoLock::NewLock("TimerThread::mLock");
   if (!mLock)
     return NS_ERROR_OUT_OF_MEMORY;
 
   mCondVar = PR_NewCondVar(mLock);
   if (!mCondVar)
     return NS_ERROR_OUT_OF_MEMORY;
 
   return NS_OK;
diff --git a/xpcom/threads/nsEnvironment.cpp b/xpcom/threads/nsEnvironment.cpp
--- a/xpcom/threads/nsEnvironment.cpp
+++ b/xpcom/threads/nsEnvironment.cpp
@@ -60,33 +60,33 @@ nsEnvironment::Create(nsISupports *aOute
         return NS_ERROR_NO_AGGREGATION;
     }
 
     nsEnvironment* obj = new nsEnvironment();
     if (!obj) {
         return NS_ERROR_OUT_OF_MEMORY;
     }
 
-    obj->mLock = PR_NewLock();
+    obj->mLock = nsAutoLock::NewLock("nsEnvironment::mLock");
     if (!obj->mLock) {
         delete obj;
         return NS_ERROR_OUT_OF_MEMORY;
     }
 
     rv = obj->QueryInterface(aIID, aResult);
     if (NS_FAILED(rv)) {
       delete obj;
     }
     return rv;
 }
 
 nsEnvironment::~nsEnvironment()
 {
     if (mLock)
-        PR_DestroyLock(mLock);
+        nsAutoLock::DestroyLock(mLock);
 }
 
 NS_IMETHODIMP
 nsEnvironment::Exists(const nsAString& aName, PRBool *aOutValue)
 {
     nsCAutoString nativeName;
     nsresult rv = NS_CopyUnicodeToNative(aName, nativeName);
     NS_ENSURE_SUCCESS(rv, rv);
diff --git a/xpcom/threads/nsProcessCommon.cpp b/xpcom/threads/nsProcessCommon.cpp
--- a/xpcom/threads/nsProcessCommon.cpp
+++ b/xpcom/threads/nsProcessCommon.cpp
@@ -100,32 +100,32 @@ cpu_type_t pref_cpu_types[2] = {
 // nsIProcess implementation
 //-------------------------------------------------------------------//
 NS_IMPL_THREADSAFE_ISUPPORTS2(nsProcess, nsIProcess,
                                          nsIObserver)
 
 //Constructor
 nsProcess::nsProcess()
     : mThread(nsnull)
-    , mLock(PR_NewLock())
+    , mLock(nsAutoLock::NewLock("nsProcess::mLock"))
     , mShutdown(PR_FALSE)
     , mPid(-1)
     , mObserver(nsnull)
     , mWeakObserver(nsnull)
     , mExitValue(-1)
 #if !defined(XP_MACOSX)
     , mProcess(nsnull)
 #endif
 {
 }
 
 //Destructor
 nsProcess::~nsProcess()
 {
-    PR_DestroyLock(mLock);
+    nsAutoLock::DestroyLock(mLock);
 }
 
 NS_IMETHODIMP
 nsProcess::Init(nsIFile* executable)
 {
     if (mExecutable)
         return NS_ERROR_ALREADY_INITIALIZED;
 
diff --git a/xpcom/threads/nsThread.cpp b/xpcom/threads/nsThread.cpp
--- a/xpcom/threads/nsThread.cpp
+++ b/xpcom/threads/nsThread.cpp
@@ -308,31 +308,31 @@ nsThread::ThreadFunc(void *arg)
   self->SetObserver(nsnull);
 
   NS_RELEASE(self);
 }
 
 //-----------------------------------------------------------------------------
 
 nsThread::nsThread()
-  : mLock(PR_NewLock())
+  : mLock(nsAutoLock::NewLock("nsThread::mLock"))
   , mEvents(&mEventsRoot)
   , mPriority(PRIORITY_NORMAL)
   , mThread(nsnull)
   , mRunningEvent(0)
   , mShutdownContext(nsnull)
   , mShutdownRequired(PR_FALSE)
   , mEventsAreDoomed(PR_FALSE)
 {
 }
 
 nsThread::~nsThread()
 {
   if (mLock)
-    PR_DestroyLock(mLock);
+    nsAutoLock::DestroyLock(mLock);
 }
 
 nsresult
 nsThread::Init()
 {
   NS_ENSURE_TRUE(mLock, NS_ERROR_OUT_OF_MEMORY);
 
   // spawn thread and wait until it is fully setup
diff --git a/xpcom/threads/nsThreadManager.cpp b/xpcom/threads/nsThreadManager.cpp
--- a/xpcom/threads/nsThreadManager.cpp
+++ b/xpcom/threads/nsThreadManager.cpp
@@ -83,17 +83,17 @@ NS_IMPL_CLASSINFO(nsThreadManager, NULL,
 NS_IMPL_QUERY_INTERFACE1_CI(nsThreadManager, nsIThreadManager)
 NS_IMPL_CI_INTERFACE_GETTER1(nsThreadManager, nsIThreadManager)
 
 //-----------------------------------------------------------------------------
 
 nsresult
 nsThreadManager::Init()
 {
-  mLock = PR_NewLock();
+  mLock = nsAutoLock::NewLock("nsThreadManager::mLock");
   if (!mLock)
     return NS_ERROR_OUT_OF_MEMORY;
 
   if (!mThreadsByPRThread.Init())
     return NS_ERROR_OUT_OF_MEMORY;
 
   if (PR_NewThreadPrivateIndex(&mCurThreadIndex, ReleaseObject) == PR_FAILURE)
     return NS_ERROR_FAILURE;
@@ -180,17 +180,17 @@ nsThreadManager::Shutdown()
 
   // Release main thread object.
   mMainThread = nsnull;
 
   // Remove the TLS entry for the main thread.
   PR_SetThreadPrivate(mCurThreadIndex, nsnull);
 
   // We don't need this lock anymore.
-  PR_DestroyLock(mLock);
+  nsAutoLock::DestroyLock(mLock);
   mLock = nsnull;
 }
 
 void
 nsThreadManager::RegisterCurrentThread(nsThread *thread)
 {
   NS_ASSERTION(thread->GetPRThread() == PR_GetCurrentThread(), "bad thread");
 
