From: Zack Weinberg <zweinberg@mozilla.com>

Bug 497495 (frame poisoning) part 2: Introduce nsIPresShell::AllocateMisc/FreeMisc functions; add an as-yet-unused "code" parameter to AllocateFrame/FreeFrame; fix up nsFrame to match; use AllocateMisc/FreeMisc for all non-frame pres arena objects; move clearing of frame objects from nsFrame::operator new to AllocateFrame.  r=roc sr=dbaron

diff --git a/layout/base/nsIPresShell.h b/layout/base/nsIPresShell.h
--- a/layout/base/nsIPresShell.h
+++ b/layout/base/nsIPresShell.h
@@ -99,19 +99,20 @@ class gfxContext;
 class nsPIDOMEventTarget;
 class nsIDOMEvent;
 class nsDisplayList;
 class nsDisplayListBuilder;
 
 typedef short SelectionType;
 typedef PRUint32 nsFrameState;
 
-#define NS_IPRESSHELL_IID \
-{ 0xfea81c36, 0xed5b, 0x41f5, \
-  { 0x89, 0x5d, 0x4c, 0x50, 0x79, 0x49, 0xad, 0x3b } }
+// eba51d41-68db-4dab-a57b-dc1a2704de87
+#define NS_IPRESSHELL_IID     \
+{ 0xeba51d41, 0x68db, 0x4dab, \
+  { 0xa5, 0x7b, 0xdc, 0x1a, 0x27, 0x04, 0xde, 0x87 } }
 
 // Constants for ScrollContentIntoView() function
 #define NS_PRESSHELL_SCROLL_TOP      0
 #define NS_PRESSHELL_SCROLL_BOTTOM   100
 #define NS_PRESSHELL_SCROLL_LEFT     0
 #define NS_PRESSHELL_SCROLL_RIGHT    100
 #define NS_PRESSHELL_SCROLL_CENTER   50
 #define NS_PRESSHELL_SCROLL_ANYWHERE -1
@@ -164,21 +165,29 @@ public:
    * controls incorrectly store their data in the frames rather than the
    * content model and printing calls |EndObservingDocument| multiple
    * times to make form controls behave nicely when printed.
    */
   NS_IMETHOD Destroy() = 0;
   
   PRBool IsDestroying() { return mIsDestroying; }
 
-  // All frames owned by the shell are allocated from an arena.  They are also recycled
-  // using free lists (separate free lists being maintained for each size_t).
-  // Methods for recycling frames.
-  virtual void* AllocateFrame(size_t aSize) = 0;
-  virtual void  FreeFrame(size_t aSize, void* aFreeChunk) = 0;
+  // All frames owned by the shell are allocated from an arena.  They
+  // are also recycled using free lists.  Separate free lists are
+  // maintained for each combination of aSize and aCode.  AllocateFrame
+  // clears the memory that it returns.
+  virtual void* AllocateFrame(size_t aSize, unsigned int aCode) = 0;
+  virtual void  FreeFrame(size_t aSize, unsigned int aCode, void* aChunk) = 0;
+
+  // Objects closely related to the frame tree, but that are not
+  // actual frames (subclasses of nsFrame) are also allocated from the
+  // arena, and recycled via a separate set of per-size free lists.
+  // AllocateMisc does *not* clear the memory that it returns.
+  virtual void* AllocateMisc(size_t aSize) = 0;
+  virtual void  FreeMisc(size_t aSize, void* aChunk) = 0;
 
   /**
    * Stack memory allocation:
    *
    * Callers who wish to allocate memory whose lifetime corresponds to
    * the lifetime of a stack-allocated object can use this API.  The
    * caller must use a pair of calls to PushStackMemory and
    * PopStackMemory, such that all stack object lifetimes are either
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -275,25 +275,25 @@ public:
   /** 
    * Get medium of presentation
    */
   nsIAtom* Medium() { return mMedium; }
 
   void* AllocateFromShell(size_t aSize)
   {
     if (mShell)
-      return mShell->AllocateFrame(aSize);
+      return mShell->AllocateMisc(aSize);
     return nsnull;
   }
 
   void FreeToShell(size_t aSize, void* aFreeChunk)
   {
     NS_ASSERTION(mShell, "freeing after shutdown");
     if (mShell)
-      mShell->FreeFrame(aSize, aFreeChunk);
+      mShell->FreeMisc(aSize, aFreeChunk);
   }
 
   /**
    * Get the font metrics for a given font.
    *
    * If aUseUserFontSet is false, don't build or use the user font set.
    * This is intended only for nsRuleNode::CalcLengthWithInitialFont
    * (which is used from media query matching, which is in turn called
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -654,18 +654,22 @@ public:
   // nsIPresShell
   NS_IMETHOD Init(nsIDocument* aDocument,
                   nsPresContext* aPresContext,
                   nsIViewManager* aViewManager,
                   nsStyleSet* aStyleSet,
                   nsCompatibility aCompatMode);
   NS_IMETHOD Destroy();
 
-  virtual NS_HIDDEN_(void*) AllocateFrame(size_t aSize);
-  virtual NS_HIDDEN_(void)  FreeFrame(size_t aSize, void* aFreeChunk);
+  virtual NS_HIDDEN_(void*) AllocateFrame(size_t aSize, unsigned int aCode);
+  virtual NS_HIDDEN_(void)  FreeFrame(size_t aSize, unsigned int aCode,
+                                      void* aChunk);
+
+  virtual NS_HIDDEN_(void*) AllocateMisc(size_t aSize);
+  virtual NS_HIDDEN_(void)  FreeMisc(size_t aSize, void* aChunk);
 
   // Dynamic stack memory allocation
   virtual NS_HIDDEN_(void) PushStackMemory();
   virtual NS_HIDDEN_(void) PopStackMemory();
   virtual NS_HIDDEN_(void*) AllocateStackMemory(size_t aSize);
 
   NS_IMETHOD SetPreferenceStyleRules(PRBool aForceReflow);
   
@@ -1962,23 +1966,40 @@ PresShell::PopStackMemory()
 
 /* virtual */ void*
 PresShell::AllocateStackMemory(size_t aSize)
 {
   return mStackArena.Allocate(aSize);
 }
 
 void
-PresShell::FreeFrame(size_t aSize, void* aPtr)
+PresShell::FreeFrame(size_t aSize, unsigned int /*unused*/, void* aPtr)
 {
   mFrameArena.Free(aSize, aPtr);
 }
 
 void*
-PresShell::AllocateFrame(size_t aSize)
+PresShell::AllocateFrame(size_t aSize, unsigned int /*unused*/)
+{
+  void* result = mFrameArena.Allocate(aSize);
+
+  if (result) {
+    memset(result, 0, aSize);
+  }
+  return result;
+}
+
+void
+PresShell::FreeMisc(size_t aSize, void* aPtr)
+{
+  mFrameArena.Free(aSize, aPtr);
+}
+
+void*
+PresShell::AllocateMisc(size_t aSize)
 {
   return mFrameArena.Allocate(aSize);
 }
 
 void
 nsIPresShell::SetAuthorStyleDisabled(PRBool aStyleDisabled)
 {
   if (aStyleDisabled != mStyleSet->GetAuthorStyleDisabled()) {
@@ -4576,17 +4597,17 @@ PresShell::IsThemeSupportEnabled()
 {
   return !mIsThemeSupportDisabled;
 }
 
 // Post a request to handle an arbitrary callback after reflow has finished.
 NS_IMETHODIMP
 PresShell::PostReflowCallback(nsIReflowCallback* aCallback)
 {
-  void* result = AllocateFrame(sizeof(nsCallbackEventRequest));
+  void* result = AllocateMisc(sizeof(nsCallbackEventRequest));
   if (NS_UNLIKELY(!result)) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
   nsCallbackEventRequest* request = (nsCallbackEventRequest*)result;
 
   request->callback = aCallback;
   request->next = nsnull;
 
@@ -4620,17 +4641,17 @@ PresShell::CancelReflowCallback(nsIReflo
           node = node->next;
           before->next = node;
         }
 
         if (toFree == mLastCallbackEventRequest) {
           mLastCallbackEventRequest = before;
         }
 
-        FreeFrame(sizeof(nsCallbackEventRequest), toFree);
+        FreeMisc(sizeof(nsCallbackEventRequest), toFree);
       } else {
         before = node;
         node = node->next;
       }
    }
 
    return NS_OK;
 }
@@ -4640,17 +4661,17 @@ PresShell::CancelPostedReflowCallbacks()
 {
   while (mFirstCallbackEventRequest) {
     nsCallbackEventRequest* node = mFirstCallbackEventRequest;
     mFirstCallbackEventRequest = node->next;
     if (!mFirstCallbackEventRequest) {
       mLastCallbackEventRequest = nsnull;
     }
     nsIReflowCallback* callback = node->callback;
-    FreeFrame(sizeof(nsCallbackEventRequest), node);
+    FreeMisc(sizeof(nsCallbackEventRequest), node);
     if (callback) {
       callback->ReflowCallbackCanceled();
     }
   }
 }
 
 void
 PresShell::HandlePostedReflowCallbacks(PRBool aInterruptible)
@@ -4659,17 +4680,17 @@ PresShell::HandlePostedReflowCallbacks(P
 
    while (mFirstCallbackEventRequest) {
      nsCallbackEventRequest* node = mFirstCallbackEventRequest;
      mFirstCallbackEventRequest = node->next;
      if (!mFirstCallbackEventRequest) {
        mLastCallbackEventRequest = nsnull;
      }
      nsIReflowCallback* callback = node->callback;
-     FreeFrame(sizeof(nsCallbackEventRequest), node);
+     FreeMisc(sizeof(nsCallbackEventRequest), node);
      if (callback) {
        if (callback->ReflowFinished()) {
          shouldFlush = PR_TRUE;
        }
      }
    }
 
    mozFlushType flushType =
diff --git a/layout/generic/nsFloatManager.cpp b/layout/generic/nsFloatManager.cpp
--- a/layout/generic/nsFloatManager.cpp
+++ b/layout/generic/nsFloatManager.cpp
@@ -50,24 +50,24 @@ PRInt32 nsFloatManager::sCachedFloatMana
 void* nsFloatManager::sCachedFloatManagers[NS_FLOAT_MANAGER_CACHE_SIZE];
 
 /////////////////////////////////////////////////////////////////////////////
 
 // PresShell Arena allocate callback (for nsIntervalSet use below)
 static void*
 PSArenaAllocCB(size_t aSize, void* aClosure)
 {
-  return static_cast<nsIPresShell*>(aClosure)->AllocateFrame(aSize);
+  return static_cast<nsIPresShell*>(aClosure)->AllocateMisc(aSize);
 }
 
 // PresShell Arena free callback (for nsIntervalSet use below)
 static void
 PSArenaFreeCB(size_t aSize, void* aPtr, void* aClosure)
 {
-  static_cast<nsIPresShell*>(aClosure)->FreeFrame(aSize, aPtr);
+  static_cast<nsIPresShell*>(aClosure)->FreeMisc(aSize, aPtr);
 }
 
 /////////////////////////////////////////////////////////////////////////////
 // nsFloatManager
 
 nsFloatManager::nsFloatManager(nsIPresShell* aPresShell)
   : mX(0), mY(0),
     mFloatDamage(PSArenaAllocCB, PSArenaFreeCB, aPresShell)
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -285,34 +285,27 @@ nsWeakFrame::Init(nsIFrame* aFrame)
 }
 
 nsIFrame*
 NS_NewEmptyFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 {
   return new (aPresShell) nsFrame(aContext);
 }
 
-// Overloaded new operator. Initializes the memory to 0 and relies on an arena
-// (which comes from the presShell) to perform the allocation.
-void* 
+// Overloaded new operator. Relies on an arena (which comes from the
+// presShell) to perform the allocation.
+void*
 nsFrame::operator new(size_t sz, nsIPresShell* aPresShell) CPP_THROW_NEW
 {
-  // Check the recycle list first.
-  void* result = aPresShell->AllocateFrame(sz);
-  
-  if (result) {
-    memset(result, 0, sz);
-  }
-
-  return result;
+  return aPresShell->AllocateFrame(sz, 0 /* dummy */);
 }
 
 // Overridden to prevent the global delete from being called, since the memory
 // came out of an nsIArena instead of the global delete operator's heap.
-void 
+void
 nsFrame::operator delete(void* aPtr, size_t sz)
 {
   // Don't let the memory be freed, since it will be recycled
   // instead. Don't call the global operator delete.
 
   // Stash the size of the object in the first four bytes of the
   // freed up memory.  The Destroy method can then use this information
   // to recycle the object.
@@ -472,29 +465,29 @@ nsFrame::Destroy()
 
   //XXX Why is this done in nsFrame instead of some frame class
   // that actually loads images?
   presContext->StopImagesFor(this);
 
   if (view) {
     // Break association between view and frame
     view->SetClientData(nsnull);
-    
+
     // Destroy the view
     view->Destroy();
   }
 
   // Deleting the frame doesn't really free the memory, since we're using an
   // arena for allocation, but we will get our destructors called.
   delete this;
 
   // Now that we're totally cleaned out, we need to add ourselves to the presshell's
   // recycler.
   size_t* sz = (size_t*)this;
-  shell->FreeFrame(*sz, (void*)this);
+  shell->FreeFrame(*sz, 0 /* dummy */, (void*)this);
 }
 
 NS_IMETHODIMP
 nsFrame::GetOffsets(PRInt32 &aStart, PRInt32 &aEnd) const
 {
   aStart = 0;
   aEnd = 0;
   return NS_OK;
diff --git a/layout/generic/nsFrame.h b/layout/generic/nsFrame.h
--- a/layout/generic/nsFrame.h
+++ b/layout/generic/nsFrame.h
@@ -129,36 +129,40 @@ class nsFrame : public nsBox
   , public nsIFrameDebug
 #endif
 {
 public:
   /**
    * Create a new "empty" frame that maps a given piece of content into a
    * 0,0 area.
    */
-  friend nsIFrame* NS_NewEmptyFrame(nsIPresShell* aShell, nsStyleContext* aContext);
+  friend nsIFrame* NS_NewEmptyFrame(nsIPresShell* aShell,
+                                    nsStyleContext* aContext);
 
-  // Overloaded new operator. Initializes the memory to 0 and relies on an arena
-  // (which comes from the presShell) to perform the allocation.
+  // Overloaded new operator. Relies on an arena (which comes from the
+  // presShell) to perform the allocation.
   void* operator new(size_t sz, nsIPresShell* aPresShell) CPP_THROW_NEW;
 
-  // Overridden to prevent the global delete from being called, since the memory
-  // came out of an arena instead of the global delete operator's heap.  
-  // XXX Would like to make this private some day, but our UNIX compilers can't 
-  // deal with it.
+private:
+  // Left undefined; nsFrame objects are never allocated from the heap.
+  void* operator new(size_t sz) CPP_THROW_NEW;
+
+protected:
+  // Overridden to prevent the global delete from being called, since
+  // the memory came out of an arena instead of the heap.
+  //
+  // Ideally this would be private and undefined, like the normal
+  // operator new.  Unfortunately, the C++ standard requires an
+  // overridden operator delete to be accessible to any subclass that
+  // defines a virtual destructor, so we can only make it protected;
+  // worse, some C++ compilers will synthesize calls to this function
+  // from the "deleting destructors" that they emit in case of
+  // delete-expressions, so it can't even be undefined.
   void operator delete(void* aPtr, size_t sz);
 
-  // We compute and store the HTML content's overflow area. So don't
-  // try to compute it in the box code.
-  virtual PRBool ComputesOwnOverflowArea() { return PR_TRUE; }
-
-private:
-  // The normal operator new is disallowed on nsFrames.
-  void* operator new(size_t sz) CPP_THROW_NEW { return nsnull; }
-
 public:
 
   // nsQueryFrame
   NS_DECL_QUERYFRAME
 
   // nsIFrame
   NS_IMETHOD  Init(nsIContent*      aContent,
                    nsIFrame*        aParent,
@@ -366,16 +370,20 @@ public:
 
   // Box layout methods
   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState);
   virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState);
   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState);
   virtual nscoord GetFlex(nsBoxLayoutState& aBoxLayoutState);
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState);
 
+  // We compute and store the HTML content's overflow area. So don't
+  // try to compute it in the box code.
+  virtual PRBool ComputesOwnOverflowArea() { return PR_TRUE; }
+
   //--------------------------------------------------
   // Additional methods
 
   /**
    * Helper method to invalidate portions of a standard container frame if the
    * desired size indicates that the size has changed (specifically border,
    * background and outline).
    * We assume that the difference between the old frame area and the new
diff --git a/layout/generic/nsLineBox.cpp b/layout/generic/nsLineBox.cpp
--- a/layout/generic/nsLineBox.cpp
+++ b/layout/generic/nsLineBox.cpp
@@ -91,37 +91,37 @@ nsLineBox*
 NS_NewLineBox(nsIPresShell* aPresShell, nsIFrame* aFrame,
               PRInt32 aCount, PRBool aIsBlock)
 {
   return new (aPresShell)nsLineBox(aFrame, aCount, aIsBlock);
 }
 
 // Overloaded new operator. Uses an arena (which comes from the presShell)
 // to perform the allocation.
-void* 
+void*
 nsLineBox::operator new(size_t sz, nsIPresShell* aPresShell) CPP_THROW_NEW
 {
-  return aPresShell->AllocateFrame(sz);
+  return aPresShell->AllocateMisc(sz);
 }
 
 // Overloaded delete operator. Doesn't actually free the memory, because we
 // use an arena
-void 
+void
 nsLineBox::operator delete(void* aPtr, size_t sz)
 {
 }
 
 void
 nsLineBox::Destroy(nsIPresShell* aPresShell)
 {
   // Destroy the object. This won't actually free the memory, though
   delete this;
 
   // Have the pres shell recycle the memory
-  aPresShell->FreeFrame(sizeof(*this), (void*)this);
+  aPresShell->FreeMisc(sizeof(*this), (void*)this);
 }
 
 void
 nsLineBox::Cleanup()
 {
   if (mData) {
     if (IsBlock()) {
       delete mBlockData;
