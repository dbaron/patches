From: L. David Baron <dbaron@dbaron.org>

Bug 977991 patch 5 - Add eRestyle_ChangeAnimationPhase to switch between the with-animation and without-animation styles.

Note that this depends on bug 1057231.

diff --git a/layout/base/nsChangeHint.h b/layout/base/nsChangeHint.h
--- a/layout/base/nsChangeHint.h
+++ b/layout/base/nsChangeHint.h
@@ -301,12 +301,22 @@ enum nsRestyleHint {
   // Replace the style data coming from inline style without updating
   // any other style data.  If a new style context results, update style
   // contexts on the descendants.  (Irrelevant if eRestyle_Self or
   // eRestyle_Subtree is also set, since those imply a superset of the
   // work.)  Supported only for element style contexts and not for
   // pseudo-elements or anonymous boxes, on which it converts to
   // eRestyle_Self.
   eRestyle_StyleAttribute = (1<<6),
+
+  // Additional restyle hint to be used along with CSSTransitions,
+  // CSSAnimations, or StyleAttribute.  This indicates that along with
+  // the replacement given, appropriate switching between the style with
+  // animation and style without animation should be performed by adding
+  // or removing rules that should be present only in the style with
+  // animation.
+  // This is implied by eRestyle_Self or eRestyle_Subtree.
+  // FIXME: Remove this as part of bug 960465.
+  eRestyle_ChangeAnimationPhase = (1 << 7),
 };
 
 
 #endif /* nsChangeHint_h___ */
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1347,22 +1347,39 @@ nsRuleNode*
 nsStyleSet::RuleNodeWithReplacement(Element* aElement,
                                     nsRuleNode* aOldRuleNode,
                                     nsCSSPseudoElements::Type aPseudoType,
                                     nsRestyleHint aReplacements)
 {
   NS_ABORT_IF_FALSE(!(aReplacements & ~(eRestyle_CSSTransitions |
                                         eRestyle_CSSAnimations |
                                         eRestyle_SVGAnimations |
-                                        eRestyle_StyleAttribute)),
+                                        eRestyle_StyleAttribute |
+                                        eRestyle_ChangeAnimationPhase)),
                     // FIXME: Once bug 931668 lands we'll have a better
                     // way to print these.
                     nsPrintfCString("unexpected replacement bits 0x%lX",
                                     uint32_t(aReplacements)).get());
 
+  bool skipAnimationRules = false;
+
+  // If we're changing animation phase, we have to reconsider what rules
+  // are in these three levels.
+  if (aReplacements & eRestyle_ChangeAnimationPhase) {
+    // FIXME: Need to deal with the SMIL style rule added in
+    // nsSVGElement::WalkContentStyleRules (in the ePresHintSheet level).
+    aReplacements |= nsRestyleHint(eRestyle_CSSTransitions |
+                                   eRestyle_CSSAnimations |
+                                   eRestyle_StyleAttribute);
+
+    nsPresContext* presContext = PresContext();
+    skipAnimationRules = presContext->IsProcessingRestyles() &&
+                         !presContext->IsProcessingAnimationStyleChange();
+  }
+
   // FIXME (perf): This should probably not rebuild the whole path, but
   // only the path from the last change in the rule tree, like
   // ReplaceAnimationRule in nsStyleSet.cpp does.  (That could then
   // perhaps share this code, too?)
   // But if we do that, we'll need to pass whether we are rebuilding the
   // rule tree from ElementRestyler::RestyleSelf to avoid taking that
   // path when we're rebuilding the rule tree.
 
@@ -1391,16 +1408,20 @@ nsStyleSet::RuleNodeWithReplacement(Elem
     bool doReplace = level->mLevelReplacementHint & aReplacements;
 
     ruleWalker.SetLevel(level->mLevel, level->mIsImportant,
                         level->mCheckForImportantRules && doReplace);
 
     if (doReplace) {
       switch (level->mLevelReplacementHint) {
         case eRestyle_CSSAnimations: {
+          if (skipAnimationRules) {
+            break;
+          }
+
           // FIXME: This should probably be more similar to what
           // FileRules does; this feels like too much poking into the
           // internals of nsAnimationManager.
           nsAnimationManager* animationManager =
             PresContext()->AnimationManager();
           AnimationPlayerCollection* collection =
             animationManager->GetAnimationPlayers(aElement, aPseudoType, false);
 
@@ -1410,16 +1431,20 @@ nsStyleSet::RuleNodeWithReplacement(Elem
               EnsureStyleRule_IsNotThrottled);
             if (collection->mStyleRule) {
               ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
             }
           }
           break;
         }
         case eRestyle_CSSTransitions: {
+          if (skipAnimationRules) {
+            break;
+          }
+
           // FIXME: This should probably be more similar to what
           // FileRules does; this feels like too much poking into the
           // internals of nsTransitionManager.
           nsPresContext* presContext = PresContext();
           AnimationPlayerCollection* collection =
             presContext->TransitionManager()->GetElementTransitions(
               aElement, aPseudoType, false);
 
@@ -1429,26 +1454,32 @@ nsStyleSet::RuleNodeWithReplacement(Elem
               EnsureStyleRule_IsNotThrottled);
             if (collection->mStyleRule) {
               ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
             }
           }
           break;
         }
         case eRestyle_SVGAnimations: {
+          MOZ_ASSERT(aReplacements & eRestyle_ChangeAnimationPhase,
+                     "don't know how to do this level without phase change");
+
           SVGAnimationRuleProcessor* ruleProcessor =
             static_cast<SVGAnimationRuleProcessor*>(
               mRuleProcessors[eSVGAnimationSheet].get());
           if (ruleProcessor &&
               aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
             ruleProcessor->ElementRulesMatching(aElement, &ruleWalker);
           }
           break;
         }
         case eRestyle_StyleAttribute: {
+          MOZ_ASSERT(aReplacements & eRestyle_ChangeAnimationPhase,
+                     "don't know how to do this level without phase change");
+
           if (!level->mIsImportant) {
             // First time through, we handle the non-!important rule.
             NS_ASSERTION(aPseudoType ==
                            nsCSSPseudoElements::ePseudo_NotPseudoElement,
                          "this code doesn't know how to replace "
                          "pseudo-element rules");
             nsHTMLCSSStyleSheet* ruleProcessor =
               static_cast<nsHTMLCSSStyleSheet*>(
