From: L. David Baron <dbaron@dbaron.org>

Bug 977991 patch 5 - Add eRestyle_ChangeAnimationPhase to switch between the with-animation and without-animation styles.  r=birtles

This is an additional bit on nsRestyleHint that says that the restyling
operation should also perform all the work needed to switch between
style-without-animation and style-with-animation (based on
nsPresContext::IsProcessingAnimationStyleChange).  These concepts will
go away in bug 960465.

Note that we don't want this behavior for the animation-only style
update code (bug 996796, etc.), and I wanted to make this explicit so
that it was clear when it was happening, and so that it was clear what
code should be removed when we git rid of it.

This is the workaround needed to land bug 977991 prior to bug 960465.
(I think there's also a minor dependency in the other direction, so we
need a workaround one way or the other.)

Note that this depends on bug 1057231.

diff --git a/layout/base/nsChangeHint.h b/layout/base/nsChangeHint.h
--- a/layout/base/nsChangeHint.h
+++ b/layout/base/nsChangeHint.h
@@ -317,16 +317,26 @@ enum nsRestyleHint {
   // any other style data.  If a new style context results, update style
   // contexts on the descendants.  (Irrelevant if eRestyle_Self or
   // eRestyle_Subtree is also set, since those imply a superset of the
   // work.)  Supported only for element style contexts and not for
   // pseudo-elements or anonymous boxes, on which it converts to
   // eRestyle_Self.
   eRestyle_StyleAttribute = (1<<6),
 
+  // Additional restyle hint to be used along with CSSTransitions,
+  // CSSAnimations, SVGAttrAnimations, or StyleAttribute.  This
+  // indicates that along with the replacement given, appropriate
+  // switching between the style with animation and style without
+  // animation should be performed by adding or removing rules that
+  // should be present only in the style with animation.
+  // This is implied by eRestyle_Self or eRestyle_Subtree.
+  // FIXME: Remove this as part of bug 960465.
+  eRestyle_ChangeAnimationPhase = (1 << 7),
+
   // Continue the restyling process to the current frame's children even
   // if this frame's restyling resulted in no style changes.
   eRestyle_Force = (1<<8),
 
   // Continue the restyling process to all of the current frame's
   // descendants, even if any frame's restyling resulted in no style
   // changes.  (Implies eRestyle_Force.)
   eRestyle_ForceDescendants = (1<<9),
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1355,22 +1355,38 @@ nsRuleNode*
 nsStyleSet::RuleNodeWithReplacement(Element* aElement,
                                     nsRuleNode* aOldRuleNode,
                                     nsCSSPseudoElements::Type aPseudoType,
                                     nsRestyleHint aReplacements)
 {
   NS_ABORT_IF_FALSE(!(aReplacements & ~(eRestyle_CSSTransitions |
                                         eRestyle_CSSAnimations |
                                         eRestyle_SVGAttrAnimations |
-                                        eRestyle_StyleAttribute)),
+                                        eRestyle_StyleAttribute |
+                                        eRestyle_ChangeAnimationPhase)),
                     // FIXME: Once bug 931668 lands we'll have a better
                     // way to print these.
                     nsPrintfCString("unexpected replacement bits 0x%lX",
                                     uint32_t(aReplacements)).get());
 
+  bool skipAnimationRules = false;
+
+  // If we're changing animation phase, we have to reconsider what rules
+  // are in these four levels.
+  if (aReplacements & eRestyle_ChangeAnimationPhase) {
+    aReplacements |= eRestyle_CSSTransitions |
+                     eRestyle_CSSAnimations |
+                     eRestyle_SVGAttrAnimations |
+                     eRestyle_StyleAttribute;
+
+    nsPresContext* presContext = PresContext();
+    skipAnimationRules = presContext->IsProcessingRestyles() &&
+                         !presContext->IsProcessingAnimationStyleChange();
+  }
+
   // FIXME (perf): This should probably not rebuild the whole path, but
   // only the path from the last change in the rule tree, like
   // ReplaceAnimationRule in nsStyleSet.cpp does.  (That could then
   // perhaps share this code, too?)
   // But if we do that, we'll need to pass whether we are rebuilding the
   // rule tree from ElementRestyler::RestyleSelf to avoid taking that
   // path when we're rebuilding the rule tree.
 
@@ -1402,61 +1418,76 @@ nsStyleSet::RuleNodeWithReplacement(Elem
                         level->mCheckForImportantRules && doReplace);
 
     if (doReplace) {
       switch (level->mLevelReplacementHint) {
         case eRestyle_CSSAnimations: {
           // FIXME: This should probably be more similar to what
           // FileRules does; this feels like too much poking into the
           // internals of nsAnimationManager.
+          nsPresContext* presContext = PresContext();
           nsAnimationManager* animationManager =
-            PresContext()->AnimationManager();
+            presContext->AnimationManager();
           AnimationPlayerCollection* collection =
             animationManager->GetAnimationPlayers(aElement, aPseudoType, false);
 
           if (collection) {
-            animationManager->UpdateStyleAndEvents(
-              collection, PresContext()->RefreshDriver()->MostRecentRefresh(),
-              EnsureStyleRule_IsNotThrottled);
-            if (collection->mStyleRule) {
-              ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
+            if (skipAnimationRules) {
+              collection->PostRestyleForAnimation(presContext);
+            } else {
+              animationManager->UpdateStyleAndEvents(
+                collection, PresContext()->RefreshDriver()->MostRecentRefresh(),
+                EnsureStyleRule_IsNotThrottled);
+              if (collection->mStyleRule) {
+                ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
+              }
             }
           }
           break;
         }
         case eRestyle_CSSTransitions: {
           // FIXME: This should probably be more similar to what
           // FileRules does; this feels like too much poking into the
           // internals of nsTransitionManager.
           nsPresContext* presContext = PresContext();
           AnimationPlayerCollection* collection =
             presContext->TransitionManager()->GetElementTransitions(
               aElement, aPseudoType, false);
 
           if (collection) {
-            collection->EnsureStyleRuleFor(
-              presContext->RefreshDriver()->MostRecentRefresh(),
-              EnsureStyleRule_IsNotThrottled);
-            if (collection->mStyleRule) {
-              ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
+            if (skipAnimationRules) {
+              collection->PostRestyleForAnimation(presContext);
+            } else {
+              collection->EnsureStyleRuleFor(
+                presContext->RefreshDriver()->MostRecentRefresh(),
+                EnsureStyleRule_IsNotThrottled);
+              if (collection->mStyleRule) {
+                ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
+              }
             }
           }
           break;
         }
         case eRestyle_SVGAttrAnimations: {
+          MOZ_ASSERT(aReplacements & eRestyle_ChangeAnimationPhase,
+                     "don't know how to do this level without phase change");
+
           SVGAttrAnimationRuleProcessor* ruleProcessor =
             static_cast<SVGAttrAnimationRuleProcessor*>(
               mRuleProcessors[eSVGAttrAnimationSheet].get());
           if (ruleProcessor &&
               aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
             ruleProcessor->ElementRulesMatching(aElement, &ruleWalker);
           }
           break;
         }
         case eRestyle_StyleAttribute: {
+          MOZ_ASSERT(aReplacements & eRestyle_ChangeAnimationPhase,
+                     "don't know how to do this level without phase change");
+
           if (!level->mIsImportant) {
             // First time through, we handle the non-!important rule.
             MOZ_ASSERT(aPseudoType ==
                          nsCSSPseudoElements::ePseudo_NotPseudoElement,
                        "this code doesn't know how to replace "
                        "pseudo-element rules");
             nsHTMLCSSStyleSheet* ruleProcessor =
               static_cast<nsHTMLCSSStyleSheet*>(
