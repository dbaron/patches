From: L. David Baron <dbaron@dbaron.org>

Bug 1087536 patch 1 - Record the transition manager's cover rule as in the eTransitionSheet level of the cascade so that ResolveStyleWithReplacement replaces it correctly.

Without this patch, patch 3 will cause bugs where we'll never remove the
cover rule we create during the process of starting a transition.  This
won't actually be problematic during the transition, since the
transition will overwrite it, but once the transition completes, the
cover rule will still be around, and we'll be stuck with the
pre-transition value instead of the post-transition value.

It's possible it also fixes existing bugs prior to the patch series in
this bug.

diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1277,19 +1277,23 @@ nsStyleSet::ResolveStyleForRules(nsStyle
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleByAddingRules(nsStyleContext* aBaseContext,
                                       const nsCOMArray<nsIStyleRule> &aRules)
 {
   NS_ENSURE_FALSE(mInShutdown, nullptr);
 
   nsRuleWalker ruleWalker(mRuleTree, mAuthorStyleDisabled);
   ruleWalker.SetCurrentNode(aBaseContext->RuleNode());
-  // FIXME: Perhaps this should be passed in, but it probably doesn't
-  // matter.
-  ruleWalker.SetLevel(eDocSheet, false, false);
+  // This needs to be the transition sheet because that is the highest
+  // level of the cascade, and thus the only thing that makes sense if
+  // we are ever going to call ResolveStyleWithReplacement on the
+  // resulting context.  It's also the right thing for the one case (the
+  // transition manager's cover rule) where we put the result of this
+  // function in the style context tree.
+  ruleWalker.SetLevel(eTransitionSheet, false, false);
   for (int32_t i = 0; i < aRules.Count(); i++) {
     ruleWalker.ForwardOnPossiblyCSSRule(aRules.ObjectAt(i));
   }
 
   nsRuleNode *ruleNode = ruleWalker.CurrentNode();
   nsRuleNode *visitedRuleNode = nullptr;
 
   if (aBaseContext->GetStyleIfVisited()) {
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -110,16 +110,27 @@ class nsStyleSet
   // sequence of style rules in the |aRules| array.
   already_AddRefed<nsStyleContext>
   ResolveStyleForRules(nsStyleContext* aParentContext,
                        const nsTArray< nsCOMPtr<nsIStyleRule> > &aRules);
 
   // Get a style context that represents aBaseContext, but as though
   // it additionally matched the rules in the aRules array (in that
   // order, as more specific than any other rules).
+  //
+  // One of the following must hold:
+  // 1. The resulting style context must be used only on a temporary
+  //    basis, and it must never be put into the style context tree
+  //    (and, in particular, we must never call
+  //    ResolveStyleWithReplacement with it as the old context, which
+  //    might happen if it is put in the style context tree), or
+  // 2. The additional rules must be appropriate for the transitions
+  //    level of the cascade, which is the highest level of the cascade.
+  //    (This is the case for one current caller, the cover rule used
+  //    for CSS transitions.)
   already_AddRefed<nsStyleContext>
   ResolveStyleByAddingRules(nsStyleContext* aBaseContext,
                             const nsCOMArray<nsIStyleRule> &aRules);
 
   // Resolve style by making replacements in the list of style rules as
   // described by aReplacements, but otherwise maintaining the status
   // quo.
   already_AddRefed<nsStyleContext>
