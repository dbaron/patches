From: Brendan Eich <brendan@mozilla.org>

Fix DEBUG bustage.  (Bug 595615)  r=dbaron

diff --git a/js/src/jspropertytree.cpp b/js/src/jspropertytree.cpp
--- a/js/src/jspropertytree.cpp
+++ b/js/src/jspropertytree.cpp
@@ -433,16 +433,46 @@ PropertyTree::getChild(JSContext *cx, Sh
         return NULL;
 
   out:
     JS_UNLOCK_GC(cx->runtime);
     return shape;
 }
 
 #ifdef DEBUG
+
+void
+KidsPointer::checkConsistency(const Shape *aKid) const
+{
+    if (isShape()) {
+        JS_ASSERT(toShape() == aKid);
+    } else if (isChunk()) {
+        bool found = false;
+        for (KidsChunk *chunk = toChunk(); chunk; chunk = chunk->next) {
+            for (uintN i = 0; i < MAX_KIDS_PER_CHUNK; i++) {
+                if (!chunk->kids[i]) {
+                    JS_ASSERT(!chunk->next);
+                    for (uintN j = i + 1; j < MAX_KIDS_PER_CHUNK; j++)
+                        JS_ASSERT(!chunk->kids[j]);
+                    JS_ASSERT(found);
+                }
+                if (chunk->kids[i] == aKid) {
+                    JS_ASSERT(!found);
+                    found = true;
+                }
+            }
+        }
+    } else {
+        JS_ASSERT(isHash());
+        KidsHash *hash = toHash();
+        KidsHash::Ptr ptr = hash->lookup(aKid);
+        JS_ASSERT(*ptr == aKid);
+    }
+}
+
 void
 Shape::dump(JSContext *cx, FILE *fp) const
 {
     JS_ASSERT(!JSID_IS_VOID(id));
 
     if (JSID_IS_INT(id)) {
         fprintf(fp, "[%ld]", (long) JSID_TO_INT(id));
     } else {
@@ -490,19 +520,16 @@ Shape::dump(JSContext *cx, FILE *fp) con
         DUMP_FLAG(SHAPE_REGEN, shape_regen);
         DUMP_FLAG(IN_DICTIONARY, in_dictionary);
 #undef  DUMP_FLAG
         fputs(") ", fp);
     }
 
     fprintf(fp, "shortid %d\n", shortid);
 }
-#endif
-
-#ifdef DEBUG
 
 static void
 MeterKidCount(JSBasicStats *bs, uintN nkids)
 {
     JS_BASIC_STATS_ACCUM(bs, nkids);
 }
 
 void
diff --git a/js/src/jspropertytree.h b/js/src/jspropertytree.h
--- a/js/src/jspropertytree.h
+++ b/js/src/jspropertytree.h
@@ -112,16 +112,20 @@ class KidsPointer {
         JS_ASSERT(isHash());
         return reinterpret_cast<KidsHash *>(w & ~jsuword(TAG));
     }
     void setHash(KidsHash *hash) {
         JS_ASSERT(hash);
         JS_ASSERT((reinterpret_cast<jsuword>(hash) & TAG) == 0);
         w = reinterpret_cast<jsuword>(hash) | HASH;
     }
+
+#ifdef DEBUG
+    void checkConsistency(const js::Shape *aKid) const;
+#endif
 };
 
 class PropertyTree
 {
     friend struct ::JSFunction;
 
     JSArenaPool arenaPool;
     js::Shape   *freeList;
diff --git a/js/src/jsscope.cpp b/js/src/jsscope.cpp
--- a/js/src/jsscope.cpp
+++ b/js/src/jsscope.cpp
@@ -682,40 +682,17 @@ JSObject::checkShapeConsistency()
                 JS_ASSERT(shape->parent);
                 for (Shape::Range r(shape); !r.empty(); r.popFront()) {
                     Shape **spp = table->search(r.front().id, false);
                     JS_ASSERT(SHAPE_FETCH(spp) == &r.front());
                 }
             }
             if (prev) {
                 JS_ASSERT(prev->slotSpan >= shape->slotSpan);
-                if (shape->kids.isShape()) {
-                    JS_ASSERT(shape->kids.toShape() == prev);
-                } else if (shape->kids.isChunk()) {
-                    bool found = false;
-                    for (KidsChunk *chunk = shape->kids.toChunk(); chunk; chunk = chunk->next) {
-                        for (uintN i = 0; i < MAX_KIDS_PER_CHUNK; i++) {
-                            if (!chunk->kids[i]) {
-                                JS_ASSERT(!chunk->next);
-                                for (uintN j = i + 1; j < MAX_KIDS_PER_CHUNK; j++)
-                                    JS_ASSERT(!chunk->kids[j]);
-                                JS_ASSERT(found);
-                            }
-                            if (chunk->kids[i] == prev) {
-                                JS_ASSERT(!found);
-                                found = true;
-                            }
-                        }
-                    }
-                } else {
-                    JS_ASSERT(shape->kids.isHash());
-                    KidsHash *hash = shape->kids.toHash();
-                    KidsHash::Ptr ptr = hash->lookup(prev);
-                    JS_ASSERT(*ptr == prev);
-                }
+                shape->kids.checkConsistency(prev);
             }
             prev = shape;
         }
 
         if (throttle == 0) {
             JS_ASSERT(!shape->table);
             JS_ASSERT(JSID_IS_EMPTY(shape->id));
             JS_ASSERT(shape->slot == SHAPE_INVALID_SLOT);
