From: L. David Baron <dbaron@dbaron.org>

Bug 898329 patch 6:  Avoid using pseudoTag outside of what will be in RestyleManager::RestyleSelf.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1991,16 +1991,22 @@ ElementRestyler::ElementRestyler(ParentC
 {
 }
 
 void
 ElementRestyler::CaptureChange(nsStyleContext* aOldContext,
                                nsStyleContext* aNewContext,
                                nsChangeHint aChangeToAssume)
 {
+  // Check some invariants about replacing one style context with another.
+  NS_ASSERTION(aOldContext->GetPseudo() == aNewContext->GetPseudo(),
+               "old and new style contexts should have the same pseudo");
+  NS_ASSERTION(aOldContext->GetPseudoType() == aNewContext->GetPseudoType(),
+               "old and new style contexts should have the same pseudo");
+
   nsChangeHint ourChange = aOldContext->CalcStyleDifference(aNewContext,
                              mParentFrameHintsNotHandledForDescendants);
   NS_ASSERTION(!(ourChange & nsChangeHint_AllReflowHints) ||
                (ourChange & nsChangeHint_NeedReflow),
                "Reflow hint bits set without actually asking for a reflow");
 
   // nsChangeHint_UpdateEffects is inherited, but it can be set due to changes
   // in inherited properties (fill and stroke).  Avoid propagating it into
@@ -2332,17 +2338,17 @@ ElementRestyler::Restyle(nsRestyleHint a
     // now look for undisplayed child content and pseudos
 
     // When the root element is display:none, we still construct *some*
     // frames that have the root element as their mContent, down to the
     // DocElementContainingBlock.
     bool checkUndisplayed;
     nsIContent* undisplayedParent;
     nsCSSFrameConstructor* frameConstructor = mPresContext->FrameConstructor();
-    if (pseudoTag) {
+    if (mFrame->StyleContext()->GetPseudo()) {
       checkUndisplayed = mFrame == frameConstructor->
                                      GetDocElementContainingBlock();
       undisplayedParent = nullptr;
     } else {
       checkUndisplayed = !!mFrame->GetContent();
       undisplayedParent = mFrame->GetContent();
     }
     if (checkUndisplayed &&
@@ -2419,17 +2425,17 @@ ElementRestyler::Restyle(nsRestyleHint a
     // It's also important to check mHintsHandled since we use
     // mFrame->StyleContext(), which is out of date if mHintsHandled has a
     // ReconstructFrame hint.  Using an out of date style context could
     // trigger assertions about mismatched rule trees.
     if (!(mHintsHandled & nsChangeHint_ReconstructFrame) &&
         childRestyleHint) {
       // Make sure not to do this for pseudo-frames or frames that
       // can't have generated content.
-      if (!pseudoTag &&
+      if (!mFrame->StyleContext()->GetPseudo() &&
           ((mFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
            // Our content insertion frame might have gotten flagged
            (mFrame->GetContentInsertionFrame()->GetStateBits() &
             NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
         // Check for a new :before pseudo and an existing :before
         // frame, but only if the frame is the first continuation.
         nsIFrame* prevContinuation = mFrame->GetPrevContinuation();
         if (!prevContinuation) {
@@ -2450,17 +2456,17 @@ ElementRestyler::Restyle(nsRestyleHint a
     }
 
     // Check whether we might need to create a new ::after frame.
     // See comments above regarding :before.
     if (!(mHintsHandled & nsChangeHint_ReconstructFrame) &&
         childRestyleHint) {
       // Make sure not to do this for pseudo-frames or frames that
       // can't have generated content.
-      if (!pseudoTag &&
+      if (!mFrame->StyleContext()->GetPseudo() &&
           ((mFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
            // Our content insertion frame might have gotten flagged
            (mFrame->GetContentInsertionFrame()->GetStateBits() &
             NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
         // Check for new :after content, but only if the frame is the
         // last continuation.
         nsIFrame* nextContinuation = mFrame->GetNextContinuation();
 
