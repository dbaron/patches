From: L. David Baron <dbaron@dbaron.org>

Ensure that a counter increment that would go past our internal limits doesn't change the counter.

Per CSS WG resolution, afternoon of 2013-02-05.
http://krijnhoetmer.nl/irc-logs/css/20130205#l-1590

diff --git a/layout/base/nsCounterManager.cpp b/layout/base/nsCounterManager.cpp
--- a/layout/base/nsCounterManager.cpp
+++ b/layout/base/nsCounterManager.cpp
@@ -53,17 +53,25 @@ void nsCounterUseNode::Calc(nsCounterLis
 void nsCounterChangeNode::Calc(nsCounterList *aList)
 {
     NS_ASSERTION(!aList->IsDirty(),
                  "Why are we calculating with a dirty list?");
     if (mType == RESET) {
         mValueAfter = mChangeValue;
     } else {
         NS_ASSERTION(mType == INCREMENT, "invalid type");
-        mValueAfter = aList->ValueBefore(this) + mChangeValue;
+        int32_t valueBefore = aList->ValueBefore(this);
+        int32_t valueAfter = valueBefore + mChangeValue;
+        // The CSS Working Group resolved that a counter-increment that
+        // exceeds internal limits should not increment at all.
+        // http://krijnhoetmer.nl/irc-logs/css/20130205#l-1590
+        if ((mChangeValue > 0) != (valueAfter > valueBefore)) {
+          valueAfter = valueBefore;
+        }
+        mValueAfter = valueAfter;
     }
 }
 
 // The text that should be displayed for this counter.
 void
 nsCounterUseNode::GetText(nsString& aResult)
 {
     aResult.Truncate();
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -6753,16 +6753,18 @@ nsBlockFrame::RenumberLists(nsPresContex
     ordinal = attr->GetIntegerValue();
   } else if (increment < 0) {
     // <ol reversed> case, or some other case with a negative increment: count
     // up the child list
     ordinal = 0;
     for (nsIContent* kid = mContent->GetFirstChild(); kid;
          kid = kid->GetNextSibling()) {
       if (kid->IsHTML(nsGkAtoms::li)) {
+        // FIXME: This isn't right in terms of what CSS says to do for
+        // overflow of counters.
         ordinal -= increment;
       }
     }
   }
 
   // Get to first-in-flow
   nsBlockFrame* block = (nsBlockFrame*) GetFirstInFlow();
   return RenumberListsInBlock(aPresContext, block, &ordinal, 0, increment);
diff --git a/layout/generic/nsBulletFrame.cpp b/layout/generic/nsBulletFrame.cpp
--- a/layout/generic/nsBulletFrame.cpp
+++ b/layout/generic/nsBulletFrame.cpp
@@ -412,17 +412,26 @@ nsBulletFrame::SetListItemOrdinal(int32_
         // Use ordinal specified by the value attribute
         mOrdinal = attr->GetIntegerValue();
       }
     }
   }
 
   *aChanged = oldOrdinal != mOrdinal;
 
-  return mOrdinal + aIncrement;
+  int32_t nextOrdinal = mOrdinal + aIncrement;
+
+  // The CSS Working Group resolved that a counter-increment that
+  // exceeds internal limits should not increment at all.
+  // http://krijnhoetmer.nl/irc-logs/css/20130205#l-1590
+  if ((aIncrement > 0) != (nextOrdinal > mOrdinal)) {
+    nextOrdinal = mOrdinal;
+  }
+
+  return nextOrdinal;
 }
 
 
 // XXX change roman/alpha to use unsigned math so that maxint and
 // maxnegint will work
 
 /**
  * For all functions below, a return value of true means that we
