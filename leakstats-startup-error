Don't count frees of things whose allocations weren't counted because they were before we overrode malloc, etc.

diff --git a/tools/trace-malloc/leakstats.c b/tools/trace-malloc/leakstats.c
--- a/tools/trace-malloc/leakstats.c
+++ b/tools/trace-malloc/leakstats.c
@@ -55,6 +55,7 @@ int optind=1;
 #include <time.h>
 #include "nsTraceMalloc.h"
 #include "tmreader.h"
+#include "prlog.h"
 
 static char *program;
 
@@ -87,8 +88,13 @@ static void my_tmevent_handler(tmreader 
 
     switch (event->type) {
       case TM_EVENT_REALLOC:
-        data->current_heapsize -= event->u.alloc.oldsize;
-        --data->current_allocations;
+        /* On Windows, original allocation could be before we overrode malloc */
+        if (event->u.alloc.oldserial != 0) {
+          data->current_heapsize -= event->u.alloc.oldsize;
+          --data->current_allocations;
+        } else {
+          PR_ASSERT(event->u.alloc.oldsize == 0);
+        }
         /* fall-through intentional */
       case TM_EVENT_MALLOC:
       case TM_EVENT_CALLOC:
@@ -100,8 +106,13 @@ static void my_tmevent_handler(tmreader 
             data->max_heapsize = data->current_heapsize;
         break;
       case TM_EVENT_FREE:
-        --data->current_allocations;
-        data->current_heapsize -= event->u.alloc.size;
+        /* On Windows, original allocation could be before we overrode malloc */
+        if (event->serial != 0) {
+          --data->current_allocations;
+          data->current_heapsize -= event->u.alloc.size;
+        } else {
+          PR_ASSERT(event->u.alloc.size == 0);
+        }
         break;
       case TM_EVENT_STATS:
         data->finished = 1;
