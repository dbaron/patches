Don't count frees of things whose allocations weren't counted because they were before we overrode malloc, etc.

diff --git a/tools/trace-malloc/leakstats.c b/tools/trace-malloc/leakstats.c
--- a/tools/trace-malloc/leakstats.c
+++ b/tools/trace-malloc/leakstats.c
@@ -87,8 +87,11 @@ static void my_tmevent_handler(tmreader 
 
     switch (event->type) {
       case TM_EVENT_REALLOC:
-        data->current_heapsize -= event->u.alloc.oldsize;
-        --data->current_allocations;
+        // On Windows, the allocation may have been before we overrode malloc.
+        if (event->u.alloc.oldsite != 0) {
+          data->current_heapsize -= event->u.alloc.oldsize;
+          --data->current_allocations;
+        }
         /* fall-through intentional */
       case TM_EVENT_MALLOC:
       case TM_EVENT_CALLOC:
@@ -100,8 +103,11 @@ static void my_tmevent_handler(tmreader 
             data->max_heapsize = data->current_heapsize;
         break;
       case TM_EVENT_FREE:
-        --data->current_allocations;
-        data->current_heapsize -= event->u.alloc.size;
+        // On Windows, the allocation may have been before we overrode malloc.
+        if (event->u.alloc.site != 0) {
+          --data->current_allocations;
+          data->current_heapsize -= event->u.alloc.size;
+        }
         break;
       case TM_EVENT_STATS:
         data->finished = 1;
