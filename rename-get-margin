From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::GetMargin to GetXULMargin.

This is a manual subset of changes written with sed, over .h and .cpp
files in layout/.

MozReview-Commit-ID: GqAa9wyb8z3

diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -8959,17 +8959,17 @@ nsFrame::BoxReflow(nsBoxLayoutState&    
 
     aDesiredSize.ClearSize();
 
     // create a reflow state to tell our child to flow at the given size.
 
     // Construct a bogus parent reflow state so that there's a usable
     // containing block reflow state.
     nsMargin margin(0,0,0,0);
-    GetMargin(margin);
+    GetXULMargin(margin);
 
     nsSize parentSize(aWidth, aHeight);
     if (parentSize.height != NS_INTRINSICSIZE)
       parentSize.height += margin.TopBottom();
     if (parentSize.width != NS_INTRINSICSIZE)
       parentSize.width += margin.LeftRight();
 
     nsIFrame *parentFrame = GetParent();
diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -1384,17 +1384,17 @@ nsXULScrollFrame::GetXULBoxAscent(nsBoxL
 {
   if (!mHelper.mScrolledFrame)
     return 0;
 
   nscoord ascent = mHelper.mScrolledFrame->GetXULBoxAscent(aState);
   nsMargin m(0,0,0,0);
   GetXULBorderAndPadding(m);
   ascent += m.top;
-  GetMargin(m);
+  GetXULMargin(m);
   ascent += m.top;
 
   return ascent;
 }
 
 nsSize
 nsXULScrollFrame::GetXULPrefSize(nsBoxLayoutState& aState)
 {
@@ -5355,34 +5355,34 @@ ScrollFrameHelper::LayoutScrollbars(nsBo
     vRect = mScrollPort;
     if (overlayScrollBarsWithZoom) {
       vRect.height = NSToCoordRound(res * scrollPortClampingSize.height);
     }
     vRect.width = aContentArea.width - mScrollPort.width;
     vRect.x = scrollbarOnLeft ? aContentArea.x : mScrollPort.x + NSToCoordRound(res * scrollPortClampingSize.width);
     if (mHasVerticalScrollbar) {
       nsMargin margin;
-      mVScrollbarBox->GetMargin(margin);
+      mVScrollbarBox->GetXULMargin(margin);
       vRect.Deflate(margin);
     }
     AdjustScrollbarRectForResizer(mOuter, presContext, vRect, hasResizer, true);
   }
 
   nsRect hRect;
   if (mHScrollbarBox) {
     NS_PRECONDITION(mHScrollbarBox->IsXULBoxFrame(), "Must be a box frame!");
     hRect = mScrollPort;
     if (overlayScrollBarsWithZoom) {
       hRect.width = NSToCoordRound(res * scrollPortClampingSize.width);
     }
     hRect.height = aContentArea.height - mScrollPort.height;
     hRect.y = mScrollPort.y + NSToCoordRound(res * scrollPortClampingSize.height);
     if (mHasHorizontalScrollbar) {
       nsMargin margin;
-      mHScrollbarBox->GetMargin(margin);
+      mHScrollbarBox->GetXULMargin(margin);
       hRect.Deflate(margin);
     }
     AdjustScrollbarRectForResizer(mOuter, presContext, hRect, hasResizer, false);
   }
 
   if (!LookAndFeel::GetInt(LookAndFeel::eIntID_AllowOverlayScrollbarsOverlap)) {
     AdjustOverlappingScrollbars(vRect, hRect);
   }
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2910,17 +2910,17 @@ public:
   virtual void SetXULBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
                             bool aRemoveOverflowAreas = false) = 0;
   nsresult XULLayout(nsBoxLayoutState& aBoxLayoutState);
   // Box methods.  Note that these do NOT just get the CSS border, padding,
   // etc.  They also talk to nsITheme.
   virtual nsresult GetXULBorderAndPadding(nsMargin& aBorderAndPadding);
   virtual nsresult GetXULBorder(nsMargin& aBorder)=0;
   virtual nsresult GetXULPadding(nsMargin& aBorderAndPadding)=0;
-  virtual nsresult GetMargin(nsMargin& aMargin)=0;
+  virtual nsresult GetXULMargin(nsMargin& aMargin)=0;
   virtual void SetLayoutManager(nsBoxLayout* aLayout) { }
   virtual nsBoxLayout* GetLayoutManager() { return nullptr; }
   nsresult GetClientRect(nsRect& aContentRect);
 
   // For nsSprocketLayout
   virtual Valignment GetVAlign() const = 0;
   virtual Halignment GetHAlign() const = 0;
 
diff --git a/layout/xul/grid/nsGridRowLayout.cpp b/layout/xul/grid/nsGridRowLayout.cpp
--- a/layout/xul/grid/nsGridRowLayout.cpp
+++ b/layout/xul/grid/nsGridRowLayout.cpp
@@ -177,17 +177,17 @@ nsGridRowLayout::GetTotalMargin(nsIFrame
               margin.right = 0;
        }
 
     }
   }
     
   // add ours to it.
   nsMargin ourMargin;
-  aBox->GetMargin(ourMargin);
+  aBox->GetXULMargin(ourMargin);
   margin += ourMargin;
 
   return margin;
 }
 
 NS_IMPL_ADDREF_INHERITED(nsGridRowLayout, nsBoxLayout)
 NS_IMPL_RELEASE_INHERITED(nsGridRowLayout, nsBoxLayout)
 
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -353,17 +353,17 @@ nsBox::GetXULPadding(nsMargin& aMargin)
 
   aMargin.SizeTo(0,0,0,0);
   StylePadding()->GetPadding(aMargin);
 
   return NS_OK;
 }
 
 nsresult
-nsBox::GetMargin(nsMargin& aMargin)
+nsBox::GetXULMargin(nsMargin& aMargin)
 {
   aMargin.SizeTo(0,0,0,0);
   StyleMargin()->GetMargin(aMargin);
 
   return NS_OK;
 }
 
 void
@@ -876,17 +876,17 @@ nsBox::AddBorderAndPadding(nsIFrame* aBo
   aBox->GetXULBorderAndPadding(borderPadding);
   AddMargin(aSize, borderPadding);
 }
 
 void
 nsBox::AddMargin(nsIFrame* aChild, nsSize& aSize)
 {
   nsMargin margin(0,0,0,0);
-  aChild->GetMargin(margin);
+  aChild->GetXULMargin(margin);
   AddMargin(aSize, margin);
 }
 
 void
 nsBox::AddMargin(nsSize& aSize, const nsMargin& aMargin)
 {
   if (aSize.width != NS_INTRINSICSIZE)
     aSize.width += aMargin.left + aMargin.right;
diff --git a/layout/xul/nsBox.h b/layout/xul/nsBox.h
--- a/layout/xul/nsBox.h
+++ b/layout/xul/nsBox.h
@@ -29,17 +29,17 @@ public:
 
   virtual bool IsXULCollapsed() override;
 
   virtual void SetXULBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
                             bool aRemoveOverflowAreas = false) override;
 
   virtual nsresult GetXULBorder(nsMargin& aBorderAndPadding) override;
   virtual nsresult GetXULPadding(nsMargin& aBorderAndPadding) override;
-  virtual nsresult GetMargin(nsMargin& aMargin) override;
+  virtual nsresult GetXULMargin(nsMargin& aMargin) override;
 
   virtual Valignment GetVAlign() const override { return vAlign_Top; }
   virtual Halignment GetHAlign() const override { return hAlign_Left; }
 
   virtual nsresult RelayoutChildAtOrdinal(nsIFrame* aChild) override;
 
 #ifdef DEBUG_LAYOUT
   NS_IMETHOD GetDebugBoxAt(const nsPoint& aPoint, nsIFrame** aBox);
diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -1478,17 +1478,17 @@ nsBoxFrame::PaintXULDebugOverlay(DrawTar
   kid = nsBox::GetChildXULBox(this);
   while (nullptr != kid) {
     bool isHorizontal = IsHorizontal();
 
     nscoord x, y, borderSize, spacerSize;
     
     nsRect cr(kid->mRect);
     nsMargin margin;
-    kid->GetMargin(margin);
+    kid->GetXULMargin(margin);
     cr.Inflate(margin);
     
     if (isHorizontal) 
     {
         cr.y = inner.y;
         x = cr.x;
         y = cr.y + onePixel;
         spacerSize = debugBorder.top - onePixel*4;
@@ -1845,17 +1845,17 @@ nsBoxFrame::SetDebugOnChildList(nsBoxLay
      }
 }
 
 nsresult
 nsBoxFrame::GetFrameSizeWithMargin(nsIFrame* aBox, nsSize& aSize)
 {
   nsRect rect(aBox->GetRect());
   nsMargin margin(0,0,0,0);
-  aBox->GetMargin(margin);
+  aBox->GetXULMargin(margin);
   rect.Inflate(margin);
   aSize.width = rect.width;
   aSize.height = rect.height;
   return NS_OK;
 }
 #endif
 
 // If you make changes to this function, check its counterparts
diff --git a/layout/xul/nsListBoxLayout.cpp b/layout/xul/nsListBoxLayout.cpp
--- a/layout/xul/nsListBoxLayout.cpp
+++ b/layout/xul/nsListBoxLayout.cpp
@@ -140,17 +140,17 @@ nsListBoxLayout::LayoutInternal(nsIFrame
 
   // if the reason is resize or initial we must relayout.
   nscoord rowHeight = body->GetRowHeightAppUnits();
 
   while (box) {
     // If this box is dirty or if it has dirty children, we
     // call layout on it.
     nsRect childRect(box->GetRect());
-    box->GetMargin(margin);
+    box->GetXULMargin(margin);
     
     // relayout if we must or we are dirty or some of our children are dirty
     //   or the client area is wider than us
     // XXXldb There should probably be a resize check here too!
     if (NS_SUBTREE_DIRTY(box) || childRect.width < clientRect.width) {
       childRect.x = 0;
       childRect.y = yOffset;
       childRect.width = clientRect.width;
diff --git a/layout/xul/nsScrollbarFrame.cpp b/layout/xul/nsScrollbarFrame.cpp
--- a/layout/xul/nsScrollbarFrame.cpp
+++ b/layout/xul/nsScrollbarFrame.cpp
@@ -162,17 +162,17 @@ nsScrollbarFrame::GetScrollbarMediator()
     if (f && f->GetContent() == mScrollbarMediator) {
       return do_QueryFrame(f);
     }
   }
   return sbm;
 }
 
 nsresult
-nsScrollbarFrame::GetMargin(nsMargin& aMargin)
+nsScrollbarFrame::GetXULMargin(nsMargin& aMargin)
 {
   nsresult rv = NS_ERROR_FAILURE;
   aMargin.SizeTo(0,0,0,0);
 
   if (LookAndFeel::GetInt(LookAndFeel::eIntID_UseOverlayScrollbars) != 0) {
     nsPresContext* presContext = PresContext();
     nsITheme* theme = presContext->GetTheme();
     if (theme) {
@@ -186,17 +186,17 @@ nsScrollbarFrame::GetMargin(nsMargin& aM
       else {
         aMargin.left = -presContext->DevPixelsToAppUnits(size.width);
       }
       rv = NS_OK;
     }
   }
 
   if (NS_FAILED(rv)) {
-    rv = nsBox::GetMargin(aMargin);
+    rv = nsBox::GetXULMargin(aMargin);
   }
 
   if (NS_SUCCEEDED(rv) && !IsHorizontal()) {
     nsIScrollbarMediator* scrollFrame = GetScrollbarMediator();
     if (scrollFrame && !scrollFrame->IsScrollbarOnRight()) {
       Swap(aMargin.left, aMargin.right);
     }
   }
diff --git a/layout/xul/nsScrollbarFrame.h b/layout/xul/nsScrollbarFrame.h
--- a/layout/xul/nsScrollbarFrame.h
+++ b/layout/xul/nsScrollbarFrame.h
@@ -76,17 +76,17 @@ public:
    * Treat scrollbars as clipping their children; overflowing children
    * will not be allowed to set an overflow rect on this
    * frame. This means that when the scroll code decides to hide a
    * scrollframe by setting its height or width to zero, that will
    * hide the children too.
    */
   virtual bool DoesClipChildren() override { return true; }
 
-  virtual nsresult GetMargin(nsMargin& aMargin) override;
+  virtual nsresult GetXULMargin(nsMargin& aMargin) override;
 
   /**
    * The following three methods set the value of mIncrement when a
    * scrollbar button is pressed.
    */
   void SetIncrementToLine(int32_t aDirection);
   void SetIncrementToPage(int32_t aDirection);
   void SetIncrementToWhole(int32_t aDirection);
diff --git a/layout/xul/nsSliderFrame.cpp b/layout/xul/nsSliderFrame.cpp
--- a/layout/xul/nsSliderFrame.cpp
+++ b/layout/xul/nsSliderFrame.cpp
@@ -332,17 +332,17 @@ nsSliderFrame::BuildDisplayListForChildr
                                            const nsDisplayListSet& aLists)
 {
   // if we are too small to have a thumb don't paint it.
   nsIFrame* thumb = nsBox::GetChildXULBox(this);
 
   if (thumb) {
     nsRect thumbRect(thumb->GetRect());
     nsMargin m;
-    thumb->GetMargin(m);
+    thumb->GetXULMargin(m);
     thumbRect.Inflate(m);
 
     nsRect crect;
     GetClientRect(crect);
 
     if (crect.width < thumbRect.width || crect.height < thumbRect.height)
       return;
 
diff --git a/layout/xul/nsSplitterFrame.cpp b/layout/xul/nsSplitterFrame.cpp
--- a/layout/xul/nsSplitterFrame.cpp
+++ b/layout/xul/nsSplitterFrame.cpp
@@ -675,17 +675,17 @@ nsSplitterFrameInner::MouseDown(nsIDOMEv
 
         mOuter->AddMargin(childBox, minSize);
         mOuter->AddMargin(childBox, prefSize);
         mOuter->AddMargin(childBox, maxSize);
 
         nscoord flex = childBox->GetXULFlex();
 
         nsMargin margin(0,0,0,0);
-        childBox->GetMargin(margin);
+        childBox->GetXULMargin(margin);
         nsRect r(childBox->GetRect());
         r.Inflate(margin);
 
         // We need to check for hidden attribute too, since treecols with
         // the hidden="true" attribute are not really hidden, just collapsed
         if (!content->AttrValueIs(kNameSpaceID_None, nsGkAtoms::fixed,
                                   nsGkAtoms::_true, eCaseMatters) &&
             !content->AttrValueIs(kNameSpaceID_None, nsGkAtoms::hidden,
@@ -949,17 +949,17 @@ nsSplitterFrameInner::SetPreferredSize(n
       pref = rect.width;
     else
       pref = rect.height;
   } else {
     pref = *aSize;
   }
 
   nsMargin margin(0,0,0,0);
-  aChildBox->GetMargin(margin);
+  aChildBox->GetXULMargin(margin);
 
   nsCOMPtr<nsIAtom> attribute;
 
   if (aIsHorizontal) {
     pref -= (margin.left + margin.right);
     attribute = nsGkAtoms::width;
   } else {
     pref -= (margin.top + margin.bottom);
diff --git a/layout/xul/nsSprocketLayout.cpp b/layout/xul/nsSprocketLayout.cpp
--- a/layout/xul/nsSprocketLayout.cpp
+++ b/layout/xul/nsSprocketLayout.cpp
@@ -417,17 +417,17 @@ nsSprocketLayout::XULLayout(nsIFrame* aB
         continue;
       }
 
       nsMargin margin(0,0,0,0);
 
       bool layout = true;
 
       // Deflate the rect of our child by its margin.
-      child->GetMargin(margin);
+      child->GetXULMargin(margin);
       childRect.Deflate(margin);
       if (childRect.width < 0)
         childRect.width = 0;
       if (childRect.height < 0)
         childRect.height = 0;
 
       // Now we're trying to figure out if we have to lay out this child, i.e., to call
       // the child's XULLayout method.
@@ -744,17 +744,17 @@ nsSprocketLayout::PopulateBoxSizes(nsIFr
     // 0 then and not even have to ask for it.
     //if (flexes != 1)  {
 
       pref = child->GetXULPrefSize(aState);
       minSize = child->GetXULMinSize(aState);
       maxSize = nsBox::BoundsCheckMinMax(minSize, child->GetXULMaxSize(aState));
       ascent = child->GetXULBoxAscent(aState);
       nsMargin margin;
-      child->GetMargin(margin);
+      child->GetXULMargin(margin);
       ascent += margin.top;
     //}
 
       pref = nsBox::BoundsCheck(minSize, pref, maxSize);
 
       AddMargin(child, pref);
       AddMargin(child, minSize);
       AddMargin(child, maxSize);
@@ -944,17 +944,17 @@ nsSprocketLayout::AlignChildren(nsIFrame
     isLTR = GetFrameDirection(aBox) == NS_STYLE_DIRECTION_LTR;
     halign = aBox->GetHAlign();
   }
 
   nsIFrame* child = nsBox::GetChildXULBox(aBox);
   while (child) {
 
     nsMargin margin;
-    child->GetMargin(margin);
+    child->GetXULMargin(margin);
     nsRect childRect = child->GetRect();
 
     if (isHorizontal) {
       const nscoord startAlign = clientRect.y + margin.top;
       const nscoord endAlign =
         clientRect.YMost() - margin.bottom - childRect.height;
 
       nscoord y;
@@ -1125,17 +1125,17 @@ nsSprocketLayout::ChildResized(nsIFrame*
       if (recompute)
             ComputeChildSizes(aBox, aState, containingWidth, aBoxSizes, aComputedBoxSizes);
 
       if (!childCurrentRect.IsEqualInterior(aChildActualRect)) {
         // the childRect includes the margin
         // make sure we remove it before setting 
         // the bounds.
         nsMargin margin(0,0,0,0);
-        aChild->GetMargin(margin);
+        aChild->GetXULMargin(margin);
         nsRect rect(aChildActualRect);
         if (rect.width >= margin.left + margin.right && rect.height >= margin.top + margin.bottom) 
           rect.Deflate(margin);
 
         aChild->SetXULBounds(aState, rect);
         aChild->XULLayout(aState);
       }
 
@@ -1511,17 +1511,17 @@ nsSprocketLayout::GetAscent(nsIFrame* aB
    {  
       // ignore collapsed children
       //if (!child->IsXULCollapsed())
       //{
         // if completely redefined don't even ask our child for its size.
         nscoord ascent = child->GetXULBoxAscent(aState);
 
         nsMargin margin;
-        child->GetMargin(margin);
+        child->GetXULMargin(margin);
         ascent += margin.top;
 
         if (isHorizontal)
         {
           if (ascent > vAscent)
             vAscent = ascent;
         } else {
           if (vAscent == 0)
diff --git a/layout/xul/nsStackLayout.cpp b/layout/xul/nsStackLayout.cpp
--- a/layout/xul/nsStackLayout.cpp
+++ b/layout/xul/nsStackLayout.cpp
@@ -144,17 +144,17 @@ nscoord
 nsStackLayout::GetAscent(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   nscoord vAscent = 0;
 
   nsIFrame* child = nsBox::GetChildXULBox(aBox);
   while (child) {  
     nscoord ascent = child->GetXULBoxAscent(aState);
     nsMargin margin;
-    child->GetMargin(margin);
+    child->GetXULMargin(margin);
     ascent += margin.top;
     if (ascent > vAscent)
       vAscent = ascent;
 
     child = nsBox::GetNextXULBox(child);
   }
 
   return vAscent;
@@ -261,34 +261,34 @@ nsStackLayout::XULLayout(nsIFrame* aBox,
 
   do {
     nsIFrame* child = nsBox::GetChildXULBox(aBox);
     grow = false;
 
     while (child) 
     {  
       nsMargin margin;
-      child->GetMargin(margin);
+      child->GetXULMargin(margin);
       nsRect childRect(clientRect);
       childRect.Deflate(margin);
 
       if (childRect.width < 0)
         childRect.width = 0;
 
       if (childRect.height < 0)
         childRect.height = 0;
 
       nsRect oldRect(child->GetRect());
       bool sizeChanged = !oldRect.IsEqualEdges(childRect);
 
       // only lay out dirty children or children whose sizes have changed
       if (sizeChanged || NS_SUBTREE_DIRTY(child)) {
           // add in the child's margin
           nsMargin margin;
-          child->GetMargin(margin);
+          child->GetXULMargin(margin);
 
           // obtain our offset from the top left border of the stack's content box.
           nsMargin offset;
           uint8_t offsetSpecified = GetOffset(child, offset);
 
           // Set the position and size based on which offsets have been specified:
           //   left only - offset from left edge, preferred width
           //   right only - offset from right edge, preferred width
