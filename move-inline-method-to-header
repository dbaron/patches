From: L. David Baron <dbaron@dbaron.org>

Bug 1209603 patch 5 - Move inline method nsStyleContext::GetCachedStyleData into header file, and make it public.

Moving it to the header allows its use by another method in the header
file, in patch 6.

Making it public allows its use in assertions in nsRuleNode in patch 7.

diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -407,31 +407,16 @@ nsStyleContext::ListContainsStyleContext
 
 bool
 nsStyleContext::HasChildThatUsesGrandancestorStyle() const
 {
   return ListContainsStyleContextThatUsesGrandancestorStyle(mEmptyChild) ||
          ListContainsStyleContextThatUsesGrandancestorStyle(mChild);
 }
 
-const void* nsStyleContext::GetCachedStyleData(nsStyleStructID aSID)
-{
-  const void* cachedData;
-  if (nsCachedStyleData::IsReset(aSID)) {
-    if (mCachedResetData) {
-      cachedData = mCachedResetData->mStyleStructs[aSID];
-    } else {
-      cachedData = nullptr;
-    }
-  } else {
-    cachedData = mCachedInheritedData.mStyleStructs[aSID];
-  }
-  return cachedData;
-}
-
 const void* nsStyleContext::StyleData(nsStyleStructID aSID)
 {
   const void* cachedData = GetCachedStyleData(aSID);
   if (cachedData)
     return cachedData; // We have computed data stored on this node in the context tree.
   return mRuleNode->GetStyleData(aSID, this, true); // Our rule node will take care of it for us.
 }
 
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -448,36 +448,54 @@ public:
 #endif
 
 #ifdef RESTYLE_LOGGING
   nsCString GetCachedStyleDataAsString(uint32_t aStructs);
   void LogStyleContextTree(int32_t aLoggingDepth, uint32_t aStructs);
   int32_t& LoggingDepth();
 #endif
 
+  /**
+   * Return style data that is currently cached on the style context.
+   * Only returns the structs we cache ourselves; never consults the
+   * ruletree.
+   *
+   * For use only in "internal" use in nsStyleContext and nsRuleNode.
+   */
+  const void* GetCachedStyleData(nsStyleStructID aSID)
+  {
+    const void* cachedData;
+    if (nsCachedStyleData::IsReset(aSID)) {
+      if (mCachedResetData) {
+        cachedData = mCachedResetData->mStyleStructs[aSID];
+      } else {
+        cachedData = nullptr;
+      }
+    } else {
+      cachedData = mCachedInheritedData.mStyleStructs[aSID];
+    }
+    return cachedData;
+  }
+
 private:
   // Private destructor, to discourage deletion outside of Release():
   ~nsStyleContext();
 
   void AddChild(nsStyleContext* aChild);
   void RemoveChild(nsStyleContext* aChild);
 
   void* GetUniqueStyleData(const nsStyleStructID& aSID);
   void* CreateEmptyStyleData(const nsStyleStructID& aSID);
 
   void ApplyStyleFixups(bool aSkipParentDisplayBasedStyleFixup);
 
   // Helper function for HasChildThatUsesGrandancestorStyle.
   static bool ListContainsStyleContextThatUsesGrandancestorStyle(
                                                    const nsStyleContext* aHead);
 
-  // Helper function that GetStyleData and GetUniqueStyleData use.  Only
-  // returns the structs we cache ourselves; never consults the ruletree.
-  inline const void* GetCachedStyleData(nsStyleStructID aSID);
-
 #ifdef DEBUG
   struct AutoCheckDependency {
 
     nsStyleContext* mStyleContext;
     nsStyleStructID mOuterSID;
 
     AutoCheckDependency(nsStyleContext* aContext, nsStyleStructID aInnerSID)
       : mStyleContext(aContext)
