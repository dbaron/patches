From: L. David Baron <dbaron@dbaron.org>

Bug 1057231 patch 4 - Move SVG Animation rules from the pres hint level to their own cascade level.

This is only a very slight reordering of their position in the cascade,
since they were previously walked at the end of
nsSVGElement::WalkContentStyleRules, which was called near the end of
nsHTMLStyleSheet::RulesMatching.  So the only change should be that they
now take priority over the xml:lang rule added by nsHTMLStyleSheet, a
rule with which they do not interact.

FIXME: Fails many mochitests in dom/smil/test/

diff --git a/content/svg/content/src/nsSVGElement.cpp b/content/svg/content/src/nsSVGElement.cpp
--- a/content/svg/content/src/nsSVGElement.cpp
+++ b/content/svg/content/src/nsSVGElement.cpp
@@ -900,16 +900,22 @@ nsSVGElement::WalkContentStyleRules(nsRu
   if (!mContentStyleRule)
     UpdateContentStyleRule();
 
   if (mContentStyleRule) {
     mContentStyleRule->RuleMatched();
     aRuleWalker->Forward(mContentStyleRule);
   }
 
+  return NS_OK;
+}
+
+void
+nsSVGElement::WalkAnimatedContentStyleRules(nsRuleWalker* aRuleWalker)
+{
   // Update & walk the animated content style rule, to include style from
   // animated mapped attributes.  But first, get nsPresContext to check
   // whether this is a "no-animation restyle". (This should match the check
   // in nsHTMLCSSStyleSheet::RulesMatching(), where we determine whether to
   // apply the SMILOverrideStyle.)
   nsIDocument* doc = OwnerDoc();
   nsIPresShell* shell = doc->GetShell();
   nsPresContext* context = shell ? shell->GetPresContext() : nullptr;
@@ -928,18 +934,16 @@ nsSVGElement::WalkContentStyleRules(nsRu
       UpdateAnimatedContentStyleRule();
       animContentStyleRule = GetAnimatedContentStyleRule();
     }
     if (animContentStyleRule) {
       animContentStyleRule->RuleMatched();
       aRuleWalker->Forward(animContentStyleRule);
     }
   }
-
-  return NS_OK;
 }
 
 NS_IMETHODIMP_(bool)
 nsSVGElement::IsAttributeMapped(const nsIAtom* name) const
 {
   if (name == nsGkAtoms::lang) {
     return true;
   }
diff --git a/content/svg/content/src/nsSVGElement.h b/content/svg/content/src/nsSVGElement.h
--- a/content/svg/content/src/nsSVGElement.h
+++ b/content/svg/content/src/nsSVGElement.h
@@ -108,16 +108,17 @@ public:
                              bool aNotify) MOZ_OVERRIDE;
 
   virtual nsChangeHint GetAttributeChangeHint(const nsIAtom* aAttribute,
                                               int32_t aModType) const MOZ_OVERRIDE;
 
   virtual bool IsNodeOfType(uint32_t aFlags) const MOZ_OVERRIDE;
 
   NS_IMETHOD WalkContentStyleRules(nsRuleWalker* aRuleWalker) MOZ_OVERRIDE;
+  void WalkAnimatedContentStyleRules(nsRuleWalker* aRuleWalker);
 
   NS_IMETHOD_(bool) IsAttributeMapped(const nsIAtom* aAttribute) const MOZ_OVERRIDE;
 
   static const MappedAttributeEntry sFillStrokeMap[];
   static const MappedAttributeEntry sGraphicsMap[];
   static const MappedAttributeEntry sTextContentElementsMap[];
   static const MappedAttributeEntry sFontSpecificationMap[];
   static const MappedAttributeEntry sGradientStopMap[];
diff --git a/layout/style/SVGAnimationRuleProcessor.cpp b/layout/style/SVGAnimationRuleProcessor.cpp
--- a/layout/style/SVGAnimationRuleProcessor.cpp
+++ b/layout/style/SVGAnimationRuleProcessor.cpp
@@ -3,32 +3,39 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
  */
 
 /* style rule processor for SVG Animation (SMIL Animation) rules */
 
 #include "SVGAnimationRuleProcessor.h"
+#include "nsRuleProcessorData.h"
+#include "nsSVGElement.h"
 
 using namespace mozilla;
 
 SVGAnimationRuleProcessor::SVGAnimationRuleProcessor()
 {
 }
 
 SVGAnimationRuleProcessor::~SVGAnimationRuleProcessor()
 {
 }
 
 NS_IMPL_ISUPPORTS(SVGAnimationRuleProcessor, nsIStyleRuleProcessor)
 
 /* virtual */ void
 SVGAnimationRuleProcessor::RulesMatching(ElementRuleProcessorData* aData)
 {
+  Element* element = aData->mElement;
+  if (element->IsSVG()) {
+    static_cast<nsSVGElement*>(element)->
+      WalkAnimatedContentStyleRules(aData->mRuleWalker);
+  }
 }
 
 /* virtual */ nsRestyleHint
 SVGAnimationRuleProcessor::HasStateDependentStyle(StateRuleProcessorData* aData)
 {
   return nsRestyleHint(0);
 }
 
