From: L. David Baron <dbaron@dbaron.org>

Make overflow from text frames be visual overflow only, and not scrollable.  (Bug 542595)

diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -2593,17 +2593,17 @@ nsLineLayout::RelativePositionFrames(Per
       // Compute a new combined area for the child span before
       // aggregating it into our combined area.
       RelativePositionFrames(pfd->mSpan, r);
     } else {
       r = pfd->mOverflowAreas;
       if (pfd->GetFlag(PFD_ISTEXTFRAME)) {
         if (pfd->GetFlag(PFD_RECOMPUTEOVERFLOW)) {
           nsTextFrame* f = static_cast<nsTextFrame*>(frame);
-          r = f->RecomputeOverflowRect();
+          r.VisualOverflow() = f->RecomputeVisualOverflow();
         }
         frame->FinishAndStoreOverflow(r, frame->GetSize());
       }
 
       // If we have something that's not an inline but with a complex frame
       // hierarchy inside that contains views, they need to be
       // positioned.
       // All descendant views must be repositioned even if this frame
diff --git a/layout/generic/nsTextFrame.h b/layout/generic/nsTextFrame.h
--- a/layout/generic/nsTextFrame.h
+++ b/layout/generic/nsTextFrame.h
@@ -236,33 +236,33 @@ public:
                     const nsHTMLReflowState& aReflowState,
                     nsReflowStatus& aStatus);
   virtual PRBool CanContinueTextRun() const;
   // Method that is called for a text frame that is logically
   // adjacent to the end of the line (i.e. followed only by empty text frames,
   // placeholders or inlines containing such).
   struct TrimOutput {
     // true if we trimmed some space or changed metrics in some other way.
-    // In this case, we should call RecomputeOverflowRect on this frame.
+    // In this case, we should call RecomputeVisualOverflow on this frame.
     PRPackedBool mChanged;
     // true if the last character is not justifiable so should be subtracted
     // from the count of justifiable characters in the frame, since the last
     // character in a line is not justifiable.
     PRPackedBool mLastCharIsJustifiable;
     // an amount to *subtract* from the frame's width (zero if !mChanged)
     nscoord      mDeltaWidth;
   };
   TrimOutput TrimTrailingWhiteSpace(nsIRenderingContext* aRC);
   virtual nsresult GetRenderedText(nsAString* aString = nsnull,
                                    gfxSkipChars* aSkipChars = nsnull,
                                    gfxSkipCharsIterator* aSkipIter = nsnull,
                                    PRUint32 aSkippedStartOffset = 0,
                                    PRUint32 aSkippedMaxLength = PR_UINT32_MAX);
 
-  nsRect RecomputeOverflowRect();
+  nsRect RecomputeVisualOverflow();
 
   void AddInlineMinWidthForFlow(nsIRenderingContext *aRenderingContext,
                                 nsIFrame::InlineMinWidthData *aData);
   void AddInlinePrefWidthForFlow(nsIRenderingContext *aRenderingContext,
                                  InlinePrefWidthData *aData);
 
   gfxFloat GetSnappedBaselineY(gfxContext* aContext, gfxFloat aY);
 
@@ -395,17 +395,17 @@ protected:
 
   // The caller of this method must call DestroySelectionDetails() on the
   // return value, if that return value is not null.  Calling
   // DestroySelectionDetails() on a null value is still OK, just not necessary.
   SelectionDetails* GetSelectionDetails();
   
   void UnionTextDecorationOverflow(nsPresContext* aPresContext,
                                    PropertyProvider& aProvider,
-                                   nsRect* aOverflowRect);
+                                   nsRect* aVisualOverflowRect);
 
   void DrawText(gfxContext* aCtx,
                 const gfxPoint& aTextBaselinePt,
                 PRUint32 aOffset,
                 PRUint32 aLength,
                 const gfxRect* aDirtyRect,
                 PropertyProvider* aProvider,
                 gfxFloat& aAdvanceWidth,
diff --git a/layout/generic/nsTextFrameThebes.cpp b/layout/generic/nsTextFrameThebes.cpp
--- a/layout/generic/nsTextFrameThebes.cpp
+++ b/layout/generic/nsTextFrameThebes.cpp
@@ -4099,38 +4099,39 @@ nsTextFrame::GetTextDecorations(nsPresCo
   }
 
   return decorations;
 }
 
 void
 nsTextFrame::UnionTextDecorationOverflow(nsPresContext* aPresContext,
                                          PropertyProvider& aProvider,
-                                         nsRect* aOverflowRect)
+                                         nsRect* aVisualOverflowRect)
 {
   // Text-shadow overflows
-  nsRect shadowRect = nsLayoutUtils::GetTextShadowRectsUnion(*aOverflowRect, this);
-  aOverflowRect->UnionRect(*aOverflowRect, shadowRect);
+  nsRect shadowRect =
+    nsLayoutUtils::GetTextShadowRectsUnion(*aVisualOverflowRect, this);
+  aVisualOverflowRect->UnionRect(*aVisualOverflowRect, shadowRect);
 
   if (IsFloatingFirstLetterChild()) {
     // The underline/overline drawable area must be contained in the overflow
     // rect when this is in floating first letter frame at *both* modes.
     nscoord fontAscent, fontHeight;
     nsIFontMetrics* fm = aProvider.GetFontMetrics();
     fm->GetMaxAscent(fontAscent);
     fm->GetMaxHeight(fontHeight);
     nsRect fontRect(0, mAscent - fontAscent, GetSize().width, fontHeight);
-    aOverflowRect->UnionRect(*aOverflowRect, fontRect);
+    aVisualOverflowRect->UnionRect(*aVisualOverflowRect, fontRect);
   }
 
   // When this frame is not selected, the text-decoration area must be in
   // frame bounds.
   nsRect decorationRect;
   if (!(GetStateBits() & NS_FRAME_SELECTED_CONTENT) ||
-      !CombineSelectionUnderlineRect(aPresContext, *aOverflowRect))
+      !CombineSelectionUnderlineRect(aPresContext, *aVisualOverflowRect))
     return;
   AddStateBits(TEXT_SELECTION_UNDERLINE_OVERFLOWED);
 }
 
 void 
 nsTextFrame::PaintTextDecorations(gfxContext* aCtx, const gfxRect& aDirtyRect,
                                   const gfxPoint& aFramePt,
                                   const gfxPoint& aTextBaselinePt,
@@ -6576,20 +6577,20 @@ nsTextFrame::ReflowText(nsLineLayout& aL
 
   NS_ASSERTION(aMetrics.ascent >= 0, "Negative ascent???");
   NS_ASSERTION(aMetrics.height - aMetrics.ascent >= 0, "Negative descent???");
 
   mAscent = aMetrics.ascent;
 
   // Handle text that runs outside its normal bounds.
   nsRect boundingBox = RoundOut(textMetrics.mBoundingBox) + nsPoint(0, mAscent);
-  aMetrics.mOverflowArea.UnionRect(boundingBox,
-                                   nsRect(0, 0, aMetrics.width, aMetrics.height));
-
-  UnionTextDecorationOverflow(presContext, provider, &aMetrics.mOverflowArea);
+  aMetrics.SetOverflowAreasToRect();
+  aMetrics.VisualOverflow().UnionRect(aMetrics.VisualOverflow(), boundingBox);
+
+  UnionTextDecorationOverflow(presContext, provider, &aMetrics.VisualOverflow());
 
   /////////////////////////////////////////////////////////////////////
   // Clean up, update state
   /////////////////////////////////////////////////////////////////////
 
   // If all our characters are discarded or collapsed, then trimmable width
   // from the last textframe should be preserved. Otherwise the trimmable width
   // from this textframe overrides. (Currently in CSS trimmable width can be
@@ -6808,17 +6809,17 @@ nsTextFrame::TrimTrailingWhiteSpace(nsIR
 #ifdef NOISY_TRIM
   ListTag(stdout);
   printf(": trim => %d\n", result.mDeltaWidth);
 #endif
   return result;
 }
 
 nsRect
-nsTextFrame::RecomputeOverflowRect()
+nsTextFrame::RecomputeVisualOverflow()
 {
   gfxSkipCharsIterator iter = EnsureTextRun();
   if (!mTextRun)
     return nsRect(nsPoint(0,0), GetSize());
 
   PropertyProvider provider(this, iter);
   provider.InitializeForDisplay(PR_TRUE);
 
diff --git a/layout/xul/base/src/nsTextBoxFrame.cpp b/layout/xul/base/src/nsTextBoxFrame.cpp
--- a/layout/xul/base/src/nsTextBoxFrame.cpp
+++ b/layout/xul/base/src/nsTextBoxFrame.cpp
@@ -951,21 +951,25 @@ nsTextBoxFrame::DoLayout(nsBoxLayoutStat
     }
 
     mState |= NS_STATE_NEED_LAYOUT;
 
     nsresult rv = nsLeafBoxFrame::DoLayout(aBoxLayoutState);
 
     const nsStyleText* textStyle = GetStyleText();
     if (textStyle->mTextShadow) {
+      nsRect bounds(nsPoint(0, 0), GetSize());
+      nsOverflowAreas overflow(bounds, bounds);
+      // Our scrollable overflow is our bounds; our visual overflow may
+      // extend beyond that.
       nsPoint origin(0,0);
       nsRect textRect = CalcTextRect(*aBoxLayoutState.GetRenderingContext(), origin);
-      nsRect overflowRect(nsLayoutUtils::GetTextShadowRectsUnion(textRect, this));
-      overflowRect.UnionRect(overflowRect, nsRect(nsPoint(0, 0), GetSize()));
-      FinishAndStoreOverflow(&overflowRect, GetSize());
+      nsRect &vis = overflow.VisualOverflow();
+      vis.UnionRect(vis, nsLayoutUtils::GetTextShadowRectsUnion(textRect, this));
+      FinishAndStoreOverflow(overflow, GetSize());
     }
     return rv;
 }
 
 PRBool
 nsTextBoxFrame::ComputesOwnOverflowArea()
 {
     return PR_TRUE;
