Make the code to suppress infinite synthesized mouse move loops work again with asynchronous style changes.  (Bug 302561)

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -1848,16 +1848,17 @@ nsCSSFrameConstructor::nsCSSFrameConstru
   , mGfxScrollFrame(nsnull)
   , mPageSequenceFrame(nsnull)
   , mUpdateCount(0)
   , mQuotesDirty(PR_FALSE)
   , mCountersDirty(PR_FALSE)
   , mIsDestroyingFrameTree(PR_FALSE)
   , mRebuildAllStyleData(PR_FALSE)
   , mHasRootAbsPosContainingBlock(PR_FALSE)
+  , mHoverGeneration(0)
 {
   if (!gGotXBLFormPrefs) {
     gGotXBLFormPrefs = PR_TRUE;
 
     gUseXBLForms =
       nsContentUtils::GetBoolPref("nglayout.debug.enable_xbl_forms");
   }
 
@@ -9995,16 +9996,20 @@ nsCSSFrameConstructor::DoContentStateCha
           }
         }
       }
     }
 
     nsReStyleHint rshint = 
       styleSet->HasStateDependentStyle(presContext, aContent, aStateMask);
       
+    if ((aStateMask & NS_EVENT_STATE_HOVER) && rshint != 0) {
+      ++mHoverGeneration;
+    }
+
     PostRestyleEvent(aContent, rshint, hint);
   }
 }
 
 nsresult
 nsCSSFrameConstructor::AttributeChanged(nsIContent* aContent,
                                         PRInt32 aNameSpaceID,
                                         nsIAtom* aAttribute,
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -150,16 +150,20 @@ public:
                             PRInt32     aModType,
                             PRUint32    aStateMask);
 
   void BeginUpdate();
   void EndUpdate();
   void RecalcQuotesAndCounters();
 
   void WillDestroyFrameTree();
+
+  // Get an integer that increments every time there is a style change
+  // as a result of a change to the :hover content state.
+  PRUint32 GetHoverGeneration() const { return mHoverGeneration; }
 
   // Note: It's the caller's responsibility to make sure to wrap a
   // ProcessRestyledFrames call in a view update batch.
   // This function does not call ProcessAttachedQueue() on the binding manager.
   // If the caller wants that to happen synchronously, it needs to handle that
   // itself.
   nsresult ProcessRestyledFrames(nsStyleChangeList& aRestyleArray);
 
@@ -1184,16 +1188,17 @@ private:
   nsCounterManager    mCounterManager;
   PRUint16            mUpdateCount;
   PRPackedBool        mQuotesDirty : 1;
   PRPackedBool        mCountersDirty : 1;
   PRPackedBool        mIsDestroyingFrameTree : 1;
   PRPackedBool        mRebuildAllStyleData : 1;
   // This is true if mDocElementContainingBlock supports absolute positioning
   PRPackedBool        mHasRootAbsPosContainingBlock : 1;
+  PRUint32            mHoverGeneration;
 
   nsRevocableEventPtr<RestyleEvent> mRestyleEvent;
 
   nsCOMPtr<nsILayoutHistoryState> mTempFrameTreeState;
 
   nsDataHashtable<nsISupportsHashKey, RestyleData> mPendingRestyles;
 
   static nsIXBLService * gXBLService;
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -909,16 +909,18 @@ public:
                          nsEventStatus*  aEventStatus);
   NS_IMETHOD HandleDOMEventWithTarget(nsIContent* aTargetContent,
                                       nsEvent* aEvent,
                                       nsEventStatus* aStatus);
   NS_IMETHOD ResizeReflow(nsIView *aView, nscoord aWidth, nscoord aHeight);
   NS_IMETHOD_(PRBool) IsVisible();
   NS_IMETHOD_(void) WillPaint();
   NS_IMETHOD_(void) InvalidateFrameForView(nsIView *view);
+  NS_IMETHOD_(void) DispatchSynthMouseMove(nsGUIEvent *aEvent,
+                                           PRBool aFlushOnHoverChange);
 
   // caret handling
   NS_IMETHOD GetCaret(nsCaret **aOutCaret);
   NS_IMETHOD_(void) MaybeInvalidateCaretPosition();
   NS_IMETHOD SetCaretEnabled(PRBool aInEnable);
   NS_IMETHOD SetCaretReadOnly(PRBool aReadOnly);
   NS_IMETHOD GetCaretEnabled(PRBool *aOutEnabled);
   NS_IMETHOD SetCaretVisibilityDuringSelection(PRBool aVisibility);
@@ -4168,16 +4170,29 @@ PresShell::GetSelectionForCopy(nsISelect
 
 /* Just hook this call into InvalidateOverflowRect */
 void
 PresShell::InvalidateFrameForView(nsIView *aView)
 {
   nsIFrame* frame = nsLayoutUtils::GetFrameFor(aView);
   if (frame)
     frame->InvalidateOverflowRect();
+}
+
+NS_IMETHODIMP_(void)
+PresShell::DispatchSynthMouseMove(nsGUIEvent *aEvent,
+                                  PRBool aFlushOnHoverChange)
+{
+  PRUint32 hoverGenerationBefore = mFrameConstructor->GetHoverGeneration();
+  nsEventStatus status;
+  mViewManager->DispatchEvent(aEvent, &status);
+  if (aFlushOnHoverChange &&
+      hoverGenerationBefore != mFrameConstructor->GetHoverGeneration()) {
+    FlushPendingNotifications(Flush_Layout);
+  }
 }
 
 NS_IMETHODIMP
 PresShell::DoGetContents(const nsACString& aMimeType, PRUint32 aFlags, PRBool aSelectionOnly, nsAString& aOutValue)
 {
   aOutValue.Truncate();
   
   if (!mDocument) return NS_ERROR_FAILURE;
diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -99,16 +99,17 @@ _TEST_FILES =	test_acid3_test46.html \
 		test_bug450191.html \
 		test_bug453896_deck.html \
 		test_cascade.html \
 		test_compute_data_with_start_struct.html \
 		test_css_eof_handling.html \
 		test_dont_use_document_colors.html \
 		test_font_face_parser.html \
 		test_for_expect_end_property.html \
+		test_hover.html \
 		test_inherit_computation.html \
 		test_inherit_storage.html \
 		test_initial_computation.html \
 		test_initial_storage.html \
 		test_media_queries.html \
 		test_media_queries_dynamic_xbl.html \
 		test_namespace_rule.html \
 		test_of_type_selectors.xhtml \
diff --git a/layout/style/test/test_hover.html b/layout/style/test/test_hover.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_hover.html
@@ -0,0 +1,168 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Test for :hover</title>
+  <script type="application/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/EventUtils.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+  <style type="text/css">
+
+  div#one { height: 10px; width: 10px; }
+  div#one:hover { background: #00f; }
+  div#one > div { height: 5px; width: 20px; }
+  div#one > div:hover { background: #f00; }
+
+  div#twoparent { overflow: hidden; height: 20px; }
+  div#two { width: 10px; height: 10px; }
+  div#two:hover { margin-left: 5px; background: #0f0; }
+  div#two + iframe { width: 50px; height: 10px; }
+  div#two:hover + iframe { width: 100px; }
+
+  </style>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=">Mozilla Bug </a>
+<div id="display" style="position: absolute; top: 0; left: 0; width: 300px; height: 300px">
+
+  <div id="one"><div></div></div>
+
+  <div id="twoparent">
+    <div id="two"></div>
+    <iframe id="twoi" src="about:blank"></iframe>
+    <div style="height: 100px"></div>
+  </div>
+
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+SimpleTest.waitForExplicitFinish();
+var div = document.getElementById("display");
+
+/** test basic hover **/
+var divone = document.getElementById("one");
+synthesizeMouse(divone, 5, 7, { type: "mousemove" }, window);
+is(getComputedStyle(divone, "").backgroundColor, "rgb(0, 0, 255)",
+   ":hover applies");
+is(getComputedStyle(divone.firstChild, "").backgroundColor, "transparent",
+   ":hover does not apply");
+synthesizeMouse(divone, 5, 2, { type: "mousemove" }, window);
+is(getComputedStyle(divone, "").backgroundColor, "rgb(0, 0, 255)",
+   ":hover applies hierarchically");
+is(getComputedStyle(divone.firstChild, "").backgroundColor, "rgb(255, 0, 0)",
+   ":hover applies");
+synthesizeMouse(divone, 15, 7, { type: "mousemove" }, window);
+is(getComputedStyle(divone, "").backgroundColor, "transparent",
+   ":hover does not apply");
+is(getComputedStyle(divone.firstChild, "").backgroundColor, "transparent",
+   ":hover does not apply");
+synthesizeMouse(divone, 15, 2, { type: "mousemove" }, window);
+is(getComputedStyle(divone, "").backgroundColor, "rgb(0, 0, 255)",
+   ":hover applies hierarchically");
+is(getComputedStyle(divone.firstChild, "").backgroundColor, "rgb(255, 0, 0)",
+   ":hover applies");
+
+/** Test for Bug 302561 **/
+var divtwo = document.getElementById("two");
+var iframe = document.getElementById("twoi");
+var divtwoparent = document.getElementById("twoparent");
+
+iframe.contentDocument.open();
+iframe.contentDocument.write("<body>");
+iframe.contentDocument.close();
+
+iframe.contentDocument.body.setAttribute("onresize", "parent.step2()");
+synthesizeMouse(divtwo, 7, 5, { type: "mousemove" }, window);
+
+var step2called = false;
+function step2() {
+    is(step2called, false, "step2 called only once");
+    step2called = true;
+    is(getComputedStyle(divtwo, "").backgroundColor, "rgb(0, 255, 0)",
+       ":hover applies");
+    iframe.contentDocument.body.setAttribute("onresize", "parent.step3()");
+    synthesizeMouse(divtwo, 2, 5, { type: "mousemove" }, window);
+}
+
+var step3called = false;
+function step3() {
+    is(step3called, false, "step3 called only once");
+    step3called = true;
+    is(getComputedStyle(divtwo, "").backgroundColor, transparent,
+       ":hover does not apply");
+    iframe.contentDocument.body.setAttribute("onresize", "parent.step4()");
+    /* expect to get a second resize from the oscillation */
+}
+
+var step4called = false;
+function step4() {
+    is(step4called, false, "step4 called only once (more than two cycles of oscillation)");
+    if (step4called)
+        return;
+    step4called = true;
+    is(getComputedStyle(divtwo, "").backgroundColor, "rgb(0, 255, 0)",
+       ":hover applies");
+    setTimeout(step5, 100);
+}
+
+function step5() {
+    is(step5called, false, "step5 called only once");
+    step5called = true;
+    iframe.contentDocument.body.setAttribute("onresize", "parent.step6()");
+    synthesizeMouse(divtwo, 25, 5, { type: "mousemove" }, window);
+}
+
+var step6called = false;
+function step6() {
+    is(step6called, false, "step5 called only once");
+    step6called = true;
+    is(getComputedStyle(divtwo, "").backgroundColor, transparent,
+       ":hover does not apply");
+    iframe.contentDocument.body.setAttribute("onresize", "parent.step7()");
+    synthesizeMouse(divtwo, 2, 5, { type: "mousemove" }, window);
+}
+
+var step7called = false;
+function step7() {
+    is(step7called, false, "step7 called only once");
+    step7called = true;
+    is(getComputedStyle(divtwo, "").backgroundColor, "rgb(0, 255, 0)",
+       ":hover applies");
+    iframe.contentDocument.body.setAttribute("onresize", "parent.step8()");
+    /* expect to get a second resize from the oscillation */
+}
+
+var step8called = false;
+function step8() {
+    is(step8called, false, "step8 called only once (more than two cycles of oscillation)");
+    if (step8called)
+        return;
+    step8called = true;
+    is(getComputedStyle(divtwo, "").backgroundColor, transparent,
+       ":hover does not apply");
+    setTimeout(step9, 100);
+}
+
+/* test the same case with scrolltop */
+
+function step9() {
+    is(step9called, false, "step9 called only once");
+    step9called = true;
+    iframe.contentDocument.body.removeAttribute("onresize");
+    synthesizeMouse(divtwoparent, 7, 5, { type: "mousemove" }, window);
+}
+
+
+
+
+
+
+function stepN() {
+    SimpleTest.finish();
+}
+
+</script>
+</pre>
+</body>
+</html>
diff --git a/view/public/nsIViewObserver.h b/view/public/nsIViewObserver.h
--- a/view/public/nsIViewObserver.h
+++ b/view/public/nsIViewObserver.h
@@ -41,19 +41,20 @@
 #include "nsISupports.h"
 #include "nsEvent.h"
 #include "nsColor.h"
 #include "nsRect.h"
 
 class nsIRenderingContext;
 class nsGUIEvent;
 
+// cb03e6e3-9d14-4018-85f8-7d46af878c98
 #define NS_IVIEWOBSERVER_IID   \
-{ 0x63ae23ee, 0xe251, 0x4005, \
-{ 0xaf, 0xe4, 0x5b, 0x0f, 0xa1, 0x5a, 0xb4, 0x99 } }
+{ 0xcb03e6e3, 0x9d14, 0x4018, \
+  { 0x85, 0xf8, 0x7d, 0x46, 0xaf, 0x87, 0x8c, 0x98 } }
 
 class nsIViewObserver : public nsISupports
 {
 public:
   
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IVIEWOBSERVER_IID)
 
   /* called when the observer needs to paint. This paints the entire
@@ -115,13 +116,21 @@ public:
    */
   NS_IMETHOD_(void) WillPaint() = 0;
 
   /**
    * Notify the observer that it should invalidate the frame bounds for
    * the frame associated with this view.
    */
   NS_IMETHOD_(void) InvalidateFrameForView(nsIView *aView) = 0;
+
+  /**
+   * Dispatch the given synthesized mouse move event, and if
+   * aFlushOnHoverChange is true, flush layout if :hover changes cause
+   * any restyles.
+   */
+  NS_IMETHOD_(void) DispatchSynthMouseMove(nsGUIEvent *aEvent,
+                                           PRBool aFlushOnHoverChange) = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIViewObserver, NS_IVIEWOBSERVER_IID)
 
 #endif
diff --git a/view/src/nsViewManager.cpp b/view/src/nsViewManager.cpp
--- a/view/src/nsViewManager.cpp
+++ b/view/src/nsViewManager.cpp
@@ -2405,18 +2405,18 @@ nsViewManager::ProcessSynthMouseMoveEven
     offset.y = NSAppUnitsToIntPixels(offset.y, p2a);
   }
   nsMouseEvent event(PR_TRUE, NS_MOUSE_MOVE, view->GetWidget(),
                      nsMouseEvent::eSynthesized);
   event.refPoint = mMouseLocation - offset;
   event.time = PR_IntervalNow();
   // XXX set event.isShift, event.isControl, event.isAlt, event.isMeta ?
 
-  nsEventStatus status;
-  view->GetViewManager()->DispatchEvent(&event, &status);
+  view->GetViewManager()->GetViewObserver()
+    ->DispatchSynthMouseMove(&event, !aFromScroll);
 
   if (!aFromScroll)
     mSynthMouseMoveEvent.Forget();
 }
 
 void
 nsViewManager::InvalidateHierarchy()
 {
