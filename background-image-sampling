Stop trying to maintain generally-unmaintainable invariants about contents (in this case, background images) not shifting in response to subpixel position changes that don't move the edges so that we can maintain stronger invariants about what pixels of the image we sample.  (Bug 446100)

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -1569,20 +1569,16 @@ nsCSSRendering::PaintBackgroundWithSC(ns
       nsMargin padding = aForFrame->GetUsedPadding();
       aForFrame->ApplySkipSides(padding);
       bgOriginArea.Deflate(padding);
       NS_ASSERTION(aColor.mBackgroundOrigin == NS_STYLE_BG_ORIGIN_CONTENT,
                    "unknown background-origin value");
     }
   }
 
-  // Snap bgOriginArea to device pixel boundaries to avoid variations in
-  // tiling when the subpixel position of the element changes.
-  PixelSnapRectangle(ctx, dc, bgOriginArea);
-
   // Based on the repeat setting, compute how many tiles we should
   // lay down for each axis. The value computed is the maximum based
   // on the dirty rect before accounting for the background-position.
   nscoord tileWidth = imageSize.width;
   nscoord tileHeight = imageSize.height;
   PRBool  needBackgroundColor = NS_GET_A(aColor.mBackgroundColor) > 0;
   PRIntn  repeat = aColor.mBackgroundRepeat;
 
@@ -1624,19 +1620,16 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     PaintBackgroundColor(aPresContext, aRenderingContext, aForFrame, bgClipArea,
                          aColor, aBorder, canDrawBackgroundColor);
   }
 
   if ((tileWidth == 0) || (tileHeight == 0) || dirtyRect.IsEmpty()) {
     // Nothing left to paint
     return;
   }
-
-  nsPoint borderAreaOriginSnapped = aBorderArea.TopLeft();
-  PixelSnapPoint(ctx, dc, borderAreaOriginSnapped);
 
   // Compute the anchor point.
   //
   // When tiling, the anchor coordinate values will be negative offsets
   // from the background-origin area.
 
   // relative to the origin of aForFrame
   nsPoint anchor;
@@ -1706,18 +1699,18 @@ nsCSSRendering::PaintBackgroundWithSC(ns
       }
     } else {
       // Otherwise, it is the normal case, and the background is
       // simply placed relative to the frame's background-clip area
       ComputeBackgroundAnchorPoint(aColor, bgOriginArea, bgClipArea, tileWidth, tileHeight, anchor);
     }
 
     // For scrolling attachment, the anchor is within the 'background-clip'
-    anchor.x += bgClipArea.x - borderAreaOriginSnapped.x;
-    anchor.y += bgClipArea.y - borderAreaOriginSnapped.y;
+    anchor.x += bgClipArea.x - aBorderArea.x;
+    anchor.y += bgClipArea.y - aBorderArea.y;
   }
 
   // Pixel-snap the anchor point so that we don't end up with blurry
   // images due to subpixel positions.  But round 0.5 down rather than
   // up, since that's what we've always done.  (And do that by just
   // snapping the negative of the point.)
   anchor.x = -anchor.x; anchor.y = -anchor.y;
   PixelSnapPoint(ctx, dc, anchor);
@@ -1843,16 +1836,19 @@ nsCSSRendering::PaintBackgroundWithSC(ns
           x1 = x0 + ((dirtyRect.x + dirtyRect.width - x0 + tileWidth - 1) /
                      tileWidth) * tileWidth
 
        The vertical case is analogous. If the background is fixed, then 
        bgClipArea.x and bgClipArea.y are set to zero when finding the parent
        viewport, above.
 
   */
+
+  nsPoint borderAreaOriginSnapped = aBorderArea.TopLeft();
+  PixelSnapPoint(ctx, dc, borderAreaOriginSnapped);
 
   // relative to aBorderArea.TopLeft()
   // ... but pixel-snapped, so that it comes out correctly relative to
   // all the other pixel-snapped things
   nsRect tileRect(anchor, nsSize(tileWidth, tileHeight));
   // Whether we take the single-image path or the tile path should not
   // depend on the dirty rect. So decide now which path to take. We
   // can take the single image path if the anchored image tile
