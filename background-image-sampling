Stop trying to maintain generally-unmaintainable invariants about contents (in this case, background images) not shifting in response to subpixel position changes that don't move the edges so that we can maintain stronger invariants about what pixels of the image we sample.  (Bug 446100)

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -1478,24 +1478,16 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     if (aColor.mBackgroundClip != NS_STYLE_BG_CLIP_BORDER ||
         IsSolidBorder(aBorder)) {
       nsMargin border = aForFrame->GetUsedBorder();
       aForFrame->ApplySkipSides(border);
       bgClipArea.Deflate(border);
     }
   }
 
-  nsIDeviceContext *dc = aPresContext->DeviceContext();
-  gfxContext *ctx = aRenderingContext.ThebesContext();
-
-  // Snap bgClipArea to device pixel boundaries.  (We have to snap
-  // bgOriginArea below; if we don't do this as well then we could make
-  // incorrect decisions about various optimizations.)
-  PixelSnapRectangle(ctx, dc, bgClipArea);
-
   // The actual dirty rect is the intersection of the 'background-clip'
   // area and the dirty rect we were given
   nsRect dirtyRect;
   if (!dirtyRect.IntersectRect(bgClipArea, aDirtyRect)) {
     // Nothing to paint
     return;
   }
 
@@ -1569,20 +1561,16 @@ nsCSSRendering::PaintBackgroundWithSC(ns
       nsMargin padding = aForFrame->GetUsedPadding();
       aForFrame->ApplySkipSides(padding);
       bgOriginArea.Deflate(padding);
       NS_ASSERTION(aColor.mBackgroundOrigin == NS_STYLE_BG_ORIGIN_CONTENT,
                    "unknown background-origin value");
     }
   }
 
-  // Snap bgOriginArea to device pixel boundaries to avoid variations in
-  // tiling when the subpixel position of the element changes.
-  PixelSnapRectangle(ctx, dc, bgOriginArea);
-
   // Based on the repeat setting, compute how many tiles we should
   // lay down for each axis. The value computed is the maximum based
   // on the dirty rect before accounting for the background-position.
   nscoord tileWidth = imageSize.width;
   nscoord tileHeight = imageSize.height;
   PRBool  needBackgroundColor = NS_GET_A(aColor.mBackgroundColor) > 0;
   PRIntn  repeat = aColor.mBackgroundRepeat;
 
@@ -1624,19 +1612,16 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     PaintBackgroundColor(aPresContext, aRenderingContext, aForFrame, bgClipArea,
                          aColor, aBorder, canDrawBackgroundColor);
   }
 
   if ((tileWidth == 0) || (tileHeight == 0) || dirtyRect.IsEmpty()) {
     // Nothing left to paint
     return;
   }
-
-  nsPoint borderAreaOriginSnapped = aBorderArea.TopLeft();
-  PixelSnapPoint(ctx, dc, borderAreaOriginSnapped);
 
   // Compute the anchor point.
   //
   // When tiling, the anchor coordinate values will be negative offsets
   // from the background-origin area.
 
   // relative to the origin of aForFrame
   nsPoint anchor;
@@ -1706,19 +1691,39 @@ nsCSSRendering::PaintBackgroundWithSC(ns
       }
     } else {
       // Otherwise, it is the normal case, and the background is
       // simply placed relative to the frame's background-clip area
       ComputeBackgroundAnchorPoint(aColor, bgOriginArea, bgClipArea, tileWidth, tileHeight, anchor);
     }
 
     // For scrolling attachment, the anchor is within the 'background-clip'
-    anchor.x += bgClipArea.x - borderAreaOriginSnapped.x;
-    anchor.y += bgClipArea.y - borderAreaOriginSnapped.y;
+    anchor.x += bgClipArea.x - aBorderArea.x;
+    anchor.y += bgClipArea.y - aBorderArea.y;
   }
+
+  nsIDeviceContext *dc = aPresContext->DeviceContext();
+  gfxContext *ctx = aRenderingContext.ThebesContext();
+
+  // Snap bgClipArea to device pixel boundaries.
+  //
+  // For now, we're better off doing this now than before the calls to
+  // ComputeBackgroundAnchorPoint because ComputeBackgroundAnchorPoint
+  // has code to snap the repeat case back to the position of the first
+  // tile, and if we rounded first, we'd risk snapping one tile too far
+  // to the top/left, and then rounding the tiny edge of that tile off
+  // when we rounded the anchor.  (All we'd lose by doing that, though,
+  // is the useSingleImagePath optimization, since we do that
+  // computation all over again, below, when we call FindTileStart and
+  // FindTileEnd.)
+  // FIXME: We should really refactor that code out of
+  // ComputeBackgroundAnchorPoint and do it
+  // after the pixel-snapping (and thus make
+  // ComputeBackgroundAnchorPoint not depend on bgClipArea at all).
+  PixelSnapRectangle(ctx, dc, bgClipArea);
 
   // Pixel-snap the anchor point so that we don't end up with blurry
   // images due to subpixel positions.  But round 0.5 down rather than
   // up, since that's what we've always done.  (And do that by just
   // snapping the negative of the point.)
   anchor.x = -anchor.x; anchor.y = -anchor.y;
   PixelSnapPoint(ctx, dc, anchor);
   anchor.x = -anchor.x; anchor.y = -anchor.y;
@@ -1843,16 +1848,19 @@ nsCSSRendering::PaintBackgroundWithSC(ns
           x1 = x0 + ((dirtyRect.x + dirtyRect.width - x0 + tileWidth - 1) /
                      tileWidth) * tileWidth
 
        The vertical case is analogous. If the background is fixed, then 
        bgClipArea.x and bgClipArea.y are set to zero when finding the parent
        viewport, above.
 
   */
+
+  nsPoint borderAreaOriginSnapped = aBorderArea.TopLeft();
+  PixelSnapPoint(ctx, dc, borderAreaOriginSnapped);
 
   // relative to aBorderArea.TopLeft()
   // ... but pixel-snapped, so that it comes out correctly relative to
   // all the other pixel-snapped things
   nsRect tileRect(anchor, nsSize(tileWidth, tileHeight));
   // Whether we take the single-image path or the tile path should not
   // depend on the dirty rect. So decide now which path to take. We
   // can take the single image path if the anchored image tile
