Stop trying to maintain generally-unmaintainable invariants about contents (in this case, background images) not shifting in response to subpixel position changes that don't move the edges so that we can maintain stronger invariants about what pixels of the image we sample.  (Bug 446100)

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -876,78 +876,32 @@ ComputeBackgroundAnchorPoint(const nsSty
     nscoord tilePos = nscoord(percent * PRFloat64(aTileWidth));
     nscoord boxPos = nscoord(percent * PRFloat64(aOriginBounds.width));
     x = boxPos - tilePos;
   }
   else {
     x = 0;
   }
   x += aOriginBounds.x - aClipBounds.x;
-  if (NS_STYLE_BG_REPEAT_X & aColor.mBackgroundRepeat) {
-    // When we are tiling in the x direction the loop will run from
-    // the left edge of the box to the right edge of the box. We need
-    // to adjust the starting coordinate to lie within the band being
-    // rendered.
-    if (x < 0) {
-      x = -x;
-      if (x < 0) {
-        // Some joker gave us max-negative-integer.
-        x = 0;
-      }
-      x %= aTileWidth;
-      x = -x;
-    }
-    else if (x != 0) {
-      x %= aTileWidth;
-      if (x > 0) {
-        x = x - aTileWidth;
-      }
-    }
-
-    NS_POSTCONDITION((x >= -(aTileWidth - 1)) && (x <= 0), "bad computed anchor value");
-  }
   aResult.x = x;
 
   nscoord y;
   if (NS_STYLE_BG_Y_POSITION_LENGTH & aColor.mBackgroundFlags) {
     y = aColor.mBackgroundYPosition.mCoord;
   }
   else if (NS_STYLE_BG_Y_POSITION_PERCENT & aColor.mBackgroundFlags){
     PRFloat64 percent = PRFloat64(aColor.mBackgroundYPosition.mFloat);
     nscoord tilePos = nscoord(percent * PRFloat64(aTileHeight));
     nscoord boxPos = nscoord(percent * PRFloat64(aOriginBounds.height));
     y = boxPos - tilePos;
   }
   else {
     y = 0;
   }
   y += aOriginBounds.y - aClipBounds.y;
-  if (NS_STYLE_BG_REPEAT_Y & aColor.mBackgroundRepeat) {
-    // When we are tiling in the y direction the loop will run from
-    // the top edge of the box to the bottom edge of the box. We need
-    // to adjust the starting coordinate to lie within the band being
-    // rendered.
-    if (y < 0) {
-      y = -y;
-      if (y < 0) {
-        // Some joker gave us max-negative-integer.
-        y = 0;
-      }
-      y %= aTileHeight;
-      y = -y;
-    }
-    else if (y != 0) {
-      y %= aTileHeight;
-      if (y > 0) {
-        y = y - aTileHeight;
-      }
-    }
-    
-    NS_POSTCONDITION((y >= -(aTileHeight - 1)) && (y <= 0), "bad computed anchor value");
-  }
   aResult.y = y;
 }
 
 const nsStyleBackground*
 nsCSSRendering::FindNonTransparentBackground(nsStyleContext* aContext,
                                              PRBool aStartAtParent /*= PR_FALSE*/)
 {
   NS_ASSERTION(aContext, "Cannot find NonTransparentBackground in a null context" );
@@ -1481,19 +1435,17 @@ nsCSSRendering::PaintBackgroundWithSC(ns
       aForFrame->ApplySkipSides(border);
       bgClipArea.Deflate(border);
     }
   }
 
   nsIDeviceContext *dc = aPresContext->DeviceContext();
   gfxContext *ctx = aRenderingContext.ThebesContext();
 
-  // Snap bgClipArea to device pixel boundaries.  (We have to snap
-  // bgOriginArea below; if we don't do this as well then we could make
-  // incorrect decisions about various optimizations.)
+  // Snap bgClipArea to device pixel boundaries.
   PixelSnapRectangle(ctx, dc, bgClipArea);
 
   // The actual dirty rect is the intersection of the 'background-clip'
   // area and the dirty rect we were given
   nsRect dirtyRect;
   if (!dirtyRect.IntersectRect(bgClipArea, aDirtyRect)) {
     // Nothing to paint
     return;
@@ -1569,20 +1521,16 @@ nsCSSRendering::PaintBackgroundWithSC(ns
       nsMargin padding = aForFrame->GetUsedPadding();
       aForFrame->ApplySkipSides(padding);
       bgOriginArea.Deflate(padding);
       NS_ASSERTION(aColor.mBackgroundOrigin == NS_STYLE_BG_ORIGIN_CONTENT,
                    "unknown background-origin value");
     }
   }
 
-  // Snap bgOriginArea to device pixel boundaries to avoid variations in
-  // tiling when the subpixel position of the element changes.
-  PixelSnapRectangle(ctx, dc, bgOriginArea);
-
   // Based on the repeat setting, compute how many tiles we should
   // lay down for each axis. The value computed is the maximum based
   // on the dirty rect before accounting for the background-position.
   nscoord tileWidth = imageSize.width;
   nscoord tileHeight = imageSize.height;
   PRBool  needBackgroundColor = NS_GET_A(aColor.mBackgroundColor) > 0;
   PRIntn  repeat = aColor.mBackgroundRepeat;
 
@@ -1624,19 +1572,16 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     PaintBackgroundColor(aPresContext, aRenderingContext, aForFrame, bgClipArea,
                          aColor, aBorder, canDrawBackgroundColor);
   }
 
   if ((tileWidth == 0) || (tileHeight == 0) || dirtyRect.IsEmpty()) {
     // Nothing left to paint
     return;
   }
-
-  nsPoint borderAreaOriginSnapped = aBorderArea.TopLeft();
-  PixelSnapPoint(ctx, dc, borderAreaOriginSnapped);
 
   // Compute the anchor point.
   //
   // When tiling, the anchor coordinate values will be negative offsets
   // from the background-origin area.
 
   // relative to the origin of aForFrame
   nsPoint anchor;
@@ -1706,27 +1651,26 @@ nsCSSRendering::PaintBackgroundWithSC(ns
       }
     } else {
       // Otherwise, it is the normal case, and the background is
       // simply placed relative to the frame's background-clip area
       ComputeBackgroundAnchorPoint(aColor, bgOriginArea, bgClipArea, tileWidth, tileHeight, anchor);
     }
 
     // For scrolling attachment, the anchor is within the 'background-clip'
-    anchor.x += bgClipArea.x - borderAreaOriginSnapped.x;
-    anchor.y += bgClipArea.y - borderAreaOriginSnapped.y;
+    anchor.x += bgClipArea.x - aBorderArea.x;
+    anchor.y += bgClipArea.y - aBorderArea.y;
   }
 
   // Pixel-snap the anchor point so that we don't end up with blurry
-  // images due to subpixel positions.  But round 0.5 down rather than
-  // up, since that's what we've always done.  (And do that by just
-  // snapping the negative of the point.)
-  anchor.x = -anchor.x; anchor.y = -anchor.y;
+  // images due to subpixel positions.  But snap the absolute position,
+  // not the frame-relative one!
+  anchor += aBorderArea.TopLeft();
   PixelSnapPoint(ctx, dc, anchor);
-  anchor.x = -anchor.x; anchor.y = -anchor.y;
+  anchor -= aBorderArea.TopLeft();
 
   ctx->Save();
 
   nscoord appUnitsPerPixel = aPresContext->DevPixelsToAppUnits(1);
 
   ctx->NewPath();
   ctx->Rectangle(RectToGfxRect(dirtyRect, appUnitsPerPixel), PR_TRUE);
   ctx->Clip();
@@ -1843,16 +1787,29 @@ nsCSSRendering::PaintBackgroundWithSC(ns
           x1 = x0 + ((dirtyRect.x + dirtyRect.width - x0 + tileWidth - 1) /
                      tileWidth) * tileWidth
 
        The vertical case is analogous. If the background is fixed, then 
        bgClipArea.x and bgClipArea.y are set to zero when finding the parent
        viewport, above.
 
   */
+
+  nsPoint borderAreaOriginSnapped = aBorderArea.TopLeft();
+  PixelSnapPoint(ctx, dc, borderAreaOriginSnapped);
+
+  // Adjust the anchor so that we have the top-left-most tile.
+  if (repeat & NS_STYLE_BG_REPEAT_X) {
+    anchor.x = FindTileStart(bgClipArea.x - borderAreaOriginSnapped.x,
+                             anchor.x, tileWidth);
+  }
+  if (repeat & NS_STYLE_BG_REPEAT_Y) {
+    anchor.y = FindTileStart(bgClipArea.y - borderAreaOriginSnapped.y,
+                             anchor.y, tileHeight);
+  }
 
   // relative to aBorderArea.TopLeft()
   // ... but pixel-snapped, so that it comes out correctly relative to
   // all the other pixel-snapped things
   nsRect tileRect(anchor, nsSize(tileWidth, tileHeight));
   // Whether we take the single-image path or the tile path should not
   // depend on the dirty rect. So decide now which path to take. We
   // can take the single image path if the anchored image tile
