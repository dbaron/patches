From: L. David Baron <dbaron@dbaron.org>

Serialize border-image shorthand to shortest form, with the exception that we'll always serialize 'border-image-source'.  (Bug 713643, patch 1)

diff --git a/layout/style/Declaration.cpp b/layout/style/Declaration.cpp
--- a/layout/style/Declaration.cpp
+++ b/layout/style/Declaration.cpp
@@ -137,16 +137,51 @@ Declaration::AppendValueToString(nsCSSPr
   if (!val) {
     return false;
   }
 
   val->AppendToString(aProperty, aResult);
   return true;
 }
 
+bool
+Declaration::HasDefaultBorderImageSlice() const
+{
+  const nsCSSValueList *slice =
+    data->ValueFor(eCSSProperty_border_image_slice)->GetListValue();
+  return !slice->mNext &&
+         slice->mValue->GetRectValue()->DoAllSidesEqual(
+           nsCSSValue(1.0f, eCSSUnit_Percent));
+}
+
+bool
+Declaration::HasDefaultBorderImageWidth() const
+{
+  const nsCSSRect *width =
+    data->ValueFor(eCSSProperty_border_image_width)->GetRectValue();
+  return width->DoAllSidesEqual(nsCSSValue(1.0f, eCSSUnit_Number));
+}
+
+bool
+Declaration::HasDefaultBorderImageOutset() const
+{
+  const nsCSSRect *outset =
+    data->ValueFor(eCSSProperty_border_image_outset)->GetRectValue();
+  return outset->DoAllSidesEqual(nsCSSValue(0.0f, eCSSUnit_Number));
+}
+
+bool
+Declaration::HasDefaultBorderImageRepeat() const
+{
+  const nsCSSValuePair *repeat =
+    data->ValueFor(eCSSProperty_border_image_repeat)->GetPairValue();
+  return repeat->DoBothValuesEqual(
+    nsCSSValue(NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH, eCSSUnit_Enumerated));
+}
+
 void
 Declaration::GetValue(nsCSSProperty aProperty, nsAString& aValue) const
 {
   aValue.Truncate(0);
 
   // simple properties are easy.
   if (!nsCSSProps::IsShorthand(aProperty)) {
     AppendValueToString(aProperty, aValue);
@@ -296,25 +331,47 @@ Declaration::GetValue(nsCSSProperty aPro
           }
           if (i < 3)
             aValue.Append(PRUnichar(' '));
         }
       }
       break;
     }
     case eCSSProperty_border_image:
+      // Even though there are some cases where we could omit
+      // 'border-image-source' (when it's none), it's probably not a
+      // good idea since it's likely to be confusing.  It would also
+      // require adding the extra check that we serialize *something*.
       AppendValueToString(eCSSProperty_border_image_source, aValue);
-      aValue.Append(PRUnichar(' '));
-      AppendValueToString(eCSSProperty_border_image_slice, aValue);
-      aValue.Append(NS_LITERAL_STRING(" / "));
-      AppendValueToString(eCSSProperty_border_image_width, aValue);
-      aValue.Append(NS_LITERAL_STRING(" / "));
-      AppendValueToString(eCSSProperty_border_image_outset, aValue);
-      aValue.Append(PRUnichar(' '));
-      AppendValueToString(eCSSProperty_border_image_repeat, aValue);
+
+      bool sliceDefault = HasDefaultBorderImageSlice();
+      bool widthDefault = HasDefaultBorderImageWidth();
+      bool outsetDefault = HasDefaultBorderImageOutset();
+
+      if (!sliceDefault || !widthDefault || !outsetDefault) {
+        aValue.Append(PRUnichar(' '));
+        AppendValueToString(eCSSProperty_border_image_slice, aValue);
+        if (!widthDefault || !outsetDefault) {
+          aValue.Append(NS_LITERAL_STRING(" /"));
+          if (!widthDefault) {
+            aValue.Append(PRUnichar(' '));
+            AppendValueToString(eCSSProperty_border_image_width, aValue);
+          }
+          if (!outsetDefault) {
+            aValue.Append(NS_LITERAL_STRING(" / "));
+            AppendValueToString(eCSSProperty_border_image_outset, aValue);
+          }
+        }
+      }
+
+      bool repeatDefault = HasDefaultBorderImageRepeat();
+      if (!repeatDefault) {
+        aValue.Append(PRUnichar(' '));
+        AppendValueToString(eCSSProperty_border_image_repeat, aValue);
+      }
       break;
     case eCSSProperty_border: {
       const nsCSSProperty* subproptables[3] = {
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_color),
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_style),
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_width)
       };
       bool match = true;
diff --git a/layout/style/Declaration.h b/layout/style/Declaration.h
--- a/layout/style/Declaration.h
+++ b/layout/style/Declaration.h
@@ -248,16 +248,21 @@ private:
   static void AppendImportanceToString(bool aIsImportant, nsAString& aString);
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
   bool AppendValueToString(nsCSSProperty aProperty, nsAString& aResult) const;
   // Helper for ToString with strange semantics regarding aValue.
   void AppendPropertyAndValueToString(nsCSSProperty aProperty,
                                       nsAutoString& aValue,
                                       nsAString& aResult) const;
 
+  bool HasDefaultBorderImageSlice() const;
+  bool HasDefaultBorderImageWidth() const;
+  bool HasDefaultBorderImageOutset() const;
+  bool HasDefaultBorderImageRepeat() const;
+
 public:
   nsCSSProperty OrderValueAt(PRUint32 aValue) const {
     return nsCSSProperty(mOrder.ElementAt(aValue));
   }
 
   size_t SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf) const;
 
 private:
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -733,16 +733,23 @@ struct nsCSSRect {
     return mTop != aOther.mTop ||
            mRight != aOther.mRight ||
            mBottom != aOther.mBottom ||
            mLeft != aOther.mLeft;
   }
 
   void SetAllSidesTo(const nsCSSValue& aValue);
 
+  bool DoAllSidesEqual(const nsCSSValue& aValue) const {
+    return mTop == aValue &&
+           mRight == aValue &&
+           mBottom == aValue &&
+           mLeft == aValue;
+  }
+
   void Reset() {
     mTop.Reset();
     mRight.Reset();
     mBottom.Reset();
     mLeft.Reset();
   }
 
   bool HasValue() const {
@@ -817,16 +824,21 @@ struct nsCSSValuePair {
            mYValue == aOther.mYValue;
   }
 
   bool operator!=(const nsCSSValuePair& aOther) const {
     return mXValue != aOther.mXValue ||
            mYValue != aOther.mYValue;
   }
 
+  bool DoBothValuesEqual(const nsCSSValue& aValue) const {
+    return mXValue == aValue &&
+           mYValue == aValue;
+  }
+
   void SetBothValuesTo(const nsCSSValue& aValue) {
     mXValue = aValue;
     mYValue = aValue;
   }
 
   void Reset() {
     mXValue.Reset();
     mYValue.Reset();
@@ -893,16 +905,22 @@ struct nsCSSValueTriplet {
     }
 
     bool operator!=(const nsCSSValueTriplet& aOther) const {
         return mXValue != aOther.mXValue ||
                mYValue != aOther.mYValue ||
                mZValue != aOther.mZValue;
     }
 
+    bool DoAllValuesEqual(const nsCSSValue& aValue) const {
+        return mXValue == aValue &&
+               mYValue == aValue &&
+               mZValue == aValue;
+    }
+
     void SetAllValuesTo(const nsCSSValue& aValue) {
         mXValue = aValue;
         mYValue = aValue;
         mZValue = aValue;
     }
 
     void Reset() {
         mXValue.Reset();
