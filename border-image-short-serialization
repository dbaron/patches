From: L. David Baron <dbaron@dbaron.org>

Serialize border-image shorthand to shortest form, with the exception that we'll always serialize 'border-image-source'.  (Bug 713643, patch 1)

diff --git a/layout/style/Declaration.cpp b/layout/style/Declaration.cpp
--- a/layout/style/Declaration.cpp
+++ b/layout/style/Declaration.cpp
@@ -296,25 +296,66 @@ Declaration::GetValue(nsCSSProperty aPro
           }
           if (i < 3)
             aValue.Append(PRUnichar(' '));
         }
       }
       break;
     }
     case eCSSProperty_border_image:
+      // Even though there are some cases where we could omit
+      // 'border-image-source' (when it's none), it's probably not a
+      // good idea since it's likely to be confusing.  It would also
+      // require adding the extra check that we serialize *something*.
       AppendValueToString(eCSSProperty_border_image_source, aValue);
-      aValue.Append(PRUnichar(' '));
-      AppendValueToString(eCSSProperty_border_image_slice, aValue);
-      aValue.Append(NS_LITERAL_STRING(" / "));
-      AppendValueToString(eCSSProperty_border_image_width, aValue);
-      aValue.Append(NS_LITERAL_STRING(" / "));
-      AppendValueToString(eCSSProperty_border_image_outset, aValue);
-      aValue.Append(PRUnichar(' '));
-      AppendValueToString(eCSSProperty_border_image_repeat, aValue);
+
+      const nsCSSValueList *slice =
+        data->ValueFor(eCSSProperty_border_image_slice)->
+        GetListValue();
+      bool sliceDefault = !slice->mNext &&
+                          slice->mValue->GetRectValue()->DoAllSidesEqual(
+                            nsCSSValue(1.0f, eCSSUnit_Percent));
+
+      const nsCSSRect *width =
+        data->ValueFor(eCSSProperty_border_image_width)->
+        GetRectValue();
+      bool widthDefault =
+        width->DoAllSidesEqual(nsCSSValue(1.0f, eCSSUnit_Number));
+
+      const nsCSSRect *outset =
+        data->ValueFor(eCSSProperty_border_image_outset)->
+        GetRectValue();
+      bool outsetDefault =
+        outset->DoAllSidesEqual(nsCSSValue(0.0f, eCSSUnit_Number));
+
+      if (!sliceDefault || !widthDefault || !outsetDefault) {
+        aValue.Append(PRUnichar(' '));
+        AppendValueToString(eCSSProperty_border_image_slice, aValue);
+        if (!widthDefault || !outsetDefault) {
+          aValue.Append(NS_LITERAL_STRING(" /"));
+          if (!widthDefault) {
+            aValue.Append(PRUnichar(' '));
+            AppendValueToString(eCSSProperty_border_image_width, aValue);
+          }
+          if (!outsetDefault) {
+            aValue.Append(NS_LITERAL_STRING(" / "));
+            AppendValueToString(eCSSProperty_border_image_outset, aValue);
+          }
+        }
+      }
+
+      const nsCSSValuePair *repeat =
+        data->ValueFor(eCSSProperty_border_image_repeat)->
+        GetPairValue();
+      bool repeatDefault = repeat->DoBothValuesEqual(
+        nsCSSValue(NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH, eCSSUnit_Enumerated));
+      if (!repeatDefault) {
+        aValue.Append(PRUnichar(' '));
+        AppendValueToString(eCSSProperty_border_image_repeat, aValue);
+      }
       break;
     case eCSSProperty_border: {
       const nsCSSProperty* subproptables[3] = {
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_color),
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_style),
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_width)
       };
       bool match = true;
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -733,16 +733,23 @@ struct nsCSSRect {
     return mTop != aOther.mTop ||
            mRight != aOther.mRight ||
            mBottom != aOther.mBottom ||
            mLeft != aOther.mLeft;
   }
 
   void SetAllSidesTo(const nsCSSValue& aValue);
 
+  bool DoAllSidesEqual(const nsCSSValue& aValue) const {
+    return mTop == aValue &&
+           mRight == aValue &&
+           mBottom == aValue &&
+           mLeft == aValue;
+  }
+
   void Reset() {
     mTop.Reset();
     mRight.Reset();
     mBottom.Reset();
     mLeft.Reset();
   }
 
   bool HasValue() const {
@@ -817,16 +824,21 @@ struct nsCSSValuePair {
            mYValue == aOther.mYValue;
   }
 
   bool operator!=(const nsCSSValuePair& aOther) const {
     return mXValue != aOther.mXValue ||
            mYValue != aOther.mYValue;
   }
 
+  bool DoBothValuesEqual(const nsCSSValue& aValue) const {
+    return mXValue == aValue &&
+           mYValue == aValue;
+  }
+
   void SetBothValuesTo(const nsCSSValue& aValue) {
     mXValue = aValue;
     mYValue = aValue;
   }
 
   void Reset() {
     mXValue.Reset();
     mYValue.Reset();
@@ -893,16 +905,22 @@ struct nsCSSValueTriplet {
     }
 
     bool operator!=(const nsCSSValueTriplet& aOther) const {
         return mXValue != aOther.mXValue ||
                mYValue != aOther.mYValue ||
                mZValue != aOther.mZValue;
     }
 
+    bool DoAllValuesEqual(const nsCSSValue& aValue) const {
+        return mXValue == aValue &&
+               mYValue == aValue &&
+               mZValue == aValue;
+    }
+
     void SetAllValuesTo(const nsCSSValue& aValue) {
         mXValue = aValue;
         mYValue = aValue;
         mZValue = aValue;
     }
 
     void Reset() {
         mXValue.Reset();
