From: L. David Baron <dbaron@dbaron.org>

Bug 828312 patch 9b:  Make handling of RecomputePosition hint check continuations.  r=bzbarsky

This is part of the patch stack making change hints apply across all
continuations and block-in-inline siblings.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -340,48 +340,49 @@ RestyleManager::RecomputePosition(nsIFra
         // We don't currently support relative positioning of inner
         // table elements.  If we apply offsets to things we haven't
         // previously offset, we'll get confused.  So bail.
         return true;
       default:
         break;
     }
 
-    nsIFrame* cb = aFrame->GetContainingBlock();
-    nsMargin newOffsets;
 
     // Move the frame
     if (display->mPosition == NS_STYLE_POSITION_STICKY) {
       // Update sticky positioning for an entire element at once when
       // RecomputePosition is called with the first continuation in a chain.
-      if (!aFrame->GetPrevContinuation()) {
-        StickyScrollContainer::ComputeStickyOffsets(aFrame);
-        StickyScrollContainer* ssc =
-          StickyScrollContainer::GetStickyScrollContainerForFrame(aFrame);
-        if (ssc) {
-          ssc->PositionContinuations(aFrame);
-        }
+      StickyScrollContainer::ComputeStickyOffsets(aFrame);
+      StickyScrollContainer* ssc =
+        StickyScrollContainer::GetStickyScrollContainerForFrame(aFrame);
+      if (ssc) {
+        ssc->PositionContinuations(aFrame);
       }
     } else {
       MOZ_ASSERT(NS_STYLE_POSITION_RELATIVE == display->mPosition,
                  "Unexpected type of positioning");
-      const nsSize size = cb->GetContentRectRelativeToSelf().Size();
+      for (nsIFrame *cont = aFrame; cont;
+           cont = nsLayoutUtils::GetNextContinuationOrSpecialSibling(cont)) {
+        nsIFrame* cb = cont->GetContainingBlock();
+        nsMargin newOffsets;
+        const nsSize size = cb->GetContentRectRelativeToSelf().Size();
 
-      nsHTMLReflowState::ComputeRelativeOffsets(
-          cb->StyleVisibility()->mDirection,
-          aFrame, size.width, size.height, newOffsets);
-      NS_ASSERTION(newOffsets.left == -newOffsets.right &&
-                   newOffsets.top == -newOffsets.bottom,
-                   "ComputeRelativeOffsets should return valid results");
+        nsHTMLReflowState::ComputeRelativeOffsets(
+            cb->StyleVisibility()->mDirection,
+            cont, size.width, size.height, newOffsets);
+        NS_ASSERTION(newOffsets.left == -newOffsets.right &&
+                     newOffsets.top == -newOffsets.bottom,
+                     "ComputeRelativeOffsets should return valid results");
 
-      // nsHTMLReflowState::ApplyRelativePositioning would work here, but
-      // since we've already checked mPosition and aren't changing the frame's
-      // normal position, go ahead and add the offsets directly.
-      aFrame->SetPosition(aFrame->GetNormalPosition() +
+        // nsHTMLReflowState::ApplyRelativePositioning would work here, but
+        // since we've already checked mPosition and aren't changing the frame's
+        // normal position, go ahead and add the offsets directly.
+        cont->SetPosition(cont->GetNormalPosition() +
                           nsPoint(newOffsets.left, newOffsets.top));
+      }
     }
 
     return true;
   }
 
   // For absolute positioning, the width can potentially change if width is
   // auto and either of left or right are not.  The height can also potentially
   // change if height is auto and either of top or bottom are not.  In these
