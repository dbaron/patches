From: L. David Baron <dbaron@dbaron.org>

Bug 828312 patch 9:  Make handling of RecomputePosition hint check continuations.

This is part of the patch stack making change hints apply across all
continuations and block-in-inline siblings.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -340,48 +340,49 @@ RestyleManager::RecomputePosition(nsIFra
         // We don't currently support relative positioning of inner
         // table elements.  If we apply offsets to things we haven't
         // previously offset, we'll get confused.  So bail.
         return true;
       default:
         break;
     }
 
-    nsIFrame* cb = aFrame->GetContainingBlock();
-    nsMargin newOffsets;
 
     // Move the frame
     if (display->mPosition == NS_STYLE_POSITION_STICKY) {
       // Update sticky positioning for an entire element at once when
       // RecomputePosition is called with the first continuation in a chain.
-      if (!aFrame->GetPrevContinuation()) {
-        StickyScrollContainer::ComputeStickyOffsets(aFrame);
-        StickyScrollContainer* ssc =
-          StickyScrollContainer::GetStickyScrollContainerForFrame(aFrame);
-        if (ssc) {
-          ssc->PositionContinuations(aFrame);
-        }
+      StickyScrollContainer::ComputeStickyOffsets(aFrame);
+      StickyScrollContainer* ssc =
+        StickyScrollContainer::GetStickyScrollContainerForFrame(aFrame);
+      if (ssc) {
+        ssc->PositionContinuations(aFrame);
       }
     } else {
       MOZ_ASSERT(NS_STYLE_POSITION_RELATIVE == display->mPosition,
                  "Unexpected type of positioning");
-      const nsSize size = cb->GetContentRectRelativeToSelf().Size();
+      for (nsIFrame *cont = aFrame; cont;
+           cont = nsLayoutUtils::GetNextContinuationOrSpecialSibling(cont)) {
+        nsIFrame* cb = aFrame->GetContainingBlock();
+        nsMargin newOffsets;
+        const nsSize size = cb->GetContentRectRelativeToSelf().Size();
 
-      nsHTMLReflowState::ComputeRelativeOffsets(
-          cb->StyleVisibility()->mDirection,
-          aFrame, size.width, size.height, newOffsets);
-      NS_ASSERTION(newOffsets.left == -newOffsets.right &&
-                   newOffsets.top == -newOffsets.bottom,
-                   "ComputeRelativeOffsets should return valid results");
+        nsHTMLReflowState::ComputeRelativeOffsets(
+            cb->StyleVisibility()->mDirection,
+            aFrame, size.width, size.height, newOffsets);
+        NS_ASSERTION(newOffsets.left == -newOffsets.right &&
+                     newOffsets.top == -newOffsets.bottom,
+                     "ComputeRelativeOffsets should return valid results");
 
-      // nsHTMLReflowState::ApplyRelativePositioning would work here, but
-      // since we've already checked mPosition and aren't changing the frame's
-      // normal position, go ahead and add the offsets directly.
-      aFrame->SetPosition(aFrame->GetNormalPosition() +
-                          nsPoint(newOffsets.left, newOffsets.top));
+        // nsHTMLReflowState::ApplyRelativePositioning would work here, but
+        // since we've already checked mPosition and aren't changing the frame's
+        // normal position, go ahead and add the offsets directly.
+        aFrame->SetPosition(aFrame->GetNormalPosition() +
+                            nsPoint(newOffsets.left, newOffsets.top));
+      }
     }
 
     return true;
   }
 
   // For absolute positioning, the width can potentially change if width is
   // auto and either of left or right are not.  The height can also potentially
   // change if height is auto and either of top or bottom are not.  In these
diff --git a/layout/generic/StickyScrollContainer.cpp b/layout/generic/StickyScrollContainer.cpp
--- a/layout/generic/StickyScrollContainer.cpp
+++ b/layout/generic/StickyScrollContainer.cpp
@@ -124,17 +124,17 @@ StickyScrollContainer::ComputeStickyOffs
               new nsMargin(computedOffsets));
   }
 }
 
 void
 StickyScrollContainer::ComputeStickyLimits(nsIFrame* aFrame, nsRect* aStick,
                                            nsRect* aContain) const
 {
-  NS_ASSERTION(!aFrame->GetPrevContinuation(),
+  NS_ASSERTION(!nsLayoutUtils::GetPrevContinuationOrSpecialSibling(aFrame),
                "Can't sticky position individual continuations");
 
   aStick->SetRect(nscoord_MIN/2, nscoord_MIN/2, nscoord_MAX, nscoord_MAX);
   aContain->SetRect(nscoord_MIN/2, nscoord_MIN/2, nscoord_MAX, nscoord_MAX);
 
   const nsMargin* computedOffsets = static_cast<nsMargin*>(
     aFrame->Properties().Get(nsIFrame::ComputedOffsetProperty()));
   if (!computedOffsets) {
@@ -259,25 +259,23 @@ StickyScrollContainer::GetScrollRanges(n
     aInner->SetRightEdge(normalPosition.x - stick.x);
     aOuter->SetRightEdge(contain.XMost() - stick.x);
   }
 }
 
 void
 StickyScrollContainer::PositionContinuations(nsIFrame* aFrame)
 {
-  NS_ASSERTION(!aFrame->GetPrevContinuation(),
+  NS_ASSERTION(!nsLayoutUtils::GetPrevContinuationOrSpecialSibling(aFrame),
                "Should be starting from the first continuation");
-  nsPoint newPosition = ComputePosition(aFrame);
-  nsPoint translation = newPosition - aFrame->GetPosition();
-  aFrame->SetPosition(newPosition);
+  nsPoint translation = ComputePosition(aFrame) - aFrame->GetPosition();
 
   // Move all continuation frames by the same amount.
-  for (nsIFrame* cont = aFrame->GetNextContinuation(); cont;
-       cont = cont->GetNextContinuation()) {
+  for (nsIFrame* cont = aFrame; cont;
+       cont = nsLayoutUtils::GetNextContinuationOrSpecialSibling(cont)) {
     cont->SetPosition(cont->GetPosition() + translation);
   }
 }
 
 void
 StickyScrollContainer::UpdatePositions(nsPoint aScrollPosition,
                                        nsIFrame* aSubtreeRoot)
 {
@@ -298,17 +296,18 @@ StickyScrollContainer::UpdatePositions(n
     if (aSubtreeRoot) {
       // Reflowing the scroll frame, so recompute offsets.
       ComputeStickyOffsets(f);
     }
     // mFrames will only contain first continuations, because we filter in
     // nsIFrame::Init.
     PositionContinuations(f);
 
-    for (nsIFrame* cont = f; cont; cont = cont->GetNextContinuation()) {
+    for (nsIFrame* cont = f; cont;
+         cont = nsLayoutUtils::GetNextContinuationOrSpecialSibling(cont)) {
       oct.AddFrame(cont);
     }
   }
   oct.Flush();
 }
 
 void
 StickyScrollContainer::ScrollPositionWillChange(nscoord aX, nscoord aY)
