Stop using potentially-deep recursion to serialize selectors.  (Bug 475215)

diff --git a/layout/style/nsCSSStyleRule.cpp b/layout/style/nsCSSStyleRule.cpp
--- a/layout/style/nsCSSStyleRule.cpp
+++ b/layout/style/nsCSSStyleRule.cpp
@@ -70,16 +70,17 @@
 #include "nsXMLNameSpaceMap.h"
 #include "nsILookAndFeel.h"
 #include "nsRuleNode.h"
 #include "nsUnicharUtils.h"
 #include "nsCSSPseudoElements.h"
 #include "nsIPrincipal.h"
 #include "nsComponentManagerUtils.h"
 #include "nsCSSPseudoClasses.h"
+#include "nsTArray.h"
 
 #include "nsContentUtils.h"
 #include "nsContentErrors.h"
 #include "mozAutoDocUpdate.h"
 
 #define NS_IF_CLONE(member_)                                                  \
   PR_BEGIN_MACRO                                                              \
     if (member_) {                                                            \
@@ -463,53 +464,78 @@ static PRBool IsPseudoElement(nsIAtom* a
     const char* str;
     aAtom->GetUTF8String(&str);
     return str && (*str == ':');
   }
 
   return PR_FALSE;
 }
 
-void nsCSSSelector::AppendNegationToString(nsAString& aString)
-{
-  aString.AppendLiteral(":not(");
-}
-
 //
 // Builds the textual representation of a selector. Called by DOM 2 CSS 
 // StyleRule:selectorText
 //
 void
 nsCSSSelector::ToString(nsAString& aString, nsICSSStyleSheet* aSheet,
                         PRBool aAppend) const
 {
   if (!aAppend)
    aString.Truncate();
+
+  // selectors are linked from right-to-left, so the next selector in
+  // the linked list actually precedes this one in the resulting string
+  nsAutoTArray<const nsCSSSelector*, 8> stack;
+  for (const nsCSSSelector *s = this; s; s = s->mNext) {
+    stack.AppendElement(s);
+  }
    
-  ToStringInternal(aString, aSheet, IsPseudoElement(mTag), PR_FALSE);
+  while (!stack.IsEmpty()) {
+    PRUint32 index = stack.Length() - 1;
+    const nsCSSSelector *s = stack.ElementAt(index);
+    stack.RemoveElementAt(index);
+
+    s->AppendToStringWithoutCombinators(aString, aSheet);
+
+    // Append the combinator, if needed.
+    if (!stack.IsEmpty()) {
+      const nsCSSSelector *next = stack.ElementAt(index - 1);
+      if (!IsPseudoElement(next->mTag)) {
+        aString.Append(PRUnichar(' '));
+        PRUnichar oper = s->mOperator;
+        if (oper != PRUnichar(0)) {
+          aString.Append(oper);
+          aString.Append(PRUnichar(' '));
+        }
+      }
+    }
+  }
 }
 
-void nsCSSSelector::ToStringInternal(nsAString& aString,
-                                     nsICSSStyleSheet* aSheet,
-                                     PRBool aIsPseudoElem,
-                                     PRBool aIsNegated) const
+void
+nsCSSSelector::AppendToStringWithoutCombinators
+                   (nsAString& aString, nsICSSStyleSheet* aSheet) const
+{
+  AppendToStringWithoutCombinatorsOrNegations(aString, aSheet, PR_FALSE);
+
+  for (const nsCSSSelector* negation = mNegations; negation;
+       negation = negation->mNegations) {
+    aString.AppendLiteral(":not(");
+    negation->AppendToStringWithoutCombinatorsOrNegations(aString, aSheet,
+                                                          PR_TRUE);
+    aString.Append(PRUnichar(')'));
+  }
+}
+
+void
+nsCSSSelector::AppendToStringWithoutCombinatorsOrNegations
+                   (nsAString& aString, nsICSSStyleSheet* aSheet,
+                   PRBool aIsNegated) const
 {
   nsAutoString temp;
   PRBool isPseudoElement = IsPseudoElement(mTag);
-  
-  // selectors are linked from right-to-left, so the next selector in the linked list
-  // actually precedes this one in the resulting string
-  if (mNext) {
-    mNext->ToStringInternal(aString, aSheet, IsPseudoElement(mTag), 0);
-    if (!aIsNegated && !isPseudoElement) {
-      // don't add a leading whitespace if we have a pseudo-element
-      // or a negated simple selector
-      aString.Append(PRUnichar(' '));
-    }
-  }
 
   // For non-pseudo-element selectors or for lone pseudo-elements, deal with
   // namespace prefixes.
   PRBool wroteNamespace = PR_FALSE;
   if (!isPseudoElement || !mNext) {
     // append the namespace prefix if needed
     nsXMLNameSpaceMap *sheetNS = aSheet ? aSheet->GetNameSpaceMap() : nsnull;
 
@@ -687,32 +713,16 @@ void nsCSSSelector::ToStringInternal(nsA
           }
           aString.Append(temp);
         }
         aString.Append(PRUnichar(')'));
       }
       list = list->mNext;
     }
   }
-
-  if (!aIsNegated) {
-    for (nsCSSSelector* negation = mNegations; negation;
-         negation = negation->mNegations) {
-      aString.AppendLiteral(":not(");
-      negation->ToStringInternal(aString, aSheet, PR_FALSE, PR_TRUE);
-      aString.Append(PRUnichar(')'));
-    }
-  }
-
-  // Append the operator only if the selector is not negated and is not
-  // a pseudo-element
-  if (!aIsNegated && mOperator && !aIsPseudoElem) {
-    aString.Append(PRUnichar(' '));
-    aString.Append(mOperator);
-  }
 }
 
 PRBool
 nsCSSSelector::CanBeNamespaced(PRBool aIsNegated) const
 {
   return !aIsNegated ||
          (!mIDList && !mClassList && !mPseudoClassList && !mAttrList);
 }
diff --git a/layout/style/nsICSSStyleRule.h b/layout/style/nsICSSStyleRule.h
--- a/layout/style/nsICSSStyleRule.h
+++ b/layout/style/nsICSSStyleRule.h
@@ -168,20 +168,22 @@ public:
 
   void ToString(nsAString& aString, nsICSSStyleSheet* aSheet,
                 PRBool aAppend = PR_FALSE) const;
 
 private:
   void AddPseudoClassInternal(nsPseudoClassList *aPseudoClass);
   nsCSSSelector* Clone(PRBool aDeepNext, PRBool aDeepNegations) const;
 
-  void AppendNegationToString(nsAString& aString);
-  void ToStringInternal(nsAString& aString, nsICSSStyleSheet* aSheet,
-                        PRBool aIsPseudoElem,
-                        PRBool aIsNegated) const;
+  void AppendToStringWithoutCombinators(nsAString& aString,
+                                        nsICSSStyleSheet* aSheet) const;
+  void AppendToStringWithoutCombinatorsOrNegations(nsAString& aString,
+                                                   nsICSSStyleSheet* aSheet,
+                                                   PRBool aIsNegated)
+                                                        const;
   // Returns true if this selector can have a namespace specified (which
   // happens if and only if the default namespace would apply to this
   // selector).
   PRBool CanBeNamespaced(PRBool aIsNegated) const;
   // Calculate the specificity of this selector (not including its mNext
   // or its mNegations).
   PRInt32 CalcWeightWithoutNegations() const;
 
diff --git a/layout/style/test/test_selectors.html b/layout/style/test/test_selectors.html
--- a/layout/style/test/test_selectors.html
+++ b/layout/style/test/test_selectors.html
@@ -34,28 +34,32 @@ function run() {
 
     /*
      * selector: the selector to test
      * body_contents: what to set the body's innerHTML to
      * match_fn: a function that, given the document object into which
      *   body_contents has been inserted, produces an array of nodes that
      *   should match selector
      * notmatch_fn: likewise, but for nodes that should not match
+     * namespaces (optional): @namespace rules to be included in the sheet
      */
-    function test_selector_in_html(selector, body_contents, match_fn, notmatch_fn)
+    function test_selector_in_html(selector, body_contents, match_fn, notmatch_fn, namespaces)
     {
         var zi = ++gCounter;
         if (typeof(body_contents) == "string") {
             ifdoc.body.innerHTML = body_contents;
         } else {
             // It's a function.
             ifdoc.body.innerHTML = "";
             body_contents(ifdoc.body);
         }
-        style_text.data = selector + "{ z-index: " + zi + " }";
+        if (!namespaces) {
+            namespaces = "";
+        }
+        style_text.data = namespaces + selector + "{ z-index: " + zi + " }";
         var should_match = match_fn(ifdoc);
         var should_not_match = notmatch_fn(ifdoc);
         if (should_match.length + should_not_match.length == 0) {
             ok(false, "nothing to check");
         }
 
         for (var i = 0; i < should_match.length; ++i) {
             var e = should_match[i];
@@ -68,41 +72,54 @@ function run() {
                "element in " + body_contents + " did not match " + selector);
         }
 
         // Now, since we're here, may as well make sure serialization
         // works correctly.  It need not produce the exact same text,
         // but it should produce a selector that matches the same
         // elements.
         zi = ++gCounter;
-        var ser1 = style_text.parentNode.sheet.cssRules[0].selectorText;
-        style_text.data = ser1 + "{ z-index: " + zi + " }";
+        var idx = style_text.parentNode.sheet.cssRules.length - 1;
+        if (namespaces == "") {
+            is(idx, 0, "unexpected rule index");
+        }
+        var ser1 = style_text.parentNode.sheet.cssRules[idx].selectorText;
+        style_text.data = namespaces + ser1 + "{ z-index: " + zi + " }";
         for (var i = 0; i < should_match.length; ++i) {
             var e = should_match[i];
             is(ifwin.getComputedStyle(e, "").zIndex, zi,
                "element in " + body_contents + " matched " + ser1 +
                " which is the reserialization of " + selector);
         }
         for (var i = 0; i < should_not_match.length; ++i) {
             var e = should_not_match[i];
             is(ifwin.getComputedStyle(e, "").zIndex, "auto",
                "element in " + body_contents + " did not match " + ser1 +
                " which is the reserialization of " + selector);
         }
 
         // But when we serialize the serialized result, we should get
         // the same text.
-        var ser2 = style_text.parentNode.sheet.cssRules[0].selectorText;
+        var ser2 = style_text.parentNode.sheet.cssRules[idx].selectorText;
         is(ser2, ser1, "parse+serialize of selector \"" + selector +
                        "\" is idempotent");
 
         ifdoc.body.innerHTML = "";
         style_text.data = "";
     }
 
+    function should_serialize_to(selector, serialization)
+    {
+        style_text.data = selector + "{ z-index: 0 }";
+        is(style_text.parentNode.sheet.cssRules[0].selectorText,
+           serialization,
+           "selector '" + selector + "' should serialize to '" +
+             serialization + "'.");
+    }
+
     function test_parseable(selector)
     {
         var zi = ++gCounter;
         ifdoc.body.innerHTML = "<p></p>";
         style_text.data = "p, " + selector + "{ z-index: " + zi + " }";
         var should_match = ifdoc.getElementsByTagName("p")[0];
         is(ifwin.getComputedStyle(should_match, "").zIndex, zi,
            "selector " + selector + " was parsed");
@@ -454,16 +471,74 @@ function run() {
                           pdaset([2], [2], []));
     test_selector_in_html(":nth-of-type(2n-0)", mixed_elements,
                           pdaset([2], [2], []),
                           pdaset([1, 3, 4], [1], [1, 2]));
     test_selector_in_html(":nth-last-of-type(even)", mixed_elements,
                           pdaset([2], [1], []),
                           pdaset([1, 3, 4], [2], [1, 2]));
 
+    // Test greediness of descendant combinators.
+    var four_children="<div id='a'><div id='b'><div id='c'><div id='d'><\/div><\/div><\/div><\/div>";
+    test_selector_in_html("#a > div div", four_children,
+                          idset(["c", "d"]), idset(["a", "b"]));
+    test_selector_in_html("#a > #b div", four_children,
+                          idset(["c", "d"]), idset(["a", "b"]));
+    test_selector_in_html("#a div > div", four_children,
+                          idset(["c", "d"]), idset(["a", "b"]));
+    test_selector_in_html("#a #b > div", four_children,
+                          idset(["c"]), idset(["a", "b", "d"]));
+    test_selector_in_html("#a > #b div", four_children,
+                          idset(["c", "d"]), idset(["a", "b"]));
+    test_selector_in_html("#a #c > div", four_children,
+                          idset(["d"]), idset(["a", "b", "c"]));
+    test_selector_in_html("#a > #c div", four_children,
+                          idset([]), idset(["a", "b", "c", "d"]));
+
+    // Test serialization of pseudo-elements.
+    should_serialize_to("p:first-letter", "p:first-letter");
+    should_serialize_to("div>p:first-letter", "div > p:first-letter");
+    should_serialize_to("span +div:first-line", "span + div:first-line");
+
+    // Test default namespaces, including inside :not().
+    var html_default_ns = "@namespace url(http://www.w3.org/1999/xhtml);";
+    var html_ns = "@namespace html url(http://www.w3.org/1999/xhtml);";
+    var xul_default_ns = "@namespace url(http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul);";
+    var single_div = "<div id='a'></div>";
+    var set_single = idset(['a']);
+    var empty_set = idset([]);
+    test_selector_in_html("div", single_div, set_single, empty_set,
+                          html_default_ns);
+    test_selector_in_html("div", single_div, empty_set, set_single,
+                          xul_default_ns);
+    test_selector_in_html("*|div", single_div, set_single, empty_set,
+                          xul_default_ns);
+    test_selector_in_html("html|div", single_div, set_single, empty_set,
+                          xul_default_ns + html_ns);
+    test_selector_in_html("*|div:not(*)", single_div, empty_set, set_single,
+                          xul_default_ns);
+    test_selector_in_html("*|div:not(div)", single_div, empty_set, set_single,
+                          xul_default_ns);
+    test_selector_in_html("*|div:not(html|*)", single_div, empty_set, set_single,
+                          xul_default_ns + html_ns);
+    test_selector_in_html("*|div:not(html|div)", single_div, empty_set, set_single,
+                          xul_default_ns + html_ns);
+    test_selector_in_html("*|div:not(|*)", single_div, set_single, empty_set,
+                          xul_default_ns + html_ns);
+    test_selector_in_html("*|div:not(|div)", single_div, set_single, empty_set,
+                          xul_default_ns + html_ns);
+    test_selector_in_html("html|div:not(|*)", single_div, set_single, empty_set,
+                          xul_default_ns + html_ns);
+    test_selector_in_html("html|div:not(|div)", single_div, set_single, empty_set,
+                          xul_default_ns + html_ns);
+    test_selector_in_html("html|div:not(*|*)", single_div, empty_set, set_single,
+                          xul_default_ns + html_ns);
+    test_selector_in_html("html|div:not(*|div)", single_div, empty_set, set_single,
+                          xul_default_ns + html_ns);
+
     SimpleTest.finish();
 }
 
 </script>
 </pre>
 </body>
 </html>
 
