From: Daniel Glazman <daniel@glazman.org>

:not() selector with no argument should be a parse error.  (Bug 553805)  r=dbaron

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -3259,16 +3259,21 @@ CSSParserImpl::nsSelectorParsingStatus
 CSSParserImpl::ParseNegatedSimpleSelector(PRInt32&       aDataMask,
                                           nsCSSSelector& aSelector)
 {
   if (! GetToken(PR_TRUE)) { // premature eof
     REPORT_UNEXPECTED_EOF(PENegationEOF);
     return eSelectorParsingStatus_Error;
   }
 
+  if (mToken.IsSymbol(')')) {
+    REPORT_UNEXPECTED_TOKEN(PENegationBadArg);
+    return eSelectorParsingStatus_Error;
+  }
+
   // Create a new nsCSSSelector and add it to the end of
   // aSelector.mNegations.
   // Given the current parsing rules, every selector in mNegations
   // contains only one simple selector (css3 definition) within it.
   // This could easily change in future versions of CSS, and the only
   // thing we need to change to support that is this parsing code and the
   // serialization code for nsCSSSelector.
   nsCSSSelector *newSel = new nsCSSSelector();
diff --git a/layout/style/test/test_selectors.html b/layout/style/test/test_selectors.html
--- a/layout/style/test/test_selectors.html
+++ b/layout/style/test/test_selectors.html
@@ -795,16 +795,33 @@ function run() {
     test_selector_in_html("[id=\\32]", spans,
                           bodychildset([2]), bodychildset([0, 1, 3]));
     test_selector_in_html("#\\2", spans,
                           bodychildset([3]), bodychildset([0, 1, 2]));
     test_selector_in_html("[id=\\2]", spans,
                           bodychildset([3]), bodychildset([0, 1, 2]));
     test_balanced_unparseable("#2");
 
+    // Bug 553805:  :not() containing nothing is forbidden
+    test_balanced_unparseable(":not()");
+    test_balanced_unparseable(":not( )");
+    test_balanced_unparseable(":not( \t\n )");
+    test_balanced_unparseable(":not(/*comment*/)");
+    test_balanced_unparseable(":not( /*comment*/  /* comment */  )");
+    test_balanced_unparseable("p :not()");
+    test_balanced_unparseable("p :not( )");
+    test_balanced_unparseable("p :not( \t\n )");
+    test_balanced_unparseable("p :not(/*comment*/)");
+    test_balanced_unparseable("p :not( /*comment*/  /* comment */  )");
+    test_balanced_unparseable("p:not()");
+    test_balanced_unparseable("p:not( )");
+    test_balanced_unparseable("p:not( \t\n )");
+    test_balanced_unparseable("p:not(/*comment*/)");
+    test_balanced_unparseable("p:not( /*comment*/  /* comment */  )");
+
     run_deferred_tests();
 }
 
 var deferred_tests = [];
 
 function defer_clonedoc_tests(docurl, onloadfunc)
 {
     deferred_tests.push( { docurl: docurl, onloadfunc: onloadfunc } );
