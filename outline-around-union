From: L. David Baron <dbaron@dbaron.org>

Bug 480888 patch 3:  Draw outline around the union of border boxes rather than the visual overflow area.

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -749,20 +749,18 @@ nsCSSRendering::PaintBorderWithStyleBord
 
 static nsRect
 GetOutlineInnerRect(nsIFrame* aFrame)
 {
   nsRect* savedOutlineInnerRect = static_cast<nsRect*>
     (aFrame->Properties().Get(nsIFrame::OutlineInnerRectProperty()));
   if (savedOutlineInnerRect)
     return *savedOutlineInnerRect;
-  // FIXME (bug 599652): We probably want something narrower than either
-  // overflow rect here, but for now use the visual overflow in order to
-  // be consistent with ComputeOutlineAndEffectsRect in nsFrame.cpp.
-  return aFrame->GetVisualOverflowRect();
+  NS_NOTREACHED("we should have saved a frame property");
+  return aFrame->GetRect();
 }
 
 void
 nsCSSRendering::PaintOutline(nsPresContext* aPresContext,
                              nsRenderingContext& aRenderingContext,
                              nsIFrame* aForFrame,
                              const nsRect& aDirtyRect,
                              const nsRect& aBorderArea,
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -5049,42 +5049,16 @@ ComputeEffectsRect(nsIFrame* aFrame, con
       r = nsSVGUtils::GetPostFilterVisualOverflowRect(aFrame, aOverflowRect);
     }
     return r;
   }
 
   // box-shadow
   r.UnionRect(r, nsLayoutUtils::GetBoxShadowRectForFrame(aFrame, aNewSize));
 
-  const nsStyleOutline* outline = aFrame->StyleOutline();
-  uint8_t outlineStyle = outline->GetOutlineStyle();
-  if (outlineStyle != NS_STYLE_BORDER_STYLE_NONE) {
-    nscoord width;
-#ifdef DEBUG
-    bool result = 
-#endif
-      outline->GetOutlineWidth(width);
-    NS_ASSERTION(result, "GetOutlineWidth had no cached outline width");
-    if (width > 0) {
-      if (aStoreRectProperties) {
-        aFrame->Properties().
-          Set(nsIFrame::OutlineInnerRectProperty(), new nsRect(r));
-      }
-
-      nscoord offset = outline->mOutlineOffset;
-      nscoord inflateBy = std::max(width + offset, 0);
-      // FIXME (bug 599652): We probably want outline to be drawn around
-      // something smaller than the visual overflow rect (perhaps the
-      // scrollable overflow rect is correct).  When we change that, we
-      // need to keep this code (and the storing of properties just
-      // above) in sync with GetOutlineInnerRect in nsCSSRendering.cpp.
-      r.Inflate(inflateBy, inflateBy);
-    }
-  }
-
   // border-image-outset.
   // We need to include border-image-outset because it can cause the
   // border image to be drawn beyond the border box.
 
   // (1) It's important we not check whether there's a border-image
   //     since the style hint for a change in border image doesn't cause
   //     reflow, and that's probably more important than optimizing the
   //     overflow areas for the silly case of border-image-outset without
@@ -6879,16 +6853,60 @@ nsIFrame::SetOverflowAreas(const nsOverf
 
 inline bool
 IsInlineFrame(nsIFrame *aFrame)
 {
   nsIAtom *type = aFrame->GetType();
   return type == nsGkAtoms::inlineFrame;
 }
 
+static nsRect UnionBorderBoxes(nsIFrame* aFrame);
+
+/**
+ * Union the border-boxes of all of the descendants of aFrame into
+ * aUnion.
+ */
+static void
+UnionDescendantBorderBoxes(nsIFrame* aFrame, nsRect& aUnion)
+{
+  // Iterate over all children except pop-ups.
+  const nsIFrame::ChildListIDs skip(nsIFrame::kPopupList |
+                                    nsIFrame::kSelectPopupList);
+  for (nsIFrame::ChildListIterator childLists(aFrame);
+       !childLists.IsDone(); childLists.Next()) {
+    if (skip.Contains(childLists.CurrentID())) {
+      continue;
+    }
+
+    nsFrameList children = childLists.CurrentList();
+    for (nsFrameList::Enumerator e(children); !e.AtEnd(); e.Next()) {
+      nsIFrame* child = e.get();
+      aUnion.UnionRectEdges(aUnion,
+                            UnionBorderBoxes(child) + child->GetPosition());
+    }
+  }
+}
+
+/**
+ * Compute the union of the border boxes of aFrame and its descendants.
+ */
+static nsRect
+UnionBorderBoxes(nsIFrame* aFrame)
+{
+  nsRect u(nsPoint(0, 0), aFrame->GetSize());
+  if (aFrame->GetVisualOverflowRect() != u &&
+      aFrame->GetScrollableOverflowRect() != u) {
+    // Only iterate through the children if the overflow areas suggest
+    // that we might need to.
+    UnionDescendantBorderBoxes(aFrame, u);
+  }
+
+  return u;
+}
+
 bool
 nsIFrame::FinishAndStoreOverflow(nsOverflowAreas& aOverflowAreas,
                                  nsSize aNewSize, nsSize* aOldSize)
 {
   NS_ASSERTION(!((GetStateBits() & NS_FRAME_SVG_LAYOUT) &&
                  (GetStateBits() & NS_FRAME_IS_NONDISPLAY)),
                "Don't call - overflow rects not maintained on these SVG frames");
 
@@ -6959,16 +6977,45 @@ nsIFrame::FinishAndStoreOverflow(nsOverf
     if (presContext->GetTheme()->
           GetWidgetOverflow(presContext->DeviceContext(), this,
                             disp->mAppearance, &r)) {
       nsRect& vo = aOverflowAreas.VisualOverflow();
       vo.UnionRectEdges(vo, r);
     }
   }
 
+  const nsStyleOutline* outline = aFrame->StyleOutline();
+  if (outline->GetOutlineStyle() != NS_STYLE_BORDER_STYLE_NONE) {
+    nscoord width;
+    DebugOnly<bool> result = outline->GetOutlineWidth(width);
+    NS_ASSERTION(result, "GetOutlineWidth had no cached outline width");
+    if (width > 0) {
+      // Find the union of the border boxes of all descendants.
+      nsRect innerRect(bounds);
+      if (aOverflowAreas.VisualOverflow() != bounds &&
+          aOverflowAreas.ScrollableOverflow() != bounds) {
+        UnionDescendantBorderBoxes(aFrame, bounds);
+      }
+
+      aFrame->Properties().
+        Set(nsIFrame::OutlineInnerRectProperty(), new nsRect(r));
+
+      nscoord offset = outline->mOutlineOffset;
+      nscoord inflateBy = std::max(width + offset, 0);
+
+      // Keep this code (and the storing of properties just above) in
+      // sync with GetOutlineInnerRect in nsCSSRendering.cpp.
+      nsRect outerRect(innerRect);
+      outerRect.Inflate(inflateBy, inflateBy);
+
+      nsRect& vo = aOverflowAreas.VisualOverflow();
+      vo.UnionRectEdges(vo, outerRect);
+    }
+  }
+
   // Nothing in here should affect scrollable overflow.
   aOverflowAreas.VisualOverflow() =
     ComputeEffectsRect(this, aOverflowAreas.VisualOverflow(), aNewSize, true);
 
   // Absolute position clipping
   nsRect clipPropClipRect;
   bool hasClipPropClip = GetClipPropClipRect(disp, &clipPropClipRect, aNewSize);
   if (hasClipPropClip) {
