From: L. David Baron <dbaron@dbaron.org>

Bug 480888 patch 3:  Draw outline around the union of border boxes rather than the visual overflow area.

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -749,20 +749,18 @@ nsCSSRendering::PaintBorderWithStyleBord
 
 static nsRect
 GetOutlineInnerRect(nsIFrame* aFrame)
 {
   nsRect* savedOutlineInnerRect = static_cast<nsRect*>
     (aFrame->Properties().Get(nsIFrame::OutlineInnerRectProperty()));
   if (savedOutlineInnerRect)
     return *savedOutlineInnerRect;
-  // FIXME (bug 599652): We probably want something narrower than either
-  // overflow rect here, but for now use the visual overflow in order to
-  // be consistent with ComputeEffectsRect in nsFrame.cpp.
-  return aFrame->GetVisualOverflowRect();
+  NS_NOTREACHED("we should have saved a frame property");
+  return nsRect(nsPoint(0, 0), aFrame->GetSize());
 }
 
 void
 nsCSSRendering::PaintOutline(nsPresContext* aPresContext,
                              nsRenderingContext& aRenderingContext,
                              nsIFrame* aForFrame,
                              const nsRect& aDirtyRect,
                              const nsRect& aBorderArea,
@@ -782,48 +780,17 @@ nsCSSRendering::PaintOutline(nsPresConte
   }
 
   nsIFrame* bgFrame = nsCSSRendering::FindNonTransparentBackgroundFrame
     (aForFrame, false);
   nsStyleContext* bgContext = bgFrame->StyleContext();
   nscolor bgColor =
     bgContext->GetVisitedDependentColor(eCSSProperty_background_color);
 
-  // When the outline property is set on :-moz-anonymous-block or
-  // :-moz-anonyomus-positioned-block pseudo-elements, it inherited that
-  // outline from the inline that was broken because it contained a
-  // block.  In that case, we don't want a really wide outline if the
-  // block inside the inline is narrow, so union the actual contents of
-  // the anonymous blocks.
-  nsIFrame *frameForArea = aForFrame;
-  do {
-    nsIAtom *pseudoType = frameForArea->StyleContext()->GetPseudo();
-    if (pseudoType != nsCSSAnonBoxes::mozAnonymousBlock &&
-        pseudoType != nsCSSAnonBoxes::mozAnonymousPositionedBlock)
-      break;
-    // If we're done, we really want it and all its later siblings.
-    frameForArea = frameForArea->GetFirstPrincipalChild();
-    NS_ASSERTION(frameForArea, "anonymous block with no children?");
-  } while (frameForArea);
-  nsRect innerRect; // relative to aBorderArea.TopLeft()
-  if (frameForArea == aForFrame) {
-    innerRect = GetOutlineInnerRect(aForFrame);
-  } else {
-    for (; frameForArea; frameForArea = frameForArea->GetNextSibling()) {
-      // The outline has already been included in aForFrame's overflow
-      // area, but not in those of its descendants, so we have to
-      // include it.  Otherwise we'll end up drawing the outline inside
-      // the border.
-      nsRect r(GetOutlineInnerRect(frameForArea) +
-               frameForArea->GetOffsetTo(aForFrame));
-      innerRect.UnionRect(innerRect, r);
-    }
-  }
-
-  innerRect += aBorderArea.TopLeft();
+  nsRect innerRect = GetOutlineInnerRect(aForFrame) + aBorderArea.TopLeft();
   nscoord offset = ourOutline->mOutlineOffset;
   innerRect.Inflate(offset, offset);
   // If the dirty rect is completely inside the border area (e.g., only the
   // content is being painted), then we can skip out now
   // XXX this isn't exactly true for rounded borders, where the inside curves may
   // encroach into the content area.  A safer calculation would be to
   // shorten insideRect by the radius one each side before performing this test.
   if (innerRect.Contains(aDirtyRect))
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -5042,40 +5042,16 @@ ComputeEffectsRect(nsIFrame* aFrame, con
       r = nsSVGUtils::GetPostFilterVisualOverflowRect(aFrame, aOverflowRect);
     }
     return r;
   }
 
   // box-shadow
   r.UnionRect(r, nsLayoutUtils::GetBoxShadowRectForFrame(aFrame, aNewSize));
 
-  const nsStyleOutline* outline = aFrame->StyleOutline();
-  uint8_t outlineStyle = outline->GetOutlineStyle();
-  if (outlineStyle != NS_STYLE_BORDER_STYLE_NONE) {
-    nscoord width;
-#ifdef DEBUG
-    bool result = 
-#endif
-      outline->GetOutlineWidth(width);
-    NS_ASSERTION(result, "GetOutlineWidth had no cached outline width");
-    if (width > 0) {
-      aFrame->Properties().
-        Set(nsIFrame::OutlineInnerRectProperty(), new nsRect(r));
-
-      nscoord offset = outline->mOutlineOffset;
-      nscoord inflateBy = std::max(width + offset, 0);
-      // FIXME (bug 599652): We probably want outline to be drawn around
-      // something smaller than the visual overflow rect (perhaps the
-      // scrollable overflow rect is correct).  When we change that, we
-      // need to keep this code (and the storing of properties just
-      // above) in sync with GetOutlineInnerRect in nsCSSRendering.cpp.
-      r.Inflate(inflateBy, inflateBy);
-    }
-  }
-
   // border-image-outset.
   // We need to include border-image-outset because it can cause the
   // border image to be drawn beyond the border box.
 
   // (1) It's important we not check whether there's a border-image
   //     since the style hint for a change in border image doesn't cause
   //     reflow, and that's probably more important than optimizing the
   //     overflow areas for the silly case of border-image-outset without
@@ -6868,16 +6844,61 @@ nsIFrame::SetOverflowAreas(const nsOverf
 
 inline bool
 IsInlineFrame(nsIFrame *aFrame)
 {
   nsIAtom *type = aFrame->GetType();
   return type == nsGkAtoms::inlineFrame;
 }
 
+static nsRect UnionBorderBoxes(nsIFrame* aFrame);
+
+/**
+ * Union the border-boxes of all of the descendants of aFrame into
+ * aUnion, in aFrame's coordinate space.
+ */
+static void
+UnionDescendantBorderBoxes(nsIFrame* aFrame, nsRect& aUnion)
+{
+  // Iterate over all children except pop-ups.
+  const nsIFrame::ChildListIDs skip(nsIFrame::kPopupList |
+                                    nsIFrame::kSelectPopupList);
+  for (nsIFrame::ChildListIterator childLists(aFrame);
+       !childLists.IsDone(); childLists.Next()) {
+    if (skip.Contains(childLists.CurrentID())) {
+      continue;
+    }
+
+    nsFrameList children = childLists.CurrentList();
+    for (nsFrameList::Enumerator e(children); !e.AtEnd(); e.Next()) {
+      nsIFrame* child = e.get();
+      aUnion.UnionRectEdges(aUnion,
+                            UnionBorderBoxes(child) + child->GetPosition());
+    }
+  }
+}
+
+/**
+ * Compute the union of the border boxes of aFrame and its descendants,
+ * in aFrame's coordinate space.
+ */
+static nsRect
+UnionBorderBoxes(nsIFrame* aFrame)
+{
+  nsRect u(nsPoint(0, 0), aFrame->GetSize());
+  if (!u.IsEqualEdges(aFrame->GetVisualOverflowRect()) &&
+      !u.IsEqualEdges(aFrame->GetScrollableOverflowRect())) {
+    // Only iterate through the children if the overflow areas suggest
+    // that we might need to.
+    UnionDescendantBorderBoxes(aFrame, u);
+  }
+
+  return u;
+}
+
 bool
 nsIFrame::FinishAndStoreOverflow(nsOverflowAreas& aOverflowAreas,
                                  nsSize aNewSize, nsSize* aOldSize)
 {
   NS_ASSERTION(!((GetStateBits() & NS_FRAME_SVG_LAYOUT) &&
                  (GetStateBits() & NS_FRAME_IS_NONDISPLAY)),
                "Don't call - overflow rects not maintained on these SVG frames");
 
@@ -6948,16 +6969,72 @@ nsIFrame::FinishAndStoreOverflow(nsOverf
     if (presContext->GetTheme()->
           GetWidgetOverflow(presContext->DeviceContext(), this,
                             disp->mAppearance, &r)) {
       nsRect& vo = aOverflowAreas.VisualOverflow();
       vo.UnionRectEdges(vo, r);
     }
   }
 
+  const nsStyleOutline* outline = StyleOutline();
+  if (outline->GetOutlineStyle() != NS_STYLE_BORDER_STYLE_NONE) {
+    nscoord width;
+    DebugOnly<bool> result = outline->GetOutlineWidth(width);
+    NS_ASSERTION(result, "GetOutlineWidth had no cached outline width");
+    if (width > 0) {
+      // When the outline property is set on :-moz-anonymous-block or
+      // :-moz-anonymous-positioned-block pseudo-elements, it inherited
+      // that outline from the inline that was broken because it
+      // contained a block.  In that case, we don't want a really wide
+      // outline if the block inside the inline is narrow, so union the
+      // actual contents of the anonymous blocks.
+      nsIFrame *frameForArea = this;
+      do {
+        nsIAtom *pseudoType = frameForArea->StyleContext()->GetPseudo();
+        if (pseudoType != nsCSSAnonBoxes::mozAnonymousBlock &&
+            pseudoType != nsCSSAnonBoxes::mozAnonymousPositionedBlock)
+          break;
+        // If we're done, we really want it and all its later siblings.
+        frameForArea = frameForArea->GetFirstPrincipalChild();
+        NS_ASSERTION(frameForArea, "anonymous block with no children?");
+      } while (frameForArea);
+
+      // Find the union of the border boxes of all descendants, or in
+      // the block-in-inline case, all descendants we care about.
+      nsRect innerRect;
+      if (frameForArea == this) {
+        innerRect = bounds;
+        if (!bounds.IsEqualEdges(aOverflowAreas.VisualOverflow()) &&
+            !bounds.IsEqualEdges(aOverflowAreas.ScrollableOverflow())) {
+          UnionDescendantBorderBoxes(this, bounds);
+        }
+      } else {
+        for (; frameForArea; frameForArea = frameForArea->GetNextSibling()) {
+          nsRect r(UnionBorderBoxes(frameForArea) +
+                   frameForArea->GetOffsetTo(this));
+          innerRect.UnionRect(innerRect, r);
+        }
+      }
+
+      Properties().Set(nsIFrame::OutlineInnerRectProperty(),
+                       new nsRect(innerRect));
+
+      nscoord offset = outline->mOutlineOffset;
+      nscoord inflateBy = std::max(width + offset, 0);
+
+      // Keep this code (and the storing of properties just above) in
+      // sync with GetOutlineInnerRect in nsCSSRendering.cpp.
+      nsRect outerRect(innerRect);
+      outerRect.Inflate(inflateBy, inflateBy);
+
+      nsRect& vo = aOverflowAreas.VisualOverflow();
+      vo.UnionRectEdges(vo, outerRect);
+    }
+  }
+
   // Nothing in here should affect scrollable overflow.
   aOverflowAreas.VisualOverflow() =
     ComputeEffectsRect(this, aOverflowAreas.VisualOverflow(), aNewSize);
 
   // Absolute position clipping
   nsRect clipPropClipRect;
   bool hasClipPropClip = GetClipPropClipRect(disp, &clipPropClipRect, aNewSize);
   if (hasClipPropClip) {
diff --git a/layout/reftests/outline/outline-and-box-shadow-ref.html b/layout/reftests/outline/outline-and-box-shadow-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/outline/outline-and-box-shadow-ref.html
@@ -0,0 +1,12 @@
+<!DOCTYPE HTML>
+<title>outline and box-shadow</title>
+<style>
+html, body { margin: 0; padding: 0 }
+p {
+  margin: 48px;
+  border: 2px solid blue;
+  background: yellow; color: black;
+  box-shadow: 10px 10px 10px 0px black;
+}
+</style>
+<p>The outline should be adjacent to the background.</p>
diff --git a/layout/reftests/outline/outline-and-box-shadow.html b/layout/reftests/outline/outline-and-box-shadow.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/outline/outline-and-box-shadow.html
@@ -0,0 +1,12 @@
+<!DOCTYPE HTML>
+<title>outline and box-shadow</title>
+<style>
+html, body { margin: 0; padding: 0 }
+p {
+  margin: 50px;
+  outline: 2px solid blue;
+  background: yellow; color: black;
+  box-shadow: 10px 10px 10px 2px black;
+}
+</style>
+<p>The outline should be adjacent to the background.</p>
diff --git a/layout/reftests/outline/reftest.list b/layout/reftests/outline/reftest.list
new file mode 100644
--- /dev/null
+++ b/layout/reftests/outline/reftest.list
@@ -0,0 +1,1 @@
+== outline-and-box-shadow.html outline-and-box-shadow-ref.html
diff --git a/layout/reftests/reftest.list b/layout/reftests/reftest.list
--- a/layout/reftests/reftest.list
+++ b/layout/reftests/reftest.list
@@ -211,16 +211,18 @@ skip-if(B2G) include margin-collapsing/r
 skip-if(B2G) include marquee/reftest.list
 
 # native-theme/
 skip-if(Android||B2G) include native-theme/reftest.list
 
 # netwerk/
 skip-if(B2G) include ../../netwerk/test/reftest/reftest.list
 
+include outline/reftest.list
+
 # object/
 skip-if(B2G) include object/reftest.list
 
 # ogg-video/
 include ogg-video/reftest.list
 
 # webm-video/
 include webm-video/reftest.list
