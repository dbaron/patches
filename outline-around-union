From: L. David Baron <dbaron@dbaron.org>

Bug 480888 patch 4:  Draw outline around the union of border boxes, SVG, and text, rather than the visual overflow area.

At the same time, move the handling of outlines on inlines that contain
blocks earlier, so that we factor it into the stored frame property (and
thus have the stored frame property) and so that we include it
accurately in the overflow calculation.

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -570,20 +570,18 @@ nsCSSRendering::PaintBorderWithStyleBord
 
 static nsRect
 GetOutlineInnerRect(nsIFrame* aFrame)
 {
   nsRect* savedOutlineInnerRect = static_cast<nsRect*>
     (aFrame->Properties().Get(nsIFrame::OutlineInnerRectProperty()));
   if (savedOutlineInnerRect)
     return *savedOutlineInnerRect;
-  // FIXME (bug 599652): We probably want something narrower than either
-  // overflow rect here, but for now use the visual overflow in order to
-  // be consistent with ComputeEffectsRect in nsFrame.cpp.
-  return aFrame->GetVisualOverflowRect();
+  NS_NOTREACHED("we should have saved a frame property");
+  return nsRect(nsPoint(0, 0), aFrame->GetSize());
 }
 
 void
 nsCSSRendering::PaintOutline(nsPresContext* aPresContext,
                              nsRenderingContext& aRenderingContext,
                              nsIFrame* aForFrame,
                              const nsRect& aDirtyRect,
                              const nsRect& aBorderArea,
@@ -603,48 +601,17 @@ nsCSSRendering::PaintOutline(nsPresConte
   }
 
   nsIFrame* bgFrame = nsCSSRendering::FindNonTransparentBackgroundFrame
     (aForFrame, false);
   nsStyleContext* bgContext = bgFrame->StyleContext();
   nscolor bgColor =
     bgContext->GetVisitedDependentColor(eCSSProperty_background_color);
 
-  // When the outline property is set on :-moz-anonymous-block or
-  // :-moz-anonyomus-positioned-block pseudo-elements, it inherited that
-  // outline from the inline that was broken because it contained a
-  // block.  In that case, we don't want a really wide outline if the
-  // block inside the inline is narrow, so union the actual contents of
-  // the anonymous blocks.
-  nsIFrame *frameForArea = aForFrame;
-  do {
-    nsIAtom *pseudoType = frameForArea->StyleContext()->GetPseudo();
-    if (pseudoType != nsCSSAnonBoxes::mozAnonymousBlock &&
-        pseudoType != nsCSSAnonBoxes::mozAnonymousPositionedBlock)
-      break;
-    // If we're done, we really want it and all its later siblings.
-    frameForArea = frameForArea->GetFirstPrincipalChild();
-    NS_ASSERTION(frameForArea, "anonymous block with no children?");
-  } while (frameForArea);
-  nsRect innerRect; // relative to aBorderArea.TopLeft()
-  if (frameForArea == aForFrame) {
-    innerRect = GetOutlineInnerRect(aForFrame);
-  } else {
-    for (; frameForArea; frameForArea = frameForArea->GetNextSibling()) {
-      // The outline has already been included in aForFrame's overflow
-      // area, but not in those of its descendants, so we have to
-      // include it.  Otherwise we'll end up drawing the outline inside
-      // the border.
-      nsRect r(GetOutlineInnerRect(frameForArea) +
-               frameForArea->GetOffsetTo(aForFrame));
-      innerRect.UnionRect(innerRect, r);
-    }
-  }
-
-  innerRect += aBorderArea.TopLeft();
+  nsRect innerRect = GetOutlineInnerRect(aForFrame) + aBorderArea.TopLeft();
   nscoord offset = ourOutline->mOutlineOffset;
   innerRect.Inflate(offset, offset);
   // If the dirty rect is completely inside the border area (e.g., only the
   // content is being painted), then we can skip out now
   // XXX this isn't exactly true for rounded borders, where the inside curves may
   // encroach into the content area.  A safer calculation would be to
   // shorten insideRect by the radius one each side before performing this test.
   if (innerRect.Contains(aDirtyRect))
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -4971,37 +4971,16 @@ ComputeEffectsRect(nsIFrame* aFrame, con
       r = nsSVGUtils::GetPostFilterVisualOverflowRect(aFrame, aOverflowRect);
     }
     return r;
   }
 
   // box-shadow
   r.UnionRect(r, nsLayoutUtils::GetBoxShadowRectForFrame(aFrame, aNewSize));
 
-  const nsStyleOutline* outline = aFrame->StyleOutline();
-  uint8_t outlineStyle = outline->GetOutlineStyle();
-  if (outlineStyle != NS_STYLE_BORDER_STYLE_NONE) {
-    nscoord width;
-    DebugOnly<bool> result = outline->GetOutlineWidth(width);
-    NS_ASSERTION(result, "GetOutlineWidth had no cached outline width");
-    if (width > 0) {
-      aFrame->Properties().
-        Set(nsIFrame::OutlineInnerRectProperty(), new nsRect(r));
-
-      nscoord offset = outline->mOutlineOffset;
-      nscoord inflateBy = std::max(width + offset, 0);
-      // FIXME (bug 599652): We probably want outline to be drawn around
-      // something smaller than the visual overflow rect (perhaps the
-      // scrollable overflow rect is correct).  When we change that, we
-      // need to keep this code (and the storing of properties just
-      // above) in sync with GetOutlineInnerRect in nsCSSRendering.cpp.
-      r.Inflate(inflateBy, inflateBy);
-    }
-  }
-
   // border-image-outset.
   // We need to include border-image-outset because it can cause the
   // border image to be drawn beyond the border box.
 
   // (1) It's important we not check whether there's a border-image
   //     since the style hint for a change in border image doesn't cause
   //     reflow, and that's probably more important than optimizing the
   //     overflow areas for the silly case of border-image-outset without
@@ -6849,16 +6828,156 @@ nsIFrame::SetOverflowAreas(const nsOverf
 
 inline bool
 IsInlineFrame(nsIFrame *aFrame)
 {
   nsIAtom *type = aFrame->GetType();
   return type == nsGkAtoms::inlineFrame;
 }
 
+/**
+ * Compute the union of the border boxes of aFrame and its descendants,
+ * in aFrame's post-transform coordinate space.
+ */
+static nsRect
+UnionBorderBoxes(nsIFrame* aFrame, const nsSize* aSizeOverride = nullptr)
+{
+  const nsRect bounds(nsPoint(0, 0),
+                      aSizeOverride ? *aSizeOverride : aFrame->GetSize());
+  nsRect u(bounds);
+
+  // Only iterate through the children if the overflow areas suggest
+  // that we might need to.
+  if (!u.IsEqualEdges(aFrame->GetVisualOverflowRect()) &&
+      !u.IsEqualEdges(aFrame->GetScrollableOverflowRect()) &&
+      aFrame->GetType() != nsGkAtoms::svgOuterSVGFrame) {
+
+    // Iterate over all children except pop-ups.
+    const nsIFrame::ChildListIDs skip(nsIFrame::kPopupList |
+                                      nsIFrame::kSelectPopupList);
+    for (nsIFrame::ChildListIterator childLists(aFrame);
+         !childLists.IsDone(); childLists.Next()) {
+      if (skip.Contains(childLists.CurrentID())) {
+        continue;
+      }
+
+      nsFrameList children = childLists.CurrentList();
+      for (nsFrameList::Enumerator e(children); !e.AtEnd(); e.Next()) {
+        nsIFrame* child = e.get();
+        nsRect childRect = UnionBorderBoxes(child) + child->GetPosition();
+        // Note that we transform each child separately according to
+        // aFrame's transform, and then union, which gives a different
+        // (smaller) result from unioning and then transforming the
+        // union.  This doesn't match the way we handle overflow areas
+        // with 2-D transforms, though it does match the way we handle
+        // overflow areas in preserve-3d 3-D scenes.
+        if (!child->Preserves3D()) {
+          childRect = nsDisplayTransform::TransformRect(childRect, aFrame,
+                                                        nsPoint(0, 0), &bounds);
+        }
+        u.UnionRectEdges(u, childRect);
+      }
+    }
+  }
+
+  return u;
+}
+
+static void
+ComputeAndIncludeOutlineArea(nsIFrame* aFrame, nsOverflowAreas& aOverflowAreas,
+                             const nsSize& aNewSize)
+{
+  const nsStyleOutline* outline = aFrame->StyleOutline();
+  if (outline->GetOutlineStyle() != NS_STYLE_BORDER_STYLE_NONE) {
+    nscoord width;
+    DebugOnly<bool> result = outline->GetOutlineWidth(width);
+    NS_ASSERTION(result, "GetOutlineWidth had no cached outline width");
+    if (width > 0) {
+      // When the outline property is set on :-moz-anonymous-block or
+      // :-moz-anonymous-positioned-block pseudo-elements, it inherited
+      // that outline from the inline that was broken because it
+      // contained a block.  In that case, we don't want a really wide
+      // outline if the block inside the inline is narrow, so union the
+      // actual contents of the anonymous blocks.
+      nsIFrame *frameForArea = aFrame;
+      do {
+        nsIAtom *pseudoType = frameForArea->StyleContext()->GetPseudo();
+        if (pseudoType != nsCSSAnonBoxes::mozAnonymousBlock &&
+            pseudoType != nsCSSAnonBoxes::mozAnonymousPositionedBlock)
+          break;
+        // If we're done, we really want it and all its later siblings.
+        frameForArea = frameForArea->GetFirstPrincipalChild();
+        NS_ASSERTION(frameForArea, "anonymous block with no children?");
+      } while (frameForArea);
+
+      const nsRect bounds(nsPoint(0, 0), aNewSize);
+
+      // Find the union of the border boxes of all descendants, or in
+      // the block-in-inline case, all descendants we care about.
+      //
+      // Note that the interesting perspective-related cases are taken
+      // care of by the code that handles those issues for overflow
+      // calling FinishAndStoreOverflow again, which in turn calls this
+      // function again.  We still need to deal with preserve-3d a bit.
+      nsRect innerRect;
+      if (frameForArea == aFrame) {
+        innerRect = UnionBorderBoxes(aFrame, &aNewSize);
+      } else {
+        for (; frameForArea; frameForArea = frameForArea->GetNextSibling()) {
+          nsRect r(UnionBorderBoxes(frameForArea) +
+                   frameForArea->GetOffsetTo(aFrame));
+
+          // Adjust for transforms up to aFrame's post-transform
+          // coordinate space; see comment in UnionBorderBoxes.
+          for (nsIFrame* f = frameForArea; f != aFrame; f = f->GetParent()) {
+            if (!f->Preserves3D()) {
+              r = nsDisplayTransform::TransformRect(r, f->GetParent(),
+                                                    nsPoint(0, 0),
+                                                    f == aFrame ? &bounds
+                                                                : nullptr);
+            }
+          }
+
+          innerRect.UnionRect(innerRect, r);
+        }
+      }
+
+      // Now we have innerRect in aFrame's post-transform coordinate
+      // space (which might include the transforms up to the root of the
+      // 3-d scene), but we want it back in aFrame's pre-transform
+      // coordinate space.
+      float factor = aFrame->PresContext()->AppUnitsPerDevPixel()
+      gfx3DMatrix matrix = nsDisplayTransform::GetResultingTransformMatrix(
+                             aFrame, nsPoint(0, 0), factor, &bounds);
+      if (matrix.IsSingular()) {
+        // Who cares?  We're in a frame that's never going to paint
+        // anything, since it's in a singular transform.
+      } else {
+        matrix.Invert();
+        innerRect =
+          nsLayoutUtils::MatrixTransformRect(innerRect, matrix, factor);
+      }
+
+      aFrame->Properties().Set(nsIFrame::OutlineInnerRectProperty(),
+                               new nsRect(innerRect));
+
+      nscoord offset = outline->mOutlineOffset;
+      nscoord inflateBy = std::max(width + offset, 0);
+
+      // Keep this code (and the storing of properties just above) in
+      // sync with GetOutlineInnerRect in nsCSSRendering.cpp.
+      nsRect outerRect(innerRect);
+      outerRect.Inflate(inflateBy, inflateBy);
+
+      nsRect& vo = aOverflowAreas.VisualOverflow();
+      vo.UnionRectEdges(vo, outerRect);
+    }
+  }
+}
+
 bool
 nsIFrame::FinishAndStoreOverflow(nsOverflowAreas& aOverflowAreas,
                                  nsSize aNewSize, nsSize* aOldSize)
 {
   NS_ASSERTION(FrameMaintainsOverflow(this),
                "Don't call - overflow rects not maintained on these SVG frames");
 
   nsRect bounds(nsPoint(0, 0), aNewSize);
@@ -6928,16 +7047,18 @@ nsIFrame::FinishAndStoreOverflow(nsOverf
     if (presContext->GetTheme()->
           GetWidgetOverflow(presContext->DeviceContext(), this,
                             disp->mAppearance, &r)) {
       nsRect& vo = aOverflowAreas.VisualOverflow();
       vo.UnionRectEdges(vo, r);
     }
   }
 
+  ComputeAndIncludeOutlineArea(this, aOverflowAreas, aNewSize);
+
   // Nothing in here should affect scrollable overflow.
   aOverflowAreas.VisualOverflow() =
     ComputeEffectsRect(this, aOverflowAreas.VisualOverflow(), aNewSize);
 
   // Absolute position clipping
   nsRect clipPropClipRect;
   bool hasClipPropClip = GetClipPropClipRect(disp, &clipPropClipRect, aNewSize);
   if (hasClipPropClip) {
diff --git a/layout/reftests/outline/outline-and-3d-transform-1-ref.html b/layout/reftests/outline/outline-and-3d-transform-1-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/outline/outline-and-3d-transform-1-ref.html
@@ -0,0 +1,42 @@
+<!DOCTYPE HTML>
+<title>Testcase for outline around 3-D transform</title>
+<style>
+
+html, body { margin: 0; padding: 0; border: none }
+
+div {
+  width: 100px;
+  height: 100px;
+}
+
+body > div {
+  margin-top: 200px;
+  margin-left: 200px;
+  transform-style: flat;
+  position: relative;
+}
+
+body > div > div {
+  position: absolute; top: 0; left: 0;
+}
+
+body > div > div:nth-child(1) {
+  transform: rotateX(30deg);
+  transform-origin: 50% 50%;
+  background: rgba(255, 0, 255, 0.4);
+}
+
+body > div > div:nth-child(2) {
+  height: 50px; top: 25px;
+  background: rgba(0, 255, 255, 0.4);
+}
+
+body > div > div:nth-child(3) {
+  height: 150px; width: 150px; top: -25px; left: -25px;
+  background: rgba(255, 255, 0, 0.4);
+  outline: 2px dashed blue;
+}
+
+</style>
+
+<div><div></div><div></div><div></div></div>
diff --git a/layout/reftests/outline/outline-and-3d-transform-1.html b/layout/reftests/outline/outline-and-3d-transform-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/outline/outline-and-3d-transform-1.html
@@ -0,0 +1,42 @@
+<!DOCTYPE HTML>
+<title>Testcase for outline around 3-D transform</title>
+<style>
+
+html, body { margin: 0; padding: 0; border: none }
+
+div {
+  width: 100px;
+  height: 100px;
+}
+
+body > div {
+  margin-top: 200px;
+  margin-left: 200px;
+  transform-style: flat;
+  outline: 2px dashed blue;
+}
+
+body > div > div {
+  transform: rotateX(30deg);
+  transform-origin: 50% 50%;
+  transform-style: preserve-3d;
+  background: rgba(255, 0, 255, 0.4);
+}
+
+body > div > div > div {
+  transform: rotateX(30deg);
+  transform-origin: 50% 50%;
+  transform-style: preserve-3d;
+  background: rgba(0, 255, 255, 0.4);
+}
+
+body > div > div > div > div {
+  transform: scale(1.5, 3);
+  transform-origin: 50% 50%;
+  background: rgba(255, 255, 0, 0.4);
+}
+
+
+</style>
+
+<div><div><div><div></div></div></div></div>
diff --git a/layout/reftests/outline/outline-and-3d-transform-2-ref.html b/layout/reftests/outline/outline-and-3d-transform-2-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/outline/outline-and-3d-transform-2-ref.html
@@ -0,0 +1,36 @@
+<!DOCTYPE HTML>
+<title>Testcase for outline around 3-D transform</title>
+<style>
+
+html, body { margin: 0; padding: 0; border: none }
+
+div {
+  width: 100px;
+  height: 100px;
+}
+
+body > div {
+  margin-top: 200px;
+  margin-left: 200px;
+  transform-style: flat;
+  position: relative;
+}
+
+body > div > div {
+  position: absolute; top: 0; left: 0;
+}
+
+body > div > div:nth-child(1) {
+  height: 50px; top: 25px;
+  background: rgba(0, 255, 255, 0.4);
+}
+
+body > div > div:nth-child(2) {
+  height: 150px; width: 150px; top: -25px; left: -25px;
+  background: rgba(255, 255, 0, 0.4);
+  outline: 2px dashed blue;
+}
+
+</style>
+
+<div><div></div><div></div></div>
diff --git a/layout/reftests/outline/outline-and-3d-transform-2.html b/layout/reftests/outline/outline-and-3d-transform-2.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/outline/outline-and-3d-transform-2.html
@@ -0,0 +1,42 @@
+<!DOCTYPE HTML>
+<title>Testcase for outline around 3-D transform</title>
+<style>
+
+html, body { margin: 0; padding: 0; border: none }
+
+div {
+  width: 100px;
+  height: 100px;
+}
+
+body > div {
+  margin-top: 200px;
+  margin-left: 200px;
+  transform-style: flat;
+  outline: 2px dashed blue;
+}
+
+body > div > div {
+  transform: rotateX(90deg);
+  transform-origin: 50% 50%;
+  transform-style: preserve-3d;
+  background: rgba(255, 0, 255, 0.4);
+}
+
+body > div > div > div {
+  transform: rotateX(-30deg);
+  transform-origin: 50% 50%;
+  transform-style: preserve-3d;
+  background: rgba(0, 255, 255, 0.4);
+}
+
+body > div > div > div > div {
+  transform: scale(1.5, 3);
+  transform-origin: 50% 50%;
+  background: rgba(255, 255, 0, 0.4);
+}
+
+
+</style>
+
+<div><div><div><div></div></div></div></div>
diff --git a/layout/reftests/outline/outline-and-box-shadow-ref.html b/layout/reftests/outline/outline-and-box-shadow-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/outline/outline-and-box-shadow-ref.html
@@ -0,0 +1,13 @@
+<!DOCTYPE HTML>
+<title>outline and box-shadow</title>
+<style>
+html, body { margin: 0; padding: 0 }
+p {
+  margin: 48px;
+  border: 2px solid blue;
+  padding: 5px; /* ensure no font overhang */
+  background: yellow; color: black;
+  box-shadow: 10px 10px 10px 0px black;
+}
+</style>
+<p>The outline should be adjacent to the background.</p>
diff --git a/layout/reftests/outline/outline-and-box-shadow.html b/layout/reftests/outline/outline-and-box-shadow.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/outline/outline-and-box-shadow.html
@@ -0,0 +1,13 @@
+<!DOCTYPE HTML>
+<title>outline and box-shadow</title>
+<style>
+html, body { margin: 0; padding: 0 }
+p {
+  margin: 50px;
+  outline: 2px solid blue;
+  padding: 5px; /* ensure no font overhang */
+  background: yellow; color: black;
+  box-shadow: 10px 10px 10px 2px black;
+}
+</style>
+<p>The outline should be adjacent to the background.</p>
diff --git a/layout/reftests/outline/reftest.list b/layout/reftests/outline/reftest.list
new file mode 100644
--- /dev/null
+++ b/layout/reftests/outline/reftest.list
@@ -0,0 +1,3 @@
+== outline-and-box-shadow.html outline-and-box-shadow-ref.html
+== outline-and-3d-transform-1.html outline-and-3d-transform-1-ref.html
+== outline-and-3d-transform-2.html outline-and-3d-transform-2-ref.html
diff --git a/layout/reftests/reftest.list b/layout/reftests/reftest.list
--- a/layout/reftests/reftest.list
+++ b/layout/reftests/reftest.list
@@ -214,16 +214,18 @@ skip-if(B2G) include margin-collapsing/r
 skip-if(B2G) include marquee/reftest.list
 
 # native-theme/
 skip-if(Android||B2G) include native-theme/reftest.list
 
 # netwerk/
 skip-if(B2G) include ../../netwerk/test/reftest/reftest.list
 
+include outline/reftest.list
+
 # object/
 skip-if(B2G) include object/reftest.list
 
 # ogg-video/
 include ogg-video/reftest.list
 
 # webm-video/
 include webm-video/reftest.list
