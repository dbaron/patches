From: L. David Baron <dbaron@dbaron.org>

Bug 1133439 patch 2 - Split eRestyle_StyleAttribute into eRestyle_StyleAttribute and eRestyle_StyleAttributeAnimations.

diff --git a/dom/base/Element.cpp b/dom/base/Element.cpp
--- a/dom/base/Element.cpp
+++ b/dom/base/Element.cpp
@@ -1798,17 +1798,22 @@ Element::SetSMILOverrideStyleRule(css::S
   if (aNotify) {
     nsIDocument* doc = GetComposedDoc();
     // Only need to request a restyle if we're in a document.  (We might not
     // be in a document, if we're clearing animation effects on a target node
     // that's been detached since the previous animation sample.)
     if (doc) {
       nsCOMPtr<nsIPresShell> shell = doc->GetShell();
       if (shell) {
-        shell->RestyleForAnimation(this, eRestyle_StyleAttribute);
+        // REVIEW:  Pass both eRestyle_StyleAttribute and
+        // eRestyle_StyleAttribute_Animations since we don't know if
+        // this style represents only the ticking of an existing
+        // animation or whether it's a new or changed animation.
+        shell->RestyleForAnimation(this, eRestyle_StyleAttribute |
+                                         eRestyle_StyleAttribute_Animations);
       }
     }
   }
 
   return NS_OK;
 }
 
 bool
diff --git a/dom/smil/nsSMILAnimationController.cpp b/dom/smil/nsSMILAnimationController.cpp
--- a/dom/smil/nsSMILAnimationController.cpp
+++ b/dom/smil/nsSMILAnimationController.cpp
@@ -827,17 +827,17 @@ nsSMILAnimationController::AddStyleUpdat
     // Something's wrong/missing about animation's target; skip this animation
     return PL_DHASH_NEXT;
   }
 
   // mIsCSS true means that the rules are the ones returned from
   // Element::GetSMILOverrideStyleRule (via nsSMILCSSProperty objects),
   // and mIsCSS false means the rules are nsSMILMappedAttribute objects
   // returned from nsSVGElement::GetAnimatedContentStyleRule.
-  nsRestyleHint rshint = key.mIsCSS ? eRestyle_StyleAttribute
+  nsRestyleHint rshint = key.mIsCSS ? eRestyle_StyleAttribute_Animations
                                     : eRestyle_SVGAttrAnimations;
   restyleTracker->AddPendingRestyle(key.mElement, rshint, nsChangeHint(0));
 
   return PL_DHASH_NEXT;
 }
 
 void
 nsSMILAnimationController::AddStyleUpdatesTo(RestyleTracker& aTracker)
diff --git a/layout/base/nsChangeHint.h b/layout/base/nsChangeHint.h
--- a/layout/base/nsChangeHint.h
+++ b/layout/base/nsChangeHint.h
@@ -343,34 +343,40 @@ enum nsRestyleHint {
 
   // Replace the style data coming from inline style without updating
   // any other style data.  If a new style context results, update style
   // contexts on the descendants.  (Irrelevant if eRestyle_Self or
   // eRestyle_Subtree is also set, since those imply a superset of the
   // work.)  Supported only for element style contexts and not for
   // pseudo-elements or anonymous boxes, on which it converts to
   // eRestyle_Self.
+  // If the change is for the advance of a declarative animation, use
+  // the value below instead.
   eRestyle_StyleAttribute = (1<<6),
 
+  // Same as eRestyle_StyleAttribute, but for when the change results
+  // from the advance of a declarative animation.
+  eRestyle_StyleAttribute_Animations = (1<<7),
+
   // Continue the restyling process to the current frame's children even
   // if this frame's restyling resulted in no style changes.
-  eRestyle_Force = (1<<7),
+  eRestyle_Force = (1<<8),
 
   // Continue the restyling process to all of the current frame's
   // descendants, even if any frame's restyling resulted in no style
   // changes.  (Implies eRestyle_Force.)  Note that this is weaker than
   // eRestyle_Subtree, which makes us rerun selector matching on all
   // descendants rather than just continuing the restyling process.
-  eRestyle_ForceDescendants = (1<<8),
+  eRestyle_ForceDescendants = (1<<9),
 
   // Useful unions:
   eRestyle_AllHintsWithAnimations = eRestyle_CSSTransitions |
                                     eRestyle_CSSAnimations |
                                     eRestyle_SVGAttrAnimations |
-                                    eRestyle_StyleAttribute,
+                                    eRestyle_StyleAttribute_Animations,
 };
 
 // The functions below need an integral type to cast to to avoid
 // infinite recursion.
 typedef decltype(nsRestyleHint(0) + nsRestyleHint(0)) nsRestyleHint_size_t;
 
 inline nsRestyleHint MOZ_CONSTEXPR
 operator|(nsRestyleHint aLeft, nsRestyleHint aRight)
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1373,22 +1373,24 @@ struct CascadeLevel {
 
 static const CascadeLevel gCascadeLevels[] = {
   { nsStyleSet::eAgentSheet,            false, false, nsRestyleHint(0) },
   { nsStyleSet::eUserSheet,             false, false, nsRestyleHint(0) },
   { nsStyleSet::ePresHintSheet,         false, false, nsRestyleHint(0) },
   { nsStyleSet::eSVGAttrAnimationSheet, false, false, eRestyle_SVGAttrAnimations },
   { nsStyleSet::eDocSheet,              false, false, nsRestyleHint(0) },
   { nsStyleSet::eScopedDocSheet,        false, false, nsRestyleHint(0) },
-  { nsStyleSet::eStyleAttrSheet,        false, true,  eRestyle_StyleAttribute },
+  { nsStyleSet::eStyleAttrSheet,        false, true,  eRestyle_StyleAttribute |
+                                                      eRestyle_StyleAttribute_Animations },
   { nsStyleSet::eOverrideSheet,         false, false, nsRestyleHint(0) },
   { nsStyleSet::eAnimationSheet,        false, false, eRestyle_CSSAnimations },
   { nsStyleSet::eScopedDocSheet,        true,  false, nsRestyleHint(0) },
   { nsStyleSet::eDocSheet,              true,  false, nsRestyleHint(0) },
-  { nsStyleSet::eStyleAttrSheet,        true,  false, eRestyle_StyleAttribute },
+  { nsStyleSet::eStyleAttrSheet,        true,  false, eRestyle_StyleAttribute |
+                                                      eRestyle_StyleAttribute_Animations },
   { nsStyleSet::eOverrideSheet,         true,  false, nsRestyleHint(0) },
   { nsStyleSet::eUserSheet,             true,  false, nsRestyleHint(0) },
   { nsStyleSet::eAgentSheet,            true,  false, nsRestyleHint(0) },
   { nsStyleSet::eTransitionSheet,       false, false, eRestyle_CSSTransitions },
 };
 
 nsRuleNode*
 nsStyleSet::RuleNodeWithReplacement(Element* aElement,
@@ -1404,16 +1406,17 @@ nsStyleSet::RuleNodeWithReplacement(Elem
               !(nsCSSPseudoElements::PseudoElementSupportsStyleAttribute(aPseudoType) ||
                 nsCSSPseudoElements::PseudoElementSupportsUserActionState(aPseudoType))),
              "should have aPseudoElement only for certain pseudo elements");
 
   NS_ABORT_IF_FALSE(!(aReplacements & ~(eRestyle_CSSTransitions |
                                         eRestyle_CSSAnimations |
                                         eRestyle_SVGAttrAnimations |
                                         eRestyle_StyleAttribute |
+                                        eRestyle_StyleAttribute_Animations |
                                         eRestyle_Force |
                                         eRestyle_ForceDescendants)),
                     // FIXME: Once bug 979133 lands we'll have a better
                     // way to print these.
                     nsPrintfCString("unexpected replacement bits 0x%" PRIX32,
                                     uint32_t(aReplacements)).get());
 
   // FIXME (perf): This should probably not rebuild the whole path, but
@@ -1447,52 +1450,52 @@ nsStyleSet::RuleNodeWithReplacement(Elem
        level != levelEnd; ++level) {
 
     bool doReplace = level->mLevelReplacementHint & aReplacements;
 
     ruleWalker.SetLevel(level->mLevel, level->mIsImportant,
                         level->mCheckForImportantRules && doReplace);
 
     if (doReplace) {
-      switch (level->mLevelReplacementHint) {
-        case eRestyle_CSSAnimations: {
+      switch (level->mLevel) {
+        case nsStyleSet::eAnimationSheet: {
           if (aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ||
               aPseudoType == nsCSSPseudoElements::ePseudo_before ||
               aPseudoType == nsCSSPseudoElements::ePseudo_after) {
             nsIStyleRule* rule = PresContext()->AnimationManager()->
               GetAnimationRule(aElement, aPseudoType);
             if (rule) {
               ruleWalker.ForwardOnPossiblyCSSRule(rule);
             }
           }
           break;
         }
-        case eRestyle_CSSTransitions: {
+        case nsStyleSet::eTransitionSheet: {
           if (aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ||
               aPseudoType == nsCSSPseudoElements::ePseudo_before ||
               aPseudoType == nsCSSPseudoElements::ePseudo_after) {
             nsIStyleRule* rule = PresContext()->TransitionManager()->
               GetAnimationRule(aElement, aPseudoType);
             if (rule) {
               ruleWalker.ForwardOnPossiblyCSSRule(rule);
             }
           }
           break;
         }
-        case eRestyle_SVGAttrAnimations: {
+        case nsStyleSet::eSVGAttrAnimationSheet: {
           SVGAttrAnimationRuleProcessor* ruleProcessor =
             static_cast<SVGAttrAnimationRuleProcessor*>(
               mRuleProcessors[eSVGAttrAnimationSheet].get());
           if (ruleProcessor &&
               aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
             ruleProcessor->ElementRulesMatching(aElement, &ruleWalker);
           }
           break;
         }
-        case eRestyle_StyleAttribute: {
+        case nsStyleSet::eStyleAttrSheet: {
           if (!level->mIsImportant) {
             // First time through, we handle the non-!important rule.
             nsHTMLCSSStyleSheet* ruleProcessor =
               static_cast<nsHTMLCSSStyleSheet*>(
                 mRuleProcessors[eStyleAttrSheet].get());
             if (ruleProcessor) {
               lastScopedRN = ruleWalker.CurrentNode();
               if (aPseudoType ==
