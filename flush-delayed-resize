Flush view manager's delayed resize when flushing layout.  (Bug 453896)

diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -4576,16 +4576,17 @@ PresShell::DoFlushPendingNotifications(m
     }
 
     // There might be more pending constructors now, but we're not going to
     // worry about them.  They can't be triggered during reflow, so we should
     // be good.
     
     if (aType >= Flush_Layout && !mIsDestroying) {
       mFrameConstructor->RecalcQuotesAndCounters();
+      mViewManager->FlushDelayedResize();
       ProcessReflowCommands(aInterruptibleReflow);
     }
 
     PRUint32 updateFlags = NS_VMREFRESH_NO_SYNC;
     if (aType >= Flush_Display) {
       // Flushing paints, so perform the invalidates and drawing
       // immediately
       updateFlags = NS_VMREFRESH_IMMEDIATE;
diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -90,16 +90,17 @@ _TEST_FILES =	test_acid3_test46.html \
 		test_bug389464.html \
 		test_bug391034.html \
 		test_bug391221.html \
 		test_bug397427.html \
 		test_bug401046.html \
 		test_bug405818.html \
 		test_bug412901.html \
 		test_bug437915.html \
+		test_bug453896_deck.html \
 		test_cascade.html \
 		test_compute_data_with_start_struct.html \
 		test_css_eof_handling.html \
 		test_dont_use_document_colors.html \
 		test_font_face_parser.html \
 		test_for_expect_end_property.html \
 		test_inherit_computation.html \
 		test_inherit_storage.html \
@@ -132,13 +133,14 @@ _TEST_FILES =	test_acid3_test46.html \
 		redirect-3.css^headers^ \
 		post-redirect-3.css \
 		xbl_bindings.xml \
 		empty.html \
 		media_queries_iframe.html \
 		media_queries_dynamic_xbl_binding.xml \
 		media_queries_dynamic_xbl_iframe.html \
 		media_queries_dynamic_xbl_style.css \
+		bug453896_iframe.html \
 		$(NULL)
 
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
diff --git a/layout/style/test/bug453896_iframe.html b/layout/style/test/bug453896_iframe.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/bug453896_iframe.html
@@ -0,0 +1,68 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
+  "http://www.w3.org/TR/html4/strict.dtd">
+<html lang="en-US">
+<head>
+  <title>Bug 453896 Test middle frame</title>
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta http-equiv="Content-Style-Type" content="text/css">
+  <script type="text/javascript">
+
+function run(test_window)
+{
+  var subdoc = document.getElementById("subdoc").contentDocument;
+  var subwin = document.getElementById("subdoc").contentWindow;
+  var style = subdoc.getElementById("style");
+  var iframe_style = document.getElementById("subdoc").style;
+  var body_cs = subdoc.defaultView.getComputedStyle(subdoc.body, "");
+
+  function query_applies(q) {
+    style.setAttribute("media", q);
+    return body_cs.getPropertyValue("text-decoration") == "underline";
+  }
+
+  function should_apply(q) {
+    test_window.ok(query_applies(q), q + " should apply");
+  }
+
+  function should_not_apply(q) {
+    test_window.ok(!query_applies(q), q + " should not apply");
+  }
+
+  // in this test, assume the common underlying implementation is correct
+  let width_val = 157; // pick two not-too-round numbers
+  let height_val = 182;
+  iframe_style.width = width_val + "px";
+  iframe_style.height = height_val + "px";
+  for (let [feature, value] in
+         Iterator({ "width": width_val, "height": height_val })) {
+    should_apply("all and (" + feature + ": " + value + "px)");
+    should_not_apply("all and (" + feature + ": " + (value + 1) + "px)");
+    should_not_apply("all and (" + feature + ": " + (value - 1) + "px)");
+  }
+
+  iframe_style.width = "0";
+  should_apply("all and (height)");
+  should_not_apply("all and (width)");
+  iframe_style.height = "0";
+  should_not_apply("all and (height)");
+  should_not_apply("all and (width)");
+  should_apply("all and (device-height)");
+  should_apply("all and (device-width)");
+  iframe_style.width = width_val + "px";
+  should_not_apply("all and (height)");
+  should_apply("all and (width)");
+  iframe_style.height = height_val + "px";
+  should_apply("all and (height)");
+  should_apply("all and (width)");
+
+  test_window.SimpleTest.finish();
+}
+
+  </script>
+</head>
+<body>
+
+<iframe id="subdoc" src="media_queries_iframe.html"></iframe>
+
+</body>
+</html>
diff --git a/layout/style/test/test_bug453896_deck.html b/layout/style/test/test_bug453896_deck.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_bug453896_deck.html
@@ -0,0 +1,42 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=453896
+-->
+<head>
+  <title>Test for Bug 453896</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body onload="run()">
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=453896">Mozilla Bug 453896</a>
+<div id="display">
+
+<div style="display:-moz-deck; height: 300px; width: 300px;">
+  <iframe src="about:blank"></iframe>
+  <iframe id="subdoc" src="bug453896_iframe.html"></iframe>
+  <iframe src="about:blank"></iframe>
+</div>
+
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 453896 **/
+
+function run()
+{
+  var iframe = document.getElementById("subdoc");
+  var subdoc = iframe.contentDocument;
+  var subwin = iframe.contentWindow;
+
+  subwin.run(window);
+}
+
+SimpleTest.waitForExplicitFinish();
+
+</script>
+</pre>
+</body>
+</html>
+
diff --git a/view/public/nsIViewManager.h b/view/public/nsIViewManager.h
--- a/view/public/nsIViewManager.h
+++ b/view/public/nsIViewManager.h
@@ -132,16 +132,21 @@ public:
   /**
    * Set the dimensions of the root window.
    * Called if the root window is resized. The dimensions are in
    * twips
    * @param aWidth of window in twips
    * @param aHeight of window in twips
    */
   NS_IMETHOD  SetWindowDimensions(nscoord aWidth, nscoord aHeight) = 0;
+
+  /**
+   * Do any resizes that are pending.
+   */
+  NS_IMETHOD  FlushDelayedResize() = 0;
 
   /**
    * Called to force a redrawing of any dirty areas.
    */
   // XXXbz why is this exposed?  Shouldn't update view batches handle this?
   // It's not like Composite() does what's expected inside a view update batch
   // anyway, since dirty areas may not have been invalidated on the widget yet
   // and widget changes may not have been propagated yet.  Maybe this should
diff --git a/view/src/nsViewManager.cpp b/view/src/nsViewManager.cpp
--- a/view/src/nsViewManager.cpp
+++ b/view/src/nsViewManager.cpp
@@ -370,16 +370,25 @@ NS_IMETHODIMP nsViewManager::SetWindowDi
     if (IsViewVisible(mRootView)) {
       mDelayedResize.SizeTo(NSCOORD_NONE, NSCOORD_NONE);
       DoSetWindowDimensions(aWidth, aHeight);
     } else {
       mDelayedResize.SizeTo(aWidth, aHeight);
     }
   }
 
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsViewManager::FlushDelayedResize()
+{
+  if (mDelayedResize != nsSize(NSCOORD_NONE, NSCOORD_NONE)) {
+    DoSetWindowDimensions(mDelayedResize.width, mDelayedResize.height);
+    mDelayedResize.SizeTo(NSCOORD_NONE, NSCOORD_NONE);
+  }
   return NS_OK;
 }
 
 static void ConvertNativeRegionToAppRegion(nsIRegion* aIn, nsRegion* aOut,
                                            nsIDeviceContext* context)
 {
   nsRegionRectSet* rects = nsnull;
   aIn->GetRects(&rects);
@@ -1068,19 +1077,17 @@ NS_IMETHODIMP nsViewManager::DispatchEve
           // have a delayed resize to handle.
           PRBool didResize = PR_FALSE;
           for (nsViewManager *vm = this; vm;
                vm = vm->mRootView->GetParent()
                       ? vm->mRootView->GetParent()->GetViewManager()
                       : nsnull) {
             if (vm->mDelayedResize != nsSize(NSCOORD_NONE, NSCOORD_NONE) &&
                 IsViewVisible(vm->mRootView)) {
-              vm->DoSetWindowDimensions(vm->mDelayedResize.width,
-                                        vm->mDelayedResize.height);
-              vm->mDelayedResize.SizeTo(NSCOORD_NONE, NSCOORD_NONE);
+              vm->FlushDelayedResize();
 
               // Paint later.
               vm->UpdateView(vm->mRootView, NS_VMREFRESH_NO_SYNC);
               didResize = PR_TRUE;
 
               // not sure if it's valid for us to claim that we
               // ignored this, but we're going to do so anyway, since
               // we didn't actually paint anything
diff --git a/view/src/nsViewManager.h b/view/src/nsViewManager.h
--- a/view/src/nsViewManager.h
+++ b/view/src/nsViewManager.h
@@ -118,16 +118,17 @@ public:
   NS_IMETHOD_(nsIScrollableView*) CreateScrollableView(const nsRect& aBounds,
                                                        const nsIView* aParent);
 
   NS_IMETHOD  GetRootView(nsIView *&aView);
   NS_IMETHOD  SetRootView(nsIView *aView);
 
   NS_IMETHOD  GetWindowDimensions(nscoord *width, nscoord *height);
   NS_IMETHOD  SetWindowDimensions(nscoord width, nscoord height);
+  NS_IMETHOD  FlushDelayedResize();
 
   NS_IMETHOD  Composite(void);
 
   NS_IMETHOD  UpdateView(nsIView *aView, PRUint32 aUpdateFlags);
   NS_IMETHOD  UpdateView(nsIView *aView, const nsRect &aRect, PRUint32 aUpdateFlags);
   NS_IMETHOD  UpdateAllViews(PRUint32 aUpdateFlags);
 
   NS_IMETHOD  DispatchEvent(nsGUIEvent *aEvent, nsEventStatus* aStatus);
