From: L. David Baron <dbaron@dbaron.org>

Make nsStyleSet use nsRuleWalker objects on the stack rather than in a member variable.  (Bug 492675)  r=bzbarsky

diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -79,17 +79,16 @@ static const nsStyleSet::sheetType gCSSS
   nsStyleSet::eAgentSheet,
   nsStyleSet::eUserSheet,
   nsStyleSet::eDocSheet,
   nsStyleSet::eOverrideSheet
 };
 
 nsStyleSet::nsStyleSet()
   : mRuleTree(nsnull),
-    mRuleWalker(nsnull),
     mUnusedRuleNodeCount(0),
     mBatching(0),
     mInShutdown(PR_FALSE),
     mAuthorStyleDisabled(PR_FALSE),
     mInReconstruct(PR_FALSE),
     mDirty(0)
 {
 }
@@ -109,59 +108,43 @@ nsStyleSet::Init(nsPresContext *aPresCon
   }
 
   mRuleTree = nsRuleNode::CreateRootNode(aPresContext);
   if (!mRuleTree) {
     mDefaultStyleData.Destroy(0, aPresContext);
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
-  mRuleWalker = new nsRuleWalker(mRuleTree);
-  if (!mRuleWalker) {
-    mRuleTree->Destroy();
-    mDefaultStyleData.Destroy(0, aPresContext);
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-
   return NS_OK;
 }
 
 nsresult
 nsStyleSet::BeginReconstruct()
 {
   NS_ASSERTION(!mInReconstruct, "Unmatched begin/end?");
   NS_ASSERTION(mRuleTree, "Reconstructing before first construction?");
 
   // Create a new rule tree root
   nsRuleNode* newTree =
     nsRuleNode::CreateRootNode(mRuleTree->GetPresContext());
   if (!newTree)
     return NS_ERROR_OUT_OF_MEMORY;
-  nsRuleWalker* ruleWalker = new nsRuleWalker(newTree);
-  if (!ruleWalker) {
+
+  // Save the old rule tree so we can destroy it later
+  if (!mOldRuleTrees.AppendElement(mRuleTree)) {
     newTree->Destroy();
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
-  // Save the old rule tree so we can destroy it later
-  if (!mOldRuleTrees.AppendElement(mRuleTree)) {
-    delete ruleWalker;
-    newTree->Destroy();
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-  // Delete mRuleWalker because it holds a reference to the rule tree root
-  delete mRuleWalker;
-
   // We need to keep mRoots so that the rule tree GC will only free the
   // rule trees that really aren't referenced anymore (which should be
   // all of them, if there are no bugs in reresolution code).
 
   mInReconstruct = PR_TRUE;
   mRuleTree = newTree;
-  mRuleWalker = ruleWalker;
 
   return NS_OK;
 }
 
 void
 nsStyleSet::EndReconstruct()
 {
   NS_ASSERTION(mInReconstruct, "Unmatched begin/end?");
@@ -432,47 +415,45 @@ EnumRulesMatching(nsIStyleRuleProcessor*
  * |GetContext| implements sharing of style contexts (not just the data
  * on the rule nodes) between siblings and cousins of the same
  * generation.  (It works for cousins of the same generation since
  * |aParentContext| could itself be a shared context.)
  */
 already_AddRefed<nsStyleContext>
 nsStyleSet::GetContext(nsPresContext* aPresContext, 
                        nsStyleContext* aParentContext, 
+                       nsRuleNode* aRuleNode,
                        nsIAtom* aPseudoTag)
 {
   nsStyleContext* result = nsnull;
-  nsRuleNode* ruleNode = mRuleWalker->GetCurrentNode();
-  // Must reset before NS_NewStyleContext, since that could cause more
-  // rule matching (see stack in bug 513741).
-  mRuleWalker->Reset();
       
   if (aParentContext)
-    result = aParentContext->FindChildWithRules(aPseudoTag, ruleNode).get();
+    result = aParentContext->FindChildWithRules(aPseudoTag, aRuleNode).get();
 
 #ifdef NOISY_DEBUG
   if (result)
     fprintf(stdout, "--- SharedSC %d ---\n", ++gSharedCount);
   else
     fprintf(stdout, "+++ NewSC %d +++\n", ++gNewCount);
 #endif
 
   if (!result) {
-    result = NS_NewStyleContext(aParentContext, aPseudoTag, ruleNode,
+    result = NS_NewStyleContext(aParentContext, aPseudoTag, aRuleNode,
                                 aPresContext).get();
     if (!aParentContext && result)
       mRoots.AppendElement(result);
   }
 
   return result;
 }
 
 void
 nsStyleSet::AddImportantRules(nsRuleNode* aCurrLevelNode,
-                              nsRuleNode* aLastPrevLevelNode)
+                              nsRuleNode* aLastPrevLevelNode,
+                              nsRuleWalker* aRuleWalker)
 {
   if (!aCurrLevelNode)
     return;
 
   nsAutoTArray<nsCOMPtr<nsIStyleRule>, 16> importantRules;
   for (nsRuleNode *node = aCurrLevelNode; node != aLastPrevLevelNode;
        node = node->GetParent()) {
     nsIStyleRule *rule = node->GetRule();
@@ -480,17 +461,17 @@ nsStyleSet::AddImportantRules(nsRuleNode
     if (cssRule) {
       nsCOMPtr<nsIStyleRule> impRule = cssRule->GetImportantRule();
       if (impRule)
         importantRules.AppendElement(impRule);
     }
   }
 
   for (PRUint32 i = importantRules.Length(); i-- != 0; ) {
-    mRuleWalker->Forward(importantRules[i]);
+    aRuleWalker->Forward(importantRules[i]);
   }
 }
 
 #ifdef DEBUG
 void
 nsStyleSet::AssertNoImportantRules(nsRuleNode* aCurrLevelNode,
                                    nsRuleNode* aLastPrevLevelNode)
 {
@@ -522,17 +503,17 @@ nsStyleSet::AssertNoCSSRules(nsRuleNode*
     NS_ASSERTION(!cssRule || !cssRule->Selector(), "Unexpected CSS rule");
   }
 }
 #endif
 
 // Enumerate the rules in a way that cares about the order of the rules.
 void
 nsStyleSet::FileRules(nsIStyleRuleProcessor::EnumFunc aCollectorFunc, 
-                      RuleProcessorData* aData)
+                      RuleProcessorData* aData, nsRuleWalker* aRuleWalker)
 {
   // Cascading order:
   // [least important]
   //  1. UA normal rules                    = Agent        normal
   //  2. Presentation hints                 = PresHint     normal
   //  3. User normal rules                  = User         normal
   //  4. HTML Presentation hints            = HTMLPresHint normal
   //  5. Author normal rules                = Document     normal
@@ -542,73 +523,73 @@ nsStyleSet::FileRules(nsIStyleRuleProces
   //  9. User !important rules              = User         !important
   // 10. UA !important rules                = Agent        !important
   // [most important]
 
   NS_PRECONDITION(SheetCount(ePresHintSheet) == 0 ||
                   SheetCount(eHTMLPresHintSheet) == 0,
                   "Can't have both types of preshint sheets at once!");
   
-  mRuleWalker->SetLevel(eAgentSheet, PR_FALSE);
+  aRuleWalker->SetLevel(eAgentSheet, PR_FALSE);
   if (mRuleProcessors[eAgentSheet])
     (*aCollectorFunc)(mRuleProcessors[eAgentSheet], aData);
-  nsRuleNode* lastAgentRN = mRuleWalker->GetCurrentNode();
+  nsRuleNode* lastAgentRN = aRuleWalker->GetCurrentNode();
 
-  mRuleWalker->SetLevel(ePresHintSheet, PR_FALSE);
+  aRuleWalker->SetLevel(ePresHintSheet, PR_FALSE);
   if (mRuleProcessors[ePresHintSheet])
     (*aCollectorFunc)(mRuleProcessors[ePresHintSheet], aData);
-  nsRuleNode* lastPresHintRN = mRuleWalker->GetCurrentNode();
+  nsRuleNode* lastPresHintRN = aRuleWalker->GetCurrentNode();
 
-  mRuleWalker->SetLevel(eUserSheet, PR_FALSE);
+  aRuleWalker->SetLevel(eUserSheet, PR_FALSE);
   PRBool skipUserStyles =
     aData->mContent && aData->mContent->IsInNativeAnonymousSubtree();
   if (!skipUserStyles && mRuleProcessors[eUserSheet]) // NOTE: different
     (*aCollectorFunc)(mRuleProcessors[eUserSheet], aData);
-  nsRuleNode* lastUserRN = mRuleWalker->GetCurrentNode();
+  nsRuleNode* lastUserRN = aRuleWalker->GetCurrentNode();
 
-  mRuleWalker->SetLevel(eHTMLPresHintSheet, PR_FALSE);
+  aRuleWalker->SetLevel(eHTMLPresHintSheet, PR_FALSE);
   if (mRuleProcessors[eHTMLPresHintSheet])
     (*aCollectorFunc)(mRuleProcessors[eHTMLPresHintSheet], aData);
-  nsRuleNode* lastHTMLPresHintRN = mRuleWalker->GetCurrentNode();
+  nsRuleNode* lastHTMLPresHintRN = aRuleWalker->GetCurrentNode();
   
-  mRuleWalker->SetLevel(eDocSheet, PR_FALSE);
+  aRuleWalker->SetLevel(eDocSheet, PR_FALSE);
   PRBool cutOffInheritance = PR_FALSE;
   if (mBindingManager) {
     // We can supply additional document-level sheets that should be walked.
     mBindingManager->WalkRules(aCollectorFunc, aData, &cutOffInheritance);
   }
   if (!skipUserStyles && !cutOffInheritance &&
       mRuleProcessors[eDocSheet]) // NOTE: different
     (*aCollectorFunc)(mRuleProcessors[eDocSheet], aData);
-  mRuleWalker->SetLevel(eStyleAttrSheet, PR_FALSE);
+  aRuleWalker->SetLevel(eStyleAttrSheet, PR_FALSE);
   if (mRuleProcessors[eStyleAttrSheet])
     (*aCollectorFunc)(mRuleProcessors[eStyleAttrSheet], aData);
-  nsRuleNode* lastDocRN = mRuleWalker->GetCurrentNode();
+  nsRuleNode* lastDocRN = aRuleWalker->GetCurrentNode();
 
-  mRuleWalker->SetLevel(eOverrideSheet, PR_FALSE);
+  aRuleWalker->SetLevel(eOverrideSheet, PR_FALSE);
   if (mRuleProcessors[eOverrideSheet])
     (*aCollectorFunc)(mRuleProcessors[eOverrideSheet], aData);
-  nsRuleNode* lastOvrRN = mRuleWalker->GetCurrentNode();
+  nsRuleNode* lastOvrRN = aRuleWalker->GetCurrentNode();
 
-  mRuleWalker->SetLevel(eDocSheet, PR_TRUE);
-  AddImportantRules(lastDocRN, lastHTMLPresHintRN);  // doc
-  mRuleWalker->SetLevel(eOverrideSheet, PR_TRUE);
-  AddImportantRules(lastOvrRN, lastDocRN);  // override
+  aRuleWalker->SetLevel(eDocSheet, PR_TRUE);
+  AddImportantRules(lastDocRN, lastHTMLPresHintRN, aRuleWalker);  // doc
+  aRuleWalker->SetLevel(eOverrideSheet, PR_TRUE);
+  AddImportantRules(lastOvrRN, lastDocRN, aRuleWalker);  // override
 #ifdef DEBUG
   AssertNoCSSRules(lastHTMLPresHintRN, lastUserRN);
   AssertNoImportantRules(lastHTMLPresHintRN, lastUserRN); // HTML preshints
 #endif
-  mRuleWalker->SetLevel(eUserSheet, PR_TRUE);
-  AddImportantRules(lastUserRN, lastPresHintRN); //user
+  aRuleWalker->SetLevel(eUserSheet, PR_TRUE);
+  AddImportantRules(lastUserRN, lastPresHintRN, aRuleWalker); //user
 #ifdef DEBUG
   AssertNoCSSRules(lastPresHintRN, lastAgentRN);
   AssertNoImportantRules(lastPresHintRN, lastAgentRN); // preshints
 #endif
-  mRuleWalker->SetLevel(eAgentSheet, PR_TRUE);
-  AddImportantRules(lastAgentRN, nsnull);     //agent
+  aRuleWalker->SetLevel(eAgentSheet, PR_TRUE);
+  AddImportantRules(lastAgentRN, nsnull, aRuleWalker);     //agent
 
 }
 
 // Enumerate all the rules in a way that doesn't care about the order
 // of the rules and doesn't walk !important-rules.
 void
 nsStyleSet::WalkRuleProcessors(nsIStyleRuleProcessor::EnumFunc aFunc,
                                RuleProcessorData* aData)
@@ -686,80 +667,77 @@ nsStyleSet::ResolveStyleFor(nsIContent* 
   nsStyleContext*  result = nsnull;
   nsPresContext* presContext = PresContext();
 
   NS_ASSERTION(aContent, "must have content");
   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eELEMENT),
                "content must be element");
 
   if (aContent && presContext) {
-    NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
-    ElementRuleProcessorData data(presContext, aContent, mRuleWalker);
-    FileRules(EnumRulesMatching, &data);
-    result = GetContext(presContext, aParentContext, nsnull).get();
-
-    // Now reset the walker back to the root of the tree.
-    mRuleWalker->Reset();
+    nsRuleWalker ruleWalker(mRuleTree);
+    ElementRuleProcessorData data(presContext, aContent, &ruleWalker);
+    FileRules(EnumRulesMatching, &data, &ruleWalker);
+    result = GetContext(presContext, aParentContext,
+                        ruleWalker.GetCurrentNode(), nsnull).get();
   }
 
   return result;
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForRules(nsStyleContext* aParentContext,
                                  nsIAtom* aPseudoTag,
                                  nsRuleNode *aRuleNode,
                                  const nsCOMArray<nsIStyleRule> &aRules)
 {
   NS_ENSURE_FALSE(mInShutdown, nsnull);
   nsStyleContext* result = nsnull;
   nsPresContext *presContext = PresContext();
 
   if (presContext) {
-    NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
+    nsRuleWalker ruleWalker(mRuleTree);
     if (aRuleNode)
-      mRuleWalker->SetCurrentNode(aRuleNode);
+      ruleWalker.SetCurrentNode(aRuleNode);
     // FIXME: Perhaps this should be passed in, but it probably doesn't
     // matter.
-    mRuleWalker->SetLevel(eDocSheet, PR_FALSE);
+    ruleWalker.SetLevel(eDocSheet, PR_FALSE);
     for (PRInt32 i = 0; i < aRules.Count(); i++) {
-      mRuleWalker->Forward(aRules.ObjectAt(i));
+      ruleWalker.Forward(aRules.ObjectAt(i));
     }
-    result = GetContext(presContext, aParentContext, aPseudoTag).get();
-    NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
+    result = GetContext(presContext, aParentContext,
+                        ruleWalker.GetCurrentNode(), aPseudoTag).get();
   }
   return result;
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForNonElement(nsStyleContext* aParentContext)
 {
   nsStyleContext* result = nsnull;
   nsPresContext *presContext = PresContext();
 
   if (presContext) {
-    NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
-    result = GetContext(presContext, aParentContext,
+    result = GetContext(presContext, aParentContext, mRuleTree,
                         nsCSSAnonBoxes::mozNonElement).get();
-    NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
   }
 
   return result;
 }
 
 void
-nsStyleSet::WalkRestrictionRule(nsIAtom* aPseudoType)
+nsStyleSet::WalkRestrictionRule(nsIAtom* aPseudoType,
+                                nsRuleWalker* aRuleWalker)
 {
   // This needs to match GetPseudoRestriction in nsRuleNode.cpp.
   if (aPseudoType) {
-    mRuleWalker->SetLevel(eAgentSheet, PR_FALSE);
+    aRuleWalker->SetLevel(eAgentSheet, PR_FALSE);
     if (aPseudoType == nsCSSPseudoElements::firstLetter)
-      mRuleWalker->Forward(mFirstLetterRule);
+      aRuleWalker->Forward(mFirstLetterRule);
     else if (aPseudoType == nsCSSPseudoElements::firstLine)
-      mRuleWalker->Forward(mFirstLineRule);
+      aRuleWalker->Forward(mFirstLineRule);
   }
 }
 
 static PRBool
 EnumPseudoRulesMatching(nsIStyleRuleProcessor* aProcessor, void* aData)
 {
   PseudoRuleProcessorData* data =
     static_cast<PseudoRuleProcessorData*>(aData);
@@ -786,24 +764,24 @@ nsStyleSet::ResolvePseudoStyleFor(nsICon
   NS_ASSERTION(aParentContent ||
                nsCSSAnonBoxes::IsAnonBox(aPseudoTag),
                "null content must correspond to anonymous box");
   NS_ASSERTION(nsCSSAnonBoxes::IsAnonBox(aPseudoTag) ||
                nsCSSPseudoElements::IsPseudoElement(aPseudoTag),
                "aPseudoTag must be pseudo-element or anonymous box");
 
   if (aPseudoTag && presContext) {
-    NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
+    nsRuleWalker ruleWalker(mRuleTree);
     PseudoRuleProcessorData data(presContext, aParentContent, aPseudoTag,
-                                 aComparator, mRuleWalker);
-    WalkRestrictionRule(aPseudoTag);
-    FileRules(EnumPseudoRulesMatching, &data);
+                                 aComparator, &ruleWalker);
+    WalkRestrictionRule(aPseudoTag, &ruleWalker);
+    FileRules(EnumPseudoRulesMatching, &data, &ruleWalker);
 
-    result = GetContext(presContext, aParentContext, aPseudoTag).get();
-    NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
+    result = GetContext(presContext, aParentContext,
+                        ruleWalker.GetCurrentNode(), aPseudoTag).get();
   }
 
   return result;
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ProbePseudoStyleFor(nsIContent* aParentContent,
                                 nsIAtom* aPseudoTag,
@@ -823,30 +801,28 @@ nsStyleSet::ProbePseudoStyleFor(nsIConte
   NS_ASSERTION(aParentContent ||
                nsCSSAnonBoxes::IsAnonBox(aPseudoTag),
                "null content must correspond to anonymous box");
   NS_ASSERTION(nsCSSAnonBoxes::IsAnonBox(aPseudoTag) ||
                nsCSSPseudoElements::IsPseudoElement(aPseudoTag),
                "aPseudoTag must be pseudo-element or anonymous box");
 
   if (aPseudoTag && presContext) {
-    NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
+    nsRuleWalker ruleWalker(mRuleTree);
     PseudoRuleProcessorData data(presContext, aParentContent, aPseudoTag,
-                                 nsnull, mRuleWalker);
-    WalkRestrictionRule(aPseudoTag);
+                                 nsnull, &ruleWalker);
+    WalkRestrictionRule(aPseudoTag, &ruleWalker);
     // not the root if there was a restriction rule
-    nsRuleNode *adjustedRoot = mRuleWalker->GetCurrentNode();
-    FileRules(EnumPseudoRulesMatching, &data);
+    nsRuleNode *adjustedRoot = ruleWalker.GetCurrentNode();
+    FileRules(EnumPseudoRulesMatching, &data, &ruleWalker);
 
-    if (mRuleWalker->GetCurrentNode() != adjustedRoot)
-      result = GetContext(presContext, aParentContext, aPseudoTag).get();
-    else
-      mRuleWalker->Reset();
-
-    NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
+    nsRuleNode *ruleNode = ruleWalker.GetCurrentNode();
+    if (ruleNode != adjustedRoot)
+      result =
+        GetContext(presContext, aParentContext, ruleNode, aPseudoTag).get();
   }
 
   // For :before and :after pseudo-elements, having display: none or no
   // 'content' property is equivalent to not having the pseudo-element
   // at all.
   if (result &&
       (aPseudoTag == nsCSSPseudoElements::before ||
        aPseudoTag == nsCSSPseudoElements::after)) {
@@ -883,19 +859,16 @@ nsStyleSet::BeginShutdown(nsPresContext*
 {
   mInShutdown = 1;
   mRoots.Clear(); // no longer valid, since we won't keep it up to date
 }
 
 void
 nsStyleSet::Shutdown(nsPresContext* aPresContext)
 {
-  delete mRuleWalker;
-  mRuleWalker = nsnull;
-
   mRuleTree->Destroy();
   mRuleTree = nsnull;
 
   // We can have old rule trees either because:
   //   (1) we failed the assertions in EndReconstruct, or
   //   (2) we're shutting down within a reconstruct (see bug 462392)
   for (PRUint32 i = mOldRuleTrees.Length(); i > 0; ) {
     --i;
@@ -910,18 +883,16 @@ static const PRUint32 kGCInterval = 300;
 
 void
 nsStyleSet::NotifyStyleContextDestroyed(nsPresContext* aPresContext,
                                         nsStyleContext* aStyleContext)
 {
   if (mInShutdown)
     return;
 
-  NS_ASSERTION(mRuleWalker->AtRoot(), "Rule walker should be at root");
-
   // Remove style contexts from mRoots even if mOldRuleTree is non-null.  This
   // could be a style context from the new ruletree!
   if (!aStyleContext->GetParent()) {
     mRoots.RemoveElement(aStyleContext);
   }
 
   if (mInReconstruct)
     return;
@@ -973,23 +944,20 @@ nsStyleSet::ReParentStyleContext(nsPresC
 
   if (aPresContext && aStyleContext) {
     if (aStyleContext->GetParent() == aNewParentContext) {
       aStyleContext->AddRef();
       return aStyleContext;
     }
     else {  // really a new parent
       nsIAtom* pseudoTag = aStyleContext->GetPseudoType();
-
       nsRuleNode* ruleNode = aStyleContext->GetRuleNode();
-      mRuleWalker->SetCurrentNode(ruleNode);
 
       already_AddRefed<nsStyleContext> result =
-          GetContext(aPresContext, aNewParentContext, pseudoTag);
-      NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
+          GetContext(aPresContext, aNewParentContext, ruleNode, pseudoTag);
       return result;
     }
   }
   return nsnull;
 }
 
 struct StatefulData : public StateRuleProcessorData {
   StatefulData(nsPresContext* aPresContext,
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -270,21 +270,23 @@ class nsStyleSet
 
   // Run mark-and-sweep GC on mRuleTree and mOldRuleTrees, based on mRoots.
   void GCRuleTrees();
 
   // Update the rule processor list after a change to the style sheet list.
   nsresult GatherRuleProcessors(sheetType aType);
 
   void AddImportantRules(nsRuleNode* aCurrLevelNode,
-                         nsRuleNode* aLastPrevLevelNode);
+                         nsRuleNode* aLastPrevLevelNode,
+                         nsRuleWalker* aRuleWalker);
 
-  // Move mRuleWalker forward by the appropriate rule if we need to add
+  // Move aRuleWalker forward by the appropriate rule if we need to add
   // a rule due to property restrictions on pseudo-elements.
-  void WalkRestrictionRule(nsIAtom* aPseudoType);
+  void WalkRestrictionRule(nsIAtom* aPseudoType,
+                           nsRuleWalker* aRuleWalker);
 
 #ifdef DEBUG
   // Just like AddImportantRules except it doesn't actually add anything; it
   // just asserts that there are no important rules between aCurrLevelNode and
   // aLastPrevLevelNode.
   void AssertNoImportantRules(nsRuleNode* aCurrLevelNode,
                               nsRuleNode* aLastPrevLevelNode);
   
@@ -293,25 +295,26 @@ class nsStyleSet
   // aLastPrevLevelNode.  Mostly useful for the preshint levels.
   void AssertNoCSSRules(nsRuleNode* aCurrLevelNode,
                         nsRuleNode* aLastPrevLevelNode);
 #endif
   
   // Enumerate the rules in a way that cares about the order of the
   // rules.
   void FileRules(nsIStyleRuleProcessor::EnumFunc aCollectorFunc,
-                 RuleProcessorData* aData);
+                 RuleProcessorData* aData, nsRuleWalker* aRuleWalker);
 
   // Enumerate all the rules in a way that doesn't care about the order
   // of the rules and break out if the enumeration is halted.
   void WalkRuleProcessors(nsIStyleRuleProcessor::EnumFunc aFunc,
                           RuleProcessorData* aData);
 
   already_AddRefed<nsStyleContext> GetContext(nsPresContext* aPresContext,
                                               nsStyleContext* aParentContext,
+                                              nsRuleNode* aRuleNode,
                                               nsIAtom* aPseudoTag);
 
   nsPresContext* PresContext() { return mRuleTree->GetPresContext(); }
 
   // The sheets in each array in mSheets are stored with the most significant
   // sheet last.
   nsCOMArray<nsIStyleSheet> mSheets[eSheetTypeCount];
 
@@ -325,18 +328,16 @@ class nsStyleSet
   // To be used only in case of emergency, such as being out of memory
   // or operating on a deleted rule node.  The latter should never
   // happen, of course.
   nsCachedStyleData mDefaultStyleData;
 
   nsRuleNode* mRuleTree; // This is the root of our rule tree.  It is a
                          // lexicographic tree of matched rules that style
                          // contexts use to look up properties.
-  nsRuleWalker* mRuleWalker; // This is an instance of a rule walker that can
-                             // be used to navigate through our tree.
 
   PRUint32 mUnusedRuleNodeCount; // used to batch rule node GC
   nsTArray<nsStyleContext*> mRoots; // style contexts with no parent
 
   // Empty style rules to force things that restrict which properties
   // apply into different branches of the rule tree.
   nsRefPtr<nsEmptyStyleRule> mFirstLineRule, mFirstLetterRule;
 
