From: L. David Baron <dbaron@dbaron.org>

Bug 1115812 patch 16 - Remove the now-unused DoRebuildAllStyleData.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1524,24 +1524,16 @@ RestyleManager::StartRebuildAllStyleData
   // Note that we can ignore the return value of ComputeStyleChangeFor
   // because we never need to reframe the root frame.
   ComputeAndProcessStyleChange(mPresContext->PresShell()->GetRootFrame(),
                                nsChangeHint(0), aRestyleTracker,
                                eRestyle_ForceDescendants);
 }
 
 void
-RestyleManager::DoRebuildAllStyleData(RestyleTracker& aRestyleTracker)
-{
-  BeginProcessingRestyles(aRestyleTracker);
-  StartRebuildAllStyleData(aRestyleTracker);
-  EndProcessingRestyles();
-}
-
-void
 RestyleManager::ProcessPendingRestyles()
 {
   NS_PRECONDITION(mPresContext->Document(), "No document?  Pshaw!");
   NS_PRECONDITION(!nsContentUtils::IsSafeToRunScript(),
                   "Missing a script blocker!");
 
   // First do any queued-up frame creation.  (We should really
   // merge this into the rest of the process, though; see bug 827239.)
@@ -2575,17 +2567,17 @@ ElementRestyler::Restyle(nsRestyleHint a
   // restyle.  Before we return from this function, we call
   // RestyleTracker::AddRestyleRootsIfAwaitingRestyle to ensure they get
   // restyled in RestyleTracker::DoProcessRestyles.
   nsTArray<nsRefPtr<Element>> descendants;
 
   nsRestyleHint hintToRestore = nsRestyleHint(0);
   if (mContent && mContent->IsElement() &&
       // If we're we're resolving from the root of the frame tree (which
-      // we do in DoRebuildAllStyleData), we need to avoid getting the
+      // we do when mDoRebuildAllStyleData), we need to avoid getting the
       // root's restyle data until we get to its primary frame, since
       // it's the primary frame that has the styles for the root element
       // (rather than the ancestors of the primary frame whose mContent
       // is the root node but which have different styles).  If we use
       // up the hint for one of the ancestors that we hit first, then
       // we'll fail to do the restyling we need to do.
       (mContent->GetParent() || mContent->GetPrimaryFrame() == mFrame)) {
     mContent->OwnerDoc()->FlushPendingLinkUpdates();
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -322,20 +322,16 @@ public:
   // (which says that rerunning selector matching is not required.  (The
   // method adds eRestyle_ForceDescendants internally, and including it
   // in the restyle hint is harmless; some callers (e.g.,
   // nsPresContext::MediaFeatureValuesChanged) might do this for their
   // own reasons.)
   void RebuildAllStyleData(nsChangeHint aExtraHint,
                            nsRestyleHint aRestyleHint);
 
-  // Helper that does part of the work of RebuildAllStyleData, shared by
-  // RestyleElement for 'rem' handling.
-  void DoRebuildAllStyleData(RestyleTracker& aRestyleTracker);
-
   // See PostRestyleEventCommon below.
   void PostRestyleEvent(Element* aElement,
                         nsRestyleHint aRestyleHint,
                         nsChangeHint aMinChangeHint)
   {
     if (mPresContext) {
       PostRestyleEventCommon(aElement, aRestyleHint, aMinChangeHint,
                              IsProcessingAnimationStyleChange());
