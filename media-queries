Implement Media Queries.  b=156716

diff --git a/content/base/src/nsGkAtomList.h b/content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h
+++ b/content/base/src/nsGkAtomList.h
@@ -196,6 +196,7 @@ GK_ATOM(collapse, "collapse")
 GK_ATOM(collapse, "collapse")
 GK_ATOM(collapsed, "collapsed")
 GK_ATOM(color, "color")
+GK_ATOM(colorIndex, "color-index")
 GK_ATOM(cols, "cols")
 GK_ATOM(colspan, "colspan")
 GK_ATOM(column, "column")
@@ -260,6 +261,9 @@ GK_ATOM(descending, "descending")
 GK_ATOM(descending, "descending")
 GK_ATOM(description, "description")
 GK_ATOM(destructor, "destructor")
+GK_ATOM(deviceAspectRatio, "device-aspect-ratio")
+GK_ATOM(deviceHeight, "device-height")
+GK_ATOM(deviceWidth, "device-width")
 GK_ATOM(dfn, "dfn")
 GK_ATOM(dialog, "dialog")
 GK_ATOM(difference, "difference")
@@ -506,6 +510,7 @@ GK_ATOM(mod, "mod")
 GK_ATOM(mod, "mod")
 GK_ATOM(mode, "mode")
 GK_ATOM(modifiers, "modifiers")
+GK_ATOM(monochrome, "monochrome")
 GK_ATOM(mousedown, "mousedown")
 GK_ATOM(mousemove, "mousemove")
 GK_ATOM(mouseout, "mouseout")
@@ -598,6 +603,7 @@ GK_ATOM(onkeyup, "onkeyup")
 GK_ATOM(onkeyup, "onkeyup")
 GK_ATOM(onLoad, "onLoad")
 GK_ATOM(onload, "onload")
+GK_ATOM(only, "only") // not an event
 GK_ATOM(onmousedown, "onmousedown")
 GK_ATOM(onmousemove, "onmousemove")
 GK_ATOM(onmouseout, "onmouseout")
@@ -715,6 +721,7 @@ GK_ATOM(resizeafter, "resizeafter")
 GK_ATOM(resizeafter, "resizeafter")
 GK_ATOM(resizebefore, "resizebefore")
 GK_ATOM(resizer, "resizer")
+GK_ATOM(resolution, "resolution")
 GK_ATOM(resource, "resource")
 GK_ATOM(resources, "resources")
 GK_ATOM(result, "result")
diff --git a/layout/style/Makefile.in b/layout/style/Makefile.in
--- a/layout/style/Makefile.in
+++ b/layout/style/Makefile.in
@@ -150,6 +150,7 @@ CPPSRCS		= \
 		nsHTMLStyleSheet.cpp \
 		nsInspectorCSSUtils.cpp \
 		nsLayoutStylesheetCache.cpp \
+		nsMediaFeatures.cpp \
 		nsROCSSPrimitiveValue.cpp \
 		nsRuleNode.cpp \
 		nsStyleContext.cpp \
diff --git a/layout/style/nsCSSDeclaration.h b/layout/style/nsCSSDeclaration.h
--- a/layout/style/nsCSSDeclaration.h
+++ b/layout/style/nsCSSDeclaration.h
@@ -158,11 +158,13 @@ private:
   static void AppendImportanceToString(PRBool aIsImportant, nsAString& aString);
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
   PRBool   AppendValueToString(nsCSSProperty aProperty, nsAString& aResult) const;
+public:
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
   static PRBool AppendCSSValueToString(nsCSSProperty aProperty,
                                        const nsCSSValue& aValue,
                                        nsAString& aResult);
 
+private:
   // May be called only for properties whose type is eCSSType_Value.
   nsresult GetValueOrImportantValue(nsCSSProperty aProperty, nsCSSValue& aValue) const;
 
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -83,6 +83,62 @@
 #include "prprf.h"
 #include "math.h"
 
+// Flags for ParseVariant method
+#define VARIANT_KEYWORD         0x000001  // K
+#define VARIANT_LENGTH          0x000002  // L
+#define VARIANT_PERCENT         0x000004  // P
+#define VARIANT_COLOR           0x000008  // C eCSSUnit_Color, eCSSUnit_String (e.g.  "red")
+#define VARIANT_URL             0x000010  // U
+#define VARIANT_NUMBER          0x000020  // N
+#define VARIANT_INTEGER         0x000040  // I
+#define VARIANT_ANGLE           0x000080  // G
+#define VARIANT_FREQUENCY       0x000100  // F
+#define VARIANT_TIME            0x000200  // T
+#define VARIANT_STRING          0x000400  // S
+#define VARIANT_COUNTER         0x000800  // 
+#define VARIANT_ATTR            0x001000  //
+#define VARIANT_IDENTIFIER      0x002000  // D
+#define VARIANT_AUTO            0x010000  // A
+#define VARIANT_INHERIT         0x020000  // H eCSSUnit_Initial, eCSSUnit_Inherit
+#define VARIANT_NONE            0x040000  // O
+#define VARIANT_NORMAL          0x080000  // M
+#define VARIANT_SYSFONT         0x100000  // eCSSUnit_System_Font
+
+// Common combinations of variants
+#define VARIANT_AL   (VARIANT_AUTO | VARIANT_LENGTH)
+#define VARIANT_LP   (VARIANT_LENGTH | VARIANT_PERCENT)
+#define VARIANT_AH   (VARIANT_AUTO | VARIANT_INHERIT)
+#define VARIANT_AHLP (VARIANT_AH | VARIANT_LP)
+#define VARIANT_AHI  (VARIANT_AH | VARIANT_INTEGER)
+#define VARIANT_AHK  (VARIANT_AH | VARIANT_KEYWORD)
+#define VARIANT_AHKLP (VARIANT_AHLP | VARIANT_KEYWORD)
+#define VARIANT_AUK  (VARIANT_AUTO | VARIANT_URL | VARIANT_KEYWORD)
+#define VARIANT_AHUK (VARIANT_AH | VARIANT_URL | VARIANT_KEYWORD)
+#define VARIANT_AHL  (VARIANT_AH | VARIANT_LENGTH)
+#define VARIANT_AHKL (VARIANT_AHK | VARIANT_LENGTH)
+#define VARIANT_HK   (VARIANT_INHERIT | VARIANT_KEYWORD)
+#define VARIANT_HKF  (VARIANT_HK | VARIANT_FREQUENCY)
+#define VARIANT_HKL  (VARIANT_HK | VARIANT_LENGTH)
+#define VARIANT_HKLP (VARIANT_HK | VARIANT_LP)
+#define VARIANT_HKLPO (VARIANT_HKLP | VARIANT_NONE)
+#define VARIANT_HL   (VARIANT_INHERIT | VARIANT_LENGTH)
+#define VARIANT_HI   (VARIANT_INHERIT | VARIANT_INTEGER)
+#define VARIANT_HLP  (VARIANT_HL | VARIANT_PERCENT)
+#define VARIANT_HLPN (VARIANT_HLP | VARIANT_NUMBER)
+#define VARIANT_HLPO (VARIANT_HLP | VARIANT_NONE)
+#define VARIANT_HTP  (VARIANT_INHERIT | VARIANT_TIME | VARIANT_PERCENT)
+#define VARIANT_HMK  (VARIANT_HK | VARIANT_NORMAL)
+#define VARIANT_HMKI (VARIANT_HMK | VARIANT_INTEGER)
+#define VARIANT_HC   (VARIANT_INHERIT | VARIANT_COLOR)
+#define VARIANT_HCK  (VARIANT_HK | VARIANT_COLOR)
+#define VARIANT_HUO  (VARIANT_INHERIT | VARIANT_URL | VARIANT_NONE)
+#define VARIANT_AHUO (VARIANT_AUTO | VARIANT_HUO)
+#define VARIANT_HPN  (VARIANT_INHERIT | VARIANT_PERCENT | VARIANT_NUMBER)
+#define VARIANT_HOK  (VARIANT_HK | VARIANT_NONE)
+#define VARIANT_HN   (VARIANT_INHERIT | VARIANT_NUMBER)
+#define VARIANT_HON  (VARIANT_HN | VARIANT_NONE)
+#define VARIANT_HOS  (VARIANT_INHERIT | VARIANT_NONE | VARIANT_STRING)
+
 //----------------------------------------------------------------------
 
 // Your basic top-down recursive descent style parser
@@ -225,6 +281,7 @@ protected:
   PRBool GatherURL(nsresult& aErrorCode, nsString& aURL);
   PRBool GatherMedia(nsresult& aErrorCode, nsMediaList* aMedia,
                      PRUnichar aStopSymbol);
+  PRBool ParseMediaQueryExpression(nsresult& aErrorCode, nsMediaQuery* aQuery);
   PRBool ProcessImport(nsresult& aErrorCode,
                        const nsString& aURLSpec,
                        nsMediaList* aMedia,
@@ -1070,6 +1127,9 @@ CSSParserImpl::DoParseMediaList(const ns
   }
 
   if (!GatherMedia(rv, aMediaList, PRUnichar(0)) && !mHTMLMediaMode) {
+    // XXX This needs to do better error propagation, and GatherMedia
+    // needs to deal with this potentially still using aMediaList in
+    // case of error.
     OUTPUT_ERROR();
   }
   CLEAR_ERROR();
@@ -1363,38 +1423,211 @@ PRBool CSSParserImpl::GatherMedia(nsresu
                                   PRUnichar aStopSymbol)
 {
   for (;;) {
-    if (!GetToken(aErrorCode, PR_TRUE)) {
-      REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
-      break;
-    }
-    if (eCSSToken_Ident != mToken.mType) {
-      REPORT_UNEXPECTED_TOKEN(PEGatherMediaNotIdent);
-      UngetToken();
-      break;
-    }
-    ToLowerCase(mToken.mIdent);  // case insensitive from CSS - must be lower cased
-    nsCOMPtr<nsIAtom> medium = do_GetAtom(mToken.mIdent);
-    aMedia->AppendAtom(medium);
-
-    if (!GetToken(aErrorCode, PR_TRUE)) {
-      if (aStopSymbol == PRUnichar(0))
-        return PR_TRUE;
-      REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
-      break;
-    }
-
-    if (eCSSToken_Symbol == mToken.mType &&
-        mToken.mSymbol == aStopSymbol) {
-      UngetToken();
-      return PR_TRUE;
-    } else if (eCSSToken_Symbol != mToken.mType ||
-               mToken.mSymbol != ',') {
-      REPORT_UNEXPECTED_TOKEN(PEGatherMediaNotComma);
-      UngetToken();
-      break;
-    }
-  }
-  return PR_FALSE;
+    nsAutoPtr<nsMediaQuery> query(new nsMediaQuery);
+    if (!query) {
+      aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+      return PR_FALSE;
+    }
+
+    // XXX XXX XXX XXX NEED TO HANDLE (expression) without media type!!!
+
+    nsCOMPtr<nsIAtom> mediaType;
+    PRBool gotNotOrOnly = PR_FALSE;
+    for (;;) {
+      if (!GetToken(aErrorCode, PR_TRUE)) {
+        REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
+        return PR_FALSE;
+      }
+      if (eCSSToken_Ident != mToken.mType) {
+        REPORT_UNEXPECTED_TOKEN(PEGatherMediaNotIdent);
+        UngetToken();
+        return PR_FALSE;
+      }
+      // case insensitive from CSS - must be lower cased
+      ToLowerCase(mToken.mIdent);
+      mediaType = do_GetAtom(mToken.mIdent);
+      if (gotNotOrOnly ||
+          (mediaType != nsGkAtoms::_not && mediaType != nsGkAtoms::only))
+        return PR_FALSE;
+      gotNotOrOnly = PR_TRUE;
+      if (mediaType == nsGkAtoms::_not)
+        query->SetNegated();
+      else
+        query->SetHasOnly();
+    }
+    query->SetType(mediaType);
+
+    // XXX WHEN DO WE WANT TO APPEND THIS?
+    aMedia->AppendQuery(query);
+
+    for (;;) {
+      if (!GetToken(aErrorCode, PR_TRUE)) {
+        if (aStopSymbol == PRUnichar(0))
+          return PR_TRUE;
+        REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
+        return PR_FALSE;
+      }
+
+      if (eCSSToken_Symbol == mToken.mType &&
+          mToken.mSymbol == aStopSymbol) {
+        UngetToken();
+        return PR_TRUE;
+      }
+      if (eCSSToken_Symbol == mToken.mType && mToken.mSymbol == ',') {
+        // Done with the expressions for this query
+        break;
+      }
+      if (eCSSToken_Ident != mToken.mType ||
+          !mToken.mIdent.LowerCaseEqualsLiteral("and")) {
+        REPORT_UNEXPECTED_TOKEN(PEGatherMediaNotComma);
+        UngetToken();
+        return PR_FALSE;
+      }
+      if (!ParseMediaQueryExpression(aErrorCode, query)) {
+        query->SetHadUnknownExpression();
+      }
+    }
+  }
+  return PR_FALSE;
+}
+
+PRBool CSSParserImpl::ParseMediaQueryExpression(nsresult& aErrorCode, nsMediaQuery* aQuery)
+{
+  if (!ExpectSymbol(aErrorCode, '(', PR_TRUE)) {
+    // XXX ADD ERROR REPORT
+    return PR_FALSE;
+  }
+  if (! GetToken(aErrorCode, PR_TRUE)) {
+    // XXX ADD ERROR REPORT
+    return PR_FALSE;
+  }
+  if (eCSSToken_Ident != mToken.mType) {
+    // XXX ADD ERROR REPORT
+    SkipUntil(aErrorCode, ')');
+    return PR_FALSE;
+  }
+
+  nsMediaExpression *expr = aQuery->NewExpression();
+  if (!expr) {
+    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    SkipUntil(aErrorCode, ')');
+    return PR_FALSE;
+  }
+
+  // case insensitive from CSS - must be lower cased
+  ToLowerCase(mToken.mIdent);
+  const PRUnichar *featureString;
+  if (StringBeginsWith(mToken.mIdent, NS_LITERAL_STRING("min-"))) {
+    expr->mRange = nsMediaExpression::eMin;
+    featureString = mToken.mIdent.get() + 4;
+  } else if (StringBeginsWith(mToken.mIdent, NS_LITERAL_STRING("max-"))) {
+    expr->mRange = nsMediaExpression::eMax;
+    featureString = mToken.mIdent.get() + 4;
+  } else {
+    expr->mRange = nsMediaExpression::eEqual;
+    featureString = mToken.mIdent.get();
+  }
+
+  nsCOMPtr<nsIAtom> mediaFeatureAtom = do_GetAtom(featureString);
+  const nsMediaFeature *feature = nsMediaFeatures::features,
+                   *feature_end = nsMediaFeatures::features +
+                                    nsMediaFeatures::COUNT;
+  for (; feature < feature_end; ++feature) {
+    if (*(feature->mName) == mediaFeatureAtom) {
+      break;
+    }
+  }
+  if (feature == feature_end ||
+      (expr->mRange != nsMediaExpression::eEqual) !=
+        (feature->mRangeType == nsMediaFeature::eMinMaxAllowed)) {
+    SkipUntil(aErrorCode, ')');
+    // XXX ADD ERROR REPORT
+    return PR_FALSE;
+  }
+  expr->mFeature = feature;
+
+  if (! GetToken(aErrorCode, PR_TRUE)) {
+    // XXX ADD ERROR REPORT
+    return PR_FALSE;
+  }
+  if (eCSSToken_Symbol != mToken.mType ||
+      (mToken.mSymbol != PRUnichar(':') && mToken.mSymbol != PRUnichar(')'))) {
+    // XXX ADD ERROR REPORT
+    SkipUntil(aErrorCode, ')');
+    return PR_FALSE;
+  }
+
+  nsRefPtr<nsCSSValue::Array> array;
+  if (feature->mValueType == nsMediaFeature::eIntRatio) {
+    array = nsCSSValue::Array::Create(2);
+    if (!array) {
+      aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+      SkipUntil(aErrorCode, ')');
+      return PR_FALSE;
+    }
+    expr->mValue.SetArrayValue(array, eCSSUnit_Array);
+  }
+
+  if (mToken.mSymbol == PRUnichar(')')) {
+    // Set the value to zero.
+    switch (feature->mValueType) {
+      case nsMediaFeature::eLength:
+        expr->mValue.SetFloatValue(0.0f, eCSSUnit_Point);
+        break;
+      case nsMediaFeature::eInteger:
+        expr->mValue.SetIntValue(0, eCSSUnit_Integer);
+        break;
+      case nsMediaFeature::eIntRatio:
+        // The spec is vague, but interpret "zero" as a ratio of 0/1.
+        array->Item(0).SetIntValue(0, eCSSUnit_Integer);
+        array->Item(1).SetIntValue(1, eCSSUnit_Integer);
+        break;
+      case nsMediaFeature::eResolution:
+        expr->mValue.SetFloatValue(0.0f, eCSSUnit_Inch);
+        break;
+    }
+    return PR_TRUE;
+  }
+
+  PRBool rv;
+  switch (feature->mValueType) {
+    case nsMediaFeature::eLength:
+      rv = ParseVariant(aErrorCode, expr->mValue, VARIANT_LENGTH, nsnull);
+      break;
+    case nsMediaFeature::eInteger:
+      rv = ParseVariant(aErrorCode, expr->mValue, VARIANT_INTEGER, nsnull);
+      break;
+    case nsMediaFeature::eIntRatio:
+      // XXX This allows whitespace around the '/'.  The spec isn't
+      // clear on whether we should.
+      rv = ParseVariant(aErrorCode, array->Item(0), VARIANT_INTEGER, nsnull) &&
+           ExpectSymbol(aErrorCode, '/', PR_TRUE) &&
+           ParseVariant(aErrorCode, array->Item(1), VARIANT_INTEGER, nsnull);
+      break;
+    case nsMediaFeature::eResolution:
+      rv = GetToken(aErrorCode, PR_TRUE) && mToken.IsDimension();
+      if (rv) {
+        NS_ASSERTION(!mToken.mIdent.IsEmpty() || mToken.mNumber == 0.0f,
+                     "IsDimension lied");
+        // XXX The spec isn't really clear on whether unitless zero
+        // should be allowed, but we allow it.
+        if (mToken.mIdent.IsEmpty() ||
+            mToken.mIdent.LowerCaseEqualsLiteral("dpi")) {
+          expr->mValue.SetFloatValue(mToken.mNumber, eCSSUnit_Inch);
+        } else if (mToken.mIdent.LowerCaseEqualsLiteral("dpcm")) {
+          expr->mValue.SetFloatValue(mToken.mNumber, eCSSUnit_Centimeter);
+        } else {
+          rv = PR_FALSE;
+        }
+      }
+      break;
+  }
+  if (!rv) {
+    // XXX ADD ERROR REPORT
+    return PR_FALSE;
+  }
+
+  return ExpectSymbol(aErrorCode, ')', PR_TRUE);
 }
 
 // Parse a CSS2 import rule: "@import STRING | URL [medium [, medium]]"
@@ -3649,62 +3882,6 @@ CSSParserImpl::DoTransferTempData(nsCSSD
     } break;
   }
 }
-
-// Flags for ParseVariant method
-#define VARIANT_KEYWORD         0x000001  // K
-#define VARIANT_LENGTH          0x000002  // L
-#define VARIANT_PERCENT         0x000004  // P
-#define VARIANT_COLOR           0x000008  // C eCSSUnit_Color, eCSSUnit_String (e.g.  "red")
-#define VARIANT_URL             0x000010  // U
-#define VARIANT_NUMBER          0x000020  // N
-#define VARIANT_INTEGER         0x000040  // I
-#define VARIANT_ANGLE           0x000080  // G
-#define VARIANT_FREQUENCY       0x000100  // F
-#define VARIANT_TIME            0x000200  // T
-#define VARIANT_STRING          0x000400  // S
-#define VARIANT_COUNTER         0x000800  // 
-#define VARIANT_ATTR            0x001000  //
-#define VARIANT_IDENTIFIER      0x002000  // D
-#define VARIANT_AUTO            0x010000  // A
-#define VARIANT_INHERIT         0x020000  // H eCSSUnit_Initial, eCSSUnit_Inherit
-#define VARIANT_NONE            0x040000  // O
-#define VARIANT_NORMAL          0x080000  // M
-#define VARIANT_SYSFONT         0x100000  // eCSSUnit_System_Font
-
-// Common combinations of variants
-#define VARIANT_AL   (VARIANT_AUTO | VARIANT_LENGTH)
-#define VARIANT_LP   (VARIANT_LENGTH | VARIANT_PERCENT)
-#define VARIANT_AH   (VARIANT_AUTO | VARIANT_INHERIT)
-#define VARIANT_AHLP (VARIANT_AH | VARIANT_LP)
-#define VARIANT_AHI  (VARIANT_AH | VARIANT_INTEGER)
-#define VARIANT_AHK  (VARIANT_AH | VARIANT_KEYWORD)
-#define VARIANT_AHKLP (VARIANT_AHLP | VARIANT_KEYWORD)
-#define VARIANT_AUK  (VARIANT_AUTO | VARIANT_URL | VARIANT_KEYWORD)
-#define VARIANT_AHUK (VARIANT_AH | VARIANT_URL | VARIANT_KEYWORD)
-#define VARIANT_AHL  (VARIANT_AH | VARIANT_LENGTH)
-#define VARIANT_AHKL (VARIANT_AHK | VARIANT_LENGTH)
-#define VARIANT_HK   (VARIANT_INHERIT | VARIANT_KEYWORD)
-#define VARIANT_HKF  (VARIANT_HK | VARIANT_FREQUENCY)
-#define VARIANT_HKL  (VARIANT_HK | VARIANT_LENGTH)
-#define VARIANT_HKLP (VARIANT_HK | VARIANT_LP)
-#define VARIANT_HKLPO (VARIANT_HKLP | VARIANT_NONE)
-#define VARIANT_HL   (VARIANT_INHERIT | VARIANT_LENGTH)
-#define VARIANT_HI   (VARIANT_INHERIT | VARIANT_INTEGER)
-#define VARIANT_HLP  (VARIANT_HL | VARIANT_PERCENT)
-#define VARIANT_HLPN (VARIANT_HLP | VARIANT_NUMBER)
-#define VARIANT_HLPO (VARIANT_HLP | VARIANT_NONE)
-#define VARIANT_HTP  (VARIANT_INHERIT | VARIANT_TIME | VARIANT_PERCENT)
-#define VARIANT_HMK  (VARIANT_HK | VARIANT_NORMAL)
-#define VARIANT_HMKI (VARIANT_HMK | VARIANT_INTEGER)
-#define VARIANT_HC   (VARIANT_INHERIT | VARIANT_COLOR)
-#define VARIANT_HCK  (VARIANT_HK | VARIANT_COLOR)
-#define VARIANT_HUO  (VARIANT_INHERIT | VARIANT_URL | VARIANT_NONE)
-#define VARIANT_AHUO (VARIANT_AUTO | VARIANT_HUO)
-#define VARIANT_HPN  (VARIANT_INHERIT | VARIANT_PERCENT | VARIANT_NUMBER)
-#define VARIANT_HOK  (VARIANT_HK | VARIANT_NONE)
-#define VARIANT_HN   (VARIANT_INHERIT | VARIANT_NUMBER)
-#define VARIANT_HON  (VARIANT_HN | VARIANT_NONE)
-#define VARIANT_HOS  (VARIANT_INHERIT | VARIANT_NONE | VARIANT_STRING)
 
 static const nsCSSProperty kBorderTopIDs[] = {
   eCSSProperty_border_top_width,
diff --git a/layout/style/nsCSSStyleSheet.cpp b/layout/style/nsCSSStyleSheet.cpp
--- a/layout/style/nsCSSStyleSheet.cpp
+++ b/layout/style/nsCSSStyleSheet.cpp
@@ -74,6 +74,7 @@
 #include "nsContentUtils.h"
 #include "nsIJSContextStack.h"
 #include "nsIScriptSecurityManager.h"
+#include "nsCSSDeclaration.h"
 
 // -------------------------------
 // Style Rule List for the DOM
@@ -162,6 +163,78 @@ CSSRuleListImpl::Item(PRUint32 aIndex, n
   return result;
 }
 
+void
+nsMediaQuery::AppendToString(nsAString& aString)
+{
+  NS_ASSERTION(!mNegated || !mHasOnly, "can't have not and only");
+  if (mNegated) {
+    aString.AppendLiteral("not ");
+  } else if (mHasOnly) {
+    aString.AppendLiteral("only ");
+  }
+  nsAutoString buffer;
+  mMediaType->ToString(buffer);
+  aString.Append(buffer);
+  buffer.Truncate();
+
+  if (mHadUnknownExpression) {
+    aString.AppendLiteral(" and (unknown-expression)");
+  } else {
+    for (PRUint32 i = 0, i_end = mExpressions.Length(); i < i_end; ++i) {
+      if (i > 0 || !mTypeOmitted)
+        aString.AppendLiteral(" and ");
+      aString.AppendLiteral("(");
+
+      nsMediaExpression &expr = mExpressions[i];
+      if (expr.mRange == nsMediaExpression::eMin) {
+        aString.AppendLiteral("min-");
+      } else if (expr.mRange == nsMediaExpression::eMax) {
+        aString.AppendLiteral("max-");
+      }
+
+      const nsMediaFeature *feature = expr.mFeature;
+      (*feature->mName)->ToString(buffer);
+      aString.Append(buffer);
+      buffer.Truncate();
+
+      // XXX Omit value in some cases?
+      aString.AppendLiteral(": ");
+      switch (feature->mValueType) {
+        case nsMediaFeature::eLength:
+          nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_width,
+                                                   expr.mValue, aString);
+          break;
+        case nsMediaFeature::eInteger:
+          nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
+                                                   expr.mValue, aString);
+          break;
+        case nsMediaFeature::eIntRatio:
+          {
+            nsCSSValue::Array *array = expr.mValue.GetArrayValue();
+            nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
+                                                     array->Item(0), aString);
+            aString.AppendLiteral("/");
+            nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
+                                                     array->Item(1), aString);
+          }
+          break;
+        case nsMediaFeature::eResolution:
+          buffer.AppendFloat(expr.mValue.GetFloatValue());
+          aString.Append(buffer);
+          buffer.Truncate();
+          if (expr.mValue.GetUnit() == eCSSUnit_Inch) {
+            aString.AppendLiteral("dpi");
+          } else {
+            aString.AppendLiteral("dpcm");
+          }
+          break;
+      }
+
+      aString.AppendLiteral(")");
+    }
+  }
+}
+
 NS_INTERFACE_MAP_BEGIN(nsMediaList)
   NS_INTERFACE_MAP_ENTRY(nsIDOMMediaList)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
@@ -186,13 +259,12 @@ nsMediaList::GetText(nsAString& aMediaTe
 {
   aMediaText.Truncate();
 
-  for (PRInt32 i = 0, i_end = mArray.Count(); i < i_end; ++i) {
-    nsIAtom* medium = mArray[i];
-    NS_ENSURE_TRUE(medium, NS_ERROR_FAILURE);
+  for (PRInt32 i = 0, i_end = mArray.Length(); i < i_end; ++i) {
+    nsMediaQuery* query = mArray[i];
+    NS_ENSURE_TRUE(query, NS_ERROR_FAILURE);
 
-    nsAutoString buffer;
-    medium->ToString(buffer);
-    aMediaText.Append(buffer);
+    query->AppendToString(aMediaText);
+
     if (i + 1 < i_end) {
       aMediaText.AppendLiteral(", ");
     }
@@ -309,7 +381,7 @@ nsMediaList::GetLength(PRUint32* aLength
 {
   NS_ENSURE_ARG_POINTER(aLength);
 
-  *aLength = mArray.Count();
+  *aLength = mArray.Length();
   return NS_OK;
 }
 
diff --git a/layout/style/nsIMediaList.h b/layout/style/nsIMediaList.h
--- a/layout/style/nsIMediaList.h
+++ b/layout/style/nsIMediaList.h
@@ -46,11 +46,52 @@
 
 #include "nsIDOMMediaList.h"
 #include "nsAString.h"
-#include "nsCOMArray.h"
+#include "nsTArray.h"
 #include "nsIAtom.h"
+#include "nsMediaFeatures.h"
+#include "nsCSSValue.h"
+
 class nsPresContext;
 class nsICSSStyleSheet;
 class nsCSSStyleSheet;
+
+struct nsMediaExpression {
+  enum Range { eMin, eMax, eEqual };
+
+  const nsMediaFeature *mFeature;
+  Range mRange;
+  nsCSSValue mValue;
+};
+
+class nsMediaQuery {
+public:
+  nsMediaQuery()
+    : mNegated(PR_FALSE)
+    , mHasOnly(PR_FALSE)
+    , mHadUnknownExpression(PR_FALSE)
+  {
+  }
+
+  void SetNegated()                     { mNegated = PR_TRUE; }
+  void SetHasOnly()                     { mHasOnly = PR_TRUE; }
+  void SetHadUnknownExpression()        { mHadUnknownExpression = PR_TRUE; }
+  void SetType(nsIAtom* aMediaType)     { mMediaType = aMediaType; }
+
+  // Return a new nsMediaExpression in the array for the caller to fill
+  // in.  The caller must either fill it in completely, or call
+  // SetHadUnknownExpression on this nsMediaQuery.
+  // Returns null on out-of-memory.
+  nsMediaExpression* NewExpression()    { return mExpressions.AppendElement(); }
+
+  void AppendToString(nsAString& aString);
+
+private:
+  PRPackedBool mNegated;
+  PRPackedBool mHasOnly; // only needed for serialization
+  PRPackedBool mHadUnknownExpression;
+  nsCOMPtr<nsIAtom> mMediaType;
+  nsTArray<nsMediaExpression> mExpressions;
+};
 
 class nsMediaList : public nsIDOMMediaList {
 public:
@@ -64,14 +105,15 @@ public:
   nsresult SetText(const nsAString& aMediaText);
   PRBool Matches(nsPresContext* aPresContext);
   nsresult SetStyleSheet(nsICSSStyleSheet* aSheet);
-  nsresult AppendAtom(nsIAtom* aMediumAtom) {
-    return mArray.AppendObject(aMediumAtom) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+  nsresult AppendQuery(nsMediaQuery *aQuery) {
+    // Takes ownership of aQuery
+    return mArray.AppendElement(aQuery) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
   }
 
   nsresult Clone(nsMediaList** aResult);
 
-  PRInt32 Count() { return mArray.Count(); }
-  nsIAtom* MediumAt(PRInt32 aIndex) { return mArray[aIndex]; }
+  PRInt32 Count() { return mArray.Length(); }
+  nsMediaQuery* MediumAt(PRInt32 aIndex) { return mArray[aIndex]; }
   void Clear() { mArray.Clear(); }
 
 protected:
@@ -80,7 +122,7 @@ protected:
   nsresult Delete(const nsAString & aOldMedium);
   nsresult Append(const nsAString & aOldMedium);
 
-  nsCOMArray<nsIAtom> mArray;
+  nsTArray<nsAutoPtr<nsMediaQuery> > mArray;
   // not refcounted; sheet will let us know when it goes away
   // mStyleSheet is the sheet that needs to be dirtied when this medialist
   // changes
diff --git a/layout/style/nsMediaFeatures.cpp b/layout/style/nsMediaFeatures.cpp
new file mode 100644
--- /dev/null
+++ b/layout/style/nsMediaFeatures.cpp
@@ -0,0 +1,86 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND,
+      either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsMediaFeatures.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>,
+      Mozilla Corporation (original author)
+ *
+ * Alternatively,
+      the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"),
+      or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL,
+      and not to allow others to
+ * use your version of this file under the terms of the MPL,
+      indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above,
+      a recipient may use your version of this file under
+ * the terms of any one of the MPL,
+      the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsMediaFeatures.h"
+#include "nsGkAtoms.h"
+
+/* static */ const nsMediaFeature
+nsMediaFeatures::features[nsMediaFeatures::COUNT] = {
+    { &nsGkAtoms::width,
+      nsMediaFeature::eMinMaxAllowed,
+      nsMediaFeature::eLength },
+    { &nsGkAtoms::height,
+      nsMediaFeature::eMinMaxAllowed,
+      nsMediaFeature::eLength },
+    { &nsGkAtoms::deviceWidth,
+      nsMediaFeature::eMinMaxAllowed,
+      nsMediaFeature::eLength },
+    { &nsGkAtoms::deviceHeight,
+      nsMediaFeature::eMinMaxAllowed,
+      nsMediaFeature::eLength },
+    { &nsGkAtoms::deviceAspectRatio,
+      nsMediaFeature::eMinMaxAllowed,
+      nsMediaFeature::eIntRatio },
+    { &nsGkAtoms::color,
+      nsMediaFeature::eMinMaxAllowed,
+      nsMediaFeature::eInteger },
+    { &nsGkAtoms::colorIndex,
+      nsMediaFeature::eMinMaxAllowed,
+      nsMediaFeature::eInteger },
+    { &nsGkAtoms::monochrome,
+      nsMediaFeature::eMinMaxAllowed,
+      nsMediaFeature::eInteger },
+    { &nsGkAtoms::resolution,
+      nsMediaFeature::eMinMaxAllowed,
+      nsMediaFeature::eResolution },
+    // Don't support 'scan' both since it doesn't apply to non-tv
+    // devices and since the spec is unclear on what "(scan)" means.
+    // { &nsGkAtoms::scan,
+    //   nsMediaFeature::eMinMaxNotAllowed,
+    //   nsMediaFeature::eScan },
+    { &nsGkAtoms::grid,
+      nsMediaFeature::eMinMaxNotAllowed,
+      nsMediaFeature::eInteger }
+};
diff --git a/layout/style/nsMediaFeatures.h b/layout/style/nsMediaFeatures.h
new file mode 100644
--- /dev/null
+++ b/layout/style/nsMediaFeatures.h
@@ -0,0 +1,64 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsMediaFeatures.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsMediaFeatures_h_
+#define nsMediaFeatures_h_
+
+#include "nsIAtom.h"
+
+struct nsMediaFeature {
+    nsIAtom **mName; // extra indirection to point to nsGkAtoms members
+
+    enum RangeType { eMinMaxAllowed, eMinMaxNotAllowed };
+    RangeType mRangeType;
+
+    enum ValueType {
+        eLength,    // values are such that nsCSSValue::IsLengthUnit() is true
+        eInteger,   // values are eCSSUnit_Integer
+        eIntRatio,  // values are eCSSUnit_Array of two eCSSUnit_Integer
+        eResolution // values are in eCSSUnit_Inch (for dpi) or
+                    //   eCSSUnit_Centimeter (for dpcm)
+    };
+    ValueType mValueType;
+};
+
+class nsMediaFeatures {
+public:
+    enum { COUNT = 10 };
+    static const nsMediaFeature features[COUNT];
+};
+
+#endif /* !defined(nsMediaFeatures_h_) */
