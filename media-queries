Implement Media Queries.  b=156716

diff --git a/content/base/src/nsGkAtomList.h b/content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h
+++ b/content/base/src/nsGkAtomList.h
@@ -103,6 +103,7 @@ GK_ATOM(archive, "archive")
 GK_ATOM(archive, "archive")
 GK_ATOM(area, "area")
 GK_ATOM(ascending, "ascending")
+GK_ATOM(aspectRatio, "aspect-ratio")
 GK_ATOM(assign, "assign")
 GK_ATOM(attribute, "attribute")
 GK_ATOM(attributeSet, "attribute-set")
@@ -196,6 +197,7 @@ GK_ATOM(collapse, "collapse")
 GK_ATOM(collapse, "collapse")
 GK_ATOM(collapsed, "collapsed")
 GK_ATOM(color, "color")
+GK_ATOM(colorIndex, "color-index")
 GK_ATOM(cols, "cols")
 GK_ATOM(colspan, "colspan")
 GK_ATOM(column, "column")
@@ -260,6 +262,9 @@ GK_ATOM(descending, "descending")
 GK_ATOM(descending, "descending")
 GK_ATOM(description, "description")
 GK_ATOM(destructor, "destructor")
+GK_ATOM(deviceAspectRatio, "device-aspect-ratio")
+GK_ATOM(deviceHeight, "device-height")
+GK_ATOM(deviceWidth, "device-width")
 GK_ATOM(dfn, "dfn")
 GK_ATOM(dialog, "dialog")
 GK_ATOM(difference, "difference")
@@ -506,6 +511,7 @@ GK_ATOM(mod, "mod")
 GK_ATOM(mod, "mod")
 GK_ATOM(mode, "mode")
 GK_ATOM(modifiers, "modifiers")
+GK_ATOM(monochrome, "monochrome")
 GK_ATOM(mousedown, "mousedown")
 GK_ATOM(mousemove, "mousemove")
 GK_ATOM(mouseout, "mouseout")
@@ -598,6 +604,7 @@ GK_ATOM(onkeyup, "onkeyup")
 GK_ATOM(onkeyup, "onkeyup")
 GK_ATOM(onLoad, "onLoad")
 GK_ATOM(onload, "onload")
+GK_ATOM(only, "only")               // this one is not an event
 GK_ATOM(onmousedown, "onmousedown")
 GK_ATOM(onmousemove, "onmousemove")
 GK_ATOM(onmouseout, "onmouseout")
@@ -632,6 +639,7 @@ GK_ATOM(order, "order")
 GK_ATOM(order, "order")
 GK_ATOM(ordinal, "ordinal")
 GK_ATOM(orient, "orient")
+GK_ATOM(orientation, "orientation")
 GK_ATOM(otherwise, "otherwise")
 GK_ATOM(output, "output")
 GK_ATOM(overflow, "overflow")
@@ -715,6 +723,7 @@ GK_ATOM(resizeafter, "resizeafter")
 GK_ATOM(resizeafter, "resizeafter")
 GK_ATOM(resizebefore, "resizebefore")
 GK_ATOM(resizer, "resizer")
+GK_ATOM(resolution, "resolution")
 GK_ATOM(resource, "resource")
 GK_ATOM(resources, "resources")
 GK_ATOM(result, "result")
diff --git a/layout/base/nsStyleConsts.h b/layout/base/nsStyleConsts.h
--- a/layout/base/nsStyleConsts.h
+++ b/layout/base/nsStyleConsts.h
@@ -733,4 +733,16 @@
 
 #endif // MOZ_SVG
 
+/*****************************************************************************
+ * Constants for media features.                                             *
+ *****************************************************************************/
+
+// orientation
+#define NS_STYLE_ORIENTATION_PORTRAIT           0
+#define NS_STYLE_ORIENTATION_LANDSCAPE          1
+
+// scan
+#define NS_STYLE_SCAN_PROGRESIVE                0
+#define NS_STYLE_SCAN_INTERLACE                 1
+
 #endif /* nsStyleConsts_h___ */
diff --git a/layout/style/Makefile.in b/layout/style/Makefile.in
--- a/layout/style/Makefile.in
+++ b/layout/style/Makefile.in
@@ -150,6 +150,7 @@ CPPSRCS		= \
 		nsHTMLStyleSheet.cpp \
 		nsInspectorCSSUtils.cpp \
 		nsLayoutStylesheetCache.cpp \
+		nsMediaFeatures.cpp \
 		nsROCSSPrimitiveValue.cpp \
 		nsRuleNode.cpp \
 		nsStyleContext.cpp \
diff --git a/layout/style/nsCSSDeclaration.h b/layout/style/nsCSSDeclaration.h
--- a/layout/style/nsCSSDeclaration.h
+++ b/layout/style/nsCSSDeclaration.h
@@ -158,11 +158,13 @@ private:
   static void AppendImportanceToString(PRBool aIsImportant, nsAString& aString);
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
   PRBool   AppendValueToString(nsCSSProperty aProperty, nsAString& aResult) const;
+public:
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
   static PRBool AppendCSSValueToString(nsCSSProperty aProperty,
                                        const nsCSSValue& aValue,
                                        nsAString& aResult);
 
+private:
   // May be called only for properties whose type is eCSSType_Value.
   nsresult GetValueOrImportantValue(nsCSSProperty aProperty, nsCSSValue& aValue) const;
 
diff --git a/layout/style/nsCSSKeywordList.h b/layout/style/nsCSSKeywordList.h
--- a/layout/style/nsCSSKeywordList.h
+++ b/layout/style/nsCSSKeywordList.h
@@ -290,6 +290,7 @@ CSS_KEY(icon, icon)
 CSS_KEY(icon, icon)
 CSS_KEY(ignore, ignore)
 CSS_KEY(in, in)
+CSS_KEY(interlace, interlace)
 CSS_KEY(inactive, inactive)
 CSS_KEY(inactiveborder, inactiveborder)
 CSS_KEY(inactivecaption, inactivecaption)
@@ -371,6 +372,7 @@ CSS_KEY(pre, pre)
 CSS_KEY(pre, pre)
 CSS_KEY(pre-wrap, pre_wrap)
 CSS_KEY(progress, progress)
+CSS_KEY(progressive, progressive)
 CSS_KEY(pt, pt)
 CSS_KEY(px, px)
 CSS_KEY(rad, rad)
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -83,6 +83,62 @@
 #include "prprf.h"
 #include "math.h"
 
+// Flags for ParseVariant method
+#define VARIANT_KEYWORD         0x000001  // K
+#define VARIANT_LENGTH          0x000002  // L
+#define VARIANT_PERCENT         0x000004  // P
+#define VARIANT_COLOR           0x000008  // C eCSSUnit_Color, eCSSUnit_String (e.g.  "red")
+#define VARIANT_URL             0x000010  // U
+#define VARIANT_NUMBER          0x000020  // N
+#define VARIANT_INTEGER         0x000040  // I
+#define VARIANT_ANGLE           0x000080  // G
+#define VARIANT_FREQUENCY       0x000100  // F
+#define VARIANT_TIME            0x000200  // T
+#define VARIANT_STRING          0x000400  // S
+#define VARIANT_COUNTER         0x000800  // 
+#define VARIANT_ATTR            0x001000  //
+#define VARIANT_IDENTIFIER      0x002000  // D
+#define VARIANT_AUTO            0x010000  // A
+#define VARIANT_INHERIT         0x020000  // H eCSSUnit_Initial, eCSSUnit_Inherit
+#define VARIANT_NONE            0x040000  // O
+#define VARIANT_NORMAL          0x080000  // M
+#define VARIANT_SYSFONT         0x100000  // eCSSUnit_System_Font
+
+// Common combinations of variants
+#define VARIANT_AL   (VARIANT_AUTO | VARIANT_LENGTH)
+#define VARIANT_LP   (VARIANT_LENGTH | VARIANT_PERCENT)
+#define VARIANT_AH   (VARIANT_AUTO | VARIANT_INHERIT)
+#define VARIANT_AHLP (VARIANT_AH | VARIANT_LP)
+#define VARIANT_AHI  (VARIANT_AH | VARIANT_INTEGER)
+#define VARIANT_AHK  (VARIANT_AH | VARIANT_KEYWORD)
+#define VARIANT_AHKLP (VARIANT_AHLP | VARIANT_KEYWORD)
+#define VARIANT_AUK  (VARIANT_AUTO | VARIANT_URL | VARIANT_KEYWORD)
+#define VARIANT_AHUK (VARIANT_AH | VARIANT_URL | VARIANT_KEYWORD)
+#define VARIANT_AHL  (VARIANT_AH | VARIANT_LENGTH)
+#define VARIANT_AHKL (VARIANT_AHK | VARIANT_LENGTH)
+#define VARIANT_HK   (VARIANT_INHERIT | VARIANT_KEYWORD)
+#define VARIANT_HKF  (VARIANT_HK | VARIANT_FREQUENCY)
+#define VARIANT_HKL  (VARIANT_HK | VARIANT_LENGTH)
+#define VARIANT_HKLP (VARIANT_HK | VARIANT_LP)
+#define VARIANT_HKLPO (VARIANT_HKLP | VARIANT_NONE)
+#define VARIANT_HL   (VARIANT_INHERIT | VARIANT_LENGTH)
+#define VARIANT_HI   (VARIANT_INHERIT | VARIANT_INTEGER)
+#define VARIANT_HLP  (VARIANT_HL | VARIANT_PERCENT)
+#define VARIANT_HLPN (VARIANT_HLP | VARIANT_NUMBER)
+#define VARIANT_HLPO (VARIANT_HLP | VARIANT_NONE)
+#define VARIANT_HTP  (VARIANT_INHERIT | VARIANT_TIME | VARIANT_PERCENT)
+#define VARIANT_HMK  (VARIANT_HK | VARIANT_NORMAL)
+#define VARIANT_HMKI (VARIANT_HMK | VARIANT_INTEGER)
+#define VARIANT_HC   (VARIANT_INHERIT | VARIANT_COLOR)
+#define VARIANT_HCK  (VARIANT_HK | VARIANT_COLOR)
+#define VARIANT_HUO  (VARIANT_INHERIT | VARIANT_URL | VARIANT_NONE)
+#define VARIANT_AHUO (VARIANT_AUTO | VARIANT_HUO)
+#define VARIANT_HPN  (VARIANT_INHERIT | VARIANT_PERCENT | VARIANT_NUMBER)
+#define VARIANT_HOK  (VARIANT_HK | VARIANT_NONE)
+#define VARIANT_HN   (VARIANT_INHERIT | VARIANT_NUMBER)
+#define VARIANT_HON  (VARIANT_HN | VARIANT_NONE)
+#define VARIANT_HOS  (VARIANT_INHERIT | VARIANT_NONE | VARIANT_STRING)
+
 //----------------------------------------------------------------------
 
 // Your basic top-down recursive descent style parser
@@ -225,6 +281,7 @@ protected:
   PRBool GatherURL(nsresult& aErrorCode, nsString& aURL);
   PRBool GatherMedia(nsresult& aErrorCode, nsMediaList* aMedia,
                      PRUnichar aStopSymbol);
+  PRBool ParseMediaQueryExpression(nsresult& aErrorCode, nsMediaQuery* aQuery);
   PRBool ProcessImport(nsresult& aErrorCode,
                        const nsString& aURLSpec,
                        nsMediaList* aMedia,
@@ -1070,6 +1127,9 @@ CSSParserImpl::DoParseMediaList(const ns
   }
 
   if (!GatherMedia(rv, aMediaList, PRUnichar(0)) && !mHTMLMediaMode) {
+    // XXX This needs to do better error propagation, and GatherMedia
+    // needs to deal with this potentially still using aMediaList in
+    // case of error.
     OUTPUT_ERROR();
   }
   CLEAR_ERROR();
@@ -1363,38 +1423,198 @@ PRBool CSSParserImpl::GatherMedia(nsresu
                                   PRUnichar aStopSymbol)
 {
   for (;;) {
-    if (!GetToken(aErrorCode, PR_TRUE)) {
-      REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
-      break;
-    }
-    if (eCSSToken_Ident != mToken.mType) {
-      REPORT_UNEXPECTED_TOKEN(PEGatherMediaNotIdent);
-      UngetToken();
-      break;
-    }
-    ToLowerCase(mToken.mIdent);  // case insensitive from CSS - must be lower cased
-    nsCOMPtr<nsIAtom> medium = do_GetAtom(mToken.mIdent);
-    aMedia->AppendAtom(medium);
-
-    if (!GetToken(aErrorCode, PR_TRUE)) {
-      if (aStopSymbol == PRUnichar(0))
-        return PR_TRUE;
-      REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
-      break;
-    }
-
-    if (eCSSToken_Symbol == mToken.mType &&
-        mToken.mSymbol == aStopSymbol) {
-      UngetToken();
-      return PR_TRUE;
-    } else if (eCSSToken_Symbol != mToken.mType ||
-               mToken.mSymbol != ',') {
-      REPORT_UNEXPECTED_TOKEN(PEGatherMediaNotComma);
-      UngetToken();
-      break;
-    }
-  }
-  return PR_FALSE;
+    nsAutoPtr<nsMediaQuery> query(new nsMediaQuery);
+    if (!query) {
+      aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+      return PR_FALSE;
+    }
+
+    // XXX XXX XXX XXX NEED TO HANDLE (expression) without media type!!!
+
+    nsCOMPtr<nsIAtom> mediaType;
+    PRBool gotNotOrOnly = PR_FALSE;
+    for (;;) {
+      if (!GetToken(aErrorCode, PR_TRUE)) {
+        REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
+        return PR_FALSE;
+      }
+      if (eCSSToken_Ident != mToken.mType) {
+        REPORT_UNEXPECTED_TOKEN(PEGatherMediaNotIdent);
+        UngetToken();
+        return PR_FALSE;
+      }
+      // case insensitive from CSS - must be lower cased
+      ToLowerCase(mToken.mIdent);
+      mediaType = do_GetAtom(mToken.mIdent);
+      if (gotNotOrOnly ||
+          (mediaType != nsGkAtoms::_not && mediaType != nsGkAtoms::only))
+        return PR_FALSE;
+      gotNotOrOnly = PR_TRUE;
+      if (mediaType == nsGkAtoms::_not)
+        query->SetNegated();
+      else
+        query->SetHasOnly();
+    }
+    query->SetType(mediaType);
+
+    // XXX WHEN DO WE WANT TO APPEND THIS?
+    aMedia->AppendQuery(query);
+
+    for (;;) {
+      if (!GetToken(aErrorCode, PR_TRUE)) {
+        if (aStopSymbol == PRUnichar(0))
+          return PR_TRUE;
+        REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
+        return PR_FALSE;
+      }
+
+      if (eCSSToken_Symbol == mToken.mType &&
+          mToken.mSymbol == aStopSymbol) {
+        UngetToken();
+        return PR_TRUE;
+      }
+      if (eCSSToken_Symbol == mToken.mType && mToken.mSymbol == ',') {
+        // Done with the expressions for this query
+        break;
+      }
+      if (eCSSToken_Ident != mToken.mType ||
+          !mToken.mIdent.LowerCaseEqualsLiteral("and")) {
+        REPORT_UNEXPECTED_TOKEN(PEGatherMediaNotComma);
+        UngetToken();
+        return PR_FALSE;
+      }
+      if (!ParseMediaQueryExpression(aErrorCode, query)) {
+        query->SetHadUnknownExpression();
+      }
+    }
+  }
+  return PR_FALSE;
+}
+
+PRBool CSSParserImpl::ParseMediaQueryExpression(nsresult& aErrorCode, nsMediaQuery* aQuery)
+{
+  if (!ExpectSymbol(aErrorCode, '(', PR_TRUE)) {
+    // XXX ADD ERROR REPORT
+    return PR_FALSE;
+  }
+  if (! GetToken(aErrorCode, PR_TRUE)) {
+    // XXX ADD ERROR REPORT
+    return PR_FALSE;
+  }
+  if (eCSSToken_Ident != mToken.mType) {
+    // XXX ADD ERROR REPORT
+    SkipUntil(aErrorCode, ')');
+    return PR_FALSE;
+  }
+
+  nsMediaExpression *expr = aQuery->NewExpression();
+  if (!expr) {
+    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    SkipUntil(aErrorCode, ')');
+    return PR_FALSE;
+  }
+
+  // case insensitive from CSS - must be lower cased
+  ToLowerCase(mToken.mIdent);
+  const PRUnichar *featureString;
+  if (StringBeginsWith(mToken.mIdent, NS_LITERAL_STRING("min-"))) {
+    expr->mRange = nsMediaExpression::eMin;
+    featureString = mToken.mIdent.get() + 4;
+  } else if (StringBeginsWith(mToken.mIdent, NS_LITERAL_STRING("max-"))) {
+    expr->mRange = nsMediaExpression::eMax;
+    featureString = mToken.mIdent.get() + 4;
+  } else {
+    expr->mRange = nsMediaExpression::eEqual;
+    featureString = mToken.mIdent.get();
+  }
+
+  nsCOMPtr<nsIAtom> mediaFeatureAtom = do_GetAtom(featureString);
+  const nsMediaFeature *feature = nsMediaFeatures::features;
+  for (; feature->mName; ++feature) {
+    if (*(feature->mName) == mediaFeatureAtom) {
+      break;
+    }
+  }
+  if (feature == feature_end ||
+      (expr->mRange != nsMediaExpression::eEqual) !=
+        (feature->mRangeType == nsMediaFeature::eMinMaxAllowed)) {
+    SkipUntil(aErrorCode, ')');
+    // XXX ADD ERROR REPORT
+    return PR_FALSE;
+  }
+  expr->mFeature = feature;
+
+  if (! GetToken(aErrorCode, PR_TRUE)) {
+    // XXX ADD ERROR REPORT
+    return PR_FALSE;
+  }
+  if (eCSSToken_Symbol != mToken.mType ||
+      (mToken.mSymbol != PRUnichar(':') && mToken.mSymbol != PRUnichar(')'))) {
+    // XXX ADD ERROR REPORT
+    SkipUntil(aErrorCode, ')');
+    return PR_FALSE;
+  }
+
+  if (mToken.mSymbol == PRUnichar(')')) {
+    // All query expressions can be given without a value.
+    expr->mValue.Reset();
+    return PR_TRUE;
+  }
+
+  PRBool rv;
+  // FIXME: enforce restrictions in
+  // http://lists.w3.org/Archives/Public/www-style/2008Mar/0444.html
+  switch (feature->mValueType) {
+    case nsMediaFeature::eLength:
+      rv = ParseVariant(aErrorCode, expr->mValue, VARIANT_LENGTH, nsnull);
+      break;
+    case nsMediaFeature::eInteger:
+      rv = ParseVariant(aErrorCode, expr->mValue, VARIANT_INTEGER, nsnull);
+      break;
+    case nsMediaFeature::eIntRatio:
+      {
+        // XXX This allows whitespace around the '/'.  The spec isn't
+        // clear on whether we should.
+        nsRefPtr<nsCSSValue::Array> a = nsCSSValue::Array::Create(2);
+        if (!a) {
+          aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+          SkipUntil(aErrorCode, ')');
+          return PR_FALSE;
+        }
+        expr->mValue.SetArrayValue(a, eCSSUnit_Array);
+        rv = ParseVariant(aErrorCode, a->Item(0), VARIANT_INTEGER, nsnull) &&
+             ExpectSymbol(aErrorCode, '/', PR_TRUE) &&
+             ParseVariant(aErrorCode, a->Item(1), VARIANT_INTEGER, nsnull);
+      }
+      break;
+    case nsMediaFeature::eResolution:
+      rv = GetToken(aErrorCode, PR_TRUE) && mToken.IsDimension();
+      if (rv) {
+        NS_ASSERTION(!mToken.mIdent.IsEmpty() || mToken.mNumber == 0.0f,
+                     "IsDimension lied");
+        // XXX The spec isn't really clear on whether unitless zero
+        // should be allowed, but we allow it.
+        if (mToken.mIdent.IsEmpty() ||
+            mToken.mIdent.LowerCaseEqualsLiteral("dpi")) {
+          expr->mValue.SetFloatValue(mToken.mNumber, eCSSUnit_Inch);
+        } else if (mToken.mIdent.LowerCaseEqualsLiteral("dpcm")) {
+          expr->mValue.SetFloatValue(mToken.mNumber, eCSSUnit_Centimeter);
+        } else {
+          rv = PR_FALSE;
+        }
+      }
+      break;
+    case nsMediaFeature::eEnumerated:
+      rv = ParseVariant(aErrorCode, expr->mValue, VARIANT_KEYWORD,
+                        feature->mKeywordTable);
+      break;
+  }
+  if (!rv) {
+    // XXX ADD ERROR REPORT
+    return PR_FALSE;
+  }
+
+  return ExpectSymbol(aErrorCode, ')', PR_TRUE);
 }
 
 // Parse a CSS2 import rule: "@import STRING | URL [medium [, medium]]"
@@ -3649,62 +3869,6 @@ CSSParserImpl::DoTransferTempData(nsCSSD
     } break;
   }
 }
-
-// Flags for ParseVariant method
-#define VARIANT_KEYWORD         0x000001  // K
-#define VARIANT_LENGTH          0x000002  // L
-#define VARIANT_PERCENT         0x000004  // P
-#define VARIANT_COLOR           0x000008  // C eCSSUnit_Color, eCSSUnit_String (e.g.  "red")
-#define VARIANT_URL             0x000010  // U
-#define VARIANT_NUMBER          0x000020  // N
-#define VARIANT_INTEGER         0x000040  // I
-#define VARIANT_ANGLE           0x000080  // G
-#define VARIANT_FREQUENCY       0x000100  // F
-#define VARIANT_TIME            0x000200  // T
-#define VARIANT_STRING          0x000400  // S
-#define VARIANT_COUNTER         0x000800  // 
-#define VARIANT_ATTR            0x001000  //
-#define VARIANT_IDENTIFIER      0x002000  // D
-#define VARIANT_AUTO            0x010000  // A
-#define VARIANT_INHERIT         0x020000  // H eCSSUnit_Initial, eCSSUnit_Inherit
-#define VARIANT_NONE            0x040000  // O
-#define VARIANT_NORMAL          0x080000  // M
-#define VARIANT_SYSFONT         0x100000  // eCSSUnit_System_Font
-
-// Common combinations of variants
-#define VARIANT_AL   (VARIANT_AUTO | VARIANT_LENGTH)
-#define VARIANT_LP   (VARIANT_LENGTH | VARIANT_PERCENT)
-#define VARIANT_AH   (VARIANT_AUTO | VARIANT_INHERIT)
-#define VARIANT_AHLP (VARIANT_AH | VARIANT_LP)
-#define VARIANT_AHI  (VARIANT_AH | VARIANT_INTEGER)
-#define VARIANT_AHK  (VARIANT_AH | VARIANT_KEYWORD)
-#define VARIANT_AHKLP (VARIANT_AHLP | VARIANT_KEYWORD)
-#define VARIANT_AUK  (VARIANT_AUTO | VARIANT_URL | VARIANT_KEYWORD)
-#define VARIANT_AHUK (VARIANT_AH | VARIANT_URL | VARIANT_KEYWORD)
-#define VARIANT_AHL  (VARIANT_AH | VARIANT_LENGTH)
-#define VARIANT_AHKL (VARIANT_AHK | VARIANT_LENGTH)
-#define VARIANT_HK   (VARIANT_INHERIT | VARIANT_KEYWORD)
-#define VARIANT_HKF  (VARIANT_HK | VARIANT_FREQUENCY)
-#define VARIANT_HKL  (VARIANT_HK | VARIANT_LENGTH)
-#define VARIANT_HKLP (VARIANT_HK | VARIANT_LP)
-#define VARIANT_HKLPO (VARIANT_HKLP | VARIANT_NONE)
-#define VARIANT_HL   (VARIANT_INHERIT | VARIANT_LENGTH)
-#define VARIANT_HI   (VARIANT_INHERIT | VARIANT_INTEGER)
-#define VARIANT_HLP  (VARIANT_HL | VARIANT_PERCENT)
-#define VARIANT_HLPN (VARIANT_HLP | VARIANT_NUMBER)
-#define VARIANT_HLPO (VARIANT_HLP | VARIANT_NONE)
-#define VARIANT_HTP  (VARIANT_INHERIT | VARIANT_TIME | VARIANT_PERCENT)
-#define VARIANT_HMK  (VARIANT_HK | VARIANT_NORMAL)
-#define VARIANT_HMKI (VARIANT_HMK | VARIANT_INTEGER)
-#define VARIANT_HC   (VARIANT_INHERIT | VARIANT_COLOR)
-#define VARIANT_HCK  (VARIANT_HK | VARIANT_COLOR)
-#define VARIANT_HUO  (VARIANT_INHERIT | VARIANT_URL | VARIANT_NONE)
-#define VARIANT_AHUO (VARIANT_AUTO | VARIANT_HUO)
-#define VARIANT_HPN  (VARIANT_INHERIT | VARIANT_PERCENT | VARIANT_NUMBER)
-#define VARIANT_HOK  (VARIANT_HK | VARIANT_NONE)
-#define VARIANT_HN   (VARIANT_INHERIT | VARIANT_NUMBER)
-#define VARIANT_HON  (VARIANT_HN | VARIANT_NONE)
-#define VARIANT_HOS  (VARIANT_INHERIT | VARIANT_NONE | VARIANT_STRING)
 
 static const nsCSSProperty kBorderTopIDs[] = {
   eCSSProperty_border_top_width,
diff --git a/layout/style/nsCSSStyleSheet.cpp b/layout/style/nsCSSStyleSheet.cpp
--- a/layout/style/nsCSSStyleSheet.cpp
+++ b/layout/style/nsCSSStyleSheet.cpp
@@ -74,6 +74,7 @@
 #include "nsContentUtils.h"
 #include "nsIJSContextStack.h"
 #include "nsIScriptSecurityManager.h"
+#include "nsCSSDeclaration.h"
 
 // -------------------------------
 // Style Rule List for the DOM
@@ -162,6 +163,78 @@ CSSRuleListImpl::Item(PRUint32 aIndex, n
   return result;
 }
 
+void
+nsMediaQuery::AppendToString(nsAString& aString)
+{
+  NS_ASSERTION(!mNegated || !mHasOnly, "can't have not and only");
+  if (mNegated) {
+    aString.AppendLiteral("not ");
+  } else if (mHasOnly) {
+    aString.AppendLiteral("only ");
+  }
+  nsAutoString buffer;
+  mMediaType->ToString(buffer);
+  aString.Append(buffer);
+  buffer.Truncate();
+
+  if (mHadUnknownExpression) {
+    aString.AppendLiteral(" and (unknown-expression)");
+  } else {
+    for (PRUint32 i = 0, i_end = mExpressions.Length(); i < i_end; ++i) {
+      if (i > 0 || !mTypeOmitted)
+        aString.AppendLiteral(" and ");
+      aString.AppendLiteral("(");
+
+      nsMediaExpression &expr = mExpressions[i];
+      if (expr.mRange == nsMediaExpression::eMin) {
+        aString.AppendLiteral("min-");
+      } else if (expr.mRange == nsMediaExpression::eMax) {
+        aString.AppendLiteral("max-");
+      }
+
+      const nsMediaFeature *feature = expr.mFeature;
+      (*feature->mName)->ToString(buffer);
+      aString.Append(buffer);
+      buffer.Truncate();
+
+      // XXX Omit value in some cases?
+      aString.AppendLiteral(": ");
+      switch (feature->mValueType) {
+        case nsMediaFeature::eLength:
+          nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_width,
+                                                   expr.mValue, aString);
+          break;
+        case nsMediaFeature::eInteger:
+          nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
+                                                   expr.mValue, aString);
+          break;
+        case nsMediaFeature::eIntRatio:
+          {
+            nsCSSValue::Array *array = expr.mValue.GetArrayValue();
+            nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
+                                                     array->Item(0), aString);
+            aString.AppendLiteral("/");
+            nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
+                                                     array->Item(1), aString);
+          }
+          break;
+        case nsMediaFeature::eResolution:
+          buffer.AppendFloat(expr.mValue.GetFloatValue());
+          aString.Append(buffer);
+          buffer.Truncate();
+          if (expr.mValue.GetUnit() == eCSSUnit_Inch) {
+            aString.AppendLiteral("dpi");
+          } else {
+            aString.AppendLiteral("dpcm");
+          }
+          break;
+      }
+
+      aString.AppendLiteral(")");
+    }
+  }
+}
+
 NS_INTERFACE_MAP_BEGIN(nsMediaList)
   NS_INTERFACE_MAP_ENTRY(nsIDOMMediaList)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
@@ -186,13 +259,12 @@ nsMediaList::GetText(nsAString& aMediaTe
 {
   aMediaText.Truncate();
 
-  for (PRInt32 i = 0, i_end = mArray.Count(); i < i_end; ++i) {
-    nsIAtom* medium = mArray[i];
-    NS_ENSURE_TRUE(medium, NS_ERROR_FAILURE);
+  for (PRInt32 i = 0, i_end = mArray.Length(); i < i_end; ++i) {
+    nsMediaQuery* query = mArray[i];
+    NS_ENSURE_TRUE(query, NS_ERROR_FAILURE);
 
-    nsAutoString buffer;
-    medium->ToString(buffer);
-    aMediaText.Append(buffer);
+    query->AppendToString(aMediaText);
+
     if (i + 1 < i_end) {
       aMediaText.AppendLiteral(", ");
     }
@@ -309,7 +381,7 @@ nsMediaList::GetLength(PRUint32* aLength
 {
   NS_ENSURE_ARG_POINTER(aLength);
 
-  *aLength = mArray.Count();
+  *aLength = mArray.Length();
   return NS_OK;
 }
 
diff --git a/layout/style/nsIMediaList.h b/layout/style/nsIMediaList.h
--- a/layout/style/nsIMediaList.h
+++ b/layout/style/nsIMediaList.h
@@ -46,11 +46,52 @@
 
 #include "nsIDOMMediaList.h"
 #include "nsAString.h"
-#include "nsCOMArray.h"
+#include "nsTArray.h"
 #include "nsIAtom.h"
+#include "nsMediaFeatures.h"
+#include "nsCSSValue.h"
+
 class nsPresContext;
 class nsICSSStyleSheet;
 class nsCSSStyleSheet;
+
+struct nsMediaExpression {
+  enum Range { eMin, eMax, eEqual };
+
+  const nsMediaFeature *mFeature;
+  Range mRange;
+  nsCSSValue mValue;
+};
+
+class nsMediaQuery {
+public:
+  nsMediaQuery()
+    : mNegated(PR_FALSE)
+    , mHasOnly(PR_FALSE)
+    , mHadUnknownExpression(PR_FALSE)
+  {
+  }
+
+  void SetNegated()                     { mNegated = PR_TRUE; }
+  void SetHasOnly()                     { mHasOnly = PR_TRUE; }
+  void SetHadUnknownExpression()        { mHadUnknownExpression = PR_TRUE; }
+  void SetType(nsIAtom* aMediaType)     { mMediaType = aMediaType; }
+
+  // Return a new nsMediaExpression in the array for the caller to fill
+  // in.  The caller must either fill it in completely, or call
+  // SetHadUnknownExpression on this nsMediaQuery.
+  // Returns null on out-of-memory.
+  nsMediaExpression* NewExpression()    { return mExpressions.AppendElement(); }
+
+  void AppendToString(nsAString& aString);
+
+private:
+  PRPackedBool mNegated;
+  PRPackedBool mHasOnly; // only needed for serialization
+  PRPackedBool mHadUnknownExpression;
+  nsCOMPtr<nsIAtom> mMediaType;
+  nsTArray<nsMediaExpression> mExpressions;
+};
 
 class nsMediaList : public nsIDOMMediaList {
 public:
@@ -64,14 +105,15 @@ public:
   nsresult SetText(const nsAString& aMediaText);
   PRBool Matches(nsPresContext* aPresContext);
   nsresult SetStyleSheet(nsICSSStyleSheet* aSheet);
-  nsresult AppendAtom(nsIAtom* aMediumAtom) {
-    return mArray.AppendObject(aMediumAtom) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+  nsresult AppendQuery(nsMediaQuery *aQuery) {
+    // Takes ownership of aQuery
+    return mArray.AppendElement(aQuery) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
   }
 
   nsresult Clone(nsMediaList** aResult);
 
-  PRInt32 Count() { return mArray.Count(); }
-  nsIAtom* MediumAt(PRInt32 aIndex) { return mArray[aIndex]; }
+  PRInt32 Count() { return mArray.Length(); }
+  nsMediaQuery* MediumAt(PRInt32 aIndex) { return mArray[aIndex]; }
   void Clear() { mArray.Clear(); }
 
 protected:
@@ -80,7 +122,7 @@ protected:
   nsresult Delete(const nsAString & aOldMedium);
   nsresult Append(const nsAString & aOldMedium);
 
-  nsCOMArray<nsIAtom> mArray;
+  nsTArray<nsAutoPtr<nsMediaQuery> > mArray;
   // not refcounted; sheet will let us know when it goes away
   // mStyleSheet is the sheet that needs to be dirtied when this medialist
   // changes
diff --git a/layout/style/nsMediaFeatures.cpp b/layout/style/nsMediaFeatures.cpp
new file mode 100644
--- /dev/null
+++ b/layout/style/nsMediaFeatures.cpp
@@ -0,0 +1,271 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsMediaFeatures.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsMediaFeatures.h"
+#include "nsGkAtoms.h"
+
+static const PRInt32 kOrientationKeywords[] = {
+  eCSSKeyword_portrait,                 NS_STYLE_ORIENTATION_PORTRAIT,
+  eCSSKeyword_landscape,                NS_STYLE_ORIENTATION_LANDSCAPE,
+  eCSSKeyword_UNKNOWN,                  -1
+};
+
+static const PRInt32 kScanKeywords[] = {
+  eCSSKeyword_progressive,              NS_STYLE_SCAN_PROGRESSIVE,
+  eCSSKeyword_interlace,                NS_STYLE_SCAN_INTERLACE,
+  eCSSKeyword_UNKNOWN,                  -1
+};
+
+PR_STATIC_CALLBACK(nsresult)
+GetWidth(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    nscoord width = aPresContext->GetVisibleArea().width;
+    float pixelWidth = aPresContext->AppUnitsToCSSPixels(width);
+    aResult.SetFloatValue(pixelWidth, eCSSUnit_Pixel);
+    return NS_OK;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetHeight(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    nscoord height = aPresContext->GetVisibleArea().height;
+    float pixelHeight = aPresContext->AppUnitsToCSSPixels(height);
+    aResult.SetFloatValue(pixelHeight, eCSSUnit_Pixel);
+    return NS_OK;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetDeviceWidth(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // FIXME: WRITE ME!
+    aResult.Reset();
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetDeviceHeight(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // FIXME: WRITE ME!
+    aResult.Reset();
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetOrientation(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // FIXME: WRITE ME!
+    aResult.Reset();
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetAspectRatio(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    nsRefPtr<nsCSSValue::Array> a = nsCSSValue::Array::Create(2);
+    NS_ENSURE_TRUE(a, NS_ERROR_OUT_OF_MEMORY);
+
+    nsSize size = aPresContext->GetVisibleArea().Size();
+    a->Item(0).SetIntValue(size.width, eCSSUnit_Integer);
+    a->Item(1).SetIntValue(size.height, eCSSUnit_Integer);
+
+    aResult.SetArrayValue(a, eCSSUnit_Array);
+    return NS_OK;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetDeviceAspectRatio(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // FIXME: WRITE ME!
+    aResult.Reset();
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetColor(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // FIXME: WRITE ME!
+    aResult.Reset();
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetColorIndex(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // FIXME: WRITE ME!
+    aResult.Reset();
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetMonochrome(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // FIXME: WRITE ME!
+    aResult.Reset();
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetResolution(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // XXX: The spec isn't clear whether this is CSS pixels or device
+    // pixels.  For now, do device pixels.
+    nsIDeviceContext *dx = aPresContext->DeviceContext();
+    float dpi = float(dx->AppUnitsPerInch()) / float(dx->AppUnitsPerDevPixel());
+    aResult.SetFloatValue(dpi, eCSSUnit_Inch);
+    return NS_OK;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetScan(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // Since Gecko doesn't support the 'tv' media type, the 'scan'
+    // feature is never present.
+    aResult.Reset();
+    return NS_OK;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetGrid(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // Gecko doesn't support grid devices (e.g., ttys), so the 'grid'
+    // feature is always 0.
+    aResult.SetIntValue(0, eCSSUnit_Integer);
+    return NS_OK;
+}
+
+/* static */ const nsMediaFeature
+nsMediaFeatures::features[] = {
+    {
+        &nsGkAtoms::width,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eLength,
+        nsnull,
+        GetWidth
+    },
+    {
+        &nsGkAtoms::height,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eLength,
+        nsnull,
+        GetHeight
+    },
+    {
+        &nsGkAtoms::deviceWidth,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eLength,
+        nsnull,
+        GetDeviceWidth
+    },
+    {
+        &nsGkAtoms::deviceHeight,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eLength,
+        nsnull,
+        GetDeviceHeight
+    },
+    {
+        &nsGkAtoms::orientation,
+        nsMediaFeature::eMinMaxNotAllowed,
+        nsMediaFeature::eEnumerated,
+        kOrientationKeywords,
+        GetOrientation
+    },
+    {
+        &nsGkAtoms::aspectRatio,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eIntRatio,
+        nsnull,
+        GetAspectRatio
+    },
+    {
+        &nsGkAtoms::deviceAspectRatio,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eIntRatio,
+        nsnull,
+        GetDeviceAspectRatio
+    },
+    {
+        &nsGkAtoms::color,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eInteger,
+        nsnull,
+        GetColor
+    },
+    {
+        &nsGkAtoms::colorIndex,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eInteger,
+        nsnull,
+        GetColorIndex
+    },
+    {
+        &nsGkAtoms::monochrome,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eInteger,
+        nsnull,
+        GetMonochrome
+    },
+    {
+        &nsGkAtoms::resolution,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eResolution,
+        nsnull,
+        GetResolution
+    },
+    {
+        &nsGkAtoms::scan,
+        nsMediaFeature::eMinMaxNotAllowed,
+        nsMediaFeature::eEnumerated,
+        kScanKeywords,
+        GetScan
+    },
+    {
+        &nsGkAtoms::grid,
+        nsMediaFeature::eMinMaxNotAllowed,
+        nsMediaFeature::eInteger,
+        nsnull,
+        GetGrid
+    },
+    // Null-mName terminator:
+    {
+        nsnull,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eInteger,
+        nsnull,
+        nsnull
+    },
+};
diff --git a/layout/style/nsMediaFeatures.h b/layout/style/nsMediaFeatures.h
new file mode 100644
--- /dev/null
+++ b/layout/style/nsMediaFeatures.h
@@ -0,0 +1,79 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsMediaFeatures.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsMediaFeatures_h_
+#define nsMediaFeatures_h_
+
+#include "nsIAtom.h"
+
+typedef nsresult
+(* PR_CALLBACK nsMediaFeatureValueGetter)(nsPresContext* aPresContext,
+                                          nsCSSValue& aResult);
+
+struct nsMediaFeature {
+    nsIAtom **mName; // extra indirection to point to nsGkAtoms members
+
+    enum RangeType { eMinMaxAllowed, eMinMaxNotAllowed };
+    RangeType mRangeType;
+
+    enum ValueType {
+        // All value types allow eCSSUnit_Null to indicate that no value
+        // was given (in addition to the types listed below).
+        eLength,     // values are such that nsCSSValue::IsLengthUnit() is true
+        eInteger,    // values are eCSSUnit_Integer
+        eIntRatio,   // values are eCSSUnit_Array of two eCSSUnit_Integer
+        eResolution, // values are in eCSSUnit_Inch (for dpi) or
+                     //   eCSSUnit_Centimeter (for dpcm)
+        eEnumerated  // values are eCSSUnit_Enumerated (uses keyword table)
+    };
+    ValueType mValueType;
+
+    // The same format as the keyword tables in nsCSSProps.
+    static const PRInt32* mKeywordTable;
+
+    // A function that returns the current value for this feature for a
+    // given presentation.  If it returns eCSSUnit_Null, the feature is
+    // not present.
+    nsMediaFeatureValueGetter mGetter;
+};
+
+class nsMediaFeatures {
+public:
+    // Terminated with an entry whose mName is null.
+    static const nsMediaFeature features[];
+};
+
+#endif /* !defined(nsMediaFeatures_h_) */
