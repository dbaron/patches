Implement Media Queries.  b=156716

diff --git a/content/base/src/nsGkAtomList.h b/content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h
+++ b/content/base/src/nsGkAtomList.h
@@ -103,6 +103,7 @@ GK_ATOM(archive, "archive")
 GK_ATOM(archive, "archive")
 GK_ATOM(area, "area")
 GK_ATOM(ascending, "ascending")
+GK_ATOM(aspectRatio, "aspect-ratio")
 GK_ATOM(assign, "assign")
 GK_ATOM(attribute, "attribute")
 GK_ATOM(attributeSet, "attribute-set")
@@ -196,6 +197,7 @@ GK_ATOM(collapse, "collapse")
 GK_ATOM(collapse, "collapse")
 GK_ATOM(collapsed, "collapsed")
 GK_ATOM(color, "color")
+GK_ATOM(colorIndex, "color-index")
 GK_ATOM(cols, "cols")
 GK_ATOM(colspan, "colspan")
 GK_ATOM(column, "column")
@@ -260,6 +262,9 @@ GK_ATOM(descending, "descending")
 GK_ATOM(descending, "descending")
 GK_ATOM(description, "description")
 GK_ATOM(destructor, "destructor")
+GK_ATOM(deviceAspectRatio, "device-aspect-ratio")
+GK_ATOM(deviceHeight, "device-height")
+GK_ATOM(deviceWidth, "device-width")
 GK_ATOM(dfn, "dfn")
 GK_ATOM(dialog, "dialog")
 GK_ATOM(difference, "difference")
@@ -506,6 +511,7 @@ GK_ATOM(mod, "mod")
 GK_ATOM(mod, "mod")
 GK_ATOM(mode, "mode")
 GK_ATOM(modifiers, "modifiers")
+GK_ATOM(monochrome, "monochrome")
 GK_ATOM(mousedown, "mousedown")
 GK_ATOM(mousemove, "mousemove")
 GK_ATOM(mouseout, "mouseout")
@@ -598,6 +604,7 @@ GK_ATOM(onkeyup, "onkeyup")
 GK_ATOM(onkeyup, "onkeyup")
 GK_ATOM(onLoad, "onLoad")
 GK_ATOM(onload, "onload")
+GK_ATOM(only, "only")               // this one is not an event
 GK_ATOM(onmousedown, "onmousedown")
 GK_ATOM(onmousemove, "onmousemove")
 GK_ATOM(onmouseout, "onmouseout")
@@ -632,6 +639,7 @@ GK_ATOM(order, "order")
 GK_ATOM(order, "order")
 GK_ATOM(ordinal, "ordinal")
 GK_ATOM(orient, "orient")
+GK_ATOM(orientation, "orientation")
 GK_ATOM(otherwise, "otherwise")
 GK_ATOM(output, "output")
 GK_ATOM(overflow, "overflow")
@@ -715,6 +723,7 @@ GK_ATOM(resizeafter, "resizeafter")
 GK_ATOM(resizeafter, "resizeafter")
 GK_ATOM(resizebefore, "resizebefore")
 GK_ATOM(resizer, "resizer")
+GK_ATOM(resolution, "resolution")
 GK_ATOM(resource, "resource")
 GK_ATOM(resources, "resources")
 GK_ATOM(result, "result")
@@ -734,6 +743,7 @@ GK_ATOM(rules, "rules")
 GK_ATOM(rules, "rules")
 GK_ATOM(s, "s")
 GK_ATOM(samp, "samp")
+GK_ATOM(scan, "scan")
 GK_ATOM(scheme, "scheme")
 GK_ATOM(scope, "scope")
 GK_ATOM(screen, "screen")
diff --git a/layout/base/nsStyleConsts.h b/layout/base/nsStyleConsts.h
--- a/layout/base/nsStyleConsts.h
+++ b/layout/base/nsStyleConsts.h
@@ -733,4 +733,16 @@
 
 #endif // MOZ_SVG
 
+/*****************************************************************************
+ * Constants for media features.                                             *
+ *****************************************************************************/
+
+// orientation
+#define NS_STYLE_ORIENTATION_PORTRAIT           0
+#define NS_STYLE_ORIENTATION_LANDSCAPE          1
+
+// scan
+#define NS_STYLE_SCAN_PROGRESSIVE               0
+#define NS_STYLE_SCAN_INTERLACE                 1
+
 #endif /* nsStyleConsts_h___ */
diff --git a/layout/style/Makefile.in b/layout/style/Makefile.in
--- a/layout/style/Makefile.in
+++ b/layout/style/Makefile.in
@@ -150,6 +150,7 @@ CPPSRCS		= \
 		nsHTMLStyleSheet.cpp \
 		nsInspectorCSSUtils.cpp \
 		nsLayoutStylesheetCache.cpp \
+		nsMediaFeatures.cpp \
 		nsROCSSPrimitiveValue.cpp \
 		nsRuleNode.cpp \
 		nsStyleContext.cpp \
diff --git a/layout/style/nsCSSDeclaration.h b/layout/style/nsCSSDeclaration.h
--- a/layout/style/nsCSSDeclaration.h
+++ b/layout/style/nsCSSDeclaration.h
@@ -158,11 +158,13 @@ private:
   static void AppendImportanceToString(PRBool aIsImportant, nsAString& aString);
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
   PRBool   AppendValueToString(nsCSSProperty aProperty, nsAString& aResult) const;
+public:
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
   static PRBool AppendCSSValueToString(nsCSSProperty aProperty,
                                        const nsCSSValue& aValue,
                                        nsAString& aResult);
 
+private:
   // May be called only for properties whose type is eCSSType_Value.
   nsresult GetValueOrImportantValue(nsCSSProperty aProperty, nsCSSValue& aValue) const;
 
diff --git a/layout/style/nsCSSKeywordList.h b/layout/style/nsCSSKeywordList.h
--- a/layout/style/nsCSSKeywordList.h
+++ b/layout/style/nsCSSKeywordList.h
@@ -290,6 +290,7 @@ CSS_KEY(icon, icon)
 CSS_KEY(icon, icon)
 CSS_KEY(ignore, ignore)
 CSS_KEY(in, in)
+CSS_KEY(interlace, interlace)
 CSS_KEY(inactive, inactive)
 CSS_KEY(inactiveborder, inactiveborder)
 CSS_KEY(inactivecaption, inactivecaption)
@@ -371,6 +372,7 @@ CSS_KEY(pre, pre)
 CSS_KEY(pre, pre)
 CSS_KEY(pre-wrap, pre_wrap)
 CSS_KEY(progress, progress)
+CSS_KEY(progressive, progressive)
 CSS_KEY(pt, pt)
 CSS_KEY(px, px)
 CSS_KEY(rad, rad)
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -83,6 +83,62 @@
 #include "prprf.h"
 #include "math.h"
 
+// Flags for ParseVariant method
+#define VARIANT_KEYWORD         0x000001  // K
+#define VARIANT_LENGTH          0x000002  // L
+#define VARIANT_PERCENT         0x000004  // P
+#define VARIANT_COLOR           0x000008  // C eCSSUnit_Color, eCSSUnit_String (e.g.  "red")
+#define VARIANT_URL             0x000010  // U
+#define VARIANT_NUMBER          0x000020  // N
+#define VARIANT_INTEGER         0x000040  // I
+#define VARIANT_ANGLE           0x000080  // G
+#define VARIANT_FREQUENCY       0x000100  // F
+#define VARIANT_TIME            0x000200  // T
+#define VARIANT_STRING          0x000400  // S
+#define VARIANT_COUNTER         0x000800  // 
+#define VARIANT_ATTR            0x001000  //
+#define VARIANT_IDENTIFIER      0x002000  // D
+#define VARIANT_AUTO            0x010000  // A
+#define VARIANT_INHERIT         0x020000  // H eCSSUnit_Initial, eCSSUnit_Inherit
+#define VARIANT_NONE            0x040000  // O
+#define VARIANT_NORMAL          0x080000  // M
+#define VARIANT_SYSFONT         0x100000  // eCSSUnit_System_Font
+
+// Common combinations of variants
+#define VARIANT_AL   (VARIANT_AUTO | VARIANT_LENGTH)
+#define VARIANT_LP   (VARIANT_LENGTH | VARIANT_PERCENT)
+#define VARIANT_AH   (VARIANT_AUTO | VARIANT_INHERIT)
+#define VARIANT_AHLP (VARIANT_AH | VARIANT_LP)
+#define VARIANT_AHI  (VARIANT_AH | VARIANT_INTEGER)
+#define VARIANT_AHK  (VARIANT_AH | VARIANT_KEYWORD)
+#define VARIANT_AHKLP (VARIANT_AHLP | VARIANT_KEYWORD)
+#define VARIANT_AUK  (VARIANT_AUTO | VARIANT_URL | VARIANT_KEYWORD)
+#define VARIANT_AHUK (VARIANT_AH | VARIANT_URL | VARIANT_KEYWORD)
+#define VARIANT_AHL  (VARIANT_AH | VARIANT_LENGTH)
+#define VARIANT_AHKL (VARIANT_AHK | VARIANT_LENGTH)
+#define VARIANT_HK   (VARIANT_INHERIT | VARIANT_KEYWORD)
+#define VARIANT_HKF  (VARIANT_HK | VARIANT_FREQUENCY)
+#define VARIANT_HKL  (VARIANT_HK | VARIANT_LENGTH)
+#define VARIANT_HKLP (VARIANT_HK | VARIANT_LP)
+#define VARIANT_HKLPO (VARIANT_HKLP | VARIANT_NONE)
+#define VARIANT_HL   (VARIANT_INHERIT | VARIANT_LENGTH)
+#define VARIANT_HI   (VARIANT_INHERIT | VARIANT_INTEGER)
+#define VARIANT_HLP  (VARIANT_HL | VARIANT_PERCENT)
+#define VARIANT_HLPN (VARIANT_HLP | VARIANT_NUMBER)
+#define VARIANT_HLPO (VARIANT_HLP | VARIANT_NONE)
+#define VARIANT_HTP  (VARIANT_INHERIT | VARIANT_TIME | VARIANT_PERCENT)
+#define VARIANT_HMK  (VARIANT_HK | VARIANT_NORMAL)
+#define VARIANT_HMKI (VARIANT_HMK | VARIANT_INTEGER)
+#define VARIANT_HC   (VARIANT_INHERIT | VARIANT_COLOR)
+#define VARIANT_HCK  (VARIANT_HK | VARIANT_COLOR)
+#define VARIANT_HUO  (VARIANT_INHERIT | VARIANT_URL | VARIANT_NONE)
+#define VARIANT_AHUO (VARIANT_AUTO | VARIANT_HUO)
+#define VARIANT_HPN  (VARIANT_INHERIT | VARIANT_PERCENT | VARIANT_NUMBER)
+#define VARIANT_HOK  (VARIANT_HK | VARIANT_NONE)
+#define VARIANT_HN   (VARIANT_INHERIT | VARIANT_NUMBER)
+#define VARIANT_HON  (VARIANT_HN | VARIANT_NONE)
+#define VARIANT_HOS  (VARIANT_INHERIT | VARIANT_NONE | VARIANT_STRING)
+
 //----------------------------------------------------------------------
 
 // Your basic top-down recursive descent style parser
@@ -225,6 +281,7 @@ protected:
   PRBool GatherURL(nsresult& aErrorCode, nsString& aURL);
   PRBool GatherMedia(nsresult& aErrorCode, nsMediaList* aMedia,
                      PRUnichar aStopSymbol);
+  PRBool ParseMediaQueryExpression(nsresult& aErrorCode, nsMediaQuery* aQuery);
   PRBool ProcessImport(nsresult& aErrorCode,
                        const nsString& aURLSpec,
                        nsMediaList* aMedia,
@@ -1070,6 +1127,9 @@ CSSParserImpl::DoParseMediaList(const ns
   }
 
   if (!GatherMedia(rv, aMediaList, PRUnichar(0)) && !mHTMLMediaMode) {
+    // XXX This needs to do better error propagation, and GatherMedia
+    // needs to deal with this potentially still using aMediaList in
+    // case of error.
     OUTPUT_ERROR();
   }
   CLEAR_ERROR();
@@ -1363,38 +1423,213 @@ PRBool CSSParserImpl::GatherMedia(nsresu
                                   PRUnichar aStopSymbol)
 {
   for (;;) {
-    if (!GetToken(aErrorCode, PR_TRUE)) {
-      REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
-      break;
-    }
-    if (eCSSToken_Ident != mToken.mType) {
-      REPORT_UNEXPECTED_TOKEN(PEGatherMediaNotIdent);
-      UngetToken();
-      break;
-    }
-    ToLowerCase(mToken.mIdent);  // case insensitive from CSS - must be lower cased
-    nsCOMPtr<nsIAtom> medium = do_GetAtom(mToken.mIdent);
-    aMedia->AppendAtom(medium);
-
-    if (!GetToken(aErrorCode, PR_TRUE)) {
-      if (aStopSymbol == PRUnichar(0))
-        return PR_TRUE;
-      REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
-      break;
-    }
-
-    if (eCSSToken_Symbol == mToken.mType &&
-        mToken.mSymbol == aStopSymbol) {
-      UngetToken();
-      return PR_TRUE;
-    } else if (eCSSToken_Symbol != mToken.mType ||
-               mToken.mSymbol != ',') {
-      REPORT_UNEXPECTED_TOKEN(PEGatherMediaNotComma);
-      UngetToken();
-      break;
-    }
-  }
-  return PR_FALSE;
+    nsAutoPtr<nsMediaQuery> queryHolder(new nsMediaQuery);
+    if (!queryHolder) {
+      aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+      return PR_FALSE;
+    }
+    nsMediaQuery *query = queryHolder;
+
+    if (ExpectSymbol(aErrorCode, '(', PR_TRUE)) {
+      // we got an expression without a media type
+      UngetToken(); // so ParseMediaQueryExpression can handle it
+      query->SetType(nsGkAtoms::all);
+      query->SetTypeOmitted();
+      // Just parse the first expression here.
+      if (!ParseMediaQueryExpression(aErrorCode, query)) {
+        query->SetHadUnknownExpression();
+      }
+    } else {
+      nsCOMPtr<nsIAtom> mediaType;
+      PRBool gotNotOrOnly = PR_FALSE;
+      for (;;) {
+        if (!GetToken(aErrorCode, PR_TRUE)) {
+          REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
+          return PR_FALSE;
+        }
+        if (eCSSToken_Ident != mToken.mType) {
+          REPORT_UNEXPECTED_TOKEN(PEGatherMediaNotIdent);
+          UngetToken();
+          return PR_FALSE;
+        }
+        // case insensitive from CSS - must be lower cased
+        ToLowerCase(mToken.mIdent);
+        mediaType = do_GetAtom(mToken.mIdent);
+        if (gotNotOrOnly ||
+            (mediaType != nsGkAtoms::_not && mediaType != nsGkAtoms::only))
+          break;
+        gotNotOrOnly = PR_TRUE;
+        if (mediaType == nsGkAtoms::_not)
+          query->SetNegated();
+        else
+          query->SetHasOnly();
+      }
+      query->SetType(mediaType);
+    }
+
+    // XXX WHEN DO WE WANT TO APPEND THIS?
+    nsresult rv = aMedia->AppendQuery(query);
+    if (NS_FAILED(rv)) {
+      aErrorCode = rv;
+      return PR_FALSE;
+    }
+    queryHolder.forget(); // aMedia now owns query
+
+    for (;;) {
+      if (!GetToken(aErrorCode, PR_TRUE)) {
+        if (aStopSymbol == PRUnichar(0))
+          return PR_TRUE;
+        REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
+        return PR_FALSE;
+      }
+
+      if (eCSSToken_Symbol == mToken.mType &&
+          mToken.mSymbol == aStopSymbol) {
+        UngetToken();
+        return PR_TRUE;
+      }
+      if (eCSSToken_Symbol == mToken.mType && mToken.mSymbol == ',') {
+        // Done with the expressions for this query
+        break;
+      }
+      if (eCSSToken_Ident != mToken.mType ||
+          !mToken.mIdent.LowerCaseEqualsLiteral("and")) {
+        REPORT_UNEXPECTED_TOKEN(PEGatherMediaNotComma);
+        UngetToken();
+        return PR_FALSE;
+      }
+      if (!ParseMediaQueryExpression(aErrorCode, query)) {
+        query->SetHadUnknownExpression();
+      }
+    }
+  }
+  return PR_FALSE;
+}
+
+PRBool CSSParserImpl::ParseMediaQueryExpression(nsresult& aErrorCode, nsMediaQuery* aQuery)
+{
+  if (!ExpectSymbol(aErrorCode, '(', PR_TRUE)) {
+    // XXX ADD ERROR REPORT
+    return PR_FALSE;
+  }
+  if (! GetToken(aErrorCode, PR_TRUE)) {
+    // XXX ADD ERROR REPORT
+    return PR_FALSE;
+  }
+  if (eCSSToken_Ident != mToken.mType) {
+    // XXX ADD ERROR REPORT
+    SkipUntil(aErrorCode, ')');
+    return PR_FALSE;
+  }
+
+  nsMediaExpression *expr = aQuery->NewExpression();
+  if (!expr) {
+    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    SkipUntil(aErrorCode, ')');
+    return PR_FALSE;
+  }
+
+  // case insensitive from CSS - must be lower cased
+  ToLowerCase(mToken.mIdent);
+  const PRUnichar *featureString;
+  if (StringBeginsWith(mToken.mIdent, NS_LITERAL_STRING("min-"))) {
+    expr->mRange = nsMediaExpression::eMin;
+    featureString = mToken.mIdent.get() + 4;
+  } else if (StringBeginsWith(mToken.mIdent, NS_LITERAL_STRING("max-"))) {
+    expr->mRange = nsMediaExpression::eMax;
+    featureString = mToken.mIdent.get() + 4;
+  } else {
+    expr->mRange = nsMediaExpression::eEqual;
+    featureString = mToken.mIdent.get();
+  }
+
+  nsCOMPtr<nsIAtom> mediaFeatureAtom = do_GetAtom(featureString);
+  const nsMediaFeature *feature = nsMediaFeatures::features;
+  for (; feature->mName; ++feature) {
+    if (*(feature->mName) == mediaFeatureAtom) {
+      break;
+    }
+  }
+  if (!feature->mName ||
+      (expr->mRange != nsMediaExpression::eEqual) !=
+        (feature->mRangeType == nsMediaFeature::eMinMaxAllowed)) {
+    SkipUntil(aErrorCode, ')');
+    // XXX ADD ERROR REPORT
+    return PR_FALSE;
+  }
+  expr->mFeature = feature;
+
+  if (! GetToken(aErrorCode, PR_TRUE)) {
+    // XXX ADD ERROR REPORT
+    return PR_FALSE;
+  }
+  if (eCSSToken_Symbol != mToken.mType ||
+      (mToken.mSymbol != PRUnichar(':') && mToken.mSymbol != PRUnichar(')'))) {
+    // XXX ADD ERROR REPORT
+    SkipUntil(aErrorCode, ')');
+    return PR_FALSE;
+  }
+
+  if (mToken.mSymbol == PRUnichar(')')) {
+    // All query expressions can be given without a value.
+    expr->mValue.Reset();
+    return PR_TRUE;
+  }
+
+  PRBool rv;
+  // FIXME: enforce restrictions in
+  // http://lists.w3.org/Archives/Public/www-style/2008Mar/0444.html
+  switch (feature->mValueType) {
+    case nsMediaFeature::eLength:
+      rv = ParseVariant(aErrorCode, expr->mValue, VARIANT_LENGTH, nsnull);
+      break;
+    case nsMediaFeature::eInteger:
+      rv = ParseVariant(aErrorCode, expr->mValue, VARIANT_INTEGER, nsnull);
+      break;
+    case nsMediaFeature::eIntRatio:
+      {
+        // XXX This allows whitespace around the '/'.  The spec isn't
+        // clear on whether we should.
+        nsRefPtr<nsCSSValue::Array> a = nsCSSValue::Array::Create(2);
+        if (!a) {
+          aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+          SkipUntil(aErrorCode, ')');
+          return PR_FALSE;
+        }
+        expr->mValue.SetArrayValue(a, eCSSUnit_Array);
+        rv = ParseVariant(aErrorCode, a->Item(0), VARIANT_INTEGER, nsnull) &&
+             ExpectSymbol(aErrorCode, '/', PR_TRUE) &&
+             ParseVariant(aErrorCode, a->Item(1), VARIANT_INTEGER, nsnull);
+      }
+      break;
+    case nsMediaFeature::eResolution:
+      rv = GetToken(aErrorCode, PR_TRUE) && mToken.IsDimension();
+      if (rv) {
+        NS_ASSERTION(!mToken.mIdent.IsEmpty() || mToken.mNumber == 0.0f,
+                     "IsDimension lied");
+        // XXX The spec isn't really clear on whether unitless zero
+        // should be allowed, but we allow it.
+        if (mToken.mIdent.IsEmpty() ||
+            mToken.mIdent.LowerCaseEqualsLiteral("dpi")) {
+          expr->mValue.SetFloatValue(mToken.mNumber, eCSSUnit_Inch);
+        } else if (mToken.mIdent.LowerCaseEqualsLiteral("dpcm")) {
+          expr->mValue.SetFloatValue(mToken.mNumber, eCSSUnit_Centimeter);
+        } else {
+          rv = PR_FALSE;
+        }
+      }
+      break;
+    case nsMediaFeature::eEnumerated:
+      rv = ParseVariant(aErrorCode, expr->mValue, VARIANT_KEYWORD,
+                        feature->mKeywordTable);
+      break;
+  }
+  if (!rv) {
+    // XXX ADD ERROR REPORT
+    return PR_FALSE;
+  }
+
+  return ExpectSymbol(aErrorCode, ')', PR_TRUE);
 }
 
 // Parse a CSS2 import rule: "@import STRING | URL [medium [, medium]]"
@@ -3647,62 +3882,6 @@ CSSParserImpl::DoTransferTempData(nsCSSD
     } break;
   }
 }
-
-// Flags for ParseVariant method
-#define VARIANT_KEYWORD         0x000001  // K
-#define VARIANT_LENGTH          0x000002  // L
-#define VARIANT_PERCENT         0x000004  // P
-#define VARIANT_COLOR           0x000008  // C eCSSUnit_Color, eCSSUnit_String (e.g.  "red")
-#define VARIANT_URL             0x000010  // U
-#define VARIANT_NUMBER          0x000020  // N
-#define VARIANT_INTEGER         0x000040  // I
-#define VARIANT_ANGLE           0x000080  // G
-#define VARIANT_FREQUENCY       0x000100  // F
-#define VARIANT_TIME            0x000200  // T
-#define VARIANT_STRING          0x000400  // S
-#define VARIANT_COUNTER         0x000800  // 
-#define VARIANT_ATTR            0x001000  //
-#define VARIANT_IDENTIFIER      0x002000  // D
-#define VARIANT_AUTO            0x010000  // A
-#define VARIANT_INHERIT         0x020000  // H eCSSUnit_Initial, eCSSUnit_Inherit
-#define VARIANT_NONE            0x040000  // O
-#define VARIANT_NORMAL          0x080000  // M
-#define VARIANT_SYSFONT         0x100000  // eCSSUnit_System_Font
-
-// Common combinations of variants
-#define VARIANT_AL   (VARIANT_AUTO | VARIANT_LENGTH)
-#define VARIANT_LP   (VARIANT_LENGTH | VARIANT_PERCENT)
-#define VARIANT_AH   (VARIANT_AUTO | VARIANT_INHERIT)
-#define VARIANT_AHLP (VARIANT_AH | VARIANT_LP)
-#define VARIANT_AHI  (VARIANT_AH | VARIANT_INTEGER)
-#define VARIANT_AHK  (VARIANT_AH | VARIANT_KEYWORD)
-#define VARIANT_AHKLP (VARIANT_AHLP | VARIANT_KEYWORD)
-#define VARIANT_AUK  (VARIANT_AUTO | VARIANT_URL | VARIANT_KEYWORD)
-#define VARIANT_AHUK (VARIANT_AH | VARIANT_URL | VARIANT_KEYWORD)
-#define VARIANT_AHL  (VARIANT_AH | VARIANT_LENGTH)
-#define VARIANT_AHKL (VARIANT_AHK | VARIANT_LENGTH)
-#define VARIANT_HK   (VARIANT_INHERIT | VARIANT_KEYWORD)
-#define VARIANT_HKF  (VARIANT_HK | VARIANT_FREQUENCY)
-#define VARIANT_HKL  (VARIANT_HK | VARIANT_LENGTH)
-#define VARIANT_HKLP (VARIANT_HK | VARIANT_LP)
-#define VARIANT_HKLPO (VARIANT_HKLP | VARIANT_NONE)
-#define VARIANT_HL   (VARIANT_INHERIT | VARIANT_LENGTH)
-#define VARIANT_HI   (VARIANT_INHERIT | VARIANT_INTEGER)
-#define VARIANT_HLP  (VARIANT_HL | VARIANT_PERCENT)
-#define VARIANT_HLPN (VARIANT_HLP | VARIANT_NUMBER)
-#define VARIANT_HLPO (VARIANT_HLP | VARIANT_NONE)
-#define VARIANT_HTP  (VARIANT_INHERIT | VARIANT_TIME | VARIANT_PERCENT)
-#define VARIANT_HMK  (VARIANT_HK | VARIANT_NORMAL)
-#define VARIANT_HMKI (VARIANT_HMK | VARIANT_INTEGER)
-#define VARIANT_HC   (VARIANT_INHERIT | VARIANT_COLOR)
-#define VARIANT_HCK  (VARIANT_HK | VARIANT_COLOR)
-#define VARIANT_HUO  (VARIANT_INHERIT | VARIANT_URL | VARIANT_NONE)
-#define VARIANT_AHUO (VARIANT_AUTO | VARIANT_HUO)
-#define VARIANT_HPN  (VARIANT_INHERIT | VARIANT_PERCENT | VARIANT_NUMBER)
-#define VARIANT_HOK  (VARIANT_HK | VARIANT_NONE)
-#define VARIANT_HN   (VARIANT_INHERIT | VARIANT_NUMBER)
-#define VARIANT_HON  (VARIANT_HN | VARIANT_NONE)
-#define VARIANT_HOS  (VARIANT_INHERIT | VARIANT_NONE | VARIANT_STRING)
 
 static const nsCSSProperty kBorderTopIDs[] = {
   eCSSProperty_border_top_width,
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -2293,6 +2293,8 @@ nsCSSRuleProcessor::GetRuleCascade(nsPre
   // (@-moz-document).)  Things will get a little more complicated if
   // we implement media queries, though.
 
+  // FIXME: per-medium caching is now invalid; fix using boundary
+  // conditions per feature
   RuleCascadeData **cascadep = &mRuleCascades;
   RuleCascadeData *cascade;
   nsIAtom *medium = aPresContext->Medium();
diff --git a/layout/style/nsCSSStyleSheet.cpp b/layout/style/nsCSSStyleSheet.cpp
--- a/layout/style/nsCSSStyleSheet.cpp
+++ b/layout/style/nsCSSStyleSheet.cpp
@@ -74,6 +74,8 @@
 #include "nsContentUtils.h"
 #include "nsIJSContextStack.h"
 #include "nsIScriptSecurityManager.h"
+#include "nsCSSDeclaration.h"
+#include "nsRuleNode.h"
 
 // -------------------------------
 // Style Rule List for the DOM
@@ -162,6 +164,251 @@ CSSRuleListImpl::Item(PRUint32 aIndex, n
   return result;
 }
 
+void
+nsMediaQuery::AppendToString(nsAString& aString) const
+{
+  nsAutoString buffer;
+
+  NS_ASSERTION(!mNegated || !mHasOnly, "can't have not and only");
+  NS_ASSERTION(!mTypeOmitted || (!mNegated && !mHasOnly),
+               "can't have not or only when type is omitted");
+  if (!mTypeOmitted) {
+    if (mNegated) {
+      aString.AppendLiteral("not ");
+    } else if (mHasOnly) {
+      aString.AppendLiteral("only ");
+    }
+    mMediaType->ToString(buffer);
+    aString.Append(buffer);
+    buffer.Truncate();
+  }
+
+  if (mHadUnknownExpression) {
+    // FIXME: I heard anne mention there was something specific we
+    // should do here.
+    aString.AppendLiteral(" and (unknown-expression)");
+  } else {
+    for (PRUint32 i = 0, i_end = mExpressions.Length(); i < i_end; ++i) {
+      if (i > 0 || !mTypeOmitted)
+        aString.AppendLiteral(" and ");
+      aString.AppendLiteral("(");
+
+      const nsMediaExpression &expr = mExpressions[i];
+      if (expr.mRange == nsMediaExpression::eMin) {
+        aString.AppendLiteral("min-");
+      } else if (expr.mRange == nsMediaExpression::eMax) {
+        aString.AppendLiteral("max-");
+      }
+
+      const nsMediaFeature *feature = expr.mFeature;
+      (*feature->mName)->ToString(buffer);
+      aString.Append(buffer);
+      buffer.Truncate();
+
+      if (expr.mValue.GetUnit() != eCSSUnit_Null) {
+        aString.AppendLiteral(": ");
+        switch (feature->mValueType) {
+          case nsMediaFeature::eLength:
+            NS_ASSERTION(expr.mValue.IsLengthUnit(), "bad unit");
+            nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_width,
+                                                     expr.mValue, aString);
+            break;
+          case nsMediaFeature::eInteger:
+            NS_ASSERTION(expr.mValue.GetUnit() == eCSSUnit_Integer,
+                         "bad unit");
+            nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
+                                                     expr.mValue, aString);
+            break;
+          case nsMediaFeature::eIntRatio:
+            {
+              NS_ASSERTION(expr.mValue.GetUnit() == eCSSUnit_Array,
+                           "bad unit");
+              nsCSSValue::Array *array = expr.mValue.GetArrayValue();
+              NS_ASSERTION(array->Item(0).GetUnit() == eCSSUnit_Integer,
+                           "bad unit");
+              NS_ASSERTION(array->Item(1).GetUnit() == eCSSUnit_Integer,
+                           "bad unit");
+              nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
+                                                       array->Item(0), aString);
+              aString.AppendLiteral("/");
+              nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
+                                                       array->Item(1), aString);
+            }
+            break;
+          case nsMediaFeature::eResolution:
+            buffer.AppendFloat(expr.mValue.GetFloatValue());
+            aString.Append(buffer);
+            buffer.Truncate();
+            if (expr.mValue.GetUnit() == eCSSUnit_Inch) {
+              aString.AppendLiteral("dpi");
+            } else {
+              NS_ASSERTION(expr.mValue.GetUnit() == eCSSUnit_Centimeter,
+                           "bad unit");
+              aString.AppendLiteral("dpcm");
+            }
+            break;
+          case nsMediaFeature::eEnumerated:
+            NS_ASSERTION(expr.mValue.GetUnit() == eCSSUnit_Enumerated,
+                         "bad unit");
+            AppendASCIItoUTF16(
+                nsCSSProps::ValueToKeyword(expr.mValue.GetIntValue(),
+                                           feature->mKeywordTable),
+                aString);
+            break;
+        }
+      }
+
+      aString.AppendLiteral(")");
+    }
+  }
+}
+
+nsMediaQuery*
+nsMediaQuery::Clone() const
+{
+  nsAutoPtr<nsMediaQuery> result(new nsMediaQuery(*this));
+  NS_ENSURE_TRUE(result &&
+                   result->mExpressions.Length() == mExpressions.Length(),
+                 nsnull);
+  return result.forget();
+}
+
+template <class Numeric>
+PRInt32 DoCompare(Numeric a, Numeric b)
+{
+  if (a == b)
+    return 0;
+  if (a < b)
+    return -1;
+  return 1;
+}
+
+PRBool
+nsMediaQuery::Matches(nsPresContext* aPresContext) const
+{
+  if (mHadUnknownExpression)
+    return PR_FALSE;
+
+  PRBool match =
+    mMediaType == aPresContext->Medium() || mMediaType == nsGkAtoms::all;
+  // FIXME: ADD CACHING OF BOUNDARIES, AND THEN USE THAT TO HANDLE DYNAMIC
+  // CHANGES!
+  for (PRUint32 i = 0, i_end = mExpressions.Length(); match && i < i_end; ++i) {
+    const nsMediaExpression &expr = mExpressions[i];
+      const nsMediaFeature *feature = expr.mFeature;
+    nsCSSValue actual;
+    nsresult rv = (feature->mGetter)(aPresContext, actual);
+    NS_ENSURE_SUCCESS(rv, PR_FALSE); // any better ideas?
+    // If we don't have the feature, the match fails.
+    if (actual.GetUnit() == eCSSUnit_Null) {
+      match = PR_FALSE;
+      continue;
+    }
+
+    // If the expression had no value to match, the match succeeds,
+    // unless the value is an integer 0.
+    const nsCSSValue required = expr.mValue;
+    if (required.GetUnit() == eCSSUnit_Null) {
+      match = actual.GetUnit() != eCSSUnit_Integer ||
+              actual.GetIntValue() != 0;
+      continue;
+    }
+
+    NS_ASSERTION(feature->mRangeType == nsMediaFeature::eMinMaxAllowed ||
+                 expr.mRange == nsMediaExpression::eEqual, "yikes");
+    PRInt32 cmp; // -1 (actual < required)
+                 //  0 (actual == required)
+                 //  1 (actual > required)
+    switch (feature->mValueType) {
+      case nsMediaFeature::eLength:
+        {
+          NS_ASSERTION(actual.IsLengthUnit(), "bad actual value");
+          NS_ASSERTION(required.IsLengthUnit(), "bad required value");
+          nscoord actualCoord = nsRuleNode::CalcLengthWithInitialFont(
+                                  aPresContext, actual);
+          nscoord requiredCoord = nsRuleNode::CalcLengthWithInitialFont(
+                                    aPresContext, required);
+          cmp = DoCompare(actualCoord, requiredCoord);
+        }
+        break;
+      case nsMediaFeature::eInteger:
+        {
+          NS_ASSERTION(actual.GetUnit() == eCSSUnit_Integer,
+                       "bad actual value");
+          NS_ASSERTION(required.GetUnit() == eCSSUnit_Integer,
+                       "bad required value");
+          cmp = DoCompare(actual.GetIntValue(), required.GetIntValue());
+        }
+        break;
+      case nsMediaFeature::eIntRatio:
+        {
+          NS_ASSERTION(actual.GetUnit() == eCSSUnit_Array &&
+                       actual.GetArrayValue()->Item(0).GetUnit() ==
+                         eCSSUnit_Integer &&
+                       actual.GetArrayValue()->Item(1).GetUnit() ==
+                         eCSSUnit_Integer,
+                       "bad actual value");
+          NS_ASSERTION(required.GetUnit() == eCSSUnit_Array &&
+                       required.GetArrayValue()->Item(0).GetUnit() ==
+                         eCSSUnit_Integer &&
+                       required.GetArrayValue()->Item(1).GetUnit() ==
+                         eCSSUnit_Integer,
+                       "bad required value");
+          // Convert to PRInt64 so we can multiply without worry
+          PRInt64 actualNum = actual.GetArrayValue()->Item(0).GetIntValue(),
+                  actualDen = actual.GetArrayValue()->Item(1).GetIntValue(),
+                  requiredNum = required.GetArrayValue()->Item(0).GetIntValue(),
+                  requiredDen = required.GetArrayValue()->Item(1).GetIntValue();
+          cmp = DoCompare(actualNum * requiredDen, requiredNum * actualDen);
+        }
+        break;
+      case nsMediaFeature::eResolution:
+        {
+          NS_ASSERTION(actual.GetUnit() == eCSSUnit_Inch ||
+                       actual.GetUnit() == eCSSUnit_Centimeter,
+                       "bad actual value");
+          NS_ASSERTION(required.GetUnit() == eCSSUnit_Inch ||
+                       required.GetUnit() == eCSSUnit_Centimeter,
+                       "bad required value");
+          float actualDPI = actual.GetFloatValue();
+          if (actual.GetUnit() == eCSSUnit_Centimeter)
+            actualDPI = actualDPI / 2.54f;
+          float requiredDPI = required.GetFloatValue();
+          if (required.GetUnit() == eCSSUnit_Centimeter)
+            requiredDPI = requiredDPI / 2.54f;
+          cmp = DoCompare(actualDPI, requiredDPI);
+        }
+        break;
+      case nsMediaFeature::eEnumerated:
+        {
+          NS_ASSERTION(actual.GetUnit() == eCSSUnit_Enumerated,
+                       "bad actual value");
+          NS_ASSERTION(required.GetUnit() == eCSSUnit_Enumerated,
+                       "bad required value");
+          NS_ASSERTION(feature->mRangeType == nsMediaFeature::eMinMaxNotAllowed,
+                       "bad range"); // we asserted above about expr.mRange
+          // We don't really need DoCompare, but it doesn't hurt (and
+          // maybe the compiler will condense this case with eInteger).
+          cmp = DoCompare(actual.GetIntValue(), required.GetIntValue());
+        }
+        break;
+    }
+    switch (expr.mRange) {
+      case nsMediaExpression::eMin:
+        match = cmp != -1;
+        break;
+      case nsMediaExpression::eMax:
+        match = cmp != 1;
+        break;
+      case nsMediaExpression::eEqual:
+        match = cmp == 0;
+        break;
+    }
+  }
+
+  return match == !mNegated;
+}
+
 NS_INTERFACE_MAP_BEGIN(nsMediaList)
   NS_INTERFACE_MAP_ENTRY(nsIDOMMediaList)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
@@ -186,13 +433,12 @@ nsMediaList::GetText(nsAString& aMediaTe
 {
   aMediaText.Truncate();
 
-  for (PRInt32 i = 0, i_end = mArray.Count(); i < i_end; ++i) {
-    nsIAtom* medium = mArray[i];
-    NS_ENSURE_TRUE(medium, NS_ERROR_FAILURE);
+  for (PRInt32 i = 0, i_end = mArray.Length(); i < i_end; ++i) {
+    nsMediaQuery* query = mArray[i];
+    NS_ENSURE_TRUE(query, NS_ERROR_FAILURE);
 
-    nsAutoString buffer;
-    medium->ToString(buffer);
-    aMediaText.Append(buffer);
+    query->AppendToString(aMediaText);
+
     if (i + 1 < i_end) {
       aMediaText.AppendLiteral(", ");
     }
@@ -223,18 +469,15 @@ nsMediaList::SetText(const nsAString& aM
                                 this, htmlMode);
 }
 
-/*
- * aMatch is true when we contain the desired medium or contain the
- * "all" medium or contain no media at all, which is the same as
- * containing "all"
- */
 PRBool
 nsMediaList::Matches(nsPresContext* aPresContext)
 {
-  if (-1 != mArray.IndexOf(aPresContext->Medium()) ||
-      -1 != mArray.IndexOf(nsGkAtoms::all))
-    return PR_TRUE;
-  return mArray.Count() == 0;
+  for (PRInt32 i = 0, i_end = mArray.Length(); i < i_end; ++i) {
+    if (mArray[i]->Matches(aPresContext)) {
+      return PR_TRUE;
+    }
+  }
+  return mArray.Length() == 0;
 }
 
 nsresult
@@ -250,10 +493,13 @@ nsMediaList::Clone(nsMediaList** aResult
 nsMediaList::Clone(nsMediaList** aResult)
 {
   nsRefPtr<nsMediaList> result = new nsMediaList();
-  if (!result)
+  if (!result || !result->mArray.SetCapacity(mArray.Length()))
     return NS_ERROR_OUT_OF_MEMORY;
-  if (!result->mArray.AppendObjects(mArray))
-    return NS_ERROR_OUT_OF_MEMORY;
+  for (PRInt32 i = 0, i_end = mArray.Length(); i < i_end; ++i) {
+    if (!(result->mArray[i] = mArray[i]->Clone())) {
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+  }
   NS_ADDREF(*aResult = result);
   return NS_OK;
 }
@@ -309,7 +555,7 @@ nsMediaList::GetLength(PRUint32* aLength
 {
   NS_ENSURE_ARG_POINTER(aLength);
 
-  *aLength = mArray.Count();
+  *aLength = mArray.Length();
   return NS_OK;
 }
 
@@ -318,7 +564,11 @@ nsMediaList::Item(PRUint32 aIndex, nsASt
 {
   PRInt32 index = aIndex;
   if (0 <= index && index < Count()) {
-    MediumAt(aIndex)->ToString(aReturn);
+    nsMediaQuery* query = mArray[index];
+    NS_ENSURE_TRUE(query, NS_ERROR_FAILURE);
+
+    aReturn.Truncate();
+    query->AppendToString(aReturn);
   } else {
     SetDOMStringToNull(aReturn);
   }
@@ -366,18 +616,19 @@ nsMediaList::Delete(const nsAString& aOl
   if (aOldMedium.IsEmpty())
     return NS_ERROR_DOM_NOT_FOUND_ERR;
 
-  nsCOMPtr<nsIAtom> old = do_GetAtom(aOldMedium);
-  NS_ENSURE_TRUE(old, NS_ERROR_OUT_OF_MEMORY);
+  for (PRInt32 i = 0, i_end = mArray.Length(); i < i_end; ++i) {
+    nsMediaQuery* query = mArray[i];
+    NS_ENSURE_TRUE(query, NS_ERROR_FAILURE);
 
-  PRInt32 indx = mArray.IndexOf(old);
-
-  if (indx < 0) {
-    return NS_ERROR_DOM_NOT_FOUND_ERR;
+    nsAutoString buf;
+    query->AppendToString(buf);
+    if (buf == aOldMedium) {
+      mArray.RemoveElementAt(i);
+      return NS_OK;
+    }
   }
 
-  mArray.RemoveObjectAt(indx);
-
-  return NS_OK;
+  return NS_ERROR_DOM_NOT_FOUND_ERR;
 }
 
 nsresult
@@ -386,18 +637,31 @@ nsMediaList::Append(const nsAString& aNe
   if (aNewMedium.IsEmpty())
     return NS_ERROR_DOM_NOT_FOUND_ERR;
 
-  nsCOMPtr<nsIAtom> media = do_GetAtom(aNewMedium);
-  NS_ENSURE_TRUE(media, NS_ERROR_OUT_OF_MEMORY);
+  Delete(aNewMedium);
 
-  PRInt32 indx = mArray.IndexOf(media);
-
-  if (indx >= 0) {
-    mArray.RemoveObjectAt(indx);
+  nsresult rv = NS_OK;
+  nsTArray<nsAutoPtr<nsMediaQuery> > buf;
+#ifdef DEBUG
+  PRBool ok = 
+#endif
+    mArray.SwapElements(buf);
+  NS_ASSERTION(ok, "SwapElements should never fail when neither array "
+                   "is an auto array");
+  SetText(aNewMedium);
+  if (mArray.Length() == 1) {
+    nsMediaQuery *query = mArray[0].forget();
+    if (!buf.AppendElement(query)) {
+      delete query;
+      rv = NS_ERROR_OUT_OF_MEMORY;
+    }
   }
-
-  mArray.AppendObject(media);
-
-  return NS_OK;
+#ifdef DEBUG
+  ok = 
+#endif
+    mArray.SwapElements(buf);
+  NS_ASSERTION(ok, "SwapElements should never fail when neither array "
+                   "is an auto array");
+  return rv;
 }
 
 // -------------------------------
diff --git a/layout/style/nsIMediaList.h b/layout/style/nsIMediaList.h
--- a/layout/style/nsIMediaList.h
+++ b/layout/style/nsIMediaList.h
@@ -46,11 +46,75 @@
 
 #include "nsIDOMMediaList.h"
 #include "nsAString.h"
-#include "nsCOMArray.h"
+#include "nsTArray.h"
 #include "nsIAtom.h"
+#include "nsMediaFeatures.h"
+#include "nsCSSValue.h"
+
 class nsPresContext;
 class nsICSSStyleSheet;
 class nsCSSStyleSheet;
+
+struct nsMediaExpression {
+  enum Range { eMin, eMax, eEqual };
+
+  const nsMediaFeature *mFeature;
+  Range mRange;
+  nsCSSValue mValue;
+};
+
+class nsMediaQuery {
+public:
+  nsMediaQuery()
+    : mNegated(PR_FALSE)
+    , mHasOnly(PR_FALSE)
+    , mTypeOmitted(PR_FALSE)
+    , mHadUnknownExpression(PR_FALSE)
+  {
+  }
+
+private:
+  // for Clone only
+  nsMediaQuery(const nsMediaQuery& aOther)
+    : mNegated(aOther.mNegated)
+    , mHasOnly(aOther.mHasOnly)
+    , mTypeOmitted(aOther.mTypeOmitted)
+    , mHadUnknownExpression(aOther.mHadUnknownExpression)
+    , mMediaType(aOther.mMediaType)
+    // Clone checks the result of this deep copy for allocation failure
+    , mExpressions(aOther.mExpressions)
+  {
+  }
+
+public:
+
+  void SetNegated()                     { mNegated = PR_TRUE; }
+  void SetHasOnly()                     { mHasOnly = PR_TRUE; }
+  void SetTypeOmitted()                 { mTypeOmitted = PR_TRUE; }
+  void SetHadUnknownExpression()        { mHadUnknownExpression = PR_TRUE; }
+  void SetType(nsIAtom* aMediaType)     { mMediaType = aMediaType; }
+
+  // Return a new nsMediaExpression in the array for the caller to fill
+  // in.  The caller must either fill it in completely, or call
+  // SetHadUnknownExpression on this nsMediaQuery.
+  // Returns null on out-of-memory.
+  nsMediaExpression* NewExpression()    { return mExpressions.AppendElement(); }
+
+  void AppendToString(nsAString& aString) const;
+
+  nsMediaQuery* Clone() const;
+
+  // Does this query apply to the presentation?
+  PRBool Matches(nsPresContext* aPresContext) const;
+
+private:
+  PRPackedBool mNegated;
+  PRPackedBool mHasOnly; // only needed for serialization
+  PRPackedBool mTypeOmitted; // only needed for serialization
+  PRPackedBool mHadUnknownExpression;
+  nsCOMPtr<nsIAtom> mMediaType;
+  nsTArray<nsMediaExpression> mExpressions;
+};
 
 class nsMediaList : public nsIDOMMediaList {
 public:
@@ -64,14 +128,15 @@ public:
   nsresult SetText(const nsAString& aMediaText);
   PRBool Matches(nsPresContext* aPresContext);
   nsresult SetStyleSheet(nsICSSStyleSheet* aSheet);
-  nsresult AppendAtom(nsIAtom* aMediumAtom) {
-    return mArray.AppendObject(aMediumAtom) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+  nsresult AppendQuery(nsMediaQuery *aQuery) {
+    // Takes ownership of aQuery
+    return mArray.AppendElement(aQuery) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
   }
 
   nsresult Clone(nsMediaList** aResult);
 
-  PRInt32 Count() { return mArray.Count(); }
-  nsIAtom* MediumAt(PRInt32 aIndex) { return mArray[aIndex]; }
+  PRInt32 Count() { return mArray.Length(); }
+  nsMediaQuery* MediumAt(PRInt32 aIndex) { return mArray[aIndex]; }
   void Clear() { mArray.Clear(); }
 
 protected:
@@ -80,7 +145,7 @@ protected:
   nsresult Delete(const nsAString & aOldMedium);
   nsresult Append(const nsAString & aOldMedium);
 
-  nsCOMArray<nsIAtom> mArray;
+  nsTArray<nsAutoPtr<nsMediaQuery> > mArray;
   // not refcounted; sheet will let us know when it goes away
   // mStyleSheet is the sheet that needs to be dirtied when this medialist
   // changes
diff --git a/layout/style/nsMediaFeatures.cpp b/layout/style/nsMediaFeatures.cpp
new file mode 100644
--- /dev/null
+++ b/layout/style/nsMediaFeatures.cpp
@@ -0,0 +1,313 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsMediaFeatures.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsMediaFeatures.h"
+#include "nsGkAtoms.h"
+#include "nsCSSKeywords.h"
+#include "nsStyleConsts.h"
+#include "nsPresContext.h"
+#include "nsIDeviceContext.h"
+#include "nsCSSValue.h"
+
+static const PRInt32 kOrientationKeywords[] = {
+  eCSSKeyword_portrait,                 NS_STYLE_ORIENTATION_PORTRAIT,
+  eCSSKeyword_landscape,                NS_STYLE_ORIENTATION_LANDSCAPE,
+  eCSSKeyword_UNKNOWN,                  -1
+};
+
+static const PRInt32 kScanKeywords[] = {
+  eCSSKeyword_progressive,              NS_STYLE_SCAN_PROGRESSIVE,
+  eCSSKeyword_interlace,                NS_STYLE_SCAN_INTERLACE,
+  eCSSKeyword_UNKNOWN,                  -1
+};
+
+PR_STATIC_CALLBACK(nsresult)
+GetWidth(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    nscoord width = aPresContext->GetVisibleArea().width;
+    float pixelWidth = aPresContext->AppUnitsToFloatCSSPixels(width);
+    aResult.SetFloatValue(pixelWidth, eCSSUnit_Pixel);
+    return NS_OK;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetHeight(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    nscoord height = aPresContext->GetVisibleArea().height;
+    float pixelHeight = aPresContext->AppUnitsToFloatCSSPixels(height);
+    aResult.SetFloatValue(pixelHeight, eCSSUnit_Pixel);
+    return NS_OK;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetDeviceWidth(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // XXX: I'm not sure if this is really the right thing for print:
+    // do we want to include unprintable areas / page margins?
+    nsIDeviceContext *dx = aPresContext->DeviceContext();
+    nscoord width, height;
+    dx->GetDeviceSurfaceDimensions(width, height);
+    float pixelWidth = aPresContext->AppUnitsToFloatCSSPixels(width);
+    aResult.SetFloatValue(pixelWidth, eCSSUnit_Pixel);
+    return NS_OK;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetDeviceHeight(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // XXX: I'm not sure if this is really the right thing for print:
+    // do we want to include unprintable areas / page margins?
+    nsIDeviceContext *dx = aPresContext->DeviceContext();
+    nscoord width, height;
+    dx->GetDeviceSurfaceDimensions(width, height);
+    float pixelHeight = aPresContext->AppUnitsToFloatCSSPixels(height);
+    aResult.SetFloatValue(pixelHeight, eCSSUnit_Pixel);
+    return NS_OK;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetOrientation(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    nsSize size = aPresContext->GetVisibleArea().Size();
+    PRInt32 orientation;
+    if (size.width > size.height) {
+        orientation = NS_STYLE_ORIENTATION_LANDSCAPE;
+    } else {
+        // Per spec, square viewports should be 'portrait'
+        orientation = NS_STYLE_ORIENTATION_PORTRAIT;
+    }
+
+    aResult.SetIntValue(orientation, eCSSUnit_Enumerated);
+    return NS_OK;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetAspectRatio(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    nsRefPtr<nsCSSValue::Array> a = nsCSSValue::Array::Create(2);
+    NS_ENSURE_TRUE(a, NS_ERROR_OUT_OF_MEMORY);
+
+    nsSize size = aPresContext->GetVisibleArea().Size();
+    a->Item(0).SetIntValue(size.width, eCSSUnit_Integer);
+    a->Item(1).SetIntValue(size.height, eCSSUnit_Integer);
+
+    aResult.SetArrayValue(a, eCSSUnit_Array);
+    return NS_OK;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetDeviceAspectRatio(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    nsRefPtr<nsCSSValue::Array> a = nsCSSValue::Array::Create(2);
+    NS_ENSURE_TRUE(a, NS_ERROR_OUT_OF_MEMORY);
+
+    // XXX: I'm not sure if this is really the right thing for print:
+    // do we want to include unprintable areas / page margins?
+    nsIDeviceContext *dx = aPresContext->DeviceContext();
+    nscoord width, height;
+    dx->GetDeviceSurfaceDimensions(width, height);
+    a->Item(0).SetIntValue(width, eCSSUnit_Integer);
+    a->Item(1).SetIntValue(height, eCSSUnit_Integer);
+
+    aResult.SetArrayValue(a, eCSSUnit_Array);
+    return NS_OK;
+}
+
+#if 0
+// Skip these for now, since nsThebesDeviceContext doesn't provide
+// reliable information.
+
+PR_STATIC_CALLBACK(nsresult)
+GetColor(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // FIXME: WRITE ME!
+    aResult.Reset();
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetColorIndex(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // FIXME: WRITE ME!
+    aResult.Reset();
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetMonochrome(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // FIXME: WRITE ME!
+    aResult.Reset();
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+#endif
+
+PR_STATIC_CALLBACK(nsresult)
+GetResolution(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // XXX: The spec isn't clear whether this is CSS pixels or device
+    // pixels.  For now, do device pixels.
+    nsIDeviceContext *dx = aPresContext->DeviceContext();
+    float dpi = float(dx->AppUnitsPerInch()) / float(dx->AppUnitsPerDevPixel());
+    aResult.SetFloatValue(dpi, eCSSUnit_Inch);
+    return NS_OK;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetScan(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // Since Gecko doesn't support the 'tv' media type, the 'scan'
+    // feature is never present.
+    aResult.Reset();
+    return NS_OK;
+}
+
+PR_STATIC_CALLBACK(nsresult)
+GetGrid(nsPresContext* aPresContext, nsCSSValue& aResult)
+{
+    // Gecko doesn't support grid devices (e.g., ttys), so the 'grid'
+    // feature is always 0.
+    aResult.SetIntValue(0, eCSSUnit_Integer);
+    return NS_OK;
+}
+
+/* static */ const nsMediaFeature
+nsMediaFeatures::features[] = {
+    {
+        &nsGkAtoms::width,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eLength,
+        nsnull,
+        GetWidth
+    },
+    {
+        &nsGkAtoms::height,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eLength,
+        nsnull,
+        GetHeight
+    },
+    {
+        &nsGkAtoms::deviceWidth,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eLength,
+        nsnull,
+        GetDeviceWidth
+    },
+    {
+        &nsGkAtoms::deviceHeight,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eLength,
+        nsnull,
+        GetDeviceHeight
+    },
+    {
+        &nsGkAtoms::orientation,
+        nsMediaFeature::eMinMaxNotAllowed,
+        nsMediaFeature::eEnumerated,
+        kOrientationKeywords,
+        GetOrientation
+    },
+    {
+        &nsGkAtoms::aspectRatio,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eIntRatio,
+        nsnull,
+        GetAspectRatio
+    },
+    {
+        &nsGkAtoms::deviceAspectRatio,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eIntRatio,
+        nsnull,
+        GetDeviceAspectRatio
+    },
+#if 0
+// Skip these for now, since nsThebesDeviceContext doesn't provide
+// reliable information.
+    {
+        &nsGkAtoms::color,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eInteger,
+        nsnull,
+        GetColor
+    },
+    {
+        &nsGkAtoms::colorIndex,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eInteger,
+        nsnull,
+        GetColorIndex
+    },
+    {
+        &nsGkAtoms::monochrome,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eInteger,
+        nsnull,
+        GetMonochrome
+    },
+#endif
+    {
+        &nsGkAtoms::resolution,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eResolution,
+        nsnull,
+        GetResolution
+    },
+    {
+        &nsGkAtoms::scan,
+        nsMediaFeature::eMinMaxNotAllowed,
+        nsMediaFeature::eEnumerated,
+        kScanKeywords,
+        GetScan
+    },
+    {
+        &nsGkAtoms::grid,
+        nsMediaFeature::eMinMaxNotAllowed,
+        nsMediaFeature::eInteger,
+        nsnull,
+        GetGrid
+    },
+    // Null-mName terminator:
+    {
+        nsnull,
+        nsMediaFeature::eMinMaxAllowed,
+        nsMediaFeature::eInteger,
+        nsnull,
+        nsnull
+    },
+};
diff --git a/layout/style/nsMediaFeatures.h b/layout/style/nsMediaFeatures.h
new file mode 100644
--- /dev/null
+++ b/layout/style/nsMediaFeatures.h
@@ -0,0 +1,83 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsMediaFeatures.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsMediaFeatures_h_
+#define nsMediaFeatures_h_
+
+#include "nscore.h"
+
+class nsIAtom;
+class nsPresContext;
+class nsCSSValue;
+
+typedef nsresult
+(* PR_CALLBACK nsMediaFeatureValueGetter)(nsPresContext* aPresContext,
+                                          nsCSSValue& aResult);
+
+struct nsMediaFeature {
+    nsIAtom **mName; // extra indirection to point to nsGkAtoms members
+
+    enum RangeType { eMinMaxAllowed, eMinMaxNotAllowed };
+    RangeType mRangeType;
+
+    enum ValueType {
+        // All value types allow eCSSUnit_Null to indicate that no value
+        // was given (in addition to the types listed below).
+        eLength,     // values are such that nsCSSValue::IsLengthUnit() is true
+        eInteger,    // values are eCSSUnit_Integer
+        eIntRatio,   // values are eCSSUnit_Array of two eCSSUnit_Integer
+        eResolution, // values are in eCSSUnit_Inch (for dpi) or
+                     //   eCSSUnit_Centimeter (for dpcm)
+        eEnumerated  // values are eCSSUnit_Enumerated (uses keyword table)
+    };
+    ValueType mValueType;
+
+    // The same format as the keyword tables in nsCSSProps.
+    const PRInt32* mKeywordTable;
+
+    // A function that returns the current value for this feature for a
+    // given presentation.  If it returns eCSSUnit_Null, the feature is
+    // not present.
+    nsMediaFeatureValueGetter mGetter;
+};
+
+class nsMediaFeatures {
+public:
+    // Terminated with an entry whose mName is null.
+    static const nsMediaFeature features[];
+};
+
+#endif /* !defined(nsMediaFeatures_h_) */
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -265,6 +265,16 @@ static nscoord CalcLength(const nsCSSVal
   NS_ASSERTION(aStyleContext, "Must have style data");
 
   return CalcLengthWith(aValue, -1, nsnull, aStyleContext, aPresContext, aInherited);
+}
+
+/* static */ nscoord
+nsRuleNode::CalcLengthWithInitialFont(nsPresContext* aPresContext,
+                                      const nsCSSValue& aValue)
+{
+  nsStyleFont defaultFont(aPresContext);
+  PRBool inherited;
+  return CalcLengthWith(aValue, -1, &defaultFont, nsnull, aPresContext,
+                        inherited);
 }
 
 #define SETCOORD_NORMAL                 0x01   // N
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -723,6 +723,10 @@ public:
 
   static PRBool
     HasAuthorSpecifiedBorderOrBackground(nsStyleContext* aStyleContext);
+
+  // Expose this so media queries can use it
+  static nscoord CalcLengthWithInitialFont(nsPresContext* aPresContext,
+                                           const nsCSSValue& aValue);
 };
 
 #endif
