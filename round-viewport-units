From: L. David Baron <dbaron@dbaron.org>

Bug 989802 - Round viewport units to appunits using trunc rather than round so that repeated uses fit within a container.  r=roc

viewport-units-rounding-1.html fails without the patch and passes with
the patch.

viewport-units-rounding-2.html fails with an early version of the patch
but not without the patch or with the final version.

diff --git a/gfx/src/nsCoord.h b/gfx/src/nsCoord.h
--- a/gfx/src/nsCoord.h
+++ b/gfx/src/nsCoord.h
@@ -263,16 +263,62 @@ inline nscoord NSToCoordCeilClamped(doub
   }
   if (aValue <= nscoord_MIN) {
     return nscoord_MIN;
   }
 #endif
   return NSToCoordCeil(aValue);
 }
 
+// The NSToCoordTrunc* functions remove the fractional component of
+// aValue, and are thus equivalent to NSToCoordFloor* for positive
+// values and NSToCoordCeil* for negative values.
+
+inline nscoord NSToCoordTrunc(float aValue)
+{
+  // There's no need to use truncf() since it matches the default
+  // rules for float to integer conversion.
+  return nscoord(aValue);
+}
+
+inline nscoord NSToCoordTrunc(double aValue)
+{
+  // There's no need to use trunc() since it matches the default
+  // rules for float to integer conversion.
+  return nscoord(aValue);
+}
+
+inline nscoord NSToCoordTruncClamped(float aValue)
+{
+#ifndef NS_COORD_IS_FLOAT
+  // Bounds-check before converting out of float, to avoid overflow
+  if (aValue >= nscoord_MAX) {
+    return nscoord_MAX;
+  }
+  if (aValue <= nscoord_MIN) {
+    return nscoord_MIN;
+  }
+#endif
+  return NSToCoordTrunc(aValue);
+}
+
+inline nscoord NSToCoordTruncClamped(double aValue)
+{
+#ifndef NS_COORD_IS_FLOAT
+  // Bounds-check before converting out of double, to avoid overflow
+  if (aValue >= nscoord_MAX) {
+    return nscoord_MAX;
+  }
+  if (aValue <= nscoord_MIN) {
+    return nscoord_MIN;
+  }
+#endif
+  return NSToCoordTrunc(aValue);
+}
+
 /*
  * Int Rounding Functions
  */
 inline int32_t NSToIntFloor(float aValue)
 {
   return int32_t(floorf(aValue));
 }
 
diff --git a/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-auto-ref-iframe.html b/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-auto-ref-iframe.html
--- a/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-auto-ref-iframe.html
+++ b/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-auto-ref-iframe.html
@@ -16,22 +16,30 @@
   <!--
   Deliberately make the scrollbars appear to ensure that with 'overflow: auto'
   viewport units are calculated as if the scrollbars are _not_ there.
   -->
   <div style="width: 500px; height: 500px; background-color: black">
 </body>
 
 <script>
+  // We round viewport units and px units differently, because we want
+  // to round viewport units down.  Therefore pixels get rounded to the
+  // nearest appunit (1/60 of a CSS pixel) with 0.5 getting rounded up,
+  // while viewport units are truncated towards the nearest appunit
+  // towards 0.  Thus, subtract 1/120 of a pixel, with no need for an
+  // additional amount to deal with the rounding direction.
+  var epsilon = 1/120;
+
   // client{Width, Height} consist of the area _inside_ the scrollbars, so we need
   // to calculate these units with 'overflow: hidden' set to ensure that there are
   // no scrollbars. This reflects the fact that with 'overflow: auto' set, viewport
   // units are sized without taking the scrollbars into account.
   var vw = 0.01 * document.body.clientWidth;
   var vh = 0.01 * document.body.clientHeight;
   var vmin = Math.min(vw, vh);
   var vmax = Math.max(vw, vh);
   document.body.style.overflow = "auto";
-  document.getElementById('a').style.width = (50 * vw) + "px";
-  document.getElementById('b').style.height = (25 * vh) + "px";
-  document.getElementById('c').style.width = (35 * vmin) + "px";
-  document.getElementById('d').style.height = (25 * vmax) + "px";
+  document.getElementById('a').style.width = (50 * vw - epsilon) + "px";
+  document.getElementById('b').style.height = (25 * vh - epsilon) + "px";
+  document.getElementById('c').style.width = (35 * vmin - epsilon) + "px";
+  document.getElementById('d').style.height = (25 * vmax - epsilon) + "px";
 </script>
diff --git a/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-scroll-ref-iframe.html b/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-scroll-ref-iframe.html
--- a/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-scroll-ref-iframe.html
+++ b/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-scroll-ref-iframe.html
@@ -17,20 +17,28 @@
   Ensure that the scroller positioned the same way as it would be in the
   'overflow: auto' case. We'll have scrollbars either way, but we don't
   want the '!=' reftest to spuriously succeed because of the scrollers.
   -->
   <div style="width: 500px; height: 500px; background-color: black">
 </body>
 
 <script>
+  // We round viewport units and px units differently, because we want
+  // to round viewport units down.  Therefore pixels get rounded to the
+  // nearest appunit (1/60 of a CSS pixel) with 0.5 getting rounded up,
+  // while viewport units are truncated towards the nearest appunit
+  // towards 0.  Thus, subtract 1/120 of a pixel, with no need for an
+  // additional amount to deal with the rounding direction.
+  var epsilon = 1/120;
+
   // client{Width, Height} consist of the area _inside_ the scrollbars, so these
   // manually calculated units reflect the fact that with 'overflow: scroll' set,
   // viewport units are sized taking the scrollbars into account.
   var vw = 0.01 * document.body.clientWidth;
   var vh = 0.01 * document.body.clientHeight;
   var vmin = Math.min(vw, vh);
   var vmax = Math.max(vw, vh);
-  document.getElementById('a').style.width = (50 * vw) + "px";
-  document.getElementById('b').style.height = (25 * vh) + "px";
-  document.getElementById('c').style.width = (35 * vmin) + "px";
-  document.getElementById('d').style.height = (25 * vmax) + "px";
+  document.getElementById('a').style.width = (50 * vw - epsilon) + "px";
+  document.getElementById('b').style.height = (25 * vh - epsilon) + "px";
+  document.getElementById('c').style.width = (35 * vmin - epsilon) + "px";
+  document.getElementById('d').style.height = (25 * vmax - epsilon) + "px";
 </script>
diff --git a/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-scroll-x-ref-iframe.html b/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-scroll-x-ref-iframe.html
--- a/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-scroll-x-ref-iframe.html
+++ b/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-scroll-x-ref-iframe.html
@@ -13,16 +13,24 @@
   <div style="width: 35px"></div> <!-- Unaffected by scrollbars. -->
   <div id="d"></div>
 
   <!-- Deliberately make scrollbars appear. -->
   <div style="width: 500px; height: 500px; background-color: black">
 </body>
 
 <script>
+  // We round viewport units and px units differently, because we want
+  // to round viewport units down.  Therefore pixels get rounded to the
+  // nearest appunit (1/60 of a CSS pixel) with 0.5 getting rounded up,
+  // while viewport units are truncated towards the nearest appunit
+  // towards 0.  Thus, subtract 1/120 of a pixel, with no need for an
+  // additional amount to deal with the rounding direction.
+  var epsilon = 1/120;
+
   // client{Width, Height} consist of the area _inside_ the scrollbars, so these
   // manually calculated units reflect the fact that with 'overflow: scroll' set,
   // viewport units are sized taking the scrollbars into account. Since we're
   // only dealing with 'overflow-x' here, only the height units are affected.
   var vh = 0.01 * document.body.clientHeight;
-  document.getElementById('b').style.height = (25 * vh) + "px";
-  document.getElementById('d').style.height = (25 * vh) + "px";
+  document.getElementById('b').style.height = (25 * vh - epsilon) + "px";
+  document.getElementById('d').style.height = (25 * vh - epsilon) + "px";
 </script>
diff --git a/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-scroll-y-ref-iframe.html b/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-scroll-y-ref-iframe.html
--- a/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-scroll-y-ref-iframe.html
+++ b/layout/reftests/css-valuesandunits/unit-vh-vw-overflow-scroll-y-ref-iframe.html
@@ -13,16 +13,24 @@
   <div id="c"></div>
   <div style="height: 50px"></div> <!-- Unaffected by scrollbars. -->
 
   <!-- Deliberately make scrollbars appear. -->
   <div style="width: 500px; height: 500px; background-color: black">
 </body>
 
 <script>
+  // We round viewport units and px units differently, because we want
+  // to round viewport units down.  Therefore pixels get rounded to the
+  // nearest appunit (1/60 of a CSS pixel) with 0.5 getting rounded up,
+  // while viewport units are truncated towards the nearest appunit
+  // towards 0.  Thus, subtract 1/120 of a pixel, with no need for an
+  // additional amount to deal with the rounding direction.
+  var epsilon = 1/120;
+
   // client{Width, Height} consist of the area _inside_ the scrollbars, so these
   // manually calculated units reflect the fact that with 'overflow: scroll' set,
   // viewport units are sized taking the scrollbars into account. Since we're
   // only dealing with 'overflow-y' here, only the width units are affected.
   var vw = 0.01 * document.body.clientWidth;
-  document.getElementById('a').style.width = (50 * vw) + "px";
-  document.getElementById('c').style.width = (35 * vw) + "px";
+  document.getElementById('a').style.width = (50 * vw - epsilon) + "px";
+  document.getElementById('c').style.width = (35 * vw - epsilon) + "px";
 </script>
diff --git a/layout/reftests/pixel-rounding/reftest.list b/layout/reftests/pixel-rounding/reftest.list
--- a/layout/reftests/pixel-rounding/reftest.list
+++ b/layout/reftests/pixel-rounding/reftest.list
@@ -169,8 +169,11 @@ fails == collapsed-border-top-6.html bor
 
 skip-if(B2G) fails-if(cocoaWidget) == background-image-tiling.html background-image-tiling-ref.html # probably bug 379317 # bug 773482
 
 != border-image-width-0.html border-image-width-10.html
 skip-if(B2G) random-if(Android) == border-image-width-4.html border-image-width-0.html # bug 661996 # bug 773482
 skip-if(B2G) random-if(Android) == border-image-width-9.html border-image-width-0.html # bug 661996 # bug 773482
 
 == iframe-1.html iframe-1-ref.html
+
+== viewport-units-rounding-1.html viewport-units-rounding-1-ref.html
+== viewport-units-rounding-2.html about:blank
diff --git a/layout/reftests/pixel-rounding/viewport-units-rounding-1-frame.html b/layout/reftests/pixel-rounding/viewport-units-rounding-1-frame.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/pixel-rounding/viewport-units-rounding-1-frame.html
@@ -0,0 +1,51 @@
+<!DOCTYPE HTML>
+<title>subframe for test of viewport units rounding</title>
+<meta charset="UTF-8">
+<style>
+
+html, body { margin: 0; padding: 0; border: none }
+
+body > div {
+  background: red; /* should never show */
+  overflow: hidden; /* block formatting context */
+}
+
+body > div > div {
+  float: left;
+  height: 10px;
+}
+
+body > div.w25 > div { width: 25vw; }
+
+</style>
+
+<div class="w25">
+  <div style="background: fuchsia"></div>
+  <div style="background: aqua"></div>
+  <div style="background: silver"></div>
+  <div style="background: yellow"></div>
+</div>
+
+<!--
+  Really, though, anything that is a multiple of 5vw will always
+  produce a round number of appunits when starting from an integer
+  number of pixels, since 5vw is 1/20 of the viewport.
+
+  So, more interesting:
+-->
+
+<div>
+  <div style="width: 24vw; background: fuchsia"></div>
+  <div style="width: 24vw; background: aqua"></div>
+  <div style="width: 24vw; background: silver"></div>
+  <div style="width: 24vw; background: yellow"></div>
+  <div style="width: 4vw; background: gray"></div>
+</div>
+
+<div>
+  <div style="width: 21vw; background: fuchsia"></div>
+  <div style="width: 21vw; background: aqua"></div>
+  <div style="width: 21vw; background: silver"></div>
+  <div style="width: 21vw; background: yellow"></div>
+  <div style="width: 16vw; background: gray"></div>
+</div>
diff --git a/layout/reftests/pixel-rounding/viewport-units-rounding-1-ref.html b/layout/reftests/pixel-rounding/viewport-units-rounding-1-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/pixel-rounding/viewport-units-rounding-1-ref.html
@@ -0,0 +1,123 @@
+<!DOCTYPE HTML>
+<title>viewport units rounding reference</title>
+<meta charset="UTF-8">
+<style>
+div.contain { height: 50px }
+div.contain > div { height: 10px }
+div.contain > div > div { height: 10px; float: left }
+</style>
+
+<div class="contain" style="width: 200px">
+  <div>
+    <div style="width: 50px; background: fuchsia"></div>
+    <div style="width: 50px; background: aqua"></div>
+    <div style="width: 50px; background: silver"></div>
+    <div style="width: 50px; background: yellow"></div>
+  </div>
+  <div>
+    <div style="width: 48px; background: fuchsia"></div>
+    <div style="width: 48px; background: aqua"></div>
+    <div style="width: 48px; background: silver"></div>
+    <div style="width: 48px; background: yellow"></div>
+    <div style="width: 8px; background: gray"></div>
+  </div>
+  <div>
+    <div style="width: 42px; background: fuchsia"></div>
+    <div style="width: 42px; background: aqua"></div>
+    <div style="width: 42px; background: silver"></div>
+    <div style="width: 42px; background: yellow"></div>
+    <div style="width: 32px; background: gray"></div>
+  </div>
+</div>
+
+<div class="contain" style="width: 201px">
+  <div>
+    <div style="width: 50px; background: fuchsia"></div>
+    <div style="width: 51px; background: aqua"></div>
+    <div style="width: 50px; background: silver"></div>
+    <div style="width: 50px; background: yellow"></div>
+  </div>
+  <div>
+    <div style="width: 48px; background: fuchsia"></div>
+    <div style="width: 48px; background: aqua"></div>
+    <div style="width: 49px; background: silver"></div>
+    <div style="width: 48px; background: yellow"></div>
+    <div style="width: 8px; background: gray"></div>
+  </div>
+  <div>
+    <div style="width: 42px; background: fuchsia"></div>
+    <div style="width: 42px; background: aqua"></div>
+    <div style="width: 43px; background: silver"></div>
+    <div style="width: 42px; background: yellow"></div>
+    <div style="width: 32px; background: gray"></div>
+  </div>
+</div>
+
+<div class="contain" style="width: 202px">
+  <div>
+    <div style="width: 51px; background: fuchsia"></div>
+    <div style="width: 50px; background: aqua"></div>
+    <div style="width: 51px; background: silver"></div>
+    <div style="width: 50px; background: yellow"></div>
+  </div>
+  <div>
+    <div style="width: 48px; background: fuchsia"></div>
+    <div style="width: 49px; background: aqua"></div>
+    <div style="width: 48px; background: silver"></div>
+    <div style="width: 49px; background: yellow"></div>
+    <div style="width: 8px; background: gray"></div>
+  </div>
+  <div>
+    <div style="width: 42px; background: fuchsia"></div>
+    <div style="width: 43px; background: aqua"></div>
+    <div style="width: 42px; background: silver"></div>
+    <div style="width: 43px; background: yellow"></div>
+    <div style="width: 32px; background: gray"></div>
+  </div>
+</div>
+
+<div class="contain" style="width: 203px">
+  <div>
+    <div style="width: 51px; background: fuchsia"></div>
+    <div style="width: 51px; background: aqua"></div>
+    <div style="width: 50px; background: silver"></div>
+    <div style="width: 51px; background: yellow"></div>
+  </div>
+  <div>
+    <div style="width: 49px; background: fuchsia"></div>
+    <div style="width: 48px; background: aqua"></div>
+    <div style="width: 49px; background: silver"></div>
+    <div style="width: 49px; background: yellow"></div>
+    <div style="width: 8px; background: gray"></div>
+  </div>
+  <div>
+    <div style="width: 43px; background: fuchsia"></div>
+    <div style="width: 42px; background: aqua"></div>
+    <div style="width: 43px; background: silver"></div>
+    <div style="width: 42px; background: yellow"></div>
+    <div style="width: 33px; background: gray"></div>
+  </div>
+</div>
+
+<div class="contain" style="width: 204px">
+  <div>
+    <div style="width: 51px; background: fuchsia"></div>
+    <div style="width: 51px; background: aqua"></div>
+    <div style="width: 51px; background: silver"></div>
+    <div style="width: 51px; background: yellow"></div>
+  </div>
+  <div>
+    <div style="width: 49px; background: fuchsia"></div>
+    <div style="width: 49px; background: aqua"></div>
+    <div style="width: 49px; background: silver"></div>
+    <div style="width: 49px; background: yellow"></div>
+    <div style="width: 8px; background: gray"></div>
+  </div>
+  <div>
+    <div style="width: 43px; background: fuchsia"></div>
+    <div style="width: 43px; background: aqua"></div>
+    <div style="width: 43px; background: silver"></div>
+    <div style="width: 42px; background: yellow"></div>
+    <div style="width: 33px; background: gray"></div>
+  </div>
+</div>
diff --git a/layout/reftests/pixel-rounding/viewport-units-rounding-1.html b/layout/reftests/pixel-rounding/viewport-units-rounding-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/pixel-rounding/viewport-units-rounding-1.html
@@ -0,0 +1,12 @@
+<!DOCTYPE HTML>
+<title>viewport units rounding</title>
+<meta charset="UTF-8">
+<style>
+iframe { display: block; border: 0; margin: 0; padding: 0; }
+</style>
+
+<iframe scrolling="no" src="viewport-units-rounding-1-frame.html" width="200" height="50" ></iframe>
+<iframe scrolling="no" src="viewport-units-rounding-1-frame.html" width="201" height="50" ></iframe>
+<iframe scrolling="no" src="viewport-units-rounding-1-frame.html" width="202" height="50" ></iframe>
+<iframe scrolling="no" src="viewport-units-rounding-1-frame.html" width="203" height="50" ></iframe>
+<iframe scrolling="no" src="viewport-units-rounding-1-frame.html" width="204" height="50" ></iframe>
diff --git a/layout/reftests/pixel-rounding/viewport-units-rounding-2.html b/layout/reftests/pixel-rounding/viewport-units-rounding-2.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/pixel-rounding/viewport-units-rounding-2.html
@@ -0,0 +1,43 @@
+<!DOCTYPE HTML>
+<title>viewport units rounding test</title>
+<meta charset="UTF-8">
+<style>
+
+body > div > div { line-height: 1px }
+span {
+  display: inline-block;
+  height: 1px;
+  width: var(--w);
+  vertical-align: bottom;
+}
+span:nth-child(1) {
+  background: red;
+}
+span:nth-child(2) {
+  background: white;
+  margin-left: var(--negw);
+}
+
+</style>
+<body>
+<script>
+
+for (var p = 0; p < 20; ++p) {
+  var position = ((20 * p) + (p / 50)) + "px";
+  var container = document.createElement("div");
+  container.style.position = "absolute";
+  container.style.top = "0px";
+  container.style.left = position;
+  for (var w = 0; w < 99; ++w) {
+    var width = (0.5 + w / 100) + "vw";
+    var div = document.createElement("div");
+    div.setAttribute("style", "--w: " + width + "; " +
+                              "--negw: -" + width);
+    div.appendChild(document.createElement("span"));
+    div.appendChild(document.createElement("span"));
+    container.appendChild(div);
+  }
+  document.body.appendChild(container);
+}
+
+</script>
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -218,19 +218,27 @@ struct CalcLengthCalcOps : public css::B
   result_type ComputeLeafValue(const nsCSSValue& aValue)
   {
     return CalcLengthWith(aValue, mFontSize, mStyleFont,
                           mStyleContext, mPresContext, mUseProvidedRootEmSize,
                           mUseUserFontSet, mCanStoreInRuleTree);
   }
 };
 
-static inline nscoord ScaleCoord(const nsCSSValue &aValue, float factor)
-{
-  return NSToCoordRoundWithClamp(aValue.GetFloatValue() * factor);
+static inline nscoord ScaleCoordRound(const nsCSSValue& aValue, float aFactor)
+{
+  return NSToCoordRoundWithClamp(aValue.GetFloatValue() * aFactor);
+}
+
+static inline nscoord ScaleCoordTrunc(const nsCSSValue& aValue, float aFactor)
+{
+  // For units (like percentages and viewport units) where authors might
+  // repeatedly use a value and expect some multiple of the value to be
+  // smaller than a container, we need to use floor rather than round.
+  return NSToCoordTruncClamped(aValue.GetFloatValue() * aFactor);
 }
 
 already_AddRefed<nsFontMetrics>
 GetMetricsFor(nsPresContext* aPresContext,
               nsStyleContext* aStyleContext,
               const nsStyleFont* aStyleFont,
               nscoord aFontSize, // overrides value from aStyleFont
               bool aUseUserFontSet)
@@ -346,28 +354,32 @@ static nscoord CalcLengthWith(const nsCS
     // throws away the style context and the rule tree.
     // Thus we do cache viewport units in the rule tree.  This allows us
     // to benefit from the performance advantages of the rule tree
     // (e.g., faster dynamic changes on other things, like transforms)
     // and allows us not to need an additional code path, in exchange
     // for an increased cost to dynamic changes to the viewport size
     // when viewport units are in use.
     case eCSSUnit_ViewportWidth: {
-      return ScaleCoord(aValue, 0.01f * CalcViewportUnitsScale(aPresContext).width);
+      nscoord viewportWidth = CalcViewportUnitsScale(aPresContext).width;
+      return ScaleCoordTrunc(aValue, 0.01f * viewportWidth);
     }
     case eCSSUnit_ViewportHeight: {
-      return ScaleCoord(aValue, 0.01f * CalcViewportUnitsScale(aPresContext).height);
+      nscoord viewportHeight = CalcViewportUnitsScale(aPresContext).height;
+      return ScaleCoordTrunc(aValue, 0.01f * viewportHeight);
     }
     case eCSSUnit_ViewportMin: {
       nsSize vuScale(CalcViewportUnitsScale(aPresContext));
-      return ScaleCoord(aValue, 0.01f * min(vuScale.width, vuScale.height));
+      nscoord viewportMin = min(vuScale.width, vuScale.height);
+      return ScaleCoordTrunc(aValue, 0.01f * viewportMin);
     }
     case eCSSUnit_ViewportMax: {
       nsSize vuScale(CalcViewportUnitsScale(aPresContext));
-      return ScaleCoord(aValue, 0.01f * max(vuScale.width, vuScale.height));
+      nscoord viewportMax = max(vuScale.width, vuScale.height);
+      return ScaleCoordTrunc(aValue, 0.01f * viewportMax);
     }
     // While we could deal with 'rem' units correctly by simply not
     // caching any data that uses them in the rule tree, it's valuable
     // to store them in the rule tree (for faster dynamic changes of
     // other things).  And since the font size of the root element
     // changes rarely, we instead handle dynamic changes to the root
     // element's font size by rebuilding all style data in
     // nsCSSFrameConstructor::RestyleElement.
@@ -410,17 +422,17 @@ static nscoord CalcLengthWith(const nsCS
           rootStyle = aPresContext->StyleSet()->ResolveStyleFor(docElement,
                                                                 nullptr);
           rootStyleFont = rootStyle->StyleFont();
         }
 
         rootFontSize = rootStyleFont->mFont.size;
       }
 
-      return ScaleCoord(aValue, float(rootFontSize));
+      return ScaleCoordRound(aValue, float(rootFontSize));
     }
     default:
       // Fall through to the code for units that can't be stored in the
       // rule tree because they depend on font data.
       break;
   }
   // Common code for units that depend on the element's font data and
   // thus can't be stored in the rule tree:
@@ -431,33 +443,33 @@ static nscoord CalcLengthWith(const nsCS
     // XXX Should this be styleFont->mSize instead to avoid taking minfontsize
     // prefs into account?
     aFontSize = styleFont->mFont.size;
   }
   switch (aValue.GetUnit()) {
     case eCSSUnit_EM: {
       // CSS2.1 specifies that this unit scales to the computed font
       // size, not the em-width in the font metrics, despite the name.
-      return ScaleCoord(aValue, float(aFontSize));
+      return ScaleCoordRound(aValue, float(aFontSize));
     }
     case eCSSUnit_XHeight: {
       nsRefPtr<nsFontMetrics> fm =
         GetMetricsFor(aPresContext, aStyleContext, styleFont,
                       aFontSize, aUseUserFontSet);
-      return ScaleCoord(aValue, float(fm->XHeight()));
+      return ScaleCoordRound(aValue, float(fm->XHeight()));
     }
     case eCSSUnit_Char: {
       nsRefPtr<nsFontMetrics> fm =
         GetMetricsFor(aPresContext, aStyleContext, styleFont,
                       aFontSize, aUseUserFontSet);
       gfxFloat zeroWidth = (fm->GetThebesFontGroup()->GetFontAt(0)
                             ->GetMetrics().zeroOrAveCharWidth);
 
-      return ScaleCoord(aValue, ceil(aPresContext->AppUnitsPerDevPixel() *
-                                     zeroWidth));
+      return ScaleCoordRound(aValue, ceil(aPresContext->AppUnitsPerDevPixel() *
+                                          zeroWidth));
     }
     default:
       NS_NOTREACHED("unexpected unit");
       break;
   }
   return 0;
 }
 
