From: L. David Baron <dbaron@dbaron.org>

Bug 989802 - Round viewport units to appunits using floor rather than round so that repeated uses fit within a container.

diff --git a/layout/reftests/pixel-rounding/reftest.list b/layout/reftests/pixel-rounding/reftest.list
--- a/layout/reftests/pixel-rounding/reftest.list
+++ b/layout/reftests/pixel-rounding/reftest.list
@@ -169,8 +169,11 @@ fails == collapsed-border-top-6.html bor
 
 skip-if(B2G) fails-if(cocoaWidget) == background-image-tiling.html background-image-tiling-ref.html # probably bug 379317 # bug 773482
 
 != border-image-width-0.html border-image-width-10.html
 skip-if(B2G) random-if(Android) == border-image-width-4.html border-image-width-0.html # bug 661996 # bug 773482
 skip-if(B2G) random-if(Android) == border-image-width-9.html border-image-width-0.html # bug 661996 # bug 773482
 
 == iframe-1.html iframe-1-ref.html
+
+== viewport-units-rounding-1.html REFERENCE-TODO
+== viewport-units-rounding-2.html REFERENCE-TODO
diff --git a/layout/reftests/pixel-rounding/viewport-units-rounding-1-frame.html b/layout/reftests/pixel-rounding/viewport-units-rounding-1-frame.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/pixel-rounding/viewport-units-rounding-1-frame.html
@@ -0,0 +1,51 @@
+<!DOCTYPE HTML>
+<title>subframe for test of viewport units rounding</title>
+<meta charset="UTF-8">
+<style>
+
+html, body { margin: 0; padding: 0; border: none }
+
+body > div {
+  background: red; /* should never show */
+  overflow: hidden; /* block formatting context */
+}
+
+body > div > div {
+  float: left;
+  height: 10px;
+}
+
+body > div.w25 > div { width: 25vw; }
+
+</style>
+
+<div class="w25">
+  <div style="background: fuchsia"></div>
+  <div style="background: aqua"></div>
+  <div style="background: silver"></div>
+  <div style="background: yellow"></div>
+</div>
+
+<!--
+  Really, though, anything that is a multiple of 5vw will always
+  produce a round number of appunits when starting from an integer
+  number of pixels, since 5vw is 1/20 of the viewport.
+
+  So, more interesting:
+-->
+
+<div>
+  <div style="width: 24vw; background: fuchsia"></div>
+  <div style="width: 24vw; background: aqua"></div>
+  <div style="width: 24vw; background: silver"></div>
+  <div style="width: 24vw; background: yellow"></div>
+  <div style="width: 4vw; background: gray"></div>
+</div>
+
+<div>
+  <div style="width: 21vw; background: fuchsia"></div>
+  <div style="width: 21vw; background: aqua"></div>
+  <div style="width: 21vw; background: silver"></div>
+  <div style="width: 21vw; background: yellow"></div>
+  <div style="width: 16vw; background: gray"></div>
+</div>
diff --git a/layout/reftests/pixel-rounding/viewport-units-rounding-1.html b/layout/reftests/pixel-rounding/viewport-units-rounding-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/pixel-rounding/viewport-units-rounding-1.html
@@ -0,0 +1,12 @@
+<!DOCTYPE HTML>
+<title>viewport units rounding</title>
+<meta charset="UTF-8">
+<style>
+iframe { display: block; border: 0; margin: 0; padding: 0; }
+</style>
+
+<iframe scrolling="no" src="viewport-units-rounding-1-frame.html" width="200" height="50" ></iframe>
+<iframe scrolling="no" src="viewport-units-rounding-1-frame.html" width="201" height="50" ></iframe>
+<iframe scrolling="no" src="viewport-units-rounding-1-frame.html" width="202" height="50" ></iframe>
+<iframe scrolling="no" src="viewport-units-rounding-1-frame.html" width="203" height="50" ></iframe>
+<iframe scrolling="no" src="viewport-units-rounding-1-frame.html" width="204" height="50" ></iframe>
diff --git a/layout/reftests/pixel-rounding/viewport-units-rounding-2.html b/layout/reftests/pixel-rounding/viewport-units-rounding-2.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/pixel-rounding/viewport-units-rounding-2.html
@@ -0,0 +1,42 @@
+<!DOCTYPE HTML>
+<title>viewport units rounding test</title>
+<meta charset="UTF-8">
+<style>
+
+body > div > div { line-height: 1px }
+span {
+  display: inline-block;
+  height: 1px;
+  width: var(--w);
+  vertical-align: bottom;
+}
+span:nth-child(1) {
+  background: red;
+}
+span:nth-child(2) {
+  background: white;
+  margin-left: calc(-1 * var(--w));
+}
+
+</style>
+<body>
+<script>
+
+for (var p = 0; p < 20; ++p) {
+  var position = ((20 * p) + (p / 50)) + "px";
+  var container = document.createElement("div");
+  container.style.position = "absolute";
+  container.style.top = "0px";
+  container.style.left = position;
+  for (var w = 0; w < 99; ++w) {
+    var width = (0.5 + w / 100) + "vw";
+    var div = document.createElement("div");
+    div.setAttribute("style", "--w: " + width);
+    div.appendChild(document.createElement("span"));
+    div.appendChild(document.createElement("span"));
+    container.appendChild(div);
+  }
+  document.body.appendChild(container);
+}
+
+</script>
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -218,19 +218,27 @@ struct CalcLengthCalcOps : public css::B
   result_type ComputeLeafValue(const nsCSSValue& aValue)
   {
     return CalcLengthWith(aValue, mFontSize, mStyleFont,
                           mStyleContext, mPresContext, mUseProvidedRootEmSize,
                           mUseUserFontSet, mCanStoreInRuleTree);
   }
 };
 
-static inline nscoord ScaleCoord(const nsCSSValue &aValue, float factor)
-{
-  return NSToCoordRoundWithClamp(aValue.GetFloatValue() * factor);
+static inline nscoord ScaleCoord(const nsCSSValue& aValue, float aFactor)
+{
+  return NSToCoordRoundWithClamp(aValue.GetFloatValue() * aFactor);
+}
+
+static inline nscoord ScaleCoordFloor(const nsCSSValue& aValue, float aFactor)
+{
+  // For units (like percentages and viewport units) where authors might
+  // repeatedly use a value and expect some multiple of the value to be
+  // smaller than a container, we need to use floor rather than round.
+  return NSToCoordFloorClamped(aValue.GetFloatValue() * aFactor);
 }
 
 already_AddRefed<nsFontMetrics>
 GetMetricsFor(nsPresContext* aPresContext,
               nsStyleContext* aStyleContext,
               const nsStyleFont* aStyleFont,
               nscoord aFontSize, // overrides value from aStyleFont
               bool aUseUserFontSet)
@@ -346,28 +354,32 @@ static nscoord CalcLengthWith(const nsCS
     // throws away the style context and the rule tree.
     // Thus we do cache viewport units in the rule tree.  This allows us
     // to benefit from the performance advantages of the rule tree
     // (e.g., faster dynamic changes on other things, like transforms)
     // and allows us not to need an additional code path, in exchange
     // for an increased cost to dynamic changes to the viewport size
     // when viewport units are in use.
     case eCSSUnit_ViewportWidth: {
-      return ScaleCoord(aValue, 0.01f * CalcViewportUnitsScale(aPresContext).width);
+      nscoord viewportWidth = CalcViewportUnitsScale(aPresContext).width;
+      return ScaleCoordFloor(aValue, 0.01f * viewportWidth);
     }
     case eCSSUnit_ViewportHeight: {
-      return ScaleCoord(aValue, 0.01f * CalcViewportUnitsScale(aPresContext).height);
+      nscoord viewportHeight = CalcViewportUnitsScale(aPresContext).height;
+      return ScaleCoordFloor(aValue, 0.01f * viewportHeight);
     }
     case eCSSUnit_ViewportMin: {
       nsSize vuScale(CalcViewportUnitsScale(aPresContext));
-      return ScaleCoord(aValue, 0.01f * min(vuScale.width, vuScale.height));
+      nscoord viewportMin = min(vuScale.width, vuScale.height);
+      return ScaleCoordFloor(aValue, 0.01f * viewportMin);
     }
     case eCSSUnit_ViewportMax: {
       nsSize vuScale(CalcViewportUnitsScale(aPresContext));
-      return ScaleCoord(aValue, 0.01f * max(vuScale.width, vuScale.height));
+      nscoord viewportMax = max(vuScale.width, vuScale.height);
+      return ScaleCoordFloor(aValue, 0.01f * viewportMax);
     }
     // While we could deal with 'rem' units correctly by simply not
     // caching any data that uses them in the rule tree, it's valuable
     // to store them in the rule tree (for faster dynamic changes of
     // other things).  And since the font size of the root element
     // changes rarely, we instead handle dynamic changes to the root
     // element's font size by rebuilding all style data in
     // nsCSSFrameConstructor::RestyleElement.
