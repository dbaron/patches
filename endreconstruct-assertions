Add assertions to EndReconstruct that all style contexts have been reresolved.  (Bug 473871)

diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -75,16 +75,24 @@ nsStyleContext::nsStyleContext(nsStyleCo
     mBits(0),
     mRefCnt(0)
 {
   mNextSibling = this;
   mPrevSibling = this;
   if (mParent) {
     mParent->AddRef();
     mParent->AddChild(this);
+#ifdef DEBUG
+    nsRuleNode *r1 = mParent->GetRuleNode(), *r2 = aRuleNode;
+    while (r1->GetParent())
+      r1 = r1->GetParent();
+    while (r2->GetParent())
+      r2 = r2->GetParent();
+    NS_ABORT_IF_FALSE(r1 == r2, "must be in the same rule tree as parent");
+#endif
   }
 
   ApplyStyleFixups(aPresContext);
 
   #define eStyleStruct_LastItem (nsStyleStructID_Length - 1)
   NS_ASSERTION(NS_STYLE_INHERIT_MASK & NS_STYLE_INHERIT_BIT(LastItem),
                "NS_STYLE_INHERIT_MASK must be bigger, and other bits shifted");
   #undef eStyleStruct_LastItem
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -102,18 +102,16 @@ public:
     }
     return mRefCnt;
   }
 
   nsPresContext* PresContext() const { return mRuleNode->GetPresContext(); }
 
   nsStyleContext* GetParent() const { return mParent; }
 
-  nsStyleContext* GetFirstChild() const { return mChild; }
-
   nsIAtom* GetPseudoType() const { return mPseudoTag; }
 
   NS_HIDDEN_(already_AddRefed<nsStyleContext>)
   FindChildWithRules(const nsIAtom* aPseudoTag, nsRuleNode* aRules);
 
   NS_HIDDEN_(PRBool)    Equals(const nsStyleContext* aOther) const;
   PRBool    HasTextDecorations() { return !!(mBits & NS_STYLE_HAS_TEXT_DECORATIONS); }
 
@@ -173,17 +171,17 @@ public:
 #endif
 
 protected:
   NS_HIDDEN_(void) AddChild(nsStyleContext* aChild);
   NS_HIDDEN_(void) RemoveChild(nsStyleContext* aChild);
 
   NS_HIDDEN_(void) ApplyStyleFixups(nsPresContext* aPresContext);
 
-  nsStyleContext* mParent;
+  nsStyleContext* const mParent;
 
   // Children are kept in two circularly-linked lists.  The list anchor
   // is not part of the list (null for empty), and we point to the first
   // child.
   // mEmptyChild for children whose rule node is the root rule node, and
   // mChild for other children.  The order of children is not
   // meaningful.
   nsStyleContext* mChild;
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -139,28 +139,45 @@ nsStyleSet::BeginReconstruct()
     newTree->Destroy();
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   // Save the old rule tree so we can destroy it later
   mOldRuleTree = mRuleTree;
   // Delete mRuleWalker because it holds a reference to the rule tree root
   delete mRuleWalker;
-  // Clear out the old style contexts; we don't need them anymore
-  mRoots.Clear();
+  // We don't need to clear out mRoots; NotifyStyleContextDestroyed
+  // will, and they're useful in EndReconstruct if they don't get
+  // completely cleared out.
 
   mRuleTree = newTree;
   mRuleWalker = ruleWalker;
 
   return NS_OK;
 }
 
 void
 nsStyleSet::EndReconstruct()
 {
+#ifdef DEBUG
+  for (PRInt32 i = mRoots.Length() - 1; i >= 0; --i) {
+    nsRuleNode *n = mRoots[i]->GetRuleNode();
+    while (n->GetParent()) {
+      n = n->GetParent();
+    }
+    // Since nsStyleContext's mParent and mRuleNode are immutable, and
+    // style contexts own their parents, and nsStyleContext asserts in
+    // its constructor that the style context and its parent are in the
+    // same rule tree, we don't need to check any of the children of
+    // mRoots; we only need to check the rule nodes of mRoots
+    // themselves.
+
+    NS_ABORT_IF_FALSE(n == mRuleTree, "style context has old rule node");
+  }
+#endif
   NS_ASSERTION(mOldRuleTree, "Unmatched begin/end?");
   // Reset the destroyed count; it's no longer valid
   mDestroyedCount = 0;
   // Destroy the old rule tree (all the associated style contexts should have
   // been destroyed by the caller beforehand)
   mOldRuleTree->Destroy();
   mOldRuleTree = nsnull;
 }
