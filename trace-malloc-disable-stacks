From: L. David Baron <dbaron@dbaron.org>

Add option for disabling the stack-walking part of trace-malloc to improve performance of tinderbox test machines.  (FIXME: Need to fix 'no callsite for' in tmreader, possibly by changing the output.)  (Bug 549561)

diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -5715,17 +5715,17 @@ MOZ_ARG_DISABLE_BOOL(plugins,
 [  --disable-plugins       Disable plugins support],
     MOZ_PLUGINS=,
     MOZ_PLUGINS=1)
 
 dnl ========================================================
 dnl = Disable building dbm
 dnl ========================================================
 MOZ_ARG_DISABLE_BOOL(dbm,
-[  --disable-dbm       Disable building dbm],
+[  --disable-dbm           Disable building dbm],
     NSS_DISABLE_DBM=1,
     NSS_DISABLE_DBM=)
 
 dnl bi-directional support always on
 IBMBIDI=1
 AC_DEFINE(IBMBIDI)
 
 dnl ========================================================
@@ -5865,17 +5865,17 @@ if test -n "$MOZ_OGG"; then
                          [${ac_cv_c_attribute_aligned}],[Maximum supported data alignment])
     fi
 fi
 
 dnl ========================================================
 dnl = Disable VP8 decoder support
 dnl ========================================================
 MOZ_ARG_DISABLE_BOOL(webm,
-[  --disable-webm         Disable support for WebM media (VP8 video and Vorbis audio)],
+[  --disable-webm          Disable support for WebM media (VP8 video and Vorbis audio)],
     MOZ_WEBM=,
     MOZ_WEBM=1)
 
 if test -n "$MOZ_WEBM"; then
     AC_DEFINE(MOZ_WEBM)
     MOZ_SYDNEYAUDIO=1
     MOZ_MEDIA=1
     MOZ_VORBIS=1
@@ -7151,16 +7151,26 @@ MOZ_ARG_ENABLE_BOOL(trace-malloc,
 if test "$NS_TRACE_MALLOC"; then
   # Please, Mr. Linker Man, don't take away our symbol names
   MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS=
   USE_ELF_DYNSTR_GC=
   AC_DEFINE(NS_TRACE_MALLOC)
 fi
 AC_SUBST(NS_TRACE_MALLOC)
 
+NS_TRACE_MALLOC_NO_STACKS=
+MOZ_ARG_DISABLE_BOOL(trace-malloc-stacks,
+[  --disable-trace-malloc-stacks
+                          Disable stack walking in trace-malloc],
+    NS_TRACE_MALLOC_NO_STACKS=1,
+    NS_TRACE_MALLOC_NO_STACKS= )
+if test "$NS_TRACE_MALLOC_NO_STACKS"; then
+  AC_DEFINE(NS_TRACE_MALLOC_NO_STACKS)
+fi
+
 dnl ========================================================
 dnl = Enable jemalloc
 dnl ========================================================
 MOZ_ARG_ENABLE_BOOL(jemalloc,
 [  --enable-jemalloc       Replace memory allocator with jemalloc],
     MOZ_MEMORY=1,
     MOZ_MEMORY=)
 
diff --git a/tools/trace-malloc/lib/nsTraceMalloc.c b/tools/trace-malloc/lib/nsTraceMalloc.c
--- a/tools/trace-malloc/lib/nsTraceMalloc.c
+++ b/tools/trace-malloc/lib/nsTraceMalloc.c
@@ -926,16 +926,19 @@ stack_callback(void *pc, void *closure)
  * On return, if *immediate_abort is set, then the return value is NULL
  * and the thread is in a very dangerous situation (e.g. holding
  * sem_pool_lock in Mac OS X pthreads); the caller should bail out
  * without doing anything (such as acquiring locks).
  */
 callsite *
 backtrace(tm_thread *t, int skip, int *immediate_abort)
 {
+#ifdef NS_TRACE_MALLOC_NO_STACKS
+    return &calltree_root;
+#else
     callsite *site;
     stack_buffer_info *info = &t->backtrace_buf;
     void ** new_stack_buffer;
     size_t new_stack_buffer_size;
     nsresult rv;
 
     t->suppress_tracing++;
 
@@ -987,16 +990,17 @@ backtrace(tm_thread *t, int skip, int *i
     if (!site) {
         tmstats.backtrace_failures++;
         PR_ASSERT(tmstats.backtrace_failures < 100);
     }
     TM_EXIT_LOCK(t);
 
     t->suppress_tracing--;
     return site;
+#endif
 }
 
 typedef struct allocation {
     PLHashEntry entry;
     size_t      size;
     FILE        *trackfp;       /* for allocation tracking */
 } allocation;
 
diff --git a/xpcom/glue/DeadlockDetector.h b/xpcom/glue/DeadlockDetector.h
--- a/xpcom/glue/DeadlockDetector.h
+++ b/xpcom/glue/DeadlockDetector.h
@@ -53,17 +53,17 @@
 namespace mozilla {
 
 
 // FIXME bug 456272: split this off into a convenience API on top of
 // nsStackWalk?
 class NS_COM_GLUE CallStack
 {
 private:
-#ifdef NS_TRACE_MALLOC
+#if defined(NS_TRACE_MALLOC) && !defined(NS_TRACE_MALLOC_NO_STACKS)
     typedef nsTMStackTraceID callstack_id;
     // needs to be a macro to avoid disturbing the backtrace
 #   define NS_GET_BACKTRACE() NS_TraceMallocGetStackTrace()
 #else
     typedef void* callstack_id;
 #   define NS_GET_BACKTRACE() 0
 #endif  // ifdef NS_TRACE_MALLOC
 
@@ -104,17 +104,17 @@ public:
         return mCallStack != aOther.mCallStack;
     }
 
     // FIXME bug 456272: if this is split off,
     // NS_TraceMallocPrintStackTrace should be modified to print into
     // an nsACString
     void Print(FILE* f) const
     {
-#ifdef NS_TRACE_MALLOC
+#if defined(NS_TRACE_MALLOC) && !defined(NS_TRACE_MALLOC_NO_STACKS)
         if (this != &kNone && mCallStack) {
             NS_TraceMallocPrintStackTrace(f, mCallStack);
             return;
         }
 #endif
         fputs("  [stack trace unavailable]\n", f);
     }
 
diff --git a/xpcom/glue/nsAutoLock.cpp b/xpcom/glue/nsAutoLock.cpp
--- a/xpcom/glue/nsAutoLock.cpp
+++ b/xpcom/glue/nsAutoLock.cpp
@@ -281,17 +281,17 @@ nsAutoLockBase::nsAutoLockBase(void* add
             // Ignore reentry: it's legal for monitors, and NSPR will assert
             // if you reenter a PRLock.
         } else if (!addr) {
             // Ignore null addresses: the caller promises not to use the
             // lock at all, and NSPR will assert if you enter it.
         } else {
             const void* node =
 // This is too slow for dbaron on Windows!
-#if defined(NS_TRACE_MALLOC) && (!defined(DEBUG_dbaron) || !defined(XP_WIN))
+#if defined(NS_TRACE_MALLOC) && !defined(NS_TRACE_MALLOC_NO_STACKS) && (!defined(DEBUG_dbaron) || !defined(XP_WIN))
                 (const void*)NS_TraceMallocGetStackTrace();
 #else
                 nsnull
 #endif
                 ;
             nsNamedVector* vec1;
             nsNamedVector* vec2;
             PRUint32 i2;
@@ -301,17 +301,17 @@ nsAutoLockBase::nsAutoLockBase(void* add
                 PR_snprintf(buf, sizeof buf,
                             "Potential deadlock between %s%s@%p and %s%s@%p",
                             vec1->mName ? vec1->mName : "",
                             LockTypeNames[stackTop->mType],
                             stackTop->mAddr,
                             vec2->mName ? vec2->mName : "",
                             LockTypeNames[type],
                             addr);
-#ifdef NS_TRACE_MALLOC
+#if defined(NS_TRACE_MALLOC) && !defined(NS_TRACE_MALLOC_NO_STACKS)
                 fprintf(stderr, "\n*** %s\n\nCurrent stack:\n", buf);
                 NS_TraceMallocPrintStackTrace(stderr,
                                               NS_TraceMallocGetStackTrace());
 
                 fputs("\nPrevious stack:\n", stderr);
                 NS_TraceMallocPrintStackTrace(stderr,
                     (nsTMStackTraceIDStruct *)vec2->mInnerSites.ElementAt(i2));
                 putc('\n', stderr);
