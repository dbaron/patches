From: L. David Baron <dbaron@dbaron.org>

Add environment variable for disabling the stack-walking part of trace-malloc to improve performance of tinderbox test machines.  (Bug 549561)

diff --git a/tools/trace-malloc/lib/nsTraceMalloc.c b/tools/trace-malloc/lib/nsTraceMalloc.c
--- a/tools/trace-malloc/lib/nsTraceMalloc.c
+++ b/tools/trace-malloc/lib/nsTraceMalloc.c
@@ -60,16 +60,17 @@
 #include "prmon.h"
 #include "prprf.h"
 #include "prenv.h"
 #include "prnetdb.h"
 #include "nsTraceMalloc.h"
 #include "nscore.h"
 #include "prinit.h"
 #include "prthread.h"
+#include "plstr.h"
 #include "nsStackWalk.h"
 #include "nsTraceMallocCallbacks.h"
 
 #if defined(XP_MACOSX)
 
 #include <malloc/malloc.h>
 
 #define WRITE_FLAGS "w"
@@ -683,16 +684,29 @@ calltree(void **stack, size_t num_stack_
             }
         }
 
         /*
          * Not in tree at all, or not logged to fp: let's find our symbolic
          * callsite info.
          */
 
+#ifdef NS_TRACE_MALLOC_NO_STACKS
+        /*
+         * Fake the necessary information for our single fake stack
+         * frame.
+         */
+        PL_strncpyz(details.library, "stacks_disabled",
+                    sizeof(details.library));
+        details.loffset = 0;
+        details.filename[0] = '\0';
+        details.lineno = 0;
+        details.function[0] = '\0';
+        details.foffset = 0;
+#else
         /*
          * NS_DescribeCodeAddress can (on Linux) acquire a lock inside
          * the shared library loader.  Another thread might call malloc
          * while holding that lock (when loading a shared library).  So
          * we have to exit tmlock around this call.  For details, see
          * https://bugzilla.mozilla.org/show_bug.cgi?id=363334#c3
          *
          * We could be more efficient by building the nodes in the
@@ -702,16 +716,17 @@ calltree(void **stack, size_t num_stack_
          */
         TM_EXIT_LOCK(t);
         rv = NS_DescribeCodeAddress(pc, &details);
         TM_ENTER_LOCK(t);
         if (NS_FAILED(rv)) {
             tmstats.dladdr_failures++;
             goto fail;
         }
+#endif
 
         /* Check whether we need to emit a library trace record. */
         library_serial = 0;
         library = NULL;
         if (details.library[0]) {
             if (!libraries) {
                 libraries = PL_NewHashTable(100, PL_HashString,
                                             PL_CompareStrings, PL_CompareValues,
@@ -927,16 +942,33 @@ backtrace(tm_thread *t, int skip, int *i
     callsite *site;
     stack_buffer_info *info = &t->backtrace_buf;
     void ** new_stack_buffer;
     size_t new_stack_buffer_size;
     nsresult rv;
 
     t->suppress_tracing++;
 
+#ifdef NS_TRACE_MALLOC_NO_STACKS
+    /*
+     * Create a single fake stack frame so that all the tools get
+     * data in the correct format.
+     */
+    if (info->size < 1) {
+        PR_ASSERT(!info->buffer); /* !info->size == !info->buffer */
+        info->buffer = __libc_malloc(1 * sizeof(void*));
+        if (!info->buffer)
+            return NULL;
+        info->size = 1;
+    }
+
+    info->entries = 1;
+    /* Must be different from pc in calltree_root to miss recursion check */
+    info->buffer[0] = (void*)1;
+#else
     /*
      * NS_StackWalk can (on Windows) acquire a lock the shared library
      * loader.  Another thread might call malloc while holding that lock
      * (when loading a shared library).  So we can't be in tmlock during
      * this call.  For details, see
      * https://bugzilla.mozilla.org/show_bug.cgi?id=374829#c8
      */
 
@@ -966,16 +998,17 @@ backtrace(tm_thread *t, int skip, int *i
         info->size = new_stack_buffer_size;
 
         /* and call NS_StackWalk again */
         info->entries = 0;
         NS_StackWalk(stack_callback, skip, info);
 
         PR_ASSERT(info->entries * 2 == new_stack_buffer_size); /* same stack */
     }
+#endif
 
     TM_ENTER_LOCK(t);
 
     site = calltree(info->buffer, info->entries, t);
 
     tmstats.backtrace_calls++;
     if (!site) {
         tmstats.backtrace_failures++;
