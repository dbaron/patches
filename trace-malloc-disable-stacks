From: L. David Baron <dbaron@dbaron.org>

Add option for disabling the stack-walking part of trace-malloc to improve performance of tinderbox test machines.  (FIXME: Need to fix 'no callsite for' in tmreader, possibly by changing the output.)  (Bug 549561)

diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -5736,17 +5736,17 @@ MOZ_ARG_DISABLE_BOOL(plugins,
 [  --disable-plugins       Disable plugins support],
     MOZ_PLUGINS=,
     MOZ_PLUGINS=1)
 
 dnl ========================================================
 dnl = Disable building dbm
 dnl ========================================================
 MOZ_ARG_DISABLE_BOOL(dbm,
-[  --disable-dbm       Disable building dbm],
+[  --disable-dbm           Disable building dbm],
     NSS_DISABLE_DBM=1,
     NSS_DISABLE_DBM=)
 
 dnl bi-directional support always on
 IBMBIDI=1
 AC_DEFINE(IBMBIDI)
 
 dnl ========================================================
@@ -5886,17 +5886,17 @@ if test -n "$MOZ_OGG"; then
                          [${ac_cv_c_attribute_aligned}],[Maximum supported data alignment])
     fi
 fi
 
 dnl ========================================================
 dnl = Disable VP8 decoder support
 dnl ========================================================
 MOZ_ARG_DISABLE_BOOL(webm,
-[  --disable-webm         Disable support for WebM media (VP8 video and Vorbis audio)],
+[  --disable-webm          Disable support for WebM media (VP8 video and Vorbis audio)],
     MOZ_WEBM=,
     MOZ_WEBM=1)
 
 if test -n "$MOZ_WEBM"; then
     AC_DEFINE(MOZ_WEBM)
     MOZ_SYDNEYAUDIO=1
     MOZ_MEDIA=1
     MOZ_VORBIS=1
@@ -7178,16 +7178,26 @@ MOZ_ARG_ENABLE_BOOL(trace-malloc,
 if test "$NS_TRACE_MALLOC"; then
   # Please, Mr. Linker Man, don't take away our symbol names
   MOZ_COMPONENTS_VERSION_SCRIPT_LDFLAGS=
   USE_ELF_DYNSTR_GC=
   AC_DEFINE(NS_TRACE_MALLOC)
 fi
 AC_SUBST(NS_TRACE_MALLOC)
 
+NS_TRACE_MALLOC_NO_STACKS=
+MOZ_ARG_DISABLE_BOOL(trace-malloc-stacks,
+[  --disable-trace-malloc-stacks
+                          Disable stack walking in trace-malloc],
+    NS_TRACE_MALLOC_NO_STACKS=1,
+    NS_TRACE_MALLOC_NO_STACKS= )
+if test "$NS_TRACE_MALLOC_NO_STACKS"; then
+  AC_DEFINE(NS_TRACE_MALLOC_NO_STACKS)
+fi
+
 dnl ========================================================
 dnl = Enable jemalloc
 dnl ========================================================
 MOZ_ARG_ENABLE_BOOL(jemalloc,
 [  --enable-jemalloc       Replace memory allocator with jemalloc],
     MOZ_MEMORY=1,
     MOZ_MEMORY=)
 
diff --git a/tools/trace-malloc/lib/nsTraceMalloc.c b/tools/trace-malloc/lib/nsTraceMalloc.c
--- a/tools/trace-malloc/lib/nsTraceMalloc.c
+++ b/tools/trace-malloc/lib/nsTraceMalloc.c
@@ -60,16 +60,17 @@
 #include "prmon.h"
 #include "prprf.h"
 #include "prenv.h"
 #include "prnetdb.h"
 #include "nsTraceMalloc.h"
 #include "nscore.h"
 #include "prinit.h"
 #include "prthread.h"
+#include "plstr.h"
 #include "nsStackWalk.h"
 #include "nsTraceMallocCallbacks.h"
 #ifdef linux
 #include <signal.h>
 #include <sys/types.h>
 #include <unistd.h>
 #include <time.h>
 #endif
@@ -690,16 +691,29 @@ calltree(void **stack, size_t num_stack_
             }
         }
 
         /*
          * Not in tree at all, or not logged to fp: let's find our symbolic
          * callsite info.
          */
 
+#ifdef NS_TRACE_MALLOC_NO_STACKS
+        /*
+         * Fake the necessary information for our single fake stack
+         * frame.
+         */
+        PL_strncpyz(details.library, "stacks_disabled",
+                    sizeof(details.library));
+        details.loffset = 0;
+        details.filename[0] = '\0';
+        details.lineno = 0;
+        details.function[0] = '\0';
+        details.foffset = 0;
+#else
         /*
          * NS_DescribeCodeAddress can (on Linux) acquire a lock inside
          * the shared library loader.  Another thread might call malloc
          * while holding that lock (when loading a shared library).  So
          * we have to exit tmlock around this call.  For details, see
          * https://bugzilla.mozilla.org/show_bug.cgi?id=363334#c3
          *
          * We could be more efficient by building the nodes in the
@@ -709,16 +723,17 @@ calltree(void **stack, size_t num_stack_
          */
         TM_EXIT_LOCK(t);
         rv = NS_DescribeCodeAddress(pc, &details);
         TM_ENTER_LOCK(t);
         if (NS_FAILED(rv)) {
             tmstats.dladdr_failures++;
             goto fail;
         }
+#endif
 
         /* Check whether we need to emit a library trace record. */
         library_serial = 0;
         library = NULL;
         if (details.library[0]) {
             if (!libraries) {
                 libraries = PL_NewHashTable(100, PL_HashString,
                                             PL_CompareStrings, PL_CompareValues,
@@ -934,16 +949,33 @@ backtrace(tm_thread *t, int skip, int *i
     callsite *site;
     stack_buffer_info *info = &t->backtrace_buf;
     void ** new_stack_buffer;
     size_t new_stack_buffer_size;
     nsresult rv;
 
     t->suppress_tracing++;
 
+#ifdef NS_TRACE_MALLOC_NO_STACKS
+    /*
+     * Create a single fake stack frame so that all the tools get
+     * data in the correct format.
+     */
+    if (info->size < 1) {
+        PR_ASSERT(!info->buffer); /* !info->size == !info->buffer */
+        info->buffer = __libc_malloc(1 * sizeof(void*));
+        if (!info->buffer)
+            return NULL;
+        info->size = 1;
+    }
+
+    info->entries = 1;
+    /* Must be different from pc in calltree_root to miss recursion check */
+    info->buffer[0] = (void*)1;
+#else
     /*
      * NS_StackWalk can (on Windows) acquire a lock the shared library
      * loader.  Another thread might call malloc while holding that lock
      * (when loading a shared library).  So we can't be in tmlock during
      * this call.  For details, see
      * https://bugzilla.mozilla.org/show_bug.cgi?id=374829#c8
      */
 
@@ -973,16 +1005,17 @@ backtrace(tm_thread *t, int skip, int *i
         info->size = new_stack_buffer_size;
 
         /* and call NS_StackWalk again */
         info->entries = 0;
         NS_StackWalk(stack_callback, skip, info);
 
         PR_ASSERT(info->entries * 2 == new_stack_buffer_size); /* same stack */
     }
+#endif
 
     TM_ENTER_LOCK(t);
 
     site = calltree(info->buffer, info->entries, t);
 
     tmstats.backtrace_calls++;
     if (!site) {
         tmstats.backtrace_failures++;
diff --git a/xpcom/glue/DeadlockDetector.h b/xpcom/glue/DeadlockDetector.h
--- a/xpcom/glue/DeadlockDetector.h
+++ b/xpcom/glue/DeadlockDetector.h
@@ -53,17 +53,17 @@
 namespace mozilla {
 
 
 // FIXME bug 456272: split this off into a convenience API on top of
 // nsStackWalk?
 class NS_COM_GLUE CallStack
 {
 private:
-#ifdef NS_TRACE_MALLOC
+#if defined(NS_TRACE_MALLOC) && !defined(NS_TRACE_MALLOC_NO_STACKS)
     typedef nsTMStackTraceID callstack_id;
     // needs to be a macro to avoid disturbing the backtrace
 #   define NS_GET_BACKTRACE() NS_TraceMallocGetStackTrace()
 #else
     typedef void* callstack_id;
 #   define NS_GET_BACKTRACE() 0
 #endif  // ifdef NS_TRACE_MALLOC
 
@@ -104,17 +104,17 @@ public:
         return mCallStack != aOther.mCallStack;
     }
 
     // FIXME bug 456272: if this is split off,
     // NS_TraceMallocPrintStackTrace should be modified to print into
     // an nsACString
     void Print(FILE* f) const
     {
-#ifdef NS_TRACE_MALLOC
+#if defined(NS_TRACE_MALLOC) && !defined(NS_TRACE_MALLOC_NO_STACKS)
         if (this != &kNone && mCallStack) {
             NS_TraceMallocPrintStackTrace(f, mCallStack);
             return;
         }
 #endif
         fputs("  [stack trace unavailable]\n", f);
     }
 
diff --git a/xpcom/glue/nsAutoLock.cpp b/xpcom/glue/nsAutoLock.cpp
--- a/xpcom/glue/nsAutoLock.cpp
+++ b/xpcom/glue/nsAutoLock.cpp
@@ -281,17 +281,17 @@ nsAutoLockBase::nsAutoLockBase(void* add
             // Ignore reentry: it's legal for monitors, and NSPR will assert
             // if you reenter a PRLock.
         } else if (!addr) {
             // Ignore null addresses: the caller promises not to use the
             // lock at all, and NSPR will assert if you enter it.
         } else {
             const void* node =
 // This is too slow for dbaron on Windows!
-#if defined(NS_TRACE_MALLOC) && (!defined(DEBUG_dbaron) || !defined(XP_WIN))
+#if defined(NS_TRACE_MALLOC) && !defined(NS_TRACE_MALLOC_NO_STACKS) && (!defined(DEBUG_dbaron) || !defined(XP_WIN))
                 (const void*)NS_TraceMallocGetStackTrace();
 #else
                 nsnull
 #endif
                 ;
             nsNamedVector* vec1;
             nsNamedVector* vec2;
             PRUint32 i2;
@@ -301,17 +301,17 @@ nsAutoLockBase::nsAutoLockBase(void* add
                 PR_snprintf(buf, sizeof buf,
                             "Potential deadlock between %s%s@%p and %s%s@%p",
                             vec1->mName ? vec1->mName : "",
                             LockTypeNames[stackTop->mType],
                             stackTop->mAddr,
                             vec2->mName ? vec2->mName : "",
                             LockTypeNames[type],
                             addr);
-#ifdef NS_TRACE_MALLOC
+#if defined(NS_TRACE_MALLOC) && !defined(NS_TRACE_MALLOC_NO_STACKS)
                 fprintf(stderr, "\n*** %s\n\nCurrent stack:\n", buf);
                 NS_TraceMallocPrintStackTrace(stderr,
                                               NS_TraceMallocGetStackTrace());
 
                 fputs("\nPrevious stack:\n", stderr);
                 NS_TraceMallocPrintStackTrace(stderr,
                     (nsTMStackTraceIDStruct *)vec2->mInnerSites.ElementAt(i2));
                 putc('\n', stderr);
