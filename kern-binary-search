From: L. David Baron <dbaron@dbaron.org>

Don't try to read the entry one past the end of the table.  (Bug 593296)

diff --git a/gfx/thebes/gfxHarfBuzzShaper.cpp b/gfx/thebes/gfxHarfBuzzShaper.cpp
--- a/gfx/thebes/gfxHarfBuzzShaper.cpp
+++ b/gfx/thebes/gfxHarfBuzzShaper.cpp
@@ -277,26 +277,37 @@ GetKernValueFmt0(const void* aSubtable,
                  PRUint16 aSecondGlyph,
                  PRInt32& aValue,
                  PRBool   aIsOverride = PR_FALSE,
                  PRBool   aIsMinimum = PR_FALSE)
 {
     const KernHeaderFmt0* hdr =
         reinterpret_cast<const KernHeaderFmt0*>(aSubtable);
 
+    // Start off with lo as the lowest valid pointer and hi one above
+    // the highest valid pointer.
     const KernPair *lo = reinterpret_cast<const KernPair*>(hdr + 1);
     const KernPair *hi = lo + PRUint16(hdr->nPairs);
 
     if (reinterpret_cast<const char*>(aSubtable) + aSubtableLen <
         reinterpret_cast<const char*>(hi)) {
         // subtable is not large enough to contain the claimed number
         // of kern pairs, so just ignore it
         return;
     }
 
+    if (hi == lo) {
+        // The table claims 0 pairs.
+        return;
+    }
+
+    // Change so that lo and hi are now the lowest and highest valid
+    // pointers.
+    --hi;
+
 #define KERN_PAIR_KEY(l,r) (PRUint32((PRUint16(l) << 16) + PRUint16(r)))
 
     PRUint32 key = KERN_PAIR_KEY(aFirstGlyph, aSecondGlyph);
     while (lo < hi) {
         const KernPair *mid = lo + (hi - lo) / 2;
         if (KERN_PAIR_KEY(mid->left, mid->right) < key) {
             lo = mid + 1;
         } else {
