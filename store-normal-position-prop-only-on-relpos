From: L. David Baron <dbaron@dbaron.org>

We should not store the NormalPositionProperty on all frames, only relatively positioned ones.

diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -844,27 +844,37 @@ nsHTMLReflowState::ComputeRelativeOffset
   }
 }
 
 /* static */ void
 nsHTMLReflowState::ApplyRelativePositioning(nsIFrame* aFrame,
                                             const nsMargin& aComputedOffsets,
                                             nsPoint* aPosition)
 {
+  const nsStyleDisplay* display = aFrame->StyleDisplay();
+
+  if (!display->IsRelativelyPositionedStyle()) {
+    NS_ASSERTION(!aFrame->Properties().Get(nsIFrame::NormalPositionProperty()),
+                 "We assume that changing the 'position' property causes "
+                 "frame reconstruction.  If that ever changes, this code "
+                 "should call "
+                 "props.Delete(nsIFrame::NormalPositionProperty())");
+    return;
+  }
+
   // Store the normal position
   FrameProperties props = aFrame->Properties();
   nsPoint* normalPosition = static_cast<nsPoint*>
     (props.Get(nsIFrame::NormalPositionProperty()));
   if (normalPosition) {
     *normalPosition = *aPosition;
   } else {
     props.Set(nsIFrame::NormalPositionProperty(), new nsPoint(*aPosition));
   }
 
-  const nsStyleDisplay* display = aFrame->StyleDisplay();
   if (NS_STYLE_POSITION_RELATIVE == display->mPosition) {
     *aPosition += nsPoint(aComputedOffsets.left, aComputedOffsets.top);
   } else if (NS_STYLE_POSITION_STICKY == display->mPosition) {
     StickyScrollContainer* ssc =
       StickyScrollContainer::GetStickyScrollContainerForFrame(aFrame);
     if (ssc) {
       *aPosition = ssc->ComputePosition(aFrame);
     }
