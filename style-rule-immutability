From: L. David Baron <dbaron@dbaron.org>

Make CSS style rule implementations hold on to their data block once MapRuleInfoInto has been called so that they follow the immutability contract of nsIStyleRule.  (Bug 522595)

diff --git a/layout/reftests/css-transitions/transitions-inline-already-wrapped-1.html b/layout/reftests/css-transitions/transitions-inline-already-wrapped-1.html
--- a/layout/reftests/css-transitions/transitions-inline-already-wrapped-1.html
+++ b/layout/reftests/css-transitions/transitions-inline-already-wrapped-1.html
@@ -5,25 +5,18 @@
 </style>
 <script type="text/javascript">
 
 window.onload = run;
 
 function run() {
   var test = document.getElementById("test");
   var unused = test.offsetWidth;
-  // FIXME (Bug 522595): It's a bug that we need to do this at all: the
-  // way we change style data essentially violates style rule
-  // immutability because we assume that all of the difference
-  // calculation will use PeekStyleData, which is no longer true with
-  // transitions.
-  unused = getComputedStyle(test, "").color;
   test.style.color = "red";
   unused = test.offsetWidth;
-  unused = getComputedStyle(test, "").color;
   document.documentElement.removeAttribute("class");
 }
 
 </script>
 <div style="width: 3em">
 <span id="test" style="color: green">
 This is some text with a transition.
 </span>
diff --git a/layout/reftests/css-transitions/transitions-inline-rewrap-1.html b/layout/reftests/css-transitions/transitions-inline-rewrap-1.html
--- a/layout/reftests/css-transitions/transitions-inline-rewrap-1.html
+++ b/layout/reftests/css-transitions/transitions-inline-rewrap-1.html
@@ -5,28 +5,20 @@
 </style>
 <script type="text/javascript">
 
 window.onload = run;
 
 function run() {
   var test = document.getElementById("test");
   var unused = test.offsetWidth;
-  // FIXME (Bug 522595): It's a bug that we need to do this at all: the
-  // way we change style data essentially violates style rule
-  // immutability because we assume that all of the difference
-  // calculation will use PeekStyleData, which is no longer true with
-  // transitions.
-  unused = getComputedStyle(test, "").color;
   test.style.color = "red";
   unused = test.offsetWidth;
-  unused = getComputedStyle(test, "").color;
   test.parentNode.style.width = "3em";
   unused = test.offsetWidth;
-  unused = getComputedStyle(test, "").color;
   document.documentElement.removeAttribute("class");
 }
 
 </script>
 <div style="width: 50em">
 <span id="test" style="color: green">
 This is some text with a transition.
 </span>
diff --git a/layout/style/nsCSSDeclaration.h b/layout/style/nsCSSDeclaration.h
--- a/layout/style/nsCSSDeclaration.h
+++ b/layout/style/nsCSSDeclaration.h
@@ -86,23 +86,18 @@ public:
     return mOrder.Length(); 
   }
   nsresult GetNthProperty(PRUint32 aIndex, nsAString& aReturn) const;
 
   nsresult ToString(nsAString& aString) const;
 
   nsCSSDeclaration* Clone() const;
 
-  nsresult MapRuleInfoInto(nsRuleData *aRuleData) const {
-    return mData->MapRuleInfoInto(aRuleData);
-  }
-
-  nsresult MapImportantRuleInfoInto(nsRuleData *aRuleData) const {
-    return mImportantData->MapRuleInfoInto(aRuleData);
-  }
+  nsCSSCompressedDataBlock* GetNormalBlock() const { return mData; }
+  nsCSSCompressedDataBlock* GetImportantBlock() const { return mImportantData; }
 
   /**
    * Initialize this declaration as holding no data.  Return false on
    * out-of-memory.
    */
   PRBool InitializeEmpty();
 
   /**
diff --git a/layout/style/nsCSSStyleRule.cpp b/layout/style/nsCSSStyleRule.cpp
--- a/layout/style/nsCSSStyleRule.cpp
+++ b/layout/style/nsCSSStyleRule.cpp
@@ -815,71 +815,59 @@ nsCSSSelectorList::Clone(PRBool aDeep) c
 }
 
 // -- CSSImportantRule -------------------------------
 
 class CSSStyleRuleImpl;
 
 class CSSImportantRule : public nsIStyleRule {
 public:
-  CSSImportantRule(nsCSSDeclaration* aDeclaration);
+  CSSImportantRule(nsCSSCompressedDataBlock *aImportantBlock);
 
   NS_DECL_ISUPPORTS
 
   // nsIStyleRule interface
   NS_IMETHOD MapRuleInfoInto(nsRuleData* aRuleData);
 #ifdef DEBUG
   NS_IMETHOD List(FILE* out = stdout, PRInt32 aIndent = 0) const;
 #endif
 
 protected:
   virtual ~CSSImportantRule(void);
 
-  nsCSSDeclaration*  mDeclaration;
+  nsRefPtr<nsCSSCompressedDataBlock> mImportantBlock;
 
   friend class CSSStyleRuleImpl;
 };
 
-CSSImportantRule::CSSImportantRule(nsCSSDeclaration* aDeclaration)
-  : mDeclaration(aDeclaration)
+CSSImportantRule::CSSImportantRule(nsCSSCompressedDataBlock* aImportantBlock)
+  : mImportantBlock(aImportantBlock)
 {
 }
 
 CSSImportantRule::~CSSImportantRule(void)
 {
-  mDeclaration = nsnull;
 }
 
 NS_IMPL_ISUPPORTS1(CSSImportantRule, nsIStyleRule)
 
 NS_IMETHODIMP
 CSSImportantRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
-  // Check this at runtime because it might be hit in some out-of-memory cases.
-  NS_ENSURE_TRUE(mDeclaration->HasImportantData(), NS_ERROR_UNEXPECTED);
-
-  return mDeclaration->MapImportantRuleInfoInto(aRuleData);
+  return mImportantBlock->MapRuleInfoInto(aRuleData);
 }
 
 #ifdef DEBUG
 NS_IMETHODIMP
 CSSImportantRule::List(FILE* out, PRInt32 aIndent) const
 {
   // Indent
   for (PRInt32 index = aIndent; --index >= 0; ) fputs("  ", out);
 
-  fputs("! Important rule ", out);
-  if (nsnull != mDeclaration) {
-    mDeclaration->List(out);
-  }
-  else {
-    fputs("{ null declaration }", out);
-  }
-  fputs("\n", out);
-
+  fprintf(out, "! Important rule block=%p\n", mImportantBlock);
   return NS_OK;
 }
 #endif
 
 // --------------------------------------------------------
 
 class DOMCSSStyleRuleImpl;
 
@@ -1273,16 +1261,17 @@ private:
   CSSStyleRuleImpl& operator=(const CSSStyleRuleImpl& aCopy); 
 
 protected:
   virtual ~CSSStyleRuleImpl(void);
 
 protected:
   nsCSSSelectorList*      mSelector; // null for style attribute
   nsCSSDeclaration*       mDeclaration;
+  nsRefPtr<nsCSSCompressedDataBlock> mNormalBlock;
   CSSImportantRule*       mImportantRule;
   DOMCSSStyleRuleImpl*    mDOMRule;                          
   PRUint32                mLineNumber;
 };
 
 CSSStyleRuleImpl::CSSStyleRuleImpl(nsCSSSelectorList* aSelector,
                                    nsCSSDeclaration* aDeclaration)
   : nsCSSRule(),
@@ -1320,27 +1309,27 @@ CSSStyleRuleImpl::CSSStyleRuleImpl(CSSSt
     mLineNumber(aCopy.mLineNumber)
 {
   // The DOM rule is replacing |aCopy| with |this|, so transfer
   // the reverse pointer as well (and transfer ownership).
   aCopy.mDOMRule = nsnull;
 
   NS_ASSERTION(aDeclaration == aCopy.mDeclaration, "declaration mismatch");
   // Transfer ownership of selector and declaration:
+  // NOTE that transferring ownership of the declaration relies on the
+  // code in RuleMatched caching what we need from mDeclaration so that
+  // mDeclaration unused in CSSStyleRuleImpl::GetImportantRule,
+  // CSSStyleRuleImpl::MapRuleInfoInto, and
+  // CSSImportantRule::MapRuleInfoInto.  This means that any style rule
+  // that has become part of the rule tree has already retrieved the
+  // necessary data blocks from its declaration, so any later
+  // MapRuleInfoInto calls (see stack in bug 209575; also needed for CSS
+  // Transitions) and GetImportantRule calls will also work.
   aCopy.mSelector = nsnull;
-#if 0
   aCopy.mDeclaration = nsnull;
-#else
-  // We ought to be able to transfer ownership of the selector and the
-  // declaration since this rule should now be unused, but unfortunately
-  // SetInlineStyleRule might use it before setting the new rule (see
-  // stack in bug 209575).  So leave the declaration pointer on the old
-  // rule.
-  mDeclaration->AddRef();
-#endif
 }
 
 
 CSSStyleRuleImpl::~CSSStyleRuleImpl(void)
 {
   if (mSelector) {
     delete mSelector;
     mSelector = nsnull;
@@ -1394,18 +1383,26 @@ already_AddRefed<nsIStyleRule> CSSStyleR
 {
   NS_IF_ADDREF(mImportantRule);
   return mImportantRule;
 }
 
 /* virtual */ void
 CSSStyleRuleImpl::RuleMatched()
 {
-  if (mDeclaration->HasImportantData() && !mImportantRule) {
-    mImportantRule = new CSSImportantRule(mDeclaration);
+  if (mNormalBlock) {
+    // This method has already been called.
+    return;
+  }
+  NS_ABORT_IF_FALSE(!mImportantRule, "should not have important rule either");
+
+  mNormalBlock = mDeclaration->GetNormalBlock();
+
+  if (mDeclaration->HasImportantData()) {
+    mImportantRule = new CSSImportantRule(mDeclaration->GetImportantBlock());
     NS_IF_ADDREF(mImportantRule);
   }
 }
 
 NS_IMETHODIMP
 CSSStyleRuleImpl::GetStyleSheet(nsIStyleSheet*& aSheet) const
 {
 // XXX What about inner, etc.
@@ -1483,17 +1480,17 @@ CSSStyleRuleImpl::DeclarationChanged(PRB
   }
 
   return clone;
 }
 
 NS_IMETHODIMP
 CSSStyleRuleImpl::MapRuleInfoInto(nsRuleData* aRuleData)
 {
-  return mDeclaration->MapRuleInfoInto(aRuleData);
+  return mNormalBlock->MapRuleInfoInto(aRuleData);
 }
 
 #ifdef DEBUG
 NS_IMETHODIMP
 CSSStyleRuleImpl::List(FILE* out, PRInt32 aIndent) const
 {
   // Indent
   for (PRInt32 index = aIndent; --index >= 0; ) fputs("  ", out);
