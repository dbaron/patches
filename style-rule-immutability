From: L. David Baron <dbaron@dbaron.org>

Make CSS style rule implementations hold on to their data block once MapRuleInfoInto has been called so that they follow the immutability contract of nsIStyleRule.  (Bug 522595)

diff --git a/layout/style/nsCSSDeclaration.h b/layout/style/nsCSSDeclaration.h
--- a/layout/style/nsCSSDeclaration.h
+++ b/layout/style/nsCSSDeclaration.h
@@ -86,23 +86,18 @@ public:
     return mOrder.Length(); 
   }
   nsresult GetNthProperty(PRUint32 aIndex, nsAString& aReturn) const;
 
   nsresult ToString(nsAString& aString) const;
 
   nsCSSDeclaration* Clone() const;
 
-  nsresult MapRuleInfoInto(nsRuleData *aRuleData) const {
-    return mData->MapRuleInfoInto(aRuleData);
-  }
-
-  nsresult MapImportantRuleInfoInto(nsRuleData *aRuleData) const {
-    return mImportantData->MapRuleInfoInto(aRuleData);
-  }
+  nsCSSCompressedDataBlock* GetNormalBlock() const { return mData; }
+  nsCSSCompressedDataBlock* GetImportantBlock() const { return mImportantData; }
 
   /**
    * Initialize this declaration as holding no data.  Return false on
    * out-of-memory.
    */
   PRBool InitializeEmpty();
 
   /**
diff --git a/layout/style/nsCSSStyleRule.cpp b/layout/style/nsCSSStyleRule.cpp
--- a/layout/style/nsCSSStyleRule.cpp
+++ b/layout/style/nsCSSStyleRule.cpp
@@ -829,16 +829,17 @@ public:
 #ifdef DEBUG
   NS_IMETHOD List(FILE* out = stdout, PRInt32 aIndent = 0) const;
 #endif
 
 protected:
   virtual ~CSSImportantRule(void);
 
   nsCSSDeclaration*  mDeclaration;
+  nsRefPtr<nsCSSCompressedDataBlock> mImportantBlock;
 
   friend class CSSStyleRuleImpl;
 };
 
 CSSImportantRule::CSSImportantRule(nsCSSDeclaration* aDeclaration)
   : mDeclaration(aDeclaration)
 {
 }
@@ -850,18 +851,21 @@ CSSImportantRule::~CSSImportantRule(void
 
 NS_IMPL_ISUPPORTS1(CSSImportantRule, nsIStyleRule)
 
 NS_IMETHODIMP
 CSSImportantRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   // Check this at runtime because it might be hit in some out-of-memory cases.
   NS_ENSURE_TRUE(mDeclaration->HasImportantData(), NS_ERROR_UNEXPECTED);
+  if (!mImportantBlock) {
+    mImportantBlock = mDeclaration->GetImportantBlock();
+  }
 
-  return mDeclaration->MapImportantRuleInfoInto(aRuleData);
+  return mImportantBlock->MapRuleInfoInto(aRuleData);
 }
 
 #ifdef DEBUG
 NS_IMETHODIMP
 CSSImportantRule::List(FILE* out, PRInt32 aIndent) const
 {
   // Indent
   for (PRInt32 index = aIndent; --index >= 0; ) fputs("  ", out);
@@ -1265,16 +1269,17 @@ private:
   CSSStyleRuleImpl& operator=(const CSSStyleRuleImpl& aCopy); 
 
 protected:
   virtual ~CSSStyleRuleImpl(void);
 
 protected:
   nsCSSSelectorList*      mSelector; // null for style attribute
   nsCSSDeclaration*       mDeclaration;
+  nsRefPtr<nsCSSCompressedDataBlock> mNormalBlock;
   CSSImportantRule*       mImportantRule;
   DOMCSSStyleRuleImpl*    mDOMRule;                          
   PRUint32                mLineNumber;
 };
 
 CSSStyleRuleImpl::CSSStyleRuleImpl(nsCSSSelectorList* aSelector,
                                    nsCSSDeclaration* aDeclaration)
   : nsCSSRule(),
@@ -1312,27 +1317,24 @@ CSSStyleRuleImpl::CSSStyleRuleImpl(CSSSt
     mLineNumber(aCopy.mLineNumber)
 {
   // The DOM rule is replacing |aCopy| with |this|, so transfer
   // the reverse pointer as well (and transfer ownership).
   aCopy.mDOMRule = nsnull;
 
   NS_ASSERTION(aDeclaration == aCopy.mDeclaration, "declaration mismatch");
   // Transfer ownership of selector and declaration:
+  // NOTE that transferring ownership of the declaration relies on our
+  // making *some* MapRuleInfoInto calls immediately when we construct
+  // the rule tree.  This means that any style rule that has become part
+  // of the rule tree has already retrieved the necessary data blocks
+  // from its declaration, so any later MapRuleInfoInto calls (see stack
+  // in bug 209575; also needed for CSS Transitions) will also work.
   aCopy.mSelector = nsnull;
-#if 0
   aCopy.mDeclaration = nsnull;
-#else
-  // We ought to be able to transfer ownership of the selector and the
-  // declaration since this rule should now be unused, but unfortunately
-  // SetInlineStyleRule might use it before setting the new rule (see
-  // stack in bug 209575).  So leave the declaration pointer on the old
-  // rule.
-  mDeclaration->AddRef();
-#endif
 }
 
 
 CSSStyleRuleImpl::~CSSStyleRuleImpl(void)
 {
   if (mSelector) {
     delete mSelector;
     mSelector = nsnull;
@@ -1477,17 +1479,20 @@ CSSStyleRuleImpl::DeclarationChanged(PRB
   }
 
   return clone;
 }
 
 NS_IMETHODIMP
 CSSStyleRuleImpl::MapRuleInfoInto(nsRuleData* aRuleData)
 {
-  return mDeclaration->MapRuleInfoInto(aRuleData);
+  if (!mNormalBlock) {
+    mNormalBlock = mDeclaration->GetNormalBlock();
+  }
+  return mNormalBlock->MapRuleInfoInto(aRuleData);
 }
 
 #ifdef DEBUG
 NS_IMETHODIMP
 CSSStyleRuleImpl::List(FILE* out, PRInt32 aIndent) const
 {
   // Indent
   for (PRInt32 index = aIndent; --index >= 0; ) fputs("  ", out);
