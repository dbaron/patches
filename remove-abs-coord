From: Zack Weinberg <zweinberg@mozilla.com>

Delete nsLayoutUtils::GetAbsoluteCoord(); fold logic into callers and simplify.  (Bug 437335)  r+sr=dbaron

diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -1488,19 +1488,27 @@ static nscoord AddPercents(nsLayoutUtils
     if (aPercent >= 1.0f)
       result = nscoord_MAX;
     else
       result = NSToCoordRound(float(result) / (1.0f - aPercent));
   }
   return result;
 }
 
+static PRBool GetAbsoluteCoord(const nsStyleCoord& aStyle, nscoord& aResult)
+{
+  if (eStyleUnit_Coord != aStyle.GetUnit())
+    return PR_FALSE;
+  
+  aResult = aStyle.GetCoordValue();
+  return PR_TRUE;
+}
+
 static PRBool
 GetPercentHeight(const nsStyleCoord& aStyle,
-                 nsIRenderingContext* aRenderingContext,
                  nsIFrame* aFrame,
                  nscoord& aResult)
 {
   if (eStyleUnit_Percent != aStyle.GetUnit())
     return PR_FALSE;
 
   nsIFrame *f;
   for (f = aFrame->GetParent(); f && !f->IsContainingBlock();
@@ -1508,46 +1516,43 @@ GetPercentHeight(const nsStyleCoord& aSt
     ;
   if (!f) {
     NS_NOTREACHED("top of frame tree not a containing block");
     return PR_FALSE;
   }
 
   const nsStylePosition *pos = f->GetStylePosition();
   nscoord h;
-  if (!nsLayoutUtils::
-        GetAbsoluteCoord(pos->mHeight, aRenderingContext, f, h) &&
-      !GetPercentHeight(pos->mHeight, aRenderingContext, f, h)) {
+  if (!GetAbsoluteCoord(pos->mHeight, h) &&
+      !GetPercentHeight(pos->mHeight, f, h)) {
     NS_ASSERTION(pos->mHeight.GetUnit() == eStyleUnit_Auto ||
                  pos->mHeight.GetUnit() == eStyleUnit_Percent,
                  "unknown height unit");
     // There's no basis for the percentage height, so it acts like auto.
     // Should we consider a max-height < min-height pair a basis for
     // percentage heights?  The spec is somewhat unclear, and not doing
     // so is simpler and avoids troubling discontinuities in behavior,
     // so I'll choose not to. -LDB
     return PR_FALSE;
   }
 
   nscoord maxh;
-  if (nsLayoutUtils::
-        GetAbsoluteCoord(pos->mMaxHeight, aRenderingContext, f, maxh) ||
-      GetPercentHeight(pos->mMaxHeight, aRenderingContext, f, maxh)) {
+  if (GetAbsoluteCoord(pos->mMaxHeight, maxh) ||
+      GetPercentHeight(pos->mMaxHeight, f, maxh)) {
     if (maxh < h)
       h = maxh;
   } else {
     NS_ASSERTION(pos->mMaxHeight.GetUnit() == eStyleUnit_None ||
                  pos->mMaxHeight.GetUnit() == eStyleUnit_Percent,
                  "unknown max-height unit");
   }
 
   nscoord minh;
-  if (nsLayoutUtils::
-        GetAbsoluteCoord(pos->mMinHeight, aRenderingContext, f, minh) ||
-      GetPercentHeight(pos->mMinHeight, aRenderingContext, f, minh)) {
+  if (GetAbsoluteCoord(pos->mMinHeight, minh) ||
+      GetPercentHeight(pos->mMinHeight, f, minh)) {
     if (minh > h)
       h = minh;
   } else {
     NS_ASSERTION(pos->mMinHeight.GetUnit() == eStyleUnit_Percent,
                  "unknown min-height unit");
   }
 
   aResult = NSToCoordRound(aStyle.GetPercentValue() * h);
@@ -1681,31 +1686,31 @@ nsLayoutUtils::IntrinsicForContainer(nsI
           styleMinHeight.GetCoordValue() == 0) ||
         styleMaxHeight.GetUnit() != eStyleUnit_None) {
 
       nsSize ratio = aFrame->GetIntrinsicRatio();
 
       if (ratio.height != 0) {
 
         nscoord h;
-        if (GetAbsoluteCoord(styleHeight, aRenderingContext, aFrame, h) ||
-            GetPercentHeight(styleHeight, aRenderingContext, aFrame, h)) {
+        if (GetAbsoluteCoord(styleHeight, h) ||
+            GetPercentHeight(styleHeight, aFrame, h)) {
           result =
             NSToCoordRound(h * (float(ratio.width) / float(ratio.height)));
         }
 
-        if (GetAbsoluteCoord(styleMaxHeight, aRenderingContext, aFrame, h) ||
-            GetPercentHeight(styleMaxHeight, aRenderingContext, aFrame, h)) {
+        if (GetAbsoluteCoord(styleMaxHeight, h) ||
+            GetPercentHeight(styleMaxHeight, aFrame, h)) {
           h = NSToCoordRound(h * (float(ratio.width) / float(ratio.height)));
           if (h < result)
             result = h;
         }
 
-        if (GetAbsoluteCoord(styleMinHeight, aRenderingContext, aFrame, h) ||
-            GetPercentHeight(styleMinHeight, aRenderingContext, aFrame, h)) {
+        if (GetAbsoluteCoord(styleMinHeight, h) ||
+            GetPercentHeight(styleMinHeight, aFrame, h)) {
           h = NSToCoordRound(h * (float(ratio.width) / float(ratio.height)));
           if (h > result)
             result = h;
         }
       }
     }
   }
       
@@ -1750,41 +1755,41 @@ nsLayoutUtils::IntrinsicForContainer(nsI
   coordOutsideWidth += offsets.hMargin;
   pctOutsideWidth += offsets.hPctMargin;
 
   min += coordOutsideWidth;
   result = NSCoordSaturatingAdd(result, coordOutsideWidth);
   pctTotal += pctOutsideWidth;
 
   nscoord w;
-  if (GetAbsoluteCoord(styleWidth, aRenderingContext, aFrame, w) ||
+  if (GetAbsoluteCoord(styleWidth, w) ||
       GetIntrinsicCoord(styleWidth, aRenderingContext, aFrame,
                         PROP_WIDTH, w)) {
     result = AddPercents(aType, w + coordOutsideWidth, pctOutsideWidth);
   }
   else if (aType == MIN_WIDTH && eStyleUnit_Percent == styleWidth.GetUnit() &&
            aFrame->IsFrameOfType(nsIFrame::eReplaced)) {
     // A percentage width on replaced elements means they can shrink to 0.
     result = 0; // let |min| handle padding/border/margin
   }
   else {
     result = AddPercents(aType, result, pctTotal);
   }
 
   nscoord maxw;
-  if (GetAbsoluteCoord(styleMaxWidth, aRenderingContext, aFrame, maxw) ||
+  if (GetAbsoluteCoord(styleMaxWidth, maxw) ||
       GetIntrinsicCoord(styleMaxWidth, aRenderingContext, aFrame,
                         PROP_MAX_WIDTH, maxw)) {
     maxw = AddPercents(aType, maxw + coordOutsideWidth, pctOutsideWidth);
     if (result > maxw)
       result = maxw;
   }
 
   nscoord minw;
-  if (GetAbsoluteCoord(styleMinWidth, aRenderingContext, aFrame, minw) ||
+  if (GetAbsoluteCoord(styleMinWidth, minw) ||
       GetIntrinsicCoord(styleMinWidth, aRenderingContext, aFrame,
                         PROP_MIN_WIDTH, minw)) {
     minw = AddPercents(aType, minw + coordOutsideWidth, pctOutsideWidth);
     if (result < minw)
       result = minw;
   }
 
   min = AddPercents(aType, min, pctTotal);
@@ -1817,29 +1822,25 @@ nsLayoutUtils::IntrinsicForContainer(nsI
          aType == MIN_WIDTH ? "min" : "pref", result);
 #endif
 
   return result;
 }
 
 /* static */ nscoord
 nsLayoutUtils::ComputeWidthDependentValue(
-                 nsIRenderingContext* aRenderingContext,
-                 nsIFrame*            aFrame,
                  nscoord              aContainingBlockWidth,
                  const nsStyleCoord&  aCoord)
 {
-  NS_PRECONDITION(aFrame, "non-null frame expected");
-  NS_PRECONDITION(aRenderingContext, "non-null rendering context expected");
   NS_PRECONDITION(aContainingBlockWidth != NS_UNCONSTRAINEDSIZE,
                   "unconstrained widths no longer supported");
 
   nscoord result;
-  if (GetAbsoluteCoord(aCoord, aRenderingContext, aFrame, result)) {
-    return result;
+  if (eStyleUnit_Coord == aCoord.GetUnit()) {
+    return aCoord.GetCoordValue();
   }
   if (eStyleUnit_Percent == aCoord.GetUnit()) {
     return NSToCoordFloor(aContainingBlockWidth * aCoord.GetPercentValue());
   }
   NS_ASSERTION(aCoord.GetUnit() == eStyleUnit_None ||
                aCoord.GetUnit() == eStyleUnit_Auto,
                "unexpected width value");
   return 0;
@@ -1857,17 +1858,18 @@ nsLayoutUtils::ComputeWidthValue(
   NS_PRECONDITION(aFrame, "non-null frame expected");
   NS_PRECONDITION(aRenderingContext, "non-null rendering context expected");
   NS_PRECONDITION(aContainingBlockWidth != NS_UNCONSTRAINEDSIZE,
                   "unconstrained widths no longer supported");
   NS_PRECONDITION(aContainingBlockWidth >= 0,
                   "width less than zero");
 
   nscoord result;
-  if (GetAbsoluteCoord(aCoord, aRenderingContext, aFrame, result)) {
+  if (eStyleUnit_Coord == aCoord.GetUnit()) {
+    result = aCoord.GetCoordValue();
     NS_ASSERTION(result >= 0, "width less than zero");
     result -= aContentEdgeToBoxSizing;
   } else if (eStyleUnit_Percent == aCoord.GetUnit()) {
     NS_ASSERTION(aCoord.GetPercentValue() >= 0.0f, "width less than zero");
     result = NSToCoordFloor(aContainingBlockWidth * aCoord.GetPercentValue()) -
              aContentEdgeToBoxSizing;
   } else if (eStyleUnit_Enumerated == aCoord.GetUnit()) {
     PRInt32 val = aCoord.GetIntValue();
@@ -1901,27 +1903,22 @@ nsLayoutUtils::ComputeWidthValue(
   if (result < 0)
     result = 0;
   return result;
 }
 
 
 /* static */ nscoord
 nsLayoutUtils::ComputeHeightDependentValue(
-                 nsIRenderingContext* aRenderingContext,
-                 nsIFrame*            aFrame,
                  nscoord              aContainingBlockHeight,
                  const nsStyleCoord&  aCoord)
 {
-  NS_PRECONDITION(aFrame, "non-null frame expected");
-  NS_PRECONDITION(aRenderingContext, "non-null rendering context expected");
-
   nscoord result;
-  if (GetAbsoluteCoord(aCoord, aRenderingContext, aFrame, result)) {
-    return result;
+  if (eStyleUnit_Coord == aCoord.GetUnit()) {
+    return aCoord.GetCoordValue();
   }
   if (eStyleUnit_Percent == aCoord.GetUnit()) {
     // XXXldb Some callers explicitly check aContainingBlockHeight
     // against NS_AUTOHEIGHT *and* unit against eStyleUnit_Percent
     // before calling this function, so this assertion probably needs to
     // be inside the percentage case.  However, it would be much more
     // likely to catch problems if it were at the start of the function.
     // XXXldb Many callers pass a non-'auto' containing block height when
@@ -2000,37 +1997,37 @@ nsLayoutUtils::ComputeSizeWithIntrinsicD
   }
 
   minWidth = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
                aFrame, aCBSize.width, boxSizingAdjust.width,
                boxSizingToMarginEdgeWidth, stylePos->mMinWidth);
   NS_ASSERTION(minWidth >= 0, "negative result from ComputeWidthValue");
 
   if (!isAutoHeight) {
-    height = nsLayoutUtils::ComputeHeightDependentValue(aRenderingContext,
-               aFrame, aCBSize.height, stylePos->mHeight) -
-             boxSizingAdjust.height;
+    height = nsLayoutUtils::
+      ComputeHeightDependentValue(aCBSize.height, stylePos->mHeight) -
+      boxSizingAdjust.height;
     if (height < 0)
       height = 0;
   }
 
   if (!IsAutoHeight(stylePos->mMaxHeight, aCBSize.height)) {
-    maxHeight = nsLayoutUtils::ComputeHeightDependentValue(aRenderingContext,
-                  aFrame, aCBSize.height, stylePos->mMaxHeight) -
-                boxSizingAdjust.height;
+    maxHeight = nsLayoutUtils::
+      ComputeHeightDependentValue(aCBSize.height, stylePos->mMaxHeight) -
+      boxSizingAdjust.height;
     if (maxHeight < 0)
       maxHeight = 0;
   } else {
     maxHeight = nscoord_MAX;
   }
 
   if (!IsAutoHeight(stylePos->mMinHeight, aCBSize.height)) {
-    minHeight = nsLayoutUtils::ComputeHeightDependentValue(aRenderingContext,
-                  aFrame, aCBSize.height, stylePos->mMinHeight) -
-                boxSizingAdjust.height;
+    minHeight = nsLayoutUtils::
+      ComputeHeightDependentValue(aCBSize.height, stylePos->mMinHeight) -
+      boxSizingAdjust.height;
     if (minHeight < 0)
       minHeight = 0;
   } else {
     minHeight = 0;
   }
 
   // Resolve percentage intrinsic width/height as necessary:
 
@@ -2050,19 +2047,18 @@ nsLayoutUtils::ComputeSizeWithIntrinsicD
     hasIntrinsicWidth = PR_FALSE;
     intrinsicWidth = 0;
   }
 
   if (aIntrinsicSize.height.GetUnit() == eStyleUnit_Coord ||
       (aIntrinsicSize.height.GetUnit() == eStyleUnit_Percent &&
        aCBSize.height != NS_AUTOHEIGHT)) {
     hasIntrinsicHeight = PR_TRUE;
-    intrinsicHeight = nsLayoutUtils::ComputeHeightDependentValue(
-                              aRenderingContext, aFrame, aCBSize.height,
-                              aIntrinsicSize.height);
+    intrinsicHeight = nsLayoutUtils::
+      ComputeHeightDependentValue(aCBSize.height, aIntrinsicSize.height);
     if (intrinsicHeight < 0)
       intrinsicHeight = 0;
   } else {
     hasIntrinsicHeight = PR_FALSE;
     intrinsicHeight = 0;
   }
 
   NS_ASSERTION(aIntrinsicRatio.width >= 0 && aIntrinsicRatio.height >= 0,
diff --git a/layout/base/nsLayoutUtils.h b/layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h
+++ b/layout/base/nsLayoutUtils.h
@@ -578,67 +578,31 @@ public:
    * the root content.
    * @param aFrame the checking frame
    * @return if TRUE, the frame is a part of the scrollbar or scrollcorner of
    *         the root content.
    */
   static PRBool IsViewportScrollbarFrame(nsIFrame* aFrame);
 
   /**
-   * Return the value of aStyle as an nscoord if it can be determined without
-   * reference to ancestors or children (e.g. is not a percentage width)
-   * @param aStyle the style coord
-   * @param aRenderingContext the rendering context to use for font measurement
-   * @param aFrame the frame whose style context should be used for font information
-   * @param aResult the nscoord value of the style coord
-   * @return TRUE if the unit is eStyleUnit_Coord
-   */
-  static PRBool GetAbsoluteCoord(const nsStyleCoord& aStyle,
-                                 nsIRenderingContext* aRenderingContext,
-                                 nsIFrame* aFrame,
-                                 nscoord& aResult)
-  {
-    return GetAbsoluteCoord(aStyle, aRenderingContext,
-                            aFrame->GetStyleContext(), aResult);
-  }
-
-  /**
-   * Same as above but doesn't need a frame
-   */
-  static PRBool GetAbsoluteCoord(const nsStyleCoord& aStyle,
-                                 nsIRenderingContext* aRenderingContext,
-                                 nsStyleContext* aStyleContext,
-                                 nscoord& aResult)
-  {
-    nsStyleUnit unit = aStyle.GetUnit();
-    if (eStyleUnit_Coord == unit) {
-      aResult = aStyle.GetCoordValue();
-      return PR_TRUE;
-    }
-    return PR_FALSE;
-  }
-
-  /**
    * Get the contribution of aFrame to its containing block's intrinsic
    * width.  This considers the child's intrinsic width, its 'width',
    * 'min-width', and 'max-width' properties, and its padding, border,
    * and margin.
    */
   enum IntrinsicWidthType { MIN_WIDTH, PREF_WIDTH };
   static nscoord IntrinsicForContainer(nsIRenderingContext* aRenderingContext,
                                        nsIFrame* aFrame,
                                        IntrinsicWidthType aType);
 
   /*
    * Convert nsStyleCoord to nscoord when percentages depend on the
    * containing block width.
    */
   static nscoord ComputeWidthDependentValue(
-                   nsIRenderingContext* aRenderingContext,
-                   nsIFrame*            aFrame,
                    nscoord              aContainingBlockWidth,
                    const nsStyleCoord&  aCoord);
 
   /*
    * Convert nsStyleCoord to nscoord when percentages depend on the
    * containing block width, and enumerated values are for width,
    * min-width, or max-width.  Returns the content-box width value based
    * on aContentEdgeToBoxSizing and aBoxSizingToMarginEdge (which are
@@ -662,18 +626,16 @@ public:
                    nscoord              aBoxSizingToMarginEdge,
                    const nsStyleCoord&  aCoord);
 
   /*
    * Convert nsStyleCoord to nscoord when percentages depend on the
    * containing block height.
    */
   static nscoord ComputeHeightDependentValue(
-                   nsIRenderingContext* aRenderingContext,
-                   nsIFrame*            aFrame,
                    nscoord              aContainingBlockHeight,
                    const nsStyleCoord&  aCoord);
 
   /*
    * Calculate the used values for 'width' and 'height' for a replaced element.
    *
    *   http://www.w3.org/TR/CSS21/visudet.html#min-max-widths
    */
diff --git a/layout/forms/nsTextControlFrame.cpp b/layout/forms/nsTextControlFrame.cpp
--- a/layout/forms/nsTextControlFrame.cpp
+++ b/layout/forms/nsTextControlFrame.cpp
@@ -1305,18 +1305,17 @@ nsTextControlFrame::CalcIntrinsicSize(ns
   nscoord charMaxAdvance  = 0;
 
   nsCOMPtr<nsIFontMetrics> fontMet;
   nsresult rv =
     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fontMet));
   NS_ENSURE_SUCCESS(rv, rv);
   aRenderingContext->SetFont(fontMet);
 
-  lineHeight = nsHTMLReflowState::CalcLineHeight(aRenderingContext,
-                                                 this);
+  lineHeight = nsHTMLReflowState::CalcLineHeight(this);
   fontMet->GetAveCharWidth(charWidth);
   fontMet->GetMaxAdvance(charMaxAdvance);
 
   // Set the width equal to the width in characters
   PRInt32 cols = GetCols();
   aIntrinsicSize.width = cols * charWidth;
 
   // To better match IE, take the maximum character width(in twips) and remove
diff --git a/layout/generic/nsBRFrame.cpp b/layout/generic/nsBRFrame.cpp
--- a/layout/generic/nsBRFrame.cpp
+++ b/layout/generic/nsBRFrame.cpp
@@ -145,18 +145,17 @@ BRFrame::Reflow(nsPresContext* aPresCont
       // here for cases where the line-height is less that 1.
       nsLayoutUtils::SetFontFromStyle(aReflowState.rendContext, mStyleContext);
       nsCOMPtr<nsIFontMetrics> fm;
       aReflowState.rendContext->GetFontMetrics(*getter_AddRefs(fm));
       if (fm) {
         nscoord ascent, descent;
         fm->GetMaxAscent(ascent);
         fm->GetMaxDescent(descent);
-        nscoord logicalHeight =
-          aReflowState.CalcLineHeight(aReflowState.rendContext, this);
+        nscoord logicalHeight = aReflowState.CalcLineHeight(this);
         nscoord leading = logicalHeight - ascent - descent;
         aMetrics.height = logicalHeight;
         aMetrics.ascent = ascent + (leading/2);
       }
       else {
         aMetrics.ascent = aMetrics.height = 0;
       }
 
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -134,18 +134,17 @@ nsBlockReflowState::nsBlockReflowState(c
   }
 
   mY = borderPadding.top;
   mBand.Init(mSpaceManager, mContentArea);
 
   mPrevChild = nsnull;
   mCurrentLine = aFrame->end_lines();
 
-  mMinLineHeight = nsHTMLReflowState::CalcLineHeight(aReflowState.rendContext,
-                                                     aReflowState.frame);
+  mMinLineHeight = nsHTMLReflowState::CalcLineHeight(aReflowState.frame);
 
   // Calculate mOutsideBulletX
   GetAvailableSpace();
   // FIXME (bug 25888): need to check the entire region that the first
   // line overlaps, not just the top pixel.
   mOutsideBulletX =
     mReflowState.mStyleVisibility->mDirection == NS_STYLE_DIRECTION_LTR ?
       mAvailSpaceRect.x :
diff --git a/layout/generic/nsColumnSetFrame.cpp b/layout/generic/nsColumnSetFrame.cpp
--- a/layout/generic/nsColumnSetFrame.cpp
+++ b/layout/generic/nsColumnSetFrame.cpp
@@ -224,25 +224,22 @@ GetAvailableContentHeight(const nsHTMLRe
   nscoord borderPaddingHeight =
     aReflowState.mComputedBorderPadding.top +
     aReflowState.mComputedBorderPadding.bottom;
   return PR_MAX(0, aReflowState.availableHeight - borderPaddingHeight);
 }
 
 static nscoord
 GetColumnGap(nsColumnSetFrame*    aFrame,
-             const nsStyleColumn* aColStyle,
-             nsIRenderingContext* aRenderingContext)
+             const nsStyleColumn* aColStyle)
 {
-  nscoord colGap;
   if (eStyleUnit_Normal == aColStyle->mColumnGap.GetUnit())
     return aFrame->GetStyleFont()->mFont.size;
-  else if (nsLayoutUtils::GetAbsoluteCoord(aColStyle->mColumnGap,
-                                           aRenderingContext,
-                                           aFrame, colGap)) {
+  if (eStyleUnit_Coord == aColStyle->mColumnGap.GetUnit()) {
+    nscoord colGap = aColStyle->mColumnGap.GetCoordValue();
     NS_ASSERTION(colGap >= 0, "negative column gap");
     return colGap;
   }
 
   NS_NOTREACHED("Unknown gap type");
   return 0;
 }
 
@@ -254,23 +251,22 @@ nsColumnSetFrame::ChooseColumnStrategy(c
   if (aReflowState.ComputedWidth() != NS_INTRINSICSIZE) {
     availContentWidth = aReflowState.ComputedWidth();
   }
   nscoord colHeight = GetAvailableContentHeight(aReflowState);
   if (aReflowState.ComputedHeight() != NS_INTRINSICSIZE) {
     colHeight = aReflowState.ComputedHeight();
   }
 
-  nscoord colGap = GetColumnGap(this, colStyle, aReflowState.rendContext);
+  nscoord colGap = GetColumnGap(this, colStyle);
   PRInt32 numColumns = colStyle->mColumnCount;
 
   nscoord colWidth;
-  if (nsLayoutUtils::GetAbsoluteCoord(colStyle->mColumnWidth,
-                                      aReflowState.rendContext,
-                                      this, colWidth)) {
+  if (colStyle->mColumnWidth.GetUnit() == eStyleUnit_Coord) {
+    colWidth = colStyle->mColumnWidth.GetCoordValue();
     NS_ASSERTION(colWidth >= 0, "negative column width");
     // Reduce column count if necessary to make columns fit in the
     // available width. Compute max number of columns that fit in
     // availContentWidth, satisfying colGap*(maxColumns - 1) +
     // colWidth*maxColumns <= availContentWidth
     if (availContentWidth != NS_INTRINSICSIZE && colGap + colWidth > 0
         && numColumns > 0) {
       // This expression uses truncated rounding, which is what we
@@ -366,54 +362,54 @@ nscoord
 nscoord
 nsColumnSetFrame::GetMinWidth(nsIRenderingContext *aRenderingContext) {
   nscoord width = 0;
   if (mFrames.FirstChild()) {
     width = mFrames.FirstChild()->GetMinWidth(aRenderingContext);
   }
   const nsStyleColumn* colStyle = GetStyleColumn();
   nscoord colWidth;
-  if (nsLayoutUtils::GetAbsoluteCoord(colStyle->mColumnWidth,
-                                      aRenderingContext, this, colWidth)) {
-    // As available width reduces to zero, we reduce our number of columns to one,
-    // and don't enforce the column width, so just return the min of the
-    // child's min-width with any specified column width.
+  if (colStyle->mColumnWidth.GetUnit() == eStyleUnit_Coord) {
+    colWidth = colStyle->mColumnWidth.GetCoordValue();
+    // As available width reduces to zero, we reduce our number of columns
+    // to one, and don't enforce the column width, so just return the min
+    // of the child's min-width with any specified column width.
     width = PR_MIN(width, colWidth);
   } else {
-    NS_ASSERTION(colStyle->mColumnCount > 0, "column-count and column-width can't both be auto");
-    // As available width reduces to zero, we still have mColumnCount columns, so
-    // multiply the child's min-width by the number of columns.
+    NS_ASSERTION(colStyle->mColumnCount > 0,
+                 "column-count and column-width can't both be auto");
+    // As available width reduces to zero, we still have mColumnCount columns,
+    // so multiply the child's min-width by the number of columns.
     colWidth = width;
     width *= colStyle->mColumnCount;
     // The multiplication above can make 'width' negative (integer overflow),
     // so use PR_MAX to protect against that.
     width = PR_MAX(width, colWidth);
   }
   // XXX count forced column breaks here? Maybe we should return the child's
   // min-width times the minimum number of columns.
   return width;
 }
 
 nscoord
 nsColumnSetFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext) {
-  // Our preferred width is our desired column width, if specified, otherwise the
-  // child's preferred width, times the number of columns, plus the width of any
-  // required column gaps
+  // Our preferred width is our desired column width, if specified, otherwise
+  // the child's preferred width, times the number of columns, plus the width
+  // of any required column gaps
   // XXX what about forced column breaks here?
   const nsStyleColumn* colStyle = GetStyleColumn();
-  nscoord colGap = GetColumnGap(this, colStyle, aRenderingContext);
+  nscoord colGap = GetColumnGap(this, colStyle);
 
   nscoord colWidth;
-  if (!nsLayoutUtils::GetAbsoluteCoord(colStyle->mColumnWidth,
-                                       aRenderingContext, this, colWidth)) {
-    if (mFrames.FirstChild()) {
-      colWidth = mFrames.FirstChild()->GetPrefWidth(aRenderingContext);
-    } else {
-      colWidth = 0;
-    }
+  if (colStyle->mColumnWidth.GetUnit() == eStyleUnit_Coord) {
+    colWidth = colStyle->mColumnWidth.GetCoordValue();
+  } else if (mFrames.FirstChild()) {
+    colWidth = mFrames.FirstChild()->GetPrefWidth(aRenderingContext);
+  } else {
+    colWidth = 0;
   }
 
   PRInt32 numColumns = colStyle->mColumnCount;
   if (numColumns <= 0) {
     // if column-count is auto, assume one column
     numColumns = 1;
   }
   
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -3081,35 +3081,35 @@ nsFrame::ComputeSize(nsIRenderingContext
       stylePos->mMinWidth);
   if (minWidth > result.width)
     result.width = minWidth;
 
   // Compute height
 
   if (!IsAutoHeight(stylePos->mHeight, aCBSize.height)) {
     result.height =
-      nsLayoutUtils::ComputeHeightDependentValue(aRenderingContext, this,
-        aCBSize.height, stylePos->mHeight) -
+      nsLayoutUtils::ComputeHeightDependentValue(aCBSize.height,
+                                                 stylePos->mHeight) -
       boxSizingAdjust.height;
   }
 
   if (result.height != NS_UNCONSTRAINEDSIZE) {
     if (!IsAutoHeight(stylePos->mMaxHeight, aCBSize.height)) {
       nscoord maxHeight =
-        nsLayoutUtils::ComputeHeightDependentValue(aRenderingContext, this,
-          aCBSize.height, stylePos->mMaxHeight) -
+        nsLayoutUtils::ComputeHeightDependentValue(aCBSize.height,
+                                                   stylePos->mMaxHeight) -
         boxSizingAdjust.height;
       if (maxHeight < result.height)
         result.height = maxHeight;
     }
 
     if (!IsAutoHeight(stylePos->mMinHeight, aCBSize.height)) {
       nscoord minHeight =
-        nsLayoutUtils::ComputeHeightDependentValue(aRenderingContext, this,
-          aCBSize.height, stylePos->mMinHeight) -
+        nsLayoutUtils::ComputeHeightDependentValue(aCBSize.height,
+                                                   stylePos->mMinHeight) -
         boxSizingAdjust.height;
       if (minHeight > result.height)
         result.height = minHeight;
     }
   }
 
   const nsStyleDisplay *disp = GetStyleDisplay();
   if (IsThemed(disp)) {
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -173,26 +173,16 @@ nsHTMLReflowState::nsHTMLReflowState(nsP
                            ? aParentReflowState.mPercentHeightObserver : nsnull;
   mPercentHeightReflowInitiator = aParentReflowState.mPercentHeightReflowInitiator;
 
   if (aInit) {
     Init(aPresContext, aContainingBlockWidth, aContainingBlockHeight);
   }
 }
 
-inline void
-nsCSSOffsetState::ComputeWidthDependentValue(nscoord aContainingBlockWidth,
-                                             const nsStyleCoord& aCoord,
-                                             nscoord& aResult)
-{
-  aResult = nsLayoutUtils::ComputeWidthDependentValue(rendContext, frame,
-                                                      aContainingBlockWidth,
-                                                      aCoord);
-}
-
 inline nscoord
 nsCSSOffsetState::ComputeWidthValue(nscoord aContainingBlockWidth,
                                     nscoord aContentEdgeToBoxSizing,
                                     nscoord aBoxSizingToMarginEdge,
                                     const nsStyleCoord& aCoord)
 {
   return nsLayoutUtils::ComputeWidthValue(rendContext, frame,
                                           aContainingBlockWidth,
@@ -215,26 +205,16 @@ nsCSSOffsetState::ComputeWidthValue(nsco
     case NS_STYLE_BOX_SIZING_PADDING:
       inside = mComputedPadding.LeftRight();
       break;
   }
   outside -= inside;
 
   return ComputeWidthValue(aContainingBlockWidth, inside,
                            outside, aCoord);
-}
-
-inline void
-nsCSSOffsetState::ComputeHeightDependentValue(nscoord aContainingBlockHeight,
-                                              const nsStyleCoord& aCoord,
-                                              nscoord& aResult)
-{
-  aResult = nsLayoutUtils::ComputeHeightDependentValue(rendContext, frame,
-                                                       aContainingBlockHeight,
-                                                       aCoord);
 }
 
 void
 nsHTMLReflowState::SetComputedWidth(nscoord aComputedWidth)
 {
   NS_ASSERTION(frame, "Must have a frame!");
   // It'd be nice to assert that |frame| is not in reflow, but this fails for
   // two reasons:
@@ -630,31 +610,31 @@ nsHTMLReflowState::ComputeRelativeOffset
   }
 
   if (leftIsAuto) {
     if (rightIsAuto) {
       // If both are 'auto' (their initial values), the computed values are 0
       mComputedOffsets.left = mComputedOffsets.right = 0;
     } else {
       // 'Right' isn't 'auto' so compute its value
-      ComputeWidthDependentValue(aContainingBlockWidth,
-                                 mStylePosition->mOffset.GetRight(),
-                                 mComputedOffsets.right);
-      
+      mComputedOffsets.right = nsLayoutUtils::
+        ComputeWidthDependentValue(aContainingBlockWidth,
+                                   mStylePosition->mOffset.GetRight());
+
       // Computed value for 'left' is minus the value of 'right'
       mComputedOffsets.left = -mComputedOffsets.right;
     }
 
   } else {
     NS_ASSERTION(rightIsAuto, "unexpected specified constraint");
     
     // 'Left' isn't 'auto' so compute its value
-    ComputeWidthDependentValue(aContainingBlockWidth,
-                               mStylePosition->mOffset.GetLeft(),
-                               mComputedOffsets.left);
+    mComputedOffsets.left = nsLayoutUtils::
+      ComputeWidthDependentValue(aContainingBlockWidth,
+                                 mStylePosition->mOffset.GetLeft());
 
     // Computed value for 'right' is minus the value of 'left'
     mComputedOffsets.right = -mComputedOffsets.left;
   }
 
   // Compute the 'top' and 'bottom' values. The 'top' and 'bottom' properties
   // move relatively positioned elements up and down. They also must be each 
   // other's negative
@@ -678,31 +658,31 @@ nsHTMLReflowState::ComputeRelativeOffset
   }
 
   if (topIsAuto) {
     if (bottomIsAuto) {
       // If both are 'auto' (their initial values), the computed values are 0
       mComputedOffsets.top = mComputedOffsets.bottom = 0;
     } else {
       // 'Bottom' isn't 'auto' so compute its value
-      ComputeHeightDependentValue(aContainingBlockHeight,
-                                  mStylePosition->mOffset.GetBottom(),
-                                  mComputedOffsets.bottom);
+      mComputedOffsets.bottom = nsLayoutUtils::
+        ComputeHeightDependentValue(aContainingBlockHeight,
+                                    mStylePosition->mOffset.GetBottom());
       
       // Computed value for 'top' is minus the value of 'bottom'
       mComputedOffsets.top = -mComputedOffsets.bottom;
     }
 
   } else {
     NS_ASSERTION(bottomIsAuto, "unexpected specified constraint");
     
     // 'Top' isn't 'auto' so compute its value
-    ComputeHeightDependentValue(aContainingBlockHeight,
-                                mStylePosition->mOffset.GetTop(),
-                                mComputedOffsets.top);
+    mComputedOffsets.top = nsLayoutUtils::
+      ComputeHeightDependentValue(aContainingBlockHeight,
+                                  mStylePosition->mOffset.GetTop());
 
     // Computed value for 'bottom' is minus the value of 'top'
     mComputedOffsets.bottom = -mComputedOffsets.top;
   }
 
   // Store the offset
   nsPropertyTable* propTable = aPresContext->PropertyTable();
   nsPoint* offsets = static_cast<nsPoint*>
@@ -812,42 +792,42 @@ nsHTMLReflowState::CalculateHorizBorderP
                        nscoord* aOutsideBoxSizing)
 {
   const nsMargin& border = mStyleBorder->GetActualBorder();
   nsMargin padding, margin;
 
   // See if the style system can provide us the padding directly
   if (!mStylePadding->GetPadding(padding)) {
     // We have to compute the left and right values
-    ComputeWidthDependentValue(aContainingBlockWidth,
-                               mStylePadding->mPadding.GetLeft(),
-                               padding.left);
-    ComputeWidthDependentValue(aContainingBlockWidth,
-                               mStylePadding->mPadding.GetRight(),
-                               padding.right);
+    padding.left = nsLayoutUtils::
+      ComputeWidthDependentValue(aContainingBlockWidth,
+                                 mStylePadding->mPadding.GetLeft());
+    padding.right = nsLayoutUtils::
+      ComputeWidthDependentValue(aContainingBlockWidth,
+                                 mStylePadding->mPadding.GetRight());
   }
 
   // See if the style system can provide us the margin directly
   if (!mStyleMargin->GetMargin(margin)) {
     // We have to compute the left and right values
     if (eStyleUnit_Auto == mStyleMargin->mMargin.GetLeftUnit()) {
       // XXX FIXME (or does CalculateBlockSideMargins do this?)
       margin.left = 0;  // just ignore
     } else {
-      ComputeWidthDependentValue(aContainingBlockWidth,
-                                 mStyleMargin->mMargin.GetLeft(),
-                                 margin.left);
+      margin.left = nsLayoutUtils::
+        ComputeWidthDependentValue(aContainingBlockWidth,
+                                   mStyleMargin->mMargin.GetLeft());
     }
     if (eStyleUnit_Auto == mStyleMargin->mMargin.GetRightUnit()) {
       // XXX FIXME (or does CalculateBlockSideMargins do this?)
       margin.right = 0;  // just ignore
     } else {
-      ComputeWidthDependentValue(aContainingBlockWidth,
-                                 mStyleMargin->mMargin.GetRight(),
-                                 margin.right);
+      margin.right = nsLayoutUtils::
+        ComputeWidthDependentValue(aContainingBlockWidth,
+                                   mStyleMargin->mMargin.GetRight());
     }
   }
 
   nscoord outside =
     padding.LeftRight() + border.LeftRight() + margin.LeftRight();
   nscoord inside = 0;
   switch (mStylePosition->mBoxSizing) {
     case NS_STYLE_BOX_SIZING_BORDER:
@@ -1151,27 +1131,27 @@ nsHTMLReflowState::InitAbsoluteConstrain
 
   // Initialize the 'left' and 'right' computed offsets
   // XXX Handle new 'static-position' value...
   PRBool        leftIsAuto = PR_FALSE, rightIsAuto = PR_FALSE;
   if (eStyleUnit_Auto == mStylePosition->mOffset.GetLeftUnit()) {
     mComputedOffsets.left = 0;
     leftIsAuto = PR_TRUE;
   } else {
-    ComputeWidthDependentValue(containingBlockWidth,
-                               mStylePosition->mOffset.GetLeft(),
-                               mComputedOffsets.left);
+    mComputedOffsets.left = nsLayoutUtils::
+      ComputeWidthDependentValue(containingBlockWidth,
+                                 mStylePosition->mOffset.GetLeft());
   }
   if (eStyleUnit_Auto == mStylePosition->mOffset.GetRightUnit()) {
     mComputedOffsets.right = 0;
     rightIsAuto = PR_TRUE;
   } else {
-    ComputeWidthDependentValue(containingBlockWidth,
-                               mStylePosition->mOffset.GetRight(),
-                               mComputedOffsets.right);
+    mComputedOffsets.right = nsLayoutUtils::
+      ComputeWidthDependentValue(containingBlockWidth,
+                                 mStylePosition->mOffset.GetRight());
   }
 
   // Use the horizontal component of the hypothetical box in the cases
   // where it's needed.
   if (leftIsAuto && rightIsAuto) {
     // Use the direction of the original ("static-position") containing block
     // to dictate whether 'left' or 'right' is treated like 'static-position'.
     if (NS_STYLE_DIRECTION_LTR == cbFrame->GetStyleVisibility()->mDirection) {
@@ -1188,27 +1168,27 @@ nsHTMLReflowState::InitAbsoluteConstrain
   }
 
   // Initialize the 'top' and 'bottom' computed offsets
   PRBool      topIsAuto = PR_FALSE, bottomIsAuto = PR_FALSE;
   if (eStyleUnit_Auto == mStylePosition->mOffset.GetTopUnit()) {
     mComputedOffsets.top = 0;
     topIsAuto = PR_TRUE;
   } else {
-    ComputeHeightDependentValue(containingBlockHeight,
-                                mStylePosition->mOffset.GetTop(),
-                                mComputedOffsets.top);
+    mComputedOffsets.top = nsLayoutUtils::
+      ComputeHeightDependentValue(containingBlockHeight,
+                                  mStylePosition->mOffset.GetTop());
   }
   if (eStyleUnit_Auto == mStylePosition->mOffset.GetBottomUnit()) {
     mComputedOffsets.bottom = 0;        
     bottomIsAuto = PR_TRUE;
   } else {
-    ComputeHeightDependentValue(containingBlockHeight,
-                                mStylePosition->mOffset.GetBottom(),
-                                mComputedOffsets.bottom);
+    mComputedOffsets.bottom = nsLayoutUtils::
+      ComputeHeightDependentValue(containingBlockHeight,
+                                  mStylePosition->mOffset.GetBottom());
   }
 
   if (topIsAuto && bottomIsAuto) {
     // Treat 'top' like 'static-position'
     mComputedOffsets.top = hypotheticalBox.mTop;
     topIsAuto = PR_FALSE;
   }
 
@@ -1797,19 +1777,19 @@ nsHTMLReflowState::InitConstraints(nsPre
         // 'height' property doesn't apply to table columns and column groups
         heightUnit = eStyleUnit_Auto;
       }
       if (eStyleUnit_Auto == heightUnit) {
         mComputedHeight = NS_AUTOHEIGHT;
       } else {
         NS_ASSERTION(heightUnit == mStylePosition->mHeight.GetUnit(),
                      "unexpected height unit change");
-        ComputeHeightDependentValue(aContainingBlockHeight,
-                                    mStylePosition->mHeight,
-                                    mComputedHeight);
+        mComputedHeight = nsLayoutUtils::
+          ComputeHeightDependentValue(aContainingBlockHeight,
+                                      mStylePosition->mHeight);
       }
 
       // Doesn't apply to table elements
       mComputedMinWidth = mComputedMinHeight = 0;
       mComputedMaxWidth = mComputedMaxHeight = NS_UNCONSTRAINEDSIZE;
 
     } else if (NS_FRAME_GET_TYPE(mFrameType) == NS_CSS_FRAME_TYPE_ABSOLUTE) {
       // XXX not sure if this belongs here or somewhere else - cwk
@@ -2045,53 +2025,45 @@ GetNormalLineHeight(nsIFontMetrics* aFon
     break;
   default:
     //case eNoExternalLeading:
     normalLineHeight = emHeight + internalLeading;
   }
   return normalLineHeight;
 }
 
-// Need only one of aRenderingContext and aDeviceContext
 static nscoord
-ComputeLineHeight(nsIRenderingContext* aRenderingContext,
-                  nsStyleContext* aStyleContext)
+ComputeLineHeight(nsStyleContext* aStyleContext)
 {
-  nscoord lineHeight;
+  const nsStyleCoord& lhCoord = aStyleContext->GetStyleText()->mLineHeight;
 
-  const nsStyleCoord& lhCoord = aStyleContext->GetStyleText()->mLineHeight;
+  if (lhCoord.GetUnit() == eStyleUnit_Coord)
+    return lhCoord.GetCoordValue();
+
+  if (lhCoord.GetUnit() == eStyleUnit_Factor)
+    // For factor units the computed value of the line-height property 
+    // is found by multiplying the factor by the font's computed size
+    // (adjusted for min-size prefs and text zoom).
+    return NSToCoordRound(lhCoord.GetFactorValue() *
+                          aStyleContext->GetStyleFont()->mFont.size);
+
   
-  if (!nsLayoutUtils::GetAbsoluteCoord(lhCoord, aRenderingContext,
-                                       aStyleContext, lineHeight)) {
-    const nsStyleFont* font = aStyleContext->GetStyleFont();
-    if (lhCoord.GetUnit() == eStyleUnit_Factor) {
-      // For factor units the computed value of the line-height property 
-      // is found by multiplying the factor by the font's computed size
-      // (adjusted for min-size prefs and text zoom).
-      float factor = lhCoord.GetFactorValue();
-      lineHeight = NSToCoordRound(factor * font->mFont.size);
-    } else {
-      NS_ASSERTION(eStyleUnit_Normal == lhCoord.GetUnit(), "bad unit");
-      nsCOMPtr<nsIFontMetrics> fm;
-      nsLayoutUtils::GetFontMetricsForStyleContext(aStyleContext,
-                                                   getter_AddRefs(fm));
-      lineHeight = GetNormalLineHeight(fm);
-    }
-  }
-  return lineHeight;
+  NS_ASSERTION(eStyleUnit_Normal == lhCoord.GetUnit(), "bad unit");
+  nsCOMPtr<nsIFontMetrics> fm;
+  nsLayoutUtils::GetFontMetricsForStyleContext(aStyleContext,
+                                               getter_AddRefs(fm));
+  return GetNormalLineHeight(fm);
 }
 
 nscoord
-nsHTMLReflowState::CalcLineHeight(nsIRenderingContext* aRenderingContext,
-                                  nsStyleContext* aStyleContext)
+nsHTMLReflowState::CalcLineHeight(nsStyleContext* aStyleContext)
 {
-  NS_PRECONDITION(aRenderingContext, "Must have a rendering context");
   NS_PRECONDITION(aStyleContext, "Must have a style context");
   
-  nscoord lineHeight = ComputeLineHeight(aRenderingContext, aStyleContext);
+  nscoord lineHeight = ComputeLineHeight(aStyleContext);
 
   NS_ASSERTION(lineHeight >= 0, "ComputeLineHeight screwed up");
 
   return lineHeight;
 }
 
 /* static */
 void
@@ -2117,34 +2089,34 @@ nsCSSOffsetState::ComputeMargin(nscoord 
       if (eStyleUnit_Coord == styleMargin->mMargin.GetLeftUnit()) {
         mComputedMargin.left = styleMargin->mMargin.GetLeft().GetCoordValue();
       }
       if (eStyleUnit_Coord == styleMargin->mMargin.GetRightUnit()) {
         mComputedMargin.right = styleMargin->mMargin.GetRight().GetCoordValue();
       }
 
     } else {
-      ComputeWidthDependentValue(aContainingBlockWidth,
-                                 styleMargin->mMargin.GetLeft(),
-                                 mComputedMargin.left);
-      ComputeWidthDependentValue(aContainingBlockWidth,
-                                 styleMargin->mMargin.GetRight(),
-                                 mComputedMargin.right);
+      mComputedMargin.left = nsLayoutUtils::
+        ComputeWidthDependentValue(aContainingBlockWidth,
+                                   styleMargin->mMargin.GetLeft());
+      mComputedMargin.right = nsLayoutUtils::
+        ComputeWidthDependentValue(aContainingBlockWidth,
+                                   styleMargin->mMargin.GetRight());
     }
 
     // According to the CSS2 spec, margin percentages are
     // calculated with respect to the *width* of the containing
     // block, even for margin-top and margin-bottom.
     // XXX This isn't true for page boxes, if we implement them.
-    ComputeWidthDependentValue(aContainingBlockWidth,
-                               styleMargin->mMargin.GetTop(),
-                               mComputedMargin.top);
-    ComputeWidthDependentValue(aContainingBlockWidth,
-                               styleMargin->mMargin.GetBottom(),
-                               mComputedMargin.bottom);
+    mComputedMargin.top = nsLayoutUtils::
+      ComputeWidthDependentValue(aContainingBlockWidth,
+                                 styleMargin->mMargin.GetTop());
+    mComputedMargin.bottom = nsLayoutUtils::
+      ComputeWidthDependentValue(aContainingBlockWidth,
+                                 styleMargin->mMargin.GetBottom());
 
     // XXX We need to include 'auto' horizontal margins in this too!
     // ... but if we did that, we'd need to fix nsFrame::GetUsedMargin
     // to use it even when the margins are all zero (since sometimes
     // they get treated as auto)
     frame->SetProperty(nsGkAtoms::usedMarginProperty,
                        new nsMargin(mComputedMargin),
                        DestroyMarginFunc);
@@ -2153,31 +2125,31 @@ nsCSSOffsetState::ComputeMargin(nscoord 
 
 void
 nsCSSOffsetState::ComputePadding(nscoord aContainingBlockWidth)
 {
   // If style can provide us the padding directly, then use it.
   const nsStylePadding *stylePadding = frame->GetStylePadding();
   if (!stylePadding->GetPadding(mComputedPadding)) {
     // We have to compute the value
-    ComputeWidthDependentValue(aContainingBlockWidth,
-                               stylePadding->mPadding.GetLeft(),
-                               mComputedPadding.left);
-    ComputeWidthDependentValue(aContainingBlockWidth,
-                               stylePadding->mPadding.GetRight(),
-                               mComputedPadding.right);
+    mComputedPadding.left = nsLayoutUtils::
+      ComputeWidthDependentValue(aContainingBlockWidth,
+                                 stylePadding->mPadding.GetLeft());
+    mComputedPadding.right = nsLayoutUtils::
+      ComputeWidthDependentValue(aContainingBlockWidth,
+                                 stylePadding->mPadding.GetRight());
 
     // According to the CSS2 spec, percentages are calculated with respect to
     // containing block width for padding-top and padding-bottom
-    ComputeWidthDependentValue(aContainingBlockWidth,
-                               stylePadding->mPadding.GetTop(),
-                               mComputedPadding.top);
-    ComputeWidthDependentValue(aContainingBlockWidth,
-                               stylePadding->mPadding.GetBottom(),
-                               mComputedPadding.bottom);
+    mComputedPadding.top = nsLayoutUtils::
+      ComputeWidthDependentValue(aContainingBlockWidth,
+                                 stylePadding->mPadding.GetTop());
+    mComputedPadding.bottom = nsLayoutUtils::
+      ComputeWidthDependentValue(aContainingBlockWidth,
+                                 stylePadding->mPadding.GetBottom());
 
     frame->SetProperty(nsGkAtoms::usedPaddingProperty,
                        new nsMargin(mComputedPadding),
                        DestroyMarginFunc);
   }
   // a table row/col group, row/col doesn't have padding
   // XXXldb Neither do border-collapse tables.
   nsIAtom* frameType = frame->GetType();
@@ -2236,32 +2208,34 @@ nsHTMLReflowState::ComputeMinMaxValues(n
   }
 
   // Check for percentage based values and a containing block height that
   // depends on the content height. Treat them like 'auto'
   if ((NS_AUTOHEIGHT == aContainingBlockHeight) &&
       (eStyleUnit_Percent == mStylePosition->mMinHeight.GetUnit())) {
     mComputedMinHeight = 0;
   } else {
-    ComputeHeightDependentValue(aContainingBlockHeight,
-                                mStylePosition->mMinHeight, mComputedMinHeight);
+    mComputedMinHeight = nsLayoutUtils::
+      ComputeHeightDependentValue(aContainingBlockHeight,
+                                  mStylePosition->mMinHeight);
   }
   nsStyleUnit maxHeightUnit = mStylePosition->mMaxHeight.GetUnit();
   if (eStyleUnit_None == maxHeightUnit) {
     // Specified value of 'none'
     mComputedMaxHeight = NS_UNCONSTRAINEDSIZE;  // no limit
   } else {
     // Check for percentage based values and a containing block height that
     // depends on the content height. Treat them like 'auto'
     if ((NS_AUTOHEIGHT == aContainingBlockHeight) && 
         (eStyleUnit_Percent == maxHeightUnit)) {
       mComputedMaxHeight = NS_UNCONSTRAINEDSIZE;
     } else {
-      ComputeHeightDependentValue(aContainingBlockHeight,
-                                  mStylePosition->mMaxHeight, mComputedMaxHeight);
+      mComputedMaxHeight = nsLayoutUtils::
+        ComputeHeightDependentValue(aContainingBlockHeight,
+                                    mStylePosition->mMaxHeight);
     }
   }
 
   // If the computed value of 'min-height' is greater than the value of
   // 'max-height', 'max-height' is set to the value of 'min-height'
   if (mComputedMinHeight > mComputedMaxHeight) {
     mComputedMaxHeight = mComputedMinHeight;
   }
diff --git a/layout/generic/nsHTMLReflowState.h b/layout/generic/nsHTMLReflowState.h
--- a/layout/generic/nsHTMLReflowState.h
+++ b/layout/generic/nsHTMLReflowState.h
@@ -191,46 +191,28 @@ protected:
 protected:
 
   void InitOffsets(nscoord aContainingBlockWidth,
                    const nsMargin *aBorder = nsnull,
                    const nsMargin *aPadding = nsnull);
 
   /*
    * Convert nsStyleCoord to nscoord when percentages depend on the
-   * containing block width.
-   */
-  // XXX Make aResult a return value
-  inline void ComputeWidthDependentValue(nscoord aContainingBlockWidth,
-                                         const nsStyleCoord& aCoord,
-                                         nscoord& aResult);
-
-  /*
-   * Convert nsStyleCoord to nscoord when percentages depend on the
    * containing block width, and enumerated values are for width,
    * min-width, or max-width.  Does not handle auto widths.
    */
   inline nscoord ComputeWidthValue(nscoord aContainingBlockWidth,
                                    nscoord aContentEdgeToBoxSizing,
                                    nscoord aBoxSizingToMarginEdge,
                                    const nsStyleCoord& aCoord);
   // same as previous, but using mComputedBorderPadding, mComputedPadding,
   // and mComputedMargin
   nscoord ComputeWidthValue(nscoord aContainingBlockWidth,
                             PRUint8 aBoxSizing,
                             const nsStyleCoord& aCoord);
-
-  /*
-   * Convert nsStyleCoord to nscoord when percentages depend on the
-   * containing block height.
-   */
-  // XXX Make aResult a return value
-  inline void ComputeHeightDependentValue(nscoord aContainingBlockHeight,
-                                          const nsStyleCoord& aCoord,
-                                          nscoord& aResult);
 };
 
 /**
  * State passed to a frame during reflow or intrinsic size calculation.
  *
  * XXX Refactor so only a base class (nsSizingState?) is used for intrinsic
  * size calculation.
  *
@@ -417,27 +399,25 @@ public:
    * frames).
    */
   static nsIFrame* GetContainingBlockFor(const nsIFrame* aFrame);
 
   /**
    * Calculate the raw line-height property for the given frame. The return
    * value will be >= 0.
    */
-  static nscoord CalcLineHeight(nsIRenderingContext* aRenderingContext,
-                                nsIFrame* aFrame)
+  static nscoord CalcLineHeight(nsIFrame* aFrame)
   {
-    return CalcLineHeight(aRenderingContext, aFrame->GetStyleContext());
+    return CalcLineHeight(aFrame->GetStyleContext());
   }
   
   /**
    * Same as above, but doesn't need a frame.
    */
-  static nscoord CalcLineHeight(nsIRenderingContext* aRenderingContext,
-                                nsStyleContext* aStyleContext);
+  static nscoord CalcLineHeight(nsStyleContext* aStyleContext);
 
 
   void ComputeContainingBlockRectangle(nsPresContext*          aPresContext,
                                        const nsHTMLReflowState* aContainingBlockRS,
                                        nscoord&                 aContainingBlockWidth,
                                        nscoord&                 aContainingBlockHeight);
 
   /**
diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -1661,17 +1661,17 @@ nsLineLayout::VerticalAlignFrames(PerSpa
            mTopEdge, mMinLineHeight,
            zeroEffectiveSpanBox ? "yes" : "no");
 #endif
   }
   else {
     // Compute the logical height for this span. The logical height
     // is based on the line-height value, not the font-size. Also
     // compute the top leading.
-    nscoord logicalHeight = nsHTMLReflowState::CalcLineHeight(rc, spanFrame);
+    nscoord logicalHeight = nsHTMLReflowState::CalcLineHeight(spanFrame);
     nscoord contentHeight = spanFramePFD->mBounds.height -
       spanFramePFD->mBorderPadding.top - spanFramePFD->mBorderPadding.bottom;
 
     // Special-case for a ::first-letter frame, set the line height to
     // the frame height if the user has left line-height == normal 
     if (spanFramePFD->GetFlag(PFD_ISLETTERFRAME) && !spanPrevInFlow &&
         spanFrame->GetStyleText()->mLineHeight.GetUnit() == eStyleUnit_Normal) {
       logicalHeight = spanFramePFD->mBounds.height;
@@ -1907,17 +1907,17 @@ nsLineLayout::VerticalAlignFrames(PerSpa
         revisedBaselineY = baselineY - coordOffset;
         pfd->mBounds.y = revisedBaselineY - pfd->mAscent;
         pfd->mVerticalAlign = VALIGN_OTHER;
         break;
 
       case eStyleUnit_Percent:
         // Similar to a length value (eStyleUnit_Coord) except that the
         // percentage is a function of the elements line-height value.
-        elementLineHeight = nsHTMLReflowState::CalcLineHeight(rc, frame);
+        elementLineHeight = nsHTMLReflowState::CalcLineHeight(frame);
         percentOffset = nscoord(
           textStyle->mVerticalAlign.GetPercentValue() * elementLineHeight
           );
         revisedBaselineY = baselineY - percentOffset;
         pfd->mBounds.y = revisedBaselineY - pfd->mAscent;
         pfd->mVerticalAlign = VALIGN_OTHER;
         break;
     }
diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -2950,29 +2950,17 @@ nsComputedDOMStyle::GetPaddingWidthFor(P
   }
 
   return CallQueryInterface(val, aValue);
 }
 
 PRBool
 nsComputedDOMStyle::GetLineHeightCoord(nscoord& aCoord)
 {
-  // Get a rendering context
-  nsCOMPtr<nsIRenderingContext> cx;
-  nsIFrame* frame = mPresShell->FrameManager()->GetRootFrame();
-  if (frame) {
-    mPresShell->CreateRenderingContext(frame, getter_AddRefs(cx));
-  }
-  if (!cx) {
-    // Give up
-    aCoord = 0;
-    return PR_FALSE;
-  }
-  
-  aCoord = nsHTMLReflowState::CalcLineHeight(cx, mStyleContextHolder);
+  aCoord = nsHTMLReflowState::CalcLineHeight(mStyleContextHolder);
   
   // CalcLineHeight uses font->mFont.size, but we want to use
   // font->mSize as the font size.  Adjust for that.  Also adjust for
   // the text zoom, if any.
   const nsStyleFont* font = GetStyleFont();
   aCoord = NSToCoordRound((float(aCoord) *
                            (float(font->mSize) / float(font->mFont.size))) /
                           mPresShell->GetPresContext()->TextZoom());
diff --git a/layout/xul/base/src/nsBox.cpp b/layout/xul/base/src/nsBox.cpp
--- a/layout/xul/base/src/nsBox.cpp
+++ b/layout/xul/base/src/nsBox.cpp
@@ -659,30 +659,30 @@ nsIFrame::Redraw(nsBoxLayoutState& aStat
   Invalidate(damageRect, aImmediate);
 
   return NS_OK;
 }
 
 PRBool 
 nsIBox::AddCSSPrefSize(nsBoxLayoutState& aState, nsIBox* aBox, nsSize& aSize)
 {
-    PRBool heightSet = PR_FALSE;
+    PRBool widthSet = PR_FALSE, heightSet = PR_FALSE;
 
     // add in the css min, max, pref
     const nsStylePosition* position = aBox->GetStylePosition();
 
     // see if the width or height was specifically set
-    PRBool widthSet = 
-      nsLayoutUtils::GetAbsoluteCoord(position->mWidth,
-                                      aState.GetRenderingContext(),
-                                      aBox, aSize.width);
     // XXX Handle eStyleUnit_Enumerated?
     // (Handling the eStyleUnit_Enumerated types requires
     // GetPrefSize/GetMinSize methods that don't consider
-    // (min-/max-/)(width/height) properties.
+    // (min-/max-/)(width/height) properties.)
+    if (position->mWidth.GetUnit() == eStyleUnit_Coord) {
+        aSize.width = position->mWidth.GetCoordValue();
+        widthSet = PR_TRUE;
+    }
 
     if (position->mHeight.GetUnit() == eStyleUnit_Coord) {
         aSize.height = position->mHeight.GetCoordValue();     
         heightSet = PR_TRUE;
     }
     
     nsIContent* content = aBox->GetContent();
     // ignore 'height' and 'width' attributes if the actual element is not XUL
@@ -745,20 +745,18 @@ nsIBox::AddCSSMinSize(nsBoxLayoutState& 
       }
     }
 
     // add in the css min, max, pref
     const nsStylePosition* position = aBox->GetStylePosition();
 
     // same for min size. Unfortunately min size is always set to 0. So for now
     // we will assume 0 means not set.
-    nscoord min;
-    if (nsLayoutUtils::GetAbsoluteCoord(position->mMinWidth,
-                                        aState.GetRenderingContext(),
-                                        aBox, min)) {
+    if (position->mMinWidth.GetUnit() == eStyleUnit_Coord) {
+        nscoord min = position->mMinWidth.GetCoordValue();
         if (min && (!widthSet || (min > aSize.width && canOverride))) {
            aSize.width = min;
            widthSet = PR_TRUE;
         }
     } else if (position->mMinWidth.GetUnit() == eStyleUnit_Percent) {
         float min = position->mMinWidth.GetPercentValue();
         NS_ASSERTION(min == 0.0f, "Non-zero percentage values not currently supported");
         aSize.width = 0;
@@ -814,34 +812,34 @@ nsIBox::AddCSSMinSize(nsBoxLayoutState& 
     }
 
     return (widthSet && heightSet);
 }
 
 PRBool 
 nsIBox::AddCSSMaxSize(nsBoxLayoutState& aState, nsIBox* aBox, nsSize& aSize)
 {  
-    PRBool heightSet = PR_FALSE;
+    PRBool widthSet = PR_FALSE, heightSet = PR_FALSE;
 
     // add in the css min, max, pref
     const nsStylePosition* position = aBox->GetStylePosition();
 
     // and max
-    PRBool widthSet = 
-      nsLayoutUtils::GetAbsoluteCoord(position->mMaxWidth,
-                                      aState.GetRenderingContext(),
-                                      aBox, aSize.width);
+    // see if the width or height was specifically set
     // XXX Handle eStyleUnit_Enumerated?
     // (Handling the eStyleUnit_Enumerated types requires
     // GetPrefSize/GetMinSize methods that don't consider
-    // (min-/max-/)(width/height) properties.
+    // (min-/max-/)(width/height) properties.)
+    if (position->mMaxWidth.GetUnit() == eStyleUnit_Coord) {
+        aSize.width = position->mMaxWidth.GetCoordValue();
+        widthSet = PR_TRUE;
+    }
 
     if (position->mMaxHeight.GetUnit() == eStyleUnit_Coord) {
-        nscoord max = position->mMaxHeight.GetCoordValue();
-        aSize.height = max;
+        aSize.height = position->mMaxHeight.GetCoordValue();
         heightSet = PR_TRUE;
     }
 
     nsIContent* content = aBox->GetContent();
     if (content) {
         nsAutoString value;
         PRInt32 error;
 
