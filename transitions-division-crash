From: L. David Baron <dbaron@dbaron.org>

Fix division-by-zero crash that dholbert saw, although I haven't been able to.

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -213,22 +213,33 @@ ElementTransitionsStyleRule::MapRuleInfo
   NS_ENSURE_TRUE(et, NS_OK); // FIXME (Bug 522597): Why can this be null?
   for (PRUint32 i = 0, i_end = et->mPropertyTransitions.Length();
        i < i_end; ++i)
   {
     ElementPropertyTransition &pt = et->mPropertyTransitions[i];
     if (aRuleData->mSIDs & nsCachedStyleData::GetBitForSID(
                              nsCSSProps::kSIDTable[pt.mProperty]))
     {
-      double timePortion =
-        (RefreshTime() - pt.mStartTime).ToSeconds() / pt.mDuration.ToSeconds();
-      if (timePortion < 0.0)
-        timePortion = 0.0; // use start value during transition-delay
-      if (timePortion > 1.0)
-        timePortion = 1.0; // we might be behind on flushing
+      double duration = pt.mDuration.ToSeconds();
+      NS_ABORT_IF_FALSE(duration >= 0.0, "negative duration forbidden");
+      double timePortion;
+      if (duration == 0.0) {
+        if (RefreshTime() >= pt.mStartTime) {
+          timePortion = 0.0;
+        } else {
+          timePortion = 1.0;
+        }
+      } else {
+        timePortion = (RefreshTime() - pt.mStartTime).ToSeconds() /
+                      pt.mDuration.ToSeconds();
+        if (timePortion < 0.0)
+          timePortion = 0.0; // use start value during transition-delay
+        if (timePortion > 1.0)
+          timePortion = 1.0; // we might be behind on flushing
+      }
 
       double valuePortion =
         pt.mTimingFunction.GetSplineValue(timePortion);
       nsStyleCoord value;
 #ifdef DEBUG
       PRBool ok =
 #endif
         nsStyleAnimation::Interpolate(pt.mStartValue, pt.mEndValue,
@@ -594,16 +605,20 @@ nsTransitionManager::ConsiderStartingTra
   }
 
 
   nsRefreshDriver *rd = presContext->RefreshDriver();
 
   pt.mProperty = aProperty;
   float delay = aTransition.GetDelay();
   float duration = aTransition.GetDuration();
+  if (duration < 0.0) {
+    // The spec says a negative duration is treated as zero.
+    duration = 0.0;
+  }
   if (durationFraction != 1.0) {
     // Negative delays are essentially part of the transition
     // function, so reduce them along with the duration, but don't
     // reduce positive delays.  (See comment above about
     // durationFraction.)
     if (delay < 0.0f)
         delay *= durationFraction;
     duration *= durationFraction;
