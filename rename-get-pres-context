From: L. David Baron <dbaron@dbaron.org>

Bug 781360 patch 2:  Rename nsRuleNode::GetPresContext to PresContext, since it can never return null.  r=dholbert

diff --git a/layout/generic/nsFirstLetterFrame.cpp b/layout/generic/nsFirstLetterFrame.cpp
--- a/layout/generic/nsFirstLetterFrame.cpp
+++ b/layout/generic/nsFirstLetterFrame.cpp
@@ -61,17 +61,17 @@ nsFirstLetterFrame::Init(nsIContent*    
 {
   nsRefPtr<nsStyleContext> newSC;
   if (aPrevInFlow) {
     // Get proper style context for ourselves.  We're creating the frame
     // that represents everything *except* the first letter, so just create
     // a style context like we would for a text node.
     nsStyleContext* parentStyleContext = mStyleContext->GetParent();
     if (parentStyleContext) {
-      newSC = mStyleContext->RuleNode()->GetPresContext()->StyleSet()->
+      newSC = PresContext()->StyleSet()->
         ResolveStyleForNonElement(parentStyleContext);
       if (newSC)
         SetStyleContextWithoutNotification(newSC);
     }
   }
 
   return nsContainerFrame::Init(aContent, aParent, aPrevInFlow);
 }
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -561,17 +561,17 @@ public:
   typedef mozilla::layout::FrameChildListID ChildListID;
   typedef mozilla::layout::FrameChildListIDs ChildListIDs;
   typedef mozilla::layout::FrameChildListIterator ChildListIterator;
   typedef mozilla::layout::FrameChildListArrayIterator ChildListArrayIterator;
 
   NS_DECL_QUERYFRAME_TARGET(nsIFrame)
 
   nsPresContext* PresContext() const {
-    return StyleContext()->RuleNode()->GetPresContext();
+    return StyleContext()->RuleNode()->PresContext();
   }
 
   /**
    * Called to initialize the frame. This is called immediately after creating
    * the frame.
    *
    * If the frame is a continuing frame, then aPrevInFlow indicates the previous
    * frame (the frame that was split).
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -1303,22 +1303,26 @@ nsRuleNode::nsRuleNode(nsPresContext* aC
   : mPresContext(aContext),
     mParent(aParent),
     mRule(aRule),
     mDependentBits((uint32_t(aLevel) << NS_RULE_NODE_LEVEL_SHIFT) |
                    (aIsImportant ? NS_RULE_NODE_IS_IMPORTANT : 0)),
     mNoneBits(0),
     mRefCnt(0)
 {
+  MOZ_ASSERT(aContext);
   NS_ABORT_IF_FALSE(IsRoot() == !aRule,
                     "non-root rule nodes must have a rule");
 
   mChildren.asVoid = nullptr;
   MOZ_COUNT_CTOR(nsRuleNode);
-  NS_IF_ADDREF(mRule);
+
+  if (mRule) {
+    mRule->AddRef();
+  }
 
   NS_ASSERTION(IsRoot() || GetLevel() == aLevel, "not enough bits");
   NS_ASSERTION(IsRoot() || IsImportantRule() == aIsImportant, "yikes");
   /* If IsRoot(), then aContext->StyleSet() is typically null at this
      point.  In any case, we don't want to treat the root rulenode as
      unused.  */
   if (!IsRoot()) {
     mParent->AddRef();
@@ -1333,17 +1337,19 @@ nsRuleNode::nsRuleNode(nsPresContext* aC
                     "must be only one rule at animation level");
 }
 
 nsRuleNode::~nsRuleNode()
 {
   MOZ_COUNT_DTOR(nsRuleNode);
   if (mStyleData.mResetData || mStyleData.mInheritedData)
     mStyleData.Destroy(mDependentBits, mPresContext);
-  NS_IF_RELEASE(mRule);
+  if (mRule) {
+    mRule->Release();
+  }
 }
 
 nsRuleNode*
 nsRuleNode::Transition(nsIStyleRule* aRule, uint8_t aLevel,
                        bool aIsImportantRule)
 {
   nsRuleNode* next = nullptr;
   nsRuleNode::Key key(aRule, aLevel, aIsImportantRule);
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -255,24 +255,24 @@ public:
                     // "inherit" value.
     eRuleFullMixed, // All props have been specified.  At least one has
                     // a non-"inherit" value.
     eRuleFullInherited  // All props have been specified with "inherit"
                         // values.
   };
 
 private:
-  nsPresContext* mPresContext; // Our pres context.
+  nsPresContext* const mPresContext; // Our pres context.
 
-  nsRuleNode* mParent; // A pointer to the parent node in the tree.
-                       // This enables us to walk backwards from the
-                       // most specific rule matched to the least
-                       // specific rule (which is the optimal order to
-                       // use for lookups of style properties.
-  nsIStyleRule* mRule; // [STRONG] A pointer to our specific rule.
+  nsRuleNode* const mParent; // A pointer to the parent node in the tree.
+                             // This enables us to walk backwards from the
+                             // most specific rule matched to the least
+                             // specific rule (which is the optimal order to
+                             // use for lookups of style properties.
+  nsIStyleRule* const mRule; // [STRONG] A pointer to our specific rule.
 
   nsRuleNode* mNextSibling; // This value should be used only by the
                             // parent, since the parent may store
                             // children in a hash, which means this
                             // pointer is not meaningful.  Order of
                             // siblings is also not meaningful.
 
   struct Key {
@@ -661,20 +661,20 @@ public:
    * of some style context (as opposed to only being the ancestor of
    * some style context's mRuleNode)?
    */
   void SetUsedDirectly();
   bool IsUsedDirectly() const {
     return (mDependentBits & NS_RULE_NODE_USED_DIRECTLY) != 0;
   }
 
-  // NOTE:  Does not |AddRef|.
+  // NOTE:  Does not |AddRef|.  Null only for the root.
   nsIStyleRule* GetRule() const { return mRule; }
-  // NOTE: Does not |AddRef|.
-  nsPresContext* GetPresContext() const { return mPresContext; }
+  // NOTE: Does not |AddRef|.  Never null.
+  nsPresContext* PresContext() const { return mPresContext; }
 
   const void* GetStyleData(nsStyleStructID aSID,
                            nsStyleContext* aContext,
                            bool aComputeData);
 
   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)                      \
     const nsStyle##name_* GetStyle##name_(nsStyleContext* aContext,           \
                                           bool aComputeData);
diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -77,17 +77,17 @@ nsStyleContext::nsStyleContext(nsStyleCo
                "NS_STYLE_INHERIT_MASK must be bigger, and other bits shifted");
   #undef eStyleStruct_LastItem
 }
 
 nsStyleContext::~nsStyleContext()
 {
   NS_ASSERTION((nullptr == mChild) && (nullptr == mEmptyChild), "destructing context with children");
 
-  nsPresContext *presContext = mRuleNode->GetPresContext();
+  nsPresContext *presContext = mRuleNode->PresContext();
 
   mRuleNode->Release();
 
   presContext->PresShell()->StyleSet()->
     NotifyStyleContextDestroyed(presContext, this);
 
   if (mParent) {
     mParent->RemoveChild(this);
@@ -276,17 +276,17 @@ nsStyleContext::SetStyle(nsStyleStructID
 
   // NOTE:  nsCachedStyleData::GetStyleData works roughly the same way.
   // See the comments there (in nsRuleNode.h) for more details about
   // what this is doing and why.
 
   void** dataSlot;
   if (nsCachedStyleData::IsReset(aSID)) {
     if (!mCachedResetData) {
-      mCachedResetData = new (mRuleNode->GetPresContext()) nsResetStyleData;
+      mCachedResetData = new (mRuleNode->PresContext()) nsResetStyleData;
     }
     dataSlot = &mCachedResetData->mStyleStructs[aSID];
   } else {
     dataSlot = &mCachedInheritedData.mStyleStructs[aSID];
   }
   NS_ASSERTION(!*dataSlot || (mBits & nsCachedStyleData::GetBitForSID(aSID)),
                "Going to leak style data");
   *dataSlot = aStruct;
@@ -697,34 +697,34 @@ nsStyleContext::operator new(size_t sz, 
 }
 
 // Overridden to prevent the global delete from being called, since the memory
 // came out of an nsIArena instead of the global delete operator's heap.
 void 
 nsStyleContext::Destroy()
 {
   // Get the pres context from our rule node.
-  nsRefPtr<nsPresContext> presContext = mRuleNode->GetPresContext();
+  nsRefPtr<nsPresContext> presContext = mRuleNode->PresContext();
 
   // Call our destructor.
   this->~nsStyleContext();
 
   // Don't let the memory be freed, since it will be recycled
   // instead. Don't call the global operator delete.
   presContext->PresShell()->FreeByObjectID(nsPresArena::nsStyleContext_id, this);
 }
 
 already_AddRefed<nsStyleContext>
 NS_NewStyleContext(nsStyleContext* aParentContext,
                    nsIAtom* aPseudoTag,
                    nsCSSPseudoElements::Type aPseudoType,
                    nsRuleNode* aRuleNode)
 {
   nsStyleContext* context =
-    new (aRuleNode->GetPresContext())
+    new (aRuleNode->PresContext())
       nsStyleContext(aParentContext, aPseudoTag, aPseudoType, aRuleNode);
   context->AddRef();
   return context;
 }
 
 static inline void
 ExtractAnimationValue(nsCSSProperty aProperty,
                       nsStyleContext* aStyleContext,
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -84,17 +84,17 @@ public:
     NS_LOG_RELEASE(this, mRefCnt, "nsStyleContext");
     if (mRefCnt == 0) {
       Destroy();
       return 0;
     }
     return mRefCnt;
   }
 
-  nsPresContext* PresContext() const { return mRuleNode->GetPresContext(); }
+  nsPresContext* PresContext() const { return mRuleNode->PresContext(); }
 
   nsStyleContext* GetParent() const { return mParent; }
 
   nsIAtom* GetPseudo() const { return mPseudoTag; }
   nsCSSPseudoElements::Type GetPseudoType() const {
     return static_cast<nsCSSPseudoElements::Type>(mBits >>
                                                   NS_STYLE_CONTEXT_TYPE_SHIFT);
   }
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -157,17 +157,17 @@ nsStyleSet::Init(nsPresContext *aPresCon
 nsresult
 nsStyleSet::BeginReconstruct()
 {
   NS_ASSERTION(!mInReconstruct, "Unmatched begin/end?");
   NS_ASSERTION(mRuleTree, "Reconstructing before first construction?");
 
   // Create a new rule tree root
   nsRuleNode* newTree =
-    nsRuleNode::CreateRootNode(mRuleTree->GetPresContext());
+    nsRuleNode::CreateRootNode(mRuleTree->PresContext());
   if (!newTree)
     return NS_ERROR_OUT_OF_MEMORY;
 
   // Save the old rule tree so we can destroy it later
   if (!mOldRuleTrees.AppendElement(mRuleTree)) {
     newTree->Destroy();
     return NS_ERROR_OUT_OF_MEMORY;
   }
@@ -1633,18 +1633,17 @@ SkipAnimationRules(nsRuleNode* aRuleNode
     ruleNode = ruleNode->GetParent();
   }
   if (ruleNode != aRuleNode) {
     NS_ASSERTION(aElement, "How can we have transition rules but no element?");
     // Need to do an animation restyle, just like
     // nsTransitionManager::WalkTransitionRule and
     // nsAnimationManager::GetAnimationRule would.
     nsRestyleHint hint = isPseudo ? eRestyle_Subtree : eRestyle_Self;
-    aRuleNode->GetPresContext()->PresShell()->RestyleForAnimation(aElement,
-                                                                  hint);
+    aRuleNode->PresContext()->PresShell()->RestyleForAnimation(aElement, hint);
   }
   return ruleNode;
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ReparentStyleContext(nsStyleContext* aStyleContext,
                                  nsStyleContext* aNewParentContext,
                                  Element* aElement)
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -371,17 +371,17 @@ class nsStyleSet
   GetContext(nsStyleContext* aParentContext,
              nsRuleNode* aRuleNode,
              nsRuleNode* aVisitedRuleNode,
              nsIAtom* aPseudoTag,
              nsCSSPseudoElements::Type aPseudoType,
              mozilla::dom::Element* aElementForAnimation,
              uint32_t aFlags);
 
-  nsPresContext* PresContext() { return mRuleTree->GetPresContext(); }
+  nsPresContext* PresContext() { return mRuleTree->PresContext(); }
 
   // The sheets in each array in mSheets are stored with the most significant
   // sheet last.
   nsCOMArray<nsIStyleSheet> mSheets[eSheetTypeCount];
 
   // mRuleProcessors[eScopedDocSheet] is always null; rule processors
   // for scoped style sheets are stored in mScopedDocSheetRuleProcessors.
   nsCOMPtr<nsIStyleRuleProcessor> mRuleProcessors[eSheetTypeCount];
diff --git a/widget/xpwidgets/nsNativeTheme.cpp b/widget/xpwidgets/nsNativeTheme.cpp
--- a/widget/xpwidgets/nsNativeTheme.cpp
+++ b/widget/xpwidgets/nsNativeTheme.cpp
@@ -32,19 +32,19 @@ nsNativeTheme::nsNativeTheme()
 NS_IMPL_ISUPPORTS1(nsNativeTheme, nsITimerCallback)
 
 nsIPresShell *
 nsNativeTheme::GetPresShell(nsIFrame* aFrame)
 {
   if (!aFrame)
     return nullptr;
 
-  // this is a workaround for the egcs 1.1.2 not inliningg
-  // aFrame->GetPresContext(), which causes an undefined symbol
-  nsPresContext *context = aFrame->StyleContext()->RuleNode()->GetPresContext();
+  // this is a workaround for the egcs 1.1.2 not inlining
+  // aFrame->PresContext(), which causes an undefined symbol
+  nsPresContext *context = aFrame->StyleContext()->RuleNode()->PresContext();
   return context ? context->GetPresShell() : nullptr;
 }
 
 nsEventStates
 nsNativeTheme::GetContentState(nsIFrame* aFrame, uint8_t aWidgetType)
 {
   if (!aFrame)
     return nsEventStates();
