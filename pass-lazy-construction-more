From: L. David Baron <dbaron@dbaron.org>

Bug 1110277 patch 6 - Pass aAllowLazyConstruction parameter from nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval to nsCSSFrameConstructor::RecreateFramesForContent.

This is needed for the automated test that uses flexbox wrapping in
patch 7, but is not related to fixing the originally-reported bug.

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -9079,17 +9079,18 @@ nsCSSFrameConstructor::MaybeRecreateCont
         // not going to catch cases when we're the first child.
         (inFlowFrame->GetType() == nsGkAtoms::tableColGroupFrame &&
          parent->GetFirstChild(nsIFrame::kColGroupList) == inFlowFrame) ||
         // Similar if we're a table-caption.
         (inFlowFrame->GetType() == nsGkAtoms::tableCaptionFrame &&
          parent->GetFirstChild(nsIFrame::kCaptionList) == inFlowFrame)) {
       // We're the first or last frame in the pseudo.  Need to reframe.
       // Good enough to recreate frames for |parent|'s content
-      *aResult = RecreateFramesForContent(parent->GetContent(), true, aFlags,
+      *aResult = RecreateFramesForContent(parent->GetContent(),
+                                          aAllowLazyConstruction, aFlags,
                                           aDestroyedFramesFor);
       return true;
     }
   }
 
   // Might need to reconstruct things if this frame's nextSibling is a table
   // or ruby pseudo, since removal of this frame might mean that this pseudo
   // needs to get merged with the frame's prevSibling if that's also a table
@@ -9109,17 +9110,18 @@ nsCSSFrameConstructor::MaybeRecreateCont
                "frame=");
         nsFrame::ListTag(stdout, aFrame);
         printf(" has a table pseudo next sibling of different type and a "
                "table pseudo prevsibling\n");
       }
 #endif
       // Good enough to recreate frames for aFrame's parent's content; even if
       // aFrame's parent is a pseudo, that'll be the right content node.
-      *aResult = RecreateFramesForContent(parent->GetContent(), true, aFlags,
+      *aResult = RecreateFramesForContent(parent->GetContent(),
+                                          aAllowLazyConstruction, aFlags,
                                           aDestroyedFramesFor);
       return true;
     }
   }
 
   // Check ruby containers
   nsIAtom* parentType = parent->GetType();
   if (parentType == nsGkAtoms::rubyFrame ||
@@ -9127,17 +9129,18 @@ nsCSSFrameConstructor::MaybeRecreateCont
       parentType == nsGkAtoms::rubyTextContainerFrame) {
     // In ruby containers, pseudo frames may be created from
     // whitespaces or even nothing. There are two cases we actually
     // need to handle here, but hard to check exactly:
     // 1. Status of spaces beside the frame may vary, and related
     //    frames may be constructed or destroyed accordingly.
     // 2. The type of the first child of a ruby frame determines
     //    whether a pseudo ruby base container should exist.
-    *aResult = RecreateFramesForContent(parent->GetContent(), true, aFlags,
+    *aResult = RecreateFramesForContent(parent->GetContent(),
+                                        aAllowLazyConstruction, aFlags,
                                         aDestroyedFramesFor);
     return true;
   }
 
   // Might need to reconstruct things if the removed frame's nextSibling is an
   // anonymous flex item.  The removed frame might've been what divided two
   // runs of inline content into two anonymous flex items, which would now
   // need to be merged.
@@ -9151,17 +9154,18 @@ nsCSSFrameConstructor::MaybeRecreateCont
     if (gNoisyContentUpdates) {
       printf("nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval: "
              "frame=");
       nsFrame::ListTag(stdout, aFrame);
       printf(" has an anonymous flex item as its next sibling\n");
     }
 #endif // DEBUG
     // Recreate frames for the flex container (the removed frame's parent)
-    *aResult = RecreateFramesForContent(parent->GetContent(), true, aFlags,
+    *aResult = RecreateFramesForContent(parent->GetContent(),
+                                        aAllowLazyConstruction, aFlags,
                                         aDestroyedFramesFor);
     return true;
   }
 
   // Might need to reconstruct things if the removed frame's nextSibling is
   // null and its parent is an anonymous flex item. (This might be the last
   // remaining child of that anonymous flex item, which can then go away.)
   if (!nextSibling && IsAnonymousFlexOrGridItem(parent)) {
@@ -9170,17 +9174,18 @@ nsCSSFrameConstructor::MaybeRecreateCont
     if (gNoisyContentUpdates) {
       printf("nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval: "
              "frame=");
       nsFrame::ListTag(stdout, aFrame);
       printf(" has an anonymous flex item as its parent\n");
     }
 #endif // DEBUG
     // Recreate frames for the flex container (the removed frame's grandparent)
-    *aResult = RecreateFramesForContent(parent->GetParent()->GetContent(), true,
+    *aResult = RecreateFramesForContent(parent->GetParent()->GetContent(),
+                                        aAllowLazyConstruction,
                                         aFlags, aDestroyedFramesFor);
     return true;
   }
 
 #ifdef MOZ_XUL
   if (aFrame->GetType() == nsGkAtoms::popupSetFrame) {
     nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
     if (rootBox && rootBox->GetPopupSetFrame() == aFrame) {
@@ -9191,17 +9196,18 @@ nsCSSFrameConstructor::MaybeRecreateCont
 #endif
 
   // Reconstruct if inflowFrame is parent's only child, and parent is, or has,
   // a non-fluid continuation, i.e. it was split by bidi resolution
   if (!inFlowFrame->GetPrevSibling() &&
       !inFlowFrame->GetNextSibling() &&
       ((parent->GetPrevContinuation() && !parent->GetPrevInFlow()) ||
        (parent->GetNextContinuation() && !parent->GetNextInFlow()))) {
-    *aResult = RecreateFramesForContent(parent->GetContent(), true, aFlags,
+    *aResult = RecreateFramesForContent(parent->GetContent(),
+                                        aAllowLazyConstruction, aFlags,
                                         aDestroyedFramesFor);
     return true;
   }
 
   // We might still need to reconstruct things if the parent of inFlowFrame is
   // ib-split, since in that case the removal of aFrame might affect the
   // splitting of its parent.
   if (!IsFramePartOfIBSplit(parent)) {
