From: L. David Baron <dbaron@dbaron.org>

Bug 1047928 patch 4 - Don't rerun selector matching for preference, charset, or system color changes.

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -940,17 +940,22 @@ nsPresContext::UpdateAfterPreferencesCha
   mDeviceContext->FlushFontCache();
 
   nsChangeHint hint = nsChangeHint(0);
 
   if (mPrefChangePendingNeedsReflow) {
     NS_UpdateHint(hint, NS_STYLE_HINT_REFLOW);
   }
 
-  RebuildAllStyleData(hint, eRestyle_Subtree);
+  // Preferences don't change the results of selector matching; they
+  // only change the computed style data.  This means we can pass
+  // nsRestyleHint(0).
+  // FIXME: Many preferences don't require rebuilding style data,
+  // either.
+  RebuildAllStyleData(hint, nsRestyleHint(0));
 }
 
 nsresult
 nsPresContext::Init(nsDeviceContext* aDeviceContext)
 {
   NS_ASSERTION(!mInitialized, "attempt to reinit pres context");
   NS_ENSURE_ARG(aDeviceContext);
 
@@ -1167,17 +1172,17 @@ nsPresContext::SetShell(nsIPresShell* aS
   }
 }
 
 void
 nsPresContext::DoChangeCharSet(const nsCString& aCharSet)
 {
   UpdateCharSet(aCharSet);
   mDeviceContext->FlushFontCache();
-  RebuildAllStyleData(NS_STYLE_HINT_REFLOW, eRestyle_Subtree);
+  RebuildAllStyleData(NS_STYLE_HINT_REFLOW, nsRestyleHint(0));
 }
 
 void
 nsPresContext::UpdateCharSet(const nsCString& aCharSet)
 {
   if (mLangService) {
     mLanguage = mLangService->LookupCharSet(aCharSet);
     // this will be a language group (or script) code rather than a true language code
@@ -1737,17 +1742,17 @@ nsPresContext::SysColorChangedInternal()
   }
 
   // Reset default background and foreground colors for the document since
   // they may be using system colors
   GetDocumentColorPreferences();
 
   // The system color values are computed to colors in the style data,
   // so normal style data comparison is sufficient here.
-  RebuildAllStyleData(nsChangeHint(0), eRestyle_Subtree);
+  RebuildAllStyleData(nsChangeHint(0), nsRestyleHint(0));
 }
 
 void
 nsPresContext::UIResolutionChanged()
 {
   if (!mPendingUIResolutionChanged) {
     nsCOMPtr<nsIRunnable> ev =
       NS_NewRunnableMethod(this, &nsPresContext::UIResolutionChangedInternal);
