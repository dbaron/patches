From: L. David Baron <dbaron@dbaron.org>

diff --git a/gfx/thebes/gfxFont.cpp b/gfx/thebes/gfxFont.cpp
--- a/gfx/thebes/gfxFont.cpp
+++ b/gfx/thebes/gfxFont.cpp
@@ -1516,30 +1516,32 @@ private:
             Glyph *end = &mGlyphBuffer[mNumGlyphs];
             std::reverse(begin, end);
         }
 
         gfx::GlyphBuffer buf;
         buf.mGlyphs = mGlyphBuffer;
         buf.mNumGlyphs = mNumGlyphs;
 
+        // FIXME
         gfxContext::AzureState state = mRunParams.context->CurrentState();
         if ((int(mRunParams.drawMode) &
             (int(DrawMode::GLYPH_STROKE) | int(DrawMode::GLYPH_STROKE_UNDERNEATH))) ==
             (int(DrawMode::GLYPH_STROKE) | int(DrawMode::GLYPH_STROKE_UNDERNEATH))) {
             FlushStroke(buf, state);
         }
         if (int(mRunParams.drawMode) & int(DrawMode::GLYPH_FILL)) {
             if (state.pattern || mFontParams.contextPaint) {
                 Pattern *pat;
 
                 RefPtr<gfxPattern> fillPattern;
                 if (!mFontParams.contextPaint ||
                     !(fillPattern = mFontParams.contextPaint->GetFillPattern(
-                                        mRunParams.context->GetDrawTarget(),
+                                        mRunParams.dt,
+                                        // FIXME
                                         mRunParams.context->CurrentMatrix()))) {
                     if (state.pattern) {
                         pat = state.pattern->GetPattern(mRunParams.dt,
                                       state.patternTransformChanged ?
                                           &state.patternTransform : nullptr);
                     } else {
                         pat = nullptr;
                     }
@@ -1590,19 +1592,21 @@ private:
             } else {
                 mRunParams.dt->FillGlyphs(mFontParams.scaledFont, buf,
                                           ColorPattern(state.color),
                                           mFontParams.drawOptions,
                                           mFontParams.renderingOptions);
             }
         }
         if (int(mRunParams.drawMode) & int(DrawMode::GLYPH_PATH)) {
+            // FIXME
             mRunParams.context->EnsurePathBuilder();
             Matrix mat = mRunParams.dt->GetTransform();
             mFontParams.scaledFont->CopyGlyphsToBuilder(
+                // FIXME
                 buf, mRunParams.context->mPathBuilder,
                 mRunParams.dt->GetBackendType(), &mat);
         }
         if ((int(mRunParams.drawMode) &
             (int(DrawMode::GLYPH_STROKE) | int(DrawMode::GLYPH_STROKE_UNDERNEATH))) ==
              int(DrawMode::GLYPH_STROKE)) {
             FlushStroke(buf, state);
         }
@@ -1612,16 +1616,17 @@ private:
 
     void FlushStroke(gfx::GlyphBuffer& aBuf, gfxContext::AzureState& aState)
     {
         RefPtr<Path> path =
             mFontParams.scaledFont->GetPathForGlyphs(aBuf, mRunParams.dt);
         if (mFontParams.contextPaint) {
             RefPtr<gfxPattern> strokePattern =
                 mFontParams.contextPaint->GetStrokePattern(
+                    // FIXME
                     mRunParams.context->GetDrawTarget(),
                     mRunParams.context->CurrentMatrix());
             if (strokePattern) {
                 mRunParams.dt->Stroke(path,
                                       *strokePattern->GetPattern(mRunParams.dt),
                                       aState.strokeOptions);
             }
         }
@@ -1805,16 +1810,17 @@ gfxFont::DrawGlyphs(gfxShapedText       
                             if (aFontParams.passedInvMatrix) {
                                 oldMat = aRunParams.dt->GetTransform();
                                 aRunParams.dt->SetTransform(
                                     *aFontParams.passedInvMatrix * oldMat);
                             }
 
                             gfxFontMissingGlyphs::DrawMissingGlyph(
                                 details->mGlyphID, glyphRect, *aRunParams.dt,
+                                // FIXME
                                 PatternFromState(aRunParams.context),
                                 aShapedText->GetAppUnitsPerDevUnit());
 
                             // Restore the matrix, if we modified it before
                             // drawing the hexbox.
                             if (aFontParams.passedInvMatrix) {
                                 aRunParams.dt->SetTransform(oldMat);
                             }
@@ -1874,27 +1880,29 @@ gfxFont::Draw(gfxTextRun *aTextRun, uint
     fontParams.contextPaint = aRunParams.runContextPaint;
     fontParams.isVerticalFont =
         aOrientation == gfxTextRunFactory::TEXT_ORIENT_VERTICAL_UPRIGHT;
 
     bool sideways = false;
     gfxPoint origPt = *aPt;
     if (aRunParams.isVerticalRun && !fontParams.isVerticalFont) {
         sideways = true;
+        // FIXME
         aRunParams.context->Save();
         gfxPoint p(aPt->x * aRunParams.devPerApp,
                    aPt->y * aRunParams.devPerApp);
         const Metrics& metrics = GetMetrics(eHorizontal);
         // Get a matrix we can use to draw the (horizontally-shaped) textrun
         // with 90-degree CW rotation.
         const gfxFloat
             rotation = (aOrientation ==
                         gfxTextRunFactory::TEXT_ORIENT_VERTICAL_SIDEWAYS_LEFT)
                        ? -M_PI / 2.0 : M_PI / 2.0;
         gfxMatrix mat =
+            // FIXME
             aRunParams.context->CurrentMatrix().
             Translate(p).     // translate origin for rotation
             Rotate(rotation). // turn 90deg CCW (sideways-left) or CW (*-right)
             Translate(-p);    // undo the translation
 
         // If we're drawing rotated horizontal text for an element styled
         // text-orientation:mixed, the dominant baseline will be vertical-
         // centered. So in this case, we need to adjust the position so that
@@ -1904,34 +1912,38 @@ gfxFont::Draw(gfxTextRun *aTextRun, uint
         // should eventually look for baseline tables[1] in the fonts and use
         // those if available.
         // [1] See http://www.microsoft.com/typography/otspec/base.htm
         if (aTextRun->UseCenterBaseline()) {
             gfxPoint baseAdj(0, (metrics.emAscent - metrics.emDescent) / 2);
             mat.Translate(baseAdj);
         }
 
+        // FIXME
         aRunParams.context->SetMatrix(mat);
     }
 
     nsAutoPtr<gfxTextContextPaint> contextPaint;
     if (fontParams.haveSVGGlyphs && !fontParams.contextPaint) {
         // If no pattern is specified for fill, use the current pattern
         NS_ASSERTION((int(aRunParams.drawMode) & int(DrawMode::GLYPH_STROKE)) == 0,
                      "no pattern supplied for stroking text");
+        // FIXME
         RefPtr<gfxPattern> fillPattern = aRunParams.context->GetPattern();
         contextPaint =
             new SimpleTextContextPaint(fillPattern, nullptr,
+                                       // FIXME
                                        aRunParams.context->CurrentMatrix());
         fontParams.contextPaint = contextPaint;
     }
 
     // Synthetic-bold strikes are each offset one device pixel in run direction.
     // (these values are only needed if IsSyntheticBold() is true)
     if (IsSyntheticBold()) {
+        // FIXME
         double xscale = CalcXScale(aRunParams.context);
         fontParams.synBoldOnePixelOffset = aRunParams.direction * xscale;
         if (xscale != 0.0) {
             // use as many strikes as needed for the the increased advance
             fontParams.extraStrikes =
                 std::max(1, NS_lroundf(GetSyntheticBoldOffset() / xscale));
         }
     } else {
@@ -1997,16 +2009,17 @@ gfxFont::Draw(gfxTextRun *aTextRun, uint
     if (aRunParams.callbacks && emittedGlyphs) {
         aRunParams.callbacks->NotifyGlyphPathEmitted();
     }
 
     aRunParams.dt->SetTransform(oldMat);
     aRunParams.dt->SetPermitSubpixelAA(oldSubpixelAA);
 
     if (sideways) {
+        // FIXME
         aRunParams.context->Restore();
         // adjust updated aPt to account for the transform we were using
         gfxFloat advance = aPt->x - origPt.x;
         if (aOrientation ==
             gfxTextRunFactory::TEXT_ORIENT_VERTICAL_SIDEWAYS_LEFT) {
             *aPt = gfxPoint(origPt.x, origPt.y - advance);
         } else {
             *aPt = gfxPoint(origPt.x, origPt.y + advance);
diff --git a/gfx/thebes/gfxFont.h b/gfx/thebes/gfxFont.h
--- a/gfx/thebes/gfxFont.h
+++ b/gfx/thebes/gfxFont.h
@@ -2107,16 +2107,17 @@ protected:
 #define DEFAULT_XHEIGHT_FACTOR 0.56f
 
 // Parameters passed to gfxFont methods for drawing glyphs from a textrun.
 // The TextRunDrawParams are set up once per textrun; the FontDrawParams
 // are dependent on the specific font, so they are set per GlyphRun.
 
 struct TextRunDrawParams {
     RefPtr<mozilla::gfx::DrawTarget> dt;
+    // FIXME
     gfxContext              *context;
     gfxFont::Spacing        *spacing;
     gfxTextRunDrawCallbacks *callbacks;
     gfxTextContextPaint     *runContextPaint;
     mozilla::gfx::Color      fontSmoothingBGColor;
     gfxFloat                 direction;
     double                   devPerApp;
     DrawMode                 drawMode;
diff --git a/gfx/thebes/gfxTextRun.cpp b/gfx/thebes/gfxTextRun.cpp
--- a/gfx/thebes/gfxTextRun.cpp
+++ b/gfx/thebes/gfxTextRun.cpp
@@ -450,16 +450,17 @@ gfxTextRun::DrawPartialLigature(gfxFont 
                                 TextRunDrawParams& aParams, uint16_t aOrientation)
 {
     if (aStart >= aEnd) {
         return;
     }
 
     // Draw partial ligature. We hack this by clipping the ligature.
     LigatureData data = ComputeLigatureData(aStart, aEnd, aProvider);
+    // FIXME
     gfxRect clipExtents = aParams.context->GetClipExtents();
     gfxFloat start, end;
     if (aParams.isVerticalRun) {
         start = clipExtents.Y() * mAppUnitsPerDevUnit;
         end = clipExtents.YMost() * mAppUnitsPerDevUnit;
         ClipPartialLigature(this, &start, &end, aPt->y, &data);
     } else {
         start = clipExtents.X() * mAppUnitsPerDevUnit;
@@ -473,29 +474,31 @@ gfxTextRun::DrawPartialLigature(gfxFont 
       // Also, make sure we snap the rectangle to device pixels.
       Rect clipRect = aParams.isVerticalRun ?
           Rect(clipExtents.X(), start / mAppUnitsPerDevUnit,
                clipExtents.Width(), (end - start) / mAppUnitsPerDevUnit) :
           Rect(start / mAppUnitsPerDevUnit, clipExtents.Y(),
                (end - start) / mAppUnitsPerDevUnit, clipExtents.Height());
       MaybeSnapToDevicePixels(clipRect, *aParams.dt, true);
 
+      // FIXME
       aParams.context->Save();
       aParams.context->Clip(clipRect);
     }
 
     gfxPoint pt;
     if (aParams.isVerticalRun) {
         pt = gfxPoint(aPt->x, aPt->y - aParams.direction * data.mPartAdvance);
     } else {
         pt = gfxPoint(aPt->x - aParams.direction * data.mPartAdvance, aPt->y);
     }
 
     DrawGlyphs(aFont, data.mLigatureStart, data.mLigatureEnd, &pt,
                aProvider, aStart, aEnd, aParams, aOrientation);
+    // FIXME
     aParams.context->Restore();
 
     if (aParams.isVerticalRun) {
         aPt->y += aParams.direction * data.mPartWidth;
     } else {
         aPt->x += aParams.direction * data.mPartWidth;
     }
 }
@@ -616,16 +619,17 @@ gfxTextRun::Draw(gfxContext *aContext, g
         metrics.mBoundingBox.MoveBy(aPt);
         syntheticBoldBuffer.PushSolidColor(metrics.mBoundingBox, currentColor,
                                            GetAppUnitsPerDevUnit());
     }
 
     // Set up parameters that will be constant across all glyph runs we need
     // to draw, regardless of the font used.
     TextRunDrawParams params;
+    // FIXME
     params.context = aContext;
     params.devPerApp = 1.0 / double(GetAppUnitsPerDevUnit());
     params.isVerticalRun = IsVertical();
     params.isRTL = IsRightToLeft();
     params.direction = direction;
     params.drawMode = aDrawMode;
     params.callbacks = aCallbacks;
     params.runContextPaint = aContextPaint;
