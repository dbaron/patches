From: L. David Baron <dbaron@dbaron.org>

Fix skipping of @-rules that are inside blocks to conform to new rule in CSS 2.1.  (Bug 604175)

This fixes the third test in
http://test.csswg.org/suites/css2.1/20110111/html4/at-rule-013.htm
(though not the fourth).

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -305,17 +305,17 @@ protected:
 
   PRBool ExpectSymbol(PRUnichar aSymbol, PRBool aSkipWS);
   PRBool ExpectEndProperty();
   PRBool CheckEndProperty();
   nsSubstring* NextIdent();
   void SkipUntil(PRUnichar aStopSymbol);
   void SkipUntilOneOf(const PRUnichar* aStopSymbolChars);
   void SkipRuleSet(PRBool aInsideBraces);
-  PRBool SkipAtRule();
+  PRBool SkipAtRule(PRBool aInsideBlock);
   PRBool SkipDeclaration(PRBool aCheckForBraces);
 
   PRBool PushGroup(nsICSSGroupRule* aRule);
   void PopGroup(void);
 
   PRBool ParseRuleSet(RuleAppendFunc aAppendFunc, void* aProcessData,
                       PRBool aInsideBraces = PR_FALSE);
   PRBool ParseAtRule(RuleAppendFunc aAppendFunc, void* aProcessData);
@@ -1421,28 +1421,33 @@ CSSParserImpl::NextIdent()
   if (eCSSToken_Ident != mToken.mType) {
     UngetToken();
     return nsnull;
   }
   return &mToken.mIdent;
 }
 
 PRBool
-CSSParserImpl::SkipAtRule()
+CSSParserImpl::SkipAtRule(PRBool aInsideBlock)
 {
   for (;;) {
     if (!GetToken(PR_TRUE)) {
       REPORT_UNEXPECTED_EOF(PESkipAtRuleEOF);
       return PR_FALSE;
     }
     if (eCSSToken_Symbol == mToken.mType) {
       PRUnichar symbol = mToken.mSymbol;
       if (symbol == ';') {
         break;
       }
+      if (aInsideBlock && symbol == '}') {
+        // The closing } doesn't belong to us.
+        UngetToken();
+        break;
+      }
       if (symbol == '{') {
         SkipUntil('}');
         break;
       } else if (symbol == '(') {
         SkipUntil(')');
       } else if (symbol == '[') {
         SkipUntil(']');
       }
@@ -1452,16 +1457,22 @@ CSSParserImpl::SkipAtRule()
   }
   return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseAtRule(RuleAppendFunc aAppendFunc,
                            void* aData)
 {
+  // If we ever allow nested at-rules, we need to be very careful about
+  // the error handling rules in the CSS spec.  In particular, we need
+  // to pass in to ParseAtRule whether we're inside a block, we need to
+  // ensure that all the individual at-rule parsing functions terminate
+  // immediately when they hit a '}', and then we need to pass whether
+  // we're inside a block to SkipAtRule below.
   nsCSSSection newSection;
   PRBool (CSSParserImpl::*parseFunc)(RuleAppendFunc, void*);
 
   if ((mSection <= eCSSSection_Charset) &&
       (mToken.mIdent.LowerCaseEqualsLiteral("charset"))) {
     parseFunc = &CSSParserImpl::ParseCharsetRule;
     newSection = eCSSSection_Import;  // only one charset allowed
 
@@ -1492,23 +1503,23 @@ CSSParserImpl::ParseAtRule(RuleAppendFun
     newSection = eCSSSection_General;
 
   } else {
     if (!NonMozillaVendorIdentifier(mToken.mIdent)) {
       REPORT_UNEXPECTED_TOKEN(PEUnknownAtRule);
       OUTPUT_ERROR();
     }
     // Skip over unsupported at rule, don't advance section
-    return SkipAtRule();
+    return SkipAtRule(PR_FALSE);
   }
 
   if (!(this->*parseFunc)(aAppendFunc, aData)) {
     // Skip over invalid at rule, don't advance section
     OUTPUT_ERROR();
-    return SkipAtRule();
+    return SkipAtRule(PR_FALSE);
   }
 
   mSection = newSection;
   return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseCharsetRule(RuleAppendFunc aAppendFunc,
@@ -1959,17 +1970,17 @@ CSSParserImpl::ParseGroupRule(nsICSSGrou
       REPORT_UNEXPECTED_EOF(PEGroupRuleEOF);
       break;
     }
     if (mToken.IsSymbol('}')) { // done!
       UngetToken();
       break;
     }
     if (eCSSToken_AtKeyword == mToken.mType) {
-      SkipAtRule(); // group rules cannot contain @rules
+      SkipAtRule(PR_TRUE); // group rules cannot contain @rules
       // XXX OUTPUT AN ERROR
       continue;
     }
     UngetToken();
     ParseRuleSet(AppendRuleToSheet, this, PR_TRUE);
   }
   PopGroup();
 
