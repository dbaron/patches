Remove PerFrameData::mFrameType, since it's write-only.  (Bug 478899)  r+sr=bzbarsky

diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -784,17 +784,16 @@ nsLineLayout::ReflowFrame(nsIFrame* aFra
   if (reflowState.ComputedWidth() == NS_UNCONSTRAINEDSIZE)
     reflowState.availableWidth = psd->mRightEdge - psd->mX;
 
   // Stash copies of some of the computed state away for later
   // (vertical alignment, for example)
   pfd->mFrame = aFrame;
   pfd->mMargin = reflowState.mComputedMargin;
   pfd->mBorderPadding = reflowState.mComputedBorderPadding;
-  pfd->mFrameType = reflowState.mFrameType;
   pfd->SetFlag(PFD_RELATIVEPOS,
                (reflowState.mStyleDisplay->mPosition == NS_STYLE_POSITION_RELATIVE));
   if (pfd->GetFlag(PFD_RELATIVEPOS)) {
     pfd->mOffsets = reflowState.mComputedOffsets;
   }
 
   // NOTE: While the x coordinate remains relative to the parent span,
   // the y coordinate is fixed at the top edge for the line. During
@@ -1329,17 +1328,16 @@ nsLineLayout::AddBulletFrame(nsIFrame* a
 
   PerFrameData* pfd;
   nsresult rv = NewPerFrameData(&pfd);
   if (NS_SUCCEEDED(rv)) {
     mRootSpan->AppendFrame(pfd);
     pfd->mFrame = aFrame;
     pfd->mMargin.SizeTo(0, 0, 0, 0);
     pfd->mBorderPadding.SizeTo(0, 0, 0, 0);
-    pfd->mFrameType = NS_FRAME_REPLACED(NS_CSS_FRAME_TYPE_INLINE);
     pfd->mFlags = 0;  // all flags default to false
     pfd->SetFlag(PFD_ISBULLET, PR_TRUE);
     if (aMetrics.ascent == nsHTMLReflowMetrics::ASK_FOR_BASELINE)
       pfd->mAscent = aFrame->GetBaseline();
     else
       pfd->mAscent = aMetrics.ascent;
 
     // Note: y value will be updated during vertical alignment
@@ -1375,17 +1373,16 @@ nsLineLayout::DumpPerSpanData(PerSpanDat
 #define VALIGN_BOTTOM 2
 
 void
 nsLineLayout::VerticalAlignLine()
 {
   // Synthesize a PerFrameData for the block frame
   PerFrameData rootPFD;
   rootPFD.mFrame = mBlockReflowState->frame;
-  rootPFD.mFrameType = mBlockReflowState->mFrameType;
   rootPFD.mAscent = 0;
   mRootSpan->mFrame = &rootPFD;
 
   // Partially place the children of the block frame. The baseline for
   // this operation is set to zero so that the y coordinates for all
   // of the placed children will be relative to there.
   PerSpanData* psd = mRootSpan;
   VerticalAlignFrames(psd);
diff --git a/layout/generic/nsLineLayout.h b/layout/generic/nsLineLayout.h
--- a/layout/generic/nsLineLayout.h
+++ b/layout/generic/nsLineLayout.h
@@ -438,19 +438,18 @@ protected:
   struct PerFrameData {
     // link to next/prev frame in same span
     PerFrameData* mNext;
     PerFrameData* mPrev;
 
     // pointer to child span data if this is an inline container frame
     PerSpanData* mSpan;
 
-    // The frame and its type
+    // The frame
     nsIFrame* mFrame;
-    nsCSSFrameType mFrameType;
 
     // From metrics
     nscoord mAscent;
     nsRect mBounds;
     nsRect mCombinedArea;
 
     // From reflow-state
     nsMargin mMargin;
