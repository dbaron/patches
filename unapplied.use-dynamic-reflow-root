From: L. David Baron <dbaron@dbaron.org>

Bug 1159042 patch 4 - Use NS_FRAME_DYNAMIC_REFLOW_ROOT.

Causes test failures (ran Linux 64 debug only):
 - Marionnette
   - test_selectioncarets.py
   - test_selectioncarets2.py
 - Mochitest 1
   - dom/browser-element/mochitest/test_browserElement_inproc_CopyPaste.html | Assertion count 12 is greater than expected range 0-0 assertions.
 - Mochitest browser-chrome 3
   - browser/components/tabview/test/browser_tabview_bug587503.js | Validate tab positions in test 2. - Got 0,1,2,3,4,6,5, expected 0,6,2,3,4,5,1
   - followed by many more failures in browser/components/tabview
 - Crashtest
   - REFTEST TEST-UNEXPECTED-FAIL | layout/base/crashtests/428113.xhtml | assertion count 1 is more than expected 0 assertions
     -> "Out-of-flow frame got reflowed before its placeholder", which
     seems like it might be a fundamental problem, since if we
     dynamically add an absolutely positioned element, with the
     placeholder and the primary frame separated by a dynamic reflow
     root, it's not clear what would make us reflow them in the correct
     order
   - REFTEST TEST-UNEXPECTED-PASS | layout/generic/crashtests/323386-1.html | assertion count 0 is less than expected 1 assertions

diff --git a/layout/base/PresShell.cpp b/layout/base/PresShell.cpp
--- a/layout/base/PresShell.cpp
+++ b/layout/base/PresShell.cpp
@@ -2622,17 +2622,18 @@ PresShell::VerifyHasDirtyRootAncestor(ns
   // handles the root frame correctly.
   if (!aFrame->GetParent()) {
     return;
   }
 
   // Make sure that there is a reflow root ancestor of |aFrame| that's
   // in mDirtyRoots already.
   while (aFrame && (aFrame->GetStateBits() & NS_FRAME_HAS_DIRTY_CHILDREN)) {
-    if (((aFrame->GetStateBits() & NS_FRAME_REFLOW_ROOT) ||
+    if (((aFrame->GetStateBits() &
+          (NS_FRAME_REFLOW_ROOT | NS_FRAME_DYNAMIC_REFLOW_ROOT)) ||
          !aFrame->GetParent()) &&
         mDirtyRoots.Contains(aFrame)) {
       return;
     }
 
     aFrame = aFrame->GetParent();
   }
 
@@ -2707,17 +2708,18 @@ PresShell::FrameNeedsReflow(nsIFrame *aF
         targetNeedsReflowFromParent = false;
         break;
       case eInferFromBitToAdd:
         targetNeedsReflowFromParent = (aBitToAdd == NS_FRAME_IS_DIRTY);
         break;
     }
 
 #define FRAME_IS_REFLOW_ROOT(_f)                   \
-  ((_f->GetStateBits() & NS_FRAME_REFLOW_ROOT) &&  \
+  ((_f->GetStateBits() & \
+    (NS_FRAME_REFLOW_ROOT | NS_FRAME_DYNAMIC_REFLOW_ROOT)) && \
    (_f != subtreeRoot || !targetNeedsReflowFromParent))
 
 
     // Mark the intrinsic widths as dirty on the frame, all of its ancestors,
     // and all of its descendants, if needed:
 
     if (aIntrinsicDirty != nsIPresShell::eResize) {
       // Mark argument and all ancestors dirty. (Unless we hit a reflow
diff --git a/layout/generic/ReflowInput.cpp b/layout/generic/ReflowInput.cpp
--- a/layout/generic/ReflowInput.cpp
+++ b/layout/generic/ReflowInput.cpp
@@ -2642,16 +2642,17 @@ SizeComputationInput::InitOffsets(Writin
     needPaddingProp = false;
   }
   else if (nsSVGUtils::IsInSVGTextSubtree(mFrame)) {
     ComputedPhysicalPadding().SizeTo(0, 0, 0, 0);
     needPaddingProp = false;
   }
   else if (aPadding) { // padding is an input arg
     ComputedPhysicalPadding() = *aPadding;
+    // FIXME
     needPaddingProp = mFrame->StylePadding()->IsWidthDependent() ||
 	  (mFrame->GetStateBits() & NS_FRAME_REFLOW_ROOT);
   }
   else {
     needPaddingProp = ComputePadding(aWM, aPercentBasis, aFrameType);
   }
 
   // Add [align|justify]-content:baseline padding contribution.
