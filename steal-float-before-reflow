From: L. David Baron <dbaron@dbaron.org>

Steal float back before reflowing it, in order to allow first continuation of a float to be pushed to the next page.  (Bug 563584)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -4458,17 +4458,17 @@ nsBlockFrame::DrainFloatContinuations(ns
 {
   // Take any continuations we need to take from our prev-in-flow.
   nsBlockFrame* prevBlock = static_cast<nsBlockFrame*>(GetPrevInFlow());
   if (!prevBlock)
     return;
   nsFrameList *list = prevBlock->RemoveFloatContinuations();
   if (list) {
     if (list->NotEmpty()) {
-      mFloats.InsertFrames(nsnull, nsnull, *list);
+      mFloats.InsertFrames(this, nsnull, *list);
     }
     delete list;
   }
 
 #ifdef DEBUG
   for (nsIFrame* f = mFloats.FirstChild(); f ; f = f->GetNextSibling()) {
     for (nsIFrame* c = f->GetFirstInFlow(); c ; c = c->GetNextInFlow()) {
       NS_ASSERTION(c == f || c->GetParent() != this || !mFloats.ContainsFrame(c),
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -542,18 +542,39 @@ nsBlockReflowState::AddFloat(nsLineLayou
                              nscoord             aAvailableWidth,
                              nsReflowStatus&     aReflowStatus)
 {
   NS_PRECONDITION(aLineLayout, "must have line layout");
   NS_PRECONDITION(mBlock->end_lines() != mCurrentLine, "null ptr");
   NS_PRECONDITION(aFloat->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
                   "aFloat must be an out-of-flow frame");
 
-  // Set the geometric parent of the float
-  aFloat->SetParent(mBlock);
+  NS_ABORT_IF_FALSE(aFloat->GetParent(), "float must have parent");
+  NS_ABORT_IF_FALSE(aFloat->GetParent()->IsFrameOfType(nsIFrame::eBlockFrame),
+                    "float's parent must be block");
+  NS_ABORT_IF_FALSE(aFloat->GetParent() == mBlock ||
+                    (aFloat->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION),
+                    "float should be in this block unless it was marked as "
+                    "float continuation");
+  if (aFloat->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION) {
+    // If, in a previous reflow, the float was pushed entirely to
+    // another column/page, we need to steal it back.  (We might just
+    // push it again, though.)  Likewise, if that previous reflow
+    // reflowed this block but not its next continuation, we might need
+    // to steal it from our own float-continuations list.
+    nsBlockFrame *floatParent =
+      static_cast<nsBlockFrame*>(aFloat->GetParent());
+    floatParent->StealFrame(mPresContext, aFloat);
+
+    aFloat->RemoveStateBits(NS_FRAME_IS_FLOAT_CONTINUATION);
+
+    // Appending is fine, since if a float was pushed to the next
+    // page/column, all later floats were also pushed.
+    mBlock->mFloats.AppendFrame(mBlock, aFloat);
+  }
 
   aReflowStatus = NS_FRAME_COMPLETE;
 
   // Because we are in the middle of reflowing a placeholder frame
   // within a line (and possibly nested in an inline frame or two
   // that's a child of our block) we need to restore the space
   // manager's translation to the space that the block resides in
   // before placing the float.
