From: L. David Baron <dbaron@dbaron.org>

Steal float back before reflowing it, in order to allow first continuation of a float to be pushed to the next page.  (Bug 563584)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -4450,17 +4450,17 @@ nsBlockFrame::DrainFloatContinuations(ns
   // Take any continuations we need to take from our prev-in-flow.
   nsIFrame* prevBlock = GetPrevInFlow();
   if (!prevBlock)
     return;
   nsFrameList *list = static_cast<nsFrameList*>(
     aState.mPresContext->PropertyTable()->Remove(prevBlock,
                                                  FloatContinuationProperty()));
   if (list) {
-    mFloats.InsertFrames(nsnull, nsnull, *list);
+    mFloats.InsertFrames(this, nsnull, *list);
     delete list;
   }
 
 #ifdef DEBUG
   for (nsIFrame* f = mFloats.FirstChild(); f ; f = f->GetNextSibling()) {
     for (nsIFrame* c = f->GetFirstInFlow(); c ; c = c->GetNextInFlow()) {
       NS_ASSERTION(c == f || c->GetParent() != this || !mFloats.ContainsFrame(c),
                    "Two floats with same parent in same floats list, expect weird errors.");
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -548,18 +548,37 @@ nsBlockReflowState::AddFloat(nsLineLayou
                              nsIFrame*           aFloat,
                              nscoord             aAvailableWidth,
                              nsReflowStatus&     aReflowStatus)
 {
   NS_PRECONDITION(!aLineLayout || mBlock->end_lines() != mCurrentLine, "null ptr");
   NS_PRECONDITION(aFloat->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
                   "aFloat must be an out-of-flow frame");
 
-  // Set the geometric parent of the float
-  aFloat->SetParent(mBlock);
+  NS_ABORT_IF_FALSE(aFloat->GetParent(), "float must have parent");
+  NS_ABORT_IF_FALSE(aFloat->GetParent()->IsFrameOfType(nsIFrame::eBlockFrame),
+                    "float's parent must be block");
+  NS_ABORT_IF_FALSE(aFloat->GetParent() == mBlock ||
+                    (aFloat->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION),
+                    "float should be in this block unless it was marked as "
+                    "float continuation");
+  if ((aFloat->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION) &&
+      aFloat->GetParent() != mBlock) {
+    // If, in a previous reflow, the float was pushed entirely to
+    // another column/page, we need to steal it back.  (We might just
+    // push it again, though.)
+    nsBlockFrame *floatParent =
+      static_cast<nsBlockFrame*>(aFloat->GetParent());
+    floatParent->StealFrame(mPresContext, aFloat);
+
+    // Appending is fine, since if a float was pushed to the next
+    // page/column, all later floats were also pushed.
+    // FIXME: check that we do this
+    mBlock->mFloats.AppendFrame(mBlock, aFloat);
+  }
 
   aReflowStatus = NS_FRAME_COMPLETE;
 
   // Because we are in the middle of reflowing a placeholder frame
   // within a line (and possibly nested in an inline frame or two
   // that's a child of our block) we need to restore the space
   // manager's translation to the space that the block resides in
   // before placing the float.
