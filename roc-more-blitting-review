From: L. David Baron <dbaron@dbaron.org>

Bug 507334, part 2 (review comments):  Address my own review comments in previous changeset.  This is a separate patch since roc didn't write it or see it.

diff --git a/layout/base/nsLayoutUtils.h b/layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h
+++ b/layout/base/nsLayoutUtils.h
@@ -501,17 +501,17 @@ public:
    * @param aUpdateRect a rectangle that bounds the area to be updated,
    * relative to aRootFrame
    * @param aRepaintRegion output: a subregion of aUpdateRect that must be
    * repainted after doing the blit
    * @param aBlitRegion output: a subregion of aUpdateRect that should
    * be repainted by blitting
    * 
    * If the caller does a bitblt copy of aBlitRegion-aPt to aBlitRegion,
-   * and then repaint aRepaintRegion; then the area aUpdateRect will be
+   * and then repaints aRepaintRegion, then the area aUpdateRect will be
    * correctly up to date. aBlitRegion and aRepaintRegion do not intersect
    * and are both contained within aUpdateRect.
    * 
    * Frame geometry must have already been adjusted for the scroll/copy
    * operation before this function is called.
    * 
    * Conceptually it works by computing a display list in the before-state
    * and a display list in the after-state and analyzing them to find the
@@ -520,32 +520,30 @@ public:
    * efficient), so we use some unfortunately tricky techniques to get by
    * with just the after-list.
    * 
    * We compute the "visible moving area": aUpdateRect minus any opaque
    * areas of non-moving content that are above all moving content in
    * z-order.
    *
    * The aRepaintRegion region consists of the visible moving area
-   * intersected with the following areas:
+   * intersected with the union of the following areas:
    * a) any visible background-attachment:fixed areas in the after-move display
    * list
    * b) any visible areas of the before-move display list corresponding to
    * frames that will not move (translated by aDelta)
    * c) any visible areas of the after-move display list corresponding to
    * frames that did not move
-   * d) except that if the same display list element is visible in b) and c)
-   * for a frame that did not move and paints a uniform color within its
-   * bounds, then the intersection of its old and new bounds can be excluded
-   * when it is processed by b) and c).
    * 
    * aBlitRegion is the visible moving area minus aRepaintRegion.
    * 
    * We may return a larger region for aRepaintRegion and/or aBlitRegion
-   * if computing the above regions precisely is too expensive.
+   * if computing the above regions precisely is too expensive.  (However,
+   * they will never intersect, since the regions that may be computed
+   * imprecisely are really the "visible moving area" and aRepaintRegion.)
    */
   static nsresult ComputeRepaintRegionForCopy(nsIFrame* aRootFrame,
                                               nsIFrame* aMovingFrame,
                                               nsPoint aDelta,
                                               const nsRect& aUpdateRect,
                                               nsRegion* aBlitRegion,
                                               nsRegion* aRepaintRegion);
 
diff --git a/view/src/nsScrollPortView.cpp b/view/src/nsScrollPortView.cpp
--- a/view/src/nsScrollPortView.cpp
+++ b/view/src/nsScrollPortView.cpp
@@ -537,20 +537,20 @@ NS_IMETHODIMP nsScrollPortView::CanScrol
 
   // Can scroll to Bottom or to Right?
   aResult = (offset < max) ? PR_TRUE : PR_FALSE;
 
   return NS_OK;
 }
 
 /**
- * Given aBlitRegion in appunits, create an nsRegion in device pixels
- * that represents the device pixels that are wholly contained in
- * aBlitRegion. Whatever appunit area was removed in that process is
- * added to aRepaintRegion.
+ * Given aBlitRegion in appunits, create and return an nsRegion in
+ * device pixels that represents the device pixels that are wholly
+ * contained in aBlitRegion. Whatever appunit area was removed in that
+ * process is added to aRepaintRegion.
  */
 static nsRegion
 ConvertToInnerPixelRegion(const nsRegion& aBlitRegion,
                           nscoord aAppUnitsPerPixel,
                           nsRegion* aRepaintRegion)
 {
   // Basically we compute the inverse of aBlitRegion,
   // expand each of its rectangles out to device pixel boundaries, then
