From: L. David Baron <dbaron@dbaron.org>

Implement CSS transitions:  handle starting and management of the animations.  (Bug 435441)

diff --git a/content/base/src/nsGkAtomList.h b/content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h
+++ b/content/base/src/nsGkAtomList.h
@@ -1659,16 +1659,17 @@ GK_ATOM(excessOverflowContainersProperty
 GK_ATOM(overflowLinesProperty, "OverflowLinesProperty")    // list of nsLineBox*
 GK_ATOM(overflowOutOfFlowsProperty, "OverflowOutOfFlowsProperty")      // nsFrameList*
 GK_ATOM(overflowPlaceholdersProperty, "OverflowPlaceholdersProperty")  // nsFrameList*
 GK_ATOM(preEffectsBBoxProperty, "PreEffectsBBoxProperty") // nsRect*
 GK_ATOM(preTransformBBoxProperty, "PreTransformBBoxProperty") // nsRect*
 GK_ATOM(rowUnpaginatedHeightProperty, "RowUnpaginatedHeightProperty")  // nscoord*
 GK_ATOM(tabWidthProperty, "TabWidthProperty")              // nsTArray<TabSetting>* array of tab widths
 GK_ATOM(tableBCProperty, "TableBCProperty")                // table border collapsing info (e.g. damage area, table border widths)
+GK_ATOM(transitionsProperty, "TransitionsProperty")        // FrameTransitions*
 GK_ATOM(usedMarginProperty, "UsedMarginProperty") // nsMargin*
 GK_ATOM(usedPaddingProperty, "UsedPaddingProperty") // nsMargin*
 GK_ATOM(viewProperty, "ViewProperty")                      
 
 // Content property names
 GK_ATOM(genConInitializerProperty, "QuoteNodeProperty")
 GK_ATOM(labelMouseDownPtProperty, "LabelMouseDownPtProperty")
 
diff --git a/content/smil/Makefile.in b/content/smil/Makefile.in
--- a/content/smil/Makefile.in
+++ b/content/smil/Makefile.in
@@ -84,16 +84,17 @@ ifdef ENABLE_TESTS
 TOOL_DIRS		+= test
 endif
 
 EXPORTS		= \
 	  nsISMILAnimationElement.h \
 	  nsISMILAttr.h \
 	  nsSMILAnimationController.h \
 	  nsSMILCompositorTable.h \
+	  nsSMILKeySpline.h \
 	  nsSMILTimeContainer.h \
 	  nsSMILTypes.h \
 	  $(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
 INCLUDES += 	\
 		-I$(srcdir)/../base/src \
diff --git a/content/smil/nsSMILKeySpline.cpp b/content/smil/nsSMILKeySpline.cpp
--- a/content/smil/nsSMILKeySpline.cpp
+++ b/content/smil/nsSMILKeySpline.cpp
@@ -38,25 +38,27 @@
 #include "nsSMILKeySpline.h"
 #include <math.h>
 
 #define NEWTON_ITERATIONS   4
 
 const double nsSMILKeySpline::kSampleStepSize = 
                                         1.0 / double(kSplineTableSize - 1);
 
-nsSMILKeySpline::nsSMILKeySpline(double aX1,
-                                 double aY1,
-                                 double aX2,
-                                 double aY2)
-: mX1(aX1),
-  mY1(aY1),
-  mX2(aX2),
-  mY2(aY2)
+void
+nsSMILKeySpline::Init(double aX1,
+                      double aY1,
+                      double aX2,
+                      double aY2)
 {
+  mX1 = aX1;
+  mY1 = aY1;
+  mX2 = aX2;
+  mY2 = aY2;
+
   if (mX1 != mY1 || mX2 != mY2)
     CalcSampleValues();
 }
 
 double
 nsSMILKeySpline::GetSplineValue(double aX) const
 {
   if (mX1 == mY1 && mX2 == mY2)
diff --git a/content/smil/nsSMILKeySpline.h b/content/smil/nsSMILKeySpline.h
--- a/content/smil/nsSMILKeySpline.h
+++ b/content/smil/nsSMILKeySpline.h
@@ -41,24 +41,32 @@
 #include "prtypes.h"
 
 /**
  * Utility class to provide scaling defined in a keySplines element.
  */
 class nsSMILKeySpline
 {
 public:
+  nsSMILKeySpline() { /* caller must call Init later */ }
+
   /*
    * Create a new key spline control point description.
    *
    * aX1, etc. are the x1, y1, x2, y2 cubic Bezier control points as defined by
    * SMILANIM 3.2.3. They must each be in the range 0.0 <= x <= 1.0
    */
   nsSMILKeySpline(double aX1, double aY1,
-                  double aX2, double aY2);
+                  double aX2, double aY2)
+  {
+    Init(aX1, aY1, aX2, aY2);
+  }
+
+  void Init(double aX1, double aY1,
+            double aX2, double aY2);
 
   /*
    * Get the output (y) value for an input (x).
    *
    * x should be a floating-point number between 0 and 1 (inclusive).
    */
   double GetSplineValue(double aX) const;
 
@@ -88,20 +96,20 @@ private:
   }
 
   static double
   C(double aA1)
   {
     return 3.0 * aA1;
   }
 
-  const double         mX1;
-  const double         mY1;
-  const double         mX2;
-  const double         mY2;
+  double               mX1;
+  double               mY1;
+  double               mX2;
+  double               mY2;
 
   enum { kSplineTableSize = 11 };
   double               mSampleValues[kSplineTableSize];
 
   static const double  kSampleStepSize;
 };
 
 #endif // NS_SMILKEYSPLINE_H_
diff --git a/layout/base/Makefile.in b/layout/base/Makefile.in
--- a/layout/base/Makefile.in
+++ b/layout/base/Makefile.in
@@ -107,16 +107,17 @@ EXPORTS		= \
 		nsILayoutHistoryState.h \
 		nsIPercentHeightObserver.h  \
 		nsIPresShell.h \
 		nsIReflowCallback.h \
 		nsLayoutErrors.h \
 		nsLayoutUtils.h \
 		nsPresContext.h \
 		nsPresState.h \
+		nsRefreshDriver.h \
 		nsStyleChangeList.h \
 		nsStyleConsts.h \
 		$(NULL)
 
 CPPSRCS		= \
 		nsCSSColorUtils.cpp \
 		nsCSSFrameConstructor.cpp \
 		nsCSSRendering.cpp \
@@ -132,16 +133,17 @@ CPPSRCS		= \
 		nsImageLoader.cpp \
 		nsLayoutDebugger.cpp \
 		nsLayoutHistoryState.cpp \
 		nsLayoutUtils.cpp \
 		nsPresContext.cpp \
 		nsPresShell.cpp \
 		nsPresState.cpp \
 		nsQuoteList.cpp \
+		nsRefreshDriver.cpp \
 		nsStyleChangeList.cpp \
 		nsStyleSheetService.cpp \
 		$(NULL)
 
 ifndef MOZ_XUL
 XPIDLSRCS  += \
 		nsIBoxObject.idl \
 		$(NULL)
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -63,16 +63,17 @@ class nsIPresShell;
 class nsFrameManager;
 class nsIDOMHTMLSelectElement;
 class nsPresContext;
 class nsStyleChangeList;
 class nsIFrame;
 struct nsGenConInitializer;
 class ChildIterator;
 class nsICSSAnonBoxPseudo;
+class nsPageContentFrame;
 
 struct nsFindFrameHint
 {
   nsIFrame *mPrimaryFrameForPrevSibling;  // weak ref to the primary frame for the content for which we need a frame
   nsFindFrameHint() : mPrimaryFrameForPrevSibling(nsnull) { }
 };
 
 typedef void (nsLazyFrameConstructionCallback)
diff --git a/layout/base/nsFrameManager.cpp b/layout/base/nsFrameManager.cpp
--- a/layout/base/nsFrameManager.cpp
+++ b/layout/base/nsFrameManager.cpp
@@ -907,42 +907,42 @@ nsFrameManager::DebugVerifyStyleTree(nsI
     nsStyleContext* parentContext = context->GetParent();
     VerifyStyleTree(GetPresContext(), aFrame, parentContext);
   }
 }
 
 #endif // DEBUG
 
 nsresult
-nsFrameManager::ReParentStyleContext(nsIFrame* aFrame)
+nsFrameManager::DoReParentStyleContext(nsIFrame* aFrame)
 {
   if (nsGkAtoms::placeholderFrame == aFrame->GetType()) {
     // Also reparent the out-of-flow
     nsIFrame* outOfFlow =
       nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
     NS_ASSERTION(outOfFlow, "no out-of-flow frame");
 
-    ReParentStyleContext(outOfFlow);
+    DoReParentStyleContext(outOfFlow);
   }
 
   // DO NOT verify the style tree before reparenting.  The frame
   // tree has already been changed, so this check would just fail.
   nsStyleContext* oldContext = aFrame->GetStyleContext();
   // XXXbz can oldContext really ever be null?
   if (oldContext) {
     nsPresContext *presContext = GetPresContext();
     nsRefPtr<nsStyleContext> newContext;
     nsIFrame* providerFrame = nsnull;
     PRBool providerIsChild = PR_FALSE;
     nsIFrame* providerChild = nsnull;
     aFrame->GetParentStyleContextFrame(presContext, &providerFrame,
                                        &providerIsChild);
     nsStyleContext* newParentContext = nsnull;
     if (providerIsChild) {
-      ReParentStyleContext(providerFrame);
+      DoReParentStyleContext(providerFrame);
       newParentContext = providerFrame->GetStyleContext();
       providerChild = providerFrame;
     } else if (providerFrame) {
       newParentContext = providerFrame->GetStyleContext();
     } else {
       NS_NOTREACHED("Reparenting something that has no usable parent? "
                     "Shouldn't happen!");
     }
@@ -985,17 +985,17 @@ nsFrameManager::ReParentStyleContext(nsI
                   nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
                 NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
 
                 NS_ASSERTION(outOfFlowFrame != providerChild,
                              "Out of flow provider?");
               }
 #endif
 
-              ReParentStyleContext(child);
+              DoReParentStyleContext(child);
             }
 
             child = child->GetNextSibling();
           }
 
           childList = aFrame->GetAdditionalChildListName(listIndex++);
         } while (childList);
 
@@ -1004,17 +1004,17 @@ nsFrameManager::ReParentStyleContext(nsI
         // Reparent its style context just in case one of our ancestors
         // (split or not) hasn't done so already). It's not a problem to
         // reparent the same frame twice because the "if (newContext !=
         // oldContext)" check will prevent us from redoing work.
         if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
             !aFrame->GetPrevInFlow()) {
           nsIFrame* sib = static_cast<nsIFrame*>(aFrame->GetProperty(nsGkAtoms::IBSplitSpecialSibling));
           if (sib) {
-            ReParentStyleContext(sib);
+            DoReParentStyleContext(sib);
           }
         }
 
         // do additional contexts 
         PRInt32 contextIndex = -1;
         while (1) {
           nsStyleContext* oldExtraContext =
             aFrame->GetAdditionalStyleContext(++contextIndex);
@@ -1050,16 +1050,26 @@ nsFrameManager::ReParentStyleContext(nsI
         VerifyStyleTree(GetPresContext(), aFrame, newParentContext);
 #endif
       }
     }
   }
   return NS_OK;
 }
 
+nsresult
+nsFrameManager::ReParentStyleContext(nsIFrame* aFrame)
+{
+  nsresult rv = DoReParentStyleContext(aFrame);
+
+  GetPresContext()->TransitionManager()->DoneChangingStyles();
+
+  return rv;
+}
+
 static nsChangeHint
 CaptureChange(nsStyleContext* aOldContext, nsStyleContext* aNewContext,
               nsIFrame* aFrame, nsIContent* aContent,
               nsStyleChangeList* aChangeList, nsChangeHint aMinChange,
               nsChangeHint aChangeToAssume)
 {
   nsChangeHint ourChange = aOldContext->CalcStyleDifference(aNewContext);
   NS_UpdateHint(ourChange, aChangeToAssume);
@@ -1459,19 +1469,19 @@ nsFrameManager::ReResolveStyleContext(ns
     }
   }
 #endif
 
   return aMinChange;
 }
 
 void
-nsFrameManager::ComputeStyleChangeFor(nsIFrame          *aFrame, 
-                                      nsStyleChangeList *aChangeList,
-                                      nsChangeHint       aMinChange)
+nsFrameManager::DoComputeStyleChangeFor(nsIFrame          *aFrame, 
+                                        nsStyleChangeList *aChangeList,
+                                        nsChangeHint       aMinChange)
 {
   if (aMinChange) {
     aChangeList->AppendChange(aFrame, aFrame->GetContent(), aMinChange);
   }
 
   nsChangeHint topLevelChange = aMinChange;
 
   nsIFrame* frame = aFrame;
@@ -1513,16 +1523,25 @@ nsFrameManager::ComputeStyleChangeFor(ns
     }
     
     frame2 = static_cast<nsIFrame*>
                         (propTable->GetProperty(frame2, nsGkAtoms::IBSplitSpecialSibling));
     frame = frame2;
   } while (frame2);
 }
 
+void
+nsFrameManager::ComputeStyleChangeFor(nsIFrame          *aFrame, 
+                                      nsStyleChangeList *aChangeList,
+                                      nsChangeHint       aMinChange)
+{
+  DoComputeStyleChangeFor(aFrame, aChangeList, aMinChange);
+
+  GetPresContext()->TransitionManager()->DoneChangingStyles();
+}
 
 nsReStyleHint
 nsFrameManager::HasAttributeDependentStyle(nsIContent *aContent,
                                            nsIAtom *aAttribute,
                                            PRInt32 aModType,
                                            PRUint32 aStateMask)
 {
   nsReStyleHint hint = mStyleSet->HasAttributeDependentStyle(GetPresContext(),
diff --git a/layout/base/nsFrameManager.h b/layout/base/nsFrameManager.h
--- a/layout/base/nsFrameManager.h
+++ b/layout/base/nsFrameManager.h
@@ -236,11 +236,16 @@ public:
 
 private:
   NS_HIDDEN_(nsChangeHint)
     ReResolveStyleContext(nsPresContext    *aPresContext,
                           nsIFrame          *aFrame,
                           nsIContent        *aParentContent,
                           nsStyleChangeList *aChangeList, 
                           nsChangeHint       aMinChange);
+  NS_HIDDEN_(void)
+    DoComputeStyleChangeFor(nsIFrame* aFrame,
+                            nsStyleChangeList* aChangeList,
+                            nsChangeHint aMinChange);
+  NS_HIDDEN_(nsresult) DoReParentStyleContext(nsIFrame* aFrame);
 };
 
 #endif
diff --git a/layout/base/nsIPresShell.h b/layout/base/nsIPresShell.h
--- a/layout/base/nsIPresShell.h
+++ b/layout/base/nsIPresShell.h
@@ -385,16 +385,17 @@ public:
   NS_IMETHOD CancelAllPendingReflows() = 0;
 
   /**
    * Recreates the frames for a node
    */
   NS_IMETHOD RecreateFramesFor(nsIContent* aContent) = 0;
 
   void PostRecreateFramesFor(nsIContent* aContent);
+  void PostRestyleFor(nsIContent* aContent);
   
   /**
    * Determine if it is safe to flush all pending notifications
    * @param aIsSafeToFlush PR_TRUE if it is safe, PR_FALSE otherwise.
    * 
    */
   NS_IMETHOD IsSafeToFlush(PRBool& aIsSafeToFlush) = 0;
 
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -65,16 +65,18 @@
 #include "nsChangeHint.h"
 // This also pulls in gfxTypes.h, which we cannot include directly.
 #include "gfxRect.h"
 #include "nsRegion.h"
 #include "nsTArray.h"
 #include "nsAutoPtr.h"
 #include "nsThreadUtils.h"
 #include "nsContentUtils.h"
+#include "nsTransitionManager.h"
+#include "nsRefreshDriver.h"
 
 class nsImageLoader;
 #ifdef IBMBIDI
 class nsBidiPresUtils;
 #endif // IBMBIDI
 
 struct nsRect;
 
@@ -208,16 +210,33 @@ public:
       return mDocument;
   }
 
 #ifdef _IMPL_NS_LAYOUT
   nsStyleSet* StyleSet() { return GetPresShell()->StyleSet(); }
 
   nsFrameManager* FrameManager()
     { return GetPresShell()->FrameManager(); } 
+
+  nsTransitionManager* TransitionManager() { return &mTransitionManager; }
+
+  static nsPresContext* FromTransitionManager(
+                            nsTransitionManager* aTransitionManager) {
+    return reinterpret_cast<nsPresContext*>(
+             reinterpret_cast<char*>(aTransitionManager) -
+             offsetof(nsPresContext, mTransitionManager));
+  }
+
+  nsRefreshDriver* RefreshDriver() { return &mRefreshDriver; }
+
+  static nsPresContext* FromRefreshDriver(nsRefreshDriver* aRefreshDriver) {
+    return reinterpret_cast<nsPresContext*>(
+             reinterpret_cast<char*>(aRefreshDriver) -
+             offsetof(nsPresContext, mRefreshDriver));
+  }
 #endif
 
   /**
    * Rebuilds all style data by throwing out the old rule tree and
    * building a new one, and additionally applying aExtraHint (which
    * must not contain nsChangeHint_ReconstructFrame) to the root frame.
    * Also rebuild the user font set.
    */
@@ -813,16 +832,26 @@ public:
     return !mSameDocDirtyRegion.IsEmpty() || !mCrossDocDirtyRegion.IsEmpty();
   }
 
   void ClearMozAfterPaintEvents() {
     mSameDocDirtyRegion.SetEmpty();
     mCrossDocDirtyRegion.SetEmpty();
   }
 
+  PRBool IsProcessingAnimationStyleChange() const {
+    return mProcessingAnimationStyleChange;
+  }
+
+  void SetProcessingAnimationStyleChange(PRBool aProcessing) {
+    NS_ASSERTION(aProcessing != mProcessingAnimationStyleChange,
+                 "should never nest");
+    mProcessingAnimationStyleChange = aProcessing;
+  }
+
   /**
    * Notify the prescontext that the presshell is about to reflow a reflow root.
    * The single argument indicates whether this reflow should be interruptible.
    * If aInterruptible is false then CheckForInterrupt and HasPendingInterrupt
    * will always return false. If aInterruptible is true then CheckForInterrupt
    * will return true when a pending event is detected.  This is for use by the
    * presshell only.  Reflow code wanting to prevent interrupts should use
    * InterruptPreventer.
@@ -912,16 +941,18 @@ protected:
   nsCOMPtr<nsIDocument> mDocument;
   nsIDeviceContext*     mDeviceContext; // [STRONG] could be weak, but
                                         // better safe than sorry.
                                         // Cannot reintroduce cycles
                                         // since there is no dependency
                                         // from gfx back to layout.
   nsIEventStateManager* mEventManager;  // [STRONG]
   nsILookAndFeel*       mLookAndFeel;   // [STRONG]
+  nsRefreshDriver       mRefreshDriver;
+  nsTransitionManager   mTransitionManager;
   nsIAtom*              mMedium;        // initialized by subclass ctors;
                                         // weak pointer to static atom
 
   nsILinkHandler*       mLinkHandler;   // [WEAK]
   nsIAtom*              mLangGroup;     // [STRONG]
 
   nsRefPtrHashtable<nsVoidPtrHashKey, nsImageLoader>
                         mImageLoaders[IMAGE_LOAD_TYPE_COUNT];
@@ -1020,20 +1051,20 @@ protected:
   unsigned              mGetUserFontSetCalled : 1;
   // Do we currently have an event posted to call FlushUserFontSet?
   unsigned              mPostedFlushUserFontSet : 1;
 
   // resize reflow is supressed when the only change has been to zoom
   // the document rather than to change the document's dimensions
   unsigned              mSupressResizeReflow : 1;
 
-#ifdef IBMBIDI
   unsigned              mIsVisual : 1;
 
-#endif
+  unsigned              mProcessingAnimationStyleChange : 1;
+
 #ifdef DEBUG
   PRBool                mInitialized;
 #endif
 
 
 protected:
 
   ~nsPresContext() NS_HIDDEN;
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -3622,16 +3622,23 @@ PresShell::RecreateFramesFor(nsIContent*
 
 void
 nsIPresShell::PostRecreateFramesFor(nsIContent* aContent)
 {
   FrameConstructor()->PostRestyleEvent(aContent, eReStyle_Self,
           nsChangeHint_ReconstructFrame);
 }
 
+void
+nsIPresShell::PostRestyleFor(nsIContent* aContent)
+{
+  FrameConstructor()->PostRestyleEvent(aContent, eReStyle_Self,
+                                       NS_STYLE_HINT_NONE);
+}
+
 NS_IMETHODIMP
 PresShell::ClearFrameRefs(nsIFrame* aFrame)
 {
   mPresContext->EventStateManager()->ClearFrameRefs(aFrame);
   
   if (aFrame == mCurrentEventFrame) {
     mCurrentEventContent = aFrame->GetContent();
     mCurrentEventFrame = nsnull;
diff --git a/layout/base/nsRefreshDriver.cpp b/layout/base/nsRefreshDriver.cpp
new file mode 100644
--- /dev/null
+++ b/layout/base/nsRefreshDriver.cpp
@@ -0,0 +1,224 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsRefreshDriver.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * Code to notify things that animate before a refresh, at an appropriate
+ * refresh rate.  (Perhaps temporary, until replaced by compositor.)
+ */
+
+#include "nsRefreshDriver.h"
+#include "nsPresContext.h"
+#include "nsComponentManagerUtils.h"
+#include "prlog.h"
+
+/*
+ * TODO:
+ * Once this is hooked in to suppressing updates when the presentation
+ * is not visible, we need to hook it up to FlushPendingNotifications so
+ * that we flush when necessary.
+ */
+
+#define REFRESH_INTERVAL_MILLISECONDS 20
+
+using mozilla::TimeStamp;
+
+nsRefreshDriver::nsRefreshDriver()
+{
+}
+
+nsRefreshDriver::~nsRefreshDriver()
+{
+    NS_ABORT_IF_FALSE(ObserverCount() == 0,
+                      "observers should have unregistered");
+    NS_ABORT_IF_FALSE(!mTimer, "timer should be gone");
+}
+
+TimeStamp
+nsRefreshDriver::MostRecentRefresh() const
+{
+    if (!mTimer) {
+        const_cast<nsRefreshDriver*>(this)->StartTimer();
+    }
+
+    return mMostRecentRefresh;
+}
+
+PRBool
+nsRefreshDriver::AddRefreshObserver(nsARefreshObserver *aObserver,
+                                    mozFlushType aFlushType)
+{
+    nsTArray<nsARefreshObserver*>& array = ArrayFor(aFlushType);
+    PRBool success = array.AppendElement(aObserver) != nsnull;
+
+    if (!mTimer) {
+        StartTimer();
+    }
+
+    return success;
+}
+
+PRBool
+nsRefreshDriver::RemoveRefreshObserver(nsARefreshObserver *aObserver,
+                                       mozFlushType aFlushType)
+{
+    nsTArray<nsARefreshObserver*>& array = ArrayFor(aFlushType);
+    PRBool success = array.RemoveElement(aObserver);
+
+    if (ObserverCount() == 0) {
+        StopTimer();
+    }
+
+    return success;
+}
+
+void
+nsRefreshDriver::StartTimer()
+{
+    UpdateMostRecentRefresh();
+
+    mTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
+    if (!mTimer) {
+        return;
+    }
+
+    nsresult rv = mTimer->InitWithCallback(this, REFRESH_INTERVAL_MILLISECONDS,
+                                           nsITimer::TYPE_REPEATING_SLACK);
+    if (NS_FAILED(rv)) {
+        mTimer = nsnull;
+    }
+}
+
+void
+nsRefreshDriver::StopTimer()
+{
+    if (!mTimer) {
+        return;
+    }
+
+    mTimer->Cancel();
+    mTimer = nsnull;
+}
+
+PRUint32
+nsRefreshDriver::ObserverCount() const
+{
+    PRUint32 sum = 0;
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(mObservers); ++i) {
+        sum += mObservers[i].Length();
+    }
+    return sum;
+}
+
+void
+nsRefreshDriver::UpdateMostRecentRefresh()
+{
+    mMostRecentRefresh = TimeStamp::Now();
+}
+
+nsTArray<nsARefreshObserver*>&
+nsRefreshDriver::ArrayFor(mozFlushType aFlushType)
+{
+    switch (aFlushType) {
+        case Flush_Style:
+            return mObservers[0];
+        case Flush_Layout:
+            return mObservers[1];
+        case Flush_Display:
+            return mObservers[2];
+        default:
+            NS_ABORT_IF_FALSE(PR_FALSE, "bad flush type");
+            return *static_cast<nsTArray<nsARefreshObserver*>*>(nsnull);
+    }
+}
+
+/*
+ * nsISupports implementation
+ */
+
+NS_IMPL_ADDREF_USING_AGGREGATOR(nsRefreshDriver,
+                                nsPresContext::FromRefreshDriver(this))
+NS_IMPL_RELEASE_USING_AGGREGATOR(nsRefreshDriver,
+                                 nsPresContext::FromRefreshDriver(this))
+NS_IMPL_QUERY_INTERFACE1(nsRefreshDriver, nsITimerCallback)
+
+/*
+ * nsITimerCallback implementation
+ */
+
+NS_IMETHODIMP
+nsRefreshDriver::Notify(nsITimer *aTimer)
+{
+    UpdateMostRecentRefresh();
+
+    nsPresContext *presContext = nsPresContext::FromRefreshDriver(this);
+    nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();
+    if (!presShell) {
+        // Things are being destroyed.
+        StopTimer();
+        return NS_OK;
+    }
+
+    // Clone observers to deal with removal during notification.
+    nsTArray<nsARefreshObserver*> observers[3] = {
+      mObservers[0], mObservers[1], mObservers[2]
+    };
+    PR_STATIC_ASSERT(NS_ARRAY_LENGTH(observers) == NS_ARRAY_LENGTH(mObservers));
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(observers); ++i) {
+        if (i == 0) {
+            // This is the Flush_Style case.
+            presContext->SetProcessingAnimationStyleChange(PR_TRUE);
+        }
+        nsTArray<nsARefreshObserver*> array = observers[i];
+        for (PRUint32 j = 0, j_end = array.Length(); j < j_end; ++j) {
+            array[j]->WillRefresh(mMostRecentRefresh);
+        }
+        if (i == 0) {
+            // This is the Flush_Style case.
+            // FIXME: This is messy.  Maybe unroll the loop.
+            // FIXME: We should only flush if the WillRefresh calls did
+            // something.
+            presShell->FlushPendingNotifications(Flush_Style);
+            presContext->SetProcessingAnimationStyleChange(PR_FALSE);
+        }
+    }
+
+    if (ObserverCount() == 0) {
+        StopTimer();
+    }
+
+    return NS_OK;
+}
diff --git a/layout/base/nsRefreshDriver.h b/layout/base/nsRefreshDriver.h
new file mode 100644
--- /dev/null
+++ b/layout/base/nsRefreshDriver.h
@@ -0,0 +1,116 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsRefreshDriver.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * Code to notify things that animate before a refresh, at an appropriate
+ * refresh rate.  (Perhaps temporary, until replaced by compositor.)
+ */
+
+#ifndef nsRefreshDriver_h_
+#define nsRefreshDriver_h_
+
+#include "mozilla/TimeStamp.h"
+#include "mozFlushType.h"
+#include "nsITimer.h"
+#include "nsCOMPtr.h"
+#include "nsTArray.h"
+
+/**
+ * An abstract base class to be implemented by callers wanting to be
+ * notified at refresh times.  When nothing needs to be painted, callers
+ * may not be notified.
+ */
+class nsARefreshObserver {
+public:
+    virtual void WillRefresh(mozilla::TimeStamp aTime) = 0;
+};
+
+/*
+ * nsRefreshDriver MUST ONLY be constructed as a sub-object of
+ * nsPresContext (since its reference counting methods forward to the
+ * pres context of which it is an mRefreshDriver)
+ */
+class nsRefreshDriver : private nsITimerCallback {
+public:
+    nsRefreshDriver();
+    ~nsRefreshDriver();
+
+    /**
+     * Return the time of the most recent refresh.  This is intended to
+     * be used by callers who want to start an animation now and what to
+     * know what time to consider the start of the animation.  (This
+     * helps ensure that multiple animations started during the same
+     * event off the main event loop have the same start time.)
+     */
+    mozilla::TimeStamp MostRecentRefresh() const;
+
+    /**
+     * Add / remove refresh observers.  Returns whether the operation
+     * succeeded.
+     *
+     * The flush type affects:
+     *   + the order in which the observers are notified (lowest flush
+     *     type to highest, in order registered)
+     *   + which observers get notified when there is a flush during
+     *     times when we're not painting
+     * and it must be either Flush_Style, Flush_Layout, or Flush_Display.
+     */
+    PRBool AddRefreshObserver(nsARefreshObserver *aObserver,
+                              mozFlushType aFlushType);
+    PRBool RemoveRefreshObserver(nsARefreshObserver *aObserver,
+                                 mozFlushType aFlushType);
+private:
+    // nsISupports implementation
+    NS_DECL_ISUPPORTS_INHERITED
+
+    // nsITimerCallback implementation
+    NS_IMETHOD Notify(nsITimer *aTimer);
+
+    void StartTimer();
+    void StopTimer();
+    PRUint32 ObserverCount() const;
+    void UpdateMostRecentRefresh();
+    nsTArray<nsARefreshObserver*>& ArrayFor(mozFlushType aFlushType);
+
+    nsCOMPtr<nsITimer> mTimer;
+    mozilla::TimeStamp mMostRecentRefresh; // only valid when mTimer non-null
+
+    // separate arrays for each flush type we support
+    nsTArray<nsARefreshObserver*> mObservers[3];
+};
+
+#endif /* !defined(nsRefreshDriver_h_) */
diff --git a/layout/build/nsLayoutStatics.cpp b/layout/build/nsLayoutStatics.cpp
--- a/layout/build/nsLayoutStatics.cpp
+++ b/layout/build/nsLayoutStatics.cpp
@@ -80,16 +80,17 @@
 #include "nsCCUncollectableMarker.h"
 #include "nsTextFragment.h"
 #include "nsCSSRuleProcessor.h"
 #include "nsXMLHttpRequest.h"
 #include "nsDOMThreadService.h"
 #include "nsHTMLDNSPrefetch.h"
 #include "nsCrossSiteListenerProxy.h"
 #include "nsFocusManager.h"
+#include "nsTransitionManager.h"
 
 #ifdef MOZ_XUL
 #include "nsXULPopupManager.h"
 #include "nsXULContentUtils.h"
 #include "nsXULElement.h"
 #include "nsXULPrototypeCache.h"
 #include "nsXULTooltipListener.h"
 
@@ -271,16 +272,17 @@ nsLayoutStatics::Initialize()
   nsHTMLMediaElement::InitMediaTypes();
 #endif
 
 #ifdef MOZ_SYDNEYAUDIO
   nsAudioStream::InitLibrary();
 #endif
 
   nsCrossSiteListenerProxy::Startup();
+  nsTransitionManager::InitializeAnimationInfo();
 
   return NS_OK;
 }
 
 void
 nsLayoutStatics::Shutdown()
 {
   nsFocusManager::Shutdown();
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -95,16 +95,17 @@
 #include "nsStyleChangeList.h"
 #include "nsIDOMRange.h"
 #include "nsITableLayout.h"    //selection necessity
 #include "nsITableCellLayout.h"//  "
 #include "nsITextControlFrame.h"
 #include "nsINameSpaceManager.h"
 #include "nsIPercentHeightObserver.h"
 #include "nsStyleStructInlines.h"
+#include "nsCSSProps.h"
 
 #ifdef IBMBIDI
 #include "nsBidiPresUtils.h"
 #endif
 
 // For triple-click pref
 #include "nsIServiceManager.h"
 #include "imgIContainer.h"
@@ -569,16 +570,22 @@ nsFrame::DidSetStyleContext(nsStyleConte
 
   // If the page contains markup that overrides text direction, and
   // does not contain any characters that would activate the Unicode
   // bidi algorithm, we need to call |SetBidiEnabled| on the pres
   // context before reflow starts.  See bug 115921.
   if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
     PresContext()->SetBidiEnabled();
   }
+
+  if (aOldStyleContext) {
+    PresContext()->TransitionManager()->
+      StyleContextChanged(this, aOldStyleContext);
+  }
+  
 }
 
 /* virtual */ nsMargin
 nsIFrame::GetUsedMargin() const
 {
   NS_ASSERTION(nsLayoutUtils::sDisableGetUsedXAssertions ||
                !NS_SUBTREE_DIRTY(this) ||
                (GetStateBits() & NS_FRAME_IN_REFLOW),
diff --git a/layout/style/Makefile.in b/layout/style/Makefile.in
--- a/layout/style/Makefile.in
+++ b/layout/style/Makefile.in
@@ -121,16 +121,17 @@ EXPORTS		= \
 		nsStyleCoord.h \
 		nsStyleSet.h \
 		nsStyleStruct.h \
 		nsStyleStructFwd.h \
 		nsStyleStructInlines.h \
 		nsStyleStructList.h \
 		nsStyleTransformMatrix.h \
 		nsStyleUtil.h \
+		nsTransitionManager.h \
 		$(NULL)
 
 CPPSRCS		= \
 		nsCSSAnonBoxes.cpp \
 		nsCSSDataBlock.cpp \
 		nsCSSDeclaration.cpp \
 		nsCSSKeywords.cpp \
 		nsCSSLoader.cpp \
@@ -161,16 +162,17 @@ CPPSRCS		= \
 		nsROCSSPrimitiveValue.cpp \
 		nsRuleNode.cpp \
 		nsStyleContext.cpp \
 		nsStyleCoord.cpp \
 		nsStyleSet.cpp \
 		nsStyleStruct.cpp \
 		nsStyleTransformMatrix.cpp \
 		nsStyleUtil.cpp \
+		nsTransitionManager.cpp \
 		$(NULL)
 
 FORCE_STATIC_LIB = 1
 
 include $(topsrcdir)/config/rules.mk
 
 LOCAL_INCLUDES	= \
 		-I$(srcdir)/../../content/base/src \
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -116,16 +116,18 @@ nsStyleSet::Init(nsPresContext *aPresCon
 
   mRuleWalker = new nsRuleWalker(mRuleTree);
   if (!mRuleWalker) {
     mRuleTree->Destroy();
     mDefaultStyleData.Destroy(0, aPresContext);
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
+  GatherRuleProcessors(eTransitionSheet);
+
   return NS_OK;
 }
 
 nsresult
 nsStyleSet::BeginReconstruct()
 {
   NS_ASSERTION(!mInReconstruct, "Unmatched begin/end?");
   NS_ASSERTION(mRuleTree, "Reconstructing before first construction?");
@@ -204,16 +206,23 @@ nsStyleSet::GatherRuleProcessors(sheetTy
   mRuleProcessors[aType] = nsnull;
   if (mAuthorStyleDisabled && (aType == eDocSheet || 
                                aType == ePresHintSheet ||
                                aType == eHTMLPresHintSheet ||
                                aType == eStyleAttrSheet)) {
     //don't regather if this level is disabled
     return NS_OK;
   }
+  if (aType == eTransitionSheet) {
+    // We have no sheet for the transitions level; just a rule
+    // processor.  (XXX: We should probably do this for the other
+    // non-CSS levels too!)
+    mRuleProcessors[aType] = PresContext()->TransitionManager();
+    return NS_OK;
+  }
   if (mSheets[aType].Count()) {
     switch (aType) {
       case eAgentSheet:
       case eUserSheet:
       case eDocSheet:
       case eOverrideSheet: {
         // levels containing CSS stylesheets
         nsCOMArray<nsIStyleSheet>& sheets = mSheets[aType];
@@ -597,16 +606,20 @@ nsStyleSet::FileRules(nsIStyleRuleProces
   AddImportantRules(lastUserRN, lastPresHintRN); //user
 #ifdef DEBUG
   AssertNoCSSRules(lastPresHintRN, lastAgentRN);
   AssertNoImportantRules(lastPresHintRN, lastAgentRN); // preshints
 #endif
   mRuleWalker->SetLevel(eAgentSheet, PR_TRUE);
   AddImportantRules(lastAgentRN, nsnull);     //agent
 
+  mRuleWalker->SetLevel(eTransitionSheet, PR_FALSE);
+  if (mRuleProcessors[eTransitionSheet])
+    (*aCollectorFunc)(mRuleProcessors[eTransitionSheet], aData);
+
 }
 
 // Enumerate all the rules in a way that doesn't care about the order
 // of the rules and doesn't walk !important-rules.
 void
 nsStyleSet::WalkRuleProcessors(nsIStyleRuleProcessor::EnumFunc aFunc,
                                RuleProcessorData* aData)
 {
@@ -634,16 +647,18 @@ nsStyleSet::WalkRuleProcessors(nsIStyleR
   }
   if (!skipUserStyles && !cutOffInheritance &&
       mRuleProcessors[eDocSheet]) // NOTE: different
     (*aFunc)(mRuleProcessors[eDocSheet], aData);
   if (mRuleProcessors[eStyleAttrSheet])
     (*aFunc)(mRuleProcessors[eStyleAttrSheet], aData);
   if (mRuleProcessors[eOverrideSheet])
     (*aFunc)(mRuleProcessors[eOverrideSheet], aData);
+  if (mRuleProcessors[eTransitionSheet])
+    (*aFunc)(mRuleProcessors[eTransitionSheet], aData);
 }
 
 PRBool nsStyleSet::BuildDefaultStyleData(nsPresContext* aPresContext)
 {
   NS_ASSERTION(!mDefaultStyleData.mResetData &&
                !mDefaultStyleData.mInheritedData,
                "leaking default style data");
   mDefaultStyleData.mResetData = new (aPresContext) nsResetStyleData;
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -188,16 +188,17 @@ class nsStyleSet
   enum sheetType {
     eAgentSheet, // CSS
     ePresHintSheet,
     eUserSheet, // CSS
     eHTMLPresHintSheet,
     eDocSheet, // CSS
     eStyleAttrSheet,
     eOverrideSheet, // CSS
+    eTransitionSheet,
     eSheetTypeCount
     // be sure to keep the number of bits in |mDirty| below and in
     // NS_RULE_NODE_LEVEL_MASK updated when changing the number of sheet
     // types
   };
 
   // APIs to manipulate the style sheet lists.  The sheets in each
   // list are stored with the most significant sheet last.
@@ -331,13 +332,13 @@ class nsStyleSet
   // Old rule trees, which should only be non-empty between
   // BeginReconstruct and EndReconstruct, but in case of bugs that cause
   // style contexts to exist too long, may last longer.
   nsTArray<nsRuleNode*> mOldRuleTrees;
 
   unsigned mInShutdown : 1;
   unsigned mAuthorStyleDisabled: 1;
   unsigned mInReconstruct : 1;
-  unsigned mDirty : 7;  // one dirty bit is used per sheet type
+  unsigned mDirty : 8;  // one dirty bit is used per sheet type
 
 };
 
 #endif
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -1496,16 +1496,17 @@ nsChangeHint nsStyleDisplay::CalcDiffere
     for (PRUint8 index = 0; index < 2; ++index)
       if (mTransformOrigin[index] != aOther.mTransformOrigin[index]) {
         NS_UpdateHint(hint, NS_CombineHint(nsChangeHint_ReflowFrame,
                                            nsChangeHint_RepaintFrame));
         break;
       }
   }
   
+  // FIXME: Handle changes to transition properties.
   
   return hint;
 }
 
 #ifdef DEBUG
 /* static */
 nsChangeHint nsStyleDisplay::MaxDifference()
 {
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
new file mode 100644
--- /dev/null
+++ b/layout/style/nsTransitionManager.cpp
@@ -0,0 +1,881 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsTransitionManager.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/* Code to start and animate CSS transitions. */
+
+#include "nsTransitionManager.h"
+#include "nsIFrame.h"
+#include "nsCSSProps.h"
+#include "mozilla/TimeStamp.h"
+#include "nsRefreshDriver.h"
+#include "nsRuleProcessorData.h"
+#include "nsIStyleRule.h"
+#include "nsRuleWalker.h"
+#include "nsRuleData.h"
+#include "nsSMILKeySpline.h"
+
+using mozilla::TimeStamp;
+using mozilla::TimeDuration;
+
+/*****************************************************************************
+ * Per-CSS-property data                                                     *
+ *****************************************************************************/
+
+struct CSSPropertyAnimationInfo {
+  enum Type {
+    eCannotAnimate,
+    eStyleSides,
+    eStyleCoord,
+    eNsCoord
+  };
+
+  Type mType;
+  PRUint32 mIndex;
+};
+
+struct StyleSidesAnimationInfo {
+  typedef nsStyleSides location_type;
+
+  nsCSSProperty mProperty;
+  size_t mLocation;
+  PRUint8 mSide;
+};
+
+static const StyleSidesAnimationInfo gStyleSidesAnimInfo[] = {
+  { eCSSProperty_margin_top,
+    offsetof(nsStyleMargin, mMargin), NS_SIDE_TOP },
+  { eCSSProperty_margin_right_value,
+    offsetof(nsStyleMargin, mMargin), NS_SIDE_RIGHT },
+  { eCSSProperty_margin_bottom,
+    offsetof(nsStyleMargin, mMargin), NS_SIDE_BOTTOM },
+  { eCSSProperty_margin_left_value,
+    offsetof(nsStyleMargin, mMargin), NS_SIDE_LEFT },
+  { eCSSProperty_padding_top,
+    offsetof(nsStylePadding, mPadding), NS_SIDE_TOP },
+  { eCSSProperty_padding_right_value,
+    offsetof(nsStylePadding, mPadding), NS_SIDE_RIGHT },
+  { eCSSProperty_padding_bottom,
+    offsetof(nsStylePadding, mPadding), NS_SIDE_BOTTOM },
+  { eCSSProperty_padding_left_value,
+    offsetof(nsStylePadding, mPadding), NS_SIDE_LEFT },
+  { eCSSProperty_top,
+    offsetof(nsStylePosition, mOffset), NS_SIDE_TOP },
+  { eCSSProperty_right,
+    offsetof(nsStylePosition, mOffset), NS_SIDE_RIGHT },
+  { eCSSProperty_bottom,
+    offsetof(nsStylePosition, mOffset), NS_SIDE_BOTTOM },
+  { eCSSProperty_left,
+    offsetof(nsStylePosition, mOffset), NS_SIDE_LEFT }
+};
+
+struct StyleCoordAnimationInfo {
+  typedef nsStyleCoord location_type;
+
+  nsCSSProperty mProperty;
+  size_t mLocation;
+};
+
+// for animation length->length, percent->percent, or number->number
+static const StyleCoordAnimationInfo gStyleCoordAnimInfo[] = {
+  { eCSSProperty_outline_width, offsetof(nsStyleOutline, mOutlineWidth) },
+  { eCSSProperty_width, offsetof(nsStylePosition, mWidth) },
+  { eCSSProperty_min_width, offsetof(nsStylePosition, mMinWidth) },
+  { eCSSProperty_max_width, offsetof(nsStylePosition, mMaxWidth) },
+  { eCSSProperty_height, offsetof(nsStylePosition, mHeight) },
+  { eCSSProperty_min_height, offsetof(nsStylePosition, mMinHeight) },
+  { eCSSProperty_max_height, offsetof(nsStylePosition, mMaxHeight) },
+  { eCSSProperty_vertical_align, offsetof(nsStyleTextReset, mVerticalAlign) },
+  { eCSSProperty_letter_spacing, offsetof(nsStyleText, mLetterSpacing) },
+  { eCSSProperty_line_height, offsetof(nsStyleText, mLineHeight) },
+  { eCSSProperty_text_indent, offsetof(nsStyleText, mTextIndent) },
+  { eCSSProperty_marker_offset, offsetof(nsStyleContent, mMarkerOffset) },
+  { eCSSProperty__moz_column_width, offsetof(nsStyleColumn, mColumnWidth) },
+  { eCSSProperty__moz_column_gap, offsetof(nsStyleColumn, mColumnGap) },
+  { eCSSProperty_stroke_dashoffset, offsetof(nsStyleSVG, mStrokeDashoffset) },
+  { eCSSProperty_stroke_width, offsetof(nsStyleSVG, mStrokeWidth) }
+};
+
+struct NsCoordAnimationInfo {
+  typedef nscoord location_type;
+
+  nsCSSProperty mProperty;
+  size_t mLocation;
+};
+
+static const NsCoordAnimationInfo gNsCoordAnimInfo[] = {
+  { eCSSProperty_outline_offset, offsetof(nsStyleOutline, mOutlineOffset) },
+  { eCSSProperty_word_spacing, offsetof(nsStyleText, mWordSpacing) }
+};
+
+static CSSPropertyAnimationInfo gAnimInfo[eCSSProperty_COUNT_no_shorthands];
+
+// Have an "*Internal" version so a specialized form can call the
+// general form and then modify the result.
+template <class InfoType>
+static inline const typename InfoType::location_type&
+GetPropertyValueInternal(nsStyleContext *aStyleContext, const InfoType& aInfo)
+{
+    const void* styleStruct =
+      aStyleContext->GetStyleData(nsCSSProps::kSIDTable[aInfo.mProperty]);
+    return *reinterpret_cast<const typename InfoType::location_type*>(
+      reinterpret_cast<const char*>(styleStruct) + aInfo.mLocation);
+}
+
+// General version
+template <class InfoType>
+static inline const typename InfoType::location_type&
+GetPropertyValue(nsStyleContext *aStyleContext, const InfoType& aInfo)
+{
+    return GetPropertyValueInternal(aStyleContext, aInfo);
+}
+
+// Version specific to nsStyleSides.
+static inline nsStyleCoord
+GetPropertyValue(nsStyleContext *aStyleContext,
+                 const StyleSidesAnimationInfo& aInfo)
+{
+    return GetPropertyValueInternal(aStyleContext, aInfo).Get(aInfo.mSide);
+}
+
+template <class InfoType>
+static inline typename InfoType::location_type&
+GetSettablePropertyValue(void* aStyleStruct, const InfoType& aInfo)
+{
+    return *reinterpret_cast<typename InfoType::location_type*>(
+      reinterpret_cast<char*>(aStyleStruct) + aInfo.mLocation);
+}
+
+// General setter
+template <class InfoType>
+static inline void
+SetPropertyValue(void* aStyleStruct, const InfoType& aInfo,
+                 const typename InfoType::location_type& aValue)
+{
+    GetSettablePropertyValue(aStyleStruct, aInfo) = aValue;
+}
+
+// Setter specific to nsStyleSides.
+static inline void
+SetPropertyValue(void* aStyleStruct,
+                 const StyleSidesAnimationInfo& aInfo,
+                 const nsStyleCoord& aValue)
+{
+    GetSettablePropertyValue(aStyleStruct, aInfo).Set(aInfo.mSide, aValue);
+}
+
+/* static */ void
+nsTransitionManager::InitializeAnimationInfo()
+{
+  for (PRUint32 i = 0; i < eCSSProperty_COUNT_no_shorthands; ++i) {
+    gAnimInfo[i].mType = CSSPropertyAnimationInfo::eCannotAnimate;
+  }
+
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gStyleSidesAnimInfo); ++i) {
+    nsCSSProperty prop = gStyleSidesAnimInfo[i].mProperty;
+    NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(prop), "must be longhand");
+    gAnimInfo[prop].mType = CSSPropertyAnimationInfo::eStyleSides;
+    gAnimInfo[prop].mIndex = i;
+  }
+
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gStyleCoordAnimInfo); ++i) {
+    nsCSSProperty prop = gStyleCoordAnimInfo[i].mProperty;
+    NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(prop), "must be longhand");
+    gAnimInfo[prop].mType = CSSPropertyAnimationInfo::eStyleCoord;
+    gAnimInfo[prop].mIndex = i;
+  }
+
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gNsCoordAnimInfo); ++i) {
+    nsCSSProperty prop = gNsCoordAnimInfo[i].mProperty;
+    NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(prop), "must be longhand");
+    gAnimInfo[prop].mType = CSSPropertyAnimationInfo::eNsCoord;
+    gAnimInfo[prop].mIndex = i;
+  }
+}
+
+/*****************************************************************************
+ * Per-Frame data                                                            *
+ *****************************************************************************/
+
+union TransitionEndpoint
+{
+    nscoord mCoord;
+    float mPercent;
+};
+
+struct FramePropertyTransition
+{
+    nsCSSProperty mProperty;
+    nsStyleUnit mUnit; // valid when gAnimInfo[mProperty].mType is
+                       // eStyleSides or eStyleCoord
+    TransitionEndpoint mStartValue, mEndValue;
+    TimeStamp mStartTime; // actual start plus transition delay
+
+    // data from the relevant nsTransition
+    TimeDuration mDuration;
+    nsSMILKeySpline mTimingFunction;
+};
+
+class FrameTransitionsStyleRule : public nsIStyleRule
+{
+public:
+    // nsISupportsImplementation
+    NS_DECL_ISUPPORTS
+
+    // nsIStyleRule implementation
+    NS_IMETHOD MapRuleInfoInto(nsRuleData* aRuleData);
+#ifdef DEBUG
+    NS_IMETHOD List(FILE* out = stdout, PRInt32 aIndent = 0) const;
+#endif
+
+    FrameTransitionsStyleRule(FrameTransitions *aOwner,
+                              TimeStamp aRefreshTime)
+        : mFrameTransitions(aOwner)
+        , mRefreshTime(aRefreshTime)
+    {}
+
+    void Disconnect() { mFrameTransitions = nsnull; }
+
+    FrameTransitions *FrameData() { return mFrameTransitions; }
+    TimeStamp RefreshTime() { return mRefreshTime; }
+
+private:
+    FrameTransitions *mFrameTransitions;
+    // The time stamp for which this style rule is valid.
+    TimeStamp mRefreshTime;
+};
+
+struct FrameTransitions : public PRCList
+{
+    FrameTransitions(nsIFrame *aFrame)
+      : mFrame(aFrame)
+      // Save pres context now since we can't get it from the frame
+      // during property table destruction.
+      , mPresContext(aFrame->PresContext())
+    {
+        PR_INIT_CLIST(this);
+    }
+    ~FrameTransitions()
+    {
+        DropStyleRule();
+        PR_REMOVE_LINK(this);
+        mPresContext->TransitionManager()->TransitionsRemoved();
+    }
+
+    // Either zero or one for each CSS property:
+    nsTArray<FramePropertyTransition> mPropertyTransitions;
+
+    void DropStyleRule();
+    PRBool EnsureStyleRuleFor(TimeStamp aRefreshTime);
+
+    // The style rule for the transitions (which contains the time stamp
+    // for which it is valid).
+    nsRefPtr<FrameTransitionsStyleRule> mStyleRule;
+
+    nsIFrame *mFrame;
+    nsPresContext *mPresContext;
+};
+
+static void
+FrameTransitionsPropertyDtor(void           *aObject,
+                             nsIAtom        *aPropertyName,
+                             void           *aPropertyValue,
+                             void           *aData)
+{
+    FrameTransitions *ft = static_cast<FrameTransitions*>(aPropertyValue);
+    delete ft;
+}
+
+NS_IMPL_ISUPPORTS1(FrameTransitionsStyleRule, nsIStyleRule)
+
+static nsStyleCoord
+CoordFromPortion(const FramePropertyTransition &aPT,
+                 double aValuePortion)
+{
+    nsStyleCoord val;
+    if (aPT.mUnit == eStyleUnit_Coord) {
+        val.SetCoordValue(NSToCoordRound(
+          aPT.mStartValue.mCoord * (1.0 - aValuePortion) +
+          aPT.mEndValue.mCoord * aValuePortion));
+    } else {
+        NS_ABORT_IF_FALSE(aPT.mUnit == eStyleUnit_Percent,
+                          "unexpected unit");
+        val.SetPercentValue(
+          aPT.mStartValue.mPercent * (1.0 - aValuePortion) +
+          aPT.mEndValue.mPercent * aValuePortion);
+    }
+    return val;
+}
+
+static void
+FrameTransitionsPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData)
+{
+    // WARNING:  This makes the rather large assumption that the
+    // transitions style rule is the most specific rule.  The way
+    // nsStyleSet is written right now ensures that, but it's a pretty
+    // fragile dependency.
+    FrameTransitionsStyleRule *rule =
+        static_cast<FrameTransitionsStyleRule*>(
+            aRuleData->mStyleContext->GetRuleNode()->GetRule());
+    FrameTransitions *ft = rule->FrameData();
+    for (PRUint32 i = 0, i_end = ft->mPropertyTransitions.Length();
+         i < i_end; ++i)
+    {
+        FramePropertyTransition &pt = ft->mPropertyTransitions[i];
+        if (aRuleData->mSIDs & nsCachedStyleData::GetBitForSID(
+                                   nsCSSProps::kSIDTable[pt.mProperty]))
+        {
+            NS_ABORT_IF_FALSE(rule->RefreshTime() - pt.mStartTime <
+                                  pt.mDuration,
+                              "should have trimmed completed transition");
+            double timePortion =
+                (rule->RefreshTime() - pt.mStartTime).ToSeconds() /
+                pt.mDuration.ToSeconds();
+            if (timePortion < 0.0)
+                timePortion = 0.0; // use start value during transition-delay
+
+            double valuePortion =
+                pt.mTimingFunction.GetSplineValue(timePortion);
+
+            const CSSPropertyAnimationInfo& animInfo = gAnimInfo[pt.mProperty];
+            switch (animInfo.mType) {
+                case CSSPropertyAnimationInfo::eCannotAnimate: {
+                    NS_ABORT_IF_FALSE(PR_FALSE, "bad property");
+                    break;
+                }
+                case CSSPropertyAnimationInfo::eStyleSides: {
+                    const StyleSidesAnimationInfo& sidesInfo =
+                        gStyleSidesAnimInfo[animInfo.mIndex];
+                    SetPropertyValue(aStyleStruct, sidesInfo,
+                                     CoordFromPortion(pt, valuePortion));
+                    break;
+                }
+                case CSSPropertyAnimationInfo::eStyleCoord: {
+                    const StyleCoordAnimationInfo& coordInfo =
+                        gStyleCoordAnimInfo[animInfo.mIndex];
+                    SetPropertyValue(aStyleStruct, coordInfo,
+                                     CoordFromPortion(pt, valuePortion));
+                    break;
+                }
+                case CSSPropertyAnimationInfo::eNsCoord: {
+                    const NsCoordAnimationInfo& coordInfo =
+                        gNsCoordAnimInfo[animInfo.mIndex];
+                    nscoord val = NSToCoordRound(
+                      pt.mStartValue.mCoord * (1.0 - valuePortion) +
+                      pt.mEndValue.mCoord * valuePortion);
+                    SetPropertyValue(aStyleStruct, coordInfo, val);
+                    break;
+                }
+            }
+
+            if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Margin)) {
+                static_cast<nsStyleMargin*>(aStyleStruct)->RecalcData();
+            }
+            if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Padding)) {
+                static_cast<nsStylePadding*>(aStyleStruct)->RecalcData();
+            }
+        }
+    }
+}
+
+NS_IMETHODIMP
+FrameTransitionsStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
+{
+    FrameTransitions *ft = FrameData();
+    NS_ENSURE_TRUE(ft, NS_OK); // FIXME: Why can this be null?
+    for (PRUint32 i = 0, i_end = ft->mPropertyTransitions.Length();
+         i < i_end; ++i)
+    {
+        FramePropertyTransition &pt = ft->mPropertyTransitions[i];
+        if (aRuleData->mSIDs & nsCachedStyleData::GetBitForSID(
+                                   nsCSSProps::kSIDTable[pt.mProperty]))
+        {
+            aRuleData->mPostResolveCallback =
+                FrameTransitionsPostResolveCallback;
+            // This really doesn't matter much, since this ought to be
+            // the only node with the rule, but it's good practice for
+            // post-resolve callbacks.
+            aRuleData->mCanStoreInRuleTree = PR_FALSE;
+
+            return NS_OK;
+        }
+    }
+
+    return NS_OK;
+}
+
+#ifdef DEBUG
+NS_IMETHODIMP
+FrameTransitionsStyleRule::List(FILE* out, PRInt32 aIndent) const
+{
+    // WRITE ME?
+    return NS_OK;
+}
+#endif
+
+void
+FrameTransitions::DropStyleRule()
+{
+    if (mStyleRule) {
+        mStyleRule->Disconnect();
+        mStyleRule = nsnull;
+    }
+}
+
+PRBool
+FrameTransitions::EnsureStyleRuleFor(TimeStamp aRefreshTime)
+{
+    if (!mStyleRule || mStyleRule->RefreshTime() != aRefreshTime) {
+        DropStyleRule();
+
+        FrameTransitionsStyleRule *newRule =
+            new FrameTransitionsStyleRule(this, aRefreshTime);
+        if (!newRule) {
+            NS_WARNING("out of memory");
+            return PR_FALSE;
+        }
+
+        mStyleRule = newRule;
+    }
+
+    return PR_TRUE;
+}
+
+/*****************************************************************************
+ * nsTransitionManager                                                       *
+ *****************************************************************************/
+
+nsTransitionManager::nsTransitionManager()
+{
+    PR_INIT_CLIST(&mFrameTransitions);
+}
+
+nsTransitionManager::~nsTransitionManager()
+{
+    // This is essentially asserting that all frames have been destroyed
+    // before the pres context.
+    NS_ABORT_IF_FALSE(PR_CLIST_IS_EMPTY(&mFrameTransitions),
+                      "all transitions must be destroyed");
+}
+
+void
+nsTransitionManager::StyleContextChanged(nsIFrame *aFrame,
+                                         nsStyleContext *aOldStyleContext)
+{
+    if (aFrame->PresContext()->IsProcessingAnimationStyleChange()) {
+        return;
+    }
+
+    const nsStyleDisplay *disp = aFrame->GetStyleDisplay();
+    for (PRUint32 i = 0, i_end = disp->mTransitions.Length(); i < i_end; ++i) {
+        const nsTransition& t = disp->mTransitions[i];
+        // Check delay and duration first, since they default to zero, and
+        // when they're both zero, we can ignore the transition.
+        if (t.GetDelay() != 0.0f || t.GetDuration() != 0.0f) {
+            // We might have something to transition.  See if any of the
+            // properties in question changed and are animatable.
+            nsCSSProperty property = t.GetProperty();
+            if (property == eCSSPropertyExtra_no_properties ||
+                property == eCSSProperty_UNKNOWN) {
+                // Nothing to do, but need to exclude this from cases below.
+            } else if (property == eCSSPropertyExtra_all_properties) {
+                for (nsCSSProperty p = nsCSSProperty(0); 
+                     p < eCSSProperty_COUNT_no_shorthands;
+                     p = nsCSSProperty(p + 1)) {
+                    ConsiderStartingTransition(p, t, aFrame, aOldStyleContext);
+                }
+            } else if (nsCSSProps::IsShorthand(property)) {
+                CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(subprop, property) {
+                    ConsiderStartingTransition(*subprop, t, aFrame,
+                                               aOldStyleContext);
+                }
+            } else {
+                ConsiderStartingTransition(property, t, aFrame,
+                                           aOldStyleContext);
+            }
+        }
+    }
+}
+
+static PRBool
+ShouldAnimateStyleCoords(const nsStyleCoord& oldVal,
+                         const nsStyleCoord& newVal)
+{
+    return oldVal != newVal &&
+           oldVal.GetUnit() == newVal.GetUnit() &&
+           (oldVal.GetUnit() == eStyleUnit_Coord ||
+            oldVal.GetUnit() == eStyleUnit_Percent);
+}
+
+static void
+InitStyleCoordTransition(const nsStyleCoord& oldVal,
+                         const nsStyleCoord& newVal,
+                         FramePropertyTransition& t)
+{
+    NS_ABORT_IF_FALSE(oldVal.GetUnit() == newVal.GetUnit(),
+                      "should have been checked by ShouldAnimateStyleCoords");
+    t.mUnit = oldVal.GetUnit();
+    if (t.mUnit == eStyleUnit_Coord) {
+        t.mStartValue.mCoord = oldVal.GetCoordValue();
+        t.mEndValue.mCoord   = newVal.GetCoordValue();
+    } else {
+        NS_ABORT_IF_FALSE(t.mUnit == eStyleUnit_Percent,
+                          "unexpected unit");
+        t.mStartValue.mPercent = oldVal.GetPercentValue();
+        t.mEndValue.mPercent   = newVal.GetPercentValue();
+    }
+}
+
+void
+nsTransitionManager::ConsiderStartingTransition(nsCSSProperty aProperty,
+                       const nsTransition& aTransition, nsIFrame *aFrame,
+                       nsStyleContext *aOldStyleContext)
+{
+    // IsShorthand itself will assert if aProperty is not a property.
+    NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(aProperty),
+                      "property out of range");
+
+    const CSSPropertyAnimationInfo& animInfo = gAnimInfo[aProperty];
+
+    // FIXME: Adjust old value (how?) if there's currently a transition
+    // for this frame+property!
+    // FIXME: Check to see if aProperty has changed, and if it has, start
+    // a transition as appropriate (considering currently running
+    // transitions as appropriate).
+    // Do NOT compare to aOldStyleContext if we already have a transition
+    // going for this property (even if it hasn't moved yet).
+
+    FramePropertyTransition t;
+    switch (animInfo.mType) {
+        case CSSPropertyAnimationInfo::eCannotAnimate: {
+            return;
+        }
+        case CSSPropertyAnimationInfo::eStyleSides: {
+            const StyleSidesAnimationInfo& sidesInfo =
+                gStyleSidesAnimInfo[animInfo.mIndex];
+            const nsStyleCoord &oldVal =
+                GetPropertyValue(aOldStyleContext, sidesInfo);
+            const nsStyleCoord &newVal =
+                GetPropertyValue(aFrame->GetStyleContext(), sidesInfo);
+            if (!ShouldAnimateStyleCoords(oldVal, newVal)) {
+                return;
+            }
+            InitStyleCoordTransition(oldVal, newVal, t);
+            break;
+        }
+        case CSSPropertyAnimationInfo::eStyleCoord: {
+            const StyleCoordAnimationInfo& coordInfo =
+                gStyleCoordAnimInfo[animInfo.mIndex];
+            const nsStyleCoord &oldVal =
+                GetPropertyValue(aOldStyleContext, coordInfo);
+            const nsStyleCoord &newVal =
+                GetPropertyValue(aFrame->GetStyleContext(), coordInfo);
+            if (!ShouldAnimateStyleCoords(oldVal, newVal)) {
+                return;
+            }
+            InitStyleCoordTransition(oldVal, newVal, t);
+            break;
+        }
+        case CSSPropertyAnimationInfo::eNsCoord: {
+            const NsCoordAnimationInfo& coordInfo =
+                gNsCoordAnimInfo[animInfo.mIndex];
+            const nscoord &oldVal =
+                GetPropertyValue(aOldStyleContext, coordInfo);
+            const nscoord &newVal =
+                GetPropertyValue(aFrame->GetStyleContext(), coordInfo);
+            if (oldVal == newVal) {
+                return;
+            }
+            t.mStartValue.mCoord = oldVal;
+            t.mEndValue.mCoord   = newVal;
+            break;
+        }
+    }
+
+    nsRefreshDriver *rd = aFrame->PresContext()->RefreshDriver();
+
+    t.mProperty = aProperty;
+    t.mStartTime = rd->MostRecentRefresh() +
+                   TimeDuration::FromMilliseconds(aTransition.GetDelay());
+    t.mDuration = TimeDuration::FromMilliseconds(aTransition.GetDuration());
+    const nsTimingFunction &tf = aTransition.GetTimingFunction();
+    t.mTimingFunction.Init(tf.mX1, tf.mY1, tf.mX2, tf.mY2);
+
+    // Should we associate transitions with the frame or the content
+    // node?
+    //   + advantages of content:
+    //      - can transition when there's a framechange too (except it
+    //        would still be hard to figure out when a frame is new or
+    //        replacing something else)
+    //      - condenses work across continuations
+    //   + advantages of frame:
+    //      - deals with pseudo-elements and things inside
+    //        pseudo-elements better (though we could deal with
+    //        :before/:after elsewhere, which are the important ones,
+    //        but stuff inside :first-line is harder)
+    //      - avoids confusion when multiple frames per content node
+    // For now, I'll associate them with the frame.
+    //
+    // To get lifetime issues right, I'll store them in objects stored
+    // as a property on the frame which are themselves linked in a
+    // master list (or array?) so we can find all current transitions
+    // quickly.
+    // (Then we can take advantage of frame property destructors...
+    // although those don't necessarily need to call an actual
+    // destructor.)
+    
+    // FIXME: Only do this at most once per call to StyleContextChanged.
+    FrameTransitions *ft = static_cast<FrameTransitions*>(
+        aFrame->GetProperty(nsGkAtoms::transitionsProperty));
+    if (!ft) {
+        // FIXME: Consider arena-allocating?
+        ft = new FrameTransitions(aFrame);
+        if (!ft) {
+            NS_WARNING("out of memory");
+            return;
+        }
+        nsresult rv = aFrame->SetProperty(nsGkAtoms::transitionsProperty,
+                                          ft, FrameTransitionsPropertyDtor,
+                                          nsnull);
+        if (NS_FAILED(rv)) {
+            NS_WARNING("SetProperty failed");
+            delete ft;
+            return;
+        }
+
+        // DoneChangingStyles takes care of restyling immediately after
+        // finishing this subtree, with the transition-based style.
+        AddFrameTransitions(ft);
+    }
+
+    nsTArray<FramePropertyTransition> &pts = ft->mPropertyTransitions;
+    for (PRUint32 i = 0, i_end = pts.Length(); i < i_end; ++i) {
+        if (pts[i].mProperty == aProperty) {
+            // FIXME: We ought to have done something more interesting
+            // with the old transition for this property.
+            pts.RemoveElementAt(i);
+            break;
+        }
+    }
+
+#ifdef DEBUG
+    for (PRUint32 i = 0, i_end = pts.Length(); i < i_end; ++i) {
+        NS_ABORT_IF_FALSE(pts[i].mProperty != aProperty,
+                          "duplicate transitions for property");
+    }
+#endif
+
+    pts.AppendElement(t);
+}
+
+void
+nsTransitionManager::AddFrameTransitions(FrameTransitions* aFrameTransitions)
+{
+    if (PR_CLIST_IS_EMPTY(&mFrameTransitions)) {
+        // We need to observe the refresh driver.
+        nsRefreshDriver *rd = 
+            nsPresContext::FromTransitionManager(this)->RefreshDriver();
+        rd->AddRefreshObserver(this, Flush_Style);
+    }
+
+    PR_INSERT_BEFORE(aFrameTransitions, &mFrameTransitions);
+}
+
+void
+nsTransitionManager::DoneChangingStyles()
+{
+    // FIXME: What about things we flush here that were actually posted
+    // before this style change started?
+
+    // We want to flush two types of events that were posted during
+    // style reresolution:
+    //   (1) restyle events for transitions that we just started
+    //   (2) restyle events for elements that were already
+    //       transitioning, but for which we skipped the transition
+    //       style rule so that we could see if they needed a new
+    //       transition
+    nsPresContext *presContext = nsPresContext::FromTransitionManager(this);
+    if (!presContext->IsProcessingAnimationStyleChange())
+    {
+        presContext->SetProcessingAnimationStyleChange(PR_TRUE);
+        presContext->PresShell()->FlushPendingNotifications(Flush_Style);
+        presContext->SetProcessingAnimationStyleChange(PR_FALSE);
+    }
+}
+
+/*
+ * nsISupports implementation
+ */
+
+NS_IMPL_ADDREF_USING_AGGREGATOR(nsTransitionManager,
+                                nsPresContext::FromTransitionManager(this))
+NS_IMPL_RELEASE_USING_AGGREGATOR(nsTransitionManager,
+                                 nsPresContext::FromTransitionManager(this))
+NS_IMPL_QUERY_INTERFACE1(nsTransitionManager, nsIStyleRuleProcessor)
+
+/*
+ * nsIStyleRuleProcessor implementation
+ */
+
+static nsresult
+WalkTransitionRule(RuleProcessorData* aData)
+{
+    nsIFrame *aFrame = aData->mFrameForTransitions;
+    if (!aFrame) {
+        return NS_OK;
+    }
+
+    if (!aData->mPresContext->IsProcessingAnimationStyleChange()) {
+        // If we're processing a normal style change rather than one
+        // from animation, don't add the transition rule.  This allows
+        // us to compute the new style value rather than having the
+        // transition override it, so that we can start transitioning
+        // differently.
+        // FIXME: We need to immediately restyle with animation after
+        // doing this.
+        return NS_OK;
+    }
+
+    FrameTransitions *ft = static_cast<FrameTransitions*>(
+        aFrame->GetProperty(nsGkAtoms::transitionsProperty));
+    if (!ft) {
+        return NS_OK;
+    }
+
+    if (!ft->EnsureStyleRuleFor(
+               aData->mPresContext->RefreshDriver()->MostRecentRefresh())) {
+        return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    aData->mRuleWalker->Forward(ft->mStyleRule);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsTransitionManager::RulesMatching(ElementRuleProcessorData* aData)
+{
+    NS_ABORT_IF_FALSE(aData->mPresContext ==
+                        nsPresContext::FromTransitionManager(this),
+                      "pres context mismatch");
+    return WalkTransitionRule(aData);
+}
+
+NS_IMETHODIMP
+nsTransitionManager::RulesMatching(PseudoRuleProcessorData* aData)
+{
+    NS_ABORT_IF_FALSE(aData->mPresContext ==
+                        nsPresContext::FromTransitionManager(this),
+                      "pres context mismatch");
+    // Note:  If we're the only thing keeping a pseudo-element frame
+    // alive (per ProbePseudoStyleContext), we still want to keep it
+    // alive, so this is ok.
+    return WalkTransitionRule(aData);
+}
+
+NS_IMETHODIMP
+nsTransitionManager::HasStateDependentStyle(StateRuleProcessorData* aData,
+                                            nsReStyleHint* aResult)
+{
+    *aResult = nsReStyleHint(0);
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsTransitionManager::HasAttributeDependentStyle(AttributeRuleProcessorData* aData,
+                                                nsReStyleHint* aResult)
+{
+    *aResult = nsReStyleHint(0);
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsTransitionManager::MediumFeaturesChanged(nsPresContext* aPresContext,
+                                           PRBool* aRulesChanged)
+{
+    *aRulesChanged = PR_FALSE;
+    return NS_OK;
+}
+
+/* virtual */ void
+nsTransitionManager::WillRefresh(mozilla::TimeStamp aTime)
+{
+    nsPresContext *presContext = nsPresContext::FromTransitionManager(this);
+
+    // Trim transitions that have completed, and post restyle events for
+    // frames that are still transitioning.
+    {
+        PRCList *next = PR_LIST_HEAD(&mFrameTransitions);
+        while (next != &mFrameTransitions) {
+            FrameTransitions *ft = static_cast<FrameTransitions*>(next);
+            next = PR_NEXT_LINK(next);
+
+            PRUint32 i = ft->mPropertyTransitions.Length();
+            NS_ABORT_IF_FALSE(i != 0, "empty transitions list?");
+            do {
+                --i;
+                FramePropertyTransition &pt = ft->mPropertyTransitions[i];
+                if (pt.mStartTime + pt.mDuration <= aTime) {
+                    // This transition has completed.
+                    ft->mPropertyTransitions.RemoveElementAt(i);
+                }
+            } while (i != 0);
+
+            // We need to restyle even if the transition rule no longer
+            // applies, since we presumably just made it not apply.
+            presContext->PresShell()->PostRestyleFor(ft->mFrame->GetContent());
+
+            if (ft->mPropertyTransitions.IsEmpty()) {
+                ft->mFrame->DeleteProperty(nsGkAtoms::transitionsProperty);
+                // |ft| is now a dangling pointer!
+            }
+        }
+    }
+
+    // We might have removed transitions above.
+    TransitionsRemoved();
+}
+
+void
+nsTransitionManager::TransitionsRemoved()
+{
+    // If we have no transitions left, remove ourselves from the refresh
+    // driver.
+    if (PR_CLIST_IS_EMPTY(&mFrameTransitions)) {
+        nsPresContext *presContext = nsPresContext::FromTransitionManager(this);
+        presContext->RefreshDriver()->RemoveRefreshObserver(this, Flush_Style);
+    }
+}
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
new file mode 100644
--- /dev/null
+++ b/layout/style/nsTransitionManager.h
@@ -0,0 +1,98 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsTransitionManager.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/* Code to start and animate CSS transitions. */
+
+#ifndef nsTransitionManager_h_
+#define nsTransitionManager_h_
+
+#include "prclist.h"
+#include "nsCSSProperty.h"
+#include "nsIStyleRuleProcessor.h"
+#include "nsRefreshDriver.h"
+
+class nsIFrame;
+class nsStyleContext;
+struct nsTransition;
+struct FrameTransitions;
+
+/**
+ * Must be created only as a sub-object of an nsPresContext (since its
+ * reference counting methods assume that).
+ */
+class nsTransitionManager : public nsIStyleRuleProcessor,
+                            public nsARefreshObserver {
+public:
+    nsTransitionManager();
+    ~nsTransitionManager();
+
+    void StyleContextChanged(nsIFrame *aFrame,
+                             nsStyleContext *aOldStyleContext);
+    void DoneChangingStyles();
+
+    static void InitializeAnimationInfo();
+
+    // nsISupports
+    NS_DECL_ISUPPORTS_INHERITED
+
+    // nsIStyleRuleProcessor
+    NS_IMETHOD RulesMatching(ElementRuleProcessorData* aData);
+    NS_IMETHOD RulesMatching(PseudoRuleProcessorData* aData);
+    NS_IMETHOD HasStateDependentStyle(StateRuleProcessorData* aData,
+                                      nsReStyleHint* aResult);
+    NS_IMETHOD HasAttributeDependentStyle(AttributeRuleProcessorData* aData,
+                                          nsReStyleHint* aResult);
+    NS_IMETHOD MediumFeaturesChanged(nsPresContext* aPresContext,
+                                     PRBool* aRulesChanged);
+
+    // nsARefreshObserver
+    virtual void WillRefresh(mozilla::TimeStamp aTime);
+
+private:
+    friend class FrameTransitions; // for TransitionsRemoved
+
+    void ConsiderStartingTransition(nsCSSProperty aProperty,
+                                    const nsTransition& aTransition,
+                                    nsIFrame *aFrame,
+                                    nsStyleContext *aOldStyleContext);
+    void AddFrameTransitions(FrameTransitions* aFrameTransitions);
+    void TransitionsRemoved();
+
+    PRCList mFrameTransitions;
+};
+
+#endif /* !defined(nsTransitionManager_h_) */
diff --git a/xpcom/ds/TimeStamp.h b/xpcom/ds/TimeStamp.h
--- a/xpcom/ds/TimeStamp.h
+++ b/xpcom/ds/TimeStamp.h
@@ -206,16 +206,28 @@ public:
     NS_ASSERTION(!aOther.IsNull(), "Cannot compute with aOther null value");
     return mValue >= aOther.mValue;
   }
   PRBool operator>(const TimeStamp& aOther) const {
     NS_ASSERTION(!IsNull(), "Cannot compute with a null value");
     NS_ASSERTION(!aOther.IsNull(), "Cannot compute with aOther null value");
     return mValue > aOther.mValue;
   }
+  PRBool operator==(const TimeStamp& aOther) const {
+    // Maybe it's ok to check == with null timestamps?
+    NS_ASSERTION(!IsNull(), "Cannot compute with a null value");
+    NS_ASSERTION(!aOther.IsNull(), "Cannot compute with aOther null value");
+    return mValue == aOther.mValue;
+  }
+  PRBool operator!=(const TimeStamp& aOther) const {
+    // Maybe it's ok to check != with null timestamps?
+    NS_ASSERTION(!IsNull(), "Cannot compute with a null value");
+    NS_ASSERTION(!aOther.IsNull(), "Cannot compute with aOther null value");
+    return mValue != aOther.mValue;
+  }
 
   // Comparing TimeStamps for equality should be discouraged. Adding
   // two TimeStamps, or scaling TimeStamps, is nonsense and must never
   // be allowed.
 
   static NS_HIDDEN_(nsresult) Startup();
   static NS_HIDDEN_(void) Shutdown();
 
