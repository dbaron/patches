From: L. David Baron <dbaron@dbaron.org>

Implement CSS transitions:  handle starting and management of the animations.  (Bug 435441)

diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -512,16 +512,34 @@ EqualImages(imgIRequest *aOldImage, imgI
 
   nsCOMPtr<nsIURI> oldURI, newURI;
   aOldImage->GetURI(getter_AddRefs(oldURI));
   aNewImage->GetURI(getter_AddRefs(newURI));
   PRBool equal;
   return NS_SUCCEEDED(oldURI->Equals(newURI, &equal)) && equal;
 }
 
+static void
+ConsiderStartingTransition(nsCSSProperty aProperty,
+                           nsIFrame *aFrame,
+                           nsStyleContext *aOldStyleContext)
+{
+  // IsShorthand itself will assert if aProperty is not a property.
+  NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(aProperty),
+                    "property out of range");
+
+  if (!nsCSSProps::PropHasFlags(aProperty, CSS_PROPERTY_CAN_ANIMATE)) {
+    return;
+  }
+  
+  // FIXME: Check to see if aProperty has changed, and if it has, start
+  // a transition as appropriate (considering currently running
+  // transitions as appropriate).
+}
+
 // Subclass hook for style post processing
 /* virtual */ void
 nsFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
   if (aOldStyleContext) {
     // If the old context had a background image image and new context
     // does not have the same image, clear the image load notifier
     // (which keeps the image loading, if it still is) for the frame.
@@ -569,16 +587,45 @@ nsFrame::DidSetStyleContext(nsStyleConte
 
   // If the page contains markup that overrides text direction, and
   // does not contain any characters that would activate the Unicode
   // bidi algorithm, we need to call |SetBidiEnabled| on the pres
   // context before reflow starts.  See bug 115921.
   if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
     PresContext()->SetBidiEnabled();
   }
+
+  if (!PresContext()->ProcessingAnimationStyleChange()) {
+    const nsStyleDisplay *disp = GetStyleDisplay();
+    for (PRUint32 i = 0, i_end = disp->mTransitions.Length(); i < i_end; ++i) {
+      const nsTransition& t = disp->mTransitions[i];
+      // Check delay and duration first, since they default to zero, and
+      // when they're both zero, we can ignore the transition.
+      if (t.mDelay != 0.0f || t.mDuration != 0.0f) {
+        // We might have something to transition.  See if any of the
+        // properties in question changed and are animatable.
+        if (t.mProperty == eCSSPropertyExtra_no_properties ||
+                   t.mProperty == eCSSProperty_UNKNOWN) {
+          // Nothing to do, but need to exclude this from cases below.
+        } else if (t.mProperty == eCSSPropertyExtra_all_properties) {
+          for (nsCSSProperty p = nsCSSProperty(0); 
+               p < nsCSSProperty_COUNT_no_shorthands;
+               p = nsCSSProperty(p + 1)) {
+            ConsiderStartingTransition(p, this, aOldStyleContext);
+          }
+        } else if (nsCSSProps::IsShorthand(t.mProperty)) {
+          CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(p, t.mProperty) {
+            ConsiderStartingTransition(*p, this, aOldStyleContext);
+          }
+        } else {
+          ConsiderStartingTransition(t.mProperty, this, aOldStyleContext);
+        }
+      }
+    }
+  }
 }
 
 /* virtual */ nsMargin
 nsIFrame::GetUsedMargin() const
 {
   NS_ASSERTION(nsLayoutUtils::sDisableGetUsedXAssertions ||
                !NS_SUBTREE_DIRTY(this) ||
                (GetStateBits() & NS_FRAME_IN_REFLOW),
