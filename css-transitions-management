From: L. David Baron <dbaron@dbaron.org>

Implement CSS transitions:  handle starting and management of the animations.  (Bug 435441)

diff --git a/content/base/src/nsGkAtomList.h b/content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h
+++ b/content/base/src/nsGkAtomList.h
@@ -1659,16 +1659,17 @@ GK_ATOM(excessOverflowContainersProperty
 GK_ATOM(overflowLinesProperty, "OverflowLinesProperty")    // list of nsLineBox*
 GK_ATOM(overflowOutOfFlowsProperty, "OverflowOutOfFlowsProperty")      // nsFrameList*
 GK_ATOM(overflowPlaceholdersProperty, "OverflowPlaceholdersProperty")  // nsFrameList*
 GK_ATOM(preEffectsBBoxProperty, "PreEffectsBBoxProperty") // nsRect*
 GK_ATOM(preTransformBBoxProperty, "PreTransformBBoxProperty") // nsRect*
 GK_ATOM(rowUnpaginatedHeightProperty, "RowUnpaginatedHeightProperty")  // nscoord*
 GK_ATOM(tabWidthProperty, "TabWidthProperty")              // nsTArray<TabSetting>* array of tab widths
 GK_ATOM(tableBCProperty, "TableBCProperty")                // table border collapsing info (e.g. damage area, table border widths)
+GK_ATOM(transitionsProperty, "TransitionsProperty")        // FrameTransitions*
 GK_ATOM(usedMarginProperty, "UsedMarginProperty") // nsMargin*
 GK_ATOM(usedPaddingProperty, "UsedPaddingProperty") // nsMargin*
 GK_ATOM(viewProperty, "ViewProperty")                      
 
 // Content property names
 GK_ATOM(genConInitializerProperty, "QuoteNodeProperty")
 GK_ATOM(labelMouseDownPtProperty, "LabelMouseDownPtProperty")
 
diff --git a/layout/base/Makefile.in b/layout/base/Makefile.in
--- a/layout/base/Makefile.in
+++ b/layout/base/Makefile.in
@@ -107,16 +107,17 @@ EXPORTS		= \
 		nsILayoutHistoryState.h \
 		nsIPercentHeightObserver.h  \
 		nsIPresShell.h \
 		nsIReflowCallback.h \
 		nsLayoutErrors.h \
 		nsLayoutUtils.h \
 		nsPresContext.h \
 		nsPresState.h \
+		nsRefreshDriver.h \
 		nsStyleChangeList.h \
 		nsStyleConsts.h \
 		$(NULL)
 
 CPPSRCS		= \
 		nsCSSColorUtils.cpp \
 		nsCSSFrameConstructor.cpp \
 		nsCSSRendering.cpp \
@@ -132,16 +133,17 @@ CPPSRCS		= \
 		nsImageLoader.cpp \
 		nsLayoutDebugger.cpp \
 		nsLayoutHistoryState.cpp \
 		nsLayoutUtils.cpp \
 		nsPresContext.cpp \
 		nsPresShell.cpp \
 		nsPresState.cpp \
 		nsQuoteList.cpp \
+		nsRefreshDriver.cpp \
 		nsStyleChangeList.cpp \
 		nsStyleSheetService.cpp \
 		$(NULL)
 
 ifndef MOZ_XUL
 XPIDLSRCS  += \
 		nsIBoxObject.idl \
 		$(NULL)
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -65,16 +65,18 @@
 #include "nsChangeHint.h"
 // This also pulls in gfxTypes.h, which we cannot include directly.
 #include "gfxRect.h"
 #include "nsRegion.h"
 #include "nsTArray.h"
 #include "nsAutoPtr.h"
 #include "nsThreadUtils.h"
 #include "nsContentUtils.h"
+#include "nsTransitionManager.h"
+#include "nsRefreshDriver.h"
 
 class nsImageLoader;
 #ifdef IBMBIDI
 class nsBidiPresUtils;
 #endif // IBMBIDI
 
 struct nsRect;
 
@@ -208,16 +210,33 @@ public:
       return mDocument;
   }
 
 #ifdef _IMPL_NS_LAYOUT
   nsStyleSet* StyleSet() { return GetPresShell()->StyleSet(); }
 
   nsFrameManager* FrameManager()
     { return GetPresShell()->FrameManager(); } 
+
+  nsTransitionManager* TransitionManager() { return &mTransitionManager; }
+
+  static nsPresContext* FromTransitionManager(
+                            nsTransitionManager* aTransitionManager) {
+    return reinterpret_cast<nsPresContext*>(
+             reinterpret_cast<char*>(aTransitionManager) -
+             offsetof(nsPresContext, mTransitionManager));
+  }
+
+  nsRefreshDriver* RefreshDriver() { return &mRefreshDriver; }
+
+  static nsPresContext* FromRefreshDriver(nsRefreshDriver* aRefreshDriver) {
+    return reinterpret_cast<nsPresContext*>(
+             reinterpret_cast<char*>(aRefreshDriver) -
+             offsetof(nsPresContext, mRefreshDriver));
+  }
 #endif
 
   /**
    * Rebuilds all style data by throwing out the old rule tree and
    * building a new one, and additionally applying aExtraHint (which
    * must not contain nsChangeHint_ReconstructFrame) to the root frame.
    * Also rebuild the user font set.
    */
@@ -798,16 +817,26 @@ public:
     return !mSameDocDirtyRegion.IsEmpty() || !mCrossDocDirtyRegion.IsEmpty();
   }
 
   void ClearMozAfterPaintEvents() {
     mSameDocDirtyRegion.SetEmpty();
     mCrossDocDirtyRegion.SetEmpty();
   }
 
+  PRBool IsProcessingAnimationStyleChange() const {
+    return mProcessingAnimationStyleChange;
+  }
+
+  void SetProcessingAnimationStyleChange(PRBool aProcessing) {
+    NS_ASSERTION(aProcessing != mProcessingAnimationStyleChange,
+                 "should never nest");
+    mProcessingAnimationStyleChange = aProcessing;
+  }
+
   /**
    * Notify the prescontext that the presshell is about to reflow a reflow root.
    * The single argument indicates whether this reflow should be interruptible.
    * If aInterruptible is false then CheckForInterrupt and HasPendingInterrupt
    * will always return false. If aInterruptible is true then CheckForInterrupt
    * will return true when a pending event is detected.  This is for use by the
    * presshell only.  Reflow code wanting to prevent interrupts should use
    * InterruptPreventer.
@@ -897,16 +926,18 @@ protected:
   nsCOMPtr<nsIDocument> mDocument;
   nsIDeviceContext*     mDeviceContext; // [STRONG] could be weak, but
                                         // better safe than sorry.
                                         // Cannot reintroduce cycles
                                         // since there is no dependency
                                         // from gfx back to layout.
   nsIEventStateManager* mEventManager;  // [STRONG]
   nsILookAndFeel*       mLookAndFeel;   // [STRONG]
+  nsRefreshDriver       mRefreshDriver;
+  nsTransitionManager   mTransitionManager;
   nsIAtom*              mMedium;        // initialized by subclass ctors;
                                         // weak pointer to static atom
 
   nsILinkHandler*       mLinkHandler;   // [WEAK]
   nsIAtom*              mLangGroup;     // [STRONG]
 
   nsRefPtrHashtable<nsVoidPtrHashKey, nsImageLoader>
                         mImageLoaders[IMAGE_LOAD_TYPE_COUNT];
@@ -1005,20 +1036,20 @@ protected:
   unsigned              mGetUserFontSetCalled : 1;
   // Do we currently have an event posted to call FlushUserFontSet?
   unsigned              mPostedFlushUserFontSet : 1;
 
   // resize reflow is supressed when the only change has been to zoom
   // the document rather than to change the document's dimensions
   unsigned              mSupressResizeReflow : 1;
 
-#ifdef IBMBIDI
   unsigned              mIsVisual : 1;
 
-#endif
+  unsigned              mProcessingAnimationStyleChange : 1;
+
 #ifdef DEBUG
   PRBool                mInitialized;
 #endif
 
 
 protected:
 
   ~nsPresContext() NS_HIDDEN;
diff --git a/layout/base/nsRefreshDriver.cpp b/layout/base/nsRefreshDriver.cpp
new file mode 100644
--- /dev/null
+++ b/layout/base/nsRefreshDriver.cpp
@@ -0,0 +1,198 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsRefreshDriver.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * Code to notify things that animate before a refresh, at an appropriate
+ * refresh rate.  (Perhaps temporary, until replaced by compositor.)
+ */
+
+#include "nsRefreshDriver.h"
+#include "nsPresContext.h"
+#include "nsComponentManagerUtils.h"
+
+/*
+ * TODO:
+ * Once this is hooked in to suppressing updates when the presentation
+ * is not visible, we need to hook it up to FlushPendingNotifications so
+ * that we flush when necessary.
+ */
+
+#define REFRESH_INTERVAL_MILLISECONDS 20
+
+using mozilla::TimeStamp;
+
+nsRefreshDriver::nsRefreshDriver()
+{
+}
+
+nsRefreshDriver::~nsRefreshDriver()
+{
+    NS_ABORT_IF_FALSE(ObserverCount() == 0,
+                      "observers should have unregistered");
+    NS_ABORT_IF_FALSE(!mTimer, "timer should be gone");
+}
+
+TimeStamp
+nsRefreshDriver::MostRecentRefresh() const
+{
+    if (!mTimer) {
+        const_cast<nsRefreshDriver*>(this)->StartTimer();
+    }
+
+    return mMostRecentRefresh;
+}
+
+PRBool
+nsRefreshDriver::AddRefreshObserver(nsARefreshObserver *aObserver,
+                                    mozFlushType aFlushType)
+{
+    nsTArray<nsARefreshObserver*>& array = ArrayFor(aFlushType);
+    PRBool success = array.AppendElement(aObserver) != nsnull;
+
+    if (!mTimer) {
+        StartTimer();
+    }
+
+    return success;
+}
+
+PRBool
+nsRefreshDriver::RemoveRefreshObserver(nsARefreshObserver *aObserver,
+                                       mozFlushType aFlushType)
+{
+    nsTArray<nsARefreshObserver*>& array = ArrayFor(aFlushType);
+    PRBool success = array.RemoveElement(aObserver);
+
+    if (ObserverCount() == 0) {
+        StopTimer();
+    }
+
+    return success;
+}
+
+void
+nsRefreshDriver::StartTimer()
+{
+    UpdateMostRecentRefresh();
+
+    mTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
+    if (!mTimer) {
+        return;
+    }
+
+    nsresult rv = mTimer->InitWithCallback(this, REFRESH_INTERVAL_MILLISECONDS,
+                                           nsITimer::TYPE_REPEATING_SLACK);
+    if (NS_FAILED(rv)) {
+        mTimer = nsnull;
+    }
+}
+
+void
+nsRefreshDriver::StopTimer()
+{
+    if (!mTimer) {
+        return;
+    }
+
+    mTimer->Cancel();
+    mTimer = nsnull;
+}
+
+PRUint32
+nsRefreshDriver::ObserverCount() const
+{
+    PRUint32 sum = 0;
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(mObservers); ++i) {
+        sum += mObservers[i].Length();
+    }
+    return sum;
+}
+
+void
+nsRefreshDriver::UpdateMostRecentRefresh()
+{
+    mMostRecentRefresh = TimeStamp::Now();
+}
+
+nsTArray<nsARefreshObserver*>&
+nsRefreshDriver::ArrayFor(mozFlushType aFlushType)
+{
+    switch (aFlushType) {
+        case Flush_Style:
+            return mObservers[0];
+        case Flush_Layout:
+            return mObservers[1];
+        case Flush_Display:
+            return mObservers[2];
+        default:
+            NS_ABORT_IF_FALSE(PR_FALSE, "bad flush type");
+            return *static_cast<nsTArray<nsARefreshObserver*>*>(nsnull);
+    }
+}
+
+/*
+ * nsISupports implementation
+ */
+
+NS_IMPL_ADDREF_USING_AGGREGATOR(nsRefreshDriver,
+                                nsPresContext::FromRefreshDriver(this))
+NS_IMPL_RELEASE_USING_AGGREGATOR(nsRefreshDriver,
+                                 nsPresContext::FromRefreshDriver(this))
+NS_IMPL_QUERY_INTERFACE1(nsRefreshDriver, nsITimerCallback)
+
+/*
+ * nsITimerCallback implementation
+ */
+
+NS_IMETHODIMP
+nsRefreshDriver::Notify(nsITimer *aTimer)
+{
+    UpdateMostRecentRefresh();
+
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(mObservers); ++i) {
+        nsTArray<nsARefreshObserver*> array = mObservers[i];
+        for (PRUint32 j = 0, j_end = array.Length(); j < j_end; ++j) {
+            array[j]->WillRefresh(mMostRecentRefresh);
+        }
+    }
+
+    if (ObserverCount() == 0) {
+        StopTimer();
+    }
+
+    return NS_OK;
+}
diff --git a/layout/base/nsRefreshDriver.h b/layout/base/nsRefreshDriver.h
new file mode 100644
--- /dev/null
+++ b/layout/base/nsRefreshDriver.h
@@ -0,0 +1,116 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsRefreshDriver.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * Code to notify things that animate before a refresh, at an appropriate
+ * refresh rate.  (Perhaps temporary, until replaced by compositor.)
+ */
+
+#ifndef nsRefreshDriver_h_
+#define nsRefreshDriver_h_
+
+#include "mozilla/TimeStamp.h"
+#include "mozFlushType.h"
+#include "nsITimer.h"
+#include "nsCOMPtr.h"
+#include "nsTArray.h"
+
+/**
+ * An abstract base class to be implemented by callers wanting to be
+ * notified at refresh times.  When nothing needs to be painted, callers
+ * may not be notified.
+ */
+class nsARefreshObserver {
+public:
+    virtual void WillRefresh(mozilla::TimeStamp aTime) = 0;
+};
+
+/*
+ * nsRefreshDriver MUST ONLY be constructed as a sub-object of
+ * nsPresContext (since its reference counting methods forward to the
+ * pres context of which it is an mRefreshDriver)
+ */
+class nsRefreshDriver : private nsITimerCallback {
+public:
+    nsRefreshDriver();
+    ~nsRefreshDriver();
+
+    /**
+     * Return the time of the most recent refresh.  This is intended to
+     * be used by callers who want to start an animation now and what to
+     * know what time to consider the start of the animation.  (This
+     * helps ensure that multiple animations started during the same
+     * event off the main event loop have the same start time.)
+     */
+    mozilla::TimeStamp MostRecentRefresh() const;
+
+    /**
+     * Add / remove refresh observers.  Returns whether the operation
+     * succeeded.
+     *
+     * The flush type affects:
+     *   + the order in which the observers are notified (lowest flush
+     *     type to highest, in order registered)
+     *   + which observers get notified when there is a flush during
+     *     times when we're not painting
+     * and it must be either Flush_Style, Flush_Layout, or Flush_Display.
+     */
+    PRBool AddRefreshObserver(nsARefreshObserver *aObserver,
+                              mozFlushType aFlushType);
+    PRBool RemoveRefreshObserver(nsARefreshObserver *aObserver,
+                                 mozFlushType aFlushType);
+private:
+    // nsISupports implementation
+    NS_DECL_ISUPPORTS_INHERITED
+
+    // nsITimerCallback implementation
+    NS_IMETHOD Notify(nsITimer *aTimer);
+
+    void StartTimer();
+    void StopTimer();
+    PRUint32 ObserverCount() const;
+    void UpdateMostRecentRefresh();
+    nsTArray<nsARefreshObserver*>& ArrayFor(mozFlushType aFlushType);
+
+    nsCOMPtr<nsITimer> mTimer;
+    mozilla::TimeStamp mMostRecentRefresh; // only valid when mTimer non-null
+
+    // separate arrays for each flush type we support
+    nsTArray<nsARefreshObserver*> mObservers[3];
+};
+
+#endif /* !defined(nsRefreshDriver_h_) */
diff --git a/layout/build/nsLayoutStatics.cpp b/layout/build/nsLayoutStatics.cpp
--- a/layout/build/nsLayoutStatics.cpp
+++ b/layout/build/nsLayoutStatics.cpp
@@ -80,16 +80,17 @@
 #include "nsCCUncollectableMarker.h"
 #include "nsTextFragment.h"
 #include "nsCSSRuleProcessor.h"
 #include "nsXMLHttpRequest.h"
 #include "nsDOMThreadService.h"
 #include "nsHTMLDNSPrefetch.h"
 #include "nsCrossSiteListenerProxy.h"
 #include "nsFocusManager.h"
+#include "nsTransitionManager.h"
 
 #ifdef MOZ_XUL
 #include "nsXULPopupManager.h"
 #include "nsXULContentUtils.h"
 #include "nsXULElement.h"
 #include "nsXULPrototypeCache.h"
 #include "nsXULTooltipListener.h"
 
@@ -273,16 +274,17 @@ nsLayoutStatics::Initialize()
   nsHTMLMediaElement::InitMediaTypes();
 #endif
 
 #ifdef MOZ_SYDNEYAUDIO
   nsAudioStream::InitLibrary();
 #endif
 
   nsCrossSiteListenerProxy::Startup();
+  nsTransitionManager::InitializeAnimationInfo();
 
   return NS_OK;
 }
 
 void
 nsLayoutStatics::Shutdown()
 {
   nsFocusManager::Shutdown();
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -95,16 +95,17 @@
 #include "nsStyleChangeList.h"
 #include "nsIDOMRange.h"
 #include "nsITableLayout.h"    //selection necessity
 #include "nsITableCellLayout.h"//  "
 #include "nsITextControlFrame.h"
 #include "nsINameSpaceManager.h"
 #include "nsIPercentHeightObserver.h"
 #include "nsStyleStructInlines.h"
+#include "nsCSSProps.h"
 
 #ifdef IBMBIDI
 #include "nsBidiPresUtils.h"
 #endif
 
 // For triple-click pref
 #include "nsIServiceManager.h"
 #include "imgIContainer.h"
@@ -569,16 +570,22 @@ nsFrame::DidSetStyleContext(nsStyleConte
 
   // If the page contains markup that overrides text direction, and
   // does not contain any characters that would activate the Unicode
   // bidi algorithm, we need to call |SetBidiEnabled| on the pres
   // context before reflow starts.  See bug 115921.
   if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
     PresContext()->SetBidiEnabled();
   }
+
+  if (aOldStyleContext) {
+    PresContext()->TransitionManager()->
+      StyleContextChanged(this, aOldStyleContext);
+  }
+  
 }
 
 /* virtual */ nsMargin
 nsIFrame::GetUsedMargin() const
 {
   NS_ASSERTION(nsLayoutUtils::sDisableGetUsedXAssertions ||
                !NS_SUBTREE_DIRTY(this) ||
                (GetStateBits() & NS_FRAME_IN_REFLOW),
diff --git a/layout/style/Makefile.in b/layout/style/Makefile.in
--- a/layout/style/Makefile.in
+++ b/layout/style/Makefile.in
@@ -121,16 +121,17 @@ EXPORTS		= \
 		nsStyleCoord.h \
 		nsStyleSet.h \
 		nsStyleStruct.h \
 		nsStyleStructFwd.h \
 		nsStyleStructInlines.h \
 		nsStyleStructList.h \
 		nsStyleTransformMatrix.h \
 		nsStyleUtil.h \
+		nsTransitionManager.h \
 		$(NULL)
 
 CPPSRCS		= \
 		nsCSSAnonBoxes.cpp \
 		nsCSSDataBlock.cpp \
 		nsCSSDeclaration.cpp \
 		nsCSSKeywords.cpp \
 		nsCSSLoader.cpp \
@@ -161,16 +162,17 @@ CPPSRCS		= \
 		nsROCSSPrimitiveValue.cpp \
 		nsRuleNode.cpp \
 		nsStyleContext.cpp \
 		nsStyleCoord.cpp \
 		nsStyleSet.cpp \
 		nsStyleStruct.cpp \
 		nsStyleTransformMatrix.cpp \
 		nsStyleUtil.cpp \
+		nsTransitionManager.cpp \
 		$(NULL)
 
 FORCE_STATIC_LIB = 1
 
 include $(topsrcdir)/config/rules.mk
 
 LOCAL_INCLUDES	= \
 		-I$(srcdir)/../../content/base/src \
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -948,16 +948,18 @@ private:
 };
 
 struct nsTransition {
   nsTransition() { /* leaves uninitialized; see also SetInitialValues */ }
   explicit nsTransition(const nsTransition& aCopy);
 
   void SetInitialValues();
 
+  // Delay and Duration are in milliseconds
+
   nsTimingFunction& GetTimingFunction() { return mTimingFunction; }
   const nsTimingFunction& GetTimingFunction() const { return mTimingFunction; }
   float GetDelay() const { return mDelay; }
   float GetDuration() const { return mDuration; }
   nsCSSProperty GetProperty() const { return mProperty; }
   nsIAtom* GetUnknownProperty() const { return mUnknownProperty; }
 
   void SetTimingFunction(const nsTimingFunction& aTimingFunction)
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
new file mode 100644
--- /dev/null
+++ b/layout/style/nsTransitionManager.cpp
@@ -0,0 +1,509 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsTransitionManager.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/* Code to start and animate CSS transitions. */
+
+#include "nsTransitionManager.h"
+#include "nsIFrame.h"
+#include "nsCSSProps.h"
+#include "mozilla/TimeStamp.h"
+#include "nsRefreshDriver.h"
+#include "nsRuleProcessorData.h"
+
+using mozilla::TimeStamp;
+using mozilla::TimeDuration;
+
+/*****************************************************************************
+ * Per-CSS-property data                                                     *
+ *****************************************************************************/
+
+struct CSSPropertyAnimationInfo {
+  enum Type {
+    eCannotAnimate,
+    eStyleSides,
+    eStyleCoord,
+    eNsCoord
+  };
+
+  Type mType;
+  PRUint32 mIndex;
+};
+
+struct StyleSidesAnimationInfo {
+  typedef nsStyleSides location_type;
+
+  nsCSSProperty mProperty;
+  size_t mLocation;
+  PRUint8 mSide;
+};
+
+static const StyleSidesAnimationInfo gStyleSidesAnimInfo[] = {
+  { eCSSProperty_margin_top,
+    offsetof(nsStyleMargin, mMargin), NS_SIDE_TOP },
+  { eCSSProperty_margin_right,
+    offsetof(nsStyleMargin, mMargin), NS_SIDE_RIGHT },
+  { eCSSProperty_margin_bottom,
+    offsetof(nsStyleMargin, mMargin), NS_SIDE_BOTTOM },
+  { eCSSProperty_margin_left,
+    offsetof(nsStyleMargin, mMargin), NS_SIDE_LEFT },
+  { eCSSProperty_padding_top,
+    offsetof(nsStylePadding, mPadding), NS_SIDE_TOP },
+  { eCSSProperty_padding_right,
+    offsetof(nsStylePadding, mPadding), NS_SIDE_RIGHT },
+  { eCSSProperty_padding_bottom,
+    offsetof(nsStylePadding, mPadding), NS_SIDE_BOTTOM },
+  { eCSSProperty_padding_left,
+    offsetof(nsStylePadding, mPadding), NS_SIDE_LEFT },
+  { eCSSProperty_top,
+    offsetof(nsStylePosition, mOffset), NS_SIDE_TOP },
+  { eCSSProperty_right,
+    offsetof(nsStylePosition, mOffset), NS_SIDE_RIGHT },
+  { eCSSProperty_bottom,
+    offsetof(nsStylePosition, mOffset), NS_SIDE_BOTTOM },
+  { eCSSProperty_left,
+    offsetof(nsStylePosition, mOffset), NS_SIDE_LEFT }
+};
+
+struct StyleCoordAnimationInfo {
+  typedef nsStyleCoord location_type;
+
+  nsCSSProperty mProperty;
+  size_t mLocation;
+};
+
+// for animation length->length, percent->percent, or number->number
+static const StyleCoordAnimationInfo gStyleCoordAnimInfo[] = {
+  { eCSSProperty_outline_width, offsetof(nsStyleOutline, mOutlineWidth) },
+  { eCSSProperty_width, offsetof(nsStylePosition, mWidth) },
+  { eCSSProperty_min_width, offsetof(nsStylePosition, mMinWidth) },
+  { eCSSProperty_max_width, offsetof(nsStylePosition, mMaxWidth) },
+  { eCSSProperty_height, offsetof(nsStylePosition, mHeight) },
+  { eCSSProperty_min_height, offsetof(nsStylePosition, mMinHeight) },
+  { eCSSProperty_max_height, offsetof(nsStylePosition, mMaxHeight) },
+  { eCSSProperty_vertical_align, offsetof(nsStyleTextReset, mVerticalAlign) },
+  { eCSSProperty_letter_spacing, offsetof(nsStyleText, mLetterSpacing) },
+  { eCSSProperty_line_height, offsetof(nsStyleText, mLineHeight) },
+  { eCSSProperty_text_indent, offsetof(nsStyleText, mTextIndent) },
+  { eCSSProperty_marker_offset, offsetof(nsStyleContent, mMarkerOffset) },
+  { eCSSProperty__moz_column_width, offsetof(nsStyleColumn, mColumnWidth) },
+  { eCSSProperty__moz_column_gap, offsetof(nsStyleColumn, mColumnGap) },
+  { eCSSProperty_stroke_dashoffset, offsetof(nsStyleSVG, mStrokeDashoffset) },
+  { eCSSProperty_stroke_width, offsetof(nsStyleSVG, mStrokeWidth) }
+};
+
+struct NsCoordAnimationInfo {
+  typedef nscoord location_type;
+
+  nsCSSProperty mProperty;
+  size_t mLocation;
+};
+
+static const NsCoordAnimationInfo gNsCoordAnimInfo[] = {
+  { eCSSProperty_outline_offset, offsetof(nsStyleOutline, mOutlineOffset) },
+  { eCSSProperty_word_spacing, offsetof(nsStyleText, mWordSpacing) }
+};
+
+static CSSPropertyAnimationInfo gAnimInfo[eCSSProperty_COUNT_no_shorthands];
+
+// Have an "*Internal" version so a specialized form can call the
+// general form and then modify the result.
+template <class InfoType>
+static inline const typename InfoType::location_type&
+GetPropertyValueInternal(nsStyleContext *aStyleContext, const InfoType& aInfo)
+{
+    const void* styleStruct =
+      aStyleContext->GetStyleData(nsCSSProps::kSIDTable[aInfo.mProperty]);
+    return *reinterpret_cast<const typename InfoType::location_type*>(
+      reinterpret_cast<const char*>(styleStruct) + aInfo.mLocation);
+}
+
+// General version
+template <class InfoType>
+static inline const typename InfoType::location_type&
+GetPropertyValue(nsStyleContext *aStyleContext, const InfoType& aInfo)
+{
+    return GetPropertyValueInternal(aStyleContext, aInfo);
+}
+
+// Version specific to nsStyleSides.
+static inline nsStyleCoord
+GetPropertyValue(nsStyleContext *aStyleContext,
+                 const StyleSidesAnimationInfo& aInfo)
+{
+    return GetPropertyValueInternal(aStyleContext, aInfo).Get(aInfo.mSide);
+}
+
+/* static */ void
+nsTransitionManager::InitializeAnimationInfo()
+{
+  for (PRUint32 i = 0; i < eCSSProperty_COUNT_no_shorthands; ++i) {
+    gAnimInfo[i].mType = CSSPropertyAnimationInfo::eCannotAnimate;
+  }
+
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gStyleSidesAnimInfo); ++i) {
+    nsCSSProperty prop = gStyleSidesAnimInfo[i].mProperty;
+    gAnimInfo[prop].mType = CSSPropertyAnimationInfo::eStyleSides;
+    gAnimInfo[prop].mIndex = i;
+  }
+
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gStyleCoordAnimInfo); ++i) {
+    nsCSSProperty prop = gStyleCoordAnimInfo[i].mProperty;
+    gAnimInfo[prop].mType = CSSPropertyAnimationInfo::eStyleCoord;
+    gAnimInfo[prop].mIndex = i;
+  }
+
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gNsCoordAnimInfo); ++i) {
+    nsCSSProperty prop = gNsCoordAnimInfo[i].mProperty;
+    gAnimInfo[prop].mType = CSSPropertyAnimationInfo::eNsCoord;
+    gAnimInfo[prop].mIndex = i;
+  }
+}
+
+/*****************************************************************************
+ * Per-Frame data                                                            *
+ *****************************************************************************/
+
+union TransitionEndpoint {
+    nscoord mCoord;
+    float mPercent;
+};
+
+struct FramePropertyTransition {
+    nsCSSProperty mProperty;
+    nsStyleUnit mUnit; // valid when gAnimInfo[mProperty].mType is
+                       // eStyleSides or eStyleCoord
+    TransitionEndpoint mStartValue, mEndValue;
+    TimeStamp mStartTime;
+
+    // data from the relevant nsTransition
+    TimeDuration mDelay, mDuration;
+    nsTimingFunction mTimingFunction;
+};
+
+struct FrameTransitions : public PRCList {
+    FrameTransitions() { PR_INIT_CLIST(this); }
+    ~FrameTransitions() { PR_REMOVE_LINK(this); }
+
+    // Either zero or one for each CSS property:
+    nsTArray<FramePropertyTransition> mPropertyTransitions;
+};
+
+static void
+FrameTransitionsPropertyDtor(void           *aObject,
+                             nsIAtom        *aPropertyName,
+                             void           *aPropertyValue,
+                             void           *aData)
+{
+    FrameTransitions *ft = static_cast<FrameTransitions*>(aPropertyValue);
+    delete ft;
+}
+
+/*****************************************************************************
+ * nsTransitionManager                                                       *
+ *****************************************************************************/
+
+nsTransitionManager::nsTransitionManager()
+{
+    PR_INIT_CLIST(&mFrameTransitions);
+}
+
+nsTransitionManager::~nsTransitionManager()
+{
+    // This is essentially asserting that all frames have been destroyed
+    // before the pres context.
+    NS_ABORT_IF_FALSE(PR_CLIST_IS_EMPTY(&mFrameTransitions),
+                      "all transitions must be destroyed");
+}
+
+void
+nsTransitionManager::StyleContextChanged(nsIFrame *aFrame,
+                                         nsStyleContext *aOldStyleContext)
+{
+    if (aFrame->PresContext()->IsProcessingAnimationStyleChange()) {
+        return;
+    }
+
+    const nsStyleDisplay *disp = aFrame->GetStyleDisplay();
+    for (PRUint32 i = 0, i_end = disp->mTransitions.Length(); i < i_end; ++i) {
+        const nsTransition& t = disp->mTransitions[i];
+        // Check delay and duration first, since they default to zero, and
+        // when they're both zero, we can ignore the transition.
+        if (t.GetDelay() != 0.0f || t.GetDuration() != 0.0f) {
+            // We might have something to transition.  See if any of the
+            // properties in question changed and are animatable.
+            nsCSSProperty property = t.GetProperty();
+            if (property == eCSSPropertyExtra_no_properties ||
+                property == eCSSProperty_UNKNOWN) {
+                // Nothing to do, but need to exclude this from cases below.
+            } else if (property == eCSSPropertyExtra_all_properties) {
+                for (nsCSSProperty p = nsCSSProperty(0); 
+                     p < eCSSProperty_COUNT_no_shorthands;
+                     p = nsCSSProperty(p + 1)) {
+                    ConsiderStartingTransition(p, t, aFrame, aOldStyleContext);
+                }
+            } else if (nsCSSProps::IsShorthand(property)) {
+                CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(subprop, property) {
+                    ConsiderStartingTransition(*subprop, t, aFrame,
+                                               aOldStyleContext);
+                }
+            } else {
+                ConsiderStartingTransition(property, t, aFrame,
+                                           aOldStyleContext);
+            }
+        }
+    }
+}
+
+static PRBool
+ShouldAnimateStyleCoords(const nsStyleCoord& oldVal,
+                         const nsStyleCoord& newVal)
+{
+    return oldVal != newVal &&
+           oldVal.GetUnit() == newVal.GetUnit() &&
+           (oldVal.GetUnit() == eStyleUnit_Coord ||
+            oldVal.GetUnit() == eStyleUnit_Percent);
+}
+
+static void
+InitStyleCoordTransition(const nsStyleCoord& oldVal,
+                         const nsStyleCoord& newVal,
+                         FramePropertyTransition& t)
+{
+    NS_ABORT_IF_FALSE(oldVal.GetUnit() == newVal.GetUnit(),
+                      "should have been checked by ShouldAnimateStyleCoords");
+    t.mUnit = oldVal.GetUnit();
+    if (t.mUnit == eStyleUnit_Coord) {
+        t.mStartValue.mCoord = oldVal.GetCoordValue();
+        t.mEndValue.mCoord   = newVal.GetCoordValue();
+    } else {
+        NS_ABORT_IF_FALSE(t.mUnit == eStyleUnit_Percent,
+                          "unexpected unit");
+        t.mStartValue.mPercent = oldVal.GetPercentValue();
+        t.mEndValue.mPercent   = newVal.GetPercentValue();
+    }
+}
+
+void
+nsTransitionManager::ConsiderStartingTransition(nsCSSProperty aProperty,
+                       const nsTransition& aTransition, nsIFrame *aFrame,
+                       nsStyleContext *aOldStyleContext)
+{
+    // IsShorthand itself will assert if aProperty is not a property.
+    NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(aProperty),
+                      "property out of range");
+
+    const CSSPropertyAnimationInfo& animInfo = gAnimInfo[aProperty];
+
+    // FIXME: Adjust old value (how?) if there's currently a transition
+    // for this frame+property!
+    // FIXME: Check to see if aProperty has changed, and if it has, start
+    // a transition as appropriate (considering currently running
+    // transitions as appropriate).
+    // Do NOT compare to aOldStyleContext if we already have a transition
+    // going for this property (even if it hasn't moved yet).
+
+    FramePropertyTransition t;
+    switch (animInfo.mType) {
+        case CSSPropertyAnimationInfo::eCannotAnimate: {
+            return;
+        }
+        case CSSPropertyAnimationInfo::eStyleSides: {
+            const StyleSidesAnimationInfo& sidesInfo =
+                gStyleSidesAnimInfo[animInfo.mIndex];
+            const nsStyleCoord &oldVal =
+                GetPropertyValue(aOldStyleContext, sidesInfo);
+            const nsStyleCoord &newVal =
+                GetPropertyValue(aFrame->GetStyleContext(), sidesInfo);
+            if (!ShouldAnimateStyleCoords(oldVal, newVal)) {
+                return;
+            }
+            InitStyleCoordTransition(oldVal, newVal, t);
+            break;
+        }
+        case CSSPropertyAnimationInfo::eStyleCoord: {
+            const StyleCoordAnimationInfo& coordInfo =
+                gStyleCoordAnimInfo[animInfo.mIndex];
+            const nsStyleCoord &oldVal =
+                GetPropertyValue(aOldStyleContext, coordInfo);
+            const nsStyleCoord &newVal =
+                GetPropertyValue(aFrame->GetStyleContext(), coordInfo);
+            if (!ShouldAnimateStyleCoords(oldVal, newVal)) {
+                return;
+            }
+            InitStyleCoordTransition(oldVal, newVal, t);
+            break;
+        }
+        case CSSPropertyAnimationInfo::eNsCoord: {
+            const NsCoordAnimationInfo& coordInfo =
+                gNsCoordAnimInfo[animInfo.mIndex];
+            const nscoord &oldVal =
+                GetPropertyValue(aOldStyleContext, coordInfo);
+            const nscoord &newVal =
+                GetPropertyValue(aFrame->GetStyleContext(), coordInfo);
+            if (oldVal == newVal) {
+                return;
+            }
+            t.mStartValue.mCoord = oldVal;
+            t.mEndValue.mCoord   = newVal;
+            break;
+        }
+    }
+
+    nsRefreshDriver *rd = aFrame->PresContext()->RefreshDriver();
+
+    t.mProperty = aProperty;
+    t.mStartTime = rd->MostRecentRefresh();
+    t.mDelay = TimeDuration::FromMilliseconds(aTransition.GetDelay());
+    t.mDuration = TimeDuration::FromMilliseconds(aTransition.GetDuration());
+    t.mTimingFunction = aTransition.GetTimingFunction();
+
+    // Should we associate transitions with the frame or the content
+    // node?
+    //   + advantages of content:
+    //      - can transition when there's a framechange too (except it
+    //        would still be hard to figure out when a frame is new or
+    //        replacing something else)
+    //      - condenses work across continuations
+    //   + advantages of frame:
+    //      - deals with pseudo-elements and things inside
+    //        pseudo-elements better (though we could deal with
+    //        :before/:after elsewhere, which are the important ones,
+    //        but stuff inside :first-line is harder)
+    //      - avoids confusion when multiple frames per content node
+    // For now, I'll associate them with the frame.
+    //
+    // To get lifetime issues right, I'll store them in objects stored
+    // as a property on the frame which are themselves linked in a
+    // master list (or array?) so we can find all current transitions
+    // quickly.
+    // (Then we can take advantage of frame property destructors...
+    // although those don't necessarily need to call an actual
+    // destructor.)
+    
+    // FIXME: Only do this at most once per call to StyleContextChanged.
+    FrameTransitions *ft = static_cast<FrameTransitions*>(
+        aFrame->GetProperty(nsGkAtoms::transitionsProperty));
+    if (!ft) {
+        // FIXME: Consider arena-allocating?
+        ft = new FrameTransitions();
+        if (!ft) {
+            NS_WARNING("out of memory");
+            return;
+        }
+        nsresult rv = aFrame->SetProperty(nsGkAtoms::transitionsProperty,
+                                          ft, FrameTransitionsPropertyDtor,
+                                          nsnull);
+        if (NS_FAILED(rv)) {
+            NS_WARNING("SetProperty failed");
+            delete ft;
+            return;
+        }
+
+        PR_INSERT_BEFORE(ft, &mFrameTransitions);
+    }
+
+    nsTArray<FramePropertyTransition> &pts = ft->mPropertyTransitions;
+    for (PRUint32 i = 0, i_end = pts.Length(); i < i_end; ++i) {
+        if (pts[i].mProperty == aProperty) {
+            // FIXME: We ought to have done something more interesting
+            // with the old transition for this property.
+            pts.RemoveElementAt(i);
+            break;
+        }
+    }
+
+#ifdef DEBUG
+    for (PRUint32 i = 0, i_end = pts.Length(); i < i_end; ++i) {
+        NS_ABORT_IF_FALSE(pts[i].mProperty != aProperty,
+                          "duplicate transitions for property");
+    }
+#endif
+
+    pts.AppendElement(t);
+}
+
+/*
+ * nsISupports implementation
+ */
+
+NS_IMPL_ADDREF_USING_AGGREGATOR(nsTransitionManager,
+                                nsPresContext::FromTransitionManager(this))
+NS_IMPL_RELEASE_USING_AGGREGATOR(nsTransitionManager,
+                                 nsPresContext::FromTransitionManager(this))
+NS_IMPL_QUERY_INTERFACE1(nsTransitionManager, nsIStyleRuleProcessor)
+
+/*
+ * nsIStyleRuleProcessor implementation
+ */
+
+NS_IMETHODIMP
+nsTransitionManager::RulesMatching(ElementRuleProcessorData* aData)
+{
+    // FIXME: WRITE ME
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsTransitionManager::RulesMatching(PseudoRuleProcessorData* aData)
+{
+    // FIXME: WRITE ME
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsTransitionManager::HasStateDependentStyle(StateRuleProcessorData* aData,
+                                            nsReStyleHint* aResult)
+{
+    *aResult = nsReStyleHint(0);
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsTransitionManager::HasAttributeDependentStyle(AttributeRuleProcessorData* aData,
+                                                nsReStyleHint* aResult)
+{
+    *aResult = nsReStyleHint(0);
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsTransitionManager::MediumFeaturesChanged(nsPresContext* aPresContext,
+                                           PRBool* aRulesChanged)
+{
+    *aRulesChanged = PR_FALSE;
+    return NS_OK;
+}
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
new file mode 100644
--- /dev/null
+++ b/layout/style/nsTransitionManager.h
@@ -0,0 +1,87 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsTransitionManager.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/* Code to start and animate CSS transitions. */
+
+#ifndef nsTransitionManager_h_
+#define nsTransitionManager_h_
+
+#include "prclist.h"
+#include "nsCSSProperty.h"
+#include "nsIStyleRuleProcessor.h"
+
+class nsIFrame;
+class nsStyleContext;
+struct nsTransition;
+
+/**
+ * Must be created only as a sub-object of an nsPresContext (since its
+ * reference counting methods assume that).
+ */
+class nsTransitionManager : public nsIStyleRuleProcessor {
+public:
+    nsTransitionManager();
+    ~nsTransitionManager();
+
+    void StyleContextChanged(nsIFrame *aFrame,
+                             nsStyleContext *aOldStyleContext);
+
+    static void InitializeAnimationInfo();
+
+    // nsISupports
+    NS_DECL_ISUPPORTS_INHERITED
+
+    // nsIStyleRuleProcessor
+    NS_IMETHOD RulesMatching(ElementRuleProcessorData* aData);
+    NS_IMETHOD RulesMatching(PseudoRuleProcessorData* aData);
+    NS_IMETHOD HasStateDependentStyle(StateRuleProcessorData* aData,
+                                      nsReStyleHint* aResult);
+    NS_IMETHOD HasAttributeDependentStyle(AttributeRuleProcessorData* aData,
+                                          nsReStyleHint* aResult);
+    NS_IMETHOD MediumFeaturesChanged(nsPresContext* aPresContext,
+                                     PRBool* aRulesChanged);
+
+private:
+    void ConsiderStartingTransition(nsCSSProperty aProperty,
+                                    const nsTransition& aTransition,
+                                    nsIFrame *aFrame,
+                                    nsStyleContext *aOldStyleContext);
+
+    PRCList mFrameTransitions;
+};
+
+#endif /* !defined(nsTransitionManager_h_) */
