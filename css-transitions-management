From: L. David Baron <dbaron@dbaron.org>

Implement CSS transitions:  handle starting and management of the animations, and add support for transitions of length and percentage values.  (Bug 435441)

diff --git a/content/base/src/nsGkAtomList.h b/content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h
+++ b/content/base/src/nsGkAtomList.h
@@ -1662,16 +1662,19 @@ GK_ATOM(excessOverflowContainersProperty
 GK_ATOM(overflowLinesProperty, "OverflowLinesProperty")    // list of nsLineBox*
 GK_ATOM(overflowOutOfFlowsProperty, "OverflowOutOfFlowsProperty")      // nsFrameList*
 GK_ATOM(overflowPlaceholdersProperty, "OverflowPlaceholdersProperty")  // nsFrameList*
 GK_ATOM(preEffectsBBoxProperty, "PreEffectsBBoxProperty") // nsRect*
 GK_ATOM(preTransformBBoxProperty, "PreTransformBBoxProperty") // nsRect*
 GK_ATOM(rowUnpaginatedHeightProperty, "RowUnpaginatedHeightProperty")  // nscoord*
 GK_ATOM(tabWidthProperty, "TabWidthProperty")              // nsTArray<TabSetting>* array of tab widths
 GK_ATOM(tableBCProperty, "TableBCProperty")                // table border collapsing info (e.g. damage area, table border widths)
+GK_ATOM(transitionsProperty, "TransitionsProperty")        // FrameTransitions*
+GK_ATOM(transitionsOfBeforeProperty, "TransitionsOfBeforeProperty") // FrameTransitions*
+GK_ATOM(transitionsOfAfterProperty, "TransitionsOfAfterProperty") // FrameTransitions*
 GK_ATOM(usedMarginProperty, "UsedMarginProperty") // nsMargin*
 GK_ATOM(usedPaddingProperty, "UsedPaddingProperty") // nsMargin*
 GK_ATOM(viewProperty, "ViewProperty")                      
 
 // Content property names
 GK_ATOM(genConInitializerProperty, "QuoteNodeProperty")
 GK_ATOM(labelMouseDownPtProperty, "LabelMouseDownPtProperty")
 
diff --git a/content/smil/Makefile.in b/content/smil/Makefile.in
--- a/content/smil/Makefile.in
+++ b/content/smil/Makefile.in
@@ -84,16 +84,17 @@ ifdef ENABLE_TESTS
 TOOL_DIRS		+= test
 endif
 
 EXPORTS		= \
 	  nsISMILAnimationElement.h \
 	  nsISMILAttr.h \
 	  nsSMILAnimationController.h \
 	  nsSMILCompositorTable.h \
+	  nsSMILKeySpline.h \
 	  nsSMILTimeContainer.h \
 	  nsSMILTypes.h \
 	  $(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
 INCLUDES += 	\
 		-I$(srcdir)/../base/src \
diff --git a/content/smil/nsSMILKeySpline.cpp b/content/smil/nsSMILKeySpline.cpp
--- a/content/smil/nsSMILKeySpline.cpp
+++ b/content/smil/nsSMILKeySpline.cpp
@@ -38,25 +38,27 @@
 #include "nsSMILKeySpline.h"
 #include <math.h>
 
 #define NEWTON_ITERATIONS   4
 
 const double nsSMILKeySpline::kSampleStepSize =
                                         1.0 / double(kSplineTableSize - 1);
 
-nsSMILKeySpline::nsSMILKeySpline(double aX1,
-                                 double aY1,
-                                 double aX2,
-                                 double aY2)
-: mX1(aX1),
-  mY1(aY1),
-  mX2(aX2),
-  mY2(aY2)
+void
+nsSMILKeySpline::Init(double aX1,
+                      double aY1,
+                      double aX2,
+                      double aY2)
 {
+  mX1 = aX1;
+  mY1 = aY1;
+  mX2 = aX2;
+  mY2 = aY2;
+
   if (mX1 != mY1 || mX2 != mY2)
     CalcSampleValues();
 }
 
 double
 nsSMILKeySpline::GetSplineValue(double aX) const
 {
   if (mX1 == mY1 && mX2 == mY2)
diff --git a/content/smil/nsSMILKeySpline.h b/content/smil/nsSMILKeySpline.h
--- a/content/smil/nsSMILKeySpline.h
+++ b/content/smil/nsSMILKeySpline.h
@@ -41,24 +41,32 @@
 #include "prtypes.h"
 
 /**
  * Utility class to provide scaling defined in a keySplines element.
  */
 class nsSMILKeySpline
 {
 public:
+  nsSMILKeySpline() { /* caller must call Init later */ }
+
   /*
    * Create a new key spline control point description.
    *
    * aX1, etc. are the x1, y1, x2, y2 cubic Bezier control points as defined by
    * SMILANIM 3.2.3. They must each be in the range 0.0 <= x <= 1.0
    */
   nsSMILKeySpline(double aX1, double aY1,
-                  double aX2, double aY2);
+                  double aX2, double aY2)
+  {
+    Init(aX1, aY1, aX2, aY2);
+  }
+
+  void Init(double aX1, double aY1,
+            double aX2, double aY2);
 
   /*
    * Get the output (y) value for an input (x).
    *
    * x should be a floating-point number between 0 and 1 (inclusive).
    */
   double GetSplineValue(double aX) const;
 
@@ -88,20 +96,20 @@ private:
   }
 
   static double
   C(double aA1)
   {
     return 3.0 * aA1;
   }
 
-  const double         mX1;
-  const double         mY1;
-  const double         mX2;
-  const double         mY2;
+  double               mX1;
+  double               mY1;
+  double               mX2;
+  double               mY2;
 
   enum { kSplineTableSize = 11 };
   double               mSampleValues[kSplineTableSize];
 
   static const double  kSampleStepSize;
 };
 
 #endif // NS_SMILKEYSPLINE_H_
diff --git a/layout/base/Makefile.in b/layout/base/Makefile.in
--- a/layout/base/Makefile.in
+++ b/layout/base/Makefile.in
@@ -107,16 +107,17 @@ EXPORTS		= \
 		nsILayoutHistoryState.h \
 		nsIPercentHeightObserver.h  \
 		nsIPresShell.h \
 		nsIReflowCallback.h \
 		nsLayoutErrors.h \
 		nsLayoutUtils.h \
 		nsPresContext.h \
 		nsPresState.h \
+		nsRefreshDriver.h \
 		nsStyleChangeList.h \
 		nsStyleConsts.h \
 		$(NULL)
 
 CPPSRCS		= \
 		nsCSSColorUtils.cpp \
 		nsCSSFrameConstructor.cpp \
 		nsCSSRendering.cpp \
@@ -132,16 +133,17 @@ CPPSRCS		= \
 		nsImageLoader.cpp \
 		nsLayoutDebugger.cpp \
 		nsLayoutHistoryState.cpp \
 		nsLayoutUtils.cpp \
 		nsPresContext.cpp \
 		nsPresShell.cpp \
 		nsPresState.cpp \
 		nsQuoteList.cpp \
+		nsRefreshDriver.cpp \
 		nsStyleChangeList.cpp \
 		nsStyleSheetService.cpp \
 		$(NULL)
 
 ifndef MOZ_XUL
 XPIDLSRCS  += \
 		nsIBoxObject.idl \
 		$(NULL)
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -63,16 +63,17 @@ class nsIPresShell;
 class nsFrameManager;
 class nsIDOMHTMLSelectElement;
 class nsPresContext;
 class nsStyleChangeList;
 class nsIFrame;
 struct nsGenConInitializer;
 class ChildIterator;
 class nsICSSAnonBoxPseudo;
+class nsPageContentFrame;
 
 struct nsFindFrameHint
 {
   nsIFrame *mPrimaryFrameForPrevSibling;  // weak ref to the primary frame for the content for which we need a frame
   nsFindFrameHint() : mPrimaryFrameForPrevSibling(nsnull) { }
 };
 
 typedef void (nsLazyFrameConstructionCallback)
@@ -176,16 +177,19 @@ private:
 class nsCSSFrameConstructor
 {
 public:
   nsCSSFrameConstructor(nsIDocument *aDocument, nsIPresShell* aPresShell);
   ~nsCSSFrameConstructor(void) {
     NS_ASSERTION(mUpdateCount == 0, "Dying in the middle of our own update?");
   }
 
+  struct RestyleData;
+  friend struct RestyleData;
+
   // Maintain global objects - gXBLService
   static nsIXBLService * GetXBLService();
   static void ReleaseGlobals() { NS_IF_RELEASE(gXBLService); }
 
   // get the alternate text for a content node
   static void GetAlternateTextFor(nsIContent*    aContent,
                                   nsIAtom*       aTag,  // content object's tag
                                   nsXPIDLString& aAltText);
@@ -1701,18 +1705,16 @@ private:
   }
 
   void CountersDirty() {
     NS_PRECONDITION(mUpdateCount != 0, "Instant counter updates are bad news");
     mCountersDirty = PR_TRUE;
   }
 
 public:
-  struct RestyleData;
-  friend struct RestyleData;
 
   struct RestyleData {
     nsReStyleHint mRestyleHint;  // What we want to restyle
     nsChangeHint  mChangeHint;   // The minimal change hint for "self"
   };
 
   struct RestyleEnumerateData : public RestyleData {
     nsCOMPtr<nsIContent> mContent;
diff --git a/layout/base/nsFrameManager.cpp b/layout/base/nsFrameManager.cpp
--- a/layout/base/nsFrameManager.cpp
+++ b/layout/base/nsFrameManager.cpp
@@ -85,16 +85,17 @@
 #include "nsContentUtils.h"
 #include "nsReadableUtils.h"
 #include "nsUnicharUtils.h"
 #include "nsPrintfCString.h"
 #include "nsLayoutErrors.h"
 #include "nsLayoutUtils.h"
 #include "nsAutoPtr.h"
 #include "imgIRequest.h"
+#include "nsTransitionManager.h"
 
 #include "nsFrameManager.h"
 #ifdef ACCESSIBILITY
 #include "nsIAccessibilityService.h"
 #include "nsIAccessibleEvent.h"
 #endif
 
   #ifdef DEBUG
@@ -906,16 +907,43 @@ nsFrameManager::DebugVerifyStyleTree(nsI
     nsStyleContext* context = aFrame->GetStyleContext();
     nsStyleContext* parentContext = context->GetParent();
     VerifyStyleTree(GetPresContext(), aFrame, parentContext);
   }
 }
 
 #endif // DEBUG
 
+// aContent must be the content for the frame in question, which may be
+// :before/:after content
+static void
+TryStartingTransition(nsPresContext *aPresContext, nsIContent *aContent,
+                      nsStyleContext *aOldStyleContext,
+                      nsRefPtr<nsStyleContext> *aNewStyleContext /* inout */)
+{
+  // Notify the transition manager, and if it starts a transition,
+  // it will give us back a transition-covering style rule which
+  // we'll use to get *another* style context.  We want to ignore
+  // any already-running transitions, but cover up any that we're
+  // currently starting with their start value so we don't start
+  // them again for descendants that inherit that value.
+  nsCOMPtr<nsIStyleRule> coverRule = 
+    aPresContext->TransitionManager()->StyleContextChanged(
+      aContent, aOldStyleContext, *aNewStyleContext);
+  if (coverRule) {
+    nsCOMArray<nsIStyleRule> rules;
+    rules.AppendObject(coverRule);
+    *aNewStyleContext = aPresContext->StyleSet()->ResolveStyleForRules(
+                     (*aNewStyleContext)->GetParent(),
+                     (*aNewStyleContext)->GetPseudoType(),
+                     (*aNewStyleContext)->GetRuleNode(),
+                     rules);
+  }
+}
+
 nsresult
 nsFrameManager::ReParentStyleContext(nsIFrame* aFrame)
 {
   if (nsGkAtoms::placeholderFrame == aFrame->GetType()) {
     // Also reparent the out-of-flow
     nsIFrame* outOfFlow =
       nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
     NS_ASSERTION(outOfFlow, "no out-of-flow frame");
@@ -951,16 +979,21 @@ nsFrameManager::ReParentStyleContext(nsI
     // Currently the IB anonymous block's style context takes the first part's
     // style context as parent, which is wrong since first-line style should
     // not apply to the anonymous block.
 
     newContext = mStyleSet->ReParentStyleContext(presContext, oldContext,
                                                  newParentContext);
     if (newContext) {
       if (newContext != oldContext) {
+        TryStartingTransition(presContext, aFrame->GetContent(),
+                              oldContext, &newContext);
+        // FIXME: Does this just repeat stuff when we have multiple
+        // continuations, or is it actually harmful?
+
         // Make sure to call CalcStyleDifference so that the new context ends
         // up resolving all the structs the old context resolved.
         nsChangeHint styleChange = oldContext->CalcStyleDifference(newContext);
         // The style change is always 0 because we have the same rulenode and
         // CalcStyleDifference optimizes us away.  That's OK, though:
         // reparenting should never trigger a frame reconstruct, and whenever
         // it's happening we already plan to reflow and repaint the frames.
         NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
@@ -1218,16 +1251,21 @@ nsFrameManager::ReResolveStyleContext(ns
           // we can use FindChildWithRules to keep a lot of the old
           // style contexts around.  However, we need to start from the
           // same root.
           newContext = oldContext;
         }
       }
 
       if (newContext != oldContext) {
+        TryStartingTransition(aPresContext, aFrame->GetContent(),
+                              oldContext, &newContext);
+        // FIXME: Does this just repeat stuff when we have multiple
+        // continuations, or is it actually harmful?
+
         aMinChange = CaptureChange(oldContext, newContext, aFrame,
                                    content, aChangeList, aMinChange,
                                    assumeDifferenceHint);
         if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
           // if frame gets regenerated, let it keep old context
           aFrame->SetStyleContext(newContext);
         }
       }
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -89,16 +89,17 @@
 #include "nsFontFaceLoader.h"
 #include "nsIEventListenerManager.h"
 #include "nsStyleStructInlines.h"
 #include "nsIAppShell.h"
 #include "prenv.h"
 #include "nsIPrivateDOMEvent.h"
 #include "nsIDOMEventTarget.h"
 #include "nsObjectFrame.h"
+#include "nsTransitionManager.h"
 
 #ifdef MOZ_SMIL
 #include "nsSMILAnimationController.h"
 #endif // MOZ_SMIL
 
 #ifdef IBMBIDI
 #include "nsBidiPresUtils.h"
 #endif // IBMBIDI
@@ -250,16 +251,18 @@ nsPresContext::nsPresContext(nsIDocument
 nsPresContext::~nsPresContext()
 {
   for (PRUint32 i = 0; i < IMAGE_LOAD_TYPE_COUNT; ++i)
     mImageLoaders[i].Enumerate(destroy_loads, nsnull);
 
   NS_PRECONDITION(!mShell, "Presshell forgot to clear our mShell pointer");
   SetShell(nsnull);
 
+  delete mTransitionManager;
+
   if (mEventManager) {
     // unclear if these are needed, but can't hurt
     mEventManager->NotifyDestroyPresContext(this);
     mEventManager->SetPresContext(nsnull);
 
     NS_RELEASE(mEventManager);
   }
 
@@ -861,16 +864,18 @@ nsPresContext::Init(nsIDeviceContext* aD
   }
 
   mEventManager = new nsEventStateManager();
   if (!mEventManager)
     return NS_ERROR_OUT_OF_MEMORY;
 
   NS_ADDREF(mEventManager);
 
+  mTransitionManager = new nsTransitionManager(this);
+
   mLangService = do_GetService(NS_LANGUAGEATOMSERVICE_CONTRACTID);
 
   // Register callbacks so we're notified when the preferences change
   nsContentUtils::RegisterPrefCallback("font.",
                                        nsPresContext::PrefChangedCallback,
                                        this);
   nsContentUtils::RegisterPrefCallback("browser.display.",
                                        nsPresContext::PrefChangedCallback,
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -66,16 +66,17 @@
 // This also pulls in gfxTypes.h, which we cannot include directly.
 #include "gfxRect.h"
 #include "nsRegion.h"
 #include "nsTArray.h"
 #include "nsAutoPtr.h"
 #include "nsThreadUtils.h"
 #include "nsContentUtils.h"
 #include "nsIWidget.h"
+#include "nsRefreshDriver.h"
 
 class nsImageLoader;
 #ifdef IBMBIDI
 class nsBidiPresUtils;
 #endif // IBMBIDI
 
 struct nsRect;
 
@@ -95,16 +96,17 @@ class nsICSSPseudoComparator;
 class nsIAtom;
 struct nsStyleBackground;
 struct nsStyleBorder;
 class nsIRunnable;
 class gfxUserFontSet;
 class nsUserFontSet;
 struct nsFontFaceRuleContainer;
 class nsObjectFrame;
+class nsTransitionManager;
 
 #ifdef MOZ_REFLOW_PERF
 class nsIRenderingContext;
 #endif
 
 enum nsWidgetType {
   eWidgetType_Button  	= 1,
   eWidgetType_Checkbox	= 2,
@@ -211,16 +213,26 @@ public:
       return mDocument;
   }
 
 #ifdef _IMPL_NS_LAYOUT
   nsStyleSet* StyleSet() { return GetPresShell()->StyleSet(); }
 
   nsFrameManager* FrameManager()
     { return GetPresShell()->FrameManager(); } 
+
+  nsTransitionManager* TransitionManager() { return mTransitionManager; }
+
+  nsRefreshDriver* RefreshDriver() { return &mRefreshDriver; }
+
+  static nsPresContext* FromRefreshDriver(nsRefreshDriver* aRefreshDriver) {
+    return reinterpret_cast<nsPresContext*>(
+             reinterpret_cast<char*>(aRefreshDriver) -
+             offsetof(nsPresContext, mRefreshDriver));
+  }
 #endif
 
   /**
    * Rebuilds all style data by throwing out the old rule tree and
    * building a new one, and additionally applying aExtraHint (which
    * must not contain nsChangeHint_ReconstructFrame) to the root frame.
    * Also rebuild the user font set.
    */
@@ -925,16 +937,18 @@ protected:
   nsCOMPtr<nsIDocument> mDocument;
   nsIDeviceContext*     mDeviceContext; // [STRONG] could be weak, but
                                         // better safe than sorry.
                                         // Cannot reintroduce cycles
                                         // since there is no dependency
                                         // from gfx back to layout.
   nsIEventStateManager* mEventManager;  // [STRONG]
   nsILookAndFeel*       mLookAndFeel;   // [STRONG]
+  nsRefreshDriver       mRefreshDriver;
+  nsTransitionManager*  mTransitionManager; // owns; it aggregates our refcount
   nsIAtom*              mMedium;        // initialized by subclass ctors;
                                         // weak pointer to static atom
 
   nsILinkHandler*       mLinkHandler;   // [WEAK]
   nsIAtom*              mLangGroup;     // [STRONG]
 
   nsRefPtrHashtable<nsVoidPtrHashKey, nsImageLoader>
                         mImageLoaders[IMAGE_LOAD_TYPE_COUNT];
diff --git a/layout/base/nsRefreshDriver.cpp b/layout/base/nsRefreshDriver.cpp
new file mode 100644
--- /dev/null
+++ b/layout/base/nsRefreshDriver.cpp
@@ -0,0 +1,225 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsRefreshDriver.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * Code to notify things that animate before a refresh, at an appropriate
+ * refresh rate.  (Perhaps temporary, until replaced by compositor.)
+ */
+
+#include "nsRefreshDriver.h"
+#include "nsPresContext.h"
+#include "nsComponentManagerUtils.h"
+#include "prlog.h"
+
+/*
+ * TODO:
+ * Once this is hooked in to suppressing updates when the presentation
+ * is not visible, we need to hook it up to FlushPendingNotifications so
+ * that we flush when necessary.
+ */
+
+#define REFRESH_INTERVAL_MILLISECONDS 20
+
+using mozilla::TimeStamp;
+
+nsRefreshDriver::nsRefreshDriver()
+{
+}
+
+nsRefreshDriver::~nsRefreshDriver()
+{
+    NS_ABORT_IF_FALSE(ObserverCount() == 0,
+                      "observers should have unregistered");
+    NS_ABORT_IF_FALSE(!mTimer, "timer should be gone");
+}
+
+TimeStamp
+nsRefreshDriver::MostRecentRefresh() const
+{
+    if (!mTimer) {
+        const_cast<nsRefreshDriver*>(this)->StartTimer();
+    }
+
+    return mMostRecentRefresh;
+}
+
+PRBool
+nsRefreshDriver::AddRefreshObserver(nsARefreshObserver *aObserver,
+                                    mozFlushType aFlushType)
+{
+    nsTArray<nsARefreshObserver*>& array = ArrayFor(aFlushType);
+    PRBool success = array.AppendElement(aObserver) != nsnull;
+
+    if (!mTimer) {
+        StartTimer();
+    }
+
+    return success;
+}
+
+PRBool
+nsRefreshDriver::RemoveRefreshObserver(nsARefreshObserver *aObserver,
+                                       mozFlushType aFlushType)
+{
+    nsTArray<nsARefreshObserver*>& array = ArrayFor(aFlushType);
+    PRBool success = array.RemoveElement(aObserver);
+
+    if (ObserverCount() == 0) {
+        StopTimer();
+    }
+
+    return success;
+}
+
+void
+nsRefreshDriver::StartTimer()
+{
+    UpdateMostRecentRefresh();
+
+    mTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
+    if (!mTimer) {
+        return;
+    }
+
+    nsresult rv = mTimer->InitWithCallback(this, REFRESH_INTERVAL_MILLISECONDS,
+                                           nsITimer::TYPE_REPEATING_SLACK);
+    if (NS_FAILED(rv)) {
+        mTimer = nsnull;
+    }
+}
+
+void
+nsRefreshDriver::StopTimer()
+{
+    if (!mTimer) {
+        return;
+    }
+
+    mTimer->Cancel();
+    mTimer = nsnull;
+}
+
+PRUint32
+nsRefreshDriver::ObserverCount() const
+{
+    PRUint32 sum = 0;
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(mObservers); ++i) {
+        sum += mObservers[i].Length();
+    }
+    return sum;
+}
+
+void
+nsRefreshDriver::UpdateMostRecentRefresh()
+{
+    mMostRecentRefresh = TimeStamp::Now();
+}
+
+nsTArray<nsARefreshObserver*>&
+nsRefreshDriver::ArrayFor(mozFlushType aFlushType)
+{
+    switch (aFlushType) {
+        case Flush_Style:
+            return mObservers[0];
+        case Flush_Layout:
+            return mObservers[1];
+        case Flush_Display:
+            return mObservers[2];
+        default:
+            NS_ABORT_IF_FALSE(PR_FALSE, "bad flush type");
+            return *static_cast<nsTArray<nsARefreshObserver*>*>(nsnull);
+    }
+}
+
+/*
+ * nsISupports implementation
+ */
+
+NS_IMPL_ADDREF_USING_AGGREGATOR(nsRefreshDriver,
+                                nsPresContext::FromRefreshDriver(this))
+NS_IMPL_RELEASE_USING_AGGREGATOR(nsRefreshDriver,
+                                 nsPresContext::FromRefreshDriver(this))
+NS_IMPL_QUERY_INTERFACE1(nsRefreshDriver, nsITimerCallback)
+
+/*
+ * nsITimerCallback implementation
+ */
+
+NS_IMETHODIMP
+nsRefreshDriver::Notify(nsITimer *aTimer)
+{
+    UpdateMostRecentRefresh();
+
+    nsPresContext *presContext = nsPresContext::FromRefreshDriver(this);
+    nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();
+    if (!presShell) {
+        // Things are being destroyed.
+        StopTimer();
+        return NS_OK;
+    }
+
+    // Clone observers to deal with removal during notification.
+    nsTArray<nsARefreshObserver*> observers[3] = {
+      mObservers[0], mObservers[1], mObservers[2]
+    };
+    PR_STATIC_ASSERT(NS_ARRAY_LENGTH(observers) == NS_ARRAY_LENGTH(mObservers));
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(observers); ++i) {
+        nsTArray<nsARefreshObserver*> array = observers[i];
+        for (PRUint32 j = 0, j_end = array.Length(); j < j_end; ++j) {
+            array[j]->WillRefresh(mMostRecentRefresh);
+        }
+        if (i == 0) {
+            // This is the Flush_Style case.
+            // FIXME: Maybe we should only flush if the WillRefresh
+            // calls did something?  It's probably ok as-is, though,
+            // especially as we hook up more things here (or to the
+            // replacement of this class).
+            // FIXME: We should probably flush for other sets of
+            // observers too.  But we should only flush layout once
+            // nsRefreshDriver is the driver for the interruptible
+            // layout timer (and we should then
+            // Flush_InterruptibleLayout).
+            presShell->FlushPendingNotifications(Flush_Style);
+        }
+    }
+
+    if (ObserverCount() == 0) {
+        StopTimer();
+    }
+
+    return NS_OK;
+}
diff --git a/layout/base/nsRefreshDriver.h b/layout/base/nsRefreshDriver.h
new file mode 100644
--- /dev/null
+++ b/layout/base/nsRefreshDriver.h
@@ -0,0 +1,116 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsRefreshDriver.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * Code to notify things that animate before a refresh, at an appropriate
+ * refresh rate.  (Perhaps temporary, until replaced by compositor.)
+ */
+
+#ifndef nsRefreshDriver_h_
+#define nsRefreshDriver_h_
+
+#include "mozilla/TimeStamp.h"
+#include "mozFlushType.h"
+#include "nsITimer.h"
+#include "nsCOMPtr.h"
+#include "nsTArray.h"
+
+/**
+ * An abstract base class to be implemented by callers wanting to be
+ * notified at refresh times.  When nothing needs to be painted, callers
+ * may not be notified.
+ */
+class nsARefreshObserver {
+public:
+    virtual void WillRefresh(mozilla::TimeStamp aTime) = 0;
+};
+
+/*
+ * nsRefreshDriver MUST ONLY be constructed as a sub-object of
+ * nsPresContext (since its reference counting methods forward to the
+ * pres context of which it is an mRefreshDriver)
+ */
+class nsRefreshDriver : private nsITimerCallback {
+public:
+    nsRefreshDriver();
+    ~nsRefreshDriver();
+
+    /**
+     * Return the time of the most recent refresh.  This is intended to
+     * be used by callers who want to start an animation now and what to
+     * know what time to consider the start of the animation.  (This
+     * helps ensure that multiple animations started during the same
+     * event off the main event loop have the same start time.)
+     */
+    mozilla::TimeStamp MostRecentRefresh() const;
+
+    /**
+     * Add / remove refresh observers.  Returns whether the operation
+     * succeeded.
+     *
+     * The flush type affects:
+     *   + the order in which the observers are notified (lowest flush
+     *     type to highest, in order registered)
+     *   + which observers get notified when there is a flush during
+     *     times when we're not painting
+     * and it must be either Flush_Style, Flush_Layout, or Flush_Display.
+     */
+    PRBool AddRefreshObserver(nsARefreshObserver *aObserver,
+                              mozFlushType aFlushType);
+    PRBool RemoveRefreshObserver(nsARefreshObserver *aObserver,
+                                 mozFlushType aFlushType);
+private:
+    // nsISupports implementation
+    NS_DECL_ISUPPORTS_INHERITED
+
+    // nsITimerCallback implementation
+    NS_IMETHOD Notify(nsITimer *aTimer);
+
+    void StartTimer();
+    void StopTimer();
+    PRUint32 ObserverCount() const;
+    void UpdateMostRecentRefresh();
+    nsTArray<nsARefreshObserver*>& ArrayFor(mozFlushType aFlushType);
+
+    nsCOMPtr<nsITimer> mTimer;
+    mozilla::TimeStamp mMostRecentRefresh; // only valid when mTimer non-null
+
+    // separate arrays for each flush type we support
+    nsTArray<nsARefreshObserver*> mObservers[3];
+};
+
+#endif /* !defined(nsRefreshDriver_h_) */
diff --git a/layout/build/nsLayoutStatics.cpp b/layout/build/nsLayoutStatics.cpp
--- a/layout/build/nsLayoutStatics.cpp
+++ b/layout/build/nsLayoutStatics.cpp
@@ -82,16 +82,17 @@
 #include "nsCSSRuleProcessor.h"
 #include "nsXMLHttpRequest.h"
 #include "nsDOMThreadService.h"
 #include "nsHTMLDNSPrefetch.h"
 #include "nsHtml5Module.h"
 #include "nsCrossSiteListenerProxy.h"
 #include "nsFocusManager.h"
 #include "nsFrameList.h"
+#include "nsTransitionManager.h"
 
 #ifdef MOZ_XUL
 #include "nsXULPopupManager.h"
 #include "nsXULContentUtils.h"
 #include "nsXULElement.h"
 #include "nsXULPrototypeCache.h"
 #include "nsXULTooltipListener.h"
 
@@ -275,16 +276,17 @@ nsLayoutStatics::Initialize()
 
 #ifdef MOZ_SYDNEYAUDIO
   nsAudioStream::InitLibrary();
 #endif
 
   nsHtml5Module::InitializeStatics();
   
   nsCrossSiteListenerProxy::Startup();
+  nsTransitionManager::InitializeAnimationInfo();
 
   rv = nsFrameList::Init();
   if (NS_FAILED(rv)) {
     NS_ERROR("Could not initialize nsFrameList");
     return rv;
   }
 
   return NS_OK;
diff --git a/layout/reftests/css-transitions/reftest.list b/layout/reftests/css-transitions/reftest.list
new file mode 100644
--- /dev/null
+++ b/layout/reftests/css-transitions/reftest.list
@@ -0,0 +1,2 @@
+== transitions-inline-rewrap-1.html transitions-inline-rewrap-ref.html
+== transitions-inline-rewrap-2.html transitions-inline-rewrap-ref.html
diff --git a/layout/reftests/css-transitions/transitions-inline-rewrap-1.html b/layout/reftests/css-transitions/transitions-inline-rewrap-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/css-transitions/transitions-inline-rewrap-1.html
@@ -0,0 +1,24 @@
+<html class="reftest-wait">
+<title>Test for CSS transitions and re-wrapping of inlines</title>
+<style type="text/css">
+#test { -moz-transition: 5s color linear 200s; }
+</style>
+<script type="text/javascript">
+
+/* FIXME: why is this timeout needed? */
+window.onload = function() { setTimeout(run, 100) };
+
+function run() {
+  var test = document.getElementById("test");
+  var unused = test.clientWidth;
+  test.style.color = "red";
+  unused = test.clientWidth;
+  test.style.width = "3em";
+  unused = test.clientWidth;
+  document.documentElement.removeAttribute("class");
+}
+
+</script>
+<div id="test" style="color: green; width: 50em;">
+This is some text with a transition.
+</div>
diff --git a/layout/reftests/css-transitions/transitions-inline-rewrap-2.html b/layout/reftests/css-transitions/transitions-inline-rewrap-2.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/css-transitions/transitions-inline-rewrap-2.html
@@ -0,0 +1,27 @@
+<html class="reftest-wait">
+<title>Test for CSS transitions and re-wrapping of inlines</title>
+<style type="text/css">
+#test { -moz-transition: 20ms color linear 0; }
+</style>
+<script type="text/javascript">
+
+/* FIXME: why is this timeout needed? */
+window.onload = function() { setTimeout(run, 100) };
+
+function run() {
+  var test = document.getElementById("test");
+  var unused = test.clientWidth;
+  test.style.color = "green";
+  unused = test.clientWidth;
+  test.style.width = "3em";
+  unused = test.clientWidth;
+  setTimeout(step2, 100);
+}
+function step2() {
+  document.documentElement.removeAttribute("class");
+}
+
+</script>
+<div id="test" style="color: red; width: 50em;">
+This is some text with a transition.
+</div>
diff --git a/layout/reftests/css-transitions/transitions-inline-rewrap-ref.html b/layout/reftests/css-transitions/transitions-inline-rewrap-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/css-transitions/transitions-inline-rewrap-ref.html
@@ -0,0 +1,5 @@
+<html class="reftest-wait">
+<title>Test for CSS transitions and re-wrapping of inlines</title>
+<div id="test" style="color: green; width: 3em;">
+This is some text with a transition.
+</div>
diff --git a/layout/reftests/reftest.list b/layout/reftests/reftest.list
--- a/layout/reftests/reftest.list
+++ b/layout/reftests/reftest.list
@@ -39,16 +39,19 @@ include canvas/reftest.list
 include css-import/reftest.list
 
 # css character encoding tests
 include css-charset/reftest.list
 
 # css media queries (tests for print mode)
 include css-mediaqueries/reftest.list
 
+# css transitions
+include css-transitions/reftest.list
+
 # css values and units
 include css-valuesandunits/reftest.list
 
 # columns/
 include columns/reftest.list
 
 # content/
 include ../../content/test/reftest/reftest.list
diff --git a/layout/style/Makefile.in b/layout/style/Makefile.in
--- a/layout/style/Makefile.in
+++ b/layout/style/Makefile.in
@@ -120,16 +120,17 @@ EXPORTS		= \
 		nsStyleCoord.h \
 		nsStyleSet.h \
 		nsStyleStruct.h \
 		nsStyleStructFwd.h \
 		nsStyleStructInlines.h \
 		nsStyleStructList.h \
 		nsStyleTransformMatrix.h \
 		nsStyleUtil.h \
+		nsTransitionManager.h \
 		$(NULL)
 
 CPPSRCS		= \
 		nsCSSAnonBoxes.cpp \
 		nsCSSDataBlock.cpp \
 		nsCSSDeclaration.cpp \
 		nsCSSKeywords.cpp \
 		nsCSSLoader.cpp \
@@ -160,16 +161,17 @@ CPPSRCS		= \
 		nsROCSSPrimitiveValue.cpp \
 		nsRuleNode.cpp \
 		nsStyleContext.cpp \
 		nsStyleCoord.cpp \
 		nsStyleSet.cpp \
 		nsStyleStruct.cpp \
 		nsStyleTransformMatrix.cpp \
 		nsStyleUtil.cpp \
+		nsTransitionManager.cpp \
 		$(NULL)
 
 FORCE_STATIC_LIB = 1
 
 include $(topsrcdir)/config/rules.mk
 
 LOCAL_INCLUDES	= \
 		-I$(srcdir)/../../content/base/src \
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -53,16 +53,17 @@
 #include "nsICSSStyleRule.h"
 #include "nsCSSAnonBoxes.h"
 #include "nsCSSPseudoElements.h"
 #include "nsCSSRuleProcessor.h"
 #include "nsIContent.h"
 #include "nsIFrame.h"
 #include "nsContentUtils.h"
 #include "nsRuleProcessorData.h"
+#include "nsTransitionManager.h"
 
 NS_IMPL_ISUPPORTS1(nsEmptyStyleRule, nsIStyleRule)
 
 NS_IMETHODIMP
 nsEmptyStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   return NS_OK;
 }
@@ -116,16 +117,18 @@ nsStyleSet::Init(nsPresContext *aPresCon
 
   mRuleWalker = new nsRuleWalker(mRuleTree);
   if (!mRuleWalker) {
     mRuleTree->Destroy();
     mDefaultStyleData.Destroy(0, aPresContext);
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
+  GatherRuleProcessors(eTransitionSheet);
+
   return NS_OK;
 }
 
 nsresult
 nsStyleSet::BeginReconstruct()
 {
   NS_ASSERTION(!mInReconstruct, "Unmatched begin/end?");
   NS_ASSERTION(mRuleTree, "Reconstructing before first construction?");
@@ -204,16 +207,23 @@ nsStyleSet::GatherRuleProcessors(sheetTy
   mRuleProcessors[aType] = nsnull;
   if (mAuthorStyleDisabled && (aType == eDocSheet || 
                                aType == ePresHintSheet ||
                                aType == eHTMLPresHintSheet ||
                                aType == eStyleAttrSheet)) {
     //don't regather if this level is disabled
     return NS_OK;
   }
+  if (aType == eTransitionSheet) {
+    // We have no sheet for the transitions level; just a rule
+    // processor.  (XXX: We should probably do this for the other
+    // non-CSS levels too!)
+    mRuleProcessors[aType] = PresContext()->TransitionManager();
+    return NS_OK;
+  }
   if (mSheets[aType].Count()) {
     switch (aType) {
       case eAgentSheet:
       case eUserSheet:
       case eDocSheet:
       case eOverrideSheet: {
         // levels containing CSS stylesheets
         nsCOMArray<nsIStyleSheet>& sheets = mSheets[aType];
@@ -597,16 +607,20 @@ nsStyleSet::FileRules(nsIStyleRuleProces
   AddImportantRules(lastUserRN, lastPresHintRN); //user
 #ifdef DEBUG
   AssertNoCSSRules(lastPresHintRN, lastAgentRN);
   AssertNoImportantRules(lastPresHintRN, lastAgentRN); // preshints
 #endif
   mRuleWalker->SetLevel(eAgentSheet, PR_TRUE);
   AddImportantRules(lastAgentRN, nsnull);     //agent
 
+  mRuleWalker->SetLevel(eTransitionSheet, PR_FALSE);
+  if (mRuleProcessors[eTransitionSheet])
+    (*aCollectorFunc)(mRuleProcessors[eTransitionSheet], aData);
+
 }
 
 // Enumerate all the rules in a way that doesn't care about the order
 // of the rules and doesn't walk !important-rules.
 void
 nsStyleSet::WalkRuleProcessors(nsIStyleRuleProcessor::EnumFunc aFunc,
                                RuleProcessorData* aData)
 {
@@ -634,16 +648,18 @@ nsStyleSet::WalkRuleProcessors(nsIStyleR
   }
   if (!skipUserStyles && !cutOffInheritance &&
       mRuleProcessors[eDocSheet]) // NOTE: different
     (*aFunc)(mRuleProcessors[eDocSheet], aData);
   if (mRuleProcessors[eStyleAttrSheet])
     (*aFunc)(mRuleProcessors[eStyleAttrSheet], aData);
   if (mRuleProcessors[eOverrideSheet])
     (*aFunc)(mRuleProcessors[eOverrideSheet], aData);
+  if (mRuleProcessors[eTransitionSheet])
+    (*aFunc)(mRuleProcessors[eTransitionSheet], aData);
 }
 
 PRBool nsStyleSet::BuildDefaultStyleData(nsPresContext* aPresContext)
 {
   NS_ASSERTION(!mDefaultStyleData.mResetData &&
                !mDefaultStyleData.mInheritedData,
                "leaking default style data");
   mDefaultStyleData.mResetData = new (aPresContext) nsResetStyleData;
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -189,16 +189,17 @@ class nsStyleSet
   enum sheetType {
     eAgentSheet, // CSS
     ePresHintSheet,
     eUserSheet, // CSS
     eHTMLPresHintSheet,
     eDocSheet, // CSS
     eStyleAttrSheet,
     eOverrideSheet, // CSS
+    eTransitionSheet,
     eSheetTypeCount
     // be sure to keep the number of bits in |mDirty| below and in
     // NS_RULE_NODE_LEVEL_MASK updated when changing the number of sheet
     // types
   };
 
   // APIs to manipulate the style sheet lists.  The sheets in each
   // list are stored with the most significant sheet last.
@@ -332,13 +333,13 @@ class nsStyleSet
   // Old rule trees, which should only be non-empty between
   // BeginReconstruct and EndReconstruct, but in case of bugs that cause
   // style contexts to exist too long, may last longer.
   nsTArray<nsRuleNode*> mOldRuleTrees;
 
   unsigned mInShutdown : 1;
   unsigned mAuthorStyleDisabled: 1;
   unsigned mInReconstruct : 1;
-  unsigned mDirty : 7;  // one dirty bit is used per sheet type
+  unsigned mDirty : 8;  // one dirty bit is used per sheet type
 
 };
 
 #endif
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -1541,16 +1541,23 @@ nsChangeHint nsStyleDisplay::CalcDiffere
     for (PRUint8 index = 0; index < 2; ++index)
       if (mTransformOrigin[index] != aOther.mTransformOrigin[index]) {
         NS_UpdateHint(hint, NS_CombineHint(nsChangeHint_ReflowFrame,
                                            nsChangeHint_RepaintFrame));
         break;
       }
   }
   
+  // Note:  Our current behavior for handling changes to transition
+  // properties is to do nothing.  In other words, the transition
+  // property that matters is what it is when the transition begins, and
+  // we don't stop a transition later because the transition property
+  // changed.
+  // FIXME:  Need to test for this and write it in the spec, if it's
+  // compatible with other browsers.
   
   return hint;
 }
 
 #ifdef DEBUG
 /* static */
 nsChangeHint nsStyleDisplay::MaxDifference()
 {
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
new file mode 100644
--- /dev/null
+++ b/layout/style/nsTransitionManager.cpp
@@ -0,0 +1,1369 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsTransitionManager.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/* Code to start and animate CSS transitions. */
+
+#include "nsTransitionManager.h"
+#include "nsIContent.h"
+#include "nsStyleContext.h"
+#include "nsCSSProps.h"
+#include "mozilla/TimeStamp.h"
+#include "nsRefreshDriver.h"
+#include "nsRuleProcessorData.h"
+#include "nsIStyleRule.h"
+#include "nsRuleWalker.h"
+#include "nsRuleData.h"
+#include "nsSMILKeySpline.h"
+#include "gfxColor.h"
+#include "nsCSSPseudoElements.h"
+#include "nsCSSPropertySet.h"
+
+using mozilla::TimeStamp;
+using mozilla::TimeDuration;
+
+/*****************************************************************************
+ * Per-CSS-property data                                                     *
+ *****************************************************************************/
+
+struct CSSPropertyAnimationInfo {
+    enum Type {
+        eCannotAnimate,
+        eStyleSides,
+        eStyleCoord,
+        eNsCoord,
+        eNsColor
+#if 0
+      ePaintServer
+#endif
+    };
+
+    Type mType;
+    PRUint32 mIndex;
+};
+
+struct StyleSidesAnimationInfo {
+    typedef nsStyleSides location_type;
+
+    nsCSSProperty mProperty;
+    size_t mLocation;
+    PRUint8 mSide;
+};
+
+// FIXME: Put this into nsCSSPropList.h
+static const StyleSidesAnimationInfo gStyleSidesAnimInfo[] = {
+    { eCSSProperty_margin_top,
+      offsetof(nsStyleMargin, mMargin), NS_SIDE_TOP },
+    { eCSSProperty_margin_right_value,
+      offsetof(nsStyleMargin, mMargin), NS_SIDE_RIGHT },
+    { eCSSProperty_margin_bottom,
+      offsetof(nsStyleMargin, mMargin), NS_SIDE_BOTTOM },
+    { eCSSProperty_margin_left_value,
+      offsetof(nsStyleMargin, mMargin), NS_SIDE_LEFT },
+    { eCSSProperty_padding_top,
+      offsetof(nsStylePadding, mPadding), NS_SIDE_TOP },
+    { eCSSProperty_padding_right_value,
+      offsetof(nsStylePadding, mPadding), NS_SIDE_RIGHT },
+    { eCSSProperty_padding_bottom,
+      offsetof(nsStylePadding, mPadding), NS_SIDE_BOTTOM },
+    { eCSSProperty_padding_left_value,
+      offsetof(nsStylePadding, mPadding), NS_SIDE_LEFT },
+    { eCSSProperty_top,
+      offsetof(nsStylePosition, mOffset), NS_SIDE_TOP },
+    { eCSSProperty_right,
+      offsetof(nsStylePosition, mOffset), NS_SIDE_RIGHT },
+    { eCSSProperty_bottom,
+      offsetof(nsStylePosition, mOffset), NS_SIDE_BOTTOM },
+    { eCSSProperty_left,
+      offsetof(nsStylePosition, mOffset), NS_SIDE_LEFT }
+};
+
+struct StyleCoordAnimationInfo {
+    typedef nsStyleCoord location_type;
+
+    nsCSSProperty mProperty;
+    size_t mLocation;
+};
+
+// for animation length->length, percent->percent, or number->number
+static const StyleCoordAnimationInfo gStyleCoordAnimInfo[] = {
+    { eCSSProperty_outline_width, offsetof(nsStyleOutline, mOutlineWidth) },
+    { eCSSProperty_width, offsetof(nsStylePosition, mWidth) },
+    { eCSSProperty_min_width, offsetof(nsStylePosition, mMinWidth) },
+    { eCSSProperty_max_width, offsetof(nsStylePosition, mMaxWidth) },
+    { eCSSProperty_height, offsetof(nsStylePosition, mHeight) },
+    { eCSSProperty_min_height, offsetof(nsStylePosition, mMinHeight) },
+    { eCSSProperty_max_height, offsetof(nsStylePosition, mMaxHeight) },
+    { eCSSProperty_vertical_align, offsetof(nsStyleTextReset, mVerticalAlign) },
+    { eCSSProperty_letter_spacing, offsetof(nsStyleText, mLetterSpacing) },
+    { eCSSProperty_line_height, offsetof(nsStyleText, mLineHeight) },
+    { eCSSProperty_text_indent, offsetof(nsStyleText, mTextIndent) },
+    { eCSSProperty_marker_offset, offsetof(nsStyleContent, mMarkerOffset) },
+    { eCSSProperty__moz_column_width, offsetof(nsStyleColumn, mColumnWidth) },
+    { eCSSProperty__moz_column_gap, offsetof(nsStyleColumn, mColumnGap) },
+    { eCSSProperty_stroke_dashoffset, offsetof(nsStyleSVG, mStrokeDashoffset) },
+    { eCSSProperty_stroke_width, offsetof(nsStyleSVG, mStrokeWidth) }
+};
+
+struct NsCoordAnimationInfo {
+    typedef nscoord location_type;
+
+    nsCSSProperty mProperty;
+    size_t mLocation;
+};
+
+static const NsCoordAnimationInfo gNsCoordAnimInfo[] = {
+    { eCSSProperty_outline_offset, offsetof(nsStyleOutline, mOutlineOffset) },
+    { eCSSProperty_word_spacing, offsetof(nsStyleText, mWordSpacing) }
+};
+
+struct NsColorAnimationInfo {
+    typedef nscolor location_type;
+
+    nsCSSProperty mProperty;
+    size_t mLocation;
+};
+
+static const NsColorAnimationInfo gNsColorAnimInfo[] = {
+    { eCSSProperty_color, offsetof(nsStyleColor, mColor) },
+    { eCSSProperty_background_color,
+      offsetof(nsStyleBackground, mBackgroundColor) },
+#if 0 // FIXME
+    { eCSSProperty_border_top_color,
+      offsetof(nsStyleBorder, mBorderColor[0]) },
+    { eCSSProperty_border_right_color_value,
+      offsetof(nsStyleBorder, mBorderColor[1]) },
+    { eCSSProperty_border_bottom_color,
+      offsetof(nsStyleBorder, mBorderColor[2]) },
+    { eCSSProperty_border_left_color_value,
+      offsetof(nsStyleBorder, mBorderColor[3]) },
+    { eCSSProperty_outline_color, offsetof(nsStyleOutline, mOutlineColor) },
+#endif
+    { eCSSProperty__moz_column_rule_color,
+      offsetof(nsStyleColumn, mColumnRuleColor) },
+    { eCSSProperty_stop_color, offsetof(nsStyleSVGReset, mStopColor) },
+    { eCSSProperty_flood_color, offsetof(nsStyleSVGReset, mFloodColor) },
+    { eCSSProperty_lighting_color, offsetof(nsStyleSVGReset, mLightingColor) }
+};
+
+struct PaintServerAnimationInfo {
+    typedef nsStyleSVGPaint location_type;
+
+    nsCSSProperty mProperty;
+    size_t mLocation;
+};
+
+static const NsColorAnimationInfo gPaintServerAnimInfo[] = {
+    { eCSSProperty_fill , offsetof(nsStyleSVG, mFill) },
+    { eCSSProperty_stroke , offsetof(nsStyleSVG, mStroke) },
+};
+
+//  { eCSSProperty_ , offsetof(nsStyle, ) },
+
+static CSSPropertyAnimationInfo gAnimInfo[eCSSProperty_COUNT_no_shorthands];
+
+// Have an "*Internal" version so a specialized form can call the
+// general form and then modify the result.
+template <class InfoType>
+static inline const typename InfoType::location_type&
+GetPropertyValueInternal(nsStyleContext *aStyleContext, const InfoType& aInfo)
+{
+    const void* styleStruct =
+      aStyleContext->GetStyleData(nsCSSProps::kSIDTable[aInfo.mProperty]);
+    return *reinterpret_cast<const typename InfoType::location_type*>(
+      reinterpret_cast<const char*>(styleStruct) + aInfo.mLocation);
+}
+
+// General version
+template <class InfoType>
+static inline const typename InfoType::location_type&
+GetPropertyValue(nsStyleContext *aStyleContext, const InfoType& aInfo)
+{
+    return GetPropertyValueInternal(aStyleContext, aInfo);
+}
+
+// Version specific to nsStyleSides.
+static inline nsStyleCoord
+GetPropertyValue(nsStyleContext *aStyleContext,
+                 const StyleSidesAnimationInfo& aInfo)
+{
+    return GetPropertyValueInternal(aStyleContext, aInfo).Get(aInfo.mSide);
+}
+
+template <class InfoType>
+static inline typename InfoType::location_type&
+GetSettablePropertyValue(void* aStyleStruct, const InfoType& aInfo)
+{
+    return *reinterpret_cast<typename InfoType::location_type*>(
+      reinterpret_cast<char*>(aStyleStruct) + aInfo.mLocation);
+}
+
+// General setter
+template <class InfoType>
+static inline void
+SetPropertyValue(void* aStyleStruct, const InfoType& aInfo,
+                 const typename InfoType::location_type& aValue)
+{
+    GetSettablePropertyValue(aStyleStruct, aInfo) = aValue;
+}
+
+// Setter specific to nsStyleSides.
+static inline void
+SetPropertyValue(void* aStyleStruct,
+                 const StyleSidesAnimationInfo& aInfo,
+                 const nsStyleCoord& aValue)
+{
+    GetSettablePropertyValue(aStyleStruct, aInfo).Set(aInfo.mSide, aValue);
+}
+
+/* static */ void
+nsTransitionManager::InitializeAnimationInfo()
+{
+    for (PRUint32 i = 0; i < eCSSProperty_COUNT_no_shorthands; ++i) {
+        gAnimInfo[i].mType = CSSPropertyAnimationInfo::eCannotAnimate;
+    }
+
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gStyleSidesAnimInfo); ++i) {
+        nsCSSProperty prop = gStyleSidesAnimInfo[i].mProperty;
+        NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(prop), "must be longhand");
+        gAnimInfo[prop].mType = CSSPropertyAnimationInfo::eStyleSides;
+        gAnimInfo[prop].mIndex = i;
+    }
+
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gStyleCoordAnimInfo); ++i) {
+        nsCSSProperty prop = gStyleCoordAnimInfo[i].mProperty;
+        NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(prop), "must be longhand");
+        gAnimInfo[prop].mType = CSSPropertyAnimationInfo::eStyleCoord;
+        gAnimInfo[prop].mIndex = i;
+    }
+
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gNsCoordAnimInfo); ++i) {
+        nsCSSProperty prop = gNsCoordAnimInfo[i].mProperty;
+        NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(prop), "must be longhand");
+        gAnimInfo[prop].mType = CSSPropertyAnimationInfo::eNsCoord;
+        gAnimInfo[prop].mIndex = i;
+    }
+
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gNsColorAnimInfo); ++i) {
+        nsCSSProperty prop = gNsColorAnimInfo[i].mProperty;
+        NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(prop), "must be longhand");
+        gAnimInfo[prop].mType = CSSPropertyAnimationInfo::eNsColor;
+        gAnimInfo[prop].mIndex = i;
+    }
+
+#if 0
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gPaintServerAnimInfo); ++i) {
+        nsCSSProperty prop = gPaintServerAnimInfo[i].mProperty;
+        NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(prop), "must be longhand");
+        gAnimInfo[prop].mType = CSSPropertyAnimationInfo::ePaintServer;
+        gAnimInfo[prop].mIndex = i;
+    }
+#endif
+}
+
+/*****************************************************************************
+ * Per-Element data                                                          *
+ *****************************************************************************/
+
+union TransitionEndpoint
+{
+    nscoord mCoord;
+    float mPercent;
+    nscolor mColor;
+};
+
+struct ElementPropertyTransition
+{
+    nsCSSProperty mProperty;
+    nsStyleUnit mUnit; // valid when gAnimInfo[mProperty].mType is
+                       // eStyleSides or eStyleCoord
+    TransitionEndpoint mStartValue, mEndValue;
+    TimeStamp mStartTime; // actual start plus transition delay
+
+    // data from the relevant nsTransition
+    TimeDuration mDuration;
+    nsSMILKeySpline mTimingFunction;
+};
+
+class ElementTransitionsStyleRule : public nsIStyleRule
+{
+public:
+    // nsISupportsImplementation
+    NS_DECL_ISUPPORTS
+
+    // nsIStyleRule implementation
+    NS_IMETHOD MapRuleInfoInto(nsRuleData* aRuleData);
+#ifdef DEBUG
+    NS_IMETHOD List(FILE* out = stdout, PRInt32 aIndent = 0) const;
+#endif
+
+    ElementTransitionsStyleRule(ElementTransitions *aOwner,
+                             TimeStamp aRefreshTime)
+        : mElementTransitions(aOwner)
+        , mRefreshTime(aRefreshTime)
+    {}
+
+    void Disconnect() { mElementTransitions = nsnull; }
+
+    ElementTransitions *ElementData() { return mElementTransitions; }
+    TimeStamp RefreshTime() { return mRefreshTime; }
+
+private:
+    ElementTransitions *mElementTransitions;
+    // The time stamp for which this style rule is valid.
+    TimeStamp mRefreshTime;
+};
+
+class CoverTransitionStartStyleRule : public nsIStyleRule
+{
+public:
+    // nsISupportsImplementation
+    NS_DECL_ISUPPORTS
+
+    // nsIStyleRule implementation
+    NS_IMETHOD MapRuleInfoInto(nsRuleData* aRuleData);
+#ifdef DEBUG
+    NS_IMETHOD List(FILE* out = stdout, PRInt32 aIndent = 0) const;
+#endif
+
+    NS_HIDDEN_(void) CoverValue(nsCSSProperty aProperty,
+                                nsStyleUnit aUnit,
+                                TransitionEndpoint &aStartValue)
+    {
+        CoveredValue v = { aProperty, aUnit, aStartValue };
+        mCoveredValues.AppendElement(v);
+    }
+
+    NS_HIDDEN_(void) FillStyleStruct(void* aStyleStruct, nsRuleData* aRuleData);
+
+    struct CoveredValue;
+    friend struct CoveredValue;
+    struct CoveredValue {
+        nsCSSProperty mProperty;
+        nsStyleUnit mUnit;
+        TransitionEndpoint mCoveredValue;
+    };
+
+private:
+    nsTArray<CoveredValue> mCoveredValues;
+};
+
+struct ElementTransitions : public PRCList
+{
+    ElementTransitions(nsIContent *aElement, nsIAtom *aElementProperty,
+                       nsTransitionManager *aTransitionManager)
+      : mElement(aElement)
+      , mElementProperty(aElementProperty)
+      , mTransitionManager(aTransitionManager)
+    {
+        PR_INIT_CLIST(this);
+    }
+    ~ElementTransitions()
+    {
+        DropStyleRule();
+        PR_REMOVE_LINK(this);
+        mTransitionManager->TransitionsRemoved();
+    }
+
+    void Destroy()
+    {
+        // This will call our destructor.
+        mElement->DeleteProperty(mElementProperty);
+    }
+
+    // Either zero or one for each CSS property:
+    nsTArray<ElementPropertyTransition> mPropertyTransitions;
+
+    void DropStyleRule();
+    PRBool EnsureStyleRuleFor(TimeStamp aRefreshTime);
+
+    // The style rule for the transitions (which contains the time stamp
+    // for which it is valid).
+    nsRefPtr<ElementTransitionsStyleRule> mStyleRule;
+
+    nsIContent *mElement;
+    nsIAtom *mElementProperty; // the atom we use in mElement's prop table
+    nsTransitionManager *mTransitionManager;
+};
+
+static void
+ElementTransitionsPropertyDtor(void           *aObject,
+                             nsIAtom        *aPropertyName,
+                             void           *aPropertyValue,
+                             void           *aData)
+{
+    ElementTransitions *et = static_cast<ElementTransitions*>(aPropertyValue);
+    delete et;
+}
+
+NS_IMPL_ISUPPORTS1(ElementTransitionsStyleRule, nsIStyleRule)
+
+static nsStyleCoord
+CoordFromPortion(const ElementPropertyTransition &aPT,
+                 double aValuePortion)
+{
+    nsStyleCoord val;
+    if (aPT.mUnit == eStyleUnit_Coord) {
+        val.SetCoordValue(NSToCoordRound(
+          aPT.mStartValue.mCoord * (1.0 - aValuePortion) +
+          aPT.mEndValue.mCoord * aValuePortion));
+    } else {
+        NS_ABORT_IF_FALSE(aPT.mUnit == eStyleUnit_Percent,
+                          "unexpected unit");
+        val.SetPercentValue(
+          aPT.mStartValue.mPercent * (1.0 - aValuePortion) +
+          aPT.mEndValue.mPercent * aValuePortion);
+    }
+    return val;
+}
+
+static nscolor
+ColorFromPortion(nscolor aStartColor, nscolor aEndColor, double aValuePortion)
+{
+    double inv = 1.0 - aValuePortion;
+    // FIXME: Does it matter if these are premultiplied?  I think it does.
+    // So the spec should say what to do here...
+#if 0
+    // Don't use premultiplication.
+    return NS_RGBA(PRUint8(NS_GET_R(aStartColor) * inv +
+                           NS_GET_R(aEndColor) * aValuePortion),
+                   PRUint8(NS_GET_G(aStartColor) * inv +
+                           NS_GET_G(aEndColor) * aValuePortion),
+                   PRUint8(NS_GET_B(aStartColor) * inv +
+                           NS_GET_B(aEndColor) * aValuePortion),
+                   PRUint8(NS_GET_A(aStartColor) * inv +
+                           NS_GET_A(aEndColor) * aValuePortion));
+#else
+    // Use premultiplication.
+    double startA = NS_GET_A(aStartColor) / 255.0;
+    double startR = NS_GET_R(aStartColor) * startA;
+    double startG = NS_GET_G(aStartColor) * startA;
+    double startB = NS_GET_B(aStartColor) * startA;
+    double endA = NS_GET_A(aEndColor) / 255.0;
+    double endR = NS_GET_R(aEndColor) * endA;
+    double endG = NS_GET_G(aEndColor) * endA;
+    double endB = NS_GET_B(aEndColor) * endA;
+    double resAf = (startA * inv + endA * aValuePortion);
+    if (resAf == 0.0) {
+        return NS_RGBA(0, 0, 0, 0);
+    }
+    double factor = 1.0 / resAf;
+    PRUint8 resA = NSToIntRound(resAf * 255.0);
+    PRUint8 resR = NSToIntRound((startR * inv + endR * aValuePortion) * factor);
+    PRUint8 resG = NSToIntRound((startG * inv + endG * aValuePortion) * factor);
+    PRUint8 resB = NSToIntRound((startB * inv + endB * aValuePortion) * factor);
+    return NS_RGBA(resR, resG, resB, resA);
+#endif
+}
+
+static void
+ElementTransitionsPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData,
+                                      nsIStyleRule* aRule)
+{
+    ElementTransitionsStyleRule *rule =
+        static_cast<ElementTransitionsStyleRule*>(aRule);
+    ElementTransitions *et = rule->ElementData();
+    for (PRUint32 i = 0, i_end = et->mPropertyTransitions.Length();
+         i < i_end; ++i)
+    {
+        ElementPropertyTransition &pt = et->mPropertyTransitions[i];
+        if (aRuleData->mSIDs & nsCachedStyleData::GetBitForSID(
+                                   nsCSSProps::kSIDTable[pt.mProperty]))
+        {
+            double timePortion =
+                (rule->RefreshTime() - pt.mStartTime).ToSeconds() /
+                pt.mDuration.ToSeconds();
+            if (timePortion < 0.0)
+                timePortion = 0.0; // use start value during transition-delay
+            if (timePortion > 1.0)
+                timePortion = 1.0; // we might be behind on flushing
+
+            double valuePortion =
+                pt.mTimingFunction.GetSplineValue(timePortion);
+
+            // FIXME: share code with cover rule
+
+            const CSSPropertyAnimationInfo& animInfo = gAnimInfo[pt.mProperty];
+            switch (animInfo.mType) {
+                case CSSPropertyAnimationInfo::eCannotAnimate: {
+                    NS_ABORT_IF_FALSE(PR_FALSE, "bad property");
+                    break;
+                }
+                case CSSPropertyAnimationInfo::eStyleSides: {
+                    const StyleSidesAnimationInfo& sidesInfo =
+                        gStyleSidesAnimInfo[animInfo.mIndex];
+                    SetPropertyValue(aStyleStruct, sidesInfo,
+                                     CoordFromPortion(pt, valuePortion));
+                    break;
+                }
+                case CSSPropertyAnimationInfo::eStyleCoord: {
+                    const StyleCoordAnimationInfo& coordInfo =
+                        gStyleCoordAnimInfo[animInfo.mIndex];
+                    SetPropertyValue(aStyleStruct, coordInfo,
+                                     CoordFromPortion(pt, valuePortion));
+                    break;
+                }
+                case CSSPropertyAnimationInfo::eNsCoord: {
+                    const NsCoordAnimationInfo& coordInfo =
+                        gNsCoordAnimInfo[animInfo.mIndex];
+                    nscoord val = NSToCoordRound(
+                        pt.mStartValue.mCoord * (1.0 - valuePortion) +
+                        pt.mEndValue.mCoord * valuePortion);
+                    SetPropertyValue(aStyleStruct, coordInfo, val);
+                    break;
+                }
+                case CSSPropertyAnimationInfo::eNsColor: {
+                    const NsColorAnimationInfo& colorInfo =
+                        gNsColorAnimInfo[animInfo.mIndex];
+                    SetPropertyValue(aStyleStruct, colorInfo,
+                                     ColorFromPortion(pt.mStartValue.mColor,
+                                                      pt.mEndValue.mColor,
+                                                      valuePortion));
+                    break;
+                }
+#if 0
+                case CSSPropertyAnimationInfo::ePaintServer: {
+                    const PaintServerAnimationInfo& paintServerInfo =
+                        gPaintServerAnimInfo[animInfo.mIndex];
+                    SetPropertyValue(aStyleStruct, paintServerInfo,
+                                     ColorFromPortion(pt, valuePortion));
+                    break;
+                }
+#endif
+            }
+
+            if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Margin)) {
+                static_cast<nsStyleMargin*>(aStyleStruct)->RecalcData();
+            }
+            if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Padding)) {
+                static_cast<nsStylePadding*>(aStyleStruct)->RecalcData();
+            }
+        }
+    }
+}
+
+NS_IMETHODIMP
+ElementTransitionsStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
+{
+    nsStyleContext *contextParent = aRuleData->mStyleContext->GetParent();
+    if (contextParent && contextParent->HasPseudoElementData()) {
+        // Don't apply transitions to things inside of pseudo-elements.
+        // FIXME: Add tests for this.
+        return NS_OK;
+    }
+
+    ElementTransitions *et = ElementData();
+    NS_ENSURE_TRUE(et, NS_OK); // FIXME: Why can this be null?
+    for (PRUint32 i = 0, i_end = et->mPropertyTransitions.Length();
+         i < i_end; ++i)
+    {
+        ElementPropertyTransition &pt = et->mPropertyTransitions[i];
+        if (aRuleData->mSIDs & nsCachedStyleData::GetBitForSID(
+                                   nsCSSProps::kSIDTable[pt.mProperty]))
+        {
+            nsPostResolveCallback prc =
+                { &ElementTransitionsPostResolveCallback, this };
+            aRuleData->mPostResolveCallbacks.AppendElement(prc);
+            // This really doesn't matter much, since this ought to be
+            // the only node with the rule, but it's good practice for
+            // post-resolve callbacks.
+            aRuleData->mCanStoreInRuleTree = PR_FALSE;
+
+            return NS_OK;
+        }
+    }
+
+    return NS_OK;
+}
+
+#ifdef DEBUG
+NS_IMETHODIMP
+ElementTransitionsStyleRule::List(FILE* out, PRInt32 aIndent) const
+{
+    // WRITE ME?
+    return NS_OK;
+}
+#endif
+
+void
+ElementTransitions::DropStyleRule()
+{
+    if (mStyleRule) {
+        mStyleRule->Disconnect();
+        mStyleRule = nsnull;
+    }
+}
+
+PRBool
+ElementTransitions::EnsureStyleRuleFor(TimeStamp aRefreshTime)
+{
+    if (!mStyleRule || mStyleRule->RefreshTime() != aRefreshTime) {
+        DropStyleRule();
+
+        ElementTransitionsStyleRule *newRule =
+            new ElementTransitionsStyleRule(this, aRefreshTime);
+        if (!newRule) {
+            NS_WARNING("out of memory");
+            return PR_FALSE;
+        }
+
+        mStyleRule = newRule;
+    }
+
+    return PR_TRUE;
+}
+
+NS_IMPL_ISUPPORTS1(CoverTransitionStartStyleRule, nsIStyleRule)
+
+static void
+CoverTransitionStartPostResolveCallback(void* aStyleStruct,
+                                        nsRuleData* aRuleData,
+                                        nsIStyleRule* aRule)
+{
+    CoverTransitionStartStyleRule* coverRule =
+        static_cast<CoverTransitionStartStyleRule*>(aRule);
+    coverRule->FillStyleStruct(aStyleStruct, aRuleData);
+}
+
+NS_IMETHODIMP
+CoverTransitionStartStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
+{
+    for (PRUint32 i = 0, i_end = mCoveredValues.Length(); i < i_end; ++i) {
+        CoveredValue &cv = mCoveredValues[i];
+        if (aRuleData->mSIDs & nsCachedStyleData::GetBitForSID(
+                                   nsCSSProps::kSIDTable[cv.mProperty]))
+        {
+            nsPostResolveCallback prc =
+                { &CoverTransitionStartPostResolveCallback, this };
+            aRuleData->mPostResolveCallbacks.AppendElement(prc);
+            // This really doesn't matter much, since this ought to be
+            // the only node with the rule, but it's good practice for
+            // post-resolve callbacks.
+            aRuleData->mCanStoreInRuleTree = PR_FALSE;
+
+            return NS_OK;
+        }
+    }
+
+    return NS_OK;
+}
+
+#ifdef DEBUG
+NS_IMETHODIMP
+CoverTransitionStartStyleRule::List(FILE* out, PRInt32 aIndent) const
+{
+    // WRITE ME?
+    return NS_OK;
+}
+#endif
+
+static nsStyleCoord
+CoordFrom(const CoverTransitionStartStyleRule::CoveredValue &aCV)
+{
+    nsStyleCoord val;
+    if (aCV.mUnit == eStyleUnit_Coord) {
+        val.SetCoordValue(aCV.mCoveredValue.mCoord);
+    } else {
+        NS_ABORT_IF_FALSE(aCV.mUnit == eStyleUnit_Percent,
+                          "unexpected unit");
+        val.SetPercentValue(aCV.mCoveredValue.mPercent);
+    }
+    return val;
+}
+
+void
+CoverTransitionStartStyleRule::FillStyleStruct(void* aStyleStruct,
+                                               nsRuleData* aRuleData)
+{
+    // XXX WRITE ME
+    for (PRUint32 i = 0, i_end = mCoveredValues.Length(); i < i_end; ++i) {
+        CoveredValue &cv = mCoveredValues[i];
+        if (aRuleData->mSIDs & nsCachedStyleData::GetBitForSID(
+                                   nsCSSProps::kSIDTable[cv.mProperty]))
+        {
+            // FIXME: share code with element transitions rule
+
+            const CSSPropertyAnimationInfo& animInfo = gAnimInfo[cv.mProperty];
+            switch (animInfo.mType) {
+                case CSSPropertyAnimationInfo::eCannotAnimate: {
+                    NS_ABORT_IF_FALSE(PR_FALSE, "bad property");
+                    break;
+                }
+                case CSSPropertyAnimationInfo::eStyleSides: {
+                    const StyleSidesAnimationInfo& sidesInfo =
+                        gStyleSidesAnimInfo[animInfo.mIndex];
+                    SetPropertyValue(aStyleStruct, sidesInfo, CoordFrom(cv));
+                    break;
+                }
+                case CSSPropertyAnimationInfo::eStyleCoord: {
+                    const StyleCoordAnimationInfo& coordInfo =
+                        gStyleCoordAnimInfo[animInfo.mIndex];
+                    SetPropertyValue(aStyleStruct, coordInfo, CoordFrom(cv));
+                    break;
+                }
+                case CSSPropertyAnimationInfo::eNsCoord: {
+                    const NsCoordAnimationInfo& coordInfo =
+                        gNsCoordAnimInfo[animInfo.mIndex];
+                    SetPropertyValue(aStyleStruct, coordInfo,
+                                     cv.mCoveredValue.mCoord);
+                    break;
+                }
+                case CSSPropertyAnimationInfo::eNsColor: {
+                    const NsColorAnimationInfo& colorInfo =
+                        gNsColorAnimInfo[animInfo.mIndex];
+                    SetPropertyValue(aStyleStruct, colorInfo,
+                                     cv.mCoveredValue.mColor);
+                    break;
+                }
+#if 0
+                case CSSPropertyAnimationInfo::ePaintServer: {
+                    const PaintServerAnimationInfo& paintServerInfo =
+                        gPaintServerAnimInfo[animInfo.mIndex];
+                    SetPropertyValue(aStyleStruct, paintServerInfo,
+                                     cv.mCoveredValue.mColor);
+                    break;
+                }
+#endif
+            }
+
+            if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Margin)) {
+                static_cast<nsStyleMargin*>(aStyleStruct)->RecalcData();
+            }
+            if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Padding)) {
+                static_cast<nsStylePadding*>(aStyleStruct)->RecalcData();
+            }
+        }
+    }
+}
+
+/*****************************************************************************
+ * nsTransitionManager                                                       *
+ *****************************************************************************/
+
+nsTransitionManager::nsTransitionManager(nsPresContext *aPresContext)
+  : mPresContext(aPresContext)
+{
+    PR_INIT_CLIST(&mElementTransitions);
+}
+
+nsTransitionManager::~nsTransitionManager()
+{
+    // This is essentially asserting that all frames have been destroyed
+    // before the pres context.
+    NS_ABORT_IF_FALSE(PR_CLIST_IS_EMPTY(&mElementTransitions),
+                      "all transitions must be destroyed");
+}
+
+already_AddRefed<nsIStyleRule>
+nsTransitionManager::StyleContextChanged(nsIContent *aElement,
+                                         nsStyleContext *aOldStyleContext,
+                                         nsStyleContext *aNewStyleContext)
+{
+    NS_PRECONDITION(aOldStyleContext->GetPseudoType() ==
+                        aNewStyleContext->GetPseudoType(),
+                    "pseudo type mismatch");
+    NS_PRECONDITION(aOldStyleContext->HasPseudoElementData() ==
+                        aNewStyleContext->HasPseudoElementData(),
+                    "pseudo type mismatch");
+    if (aNewStyleContext->PresContext()->IsProcessingAnimationStyleChange()) {
+        return nsnull;
+    }
+    
+    nsIAtom *pseudo = aNewStyleContext->GetPseudoType();
+    if (pseudo && (pseudo != nsCSSPseudoElements::before &&
+                   pseudo != nsCSSPseudoElements::after)) {
+        return nsnull;
+    }
+    if (aNewStyleContext->GetParent() &&
+        aNewStyleContext->GetParent()->HasPseudoElementData()) {
+        // Ignore transitions on things that inherit properties from
+        // pseudo-elements.
+        // FIXME: Add tests for this.
+        return nsnull;
+    }
+
+    const nsStyleDisplay *disp = aNewStyleContext->GetStyleDisplay();
+    PRBool startedAny = PR_FALSE;
+    nsCSSPropertySet whichStarted;
+    ElementTransitions *et = nsnull;
+    for (PRUint32 i = 0, i_end = disp->mTransitions.Length(); i < i_end; ++i) {
+        const nsTransition& t = disp->mTransitions[i];
+        // Check delay and duration first, since they default to zero, and
+        // when they're both zero, we can ignore the transition.
+        if (t.GetDelay() != 0.0f || t.GetDuration() != 0.0f) {
+            et = GetElementTransitions(aElement,
+                                       aNewStyleContext->GetPseudoType(),
+                                       PR_FALSE);
+
+            // We might have something to transition.  See if any of the
+            // properties in question changed and are animatable.
+            nsCSSProperty property = t.GetProperty();
+            if (property == eCSSPropertyExtra_no_properties ||
+                property == eCSSProperty_UNKNOWN) {
+                // Nothing to do, but need to exclude this from cases below.
+            } else if (property == eCSSPropertyExtra_all_properties) {
+                for (nsCSSProperty p = nsCSSProperty(0); 
+                     p < eCSSProperty_COUNT_no_shorthands;
+                     p = nsCSSProperty(p + 1)) {
+                    ConsiderStartingTransition(p, t, aElement, et,
+                                               aOldStyleContext,
+                                               aNewStyleContext,
+                                               &startedAny, &whichStarted);
+                }
+            } else if (nsCSSProps::IsShorthand(property)) {
+                CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(subprop, property) {
+                    ConsiderStartingTransition(*subprop, t, aElement, et,
+                                               aOldStyleContext,
+                                               aNewStyleContext,
+                                               &startedAny, &whichStarted);
+                }
+            } else {
+                ConsiderStartingTransition(property, t, aElement, et,
+                                           aOldStyleContext,
+                                           aNewStyleContext,
+                                           &startedAny, &whichStarted);
+            }
+        }
+    }
+
+    if (!startedAny) {
+        return nsnull;
+    }
+
+    NS_ABORT_IF_FALSE(et, "must have element transitions if we started "
+                          "any transitions");
+
+    // In the CSS working group discussion (2009 Jul 15 telecon,
+    // http://www.w3.org/mid/4A5E1470.4030904@inkedblade.net ) of
+    // http://lists.w3.org/Archives/Public/www-style/2009Jun/0121.html ,
+    // the working group decided that a transition property on an
+    // element should not cause any transitions if the property change
+    // is itself inheriting a value that is transitioning on an
+    // ancestor.  So, to get the correct behavior, we continue the
+    // restyle that caused this transition using a "covering" rule that
+    // covers up any changes on which we started transitions, so that
+    // descendants don't start their own transitions.  (In the case of
+    // negative transition delay, this covering rule produces different
+    // results than applying the transition rule immediately would).
+    // Our caller is responsible for restyling again using this covering
+    // rule.
+
+    nsRefPtr<CoverTransitionStartStyleRule> coverRule =
+        new CoverTransitionStartStyleRule;
+    if (!coverRule) {
+        NS_WARNING("out of memory");
+        return nsnull;
+    }
+    
+    nsTArray<ElementPropertyTransition> &pts = et->mPropertyTransitions;
+    for (PRUint32 i = 0, i_end = pts.Length(); i < i_end; ++i) {
+        ElementPropertyTransition &pt = pts[i];
+        if (whichStarted.HasProperty(pt.mProperty)) {
+            coverRule->CoverValue(pt.mProperty, pt.mUnit, pt.mStartValue);
+        }
+    }
+
+    return already_AddRefed<nsIStyleRule>(static_cast<nsIStyleRule*>(
+               coverRule.forget().get()));
+}
+
+static PRBool
+ShouldAnimateStyleCoords(const nsStyleCoord& oldVal,
+                         const nsStyleCoord& newVal)
+{
+    // FIXME: We can animate any types once we have calc().
+    return oldVal != newVal &&
+           oldVal.GetUnit() == newVal.GetUnit() &&
+           (oldVal.GetUnit() == eStyleUnit_Coord ||
+            oldVal.GetUnit() == eStyleUnit_Percent);
+}
+
+static void
+InitStyleCoordTransition(const nsStyleCoord& oldVal,
+                         const nsStyleCoord& newVal,
+                         ElementPropertyTransition& t)
+{
+    NS_ABORT_IF_FALSE(oldVal.GetUnit() == newVal.GetUnit(),
+                      "should have been checked by ShouldAnimateStyleCoords");
+    t.mUnit = oldVal.GetUnit();
+    if (t.mUnit == eStyleUnit_Coord) {
+        t.mStartValue.mCoord = oldVal.GetCoordValue();
+        t.mEndValue.mCoord   = newVal.GetCoordValue();
+    } else {
+        NS_ABORT_IF_FALSE(t.mUnit == eStyleUnit_Percent,
+                          "unexpected unit");
+        t.mStartValue.mPercent = oldVal.GetPercentValue();
+        t.mEndValue.mPercent   = newVal.GetPercentValue();
+    }
+}
+
+void
+nsTransitionManager::ConsiderStartingTransition(nsCSSProperty aProperty,
+                       const nsTransition& aTransition,
+                       nsIContent *aElement,
+                       ElementTransitions *&aElementTransitions,
+                       nsStyleContext *aOldStyleContext,
+                       nsStyleContext *aNewStyleContext,
+                       PRBool *aStartedAny,
+                       nsCSSPropertySet *aWhichStarted)
+{
+    // IsShorthand itself will assert if aProperty is not a property.
+    NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(aProperty),
+                      "property out of range");
+
+    const CSSPropertyAnimationInfo& animInfo = gAnimInfo[aProperty];
+    ElementPropertyTransition t;
+    PRBool shouldAnimate;
+    switch (animInfo.mType) {
+        case CSSPropertyAnimationInfo::eCannotAnimate: {
+            return;
+        }
+        case CSSPropertyAnimationInfo::eStyleSides: {
+            const StyleSidesAnimationInfo& sidesInfo =
+                gStyleSidesAnimInfo[animInfo.mIndex];
+            const nsStyleCoord &oldVal =
+                GetPropertyValue(aOldStyleContext, sidesInfo);
+            const nsStyleCoord &newVal =
+                GetPropertyValue(aNewStyleContext, sidesInfo);
+            shouldAnimate = ShouldAnimateStyleCoords(oldVal, newVal);
+            if (shouldAnimate) {
+                InitStyleCoordTransition(oldVal, newVal, t);
+            }
+            break;
+        }
+        case CSSPropertyAnimationInfo::eStyleCoord: {
+            const StyleCoordAnimationInfo& coordInfo =
+                gStyleCoordAnimInfo[animInfo.mIndex];
+            const nsStyleCoord &oldVal =
+                GetPropertyValue(aOldStyleContext, coordInfo);
+            const nsStyleCoord &newVal =
+                GetPropertyValue(aNewStyleContext, coordInfo);
+            shouldAnimate = ShouldAnimateStyleCoords(oldVal, newVal);
+            if (shouldAnimate) {
+                InitStyleCoordTransition(oldVal, newVal, t);
+            }
+            break;
+        }
+        case CSSPropertyAnimationInfo::eNsCoord: {
+            const NsCoordAnimationInfo& coordInfo =
+                gNsCoordAnimInfo[animInfo.mIndex];
+            const nscoord &oldVal =
+                GetPropertyValue(aOldStyleContext, coordInfo);
+            const nscoord &newVal =
+                GetPropertyValue(aNewStyleContext, coordInfo);
+            shouldAnimate = oldVal != newVal;
+            if (shouldAnimate) {
+                t.mStartValue.mCoord = oldVal;
+                t.mEndValue.mCoord   = newVal;
+            }
+            break;
+        }
+        case CSSPropertyAnimationInfo::eNsColor: {
+            const NsColorAnimationInfo& colorInfo =
+                gNsColorAnimInfo[animInfo.mIndex];
+            const nscolor &oldVal =
+                GetPropertyValue(aOldStyleContext, colorInfo);
+            const nscolor &newVal =
+                GetPropertyValue(aNewStyleContext, colorInfo);
+            shouldAnimate = oldVal != newVal;
+            if (shouldAnimate) {
+                t.mStartValue.mColor = oldVal;
+                t.mEndValue.mColor   = newVal;
+            }
+            break;
+        }
+#if 0
+        case CSSPropertyAnimationInfo::ePaintServer: {
+            const PaintServerAnimationInfo& paintServerInfo =
+                gPaintServerAnimInfo[animInfo.mIndex];
+            const nsStyleSVGPaint &oldVal =
+                GetPropertyValue(aOldStyleContext, paintServerInfo);
+            const nsStyleSVGPaint &newVal =
+                GetPropertyValue(aNewStyleContext, paintServerInfo);
+            // FIXME: Support gradient animation.
+            shouldAnimate = oldVal != newVal &&
+                            oldVal.mType == eStyleSVGPaintType_Color &&
+                            newVal.mType == eStyleSVGPaintType_Color;
+            if (shouldAnimate) {
+                t.mStartValue.mColor = oldVal.mPaint.mColor;
+                t.mEndValue.mColor   = newVal.mPaint.mColor;
+            }
+            break;
+        }
+#endif
+    }
+
+    PRUint32 currentIndex = PRUint32(-1);
+    if (aElementTransitions) {
+        nsTArray<ElementPropertyTransition> &pts =
+            aElementTransitions->mPropertyTransitions;
+        for (PRUint32 i = 0, i_end = pts.Length(); i < i_end; ++i) {
+            if (pts[i].mProperty == aProperty) {
+                currentIndex = i;
+                break;
+            }
+        }
+    }
+
+    nsPresContext *presContext = aNewStyleContext->PresContext();
+
+    if (!shouldAnimate) {
+        if (currentIndex != PRUint32(-1)) {
+            // We're in the middle of a transition, but just got a
+            // non-transition style change changing to exactly the
+            // current in-progress value.   (This is quite easy to cause
+            // using 'transition-delay'.)
+            nsTArray<ElementPropertyTransition> &pts =
+                aElementTransitions->mPropertyTransitions;
+            pts.RemoveElementAt(currentIndex);
+            if (pts.IsEmpty()) {
+                aElementTransitions->Destroy();
+                // |aElementTransitions| is now a dangling pointer!
+                aElementTransitions = nsnull;
+            }
+            presContext->PresShell()->PostRestyleFor(aElement, PR_TRUE);
+        }
+        return;
+    }
+
+    // When we interrupt an running transition, we want to reduce the
+    // duration of the new transition *if* the new transition would have
+    // been longer had it started from the endpoint of the currently
+    // running transition.
+    double durationFraction = 1.0;
+    if (currentIndex != PRUint32(-1)) {
+        const TransitionEndpoint &endVal =
+            aElementTransitions->mPropertyTransitions[currentIndex].mEndValue;
+
+        switch (animInfo.mType) {
+            case CSSPropertyAnimationInfo::eCannotAnimate: {
+                NS_ABORT_IF_FALSE(PR_FALSE, "unexpected property");
+            }
+            case CSSPropertyAnimationInfo::eStyleSides:
+            case CSSPropertyAnimationInfo::eStyleCoord: {
+                if (t.mUnit == eStyleUnit_Percent) {
+                    NS_ABORT_IF_FALSE(aElementTransitions->mPropertyTransitions
+                                        [currentIndex].mUnit ==
+                                      eStyleUnit_Percent,
+                                      "unit mismatch");
+                    durationFraction =
+                        double(t.mStartValue.mPercent - t.mEndValue.mPercent) /
+                        double(endVal.mPercent - t.mEndValue.mPercent);
+                    break;
+                }
+                // else fall through
+            }
+            case CSSPropertyAnimationInfo::eNsCoord: {
+                durationFraction =
+                    double(t.mStartValue.mCoord - t.mEndValue.mCoord) /
+                    double(endVal.mCoord - t.mEndValue.mCoord);
+                break;
+            }
+            // FIXME: Needs cases for color, which requires distance
+            // function, perhaps?
+        }
+        if (durationFraction < 0.0)
+            durationFraction = -durationFraction;
+        if (durationFraction > 1.0)
+            durationFraction = 1.0;
+    }
+
+
+    nsRefreshDriver *rd = presContext->RefreshDriver();
+
+    t.mProperty = aProperty;
+    float delay = aTransition.GetDelay();
+    float duration = aTransition.GetDuration();
+    if (durationFraction != 1.0) {
+        // Negative delays are essentially part of the transition
+        // function, so reduce them along with the duration, but don't
+        // reduce positive delays.  (See comment above about
+        // durationFraction.)
+        if (delay < 0.0f)
+            delay *= durationFraction;
+        duration *= durationFraction;
+    }
+    t.mStartTime = rd->MostRecentRefresh() +
+                   TimeDuration::FromMilliseconds(delay);
+    t.mDuration = TimeDuration::FromMilliseconds(duration);
+    const nsTimingFunction &tf = aTransition.GetTimingFunction();
+    t.mTimingFunction.Init(tf.mX1, tf.mY1, tf.mX2, tf.mY2);
+
+    // Should we associate transitions with the frame or the content
+    // node?
+    //   + advantages of content:
+    //      - can transition when there's a framechange too (except it
+    //        would still be hard to figure out when a frame is new or
+    //        replacing something else)
+    //      - condenses work across continuations
+    //   + advantages of frame:
+    //      - deals with pseudo-elements and things inside
+    //        pseudo-elements better (though we could deal with
+    //        :before/:after elsewhere, which are the important ones,
+    //        but stuff inside :first-line is harder)
+    //      - avoids confusion when multiple frames per content node
+    // For now, I'll associate them with the frame.
+    //
+    // To get lifetime issues right, I'll store them in objects stored
+    // as a property on the frame which are themselves linked in a
+    // master list (or array?) so we can find all current transitions
+    // quickly.
+    // (Then we can take advantage of frame property destructors...
+    // although those don't necessarily need to call an actual
+    // destructor.)
+    // FIXME: attach to content instead, and write test for color
+    // transition on element that then breaks into lines.  (Need to be
+    // careful to start transition only once per node.)
+    
+    if (!aElementTransitions) {
+        aElementTransitions =
+            GetElementTransitions(aElement, aNewStyleContext->GetPseudoType(),
+                                  PR_TRUE);
+        if (!aElementTransitions) {
+            NS_WARNING("allocating ElementTransitions failed");
+            return;
+        }
+    }
+    
+    nsTArray<ElementPropertyTransition> &pts =
+        aElementTransitions->mPropertyTransitions;
+#ifdef DEBUG
+    for (PRUint32 i = 0, i_end = pts.Length(); i < i_end; ++i) {
+        NS_ABORT_IF_FALSE(i == currentIndex ||
+                          pts[i].mProperty != aProperty,
+                          "duplicate transitions for property");
+    }
+#endif
+    if (currentIndex != PRUint32(-1)) {
+        pts[currentIndex] = t;
+    } else {
+        if (!pts.AppendElement(t)) {
+            NS_WARNING("out of memory");
+            return;
+        }
+    }
+
+    presContext->PresShell()->PostRestyleFor(aElement, PR_TRUE);
+
+    *aStartedAny = PR_TRUE;
+    aWhichStarted->AddProperty(aProperty);
+}
+
+ElementTransitions*
+nsTransitionManager::GetElementTransitions(nsIContent *aElement,
+                                           nsIAtom *aPseudo,
+                                           PRBool aCreateIfNeeded)
+{
+    nsIAtom *propName;
+    if (aPseudo == nsCSSPseudoElements::before) {
+        propName = nsGkAtoms::transitionsOfBeforeProperty;
+    } else if (aPseudo == nsCSSPseudoElements::after) {
+        propName = nsGkAtoms::transitionsOfAfterProperty;
+    } else {
+        NS_ASSERTION(!aPseudo || !aCreateIfNeeded,
+                     "should never try to create transitions for pseudo "
+                     "other than :before or :after");
+        propName = nsGkAtoms::transitionsProperty;
+    }
+    ElementTransitions *et = static_cast<ElementTransitions*>(
+        aElement->GetProperty(propName));
+    if (!et && aCreateIfNeeded) {
+        // FIXME: Consider arena-allocating?
+        et = new ElementTransitions(aElement, propName, this);
+        if (!et) {
+            NS_WARNING("out of memory");
+            return nsnull;
+        }
+        nsresult rv = aElement->SetProperty(propName, et,
+                                            ElementTransitionsPropertyDtor,
+                                            nsnull);
+        if (NS_FAILED(rv)) {
+            NS_WARNING("SetProperty failed");
+            delete et;
+            return nsnull;
+        }
+
+        AddElementTransitions(et);
+    }
+
+    return et;
+}
+
+void
+nsTransitionManager::AddElementTransitions(ElementTransitions* aElementTransitions)
+{
+    if (PR_CLIST_IS_EMPTY(&mElementTransitions)) {
+        // We need to observe the refresh driver.
+        nsRefreshDriver *rd = mPresContext->RefreshDriver();
+        rd->AddRefreshObserver(this, Flush_Style);
+    }
+
+    PR_INSERT_BEFORE(aElementTransitions, &mElementTransitions);
+}
+
+/*
+ * nsISupports implementation
+ */
+
+NS_IMPL_ADDREF_USING_AGGREGATOR(nsTransitionManager, mPresContext)
+NS_IMPL_RELEASE_USING_AGGREGATOR(nsTransitionManager, mPresContext)
+NS_IMPL_QUERY_INTERFACE1(nsTransitionManager, nsIStyleRuleProcessor)
+
+/*
+ * nsIStyleRuleProcessor implementation
+ */
+
+nsresult
+nsTransitionManager::WalkTransitionRule(RuleProcessorData* aData,
+                                        nsIAtom *aPseudo)
+{
+    if (!aData->mPresContext->IsProcessingAnimationStyleChange()) {
+        // If we're processing a normal style change rather than one
+        // from animation, don't add the transition rule.  This allows
+        // us to compute the new style value rather than having the
+        // transition override it, so that we can start transitioning
+        // differently.
+        // FIXME: We need to immediately restyle with animation after
+        // doing this.
+        return NS_OK;
+    }
+
+    ElementTransitions *et =
+        GetElementTransitions(aData->mContent, aPseudo, PR_FALSE);
+    if (!et) {
+        return NS_OK;
+    }
+
+    if (!et->EnsureStyleRuleFor(
+               aData->mPresContext->RefreshDriver()->MostRecentRefresh())) {
+        return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    aData->mRuleWalker->Forward(et->mStyleRule);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsTransitionManager::RulesMatching(ElementRuleProcessorData* aData)
+{
+    NS_ABORT_IF_FALSE(aData->mPresContext == mPresContext,
+                      "pres context mismatch");
+    return WalkTransitionRule(aData, nsnull);
+}
+
+NS_IMETHODIMP
+nsTransitionManager::RulesMatching(PseudoRuleProcessorData* aData)
+{
+    NS_ABORT_IF_FALSE(aData->mPresContext == mPresContext,
+                      "pres context mismatch");
+    // Note:  If we're the only thing keeping a pseudo-element frame
+    // alive (per ProbePseudoStyleContext), we still want to keep it
+    // alive, so this is ok.
+    return WalkTransitionRule(aData, aData->mPseudoTag);
+}
+
+NS_IMETHODIMP
+nsTransitionManager::HasStateDependentStyle(StateRuleProcessorData* aData,
+                                            nsReStyleHint* aResult)
+{
+    *aResult = nsReStyleHint(0);
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsTransitionManager::HasAttributeDependentStyle(AttributeRuleProcessorData* aData,
+                                                nsReStyleHint* aResult)
+{
+    *aResult = nsReStyleHint(0);
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsTransitionManager::MediumFeaturesChanged(nsPresContext* aPresContext,
+                                           PRBool* aRulesChanged)
+{
+    *aRulesChanged = PR_FALSE;
+    return NS_OK;
+}
+
+/* virtual */ void
+nsTransitionManager::WillRefresh(mozilla::TimeStamp aTime)
+{
+    // Trim transitions that have completed, and post restyle events for
+    // frames that are still transitioning.
+    {
+        PRCList *next = PR_LIST_HEAD(&mElementTransitions);
+        while (next != &mElementTransitions) {
+            ElementTransitions *et = static_cast<ElementTransitions*>(next);
+            next = PR_NEXT_LINK(next);
+
+            PRUint32 i = et->mPropertyTransitions.Length();
+            NS_ABORT_IF_FALSE(i != 0, "empty transitions list?");
+            do {
+                --i;
+                ElementPropertyTransition &pt = et->mPropertyTransitions[i];
+                if (pt.mStartTime + pt.mDuration <= aTime) {
+                    // This transition has completed.
+                    et->mPropertyTransitions.RemoveElementAt(i);
+                }
+            } while (i != 0);
+
+            // We need to restyle even if the transition rule no longer
+            // applies (in which case we just made it not apply).
+            mPresContext->PresShell()->PostRestyleFor(et->mElement, PR_TRUE);
+
+            if (et->mPropertyTransitions.IsEmpty()) {
+                et->Destroy();
+                // |et| is now a dangling pointer!
+                et = nsnull;
+            }
+        }
+    }
+
+    // We might have removed transitions above.
+    TransitionsRemoved();
+}
+
+void
+nsTransitionManager::TransitionsRemoved()
+{
+    // If we have no transitions left, remove ourselves from the refresh
+    // driver.
+    if (PR_CLIST_IS_EMPTY(&mElementTransitions)) {
+        mPresContext->RefreshDriver()->RemoveRefreshObserver(this, Flush_Style);
+    }
+}
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
new file mode 100644
--- /dev/null
+++ b/layout/style/nsTransitionManager.h
@@ -0,0 +1,114 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsTransitionManager.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/* Code to start and animate CSS transitions. */
+
+#ifndef nsTransitionManager_h_
+#define nsTransitionManager_h_
+
+#include "prclist.h"
+#include "nsCSSProperty.h"
+#include "nsIStyleRuleProcessor.h"
+#include "nsRefreshDriver.h"
+
+class nsStyleContext;
+class nsPresContext;
+class nsCSSPropertySet;
+struct nsTransition;
+struct ElementTransitions;
+
+/**
+ * Must be created only as a sub-object of an nsPresContext (since its
+ * reference counting methods assume that).
+ */
+class nsTransitionManager : public nsIStyleRuleProcessor,
+                            public nsARefreshObserver {
+public:
+    nsTransitionManager(nsPresContext *aPresContext);
+    ~nsTransitionManager();
+
+    /**
+     * StyleContextChanged 
+     *
+     *
+     */
+    already_AddRefed<nsIStyleRule>
+         StyleContextChanged(nsIContent *aElement,
+                             nsStyleContext *aOldStyleContext,
+                             nsStyleContext *aNewStyleContext);
+
+    static void InitializeAnimationInfo();
+
+    // nsISupports
+    NS_DECL_ISUPPORTS_INHERITED
+
+    // nsIStyleRuleProcessor
+    NS_IMETHOD RulesMatching(ElementRuleProcessorData* aData);
+    NS_IMETHOD RulesMatching(PseudoRuleProcessorData* aData);
+    NS_IMETHOD HasStateDependentStyle(StateRuleProcessorData* aData,
+                                      nsReStyleHint* aResult);
+    NS_IMETHOD HasAttributeDependentStyle(AttributeRuleProcessorData* aData,
+                                          nsReStyleHint* aResult);
+    NS_IMETHOD MediumFeaturesChanged(nsPresContext* aPresContext,
+                                     PRBool* aRulesChanged);
+
+    // nsARefreshObserver
+    virtual void WillRefresh(mozilla::TimeStamp aTime);
+
+private:
+    friend class ElementTransitions; // for TransitionsRemoved
+
+    void ConsiderStartingTransition(nsCSSProperty aProperty,
+                                    const nsTransition& aTransition,
+                                    nsIContent *aElement,
+                                    ElementTransitions *&aElementTransitions,
+                                    nsStyleContext *aOldStyleContext,
+                                    nsStyleContext *aNewStyleContext,
+                                    PRBool *aStartedAny,
+                                    nsCSSPropertySet *aWhichStarted);
+    ElementTransitions* GetElementTransitions(nsIContent *aElement,
+                                              nsIAtom *aPseudo,
+                                              PRBool aCreateIfNeeded);
+    void AddElementTransitions(ElementTransitions* aElementTransitions);
+    void TransitionsRemoved();
+    nsresult WalkTransitionRule(RuleProcessorData* aData, nsIAtom *aPseudo);
+
+    PRCList mElementTransitions;
+    nsPresContext *mPresContext;
+};
+
+#endif /* !defined(nsTransitionManager_h_) */
diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -126,16 +126,18 @@ _TEST_FILES =	test_acid3_test46.html \
 		test_property_syntax_errors.html \
 		test_rem_unit.html \
 		test_selectors.html \
 		test_selectors_on_anonymous_content.html \
 		test_shorthand_property_getters.html \
 		test_style_struct_copy_constructors.html \
 		test_system_font_serialization.html \
 		test_transitions_computed_values.html \
+		test_transitions.html \
+		test_transitions_per_property.html \
 		test_units_angle.html \
 		test_units_frequency.html \
 		test_units_length.html \
 		test_units_time.html \
 		test_value_computation.html \
 		test_value_storage.html \
 		test_visited_pref.html \
 		css_properties.js \
diff --git a/layout/style/test/test_transitions.html b/layout/style/test/test_transitions.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_transitions.html
@@ -0,0 +1,515 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=435441
+-->
+<head>
+  <title>Test for Bug 435441</title>
+  <script type="application/javascript" src="/MochiKit/packed.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+  <style type="text/css">
+
+  #display p { margin-top: 0; margin-bottom: 0; }
+
+  </style>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=435441">Mozilla Bug 435441</a>
+<div id="display">
+
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 435441 **/
+
+function px_to_num(str)
+{
+    return Number(String(str).match(/^([\d.]+)px$/)[1]);
+}
+
+// Run tests simultaneously so we don't have to take up too much time.
+SimpleTest.waitForExplicitFinish();
+var gTestsRunning = 0;
+function TestStarted() { ++gTestsRunning; }
+function TestFinished() { if (--gTestsRunning == 0) SimpleTest.finish(); }
+
+// An array of arrays of functions to be called at the outer index number
+// of seconds after the present.
+var gFutureCalls = [];
+
+function add_future_call(index, func)
+{
+    if (!(index in gFutureCalls)) {
+        gFutureCalls[index] = [];
+    }
+    gFutureCalls[index].push(func);
+    TestStarted();
+}
+var gStartTime1, gStartTime2;
+function process_future_calls(index)
+{
+    var calls = gFutureCalls[index];
+    if (!calls)
+        return;
+    var ms_late1 = Date.now() - gStartTime1 - 1000 * index;
+    var ms_late2 = Date.now() - gStartTime2 - 1000 * index;
+    // our real tolerance is 40ms (1% of 4s)
+    if (Math.abs(ms_late1) > 35 || Math.abs(ms_late2) > 35) {
+        todo(false, "Timer for tests at time " + index + "s was fired " +
+                    ms_late2 + "ms - " + ms_late1 + "ms late, so skipping " +
+                    "tests for being outside of tolerable range.");
+    } else {
+        for (var i = 0; i < calls.length; ++i) {
+            calls[i]();
+        }
+    }
+    for (var i = 0; i < calls.length; ++i) {
+        TestFinished();
+    }
+}
+
+var timingFunctions = {
+  // a map from the value of 'transition-timing-function' to an array of
+  // the portions this function yields at 0 (always 0), 1/4, 1/2, and
+  // 3/4 and all (always 1) of the way through the time of the
+  // transition.  Each portion is represented as a value and an
+  // acceptable error tolerance (based on a time error of 1%) for that
+  // value.
+
+  // ease
+  "ease": [ [0, 0.00450], [0.40851, 0.02226], [0.80240, 0.01013], [0.96046, 0.00357], [1, 0.00006] ],
+  "cubic-bezier(0.25, 0.1, 0.25, 1.0)": [ [0, 0.00450], [0.40851, 0.02226], [0.80240, 0.01013], [0.96046, 0.00357], [1, 0.00006] ],
+
+  // linear and various synonyms for it
+  "linear": [ [0, 0.01], [0.25, 0.01], [0.5, 0.01], [0.75, 0.01], [1, 0.01] ],
+  "cubic-bezier(0.0, 0.0, 1.0, 1.0)": [ [0, 0.01], [0.25, 0.01], [0.5, 0.01], [0.75, 0.01], [1, 0.01] ],
+  "cubic-bezier(0, 0, 1, 1)": [ [0, 0.01], [0.25, 0.01], [0.5, 0.01], [0.75, 0.01], [1, 0.01] ],
+  "cubic-bezier(0, 0, 0, 0.0)": [ [0, 0.01], [0.25, 0.01], [0.5, 0.01], [0.75, 0.01], [1, 0.01] ],
+  "cubic-bezier(1.0, 1, 0, 0)": [ [0, 0.01], [0.25, 0.01], [0.5, 0.01], [0.75, 0.01], [1, 0.01] ],
+
+  // ease-in
+  "ease-in": [ [0, 0.00019], [0.09346, 0.00686], [0.31536, 0.01082], [0.62186, 0.01375], [1, 0.01691] ],
+  "cubic-bezier(0.42, 0, 1.0, 1.0)": [ [0, 0.00019], [0.09346, 0.00686], [0.31536, 0.01082], [0.62186, 0.01375], [1, 0.01691] ],
+
+  // ease-out
+  "ease-out": [ [0, 0.01692], [0.37814, 0.01375], [0.68464, 0.01082], [0.90654, 0.00686], [1, 0.00019] ],
+  "cubic-bezier(0, 0, 0.58, 1.0)": [ [0, 0.01692], [0.37814, 0.01375], [0.68464, 0.01082], [0.90654, 0.00686], [1, 0.00019] ],
+
+  // ease-in-out
+  "ease-in-out": [ [0, 0.00020], [0.12916, 0.01082], [0.5, 0.01724], [0.87084, 0.01082], [1, 0.00019] ],
+  "cubic-bezier(0.42, 0, 0.58, 1.0)": [ [0, 0.00020], [0.12916, 0.01082], [0.5, 0.01724], [0.87084, 0.01082], [1, 0.00019] ],
+
+  // other cubic-bezier values
+  "cubic-bezier(0.4, 0.1, 0.7, 0.95)": [ [0, 0.00267], [0.15786, 0.00996], [0.46568, 0.01409], [0.80898, 0.01226], [1, 0.00197] ],
+  "cubic-bezier(1, 0, 0, 1)": [ [0, 0.00004], [0.02972, 0.00306], [0.5, 0.19859], [0.97028, 0.00306], [1, 0.00004] ],
+  "cubic-bezier(0, 1, 1, 0)": [ [0, 0.15672], [0.47906, 0.00290], [0.5, 0.00001], [0.52094, 0.00290], [1, 0.15672] ]
+
+};
+
+var div = document.getElementById("display");
+
+// Set up all the elements on which we are going to start transitions.
+
+// Test all timing functions using a set of 8-second transitions, which
+// we check at times 0, 2s, 4s, 6s, and 8s.
+var tftests = [];
+for (var tf in timingFunctions) {
+    var p = document.createElement("p");
+    var t = document.createTextNode("transition-timing-function: " + tf);
+    p.appendChild(t);
+    p.style.textIndent = "0px";
+    p.style.MozTransition = "8s text-indent linear";
+    p.style.MozTransitionTimingFunction = tf;
+    div.appendChild(p);
+    is(getComputedStyle(p, "").textIndent, "0px",
+       "should be zero before changing value");
+    tftests.push([ p, tf ]);
+}
+
+// Test transition-delay values of -4s through 4s on a 4s transition
+// with 'ease-out' timing function.
+var delay_tests = {};
+for (var d = -4; d <= 4; ++d) {
+    var p = document.createElement("p");
+    var delay = d + "s";
+    var t = document.createTextNode("transition-delay: " + delay);
+    p.appendChild(t);
+    p.style.marginLeft = "0px";
+    p.style.MozTransition = "4s margin-left ease-out " + delay;
+    div.appendChild(p);
+    is(getComputedStyle(p, "").marginLeft, "0px",
+       "should be zero before changing value");
+    delay_tests[d] = p;
+}
+
+// Test that changing the value on an already-running transition to the
+// value it currently happens to have resets the transition.
+var p = document.createElement("p");
+var t = document.createTextNode("transition-delay reset to starting point");
+p.appendChild(t);
+p.style.marginLeft = "0px";
+p.style.MozTransition = "4s margin-left ease-out 4s";
+div.appendChild(p);
+is(getComputedStyle(p, "").marginLeft, "0px",
+   "should be zero before changing value");
+var reset_test = p;
+
+// Test that transitions on descendants do not trigger when the
+// inherited value is itself transitioning. (FIXME: word this better)
+var descendant_tests = [
+    { parent_transition: "",
+      child_transition: "4s text-indent" },
+    { parent_transition: "4s text-indent",
+      child_transition: "" },
+    { parent_transition: "4s text-indent",
+      child_transition: "16s text-indent" },
+    { parent_transition: "4s text-indent",
+      child_transition: "1s text-indent" },
+    { parent_transition: "8s letter-spacing",
+      child_transition: "4s text-indent" },
+    { parent_transition: "4s text-indent",
+      child_transition: "8s letter-spacing" },
+    { parent_transition: "4s text-indent",
+      child_transition: "8s all" },
+    { parent_transition: "8s text-indent",
+      child_transition: "4s all" },
+    // examples with positive and negative delay
+    { parent_transition: "4s text-indent 1s",
+      child_transition: "8s text-indent" },
+    { parent_transition: "4s text-indent -1s",
+      child_transition: "8s text-indent" }
+];
+
+for (var i in descendant_tests) {
+    var test = descendant_tests[i];
+    test.parentNode = document.createElement("div");
+    test.childNode = document.createElement("p");
+    test.parentNode.appendChild(test.childNode);
+    test.childNode.appendChild(document.createTextNode(
+        "parent with \"" + test.parent_transition + "\" and " +
+        "child with \"" + test.child_transition + "\""));
+    test.parentNode.style.MozTransition = test.parent_transition;
+    test.childNode.style.MozTransition = test.child_transition;
+    test.parentNode.style.textIndent = "50px"; // transition from 50 to 150
+    test.parentNode.style.letterSpacing = "10px"; // transition from 10 to 5
+    div.appendChild(test.parentNode);
+    var parentCS = getComputedStyle(test.parentNode, "");
+    var childCS = getComputedStyle(test.childNode, "");
+    is(parentCS.textIndent, "50px",
+       "parent text-indent should be 50px before changing");
+    is(parentCS.letterSpacing, "10px",
+       "parent letter-spacing should be 10px before changing");
+    is(childCS.textIndent, "50px",
+       "child text-indent should be 50px before changing");
+    is(childCS.letterSpacing, "10px",
+       "child letter-spacing should be 10px before changing");
+    test.childCS = childCS;
+}
+
+// Test transitions that are also from-display:none, to-display:none, and
+// display:none throughout.
+var from_none_test, to_none_test, always_none_test;
+function make_display_test(initially_none, text)
+{
+    var p = document.createElement("p");
+    p.appendChild(document.createTextNode(text));
+    p.style.textIndent = "0px";
+    p.style.MozTransition = "8s text-indent ease-in-out";
+    if (initially_none)
+        p.style.display = "none";
+    div.appendChild(p);
+    return p;
+}
+from_none_test   = make_display_test(true,  "transition from display:none");
+to_none_test     = make_display_test(false, "transition to display:none");
+always_none_test = make_display_test(true,  "transition always display:none");
+var display_tests = [ from_none_test, to_none_test, always_none_test ];
+
+// FIXME: Test a transition that reverses partway through.
+
+// flush style changes
+var x = getComputedStyle(div, "").color;
+
+// Start our timer as close as possible to when we start the first
+// transition.
+// Do not use setInterval because once it gets off in time, it stays off.
+for (var i = 1; i <= 8; ++i) {
+    setTimeout(process_future_calls, i * 1000, i);
+}
+gStartTime1 = Date.now(); // set before any transitions have started
+
+// Start all the transitions.
+for (var test in tftests) {
+    var p = tftests[test][0];
+    var tf = tftests[test][1];
+    p.style.textIndent = "100px";
+}
+for (var d in delay_tests) {
+    var p = delay_tests[d];
+    p.style.marginLeft = "100px";
+}
+reset_test.style.marginLeft = "100px";
+for (var i in descendant_tests) {
+    var test = descendant_tests[i];
+    test.parentNode.style.textIndent = "150px";
+    test.parentNode.style.letterSpacing = "5px";
+}
+from_none_test.style.textIndent = "100px";
+from_none_test.style.display = "";
+to_none_test.style.textIndent = "100px";
+to_none_test.style.display = "none";
+always_none_test.style.textIndent = "100px";
+
+// flush style changes
+x = getComputedStyle(div, "").color;
+
+gStartTime2 = Date.now(); // set after all transitions have started
+
+function check_tf_test(time_portion) {
+    for (var test in tftests) {
+        var p = tftests[test][0];
+        var tf = tftests[test][1];
+
+        var vpt = timingFunctions[tf][time_portion * 4];
+        var value_portion = vpt[0];
+        var tolerance = vpt[1];
+
+        if (time_portion == 0)
+            tolerance = 0; // no timer is involved
+
+        var cvorig = getComputedStyle(p, "").textIndent;
+
+        // remove the "px" if present
+        var cval = cvorig;
+        if (cval == "0") cval = "0px";
+        cval = cval.substring(0, cval.length - 2);
+
+        var error = Math.abs(Number(cval) - 100 * value_portion);
+        var func = ok;
+        if (tf == "cubic-bezier(1, 0, 0, 1)" && time_portion == 0.5 &&
+            error > 1000) {
+            // Bug 501569 (nsSMILKeySpline(1, 0, 0, 1) miscalculates
+            // values just under 0.5) *sometimes* causes a problem for
+            // cubic-bezier(1, 0, 0, 0) at time_portion == 0.5.  So if
+            // there's a very large error, mark this as a todo.
+            func = todo;
+        }
+        func(error <= tolerance * 100,
+           "timing function test: computed value " + cvorig +
+           " should be within " + (tolerance * 100) + "px of " +
+           (100 * value_portion) + "px" +
+           " for timing function " + tf + " at time " + time_portion * 8 +
+           "s.");
+    }
+}
+
+check_tf_test(0);
+add_future_call(2, function() { check_tf_test(0.25); });
+add_future_call(4, function() { check_tf_test(0.50); });
+add_future_call(6, function() { check_tf_test(0.75); });
+add_future_call(8, function() { check_tf_test(1.00); });
+
+function check_delay_test(time)
+{
+    var tf = timingFunctions["ease-out"];
+    for (var d in delay_tests) {
+        var p = delay_tests[d];
+        var time_portion = (time - d) / 4;
+
+        var tolerance, value_portion;
+        if (time_portion < 0 || (time_portion == 0 && time == 0)) {
+            tolerance = 0;
+            value_portion = 0;
+        } else if (time_portion <= 1) {
+            var tfitem = tf[time_portion * 4];
+            value_portion = tfitem[0];
+            tolerance = tfitem[1];
+        } else {
+            tolerance = 0;
+            value_portion = 1;
+        }
+
+        var cvorig = getComputedStyle(p, "").marginLeft;
+
+        // remove the "px" if present
+        var cval = cvorig;
+        if (cval == "0") cval = "0px";
+        cval = cval.substring(0, cval.length - 2);
+
+        // allow to be within tolerance of the exact value
+        ok(Math.abs(Number(cval) - 100 * value_portion) <= tolerance * 100,
+           "delay test: computed value " + cvorig +
+           " should be within " + (tolerance * 100) + "px of " +
+           (100 * value_portion) + "px" +
+           " for delay " + d + "s at time " + time + "s.");
+    }
+}
+
+check_delay_test(0);
+for (var i = 1; i <= 8; ++i) {
+    (function(j) {
+        add_future_call(j, function() { check_delay_test(j); });
+    })(i);
+}
+
+function reset_reset_test(time)
+{
+    reset_test.style.marginLeft = "0px";
+}
+function check_reset_test(time)
+{
+    is(getComputedStyle(reset_test, "").marginLeft, "0px",
+       "reset test value at time " + time + "s.");
+}
+setTimeout(reset_reset_test, 1000); // must always run, even if late
+check_reset_test(0);
+for (var i = 1; i <= 8; ++i) {
+    (function(j) {
+        add_future_call(j, function() { check_reset_test(j); });
+    })(i);
+}
+
+check_descendant_tests(0);
+add_future_call(2, function() { check_descendant_tests(2); });
+add_future_call(6, function() { check_descendant_tests(6); });
+
+function check_descendant_tests(time) {
+    // text-indent: transition from 50px to 150px
+    // letter-spacing: transition from 10px to 5px
+    var values = {};
+    values["text-indent"] = [ 50, 150 ];
+    values["letter-spacing"] = [ 10, 5 ];
+    var tf = timingFunctions["ease"];
+
+    for (var i in descendant_tests) {
+        var test = descendant_tests[i];
+
+        /* ti=text-indent, ls=letter-spacing */
+        var child_ti_duration = 0;
+        var child_ls_duration = 0;
+        var child_ti_delay = 0;
+        var child_ls_delay = 0;
+
+        if (test.parent_transition != "") {
+            var props = test.parent_transition.split(" ");
+            var duration = parseInt(props[0]);
+            var delay = (props.length > 2) ? parseInt(props[2]) : 0;
+            var property = props[1];
+            if (property == "text-indent") {
+                child_ti_duration = duration;
+                child_ti_delay = delay;
+            } else if (property == "letter-spacing") {
+                child_ls_duration = duration;
+                child_ls_delay = delay;
+            } else {
+                ok(false, "fix this test (unexpected transition-property " +
+                          property + " on parent)");
+            }
+        }
+
+        if (test.child_transition != "") {
+            var props = test.child_transition.split(" ");
+            var duration = parseInt(props[0]);
+            var delay = (props.length > 2) ? parseInt(props[2]) : 0;
+            var property = props[1];
+            if (property != "text-indent" && property != "letter-spacing" &&
+                property != "all") {
+                ok(false, "fix this test (unexpected transition-property " +
+                          property + " on child)");
+            }
+
+            if (property != "letter-spacing" && child_ti_duration == 0) {
+                child_ti_duration = duration;
+                child_ti_delay = delay;
+            }
+            if (property != "text-indent" && child_ls_duration == 0) {
+                child_ls_duration = duration;
+                child_ls_delay = delay;
+            }
+        }
+
+        var time_portions = {};
+        time_portions["text-indent"] = (child_ti_duration == 0) ? 2 :
+            ((time - child_ti_delay) / child_ti_duration);
+        time_portions["letter-spacing"] = (child_ls_duration == 0) ? 2 :
+             ((time - child_ls_delay) / child_ls_duration);
+
+        for (var prop in {"text-indent": true, "letter-spacing": true}) {
+            var time_portion = time_portions[prop];
+            var tolerance, value_portion;
+            if (time_portion < 0 || (time_portion == 0 && time == 0)) {
+                tolerance = 0;
+                value_portion = 0;
+            } else if (time_portion <= 1) {
+                var tfitem = tf[time_portion * 4];
+                value_portion = tfitem[0];
+                tolerance = tfitem[1];
+            } else {
+                tolerance = 0;
+                value_portion = 1;
+            }
+
+            var value = px_to_num(test.childCS.getPropertyValue(prop));
+            var expected = (1 - value_portion) * values[prop][0] +
+                           value_portion       * values[prop][1];
+            var error_allowed = Math.abs(values[prop][0] - values[prop][1]) *
+                                tolerance;
+
+            ok(Math.abs(value - expected) <= error_allowed,
+               "descendant test: " + prop + " computed value " + value +
+               "px should be within " + error_allowed + "px of " +
+               expected + "px" +
+               " for test " + i + " at time " + time + "s.");
+        }
+    }
+}
+
+function check_display_tests(time)
+{
+    var tf = timingFunctions["ease-in-out"];
+    for (var i in display_tests) {
+        var p = display_tests[i];
+        var time_portion = time / 8;
+
+        var tolerance, value_portion;
+        if (time_portion < 0 || (time_portion == 0 && time == 0)) {
+            tolerance = 0;
+            value_portion = 0;
+        } else if (time_portion <= 1) {
+            var tfitem = tf[time_portion * 4];
+            value_portion = tfitem[0];
+            tolerance = tfitem[1];
+        } else {
+            tolerance = 0;
+            value_portion = 1;
+        }
+
+        var cvorig = getComputedStyle(p, "").textIndent;
+
+        // remove the "px" if present
+        var cval = cvorig;
+        if (cval == "0") cval = "0px";
+        cval = cval.substring(0, cval.length - 2);
+
+        // allow to be within tolerance of the exact value
+        ok(Math.abs(Number(cval) - 100 * value_portion) <= tolerance * 100,
+           "display test: computed value " + cvorig +
+           " should be within " + (tolerance * 100) + "px of " +
+           (100 * value_portion) + "px" +
+           " for test with " + p.childNodes[0].data +
+           " at time " + time + "s.");
+    }
+}
+
+check_display_tests(0);
+add_future_call(2, function() { check_display_tests(2); });
+add_future_call(4, function() { check_display_tests(4); });
+add_future_call(6, function() { check_display_tests(6); });
+add_future_call(8, function() { check_display_tests(8); });
+
+</script>
+</pre>
+</body>
+</html>
diff --git a/layout/style/test/test_transitions_per_property.html b/layout/style/test/test_transitions_per_property.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_transitions_per_property.html
@@ -0,0 +1,131 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=435441
+-->
+<head>
+  <title>Test for Bug 435441</title>
+  <script type="application/javascript" src="/MochiKit/packed.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript" src="property_database.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+  <style type="text/css">
+
+  #display > p { margin-top: 0; margin-bottom: 0; }
+
+  </style>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=435441">Mozilla Bug 435441</a>
+<div id="display">
+
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 435441 **/
+
+// Run tests simultaneously so we don't have to take up too much time.
+SimpleTest.waitForExplicitFinish();
+var gTestsRunning = 0;
+function TestStarted() { ++gTestsRunning; }
+function TestFinished() { if (--gTestsRunning == 0) SimpleTest.finish(); }
+
+// An array of arrays of functions to be called at the outer index number
+// of seconds after the present.
+var gFutureCalls = [];
+
+function add_future_call(index, func)
+{
+    if (!(index in gFutureCalls)) {
+        gFutureCalls[index] = [];
+    }
+    gFutureCalls[index].push(func);
+    TestStarted();
+}
+var gStartTime1, gStartTime2;
+function process_future_calls(index)
+{
+    var calls = gFutureCalls[index];
+    if (!calls)
+        return;
+    var ms_late1 = Date.now() - gStartTime1 - 1000 * index;
+    var ms_late2 = Date.now() - gStartTime2 - 1000 * index;
+    // our real tolerance is 40ms (1% of 4s)
+    if (Math.abs(ms_late1) > 35 || Math.abs(ms_late2) > 35) {
+        todo(false, "Timer for tests at time " + index + "s was fired " +
+                    ms_late2 + "ms - " + ms_late1 + "ms late, so skipping " +
+                    "tests for being outside of tolerable range.");
+    } else {
+        for (var i = 0; i < calls.length; ++i) {
+            calls[i]();
+        }
+    }
+    for (var i = 0; i < calls.length; ++i) {
+        TestFinished();
+    }
+}
+
+var supported_properties = {
+    "margin-top": [ test_length_transition, test_percent_transition ],
+    "margin-right": [ test_length_transition, test_percent_transition ],
+    "margin-bottom": [ test_length_transition, test_percent_transition ],
+    "margin-left": [ test_length_transition, test_percent_transition ],
+    "padding-top": [ test_length_transition, test_percent_transition ],
+    "padding-right": [ test_length_transition, test_percent_transition ],
+    "padding-bottom": [ test_length_transition, test_percent_transition ],
+    "padding-left": [ test_length_transition, test_percent_transition ],
+    "top": [ test_length_transition, test_percent_transition ],
+    "right": [ test_length_transition, test_percent_transition ],
+    "bottom": [ test_length_transition, test_percent_transition ],
+    "left": [ test_length_transition, test_percent_transition ],
+    "outline-width": [ test_length_transition, test_percent_transition ],
+    "width": [ test_length_transition, test_percent_transition ],
+    "min-width": [ test_length_transition, test_percent_transition ],
+    "max-width": [ test_length_transition, test_percent_transition ],
+    "height": [ test_length_transition, test_percent_transition ],
+    "min-height": [ test_length_transition, test_percent_transition ],
+    "max-height": [ test_length_transition, test_percent_transition ],
+    "vertical-align": [ test_length_transition, test_percent_transition ],
+    "letter-spacing": [ test_length_transition, test_percent_transition ],
+    "line-height": [ test_length_transition, test_percent_transition ],
+    "text-indent": [ test_length_transition, test_percent_transition ],
+    "marker-offset": [ test_length_transition, test_percent_transition ],
+    "-moz-column-width": [ test_length_transition, test_percent_transition ],
+    "-moz-column-gap": [ test_length_transition, test_percent_transition ],
+    "stroke-dashoffset": [ test_length_transition, test_percent_transition ],
+    "stroke-width": [ test_length_transition, test_percent_transition ],
+    "outline-offset": [ test_length_transition ],
+    "word-spacing": [ test_length_transition ]
+};
+
+var prop;
+for (prop in supported_properties) {
+    // FIXME: Test that prop is in the property database and that the
+    // entry has at least one test function.
+}
+
+for (prop in gCSSProperties) {
+    // FIXME: If not in supported properties, tests that transitions
+    // don't do anything.
+}
+
+for (prop in supported_properties) {
+    // FIXME: Start actual transition tests.
+}
+
+function test_length_transition() {
+    // FIXME: write me
+}
+
+function test_percent_transition() {
+    // FIXME: write me
+}
+
+// FIXME: REMOVE ME (temporary, to cause test to finish)
+SimpleTest.finish();
+
+</script>
+</pre>
+</body>
+</html>
diff --git a/xpcom/ds/TimeStamp.h b/xpcom/ds/TimeStamp.h
--- a/xpcom/ds/TimeStamp.h
+++ b/xpcom/ds/TimeStamp.h
@@ -206,16 +206,28 @@ public:
     NS_ASSERTION(!aOther.IsNull(), "Cannot compute with aOther null value");
     return mValue >= aOther.mValue;
   }
   PRBool operator>(const TimeStamp& aOther) const {
     NS_ASSERTION(!IsNull(), "Cannot compute with a null value");
     NS_ASSERTION(!aOther.IsNull(), "Cannot compute with aOther null value");
     return mValue > aOther.mValue;
   }
+  PRBool operator==(const TimeStamp& aOther) const {
+    // Maybe it's ok to check == with null timestamps?
+    NS_ASSERTION(!IsNull(), "Cannot compute with a null value");
+    NS_ASSERTION(!aOther.IsNull(), "Cannot compute with aOther null value");
+    return mValue == aOther.mValue;
+  }
+  PRBool operator!=(const TimeStamp& aOther) const {
+    // Maybe it's ok to check != with null timestamps?
+    NS_ASSERTION(!IsNull(), "Cannot compute with a null value");
+    NS_ASSERTION(!aOther.IsNull(), "Cannot compute with aOther null value");
+    return mValue != aOther.mValue;
+  }
 
   // Comparing TimeStamps for equality should be discouraged. Adding
   // two TimeStamps, or scaling TimeStamps, is nonsense and must never
   // be allowed.
 
   static NS_HIDDEN_(nsresult) Startup();
   static NS_HIDDEN_(void) Shutdown();
 
