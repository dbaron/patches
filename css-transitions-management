From: L. David Baron <dbaron@dbaron.org>

Implement CSS transitions:  handle starting and management of the animations.  (Bug 435441)

diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -65,16 +65,17 @@
 #include "nsChangeHint.h"
 // This also pulls in gfxTypes.h, which we cannot include directly.
 #include "gfxRect.h"
 #include "nsRegion.h"
 #include "nsTArray.h"
 #include "nsAutoPtr.h"
 #include "nsThreadUtils.h"
 #include "nsContentUtils.h"
+#include "nsTransitionManager.h"
 
 class nsImageLoader;
 #ifdef IBMBIDI
 class nsBidiPresUtils;
 #endif // IBMBIDI
 
 struct nsRect;
 
@@ -208,16 +209,18 @@ public:
       return mDocument;
   }
 
 #ifdef _IMPL_NS_LAYOUT
   nsStyleSet* StyleSet() { return GetPresShell()->StyleSet(); }
 
   nsFrameManager* FrameManager()
     { return GetPresShell()->FrameManager(); } 
+
+  nsTransitionManager* TransitionManager() { return &mTransitionManager; }
 #endif
 
   /**
    * Rebuilds all style data by throwing out the old rule tree and
    * building a new one, and additionally applying aExtraHint (which
    * must not contain nsChangeHint_ReconstructFrame) to the root frame.
    * Also rebuild the user font set.
    */
@@ -798,16 +801,26 @@ public:
     return !mSameDocDirtyRegion.IsEmpty() || !mCrossDocDirtyRegion.IsEmpty();
   }
 
   void ClearMozAfterPaintEvents() {
     mSameDocDirtyRegion.SetEmpty();
     mCrossDocDirtyRegion.SetEmpty();
   }
 
+  PRBool IsProcessingAnimationStyleChange() const {
+    return mProcessingAnimationStyleChange;
+  }
+
+  void SetProcessingAnimationStyleChange(PRBool aProcessing) {
+    NS_ASSERTION(aProcessing != mProcessingAnimationStyleChange,
+                 "should never nest");
+    mProcessingAnimationStyleChange = aProcessing;
+  }
+
   /**
    * Notify the prescontext that the presshell is about to reflow a reflow root.
    * The single argument indicates whether this reflow should be interruptible.
    * If aInterruptible is false then CheckForInterrupt and HasPendingInterrupt
    * will always return false. If aInterruptible is true then CheckForInterrupt
    * will return true when a pending event is detected.  This is for use by the
    * presshell only.  Reflow code wanting to prevent interrupts should use
    * InterruptPreventer.
@@ -897,16 +910,17 @@ protected:
   nsCOMPtr<nsIDocument> mDocument;
   nsIDeviceContext*     mDeviceContext; // [STRONG] could be weak, but
                                         // better safe than sorry.
                                         // Cannot reintroduce cycles
                                         // since there is no dependency
                                         // from gfx back to layout.
   nsIEventStateManager* mEventManager;  // [STRONG]
   nsILookAndFeel*       mLookAndFeel;   // [STRONG]
+  nsTransitionManager   mTransitionManager;
   nsIAtom*              mMedium;        // initialized by subclass ctors;
                                         // weak pointer to static atom
 
   nsILinkHandler*       mLinkHandler;   // [WEAK]
   nsIAtom*              mLangGroup;     // [STRONG]
 
   nsRefPtrHashtable<nsVoidPtrHashKey, nsImageLoader>
                         mImageLoaders[IMAGE_LOAD_TYPE_COUNT];
@@ -1005,20 +1019,20 @@ protected:
   unsigned              mGetUserFontSetCalled : 1;
   // Do we currently have an event posted to call FlushUserFontSet?
   unsigned              mPostedFlushUserFontSet : 1;
 
   // resize reflow is supressed when the only change has been to zoom
   // the document rather than to change the document's dimensions
   unsigned              mSupressResizeReflow : 1;
 
-#ifdef IBMBIDI
   unsigned              mIsVisual : 1;
 
-#endif
+  unsigned              mProcessingAnimationStyleChange : 1;
+
 #ifdef DEBUG
   PRBool                mInitialized;
 #endif
 
 
 protected:
 
   ~nsPresContext() NS_HIDDEN;
diff --git a/layout/build/nsLayoutStatics.cpp b/layout/build/nsLayoutStatics.cpp
--- a/layout/build/nsLayoutStatics.cpp
+++ b/layout/build/nsLayoutStatics.cpp
@@ -80,16 +80,17 @@
 #include "nsCCUncollectableMarker.h"
 #include "nsTextFragment.h"
 #include "nsCSSRuleProcessor.h"
 #include "nsXMLHttpRequest.h"
 #include "nsDOMThreadService.h"
 #include "nsHTMLDNSPrefetch.h"
 #include "nsCrossSiteListenerProxy.h"
 #include "nsFocusManager.h"
+#include "nsTransitionManager.h"
 
 #ifdef MOZ_XUL
 #include "nsXULPopupManager.h"
 #include "nsXULContentUtils.h"
 #include "nsXULElement.h"
 #include "nsXULPrototypeCache.h"
 #include "nsXULTooltipListener.h"
 
@@ -273,16 +274,17 @@ nsLayoutStatics::Initialize()
   nsHTMLMediaElement::InitMediaTypes();
 #endif
 
 #ifdef MOZ_SYDNEYAUDIO
   nsAudioStream::InitLibrary();
 #endif
 
   nsCrossSiteListenerProxy::Startup();
+  nsTransitionManager::InitializeAnimationInfo();
 
   return NS_OK;
 }
 
 void
 nsLayoutStatics::Shutdown()
 {
   nsFocusManager::Shutdown();
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -95,16 +95,17 @@
 #include "nsStyleChangeList.h"
 #include "nsIDOMRange.h"
 #include "nsITableLayout.h"    //selection necessity
 #include "nsITableCellLayout.h"//  "
 #include "nsITextControlFrame.h"
 #include "nsINameSpaceManager.h"
 #include "nsIPercentHeightObserver.h"
 #include "nsStyleStructInlines.h"
+#include "nsCSSProps.h"
 
 #ifdef IBMBIDI
 #include "nsBidiPresUtils.h"
 #endif
 
 // For triple-click pref
 #include "nsIServiceManager.h"
 #include "imgIContainer.h"
@@ -569,16 +570,22 @@ nsFrame::DidSetStyleContext(nsStyleConte
 
   // If the page contains markup that overrides text direction, and
   // does not contain any characters that would activate the Unicode
   // bidi algorithm, we need to call |SetBidiEnabled| on the pres
   // context before reflow starts.  See bug 115921.
   if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
     PresContext()->SetBidiEnabled();
   }
+
+  if (aOldStyleContext) {
+    PresContext()->TransitionManager()->
+      StyleContextChanged(this, aOldStyleContext);
+  }
+  
 }
 
 /* virtual */ nsMargin
 nsIFrame::GetUsedMargin() const
 {
   NS_ASSERTION(nsLayoutUtils::sDisableGetUsedXAssertions ||
                !NS_SUBTREE_DIRTY(this) ||
                (GetStateBits() & NS_FRAME_IN_REFLOW),
diff --git a/layout/style/Makefile.in b/layout/style/Makefile.in
--- a/layout/style/Makefile.in
+++ b/layout/style/Makefile.in
@@ -120,16 +120,17 @@ EXPORTS		= \
 		nsStyleCoord.h \
 		nsStyleSet.h \
 		nsStyleStruct.h \
 		nsStyleStructFwd.h \
 		nsStyleStructInlines.h \
 		nsStyleStructList.h \
 		nsStyleTransformMatrix.h \
 		nsStyleUtil.h \
+		nsTransitionManager.h \
 		$(NULL)
 
 CPPSRCS		= \
 		nsCSSAnonBoxes.cpp \
 		nsCSSDataBlock.cpp \
 		nsCSSDeclaration.cpp \
 		nsCSSKeywords.cpp \
 		nsCSSLoader.cpp \
@@ -160,16 +161,17 @@ CPPSRCS		= \
 		nsROCSSPrimitiveValue.cpp \
 		nsRuleNode.cpp \
 		nsStyleContext.cpp \
 		nsStyleCoord.cpp \
 		nsStyleSet.cpp \
 		nsStyleStruct.cpp \
 		nsStyleTransformMatrix.cpp \
 		nsStyleUtil.cpp \
+		nsTransitionManager.cpp \
 		$(NULL)
 
 FORCE_STATIC_LIB = 1
 
 include $(topsrcdir)/config/rules.mk
 
 LOCAL_INCLUDES	= \
 		-I$(srcdir)/../../content/base/src \
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
new file mode 100644
--- /dev/null
+++ b/layout/style/nsTransitionManager.cpp
@@ -0,0 +1,335 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsTransitionManager.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsTransitionManager.h"
+#include "nsIFrame.h"
+#include "nsCSSProps.h"
+
+/*****************************************************************************
+ * Per-CSS-property data                                                     *
+ *****************************************************************************/
+
+struct CSSPropertyAnimationInfo {
+  enum Type {
+    eCannotAnimate,
+    eStyleSides,
+    eStyleCoord,
+    eNsCoord
+  };
+
+  Type mType;
+  PRUint32 mIndex;
+};
+
+struct ArbitraryStyleStruct; /* dummy type */
+
+struct StyleSidesAnimationInfo {
+  typedef nsStyleSides location_type;
+
+  nsCSSProperty mProperty;
+  nsStyleSides ArbitraryStyleStruct::* mLocation;
+  PRUint8 mSide;
+};
+
+static const StyleSidesAnimationInfo gStyleSidesAnimInfo[] = {
+  { eCSSProperty_margin_top, (nsStyleSides ArbitraryStyleStruct::*)&nsStyleMargin::mMargin, NS_SIDE_TOP },
+  { eCSSProperty_margin_right, (nsStyleSides ArbitraryStyleStruct::*)&nsStyleMargin::mMargin, NS_SIDE_RIGHT },
+  { eCSSProperty_margin_bottom, (nsStyleSides ArbitraryStyleStruct::*)&nsStyleMargin::mMargin, NS_SIDE_BOTTOM },
+  { eCSSProperty_margin_left, (nsStyleSides ArbitraryStyleStruct::*)&nsStyleMargin::mMargin, NS_SIDE_LEFT },
+  { eCSSProperty_padding_top, (nsStyleSides ArbitraryStyleStruct::*)&nsStylePadding::mPadding, NS_SIDE_TOP },
+  { eCSSProperty_padding_right, (nsStyleSides ArbitraryStyleStruct::*)&nsStylePadding::mPadding, NS_SIDE_RIGHT },
+  { eCSSProperty_padding_bottom, (nsStyleSides ArbitraryStyleStruct::*)&nsStylePadding::mPadding, NS_SIDE_BOTTOM },
+  { eCSSProperty_padding_left, (nsStyleSides ArbitraryStyleStruct::*)&nsStylePadding::mPadding, NS_SIDE_LEFT },
+  { eCSSProperty_top, (nsStyleSides ArbitraryStyleStruct::*)&nsStylePosition::mOffset, NS_SIDE_TOP },
+  { eCSSProperty_right, (nsStyleSides ArbitraryStyleStruct::*)&nsStylePosition::mOffset, NS_SIDE_RIGHT },
+  { eCSSProperty_bottom, (nsStyleSides ArbitraryStyleStruct::*)&nsStylePosition::mOffset, NS_SIDE_BOTTOM },
+  { eCSSProperty_left, (nsStyleSides ArbitraryStyleStruct::*)&nsStylePosition::mOffset, NS_SIDE_LEFT }
+};
+
+struct StyleCoordAnimationInfo {
+  typedef nsStyleCoord location_type;
+
+  nsCSSProperty mProperty;
+  nsStyleCoord ArbitraryStyleStruct::* mLocation;
+};
+
+// for animation length->length, percent->percent, or number->number
+static const StyleCoordAnimationInfo gStyleCoordAnimInfo[] = {
+  { eCSSProperty_outline_width, (nsStyleCoord ArbitraryStyleStruct::*)&nsStyleOutline::mOutlineWidth },
+  { eCSSProperty_width, (nsStyleCoord ArbitraryStyleStruct::*)&nsStylePosition::mWidth },
+  { eCSSProperty_min_width, (nsStyleCoord ArbitraryStyleStruct::*)&nsStylePosition::mMinWidth },
+  { eCSSProperty_max_width, (nsStyleCoord ArbitraryStyleStruct::*)&nsStylePosition::mMaxWidth },
+  { eCSSProperty_height, (nsStyleCoord ArbitraryStyleStruct::*)&nsStylePosition::mHeight },
+  { eCSSProperty_min_height, (nsStyleCoord ArbitraryStyleStruct::*)&nsStylePosition::mMinHeight },
+  { eCSSProperty_max_height, (nsStyleCoord ArbitraryStyleStruct::*)&nsStylePosition::mMaxHeight },
+  { eCSSProperty_vertical_align, (nsStyleCoord ArbitraryStyleStruct::*)&nsStyleTextReset::mVerticalAlign },
+  { eCSSProperty_letter_spacing, (nsStyleCoord ArbitraryStyleStruct::*)&nsStyleText::mLetterSpacing },
+  { eCSSProperty_line_height, (nsStyleCoord ArbitraryStyleStruct::*)&nsStyleText::mLineHeight },
+  { eCSSProperty_text_indent, (nsStyleCoord ArbitraryStyleStruct::*)&nsStyleText::mTextIndent },
+  { eCSSProperty_marker_offset, (nsStyleCoord ArbitraryStyleStruct::*)&nsStyleContent::mMarkerOffset },
+  { eCSSProperty__moz_column_width, (nsStyleCoord ArbitraryStyleStruct::*)&nsStyleColumn::mColumnWidth },
+  { eCSSProperty__moz_column_gap, (nsStyleCoord ArbitraryStyleStruct::*)&nsStyleColumn::mColumnGap },
+  { eCSSProperty_stroke_dashoffset, (nsStyleCoord ArbitraryStyleStruct::*)&nsStyleSVG::mStrokeDashoffset },
+  { eCSSProperty_stroke_width, (nsStyleCoord ArbitraryStyleStruct::*)&nsStyleSVG::mStrokeWidth }
+};
+
+struct NsCoordAnimationInfo {
+  typedef nscoord location_type;
+
+  nsCSSProperty mProperty;
+  nscoord ArbitraryStyleStruct::* mLocation;
+};
+
+static const NsCoordAnimationInfo gNsCoordAnimInfo[] = {
+  { eCSSProperty_outline_offset, (nscoord ArbitraryStyleStruct::*)&nsStyleOutline::mOutlineOffset },
+  { eCSSProperty_word_spacing, (nscoord ArbitraryStyleStruct::*)&nsStyleText::mWordSpacing }
+};
+
+static CSSPropertyAnimationInfo gAnimInfo[eCSSProperty_COUNT_no_shorthands];
+
+// Have an "*Internal" version so a specialized form can call the
+// general form and then modify the result.
+template <class InfoType>
+static inline const typename InfoType::location_type&
+GetPropertyValueInternal(nsStyleContext *aStyleContext, const InfoType& aInfo)
+{
+    const void* styleStructV =
+      aStyleContext->GetStyleData(nsCSSProps::kSIDTable[aInfo.mProperty]);
+    const ArbitraryStyleStruct* styleStructA =
+      static_cast<const ArbitraryStyleStruct*>(styleStructV);
+    return styleStructA->*(aInfo.mLocation);
+}
+
+// General version
+template <class InfoType>
+static inline const typename InfoType::location_type&
+GetPropertyValue(nsStyleContext *aStyleContext, const InfoType& aInfo)
+{
+    return GetPropertyValueInternal(aStyleContext, aInfo);
+}
+
+// Version specific to nsStyleSides.
+static inline nsStyleCoord
+GetPropertyValue(nsStyleContext *aStyleContext,
+                 const StyleSidesAnimationInfo& aInfo)
+{
+    return GetPropertyValueInternal(aStyleContext, aInfo).Get(aInfo.mSide);
+}
+
+/* static */ void
+nsTransitionManager::InitializeAnimationInfo()
+{
+  for (PRUint32 i = 0; i < eCSSProperty_COUNT_no_shorthands; ++i) {
+    gAnimInfo[i].mType = CSSPropertyAnimationInfo::eCannotAnimate;
+  }
+
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gStyleSidesAnimInfo); ++i) {
+    nsCSSProperty prop = gStyleSidesAnimInfo[i].mProperty;
+    gAnimInfo[prop].mType = CSSPropertyAnimationInfo::eStyleSides;
+    gAnimInfo[prop].mIndex = i;
+  }
+
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gStyleCoordAnimInfo); ++i) {
+    nsCSSProperty prop = gStyleCoordAnimInfo[i].mProperty;
+    gAnimInfo[prop].mType = CSSPropertyAnimationInfo::eStyleCoord;
+    gAnimInfo[prop].mIndex = i;
+  }
+
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gNsCoordAnimInfo); ++i) {
+    nsCSSProperty prop = gNsCoordAnimInfo[i].mProperty;
+    gAnimInfo[prop].mType = CSSPropertyAnimationInfo::eNsCoord;
+    gAnimInfo[prop].mIndex = i;
+  }
+}
+
+/*****************************************************************************
+ * Per-Frame data                                                            *
+ *****************************************************************************/
+
+struct FrameTransitions : public PRCList {
+};
+
+/*****************************************************************************
+ * nsTransitionManager                                                       *
+ *****************************************************************************/
+
+nsTransitionManager::nsTransitionManager()
+{
+    PR_INIT_CLIST(&mFrameTransitions);
+}
+
+nsTransitionManager::~nsTransitionManager()
+{
+    // This is essentially asserting that all frames have been destroyed
+    // before the pres context.
+    NS_ABORT_IF_FALSE(PR_CLIST_IS_EMPTY(&mFrameTransitions),
+                      "all transitions must be destroyed");
+}
+
+static PRBool
+ShouldAnimateStyleCoords(const nsStyleCoord& aOldVal,
+                         const nsStyleCoord& aNewVal)
+{
+    return aOldVal != aNewVal &&
+           aOldVal.GetUnit() == aNewVal.GetUnit() &&
+           (aOldVal.GetUnit() == eStyleUnit_Coord ||
+            aOldVal.GetUnit() == eStyleUnit_Percent);
+}
+
+static void
+ConsiderStartingTransition(nsCSSProperty aProperty,
+                           nsIFrame *aFrame,
+                           nsStyleContext *aOldStyleContext)
+{
+    // IsShorthand itself will assert if aProperty is not a property.
+    NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(aProperty),
+                      "property out of range");
+
+    const CSSPropertyAnimationInfo& animInfo = gAnimInfo[aProperty];
+
+    // FIXME: Adjust old value (how?) if there's currently a transition
+    // for this frame+property!
+    // FIXME: Check to see if aProperty has changed, and if it has, start
+    // a transition as appropriate (considering currently running
+    // transitions as appropriate).
+    // Do NOT compare to aOldStyleContext if we already have a transition
+    // going for this property (even if it hasn't moved yet).
+
+    PRBool doStart;
+    switch (animInfo.mType) {
+        case CSSPropertyAnimationInfo::eCannotAnimate: {
+            doStart = PR_FALSE;
+            break;
+        }
+        case CSSPropertyAnimationInfo::eStyleSides: {
+            const StyleSidesAnimationInfo& sidesInfo =
+              gStyleSidesAnimInfo[animInfo.mIndex];
+            const nsStyleCoord &oldVal =
+              GetPropertyValue(aOldStyleContext, sidesInfo);
+            const nsStyleCoord &newVal =
+              GetPropertyValue(aFrame->GetStyleContext(), sidesInfo);
+            doStart = ShouldAnimateStyleCoords(oldVal, newVal);
+            break;
+        }
+        case CSSPropertyAnimationInfo::eStyleCoord: {
+            const StyleCoordAnimationInfo& coordInfo =
+              gStyleCoordAnimInfo[animInfo.mIndex];
+            const nsStyleCoord &oldVal =
+              GetPropertyValue(aOldStyleContext, coordInfo);
+            const nsStyleCoord &newVal =
+              GetPropertyValue(aFrame->GetStyleContext(), coordInfo);
+            doStart = ShouldAnimateStyleCoords(oldVal, newVal);
+            break;
+        }
+        case CSSPropertyAnimationInfo::eNsCoord: {
+            const StyleCoordAnimationInfo& coordInfo =
+              gStyleCoordAnimInfo[animInfo.mIndex];
+            const nsStyleCoord &oldVal =
+              GetPropertyValue(aOldStyleContext, coordInfo);
+            const nsStyleCoord &newVal =
+              GetPropertyValue(aFrame->GetStyleContext(), coordInfo);
+            doStart = oldVal != newVal;
+            break;
+        }
+    }
+
+    if (!doStart) {
+        return;
+    }
+
+    // Should we associate transitions with the frame or the content
+    // node?
+    //   + advantages of content:
+    //      - can transition when there's a framechange too (except it
+    //        would still be hard to figure out when a frame is new or
+    //        replacing something else)
+    //      - condenses work across continuations
+    //   + advantages of frame:
+    //      - deals with pseudo-elements and things inside
+    //        pseudo-elements better (though we could deal with
+    //        :before/:after elsewhere, which are the important ones,
+    //        but stuff inside :first-line is harder)
+    //      - avoids confusion when multiple frames per content node
+    // For now, I'll associate them with the frame.
+    //
+    // To get lifetime issues right, I'll store them in objects stored
+    // as a property on the frame which are themselves linked in a
+    // master list (or array?) so we can find all current transitions
+    // quickly.
+    // (Then we can take advantage of frame property destructors...
+    // although those don't necessarily need to call an actual
+    // destructor.)
+    
+}
+
+void
+nsTransitionManager::StyleContextChanged(nsIFrame *aFrame,
+                                         nsStyleContext *aOldStyleContext)
+{
+    if (aFrame->PresContext()->IsProcessingAnimationStyleChange()) {
+        return;
+    }
+
+    const nsStyleDisplay *disp = aFrame->GetStyleDisplay();
+    for (PRUint32 i = 0, i_end = disp->mTransitions.Length(); i < i_end; ++i) {
+        const nsTransition& t = disp->mTransitions[i];
+        // Check delay and duration first, since they default to zero, and
+        // when they're both zero, we can ignore the transition.
+        if (t.GetDelay() != 0.0f || t.GetDuration() != 0.0f) {
+            // We might have something to transition.  See if any of the
+            // properties in question changed and are animatable.
+            nsCSSProperty property = t.GetProperty();
+            if (property == eCSSPropertyExtra_no_properties ||
+                property == eCSSProperty_UNKNOWN) {
+                // Nothing to do, but need to exclude this from cases below.
+            } else if (property == eCSSPropertyExtra_all_properties) {
+                for (nsCSSProperty p = nsCSSProperty(0); 
+                     p < eCSSProperty_COUNT_no_shorthands;
+                     p = nsCSSProperty(p + 1)) {
+                    ConsiderStartingTransition(p, aFrame, aOldStyleContext);
+                }
+            } else if (nsCSSProps::IsShorthand(property)) {
+                CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(subprop, property) {
+                    ConsiderStartingTransition(*subprop, aFrame,
+                                               aOldStyleContext);
+                }
+            } else {
+                ConsiderStartingTransition(property, aFrame, aOldStyleContext);
+            }
+        }
+    }
+}
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
new file mode 100644
--- /dev/null
+++ b/layout/style/nsTransitionManager.h
@@ -0,0 +1,59 @@
+/* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsTransitionManager.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsTransitionManager_h_
+#define nsTransitionManager_h_
+
+#include "prclist.h"
+
+class nsIFrame;
+class nsStyleContext;
+
+class nsTransitionManager {
+public:
+    nsTransitionManager();
+    ~nsTransitionManager();
+
+    void StyleContextChanged(nsIFrame *aFrame,
+                             nsStyleContext *aOldStyleContext);
+
+    static void InitializeAnimationInfo();
+
+private:
+    PRCList mFrameTransitions;
+};
+
+#endif /* !defined(nsTransitionManager_h_) */
