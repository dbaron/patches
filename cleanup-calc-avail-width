Clean up CalcAvailWidth.

diff --git a/layout/tables/nsTableRowFrame.cpp b/layout/tables/nsTableRowFrame.cpp
--- a/layout/tables/nsTableRowFrame.cpp
+++ b/layout/tables/nsTableRowFrame.cpp
@@ -662,45 +662,35 @@ nsTableRowFrame::CalculateCellActualSize
     aDesiredWidth = aAvailWidth;
   } 
 
   return NS_OK;
 }
 
 // Calculates the available width for the table cell based on the known
 // column widths taking into account column spans and column spacing
-static void 
+static nscoord
 CalcAvailWidth(nsTableFrame&     aTableFrame,
                nsTableCellFrame& aCellFrame,
-               nscoord           aCellSpacingX,
-               nscoord&          aColAvailWidth,
-               nscoord&          aCellAvailWidth)
+               nscoord           aCellSpacingX)
 {
-  aColAvailWidth = aCellAvailWidth = NS_UNCONSTRAINEDSIZE;
+  nscoord cellAvailWidth = 0;
   PRInt32 colIndex;
   aCellFrame.GetColIndex(colIndex);
   PRInt32 colspan = aTableFrame.GetEffectiveColSpan(aCellFrame);
-  nscoord cellSpacing = 0;
+  NS_ASSERTION(colspan > 0, "effective colspan should be positive");
 
   for (PRInt32 spanX = 0; spanX < colspan; spanX++) {
-    nscoord colWidth = aTableFrame.GetColumnWidth(colIndex + spanX);
-    if (NS_UNCONSTRAINEDSIZE == aColAvailWidth) {
-      aColAvailWidth = colWidth; 
-    }
-    else {
-      aColAvailWidth += colWidth;
-    }
-    if ((spanX > 0) && aTableFrame.ColumnHasCellSpacingBefore(colIndex + spanX)) {
-      cellSpacing += aCellSpacingX;
+    cellAvailWidth += aTableFrame.GetColumnWidth(colIndex + spanX);
+    if (spanX > 0 &&
+        aTableFrame.ColumnHasCellSpacingBefore(colIndex + spanX)) {
+      cellAvailWidth += aCellSpacingX;
     }
   }
-  if (NS_UNCONSTRAINEDSIZE != aColAvailWidth) {
-    aColAvailWidth += cellSpacing;
-  } 
-  aCellAvailWidth = aColAvailWidth;
+  return cellAvailWidth;
 }
 
 nscoord
 GetSpaceBetween(PRInt32       aPrevColIndex,
                 PRInt32       aColIndex,
                 PRInt32       aColSpan,
                 nsTableFrame& aTableFrame,
                 nscoord       aCellSpacingX,
@@ -865,19 +855,18 @@ nsTableRowFrame::ReflowChildren(nsPresCo
     // Reflow the child frame
     nsRect kidRect = kidFrame->GetRect();
     nsRect kidOverflowRect = kidFrame->GetOverflowRect();
     PRBool firstReflow =
       (kidFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW) != 0;
 
     if (doReflowChild) {
       // Calculate the available width for the table cell using the known column widths
-      nscoord availColWidth, availCellWidth;
-      CalcAvailWidth(aTableFrame, *cellFrame, cellSpacingX,
-                     availColWidth, availCellWidth);
+      nscoord availCellWidth =
+        CalcAvailWidth(aTableFrame, *cellFrame, cellSpacingX);
 
       nsHTMLReflowMetrics desiredSize;
 
       // If the avail width is not the same as last time we reflowed the cell or
       // the cell wants to be bigger than what was available last time or
       // it is a style change reflow or we are printing, then we must reflow the
       // cell. Otherwise we can skip the reflow.
       // XXXldb Why is this condition distinct from doReflowChild above?
@@ -887,17 +876,17 @@ nsTableRowFrame::ReflowChildren(nsPresCo
           (GetStateBits() & NS_FRAME_IS_DIRTY)                      ||
           isPaginated                                               ||
           NS_SUBTREE_DIRTY(cellFrame)                               ||
           // See if it needs a special reflow, or if it had one that we need to undo.
           (cellFrame->GetStateBits() & NS_FRAME_CONTAINS_RELATIVE_HEIGHT) ||
           HasPctHeight()) {
         // Reflow the cell to fit the available width, height
         // XXX The old IR_ChildIsDirty code used availCellWidth here.
-        nsSize  kidAvailSize(availColWidth, aReflowState.availableHeight);
+        nsSize  kidAvailSize(availCellWidth, aReflowState.availableHeight);
 
         // Reflow the child
         nsTableCellReflowState kidReflowState(aPresContext, aReflowState, 
                                               kidFrame, kidAvailSize, PR_FALSE);
         InitChildReflowState(*aPresContext, kidAvailSize, borderCollapse,
                              kidReflowState);
 
         nsReflowStatus status;
@@ -954,19 +943,17 @@ nsTableRowFrame::ReflowChildren(nsPresCo
         cellMaxHeight = PR_MAX(cellMaxHeight, desiredSize.height);
         PRInt32 rowSpan = aTableFrame.GetEffectiveRowSpan((nsTableCellFrame&)*kidFrame);
         if (1 == rowSpan) {
           SetContentHeight(cellMaxHeight);
         }
       }
 
       // Place the child
-      if (NS_UNCONSTRAINEDSIZE != availColWidth) {
-        desiredSize.width = PR_MAX(availCellWidth, availColWidth);
-      }
+      desiredSize.width = availCellWidth;
 
       FinishReflowChild(kidFrame, aPresContext, nsnull, desiredSize, x, 0, 0);
 
       nsTableFrame::InvalidateFrame(kidFrame, kidRect, kidOverflowRect,
                                     firstReflow);
       
       x += desiredSize.width;  
     }
