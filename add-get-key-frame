From: L. David Baron <dbaron@dbaron.org>

Add GetKeyFrame to nsDisplayItem so that callers can still get a frame when GetUnderlyingFrame is null.  (FIXME: keys not unique)  (FIXME: do more callers need to be switched?)

diff --git a/layout/base/FrameLayerBuilder.cpp b/layout/base/FrameLayerBuilder.cpp
--- a/layout/base/FrameLayerBuilder.cpp
+++ b/layout/base/FrameLayerBuilder.cpp
@@ -1102,17 +1102,17 @@ ContainerState::ProcessDisplayItems(cons
     } else {
       nsRefPtr<BasicLayerManager> tempLayerManager;
       if (layerState == LAYER_INACTIVE) {
         tempLayerManager = BuildTempManagerForInactiveLayer(mBuilder, item);
         if (!tempLayerManager)
           continue;
       }
 
-      nsIFrame* f = item->GetUnderlyingFrame();
+      nsIFrame* f = item->GetKeyFrame();
       nsIFrame* activeScrolledRoot =
         nsLayoutUtils::GetActiveScrolledRootFor(f, mBuilder->ReferenceFrame());
       if (item->IsFixedAndCoveringViewport(mBuilder)) {
         // Make its active scrolled root be the active scrolled root of
         // the enclosing viewport, since it shouldn't be scrolled by scrolled
         // frames in its document. InvalidateFixedBackgroundFramesFromList in
         // nsGfxScrollFrame will not repaint this item when scrolling occurs.
         nsIFrame* viewportFrame =
@@ -1133,17 +1133,17 @@ ContainerState::ProcessDisplayItems(cons
                              layerState, tempLayerManager);
     }
   }
 }
 
 void
 ContainerState::InvalidateForLayerChange(nsDisplayItem* aItem, Layer* aNewLayer)
 {
-  nsIFrame* f = aItem->GetUnderlyingFrame();
+  nsIFrame* f = aItem->GetKeyFrame();
   NS_ASSERTION(f, "Display items that render using Thebes must have a frame");
   PRUint32 key = aItem->GetPerFrameKey();
   NS_ASSERTION(key, "Display items that render using Thebes must have a key");
   Layer* oldLayer = mBuilder->LayerBuilder()->GetOldLayerFor(f, key);
   if (!oldLayer) {
     // Nothing to do here, this item didn't have a layer before
     return;
   }
@@ -1186,31 +1186,31 @@ FrameLayerBuilder::AddThebesDisplayItem(
                                         LayerState aLayerState,
                                         LayerManager* aTempManager)
 {
   AddLayerDisplayItem(aLayer, aItem);
 
   ThebesLayerItemsEntry* entry = mThebesLayerItems.PutEntry(aLayer);
   if (entry) {
     entry->mContainerLayerFrame = aContainerLayerFrame;
-    NS_ASSERTION(aItem->GetUnderlyingFrame(), "Must have frame");
+    NS_ASSERTION(aItem->GetKeyFrame(), "Must have frame");
     ClippedDisplayItem* cdi =
       entry->mItems.AppendElement(ClippedDisplayItem(aItem, aClipRect));
     cdi->mTempLayerManager = aTempManager;
   }
 }
 
 void
 FrameLayerBuilder::AddLayerDisplayItem(Layer* aLayer,
                                        nsDisplayItem* aItem)
 {
   if (aLayer->Manager() != mRetainingManager)
     return;
 
-  nsIFrame* f = aItem->GetUnderlyingFrame();
+  nsIFrame* f = aItem->GetKeyFrame();
   DisplayItemDataEntry* entry = mNewDisplayItemData.PutEntry(f);
   if (entry) {
     entry->mData.AppendElement(DisplayItemData(aLayer, aItem->GetPerFrameKey()));
   }
 }
 
 nscolor
 FrameLayerBuilder::FindOpaqueColorCovering(nsDisplayListBuilder* aBuilder,
diff --git a/layout/base/nsDisplayList.h b/layout/base/nsDisplayList.h
--- a/layout/base/nsDisplayList.h
+++ b/layout/base/nsDisplayList.h
@@ -506,16 +506,24 @@ public:
   /**
    * @return the frame that this display item is based on. This is used to sort
    * items by z-index and content order and for some other uses. For some items
    * that wrap item lists, this could return nsnull because there is no single
    * underlying frame; for leaf items it will never return nsnull.
    */
   inline nsIFrame* GetUnderlyingFrame() { return mFrame; }
   /**
+   * Return a frame that can be used as a key for this display item,
+   * along with GetPerFrameKey.  This is generally the same as
+   * GetUnderlyingFrame, except when GetUnderlyingFrame is null.  (This
+   * is *still* null for nsDisplayClip, but we could fix that if we need
+   * to.)
+   */
+  virtual nsIFrame* GetKeyFrame() { return mFrame; }
+  /**
    * The default bounds is the frame border rect.
    * @return a rectangle relative to aBuilder->ReferenceFrame() that
    * contains the area drawn by this display item
    */
   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
     return nsRect(ToReferenceFrame(), GetUnderlyingFrame()->GetSize());
   }
   /**
@@ -1656,17 +1664,17 @@ public:
   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
     return mBounds;
   }
   virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx);
   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
                                    nsRegion* aVisibleRegion);
   virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
   NS_DISPLAY_DECL_NAME("ClipRoundedRect", TYPE_CLIP_BORDER_RADIUS)
-  virtual PRUint32 GetPerFrameKey() { return 0; }
+  virtual nsIFrame* GetKeyFrame() { return mClippingFrame; }
 
   virtual nsDisplayWrapList* WrapWithClone(nsDisplayListBuilder* aBuilder,
                                            nsDisplayItem* aItem);
 
 private:
   nsIFrame* mClippingFrame;
   nsRect mBounds;
   nscoord mRadii[8];
