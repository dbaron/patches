From: L. David Baron <dbaron@dbaron.org>

Make tokenization of url() function be noncontextual, as required by CSS.  (Bug 604179)

Needed to help CSS 2.1 meet Proposed Recommendation entrance criteria.

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -554,17 +554,16 @@ protected:
                                  PRInt32 aVariantMask,
                                  const PRInt32 aKeywordTable[]);
   PRBool ParsePositiveNonZeroVariant(nsCSSValue& aValue,
                                      PRInt32 aVariantMask,
                                      const PRInt32 aKeywordTable[]);
   PRBool ParseCounter(nsCSSValue& aValue);
   PRBool ParseAttr(nsCSSValue& aValue);
   PRBool SetValueToURL(nsCSSValue& aValue, const nsString& aURL);
-  PRBool ParseURL(nsCSSValue& aValue);
   PRBool TranslateDimension(nsCSSValue& aValue, PRInt32 aVariantMask,
                             float aNumber, const nsString& aUnit);
   PRBool ParseImageRect(nsCSSValue& aImage);
   PRBool ParseElement(nsCSSValue& aValue);
   PRBool ParseColorStop(nsCSSValueGradient* aGradient);
   PRBool ParseGradient(nsCSSValue& aValue, PRBool aIsRadial,
                        PRBool aIsRepeating);
 
@@ -1568,25 +1567,20 @@ CSSParserImpl::ParseCharsetRule(RuleAppe
 }
 
 PRBool
 CSSParserImpl::ParseURLOrString(nsString& aURL)
 {
   if (!GetToken(PR_TRUE)) {
     return PR_FALSE;
   }
-  if (eCSSToken_String == mToken.mType) {
+  if (eCSSToken_String == mToken.mType || eCSSToken_URL == mToken.mType) {
     aURL = mToken.mIdent;
     return PR_TRUE;
   }
-  else if (eCSSToken_Function == mToken.mType &&
-           mToken.mIdent.LowerCaseEqualsLiteral("url") &&
-           GetURLInParens(aURL)) {
-    return PR_TRUE;
-  }
   UngetToken();
   return PR_FALSE;
 }
 
 PRBool
 CSSParserImpl::ParseMediaQuery(PRBool aInAtRule,
                                nsMediaQuery **aQuery,
                                PRBool *aParsedSomething,
@@ -2037,50 +2031,53 @@ CSSParserImpl::ParseMediaRule(RuleAppend
 // url(), url-prefix(), or domain().
 PRBool
 CSSParserImpl::ParseMozDocumentRule(RuleAppendFunc aAppendFunc, void* aData)
 {
   nsCSSDocumentRule::URL *urls = nsnull;
   nsCSSDocumentRule::URL **next = &urls;
   do {
     if (!GetToken(PR_TRUE) ||
-        eCSSToken_Function != mToken.mType ||
-        !(mToken.mIdent.LowerCaseEqualsLiteral("url") ||
-          mToken.mIdent.LowerCaseEqualsLiteral("url-prefix") ||
-          mToken.mIdent.LowerCaseEqualsLiteral("domain"))) {
+        !(eCSSToken_URL == mToken.mType ||
+          (eCSSToken_Function == mToken.mType &&
+           (mToken.mIdent.LowerCaseEqualsLiteral("url-prefix") ||
+            mToken.mIdent.LowerCaseEqualsLiteral("domain"))))) {
       REPORT_UNEXPECTED_TOKEN(PEMozDocRuleBadFunc);
       delete urls;
       return PR_FALSE;
     }
     nsCSSDocumentRule::URL *cur = *next = new nsCSSDocumentRule::URL;
     if (!cur) {
       mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
       delete urls;
       return PR_FALSE;
     }
     next = &cur->next;
-    if (mToken.mIdent.LowerCaseEqualsLiteral("url")) {
+    if (mToken.mType == eCSSToken_URL) {
       cur->func = nsCSSDocumentRule::eURL;
-    } else if (mToken.mIdent.LowerCaseEqualsLiteral("url-prefix")) {
-      cur->func = nsCSSDocumentRule::eURLPrefix;
-    } else if (mToken.mIdent.LowerCaseEqualsLiteral("domain")) {
-      cur->func = nsCSSDocumentRule::eDomain;
-    }
-
-    nsAutoString url;
-    if (!GetURLInParens(url)) {
-      REPORT_UNEXPECTED_TOKEN(PEMozDocRuleNotURI);
-      delete urls;
-      return PR_FALSE;
-    }
-
-    // We could try to make the URL (as long as it's not domain())
-    // canonical and absolute with NS_NewURI and GetSpec, but I'm
-    // inclined to think we shouldn't.
-    CopyUTF16toUTF8(url, cur->url);
+      CopyUTF16toUTF8(mToken.mIdent, cur->url);
+    } else {
+      if (mToken.mIdent.LowerCaseEqualsLiteral("url-prefix")) {
+        cur->func = nsCSSDocumentRule::eURLPrefix;
+      } else if (mToken.mIdent.LowerCaseEqualsLiteral("domain")) {
+        cur->func = nsCSSDocumentRule::eDomain;
+      }
+
+      nsAutoString url;
+      if (!GetURLInParens(url)) {
+        REPORT_UNEXPECTED_TOKEN(PEMozDocRuleNotURI);
+        delete urls;
+        return PR_FALSE;
+      }
+
+      // We could try to make the URL (as long as it's not domain())
+      // canonical and absolute with NS_NewURI and GetSpec, but I'm
+      // inclined to think we shouldn't.
+      CopyUTF16toUTF8(url, cur->url);
+    }
   } while (ExpectSymbol(',', PR_TRUE));
 
   nsRefPtr<nsCSSDocumentRule> rule(new nsCSSDocumentRule());
   if (!rule) {
     mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     delete urls;
     return PR_FALSE;
   }
@@ -4434,22 +4431,19 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
         (eCSSToken_Number == tk->mType)) {
       aValue.SetFloatValue(tk->mNumber, eCSSUnit_Pixel);
       return PR_TRUE;
     }
   }
 #endif
 
   if (((aVariantMask & VARIANT_URL) != 0) &&
-      (eCSSToken_Function == tk->mType) &&
-      tk->mIdent.LowerCaseEqualsLiteral("url")) {
-    if (ParseURL(aValue)) {
-      return PR_TRUE;
-    }
-    return PR_FALSE;
+      eCSSToken_URL == tk->mType) {
+    SetValueToURL(aValue, tk->mIdent);
+    return PR_TRUE;
   }
   if ((aVariantMask & VARIANT_GRADIENT) != 0 &&
       eCSSToken_Function == tk->mType) {
     // a generated gradient
     if (tk->mIdent.LowerCaseEqualsLiteral("-moz-linear-gradient"))
       return ParseGradient(aValue, PR_FALSE, PR_FALSE);
 
     if (tk->mIdent.LowerCaseEqualsLiteral("-moz-radial-gradient"))
@@ -4699,26 +4693,16 @@ CSSParserImpl::SetValueToURL(nsCSSValue&
   if (NS_UNLIKELY(!urlVal)) {
     mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     return PR_FALSE;
   }
   aValue.SetURLValue(urlVal);
   return PR_TRUE;
 }
 
-PRBool
-CSSParserImpl::ParseURL(nsCSSValue& aValue)
-{
-  nsAutoString url;
-  if (!GetURLInParens(url))
-    return PR_FALSE;
-
-  return SetValueToURL(aValue, url);
-}
-
 /**
  * Parse the arguments of -moz-image-rect() function.
  * -moz-image-rect(<uri>, <top>, <right>, <bottom>, <left>)
  */
 PRBool
 CSSParserImpl::ParseImageRect(nsCSSValue& aImage)
 {
   // A non-iterative for loop to break out when an error occurs.
@@ -4736,17 +4720,17 @@ CSSParserImpl::ParseImageRect(nsCSSValue
     nsCSSValue& url    = func->Item(1);
     nsCSSValue& top    = func->Item(2);
     nsCSSValue& right  = func->Item(3);
     nsCSSValue& bottom = func->Item(4);
     nsCSSValue& left   = func->Item(5);
 
     nsAutoString urlString;
     if (!ParseURLOrString(urlString) ||
-        !SetValuetoURL(url, urlString) ||
+        !SetValueToURL(url, urlString) ||
         !ExpectSymbol(',', PR_TRUE)) {
       break;
     }
 
     static const PRInt32 VARIANT_SIDE = VARIANT_NUMBER | VARIANT_PERCENT;
     if (!ParseNonNegativeVariant(top, VARIANT_SIDE, nsnull) ||
         !ExpectSymbol(',', PR_TRUE) ||
         !ParseNonNegativeVariant(right, VARIANT_SIDE, nsnull) ||
@@ -5848,24 +5832,24 @@ CSSParserImpl::ParseBackgroundItem(CSSPa
         if (haveColor)
           return PR_FALSE;
         haveColor = PR_TRUE;
         if (!ParseSingleValueProperty(aState.mColor,
                                       eCSSProperty_background_color)) {
           return PR_FALSE;
         }
       }
-    } else if (tt == eCSSToken_Function &&
-               (mToken.mIdent.LowerCaseEqualsLiteral("url") ||
-                mToken.mIdent.LowerCaseEqualsLiteral("-moz-linear-gradient") ||
-                mToken.mIdent.LowerCaseEqualsLiteral("-moz-radial-gradient") ||
-                mToken.mIdent.LowerCaseEqualsLiteral("-moz-repeating-linear-gradient") ||
-                mToken.mIdent.LowerCaseEqualsLiteral("-moz-repeating-radial-gradient") ||
-                mToken.mIdent.LowerCaseEqualsLiteral("-moz-image-rect") ||
-                mToken.mIdent.LowerCaseEqualsLiteral("-moz-element"))) {
+    } else if (tt == eCSSToken_URL ||
+               (tt == eCSSToken_Function &&
+                (mToken.mIdent.LowerCaseEqualsLiteral("-moz-linear-gradient") ||
+                 mToken.mIdent.LowerCaseEqualsLiteral("-moz-radial-gradient") ||
+                 mToken.mIdent.LowerCaseEqualsLiteral("-moz-repeating-linear-gradient") ||
+                 mToken.mIdent.LowerCaseEqualsLiteral("-moz-repeating-radial-gradient") ||
+                 mToken.mIdent.LowerCaseEqualsLiteral("-moz-image-rect") ||
+                 mToken.mIdent.LowerCaseEqualsLiteral("-moz-element")))) {
       if (haveImage)
         return PR_FALSE;
       haveImage = PR_TRUE;
       if (!ParseSingleValueProperty(aState.mImage->mValue,
                                     eCSSProperty_background_image)) {
         return PR_FALSE;
       }
     } else if (tt == eCSSToken_Dimension ||
@@ -7442,20 +7426,18 @@ CSSParserImpl::ParseFontSrc(nsCSSValue& 
 {
   // could we maybe turn nsCSSValue::Array into nsTArray<nsCSSValue>?
   nsTArray<nsCSSValue> values;
   nsCSSValue cur;
   for (;;) {
     if (!GetToken(PR_TRUE))
       break;
 
-    if (mToken.mType == eCSSToken_Function &&
-        mToken.mIdent.LowerCaseEqualsLiteral("url")) {
-      if (!ParseURL(cur))
-        return PR_FALSE;
+    if (mToken.mType == eCSSToken_URL) {
+      SetValueToURL(cur, mToken.mIdent);
       values.AppendElement(cur);
       if (!ParseFontSrcFormat(values))
         return PR_FALSE;
 
     } else if (mToken.mType == eCSSToken_Function &&
                mToken.mIdent.LowerCaseEqualsLiteral("local")) {
       // css3-fonts does not specify a formal grammar for local().
       // The text permits both unquoted identifiers and quoted
diff --git a/layout/style/nsCSSScanner.cpp b/layout/style/nsCSSScanner.cpp
--- a/layout/style/nsCSSScanner.cpp
+++ b/layout/style/nsCSSScanner.cpp
@@ -198,16 +198,17 @@ nsCSSToken::AppendToString(nsString& aBu
     case eCSSToken_HTMLComment:
     case eCSSToken_URange:
       aBuffer.Append(mIdent);
       if (mType == eCSSToken_Function)
         aBuffer.Append(PRUnichar('('));
       break;
     case eCSSToken_URL:
     case eCSSToken_Bad_URL:
+      aBuffer.AppendLiteral("url(");
       if (mSymbol != PRUnichar(0)) {
         aBuffer.Append(mSymbol);
       }
       aBuffer.Append(mIdent);
       if (mSymbol != PRUnichar(0)) {
         aBuffer.Append(mSymbol);
       }
       if (mType == eCSSToken_URL) {
@@ -1143,16 +1144,21 @@ nsCSSScanner::ParseIdent(PRInt32 aChar, 
     return PR_FALSE;
   }
 
   nsCSSTokenType tokenType = eCSSToken_Ident;
   // look for functions (ie: "ident(")
   if (Peek() == PRUnichar('(')) {
     Read();
     tokenType = eCSSToken_Function;
+
+    if (ident.LowerCaseEqualsLiteral("url")) {
+      NextURL(aToken); // ignore return value, since *we* read something
+      return PR_TRUE;
+    }
   }
 
   aToken.mType = tokenType;
   return PR_TRUE;
 }
 
 PRBool
 nsCSSScanner::ParseAtKeyword(PRInt32 aChar, nsCSSToken& aToken)
diff --git a/layout/style/test/test_unclosed_parentheses.html b/layout/style/test/test_unclosed_parentheses.html
--- a/layout/style/test/test_unclosed_parentheses.html
+++ b/layout/style/test/test_unclosed_parentheses.html
@@ -26,16 +26,24 @@ https://bugzilla.mozilla.org/show_bug.cg
 
 // Each of the following declarations should have a single missing ')'
 // in the value.
 var declarations = [
   "content: url(",
   "content: url( ",
   "content: url(http://www.foo.com",
   "content: url('http://www.foo.com'",
+  "content: foobar(",
+  "content: foobar( ",
+  "content: foobar(http://www.foo.com",
+  "content: foobar('http://www.foo.com'",
+  "color: url(",
+  "color: url( ",
+  "color: url(http://www.foo.com",
+  "color: url('http://www.foo.com'",
   "background-image: -moz-linear-gradient(",
   "background-image: -moz-linear-gradient( ",
   "background-image: -moz-linear-gradient(red, blue",
   "background-image: -moz-linear-gradient(red, yellow, blue",
   "background-image: -moz-linear-gradient(red 1px, yellow 5px, blue 10px",
   "background-image: -moz-linear-gradient(red, yellow, rgb(0, 0, 255)",
   "background-image: -moz-repeating-linear-gradient(top left, red, blue",
   "background-image: -moz-linear-gradient(top left, red, yellow, blue",
