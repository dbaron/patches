From: L. David Baron <dbaron@dbaron.org>

Add mechanism for assertions that fire when a guard object is used as a temporary (see JS version in bug 518633).

diff --git a/xpcom/glue/AutoRestore.h b/xpcom/glue/AutoRestore.h
--- a/xpcom/glue/AutoRestore.h
+++ b/xpcom/glue/AutoRestore.h
@@ -38,16 +38,110 @@
 /* functions for restoring saved values at the end of a C++ scope */
 
 #ifndef mozilla_AutoRestore_h_
 #define mozilla_AutoRestore_h_
 
 namespace mozilla {
 
   /**
+   * The following classes are designed to cause assertions to detect
+   * inadvertent use of guard objects as temporaries.  In other words,
+   * when we have a guard object whose only purpose is its constructor and
+   * destructor (and is never otherwise referenced), the intended use
+   * might be:
+   *     AutoRestore savePainting(mIsPainting);
+   * but is is easy to accidentally write:
+   *     AutoRestore(mIsPainting);
+   * which compiles just fine, but runs the destructor well before the
+   * intended time.
+   *
+   * They work by adding (#ifdef DEBUG) an additional parameter to the
+   * guard object's constructor, with a default value, so that users of
+   * the guard object's API do not need to do anything.  The default value
+   * of this parameter is a temporary object.  C++ (ISO/IEC 14882:1998),
+   * section 12.2 [class.temporary], clauses 4 and 5 seem to assume a
+   * guarantee that temporaries are destroyed in the reverse of their
+   * construction order, but I actually can't find a statement that that
+   * is true in the general case (beyond the two specific cases mentioned
+   * there).  However, it seems to be true.
+   *
+   * These classes are intended to be used only via the macros immediately
+   * below them:
+   *   MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER declares (ifdef DEBUG) a member
+   *     variable, and should be put where a declaration of a private
+   *     member variable would be placed.
+   *   MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM should be placed at the end of the
+   *     parameters to each constructor of the guard object; it declares
+   *     (ifdef DEBUG) an additional parameter.
+   *   MOZILLA_GUARD_OBJECT_NOTIFIER_INIT is a statement that belongs in each
+   *     constructor.  It uses the parameter declared by
+   *     MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM.
+   */
+#ifdef DEBUG
+  class GuardObjectNotifier
+  {
+  private:
+    bool* mStatementDone;
+  public:
+    GuardObjectNotifier() : mStatementDone(NULL) {}
+
+    ~GuardObjectNotifier() {
+      *mStatementDone = true;
+    }
+
+    void SetStatementDone(bool *aStatementDone) {
+      mStatementDone = aStatementDone;
+    }
+  };
+
+  class GuardObjectNotificationReceiver
+  {
+  private:
+    bool mStatementDone;
+  public:
+    GuardObjectNotificationReceiver() : mStatementDone(false) {}
+
+    ~GuardObjectNotificationReceiver() {
+      /*
+       * Assert that the guard object was not used as a temporary.
+       * (Note that this assert might also fire if Init is not called
+       * because the guard object's implementation is not using the
+       * above macros correctly.)
+       */
+      MOZILLA_ASSERT(mStatementDone);
+    }
+
+    void Init(const GuardObjectNotifier &aNotifier) {
+      /*
+       * aNotifier is passed as a const reference so that we can pass a
+       * temporary, but we really intend it as non-const
+       */
+      const_cast<GuardObjectNotifier&>(aNotifier).
+          SetStatementDone(&mStatementDone);
+    }
+  };
+
+  #define MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER \
+      GuardObjectNotificationReceiver _mCheckNotUsedAsTemporary;
+  #define MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM \
+      , const GuardObjectNotifier& _notifier = GuardObjectNotifier()
+  #define MOZILLA_GUARD_OBJECT_NOTIFIER_INIT \
+      PR_BEGIN_MACRO _mCheckNotUsedAsTemporary.Init(_notifier); PR_END_MACRO
+
+#else /* defined(DEBUG) */
+
+  #define MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
+  #define MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM
+  #define MOZILLA_GUARD_OBJECT_NOTIFIER_INIT PR_BEGIN_MACRO PR_END_MACRO
+
+#endif /* !defined(DEBUG) */
+
+
+  /**
    * Save the current value of a variable and restore it when the object
    * goes out of scope.  For example:
    *   {
    *     AutoRestore<PRBool> savePainting(mIsPainting);
    *     mIsPainting = PR_TRUE;
    *     
    *     // ... your code here ...
    *
