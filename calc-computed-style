From: L. David Baron <dbaron@dbaron.org>

Handle computed-value calc() expressions in computed style.  (Bug 363249)  r=bzbarsky

diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -76,18 +76,20 @@
 #include "nsLayoutUtils.h"
 #include "nsFrameManager.h"
 #include "prlog.h"
 #include "nsCSSKeywords.h"
 #include "nsStyleCoord.h"
 #include "nsDisplayList.h"
 #include "nsDOMCSSDeclaration.h"
 #include "mozilla/dom/Element.h"
+#include "CSSCalc.h"
 
 using namespace mozilla::dom;
+namespace css = mozilla::css;
 
 #if defined(DEBUG_bzbarsky) || defined(DEBUG_caillon)
 #define DEBUG_ComputedDOMStyle
 #endif
 
 /*
  * This is the implementation of the readonly CSSStyleDeclaration that is
  * returned by the getComputedStyle() function.
@@ -3747,16 +3749,67 @@ nsComputedDOMStyle::GetBorderStyleFor(mo
   val->SetIdent(
     nsCSSProps::ValueToKeywordEnum(GetStyleBorder()->GetBorderStyle(aSide),
                                    nsCSSProps::kBorderStyleKTable));
 
   NS_ADDREF(*aValue = val);
   return NS_OK;
 }
 
+struct StyleCoordSerializeCalcOps {
+  StyleCoordSerializeCalcOps(nsAString& aResult, PRInt32 aAppUnitsPerInch)
+    : mResult(aResult),
+      mAppUnitsPerInch(aAppUnitsPerInch)
+  {
+  }
+
+  typedef nsStyleCoord input_type;
+  typedef nsStyleCoord::Array input_array_type;
+
+  static nsCSSUnit GetUnit(const input_type& aValue) {
+    if (aValue.IsCalcUnit()) {
+      return css::ConvertCalcUnit(aValue.GetUnit());
+    }
+    return eCSSUnit_Null;
+  }
+
+  void Append(const char* aString)
+  {
+    mResult.AppendASCII(aString);
+  }
+
+  void AppendLeafValue(const input_type& aValue)
+  {
+    nsRefPtr<nsROCSSPrimitiveValue> val =
+      new nsROCSSPrimitiveValue(mAppUnitsPerInch);
+    if (aValue.GetUnit() == eStyleUnit_Percent) {
+      val->SetPercent(aValue.GetPercentValue());
+    } else {
+      NS_ABORT_IF_FALSE(aValue.GetUnit() == eStyleUnit_Coord,
+                        "unexpected unit");
+      val->SetAppUnits(aValue.GetCoordValue());
+    }
+
+    nsAutoString tmp;
+    val->GetCssText(tmp);
+    mResult.Append(tmp);
+  }
+
+  void AppendNumber(const input_type& aValue)
+  {
+    NS_ABORT_IF_FALSE(PR_FALSE,
+                      "should not have numbers in nsStyleCoord calc()");
+  }
+
+private:
+  nsAString &mResult;
+  PRInt32 mAppUnitsPerInch;
+};
+
+
 void
 nsComputedDOMStyle::SetValueToCoord(nsROCSSPrimitiveValue* aValue,
                                     const nsStyleCoord& aCoord,
                                     PercentageBaseGetter aPercentageBaseGetter,
                                     const PRInt32 aTable[],
                                     nscoord aMinAppUnits,
                                     nscoord aMaxAppUnits)
 {
@@ -3771,17 +3824,18 @@ nsComputedDOMStyle::SetValueToCoord(nsRO
       aValue->SetIdent(eCSSKeyword_auto);
       break;
 
     case eStyleUnit_Percent:
       {
         nscoord percentageBase;
         if (aPercentageBaseGetter &&
             (this->*aPercentageBaseGetter)(percentageBase)) {
-          nscoord val = nscoord(aCoord.GetPercentValue() * percentageBase);
+          nscoord val = NSCoordSaturatingMultiply(percentageBase,
+                                                  aCoord.GetPercentValue());
           aValue->SetAppUnits(NS_MAX(aMinAppUnits, NS_MIN(val, aMaxAppUnits)));
         } else {
           aValue->SetPercent(aCoord.GetPercentValue());
         }
       }
       break;
 
     case eStyleUnit_Factor:
@@ -3805,40 +3859,51 @@ nsComputedDOMStyle::SetValueToCoord(nsRO
                                                       aTable));
       break;
 
     case eStyleUnit_None:
       aValue->SetIdent(eCSSKeyword_none);
       break;
 
     default:
-      NS_ERROR("Can't handle this unit");
+      if (aCoord.IsCalcUnit()) {
+        nscoord percentageBase;
+        if (aPercentageBaseGetter &&
+            (this->*aPercentageBaseGetter)(percentageBase)) {
+          nscoord val =
+            nsRuleNode::ComputeCoordPercentCalc(aCoord, percentageBase);
+          aValue->SetAppUnits(NS_MAX(aMinAppUnits, NS_MIN(val, aMaxAppUnits)));
+        } else {
+          nsAutoString tmp;
+          StyleCoordSerializeCalcOps ops(tmp, mAppUnitsPerInch);
+          css::SerializeCalc(aCoord, ops);
+          aValue->SetString(tmp); // not really SetString
+        }
+      } else {
+        NS_ERROR("Can't handle this unit");
+      }
       break;
   }
 }
 
 nscoord
 nsComputedDOMStyle::StyleCoordToNSCoord(const nsStyleCoord& aCoord,
                                         PercentageBaseGetter aPercentageBaseGetter,
                                         nscoord aDefaultValue)
 {
   NS_PRECONDITION(aPercentageBaseGetter, "Must have a percentage base getter");
-  switch (aCoord.GetUnit()) {
-    case eStyleUnit_Coord:
-      return aCoord.GetCoordValue();
-    case eStyleUnit_Percent:
-      {
-        nscoord percentageBase;
-        if ((this->*aPercentageBaseGetter)(percentageBase)) {
-          return nscoord(aCoord.GetPercentValue() * percentageBase);
-        }
-      }
-      // Fall through to returning aDefaultValue if we have no percentage base.
-    default:
-      break;
+  if (aCoord.GetUnit() == eStyleUnit_Coord) {
+    return aCoord.GetCoordValue();
+  }
+  if (aCoord.GetUnit() == eStyleUnit_Percent || aCoord.IsCalcUnit()) {
+    nscoord percentageBase;
+    if ((this->*aPercentageBaseGetter)(percentageBase)) {
+      return nsRuleNode::ComputeCoordPercentCalc(aCoord, percentageBase);
+    }
+    // Fall through to returning aDefaultValue if we have no percentage base.
   }
 
   return aDefaultValue;
 }
 
 PRBool
 nsComputedDOMStyle::GetCBContentWidth(nscoord& aWidth)
 {
