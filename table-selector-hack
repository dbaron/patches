From: L. David Baron <dbaron@dbaron.org>

Add a selector hack so that we can implement table border styles compatibly in CSS.  (Bug 539880)

diff --git a/layout/style/html.css b/layout/style/html.css
--- a/layout/style/html.css
+++ b/layout/style/html.css
@@ -289,48 +289,49 @@ table[align="right"] {
 table[rules] { 
   border: thin hidden; 
 }
 
   /* 'border' before 'frame' so 'frame' overrides
       A border with a given value should, of course, pass that value
       as the border-width in pixels -> attr mapping */
 
-  /* 'border="0"' suppresses the border */
-table[border]:not([border="0"]) { 
+  /* :-moz-table-border-nonzero is like [border]:not([border="0"]) except it
+     also checks for other zero-like values according to HTML attribute
+     parsing rules */
+table:-moz-table-border-nonzero { 
   border: thin outset; 
 }
 
-  
 table[frame] {
   border: thin hidden;
 }
 
-/*increased specificity to compete with [border]:not([border="0"]) rule above*/
-table[frame][frame="void"]   { border-style: hidden; }
-table[frame][frame="above"]  { border-style: outset hidden hidden hidden; }
-table[frame][frame="below"]  { border-style: hidden hidden outset hidden; }
-table[frame][frame="lhs"]    { border-style: hidden hidden hidden outset; }
-table[frame][frame="rhs"]    { border-style: hidden outset hidden hidden; }
-table[frame][frame="hsides"] { border-style: outset hidden; }
-table[frame][frame="vsides"] { border-style: hidden outset; }
-table[frame][frame="box"],
-table[frame][frame="border"] { border-style: outset; }
+/* specificity must beat table:-moz-table-border-nonzero rule above */
+table[frame="void"]   { border-style: hidden; }
+table[frame="above"]  { border-style: outset hidden hidden hidden; }
+table[frame="below"]  { border-style: hidden hidden outset hidden; }
+table[frame="lhs"]    { border-style: hidden hidden hidden outset; }
+table[frame="rhs"]    { border-style: hidden outset hidden hidden; }
+table[frame="hsides"] { border-style: outset hidden; }
+table[frame="vsides"] { border-style: hidden outset; }
+table[frame="box"],
+table[frame="border"] { border-style: outset; }
 
  
 /* Internal Table Borders */
 
   /* 'border' cell borders first */
 
-table[border]:not([border="0"])> * > tr > td,
-table[border]:not([border="0"])> * > tr > th,
-table[border]:not([border="0"])> * > td,
-table[border]:not([border="0"])> * > th,
-table[border]:not([border="0"])> td,
-table[border]:not([border="0"])> th
+table:-moz-table-border-nonzero > * > tr > td,
+table:-moz-table-border-nonzero > * > tr > th,
+table:-moz-table-border-nonzero > * > td,
+table:-moz-table-border-nonzero > * > th,
+table:-moz-table-border-nonzero > td,
+table:-moz-table-border-nonzero > th
 {
   border: thin inset;
 }
 
 /* collapse only if rules are really specified */
 table[rules]:not([rules="none"]):not([rules=""]) {
   border-collapse: collapse;
 }
diff --git a/layout/style/nsCSSPseudoClassList.h b/layout/style/nsCSSPseudoClassList.h
--- a/layout/style/nsCSSPseudoClassList.h
+++ b/layout/style/nsCSSPseudoClassList.h
@@ -110,16 +110,20 @@ CSS_PSEUDO_CLASS(mozLWTheme, ":-moz-lwth
 CSS_PSEUDO_CLASS(mozLWThemeBrightText, ":-moz-lwtheme-brighttext")
 
 // -moz-lwtheme-darktext matches a document that has a bright lightweight theme
 CSS_PSEUDO_CLASS(mozLWThemeDarkText, ":-moz-lwtheme-darktext")
 
 // Matches anything when the containing window is inactive
 CSS_PSEUDO_CLASS(mozWindowInactive, ":-moz-window-inactive")
 
+// Matches any table elements that have a nonzero border attribute,
+// according to HTML integer attribute parsing rules.
+CSS_PSEUDO_CLASS(mozTableBorderNonzero, ":-moz-table-border-nonzero")
+
 // :not needs to come at the end of the non-bit pseudo-class list, since
 // it doesn't actually get directly matched on in SelectorMatches.
 CSS_PSEUDO_CLASS(notPseudo, ":not")
 
 CSS_STATE_PSEUDO_CLASS(link, ":link", NS_EVENT_STATE_UNVISITED)
 // what matches :link or :visited
 CSS_STATE_PSEUDO_CLASS(mozAnyLink, ":-moz-any-link",
                        NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED)
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -87,16 +87,17 @@
 #include "nsIPrincipal.h"
 #include "nsStyleSet.h"
 #include "prlog.h"
 #include "nsIObserverService.h"
 #include "nsIPrivateBrowsingService.h"
 #include "nsNetCID.h"
 #include "mozilla/Services.h"
 #include "mozilla/dom/Element.h"
+#include "nsGenericElement.h"
 
 using namespace mozilla::dom;
 
 #define VISITED_PSEUDO_PREF "layout.css.visited_links_enabled"
 
 static PRBool gSupportVisitedPseudo = PR_TRUE;
 
 static NS_DEFINE_CID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
@@ -2025,16 +2026,32 @@ static PRBool SelectorMatches(RuleProces
         break;
 
       case nsCSSPseudoClasses::ePseudoClass_mozWindowInactive:
         if ((data.DocumentState() & NS_DOCUMENT_STATE_WINDOW_INACTIVE) == 0) {
           return PR_FALSE;
         }
         break;
 
+      case nsCSSPseudoClasses::ePseudoClass_mozTableBorderNonzero:
+        {
+          if (!data.mIsHTMLContent) {
+            return PR_FALSE;
+          }
+          nsGenericElement *ge = static_cast<nsGenericElement*>(data.mElement);
+          const nsAttrValue *val =
+            ge->GetAttrInfo(kNameSpaceID_None, nsGkAtoms::border).mValue;
+          if (!val ||
+              (val->Type() == nsAttrValue::eInteger &&
+               val->GetIntegerValue() == 0)) {
+            return PR_FALSE;
+          }
+        }
+        break;
+
       default:
         NS_ABORT_IF_FALSE(PR_FALSE, "How did that happen?");
       }
     } else {
       // Bit-based pseudo-classes
       if ((statesToCheck & (NS_EVENT_STATE_HOVER | NS_EVENT_STATE_ACTIVE)) &&
           data.mCompatMode == eCompatibility_NavQuirks &&
           // global selector (but don't check .class):
@@ -2699,18 +2716,17 @@ AddSelector(RuleCascadeData* aCascade,
        attr = attr->mNext) {
     nsTArray<nsCSSSelector*> *array =
       aCascade->AttributeListFor(attr->mCasedAttr);
     if (!array) {
       return PR_FALSE;
     }
     array->AppendElement(aSelectorInTopLevel);
     if (attr->mLowercaseAttr != attr->mCasedAttr) {
-      nsTArray<nsCSSSelector*> *array =
-        aCascade->AttributeListFor(attr->mLowercaseAttr);
+      array = aCascade->AttributeListFor(attr->mLowercaseAttr);
       if (!array) {
         return PR_FALSE;
       }
       array->AppendElement(aSelectorInTopLevel);
     }
   }
 
   // Recur through any :-moz-any selectors
