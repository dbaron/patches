From: L. David Baron <dbaron@dbaron.org>

Add a selector hack so that we can implement table border styles compatibly in CSS.  (Bug 539880)

diff --git a/layout/style/nsCSSPseudoClassList.h b/layout/style/nsCSSPseudoClassList.h
--- a/layout/style/nsCSSPseudoClassList.h
+++ b/layout/style/nsCSSPseudoClassList.h
@@ -110,16 +110,20 @@ CSS_PSEUDO_CLASS(mozLWTheme, ":-moz-lwth
 CSS_PSEUDO_CLASS(mozLWThemeBrightText, ":-moz-lwtheme-brighttext")
 
 // -moz-lwtheme-darktext matches a document that has a bright lightweight theme
 CSS_PSEUDO_CLASS(mozLWThemeDarkText, ":-moz-lwtheme-darktext")
 
 // Matches anything when the containing window is inactive
 CSS_PSEUDO_CLASS(mozWindowInactive, ":-moz-window-inactive")
 
+// Matches any table elements that have a nonzero border attribute,
+// according to HTML integer attribute parsing rules.
+CSS_PSEUDO_CLASS(mozTableBorderNonzero, ":-moz-table-border-nonzero")
+
 // :not needs to come at the end of the non-bit pseudo-class list, since
 // it doesn't actually get directly matched on in SelectorMatches.
 CSS_PSEUDO_CLASS(notPseudo, ":not")
 
 CSS_STATE_PSEUDO_CLASS(link, ":link", NS_EVENT_STATE_UNVISITED)
 // what matches :link or :visited
 CSS_STATE_PSEUDO_CLASS(mozAnyLink, ":-moz-any-link",
                        NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED)
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -87,16 +87,17 @@
 #include "nsIPrincipal.h"
 #include "nsStyleSet.h"
 #include "prlog.h"
 #include "nsIObserverService.h"
 #include "nsIPrivateBrowsingService.h"
 #include "nsNetCID.h"
 #include "mozilla/Services.h"
 #include "mozilla/dom/Element.h"
+#include "nsGenericElement.h"
 
 using namespace mozilla::dom;
 
 #define VISITED_PSEUDO_PREF "layout.css.visited_links_enabled"
 
 static PRBool gSupportVisitedPseudo = PR_TRUE;
 
 static NS_DEFINE_CID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
@@ -2025,16 +2026,32 @@ static PRBool SelectorMatches(RuleProces
         break;
 
       case nsCSSPseudoClasses::ePseudoClass_mozWindowInactive:
         if ((data.DocumentState() & NS_DOCUMENT_STATE_WINDOW_INACTIVE) == 0) {
           return PR_FALSE;
         }
         break;
 
+      case nsCSSPseudoClasses::ePseudoClass_mozTableBorderNonzero:
+        {
+          if (!data.mIsHTMLContent) {
+            return PR_FALSE;
+          }
+          nsGenericElement *ge = static_cast<nsGenericElement*>(data.mElement);
+          const nsAttrValue *val =
+            ge->GetAttrInfo(kNameSpaceID_None, nsGkAtoms::border).mValue;
+          if (!val ||
+              (val->Type() == nsAttrValue::eInteger &&
+               val->GetIntegerValue() == 0)) {
+            return PR_FALSE;
+          }
+        }
+        break;
+
       default:
         NS_ABORT_IF_FALSE(PR_FALSE, "How did that happen?");
       }
     } else {
       // Bit-based pseudo-classes
       if ((statesToCheck & (NS_EVENT_STATE_HOVER | NS_EVENT_STATE_ACTIVE)) &&
           data.mCompatMode == eCompatibility_NavQuirks &&
           // global selector (but don't check .class):
@@ -2699,18 +2716,17 @@ AddSelector(RuleCascadeData* aCascade,
        attr = attr->mNext) {
     nsTArray<nsCSSSelector*> *array =
       aCascade->AttributeListFor(attr->mCasedAttr);
     if (!array) {
       return PR_FALSE;
     }
     array->AppendElement(aSelectorInTopLevel);
     if (attr->mLowercaseAttr != attr->mCasedAttr) {
-      nsTArray<nsCSSSelector*> *array =
-        aCascade->AttributeListFor(attr->mLowercaseAttr);
+      array = aCascade->AttributeListFor(attr->mLowercaseAttr);
       if (!array) {
         return PR_FALSE;
       }
       array->AppendElement(aSelectorInTopLevel);
     }
   }
 
   // Recur through any :-moz-any selectors
