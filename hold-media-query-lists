From: L. David Baron <dbaron@dbaron.org>

Hold on to MediaQueryList objects that have listeners so that notification doesn't depend on GC timing.  (Bug 716751)  r=bzbarsky

Note:  This also fixes a crash (when notifications happen) from
calling mql.addListeners(null).

This also fixes test_media_query_list.html so that the initial set of
tests doesn't keep running through the later tests.

The test for the null-dereference has been confirmed to crash without
the patch and pass with the patch.

The test for the gc issue has been confirmed to fail without the patch
and pass with the patch.

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -346,30 +346,43 @@ NS_IMPL_CYCLE_COLLECTING_RELEASE(nsPresC
 
 static PLDHashOperator
 TraverseImageLoader(const void * aKey, nsRefPtr<nsImageLoader>& aData,
                     void* aClosure)
 {
   nsCycleCollectionTraversalCallback *cb =
     static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
 
+  NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mImageLoaders[i] item");
   cb->NoteXPCOMChild(aData);
 
   return PL_DHASH_NEXT;
 }
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsPresContext)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDocument);
   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mDeviceContext); // not xpcom
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mEventManager, nsIObserver);
   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mLanguage); // an atom
 
   for (PRUint32 i = 0; i < IMAGE_LOAD_TYPE_COUNT; ++i)
     tmp->mImageLoaders[i].Enumerate(TraverseImageLoader, &cb);
 
+  // We own only the items in mDOMMediaQueryLists that have listeners;
+  // this reference is managed by their AddListener and RemoveListener
+  // methods.
+  for (PRCList *l = PR_LIST_HEAD(&tmp->mDOMMediaQueryLists);
+       l != &tmp->mDOMMediaQueryLists; l = PR_NEXT_LINK(l)) {
+    nsDOMMediaQueryList *mql = static_cast<nsDOMMediaQueryList*>(l);
+    if (mql->HasListeners()) {
+      NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mDOMMediaQueryLists item");
+      cb.NoteXPCOMChild(mql);
+    }
+  }
+
   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTheme); // a service
   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLangService); // a service
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrintSettings);
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrefChangedTimer);
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsPresContext)
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDocument);
@@ -377,16 +390,27 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(ns
   if (tmp->mEventManager) {
     // unclear if these are needed, but can't hurt
     tmp->mEventManager->NotifyDestroyPresContext(tmp);
     tmp->mEventManager->SetPresContext(nsnull);
 
     NS_RELEASE(tmp->mEventManager);
   }
 
+  // We own only the items in mDOMMediaQueryLists that have listeners;
+  // this reference is managed by their AddListener and RemoveListener
+  // methods.
+  for (PRCList *l = PR_LIST_HEAD(&tmp->mDOMMediaQueryLists);
+       l != &tmp->mDOMMediaQueryLists; ) {
+    PRCList *next = PR_NEXT_LINK(l);
+    nsDOMMediaQueryList *mql = static_cast<nsDOMMediaQueryList*>(l);
+    mql->RemoveAllListeners();
+    l = next;
+  }
+
   // NS_RELEASE(tmp->mLanguage); // an atom
 
   // NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mTheme); // a service
   // NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mLangService); // a service
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPrintSettings);
   if (tmp->mPrefChangedTimer)
   {
     tmp->mPrefChangedTimer->Cancel();
diff --git a/layout/style/nsDOMMediaQueryList.cpp b/layout/style/nsDOMMediaQueryList.cpp
--- a/layout/style/nsDOMMediaQueryList.cpp
+++ b/layout/style/nsDOMMediaQueryList.cpp
@@ -69,17 +69,17 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMP
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY_OF_NSCOMPTR(mListeners)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsDOMMediaQueryList)
 if (tmp->mPresContext) {
   PR_REMOVE_LINK(tmp);
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPresContext)
 }
-NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mListeners)
+tmp->RemoveAllListeners();
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 DOMCI_DATA(MediaQueryList, nsDOMMediaQueryList)
 
 NS_INTERFACE_MAP_BEGIN(nsDOMMediaQueryList)
   NS_INTERFACE_MAP_ENTRY(nsIDOMMediaQueryList)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsDOMMediaQueryList)
@@ -95,50 +95,82 @@ nsDOMMediaQueryList::GetMedia(nsAString 
   mMediaList->GetText(aMedia);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMMediaQueryList::GetMatches(bool *aMatches)
 {
   if (!mMatchesValid) {
-    NS_ABORT_IF_FALSE(mListeners.Length() == 0,
+    NS_ABORT_IF_FALSE(!HasListeners(),
                       "when listeners present, must keep mMatches current");
     RecomputeMatches();
   }
 
   *aMatches = mMatches;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMMediaQueryList::AddListener(nsIDOMMediaQueryListListener *aListener)
 {
+  if (!aListener) {
+    return NS_OK;
+  }
+
+  if (!HasListeners()) {
+    // When we have listeners, the pres context owns a reference to
+    // this.  This is a cyclic reference that can only be broken by
+    // cycle collection.
+    NS_ADDREF_THIS();
+  }
+
   if (!mMatchesValid) {
-    NS_ABORT_IF_FALSE(mListeners.Length() == 0,
+    NS_ABORT_IF_FALSE(!HasListeners(),
                       "when listeners present, must keep mMatches current");
     RecomputeMatches();
   }
 
   if (!mListeners.Contains(aListener)) {
     mListeners.AppendElement(aListener);
+    if (!HasListeners()) {
+      // Append failed; undo the AddRef above.
+      NS_RELEASE_THIS();
+    }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMMediaQueryList::RemoveListener(nsIDOMMediaQueryListListener *aListener)
 {
-  mListeners.RemoveElement(aListener);
+  bool removed = mListeners.RemoveElement(aListener);
   NS_ABORT_IF_FALSE(!mListeners.Contains(aListener),
                     "duplicate occurrence of listeners");
+
+  if (removed && !HasListeners()) {
+    // See NS_ADDREF_THIS() in AddListener.
+    NS_RELEASE_THIS();
+  }
+
   return NS_OK;
 }
 
 void
+nsDOMMediaQueryList::RemoveAllListeners()
+{
+  bool hadListeners = HasListeners();
+  mListeners.Clear();
+  if (hadListeners) {
+    // See NS_ADDREF_THIS() in AddListener.
+    NS_RELEASE_THIS();
+  }
+}
+
+void
 nsDOMMediaQueryList::RecomputeMatches()
 {
   if (!mPresContext) {
     return;
   }
 
   mMatches = mMediaList->Matches(mPresContext, nsnull);
   mMatchesValid = true;
diff --git a/layout/style/nsDOMMediaQueryList.h b/layout/style/nsDOMMediaQueryList.h
--- a/layout/style/nsDOMMediaQueryList.h
+++ b/layout/style/nsDOMMediaQueryList.h
@@ -73,16 +73,20 @@ public:
   };
 
   typedef FallibleTArray< nsCOMPtr<nsIDOMMediaQueryListListener> > ListenerList;
   typedef FallibleTArray<HandleChangeData> NotifyList;
 
   // Appends listeners that need notification to aListenersToNotify
   void MediumFeaturesChanged(NotifyList &aListenersToNotify);
 
+  bool HasListeners() const { return !mListeners.IsEmpty(); }
+
+  void RemoveAllListeners();
+
 private:
   void RecomputeMatches();
 
   // We only need a pointer to the pres context to support lazy
   // reevaluation following dynamic changes.  However, this lazy
   // reevaluation is perhaps somewhat important, since some usage
   // patterns may involve the creation of large numbers of
   // MediaQueryList objects which almost immediately become garbage
diff --git a/layout/style/test/test_media_query_list.html b/layout/style/test/test_media_query_list.html
--- a/layout/style/test/test_media_query_list.html
+++ b/layout/style/test/test_media_query_list.html
@@ -32,30 +32,39 @@ function run() {
 
   var w = Math.floor(em_size * 9.3);
   var h = Math.floor(em_size * 4.2);
   iframe.style.width = w + "px";
   iframe.style.height = h + "px";
   subroot.offsetWidth; // flush layout
 
   function setup_mql(str) {
-    var obj = { str: str, mql: subwin.matchMedia(str), notifyCount: 0 }
-    obj.mql.addListener(function(mql) {
-                          is(mql, obj.mql,
-                             "correct argument to listener: " + obj.str);
-                          ++obj.notifyCount;
-                          // Test the last match result only on odd
-                          // notifications.
-                          if (obj.notifyCount & 1) {
-                            obj.lastOddMatchResult = mql.matches;
-                          }
-                        });
+    var obj = {
+      str: str,
+      mql: subwin.matchMedia(str),
+      notifyCount: 0,
+      listener: function(mql) {
+                  is(mql, obj.mql,
+                     "correct argument to listener: " + obj.str);
+                  ++obj.notifyCount;
+                  // Test the last match result only on odd
+                  // notifications.
+                  if (obj.notifyCount & 1) {
+                    obj.lastOddMatchResult = mql.matches;
+                  }
+                }
+    }
+    obj.mql.addListener(obj.listener);
     return obj;
   }
 
+  function finish_mql(obj) {
+    obj.mql.removeListener(obj.listener);
+  }
+
   var w_exact_w = setup_mql("(width: " + w + "px)");
   var w_min_9em = setup_mql("(min-width : 9em)");
   var w_min_10em = setup_mql("(  min-width: 10em ) ");
   var w_max_9em = setup_mql("(max-width: 9em)");
   var w_max_10em = setup_mql("(max-width: 10em)");
 
   is(w_exact_w.mql.media, "(width: " + w + "px)", "serialization");
   is(w_min_9em.mql.media, "(min-width: 9em)", "serialization");
@@ -127,16 +136,22 @@ function run() {
   check_notify(w_min_10em, 2, "after zoom");
   check_match(w_max_9em, false, "after zoom");
   check_notify(w_max_9em, 0, "after zoom");
   check_match(w_max_10em, true, "after zoom");
   check_notify(w_max_10em, 2, "after zoom");
 
   SpecialPowers.setFullZoom(subwin, 1.0);
 
+  finish_mql(w_exact_w);
+  finish_mql(w_min_9em);
+  finish_mql(w_min_10em);
+  finish_mql(w_max_9em);
+  finish_mql(w_max_10em);
+
   // Additional tests of listener mutation.
   (function() {
     var received = [];
     var received_mql = [];
     function listener1(mql) {
       received.push(1);
       received_mql.push(mql);
     }
@@ -244,15 +259,65 @@ function run() {
     is(JSON.stringify(received), "[1,3]",
        "listeners not notified for changes after their removal");
     is(received_mql[0], mql,
        "notification order (removal tests)");
     is(received_mql[1], mql,
        "notification order (removal tests)");
   })();
 
-  SimpleTest.finish();
+  /* Bug 716751: null-dereference crash */
+  (function() {
+    iframe.style.width = "200px";
+    subroot.offsetWidth; // flush layout
+
+    var mql = subwin.matchMedia("(min-width: 150px)");
+    mql.addListener(null);
+
+    iframe.style.width = "100px";
+    subroot.offsetWidth; // flush layout
+    // With the bug, we crash here.  No need for test assertions.
+
+    mql.removeListener(null);
+    mql.removeListener(null);
+  })();
+
+  /* Bug 716751: listeners lost due to GC */
+  var gc_received = [];
+  (function() {
+    var received = [];
+    var listener1 = function(mql) {
+      gc_received.push(1);
+    }
+
+    iframe.style.width = "200px";
+    subroot.offsetWidth; // flush layout
+
+    var mql = subwin.matchMedia("(min-width: 150px)");
+    mql.addListener(listener1);
+    is(JSON.stringify(gc_received), "[]", "GC test: before notification");
+
+    iframe.style.width = "100px";
+    subroot.offsetWidth; // flush layout
+
+    is(JSON.stringify(gc_received), "[1]", "GC test: after notification 1");
+
+    // Because of conservative GC, we need to go back to the event loop
+    // to GC properly.
+    setTimeout(step2, 0);
+  })();
+
+  function step2() {
+    SpecialPowers.DOMWindowUtils.garbageCollect();
+
+    iframe.style.width = "200px";
+    subroot.offsetWidth; // flush layout
+
+    is(JSON.stringify(gc_received), "[1,1]", "GC test: after notification 2");
+
+    SimpleTest.finish();
+  }
 }
 
 </script>
 </pre>
 </body>
 </html>
