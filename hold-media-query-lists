From: L. David Baron <dbaron@dbaron.org>

Hold on to MediaQueryList objects that have listeners so that notification doesn't depend on GC timing.  (Bug 716751)

Note:  This also fixes a crash (when notifications happen) from
calling mql.addListeners(null).

The test for the null-dereference has been confirmed to crash without
the patch and pass with the patch.

TODO: Make the test for the main bug fail without the patch.

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -346,30 +346,43 @@ NS_IMPL_CYCLE_COLLECTING_RELEASE(nsPresC
 
 static PLDHashOperator
 TraverseImageLoader(const void * aKey, nsRefPtr<nsImageLoader>& aData,
                     void* aClosure)
 {
   nsCycleCollectionTraversalCallback *cb =
     static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
 
+  NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mImageLoaders[i] item");
   cb->NoteXPCOMChild(aData);
 
   return PL_DHASH_NEXT;
 }
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsPresContext)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDocument);
   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mDeviceContext); // not xpcom
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mEventManager, nsIObserver);
   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mLanguage); // an atom
 
   for (PRUint32 i = 0; i < IMAGE_LOAD_TYPE_COUNT; ++i)
     tmp->mImageLoaders[i].Enumerate(TraverseImageLoader, &cb);
 
+  // We own only the items in mDOMMediaQueryLists that have listeners;
+  // this reference is managed by their AddListener and RemoveListener
+  // methods.
+  for (PRCList *l = PR_LIST_HEAD(&tmp->mDOMMediaQueryLists);
+       l != &tmp->mDOMMediaQueryLists; l = PR_NEXT_LINK(l)) {
+    nsDOMMediaQueryList *mql = static_cast<nsDOMMediaQueryList*>(l);
+    if (mql->HasListeners()) {
+      NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mDOMMediaQueryLists item");
+      cb.NoteXPCOMChild(mql);
+    }
+  }
+
   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTheme); // a service
   // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLangService); // a service
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrintSettings);
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrefChangedTimer);
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsPresContext)
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDocument);
@@ -377,16 +390,27 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(ns
   if (tmp->mEventManager) {
     // unclear if these are needed, but can't hurt
     tmp->mEventManager->NotifyDestroyPresContext(tmp);
     tmp->mEventManager->SetPresContext(nsnull);
 
     NS_RELEASE(tmp->mEventManager);
   }
 
+  // We own only the items in mDOMMediaQueryLists that have listeners;
+  // this reference is managed by their AddListener and RemoveListener
+  // methods.
+  for (PRCList *l = PR_LIST_HEAD(&tmp->mDOMMediaQueryLists);
+       l != &tmp->mDOMMediaQueryLists; ) {
+    PRCList *next = PR_NEXT_LINK(l);
+    nsDOMMediaQueryList *mql = static_cast<nsDOMMediaQueryList*>(l);
+    mql->RemoveAllListeners();
+    l = next;
+  }
+
   // NS_RELEASE(tmp->mLanguage); // an atom
 
   // NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mTheme); // a service
   // NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mLangService); // a service
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPrintSettings);
   if (tmp->mPrefChangedTimer)
   {
     tmp->mPrefChangedTimer->Cancel();
diff --git a/layout/style/nsDOMMediaQueryList.cpp b/layout/style/nsDOMMediaQueryList.cpp
--- a/layout/style/nsDOMMediaQueryList.cpp
+++ b/layout/style/nsDOMMediaQueryList.cpp
@@ -69,17 +69,17 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMP
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY_OF_NSCOMPTR(mListeners)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsDOMMediaQueryList)
 if (tmp->mPresContext) {
   PR_REMOVE_LINK(tmp);
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPresContext)
 }
-NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mListeners)
+tmp->RemoveAllListeners();
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 DOMCI_DATA(MediaQueryList, nsDOMMediaQueryList)
 
 NS_INTERFACE_MAP_BEGIN(nsDOMMediaQueryList)
   NS_INTERFACE_MAP_ENTRY(nsIDOMMediaQueryList)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsDOMMediaQueryList)
@@ -95,50 +95,78 @@ nsDOMMediaQueryList::GetMedia(nsAString 
   mMediaList->GetText(aMedia);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMMediaQueryList::GetMatches(bool *aMatches)
 {
   if (!mMatchesValid) {
-    NS_ABORT_IF_FALSE(mListeners.Length() == 0,
+    NS_ABORT_IF_FALSE(!HasListeners(),
                       "when listeners present, must keep mMatches current");
     RecomputeMatches();
   }
 
   *aMatches = mMatches;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMMediaQueryList::AddListener(nsIDOMMediaQueryListListener *aListener)
 {
+  if (!aListener) {
+    return NS_OK;
+  }
+
+  if (!HasListeners()) {
+    // When we have listeners, the pres context owns a reference to
+    // this.  This is a cyclic reference that can only be broken by
+    // cycle collection.
+    NS_ADDREF_THIS();
+  }
+
   if (!mMatchesValid) {
-    NS_ABORT_IF_FALSE(mListeners.Length() == 0,
+    NS_ABORT_IF_FALSE(!HasListeners(),
                       "when listeners present, must keep mMatches current");
     RecomputeMatches();
   }
 
   if (!mListeners.Contains(aListener)) {
     mListeners.AppendElement(aListener);
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMMediaQueryList::RemoveListener(nsIDOMMediaQueryListListener *aListener)
 {
-  mListeners.RemoveElement(aListener);
+  bool removed = mListeners.RemoveElement(aListener);
   NS_ABORT_IF_FALSE(!mListeners.Contains(aListener),
                     "duplicate occurrence of listeners");
+
+  if (removed && !HasListeners()) {
+    // See NS_ADDREF_THIS() in AddListener.
+    NS_RELEASE_THIS();
+  }
+
   return NS_OK;
 }
 
 void
+nsDOMMediaQueryList::RemoveAllListeners()
+{
+  bool hadListeners = HasListeners();
+  mListeners.Clear();
+  if (hadListeners) {
+    // See NS_ADDREF_THIS() in AddListener.
+    NS_RELEASE_THIS();
+  }
+}
+
+void
 nsDOMMediaQueryList::RecomputeMatches()
 {
   if (!mPresContext) {
     return;
   }
 
   mMatches = mMediaList->Matches(mPresContext, nsnull);
   mMatchesValid = true;
diff --git a/layout/style/nsDOMMediaQueryList.h b/layout/style/nsDOMMediaQueryList.h
--- a/layout/style/nsDOMMediaQueryList.h
+++ b/layout/style/nsDOMMediaQueryList.h
@@ -73,16 +73,20 @@ public:
   };
 
   typedef FallibleTArray< nsCOMPtr<nsIDOMMediaQueryListListener> > ListenerList;
   typedef FallibleTArray<HandleChangeData> NotifyList;
 
   // Appends listeners that need notification to aListenersToNotify
   void MediumFeaturesChanged(NotifyList &aListenersToNotify);
 
+  bool HasListeners() const { return !mListeners.IsEmpty(); }
+
+  void RemoveAllListeners();
+
 private:
   void RecomputeMatches();
 
   // We only need a pointer to the pres context to support lazy
   // reevaluation following dynamic changes.  However, this lazy
   // reevaluation is perhaps somewhat important, since some usage
   // patterns may involve the creation of large numbers of
   // MediaQueryList objects which almost immediately become garbage
diff --git a/layout/style/test/test_media_query_list.html b/layout/style/test/test_media_query_list.html
--- a/layout/style/test/test_media_query_list.html
+++ b/layout/style/test/test_media_query_list.html
@@ -244,15 +244,60 @@ function run() {
     is(JSON.stringify(received), "[1,3]",
        "listeners not notified for changes after their removal");
     is(received_mql[0], mql,
        "notification order (removal tests)");
     is(received_mql[1], mql,
        "notification order (removal tests)");
   })();
 
+  /* Bug 716751: null-dereference crash */
+  (function() {
+    iframe.style.width = "200px";
+    subroot.offsetWidth; // flush layout
+
+    var mql = subwin.matchMedia("(min-width: 150px)");
+    mql.addListener(null);
+
+    iframe.style.width = "100px";
+    subroot.offsetWidth; // flush layout
+  })();
+
+  /* Bug 716751: listeners lost due to GC */
+  (function() {
+    var received = [];
+    var received_mql = [];
+    var listener1 = function(mql) {
+      received.push(1);
+      received_mql.push(mql);
+    }
+
+    iframe.style.width = "200px";
+    subroot.offsetWidth; // flush layout
+
+    var mql = subwin.matchMedia("(min-width: 150px)");
+    mql.addListener(listener1);
+    is(JSON.stringify(received), "[]", "listeners before notification");
+
+    iframe.style.width = "100px";
+    subroot.offsetWidth; // flush layout
+
+    is(JSON.stringify(received), "[1]", "listeners after first notification");
+
+    mql = null;
+    listener1 = null;
+    SpecialPowers.DOMWindowUtils.garbageCollect();
+
+    iframe.style.width = "200px";
+    subroot.offsetWidth; // flush layout
+
+    is(JSON.stringify(received), "[1,1]",
+       "listeners after second notification");
+  })();
+
+
   SimpleTest.finish();
 }
 
 </script>
 </pre>
 </body>
 </html>
