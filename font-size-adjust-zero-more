From: L. David Baron <dbaron@dbaron.org>

Bug 1144885 additional changes.

These make the adjusted size 0 more consistently when font-size-adjust
is 0; with the prior patch this was only fully true for gfxDWriteFonts.

I'll merge this in to the other patch once reviewed.

I didn't observe any problems related to this, but I think this probably
is needed for consistency, to keep mAdjustedSize sensible.

diff --git a/gfx/thebes/gfxFT2FontBase.cpp b/gfx/thebes/gfxFT2FontBase.cpp
--- a/gfx/thebes/gfxFT2FontBase.cpp
+++ b/gfx/thebes/gfxFT2FontBase.cpp
@@ -109,17 +109,18 @@ gfxFT2FontBase::GetGlyphExtents(uint32_t
 }
 
 const gfxFont::Metrics&
 gfxFT2FontBase::GetHorizontalMetrics()
 {
     if (mHasMetrics)
         return mMetrics;
 
-    if (MOZ_UNLIKELY(GetStyle()->size <= 0.0)) {
+    if (MOZ_UNLIKELY(GetStyle()->size <= 0.0) ||
+        MOZ_UNLIKELY(GetStyle()->sizeAdjust == 0.0)) {
         new(&mMetrics) gfxFont::Metrics(); // zero initialize
         mSpaceGlyph = GetGlyph(' ');
     } else {
         gfxFT2LockedFace face(this);
         face.GetMetrics(&mMetrics, &mSpaceGlyph);
     }
 
     SanitizeMetrics(&mMetrics, false);
diff --git a/gfx/thebes/gfxFont.cpp b/gfx/thebes/gfxFont.cpp
--- a/gfx/thebes/gfxFont.cpp
+++ b/gfx/thebes/gfxFont.cpp
@@ -2196,16 +2196,17 @@ gfxFont::Measure(gfxTextRun *aTextRun,
     const gfxTextRun::CompressedGlyph *charGlyphs = aTextRun->GetCharacterGlyphs();
     bool isRTL = aTextRun->IsRightToLeft();
     double direction = aTextRun->GetDirection();
     bool needsGlyphExtents = NeedsGlyphExtents(this, aTextRun);
     gfxGlyphExtents *extents =
         ((aBoundingBoxType == LOOSE_INK_EXTENTS &&
             !needsGlyphExtents &&
             !aTextRun->HasDetailedGlyphs()) ||
+         (MOZ_UNLIKELY(GetStyle()->sizeAdjust == 0.0)) ||
          (MOZ_UNLIKELY(GetStyle()->size == 0))) ? nullptr
         : GetOrCreateGlyphExtents(aTextRun->GetAppUnitsPerDevUnit());
     double x = 0;
     if (aSpacing) {
         x += direction*aSpacing[0].mBefore;
     }
     uint32_t spaceGlyph = GetSpaceGlyph();
     bool allGlyphsInvisible = true;
@@ -3315,17 +3316,17 @@ void gfxFont::CalculateDerivedMetrics(Me
     }
 }
 
 void
 gfxFont::SanitizeMetrics(gfxFont::Metrics *aMetrics, bool aIsBadUnderlineFont)
 {
     // Even if this font size is zero, this font is created with non-zero size.
     // However, for layout and others, we should return the metrics of zero size font.
-    if (mStyle.size == 0.0) {
+    if (mStyle.size == 0.0 || mStyle.sizeAdjust == 0.0) {
         memset(aMetrics, 0, sizeof(gfxFont::Metrics));
         return;
     }
 
     aMetrics->underlineSize = std::max(1.0, aMetrics->underlineSize);
     aMetrics->strikeoutSize = std::max(1.0, aMetrics->strikeoutSize);
 
     aMetrics->underlineOffset = std::min(aMetrics->underlineOffset, -1.0);
diff --git a/gfx/thebes/gfxFont.h b/gfx/thebes/gfxFont.h
--- a/gfx/thebes/gfxFont.h
+++ b/gfx/thebes/gfxFont.h
@@ -1382,17 +1382,19 @@ public:
     virtual cairo_scaled_font_t* GetCairoScaledFont() { return mScaledFont; }
 
     virtual gfxFont* CopyWithAntialiasOption(AntialiasOption anAAOption) {
         // platforms where this actually matters should override
         return nullptr;
     }
 
     virtual gfxFloat GetAdjustedSize() const {
-        return mAdjustedSize > 0.0 ? mAdjustedSize : mStyle.size;
+        return mAdjustedSize > 0.0
+                 ? mAdjustedSize
+                 : (mStyle.sizeAdjust == 0.0 ? 0.0 : mStyle.size);
     }
 
     float FUnitsToDevUnitsFactor() const {
         // check this was set up during font initialization
         NS_ASSERTION(mFUnitsConvFactor > 0.0f, "mFUnitsConvFactor not valid");
         return mFUnitsConvFactor;
     }
 
diff --git a/gfx/thebes/gfxGDIFont.cpp b/gfx/thebes/gfxGDIFont.cpp
--- a/gfx/thebes/gfxGDIFont.cpp
+++ b/gfx/thebes/gfxGDIFont.cpp
@@ -208,16 +208,18 @@ gfxGDIFont::Initialize()
             gfxFloat aspect = mMetrics->xHeight / mMetrics->emHeight;
             mAdjustedSize = mStyle.GetAdjustedSize(aspect);
 
             // delete the temporary font and metrics
             ::DeleteObject(mFont);
             mFont = nullptr;
             delete mMetrics;
             mMetrics = nullptr;
+        } else if (mStyle.sizeAdjust == 0.0) {
+            mAdjustedSize = 0.0;
         }
     }
 
     // (bug 724231) for local user fonts, we don't use GDI's synthetic bold,
     // as it could lead to a different, incompatible face being used
     // but instead do our own multi-striking
     if (mNeedsBold && GetFontEntry()->IsLocalUserFont()) {
         mApplySyntheticBold = true;
