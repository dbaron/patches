From: L. David Baron <dbaron@dbaron.org>

Transition manager should use SetStyleContext rather than SetStyleContextWithoutNotification.

While debugging bug 858937 I noticed that the transition manager was
calling nsIFrame::SetStyleContextWithoutNotification rather than
nsIFrame::SetStyleContext.  SetStyleContextWithoutNotification should
only be used for things that aren't really style changes, but are
instead changes we make during frame construction before things are
really initialized.  Anything that's really a dynamic style change, as
these are, should use SetStyleContext.

I realize I said the opposite in bug 780692 comment 186, and bz said the
same in bug 780692 comment 204, which is why this is the state that it
is.

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -215,23 +215,23 @@ static void ReparentBeforeAndAfter(dom::
                                    nsIFrame* aPrimaryFrame,
                                    nsStyleContext* aNewStyle,
                                    nsStyleSet* aStyleSet)
 {
   if (nsIFrame* before = nsLayoutUtils::GetBeforeFrame(aPrimaryFrame)) {
     nsRefPtr<nsStyleContext> beforeStyle =
       aStyleSet->ReparentStyleContext(before->StyleContext(),
                                      aNewStyle, aElement);
-    before->SetStyleContextWithoutNotification(beforeStyle);
+    before->SetStyleContext(beforeStyle);
   }
   if (nsIFrame* after = nsLayoutUtils::GetBeforeFrame(aPrimaryFrame)) {
     nsRefPtr<nsStyleContext> afterStyle =
       aStyleSet->ReparentStyleContext(after->StyleContext(),
                                      aNewStyle, aElement);
-    after->SetStyleContextWithoutNotification(afterStyle);
+    after->SetStyleContext(afterStyle);
   }
 }
 
 // Ensure that the next repaint rebuilds the layer tree for aFrame. That
 // means that changes to animations on aFrame's layer are propagated to
 // the compositor, which is needed for correct behaviour of new
 // transitions.
 static void
@@ -314,17 +314,17 @@ nsTransitionManager::UpdateThrottledStyl
   // We absolutely must call CalcStyleDifference in order to ensure the
   // new context has all the structs cached that the old context had.
   // We also need it for processing of the changes.
   nsChangeHint styleChange =
     oldStyle->CalcStyleDifference(newStyle, nsChangeHint(0));
   aChangeList.AppendChange(primaryFrame, primaryFrame->GetContent(),
                            styleChange);
 
-  primaryFrame->SetStyleContextWithoutNotification(newStyle);
+  primaryFrame->SetStyleContext(newStyle);
 
   ReparentBeforeAndAfter(aElement, primaryFrame, newStyle, mPresContext->PresShell()->StyleSet());
 
   return newStyle;
 }
 
 void
 nsTransitionManager::UpdateThrottledStylesForSubtree(nsIContent* aContent,
@@ -354,17 +354,17 @@ nsTransitionManager::UpdateThrottledStyl
     nsStyleSet* styleSet = mPresContext->PresShell()->StyleSet();
     nsIFrame* primaryFrame = nsLayoutUtils::GetStyleFrame(aContent);
     if (!primaryFrame) {
       return;
     }
 
     newStyle = styleSet->ReparentStyleContext(primaryFrame->StyleContext(),
                                               aParentStyle, element);
-    primaryFrame->SetStyleContextWithoutNotification(newStyle);
+    primaryFrame->SetStyleContext(newStyle);
     ReparentBeforeAndAfter(element, primaryFrame, newStyle, styleSet);
   }
 
   // walk the children
   if (newStyle) {
     for (nsIContent *child = aContent->GetFirstChild(); child;
          child = child->GetNextSibling()) {
       UpdateThrottledStylesForSubtree(child, newStyle, aChangeList);
