Suspect all native wrappers during cycle collection.  b=368869  r=graydon  sr=jst

diff --git a/js/src/xpconnect/src/nsXPConnect.cpp b/js/src/xpconnect/src/nsXPConnect.cpp
--- a/js/src/xpconnect/src/nsXPConnect.cpp
+++ b/js/src/xpconnect/src/nsXPConnect.cpp
@@ -574,6 +574,8 @@ nsXPConnect::BeginCycleCollection()
     JS_SetGCThingCallback(cx, nsnull, nsnull);
     JS_SetGCCallback(cx, gOldJSGCCallback);
     gOldJSGCCallback = nsnull;
+
+    XPCWrappedNativeScope::SuspectAllWrappers(mRuntime);
 
 #ifndef XPCONNECT_STANDALONE
     NS_ASSERTION(mObjRefcounts->mScopes.Count() == 0, "Didn't clear mScopes?");
diff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h
--- a/js/src/xpconnect/src/xpcprivate.h
+++ b/js/src/xpconnect/src/xpcprivate.h
@@ -1134,6 +1134,9 @@ public:
 
     static void
     TraceJS(JSTracer* trc, XPCJSRuntime* rt);
+
+    static void
+    SuspectAllWrappers(XPCJSRuntime* rt);
 
     static void
     FinishedMarkPhaseOfGC(JSContext* cx, XPCJSRuntime* rt);
diff --git a/js/src/xpconnect/src/xpcwrappednativescope.cpp b/js/src/xpconnect/src/xpcwrappednativescope.cpp
--- a/js/src/xpconnect/src/xpcwrappednativescope.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativescope.cpp
@@ -271,15 +271,8 @@ WrappedNativeJSGCThingTracer(JSDHashTabl
         JSTracer* trc = (JSTracer *)arg;
         JS_CALL_OBJECT_TRACER(trc, wrapper->GetFlatJSObject(),
                               "XPCWrappedNative::mFlatJSObject");
-
-        // FIXME: this call appears to do more harm than good, but
-        // there is reason to imagine it might clean up some cycles
-        // formed by a poor order between C++ and JS garbage cycle
-        // formations. See Bug 368869.
-        //
-        // if (JS_IsGCMarkingTracer(trc))
-        //   nsCycleCollector_suspectCurrent(wrapper);
-    }
+    }
+
     return JS_DHASH_NEXT;
 }
 
@@ -291,10 +284,39 @@ XPCWrappedNativeScope::TraceJS(JSTracer*
     // access to JS runtime. See bug 380139.
     XPCAutoLock lock(rt->GetMapLock());
 
-    // Do JS_CallTracer for all wrapperednatives with external references.
+    // Do JS_CallTracer for all wrapped natives with external references.
     for(XPCWrappedNativeScope* cur = gScopes; cur; cur = cur->mNext)
     {
         cur->mWrappedNativeMap->Enumerate(WrappedNativeJSGCThingTracer, trc);
+    }
+}
+
+JS_STATIC_DLL_CALLBACK(JSDHashOperator)
+WrappedNativeSuspecter(JSDHashTable *table, JSDHashEntryHdr *hdr,
+                       uint32 number, void *arg)
+{
+    XPCWrappedNative* wrapper = ((Native2WrappedNativeMap::Entry*)hdr)->value;
+    XPCWrappedNativeProto* proto = wrapper->GetProto();
+    if(proto && proto->ClassIsMainThreadOnly()) 
+    {
+        NS_ASSERTION(NS_IsMainThread(), 
+                     "Suspecting wrapped natives from non-main thread");
+        nsCycleCollector_suspectCurrent(wrapper);
+    }
+
+    return JS_DHASH_NEXT;
+}
+
+// static
+void
+XPCWrappedNativeScope::SuspectAllWrappers(XPCJSRuntime* rt)
+{
+    XPCAutoLock lock(rt->GetMapLock());
+
+    // Do nsCycleCollector_suspectCurrent for all wrapped natives.
+    for(XPCWrappedNativeScope* cur = gScopes; cur; cur = cur->mNext)
+    {
+        cur->mWrappedNativeMap->Enumerate(WrappedNativeSuspecter, nsnull);
     }
 }
 
