From: L. David Baron <dbaron@dbaron.org>

Add tests for media query serialization.

diff --git a/layout/style/test/test_media_queries.html b/layout/style/test/test_media_queries.html
--- a/layout/style/test/test_media_queries.html
+++ b/layout/style/test/test_media_queries.html
@@ -33,20 +33,22 @@ function run() {
 
   function query_applies(q) {
     style.setAttribute("media", q);
     return body_cs.getPropertyValue("text-decoration") == "underline";
   }
 
   function should_apply(q) {
     ok(query_applies(q), q + " should apply");
+    test_serialization(q, true, true);
   }
 
   function should_not_apply(q) {
     ok(!query_applies(q), q + " should not apply");
+    test_serialization(q, true, false);
   }
 
   /*
    * Functions to test whether a query is parseable at all.  (Should not
    * be used for parse errors within expressions.)
    */
   var parse_test_style_element = document.createElement("style");
   parse_test_style_element.type = "text/css";
@@ -64,16 +66,17 @@ function run() {
       return sheet.cssRules[0].media.mediaText != "screen";
     ok(false, "unexpected result testing whether query " + q +
               " is parseable");
     return true; // doesn't matter, we already failed
   }
 
   function query_should_be_parseable(q) {
     ok(query_is_parseable(q), "query " + q + " should be parseable");
+    test_serialization(q, false, false);
   }
 
   function query_should_not_be_parseable(q) {
     ok(!query_is_parseable(q), "query " + q + " should not be parseable");
   }
 
   /*
    * Functions to test whether a single media expression is parseable.
@@ -81,23 +84,36 @@ function run() {
   function expression_is_parseable(e) {
     style.setAttribute("media", "all and (" + e + ")");
     return style.sheet.media.mediaText != "not all";
   }
 
   function expression_should_be_parseable(e) {
     ok(expression_is_parseable(e),
        "expression " + e + " should be parseable");
+    test_serialization("all and (" + q + ")", false, false);
   }
 
   function expression_should_not_be_parseable(e) {
     ok(!expression_is_parseable(e),
        "expression " + e + " should not be parseable");
   }
 
+  function test_serialization(q, test_application, should_apply) {
+    style.setAttribute("media", q);
+    var ser1 = style.sheet.media.mediaText;
+    isnot(ser1, "", "serialization of '" + q + "' should not be empty");
+    style.setAttribute("media", ser1);
+    is(ser2, ser1, "parse+serialize of '" + q + "' should be idempotent");
+    if (test_application) {
+      var applies = body_cs.getPropertyValue("text-decoration") == "underline";
+      is(applies, should_apply, "Media query '" + q "' should apply after serialize + reparse");
+    }
+  }
+
   // The no-type syntax doesn't mix with the not and only keywords.
   query_should_be_parseable("(orientation)");
   query_should_not_be_parseable("not (orientation)");
   query_should_not_be_parseable("only (orientation)");
   query_should_be_parseable("all and (orientation)");
   query_should_be_parseable("not all and (orientation)");
   query_should_be_parseable("only all and (orientation)");
 
