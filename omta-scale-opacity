From: L. David Baron <dbaron@dbaron.org>

Bug 1122526 patch 2 - BETTER NAME NEEDED Add tests with opacity as well.

diff --git a/layout/base/FrameLayerBuilder.cpp b/layout/base/FrameLayerBuilder.cpp
--- a/layout/base/FrameLayerBuilder.cpp
+++ b/layout/base/FrameLayerBuilder.cpp
@@ -4620,16 +4620,17 @@ static void RestrictScaleToMaxLayerSize(
     scale = gfxUtils::ClampToScaleFactor(scale);
     aScale.height /= scale;
   }
 }
 static bool
 ChooseScaleAndSetTransform(FrameLayerBuilder* aLayerBuilder,
                            nsDisplayListBuilder* aDisplayListBuilder,
                            nsIFrame* aContainerFrame,
+                           nsDisplayItem* aContainerItem,
                            const nsRect& aVisibleRect,
                            const Matrix4x4* aTransform,
                            const ContainerLayerParameters& aIncomingScale,
                            ContainerLayer* aLayer,
                            LayerState aState,
                            ContainerLayerParameters& aOutgoingScale)
 {
   nsIntPoint offset;
@@ -4675,16 +4676,18 @@ ChooseScaleAndSetTransform(FrameLayerBui
 
   bool canDraw2D = transform.CanDraw2D(&transform2d);
   gfxSize scale;
   // XXX Should we do something for 3D transforms?
   if (canDraw2D) {
     // If the container's transform is animated off main thread, fix a suitable scale size
     // for animation
     if (aContainerFrame->GetContent() &&
+        aContainerItem &&
+        aContainerItem->GetType() == nsDisplayItem::TYPE_TRANSFORM &&
         nsLayoutUtils::HasAnimationsForCompositor(
           aContainerFrame->GetContent(), eCSSProperty_transform)) {
       // compute scale using the animation on the container (ignoring
       // its ancestors)
       scale = nsLayoutUtils::ComputeSuitableScaleForAnimation(
                 aContainerFrame->GetContent(), aVisibleRect.Size(),
                 aContainerFrame->PresContext()->GetVisibleArea().Size());
       // multiply by the scale inherited from ancestors
@@ -4868,16 +4871,17 @@ FrameLayerBuilder::BuildContainerLayerFo
   }
 
   ContainerLayerParameters scaleParameters;
   nsRect bounds = aChildren->GetBounds(aBuilder);
   nsRect childrenVisible =
       aContainerItem ? aContainerItem->GetVisibleRectForChildren() :
           aContainerFrame->GetVisualOverflowRectRelativeToSelf();
   if (!ChooseScaleAndSetTransform(this, aBuilder, aContainerFrame,
+                                  aContainerItem,
                                   bounds.Intersect(childrenVisible),
                                   aTransform, aParameters,
                                   containerLayer, state, scaleParameters)) {
     return nullptr;
   }
 
   uint32_t oldGeneration = mContainerLayerGeneration;
   mContainerLayerGeneration = ++mMaxContainerLayerGeneration;
diff --git a/layout/reftests/transform/animate-layer-scale-inherit-2-ref.html b/layout/reftests/transform/animate-layer-scale-inherit-2-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/transform/animate-layer-scale-inherit-2-ref.html
@@ -0,0 +1,24 @@
+<!DOCTYPE HTML>
+<title>Testcase, bug 1122526</title>
+<style>
+
+#outer, #inner {
+  display: inline-block;
+  background: white;
+  color: black;
+}
+
+#inner {
+  vertical-align: top;
+  height: 100px;
+  width: 100px;
+  background: repeating-linear-gradient(to top left, yellow, blue 10px);
+  opacity: 0.6;
+}
+
+</style>
+
+<div id="outer">
+  <div id="inner">
+  </div>
+</div>
diff --git a/layout/reftests/transform/animate-layer-scale-inherit-2.html b/layout/reftests/transform/animate-layer-scale-inherit-2.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/transform/animate-layer-scale-inherit-2.html
@@ -0,0 +1,31 @@
+<!DOCTYPE HTML>
+<title>Testcase, bug 1122526</title>
+<style>
+
+#outer, #inner {
+  display: inline-block;
+  background: white;
+  color: black;
+}
+#outer { transform: scale(20) }
+#inner { animation: HoldTransform linear infinite 1s,
+                    HoldOpacity   linear infinite 1s; }
+#inner {
+  vertical-align: top;
+  height: 100px;
+  width: 100px;
+  background: repeating-linear-gradient(to top left, yellow, blue 10px);
+}
+@keyframes HoldTransform {
+  from, to { transform: scale(0.05) }
+}
+@keyframes HoldOpacity {
+  from, to { opacity: 0.6 }
+}
+
+</style>
+
+<div id="outer">
+  <div id="inner">
+  </div>
+</div>
diff --git a/layout/reftests/transform/reftest.list b/layout/reftests/transform/reftest.list
--- a/layout/reftests/transform/reftest.list
+++ b/layout/reftests/transform/reftest.list
@@ -129,8 +129,9 @@ pref(svg.transform-origin.enabled,true) 
 pref(svg.transform-origin.enabled,true) == transform-box-svg-2a.svg transform-box-svg-2-ref.svg
 pref(svg.transform-origin.enabled,true) == transform-box-svg-2b.svg transform-box-svg-2-ref.svg
 pref(svg.transform-origin.enabled,true) == transform-origin-svg-1a.svg transform-origin-svg-1-ref.svg
 pref(svg.transform-origin.enabled,true) == transform-origin-svg-1b.svg transform-origin-svg-1-ref.svg
 pref(svg.transform-origin.enabled,true) == transform-origin-svg-2a.svg transform-origin-svg-2-ref.svg
 pref(svg.transform-origin.enabled,true) == transform-origin-svg-2b.svg transform-origin-svg-2-ref.svg
 # Bug 1122526
 == animate-layer-scale-inherit-1.html animate-layer-scale-inherit-1-ref.html
+== animate-layer-scale-inherit-2.html animate-layer-scale-inherit-2-ref.html
