From: L. David Baron <dbaron@dbaron.org>

Bug 1090555 - Fix visited link test in test_animations_omta.html to wait for visited link coloring properly.

I tested locally that without the patch I get the failures, and with the
patch the failures go away, using:
./mach mochitest-plain --e10s --setpref layers.acceleration.force-enabled=true --setpref layers.offmainthreadcomposition.async-animations=true layout/style/test/test_animations_omta.html

Further, when running (and passing), I checked that
waitForVisitedLinkColoring() does go through one setTimeout cycle.

Also, I tested that if I effectively revert
https://hg.mozilla.org/mozilla-central/rev/d13154302d77 by changing the
third parameter to the GetContext call in
nsStyleSet::ResolveStyleWithReplacement to be nullptr instead of
visitedRuleNode, I get the failure:
TEST-UNEXPECTED-FAIL | layout/style/test/test_animations_omta.html | visited link background color after animation-only flush - got rgb(255, 255, 0), expected rgb(0, 0, 255)
which confirms that the test is still testing what it was designed to
test.

diff --git a/layout/style/test/animation_utils.js b/layout/style/test/animation_utils.js
--- a/layout/style/test/animation_utils.js
+++ b/layout/style/test/animation_utils.js
@@ -671,8 +671,25 @@ function waitForPaints() {
 }
 
 // As with waitForPaints but also flushes pending style changes before waiting
 function waitForPaintsFlushed() {
   return new Promise(function(resolve, reject) {
     waitForAllPaintsFlushed(resolve);
   });
 }
+
+function waitForVisitedLinkColoring(visitedLink, waitProperty, waitValue) {
+  function check_link(resolve) {
+    if (SpecialPowers.DOMWindowUtils
+          .getVisitedDependentComputedStyle(visitedLink, "", waitProperty) ==
+        waitValue) {
+      // Our link has been styled as visited.  Resolve.
+      resolve(true);
+    } else {
+      // Our link is not yet styled as visited.  Poll for completion.
+      setTimeout(check_link, 0, resolve);
+    }
+  }
+  return new Promise(function(resolve, reject) {
+    check_link(resolve);
+  });
+}
diff --git a/layout/style/test/mochitest.ini b/layout/style/test/mochitest.ini
--- a/layout/style/test/mochitest.ini
+++ b/layout/style/test/mochitest.ini
@@ -32,17 +32,16 @@ support-files =
   xbl_bindings.xml
 generated-files = css_properties.js
 
 [test_acid3_test46.html]
 [test_all_shorthand.html]
 [test_animations.html]
 skip-if = toolkit == 'android'
 [test_animations_omta.html]
-skip-if = buildapp == 'mulet'
 [test_animations_omta_start.html]
 skip-if = (buildapp == 'b2g' && toolkit != 'gonk') # bug 1041017
 [test_animations_pausing.html]
 [test_any_dynamic.html]
 [test_at_rule_parse_serialize.html]
 [test_bug73586.html]
 [test_bug74880.html]
 [test_bug98997.html]
diff --git a/layout/style/test/test_animations_omta.html b/layout/style/test/test_animations_omta.html
--- a/layout/style/test/test_animations_omta.html
+++ b/layout/style/test/test_animations_omta.html
@@ -147,18 +147,18 @@ https://bugzilla.mozilla.org/show_bug.cg
 
     .target {
       /* The animation target needs geometry in order to qualify for OMTA */
       width: 100px;
       height: 100px;
       background-color: white;
     }
 
-    #visitedLink:link { background-color: yellow }
-    #visitedLink:visited { background-color: blue }
+    .visitedLink:link { background-color: yellow }
+    .visitedLink:visited { background-color: blue }
 
     @keyframes opacitymid {
       0% { opacity: 0.2 }
       100% { opacity: 0.8 }
     }
   </style>
 </head>
 <body>
@@ -2017,41 +2017,53 @@ addAsyncAnimTest(function *() {
                "empty keyframes rule");
 
   done_div();
 });
 
 // Bug 996796 patch 12 - test for correct visited styles during
 // animation-only style flush.
 addAsyncAnimTest(function *() {
+  var isb2g = SpecialPowers.Services.appinfo.name == "B2G";
+  if (isb2g) {
+    todo(false, "no global history on B2G; can't run test");
+    return;
+  }
+
   var div1 = document.createElement("div");
   div1.classList.add("target");
   div1.style.height = "10px";
   div1.style.animation = "anim2 linear 1s";
 
   var visitedLink = document.createElement("a");
-  visitedLink.setAttribute("href", "");
-  visitedLink.setAttribute("id", "visitedLink");
+  visitedLink.setAttribute("href", window.top.location.href);
+  visitedLink.classList.add("visitedLink");
   visitedLink.classList.add("target");
   visitedLink.style.display = "block";
   visitedLink.style.height = "10px";
   visitedLink.style.animation = "anim2 linear 1s";
 
+  var refVisitedLink = document.createElement("a");
+  refVisitedLink.setAttribute("href", window.top.location.href);
+  refVisitedLink.classList.add("visitedLink");
+
   gDisplay.appendChild(div1);
   gDisplay.appendChild(visitedLink);
+  gDisplay.appendChild(refVisitedLink);
 
-  // Wait for animations to start and for visited link coloring.
+  // Wait for visited link coloring.
+  yield waitForVisitedLinkColoring(refVisitedLink,
+                                   "background-color", "rgb(0, 0, 255)");
+
+  // Wait for animations to start.
   yield waitForPaintsFlushed();
 
   var bgColor = SpecialPowers.DOMWindowUtils
     .getVisitedDependentComputedStyle(visitedLink, "", "background-color");
-  var isb2g = SpecialPowers.Services.appinfo.name == "B2G";
-  // No global history in B2G.
-  (isb2g ? todo_is : is)(bgColor, "rgb(0, 0, 255)",
-                         "initial visited link background color");
+  is(bgColor, "rgb(0, 0, 255)", "initial visited link background color");
 
   if (isb2g) {
     // The above failure makes the rest of the test pointless.
     div1.remove();
     visitedLink.remove();
     return;
   }
 
@@ -2065,16 +2077,17 @@ addAsyncAnimTest(function *() {
   bgColor = SpecialPowers.DOMWindowUtils
     .getVisitedDependentComputedStyle(visitedLink, "", "background-color");
 
   is(bgColor, "rgb(0, 0, 255)",
      "visited link background color after animation-only flush");
 
   div1.remove();
   visitedLink.remove();
+  refVisitedLink.remove();
 });
 
 /*
  * Bug 962594 - Turn off CSS animations when the element is display:none, or
  * is in a display:none subtree.
  */
 
 // Check that it works if the animated element itself becomes display:none
