From: L. David Baron <dbaron@dbaron.org>

Instantiate the calc ops struct rather than a nested data struct inside of it.  (Bug 363249)

diff --git a/layout/style/CSSCalc.h b/layout/style/CSSCalc.h
--- a/layout/style/CSSCalc.h
+++ b/layout/style/CSSCalc.h
@@ -46,34 +46,33 @@ namespace css {
 
 /**
  * ComputeCalc computes the result of a calc() expression tree.
  *
  * It is templatized over a CalcOps class that is expected to provide:
  *
  *   typedef ... result_type;
  *
- *   static result_type
+ *   result_type
  *   MergeAdditive(nsCSSUnit aCalcFunction,
  *                 result_type aValue1, result_type aValue2);
  *
- *   static result_type
+ *   result_type
  *   MergeMultiplicativeL(nsCSSUnit aCalcFunction,
  *                        float aValue1, result_type aValue2);
  *
- *   static result_type
+ *   result_type
  *   MergeMultiplicativeR(nsCSSUnit aCalcFunction,
  *                        result_type aValue1, float aValue2);
  *
- *   struct ComputeData { ... };
+ *   result_type
+ *   ComputeLeafValue(const nsCSSValue& aValue);
  *
- *   static result_type ComputeLeafValue(const nsCSSValue& aValue,
- *                                       const ComputeData& aClosure);
- *
- *   static float ComputeNumber(const nsCSSValue& aValue);
+ *   float
+ *   ComputeNumber(const nsCSSValue& aValue);
  *
  * The CalcOps methods might compute the calc() expression down to a
  * number, reduce some parts of it to a number but replicate other
  * parts, or produce a tree with a different data structure (for
  * example, nsCSS* for specified values vs nsStyle* for computed
  * values).
  *
  * For each leaf in the calc() expression, ComputeCalc will call either
@@ -87,80 +86,74 @@ namespace css {
  *
  * For non-leaves, one of the Merge functions will be called:
  *   MergeAdditive for Plus, Minus, Minimum, and Maximum
  *   MergeMultiplicativeL for Times_L (number * value)
  *   MergeMultiplicativeR for Times_R (value * number) and Divided
  */
 template <class CalcOps>
 static typename CalcOps::result_type
-ComputeCalc(const nsCSSValue& aValue,
-            const typename CalcOps::ComputeData &aClosure)
+ComputeCalc(const nsCSSValue& aValue, CalcOps &aOps)
 {
   switch (aValue.GetUnit()) {
     case eCSSUnit_Calc: {
       nsCSSValue::Array *arr = aValue.GetArrayValue();
       NS_ABORT_IF_FALSE(arr->Count() == 1, "unexpected length");
-      return ComputeCalc<CalcOps>(arr->Item(0), aClosure);
+      return ComputeCalc(arr->Item(0), aOps);
     }
     case eCSSUnit_Calc_Plus:
     case eCSSUnit_Calc_Minus: {
       nsCSSValue::Array *arr = aValue.GetArrayValue();
       NS_ABORT_IF_FALSE(arr->Count() == 2, "unexpected length");
-      typename CalcOps::result_type
-        lhs = ComputeCalc<CalcOps>(arr->Item(0), aClosure),
-        rhs = ComputeCalc<CalcOps>(arr->Item(1), aClosure);
-      return CalcOps::MergeAdditive(aValue.GetUnit(), lhs, rhs);
+      typename CalcOps::result_type lhs = ComputeCalc(arr->Item(0), aOps),
+                                    rhs = ComputeCalc(arr->Item(1), aOps);
+      return aOps.MergeAdditive(aValue.GetUnit(), lhs, rhs);
     }
     case eCSSUnit_Calc_Times_L: {
       nsCSSValue::Array *arr = aValue.GetArrayValue();
       NS_ABORT_IF_FALSE(arr->Count() == 2, "unexpected length");
-      float lhs = CalcOps::ComputeNumber(arr->Item(0));
-      typename CalcOps::result_type rhs =
-        ComputeCalc<CalcOps>(arr->Item(1), aClosure);
-      return CalcOps::MergeMultiplicativeL(aValue.GetUnit(), lhs, rhs);
+      float lhs = aOps.ComputeNumber(arr->Item(0));
+      typename CalcOps::result_type rhs = ComputeCalc(arr->Item(1), aOps);
+      return aOps.MergeMultiplicativeL(aValue.GetUnit(), lhs, rhs);
     }
     case eCSSUnit_Calc_Times_R:
     case eCSSUnit_Calc_Divided: {
       nsCSSValue::Array *arr = aValue.GetArrayValue();
       NS_ABORT_IF_FALSE(arr->Count() == 2, "unexpected length");
-      typename CalcOps::result_type lhs =
-        ComputeCalc<CalcOps>(arr->Item(0), aClosure);
-      float rhs = CalcOps::ComputeNumber(arr->Item(1));
-      return CalcOps::MergeMultiplicativeR(aValue.GetUnit(), lhs, rhs);
+      typename CalcOps::result_type lhs = ComputeCalc(arr->Item(0), aOps);
+      float rhs = aOps.ComputeNumber(arr->Item(1));
+      return aOps.MergeMultiplicativeR(aValue.GetUnit(), lhs, rhs);
     }
     case eCSSUnit_Calc_Minimum:
     case eCSSUnit_Calc_Maximum: {
       nsCSSValue::Array *arr = aValue.GetArrayValue();
-      typename CalcOps::result_type result =
-        ComputeCalc<CalcOps>(arr->Item(0), aClosure);
+      typename CalcOps::result_type result = ComputeCalc(arr->Item(0), aOps);
       for (PRUint32 i = 1, i_end = arr->Count(); i < i_end; ++i) {
-        typename CalcOps::result_type tmp =
-          ComputeCalc<CalcOps>(arr->Item(i), aClosure);
-        result = CalcOps::MergeAdditive(aValue.GetUnit(), result, tmp);
+        typename CalcOps::result_type tmp = ComputeCalc(arr->Item(i), aOps);
+        result = aOps.MergeAdditive(aValue.GetUnit(), result, tmp);
       }
       return result;
     }
     default: {
-      return CalcOps::ComputeLeafValue(aValue, aClosure);
+      return aOps.ComputeLeafValue(aValue);
     }
   }
 }
 
 /**
  * Basic*CalcOps provide a partial implementation of the CalcOps
  * template parameter to ComputeCalc, for those callers whose merging
  * just consists of mathematics (rather than tree construction).
  */
 template <typename T>
 struct BasicCalcOpsAdditive
 {
   typedef T result_type;
 
-  static result_type
+  result_type
   MergeAdditive(nsCSSUnit aCalcFunction,
                 result_type aValue1, result_type aValue2)
   {
     if (aCalcFunction == eCSSUnit_Calc_Plus) {
       return aValue1 + aValue2;
     }
     if (aCalcFunction == eCSSUnit_Calc_Minus) {
       return aValue1 - aValue2;
@@ -171,50 +164,50 @@ struct BasicCalcOpsAdditive
     NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Maximum,
                       "unexpected unit");
     return NS_MAX(aValue1, aValue2);
   }
 };
 
 struct BasicCoordCalcOps : public BasicCalcOpsAdditive<nscoord>
 {
-  static result_type
+  result_type
   MergeMultiplicativeL(nsCSSUnit aCalcFunction,
                        float aValue1, result_type aValue2)
   {
     NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Times_L,
                       "unexpected unit");
     return NSToCoordRound(aValue1 * aValue2);
   }
 
-  static result_type
+  result_type
   MergeMultiplicativeR(nsCSSUnit aCalcFunction,
                        result_type aValue1, float aValue2)
   {
     if (aCalcFunction == eCSSUnit_Calc_Times_R) {
       return NSToCoordRound(aValue1 * aValue2);
     }
     NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Divided,
                       "unexpected unit");
     return NSToCoordRound(aValue1 / aValue2);
   }
 };
 
 struct BasicFloatCalcOps : public BasicCalcOpsAdditive<float>
 {
-  static result_type
+  result_type
   MergeMultiplicativeL(nsCSSUnit aCalcFunction,
                        float aValue1, result_type aValue2)
   {
     NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Times_L,
                       "unexpected unit");
     return aValue1 * aValue2;
   }
 
-  static result_type
+  result_type
   MergeMultiplicativeR(nsCSSUnit aCalcFunction,
                        result_type aValue1, float aValue2)
   {
     if (aCalcFunction == eCSSUnit_Calc_Times_R) {
       return aValue1 * aValue2;
     }
     NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Divided,
                       "unexpected unit");
@@ -223,17 +216,17 @@ struct BasicFloatCalcOps : public BasicC
 };
 
 /**
  * A ComputeNumber implementation for callers that can assume numbers
  * are already normalized (i.e., anything past the parser).
  */
 struct NumbersAlreadyNormalizedOps
 {
-  static float ComputeNumber(const nsCSSValue& aValue)
+  float ComputeNumber(const nsCSSValue& aValue)
   {
     NS_ABORT_IF_FALSE(aValue.GetUnit() == eCSSUnit_Number, "unexpected unit");
     return aValue.GetFloatValue();
   }
 };
 
 }
 
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -7292,29 +7292,25 @@ CSSParserImpl::ParseCalcAdditiveExpressi
     arr->Item(0) = aValue;
     storage = &arr->Item(1);
     aValue.SetArrayValue(arr, unit);
   }
 }
 
 struct ReduceNumberCalcOps : public mozilla::css::BasicFloatCalcOps
 {
-  struct ComputeData {};
-
-  static result_type ComputeLeafValue(const nsCSSValue& aValue,
-                                      const ComputeData& aClosure)
+  result_type ComputeLeafValue(const nsCSSValue& aValue)
   {
     NS_ABORT_IF_FALSE(aValue.GetUnit() == eCSSUnit_Number, "unexpected unit");
     return aValue.GetFloatValue();
   }
 
-  static float ComputeNumber(const nsCSSValue& aValue)
+  float ComputeNumber(const nsCSSValue& aValue)
   {
-    return mozilla::css::ComputeCalc<ReduceNumberCalcOps>(
-             aValue, ReduceNumberCalcOps::ComputeData());
+    return mozilla::css::ComputeCalc(aValue, *this);
   }
 };
 
 //  * If aVariantMask is VARIANT_NUMBER, this function parses the
 //    <number-multiplicative-expression> production.
 //  * If aVariantMask does not contain VARIANT_NUMBER, this function
 //    parses the <value-multiplicative-expression> production.
 //  * Otherwise (VARIANT_NUMBER and other bits) this function parses
@@ -7349,32 +7345,32 @@ CSSParserImpl::ParseCalcMultiplicativeEx
                       "ParseCalcTerm did not set variantMask appropriately");
     NS_ABORT_IF_FALSE(!(variantMask & VARIANT_NUMBER) ||
                       !(variantMask & ~PRInt32(VARIANT_NUMBER)),
                       "ParseCalcTerm did not set variantMask appropriately");
 
     if (variantMask & VARIANT_NUMBER) {
       // Simplify the value immediately so we can check for division by
       // zero.
-      float number = mozilla::css::ComputeCalc<ReduceNumberCalcOps>(
-                       *storage, ReduceNumberCalcOps::ComputeData());
+      ReduceNumberCalcOps ops;
+      float number = mozilla::css::ComputeCalc(*storage, ops);
       if (number == 0.0 && afterDivision)
         return PR_FALSE;
       storage->SetFloatValue(number, eCSSUnit_Number);
     } else {
       gotValue = PR_TRUE;
 
       if (storage != &aValue) {
         // Simplify any numbers in the Times_L position (which are
         // not simplified by the check above).
         NS_ABORT_IF_FALSE(storage == &aValue.GetArrayValue()->Item(1),
                           "unexpected relationship to current storage");
         nsCSSValue &leftValue = aValue.GetArrayValue()->Item(0);
-        float number = mozilla::css::ComputeCalc<ReduceNumberCalcOps>(
-                         leftValue, ReduceNumberCalcOps::ComputeData());
+        ReduceNumberCalcOps ops;
+        float number = mozilla::css::ComputeCalc(leftValue, ops);
         leftValue.SetFloatValue(number, eCSSUnit_Number);
       }
     }
 
     PRBool hadWS = RequireWhitespace();
     if (!GetToken(PR_FALSE)) {
       *aHadFinalWS = hadWS;
       break;
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -177,49 +177,44 @@ static nscoord CalcLengthWith(const nsCS
                               nsPresContext* aPresContext,
                               PRBool aUseProvidedRootEmSize,
                               PRBool aUseUserFontSet,
                               PRBool& aCanStoreInRuleTree);
 
 struct CalcLengthCalcOps : public mozilla::css::BasicCoordCalcOps,
                            public mozilla::css::NumbersAlreadyNormalizedOps
 {
-  struct ComputeData {
-    // All of the parameters to CalcLengthWith except aValue.
-    nscoord mFontSize;
-    const nsStyleFont* mStyleFont;
-    nsStyleContext* mStyleContext;
-    nsPresContext* mPresContext;
-    PRBool mUseProvidedRootEmSize;
-    PRBool mUseUserFontSet;
-    PRBool& mCanStoreInRuleTree;
-
-    ComputeData(nscoord aFontSize, const nsStyleFont* aStyleFont,
-                nsStyleContext* aStyleContext, nsPresContext* aPresContext,
-                PRBool aUseProvidedRootEmSize, PRBool aUseUserFontSet,
-                PRBool& aCanStoreInRuleTree)
-      : mFontSize(aFontSize),
-        mStyleFont(aStyleFont),
-        mStyleContext(aStyleContext),
-        mPresContext(aPresContext),
-        mUseProvidedRootEmSize(aUseProvidedRootEmSize),
-        mUseUserFontSet(aUseUserFontSet),
-        mCanStoreInRuleTree(aCanStoreInRuleTree)
-    {
-    }
-  };
-
-  static result_type ComputeLeafValue(const nsCSSValue& aValue,
-                                      const ComputeData& aClosure)
+  // All of the parameters to CalcLengthWith except aValue.
+  const nscoord mFontSize;
+  const nsStyleFont* const mStyleFont;
+  nsStyleContext* const mStyleContext;
+  nsPresContext* const mPresContext;
+  const PRBool mUseProvidedRootEmSize;
+  const PRBool mUseUserFontSet;
+  PRBool& mCanStoreInRuleTree;
+
+  CalcLengthCalcOps(nscoord aFontSize, const nsStyleFont* aStyleFont,
+                    nsStyleContext* aStyleContext, nsPresContext* aPresContext,
+                    PRBool aUseProvidedRootEmSize, PRBool aUseUserFontSet,
+                    PRBool& aCanStoreInRuleTree)
+    : mFontSize(aFontSize),
+      mStyleFont(aStyleFont),
+      mStyleContext(aStyleContext),
+      mPresContext(aPresContext),
+      mUseProvidedRootEmSize(aUseProvidedRootEmSize),
+      mUseUserFontSet(aUseUserFontSet),
+      mCanStoreInRuleTree(aCanStoreInRuleTree)
   {
-    return CalcLengthWith(aValue, aClosure.mFontSize, aClosure.mStyleFont,
-                          aClosure.mStyleContext, aClosure.mPresContext,
-                          aClosure.mUseProvidedRootEmSize,
-                          aClosure.mUseUserFontSet,
-                          aClosure.mCanStoreInRuleTree);
+  }
+
+  result_type ComputeLeafValue(const nsCSSValue& aValue)
+  {
+    return CalcLengthWith(aValue, mFontSize, mStyleFont, mStyleContext,
+                          mPresContext, mUseProvidedRootEmSize,
+                          mUseUserFontSet, mCanStoreInRuleTree);
   }
 };
 
 static inline nscoord ScaleCoord(const nsCSSValue &aValue, float factor)
 {
   return NSToCoordRoundWithClamp(aValue.GetFloatValue() * factor);
 }
 
@@ -324,20 +319,20 @@ static nscoord CalcLengthWith(const nsCS
     case eCSSUnit_Calc:
     case eCSSUnit_Calc_Plus:
     case eCSSUnit_Calc_Minus:
     case eCSSUnit_Calc_Times_L:
     case eCSSUnit_Calc_Times_R:
     case eCSSUnit_Calc_Divided:
     case eCSSUnit_Calc_Minimum:
     case eCSSUnit_Calc_Maximum: {
-      CalcLengthCalcOps::ComputeData
-        data(aFontSize, aStyleFont, aStyleContext, aPresContext,
-             aUseProvidedRootEmSize, aUseUserFontSet, aCanStoreInRuleTree);
-      return mozilla::css::ComputeCalc<CalcLengthCalcOps>(aValue, data);
+      CalcLengthCalcOps ops(aFontSize, aStyleFont, aStyleContext, aPresContext,
+                            aUseProvidedRootEmSize, aUseUserFontSet,
+                            aCanStoreInRuleTree);
+      return mozilla::css::ComputeCalc(aValue, ops);
     }
     default:
       NS_NOTREACHED("unexpected unit");
       break;
   }
   return 0;
 }
 
@@ -2657,60 +2652,57 @@ ComputeScriptLevelSize(const nsStyleFont
     return NS_MIN(scriptLevelSize, NS_MAX(*aUnconstrainedSize, minScriptSize));
   }
 }
 #endif
 
 struct SetFontSizeCalcOps : public mozilla::css::BasicCoordCalcOps,
                             public mozilla::css::NumbersAlreadyNormalizedOps
 {
-  struct ComputeData {
-    // The parameters beyond aValue that we need for CalcLengthWith.
-    nscoord mParentSize;
-    const nsStyleFont* mParentFont;
-    nsPresContext* mPresContext;
-    PRBool mAtRoot;
-    PRBool& mCanStoreInRuleTree;
-
-    ComputeData(nscoord aParentSize, const nsStyleFont* aParentFont,
-                nsPresContext* aPresContext, PRBool aAtRoot,
-                PRBool& aCanStoreInRuleTree)
-      : mParentSize(aParentSize),
-        mParentFont(aParentFont),
-        mPresContext(aPresContext),
-        mAtRoot(aAtRoot),
-        mCanStoreInRuleTree(aCanStoreInRuleTree)
-    {
-    }
-  };
-
-  static result_type ComputeLeafValue(const nsCSSValue& aValue,
-                                      const ComputeData& aClosure)
+  // The parameters beyond aValue that we need for CalcLengthWith.
+  const nscoord mParentSize;
+  const nsStyleFont* const mParentFont;
+  nsPresContext* const mPresContext;
+  const PRBool mAtRoot;
+  PRBool& mCanStoreInRuleTree;
+
+  SetFontSizeCalcOps(nscoord aParentSize, const nsStyleFont* aParentFont,
+                     nsPresContext* aPresContext, PRBool aAtRoot,
+                     PRBool& aCanStoreInRuleTree)
+    : mParentSize(aParentSize),
+      mParentFont(aParentFont),
+      mPresContext(aPresContext),
+      mAtRoot(aAtRoot),
+      mCanStoreInRuleTree(aCanStoreInRuleTree)
+  {
+  }
+
+  result_type ComputeLeafValue(const nsCSSValue& aValue)
   {
     nscoord size;
     if (aValue.IsLengthUnit()) {
       // Note that font-based length units use the parent's size
       // unadjusted for scriptlevel changes. A scriptlevel change
       // between us and the parent is simply ignored.
-      size = CalcLengthWith(aValue, aClosure.mParentSize, aClosure.mParentFont,
-                            nsnull, aClosure.mPresContext, aClosure.mAtRoot,
-                            PR_TRUE, aClosure.mCanStoreInRuleTree);
+      size = CalcLengthWith(aValue, mParentSize, mParentFont,
+                            nsnull, mPresContext, mAtRoot,
+                            PR_TRUE, mCanStoreInRuleTree);
       if (aValue.IsFixedLengthUnit() || aValue.GetUnit() == eCSSUnit_Pixel) {
-        size = nsStyleFont::ZoomText(aClosure.mPresContext, size);
+        size = nsStyleFont::ZoomText(mPresContext, size);
       }
     }
     else if (eCSSUnit_Percent == aValue.GetUnit()) {
-      aClosure.mCanStoreInRuleTree = PR_FALSE;
+      mCanStoreInRuleTree = PR_FALSE;
       // Note that % units use the parent's size unadjusted for scriptlevel
       // changes. A scriptlevel change between us and the parent is simply
       // ignored.
-      size = NSToCoordRound(aClosure.mParentSize * aValue.GetPercentValue());
+      size = NSToCoordRound(mParentSize * aValue.GetPercentValue());
     } else {
       NS_ABORT_IF_FALSE(PR_FALSE, "unexpected value");
-      size = aClosure.mParentSize;
+      size = mParentSize;
     }
 
     return size;
   }
 };
 
 /* static */ void
 nsRuleNode::SetFontSize(nsPresContext* aPresContext,
@@ -2771,21 +2763,19 @@ nsRuleNode::SetFontSize(nsPresContext* a
       }
     } else {
       NS_NOTREACHED("unexpected value");
     }
   }
   else if (aFontData.mSize.IsLengthUnit() ||
            aFontData.mSize.GetUnit() == eCSSUnit_Percent ||
            aFontData.mSize.IsCalcUnit()) {
-    SetFontSizeCalcOps::ComputeData data(aParentSize, aParentFont,
-                                         aPresContext, aAtRoot,
-                                         aCanStoreInRuleTree);
-    *aSize =
-      mozilla::css::ComputeCalc<SetFontSizeCalcOps>(aFontData.mSize, data);
+    SetFontSizeCalcOps ops(aParentSize, aParentFont, aPresContext, aAtRoot,
+                           aCanStoreInRuleTree);
+    *aSize = mozilla::css::ComputeCalc(aFontData.mSize, ops);
     if (*aSize < 0) {
       NS_ABORT_IF_FALSE(aFontData.mSize.IsCalcUnit(),
                         "negative lengths and percents should be rejected "
                         "by parser");
       *aSize = 0;
     }
     // Zoom is handled inside the calc ops when needed.
     zoom = PR_FALSE;
