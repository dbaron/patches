From: L. David Baron <dbaron@dbaron.org>

Add template-based mechanism for computing a calc() tree.

diff --git a/layout/style/CSSCalc.h b/layout/style/CSSCalc.h
new file mode 100644
--- /dev/null
+++ b/layout/style/CSSCalc.h
@@ -0,0 +1,116 @@
+/* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is CSSCalc.h.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef CSSCalc_h_
+#define CSSCalc_h_
+
+#include "nsCSSValue.h"
+
+namespace mozilla {
+
+namespace css {
+
+template <typename T>
+static T
+MergeCalcValues(nsCSSUnit aCalcFunction, T aValue1, T aValue2)
+{
+  switch (aCalcFunction) {
+    case eCSSUnit_Calc_Plus:
+      return aValue1 + aValue2;
+    case eCSSUnit_Calc_Minus:
+      return aValue1 - aValue2;
+    case eCSSUnit_Calc_Times:
+      return aValue1 * aValue2;
+    case eCSSUnit_Calc_Divided:
+      return aValue1 / aValue2;
+    case eCSSUnit_Calc_Modulus:
+      return aValue1 % aValue2;
+    case eCSSUnit_Calc_Minimum:
+      return NS_MIN(aValue1, aValue2);
+    case eCSSUnit_Calc_Maximum:
+      return NS_MAX(aValue1, aValue2);
+    default:
+      NS_ABORT_IF_FALSE(PR_TRUE, "unexpected function");
+      return 0;
+  }
+}
+
+template <class CalcOps>
+static typename CalcOps::result_type
+ComputeCalc(const nsCSSValue& aValue,
+            const typename CalcOps::ComputeData &aClosure)
+{
+  switch (aValue.GetUnit()) {
+    case eCSSUnit_Calc: {
+      nsCSSValue::Array *arr = aValue.GetArrayValue();
+      NS_ABORT_IF_FALSE(arr->Count() == 1, "unexpected length");
+      return ComputeCalc<CalcOps>(arr->Item(0), aClosure);
+    }
+    case eCSSUnit_Calc_Plus:
+    case eCSSUnit_Calc_Minus:
+    case eCSSUnit_Calc_Times:
+    case eCSSUnit_Calc_Divided:
+    case eCSSUnit_Calc_Modulus: {
+      nsCSSValue::Array *arr = aValue.GetArrayValue();
+      NS_ABORT_IF_FALSE(arr->Count() == 2, "unexpected length");
+      typename CalcOps::result_type
+        lhs = ComputeCalc<CalcOps>(arr->Item(0), aClosure),
+        rhs = ComputeCalc<CalcOps>(arr->Item(1), aClosure);
+      return CalcOps::Merge(aValue.GetUnit(), lhs, rhs);
+    }
+    case eCSSUnit_Calc_Minimum:
+    case eCSSUnit_Calc_Maximum: {
+      nsCSSValue::Array *arr = aValue.GetArrayValue();
+      typename CalcOps::result_type result =
+        ComputeCalc<CalcOps>(arr->Item(0), aClosure);
+      for (PRUint32 i = 1, i_end = arr->Count(); i < i_end; ++i) {
+        typename CalcOps::result_type tmp =
+          ComputeCalc<CalcOps>(arr->Item(i), aClosure);
+        result = CalcOps::Merge(aValue.GetUnit(), result, tmp);
+      }
+      return result;
+    }
+    default: {
+      return CalcOps::ComputeLeaf(aValue, aClosure);
+    }
+  }
+}
+
+}
+
+}
+
+#endif /* !defined(CSSCalc_h_) */
