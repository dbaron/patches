From: Zack Weinberg <zweinberg@mozilla.com>, L. David Baron <dbaron@dbaron.org>

Paint different backgrounds behind the reftest test and references to detect areas that are not painted at all.  (Bug 454349)

diff --git a/layout/tools/reftest/reftest.js b/layout/tools/reftest/reftest.js
--- a/layout/tools/reftest/reftest.js
+++ b/layout/tools/reftest/reftest.js
@@ -51,17 +51,17 @@ const NS_REFTESTHELPER_CONTRACTID =
 const NS_REFTESTHELPER_CONTRACTID =
           "@mozilla.org/reftest-helper;1";
 const NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX =
           "@mozilla.org/network/protocol;1?name=";
 
 const LOAD_FAILURE_TIMEOUT = 10000; // ms
 
 var gBrowser;
-var gCanvas1, gCanvas2;
+var gCanvasTest, gCanvasRef;
 var gURLs;
 // Map from URI spec to the number of times it remains to be used
 var gURIUseCounts;
 // Map from URI spec to the canvas rendered for that URI
 var gURICanvases;
 var gTestResults = {
   // Successful...
   Pass: 0,
@@ -279,18 +279,18 @@ function ReadManifest(aURL)
             var prettyPath = runHttp
                            ? gIOService.newURI(items[1], null, listURL).spec
                            : testURI.spec;
             secMan.checkLoadURI(aURL, testURI,
                                 CI.nsIScriptSecurityManager.DISALLOW_SCRIPT);
             gURLs.push( { equal: true /* meaningless */,
                           expected: expected_status,
                           prettyPath: prettyPath,
-                          url1: testURI,
-                          url2: null } );
+                          urltest: testURI,
+                          urlref: null } );
         } else if (items[0] == "==" || items[0] == "!=") {
             if (items.length != 3)
                 throw "Error in manifest file " + aURL.spec + " line " + lineNo;
             var [testURI, refURI] = runHttp
                                   ? ServeFiles(aURL, httpDepth,
                                                listURL.file.parent, [items[1], items[2]])
                                   : [gIOService.newURI(items[1], null, listURL),
                                      gIOService.newURI(items[2], null, listURL)];
@@ -299,45 +299,45 @@ function ReadManifest(aURL)
                            : testURI.spec;
             secMan.checkLoadURI(aURL, testURI,
                                 CI.nsIScriptSecurityManager.DISALLOW_SCRIPT);
             secMan.checkLoadURI(aURL, refURI,
                                 CI.nsIScriptSecurityManager.DISALLOW_SCRIPT);
             gURLs.push( { equal: (items[0] == "=="),
                           expected: expected_status,
                           prettyPath: prettyPath,
-                          url1: testURI,
-                          url2: refURI } );
+                          urltest: testURI,
+                          urlref: refURI } );
         } else {
             throw "Error in manifest file " + aURL.spec + " line " + lineNo;
         }
     } while (more);
 }
 
-function AddURIUseCount(uri)
+function AddURIUseCount(which, uri)
 {
     if (uri == null)
         return;
 
-    var spec = uri.spec;
+    var spec = which + "-" + uri.spec;
     if (spec in gURIUseCounts) {
         gURIUseCounts[spec]++;
     } else {
         gURIUseCounts[spec] = 1;
     }
 }
 
 function BuildUseCounts()
 {
     gURIUseCounts = {};
     for (var i = 0; i < gURLs.length; ++i) {
         var expected = gURLs[i].expected;
         if (expected != EXPECTED_DEATH && expected != EXPECTED_LOAD) {
-            AddURIUseCount(gURLs[i].url1);
-            AddURIUseCount(gURLs[i].url2);
+            AddURIUseCount("test", gURLs[i].urltest);
+            AddURIUseCount("ref", gURLs[i].urlref);
         }
     }
 }
 
 function ServeFiles(manifestURL, depth, directory, files)
 {
     if (!gServer)
         gServer = CC["@mozilla.org/server/jshttp;1"].
@@ -379,41 +379,42 @@ function ServeFiles(manifestURL, depth, 
     return files.map(FileToURI);
 }
 
 function StartCurrentTest()
 {
     // make sure we don't run tests that are expected to kill the browser
     while (gURLs.length > 0 && gURLs[0].expected == EXPECTED_DEATH) {
         ++gTestResults.Skip;
-        dump("REFTEST TEST-KNOWN-FAIL | " + gURLs[0].url1.spec + " | (SKIP)\n");
+        dump("REFTEST TEST-KNOWN-FAIL | " + gURLs[0].urltest.spec + " | (SKIP)\n");
         gURLs.shift();
     }
 
     if (gURLs.length == 0) {
         DoneTests();
     }
     else {
         var currentTest = gTotalTests - gURLs.length;
         document.title = "reftest: " + currentTest + " / " + gTotalTests +
             " (" + Math.floor(100 * (currentTest / gTotalTests)) + "%)";
-        StartCurrentURI(1);
+        StartCurrentURI("test");
     }
 }
 
 function StartCurrentURI(aState)
 {
     gCurrentTestStartTime = Date.now();
     gFailureTimeout = setTimeout(LoadFailed, LOAD_FAILURE_TIMEOUT);
     gFailureReason = "timed out waiting for onload to fire";
 
     gState = aState;
     gCurrentURL = gURLs[0]["url" + aState].spec;
 
-    if (gURICanvases[gCurrentURL] && gURLs[0].expected != EXPECTED_LOAD) {
+    if (gURICanvases[aState + "-" + gCurrentURL] &&
+        gURLs[0].expected != EXPECTED_LOAD) {
         // Pretend the document loaded --- DocumentLoaded will notice
         // there's already a canvas for this URL
         setTimeout(DocumentLoaded, 0);
     } else {
         gBrowser.loadURI(gCurrentURL);
     }
 }
 
@@ -533,19 +534,19 @@ function OnDocumentLoad(event)
         // Since we can't use a bubbling-phase load listener from chrome,
         // this is a capturing phase listener.  So do setTimeout twice, the
         // first to get us after the onload has fired in the content, and
         // the second to get us after any setTimeout(foo, 0) in the content.
         setTimeout(setTimeout, 0, DocumentLoaded, 0);
     }
 }
 
-function UpdateCanvasCache(url, canvas)
+function UpdateCanvasCache(which, url, canvas)
 {
-    var spec = url.spec;
+    var spec = which + "-" + url.spec;
 
     --gURIUseCounts[spec];
     if (gURIUseCounts[spec] == 0) {
         ReleaseCanvas(canvas);
         delete gURICanvases[spec];
     } else if (gURIUseCounts[spec] > 0) {
         gURICanvases[spec] = canvas;
     } else {
@@ -568,70 +569,97 @@ function DocumentLoaded()
     if (gURLs[0].expected == EXPECTED_LOAD) {
         ++gTestResults.LoadOnly;
         dump("REFTEST TEST-PASS | " + gURLs[0].prettyPath + " | (LOAD ONLY)\n");
         gURLs.shift();
         StartCurrentTest();
         return;
     }
 
+    // To catch cases  where page rendering doesn't paint opaque color
+    // over the entire viewport (e.g. bug 453566), we avoid having
+    // drawWindow erase the requested rectangle before rendering.
+    // Instead, we manually erase the canvas to white, then fill the
+    // bounding box reported by the document's root with different
+    // colors for test and reference.
+    //
+    // We can't just fill the canvas with different colors for the
+    // test and reference, because the viewport can be smaller than
+    // the rectangle requested in the drawWindow call; the bounding
+    // box reported by the document root is the closest approximation
+    // to the viewport rectangle that's available in the DOM.
+    //
+    // drawWindow always draws one canvas pixel for each CSS pixel in
+    // the source window, so we scale the drawing to show the zoom
+    // (making each canvas pixel be one device pixel instead)
+
     var canvas;
-    if (gURICanvases[gCurrentURL]) {
-        canvas = gURICanvases[gCurrentURL];
+    var bgcolor;
+    var cachespec = gState + "-" + gCurrentURL;
+    if (gURICanvases[cachespec]) {
+        canvas = gURICanvases[cachespec];
     } else {
         canvas = AllocateCanvas();
+
+        if (gState == "test") {
+            bgcolor = "rgb(255,0,123)";
+        } else {
+            bgcolor = "rgb(255,74,0)";
+        }
 
         /* XXX This needs to be rgb(255,255,255) because otherwise we get
          * black bars at the bottom of every test that are different size
          * for the first test and the rest (scrollbar-related??) */
         var win = gBrowser.contentWindow;
         var ctx = canvas.getContext("2d");
+        var bbox = gBrowser.contentDocument.documentElement.getBoundingClientRect();
         var scale = gBrowser.markupDocumentViewer.fullZoom;
         ctx.save();
-        // drawWindow always draws one canvas pixel for each CSS pixel in the source
-        // window, so scale the drawing to show the zoom (making each canvas pixel be one
-        // device pixel instead)
+        ctx.fillStyle = "white";
+        ctx.fillRect(0, 0, canvas.width, canvas.height);
         ctx.scale(scale, scale);
+        ctx.fillStyle = bgcolor;
+        ctx.fillRect(bbox.top, bbox.left, bbox.width, bbox.height);
         ctx.drawWindow(win, win.scrollX, win.scrollY,
-                       canvas.width, canvas.height, "rgb(255,255,255)");
+                       canvas.width, canvas.height, "rgba(0,0,0,0)");
         ctx.restore();
     }
 
-    if (gState == 1) {
-        gCanvas1 = canvas;
+    if (gState == "test") {
+        gCanvasTest = canvas;
     } else {
-        gCanvas2 = canvas;
+        gCanvasRef = canvas;
     }
 
     resetZoom();
 
     switch (gState) {
-        case 1:
+        case "test":
             // First document has been loaded.
             // Proceed to load the second document.
 
-            StartCurrentURI(2);
+            StartCurrentURI("ref");
             break;
-        case 2:
+        case "ref":
             // Both documents have been loaded. Compare the renderings and see
             // if the comparison result matches the expected result specified
             // in the manifest.
 
             // number of different pixels
             var differences;
             // whether the two renderings match:
             var equal;
 
             if (gWindowUtils) {
-                differences = gWindowUtils.compareCanvases(gCanvas1, gCanvas2, {});
+                differences = gWindowUtils.compareCanvases(gCanvasTest, gCanvasRef, {});
                 equal = (differences == 0);
             } else {
                 differences = -1;
-                var k1 = gCanvas1.toDataURL();
-                var k2 = gCanvas2.toDataURL();
+                var k1 = gCanvasTest.toDataURL();
+                var k2 = gCanvasRef.toDataURL();
                 equal = (k1 == k2);
             }
 
             // whether the comparison result matches what is in the manifest
             var test_passed = (equal == gURLs[0].equal);
             // what is expected on this platform (PASS, FAIL, or RANDOM)
             var expected = gURLs[0].expected;
             
@@ -657,26 +685,26 @@ function DocumentLoaded()
             if (!gURLs[0].equal) {
                 result += "(!=) ";
             }
             dump(result + "\n");
 
             if (!test_passed && expected == EXPECTED_PASS ||
                 test_passed && expected == EXPECTED_FAIL) {
                 if (!equal) {
-                    dump("REFTEST   IMAGE 1 (TEST): " + gCanvas1.toDataURL() + "\n");
-                    dump("REFTEST   IMAGE 2 (REFERENCE): " + gCanvas2.toDataURL() + "\n");
+                    dump("REFTEST   IMAGE 1 (TEST): " + gCanvasTest.toDataURL() + "\n");
+                    dump("REFTEST   IMAGE 2 (REFERENCE): " + gCanvasRef.toDataURL() + "\n");
                     dump("REFTEST number of differing pixels: " + differences + "\n");
                 } else {
-                    dump("REFTEST   IMAGE: " + gCanvas1.toDataURL() + "\n");
+                    dump("REFTEST   IMAGE: " + gCanvasTest.toDataURL() + "\n");
                 }
             }
 
-            UpdateCanvasCache(gURLs[0].url1, gCanvas1);
-            UpdateCanvasCache(gURLs[0].url2, gCanvas2);
+            UpdateCanvasCache("test", gURLs[0].urltest, gCanvasTest);
+            UpdateCanvasCache("ref", gURLs[0].urlref, gCanvasRef);
 
             gURLs.shift();
             StartCurrentTest();
             break;
         default:
             throw "Unexpected state.";
     }
 }
