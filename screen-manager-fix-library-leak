Don't leak the result of PR_LoadLibrary for the xinerama library.  (Bug 403706)  r+sr=roc

diff --git a/widget/src/gtk2/nsScreenManagerGtk.cpp b/widget/src/gtk2/nsScreenManagerGtk.cpp
--- a/widget/src/gtk2/nsScreenManagerGtk.cpp
+++ b/widget/src/gtk2/nsScreenManagerGtk.cpp
@@ -37,58 +37,66 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsScreenManagerGtk.h"
 #include "nsScreenGtk.h"
 #include "nsIComponentManager.h"
 #include "nsRect.h"
 #include "nsAutoPtr.h"
-#include "prlink.h"
 
 #include <gdk/gdkx.h>
+
+#define SCREEN_MANAGER_LIBRARY_LOAD_FAILED ((PRLibrary*)1)
 
 // prototypes from Xinerama.h
 typedef Bool (*_XnrmIsActive_fn)(Display *dpy);
 typedef XineramaScreenInfo* (*_XnrmQueryScreens_fn)(Display *dpy, int *number);
 
 nsScreenManagerGtk :: nsScreenManagerGtk ( )
+  : mXineramalib(nsnull)
 {
   // nothing else to do. I guess we could cache a bunch of information
   // here, but we want to ask the device at runtime in case anything
   // has changed.
 }
 
 
 nsScreenManagerGtk :: ~nsScreenManagerGtk()
 {
-  // nothing to see here.
+  if (mXineramalib && mXineramalib != SCREEN_MANAGER_LIBRARY_LOAD_FAILED) {
+    PR_UnloadLibrary(mXineramalib);
+  }
 }
 
 
 // addref, release, QI
 NS_IMPL_ISUPPORTS1(nsScreenManagerGtk, nsIScreenManager)
 
 
 // this function will make sure that everything has been initialized.
 nsresult
 nsScreenManagerGtk :: EnsureInit(void)
 {
   if (mCachedScreenArray.Count() == 0) {
     XineramaScreenInfo *screenInfo = NULL;
     int numScreens;
 
-    // We are leaking xineramalib, but there is no other way to do this.
-    PRLibrary* xineramalib = PR_LoadLibrary("libXinerama.so.1");
-    if (xineramalib) {
+    if (!mXineramalib) {
+      mXineramalib = PR_LoadLibrary("libXinerama.so.1");
+      if (!mXineramalib) {
+        mXineramalib = SCREEN_MANAGER_LIBRARY_LOAD_FAILED;
+      }
+    }
+    if (mXineramalib && mXineramalib != SCREEN_MANAGER_LIBRARY_LOAD_FAILED) {
       _XnrmIsActive_fn _XnrmIsActive = (_XnrmIsActive_fn)
-          PR_FindFunctionSymbol(xineramalib, "XineramaIsActive");
+          PR_FindFunctionSymbol(mXineramalib, "XineramaIsActive");
 
       _XnrmQueryScreens_fn _XnrmQueryScreens = (_XnrmQueryScreens_fn)
-          PR_FindFunctionSymbol(xineramalib, "XineramaQueryScreens");
+          PR_FindFunctionSymbol(mXineramalib, "XineramaQueryScreens");
           
       // get the number of screens via xinerama
       if (_XnrmIsActive && _XnrmQueryScreens &&
           _XnrmIsActive(GDK_DISPLAY())) {
         screenInfo = _XnrmQueryScreens(GDK_DISPLAY(), &numScreens);
       }
     }
     // screenInfo == NULL if either Xinerama couldn't be loaded or
diff --git a/widget/src/gtk2/nsScreenManagerGtk.h b/widget/src/gtk2/nsScreenManagerGtk.h
--- a/widget/src/gtk2/nsScreenManagerGtk.h
+++ b/widget/src/gtk2/nsScreenManagerGtk.h
@@ -38,16 +38,17 @@
 
 #ifndef nsScreenManagerGtk_h___
 #define nsScreenManagerGtk_h___
 
 #include "nsIScreenManager.h"
 #include "nsIScreen.h"
 #include "nsCOMPtr.h"
 #include "nsCOMArray.h"
+#include "prlink.h"
 
 //------------------------------------------------------------------------
 
 class nsScreenManagerGtk : public nsIScreenManager
 {
 public:
   nsScreenManagerGtk ( );
   virtual ~nsScreenManagerGtk();
@@ -56,11 +57,13 @@ public:
   NS_DECL_NSISCREENMANAGER
 
 private:
 
   nsresult EnsureInit(void);
 
   // Cached screen array.  Its length is the number of screens we have.
   nsCOMArray<nsIScreen> mCachedScreenArray;
+
+  PRLibrary *mXineramalib;
 };
 
 #endif  // nsScreenManagerGtk_h___ 
