From: L. David Baron <dbaron@dbaron.org>

Bug 996796 patch 5 - Move the guts of UpdateThrottledStyle into nsStyleSet, where it can be reused.

diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -239,76 +239,32 @@ CommonAnimationManager::UpdateThrottledS
                  false), "element not animated");
 
   nsIFrame* primaryFrame = nsLayoutUtils::GetStyleFrame(aElement);
   if (!primaryFrame) {
     return nullptr;
   }
 
   nsStyleContext* oldStyle = primaryFrame->StyleContext();
-  nsRuleNode* ruleNode = oldStyle->RuleNode();
-  nsTArray<nsStyleSet::RuleAndLevel> rules;
-  do {
-    if (ruleNode->IsRoot()) {
-      break;
-    }
 
-    nsStyleSet::RuleAndLevel curRule;
-    curRule.mLevel = ruleNode->GetLevel();
-
-    if (curRule.mLevel == nsStyleSet::eAnimationSheet) {
-      CommonElementAnimationData* ea =
-        mPresContext->AnimationManager()->GetElementAnimations(
-          aElement,
-          oldStyle->GetPseudoType(),
-          false);
-      NS_ASSERTION(ea,
-        "Rule has level eAnimationSheet without animation on manager");
-
-      mPresContext->AnimationManager()->UpdateStyleAndEvents(
-        ea, mPresContext->RefreshDriver()->MostRecentRefresh(),
-        EnsureStyleRule_IsNotThrottled);
-      curRule.mRule = ea->mStyleRule;
-    } else if (curRule.mLevel == nsStyleSet::eTransitionSheet) {
-      CommonElementAnimationData* et =
-        mPresContext->TransitionManager()->GetElementTransitions(
-          aElement,
-          oldStyle->GetPseudoType(),
-          false);
-      NS_ASSERTION(et,
-        "Rule has level eTransitionSheet without transition on manager");
-
-      et->EnsureStyleRuleFor(
-        mPresContext->RefreshDriver()->MostRecentRefresh(),
-        EnsureStyleRule_IsNotThrottled);
-      curRule.mRule = et->mStyleRule;
-    } else {
-      curRule.mRule = ruleNode->GetRule();
-    }
-
-    if (curRule.mRule) {
-      rules.AppendElement(curRule);
-    }
-  } while ((ruleNode = ruleNode->GetParent()));
-
-  nsRefPtr<nsStyleContext> newStyle = mPresContext->PresShell()->StyleSet()->
-    ResolveStyleForRules(aParentStyle, oldStyle, rules);
+  nsStyleSet* styleSet = mPresContext->StyleSet();
+  nsRefPtr<nsStyleContext> newStyle =
+    styleSet->ResolveStyleWithReplacement(aElement, aParentStyle, oldStyle);
 
   // We absolutely must call CalcStyleDifference in order to ensure the
   // new context has all the structs cached that the old context had.
   // We also need it for processing of the changes.
   nsChangeHint styleChange =
     oldStyle->CalcStyleDifference(newStyle, nsChangeHint(0));
   aChangeList.AppendChange(primaryFrame, primaryFrame->GetContent(),
                            styleChange);
 
   primaryFrame->SetStyleContext(newStyle);
 
-  ReparentBeforeAndAfter(aElement, primaryFrame, newStyle,
-                         mPresContext->PresShell()->StyleSet());
+  ReparentBeforeAndAfter(aElement, primaryFrame, newStyle, styleSet);
 
   return newStyle;
 }
 
 NS_IMPL_ISUPPORTS(AnimValuesStyleRule, nsIStyleRule)
 
 /* virtual */ void
 AnimValuesStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -31,16 +31,17 @@
 #include "nsStyleSheetService.h"
 #include "mozilla/dom/Element.h"
 #include "GeckoProfiler.h"
 #include "nsHTMLCSSStyleSheet.h"
 #include "nsHTMLStyleSheet.h"
 #include "nsCSSRules.h"
 
 using namespace mozilla;
+using namespace mozilla::css;
 using namespace mozilla::dom;
 
 NS_IMPL_ISUPPORTS(nsEmptyStyleRule, nsIStyleRule)
 
 /* virtual */ void
 nsEmptyStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
 }
@@ -1316,16 +1317,70 @@ nsStyleSet::ResolveStyleByAddingRules(ns
   }
   return GetContext(aBaseContext->GetParent(), ruleNode, visitedRuleNode,
                     aBaseContext->GetPseudo(),
                     aBaseContext->GetPseudoType(),
                     nullptr, flags);
 }
 
 already_AddRefed<nsStyleContext>
+nsStyleSet::ResolveStyleWithReplacement(Element* aElement,
+                                        nsStyleContext* aNewParentContext,
+                                        nsStyleContext* aOldStyleContext)
+{
+  nsRuleNode* ruleNode = aOldStyleContext->RuleNode();
+  nsTArray<nsStyleSet::RuleAndLevel> rules;
+  do {
+    if (ruleNode->IsRoot()) {
+      break;
+    }
+
+    nsStyleSet::RuleAndLevel curRule;
+    curRule.mLevel = ruleNode->GetLevel();
+
+    if (curRule.mLevel == nsStyleSet::eAnimationSheet) {
+      nsAnimationManager* animationManager = PresContext()->AnimationManager();
+      CommonElementAnimationData* ea = animationManager->GetElementAnimations(
+        aElement, aOldStyleContext->GetPseudoType(), false);
+      NS_ASSERTION(ea,
+        "Rule has level eAnimationSheet without animation on manager");
+
+      animationManager->UpdateStyleAndEvents(
+        ea, PresContext()->RefreshDriver()->MostRecentRefresh(),
+        EnsureStyleRule_IsNotThrottled);
+      curRule.mRule = ea->mStyleRule;
+    } else if (curRule.mLevel == nsStyleSet::eTransitionSheet) {
+      nsPresContext* presContext = PresContext();
+      CommonElementAnimationData* et =
+        presContext->TransitionManager()->GetElementTransitions(
+          aElement,
+          aOldStyleContext->GetPseudoType(),
+          false);
+      NS_ASSERTION(et,
+        "Rule has level eTransitionSheet without transition on manager");
+
+      et->EnsureStyleRuleFor(
+        presContext->RefreshDriver()->MostRecentRefresh(),
+        EnsureStyleRule_IsNotThrottled);
+      curRule.mRule = et->mStyleRule;
+    } else {
+      curRule.mRule = ruleNode->GetRule();
+    }
+
+    if (curRule.mRule) {
+      rules.AppendElement(curRule);
+    }
+  } while ((ruleNode = ruleNode->GetParent()));
+
+  // FIXME: Does this handle visited contexts correctly???
+  return ResolveStyleForRules(aNewParentContext, aOldStyleContext, rules);
+}
+
+
+already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForNonElement(nsStyleContext* aParentContext)
 {
   return GetContext(aParentContext, mRuleTree, nullptr,
                     nsCSSAnonBoxes::mozNonElement,
                     nsCSSPseudoElements::ePseudo_AnonBox, nullptr,
                     eNoFlags);
 }
 
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -129,16 +129,23 @@ class nsStyleSet
 
   // Get a style context that represents aBaseContext, but as though
   // it additionally matched the rules in the aRules array (in that
   // order, as more specific than any other rules).
   already_AddRefed<nsStyleContext>
   ResolveStyleByAddingRules(nsStyleContext* aBaseContext,
                             const nsCOMArray<nsIStyleRule> &aRules);
 
+  // Resolve style by replacing the animation and transition rules, but
+  // otherwise maintaining the status quo.
+  already_AddRefed<nsStyleContext>
+  ResolveStyleWithReplacement(mozilla::dom::Element* aElement,
+                              nsStyleContext* aNewParentContext,
+                              nsStyleContext* aOldStyleContext);
+
   // Get a style context for a non-element (which no rules will match),
   // such as text nodes, placeholder frames, and the nsFirstLetterFrame
   // for everything after the first letter.
   //
   // Perhaps this should go away and we shouldn't even create style
   // contexts for such content nodes.  However, not doing any rule
   // matching for them is a first step.
   already_AddRefed<nsStyleContext>
