From: L. David Baron <dbaron@dbaron.org>

Bug 1110277 patch 2 - Make the lifetime of the ReframingStyleContexts object slightly large so it includes the calls to RecreateFramesForContent and MaybeRecreateFramesForElement made from RestyleManager::RestyleElement.

Probably not related.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -955,16 +955,23 @@ RestyleManager::RestyleElement(Element* 
         if (aMinHint == 0) {
           return;
         }
         aPrimaryFrame = aElement->GetPrimaryFrame();
       }
     }
   }
 
+  // Create a ReframingStyleContexts struct on the stack and put it in our
+  // mReframingStyleContexts for the remaining scope of this function.
+  MOZ_ASSERT(!mReframingStyleContexts, "shouldn't call recursively");
+  AutoRestore<ReframingStyleContexts*> ar(mReframingStyleContexts);
+  ReframingStyleContexts reframingStyleContexts;
+  mReframingStyleContexts = &reframingStyleContexts;
+
   if (aMinHint & nsChangeHint_ReconstructFrame) {
     FrameConstructor()->RecreateFramesForContent(aElement, false,
       nsCSSFrameConstructor::REMOVE_FOR_RECONSTRUCTION, nullptr);
   } else if (!(aRestyleHint & ~eRestyle_LaterSiblings)) {
     if (aMinHint &&
         (aPrimaryFrame || (aMinHint & nsChangeHint_ReconstructFrame))) {
       // Don't need to recompute style; just apply the hint
       nsStyleChangeList changeList;
@@ -1577,18 +1584,29 @@ RestyleManager::DoRebuildAllStyleData(Re
   // because we never need to reframe the root frame
   // XXX This could be made faster by not rerunning rule matching
   // (but note that nsPresShell::SetPreferenceStyleRules currently depends
   // on us re-running rule matching here
   // XXX Does it matter that we're passing aExtraHint to the real root
   // frame and not the root node's primary frame?  (We could do
   // roughly what we do for aRestyleHint above.)
   // Note: The restyle tracker we pass in here doesn't matter.
-  ComputeAndProcessStyleChange(mPresContext->PresShell()->GetRootFrame(),
-                               aExtraHint, aRestyleTracker, aRestyleHint);
+
+  {
+    // Create a ReframingStyleContexts struct on the stack and put it in
+    // our mReframingStyleContexts within this scope.
+    MOZ_ASSERT(!mReframingStyleContexts, "shouldn't call recursively");
+    AutoRestore<ReframingStyleContexts*> ar(mReframingStyleContexts);
+    ReframingStyleContexts reframingStyleContexts;
+    mReframingStyleContexts = &reframingStyleContexts;
+
+    ComputeAndProcessStyleChange(mPresContext->PresShell()->GetRootFrame(),
+                                 aExtraHint, aRestyleTracker, aRestyleHint);
+  }
+
   FlushOverflowChangedTracker();
 
   // Tell the style set it's safe to destroy the old rule tree.  We
   // must do this after the ProcessRestyledFrames call in case the
   // change list has frame reconstructs in it (since frames to be
   // reconstructed will still have their old style context pointers
   // until they are destroyed).
   mPresContext->StyleSet()->EndReconstruct();
@@ -3888,43 +3906,29 @@ ElementRestyler::SendAccessibilityNotifi
 }
 
 void
 RestyleManager::ComputeAndProcessStyleChange(nsIFrame*          aFrame,
                                              nsChangeHint       aMinChange,
                                              RestyleTracker&    aRestyleTracker,
                                              nsRestyleHint      aRestyleHint)
 {
-  // Create a ReframingStyleContexts struct on the stack and put it in
-  // our mReframingStyleContexts for the scope of this function.
-  MOZ_ASSERT(!mReframingStyleContexts, "shouldn't call recursively");
-  AutoRestore<ReframingStyleContexts*> ar(mReframingStyleContexts);
-  ReframingStyleContexts reframingStyleContexts;
-  mReframingStyleContexts = &reframingStyleContexts;
-
   nsStyleChangeList changeList;
   ElementRestyler::ComputeStyleChangeFor(aFrame, &changeList, aMinChange,
                                          aRestyleTracker, aRestyleHint);
   ProcessRestyledFrames(changeList);
 }
 
 void
 RestyleManager::ComputeAndProcessStyleChange(nsStyleContext*    aNewContext,
                                              Element*           aElement,
                                              nsChangeHint       aMinChange,
                                              RestyleTracker&    aRestyleTracker,
                                              nsRestyleHint      aRestyleHint)
 {
-  // Create a ReframingStyleContexts struct on the stack and put it in
-  // our mReframingStyleContexts for the scope of this function.
-  MOZ_ASSERT(!mReframingStyleContexts, "shouldn't call recursively");
-  AutoRestore<ReframingStyleContexts*> ar(mReframingStyleContexts);
-  ReframingStyleContexts reframingStyleContexts;
-  mReframingStyleContexts = &reframingStyleContexts;
-
   MOZ_ASSERT(aNewContext->StyleDisplay()->mDisplay == NS_STYLE_DISPLAY_CONTENTS);
   nsIFrame* frame = GetNearestAncestorFrame(aElement);
   MOZ_ASSERT(frame, "display:contents node in map although it's a "
                     "display:none descendant?");
   TreeMatchContext treeMatchContext(true,
                                     nsRuleWalker::eRelevantLinkUnvisited,
                                     frame->PresContext()->Document());
   nsIContent* parent = aElement->GetParent();
