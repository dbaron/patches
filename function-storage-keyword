From: L. David Baron <dbaron@dbaron.org>

Bug 511803:  Convert all eCSSUnit_Function storage to use nsCSSKeyword.  This leads to one behavior change, which is case canonicalization for font-variant-alternates function values.

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -670,17 +670,17 @@ protected:
     mParsingCompoundProperty = aBool;
   }
   bool IsParsingCompoundProperty(void) const {
     return mParsingCompoundProperty;
   }
 
   /* Functions for transform Parsing */
   bool ParseSingleTransform(bool aIsPrefixed, nsCSSValue& aValue, bool& aIs3D);
-  bool ParseFunction(const nsString &aFunction, const int32_t aAllowedTypes[],
+  bool ParseFunction(nsCSSKeyword aFunction, const int32_t aAllowedTypes[],
                      int32_t aVariantMaskAll, uint16_t aMinElems,
                      uint16_t aMaxElems, nsCSSValue &aValue);
   bool ParseFunctionInternals(const int32_t aVariantMask[],
                               int32_t aVariantMaskAll,
                               uint16_t aMinElems,
                               uint16_t aMaxElems,
                               InfallibleTArray<nsCSSValue>& aOutput);
 
@@ -8765,17 +8765,17 @@ CSSParserImpl::ParseSingleAlternate(int3
     return true;
   }
 
   uint16_t maxElems = 1;
   if (keyword == eCSSKeyword_styleset ||
       keyword == eCSSKeyword_character_variant) {
     maxElems = MAX_ALLOWED_FEATURES;
   }
-  return ParseFunction(mToken.mIdent, nullptr, VARIANT_IDENTIFIER,
+  return ParseFunction(keyword, nullptr, VARIANT_IDENTIFIER,
                        1, maxElems, aValue);
 }
 
 bool
 CSSParserImpl::ParseFontVariantAlternates(nsCSSValue& aValue)
 {
   if (ParseVariant(aValue, VARIANT_INHERIT | VARIANT_NORMAL, nullptr)) {
     return true;
@@ -9748,65 +9748,53 @@ CSSParserImpl::ParseFunctionInternals(co
  * @param aAllowedTypesAll If set, every element tested for these types
  * @param aMinElems Minimum number of elements to read.  Reading fewer than
  *        this many elements will result in the function failing.
  * @param aMaxElems Maximum number of elements to read.  Reading more than
  *        this many elements will result in the function failing.
  * @param aValue (out) The value that was parsed.
  */
 bool
-CSSParserImpl::ParseFunction(const nsString &aFunction,
+CSSParserImpl::ParseFunction(nsCSSKeyword aFunction,
                              const int32_t aAllowedTypes[],
                              int32_t aAllowedTypesAll,
                              uint16_t aMinElems, uint16_t aMaxElems,
                              nsCSSValue &aValue)
 {
   NS_ASSERTION((aAllowedTypes && !aAllowedTypesAll) ||
                (!aAllowedTypes && aAllowedTypesAll),
                "only one of the two allowed type parameter can be set");
   typedef InfallibleTArray<nsCSSValue>::size_type arrlen_t;
 
   /* 2^16 - 2, so that if we have 2^16 - 2 transforms, we have 2^16 - 1
    * elements stored in the the nsCSSValue::Array.
    */
   static const arrlen_t MAX_ALLOWED_ELEMS = 0xFFFE;
 
-  /* Make a copy of the function name, since the reference is _probably_ to
-   * mToken.mIdent, which is going to get overwritten during the course of this
-   * function.
-   */
-  nsString functionName(aFunction);
-
   /* Read in a list of values as an array, failing if we can't or if
    * it's out of bounds.
    */
   InfallibleTArray<nsCSSValue> foundValues;
   if (!ParseFunctionInternals(aAllowedTypes, aAllowedTypesAll, aMinElems,
                               aMaxElems, foundValues)) {
     return false;
   }
 
-  /* Now, convert this array into an nsCSSValue::Array object.
-   * We'll need N + 1 spots, one for the function name and the rest for the
-   * arguments.  In case the user has given us more than 2^16 - 2 arguments,
+  /*
+   * In case the user has given us more than 2^16 - 2 arguments,
    * we'll truncate them at 2^16 - 2 arguments.
    */
-  uint16_t numElements = (foundValues.Length() <= MAX_ALLOWED_ELEMS ?
-                          foundValues.Length() + 1 : MAX_ALLOWED_ELEMS);
+  uint16_t numArgs = NS_MIN(foundValues.Length(), MAX_ALLOWED_ELEMS);
   nsRefPtr<nsCSSValue::Array> convertedArray =
-    nsCSSValue::Array::Create(numElements);
+    aValue.InitFunction(aFunction, numArgs);
 
   /* Copy things over. */
-  convertedArray->Item(0).SetStringValue(functionName, eCSSUnit_Ident);
-  for (uint16_t index = 0; index + 1 < numElements; ++index)
+  for (uint16_t index = 0; index < numArgs; ++index)
     convertedArray->Item(index + 1) = foundValues[static_cast<arrlen_t>(index)];
 
-  /* Fill in the outparam value with the array. */
-  aValue.SetArrayValue(convertedArray, eCSSUnit_Function);
-
   /* Return it! */
   return true;
 }
 
 /**
  * Given a token, determines the minimum and maximum number of function
  * parameters to read, along with the mask that should be used to read
  * those function parameters.  If the token isn't a transform function,
@@ -10023,47 +10011,17 @@ CSSParserImpl::ParseSingleTransform(bool
   const int32_t* variantMask;
   uint16_t minElems, maxElems;
   nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(mToken.mIdent);
 
   if (!GetFunctionParseInformation(keyword, aIsPrefixed,
                                    minElems, maxElems, variantMask, aIs3D))
     return false;
 
-  // Bug 721136: Normalize the identifier to lowercase, except that things
-  // like scaleX should have the last character capitalized.  This matches
-  // what other browsers do.
-  nsContentUtils::ASCIIToLower(mToken.mIdent);
-  switch (keyword) {
-    case eCSSKeyword_rotatex:
-    case eCSSKeyword_scalex:
-    case eCSSKeyword_skewx:
-    case eCSSKeyword_translatex:
-      mToken.mIdent.Replace(mToken.mIdent.Length() - 1, 1, PRUnichar('X'));
-      break;
-
-    case eCSSKeyword_rotatey:
-    case eCSSKeyword_scaley:
-    case eCSSKeyword_skewy:
-    case eCSSKeyword_translatey:
-      mToken.mIdent.Replace(mToken.mIdent.Length() - 1, 1, PRUnichar('Y'));
-      break;
-
-    case eCSSKeyword_rotatez:
-    case eCSSKeyword_scalez:
-    case eCSSKeyword_translatez:
-      mToken.mIdent.Replace(mToken.mIdent.Length() - 1, 1, PRUnichar('Z'));
-      break;
-
-    default:
-      break;
-  }
-
-  return ParseFunction(mToken.mIdent, variantMask, 0, minElems,
-                       maxElems, aValue);
+  return ParseFunction(keyword, variantMask, 0, minElems, maxElems, aValue);
 }
 
 /* Parses a transform property list by continuously reading in properties
  * and constructing a matrix from it.
  */
 bool CSSParserImpl::ParseTransform(bool aIsPrefixed)
 {
   nsCSSValue value;
diff --git a/layout/style/nsCSSValue.cpp b/layout/style/nsCSSValue.cpp
--- a/layout/style/nsCSSValue.cpp
+++ b/layout/style/nsCSSValue.cpp
@@ -610,18 +610,17 @@ nsCSSValue::EqualsFunction(nsCSSKeyword 
     return false;
   }
 
   nsCSSValue::Array* func = mValue.mArray;
   NS_ABORT_IF_FALSE(func && func->Count() >= 1 &&
                     func->Item(0).GetUnit() == eCSSUnit_Enumerated,
                     "illegally structured function value");
 
-  nsCSSKeyword thisFunctionId =
-    static_cast<nsCSSKeyword>(func->Item(0).GetIntValue());
+  nsCSSKeyword thisFunctionId = func->Item(0).GetKeywordValue();
   return thisFunctionId == aFunctionId;
 }
 
 // static
 already_AddRefed<nsStringBuffer>
 nsCSSValue::BufferFromString(const nsString& aValue)
 {
   nsRefPtr<nsStringBuffer> buffer = nsStringBuffer::FromString(aValue);
@@ -770,23 +769,48 @@ nsCSSValue::AppendToString(nsCSSProperty
     const nsCSSValue::Array* array = GetArrayValue();
     NS_ABORT_IF_FALSE(array->Count() >= 1,
                       "Functions must have at least one element for the name.");
 
     /* Append the function name. */
     const nsCSSValue& functionName = array->Item(0);
     if (functionName.GetUnit() == eCSSUnit_Enumerated) {
       // We assume that the first argument is always of nsCSSKeyword type.
-      const nsCSSKeyword functionId =
-        static_cast<nsCSSKeyword>(functionName.GetIntValue());
-      nsStyleUtil::AppendEscapedCSSIdent(
-        NS_ConvertASCIItoUTF16(nsCSSKeywords::GetStringValue(functionId)),
-        aResult);
+      const nsCSSKeyword functionId = functionName.GetKeywordValue();
+      NS_ConvertASCIItoUTF16 ident(nsCSSKeywords::GetStringValue(functionId));
+      // Bug 721136: Normalize the identifier to lowercase, except that things
+      // like scaleX should have the last character capitalized.  This matches
+      // what other browsers do.
+      switch (functionId) {
+        case eCSSKeyword_rotatex:
+        case eCSSKeyword_scalex:
+        case eCSSKeyword_skewx:
+        case eCSSKeyword_translatex:
+          ident.Replace(ident.Length() - 1, 1, PRUnichar('X'));
+          break;
+
+        case eCSSKeyword_rotatey:
+        case eCSSKeyword_scaley:
+        case eCSSKeyword_skewy:
+        case eCSSKeyword_translatey:
+          ident.Replace(ident.Length() - 1, 1, PRUnichar('Y'));
+          break;
+
+        case eCSSKeyword_rotatez:
+        case eCSSKeyword_scalez:
+        case eCSSKeyword_translatez:
+          ident.Replace(ident.Length() - 1, 1, PRUnichar('Z'));
+          break;
+
+        default:
+          break;
+      }
+      nsStyleUtil::AppendEscapedCSSIdent(ident, aResult);
     } else {
-      functionName.AppendToString(aProperty, aResult);
+      MOZ_ASSERT(false, "should no longer have non-enumerated functions");
     }
     aResult.AppendLiteral("(");
 
     /* Now, step through the function contents, writing each of them as we go. */
     for (size_t index = 1; index < array->Count(); ++index) {
       array->Item(index).AppendToString(aProperty, aResult);
 
       /* If we're not at the final element, append a comma. */
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -159,16 +159,17 @@ enum nsCSSUnit {
 
   eCSSUnit_Array        = 20,     // (nsCSSValue::Array*) a list of values
   eCSSUnit_Counter      = 21,     // (nsCSSValue::Array*) a counter(string,[string]) value
   eCSSUnit_Counters     = 22,     // (nsCSSValue::Array*) a counters(string,string[,string]) value
   eCSSUnit_Cubic_Bezier = 23,     // (nsCSSValue::Array*) a list of float values
   eCSSUnit_Steps        = 24,     // (nsCSSValue::Array*) a list of (integer, enumerated)
   eCSSUnit_Function     = 25,     // (nsCSSValue::Array*) a function with
                                   //  parameters.  First elem of array is name,
+                                  //  an nsCSSKeyword as eCSSUnit_Enumerated,
                                   //  the rest of the values are arguments.
 
   // The top level of a calc() expression is eCSSUnit_Calc.  All
   // remaining eCSSUnit_Calc_* units only occur inside these toplevel
   // calc values.
 
   // eCSSUnit_Calc has an array with exactly 1 element.  eCSSUnit_Calc
   // exists so we can distinguish calc(2em) from 2em as specified values
@@ -341,16 +342,22 @@ public:
   {
     NS_ABORT_IF_FALSE(mUnit == eCSSUnit_Integer ||
                       mUnit == eCSSUnit_Enumerated ||
                       mUnit == eCSSUnit_EnumColor,
                       "not an int value");
     return mValue.mInt;
   }
 
+  nsCSSKeyword GetKeywordValue() const
+  {
+    NS_ABORT_IF_FALSE(mUnit == eCSSUnit_Enumerated, "not a keyword value");
+    return static_cast<nsCSSKeyword>(mValue.mInt);
+  }
+
   float GetPercentValue() const
   {
     NS_ABORT_IF_FALSE(mUnit == eCSSUnit_Percent, "not a percent value");
     return mValue.mFloat;
   }
 
   float GetFloatValue() const
   {
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -145,19 +145,17 @@ AppendFunction(nsCSSKeyword aTransformFu
     case eCSSKeyword_rotatey:
     case eCSSKeyword_rotatez:
     case eCSSKeyword_perspective:
       nargs = 1;
       break;
   }
 
   nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(nargs + 1);
-  arr->Item(0).SetStringValue(
-    NS_ConvertUTF8toUTF16(nsCSSKeywords::GetStringValue(aTransformFunction)),
-    eCSSUnit_Ident);
+  arr->Item(0).SetIntValue(aTransformFunction, eCSSUnit_Enumerated);
 
   return arr.forget();
 }
 
 static already_AddRefed<nsCSSValue::Array>
 ToPrimitive(nsCSSValue::Array* aArray)
 {
   nsCSSKeyword tfunc = nsStyleTransformMatrix::TransformFunctionOf(aArray);
diff --git a/layout/style/nsStyleTransformMatrix.cpp b/layout/style/nsStyleTransformMatrix.cpp
--- a/layout/style/nsStyleTransformMatrix.cpp
+++ b/layout/style/nsStyleTransformMatrix.cpp
@@ -592,19 +592,18 @@ MatrixForTransformFunction(gfx3DMatrix& 
 
 /**
  * Return the transform function, as an nsCSSKeyword, for the given
  * nsCSSValue::Array from a transform list.
  */
 nsCSSKeyword
 TransformFunctionOf(const nsCSSValue::Array* aData)
 {
-  nsAutoString keyword;
-  aData->Item(0).GetStringValue(keyword);
-  return nsCSSKeywords::LookupKeyword(keyword);
+  MOZ_ASSERT(aData->Item(0).GetUnit() == eCSSUnit_Enumerated);
+  return aData->Item(0).GetKeywordValue();
 }
 
 gfx3DMatrix
 ReadTransforms(const nsCSSValueList* aList,
                nsStyleContext* aContext,
                nsPresContext* aPresContext,
                bool &aCanStoreInRuleTree,
                nsRect& aBounds,
diff --git a/layout/style/nsStyleUtil.cpp b/layout/style/nsStyleUtil.cpp
--- a/layout/style/nsStyleUtil.cpp
+++ b/layout/style/nsStyleUtil.cpp
@@ -346,19 +346,17 @@ nsStyleUtil::ComputeFunctionalAlternates
     if (curr->mValue.GetUnit() != eCSSUnit_Function) {
       continue;
     }
 
     // element 0 is the propval in ident form
     const nsCSSValue::Array *func = curr->mValue.GetArrayValue();
 
     // lookup propval
-    nsAutoString keywordStr;
-    func->Item(0).GetStringValue(keywordStr);
-    nsCSSKeyword key = nsCSSKeywords::LookupKeyword(keywordStr);
+    nsCSSKeyword key = func->Item(0).GetKeywordValue();
     NS_ASSERTION(key != eCSSKeyword_UNKNOWN, "unknown alternate property value");
 
     int32_t alternate;
     if (key == eCSSKeyword_UNKNOWN ||
         !nsCSSProps::FindKeyword(key,
                                  nsCSSProps::kFontVariantAlternatesFuncsKTable,
                                  alternate)) {
       NS_NOTREACHED("keyword not a font-variant-alternates value");
