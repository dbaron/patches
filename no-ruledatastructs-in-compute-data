From: L. David Baron <dbaron@dbaron.org>

Convert nsRuleNode::Compute*Data to property getters instead of accessing struct members.  (Bug 636039, patch 11)

diff --git a/layout/style/nsRuleData.h b/layout/style/nsRuleData.h
--- a/layout/style/nsRuleData.h
+++ b/layout/style/nsRuleData.h
@@ -107,16 +107,20 @@ struct nsRuleData
    * Return a pointer to the value object within |this| corresponding
    * to property |aProperty|.
    *
    * This function must only be called if the given property is in
    * mSIDs.
    */
   nsCSSValue* ValueFor(nsCSSProperty aProperty);
 
+  const nsCSSValue* ValueFor(nsCSSProperty aProperty) const {
+    return const_cast<nsRuleData*>(this)->ValueFor(aProperty);
+  }
+
   /**
    * Getters like ValueFor(aProperty), but for each property by name
    * (ValueForBackgroundColor, etc.), and more efficient than ValueFor.
    * These use the names used for the property on DOM interfaces (the
    * 'method' field in nsCSSPropList.h).
    *
    * Like ValueFor(), the caller must check that the property is within
    * mSIDs.
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -2108,17 +2108,17 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
       // come from the pres context.
       return SetDefaultOnRoot(aSID, aContext);
   }
 
   // We need to compute the data from the information that the rules specified.
   const void* res;
 #define STYLE_STRUCT_TEST aSID
 #define STYLE_STRUCT(name, checkdata_cb, ctor_args)                           \
-  res = Compute##name##Data(startStruct, *aSpecificData, aContext,            \
+  res = Compute##name##Data(startStruct, aRuleData, aContext,                 \
                       highestNode, detail, aRuleData->mCanStoreInRuleTree);
 #include "nsStyleStructList.h"
 #undef STYLE_STRUCT
 #undef STYLE_STRUCT_TEST
 
   // If we have a post-resolve callback, handle that now.
   if (aRuleData->mPostResolveCallback && (NS_LIKELY(res != nsnull)))
     (*aRuleData->mPostResolveCallback)(const_cast<void*>(res), aRuleData);
@@ -2410,18 +2410,16 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
  * @param rdata_ Variable (declared here) holding the nsCSS* used here.
  */
 #define COMPUTE_START_INHERITED(type_, ctorargs_, data_, parentdata_, rdtype_, rdata_) \
   NS_ASSERTION(aRuleDetail != eRuleFullInherited,                             \
                "should not have bothered calling Compute*Data");              \
                                                                               \
   nsStyleContext* parentContext = aContext->GetParent();                      \
                                                                               \
-  const nsRuleData##rdtype_& rdata_ =                                         \
-    static_cast<const nsRuleData##rdtype_&>(aData);                           \
   nsStyle##type_* data_ = nsnull;                                             \
   const nsStyle##type_* parentdata_ = nsnull;                                 \
   PRBool canStoreInRuleTree = aCanStoreInRuleTree;                            \
                                                                               \
   /* If |canStoreInRuleTree| might be true by the time we're done, we */      \
   /* can't call parentContext->GetStyle##type_() since it could recur into */ \
   /* setting the same struct on the same rule node, causing a leak. */        \
   if (parentContext && aRuleDetail != eRuleFullReset &&                       \
@@ -2471,18 +2469,16 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
   nsStyleContext* parentContext = aContext->GetParent();                      \
   /* Reset structs don't inherit from first-line */                           \
   /* See similar code in WalkRuleTree */                                      \
   while (parentContext &&                                                     \
          parentContext->GetPseudo() == nsCSSPseudoElements::firstLine) {      \
     parentContext = parentContext->GetParent();                               \
   }                                                                           \
                                                                               \
-  const nsRuleData##rdtype_& rdata_ =                                         \
-    static_cast<const nsRuleData##rdtype_&>(aData);                           \
   nsStyle##type_* data_;                                                      \
   if (aStartStruct)                                                           \
     /* We only need to compute the delta between this computed data and */    \
     /* our computed data. */                                                  \
     data_ = new (mPresContext)                                                \
             nsStyle##type_(*static_cast<nsStyle##type_*>(aStartStruct));      \
   else                                                                        \
     data_ = new (mPresContext) nsStyle##type_ ctorargs_;                      \
@@ -2684,32 +2680,33 @@ struct SetFontSizeCalcOps : public css::
     }
 
     return size;
   }
 };
 
 /* static */ void
 nsRuleNode::SetFontSize(nsPresContext* aPresContext,
-                        const nsRuleDataFont& aFontData,
+                        const nsRuleData* aRuleData,
                         const nsStyleFont* aFont,
                         const nsStyleFont* aParentFont,
                         nscoord* aSize,
                         const nsFont& aSystemFont,
                         nscoord aParentSize,
                         nscoord aScriptLevelAdjustedParentSize,
                         PRBool aUsedStartStruct,
                         PRBool aAtRoot,
                         PRBool& aCanStoreInRuleTree)
 {
   PRBool zoom = PR_FALSE;
   PRInt32 baseSize = (PRInt32) aPresContext->
     GetDefaultFont(aFont->mGenericID)->size;
-  if (eCSSUnit_Enumerated == aFontData.mSize.GetUnit()) {
-    PRInt32 value = aFontData.mSize.GetIntValue();
+  const nsCSSValue* sizeValue = aRuleData->ValueForFontSize();
+  if (eCSSUnit_Enumerated == sizeValue->GetUnit()) {
+    PRInt32 value = sizeValue->GetIntValue();
     PRInt32 scaler = aPresContext->FontScaler();
     float scaleFactor = nsStyleUtil::GetScalingFactor(scaler);
 
     zoom = PR_TRUE;
     if ((NS_STYLE_FONT_SIZE_XXSMALL <= value) &&
         (value <= NS_STYLE_FONT_SIZE_XXLARGE)) {
       *aSize = nsStyleUtil::CalcFontPointSize(value, baseSize,
                        scaleFactor, aPresContext, eFontSize_CSS);
@@ -2743,51 +2740,51 @@ nsRuleNode::SetFontSize(nsPresContext* a
         NS_ASSERTION(*aSize < parentSize ||
                      parentSize <= nsPresContext::CSSPixelsToAppUnits(1),
                      "FindNextSmallerFontSize failed");
       }
     } else {
       NS_NOTREACHED("unexpected value");
     }
   }
-  else if (aFontData.mSize.IsLengthUnit() ||
-           aFontData.mSize.GetUnit() == eCSSUnit_Percent ||
-           aFontData.mSize.IsCalcUnit()) {
+  else if (sizeValue->IsLengthUnit() ||
+           sizeValue->GetUnit() == eCSSUnit_Percent ||
+           sizeValue->IsCalcUnit()) {
     SetFontSizeCalcOps ops(aParentSize, aParentFont, aPresContext, aAtRoot,
                            aCanStoreInRuleTree);
-    *aSize = css::ComputeCalc(aFontData.mSize, ops);
+    *aSize = css::ComputeCalc(*sizeValue, ops);
     if (*aSize < 0) {
-      NS_ABORT_IF_FALSE(aFontData.mSize.IsCalcUnit(),
+      NS_ABORT_IF_FALSE(sizeValue->IsCalcUnit(),
                         "negative lengths and percents should be rejected "
                         "by parser");
       *aSize = 0;
     }
     // Zoom is handled inside the calc ops when needed.
     zoom = PR_FALSE;
   }
-  else if (eCSSUnit_System_Font == aFontData.mSize.GetUnit()) {
+  else if (eCSSUnit_System_Font == sizeValue->GetUnit()) {
     // this becomes our cascading size
     *aSize = aSystemFont.size;
     zoom = PR_TRUE;
   }
-  else if (eCSSUnit_Inherit == aFontData.mSize.GetUnit()) {
+  else if (eCSSUnit_Inherit == sizeValue->GetUnit()) {
     aCanStoreInRuleTree = PR_FALSE;
     // We apply scriptlevel change for this case, because the default is
     // to inherit and we don't want explicit "inherit" to differ from the
     // default.
     *aSize = aScriptLevelAdjustedParentSize;
     zoom = PR_FALSE;
   }
-  else if (eCSSUnit_Initial == aFontData.mSize.GetUnit()) {
+  else if (eCSSUnit_Initial == sizeValue->GetUnit()) {
     // The initial value is 'medium', which has magical sizing based on
     // the generic font family, so do that here too.
     *aSize = baseSize;
     zoom = PR_TRUE;
   } else {
-    NS_ASSERTION(eCSSUnit_Null == aFontData.mSize.GetUnit(),
+    NS_ASSERTION(eCSSUnit_Null == sizeValue->GetUnit(),
                  "What kind of font-size value is this?");
 #ifdef MOZ_MATHML
     // if aUsedStartStruct is true, then every single property in the
     // font struct is being set all at once. This means scriptlevel is not
     // going to have any influence on the font size; there is no need to
     // do anything here.
     if (!aUsedStartStruct && aParentSize != aScriptLevelAdjustedParentSize) {
       // There was no rule affecting the size but the size has been
@@ -2812,30 +2809,31 @@ static PRInt8 ClampTo8Bit(PRInt32 aValue
   if (aValue > 127)
     return 127;
   return PRInt8(aValue);
 }
 
 /* static */ void
 nsRuleNode::SetFont(nsPresContext* aPresContext, nsStyleContext* aContext,
                     nscoord aMinFontSize,
-                    PRUint8 aGenericFontID, const nsRuleDataFont& aFontData,
+                    PRUint8 aGenericFontID, const nsRuleData* aRuleData,
                     const nsStyleFont* aParentFont,
                     nsStyleFont* aFont, PRBool aUsedStartStruct,
                     PRBool& aCanStoreInRuleTree)
 {
   const nsFont* defaultVariableFont =
     aPresContext->GetDefaultFont(kPresContext_DefaultVariableFont_ID);
   PRBool atRoot = !aContext->GetParent();
 
   // -moz-system-font: enum (never inherit!)
   nsFont systemFont;
-  if (eCSSUnit_Enumerated == aFontData.mSystemFont.GetUnit()) {
+  const nsCSSValue* systemFontValue = aRuleData->ValueForSystemFont();
+  if (eCSSUnit_Enumerated == systemFontValue->GetUnit()) {
     nsSystemFontID sysID;
-    switch (aFontData.mSystemFont.GetIntValue()) {
+    switch (systemFontValue->GetIntValue()) {
       case NS_STYLE_FONT_CAPTION:       sysID = eSystemFont_Caption;      break;    // css2
       case NS_STYLE_FONT_ICON:          sysID = eSystemFont_Icon;         break;
       case NS_STYLE_FONT_MENU:          sysID = eSystemFont_Menu;         break;
       case NS_STYLE_FONT_MESSAGE_BOX:   sysID = eSystemFont_MessageBox;   break;
       case NS_STYLE_FONT_SMALL_CAPTION: sysID = eSystemFont_SmallCaption; break;
       case NS_STYLE_FONT_STATUS_BAR:    sysID = eSystemFont_StatusBar;    break;
       case NS_STYLE_FONT_WINDOW:        sysID = eSystemFont_Window;       break;    // css3
       case NS_STYLE_FONT_DOCUMENT:      sysID = eSystemFont_Document;     break;
@@ -2887,77 +2885,81 @@ nsRuleNode::SetFont(nsPresContext* aPres
 #endif
   } else {
     // In case somebody explicitly used -moz-use-system-font.
     systemFont = *defaultVariableFont;
   }
 
 
   // font-family: string list, enum, inherit
-  NS_ASSERTION(eCSSUnit_Enumerated != aFontData.mFamily.GetUnit(),
+  const nsCSSValue* familyValue = aRuleData->ValueForFontFamily();
+  NS_ASSERTION(eCSSUnit_Enumerated != familyValue->GetUnit(),
                "system fonts should not be in mFamily anymore");
-  if (eCSSUnit_Families == aFontData.mFamily.GetUnit()) {
+  if (eCSSUnit_Families == familyValue->GetUnit()) {
     // set the correct font if we are using DocumentFonts OR we are overriding for XUL
     // MJA: bug 31816
     if (aGenericFontID == kGenericFont_NONE) {
       // only bother appending fallback fonts if this isn't a fallback generic font itself
       if (!aFont->mFont.name.IsEmpty())
         aFont->mFont.name.Append((PRUnichar)',');
       // defaultVariableFont.name should always be "serif" or "sans-serif".
       aFont->mFont.name.Append(defaultVariableFont->name);
     }
     aFont->mFont.systemFont = PR_FALSE;
     // Technically this is redundant with the code below, but it's good
     // to have since we'll still want it once we get rid of
     // SetGenericFont (bug 380915).
     aFont->mGenericID = aGenericFontID;
   }
-  else if (eCSSUnit_System_Font == aFontData.mFamily.GetUnit()) {
+  else if (eCSSUnit_System_Font == familyValue->GetUnit()) {
     aFont->mFont.name = systemFont.name;
     aFont->mFont.systemFont = PR_TRUE;
     aFont->mGenericID = kGenericFont_NONE;
   }
-  else if (eCSSUnit_Inherit == aFontData.mFamily.GetUnit()) {
+  else if (eCSSUnit_Inherit == familyValue->GetUnit()) {
     aCanStoreInRuleTree = PR_FALSE;
     aFont->mFont.name = aParentFont->mFont.name;
     aFont->mFont.systemFont = aParentFont->mFont.systemFont;
     aFont->mGenericID = aParentFont->mGenericID;
   }
-  else if (eCSSUnit_Initial == aFontData.mFamily.GetUnit()) {
+  else if (eCSSUnit_Initial == familyValue->GetUnit()) {
     aFont->mFont.name = defaultVariableFont->name;
     aFont->mFont.systemFont = defaultVariableFont->systemFont;
     aFont->mGenericID = kGenericFont_NONE;
   }
 
   // When we're in the loop in SetGenericFont, we must ensure that we
   // always keep aFont->mFlags set to the correct generic.  But we have
   // to be careful not to touch it when we're called directly from
   // ComputeFontData, because we could have a start struct.
   if (aGenericFontID != kGenericFont_NONE) {
     aFont->mGenericID = aGenericFontID;
   }
 
   // font-style: enum, inherit, initial, -moz-system-font
-  SetDiscrete(aFontData.mStyle, aFont->mFont.style, aCanStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForFontStyle(),
+              aFont->mFont.style, aCanStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_SYSTEM_FONT,
               aParentFont->mFont.style,
               defaultVariableFont->style,
               0, 0, 0, systemFont.style);
 
   // font-variant: enum, inherit, initial, -moz-system-font
-  SetDiscrete(aFontData.mVariant, aFont->mFont.variant, aCanStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForFontVariant(),
+              aFont->mFont.variant, aCanStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_SYSTEM_FONT,
               aParentFont->mFont.variant,
               defaultVariableFont->variant,
               0, 0, 0, systemFont.variant);
 
   // font-weight: int, enum, inherit, initial, -moz-system-font
   // special handling for enum
-  if (eCSSUnit_Enumerated == aFontData.mWeight.GetUnit()) {
-    PRInt32 value = aFontData.mWeight.GetIntValue();
+  const nsCSSValue* weightValue = aRuleData->ValueForFontWeight();
+  if (eCSSUnit_Enumerated == weightValue->GetUnit()) {
+    PRInt32 value = weightValue->GetIntValue();
     switch (value) {
       case NS_STYLE_FONT_WEIGHT_NORMAL:
       case NS_STYLE_FONT_WEIGHT_BOLD:
         aFont->mFont.weight = value;
         break;
       case NS_STYLE_FONT_WEIGHT_BOLDER: {
         aCanStoreInRuleTree = PR_FALSE;
         PRInt32 inheritedValue = aParentFont->mFont.weight;
@@ -2979,118 +2981,126 @@ nsRuleNode::SetFont(nsPresContext* aPres
           aFont->mFont.weight = 400;
         } else {
           aFont->mFont.weight = 700;
         }
         break;
       }
     }
   } else
-    SetDiscrete(aFontData.mWeight, aFont->mFont.weight, aCanStoreInRuleTree,
+    SetDiscrete(*weightValue, aFont->mFont.weight, aCanStoreInRuleTree,
                 SETDSC_INTEGER | SETDSC_SYSTEM_FONT,
                 aParentFont->mFont.weight,
                 defaultVariableFont->weight,
                 0, 0, 0, systemFont.weight);
 
   // font-stretch: enum, inherit, initial, -moz-system-font
-  SetDiscrete(aFontData.mStretch, aFont->mFont.stretch, aCanStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForFontStretch(),
+              aFont->mFont.stretch, aCanStoreInRuleTree,
               SETDSC_SYSTEM_FONT | SETDSC_ENUMERATED,
               aParentFont->mFont.stretch,
               defaultVariableFont->stretch,
               0, 0, 0, systemFont.stretch);
 
 #ifdef MOZ_MATHML
   // Compute scriptlevel, scriptminsize and scriptsizemultiplier now so
   // they're available for font-size computation.
 
   // -moz-script-min-size: length
-  if (aFontData.mScriptMinSize.IsLengthUnit()) {
+  const nsCSSValue* scriptMinSizeValue = aRuleData->ValueForScriptMinSize();
+  if (scriptMinSizeValue->IsLengthUnit()) {
     // scriptminsize in font units (em, ex) has to be interpreted relative
     // to the parent font, or the size definitions are circular and we
     //
     aFont->mScriptMinSize =
-      CalcLengthWith(aFontData.mScriptMinSize, aParentFont->mSize, aParentFont,
+      CalcLengthWith(*scriptMinSizeValue, aParentFont->mSize, aParentFont,
                      nsnull, aPresContext, atRoot, PR_TRUE,
                      aCanStoreInRuleTree);
   }
 
   // -moz-script-size-multiplier: factor, inherit, initial
-  SetFactor(aFontData.mScriptSizeMultiplier, aFont->mScriptSizeMultiplier,
+  SetFactor(*aRuleData->ValueForScriptSizeMultiplier(),
+            aFont->mScriptSizeMultiplier,
             aCanStoreInRuleTree, aParentFont->mScriptSizeMultiplier,
             NS_MATHML_DEFAULT_SCRIPT_SIZE_MULTIPLIER,
             SETFCT_POSITIVE);
 
   // -moz-script-level: integer, number, inherit
-  if (eCSSUnit_Integer == aFontData.mScriptLevel.GetUnit()) {
+  const nsCSSValue* scriptLevelValue = aRuleData->ValueForScriptLevel();
+  if (eCSSUnit_Integer == scriptLevelValue->GetUnit()) {
     // "relative"
-    aFont->mScriptLevel = ClampTo8Bit(aParentFont->mScriptLevel + aFontData.mScriptLevel.GetIntValue());
-  }
-  else if (eCSSUnit_Number == aFontData.mScriptLevel.GetUnit()) {
+    aFont->mScriptLevel = ClampTo8Bit(aParentFont->mScriptLevel + scriptLevelValue->GetIntValue());
+  }
+  else if (eCSSUnit_Number == scriptLevelValue->GetUnit()) {
     // "absolute"
-    aFont->mScriptLevel = ClampTo8Bit(PRInt32(aFontData.mScriptLevel.GetFloatValue()));
-  }
-  else if (eCSSUnit_Inherit == aFontData.mScriptLevel.GetUnit()) {
+    aFont->mScriptLevel = ClampTo8Bit(PRInt32(scriptLevelValue->GetFloatValue()));
+  }
+  else if (eCSSUnit_Inherit == scriptLevelValue->GetUnit()) {
     aCanStoreInRuleTree = PR_FALSE;
     aFont->mScriptLevel = aParentFont->mScriptLevel;
   }
-  else if (eCSSUnit_Initial == aFontData.mScriptLevel.GetUnit()) {
+  else if (eCSSUnit_Initial == scriptLevelValue->GetUnit()) {
     aFont->mScriptLevel = 0;
   }
 #endif
 
   // font-feature-settings
-  if (eCSSUnit_Inherit == aFontData.mFontFeatureSettings.GetUnit()) {
+  const nsCSSValue* featureSettingsValue =
+    aRuleData->ValueForFontFeatureSettings();
+  if (eCSSUnit_Inherit == featureSettingsValue->GetUnit()) {
     aCanStoreInRuleTree = PR_FALSE;
     aFont->mFont.featureSettings = aParentFont->mFont.featureSettings;
-  } else if (eCSSUnit_Normal == aFontData.mFontFeatureSettings.GetUnit() ||
-             eCSSUnit_Initial == aFontData.mFontFeatureSettings.GetUnit()) {
+  } else if (eCSSUnit_Normal == featureSettingsValue->GetUnit() ||
+             eCSSUnit_Initial == featureSettingsValue->GetUnit()) {
     aFont->mFont.featureSettings.Truncate();
-  } else if (eCSSUnit_System_Font == aFontData.mFontFeatureSettings.GetUnit()) {
+  } else if (eCSSUnit_System_Font == featureSettingsValue->GetUnit()) {
     aFont->mFont.featureSettings = systemFont.featureSettings;
-  } else if (eCSSUnit_String == aFontData.mFontFeatureSettings.GetUnit()) {
-    aFontData.mFontFeatureSettings.GetStringValue(aFont->mFont.featureSettings);
+  } else if (eCSSUnit_String == featureSettingsValue->GetUnit()) {
+    featureSettingsValue->GetStringValue(aFont->mFont.featureSettings);
   }
 
   // font-language-override
-  if (eCSSUnit_Inherit == aFontData.mFontLanguageOverride.GetUnit()) {
+  const nsCSSValue* languageOverrideValue =
+    aRuleData->ValueForFontLanguageOverride();
+  if (eCSSUnit_Inherit == languageOverrideValue->GetUnit()) {
     aCanStoreInRuleTree = PR_FALSE;
     aFont->mFont.languageOverride = aParentFont->mFont.languageOverride;
-  } else if (eCSSUnit_Normal == aFontData.mFontLanguageOverride.GetUnit() ||
-             eCSSUnit_Initial == aFontData.mFontLanguageOverride.GetUnit()) {
+  } else if (eCSSUnit_Normal == languageOverrideValue->GetUnit() ||
+             eCSSUnit_Initial == languageOverrideValue->GetUnit()) {
     aFont->mFont.languageOverride.Truncate();
-  } else if (eCSSUnit_System_Font == aFontData.mFontLanguageOverride.GetUnit()) {
+  } else if (eCSSUnit_System_Font == languageOverrideValue->GetUnit()) {
     aFont->mFont.languageOverride = systemFont.languageOverride;
-  } else if (eCSSUnit_String == aFontData.mFontLanguageOverride.GetUnit()) {
-    aFontData.mFontLanguageOverride.GetStringValue(aFont->mFont.languageOverride);
+  } else if (eCSSUnit_String == languageOverrideValue->GetUnit()) {
+    languageOverrideValue->GetStringValue(aFont->mFont.languageOverride);
   }
 
   // font-size: enum, length, percent, inherit
   nscoord scriptLevelAdjustedParentSize = aParentFont->mSize;
 #ifdef MOZ_MATHML
   nscoord scriptLevelAdjustedUnconstrainedParentSize;
   scriptLevelAdjustedParentSize =
     ComputeScriptLevelSize(aFont, aParentFont, aPresContext,
                            &scriptLevelAdjustedUnconstrainedParentSize);
   NS_ASSERTION(!aUsedStartStruct || aFont->mScriptUnconstrainedSize == aFont->mSize,
                "If we have a start struct, we should have reset everything coming in here");
 #endif
-  SetFontSize(aPresContext, aFontData, aFont, aParentFont, &aFont->mSize,
+  SetFontSize(aPresContext, aRuleData, aFont, aParentFont, &aFont->mSize,
               systemFont, aParentFont->mSize, scriptLevelAdjustedParentSize,
               aUsedStartStruct, atRoot, aCanStoreInRuleTree);
 #ifdef MOZ_MATHML
   if (aParentFont->mSize == aParentFont->mScriptUnconstrainedSize &&
       scriptLevelAdjustedParentSize == scriptLevelAdjustedUnconstrainedParentSize) {
     // Fast path: we have not been affected by scriptminsize so we don't
     // need to call SetFontSize again to compute the
     // scriptminsize-unconstrained size. This is OK even if we have a
     // start struct, because if we have a start struct then 'font-size'
     // was specified and so scriptminsize has no effect.
     aFont->mScriptUnconstrainedSize = aFont->mSize;
   } else {
-    SetFontSize(aPresContext, aFontData, aFont, aParentFont,
+    SetFontSize(aPresContext, aRuleData, aFont, aParentFont,
                 &aFont->mScriptUnconstrainedSize, systemFont,
                 aParentFont->mScriptUnconstrainedSize,
                 scriptLevelAdjustedUnconstrainedParentSize,
                 aUsedStartStruct, atRoot, aCanStoreInRuleTree);
   }
   NS_ASSERTION(aFont->mScriptUnconstrainedSize <= aFont->mSize,
                "scriptminsize should never be making things bigger");
 #endif
@@ -3098,20 +3108,21 @@ nsRuleNode::SetFont(nsPresContext* aPres
   // enforce the user' specified minimum font-size on the value that we expose
   // (but don't change font-size:0)
   if (0 < aFont->mSize && aFont->mSize < aMinFontSize)
     aFont->mFont.size = aMinFontSize;
   else
     aFont->mFont.size = aFont->mSize;
 
   // font-size-adjust: number, none, inherit, initial, -moz-system-font
-  if (eCSSUnit_System_Font == aFontData.mSizeAdjust.GetUnit()) {
+  const nsCSSValue* sizeAdjustValue = aRuleData->ValueForFontSizeAdjust();
+  if (eCSSUnit_System_Font == sizeAdjustValue->GetUnit()) {
     aFont->mFont.sizeAdjust = systemFont.sizeAdjust;
   } else
-    SetFactor(aFontData.mSizeAdjust, aFont->mFont.sizeAdjust,
+    SetFactor(*sizeAdjustValue, aFont->mFont.sizeAdjust,
               aCanStoreInRuleTree, aParentFont->mFont.sizeAdjust, 0.0f,
               SETFCT_NONE);
 }
 
 // SetGenericFont:
 //  - backtrack to an ancestor with the same generic font name (possibly
 //    up to the root where default values come from the presentation context)
 //  - re-apply cascading rules from there without caching intermediate values
@@ -3174,20 +3185,20 @@ nsRuleNode::SetGenericFont(nsPresContext
       }
     }
 
     // Compute the delta from the information that the rules specified
 
     // Avoid unnecessary operations in SetFont().  But we care if it's
     // the final value that we're computing.
     if (i != 0)
-      fontData.mFamily.Reset();
+      ruleData.ValueForFontFamily()->Reset();
 
     nsRuleNode::SetFont(aPresContext, context, aMinFontSize,
-                        aGenericFontID, fontData, &parentFont, aFont,
+                        aGenericFontID, &ruleData, &parentFont, aFont,
                         PR_FALSE, dummy);
 
     // XXX Not sure if we need to do this here
     // If we have a post-resolve callback, handle that now.
     if (ruleData.mPostResolveCallback)
       (ruleData.mPostResolveCallback)(aFont, &ruleData);
 
     parentFont = *aFont;
@@ -3203,17 +3214,17 @@ static PRBool ExtractGeneric(const nsStr
     *data = aFamily;
     return PR_FALSE; // stop enumeration
   }
   return PR_TRUE;
 }
 
 const void*
 nsRuleNode::ComputeFontData(void* aStartStruct,
-                            const nsRuleDataStruct& aData,
+                            const nsRuleData* aRuleData,
                             nsStyleContext* aContext,
                             nsRuleNode* aHighestNode,
                             const RuleDetail aRuleDetail,
                             const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Font, (mPresContext), font, parentFont,
                           Font, fontData)
 
@@ -3248,18 +3259,19 @@ nsRuleNode::ComputeFontData(void* aStart
     useDocumentFonts = PR_TRUE;
     minimumFontSize = 0;
   }
 
   // Figure out if we are a generic font
   PRUint8 generic = kGenericFont_NONE;
   // XXXldb What if we would have had a string if we hadn't been doing
   // the optimization with a non-null aStartStruct?
-  if (eCSSUnit_Families == fontData.mFamily.GetUnit()) {
-    fontData.mFamily.GetStringValue(font->mFont.name);
+  const nsCSSValue* familyValue = aRuleData->ValueForFontFamily();
+  if (eCSSUnit_Families == familyValue->GetUnit()) {
+    familyValue->GetStringValue(font->mFont.name);
     // XXXldb Do we want to extract the generic for this if it's not only a
     // generic?
     nsFont::GetGenericID(font->mFont.name, &generic);
 
     // If we aren't allowed to use document fonts, then we are only entitled
     // to use the user's default variable-width font and fixed-width font
     if (!useDocumentFonts) {
       // Extract the generic from the specified font family...
@@ -3282,17 +3294,17 @@ nsRuleNode::ComputeFontData(void* aStart
       }
     }
   }
 
   // Now compute our font struct
   if (generic == kGenericFont_NONE) {
     // continue the normal processing
     nsRuleNode::SetFont(mPresContext, aContext, minimumFontSize, generic,
-                        fontData, parentFont, font,
+                        aRuleData, parentFont, font,
                         aStartStruct != nsnull, canStoreInRuleTree);
   }
   else {
     // re-calculate the font as a generic font
     canStoreInRuleTree = PR_FALSE;
     nsRuleNode::SetGenericFont(mPresContext, aContext, generic,
                                minimumFontSize, font);
   }
@@ -3390,70 +3402,74 @@ nsRuleNode::GetShadowData(const nsCSSVal
   }
 
   NS_ADDREF(shadowList);
   return shadowList;
 }
 
 const void*
 nsRuleNode::ComputeTextData(void* aStartStruct,
-                            const nsRuleDataStruct& aData,
+                            const nsRuleData* aRuleData,
                             nsStyleContext* aContext,
                             nsRuleNode* aHighestNode,
                             const RuleDetail aRuleDetail,
                             const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Text, (), text, parentText, Text, textData)
 
   // tab-size: integer, inherit
-  SetDiscrete(textData.mTabSize, text->mTabSize, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForTabSize(),
+              text->mTabSize, canStoreInRuleTree,
               SETDSC_INTEGER, parentText->mTabSize,
               NS_STYLE_TABSIZE_INITIAL, 0, 0, 0, 0);
 
   // letter-spacing: normal, length, inherit
-  SetCoord(textData.mLetterSpacing, text->mLetterSpacing, parentText->mLetterSpacing,
+  SetCoord(*aRuleData->ValueForLetterSpacing(),
+           text->mLetterSpacing, parentText->mLetterSpacing,
            SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL |
              SETCOORD_CALC_LENGTH_ONLY,
            aContext, mPresContext, canStoreInRuleTree);
 
   // text-shadow: none, list, inherit, initial
-  if (textData.mTextShadow.GetUnit() != eCSSUnit_Null) {
+  const nsCSSValue* textShadowValue = aRuleData->ValueForTextShadow();
+  if (textShadowValue->GetUnit() != eCSSUnit_Null) {
     text->mTextShadow = nsnull;
 
     // Don't need to handle none/initial explicitly: The above assignment
     // takes care of that
-    if (textData.mTextShadow.GetUnit() == eCSSUnit_Inherit) {
+    if (textShadowValue->GetUnit() == eCSSUnit_Inherit) {
       canStoreInRuleTree = PR_FALSE;
       text->mTextShadow = parentText->mTextShadow;
-    } else if (textData.mTextShadow.GetUnit() == eCSSUnit_List ||
-               textData.mTextShadow.GetUnit() == eCSSUnit_ListDep) {
+    } else if (textShadowValue->GetUnit() == eCSSUnit_List ||
+               textShadowValue->GetUnit() == eCSSUnit_ListDep) {
       // List of arrays
-      text->mTextShadow = GetShadowData(textData.mTextShadow.GetListValue(),
+      text->mTextShadow = GetShadowData(textShadowValue->GetListValue(),
                                         aContext, PR_FALSE, canStoreInRuleTree);
     }
   }
 
   // line-height: normal, number, length, percent, inherit
-  if (eCSSUnit_Percent == textData.mLineHeight.GetUnit()) {
+  const nsCSSValue* lineHeightValue = aRuleData->ValueForLineHeight();
+  if (eCSSUnit_Percent == lineHeightValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     // Use |mFont.size| to pick up minimum font size.
     text->mLineHeight.SetCoordValue(
         nscoord(float(aContext->GetStyleFont()->mFont.size) *
-                textData.mLineHeight.GetPercentValue()));
-  }
-  else if (eCSSUnit_Initial == textData.mLineHeight.GetUnit() ||
-           eCSSUnit_System_Font == textData.mLineHeight.GetUnit()) {
+                lineHeightValue->GetPercentValue()));
+  }
+  else if (eCSSUnit_Initial == lineHeightValue->GetUnit() ||
+           eCSSUnit_System_Font == lineHeightValue->GetUnit()) {
     text->mLineHeight.SetNormalValue();
   }
   else {
-    SetCoord(textData.mLineHeight, text->mLineHeight, parentText->mLineHeight,
+    SetCoord(*lineHeightValue, text->mLineHeight, parentText->mLineHeight,
              SETCOORD_LEH | SETCOORD_FACTOR | SETCOORD_NORMAL,
              aContext, mPresContext, canStoreInRuleTree);
-    if (textData.mLineHeight.IsLengthUnit() &&
-        !textData.mLineHeight.IsRelativeLengthUnit()) {
+    if (lineHeightValue->IsLengthUnit() &&
+        !lineHeightValue->IsRelativeLengthUnit()) {
       nscoord lh = nsStyleFont::ZoomText(mPresContext,
                                          text->mLineHeight.GetCoordValue());
       nscoord minimumFontSize =
         mPresContext->GetCachedIntPref(kPresContext_MinimumFontSize);
 
       if (minimumFontSize > 0 && !mPresContext->IsChrome()) {
         // If we applied a minimum font size, scale the line height by
         // the same ratio.  (If we *might* have applied a minimum font
@@ -3467,137 +3483,142 @@ nsRuleNode::ComputeTextData(void* aStart
         }
       }
       text->mLineHeight.SetCoordValue(lh);
     }
   }
 
 
   // text-align: enum, string, inherit, initial
-  if (eCSSUnit_String == textData.mTextAlign.GetUnit()) {
+  const nsCSSValue* textAlignValue = aRuleData->ValueForTextAlign();
+  if (eCSSUnit_String == textAlignValue->GetUnit()) {
     NS_NOTYETIMPLEMENTED("align string");
-  } else if (eCSSUnit_Enumerated == textData.mTextAlign.GetUnit() &&
+  } else if (eCSSUnit_Enumerated == textAlignValue->GetUnit() &&
              NS_STYLE_TEXT_ALIGN_MOZ_CENTER_OR_INHERIT ==
-               textData.mTextAlign.GetIntValue()) {
+               textAlignValue->GetIntValue()) {
     canStoreInRuleTree = PR_FALSE;
     PRUint8 parentAlign = parentText->mTextAlign;
     text->mTextAlign = (NS_STYLE_TEXT_ALIGN_DEFAULT == parentAlign) ?
       NS_STYLE_TEXT_ALIGN_CENTER : parentAlign;
   } else
-    SetDiscrete(textData.mTextAlign, text->mTextAlign, canStoreInRuleTree,
+    SetDiscrete(*textAlignValue, text->mTextAlign, canStoreInRuleTree,
                 SETDSC_ENUMERATED, parentText->mTextAlign,
                 NS_STYLE_TEXT_ALIGN_DEFAULT,
                 0, 0, 0, 0);
 
   // text-indent: length, percent, calc, inherit, initial
-  SetCoord(textData.mTextIndent, text->mTextIndent, parentText->mTextIndent,
+  SetCoord(*aRuleData->ValueForTextIndent(), text->mTextIndent, parentText->mTextIndent,
            SETCOORD_LPH | SETCOORD_INITIAL_ZERO | SETCOORD_STORE_CALC,
            aContext, mPresContext, canStoreInRuleTree);
 
   // text-transform: enum, inherit, initial
-  SetDiscrete(textData.mTextTransform, text->mTextTransform, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForTextTransform(), text->mTextTransform, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentText->mTextTransform,
               NS_STYLE_TEXT_TRANSFORM_NONE, 0, 0, 0, 0);
 
   // white-space: enum, inherit, initial
-  SetDiscrete(textData.mWhiteSpace, text->mWhiteSpace, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForWhiteSpace(), text->mWhiteSpace, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentText->mWhiteSpace,
               NS_STYLE_WHITESPACE_NORMAL, 0, 0, 0, 0);
 
   // word-spacing: normal, length, inherit
   nsStyleCoord tempCoord;
-  if (SetCoord(textData.mWordSpacing, tempCoord,
+  const nsCSSValue* wordSpacingValue = aRuleData->ValueForWordSpacing();
+  if (SetCoord(*wordSpacingValue, tempCoord,
                nsStyleCoord(parentText->mWordSpacing,
                             nsStyleCoord::CoordConstructor),
                SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL |
                  SETCOORD_CALC_LENGTH_ONLY,
                aContext, mPresContext, canStoreInRuleTree)) {
     if (tempCoord.GetUnit() == eStyleUnit_Coord) {
       text->mWordSpacing = tempCoord.GetCoordValue();
     } else if (tempCoord.GetUnit() == eStyleUnit_Normal) {
       text->mWordSpacing = 0;
     } else {
       NS_NOTREACHED("unexpected unit");
     }
   } else {
-    NS_ASSERTION(textData.mWordSpacing.GetUnit() == eCSSUnit_Null,
+    NS_ASSERTION(wordSpacingValue->GetUnit() == eCSSUnit_Null,
                  "unexpected unit");
   }
 
   // word-wrap: enum, inherit, initial
-  SetDiscrete(textData.mWordWrap, text->mWordWrap, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForWordWrap(), text->mWordWrap, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentText->mWordWrap,
               NS_STYLE_WORDWRAP_NORMAL, 0, 0, 0, 0);
 
   COMPUTE_END_INHERITED(Text, text)
 }
 
 const void*
 nsRuleNode::ComputeTextResetData(void* aStartStruct,
-                                 const nsRuleDataStruct& aData,
+                                 const nsRuleData* aRuleData,
                                  nsStyleContext* aContext,
                                  nsRuleNode* aHighestNode,
                                  const RuleDetail aRuleDetail,
                                  const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(TextReset, (), text, parentText, Text, textData)
 
   // vertical-align: enum, length, percent, calc, inherit
-  if (!SetCoord(textData.mVerticalAlign, text->mVerticalAlign,
+  const nsCSSValue* verticalAlignValue = aRuleData->ValueForVerticalAlign();
+  if (!SetCoord(*verticalAlignValue, text->mVerticalAlign,
                 parentText->mVerticalAlign,
                 SETCOORD_LPH | SETCOORD_ENUMERATED | SETCOORD_STORE_CALC,
                 aContext, mPresContext, canStoreInRuleTree)) {
-    if (eCSSUnit_Initial == textData.mVerticalAlign.GetUnit()) {
+    if (eCSSUnit_Initial == verticalAlignValue->GetUnit()) {
       text->mVerticalAlign.SetIntValue(NS_STYLE_VERTICAL_ALIGN_BASELINE,
                                        eStyleUnit_Enumerated);
     }
   }
 
   // text-decoration: enum (bit field), inherit, initial
-  if (eCSSUnit_Enumerated == textData.mDecoration.GetUnit()) {
-    PRInt32 td = textData.mDecoration.GetIntValue();
+  const nsCSSValue* decorationValue = aRuleData->ValueForTextDecoration();
+  if (eCSSUnit_Enumerated == decorationValue->GetUnit()) {
+    PRInt32 td = decorationValue->GetIntValue();
     text->mTextDecoration = td;
     if (td & NS_STYLE_TEXT_DECORATION_PREF_ANCHORS) {
       PRBool underlineLinks =
         mPresContext->GetCachedBoolPref(kPresContext_UnderlineLinks);
       if (underlineLinks) {
         text->mTextDecoration |= NS_STYLE_TEXT_DECORATION_UNDERLINE;
       }
       else {
         text->mTextDecoration &= ~NS_STYLE_TEXT_DECORATION_UNDERLINE;
       }
     }
-  } else if (eCSSUnit_Inherit == textData.mDecoration.GetUnit()) {
+  } else if (eCSSUnit_Inherit == decorationValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     text->mTextDecoration = parentText->mTextDecoration;
-  } else if (eCSSUnit_Initial == textData.mDecoration.GetUnit()) {
+  } else if (eCSSUnit_Initial == decorationValue->GetUnit()) {
     text->mTextDecoration = NS_STYLE_TEXT_DECORATION_NONE;
   }
 
   // unicode-bidi: enum, inherit, initial
-  SetDiscrete(textData.mUnicodeBidi, text->mUnicodeBidi, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForUnicodeBidi(), text->mUnicodeBidi, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentText->mUnicodeBidi,
               NS_STYLE_UNICODE_BIDI_NORMAL, 0, 0, 0, 0);
 
   COMPUTE_END_RESET(TextReset, text)
 }
 
 const void*
 nsRuleNode::ComputeUserInterfaceData(void* aStartStruct,
-                                     const nsRuleDataStruct& aData,
+                                     const nsRuleData* aRuleData,
                                      nsStyleContext* aContext,
                                      nsRuleNode* aHighestNode,
                                      const RuleDetail aRuleDetail,
                                      const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(UserInterface, (), ui, parentUI,
                           UserInterface, uiData)
 
   // cursor: enum, url, inherit
-  nsCSSUnit cursorUnit = uiData.mCursor.GetUnit();
+  const nsCSSValue* cursorValue = aRuleData->ValueForCursor();
+  nsCSSUnit cursorUnit = cursorValue->GetUnit();
   if (cursorUnit != eCSSUnit_Null) {
     delete [] ui->mCursorArray;
     ui->mCursorArray = nsnull;
     ui->mCursorArrayLength = 0;
 
     if (cursorUnit == eCSSUnit_Inherit) {
       canStoreInRuleTree = PR_FALSE;
       ui->mCursor = parentUI->mCursor;
@@ -3608,17 +3629,17 @@ nsRuleNode::ComputeUserInterfaceData(voi
     }
     else {
       // The parser will never create a list that is *all* URL values --
       // that's invalid.
       NS_ABORT_IF_FALSE(cursorUnit == eCSSUnit_List ||
                         cursorUnit == eCSSUnit_ListDep,
                         nsPrintfCString(64, "unrecognized cursor unit %d",
                                         cursorUnit).get());
-      const nsCSSValueList* list = uiData.mCursor.GetListValue();
+      const nsCSSValueList* list = cursorValue->GetListValue();
       const nsCSSValueList* list2 = list;
       PRUint32 arrayLength = 0;
       for ( ; list->mValue.GetUnit() == eCSSUnit_Array; list = list->mNext)
         if (list->mValue.GetArrayValue()->Item(0).GetImageValue())
           ++arrayLength;
 
       if (arrayLength != 0) {
         ui->mCursorArray = new nsCursorImage[arrayLength];
@@ -3646,101 +3667,107 @@ nsRuleNode::ComputeUserInterfaceData(voi
       NS_ASSERTION(list, "Must have non-array value at the end");
       NS_ASSERTION(list->mValue.GetUnit() == eCSSUnit_Enumerated,
                    "Unexpected fallback value at end of cursor list");
       ui->mCursor = list->mValue.GetIntValue();
     }
   }
 
   // user-input: enum, inherit, initial
-  SetDiscrete(uiData.mUserInput, ui->mUserInput, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForUserInput(),
+              ui->mUserInput, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentUI->mUserInput,
               NS_STYLE_USER_INPUT_AUTO, 0, 0, 0, 0);
 
   // user-modify: enum, inherit, initial
-  SetDiscrete(uiData.mUserModify, ui->mUserModify, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForUserModify(),
+              ui->mUserModify, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentUI->mUserModify,
               NS_STYLE_USER_MODIFY_READ_ONLY,
               0, 0, 0, 0);
 
   // user-focus: enum, inherit, initial
-  SetDiscrete(uiData.mUserFocus, ui->mUserFocus, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForUserFocus(),
+              ui->mUserFocus, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentUI->mUserFocus,
               NS_STYLE_USER_FOCUS_NONE, 0, 0, 0, 0);
 
   COMPUTE_END_INHERITED(UserInterface, ui)
 }
 
 const void*
 nsRuleNode::ComputeUIResetData(void* aStartStruct,
-                               const nsRuleDataStruct& aData,
+                               const nsRuleData* aRuleData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(UIReset, (), ui, parentUI, UserInterface, uiData)
 
   // user-select: enum, inherit, initial
-  SetDiscrete(uiData.mUserSelect, ui->mUserSelect, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForUserSelect(),
+              ui->mUserSelect, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentUI->mUserSelect,
               NS_STYLE_USER_SELECT_AUTO, 0, 0, 0, 0);
 
   // ime-mode: enum, inherit, initial
-  SetDiscrete(uiData.mIMEMode, ui->mIMEMode, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForImeMode(),
+              ui->mIMEMode, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentUI->mIMEMode,
               NS_STYLE_IME_MODE_AUTO, 0, 0, 0, 0);
 
   // force-broken-image-icons: integer, inherit, initial
-  SetDiscrete(uiData.mForceBrokenImageIcon, ui->mForceBrokenImageIcon,
+  SetDiscrete(*aRuleData->ValueForForceBrokenImageIcon(),
+              ui->mForceBrokenImageIcon,
               canStoreInRuleTree,
               SETDSC_INTEGER,
               parentUI->mForceBrokenImageIcon,
               0, 0, 0, 0, 0);
 
   // -moz-window-shadow: enum, inherit, initial
-  SetDiscrete(uiData.mWindowShadow, ui->mWindowShadow, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForWindowShadow(),
+              ui->mWindowShadow, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentUI->mWindowShadow,
               NS_STYLE_WINDOW_SHADOW_DEFAULT, 0, 0, 0, 0);
 
   COMPUTE_END_RESET(UIReset, ui)
 }
 
 // Information about each transition property that is constant.
 struct TransitionPropInfo {
-  // Location of the property's specified value.
-  nsCSSValue nsRuleDataDisplay::* rdList;
+  nsCSSProperty property;
   // Location of the count of the property's computed value.
   PRUint32 nsStyleDisplay::* sdCount;
 };
 
 // Each property's index in this array must match its index in the
 // mutable array |transitionPropData| below.
 static const TransitionPropInfo transitionPropInfo[4] = {
-  { &nsRuleDataDisplay::mTransitionDelay,
+  { eCSSProperty_transition_delay,
     &nsStyleDisplay::mTransitionDelayCount },
-  { &nsRuleDataDisplay::mTransitionDuration,
+  { eCSSProperty_transition_duration,
     &nsStyleDisplay::mTransitionDurationCount },
-  { &nsRuleDataDisplay::mTransitionProperty,
+  { eCSSProperty_transition_property,
     &nsStyleDisplay::mTransitionPropertyCount },
-  { &nsRuleDataDisplay::mTransitionTimingFunction,
+  { eCSSProperty_transition_timing_function,
     &nsStyleDisplay::mTransitionTimingFunctionCount },
 };
 
 // Information about each transition property that changes during
 // ComputeDisplayData.
 struct TransitionPropData {
   const nsCSSValueList *list;
   nsCSSUnit unit;
   PRUint32 num;
 };
 
 const void*
 nsRuleNode::ComputeDisplayData(void* aStartStruct,
-                               const nsRuleDataStruct& aData,
+                               const nsRuleData* aRuleData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Display, (), display, parentDisplay,
                       Display, displayData)
 
@@ -3788,17 +3815,17 @@ nsRuleNode::ComputeDisplayData(void* aSt
   PRUint32 numTransitions = 0;
   FOR_ALL_TRANSITION_PROPS(p) {
     const TransitionPropInfo& i = transitionPropInfo[p];
     TransitionPropData& d = transitionPropData[p];
 
     // cache whether any of the properties are specified as 'inherit' so
     // we can use it below
 
-    const nsCSSValue& value = displayData.*(i.rdList);
+    const nsCSSValue& value = *aRuleData->ValueFor(i.property);
     d.unit = value.GetUnit();
     d.list = (value.GetUnit() == eCSSUnit_List ||
               value.GetUnit() == eCSSUnit_ListDep)
       ? value.GetListValue() : nsnull;
     d.num = 0;
 
     // General algorithm to determine how many total transitions we need
     // to build.  For each property:
@@ -3970,109 +3997,116 @@ nsRuleNode::ComputeDisplayData(void* aSt
     FOR_ALL_TRANSITION_PROPS(p) {
       const TransitionPropInfo& info = transitionPropInfo[p];
       TransitionPropData& d = transitionPropData[p];
 
       // if we're at the end of the list, start at the beginning and repeat
       // until we're out of transitions to populate
       if (d.list) {
         d.list = d.list->mNext ? d.list->mNext :
-          (displayData.*(info.rdList)).GetListValue();
+          aRuleData->ValueFor(info.property)->GetListValue();
       }
     }
   }
 
   // opacity: factor, inherit, initial
-  SetFactor(displayData.mOpacity, display->mOpacity, canStoreInRuleTree,
+  SetFactor(*aRuleData->ValueForOpacity(), display->mOpacity, canStoreInRuleTree,
             parentDisplay->mOpacity, 1.0f, SETFCT_OPACITY);
 
   // display: enum, inherit, initial
-  SetDiscrete(displayData.mDisplay, display->mDisplay, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForDisplay(), display->mDisplay, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentDisplay->mDisplay,
               NS_STYLE_DISPLAY_INLINE, 0, 0, 0, 0);
 
   // appearance: enum, inherit, initial
-  SetDiscrete(displayData.mAppearance, display->mAppearance, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForAppearance(),
+              display->mAppearance, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentDisplay->mAppearance,
               NS_THEME_NONE, 0, 0, 0, 0);
 
   // binding: url, none, inherit
-  if (eCSSUnit_URL == displayData.mBinding.GetUnit()) {
-    nsCSSValue::URL* url = displayData.mBinding.GetURLStructValue();
+  const nsCSSValue* bindingValue = aRuleData->ValueForBinding();
+  if (eCSSUnit_URL == bindingValue->GetUnit()) {
+    nsCSSValue::URL* url = bindingValue->GetURLStructValue();
     NS_ASSERTION(url, "What's going on here?");
 
     if (NS_LIKELY(url->mURI)) {
       display->mBinding = url;
     } else {
       display->mBinding = nsnull;
     }
   }
-  else if (eCSSUnit_None == displayData.mBinding.GetUnit() ||
-           eCSSUnit_Initial == displayData.mBinding.GetUnit()) {
+  else if (eCSSUnit_None == bindingValue->GetUnit() ||
+           eCSSUnit_Initial == bindingValue->GetUnit()) {
     display->mBinding = nsnull;
   }
-  else if (eCSSUnit_Inherit == displayData.mBinding.GetUnit()) {
+  else if (eCSSUnit_Inherit == bindingValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     display->mBinding = parentDisplay->mBinding;
   }
 
   // position: enum, inherit, initial
-  SetDiscrete(displayData.mPosition, display->mPosition, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForPosition(), display->mPosition, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentDisplay->mPosition,
               NS_STYLE_POSITION_STATIC, 0, 0, 0, 0);
 
   // clear: enum, inherit, initial
-  SetDiscrete(displayData.mClear, display->mBreakType, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForClear(), display->mBreakType, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentDisplay->mBreakType,
               NS_STYLE_CLEAR_NONE, 0, 0, 0, 0);
 
   // temp fix for bug 24000
   // Map 'auto' and 'avoid' to PR_FALSE, and 'always', 'left', and
   // 'right' to PR_TRUE.
   // "A conforming user agent may interpret the values 'left' and
   // 'right' as 'always'." - CSS2.1, section 13.3.1
-  if (eCSSUnit_Enumerated == displayData.mBreakBefore.GetUnit()) {
+  const nsCSSValue* breakBeforeValue = aRuleData->ValueForPageBreakBefore();
+  if (eCSSUnit_Enumerated == breakBeforeValue->GetUnit()) {
     display->mBreakBefore =
-      (NS_STYLE_PAGE_BREAK_AVOID != displayData.mBreakBefore.GetIntValue() &&
-       NS_STYLE_PAGE_BREAK_AUTO  != displayData.mBreakBefore.GetIntValue());
-  }
-  else if (eCSSUnit_Initial == displayData.mBreakBefore.GetUnit()) {
+      (NS_STYLE_PAGE_BREAK_AVOID != breakBeforeValue->GetIntValue() &&
+       NS_STYLE_PAGE_BREAK_AUTO  != breakBeforeValue->GetIntValue());
+  }
+  else if (eCSSUnit_Initial == breakBeforeValue->GetUnit()) {
     display->mBreakBefore = PR_FALSE;
   }
-  else if (eCSSUnit_Inherit == displayData.mBreakBefore.GetUnit()) {
+  else if (eCSSUnit_Inherit == breakBeforeValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     display->mBreakBefore = parentDisplay->mBreakBefore;
   }
 
-  if (eCSSUnit_Enumerated == displayData.mBreakAfter.GetUnit()) {
+  const nsCSSValue* breakAfterValue = aRuleData->ValueForPageBreakAfter();
+  if (eCSSUnit_Enumerated == breakAfterValue->GetUnit()) {
     display->mBreakAfter =
-      (NS_STYLE_PAGE_BREAK_AVOID != displayData.mBreakAfter.GetIntValue() &&
-       NS_STYLE_PAGE_BREAK_AUTO  != displayData.mBreakAfter.GetIntValue());
-  }
-  else if (eCSSUnit_Initial == displayData.mBreakAfter.GetUnit()) {
+      (NS_STYLE_PAGE_BREAK_AVOID != breakAfterValue->GetIntValue() &&
+       NS_STYLE_PAGE_BREAK_AUTO  != breakAfterValue->GetIntValue());
+  }
+  else if (eCSSUnit_Initial == breakAfterValue->GetUnit()) {
     display->mBreakAfter = PR_FALSE;
   }
-  else if (eCSSUnit_Inherit == displayData.mBreakAfter.GetUnit()) {
+  else if (eCSSUnit_Inherit == breakAfterValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     display->mBreakAfter = parentDisplay->mBreakAfter;
   }
   // end temp fix
 
   // float: enum, inherit, initial
-  SetDiscrete(displayData.mFloat, display->mFloats, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForCssFloat(),
+              display->mFloats, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentDisplay->mFloats,
               NS_STYLE_FLOAT_NONE, 0, 0, 0, 0);
 
   // overflow-x: enum, inherit, initial
-  SetDiscrete(displayData.mOverflowX, display->mOverflowX, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForOverflowX(),
+              display->mOverflowX, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentDisplay->mOverflowX,
               NS_STYLE_OVERFLOW_VISIBLE, 0, 0, 0, 0);
 
   // overflow-y: enum, inherit, initial
-  SetDiscrete(displayData.mOverflowY, display->mOverflowY, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForOverflowY(),
+              display->mOverflowY, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentDisplay->mOverflowY,
               NS_STYLE_OVERFLOW_VISIBLE, 0, 0, 0, 0);
 
   // CSS3 overflow-x and overflow-y require some fixup as well in some
   // cases.  NS_STYLE_OVERFLOW_VISIBLE and NS_STYLE_OVERFLOW_CLIP are
   // meaningful only when used in both dimensions.
   if (display->mOverflowX != display->mOverflowY &&
       (display->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE ||
@@ -4093,39 +4127,40 @@ nsRuleNode::ComputeDisplayData(void* aSt
     // If 'visible' is specified but doesn't match the other dimension, it
     // turns into 'auto'.
     if (display->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE)
       display->mOverflowX = NS_STYLE_OVERFLOW_AUTO;
     if (display->mOverflowY == NS_STYLE_OVERFLOW_VISIBLE)
       display->mOverflowY = NS_STYLE_OVERFLOW_AUTO;
   }
 
-  SetDiscrete(displayData.mResize, display->mResize, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForResize(), display->mResize, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentDisplay->mResize,
               NS_STYLE_RESIZE_NONE, 0, 0, 0, 0);
 
   // clip property: length, auto, inherit
-  switch (displayData.mClip.GetUnit()) {
+  const nsCSSValue* clipValue = aRuleData->ValueForClip();
+  switch (clipValue->GetUnit()) {
   case eCSSUnit_Inherit:
     canStoreInRuleTree = PR_FALSE;
     display->mClipFlags = parentDisplay->mClipFlags;
     display->mClip = parentDisplay->mClip;
     break;
 
   case eCSSUnit_Initial:
   case eCSSUnit_Auto:
     display->mClipFlags = NS_STYLE_CLIP_AUTO;
     display->mClip.SetRect(0,0,0,0);
     break;
 
   case eCSSUnit_Null:
     break;
 
   case eCSSUnit_Rect: {
-    const nsCSSRect& clipRect = displayData.mClip.GetRectValue();
+    const nsCSSRect& clipRect = clipValue->GetRectValue();
 
     display->mClipFlags = NS_STYLE_CLIP_RECT;
 
     if (clipRect.mTop.GetUnit() == eCSSUnit_Auto) {
       display->mClip.y = 0;
       display->mClipFlags |= NS_STYLE_CLIP_TOP_AUTO;
     }
     else if (clipRect.mTop.IsLengthUnit()) {
@@ -4215,17 +4250,18 @@ nsRuleNode::ComputeDisplayData(void* aSt
       // rule has 'float: none' we'll end up with the wrong 'display'
       // property.
       canStoreInRuleTree = PR_FALSE;
     }
 
   }
 
   /* Convert the nsCSSValueList into an nsTArray<nsTransformFunction *>. */
-  switch (displayData.mTransform.GetUnit()) {
+  const nsCSSValue* transformValue = aRuleData->ValueForTransform();
+  switch (transformValue->GetUnit()) {
   case eCSSUnit_Null:
     break;
 
   case eCSSUnit_Initial:
   case eCSSUnit_None:
     display->mSpecifiedTransform = nsnull;
     break;
 
@@ -4233,17 +4269,17 @@ nsRuleNode::ComputeDisplayData(void* aSt
     display->mSpecifiedTransform = parentDisplay->mSpecifiedTransform;
     if (parentDisplay->mSpecifiedTransform)
       display->mTransform = parentDisplay->mTransform;
     canStoreInRuleTree = PR_FALSE;
     break;
 
   case eCSSUnit_List:
   case eCSSUnit_ListDep: {
-    const nsCSSValueList* head = displayData.mTransform.GetListValue();
+    const nsCSSValueList* head = transformValue->GetListValue();
     // can get a _None in here from transform animation
     if (head->mValue.GetUnit() == eCSSUnit_None) {
       NS_ABORT_IF_FALSE(head->mNext == nsnull, "none must be alone");
       display->mSpecifiedTransform = nsnull;
     } else {
       display->mSpecifiedTransform = head; // weak pointer, owned by rule
       display->mTransform = nsStyleTransformMatrix::ReadTransforms(head,
                               aContext, mPresContext, canStoreInRuleTree);
@@ -4251,110 +4287,114 @@ nsRuleNode::ComputeDisplayData(void* aSt
     break;
   }
 
   default:
     NS_ABORT_IF_FALSE(false, "unrecognized transform unit");
   }
 
   /* Convert -moz-transform-origin. */
-  if (displayData.mTransformOrigin.GetUnit() != eCSSUnit_Null) {
+  const nsCSSValue* transformOriginValue =
+    aRuleData->ValueForTransformOrigin();
+  if (transformOriginValue->GetUnit() != eCSSUnit_Null) {
 #ifdef DEBUG
     PRBool result =
 #endif
-      SetPairCoords(displayData.mTransformOrigin,
+      SetPairCoords(*transformOriginValue,
                     display->mTransformOrigin[0],
                     display->mTransformOrigin[1],
                     parentDisplay->mTransformOrigin[0],
                     parentDisplay->mTransformOrigin[1],
                     SETCOORD_LPH | SETCOORD_INITIAL_HALF |
                     SETCOORD_BOX_POSITION | SETCOORD_STORE_CALC,
                     aContext, mPresContext, canStoreInRuleTree);
     NS_ASSERTION(result, "Malformed -moz-transform-origin parse!");
   }
 
   COMPUTE_END_RESET(Display, display)
 }
 
 const void*
 nsRuleNode::ComputeVisibilityData(void* aStartStruct,
-                                  const nsRuleDataStruct& aData,
+                                  const nsRuleData* aRuleData,
                                   nsStyleContext* aContext,
                                   nsRuleNode* aHighestNode,
                                   const RuleDetail aRuleDetail,
                                   const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Visibility, (mPresContext),
                           visibility, parentVisibility,
                           Display, displayData)
 
   // direction: enum, inherit, initial
-  SetDiscrete(displayData.mDirection, visibility->mDirection,
+  SetDiscrete(*aRuleData->ValueForDirection(), visibility->mDirection,
               canStoreInRuleTree,
               SETDSC_ENUMERATED, parentVisibility->mDirection,
               (GET_BIDI_OPTION_DIRECTION(mPresContext->GetBidi())
                == IBMBIDI_TEXTDIRECTION_RTL)
               ? NS_STYLE_DIRECTION_RTL : NS_STYLE_DIRECTION_LTR,
               0, 0, 0, 0);
 
   // visibility: enum, inherit, initial
-  SetDiscrete(displayData.mVisibility, visibility->mVisible,
+  SetDiscrete(*aRuleData->ValueForVisibility(), visibility->mVisible,
               canStoreInRuleTree,
               SETDSC_ENUMERATED, parentVisibility->mVisible,
               NS_STYLE_VISIBILITY_VISIBLE, 0, 0, 0, 0);
 
   // pointer-events: enum, inherit, initial
-  SetDiscrete(displayData.mPointerEvents, visibility->mPointerEvents,
+  SetDiscrete(*aRuleData->ValueForPointerEvents(), visibility->mPointerEvents,
               canStoreInRuleTree,
               SETDSC_ENUMERATED, parentVisibility->mPointerEvents,
               NS_STYLE_POINTER_EVENTS_AUTO, 0, 0, 0, 0);
 
   // lang: string, inherit
   // this is not a real CSS property, it is a html attribute mapped to CSS struture
-  if (eCSSUnit_Ident == displayData.mLang.GetUnit()) {
+  const nsCSSValue* langValue = aRuleData->ValueForLang();
+  if (eCSSUnit_Ident == langValue->GetUnit()) {
     if (!gLangService) {
       CallGetService(NS_LANGUAGEATOMSERVICE_CONTRACTID, &gLangService);
     }
 
     if (gLangService) {
       nsAutoString lang;
-      displayData.mLang.GetStringValue(lang);
+      langValue->GetStringValue(lang);
 
       nsContentUtils::ASCIIToLower(lang);
       visibility->mLanguage = do_GetAtom(lang);
     }
   }
 
   COMPUTE_END_INHERITED(Visibility, visibility)
 }
 
 const void*
 nsRuleNode::ComputeColorData(void* aStartStruct,
-                             const nsRuleDataStruct& aData,
+                             const nsRuleData* aRuleData,
                              nsStyleContext* aContext,
                              nsRuleNode* aHighestNode,
                              const RuleDetail aRuleDetail,
                              const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Color, (mPresContext), color, parentColor,
                           Color, colorData)
 
   // color: color, string, inherit
   // Special case for currentColor.  According to CSS3, setting color to 'currentColor'
   // should behave as if it is inherited
-  if (colorData.mColor.GetUnit() == eCSSUnit_EnumColor &&
-      colorData.mColor.GetIntValue() == NS_COLOR_CURRENTCOLOR) {
+  const nsCSSValue* colorValue = aRuleData->ValueForColor();
+  if (colorValue->GetUnit() == eCSSUnit_EnumColor &&
+      colorValue->GetIntValue() == NS_COLOR_CURRENTCOLOR) {
     color->mColor = parentColor->mColor;
     canStoreInRuleTree = PR_FALSE;
   }
-  else if (colorData.mColor.GetUnit() == eCSSUnit_Initial) {
+  else if (colorValue->GetUnit() == eCSSUnit_Initial) {
     color->mColor = mPresContext->DefaultColor();
   }
   else {
-    SetColor(colorData.mColor, parentColor->mColor, mPresContext, aContext,
+    SetColor(*colorValue, parentColor->mColor, mPresContext, aContext,
              color->mColor, canStoreInRuleTree);
   }
 
   COMPUTE_END_INHERITED(Color, color)
 }
 
 // information about how to compute values for background-* properties
 template <class SpecifiedValueItem>
@@ -4714,91 +4754,99 @@ FillBackgroundList(nsAutoTArray< nsStyle
        ++sourceLayer, ++destLayer) {
     aLayers[destLayer].*aResultLocation =
       aLayers[sourceLayer].*aResultLocation;
   }
 }
 
 const void*
 nsRuleNode::ComputeBackgroundData(void* aStartStruct,
-                                  const nsRuleDataStruct& aData,
+                                  const nsRuleData* aRuleData,
                                   nsStyleContext* aContext,
                                   nsRuleNode* aHighestNode,
                                   const RuleDetail aRuleDetail,
                                   const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Background, (), bg, parentBG, Color, colorData)
 
   // background-color: color, string, inherit
-  if (eCSSUnit_Initial == colorData.mBackColor.GetUnit()) {
+  const nsCSSValue* backColorValue = aRuleData->ValueForBackgroundColor();
+  if (eCSSUnit_Initial == backColorValue->GetUnit()) {
     bg->mBackgroundColor = NS_RGBA(0, 0, 0, 0);
-  } else if (!SetColor(colorData.mBackColor, parentBG->mBackgroundColor,
+  } else if (!SetColor(*backColorValue, parentBG->mBackgroundColor,
                        mPresContext, aContext, bg->mBackgroundColor,
                        canStoreInRuleTree)) {
-    NS_ASSERTION(eCSSUnit_Null == colorData.mBackColor.GetUnit(),
+    NS_ASSERTION(eCSSUnit_Null == backColorValue->GetUnit(),
                  "unexpected color unit");
   }
 
   PRUint32 maxItemCount = 1;
   PRBool rebuild = PR_FALSE;
 
   // background-image: url (stored as image), none, inherit [list]
   nsStyleImage initialImage;
-  SetBackgroundList(aContext, colorData.mBackImage, bg->mLayers,
+  SetBackgroundList(aContext, *aRuleData->ValueForBackgroundImage(),
+                    bg->mLayers,
                     parentBG->mLayers, &nsStyleBackground::Layer::mImage,
                     initialImage, parentBG->mImageCount, bg->mImageCount,
                     maxItemCount, rebuild, canStoreInRuleTree);
 
   // background-repeat: enum, inherit, initial [list]
-  SetBackgroundList(aContext, colorData.mBackRepeat, bg->mLayers,
+  SetBackgroundList(aContext, *aRuleData->ValueForBackgroundRepeat(),
+                    bg->mLayers,
                     parentBG->mLayers, &nsStyleBackground::Layer::mRepeat,
                     PRUint8(NS_STYLE_BG_REPEAT_XY), parentBG->mRepeatCount,
                     bg->mRepeatCount, maxItemCount, rebuild, canStoreInRuleTree);
 
   // background-attachment: enum, inherit, initial [list]
-  SetBackgroundList(aContext, colorData.mBackAttachment, bg->mLayers,
-                    parentBG->mLayers,
+  SetBackgroundList(aContext, *aRuleData->ValueForBackgroundAttachment(),
+                    bg->mLayers, parentBG->mLayers,
                     &nsStyleBackground::Layer::mAttachment,
                     PRUint8(NS_STYLE_BG_ATTACHMENT_SCROLL),
                     parentBG->mAttachmentCount,
                     bg->mAttachmentCount, maxItemCount, rebuild,
                     canStoreInRuleTree);
 
   // background-clip: enum, inherit, initial [list]
-  SetBackgroundList(aContext, colorData.mBackClip, bg->mLayers,
+  SetBackgroundList(aContext, *aRuleData->ValueForBackgroundClip(),
+                    bg->mLayers,
                     parentBG->mLayers, &nsStyleBackground::Layer::mClip,
                     PRUint8(NS_STYLE_BG_CLIP_BORDER), parentBG->mClipCount,
                     bg->mClipCount, maxItemCount, rebuild, canStoreInRuleTree);
 
   // background-inline-policy: enum, inherit, initial
-  SetDiscrete(colorData.mBackInlinePolicy, bg->mBackgroundInlinePolicy,
+  SetDiscrete(*aRuleData->ValueForBackgroundInlinePolicy(),
+              bg->mBackgroundInlinePolicy,
               canStoreInRuleTree, SETDSC_ENUMERATED,
               parentBG->mBackgroundInlinePolicy,
               NS_STYLE_BG_INLINE_POLICY_CONTINUOUS, 0, 0, 0, 0);
 
   // background-origin: enum, inherit, initial [list]
-  SetBackgroundList(aContext, colorData.mBackOrigin, bg->mLayers,
+  SetBackgroundList(aContext, *aRuleData->ValueForBackgroundOrigin(),
+                    bg->mLayers,
                     parentBG->mLayers, &nsStyleBackground::Layer::mOrigin,
                     PRUint8(NS_STYLE_BG_ORIGIN_PADDING), parentBG->mOriginCount,
                     bg->mOriginCount, maxItemCount, rebuild,
                     canStoreInRuleTree);
 
   // background-position: enum, length, percent (flags), inherit [pair list]
   nsStyleBackground::Position initialPosition;
   initialPosition.SetInitialValues();
-  SetBackgroundPairList(aContext, colorData.mBackPosition, bg->mLayers,
+  SetBackgroundPairList(aContext, *aRuleData->ValueForBackgroundPosition(),
+                        bg->mLayers,
                         parentBG->mLayers, &nsStyleBackground::Layer::mPosition,
                         initialPosition, parentBG->mPositionCount,
                         bg->mPositionCount, maxItemCount, rebuild,
                         canStoreInRuleTree);
 
   // background-size: enum, length, auto, inherit, initial [pair list]
   nsStyleBackground::Size initialSize;
   initialSize.SetInitialValues();
-  SetBackgroundPairList(aContext, colorData.mBackSize, bg->mLayers,
+  SetBackgroundPairList(aContext, *aRuleData->ValueForBackgroundSize(),
+                        bg->mLayers,
                         parentBG->mLayers, &nsStyleBackground::Layer::mSize,
                         initialSize, parentBG->mSizeCount,
                         bg->mSizeCount, maxItemCount, rebuild,
                         canStoreInRuleTree);
 
   if (rebuild) {
     // Delete any extra items.  We need to keep layers in which any
     // property was specified.
@@ -4825,36 +4873,42 @@ nsRuleNode::ComputeBackgroundData(void* 
   for (PRUint32 i = 0; i < bg->mImageCount; ++i)
     bg->mLayers[i].TrackImages(aContext->PresContext());
 
   COMPUTE_END_RESET(Background, bg)
 }
 
 const void*
 nsRuleNode::ComputeMarginData(void* aStartStruct,
-                              const nsRuleDataStruct& aData,
+                              const nsRuleData* aRuleData,
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Margin, (), margin, parentMargin, Margin, marginData)
 
   // margin: length, percent, auto, inherit
   nsStyleCoord  coord;
-  nsCSSRect ourMargin(marginData.mMargin);
+  nsCSSRect ourMargin;
+  ourMargin.mTop = *aRuleData->ValueForMarginTop();
+  ourMargin.mRight = *aRuleData->ValueForMarginRightValue();
+  ourMargin.mBottom = *aRuleData->ValueForMarginBottom();
+  ourMargin.mLeft = *aRuleData->ValueForMarginLeftValue();
   AdjustLogicalBoxProp(aContext,
-                       marginData.mMarginLeftLTRSource,
-                       marginData.mMarginLeftRTLSource,
-                       marginData.mMarginStart, marginData.mMarginEnd,
+                       *aRuleData->ValueForMarginLeftLTRSource(),
+                       *aRuleData->ValueForMarginLeftRTLSource(),
+                       *aRuleData->ValueForMarginStartValue(),
+                       *aRuleData->ValueForMarginEndValue(),
                        NS_SIDE_LEFT, ourMargin, canStoreInRuleTree);
   AdjustLogicalBoxProp(aContext,
-                       marginData.mMarginRightLTRSource,
-                       marginData.mMarginRightRTLSource,
-                       marginData.mMarginEnd, marginData.mMarginStart,
+                       *aRuleData->ValueForMarginRightLTRSource(),
+                       *aRuleData->ValueForMarginRightRTLSource(),
+                       *aRuleData->ValueForMarginEndValue(),
+                       *aRuleData->ValueForMarginStartValue(),
                        NS_SIDE_RIGHT, ourMargin, canStoreInRuleTree);
   NS_FOR_CSS_SIDES(side) {
     nsStyleCoord parentCoord = parentMargin->mMargin.Get(side);
     if (SetCoord(ourMargin.*(nsCSSRect::sides[side]),
                  coord, parentCoord,
                  SETCOORD_LPAH | SETCOORD_INITIAL_ZERO | SETCOORD_STORE_CALC,
                  aContext, mPresContext, canStoreInRuleTree)) {
       margin->mMargin.Set(side, coord);
@@ -4862,66 +4916,71 @@ nsRuleNode::ComputeMarginData(void* aSta
   }
 
   margin->RecalcData();
   COMPUTE_END_RESET(Margin, margin)
 }
 
 const void*
 nsRuleNode::ComputeBorderData(void* aStartStruct,
-                              const nsRuleDataStruct& aData,
+                              const nsRuleData* aRuleData,
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Border, (mPresContext), border, parentBorder,
                       Margin, marginData)
 
   // box-shadow: none, list, inherit, initial
-  switch (marginData.mBoxShadow.GetUnit()) {
+  const nsCSSValue* boxShadowValue = aRuleData->ValueForBoxShadow();
+  switch (boxShadowValue->GetUnit()) {
   case eCSSUnit_Null:
     break;
 
   case eCSSUnit_Initial:
   case eCSSUnit_None:
     border->mBoxShadow = nsnull;
     break;
 
   case eCSSUnit_Inherit:
     border->mBoxShadow = parentBorder->mBoxShadow;
     canStoreInRuleTree = PR_FALSE;
     break;
 
   case eCSSUnit_List:
   case eCSSUnit_ListDep:
-    border->mBoxShadow = GetShadowData(marginData.mBoxShadow.GetListValue(),
+    border->mBoxShadow = GetShadowData(boxShadowValue->GetListValue(),
                                        aContext, PR_TRUE, canStoreInRuleTree);
     break;
 
   default:
     NS_ABORT_IF_FALSE(false,
                       nsPrintfCString(64, "unrecognized shadow unit %d",
-                                      marginData.mBoxShadow.GetUnit()).get());
+                                      boxShadowValue->GetUnit()).get());
   }
 
   // border-width, border-*-width: length, enum, inherit
   nsStyleCoord  coord;
-  nsCSSRect ourBorderWidth(marginData.mBorderWidth);
+  nsCSSRect ourBorderWidth;
+  ourBorderWidth.mTop = *aRuleData->ValueForBorderTopWidth();
+  ourBorderWidth.mRight = *aRuleData->ValueForBorderRightWidthValue();
+  ourBorderWidth.mBottom = *aRuleData->ValueForBorderBottomWidth();
+  ourBorderWidth.mLeft = *aRuleData->ValueForBorderLeftWidthValue();
   AdjustLogicalBoxProp(aContext,
-                       marginData.mBorderLeftWidthLTRSource,
-                       marginData.mBorderLeftWidthRTLSource,
-                       marginData.mBorderStartWidth,
-                       marginData.mBorderEndWidth,
+                       *aRuleData->ValueForBorderLeftWidthLTRSource(),
+                       *aRuleData->ValueForBorderLeftWidthRTLSource(),
+                       *aRuleData->ValueForBorderStartWidthValue(),
+                       *aRuleData->ValueForBorderEndWidthValue(),
                        NS_SIDE_LEFT, ourBorderWidth, canStoreInRuleTree);
   AdjustLogicalBoxProp(aContext,
-                       marginData.mBorderRightWidthLTRSource,
-                       marginData.mBorderRightWidthRTLSource,
-                       marginData.mBorderEndWidth,
-                       marginData.mBorderStartWidth,
+                       *aRuleData->ValueForBorderRightWidthLTRSource(),
+                       *aRuleData->ValueForBorderRightWidthRTLSource(),
+                       *aRuleData->ValueForBorderEndWidthValue(),
+                       *aRuleData->ValueForBorderStartWidthValue(),
                        NS_SIDE_RIGHT, ourBorderWidth, canStoreInRuleTree);
   { // scope for compilers with broken |for| loop scoping
     NS_FOR_CSS_SIDES(side) {
       const nsCSSValue &value = ourBorderWidth.*(nsCSSRect::sides[side]);
       NS_ASSERTION(eCSSUnit_Percent != value.GetUnit(),
                    "Percentage borders not implemented yet "
                    "If implementing, make sure to fix all consumers of "
                    "nsStyleBorder, the IsPercentageAwareChild method, "
@@ -4957,30 +5016,36 @@ nsRuleNode::ComputeBorderData(void* aSta
       else {
         NS_ASSERTION(eCSSUnit_Null == value.GetUnit(),
                      "missing case handling border width");
       }
     }
   }
 
   // border-style, border-*-style: enum, inherit
-  nsCSSRect ourStyle(marginData.mBorderStyle);
+  nsCSSRect ourBorderStyle;
+  ourBorderStyle.mTop = *aRuleData->ValueForBorderTopStyle();
+  ourBorderStyle.mRight = *aRuleData->ValueForBorderRightStyleValue();
+  ourBorderStyle.mBottom = *aRuleData->ValueForBorderBottomStyle();
+  ourBorderStyle.mLeft = *aRuleData->ValueForBorderLeftStyleValue();
   AdjustLogicalBoxProp(aContext,
-                       marginData.mBorderLeftStyleLTRSource,
-                       marginData.mBorderLeftStyleRTLSource,
-                       marginData.mBorderStartStyle, marginData.mBorderEndStyle,
-                       NS_SIDE_LEFT, ourStyle, canStoreInRuleTree);
+                       *aRuleData->ValueForBorderLeftStyleLTRSource(),
+                       *aRuleData->ValueForBorderLeftStyleRTLSource(),
+                       *aRuleData->ValueForBorderStartStyleValue(),
+                       *aRuleData->ValueForBorderEndStyleValue(),
+                       NS_SIDE_LEFT, ourBorderStyle, canStoreInRuleTree);
   AdjustLogicalBoxProp(aContext,
-                       marginData.mBorderRightStyleLTRSource,
-                       marginData.mBorderRightStyleRTLSource,
-                       marginData.mBorderEndStyle, marginData.mBorderStartStyle,
-                       NS_SIDE_RIGHT, ourStyle, canStoreInRuleTree);
+                       *aRuleData->ValueForBorderRightStyleLTRSource(),
+                       *aRuleData->ValueForBorderRightStyleRTLSource(),
+                       *aRuleData->ValueForBorderEndStyleValue(),
+                       *aRuleData->ValueForBorderStartStyleValue(),
+                       NS_SIDE_RIGHT, ourBorderStyle, canStoreInRuleTree);
   { // scope for compilers with broken |for| loop scoping
     NS_FOR_CSS_SIDES(side) {
-      const nsCSSValue &value = ourStyle.*(nsCSSRect::sides[side]);
+      const nsCSSValue &value = ourBorderStyle.*(nsCSSRect::sides[side]);
       nsCSSUnit unit = value.GetUnit();
       NS_ABORT_IF_FALSE(eCSSUnit_None != unit,
                         "'none' should be handled as enumerated value");
       if (eCSSUnit_Enumerated == unit) {
         border->SetBorderStyle(side, value.GetIntValue());
       }
       else if (eCSSUnit_Initial == unit) {
         border->SetBorderStyle(side, NS_STYLE_BORDER_STYLE_NONE);
@@ -4991,19 +5056,25 @@ nsRuleNode::ComputeBorderData(void* aSta
       }
     }
   }
 
   // -moz-border-*-colors: color, string, enum, none, inherit/initial
   nscolor borderColor;
   nscolor unused = NS_RGB(0,0,0);
 
+  static const nsCSSProperty borderColorsProps[] = {
+    eCSSProperty_border_top_colors,
+    eCSSProperty_border_right_colors,
+    eCSSProperty_border_bottom_colors,
+    eCSSProperty_border_left_colors
+  };
+
   NS_FOR_CSS_SIDES(side) {
-    const nsCSSValue& value =
-      marginData.mBorderColors.*(nsCSSRect::sides[side]);
+    const nsCSSValue& value = *aRuleData->ValueFor(borderColorsProps[side]);
     switch (value.GetUnit()) {
     case eCSSUnit_Null:
       break;
 
     case eCSSUnit_Initial:
     case eCSSUnit_None:
       border->ClearBorderColors(side);
       break;
@@ -5042,27 +5113,33 @@ nsRuleNode::ComputeBorderData(void* aSta
     }
 
     default:
       NS_ABORT_IF_FALSE(false, "unrecognized border color unit");
     }
   }
 
   // border-color, border-*-color: color, string, enum, inherit
-  nsCSSRect ourBorderColor(marginData.mBorderColor);
   PRBool foreground;
+  nsCSSRect ourBorderColor;
+  ourBorderColor.mTop = *aRuleData->ValueForBorderTopColor();
+  ourBorderColor.mRight = *aRuleData->ValueForBorderRightColorValue();
+  ourBorderColor.mBottom = *aRuleData->ValueForBorderBottomColor();
+  ourBorderColor.mLeft = *aRuleData->ValueForBorderLeftColorValue();
   AdjustLogicalBoxProp(aContext,
-                       marginData.mBorderLeftColorLTRSource,
-                       marginData.mBorderLeftColorRTLSource,
-                       marginData.mBorderStartColor, marginData.mBorderEndColor,
+                       *aRuleData->ValueForBorderLeftColorLTRSource(),
+                       *aRuleData->ValueForBorderLeftColorRTLSource(),
+                       *aRuleData->ValueForBorderStartColorValue(),
+                       *aRuleData->ValueForBorderEndColorValue(),
                        NS_SIDE_LEFT, ourBorderColor, canStoreInRuleTree);
   AdjustLogicalBoxProp(aContext,
-                       marginData.mBorderRightColorLTRSource,
-                       marginData.mBorderRightColorRTLSource,
-                       marginData.mBorderEndColor, marginData.mBorderStartColor,
+                       *aRuleData->ValueForBorderRightColorLTRSource(),
+                       *aRuleData->ValueForBorderRightColorRTLSource(),
+                       *aRuleData->ValueForBorderEndColorValue(),
+                       *aRuleData->ValueForBorderStartColorValue(),
                        NS_SIDE_RIGHT, ourBorderColor, canStoreInRuleTree);
   { // scope for compilers with broken |for| loop scoping
     NS_FOR_CSS_SIDES(side) {
       const nsCSSValue &value = ourBorderColor.*(nsCSSRect::sides[side]);
       if (eCSSUnit_Inherit == value.GetUnit()) {
         canStoreInRuleTree = PR_FALSE;
         if (parentContext) {
           parentBorder->GetBorderColor(side, borderColor, foreground);
@@ -5094,43 +5171,46 @@ nsRuleNode::ComputeBorderData(void* aSta
       else if (eCSSUnit_Initial == value.GetUnit()) {
         border->SetBorderToForeground(side);
       }
     }
   }
 
   // border-radius: length, percent, inherit
   {
-    const nsCSSCornerSizes& borderRadius = marginData.mBorderRadius;
+    const nsCSSProperty* subprops =
+      nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_radius);
     NS_FOR_CSS_FULL_CORNERS(corner) {
       int cx = NS_FULL_TO_HALF_CORNER(corner, false);
       int cy = NS_FULL_TO_HALF_CORNER(corner, true);
-      const nsCSSValue& radius = borderRadius.GetCorner(corner);
+      const nsCSSValue& radius = *aRuleData->ValueFor(subprops[corner]);
       nsStyleCoord parentX = parentBorder->mBorderRadius.Get(cx);
       nsStyleCoord parentY = parentBorder->mBorderRadius.Get(cy);
       nsStyleCoord coordX, coordY;
 
       if (SetPairCoords(radius, coordX, coordY, parentX, parentY,
                         SETCOORD_LPH | SETCOORD_INITIAL_ZERO |
                           SETCOORD_STORE_CALC,
                         aContext, mPresContext, canStoreInRuleTree)) {
         border->mBorderRadius.Set(cx, coordX);
         border->mBorderRadius.Set(cy, coordY);
       }
     }
   }
 
   // float-edge: enum, inherit, initial
-  SetDiscrete(marginData.mFloatEdge, border->mFloatEdge, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForFloatEdge(),
+              border->mFloatEdge, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentBorder->mFloatEdge,
               NS_STYLE_FLOAT_EDGE_CONTENT, 0, 0, 0, 0);
 
   // border-image
-  if (eCSSUnit_Array == marginData.mBorderImage.GetUnit()) {
-    nsCSSValue::Array *arr = marginData.mBorderImage.GetArrayValue();
+  const nsCSSValue* borderImageValue = aRuleData->ValueForBorderImage();
+  if (eCSSUnit_Array == borderImageValue->GetUnit()) {
+    nsCSSValue::Array *arr = borderImageValue->GetArrayValue();
 
     // the image
     if (eCSSUnit_Image == arr->Item(0).GetUnit()) {
       NS_SET_IMAGE_REQUEST(border->SetBorderImage,
                            aContext,
                            arr->Item(0).GetImageValue())
     }
 
@@ -5176,21 +5256,21 @@ nsRuleNode::ComputeBorderData(void* aSta
       if (eCSSUnit_Null == arr->Item(10).GetUnit()) {
         // vertical same as horizontal
         border->mBorderImageVFill = border->mBorderImageHFill;
       } else {
         // have vertical value
         border->mBorderImageVFill = arr->Item(10).GetIntValue();
       }
     }
-  } else if (eCSSUnit_None == marginData.mBorderImage.GetUnit() ||
-             eCSSUnit_Initial == marginData.mBorderImage.GetUnit()) {
+  } else if (eCSSUnit_None == borderImageValue->GetUnit() ||
+             eCSSUnit_Initial == borderImageValue->GetUnit()) {
     border->mHaveBorderImageWidth = PR_FALSE;
     border->SetBorderImage(nsnull);
-  } else if (eCSSUnit_Inherit == marginData.mBorderImage.GetUnit()) {
+  } else if (eCSSUnit_Inherit == borderImageValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     NS_FOR_CSS_SIDES(side) {
       border->SetBorderImageWidthOverride(side, parentBorder->mBorderImageWidth.side(side));
     }
     border->mBorderImageSplit = parentBorder->mBorderImageSplit;
     border->mBorderImageHFill = parentBorder->mBorderImageHFill;
     border->mBorderImageVFill = parentBorder->mBorderImageVFill;
     border->mHaveBorderImageWidth = parentBorder->mHaveBorderImageWidth;
@@ -5201,36 +5281,42 @@ nsRuleNode::ComputeBorderData(void* aSta
   if (border->HasBorderImage())
     border->TrackImage(aContext->PresContext());
 
   COMPUTE_END_RESET(Border, border)
 }
 
 const void*
 nsRuleNode::ComputePaddingData(void* aStartStruct,
-                               const nsRuleDataStruct& aData,
+                               const nsRuleData* aRuleData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Padding, (), padding, parentPadding, Margin, marginData)
 
   // padding: length, percent, inherit
   nsStyleCoord  coord;
-  nsCSSRect ourPadding(marginData.mPadding);
+  nsCSSRect ourPadding;
+  ourPadding.mTop = *aRuleData->ValueForPaddingTop();
+  ourPadding.mRight = *aRuleData->ValueForPaddingRightValue();
+  ourPadding.mBottom = *aRuleData->ValueForPaddingBottom();
+  ourPadding.mLeft = *aRuleData->ValueForPaddingLeftValue();
   AdjustLogicalBoxProp(aContext,
-                       marginData.mPaddingLeftLTRSource,
-                       marginData.mPaddingLeftRTLSource,
-                       marginData.mPaddingStart, marginData.mPaddingEnd,
+                       *aRuleData->ValueForPaddingLeftLTRSource(),
+                       *aRuleData->ValueForPaddingLeftRTLSource(),
+                       *aRuleData->ValueForPaddingStartValue(),
+                       *aRuleData->ValueForPaddingEndValue(),
                        NS_SIDE_LEFT, ourPadding, canStoreInRuleTree);
   AdjustLogicalBoxProp(aContext,
-                       marginData.mPaddingRightLTRSource,
-                       marginData.mPaddingRightRTLSource,
-                       marginData.mPaddingEnd, marginData.mPaddingStart,
+                       *aRuleData->ValueForPaddingRightLTRSource(),
+                       *aRuleData->ValueForPaddingRightRTLSource(),
+                       *aRuleData->ValueForPaddingEndValue(),
+                       *aRuleData->ValueForPaddingStartValue(),
                        NS_SIDE_RIGHT, ourPadding, canStoreInRuleTree);
   NS_FOR_CSS_SIDES(side) {
     nsStyleCoord parentCoord = parentPadding->mPadding.Get(side);
     if (SetCoord(ourPadding.*(nsCSSRect::sides[side]),
                  coord, parentCoord,
                  SETCOORD_LPH | SETCOORD_INITIAL_ZERO | SETCOORD_STORE_CALC,
                  aContext, mPresContext, canStoreInRuleTree)) {
       padding->mPadding.Set(side, coord);
@@ -5238,54 +5324,57 @@ nsRuleNode::ComputePaddingData(void* aSt
   }
 
   padding->RecalcData();
   COMPUTE_END_RESET(Padding, padding)
 }
 
 const void*
 nsRuleNode::ComputeOutlineData(void* aStartStruct,
-                               const nsRuleDataStruct& aData,
+                               const nsRuleData* aRuleData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Outline, (mPresContext), outline, parentOutline,
                       Margin, marginData)
 
   // outline-width: length, enum, inherit
-  if (eCSSUnit_Initial == marginData.mOutlineWidth.GetUnit()) {
+  const nsCSSValue* outlineWidthValue = aRuleData->ValueForOutlineWidth();
+  if (eCSSUnit_Initial == outlineWidthValue->GetUnit()) {
     outline->mOutlineWidth =
       nsStyleCoord(NS_STYLE_BORDER_WIDTH_MEDIUM, eStyleUnit_Enumerated);
   }
   else {
-    SetCoord(marginData.mOutlineWidth, outline->mOutlineWidth,
+    SetCoord(*outlineWidthValue, outline->mOutlineWidth,
              parentOutline->mOutlineWidth,
              SETCOORD_LEH | SETCOORD_CALC_LENGTH_ONLY, aContext,
              mPresContext, canStoreInRuleTree);
   }
 
   // outline-offset: length, inherit
   nsStyleCoord tempCoord;
-  if (SetCoord(marginData.mOutlineOffset, tempCoord,
+  const nsCSSValue* outlineOffsetValue = aRuleData->ValueForOutlineOffset();
+  if (SetCoord(*outlineOffsetValue, tempCoord,
                nsStyleCoord(parentOutline->mOutlineOffset,
                             nsStyleCoord::CoordConstructor),
                SETCOORD_LH | SETCOORD_INITIAL_ZERO | SETCOORD_CALC_LENGTH_ONLY,
                aContext, mPresContext, canStoreInRuleTree)) {
     outline->mOutlineOffset = tempCoord.GetCoordValue();
   } else {
-    NS_ASSERTION(marginData.mOutlineOffset.GetUnit() == eCSSUnit_Null,
+    NS_ASSERTION(outlineOffsetValue->GetUnit() == eCSSUnit_Null,
                  "unexpected unit");
   }
 
   // outline-color: color, string, enum, inherit
   nscolor outlineColor;
   nscolor unused = NS_RGB(0,0,0);
-  if (eCSSUnit_Inherit == marginData.mOutlineColor.GetUnit()) {
+  const nsCSSValue* outlineColorValue = aRuleData->ValueForOutlineColor();
+  if (eCSSUnit_Inherit == outlineColorValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     if (parentContext) {
       if (parentOutline->GetOutlineColor(outlineColor))
         outline->SetOutlineColor(outlineColor);
       else {
 #ifdef GFX_HAS_INVERT
         outline->SetOutlineInitialColor();
 #else
@@ -5296,118 +5385,123 @@ nsRuleNode::ComputeOutlineData(void* aSt
         // which the color could be specified on a more specific rule).
         outline->SetOutlineColor(parentContext->GetStyleColor()->mColor);
 #endif
       }
     } else {
       outline->SetOutlineInitialColor();
     }
   }
-  else if (SetColor(marginData.mOutlineColor, unused, mPresContext,
+  else if (SetColor(*outlineColorValue, unused, mPresContext,
                     aContext, outlineColor, canStoreInRuleTree))
     outline->SetOutlineColor(outlineColor);
-  else if (eCSSUnit_Enumerated == marginData.mOutlineColor.GetUnit() ||
-           eCSSUnit_Initial == marginData.mOutlineColor.GetUnit()) {
+  else if (eCSSUnit_Enumerated == outlineColorValue->GetUnit() ||
+           eCSSUnit_Initial == outlineColorValue->GetUnit()) {
     outline->SetOutlineInitialColor();
   }
 
   // -moz-outline-radius: length, percent, inherit
   {
-    nsStyleCoord coord;
-    const nsCSSCornerSizes& outlineRadius = marginData.mOutlineRadius;
+    const nsCSSProperty* subprops =
+      nsCSSProps::SubpropertyEntryFor(eCSSProperty__moz_outline_radius);
     NS_FOR_CSS_FULL_CORNERS(corner) {
       int cx = NS_FULL_TO_HALF_CORNER(corner, false);
       int cy = NS_FULL_TO_HALF_CORNER(corner, true);
-      const nsCSSValue& radius = outlineRadius.GetCorner(corner);
+      const nsCSSValue& radius = *aRuleData->ValueFor(subprops[corner]);
       nsStyleCoord parentX = parentOutline->mOutlineRadius.Get(cx);
       nsStyleCoord parentY = parentOutline->mOutlineRadius.Get(cy);
       nsStyleCoord coordX, coordY;
 
       if (SetPairCoords(radius, coordX, coordY, parentX, parentY,
                         SETCOORD_LPH | SETCOORD_INITIAL_ZERO |
                           SETCOORD_STORE_CALC,
                         aContext, mPresContext, canStoreInRuleTree)) {
         outline->mOutlineRadius.Set(cx, coordX);
         outline->mOutlineRadius.Set(cy, coordY);
       }
     }
   }
 
   // outline-style: enum, inherit, initial
   // cannot use SetDiscrete because of SetOutlineStyle
-  nsCSSUnit unit = marginData.mOutlineStyle.GetUnit();
+  const nsCSSValue* outlineStyleValue = aRuleData->ValueForOutlineStyle();
+  nsCSSUnit unit = outlineStyleValue->GetUnit();
   NS_ABORT_IF_FALSE(eCSSUnit_None != unit && eCSSUnit_Auto != unit,
                     "'none' and 'auto' should be handled as enumerated values");
   if (eCSSUnit_Enumerated == unit) {
-    outline->SetOutlineStyle(marginData.mOutlineStyle.GetIntValue());
+    outline->SetOutlineStyle(outlineStyleValue->GetIntValue());
   } else if (eCSSUnit_Initial == unit) {
     outline->SetOutlineStyle(NS_STYLE_BORDER_STYLE_NONE);
   } else if (eCSSUnit_Inherit == unit) {
     canStoreInRuleTree = PR_FALSE;
     outline->SetOutlineStyle(parentOutline->GetOutlineStyle());
   }
 
   outline->RecalcData(mPresContext);
   COMPUTE_END_RESET(Outline, outline)
 }
 
 const void*
 nsRuleNode::ComputeListData(void* aStartStruct,
-                            const nsRuleDataStruct& aData,
+                            const nsRuleData* aRuleData,
                             nsStyleContext* aContext,
                             nsRuleNode* aHighestNode,
                             const RuleDetail aRuleDetail,
                             const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(List, (), list, parentList, List, listData)
 
   // list-style-type: enum, inherit, initial
-  SetDiscrete(listData.mType, list->mListStyleType, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForListStyleType(),
+              list->mListStyleType, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentList->mListStyleType,
               NS_STYLE_LIST_STYLE_DISC, 0, 0, 0, 0);
 
   // list-style-image: url, none, inherit
-  if (eCSSUnit_Image == listData.mImage.GetUnit()) {
+  const nsCSSValue* imageValue = aRuleData->ValueForListStyleImage();
+  if (eCSSUnit_Image == imageValue->GetUnit()) {
     NS_SET_IMAGE_REQUEST(list->SetListStyleImage,
                          aContext,
-                         listData.mImage.GetImageValue())
-  }
-  else if (eCSSUnit_None == listData.mImage.GetUnit() ||
-           eCSSUnit_Initial == listData.mImage.GetUnit()) {
+                         imageValue->GetImageValue())
+  }
+  else if (eCSSUnit_None == imageValue->GetUnit() ||
+           eCSSUnit_Initial == imageValue->GetUnit()) {
     list->SetListStyleImage(nsnull);
   }
-  else if (eCSSUnit_Inherit == listData.mImage.GetUnit()) {
+  else if (eCSSUnit_Inherit == imageValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     NS_SET_IMAGE_REQUEST(list->SetListStyleImage,
                          aContext,
                          parentList->GetListStyleImage())
   }
 
   // list-style-position: enum, inherit, initial
-  SetDiscrete(listData.mPosition, list->mListStylePosition, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForListStylePosition(),
+              list->mListStylePosition, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentList->mListStylePosition,
               NS_STYLE_LIST_STYLE_POSITION_OUTSIDE, 0, 0, 0, 0);
 
   // image region property: length, auto, inherit
-  switch (listData.mImageRegion.GetUnit()) {
+  const nsCSSValue* imageRegionValue = aRuleData->ValueForImageRegion();
+  switch (imageRegionValue->GetUnit()) {
   case eCSSUnit_Inherit:
     canStoreInRuleTree = PR_FALSE;
     list->mImageRegion = parentList->mImageRegion;
     break;
 
   case eCSSUnit_Initial:
   case eCSSUnit_Auto:
     list->mImageRegion.SetRect(0,0,0,0);
     break;
 
   case eCSSUnit_Null:
     break;
 
   case eCSSUnit_Rect: {
-    const nsCSSRect& rgnRect = listData.mImageRegion.GetRectValue();
+    const nsCSSRect& rgnRect = imageRegionValue->GetRectValue();
 
     if (rgnRect.mTop.GetUnit() == eCSSUnit_Auto)
       list->mImageRegion.y = 0;
     else if (rgnRect.mTop.IsLengthUnit())
       list->mImageRegion.y =
         CalcLength(rgnRect.mTop, aContext, mPresContext, canStoreInRuleTree);
 
     if (rgnRect.mBottom.GetUnit() == eCSSUnit_Auto)
@@ -5436,174 +5530,189 @@ nsRuleNode::ComputeListData(void* aStart
     NS_ABORT_IF_FALSE(false, "unrecognized image-region unit");
   }
 
   COMPUTE_END_INHERITED(List, list)
 }
 
 const void*
 nsRuleNode::ComputePositionData(void* aStartStruct,
-                                const nsRuleDataStruct& aData,
+                                const nsRuleData* aRuleData,
                                 nsStyleContext* aContext,
                                 nsRuleNode* aHighestNode,
                                 const RuleDetail aRuleDetail,
                                 const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Position, (), pos, parentPos, Position, posData)
 
   // box offsets: length, percent, calc, auto, inherit
+  static const nsCSSProperty offsetProps[] = {
+    eCSSProperty_top,
+    eCSSProperty_right,
+    eCSSProperty_bottom,
+    eCSSProperty_left
+  };
   nsStyleCoord  coord;
   NS_FOR_CSS_SIDES(side) {
     nsStyleCoord parentCoord = parentPos->mOffset.Get(side);
-    if (SetCoord(posData.mOffset.*(nsCSSRect::sides[side]),
+    if (SetCoord(*aRuleData->ValueFor(offsetProps[side]),
                  coord, parentCoord,
                  SETCOORD_LPAH | SETCOORD_INITIAL_AUTO | SETCOORD_STORE_CALC,
                  aContext, mPresContext, canStoreInRuleTree)) {
       pos->mOffset.Set(side, coord);
     }
   }
 
-  SetCoord(posData.mWidth, pos->mWidth, parentPos->mWidth,
+  SetCoord(*aRuleData->ValueForWidth(), pos->mWidth, parentPos->mWidth,
            SETCOORD_LPAEH | SETCOORD_INITIAL_AUTO | SETCOORD_STORE_CALC,
            aContext, mPresContext, canStoreInRuleTree);
-  SetCoord(posData.mMinWidth, pos->mMinWidth, parentPos->mMinWidth,
+  SetCoord(*aRuleData->ValueForMinWidth(), pos->mMinWidth, parentPos->mMinWidth,
            SETCOORD_LPEH | SETCOORD_INITIAL_ZERO | SETCOORD_STORE_CALC,
            aContext, mPresContext, canStoreInRuleTree);
-  SetCoord(posData.mMaxWidth, pos->mMaxWidth, parentPos->mMaxWidth,
+  SetCoord(*aRuleData->ValueForMaxWidth(), pos->mMaxWidth, parentPos->mMaxWidth,
            SETCOORD_LPOEH | SETCOORD_INITIAL_NONE | SETCOORD_STORE_CALC,
            aContext, mPresContext, canStoreInRuleTree);
 
-  SetCoord(posData.mHeight, pos->mHeight, parentPos->mHeight,
+  SetCoord(*aRuleData->ValueForHeight(), pos->mHeight, parentPos->mHeight,
            SETCOORD_LPAH | SETCOORD_INITIAL_AUTO | SETCOORD_STORE_CALC,
            aContext, mPresContext, canStoreInRuleTree);
-  SetCoord(posData.mMinHeight, pos->mMinHeight, parentPos->mMinHeight,
+  SetCoord(*aRuleData->ValueForMinHeight(), pos->mMinHeight, parentPos->mMinHeight,
            SETCOORD_LPH | SETCOORD_INITIAL_ZERO | SETCOORD_STORE_CALC,
            aContext, mPresContext, canStoreInRuleTree);
-  SetCoord(posData.mMaxHeight, pos->mMaxHeight, parentPos->mMaxHeight,
+  SetCoord(*aRuleData->ValueForMaxHeight(), pos->mMaxHeight, parentPos->mMaxHeight,
            SETCOORD_LPOH | SETCOORD_INITIAL_NONE | SETCOORD_STORE_CALC,
            aContext, mPresContext, canStoreInRuleTree);
 
   // box-sizing: enum, inherit, initial
-  SetDiscrete(posData.mBoxSizing, pos->mBoxSizing, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForBoxSizing(),
+              pos->mBoxSizing, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentPos->mBoxSizing,
               NS_STYLE_BOX_SIZING_CONTENT, 0, 0, 0, 0);
 
   // z-index
-  if (! SetCoord(posData.mZIndex, pos->mZIndex, parentPos->mZIndex,
+  const nsCSSValue* zIndexValue = aRuleData->ValueForZIndex();
+  if (! SetCoord(*zIndexValue, pos->mZIndex, parentPos->mZIndex,
                  SETCOORD_IA | SETCOORD_INITIAL_AUTO, aContext,
                  nsnull, canStoreInRuleTree)) {
-    if (eCSSUnit_Inherit == posData.mZIndex.GetUnit()) {
+    if (eCSSUnit_Inherit == zIndexValue->GetUnit()) {
       // handle inherit, because it's ok to inherit 'auto' here
       canStoreInRuleTree = PR_FALSE;
       pos->mZIndex = parentPos->mZIndex;
     }
   }
 
   COMPUTE_END_RESET(Position, pos)
 }
 
 const void*
 nsRuleNode::ComputeTableData(void* aStartStruct,
-                             const nsRuleDataStruct& aData,
+                             const nsRuleData* aRuleData,
                              nsStyleContext* aContext,
                              nsRuleNode* aHighestNode,
                              const RuleDetail aRuleDetail,
                              const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Table, (), table, parentTable, Table, tableData)
 
   // table-layout: enum, inherit, initial
-  SetDiscrete(tableData.mLayout, table->mLayoutStrategy, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForTableLayout(),
+              table->mLayoutStrategy, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentTable->mLayoutStrategy,
               NS_STYLE_TABLE_LAYOUT_AUTO, 0, 0, 0, 0);
 
   // cols: enum, int (not a real CSS prop)
-  if (eCSSUnit_Enumerated == tableData.mCols.GetUnit() ||
-      eCSSUnit_Integer == tableData.mCols.GetUnit())
-    table->mCols = tableData.mCols.GetIntValue();
+  const nsCSSValue* colsValue = aRuleData->ValueForCols();
+  if (eCSSUnit_Enumerated == colsValue->GetUnit() ||
+      eCSSUnit_Integer == colsValue->GetUnit())
+    table->mCols = colsValue->GetIntValue();
 
   // span: pixels (not a real CSS prop)
-  if (eCSSUnit_Enumerated == tableData.mSpan.GetUnit() ||
-      eCSSUnit_Integer == tableData.mSpan.GetUnit())
-    table->mSpan = tableData.mSpan.GetIntValue();
+  const nsCSSValue* spanValue = aRuleData->ValueForSpan();
+  if (eCSSUnit_Enumerated == spanValue->GetUnit() ||
+      eCSSUnit_Integer == spanValue->GetUnit())
+    table->mSpan = spanValue->GetIntValue();
 
   COMPUTE_END_RESET(Table, table)
 }
 
 const void*
 nsRuleNode::ComputeTableBorderData(void* aStartStruct,
-                                   const nsRuleDataStruct& aData,
+                                   const nsRuleData* aRuleData,
                                    nsStyleContext* aContext,
                                    nsRuleNode* aHighestNode,
                                    const RuleDetail aRuleDetail,
                                    const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(TableBorder, (mPresContext), table, parentTable,
                           Table, tableData)
 
   // border-collapse: enum, inherit, initial
-  SetDiscrete(tableData.mBorderCollapse, table->mBorderCollapse,
+  SetDiscrete(*aRuleData->ValueForBorderCollapse(), table->mBorderCollapse,
               canStoreInRuleTree,
               SETDSC_ENUMERATED, parentTable->mBorderCollapse,
               NS_STYLE_BORDER_SEPARATE, 0, 0, 0, 0);
 
-  if (tableData.mBorderSpacing.GetUnit() != eCSSUnit_Null) {
+  const nsCSSValue* borderSpacingValue = aRuleData->ValueForBorderSpacing();
+  if (borderSpacingValue->GetUnit() != eCSSUnit_Null) {
     // border-spacing-x/y: length, inherit
     nsStyleCoord parentX(parentTable->mBorderSpacingX,
                          nsStyleCoord::CoordConstructor);
     nsStyleCoord parentY(parentTable->mBorderSpacingY,
                          nsStyleCoord::CoordConstructor);
     nsStyleCoord coordX, coordY;
 
 #ifdef DEBUG
     PRBool result =
 #endif
-      SetPairCoords(tableData.mBorderSpacing,
+      SetPairCoords(*borderSpacingValue,
                     coordX, coordY, parentX, parentY,
                     SETCOORD_LH | SETCOORD_INITIAL_ZERO |
                     SETCOORD_CALC_LENGTH_ONLY |
                     SETCOORD_CALC_CLAMP_NONNEGATIVE,
                     aContext, mPresContext, canStoreInRuleTree);
     NS_ASSERTION(result, "malformed table border value");
     table->mBorderSpacingX = coordX.GetCoordValue();
     table->mBorderSpacingY = coordY.GetCoordValue();
   }
 
   // caption-side: enum, inherit, initial
-  SetDiscrete(tableData.mCaptionSide, table->mCaptionSide, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForCaptionSide(),
+              table->mCaptionSide, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentTable->mCaptionSide,
               NS_STYLE_CAPTION_SIDE_TOP, 0, 0, 0, 0);
 
   // empty-cells: enum, inherit, initial
-  SetDiscrete(tableData.mEmptyCells, table->mEmptyCells, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForEmptyCells(),
+              table->mEmptyCells, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentTable->mEmptyCells,
               (mPresContext->CompatibilityMode() == eCompatibility_NavQuirks)
               ? NS_STYLE_TABLE_EMPTY_CELLS_SHOW_BACKGROUND
               : NS_STYLE_TABLE_EMPTY_CELLS_SHOW,
               0, 0, 0, 0);
 
   COMPUTE_END_INHERITED(TableBorder, table)
 }
 
 const void*
 nsRuleNode::ComputeContentData(void* aStartStruct,
-                               const nsRuleDataStruct& aData,
+                               const nsRuleData* aRuleData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
   PRUint32 count;
   nsAutoString buffer;
 
   COMPUTE_START_RESET(Content, (), content, parentContent,
                       Content, contentData)
 
   // content: [string, url, counter, attr, enum]+, normal, none, inherit
-  switch (contentData.mContent.GetUnit()) {
+  const nsCSSValue* contentValue = aRuleData->ValueForContent();
+  switch (contentValue->GetUnit()) {
   case eCSSUnit_Null:
     break;
 
   case eCSSUnit_Normal:
   case eCSSUnit_None:
   case eCSSUnit_Initial:
     // "normal", "none", and "initial" all mean no content
     content->AllocateContents(0);
@@ -5615,40 +5724,40 @@ nsRuleNode::ComputeContentData(void* aSt
     if (NS_SUCCEEDED(content->AllocateContents(count))) {
       while (0 < count--) {
         content->ContentAt(count) = parentContent->ContentAt(count);
       }
     }
     break;
 
   case eCSSUnit_Enumerated: {
-    NS_ABORT_IF_FALSE(contentData.mContent.GetIntValue() ==
+    NS_ABORT_IF_FALSE(contentValue->GetIntValue() ==
                       NS_STYLE_CONTENT_ALT_CONTENT,
                       "unrecognized solitary content keyword");
     content->AllocateContents(1);
     nsStyleContentData& data = content->ContentAt(0);
     data.mType = eStyleContentType_AltContent;
     data.mContent.mString = nsnull;
     break;
   }
 
   case eCSSUnit_List:
   case eCSSUnit_ListDep: {
-    const nsCSSValueList* contentValue = contentData.mContent.GetListValue();
+    const nsCSSValueList* contentValueList = contentValue->GetListValue();
       count = 0;
-      while (contentValue) {
+      while (contentValueList) {
         count++;
-        contentValue = contentValue->mNext;
+        contentValueList = contentValueList->mNext;
       }
       if (NS_SUCCEEDED(content->AllocateContents(count))) {
         const nsAutoString  nullStr;
         count = 0;
-        contentValue = contentData.mContent.GetListValue();
-        while (contentValue) {
-          const nsCSSValue& value = contentValue->mValue;
+        contentValueList = contentValue->GetListValue();
+        while (contentValueList) {
+          const nsCSSValue& value = contentValueList->mValue;
           nsCSSUnit unit = value.GetUnit();
           nsStyleContentType type;
           nsStyleContentData &data = content->ContentAt(count++);
           switch (unit) {
           case eCSSUnit_String:   type = eStyleContentType_String;    break;
           case eCSSUnit_Image:    type = eStyleContentType_Image;     break;
           case eCSSUnit_Attr:     type = eStyleContentType_Attr;      break;
           case eCSSUnit_Counter:  type = eStyleContentType_Counter;   break;
@@ -5680,30 +5789,32 @@ nsRuleNode::ComputeContentData(void* aSt
           }
           else if (type <= eStyleContentType_Counters) {
             data.mContent.mCounters = value.GetArrayValue();
             data.mContent.mCounters->AddRef();
           }
           else {
             data.mContent.mString = nsnull;
           }
-          contentValue = contentValue->mNext;
+          contentValueList = contentValueList->mNext;
         }
       }
       break;
   }
 
   default:
     NS_ABORT_IF_FALSE(false,
                       nsPrintfCString(64, "unrecognized content unit %d",
-                                      contentData.mContent.GetUnit()).get());
+                                      contentValue->GetUnit()).get());
   }
 
   // counter-increment: [string [int]]+, none, inherit
-  switch (contentData.mCounterIncrement.GetUnit()) {
+  const nsCSSValue* counterIncrementValue =
+    aRuleData->ValueForCounterIncrement();
+  switch (counterIncrementValue->GetUnit()) {
   case eCSSUnit_Null:
     break;
 
   case eCSSUnit_None:
   case eCSSUnit_Initial:
     content->AllocateCounterIncrements(0);
     break;
 
@@ -5717,17 +5828,17 @@ nsRuleNode::ComputeContentData(void* aSt
         content->SetCounterIncrementAt(count, data->mCounter, data->mValue);
       }
     }
     break;
 
   case eCSSUnit_PairList:
   case eCSSUnit_PairListDep: {
     const nsCSSValuePairList* ourIncrement =
-      contentData.mCounterIncrement.GetPairListValue();
+      counterIncrementValue->GetPairListValue();
     NS_ABORT_IF_FALSE(ourIncrement->mXValue.GetUnit() == eCSSUnit_Ident,
                       "unexpected value unit");
     count = ListLength(ourIncrement);
     if (NS_FAILED(content->AllocateCounterIncrements(count))) {
       break;
     }
 
     count = 0;
@@ -5744,17 +5855,18 @@ nsRuleNode::ComputeContentData(void* aSt
     break;
   }
 
   default:
     NS_ABORT_IF_FALSE(false, "unexpected value unit");
   }
 
   // counter-reset: [string [int]]+, none, inherit
-  switch (contentData.mCounterReset.GetUnit()) {
+  const nsCSSValue* counterResetValue = aRuleData->ValueForCounterReset();
+  switch (counterResetValue->GetUnit()) {
   case eCSSUnit_Null:
     break;
 
   case eCSSUnit_None:
   case eCSSUnit_Initial:
     content->AllocateCounterResets(0);
     break;
 
@@ -5768,17 +5880,17 @@ nsRuleNode::ComputeContentData(void* aSt
         content->SetCounterResetAt(count, data->mCounter, data->mValue);
       }
     }
     break;
 
   case eCSSUnit_PairList:
   case eCSSUnit_PairListDep: {
     const nsCSSValuePairList* ourReset =
-      contentData.mCounterReset.GetPairListValue();
+      counterResetValue->GetPairListValue();
     NS_ABORT_IF_FALSE(ourReset->mXValue.GetUnit() == eCSSUnit_Ident,
                       "unexpected value unit");
     count = ListLength(ourReset);
     if (NS_FAILED(content->AllocateCounterResets(count))) {
       break;
     }
 
     count = 0;
@@ -5795,17 +5907,17 @@ nsRuleNode::ComputeContentData(void* aSt
     break;
   }
 
   default:
     NS_ABORT_IF_FALSE(false, "unexpected value unit");
   }
 
   // marker-offset: length, auto, inherit
-  SetCoord(contentData.mMarkerOffset, content->mMarkerOffset, parentContent->mMarkerOffset,
+  SetCoord(*aRuleData->ValueForMarkerOffset(), content->mMarkerOffset, parentContent->mMarkerOffset,
            SETCOORD_LH | SETCOORD_AUTO | SETCOORD_INITIAL_AUTO |
              SETCOORD_CALC_LENGTH_ONLY,
            aContext, mPresContext, canStoreInRuleTree);
 
   // If we ended up with an image, track it.
   for (PRUint32 i = 0; i < content->ContentCount(); ++i) {
     if ((content->ContentAt(i).mType == eStyleContentType_Image) &&
         content->ContentAt(i).mContent.mImage) {
@@ -5813,43 +5925,44 @@ nsRuleNode::ComputeContentData(void* aSt
     }
   }
 
   COMPUTE_END_RESET(Content, content)
 }
 
 const void*
 nsRuleNode::ComputeQuotesData(void* aStartStruct,
-                              const nsRuleDataStruct& aData,
+                              const nsRuleData* aRuleData,
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Quotes, (), quotes, parentQuotes,
                           Content, contentData)
 
   // quotes: inherit, initial, none, [string string]+
-  switch (contentData.mQuotes.GetUnit()) {
+  const nsCSSValue* quotesValue = aRuleData->ValueForQuotes();
+  switch (quotesValue->GetUnit()) {
   case eCSSUnit_Null:
     break;
   case eCSSUnit_Inherit:
     canStoreInRuleTree = PR_FALSE;
     quotes->CopyFrom(*parentQuotes);
     break;
   case eCSSUnit_Initial:
     quotes->SetInitial();
     break;
   case eCSSUnit_None:
     quotes->AllocateQuotes(0);
     break;
   case eCSSUnit_PairList:
   case eCSSUnit_PairListDep: {
     const nsCSSValuePairList* ourQuotes
-      = contentData.mQuotes.GetPairListValue();
+      = quotesValue->GetPairListValue();
     nsAutoString buffer;
     nsAutoString closeBuffer;
     PRUint32 count = ListLength(ourQuotes);
     if (NS_FAILED(quotes->AllocateQuotes(count))) {
       break;
     }
     count = 0;
     while (ourQuotes) {
@@ -5867,110 +5980,118 @@ nsRuleNode::ComputeQuotesData(void* aSta
     NS_ABORT_IF_FALSE(false, "unexpected value unit");
   }
 
   COMPUTE_END_INHERITED(Quotes, quotes)
 }
 
 const void*
 nsRuleNode::ComputeXULData(void* aStartStruct,
-                           const nsRuleDataStruct& aData,
+                           const nsRuleData* aRuleData,
                            nsStyleContext* aContext,
                            nsRuleNode* aHighestNode,
                            const RuleDetail aRuleDetail,
                            const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(XUL, (), xul, parentXUL, XUL, xulData)
 
   // box-align: enum, inherit, initial
-  SetDiscrete(xulData.mBoxAlign, xul->mBoxAlign, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForBoxAlign(),
+              xul->mBoxAlign, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentXUL->mBoxAlign,
               NS_STYLE_BOX_ALIGN_STRETCH, 0, 0, 0, 0);
 
   // box-direction: enum, inherit, initial
-  SetDiscrete(xulData.mBoxDirection, xul->mBoxDirection, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForBoxDirection(),
+              xul->mBoxDirection, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentXUL->mBoxDirection,
               NS_STYLE_BOX_DIRECTION_NORMAL, 0, 0, 0, 0);
 
   // box-flex: factor, inherit
-  SetFactor(xulData.mBoxFlex, xul->mBoxFlex, canStoreInRuleTree,
+  SetFactor(*aRuleData->ValueForBoxFlex(),
+            xul->mBoxFlex, canStoreInRuleTree,
             parentXUL->mBoxFlex, 0.0f);
 
   // box-orient: enum, inherit, initial
-  SetDiscrete(xulData.mBoxOrient, xul->mBoxOrient, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForBoxOrient(),
+              xul->mBoxOrient, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentXUL->mBoxOrient,
               NS_STYLE_BOX_ORIENT_HORIZONTAL, 0, 0, 0, 0);
 
   // box-pack: enum, inherit, initial
-  SetDiscrete(xulData.mBoxPack, xul->mBoxPack, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForBoxPack(),
+              xul->mBoxPack, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentXUL->mBoxPack,
               NS_STYLE_BOX_PACK_START, 0, 0, 0, 0);
 
   // box-ordinal-group: integer, inherit, initial
-  SetDiscrete(xulData.mBoxOrdinal, xul->mBoxOrdinal, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForBoxOrdinalGroup(),
+              xul->mBoxOrdinal, canStoreInRuleTree,
               SETDSC_INTEGER, parentXUL->mBoxOrdinal, 1,
               0, 0, 0, 0);
 
-  if (eCSSUnit_Inherit == xulData.mStackSizing.GetUnit()) {
+  const nsCSSValue* stackSizingValue = aRuleData->ValueForStackSizing();
+  if (eCSSUnit_Inherit == stackSizingValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     xul->mStretchStack = parentXUL->mStretchStack;
-  } else if (eCSSUnit_Initial == xulData.mStackSizing.GetUnit()) {
+  } else if (eCSSUnit_Initial == stackSizingValue->GetUnit()) {
     xul->mStretchStack = PR_TRUE;
-  } else if (eCSSUnit_Enumerated == xulData.mStackSizing.GetUnit()) {
-    xul->mStretchStack = xulData.mStackSizing.GetIntValue() ==
+  } else if (eCSSUnit_Enumerated == stackSizingValue->GetUnit()) {
+    xul->mStretchStack = stackSizingValue->GetIntValue() ==
       NS_STYLE_STACK_SIZING_STRETCH_TO_FIT;
   }
 
   COMPUTE_END_RESET(XUL, xul)
 }
 
 const void*
 nsRuleNode::ComputeColumnData(void* aStartStruct,
-                              const nsRuleDataStruct& aData,
+                              const nsRuleData* aRuleData,
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Column, (mPresContext), column, parent, Column, columnData)
 
   // column-width: length, auto, inherit
-  SetCoord(columnData.mColumnWidth,
+  SetCoord(*aRuleData->ValueForColumnWidth(),
            column->mColumnWidth, parent->mColumnWidth,
            SETCOORD_LAH | SETCOORD_INITIAL_AUTO |
            SETCOORD_CALC_LENGTH_ONLY | SETCOORD_CALC_CLAMP_NONNEGATIVE,
            aContext, mPresContext, canStoreInRuleTree);
 
   // column-gap: length, inherit, normal
-  SetCoord(columnData.mColumnGap,
+  SetCoord(*aRuleData->ValueForColumnGap(),
            column->mColumnGap, parent->mColumnGap,
            SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL |
            SETCOORD_CALC_LENGTH_ONLY,
            aContext, mPresContext, canStoreInRuleTree);
   // clamp negative calc() to 0
   if (column->mColumnGap.GetUnit() == eStyleUnit_Coord) {
     column->mColumnGap.SetCoordValue(
       NS_MAX(column->mColumnGap.GetCoordValue(), 0));
   }
 
   // column-count: auto, integer, inherit
-  if (eCSSUnit_Auto == columnData.mColumnCount.GetUnit() ||
-      eCSSUnit_Initial == columnData.mColumnCount.GetUnit()) {
+  const nsCSSValue* columnCountValue = aRuleData->ValueForColumnCount();
+  if (eCSSUnit_Auto == columnCountValue->GetUnit() ||
+      eCSSUnit_Initial == columnCountValue->GetUnit()) {
     column->mColumnCount = NS_STYLE_COLUMN_COUNT_AUTO;
-  } else if (eCSSUnit_Integer == columnData.mColumnCount.GetUnit()) {
-    column->mColumnCount = columnData.mColumnCount.GetIntValue();
+  } else if (eCSSUnit_Integer == columnCountValue->GetUnit()) {
+    column->mColumnCount = columnCountValue->GetIntValue();
     // Max 1000 columns - wallpaper for bug 345583.
     column->mColumnCount = NS_MIN(column->mColumnCount, 1000U);
-  } else if (eCSSUnit_Inherit == columnData.mColumnCount.GetUnit()) {
+  } else if (eCSSUnit_Inherit == columnCountValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     column->mColumnCount = parent->mColumnCount;
   }
 
   // column-rule-width: length, enum, inherit
-  const nsCSSValue& widthValue = columnData.mColumnRuleWidth;
+  const nsCSSValue& widthValue = *aRuleData->ValueForColumnRuleWidth();
   if (eCSSUnit_Initial == widthValue.GetUnit()) {
     column->SetColumnRuleWidth(
         (mPresContext->GetBorderWidthTable())[NS_STYLE_BORDER_WIDTH_MEDIUM]);
   }
   else if (eCSSUnit_Enumerated == widthValue.GetUnit()) {
     NS_ASSERTION(widthValue.GetIntValue() == NS_STYLE_BORDER_WIDTH_THIN ||
                  widthValue.GetIntValue() == NS_STYLE_BORDER_WIDTH_MEDIUM ||
                  widthValue.GetIntValue() == NS_STYLE_BORDER_WIDTH_THICK,
@@ -5992,32 +6113,32 @@ nsRuleNode::ComputeColumnData(void* aSta
       NS_ASSERTION(widthValue.IsCalcUnit(),
                    "parser should have rejected negative length");
       len = 0;
     }
     column->SetColumnRuleWidth(len);
   }
 
   // column-rule-style: enum, inherit
-  const nsCSSValue& styleValue = columnData.mColumnRuleStyle;
+  const nsCSSValue& styleValue = *aRuleData->ValueForColumnRuleStyle();
   NS_ABORT_IF_FALSE(eCSSUnit_None != styleValue.GetUnit(),
                     "'none' should be handled as enumerated value");
   if (eCSSUnit_Enumerated == styleValue.GetUnit()) {
     column->mColumnRuleStyle = styleValue.GetIntValue();
   }
   else if (eCSSUnit_Initial == styleValue.GetUnit()) {
     column->mColumnRuleStyle = NS_STYLE_BORDER_STYLE_NONE;
   }
   else if (eCSSUnit_Inherit == styleValue.GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     column->mColumnRuleStyle = parent->mColumnRuleStyle;
   }
 
   // column-rule-color: color, inherit
-  const nsCSSValue& colorValue = columnData.mColumnRuleColor;
+  const nsCSSValue& colorValue = *aRuleData->ValueForColumnRuleColor();
   if (eCSSUnit_Inherit == colorValue.GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     column->mColumnRuleColorIsForeground = PR_FALSE;
     if (parent->mColumnRuleColorIsForeground) {
       column->mColumnRuleColor = parentContext->GetStyleColor()->mColor;
     } else {
       column->mColumnRuleColor = parent->mColumnRuleColor;
     }
@@ -6075,103 +6196,114 @@ SetSVGPaint(const nsCSSValue& aValue, co
   } else {
     NS_ABORT_IF_FALSE(aValue.GetUnit() == eCSSUnit_Null,
                       "malformed paint server value");
   }
 }
 
 const void*
 nsRuleNode::ComputeSVGData(void* aStartStruct,
-                           const nsRuleDataStruct& aData,
+                           const nsRuleData* aRuleData,
                            nsStyleContext* aContext,
                            nsRuleNode* aHighestNode,
                            const RuleDetail aRuleDetail,
                            const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(SVG, (), svg, parentSVG, SVG, SVGData)
 
   // clip-rule: enum, inherit, initial
-  SetDiscrete(SVGData.mClipRule, svg->mClipRule, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForClipRule(),
+              svg->mClipRule, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mClipRule,
               NS_STYLE_FILL_RULE_NONZERO, 0, 0, 0, 0);
 
   // color-interpolation: enum, inherit, initial
-  SetDiscrete(SVGData.mColorInterpolation,
+  SetDiscrete(*aRuleData->ValueForColorInterpolation(),
               svg->mColorInterpolation, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mColorInterpolation,
               NS_STYLE_COLOR_INTERPOLATION_SRGB, 0, 0, 0, 0);
 
   // color-interpolation-filters: enum, inherit, initial
-  SetDiscrete(SVGData.mColorInterpolationFilters,
+  SetDiscrete(*aRuleData->ValueForColorInterpolationFilters(),
               svg->mColorInterpolationFilters, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mColorInterpolationFilters,
               NS_STYLE_COLOR_INTERPOLATION_LINEARRGB, 0, 0, 0, 0);
 
   // fill:
-  SetSVGPaint(SVGData.mFill, parentSVG->mFill, mPresContext, aContext,
+  SetSVGPaint(*aRuleData->ValueForFill(),
+              parentSVG->mFill, mPresContext, aContext,
               svg->mFill, eStyleSVGPaintType_Color, canStoreInRuleTree);
 
   // fill-opacity: factor, inherit, initial
-  SetFactor(SVGData.mFillOpacity, svg->mFillOpacity, canStoreInRuleTree,
+  SetFactor(*aRuleData->ValueForFillOpacity(),
+            svg->mFillOpacity, canStoreInRuleTree,
             parentSVG->mFillOpacity, 1.0f, SETFCT_OPACITY);
 
   // fill-rule: enum, inherit, initial
-  SetDiscrete(SVGData.mFillRule, svg->mFillRule, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForFillRule(),
+              svg->mFillRule, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mFillRule,
               NS_STYLE_FILL_RULE_NONZERO, 0, 0, 0, 0);
 
   // image-rendering: enum, inherit
-  SetDiscrete(SVGData.mImageRendering, svg->mImageRendering, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForImageRendering(),
+              svg->mImageRendering, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mImageRendering,
               NS_STYLE_IMAGE_RENDERING_AUTO, 0, 0, 0, 0);
 
   // marker-end: url, none, inherit
-  if (eCSSUnit_URL == SVGData.mMarkerEnd.GetUnit()) {
-    svg->mMarkerEnd = SVGData.mMarkerEnd.GetURLValue();
-  } else if (eCSSUnit_None == SVGData.mMarkerEnd.GetUnit() ||
-             eCSSUnit_Initial == SVGData.mMarkerEnd.GetUnit()) {
+  const nsCSSValue* markerEndValue = aRuleData->ValueForMarkerEnd();
+  if (eCSSUnit_URL == markerEndValue->GetUnit()) {
+    svg->mMarkerEnd = markerEndValue->GetURLValue();
+  } else if (eCSSUnit_None == markerEndValue->GetUnit() ||
+             eCSSUnit_Initial == markerEndValue->GetUnit()) {
     svg->mMarkerEnd = nsnull;
-  } else if (eCSSUnit_Inherit == SVGData.mMarkerEnd.GetUnit()) {
+  } else if (eCSSUnit_Inherit == markerEndValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     svg->mMarkerEnd = parentSVG->mMarkerEnd;
   }
 
   // marker-mid: url, none, inherit
-  if (eCSSUnit_URL == SVGData.mMarkerMid.GetUnit()) {
-    svg->mMarkerMid = SVGData.mMarkerMid.GetURLValue();
-  } else if (eCSSUnit_None == SVGData.mMarkerMid.GetUnit() ||
-             eCSSUnit_Initial == SVGData.mMarkerMid.GetUnit()) {
+  const nsCSSValue* markerMidValue = aRuleData->ValueForMarkerMid();
+  if (eCSSUnit_URL == markerMidValue->GetUnit()) {
+    svg->mMarkerMid = markerMidValue->GetURLValue();
+  } else if (eCSSUnit_None == markerMidValue->GetUnit() ||
+             eCSSUnit_Initial == markerMidValue->GetUnit()) {
     svg->mMarkerMid = nsnull;
-  } else if (eCSSUnit_Inherit == SVGData.mMarkerMid.GetUnit()) {
+  } else if (eCSSUnit_Inherit == markerMidValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     svg->mMarkerMid = parentSVG->mMarkerMid;
   }
 
   // marker-start: url, none, inherit
-  if (eCSSUnit_URL == SVGData.mMarkerStart.GetUnit()) {
-    svg->mMarkerStart = SVGData.mMarkerStart.GetURLValue();
-  } else if (eCSSUnit_None == SVGData.mMarkerStart.GetUnit() ||
-             eCSSUnit_Initial == SVGData.mMarkerStart.GetUnit()) {
+  const nsCSSValue* markerStartValue = aRuleData->ValueForMarkerStart();
+  if (eCSSUnit_URL == markerStartValue->GetUnit()) {
+    svg->mMarkerStart = markerStartValue->GetURLValue();
+  } else if (eCSSUnit_None == markerStartValue->GetUnit() ||
+             eCSSUnit_Initial == markerStartValue->GetUnit()) {
     svg->mMarkerStart = nsnull;
-  } else if (eCSSUnit_Inherit == SVGData.mMarkerStart.GetUnit()) {
+  } else if (eCSSUnit_Inherit == markerStartValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     svg->mMarkerStart = parentSVG->mMarkerStart;
   }
 
   // shape-rendering: enum, inherit
-  SetDiscrete(SVGData.mShapeRendering, svg->mShapeRendering, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForShapeRendering(),
+              svg->mShapeRendering, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mShapeRendering,
               NS_STYLE_SHAPE_RENDERING_AUTO, 0, 0, 0, 0);
 
   // stroke:
-  SetSVGPaint(SVGData.mStroke, parentSVG->mStroke, mPresContext, aContext,
+  SetSVGPaint(*aRuleData->ValueForStroke(),
+              parentSVG->mStroke, mPresContext, aContext,
               svg->mStroke, eStyleSVGPaintType_None, canStoreInRuleTree);
 
   // stroke-dasharray: <dasharray>, none, inherit
-  switch (SVGData.mStrokeDasharray.GetUnit()) {
+  const nsCSSValue* strokeDasharrayValue = aRuleData->ValueForStrokeDasharray();
+  switch (strokeDasharrayValue->GetUnit()) {
   case eCSSUnit_Null:
     break;
 
   case eCSSUnit_Inherit:
     canStoreInRuleTree = PR_FALSE;
     // only do the copy if weren't already set up by the copy constructor
     // FIXME Bug 389408: This is broken when aStartStruct is non-null!
     if (!svg->mStrokeDasharray) {
@@ -6197,17 +6329,17 @@ nsRuleNode::ComputeSVGData(void* aStartS
 
   case eCSSUnit_List:
   case eCSSUnit_ListDep: {
     delete [] svg->mStrokeDasharray;
     svg->mStrokeDasharray = nsnull;
     svg->mStrokeDasharrayLength = 0;
 
     // count number of values
-    const nsCSSValueList *value = SVGData.mStrokeDasharray.GetListValue();
+    const nsCSSValueList *value = strokeDasharrayValue->GetListValue();
     svg->mStrokeDasharrayLength = ListLength(value);
 
     NS_ASSERTION(svg->mStrokeDasharrayLength != 0, "no dasharray items");
 
     svg->mStrokeDasharray = new nsStyleCoord[svg->mStrokeDasharrayLength];
 
     if (svg->mStrokeDasharray) {
       PRUint32 i = 0;
@@ -6224,141 +6356,157 @@ nsRuleNode::ComputeSVGData(void* aStartS
     break;
   }
 
   default:
     NS_ABORT_IF_FALSE(false, "unrecognized dasharray unit");
   }
 
   // stroke-dashoffset: <dashoffset>, inherit
-  SetCoord(SVGData.mStrokeDashoffset,
+  SetCoord(*aRuleData->ValueForStrokeDashoffset(),
            svg->mStrokeDashoffset, parentSVG->mStrokeDashoffset,
            SETCOORD_LPH | SETCOORD_FACTOR | SETCOORD_INITIAL_ZERO,
            aContext, mPresContext, canStoreInRuleTree);
 
   // stroke-linecap: enum, inherit, initial
-  SetDiscrete(SVGData.mStrokeLinecap, svg->mStrokeLinecap, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForStrokeLinecap(),
+              svg->mStrokeLinecap, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mStrokeLinecap,
               NS_STYLE_STROKE_LINECAP_BUTT, 0, 0, 0, 0);
 
   // stroke-linejoin: enum, inherit, initial
-  SetDiscrete(SVGData.mStrokeLinejoin, svg->mStrokeLinejoin, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForStrokeLinejoin(),
+              svg->mStrokeLinejoin, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mStrokeLinejoin,
               NS_STYLE_STROKE_LINEJOIN_MITER, 0, 0, 0, 0);
 
   // stroke-miterlimit: <miterlimit>, inherit
-  SetFactor(SVGData.mStrokeMiterlimit, svg->mStrokeMiterlimit,
+  SetFactor(*aRuleData->ValueForStrokeMiterlimit(),
+            svg->mStrokeMiterlimit,
             canStoreInRuleTree,
             parentSVG->mStrokeMiterlimit, 4.0f);
 
   // stroke-opacity:
-  SetFactor(SVGData.mStrokeOpacity, svg->mStrokeOpacity, canStoreInRuleTree,
+  SetFactor(*aRuleData->ValueForStrokeOpacity(),
+            svg->mStrokeOpacity, canStoreInRuleTree,
             parentSVG->mStrokeOpacity, 1.0f, SETFCT_OPACITY);
 
   // stroke-width:
-  if (eCSSUnit_Initial == SVGData.mStrokeWidth.GetUnit()) {
+  const nsCSSValue* strokeWidthValue = aRuleData->ValueForStrokeWidth();
+  if (eCSSUnit_Initial == strokeWidthValue->GetUnit()) {
     svg->mStrokeWidth.SetCoordValue(nsPresContext::CSSPixelsToAppUnits(1));
   } else {
-    SetCoord(SVGData.mStrokeWidth,
+    SetCoord(*strokeWidthValue,
              svg->mStrokeWidth, parentSVG->mStrokeWidth,
              SETCOORD_LPH | SETCOORD_FACTOR,
              aContext, mPresContext, canStoreInRuleTree);
   }
 
   // text-anchor: enum, inherit, initial
-  SetDiscrete(SVGData.mTextAnchor, svg->mTextAnchor, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForTextAnchor(),
+              svg->mTextAnchor, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mTextAnchor,
               NS_STYLE_TEXT_ANCHOR_START, 0, 0, 0, 0);
 
   // text-rendering: enum, inherit, initial
-  SetDiscrete(SVGData.mTextRendering, svg->mTextRendering, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForTextRendering(),
+              svg->mTextRendering, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mTextRendering,
               NS_STYLE_TEXT_RENDERING_AUTO, 0, 0, 0, 0);
 
   COMPUTE_END_INHERITED(SVG, svg)
 }
 
 const void*
 nsRuleNode::ComputeSVGResetData(void* aStartStruct,
-                                const nsRuleDataStruct& aData,
+                                const nsRuleData* aRuleData,
                                 nsStyleContext* aContext,
                                 nsRuleNode* aHighestNode,
                                 const RuleDetail aRuleDetail,
                                 const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(SVGReset, (), svgReset, parentSVGReset, SVG, SVGData)
 
   // stop-color:
-  if (eCSSUnit_Initial == SVGData.mStopColor.GetUnit()) {
+  const nsCSSValue* stopColorValue = aRuleData->ValueForStopColor();
+  if (eCSSUnit_Initial == stopColorValue->GetUnit()) {
     svgReset->mStopColor = NS_RGB(0, 0, 0);
   } else {
-    SetColor(SVGData.mStopColor, parentSVGReset->mStopColor,
+    SetColor(*stopColorValue, parentSVGReset->mStopColor,
              mPresContext, aContext, svgReset->mStopColor, canStoreInRuleTree);
   }
 
   // flood-color:
-  if (eCSSUnit_Initial == SVGData.mFloodColor.GetUnit()) {
+  const nsCSSValue* floodColorValue = aRuleData->ValueForFloodColor();
+  if (eCSSUnit_Initial == floodColorValue->GetUnit()) {
     svgReset->mFloodColor = NS_RGB(0, 0, 0);
   } else {
-    SetColor(SVGData.mFloodColor, parentSVGReset->mFloodColor,
+    SetColor(*floodColorValue, parentSVGReset->mFloodColor,
              mPresContext, aContext, svgReset->mFloodColor, canStoreInRuleTree);
   }
 
   // lighting-color:
-  if (eCSSUnit_Initial == SVGData.mLightingColor.GetUnit()) {
+  const nsCSSValue* lightingColorValue = aRuleData->ValueForLightingColor();
+  if (eCSSUnit_Initial == lightingColorValue->GetUnit()) {
     svgReset->mLightingColor = NS_RGB(255, 255, 255);
   } else {
-    SetColor(SVGData.mLightingColor, parentSVGReset->mLightingColor,
+    SetColor(*lightingColorValue, parentSVGReset->mLightingColor,
              mPresContext, aContext, svgReset->mLightingColor,
              canStoreInRuleTree);
   }
 
   // clip-path: url, none, inherit
-  if (eCSSUnit_URL == SVGData.mClipPath.GetUnit()) {
-    svgReset->mClipPath = SVGData.mClipPath.GetURLValue();
-  } else if (eCSSUnit_None == SVGData.mClipPath.GetUnit() ||
-             eCSSUnit_Initial == SVGData.mClipPath.GetUnit()) {
+  const nsCSSValue* clipPathValue = aRuleData->ValueForClipPath();
+  if (eCSSUnit_URL == clipPathValue->GetUnit()) {
+    svgReset->mClipPath = clipPathValue->GetURLValue();
+  } else if (eCSSUnit_None == clipPathValue->GetUnit() ||
+             eCSSUnit_Initial == clipPathValue->GetUnit()) {
     svgReset->mClipPath = nsnull;
-  } else if (eCSSUnit_Inherit == SVGData.mClipPath.GetUnit()) {
+  } else if (eCSSUnit_Inherit == clipPathValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     svgReset->mClipPath = parentSVGReset->mClipPath;
   }
 
   // stop-opacity:
-  SetFactor(SVGData.mStopOpacity, svgReset->mStopOpacity, canStoreInRuleTree,
+  SetFactor(*aRuleData->ValueForStopOpacity(),
+            svgReset->mStopOpacity, canStoreInRuleTree,
             parentSVGReset->mStopOpacity, 1.0f, SETFCT_OPACITY);
 
   // flood-opacity:
-  SetFactor(SVGData.mFloodOpacity, svgReset->mFloodOpacity, canStoreInRuleTree,
+  SetFactor(*aRuleData->ValueForFloodOpacity(),
+            svgReset->mFloodOpacity, canStoreInRuleTree,
             parentSVGReset->mFloodOpacity, 1.0f, SETFCT_OPACITY);
 
   // dominant-baseline: enum, inherit, initial
-  SetDiscrete(SVGData.mDominantBaseline, svgReset->mDominantBaseline,
+  SetDiscrete(*aRuleData->ValueForDominantBaseline(),
+              svgReset->mDominantBaseline,
               canStoreInRuleTree, SETDSC_ENUMERATED,
               parentSVGReset->mDominantBaseline,
               NS_STYLE_DOMINANT_BASELINE_AUTO, 0, 0, 0, 0);
 
   // filter: url, none, inherit
-  if (eCSSUnit_URL == SVGData.mFilter.GetUnit()) {
-    svgReset->mFilter = SVGData.mFilter.GetURLValue();
-  } else if (eCSSUnit_None == SVGData.mFilter.GetUnit() ||
-             eCSSUnit_Initial == SVGData.mFilter.GetUnit()) {
+  const nsCSSValue* filterValue = aRuleData->ValueForFilter();
+  if (eCSSUnit_URL == filterValue->GetUnit()) {
+    svgReset->mFilter = filterValue->GetURLValue();
+  } else if (eCSSUnit_None == filterValue->GetUnit() ||
+             eCSSUnit_Initial == filterValue->GetUnit()) {
     svgReset->mFilter = nsnull;
-  } else if (eCSSUnit_Inherit == SVGData.mFilter.GetUnit()) {
+  } else if (eCSSUnit_Inherit == filterValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     svgReset->mFilter = parentSVGReset->mFilter;
   }
 
   // mask: url, none, inherit
-  if (eCSSUnit_URL == SVGData.mMask.GetUnit()) {
-    svgReset->mMask = SVGData.mMask.GetURLValue();
-  } else if (eCSSUnit_None == SVGData.mMask.GetUnit() ||
-             eCSSUnit_Initial == SVGData.mMask.GetUnit()) {
+  const nsCSSValue* maskValue = aRuleData->ValueForMask();
+  if (eCSSUnit_URL == maskValue->GetUnit()) {
+    svgReset->mMask = maskValue->GetURLValue();
+  } else if (eCSSUnit_None == maskValue->GetUnit() ||
+             eCSSUnit_Initial == maskValue->GetUnit()) {
     svgReset->mMask = nsnull;
-  } else if (eCSSUnit_Inherit == SVGData.mMask.GetUnit()) {
+  } else if (eCSSUnit_Inherit == maskValue->GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     svgReset->mMask = parentSVGReset->mMask;
   }
 
   COMPUTE_END_RESET(SVGReset, svgReset)
 }
 
 inline const void*
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -459,194 +459,194 @@ protected:
                                nsStyleContext* aContext);
 
   const void*
     WalkRuleTree(const nsStyleStructID aSID, nsStyleContext* aContext,
                  nsRuleData* aRuleData, nsRuleDataStruct* aSpecificData);
 
   const void*
     ComputeDisplayData(void* aStartStruct,
-                       const nsRuleDataStruct& aData,
+                       const nsRuleData* aRuleData,
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
                        RuleDetail aRuleDetail,
                        const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeVisibilityData(void* aStartStruct,
-                          const nsRuleDataStruct& aData,
+                          const nsRuleData* aRuleData,
                           nsStyleContext* aContext, nsRuleNode* aHighestNode,
                           RuleDetail aRuleDetail,
                           const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeFontData(void* aStartStruct,
-                    const nsRuleDataStruct& aData,
+                    const nsRuleData* aRuleData,
                     nsStyleContext* aContext, nsRuleNode* aHighestNode,
                     RuleDetail aRuleDetail,
                     const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeColorData(void* aStartStruct,
-                     const nsRuleDataStruct& aData,
+                     const nsRuleData* aRuleData,
                      nsStyleContext* aContext, nsRuleNode* aHighestNode,
                      RuleDetail aRuleDetail,
                      const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeBackgroundData(void* aStartStruct,
-                          const nsRuleDataStruct& aData,
+                          const nsRuleData* aRuleData,
                           nsStyleContext* aContext, nsRuleNode* aHighestNode,
                           RuleDetail aRuleDetail,
                           const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeMarginData(void* aStartStruct,
-                      const nsRuleDataStruct& aData,
+                      const nsRuleData* aRuleData,
                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
                       RuleDetail aRuleDetail,
                       const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeBorderData(void* aStartStruct,
-                      const nsRuleDataStruct& aData,
+                      const nsRuleData* aRuleData,
                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
                       RuleDetail aRuleDetail,
                       const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputePaddingData(void* aStartStruct,
-                       const nsRuleDataStruct& aData,
+                       const nsRuleData* aRuleData,
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
                        RuleDetail aRuleDetail,
                        const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeOutlineData(void* aStartStruct,
-                       const nsRuleDataStruct& aData,
+                       const nsRuleData* aRuleData,
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
                        RuleDetail aRuleDetail,
                        const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeListData(void* aStartStruct,
-                    const nsRuleDataStruct& aData,
+                    const nsRuleData* aRuleData,
                     nsStyleContext* aContext, nsRuleNode* aHighestNode,
                     RuleDetail aRuleDetail,
                     const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputePositionData(void* aStartStruct,
-                        const nsRuleDataStruct& aData,
+                        const nsRuleData* aRuleData,
                         nsStyleContext* aContext, nsRuleNode* aHighestNode,
                         RuleDetail aRuleDetail,
                         const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeTableData(void* aStartStruct,
-                     const nsRuleDataStruct& aData,
+                     const nsRuleData* aRuleData,
                      nsStyleContext* aContext, nsRuleNode* aHighestNode,
                      RuleDetail aRuleDetail,
                      const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeTableBorderData(void* aStartStruct,
-                           const nsRuleDataStruct& aData,
+                           const nsRuleData* aRuleData,
                            nsStyleContext* aContext, nsRuleNode* aHighestNode,
                            RuleDetail aRuleDetail,
                            const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeContentData(void* aStartStruct,
-                       const nsRuleDataStruct& aData,
+                       const nsRuleData* aRuleData,
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
                        RuleDetail aRuleDetail,
                        const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeQuotesData(void* aStartStruct,
-                      const nsRuleDataStruct& aData,
+                      const nsRuleData* aRuleData,
                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
                       RuleDetail aRuleDetail,
                       const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeTextData(void* aStartStruct,
-                    const nsRuleDataStruct& aData,
+                    const nsRuleData* aRuleData,
                     nsStyleContext* aContext, nsRuleNode* aHighestNode,
                     RuleDetail aRuleDetail,
                     const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeTextResetData(void* aStartStruct,
-                         const nsRuleDataStruct& aData,
+                         const nsRuleData* aRuleData,
                          nsStyleContext* aContext, nsRuleNode* aHighestNode,
                          RuleDetail aRuleDetail,
                          const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeUserInterfaceData(void* aStartStruct,
-                             const nsRuleDataStruct& aData,
+                             const nsRuleData* aRuleData,
                              nsStyleContext* aContext,
                              nsRuleNode* aHighestNode,
                              RuleDetail aRuleDetail,
                              const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeUIResetData(void* aStartStruct,
-                       const nsRuleDataStruct& aData,
+                       const nsRuleData* aRuleData,
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
                        RuleDetail aRuleDetail,
                        const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeXULData(void* aStartStruct,
-                   const nsRuleDataStruct& aData,
+                   const nsRuleData* aRuleData,
                    nsStyleContext* aContext, nsRuleNode* aHighestNode,
                    RuleDetail aRuleDetail,
                    const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeColumnData(void* aStartStruct,
-                      const nsRuleDataStruct& aData,
+                      const nsRuleData* aRuleData,
                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
                       RuleDetail aRuleDetail,
                       const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeSVGData(void* aStartStruct,
-                   const nsRuleDataStruct& aData,
+                   const nsRuleData* aRuleData,
                    nsStyleContext* aContext, nsRuleNode* aHighestNode,
                    RuleDetail aRuleDetail,
                    const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeSVGResetData(void* aStartStruct,
-                        const nsRuleDataStruct& aData,
+                        const nsRuleData* aRuleData,
                         nsStyleContext* aContext, nsRuleNode* aHighestNode,
                         RuleDetail aRuleDetail,
                         const PRBool aCanStoreInRuleTree);
 
   // helpers for |ComputeFontData| that need access to |mNoneBits|:
   static void SetFontSize(nsPresContext* aPresContext,
-                          const nsRuleDataFont& aFontData,
+                          const nsRuleData* aRuleData,
                           const nsStyleFont* aFont,
                           const nsStyleFont* aParentFont,
                           nscoord* aSize,
                           const nsFont& aSystemFont,
                           nscoord aParentSize,
                           nscoord aScriptLevelAdjustedParentSize,
                           PRBool aUsedStartStruct,
                           PRBool aAtRoot,
                           PRBool& aCanStoreInRuleTree);
 
   static void SetFont(nsPresContext* aPresContext,
                       nsStyleContext* aContext,
                       nscoord aMinFontSize,
                       PRUint8 aGenericFontID,
-                      const nsRuleDataFont& aFontData,
+                      const nsRuleData* aRuleData,
                       const nsStyleFont* aParentFont,
                       nsStyleFont* aFont,
                       PRBool aStartStruct,
                       PRBool& aCanStoreInRuleTree);
 
   static void SetGenericFont(nsPresContext* aPresContext,
                              nsStyleContext* aContext,
                              PRUint8 aGenericFontID,
