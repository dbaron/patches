Make non-box frames use nsITheme methods concerning size, border, and padding, so that non-boxes with appearance set will obey the platform-specific theme.

diff -r ac7a6f9ee674 gfx/public/nsITheme.h
--- a/gfx/public/nsITheme.h	Thu Jan 11 18:57:45 2007 -0800
+++ b/gfx/public/nsITheme.h	Thu Jan 11 20:06:48 2007 -0800
@@ -36,6 +36,8 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
+/* service providing platform-specific native rendering for widgets */
+
 #ifndef nsITheme_h_
 #define nsITheme_h_
 
@@ -63,6 +65,16 @@ class nsIAtom;
 #define NS_THEMERENDERER_CID \
 { 0xd930e29b, 0x6909, 0x44e5, { 0xab, 0x4b, 0xaf, 0x10, 0xd6, 0x92, 0x37, 0x5 } }
 
+/**
+ * nsITheme is a service that provides platform-specific native
+ * rendering for widgets.  In other words, it provides the necessary
+ * operations to draw a rendering object (an nsIFrame) as a native
+ * widget.
+ *
+ * All the methods on nsITheme take a rendering context or device
+ * context, a frame (the rendering object), and a widget type (one of
+ * the constants in nsThemeConstants.h).
+ */
 class nsITheme: public nsISupports {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ITHEME_IID)
@@ -95,7 +107,14 @@ public:
                                    nsRect* aResult)
   { return PR_FALSE; }
 
-  NS_IMETHOD GetMinimumWidgetSize(nsIRenderingContext* aContext, nsIFrame* aFrame,
+  /**
+   * Get the minimum border-box size of a widget, in *pixels* (in
+   * |aResult|).  If |aIsOverridable| is set to true, this size is a
+   * minimum size; if false, this size is the only valid size for the
+   * widget.
+   */
+  NS_IMETHOD GetMinimumWidgetSize(nsIRenderingContext* aContext,
+                                  nsIFrame* aFrame,
                                   PRUint8 aWidgetType,
                                   nsSize* aResult,
                                   PRBool* aIsOverridable)=0;
diff -r ac7a6f9ee674 layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp	Thu Jan 11 18:57:45 2007 -0800
+++ b/layout/base/nsLayoutUtils.cpp	Thu Jan 11 20:30:58 2007 -0800
@@ -1263,6 +1263,27 @@ nsLayoutUtils::IntrinsicForContainer(nsI
   if (result < min)
     result = min;
 
+  const nsStyleDisplay *disp = aFrame->GetStyleDisplay();
+  if (aFrame->IsThemed(disp)) {
+    nsSize size(0, 0);
+    PRBool canOverride = PR_TRUE;
+    nsPresContext *presContext = aFrame->GetPresContext();
+    presContext->GetTheme()->
+      GetMinimumWidgetSize(aRenderingContext, aFrame, disp->mAppearance,
+                           &size, &canOverride);
+
+    // GMWS() returns size in pixels, we need to convert it back to twips
+    float p2t = presContext->ScaledPixelsToTwips();
+    nscoord themeWidth = NSIntPixelsToTwips(size.width, p2t);
+
+    // GMWS() returns a border-box width
+    themeWidth += offsets.hMargin;
+    themeWidth = AddPercents(aType, themeWidth, offsets.hPctMargin);
+
+    if (themeWidth > result || !canOverride)
+      result = themeWidth;
+  }
+
 #ifdef DEBUG_INTRINSIC_WIDTH
   nsFrame::IndentBy(stdout, gNoiseIndent);
   NS_STATIC_CAST(nsFrame*, aFrame)->ListTag(stdout);
diff -r ac7a6f9ee674 layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp	Thu Jan 11 18:57:45 2007 -0800
+++ b/layout/generic/nsFrame.cpp	Thu Jan 11 20:33:46 2007 -0800
@@ -3085,9 +3085,6 @@ nsFrame::ComputeSize(nsIRenderingContext
   if (minWidth > result.width)
     result.width = minWidth;
 
-  if (result.width < 0)
-    result.width = 0;
-
   // Compute height
 
   if (!IsAutoHeight(stylePos->mHeight, aCBSize.height)) {
@@ -3116,6 +3113,33 @@ nsFrame::ComputeSize(nsIRenderingContext
         result.height = minHeight;
     }
   }
+
+  const nsStyleDisplay *disp = GetStyleDisplay();
+  if (IsThemed(disp)) {
+    nsSize size(0, 0);
+    PRBool canOverride = PR_TRUE;
+    nsPresContext *presContext = GetPresContext();
+    presContext->GetTheme()->
+      GetMinimumWidgetSize(aRenderingContext, this, disp->mAppearance,
+                           &size, &canOverride);
+
+    // GMWS() returns size in pixels, we need to convert it back to twips
+    float p2t = presContext->ScaledPixelsToTwips();
+    size.width = NSIntPixelsToTwips(size.width, p2t);
+    size.height = NSIntPixelsToTwips(size.height, p2t);
+
+    // GMWS() returns border-box; we need content-box
+    size.width -= aBorder.width + aPadding.width;
+    size.height -= aBorder.height + aPadding.height;
+
+    if (size.height > result.height || !canOverride)
+      result.height = size.height;
+    if (size.width > result.width || !canOverride)
+      result.width = size.width;
+  }
+
+  if (result.width < 0)
+    result.width = 0;
 
   if (result.height < 0)
     result.height = 0;
diff -r ac7a6f9ee674 layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp	Thu Jan 11 18:57:45 2007 -0800
+++ b/layout/generic/nsHTMLReflowState.cpp	Thu Jan 11 20:30:18 2007 -0800
@@ -1666,7 +1666,22 @@ nsCSSOffsetState::InitOffsets(nscoord aC
   // XXX fix to provide 0,0 for the top&bottom margins for
   // inline-non-replaced elements
   ComputeMargin(aContainingBlockWidth);
-  if (aPadding) { // padding is an input arg
+
+  const nsStyleDisplay *disp = frame->GetStyleDisplay();
+  PRBool isThemed = frame->IsThemed(disp);
+  nsPresContext *presContext = frame->GetPresContext();
+
+  if (isThemed &&
+      presContext->GetTheme()->GetWidgetPadding(presContext->DeviceContext(),
+                                                frame, disp->mAppearance,
+                                                &mComputedPadding)) {
+    float p2t = presContext->ScaledPixelsToTwips();
+    mComputedPadding.top = NSIntPixelsToTwips(mComputedPadding.top, p2t);
+    mComputedPadding.right = NSIntPixelsToTwips(mComputedPadding.right, p2t);
+    mComputedPadding.bottom = NSIntPixelsToTwips(mComputedPadding.bottom, p2t);
+    mComputedPadding.left = NSIntPixelsToTwips(mComputedPadding.left, p2t);
+  }
+  else if (aPadding) { // padding is an input arg
     mComputedPadding.top    = aPadding->top;
     mComputedPadding.right  = aPadding->right;
     mComputedPadding.bottom = aPadding->bottom;
@@ -1675,7 +1690,22 @@ nsCSSOffsetState::InitOffsets(nscoord aC
   else {
     ComputePadding(aContainingBlockWidth);
   }
-  if (aBorder) {  // border is an input arg
+
+  if (isThemed) {
+    presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
+                                             frame, disp->mAppearance,
+                                             &mComputedBorderPadding);
+    float p2t = presContext->ScaledPixelsToTwips();
+    mComputedBorderPadding.top =
+      NSIntPixelsToTwips(mComputedBorderPadding.top, p2t);
+    mComputedBorderPadding.right =
+      NSIntPixelsToTwips(mComputedBorderPadding.right, p2t);
+    mComputedBorderPadding.bottom =
+      NSIntPixelsToTwips(mComputedBorderPadding.bottom, p2t);
+    mComputedBorderPadding.left =
+      NSIntPixelsToTwips(mComputedBorderPadding.left, p2t);
+  }
+  else if (aBorder) {  // border is an input arg
     mComputedBorderPadding = *aBorder;
   }
   else {
