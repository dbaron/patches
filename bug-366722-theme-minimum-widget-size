Make non-box frames use nsITheme methods concerning size, border, and padding, so that non-boxes with appearance set will obey the platform-specific theme.  b=366722

diff -r f03505149e3f gfx/public/nsITheme.h
--- a/gfx/public/nsITheme.h	Fri Jan 12 11:58:11 2007 -0800
+++ b/gfx/public/nsITheme.h	Fri Jan 12 11:58:16 2007 -0800
@@ -36,6 +36,8 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
+/* service providing platform-specific native rendering for widgets */
+
 #ifndef nsITheme_h_
 #define nsITheme_h_
 
@@ -63,6 +65,16 @@ class nsIAtom;
 #define NS_THEMERENDERER_CID \
 { 0xd930e29b, 0x6909, 0x44e5, { 0xab, 0x4b, 0xaf, 0x10, 0xd6, 0x92, 0x37, 0x5 } }
 
+/**
+ * nsITheme is a service that provides platform-specific native
+ * rendering for widgets.  In other words, it provides the necessary
+ * operations to draw a rendering object (an nsIFrame) as a native
+ * widget.
+ *
+ * All the methods on nsITheme take a rendering context or device
+ * context, a frame (the rendering object), and a widget type (one of
+ * the constants in nsThemeConstants.h).
+ */
 class nsITheme: public nsISupports {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ITHEME_IID)
@@ -73,29 +85,48 @@ public:
                                   const nsRect& aRect,
                                   const nsRect& aClipRect)=0;
 
+  /**
+   * Get the computed CSS border for the widget, in pixels.
+   */
   NS_IMETHOD GetWidgetBorder(nsIDeviceContext* aContext, 
                              nsIFrame* aFrame,
                              PRUint8 aWidgetType,
                              nsMargin* aResult)=0;
 
-  // This method can return PR_FALSE to indicate that the CSS padding value
-  // should be used.  Otherwise, it will fill in aResult with the desired
-  // padding and return PR_TRUE.
+  /**
+   * This method can return PR_FALSE to indicate that the CSS padding
+   * value should be used.  Otherwise, it will fill in aResult with the
+   * computed padding, in pixels, and return PR_TRUE.
+   *
+   * XXXldb This ought to be required to return true for non-containers
+   * so that we don't let specified padding that has no effect change
+   * the computed padding and potentially the size.
+   */
   virtual PRBool GetWidgetPadding(nsIDeviceContext* aContext,
                                   nsIFrame* aFrame,
                                   PRUint8 aWidgetType,
                                   nsMargin* aResult) = 0;
 
-  // This method can return PR_FALSE to indicate that no special overflow
-  // area is required by the native widget. Otherwise it will fill in
-  // aResult with the desired overflow area and return PR_TRUE.
+  /**
+   * This method can return PR_FALSE to indicate that no special
+   * overflow area is required by the native widget. Otherwise it will
+   * fill in aResult with the desired overflow area, in twips, relative
+   * to the widget origin, and return PR_TRUE.
+   */
   virtual PRBool GetWidgetOverflow(nsIDeviceContext* aContext,
                                    nsIFrame* aFrame,
                                    PRUint8 aWidgetType,
                                    nsRect* aResult)
   { return PR_FALSE; }
 
-  NS_IMETHOD GetMinimumWidgetSize(nsIRenderingContext* aContext, nsIFrame* aFrame,
+  /**
+   * Get the minimum border-box size of a widget, in *pixels* (in
+   * |aResult|).  If |aIsOverridable| is set to true, this size is a
+   * minimum size; if false, this size is the only valid size for the
+   * widget.
+   */
+  NS_IMETHOD GetMinimumWidgetSize(nsIRenderingContext* aContext,
+                                  nsIFrame* aFrame,
                                   PRUint8 aWidgetType,
                                   nsSize* aResult,
                                   PRBool* aIsOverridable)=0;
@@ -105,6 +136,9 @@ public:
 
   NS_IMETHOD ThemeChanged()=0;
 
+  /**
+   * Can the nsITheme implementation handle this widget?
+   */
   virtual PRBool ThemeSupportsWidget(nsPresContext* aPresContext,
                                      nsIFrame* aFrame,
                                      PRUint8 aWidgetType)=0;
diff -r f03505149e3f layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp	Fri Jan 12 11:58:11 2007 -0800
+++ b/layout/base/nsLayoutUtils.cpp	Fri Jan 12 11:58:16 2007 -0800
@@ -1263,6 +1263,27 @@ nsLayoutUtils::IntrinsicForContainer(nsI
   if (result < min)
     result = min;
 
+  const nsStyleDisplay *disp = aFrame->GetStyleDisplay();
+  if (aFrame->IsThemed(disp)) {
+    nsSize size(0, 0);
+    PRBool canOverride = PR_TRUE;
+    nsPresContext *presContext = aFrame->GetPresContext();
+    presContext->GetTheme()->
+      GetMinimumWidgetSize(aRenderingContext, aFrame, disp->mAppearance,
+                           &size, &canOverride);
+
+    // GMWS() returns size in pixels, we need to convert it back to twips
+    float p2t = presContext->ScaledPixelsToTwips();
+    nscoord themeWidth = NSIntPixelsToTwips(size.width, p2t);
+
+    // GMWS() returns a border-box width
+    themeWidth += offsets.hMargin;
+    themeWidth = AddPercents(aType, themeWidth, offsets.hPctMargin);
+
+    if (themeWidth > result || !canOverride)
+      result = themeWidth;
+  }
+
 #ifdef DEBUG_INTRINSIC_WIDTH
   nsFrame::IndentBy(stdout, gNoiseIndent);
   NS_STATIC_CAST(nsFrame*, aFrame)->ListTag(stdout);
diff -r f03505149e3f layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp	Fri Jan 12 11:58:11 2007 -0800
+++ b/layout/generic/nsFrame.cpp	Fri Jan 12 11:58:16 2007 -0800
@@ -3085,9 +3085,6 @@ nsFrame::ComputeSize(nsIRenderingContext
   if (minWidth > result.width)
     result.width = minWidth;
 
-  if (result.width < 0)
-    result.width = 0;
-
   // Compute height
 
   if (!IsAutoHeight(stylePos->mHeight, aCBSize.height)) {
@@ -3116,6 +3113,33 @@ nsFrame::ComputeSize(nsIRenderingContext
         result.height = minHeight;
     }
   }
+
+  const nsStyleDisplay *disp = GetStyleDisplay();
+  if (IsThemed(disp)) {
+    nsSize size(0, 0);
+    PRBool canOverride = PR_TRUE;
+    nsPresContext *presContext = GetPresContext();
+    presContext->GetTheme()->
+      GetMinimumWidgetSize(aRenderingContext, this, disp->mAppearance,
+                           &size, &canOverride);
+
+    // GMWS() returns size in pixels, we need to convert it back to twips
+    float p2t = presContext->ScaledPixelsToTwips();
+    size.width = NSIntPixelsToTwips(size.width, p2t);
+    size.height = NSIntPixelsToTwips(size.height, p2t);
+
+    // GMWS() returns border-box; we need content-box
+    size.width -= aBorder.width + aPadding.width;
+    size.height -= aBorder.height + aPadding.height;
+
+    if (size.height > result.height || !canOverride)
+      result.height = size.height;
+    if (size.width > result.width || !canOverride)
+      result.width = size.width;
+  }
+
+  if (result.width < 0)
+    result.width = 0;
 
   if (result.height < 0)
     result.height = 0;
@@ -5228,12 +5252,23 @@ nsIFrame::FinishAndStoreOverflow(nsRect*
 {
   // This is now called FinishAndStoreOverflow() instead of 
   // StoreOverflow() because frame-generic ways of adding overflow
-  // can happen here, e.g. CSS2 outline.
+  // can happen here, e.g. CSS2 outline and native theme.
   // If we find more things other than outline that need to be added,
   // we should think about starting a new method like GetAdditionalOverflow()
   NS_ASSERTION(aNewSize.width == 0 || aNewSize.height == 0 ||
                aOverflowArea->Contains(nsRect(nsPoint(0, 0), aNewSize)),
                "Computed overflow area must contain frame bounds");
+
+  const nsStyleDisplay *disp = GetStyleDisplay();
+  if (IsThemed(disp)) {
+    nsRect r;
+    nsPresContext *presContext = GetPresContext();
+    if (presContext->GetTheme()->
+          GetWidgetOverflow(presContext->DeviceContext(), this,
+                            disp->mAppearance, &r)) {
+      aOverflowArea->UnionRect(*aOverflowArea, r);
+    }
+  }
 
   PRBool geometricOverflow =
     aOverflowArea->x < 0 || aOverflowArea->y < 0 ||
diff -r f03505149e3f layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp	Fri Jan 12 11:58:11 2007 -0800
+++ b/layout/generic/nsHTMLReflowState.cpp	Fri Jan 12 11:58:16 2007 -0800
@@ -1666,7 +1666,22 @@ nsCSSOffsetState::InitOffsets(nscoord aC
   // XXX fix to provide 0,0 for the top&bottom margins for
   // inline-non-replaced elements
   ComputeMargin(aContainingBlockWidth);
-  if (aPadding) { // padding is an input arg
+
+  const nsStyleDisplay *disp = frame->GetStyleDisplay();
+  PRBool isThemed = frame->IsThemed(disp);
+  nsPresContext *presContext = frame->GetPresContext();
+
+  if (isThemed &&
+      presContext->GetTheme()->GetWidgetPadding(presContext->DeviceContext(),
+                                                frame, disp->mAppearance,
+                                                &mComputedPadding)) {
+    float p2t = presContext->ScaledPixelsToTwips();
+    mComputedPadding.top = NSIntPixelsToTwips(mComputedPadding.top, p2t);
+    mComputedPadding.right = NSIntPixelsToTwips(mComputedPadding.right, p2t);
+    mComputedPadding.bottom = NSIntPixelsToTwips(mComputedPadding.bottom, p2t);
+    mComputedPadding.left = NSIntPixelsToTwips(mComputedPadding.left, p2t);
+  }
+  else if (aPadding) { // padding is an input arg
     mComputedPadding.top    = aPadding->top;
     mComputedPadding.right  = aPadding->right;
     mComputedPadding.bottom = aPadding->bottom;
@@ -1675,7 +1690,22 @@ nsCSSOffsetState::InitOffsets(nscoord aC
   else {
     ComputePadding(aContainingBlockWidth);
   }
-  if (aBorder) {  // border is an input arg
+
+  if (isThemed) {
+    presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
+                                             frame, disp->mAppearance,
+                                             &mComputedBorderPadding);
+    float p2t = presContext->ScaledPixelsToTwips();
+    mComputedBorderPadding.top =
+      NSIntPixelsToTwips(mComputedBorderPadding.top, p2t);
+    mComputedBorderPadding.right =
+      NSIntPixelsToTwips(mComputedBorderPadding.right, p2t);
+    mComputedBorderPadding.bottom =
+      NSIntPixelsToTwips(mComputedBorderPadding.bottom, p2t);
+    mComputedBorderPadding.left =
+      NSIntPixelsToTwips(mComputedBorderPadding.left, p2t);
+  }
+  else if (aBorder) {  // border is an input arg
     mComputedBorderPadding = *aBorder;
   }
   else {
diff -r f03505149e3f layout/xul/base/src/nsBox.cpp
--- a/layout/xul/base/src/nsBox.cpp	Fri Jan 12 11:58:11 2007 -0800
+++ b/layout/xul/base/src/nsBox.cpp	Fri Jan 12 11:58:16 2007 -0800
@@ -700,18 +700,6 @@ nsBox::SyncLayout(nsBoxLayoutState& aSta
       }
     }
 
-    const nsStyleDisplay* disp = GetStyleDisplay();
-    if (disp->mAppearance && gTheme) {
-      // Add in the theme's desired overflow
-      if (gTheme->ThemeSupportsWidget(presContext, this, disp->mAppearance)) {
-        nsRect r;
-        if (gTheme->GetWidgetOverflow(presContext->DeviceContext(), this,
-                                      disp->mAppearance, &r)) {
-          rect.UnionRect(rect, r);
-        }
-      }
-    }
-
     FinishAndStoreOverflow(&rect, GetSize());
   }
 
