From: L. David Baron <dbaron@dbaron.org>

Bug 996796 patch N - Make restyling exact - only call RestyleBeforePseudo and RestyleAfterPseudo when we have an eRestyle_Subtree hint.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -2629,27 +2629,41 @@ ElementRestyler::RestyleSelf(nsIFrame* a
       }
     }
   }
 }
 
 void
 ElementRestyler::RestyleChildren(nsRestyleHint aChildRestyleHint)
 {
+  // We'd like style resolution to be exact in the sense that an
+  // animation-only style flush flushes only the styles it requests
+  // flushing and doesn't update any other styles.  This means avoiding
+  // constructing new frames during such a flush.
+  //
+  // For a ::before or ::after, we'll do an eRestyle_Subtree due to
+  // RestyleHintForOp in nsCSSRuleProcessor.cpp (via its
+  // HasAttributeDependentStyle or HasStateDependentStyle), given that
+  // we store pseudo-elements in selectors like they were children.
+  //
+  // Also, it's faster to skip the work we do on undisplayed children
+  // and pseudo-elements when we can skip it.
+  bool mightReframePseudos = aChildRestyleHint & eRestyle_Subtree;
+
   RestyleUndisplayedChildren(aChildRestyleHint);
 
   // Check whether we might need to create a new ::before frame.
   // There's no need to do this if we're planning to reframe already
   // or if we're not forcing restyles on kids.
   // It's also important to check mHintsHandled since we use
   // mFrame->StyleContext(), which is out of date if mHintsHandled has a
   // ReconstructFrame hint.  Using an out of date style context could
   // trigger assertions about mismatched rule trees.
   if (!(mHintsHandled & nsChangeHint_ReconstructFrame) &&
-      aChildRestyleHint) {
+      mightReframePseudos) {
     RestyleBeforePseudo();
   }
 
   // There is no need to waste time crawling into a frame's children
   // on a frame change.  The act of reconstructing frames will force
   // new style contexts to be resolved on all of this frame's
   // descendants anyway, so we want to avoid wasting time processing
   // style contexts that we're just going to throw away anyway. - dwh
@@ -2668,17 +2682,17 @@ ElementRestyler::RestyleChildren(nsResty
     }
 
     SendAccessibilityNotifications();
   }
 
   // Check whether we might need to create a new ::after frame.
   // See comments above regarding :before.
   if (!(mHintsHandled & nsChangeHint_ReconstructFrame) &&
-      aChildRestyleHint) {
+      mightReframePseudos) {
     RestyleAfterPseudo(lastContinuation);
   }
 }
 
 void
 ElementRestyler::RestyleUndisplayedChildren(nsRestyleHint aChildRestyleHint)
 {
   // When the root element is display:none, we still construct *some*
