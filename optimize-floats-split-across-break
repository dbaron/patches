From: L. David Baron <dbaron@dbaron.org>

Add the optimization mentioned in the previous patch, so we don't have to iterate all floats to determine if one was split.  (Bug 563584, patch 10)  r=roc

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -3908,16 +3908,24 @@ nsBlockFrame::SplitFloat(nsBlockReflowSt
   if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aFloatStatus))
     aFloat->GetNextInFlow()->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
 
   // Float continuations can only trigger overflow
   NS_FRAME_SET_OVERFLOW_INCOMPLETE(aFloatStatus);
   // Make sure the containing block knows about the float's status
   NS_MergeReflowStatusInto(&aState.mReflowStatus, aFloatStatus);
 
+  if (aFloat->GetStyleDisplay()->mFloats == NS_STYLE_FLOAT_LEFT) {
+    aState.mFloatManager->SetSplitLeftFloatAcrossBreak();
+  } else {
+    NS_ABORT_IF_FALSE(aFloat->GetStyleDisplay()->mFloats ==
+                        NS_STYLE_FLOAT_RIGHT, "unexpected float side");
+    aState.mFloatManager->SetSplitRightFloatAcrossBreak();
+  }
+
   if (nextInFlow) {
     // Next in flow was created above.
     aState.AppendFloatContinuation(nextInFlow);
   }
   return NS_OK;
 }
 
 static nsFloatCache*
diff --git a/layout/generic/nsFloatManager.cpp b/layout/generic/nsFloatManager.cpp
--- a/layout/generic/nsFloatManager.cpp
+++ b/layout/generic/nsFloatManager.cpp
@@ -69,17 +69,19 @@ PSArenaFreeCB(size_t aSize, void* aPtr, 
 
 /////////////////////////////////////////////////////////////////////////////
 // nsFloatManager
 
 nsFloatManager::nsFloatManager(nsIPresShell* aPresShell)
   : mX(0), mY(0),
     mFloatDamage(PSArenaAllocCB, PSArenaFreeCB, aPresShell),
     mPushedLeftFloatPastBreak(PR_FALSE),
-    mPushedRightFloatPastBreak(PR_FALSE)
+    mPushedRightFloatPastBreak(PR_FALSE),
+    mSplitLeftFloatAcrossBreak(PR_FALSE),
+    mSplitRightFloatAcrossBreak(PR_FALSE)
 {
   MOZ_COUNT_CTOR(nsFloatManager);
 }
 
 nsFloatManager::~nsFloatManager()
 {
   MOZ_COUNT_DTOR(nsFloatManager);
 }
@@ -414,28 +416,32 @@ nsFloatManager::PushState(SavedState* aS
   // reflow mentioned above) and then from B to C during the subsequent
   // reflow. In the typical case A and C will be the same, but not always.
   // Allowing mFloatDamage to accumulate the damage incurred during both
   // reflows ensures that nothing gets missed.
   aState->mX = mX;
   aState->mY = mY;
   aState->mPushedLeftFloatPastBreak = mPushedLeftFloatPastBreak;
   aState->mPushedRightFloatPastBreak = mPushedRightFloatPastBreak;
+  aState->mSplitLeftFloatAcrossBreak = mSplitLeftFloatAcrossBreak;
+  aState->mSplitRightFloatAcrossBreak = mSplitRightFloatAcrossBreak;
   aState->mFloatInfoCount = mFloats.Length();
 }
 
 void
 nsFloatManager::PopState(SavedState* aState)
 {
   NS_PRECONDITION(aState, "No state to restore?");
 
   mX = aState->mX;
   mY = aState->mY;
   mPushedLeftFloatPastBreak = aState->mPushedLeftFloatPastBreak;
   mPushedRightFloatPastBreak = aState->mPushedRightFloatPastBreak;
+  mSplitLeftFloatAcrossBreak = aState->mSplitLeftFloatAcrossBreak;
+  mSplitRightFloatAcrossBreak = aState->mSplitRightFloatAcrossBreak;
 
   NS_ASSERTION(aState->mFloatInfoCount <= mFloats.Length(),
                "somebody misused PushState/PopState");
   mFloats.TruncateLength(aState->mFloatInfoCount);
 }
 
 nscoord
 nsFloatManager::GetLowestFloatTop() const
@@ -505,43 +511,22 @@ nsFloatManager::ClearFloats(nscoord aY, 
   bottom -= mY;
 
   return bottom;
 }
 
 PRBool
 nsFloatManager::ClearContinues(PRUint8 aBreakType) const
 {
-  if ((mPushedLeftFloatPastBreak &&
-       (aBreakType == NS_STYLE_CLEAR_LEFT_AND_RIGHT ||
-        aBreakType == NS_STYLE_CLEAR_LEFT)) ||
-      (mPushedRightFloatPastBreak &&
-       (aBreakType == NS_STYLE_CLEAR_LEFT_AND_RIGHT ||
-        aBreakType == NS_STYLE_CLEAR_RIGHT))) {
-    return PR_TRUE;
-  }
-  if (!HasAnyFloats() || aBreakType == NS_STYLE_CLEAR_NONE)
-    return PR_FALSE;
-  // FIXME: We could make this faster by recording whenever we split a
-  // float (in addition to recording whenever we push a float in its
-  // entirety).
-  for (PRUint32 i = mFloats.Length(); i > 0; i--) {
-    nsIFrame* f = mFloats[i-1].mFrame;
-    if (f->GetNextInFlow()) {
-      if (aBreakType == NS_STYLE_CLEAR_LEFT_AND_RIGHT)
-        return PR_TRUE;
-      PRUint8 floatSide = f->GetStyleDisplay()->mFloats;
-      if ((aBreakType == NS_STYLE_CLEAR_LEFT &&
-           floatSide == NS_STYLE_FLOAT_LEFT) ||
-          (aBreakType == NS_STYLE_CLEAR_RIGHT &&
-           floatSide == NS_STYLE_FLOAT_RIGHT))
-        return PR_TRUE;
-    }
-  }
-  return PR_FALSE;
+  return ((mPushedLeftFloatPastBreak || mSplitLeftFloatAcrossBreak) &&
+          (aBreakType == NS_STYLE_CLEAR_LEFT_AND_RIGHT ||
+           aBreakType == NS_STYLE_CLEAR_LEFT)) ||
+         ((mPushedRightFloatPastBreak || mSplitRightFloatAcrossBreak) &&
+          (aBreakType == NS_STYLE_CLEAR_LEFT_AND_RIGHT ||
+           aBreakType == NS_STYLE_CLEAR_RIGHT));
 }
 
 /////////////////////////////////////////////////////////////////////////////
 // FloatInfo
 
 nsFloatManager::FloatInfo::FloatInfo(nsIFrame* aFrame, const nsRect& aRect)
   : mFrame(aFrame), mRect(aRect)
 {
diff --git a/layout/generic/nsFloatManager.h b/layout/generic/nsFloatManager.h
--- a/layout/generic/nsFloatManager.h
+++ b/layout/generic/nsFloatManager.h
@@ -108,16 +108,18 @@ public:
   struct SavedState;
   friend struct SavedState;
   struct SavedState {
   private:
     PRUint32 mFloatInfoCount;
     nscoord mX, mY;
     PRPackedBool mPushedLeftFloatPastBreak;
     PRPackedBool mPushedRightFloatPastBreak;
+    PRPackedBool mSplitLeftFloatAcrossBreak;
+    PRPackedBool mSplitRightFloatAcrossBreak;
 
     friend class nsFloatManager;
   };
 
   /**
    * Translate the current origin by the specified (dx, dy). This
    * creates a new local coordinate space relative to the current
    * coordinate space.
@@ -182,24 +184,35 @@ public:
    * must ensure aMarginRect.height >= 0 and aMarginRect.width >= 0.
    */
   nsresult AddFloat(nsIFrame* aFloatFrame, const nsRect& aMarginRect);
 
   /**
    * Notify that we tried to place a float that could not fit at all and
    * had to be pushed to the next page/column?  (If so, we can't place
    * any more floats in this page/column because of the rule that the
-   * top of a float cannot be above the top of an earlier float.)
+   * top of a float cannot be above the top of an earlier float.  It
+   * also means that any clear needs to continue to the next column.)
    */
   void SetPushedLeftFloatPastBreak()
     { mPushedLeftFloatPastBreak = PR_TRUE; }
   void SetPushedRightFloatPastBreak()
     { mPushedRightFloatPastBreak = PR_TRUE; }
 
   /**
+   * Notify that we split a float, with part of it needing to be pushed
+   * to the next page/column.  (This means that any 'clear' needs to
+   * continue to the next page/column.)
+   */
+  void SetSplitLeftFloatAcrossBreak()
+    { mSplitLeftFloatAcrossBreak = PR_TRUE; }
+  void SetSplitRightFloatAcrossBreak()
+    { mSplitRightFloatAcrossBreak = PR_TRUE; }
+
+  /**
    * Remove the regions associated with this floating frame and its
    * next-sibling list.  Some of the frames may never have been added;
    * we just skip those. This is not fully general; it only works as
    * long as the N frames to be removed are the last N frames to have
    * been added; if there's a frame in the middle of them that should
    * not be removed, YOU LOSE.
    */
   nsresult RemoveTrailingRegions(nsIFrame* aFrameList);
@@ -271,16 +284,20 @@ public:
 
   void AssertStateMatches(SavedState *aState) const
   {
     NS_ASSERTION(aState->mX == mX && aState->mY == mY &&
                  aState->mPushedLeftFloatPastBreak ==
                    mPushedLeftFloatPastBreak &&
                  aState->mPushedRightFloatPastBreak ==
                    mPushedRightFloatPastBreak &&
+                 aState->mSplitLeftFloatAcrossBreak ==
+                   mSplitLeftFloatAcrossBreak &&
+                 aState->mSplitRightFloatAcrossBreak ==
+                   mSplitRightFloatAcrossBreak &&
                  aState->mFloatInfoCount == mFloats.Length(),
                  "float manager state should match saved state");
   }
 
 #ifdef DEBUG
   /**
    * Dump the state of the float manager out to a file.
    */
@@ -310,16 +327,22 @@ private:
   // pushed to the next page/column?  If so, we can't place any more
   // floats in this page/column because of the rule that the top of a
   // float cannot be above the top of an earlier float.  And we also
   // need to apply this information to 'clear', and thus need to
   // separate left and right floats.
   PRPackedBool mPushedLeftFloatPastBreak;
   PRPackedBool mPushedRightFloatPastBreak;
 
+  // Did we split a float, with part of it needing to be pushed to the
+  // next page/column.  This means that any 'clear' needs to continue to
+  // the next page/column.
+  PRPackedBool mSplitLeftFloatAcrossBreak;
+  PRPackedBool mSplitRightFloatAcrossBreak;
+
   static PRInt32 sCachedFloatManagerCount;
   static void* sCachedFloatManagers[NS_FLOAT_MANAGER_CACHE_SIZE];
 
   nsFloatManager(const nsFloatManager&);  // no implementation
   void operator=(const nsFloatManager&);  // no implementation
 };
 
 /**
