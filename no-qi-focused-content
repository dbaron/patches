From: L. David Baron <dbaron@dbaron.org>

Don't QI a node to nsIDOMElement and back to nsIContent for every call to nsEventStateManager::GetContentState.  (Bug 509889)  r=enndeakin

diff --git a/content/events/src/nsEventStateManager.cpp b/content/events/src/nsEventStateManager.cpp
--- a/content/events/src/nsEventStateManager.cpp
+++ b/content/events/src/nsEventStateManager.cpp
@@ -3805,25 +3805,19 @@ nsEventStateManager::GetContentState(nsI
   for (nsIContent* hoverContent = mHoverContent; hoverContent;
        hoverContent = hoverContent->GetParent()) {
     if (aContent == hoverContent) {
       aState |= NS_EVENT_STATE_HOVER;
       break;
     }
   }
 
-  nsIFocusManager* fm = nsFocusManager::GetFocusManager();
-  if (fm) {
-    nsCOMPtr<nsIDOMElement> focusedElement;
-    fm->GetFocusedElement(getter_AddRefs(focusedElement));
-
-    nsCOMPtr<nsIContent> focusedContent = do_QueryInterface(focusedElement);
-    if (aContent == focusedContent) {
-      aState |= NS_EVENT_STATE_FOCUS;
-    }
+  nsFocusManager* fm = nsFocusManager::GetFocusManager();
+  if (fm && aContent == fm->GetFocusedContent()) {
+    aState |= NS_EVENT_STATE_FOCUS;
   }
   if (aContent == mDragOverContent) {
     aState |= NS_EVENT_STATE_DRAGOVER;
   }
   if (aContent == mURLTargetContent) {
     aState |= NS_EVENT_STATE_URLTARGET;
   }
   return NS_OK;
diff --git a/dom/base/nsFocusManager.cpp b/dom/base/nsFocusManager.cpp
--- a/dom/base/nsFocusManager.cpp
+++ b/dom/base/nsFocusManager.cpp
@@ -144,17 +144,17 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFocusedContent)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFirstBlurEvent)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFirstFocusEvent)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mWindowBeingLowered)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 static NS_DEFINE_CID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
 
-nsIFocusManager* nsFocusManager::sInstance = nsnull;
+nsFocusManager* nsFocusManager::sInstance = nsnull;
 
 nsFocusManager::nsFocusManager()
 { }
 
 nsFocusManager::~nsFocusManager()
 {
   nsCOMPtr<nsIPrefBranch2> prefBranch =
     do_QueryInterface(nsContentUtils::GetPrefBranch());
diff --git a/dom/base/nsFocusManager.h b/dom/base/nsFocusManager.h
--- a/dom/base/nsFocusManager.h
+++ b/dom/base/nsFocusManager.h
@@ -68,17 +68,24 @@ public:
 
   // called to initialize and stop the focus manager at startup and shutdown
   static nsresult Init();
   static void Shutdown();
 
   /**
    * Retrieve the single focus manager.
    */
-  static nsIFocusManager* GetFocusManager() { return sInstance; }
+  static nsFocusManager* GetFocusManager() { return sInstance; }
+
+  /**
+   * A faster version of nsIFocusManager::GetFocusedElement, returning a
+   * raw nsIContent pointer (instead of having AddRef-ed nsIDOMElement
+   * pointer filled in to an out-parameter).
+   */
+  nsIContent* GetFocusedContent() { return mFocusedContent; }
 
   /**
    * Returns the content node that would be focused if aWindow was in an
    * active window. This will traverse down the frame hierarchy, starting at
    * the given window aWindow. Sets aFocusedWindow to the window with the
    * document containing aFocusedContent. If no element is focused,
    * aFocusedWindow may be still be set -- this means that the document is
    * focused but no element within it is focused.
@@ -432,15 +439,15 @@ protected:
   // keep track of a window while it is being lowered
   nsCOMPtr<nsPIDOMWindow> mWindowBeingLowered;
 
   // synchronized actions cannot be interrupted with events, so queue these up
   // and fire them later.
   nsTArray<nsDelayedBlurOrFocusEvent> mDelayedBlurFocusEvents;
 
   // the single focus manager
-  static nsIFocusManager* sInstance;
+  static nsFocusManager* sInstance;
 };
 
 nsresult
 NS_NewFocusManager(nsIFocusManager** aResult);
 
 #endif
