Use PlaceTopBottomFrames for the children of the root span, too.  b=118501

diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -1452,57 +1452,22 @@ nsLineLayout::VerticalAlignLine()
 #endif
 
   // Now position all of the frames in the root span. We will also
   // recurse over the child spans and place any top/bottom aligned
   // frames we find.
   // XXX PERFORMANCE: set a bit per-span to avoid the extra work
   // (propagate it upward too)
   for (PerFrameData* pfd = psd->mFirstFrame; pfd; pfd = pfd->mNext) {
-    PerSpanData* span = pfd->mSpan;
-#ifdef DEBUG
-    NS_ASSERTION(0xFF != pfd->mVerticalAlign, "umr");
-#endif
-    switch (pfd->mVerticalAlign) {
-      case VALIGN_TOP:
-        if (span) {
-          pfd->mBounds.y = mTopEdge - pfd->mBorderPadding.top +
-            span->mTopLeading;
-        }
-        else {
-          pfd->mBounds.y = mTopEdge + pfd->mMargin.top;
-        }
-        break;
-      case VALIGN_BOTTOM:
-        if (span) {
-          // Compute bottom leading
-          pfd->mBounds.y = mTopEdge + lineHeight -
-            pfd->mBounds.height + pfd->mBorderPadding.bottom -
-            span->mBottomLeading;
-        }
-        else {
-          pfd->mBounds.y = mTopEdge + lineHeight - pfd->mMargin.bottom -
-            pfd->mBounds.height;
-        }
-        break;
-      case VALIGN_OTHER:
-        pfd->mBounds.y += baselineY;
-        break;
-    }
-    pfd->mFrame->SetRect(pfd->mBounds);
-#ifdef NOISY_VERTICAL_ALIGN
-    printf("  [child of line]");
-    nsFrame::ListTag(stdout, pfd->mFrame);
-    printf(": y=%d\n", pfd->mBounds.y);
-#endif
-    if (span) {
-      nscoord distanceFromTop = pfd->mBounds.y - mTopEdge;
-      PlaceTopBottomFrames(span, distanceFromTop, lineHeight);
+    if (pfd->mVerticalAlign == VALIGN_OTHER) {
+      pfd->mBounds.y += baselineY;
+      pfd->mFrame->SetRect(pfd->mBounds);
     }
   }
+  PlaceTopBottomFrames(psd, -mTopEdge, lineHeight);
 
   // Fill in returned line-box and max-element-width data
   mLineBox->mBounds.x = psd->mLeftEdge;
   mLineBox->mBounds.y = mTopEdge;
   mLineBox->mBounds.width = psd->mX - psd->mLeftEdge;
   mLineBox->mBounds.height = lineHeight;
   mFinalLineHeight = lineHeight;
   mLineBox->SetAscent(baselineY - mTopEdge);
@@ -1518,18 +1483,17 @@ nsLineLayout::VerticalAlignLine()
   mRootSpan->mFrame = nsnull;
 }
 
 void
 nsLineLayout::PlaceTopBottomFrames(PerSpanData* psd,
                                    nscoord aDistanceFromTop,
                                    nscoord aLineHeight)
 {
-  PerFrameData* pfd = psd->mFirstFrame;
-  while (nsnull != pfd) {
+  for (PerFrameData* pfd = psd->mFirstFrame; pfd; pfd = pfd->mNext) {
     PerSpanData* span = pfd->mSpan;
 #ifdef DEBUG
     NS_ASSERTION(0xFF != pfd->mVerticalAlign, "umr");
 #endif
     switch (pfd->mVerticalAlign) {
       case VALIGN_TOP:
         if (span) {
           pfd->mBounds.y = -aDistanceFromTop - pfd->mBorderPadding.top +
@@ -1566,17 +1530,16 @@ nsLineLayout::PlaceTopBottomFrames(PerSp
         printf(": y=%d\n", pfd->mBounds.y);
 #endif
         break;
     }
     if (span) {
       nscoord distanceFromTop = aDistanceFromTop + pfd->mBounds.y;
       PlaceTopBottomFrames(span, distanceFromTop, aLineHeight);
     }
-    pfd = pfd->mNext;
   }
 }
 
 #define VERTICAL_ALIGN_FRAMES_NO_MINIMUM 32767
 #define VERTICAL_ALIGN_FRAMES_NO_MAXIMUM -32768
 
 // Vertically place frames within a given span. Note: this doesn't
 // place top/bottom aligned frames as those have to wait until the
