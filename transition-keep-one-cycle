From: L. David Baron <dbaron@dbaron.org>

Store transitions for one refresh cycle after they complete so that merging with a non-animation style change doesn't make us start a second transition to transition the last step.  (Bug 537151)  r=bzbarsky

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -70,16 +70,27 @@ struct ElementPropertyTransition
   // object's owning style rule needs to keep alive (after calling
   // UncomputeValue on it in MapRuleInfoInto).
   nsStyleAnimation::Value mStartValue, mEndValue, mCurrentValue;
   TimeStamp mStartTime; // actual start plus transition delay
 
   // data from the relevant nsTransition
   TimeDuration mDuration;
   nsSMILKeySpline mTimingFunction;
+
+  PRBool IsRemovedSentinel() const
+  {
+    return mStartTime.IsNull();
+  }
+
+  void SetRemovedSentinel()
+  {
+    // assign the null time stamp
+    mStartTime = TimeStamp();
+  }
 };
 
 /**
  * An ElementTransitionsStyleRule overrides style data with the
  * currently-transitioning value for an element that is executing a
  * transition.  It only matches when styling with animation.  When we
  * style without animation, we need to not use it so that we can detect
  * any new changes; if necessary we restyle immediately afterwards with
@@ -215,16 +226,20 @@ ElementTransitionsStyleRule::MapRuleInfo
   }
 
   ElementTransitions *et = ElementData();
   NS_ENSURE_TRUE(et, NS_OK); // FIXME (Bug 522597): Why can this be null?
   for (PRUint32 i = 0, i_end = et->mPropertyTransitions.Length();
        i < i_end; ++i)
   {
     ElementPropertyTransition &pt = et->mPropertyTransitions[i];
+    if (pt.IsRemovedSentinel()) {
+      continue;
+    }
+
     if (aRuleData->mSIDs & nsCachedStyleData::GetBitForSID(
                              nsCSSProps::kSIDTable[pt.mProperty]))
     {
       double timePortion =
         (RefreshTime() - pt.mStartTime).ToSeconds() / pt.mDuration.ToSeconds();
       if (timePortion < 0.0)
         timePortion = 0.0; // use start value during transition-delay
       if (timePortion > 1.0)
@@ -639,20 +654,20 @@ nsTransitionManager::ConsiderStartingTra
   // been longer had it started from the endpoint of the currently
   // running transition.
   double durationFraction = 1.0;
 
   // We need to check two things if we have a currently running
   // transition for this property:  see durationFraction comment above
   // and the endpoint check below.
   if (currentIndex != nsTArray<ElementPropertyTransition>::NoIndex) {
-    const nsStyleAnimation::Value &endVal =
-      aElementTransitions->mPropertyTransitions[currentIndex].mEndValue;
+    const ElementPropertyTransition &oldPT =
+      aElementTransitions->mPropertyTransitions[currentIndex];
 
-    if (endVal == pt.mEndValue) {
+    if (oldPT.mEndValue == pt.mEndValue) {
       // If we got a style change that changed the value to the endpoint
       // of the currently running transition, we don't want to interrupt
       // its timing function.
       // WalkTransitionRule already called RestyleForAnimation.
       return;
     }
 
     double fullDistance, remainingDistance;
@@ -935,26 +950,37 @@ nsTransitionManager::WillRefresh(mozilla
                         "nsGenericElement::UnbindFromTree should have "
                         "destroyed the element transitions object");
 
       PRUint32 i = et->mPropertyTransitions.Length();
       NS_ABORT_IF_FALSE(i != 0, "empty transitions list?");
       do {
         --i;
         ElementPropertyTransition &pt = et->mPropertyTransitions[i];
-        if (pt.mStartTime + pt.mDuration <= aTime) {
+        if (pt.IsRemovedSentinel()) {
+          // Actually remove transitions one cycle after their
+          // completion.  See comment below.
+          et->mPropertyTransitions.RemoveElementAt(i);
+        } else if (pt.mStartTime + pt.mDuration <= aTime) {
           // This transition has completed.
           nsCSSProperty prop = pt.mProperty;
           if (nsCSSProps::PropHasFlags(prop, CSS_PROPERTY_REPORT_OTHER_NAME)) {
             prop = nsCSSProps::OtherNameFor(prop);
           }
           events.AppendElement(
             TransitionEventInfo(et->mElement, prop, pt.mDuration));
 
-          et->mPropertyTransitions.RemoveElementAt(i);
+          // Leave this transition in the list for one more refresh
+          // cycle, since we haven't yet processed its style change, and
+          // if we also have (already, or will have from processing
+          // transitionend events or other refresh driver notifications)
+          // a non-animation style change that would affect it, we need
+          // to know not to start a new transition for the transition
+          // from the almost-completed value to the final value.
+          pt.SetRemovedSentinel();
         }
       } while (i != 0);
 
       // We need to restyle even if the transition rule no longer
       // applies (in which case we just made it not apply).
       mPresContext->PresShell()->RestyleForAnimation(et->mElement);
 
       if (et->mPropertyTransitions.IsEmpty()) {
diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -138,16 +138,17 @@ _TEST_FILES =	test_acid3_test46.html \
 		test_style_struct_copy_constructors.html \
 		test_system_font_serialization.html \
 		test_transitions_computed_values.html \
 		test_transitions_computed_value_combinations.html \
 		test_transitions_events.html \
 		test_transitions.html \
 		test_transitions_per_property.html \
 		test_transitions_dynamic_changes.html \
+		test_transitions_bug537151.html \
 		test_units_angle.html \
 		test_units_frequency.html \
 		test_units_length.html \
 		test_units_time.html \
 		test_value_cloning.html \
 		test_value_computation.html \
 		test_value_storage.html \
 		test_visited_pref.html \
diff --git a/layout/style/test/test_transitions_bug537151.html b/layout/style/test/test_transitions_bug537151.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_transitions_bug537151.html
@@ -0,0 +1,51 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=537151
+-->
+<head>
+  <title>Test for Bug 537151</title>
+  <script type="application/javascript" src="/MochiKit/packed.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+  <style type="text/css">
+
+  #display {
+    -moz-transition: margin-left 200ms;
+  }
+
+  </style>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=537151">Mozilla Bug 537151</a>
+<p id="display">Paragraph</p>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 537151 **/
+
+SimpleTest.waitForExplicitFinish();
+
+var p = document.getElementById("display");
+p.addEventListener("transitionend", listener, false);
+var ignored = getComputedStyle(p, "").marginLeft;
+p.style.marginLeft = "150px";
+
+var event_count = 0;
+function listener(event)
+{
+  ++event_count;
+  setTimeout(finish, 400);
+  p.style.color = "blue";
+}
+
+function finish()
+{
+  is(event_count, 1, "should have gotten only 1 transitionend event");
+  SimpleTest.finish();
+}
+
+</script>
+</pre>
+</body>
+</html>
