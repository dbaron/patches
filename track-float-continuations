From: L. David Baron <dbaron@dbaron.org>

Track which frames were float continuations that need to be pulled to the next block rather than figuring it out again when it's time to pull them.  (This allows first-in-flows to be float continuations.)  (Bug 563584)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1009,18 +1009,19 @@ nsBlockFrame::Reflow(nsPresContext*     
   rv = ReflowDirtyLines(state);
   NS_ASSERTION(NS_SUCCEEDED(rv), "reflow dirty lines failed");
   if (NS_FAILED(rv)) return rv;
 
   NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
   NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
 
   // Put continued floats at the end of mFloats
-  if (state.mFloatContinuations.NotEmpty())
+  if (state.mFloatContinuations.NotEmpty()) {
     mFloats.AppendFrames(nsnull, state.mFloatContinuations);
+  }
 
   // If we end in a BR with clear and affected floats continue,
   // we need to continue, too.
   if (NS_UNCONSTRAINEDSIZE != aReflowState.availableHeight &&
       NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
       state.mFloatManager->ClearContinues(FindTrailingClear())) {
     NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
   }
@@ -3958,34 +3959,37 @@ nsBlockFrame::CreateContinuationFor(nsBl
   return NS_OK;
 }
 
 nsresult
 nsBlockFrame::SplitFloat(nsBlockReflowState& aState,
                          nsIFrame*           aFloat,
                          nsReflowStatus      aFloatStatus)
 {
-  nsIFrame* nextInFlow = nsnull;
-  if (!aFloat->GetNextInFlow()) {
+  nsIFrame* nextInFlow = aFloat->GetNextInFlow();
+  if (nextInFlow) {
+    nsContainerFrame *oldParent =
+      static_cast<nsContainerFrame*>(nextInFlow->GetParent());
+    nsresult rv = oldParent->StealFrame(aState.mPresContext, nextInFlow);
+    NS_ASSERTION(NS_SUCCEEDED(rv), "StealFrame failed");
+    ReparentFrame(nextInFlow, oldParent, this);
+  } else {
     nsresult rv = aState.mPresContext->PresShell()->FrameConstructor()->
       CreateContinuingFrame(aState.mPresContext, aFloat, this, &nextInFlow);
     NS_ENSURE_SUCCESS(rv, rv);
   }
   if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aFloatStatus))
     aFloat->GetNextInFlow()->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
 
   // Float continuations can only trigger overflow
   NS_FRAME_SET_OVERFLOW_INCOMPLETE(aFloatStatus);
   // Make sure the containing block knows about the float's status
   NS_MergeReflowStatusInto(&aState.mReflowStatus, aFloatStatus);
 
-  if (nextInFlow) {
-    // Next in flow was created above.
-    aState.AppendFloatContinuation(nextInFlow);
-  }
+  aState.AppendFloatContinuation(nextInFlow);
   return NS_OK;
 }
 
 static nsFloatCache*
 GetLastFloat(nsLineBox* aLine)
 {
   nsFloatCache* fc = aLine->GetFirstFloat();
   while (fc && fc->Next()) {
@@ -4491,63 +4495,67 @@ nsBlockFrame::DrainOverflowLines(nsBlock
     }
     delete ourOverflowLines;
   }
 
   return PR_TRUE;
 }
 
 // This function assumes our prev-in-flow has completed reflow and its
-// mFloats contains at most two frames that belong to the same flow chain,
-// the second one being a last-in-flow continuation intended for this block.
+// mFloats may contain frames at the end of its float list, marked with
+// NS_BLOCK_IS_FLOAT_CONTINUATION, that should be pulled to this block.
 void
 nsBlockFrame::DrainFloatContinuations(nsBlockReflowState& aState)
 {
   // Cache any continuations of our own floats that we're still holding onto
   // so they're out of the way. This should only happen if we're re-Reflow'd
   // before our next-in-flow gets a chance to pull these continuations.
-  nsFrameList floatContinuations;
-  nsPresContext* presContext = PresContext();
-  for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
-    nsIFrame* nif = f->GetNextInFlow();
-    if (!nif) continue;
-    if (nif->GetParent() == this) {
-      NS_ASSERTION(!nif->GetNextInFlow(),
-                   "Unexpected next-in-flow for float continuation");
-      StealFrame(presContext, nif);
-      floatContinuations.AppendFrame(nsnull, nif);
-    }
-  }
-  if (floatContinuations.NotEmpty()) {
+  // FIXME: This is not compatible with doing float breaking in dynamic
+  // situations, since in those situations we could have current
+  // continuations at the end of our float list that were actually
+  // continuations from a previous frame to this one.  (However, it's
+  // not clear to me that we really need this code in the first place;
+  // the best solution might just be to remove it.)
+  nsIFrame *f = mFloats.LastChild();
+  if (f && (f->GetStateBits() & NS_BLOCK_IS_FLOAT_CONTINUATION)) {
+    do {
+      f = f->GetPrevSibling();
+    } while (f && (f->GetStateBits() & NS_BLOCK_IS_FLOAT_CONTINUATION));
     aState.SetupFloatContinuationList();
-    aState.mFloatContinuations.AppendFrames(nsnull, floatContinuations);
+    if (f) {
+      nsFrameList floatContinuations = mFloats.RemoveFramesAfter(f);
+      aState.mFloatContinuations.AppendFrames(nsnull, floatContinuations);
+    } else {
+      // Move all of mFloats.
+      aState.mFloatContinuations.AppendFrames(nsnull, mFloats);
+    }
   }
 
   // Walk our prev-in-flow's floats and prepend their continuations to our
   // floats list. This pulls any continuations we need to take from our
   // prev-in-flow and makes sure our continuations of its floats are in the
   // proper order.
   nsBlockFrame* prevBlock = static_cast<nsBlockFrame*>(GetPrevInFlow());
   if (!prevBlock)
     return;
-  for (nsIFrame* pf = prevBlock->mFloats.FirstChild(); pf; pf = pf->GetNextSibling()) {
-    nsIFrame* nif = pf->GetNextInFlow();
-    if (!nif)
-      continue;
-    nsContainerFrame* nifParent = static_cast<nsContainerFrame*>(nif->GetParent());
-    nifParent->StealFrame(presContext, nif);
-    if (nif->GetParent() != this) {
-      NS_ASSERTION(!nif->GetNextInFlow(),
-                   "Unexpected next-in-flow for float continuation");
-      ReparentFrame(nif, nifParent, this);
-    }
-    floatContinuations.AppendFrame(this, nif);
-  }
-  if (floatContinuations.NotEmpty())
-    mFloats.InsertFrames(nsnull, nsnull, floatContinuations);
+  f = prevBlock->mFloats.LastChild();
+  if (f && (f->GetStateBits() & NS_BLOCK_IS_FLOAT_CONTINUATION)) {
+    do {
+      ReparentFrame(f, prevBlock, this);
+      f = f->GetPrevSibling();
+    } while (f && (f->GetStateBits() & NS_BLOCK_IS_FLOAT_CONTINUATION));
+
+    if (f) {
+      nsFrameList floatContinuations = prevBlock->mFloats.RemoveFramesAfter(f);
+      mFloats.InsertFrames(nsnull, nsnull, floatContinuations);
+    } else {
+      // Move all of prevBlock->mFloats.
+      mFloats.InsertFrames(nsnull, nsnull, prevBlock->mFloats);
+    }
+  }
 
 #ifdef DEBUG
   for (nsIFrame* f = mFloats.FirstChild(); f ; f = f->GetNextSibling()) {
     for (nsIFrame* c = f->GetFirstInFlow(); c ; c = c->GetNextInFlow()) {
       NS_ASSERTION(c == f || c->GetParent() != this || !mFloats.ContainsFrame(c),
                    "Two floats with same parent in same floats list, expect weird errors.");
     }
   }
@@ -5770,17 +5778,18 @@ nsBlockFrame::FindTrailingClear()
 }
 
 nsresult
 nsBlockFrame::ReflowFloatContinuations(nsBlockReflowState& aState,
                                        nsRect&             aBounds,
                                        nsReflowStatus&     aStatus)
 {
   nsresult rv = NS_OK;
-  for (nsIFrame* f = mFloats.FirstChild(); f && f->GetPrevInFlow();
+  for (nsIFrame* f = mFloats.FirstChild();
+       f && (f->GetStateBits() & NS_BLOCK_IS_FLOAT_CONTINUATION);
        f = f->GetNextSibling()) {
     if (NS_SUBTREE_DIRTY(f) || aState.mReflowState.ShouldReflowAllKids()) {
       // Cache old bounds
       nsRect oldRect = f->GetRect();
       nsRect oldOverflow = f->GetOverflowRect();
 
       // Reflow
       nsReflowStatus fStatus = NS_FRAME_COMPLETE;
@@ -6095,17 +6104,17 @@ nsBlockFrame::BuildDisplayList(nsDisplay
   }
 #endif
 
   DisplayBorderBackgroundOutline(aBuilder, aLists);
 
   if (GetPrevInFlow()) {
     DisplayOverflowContainers(aBuilder, aDirtyRect, aLists);
     for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
-      if (f->GetPrevInFlow())
+      if (f->GetStateBits() & NS_BLOCK_IS_FLOAT_CONTINUATION)
          BuildDisplayListForChild(aBuilder, f, aDirtyRect, aLists);
     }
   }
 
   aBuilder->MarkFramesForDisplayList(this, mFloats, aDirtyRect);
   aBuilder->MarkFramesForDisplayList(this, mAbsoluteContainer.GetChildList(),
                                      aDirtyRect);
 
@@ -6752,17 +6761,17 @@ nsBlockFrame::CheckFloats(nsBlockReflowS
       anyLineDirty = PR_TRUE;
     }
   }
   
   nsAutoTArray<nsIFrame*, 8> storedFloats;
   PRBool equal = PR_TRUE;
   PRUint32 i = 0;
   for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
-    if (f->GetPrevInFlow())
+    if (f->GetStateBits() & NS_BLOCK_IS_FLOAT_CONTINUATION)
       continue;
     storedFloats.AppendElement(f);
     if (i < lineFloats.Length() && lineFloats.ElementAt(i) != f) {
       equal = PR_FALSE;
     }
     ++i;
   }
 
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -92,17 +92,27 @@ class nsIntervalSet;
  * flow frames whose placeholders are in the overflow list.
  * -- A given piece of content has at most one placeholder
  * frame in a block's normal child list.
  * -- While a block is being reflowed, it may have a FloatContinuationProperty
  * frame property that points to an nsFrameList in its
  * nsBlockReflowState. This list contains continuations for
  * floats whose prev-in-flow is in the block's regular float
  * list. The list is always empty/non-existent after the
- * block has been reflowed.
+ * block has been reflowed.  (However, after it has been
+ * reflowed and before the continuations are moved to the
+ * next block, they are temporarily at the end of the
+ * block's float list.  FIXME: This temporary storage
+ * situation is not compatible with doing float breaking in
+ * dynamic cases, since we can't distinguish unflushed
+ * temporary storage (floats being transferred from the
+ * frame) in a case where we need a second reflow from
+ * frames previously transferred to the frame; fixing this
+ * would require an additional frame list for this temporary
+ * storage.)
  * -- In all these frame lists, if there are two frames for
  * the same content appearing in the list, then the frames
  * appear with the prev-in-flow before the next-in-flow.
  * -- While reflowing a block, its overflow line list
  * will usually be empty but in some cases will have lines
  * (while we reflow the block at its shrink-wrap width).
  * In this case any new overflowing content must be
  * prepended to the overflow lines.
@@ -120,16 +130,22 @@ class nsIntervalSet;
 #define NS_BLOCK_HAS_OVERFLOW_LINES         0x02000000
 #define NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS  0x04000000
 
 // Set on any block that has descendant frames in the normal
 // flow with 'clear' set to something other than 'none'
 // (including <BR CLEAR="..."> frames)
 #define NS_BLOCK_HAS_CLEAR_CHILDREN         0x08000000
 
+// This bit is set on floats whose parent does not contain their
+// placeholder.  This can happen for two reasons:  (1) the float was
+// split, and this piece is the continuation, or (2) the entire float
+// didn't fit on the page.
+#define NS_BLOCK_IS_FLOAT_CONTINUATION      0x10000000
+
 #define nsBlockFrameSuper nsHTMLContainerFrame
 
 /*
  * Base class for block and inline frames.
  * The block frame has an additional named child list:
  * - "Absolute-list" which contains the absolutely positioned frames
  *
  * @see nsGkAtoms::absoluteList
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -259,16 +259,17 @@ public:
   // they move to the end of the mFloats list.
   nsFrameList mFloatContinuations;
   // This method makes sure float continuations are accessible to
   // StealFrame. Call it before adding any frames to mFloatContinuations.
   void SetupFloatContinuationList();
   // Use this method to append to mFloatContinuations.
   void AppendFloatContinuation(nsIFrame* aFloatCont) {
     SetupFloatContinuationList();
+    aFloatCont->AddStateBits(NS_BLOCK_IS_FLOAT_CONTINUATION);
     mFloatContinuations.AppendFrame(mBlock, aFloatCont);
   }
 
   // Track child overflow continuations.
   nsOverflowContinuationTracker* mOverflowTracker;
 
   //----------------------------------------
 
