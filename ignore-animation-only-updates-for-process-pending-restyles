From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Use SetInAnimationOnlyStyleUpdate for ProcessPendingRestyles runs that are only updating animation data.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1508,19 +1508,37 @@ RestyleManager::ProcessPendingRestyles()
   NS_ABORT_IF_FALSE(!mPresContext->IsProcessingRestyles(),
                     "Nesting calls to ProcessPendingRestyles?");
   mPresContext->SetProcessingRestyles(true);
 
   // Before we process any restyles, we need to ensure that style
   // resulting from any animations is up-to-date, so that if any style
   // changes we cause trigger transitions, we have the correct old style
   // for starting the transition.
-  if (mHavePendingNonAnimationRestyles) {
+  bool haveNonAnimation = mHavePendingNonAnimationRestyles;
+  if (haveNonAnimation) {
     ++mAnimationGeneration;
     UpdateOnlyAnimationStyles();
+  } else {
+    // If we don't have non-animation style updates, then we have queued
+    // up animation style updates from the refresh driver tick.  This
+    // doesn't necessarily include *all* animation style updates, since
+    // we might be suppressing main-thread updates for some animations,
+    // so we don't want to call UpdateOnlyAnimationStyles, which updates
+    // all animations.
+    //
+    // So we want to act here as though we're in an animation-only style
+    // update and suppress changes to transitions, since we're really
+    // doing *part* of UpdateOnlyAnimationStyles.
+    //
+    // FIXME: In the future, we might want to refactor the way the
+    // animation and transition manager do their refresh driver ticks so
+    // that we can use UpdateOnlyAnimationStyles, with a different
+    // boolean argument, for this update as well.
+    mPresContext->TransitionManager()->SetInAnimationOnlyStyleUpdate(true);
   }
 
   mPendingRestyles.ProcessRestyles();
 
 #ifdef DEBUG
   uint32_t oldPendingRestyleCount = mPendingRestyles.Count();
 #endif
 
@@ -1531,21 +1549,27 @@ RestyleManager::ProcessPendingRestyles()
   // restyle-with-animation any just-restyled elements that are
   // mid-transition (since processing the non-animation restyle ignores
   // the running transition so it can check for a new change on the same
   // property, and then posts an immediate animation style change).
   mPresContext->SetProcessingAnimationStyleChange(true);
   mPendingAnimationRestyles.ProcessRestyles();
   mPresContext->SetProcessingAnimationStyleChange(false);
 
+  if (!haveNonAnimation) {
+    mPresContext->TransitionManager()->SetInAnimationOnlyStyleUpdate(false);
+  }
+
   mPresContext->SetProcessingRestyles(false);
   NS_POSTCONDITION(mPendingRestyles.Count() == oldPendingRestyleCount,
                    "We should not have posted new non-animation restyles while "
                    "processing animation restyles");
 
+  NS_ASSERTION(haveNonAnimation == mHavePendingNonAnimationRestyles,
+               "should not have added restyles");
   mHavePendingNonAnimationRestyles = false;
 
   if (mRebuildAllStyleData) {
     // We probably wasted a lot of work up above, but this seems safest
     // and it should be rarely used.
     // This might add us as a refresh observer again; that's ok.
     RebuildAllStyleData(nsChangeHint(0));
   }
