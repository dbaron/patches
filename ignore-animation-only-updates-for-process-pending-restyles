From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Use SetInAnimationOnlyStyleUpdate for ProcessPendingRestyles runs that are only updating animation data.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1532,19 +1532,37 @@ RestyleManager::RebuildAllStyleData(nsCh
   presShell->GetDocument()->FlushPendingNotifications(Flush_ContentAndNotify);
 
   nsAutoScriptBlocker scriptBlocker;
 
   // Before we process any restyles, we need to ensure that style
   // resulting from any animations is up-to-date, so that if any style
   // changes we cause trigger transitions, we have the correct old style
   // for starting the transition.
-  if (mHavePendingNonAnimationRestyles) {
+  bool haveNonAnimation = mHavePendingNonAnimationRestyles;
+  if (haveNonAnimation) {
     IncrementAnimationGeneration();
     UpdateOnlyAnimationStyles();
+  } else {
+    // If we don't have non-animation style updates, then we have queued
+    // up animation style updates from the refresh driver tick.  This
+    // doesn't necessarily include *all* animation style updates, since
+    // we might be suppressing main-thread updates for some animations,
+    // so we don't want to call UpdateOnlyAnimationStyles, which updates
+    // all animations.
+    //
+    // So we want to act here as though we're in an animation-only style
+    // update and suppress changes to transitions, since we're really
+    // doing *part* of UpdateOnlyAnimationStyles.
+    //
+    // FIXME: In the future, we might want to refactor the way the
+    // animation and transition manager do their refresh driver ticks so
+    // that we can use UpdateOnlyAnimationStyles, with a different
+    // boolean argument, for this update as well.
+    mPresContext->TransitionManager()->SetInAnimationOnlyStyleUpdate(true);
   }
 
   MOZ_ASSERT(!mIsProcessingRestyles, "Nesting calls to processing restyles");
 #ifdef DEBUG
   mIsProcessingRestyles = true;
 #endif
 
   // Until we get rid of these phases in bug 960465, we need to skip
@@ -1566,16 +1584,20 @@ RestyleManager::RebuildAllStyleData(nsCh
   }
 
   mPostAnimationRestyles = false;
   mSkipAnimationRules = false;
 #ifdef DEBUG
   mIsProcessingRestyles = false;
 #endif
 
+  if (!haveNonAnimation) {
+    mPresContext->TransitionManager()->SetInAnimationOnlyStyleUpdate(false);
+  }
+
   // Make sure that we process any pending animation restyles from the
   // above style change.  Note that we can *almost* implement the above
   // by just posting a style change -- except we really need to restyle
   // the root frame rather than the root element's primary frame.
   ProcessPendingRestyles();
 }
 
 void
@@ -1655,19 +1677,37 @@ RestyleManager::ProcessPendingRestyles()
 #ifdef DEBUG
   mIsProcessingRestyles = true;
 #endif
 
   // Before we process any restyles, we need to ensure that style
   // resulting from any animations is up-to-date, so that if any style
   // changes we cause trigger transitions, we have the correct old style
   // for starting the transition.
-  if (mHavePendingNonAnimationRestyles) {
+  bool haveNonAnimation = mHavePendingNonAnimationRestyles;
+  if (haveNonAnimation) {
     IncrementAnimationGeneration();
     UpdateOnlyAnimationStyles();
+  } else {
+    // If we don't have non-animation style updates, then we have queued
+    // up animation style updates from the refresh driver tick.  This
+    // doesn't necessarily include *all* animation style updates, since
+    // we might be suppressing main-thread updates for some animations,
+    // so we don't want to call UpdateOnlyAnimationStyles, which updates
+    // all animations.
+    //
+    // So we want to act here as though we're in an animation-only style
+    // update and suppress changes to transitions, since we're really
+    // doing *part* of UpdateOnlyAnimationStyles.
+    //
+    // FIXME: In the future, we might want to refactor the way the
+    // animation and transition manager do their refresh driver ticks so
+    // that we can use UpdateOnlyAnimationStyles, with a different
+    // boolean argument, for this update as well.
+    mPresContext->TransitionManager()->SetInAnimationOnlyStyleUpdate(true);
   }
 
   // Until we get rid of these phases in bug 960465, we need to skip
   // animation restyles during the non-animation phase, and post
   // animation restyles so that we restyle those elements again in the
   // animation phase.
   mSkipAnimationRules = true;
   mPostAnimationRestyles = true;
@@ -1690,23 +1730,29 @@ RestyleManager::ProcessPendingRestyles()
   // the running transition so it can check for a new change on the same
   // property, and then posts an immediate animation style change).
   MOZ_ASSERT(!mIsProcessingAnimationStyleChange, "nesting forbidden");
   mIsProcessingAnimationStyleChange = true;
   mPendingAnimationRestyles.ProcessRestyles();
   MOZ_ASSERT(mIsProcessingAnimationStyleChange, "nesting forbidden");
   mIsProcessingAnimationStyleChange = false;
 
+  if (!haveNonAnimation) {
+    mPresContext->TransitionManager()->SetInAnimationOnlyStyleUpdate(false);
+  }
+
 #ifdef DEBUG
   mIsProcessingRestyles = false;
 #endif
   NS_POSTCONDITION(mPendingRestyles.Count() == oldPendingRestyleCount,
                    "We should not have posted new non-animation restyles while "
                    "processing animation restyles");
 
+  NS_ASSERTION(haveNonAnimation == mHavePendingNonAnimationRestyles,
+               "should not have added restyles");
   mHavePendingNonAnimationRestyles = false;
 
   if (mRebuildAllStyleData) {
     // We probably wasted a lot of work up above, but this seems safest
     // and it should be rarely used.
     // This might add us as a refresh observer again; that's ok.
     RebuildAllStyleData(nsChangeHint(0), nsRestyleHint(0));
   }
