From: L. David Baron <dbaron@dbaron.org>

Allow the float manager to record that a float has been pushed past a break.  (Bug 563584)  (FIXME: need tests for lowest-top and for clear)

diff --git a/layout/generic/nsFloatManager.cpp b/layout/generic/nsFloatManager.cpp
--- a/layout/generic/nsFloatManager.cpp
+++ b/layout/generic/nsFloatManager.cpp
@@ -67,17 +67,19 @@ PSArenaFreeCB(size_t aSize, void* aPtr, 
   static_cast<nsIPresShell*>(aClosure)->FreeMisc(aSize, aPtr);
 }
 
 /////////////////////////////////////////////////////////////////////////////
 // nsFloatManager
 
 nsFloatManager::nsFloatManager(nsIPresShell* aPresShell)
   : mX(0), mY(0),
-    mFloatDamage(PSArenaAllocCB, PSArenaFreeCB, aPresShell)
+    mFloatDamage(PSArenaAllocCB, PSArenaFreeCB, aPresShell),
+    mPushedLeftFloatPastBreak(PR_FALSE),
+    mPushedRightFloatPastBreak(PR_FALSE)
 {
   MOZ_COUNT_CTOR(nsFloatManager);
 }
 
 nsFloatManager::~nsFloatManager()
 {
   MOZ_COUNT_DTOR(nsFloatManager);
 }
@@ -410,35 +412,42 @@ nsFloatManager::PushState(SavedState* aS
   // since that could lead to bugs where damage is missed/dropped when
   // we move from position A to B (during the intermediate incremental
   // reflow mentioned above) and then from B to C during the subsequent
   // reflow. In the typical case A and C will be the same, but not always.
   // Allowing mFloatDamage to accumulate the damage incurred during both
   // reflows ensures that nothing gets missed.
   aState->mX = mX;
   aState->mY = mY;
+  aState->mPushedLeftFloatPastBreak = mPushedLeftFloatPastBreak;
+  aState->mPushedRightFloatPastBreak = mPushedRightFloatPastBreak;
   aState->mFloatInfoCount = mFloats.Length();
 }
 
 void
 nsFloatManager::PopState(SavedState* aState)
 {
   NS_PRECONDITION(aState, "No state to restore?");
 
   mX = aState->mX;
   mY = aState->mY;
+  mPushedLeftFloatPastBreak = aState->mPushedLeftFloatPastBreak;
+  mPushedRightFloatPastBreak = aState->mPushedRightFloatPastBreak;
 
   NS_ASSERTION(aState->mFloatInfoCount <= mFloats.Length(),
                "somebody misused PushState/PopState");
   mFloats.TruncateLength(aState->mFloatInfoCount);
 }
 
 nscoord
 nsFloatManager::GetLowestFloatTop() const
 {
+  if (mPushedLeftFloatPastBreak || mPushedRightFloatPastBreak) {
+    return nscoord_MAX;
+  }
   if (!HasAnyFloats()) {
     return nscoord_MIN;
   }
   return mFloats[mFloats.Length() - 1].mRect.y - mY;
 }
 
 #ifdef DEBUG
 void
@@ -462,16 +471,19 @@ nsFloatManager::List(FILE* out) const
   }
   return NS_OK;
 }
 #endif
 
 nscoord
 nsFloatManager::ClearFloats(nscoord aY, PRUint8 aBreakType) const
 {
+  if (ClearContinues(aBreakType)) {
+    return nscoord_MAX;
+  }
   if (!HasAnyFloats()) {
     return aY;
   }
 
   nscoord bottom = aY + mY;
 
   const FloatInfo &tail = mFloats[mFloats.Length() - 1];
   switch (aBreakType) {
@@ -493,18 +505,29 @@ nsFloatManager::ClearFloats(nscoord aY, 
   bottom -= mY;
 
   return bottom;
 }
 
 PRBool
 nsFloatManager::ClearContinues(PRUint8 aBreakType) const
 {
+  if ((mPushedLeftFloatPastBreak &&
+       (aBreakType == NS_STYLE_CLEAR_LEFT_AND_RIGHT ||
+        aBreakType == NS_STYLE_CLEAR_LEFT)) ||
+      (mPushedRightFloatPastBreak &&
+       (aBreakType == NS_STYLE_CLEAR_LEFT_AND_RIGHT ||
+        aBreakType == NS_STYLE_CLEAR_RIGHT))) {
+    return PR_TRUE;
+  }
   if (!HasAnyFloats() || aBreakType == NS_STYLE_CLEAR_NONE)
     return PR_FALSE;
+  // FIXME: We could make this faster by recording whenever we split a
+  // float (in addition to recording whenever we push a float in its
+  // entirety).
   for (PRUint32 i = mFloats.Length(); i > 0; i--) {
     nsIFrame* f = mFloats[i-1].mFrame;
     if (f->GetNextInFlow()) {
       if (aBreakType == NS_STYLE_CLEAR_LEFT_AND_RIGHT)
         return PR_TRUE;
       PRUint8 floatSide = f->GetStyleDisplay()->mFloats;
       if ((aBreakType == NS_STYLE_CLEAR_LEFT &&
            floatSide == NS_STYLE_FLOAT_LEFT) ||
diff --git a/layout/generic/nsFloatManager.h b/layout/generic/nsFloatManager.h
--- a/layout/generic/nsFloatManager.h
+++ b/layout/generic/nsFloatManager.h
@@ -106,17 +106,19 @@ public:
   // Structure that stores the current state of a frame manager for
   // Save/Restore purposes.
   struct SavedState;
   friend struct SavedState;
   struct SavedState {
   private:
     PRUint32 mFloatInfoCount;
     nscoord mX, mY;
-    
+    PRPackedBool mPushedLeftFloatPastBreak;
+    PRPackedBool mPushedRightFloatPastBreak;
+
     friend class nsFloatManager;
   };
 
   /**
    * Translate the current origin by the specified (dx, dy). This
    * creates a new local coordinate space relative to the current
    * coordinate space.
    */
@@ -177,16 +179,27 @@ public:
    * must be even with or below the top of all previous floats.
    *
    * aMarginRect is relative to the current translation.  The caller
    * must ensure aMarginRect.height >= 0 and aMarginRect.width >= 0.
    */
   nsresult AddFloat(nsIFrame* aFloatFrame, const nsRect& aMarginRect);
 
   /**
+   * Notify that we tried to place a float that could not fit at all and
+   * had to be pushed to the next page/column?  (If so, we can't place
+   * any more floats in this page/column because of the rule that the
+   * top of a float cannot be above the top of an earlier float.)
+   */
+  void SetPushedLeftFloatPastBreak()
+    { mPushedLeftFloatPastBreak = PR_TRUE; }
+  void SetPushedRightFloatPastBreak()
+    { mPushedRightFloatPastBreak = PR_TRUE; }
+
+  /**
    * Remove the regions associated with this floating frame and its
    * next-sibling list.  Some of the frames may never have been added;
    * we just skip those. This is not fully general; it only works as
    * long as the N frames to be removed are the last N frames to have
    * been added; if there's a frame in the middle of them that should
    * not be removed, YOU LOSE.
    */
   nsresult RemoveTrailingRegions(nsIFrame* aFrameList);
@@ -254,16 +267,20 @@ public:
    * Checks if clear would pass into the floats' BFC's next-in-flow,
    * i.e. whether floats affecting this clear have continuations.
    */
   PRBool ClearContinues(PRUint8 aBreakType) const;
 
   void AssertStateMatches(SavedState *aState) const
   {
     NS_ASSERTION(aState->mX == mX && aState->mY == mY &&
+                 aState->mPushedLeftFloatPastBreak ==
+                   mPushedLeftFloatPastBreak &&
+                 aState->mPushedRightFloatPastBreak ==
+                   mPushedRightFloatPastBreak &&
                  aState->mFloatInfoCount == mFloats.Length(),
                  "float manager state should match saved state");
   }
 
 #ifdef DEBUG
   /**
    * Dump the state of the float manager out to a file.
    */
@@ -284,16 +301,25 @@ private:
     ~FloatInfo();
 #endif
   };
 
   nscoord         mX, mY;     // translation from local to global coordinate space
   nsTArray<FloatInfo> mFloats;
   nsIntervalSet   mFloatDamage;
 
+  // Did we try to place a float that could not fit at all and had to be
+  // pushed to the next page/column?  If so, we can't place any more
+  // floats in this page/column because of the rule that the top of a
+  // float cannot be above the top of an earlier float.  And we also
+  // need to apply this information to 'clear', and thus need to
+  // separate left and right floats.
+  PRPackedBool mPushedLeftFloatPastBreak;
+  PRPackedBool mPushedRightFloatPastBreak;
+
   static PRInt32 sCachedFloatManagerCount;
   static void* sCachedFloatManagers[NS_FLOAT_MANAGER_CACHE_SIZE];
 
   nsFloatManager(const nsFloatManager&);  // no implementation
   void operator=(const nsFloatManager&);  // no implementation
 };
 
 /**
