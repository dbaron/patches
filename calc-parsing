From: L. David Baron <dbaron@dbaron.org>

Implement parsing of calc().

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -109,16 +109,17 @@
 #define VARIANT_NORMAL          0x080000  // M
 #define VARIANT_SYSFONT         0x100000  // eCSSUnit_System_Font
 #define VARIANT_GRADIENT        0x200000  // eCSSUnit_Gradient
 #define VARIANT_CUBIC_BEZIER    0x400000  // CSS transition timing function
 #define VARIANT_ALL             0x800000  //
 #define VARIANT_IMAGE_RECT    0x01000000  // eCSSUnit_Function
 // This is an extra bit that says that a VARIANT_ANGLE allows unitless zero:
 #define VARIANT_ZERO_ANGLE    0x02000000  // unitless zero for angles
+#define VARIANT_CALC          0x04000000  // eCSSUnit_Calc
 
 // Common combinations of variants
 #define VARIANT_AL   (VARIANT_AUTO | VARIANT_LENGTH)
 #define VARIANT_LP   (VARIANT_LENGTH | VARIANT_PERCENT)
 #define VARIANT_AH   (VARIANT_AUTO | VARIANT_INHERIT)
 #define VARIANT_AHLP (VARIANT_AH | VARIANT_LP)
 #define VARIANT_AHI  (VARIANT_AH | VARIANT_INTEGER)
 #define VARIANT_AHK  (VARIANT_AH | VARIANT_KEYWORD)
@@ -458,16 +459,28 @@ protected:
   PRBool ParseBorderImage();
   PRBool ParseBorderSpacing();
   PRBool ParseBorderSide(const nsCSSProperty aPropIDs[],
                          PRBool aSetAllSides);
   PRBool ParseDirectionalBorderSide(const nsCSSProperty aPropIDs[],
                                     PRInt32 aSourceType);
   PRBool ParseBorderStyle();
   PRBool ParseBorderWidth();
+
+  PRBool ParseCalc(nsCSSValue &aValue, PRInt32 aVariantMask);
+  PRBool ParseCalcValueAdditiveExpression(nsCSSValue& aValue,
+                                          PRInt32 aVariantMask);
+  PRBool ParseCalcValueMultiplicativeExpression(nsCSSValue& aValue,
+                                                PRInt32 aVariantMask);
+  PRBool ParseCalcValueTerm(nsCSSValue& aValue, PRInt32 aVariantMask);
+  PRBool ParseCalcNumberAdditiveExpression(nsCSSValue& aValue);
+  PRBool ParseCalcNumberMultiplicativeExpression(nsCSSValue& aValue);
+  PRBool ParseCalcNumberTerm(nsCSSValue& aValue);
+  PRBool RequireWhitespace();
+
   // for 'clip' and '-moz-image-region'
   PRBool ParseRect(nsCSSRect& aRect,
                    nsCSSProperty aPropID);
   PRBool DoParseRect(nsCSSRect& aRect);
   PRBool ParseContent();
   PRBool ParseCounterData(nsCSSValuePairList** aResult,
                           nsCSSProperty aPropID);
   PRBool ParseCue();
@@ -4349,16 +4362,19 @@ CSSParserImpl::TranslateDimension(nsCSSV
   }
   if ((type & aVariantMask) != 0) {
     aValue.SetFloatValue(aNumber, units);
     return PR_TRUE;
   }
   return PR_FALSE;
 }
 
+// This explicitly does not include VARIANT_CALC, which we do consider
+// numeric.  If we support calc() on properties requiring nonnegative or
+// positive values, we need to figure out what the requirements are.
 #define VARIANT_ALL_NONNUMERIC \
   VARIANT_KEYWORD | \
   VARIANT_COLOR | \
   VARIANT_URL | \
   VARIANT_STRING | \
   VARIANT_COUNTER | \
   VARIANT_ATTR | \
   VARIANT_IDENTIFIER | \
@@ -4624,16 +4640,24 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
     return ParseAttr(aValue);
   }
   if (((aVariantMask & VARIANT_CUBIC_BEZIER) != 0) &&
       (eCSSToken_Function == tk->mType)) {
      if (tk->mIdent.LowerCaseEqualsLiteral("cubic-bezier")) {
       return ParseTransitionTimingFunctionValues(aValue);
     }
   }
+  if ((aVariantMask & VARIANT_CALC) &&
+      (eCSSToken_Function == tk->mType) &&
+      (tk->mIdent.LowerCaseEqualsLiteral("-moz-calc") ||
+       tk->mIdent.LowerCaseEqualsLiteral("-moz-min") ||
+       tk->mIdent.LowerCaseEqualsLiteral("-moz-max"))) {
+    // calc() currently allows only lengths and percents inside it.
+    return ParseCalc(aValue, aVariantMask & VARIANT_LP);
+  }
 
   UngetToken();
   return PR_FALSE;
 }
 
 
 PRBool
 CSSParserImpl::ParseCounter(nsCSSValue& aValue)
@@ -7114,16 +7138,187 @@ CSSParserImpl::ParseBorderColors(nsCSSVa
       break;
     }
   }
   // Have failure case at the end so we can |break| to get to it.
   delete list;
   return PR_FALSE;
 }
 
+// Parse the top level of a calc() expression, which can be calc(),
+// min(), or max().
+PRBool
+CSSParserImpl::ParseCalc(nsCSSValue &aValue, PRInt32 aVariantMask)
+{
+  nsCSSUnit unit;
+  if (mToken.mIdent.LowerCaseEqualsLiteral("-moz-min")) {
+    unit = eCSSUnit_Calc_Minimum;
+  } else if (mToken.mIdent.LowerCaseEqualsLiteral("-moz-max")) {
+    unit = eCSSUnit_Calc_Maximum;
+  } else {
+    NS_ASSERTION(mToken.mIdent.LowerCaseEqualsLiteral("-moz-calc"),
+                 "unexpected function");
+    unit = eCSSUnit_Calc;
+  }
+
+  PRBool res = ExpectSymbol('(', PR_FALSE);
+  NS_ABORT_IF_FALSE(res, "function token without open paren");
+
+  if (unit != eCSSUnit_Calc) {
+    // FIXME: WRITE HANDLING OF min() and max().
+    return PR_FALSE;
+  }
+
+  // One-iteration loop so we can break to the error-handling case.
+  do {
+    // The toplevel of a calc() is always an nsCSSValue::Array of length 1.
+    nsRefPtr<nsCSSValue::Array> val = nsCSSValue::Array::Create(1);
+    if (!val)
+      break;
+
+    if (!ParseCalcValueAdditiveExpression(val->Item(0), aVariantMask))
+      break;
+
+    if (!ExpectSymbol(')', PR_TRUE))
+      break;
+
+    aValue.SetArrayValue(val, eCSSUnit_Calc);
+    return PR_TRUE;
+  } while (PR_FALSE);
+
+  mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+  SkipUntil(')');
+  return PR_FALSE;
+}
+
+// We optimize away the <value-expression> production given that
+// ParseVariant consumes initial whitespace and we call
+// ExpectSymbol(')') with PR_TRUE for aSkipWS.
+// This function parses the <value-additive-expression> production
+// iteratively, but builds the correct recursive data structure.
+PRBool
+CSSParserImpl::ParseCalcValueAdditiveExpression(nsCSSValue& aValue,
+                                                PRInt32 aVariantMask)
+{
+  nsCSSValue *storage = &aValue;
+  for (;;) {
+    if (!ParseCalcValueMultiplicativeExpression(*storage, aVariantMask))
+      return PR_FALSE;
+
+    if (!RequireWhitespace() || !GetToken(PR_FALSE))
+      return PR_TRUE;
+    nsCSSUnit unit;
+    if (mToken.IsSymbol('+')) {
+      unit = eCSSUnit_Calc_Plus;
+    } else if (mToken.IsSymbol('-')) {
+      unit = eCSSUnit_Calc_Minus;
+    } else {
+      UngetToken();
+      return PR_TRUE;
+    }
+    if (!RequireWhitespace())
+      return PR_FALSE;
+
+    nsRefPtr<nsCSSValue::Array> val = nsCSSValue::Array::Create(2);
+    val->Item(0) = aValue;
+    storage = val->Item(1);
+    aValue.SetArrayValue(val, unit);
+  }
+}
+
+// This function parses the <value-multiplicative-expression> production
+// AND its interleaving with <number-multiplicative-expression>
+// iteratively, but builds the correct recursive data structure.
+PRBool
+CSSParserImpl::ParseCalcValueMultiplicativeExpression(nsCSSValue& aValue,
+                                                      PRInt32 aVariantMask)
+{
+  // Whether the next value can be the one with the unit.
+  PRBool valueAllowed = PR_TRUE;
+  // Whether we already got the one with the unit.
+  PRBool gotValue = PR_FALSE;
+
+  nsCSSValue *storage = &aValue;
+  for (;;) {
+    if (!GetToken(PR_TRUE))
+      return PR_FALSE;
+    PRBool isNumber = mToken.mType == eCSSToken_Number;
+    UngetToken();
+
+    if (isNumber) {
+      if (!ParseCalcNumberTerm(*storage))
+        return PR_FALSE;
+    } else {
+      if (!valueAllowed || !ParseCalcValueTerm(*storage, aVariantMask))
+        return PR_FALSE;
+    }
+
+    PRBool hadWS = RequireWhitespace();
+    if (!GetToken(PR_FALSE))
+      return gotValue;
+    nsCSSUnit unit;
+    if (mToken.IsSymbol('*')) {
+      unit = eCSSUnit_Calc_Times;
+      valueAllowed = !gotValue;
+    } else if (mToken.IsSymbol('/')) {
+      unit = eCSSUnit_Calc_Divided;
+      valueAllowed = PR_FALSE;
+    } else if (mToken.mType == eCSSToken_Ident &&
+               mToken.mIdent.LowerCaseEqualsLiteral("mod")) {
+      if (!hadWS || !RequireWhitespace())
+        return PR_FALSE;
+      unit = eCSSUnit_Calc_Modulus;
+      valueAllowed = PR_FALSE;
+    } else {
+      UngetToken();
+      // FIXME: We need to push back the whitespace too!
+      return gotValue;
+    }
+
+    nsRefPtr<nsCSSValue::Array> val = nsCSSValue::Array::Create(2);
+    val->Item(0) = aValue;
+    storage = val->Item(1);
+    aValue.SetArrayValue(val, unit);
+  }
+}
+
+PRBool
+CSSParserImpl::ParseCalcValueTerm(nsCSSValue& aValue, PRInt32 aVariantMask)
+{
+}
+
+PRBool
+CSSParserImpl::ParseCalcNumberAdditiveExpression(nsCSSValue& aValue)
+{
+}
+
+PRBool
+CSSParserImpl::ParseCalcNumberMultiplicativeExpression(nsCSSValue& aValue)
+{
+}
+
+PRBool
+CSSParserImpl::ParseCalcNumberTerm(nsCSSValue& aValue)
+{
+}
+
+PRBool
+CSSParserImpl::RequireWhitespace()
+{
+  GetToken(PR_FALSE);
+  if (mToken.mType != eCSSToken_WhiteSpace) {
+    UngetToken();
+    return PR_FALSE;
+  }
+  // Skip any additional whitespace tokens.
+  GetToken(PR_TRUE);
+  UngetToken();
+  return PR_TRUE;
+}
+
 PRBool
 CSSParserImpl::ParseRect(nsCSSRect& aRect, nsCSSProperty aPropID)
 {
   nsCSSRect rect;
   PRBool result;
   if ((result = DoParseRect(rect)) &&
       rect != aRect) {
     aRect = rect;
