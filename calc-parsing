From: L. David Baron <dbaron@dbaron.org>

Implement parsing of calc().

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -109,16 +109,17 @@
 #define VARIANT_NORMAL          0x080000  // M
 #define VARIANT_SYSFONT         0x100000  // eCSSUnit_System_Font
 #define VARIANT_GRADIENT        0x200000  // eCSSUnit_Gradient
 #define VARIANT_CUBIC_BEZIER    0x400000  // CSS transition timing function
 #define VARIANT_ALL             0x800000  //
 #define VARIANT_IMAGE_RECT    0x01000000  // eCSSUnit_Function
 // This is an extra bit that says that a VARIANT_ANGLE allows unitless zero:
 #define VARIANT_ZERO_ANGLE    0x02000000  // unitless zero for angles
+#define VARIANT_CALC          0x04000000  // eCSSUnit_Calc
 
 // Common combinations of variants
 #define VARIANT_AL   (VARIANT_AUTO | VARIANT_LENGTH)
 #define VARIANT_LP   (VARIANT_LENGTH | VARIANT_PERCENT)
 #define VARIANT_AH   (VARIANT_AUTO | VARIANT_INHERIT)
 #define VARIANT_AHLP (VARIANT_AH | VARIANT_LP)
 #define VARIANT_AHI  (VARIANT_AH | VARIANT_INTEGER)
 #define VARIANT_AHK  (VARIANT_AH | VARIANT_KEYWORD)
@@ -458,16 +459,28 @@ protected:
   PRBool ParseBorderImage();
   PRBool ParseBorderSpacing();
   PRBool ParseBorderSide(const nsCSSProperty aPropIDs[],
                          PRBool aSetAllSides);
   PRBool ParseDirectionalBorderSide(const nsCSSProperty aPropIDs[],
                                     PRInt32 aSourceType);
   PRBool ParseBorderStyle();
   PRBool ParseBorderWidth();
+
+  PRBool ParseCalc(nsCSSValue &aValue, PRInt32 aVariantMask);
+  PRBool ParseCalcValueAdditiveExpression(nsCSSValue& aValue,
+                                          PRInt32 aVariantMask);
+  PRBool ParseCalcValueMultiplicativeExpression(nsCSSValue& aValue,
+                                                PRInt32 aVariantMask,
+                                                PRBool *aHadFinalWS);
+  PRBool ParseCalcValueTerm(nsCSSValue& aValue, PRInt32 aVariantMask);
+  PRBool ParseCalcMinMax(nsCSSValue& aValue, nsCSSUnit aUnit,
+                         PRInt32 aVariantMask);
+  PRBool RequireWhitespace();
+
   // for 'clip' and '-moz-image-region'
   PRBool ParseRect(nsCSSRect& aRect,
                    nsCSSProperty aPropID);
   PRBool DoParseRect(nsCSSRect& aRect);
   PRBool ParseContent();
   PRBool ParseCounterData(nsCSSValuePairList** aResult,
                           nsCSSProperty aPropID);
   PRBool ParseCue();
@@ -4349,33 +4362,42 @@ CSSParserImpl::TranslateDimension(nsCSSV
   }
   if ((type & aVariantMask) != 0) {
     aValue.SetFloatValue(aNumber, units);
     return PR_TRUE;
   }
   return PR_FALSE;
 }
 
+// Note that this does include VARIANT_CALC, which is numeric.  This is
+// because calc() parsing, as proposed, drops range restrictions inside
+// the calc() expression and clamps the result of the calculation to the
+// range.
 #define VARIANT_ALL_NONNUMERIC \
   VARIANT_KEYWORD | \
   VARIANT_COLOR | \
   VARIANT_URL | \
   VARIANT_STRING | \
   VARIANT_COUNTER | \
   VARIANT_ATTR | \
   VARIANT_IDENTIFIER | \
   VARIANT_AUTO | \
   VARIANT_INHERIT | \
   VARIANT_NONE | \
   VARIANT_NORMAL | \
   VARIANT_SYSFONT | \
   VARIANT_GRADIENT | \
   VARIANT_CUBIC_BEZIER | \
-  VARIANT_ALL
-
+  VARIANT_ALL | \
+  VARIANT_CALC
+
+// Note that callers passing VARIANT_CALC in aVariantMask will get
+// full-range parsing inside the calc() expression, and the code that
+// computes the calc will be required to clamp the resulting value to an
+// appropriate range.
 PRBool
 CSSParserImpl::ParseNonNegativeVariant(nsCSSValue& aValue,
                                        PRInt32 aVariantMask,
                                        const PRInt32 aKeywordTable[])
 {
   // The variant mask must only contain non-numeric variants or the ones
   // that we specifically handle.
   NS_ABORT_IF_FALSE((aVariantMask & ~(VARIANT_ALL_NONNUMERIC |
@@ -4404,16 +4426,20 @@ CSSParserImpl::ParseNonNegativeVariant(n
         return PR_FALSE;
       }
     }
     return PR_TRUE;
   }
   return PR_FALSE;
 }
 
+// Note that callers passing VARIANT_CALC in aVariantMask will get
+// full-range parsing inside the calc() expression, and the code that
+// computes the calc will be required to clamp the resulting value to an
+// appropriate range.
 PRBool
 CSSParserImpl::ParsePositiveNonZeroVariant(nsCSSValue& aValue,
                                            PRInt32 aVariantMask,
                                            const PRInt32 aKeywordTable[])
 {
   // The variant mask must only contain non-numeric variants or the ones
   // that we specifically handle.
   NS_ABORT_IF_FALSE((aVariantMask & ~(VARIANT_ALL_NONNUMERIC |
@@ -4624,16 +4650,24 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
     return ParseAttr(aValue);
   }
   if (((aVariantMask & VARIANT_CUBIC_BEZIER) != 0) &&
       (eCSSToken_Function == tk->mType)) {
      if (tk->mIdent.LowerCaseEqualsLiteral("cubic-bezier")) {
       return ParseTransitionTimingFunctionValues(aValue);
     }
   }
+  if ((aVariantMask & VARIANT_CALC) &&
+      (eCSSToken_Function == tk->mType) &&
+      (tk->mIdent.LowerCaseEqualsLiteral("-moz-calc") ||
+       tk->mIdent.LowerCaseEqualsLiteral("-moz-min") ||
+       tk->mIdent.LowerCaseEqualsLiteral("-moz-max"))) {
+    // calc() currently allows only lengths and percents inside it.
+    return ParseCalc(aValue, aVariantMask & VARIANT_LP);
+  }
 
   UngetToken();
   return PR_FALSE;
 }
 
 
 PRBool
 CSSParserImpl::ParseCounter(nsCSSValue& aValue)
@@ -7114,16 +7148,284 @@ CSSParserImpl::ParseBorderColors(nsCSSVa
       break;
     }
   }
   // Have failure case at the end so we can |break| to get to it.
   delete list;
   return PR_FALSE;
 }
 
+// Parse the top level of a calc() expression, which can be calc(),
+// min(), or max().
+PRBool
+CSSParserImpl::ParseCalc(nsCSSValue &aValue, PRInt32 aVariantMask)
+{
+  NS_ASSERTION(!(aVariantMask & VARIANT_NUMBER), "unexpected variant mask");
+
+  nsCSSUnit unit;
+  if (mToken.mIdent.LowerCaseEqualsLiteral("-moz-min")) {
+    unit = eCSSUnit_Calc_Minimum;
+  } else if (mToken.mIdent.LowerCaseEqualsLiteral("-moz-max")) {
+    unit = eCSSUnit_Calc_Maximum;
+  } else {
+    NS_ASSERTION(mToken.mIdent.LowerCaseEqualsLiteral("-moz-calc"),
+                 "unexpected function");
+    unit = eCSSUnit_Calc;
+  }
+
+  if (unit != eCSSUnit_Calc) {
+    return ParseCalcMinMax(aValue, unit, aVariantMask);
+  }
+
+  PRBool res = ExpectSymbol('(', PR_FALSE);
+  NS_ABORT_IF_FALSE(res, "function token without open paren");
+
+  // One-iteration loop so we can break to the error-handling case.
+  do {
+    // The toplevel of a calc() is always an nsCSSValue::Array of length 1.
+    nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(1);
+    if (!arr) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+
+    if (!ParseCalcValueAdditiveExpression(arr->Item(0), aVariantMask))
+      break;
+
+    if (!ExpectSymbol(')', PR_TRUE))
+      break;
+
+    aValue.SetArrayValue(arr, eCSSUnit_Calc);
+    return PR_TRUE;
+  } while (PR_FALSE);
+
+  SkipUntil(')');
+  return PR_FALSE;
+}
+
+// We optimize away the <value-expression> production given that
+// ParseVariant consumes initial whitespace and we call
+// ExpectSymbol(')') with PR_TRUE for aSkipWS.
+// This function parses the <value-additive-expression> production, or,
+// when aVariantMask is VARIANT_NUMBER, the <number-additive-expression>
+// production.  It does so iteratively, but builds the correct recursive
+// data structure.
+PRBool
+CSSParserImpl::ParseCalcValueAdditiveExpression(nsCSSValue& aValue,
+                                                PRInt32 aVariantMask)
+{
+  nsCSSValue *storage = &aValue;
+  for (;;) {
+    PRBool haveWS;
+    if (!ParseCalcValueMultiplicativeExpression(*storage, aVariantMask,
+                                                &haveWS))
+      return PR_FALSE;
+
+    if (!haveWS || !GetToken(PR_FALSE))
+      return PR_TRUE;
+    nsCSSUnit unit;
+    if (mToken.IsSymbol('+')) {
+      unit = eCSSUnit_Calc_Plus;
+    } else if (mToken.IsSymbol('-')) {
+      unit = eCSSUnit_Calc_Minus;
+    } else {
+      UngetToken();
+      return PR_TRUE;
+    }
+    if (!RequireWhitespace())
+      return PR_FALSE;
+
+    nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(2);
+    if (!arr) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      return PR_FALSE;
+    }
+    arr->Item(0) = aValue;
+    storage = &arr->Item(1);
+    aValue.SetArrayValue(arr, unit);
+  }
+}
+
+// This function parses the <value-multiplicative-expression> production
+// AND its interleaving with <number-multiplicative-expression>, or,
+// when aVariantMask is VARIANT_NUMBER, the
+// <number-multiplicative-expression> production.  It does so
+// iteratively, but builds the correct recursive data structure.
+// This function always consumes *trailing* whitespace when it returns
+// true; whether there was any such whitespace is returned in the
+// aHadFinalWS parameter.
+PRBool
+CSSParserImpl::ParseCalcValueMultiplicativeExpression(nsCSSValue& aValue,
+                                                      PRInt32 aVariantMask,
+                                                      PRBool *aHadFinalWS)
+{
+  // Whether we already got the one with the unit.
+  // If we're parsing <number-multiplicative-expression>, then
+  // initialize it to true.
+  PRBool gotValue = aVariantMask == VARIANT_NUMBER;
+  // Whether the next value can be the one with the unit.
+  PRBool valueAllowed = !gotValue;
+
+  nsCSSValue *storage = &aValue;
+  for (;;) {
+    if (!GetToken(PR_TRUE))
+      return PR_FALSE;
+    PRBool isNumber = mToken.mType == eCSSToken_Number;
+    UngetToken();
+
+    if (isNumber) {
+      if (!ParseCalcValueTerm(*storage, VARIANT_NUMBER))
+        return PR_FALSE;
+    } else {
+      if (!valueAllowed || !ParseCalcValueTerm(*storage, aVariantMask))
+        return PR_FALSE;
+      gotValue = PR_TRUE;
+    }
+
+    PRBool hadWS = RequireWhitespace();
+    if (!GetToken(PR_FALSE)) {
+      *aHadFinalWS = hadWS;
+      return gotValue;
+    }
+    nsCSSUnit unit;
+    if (mToken.IsSymbol('*')) {
+      unit = eCSSUnit_Calc_Times;
+      valueAllowed = !gotValue;
+    } else if (mToken.IsSymbol('/')) {
+      unit = eCSSUnit_Calc_Divided;
+      valueAllowed = PR_FALSE;
+    } else if (mToken.mType == eCSSToken_Ident &&
+               mToken.mIdent.LowerCaseEqualsLiteral("mod")) {
+      if (!hadWS || !RequireWhitespace())
+        return PR_FALSE;
+      unit = eCSSUnit_Calc_Modulus;
+      valueAllowed = PR_FALSE;
+    } else {
+      UngetToken();
+      *aHadFinalWS = hadWS;
+      return gotValue;
+    }
+
+    nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(2);
+    if (!arr) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      return PR_FALSE;
+    }
+    arr->Item(0) = aValue;
+    storage = &arr->Item(1);
+    aValue.SetArrayValue(arr, unit);
+  }
+}
+
+// Parse the <length-term> production, or, if aVariantMask is
+// VARIANT_NUMBER, the <number-term> production.
+PRBool
+CSSParserImpl::ParseCalcValueTerm(nsCSSValue& aValue, PRInt32 aVariantMask)
+{
+  if (!GetToken(PR_TRUE))
+    return PR_FALSE;
+  // Either an additive expression in parentheses...
+  if (mToken.IsSymbol('(')) {
+    if (!ParseCalcValueAdditiveExpression(aValue, aVariantMask) ||
+        !ExpectSymbol(')', PR_TRUE)) {
+      SkipUntil(')');
+      return PR_FALSE;
+    }
+    return PR_TRUE;
+  }
+  // ... or a min() or max() expression
+  if (aVariantMask != VARIANT_NUMBER &&
+      mToken.mType == eCSSToken_Function &&
+      (mToken.mIdent.LowerCaseEqualsLiteral("min") ||
+       mToken.mIdent.LowerCaseEqualsLiteral("max"))) {
+    nsCSSUnit unit = mToken.mIdent.LowerCaseEqualsLiteral("min")
+                       ? eCSSUnit_Calc_Minimum : eCSSUnit_Calc_Maximum;
+    return ParseCalcMinMax(aValue, unit, aVariantMask);
+  }
+  // ... or just a value
+  UngetToken();
+  return ParseVariant(aValue, aVariantMask, nsnull);
+}
+
+PRBool
+CSSParserImpl::ParseCalcMinMax(nsCSSValue& aValue, nsCSSUnit aUnit,
+                               PRInt32 aVariantMask)
+{
+  NS_ASSERTION(aUnit == eCSSUnit_Calc_Minimum ||
+               aUnit == eCSSUnit_Calc_Maximum,
+               "unexpected unit");
+  NS_ASSERTION(mToken.mType == eCSSToken_Function, "unexpected current token");
+  NS_ASSERTION(aUnit != eCSSUnit_Calc_Minimum ||
+               mToken.mIdent.LowerCaseEqualsLiteral("min") ||
+               mToken.mIdent.LowerCaseEqualsLiteral("-moz-min"),
+               "unexpected current token");
+  NS_ASSERTION(aUnit != eCSSUnit_Calc_Maximum ||
+               mToken.mIdent.LowerCaseEqualsLiteral("max") ||
+               mToken.mIdent.LowerCaseEqualsLiteral("-moz-max"),
+               "unexpected current token");
+  NS_ASSERTION(!(aVariantMask & VARIANT_NUMBER), "unexpected variant mask");
+
+  PRBool res = ExpectSymbol('(', PR_FALSE);
+  NS_ABORT_IF_FALSE(res, "function token without open paren");
+
+  nsTArray<nsCSSValue> values;
+  for (;;) {
+    nsCSSValue *v = values.AppendElement();
+    if (!v) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      return PR_FALSE;
+    }
+
+    if (!ParseCalcValueAdditiveExpression(*v, aVariantMask))
+      return PR_FALSE;
+
+    if (ExpectSymbol(',', PR_TRUE))
+      continue;
+
+    if (ExpectSymbol(')', PR_TRUE))
+      break;
+
+    SkipUntil(')');
+    return PR_FALSE;
+  }
+
+  if (values.Length() < 2)
+    return PR_FALSE;
+
+  nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(values.Length());
+  if (!arr) {
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+    return PR_FALSE;
+  }
+  for (PRUint32 i = 0, i_end = values.Length(); i < i_end; ++i) {
+    arr->Item(i) = values[i];
+  }
+
+  aValue.SetArrayValue(arr, aUnit);
+  return PR_TRUE;
+}
+
+// This function consumes all consecutive whitespace and returns whether
+// there was any.
+PRBool
+CSSParserImpl::RequireWhitespace()
+{
+  if (!GetToken(PR_FALSE))
+    return PR_FALSE;
+  if (mToken.mType != eCSSToken_WhiteSpace) {
+    UngetToken();
+    return PR_FALSE;
+  }
+  // Skip any additional whitespace tokens.
+  if (GetToken(PR_TRUE)) {
+    UngetToken();
+  }
+  return PR_TRUE;
+}
+
 PRBool
 CSSParserImpl::ParseRect(nsCSSRect& aRect, nsCSSProperty aPropID)
 {
   nsCSSRect rect;
   PRBool result;
   if ((result = DoParseRect(rect)) &&
       rect != aRect) {
     aRect = rect;
