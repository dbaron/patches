From: L. David Baron <dbaron@dbaron.org>

Implement CSS transitions:  add support for transitions of color values.  (Bug 435441)

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -42,30 +42,35 @@
 #include "nsCSSProps.h"
 #include "mozilla/TimeStamp.h"
 #include "nsRefreshDriver.h"
 #include "nsRuleProcessorData.h"
 #include "nsIStyleRule.h"
 #include "nsRuleWalker.h"
 #include "nsRuleData.h"
 #include "nsSMILKeySpline.h"
+#include "gfxColor.h"
 
 using mozilla::TimeStamp;
 using mozilla::TimeDuration;
 
 /*****************************************************************************
  * Per-CSS-property data                                                     *
  *****************************************************************************/
 
 struct CSSPropertyAnimationInfo {
   enum Type {
     eCannotAnimate,
     eStyleSides,
     eStyleCoord,
-    eNsCoord
+    eNsCoord,
+    eNsColor
+#if 0
+    ePaintServer
+#endif
   };
 
   Type mType;
   PRUint32 mIndex;
 };
 
 struct StyleSidesAnimationInfo {
   typedef nsStyleSides location_type;
@@ -137,16 +142,59 @@ struct NsCoordAnimationInfo {
   size_t mLocation;
 };
 
 static const NsCoordAnimationInfo gNsCoordAnimInfo[] = {
   { eCSSProperty_outline_offset, offsetof(nsStyleOutline, mOutlineOffset) },
   { eCSSProperty_word_spacing, offsetof(nsStyleText, mWordSpacing) }
 };
 
+struct NsColorAnimationInfo {
+  typedef nscolor location_type;
+
+  nsCSSProperty mProperty;
+  size_t mLocation;
+};
+
+static const NsColorAnimationInfo gNsColorAnimInfo[] = {
+  { eCSSProperty_color, offsetof(nsStyleColor, mColor) },
+  { eCSSProperty_background_color,
+    offsetof(nsStyleBackground, mBackgroundColor) },
+#if 0 // FIXME
+  { eCSSProperty_border_top_color,
+    offsetof(nsStyleBorder, mBorderColor[0]) },
+  { eCSSProperty_border_right_color_value,
+    offsetof(nsStyleBorder, mBorderColor[1]) },
+  { eCSSProperty_border_bottom_color,
+    offsetof(nsStyleBorder, mBorderColor[2]) },
+  { eCSSProperty_border_left_color_value,
+    offsetof(nsStyleBorder, mBorderColor[3]) },
+  { eCSSProperty_outline_color, offsetof(nsStyleOutline, mOutlineColor) },
+#endif
+  { eCSSProperty__moz_column_rule_color,
+    offsetof(nsStyleColumn, mColumnRuleColor) },
+  { eCSSProperty_stop_color, offsetof(nsStyleSVGReset, mStopColor) },
+  { eCSSProperty_flood_color, offsetof(nsStyleSVGReset, mFloodColor) },
+  { eCSSProperty_lighting_color, offsetof(nsStyleSVGReset, mLightingColor) }
+};
+
+struct PaintServerAnimationInfo {
+  typedef nsStyleSVGPaint location_type;
+
+  nsCSSProperty mProperty;
+  size_t mLocation;
+};
+
+static const NsColorAnimationInfo gPaintServerAnimInfo[] = {
+  { eCSSProperty_fill , offsetof(nsStyleSVG, mFill) },
+  { eCSSProperty_stroke , offsetof(nsStyleSVG, mStroke) },
+};
+
+//  { eCSSProperty_ , offsetof(nsStyle, ) },
+
 static CSSPropertyAnimationInfo gAnimInfo[eCSSProperty_COUNT_no_shorthands];
 
 // Have an "*Internal" version so a specialized form can call the
 // general form and then modify the result.
 template <class InfoType>
 static inline const typename InfoType::location_type&
 GetPropertyValueInternal(nsStyleContext *aStyleContext, const InfoType& aInfo)
 {
@@ -220,26 +268,43 @@ nsTransitionManager::InitializeAnimation
     }
 
     for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gNsCoordAnimInfo); ++i) {
         nsCSSProperty prop = gNsCoordAnimInfo[i].mProperty;
         NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(prop), "must be longhand");
         gAnimInfo[prop].mType = CSSPropertyAnimationInfo::eNsCoord;
         gAnimInfo[prop].mIndex = i;
     }
+
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gNsColorAnimInfo); ++i) {
+        nsCSSProperty prop = gNsColorAnimInfo[i].mProperty;
+        NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(prop), "must be longhand");
+        gAnimInfo[prop].mType = CSSPropertyAnimationInfo::eNsColor;
+        gAnimInfo[prop].mIndex = i;
+    }
+
+#if 0
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gPaintServerAnimInfo); ++i) {
+        nsCSSProperty prop = gPaintServerAnimInfo[i].mProperty;
+        NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(prop), "must be longhand");
+        gAnimInfo[prop].mType = CSSPropertyAnimationInfo::ePaintServer;
+        gAnimInfo[prop].mIndex = i;
+    }
+#endif
 }
 
 /*****************************************************************************
  * Per-Frame data                                                            *
  *****************************************************************************/
 
 union TransitionEndpoint
 {
     nscoord mCoord;
     float mPercent;
+    nscolor mColor;
 };
 
 struct FramePropertyTransition
 {
     nsCSSProperty mProperty;
     nsStyleUnit mUnit; // valid when gAnimInfo[mProperty].mType is
                        // eStyleSides or eStyleCoord
     TransitionEndpoint mStartValue, mEndValue;
@@ -336,16 +401,55 @@ CoordFromPortion(const FramePropertyTran
                           "unexpected unit");
         val.SetPercentValue(
           aPT.mStartValue.mPercent * (1.0 - aValuePortion) +
           aPT.mEndValue.mPercent * aValuePortion);
     }
     return val;
 }
 
+static nscolor
+ColorFromPortion(nscolor aStartColor, nscolor aEndColor, double aValuePortion)
+{
+    double inv = 1.0 - aValuePortion;
+    // FIXME: Does it matter if these are premultiplied?  I think it does.
+    // So the spec should say what to do here...
+#if 0
+    // Don't use premultiplication.
+    return NS_RGBA(PRUint8(NS_GET_R(aStartColor) * inv +
+                           NS_GET_R(aEndColor) * aValuePortion),
+                   PRUint8(NS_GET_G(aStartColor) * inv +
+                           NS_GET_G(aEndColor) * aValuePortion),
+                   PRUint8(NS_GET_B(aStartColor) * inv +
+                           NS_GET_B(aEndColor) * aValuePortion),
+                   PRUint8(NS_GET_A(aStartColor) * inv +
+                           NS_GET_A(aEndColor) * aValuePortion));
+#else
+    // Use premultiplication.
+    double startA = NS_GET_A(aStartColor) / 255.0;
+    double startR = NS_GET_R(aStartColor) * startA;
+    double startG = NS_GET_G(aStartColor) * startA;
+    double startB = NS_GET_B(aStartColor) * startA;
+    double endA = NS_GET_A(aEndColor) / 255.0;
+    double endR = NS_GET_R(aEndColor) * endA;
+    double endG = NS_GET_G(aEndColor) * endA;
+    double endB = NS_GET_B(aEndColor) * endA;
+    double resAf = (startA * inv + endA * aValuePortion);
+    if (resAf == 0.0) {
+        return NS_RGBA(0, 0, 0, 0);
+    }
+    double factor = 1.0 / resAf;
+    PRUint8 resA = NSToIntRound(resAf * 255.0);
+    PRUint8 resR = NSToIntRound((startR * inv + endR * aValuePortion) * factor);
+    PRUint8 resG = NSToIntRound((startG * inv + endG * aValuePortion) * factor);
+    PRUint8 resB = NSToIntRound((startB * inv + endB * aValuePortion) * factor);
+    return NS_RGBA(resR, resG, resB, resA);
+#endif
+}
+
 static void
 FrameTransitionsPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData)
 {
     // WARNING:  This makes the rather large assumption that the
     // transitions style rule is the most specific rule.  The way
     // nsStyleSet is written right now ensures that, but it's a pretty
     // fragile dependency.
     FrameTransitionsStyleRule *rule =
@@ -394,16 +498,34 @@ FrameTransitionsPostResolveCallback(void
                     const NsCoordAnimationInfo& coordInfo =
                         gNsCoordAnimInfo[animInfo.mIndex];
                     nscoord val = NSToCoordRound(
                         pt.mStartValue.mCoord * (1.0 - valuePortion) +
                         pt.mEndValue.mCoord * valuePortion);
                     SetPropertyValue(aStyleStruct, coordInfo, val);
                     break;
                 }
+                case CSSPropertyAnimationInfo::eNsColor: {
+                    const NsColorAnimationInfo& colorInfo =
+                        gNsColorAnimInfo[animInfo.mIndex];
+                    SetPropertyValue(aStyleStruct, colorInfo,
+                                     ColorFromPortion(pt.mStartValue.mColor,
+                                                      pt.mEndValue.mColor,
+                                                      valuePortion));
+                    break;
+                }
+#if 0
+                case CSSPropertyAnimationInfo::ePaintServer: {
+                    const PaintServerAnimationInfo& paintServerInfo =
+                        gPaintServerAnimInfo[animInfo.mIndex];
+                    SetPropertyValue(aStyleStruct, paintServerInfo,
+                                     ColorFromPortion(pt, valuePortion));
+                    break;
+                }
+#endif
             }
 
             if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Margin)) {
                 static_cast<nsStyleMargin*>(aStyleStruct)->RecalcData();
             }
             if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Padding)) {
                 static_cast<nsStylePadding*>(aStyleStruct)->RecalcData();
             }
@@ -626,16 +748,49 @@ nsTransitionManager::ConsiderStartingTra
                 GetPropertyValue(aFrame->GetStyleContext(), coordInfo);
             shouldAnimate = oldVal != newVal;
             if (shouldAnimate) {
                 t.mStartValue.mCoord = oldVal;
                 t.mEndValue.mCoord   = newVal;
             }
             break;
         }
+        case CSSPropertyAnimationInfo::eNsColor: {
+            const NsColorAnimationInfo& colorInfo =
+                gNsColorAnimInfo[animInfo.mIndex];
+            const nscolor &oldVal =
+                GetPropertyValue(aOldStyleContext, colorInfo);
+            const nscolor &newVal =
+                GetPropertyValue(aFrame->GetStyleContext(), colorInfo);
+            shouldAnimate = oldVal != newVal;
+            if (shouldAnimate) {
+                t.mStartValue.mColor = oldVal;
+                t.mEndValue.mColor   = newVal;
+            }
+            break;
+        }
+#if 0
+        case CSSPropertyAnimationInfo::ePaintServer: {
+            const PaintServerAnimationInfo& paintServerInfo =
+                gPaintServerAnimInfo[animInfo.mIndex];
+            const nsStyleSVGPaint &oldVal =
+                GetPropertyValue(aOldStyleContext, paintServerInfo);
+            const nsStyleSVGPaint &newVal =
+                GetPropertyValue(aFrame->GetStyleContext(), paintServerInfo);
+            // FIXME: Support gradient animation.
+            shouldAnimate = oldVal != newVal &&
+                            oldVal.mType == eStyleSVGPaintType_Color &&
+                            newVal.mType == eStyleSVGPaintType_Color;
+            if (shouldAnimate) {
+                t.mStartValue.mColor = oldVal.mPaint.mColor;
+                t.mEndValue.mColor   = newVal.mPaint.mColor;
+            }
+            break;
+        }
+#endif
     }
 
     PRUint32 currentIndex = PRUint32(-1);
     if (aFrameTransitions) {
         nsTArray<FramePropertyTransition> &pts =
             aFrameTransitions->mPropertyTransitions;
         for (PRUint32 i = 0, i_end = pts.Length(); i < i_end; ++i) {
             if (pts[i].mProperty == aProperty) {
