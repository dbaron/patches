Add debugging code to cycle collector to give information about objects it has been told ought to be freed.

diff -r 01cc967aebe9 dom/src/base/nsGlobalWindow.cpp
--- a/dom/src/base/nsGlobalWindow.cpp	Thu Mar 01 14:02:41 2007 -0800
+++ b/dom/src/base/nsGlobalWindow.cpp	Thu Mar 01 14:10:31 2007 -0800
@@ -74,6 +74,7 @@
 #endif
 #include "nsContentCID.h"
 #include "nsLayoutStatics.h"
+#include "nsCycleCollector.h"
 
 // Interfaces Needed
 #include "nsIWidget.h"
@@ -552,6 +553,10 @@ nsGlobalWindow::~nsGlobalWindow()
 
   CleanUp();
 
+#ifdef DEBUG
+  nsCycleCollector_DEBUG_wasFreed(NS_STATIC_CAST(nsIScriptGlobalObject*, this));
+#endif
+
   delete mPendingStorageEvents;
 
   nsLayoutStatics::Release();
@@ -604,6 +609,10 @@ nsGlobalWindow::CleanUp()
   }
   mArguments = nsnull;
   mArgumentsLast = nsnull;
+
+#ifdef DEBUG
+  nsCycleCollector_DEBUG_shouldBeFreed(NS_STATIC_CAST(nsIScriptGlobalObject*, this));
+#endif
 }
 
 void
@@ -661,6 +670,10 @@ nsGlobalWindow::FreeInnerObjects(PRBool 
         scx->ClearScope(mScriptGlobals[NS_STID_INDEX(lang_id)], PR_TRUE);
     }
   }
+
+#ifdef DEBUG
+  nsCycleCollector_DEBUG_shouldBeFreed(NS_STATIC_CAST(nsIScriptGlobalObject*, this));
+#endif
 }
 
 //*****************************************************************************
diff -r 01cc967aebe9 xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp	Thu Mar 01 14:02:41 2007 -0800
+++ b/xpcom/base/nsCycleCollector.cpp	Thu Mar 01 15:34:02 2007 -0800
@@ -289,7 +289,11 @@ struct PtrInfo
 };
 
 
-typedef nsBaseHashtable<nsClearingVoidPtrHashKey, PRUint32, PRUint32> PointerSet;
+// XXX Would be nice to have an nsHashSet<KeyType> API that has
+// Add/Remove/Has rather than PutEntry/RemoveEntry/GetEntry.
+typedef nsTHashtable<nsClearingVoidPtrHashKey> PointerSet;
+typedef nsBaseHashtable<nsClearingVoidPtrHashKey, PRUint32, PRUint32>
+    PointerSetWithGeneration;
 typedef nsBaseHashtable<nsClearingVoidPtrHashKey, PtrInfo, PtrInfo> GCTable;
 
 static void
@@ -323,7 +327,7 @@ struct nsPurpleBuffer
     nsCycleCollectorStats &mStats;
     void* mCache[N_POINTERS];
     PRUint32 mCurrGen;    
-    PointerSet mBackingStore;
+    PointerSetWithGeneration mBackingStore;
     nsDeque *mTransferBuffer;
     
     nsPurpleBuffer(nsCycleCollectorParams &params,
@@ -480,7 +484,7 @@ struct nsCycleCollector
                          nsCycleCollectionLanguageRuntime *rt);
     void ForgetRuntime(PRUint32 langID);
 
-    void CollectPurple();
+    void CollectPurple(); // XXXldb Should this be called SelectPurple?
     void MarkRoots();
     void ScanRoots();
     void CollectWhite();
@@ -495,6 +499,13 @@ struct nsCycleCollector
     void Freed(void *n);
     void Collect();
     void Shutdown();
+
+#ifdef DEBUG
+    void ExplainLiveExpectedGarbage();
+    void ShouldBeFreed(nsISupports *n);
+    void WasFreed(nsISupports *n);
+    PointerSet mExpectedGarbage;
+#endif
 };
 
 
@@ -1125,14 +1136,12 @@ struct graphVizWalker : public GraphWalk
 
     PRBool ShouldVisitNode(void *p, PtrInfo const & pi)  
     { 
-        PRUint32 dummy;
-        return ! mVisited.Get(p, &dummy);
+        return ! mVisited.GetEntry(p);
     }
 
     void VisitNode(void *p, PtrInfo & pi, size_t refcount) 
     {
-        PRUint32 dummy = 0;
-        mVisited.Put(p, dummy);
+        mVisited.PutEntry(p);
         mParent = p;
         fprintf(mStream, 
                 "n%p [label=\"%s\\n%p\\n%u/%u refs found\", "
@@ -1360,6 +1369,9 @@ nsCycleCollector::nsCycleCollector() :
     mPtrLog(nsnull)
 {
     mGraph.Init();
+#ifdef DEBUG
+    mExpectedGarbage.Init();
+#endif
 
     for (PRUint32 i = 0; i <= nsIProgrammingLanguage::MAX; ++i) {
         mRuntimes[i] = nsnull;
@@ -1662,6 +1674,13 @@ nsCycleCollector::Collect()
             MaybeDrawGraphs();
             CollectWhite();
             ForgetAll();
+
+#ifdef DEBUG
+            if (mParams.mScanDelay == 0) {
+                // In shutdown or scan delay set to 0 by environment variable.
+                ExplainLiveExpectedGarbage();
+            }
+#endif
             
             // Some additional book-keeping.
             
@@ -1693,6 +1712,106 @@ nsCycleCollector::Shutdown()
     mParams.mDoNothing = PR_TRUE;
 }
 
+#ifdef DEBUG
+
+PR_STATIC_CALLBACK(PLDHashOperator)
+AddExpectedGarbage(nsClearingVoidPtrHashKey *p, void *arg)
+{
+    nsCycleCollector *c = NS_STATIC_CAST(nsCycleCollector*, arg);
+    c->mBufs[0]->Push(NS_CONST_CAST(void*, p->GetKey()));
+    return PL_DHASH_NEXT;
+}
+
+struct explainWalker : public GraphWalker
+{
+    explainWalker(GCTable &tab,
+                  nsCycleCollectionLanguageRuntime **runtimes)
+        : GraphWalker(tab, runtimes) 
+    {}
+
+    PRBool ShouldVisitNode(void *p, PtrInfo const & pi) 
+    { 
+        // We set them back to gray as we explain problems.
+        return pi.mColor != grey; 
+    }
+
+    void VisitNode(void *p, PtrInfo & pi, size_t refcount) 
+    {
+        if (pi.mColor == grey)
+            Fault("scanning grey node", p);
+
+        if (pi.mColor == white) {
+            printf("nsCycleCollector: %s %p was not collected due to\n"
+                   "  missing call to suspect\n",
+                   pi.mName, p);
+        }
+
+        if (pi.mInternalRefs != refcount) {
+            // Note that the external references may have been external
+            // to a different node in the cycle collection that just
+            // happened, if that different node was purple and then
+            // black.
+            printf("nsCycleCollector: %s %p was not collected due to %d\n"
+                   "  external references\n",
+                   pi.mName, p, refcount - pi.mInternalRefs);
+        }
+
+        pi.mColor = grey;
+
+        mGraph.Put(p, pi);
+    }
+    void NoteChild(void *c, PtrInfo & childpi) {}
+};
+
+void
+nsCycleCollector::ExplainLiveExpectedGarbage()
+{
+    // This function must be called during Collect, when the runtimes
+    // are capable of doing traversal, but we don't have a way to assert
+    // that.
+    // XXX Are they really still capable of doing proper traversal after
+    // there's been Unlink-ing?  I'd think probably not...
+
+    if (mScanInProgress || mCollectionInProgress)
+        Fault("can't explain expected garbage during collection itself");
+
+    mGraph.Clear();
+
+    mBufs[0]->Empty();
+    mExpectedGarbage.EnumerateEntries(&AddExpectedGarbage, this);
+    MarkRoots();
+
+    for (int i = 0; i < mBufs[0]->GetSize(); ++i) {
+        nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0]->ObjectAt(i));
+        s = canonicalize(s);
+        scanWalker(mGraph, mRuntimes).Walk(s); 
+    }
+
+    // Sanity check: scan should have colored all grey nodes black or
+    // white. So we ensure we have no grey nodes at this point.
+    mGraph.Enumerate(NoGreyCallback, this);
+
+    for (int i = 0; i < mBufs[0]->GetSize(); ++i) {
+        nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0]->ObjectAt(i));
+        s = canonicalize(s);
+        explainWalker(mGraph, mRuntimes).Walk(s); 
+    }
+
+    mGraph.Clear();
+}
+
+void
+nsCycleCollector::ShouldBeFreed(nsISupports *n)
+{
+    mExpectedGarbage.PutEntry(n);
+}
+
+void
+nsCycleCollector::WasFreed(nsISupports *n)
+{
+    mExpectedGarbage.RemoveEntry(n);
+}
+#endif
 
 ////////////////////////////////////////////////////////////////////////
 // Module public API (exported in nsCycleCollector.h)
@@ -1758,6 +1877,25 @@ nsCycleCollector_shutdown()
     sCollector.Shutdown();
 }
 
+#ifdef DEBUG
+void
+nsCycleCollector_DEBUG_shouldBeFreed(nsISupports *n)
+{
+    if (sCollectorConstructed == 0)
+        return;
+    
+    sCollector.ShouldBeFreed(n);
+}
+
+void
+nsCycleCollector_DEBUG_wasFreed(nsISupports *n)
+{
+    if (sCollectorConstructed == 0)
+        return;
+    
+    sCollector.WasFreed(n);
+}
+#endif
 
 PRBool
 nsCycleCollector_isScanSafe(nsISupports *s)
diff -r 01cc967aebe9 xpcom/base/nsCycleCollector.h
--- a/xpcom/base/nsCycleCollector.h	Thu Mar 01 14:02:41 2007 -0800
+++ b/xpcom/base/nsCycleCollector.h	Thu Mar 01 14:02:43 2007 -0800
@@ -65,6 +65,11 @@ NS_COM void nsCycleCollector_collect();
 NS_COM void nsCycleCollector_collect();
 NS_COM void nsCycleCollector_shutdown();
 
+#ifdef DEBUG
+NS_COM void nsCycleCollector_DEBUG_shouldBeFreed(nsISupports *n);
+NS_COM void nsCycleCollector_DEBUG_wasFreed(nsISupports *n);
+#endif
+
 // Helpers for interacting with language-identified scripts
 
 NS_COM void nsCycleCollector_registerRuntime(PRUint32 langID, nsCycleCollectionLanguageRuntime *rt);
