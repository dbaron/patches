From: L. David Baron <dbaron@dbaron.org>

Bug 1115812 patch 13 - Refactor the before-part of the rebuild to StartRebuildingStyleData.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1472,21 +1472,21 @@ RestyleManager::RestyleForRemove(Element
 void
 RestyleManager::RebuildAllStyleData(nsChangeHint aExtraHint,
                                     nsRestyleHint aRestyleHint)
 {
   NS_ASSERTION(!(aExtraHint & nsChangeHint_ReconstructFrame),
                "Should not reconstruct the root of the frame tree.  "
                "Use ReconstructDocElementHierarchy instead.");
 
-  mDoRebuildAllStyleData = false;
-
   nsIPresShell* presShell = mPresContext->GetPresShell();
-  if (!presShell || !presShell->GetRootFrame())
+  if (!presShell || !presShell->GetRootFrame()) {
+    mDoRebuildAllStyleData = false;
     return;
+  }
 
   // Make sure that the viewmanager will outlive the presshell
   nsRefPtr<nsViewManager> vm = presShell->GetViewManager();
 
   // Processing the style changes could cause a flush that propagates to
   // the parent frame and thus destroys the pres shell.
   nsCOMPtr<nsIPresShell> kungFuDeathGrip(presShell);
 
@@ -1521,43 +1521,49 @@ RestyleManager::RebuildAllStyleData(nsCh
   // Make sure that we process any pending animation restyles from the
   // above style change.  Note that we can *almost* implement the above
   // by just posting a style change -- except we really need to restyle
   // the root frame rather than the root element's primary frame.
   ProcessPendingRestyles();
 }
 
 void
-RestyleManager::DoRebuildAllStyleData(RestyleTracker& aRestyleTracker)
+RestyleManager::StartRebuildAllStyleData(RestyleTracker& aRestyleTracker)
 {
-  BeginProcessingRestyles(aRestyleTracker);
+  MOZ_ASSERT(mIsProcessingRestyles);
 
   mInRebuildAllStyleData = true;
 
   // Tell the style set to get the old rule tree out of the way
   // so we can recalculate while maintaining rule tree immutability
   nsresult rv = mPresContext->StyleSet()->BeginReconstruct();
   if (NS_FAILED(rv)) {
-    return;
+    MOZ_CRASH("unable to rebuild style data");
   }
 
   // Until we get rid of these phases in bug 960465, we need to add
   // eRestyle_ChangeAnimationPhaseDescendants so that we actually honor
   // animation phase booleans in all cases.
   mPendingRestyles.AddPendingRestyleToRoot(
     eRestyle_ChangeAnimationPhaseDescendants, nsChangeHint(0));
 
-  // Recalculate all of the style contexts for the document
+  // Recalculate all of the style contexts for the document, from the
+  // root frame.  We can't do this with a change hint, since we can't
+  // post a change hint for the root frame.
   // Note that we can ignore the return value of ComputeStyleChangeFor
-  // because we never need to reframe the root frame
-  // Note: The restyle tracker we pass in here doesn't matter.
+  // because we never need to reframe the root frame.
   ComputeAndProcessStyleChange(mPresContext->PresShell()->GetRootFrame(),
                                nsChangeHint(0), aRestyleTracker,
                                eRestyle_ForceDescendants);
-
+}
+
+void
+RestyleManager::DoRebuildAllStyleData(RestyleTracker& aRestyleTracker)
+{
+  BeginProcessingRestyles(aRestyleTracker);
   EndProcessingRestyles();
 }
 
 void
 RestyleManager::ProcessPendingRestyles()
 {
   NS_PRECONDITION(mPresContext->Document(), "No document?  Pshaw!");
   NS_PRECONDITION(!nsContentUtils::IsSafeToRunScript(),
@@ -1639,16 +1645,21 @@ RestyleManager::ProcessPendingRestyles()
 void
 RestyleManager::BeginProcessingRestyles(RestyleTracker& aRestyleTracker)
 {
   // Make sure to not rebuild quote or counter lists while we're
   // processing restyles
   mPresContext->FrameConstructor()->BeginUpdate();
 
   mInStyleRefresh = true;
+
+  if (ShouldStartRebuildAllFor(aRestyleTracker)) {
+    mDoRebuildAllStyleData = false;
+    StartRebuildAllStyleData(aRestyleTracker);
+  }
 }
 
 void
 RestyleManager::EndProcessingRestyles()
 {
   FlushOverflowChangedTracker();
 
   // Set mInStyleRefresh to false now, since the EndUpdate call might
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -448,31 +448,39 @@ private:
   /* aMinHint is the minimal change that should be made to the element */
   // XXXbz do we really need the aPrimaryFrame argument here?
   void RestyleElement(Element*        aElement,
                       nsIFrame*       aPrimaryFrame,
                       nsChangeHint    aMinHint,
                       RestyleTracker& aRestyleTracker,
                       nsRestyleHint   aRestyleHint);
 
+  void StartRebuildAllStyleData(RestyleTracker& aRestyleTracker);
+
   void StyleChangeReflow(nsIFrame* aFrame, nsChangeHint aHint);
 
   // Recursively add all the given frame and all children to the tracker.
   void AddSubtreeToOverflowTracker(nsIFrame* aFrame);
 
   // Returns true if this function managed to successfully move a frame, and
   // false if it could not process the position change, and a reflow should
   // be performed instead.
   bool RecomputePosition(nsIFrame* aFrame);
 
+  bool ShouldStartRebuildAllFor(RestyleTracker& aRestyleTracker) {
+    // When we process our primary restyle tracker and we have a pending
+    // rebuild-all, we need to process it.
+    return mDoRebuildAllStyleData &&
+           &aRestyleTracker == &mPendingRestyles;
+  }
+
   void ProcessRestyles(RestyleTracker& aRestyleTracker) {
     // Fast-path the common case (esp. for the animation restyle
     // tracker) of not having anything to do.
-    if (aRestyleTracker.Count() ||
-        mInRebuildAllStyleData) {
+    if (aRestyleTracker.Count() || ShouldStartRebuildAllFor(aRestyleTracker)) {
       aRestyleTracker.DoProcessRestyles();
     }
   }
 
 private:
   nsPresContext* mPresContext; // weak, disconnected in Disconnect
 
   bool mDoRebuildAllStyleData : 1;
