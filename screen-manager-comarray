Convert nsScreenManagerGtk from nsISupportsArray to nsCOMArray.  b=403706

diff --git a/widget/src/gtk2/nsScreenManagerGtk.cpp b/widget/src/gtk2/nsScreenManagerGtk.cpp
--- a/widget/src/gtk2/nsScreenManagerGtk.cpp
+++ b/widget/src/gtk2/nsScreenManagerGtk.cpp
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 2000
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Sylvain Pasche <sylvain.pasche@gmail.com>
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -67,21 +68,17 @@ nsScreenManagerGtk :: ~nsScreenManagerGt
 // addref, release, QI
 NS_IMPL_ISUPPORTS1(nsScreenManagerGtk, nsIScreenManager)
 
 
 // this function will make sure that everything has been initialized.
 nsresult
 nsScreenManagerGtk :: EnsureInit(void)
 {
-  if (!mCachedScreenArray) {
-    mCachedScreenArray = do_CreateInstance("@mozilla.org/supports-array;1");
-    if (!mCachedScreenArray) {
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
+  if (mNumScreens == 0) {
     XineramaScreenInfo *screenInfo = NULL;
 
     // We are leaking xineramalib, but there is no other way to do this.
     PRLibrary* xineramalib = PR_LoadLibrary("libXinerama.so.1");
     if (xineramalib) {
       _XnrmIsActive_fn _XnrmIsActive = (_XnrmIsActive_fn)
           PR_FindFunctionSymbol(xineramalib, "XineramaIsActive");
 
@@ -99,18 +96,17 @@ nsScreenManagerGtk :: EnsureInit(void)
     if (!screenInfo) {
       mNumScreens = 1;
       nsRefPtr<nsScreenGtk> screen = new nsScreenGtk();
       if (!screen)
         return NS_ERROR_OUT_OF_MEMORY;
 
       screen->Init();
 
-      nsISupports *supportsScreen = screen;
-      mCachedScreenArray->AppendElement(supportsScreen);
+      mCachedScreenArray.AppendObject(screen);
     }
     // If Xinerama is enabled and there's more than one screen, fill
     // in the info for all of the screens.  If that's not the case
     // then nsScreenGTK() defaults to the screen width + height
     else {
 #ifdef DEBUG
       printf("Xinerama superpowers activated for %d screens!\n", mNumScreens);
 #endif
@@ -119,18 +115,17 @@ nsScreenManagerGtk :: EnsureInit(void)
         nsRefPtr<nsScreenGtk> screen = new nsScreenGtk();
         if (!screen) {
           return NS_ERROR_OUT_OF_MEMORY;
         }
 
         // initialize this screen object
         screen->Init(&screenInfo[i]);
 
-        nsISupports *screenSupports = screen;
-        mCachedScreenArray->AppendElement(screenSupports);
+        mCachedScreenArray.AppendObject(screen);
       }
     }
 
     if (screenInfo) {
       XFree(screenInfo);
     }
   }
 
@@ -160,40 +155,33 @@ nsScreenManagerGtk :: ScreenForRect ( PR
   // which screen ( index from zero ) should we return?
   PRUint32 which = 0;
   // Optimize for the common case.  If the number of screens is only
   // one then this will fall through with which == 0 and will get the
   // primary screen.
   if (mNumScreens > 1) {
     // walk the list of screens and find the one that has the most
     // surface area.
-    PRUint32 count;
-    mCachedScreenArray->Count(&count);
-    PRUint32 i;
     PRUint32 area = 0;
     nsRect   windowRect(aX, aY, aWidth, aHeight);
-    for (i=0; i < count; i++) {
+    for (PRInt32 i = 0, i_end = mCachedScreenArray.Count(); i < i_end; ++i) {
       PRInt32  x, y, width, height;
       x = y = width = height = 0;
-      nsCOMPtr<nsIScreen> screen;
-      mCachedScreenArray->GetElementAt(i, getter_AddRefs(screen));
-      screen->GetRect(&x, &y, &width, &height);
+      mCachedScreenArray[i]->GetRect(&x, &y, &width, &height);
       // calculate the surface area
       nsRect screenRect(x, y, width, height);
       screenRect.IntersectRect(screenRect, windowRect);
       PRUint32 tempArea = screenRect.width * screenRect.height;
       if (tempArea >= area) {
         which = i;
         area = tempArea;
       }
     }
   }
-  nsCOMPtr<nsIScreen> outScreen;
-  mCachedScreenArray->GetElementAt(which, getter_AddRefs(outScreen));
-  *aOutScreen = outScreen.get();
+  *aOutScreen = mCachedScreenArray.SafeObjectAt(which);
   NS_IF_ADDREF(*aOutScreen);
   return NS_OK;
     
 } // ScreenForRect
 
 
 //
 // GetPrimaryScreen
@@ -205,19 +193,17 @@ nsScreenManagerGtk :: GetPrimaryScreen(n
 nsScreenManagerGtk :: GetPrimaryScreen(nsIScreen * *aPrimaryScreen) 
 {
   nsresult rv;
   rv =  EnsureInit();
   if (NS_FAILED(rv)) {
     NS_ERROR("nsScreenManagerGtk::EnsureInit() failed from GetPrimaryScreen\n");
     return rv;
   }
-  nsCOMPtr <nsIScreen> screen;
-  mCachedScreenArray->GetElementAt(0, getter_AddRefs(screen));
-  *aPrimaryScreen = screen.get();
+  *aPrimaryScreen = mCachedScreenArray.SafeObjectAt(0);
   NS_IF_ADDREF(*aPrimaryScreen);
   return NS_OK;
   
 } // GetPrimaryScreen
 
 
 //
 // GetNumberOfScreens
diff --git a/widget/src/gtk2/nsScreenManagerGtk.h b/widget/src/gtk2/nsScreenManagerGtk.h
--- a/widget/src/gtk2/nsScreenManagerGtk.h
+++ b/widget/src/gtk2/nsScreenManagerGtk.h
@@ -15,16 +15,17 @@
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 2000
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -36,17 +37,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsScreenManagerGtk_h___
 #define nsScreenManagerGtk_h___
 
 #include "nsIScreenManager.h"
 #include "nsIScreen.h"
 #include "nsCOMPtr.h"
-#include "nsISupportsArray.h"
+#include "nsCOMArray.h"
 
 //------------------------------------------------------------------------
 
 class nsScreenManagerGtk : public nsIScreenManager
 {
 public:
   nsScreenManagerGtk ( );
   virtual ~nsScreenManagerGtk();
@@ -55,15 +56,15 @@ public:
   NS_DECL_NSISCREENMANAGER
 
 private:
 
   nsresult EnsureInit(void);
 
   // cache the primary screen object to avoid memory allocation every
   // time
-  nsCOMPtr<nsISupportsArray> mCachedScreenArray;
+  nsCOMArray<nsIScreen> mCachedScreenArray;
   // how many screens do we have?
   int mNumScreens;
 
 };
 
 #endif  // nsScreenManagerGtk_h___ 
