From: L. David Baron <dbaron@dbaron.org>

Use the non-inherited hints from the parent style context when that parent style context is on a child frame.

(Originally written as part of bug 828312.)

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -2711,20 +2711,28 @@ ElementRestyler::RestyleSelf(nsIFrame* a
   const nsCSSPseudoElements::Type pseudoType = oldContext->GetPseudoType();
 
   nsStyleContext* parentContext;
   // Get the frame providing the parent style context.  If it is a
   // child, then resolve the provider first.
   nsIFrame* providerFrame = aSelf->GetParentStyleContextFrame();
   bool isChild = providerFrame && providerFrame->GetParent() == aSelf;
   if (!isChild) {
-    if (providerFrame)
+    if (providerFrame) {
       parentContext = providerFrame->StyleContext();
-    else
+
+      if (providerFrame != aSelf->GetParent()) {
+        // We don't actually know what the parent style context's
+        // non-inherited hints were, so assume the worst.
+        mParentFrameHintsNotHandledForDescendants =
+          nsChangeHint_Hints_NotHandledForDescendants;
+      }
+    } else {
       parentContext = nullptr;
+    }
   }
   else {
     MOZ_ASSERT(providerFrame->GetContent() == aSelf->GetContent(),
                "Postcondition for GetParentStyleContextFrame() violated. "
                "That means we need to add the current element to the "
                "ancestor filter.");
 
     // resolve the provider here (before aSelf below).
@@ -2735,34 +2743,29 @@ ElementRestyler::RestyleSelf(nsIFrame* a
     // can't be trusted because it assumes any changes to the parent
     // style context provider will be automatically propagated to
     // the frame(s) with child style contexts.
 
     ElementRestyler providerRestyler(PARENT_CONTEXT_FROM_CHILD_FRAME,
                                      *this, providerFrame);
     providerRestyler.Restyle(aRestyleHint);
     assumeDifferenceHint = providerRestyler.HintsHandledForFrame();
+    mParentFrameHintsNotHandledForDescendants =
+      providerRestyler.HintsNotHandledForDescendants();
 
     // The provider's new context becomes the parent context of
     // aSelf's context.
     parentContext = providerFrame->StyleContext();
     // Set |mResolvedChild| so we don't bother resolving the
     // provider again.
     mResolvedChild = providerFrame;
     // Continue restyling past the odd style context inheritance.
     result = eRestyleResult_Continue;
   }
 
-  if (providerFrame != aSelf->GetParent()) {
-    // We don't actually know what the parent style context's
-    // non-inherited hints were, so assume the worst.
-    mParentFrameHintsNotHandledForDescendants =
-      nsChangeHint_Hints_NotHandledForDescendants;
-  }
-
   // We don't support using eRestyle_StyleAttribute when pseudo-elements
   // are involved.  This is mostly irrelevant since style attribute
   // changes on pseudo-elements are very rare, though it does mean we
   // don't get the optimization for table elements.
   if (pseudoType != nsCSSPseudoElements::ePseudo_NotPseudoElement &&
       (aRestyleHint & eRestyle_StyleAttribute)) {
     aRestyleHint = (aRestyleHint & ~eRestyle_StyleAttribute) | eRestyle_Self;
   }
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -421,16 +421,19 @@ public:
    * mHintsHandled changes over time; it starts off as the hints that
    * have been handled by ancestors, and by the end of Restyle it
    * represents the hints that have been handled for this frame.  This
    * method is intended to be called after Restyle, to find out what
    * hints have been handled for this frame.
    */
   nsChangeHint HintsHandledForFrame() { return mHintsHandled; }
 
+  nsChangeHint HintsNotHandledForDescendants()
+    { return mHintsNotHandledForDescendants; }
+
 private:
   // Enum for the result of RestyleSelf, which indicates whether the
   // restyle procedure should continue to the children, and how.
   //
   // These values must be ordered so that later values imply that all
   // the work of the earlier values is also done.
   enum RestyleResult {
 
