From: L. David Baron <dbaron@dbaron.org>

Make the 'noappend' selector optimizations only restyle later siblings, which is what they need to do.  (Bug 534804)  r=bzbarsky

diff --git a/content/base/public/nsINode.h b/content/base/public/nsINode.h
--- a/content/base/public/nsINode.h
+++ b/content/base/public/nsINode.h
@@ -134,28 +134,29 @@ enum {
   // removal, or appending of children requires restyling the parent.
   NODE_HAS_SLOW_SELECTOR =       0x00004000U,
 
   // A child of the node has a :first-child, :-moz-first-node,
   // :only-child, :last-child or :-moz-last-node selector.
   NODE_HAS_EDGE_CHILD_SELECTOR = 0x00008000U,
 
   // A child of the node has a selector such that any insertion or
-  // removal of children requires restyling the parent (but append is
-  // OK).  Additionally (in this manner it is stronger than
-  // NODE_HAS_SLOW_SELECTOR), if a child's style changes in any way
-  // (e.g., the child changes to or from matching :empty due to a
-  // grandchild changes), the node must also be restyled.
-  NODE_HAS_SLOW_SELECTOR_NOAPPEND
+  // removal of children requires restyling later siblings of that
+  // element.  Additionally (in this manner it is stronger than
+  // NODE_HAS_SLOW_SELECTOR), if a child's style changes due to any
+  // other content tree changes (e.g., the child changes to or from
+  // matching :empty due to a grandchild insertion or removal), the
+  // child's later siblings must also be restyled.
+  NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS
                                = 0x00010000U,
 
   NODE_ALL_SELECTOR_FLAGS =      NODE_HAS_EMPTY_SELECTOR |
                                  NODE_HAS_SLOW_SELECTOR |
                                  NODE_HAS_EDGE_CHILD_SELECTOR |
-                                 NODE_HAS_SLOW_SELECTOR_NOAPPEND,
+                                 NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS,
 
   NODE_MAY_HAVE_CONTENT_EDITABLE_ATTR
                                = 0x00020000U,
 
   NODE_ATTACH_BINDING_ON_POSTCREATE
                                = 0x00040000U,
 
   // This node needs to go through frame construction to get a frame (or
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -11315,26 +11315,26 @@ nsCSSFrameConstructor::ReframeContaining
   // If we get here, we're screwed!
   return RecreateFramesForContent(mPresShell->GetDocument()->GetRootElement(),
 				  PR_TRUE);
 }
 
 void
 nsCSSFrameConstructor::RestyleForEmptyChange(Element* aContainer)
 {
-  Element* toRestyle = aContainer;
   // In some cases (:empty + E, :empty ~ E), a change if the content of
   // an element requires restyling its grandparent, because it changes
   // its parent's :empty state.
+  nsRestyleHint hint = eRestyle_Self;
   nsIContent* grandparent = aContainer->GetParent();
   if (grandparent &&
-      (grandparent->GetFlags() & NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
-    toRestyle = grandparent->AsElement();
-  }
-  PostRestyleEvent(toRestyle, eRestyle_Self, NS_STYLE_HINT_NONE);
+      (grandparent->GetFlags() & NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS)) {
+    hint = nsRestyleHint(hint | eRestyle_LaterSiblings);
+  }
+  PostRestyleEvent(aContainer, hint, NS_STYLE_HINT_NONE);
 }
 
 void
 nsCSSFrameConstructor::RestyleForAppend(Element* aContainer,
                                         nsIContent* aFirstNewContent)
 {
   NS_ASSERTION(aContainer, "must have container for append");
 #ifdef DEBUG
@@ -11342,17 +11342,17 @@ nsCSSFrameConstructor::RestyleForAppend(
     for (nsIContent* cur = aFirstNewContent; cur; cur = cur->GetNextSibling()) {
       NS_ASSERTION(!cur->IsRootOfAnonymousSubtree(),
                    "anonymous nodes should not be in child lists");
     }
   }
 #endif
   PRUint32 selectorFlags =
     aContainer->GetFlags() & (NODE_ALL_SELECTOR_FLAGS &
-                              ~NODE_HAS_SLOW_SELECTOR_NOAPPEND);
+                              ~NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS);
   if (selectorFlags == 0)
     return;
 
   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
     // see whether we need to restyle the container
     PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
     for (nsIContent* cur = aContainer->GetFirstChild();
          cur != aFirstNewContent;
@@ -11386,16 +11386,32 @@ nsCSSFrameConstructor::RestyleForAppend(
       if (cur->IsElement()) {
         PostRestyleEvent(cur->AsElement(), eRestyle_Self, NS_STYLE_HINT_NONE);
         break;
       }
     }
   }
 }
 
+static void
+RestyleSiblingsStartingWith(nsCSSFrameConstructor *aFrameConstructor,
+                            nsIContent *aStartingSibling /* may be null */)
+{
+  for (nsIContent *sibling = aStartingSibling; sibling;
+       sibling = sibling->GetNextSibling()) {
+    if (sibling->IsElement()) {
+      aFrameConstructor->
+        PostRestyleEvent(sibling->AsElement(),
+                         nsRestyleHint(eRestyle_Self | eRestyle_LaterSiblings),
+                         NS_STYLE_HINT_NONE);
+      break;
+    }
+  }
+}
+
 // Restyling for a ContentInserted or CharacterDataChanged notification.
 // This could be used for ContentRemoved as well if we got the
 // notification before the removal happened (and sometimes
 // CharacterDataChanged is more like a removal than an addition).
 // The comments are written and variables are named in terms of it being
 // a ContentInserted notification.
 void
 nsCSSFrameConstructor::RestyleForInsertOrChange(Element* aContainer,
@@ -11426,23 +11442,28 @@ nsCSSFrameConstructor::RestyleForInsertO
       }
     }
     if (wasEmpty) {
       RestyleForEmptyChange(aContainer);
       return;
     }
   }
 
-  if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
-                       NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
+  if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
     PostRestyleEvent(aContainer, eRestyle_Self, NS_STYLE_HINT_NONE);
     // Restyling the container is the most we can do here, so we're done.
     return;
   }
 
+  if (selectorFlags & NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS) {
+    // Restyle all later siblings. (We can't use PostRestyleEvent directly
+    // since aChild->GetNextSibling() might not be an element).
+    RestyleSiblingsStartingWith(this, aChild->GetNextSibling());
+  }
+
   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
     // restyle the previously-first element child if it is after this node
     PRBool passedChild = PR_FALSE;
     for (nsIContent* content = aContainer->GetFirstChild();
          content;
          content = content->GetNextSibling()) {
       if (content == aChild) {
         passedChild = PR_TRUE;
@@ -11504,23 +11525,27 @@ nsCSSFrameConstructor::RestyleForRemove(
       }
     }
     if (isEmpty) {
       RestyleForEmptyChange(aContainer);
       return;
     }
   }
 
-  if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
-                       NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
+  if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
     PostRestyleEvent(aContainer, eRestyle_Self, NS_STYLE_HINT_NONE);
     // Restyling the container is the most we can do here, so we're done.
     return;
   }
 
+  if (selectorFlags & NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS) {
+    // Restyle all later siblings.
+    RestyleSiblingsStartingWith(this, aFollowingSibling);
+  }
+
   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
     // restyle the now-first element child if it was after aOldChild
     PRBool reachedFollowingSibling = PR_FALSE;
     for (nsIContent* content = aContainer->GetFirstChild();
          content;
          content = content->GetNextSibling()) {
       if (content == aFollowingSibling) {
         reachedFollowingSibling = PR_TRUE;
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1439,17 +1439,17 @@ nthChildGenericMatches(RuleProcessorData
   if (!parent) {
     return PR_FALSE;
   }
 
   if (aTreeMatchContext.mForStyling) {
     if (isFromEnd)
       parent->SetFlags(NODE_HAS_SLOW_SELECTOR);
     else
-      parent->SetFlags(NODE_HAS_SLOW_SELECTOR_NOAPPEND);
+      parent->SetFlags(NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS);
   }
 
   const PRInt32 index = data.GetNthIndex(isOfType, isFromEnd, PR_FALSE);
   if (index <= 0) {
     // Node is anonymous content (not really a child of its parent).
     return PR_FALSE;
   }
 
@@ -1476,17 +1476,17 @@ edgeOfTypeMatches(RuleProcessorData& dat
   if (!parent) {
     return PR_FALSE;
   }
 
   if (aTreeMatchContext.mForStyling) {
     if (checkLast)
       parent->SetFlags(NODE_HAS_SLOW_SELECTOR);
     else
-      parent->SetFlags(NODE_HAS_SLOW_SELECTOR_NOAPPEND);
+      parent->SetFlags(NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS);
   }
 
   return (!checkFirst ||
           data.GetNthIndex(PR_TRUE, PR_FALSE, PR_TRUE) == 1) &&
          (!checkLast ||
           data.GetNthIndex(PR_TRUE, PR_TRUE, PR_TRUE) == 1);
 }
 
@@ -2119,17 +2119,17 @@ static PRBool SelectorMatchesTree(RulePr
         PRUnichar('~') == selector->mOperator) {
       // The relevant link must be an ancestor of the node being matched.
       aLookForRelevantLink = PR_FALSE;
       data = prevdata->mPreviousSiblingData;
       if (!data) {
         nsIContent* parent = prevdata->mParentContent;
         if (parent) {
           if (aTreeMatchContext.mForStyling)
-            parent->SetFlags(NODE_HAS_SLOW_SELECTOR_NOAPPEND);
+            parent->SetFlags(NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS);
 
           PRInt32 index = parent->IndexOf(prevdata->mElement);
           while (0 <= --index) {
             nsIContent* content = parent->GetChildAt(index);
             if (content->IsElement()) {
               data = RuleProcessorData::Create(prevdata->mPresContext,
                                                content->AsElement(),
                                                prevdata->mRuleWalker,
