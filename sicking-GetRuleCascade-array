Get rid of a temporary array in GetRuleCascade.  b=408135  Patch by sicking.

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -2094,26 +2094,6 @@ FillArray(nsHashKey* aKey, void* aData, 
   return PR_TRUE;
 }
 
-/**
- * Takes the hashtable of arrays (keyed by weight, in order sort) and
- * puts them all in one big array which has a primary sort by weight
- * and secondary sort by order.
- */
-static void PutRulesInList(nsObjectHashtable* aRuleArrays,
-                           nsVoidArray* aWeightedRules)
-{
-  PRInt32 arrayCount = aRuleArrays->Count();
-  RuleArrayData* arrayData = new RuleArrayData[arrayCount];
-  FillArrayData faData(arrayData);
-  aRuleArrays->Enumerate(FillArray, &faData);
-  NS_QuickSort(arrayData, arrayCount, sizeof(RuleArrayData),
-               CompareArrayData, nsnull);
-  for (PRInt32 i = 0; i < arrayCount; ++i)
-    aWeightedRules->AppendElements(*arrayData[i].mRuleArray);
-
-  delete [] arrayData;
-}
-
 RuleCascadeData*
 nsCSSRuleProcessor::GetRuleCascade(nsPresContext* aPresContext)
 {
@@ -2133,22 +2113,33 @@ nsCSSRuleProcessor::GetRuleCascade(nsPre
   }
 
   if (mSheets.Count() != 0) {
-    cascade = new RuleCascadeData(medium,
-                                  eCompatibility_NavQuirks == aPresContext->CompatibilityMode());
-    if (cascade) {
-      CascadeEnumData data(aPresContext, cascade->mRuleHash.Arena());
+    nsAutoPtr<RuleCascadeData> newCascade(
+      new RuleCascadeData(medium,
+                          eCompatibility_NavQuirks == aPresContext->CompatibilityMode()));
+    if (newCascade) {
+      CascadeEnumData data(aPresContext, newCascade->mRuleHash.Arena());
       mSheets.EnumerateForwards(CascadeSheetRulesInto, &data);
-      nsVoidArray weightedRules;
-      PutRulesInList(&data.mRuleArrays, &weightedRules);
+
+      // Take the hashtable of arrays (keyed by weight, in order sort) and
+      // sort by weight and secondary sort by order.
+      PRInt32 arrayCount = data.mRuleArrays.Count();
+      nsAutoArrayPtr<RuleArrayData> arrayData(new RuleArrayData[arrayCount]);
+      FillArrayData faData(arrayData);
+      data.mRuleArrays.Enumerate(FillArray, &faData);
+      NS_QuickSort(arrayData, arrayCount, sizeof(RuleArrayData),
+                   CompareArrayData, nsnull);
 
       // Put things into the rule hash backwards because it's easier to
       // build a singly linked list lowest-first that way.
-      if (!weightedRules.EnumerateBackwards(AddRule, cascade)) {
-        delete cascade;
-        cascade = nsnull;
+      for (PRInt32 i = arrayCount - 1; i >= 0; --i) {
+        if (!arrayData[i].mRuleArray->EnumerateBackwards(AddRule,
+                                                         newCascade)) {
+          return nsnull;
+        }
       }
 
-      *cascadep = cascade;
+      *cascadep = newCascade;
+      cascade = newCascade.forget();
     }
   }
   return cascade;
