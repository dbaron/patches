From: L. David Baron <dbaron@dbaron.org>

Make threadsafe reference counting use the minimum memory sychronization needed.

MozReview-Commit-ID: 7xByCXt17Dr

diff --git a/xpcom/glue/nsISupportsImpl.h b/xpcom/glue/nsISupportsImpl.h
--- a/xpcom/glue/nsISupportsImpl.h
+++ b/xpcom/glue/nsISupportsImpl.h
@@ -335,34 +335,52 @@ private:
 namespace mozilla {
 class ThreadSafeAutoRefCnt
 {
 public:
   ThreadSafeAutoRefCnt() : mValue(0) {}
   explicit ThreadSafeAutoRefCnt(nsrefcnt aValue) : mValue(aValue) {}
 
   // only support prefix increment/decrement
-  MOZ_ALWAYS_INLINE nsrefcnt operator++() { return ++mValue; }
-  MOZ_ALWAYS_INLINE nsrefcnt operator--() { return --mValue; }
+  MOZ_ALWAYS_INLINE nsrefcnt operator++()
+  {
+    return mValue.fetch_add(1, std::memory_order_relaxed);
+  }
+  MOZ_ALWAYS_INLINE nsrefcnt operator--()
+  {
+    nsrefcnt result = mValue.fetch_sub(1, std::memory_order_release);
+    if (result == 0) {
+      // We're going to destroy the object on this thread, so we need an
+      // acquire to synchronize with the memory released by the last
+      // release on other threads.
+      result = mValue.load(std::memory_order_acquire);
+    }
+    return result;
+  }
 
   MOZ_ALWAYS_INLINE nsrefcnt operator=(nsrefcnt aValue)
   {
-    return (mValue = aValue);
+    // Use release semantics since we're not sure what the caller is
+    // doing.
+    mValue.store(aValue, std::memory_order_release);
+    return aValue;
   }
-  MOZ_ALWAYS_INLINE operator nsrefcnt() const { return mValue; }
-  MOZ_ALWAYS_INLINE nsrefcnt get() const { return mValue; }
+  MOZ_ALWAYS_INLINE operator nsrefcnt() const { return get(); }
+  MOZ_ALWAYS_INLINE nsrefcnt get() const
+  {
+    // Use acquire semantics since we're not sure what the caller is
+    // doing.
+    return mValue.load(std::memory_order_acquire);
+  }
 
   static const bool isThreadSafe = true;
 private:
   nsrefcnt operator++(int) = delete;
   nsrefcnt operator--(int) = delete;
-  // In theory, RelaseAcquire consistency (but no weaker) is sufficient for
-  // the counter. Making it weaker could speed up builds on ARM (but not x86),
-  // but could break pre-existing code that assumes sequential consistency.
-  Atomic<nsrefcnt> mValue;
+  std::atomic<nsrefcnt> mValue;
 };
 } // namespace mozilla
 #endif
 
 ///////////////////////////////////////////////////////////////////////////////
 
 /**
  * Declare the reference count variable and the implementations of the
