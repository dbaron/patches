From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Make AddStyleUpdatesTo only add updates that need to be done, and make RuleNodeWithReplacement interact with the nsAnimationManager and nsTransitionManager in a more typical way.

FIXME: This needs reexamination of what happened when merging!

diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -20,26 +20,16 @@
 #include "nsIFrame.h"
 #include "nsIDocument.h"
 #include <math.h>
 
 using namespace mozilla;
 using namespace mozilla::css;
 
 void
-nsAnimationManager::UpdateStyleAndEvents(CommonElementAnimationData* aEA,
-                                         TimeStamp aRefreshTime,
-                                         EnsureStyleRuleFlags aFlags)
-{
-  aEA->EnsureStyleRuleFor(aRefreshTime, aFlags);
-  GetEventsAt(aEA, aRefreshTime, mPendingEvents);
-  CheckNeedsRefresh();
-}
-
-void
 nsAnimationManager::GetEventsAt(CommonElementAnimationData* aEA,
                                 TimeStamp aRefreshTime,
                                 EventArray& aEventsToDispatch)
 {
   for (uint32_t animIdx = aEA->mAnimations.Length(); animIdx-- != 0; ) {
     ElementAnimation* anim = aEA->mAnimations[animIdx];
 
     TimeDuration localTime = anim->GetLocalTimeAt(aRefreshTime);
@@ -783,20 +773,40 @@ nsAnimationManager::StopAllAnimations()
     if (needsRestyle) {
       ea->PostRestyleForAnimation(mPresContext);
     }
   }
 }
 void
 nsAnimationManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
 {
+  TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+
   PRCList *next = PR_LIST_HEAD(&mElementData);
   while (next != &mElementData) {
     CommonElementAnimationData *ea = static_cast<CommonElementAnimationData*>(next);
     next = PR_NEXT_LINK(next);
 
+    nsRefPtr<css::AnimValuesStyleRule> oldStyleRule = ea->mStyleRule;
+    ea->EnsureStyleRuleFor(now, false);
+    ea->GetEventsAt(now, mPendingEvents);
+#if 0
+    // FIXME: It would be nice to check this; it would allow us to skip
+    // a good bit of duplication of work.  Unfortunately it's the norm
+    // that we have already updated the style rule, but not yet
+    // restyled.
+    if (oldStyleRule == ea->mStyleRule) {
+      // No style to update.
+      continue;
+    }
+#endif
+
     dom::Element* elementToRestyle = ea->ElementToRestyle();
     if (elementToRestyle) {
       aTracker.AddPendingRestyle(elementToRestyle, eRestyle_CSSAnimations,
                                  nsChangeHint(0));
     }
   }
+
+  // FIXME: Do something with mPendingEvents?
+
+  CheckNeedsRefresh();
 }
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -72,19 +72,16 @@ public:
       if (aContent->GetProperty(nsGkAtoms::animationsProperty)) {
         return true;
       }
     } while ((aContent = aContent->GetParent()));
 
     return false;
   }
 
-  void UpdateStyleAndEvents(mozilla::css::CommonElementAnimationData* aEA,
-                            mozilla::TimeStamp aRefreshTime,
-                            mozilla::EnsureStyleRuleFlags aFlags);
   void GetEventsAt(mozilla::css::CommonElementAnimationData* aEA,
                    mozilla::TimeStamp aRefreshTime,
                    EventArray &aEventsToDispatch);
 
   // nsIStyleRuleProcessor (parts)
   virtual void RulesMatching(ElementRuleProcessorData* aData) MOZ_OVERRIDE;
   virtual void RulesMatching(PseudoElementRuleProcessorData* aData) MOZ_OVERRIDE;
   virtual void RulesMatching(AnonBoxRuleProcessorData* aData) MOZ_OVERRIDE;
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1366,36 +1366,30 @@ nsStyleSet::RuleNodeWithReplacement(Elem
           // FileRules does.
           nsAnimationManager* animationManager =
             PresContext()->AnimationManager();
           CommonElementAnimationData* ea = animationManager->GetElementAnimations(
             aElement, aPseudoType, false);
           NS_ASSERTION(ea,
             "Rule has level eAnimationSheet without animation on manager");
 
-          animationManager->UpdateStyleAndEvents(
-            ea, PresContext()->RefreshDriver()->MostRecentRefresh(),
-            EnsureStyleRule_IsNotThrottled);
           ruleWalker.ForwardOnPossiblyCSSRule(ea->mStyleRule);
         }
         break;
       case eRestyle_CSSTransitions:
         {
           // FIXME: This should probably be more similar to what
           // FileRules does.
           nsPresContext* presContext = PresContext();
           CommonElementAnimationData* et =
             presContext->TransitionManager()->GetElementTransitions(
               aElement, aPseudoType, false);
           NS_ASSERTION(et,
             "Rule has level eTransitionSheet without transition on manager");
 
-          et->EnsureStyleRuleFor(
-            presContext->RefreshDriver()->MostRecentRefresh(),
-            EnsureStyleRule_IsNotThrottled);
           ruleWalker.ForwardOnPossiblyCSSRule(et->mStyleRule);
         }
         break;
       default:
         break;
       }
     }
 
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -69,21 +69,39 @@ ElementPropertyTransition::ValuePortionF
 
 /*****************************************************************************
  * nsTransitionManager                                                       *
  *****************************************************************************/
 
 void
 nsTransitionManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
 {
+  // FIXME: Do we need to do something with events like FlushTransitions
+  // does?
+
+  TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+
   PRCList *next = PR_LIST_HEAD(&mElementData);
   while (next != &mElementData) {
     CommonElementAnimationData *et = static_cast<CommonElementAnimationData*>(next);
     next = PR_NEXT_LINK(next);
 
+    nsRefPtr<css::AnimValuesStyleRule> oldStyleRule = et->mStyleRule;
+    et->EnsureStyleRuleFor(now);
+#if 0
+    // FIXME: It would be nice to check this; it would allow us to skip
+    // a good bit of duplication of work.  Unfortunately it's the norm
+    // that we have already updated the style rule, but not yet
+    // restyled.
+    if (oldStyleRule == et->mStyleRule) {
+      // No style to update.
+      continue;
+    }
+#endif
+
     dom::Element* elementToRestyle = et->ElementToRestyle();
     if (elementToRestyle) {
       aTracker.AddPendingRestyle(elementToRestyle, eRestyle_CSSTransitions,
                                  nsChangeHint(0));
     }
   }
 }
 
@@ -335,16 +353,17 @@ nsTransitionManager::StyleContextChanged
     AnimationProperty& prop = animation->mProperties[0];
     AnimationPropertySegment& segment = prop.mSegments[0];
     if (whichStarted.HasProperty(prop.mProperty)) {
       coverRule->AddValue(prop.mProperty, segment.mFromValue);
     }
   }
 
   et->mStyleRule = nullptr;
+  et->EnsureStyleRuleFor(mPresContext->RefreshDriver()->MostRecentRefresh());
 
   return coverRule.forget();
 }
 
 void
 nsTransitionManager::ConsiderStartingTransition(nsCSSProperty aProperty,
                                                 const nsTransition& aTransition,
                                                 dom::Element* aElement,
@@ -821,16 +840,17 @@ nsTransitionManager::FlushTransitions(Fl
 
       // We need to restyle even if the transition rule no longer
       // applies (in which case we just made it not apply).
       NS_ASSERTION(et->mElementProperty == nsGkAtoms::transitionsProperty ||
                    et->mElementProperty == nsGkAtoms::transitionsOfBeforeProperty ||
                    et->mElementProperty == nsGkAtoms::transitionsOfAfterProperty,
                    "Unexpected element property; might restyle too much");
       if (!canThrottleTick || transitionStartedOrEnded) {
+        et->EnsureStyleRuleFor(now);
         et->PostRestyleForAnimation(mPresContext);
       } else {
         didThrottle = true;
       }
 
       if (et->mAnimations.IsEmpty()) {
         et->Destroy();
         // |et| is now a dangling pointer!
