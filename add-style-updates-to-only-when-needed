From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Make AddStyleUpdatesTo only add updates that need to be done, and make RuleNodeWithReplacement interact with the nsAnimationManager and nsTransitionManager in a more typical way.

FIXME: This needs reexamination of what happened when merging!

diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -165,22 +165,46 @@ CommonAnimationManager::SizeOfExcludingT
 CommonAnimationManager::SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
 {
   return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
 }
 
 void
 CommonAnimationManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
 {
+  // FIXME: Do we need to do something with events like FlushTransitions
+  // does?  (maybe transitions only?)
+
+  TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+
   PRCList* next = PR_LIST_HEAD(&mElementCollections);
   while (next != &mElementCollections) {
     AnimationPlayerCollection* collection =
       static_cast<AnimationPlayerCollection*>(next);
     next = PR_NEXT_LINK(next);
 
+    nsRefPtr<css::AnimValuesStyleRule> oldStyleRule = collection->mStyleRule;
+    collection->EnsureStyleRuleFor(now);
+    // FIXME: For animations, need:
+//    GetEventsForCurrentTime(collection, mPendingEvents);
+
+#if 0
+    // FIXME: It would be nice to check this; it would allow us to skip
+    // a good bit of duplication of work.  Unfortunately it's the norm
+    // that we have already updated the style rule, but not yet
+    // restyled.  (Is that because of the FlushAnimations/FlushTransitions
+    // calls in PresShell::FlushPendingNotifications, which post updates
+    // before the animation-only style flush in ProcessPendingRestyles
+    // but aren't processed until later in ProcessPendingRestyles?)
+    if (oldStyleRule == collection->mStyleRule) {
+      // No style to update.
+      continue;
+    }
+#endif
+
     dom::Element* elementToRestyle = collection->GetElementToRestyle();
     if (elementToRestyle) {
       nsRestyleHint rshint = collection->IsForTransitions()
         ? eRestyle_CSSTransitions : eRestyle_CSSAnimations;
       aTracker.AddPendingRestyle(elementToRestyle, rshint, nsChangeHint(0));
     }
   }
 }
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -23,27 +23,16 @@
 #include <math.h>
 
 using namespace mozilla;
 using namespace mozilla::css;
 using mozilla::dom::Animation;
 using mozilla::dom::AnimationPlayer;
 
 void
-nsAnimationManager::UpdateStyleAndEvents(AnimationPlayerCollection*
-                                           aCollection,
-                                         TimeStamp aRefreshTime,
-                                         EnsureStyleRuleFlags aFlags)
-{
-  aCollection->EnsureStyleRuleFor(aRefreshTime, aFlags);
-  GetEventsForCurrentTime(aCollection, mPendingEvents);
-  CheckNeedsRefresh();
-}
-
-void
 nsAnimationManager::GetEventsForCurrentTime(AnimationPlayerCollection*
                                               aCollection,
                                             EventArray& aEventsToDispatch)
 {
   for (size_t playerIdx = aCollection->mPlayers.Length(); playerIdx-- != 0; ) {
     AnimationPlayer* player = aCollection->mPlayers[playerIdx];
     Animation* anim = player->GetSource();
     if (!anim) {
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -71,19 +71,16 @@ public:
       if (aContent->GetProperty(nsGkAtoms::animationsProperty)) {
         return true;
       }
     } while ((aContent = aContent->GetParent()));
 
     return false;
   }
 
-  void UpdateStyleAndEvents(mozilla::AnimationPlayerCollection* aEA,
-                            mozilla::TimeStamp aRefreshTime,
-                            mozilla::EnsureStyleRuleFlags aFlags);
   void GetEventsForCurrentTime(mozilla::AnimationPlayerCollection* aEA,
                                EventArray &aEventsToDispatch);
 
   // nsIStyleRuleProcessor (parts)
   virtual void RulesMatching(ElementRuleProcessorData* aData) MOZ_OVERRIDE;
   virtual void RulesMatching(PseudoElementRuleProcessorData* aData) MOZ_OVERRIDE;
   virtual void RulesMatching(AnonBoxRuleProcessorData* aData) MOZ_OVERRIDE;
 #ifdef MOZ_XUL
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1419,50 +1419,34 @@ nsStyleSet::RuleNodeWithReplacement(Elem
           // FileRules does; this feels like too much poking into the
           // internals of nsAnimationManager.
           nsPresContext* presContext = PresContext();
           nsAnimationManager* animationManager =
             presContext->AnimationManager();
           AnimationPlayerCollection* collection =
             animationManager->GetAnimationPlayers(aElement, aPseudoType, false);
 
-          if (collection) {
-            if (skipAnimationRules) {
-              collection->PostRestyleForAnimation(presContext);
-            } else {
-              animationManager->UpdateStyleAndEvents(
-                collection, PresContext()->RefreshDriver()->MostRecentRefresh(),
-                EnsureStyleRule_IsNotThrottled);
-              if (collection->mStyleRule) {
-                ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
-              }
-            }
+          // FIXME: Need to remove skipAnimationRules before this patch!
+          if (collection && collection->mStyleRule) {
+            ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
           }
           break;
         }
         case eRestyle_CSSTransitions: {
           // FIXME: This should probably be more similar to what
           // FileRules does; this feels like too much poking into the
           // internals of nsTransitionManager.
           nsPresContext* presContext = PresContext();
           AnimationPlayerCollection* collection =
             presContext->TransitionManager()->GetElementTransitions(
               aElement, aPseudoType, false);
 
-          if (collection) {
-            if (skipAnimationRules) {
-              collection->PostRestyleForAnimation(presContext);
-            } else {
-              collection->EnsureStyleRuleFor(
-                presContext->RefreshDriver()->MostRecentRefresh(),
-                EnsureStyleRule_IsNotThrottled);
-              if (collection->mStyleRule) {
-                ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
-              }
-            }
+          // FIXME: Need to remove skipAnimationRules before this patch!
+          if (collection && collection->mStyleRule) {
+            ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
           }
           break;
         }
         case eRestyle_SVGAttrAnimations: {
           MOZ_ASSERT(aReplacements & eRestyle_ChangeAnimationPhase,
                      "don't know how to do this level without phase change");
 
           SVGAttrAnimationRuleProcessor* ruleProcessor =
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -303,16 +303,17 @@ nsTransitionManager::StyleContextChanged
   }
 
   NS_ABORT_IF_FALSE(collection, "must have element transitions if we started "
                                 "any transitions");
 
   // Set the style rule refresh time to null so that EnsureStyleRuleFor
   // creates a new style rule.
   collection->mStyleRuleRefreshTime = TimeStamp();
+  collection->EnsureStyleRuleFor(mPresContext->RefreshDriver()->MostRecentRefresh());
 
   return true;
 }
 
 void
 nsTransitionManager::ConsiderStartingTransition(
   nsCSSProperty aProperty,
   const StyleTransition& aTransition,
@@ -795,16 +796,17 @@ nsTransitionManager::FlushTransitions(Fl
       MOZ_ASSERT(collection->mElementProperty ==
                    nsGkAtoms::transitionsProperty ||
                  collection->mElementProperty ==
                    nsGkAtoms::transitionsOfBeforeProperty ||
                  collection->mElementProperty ==
                    nsGkAtoms::transitionsOfAfterProperty,
                  "Unexpected element property; might restyle too much");
       if (!canThrottleTick || transitionStartedOrEnded) {
+        collection->EnsureStyleRuleFor(now);
         collection->PostRestyleForAnimation(mPresContext);
       } else {
         didThrottle = true;
       }
 
       if (collection->mPlayers.IsEmpty()) {
         collection->Destroy();
         // |collection| is now a dangling pointer!
