From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Make AddStyleUpdatesTo only add updates that need to be done, and make RuleNodeWithReplacement interact with the nsAnimationManager and nsTransitionManager in a more typical way.

FIXME: This needs reexamination of what happened when merging!

diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -20,27 +20,16 @@
 #include "nsIFrame.h"
 #include "nsIDocument.h"
 #include <math.h>
 
 using namespace mozilla;
 using namespace mozilla::css;
 
 void
-nsAnimationManager::UpdateStyleAndEvents(ElementAnimationCollection*
-                                           aCollection,
-                                         TimeStamp aRefreshTime,
-                                         EnsureStyleRuleFlags aFlags)
-{
-  aCollection->EnsureStyleRuleFor(aRefreshTime, aFlags);
-  GetEventsForCurrentTime(aCollection, mPendingEvents);
-  CheckNeedsRefresh();
-}
-
-void
 nsAnimationManager::GetEventsForCurrentTime(ElementAnimationCollection*
                                               aCollection,
                                             EventArray& aEventsToDispatch)
 {
   for (uint32_t animIdx = aCollection->mAnimations.Length(); animIdx-- != 0; ) {
     ElementAnimation* anim = aCollection->mAnimations[animIdx];
 
     ComputedTiming computedTiming = anim->GetComputedTiming(anim->mTiming);
@@ -817,20 +806,40 @@ nsAnimationManager::StopAllAnimations()
       collection->PostRestyleForAnimation(mPresContext);
     }
   }
 }
 
 void
 nsAnimationManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
 {
+  TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+
   PRCList *next = PR_LIST_HEAD(&mElementCollections);
   while (next != &mElementCollections) {
     ElementAnimationCollection *collection = static_cast<ElementAnimationCollection*>(next);
     next = PR_NEXT_LINK(next);
 
+    nsRefPtr<css::AnimValuesStyleRule> oldStyleRule = collection->mStyleRule;
+    collection->EnsureStyleRuleFor(now, false);
+    GetEventsForCurrentTime(collection, mPendingEvents);
+#if 0
+    // FIXME: It would be nice to check this; it would allow us to skip
+    // a good bit of duplication of work.  Unfortunately it's the norm
+    // that we have already updated the style rule, but not yet
+    // restyled.
+    if (oldStyleRule == collection->mStyleRule) {
+      // No style to update.
+      continue;
+    }
+#endif
+
     dom::Element* elementToRestyle = collection->ElementToRestyle();
     if (elementToRestyle) {
       aTracker.AddPendingRestyle(elementToRestyle, eRestyle_CSSAnimations,
                                  nsChangeHint(0));
     }
   }
+
+  // FIXME: Do something with mPendingEvents?
+
+  CheckNeedsRefresh();
 }
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -72,19 +72,16 @@ public:
       if (aContent->GetProperty(nsGkAtoms::animationsProperty)) {
         return true;
       }
     } while ((aContent = aContent->GetParent()));
 
     return false;
   }
 
-  void UpdateStyleAndEvents(mozilla::ElementAnimationCollection* aEA,
-                            mozilla::TimeStamp aRefreshTime,
-                            mozilla::EnsureStyleRuleFlags aFlags);
   void GetEventsForCurrentTime(mozilla::ElementAnimationCollection* aEA,
                                EventArray &aEventsToDispatch);
 
   // nsIStyleRuleProcessor (parts)
   virtual void RulesMatching(ElementRuleProcessorData* aData) MOZ_OVERRIDE;
   virtual void RulesMatching(PseudoElementRuleProcessorData* aData) MOZ_OVERRIDE;
   virtual void RulesMatching(AnonBoxRuleProcessorData* aData) MOZ_OVERRIDE;
 #ifdef MOZ_XUL
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1372,43 +1372,33 @@ nsStyleSet::RuleNodeWithReplacement(Elem
           // FIXME: This should probably be more similar to what
           // FileRules does; this feels like too much poking into the
           // internals of nsAnimationManager.
           nsAnimationManager* animationManager =
             PresContext()->AnimationManager();
           ElementAnimationCollection* collection = animationManager->GetElementAnimations(
             aElement, aPseudoType, false);
 
-          if (collection) {
-            animationManager->UpdateStyleAndEvents(
-              collection, PresContext()->RefreshDriver()->MostRecentRefresh(),
-              EnsureStyleRule_IsNotThrottled);
-            if (collection->mStyleRule) {
-              ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
-            }
+          if (collection && collection->mStyleRule) {
+            ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
           }
         }
         break;
       case eRestyle_CSSTransitions:
         {
           // FIXME: This should probably be more similar to what
           // FileRules does; this feels like too much poking into the
           // internals of nsTransitionManager.
           nsPresContext* presContext = PresContext();
           ElementAnimationCollection* collection =
             presContext->TransitionManager()->GetElementTransitions(
               aElement, aPseudoType, false);
 
-          if (collection) {
-            collection->EnsureStyleRuleFor(
-              presContext->RefreshDriver()->MostRecentRefresh(),
-              EnsureStyleRule_IsNotThrottled);
-            if (collection->mStyleRule) {
-              ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
-            }
+          if (collection && collection->mStyleRule) {
+            ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
           }
         }
         break;
       default:
         break;
       }
     }
 
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -70,21 +70,39 @@ ElementPropertyTransition::CurrentValueP
 
 /*****************************************************************************
  * nsTransitionManager                                                       *
  *****************************************************************************/
 
 void
 nsTransitionManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
 {
+  // FIXME: Do we need to do something with events like FlushTransitions
+  // does?
+
+  TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+
   PRCList *next = PR_LIST_HEAD(&mElementCollections);
   while (next != &mElementCollections) {
     ElementAnimationCollection *collection = static_cast<ElementAnimationCollection*>(next);
     next = PR_NEXT_LINK(next);
 
+    nsRefPtr<css::AnimValuesStyleRule> oldStyleRule = collection->mStyleRule;
+    collection->EnsureStyleRuleFor(now);
+#if 0
+    // FIXME: It would be nice to check this; it would allow us to skip
+    // a good bit of duplication of work.  Unfortunately it's the norm
+    // that we have already updated the style rule, but not yet
+    // restyled.
+    if (oldStyleRule == collection->mStyleRule) {
+      // No style to update.
+      continue;
+    }
+#endif
+
     dom::Element* elementToRestyle = collection->ElementToRestyle();
     if (elementToRestyle) {
       aTracker.AddPendingRestyle(elementToRestyle, eRestyle_CSSTransitions,
                                  nsChangeHint(0));
     }
   }
 }
 
@@ -350,16 +368,17 @@ nsTransitionManager::StyleContextChanged
     AnimationProperty& prop = animation->mProperties[0];
     AnimationPropertySegment& segment = prop.mSegments[0];
     if (whichStarted.HasProperty(prop.mProperty)) {
       coverRule->AddValue(prop.mProperty, segment.mFromValue);
     }
   }
 
   collection->mStyleRule = nullptr;
+  collection->EnsureStyleRuleFor(mPresContext->RefreshDriver()->MostRecentRefresh());
 
   return coverRule.forget();
 }
 
 void
 nsTransitionManager::ConsiderStartingTransition(
   nsCSSProperty aProperty,
   const StyleTransition& aTransition,
@@ -840,16 +859,17 @@ nsTransitionManager::FlushTransitions(Fl
       MOZ_ASSERT(collection->mElementProperty ==
                    nsGkAtoms::transitionsProperty ||
                  collection->mElementProperty ==
                    nsGkAtoms::transitionsOfBeforeProperty ||
                  collection->mElementProperty ==
                    nsGkAtoms::transitionsOfAfterProperty,
                  "Unexpected element property; might restyle too much");
       if (!canThrottleTick || transitionStartedOrEnded) {
+        collection->EnsureStyleRuleFor(now);
         collection->PostRestyleForAnimation(mPresContext);
       } else {
         didThrottle = true;
       }
 
       if (collection->mAnimations.IsEmpty()) {
         collection->Destroy();
         // |collection| is now a dangling pointer!
