From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Make AddStyleUpdatesTo only add updates that need to be done, and make RuleNodeWithReplacement interact with the nsAnimationManager and nsTransitionManager in a more typical way.

FIXME: This needs reexamination of what happened when merging!

diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -164,21 +164,45 @@ CommonAnimationManager::SizeOfExcludingT
 CommonAnimationManager::SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
 {
   return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
 }
 
 void
 CommonAnimationManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
 {
+  // FIXME: Do we need to do something with events like FlushTransitions
+  // does?  (maybe transitions only?)
+
+  TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+
   PRCList* next = PR_LIST_HEAD(&mElementCollections);
   while (next != &mElementCollections) {
     ElementAnimationCollection* collection = static_cast<ElementAnimationCollection*>(next);
     next = PR_NEXT_LINK(next);
 
+    nsRefPtr<css::AnimValuesStyleRule> oldStyleRule = collection->mStyleRule;
+    collection->EnsureStyleRuleFor(now);
+    // FIXME: For animations, need:
+//    GetEventsForCurrentTime(collection, mPendingEvents);
+
+#if 0
+    // FIXME: It would be nice to check this; it would allow us to skip
+    // a good bit of duplication of work.  Unfortunately it's the norm
+    // that we have already updated the style rule, but not yet
+    // restyled.  (Is that because of the FlushAnimations/FlushTransitions
+    // calls in PresShell::FlushPendingNotifications, which post updates
+    // before the animation-only style flush in ProcessPendingRestyles
+    // but aren't processed until later in ProcessPendingRestyles?)
+    if (oldStyleRule == collection->mStyleRule) {
+      // No style to update.
+      continue;
+    }
+#endif
+
     dom::Element* elementToRestyle = collection->ElementToRestyle();
     if (elementToRestyle) {
       nsRestyleHint rshint = collection->IsForTransitions()
         ? eRestyle_CSSTransitions : eRestyle_CSSAnimations;
       aTracker.AddPendingRestyle(elementToRestyle, rshint, nsChangeHint(0));
     }
   }
 }
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -20,27 +20,16 @@
 #include "nsIFrame.h"
 #include "nsIDocument.h"
 #include <math.h>
 
 using namespace mozilla;
 using namespace mozilla::css;
 
 void
-nsAnimationManager::UpdateStyleAndEvents(ElementAnimationCollection*
-                                           aCollection,
-                                         TimeStamp aRefreshTime,
-                                         EnsureStyleRuleFlags aFlags)
-{
-  aCollection->EnsureStyleRuleFor(aRefreshTime, aFlags);
-  GetEventsForCurrentTime(aCollection, mPendingEvents);
-  CheckNeedsRefresh();
-}
-
-void
 nsAnimationManager::GetEventsForCurrentTime(ElementAnimationCollection*
                                               aCollection,
                                             EventArray& aEventsToDispatch)
 {
   for (uint32_t animIdx = aCollection->mAnimations.Length(); animIdx-- != 0; ) {
     ElementAnimation* anim = aCollection->mAnimations[animIdx];
 
     ComputedTiming computedTiming = anim->GetComputedTiming(anim->mTiming);
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -71,19 +71,16 @@ public:
       if (aContent->GetProperty(nsGkAtoms::animationsProperty)) {
         return true;
       }
     } while ((aContent = aContent->GetParent()));
 
     return false;
   }
 
-  void UpdateStyleAndEvents(mozilla::ElementAnimationCollection* aEA,
-                            mozilla::TimeStamp aRefreshTime,
-                            mozilla::EnsureStyleRuleFlags aFlags);
   void GetEventsForCurrentTime(mozilla::ElementAnimationCollection* aEA,
                                EventArray &aEventsToDispatch);
 
   // nsIStyleRuleProcessor (parts)
   virtual void RulesMatching(ElementRuleProcessorData* aData) MOZ_OVERRIDE;
   virtual void RulesMatching(PseudoElementRuleProcessorData* aData) MOZ_OVERRIDE;
   virtual void RulesMatching(AnonBoxRuleProcessorData* aData) MOZ_OVERRIDE;
 #ifdef MOZ_XUL
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1378,42 +1378,32 @@ nsStyleSet::RuleNodeWithReplacement(Elem
           // FIXME: This should probably be more similar to what
           // FileRules does; this feels like too much poking into the
           // internals of nsAnimationManager.
           nsAnimationManager* animationManager =
             PresContext()->AnimationManager();
           ElementAnimationCollection* collection = animationManager->GetElementAnimations(
             aElement, aPseudoType, false);
 
-          if (collection) {
-            animationManager->UpdateStyleAndEvents(
-              collection, PresContext()->RefreshDriver()->MostRecentRefresh(),
-              EnsureStyleRule_IsNotThrottled);
-            if (collection->mStyleRule) {
-              ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
-            }
+          if (collection && collection->mStyleRule) {
+            ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
           }
           break;
         }
         case eRestyle_CSSTransitions: {
           // FIXME: This should probably be more similar to what
           // FileRules does; this feels like too much poking into the
           // internals of nsTransitionManager.
           nsPresContext* presContext = PresContext();
           ElementAnimationCollection* collection =
             presContext->TransitionManager()->GetElementTransitions(
               aElement, aPseudoType, false);
 
-          if (collection) {
-            collection->EnsureStyleRuleFor(
-              presContext->RefreshDriver()->MostRecentRefresh(),
-              EnsureStyleRule_IsNotThrottled);
-            if (collection->mStyleRule) {
-              ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
-            }
+          if (collection && collection->mStyleRule) {
+            ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
           }
           break;
         }
         case eRestyle_StyleAttribute: {
           if (!level->mIsImportant) {
             // First time through, we handle the non-!important rule.
             // FIXME: WRITE ME
 #if 0
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -335,16 +335,17 @@ nsTransitionManager::StyleContextChanged
     AnimationPropertySegment& segment = prop.mSegments[0];
     if (whichStarted.HasProperty(prop.mProperty)) {
       coverRule->AddValue(prop.mProperty, segment.mFromValue);
     }
   }
 
   collection->mStyleRule = nullptr;
   collection->mStyleRuleRefreshTime = TimeStamp(); // force rebuild
+  collection->EnsureStyleRuleFor(mPresContext->RefreshDriver()->MostRecentRefresh());
 
   return coverRule.forget();
 }
 
 void
 nsTransitionManager::ConsiderStartingTransition(
   nsCSSProperty aProperty,
   const StyleTransition& aTransition,
@@ -823,16 +824,17 @@ nsTransitionManager::FlushTransitions(Fl
       MOZ_ASSERT(collection->mElementProperty ==
                    nsGkAtoms::transitionsProperty ||
                  collection->mElementProperty ==
                    nsGkAtoms::transitionsOfBeforeProperty ||
                  collection->mElementProperty ==
                    nsGkAtoms::transitionsOfAfterProperty,
                  "Unexpected element property; might restyle too much");
       if (!canThrottleTick || transitionStartedOrEnded) {
+        collection->EnsureStyleRuleFor(now);
         collection->PostRestyleForAnimation(mPresContext);
       } else {
         didThrottle = true;
       }
 
       if (collection->mAnimations.IsEmpty()) {
         collection->Destroy();
         // |collection| is now a dangling pointer!
