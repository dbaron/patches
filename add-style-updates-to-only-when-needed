From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Make AddStyleUpdatesTo only add updates that need to be done, and make RuleNodeWithReplacement interact with the nsAnimationManager and nsTransitionManager in a more typical way.

diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -473,26 +473,16 @@ nsAnimationManager::GetElementAnimations
     }
 
     AddElementData(ea);
   }
 
   return ea;
 }
 
-
-void
-nsAnimationManager::EnsureStyleRuleFor(ElementAnimations* aET)
-{
-  aET->EnsureStyleRuleFor(mPresContext->RefreshDriver()->MostRecentRefresh(),
-                          mPendingEvents,
-                          false);
-  CheckNeedsRefresh();
-}
-
 /* virtual */ void
 nsAnimationManager::RulesMatching(ElementRuleProcessorData* aData)
 {
   NS_ABORT_IF_FALSE(aData->mPresContext == mPresContext,
                     "pres context mismatch");
   nsIStyleRule *rule =
     GetAnimationRule(aData->mElement,
                      nsCSSPseudoElements::ePseudo_NotPseudoElement);
@@ -1144,20 +1134,39 @@ nsAnimationManager::StopAllAnimations()
     if (needsRestyle) {
       ea->PostRestyleForAnimation(mPresContext);
     }
   }
 }
 void
 nsAnimationManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
 {
+  TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+
   PRCList *next = PR_LIST_HEAD(&mElementData);
   while (next != &mElementData) {
     ElementAnimations *ea = static_cast<ElementAnimations*>(next);
     next = PR_NEXT_LINK(next);
 
+    nsRefPtr<css::AnimValuesStyleRule> oldStyleRule = ea->mStyleRule;
+    ea->EnsureStyleRuleFor(now, mPendingEvents, false);
+#if 0
+    // FIXME: It would be nice to check this; it would allow us to skip
+    // a good bit of duplication of work.  Unfortunately it's the norm
+    // that we have already updated the style rule, but not yet
+    // restyled.
+    if (oldStyleRule == ea->mStyleRule) {
+      // No style to update.
+      continue;
+    }
+#endif
+
     dom::Element* elementToRestyle = ea->ElementToRestyle();
     if (elementToRestyle) {
       aTracker.AddPendingRestyle(elementToRestyle, eRestyle_CSSAnimations,
                                  nsChangeHint(0));
     }
   }
+
+  // FIXME: Do something with mPendingEvents?
+
+  CheckNeedsRefresh();
 }
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -166,18 +166,16 @@ public:
       if (aContent->GetProperty(nsGkAtoms::animationsProperty)) {
         return true;
       }
     } while ((aContent = aContent->GetParent()));
 
     return false;
   }
 
-  void EnsureStyleRuleFor(ElementAnimations* aET);
-
   // nsIStyleRuleProcessor (parts)
   virtual void RulesMatching(ElementRuleProcessorData* aData) MOZ_OVERRIDE;
   virtual void RulesMatching(PseudoElementRuleProcessorData* aData) MOZ_OVERRIDE;
   virtual void RulesMatching(AnonBoxRuleProcessorData* aData) MOZ_OVERRIDE;
 #ifdef MOZ_XUL
   virtual void RulesMatching(XULTreeRuleProcessorData* aData) MOZ_OVERRIDE;
 #endif
   virtual size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf)
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1353,32 +1353,30 @@ nsStyleSet::RuleNodeWithReplacement(Elem
           // FileRules does.
           nsAnimationManager* animationManager =
             PresContext()->AnimationManager();
           ElementAnimations* ea = animationManager->GetElementAnimations(
             aElement, aPseudoType, false);
           NS_ASSERTION(ea,
             "Rule has level eAnimationSheet without animation on manager");
 
-          animationManager->EnsureStyleRuleFor(ea);
           ruleWalker.ForwardOnPossiblyCSSRule(ea->mStyleRule);
         }
         break;
       case eRestyle_CSSTransitions:
         {
           // FIXME: This should probably be more similar to what
           // FileRules does.
           nsPresContext* presContext = PresContext();
           ElementTransitions *et =
             presContext->TransitionManager()->GetElementTransitions(
               aElement, aPseudoType, false);
           NS_ASSERTION(et,
             "Rule has level eTransitionSheet without transition on manager");
 
-          et->EnsureStyleRuleFor(presContext->RefreshDriver()->MostRecentRefresh());
           ruleWalker.ForwardOnPossiblyCSSRule(et->mStyleRule);
         }
         break;
       default:
         break;
       }
     }
 
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -245,21 +245,39 @@ ElementTransitions::CanPerformOnComposit
 
 /*****************************************************************************
  * nsTransitionManager                                                       *
  *****************************************************************************/
 
 void
 nsTransitionManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
 {
+  // FIXME: Do we need to do something with events like FlushTransitions
+  // does?
+
+  TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+
   PRCList *next = PR_LIST_HEAD(&mElementData);
   while (next != &mElementData) {
     ElementTransitions *et = static_cast<ElementTransitions*>(next);
     next = PR_NEXT_LINK(next);
 
+    nsRefPtr<css::AnimValuesStyleRule> oldStyleRule = et->mStyleRule;
+    et->EnsureStyleRuleFor(now);
+#if 0
+    // FIXME: It would be nice to check this; it would allow us to skip
+    // a good bit of duplication of work.  Unfortunately it's the norm
+    // that we have already updated the style rule, but not yet
+    // restyled.
+    if (oldStyleRule == et->mStyleRule) {
+      // No style to update.
+      continue;
+    }
+#endif
+
     dom::Element* elementToRestyle = et->ElementToRestyle();
     if (elementToRestyle) {
       aTracker.AddPendingRestyle(elementToRestyle, eRestyle_CSSTransitions,
                                  nsChangeHint(0));
     }
   }
 }
 
@@ -511,16 +529,17 @@ nsTransitionManager::StyleContextChanged
     AnimationProperty& prop = pt.mProperties[0];
     AnimationPropertySegment& segment = prop.mSegments[0];
     if (whichStarted.HasProperty(prop.mProperty)) {
       coverRule->AddValue(prop.mProperty, segment.mFromValue);
     }
   }
 
   et->mStyleRule = nullptr;
+  et->EnsureStyleRuleFor(mPresContext->RefreshDriver()->MostRecentRefresh());
 
   return coverRule.forget();
 }
 
 void
 nsTransitionManager::ConsiderStartingTransition(nsCSSProperty aProperty,
                                                 const nsTransition& aTransition,
                                                 dom::Element* aElement,
@@ -989,16 +1008,17 @@ nsTransitionManager::FlushTransitions(Fl
           et->UpdateAnimationGeneration(mPresContext);
           transitionStartedOrEnded = true;
         }
       } while (i != 0);
 
       // We need to restyle even if the transition rule no longer
       // applies (in which case we just made it not apply).
       if (!canThrottleTick || transitionStartedOrEnded) {
+        et->EnsureStyleRuleFor(now);
         et->PostRestyleForAnimation(mPresContext);
       } else {
         didThrottle = true;
       }
 
       if (et->mPropertyTransitions.IsEmpty()) {
         et->Destroy();
         // |et| is now a dangling pointer!
