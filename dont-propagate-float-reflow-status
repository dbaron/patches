From: L. David Baron <dbaron@dbaron.org>

Don't propagate the float's reflow status through places that expect an inline's reflow status, to avoid the assertion for which bug 563584 was filed.  (Bug 563584)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -3880,36 +3880,24 @@ nsBlockFrame::ReflowInlineFrame(nsBlockR
 
         if (NS_INLINE_IS_BREAK_AFTER(frameReflowStatus) &&
             !aLineLayout.GetLineEndsInBR()) {
           aLineLayout.SetDirtyNextLine();
         }
       }
     }
   }
-  else if (NS_FRAME_IS_TRUNCATED(frameReflowStatus) &&
-           nsGkAtoms::placeholderFrame == aFrame->GetType()) {
-    // if the frame is a placeholder and was complete but truncated (and not at the top
-    // of page), the entire line will be pushed to give it another chance to not truncate.
-    *aLineReflowStatus = LINE_REFLOW_TRUNCATED;
-  }
 
   if (!NS_FRAME_IS_FULLY_COMPLETE(frameReflowStatus)) {
     // Create a continuation for the incomplete frame. Note that the
     // frame may already have a continuation.
     nsIAtom* frameType = aFrame->GetType();
 
     PRBool madeContinuation;
-    if (nsGkAtoms::placeholderFrame == frameType) {
-      nsPlaceholderFrame* placeholder = static_cast<nsPlaceholderFrame*>(aFrame);
-      rv = SplitFloat(aState, placeholder->GetOutOfFlowFrame(), frameReflowStatus);
-    }
-    else {
-      rv = CreateContinuationFor(aState, aLine, aFrame, madeContinuation);
-    }
+    rv = CreateContinuationFor(aState, aLine, aFrame, madeContinuation);
     NS_ENSURE_SUCCESS(rv, rv);
 
     // Remember that the line has wrapped
     if (!aLineLayout.GetLineEndsInBR()) {
       aLine->SetLineWrapped(PR_TRUE);
     }
     
     // If we just ended a first-letter frame or reflowed a placeholder then 
@@ -3967,20 +3955,18 @@ nsBlockFrame::SplitFloat(nsBlockReflowSt
   if (!aFloat->GetNextInFlow()) {
     nsresult rv = aState.mPresContext->PresShell()->FrameConstructor()->
       CreateContinuingFrame(aState.mPresContext, aFloat, this, &nextInFlow);
     NS_ENSURE_SUCCESS(rv, rv);
   }
   if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aFloatStatus))
     aFloat->GetNextInFlow()->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
 
-  // Float continuations can only trigger overflow
-  NS_FRAME_SET_OVERFLOW_INCOMPLETE(aFloatStatus);
-  // Make sure the containing block knows about the float's status
-  NS_MergeReflowStatusInto(&aState.mReflowStatus, aFloatStatus);
+  // The containing block is now overflow-incomplete.
+  NS_FRAME_SET_OVERFLOW_INCOMPLETE(aState.mReflowStatus);
 
   if (nextInFlow) {
     // Next in flow was created above.
     aState.AppendFloatContinuation(nextInFlow);
   }
   return NS_OK;
 }
 
@@ -5780,22 +5766,16 @@ nsBlockFrame::ReflowFloatContinuations(n
     if (NS_SUBTREE_DIRTY(f) || aState.mReflowState.ShouldReflowAllKids()) {
       // Cache old bounds
       nsRect oldRect = f->GetRect();
       nsRect oldOverflow = f->GetOverflowRect();
 
       // Reflow
       nsReflowStatus fStatus = NS_FRAME_COMPLETE;
       aState.AddFloat(nsnull, f, aState.mContentArea.width, fStatus);
-      if (!NS_FRAME_IS_FULLY_COMPLETE(fStatus)) {
-        rv = SplitFloat(aState, f, fStatus);
-        NS_ENSURE_SUCCESS(rv, rv);
-        NS_FRAME_SET_OVERFLOW_INCOMPLETE(fStatus);
-      }
-      NS_MergeReflowStatusInto(&aStatus, fStatus);
 
       // Invalidate if there was a position or size change
       nsRect rect = f->GetRect();
       if (rect != oldRect) {
         nsRect dirtyRect = oldOverflow;
         dirtyRect.MoveBy(oldRect.x, oldRect.y);
         Invalidate(dirtyRect);
 
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -545,16 +545,17 @@ nsBlockReflowState::AddFloat(nsLineLayou
 {
   NS_PRECONDITION(!aLineLayout || mBlock->end_lines() != mCurrentLine, "null ptr");
   NS_PRECONDITION(aFloat->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
                   "aFloat must be an out-of-flow frame");
 
   // Set the geometric parent of the float
   aFloat->SetParent(mBlock);
 
+  // FIXME: Remove aReflowStatus parameter!
   aReflowStatus = NS_FRAME_COMPLETE;
 
   // Because we are in the middle of reflowing a placeholder frame
   // within a line (and possibly nested in an inline frame or two
   // that's a child of our block) we need to restore the space
   // manager's translation to the space that the block resides in
   // before placing the float.
   nscoord ox, oy;
@@ -573,41 +574,28 @@ nsBlockReflowState::AddFloat(nsLineLayou
   nsRect floatAvailableSpace = GetFloatAvailableSpace().mRect;
   if (!aLineLayout ||
       (mBelowCurrentLineFloats.IsEmpty() &&
        (aLineLayout->LineIsEmpty() ||
         mBlock->ComputeFloatWidth(*this, floatAvailableSpace, aFloat)
         <= aAvailableWidth))) {
     // And then place it
     placed = FlowAndPlaceFloat(aFloat, aReflowStatus);
-    if (placed && !NS_FRAME_IS_TRUNCATED(aReflowStatus)) {
+    if (placed) {
       // Pass on updated available space to the current inline reflow engine
       nsFlowAreaRect floatAvailSpace = GetFloatAvailableSpace(mY);
       nsRect availSpace(nsPoint(floatAvailSpace.mRect.x + BorderPadding().left,
                                 mY),
                         floatAvailSpace.mRect.Size());
       if (aLineLayout) {
         aLineLayout->UpdateBand(availSpace, aFloat);
         // Record this float in the current-line list
         mCurrentLineFloats.Append(mFloatCacheFreeList.Alloc(aFloat));
       }
     }
-    else {
-      if (IsAdjacentWithTop()) {
-        // Pushing the line to the next page won't give us any more space;
-        // therefore, we break.
-        NS_ASSERTION(aLineLayout->LineIsBreakable(),
-                     "We can't get here unless forceFit is false");
-        aReflowStatus = NS_INLINE_LINE_BREAK_BEFORE();
-      } else {
-        // Make sure we propagate the truncated status; this signals the
-        // block to push the line to the next page.
-        aReflowStatus |= NS_FRAME_TRUNCATED;
-      }
-    }
   }
   else {
     // Always claim to be placed; we don't know whether we fit yet, so we
     // deal with this in PlaceBelowCurrentLineFloats
     placed = PR_TRUE;
     // This float will be placed after the line is done (it is a
     // below-current-line float).
     mBelowCurrentLineFloats.Append(mFloatCacheFreeList.Alloc(aFloat));
@@ -648,16 +636,17 @@ FloatMarginWidth(const nsHTMLReflowState
            aFloatOffsetState.mComputedPadding.TopBottom()),
     PR_TRUE).width +
   aFloatOffsetState.mComputedMargin.LeftRight() +
   aFloatOffsetState.mComputedBorderPadding.LeftRight();
 }
 
 PRBool
 nsBlockReflowState::FlowAndPlaceFloat(nsIFrame*       aFloat,
+                                      // FIXME: remove aReflowStatus
                                       nsReflowStatus& aReflowStatus)
 {
   aReflowStatus = NS_FRAME_COMPLETE;
   // Save away the Y coordinate before placing the float. We will
   // restore mY at the end after placing the float. This is
   // necessary because any adjustments to mY during the float
   // placement are for the float only, not for any non-floating
   // content.
@@ -705,16 +694,17 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
 	       "invalid float type");
 
   // Can the float fit here?
   PRBool keepFloatOnSameLine = PR_FALSE;
 
   while (!CanPlaceFloat(floatMarginWidth, floatAvailableSpace)) {
     if (floatAvailableSpace.mRect.height <= 0) {
       // No space, nowhere to put anything.
+      PushFloatPastBreak(aFloat);
       return PR_FALSE;
     }
 
     // Nope. try to advance to the next band.
     if (NS_STYLE_DISPLAY_TABLE != floatDisplay->mDisplay ||
           eCompatibility_NavQuirks != mPresContext->CompatibilityMode() ) {
 
       mY += floatAvailableSpace.mRect.height;
@@ -804,30 +794,38 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
     // means the margin edge of the float can't be higher than the
     // content edge of the block that contains it.)
     floatY = 0;
   }
 
   // Reflow the float after computing its vertical position so it knows
   // where to break.
   nsMargin floatMargin; // computed margin
+  nsReflowStatus reflowStatus;
   mBlock->ReflowFloat(*this, adjustedAvailableSpace, aFloat,
-                      floatMargin, mY != saveY, aReflowStatus);
+                      floatMargin, mY != saveY, reflowStatus);
   if (aFloat->GetPrevInFlow())
     floatMargin.top = 0;
-  if (NS_FRAME_IS_NOT_COMPLETE(aReflowStatus))
+  if (NS_FRAME_IS_NOT_COMPLETE(reflowStatus))
     floatMargin.bottom = 0;
 
   // In the case that we're in columns and not splitting floats, we need
   // to check here that the float's height fit, and if it didn't, bail.
   // (This code is only for DISABLE_FLOAT_BREAKING_IN_COLUMNS .)
-  if (mContentArea.height != NS_UNCONSTRAINEDSIZE &&
-      adjustedAvailableSpace.height == NS_UNCONSTRAINEDSIZE &&
-      aFloat->GetSize().height + floatMargin.TopBottom() >
-        mContentArea.height - floatY) {
+  //
+  // Likewise, if none of the float fit, and it needs to be pushed in
+  // its entirety to the next page (NS_FRAME_IS_TRUNCATED), we need to
+  // do the same.
+  if ((mContentArea.height != NS_UNCONSTRAINEDSIZE &&
+       adjustedAvailableSpace.height == NS_UNCONSTRAINEDSIZE &&
+       aFloat->GetSize().height + floatMargin.TopBottom() >
+         mContentArea.height - floatY) ||
+      NS_FRAME_IS_TRUNCATED(reflowStatus)) {
+
+    PushFloatPastBreak(aFloat);
     return PR_FALSE;
   }
 
   // Calculate the actual origin of the float frame's border rect
   // relative to the parent block; floatX/Y must be converted from space-manager
   // coordinates to parent coordinates, and the margin must be added in
   // to get the border rect
   nsPoint origin(borderPadding.left + floatMargin.left + floatX,
@@ -848,17 +846,17 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
 
   // XXX Floats should really just get invalidated here if necessary
   mFloatCombinedArea.UnionRect(combinedArea, mFloatCombinedArea);
 
   // Place the float in the float manager
   // calculate region
   nsRect region = nsFloatManager::CalculateRegionFor(aFloat, floatMargin);
   // if the float split, then take up all of the vertical height
-  if (NS_FRAME_IS_NOT_COMPLETE(aReflowStatus) &&
+  if (NS_FRAME_IS_NOT_COMPLETE(reflowStatus) &&
       (NS_UNCONSTRAINEDSIZE != mContentArea.height)) {
     region.height = NS_MAX(region.height, mContentArea.height - floatY);
   }
   nsresult rv =
   // spacemanager translation is inset by the border+padding.
   mFloatManager->AddFloat(aFloat,
                           region - nsPoint(borderPadding.left, borderPadding.top));
   NS_ABORT_IF_FALSE(NS_SUCCEEDED(rv), "bad float placement");
@@ -873,16 +871,20 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
     // less damage; e.g., if only height has changed, then only note the
     // area into which the float has grown or from which the float has
     // shrunk.
     nscoord top = NS_MIN(region.y, oldRegion.y) - borderPadding.top;
     nscoord bottom = NS_MAX(region.YMost(), oldRegion.YMost()) - borderPadding.top;
     mFloatManager->IncludeInDamage(top, bottom);
   }
 
+  if (NS_FRAME_IS_NOT_COMPLETE(reflowStatus)) {
+    mBlock->SplitFloat(*this, aFloat, reflowStatus);
+  }
+
 #ifdef NOISY_FLOATMANAGER
   nscoord tx, ty;
   mFloatManager->GetTranslation(tx, ty);
   nsFrame::ListTag(stdout, mBlock);
   printf(": FlowAndPlaceFloat: AddFloat: txy=%d,%d (%d,%d) {%d,%d,%d,%d}\n",
          tx, ty, mFloatManagerX, mFloatManagerY,
          region.x, region.y, region.width, region.height);
 #endif
@@ -895,16 +897,33 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
     nsFrame::ListTag(stdout, aFloat);
     printf(" %d,%d,%d,%d\n", r.x, r.y, r.width, r.height);
   }
 #endif
 
   return PR_TRUE;
 }
 
+void
+nsBlockReflowState::PushFloatPastBreak(nsIFrame *aFloat)
+{
+  // This ensures that we:
+  //  * don't try to place later but smaller floats (which CSS says
+  //    must have their tops below the top of this float)
+  //  * don't waste much time trying to reflow this float again until
+  //    after the break
+  mFloatManager->PushedFloatPastBreak();
+
+  // Put the float on the float continuations list, even though it
+  // isn't actually a continuation.
+  AppendFloatContinuation(aFloat);
+
+  NS_FRAME_SET_OVERFLOW_INCOMPLETE(mReflowStatus);
+}
+
 /**
  * Place below-current-line floats.
  */
 PRBool
 nsBlockReflowState::PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aList)
 {
   nsFloatCache* fc = aList.Head();
   while (fc) {
@@ -916,32 +935,21 @@ nsBlockReflowState::PlaceBelowCurrentLin
         nsFrame::ListTag(stdout, fc->mFloat);
         printf("\n");
       }
 #endif
       // Place the float
       nsReflowStatus reflowStatus;
       PRBool placed = FlowAndPlaceFloat(fc->mFloat, reflowStatus);
 
-      if (!placed || NS_FRAME_IS_TRUNCATED(reflowStatus)) {
+      if (!placed) {
         // return before processing all of the floats, since the line will be pushed.
+        // FIXME: This seems like it should be handled elsewhere...
         return PR_FALSE;
       }
-      else if (!NS_FRAME_IS_FULLY_COMPLETE(reflowStatus)) {
-        // Create a continuation for the incomplete float
-        nsresult rv = mBlock->SplitFloat(*this, fc->mFloat, reflowStatus);
-        if (NS_FAILED(rv))
-          return PR_FALSE;
-      } else {
-        // XXX We could deal with truncated frames better by breaking before
-        // the associated placeholder
-        NS_WARN_IF_FALSE(!NS_FRAME_IS_TRUNCATED(reflowStatus),
-                         "This situation currently leads to data not printing");
-        // Float is complete.
-      }
     }
     fc = fc->Next();
   }
   return PR_TRUE;
 }
 
 nscoord
 nsBlockReflowState::ClearFloats(nscoord aY, PRUint8 aBreakType,
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -103,20 +103,23 @@ public:
    * space.
    * aLineLayout is null when we are reflowing float continuations (because
    * they are not associated with a line box).
    */
   PRBool AddFloat(nsLineLayout*       aLineLayout,
                   nsIFrame*           aFloat,
                   nscoord             aAvailableWidth,
                   nsReflowStatus&     aReflowStatus);
+private:
   PRBool CanPlaceFloat(nscoord aFloatWidth,
                        const nsFlowAreaRect& aFloatAvailableSpace);
   PRBool FlowAndPlaceFloat(nsIFrame*       aFloat,
                            nsReflowStatus& aReflowStatus);
+  void PushFloatPastBreak(nsIFrame* aFloat);
+public:
   PRBool PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aFloats);
 
   // Returns the first coordinate >= aY that clears the
   // floats indicated by aBreakType and has enough width between floats
   // (or no floats remaining) to accomodate aReplacedBlock.
   nscoord ClearFloats(nscoord aY, PRUint8 aBreakType,
                       nsIFrame *aReplacedBlock = nsnull);
 
