From: L. David Baron <dbaron@dbaron.org>

Don't propagate the float's reflow status through places that expect an inline's reflow status, to avoid the assertion for which bug 563584 was filed.  This separates pushing of floats from pushing of lines, and allows first-in-flow floats to be pushed to the next page without their associated line.  (Bug 563584)  (FIXME:  needs tests for this and series of patches under it)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1024,17 +1024,17 @@ nsBlockFrame::Reflow(nsPresContext*     
   // we need to continue, too.
   if (NS_UNCONSTRAINEDSIZE != aReflowState.availableHeight &&
       NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
       state.mFloatManager->ClearContinues(FindTrailingClear())) {
     NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
   }
 
   if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
-    if (GetOverflowLines()) {
+    if (GetOverflowLines() || GetFloatContinuations()) {
       state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
     }
 
 #ifdef DEBUG_kipp
     ListTag(stdout); printf(": block is not fully complete\n");
 #endif
   }
 
@@ -3537,20 +3537,19 @@ nsBlockFrame::DoReflowInlineFrames(nsBlo
         // uses DoRemoveFrame?
         nsLineBox *toremove = aLine;
         aLine = mLines.erase(aLine);
         NS_ASSERTION(nsnull == toremove->mFirstChild, "bad empty line");
         aState.FreeLineBox(toremove);
       }
       --aLine;
 
-      if (LINE_REFLOW_TRUNCATED == lineReflowStatus) {
-        // Push the line with the truncated float
-        PushTruncatedPlaceholderLine(aState, aLine, *aKeepReflowGoing);
-      }
+      NS_ASSERTION(lineReflowStatus != LINE_REFLOW_TRUNCATED,
+                   "ReflowInlineFrame should never determine that a line "
+                   "needs to go to the next page/column");
     }
   }
 
   // Don't pull up new frames into lines with continuation placeholders
   if (aAllowPullUp) {
     // Pull frames and reflow them until we can't
     while (LINE_REFLOW_OK == lineReflowStatus) {
       frame = PullFrame(aState, aLine);
@@ -3635,19 +3634,19 @@ nsBlockFrame::DoReflowInlineFrames(nsBlo
         aState.mY += 1;
         // We should never hit this case if we've placed floats on the
         // line; if we have, then the GetFloatAvailableSpace call is wrong
         // and needs to happen after the caller pops the space manager
         // state.
         aState.mFloatManager->AssertStateMatches(aFloatStateBeforeLine);
         aFloatAvailableSpace = aState.GetFloatAvailableSpace();
       } else {
-        // There's nowhere to retry placing the line. Just treat it as if
-        // we placed the float but it was truncated so we need this line
-        // to go to the next page/column.
+        // There's nowhere to retry placing the line, so we want to push
+        // it to the next page/column where its contents can fit not
+        // next to a float.
         lineReflowStatus = LINE_REFLOW_TRUNCATED;
         // Push the line that didn't fit
         PushTruncatedPlaceholderLine(aState, aLine, *aKeepReflowGoing);
       }
     }
 
     // XXX: a small optimization can be done here when paginating:
     // if the new Y coordinate is past the end of the block then
@@ -3821,36 +3820,24 @@ nsBlockFrame::ReflowInlineFrame(nsBlockR
 
         if (NS_INLINE_IS_BREAK_AFTER(frameReflowStatus) &&
             !aLineLayout.GetLineEndsInBR()) {
           aLineLayout.SetDirtyNextLine();
         }
       }
     }
   }
-  else if (NS_FRAME_IS_TRUNCATED(frameReflowStatus) &&
-           nsGkAtoms::placeholderFrame == aFrame->GetType()) {
-    // if the frame is a placeholder and was complete but truncated (and not at the top
-    // of page), the entire line will be pushed to give it another chance to not truncate.
-    *aLineReflowStatus = LINE_REFLOW_TRUNCATED;
-  }
 
   if (!NS_FRAME_IS_FULLY_COMPLETE(frameReflowStatus)) {
     // Create a continuation for the incomplete frame. Note that the
     // frame may already have a continuation.
     nsIAtom* frameType = aFrame->GetType();
 
     PRBool madeContinuation;
-    if (nsGkAtoms::placeholderFrame == frameType) {
-      nsPlaceholderFrame* placeholder = static_cast<nsPlaceholderFrame*>(aFrame);
-      rv = SplitFloat(aState, placeholder->GetOutOfFlowFrame(), frameReflowStatus);
-    }
-    else {
-      rv = CreateContinuationFor(aState, aLine, aFrame, madeContinuation);
-    }
+    rv = CreateContinuationFor(aState, aLine, aFrame, madeContinuation);
     NS_ENSURE_SUCCESS(rv, rv);
 
     // Remember that the line has wrapped
     if (!aLineLayout.GetLineEndsInBR()) {
       aLine->SetLineWrapped(PR_TRUE);
     }
     
     // If we just ended a first-letter frame or reflowed a placeholder then 
@@ -3916,20 +3903,18 @@ nsBlockFrame::SplitFloat(nsBlockReflowSt
   } else {
     nsresult rv = aState.mPresContext->PresShell()->FrameConstructor()->
       CreateContinuingFrame(aState.mPresContext, aFloat, this, &nextInFlow);
     NS_ENSURE_SUCCESS(rv, rv);
   }
   if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aFloatStatus))
     aFloat->GetNextInFlow()->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
 
-  // Float continuations can only trigger overflow
-  NS_FRAME_SET_OVERFLOW_INCOMPLETE(aFloatStatus);
-  // Make sure the containing block knows about the float's status
-  NS_MergeReflowStatusInto(&aState.mReflowStatus, aFloatStatus);
+  // The containing block is now overflow-incomplete.
+  NS_FRAME_SET_OVERFLOW_INCOMPLETE(aState.mReflowStatus);
 
   if (aFloat->GetStyleDisplay()->mFloats == NS_STYLE_FLOAT_LEFT) {
     aState.mFloatManager->SetSplitLeftFloatAcrossBreak();
   } else {
     NS_ABORT_IF_FALSE(aFloat->GetStyleDisplay()->mFloats ==
                         NS_STYLE_FLOAT_RIGHT, "unexpected float side");
     aState.mFloatManager->SetSplitRightFloatAcrossBreak();
   }
@@ -5751,22 +5736,16 @@ nsBlockFrame::ReflowFloatContinuations(n
     if (NS_SUBTREE_DIRTY(f) || aState.mReflowState.ShouldReflowAllKids()) {
       // Cache old bounds
       nsRect oldRect = f->GetRect();
       nsRect oldOverflow = f->GetOverflowRect();
 
       // Reflow
       nsReflowStatus fStatus = NS_FRAME_COMPLETE;
       aState.FlowAndPlaceFloat(f, fStatus);
-      if (!NS_FRAME_IS_FULLY_COMPLETE(fStatus)) {
-        rv = SplitFloat(aState, f, fStatus);
-        NS_ENSURE_SUCCESS(rv, rv);
-        NS_FRAME_SET_OVERFLOW_INCOMPLETE(fStatus);
-      }
-      NS_MergeReflowStatusInto(&aStatus, fStatus);
 
       // Invalidate if there was a position or size change
       nsRect rect = f->GetRect();
       if (rect != oldRect) {
         nsRect dirtyRect = oldOverflow;
         dirtyRect.MoveBy(oldRect.x, oldRect.y);
         Invalidate(dirtyRect);
 
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -92,17 +92,19 @@ class nsIntervalSet;
  * flow frames whose placeholders are in the overflow list.
  * -- A given piece of content has at most one placeholder
  * frame in a block's normal child list.
  * -- While a block is being reflowed, and from then until
  * its next-in-flow is reflowed it may have a
  * FloatContinuationProperty frame property that points to
  * an nsFrameList. This list contains continuations for
  * floats whose prev-in-flow is in the block's regular float
- * list.
+ * list and first-in-flows of floats that did not fit, but
+ * whose placeholders are in the block or one of its
+ * prev-in-flows.
  * -- In all these frame lists, if there are two frames for
  * the same content appearing in the list, then the frames
  * appear with the prev-in-flow before the next-in-flow.
  * -- While reflowing a block, its overflow line list
  * will usually be empty but in some cases will have lines
  * (while we reflow the block at its shrink-wrap width).
  * In this case any new overflowing content must be
  * prepended to the overflow lines.
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -566,16 +566,17 @@ nsBlockReflowState::AddFloat(nsLineLayou
 
     aFloat->RemoveStateBits(NS_FRAME_IS_FLOAT_CONTINUATION);
 
     // Appending is fine, since if a float was pushed to the next
     // page/column, all later floats were also pushed.
     mBlock->mFloats.AppendFrame(mBlock, aFloat);
   }
 
+  // FIXME: Remove aReflowStatus parameter!
   aReflowStatus = NS_FRAME_COMPLETE;
 
   // Because we are in the middle of reflowing a placeholder frame
   // within a line (and possibly nested in an inline frame or two
   // that's a child of our block) we need to restore the space
   // manager's translation to the space that the block resides in
   // before placing the float.
   nscoord ox, oy;
@@ -591,49 +592,28 @@ nsBlockReflowState::AddFloat(nsLineLayou
   // If one or more floats has already been pushed to the next line,
   // don't let this one go on the current line, since that would violate
   // float ordering.
   nsRect floatAvailableSpace = GetFloatAvailableSpace().mRect;
   if (mBelowCurrentLineFloats.IsEmpty() &&
       (aLineLayout->LineIsEmpty() ||
        mBlock->ComputeFloatWidth(*this, floatAvailableSpace, aFloat)
        <= aAvailableWidth)) {
-    nsFloatManager::SavedState floatManagerState;
-    mFloatManager->PushState(&floatManagerState);
-
     // And then place it
     placed = FlowAndPlaceFloat(aFloat, aReflowStatus);
-    if (placed && !NS_FRAME_IS_TRUNCATED(aReflowStatus)) {
+    if (placed) {
       // Pass on updated available space to the current inline reflow engine
       nsFlowAreaRect floatAvailSpace = GetFloatAvailableSpace(mY);
       nsRect availSpace(nsPoint(floatAvailSpace.mRect.x + BorderPadding().left,
                                 mY),
                         floatAvailSpace.mRect.Size());
       aLineLayout->UpdateBand(availSpace, aFloat);
       // Record this float in the current-line list
       mCurrentLineFloats.Append(mFloatCacheFreeList.Alloc(aFloat));
     }
-    else {
-      if (placed) {
-        mFloatManager->PopState(&floatManagerState);
-      } else {
-        mFloatManager->AssertStateMatches(&floatManagerState);
-      }
-      if (IsAdjacentWithTop()) {
-        // Pushing the line to the next page won't give us any more space;
-        // therefore, we break.
-        NS_ASSERTION(aLineLayout->LineIsBreakable(),
-                     "We can't get here unless forceFit is false");
-        aReflowStatus = NS_INLINE_LINE_BREAK_BEFORE();
-      } else {
-        // Make sure we propagate the truncated status; this signals the
-        // block to push the line to the next page.
-        aReflowStatus |= NS_FRAME_TRUNCATED;
-      }
-    }
   }
   else {
     // Always claim to be placed; we don't know whether we fit yet, so we
     // deal with this in PlaceBelowCurrentLineFloats
     placed = PR_TRUE;
     // This float will be placed after the line is done (it is a
     // below-current-line float).
     mBelowCurrentLineFloats.Append(mFloatCacheFreeList.Alloc(aFloat));
@@ -678,16 +658,17 @@ FloatMarginWidth(const nsHTMLReflowState
            aFloatOffsetState.mComputedPadding.TopBottom()),
     PR_TRUE).width +
   aFloatOffsetState.mComputedMargin.LeftRight() +
   aFloatOffsetState.mComputedBorderPadding.LeftRight();
 }
 
 PRBool
 nsBlockReflowState::FlowAndPlaceFloat(nsIFrame*       aFloat,
+                                      // FIXME: remove aReflowStatus
                                       nsReflowStatus& aReflowStatus)
 {
   aReflowStatus = NS_FRAME_COMPLETE;
   // Save away the Y coordinate before placing the float. We will
   // restore mY at the end after placing the float. This is
   // necessary because any adjustments to mY during the float
   // placement are for the float only, not for any non-floating
   // content.
@@ -735,16 +716,17 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
 	       "invalid float type");
 
   // Can the float fit here?
   PRBool keepFloatOnSameLine = PR_FALSE;
 
   for (;;) {
     if (floatAvailableSpace.mRect.height <= 0) {
       // No space, nowhere to put anything.
+      PushFloatPastBreak(aFloat);
       return PR_FALSE;
     }
 
     if (CanPlaceFloat(floatMarginWidth, floatAvailableSpace)) {
       // We found an appropriate place.
       break;
     }
 
@@ -840,32 +822,40 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
     // content edge of the block that contains it.)
     floatY = 0;
   }
 
   // Reflow the float after computing its vertical position so it knows
   // where to break.
   nsMargin floatMargin; // computed margin
   PRBool pushedDown = mY != saveY;
+  nsReflowStatus reflowStatus;
   mBlock->ReflowFloat(*this, adjustedAvailableSpace, aFloat,
-                      floatMargin, pushedDown, aReflowStatus);
+                      floatMargin, pushedDown, reflowStatus);
   if (aFloat->GetPrevInFlow())
     floatMargin.top = 0;
-  if (NS_FRAME_IS_NOT_COMPLETE(aReflowStatus))
+  if (NS_FRAME_IS_NOT_COMPLETE(reflowStatus))
     floatMargin.bottom = 0;
 
   // In the case that we're in columns and not splitting floats, we need
   // to check here that the float's height fit, and if it didn't, bail.
   // (This code is only for DISABLE_FLOAT_BREAKING_IN_COLUMNS .)
-  if (mContentArea.height != NS_UNCONSTRAINEDSIZE &&
-      adjustedAvailableSpace.height == NS_UNCONSTRAINEDSIZE &&
-      (!mReflowState.mFlags.mIsTopOfPage || !IsAdjacentWithTop() ||
-       pushedDown) &&
-      aFloat->GetSize().height + floatMargin.TopBottom() >
-        mContentArea.height - floatY) {
+  //
+  // Likewise, if none of the float fit, and it needs to be pushed in
+  // its entirety to the next page (NS_FRAME_IS_TRUNCATED), we need to
+  // do the same.
+  if ((mContentArea.height != NS_UNCONSTRAINEDSIZE &&
+       adjustedAvailableSpace.height == NS_UNCONSTRAINEDSIZE &&
+       (!mReflowState.mFlags.mIsTopOfPage || !IsAdjacentWithTop() ||
+        pushedDown) &&
+       aFloat->GetSize().height + floatMargin.TopBottom() >
+         mContentArea.height - floatY) ||
+      NS_FRAME_IS_TRUNCATED(reflowStatus)) {
+
+    PushFloatPastBreak(aFloat);
     return PR_FALSE;
   }
 
   // Calculate the actual origin of the float frame's border rect
   // relative to the parent block; floatX/Y must be converted from space-manager
   // coordinates to parent coordinates, and the margin must be added in
   // to get the border rect
   nsPoint origin(borderPadding.left + floatMargin.left + floatX,
@@ -886,17 +876,17 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
 
   // XXX Floats should really just get invalidated here if necessary
   mFloatCombinedArea.UnionRect(combinedArea, mFloatCombinedArea);
 
   // Place the float in the float manager
   // calculate region
   nsRect region = nsFloatManager::CalculateRegionFor(aFloat, floatMargin);
   // if the float split, then take up all of the vertical height
-  if (NS_FRAME_IS_NOT_COMPLETE(aReflowStatus) &&
+  if (NS_FRAME_IS_NOT_COMPLETE(reflowStatus) &&
       (NS_UNCONSTRAINEDSIZE != mContentArea.height)) {
     region.height = NS_MAX(region.height, mContentArea.height - floatY);
   }
   nsresult rv =
   // spacemanager translation is inset by the border+padding.
   mFloatManager->AddFloat(aFloat,
                           region - nsPoint(borderPadding.left, borderPadding.top));
   NS_ABORT_IF_FALSE(NS_SUCCEEDED(rv), "bad float placement");
@@ -911,16 +901,20 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
     // less damage; e.g., if only height has changed, then only note the
     // area into which the float has grown or from which the float has
     // shrunk.
     nscoord top = NS_MIN(region.y, oldRegion.y) - borderPadding.top;
     nscoord bottom = NS_MAX(region.YMost(), oldRegion.YMost()) - borderPadding.top;
     mFloatManager->IncludeInDamage(top, bottom);
   }
 
+  if (NS_FRAME_IS_NOT_COMPLETE(reflowStatus)) {
+    mBlock->SplitFloat(*this, aFloat, reflowStatus);
+  }
+
 #ifdef NOISY_FLOATMANAGER
   nscoord tx, ty;
   mFloatManager->GetTranslation(tx, ty);
   nsFrame::ListTag(stdout, mBlock);
   printf(": FlowAndPlaceFloat: AddFloat: txy=%d,%d (%d,%d) {%d,%d,%d,%d}\n",
          tx, ty, mFloatManagerX, mFloatManagerY,
          region.x, region.y, region.width, region.height);
 #endif
@@ -933,16 +927,42 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
     nsFrame::ListTag(stdout, aFloat);
     printf(" %d,%d,%d,%d\n", r.x, r.y, r.width, r.height);
   }
 #endif
 
   return PR_TRUE;
 }
 
+void
+nsBlockReflowState::PushFloatPastBreak(nsIFrame *aFloat)
+{
+  // This ensures that we:
+  //  * don't try to place later but smaller floats (which CSS says
+  //    must have their tops below the top of this float)
+  //  * don't waste much time trying to reflow this float again until
+  //    after the break
+  if (aFloat->GetStyleDisplay()->mFloats == NS_STYLE_FLOAT_LEFT) {
+    mFloatManager->SetPushedLeftFloatPastBreak();
+  } else {
+    NS_ABORT_IF_FALSE(aFloat->GetStyleDisplay()->mFloats ==
+                        NS_STYLE_FLOAT_RIGHT,
+                      "unexpected float value");
+    mFloatManager->SetPushedRightFloatPastBreak();
+  }
+
+  // Put the float on the float continuations list, even though it
+  // isn't actually a continuation.
+  nsresult rv = mBlock->StealFrame(mPresContext, aFloat);
+  NS_ASSERTION(NS_SUCCEEDED(rv), "StealFrame should succeed");
+  AppendFloatContinuation(aFloat);
+
+  NS_FRAME_SET_OVERFLOW_INCOMPLETE(mReflowStatus);
+}
+
 /**
  * Place below-current-line floats.
  */
 PRBool
 nsBlockReflowState::PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aList)
 {
   nsFloatCache* fc = aList.Head();
   while (fc) {
@@ -954,32 +974,21 @@ nsBlockReflowState::PlaceBelowCurrentLin
         nsFrame::ListTag(stdout, fc->mFloat);
         printf("\n");
       }
 #endif
       // Place the float
       nsReflowStatus reflowStatus;
       PRBool placed = FlowAndPlaceFloat(fc->mFloat, reflowStatus);
 
-      if (!placed || NS_FRAME_IS_TRUNCATED(reflowStatus)) {
+      if (!placed) {
         // return before processing all of the floats, since the line will be pushed.
+        // FIXME: This seems like it should be handled elsewhere...
         return PR_FALSE;
       }
-      else if (!NS_FRAME_IS_FULLY_COMPLETE(reflowStatus)) {
-        // Create a continuation for the incomplete float
-        nsresult rv = mBlock->SplitFloat(*this, fc->mFloat, reflowStatus);
-        if (NS_FAILED(rv))
-          return PR_FALSE;
-      } else {
-        // XXX We could deal with truncated frames better by breaking before
-        // the associated placeholder
-        NS_WARN_IF_FALSE(!NS_FRAME_IS_TRUNCATED(reflowStatus),
-                         "This situation currently leads to data not printing");
-        // Float is complete.
-      }
     }
     fc = fc->Next();
   }
   return PR_TRUE;
 }
 
 nscoord
 nsBlockReflowState::ClearFloats(nscoord aY, PRUint8 aBreakType,
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -103,20 +103,25 @@ public:
    * space.
    * aLineLayout is null when we are reflowing float continuations (because
    * they are not associated with a line box).
    */
   PRBool AddFloat(nsLineLayout*       aLineLayout,
                   nsIFrame*           aFloat,
                   nscoord             aAvailableWidth,
                   nsReflowStatus&     aReflowStatus);
+private:
   PRBool CanPlaceFloat(nscoord aFloatWidth,
                        const nsFlowAreaRect& aFloatAvailableSpace);
+public:
   PRBool FlowAndPlaceFloat(nsIFrame*       aFloat,
                            nsReflowStatus& aReflowStatus);
+private:
+  void PushFloatPastBreak(nsIFrame* aFloat);
+public:
   PRBool PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aFloats);
 
   // Returns the first coordinate >= aY that clears the
   // floats indicated by aBreakType and has enough width between floats
   // (or no floats remaining) to accomodate aReplacedBlock.
   nscoord ClearFloats(nscoord aY, PRUint8 aBreakType,
                       nsIFrame *aReplacedBlock = nsnull,
                       PRUint32 aFlags = 0);
diff --git a/layout/generic/nsInlineFrame.cpp b/layout/generic/nsInlineFrame.cpp
--- a/layout/generic/nsInlineFrame.cpp
+++ b/layout/generic/nsInlineFrame.cpp
@@ -749,27 +749,16 @@ nsInlineFrame::ReflowInlineFrame(nsPresC
         }
       }
     }
     return NS_OK;
   }
 
   // Create a next-in-flow if needed.
   if (!NS_FRAME_IS_FULLY_COMPLETE(aStatus)) {
-    if (nsGkAtoms::placeholderFrame == aFrame->GetType()) {
-      nsBlockReflowState* blockRS = lineLayout->mBlockRS;
-      nsPlaceholderFrame* placeholder =
-        static_cast<nsPlaceholderFrame*>(aFrame);
-      rv = blockRS->mBlock->SplitFloat(*blockRS,
-                                       placeholder->GetOutOfFlowFrame(),
-                                       aStatus);
-      // Allow the parent to continue reflowing.
-      aStatus = NS_FRAME_COMPLETE;
-      return rv;
-    }
     nsIFrame* newFrame;
     rv = CreateNextInFlow(aPresContext, aFrame, newFrame);
     if (NS_FAILED(rv)) {
       return rv;
     }
   }
 
   if (NS_INLINE_IS_BREAK_AFTER(aStatus)) {
