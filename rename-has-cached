From: L. David Baron <dbaron@dbaron.org>

Bug 1209603 patch 6b - Rename nsStyleContext::HasCachedInheritedStyleData to HasCachedDependentStyleData.  r=heycam

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -4046,17 +4046,17 @@ ElementRestyler::RestyleSelf(nsIFrame* a
       // (b) when we were unable to swap the structs on the parent because
       //     either or both of the old parent and new parent are shared.
       //
       // FIXME This loop could be rewritten as bit operations on
       //       oldContext->mBits and samePointerStructs.
       for (nsStyleStructID sid = nsStyleStructID(0);
            sid < nsStyleStructID_Length;
            sid = nsStyleStructID(sid + 1)) {
-        if (oldContext->HasCachedInheritedStyleData(sid) &&
+        if (oldContext->HasCachedDependentStyleData(sid) &&
             !(samePointerStructs & nsCachedStyleData::GetBitForSID(sid))) {
           LOG_RESTYLE_CONTINUE("there are different struct pointers");
           result = eRestyleResult_Continue;
           break;
         }
       }
     }
 
diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -1481,17 +1481,17 @@ nsStyleContext::GetCachedStyleDataAsStri
        i < nsStyleStructID_Length;
        i = nsStyleStructID(i + 1)) {
     if (aStructs & nsCachedStyleData::GetBitForSID(i)) {
       const void* data = GetCachedStyleData(i);
       if (!structs.IsEmpty()) {
         structs.Append(' ');
       }
       structs.AppendPrintf("%s=%p", StructName(i), data);
-      if (HasCachedInheritedStyleData(i)) {
+      if (HasCachedDependentStyleData(i)) {
         structs.AppendLiteral("(dependent)");
       } else {
         structs.AppendLiteral("(owned)");
       }
     }
   }
   return structs;
 }
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -282,17 +282,17 @@ public:
   #undef STYLE_STRUCT_INHERITED
 
   /**
    * Returns whether this style context has cached style data for a
    * given style struct and it does NOT own that struct.  This can
    * happen because it was inherited from the parent style context, or
    * because it was stored conditionally on the rule node.
    */
-  bool HasCachedInheritedStyleData(nsStyleStructID aSID) {
+  bool HasCachedDependentStyleData(nsStyleStructID aSID) {
     return (mBits & nsCachedStyleData::GetBitForSID(aSID)) &&
            GetCachedStyleData(aSID);
   }
 
   nsRuleNode* RuleNode() { return mRuleNode; }
   void AddStyleBit(const uint64_t& aBit) { mBits |= aBit; }
 
   /*
