From: L. David Baron <dbaron@dbaron.org>

Use the same width basis for font inflation throughout a font inflation flow root.  (Bug 747720, patch 3)

NEEDS TESTS

Font inflation flow roots are similar to block formatting contexts,
though I'm trying to make not all block formatting contexts be flow
roots in later patches on this bug, bug 707195, and related bugs.

This will lead to more consistent font size inflation in a flow of text
where the blocks vary in width (e.g., because some of the blocks have
horizontal margins) but we determine the text to comprise a single flow.

diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -4764,119 +4764,73 @@ nsLayoutUtils::FontSizeInflationInner(co
 
   // To scale 0-1.5 times min to instead be 1-1.5 times min, we want
   // to the desired multiple of min to be 1 + (ratio/3) (where ratio
   // is our input's multiple of min).  The scaling needed to produce
   // that is that divided by |ratio|, or:
   return (1.0f / ratio) + (1.0f / 3.0f);
 }
 
-static inline bool
-InflationDataSaysEnabled(const nsIFrame *aFrame)
-{
-  nsFontInflationData *data =
-    nsFontInflationData::FindFontInflationDataFor(aFrame);
-  return data && data->InflationEnabled();
-}
-
 static bool
 ShouldInflateFontsForContainer(const nsIFrame *aFrame)
 {
   // We only want to inflate fonts for text that is in a place
   // with room to expand.  The question is what the best heuristic for
   // that is...
   // For now, we're going to use NS_FRAME_IN_CONSTRAINED_HEIGHT, which
   // indicates whether the frame is inside something with a constrained
   // height (propagating down the tree), but the propagation stops when
   // we hit overflow-y: scroll or auto.
   const nsStyleText* styleText = aFrame->GetStyleText();
 
   return styleText->mTextSizeAdjust != NS_STYLE_TEXT_SIZE_ADJUST_NONE &&
          !(aFrame->GetStateBits() & NS_FRAME_IN_CONSTRAINED_HEIGHT) &&
          // We also want to disable font inflation for containers that have
          // preformatted text.
-         styleText->WhiteSpaceCanWrap() &&
-         InflationDataSaysEnabled(aFrame);
+         styleText->WhiteSpaceCanWrap();
 }
 
 nscoord
 nsLayoutUtils::InflationMinFontSizeFor(const nsIFrame *aFrame,
                                        WidthDetermination aWidthDetermination)
 {
-#ifdef DEBUG
-  if (aWidthDetermination == eNotInReflow) {
-    // Check that neither this frame nor any of its ancestors are
-    // currently being reflowed.
-    // It's ok for box frames (but not arbitrary ancestors of box frames)
-    // since they set their size before reflow.
-    if (!(aFrame->IsBoxFrame() && IsContainerForFontSizeInflation(aFrame))) {
-      for (const nsIFrame *f = aFrame; f; f = f->GetParent()) {
-        NS_ABORT_IF_FALSE(!(f->GetStateBits() & NS_FRAME_IN_REFLOW),
-                          "must call nsHTMLReflowState& version during reflow");
-      }
-    }
-    // It's ok if frames are dirty, or even if they've never been
-    // reflowed, since they will be eventually and then we'll get the
-    // right size.
-  }
-#endif
-
   nsPresContext *presContext = aFrame->PresContext();
   if (!FontSizeInflationEnabled(presContext) ||
       presContext->mInflationDisabledForShrinkWrap) {
     return 0;
   }
 
-  if (aWidthDetermination == eInReflow) {
-    nsIFrame *container = presContext->mCurrentInflationContainer;
-    if (!container || !ShouldInflateFontsForContainer(container)) {
-      return 0;
-    }
-    return MinimumFontSizeFor(presContext,
-                              presContext->mCurrentInflationContainerWidth);
-  }
-
   for (const nsIFrame *f = aFrame; f; f = f->GetParent()) {
     if (IsContainerForFontSizeInflation(f)) {
       if (!ShouldInflateFontsForContainer(f)) {
         return 0;
       }
 
+      nsFontInflationData *data =
+        nsFontInflationData::FindFontInflationDataFor(aFrame);
+      // FIXME: The need to null-check here is sort of a bug, and might
+      // lead to incorrect results.
+      if (!data || !data->InflationEnabled()) {
+        return 0;
+      }
+
       return MinimumFontSizeFor(aFrame->PresContext(),
-                                f->GetContentRect().width);
+                                data->EffectiveWidth());
     }
   }
 
   NS_ABORT_IF_FALSE(false, "root should always be container");
 
   return 0;
 }
 
 float
 nsLayoutUtils::FontSizeInflationFor(const nsIFrame *aFrame,
                                     WidthDetermination aWidthDetermination)
 {
-#ifdef DEBUG
-  if (aWidthDetermination == eNotInReflow) {
-    // Check that neither this frame nor any of its ancestors are
-    // currently being reflowed.
-    // It's ok for box frames (but not arbitrary ancestors of box frames)
-    // since they set their size before reflow.
-    if (!(aFrame->IsBoxFrame() && IsContainerForFontSizeInflation(aFrame))) {
-      for (const nsIFrame *f = aFrame; f; f = f->GetParent()) {
-        NS_ABORT_IF_FALSE(!(f->GetStateBits() & NS_FRAME_IN_REFLOW),
-                          "must call nsHTMLReflowState& version during reflow");
-      }
-    }
-    // It's ok if frames are dirty, or even if they've never been
-    // reflowed, since they will be eventually and then we'll get the
-    // right size.
-  }
-#endif
-
   if (!FontSizeInflationEnabled(aFrame->PresContext())) {
     return 1.0;
   }
 
   return FontSizeInflationInner(aFrame,
                                 InflationMinFontSizeFor(aFrame,
                                                         aWidthDetermination));
 }
