From: L. David Baron <dbaron@dbaron.org>

Bug 91419 patch 3:  Rename everything with IBSplitSpecialSibling to IBSplitSibling.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1845,20 +1845,20 @@ GetNextContinuationWithSameStyle(nsIFram
   // See GetPrevContinuationWithSameStyle about {ib} splits.
 
   nsIFrame *nextContinuation = aFrame->GetNextContinuation();
   if (!nextContinuation &&
       (aFrame->GetStateBits() & NS_FRAME_BLOCK_IN_INLINE_SPLIT)) {
     // We're the last continuation, so we have to hop back to the first
     // before getting the frame property
     nextContinuation = static_cast<nsIFrame*>(aFrame->FirstContinuation()->
-      Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+      Properties().Get(nsIFrame::IBSplitSibling()));
     if (nextContinuation) {
       nextContinuation = static_cast<nsIFrame*>(
-        nextContinuation->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+        nextContinuation->Properties().Get(nsIFrame::IBSplitSibling()));
     }
   }
 
   if (!nextContinuation) {
     return nullptr;
   }
 
   NS_ASSERTION(nextContinuation->GetContent() == aFrame->GetContent(),
@@ -2016,17 +2016,17 @@ RestyleManager::ReparentStyleContext(nsI
       // the next part of the split might be a child of our style context.
       // Reparent its style context just in case one of our ancestors
       // (split or not) hasn't done so already). It's not a problem to
       // reparent the same frame twice because the "if (newContext !=
       // oldContext)" check will prevent us from redoing work.
       if ((aFrame->GetStateBits() & NS_FRAME_BLOCK_IN_INLINE_SPLIT) &&
           !aFrame->GetPrevContinuation()) {
         nsIFrame* sib = static_cast<nsIFrame*>
-          (aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+          (aFrame->Properties().Get(nsIFrame::IBSplitSibling()));
         if (sib) {
           ReparentStyleContext(sib);
         }
       }
 
       // do additional contexts
       int32_t contextIndex = 0;
       for (nsStyleContext* oldExtraContext;
@@ -2842,17 +2842,17 @@ GetNextBlockInInlineSibling(FramePropert
                "must start with the first continuation");
   // Might we have special siblings?
   if (!(aFrame->GetStateBits() & NS_FRAME_BLOCK_IN_INLINE_SPLIT)) {
     // nothing more to do here
     return nullptr;
   }
 
   return static_cast<nsIFrame*>
-    (aPropTable->Get(aFrame, nsIFrame::IBSplitSpecialSibling()));
+    (aPropTable->Get(aFrame, nsIFrame::IBSplitSibling()));
 }
 
 void
 RestyleManager::ComputeStyleChangeFor(nsIFrame*          aFrame,
                                       nsStyleChangeList* aChangeList,
                                       nsChangeHint       aMinChange,
                                       RestyleTracker&    aRestyleTracker,
                                       bool               aRestyleDescendants)
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -420,17 +420,17 @@ static nsIFrame* GetSpecialSibling(nsIFr
 {
   NS_PRECONDITION(IsFramePartOfBlockInInlineSplit(aFrame),
                   "Shouldn't call this");
 
   // We only store the "special sibling" annotation with the first
   // frame in the continuation chain. Walk back to find that frame now.
   return static_cast<nsIFrame*>
     (aFrame->FirstContinuation()->
-       Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+       Properties().Get(nsIFrame::IBSplitSibling()));
 }
 
 static nsIFrame* GetSpecialPrevSibling(nsIFrame* aFrame)
 {
   NS_PRECONDITION(IsFramePartOfBlockInInlineSplit(aFrame),
                   "Shouldn't call this");
 
   // We only store the "special sibling" annotation with the first
@@ -475,17 +475,17 @@ SetFrameIsSpecial(nsIFrame* aFrame, nsIF
   if (aSpecialSibling) {
     NS_ASSERTION(!aSpecialSibling->GetPrevContinuation(),
                  "assigning something other than the first continuation as the "
                  "special sibling");
 
     // Store the "special sibling" (if we were given one) with the
     // first frame in the flow.
     FramePropertyTable* props = aFrame->PresContext()->PropertyTable();
-    props->Set(aFrame, nsIFrame::IBSplitSpecialSibling(), aSpecialSibling);
+    props->Set(aFrame, nsIFrame::IBSplitSibling(), aSpecialSibling);
     props->Set(aSpecialSibling, nsIFrame::IBSplitSpecialPrevSibling(), aFrame);
   }
 }
 
 static nsIFrame*
 GetIBContainingBlockFor(nsIFrame* aFrame)
 {
   NS_PRECONDITION(IsFramePartOfBlockInInlineSplit(aFrame),
@@ -10401,17 +10401,17 @@ nsCSSFrameConstructor::ConstructInline(n
   // runs of inlines, and put all these frames, in order, into aFrameItems.  We
   // return the the first one.  The whole setup is called an {ib}
   // split; in what follows "frames in the split" refers to the anonymous blocks
   // and inlines that contain our children.
   //
   // {ib} splits maintain the following invariants:
   // 1) All frames in the split have the NS_FRAME_BLOCK_IN_INLINE_SPLIT bit
   //    set.
-  // 2) Each frame in the split has the nsIFrame::IBSplitSpecialSibling
+  // 2) Each frame in the split has the nsIFrame::IBSplitSibling
   //    property pointing to the next frame in the split, except for the last
   //    one, which does not have it set.
   // 3) Each frame in the split has the nsIFrame::IBSplitSpecialPrevSibling
   //    property pointing to the previous frame in the split, except for the
   //    first one, which does not have it set.
   // 4) The first and last frame in the split are always inlines.
   //
   // An invariant that is NOT maintained is that the wrappers are actually
diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -219,20 +219,20 @@ protected:
   nsIFrame* GetNextContinuation(nsIFrame* aFrame)
   {
     nsIFrame* nextCont = aFrame->GetNextContinuation();
     if (!nextCont &&
         (aFrame->GetStateBits() & NS_FRAME_BLOCK_IN_INLINE_SPLIT)) {
       // The {ib} properties are only stored on first continuations
       aFrame = aFrame->FirstContinuation();
       nsIFrame* block = static_cast<nsIFrame*>
-        (aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+        (aFrame->Properties().Get(nsIFrame::IBSplitSibling()));
       if (block) {
         nextCont = static_cast<nsIFrame*>
-          (block->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+          (block->Properties().Get(nsIFrame::IBSplitSibling()));
         NS_ASSERTION(nextCont, "How did that happen?");
       }
     }
     return nextCont;
   }
 
   void Init(nsIFrame* aFrame)
   {
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -2751,17 +2751,17 @@ nsLayoutUtils::GetNextContinuationOrSpec
   if (result)
     return result;
 
   if ((aFrame->GetStateBits() & NS_FRAME_BLOCK_IN_INLINE_SPLIT) != 0) {
     // We only store the "special sibling" annotation with the first
     // frame in the continuation chain. Walk back to find that frame now.
     aFrame = aFrame->FirstContinuation();
 
-    void* value = aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling());
+    void* value = aFrame->Properties().Get(nsIFrame::IBSplitSibling());
     return static_cast<nsIFrame*>(value);
   }
 
   return nullptr;
 }
 
 nsIFrame*
 nsLayoutUtils::FirstContinuationOrSpecialSibling(nsIFrame *aFrame)
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -623,24 +623,24 @@ nsFrame::DestroyFrom(nsIFrame* aDestruct
   // (Note: This has to happen before we call shell->NotifyDestroyingFrame,
   // because that clears our Properties() table.)
   if (mState & NS_FRAME_BLOCK_IN_INLINE_SPLIT) {
     // Delete previous sibling's reference to me.
     nsIFrame* prevSib = static_cast<nsIFrame*>
       (Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
     if (prevSib) {
       NS_WARN_IF_FALSE(this ==
-         prevSib->Properties().Get(nsIFrame::IBSplitSpecialSibling()),
+         prevSib->Properties().Get(nsIFrame::IBSplitSibling()),
          "IB sibling chain is inconsistent");
-      prevSib->Properties().Delete(nsIFrame::IBSplitSpecialSibling());
+      prevSib->Properties().Delete(nsIFrame::IBSplitSibling());
     }
 
     // Delete next sibling's reference to me.
     nsIFrame* nextSib = static_cast<nsIFrame*>
-      (Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+      (Properties().Get(nsIFrame::IBSplitSibling()));
     if (nextSib) {
       NS_WARN_IF_FALSE(this ==
          nextSib->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()),
          "IB sibling chain is inconsistent");
       nextSib->Properties().Delete(nsIFrame::IBSplitSpecialPrevSibling());
     }
   }
 
@@ -5320,19 +5320,19 @@ nsIFrame::ListGeneric(nsACString& aTo, c
     aTo += nsPrintfCString(" prev-%s=%p", fluid?"in-flow":"continuation",
             static_cast<void*>(GetPrevContinuation()));
   }
   if (GetNextContinuation()) {
     bool fluid = GetNextInFlow() == GetNextContinuation();
     aTo += nsPrintfCString(" next-%s=%p", fluid?"in-flow":"continuation",
             static_cast<void*>(GetNextContinuation()));
   }
-  void* IBsibling = Properties().Get(IBSplitSpecialSibling());
+  void* IBsibling = Properties().Get(IBSplitSibling());
   if (IBsibling) {
-    aTo += nsPrintfCString(" IBSplitSpecialSibling=%p", IBsibling);
+    aTo += nsPrintfCString(" IBSplitSibling=%p", IBsibling);
   }
   void* IBprevsibling = Properties().Get(IBSplitSpecialPrevSibling());
   if (IBprevsibling) {
     aTo += nsPrintfCString(" IBSplitSpecialPrevSibling=%p", IBprevsibling);
   }
   aTo += nsPrintfCString(" {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
   nsIFrame* f = const_cast<nsIFrame*>(this);
   if (f->HasOverflowAreas()) {
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -997,17 +997,17 @@ public:
   }
 // Don't use this unless you really know what you're doing!
 #define NS_DECLARE_FRAME_PROPERTY_WITH_FRAME_IN_DTOR(prop, dtor)                               \
   static const FramePropertyDescriptor* prop() {                                               \
     static NS_PROPERTY_DESCRIPTOR_CONST FramePropertyDescriptor descriptor = { nullptr, dtor }; \
     return &descriptor;                                                                        \
   }
 
-  NS_DECLARE_FRAME_PROPERTY(IBSplitSpecialSibling, nullptr)
+  NS_DECLARE_FRAME_PROPERTY(IBSplitSibling, nullptr)
   NS_DECLARE_FRAME_PROPERTY(IBSplitSpecialPrevSibling, nullptr)
 
   NS_DECLARE_FRAME_PROPERTY(NormalPositionProperty, DestroyPoint)
   NS_DECLARE_FRAME_PROPERTY(ComputedOffsetProperty, DestroyMargin)
 
   NS_DECLARE_FRAME_PROPERTY(OutlineInnerRectProperty, DestroyRect)
   NS_DECLARE_FRAME_PROPERTY(PreEffectsBBoxProperty, DestroyRect)
   NS_DECLARE_FRAME_PROPERTY(PreTransformOverflowAreasProperty,
@@ -3036,17 +3036,17 @@ NS_PTR_TO_INT32(frame->Properties().Get(
   }
 
   /**
    * Return true if aFrame is in an {ib} split and is NOT one of the
    * continuations of the last inline in it.
    */
   bool FrameIsNonLastInIBSplit() const {
     return (GetStateBits() & NS_FRAME_BLOCK_IN_INLINE_SPLIT) &&
-      FirstContinuation()->Properties().Get(nsIFrame::IBSplitSpecialSibling());
+      FirstContinuation()->Properties().Get(nsIFrame::IBSplitSibling());
   }
 
   /**
    * Return whether this is a frame whose width is used when computing
    * the font size inflation of its descendants.
    */
   bool IsContainerForFontSizeInflation() const {
     return GetStateBits() & NS_FRAME_FONT_INFLATION_CONTAINER;
