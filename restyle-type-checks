From: L. David Baron <dbaron@dbaron.org>

Bug 996796 patch 7 - Adjust checks of restyle types to accomodate new types weaker than eRestyle_Self.

Later patches will add such types that are like eRestyle_Self but that
only replace the style attribute, animation rule, or transition rule.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -2300,21 +2300,17 @@ ElementRestyler::Restyle(nsRestyleHint a
     if (mRestyleTracker.GetRestyleData(mContent->AsElement(), &restyleData)) {
       if (NS_UpdateHint(mHintsHandled, restyleData.mChangeHint)) {
         mChangeList->AppendChange(mFrame, mContent, restyleData.mChangeHint);
       }
       aRestyleHint = nsRestyleHint(aRestyleHint | restyleData.mRestyleHint);
     }
   }
 
-  nsRestyleHint childRestyleHint = aRestyleHint;
-
-  if (childRestyleHint == eRestyle_Self) {
-    childRestyleHint = nsRestyleHint(0);
-  }
+  nsRestyleHint childRestyleHint = nsRestyleHint(aRestyleHint & eRestyle_Subtree);
 
   {
     nsRefPtr<nsStyleContext> oldContext = mFrame->StyleContext();
 
     // TEMPORARY (until bug 918064):  Call RestyleSelf for each
     // continuation or block-in-inline sibling.
 
     for (nsIFrame* f = mFrame; f;
diff --git a/layout/base/RestyleTracker.cpp b/layout/base/RestyleTracker.cpp
--- a/layout/base/RestyleTracker.cpp
+++ b/layout/base/RestyleTracker.cpp
@@ -112,17 +112,17 @@ RestyleTracker::ProcessOneRestyle(Elemen
 {
   NS_PRECONDITION((aRestyleHint & eRestyle_LaterSiblings) == 0,
                   "Someone should have handled this before calling us");
   NS_PRECONDITION(Document(), "Must have a document");
   NS_PRECONDITION(aElement->GetCurrentDoc() == Document(),
                   "Element has unexpected document");
 
   nsIFrame* primaryFrame = aElement->GetPrimaryFrame();
-  if (aRestyleHint & (eRestyle_Self | eRestyle_Subtree)) {
+  if (aRestyleHint & ~eRestyle_LaterSiblings) {
     mRestyleManager->RestyleElement(aElement, primaryFrame, aChangeHint,
                                     *this, aRestyleHint);
   } else if (aChangeHint &&
              (primaryFrame ||
               (aChangeHint & nsChangeHint_ReconstructFrame))) {
     // Don't need to recompute style; just apply the hint
     nsStyleChangeList changeList;
     changeList.AppendChange(primaryFrame, aElement, aChangeHint);
diff --git a/layout/base/RestyleTracker.h b/layout/base/RestyleTracker.h
--- a/layout/base/RestyleTracker.h
+++ b/layout/base/RestyleTracker.h
@@ -375,17 +375,17 @@ inline bool RestyleTracker::AddPendingRe
     nsRestyleHint(existingData.mRestyleHint | aRestyleHint);
   NS_UpdateHint(existingData.mChangeHint, aMinChangeHint);
 
   mPendingRestyles.Put(aElement, existingData);
 
   // We can only treat this element as a restyle root if we would
   // actually restyle its descendants (so either call
   // ReResolveStyleContext on it or just reframe it).
-  if ((aRestyleHint & (eRestyle_Self | eRestyle_Subtree)) ||
+  if ((aRestyleHint & ~eRestyle_LaterSiblings) ||
       (aMinChangeHint & nsChangeHint_ReconstructFrame)) {
     for (const Element* cur = aElement; !cur->HasFlag(RootBit()); ) {
       nsIContent* parent = cur->GetFlattenedTreeParent();
       // Stop if we have no parent or the parent is not an element or
       // we're part of the viewport scrollbars (because those are not
       // frametree descendants of the primary frame of the root
       // element).
       // XXXbz maybe the primary frame of the root should be the root scrollframe?
