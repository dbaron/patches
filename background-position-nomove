Snap background origin and clip areas to device pixels to prevent tiling from varying for subpixel position changes that don't change the box's visible position at all.  b=433640

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -3463,6 +3463,38 @@ FindTileEnd(nscoord aDirtyEnd, nscoord a
          IntDivCeil(aDirtyEnd - aTileOffset, aTileSize) * aTileSize;
 }
 
+static void
+PixelSnapRectangle(gfxContext* aContext, nsIDeviceContext *aDC, nsRect& aRect)
+{
+  gfxRect tmpRect;
+  tmpRect.pos.x = aDC->AppUnitsToGfxUnits(aRect.x);
+  tmpRect.pos.y = aDC->AppUnitsToGfxUnits(aRect.y);
+  tmpRect.size.width = aDC->AppUnitsToGfxUnits(aRect.width);
+  tmpRect.size.height = aDC->AppUnitsToGfxUnits(aRect.height);
+  if (aContext->UserToDevicePixelSnapped(tmpRect)) {
+    tmpRect = aContext->DeviceToUser(tmpRect);
+    aRect.x = aDC->GfxUnitsToAppUnits(tmpRect.pos.x);
+    aRect.y = aDC->GfxUnitsToAppUnits(tmpRect.pos.y);
+    aRect.width = aDC->GfxUnitsToAppUnits(tmpRect.size.width);
+    aRect.height = aDC->GfxUnitsToAppUnits(tmpRect.size.height);
+  }
+}
+
+static void
+PixelSnapPoint(gfxContext* aContext, nsIDeviceContext *aDC, nsPoint& aPoint)
+{
+  gfxRect tmpRect;
+  tmpRect.pos.x = aDC->AppUnitsToGfxUnits(aPoint.x);
+  tmpRect.pos.y = aDC->AppUnitsToGfxUnits(aPoint.y);
+  tmpRect.size.width = 0;
+  tmpRect.size.height = 0;
+  if (aContext->UserToDevicePixelSnapped(tmpRect)) {
+    tmpRect = aContext->DeviceToUser(tmpRect);
+    aPoint.x = aDC->GfxUnitsToAppUnits(tmpRect.pos.x);
+    aPoint.y = aDC->GfxUnitsToAppUnits(tmpRect.pos.y);
+  }
+}
+
 void
 nsCSSRendering::PaintBackgroundWithSC(nsPresContext* aPresContext,
                                       nsIRenderingContext& aRenderingContext,
@@ -3520,6 +3552,14 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     }
   }
 
+  nsIDeviceContext *dc = aPresContext->DeviceContext();
+  nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
+
+  // Snap bgClipArea to device pixel boundaries.  (We have to snap
+  // bgOriginArea below; if we don't do this as well then we could make
+  // incorrect decisions about various optimizations.)
+  PixelSnapRectangle(ctx, dc, bgClipArea);
+
   // The actual dirty rect is the intersection of the 'background-clip'
   // area and the dirty rect we were given
   nsRect dirtyRect;
@@ -3604,6 +3644,10 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     }
   }
 
+  // Snap bgOriginArea to device pixel boundaries to avoid variations in
+  // tiling when the subpixel position of the element changes.
+  PixelSnapRectangle(ctx, dc, bgOriginArea);
+
   // Based on the repeat setting, compute how many tiles we should
   // lay down for each axis. The value computed is the maximum based
   // on the dirty rect before accounting for the background-position.
@@ -3739,7 +3783,10 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     anchor.y += bgClipArea.y - aBorderArea.y;
   }
 
-  nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
+  // Pixel-snap the anchor point so that we don't end up with blurry
+  // images due to subpixel positions.
+  PixelSnapPoint(ctx, dc, anchor);
+
   ctx->Save();
 
   nscoord appUnitsPerPixel = aPresContext->DevPixelsToAppUnits(1);
@@ -3893,13 +3940,17 @@ nsCSSRendering::PaintBackgroundWithSC(ns
   */
 
   // relative to aBorderArea.TopLeft()
+  // ... but pixel-snapped, so that it comes out correctly relative to
+  // all the other pixel-snapped things
+  nsPoint borderAreaOrigin = aBorderArea.TopLeft();
+  PixelSnapPoint(ctx, dc, borderAreaOrigin);
   nsRect tileRect(anchor, nsSize(tileWidth, tileHeight));
   if (repeat & NS_STYLE_BG_REPEAT_X) {
     // When tiling in the x direction, adjust the starting position of the
     // tile to account for dirtyRect.x. When tiling in x, the anchor.x value
     // will be a negative value used to adjust the starting coordinate.
-    nscoord x0 = FindTileStart(dirtyRect.x - aBorderArea.x, anchor.x, tileWidth);
-    nscoord x1 = FindTileEnd(dirtyRect.XMost() - aBorderArea.x, anchor.x, tileWidth);
+    nscoord x0 = FindTileStart(dirtyRect.x - borderAreaOrigin.x, anchor.x, tileWidth);
+    nscoord x1 = FindTileEnd(dirtyRect.XMost() - borderAreaOrigin.x, anchor.x, tileWidth);
     tileRect.x = x0;
     tileRect.width = x1 - x0;
   }
@@ -3907,14 +3958,14 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     // When tiling in the y direction, adjust the starting position of the
     // tile to account for dirtyRect.y. When tiling in y, the anchor.y value
     // will be a negative value used to adjust the starting coordinate.
-    nscoord y0 = FindTileStart(dirtyRect.y - aBorderArea.y, anchor.y, tileHeight);
-    nscoord y1 = FindTileEnd(dirtyRect.YMost() - aBorderArea.y, anchor.y, tileHeight);
+    nscoord y0 = FindTileStart(dirtyRect.y - borderAreaOrigin.y, anchor.y, tileHeight);
+    nscoord y1 = FindTileEnd(dirtyRect.YMost() - borderAreaOrigin.y, anchor.y, tileHeight);
     tileRect.y = y0;
     tileRect.height = y1 - y0;
   }
 
   // Take the intersection again to paint only the required area.
-  nsRect absTileRect = tileRect + aBorderArea.TopLeft();
+  nsRect absTileRect = tileRect + borderAreaOrigin;
   
   nsRect drawRect;
   if (drawRect.IntersectRect(absTileRect, dirtyRect)) {
@@ -3933,7 +3984,7 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     // passed in relative to the image top-left.
     nsRect destRect; // The rectangle we would draw ignoring dirty-rect
     destRect.IntersectRect(absTileRect, bgClipArea);
-    nsRect subimageRect = destRect - aBorderArea.TopLeft() - tileRect.TopLeft();
+    nsRect subimageRect = destRect - borderAreaOrigin - tileRect.TopLeft();
     if (sourceRect.XMost() <= tileWidth && sourceRect.YMost() <= tileHeight) {
       // The entire drawRect is contained inside a single tile; just
       // draw the corresponding part of the image once.
diff --git a/layout/reftests/pixel-rounding/bl-corner.png b/layout/reftests/pixel-rounding/bl-corner.png
new file mode 100644
index 0000000000000000000000000000000000000000..bed9056cb61b959cf70e0318b1b47ec2744a5ffa
GIT binary patch
literal 115
zc%17D@N?(olHy`uVBq!ia0vp^3LwnE1SJ1Ryj={W7>k44ofy`glX(f`=z6+1hIkx*
zd)ASW!9d`U!HoLzwxWBkNq8vo&a9L)Hh_U2Y8pAs%zgh^ty3BO{eT)7JYD@<);T3K
F0RS=*9*6({

diff --git a/layout/reftests/pixel-rounding/br-corner.png b/layout/reftests/pixel-rounding/br-corner.png
new file mode 100644
index 0000000000000000000000000000000000000000..44accf944998e5e45412da645dcb522c57b283d5
GIT binary patch
literal 117
zc%17D@N?(olHy`uVBq!ia0vp^3LwnE1SJ1Ryj={W7>k44ofy`glX(f`=zF?2hIkx*
zd(DuM!9bwdA?W|S&ss*JJa@b@W`=%}P*;F~54;ne?q!xS`O9jp)YZfZ)XL!L>gTe~
HDWM4fj_)7{

diff --git a/layout/reftests/pixel-rounding/tl-corner.png b/layout/reftests/pixel-rounding/tl-corner.png
new file mode 100644
index 0000000000000000000000000000000000000000..65a71e1199e70909c1ad474e30eb889b8883ffe8
GIT binary patch
literal 115
zc%17D@N?(olHy`uVBq!ia0vp^3LwnE1SJ1Ryj={W7>k44ofy`glX(f`=z6+1hIkx*
zd)85qfq~=jhC>hU8?Cs}eas<i`U=Lbgi9@w5-_lbldrvx*+GS^Q4gq*!PC{xWt~$(
F69AlpAQu1t

diff --git a/layout/reftests/pixel-rounding/tr-corner.png b/layout/reftests/pixel-rounding/tr-corner.png
new file mode 100644
index 0000000000000000000000000000000000000000..df6590fa0429781f671fe4cb8e6cb85553fadf11
GIT binary patch
literal 114
zc%17D@N?(olHy`uVBq!ia0vp^3LwnE1SJ1Ryj={W7>k44ofy`glX(f`=y<v~hIkx*
zd)ASW!9d{92BZJ;EJgQRlkkXIcBn|BvPV(^25N+5@^x9QD+F%+0_tP%boFyt=akR{
E05oeJ-2eap

