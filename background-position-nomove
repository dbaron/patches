Snap background origin and clip areas to device pixels to prevent tiling from varying for subpixel position changes that don't change the box's visible position at all.  b=433640

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -3520,6 +3520,28 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     }
   }
 
+  nsCOMPtr<nsIDeviceContext> dc;
+  aRenderingContext->GetDeviceContext(*getter_AddRefs(dc));
+  nsRefPtr<gfxContext> ctx = aRenderingContext->ThebesContext();
+
+  // Snap bgClipArea to device pixel boundaries.  (We have to snap
+  // bgOriginArea below; if we don't do this as well then we could make
+  // incorrect decisions about various optimizations.)
+  {
+    gfxRect bgClipRect;
+    bgClipRect.pos.x = dc->AppUnitsToGfxUnits(bgClipArea.x);
+    bgClipRect.pos.y = dc->AppUnitsToGfxUnits(bgClipArea.y);
+    bgClipRect.size.width = dc->AppUnitsToGfxUnits(bgClipArea.width);
+    bgClipRect.size.height = dc->AppUnitsToGfxUnits(bgClipArea.height);
+    if (ctx->UserToDevicePixelSnapped(bgClipRect)) {
+      bgClipRect = ctx->DeviceToUser(bgClipRect);
+      bgClipArea.x = dc->GfxUnitsToAppUnits(bgClipRect.pos.x);
+      bgClipArea.y = dc->GfxUnitsToAppUnits(bgClipRect.pos.y);
+      bgClipArea.width = dc->GfxUnitsToAppUnits(bgClipRect.size.width);
+      bgClipArea.height = dc->GfxUnitsToAppUnits(bgClipRect.size.height);
+    }
+  }
+
   // The actual dirty rect is the intersection of the 'background-clip'
   // area and the dirty rect we were given
   nsRect dirtyRect;
@@ -3603,6 +3625,24 @@ nsCSSRendering::PaintBackgroundWithSC(ns
                    "unknown background-origin value");
     }
   }
+
+  // Snap bgOriginArea to device pixel boundaries to avoid variations in
+  // tiling when the subpixel position of the element changes.
+  {
+    gfxRect bgOriginRect;
+    bgOriginRect.pos.x = dc->AppUnitsToGfxUnits(bgOriginArea.x);
+    bgOriginRect.pos.y = dc->AppUnitsToGfxUnits(bgOriginArea.y);
+    bgOriginRect.size.width = dc->AppUnitsToGfxUnits(bgOriginArea.width);
+    bgOriginRect.size.height = dc->AppUnitsToGfxUnits(bgOriginArea.height);
+    if (ctx->UserToDevicePixelSnapped(bgOriginRect)) {
+      bgOriginRect = ctx->DeviceToUser(bgOriginRect);
+      bgOriginArea.x = dc->GfxUnitsToAppUnits(bgOriginRect.pos.x);
+      bgOriginArea.y = dc->GfxUnitsToAppUnits(bgOriginRect.pos.y);
+      bgOriginArea.width = dc->GfxUnitsToAppUnits(bgOriginRect.size.width);
+      bgOriginArea.height = dc->GfxUnitsToAppUnits(bgOriginRect.size.height);
+    }
+  }
+
 
   // Based on the repeat setting, compute how many tiles we should
   // lay down for each axis. The value computed is the maximum based
