Snap background origin and clip areas to device pixels to prevent tiling from varying for subpixel position changes that don't change the box's visible position at all.  b=433640

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -3463,6 +3463,38 @@ FindTileEnd(nscoord aDirtyEnd, nscoord a
          IntDivCeil(aDirtyEnd - aTileOffset, aTileSize) * aTileSize;
 }
 
+static void
+PixelSnapRectangle(gfxContext* aContext, nsIDeviceContext *aDC, nsRect& aRect)
+{
+  gfxRect tmpRect;
+  tmpRect.pos.x = aDC->AppUnitsToGfxUnits(aRect.x);
+  tmpRect.pos.y = aDC->AppUnitsToGfxUnits(aRect.y);
+  tmpRect.size.width = aDC->AppUnitsToGfxUnits(aRect.width);
+  tmpRect.size.height = aDC->AppUnitsToGfxUnits(aRect.height);
+  if (ctx->UserToDevicePixelSnapped(tmpRect)) {
+    tmpRect = ctx->DeviceToUser(tmpRect);
+    aRect.x = aDC->GfxUnitsToAppUnits(tmpRect.pos.x);
+    aRect.y = aDC->GfxUnitsToAppUnits(tmpRect.pos.y);
+    aRect.width = aDC->GfxUnitsToAppUnits(tmpRect.size.width);
+    aRect.height = aDC->GfxUnitsToAppUnits(tmpRect.size.height);
+  }
+}
+
+static void
+PixelSnapPoint(gfxContext* aContext, nsIDeviceContext *aDC, nsPoint& aPoint)
+{
+  gfxRect tmpRect;
+  tmpRect.pos.x = aDC->AppUnitsToGfxUnits(aPoint.x);
+  tmpRect.pos.y = aDC->AppUnitsToGfxUnits(aPoint.y);
+  tmpRect.size.width = 0;
+  tmpRect.size.height = 0;
+  if (ctx->UserToDevicePixelSnapped(tmpRect)) {
+    tmpRect = ctx->DeviceToUser(tmpRect);
+    aPoint.x = aDC->GfxUnitsToAppUnits(tmpRect.pos.x);
+    aPoint.y = aDC->GfxUnitsToAppUnits(tmpRect.pos.y);
+  }
+}
+
 void
 nsCSSRendering::PaintBackgroundWithSC(nsPresContext* aPresContext,
                                       nsIRenderingContext& aRenderingContext,
@@ -3520,6 +3552,15 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     }
   }
 
+  nsCOMPtr<nsIDeviceContext> dc;
+  aRenderingContext.GetDeviceContext(*getter_AddRefs(dc));
+  nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
+
+  // Snap bgClipArea to device pixel boundaries.  (We have to snap
+  // bgOriginArea below; if we don't do this as well then we could make
+  // incorrect decisions about various optimizations.)
+  PixelSnapRectangle(ctx, dc, bgClipArea);
+
   // The actual dirty rect is the intersection of the 'background-clip'
   // area and the dirty rect we were given
   nsRect dirtyRect;
@@ -3604,6 +3645,10 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     }
   }
 
+  // Snap bgOriginArea to device pixel boundaries to avoid variations in
+  // tiling when the subpixel position of the element changes.
+  PixelSnapRectangle(ctx, dc, bgOriginArea);
+
   // Based on the repeat setting, compute how many tiles we should
   // lay down for each axis. The value computed is the maximum based
   // on the dirty rect before accounting for the background-position.
@@ -3739,7 +3784,10 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     anchor.y += bgClipArea.y - aBorderArea.y;
   }
 
-  nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
+  // Pixel-snap the anchor point so that we don't end up with blurry
+  // images due to subpixel positions.
+  PixelSnapPoint(ctx, dc, anchor);
+
   ctx->Save();
 
   nscoord appUnitsPerPixel = aPresContext->DevPixelsToAppUnits(1);
@@ -3893,13 +3941,17 @@ nsCSSRendering::PaintBackgroundWithSC(ns
   */
 
   // relative to aBorderArea.TopLeft()
+  // ... but pixel-snapped, so that it comes out correctly relative to
+  // all the other pixel-snapped things
+  nsPoint borderAreaOrigin = aBorderArea.TopLeft();
+  PixelSnapPoint(ctx, dc, borderAreaOrigin);
   nsRect tileRect(anchor, nsSize(tileWidth, tileHeight));
   if (repeat & NS_STYLE_BG_REPEAT_X) {
     // When tiling in the x direction, adjust the starting position of the
     // tile to account for dirtyRect.x. When tiling in x, the anchor.x value
     // will be a negative value used to adjust the starting coordinate.
-    nscoord x0 = FindTileStart(dirtyRect.x - aBorderArea.x, anchor.x, tileWidth);
-    nscoord x1 = FindTileEnd(dirtyRect.XMost() - aBorderArea.x, anchor.x, tileWidth);
+    nscoord x0 = FindTileStart(dirtyRect.x - borderAreaOrigin.x, anchor.x, tileWidth);
+    nscoord x1 = FindTileEnd(dirtyRect.XMost() - borderAreaOrigin.x, anchor.x, tileWidth);
     tileRect.x = x0;
     tileRect.width = x1 - x0;
   }
@@ -3907,14 +3959,14 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     // When tiling in the y direction, adjust the starting position of the
     // tile to account for dirtyRect.y. When tiling in y, the anchor.y value
     // will be a negative value used to adjust the starting coordinate.
-    nscoord y0 = FindTileStart(dirtyRect.y - aBorderArea.y, anchor.y, tileHeight);
-    nscoord y1 = FindTileEnd(dirtyRect.YMost() - aBorderArea.y, anchor.y, tileHeight);
+    nscoord y0 = FindTileStart(dirtyRect.y - borderAreaOrigin.y, anchor.y, tileHeight);
+    nscoord y1 = FindTileEnd(dirtyRect.YMost() - borderAreaOrigin.y, anchor.y, tileHeight);
     tileRect.y = y0;
     tileRect.height = y1 - y0;
   }
 
   // Take the intersection again to paint only the required area.
-  nsRect absTileRect = tileRect + aBorderArea.TopLeft();
+  nsRect absTileRect = tileRect + borderAreaOrigin;
   
   nsRect drawRect;
   if (drawRect.IntersectRect(absTileRect, dirtyRect)) {
@@ -3933,7 +3985,7 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     // passed in relative to the image top-left.
     nsRect destRect; // The rectangle we would draw ignoring dirty-rect
     destRect.IntersectRect(absTileRect, bgClipArea);
-    nsRect subimageRect = destRect - aBorderArea.TopLeft() - tileRect.TopLeft();
+    nsRect subimageRect = destRect - borderAreaOrigin - tileRect.TopLeft();
     if (sourceRect.XMost() <= tileWidth && sourceRect.YMost() <= tileHeight) {
       // The entire drawRect is contained inside a single tile; just
       // draw the corresponding part of the image once.
