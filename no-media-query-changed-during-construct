Prevent posting media query changed events during construction.  (Bug 468645)

diff --git a/layout/base/nsIPresShell.h b/layout/base/nsIPresShell.h
--- a/layout/base/nsIPresShell.h
+++ b/layout/base/nsIPresShell.h
@@ -270,16 +270,17 @@ public:
   NS_IMETHOD EndObservingDocument() = 0;
 
   /**
    * Determine if InitialReflow() was previously called.
    * @param aDidInitialReflow PR_TRUE if InitalReflow() was previously called,
    * PR_FALSE otherwise.
    */
   NS_IMETHOD GetDidInitialReflow(PRBool *aDidInitialReflow) = 0;
+  PRBool DidInitialReflow() const { return mDidInitialReflow; }
 
   /**
    * Perform the initial reflow. Constructs the frame for the root content
    * object and then reflows the frame model into the specified width and
    * height.
    *
    * The coordinates for aWidth and aHeight must be in standard nscoords.
    *
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1171,18 +1171,22 @@ nsPresContext::SetFullZoom(float aZoom)
   }
 
   NS_ASSERTION(mSupressResizeReflow == PR_FALSE, "two zooms happening at the same time? impossible!");
   mSupressResizeReflow = PR_TRUE;
 
   mFullZoom = aZoom;
   GetViewManager()->SetWindowDimensions(NSToCoordRound(oldWidthDevPixels * AppUnitsPerDevPixel()),
                                         NSToCoordRound(oldHeightDevPixels * AppUnitsPerDevPixel()));
-  MediaFeatureValuesChanged(PR_TRUE);
-  RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
+  if (mShell && mShell->DidInitialReflow()) {
+    MediaFeatureValuesChanged(PR_TRUE);
+    RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
+  } else {
+    AssertNoStyleDataToRebuild();
+  }
 
   mSupressResizeReflow = PR_FALSE;
 
   mCurAppUnitsPerDevPixel = AppUnitsPerDevPixel();
 }
 
 void
 nsPresContext::SetImageLoaders(nsIFrame* aTargetFrame,
@@ -1862,16 +1866,24 @@ nsPresContext::UserFontSetUpdated()
   //   2. Changing the value of the 'ex' and 'ch' units in style data,
   //      which also depend on font metrics.  Updating this information
   //      requires rebuilding the rule tree from the top, avoiding the
   //      reuse of cached data even when no style rules have changed.
 
   PostRebuildAllStyleDataEvent(NS_STYLE_HINT_REFLOW);
 }
 
+#ifdef DEBUG
+void
+nsPresContext::AssertNoStyleDataToRebuild()
+{
+  StyleSet()->AssertNoStyleDataToRebuild();
+}
+#endif
+
 void
 nsPresContext::FireDOMPaintEvent()
 {
   nsCOMPtr<nsPIDOMWindow> ourWindow = mDocument->GetWindow();
   if (!ourWindow)
     return;
 
   nsISupports* eventTarget = ourWindow;
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -441,17 +441,20 @@ public:
   nsRect GetVisibleArea() { return mVisibleArea; }
 
   /**
    * Set the currently visible area. The units for r are standard
    * nscoord units (as scaled by the device context).
    */
   void SetVisibleArea(const nsRect& r) {
     mVisibleArea = r;
-    PostMediaFeatureValuesChangedEvent();
+    if (mShell && mShell->DidInitialReflow())
+      PostMediaFeatureValuesChangedEvent();
+    else
+      AssertNoStyleDataToRebuild();
   }
 
   /**
    * Return true if this presentation context is a paginated
    * context.
    */
   PRBool IsPaginated() const { return mPaginated; }
   
@@ -507,17 +510,20 @@ public:
 
   nsIDeviceContext* DeviceContext() { return mDeviceContext; }
   nsIEventStateManager* EventStateManager() { return mEventManager; }
   nsIAtom* GetLangGroup() { return mLangGroup; }
 
   float TextZoom() { return mTextZoom; }
   void SetTextZoom(float aZoom) {
     mTextZoom = aZoom;
-    RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
+    if (mShell && mShell->DidInitialReflow())
+      RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
+    else
+      AssertNoStyleDataToRebuild();
   }
 
   float GetFullZoom() { return mFullZoom; }
   void SetFullZoom(float aZoom);
 
   nscoord GetAutoQualityMinFontSize() {
     return DevPixelsToAppUnits(mAutoQualityMinFontSizePixelsPref);
   }
@@ -800,16 +806,22 @@ protected:
 
   NS_HIDDEN_(void) UpdateCharSet(const nsAFlatCString& aCharSet);
 
   void HandleRebuildUserFontSet() {
     mPostedFlushUserFontSet = PR_FALSE;
     FlushUserFontSet();
   }
 
+#ifdef DEBUG
+  void AssertNoStyleDataToRebuild();
+#else
+  void AssertNoStyleDataToRebuild() {}
+#endif
+
   // IMPORTANT: The ownership implicit in the following member variables
   // has been explicitly checked.  If you add any members to this class,
   // please make the ownership explicit (pinkerton, scc).
   
   nsPresContextType     mType;
   nsIPresShell*         mShell;         // [WEAK]
   nsCOMPtr<nsIDocument> mDocument;
   nsIDeviceContext*     mDeviceContext; // [STRONG] could be weak, but
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -746,11 +746,20 @@ public:
   // Expose this so media queries can use it
   static nscoord CalcLengthWithInitialFont(nsPresContext* aPresContext,
                                            const nsCSSValue& aValue);
   // Expose this so nsTransformFunctions can use it.
   static nscoord CalcLength(const nsCSSValue& aValue,
                             nsStyleContext* aStyleContext,
                             nsPresContext* aPresContext,
                             PRBool& aInherited);
+
+#ifdef DEBUG
+  void AssertTreeHasNoCachedData() {
+    NS_ASSERTION(IsRoot(), "should only be called on root of rule tree");
+    NS_ASSERTION(!HaveChildren(), "should not have children");
+    NS_ASSERTION(!mStyleData.mInheritedData && !mStyleData.mResetData,
+                 "should not have cached data");
+  }
+#endif
 };
 
 #endif
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -222,16 +222,31 @@ class nsStyleSet
   nsresult BeginReconstruct();
   // Note: EndReconstruct should not be called if BeginReconstruct fails
   void EndReconstruct();
 
   // Let the style set know that a particular sheet is the quirks sheet.  This
   // sheet must already have been added to the UA sheets.  The pointer must not
   // be null.  This should only be called once for a given style set.
   void SetQuirkStyleSheet(nsIStyleSheet* aQuirkStyleSheet);
+
+#ifdef DEBUG
+  // Assert that things that change the results of media queries or
+  // things that require style data rebuilds don't need to cause
+  // any rebuilding to happen yet.
+  void AssertNoStyleDataToRebuild() {
+    // Assert that the root rule node has no children and no style data.
+    if (mRuleTree) {
+      mRuleTree->AssertTreeHasNoCachedData();
+    }
+    // We don't care whether we have cached rule processors or whether
+    // they have cached rule cascades; getting the rule cascades again
+    // in order to do rule matching will get the correct rule cascade.
+  }
+#endif
   
  private:
   // Not to be implemented
   nsStyleSet(const nsStyleSet& aCopy);
   nsStyleSet& operator=(const nsStyleSet& aCopy);
 
   // Returns false on out-of-memory.
   PRBool BuildDefaultStyleData(nsPresContext* aPresContext);
