Prevent posting media query changed events during construction.  (Bug 468645)  (BREAKS OPENING layout/style/test/test_acid3_test46.html IN A NEW TAB)

diff --git a/layout/base/nsIPresShell.h b/layout/base/nsIPresShell.h
--- a/layout/base/nsIPresShell.h
+++ b/layout/base/nsIPresShell.h
@@ -270,16 +270,17 @@ public:
   NS_IMETHOD EndObservingDocument() = 0;
 
   /**
    * Determine if InitialReflow() was previously called.
    * @param aDidInitialReflow PR_TRUE if InitalReflow() was previously called,
    * PR_FALSE otherwise.
    */
   NS_IMETHOD GetDidInitialReflow(PRBool *aDidInitialReflow) = 0;
+  PRBool DidInitialReflow() const { return mDidInitialReflow; }
 
   /**
    * Perform the initial reflow. Constructs the frame for the root content
    * object and then reflows the frame model into the specified width and
    * height.
    *
    * The coordinates for aWidth and aHeight must be in standard nscoords.
    *
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1171,18 +1171,20 @@ nsPresContext::SetFullZoom(float aZoom)
   }
 
   NS_ASSERTION(mSupressResizeReflow == PR_FALSE, "two zooms happening at the same time? impossible!");
   mSupressResizeReflow = PR_TRUE;
 
   mFullZoom = aZoom;
   GetViewManager()->SetWindowDimensions(NSToCoordRound(oldWidthDevPixels * AppUnitsPerDevPixel()),
                                         NSToCoordRound(oldHeightDevPixels * AppUnitsPerDevPixel()));
-  MediaFeatureValuesChanged(PR_TRUE);
-  RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
+  if (HasCachedStyleData()) {
+    MediaFeatureValuesChanged(PR_TRUE);
+    RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
+  }
 
   mSupressResizeReflow = PR_FALSE;
 
   mCurAppUnitsPerDevPixel = AppUnitsPerDevPixel();
 }
 
 void
 nsPresContext::SetImageLoaders(nsIFrame* aTargetFrame,
@@ -1948,8 +1950,14 @@ nsPresContext::NotifyInvalidation(const 
                                           &nsPresContext::FireDOMPaintEvent);
     NS_DispatchToCurrentThread(ev);
   }
 
   nsRegion* r = aIsCrossDoc ? &mCrossDocDirtyRegion : &mSameDocDirtyRegion;
   r->Or(*r, aRect);
   r->SimplifyOutward(10);
 }
+
+PRBool
+nsPresContext::HasCachedStyleData()
+{
+  return mShell && mShell->StyleSet()->HasCachedStyleData();
+}
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -441,17 +441,18 @@ public:
   nsRect GetVisibleArea() { return mVisibleArea; }
 
   /**
    * Set the currently visible area. The units for r are standard
    * nscoord units (as scaled by the device context).
    */
   void SetVisibleArea(const nsRect& r) {
     mVisibleArea = r;
-    PostMediaFeatureValuesChangedEvent();
+    if (HasCachedStyleData())
+      PostMediaFeatureValuesChangedEvent();
   }
 
   /**
    * Return true if this presentation context is a paginated
    * context.
    */
   PRBool IsPaginated() const { return mPaginated; }
   
@@ -507,17 +508,18 @@ public:
 
   nsIDeviceContext* DeviceContext() { return mDeviceContext; }
   nsIEventStateManager* EventStateManager() { return mEventManager; }
   nsIAtom* GetLangGroup() { return mLangGroup; }
 
   float TextZoom() { return mTextZoom; }
   void SetTextZoom(float aZoom) {
     mTextZoom = aZoom;
-    RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
+    if (HasCachedStyleData())
+      RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
   }
 
   float GetFullZoom() { return mFullZoom; }
   void SetFullZoom(float aZoom);
 
   nscoord GetAutoQualityMinFontSize() {
     return DevPixelsToAppUnits(mAutoQualityMinFontSizePixelsPref);
   }
@@ -800,16 +802,19 @@ protected:
 
   NS_HIDDEN_(void) UpdateCharSet(const nsAFlatCString& aCharSet);
 
   void HandleRebuildUserFontSet() {
     mPostedFlushUserFontSet = PR_FALSE;
     FlushUserFontSet();
   }
 
+  // Can't be inline because we can't include nsStyleSet.h.
+  PRBool HasCachedStyleData();
+
   // IMPORTANT: The ownership implicit in the following member variables
   // has been explicitly checked.  If you add any members to this class,
   // please make the ownership explicit (pinkerton, scc).
   
   nsPresContextType     mType;
   nsIPresShell*         mShell;         // [WEAK]
   nsCOMPtr<nsIDocument> mDocument;
   nsIDeviceContext*     mDeviceContext; // [STRONG] could be weak, but
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -396,17 +396,17 @@ private:
     kHashType = 0x1
   };
   enum {
     // Maximum to have in a list before converting to a hashtable.
     // XXX Need to optimize this.
     kMaxChildrenInList = 32
   };
 
-  PRBool HaveChildren() {
+  PRBool HaveChildren() const {
     return mChildren.asVoid != nsnull;
   }
   PRBool ChildrenAreHashed() {
     return (PRWord(mChildren.asVoid) & kTypeMask) == kHashType;
   }
   nsRuleNode* ChildrenList() {
     return mChildren.asList;
   }
@@ -746,11 +746,20 @@ public:
   // Expose this so media queries can use it
   static nscoord CalcLengthWithInitialFont(nsPresContext* aPresContext,
                                            const nsCSSValue& aValue);
   // Expose this so nsTransformFunctions can use it.
   static nscoord CalcLength(const nsCSSValue& aValue,
                             nsStyleContext* aStyleContext,
                             nsPresContext* aPresContext,
                             PRBool& aInherited);
+
+  // Return whether the rule tree for which this node is the root has
+  // cached data such that we need to do dynamic change handling for
+  // changes that change the results of media queries or require
+  // rebuilding all style data.
+  PRBool TreeHasCachedData() const {
+    NS_ASSERTION(IsRoot(), "should only be called on root of rule tree");
+    return HaveChildren() || mStyleData.mInheritedData || mStyleData.mResetData;
+  }
 };
 
 #endif
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -222,16 +222,28 @@ class nsStyleSet
   nsresult BeginReconstruct();
   // Note: EndReconstruct should not be called if BeginReconstruct fails
   void EndReconstruct();
 
   // Let the style set know that a particular sheet is the quirks sheet.  This
   // sheet must already have been added to the UA sheets.  The pointer must not
   // be null.  This should only be called once for a given style set.
   void SetQuirkStyleSheet(nsIStyleSheet* aQuirkStyleSheet);
+
+  // Return whether the rule tree has cached data such that we need to
+  // do dynamic change handling for changes that change the results of
+  // media queries or require rebuilding all style data.
+  // We don't care whether we have cached rule processors or whether
+  // they have cached rule cascades; getting the rule cascades again in
+  // order to do rule matching will get the correct rule cascade.
+  PRBool HasCachedStyleData() const {
+    if (!mRuleTree)
+      return PR_FALSE;
+    return mRuleTree->TreeHasCachedData();
+  }
   
  private:
   // Not to be implemented
   nsStyleSet(const nsStyleSet& aCopy);
   nsStyleSet& operator=(const nsStyleSet& aCopy);
 
   // Returns false on out-of-memory.
   PRBool BuildDefaultStyleData(nsPresContext* aPresContext);
