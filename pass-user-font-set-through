Pass the user font set through more reliably and make it a required parameter.  (Bug 467084)  r+sr=roc  a=blocking1.9.1+

diff --git a/accessible/src/html/nsHyperTextAccessible.cpp b/accessible/src/html/nsHyperTextAccessible.cpp
--- a/accessible/src/html/nsHyperTextAccessible.cpp
+++ b/accessible/src/html/nsHyperTextAccessible.cpp
@@ -266,26 +266,16 @@ nsIntRect nsHyperTextAccessible::GetBoun
   // Get the right frame continuation -- not really a child, but a sibling of
   // the primary frame passed in
   rv = aFrame->GetChildFrameContainingOffset(startContentOffset, PR_FALSE,
                                              &startContentOffsetInFrame, &frame);
   NS_ENSURE_SUCCESS(rv, screenRect);
 
   nsCOMPtr<nsIPresShell> shell = GetPresShell();
   NS_ENSURE_TRUE(shell, screenRect);
-
-  nsCOMPtr<nsIRenderingContext> rc;
-  shell->CreateRenderingContext(frame, getter_AddRefs(rc));
-  NS_ENSURE_TRUE(rc, screenRect);
-
-  const nsStyleFont *font = frame->GetStyleFont();
-  const nsStyleVisibility *visibility = frame->GetStyleVisibility();
-
-  rv = rc->SetFont(font->mFont, visibility->mLangGroup);
-  NS_ENSURE_SUCCESS(rv, screenRect);
 
   nsPresContext *context = shell->GetPresContext();
 
   while (frame && startContentOffset < endContentOffset) {
     // Start with this frame's screen rect, which we will 
     // shrink based on the substring we care about within it.
     // We will then add that frame to the total screenRect we
     // are returning.
diff --git a/accessible/src/msaa/nsTextAccessibleWrap.cpp b/accessible/src/msaa/nsTextAccessibleWrap.cpp
--- a/accessible/src/msaa/nsTextAccessibleWrap.cpp
+++ b/accessible/src/msaa/nsTextAccessibleWrap.cpp
@@ -246,31 +246,32 @@ STDMETHODIMP nsTextAccessibleWrap::get_f
 STDMETHODIMP nsTextAccessibleWrap::get_fontFamily(
     /* [retval][out] */ BSTR __RPC_FAR *aFontFamily)
 {
 __try {
   *aFontFamily = NULL;
 
   nsIFrame *frame = GetFrame();
   nsCOMPtr<nsIPresShell> presShell = GetPresShell();
-  if (!frame || !presShell) {
+  if (!frame || !presShell || !presShell->GetPresContext()) {
     return E_FAIL;
   }
 
   nsCOMPtr<nsIRenderingContext> rc;
   presShell->CreateRenderingContext(frame, getter_AddRefs(rc));
   if (!rc) {
     return E_FAIL;
   }
 
   const nsStyleFont *font = frame->GetStyleFont();
 
   const nsStyleVisibility *visibility = frame->GetStyleVisibility();
 
-  if (NS_FAILED(rc->SetFont(font->mFont, visibility->mLangGroup))) {
+  if (NS_FAILED(rc->SetFont(font->mFont, visibility->mLangGroup,
+                            presShell->GetPresContext()->GetUserFontSet()))) {
     return E_FAIL;
   }
 
   nsCOMPtr<nsIDeviceContext> deviceContext;
   rc->GetDeviceContext(*getter_AddRefs(deviceContext));
   if (!deviceContext) {
     return E_FAIL;
   }
diff --git a/gfx/public/nsDeviceContext.h b/gfx/public/nsDeviceContext.h
--- a/gfx/public/nsDeviceContext.h
+++ b/gfx/public/nsDeviceContext.h
@@ -56,17 +56,18 @@ class NS_GFX nsFontCache
 {
 public:
   nsFontCache();
   virtual ~nsFontCache();
 
   virtual nsresult Init(nsIDeviceContext* aContext);
   virtual nsresult GetDeviceContext(nsIDeviceContext *&aContext) const;
   virtual nsresult GetMetricsFor(const nsFont& aFont, nsIAtom* aLangGroup,
-                                 nsIFontMetrics *&aMetrics, gfxUserFontSet *aUserFontSet = nsnull);
+                                 gfxUserFontSet* aUserFontSet,
+                                 nsIFontMetrics *&aMetrics);
 
   nsresult   FontMetricsDeleted(const nsIFontMetrics* aFontMetrics);
   nsresult   Compact();
   nsresult   Flush();
   /* printer device context classes may create their own
    * subclasses of nsFontCache (and override this method) and override 
    * DeviceContextImpl::CreateFontCache (see bug 81311).
    */
@@ -95,19 +96,21 @@ public:
   NS_IMETHOD  Init(nsNativeWidget aWidget);
 
   NS_IMETHOD  CreateRenderingContext(nsIView *aView, nsIRenderingContext *&aContext);
   NS_IMETHOD  CreateRenderingContext(nsIWidget *aWidget, nsIRenderingContext *&aContext);
   NS_IMETHOD  CreateRenderingContext(nsIRenderingContext *&aContext){return NS_ERROR_NOT_IMPLEMENTED;}
   NS_IMETHOD  CreateRenderingContextInstance(nsIRenderingContext *&aContext);
 
   NS_IMETHOD  GetMetricsFor(const nsFont& aFont, nsIAtom* aLangGroup,
-                            nsIFontMetrics*& aMetrics, gfxUserFontSet *aUserFontSet = nsnull);
-  NS_IMETHOD  GetMetricsFor(const nsFont& aFont, nsIFontMetrics*& aMetrics, 
-                            gfxUserFontSet *aUserFontSet = nsnull);
+                            gfxUserFontSet* aUserFontSet,
+                            nsIFontMetrics*& aMetrics);
+  NS_IMETHOD  GetMetricsFor(const nsFont& aFont,
+                            gfxUserFontSet* aUserFontSet,
+                            nsIFontMetrics*& aMetrics);
 
   NS_IMETHOD FirstExistingFont(const nsFont& aFont, nsString& aFaceName);
 
   NS_IMETHOD GetLocalFontName(const nsString& aFaceName, nsString& aLocalName,
                               PRBool& aAliased);
 
   NS_IMETHOD CreateFontCache();
   NS_IMETHOD FontMetricsDeleted(const nsIFontMetrics* aFontMetrics);
diff --git a/gfx/public/nsIDeviceContext.h b/gfx/public/nsIDeviceContext.h
--- a/gfx/public/nsIDeviceContext.h
+++ b/gfx/public/nsIDeviceContext.h
@@ -164,20 +164,20 @@ typedef void * nsNativeDeviceContext;
 #ifdef NS_PRINT_PREVIEW
 const PRUint8 kUseAltDCFor_NONE            = 0x00; // Do not use the AltDC for anything
 const PRUint8 kUseAltDCFor_FONTMETRICS     = 0x01; // Use it for only getting the font metrics
 const PRUint8 kUseAltDCFor_CREATERC_REFLOW = 0x02; // Use when creating RenderingContexts for Reflow
 const PRUint8 kUseAltDCFor_CREATERC_PAINT  = 0x04; // Use when creating RenderingContexts for Painting
 const PRUint8 kUseAltDCFor_SURFACE_DIM     = 0x08; // Use it for getting the Surface Dimensions
 #endif
 
-// 92a1e76c-adbd-441e-aae6-243d6004e0ee
+// eca27eb2-ef6f-4142-bf77-89c14e595171
 #define NS_IDEVICE_CONTEXT_IID   \
-{ 0x92a1e76c, 0xadbd, 0x441e, \
- { 0xaa, 0xe6, 0x24, 0x3d, 0x60, 0x4, 0xe0, 0xee } }
+{ 0xeca27eb2, 0xef6f, 0x4142, \
+  { 0xbf, 0x77, 0x89, 0xc1, 0x4e, 0x59, 0x51, 0x71 } }
 
 //a cross platform way of specifying a native palette handle
 typedef void * nsPalette;
 
   //structure used to return information about a device's palette capabilities
   struct nsPaletteInfo {
      PRPackedBool  isPaletteDevice;
      PRUint16      sizePalette;  // number of entries in the palette
@@ -330,29 +330,29 @@ public:
    * an nsFont.
    * @param aFont font description to obtain metrics for
    * @param aLangGroup the language group of the document
    * @param aMetrics out parameter for font metrics
    * @param aUserFontSet user font set
    * @return error status
    */
   NS_IMETHOD  GetMetricsFor(const nsFont& aFont, nsIAtom* aLangGroup,
-                            nsIFontMetrics*& aMetrics, 
-                            gfxUserFontSet *aUserFontSet = nsnull) = 0;
+                            gfxUserFontSet* aUserFontSet,
+                            nsIFontMetrics*& aMetrics) = 0;
 
   /**
    * Get the nsIFontMetrics that describe the properties of
    * an nsFont.
    * @param aFont font description to obtain metrics for
    * @param aMetrics out parameter for font metrics
    * @param aUserFontSet user font set
    * @return error status
    */
-  NS_IMETHOD  GetMetricsFor(const nsFont& aFont, nsIFontMetrics*& aMetrics, 
-                            gfxUserFontSet *aUserFontSet = nsnull) = 0;
+  NS_IMETHOD  GetMetricsFor(const nsFont& aFont, gfxUserFontSet* aUserFontSet,
+                            nsIFontMetrics*& aMetrics) = 0;
 
   /**
    * Check to see if a particular named font exists.
    * @param aFontName character string of font face name
    * @return NS_OK if font is available, else font is unavailable
    */
   NS_IMETHOD CheckFontExistence(const nsString& aFaceName) = 0;
   NS_IMETHOD FirstExistingFont(const nsFont& aFont, nsString& aFaceName) = 0;
diff --git a/gfx/public/nsIRenderingContext.h b/gfx/public/nsIRenderingContext.h
--- a/gfx/public/nsIRenderingContext.h
+++ b/gfx/public/nsIRenderingContext.h
@@ -55,16 +55,17 @@ class nsTransform2D;
 class nsTransform2D;
 class nsString;
 class nsIDeviceContext;
 class nsIRegion;
 class nsIAtom;
 
 struct nsFont;
 struct nsTextDimensions;
+class gfxUserFontSet;
 #ifdef MOZ_MATHML
 struct nsBoundingMetrics;
 #endif
 
 class gfxASurface;
 class gfxContext;
 
 /* gfx2 */
@@ -92,20 +93,20 @@ typedef enum
 typedef enum
 {
   nsPenMode_kNone   = 0,
   nsPenMode_kInvert = 1
 } nsPenMode;
 
 
 // IID for the nsIRenderingContext interface
-// 3a6209e8-d80d-42ab-ad6a-b8832f7fb09f
+// 37762dd8-8df0-48cd-a5d6-24573ffdb5b6
 #define NS_IRENDERING_CONTEXT_IID \
-{ 0x3a6209e8, 0xd80d, 0x42ab, \
-  { 0xad, 0x6a, 0xb8, 0x83, 0x2f, 0x7f, 0xb0, 0x9f } }
+{ 0x37762dd8, 0x8df0, 0x48cd, \
+  { 0xa5, 0xd6, 0x24, 0x57, 0x3f, 0xfd, 0xb5, 0xb6 } }
 
 //----------------------------------------------------------------------
 
 // RenderingContext interface
 class nsIRenderingContext : public nsISupports
 {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IRENDERING_CONTEXT_IID)
@@ -197,17 +198,18 @@ public:
    * @return The current forground color of the RenderingContext
    */
   NS_IMETHOD GetColor(nscolor &aColor) const = 0;
 
   /**
    * Sets the font for the RenderingContext
    * @param aFont The font to use in the RenderingContext
    */
-  NS_IMETHOD SetFont(const nsFont& aFont, nsIAtom* aLangGroup) = 0;
+  NS_IMETHOD SetFont(const nsFont& aFont, nsIAtom* aLangGroup,
+                     gfxUserFontSet *aUserFontSet) = 0;
 
   /**
    * Sets the font for the RenderingContext
    * @param aFontMetric The font metrics representing the
    *        font to use in the RenderingContext
    */
   NS_IMETHOD SetFont(nsIFontMetrics *aFontMetrics) = 0;
 
diff --git a/gfx/src/nsDeviceContext.cpp b/gfx/src/nsDeviceContext.cpp
--- a/gfx/src/nsDeviceContext.cpp
+++ b/gfx/src/nsDeviceContext.cpp
@@ -210,51 +210,51 @@ DeviceContextImpl::GetLocaleLangGroup(vo
     }
     if (!mLocaleLangGroup) {
       mLocaleLangGroup = do_GetAtom("x-western");
     }
   }
 }
 
 NS_IMETHODIMP DeviceContextImpl::GetMetricsFor(const nsFont& aFont,
-  nsIAtom* aLangGroup, nsIFontMetrics*& aMetrics, gfxUserFontSet *aUserFontSet)
+  nsIAtom* aLangGroup, gfxUserFontSet *aUserFontSet, nsIFontMetrics*& aMetrics)
 {
   if (nsnull == mFontCache) {
     nsresult  rv = CreateFontCache();
     if (NS_FAILED(rv)) {
       aMetrics = nsnull;
       return rv;
     }
     // XXX temporary fix for performance problem -- erik
     GetLocaleLangGroup();
   }
 
   // XXX figure out why aLangGroup is NULL sometimes
   if (!aLangGroup) {
     aLangGroup = mLocaleLangGroup;
   }
 
-  return mFontCache->GetMetricsFor(aFont, aLangGroup, aMetrics, aUserFontSet);
+  return mFontCache->GetMetricsFor(aFont, aLangGroup, aUserFontSet, aMetrics);
 }
 
 NS_IMETHODIMP DeviceContextImpl::GetMetricsFor(const nsFont& aFont, 
-                                               nsIFontMetrics*& aMetrics, 
-                                               gfxUserFontSet *aUserFontSet)
+                                               gfxUserFontSet *aUserFontSet,
+                                               nsIFontMetrics*& aMetrics)
 {
   if (nsnull == mFontCache) {
     nsresult  rv = CreateFontCache();
     if (NS_FAILED(rv)) {
       aMetrics = nsnull;
       return rv;
     }
     // XXX temporary fix for performance problem -- erik
     GetLocaleLangGroup();
   }
-  return mFontCache->GetMetricsFor(aFont, mLocaleLangGroup, 
-                                   aMetrics, aUserFontSet);
+  return mFontCache->GetMetricsFor(aFont, mLocaleLangGroup, aUserFontSet,
+                                   aMetrics);
 }
 
 NS_IMETHODIMP DeviceContextImpl::GetDepth(PRUint32& aDepth)
 {
   aDepth = 24;
   return NS_OK;
 }
 
@@ -469,17 +469,17 @@ nsFontCache::GetDeviceContext(nsIDeviceC
 {
   aContext = mContext;
   NS_IF_ADDREF(aContext);
   return NS_OK;
 }
 
 nsresult
 nsFontCache::GetMetricsFor(const nsFont& aFont, nsIAtom* aLangGroup,
-  nsIFontMetrics *&aMetrics, gfxUserFontSet *aUserFontSet)
+  gfxUserFontSet *aUserFontSet, nsIFontMetrics *&aMetrics)
 {
   // First check our cache
   // start from the end, which is where we put the most-recent-used element
 
   nsIFontMetrics* fm;
   PRInt32 n = mFontMetrics.Count() - 1;
   for (PRInt32 i = n; i >= 0; --i) {
     fm = static_cast<nsIFontMetrics*>(mFontMetrics[i]);
diff --git a/gfx/src/thebes/nsThebesRenderingContext.cpp b/gfx/src/thebes/nsThebesRenderingContext.cpp
--- a/gfx/src/thebes/nsThebesRenderingContext.cpp
+++ b/gfx/src/thebes/nsThebesRenderingContext.cpp
@@ -778,22 +778,24 @@ nsThebesRenderingContext::GetRightToLeft
 
 void
 nsThebesRenderingContext::SetTextRunRTL(PRBool aIsRTL)
 {
 	mFontMetrics->SetTextRunRTL(aIsRTL);
 }
 
 NS_IMETHODIMP
-nsThebesRenderingContext::SetFont(const nsFont& aFont, nsIAtom* aLangGroup)
+nsThebesRenderingContext::SetFont(const nsFont& aFont, nsIAtom* aLangGroup,
+                                  gfxUserFontSet *aUserFontSet)
 {
     PR_LOG(gThebesGFXLog, PR_LOG_DEBUG, ("## %p nsTRC::SetFont %p\n", this, &aFont));
 
     nsCOMPtr<nsIFontMetrics> newMetrics;
-    mDeviceContext->GetMetricsFor(aFont, aLangGroup, *getter_AddRefs(newMetrics));
+    mDeviceContext->GetMetricsFor(aFont, aLangGroup, aUserFontSet,
+                                  *getter_AddRefs(newMetrics));
     mFontMetrics = reinterpret_cast<nsIThebesFontMetrics*>(newMetrics.get());
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsThebesRenderingContext::SetFont(nsIFontMetrics *aFontMetrics)
 {
     PR_LOG(gThebesGFXLog, PR_LOG_DEBUG, ("## %p nsTRC::SetFont[Metrics] %p\n", this, aFontMetrics));
diff --git a/gfx/src/thebes/nsThebesRenderingContext.h b/gfx/src/thebes/nsThebesRenderingContext.h
--- a/gfx/src/thebes/nsThebesRenderingContext.h
+++ b/gfx/src/thebes/nsThebesRenderingContext.h
@@ -74,17 +74,18 @@ public:
     NS_IMETHOD GetDeviceContext(nsIDeviceContext *& aDeviceContext);
     NS_IMETHOD PushState(void);
     NS_IMETHOD PopState(void);
     NS_IMETHOD SetClipRect(const nsRect& aRect, nsClipCombine aCombine);
     NS_IMETHOD SetLineStyle(nsLineStyle aLineStyle);
     NS_IMETHOD SetClipRegion(const nsIRegion& aRegion, nsClipCombine aCombine);
     NS_IMETHOD SetColor(nscolor aColor);
     NS_IMETHOD GetColor(nscolor &aColor) const;
-    NS_IMETHOD SetFont(const nsFont& aFont, nsIAtom* aLangGroup);
+    NS_IMETHOD SetFont(const nsFont& aFont, nsIAtom* aLangGroup,
+                       gfxUserFontSet *aUserFontSet);
     NS_IMETHOD SetFont(nsIFontMetrics *aFontMetrics);
     NS_IMETHOD GetFontMetrics(nsIFontMetrics *&aFontMetrics);
     NS_IMETHOD Translate(nscoord aX, nscoord aY);
     NS_IMETHOD Scale(float aSx, float aSy);
     NS_IMETHOD GetCurrentTransform(nsTransform2D *&aTransform);
 
     NS_IMETHOD DrawLine(nscoord aX0, nscoord aY0, nscoord aX1, nscoord aY1);
     NS_IMETHOD DrawRect(const nsRect& aRect);
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -1504,17 +1504,17 @@ nsLayoutUtils::GetFontMetricsForStyleCon
                                              nsIFontMetrics** aFontMetrics)
 {
   // pass the user font set object into the device context to pass along to CreateFontGroup
   gfxUserFontSet* fs = aStyleContext->PresContext()->GetUserFontSet();
   
   return aStyleContext->PresContext()->DeviceContext()->GetMetricsFor(
                   aStyleContext->GetStyleFont()->mFont,
                   aStyleContext->GetStyleVisibility()->mLangGroup,
-                  *aFontMetrics, fs);
+                  fs, *aFontMetrics);
 }
 
 nsIFrame*
 nsLayoutUtils::FindChildContainingDescendant(nsIFrame* aParent, nsIFrame* aDescendantFrame)
 {
   nsIFrame* result = aDescendantFrame;
 
   while (result) {
@@ -2902,17 +2902,18 @@ nsLayoutUtils::GetWholeImageDestination(
 }
 
 void
 nsLayoutUtils::SetFontFromStyle(nsIRenderingContext* aRC, nsStyleContext* aSC) 
 {
   const nsStyleFont* font = aSC->GetStyleFont();
   const nsStyleVisibility* visibility = aSC->GetStyleVisibility();
 
-  aRC->SetFont(font->mFont, visibility->mLangGroup);
+  aRC->SetFont(font->mFont, visibility->mLangGroup,
+               aSC->PresContext()->GetUserFontSet());
 }
 
 static PRBool NonZeroStyleCoord(const nsStyleCoord& aCoord)
 {
   switch (aCoord.GetUnit()) {
   case eStyleUnit_Percent:
     return aCoord.GetPercentValue() > 0;
   case eStyleUnit_Coord:
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1099,17 +1099,17 @@ nsPresContext::SetImageAnimationModeExte
 {
   SetImageAnimationModeInternal(aMode);
 }
 
 already_AddRefed<nsIFontMetrics>
 nsPresContext::GetMetricsFor(const nsFont& aFont)
 {
   nsIFontMetrics* metrics = nsnull;
-  mDeviceContext->GetMetricsFor(aFont, mLangGroup, metrics);
+  mDeviceContext->GetMetricsFor(aFont, mLangGroup, GetUserFontSet(), metrics);
   return metrics;
 }
 
 const nsFont*
 nsPresContext::GetDefaultFont(PRUint8 aFontID) const
 {
   const nsFont *font;
   switch (aFontID) {
@@ -1703,17 +1703,17 @@ InsertFontFaceRule(nsCSSFontFaceRule *aR
   }
   
   if (!fontfamily.IsEmpty() && srcArray.Length() > 0) {
     aFontSet->AddFontFace(fontfamily, srcArray, weight, stretch, italicStyle);
   }
 }
 
 gfxUserFontSet*
-nsPresContext::GetUserFontSet()
+nsPresContext::GetUserFontSetInternal()
 {
   // We want to initialize the user font set lazily the first time the
   // user asks for it, rather than building it too early and forcing
   // rule cascade creation.  Thus we try to enforce the invariant that
   // we *never* build the user font set until the first call to
   // GetUserFontSet.  However, once it's been requested, we can't wait
   // for somebody to call GetUserFontSet in order to rebuild it (see
   // comments below in RebuildUserFontSet for why).
@@ -1733,16 +1733,22 @@ nsPresContext::GetUserFontSet()
                    "FlushUserFontSet should have been called first");
     }
 #endif
     FlushUserFontSet();
   }
 
   mGetUserFontSetCalled = PR_TRUE;
   return mUserFontSet;
+}
+
+gfxUserFontSet*
+nsPresContext::GetUserFontSetExternal()
+{
+  return GetUserFontSetInternal();
 }
 
 void
 nsPresContext::FlushUserFontSet()
 {
   if (!mShell)
     return; // we've been torn down
 
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -740,17 +740,24 @@ public:
 
   // Is it OK to let the page specify colors and backgrounds?
   PRBool UseDocumentColors() const {
     return GetCachedBoolPref(kPresContext_UseDocumentColors) || IsChrome();
   }
 
   PRBool           SupressingResizeReflow() const { return mSupressResizeReflow; }
   
-  gfxUserFontSet* GetUserFontSet();
+  virtual NS_HIDDEN_(gfxUserFontSet*) GetUserFontSetExternal();
+  NS_HIDDEN_(gfxUserFontSet*) GetUserFontSetInternal();
+#ifdef _IMPL_NS_LAYOUT
+  gfxUserFontSet* GetUserFontSet() { return GetUserFontSetInternal(); }
+#else
+  gfxUserFontSet* GetUserFontSet() { return GetUserFontSetExternal(); }
+#endif
+
   void FlushUserFontSet();
   void RebuildUserFontSet(); // asynchronously
 
   void NotifyInvalidation(const nsRect& aRect, PRBool aIsCrossDoc);
   void FireDOMPaintEvent();
 
 protected:
   friend class nsRunnableMethod<nsPresContext>;
diff --git a/layout/forms/nsListControlFrame.cpp b/layout/forms/nsListControlFrame.cpp
--- a/layout/forms/nsListControlFrame.cpp
+++ b/layout/forms/nsListControlFrame.cpp
@@ -1872,46 +1872,37 @@ nsListControlFrame::IsLeftButton(nsIDOME
     }
   }
   return PR_FALSE;
 }
 
 nscoord
 nsListControlFrame::CalcFallbackRowHeight(PRInt32 aNumOptions)
 {
-  const nsStyleFont* styleFont = nsnull;
+  nsIFrame *fontFrame = nsnull;
     
   if (aNumOptions > 0) {
     // Try the first option
     nsCOMPtr<nsIContent> option = GetOptionContent(0);
     if (option) {
-      nsIFrame * optFrame = PresContext()->PresShell()->
-        GetPrimaryFrameFor(option);
-      if (optFrame) {
-        styleFont = optFrame->GetStyleFont();
-      }
+      fontFrame = PresContext()->PresShell()->GetPrimaryFrameFor(option);
     }
   }
 
-  if (!styleFont) {
+  if (!fontFrame) {
     // Fall back to our own font
-    styleFont = GetStyleFont();
+    fontFrame = this;
   }
-
-  NS_ASSERTION(styleFont, "Must have font style by now!");
 
   nscoord rowHeight = 0;
   
   nsCOMPtr<nsIFontMetrics> fontMet;
-  nsresult result = PresContext()->DeviceContext()->
-    GetMetricsFor(styleFont->mFont, *getter_AddRefs(fontMet));
-  if (NS_SUCCEEDED(result) && fontMet) {
-    if (fontMet) {
-      fontMet->GetHeight(rowHeight);
-    }
+  nsLayoutUtils::GetFontMetricsForFrame(fontFrame, getter_AddRefs(fontMet));
+  if (fontMet) {
+    fontMet->GetHeight(rowHeight);
   }
 
   return rowHeight;
 }
 
 nscoord
 nsListControlFrame::CalcIntrinsicHeight(nscoord aHeightOfARow,
                                         PRInt32 aNumberOfOptions)
diff --git a/layout/generic/nsPageFrame.cpp b/layout/generic/nsPageFrame.cpp
--- a/layout/generic/nsPageFrame.cpp
+++ b/layout/generic/nsPageFrame.cpp
@@ -495,23 +495,26 @@ nsPageFrame::PaintHeaderFooter(nsIRender
       mPD->mPrintSettings = pc->GetPrintSettings();
     if (!mPD->mPrintSettings)
       return;
   }
 
   nsRect rect(aPt.x, aPt.y, mRect.width - mPD->mShadowSize.width,
               mRect.height - mPD->mShadowSize.height);
 
-  aRenderingContext.SetFont(*mPD->mHeadFootFont, nsnull);
   aRenderingContext.SetColor(NS_RGB(0,0,0));
 
   // Get the FontMetrics to determine width.height of strings
   nsCOMPtr<nsIFontMetrics> fontMet;
   pc->DeviceContext()->GetMetricsFor(*mPD->mHeadFootFont, nsnull,
+                                     pc->GetUserFontSet(),
                                      *getter_AddRefs(fontMet));
+
+  aRenderingContext.SetFont(fontMet);
+
   nscoord ascent = 0;
   nscoord visibleHeight = 0;
   if (fontMet) {
     fontMet->GetHeight(visibleHeight);
     fontMet->GetMaxAscent(ascent);
   }
 
   // print document headers and footers
diff --git a/layout/mathml/base/src/nsMathMLChar.cpp b/layout/mathml/base/src/nsMathMLChar.cpp
--- a/layout/mathml/base/src/nsMathMLChar.cpp
+++ b/layout/mathml/base/src/nsMathMLChar.cpp
@@ -1154,27 +1154,28 @@ insert:
   }
   else { // whitespace or empty
     aFontName = aFallbackFamilies;
   }
 }
 
 // Update the font and rendering context if there is a family change
 static void
-SetFontFamily(nsIRenderingContext& aRenderingContext,
+SetFontFamily(nsPresContext*       aPresContext,
+              nsIRenderingContext& aRenderingContext,
               nsFont&              aFont,
               const nsGlyphTable*  aGlyphTable,
               const nsGlyphCode&   aGlyphCode,
               const nsAString&     aDefaultFamily)
 {
   const nsAString& family =
     aGlyphCode.font ? aGlyphTable->FontNameFor(aGlyphCode) : aDefaultFamily;
   if (! family.Equals(aFont.name)) {
     aFont.name = family;
-    aRenderingContext.SetFont(aFont, nsnull);
+    aRenderingContext.SetFont(aFont, nsnull, aPresContext->GetUserFontSet());
   }
 }
 
 class nsMathMLChar::StretchEnumContext {
 public:
   StretchEnumContext(nsMathMLChar*        aChar,
                      nsPresContext*       aPresContext,
                      nsIRenderingContext& aRenderingContext,
@@ -1255,17 +1256,18 @@ nsMathMLChar::StretchEnumContext::TryVar
 #ifdef NOISY_SEARCH
   printf("  searching in %s ...\n",
            NS_LossyConvertUTF16toASCII(aFamily).get());
 #endif
 
   nsGlyphCode ch;
   while ((ch = aGlyphTable->BigOf(mPresContext, mChar, size)).Exists()) {
 
-    SetFontFamily(mRenderingContext, font, aGlyphTable, ch, aFamily);
+    SetFontFamily(mChar->mStyleContext->PresContext(), mRenderingContext,
+                  font, aGlyphTable, ch, aFamily);
 
     NS_ASSERTION(maxWidth || ch.code != mChar->mGlyph.code ||
                  !font.name.Equals(mChar->mFamily),
                  "glyph table incorrectly set -- duplicate found");
 
     nsBoundingMetrics bm;
     nsresult rv = mRenderingContext.GetBoundingMetrics(&ch.code, 1, bm);
     if (NS_SUCCEEDED(rv)) {
@@ -1379,17 +1381,18 @@ nsMathMLChar::StretchEnumContext::TryPar
     nsBoundingMetrics bm;
     chdata[i] = ch;
     if (!ch.Exists()) {
       // Null glue indicates that a rule will be drawn, which can stretch to
       // fill any space.  Leave bounding metrics at 0.
       sizedata[i] = mTargetSize;
     }
     else {
-      SetFontFamily(mRenderingContext, font, aGlyphTable, ch, aFamily);
+      SetFontFamily(mChar->mStyleContext->PresContext(), mRenderingContext,
+                    font, aGlyphTable, ch, aFamily);
       nsresult rv = mRenderingContext.GetBoundingMetrics(&ch.code, 1, bm);
       if (NS_FAILED(rv)) {
         // stop if we failed to compute the bounding metrics of a part.
         NS_WARNING("GetBoundingMetrics failed");
         return PR_FALSE; // to next table
       }
 
       // TODO: For the generic Unicode table, ideally we should check that the
@@ -1578,17 +1581,17 @@ nsMathMLChar::StretchInternal(nsPresCont
   // Don't modify this nsMathMLChar when doing GetMaxWidth()
   PRBool maxWidth = (NS_STRETCH_MAXWIDTH & aStretchHint) != 0;
   if (!maxWidth) {
     // Record the families in case there is no stretch.  But don't bother
     // storing families when they are just those from the StyleContext.
     mFamily = families;
   }    
 
-  aRenderingContext.SetFont(font, nsnull);
+  aRenderingContext.SetFont(font, nsnull, aPresContext->GetUserFontSet());
   nsresult rv =
     aRenderingContext.GetBoundingMetrics(mData.get(), PRUint32(mData.Length()),
                                          aDesiredStretchSize);
   if (NS_FAILED(rv)) {
     NS_WARNING("GetBoundingMetrics failed");
     return rv;
   }
 
@@ -2089,17 +2092,17 @@ nsMathMLChar::PaintForeground(nsPresCont
   }
   aRenderingContext.SetColor(fgColor);
 
   nsAutoString fontName;
   nsFont theFont(styleContext->GetStyleFont()->mFont);
   if (! mFamily.IsEmpty()) {
     theFont.name = mFamily;
   }
-  aRenderingContext.SetFont(theFont, nsnull);
+  aRenderingContext.SetFont(theFont, nsnull, aPresContext->GetUserFontSet());
 
   if (NS_STRETCH_DIRECTION_UNSUPPORTED == mDirection) {
     // normal drawing if there is nothing special about this char ...
     // Grab some metrics to adjust the placements ...
     PRUint32 len = PRUint32(mData.Length());
 //printf("Painting %04X like a normal char\n", mData[0]);
 //aRenderingContext.SetColor(NS_RGB(255,0,0));
     aRenderingContext.DrawString(mData.get(), len, mRect.x + aPt.x,
@@ -2205,17 +2208,18 @@ nsMathMLChar::PaintVertically(nsPresCont
         ch = chGlue;
         glue = i;
         break;
     }
     // empty slots are filled with the glue if it is not null
     if (!ch.Exists()) ch = chGlue;
     // if (!ch.Exists()) glue is null, leave bounding metrics at 0
     if (ch.Exists()) {
-      SetFontFamily(aRenderingContext, aFont, aGlyphTable, ch, mFamily);
+      SetFontFamily(aPresContext, aRenderingContext,
+                    aFont, aGlyphTable, ch, mFamily);
       rv = aRenderingContext.GetBoundingMetrics(&ch.code, 1, bmdata[i]);
       if (NS_FAILED(rv)) {
         NS_WARNING("GetBoundingMetrics failed");
         return rv;
       }
     }
     chdata[i] = ch;
     ++i;
@@ -2293,17 +2297,18 @@ nsMathMLChar::PaintVertically(nsPresCont
         }
         else { // middle
           clipRect.y = start[i];
           clipRect.height = end[i] - start[i];
         }
       }
       if (!clipRect.IsEmpty()) {
         AutoPushClipRect clip(aRenderingContext, clipRect);
-        SetFontFamily(aRenderingContext, aFont, aGlyphTable, ch, mFamily);
+        SetFontFamily(aPresContext, aRenderingContext,
+                      aFont, aGlyphTable, ch, mFamily);
         aRenderingContext.DrawString(&ch.code, 1, dx, dy);
       }
     }
   }
 
   ///////////////
   // fill the gap between top and middle, and between middle and bottom.
   if (!chGlue.Exists()) { // null glue : draw a rule
@@ -2349,17 +2354,18 @@ nsMathMLChar::PaintVertically(nsPresCont
     // Ensure the stride for the glue is not reduced to less than one pixel
     if (bm.ascent + bm.descent >= 3 * oneDevPixel) {
       // To protect against gaps, pretend the glue is smaller than it is,
       // in order to trim off ends and thus get a solid edge for the join.
       bm.ascent -= oneDevPixel;
       bm.descent -= oneDevPixel;
     }
 
-    SetFontFamily(aRenderingContext, aFont, aGlyphTable, chGlue, mFamily);
+    SetFontFamily(aPresContext, aRenderingContext,
+                  aFont, aGlyphTable, chGlue, mFamily);
     nsRect clipRect = unionRect;
 
     for (i = 0; i < bottom; ++i) {
       // Make sure not to draw outside the character
       nscoord dy = PR_MAX(end[i], aRect.y);
       nscoord fillEnd = PR_MIN(start[i+1], aRect.YMost());
 #ifdef SHOW_BORDERS
       // exact area to fill
@@ -2435,17 +2441,18 @@ nsMathMLChar::PaintHorizontally(nsPresCo
         ch = chGlue;
         glue = i;
         break;
     }
     // empty slots are filled with the glue if it is not null
     if (!ch.Exists()) ch = chGlue;
     // if (!ch.Exists()) glue is null, leave bounding metrics at 0.
     if (ch.Exists()) {
-      SetFontFamily(aRenderingContext, aFont, aGlyphTable, ch, mFamily);
+      SetFontFamily(aPresContext, aRenderingContext,
+                    aFont, aGlyphTable, ch, mFamily);
       rv = aRenderingContext.GetBoundingMetrics(&ch.code, 1, bmdata[i]);
       if (NS_FAILED(rv)) {
         NS_WARNING("GetBoundingMetrics failed");
         return rv;
       }
     }
     chdata[i] = ch;
     ++i;
@@ -2518,17 +2525,18 @@ nsMathMLChar::PaintHorizontally(nsPresCo
         }
         else { // middle
           clipRect.x = start[i];
           clipRect.width = end[i] - start[i];
         }
       }
       if (!clipRect.IsEmpty()) {
         AutoPushClipRect clip(aRenderingContext, clipRect);
-        SetFontFamily(aRenderingContext, aFont, aGlyphTable, ch, mFamily);
+        SetFontFamily(aPresContext, aRenderingContext,
+                      aFont, aGlyphTable, ch, mFamily);
         aRenderingContext.DrawString(&ch.code, 1, dx, dy);
       }
     }
   }
 
   ////////////////
   // fill the gap between left and middle, and between middle and right.
   if (!chGlue.Exists()) { // null glue : draw a rule
@@ -2573,17 +2581,18 @@ nsMathMLChar::PaintHorizontally(nsPresCo
     // Ensure the stride for the glue is not reduced to less than one pixel
     if (bm.rightBearing - bm.leftBearing >= 3 * oneDevPixel) {
       // To protect against gaps, pretend the glue is smaller than it is,
       // in order to trim off ends and thus get a solid edge for the join.
       bm.leftBearing += oneDevPixel;
       bm.rightBearing -= oneDevPixel;
     }
 
-    SetFontFamily(aRenderingContext, aFont, aGlyphTable, chGlue, mFamily);
+    SetFontFamily(aPresContext, aRenderingContext,
+                  aFont, aGlyphTable, chGlue, mFamily);
     nsRect clipRect = unionRect;
 
     for (i = 0; i < right; ++i) {
       // Make sure not to draw outside the character
       nscoord dx = PR_MAX(end[i], aRect.x);
       nscoord fillEnd = PR_MIN(start[i+1], aRect.XMost());
 #ifdef SHOW_BORDERS
       // rectangles in-between that are to be filled
diff --git a/layout/mathml/base/src/nsMathMLContainerFrame.cpp b/layout/mathml/base/src/nsMathMLContainerFrame.cpp
--- a/layout/mathml/base/src/nsMathMLContainerFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLContainerFrame.cpp
@@ -89,17 +89,17 @@ nsMathMLContainerFrame::ReflowError(nsIR
   nsresult rv;
 
   // clear all other flags and record that there is an error with this frame
   mEmbellishData.flags = 0;
   mPresentationData.flags = NS_MATHML_ERROR;
 
   ///////////////
   // Set font
-  aRenderingContext.SetFont(GetStyleFont()->mFont, nsnull);
+  nsLayoutUtils::SetFontFromStyle(&aRenderingContext, GetStyleContext());
 
   // bounding metrics
   nsAutoString errorMsg; errorMsg.AssignLiteral("invalid-markup");
   rv = aRenderingContext.GetBoundingMetrics(errorMsg.get(),
                                             PRUint32(errorMsg.Length()),
                                             mBoundingMetrics);
   if (NS_FAILED(rv)) {
     NS_WARNING("GetBoundingMetrics failed");
@@ -139,17 +139,17 @@ public:
      const nsRect& aDirtyRect);
   NS_DISPLAY_DECL_NAME("MathMLError")
 };
 
 void nsDisplayMathMLError::Paint(nsDisplayListBuilder* aBuilder,
      nsIRenderingContext* aCtx, const nsRect& aDirtyRect)
 {
   // Set color and font ...
-  aCtx->SetFont(mFrame->GetStyleFont()->mFont, nsnull);
+  nsLayoutUtils::SetFontFromStyle(aCtx, mFrame->GetStyleContext());
 
   nsPoint pt = aBuilder->ToReferenceFrame(mFrame);
   aCtx->SetColor(NS_RGB(255,0,0));
   aCtx->FillRect(nsRect(pt, mFrame->GetSize()));
   aCtx->SetColor(NS_RGB(255,255,255));
 
   nscoord ascent;
   nsCOMPtr<nsIFontMetrics> fm;
diff --git a/layout/mathml/base/src/nsMathMLmfencedFrame.cpp b/layout/mathml/base/src/nsMathMLmfencedFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmfencedFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmfencedFrame.cpp
@@ -267,17 +267,18 @@ nsMathMLmfencedFrame::doReflow(nsPresCon
   nsresult rv;
   aDesiredSize.width = aDesiredSize.height = 0;
   aDesiredSize.ascent = 0;
   aDesiredSize.mBoundingMetrics.Clear();
 
   PRInt32 i;
   nsCOMPtr<nsIFontMetrics> fm;
   const nsStyleFont* font = aForFrame->GetStyleFont();
-  aReflowState.rendContext->SetFont(font->mFont, nsnull);
+  aReflowState.rendContext->SetFont(font->mFont, nsnull,
+                                    aPresContext->GetUserFontSet());
   aReflowState.rendContext->GetFontMetrics(*getter_AddRefs(fm));
   nscoord axisHeight, em;
   GetAxisHeight(*aReflowState.rendContext, fm, axisHeight);
   GetEmHeight(fm, em);
   // leading to be left at the top and the bottom of stretched chars
   nscoord leading = NSToCoordRound(0.2f * em); 
 
   /////////////
diff --git a/layout/mathml/base/src/nsMathMLmfracFrame.cpp b/layout/mathml/base/src/nsMathMLmfracFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmfracFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmfracFrame.cpp
@@ -300,17 +300,18 @@ nsMathMLmfracFrame::Place(nsIRenderingCo
   GetReflowAndBoundingMetricsFor(frameDen, sizeDen, bmDen);
 
   //////////////////
   // Get shifts
 
   nsPresContext* presContext = PresContext();
   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
 
-  aRenderingContext.SetFont(GetStyleFont()->mFont, nsnull);
+  aRenderingContext.SetFont(GetStyleFont()->mFont, nsnull,
+                            presContext->GetUserFontSet());
   nsCOMPtr<nsIFontMetrics> fm;
   aRenderingContext.GetFontMetrics(*getter_AddRefs(fm));
 
   nscoord defaultRuleThickness, axisHeight;
   GetRuleThickness(aRenderingContext, fm, defaultRuleThickness);
   GetAxisHeight(aRenderingContext, fm, axisHeight);
 
   // by default, leave at least one-pixel padding at either end, or use
diff --git a/layout/mathml/base/src/nsMathMLmmultiscriptsFrame.cpp b/layout/mathml/base/src/nsMathMLmmultiscriptsFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmmultiscriptsFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmmultiscriptsFrame.cpp
@@ -154,17 +154,18 @@ nsMathMLmmultiscriptsFrame::Place(nsIRen
   // Initialize super/sub shifts that
   // depend only on the current font
   ////////////////////////////////////////
 
   ProcessAttributes();
 
   // get x-height (an ex)
   const nsStyleFont* font = GetStyleFont();
-  aRenderingContext.SetFont(font->mFont, nsnull);
+  aRenderingContext.SetFont(font->mFont, nsnull,
+                            PresContext()->GetUserFontSet());
   nsCOMPtr<nsIFontMetrics> fm;
   aRenderingContext.GetFontMetrics(*getter_AddRefs(fm));
 
   nscoord xHeight;
   fm->GetXHeight (xHeight);
 
   nscoord ruleSize;
   GetRuleThickness (aRenderingContext, fm, ruleSize);
diff --git a/layout/mathml/base/src/nsMathMLmoFrame.cpp b/layout/mathml/base/src/nsMathMLmoFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmoFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmoFrame.cpp
@@ -627,17 +627,18 @@ nsMathMLmoFrame::Stretch(nsIRenderingCon
     return NS_OK;
   }
   mPresentationData.flags |= NS_MATHML_STRETCH_DONE;
 
   nsIFrame* firstChild = mFrames.FirstChild();
 
   // get the axis height;
   nsCOMPtr<nsIFontMetrics> fm;
-  aRenderingContext.SetFont(GetStyleFont()->mFont, nsnull);
+  aRenderingContext.SetFont(GetStyleFont()->mFont, nsnull,
+                            PresContext()->GetUserFontSet());
   aRenderingContext.GetFontMetrics(*getter_AddRefs(fm));
   nscoord axisHeight, height;
   GetAxisHeight(aRenderingContext, fm, axisHeight);
 
   // get the leading to be left at the top and the bottom of the stretched char
   // this seems more reliable than using fm->GetLeading() on suspicious fonts               
   nscoord em;
   GetEmHeight(fm, em);
diff --git a/layout/mathml/base/src/nsMathMLmoverFrame.cpp b/layout/mathml/base/src/nsMathMLmoverFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmoverFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmoverFrame.cpp
@@ -275,17 +275,18 @@ nsMathMLmoverFrame::Place(nsIRenderingCo
   GetReflowAndBoundingMetricsFor(baseFrame, baseSize, bmBase);
   GetReflowAndBoundingMetricsFor(overFrame, overSize, bmOver);
 
   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
 
   ////////////////////
   // Place Children
 
-  aRenderingContext.SetFont(GetStyleFont()->mFont, nsnull);
+  aRenderingContext.SetFont(GetStyleFont()->mFont, nsnull,
+                            PresContext()->GetUserFontSet());
   nsCOMPtr<nsIFontMetrics> fm;
   aRenderingContext.GetFontMetrics(*getter_AddRefs(fm));
 
   nscoord xHeight = 0;
   fm->GetXHeight (xHeight);
 
   nscoord ruleThickness;
   GetRuleThickness (aRenderingContext, fm, ruleThickness);
diff --git a/layout/mathml/base/src/nsMathMLmrootFrame.cpp b/layout/mathml/base/src/nsMathMLmrootFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmrootFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmrootFrame.cpp
@@ -252,17 +252,18 @@ nsMathMLmrootFrame::Reflow(nsPresContext
     // Call DidReflow() for the child frames we successfully did reflow.
     DidReflowChildren(mFrames.FirstChild(), childFrame);
     return rv;
   }
 
   ////////////
   // Prepare the radical symbol and the overline bar
 
-  renderingContext.SetFont(GetStyleFont()->mFont, nsnull);
+  renderingContext.SetFont(GetStyleFont()->mFont, nsnull,
+                           aPresContext->GetUserFontSet());
   nsCOMPtr<nsIFontMetrics> fm;
   renderingContext.GetFontMetrics(*getter_AddRefs(fm));
 
   // For radical glyphs from TeX fonts and some of the radical glyphs from
   // Mathematica fonts, the thickness of the overline can be obtained from the
   // ascent of the glyph.  Most fonts however have radical glyphs above the
   // baseline so no assumption can be made about the meaning of the ascent.
   nscoord ruleThickness, leading, em;
diff --git a/layout/mathml/base/src/nsMathMLmsqrtFrame.cpp b/layout/mathml/base/src/nsMathMLmsqrtFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmsqrtFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmsqrtFrame.cpp
@@ -180,17 +180,18 @@ nsMathMLmsqrtFrame::Place(nsIRenderingCo
   }
 
   nsBoundingMetrics bmSqr, bmBase;
   bmBase = baseSize.mBoundingMetrics;
 
   ////////////
   // Prepare the radical symbol and the overline bar
 
-  aRenderingContext.SetFont(GetStyleFont()->mFont, nsnull);
+  aRenderingContext.SetFont(GetStyleFont()->mFont, nsnull,
+                            PresContext()->GetUserFontSet());
   nsCOMPtr<nsIFontMetrics> fm;
   aRenderingContext.GetFontMetrics(*getter_AddRefs(fm));
 
   // For radical glyphs from TeX fonts and some of the radical glyphs from
   // Mathematica fonts, the thickness of the overline can be obtained from the
   // ascent of the glyph.  Most fonts however have radical glyphs above the
   // baseline so no assumption can be made about the meaning of the ascent.
   nscoord ruleThickness, leading, em;
diff --git a/layout/mathml/base/src/nsMathMLmsubsupFrame.cpp b/layout/mathml/base/src/nsMathMLmsubsupFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmsubsupFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmsubsupFrame.cpp
@@ -187,17 +187,18 @@ nsMathMLmsubsupFrame::PlaceSubSupScript(
   //////////////////////////////////////////////////
 
   // subScriptShift{1,2}
   // = minimum amount to shift the subscript down
   // = sub{1,2} in TeXbook
   // subScriptShift1 = subscriptshift attribute * x-height
   nscoord subScriptShift1, subScriptShift2;
 
-  aRenderingContext.SetFont(baseFrame->GetStyleFont()->mFont, nsnull);
+  aRenderingContext.SetFont(baseFrame->GetStyleFont()->mFont, nsnull,
+                            aPresContext->GetUserFontSet());
   nsCOMPtr<nsIFontMetrics> fm;
   aRenderingContext.GetFontMetrics(*getter_AddRefs(fm));
 
   // get x-height (an ex)
   nscoord xHeight;
   fm->GetXHeight (xHeight);
 
   nscoord ruleSize;
diff --git a/layout/mathml/base/src/nsMathMLmtableFrame.cpp b/layout/mathml/base/src/nsMathMLmtableFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmtableFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmtableFrame.cpp
@@ -604,17 +604,18 @@ nsMathMLmtableOuterFrame::Reflow(nsPresC
         }
       }
       // in other situations, fallback to center
       aDesiredSize.ascent = dy + height/2;
       break;
     case eAlign_axis:
     default: {
       // XXX should instead use style data from the row of reference here ?
-      aReflowState.rendContext->SetFont(GetStyleFont()->mFont, nsnull);
+      aReflowState.rendContext->SetFont(GetStyleFont()->mFont, nsnull,
+                                        aPresContext->GetUserFontSet());
       nsCOMPtr<nsIFontMetrics> fm;
       aReflowState.rendContext->GetFontMetrics(*getter_AddRefs(fm));
       nscoord axisHeight;
       GetAxisHeight(*aReflowState.rendContext, fm, axisHeight);
       if (rowFrame) {
         // anchor the table on the axis of the row of reference
         // XXX fallback to baseline because it is a hard problem
         // XXX need to fetch the axis of the row; would need rowalign=axis to work better
diff --git a/layout/mathml/base/src/nsMathMLmunderFrame.cpp b/layout/mathml/base/src/nsMathMLmunderFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmunderFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmunderFrame.cpp
@@ -272,17 +272,18 @@ nsMathMLmunderFrame::Place(nsIRenderingC
   GetReflowAndBoundingMetricsFor(baseFrame, baseSize, bmBase);
   GetReflowAndBoundingMetricsFor(underFrame, underSize, bmUnder);
 
   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
 
   ////////////////////
   // Place Children
 
-  aRenderingContext.SetFont(GetStyleFont()->mFont, nsnull);
+  aRenderingContext.SetFont(GetStyleFont()->mFont, nsnull,
+                            PresContext()->GetUserFontSet());
   nsCOMPtr<nsIFontMetrics> fm;
   aRenderingContext.GetFontMetrics(*getter_AddRefs(fm));
 
   nscoord xHeight = 0;
   fm->GetXHeight (xHeight);
 
   nscoord ruleThickness;
   GetRuleThickness (aRenderingContext, fm, ruleThickness);
diff --git a/layout/mathml/base/src/nsMathMLmunderoverFrame.cpp b/layout/mathml/base/src/nsMathMLmunderoverFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmunderoverFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmunderoverFrame.cpp
@@ -313,17 +313,18 @@ nsMathMLmunderoverFrame::Place(nsIRender
   GetReflowAndBoundingMetricsFor(underFrame, underSize, bmUnder);
   GetReflowAndBoundingMetricsFor(overFrame, overSize, bmOver);
 
   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
 
   ////////////////////
   // Place Children
 
-  aRenderingContext.SetFont(GetStyleFont()->mFont, nsnull);
+  aRenderingContext.SetFont(GetStyleFont()->mFont, nsnull,
+                            PresContext()->GetUserFontSet());
   nsCOMPtr<nsIFontMetrics> fm;
   aRenderingContext.GetFontMetrics(*getter_AddRefs(fm));
 
   nscoord xHeight = 0;
   fm->GetXHeight (xHeight);
 
   nscoord ruleThickness;
   GetRuleThickness (aRenderingContext, fm, ruleThickness);
diff --git a/layout/reftests/font-face/ahem-metrics-1-ref.html b/layout/reftests/font-face/ahem-metrics-1-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/font-face/ahem-metrics-1-ref.html
@@ -0,0 +1,8 @@
+<title>Testcase, bug 467084</title>
+<style>
+body { background: white; }
+body > div { background: blue; height: 100px; width: 100px; padding: 5px; }
+body > div > div { background: aqua; height: 100px; width: 100px; }
+</style>
+<div><div></div></div>
+
diff --git a/layout/reftests/font-face/ahem-metrics-1.html b/layout/reftests/font-face/ahem-metrics-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/font-face/ahem-metrics-1.html
@@ -0,0 +1,9 @@
+<title>Testcase, bug 467084</title>
+<style>
+html { background: white; }
+@font-face { font-family: "AcidAhemTest"; src: url(../fonts/Ahem.ttf); }
+body { background: blue; height: 100px; width: 100px; padding: 5px; }
+div { color: aqua; font: 100px/1 AcidAhemTest; }
+</style>
+<div>X</div>
+
diff --git a/layout/reftests/font-face/reftest.list b/layout/reftests/font-face/reftest.list
--- a/layout/reftests/font-face/reftest.list
+++ b/layout/reftests/font-face/reftest.list
@@ -50,8 +50,10 @@ skip-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP
 skip-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == disable-sheet-5.html disable-sheet-4-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == sheet-set-base-1.html sheet-set-base-1-ref.html
 skip-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == sheet-set-switch-1.html sheet-set-switch-1-ref.html
 skip-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == insert-rule-1.html insert-rule-1-ref.html
 HTTP(..) == delete-rule-1.html delete-rule-1-ref.html
 skip-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == media-query-add-1.html media-query-add-1-ref.html
 skip-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == media-query-remove-1.html media-query-remove-1-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) != media-query-add-1-ref.html media-query-remove-1-ref.html
+
+fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == ahem-metrics-1.html ahem-metrics-1-ref.html
