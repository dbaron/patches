From: L. David Baron <dbaron@dbaron.org>

Implement animation of -moz-transform property.  (Bug 531344)

diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -2362,18 +2362,18 @@ CSS_PROP_DISPLAY(
     -moz-transform,
     _moz_transform,
     MozTransform,
     0,
     Display,
     mTransform,
     eCSSType_ValueList,
     kDisplayKTable,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleDisplay, mSpecifiedTransform),
+    eStyleAnimType_Custom)
 CSS_PROP_DISPLAY(
     -moz-transform-origin,
     _moz_transform_origin,
     MozTransformOrigin,
     0,
     Display,
     mTransformOrigin,
     eCSSType_ValuePair,
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -399,16 +399,20 @@ nsStyleAnimation::ComputeDistance(nsCSSP
 
         shadow1 = shadow1->mNext;
         shadow2 = shadow2->mNext;
         NS_ABORT_IF_FALSE(!shadow1 == !shadow2, "lists should be same length");
       }
       aDistance = sqrt(squareDistance);
       break;
     }
+    case eUnit_Transform: {
+      // FIXME: WRITE ME (or not?)
+      return PR_FALSE;
+    }
     case eUnit_CSSValuePairList: {
       const nsCSSValuePairList *list1 = aStartValue.GetCSSValuePairListValue();
       const nsCSSValuePairList *list2 = aEndValue.GetCSSValuePairListValue();
       double squareDistance = 0.0f;
       do {
         static nsCSSValue nsCSSValuePairList::* const pairListValues[] = {
           &nsCSSValuePairList::mXValue,
           &nsCSSValuePairList::mYValue,
@@ -540,16 +544,184 @@ AddShadowItems(double aCoeff1, const nsC
     return PR_FALSE;
   }
   resultItem->mValue.SetArrayValue(resultArray, eCSSUnit_Array);
   *aResultTail = resultItem;
   aResultTail = &resultItem->mNext;
   return PR_TRUE;
 }
 
+static void
+InterpolateTranslate(const nsCSSValue::Array *aArray1, double aCoeff1,
+                     const nsCSSValue::Array *aArray2, double aCoeff2,
+                     nsCSSValue::Array *aResultArray, PRBool aTwoValues)
+{
+  // When combining translates with % and length, need to keep
+  // them separate (same for relevant matrix components!).
+  const nsCSSValue &v1 = aArray1->Item(1), &v2 = aArray2->Item(1);
+  NS_ABORT_IF_FALSE(v1.GetUnit() == eCSSUnit_Percent ||
+                    v1.GetUnit() == eCSSUnit_Pixel,
+                    "unexpected unit");
+  NS_ABORT_IF_FALSE(v2.GetUnit() == eCSSUnit_Percent ||
+                    v2.GetUnit() == eCSSUnit_Pixel,
+                    "unexpected unit");
+  if (v1.GetUnit() == eCSSUnit_Percent) {
+    if (v2.GetUnit() == eCSSUnit_Percent) {
+      // both percent
+      // FIXME:  WRITE ME
+    } else {
+      // v1 percent, v1 pixels
+      // FIXME:  WRITE ME
+    }
+  } else {
+    if (v2.GetUnit() == eCSSUnit_Percent) {
+      // v1 pixels, v2 percent
+      // FIXME:  WRITE ME
+    } else {
+      // both pixels
+      // FIXME:  WRITE ME
+    }
+  }
+
+
+  if (aTwoValues) {
+    // FIXME:  WRITE ME
+  }
+}
+
+static nsCSSValueList*
+InterpolateTransformLists(const nsCSSValueList* aList1, double aCoeff1,
+                          const nsCSSValueList* aList2, double aCoeff2)
+{
+  nsAutoPtr<nsCSSValueList> result;
+  nsCSSValueList **resultTail = getter_Transfers(result);
+
+  do {
+    nsCSSValueList *item = new nsCSSValueList;
+    if (!item) {
+      return nsnull;
+    }
+    *resultTail = item;
+    resultTail = &item->mNext;
+
+    const nsCSSValue::Array *a1 = aList1->mValue.GetArrayValue(),
+                            *a2 = aList2->mValue.GetArrayValue();
+    NS_ABORT_IF_FALSE(nsStyleTransformMatrix::TransformFunctionOf(a1) ==
+                      nsStyleTransformMatrix::TransformFunctionOf(a2),
+                      "transform function mismatch");
+
+    nsCSSKeyword tfunc = nsStyleTransformMatrix::TransformFunctionOf(a1);
+    PRUint32 nargs;
+    if (tfunc == eCSSKeyword_matrix) {
+      nargs = 6;
+    } else if (tfunc == eCSSKeyword_translate ||
+               tfunc == eCSSKeyword_skew ||
+               tfunc == eCSSKeyword_scale) {
+      nargs = 2;
+    } else {
+      nargs = 1;
+    }
+
+    nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(nargs + 1);
+    if (!arr) {
+      return nsnull;
+    }
+    arr->Item(0).SetStringValue(
+      NS_ConvertUTF8toUTF16(nsCSSKeywords::GetStringValue(tfunc)),
+      eCSSUnit_Ident);
+
+    switch (tfunc) {
+      case eCSSKeyword_translatex:
+      case eCSSKeyword_translatey: {
+        NS_ABORT_IF_FALSE(a1->Count() == 2, "unexpected count");
+        NS_ABORT_IF_FALSE(a2->Count() == 2, "unexpected count");
+        InterpolateTranslate(a1, aCoeff1, a2, aCoeff2, arr, PR_FALSE);
+        break;
+      }
+      case eCSSKeyword_translate: {
+        NS_ABORT_IF_FALSE(a1->Count() == 2 || a1->Count() == 3,
+                          "unexpected count");
+        NS_ABORT_IF_FALSE(a2->Count() == 2 || a2->Count() == 3,
+                          "unexpected count");
+        InterpolateTranslate(a1, aCoeff1, a2, aCoeff2, arr, PR_TRUE);
+        break;
+      }
+      case eCSSKeyword_scalex:
+      case eCSSKeyword_scaley: {
+        NS_ABORT_IF_FALSE(a1->Count() == 2, "unexpected count");
+        NS_ABORT_IF_FALSE(a2->Count() == 2, "unexpected count");
+        // FIXME:  WRITE ME
+
+        // Handle scale, and the two matrix components where identity is
+        // 1, by subtracting 1, multiplying by the coefficients, and
+        // then adding 1 back.  This gets the right AddWeighted behavior
+        // and gets us the interpolation-against-identity behavior for
+        // free.
+
+        break;
+      }
+      case eCSSKeyword_scale: {
+        NS_ABORT_IF_FALSE(a1->Count() == 2 || a1->Count() == 3,
+                          "unexpected count");
+        NS_ABORT_IF_FALSE(a2->Count() == 2 || a2->Count() == 3,
+                          "unexpected count");
+        // FIXME:  WRITE ME
+
+        // Handle scale, and the two matrix components where identity is
+        // 1, by subtracting 1, multiplying by the coefficients, and
+        // then adding 1 back.  This gets the right AddWeighted behavior
+        // and gets us the interpolation-against-identity behavior for
+        // free.
+
+        break;
+      }
+      case eCSSKeyword_skewx:
+      case eCSSKeyword_skewy:
+      case eCSSKeyword_rotate: {
+        NS_ABORT_IF_FALSE(a1->Count() == 2, "unexpected count");
+        NS_ABORT_IF_FALSE(a2->Count() == 2, "unexpected count");
+        // FIXME:  WRITE ME
+        break;
+      }
+      case eCSSKeyword_skew: {
+        NS_ABORT_IF_FALSE(a1->Count() == 2 || a1->Count() == 3,
+                          "unexpected count");
+        NS_ABORT_IF_FALSE(a2->Count() == 2 || a2->Count() == 3,
+                          "unexpected count");
+        // FIXME:  WRITE ME
+        break;
+      }
+      case eCSSKeyword_matrix: {
+        NS_ABORT_IF_FALSE(a1->Count() == 7, "unexpected count");
+        NS_ABORT_IF_FALSE(a2->Count() == 7, "unexpected count");
+        // FIXME:  WRITE ME
+
+        // Handle scale, and the two matrix components where identity is
+        // 1, by subtracting 1, multiplying by the coefficients, and
+        // then adding 1 back.  This gets the right AddWeighted behavior
+        // and gets us the interpolation-against-identity behavior for
+        // free.
+
+        // When combining translates with % and length, need to keep
+        // them separate (same for relevant matrix components!).
+
+        break;
+      }
+      default:
+        NS_ABORT_IF_FALSE(PR_FALSE, "unknown transform function");
+    }
+
+    aList1 = aList1->mNext;
+    aList2 = aList2->mNext;
+  } while (aList1);
+  NS_ABORT_IF_FALSE(!aList2, "list length mismatch");
+
+  return result.forget();
+}
+
 PRBool
 nsStyleAnimation::AddWeighted(nsCSSProperty aProperty,
                               double aCoeff1, const Value& aValue1,
                               double aCoeff2, const Value& aValue2,
                               Value& aResultValue)
 {
   Unit commonUnit = GetCommonUnit(aValue1.GetUnit(), aValue2.GetUnit());
   // Maybe need a followup method to convert the inputs into the common
@@ -851,16 +1023,81 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
           }
 
           longShadow = longShadow->mNext;
         }
       }
       aResultValue.SetAndAdoptCSSValueListValue(result.forget(), eUnit_Shadow);
       break;
     }
+    case eUnit_Transform: {
+      const nsCSSValueList *list1 = aValue1.GetCSSValueListValue();
+      const nsCSSValueList *list2 = aValue2.GetCSSValueListValue();
+
+      // We want to avoid the matrix decomposition when we can, since
+      // avoiding it can produce better results both for compound
+      // transforms and for skew and skewY (see below).  We can do this
+      // in two cases:
+      //   (1) if one of the transforms is 'none'
+      //   (2) if the lists have the same length and the transform
+      //       functions match
+      nsAutoPtr<nsCSSValueList> result;
+      if (list1->mValue.GetUnit() == eCSSUnit_None) {
+        if (list2->mValue.GetUnit() == eCSSUnit_None) {
+          result = new nsCSSValueList;
+          if (result) {
+            result->mValue.SetNoneValue();
+          }
+        } else {
+          result = InterpolateTransformLists(list2, aCoeff2, list2, 0);
+        }
+      } else {
+        if (list2->mValue.GetUnit() == eCSSUnit_None) {
+          result = InterpolateTransformLists(list1, aCoeff1, list1, 0);
+        } else {
+          PRBool match = PR_TRUE;
+
+          {
+            const nsCSSValueList *item1 = list1, *item2 = list2;
+            do {
+              nsCSSKeyword func1 = nsStyleTransformMatrix::TransformFunctionOf(
+                                     item1->mValue.GetArrayValue());
+              nsCSSKeyword func2 = nsStyleTransformMatrix::TransformFunctionOf(
+                                     item2->mValue.GetArrayValue());
+              if (func1 != func2) {
+                break;
+              }
+
+              item1 = item1->mNext;
+              item2 = item2->mNext;
+            } while (item1 && item2);
+            if (item1 || item2) {
+              // Either |break| above or length mismatch.
+              match = PR_FALSE;
+            }
+          }
+
+          if (match) {
+            result = InterpolateTransformLists(list1, aCoeff1,
+                                               list2, aCoeff2);
+          } else {
+            // FIXME: Pull in big comment from the bug (maybe into
+            // separate function)!
+            // FIXME: WRITE ME
+          }
+        }
+      }
+
+      if (!result) {
+        return PR_FALSE;
+      }
+
+      // FIXME: WRITE ME
+      return PR_FALSE;
+    }
     case eUnit_CSSValuePairList: {
       const nsCSSValuePairList *list1 = aValue1.GetCSSValuePairListValue();
       const nsCSSValuePairList *list2 = aValue2.GetCSSValuePairListValue();
       nsAutoPtr<nsCSSValuePairList> result;
       nsCSSValuePairList **resultTail = getter_Transfers(result);
       do {
         nsCSSValuePairList *item = new nsCSSValuePairList;
         if (!item) {
@@ -1154,16 +1391,17 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
     case eUnit_CSSRect:
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
                           eCSSType_Rect, "type mismatch");
       *static_cast<nsCSSRect*>(aSpecifiedValue) =
         *aComputedValue.GetCSSRectValue();
       break;
     case eUnit_Dasharray:
     case eUnit_Shadow:
+    case eUnit_Transform:
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
                           eCSSType_ValueList, "type mismatch");
       *static_cast<nsCSSValueList**>(aSpecifiedValue) =
         aComputedValue.GetCSSValueListValue();
       break;
     case eUnit_CSSValuePairList:
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
                           eCSSType_ValuePairList, "type mismatch");
@@ -1629,16 +1867,63 @@ nsStyleAnimation::ExtractComputedValue(n
                 break;
             }
           }
 
           aComputedValue.SetAndAdoptCSSValuePairListValue(result);
           break;
         }
 
+        case eCSSProperty__moz_transform: {
+          const nsStyleDisplay *display =
+            static_cast<const nsStyleDisplay*>(styleStruct);
+          nsAutoPtr<nsCSSValueList> result;
+          if (display->mSpecifiedTransform) {
+            // Clone, and convert all lengths (not percents) to pixels.
+            nsCSSValueList **resultTail = getter_Transfers(result);
+            for (const nsCSSValueList *l = display->mSpecifiedTransform;
+                 l; l = l->mNext) {
+              nsCSSValueList *clone = new nsCSSValueList;
+              if (!clone) {
+                result = nsnull;
+                break;
+              }
+              *resultTail = clone;
+              resultTail = &clone->mNext;
+
+              if (l->mValue.IsLengthUnit() &&
+                  l->mValue.GetUnit() != eCSSUnit_Pixel) {
+                PRBool canStoreInRuleTree = PR_TRUE;
+                nscoord len =
+                  nsRuleNode::CalcLength(l->mValue, aStyleContext,
+                                         aStyleContext->PresContext(),
+                                         canStoreInRuleTree);
+                clone->mValue.SetFloatValue(
+                                nsPresContext::AppUnitsToFloatCSSPixels(len),
+                                eCSSUnit_Pixel);
+              } else {
+                clone->mValue = l->mValue;
+              }
+            }
+          } else {
+            result = new nsCSSValueList();
+            if (result) {
+              result->mValue.SetNoneValue();
+            }
+          }
+          if (!result) {
+            NS_WARNING("out of memory");
+            return PR_FALSE;
+          }
+
+          aComputedValue.SetAndAdoptCSSValueListValue(result.forget(),
+                                                      eUnit_Transform);
+          break;
+        }
+
         default:
           NS_ABORT_IF_FALSE(PR_FALSE, "missing property implementation");
           return PR_FALSE;
       };
       return PR_TRUE;
     case eStyleAnimType_Coord:
       return StyleCoordToValue(*static_cast<const nsStyleCoord*>(
         StyleDataAtOffset(styleStruct, ssOffset)), aComputedValue);
@@ -1843,18 +2128,19 @@ nsStyleAnimation::Value::operator=(const
       NS_ABORT_IF_FALSE(aOther.mValue.mCSSRect, "rects may not be null");
       mValue.mCSSRect = new nsCSSRect(*aOther.mValue.mCSSRect);
       if (!mValue.mCSSRect) {
         mUnit = eUnit_Null;
       }
       break;
     case eUnit_Dasharray:
     case eUnit_Shadow:
-      NS_ABORT_IF_FALSE(mUnit != eUnit_Dasharray || aOther.mValue.mCSSValueList,
-                        "dasharrays may not be null");
+    case eUnit_Transform:
+      NS_ABORT_IF_FALSE(mUnit == eUnit_Shadow || aOther.mValue.mCSSValueList,
+                        "value lists other than shadows may not be null");
       if (aOther.mValue.mCSSValueList) {
         mValue.mCSSValueList = aOther.mValue.mCSSValueList->Clone();
         if (!mValue.mCSSValueList) {
           mUnit = eUnit_Null;
         }
       } else {
         mValue.mCSSValueList = nsnull;
       }
@@ -2037,16 +2323,17 @@ nsStyleAnimation::Value::operator==(cons
     case eUnit_Color:
       return mValue.mColor == aOther.mValue.mColor;
     case eUnit_CSSValuePair:
       return *mValue.mCSSValuePair == *aOther.mValue.mCSSValuePair;
     case eUnit_CSSRect:
       return *mValue.mCSSRect == *aOther.mValue.mCSSRect;
     case eUnit_Dasharray:
     case eUnit_Shadow:
+    case eUnit_Transform:
       return nsCSSValueList::Equal(mValue.mCSSValueList,
                                    aOther.mValue.mCSSValueList);
     case eUnit_CSSValuePairList:
       return nsCSSValuePairList::Equal(mValue.mCSSValuePairList,
                                        aOther.mValue.mCSSValuePairList);
     case eUnit_UnparsedString:
       return (NS_strcmp(GetStringBufferValue(),
                         aOther.GetStringBufferValue()) == 0);
diff --git a/layout/style/nsStyleAnimation.h b/layout/style/nsStyleAnimation.h
--- a/layout/style/nsStyleAnimation.h
+++ b/layout/style/nsStyleAnimation.h
@@ -233,16 +233,17 @@ public:
     eUnit_Coord,
     eUnit_Percent,
     eUnit_Float,
     eUnit_Color,
     eUnit_CSSValuePair, // nsCSSValuePair* (never null)
     eUnit_CSSRect, // nsCSSRect* (never null)
     eUnit_Dasharray, // nsCSSValueList* (never null)
     eUnit_Shadow, // nsCSSValueList* (may be null)
+    eUnit_Transform, // nsCSSValueList* (never null)
     eUnit_CSSValuePairList, // nsCSSValuePairList* (never null)
     eUnit_UnparsedString // nsStringBuffer* (never null)
   };
 
   class Value {
   private:
     Unit mUnit;
     union {
@@ -371,17 +372,18 @@ public:
     }
     static PRBool IsCSSValuePairUnit(Unit aUnit) {
       return aUnit == eUnit_CSSValuePair;
     }
     static PRBool IsCSSRectUnit(Unit aUnit) {
       return aUnit == eUnit_CSSRect;
     }
     static PRBool IsCSSValueListUnit(Unit aUnit) {
-      return aUnit == eUnit_Dasharray || aUnit == eUnit_Shadow;
+      return aUnit == eUnit_Dasharray || aUnit == eUnit_Shadow ||
+             aUnit == eUnit_Transform;
     }
     static PRBool IsCSSValuePairListUnit(Unit aUnit) {
       return aUnit == eUnit_CSSValuePairList;
     }
     static PRBool IsStringUnit(Unit aUnit) {
       return aUnit == eUnit_UnparsedString;
     }
   };
diff --git a/layout/style/nsStyleTransformMatrix.cpp b/layout/style/nsStyleTransformMatrix.cpp
--- a/layout/style/nsStyleTransformMatrix.cpp
+++ b/layout/style/nsStyleTransformMatrix.cpp
@@ -440,16 +440,28 @@ static void ProcessRotate(float aMain[4]
   float sinTheta = FlushToZero(sin(theta));
 
   aMain[0] = cosTheta;
   aMain[1] = sinTheta;
   aMain[2] = -sinTheta;
   aMain[3] = cosTheta;
 }
 
+  /**
+   * Return the transform function, as an nsCSSKeyword, for the given
+   * nsCSSValue::Array from a transform list.
+   */
+/* static */ nsCSSKeyword
+nsStyleTransformMatrix::TransformFunctionOf(const nsCSSValue::Array* aData)
+{
+  nsAutoString keyword;
+  aData->Item(0).GetStringValue(keyword);
+  return nsCSSKeywords::LookupKeyword(keyword);
+}
+
 /**
  * SetToTransformFunction is essentially a giant switch statement that fans
  * out to many smaller helper functions.
  */
 void
 nsStyleTransformMatrix::SetToTransformFunction(const nsCSSValue::Array * aData,
                                                nsStyleContext* aContext,
                                                nsPresContext* aPresContext,
@@ -460,19 +472,17 @@ nsStyleTransformMatrix::SetToTransformFu
   NS_PRECONDITION(aPresContext, "Need a context for unit conversion!");
   
   /* Reset the matrix to the identity so that each subfunction can just
    * worry about its own components.
    */
   SetToIdentity();
 
   /* Get the keyword for the transform. */
-  nsAutoString keyword;
-  aData->Item(0).GetStringValue(keyword);
-  switch (nsCSSKeywords::LookupKeyword(keyword)) {
+  switch (TransformFunctionOf(aData)) {
   case eCSSKeyword_translatex:
     ProcessTranslateX(mDelta, mX, aData, aContext, aPresContext,
                       aCanStoreInRuleTree);
     break;
   case eCSSKeyword_translatey:
     ProcessTranslateY(mDelta, mY, aData, aContext, aPresContext,
                       aCanStoreInRuleTree);
     break;
diff --git a/layout/style/nsStyleTransformMatrix.h b/layout/style/nsStyleTransformMatrix.h
--- a/layout/style/nsStyleTransformMatrix.h
+++ b/layout/style/nsStyleTransformMatrix.h
@@ -101,16 +101,22 @@ class nsStyleTransformMatrix
    * @param aOther The matrix to multiply this matrix by.
    * @return A new nsStyleTransformMatrix equal to this matrix multiplied
    *         by the other matrix.
    */
   const nsStyleTransformMatrix
     operator * (const nsStyleTransformMatrix &aOther) const;
 
   /**
+   * Return the transform function, as an nsCSSKeyword, for the given
+   * nsCSSValue::Array from a transform list.
+   */
+  static nsCSSKeyword TransformFunctionOf(const nsCSSValue::Array* aData);
+
+  /**
    * Given an nsCSSValue::Array* containing a -moz-transform function,
    * updates this matrix to hold the value of that function.
    *
    * @param aData The nsCSSValue::Array* containing the transform function.
    * @param aContext The style context, used for unit conversion.
    * @param aPresContext The presentation context, used for unit conversion.
    * @param aCanStoreInRuleTree Set to false if the result cannot be cached
    *                            in the rule tree, otherwise untouched.
diff --git a/layout/style/test/test_transitions_per_property.html b/layout/style/test/test_transitions_per_property.html
--- a/layout/style/test/test_transitions_per_property.html
+++ b/layout/style/test/test_transitions_per_property.html
@@ -60,16 +60,17 @@ var supported_properties = {
     "-moz-column-rule-color": [ test_color_transition ],
     "-moz-column-rule-width": [ test_length_transition ],
     "-moz-column-width": [ test_length_transition ],
     "-moz-image-region": [ test_rect_transition ],
     "-moz-outline-radius-bottomleft": [ test_radius_transition ],
     "-moz-outline-radius-bottomright": [ test_radius_transition ],
     "-moz-outline-radius-topleft": [ test_radius_transition ],
     "-moz-outline-radius-topright": [ test_radius_transition ],
+    "-moz-transform": [ test_transform_transition ],
     "-moz-transform-origin": [ test_length_pair_transition,
                                test_length_percent_pair_transition ],
     "background-color": [ test_color_transition ],
     "background-position": [ test_background_position_transition ],
     "border-bottom-color": [ test_color_transition ],
     "border-bottom-width": [ test_length_transition ],
     "border-left-color": [ test_color_transition ],
     "border-left-width": [ test_length_transition ],
@@ -605,12 +606,16 @@ function test_background_position_size_c
   div.style.setProperty(prop, "10px 40%, 50% 50px, 30% 20%", "");
   is(cs.getPropertyValue(prop), "10px 40%, 50% 50px, 30% 20%",
      "property " + prop + ": computed value before transition");
   div.style.setProperty(prop, "50px 20%, 70% 50px, 30% 40%", "");
   is(cs.getPropertyValue(prop), "30px 30%, 60% 50px, 30% 30%",
      "property " + prop + ": interpolation of lists of lengths and percents");
 }
 
+function test_transform_transition(prop) {
+  ok(false, "FIXME: WRITE ME");
+}
+
 </script>
 </pre>
 </body>
 </html>
