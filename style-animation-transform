From: L. David Baron <dbaron@dbaron.org>

Implement animation of -moz-transform property.  (Bug 531344)  r=dholbert

diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -2362,18 +2362,18 @@ CSS_PROP_DISPLAY(
     -moz-transform,
     _moz_transform,
     MozTransform,
     0,
     Display,
     mTransform,
     eCSSType_ValueList,
     kDisplayKTable,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleDisplay, mSpecifiedTransform),
+    eStyleAnimType_Custom)
 CSS_PROP_DISPLAY(
     -moz-transform-origin,
     _moz_transform_origin,
     MozTransformOrigin,
     0,
     Display,
     mTransformOrigin,
     eCSSType_ValuePair,
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -348,17 +348,17 @@ nsStyleAnimation::ComputeDistance(nsCSSP
                        normValue2)) {
         success = PR_FALSE;
         break;
       }
 
       const nsCSSValueList *shadow1 = normValue1.GetCSSValueListValue();
       const nsCSSValueList *shadow2 = normValue2.GetCSSValueListValue();
 
-      double squareDistance = 0.0f;
+      double squareDistance = 0.0;
       NS_ABORT_IF_FALSE(!shadow1 == !shadow2, "lists should be same length");
       while (shadow1) {
         nsCSSValue::Array *array1 = shadow1->mValue.GetArrayValue();
         nsCSSValue::Array *array2 = shadow2->mValue.GetArrayValue();
         for (size_t i = 0; i < 4; ++i) {
           NS_ABORT_IF_FALSE(array1->Item(i).GetUnit() == eCSSUnit_Pixel,
                             "unexpected unit");
           NS_ABORT_IF_FALSE(array2->Item(i).GetUnit() == eCSSUnit_Pixel,
@@ -399,20 +399,57 @@ nsStyleAnimation::ComputeDistance(nsCSSP
 
         shadow1 = shadow1->mNext;
         shadow2 = shadow2->mNext;
         NS_ABORT_IF_FALSE(!shadow1 == !shadow2, "lists should be same length");
       }
       aDistance = sqrt(squareDistance);
       break;
     }
+    case eUnit_Transform: {
+      const nsCSSValueList *list1 = aStartValue.GetCSSValueListValue();
+      const nsCSSValueList *list2 = aEndValue.GetCSSValueListValue();
+
+      PRBool dummy;
+      nsStyleTransformMatrix matrix1 =
+        nsStyleTransformMatrix::ReadTransforms(list1, nsnull, nsnull, dummy),
+                             matrix2 =
+        nsStyleTransformMatrix::ReadTransforms(list2, nsnull, nsnull, dummy);
+      double diff;
+      double squareDistance = 0.0;
+      for (PRUint32 i = 0; i < 4; ++i) {
+        diff = matrix1.GetMainMatrixEntry(i) - matrix2.GetMainMatrixEntry(i);
+        squareDistance += diff * diff;
+      }
+      diff = nsPresContext::AppUnitsToFloatCSSPixels(
+        matrix1.GetCoordXTranslation() - matrix2.GetCoordXTranslation());
+      squareDistance += diff * diff;
+      diff = nsPresContext::AppUnitsToFloatCSSPixels(
+        matrix1.GetCoordYTranslation() - matrix2.GetCoordYTranslation());
+      squareDistance += diff * diff;
+      diff = matrix1.GetWidthRelativeXTranslation() -
+             matrix2.GetWidthRelativeXTranslation();
+      squareDistance += diff * diff;
+      diff = matrix1.GetWidthRelativeYTranslation() -
+             matrix2.GetWidthRelativeYTranslation();
+      squareDistance += diff * diff;
+      diff = matrix1.GetHeightRelativeXTranslation() -
+             matrix2.GetHeightRelativeXTranslation();
+      squareDistance += diff * diff;
+      diff = matrix1.GetHeightRelativeYTranslation() -
+             matrix2.GetHeightRelativeYTranslation();
+      squareDistance += diff * diff;
+
+      aDistance = sqrt(squareDistance);
+      break;
+    }
     case eUnit_CSSValuePairList: {
       const nsCSSValuePairList *list1 = aStartValue.GetCSSValuePairListValue();
       const nsCSSValuePairList *list2 = aEndValue.GetCSSValuePairListValue();
-      double squareDistance = 0.0f;
+      double squareDistance = 0.0;
       do {
         static nsCSSValue nsCSSValuePairList::* const pairListValues[] = {
           &nsCSSValuePairList::mXValue,
           &nsCSSValuePairList::mYValue,
         };
         for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(pairListValues); ++i) {
           const nsCSSValue &v1 = list1->*(pairListValues[i]);
           const nsCSSValue &v2 = list2->*(pairListValues[i]);
@@ -508,16 +545,54 @@ AddCSSValuePercent(double aCoeff1, const
                    nsCSSValue &aResult)
 {
   NS_ABORT_IF_FALSE(aValue1.GetUnit() == eCSSUnit_Percent, "unexpected unit");
   NS_ABORT_IF_FALSE(aValue2.GetUnit() == eCSSUnit_Percent, "unexpected unit");
   aResult.SetPercentValue(aCoeff1 * aValue1.GetPercentValue() +
                           aCoeff2 * aValue2.GetPercentValue());
 }
 
+static void
+AddCSSValueCalc(double aCoeff1, const nsCSSValue &aValue1,
+                double aCoeff2, const nsCSSValue &aValue2,
+                nsCSSValue &aResult)
+{
+  NS_ABORT_IF_FALSE(aValue1.GetUnit() == eCSSUnit_Percent ||
+                    aValue1.GetUnit() == eCSSUnit_Pixel ||
+                    aValue1.IsCalcUnit(), "unexpected unit");
+  NS_ABORT_IF_FALSE(aValue2.GetUnit() == eCSSUnit_Percent ||
+                    aValue2.GetUnit() == eCSSUnit_Pixel ||
+                    aValue2.IsCalcUnit(), "unexpected unit");
+  nsRefPtr<nsCSSValue::Array> a1 = nsCSSValue::Array::Create(2),
+                              a2 = nsCSSValue::Array::Create(2),
+                              atop = nsCSSValue::Array::Create(2),
+                              acalc = nsCSSValue::Array::Create(1);
+  // Don't nest the eCSSUnit_Calc in our input inside any expressions.
+  a1->Item(0).SetFloatValue(aCoeff1, eCSSUnit_Number);
+  a1->Item(1) = aValue1.GetUnit() == eCSSUnit_Calc
+                  ? aValue1.GetArrayValue()->Item(0) : aValue1;
+  a2->Item(0).SetFloatValue(aCoeff2, eCSSUnit_Number);
+  a2->Item(1) = aValue2.GetUnit() == eCSSUnit_Calc
+                  ? aValue2.GetArrayValue()->Item(0) : aValue2;
+  atop->Item(0).SetArrayValue(a1, eCSSUnit_Calc_Times_L);
+  atop->Item(1).SetArrayValue(a2, eCSSUnit_Calc_Times_L);
+  acalc->Item(0).SetArrayValue(atop, eCSSUnit_Calc_Plus);
+  aResult.SetArrayValue(acalc, eCSSUnit_Calc);
+}
+
+static void
+AddCSSValueAngle(const nsCSSValue &aValue1, double aCoeff1,
+                 const nsCSSValue &aValue2, double aCoeff2,
+                 nsCSSValue &aResult)
+{
+  aResult.SetFloatValue(aCoeff1 * aValue1.GetAngleValueInRadians() +
+                        aCoeff2 * aValue2.GetAngleValueInRadians(),
+                        eCSSUnit_Radian);
+}
+
 static PRBool
 AddShadowItems(double aCoeff1, const nsCSSValue &aValue1,
                double aCoeff2, const nsCSSValue &aValue2,
                nsCSSValueList **&aResultTail)
 {
   // X, Y, Radius, Spread, Color, Inset
   NS_ABORT_IF_FALSE(aValue1.GetUnit() == eCSSUnit_Array,
                     "wrong unit");
@@ -569,16 +644,529 @@ AddShadowItems(double aCoeff1, const nsC
     return PR_FALSE;
   }
   resultItem->mValue.SetArrayValue(resultArray, eCSSUnit_Array);
   *aResultTail = resultItem;
   aResultTail = &resultItem->mNext;
   return PR_TRUE;
 }
 
+static void
+AddTransformTranslate(const nsCSSValue &aValue1, double aCoeff1,
+                      const nsCSSValue &aValue2, double aCoeff2,
+                      nsCSSValue &aResult)
+{
+  NS_ABORT_IF_FALSE(aValue1.GetUnit() == eCSSUnit_Percent ||
+                    aValue1.GetUnit() == eCSSUnit_Pixel ||
+                    aValue1.IsCalcUnit(),
+                    "unexpected unit");
+  NS_ABORT_IF_FALSE(aValue2.GetUnit() == eCSSUnit_Percent ||
+                    aValue2.GetUnit() == eCSSUnit_Pixel ||
+                    aValue2.IsCalcUnit(),
+                    "unexpected unit");
+
+  if (aValue1.GetUnit() != aValue2.GetUnit() || aValue1.IsCalcUnit()) {
+    // different units; create a calc() expression
+    AddCSSValueCalc(aCoeff1, aValue1, aCoeff2, aValue2, aResult);
+  } else if (aValue1.GetUnit() == eCSSUnit_Percent) {
+    // both percent
+    AddCSSValuePercent(aCoeff1, aValue1, aCoeff2, aValue2, aResult);
+  } else {
+    // both pixels
+    AddCSSValuePixel(aCoeff1, aValue1, aCoeff2, aValue2, aResult);
+  }
+}
+
+static void
+AddTransformScale(const nsCSSValue &aValue1, double aCoeff1,
+                  const nsCSSValue &aValue2, double aCoeff2,
+                  nsCSSValue &aResult)
+{
+  // Handle scale, and the two matrix components where identity is 1, by
+  // subtracting 1, multiplying by the coefficients, and then adding 1
+  // back.  This gets the right AddWeighted behavior and gets us the
+  // interpolation-against-identity behavior for free.
+  NS_ABORT_IF_FALSE(aValue1.GetUnit() == eCSSUnit_Number, "unexpected unit");
+  NS_ABORT_IF_FALSE(aValue2.GetUnit() == eCSSUnit_Number, "unexpected unit");
+
+  float v1 = aValue1.GetFloatValue() - 1.0f,
+        v2 = aValue2.GetFloatValue() - 1.0f;
+  float result = v1 * aCoeff1 + v2 * aCoeff2;
+  aResult.SetFloatValue(result + 1.0f, eCSSUnit_Number);
+}
+
+// FIXME: The spec still says skew should animate in angle space,
+// although I think we at least sort of agreed that it should animate
+// in tangent space.  So here I animate in in tangent space.
+// Animating in angle space would mean just using AddCSSValueAngle.
+static void
+AddTransformSkew(const nsCSSValue &aValue1, double aCoeff1,
+                 const nsCSSValue &aValue2, double aCoeff2,
+                 nsCSSValue &aResult)
+{
+  aResult.SetFloatValue(atan(aCoeff1 * tan(aValue1.GetAngleValueInRadians()) +
+                             aCoeff2 * tan(aValue2.GetAngleValueInRadians())),
+                        eCSSUnit_Radian);
+}
+
+
+static already_AddRefed<nsCSSValue::Array>
+AppendTransformFunction(nsCSSKeyword aTransformFunction,
+                        nsCSSValueList**& aListTail)
+{
+  PRUint32 nargs;
+  if (aTransformFunction == eCSSKeyword_matrix) {
+    nargs = 6;
+  } else if (aTransformFunction == eCSSKeyword_translate ||
+             aTransformFunction == eCSSKeyword_skew ||
+             aTransformFunction == eCSSKeyword_scale) {
+    nargs = 2;
+  } else {
+    NS_ABORT_IF_FALSE(aTransformFunction == eCSSKeyword_translatex ||
+                      aTransformFunction == eCSSKeyword_translatey ||
+                      aTransformFunction == eCSSKeyword_scalex ||
+                      aTransformFunction == eCSSKeyword_scaley ||
+                      aTransformFunction == eCSSKeyword_skewx ||
+                      aTransformFunction == eCSSKeyword_skewy ||
+                      aTransformFunction == eCSSKeyword_rotate,
+                      "must be a transform function");
+    nargs = 1;
+  }
+
+  nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(nargs + 1);
+  arr->Item(0).SetStringValue(
+    NS_ConvertUTF8toUTF16(nsCSSKeywords::GetStringValue(aTransformFunction)),
+    eCSSUnit_Ident);
+
+  nsCSSValueList *item = new nsCSSValueList;
+  item->mValue.SetArrayValue(arr, eCSSUnit_Function);
+
+  *aListTail = item;
+  aListTail = &item->mNext;
+
+  return arr.forget();
+}
+
+/*
+ * The relevant section of the transitions specification:
+ * http://dev.w3.org/csswg/css3-transitions/#animation-of-property-types-
+ * defers all of the details to the 2-D and 3-D transforms specifications.
+ * For the 2-D transforms specification (all that's relevant for us, right
+ * now), the relevant section is:
+ * http://dev.w3.org/csswg/css3-2d-transforms/#animation
+ * This, in turn, refers to the unmatrix program in Graphics Gems,
+ * available from http://tog.acm.org/resources/GraphicsGems/ , and in
+ * particular as the file GraphicsGems/gemsii/unmatrix.c
+ * in http://tog.acm.org/resources/GraphicsGems/AllGems.tar.gz
+ *
+ * The unmatrix reference is for general 3-D transform matrices (any of the
+ * 16 components can have any value).
+ *
+ * For CSS 2-D transforms, we have a 2-D matrix with the bottom row constant:
+ *
+ * [ A C E ]
+ * [ B D F ]
+ * [ 0 0 1 ]
+ *
+ * For that case, I believe the algorithm in unmatrix reduces to:
+ *
+ *  (1) If A * D - B * C == 0, the matrix is singular.  Fail.
+ *
+ *  (2) Set translation components (Tx and Ty) to the translation parts of
+ *      the matrix (E and F) and then ignore them for the rest of the time.
+ *      (For us, E and F each actually consist of three constants:  a
+ *      length, a multiplier for the width, and a multiplier for the
+ *      height.  This actually requires its own decomposition, but I'll
+ *      keep that separate.)
+ *
+ *  (3) Let the X scale (Sx) be sqrt(A^2 + B^2).  Then divide both A and B
+ *      by it.
+ *
+ *  (4) Let the XY shear (K) be A * C + B * D.  From C, subtract A times
+ *      the XY shear.  From D, subtract B times the XY shear.
+ *
+ *  (5) Let the Y scale (Sy) be sqrt(C^2 + D^2).  Divide C, D, and the XY
+ *      shear (K) by it.
+ *
+ *  (6) At this point, A * D - B * C is either 1 or -1.  If it is -1,
+ *      negate the XY shear (K), the X scale (Sy), and A, B, C, and D.
+ *      (Alternatively, we could negate the XY shear (K) and the Y scale
+ *      (Sy).)
+ *
+ *  (7) Let the rotation be R = atan2(B, A).
+ *
+ * Then the resulting decomposed transformation is:
+ *
+ *   translate(Tx, Ty) rotate(R) skewX(atan(K)) scale(Sx, Sy)
+ *
+ * An interesting result of this is that all of the simple transform
+ * functions (i.e., all functions other than matrix()), in isolation,
+ * decompose back to themselves except for:
+ *   'skewY(φ)', which is 'matrix(1, tan(φ), 0, 1, 0, 0)', which decomposes
+ *   to 'rotate(φ) skewX(φ) scale(sec(φ), cos(φ))' since (ignoring the
+ *   alternate sign possibilities that would get fixed in step 6):
+ *     In step 3, the X scale factor is sqrt(1+tan²(φ)) = sqrt(sec²(φ)) = sec(φ).
+ *     Thus, after step 3, A = 1/sec(φ) = cos(φ) and B = tan(φ) / sec(φ) = sin(φ).
+ *     In step 4, the XY shear is sin(φ).
+ *     Thus, after step 4, C = -cos(φ)sin(φ) and D = 1 - sin²(φ) = cos²(φ).
+ *     Thus, in step 5, the Y scale is sqrt(cos²(φ)(sin²(φ) + cos²(φ)) = cos(φ).
+ *     Thus, after step 5, C = -sin(φ), D = cos(φ), and the XY shear is tan(φ).
+ *     Thus, in step 6, A * D - B * C = cos²(φ) + sin²(φ) = 1.
+ *     In step 7, the rotation is thus φ.
+ *
+ *   skew(θ, φ), which is matrix(1, tan(φ), tan(θ), 1, 0, 0), which decomposes
+ *   to 'rotate(φ) skewX(θ + φ) scale(sec(φ), cos(φ))' since (ignoring
+ *   the alternate sign possibilities that would get fixed in step 6):
+ *     In step 3, the X scale factor is sqrt(1+tan²(φ)) = sqrt(sec²(φ)) = sec(φ).
+ *     Thus, after step 3, A = 1/sec(φ) = cos(φ) and B = tan(φ) / sec(φ) = sin(φ).
+ *     In step 4, the XY shear is cos(φ)tan(θ) + sin(φ).
+ *     Thus, after step 4,
+ *     C = tan(θ) - cos(φ)(cos(φ)tan(θ) + sin(φ)) = tan(θ)sin²(φ) - cos(φ)sin(φ)
+ *     D = 1 - sin(φ)(cos(φ)tan(θ) + sin(φ)) = cos²(φ) - sin(φ)cos(φ)tan(θ)
+ *     Thus, in step 5, the Y scale is sqrt(C² + D²) =
+ *     sqrt(tan²(θ)(sin⁴(φ) + sin²(φ)cos²(φ)) -
+ *          2 tan(θ)(sin³(φ)cos(φ) + sin(φ)cos³(φ)) +
+ *          (sin²(φ)cos²(φ) + cos⁴(φ))) =
+ *     sqrt(tan²(θ)sin²(φ) - 2 tan(θ)sin(φ)cos(φ) + cos²(φ)) =
+ *     cos(φ) - tan(θ)sin(φ) (taking the negative of the obvious solution so
+ *     we avoid flipping in step 6).
+ *     After step 5, C = -sin(φ) and D = cos(φ), and the XY shear is
+ *     (cos(φ)tan(θ) + sin(φ)) / (cos(φ) - tan(θ)sin(φ)) =
+ *     (dividing both numerator and denominator by cos(φ))
+ *     (tan(θ) + tan(φ)) / (1 - tan(θ)tan(φ)) = tan(θ + φ).
+ *     (See http://en.wikipedia.org/wiki/List_of_trigonometric_identities .)
+ *     Thus, in step 6, A * D - B * C = cos²(φ) + sin²(φ) = 1.
+ *     In step 7, the rotation is thus φ.
+ *
+ *     To check this result, we can multiply things back together:
+ *
+ *     [ cos(φ) -sin(φ) ] [ 1 tan(θ + φ) ] [ sec(φ)    0   ]
+ *     [ sin(φ)  cos(φ) ] [ 0      1     ] [   0    cos(φ) ]
+ *
+ *     [ cos(φ)      cos(φ)tan(θ + φ) - sin(φ) ] [ sec(φ)    0   ]
+ *     [ sin(φ)      sin(φ)tan(θ + φ) + cos(φ) ] [   0    cos(φ) ]
+ *
+ *     but since tan(θ + φ) = (tan(θ) + tan(φ)) / (1 - tan(θ)tan(φ)),
+ *     cos(φ)tan(θ + φ) - sin(φ)
+ *      = cos(φ)(tan(θ) + tan(φ)) - sin(φ) + sin(φ)tan(θ)tan(φ)
+ *      = cos(φ)tan(θ) + sin(φ) - sin(φ) + sin(φ)tan(θ)tan(φ)
+ *      = cos(φ)tan(θ) + sin(φ)tan(θ)tan(φ)
+ *      = tan(θ) (cos(φ) + sin(φ)tan(φ))
+ *      = tan(θ) sec(φ) (cos²(φ) + sin²(φ))
+ *      = tan(θ) sec(φ)
+ *     and
+ *     sin(φ)tan(θ + φ) + cos(φ)
+ *      = sin(φ)(tan(θ) + tan(φ)) + cos(φ) - cos(φ)tan(θ)tan(φ)
+ *      = tan(θ) (sin(φ) - sin(φ)) + sin(φ)tan(φ) + cos(φ)
+ *      = sec(φ) (sin²(φ) + cos²(φ))
+ *      = sec(φ)
+ *     so the above is:
+ *     [ cos(φ)  tan(θ) sec(φ) ] [ sec(φ)    0   ]
+ *     [ sin(φ)     sec(φ)     ] [   0    cos(φ) ]
+ *
+ *     [    1   tan(θ) ]
+ *     [ tan(φ)    1   ]
+ */
+
+/*
+ * DecomposeMatrix implements the non-translation parts of the above
+ * decomposition algorithm.
+ */
+static PRBool
+DecomposeMatrix(const nsStyleTransformMatrix &aMatrix,
+                float &aRotate, float &aXYShear, float &aScaleX, float &aScaleY)
+{
+  float A = aMatrix.GetMainMatrixEntry(0),
+        B = aMatrix.GetMainMatrixEntry(1),
+        C = aMatrix.GetMainMatrixEntry(2),
+        D = aMatrix.GetMainMatrixEntry(3);
+  if (A * D == B * C) {
+    // singular matrix
+    return PR_FALSE;
+  }
+
+  float scaleX = sqrt(A * A + B * B);
+  A /= scaleX;
+  B /= scaleX;
+
+  float XYshear = A * C + B * D;
+  C -= A * XYshear;
+  D -= B * XYshear;
+
+  float scaleY = sqrt(C * C + D * D);
+  C /= scaleY;
+  D /= scaleY;
+  XYshear /= scaleY;
+
+ // A*D - B*C should now be 1 or -1
+  NS_ASSERTION(0.99 < PR_ABS(A*D - B*C) && PR_ABS(A*D - B*C) < 1.01,
+               "determinant should now be 1 or -1");
+  if (A * D < B * C) {
+    A = -A;
+    B = -B;
+    C = -C;
+    D = -D;
+    XYshear = -XYshear;
+    scaleX = -scaleX;
+  }
+
+  float rotation = atan2f(B, A);
+
+  aRotate = rotation;
+  aXYShear = XYshear;
+  aScaleX = scaleX;
+  aScaleY = scaleY;
+
+  return PR_TRUE;
+}
+
+static nsCSSValueList*
+AddTransformMatrix(const nsStyleTransformMatrix &aMatrix1, double aCoeff1,
+                   const nsStyleTransformMatrix &aMatrix2, double aCoeff2)
+{
+
+  nsAutoPtr<nsCSSValueList> result;
+  nsCSSValueList **resultTail = getter_Transfers(result);
+  nsRefPtr<nsCSSValue::Array> arr;
+
+  // The translation part of the matrix comes first in our result list,
+  // but it's complicated by the mix of %s, possibly in between rotates.
+
+  // append a rotate(90deg)
+  arr = AppendTransformFunction(eCSSKeyword_rotate, resultTail);
+  arr->Item(1).SetFloatValue(90.0f, eCSSUnit_Degree);
+
+  // append the translation for parts of the % translation components
+  // that were from inside a rotation
+  float rtranslateXPercent =
+    aMatrix1.GetWidthRelativeYTranslation() * aCoeff1 +
+    aMatrix2.GetWidthRelativeYTranslation() * aCoeff2;
+  float rtranslateYPercent =
+    - (aMatrix1.GetHeightRelativeXTranslation() * aCoeff1 +
+       aMatrix2.GetHeightRelativeXTranslation() * aCoeff2);
+  arr = AppendTransformFunction(eCSSKeyword_translate, resultTail);
+  arr->Item(1).SetPercentValue(rtranslateXPercent);
+  arr->Item(2).SetPercentValue(rtranslateYPercent);
+
+  // append a rotate(-90deg)
+  arr = AppendTransformFunction(eCSSKeyword_rotate, resultTail);
+  arr->Item(1).SetFloatValue(-90.0f, eCSSUnit_Degree);
+
+  nscoord translateXCoord = NSToCoordRound(
+                              aMatrix1.GetCoordXTranslation() * aCoeff1 +
+                              aMatrix2.GetCoordXTranslation() * aCoeff2);
+  nscoord translateYCoord = NSToCoordRound(
+                              aMatrix1.GetCoordYTranslation() * aCoeff1 +
+                              aMatrix2.GetCoordYTranslation() * aCoeff2);
+  float translateXPercent = aMatrix1.GetWidthRelativeXTranslation() * aCoeff1 +
+                            aMatrix2.GetWidthRelativeXTranslation() * aCoeff2;
+  float translateYPercent = aMatrix1.GetHeightRelativeYTranslation() * aCoeff1 +
+                            aMatrix2.GetHeightRelativeYTranslation() * aCoeff2;
+
+  float rotate1, XYshear1, scaleX1, scaleY1;
+  DecomposeMatrix(aMatrix1, rotate1, XYshear1, scaleX1, scaleY1);
+  float rotate2, XYshear2, scaleX2, scaleY2;
+  DecomposeMatrix(aMatrix2, rotate2, XYshear2, scaleX2, scaleY2);
+
+  float rotate = rotate1 * aCoeff1 + rotate2 * aCoeff2;
+
+  // FIXME: The spec still says skew should animate in angle space,
+  // although I think we at least sort of agreed that it should animate
+  // in tangent space.  So here I animate in in tangent space.
+  float skewX = atanf(XYshear1 * aCoeff1 + XYshear2 * aCoeff2);
+
+  // Handle scale, and the two matrix components where identity is 1, by
+  // subtracting 1, multiplying by the coefficients, and then adding 1
+  // back.  This gets the right AddWeighted behavior and gets us the
+  // interpolation-against-identity behavior for free.
+  float scaleX =
+    ((scaleX1 - 1.0f) * aCoeff1 + (scaleX2 - 1.0f) * aCoeff2) + 1.0f;
+  float scaleY =
+    ((scaleY1 - 1.0f) * aCoeff1 + (scaleY2 - 1.0f) * aCoeff2) + 1.0f;
+
+  // It's simpler to append an additional function for the percentage
+  // translate parts than to build a calc() expression.
+  arr = AppendTransformFunction(eCSSKeyword_translate, resultTail);
+  arr->Item(1).SetPercentValue(translateXPercent);
+  arr->Item(2).SetPercentValue(translateYPercent);
+
+  arr = AppendTransformFunction(eCSSKeyword_translate, resultTail);
+  arr->Item(1).SetFloatValue(
+    nsPresContext::AppUnitsToFloatCSSPixels(translateXCoord), eCSSUnit_Pixel);
+  arr->Item(2).SetFloatValue(
+    nsPresContext::AppUnitsToFloatCSSPixels(translateYCoord), eCSSUnit_Pixel);
+
+  arr = AppendTransformFunction(eCSSKeyword_rotate, resultTail);
+  arr->Item(1).SetFloatValue(rotate, eCSSUnit_Radian);
+
+  arr = AppendTransformFunction(eCSSKeyword_skewx, resultTail);
+  arr->Item(1).SetFloatValue(skewX, eCSSUnit_Radian);
+
+  arr = AppendTransformFunction(eCSSKeyword_scale, resultTail);
+  arr->Item(1).SetFloatValue(scaleX, eCSSUnit_Number);
+  arr->Item(2).SetFloatValue(scaleY, eCSSUnit_Number);
+
+  return result.forget();
+}
+
+static nsCSSValueList*
+AddTransformLists(const nsCSSValueList* aList1, double aCoeff1,
+                  const nsCSSValueList* aList2, double aCoeff2)
+{
+  nsAutoPtr<nsCSSValueList> result;
+  nsCSSValueList **resultTail = getter_Transfers(result);
+
+  do {
+    const nsCSSValue::Array *a1 = aList1->mValue.GetArrayValue(),
+                            *a2 = aList2->mValue.GetArrayValue();
+    NS_ABORT_IF_FALSE(nsStyleTransformMatrix::TransformFunctionOf(a1) ==
+                      nsStyleTransformMatrix::TransformFunctionOf(a2),
+                      "transform function mismatch");
+
+    nsCSSKeyword tfunc = nsStyleTransformMatrix::TransformFunctionOf(a1);
+    nsRefPtr<nsCSSValue::Array> arr;
+    if (tfunc != eCSSKeyword_matrix) {
+      arr = AppendTransformFunction(tfunc, resultTail);
+    }
+
+    switch (tfunc) {
+      case eCSSKeyword_translate: {
+        NS_ABORT_IF_FALSE(a1->Count() == 2 || a1->Count() == 3,
+                          "unexpected count");
+        NS_ABORT_IF_FALSE(a2->Count() == 2 || a2->Count() == 3,
+                          "unexpected count");
+
+        // FIXME: This would produce fewer calc() expressions if the
+        // zero were of compatible type (length vs. percent) when
+        // needed.
+        nsCSSValue zero(0.0f, eCSSUnit_Pixel);
+        // Add Y component of translation.
+        AddTransformTranslate(a1->Count() == 3 ? a1->Item(2) : zero,
+                              aCoeff1,
+                              a2->Count() == 3 ? a2->Item(2) : zero,
+                              aCoeff2,
+                              arr->Item(2));
+
+        // Add X component of translation (which can be merged with case
+        // below in non-DEBUG).
+        AddTransformTranslate(a1->Item(1), aCoeff1, a2->Item(1), aCoeff2,
+                              arr->Item(1));
+        break;
+      }
+      case eCSSKeyword_translatex:
+      case eCSSKeyword_translatey: {
+        NS_ABORT_IF_FALSE(a1->Count() == 2, "unexpected count");
+        NS_ABORT_IF_FALSE(a2->Count() == 2, "unexpected count");
+        AddTransformTranslate(a1->Item(1), aCoeff1, a2->Item(1), aCoeff2,
+                              arr->Item(1));
+        break;
+      }
+      case eCSSKeyword_scale: {
+        NS_ABORT_IF_FALSE(a1->Count() == 2 || a1->Count() == 3,
+                          "unexpected count");
+        NS_ABORT_IF_FALSE(a2->Count() == 2 || a2->Count() == 3,
+                          "unexpected count");
+
+        // This is different from skew() and translate(), since an
+        // omitted second parameter repeats the first rather than being
+        // zero.
+        // Add Y component of scale.
+        AddTransformScale(a1->Count() == 3 ? a1->Item(2) : a1->Item(1),
+                          aCoeff1,
+                          a2->Count() == 3 ? a2->Item(2) : a2->Item(1),
+                          aCoeff2,
+                          arr->Item(2));
+
+        // Add X component of scale (which can be merged with case below
+        // in non-DEBUG).
+        AddTransformScale(a1->Item(1), aCoeff1, a2->Item(1), aCoeff2,
+                          arr->Item(1));
+
+        break;
+      }
+      case eCSSKeyword_scalex:
+      case eCSSKeyword_scaley: {
+        NS_ABORT_IF_FALSE(a1->Count() == 2, "unexpected count");
+        NS_ABORT_IF_FALSE(a2->Count() == 2, "unexpected count");
+
+        AddTransformScale(a1->Item(1), aCoeff1, a2->Item(1), aCoeff2,
+                          arr->Item(1));
+
+        break;
+      }
+      case eCSSKeyword_skew: {
+        NS_ABORT_IF_FALSE(a1->Count() == 2 || a1->Count() == 3,
+                          "unexpected count");
+        NS_ABORT_IF_FALSE(a2->Count() == 2 || a2->Count() == 3,
+                          "unexpected count");
+
+        nsCSSValue zero(0.0f, eCSSUnit_Radian);
+        // Add Y component of skew.
+        AddTransformSkew(a1->Count() == 3 ? a1->Item(2) : zero,
+                         aCoeff1,
+                         a2->Count() == 3 ? a2->Item(2) : zero,
+                         aCoeff2,
+                         arr->Item(2));
+
+        // Add X component of skew (which can be merged with case below
+        // in non-DEBUG).
+        AddTransformSkew(a1->Item(1), aCoeff1, a2->Item(1), aCoeff2,
+                         arr->Item(1));
+
+        break;
+      }
+      case eCSSKeyword_skewx:
+      case eCSSKeyword_skewy: {
+        NS_ABORT_IF_FALSE(a1->Count() == 2, "unexpected count");
+        NS_ABORT_IF_FALSE(a2->Count() == 2, "unexpected count");
+
+        AddTransformSkew(a1->Item(1), aCoeff1, a2->Item(1), aCoeff2,
+                         arr->Item(1));
+
+        break;
+      }
+      case eCSSKeyword_rotate: {
+        NS_ABORT_IF_FALSE(a1->Count() == 2, "unexpected count");
+        NS_ABORT_IF_FALSE(a2->Count() == 2, "unexpected count");
+
+        AddCSSValueAngle(a1->Item(1), aCoeff1, a2->Item(1), aCoeff2,
+                         arr->Item(1));
+
+        break;
+      }
+      case eCSSKeyword_matrix: {
+        NS_ABORT_IF_FALSE(a1->Count() == 7, "unexpected count");
+        NS_ABORT_IF_FALSE(a2->Count() == 7, "unexpected count");
+
+        PRBool dummy;
+        nsStyleTransformMatrix matrix1, matrix2;
+        matrix1.SetToTransformFunction(a1, nsnull, nsnull, dummy);
+        matrix2.SetToTransformFunction(a2, nsnull, nsnull, dummy);
+
+        *resultTail =
+          AddTransformMatrix(matrix1, aCoeff1, matrix2, aCoeff2);
+
+        while ((*resultTail)->mNext) {
+          resultTail = &(*resultTail)->mNext;
+        }
+
+        break;
+      }
+      default:
+        NS_ABORT_IF_FALSE(PR_FALSE, "unknown transform function");
+    }
+
+    aList1 = aList1->mNext;
+    aList2 = aList2->mNext;
+  } while (aList1);
+  NS_ABORT_IF_FALSE(!aList2, "list length mismatch");
+
+  return result.forget();
+}
+
 PRBool
 nsStyleAnimation::AddWeighted(nsCSSProperty aProperty,
                               double aCoeff1, const Value& aValue1,
                               double aCoeff2, const Value& aValue2,
                               Value& aResultValue)
 {
   Unit commonUnit = GetCommonUnit(aValue1.GetUnit(), aValue2.GetUnit());
   // Maybe need a followup method to convert the inputs into the common
@@ -687,19 +1275,16 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
       const nsCSSValuePair *pair2 = aValue2.GetCSSValuePairValue();
       if (pair1->mXValue.GetUnit() != pair2->mXValue.GetUnit() ||
           pair1->mYValue.GetUnit() != pair2->mYValue.GetUnit()) {
         // At least until we have calc()
         return PR_FALSE;
       }
 
       nsAutoPtr<nsCSSValuePair> result(new nsCSSValuePair);
-      if (!result) {
-        return PR_FALSE;
-      }
       static nsCSSValue nsCSSValuePair::* const pairValues[] = {
         &nsCSSValuePair::mXValue, &nsCSSValuePair::mYValue
       };
       for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(pairValues); ++i) {
         nsCSSValue nsCSSValuePair::*member = pairValues[i];
         NS_ABORT_IF_FALSE((pair1->*member).GetUnit() ==
                             (pair2->*member).GetUnit(),
                           "should have returned above");
@@ -730,19 +1315,16 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
           rect1->mRight.GetUnit() != rect2->mRight.GetUnit() ||
           rect1->mBottom.GetUnit() != rect2->mBottom.GetUnit() ||
           rect1->mLeft.GetUnit() != rect2->mLeft.GetUnit()) {
         // At least until we have calc()
         return PR_FALSE;
       }
 
       nsAutoPtr<nsCSSRect> result(new nsCSSRect);
-      if (!result) {
-        return PR_FALSE;
-      }
       for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(nsCSSRect::sides); ++i) {
         nsCSSValue nsCSSRect::*member = nsCSSRect::sides[i];
         NS_ABORT_IF_FALSE((rect1->*member).GetUnit() ==
                             (rect2->*member).GetUnit(),
                           "should have returned above");
         switch ((rect1->*member).GetUnit()) {
           case eCSSUnit_Pixel:
             AddCSSValuePixel(aCoeff1, rect1->*member, aCoeff2, rect2->*member,
@@ -872,16 +1454,82 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
           }
 
           longShadow = longShadow->mNext;
         }
       }
       aResultValue.SetAndAdoptCSSValueListValue(result.forget(), eUnit_Shadow);
       break;
     }
+    case eUnit_Transform: {
+      const nsCSSValueList *list1 = aValue1.GetCSSValueListValue();
+      const nsCSSValueList *list2 = aValue2.GetCSSValueListValue();
+
+      // We want to avoid the matrix decomposition when we can, since
+      // avoiding it can produce better results both for compound
+      // transforms and for skew and skewY (see below).  We can do this
+      // in two cases:
+      //   (1) if one of the transforms is 'none'
+      //   (2) if the lists have the same length and the transform
+      //       functions match
+      nsAutoPtr<nsCSSValueList> result;
+      if (list1->mValue.GetUnit() == eCSSUnit_None) {
+        if (list2->mValue.GetUnit() == eCSSUnit_None) {
+          result = new nsCSSValueList;
+          if (result) {
+            result->mValue.SetNoneValue();
+          }
+        } else {
+          result = AddTransformLists(list2, aCoeff2, list2, 0);
+        }
+      } else {
+        if (list2->mValue.GetUnit() == eCSSUnit_None) {
+          result = AddTransformLists(list1, aCoeff1, list1, 0);
+        } else {
+          PRBool match = PR_TRUE;
+
+          {
+            const nsCSSValueList *item1 = list1, *item2 = list2;
+            do {
+              nsCSSKeyword func1 = nsStyleTransformMatrix::TransformFunctionOf(
+                                     item1->mValue.GetArrayValue());
+              nsCSSKeyword func2 = nsStyleTransformMatrix::TransformFunctionOf(
+                                     item2->mValue.GetArrayValue());
+              if (func1 != func2) {
+                break;
+              }
+
+              item1 = item1->mNext;
+              item2 = item2->mNext;
+            } while (item1 && item2);
+            if (item1 || item2) {
+              // Either |break| above or length mismatch.
+              match = PR_FALSE;
+            }
+          }
+
+          if (match) {
+            result = AddTransformLists(list1, aCoeff1, list2, aCoeff2);
+          } else {
+            PRBool dummy;
+            nsStyleTransformMatrix matrix1 =
+              nsStyleTransformMatrix::ReadTransforms(list1, nsnull, nsnull,
+                                                     dummy),
+                                   matrix2 =
+              nsStyleTransformMatrix::ReadTransforms(list2, nsnull, nsnull,
+                                                     dummy);
+            result = AddTransformMatrix(matrix1, aCoeff1, matrix2, aCoeff2);
+          }
+        }
+      }
+
+      aResultValue.SetAndAdoptCSSValueListValue(result.forget(),
+                                                eUnit_Transform);
+      return PR_TRUE;
+    }
     case eUnit_CSSValuePairList: {
       const nsCSSValuePairList *list1 = aValue1.GetCSSValuePairListValue();
       const nsCSSValuePairList *list2 = aValue2.GetCSSValuePairListValue();
       nsAutoPtr<nsCSSValuePairList> result;
       nsCSSValuePairList **resultTail = getter_Transfers(result);
       do {
         nsCSSValuePairList *item = new nsCSSValuePairList;
         if (!item) {
@@ -1178,16 +1826,17 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
     case eUnit_CSSRect:
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
                           eCSSType_Rect, "type mismatch");
       *static_cast<nsCSSRect*>(aSpecifiedValue) =
         *aComputedValue.GetCSSRectValue();
       break;
     case eUnit_Dasharray:
     case eUnit_Shadow:
+    case eUnit_Transform:
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
                           eCSSType_ValueList, "type mismatch");
       *static_cast<nsCSSValueList**>(aSpecifiedValue) =
         aComputedValue.GetCSSValueListValue();
       break;
     case eUnit_CSSValuePairList:
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
                           eCSSType_ValuePairList, "type mismatch");
@@ -1319,16 +1968,46 @@ StyleCoordToCSSValue(const nsStyleCoord&
     case eStyleUnit_Percent:
       aCSSValue.SetPercentValue(aCoord.GetPercentValue());
       break;
     default:
       NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
   }
 }
 
+/*
+ * Assign |aOutput = aInput|, except with any non-pixel lengths
+ * replaced with the equivalent in pixels.
+ */
+static void
+SubstitutePixelValues(nsStyleContext* aStyleContext,
+                      const nsCSSValue& aInput, nsCSSValue& aOutput)
+{
+  if (aInput.UnitHasArrayValue()) {
+    const nsCSSValue::Array *inputArray = aInput.GetArrayValue();
+    nsRefPtr<nsCSSValue::Array> outputArray =
+      nsCSSValue::Array::Create(inputArray->Count());
+    for (size_t i = 0, i_end = inputArray->Count(); i < i_end; ++i) {
+      SubstitutePixelValues(aStyleContext,
+                            inputArray->Item(i), outputArray->Item(i));
+    }
+    aOutput.SetArrayValue(outputArray, aInput.GetUnit());
+  } else if (aInput.IsLengthUnit() &&
+             aInput.GetUnit() != eCSSUnit_Pixel) {
+    PRBool canStoreInRuleTree = PR_TRUE;
+    nscoord len = nsRuleNode::CalcLength(aInput, aStyleContext,
+                                         aStyleContext->PresContext(),
+                                         canStoreInRuleTree);
+    aOutput.SetFloatValue(nsPresContext::AppUnitsToFloatCSSPixels(len),
+                          eCSSUnit_Pixel);
+  } else {
+    aOutput = aInput;
+  }
+}
+
 PRBool
 nsStyleAnimation::ExtractComputedValue(nsCSSProperty aProperty,
                                        nsStyleContext* aStyleContext,
                                        Value& aComputedValue)
 {
   NS_ABORT_IF_FALSE(0 <= aProperty &&
                     aProperty < eCSSProperty_COUNT_no_shorthands,
                     "bad property");
@@ -1533,34 +2212,28 @@ nsStyleAnimation::ExtractComputedValue(n
             static_cast<const nsStyleList*>(styleStruct);
           const nsRect &srect = list->mImageRegion;
           if (srect.IsEmpty()) {
             aComputedValue.SetAutoValue();
             break;
           }
 
           nsCSSRect *vrect = new nsCSSRect;
-          if (!vrect) {
-            return PR_FALSE;
-          }
           nscoordToCSSValue(srect.x, vrect->mLeft);
           nscoordToCSSValue(srect.y, vrect->mTop);
           nscoordToCSSValue(srect.XMost(), vrect->mRight);
           nscoordToCSSValue(srect.YMost(), vrect->mBottom);
           aComputedValue.SetAndAdoptCSSRectValue(vrect, eUnit_CSSRect);
           break;
         }
 
         case eCSSProperty_clip: {
           const nsStyleDisplay *display =
             static_cast<const nsStyleDisplay*>(styleStruct);
           nsCSSRect *vrect = new nsCSSRect;
-          if (!vrect) {
-            return PR_FALSE;
-          }
           if (!(display->mClipFlags & NS_STYLE_CLIP_RECT)) {
             vrect->SetAllSidesTo(nsCSSValue(eCSSUnit_RectIsAuto));
           } else {
             const nsRect &srect = display->mClip;
             if (display->mClipFlags & NS_STYLE_CLIP_TOP_AUTO) {
               vrect->mTop.SetAutoValue();
             } else {
               nscoordToCSSValue(srect.y, vrect->mTop);
@@ -1588,20 +2261,16 @@ nsStyleAnimation::ExtractComputedValue(n
         case eCSSProperty_background_position: {
           const nsStyleBackground *bg =
             static_cast<const nsStyleBackground*>(styleStruct);
           nsCSSValuePairList *result = nsnull;
           nsCSSValuePairList **resultTail = &result;
           NS_ABORT_IF_FALSE(bg->mPositionCount > 0, "unexpected count");
           for (PRUint32 i = 0, i_end = bg->mPositionCount; i != i_end; ++i) {
             nsCSSValuePairList *item = new nsCSSValuePairList;
-            if (!item) {
-              delete result;
-              return PR_FALSE;
-            }
             *resultTail = item;
             resultTail = &item->mNext;
 
             const nsStyleBackground::Position &pos = bg->mLayers[i].mPosition;
             if (pos.mXIsPercent) {
               item->mXValue.SetPercentValue(pos.mXPosition.mFloat);
             } else {
               nscoordToCSSValue(pos.mXPosition.mCoord, item->mXValue);
@@ -1620,20 +2289,16 @@ nsStyleAnimation::ExtractComputedValue(n
         case eCSSProperty_background_size: {
           const nsStyleBackground *bg =
             static_cast<const nsStyleBackground*>(styleStruct);
           nsCSSValuePairList *result = nsnull;
           nsCSSValuePairList **resultTail = &result;
           NS_ABORT_IF_FALSE(bg->mSizeCount > 0, "unexpected count");
           for (PRUint32 i = 0, i_end = bg->mSizeCount; i != i_end; ++i) {
             nsCSSValuePairList *item = new nsCSSValuePairList;
-            if (!item) {
-              delete result;
-              return PR_FALSE;
-            }
             *resultTail = item;
             resultTail = &item->mNext;
 
             const nsStyleBackground::Size &size = bg->mLayers[i].mSize;
             switch (size.mWidthType) {
               case nsStyleBackground::Size::eContain:
               case nsStyleBackground::Size::eCover:
                 item->mXValue.SetIntValue(size.mWidthType,
@@ -1666,16 +2331,41 @@ nsStyleAnimation::ExtractComputedValue(n
                 break;
             }
           }
 
           aComputedValue.SetAndAdoptCSSValuePairListValue(result);
           break;
         }
 
+        case eCSSProperty__moz_transform: {
+          const nsStyleDisplay *display =
+            static_cast<const nsStyleDisplay*>(styleStruct);
+          nsAutoPtr<nsCSSValueList> result;
+          if (display->mSpecifiedTransform) {
+            // Clone, and convert all lengths (not percents) to pixels.
+            nsCSSValueList **resultTail = getter_Transfers(result);
+            for (const nsCSSValueList *l = display->mSpecifiedTransform;
+                 l; l = l->mNext) {
+              nsCSSValueList *clone = new nsCSSValueList;
+              *resultTail = clone;
+              resultTail = &clone->mNext;
+
+              SubstitutePixelValues(aStyleContext, l->mValue, clone->mValue);
+            }
+          } else {
+            result = new nsCSSValueList();
+            result->mValue.SetNoneValue();
+          }
+
+          aComputedValue.SetAndAdoptCSSValueListValue(result.forget(),
+                                                      eUnit_Transform);
+          break;
+        }
+
         default:
           NS_ABORT_IF_FALSE(PR_FALSE, "missing property implementation");
           return PR_FALSE;
       };
       return PR_TRUE;
     case eStyleAnimType_Coord:
       return StyleCoordToValue(*static_cast<const nsStyleCoord*>(
         StyleDataAtOffset(styleStruct, ssOffset)), aComputedValue);
@@ -1880,18 +2570,19 @@ nsStyleAnimation::Value::operator=(const
       NS_ABORT_IF_FALSE(aOther.mValue.mCSSRect, "rects may not be null");
       mValue.mCSSRect = new nsCSSRect(*aOther.mValue.mCSSRect);
       if (!mValue.mCSSRect) {
         mUnit = eUnit_Null;
       }
       break;
     case eUnit_Dasharray:
     case eUnit_Shadow:
-      NS_ABORT_IF_FALSE(mUnit != eUnit_Dasharray || aOther.mValue.mCSSValueList,
-                        "dasharrays may not be null");
+    case eUnit_Transform:
+      NS_ABORT_IF_FALSE(mUnit == eUnit_Shadow || aOther.mValue.mCSSValueList,
+                        "value lists other than shadows may not be null");
       if (aOther.mValue.mCSSValueList) {
         mValue.mCSSValueList = aOther.mValue.mCSSValueList->Clone();
         if (!mValue.mCSSValueList) {
           mUnit = eUnit_Null;
         }
       } else {
         mValue.mCSSValueList = nsnull;
       }
@@ -2074,16 +2765,17 @@ nsStyleAnimation::Value::operator==(cons
     case eUnit_Color:
       return mValue.mColor == aOther.mValue.mColor;
     case eUnit_CSSValuePair:
       return *mValue.mCSSValuePair == *aOther.mValue.mCSSValuePair;
     case eUnit_CSSRect:
       return *mValue.mCSSRect == *aOther.mValue.mCSSRect;
     case eUnit_Dasharray:
     case eUnit_Shadow:
+    case eUnit_Transform:
       return nsCSSValueList::Equal(mValue.mCSSValueList,
                                    aOther.mValue.mCSSValueList);
     case eUnit_CSSValuePairList:
       return nsCSSValuePairList::Equal(mValue.mCSSValuePairList,
                                        aOther.mValue.mCSSValuePairList);
     case eUnit_UnparsedString:
       return (NS_strcmp(GetStringBufferValue(),
                         aOther.GetStringBufferValue()) == 0);
diff --git a/layout/style/nsStyleAnimation.h b/layout/style/nsStyleAnimation.h
--- a/layout/style/nsStyleAnimation.h
+++ b/layout/style/nsStyleAnimation.h
@@ -233,16 +233,17 @@ public:
     eUnit_Coord,
     eUnit_Percent,
     eUnit_Float,
     eUnit_Color,
     eUnit_CSSValuePair, // nsCSSValuePair* (never null)
     eUnit_CSSRect, // nsCSSRect* (never null)
     eUnit_Dasharray, // nsCSSValueList* (never null)
     eUnit_Shadow, // nsCSSValueList* (may be null)
+    eUnit_Transform, // nsCSSValueList* (never null)
     eUnit_CSSValuePairList, // nsCSSValuePairList* (never null)
     eUnit_UnparsedString // nsStringBuffer* (never null)
   };
 
   class Value {
   private:
     Unit mUnit;
     union {
@@ -371,17 +372,18 @@ public:
     }
     static PRBool IsCSSValuePairUnit(Unit aUnit) {
       return aUnit == eUnit_CSSValuePair;
     }
     static PRBool IsCSSRectUnit(Unit aUnit) {
       return aUnit == eUnit_CSSRect;
     }
     static PRBool IsCSSValueListUnit(Unit aUnit) {
-      return aUnit == eUnit_Dasharray || aUnit == eUnit_Shadow;
+      return aUnit == eUnit_Dasharray || aUnit == eUnit_Shadow ||
+             aUnit == eUnit_Transform;
     }
     static PRBool IsCSSValuePairListUnit(Unit aUnit) {
       return aUnit == eUnit_CSSValuePairList;
     }
     static PRBool IsStringUnit(Unit aUnit) {
       return aUnit == eUnit_UnparsedString;
     }
   };
diff --git a/layout/style/nsStyleTransformMatrix.cpp b/layout/style/nsStyleTransformMatrix.cpp
--- a/layout/style/nsStyleTransformMatrix.cpp
+++ b/layout/style/nsStyleTransformMatrix.cpp
@@ -212,16 +212,24 @@ nsStyleTransformMatrix::operator *(const
 }
 
 /* Helper function to fill in an nscoord with the specified nsCSSValue. */
 static nscoord CalcLength(const nsCSSValue &aValue,
                           nsStyleContext* aContext,
                           nsPresContext* aPresContext,
                           PRBool &aCanStoreInRuleTree)
 {
+  if (aValue.GetUnit() == eCSSUnit_Pixel) {
+    // Handle this here (even though nsRuleNode::CalcLength handles it
+    // fine) so that callers are allowed to pass a null style context
+    // and pres context to SetToTransformFunction if they know (as
+    // nsStyleAnimation does) that all lengths within the transform
+    // function have already been computed to pixels and percents.
+    return nsPresContext::CSSPixelsToAppUnits(aValue.GetFloatValue());
+  }
   return nsRuleNode::CalcLength(aValue, aContext, aPresContext,
                                 aCanStoreInRuleTree);
 }
 
 /* Helper function to process a matrix entry. */
 static void ProcessMatrix(float aMain[4], nscoord aDelta[2],
                           float aX[2], float aY[2],
                           const nsCSSValue::Array* aData,
@@ -527,38 +535,49 @@ static void ProcessRotate(float aMain[4]
 
   aMain[0] = cosTheta;
   aMain[1] = sinTheta;
   aMain[2] = -sinTheta;
   aMain[3] = cosTheta;
 }
 
 /**
+ * Return the transform function, as an nsCSSKeyword, for the given
+ * nsCSSValue::Array from a transform list.
+ */
+/* static */ nsCSSKeyword
+nsStyleTransformMatrix::TransformFunctionOf(const nsCSSValue::Array* aData)
+{
+  nsAutoString keyword;
+  aData->Item(0).GetStringValue(keyword);
+  return nsCSSKeywords::LookupKeyword(keyword);
+}
+
+/**
  * SetToTransformFunction is essentially a giant switch statement that fans
  * out to many smaller helper functions.
  */
 void
 nsStyleTransformMatrix::SetToTransformFunction(const nsCSSValue::Array * aData,
                                                nsStyleContext* aContext,
                                                nsPresContext* aPresContext,
                                                PRBool& aCanStoreInRuleTree)
 {
   NS_PRECONDITION(aData, "Why did you want to get data from a null array?");
-  NS_PRECONDITION(aContext, "Need a context for unit conversion!");
-  NS_PRECONDITION(aPresContext, "Need a context for unit conversion!");
-  
+  // It's OK if aContext and aPresContext are null if the caller already
+  // knows that all length units have been converted to pixels (as
+  // nsStyleAnimation does).
+
   /* Reset the matrix to the identity so that each subfunction can just
    * worry about its own components.
    */
   SetToIdentity();
 
   /* Get the keyword for the transform. */
-  nsAutoString keyword;
-  aData->Item(0).GetStringValue(keyword);
-  switch (nsCSSKeywords::LookupKeyword(keyword)) {
+  switch (TransformFunctionOf(aData)) {
   case eCSSKeyword_translatex:
     ProcessTranslateX(mDelta, mX, aData, aContext, aPresContext,
                       aCanStoreInRuleTree);
     break;
   case eCSSKeyword_translatey:
     ProcessTranslateY(mDelta, mY, aData, aContext, aPresContext,
                       aCanStoreInRuleTree);
     break;
diff --git a/layout/style/nsStyleTransformMatrix.h b/layout/style/nsStyleTransformMatrix.h
--- a/layout/style/nsStyleTransformMatrix.h
+++ b/layout/style/nsStyleTransformMatrix.h
@@ -103,24 +103,34 @@ class nsStyleTransformMatrix
    * @param aOther The matrix to multiply this matrix by.
    * @return A new nsStyleTransformMatrix equal to this matrix multiplied
    *         by the other matrix.
    */
   const nsStyleTransformMatrix
     operator * (const nsStyleTransformMatrix &aOther) const;
 
   /**
+   * Return the transform function, as an nsCSSKeyword, for the given
+   * nsCSSValue::Array from a transform list.
+   */
+  static nsCSSKeyword TransformFunctionOf(const nsCSSValue::Array* aData);
+
+  /**
    * Given an nsCSSValue::Array* containing a -moz-transform function,
    * updates this matrix to hold the value of that function.
    *
    * @param aData The nsCSSValue::Array* containing the transform function.
    * @param aContext The style context, used for unit conversion.
    * @param aPresContext The presentation context, used for unit conversion.
    * @param aCanStoreInRuleTree Set to false if the result cannot be cached
    *                            in the rule tree, otherwise untouched.
+   *
+   * aContext and aPresContext may be null if all of the (non-percent)
+   * length values in aData are already known to have been converted to
+   * eCSSUnit_Pixel (as they are in an nsStyleAnimation::Value)
    */
   void SetToTransformFunction(const nsCSSValue::Array* aData,
                               nsStyleContext* aContext,
                               nsPresContext* aPresContext,
                               PRBool& aCanStoreInRuleTree);
 
   /**
    * The same as SetToTransformFunction, but for a list of transform
@@ -157,16 +167,26 @@ class nsStyleTransformMatrix
    *
    * @param aBounds The bounds of the element.
    * @return The value of the X or Ytranslation component.
    */
   nscoord GetXTranslation(const nsRect& aBounds) const;
   nscoord GetYTranslation(const nsRect& aBounds) const;
 
   /**
+   * Get the raw components used for GetXTranslation and GetYTranslation.
+   */
+  nscoord GetCoordXTranslation() const { return mDelta[0]; }
+  nscoord GetCoordYTranslation() const { return mDelta[1]; }
+  float GetWidthRelativeXTranslation() const { return mX[0]; }
+  float GetWidthRelativeYTranslation() const { return mX[1]; }
+  float GetHeightRelativeXTranslation() const { return mY[0]; }
+  float GetHeightRelativeYTranslation() const { return mY[1]; }
+
+  /**
    * Returns whether the two matrices are equal or not.
    *
    * @param aOther The matrix to compare to.
    * @return Whether the two matrices are equal.
    */
   PRBool operator== (const nsStyleTransformMatrix& aOther) const;
   PRBool operator!= (const nsStyleTransformMatrix& aOther) const
   {
diff --git a/layout/style/test/property_database.js b/layout/style/test/property_database.js
--- a/layout/style/test/property_database.js
+++ b/layout/style/test/property_database.js
@@ -681,16 +681,17 @@ var gCSSProperties = {
 		initial_values: [ "8" ],
 		other_values: [ "0", "3", "99", "12000" ],
 		invalid_values: [ "-1", "-808", "3.0", "17.5" ]
 	},
 	"-moz-transform": {
 		domProp: "MozTransform",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
+		prerequisites: { "width": "300px", "height": "50px" },
 		initial_values: [ "none" ],
 		other_values: [ "translatex(1px)", "translatex(4em)", "translatex(-4px)", "translatex(3px)", "translatex(0px) translatex(1px) translatex(2px) translatex(3px) translatex(4px)", "translatey(4em)", "translate(3px)", "translate(10px, -3px)", "rotate(45deg)", "rotate(45grad)", "rotate(45rad)", "rotate(0)", "scalex(10)", "scaley(10)", "scale(10)", "scale(10, 20)", "skewx(30deg)", "skewx(0)", "skewy(0)", "skewx(30grad)", "skewx(30rad)", "skewy(30deg)", "skewy(30grad)", "skewy(30rad)", "matrix(1, 2, 3, 4, 5px, 6em)", "rotate(45deg) scale(2, 1)", "skewx(45deg) skewx(-50grad)", "translate(0, 0) scale(1, 1) skewx(0) skewy(0) matrix(1, 0, 0, 1, 0, 0)", "translatex(50%)", "translatey(50%)", "translate(50%)", "translate(3%, 5px)", "translate(5px, 3%)", "matrix(1, 2, 3, 4, 5px, 6%)", "matrix(1, 2, 3, 4, 5%, 6px)", "matrix(1, 2, 3, 4, 5%, 6%)",
 			/* valid calc() values */
 			"translatex(-moz-calc(5px + 10%))",
 			"translatey(-moz-calc(0.25 * 5px + 10% / 3))",
 			"translate(-moz-calc(5px - 10% * 3))",
 			"translate(-moz-calc(5px - 3 * 10%), 50px)",
 			"translate(-50px, -moz-calc(5px - 10% * 3))",
diff --git a/layout/style/test/test_transitions_per_property.html b/layout/style/test/test_transitions_per_property.html
--- a/layout/style/test/test_transitions_per_property.html
+++ b/layout/style/test/test_transitions_per_property.html
@@ -63,16 +63,17 @@ var supported_properties = {
                                 test_border_color_transition ],
     "-moz-column-rule-width": [ test_length_transition ],
     "-moz-column-width": [ test_length_transition ],
     "-moz-image-region": [ test_rect_transition ],
     "-moz-outline-radius-bottomleft": [ test_radius_transition ],
     "-moz-outline-radius-bottomright": [ test_radius_transition ],
     "-moz-outline-radius-topleft": [ test_radius_transition ],
     "-moz-outline-radius-topright": [ test_radius_transition ],
+    "-moz-transform": [ test_transform_transition ],
     "-moz-transform-origin": [ test_length_pair_transition,
                                test_length_percent_pair_transition ],
     "background-color": [ test_color_transition ],
     "background-position": [ test_background_position_transition ],
     "background-size": [ test_background_size_transition ],
     "border-bottom-color": [ test_color_transition,
                              test_border_color_transition ],
     "border-bottom-width": [ test_length_transition ],
@@ -641,12 +642,265 @@ function test_background_position_size_c
   div.style.setProperty(prop, "10px 40%, 50% 50px, 30% 20%", "");
   is(cs.getPropertyValue(prop), "10px 40%, 50% 50px, 30% 20%",
      "property " + prop + ": computed value before transition");
   div.style.setProperty(prop, "50px 20%, 70% 50px, 30% 40%", "");
   is(cs.getPropertyValue(prop), "20px 35%, 55% 50px, 30% 25%",
      "property " + prop + ": interpolation of lists of lengths and percents");
 }
 
+function test_transform_transition(prop) {
+  function c(v) {
+    div.style.setProperty(prop, v, "");
+    var result = cs.getPropertyValue(prop);
+    div.style.removeProperty(prop);
+    return result;
+  }
+  var c_rot_15 = c("rotate(15deg)");
+  is(c_rot_15.substring(0,6), "matrix", "should compute to matrix value");
+  var c_rot_60 = c("rotate(60deg)");
+  is(c_rot_60.substring(0,6), "matrix", "should compute to matrix value");
+
+  var tests = [
+    // rotate
+    { start: 'none', end: 'rotate(60deg)',
+      expected: c_rot_15 },
+    { start: 'rotate(0)', end: 'rotate(60deg)',
+      expected: c_rot_15 },
+    { start: 'rotate(0deg)', end: 'rotate(60deg)',
+      expected: c_rot_15 },
+    { start: 'none', end: c_rot_60,
+      expected: c_rot_15 },
+    { start: 'none', end: 'rotate(360deg)', expected: c('rotate(90deg)') },
+    { start: 'none', end: 'rotate(720deg)', expected: c('rotate(180deg)') },
+    { start: 'none', end: 'rotate(1080deg)', expected: c('rotate(270deg)') },
+    { start: 'none', end: 'rotate(1440deg)', expected: c('scale(1)'),
+      round_error_ok: true },
+
+    // translate
+    { start: 'translate(20px)', end: 'none',
+      expected: 'matrix(1, 0, 0, 1, 15px, 0px)' },
+    { start: 'translate(20px, 12px)', end: 'none',
+      expected: 'matrix(1, 0, 0, 1, 15px, 9px)' },
+    { start: 'translateX(-20px)', end: 'none',
+      expected: 'matrix(1, 0, 0, 1, -15px, 0px)' },
+    { start: 'translateY(-40px)', end: 'none',
+      expected: 'matrix(1, 0, 0, 1, 0px, -30px)' },
+    // percentages are relative to 300px (width) and 50px (height)
+    // per the prerequisites in property_database.js
+    { start: 'translate(20%)', end: 'none',
+      expected: 'matrix(1, 0, 0, 1, 45px, 0px)' },
+    { start: 'translate(20%, 12%)', end: 'none',
+      expected: 'matrix(1, 0, 0, 1, 45px, 4.5px)' },
+    { start: 'translateX(-20%)', end: 'none',
+      expected: 'matrix(1, 0, 0, 1, -45px, 0px)' },
+    { start: 'translateY(-40%)', end: 'none',
+      expected: 'matrix(1, 0, 0, 1, 0px, -15px)' },
+    { start: 'none', end: 'rotate(90deg) translate(20%, 20%) rotate(-90deg)',
+      expected: c('rotate(22.5deg) translate(5%, 5%) rotate(-22.5deg)') },
+    { start: 'none', end: 'rotate(-90deg) translate(20%, 20%) rotate(90deg)',
+      expected: c('rotate(-22.5deg) translate(5%, 5%) rotate(22.5deg)') },
+    // test percent translation using matrix decomposition
+    { start: 'rotate(45deg) rotate(-45deg)',
+      end: 'rotate(90deg) translate(20%, 20%) rotate(-90deg)',
+      expected: 'matrix(1, 0, 0, 1, -2.5px, 15px)' },
+    { start: 'rotate(45deg) rotate(-45deg)',
+      end: 'rotate(-90deg) translate(20%, 20%) rotate(90deg)',
+      expected: 'matrix(1, 0, 0, 1, 2.5px, -15px)' },
+    // test calc() in translate
+    // Note that font-size: is 20px, and that percentages are relative
+    // to 300px (width) and 50px (height) per the prerequisites in
+    // property_database.js
+    { start: 'translateX(20%)', /* 60px */
+      end: 'translateX(-moz-calc(10% + 1em))', /* 30px + 20px = 50px */
+      expected: 'matrix(1, 0, 0, 1, 57.5px, 0px)' },
+    { start: 'translate(-moz-calc(0.75 * 3em + 1.5 * 10%), -moz-calc(0.5 * 5em + 0.5 * 8%))', /* 90px, 52px */
+      end: 'rotate(90deg) translateY(20%) rotate(90deg) translateY(-moz-calc(10% + 0.5em)) rotate(180deg)', /* -10px, -15px */
+      expected: 'matrix(1, 0, 0, 1, 65px, 35.25px)' },
+
+    // scale
+    { start: 'scale(2)', end: 'none',
+      expected: 'matrix(1.75, 0, 0, 1.75, 0px, 0px)' },
+    { start: 'none', end: 'scale(0.4)',
+      expected: 'matrix(0.85, 0, 0, 0.85, 0px, 0px)' },
+    { start: 'scale(2)', end: 'scale(-2)',
+      expected: 'matrix(1, 0, 0, 1, 0px, 0px)' },
+    { start: 'scale(2)', end: 'scale(-6)',
+      expected: 'matrix(0, 0, 0, 0, 0px, 0px)' },
+    { start: 'scale(2, 0.4)', end: 'none',
+      expected: 'matrix(1.75, 0, 0, 0.55, 0px, 0px)' },
+    { start: 'scaleX(3)', end: 'none',
+      expected: 'matrix(2.5, 0, 0, 1, 0px, 0px)' },
+    { start: 'scaleY(5)', end: 'none',
+      expected: 'matrix(1, 0, 0, 4, 0px, 0px)' },
+
+    // skew
+    { start: 'skewX(45deg)', end: 'none',
+      expected: 'matrix(1, 0, 0.75, 1, 0px, 0px)' },
+    { start: 'skewY(45deg)', end: 'none',
+      expected: 'matrix(1, 0.75, 0, 1, 0px, 0px)' },
+    { start: 'skew(45deg)', end: 'none',
+      expected: 'matrix(1, 0, 0.75, 1, 0px, 0px)' },
+    { start: 'skew(45deg, 45deg)', end: 'none',
+      expected: 'matrix(1, 0.75, 0.75, 1, 0px, 0px)' },
+    { start: 'skewX(45deg)', end: 'skewX(-45deg)',
+      expected: 'matrix(1, 0, 0.5, 1, 0px, 0px)' },
+    { start: 'skewX(0)', end: 'skewX(-45deg)',
+      expected: 'matrix(1, 0, -0.25, 1, 0px, 0px)' },
+    { start: 'skewY(45deg)', end: 'skewY(-45deg)',
+      expected: 'matrix(1, 0.5, 0, 1, 0px, 0px)' },
+
+    // matrix : skewX
+    { start: 'matrix(1, 0, 3, 1, 0px, 0px)', end: 'none',
+      expected: 'matrix(1, 0, 2.25, 1, 0px, 0px)' },
+    { start: 'skewX(0)', end: 'skewX(-45deg) translate(0)',
+      expected: 'matrix(1, 0, -0.25, 1, 0px, 0px)' },
+    // matrix : rotate
+    { start: 'rotate(-30deg)', end: 'matrix(0, 1, -1, 0, 0px, 0px)',
+      expected: 'matrix(1, 0, 0, 1, 0px, 0px)' },
+    { start: 'rotate(-30deg) translateX(0)',
+      end: 'translateX(0) rotate(-90deg)',
+      expected: c('rotate(-45deg)') },
+    // matrix decomposition of skewY
+    { start: 'skewY(60deg)', end: 'skewY(-60deg) translateX(0)',
+      expected: c('rotate(30deg) skewX(' + Math.atan(Math.tan(Math.PI / 3) / 2) + 'rad) scale(2, 0.5)') },
+
+    // matrix decomposition
+
+    // Four pairs of the same matrix expressed different ways.
+    { start: 'matrix(-1, 0, 0, -1, 0pt, 0pt)', /* rotate(180deg) */
+      end: 'matrix(1, 0, 0, 1, 0, 0)',
+      expected: c('rotate(135deg)') },
+    { start: 'scale(-1)', end: 'none',
+      expected: 'matrix(-0.5, 0, 0, -0.5, 0px, 0px)' },
+    { start: 'rotate(180deg)', end: 'none',
+      expected: c('rotate(135deg)') },
+    { start: 'rotate(-180deg)', end: 'none',
+      expected: c('rotate(225deg)') },
+
+    // ... and a bunch of similar possibilities.  The spec isn't settled
+    // here; there are multiple options.  See:
+    // http://lists.w3.org/Archives/Public/www-style/2010Jun/0602.html
+    { start: 'matrix(-1, 0, 0, 1, 0pt, 0pt)', /* scaleX(-1) */
+      end: 'matrix(1, 0, 0, 1, 0, 0)',
+      expected: c('scaleX(-0.5)') },
+
+    { start: 'matrix(1, 0, 0, -1, 0pt, 0pt)', /* rotate(-180deg) scaleX(-1) */
+      end: 'matrix(1, 0, 0, 1, 0, 0)',
+      expected: c('rotate(-135deg) scaleX(-0.5)') },
+
+    { start: 'matrix(0, 1, 1, 0, 0pt, 0pt)', /* rotate(-90deg) scaleX(-1) */
+      end: 'matrix(1, 0, 0, 1, 0, 0)',
+      expected: c('rotate(-67.5deg) scaleX(-0.5)') },
+
+    { start: 'matrix(0, -1, 1, 0, 0pt, 0pt)', /* rotate(-90deg) */
+      end: 'matrix(1, 0, 0, 1, 0, 0)',
+      expected: c('rotate(-67.5deg)') },
+
+    { start: 'matrix(0, 1, -1, 0, 0pt, 0pt)', /* rotate(90deg) */
+      end: 'matrix(1, 0, 0, 1, 0, 0)',
+      expected: c('rotate(67.5deg)') },
+
+    { start: 'matrix(0, -1, -1, 0, 0pt, 0pt)', /* rotate(90deg) scaleX(-1) */
+      end: 'matrix(1, 0, 0, 1, 0, 0)',
+      expected: c('rotate(67.5deg) scaleX(-0.5)') },
+
+    // Similar decomposition tests, but with skewX.  I checked visually
+    // that the sign of the skew was correct by checking visually that
+    // the animations in
+    // http://dbaron.org/css/test/2010/transition-negative-determinant
+    // don't flip when they finish, and then wrote tests corresponding
+    // to the current code's behavior.
+    // ... start with four with positive determinants
+    { start: 'none',
+      end: 'matrix(1, 0, 1.5, 1, 0pt, 0pt)',
+              /* skewX(atan(1.5)) */
+      expected: c('matrix(1, 0, 0.375, 1, 0, 0)') },
+    { start: 'none',
+      end: 'matrix(-1, 0, 2, -1, 0pt, 0pt)',
+              /* rotate(180deg) skewX(atan(-2)) */
+      expected: c('rotate(45deg) matrix(1, 0, -0.5, 1, 0, 0)') },
+    { start: 'none',
+      end: 'matrix(0, -1, 1, -3, 0pt, 0pt)',
+              /* rotate(-90deg) skewX(atan(3)) */
+      expected: c('rotate(-22.5deg) matrix(1, 0, 0.75, 1, 0, 0)') },
+    { start: 'none',
+      end: 'matrix(0, 1, -1, 4, 0pt, 0pt)',
+              /* rotate(90deg) skewX(atan(4)) */
+      expected: c('rotate(22.5deg) matrix(1, 0, 1, 1, 0, 0)') },
+    // and then four with negative determinants
+    { start: 'none',
+      end: 'matrix(1, 0, 1, -1, 0pt, 0pt)',
+              /* rotate(-180deg) skewX(atan(-1)) scaleX(-1) */
+      expected: c('rotate(-45deg) matrix(1, 0, -0.25, 1, 0, 0) scaleX(0.5)'),
+      round_error_ok: true },
+    { start: 'none',
+      end: 'matrix(-1, 0, -1, 1, 0pt, 0pt)',
+              /* skewX(atan(-1)) scaleX(-1) */
+      expected: c('matrix(1, 0, -0.25, 1, 0, 0) scaleX(0.5)') },
+    { start: 'none',
+      end: 'matrix(0, 1, 1, -2, 0pt, 0pt)',
+              /* rotate(-90deg) skewX(atan(2)) scaleX(-1) */
+      expected: c('rotate(-22.5deg) matrix(1, 0, 0.5, 1, 0, 0) scaleX(0.5)') },
+    { start: 'none',
+      end: 'matrix(0, -1, -1, 0.5, 0pt, 0pt)',
+              /* rotate(90deg) skewX(atan(0.5)) scaleX(-1) */
+      expected: c('rotate(22.5deg) matrix(1, 0, 0.125, 1, 0, 0) scaleX(0.5)') },
+
+    // lists vs. matrix decomposition
+    { start: 'translate(10px) skewY(45deg)',
+      end: 'translate(30px) skewY(-45deg)',
+      expected: 'matrix(1, 0.5, 0, 1, 15px, 0px)' },
+    { start: 'skewY(45deg) rotate(90deg)',
+      end: 'skewY(-45deg) rotate(90deg)',
+      expected: c('matrix(1, 0.5, 0, 1, 0px, 0px) rotate(90deg)') },
+    { start: 'skewY(45deg) rotate(90deg) translate(0)',
+      end: 'skewY(-45deg) rotate(90deg)',
+      expected: c('matrix(1, 0.5, 0, 1, 0px, 0px) rotate(90deg)') },
+    { start: 'skewX(45deg) rotate(90deg)',
+      end: 'skewX(-45deg) rotate(90deg)',
+      expected: c('matrix(1, 0, 0.5, 1, 0px, 0px) rotate(90deg)') },
+    { start: 'skewX(-60deg) rotate(90deg) translate(0)',
+      end: 'skewX(60deg) rotate(90deg)',
+      expected: c('rotate(120deg) skewX(' +
+                   Math.atan(Math.tan(Math.PI / 3) / 2) +
+                  'rad) scale(2, 0.5)') },
+  ];
+
+  for (var i in tests) {
+    var test = tests[i];
+    div.style.setProperty("-moz-transition-property", "none", "");
+    div.style.setProperty(prop, test.start, "");
+    cs.getPropertyValue(prop);
+    div.style.setProperty("-moz-transition-property", prop, "");
+    div.style.setProperty(prop, test.end, "");
+    var actual = cs.getPropertyValue(prop);
+    if (!test.round_error_ok || actual == test.expected) {
+      // In most cases, we'll get an exact match, but in some cases
+      // there can be a small amount of rounding error.
+      is(actual, test.expected,
+         "interpolation of transitions: " + test.start + " to " + test.end);
+    } else {
+      function s(mat) {
+        return mat.match(/^matrix\(([^,]*), ([^,]*), ([^,]*), ([^,]*), ([^,]*)px, ([^,]*)px\)$/).slice(1,7);
+      }
+      var pass = true;
+      var actual_split = s(actual);
+      var expected_split = s(test.expected);
+      for (var i = 0; i < 6; ++i) {
+        // Allow differences of 1 at the sixth decimal place, and allow
+        // a drop extra for floating point error from the subtraction.
+        if (Math.abs(Number(actual_split[i]) - Number(expected_split[i])) >
+              0.0000011) {
+          pass = false;
+        }
+      }
+      ok(pass,
+         "interpolation of transitions: " + test.start + " to " + test.end +
+         ": " + actual + " should approximately equal " + test.expected);
+    }
+  }
+}
+
 </script>
 </pre>
 </body>
 </html>
