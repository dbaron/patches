From: L. David Baron <dbaron@dbaron.org>

Merge InitFloat into AddFloat (on nsLineLayout and nsBlockReflowState).  (Bug 25888)

diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -516,51 +516,37 @@ nsBlockReflowState::RecoverStateFrom(nsL
       mFloatManager->List(stdout);
     }
 #endif
     // And then put the translation back again
     mFloatManager->Translate(bp.left, bp.top);
   }
 }
 
-PRBool
-nsBlockReflowState::InitFloat(nsLineLayout&       aLineLayout,
-                              nsPlaceholderFrame* aPlaceholder,
-                              nscoord             aAvailableWidth,
-                              nsReflowStatus&     aReflowStatus)
-{
-  // Set the geometric parent of the float
-  nsIFrame* floatFrame = aPlaceholder->GetOutOfFlowFrame();
-  floatFrame->SetParent(mBlock);
-
-  // Then add the float to the current line and place it when
-  // appropriate
-  return AddFloat(aLineLayout, aPlaceholder, PR_TRUE,
-                  aAvailableWidth, aReflowStatus);
-}
-
 // This is called by the line layout's AddFloat method when a
 // place-holder frame is reflowed in a line. If the float is a
 // left-most child (it's x coordinate is at the line's left margin)
 // then the float is place immediately, otherwise the float
 // placement is deferred until the line has been reflowed.
 
 // XXXldb This behavior doesn't quite fit with CSS1 and CSS2 --
 // technically we're supposed let the current line flow around the
 // float as well unless it won't fit next to what we already have.
 // But nobody else implements it that way...
 PRBool
 nsBlockReflowState::AddFloat(nsLineLayout&       aLineLayout,
                              nsPlaceholderFrame* aPlaceholder,
-                             PRBool              aInitialReflow,
                              nscoord             aAvailableWidth,
                              nsReflowStatus&     aReflowStatus)
 {
   NS_PRECONDITION(mBlock->end_lines() != mCurrentLine, "null ptr");
 
+  // Set the geometric parent of the float
+  aPlaceholder->GetOutOfFlowFrame()->SetParent(mBlock);
+
   aReflowStatus = NS_FRAME_COMPLETE;
   // Allocate a nsFloatCache for the float
   nsFloatCache* fc = mFloatCacheFreeList.Alloc();
   fc->mPlaceholder = aPlaceholder;
 
   // Because we are in the middle of reflowing a placeholder frame
   // within a line (and possibly nested in an inline frame or two
   // that's a child of our block) we need to restore the space
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -101,23 +101,18 @@ public:
     GetFloatAvailableSpaceWithState(nscoord aY, PRBool aRelaxHeightConstraint,
                                     nsFloatManager::SavedState *aState) const;
 
   /*
    * The following functions all return PR_TRUE if they were able to
    * place the float, PR_FALSE if the float did not fit in available
    * space.
    */
-  PRBool InitFloat(nsLineLayout&       aLineLayout,
-                   nsPlaceholderFrame* aPlaceholderFrame,
-                   nscoord             aAvailableWidth,
-                   nsReflowStatus&     aReflowStatus);
   PRBool AddFloat(nsLineLayout&       aLineLayout,
                   nsPlaceholderFrame* aPlaceholderFrame,
-                  PRBool              aInitialReflow,
                   nscoord             aAvailableWidth,
                   nsReflowStatus&     aReflowStatus);
   PRBool CanPlaceFloat(const nsSize& aFloatSize, PRUint8 aFloats,
                        const nsFlowAreaRect& aFloatAvailableSpace,
                        PRBool aForceFit);
   PRBool FlowAndPlaceFloat(nsFloatCache*   aFloatCache,
                            PRBool*         aIsLeftFloat,
                            nsReflowStatus& aReflowStatus,
diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -883,24 +883,17 @@ nsLineLayout::ReflowFrame(nsIFrame* aFra
           // so we can't know whether the float plus that content will fit
           // on the line. So for now, don't place floats after inline
           // content where there's no break opportunity. This is incorrect
           // but hopefully rare. Fixing it will require significant
           // restructuring of line layout.
           // We might as well allow zero-width floats to be placed, though.
           availableWidth = 0;
         }
-        // XXXldb What is this test supposed to be?
-        if (!NS_SUBTREE_DIRTY(aFrame)) {
-          // incremental reflow of child
-          placedFloat = InitFloat(placeholder, availableWidth, aReflowStatus);
-        }
-        else {
-          placedFloat = AddFloat(placeholder, availableWidth, aReflowStatus);
-        }
+        placedFloat = AddFloat(placeholder, availableWidth, aReflowStatus);
         NS_ASSERTION(!(outOfFlowFrame->GetType() == nsGkAtoms::letterFrame &&
                        GetFirstLetterStyleOK()),
                     "FirstLetterStyle set on line with floating first letter");
       }
     }
     else if (nsGkAtoms::textFrame == frameType) {
       // Note non-empty text-frames for inline frame compatibility hackery
       pfd->SetFlag(PFD_ISTEXTFRAME, PR_TRUE);
diff --git a/layout/generic/nsLineLayout.h b/layout/generic/nsLineLayout.h
--- a/layout/generic/nsLineLayout.h
+++ b/layout/generic/nsLineLayout.h
@@ -208,27 +208,20 @@ public:
   void SetLineEndsInBR(PRBool aOn) 
   { 
     SetFlag(LL_LINEENDSINBR, aOn); 
   }
 
   //----------------------------------------
   // Inform the line-layout about the presence of a floating frame
   // XXX get rid of this: use get-frame-type?
-  PRBool InitFloat(nsPlaceholderFrame* aFrame, 
-                   nscoord aAvailableWidth,
-                   nsReflowStatus& aReflowStatus) {
-    return mBlockRS->InitFloat(*this, aFrame, aAvailableWidth, aReflowStatus);
-  }
-
   PRBool AddFloat(nsPlaceholderFrame* aFrame,
                   nscoord aAvailableWidth,
                   nsReflowStatus& aReflowStatus) {
-    return mBlockRS->AddFloat(*this, aFrame, PR_FALSE,
-                              aAvailableWidth, aReflowStatus);
+    return mBlockRS->AddFloat(*this, aFrame, aAvailableWidth, aReflowStatus);
   }
 
   void SetTrimmableWidth(nscoord aTrimmableWidth) {
     mTrimmableWidth = aTrimmableWidth;
   }
 
   //----------------------------------------
 
