Optimize rebuilding of user font set by comparing arrays.

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1733,41 +1733,63 @@ InsertFontFaceRule(nsCSSFontFaceRule *aR
     aFontSet->AddFontFace(fontfamily, srcArray, weight, stretch, italicStyle);
   }
 }
 
 gfxUserFontSet* 
 nsPresContext::GetUserFontSet()
 {
   if (mUserFontSetDirty) {
-    NS_IF_RELEASE(mUserFontSet);
-
     if (gfxPlatform::GetPlatform()->DownloadableFontsEnabled()) {
       nsTArray< nsRefPtr<nsCSSFontFaceRule> > rules;
       if (!mShell->StyleSet()->AppendFontFaceRules(this, rules))
         return nsnull;
 
       if (rules.Length() > 0) {
-        nsFontFaceLoaderContext *loaderCtx =
-          new nsFontFaceLoaderContext(this);
-        if (!loaderCtx)
-          return nsnull;
-        gfxUserFontSet *fs = new gfxUserFontSet(loaderCtx);
-        // user font set owns loader context
-        if (!fs) {
-          delete loaderCtx;
-          return nsnull;
+        PRBool differ;
+        if (rules.Length() == mFontFaceRules.Length()) {
+          differ = PR_FALSE;
+          for (PRUint32 i = 0, i_end = rules.Length(); i < i_end; ++i) {
+            if (rules[i] != mFontFaceRules[i]) {
+              differ = PR_TRUE;
+              break;
+            }
+          }
+        } else {
+          differ = PR_TRUE;
         }
-        mUserFontSet = fs;
-        NS_ADDREF(mUserFontSet);
 
-        for (PRUint32 i = 0, i_end = rules.Length(); i < i_end; ++i) {
-          InsertFontFaceRule(rules[i], fs);
+        // Only rebuild things if the set of @font-face rules is different.
+        if (differ) {
+          NS_IF_RELEASE(mUserFontSet);
+
+          nsFontFaceLoaderContext *loaderCtx =
+            new nsFontFaceLoaderContext(this);
+          if (!loaderCtx)
+            return nsnull;
+          gfxUserFontSet *fs = new gfxUserFontSet(loaderCtx);
+          // user font set owns loader context
+          if (!fs) {
+            delete loaderCtx;
+            return nsnull;
+          }
+          mUserFontSet = fs;
+          NS_ADDREF(mUserFontSet);
+
+          for (PRUint32 i = 0, i_end = rules.Length(); i < i_end; ++i) {
+            InsertFontFaceRule(rules[i], fs);
+          }
         }
       }
+
+#ifdef DEBUG
+      PRBool success =
+#endif
+        rules.SwapElements(mFontFaceRules);
+      NS_ASSERTION(success, "should never fail given both are heap arrays");
     }
 
     mUserFontSetDirty = PR_FALSE;
   }
   return mUserFontSet;
 }
 
 void
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -61,16 +61,18 @@
 #include "nsGkAtoms.h"
 #include "nsIDocument.h"
 #include "nsInterfaceHashtable.h"
 #include "nsCycleCollectionParticipant.h"
 #include "nsChangeHint.h"
 // This also pulls in gfxTypes.h, which we cannot include directly.
 #include "gfxRect.h"
 #include "nsRegion.h"
+#include "nsTArray.h"
+#include "nsAutoPtr.h"
 
 class nsImageLoader;
 #ifdef IBMBIDI
 class nsBidiPresUtils;
 #endif // IBMBIDI
 
 struct nsRect;
 
@@ -89,16 +91,17 @@ class nsILookAndFeel;
 class nsILookAndFeel;
 class nsICSSPseudoComparator;
 class nsIAtom;
 class nsIAnimationController;
 struct nsStyleBackground;
 template <class T> class nsRunnableMethod;
 class nsIRunnable;
 class gfxUserFontSet;
+class nsCSSFontFaceRule;
 
 #ifdef MOZ_REFLOW_PERF
 class nsIRenderingContext;
 #endif
 
 enum nsWidgetType {
   eWidgetType_Button  	= 1,
   eWidgetType_Checkbox	= 2,
@@ -823,16 +826,18 @@ protected:
 
   nsPropertyTable       mPropertyTable;
 
   nsRegion              mSameDocDirtyRegion;
   nsRegion              mCrossDocDirtyRegion;
 
   // container for per-context fonts (downloadable, SVG, etc.)
   gfxUserFontSet* mUserFontSet;
+  // The list of @font-face rules that we put into mUserFontSet
+  nsTArray< nsRefPtr<nsCSSFontFaceRule> > mFontFaceRules;
   
   PRInt32               mFontScaler;
   nscoord               mMinimumFontSize;
 
   nsRect                mVisibleArea;
   nsSize                mPageSize;
   float                 mPageScale;
   float                 mPPScale;
