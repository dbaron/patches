From: L. David Baron <dbaron@dbaron.org>

Bug 625289 patch 7 - Store style contexts being reframed in the ReframingStyleContexts struct.

diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -648,18 +648,37 @@ nsFrame::DestroyFrom(nsIFrame* aDestruct
          "IB sibling chain is inconsistent");
       nextSib->Properties().Delete(nsIFrame::IBSplitPrevSibling());
     }
   }
 
   // This needs to happen before shell->NotifyDestroyingFrame because that
   // clears our Properties() table.
   bool isPrimaryFrame = (mContent && mContent->GetPrimaryFrame() == this);
+  // FIXME: Check that this works for ::before/::after.
   if (isPrimaryFrame) {
     ActiveLayerTracker::TransferActivityToContent(this, mContent);
+
+    // Unfortunately, we need to do this for all frames being reframed
+    // and not only those whose currently style involves CSS
+    // transitions, because what matters is whether the new style (not
+    // the old) specifies CSS transitions.
+    RestyleManager::ReframingStyleContexts* rsc =
+      presContext->RestyleManager()->GetReframingStyleContexts();
+    if (rsc) {
+      nsStyleContext* sc = mStyleContext;
+      nsCSSPseudoElements::Type pseudoType = sc->GetPseudoType();
+      if (pseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
+        rsc->mElementContexts.Put(mContent, sc);
+      } else if (pseudoType == nsCSSPseudoElements::ePseudo_before) {
+        rsc->mBeforePseudoContexts.Put(mContent->GetParent(), sc);
+      } else if (pseudoType == nsCSSPseudoElements::ePseudo_after) {
+        rsc->mAfterPseudoContexts.Put(mContent->GetParent(), sc);
+      }
+    }
   }
 
   shell->NotifyDestroyingFrame(this);
 
   if (mState & NS_FRAME_EXTERNAL_REFERENCE) {
     shell->ClearFrameRefs(this);
   }
 
