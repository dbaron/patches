Rename aInherited/inherited to aCanStoreInRuleTree/canStoreInRuleTree.  (Bug 476598)  r+sr=bzbarsky

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -178,31 +178,31 @@ static nscoord CalcLengthWith(const nsCS
                               const nsStyleFont* aStyleFont,
                               nsStyleContext* aStyleContext,
                               nsPresContext* aPresContext,
                               PRBool aUseProvidedRootEmSize,
                               // aUseUserFontSet should always be PR_TRUE
                               // except when called from
                               // CalcLengthWithInitialFont.
                               PRBool aUseUserFontSet,
-                              PRBool& aInherited)
+                              PRBool& aCanStoreInRuleTree)
 {
   NS_ASSERTION(aValue.IsLengthUnit(), "not a length unit");
   NS_ASSERTION(aStyleFont || aStyleContext, "Must have style data");
   NS_ASSERTION(aPresContext, "Must have prescontext");
 
   if (aValue.IsFixedLengthUnit()) {
     return aPresContext->TwipsToAppUnits(aValue.GetLengthTwips());
   }
   nsCSSUnit unit = aValue.GetUnit();
   if (unit == eCSSUnit_Pixel) {
     return nsPresContext::CSSPixelsToAppUnits(aValue.GetFloatValue());
   }
   // Common code for all units other than pixels:
-  aInherited = PR_FALSE;
+  aCanStoreInRuleTree = PR_FALSE;
   if (!aStyleFont) {
     aStyleFont = aStyleContext->GetStyleFont();
   }
   if (aFontSize == -1) {
     // XXX Should this be aStyleFont->mSize instead to avoid taking minfontsize
     // prefs into account?
     aFontSize = aStyleFont->mFont.size;
   }
@@ -263,42 +263,42 @@ static nscoord CalcLengthWith(const nsCS
   }
   return 0;
 }
 
 /* static */ nscoord
 nsRuleNode::CalcLength(const nsCSSValue& aValue,
                        nsStyleContext* aStyleContext,
                        nsPresContext* aPresContext,
-                       PRBool& aInherited)
+                       PRBool& aCanStoreInRuleTree)
 {
   NS_ASSERTION(aStyleContext, "Must have style data");
 
   return CalcLengthWith(aValue, -1, nsnull, aStyleContext, aPresContext,
-                        PR_FALSE, PR_TRUE, aInherited);
+                        PR_FALSE, PR_TRUE, aCanStoreInRuleTree);
 }
 
 /* Inline helper function to redirect requests to CalcLength. */
 static inline nscoord CalcLength(const nsCSSValue& aValue,
                                  nsStyleContext* aStyleContext,
                                  nsPresContext* aPresContext,
-                                 PRBool& aInherited)
+                                 PRBool& aCanStoreInRuleTree)
 {
   return nsRuleNode::CalcLength(aValue, aStyleContext,
-                                aPresContext, aInherited);
+                                aPresContext, aCanStoreInRuleTree);
 }
 
 /* static */ nscoord
 nsRuleNode::CalcLengthWithInitialFont(nsPresContext* aPresContext,
                                       const nsCSSValue& aValue)
 {
   nsStyleFont defaultFont(aPresContext);
-  PRBool inherited;
+  PRBool canStoreInRuleTree;
   return CalcLengthWith(aValue, -1, &defaultFont, nsnull, aPresContext,
-                        PR_TRUE, PR_FALSE, inherited);
+                        PR_TRUE, PR_FALSE, canStoreInRuleTree);
 }
 
 #define SETCOORD_NORMAL                 0x01   // N
 #define SETCOORD_AUTO                   0x02   // A
 #define SETCOORD_INHERIT                0x04   // H
 #define SETCOORD_PERCENT                0x08   // P
 #define SETCOORD_FACTOR                 0x10   // F
 #define SETCOORD_LENGTH                 0x20   // L
@@ -325,25 +325,27 @@ nsRuleNode::CalcLengthWithInitialFont(ns
 #define SETCOORD_LEH    (SETCOORD_LE | SETCOORD_INHERIT)
 #define SETCOORD_IA     (SETCOORD_INTEGER | SETCOORD_AUTO)
 #define SETCOORD_LAE    (SETCOORD_LENGTH | SETCOORD_AUTO | SETCOORD_ENUMERATED)
 
 // changes aCoord iff it returns PR_TRUE
 static PRBool SetCoord(const nsCSSValue& aValue, nsStyleCoord& aCoord, 
                        const nsStyleCoord& aParentCoord,
                        PRInt32 aMask, nsStyleContext* aStyleContext,
-                       nsPresContext* aPresContext, PRBool& aInherited)
+                       nsPresContext* aPresContext,
+                       PRBool& aCanStoreInRuleTree)
 {
   PRBool  result = PR_TRUE;
   if (aValue.GetUnit() == eCSSUnit_Null) {
     result = PR_FALSE;
   }
   else if (((aMask & SETCOORD_LENGTH) != 0) && 
            aValue.IsLengthUnit()) {
-    aCoord.SetCoordValue(CalcLength(aValue, aStyleContext, aPresContext, aInherited));
+    aCoord.SetCoordValue(CalcLength(aValue, aStyleContext, aPresContext,
+                                    aCanStoreInRuleTree));
   }
   else if (((aMask & SETCOORD_PERCENT) != 0) && 
            (aValue.GetUnit() == eCSSUnit_Percent)) {
     aCoord.SetPercentValue(aValue.GetPercentValue());
   } 
   else if (((aMask & SETCOORD_INTEGER) != 0) && 
            (aValue.GetUnit() == eCSSUnit_Integer)) {
     aCoord.SetIntValue(aValue.GetIntValue(), eStyleUnit_Integer);
@@ -354,17 +356,17 @@ static PRBool SetCoord(const nsCSSValue&
   } 
   else if (((aMask & SETCOORD_AUTO) != 0) && 
            (aValue.GetUnit() == eCSSUnit_Auto)) {
     aCoord.SetAutoValue();
   } 
   else if (((aMask & SETCOORD_INHERIT) != 0) && 
            (aValue.GetUnit() == eCSSUnit_Inherit)) {
     aCoord = aParentCoord;  // just inherit value from parent
-    aInherited = PR_FALSE;
+    aCanStoreInRuleTree = PR_FALSE;
   }
   else if (((aMask & SETCOORD_NORMAL) != 0) && 
            (aValue.GetUnit() == eCSSUnit_Normal)) {
     aCoord.SetNormalValue();
   }
   else if (((aMask & SETCOORD_NONE) != 0) && 
            (aValue.GetUnit() == eCSSUnit_None)) {
     aCoord.SetNoneValue();
@@ -420,17 +422,17 @@ static float GetFloatFromBoxPosition(PRI
     // fall through
   case NS_STYLE_BG_POSITION_CENTER:
     return 0.5f;
   }
 }
 
 static PRBool SetColor(const nsCSSValue& aValue, const nscolor aParentColor, 
                        nsPresContext* aPresContext, nsStyleContext *aContext,
-                       nscolor& aResult, PRBool& aInherited)
+                       nscolor& aResult, PRBool& aCanStoreInRuleTree)
 {
   PRBool  result = PR_FALSE;
   nsCSSUnit unit = aValue.GetUnit();
 
   if (eCSSUnit_Color == unit) {
     aResult = aValue.GetColorValue();
     result = PR_TRUE;
   }
@@ -461,30 +463,30 @@ static PRBool SetColor(const nsCSSValue&
           aResult = aPresContext->DefaultVisitedLinkColor();
           break;
         case NS_COLOR_MOZ_ACTIVEHYPERLINKTEXT:
           aResult = aPresContext->DefaultActiveLinkColor();
           break;
         case NS_COLOR_CURRENTCOLOR:
           // The data computed from this can't be shared in the rule tree 
           // because they could be used on a node with a different color
-          aInherited = PR_FALSE;
+          aCanStoreInRuleTree = PR_FALSE;
           aResult = aContext->GetStyleColor()->mColor;
           break;
         default:
           NS_NOTREACHED("Should never have an unknown negative colorID.");
           break;
       }
       result = PR_TRUE;
     }
   }
   else if (eCSSUnit_Inherit == unit) {
     aResult = aParentColor;
     result = PR_TRUE;
-    aInherited = PR_FALSE;
+    aCanStoreInRuleTree = PR_FALSE;
   }
   return result;
 }
 
 // flags for SetDiscrete - align values with SETCOORD_* constants
 // where possible
 
 #define SETDSC_NORMAL                 0x01   // N
@@ -494,32 +496,32 @@ static PRBool SetColor(const nsCSSValue&
 #define SETDSC_NONE                   0x100  // O
 #define SETDSC_SYSTEM_FONT            0x2000
 
 // no caller cares whether aField was changed or not
 template <typename FieldT,
           typename T1, typename T2, typename T3, typename T4, typename T5>
 static void
 SetDiscrete(const nsCSSValue& aValue, FieldT & aField,
-            PRBool& aInherited, PRUint32 aMask,
+            PRBool& aCanStoreInRuleTree, PRUint32 aMask,
             FieldT aParentValue,
             T1 aInitialValue,
             T2 aAutoValue,
             T3 aNoneValue,
             T4 aNormalValue,
             T5 aSystemFontValue)
 {
   switch (aValue.GetUnit()) {
   case eCSSUnit_Null:
     return;
 
     // every caller of SetDiscrete provides inherit and initial
     // alternatives, so we don't require them to say so in the mask
   case eCSSUnit_Inherit:
-    aInherited = PR_FALSE;
+    aCanStoreInRuleTree = PR_FALSE;
     aField = aParentValue;
     return;
 
   case eCSSUnit_Initial:
     aField = aInitialValue;
     return;
 
     // every caller provides one or other of these alternatives,
@@ -575,17 +577,17 @@ SetDiscrete(const nsCSSValue& aValue, Fi
 }
 
 // flags for SetFactor
 #define SETFCT_POSITIVE 0x01        // assert value is >= 0.0f
 #define SETFCT_OPACITY  0x02        // clamp value to [0.0f .. 1.0f]
 #define SETFCT_NONE     0x04        // allow _None (uses aInitialValue).
 
 static void
-SetFactor(const nsCSSValue& aValue, float& aField, PRBool& aInherited,
+SetFactor(const nsCSSValue& aValue, float& aField, PRBool& aCanStoreInRuleTree,
           float aParentValue, float aInitialValue, PRUint32 aFlags = 0)
 {
   switch (aValue.GetUnit()) {
   case eCSSUnit_Null:
     return;
 
   case eCSSUnit_Number:
     aField = aValue.GetFloatValue();
@@ -598,17 +600,17 @@ SetFactor(const nsCSSValue& aValue, floa
       if (aField < 0.0f)
         aField = 0.0f;
       if (aField > 1.0f)
         aField = 1.0f;
     }
     return;
 
   case eCSSUnit_Inherit:
-    aInherited = PR_FALSE;
+    aCanStoreInRuleTree = PR_FALSE;
     aField = aParentValue;
     return;
 
   case eCSSUnit_Initial:
     aField = aInitialValue;
     return;
 
   case eCSSUnit_None:
@@ -2064,27 +2066,27 @@ nsRuleNode::SetDefaultOnRoot(const nsSty
 void
 nsRuleNode::AdjustLogicalBoxProp(nsStyleContext* aContext,
                                  const nsCSSValue& aLTRSource,
                                  const nsCSSValue& aRTLSource,
                                  const nsCSSValue& aLTRLogicalValue,
                                  const nsCSSValue& aRTLLogicalValue,
                                  PRUint8 aSide,
                                  nsCSSRect& aValueRect,
-                                 PRBool& aInherited)
+                                 PRBool& aCanStoreInRuleTree)
 {
   PRBool LTRlogical = aLTRSource.GetUnit() == eCSSUnit_Enumerated &&
                       aLTRSource.GetIntValue() == NS_BOXPROP_SOURCE_LOGICAL;
   PRBool RTLlogical = aRTLSource.GetUnit() == eCSSUnit_Enumerated &&
                       aRTLSource.GetIntValue() == NS_BOXPROP_SOURCE_LOGICAL;
   if (LTRlogical || RTLlogical) {
     // We can't cache anything on the rule tree if we use any data from
     // the style context, since data cached in the rule tree could be
     // used with a style context with a different value.
-    aInherited = PR_FALSE;
+    aCanStoreInRuleTree = PR_FALSE;
     PRUint8 dir = aContext->GetStyleVisibility()->mDirection;
 
     if (dir == NS_STYLE_DIRECTION_LTR) {
       if (LTRlogical)
         aValueRect.*(nsCSSRect::sides[aSide]) = aLTRLogicalValue;
     } else {
       if (RTLlogical)
         aValueRect.*(nsCSSRect::sides[aSide]) = aRTLLogicalValue;
@@ -2109,35 +2111,35 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
                "should not have bothered calling Compute*Data");              \
                                                                               \
   nsStyleContext* parentContext = aContext->GetParent();                      \
                                                                               \
   const nsRuleData##rdtype_& rdata_ =                                         \
     static_cast<const nsRuleData##rdtype_&>(aData);                           \
   nsStyle##type_* data_ = nsnull;                                             \
   const nsStyle##type_* parentdata_ = nsnull;                                 \
-  PRBool inherited = aInherited;                                              \
-                                                                              \
-  /* If |inherited| might be false by the time we're done, we can't call */   \
-  /* parentContext->GetStyle##type_() since it could recur into setting */    \
-  /* the same struct on the same rule node, causing a leak. */                \
+  PRBool canStoreInRuleTree = aCanStoreInRuleTree;                            \
+                                                                              \
+  /* If |canStoreInRuleTree| might be false by the time we're done, we */     \
+  /* can't call parentContext->GetStyle##type_() since it could recur into */ \
+  /* setting the same struct on the same rule node, causing a leak. */        \
   if (parentContext && aRuleDetail != eRuleFullReset &&                       \
       (!aStartStruct || (aRuleDetail != eRulePartialReset &&                  \
                          aRuleDetail != eRuleNone)))                          \
     parentdata_ = parentContext->GetStyle##type_();                           \
   if (aStartStruct)                                                           \
     /* We only need to compute the delta between this computed data and */    \
     /* our computed data. */                                                  \
     data_ = new (mPresContext)                                                \
             nsStyle##type_(*static_cast<nsStyle##type_*>(aStartStruct));      \
   else {                                                                      \
     if (aRuleDetail != eRuleFullMixed && aRuleDetail != eRuleFullReset) {     \
       /* No question. We will have to inherit. Go ahead and init */           \
       /* with inherited vals from parent. */                                  \
-      inherited = PR_FALSE;                                                    \
+      canStoreInRuleTree = PR_FALSE;                                          \
       if (parentdata_)                                                        \
         data_ = new (mPresContext) nsStyle##type_(*parentdata_);              \
       else                                                                    \
         data_ = new (mPresContext) nsStyle##type_ ctorargs_;                  \
     }                                                                         \
     else                                                                      \
       data_ = new (mPresContext) nsStyle##type_ ctorargs_;                    \
   }                                                                           \
@@ -2180,37 +2182,37 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
     data_ = new (mPresContext)                                                \
             nsStyle##type_(*static_cast<nsStyle##type_*>(aStartStruct));      \
   else                                                                        \
     data_ = new (mPresContext) nsStyle##type_ ctorargs_;                      \
                                                                               \
   if (NS_UNLIKELY(!data_))                                                    \
     return nsnull;  /* Out Of Memory */                                       \
                                                                               \
-  /* If |inherited| might be false by the time we're done, we can't call */   \
-  /* parentContext->GetStyle##type_() since it could recur into setting */    \
-  /* the same struct on the same rule node, causing a leak. */                \
+  /* If |canStoreInRuleTree| might be false by the time we're done, we */     \
+  /* can't call parentContext->GetStyle##type_() since it could recur into */ \
+  /* setting the same struct on the same rule node, causing a leak. */        \
   const nsStyle##type_* parentdata_ = data_;                                  \
   if (parentContext &&                                                        \
       aRuleDetail != eRuleFullReset &&                                        \
       aRuleDetail != eRulePartialReset &&                                     \
       aRuleDetail != eRuleNone)                                               \
     parentdata_ = parentContext->GetStyle##type_();                           \
-  PRBool inherited = aInherited;
+  PRBool canStoreInRuleTree = aCanStoreInRuleTree;
 
 /**
  * Begin an nsRuleNode::Compute*Data function for an inherited struct.
  *
  * @param type_ The nsStyle* type this function computes.
  * @param data_ Variable holding the result of this function.
  */
 #define COMPUTE_END_INHERITED(type_, data_)                                   \
-  if (!inherited)                                                             \
-    /* We inherited, and therefore can't be cached in the rule node.  We */   \
-    /* have to be put right on the style context. */                          \
+  if (!canStoreInRuleTree)                                                    \
+    /* We can't be cached in the rule node.  We have to be put right */       \
+    /* on the style context. */                                               \
     aContext->SetStyle(eStyleStruct_##type_, data_);                          \
   else {                                                                      \
     /* We were fully specified and can therefore be cached right on the */    \
     /* rule node. */                                                          \
     if (!aHighestNode->mStyleData.mInheritedData) {                           \
       aHighestNode->mStyleData.mInheritedData =                               \
         new (mPresContext) nsInheritedStyleData;                              \
       if (NS_UNLIKELY(!aHighestNode->mStyleData.mInheritedData)) {            \
@@ -2227,19 +2229,19 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
 
 /**
  * Begin an nsRuleNode::Compute*Data function for a reset struct.
  *
  * @param type_ The nsStyle* type this function computes.
  * @param data_ Variable holding the result of this function.
  */
 #define COMPUTE_END_RESET(type_, data_)                                       \
-  if (!inherited)                                                             \
-    /* We inherited, and therefore can't be cached in the rule node.  We */   \
-    /* have to be put right on the style context. */                          \
+  if (!canStoreInRuleTree)                                                    \
+    /* We can't be cached in the rule node.  We have to be put right */       \
+    /* on the style context. */                                               \
     aContext->SetStyle(eStyleStruct_##type_, data_);                          \
   else {                                                                      \
     /* We were fully specified and can therefore be cached right on the */    \
     /* rule node. */                                                          \
     if (!aHighestNode->mStyleData.mResetData) {                               \
       aHighestNode->mStyleData.mResetData =                                   \
         new (mPresContext) nsResetStyleData;                                  \
       if (NS_UNLIKELY(!aHighestNode->mStyleData.mResetData)) {                \
@@ -2321,17 +2323,17 @@ nsRuleNode::SetFontSize(nsPresContext* a
                         const nsStyleFont* aFont,
                         const nsStyleFont* aParentFont,
                         nscoord* aSize,
                         const nsFont& aSystemFont,
                         nscoord aParentSize,
                         nscoord aScriptLevelAdjustedParentSize,
                         PRBool aUsedStartStruct,
                         PRBool aAtRoot,
-                        PRBool& aInherited)
+                        PRBool& aCanStoreInRuleTree)
 {
   PRBool zoom = PR_FALSE;
   PRInt32 baseSize = (PRInt32) aPresContext->
     GetDefaultFont(aFont->mGenericID)->size;
   if (eCSSUnit_Enumerated == aFontData.mSize.GetUnit()) {
     PRInt32 value = aFontData.mSize.GetIntValue();
     PRInt32 scaler = aPresContext->FontScaler();
     float scaleFactor = nsStyleUtil::GetScalingFactor(scaler);
@@ -2344,17 +2346,17 @@ nsRuleNode::SetFontSize(nsPresContext* a
     }
     else if (NS_STYLE_FONT_SIZE_XXXLARGE == value) {
       // <font size="7"> is not specified in CSS, so we don't use eFontSize_CSS.
       *aSize = nsStyleUtil::CalcFontPointSize(value, baseSize,
                        scaleFactor, aPresContext);
     }
     else if (NS_STYLE_FONT_SIZE_LARGER  == value ||
              NS_STYLE_FONT_SIZE_SMALLER == value) {
-      aInherited = PR_FALSE;
+      aCanStoreInRuleTree = PR_FALSE;
 
       // Un-zoom so we use the tables correctly.  We'll then rezoom due
       // to the |zoom = PR_TRUE| above.
       // Note that relative units here use the parent's size unadjusted
       // for scriptlevel changes. A scriptlevel change between us and the parent
       // is simply ignored.
       nscoord parentSize =
         nsStyleFont::UnZoomText(aPresContext, aParentSize);
@@ -2376,36 +2378,37 @@ nsRuleNode::SetFontSize(nsPresContext* a
       NS_NOTREACHED("unexpected value");
     }
   }
   else if (aFontData.mSize.IsLengthUnit()) {
     // Note that font-based length units use the parent's size unadjusted
     // for scriptlevel changes. A scriptlevel change between us and the parent
     // is simply ignored.
     *aSize = CalcLengthWith(aFontData.mSize, aParentSize, aParentFont, nsnull,
-                            aPresContext, aAtRoot, PR_TRUE, aInherited);
+                            aPresContext, aAtRoot, PR_TRUE,
+                            aCanStoreInRuleTree);
     zoom = aFontData.mSize.IsFixedLengthUnit() ||
            aFontData.mSize.GetUnit() == eCSSUnit_Pixel;
   }
   else if (eCSSUnit_Percent == aFontData.mSize.GetUnit()) {
-    aInherited = PR_FALSE;
+    aCanStoreInRuleTree = PR_FALSE;
     // Note that % units use the parent's size unadjusted for scriptlevel
     // changes. A scriptlevel change between us and the parent is simply
     // ignored.
     *aSize = NSToCoordRound(aParentSize *
                             aFontData.mSize.GetPercentValue());
     zoom = PR_FALSE;
   }
   else if (eCSSUnit_System_Font == aFontData.mSize.GetUnit()) {
     // this becomes our cascading size
     *aSize = aSystemFont.size;
     zoom = PR_TRUE;
   }
   else if (eCSSUnit_Inherit == aFontData.mSize.GetUnit()) {
-    aInherited = PR_FALSE;
+    aCanStoreInRuleTree = PR_FALSE;
     // We apply scriptlevel change for this case, because the default is
     // to inherit and we don't want explicit "inherit" to differ from the
     // default.
     *aSize = aScriptLevelAdjustedParentSize;
     zoom = PR_FALSE;
   }
   else if (eCSSUnit_Initial == aFontData.mSize.GetUnit()) {
     // The initial value is 'medium', which has magical sizing based on
@@ -2417,19 +2420,19 @@ nsRuleNode::SetFontSize(nsPresContext* a
                  "What kind of font-size value is this?");
 #ifdef MOZ_MATHML
     // if aUsedStartStruct is true, then every single property in the
     // font struct is being set all at once. This means scriptlevel is not
     // going to have any influence on the font size; there is no need to
     // do anything here.
     if (!aUsedStartStruct && aParentSize != aScriptLevelAdjustedParentSize) {
       // There was no rule affecting the size but the size has been
-      // affected by the parent's size via scriptlevel change. So treat
-      // this as inherited.
-      aInherited = PR_FALSE;
+      // affected by the parent's size via scriptlevel change. So we cannot
+      // store the data in the rule tree.
+      aCanStoreInRuleTree = PR_FALSE;
       *aSize = aScriptLevelAdjustedParentSize;
     }
 #endif
   }
 
   // We want to zoom the cascaded size so that em-based measurements,
   // line-heights, etc., work.
   if (zoom) {
@@ -2446,17 +2449,17 @@ static PRInt8 ClampTo8Bit(PRInt32 aValue
 }
 
 /* static */ void
 nsRuleNode::SetFont(nsPresContext* aPresContext, nsStyleContext* aContext,
                     nscoord aMinFontSize,
                     PRUint8 aGenericFontID, const nsRuleDataFont& aFontData,
                     const nsStyleFont* aParentFont,
                     nsStyleFont* aFont, PRBool aUsedStartStruct,
-                    PRBool& aInherited)
+                    PRBool& aCanStoreInRuleTree)
 {
   const nsFont* defaultVariableFont =
     aPresContext->GetDefaultFont(kPresContext_DefaultVariableFont_ID);
   PRBool atRoot = !aContext->GetParent();
 
   // -moz-system-font: enum (never inherit!)
   nsFont systemFont;
   if (eCSSUnit_Enumerated == aFontData.mSystemFont.GetUnit()) {
@@ -2546,17 +2549,17 @@ nsRuleNode::SetFont(nsPresContext* aPres
   }
   else if (eCSSUnit_System_Font == aFontData.mFamily.GetUnit()) {
     aFont->mFont.name = systemFont.name;
     aFont->mFont.familyNameQuirks = PR_FALSE;
     aFont->mFont.systemFont = PR_TRUE;
     aFont->mGenericID = kGenericFont_NONE;
   }
   else if (eCSSUnit_Inherit == aFontData.mFamily.GetUnit()) {
-    aInherited = PR_FALSE;
+    aCanStoreInRuleTree = PR_FALSE;
     aFont->mFont.name = aParentFont->mFont.name;
     aFont->mFont.familyNameQuirks = aParentFont->mFont.familyNameQuirks;
     aFont->mFont.systemFont = aParentFont->mFont.systemFont;
     aFont->mGenericID = aParentFont->mGenericID;
   }
   else if (eCSSUnit_Initial == aFontData.mFamily.GetUnit()) {
     aFont->mFont.name = defaultVariableFont->name;
     aFont->mFont.familyNameQuirks = PR_FALSE;
@@ -2568,26 +2571,26 @@ nsRuleNode::SetFont(nsPresContext* aPres
   // always keep aFont->mFlags set to the correct generic.  But we have
   // to be careful not to touch it when we're called directly from
   // ComputeFontData, because we could have a start struct.
   if (aGenericFontID != kGenericFont_NONE) {
     aFont->mGenericID = aGenericFontID;
   }
 
   // font-style: enum, normal, inherit, initial, -moz-system-font
-  SetDiscrete(aFontData.mStyle, aFont->mFont.style, aInherited,
+  SetDiscrete(aFontData.mStyle, aFont->mFont.style, aCanStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NORMAL | SETDSC_SYSTEM_FONT,
               aParentFont->mFont.style,
               defaultVariableFont->style,
               0, 0,
               NS_STYLE_FONT_STYLE_NORMAL,
               systemFont.style);
 
   // font-variant: enum, normal, inherit, initial, -moz-system-font
-  SetDiscrete(aFontData.mVariant, aFont->mFont.variant, aInherited,
+  SetDiscrete(aFontData.mVariant, aFont->mFont.variant, aCanStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NORMAL | SETDSC_SYSTEM_FONT,
               aParentFont->mFont.variant,
               defaultVariableFont->variant,
               0, 0,
               NS_STYLE_FONT_VARIANT_NORMAL,
               systemFont.variant);
 
   // font-weight: int, enum, normal, inherit, initial, -moz-system-font
@@ -2596,80 +2599,81 @@ nsRuleNode::SetFont(nsPresContext* aPres
     PRInt32 value = aFontData.mWeight.GetIntValue();
     switch (value) {
       case NS_STYLE_FONT_WEIGHT_NORMAL:
       case NS_STYLE_FONT_WEIGHT_BOLD:
         aFont->mFont.weight = value;
         break;
       case NS_STYLE_FONT_WEIGHT_BOLDER:
       case NS_STYLE_FONT_WEIGHT_LIGHTER:
-        aInherited = PR_FALSE;
+        aCanStoreInRuleTree = PR_FALSE;
         aFont->mFont.weight = nsStyleUtil::ConstrainFontWeight(aParentFont->mFont.weight + value);
         break;
     }
   } else 
-    SetDiscrete(aFontData.mWeight, aFont->mFont.weight, aInherited,
+    SetDiscrete(aFontData.mWeight, aFont->mFont.weight, aCanStoreInRuleTree,
                 SETDSC_INTEGER | SETDSC_NORMAL | SETDSC_SYSTEM_FONT,
                 aParentFont->mFont.weight,
                 defaultVariableFont->weight,
                 0, 0,
                 NS_STYLE_FONT_WEIGHT_NORMAL,
                 systemFont.weight);
 
   // font-stretch: enum, normal, inherit
   if (eCSSUnit_Enumerated == aFontData.mStretch.GetUnit()) {
     PRInt32 value = aFontData.mStretch.GetIntValue();
     switch (value) {
       case NS_FONT_STRETCH_WIDER:
       case NS_FONT_STRETCH_NARROWER:
-        aInherited = PR_FALSE;
+        aCanStoreInRuleTree = PR_FALSE;
         aFont->mFont.stretch = aParentFont->mFont.stretch + value;
         break;
       default:
         aFont->mFont.stretch = value;
         break;
     }
   } else
-    SetDiscrete(aFontData.mStretch, aFont->mFont.stretch, aInherited,
+    SetDiscrete(aFontData.mStretch, aFont->mFont.stretch, aCanStoreInRuleTree,
                 SETDSC_NORMAL | SETDSC_SYSTEM_FONT,
                 aParentFont->mFont.stretch,
                 defaultVariableFont->stretch,
                 0, 0, NS_FONT_STRETCH_NORMAL, systemFont.stretch);
 
 #ifdef MOZ_MATHML
   // Compute scriptlevel, scriptminsize and scriptsizemultiplier now so
   // they're available for font-size computation.
 
   // -moz-script-min-size: length
   if (aFontData.mScriptMinSize.IsLengthUnit()) {
     // scriptminsize in font units (em, ex) has to be interpreted relative
     // to the parent font, or the size definitions are circular and we
     // 
     aFont->mScriptMinSize =
       CalcLengthWith(aFontData.mScriptMinSize, aParentFont->mSize, aParentFont,
-                     nsnull, aPresContext, atRoot, PR_TRUE, aInherited);
+                     nsnull, aPresContext, atRoot, PR_TRUE,
+                     aCanStoreInRuleTree);
   }
 
   // -moz-script-size-multiplier: factor, inherit, initial
   SetFactor(aFontData.mScriptSizeMultiplier, aFont->mScriptSizeMultiplier,
-            aInherited, aParentFont->mScriptSizeMultiplier,
+            aCanStoreInRuleTree, aParentFont->mScriptSizeMultiplier,
             NS_MATHML_DEFAULT_SCRIPT_SIZE_MULTIPLIER,
             SETFCT_POSITIVE);
   
   // -moz-script-level: integer, number, inherit
   if (eCSSUnit_Integer == aFontData.mScriptLevel.GetUnit()) {
     // "relative"
     aFont->mScriptLevel = ClampTo8Bit(aParentFont->mScriptLevel + aFontData.mScriptLevel.GetIntValue());
   }
   else if (eCSSUnit_Number == aFontData.mScriptLevel.GetUnit()) {
     // "absolute"
     aFont->mScriptLevel = ClampTo8Bit(PRInt32(aFontData.mScriptLevel.GetFloatValue()));
   }
   else if (eCSSUnit_Inherit == aFontData.mScriptSizeMultiplier.GetUnit()) {
-    aInherited = PR_FALSE;
+    aCanStoreInRuleTree = PR_FALSE;
     aFont->mScriptLevel = aParentFont->mScriptLevel;
   }
   else if (eCSSUnit_Initial == aFontData.mScriptSizeMultiplier.GetUnit()) {
     aFont->mScriptLevel = 0;
   }
 #endif
 
   // font-size: enum, length, percent, inherit
@@ -2679,50 +2683,51 @@ nsRuleNode::SetFont(nsPresContext* aPres
   scriptLevelAdjustedParentSize =
     ComputeScriptLevelSize(aFont, aParentFont, aPresContext,
                            &scriptLevelAdjustedUnconstrainedParentSize);
   NS_ASSERTION(!aUsedStartStruct || aFont->mScriptUnconstrainedSize == aFont->mSize,
                "If we have a start struct, we should have reset everything coming in here");
 #endif
   SetFontSize(aPresContext, aFontData, aFont, aParentFont, &aFont->mSize,
               systemFont, aParentFont->mSize, scriptLevelAdjustedParentSize,
-              aUsedStartStruct, atRoot, aInherited);
+              aUsedStartStruct, atRoot, aCanStoreInRuleTree);
 #ifdef MOZ_MATHML
   if (aParentFont->mSize == aParentFont->mScriptUnconstrainedSize &&
       scriptLevelAdjustedParentSize == scriptLevelAdjustedUnconstrainedParentSize) {
     // Fast path: we have not been affected by scriptminsize so we don't
     // need to call SetFontSize again to compute the
     // scriptminsize-unconstrained size. This is OK even if we have a
     // start struct, because if we have a start struct then 'font-size'
     // was specified and so scriptminsize has no effect.
     aFont->mScriptUnconstrainedSize = aFont->mSize;
   } else {
     SetFontSize(aPresContext, aFontData, aFont, aParentFont,
                 &aFont->mScriptUnconstrainedSize, systemFont,
                 aParentFont->mScriptUnconstrainedSize,
                 scriptLevelAdjustedUnconstrainedParentSize,
-                aUsedStartStruct, atRoot, aInherited);
+                aUsedStartStruct, atRoot, aCanStoreInRuleTree);
   }
   NS_ASSERTION(aFont->mScriptUnconstrainedSize <= aFont->mSize,
                "scriptminsize should never be making things bigger");
 #endif
 
   // enforce the user' specified minimum font-size on the value that we expose
   // (but don't change font-size:0)
   if (0 < aFont->mSize && aFont->mSize < aMinFontSize)
     aFont->mFont.size = aMinFontSize;
   else
     aFont->mFont.size = aFont->mSize;
 
   // font-size-adjust: number, none, inherit, initial, -moz-system-font
   if (eCSSUnit_System_Font == aFontData.mSizeAdjust.GetUnit()) {
     aFont->mFont.sizeAdjust = systemFont.sizeAdjust;
   } else
-    SetFactor(aFontData.mSizeAdjust, aFont->mFont.sizeAdjust, aInherited,
-              aParentFont->mFont.sizeAdjust, 0.0f, SETFCT_NONE);
+    SetFactor(aFontData.mSizeAdjust, aFont->mFont.sizeAdjust,
+              aCanStoreInRuleTree, aParentFont->mFont.sizeAdjust, 0.0f,
+              SETFCT_NONE);
 }
 
 // SetGenericFont:
 //  - backtrack to an ancestor with the same generic font name (possibly
 //    up to the root where default values come from the presentation context)
 //  - re-apply cascading rules from there without caching intermediate values
 /* static */ void
 nsRuleNode::SetGenericFont(nsPresContext* aPresContext,
@@ -2816,17 +2821,17 @@ static PRBool ExtractGeneric(const nsStr
 }
 
 const void* 
 nsRuleNode::ComputeFontData(void* aStartStruct,
                             const nsRuleDataStruct& aData, 
                             nsStyleContext* aContext, 
                             nsRuleNode* aHighestNode,
                             const RuleDetail aRuleDetail,
-                            const PRBool aInherited)
+                            const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Font, (mPresContext), font, parentFont,
                           Font, fontData)
 
   // NOTE:  The |aRuleDetail| passed in is a little bit conservative due
   // to the -moz-system-font property.  We really don't need to consider
   // it here in determining whether to cache in the rule tree.  However,
   // we do need to consider it in WalkRuleTree when deciding whether to
@@ -2892,33 +2897,33 @@ nsRuleNode::ComputeFontData(void* aStart
     }
   }
 
   // Now compute our font struct
   if (generic == kGenericFont_NONE) {
     // continue the normal processing
     nsRuleNode::SetFont(mPresContext, aContext, minimumFontSize, generic,
                         fontData, parentFont, font,
-                        aStartStruct != nsnull, inherited);
+                        aStartStruct != nsnull, canStoreInRuleTree);
   }
   else {
     // re-calculate the font as a generic font
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     nsRuleNode::SetGenericFont(mPresContext, aContext, generic,
                                minimumFontSize, font);
   }
 
   COMPUTE_END_INHERITED(Font, font)
 }
 
 already_AddRefed<nsCSSShadowArray>
 nsRuleNode::GetShadowData(nsCSSValueList* aList,
                           nsStyleContext* aContext,
                           PRBool aUsesSpread,
-                          PRBool& inherited)
+                          PRBool& canStoreInRuleTree)
 {
   PRUint32 arrayLength = 0;
   for (nsCSSValueList *list2 = aList; list2; list2 = list2->mNext)
     ++arrayLength;
 
   NS_ASSERTION(arrayLength > 0, "Non-null text-shadow list, yet we counted 0 items.");
   nsCSSShadowArray* shadowList = new(arrayLength) nsCSSShadowArray(arrayLength);
 
@@ -2928,196 +2933,201 @@ nsRuleNode::GetShadowData(nsCSSValueList
   nsStyleCoord tempCoord;
   PRBool unitOK;
   for (nsCSSShadowItem* item = shadowList->ShadowAt(0);
        aList;
        aList = aList->mNext, ++item) {
     nsCSSValue::Array *arr = aList->mValue.GetArrayValue();
     // OK to pass bad aParentCoord since we're not passing SETCOORD_INHERIT
     unitOK = SetCoord(arr->Item(0), tempCoord, nsStyleCoord(),
-                      SETCOORD_LENGTH, aContext, mPresContext, inherited);
+                      SETCOORD_LENGTH, aContext, mPresContext,
+                      canStoreInRuleTree);
     NS_ASSERTION(unitOK, "unexpected unit");
     item->mXOffset = tempCoord.GetCoordValue();
 
     unitOK = SetCoord(arr->Item(1), tempCoord, nsStyleCoord(),
-                      SETCOORD_LENGTH, aContext, mPresContext, inherited);
+                      SETCOORD_LENGTH, aContext, mPresContext,
+                      canStoreInRuleTree);
     NS_ASSERTION(unitOK, "unexpected unit");
     item->mYOffset = tempCoord.GetCoordValue();
 
     // Blur radius is optional in the current box-shadow spec
     if (arr->Item(2).GetUnit() != eCSSUnit_Null) {
       unitOK = SetCoord(arr->Item(2), tempCoord, nsStyleCoord(),
-                        SETCOORD_LENGTH, aContext, mPresContext, inherited);
+                        SETCOORD_LENGTH, aContext, mPresContext,
+                        canStoreInRuleTree);
       NS_ASSERTION(unitOK, "unexpected unit");
       item->mRadius = tempCoord.GetCoordValue();
     } else {
       item->mRadius = 0;
     }
 
     // Find the spread radius
     if (aUsesSpread && arr->Item(3).GetUnit() != eCSSUnit_Null) {
       unitOK = SetCoord(arr->Item(3), tempCoord, nsStyleCoord(),
-                        SETCOORD_LENGTH, aContext, mPresContext, inherited);
+                        SETCOORD_LENGTH, aContext, mPresContext,
+                        canStoreInRuleTree);
       NS_ASSERTION(unitOK, "unexpected unit");
       item->mSpread = tempCoord.GetCoordValue();
     } else {
       item->mSpread = 0;
     }
 
     if (arr->Item(4).GetUnit() != eCSSUnit_Null) {
       item->mHasColor = PR_TRUE;
       // 2nd argument can be bogus since inherit is not a valid color
       unitOK = SetColor(arr->Item(4), 0, mPresContext, aContext, item->mColor,
-                        inherited);
+                        canStoreInRuleTree);
       NS_ASSERTION(unitOK, "unexpected unit");
     }
   }
 
   NS_ADDREF(shadowList);
   return shadowList;
 }
 
 const void*
 nsRuleNode::ComputeTextData(void* aStartStruct,
                             const nsRuleDataStruct& aData, 
                             nsStyleContext* aContext, 
                             nsRuleNode* aHighestNode,
                             const RuleDetail aRuleDetail,
-                            const PRBool aInherited)
+                            const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Text, (), text, parentText, Text, textData)
 
     // letter-spacing: normal, length, inherit
   SetCoord(textData.mLetterSpacing, text->mLetterSpacing, parentText->mLetterSpacing,
            SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL,
-           aContext, mPresContext, inherited);
+           aContext, mPresContext, canStoreInRuleTree);
 
   // text-shadow: none, list, inherit, initial
   nsCSSValueList* list = textData.mTextShadow;
   if (list) {
     text->mTextShadow = nsnull;
 
     // Don't need to handle none/initial explicitly: The above assignment
     // takes care of that
     if (eCSSUnit_Inherit == list->mValue.GetUnit()) {
-      inherited = PR_FALSE;
+      canStoreInRuleTree = PR_FALSE;
       text->mTextShadow = parentText->mTextShadow;
     } else if (eCSSUnit_Array == list->mValue.GetUnit()) {
       // List of arrays
-      text->mTextShadow = GetShadowData(list, aContext, PR_FALSE, inherited);
+      text->mTextShadow = GetShadowData(list, aContext, PR_FALSE,
+                                        canStoreInRuleTree);
     }
   }
 
   // line-height: normal, number, length, percent, inherit
   if (eCSSUnit_Percent == textData.mLineHeight.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     // Use |mFont.size| to pick up minimum font size.
     text->mLineHeight.SetCoordValue(
         nscoord(float(aContext->GetStyleFont()->mFont.size) *
                 textData.mLineHeight.GetPercentValue()));
   }
   else if (eCSSUnit_Initial == textData.mLineHeight.GetUnit() ||
            eCSSUnit_System_Font == textData.mLineHeight.GetUnit()) {
     text->mLineHeight.SetNormalValue();
   }
   else {
     SetCoord(textData.mLineHeight, text->mLineHeight, parentText->mLineHeight,
              SETCOORD_LH | SETCOORD_FACTOR | SETCOORD_NORMAL,
-             aContext, mPresContext, inherited);
+             aContext, mPresContext, canStoreInRuleTree);
     if (textData.mLineHeight.IsFixedLengthUnit() ||
         textData.mLineHeight.GetUnit() == eCSSUnit_Pixel) {
       nscoord lh = nsStyleFont::ZoomText(mPresContext,
                                          text->mLineHeight.GetCoordValue());
       nscoord minimumFontSize =
         mPresContext->GetCachedIntPref(kPresContext_MinimumFontSize);
 
       if (minimumFontSize > 0 && !mPresContext->IsChrome()) {
         // If we applied a minimum font size, scale the line height by
         // the same ratio.  (If we *might* have applied a minimum font
         // size, we can't cache in the rule tree.)
-        inherited = PR_FALSE;
+        canStoreInRuleTree = PR_FALSE;
         const nsStyleFont *font = aContext->GetStyleFont();
         if (font->mSize != 0) {
           lh = nscoord(float(lh) * float(font->mFont.size) / float(font->mSize));
         } else {
           lh = minimumFontSize;
         }
       }
       text->mLineHeight.SetCoordValue(lh);
     }
   }
 
 
   // text-align: enum, string, inherit, initial
   if (eCSSUnit_String == textData.mTextAlign.GetUnit()) {
     NS_NOTYETIMPLEMENTED("align string");
   } else
-    SetDiscrete(textData.mTextAlign, text->mTextAlign, inherited,
+    SetDiscrete(textData.mTextAlign, text->mTextAlign, canStoreInRuleTree,
                 SETDSC_ENUMERATED, parentText->mTextAlign,
                 NS_STYLE_TEXT_ALIGN_DEFAULT,
                 0, 0, 0, 0);
 
   // text-indent: length, percent, inherit, initial
   SetCoord(textData.mTextIndent, text->mTextIndent, parentText->mTextIndent,
            SETCOORD_LPH | SETCOORD_INITIAL_ZERO, aContext,
-           mPresContext, inherited);
+           mPresContext, canStoreInRuleTree);
 
   // text-transform: enum, none, inherit, initial
-  SetDiscrete(textData.mTextTransform, text->mTextTransform, inherited,
+  SetDiscrete(textData.mTextTransform, text->mTextTransform, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NONE, parentText->mTextTransform,
               NS_STYLE_TEXT_TRANSFORM_NONE, 0,
               NS_STYLE_TEXT_TRANSFORM_NONE, 0, 0);
 
   // white-space: enum, normal, inherit, initial
-  SetDiscrete(textData.mWhiteSpace, text->mWhiteSpace, inherited,
+  SetDiscrete(textData.mWhiteSpace, text->mWhiteSpace, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NORMAL, parentText->mWhiteSpace,
               NS_STYLE_WHITESPACE_NORMAL, 0, 0,
               NS_STYLE_WHITESPACE_NORMAL, 0);
  
   // word-spacing: normal, length, inherit
   nsStyleCoord tempCoord;
   if (SetCoord(textData.mWordSpacing, tempCoord,
                nsStyleCoord(parentText->mWordSpacing),
                SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL,
-               aContext, mPresContext, inherited)) {
+               aContext, mPresContext, canStoreInRuleTree)) {
     if (tempCoord.GetUnit() == eStyleUnit_Coord) {
       text->mWordSpacing = tempCoord.GetCoordValue();
     } else if (tempCoord.GetUnit() == eStyleUnit_Normal) {
       text->mWordSpacing = 0;
     } else {
       NS_NOTREACHED("unexpected unit");
     }
   } else {
     NS_ASSERTION(textData.mWordSpacing.GetUnit() == eCSSUnit_Null,
                  "unexpected unit");
   }
 
   // word-wrap: enum, normal, inherit, initial
-  SetDiscrete(textData.mWordWrap, text->mWordWrap, inherited,
+  SetDiscrete(textData.mWordWrap, text->mWordWrap, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NORMAL, parentText->mWordWrap,
               NS_STYLE_WORDWRAP_NORMAL, 0, 0,
               NS_STYLE_WORDWRAP_NORMAL, 0);
 
   COMPUTE_END_INHERITED(Text, text)
 }
 
 const void*
 nsRuleNode::ComputeTextResetData(void* aStartStruct,
                                  const nsRuleDataStruct& aData, 
                                  nsStyleContext* aContext, 
                                  nsRuleNode* aHighestNode,
                                  const RuleDetail aRuleDetail,
-                                 const PRBool aInherited)
+                                 const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(TextReset, (), text, parentText, Text, textData)
   
   // vertical-align: enum, length, percent, inherit
   if (!SetCoord(textData.mVerticalAlign, text->mVerticalAlign,
                 parentText->mVerticalAlign, SETCOORD_LPH | SETCOORD_ENUMERATED,
-                aContext, mPresContext, inherited)) {
+                aContext, mPresContext, canStoreInRuleTree)) {
     if (eCSSUnit_Initial == textData.mVerticalAlign.GetUnit()) {
       text->mVerticalAlign.SetIntValue(NS_STYLE_VERTICAL_ALIGN_BASELINE,
                                        eStyleUnit_Enumerated);
     }
   }
 
   // text-decoration: none, enum (bit field), inherit, initial
   if (eCSSUnit_Enumerated == textData.mDecoration.GetUnit()) {
@@ -3130,52 +3140,52 @@ nsRuleNode::ComputeTextResetData(void* a
         text->mTextDecoration |= NS_STYLE_TEXT_DECORATION_UNDERLINE;
       }
       else {
         text->mTextDecoration &= ~NS_STYLE_TEXT_DECORATION_UNDERLINE;
       }
     }
   }
   else
-    SetDiscrete(textData.mDecoration, text->mTextDecoration, inherited,
-                SETDSC_NONE,
+    SetDiscrete(textData.mDecoration, text->mTextDecoration,
+                canStoreInRuleTree, SETDSC_NONE,
                 parentText->mTextDecoration,
                 NS_STYLE_TEXT_DECORATION_NONE, 0,
                 NS_STYLE_TEXT_DECORATION_NONE, 0, 0);
 
   // unicode-bidi: enum, normal, inherit, initial
-  SetDiscrete(textData.mUnicodeBidi, text->mUnicodeBidi, inherited,
+  SetDiscrete(textData.mUnicodeBidi, text->mUnicodeBidi, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NORMAL,
               parentText->mUnicodeBidi,
               NS_STYLE_UNICODE_BIDI_NORMAL, 0, 0,
               NS_STYLE_UNICODE_BIDI_NORMAL, 0);
 
   COMPUTE_END_RESET(TextReset, text)
 }
 
 const void*
 nsRuleNode::ComputeUserInterfaceData(void* aStartStruct,
                                      const nsRuleDataStruct& aData, 
                                      nsStyleContext* aContext, 
                                      nsRuleNode* aHighestNode,
                                      const RuleDetail aRuleDetail,
-                                     const PRBool aInherited)
+                                     const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(UserInterface, (), ui, parentUI,
                           UserInterface, uiData)
 
   // cursor: enum, auto, url, inherit
   nsCSSValueList*  list = uiData.mCursor;
   if (nsnull != list) {
     delete [] ui->mCursorArray;
     ui->mCursorArray = nsnull;
     ui->mCursorArrayLength = 0;
 
     if (eCSSUnit_Inherit == list->mValue.GetUnit()) {
-      inherited = PR_FALSE;
+      canStoreInRuleTree = PR_FALSE;
       ui->mCursor = parentUI->mCursor;
       ui->CopyCursorArrayFrom(*parentUI);
     }
     else if (eCSSUnit_Initial == list->mValue.GetUnit()) {
       ui->mCursor = NS_STYLE_CURSOR_AUTO;
     }
     else {
       // The parser will never create a list that is *all* URL values --
@@ -3219,33 +3229,33 @@ nsRuleNode::ComputeUserInterfaceData(voi
       }
       else if (eCSSUnit_Auto == list->mValue.GetUnit()) {
         ui->mCursor = NS_STYLE_CURSOR_AUTO;
       }
     }
   }
 
   // user-input: auto, none, enum, inherit, initial
-  SetDiscrete(uiData.mUserInput, ui->mUserInput, inherited,
+  SetDiscrete(uiData.mUserInput, ui->mUserInput, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NONE | SETDSC_AUTO,
               parentUI->mUserInput,
               NS_STYLE_USER_INPUT_AUTO,
               NS_STYLE_USER_INPUT_AUTO,
               NS_STYLE_USER_INPUT_NONE,
               0, 0);
 
   // user-modify: enum, inherit, initial
-  SetDiscrete(uiData.mUserModify, ui->mUserModify, inherited,
+  SetDiscrete(uiData.mUserModify, ui->mUserModify, canStoreInRuleTree,
               SETDSC_ENUMERATED,
               parentUI->mUserModify,
               NS_STYLE_USER_MODIFY_READ_ONLY, 
               0, 0, 0, 0);
 
   // user-focus: none, normal, enum, inherit, initial
-  SetDiscrete(uiData.mUserFocus, ui->mUserFocus, inherited,
+  SetDiscrete(uiData.mUserFocus, ui->mUserFocus, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NONE | SETDSC_NORMAL,
               parentUI->mUserFocus,
               NS_STYLE_USER_FOCUS_NONE,
               0,
               NS_STYLE_USER_FOCUS_NONE,
               NS_STYLE_USER_FOCUS_NORMAL,
               0);
 
@@ -3253,110 +3263,110 @@ nsRuleNode::ComputeUserInterfaceData(voi
 }
 
 const void*
 nsRuleNode::ComputeUIResetData(void* aStartStruct,
                                const nsRuleDataStruct& aData, 
                                nsStyleContext* aContext, 
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
-                               const PRBool aInherited)
+                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(UIReset, (), ui, parentUI, UserInterface, uiData)
   
   // user-select: auto, none, enum, inherit, initial
-  SetDiscrete(uiData.mUserSelect, ui->mUserSelect, inherited,
+  SetDiscrete(uiData.mUserSelect, ui->mUserSelect, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NONE | SETDSC_AUTO,
               parentUI->mUserSelect,
               NS_STYLE_USER_SELECT_AUTO,
               NS_STYLE_USER_SELECT_AUTO,
               NS_STYLE_USER_SELECT_NONE,
               0, 0);
 
   // ime-mode: auto, normal, enum, inherit, initial
-  SetDiscrete(uiData.mIMEMode, ui->mIMEMode, inherited,
+  SetDiscrete(uiData.mIMEMode, ui->mIMEMode, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NORMAL | SETDSC_AUTO,
               parentUI->mIMEMode,
               NS_STYLE_IME_MODE_AUTO,
               NS_STYLE_IME_MODE_AUTO,
               0,
               NS_STYLE_IME_MODE_NORMAL,
               0);
 
   // force-broken-image-icons: integer, inherit, initial
   SetDiscrete(uiData.mForceBrokenImageIcon, ui->mForceBrokenImageIcon,
-              inherited,
+              canStoreInRuleTree,
               SETDSC_INTEGER,
               parentUI->mForceBrokenImageIcon,
               0, 0, 0, 0, 0);
 
   // -moz-window-shadow: enum, none, inherit, initial
-  SetDiscrete(uiData.mWindowShadow, ui->mWindowShadow, inherited,
+  SetDiscrete(uiData.mWindowShadow, ui->mWindowShadow, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NONE, parentUI->mWindowShadow,
               NS_STYLE_WINDOW_SHADOW_DEFAULT, 0,
               NS_STYLE_WINDOW_SHADOW_NONE, 0, 0);
 
   COMPUTE_END_RESET(UIReset, ui)
 }
 
 /* Given a -moz-transform token stream, accumulates them into an
  * nsStyleTransformMatrix
  *
  * @param aList The nsCSSValueList of arrays to read into transform functions.
  * @param aContext The style context to use for unit conversion.
  * @param aPresContext The presentation context to use for unit conversion
- * @param aInherited If the value is inherited, this is set to PR_FALSE.
+ * @param aCanStoreInRuleTree This is set to PR_FALSE if the value cannot be stored in the rule tree.
  * @return An nsStyleTransformMatrix corresponding to the net transform.
  */
 static nsStyleTransformMatrix ReadTransforms(const nsCSSValueList* aList,
                                              nsStyleContext* aContext,
                                              nsPresContext* aPresContext,
-                                             PRBool &aInherited)
+                                             PRBool &aCanStoreInRuleTree)
 {
   nsStyleTransformMatrix result;
 
   for (const nsCSSValueList* curr = aList; curr != nsnull; curr = curr->mNext) {
     const nsCSSValue &currElem = curr->mValue;
     NS_ASSERTION(currElem.GetUnit() == eCSSUnit_Function,
                  "Stream should consist solely of functions!");
     NS_ASSERTION(currElem.GetArrayValue()->Count() >= 1,
                  "Incoming function is too short!");
 
     /* Read in a single transform matrix, then accumulate it with the total. */
     nsStyleTransformMatrix currMatrix;
     currMatrix.SetToTransformFunction(currElem.GetArrayValue(), aContext,
-                                      aPresContext, aInherited);
+                                      aPresContext, aCanStoreInRuleTree);
     result *= currMatrix;
   }
   return result;
 }
 
 const void*
 nsRuleNode::ComputeDisplayData(void* aStartStruct,
                                const nsRuleDataStruct& aData, 
                                nsStyleContext* aContext, 
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
-                               const PRBool aInherited)
+                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Display, (), display, parentDisplay,
                       Display, displayData)
 
   // opacity: factor, inherit, initial
-  SetFactor(displayData.mOpacity, display->mOpacity, inherited,
+  SetFactor(displayData.mOpacity, display->mOpacity, canStoreInRuleTree,
             parentDisplay->mOpacity, 1.0f, SETFCT_OPACITY);
 
   // display: enum, none, inherit, initial
-  SetDiscrete(displayData.mDisplay, display->mDisplay, inherited,
+  SetDiscrete(displayData.mDisplay, display->mDisplay, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NONE, parentDisplay->mDisplay,
               NS_STYLE_DISPLAY_INLINE, 0,
               NS_STYLE_DISPLAY_NONE, 0, 0);
 
   // appearance: enum, none, inherit, initial
-  SetDiscrete(displayData.mAppearance, display->mAppearance, inherited,
+  SetDiscrete(displayData.mAppearance, display->mAppearance, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NONE, parentDisplay->mAppearance,
               NS_THEME_NONE, 0,
               NS_THEME_NONE, 0, 0);
 
   // binding: url, none, inherit
   if (eCSSUnit_URL == displayData.mBinding.GetUnit()) {
     nsCSSValue::URL* url = displayData.mBinding.GetURLStructValue();
     NS_ASSERTION(url, "What's going on here?");
@@ -3367,27 +3377,27 @@ nsRuleNode::ComputeDisplayData(void* aSt
       display->mBinding = nsnull;
     }
   }
   else if (eCSSUnit_None == displayData.mBinding.GetUnit() ||
            eCSSUnit_Initial == displayData.mBinding.GetUnit()) {
     display->mBinding = nsnull;
   }
   else if (eCSSUnit_Inherit == displayData.mBinding.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     display->mBinding = parentDisplay->mBinding;
   }
 
   // position: enum, inherit, initial
-  SetDiscrete(displayData.mPosition, display->mPosition, inherited,
+  SetDiscrete(displayData.mPosition, display->mPosition, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentDisplay->mPosition,
               NS_STYLE_POSITION_STATIC, 0, 0, 0, 0);
 
   // clear: enum, none, inherit, initial
-  SetDiscrete(displayData.mClear, display->mBreakType, inherited,
+  SetDiscrete(displayData.mClear, display->mBreakType, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NONE, parentDisplay->mBreakType,
               NS_STYLE_CLEAR_NONE, 0,
               NS_STYLE_CLEAR_NONE, 0, 0);
 
   // temp fix for bug 24000
   // Map 'auto' and 'avoid' to PR_FALSE, and 'always', 'left', and
   // 'right' to PR_TRUE.
   // "A conforming user agent may interpret the values 'left' and
@@ -3395,66 +3405,66 @@ nsRuleNode::ComputeDisplayData(void* aSt
   if (eCSSUnit_Enumerated == displayData.mBreakBefore.GetUnit()) {
     display->mBreakBefore = (NS_STYLE_PAGE_BREAK_AVOID != displayData.mBreakBefore.GetIntValue());
   }
   else if (eCSSUnit_Auto == displayData.mBreakBefore.GetUnit() ||
            eCSSUnit_Initial == displayData.mBreakBefore.GetUnit()) {
     display->mBreakBefore = PR_FALSE;
   }
   else if (eCSSUnit_Inherit == displayData.mBreakBefore.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     display->mBreakBefore = parentDisplay->mBreakBefore;
   }
 
   if (eCSSUnit_Enumerated == displayData.mBreakAfter.GetUnit()) {
     display->mBreakAfter = (NS_STYLE_PAGE_BREAK_AVOID != displayData.mBreakAfter.GetIntValue());
   }
   else if (eCSSUnit_Auto == displayData.mBreakAfter.GetUnit() ||
            eCSSUnit_Initial == displayData.mBreakAfter.GetUnit()) {
     display->mBreakAfter = PR_FALSE;
   }
   else if (eCSSUnit_Inherit == displayData.mBreakAfter.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     display->mBreakAfter = parentDisplay->mBreakAfter;
   }
   // end temp fix
 
   // float: enum, none, inherit, initial
-  SetDiscrete(displayData.mFloat, display->mFloats, inherited,
+  SetDiscrete(displayData.mFloat, display->mFloats, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NONE, parentDisplay->mFloats,
               NS_STYLE_FLOAT_NONE, 0,
               NS_STYLE_FLOAT_NONE, 0, 0);
 
   // overflow-x: enum, auto, inherit, initial
-  SetDiscrete(displayData.mOverflowX, display->mOverflowX, inherited,
+  SetDiscrete(displayData.mOverflowX, display->mOverflowX, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_AUTO,
               parentDisplay->mOverflowX,
               NS_STYLE_OVERFLOW_VISIBLE,
               NS_STYLE_OVERFLOW_AUTO,
               0, 0, 0);
 
   // overflow-y: enum, auto, inherit, initial
-  SetDiscrete(displayData.mOverflowY, display->mOverflowY, inherited,
+  SetDiscrete(displayData.mOverflowY, display->mOverflowY, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_AUTO,
               parentDisplay->mOverflowY,
               NS_STYLE_OVERFLOW_VISIBLE,
               NS_STYLE_OVERFLOW_AUTO,
               0, 0, 0);
 
   // CSS3 overflow-x and overflow-y require some fixup as well in some
   // cases.  NS_STYLE_OVERFLOW_VISIBLE and NS_STYLE_OVERFLOW_CLIP are
   // meaningful only when used in both dimensions.
   if (display->mOverflowX != display->mOverflowY &&
       (display->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE ||
        display->mOverflowX == NS_STYLE_OVERFLOW_CLIP ||
        display->mOverflowY == NS_STYLE_OVERFLOW_VISIBLE ||
        display->mOverflowY == NS_STYLE_OVERFLOW_CLIP)) {
     // We can't store in the rule tree since a more specific rule might
     // change these conditions.
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
 
     // NS_STYLE_OVERFLOW_CLIP is a deprecated value, so if it's specified
     // in only one dimension, convert it to NS_STYLE_OVERFLOW_HIDDEN.
     if (display->mOverflowX == NS_STYLE_OVERFLOW_CLIP)
       display->mOverflowX = NS_STYLE_OVERFLOW_HIDDEN;
     if (display->mOverflowY == NS_STYLE_OVERFLOW_CLIP)
       display->mOverflowY = NS_STYLE_OVERFLOW_HIDDEN;
 
@@ -3463,17 +3473,17 @@ nsRuleNode::ComputeDisplayData(void* aSt
     if (display->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE)
       display->mOverflowX = NS_STYLE_OVERFLOW_AUTO;
     if (display->mOverflowY == NS_STYLE_OVERFLOW_VISIBLE)
       display->mOverflowY = NS_STYLE_OVERFLOW_AUTO;
   }
 
   // clip property: length, auto, inherit
   if (eCSSUnit_Inherit == displayData.mClip.mTop.GetUnit()) { // if one is inherit, they all are
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     display->mClipFlags = parentDisplay->mClipFlags;
     display->mClip = parentDisplay->mClip;
   }
   // if one is initial or auto (rect), they all are
   else if (eCSSUnit_Initial == displayData.mClip.mTop.GetUnit() ||
            eCSSUnit_RectIsAuto == displayData.mClip.mTop.GetUnit()) {
     display->mClipFlags = NS_STYLE_CLIP_AUTO;
     display->mClip.SetRect(0,0,0,0);
@@ -3481,45 +3491,49 @@ nsRuleNode::ComputeDisplayData(void* aSt
   else if (eCSSUnit_Null != displayData.mClip.mTop.GetUnit()) {
     display->mClipFlags = 0; // clear it
 
     if (eCSSUnit_Auto == displayData.mClip.mTop.GetUnit()) {
       display->mClip.y = 0;
       display->mClipFlags |= NS_STYLE_CLIP_TOP_AUTO;
     } 
     else if (displayData.mClip.mTop.IsLengthUnit()) {
-      display->mClip.y = CalcLength(displayData.mClip.mTop, aContext, mPresContext, inherited);
+      display->mClip.y = CalcLength(displayData.mClip.mTop, aContext,
+                                    mPresContext, canStoreInRuleTree);
     }
     if (eCSSUnit_Auto == displayData.mClip.mBottom.GetUnit()) {
       // Setting to NS_MAXSIZE for the 'auto' case ensures that
       // the clip rect is nonempty. It is important that mClip be
       // nonempty if the actual clip rect could be nonempty.
       display->mClip.height = NS_MAXSIZE;
       display->mClipFlags |= NS_STYLE_CLIP_BOTTOM_AUTO;
     } 
     else if (displayData.mClip.mBottom.IsLengthUnit()) {
-      display->mClip.height = CalcLength(displayData.mClip.mBottom, aContext, mPresContext, inherited) -
+      display->mClip.height = CalcLength(displayData.mClip.mBottom, aContext,
+                                         mPresContext, canStoreInRuleTree) -
                               display->mClip.y;
     }
     if (eCSSUnit_Auto == displayData.mClip.mLeft.GetUnit()) {
       display->mClip.x = 0;
       display->mClipFlags |= NS_STYLE_CLIP_LEFT_AUTO;
     } 
     else if (displayData.mClip.mLeft.IsLengthUnit()) {
-      display->mClip.x = CalcLength(displayData.mClip.mLeft, aContext, mPresContext, inherited);
+      display->mClip.x = CalcLength(displayData.mClip.mLeft, aContext,
+                                    mPresContext, canStoreInRuleTree);
     }
     if (eCSSUnit_Auto == displayData.mClip.mRight.GetUnit()) {
       // Setting to NS_MAXSIZE for the 'auto' case ensures that
       // the clip rect is nonempty. It is important that mClip be
       // nonempty if the actual clip rect could be nonempty.
       display->mClip.width = NS_MAXSIZE;
       display->mClipFlags |= NS_STYLE_CLIP_RIGHT_AUTO;
     } 
     else if (displayData.mClip.mRight.IsLengthUnit()) {
-      display->mClip.width = CalcLength(displayData.mClip.mRight, aContext, mPresContext, inherited) -
+      display->mClip.width = CalcLength(displayData.mClip.mRight, aContext,
+                                        mPresContext, canStoreInRuleTree) -
                              display->mClip.x;
     }
     display->mClipFlags &= ~NS_STYLE_CLIP_TYPE_MASK;
     display->mClipFlags |= NS_STYLE_CLIP_RECT;
   }
 
   if (display->mDisplay != NS_STYLE_DISPLAY_NONE) {
     // CSS2 9.7 specifies display type corrections dealing with 'float'
@@ -3529,44 +3543,44 @@ nsRuleNode::ComputeDisplayData(void* aSt
     if (nsCSSPseudoElements::firstLetter == aContext->GetPseudoType()) {
       // a non-floating first-letter must be inline
       // XXX this fix can go away once bug 103189 is fixed correctly
       display->mDisplay = NS_STYLE_DISPLAY_INLINE;
 
       // We can't cache the data in the rule tree since if a more specific
       // rule has 'float: left' we'll end up with the wrong 'display'
       // property.
-      inherited = PR_FALSE;
+      canStoreInRuleTree = PR_FALSE;
     }
 
     if (display->IsAbsolutelyPositioned()) {
       // 1) if position is 'absolute' or 'fixed' then display must be
       // block-level and float must be 'none'
 
       // Backup original display value for calculation of a hypothetical
       // box (CSS2 10.6.4/10.6.5).
       // See nsHTMLReflowState::CalculateHypotheticalBox
       display->mOriginalDisplay = display->mDisplay;
       EnsureBlockDisplay(display->mDisplay);
       display->mFloats = NS_STYLE_FLOAT_NONE;
 
       // We can't cache the data in the rule tree since if a more specific
       // rule has 'position: static' we'll end up with problems with the
       // 'display' and 'float' properties.
-      inherited = PR_FALSE;
+      canStoreInRuleTree = PR_FALSE;
     } else if (display->mFloats != NS_STYLE_FLOAT_NONE) {
       // 2) if float is not none, and display is not none, then we must
       // set a block-level 'display' type per CSS2.1 section 9.7.
 
       EnsureBlockDisplay(display->mDisplay);
 
       // We can't cache the data in the rule tree since if a more specific
       // rule has 'float: none' we'll end up with the wrong 'display'
       // property.
-      inherited = PR_FALSE;
+      canStoreInRuleTree = PR_FALSE;
     }
 
   }
   
   /* Convert the nsCSSValueList into an nsTArray<nsTransformFunction *>. */
   const nsCSSValueList *head = displayData.mTransform;
   
   if (head != nsnull) {
@@ -3579,30 +3593,30 @@ nsRuleNode::ComputeDisplayData(void* aSt
     if (head->mValue.GetUnit() == eCSSUnit_None)
       display->mTransformPresent = PR_FALSE;
     
     /* If we need to inherit, do so by making a full deep-copy. */
     else if (head->mValue.GetUnit() == eCSSUnit_Inherit)  {
       display->mTransformPresent = parentDisplay->mTransformPresent;
       if (parentDisplay->mTransformPresent)
         display->mTransform = parentDisplay->mTransform;
-      inherited = PR_FALSE;
+      canStoreInRuleTree = PR_FALSE;
     }
     /* If it's 'initial', then we reset to empty. */
     else if (head->mValue.GetUnit() == eCSSUnit_Initial)
       display->mTransformPresent = PR_FALSE;
     
     /* Otherwise, we are looking at a list of CSS tokens.  We'll read each of
      * them in as an array of nsTransformFunction objects, then will accumulate
      * them all together to form the final transform matrix.
      */
     else {
  
       display->mTransform = 
-        ReadTransforms(head, aContext, mPresContext, inherited);
+        ReadTransforms(head, aContext, mPresContext, canStoreInRuleTree);
 
       /* Make sure to say that this data is valid! */
       display->mTransformPresent = PR_TRUE;
     }
   }
   
   /* Convert -moz-transform-origin. */
   if (displayData.mTransformOrigin.mXValue.GetUnit() != eCSSUnit_Null ||
@@ -3617,17 +3631,17 @@ nsRuleNode::ComputeDisplayData(void* aSt
       /* Convert lengths, percents, and inherit.  Default value is 50%. */
 #ifdef DEBUG
       PRBool result =
 #endif
         SetCoord(displayData.mTransformOrigin.mXValue,
                  display->mTransformOrigin[0],
                  parentDisplay->mTransformOrigin[0],
                  SETCOORD_LPH | SETCOORD_INITIAL_HALF,
-                 aContext, mPresContext, inherited);
+                 aContext, mPresContext, canStoreInRuleTree);
       NS_ASSERTION(result, "Malformed -moz-transform-origin parse!");
     }
 
     /* If Y coordinate is an enumerated type, handle it explicitly. */
     if (eCSSUnit_Enumerated == displayData.mTransformOrigin.mYValue.GetUnit())
       display->mTransformOrigin[1].SetPercentValue
         (GetFloatFromBoxPosition
          (displayData.mTransformOrigin.mYValue.GetIntValue()));
@@ -3635,46 +3649,48 @@ nsRuleNode::ComputeDisplayData(void* aSt
       /* Convert lengths, percents, initial, inherit. */
 #ifdef DEBUG
       PRBool result =
 #endif
         SetCoord(displayData.mTransformOrigin.mYValue,
                  display->mTransformOrigin[1],
                  parentDisplay->mTransformOrigin[1],
                  SETCOORD_LPH | SETCOORD_INITIAL_HALF,
-                 aContext, mPresContext, inherited);
+                 aContext, mPresContext, canStoreInRuleTree);
       NS_ASSERTION(result, "Malformed -moz-transform-origin parse!");
     }
   }
 
   COMPUTE_END_RESET(Display, display)
 }
 
 const void*
 nsRuleNode::ComputeVisibilityData(void* aStartStruct,
                                   const nsRuleDataStruct& aData, 
                                   nsStyleContext* aContext, 
                                   nsRuleNode* aHighestNode,
                                   const RuleDetail aRuleDetail,
-                                  const PRBool aInherited)
+                                  const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Visibility, (mPresContext),
                           visibility, parentVisibility,
                           Display, displayData)
 
   // direction: enum, inherit, initial
-  SetDiscrete(displayData.mDirection, visibility->mDirection, inherited,
+  SetDiscrete(displayData.mDirection, visibility->mDirection,
+              canStoreInRuleTree,
               SETDSC_ENUMERATED, parentVisibility->mDirection,
               (GET_BIDI_OPTION_DIRECTION(mPresContext->GetBidi())
                == IBMBIDI_TEXTDIRECTION_RTL)
               ? NS_STYLE_DIRECTION_RTL : NS_STYLE_DIRECTION_LTR,
               0, 0, 0, 0);
 
   // visibility: enum, inherit, initial
-  SetDiscrete(displayData.mVisibility, visibility->mVisible, inherited,
+  SetDiscrete(displayData.mVisibility, visibility->mVisible,
+              canStoreInRuleTree,
               SETDSC_ENUMERATED, parentVisibility->mVisible,
               NS_STYLE_VISIBILITY_VISIBLE, 0, 0, 0, 0);
 
   // lang: string, inherit
   // this is not a real CSS property, it is a html attribute mapped to CSS struture
   if (eCSSUnit_String == displayData.mLang.GetUnit()) {
     if (!gLangService) {
       CallGetService(NS_LANGUAGEATOMSERVICE_CONTRACTID, &gLangService);
@@ -3691,157 +3707,157 @@ nsRuleNode::ComputeVisibilityData(void* 
 }
 
 const void*
 nsRuleNode::ComputeColorData(void* aStartStruct,
                              const nsRuleDataStruct& aData, 
                              nsStyleContext* aContext, 
                              nsRuleNode* aHighestNode,
                              const RuleDetail aRuleDetail,
-                             const PRBool aInherited)
+                             const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Color, (mPresContext), color, parentColor,
                           Color, colorData)
 
   // color: color, string, inherit
   // Special case for currentColor.  According to CSS3, setting color to 'currentColor'
   // should behave as if it is inherited
   if (colorData.mColor.GetUnit() == eCSSUnit_EnumColor && 
       colorData.mColor.GetIntValue() == NS_COLOR_CURRENTCOLOR) {
     color->mColor = parentColor->mColor;
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
   }
   else if (colorData.mColor.GetUnit() == eCSSUnit_Initial) {
     color->mColor = mPresContext->DefaultColor();
   }
   else {
-    SetColor(colorData.mColor, parentColor->mColor, mPresContext, aContext, color->mColor, 
-             inherited);
+    SetColor(colorData.mColor, parentColor->mColor, mPresContext, aContext,
+             color->mColor, canStoreInRuleTree);
   }
 
   COMPUTE_END_INHERITED(Color, color)
 }
 
 const void*
 nsRuleNode::ComputeBackgroundData(void* aStartStruct,
                                   const nsRuleDataStruct& aData, 
                                   nsStyleContext* aContext, 
                                   nsRuleNode* aHighestNode,
                                   const RuleDetail aRuleDetail,
-                                  const PRBool aInherited)
+                                  const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Background, (), bg, parentBG, Color, colorData)
 
   // save parentFlags in case bg == parentBG and we clobber them later
   PRUint8 parentFlags = parentBG->mBackgroundFlags;
 
   // background-color: color, string, inherit
   if (eCSSUnit_Initial == colorData.mBackColor.GetUnit()) {
     bg->mBackgroundColor = NS_RGBA(0, 0, 0, 0);
   } else if (!SetColor(colorData.mBackColor, parentBG->mBackgroundColor,
                        mPresContext, aContext, bg->mBackgroundColor,
-                       inherited)) {
+                       canStoreInRuleTree)) {
     NS_ASSERTION(eCSSUnit_Null == colorData.mBackColor.GetUnit(),
                  "unexpected color unit");
   }
 
   // background-image: url (stored as image), none, inherit
   if (eCSSUnit_Image == colorData.mBackImage.GetUnit()) {
     bg->mBackgroundImage = colorData.mBackImage.GetImageValue();
   }
   else if (eCSSUnit_None == colorData.mBackImage.GetUnit() ||
            eCSSUnit_Initial == colorData.mBackImage.GetUnit()) {
     bg->mBackgroundImage = nsnull;
   }
   else if (eCSSUnit_Inherit == colorData.mBackImage.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     bg->mBackgroundImage = parentBG->mBackgroundImage;
   }
 
   if (bg->mBackgroundImage) {
     bg->mBackgroundFlags &= ~NS_STYLE_BG_IMAGE_NONE;
   } else {
     bg->mBackgroundFlags |= NS_STYLE_BG_IMAGE_NONE;
   }
 
   // background-repeat: enum, inherit, initial
-  SetDiscrete(colorData.mBackRepeat, bg->mBackgroundRepeat, inherited,
+  SetDiscrete(colorData.mBackRepeat, bg->mBackgroundRepeat, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentBG->mBackgroundRepeat,
               NS_STYLE_BG_REPEAT_XY, 0, 0, 0, 0);
 
   // background-attachment: enum, inherit, initial
-  SetDiscrete(colorData.mBackAttachment, bg->mBackgroundAttachment, inherited,
+  SetDiscrete(colorData.mBackAttachment, bg->mBackgroundAttachment, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentBG->mBackgroundAttachment,
               NS_STYLE_BG_ATTACHMENT_SCROLL, 0, 0, 0, 0);
 
   // background-clip: enum, inherit, initial
-  SetDiscrete(colorData.mBackClip, bg->mBackgroundClip, inherited,
+  SetDiscrete(colorData.mBackClip, bg->mBackgroundClip, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentBG->mBackgroundClip,
               NS_STYLE_BG_CLIP_BORDER, 0, 0, 0, 0);
 
   // background-inline-policy: enum, inherit, initial
   SetDiscrete(colorData.mBackInlinePolicy, bg->mBackgroundInlinePolicy,
-              inherited, SETDSC_ENUMERATED,
+              canStoreInRuleTree, SETDSC_ENUMERATED,
               parentBG->mBackgroundInlinePolicy,
               NS_STYLE_BG_INLINE_POLICY_CONTINUOUS, 0, 0, 0, 0);
 
   // background-origin: enum, inherit, initial
-  SetDiscrete(colorData.mBackOrigin, bg->mBackgroundOrigin, inherited,
+  SetDiscrete(colorData.mBackOrigin, bg->mBackgroundOrigin, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentBG->mBackgroundOrigin,
               NS_STYLE_BG_ORIGIN_PADDING, 0, 0, 0, 0);
 
   // background-position: enum, length, percent (flags), inherit
   if (eCSSUnit_Percent == colorData.mBackPosition.mXValue.GetUnit()) {
     bg->mBackgroundXPosition.mFloat = colorData.mBackPosition.mXValue.GetPercentValue();
     bg->mBackgroundFlags |= NS_STYLE_BG_X_POSITION_PERCENT;
     bg->mBackgroundFlags &= ~NS_STYLE_BG_X_POSITION_LENGTH;
   }
   else if (colorData.mBackPosition.mXValue.IsLengthUnit()) {
     bg->mBackgroundXPosition.mCoord = CalcLength(colorData.mBackPosition.mXValue, 
-                                                 aContext, mPresContext, inherited);
+                                                 aContext, mPresContext, canStoreInRuleTree);
     bg->mBackgroundFlags |= NS_STYLE_BG_X_POSITION_LENGTH;
     bg->mBackgroundFlags &= ~NS_STYLE_BG_X_POSITION_PERCENT;
   }
   else if (eCSSUnit_Enumerated == colorData.mBackPosition.mXValue.GetUnit()) {
     bg->mBackgroundXPosition.mFloat =
       GetFloatFromBoxPosition(colorData.mBackPosition.mXValue.GetIntValue());
 
     bg->mBackgroundFlags |= NS_STYLE_BG_X_POSITION_PERCENT;
     bg->mBackgroundFlags &= ~NS_STYLE_BG_X_POSITION_LENGTH;
   }
   else if (eCSSUnit_Inherit == colorData.mBackPosition.mXValue.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     bg->mBackgroundXPosition = parentBG->mBackgroundXPosition;
     bg->mBackgroundFlags &= ~(NS_STYLE_BG_X_POSITION_LENGTH | NS_STYLE_BG_X_POSITION_PERCENT);
     bg->mBackgroundFlags |= (parentFlags & (NS_STYLE_BG_X_POSITION_LENGTH | NS_STYLE_BG_X_POSITION_PERCENT));
   }
   else if (eCSSUnit_Initial == colorData.mBackPosition.mXValue.GetUnit()) {
     bg->mBackgroundFlags &= ~(NS_STYLE_BG_X_POSITION_LENGTH | NS_STYLE_BG_X_POSITION_PERCENT);
   }
 
   if (eCSSUnit_Percent == colorData.mBackPosition.mYValue.GetUnit()) {
     bg->mBackgroundYPosition.mFloat = colorData.mBackPosition.mYValue.GetPercentValue();
     bg->mBackgroundFlags |= NS_STYLE_BG_Y_POSITION_PERCENT;
     bg->mBackgroundFlags &= ~NS_STYLE_BG_Y_POSITION_LENGTH;
   }
   else if (colorData.mBackPosition.mYValue.IsLengthUnit()) {
     bg->mBackgroundYPosition.mCoord = CalcLength(colorData.mBackPosition.mYValue,
-                                                 aContext, mPresContext, inherited);
+                                                 aContext, mPresContext, canStoreInRuleTree);
     bg->mBackgroundFlags |= NS_STYLE_BG_Y_POSITION_LENGTH;
     bg->mBackgroundFlags &= ~NS_STYLE_BG_Y_POSITION_PERCENT;
   }
   else if (eCSSUnit_Enumerated == colorData.mBackPosition.mYValue.GetUnit()) {
     bg->mBackgroundYPosition.mFloat =
       GetFloatFromBoxPosition(colorData.mBackPosition.mYValue.GetIntValue());
 
     bg->mBackgroundFlags |= NS_STYLE_BG_Y_POSITION_PERCENT;
     bg->mBackgroundFlags &= ~NS_STYLE_BG_Y_POSITION_LENGTH;
   }
   else if (eCSSUnit_Inherit == colorData.mBackPosition.mYValue.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     bg->mBackgroundYPosition = parentBG->mBackgroundYPosition;
     bg->mBackgroundFlags &= ~(NS_STYLE_BG_Y_POSITION_LENGTH | NS_STYLE_BG_Y_POSITION_PERCENT);
     bg->mBackgroundFlags |= (parentFlags & (NS_STYLE_BG_Y_POSITION_LENGTH | NS_STYLE_BG_Y_POSITION_PERCENT));
   }
   else if (eCSSUnit_Initial == colorData.mBackPosition.mYValue.GetUnit()) {
     bg->mBackgroundFlags &= ~(NS_STYLE_BG_Y_POSITION_LENGTH | NS_STYLE_BG_Y_POSITION_PERCENT);
   }
 
@@ -3849,89 +3865,90 @@ nsRuleNode::ComputeBackgroundData(void* 
 }
 
 const void*
 nsRuleNode::ComputeMarginData(void* aStartStruct,
                               const nsRuleDataStruct& aData, 
                               nsStyleContext* aContext, 
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
-                              const PRBool aInherited)
+                              const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Margin, (), margin, parentMargin, Margin, marginData)
 
   // margin: length, percent, auto, inherit
   nsStyleCoord  coord;
   nsCSSRect ourMargin(marginData.mMargin);
   AdjustLogicalBoxProp(aContext,
                        marginData.mMarginLeftLTRSource,
                        marginData.mMarginLeftRTLSource,
                        marginData.mMarginStart, marginData.mMarginEnd,
-                       NS_SIDE_LEFT, ourMargin, inherited);
+                       NS_SIDE_LEFT, ourMargin, canStoreInRuleTree);
   AdjustLogicalBoxProp(aContext,
                        marginData.mMarginRightLTRSource,
                        marginData.mMarginRightRTLSource,
                        marginData.mMarginEnd, marginData.mMarginStart,
-                       NS_SIDE_RIGHT, ourMargin, inherited);
+                       NS_SIDE_RIGHT, ourMargin, canStoreInRuleTree);
   NS_FOR_CSS_SIDES(side) {
     nsStyleCoord parentCoord = parentMargin->mMargin.Get(side);
     if (SetCoord(ourMargin.*(nsCSSRect::sides[side]),
                  coord, parentCoord, SETCOORD_LPAH | SETCOORD_INITIAL_ZERO,
-                 aContext, mPresContext, inherited)) {
+                 aContext, mPresContext, canStoreInRuleTree)) {
       margin->mMargin.Set(side, coord);
     }
   }
 
   margin->RecalcData();
   COMPUTE_END_RESET(Margin, margin)
 }
 
 const void* 
 nsRuleNode::ComputeBorderData(void* aStartStruct,
                               const nsRuleDataStruct& aData, 
                               nsStyleContext* aContext, 
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
-                              const PRBool aInherited)
+                              const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Border, (mPresContext), border, parentBorder,
                       Margin, marginData)
 
   // -moz-box-shadow: none, list, inherit, initial
   {
     nsCSSValueList* list = marginData.mBoxShadow;
     if (list) {
       // This handles 'none' and 'initial'
       border->mBoxShadow = nsnull;
 
       if (eCSSUnit_Inherit == list->mValue.GetUnit()) {
-        inherited = PR_FALSE;
+        canStoreInRuleTree = PR_FALSE;
         border->mBoxShadow = parentBorder->mBoxShadow;
       } else if (eCSSUnit_Array == list->mValue.GetUnit()) {
         // List of arrays
-        border->mBoxShadow = GetShadowData(list, aContext, PR_TRUE, inherited);
+        border->mBoxShadow = GetShadowData(list, aContext, PR_TRUE,
+                                           canStoreInRuleTree);
       }
     }
   }
 
   // border-width, border-*-width: length, enum, inherit
   nsStyleCoord  coord;
   nsCSSRect ourBorderWidth(marginData.mBorderWidth);
   AdjustLogicalBoxProp(aContext,
                        marginData.mBorderLeftWidthLTRSource,
                        marginData.mBorderLeftWidthRTLSource,
                        marginData.mBorderStartWidth,
                        marginData.mBorderEndWidth,
-                       NS_SIDE_LEFT, ourBorderWidth, inherited);
+                       NS_SIDE_LEFT, ourBorderWidth, canStoreInRuleTree);
   AdjustLogicalBoxProp(aContext,
                        marginData.mBorderRightWidthLTRSource,
                        marginData.mBorderRightWidthRTLSource,
                        marginData.mBorderEndWidth,
                        marginData.mBorderStartWidth,
-                       NS_SIDE_RIGHT, ourBorderWidth, inherited);
+                       NS_SIDE_RIGHT, ourBorderWidth, canStoreInRuleTree);
   { // scope for compilers with broken |for| loop scoping
     NS_FOR_CSS_SIDES(side) {
       const nsCSSValue &value = ourBorderWidth.*(nsCSSRect::sides[side]);
       NS_ASSERTION(eCSSUnit_Percent != value.GetUnit(),
                    "Percentage borders not implemented yet "
                    "If implementing, make sure to fix all consumers of "
                    "nsStyleBorder, the IsPercentageAwareChild method, "
                    "the nsAbsoluteContainingBlock::FrameDependsOnContainer "
@@ -3943,22 +3960,22 @@ nsRuleNode::ComputeBorderData(void* aSta
                      value.GetIntValue() == NS_STYLE_BORDER_WIDTH_MEDIUM ||
                      value.GetIntValue() == NS_STYLE_BORDER_WIDTH_THICK,
                      "Unexpected enum value");
         border->SetBorderWidth(side,
                                (mPresContext->GetBorderWidthTable())[value.GetIntValue()]);
       }
       // OK to pass bad aParentCoord since we're not passing SETCOORD_INHERIT
       else if (SetCoord(value, coord, nsStyleCoord(), SETCOORD_LENGTH,
-                        aContext, mPresContext, inherited)) {
+                        aContext, mPresContext, canStoreInRuleTree)) {
         NS_ASSERTION(coord.GetUnit() == eStyleUnit_Coord, "unexpected unit");
         border->SetBorderWidth(side, coord.GetCoordValue());
       }
       else if (eCSSUnit_Inherit == value.GetUnit()) {
-        inherited = PR_FALSE;
+        canStoreInRuleTree = PR_FALSE;
         border->SetBorderWidth(side,
                                parentBorder->GetComputedBorder().side(side));
       }
       else if (eCSSUnit_Initial == value.GetUnit()) {
         border->SetBorderWidth(side,
           (mPresContext->GetBorderWidthTable())[NS_STYLE_BORDER_WIDTH_MEDIUM]);
       }
       else {
@@ -3969,34 +3986,34 @@ nsRuleNode::ComputeBorderData(void* aSta
   }
 
   // border-style, border-*-style: enum, none, inherit
   nsCSSRect ourStyle(marginData.mBorderStyle);
   AdjustLogicalBoxProp(aContext,
                        marginData.mBorderLeftStyleLTRSource,
                        marginData.mBorderLeftStyleRTLSource,
                        marginData.mBorderStartStyle, marginData.mBorderEndStyle,
-                       NS_SIDE_LEFT, ourStyle, inherited);
+                       NS_SIDE_LEFT, ourStyle, canStoreInRuleTree);
   AdjustLogicalBoxProp(aContext,
                        marginData.mBorderRightStyleLTRSource,
                        marginData.mBorderRightStyleRTLSource,
                        marginData.mBorderEndStyle, marginData.mBorderStartStyle,
-                       NS_SIDE_RIGHT, ourStyle, inherited);
+                       NS_SIDE_RIGHT, ourStyle, canStoreInRuleTree);
   { // scope for compilers with broken |for| loop scoping
     NS_FOR_CSS_SIDES(side) {
       const nsCSSValue &value = ourStyle.*(nsCSSRect::sides[side]);
       nsCSSUnit unit = value.GetUnit();
       if (eCSSUnit_Enumerated == unit) {
         border->SetBorderStyle(side, value.GetIntValue());
       }
       else if (eCSSUnit_None == unit || eCSSUnit_Initial == unit) {
         border->SetBorderStyle(side, NS_STYLE_BORDER_STYLE_NONE);
       }
       else if (eCSSUnit_Inherit == unit) {
-        inherited = PR_FALSE;
+        canStoreInRuleTree = PR_FALSE;
         border->SetBorderStyle(side, parentBorder->GetBorderStyle(side));
       }
     }
   }
 
   // -moz-border-*-colors: color, string, enum, none, inherit/initial
   nscolor borderColor;
   nscolor unused = NS_RGB(0,0,0);
@@ -4025,17 +4042,17 @@ nsRuleNode::ComputeBorderData(void* aSta
         }
         else {
           // Some composite border color information has been specified for this
           // border side.
           border->EnsureBorderColors();
           border->ClearBorderColors(side);
           while (list) {
             if (SetColor(list->mValue, unused, mPresContext,
-                         aContext, borderColor, inherited))
+                         aContext, borderColor, canStoreInRuleTree))
               border->AppendBorderColor(side, borderColor);
             else {
               NS_NOTREACHED("unexpected item in -moz-border-*-colors list");
             }
             list = list->mNext;
           }
         }
       }
@@ -4044,44 +4061,45 @@ nsRuleNode::ComputeBorderData(void* aSta
 
   // border-color, border-*-color: color, string, enum, inherit
   nsCSSRect ourBorderColor(marginData.mBorderColor);
   PRBool foreground;
   AdjustLogicalBoxProp(aContext,
                        marginData.mBorderLeftColorLTRSource,
                        marginData.mBorderLeftColorRTLSource,
                        marginData.mBorderStartColor, marginData.mBorderEndColor,
-                       NS_SIDE_LEFT, ourBorderColor, inherited);
+                       NS_SIDE_LEFT, ourBorderColor, canStoreInRuleTree);
   AdjustLogicalBoxProp(aContext,
                        marginData.mBorderRightColorLTRSource,
                        marginData.mBorderRightColorRTLSource,
                        marginData.mBorderEndColor, marginData.mBorderStartColor,
-                       NS_SIDE_RIGHT, ourBorderColor, inherited);
+                       NS_SIDE_RIGHT, ourBorderColor, canStoreInRuleTree);
   { // scope for compilers with broken |for| loop scoping
     NS_FOR_CSS_SIDES(side) {
       const nsCSSValue &value = ourBorderColor.*(nsCSSRect::sides[side]);
       if (eCSSUnit_Inherit == value.GetUnit()) {
         if (parentContext) {
-          inherited = PR_FALSE;
+          canStoreInRuleTree = PR_FALSE;
           parentBorder->GetBorderColor(side, borderColor, foreground);
           if (foreground) {
             // We want to inherit the color from the parent, not use the
             // color on the element where this chunk of style data will be
             // used.  We can ensure that the data for the parent are fully
             // computed (unlike for the element where this will be used, for
             // which the color could be specified on a more specific rule).
             border->SetBorderColor(side, parentContext->GetStyleColor()->mColor);
           } else
             border->SetBorderColor(side, borderColor);
         } else {
           // We're the root
           border->SetBorderToForeground(side);
         }
       }
-      else if (SetColor(value, unused, mPresContext, aContext, borderColor, inherited)) {
+      else if (SetColor(value, unused, mPresContext, aContext, borderColor,
+                        canStoreInRuleTree)) {
         border->SetBorderColor(side, borderColor);
       }
       else if (eCSSUnit_Enumerated == value.GetUnit()) {
         switch (value.GetIntValue()) {
           case NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR:
             border->SetBorderToForeground(side);
             break;
         }
@@ -4094,23 +4112,23 @@ nsRuleNode::ComputeBorderData(void* aSta
 
   // -moz-border-radius: length, percent, inherit
   {
     const nsCSSCornerSizes& borderRadius = marginData.mBorderRadius;
     NS_FOR_CSS_HALF_CORNERS(corner) {
       nsStyleCoord parentCoord = parentBorder->mBorderRadius.Get(corner);
       if (SetCoord(borderRadius.GetHalfCorner(corner),
                    coord, parentCoord, SETCOORD_LPH | SETCOORD_INITIAL_ZERO,
-                   aContext, mPresContext, inherited))
+                   aContext, mPresContext, canStoreInRuleTree))
         border->mBorderRadius.Set(corner, coord);
     }
   }
 
   // float-edge: enum, inherit, initial
-  SetDiscrete(marginData.mFloatEdge, border->mFloatEdge, inherited,
+  SetDiscrete(marginData.mFloatEdge, border->mFloatEdge, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentBorder->mFloatEdge,
               NS_STYLE_FLOAT_EDGE_CONTENT, 0, 0, 0, 0);
   
   // border-image
   if (eCSSUnit_Array == marginData.mBorderImage.GetUnit()) {
     nsCSSValue::Array *arr = marginData.mBorderImage.GetArrayValue();
     
     // the image
@@ -4118,28 +4136,29 @@ nsRuleNode::ComputeBorderData(void* aSta
       border->SetBorderImage(arr->Item(0).GetImageValue());
     }
     
     // the numbers saying where to split the image
     NS_FOR_CSS_SIDES(side) {
       // an uninitialized parentCoord is ok because I'm not passing SETCOORD_INHERIT
       if (SetCoord(arr->Item(1 + side), coord, nsStyleCoord(),
                    SETCOORD_FACTOR | SETCOORD_PERCENT, aContext,
-                   mPresContext, inherited)) {
+                   mPresContext, canStoreInRuleTree)) {
         border->mBorderImageSplit.Set(side, coord);
       }
     }
     
     // possible replacement for border-width
     // if have one - have all four (see CSSParserImpl::ParseBorderImage())
     if (eCSSUnit_Null != arr->Item(5).GetUnit()) {
       NS_FOR_CSS_SIDES(side) {
         // an uninitialized parentCoord is ok because I'm not passing SETCOORD_INHERIT
         if (!SetCoord(arr->Item(5 + side), coord, nsStyleCoord(),
-                      SETCOORD_LENGTH, aContext, mPresContext, inherited)) {
+                      SETCOORD_LENGTH, aContext, mPresContext,
+                      canStoreInRuleTree)) {
           NS_NOTREACHED("SetCoord for border-width replacement from border-image failed");
         }
         if (coord.GetUnit() == eStyleUnit_Coord) {
           border->SetBorderImageWidthOverride(side, coord.GetCoordValue());
         } else {
           NS_WARNING("a border-width replacement from border-image "
                      "has a unit that's not eStyleUnit_Coord");
           border->SetBorderImageWidthOverride(side, 0);
@@ -4185,86 +4204,86 @@ nsRuleNode::ComputeBorderData(void* aSta
 }
   
 const void*
 nsRuleNode::ComputePaddingData(void* aStartStruct,
                                const nsRuleDataStruct& aData, 
                                nsStyleContext* aContext, 
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
-                               const PRBool aInherited)
+                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Padding, (), padding, parentPadding, Margin, marginData)
 
   // padding: length, percent, inherit
   nsStyleCoord  coord;
   nsCSSRect ourPadding(marginData.mPadding);
   AdjustLogicalBoxProp(aContext,
                        marginData.mPaddingLeftLTRSource,
                        marginData.mPaddingLeftRTLSource,
                        marginData.mPaddingStart, marginData.mPaddingEnd,
-                       NS_SIDE_LEFT, ourPadding, inherited);
+                       NS_SIDE_LEFT, ourPadding, canStoreInRuleTree);
   AdjustLogicalBoxProp(aContext,
                        marginData.mPaddingRightLTRSource,
                        marginData.mPaddingRightRTLSource,
                        marginData.mPaddingEnd, marginData.mPaddingStart,
-                       NS_SIDE_RIGHT, ourPadding, inherited);
+                       NS_SIDE_RIGHT, ourPadding, canStoreInRuleTree);
   NS_FOR_CSS_SIDES(side) {
     nsStyleCoord parentCoord = parentPadding->mPadding.Get(side);
     if (SetCoord(ourPadding.*(nsCSSRect::sides[side]),
                  coord, parentCoord, SETCOORD_LPH | SETCOORD_INITIAL_ZERO,
-                 aContext, mPresContext, inherited)) {
+                 aContext, mPresContext, canStoreInRuleTree)) {
       padding->mPadding.Set(side, coord);
     }
   }
 
   padding->RecalcData();
   COMPUTE_END_RESET(Padding, padding)
 }
 
 const void*
 nsRuleNode::ComputeOutlineData(void* aStartStruct,
                                const nsRuleDataStruct& aData, 
                                nsStyleContext* aContext, 
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
-                               const PRBool aInherited)
+                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Outline, (mPresContext), outline, parentOutline,
                       Margin, marginData)
 
   // outline-width: length, enum, inherit
   if (eCSSUnit_Initial == marginData.mOutlineWidth.GetUnit()) {
     outline->mOutlineWidth =
       nsStyleCoord(NS_STYLE_BORDER_WIDTH_MEDIUM, eStyleUnit_Enumerated);
   }
   else {
     SetCoord(marginData.mOutlineWidth, outline->mOutlineWidth,
              parentOutline->mOutlineWidth, SETCOORD_LEH, aContext,
-             mPresContext, inherited);
+             mPresContext, canStoreInRuleTree);
   }
 
   // outline-offset: length, inherit
   nsStyleCoord tempCoord;
   if (SetCoord(marginData.mOutlineOffset, tempCoord,
                parentOutline->mOutlineOffset,
                SETCOORD_LH | SETCOORD_INITIAL_ZERO, aContext, mPresContext,
-               inherited)) {
+               canStoreInRuleTree)) {
     outline->mOutlineOffset = tempCoord.GetCoordValue();
   } else {
     NS_ASSERTION(marginData.mOutlineOffset.GetUnit() == eCSSUnit_Null,
                  "unexpected unit");
   }
 
   // outline-color: color, string, enum, inherit
   nscolor outlineColor;
   nscolor unused = NS_RGB(0,0,0);
   if (eCSSUnit_Inherit == marginData.mOutlineColor.GetUnit()) {
     if (parentContext) {
-      inherited = PR_FALSE;
+      canStoreInRuleTree = PR_FALSE;
       if (parentOutline->GetOutlineColor(outlineColor))
         outline->SetOutlineColor(outlineColor);
       else {
 #ifdef GFX_HAS_INVERT
         outline->SetOutlineInitialColor();
 #else
         // We want to inherit the color from the parent, not use the
         // color on the element where this chunk of style data will be
@@ -4273,197 +4292,206 @@ nsRuleNode::ComputeOutlineData(void* aSt
         // which the color could be specified on a more specific rule).
         outline->SetOutlineColor(parentContext->GetStyleColor()->mColor);
 #endif
       }
     } else {
       outline->SetOutlineInitialColor();
     }
   }
-  else if (SetColor(marginData.mOutlineColor, unused, mPresContext, aContext, outlineColor, inherited))
+  else if (SetColor(marginData.mOutlineColor, unused, mPresContext,
+                    aContext, outlineColor, canStoreInRuleTree))
     outline->SetOutlineColor(outlineColor);
   else if (eCSSUnit_Enumerated == marginData.mOutlineColor.GetUnit() ||
            eCSSUnit_Initial == marginData.mOutlineColor.GetUnit()) {
     outline->SetOutlineInitialColor();
   }
 
   // -moz-outline-radius: length, percent, inherit
   { 
     nsStyleCoord coord;
     const nsCSSCornerSizes& outlineRadius = marginData.mOutlineRadius;
     NS_FOR_CSS_HALF_CORNERS(corner) {
       nsStyleCoord parentCoord = parentOutline->mOutlineRadius.Get(corner);
       if (SetCoord(outlineRadius.GetHalfCorner(corner),
                    coord, parentCoord, SETCOORD_LPH | SETCOORD_INITIAL_ZERO,
-                   aContext, mPresContext, inherited))
+                   aContext, mPresContext, canStoreInRuleTree))
         outline->mOutlineRadius.Set(corner, coord);
     }
   }
 
   // outline-style: auto, enum, none, inherit, initial
   // cannot use SetDiscrete because of SetOutlineStyle
   if (eCSSUnit_Enumerated == marginData.mOutlineStyle.GetUnit())
     outline->SetOutlineStyle(marginData.mOutlineStyle.GetIntValue());
   else if (eCSSUnit_None == marginData.mOutlineStyle.GetUnit() ||
            eCSSUnit_Initial == marginData.mOutlineStyle.GetUnit())
     outline->SetOutlineStyle(NS_STYLE_BORDER_STYLE_NONE);
   else if (eCSSUnit_Auto == marginData.mOutlineStyle.GetUnit()) {
     outline->SetOutlineStyle(NS_STYLE_BORDER_STYLE_AUTO);
   } else if (eCSSUnit_Inherit == marginData.mOutlineStyle.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     outline->SetOutlineStyle(parentOutline->GetOutlineStyle());
   }
 
   outline->RecalcData(mPresContext);
   COMPUTE_END_RESET(Outline, outline)
 }
 
 const void* 
 nsRuleNode::ComputeListData(void* aStartStruct,
                             const nsRuleDataStruct& aData, 
                             nsStyleContext* aContext, 
                             nsRuleNode* aHighestNode,
                             const RuleDetail aRuleDetail,
-                            const PRBool aInherited)
+                            const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(List, (), list, parentList, List, listData)
 
   // list-style-type: enum, none, inherit, initial
-  SetDiscrete(listData.mType, list->mListStyleType, inherited,
+  SetDiscrete(listData.mType, list->mListStyleType, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NONE, parentList->mListStyleType,
               NS_STYLE_LIST_STYLE_DISC, 0,
               NS_STYLE_LIST_STYLE_NONE, 0, 0);
 
   // list-style-image: url, none, inherit
   if (eCSSUnit_Image == listData.mImage.GetUnit()) {
     list->mListStyleImage = listData.mImage.GetImageValue();
   }
   else if (eCSSUnit_None == listData.mImage.GetUnit() ||
            eCSSUnit_Initial == listData.mImage.GetUnit()) {
     list->mListStyleImage = nsnull;
   }
   else if (eCSSUnit_Inherit == listData.mImage.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     list->mListStyleImage = parentList->mListStyleImage;
   }
 
   // list-style-position: enum, inherit, initial
-  SetDiscrete(listData.mPosition, list->mListStylePosition, inherited,
+  SetDiscrete(listData.mPosition, list->mListStylePosition, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentList->mListStylePosition,
               NS_STYLE_LIST_STYLE_POSITION_OUTSIDE, 0, 0, 0, 0);
 
   // image region property: length, auto, inherit
   if (eCSSUnit_Inherit == listData.mImageRegion.mTop.GetUnit()) { // if one is inherit, they all are
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     list->mImageRegion = parentList->mImageRegion;
   }
   // if one is -moz-initial or auto (rect), they all are
   else if (eCSSUnit_Initial == listData.mImageRegion.mTop.GetUnit() ||
            eCSSUnit_RectIsAuto == listData.mImageRegion.mTop.GetUnit()) {
     list->mImageRegion.Empty();
   }
   else if (eCSSUnit_Null != listData.mImageRegion.mTop.GetUnit()) {
     if (eCSSUnit_Auto == listData.mImageRegion.mTop.GetUnit())
       list->mImageRegion.y = 0;
     else if (listData.mImageRegion.mTop.IsLengthUnit())
-      list->mImageRegion.y = CalcLength(listData.mImageRegion.mTop, aContext, mPresContext, inherited);
+      list->mImageRegion.y =
+        CalcLength(listData.mImageRegion.mTop, aContext, mPresContext,
+                   canStoreInRuleTree);
       
     if (eCSSUnit_Auto == listData.mImageRegion.mBottom.GetUnit())
       list->mImageRegion.height = 0;
     else if (listData.mImageRegion.mBottom.IsLengthUnit())
-      list->mImageRegion.height = CalcLength(listData.mImageRegion.mBottom, aContext, 
-                                            mPresContext, inherited) - list->mImageRegion.y;
+      list->mImageRegion.height =
+        CalcLength(listData.mImageRegion.mBottom, aContext, mPresContext,
+                   canStoreInRuleTree) -
+        list->mImageRegion.y;
   
     if (eCSSUnit_Auto == listData.mImageRegion.mLeft.GetUnit())
       list->mImageRegion.x = 0;
     else if (listData.mImageRegion.mLeft.IsLengthUnit())
-      list->mImageRegion.x = CalcLength(listData.mImageRegion.mLeft, aContext, mPresContext, inherited);
+      list->mImageRegion.x =
+        CalcLength(listData.mImageRegion.mLeft, aContext, mPresContext,
+                   canStoreInRuleTree);
       
     if (eCSSUnit_Auto == listData.mImageRegion.mRight.GetUnit())
       list->mImageRegion.width = 0;
     else if (listData.mImageRegion.mRight.IsLengthUnit())
-      list->mImageRegion.width = CalcLength(listData.mImageRegion.mRight, aContext, mPresContext, inherited) -
-                                list->mImageRegion.x;
+      list->mImageRegion.width =
+        CalcLength(listData.mImageRegion.mRight, aContext, mPresContext,
+                   canStoreInRuleTree) -
+        list->mImageRegion.x;
   }
 
   COMPUTE_END_INHERITED(List, list)
 }
 
 const void* 
 nsRuleNode::ComputePositionData(void* aStartStruct,
                                 const nsRuleDataStruct& aData, 
                                 nsStyleContext* aContext, 
                                 nsRuleNode* aHighestNode,
                                 const RuleDetail aRuleDetail,
-                                const PRBool aInherited)
+                                const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Position, (), pos, parentPos, Position, posData)
 
   // box offsets: length, percent, auto, inherit
   nsStyleCoord  coord;
   NS_FOR_CSS_SIDES(side) {
     nsStyleCoord parentCoord = parentPos->mOffset.Get(side);
     if (SetCoord(posData.mOffset.*(nsCSSRect::sides[side]),
                  coord, parentCoord, SETCOORD_LPAH | SETCOORD_INITIAL_AUTO,
-                 aContext, mPresContext, inherited)) {
+                 aContext, mPresContext, canStoreInRuleTree)) {
       pos->mOffset.Set(side, coord);
     }
   }
 
   SetCoord(posData.mWidth, pos->mWidth, parentPos->mWidth,
            SETCOORD_LPAEH | SETCOORD_INITIAL_AUTO, aContext,
-           mPresContext, inherited);
+           mPresContext, canStoreInRuleTree);
   SetCoord(posData.mMinWidth, pos->mMinWidth, parentPos->mMinWidth,
            SETCOORD_LPEH | SETCOORD_INITIAL_ZERO, aContext,
-           mPresContext, inherited);
+           mPresContext, canStoreInRuleTree);
   SetCoord(posData.mMaxWidth, pos->mMaxWidth, parentPos->mMaxWidth,
            SETCOORD_LPOEH | SETCOORD_INITIAL_NONE, aContext,
-           mPresContext, inherited);
+           mPresContext, canStoreInRuleTree);
 
   SetCoord(posData.mHeight, pos->mHeight, parentPos->mHeight,
            SETCOORD_LPAH | SETCOORD_INITIAL_AUTO, aContext,
-           mPresContext, inherited);
+           mPresContext, canStoreInRuleTree);
   SetCoord(posData.mMinHeight, pos->mMinHeight, parentPos->mMinHeight,
            SETCOORD_LPH | SETCOORD_INITIAL_ZERO, aContext,
-           mPresContext, inherited);
+           mPresContext, canStoreInRuleTree);
   SetCoord(posData.mMaxHeight, pos->mMaxHeight, parentPos->mMaxHeight,
            SETCOORD_LPOH | SETCOORD_INITIAL_NONE, aContext,
-           mPresContext, inherited);
+           mPresContext, canStoreInRuleTree);
 
   // box-sizing: enum, inherit, initial
-  SetDiscrete(posData.mBoxSizing, pos->mBoxSizing, inherited,
+  SetDiscrete(posData.mBoxSizing, pos->mBoxSizing, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentPos->mBoxSizing,
               NS_STYLE_BOX_SIZING_CONTENT, 0, 0, 0, 0);
 
   // z-index
   if (! SetCoord(posData.mZIndex, pos->mZIndex, parentPos->mZIndex,
                  SETCOORD_IA | SETCOORD_INITIAL_AUTO, aContext,
-                 nsnull, inherited)) {
+                 nsnull, canStoreInRuleTree)) {
     if (eCSSUnit_Inherit == posData.mZIndex.GetUnit()) {
       // handle inherit, because it's ok to inherit 'auto' here
-      inherited = PR_FALSE;
+      canStoreInRuleTree = PR_FALSE;
       pos->mZIndex = parentPos->mZIndex;
     }
   }
 
   COMPUTE_END_RESET(Position, pos)
 }
 
 const void* 
 nsRuleNode::ComputeTableData(void* aStartStruct,
                              const nsRuleDataStruct& aData, 
                              nsStyleContext* aContext, 
                              nsRuleNode* aHighestNode,
                              const RuleDetail aRuleDetail,
-                             const PRBool aInherited)
+                             const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Table, (), table, parentTable, Table, tableData)
 
   // table-layout: auto, enum, inherit, initial
-  SetDiscrete(tableData.mLayout, table->mLayoutStrategy, inherited,
+  SetDiscrete(tableData.mLayout, table->mLayoutStrategy, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_AUTO,
               parentTable->mLayoutStrategy,
               NS_STYLE_TABLE_LAYOUT_AUTO,
               NS_STYLE_TABLE_LAYOUT_AUTO, 0, 0, 0);
 
   // rules: enum (not a real CSS prop)
   if (eCSSUnit_Enumerated == tableData.mRules.GetUnit())
     table->mRules = tableData.mRules.GetIntValue();
@@ -4486,89 +4514,90 @@ nsRuleNode::ComputeTableData(void* aStar
 }
 
 const void* 
 nsRuleNode::ComputeTableBorderData(void* aStartStruct,
                                    const nsRuleDataStruct& aData, 
                                    nsStyleContext* aContext, 
                                    nsRuleNode* aHighestNode,
                                    const RuleDetail aRuleDetail,
-                                   const PRBool aInherited)
+                                   const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(TableBorder, (mPresContext), table, parentTable,
                           Table, tableData)
 
   // border-collapse: enum, inherit, initial
-  SetDiscrete(tableData.mBorderCollapse, table->mBorderCollapse, inherited,
+  SetDiscrete(tableData.mBorderCollapse, table->mBorderCollapse,
+              canStoreInRuleTree,
               SETDSC_ENUMERATED, parentTable->mBorderCollapse,
               NS_STYLE_BORDER_SEPARATE, 0, 0, 0, 0);
 
   // border-spacing-x: length, inherit
   nsStyleCoord tempCoord;
   if (SetCoord(tableData.mBorderSpacing.mXValue, tempCoord,
                parentTable->mBorderSpacingX,
                SETCOORD_LH | SETCOORD_INITIAL_ZERO,
-               aContext, mPresContext, inherited)) {
+               aContext, mPresContext, canStoreInRuleTree)) {
     table->mBorderSpacingX = tempCoord.GetCoordValue();
   } else {
     NS_ASSERTION(tableData.mBorderSpacing.mXValue.GetUnit() == eCSSUnit_Null,
                  "unexpected unit");
   }
 
   // border-spacing-y: length, inherit
   if (SetCoord(tableData.mBorderSpacing.mYValue, tempCoord,
                parentTable->mBorderSpacingY,
                SETCOORD_LH | SETCOORD_INITIAL_ZERO,
-               aContext, mPresContext, inherited)) {
+               aContext, mPresContext, canStoreInRuleTree)) {
     table->mBorderSpacingY = tempCoord.GetCoordValue();
   } else {
     NS_ASSERTION(tableData.mBorderSpacing.mYValue.GetUnit() == eCSSUnit_Null,
                  "unexpected unit");
   }
 
   // caption-side: enum, inherit, initial
-  SetDiscrete(tableData.mCaptionSide, table->mCaptionSide, inherited,
+  SetDiscrete(tableData.mCaptionSide, table->mCaptionSide, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentTable->mCaptionSide,
               NS_STYLE_CAPTION_SIDE_TOP, 0, 0, 0, 0);
 
   // empty-cells: enum, inherit, initial
-  SetDiscrete(tableData.mEmptyCells, table->mEmptyCells, inherited,
+  SetDiscrete(tableData.mEmptyCells, table->mEmptyCells, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentTable->mEmptyCells,
               (mPresContext->CompatibilityMode() == eCompatibility_NavQuirks)
               ? NS_STYLE_TABLE_EMPTY_CELLS_SHOW_BACKGROUND     
               : NS_STYLE_TABLE_EMPTY_CELLS_SHOW,
               0, 0, 0, 0);
 
   COMPUTE_END_INHERITED(TableBorder, table)
 }
 
 const void* 
 nsRuleNode::ComputeContentData(void* aStartStruct,
                                const nsRuleDataStruct& aData, 
                                nsStyleContext* aContext, 
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
-                               const PRBool aInherited)
+                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Content, (), content, parentContent,
                       Content, contentData)
 
   // content: [string, url, counter, attr, enum]+, normal, none, inherit
   PRUint32 count;
   nsAutoString  buffer;
   nsCSSValueList* contentValue = contentData.mContent;
   if (contentValue) {
     if (eCSSUnit_Normal == contentValue->mValue.GetUnit() ||
         eCSSUnit_None == contentValue->mValue.GetUnit() ||
         eCSSUnit_Initial == contentValue->mValue.GetUnit()) {
       // "normal", "none", and "initial" all mean no content
       content->AllocateContents(0);
     }
     else if (eCSSUnit_Inherit == contentValue->mValue.GetUnit()) {
-      inherited = PR_FALSE;
+      canStoreInRuleTree = PR_FALSE;
       count = parentContent->ContentCount();
       if (NS_SUCCEEDED(content->AllocateContents(count))) {
         while (0 < count--) {
           content->ContentAt(count) = parentContent->ContentAt(count);
         }
       }
     }
     else {
@@ -4637,17 +4666,17 @@ nsRuleNode::ComputeContentData(void* aSt
   // counter-increment: [string [int]]+, none, inherit
   nsCSSValuePairList* ourIncrement = contentData.mCounterIncrement;
   if (ourIncrement) {
     if (eCSSUnit_None == ourIncrement->mXValue.GetUnit() ||
         eCSSUnit_Initial == ourIncrement->mXValue.GetUnit()) {
       content->AllocateCounterIncrements(0);
     }
     else if (eCSSUnit_Inherit == ourIncrement->mXValue.GetUnit()) {
-      inherited = PR_FALSE;
+      canStoreInRuleTree = PR_FALSE;
       count = parentContent->CounterIncrementCount();
       if (NS_SUCCEEDED(content->AllocateCounterIncrements(count))) {
         while (0 < count--) {
           const nsStyleCounterData *data =
             parentContent->GetCounterIncrementAt(count);
           content->SetCounterIncrementAt(count, data->mCounter, data->mValue);
         }
       }
@@ -4680,17 +4709,17 @@ nsRuleNode::ComputeContentData(void* aSt
   // counter-reset: [string [int]]+, none, inherit
   nsCSSValuePairList* ourReset = contentData.mCounterReset;
   if (ourReset) {
     if (eCSSUnit_None == ourReset->mXValue.GetUnit() ||
         eCSSUnit_Initial == ourReset->mXValue.GetUnit()) {
       content->AllocateCounterResets(0);
     }
     else if (eCSSUnit_Inherit == ourReset->mXValue.GetUnit()) {
-      inherited = PR_FALSE;
+      canStoreInRuleTree = PR_FALSE;
       count = parentContent->CounterResetCount();
       if (NS_SUCCEEDED(content->AllocateCounterResets(count))) {
         while (0 < count--) {
           const nsStyleCounterData *data =
             parentContent->GetCounterResetAt(count);
           content->SetCounterResetAt(count, data->mCounter, data->mValue);
         }
       }
@@ -4718,37 +4747,37 @@ nsRuleNode::ComputeContentData(void* aSt
         }
       }
     }
   }
 
   // marker-offset: length, auto, inherit
   SetCoord(contentData.mMarkerOffset, content->mMarkerOffset, parentContent->mMarkerOffset,
            SETCOORD_LH | SETCOORD_AUTO | SETCOORD_INITIAL_AUTO, aContext,
-           mPresContext, inherited);
+           mPresContext, canStoreInRuleTree);
     
   COMPUTE_END_RESET(Content, content)
 }
 
 const void* 
 nsRuleNode::ComputeQuotesData(void* aStartStruct,
                               const nsRuleDataStruct& aData, 
                               nsStyleContext* aContext, 
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
-                              const PRBool aInherited)
+                              const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Quotes, (), quotes, parentQuotes,
                           Content, contentData)
 
   // quotes: inherit, initial, none, [string string]+
   nsCSSValuePairList* ourQuotes = contentData.mQuotes;
   if (ourQuotes) {
     if (eCSSUnit_Inherit == ourQuotes->mXValue.GetUnit()) {
-      inherited = PR_FALSE;
+      canStoreInRuleTree = PR_FALSE;
       quotes->CopyFrom(*parentQuotes);
     }
     else if (eCSSUnit_Initial == ourQuotes->mXValue.GetUnit()) {
       quotes->SetInitial();
     }
     else if (eCSSUnit_None == ourQuotes->mXValue.GetUnit()) {
       quotes->AllocateQuotes(0);
     }
@@ -4780,51 +4809,51 @@ nsRuleNode::ComputeQuotesData(void* aSta
 }
 
 const void* 
 nsRuleNode::ComputeXULData(void* aStartStruct,
                            const nsRuleDataStruct& aData, 
                            nsStyleContext* aContext, 
                            nsRuleNode* aHighestNode,
                            const RuleDetail aRuleDetail,
-                           const PRBool aInherited)
+                           const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(XUL, (), xul, parentXUL, XUL, xulData)
 
   // box-align: enum, inherit, initial
-  SetDiscrete(xulData.mBoxAlign, xul->mBoxAlign, inherited,
+  SetDiscrete(xulData.mBoxAlign, xul->mBoxAlign, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentXUL->mBoxAlign,
               NS_STYLE_BOX_ALIGN_STRETCH, 0, 0, 0, 0);
 
   // box-direction: enum, inherit, initial
-  SetDiscrete(xulData.mBoxDirection, xul->mBoxDirection, inherited,
+  SetDiscrete(xulData.mBoxDirection, xul->mBoxDirection, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentXUL->mBoxDirection,
               NS_STYLE_BOX_DIRECTION_NORMAL, 0, 0, 0, 0);
 
   // box-flex: factor, inherit
-  SetFactor(xulData.mBoxFlex, xul->mBoxFlex, inherited,
+  SetFactor(xulData.mBoxFlex, xul->mBoxFlex, canStoreInRuleTree,
             parentXUL->mBoxFlex, 0.0f);
 
   // box-orient: enum, inherit, initial
-  SetDiscrete(xulData.mBoxOrient, xul->mBoxOrient, inherited,
+  SetDiscrete(xulData.mBoxOrient, xul->mBoxOrient, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentXUL->mBoxOrient,
               NS_STYLE_BOX_ORIENT_HORIZONTAL, 0, 0, 0, 0);
 
   // box-pack: enum, inherit, initial
-  SetDiscrete(xulData.mBoxPack, xul->mBoxPack, inherited,
+  SetDiscrete(xulData.mBoxPack, xul->mBoxPack, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentXUL->mBoxPack,
               NS_STYLE_BOX_PACK_START, 0, 0, 0, 0);
 
   // box-ordinal-group: integer, inherit, initial
-  SetDiscrete(xulData.mBoxOrdinal, xul->mBoxOrdinal, inherited,
+  SetDiscrete(xulData.mBoxOrdinal, xul->mBoxOrdinal, canStoreInRuleTree,
               SETDSC_INTEGER, parentXUL->mBoxOrdinal, 1,
               0, 0, 0, 0);
 
   if (eCSSUnit_Inherit == xulData.mStackSizing.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     xul->mStretchStack = parentXUL->mStretchStack;
   } else if (eCSSUnit_Initial == xulData.mStackSizing.GetUnit()) {
     xul->mStretchStack = PR_TRUE;
   } else if (eCSSUnit_Enumerated == xulData.mStackSizing.GetUnit()) {
     xul->mStretchStack = xulData.mStackSizing.GetIntValue() ==
       NS_STYLE_STACK_SIZING_STRETCH_TO_FIT;
   }
 
@@ -4832,42 +4861,42 @@ nsRuleNode::ComputeXULData(void* aStartS
 }
 
 const void* 
 nsRuleNode::ComputeColumnData(void* aStartStruct,
                               const nsRuleDataStruct& aData, 
                               nsStyleContext* aContext, 
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
-                              const PRBool aInherited)
+                              const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Column, (mPresContext), column, parent, Column, columnData)
 
   // column-width: length, auto, inherit
   SetCoord(columnData.mColumnWidth,
            column->mColumnWidth, parent->mColumnWidth,
            SETCOORD_LAH | SETCOORD_INITIAL_AUTO,
-           aContext, mPresContext, inherited);
+           aContext, mPresContext, canStoreInRuleTree);
 
   // column-gap: length, percentage, inherit, normal
   SetCoord(columnData.mColumnGap,
            column->mColumnGap, parent->mColumnGap,
            SETCOORD_LPH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL,
-           aContext, mPresContext, inherited);
+           aContext, mPresContext, canStoreInRuleTree);
 
   // column-count: auto, integer, inherit
   if (eCSSUnit_Auto == columnData.mColumnCount.GetUnit() ||
       eCSSUnit_Initial == columnData.mColumnCount.GetUnit()) {
     column->mColumnCount = NS_STYLE_COLUMN_COUNT_AUTO;
   } else if (eCSSUnit_Integer == columnData.mColumnCount.GetUnit()) {
     column->mColumnCount = columnData.mColumnCount.GetIntValue();
     // Max 1000 columns - wallpaper for bug 345583.
     column->mColumnCount = PR_MIN(column->mColumnCount, 1000);
   } else if (eCSSUnit_Inherit == columnData.mColumnCount.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     column->mColumnCount = parent->mColumnCount;
   }
 
   // column-rule-width: length, enum, inherit
   const nsCSSValue& widthValue = columnData.mColumnRuleWidth;
   if (eCSSUnit_Initial == widthValue.GetUnit()) {
     column->SetColumnRuleWidth(
         (mPresContext->GetBorderWidthTable())[NS_STYLE_BORDER_WIDTH_MEDIUM]);
@@ -4877,193 +4906,197 @@ nsRuleNode::ComputeColumnData(void* aSta
                  widthValue.GetIntValue() == NS_STYLE_BORDER_WIDTH_MEDIUM ||
                  widthValue.GetIntValue() == NS_STYLE_BORDER_WIDTH_THICK,
                  "Unexpected enum value");
     column->SetColumnRuleWidth(
         (mPresContext->GetBorderWidthTable())[widthValue.GetIntValue()]);
   }
   else if (eCSSUnit_Inherit == widthValue.GetUnit()) {
     column->SetColumnRuleWidth(parent->GetComputedColumnRuleWidth());
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
   }
   else if (widthValue.IsLengthUnit()) {
     column->SetColumnRuleWidth(CalcLength(widthValue, aContext,
-                                          mPresContext, inherited));
+                                          mPresContext, canStoreInRuleTree));
   }
 
   // column-rule-style: enum, none, inherit
   const nsCSSValue& styleValue = columnData.mColumnRuleStyle;
   if (eCSSUnit_Enumerated == styleValue.GetUnit()) {
     column->mColumnRuleStyle = styleValue.GetIntValue();
   }
   else if (eCSSUnit_None == styleValue.GetUnit() ||
            eCSSUnit_Initial == styleValue.GetUnit()) {
     column->mColumnRuleStyle = NS_STYLE_BORDER_STYLE_NONE;
   }
   else if (eCSSUnit_Inherit == styleValue.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     column->mColumnRuleStyle = parent->mColumnRuleStyle;
   }
 
   // column-rule-color: color, inherit
   const nsCSSValue& colorValue = columnData.mColumnRuleColor;
   if (eCSSUnit_Inherit == colorValue.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     column->mColumnRuleColorIsForeground = PR_FALSE;
     if (parent->mColumnRuleColorIsForeground) {
       column->mColumnRuleColor = parentContext->GetStyleColor()->mColor;
     } else {
       column->mColumnRuleColor = parent->mColumnRuleColor;
     }
   }
   else if (eCSSUnit_Initial == colorValue.GetUnit()) {
     column->mColumnRuleColorIsForeground = PR_TRUE;
   }
-  else if (SetColor(colorValue, 0, mPresContext, aContext, column->mColumnRuleColor, inherited)) {
+  else if (SetColor(colorValue, 0, mPresContext, aContext,
+                    column->mColumnRuleColor, canStoreInRuleTree)) {
     column->mColumnRuleColorIsForeground = PR_FALSE;
   }
 
   COMPUTE_END_RESET(Column, column)
 }
 
 #ifdef MOZ_SVG
 static void
 SetSVGPaint(const nsCSSValuePair& aValue, const nsStyleSVGPaint& parentPaint,
             nsPresContext* aPresContext, nsStyleContext *aContext, 
             nsStyleSVGPaint& aResult, nsStyleSVGPaintType aInitialPaintType,
-            PRBool& aInherited)
+            PRBool& aCanStoreInRuleTree)
 {
   nscolor color;
 
   if (aValue.mXValue.GetUnit() == eCSSUnit_Inherit) {
     aResult = parentPaint;
-    aInherited = PR_FALSE;
+    aCanStoreInRuleTree = PR_FALSE;
   } else if (aValue.mXValue.GetUnit() == eCSSUnit_None) {
     aResult.SetType(eStyleSVGPaintType_None);
   } else if (aValue.mXValue.GetUnit() == eCSSUnit_Initial) {
     aResult.SetType(aInitialPaintType);
     aResult.mPaint.mColor = NS_RGB(0, 0, 0);
     aResult.mFallbackColor = NS_RGB(0, 0, 0);
   } else if (aValue.mXValue.GetUnit() == eCSSUnit_URL) {
     aResult.SetType(eStyleSVGPaintType_Server);
     aResult.mPaint.mPaintServer = aValue.mXValue.GetURLValue();
     NS_IF_ADDREF(aResult.mPaint.mPaintServer);
     if (aValue.mYValue.GetUnit() == eCSSUnit_None) {
       aResult.mFallbackColor = NS_RGBA(0, 0, 0, 0);
     } else {
       NS_ASSERTION(aValue.mYValue.GetUnit() != eCSSUnit_Inherit, "cannot inherit fallback colour");
-      SetColor(aValue.mYValue, NS_RGB(0, 0, 0), aPresContext, aContext, aResult.mFallbackColor, aInherited);
-    }
-  } else if (SetColor(aValue.mXValue, parentPaint.mPaint.mColor, aPresContext, aContext, color, aInherited)) {
+      SetColor(aValue.mYValue, NS_RGB(0, 0, 0), aPresContext, aContext,
+               aResult.mFallbackColor, aCanStoreInRuleTree);
+    }
+  } else if (SetColor(aValue.mXValue, parentPaint.mPaint.mColor, aPresContext,
+                      aContext, color, aCanStoreInRuleTree)) {
     aResult.SetType(eStyleSVGPaintType_Color);
     aResult.mPaint.mColor = color;
   }
 }
 
 const void* 
 nsRuleNode::ComputeSVGData(void* aStartStruct,
                            const nsRuleDataStruct& aData, 
                            nsStyleContext* aContext, 
                            nsRuleNode* aHighestNode,
                            const RuleDetail aRuleDetail,
-                           const PRBool aInherited)
+                           const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(SVG, (), svg, parentSVG, SVG, SVGData)
 
   // clip-rule: enum, inherit, initial
-  SetDiscrete(SVGData.mClipRule, svg->mClipRule, inherited,
+  SetDiscrete(SVGData.mClipRule, svg->mClipRule, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mClipRule,
               NS_STYLE_FILL_RULE_NONZERO, 0, 0, 0, 0);
 
   // color-interpolation: enum, auto, inherit, initial
-  SetDiscrete(SVGData.mColorInterpolation, svg->mColorInterpolation, inherited,
+  SetDiscrete(SVGData.mColorInterpolation, svg->mColorInterpolation,
+              canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_AUTO,
               parentSVG->mColorInterpolation,
               NS_STYLE_COLOR_INTERPOLATION_SRGB,
               NS_STYLE_COLOR_INTERPOLATION_AUTO, 0, 0, 0);
 
   // color-interpolation-filters: enum, auto, inherit, initial
   SetDiscrete(SVGData.mColorInterpolationFilters,
-              svg->mColorInterpolationFilters, inherited,
+              svg->mColorInterpolationFilters, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_AUTO,
               parentSVG->mColorInterpolationFilters,
               NS_STYLE_COLOR_INTERPOLATION_LINEARRGB,
               NS_STYLE_COLOR_INTERPOLATION_AUTO, 0, 0, 0);
 
   // fill: 
   SetSVGPaint(SVGData.mFill, parentSVG->mFill, mPresContext, aContext,
-              svg->mFill, eStyleSVGPaintType_Color, inherited);
+              svg->mFill, eStyleSVGPaintType_Color, canStoreInRuleTree);
 
   // fill-opacity: factor, inherit, initial
-  SetFactor(SVGData.mFillOpacity, svg->mFillOpacity, inherited,
+  SetFactor(SVGData.mFillOpacity, svg->mFillOpacity, canStoreInRuleTree,
             parentSVG->mFillOpacity, 1.0f, SETFCT_OPACITY);
 
   // fill-rule: enum, inherit, initial
-  SetDiscrete(SVGData.mFillRule, svg->mFillRule, inherited,
+  SetDiscrete(SVGData.mFillRule, svg->mFillRule, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mFillRule,
               NS_STYLE_FILL_RULE_NONZERO, 0, 0, 0, 0);
 
   // marker-end: url, none, inherit
   if (eCSSUnit_URL == SVGData.mMarkerEnd.GetUnit()) {
     svg->mMarkerEnd = SVGData.mMarkerEnd.GetURLValue();
   } else if (eCSSUnit_None == SVGData.mMarkerEnd.GetUnit() ||
              eCSSUnit_Initial == SVGData.mMarkerEnd.GetUnit()) {
     svg->mMarkerEnd = nsnull;
   } else if (eCSSUnit_Inherit == SVGData.mMarkerEnd.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     svg->mMarkerEnd = parentSVG->mMarkerEnd;
   }
 
   // marker-mid: url, none, inherit
   if (eCSSUnit_URL == SVGData.mMarkerMid.GetUnit()) {
     svg->mMarkerMid = SVGData.mMarkerMid.GetURLValue();
   } else if (eCSSUnit_None == SVGData.mMarkerMid.GetUnit() ||
              eCSSUnit_Initial == SVGData.mMarkerMid.GetUnit()) {
     svg->mMarkerMid = nsnull;
   } else if (eCSSUnit_Inherit == SVGData.mMarkerMid.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     svg->mMarkerMid = parentSVG->mMarkerMid;
   }
 
   // marker-start: url, none, inherit
   if (eCSSUnit_URL == SVGData.mMarkerStart.GetUnit()) {
     svg->mMarkerStart = SVGData.mMarkerStart.GetURLValue();
   } else if (eCSSUnit_None == SVGData.mMarkerStart.GetUnit() ||
              eCSSUnit_Initial == SVGData.mMarkerStart.GetUnit()) {
     svg->mMarkerStart = nsnull;
   } else if (eCSSUnit_Inherit == SVGData.mMarkerStart.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     svg->mMarkerStart = parentSVG->mMarkerStart;
   }
 
   // pointer-events: enum, none, inherit, initial
-  SetDiscrete(SVGData.mPointerEvents, svg->mPointerEvents, inherited,
+  SetDiscrete(SVGData.mPointerEvents, svg->mPointerEvents, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NONE, parentSVG->mPointerEvents,
               NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED, 0,
               NS_STYLE_POINTER_EVENTS_NONE, 0, 0);
 
   // shape-rendering: enum, auto, inherit
-  SetDiscrete(SVGData.mShapeRendering, svg->mShapeRendering, inherited,
+  SetDiscrete(SVGData.mShapeRendering, svg->mShapeRendering, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_AUTO,
               parentSVG->mShapeRendering,
               NS_STYLE_SHAPE_RENDERING_AUTO, 
               NS_STYLE_SHAPE_RENDERING_AUTO, 0, 0, 0);
 
   // stroke: 
   SetSVGPaint(SVGData.mStroke, parentSVG->mStroke, mPresContext, aContext,
-              svg->mStroke, eStyleSVGPaintType_None, inherited);
+              svg->mStroke, eStyleSVGPaintType_None, canStoreInRuleTree);
 
   // stroke-dasharray: <dasharray>, none, inherit
   nsCSSValueList *list = SVGData.mStrokeDasharray;
   if (list) {
     if (eCSSUnit_Inherit == list->mValue.GetUnit()) {
       // only do the copy if weren't already set up by the copy constructor
       // FIXME Bug 389408: This is broken when aStartStruct is non-null!
       if (!svg->mStrokeDasharray) {
-        inherited = PR_FALSE;
+        canStoreInRuleTree = PR_FALSE;
         svg->mStrokeDasharrayLength = parentSVG->mStrokeDasharrayLength;
         if (svg->mStrokeDasharrayLength) {
           svg->mStrokeDasharray = new nsStyleCoord[svg->mStrokeDasharrayLength];
           if (svg->mStrokeDasharray)
             memcpy(svg->mStrokeDasharray,
                    parentSVG->mStrokeDasharray,
                    svg->mStrokeDasharrayLength * sizeof(nsStyleCoord));
           else
@@ -5090,154 +5123,156 @@ nsRuleNode::ComputeSVGData(void* aStartS
 
         if (svg->mStrokeDasharray) {
           value = SVGData.mStrokeDasharray;
           PRUint32 i = 0;
           while (nsnull != value) {
             SetCoord(value->mValue,
                      svg->mStrokeDasharray[i++], nsnull,
                      SETCOORD_LP | SETCOORD_FACTOR,
-                     aContext, mPresContext, inherited);
+                     aContext, mPresContext, canStoreInRuleTree);
             value = value->mNext;
           }
         } else
           svg->mStrokeDasharrayLength = 0;
       }
     }
   }
 
   // stroke-dashoffset: <dashoffset>, inherit
   SetCoord(SVGData.mStrokeDashoffset,
            svg->mStrokeDashoffset, parentSVG->mStrokeDashoffset,
            SETCOORD_LPH | SETCOORD_FACTOR | SETCOORD_INITIAL_ZERO,
-           aContext, mPresContext, inherited);
+           aContext, mPresContext, canStoreInRuleTree);
 
   // stroke-linecap: enum, inherit, initial
-  SetDiscrete(SVGData.mStrokeLinecap, svg->mStrokeLinecap, inherited,
+  SetDiscrete(SVGData.mStrokeLinecap, svg->mStrokeLinecap, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mStrokeLinecap,
               NS_STYLE_STROKE_LINECAP_BUTT, 0, 0, 0, 0);
 
   // stroke-linejoin: enum, inherit, initial
-  SetDiscrete(SVGData.mStrokeLinejoin, svg->mStrokeLinejoin, inherited,
+  SetDiscrete(SVGData.mStrokeLinejoin, svg->mStrokeLinejoin, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mStrokeLinejoin,
               NS_STYLE_STROKE_LINEJOIN_MITER, 0, 0, 0, 0);
 
   // stroke-miterlimit: <miterlimit>, inherit
-  SetFactor(SVGData.mStrokeMiterlimit, svg->mStrokeMiterlimit, inherited,
+  SetFactor(SVGData.mStrokeMiterlimit, svg->mStrokeMiterlimit,
+            canStoreInRuleTree,
             parentSVG->mStrokeMiterlimit, 4.0f);
 
   // stroke-opacity:
-  SetFactor(SVGData.mStrokeOpacity, svg->mStrokeOpacity, inherited,
+  SetFactor(SVGData.mStrokeOpacity, svg->mStrokeOpacity, canStoreInRuleTree,
             parentSVG->mStrokeOpacity, 1.0f, SETFCT_OPACITY);
 
   // stroke-width:
   if (eCSSUnit_Initial == SVGData.mStrokeWidth.GetUnit()) {
     svg->mStrokeWidth.SetCoordValue(nsPresContext::CSSPixelsToAppUnits(1));
   } else {
     SetCoord(SVGData.mStrokeWidth,
              svg->mStrokeWidth, parentSVG->mStrokeWidth,
              SETCOORD_LPH | SETCOORD_FACTOR,
-             aContext, mPresContext, inherited);
+             aContext, mPresContext, canStoreInRuleTree);
   }
 
   // text-anchor: enum, inherit, initial
-  SetDiscrete(SVGData.mTextAnchor, svg->mTextAnchor, inherited,
+  SetDiscrete(SVGData.mTextAnchor, svg->mTextAnchor, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mTextAnchor,
               NS_STYLE_TEXT_ANCHOR_START, 0, 0, 0, 0);
   
   // text-rendering: enum, auto, inherit, initial
-  SetDiscrete(SVGData.mTextRendering, svg->mTextRendering, inherited,
+  SetDiscrete(SVGData.mTextRendering, svg->mTextRendering, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_AUTO,
               parentSVG->mTextRendering,
               NS_STYLE_TEXT_RENDERING_AUTO,
               NS_STYLE_TEXT_RENDERING_AUTO, 0, 0, 0);
 
   COMPUTE_END_INHERITED(SVG, svg)
 }
 
 const void* 
 nsRuleNode::ComputeSVGResetData(void* aStartStruct,
                                 const nsRuleDataStruct& aData,
                                 nsStyleContext* aContext, 
                                 nsRuleNode* aHighestNode,
                                 const RuleDetail aRuleDetail,
-                                const PRBool aInherited)
+                                const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(SVGReset, (), svgReset, parentSVGReset, SVG, SVGData)
 
   // stop-color:
   if (eCSSUnit_Initial == SVGData.mStopColor.GetUnit()) {
     svgReset->mStopColor = NS_RGB(0, 0, 0);
   } else {
     SetColor(SVGData.mStopColor, parentSVGReset->mStopColor,
-             mPresContext, aContext, svgReset->mStopColor, inherited);
+             mPresContext, aContext, svgReset->mStopColor, canStoreInRuleTree);
   }
 
   // flood-color:
   if (eCSSUnit_Initial == SVGData.mFloodColor.GetUnit()) {
     svgReset->mFloodColor = NS_RGB(0, 0, 0);
   } else {
     SetColor(SVGData.mFloodColor, parentSVGReset->mFloodColor,
-             mPresContext, aContext, svgReset->mFloodColor, inherited);
+             mPresContext, aContext, svgReset->mFloodColor, canStoreInRuleTree);
   }
 
   // lighting-color:
   if (eCSSUnit_Initial == SVGData.mLightingColor.GetUnit()) {
     svgReset->mLightingColor = NS_RGB(255, 255, 255);
   } else {
     SetColor(SVGData.mLightingColor, parentSVGReset->mLightingColor,
-             mPresContext, aContext, svgReset->mLightingColor, inherited);
+             mPresContext, aContext, svgReset->mLightingColor,
+             canStoreInRuleTree);
   }
 
   // clip-path: url, none, inherit
   if (eCSSUnit_URL == SVGData.mClipPath.GetUnit()) {
     svgReset->mClipPath = SVGData.mClipPath.GetURLValue();
   } else if (eCSSUnit_None == SVGData.mClipPath.GetUnit() ||
              eCSSUnit_Initial == SVGData.mClipPath.GetUnit()) {
     svgReset->mClipPath = nsnull;
   } else if (eCSSUnit_Inherit == SVGData.mClipPath.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     svgReset->mClipPath = parentSVGReset->mClipPath;
   }
 
   // stop-opacity:
-  SetFactor(SVGData.mStopOpacity, svgReset->mStopOpacity, inherited,
+  SetFactor(SVGData.mStopOpacity, svgReset->mStopOpacity, canStoreInRuleTree,
             parentSVGReset->mStopOpacity, 1.0f, SETFCT_OPACITY);
 
   // flood-opacity:
-  SetFactor(SVGData.mFloodOpacity, svgReset->mFloodOpacity, inherited,
+  SetFactor(SVGData.mFloodOpacity, svgReset->mFloodOpacity, canStoreInRuleTree,
             parentSVGReset->mFloodOpacity, 1.0f, SETFCT_OPACITY);
 
   // dominant-baseline: enum, auto, inherit, initial
   SetDiscrete(SVGData.mDominantBaseline, svgReset->mDominantBaseline,
-              inherited,
+              canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_AUTO,
               parentSVGReset->mDominantBaseline,
               NS_STYLE_DOMINANT_BASELINE_AUTO,
               NS_STYLE_DOMINANT_BASELINE_AUTO, 0, 0, 0);
 
   // filter: url, none, inherit
   if (eCSSUnit_URL == SVGData.mFilter.GetUnit()) {
     svgReset->mFilter = SVGData.mFilter.GetURLValue();
   } else if (eCSSUnit_None == SVGData.mFilter.GetUnit() ||
              eCSSUnit_Initial == SVGData.mFilter.GetUnit()) {
     svgReset->mFilter = nsnull;
   } else if (eCSSUnit_Inherit == SVGData.mFilter.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     svgReset->mFilter = parentSVGReset->mFilter;
   }
 
   // mask: url, none, inherit
   if (eCSSUnit_URL == SVGData.mMask.GetUnit()) {
     svgReset->mMask = SVGData.mMask.GetURLValue();
   } else if (eCSSUnit_None == SVGData.mMask.GetUnit() ||
              eCSSUnit_Initial == SVGData.mMask.GetUnit()) {
     svgReset->mMask = nsnull;
   } else if (eCSSUnit_Inherit == SVGData.mMask.GetUnit()) {
-    inherited = PR_FALSE;
+    canStoreInRuleTree = PR_FALSE;
     svgReset->mMask = parentSVGReset->mMask;
   }
   
   COMPUTE_END_RESET(SVGReset, svgReset)
 }
 #endif
 
 inline const void* 
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -470,189 +470,213 @@ protected:
   NS_HIDDEN_(const void*)
     WalkRuleTree(const nsStyleStructID aSID, nsStyleContext* aContext, 
                  nsRuleData* aRuleData, nsRuleDataStruct* aSpecificData);
 
   NS_HIDDEN_(const void*)
     ComputeDisplayData(void* aStartStruct,
                        const nsRuleDataStruct& aData,
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                       RuleDetail aRuleDetail, const PRBool aInherited);
+                       RuleDetail aRuleDetail,
+                       const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeVisibilityData(void* aStartStruct,
                           const nsRuleDataStruct& aData,
                           nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                          RuleDetail aRuleDetail, const PRBool aInherited);
+                          RuleDetail aRuleDetail,
+                          const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeFontData(void* aStartStruct,
                     const nsRuleDataStruct& aData,
                     nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                    RuleDetail aRuleDetail, const PRBool aInherited);
+                    RuleDetail aRuleDetail,
+                    const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeColorData(void* aStartStruct,
                      const nsRuleDataStruct& aData,
                      nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                     RuleDetail aRuleDetail, const PRBool aInherited);
+                     RuleDetail aRuleDetail,
+                     const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeBackgroundData(void* aStartStruct,
                           const nsRuleDataStruct& aData, 
                           nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                          RuleDetail aRuleDetail, const PRBool aInherited);
+                          RuleDetail aRuleDetail,
+                          const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeMarginData(void* aStartStruct,
                       const nsRuleDataStruct& aData, 
                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                      RuleDetail aRuleDetail, const PRBool aInherited);
+                      RuleDetail aRuleDetail,
+                      const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeBorderData(void* aStartStruct,
                       const nsRuleDataStruct& aData, 
                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                      RuleDetail aRuleDetail, const PRBool aInherited);
+                      RuleDetail aRuleDetail,
+                      const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputePaddingData(void* aStartStruct,
                        const nsRuleDataStruct& aData, 
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                       RuleDetail aRuleDetail, const PRBool aInherited);
+                       RuleDetail aRuleDetail,
+                       const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeOutlineData(void* aStartStruct,
                        const nsRuleDataStruct& aData, 
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                       RuleDetail aRuleDetail, const PRBool aInherited);
+                       RuleDetail aRuleDetail,
+                       const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeListData(void* aStartStruct,
                     const nsRuleDataStruct& aData,
                     nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                    RuleDetail aRuleDetail, const PRBool aInherited);
+                    RuleDetail aRuleDetail,
+                    const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputePositionData(void* aStartStruct,
                         const nsRuleDataStruct& aData, 
                         nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                        RuleDetail aRuleDetail, const PRBool aInherited);
+                        RuleDetail aRuleDetail,
+                        const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeTableData(void* aStartStruct,
                      const nsRuleDataStruct& aData, 
                      nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                     RuleDetail aRuleDetail, const PRBool aInherited);
+                     RuleDetail aRuleDetail,
+                     const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeTableBorderData(void* aStartStruct,
                            const nsRuleDataStruct& aData, 
                            nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                           RuleDetail aRuleDetail, const PRBool aInherited);
+                           RuleDetail aRuleDetail,
+                           const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeContentData(void* aStartStruct,
                        const nsRuleDataStruct& aData,
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                       RuleDetail aRuleDetail, const PRBool aInherited);
+                       RuleDetail aRuleDetail,
+                       const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeQuotesData(void* aStartStruct,
                       const nsRuleDataStruct& aData, 
                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                      RuleDetail aRuleDetail, const PRBool aInherited);
+                      RuleDetail aRuleDetail,
+                      const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeTextData(void* aStartStruct,
                     const nsRuleDataStruct& aData, 
                     nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                    RuleDetail aRuleDetail, const PRBool aInherited);
+                    RuleDetail aRuleDetail,
+                    const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeTextResetData(void* aStartStruct,
                          const nsRuleDataStruct& aData,
                          nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                         RuleDetail aRuleDetail, const PRBool aInherited);
+                         RuleDetail aRuleDetail,
+                         const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeUserInterfaceData(void* aStartStruct,
                              const nsRuleDataStruct& aData, 
                              nsStyleContext* aContext,
                              nsRuleNode* aHighestNode,
-                             RuleDetail aRuleDetail, const PRBool aInherited);
+                             RuleDetail aRuleDetail,
+                             const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeUIResetData(void* aStartStruct,
                        const nsRuleDataStruct& aData,
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                       RuleDetail aRuleDetail, const PRBool aInherited);
+                       RuleDetail aRuleDetail,
+                       const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeXULData(void* aStartStruct,
                    const nsRuleDataStruct& aData, 
                    nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                   RuleDetail aRuleDetail, const PRBool aInherited);
+                   RuleDetail aRuleDetail,
+                   const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeColumnData(void* aStartStruct,
                       const nsRuleDataStruct& aData,
                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                      RuleDetail aRuleDetail, const PRBool aInherited);
+                      RuleDetail aRuleDetail,
+                      const PRBool aCanStoreInRuleTree);
 
 #ifdef MOZ_SVG
   NS_HIDDEN_(const void*)
     ComputeSVGData(void* aStartStruct,
                    const nsRuleDataStruct& aData, 
                    nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                   RuleDetail aRuleDetail, const PRBool aInherited);
+                   RuleDetail aRuleDetail,
+                   const PRBool aCanStoreInRuleTree);
 
   NS_HIDDEN_(const void*)
     ComputeSVGResetData(void* aStartStruct,
                         const nsRuleDataStruct& aData, 
                         nsStyleContext* aContext, nsRuleNode* aHighestNode,
-                        RuleDetail aRuleDetail, const PRBool aInherited);
+                        RuleDetail aRuleDetail,
+                        const PRBool aCanStoreInRuleTree);
 #endif
 
   // helpers for |ComputeFontData| that need access to |mNoneBits|:
   static NS_HIDDEN_(void) SetFontSize(nsPresContext* aPresContext,
                                       const nsRuleDataFont& aFontData,
                                       const nsStyleFont* aFont,
                                       const nsStyleFont* aParentFont,
                                       nscoord* aSize,
                                       const nsFont& aSystemFont,
                                       nscoord aParentSize,
                                       nscoord aScriptLevelAdjustedParentSize,
                                       PRBool aUsedStartStruct,
                                       PRBool aAtRoot,
-                                      PRBool& aInherited);
+                                      PRBool& aCanStoreInRuleTree);
 
   static NS_HIDDEN_(void) SetFont(nsPresContext* aPresContext,
                                   nsStyleContext* aContext,
                                   nscoord aMinFontSize,
                                   PRUint8 aGenericFontID,
                                   const nsRuleDataFont& aFontData,
                                   const nsStyleFont* aParentFont,
                                   nsStyleFont* aFont,
-                                  PRBool aStartStruct, PRBool& aInherited);
+                                  PRBool aStartStruct,
+                                  PRBool& aCanStoreInRuleTree);
 
   static NS_HIDDEN_(void) SetGenericFont(nsPresContext* aPresContext,
                                          nsStyleContext* aContext,
                                          PRUint8 aGenericFontID,
                                          nscoord aMinFontSize,
                                          nsStyleFont* aFont);
 
   NS_HIDDEN_(void) AdjustLogicalBoxProp(nsStyleContext* aContext,
                                         const nsCSSValue& aLTRSource,
                                         const nsCSSValue& aRTLSource,
                                         const nsCSSValue& aLTRLogicalValue,
                                         const nsCSSValue& aRTLLogicalValue,
                                         PRUint8 aSide,
                                         nsCSSRect& aValueRect,
-                                        PRBool& aInherited);
+                                        PRBool& aCanStoreInRuleTree);
 
   inline RuleDetail CheckSpecifiedProperties(const nsStyleStructID aSID, const nsRuleDataStruct& aRuleDataStruct);
 
   NS_HIDDEN_(const void*) GetParentData(const nsStyleStructID aSID);
   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)  \
     NS_HIDDEN_(const nsStyle##name_*) GetParent##name_();
   #include "nsStyleStructList.h"
   #undef STYLE_STRUCT  
@@ -746,17 +770,17 @@ public:
 
   // Expose this so media queries can use it
   static nscoord CalcLengthWithInitialFont(nsPresContext* aPresContext,
                                            const nsCSSValue& aValue);
   // Expose this so nsTransformFunctions can use it.
   static nscoord CalcLength(const nsCSSValue& aValue,
                             nsStyleContext* aStyleContext,
                             nsPresContext* aPresContext,
-                            PRBool& aInherited);
+                            PRBool& aCanStoreInRuleTree);
 
   // Return whether the rule tree for which this node is the root has
   // cached data such that we need to do dynamic change handling for
   // changes that change the results of media queries or require
   // rebuilding all style data.
   PRBool TreeHasCachedData() const {
     NS_ASSERTION(IsRoot(), "should only be called on root of rule tree");
     return HaveChildren() || mStyleData.mInheritedData || mStyleData.mResetData;
diff --git a/layout/style/nsStyleTransformMatrix.cpp b/layout/style/nsStyleTransformMatrix.cpp
--- a/layout/style/nsStyleTransformMatrix.cpp
+++ b/layout/style/nsStyleTransformMatrix.cpp
@@ -231,140 +231,142 @@ nsStyleTransformMatrix::operator *(const
 {
   return nsStyleTransformMatrix(*this) *= aOther;
 }
 
 /* Helper function to fill in an nscoord with the specified nsCSSValue. */
 static void SetCoordToValue(const nsCSSValue &aValue,
                             nsStyleContext* aContext,
                             nsPresContext* aPresContext,
-                            PRBool &aInherited, nscoord &aOut)
+                            PRBool &aCanStoreInRuleTree, nscoord &aOut)
 {
-  aOut = nsRuleNode::CalcLength(aValue, aContext, aPresContext, aInherited);
+  aOut = nsRuleNode::CalcLength(aValue, aContext, aPresContext,
+                                aCanStoreInRuleTree);
 }
 
 /* Helper function to process a matrix entry. */
 static void ProcessMatrix(float aMain[4], nscoord aDelta[2],
                           float aX[2], float aY[2],
                           const nsCSSValue::Array* aData,
                           nsStyleContext* aContext,
                           nsPresContext* aPresContext,
-                          PRBool& aInherited)
+                          PRBool& aCanStoreInRuleTree)
 {
   NS_PRECONDITION(aData->Count() == 7, "Invalid array!");
 
   /* Take the first four elements out of the array as floats and store
    * them in aMain.
    */
   for (PRUint16 index = 1; index <= 4; ++index)
     aMain[index - 1] = aData->Item(index).GetFloatValue();
 
   /* For the fifth element, if it's a percentage, store it in aX[0].
    * Otherwise, it's a length that needs to go in aDelta[0]
    */
   if (aData->Item(5).GetUnit() == eCSSUnit_Percent)
     aX[0] = aData->Item(5).GetPercentValue();
   else
-    SetCoordToValue(aData->Item(5), aContext, aPresContext, aInherited,
+    SetCoordToValue(aData->Item(5), aContext, aPresContext, aCanStoreInRuleTree,
                     aDelta[0]);
 
   /* For the final element, if it's a percentage, store it in aY[1].
    * Otherwise, it's a length that needs to go in aDelta[1].
    */
   if (aData->Item(6).GetUnit() == eCSSUnit_Percent)
     aY[1] = aData->Item(6).GetPercentValue();
   else
-    SetCoordToValue(aData->Item(6), aContext, aPresContext, aInherited,
+    SetCoordToValue(aData->Item(6), aContext, aPresContext, aCanStoreInRuleTree,
                     aDelta[1]);
 }
 
 /* Helper function to process a translatex function. */
 static void ProcessTranslateX(nscoord aDelta[2], float aX[2],
                               const nsCSSValue::Array* aData,
                               nsStyleContext* aContext,
                               nsPresContext* aPresContext,
-                              PRBool& aInherited)
+                              PRBool& aCanStoreInRuleTree)
 {
   NS_PRECONDITION(aData->Count() == 2, "Invalid array!");
 
   /* There are two cases.  If we have a number, we want our matrix to look
    * like this:
    *
    * |  1  0 dx|
    * |  0  1  0|
    * |  0  0  1|
    * So E = value
    * 
    * Otherwise, we might have a percentage, so we want to set the dX component
    * to the percent.
    */
   if (aData->Item(1).GetUnit() != eCSSUnit_Percent)
-    SetCoordToValue(aData->Item(1), aContext, aPresContext, aInherited,
+    SetCoordToValue(aData->Item(1), aContext, aPresContext, aCanStoreInRuleTree,
                     aDelta[0]);
   else
     aX[0] = aData->Item(1).GetPercentValue();
 }
 
 /* Helper function to process a translatey function. */
 static void ProcessTranslateY(nscoord aDelta[2], float aY[2],
                               const nsCSSValue::Array* aData,
                               nsStyleContext* aContext,
                               nsPresContext* aPresContext,
-                              PRBool& aInherited)
+                              PRBool& aCanStoreInRuleTree)
 {
   NS_PRECONDITION(aData->Count() == 2, "Invalid array!");
 
   /* There are two cases.  If we have a number, we want our matrix to look
    * like this:
    *
    * |  1  0  0|
    * |  0  1 dy|
    * |  0  0  1|
    * So E = value
    * 
    * Otherwise, we might have a percentage, so we want to set the dY component
    * to the percent.
    */
   if (aData->Item(1).GetUnit() != eCSSUnit_Percent)
-    SetCoordToValue(aData->Item(1), aContext, aPresContext, aInherited,
+    SetCoordToValue(aData->Item(1), aContext, aPresContext, aCanStoreInRuleTree,
                     aDelta[1]);
   else
     aY[1] = aData->Item(1).GetPercentValue();
 }
 
 /* Helper function to process a translate function. */
 static void ProcessTranslate(nscoord aDelta[2], float aX[2], float aY[2],
                              const nsCSSValue::Array* aData,
                              nsStyleContext* aContext,
                              nsPresContext* aPresContext,
-                             PRBool& aInherited)
+                             PRBool& aCanStoreInRuleTree)
 {
   NS_PRECONDITION(aData->Count() == 2 || aData->Count() == 3, "Invalid array!");
 
   /* There are several cases to consider.
    * First, we might have one value, or we might have two.  If we have
    * two, we need to consider both dX and dY components.
    * Next, the values might be lengths, or they might be percents.  If they're
    * percents, store them in the dX and dY components.  Otherwise, store them in
    * the main matrix.
    */
 
   const nsCSSValue &dx = aData->Item(1);
   if (dx.GetUnit() == eCSSUnit_Percent)
     aX[0] = dx.GetPercentValue();
   else
-    SetCoordToValue(dx, aContext, aPresContext, aInherited, aDelta[0]);
+    SetCoordToValue(dx, aContext, aPresContext, aCanStoreInRuleTree, aDelta[0]);
 
   /* If we read in a Y component, set it appropriately */
   if (aData->Count() == 3) {
     const nsCSSValue &dy = aData->Item(2);
     if (dy.GetUnit() == eCSSUnit_Percent)
       aY[1] = dy.GetPercentValue();
     else
-      SetCoordToValue(dy, aContext, aPresContext, aInherited, aDelta[1]); 
+      SetCoordToValue(dy, aContext, aPresContext, aCanStoreInRuleTree,
+                      aDelta[1]); 
   }
 }
 
 /* Helper function to set up a scale matrix. */
 static void ProcessScaleHelper(float aXScale, float aYScale, float aMain[4])
 {
   /* We want our matrix to look like this:
    * | dx  0  0|
@@ -470,40 +472,42 @@ static void ProcessRotate(float aMain[4]
 /**
  * SetToTransformFunction is essentially a giant switch statement that fans
  * out to many smaller helper functions.
  */
 void
 nsStyleTransformMatrix::SetToTransformFunction(const nsCSSValue::Array * aData,
                                                nsStyleContext* aContext,
                                                nsPresContext* aPresContext,
-                                               PRBool& aInherited)
+                                               PRBool& aCanStoreInRuleTree)
 {
   NS_PRECONDITION(aData, "Why did you want to get data from a null array?");
   NS_PRECONDITION(aContext, "Need a context for unit conversion!");
   NS_PRECONDITION(aPresContext, "Need a context for unit conversion!");
   
   /* Reset the matrix to the identity so that each subfunction can just
    * worry about its own components.
    */
   SetToIdentity();
 
   /* Get the keyword for the transform. */
   nsAutoString keyword;
   aData->Item(0).GetStringValue(keyword);
   switch (nsCSSKeywords::LookupKeyword(keyword)) {
   case eCSSKeyword_translatex:
-    ProcessTranslateX(mDelta, mX, aData, aContext, aPresContext, aInherited);
+    ProcessTranslateX(mDelta, mX, aData, aContext, aPresContext,
+                      aCanStoreInRuleTree);
     break;
   case eCSSKeyword_translatey:
-    ProcessTranslateY(mDelta, mY, aData, aContext, aPresContext, aInherited);
+    ProcessTranslateY(mDelta, mY, aData, aContext, aPresContext,
+                      aCanStoreInRuleTree);
     break;
   case eCSSKeyword_translate:
     ProcessTranslate(mDelta, mX, mY, aData, aContext, aPresContext,
-                     aInherited);
+                     aCanStoreInRuleTree);
     break;
   case eCSSKeyword_scalex:
     ProcessScaleX(mMain, aData);
     break;
   case eCSSKeyword_scaley:
     ProcessScaleY(mMain, aData);
     break;
   case eCSSKeyword_scale:
@@ -518,17 +522,17 @@ nsStyleTransformMatrix::SetToTransformFu
   case eCSSKeyword_skew:
     ProcessSkew(mMain, aData);
     break;
   case eCSSKeyword_rotate:
     ProcessRotate(mMain, aData);
     break;
   case eCSSKeyword_matrix:
     ProcessMatrix(mMain, mDelta, mX, mY, aData, aContext, aPresContext,
-                  aInherited);
+                  aCanStoreInRuleTree);
     break;
   default:
     NS_NOTREACHED("Unknown transform function!");
   }
 }
 
 /* Does an element-by-element comparison and returns whether or not the
  * matrices are equal.
diff --git a/layout/style/nsStyleTransformMatrix.h b/layout/style/nsStyleTransformMatrix.h
--- a/layout/style/nsStyleTransformMatrix.h
+++ b/layout/style/nsStyleTransformMatrix.h
@@ -107,23 +107,23 @@ class nsStyleTransformMatrix
 
   /**
    * Given an nsCSSValue::Array* containing a -moz-transform function,
    * updates this matrix to hold the value of that function.
    *
    * @param aData The nsCSSValue::Array* containing the transform function.
    * @param aContext The style context, used for unit conversion.
    * @param aPresContext The presentation context, used for unit conversion.
-   * @param aInherited Set to false if the result cannot be cached in the rule
-   *                   tree, otherwise untouched.
+   * @param aCanStoreInRuleTree Set to false if the result cannot be cached
+   *                            in the rule tree, otherwise untouched.
    */
   void SetToTransformFunction(const nsCSSValue::Array* aData,
                               nsStyleContext* aContext,
                               nsPresContext* aPresContext,
-                              PRBool& aInherited);
+                              PRBool& aCanStoreInRuleTree);
 
   /**
    * Sets this matrix to be the identity matrix.
    */
   void SetToIdentity();
 
   /**
    * Returns the value of the entry at the 2x2 submatrix of the
