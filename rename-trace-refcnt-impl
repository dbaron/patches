From: L. David Baron <dbaron@dbaron.org>

Bug 976350 patch 2:  Rename nsTraceRefcntImpl to nsTraceRefcnt.  r=bsmedberg

Now that bug 975295 removed the obsolete wrapper class, we can rename
nsTraceRefcntImpl back to its correct pre-XPCOM-glue name,
nsTraceRefcnt.

The best part is that the one place where indentation should have needed
fixing, nsTraceRefcnt::DemangleSymbol, never had its indentation fixed
for the previous renaming.

diff --git a/accessible/src/base/Logging.cpp b/accessible/src/base/Logging.cpp
--- a/accessible/src/base/Logging.cpp
+++ b/accessible/src/base/Logging.cpp
@@ -12,17 +12,17 @@
 #include "nsAccessibilityService.h"
 #include "nsCoreUtils.h"
 #include "OuterDocAccessible.h"
 
 #include "nsDocShellLoadTypes.h"
 #include "nsIChannel.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsISelectionPrivate.h"
-#include "nsTraceRefcntImpl.h"
+#include "nsTraceRefcnt.h"
 #include "nsIWebProgress.h"
 #include "prenv.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsIURI.h"
 #include "mozilla/dom/Element.h"
 
 using namespace mozilla;
 using namespace mozilla::a11y;
@@ -795,17 +795,17 @@ logging::DOMEvent(const char* aDescr, ns
   logging::MsgEnd();
 }
 
 void
 logging::Stack()
 {
   if (IsEnabled(eStack)) {
     printf("  stack: \n");
-    nsTraceRefcntImpl::WalkTheStack(stdout);
+    nsTraceRefcnt::WalkTheStack(stdout);
   }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // namespace logging:: initialization
 
 bool
 logging::IsEnabled(uint32_t aModules)
diff --git a/js/src/devtools/rootAnalysis/annotations.js b/js/src/devtools/rootAnalysis/annotations.js
--- a/js/src/devtools/rootAnalysis/annotations.js
+++ b/js/src/devtools/rootAnalysis/annotations.js
@@ -8,20 +8,20 @@ var ignoreIndirectCalls = {
     "aMallocSizeOf" : true,
     "_malloc_message" : true,
     "__conv" : true,
     "__convf" : true,
     "prerrortable.c:callback_newtable" : true,
     "mozalloc_oom.cpp:void (* gAbortHandler)(size_t)" : true,
 
     // I don't know why these are getting truncated
-    "nsTraceRefcntImpl.cpp:void (* leakyLogAddRef)(void*": true,
-    "nsTraceRefcntImpl.cpp:void (* leakyLogAddRef)(void*, int, int)": true,
-    "nsTraceRefcntImpl.cpp:void (* leakyLogRelease)(void*": true,
-    "nsTraceRefcntImpl.cpp:void (* leakyLogRelease)(void*, int, int)": true,
+    "nsTraceRefcnt.cpp:void (* leakyLogAddRef)(void*": true,
+    "nsTraceRefcnt.cpp:void (* leakyLogAddRef)(void*, int, int)": true,
+    "nsTraceRefcnt.cpp:void (* leakyLogRelease)(void*": true,
+    "nsTraceRefcnt.cpp:void (* leakyLogRelease)(void*, int, int)": true,
 };
 
 function indirectCallCannotGC(fullCaller, fullVariable)
 {
     var caller = readable(fullCaller);
 
     // This is usually a simple variable name, but sometimes a full name gets
     // passed through. And sometimes that name is truncated. Examples:
diff --git a/netwerk/protocol/about/nsAboutBloat.cpp b/netwerk/protocol/about/nsAboutBloat.cpp
--- a/netwerk/protocol/about/nsAboutBloat.cpp
+++ b/netwerk/protocol/about/nsAboutBloat.cpp
@@ -1,14 +1,14 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#include "nsTraceRefcntImpl.h"
+#include "nsTraceRefcnt.h"
 
 // if NS_BUILD_REFCNT_LOGGING isn't defined, don't try to build
 #ifdef NS_BUILD_REFCNT_LOGGING
 
 #include "nsAboutBloat.h"
 #include "nsStringStream.h"
 #include "nsIURI.h"
 #include "nsCOMPtr.h"
@@ -24,35 +24,35 @@ NS_IMETHODIMP
 nsAboutBloat::NewChannel(nsIURI *aURI, nsIChannel **result)
 {
     NS_ENSURE_ARG_POINTER(aURI);
     nsresult rv;
     nsAutoCString path;
     rv = aURI->GetPath(path);
     if (NS_FAILED(rv)) return rv;
 
-    nsTraceRefcntImpl::StatisticsType statType = nsTraceRefcntImpl::ALL_STATS;
+    nsTraceRefcnt::StatisticsType statType = nsTraceRefcnt::ALL_STATS;
     bool clear = false;
     bool leaks = false;
 
     int32_t pos = path.Find("?");
     if (pos > 0) {
         nsAutoCString param;
         (void)path.Right(param, path.Length() - (pos+1));
         if (param.EqualsLiteral("new"))
-            statType = nsTraceRefcntImpl::NEW_STATS;
+            statType = nsTraceRefcnt::NEW_STATS;
         else if (param.EqualsLiteral("clear"))
             clear = true;
         else if (param.EqualsLiteral("leaks"))
             leaks = true;
     }
 
     nsCOMPtr<nsIInputStream> inStr;
     if (clear) {
-        nsTraceRefcntImpl::ResetStatistics();
+        nsTraceRefcnt::ResetStatistics();
 
         rv = NS_NewCStringInputStream(getter_AddRefs(inStr),
             NS_LITERAL_CSTRING("Bloat statistics cleared."));
         if (NS_FAILED(rv)) return rv;
     }
     else if (leaks) {
         // dump the current set of leaks.
         GC_gcollect();
@@ -78,33 +78,33 @@ nsAboutBloat::NewChannel(nsIURI *aURI, n
             // On all the platforms that I know use permissions,
             // directories need to have the executable flag set
             // if you want to do anything inside the directory.
             rv = file->Create(nsIFile::DIRECTORY_TYPE, 0755);
             if (NS_FAILED(rv)) return rv;
         }
 
         nsAutoCString dumpFileName;
-        if (statType == nsTraceRefcntImpl::ALL_STATS)
+        if (statType == nsTraceRefcnt::ALL_STATS)
             dumpFileName.AssignLiteral("all-");
         else
             dumpFileName.AssignLiteral("new-");
         PRExplodedTime expTime;
         PR_ExplodeTime(PR_Now(), PR_LocalTimeParameters, &expTime);
         char time[128];
         PR_FormatTimeUSEnglish(time, 128, "%Y-%m-%d-%H%M%S.txt", &expTime);
         dumpFileName += time;
         rv = file->AppendNative(dumpFileName);
         if (NS_FAILED(rv)) return rv;
 
         FILE* out;
         rv = file->OpenANSIFileDesc("w", &out);
         if (NS_FAILED(rv)) return rv;
 
-        rv = nsTraceRefcntImpl::DumpStatistics(statType, out);
+        rv = nsTraceRefcnt::DumpStatistics(statType, out);
         ::fclose(out);
         if (NS_FAILED(rv)) return rv;
 
         rv = NS_NewLocalFileInputStream(getter_AddRefs(inStr), file);
         if (NS_FAILED(rv)) return rv;
     }
 
     nsIChannel* channel;
diff --git a/tools/rb/fix-linux-stack.pl b/tools/rb/fix-linux-stack.pl
--- a/tools/rb/fix-linux-stack.pl
+++ b/tools/rb/fix-linux-stack.pl
@@ -5,18 +5,18 @@
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 # $Id: fix-linux-stack.pl,v 1.16 2008/05/05 21:51:11 dbaron%dbaron.org Exp $
 #
 # This script uses addr2line (part of binutils) to process the output of
 # nsTraceRefcnt's Linux stack walking code.  This is useful for two
 # things:
 #  (1) Getting line number information out of
-#      |nsTraceRefcntImpl::WalkTheStack|'s output in debug builds.
-#  (2) Getting function names out of |nsTraceRefcntImpl::WalkTheStack|'s
+#      |nsTraceRefcnt::WalkTheStack|'s output in debug builds.
+#  (2) Getting function names out of |nsTraceRefcnt::WalkTheStack|'s
 #      output on optimized builds (where it mostly prints UNKNOWN
 #      because only a handful of symbols are exported from component
 #      libraries).
 #
 # Use the script by piping output containing stacks (such as raw stacks
 # or make-tree.pl balance trees) through this script.
 
 use strict;
diff --git a/tools/rb/fix_macosx_stack.py b/tools/rb/fix_macosx_stack.py
--- a/tools/rb/fix_macosx_stack.py
+++ b/tools/rb/fix_macosx_stack.py
@@ -2,18 +2,18 @@
 # vim:sw=4:ts=4:et:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 # This script uses atos to process the output of nsTraceRefcnt's Mac OS
 # X stack walking code.  This is useful for two things:
 #  (1) Getting line number information out of
-#      |nsTraceRefcntImpl::WalkTheStack|'s output in debug builds.
-#  (2) Getting function names out of |nsTraceRefcntImpl::WalkTheStack|'s
+#      |nsTraceRefcnt::WalkTheStack|'s output in debug builds.
+#  (2) Getting function names out of |nsTraceRefcnt::WalkTheStack|'s
 #      output on all builds (where it mostly prints UNKNOWN because only
 #      a handful of symbols are exported from component libraries).
 #
 # Use the script by piping output containing stacks (such as raw stacks
 # or make-tree.pl balance trees) through this script.
 
 import subprocess
 import sys
diff --git a/xpcom/base/moz.build b/xpcom/base/moz.build
--- a/xpcom/base/moz.build
+++ b/xpcom/base/moz.build
@@ -51,17 +51,17 @@ EXPORTS += [
     'nsIAllocator.h',
     'nsIID.h',
     'nsInterfaceRequestorAgg.h',
     'nsISizeOf.h',
     'nsISupportsBase.h',
     'nsISupportsObsolete.h',
     'nsObjCExceptions.h',
     'nsStackWalk.h',
-    'nsTraceRefcntImpl.h',
+    'nsTraceRefcnt.h',
     'nsWeakPtr.h',
 ]
 
 if CONFIG['OS_ARCH'] == 'WINNT':
     EXPORTS += [
         'nsWindowsHelpers.h',
     ]
     if CONFIG['MOZ_DEBUG']:
@@ -105,17 +105,17 @@ UNIFIED_SOURCES += [
     'nsGZFileWriter.cpp',
     'nsInterfaceRequestorAgg.cpp',
     'nsMemoryImpl.cpp',
     'nsMemoryInfoDumper.cpp',
     'nsMemoryReporterManager.cpp',
     'nsMessageLoop.cpp',
     'nsSecurityConsoleMessage.cpp',
     'nsSystemInfo.cpp',
-    'nsTraceRefcntImpl.cpp',
+    'nsTraceRefcnt.cpp',
     'nsUUIDGenerator.cpp',
     'nsVersionComparatorImpl.cpp',
     'VisualEventTracer.cpp',
 ]
 
 # On Windows, NS_StackWalk will only work correctly if we have frame pointers available.
 # That will only be true for non-optimized builds, and for optimized builds with
 # --enable-profiling in the .mozconfig (which is turned on in Nightly by default.)
diff --git a/xpcom/base/nsDebugImpl.cpp b/xpcom/base/nsDebugImpl.cpp
--- a/xpcom/base/nsDebugImpl.cpp
+++ b/xpcom/base/nsDebugImpl.cpp
@@ -25,17 +25,17 @@
 #include <android/log.h>
 #endif
 
 #ifdef _WIN32
 /* for getenv() */
 #include <stdlib.h>
 #endif
 
-#include "nsTraceRefcntImpl.h"
+#include "nsTraceRefcnt.h"
 
 #if defined(XP_UNIX)
 #include <signal.h>
 #endif
 
 #if defined(XP_WIN)
 #include <tchar.h>
 #include "nsString.h"
@@ -368,17 +368,17 @@ NS_DebugBreak(uint32_t aSeverity, const 
      CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("AbortMessage"),
                                         nsDependentCString(buf.buffer));
 #endif  // MOZ_CRASHREPORTER
 
 #if defined(DEBUG) && defined(_WIN32)
      RealBreak();
 #endif
 #ifdef DEBUG
-     nsTraceRefcntImpl::WalkTheStack(stderr);
+     nsTraceRefcnt::WalkTheStack(stderr);
 #endif
      Abort(buf.buffer);
      return;
    }
    }
 
    // Now we deal with assertions
    gAssertionCount++;
@@ -392,21 +392,21 @@ NS_DebugBreak(uint32_t aSeverity, const 
       fprintf(stderr, "Suspending process; attach with the debugger.\n");
       kill(0, SIGSTOP);
 #else
       Break(buf.buffer);
 #endif
       return;
 
    case NS_ASSERT_STACK:
-     nsTraceRefcntImpl::WalkTheStack(stderr);
+     nsTraceRefcnt::WalkTheStack(stderr);
      return;
 
    case NS_ASSERT_STACK_AND_ABORT:
-     nsTraceRefcntImpl::WalkTheStack(stderr);
+     nsTraceRefcnt::WalkTheStack(stderr);
      // Fall through to abort
 
    case NS_ASSERT_ABORT:
      Abort(buf.buffer);
      return;
 
    case NS_ASSERT_TRAP:
    case NS_ASSERT_UNINITIALIZED: // Default to "trap" behavior
diff --git a/xpcom/base/nsTraceRefcntImpl.cpp b/xpcom/base/nsTraceRefcnt.cpp
rename from xpcom/base/nsTraceRefcntImpl.cpp
rename to xpcom/base/nsTraceRefcnt.cpp
--- a/xpcom/base/nsTraceRefcntImpl.cpp
+++ b/xpcom/base/nsTraceRefcnt.cpp
@@ -1,14 +1,14 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#include "nsTraceRefcntImpl.h"
+#include "nsTraceRefcnt.h"
 #include "mozilla/IntegerPrintfMacros.h"
 #include "nsXPCOMPrivate.h"
 #include "nscore.h"
 #include "nsISupports.h"
 #include "nsTArray.h"
 #include "prenv.h"
 #include "plstr.h"
 #include "prlink.h"
@@ -311,44 +311,44 @@ public:
     total->mClassSize += mClassSize * count;    // adjust for average in DumpTotal
     total->mTotalLeaked += (uint64_t)(mClassSize *
                                      ((mNewStats.mCreates + mAllStats.mCreates)
                                       -(mNewStats.mDestroys + mAllStats.mDestroys)));
   }
 
   void DumpTotal(FILE* out) {
     mClassSize /= mAllStats.mCreates;
-    Dump(-1, out, nsTraceRefcntImpl::ALL_STATS);
+    Dump(-1, out, nsTraceRefcnt::ALL_STATS);
   }
 
   static bool HaveLeaks(nsTraceRefcntStats* stats) {
     return ((stats->mAddRefs != stats->mReleases) ||
             (stats->mCreates != stats->mDestroys));
   }
 
-  bool PrintDumpHeader(FILE* out, const char* msg, nsTraceRefcntImpl::StatisticsType type) {
+  bool PrintDumpHeader(FILE* out, const char* msg, nsTraceRefcnt::StatisticsType type) {
     fprintf(out, "\n== BloatView: %s, %s process %d\n", msg,
             XRE_ChildProcessTypeToString(XRE_GetProcessType()), getpid());
     nsTraceRefcntStats& stats =
-      (type == nsTraceRefcntImpl::NEW_STATS) ? mNewStats : mAllStats;
+      (type == nsTraceRefcnt::NEW_STATS) ? mNewStats : mAllStats;
     if (gLogLeaksOnly && !HaveLeaks(&stats))
       return false;
 
     fprintf(out,
         "\n" \
         "     |<----------------Class--------------->|<-----Bytes------>|<----------------Objects---------------->|<--------------References-------------->|\n" \
         "                                              Per-Inst   Leaked    Total      Rem      Mean       StdDev     Total      Rem      Mean       StdDev\n");
 
     this->DumpTotal(out);
 
     return true;
   }
 
-  void Dump(int i, FILE* out, nsTraceRefcntImpl::StatisticsType type) {
-    nsTraceRefcntStats* stats = (type == nsTraceRefcntImpl::NEW_STATS) ? &mNewStats : &mAllStats;
+  void Dump(int i, FILE* out, nsTraceRefcnt::StatisticsType type) {
+    nsTraceRefcntStats* stats = (type == nsTraceRefcnt::NEW_STATS) ? &mNewStats : &mAllStats;
     if (gLogLeaksOnly && !HaveLeaks(stats)) {
       return;
     }
 
     double meanRefs, stddevRefs;
     NS_MeanAndStdDev(stats->mAddRefs + stats->mReleases,
                      stats->mRefsOutstandingTotal,
                      stats->mRefsOutstandingSquared,
@@ -474,17 +474,17 @@ class nsDefaultComparator <BloatEntry*, 
     bool LessThan(BloatEntry* const& aA, BloatEntry* const& aB) const {
       return PL_strcmp(aA->GetClassName(), aB->GetClassName()) < 0;
     }
 };
 
 #endif /* NS_IMPL_REFCNT_LOGGING */
 
 nsresult
-nsTraceRefcntImpl::DumpStatistics(StatisticsType type, FILE* out)
+nsTraceRefcnt::DumpStatistics(StatisticsType type, FILE* out)
 {
 #ifdef NS_IMPL_REFCNT_LOGGING
   if (gBloatLog == nullptr || gBloatView == nullptr) {
     return NS_ERROR_FAILURE;
   }
   if (out == nullptr) {
     out = gBloatLog;
   }
@@ -522,32 +522,32 @@ nsTraceRefcntImpl::DumpStatistics(Statis
     for (uint32_t i = 0; i < count; ++i) {
       BloatEntry* entry = entries[i];
       entry->Dump(i, out, type);
     }
 
     fprintf(out, "\n");
   }
 
-  fprintf(out, "nsTraceRefcntImpl::DumpStatistics: %d entries\n", count);
+  fprintf(out, "nsTraceRefcnt::DumpStatistics: %d entries\n", count);
 
   if (gSerialNumbers) {
     fprintf(out, "\nSerial Numbers of Leaked Objects:\n");
     PL_HashTableEnumerateEntries(gSerialNumbers, DumpSerialNumbers, out);
   }
 
   gLogging = wasLogging;
   UNLOCK_TRACELOG();
 #endif
 
   return NS_OK;
 }
 
 void
-nsTraceRefcntImpl::ResetStatistics()
+nsTraceRefcnt::ResetStatistics()
 {
 #ifdef NS_IMPL_REFCNT_LOGGING
   LOCK_TRACELOG();
   if (gBloatView) {
     PL_HashTableDestroy(gBloatView);
     gBloatView = nullptr;
   }
   UNLOCK_TRACELOG();
@@ -851,17 +851,17 @@ static void PrintStackFrame(void *aPC, v
   NS_FormatCodeAddressDetails(aPC, &details, buf, sizeof(buf));
   fputs(buf, stream);
 }
 #endif
 
 }
 
 void
-nsTraceRefcntImpl::WalkTheStack(FILE* aStream)
+nsTraceRefcnt::WalkTheStack(FILE* aStream)
 {
 #ifdef STACKWALKING_AVAILABLE
   NS_StackWalk(PrintStackFrame, /* skipFrames */ 2, /* maxFrames */ 0, aStream,
                0, nullptr);
 #endif
 }
 
 //----------------------------------------------------------------------
@@ -869,17 +869,17 @@ nsTraceRefcntImpl::WalkTheStack(FILE* aS
 // This thing is exported by libstdc++
 // Yes, this is a gcc only hack
 #if defined(MOZ_DEMANGLE_SYMBOLS)
 #include <cxxabi.h>
 #include <stdlib.h> // for free()
 #endif // MOZ_DEMANGLE_SYMBOLS
 
 void
-nsTraceRefcntImpl::DemangleSymbol(const char * aSymbol,
+nsTraceRefcnt::DemangleSymbol(const char * aSymbol,
                               char * aBuffer,
                               int aBufLen)
 {
   NS_ASSERTION(nullptr != aSymbol,"null symbol");
   NS_ASSERTION(nullptr != aBuffer,"null buffer");
   NS_ASSERTION(aBufLen >= 32 ,"pulled 32 out of you know where");
 
   aBuffer[0] = '\0';
@@ -903,17 +903,17 @@ EXPORT_XPCOM_API(void)
 NS_LogInit()
 {
   // FIXME: This is called multiple times, we should probably not allow that.
 #ifdef STACKWALKING_AVAILABLE
   StackWalkInitCriticalAddress();
 #endif
 #ifdef NS_IMPL_REFCNT_LOGGING
   if (++gInitCount)
-    nsTraceRefcntImpl::SetActivityIsLegal(true);
+    nsTraceRefcnt::SetActivityIsLegal(true);
 #endif
 
 #ifdef NS_TRACE_MALLOC
   // XXX we don't have to worry about shutting down trace-malloc; it
   // handles this itself, through an atexit() callback.
   if (!NS_TraceMallocHasStarted())
     NS_TraceMallocStartup(-1);  // -1 == no logging
 #endif
@@ -945,22 +945,22 @@ LogTerm()
      * this solution, however, we need to guarantee that
      * BlockingResourceBase::Shutdown() runs after all other shutdown
      * functions.
      */
     BlockingResourceBase::Shutdown();
 #endif
     
     if (gInitialized) {
-      nsTraceRefcntImpl::DumpStatistics();
-      nsTraceRefcntImpl::ResetStatistics();
+      nsTraceRefcnt::DumpStatistics();
+      nsTraceRefcnt::ResetStatistics();
     }
-    nsTraceRefcntImpl::Shutdown();
+    nsTraceRefcnt::Shutdown();
 #ifdef NS_IMPL_REFCNT_LOGGING
-    nsTraceRefcntImpl::SetActivityIsLegal(false);
+    nsTraceRefcnt::SetActivityIsLegal(false);
     gActivityTLS = BAD_TLS_INDEX;
 #endif
   }
 }
 
 } // namespace mozilla
 
 EXPORT_XPCOM_API(void)
@@ -996,28 +996,28 @@ NS_LogAddRef(void* aPtr, nsrefcnt aRefcn
         (*count)++;
 
     }
 
     bool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
     if (aRefcnt == 1 && gAllocLog && loggingThisType && loggingThisObject) {
       fprintf(gAllocLog, "\n<%s> 0x%08X %" PRIdPTR " Create\n",
               aClazz, NS_PTR_TO_INT32(aPtr), serialno);
-      nsTraceRefcntImpl::WalkTheStack(gAllocLog);
+      nsTraceRefcnt::WalkTheStack(gAllocLog);
     }
 
     if (gRefcntsLog && loggingThisType && loggingThisObject) {
       if (gLogToLeaky) {
         (*leakyLogAddRef)(aPtr, aRefcnt - 1, aRefcnt);
       }
       else {
           // Can't use PR_LOG(), b/c it truncates the line
           fprintf(gRefcntsLog,
                   "\n<%s> 0x%08X %" PRIdPTR " AddRef %d\n", aClazz, NS_PTR_TO_INT32(aPtr), serialno, aRefcnt);
-          nsTraceRefcntImpl::WalkTheStack(gRefcntsLog);
+          nsTraceRefcnt::WalkTheStack(gRefcntsLog);
           fflush(gRefcntsLog);
       }
     }
     UNLOCK_TRACELOG();
   }
 #endif
 }
 
@@ -1055,29 +1055,29 @@ NS_LogRelease(void* aPtr, nsrefcnt aRefc
     if (gRefcntsLog && loggingThisType && loggingThisObject) {
       if (gLogToLeaky) {
         (*leakyLogRelease)(aPtr, aRefcnt + 1, aRefcnt);
       }
       else {
           // Can't use PR_LOG(), b/c it truncates the line
           fprintf(gRefcntsLog,
                   "\n<%s> 0x%08X %" PRIdPTR " Release %d\n", aClazz, NS_PTR_TO_INT32(aPtr), serialno, aRefcnt);
-          nsTraceRefcntImpl::WalkTheStack(gRefcntsLog);
+          nsTraceRefcnt::WalkTheStack(gRefcntsLog);
           fflush(gRefcntsLog);
       }
     }
 
     // Here's the case where MOZ_COUNT_DTOR was not used,
     // yet we still want to see deletion information:
 
     if (aRefcnt == 0 && gAllocLog && loggingThisType && loggingThisObject) {
       fprintf(gAllocLog,
               "\n<%s> 0x%08X %" PRIdPTR " Destroy\n",
               aClazz, NS_PTR_TO_INT32(aPtr), serialno);
-      nsTraceRefcntImpl::WalkTheStack(gAllocLog);
+      nsTraceRefcnt::WalkTheStack(gAllocLog);
     }
 
     if (aRefcnt == 0 && gSerialNumbers && loggingThisType) {
       RecycleSerialNumberPtr(aPtr);
     }
 
     UNLOCK_TRACELOG();
   }
@@ -1107,17 +1107,17 @@ NS_LogCtor(void* aPtr, const char* aType
     if (gSerialNumbers && loggingThisType) {
       serialno = GetSerialNumber(aPtr, true);
     }
 
     bool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
     if (gAllocLog && loggingThisType && loggingThisObject) {
       fprintf(gAllocLog, "\n<%s> 0x%08X %" PRIdPTR " Ctor (%d)\n",
              aType, NS_PTR_TO_INT32(aPtr), serialno, aInstanceSize);
-      nsTraceRefcntImpl::WalkTheStack(gAllocLog);
+      nsTraceRefcnt::WalkTheStack(gAllocLog);
     }
 
     UNLOCK_TRACELOG();
   }
 #endif
 }
 
 
@@ -1148,17 +1148,17 @@ NS_LogDtor(void* aPtr, const char* aType
 
     bool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
 
     // (If we're on a losing architecture, don't do this because we'll be
     // using LogDeleteXPCOM instead to get file and line numbers.)
     if (gAllocLog && loggingThisType && loggingThisObject) {
       fprintf(gAllocLog, "\n<%s> 0x%08X %" PRIdPTR " Dtor (%d)\n",
              aType, NS_PTR_TO_INT32(aPtr), serialno, aInstanceSize);
-      nsTraceRefcntImpl::WalkTheStack(gAllocLog);
+      nsTraceRefcnt::WalkTheStack(gAllocLog);
     }
 
     UNLOCK_TRACELOG();
   }
 #endif
 }
 
 
@@ -1189,17 +1189,17 @@ NS_LogCOMPtrAddRef(void* aCOMPtr, nsISup
     if(count)
       (*count)++;
 
     bool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
 
     if (gCOMPtrLog && loggingThisObject) {
       fprintf(gCOMPtrLog, "\n<?> 0x%08X %" PRIdPTR " nsCOMPtrAddRef %d 0x%08X\n",
               NS_PTR_TO_INT32(object), serialno, count?(*count):-1, NS_PTR_TO_INT32(aCOMPtr));
-      nsTraceRefcntImpl::WalkTheStack(gCOMPtrLog);
+      nsTraceRefcnt::WalkTheStack(gCOMPtrLog);
     }
 
     UNLOCK_TRACELOG();
   }
 #endif
 }
 
 
@@ -1230,40 +1230,40 @@ NS_LogCOMPtrRelease(void* aCOMPtr, nsISu
     if(count)
       (*count)--;
 
     bool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
 
     if (gCOMPtrLog && loggingThisObject) {
       fprintf(gCOMPtrLog, "\n<?> 0x%08X %" PRIdPTR " nsCOMPtrRelease %d 0x%08X\n",
               NS_PTR_TO_INT32(object), serialno, count?(*count):-1, NS_PTR_TO_INT32(aCOMPtr));
-      nsTraceRefcntImpl::WalkTheStack(gCOMPtrLog);
+      nsTraceRefcnt::WalkTheStack(gCOMPtrLog);
     }
 
     UNLOCK_TRACELOG();
   }
 #endif
 }
 
 void
-nsTraceRefcntImpl::Startup()
+nsTraceRefcnt::Startup()
 {
 }
 
 static void maybeUnregisterAndCloseFile(FILE *&f) {
   if (!f)
     return;
 
   MozillaUnRegisterDebugFILE(f);
   fclose(f);
   f = nullptr;
 }
 
 void
-nsTraceRefcntImpl::Shutdown()
+nsTraceRefcnt::Shutdown()
 {
 #ifdef NS_IMPL_REFCNT_LOGGING
 
   if (gBloatView) {
     PL_HashTableDestroy(gBloatView);
     gBloatView = nullptr;
   }
   if (gTypesToLog) {
@@ -1282,17 +1282,17 @@ nsTraceRefcntImpl::Shutdown()
   maybeUnregisterAndCloseFile(gRefcntsLog);
   maybeUnregisterAndCloseFile(gAllocLog);
   maybeUnregisterAndCloseFile(gLeakyLog);
   maybeUnregisterAndCloseFile(gCOMPtrLog);
 #endif
 }
 
 void
-nsTraceRefcntImpl::SetActivityIsLegal(bool aLegal)
+nsTraceRefcnt::SetActivityIsLegal(bool aLegal)
 {
 #ifdef NS_IMPL_REFCNT_LOGGING
   if (gActivityTLS == BAD_TLS_INDEX)
     PR_NewThreadPrivateIndex(&gActivityTLS, nullptr);
 
   PR_SetThreadPrivate(gActivityTLS, NS_INT32_TO_PTR(!aLegal));
 #endif
 }
diff --git a/xpcom/base/nsTraceRefcntImpl.h b/xpcom/base/nsTraceRefcnt.h
rename from xpcom/base/nsTraceRefcntImpl.h
rename to xpcom/base/nsTraceRefcnt.h
--- a/xpcom/base/nsTraceRefcntImpl.h
+++ b/xpcom/base/nsTraceRefcnt.h
@@ -1,19 +1,19 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-#ifndef nsTraceRefcntImpl_h___
-#define nsTraceRefcntImpl_h___
+#ifndef nsTraceRefcnt_h___
+#define nsTraceRefcnt_h___
 
 #include <stdio.h> // for FILE
 #include "nscore.h"
 
-class nsTraceRefcntImpl
+class nsTraceRefcnt
 {
 public:
   static void Startup();
   static void Shutdown();
 
   enum StatisticsType {
     ALL_STATS,
     NEW_STATS
diff --git a/xpcom/build/PoisonIOInterposerMac.cpp b/xpcom/build/PoisonIOInterposerMac.cpp
--- a/xpcom/build/PoisonIOInterposerMac.cpp
+++ b/xpcom/build/PoisonIOInterposerMac.cpp
@@ -12,17 +12,17 @@
 #include "mozilla/DebugOnly.h"
 #include "mozilla/IOInterposer.h"
 #include "mozilla/Mutex.h"
 #include "mozilla/ProcessedStack.h"
 #include "mozilla/Scoped.h"
 #include "mozilla/Telemetry.h"
 #include "nsPrintfCString.h"
 #include "nsStackWalk.h"
-#include "nsTraceRefcntImpl.h"
+#include "nsTraceRefcnt.h"
 #include "plstr.h"
 #include "prio.h"
 
 #include <algorithm>
 #include <vector>
 
 #include <sys/param.h>
 #include <sys/stat.h>
diff --git a/xpcom/build/nsXPComInit.cpp b/xpcom/build/nsXPComInit.cpp
--- a/xpcom/build/nsXPComInit.cpp
+++ b/xpcom/build/nsXPComInit.cpp
@@ -24,17 +24,17 @@
 #include "nsScriptableInputStream.h"
 #include "nsBinaryStream.h"
 #include "nsStorageStream.h"
 #include "nsPipe.h"
 #include "nsScriptableBase64Encoder.h"
 
 #include "nsMemoryImpl.h"
 #include "nsDebugImpl.h"
-#include "nsTraceRefcntImpl.h"
+#include "nsTraceRefcnt.h"
 #include "nsErrorService.h"
 
 #include "nsSupportsArray.h"
 #include "nsArray.h"
 #include "nsINIParserImpl.h"
 #include "nsSupportsPrimitives.h"
 #include "nsConsoleService.h"
 
diff --git a/xpcom/components/nsNativeComponentLoader.cpp b/xpcom/components/nsNativeComponentLoader.cpp
--- a/xpcom/components/nsNativeComponentLoader.cpp
+++ b/xpcom/components/nsNativeComponentLoader.cpp
@@ -24,17 +24,17 @@
 #include "prlog.h"
 #include "prinit.h"
 #include "prerror.h"
 
 #include "nsComponentManager.h"
 #include "ManifestParser.h" // for LogMessage
 #include "nsCRTGlue.h"
 #include "nsThreadUtils.h"
-#include "nsTraceRefcntImpl.h"
+#include "nsTraceRefcnt.h"
 
 #include "nsIFile.h"
 #include "mozilla/WindowsDllBlocklist.h"
 
 #ifdef XP_WIN
 #include <windows.h>
 #endif
 
@@ -215,28 +215,28 @@ nsNativeModuleLoader::UnloaderFunc(nsIHa
         nsAutoCString filePath;
         file->GetNativePath(filePath);
 
         LOG(PR_LOG_DEBUG,
             ("nsNativeModuleLoader::UnloaderFunc(\"%s\")", filePath.get()));
     }
 
 #ifdef NS_BUILD_REFCNT_LOGGING
-    nsTraceRefcntImpl::SetActivityIsLegal(false);
+    nsTraceRefcnt::SetActivityIsLegal(false);
 #endif
 
 #if 0
     // XXXbsmedberg: do this as soon as the static-destructor crash(es)
     // are fixed
     PRStatus ret = PR_UnloadLibrary(aLoadData.library);
     NS_ASSERTION(ret == PR_SUCCESS, "Failed to unload library");
 #endif
 
 #ifdef NS_BUILD_REFCNT_LOGGING
-    nsTraceRefcntImpl::SetActivityIsLegal(true);
+    nsTraceRefcnt::SetActivityIsLegal(true);
 #endif
 
     return PL_DHASH_REMOVE;
 }
 
 void
 nsNativeModuleLoader::UnloadLibraries()
 {
diff --git a/xpcom/io/nsLocalFileUnix.cpp b/xpcom/io/nsLocalFileUnix.cpp
--- a/xpcom/io/nsLocalFileUnix.cpp
+++ b/xpcom/io/nsLocalFileUnix.cpp
@@ -65,17 +65,17 @@ static nsresult MacErrorMapper(OSErr inE
 #include <linux/magic.h>
 #endif
 
 #ifdef MOZ_ENABLE_CONTENTACTION
 #include <contentaction/contentaction.h>
 #endif
 
 #include "nsNativeCharsetUtils.h"
-#include "nsTraceRefcntImpl.h"
+#include "nsTraceRefcnt.h"
 #include "nsHashKeys.h"
 
 using namespace mozilla;
 
 #define ENSURE_STAT_CACHE()                     \
     PR_BEGIN_MACRO                              \
         if (!FillStatCache())                   \
              return NSRESULT_FOR_ERRNO();       \
@@ -1732,23 +1732,23 @@ nsLocalFile::GetDirectoryEntries(nsISimp
 NS_IMETHODIMP
 nsLocalFile::Load(PRLibrary **_retval)
 {
     CHECK_mPath();
     if (NS_WARN_IF(!_retval))
         return NS_ERROR_INVALID_ARG;
 
 #ifdef NS_BUILD_REFCNT_LOGGING
-    nsTraceRefcntImpl::SetActivityIsLegal(false);
+    nsTraceRefcnt::SetActivityIsLegal(false);
 #endif
 
     *_retval = PR_LoadLibrary(mPath.get());
 
 #ifdef NS_BUILD_REFCNT_LOGGING
-    nsTraceRefcntImpl::SetActivityIsLegal(true);
+    nsTraceRefcnt::SetActivityIsLegal(true);
 #endif
 
     if (!*_retval)
         return NS_ERROR_FAILURE;
     return NS_OK;
 }
 
 NS_IMETHODIMP
diff --git a/xpcom/io/nsLocalFileWin.cpp b/xpcom/io/nsLocalFileWin.cpp
--- a/xpcom/io/nsLocalFileWin.cpp
+++ b/xpcom/io/nsLocalFileWin.cpp
@@ -41,17 +41,17 @@
 
 #include "nsXPIDLString.h"
 #include "prproces.h"
 #include "prlink.h"
 
 #include "mozilla/Mutex.h"
 #include "SpecialSystemDirectory.h"
 
-#include "nsTraceRefcntImpl.h"
+#include "nsTraceRefcnt.h"
 #include "nsXPCOMCIDInternal.h"
 #include "nsThreadUtils.h"
 #include "nsXULAppAPI.h"
 
 using namespace mozilla;
 
 #define CHECK_mWorkingPath()                    \
     PR_BEGIN_MACRO                              \
@@ -2221,26 +2221,26 @@ nsLocalFile::Load(PRLibrary * *_retval)
 
     if (NS_FAILED(rv))
         return rv;
 
     if (! isFile)
         return NS_ERROR_FILE_IS_DIRECTORY;
 
 #ifdef NS_BUILD_REFCNT_LOGGING
-    nsTraceRefcntImpl::SetActivityIsLegal(false);
+    nsTraceRefcnt::SetActivityIsLegal(false);
 #endif
 
     PRLibSpec libSpec;
     libSpec.value.pathname_u = mResolvedPath.get();
     libSpec.type = PR_LibSpec_PathnameU;
     *_retval =  PR_LoadLibraryWithFlags(libSpec, 0);
 
 #ifdef NS_BUILD_REFCNT_LOGGING
-    nsTraceRefcntImpl::SetActivityIsLegal(true);
+    nsTraceRefcnt::SetActivityIsLegal(true);
 #endif
 
     if (*_retval)
         return NS_OK;
     return NS_ERROR_NULL_POINTER;
 }
 
 NS_IMETHODIMP
diff --git a/xpcom/tests/TestStackCrawl.cpp b/xpcom/tests/TestStackCrawl.cpp
--- a/xpcom/tests/TestStackCrawl.cpp
+++ b/xpcom/tests/TestStackCrawl.cpp
@@ -1,11 +1,11 @@
 #include <stdio.h>
 
 #include "nsISupportsUtils.h"
-#include "nsTraceRefCntImpl.h"
+#include "nsTraceRefcnt.h"
 
 int main(int argc, char* argv[])
 {
-    nsTraceRefcntImpl::WalkTheStack(stdout);
+    nsTraceRefcnt::WalkTheStack(stdout);
     return 0;
 }
 
