From: L. David Baron <dbaron@dbaron.org>

Add parameter allowing LookupProperty to return an alias.  (Bug 784461, patch 2)

TODO: Should probably return the alias in an out param instead.

diff --git a/layout/style/nsCSSProps.cpp b/layout/style/nsCSSProps.cpp
--- a/layout/style/nsCSSProps.cpp
+++ b/layout/style/nsCSSProps.cpp
@@ -370,68 +370,75 @@ nsCSSProps::IsCustomPropertyName(const n
 nsCSSProps::IsCustomPropertyName(const nsAString& aProperty)
 {
   return aProperty.Length() >= (VAR_PREFIX_LENGTH + 1) &&
          StringBeginsWith(aProperty, NS_LITERAL_STRING("var-"));
 }
 
 /* static */ nsCSSProperty
 nsCSSProps::DoLookupProperty(nsCSSProperty aTableLookupResult,
-                             EnabledState aEnabled)
+                             EnabledState aEnabled,
+                             AliasHandling aAliasHandling)
 {
   nsCSSProperty res = aTableLookupResult;
+  if (res != eCSSProperty_UNKNOWN && aEnabled == eEnabled && !IsEnabled(res)) {
+    res = eCSSProperty_UNKNOWN;
+  }
   // Check eCSSAliasCount against 0 to make it easy for the
   // compiler to optimize away the 0-aliases case.
   if (eCSSAliasCount != 0 && res >= eCSSProperty_COUNT) {
     static_assert(eCSSProperty_UNKNOWN < eCSSProperty_COUNT,
                   "assuming eCSSProperty_UNKNOWN doesn't hit this code");
-    if (IsEnabled(res) || aEnabled == eAny) {
-      res = gAliases[res - eCSSProperty_COUNT];
-      NS_ABORT_IF_FALSE(0 <= res && res < eCSSProperty_COUNT,
-                        "aliases must not point to other aliases");
-    } else {
+    nsCSSProperty aliasTarget = gAliases[res - eCSSProperty_COUNT];
+    NS_ABORT_IF_FALSE(0 <= aliasTarget && aliasTarget < eCSSProperty_COUNT,
+                      "aliases must not point to other aliases");
+    if (aEnabled == eEnabled && !IsEnabled(aliasTarget)) {
+      // We need to check whether the alias's target is enabled whether
+      // or not we want to return the alias or its target.
       res = eCSSProperty_UNKNOWN;
+    } else if (aAliasHandling == eResolveAliases) {
+      res = aliasTarget;
     }
   }
-  if (res != eCSSProperty_UNKNOWN && aEnabled == eEnabled && !IsEnabled(res)) {
-    res = eCSSProperty_UNKNOWN;
-  }
   return res;
 }
 
 nsCSSProperty
 nsCSSProps::LookupProperty(const nsACString& aProperty,
-                           EnabledState aEnabled)
+                           EnabledState aEnabled,
+                           AliasHandling aAliasHandling)
 {
   NS_ABORT_IF_FALSE(gPropertyTable, "no lookup table, needs addref");
 
   if (nsLayoutUtils::CSSVariablesEnabled() &&
       IsCustomPropertyName(aProperty)) {
     return eCSSPropertyExtra_variable;
   }
 
   return DoLookupProperty(nsCSSProperty(gPropertyTable->Lookup(aProperty)),
-                          aEnabled);
+                          aEnabled, aAliasHandling);
 }
 
 nsCSSProperty
-nsCSSProps::LookupProperty(const nsAString& aProperty, EnabledState aEnabled)
+nsCSSProps::LookupProperty(const nsAString& aProperty,
+                           EnabledState aEnabled,
+                           AliasHandling aAliasHandling)
 {
   NS_ABORT_IF_FALSE(gPropertyTable, "no lookup table, needs addref");
 
   if (nsLayoutUtils::CSSVariablesEnabled() &&
       IsCustomPropertyName(aProperty)) {
     return eCSSPropertyExtra_variable;
   }
 
   // This is faster than converting and calling
   // LookupProperty(nsACString&).  The table will do its own
   // converting and avoid a PromiseFlatCString() call.
   return DoLookupProperty(nsCSSProperty(gPropertyTable->Lookup(aProperty)),
-                          aEnabled);
+                          aEnabled, aAliasHandling);
 }
 
 nsCSSFontDesc
 nsCSSProps::LookupFontDesc(const nsACString& aFontDesc)
 {
   NS_ABORT_IF_FALSE(gFontDescTable, "no lookup table, needs addref");
   return nsCSSFontDesc(gFontDescTable->Lookup(aFontDesc));
 }
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -249,26 +249,35 @@ public:
   static void AddRefTable(void);
   static void ReleaseTable(void);
 
   // Given a property string, return the enum value
   enum EnabledState {
     eEnabled,
     eAny
   };
+  enum AliasHandling {
+    eResolveAliases,
+    eReturnAliases
+  };
   // Looks up the property with name aProperty and returns its corresponding
   // nsCSSProperty value.  If aProperty is the name of a custom property,
   // then eCSSPropertyExtra_variable will be returned.
   static nsCSSProperty LookupProperty(const nsAString& aProperty,
-                                      EnabledState aEnabled);
+                                      EnabledState aEnabled,
+                                      AliasHandling aAliasHandling =
+                                                      eResolveAliases);
   static nsCSSProperty LookupProperty(const nsACString& aProperty,
-                                      EnabledState aEnabled);
+                                      EnabledState aEnabled,
+                                      AliasHandling aAliasHandling =
+                                                      eResolveAliases);
 private:
   static nsCSSProperty DoLookupProperty(nsCSSProperty aTableLookupResult,
-                                        EnabledState aEnabled);
+                                        EnabledState aEnabled,
+                                        AliasHandling aAliasHandling);
 public:
   // Returns whether aProperty is a custom property name, i.e. begins with
   // "var-" and has at least one more character.  This assumes that
   // the CSS Variables pref has been enabled.
   static bool IsCustomPropertyName(const nsAString& aProperty);
   static bool IsCustomPropertyName(const nsACString& aProperty);
 
   static inline bool IsShorthand(nsCSSProperty aProperty) {
