Add nsTArray<E>::TruncateLength, which is like SetLength, except only allows shortening of the array.  (Bug 191448)  r=bsmedberg

diff --git a/layout/generic/nsFloatManager.cpp b/layout/generic/nsFloatManager.cpp
--- a/layout/generic/nsFloatManager.cpp
+++ b/layout/generic/nsFloatManager.cpp
@@ -280,17 +280,17 @@ nsFloatManager::RemoveTrailingRegions(ns
 
   PRUint32 newLength = mFloats.Length();
   while (newLength > 0) {
     if (!frameSet.Contains(mFloats[newLength - 1].mFrame)) {
       break;
     }
     --newLength;
   }
-  mFloats.RemoveElementsAt(newLength, mFloats.Length() - newLength);
+  mFloats.TruncateLength(newLength);
 
 #ifdef DEBUG
   for (PRUint32 i = 0; i < mFloats.Length(); ++i) {
     NS_ASSERTION(!frameSet.Contains(mFloats[i].mFrame),
                  "Frame region deletion was requested but we couldn't delete it");
   }
 #endif
 
@@ -329,18 +329,17 @@ nsFloatManager::PopState(SavedState* aSt
 {
   NS_PRECONDITION(aState, "No state to restore?");
 
   mX = aState->mX;
   mY = aState->mY;
 
   NS_ASSERTION(aState->mFloatInfoCount <= mFloats.Length(),
                "somebody misused PushState/PopState");
-  mFloats.RemoveElementsAt(aState->mFloatInfoCount,
-                           mFloats.Length() - aState->mFloatInfoCount);
+  mFloats.TruncateLength(aState->mFloatInfoCount);
 }
 
 nscoord
 nsFloatManager::GetLowestFloatTop() const
 {
   if (!HasAnyFloats()) {
     return nscoord_MIN;
   }
diff --git a/xpcom/glue/nsTArray.h b/xpcom/glue/nsTArray.h
--- a/xpcom/glue/nsTArray.h
+++ b/xpcom/glue/nsTArray.h
@@ -655,24 +655,39 @@ class nsTArray : public nsTArray_base {
     }
 
     // This method modifies the length of the array.  If the new length is
     // larger than the existing length of the array, then new elements will be
     // constructed using elem_type's default constructor.  Otherwise, this call
     // removes elements from the array (see also RemoveElementsAt).
     // @param newLen  The desired length of this array.
     // @return        True if the operation succeeded; false otherwise.
+    // See also TruncateLength if the new length is guaranteed to be
+    // smaller than the old.
     PRBool SetLength(size_type newLen) {
       size_type oldLen = Length();
       if (newLen > oldLen) {
         return InsertElementsAt(oldLen, newLen - oldLen) != nsnull;
       }
       
+      TruncateLength(newLen);
+      return PR_TRUE;
+    }
+
+    // This method modifies the length of the array, but may only be
+    // called when the new length is shorter than the old.  It can
+    // therefore be called when elem_type has no default constructor,
+    // unlike SetLength.  It removes elements from the array (see also
+    // RemoveElementsAt).
+    // @param newLen  The desired length of this array.
+    void TruncateLength(size_type newLen) {
+      size_type oldLen = Length();
+      NS_ABORT_IF_FALSE(newLen <= oldLen,
+                        "caller should use SetLength instead");
       RemoveElementsAt(newLen, oldLen - newLen);
-      return PR_TRUE;
     }
 
     // This method inserts elements into the array, constructing
     // them using elem_type's default constructor.
     // @param index the place to insert the new elements. This must be no
     //              greater than the current length of the array.
     // @param count the number of elements to insert
     elem_type *InsertElementsAt(index_type index, size_type count) {
