From: L. David Baron <dbaron@dbaron.org>

Bug 804970, patch 3: Don't force vw/vh/vmin/vmax units out of the rule tree.

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -264,45 +264,68 @@ static nscoord CalcLengthWith(const nsCS
     // properties by not calling CalcLength in those cases:  SetCoord
     // only calls CalcLength for a calc when it is appropriate to do so.
     CalcLengthCalcOps ops(aFontSize, aStyleFont,
                           aStyleContext, aPresContext,
                           aUseProvidedRootEmSize, aUseUserFontSet,
                           aCanStoreInRuleTree);
     return css::ComputeCalc(aValue, ops);
   }
+  switch (aValue.GetUnit()) {
+    // nsPresContext::SetVisibleArea and
+    // nsPresContext::MediaFeatureValuesChanged handle dynamic changes
+    // of the basis for viewport units by rebuilding the rule tree and
+    // style context tree.  Not caching them in the rule tree wouldn't
+    // be sufficient to handle these changes because we also need a way
+    // to get rid of cached values in the style context tree without any
+    // changes in specified style.  We can either do this by not caching
+    // in the rule tree and then throwing away the style context tree
+    // for dynamic viewport size changes, or by allowing caching in the
+    // rule tree and using the existing rebuild style data path that
+    // throws away the style context and the rule tree.
+    // Thus we do cache viewport units in the rule tree.  This allows us
+    // to benefit from the performance advantages of the rule tree
+    // (e.g., faster dynamic changes on other things, like transforms)
+    // and allows us not to need an additional code path, in exchange
+    // for an increased cost to dynamic changes to the viewport size
+    // when viewport units are in use.
+    case eCSSUnit_ViewportWidth: {
+      aPresContext->SetUsesViewportUnits(true);
+      return ScaleCoord(aValue, 0.01f * aPresContext->GetVisibleArea().width);
+    }
+    case eCSSUnit_ViewportHeight: {
+      aPresContext->SetUsesViewportUnits(true);
+      return ScaleCoord(aValue, 0.01f * aPresContext->GetVisibleArea().height);
+    }
+    case eCSSUnit_ViewportMin: {
+      aPresContext->SetUsesViewportUnits(true);
+      nsSize viewportSize = aPresContext->GetVisibleArea().Size();
+      return ScaleCoord(aValue, 0.01f * min(viewportSize.width, viewportSize.height));
+    }
+    case eCSSUnit_ViewportMax: {
+      aPresContext->SetUsesViewportUnits(true);
+      nsSize viewportSize = aPresContext->GetVisibleArea().Size();
+      return ScaleCoord(aValue, 0.01f * max(viewportSize.width, viewportSize.height));
+    }
+    default:
+      // Fall through to the code for units that can't be stored in the
+      // rule tree because they depend on font data.
+      break;
+  }
   // Common code for all units other than pixel-based units and fixed-length
   // units:
   aCanStoreInRuleTree = false;
   const nsStyleFont *styleFont =
     aStyleFont ? aStyleFont : aStyleContext->GetStyleFont();
   if (aFontSize == -1) {
     // XXX Should this be styleFont->mSize instead to avoid taking minfontsize
     // prefs into account?
     aFontSize = styleFont->mFont.size;
   }
   switch (aValue.GetUnit()) {
-    case eCSSUnit_ViewportWidth: {
-      aPresContext->SetUsesViewportUnits(true);
-      return ScaleCoord(aValue, 0.01f * aPresContext->GetVisibleArea().width);
-    }
-    case eCSSUnit_ViewportHeight: {
-      aPresContext->SetUsesViewportUnits(true);
-      return ScaleCoord(aValue, 0.01f * aPresContext->GetVisibleArea().height);
-    }
-    case eCSSUnit_ViewportMin: {
-      aPresContext->SetUsesViewportUnits(true);
-      nsSize viewportSize = aPresContext->GetVisibleArea().Size();
-      return ScaleCoord(aValue, 0.01f * min(viewportSize.width, viewportSize.height));
-    }
-    case eCSSUnit_ViewportMax: {
-      aPresContext->SetUsesViewportUnits(true);
-      nsSize viewportSize = aPresContext->GetVisibleArea().Size();
-      return ScaleCoord(aValue, 0.01f * max(viewportSize.width, viewportSize.height));
-    }
     case eCSSUnit_RootEM: {
       nscoord rootFontSize;
 
       if (aUseProvidedRootEmSize) {
         // We should use the provided aFontSize as the reference length to
         // scale. This only happens when we are calculating font-size or
         // an equivalent (scriptminsize or CalcLengthWithInitialFont) on
         // the root element, in which case aFontSize is already the
