Distribute extra space in fixed-layout tables where all columns have widths proportionally rather than equally, for compatibility.  (Bug 445142)

diff --git a/layout/tables/FixedTableLayoutStrategy.cpp b/layout/tables/FixedTableLayoutStrategy.cpp
--- a/layout/tables/FixedTableLayoutStrategy.cpp
+++ b/layout/tables/FixedTableLayoutStrategy.cpp
@@ -197,34 +197,39 @@ FixedTableLayoutStrategy::ComputeColumnW
 
     // XXX Should we really ignore widths on column groups?
 
     PRUint32 unassignedCount = 0;
     nscoord unassignedSpace = tableWidth;
     const nscoord unassignedMarker = nscoord_MIN;
 
     // We use the PrefPercent on the columns to store the percentages
-    // used to compute column widths in case we need to reduce their
-    // basis.
+    // used to compute column widths in case we need to shrink or expand
+    // the columns.
     float pctTotal = 0.0f;
+
+    // Accumulate the total specified (non-percent) on the columns for
+    // distributing excess width to the columns.
+    nscoord specTotal = 0;
 
     for (PRInt32 col = 0; col < colCount; ++col) {
         nsTableColFrame *colFrame = mTableFrame->GetColFrame(col);
         if (!colFrame) {
             NS_ERROR("column frames out of sync with cell map");
             continue;
         }
         colFrame->ResetPrefPercent();
         const nsStyleCoord *styleWidth =
             &colFrame->GetStylePosition()->mWidth;
         nscoord colWidth;
         if (styleWidth->GetUnit() == eStyleUnit_Coord) {
             colWidth = nsLayoutUtils::ComputeWidthValue(
                          aReflowState.rendContext,
                          colFrame, 0, 0, 0, *styleWidth);
+            specTotal += colWidth;
         } else if (styleWidth->GetUnit() == eStyleUnit_Percent) {
             float pct = styleWidth->GetPercentValue();
             colWidth = NSToCoordFloor(pct * float(tableWidth));
             colFrame->AddPrefPercent(pct);
             pctTotal += pct;
         } else {
             NS_ASSERTION(styleWidth->GetUnit() == eStyleUnit_Auto ||
                          styleWidth->GetUnit() == eStyleUnit_Enumerated,
@@ -270,16 +275,19 @@ FixedTableLayoutStrategy::ComputeColumnW
                         // If a column-spanning cell is in the first
                         // row, split up the space evenly.  (XXX This
                         // isn't quite right if some of the columns it's
                         // in have specified widths.  Should we care?)
                         colWidth = ((colWidth + spacing) / colSpan) - spacing;
                         if (colWidth < 0)
                             colWidth = 0;
                     }
+                    if (styleWidth->GetUnit() != eStyleUnit_Percent) {
+                        specTotal += colWidth;
+                    }
                 }
             } else {
                 colWidth = unassignedMarker;
             }
         }
 
         colFrame->SetFinalWidth(colWidth);
 
@@ -311,33 +319,85 @@ FixedTableLayoutStrategy::ComputeColumnW
                     colWidth = 0;
                 colFrame->SetFinalWidth(colWidth);
             }
         }
         unassignedSpace = 0;
     }
 
     if (unassignedCount > 0) {
+        // The spec says to distribute the remaining space evenly among
+        // the columns.
         nscoord toAssign = unassignedSpace / unassignedCount;
         for (PRInt32 col = 0; col < colCount; ++col) {
             nsTableColFrame *colFrame = mTableFrame->GetColFrame(col);
             if (!colFrame) {
                 NS_ERROR("column frames out of sync with cell map");
                 continue;
             }
             if (colFrame->GetFinalWidth() == unassignedMarker)
                 colFrame->SetFinalWidth(toAssign);
         }
     } else if (unassignedSpace > 0) {
-        // The spec says to distribute extra space evenly.  (That's not
-        // what WinIE6 does, though.  It treats percentages and
-        // nonpercentages differently.)
-        nscoord toAdd = unassignedSpace / colCount;
-        for (PRInt32 col = 0; col < colCount; ++col) {
-            nsTableColFrame *colFrame = mTableFrame->GetColFrame(col);
-            if (!colFrame) {
-                NS_ERROR("column frames out of sync with cell map");
-                continue;
+        // The spec doesn't say how to distribute the unassigned space.
+        if (specTotal > 0) {
+            // Distribute proportionally to non-percentage columns.
+            nscoord specUndist = specTotal;
+            for (PRInt32 col = 0; col < colCount; ++col) {
+                nsTableColFrame *colFrame = mTableFrame->GetColFrame(col);
+                if (!colFrame) {
+                    NS_ERROR("column frames out of sync with cell map");
+                    continue;
+                }
+                if (colFrame->GetPrefPercent() == 0.0f) {
+                    NS_ASSERTION(colFrame->GetFinalWidth() <= specUndist,
+                                 "widths don't add up");
+                    nscoord toAdd = NSToCoordRound(float(unassignedSpace) *
+                       (float(colFrame->GetFinalWidth()) / float(specUndist)));
+                    specUndist -= colFrame->GetFinalWidth();
+                    colFrame->SetFinalWidth(colFrame->GetFinalWidth() + toAdd);
+                    unassignedSpace -= toAdd;
+                    if (specUndist == 0) {
+                        break;
+                    }
+                }
             }
-            colFrame->SetFinalWidth(colFrame->GetFinalWidth() + toAdd);
+            NS_ASSERTION(unassignedSpace == 0, "failed to redistribute");
+        } else if (pctTotal > 0) {
+            // Distribute proportionally to percentage columns.
+            float pctUndist = pctTotal;
+            for (PRInt32 col = 0; col < colCount; ++col) {
+                nsTableColFrame *colFrame = mTableFrame->GetColFrame(col);
+                if (!colFrame) {
+                    NS_ERROR("column frames out of sync with cell map");
+                    continue;
+                }
+                NS_ASSERTION(colFrame->GetPrefPercent() <= pctUndist,
+                             "widths don't add up");
+                nscoord toAdd = NSToCoordRound(float(unassignedSpace) *
+                    (colFrame->GetPrefPercent() / pctUndist));
+                colFrame->SetFinalWidth(colFrame->GetFinalWidth() + toAdd);
+                unassignedSpace -= toAdd;
+                pctUndist -= colFrame->GetPrefPercent();
+                if (pctUndist <= 0.0f) {
+                    break;
+                }
+            }
+            NS_ASSERTION(unassignedSpace == 0, "failed to redistribute");
+        } else {
+            // Distribute equally to the zero-width columns.
+            PRInt32 colsLeft = colCount;
+            for (PRInt32 col = 0; col < colCount; ++col) {
+                nsTableColFrame *colFrame = mTableFrame->GetColFrame(col);
+                if (!colFrame) {
+                    NS_ERROR("column frames out of sync with cell map");
+                    continue;
+                }
+                NS_ASSERTION(colFrame->GetFinalWidth() == 0, "yikes");
+                nscoord toAdd = NSToCoordRound(float(unassignedSpace) /
+                                               float(colsLeft));
+                colFrame->SetFinalWidth(toAdd);
+                unassignedSpace -= toAdd;
+                --colsLeft;
+            }
         }
     }
 }
