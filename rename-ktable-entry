From: L. David Baron <dbaron@dbaron.org>

Bug 1224464 patch 3 - Rename KTableValue to KTableEntry now that it is a struct.  r?heycam

diff --git a/layout/inspector/inDOMUtils.cpp b/layout/inspector/inDOMUtils.cpp
--- a/layout/inspector/inDOMUtils.cpp
+++ b/layout/inspector/inDOMUtils.cpp
@@ -572,17 +572,17 @@ static void InsertNoDuplicates(nsTArray<
 
 static void GetKeywordsForProperty(const nsCSSProperty aProperty,
                                    nsTArray<nsString>& aArray)
 {
   if (nsCSSProps::IsShorthand(aProperty)) {
     // Shorthand props have no keywords.
     return;
   }
-  const nsCSSProps::KTableValue *keywordTable =
+  const nsCSSProps::KTableEntry* keywordTable =
     nsCSSProps::kKeywordTableTable[aProperty];
   if (keywordTable) {
     for (size_t i = 0; keywordTable[i].mKeyword != eCSSKeyword_UNKNOWN; ++i) {
       nsCSSKeyword word = keywordTable[i].mKeyword;
       InsertNoDuplicates(aArray,
                          NS_ConvertASCIItoUTF16(nsCSSKeywords::GetStringValue(word)));
       // Increment counter by 2, because in this table every second
       // element is a nsCSSKeyword.
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -48,17 +48,17 @@
 #include "mozilla/Preferences.h"
 #include "nsRuleData.h"
 #include "mozilla/CSSVariableValues.h"
 #include "mozilla/dom/URL.h"
 #include "gfxFontFamilyList.h"
 
 using namespace mozilla;
 
-typedef nsCSSProps::KTableValue KTableValue;
+typedef nsCSSProps::KTableEntry KTableEntry;
 
 // pref-backed bool values (hooked up in nsCSSParser::Startup)
 static bool sOpentypeSVGEnabled;
 static bool sWebkitPrefixedAliasesEnabled;
 static bool sUnprefixingServiceEnabled;
 #ifdef NIGHTLY_BUILD
 static bool sUnprefixingServiceGloballyWhitelisted;
 #endif
@@ -761,17 +761,17 @@ protected:
                         bool* aChanged,
                         nsCSSContextType aContext = eCSSContext_General);
 
   // A "prefix-aware" wrapper for nsCSSKeywords::LookupKeyword().
   // Use this instead of LookupKeyword() if you might be parsing an unprefixed
   // property (like "display") for which we emulate a vendor-prefixed value
   // (like "-webkit-box").
   nsCSSKeyword LookupKeywordPrefixAware(nsAString& aKeywordStr,
-                                        const KTableValue aKeywordTable[]);
+                                        const KTableEntry aKeywordTable[]);
 
   bool ShouldUseUnprefixingService() const;
   bool ParsePropertyWithUnprefixingService(const nsAString& aPropertyName,
                                            css::Declaration* aDeclaration,
                                            uint32_t aFlags,
                                            bool aMustCallValueAppended,
                                            bool* aChanged,
                                            nsCSSContextType aContext);
@@ -933,17 +933,17 @@ protected:
   bool ParseGridLine(nsCSSValue& aValue);
   bool ParseGridColumnRowStartEnd(nsCSSProperty aPropID);
   bool ParseGridColumnRow(nsCSSProperty aStartPropID,
                           nsCSSProperty aEndPropID);
   bool ParseGridArea();
 
   // parsing 'align/justify-items/self' from the css-align spec
   bool ParseAlignJustifyPosition(nsCSSValue& aResult,
-                                 const KTableValue aTable[]);
+                                 const KTableEntry aTable[]);
   bool ParseJustifyItems();
   bool ParseAlignItemsSelfJustifySelf(nsCSSProperty aPropID);
   // parsing 'align/justify-content' from the css-align spec
   bool ParseAlignJustifyContent(nsCSSProperty aPropID);
 
   // for 'clip' and '-moz-image-region'
   bool ParseRect(nsCSSProperty aPropID);
   bool ParseColumns();
@@ -953,17 +953,17 @@ protected:
   bool ParseCursor();
   bool ParseFont();
   bool ParseFontSynthesis(nsCSSValue& aValue);
   bool ParseSingleAlternate(int32_t& aWhichFeature, nsCSSValue& aValue);
   bool ParseFontVariantAlternates(nsCSSValue& aValue);
   bool MergeBitmaskValue(int32_t aNewValue, const int32_t aMasks[],
                          int32_t& aMergedValue);
   bool ParseBitmaskValues(nsCSSValue& aValue,
-                          const KTableValue aKeywordTable[],
+                          const KTableEntry aKeywordTable[],
                           const int32_t aMasks[]);
   bool ParseFontVariantEastAsian(nsCSSValue& aValue);
   bool ParseFontVariantLigatures(nsCSSValue& aValue);
   bool ParseFontVariantNumeric(nsCSSValue& aValue);
   bool ParseFontVariant();
   bool ParseFontWeight(nsCSSValue& aValue);
   bool ParseOneFamily(nsAString& aFamily, bool& aOneKeyword, bool& aQuoted);
   bool ParseFamily(nsCSSValue& aValue);
@@ -977,17 +977,17 @@ protected:
   bool ParseClipPath();
   bool ParseTransform(bool aIsPrefixed);
   bool ParseObjectPosition();
   bool ParseOutline();
   bool ParseOverflow();
   bool ParsePadding();
   bool ParseQuotes();
   bool ParseTextAlign(nsCSSValue& aValue,
-                      const KTableValue aTable[]);
+                      const KTableEntry aTable[]);
   bool ParseTextAlign(nsCSSValue& aValue);
   bool ParseTextAlignLast(nsCSSValue& aValue);
   bool ParseTextDecoration();
   bool ParseTextDecorationLine(nsCSSValue& aValue);
   bool ParseTextCombineUpright(nsCSSValue& aValue);
   bool ParseTextOverflow(nsCSSValue& aValue);
   bool ParseTouchAction(nsCSSValue& aValue);
 
@@ -1088,75 +1088,75 @@ protected:
   // up through and including the aStop char.
   bool ParseHSLColor(float& aHue, float& aSaturation, float& aLightness,
                      char aStop);
   // ParseColorOpacity will enforce that the color ends with a ')'
   // after the opacity
   bool ParseColorOpacity(uint8_t& aOpacity);
   bool ParseColorOpacity(float& aOpacity);
   bool ParseEnum(nsCSSValue& aValue,
-                 const KTableValue aKeywordTable[]);
+                 const KTableEntry aKeywordTable[]);
 
   // Variant parsing methods
   CSSParseResult ParseVariant(nsCSSValue& aValue,
                               int32_t aVariantMask,
-                              const KTableValue aKeywordTable[]);
+                              const KTableEntry aKeywordTable[]);
   CSSParseResult ParseVariantWithRestrictions(nsCSSValue& aValue,
                                               int32_t aVariantMask,
-                                              const KTableValue aKeywordTable[],
+                                              const KTableEntry aKeywordTable[],
                                               uint32_t aRestrictions);
   CSSParseResult ParseNonNegativeVariant(nsCSSValue& aValue,
                                          int32_t aVariantMask,
-                                         const KTableValue aKeywordTable[]);
+                                         const KTableEntry aKeywordTable[]);
   CSSParseResult ParseOneOrLargerVariant(nsCSSValue& aValue,
                                          int32_t aVariantMask,
-                                         const KTableValue aKeywordTable[]);
+                                         const KTableEntry aKeywordTable[]);
 
   // Variant parsing methods that are guaranteed to UngetToken any token
   // consumed on failure
   bool ParseSingleTokenVariant(nsCSSValue& aValue,
                                int32_t aVariantMask,
-                               const KTableValue aKeywordTable[])
+                               const KTableEntry aKeywordTable[])
   {
     MOZ_ASSERT(!(aVariantMask & VARIANT_MULTIPLE_TOKENS),
                "use ParseVariant for variants in VARIANT_MULTIPLE_TOKENS");
     CSSParseResult result = ParseVariant(aValue, aVariantMask, aKeywordTable);
     MOZ_ASSERT(result != CSSParseResult::Error);
     return result == CSSParseResult::Ok;
   }
   bool ParseSingleTokenVariantWithRestrictions(
       nsCSSValue& aValue,
       int32_t aVariantMask,
-      const KTableValue aKeywordTable[],
+      const KTableEntry aKeywordTable[],
       uint32_t aRestrictions)
   {
     MOZ_ASSERT(!(aVariantMask & VARIANT_MULTIPLE_TOKENS),
                "use ParseVariantWithRestrictions for variants in "
                "VARIANT_MULTIPLE_TOKENS");
     CSSParseResult result =
       ParseVariantWithRestrictions(aValue, aVariantMask, aKeywordTable,
                                    aRestrictions);
     MOZ_ASSERT(result != CSSParseResult::Error);
     return result == CSSParseResult::Ok;
   }
   bool ParseSingleTokenNonNegativeVariant(nsCSSValue& aValue,
                                           int32_t aVariantMask,
-                                          const KTableValue aKeywordTable[])
+                                          const KTableEntry aKeywordTable[])
   {
     MOZ_ASSERT(!(aVariantMask & VARIANT_MULTIPLE_TOKENS),
                "use ParseNonNegativeVariant for variants in "
                "VARIANT_MULTIPLE_TOKENS");
     CSSParseResult result =
       ParseNonNegativeVariant(aValue, aVariantMask, aKeywordTable);
     MOZ_ASSERT(result != CSSParseResult::Error);
     return result == CSSParseResult::Ok;
   }
   bool ParseSingleTokenOneOrLargerVariant(nsCSSValue& aValue,
                                           int32_t aVariantMask,
-                                          const KTableValue aKeywordTable[])
+                                          const KTableEntry aKeywordTable[])
   {
     MOZ_ASSERT(!(aVariantMask & VARIANT_MULTIPLE_TOKENS),
                "use ParseOneOrLargerVariant for variants in "
                "VARIANT_MULTIPLE_TOKENS");
     CSSParseResult result =
       ParseOneOrLargerVariant(aValue, aVariantMask, aKeywordTable);
     MOZ_ASSERT(result != CSSParseResult::Error);
     return result == CSSParseResult::Ok;
@@ -1178,22 +1178,22 @@ protected:
   // * "default"
   // * a keyword in |aExcludedKeywords|
   // * a keyword in |aPropertyKTable|
   //
   // |aExcludedKeywords| is an array of nsCSSKeyword
   // that ends with a eCSSKeyword_UNKNOWN marker.
   //
   // |aPropertyKTable| can be used if some of the keywords to exclude
-  // also appear in an existing nsCSSProps::KTableValue,
+  // also appear in an existing nsCSSProps::KTableEntry,
   // to avoid duplicating them.
   bool ParseCustomIdent(nsCSSValue& aValue,
                         const nsAutoString& aIdentValue,
                         const nsCSSKeyword aExcludedKeywords[] = nullptr,
-                        const nsCSSProps::KTableValue aPropertyKTable[] = nullptr);
+                        const nsCSSProps::KTableEntry aPropertyKTable[] = nullptr);
   bool ParseCounter(nsCSSValue& aValue);
   bool ParseAttr(nsCSSValue& aValue);
   bool ParseSymbols(nsCSSValue& aValue);
   bool SetValueToURL(nsCSSValue& aValue, const nsString& aURL);
   bool TranslateDimension(nsCSSValue& aValue, int32_t aVariantMask,
                             float aNumber, const nsString& aUnit);
   bool ParseImageOrientation(nsCSSValue& aAngle);
   bool ParseImageRect(nsCSSValue& aImage);
@@ -6779,17 +6779,17 @@ CSSParserImpl::ParseTreePseudoElement(ns
   *aPseudoElementArgs = fakeSelector.mClassList;
   fakeSelector.mClassList = nullptr;
   return true;
 }
 #endif
 
 nsCSSKeyword
 CSSParserImpl::LookupKeywordPrefixAware(nsAString& aKeywordStr,
-                                        const KTableValue aKeywordTable[])
+                                        const KTableEntry aKeywordTable[])
 {
   nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(aKeywordStr);
 
   if (aKeywordTable == nsCSSProps::kDisplayKTable) {
     if (keyword == eCSSKeyword__webkit_box &&
         (sWebkitPrefixedAliasesEnabled || ShouldUseUnprefixingService())) {
       // Treat "display: -webkit-box" as "display: flex". In simple scenarios,
       // they largely behave the same, as long as we alias the associated
@@ -7191,17 +7191,17 @@ static const nsCSSProperty kBorderBlockE
 static const nsCSSProperty kColumnRuleIDs[] = {
   eCSSProperty__moz_column_rule_width,
   eCSSProperty__moz_column_rule_style,
   eCSSProperty__moz_column_rule_color
 };
 
 bool
 CSSParserImpl::ParseEnum(nsCSSValue& aValue,
-                         const KTableValue aKeywordTable[])
+                         const KTableEntry aKeywordTable[])
 {
   nsSubstring* ident = NextIdent();
   if (nullptr == ident) {
     return false;
   }
   nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(*ident);
   if (eCSSKeyword_UNKNOWN < keyword) {
     int32_t value;
@@ -7336,17 +7336,17 @@ CSSParserImpl::TranslateDimension(nsCSSV
   VARIANT_TIMING_FUNCTION | \
   VARIANT_ALL | \
   VARIANT_CALC | \
   VARIANT_OPENTYPE_SVG_KEYWORD
 
 CSSParseResult
 CSSParserImpl::ParseVariantWithRestrictions(nsCSSValue& aValue,
                                             int32_t aVariantMask,
-                                            const KTableValue aKeywordTable[],
+                                            const KTableEntry aKeywordTable[],
                                             uint32_t aRestrictions)
 {
   switch (aRestrictions) {
     default:
       MOZ_ASSERT(false, "should not be reached");
     case 0:
       return ParseVariant(aValue, aVariantMask, aKeywordTable);
     case CSS_PROPERTY_VALUE_NONNEGATIVE:
@@ -7358,17 +7358,17 @@ CSSParserImpl::ParseVariantWithRestricti
 
 // Note that callers passing VARIANT_CALC in aVariantMask will get
 // full-range parsing inside the calc() expression, and the code that
 // computes the calc will be required to clamp the resulting value to an
 // appropriate range.
 CSSParseResult
 CSSParserImpl::ParseNonNegativeVariant(nsCSSValue& aValue,
                                        int32_t aVariantMask,
-                                       const KTableValue aKeywordTable[])
+                                       const KTableEntry aKeywordTable[])
 {
   // The variant mask must only contain non-numeric variants or the ones
   // that we specifically handle.
   MOZ_ASSERT((aVariantMask & ~(VARIANT_ALL_NONNUMERIC |
                                VARIANT_NUMBER |
                                VARIANT_LENGTH |
                                VARIANT_PERCENT |
                                VARIANT_INTEGER)) == 0,
@@ -7400,17 +7400,17 @@ CSSParserImpl::ParseNonNegativeVariant(n
 
 // Note that callers passing VARIANT_CALC in aVariantMask will get
 // full-range parsing inside the calc() expression, and the code that
 // computes the calc will be required to clamp the resulting value to an
 // appropriate range.
 CSSParseResult
 CSSParserImpl::ParseOneOrLargerVariant(nsCSSValue& aValue,
                                        int32_t aVariantMask,
-                                       const KTableValue aKeywordTable[])
+                                       const KTableEntry aKeywordTable[])
 {
   // The variant mask must only contain non-numeric variants or the ones
   // that we specifically handle.
   MOZ_ASSERT((aVariantMask & ~(VARIANT_ALL_NONNUMERIC |
                                VARIANT_NUMBER |
                                VARIANT_INTEGER)) == 0,
              "need to update code below to handle additional variants");
 
@@ -7430,17 +7430,17 @@ CSSParserImpl::ParseOneOrLargerVariant(n
   }
   return result;
 }
 
 // Assigns to aValue iff it returns CSSParseResult::Ok.
 CSSParseResult
 CSSParserImpl::ParseVariant(nsCSSValue& aValue,
                             int32_t aVariantMask,
-                            const KTableValue aKeywordTable[])
+                            const KTableEntry aKeywordTable[])
 {
   NS_ASSERTION(!(mHashlessColorQuirk && (aVariantMask & VARIANT_COLOR)) ||
                !(aVariantMask & VARIANT_NUMBER),
                "can't distinguish colors from numbers");
   NS_ASSERTION(!(mHashlessColorQuirk && (aVariantMask & VARIANT_COLOR)) ||
                !(mUnitlessLengthQuirk && (aVariantMask & VARIANT_LENGTH)),
                "can't distinguish colors from lengths");
   NS_ASSERTION(!(mUnitlessLengthQuirk && (aVariantMask & VARIANT_LENGTH)) ||
@@ -7736,17 +7736,17 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
   AssertNextTokenAt(lineBefore, colBefore);
   return CSSParseResult::NotFound;
 }
 
 bool
 CSSParserImpl::ParseCustomIdent(nsCSSValue& aValue,
                                 const nsAutoString& aIdentValue,
                                 const nsCSSKeyword aExcludedKeywords[],
-                                const nsCSSProps::KTableValue aPropertyKTable[])
+                                const nsCSSProps::KTableEntry aPropertyKTable[])
 {
   nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(aIdentValue);
   if (keyword == eCSSKeyword_UNKNOWN) {
     // Fast path for identifiers that are not known CSS keywords:
     aValue.SetStringValue(mToken.mIdent, eCSSUnit_Ident);
     return true;
   }
   if (keyword == eCSSKeyword_inherit ||
@@ -9388,17 +9388,17 @@ CSSParserImpl::ParseGridArea()
   AppendValue(eCSSProperty_grid_column_end, values[3]);
   return true;
 }
 
 // [ $aTable && <overflow-position>? ] ?
 // $aTable is for <content-position> or <self-position>
 bool
 CSSParserImpl::ParseAlignJustifyPosition(nsCSSValue& aResult,
-                                         const KTableValue aTable[])
+                                         const KTableEntry aTable[])
 {
   nsCSSValue pos, overflowPos;
   int32_t value = 0;
   if (ParseEnum(pos, aTable)) {
     value = pos.GetIntValue();
     if (ParseEnum(overflowPos, nsCSSProps::kAlignOverflowPosition)) {
       value |= overflowPos.GetIntValue();
     }
@@ -10731,17 +10731,17 @@ CSSParserImpl::ParseBoxProperty(nsCSSVal
   }
 
   if (variant & ~(VARIANT_AHKLP | VARIANT_COLOR | VARIANT_CALC)) {
     MOZ_ASSERT(false, "must only be called for properties that take certain "
                       "variants");
     return CSSParseResult::NotFound;
   }
 
-  const KTableValue* kwtable = nsCSSProps::kKeywordTableTable[aPropID];
+  const KTableEntry* kwtable = nsCSSProps::kKeywordTableTable[aPropID];
   uint32_t restrictions = nsCSSProps::ValueRestrictions(aPropID);
 
   return ParseVariantWithRestrictions(aValue, variant, kwtable, restrictions);
 }
 
 bool
 CSSParserImpl::ParseSingleValuePropertyByFunction(nsCSSValue& aValue,
                                                   nsCSSProperty aPropID)
@@ -10837,17 +10837,17 @@ CSSParserImpl::ParseSingleValueProperty(
   }
 
   uint32_t variant = nsCSSProps::ParserVariant(aPropID);
   if (variant == 0) {
     MOZ_ASSERT(false, "not a single value property");
     return CSSParseResult::NotFound;
   }
 
-  const KTableValue* kwtable = nsCSSProps::kKeywordTableTable[aPropID];
+  const KTableEntry* kwtable = nsCSSProps::kKeywordTableTable[aPropID];
   uint32_t restrictions = nsCSSProps::ValueRestrictions(aPropID);
   return ParseVariantWithRestrictions(aValue, variant, kwtable, restrictions);
 }
 
 // font-descriptor: descriptor ':' value ';'
 // caller has advanced mToken to point at the descriptor
 bool
 CSSParserImpl::ParseFontDescriptorValue(nsCSSFontDesc aDescID,
@@ -12466,25 +12466,25 @@ CSSParserImpl::ParseColumns()
 
 #define VARIANT_CONTENT (VARIANT_STRING | VARIANT_URL | VARIANT_COUNTER | VARIANT_ATTR | \
                          VARIANT_KEYWORD)
 bool
 CSSParserImpl::ParseContent()
 {
   // We need to divide the 'content' keywords into two classes for
   // ParseVariant's sake, so we can't just use nsCSSProps::kContentKTable.
-  static const KTableValue kContentListKWs[] = {
+  static const KTableEntry kContentListKWs[] = {
     { eCSSKeyword_open_quote, NS_STYLE_CONTENT_OPEN_QUOTE },
     { eCSSKeyword_close_quote, NS_STYLE_CONTENT_CLOSE_QUOTE },
     { eCSSKeyword_no_open_quote, NS_STYLE_CONTENT_NO_OPEN_QUOTE },
     { eCSSKeyword_no_close_quote, NS_STYLE_CONTENT_NO_CLOSE_QUOTE },
     { eCSSKeyword_UNKNOWN, -1 }
   };
 
-  static const KTableValue kContentSolitaryKWs[] = {
+  static const KTableEntry kContentSolitaryKWs[] = {
     { eCSSKeyword__moz_alt_content, NS_STYLE_CONTENT_ALT_CONTENT },
     { eCSSKeyword_UNKNOWN, -1 }
   };
 
   // Verify that these two lists add up to the size of
   // nsCSSProps::kContentKTable.
   MOZ_ASSERT(nsCSSProps::kContentKTable[
                ArrayLength(kContentListKWs) +
@@ -12959,17 +12959,17 @@ CSSParserImpl::MergeBitmaskValue(int32_t
   return true;
 }
 
 // aMasks - array of masks for mutually-exclusive property values,
 //          e.g. proportial-nums, tabular-nums
 
 bool
 CSSParserImpl::ParseBitmaskValues(nsCSSValue& aValue,
-                                  const KTableValue aKeywordTable[],
+                                  const KTableEntry aKeywordTable[],
                                   const int32_t aMasks[])
 {
   // Parse at least one keyword
   if (!ParseEnum(aValue, aKeywordTable)) {
     return false;
   }
 
   // look for more values
@@ -13937,17 +13937,17 @@ CSSParserImpl::ParseTextDecoration()
 
   for (int32_t index = 0; index < numProps; index++) {
     AppendValue(kTextDecorationIDs[index], values[index]);
   }
   return true;
 }
 
 bool
-CSSParserImpl::ParseTextAlign(nsCSSValue& aValue, const KTableValue aTable[])
+CSSParserImpl::ParseTextAlign(nsCSSValue& aValue, const KTableEntry aTable[])
 {
   if (ParseSingleTokenVariant(aValue, VARIANT_INHERIT, nullptr)) {
     // 'inherit', 'initial' and 'unset' must be alone
     return true;
   }
 
   nsCSSValue left;
   if (!ParseSingleTokenVariant(left, VARIANT_KEYWORD, aTable)) {
@@ -15616,17 +15616,17 @@ CSSParserImpl::ParseMarker()
 
 bool
 CSSParserImpl::ParsePaintOrder()
 {
   static_assert
     ((1 << NS_STYLE_PAINT_ORDER_BITWIDTH) > NS_STYLE_PAINT_ORDER_LAST_VALUE,
      "bitfield width insufficient for paint-order constants");
 
-  static const KTableValue kPaintOrderKTable[] = {
+  static const KTableEntry kPaintOrderKTable[] = {
     { eCSSKeyword_normal,  NS_STYLE_PAINT_ORDER_NORMAL },
     { eCSSKeyword_fill,    NS_STYLE_PAINT_ORDER_FILL },
     { eCSSKeyword_stroke,  NS_STYLE_PAINT_ORDER_STROKE },
     { eCSSKeyword_markers, NS_STYLE_PAINT_ORDER_MARKERS },
     { eCSSKeyword_UNKNOWN, -1 }
   };
 
   static_assert(MOZ_ARRAY_LENGTH(kPaintOrderKTable) ==
diff --git a/layout/style/nsCSSProps.cpp b/layout/style/nsCSSProps.cpp
--- a/layout/style/nsCSSProps.cpp
+++ b/layout/style/nsCSSProps.cpp
@@ -21,17 +21,17 @@
 
 #include "nsString.h"
 #include "nsStaticNameTable.h"
 
 #include "mozilla/Preferences.h"
 
 using namespace mozilla;
 
-typedef nsCSSProps::KTableValue KTableValue;
+typedef nsCSSProps::KTableEntry KTableEntry;
 
 // MSVC before 2015 doesn't consider string literal as a constant
 // expression, thus we are not able to do this check here.
 #if !defined(_MSC_VER) || _MSC_VER >= 1900
 // By wrapping internal-only properties in this macro, we are not
 // exposing them in the CSSOM. Since currently it is not necessary to
 // allow accessing them in that way, it is easier and cheaper to just
 // do this rather than exposing them conditionally.
@@ -696,44 +696,44 @@ nsCSSProps::GetStringValue(nsCSSCounterD
   } else {
     static nsDependentCString sNullStr("");
     return sNullStr;
   }
 }
 
 /***************************************************************************/
 
-const KTableValue nsCSSProps::kAnimationDirectionKTable[] = {
+const KTableEntry nsCSSProps::kAnimationDirectionKTable[] = {
   { eCSSKeyword_normal, NS_STYLE_ANIMATION_DIRECTION_NORMAL },
   { eCSSKeyword_reverse, NS_STYLE_ANIMATION_DIRECTION_REVERSE },
   { eCSSKeyword_alternate, NS_STYLE_ANIMATION_DIRECTION_ALTERNATE },
   { eCSSKeyword_alternate_reverse, NS_STYLE_ANIMATION_DIRECTION_ALTERNATE_REVERSE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kAnimationFillModeKTable[] = {
+const KTableEntry nsCSSProps::kAnimationFillModeKTable[] = {
   { eCSSKeyword_none, NS_STYLE_ANIMATION_FILL_MODE_NONE },
   { eCSSKeyword_forwards, NS_STYLE_ANIMATION_FILL_MODE_FORWARDS },
   { eCSSKeyword_backwards, NS_STYLE_ANIMATION_FILL_MODE_BACKWARDS },
   { eCSSKeyword_both, NS_STYLE_ANIMATION_FILL_MODE_BOTH },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kAnimationIterationCountKTable[] = {
+const KTableEntry nsCSSProps::kAnimationIterationCountKTable[] = {
   { eCSSKeyword_infinite, NS_STYLE_ANIMATION_ITERATION_COUNT_INFINITE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kAnimationPlayStateKTable[] = {
+const KTableEntry nsCSSProps::kAnimationPlayStateKTable[] = {
   { eCSSKeyword_running, NS_STYLE_ANIMATION_PLAY_STATE_RUNNING },
   { eCSSKeyword_paused, NS_STYLE_ANIMATION_PLAY_STATE_PAUSED },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kAppearanceKTable[] = {
+const KTableEntry nsCSSProps::kAppearanceKTable[] = {
   { eCSSKeyword_none,                   NS_THEME_NONE },
   { eCSSKeyword_button,                 NS_THEME_BUTTON },
   { eCSSKeyword_radio,                  NS_THEME_RADIO },
   { eCSSKeyword_checkbox,               NS_THEME_CHECKBOX },
   { eCSSKeyword_button_bevel,           NS_THEME_BUTTON_BEVEL },
   { eCSSKeyword_toolbox,                NS_THEME_TOOLBOX },
   { eCSSKeyword_toolbar,                NS_THEME_TOOLBAR },
   { eCSSKeyword_toolbarbutton,          NS_THEME_TOOLBAR_BUTTON },
@@ -845,79 +845,79 @@ const KTableValue nsCSSProps::kAppearanc
   { eCSSKeyword__moz_mac_vibrancy_light,        NS_THEME_MAC_VIBRANCY_LIGHT },
   { eCSSKeyword__moz_mac_vibrancy_dark,         NS_THEME_MAC_VIBRANCY_DARK },
   { eCSSKeyword__moz_mac_disclosure_button_open,   NS_THEME_MAC_DISCLOSURE_BUTTON_OPEN },
   { eCSSKeyword__moz_mac_disclosure_button_closed, NS_THEME_MAC_DISCLOSURE_BUTTON_CLOSED },
   { eCSSKeyword__moz_gtk_info_bar,              NS_THEME_GTK_INFO_BAR },
   { eCSSKeyword_UNKNOWN,                        -1 }
 };
 
-const KTableValue nsCSSProps::kBackfaceVisibilityKTable[] = {
+const KTableEntry nsCSSProps::kBackfaceVisibilityKTable[] = {
   { eCSSKeyword_visible, NS_STYLE_BACKFACE_VISIBILITY_VISIBLE },
   { eCSSKeyword_hidden, NS_STYLE_BACKFACE_VISIBILITY_HIDDEN },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kTransformStyleKTable[] = {
+const KTableEntry nsCSSProps::kTransformStyleKTable[] = {
   { eCSSKeyword_flat, NS_STYLE_TRANSFORM_STYLE_FLAT },
   { eCSSKeyword_preserve_3d, NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kBackgroundAttachmentKTable[] = {
+const KTableEntry nsCSSProps::kBackgroundAttachmentKTable[] = {
   { eCSSKeyword_fixed, NS_STYLE_BG_ATTACHMENT_FIXED },
   { eCSSKeyword_scroll, NS_STYLE_BG_ATTACHMENT_SCROLL },
   { eCSSKeyword_local, NS_STYLE_BG_ATTACHMENT_LOCAL },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
 static_assert(NS_STYLE_BG_CLIP_BORDER == NS_STYLE_BG_ORIGIN_BORDER &&
               NS_STYLE_BG_CLIP_PADDING == NS_STYLE_BG_ORIGIN_PADDING &&
               NS_STYLE_BG_CLIP_CONTENT == NS_STYLE_BG_ORIGIN_CONTENT,
               "bg-clip and bg-origin style constants must agree");
-const KTableValue nsCSSProps::kBackgroundOriginKTable[] = {
+const KTableEntry nsCSSProps::kBackgroundOriginKTable[] = {
   { eCSSKeyword_border_box, NS_STYLE_BG_ORIGIN_BORDER },
   { eCSSKeyword_padding_box, NS_STYLE_BG_ORIGIN_PADDING },
   { eCSSKeyword_content_box, NS_STYLE_BG_ORIGIN_CONTENT },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
 // Note: Don't change this table unless you update
 // parseBackgroundPosition!
 
-const KTableValue nsCSSProps::kBackgroundPositionKTable[] = {
+const KTableEntry nsCSSProps::kBackgroundPositionKTable[] = {
   { eCSSKeyword_center, NS_STYLE_BG_POSITION_CENTER },
   { eCSSKeyword_top, NS_STYLE_BG_POSITION_TOP },
   { eCSSKeyword_bottom, NS_STYLE_BG_POSITION_BOTTOM },
   { eCSSKeyword_left, NS_STYLE_BG_POSITION_LEFT },
   { eCSSKeyword_right, NS_STYLE_BG_POSITION_RIGHT },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kBackgroundRepeatKTable[] = {
+const KTableEntry nsCSSProps::kBackgroundRepeatKTable[] = {
   { eCSSKeyword_no_repeat,  NS_STYLE_BG_REPEAT_NO_REPEAT },
   { eCSSKeyword_repeat,     NS_STYLE_BG_REPEAT_REPEAT },
   { eCSSKeyword_repeat_x,   NS_STYLE_BG_REPEAT_REPEAT_X },
   { eCSSKeyword_repeat_y,   NS_STYLE_BG_REPEAT_REPEAT_Y },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kBackgroundRepeatPartKTable[] = {
+const KTableEntry nsCSSProps::kBackgroundRepeatPartKTable[] = {
   { eCSSKeyword_no_repeat,  NS_STYLE_BG_REPEAT_NO_REPEAT },
   { eCSSKeyword_repeat,     NS_STYLE_BG_REPEAT_REPEAT },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kBackgroundSizeKTable[] = {
+const KTableEntry nsCSSProps::kBackgroundSizeKTable[] = {
   { eCSSKeyword_contain, NS_STYLE_BG_SIZE_CONTAIN },
   { eCSSKeyword_cover,   NS_STYLE_BG_SIZE_COVER },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kBlendModeKTable[] = {
+const KTableEntry nsCSSProps::kBlendModeKTable[] = {
     { eCSSKeyword_normal,      NS_STYLE_BLEND_NORMAL },
     { eCSSKeyword_multiply,    NS_STYLE_BLEND_MULTIPLY },
     { eCSSKeyword_screen,      NS_STYLE_BLEND_SCREEN },
     { eCSSKeyword_overlay,     NS_STYLE_BLEND_OVERLAY },
     { eCSSKeyword_darken,      NS_STYLE_BLEND_DARKEN },
     { eCSSKeyword_lighten,     NS_STYLE_BLEND_LIGHTEN },
     { eCSSKeyword_color_dodge, NS_STYLE_BLEND_COLOR_DODGE },
     { eCSSKeyword_color_burn,  NS_STYLE_BLEND_COLOR_BURN },
@@ -927,100 +927,100 @@ const KTableValue nsCSSProps::kBlendMode
     { eCSSKeyword_exclusion,   NS_STYLE_BLEND_EXCLUSION },
     { eCSSKeyword_hue,         NS_STYLE_BLEND_HUE },
     { eCSSKeyword_saturation,  NS_STYLE_BLEND_SATURATION },
     { eCSSKeyword_color,       NS_STYLE_BLEND_COLOR },
     { eCSSKeyword_luminosity,  NS_STYLE_BLEND_LUMINOSITY },
     { eCSSKeyword_UNKNOWN,     -1 }
 };
 
-const KTableValue nsCSSProps::kBorderCollapseKTable[] = {
+const KTableEntry nsCSSProps::kBorderCollapseKTable[] = {
   { eCSSKeyword_collapse,  NS_STYLE_BORDER_COLLAPSE },
   { eCSSKeyword_separate,  NS_STYLE_BORDER_SEPARATE },
   { eCSSKeyword_UNKNOWN,   -1 }
 };
 
-const KTableValue nsCSSProps::kBorderColorKTable[] = {
+const KTableEntry nsCSSProps::kBorderColorKTable[] = {
   { eCSSKeyword__moz_use_text_color, NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kBorderImageRepeatKTable[] = {
+const KTableEntry nsCSSProps::kBorderImageRepeatKTable[] = {
   { eCSSKeyword_stretch, NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH },
   { eCSSKeyword_repeat, NS_STYLE_BORDER_IMAGE_REPEAT_REPEAT },
   { eCSSKeyword_round, NS_STYLE_BORDER_IMAGE_REPEAT_ROUND },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kBorderImageSliceKTable[] = {
+const KTableEntry nsCSSProps::kBorderImageSliceKTable[] = {
   { eCSSKeyword_fill, NS_STYLE_BORDER_IMAGE_SLICE_FILL },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kBorderStyleKTable[] = {
+const KTableEntry nsCSSProps::kBorderStyleKTable[] = {
   { eCSSKeyword_none,   NS_STYLE_BORDER_STYLE_NONE },
   { eCSSKeyword_hidden, NS_STYLE_BORDER_STYLE_HIDDEN },
   { eCSSKeyword_dotted, NS_STYLE_BORDER_STYLE_DOTTED },
   { eCSSKeyword_dashed, NS_STYLE_BORDER_STYLE_DASHED },
   { eCSSKeyword_solid,  NS_STYLE_BORDER_STYLE_SOLID },
   { eCSSKeyword_double, NS_STYLE_BORDER_STYLE_DOUBLE },
   { eCSSKeyword_groove, NS_STYLE_BORDER_STYLE_GROOVE },
   { eCSSKeyword_ridge,  NS_STYLE_BORDER_STYLE_RIDGE },
   { eCSSKeyword_inset,  NS_STYLE_BORDER_STYLE_INSET },
   { eCSSKeyword_outset, NS_STYLE_BORDER_STYLE_OUTSET },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kBorderWidthKTable[] = {
+const KTableEntry nsCSSProps::kBorderWidthKTable[] = {
   { eCSSKeyword_thin, NS_STYLE_BORDER_WIDTH_THIN },
   { eCSSKeyword_medium, NS_STYLE_BORDER_WIDTH_MEDIUM },
   { eCSSKeyword_thick, NS_STYLE_BORDER_WIDTH_THICK },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kBoxDecorationBreakKTable[] = {
+const KTableEntry nsCSSProps::kBoxDecorationBreakKTable[] = {
   { eCSSKeyword_slice, NS_STYLE_BOX_DECORATION_BREAK_SLICE },
   { eCSSKeyword_clone, NS_STYLE_BOX_DECORATION_BREAK_CLONE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kBoxShadowTypeKTable[] = {
+const KTableEntry nsCSSProps::kBoxShadowTypeKTable[] = {
   { eCSSKeyword_inset, NS_STYLE_BOX_SHADOW_INSET },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kBoxSizingKTable[] = {
+const KTableEntry nsCSSProps::kBoxSizingKTable[] = {
   { eCSSKeyword_content_box,  NS_STYLE_BOX_SIZING_CONTENT },
   { eCSSKeyword_border_box,   NS_STYLE_BOX_SIZING_BORDER },
   { eCSSKeyword_padding_box,  NS_STYLE_BOX_SIZING_PADDING },
   { eCSSKeyword_UNKNOWN,      -1 }
 };
 
-const KTableValue nsCSSProps::kCaptionSideKTable[] = {
+const KTableEntry nsCSSProps::kCaptionSideKTable[] = {
   { eCSSKeyword_top,                  NS_STYLE_CAPTION_SIDE_TOP },
   { eCSSKeyword_right,                NS_STYLE_CAPTION_SIDE_RIGHT },
   { eCSSKeyword_bottom,               NS_STYLE_CAPTION_SIDE_BOTTOM },
   { eCSSKeyword_left,                 NS_STYLE_CAPTION_SIDE_LEFT },
   { eCSSKeyword_top_outside,          NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE },
   { eCSSKeyword_bottom_outside,       NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE },
   { eCSSKeyword_UNKNOWN,              -1 }
 };
 
-KTableValue nsCSSProps::kClearKTable[] = {
+KTableEntry nsCSSProps::kClearKTable[] = {
   { eCSSKeyword_none,         NS_STYLE_CLEAR_NONE },
   { eCSSKeyword_left,         NS_STYLE_CLEAR_LEFT },
   { eCSSKeyword_right,        NS_STYLE_CLEAR_RIGHT },
   { eCSSKeyword_inline_start, NS_STYLE_CLEAR_INLINE_START },
   { eCSSKeyword_inline_end,   NS_STYLE_CLEAR_INLINE_END },
   { eCSSKeyword_both,         NS_STYLE_CLEAR_BOTH },
   { eCSSKeyword_UNKNOWN,      -1 }
 };
 
 // See also kContextPatternKTable for SVG paint-specific values
-const KTableValue nsCSSProps::kColorKTable[] = {
+const KTableEntry nsCSSProps::kColorKTable[] = {
   { eCSSKeyword_activeborder, LookAndFeel::eColorID_activeborder },
   { eCSSKeyword_activecaption, LookAndFeel::eColorID_activecaption },
   { eCSSKeyword_appworkspace, LookAndFeel::eColorID_appworkspace },
   { eCSSKeyword_background, LookAndFeel::eColorID_background },
   { eCSSKeyword_buttonface, LookAndFeel::eColorID_buttonface },
   { eCSSKeyword_buttonhighlight, LookAndFeel::eColorID_buttonhighlight },
   { eCSSKeyword_buttonshadow, LookAndFeel::eColorID_buttonshadow },
   { eCSSKeyword_buttontext, LookAndFeel::eColorID_buttontext },
@@ -1083,65 +1083,65 @@ const KTableValue nsCSSProps::kColorKTab
   { eCSSKeyword__moz_win_mediatext, LookAndFeel::eColorID__moz_win_mediatext },
   { eCSSKeyword__moz_win_communicationstext, LookAndFeel::eColorID__moz_win_communicationstext },
   { eCSSKeyword__moz_nativehyperlinktext, LookAndFeel::eColorID__moz_nativehyperlinktext },
   { eCSSKeyword__moz_comboboxtext, LookAndFeel::eColorID__moz_comboboxtext },
   { eCSSKeyword__moz_combobox, LookAndFeel::eColorID__moz_combobox },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kContentKTable[] = {
+const KTableEntry nsCSSProps::kContentKTable[] = {
   { eCSSKeyword_open_quote, NS_STYLE_CONTENT_OPEN_QUOTE },
   { eCSSKeyword_close_quote, NS_STYLE_CONTENT_CLOSE_QUOTE },
   { eCSSKeyword_no_open_quote, NS_STYLE_CONTENT_NO_OPEN_QUOTE },
   { eCSSKeyword_no_close_quote, NS_STYLE_CONTENT_NO_CLOSE_QUOTE },
   { eCSSKeyword__moz_alt_content, NS_STYLE_CONTENT_ALT_CONTENT },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kControlCharacterVisibilityKTable[] = {
+const KTableEntry nsCSSProps::kControlCharacterVisibilityKTable[] = {
   { eCSSKeyword_hidden, NS_STYLE_CONTROL_CHARACTER_VISIBILITY_HIDDEN },
   { eCSSKeyword_visible, NS_STYLE_CONTROL_CHARACTER_VISIBILITY_VISIBLE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kCounterRangeKTable[] = {
+const KTableEntry nsCSSProps::kCounterRangeKTable[] = {
   { eCSSKeyword_infinite, NS_STYLE_COUNTER_RANGE_INFINITE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kCounterSpeakAsKTable[] = {
+const KTableEntry nsCSSProps::kCounterSpeakAsKTable[] = {
   { eCSSKeyword_bullets, NS_STYLE_COUNTER_SPEAKAS_BULLETS },
   { eCSSKeyword_numbers, NS_STYLE_COUNTER_SPEAKAS_NUMBERS },
   { eCSSKeyword_words, NS_STYLE_COUNTER_SPEAKAS_WORDS },
   { eCSSKeyword_spell_out, NS_STYLE_COUNTER_SPEAKAS_SPELL_OUT },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kCounterSymbolsSystemKTable[] = {
+const KTableEntry nsCSSProps::kCounterSymbolsSystemKTable[] = {
   { eCSSKeyword_cyclic, NS_STYLE_COUNTER_SYSTEM_CYCLIC },
   { eCSSKeyword_numeric, NS_STYLE_COUNTER_SYSTEM_NUMERIC },
   { eCSSKeyword_alphabetic, NS_STYLE_COUNTER_SYSTEM_ALPHABETIC },
   { eCSSKeyword_symbolic, NS_STYLE_COUNTER_SYSTEM_SYMBOLIC },
   { eCSSKeyword_fixed, NS_STYLE_COUNTER_SYSTEM_FIXED },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kCounterSystemKTable[] = {
+const KTableEntry nsCSSProps::kCounterSystemKTable[] = {
   { eCSSKeyword_cyclic, NS_STYLE_COUNTER_SYSTEM_CYCLIC },
   { eCSSKeyword_numeric, NS_STYLE_COUNTER_SYSTEM_NUMERIC },
   { eCSSKeyword_alphabetic, NS_STYLE_COUNTER_SYSTEM_ALPHABETIC },
   { eCSSKeyword_symbolic, NS_STYLE_COUNTER_SYSTEM_SYMBOLIC },
   { eCSSKeyword_additive, NS_STYLE_COUNTER_SYSTEM_ADDITIVE },
   { eCSSKeyword_fixed, NS_STYLE_COUNTER_SYSTEM_FIXED },
   { eCSSKeyword_extends, NS_STYLE_COUNTER_SYSTEM_EXTENDS },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kCursorKTable[] = {
+const KTableEntry nsCSSProps::kCursorKTable[] = {
   // CSS 2.0
   { eCSSKeyword_auto, NS_STYLE_CURSOR_AUTO },
   { eCSSKeyword_crosshair, NS_STYLE_CURSOR_CROSSHAIR },
   { eCSSKeyword_default, NS_STYLE_CURSOR_DEFAULT },
   { eCSSKeyword_pointer, NS_STYLE_CURSOR_POINTER },
   { eCSSKeyword_move, NS_STYLE_CURSOR_MOVE },
   { eCSSKeyword_e_resize, NS_STYLE_CURSOR_E_RESIZE },
   { eCSSKeyword_ne_resize, NS_STYLE_CURSOR_NE_RESIZE },
@@ -1179,23 +1179,23 @@ const KTableValue nsCSSProps::kCursorKTa
   // -moz- prefixed vendor specific
   { eCSSKeyword__moz_grab, NS_STYLE_CURSOR_GRAB },
   { eCSSKeyword__moz_grabbing, NS_STYLE_CURSOR_GRABBING },
   { eCSSKeyword__moz_zoom_in, NS_STYLE_CURSOR_ZOOM_IN },
   { eCSSKeyword__moz_zoom_out, NS_STYLE_CURSOR_ZOOM_OUT },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kDirectionKTable[] = {
+const KTableEntry nsCSSProps::kDirectionKTable[] = {
   { eCSSKeyword_ltr,      NS_STYLE_DIRECTION_LTR },
   { eCSSKeyword_rtl,      NS_STYLE_DIRECTION_RTL },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-KTableValue nsCSSProps::kDisplayKTable[] = {
+KTableEntry nsCSSProps::kDisplayKTable[] = {
   { eCSSKeyword_none,                NS_STYLE_DISPLAY_NONE },
   { eCSSKeyword_inline,              NS_STYLE_DISPLAY_INLINE },
   { eCSSKeyword_block,               NS_STYLE_DISPLAY_BLOCK },
   { eCSSKeyword_inline_block,        NS_STYLE_DISPLAY_INLINE_BLOCK },
   { eCSSKeyword_list_item,           NS_STYLE_DISPLAY_LIST_ITEM },
   { eCSSKeyword_table,               NS_STYLE_DISPLAY_TABLE },
   { eCSSKeyword_inline_table,        NS_STYLE_DISPLAY_INLINE_TABLE },
   { eCSSKeyword_table_row_group,     NS_STYLE_DISPLAY_TABLE_ROW_GROUP },
@@ -1233,23 +1233,23 @@ KTableValue nsCSSProps::kDisplayKTable[]
   { eCSSKeyword_ruby_text,           NS_STYLE_DISPLAY_RUBY_TEXT },
   { eCSSKeyword_ruby_text_container, NS_STYLE_DISPLAY_RUBY_TEXT_CONTAINER },
   // The next entry is controlled by the layout.css.display-contents.enabled
   // pref.
   { eCSSKeyword_contents,            NS_STYLE_DISPLAY_CONTENTS },
   { eCSSKeyword_UNKNOWN,             -1 }
 };
 
-const KTableValue nsCSSProps::kEmptyCellsKTable[] = {
+const KTableEntry nsCSSProps::kEmptyCellsKTable[] = {
   { eCSSKeyword_show,                 NS_STYLE_TABLE_EMPTY_CELLS_SHOW },
   { eCSSKeyword_hide,                 NS_STYLE_TABLE_EMPTY_CELLS_HIDE },
   { eCSSKeyword_UNKNOWN,              -1 }
 };
 
-const KTableValue nsCSSProps::kAlignAllKeywords[] = {
+const KTableEntry nsCSSProps::kAlignAllKeywords[] = {
   { eCSSKeyword_auto,          NS_STYLE_ALIGN_AUTO },
   { eCSSKeyword_start,         NS_STYLE_ALIGN_START },
   { eCSSKeyword_end,           NS_STYLE_ALIGN_END },
   { eCSSKeyword_flex_start,    NS_STYLE_ALIGN_FLEX_START },
   { eCSSKeyword_flex_end,      NS_STYLE_ALIGN_FLEX_END },
   { eCSSKeyword_center,        NS_STYLE_ALIGN_CENTER },
   { eCSSKeyword_left,          NS_STYLE_ALIGN_LEFT },
   { eCSSKeyword_right,         NS_STYLE_ALIGN_RIGHT },
@@ -1262,119 +1262,119 @@ const KTableValue nsCSSProps::kAlignAllK
   { eCSSKeyword_space_around,  NS_STYLE_ALIGN_SPACE_AROUND },
   { eCSSKeyword_space_evenly,  NS_STYLE_ALIGN_SPACE_EVENLY },
   { eCSSKeyword_legacy,        NS_STYLE_ALIGN_LEGACY },
   { eCSSKeyword_safe,          NS_STYLE_ALIGN_SAFE },
   { eCSSKeyword_true,          NS_STYLE_ALIGN_TRUE },
   { eCSSKeyword_UNKNOWN,       -1 }
 };
 
-const KTableValue nsCSSProps::kAlignOverflowPosition[] = {
+const KTableEntry nsCSSProps::kAlignOverflowPosition[] = {
   { eCSSKeyword_true,          NS_STYLE_ALIGN_TRUE },
   { eCSSKeyword_safe,          NS_STYLE_ALIGN_SAFE },
   { eCSSKeyword_UNKNOWN,       -1 }
 };
 
-const KTableValue nsCSSProps::kAlignSelfPosition[] = {
+const KTableEntry nsCSSProps::kAlignSelfPosition[] = {
   { eCSSKeyword_start,         NS_STYLE_ALIGN_START },
   { eCSSKeyword_end,           NS_STYLE_ALIGN_END },
   { eCSSKeyword_flex_start,    NS_STYLE_ALIGN_FLEX_START },
   { eCSSKeyword_flex_end,      NS_STYLE_ALIGN_FLEX_END },
   { eCSSKeyword_center,        NS_STYLE_ALIGN_CENTER },
   { eCSSKeyword_left,          NS_STYLE_ALIGN_LEFT },
   { eCSSKeyword_right,         NS_STYLE_ALIGN_RIGHT },
   { eCSSKeyword_self_start,    NS_STYLE_ALIGN_SELF_START },
   { eCSSKeyword_self_end,      NS_STYLE_ALIGN_SELF_END },
   { eCSSKeyword_UNKNOWN,       -1 }
 };
 
-const KTableValue nsCSSProps::kAlignLegacy[] = {
+const KTableEntry nsCSSProps::kAlignLegacy[] = {
   { eCSSKeyword_legacy,        NS_STYLE_ALIGN_LEGACY },
   { eCSSKeyword_UNKNOWN,       -1 }
 };
 
-const KTableValue nsCSSProps::kAlignLegacyPosition[] = {
+const KTableEntry nsCSSProps::kAlignLegacyPosition[] = {
   { eCSSKeyword_center,        NS_STYLE_ALIGN_CENTER },
   { eCSSKeyword_left,          NS_STYLE_ALIGN_LEFT },
   { eCSSKeyword_right,         NS_STYLE_ALIGN_RIGHT },
   { eCSSKeyword_UNKNOWN,       -1 }
 };
 
-const KTableValue nsCSSProps::kAlignAutoStretchBaseline[] = {
+const KTableEntry nsCSSProps::kAlignAutoStretchBaseline[] = {
   { eCSSKeyword_auto,          NS_STYLE_ALIGN_AUTO },
   { eCSSKeyword_stretch,       NS_STYLE_ALIGN_STRETCH },
   { eCSSKeyword_baseline,      NS_STYLE_ALIGN_BASELINE },
   { eCSSKeyword_last_baseline, NS_STYLE_ALIGN_LAST_BASELINE },
   { eCSSKeyword_UNKNOWN,       -1 }
 };
 
-const KTableValue nsCSSProps::kAlignAutoBaseline[] = {
+const KTableEntry nsCSSProps::kAlignAutoBaseline[] = {
   { eCSSKeyword_auto,          NS_STYLE_ALIGN_AUTO },
   { eCSSKeyword_baseline,      NS_STYLE_ALIGN_BASELINE },
   { eCSSKeyword_last_baseline, NS_STYLE_ALIGN_LAST_BASELINE },
   { eCSSKeyword_UNKNOWN,       -1 }
 };
 
-const KTableValue nsCSSProps::kAlignContentDistribution[] = {
+const KTableEntry nsCSSProps::kAlignContentDistribution[] = {
   { eCSSKeyword_stretch,       NS_STYLE_ALIGN_STRETCH },
   { eCSSKeyword_space_between, NS_STYLE_ALIGN_SPACE_BETWEEN },
   { eCSSKeyword_space_around,  NS_STYLE_ALIGN_SPACE_AROUND },
   { eCSSKeyword_space_evenly,  NS_STYLE_ALIGN_SPACE_EVENLY },
   { eCSSKeyword_UNKNOWN,       -1 }
 };
 
-const KTableValue nsCSSProps::kAlignContentPosition[] = {
+const KTableEntry nsCSSProps::kAlignContentPosition[] = {
   { eCSSKeyword_start,         NS_STYLE_ALIGN_START },
   { eCSSKeyword_end,           NS_STYLE_ALIGN_END },
   { eCSSKeyword_flex_start,    NS_STYLE_ALIGN_FLEX_START },
   { eCSSKeyword_flex_end,      NS_STYLE_ALIGN_FLEX_END },
   { eCSSKeyword_center,        NS_STYLE_ALIGN_CENTER },
   { eCSSKeyword_left,          NS_STYLE_ALIGN_LEFT },
   { eCSSKeyword_right,         NS_STYLE_ALIGN_RIGHT },
   { eCSSKeyword_UNKNOWN,       -1 }
 };
 
-const KTableValue nsCSSProps::kFlexDirectionKTable[] = {
+const KTableEntry nsCSSProps::kFlexDirectionKTable[] = {
   { eCSSKeyword_row,            NS_STYLE_FLEX_DIRECTION_ROW },
   { eCSSKeyword_row_reverse,    NS_STYLE_FLEX_DIRECTION_ROW_REVERSE },
   { eCSSKeyword_column,         NS_STYLE_FLEX_DIRECTION_COLUMN },
   { eCSSKeyword_column_reverse, NS_STYLE_FLEX_DIRECTION_COLUMN_REVERSE },
   { eCSSKeyword_UNKNOWN,        -1 }
 };
 
-const KTableValue nsCSSProps::kFlexWrapKTable[] = {
+const KTableEntry nsCSSProps::kFlexWrapKTable[] = {
   { eCSSKeyword_nowrap,       NS_STYLE_FLEX_WRAP_NOWRAP },
   { eCSSKeyword_wrap,         NS_STYLE_FLEX_WRAP_WRAP },
   { eCSSKeyword_wrap_reverse, NS_STYLE_FLEX_WRAP_WRAP_REVERSE },
   { eCSSKeyword_UNKNOWN,      -1 }
 };
 
-const KTableValue nsCSSProps::kHyphensKTable[] = {
+const KTableEntry nsCSSProps::kHyphensKTable[] = {
   { eCSSKeyword_none, NS_STYLE_HYPHENS_NONE },
   { eCSSKeyword_manual, NS_STYLE_HYPHENS_MANUAL },
   { eCSSKeyword_auto, NS_STYLE_HYPHENS_AUTO },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-KTableValue nsCSSProps::kFloatKTable[] = {
+KTableEntry nsCSSProps::kFloatKTable[] = {
   { eCSSKeyword_none,         NS_STYLE_FLOAT_NONE },
   { eCSSKeyword_left,         NS_STYLE_FLOAT_LEFT },
   { eCSSKeyword_right,        NS_STYLE_FLOAT_RIGHT },
   { eCSSKeyword_inline_start, NS_STYLE_FLOAT_INLINE_START },
   { eCSSKeyword_inline_end,   NS_STYLE_FLOAT_INLINE_END },
   { eCSSKeyword_UNKNOWN,      -1 }
 };
 
-const KTableValue nsCSSProps::kFloatEdgeKTable[] = {
+const KTableEntry nsCSSProps::kFloatEdgeKTable[] = {
   { eCSSKeyword_content_box, NS_STYLE_FLOAT_EDGE_CONTENT },
   { eCSSKeyword_margin_box, NS_STYLE_FLOAT_EDGE_MARGIN },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFontKTable[] = {
+const KTableEntry nsCSSProps::kFontKTable[] = {
   // CSS2.
   { eCSSKeyword_caption, NS_STYLE_FONT_CAPTION },
   { eCSSKeyword_icon, NS_STYLE_FONT_ICON },
   { eCSSKeyword_menu, NS_STYLE_FONT_MENU },
   { eCSSKeyword_message_box, NS_STYLE_FONT_MESSAGE_BOX },
   { eCSSKeyword_small_caption, NS_STYLE_FONT_SMALL_CAPTION },
   { eCSSKeyword_status_bar, NS_STYLE_FONT_STATUS_BAR },
 
@@ -1387,196 +1387,196 @@ const KTableValue nsCSSProps::kFontKTabl
   { eCSSKeyword__moz_dialog, NS_STYLE_FONT_DIALOG },
   { eCSSKeyword__moz_button, NS_STYLE_FONT_BUTTON },
   { eCSSKeyword__moz_pull_down_menu, NS_STYLE_FONT_PULL_DOWN_MENU },
   { eCSSKeyword__moz_list, NS_STYLE_FONT_LIST },
   { eCSSKeyword__moz_field, NS_STYLE_FONT_FIELD },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFontKerningKTable[] = {
+const KTableEntry nsCSSProps::kFontKerningKTable[] = {
   { eCSSKeyword_auto, NS_FONT_KERNING_AUTO },
   { eCSSKeyword_none, NS_FONT_KERNING_NONE },
   { eCSSKeyword_normal, NS_FONT_KERNING_NORMAL },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFontSizeKTable[] = {
+const KTableEntry nsCSSProps::kFontSizeKTable[] = {
   { eCSSKeyword_xx_small, NS_STYLE_FONT_SIZE_XXSMALL },
   { eCSSKeyword_x_small, NS_STYLE_FONT_SIZE_XSMALL },
   { eCSSKeyword_small, NS_STYLE_FONT_SIZE_SMALL },
   { eCSSKeyword_medium, NS_STYLE_FONT_SIZE_MEDIUM },
   { eCSSKeyword_large, NS_STYLE_FONT_SIZE_LARGE },
   { eCSSKeyword_x_large, NS_STYLE_FONT_SIZE_XLARGE },
   { eCSSKeyword_xx_large, NS_STYLE_FONT_SIZE_XXLARGE },
   { eCSSKeyword_larger, NS_STYLE_FONT_SIZE_LARGER },
   { eCSSKeyword_smaller, NS_STYLE_FONT_SIZE_SMALLER },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFontSmoothingKTable[] = {
+const KTableEntry nsCSSProps::kFontSmoothingKTable[] = {
   { eCSSKeyword_auto, NS_FONT_SMOOTHING_AUTO },
   { eCSSKeyword_grayscale, NS_FONT_SMOOTHING_GRAYSCALE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFontStretchKTable[] = {
+const KTableEntry nsCSSProps::kFontStretchKTable[] = {
   { eCSSKeyword_ultra_condensed, NS_STYLE_FONT_STRETCH_ULTRA_CONDENSED },
   { eCSSKeyword_extra_condensed, NS_STYLE_FONT_STRETCH_EXTRA_CONDENSED },
   { eCSSKeyword_condensed, NS_STYLE_FONT_STRETCH_CONDENSED },
   { eCSSKeyword_semi_condensed, NS_STYLE_FONT_STRETCH_SEMI_CONDENSED },
   { eCSSKeyword_normal, NS_STYLE_FONT_STRETCH_NORMAL },
   { eCSSKeyword_semi_expanded, NS_STYLE_FONT_STRETCH_SEMI_EXPANDED },
   { eCSSKeyword_expanded, NS_STYLE_FONT_STRETCH_EXPANDED },
   { eCSSKeyword_extra_expanded, NS_STYLE_FONT_STRETCH_EXTRA_EXPANDED },
   { eCSSKeyword_ultra_expanded, NS_STYLE_FONT_STRETCH_ULTRA_EXPANDED },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFontStyleKTable[] = {
+const KTableEntry nsCSSProps::kFontStyleKTable[] = {
   { eCSSKeyword_normal, NS_STYLE_FONT_STYLE_NORMAL },
   { eCSSKeyword_italic, NS_STYLE_FONT_STYLE_ITALIC },
   { eCSSKeyword_oblique, NS_STYLE_FONT_STYLE_OBLIQUE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFontSynthesisKTable[] = {
+const KTableEntry nsCSSProps::kFontSynthesisKTable[] = {
   { eCSSKeyword_weight, NS_FONT_SYNTHESIS_WEIGHT },
   { eCSSKeyword_style, NS_FONT_SYNTHESIS_STYLE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFontVariantAlternatesKTable[] = {
+const KTableEntry nsCSSProps::kFontVariantAlternatesKTable[] = {
   { eCSSKeyword_historical_forms, NS_FONT_VARIANT_ALTERNATES_HISTORICAL },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFontVariantAlternatesFuncsKTable[] = {
+const KTableEntry nsCSSProps::kFontVariantAlternatesFuncsKTable[] = {
   { eCSSKeyword_stylistic, NS_FONT_VARIANT_ALTERNATES_STYLISTIC },
   { eCSSKeyword_styleset, NS_FONT_VARIANT_ALTERNATES_STYLESET },
   { eCSSKeyword_character_variant, NS_FONT_VARIANT_ALTERNATES_CHARACTER_VARIANT },
   { eCSSKeyword_swash, NS_FONT_VARIANT_ALTERNATES_SWASH },
   { eCSSKeyword_ornaments, NS_FONT_VARIANT_ALTERNATES_ORNAMENTS },
   { eCSSKeyword_annotation, NS_FONT_VARIANT_ALTERNATES_ANNOTATION },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFontVariantCapsKTable[] = {
+const KTableEntry nsCSSProps::kFontVariantCapsKTable[] = {
   { eCSSKeyword_small_caps, NS_FONT_VARIANT_CAPS_SMALLCAPS },
   { eCSSKeyword_all_small_caps, NS_FONT_VARIANT_CAPS_ALLSMALL },
   { eCSSKeyword_petite_caps, NS_FONT_VARIANT_CAPS_PETITECAPS },
   { eCSSKeyword_all_petite_caps, NS_FONT_VARIANT_CAPS_ALLPETITE },
   { eCSSKeyword_titling_caps, NS_FONT_VARIANT_CAPS_TITLING },
   { eCSSKeyword_unicase, NS_FONT_VARIANT_CAPS_UNICASE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFontVariantEastAsianKTable[] = {
+const KTableEntry nsCSSProps::kFontVariantEastAsianKTable[] = {
   { eCSSKeyword_jis78, NS_FONT_VARIANT_EAST_ASIAN_JIS78 },
   { eCSSKeyword_jis83, NS_FONT_VARIANT_EAST_ASIAN_JIS83 },
   { eCSSKeyword_jis90, NS_FONT_VARIANT_EAST_ASIAN_JIS90 },
   { eCSSKeyword_jis04, NS_FONT_VARIANT_EAST_ASIAN_JIS04 },
   { eCSSKeyword_simplified, NS_FONT_VARIANT_EAST_ASIAN_SIMPLIFIED },
   { eCSSKeyword_traditional, NS_FONT_VARIANT_EAST_ASIAN_TRADITIONAL },
   { eCSSKeyword_full_width, NS_FONT_VARIANT_EAST_ASIAN_FULL_WIDTH },
   { eCSSKeyword_proportional_width, NS_FONT_VARIANT_EAST_ASIAN_PROP_WIDTH },
   { eCSSKeyword_ruby, NS_FONT_VARIANT_EAST_ASIAN_RUBY },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFontVariantLigaturesKTable[] = {
+const KTableEntry nsCSSProps::kFontVariantLigaturesKTable[] = {
   { eCSSKeyword_common_ligatures, NS_FONT_VARIANT_LIGATURES_COMMON },
   { eCSSKeyword_no_common_ligatures, NS_FONT_VARIANT_LIGATURES_NO_COMMON },
   { eCSSKeyword_discretionary_ligatures, NS_FONT_VARIANT_LIGATURES_DISCRETIONARY },
   { eCSSKeyword_no_discretionary_ligatures, NS_FONT_VARIANT_LIGATURES_NO_DISCRETIONARY },
   { eCSSKeyword_historical_ligatures, NS_FONT_VARIANT_LIGATURES_HISTORICAL },
   { eCSSKeyword_no_historical_ligatures, NS_FONT_VARIANT_LIGATURES_NO_HISTORICAL },
   { eCSSKeyword_contextual, NS_FONT_VARIANT_LIGATURES_CONTEXTUAL },
   { eCSSKeyword_no_contextual, NS_FONT_VARIANT_LIGATURES_NO_CONTEXTUAL },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFontVariantNumericKTable[] = {
+const KTableEntry nsCSSProps::kFontVariantNumericKTable[] = {
   { eCSSKeyword_lining_nums, NS_FONT_VARIANT_NUMERIC_LINING },
   { eCSSKeyword_oldstyle_nums, NS_FONT_VARIANT_NUMERIC_OLDSTYLE },
   { eCSSKeyword_proportional_nums, NS_FONT_VARIANT_NUMERIC_PROPORTIONAL },
   { eCSSKeyword_tabular_nums, NS_FONT_VARIANT_NUMERIC_TABULAR },
   { eCSSKeyword_diagonal_fractions, NS_FONT_VARIANT_NUMERIC_DIAGONAL_FRACTIONS },
   { eCSSKeyword_stacked_fractions, NS_FONT_VARIANT_NUMERIC_STACKED_FRACTIONS },
   { eCSSKeyword_slashed_zero, NS_FONT_VARIANT_NUMERIC_SLASHZERO },
   { eCSSKeyword_ordinal, NS_FONT_VARIANT_NUMERIC_ORDINAL },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFontVariantPositionKTable[] = {
+const KTableEntry nsCSSProps::kFontVariantPositionKTable[] = {
   { eCSSKeyword_super, NS_FONT_VARIANT_POSITION_SUPER },
   { eCSSKeyword_sub, NS_FONT_VARIANT_POSITION_SUB },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFontWeightKTable[] = {
+const KTableEntry nsCSSProps::kFontWeightKTable[] = {
   { eCSSKeyword_normal, NS_STYLE_FONT_WEIGHT_NORMAL },
   { eCSSKeyword_bold, NS_STYLE_FONT_WEIGHT_BOLD },
   { eCSSKeyword_bolder, NS_STYLE_FONT_WEIGHT_BOLDER },
   { eCSSKeyword_lighter, NS_STYLE_FONT_WEIGHT_LIGHTER },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kGridAutoFlowKTable[] = {
+const KTableEntry nsCSSProps::kGridAutoFlowKTable[] = {
   { eCSSKeyword_row, NS_STYLE_GRID_AUTO_FLOW_ROW },
   { eCSSKeyword_column, NS_STYLE_GRID_AUTO_FLOW_COLUMN },
   { eCSSKeyword_dense, NS_STYLE_GRID_AUTO_FLOW_DENSE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kGridTrackBreadthKTable[] = {
+const KTableEntry nsCSSProps::kGridTrackBreadthKTable[] = {
   { eCSSKeyword_min_content, NS_STYLE_GRID_TRACK_BREADTH_MIN_CONTENT },
   { eCSSKeyword_max_content, NS_STYLE_GRID_TRACK_BREADTH_MAX_CONTENT },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kImageOrientationKTable[] = {
+const KTableEntry nsCSSProps::kImageOrientationKTable[] = {
   { eCSSKeyword_flip, NS_STYLE_IMAGE_ORIENTATION_FLIP },
   { eCSSKeyword_from_image, NS_STYLE_IMAGE_ORIENTATION_FROM_IMAGE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kImageOrientationFlipKTable[] = {
+const KTableEntry nsCSSProps::kImageOrientationFlipKTable[] = {
   { eCSSKeyword_flip, NS_STYLE_IMAGE_ORIENTATION_FLIP },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kIsolationKTable[] = {
+const KTableEntry nsCSSProps::kIsolationKTable[] = {
   { eCSSKeyword_auto, NS_STYLE_ISOLATION_AUTO },
   { eCSSKeyword_isolate, NS_STYLE_ISOLATION_ISOLATE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kIMEModeKTable[] = {
+const KTableEntry nsCSSProps::kIMEModeKTable[] = {
   { eCSSKeyword_normal, NS_STYLE_IME_MODE_NORMAL },
   { eCSSKeyword_auto, NS_STYLE_IME_MODE_AUTO },
   { eCSSKeyword_active, NS_STYLE_IME_MODE_ACTIVE },
   { eCSSKeyword_disabled, NS_STYLE_IME_MODE_DISABLED },
   { eCSSKeyword_inactive, NS_STYLE_IME_MODE_INACTIVE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kLineHeightKTable[] = {
+const KTableEntry nsCSSProps::kLineHeightKTable[] = {
   // -moz- prefixed, intended for internal use for single-line controls
   { eCSSKeyword__moz_block_height, NS_STYLE_LINE_HEIGHT_BLOCK_HEIGHT },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kListStylePositionKTable[] = {
+const KTableEntry nsCSSProps::kListStylePositionKTable[] = {
   { eCSSKeyword_inside, NS_STYLE_LIST_STYLE_POSITION_INSIDE },
   { eCSSKeyword_outside, NS_STYLE_LIST_STYLE_POSITION_OUTSIDE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kListStyleKTable[] = {
+const KTableEntry nsCSSProps::kListStyleKTable[] = {
   // none and decimal are not redefinable, so they should not be moved.
   { eCSSKeyword_none, NS_STYLE_LIST_STYLE_NONE },
   { eCSSKeyword_decimal, NS_STYLE_LIST_STYLE_DECIMAL },
   // the following graphic styles are processed in a different way.
   { eCSSKeyword_disc, NS_STYLE_LIST_STYLE_DISC },
   { eCSSKeyword_circle, NS_STYLE_LIST_STYLE_CIRCLE },
   { eCSSKeyword_square, NS_STYLE_LIST_STYLE_SQUARE },
   { eCSSKeyword_disclosure_closed, NS_STYLE_LIST_STYLE_DISCLOSURE_CLOSED },
@@ -1591,17 +1591,17 @@ const KTableValue nsCSSProps::kListStyle
   { eCSSKeyword_simp_chinese_informal, NS_STYLE_LIST_STYLE_SIMP_CHINESE_INFORMAL },
   { eCSSKeyword_simp_chinese_formal, NS_STYLE_LIST_STYLE_SIMP_CHINESE_FORMAL },
   { eCSSKeyword_trad_chinese_informal, NS_STYLE_LIST_STYLE_TRAD_CHINESE_INFORMAL },
   { eCSSKeyword_trad_chinese_formal, NS_STYLE_LIST_STYLE_TRAD_CHINESE_FORMAL },
   { eCSSKeyword_ethiopic_numeric, NS_STYLE_LIST_STYLE_ETHIOPIC_NUMERIC },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kMathVariantKTable[] = {
+const KTableEntry nsCSSProps::kMathVariantKTable[] = {
   { eCSSKeyword_none, NS_MATHML_MATHVARIANT_NONE },
   { eCSSKeyword_normal, NS_MATHML_MATHVARIANT_NORMAL },
   { eCSSKeyword_bold, NS_MATHML_MATHVARIANT_BOLD },
   { eCSSKeyword_italic, NS_MATHML_MATHVARIANT_ITALIC },
   { eCSSKeyword_bold_italic, NS_MATHML_MATHVARIANT_BOLD_ITALIC },
   { eCSSKeyword_script, NS_MATHML_MATHVARIANT_SCRIPT },
   { eCSSKeyword_bold_script, NS_MATHML_MATHVARIANT_BOLD_SCRIPT },
   { eCSSKeyword_fraktur, NS_MATHML_MATHVARIANT_FRAKTUR },
@@ -1614,734 +1614,734 @@ const KTableValue nsCSSProps::kMathVaria
   { eCSSKeyword_monospace, NS_MATHML_MATHVARIANT_MONOSPACE },
   { eCSSKeyword_initial, NS_MATHML_MATHVARIANT_INITIAL },
   { eCSSKeyword_tailed, NS_MATHML_MATHVARIANT_TAILED },
   { eCSSKeyword_looped, NS_MATHML_MATHVARIANT_LOOPED },
   { eCSSKeyword_stretched, NS_MATHML_MATHVARIANT_STRETCHED },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kMathDisplayKTable[] = {
+const KTableEntry nsCSSProps::kMathDisplayKTable[] = {
   { eCSSKeyword_inline, NS_MATHML_DISPLAYSTYLE_INLINE },
   { eCSSKeyword_block, NS_MATHML_DISPLAYSTYLE_BLOCK },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kContainKTable[] = {
+const KTableEntry nsCSSProps::kContainKTable[] = {
   { eCSSKeyword_none,    NS_STYLE_CONTAIN_NONE },
   { eCSSKeyword_strict,  NS_STYLE_CONTAIN_STRICT },
   { eCSSKeyword_layout,  NS_STYLE_CONTAIN_LAYOUT },
   { eCSSKeyword_style,   NS_STYLE_CONTAIN_STYLE },
   { eCSSKeyword_paint,   NS_STYLE_CONTAIN_PAINT },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kContextOpacityKTable[] = {
+const KTableEntry nsCSSProps::kContextOpacityKTable[] = {
   { eCSSKeyword_context_fill_opacity, NS_STYLE_CONTEXT_FILL_OPACITY },
   { eCSSKeyword_context_stroke_opacity, NS_STYLE_CONTEXT_STROKE_OPACITY },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kContextPatternKTable[] = {
+const KTableEntry nsCSSProps::kContextPatternKTable[] = {
   { eCSSKeyword_context_fill, NS_COLOR_CONTEXT_FILL },
   { eCSSKeyword_context_stroke, NS_COLOR_CONTEXT_STROKE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kObjectFitKTable[] = {
+const KTableEntry nsCSSProps::kObjectFitKTable[] = {
   { eCSSKeyword_fill,       NS_STYLE_OBJECT_FIT_FILL },
   { eCSSKeyword_contain,    NS_STYLE_OBJECT_FIT_CONTAIN },
   { eCSSKeyword_cover,      NS_STYLE_OBJECT_FIT_COVER },
   { eCSSKeyword_none,       NS_STYLE_OBJECT_FIT_NONE },
   { eCSSKeyword_scale_down, NS_STYLE_OBJECT_FIT_SCALE_DOWN },
   { eCSSKeyword_UNKNOWN,    -1 }
 };
 
-const KTableValue nsCSSProps::kOrientKTable[] = {
+const KTableEntry nsCSSProps::kOrientKTable[] = {
   { eCSSKeyword_inline,     NS_STYLE_ORIENT_INLINE },
   { eCSSKeyword_block,      NS_STYLE_ORIENT_BLOCK },
   { eCSSKeyword_horizontal, NS_STYLE_ORIENT_HORIZONTAL },
   { eCSSKeyword_vertical,   NS_STYLE_ORIENT_VERTICAL },
   { eCSSKeyword_UNKNOWN,    -1 }
 };
 
 // Same as kBorderStyleKTable except 'hidden'.
-const KTableValue nsCSSProps::kOutlineStyleKTable[] = {
+const KTableEntry nsCSSProps::kOutlineStyleKTable[] = {
   { eCSSKeyword_none,   NS_STYLE_BORDER_STYLE_NONE },
   { eCSSKeyword_auto,   NS_STYLE_BORDER_STYLE_AUTO },
   { eCSSKeyword_dotted, NS_STYLE_BORDER_STYLE_DOTTED },
   { eCSSKeyword_dashed, NS_STYLE_BORDER_STYLE_DASHED },
   { eCSSKeyword_solid,  NS_STYLE_BORDER_STYLE_SOLID },
   { eCSSKeyword_double, NS_STYLE_BORDER_STYLE_DOUBLE },
   { eCSSKeyword_groove, NS_STYLE_BORDER_STYLE_GROOVE },
   { eCSSKeyword_ridge,  NS_STYLE_BORDER_STYLE_RIDGE },
   { eCSSKeyword_inset,  NS_STYLE_BORDER_STYLE_INSET },
   { eCSSKeyword_outset, NS_STYLE_BORDER_STYLE_OUTSET },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kOutlineColorKTable[] = {
+const KTableEntry nsCSSProps::kOutlineColorKTable[] = {
   { eCSSKeyword__moz_use_text_color, NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kOverflowKTable[] = {
+const KTableEntry nsCSSProps::kOverflowKTable[] = {
   { eCSSKeyword_auto, NS_STYLE_OVERFLOW_AUTO },
   { eCSSKeyword_visible, NS_STYLE_OVERFLOW_VISIBLE },
   { eCSSKeyword_hidden, NS_STYLE_OVERFLOW_HIDDEN },
   { eCSSKeyword_scroll, NS_STYLE_OVERFLOW_SCROLL },
   // Deprecated:
   { eCSSKeyword__moz_scrollbars_none, NS_STYLE_OVERFLOW_HIDDEN },
   { eCSSKeyword__moz_scrollbars_horizontal, NS_STYLE_OVERFLOW_SCROLLBARS_HORIZONTAL },
   { eCSSKeyword__moz_scrollbars_vertical, NS_STYLE_OVERFLOW_SCROLLBARS_VERTICAL },
   { eCSSKeyword__moz_hidden_unscrollable, NS_STYLE_OVERFLOW_CLIP },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kOverflowClipBoxKTable[] = {
+const KTableEntry nsCSSProps::kOverflowClipBoxKTable[] = {
   { eCSSKeyword_padding_box, NS_STYLE_OVERFLOW_CLIP_BOX_PADDING_BOX },
   { eCSSKeyword_content_box, NS_STYLE_OVERFLOW_CLIP_BOX_CONTENT_BOX },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kOverflowSubKTable[] = {
+const KTableEntry nsCSSProps::kOverflowSubKTable[] = {
   { eCSSKeyword_auto, NS_STYLE_OVERFLOW_AUTO },
   { eCSSKeyword_visible, NS_STYLE_OVERFLOW_VISIBLE },
   { eCSSKeyword_hidden, NS_STYLE_OVERFLOW_HIDDEN },
   { eCSSKeyword_scroll, NS_STYLE_OVERFLOW_SCROLL },
   // Deprecated:
   { eCSSKeyword__moz_hidden_unscrollable, NS_STYLE_OVERFLOW_CLIP },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kPageBreakKTable[] = {
+const KTableEntry nsCSSProps::kPageBreakKTable[] = {
   { eCSSKeyword_auto, NS_STYLE_PAGE_BREAK_AUTO },
   { eCSSKeyword_always, NS_STYLE_PAGE_BREAK_ALWAYS },
   { eCSSKeyword_avoid, NS_STYLE_PAGE_BREAK_AVOID },
   { eCSSKeyword_left, NS_STYLE_PAGE_BREAK_LEFT },
   { eCSSKeyword_right, NS_STYLE_PAGE_BREAK_RIGHT },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kPageBreakInsideKTable[] = {
+const KTableEntry nsCSSProps::kPageBreakInsideKTable[] = {
   { eCSSKeyword_auto, NS_STYLE_PAGE_BREAK_AUTO },
   { eCSSKeyword_avoid, NS_STYLE_PAGE_BREAK_AVOID },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kPageMarksKTable[] = {
+const KTableEntry nsCSSProps::kPageMarksKTable[] = {
   { eCSSKeyword_none, NS_STYLE_PAGE_MARKS_NONE },
   { eCSSKeyword_crop, NS_STYLE_PAGE_MARKS_CROP },
   { eCSSKeyword_cross, NS_STYLE_PAGE_MARKS_REGISTER },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kPageSizeKTable[] = {
+const KTableEntry nsCSSProps::kPageSizeKTable[] = {
   { eCSSKeyword_landscape, NS_STYLE_PAGE_SIZE_LANDSCAPE },
   { eCSSKeyword_portrait, NS_STYLE_PAGE_SIZE_PORTRAIT },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kPointerEventsKTable[] = {
+const KTableEntry nsCSSProps::kPointerEventsKTable[] = {
   { eCSSKeyword_none, NS_STYLE_POINTER_EVENTS_NONE },
   { eCSSKeyword_visiblepainted, NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED },
   { eCSSKeyword_visiblefill, NS_STYLE_POINTER_EVENTS_VISIBLEFILL },
   { eCSSKeyword_visiblestroke, NS_STYLE_POINTER_EVENTS_VISIBLESTROKE },
   { eCSSKeyword_visible, NS_STYLE_POINTER_EVENTS_VISIBLE },
   { eCSSKeyword_painted, NS_STYLE_POINTER_EVENTS_PAINTED },
   { eCSSKeyword_fill, NS_STYLE_POINTER_EVENTS_FILL },
   { eCSSKeyword_stroke, NS_STYLE_POINTER_EVENTS_STROKE },
   { eCSSKeyword_all, NS_STYLE_POINTER_EVENTS_ALL },
   { eCSSKeyword_auto, NS_STYLE_POINTER_EVENTS_AUTO },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-KTableValue nsCSSProps::kPositionKTable[] = {
+KTableEntry nsCSSProps::kPositionKTable[] = {
   { eCSSKeyword_static, NS_STYLE_POSITION_STATIC },
   { eCSSKeyword_relative, NS_STYLE_POSITION_RELATIVE },
   { eCSSKeyword_absolute, NS_STYLE_POSITION_ABSOLUTE },
   { eCSSKeyword_fixed, NS_STYLE_POSITION_FIXED },
   // The next entry is controlled by the layout.css.sticky.enabled pref.
   { eCSSKeyword_sticky, NS_STYLE_POSITION_STICKY },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kRadialGradientShapeKTable[] = {
+const KTableEntry nsCSSProps::kRadialGradientShapeKTable[] = {
   { eCSSKeyword_circle,  NS_STYLE_GRADIENT_SHAPE_CIRCULAR },
   { eCSSKeyword_ellipse, NS_STYLE_GRADIENT_SHAPE_ELLIPTICAL },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kRadialGradientSizeKTable[] = {
+const KTableEntry nsCSSProps::kRadialGradientSizeKTable[] = {
   { eCSSKeyword_closest_side,    NS_STYLE_GRADIENT_SIZE_CLOSEST_SIDE },
   { eCSSKeyword_closest_corner,  NS_STYLE_GRADIENT_SIZE_CLOSEST_CORNER },
   { eCSSKeyword_farthest_side,   NS_STYLE_GRADIENT_SIZE_FARTHEST_SIDE },
   { eCSSKeyword_farthest_corner, NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER },
   { eCSSKeyword_UNKNOWN,         -1 }
 };
 
-const KTableValue nsCSSProps::kRadialGradientLegacySizeKTable[] = {
+const KTableEntry nsCSSProps::kRadialGradientLegacySizeKTable[] = {
   { eCSSKeyword_closest_side,    NS_STYLE_GRADIENT_SIZE_CLOSEST_SIDE },
   { eCSSKeyword_closest_corner,  NS_STYLE_GRADIENT_SIZE_CLOSEST_CORNER },
   { eCSSKeyword_farthest_side,   NS_STYLE_GRADIENT_SIZE_FARTHEST_SIDE },
   { eCSSKeyword_farthest_corner, NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER },
   // synonyms
   { eCSSKeyword_contain,         NS_STYLE_GRADIENT_SIZE_CLOSEST_SIDE },
   { eCSSKeyword_cover,           NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER },
   { eCSSKeyword_UNKNOWN,         -1 }
 };
 
-const KTableValue nsCSSProps::kResizeKTable[] = {
+const KTableEntry nsCSSProps::kResizeKTable[] = {
   { eCSSKeyword_none,       NS_STYLE_RESIZE_NONE },
   { eCSSKeyword_both,       NS_STYLE_RESIZE_BOTH },
   { eCSSKeyword_horizontal, NS_STYLE_RESIZE_HORIZONTAL },
   { eCSSKeyword_vertical,   NS_STYLE_RESIZE_VERTICAL },
   { eCSSKeyword_UNKNOWN,    -1 }
 };
 
-const KTableValue nsCSSProps::kRubyAlignKTable[] = {
+const KTableEntry nsCSSProps::kRubyAlignKTable[] = {
   { eCSSKeyword_start, NS_STYLE_RUBY_ALIGN_START },
   { eCSSKeyword_center, NS_STYLE_RUBY_ALIGN_CENTER },
   { eCSSKeyword_space_between, NS_STYLE_RUBY_ALIGN_SPACE_BETWEEN },
   { eCSSKeyword_space_around, NS_STYLE_RUBY_ALIGN_SPACE_AROUND },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kRubyPositionKTable[] = {
+const KTableEntry nsCSSProps::kRubyPositionKTable[] = {
   { eCSSKeyword_over, NS_STYLE_RUBY_POSITION_OVER },
   { eCSSKeyword_under, NS_STYLE_RUBY_POSITION_UNDER },
   // bug 1055672 for 'inter-character' support
   // { eCSSKeyword_inter_character, NS_STYLE_RUBY_POSITION_INTER_CHARACTER },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kScrollBehaviorKTable[] = {
+const KTableEntry nsCSSProps::kScrollBehaviorKTable[] = {
   { eCSSKeyword_auto,       NS_STYLE_SCROLL_BEHAVIOR_AUTO },
   { eCSSKeyword_smooth,     NS_STYLE_SCROLL_BEHAVIOR_SMOOTH },
   { eCSSKeyword_UNKNOWN,    -1 }
 };
 
-const KTableValue nsCSSProps::kScrollSnapTypeKTable[] = {
+const KTableEntry nsCSSProps::kScrollSnapTypeKTable[] = {
   { eCSSKeyword_none,      NS_STYLE_SCROLL_SNAP_TYPE_NONE },
   { eCSSKeyword_mandatory, NS_STYLE_SCROLL_SNAP_TYPE_MANDATORY },
   { eCSSKeyword_proximity, NS_STYLE_SCROLL_SNAP_TYPE_PROXIMITY },
   { eCSSKeyword_UNKNOWN,   -1 }
 };
 
-const KTableValue nsCSSProps::kStackSizingKTable[] = {
+const KTableEntry nsCSSProps::kStackSizingKTable[] = {
   { eCSSKeyword_ignore, NS_STYLE_STACK_SIZING_IGNORE },
   { eCSSKeyword_stretch_to_fit, NS_STYLE_STACK_SIZING_STRETCH_TO_FIT },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kTableLayoutKTable[] = {
+const KTableEntry nsCSSProps::kTableLayoutKTable[] = {
   { eCSSKeyword_auto, NS_STYLE_TABLE_LAYOUT_AUTO },
   { eCSSKeyword_fixed, NS_STYLE_TABLE_LAYOUT_FIXED },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-KTableValue nsCSSProps::kTextAlignKTable[] = {
+KTableEntry nsCSSProps::kTextAlignKTable[] = {
   { eCSSKeyword_left, NS_STYLE_TEXT_ALIGN_LEFT },
   { eCSSKeyword_right, NS_STYLE_TEXT_ALIGN_RIGHT },
   { eCSSKeyword_center, NS_STYLE_TEXT_ALIGN_CENTER },
   { eCSSKeyword_justify, NS_STYLE_TEXT_ALIGN_JUSTIFY },
   { eCSSKeyword__moz_center, NS_STYLE_TEXT_ALIGN_MOZ_CENTER },
   { eCSSKeyword__moz_right, NS_STYLE_TEXT_ALIGN_MOZ_RIGHT },
   { eCSSKeyword__moz_left, NS_STYLE_TEXT_ALIGN_MOZ_LEFT },
   { eCSSKeyword_start, NS_STYLE_TEXT_ALIGN_DEFAULT },
   { eCSSKeyword_end, NS_STYLE_TEXT_ALIGN_END },
   { eCSSKeyword_true, NS_STYLE_TEXT_ALIGN_TRUE },
   { eCSSKeyword_match_parent, NS_STYLE_TEXT_ALIGN_MATCH_PARENT },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-KTableValue nsCSSProps::kTextAlignLastKTable[] = {
+KTableEntry nsCSSProps::kTextAlignLastKTable[] = {
   { eCSSKeyword_auto, NS_STYLE_TEXT_ALIGN_AUTO },
   { eCSSKeyword_left, NS_STYLE_TEXT_ALIGN_LEFT },
   { eCSSKeyword_right, NS_STYLE_TEXT_ALIGN_RIGHT },
   { eCSSKeyword_center, NS_STYLE_TEXT_ALIGN_CENTER },
   { eCSSKeyword_justify, NS_STYLE_TEXT_ALIGN_JUSTIFY },
   { eCSSKeyword_start, NS_STYLE_TEXT_ALIGN_DEFAULT },
   { eCSSKeyword_end, NS_STYLE_TEXT_ALIGN_END },
   { eCSSKeyword_true, NS_STYLE_TEXT_ALIGN_TRUE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kTextCombineUprightKTable[] = {
+const KTableEntry nsCSSProps::kTextCombineUprightKTable[] = {
   { eCSSKeyword_none, NS_STYLE_TEXT_COMBINE_UPRIGHT_NONE },
   { eCSSKeyword_all, NS_STYLE_TEXT_COMBINE_UPRIGHT_ALL },
   { eCSSKeyword_digits, NS_STYLE_TEXT_COMBINE_UPRIGHT_DIGITS_2 }, // w/o number ==> 2
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kTextDecorationLineKTable[] = {
+const KTableEntry nsCSSProps::kTextDecorationLineKTable[] = {
   { eCSSKeyword_none, NS_STYLE_TEXT_DECORATION_LINE_NONE },
   { eCSSKeyword_underline, NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE },
   { eCSSKeyword_overline, NS_STYLE_TEXT_DECORATION_LINE_OVERLINE },
   { eCSSKeyword_line_through, NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH },
   { eCSSKeyword_blink, NS_STYLE_TEXT_DECORATION_LINE_BLINK },
   { eCSSKeyword__moz_anchor_decoration, NS_STYLE_TEXT_DECORATION_LINE_PREF_ANCHORS },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kTextDecorationStyleKTable[] = {
+const KTableEntry nsCSSProps::kTextDecorationStyleKTable[] = {
   { eCSSKeyword__moz_none, NS_STYLE_TEXT_DECORATION_STYLE_NONE },
   { eCSSKeyword_solid, NS_STYLE_TEXT_DECORATION_STYLE_SOLID },
   { eCSSKeyword_double, NS_STYLE_TEXT_DECORATION_STYLE_DOUBLE },
   { eCSSKeyword_dotted, NS_STYLE_TEXT_DECORATION_STYLE_DOTTED },
   { eCSSKeyword_dashed, NS_STYLE_TEXT_DECORATION_STYLE_DASHED },
   { eCSSKeyword_wavy, NS_STYLE_TEXT_DECORATION_STYLE_WAVY },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kTextOrientationKTable[] = {
+const KTableEntry nsCSSProps::kTextOrientationKTable[] = {
   { eCSSKeyword_mixed, NS_STYLE_TEXT_ORIENTATION_MIXED },
   { eCSSKeyword_upright, NS_STYLE_TEXT_ORIENTATION_UPRIGHT },
   { eCSSKeyword_sideways, NS_STYLE_TEXT_ORIENTATION_SIDEWAYS },
   { eCSSKeyword_sideways_right, NS_STYLE_TEXT_ORIENTATION_SIDEWAYS },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kTextOverflowKTable[] = {
+const KTableEntry nsCSSProps::kTextOverflowKTable[] = {
   { eCSSKeyword_clip, NS_STYLE_TEXT_OVERFLOW_CLIP },
   { eCSSKeyword_ellipsis, NS_STYLE_TEXT_OVERFLOW_ELLIPSIS },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kTextTransformKTable[] = {
+const KTableEntry nsCSSProps::kTextTransformKTable[] = {
   { eCSSKeyword_none, NS_STYLE_TEXT_TRANSFORM_NONE },
   { eCSSKeyword_capitalize, NS_STYLE_TEXT_TRANSFORM_CAPITALIZE },
   { eCSSKeyword_lowercase, NS_STYLE_TEXT_TRANSFORM_LOWERCASE },
   { eCSSKeyword_uppercase, NS_STYLE_TEXT_TRANSFORM_UPPERCASE },
   { eCSSKeyword_full_width, NS_STYLE_TEXT_TRANSFORM_FULLWIDTH },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kTouchActionKTable[] = {
+const KTableEntry nsCSSProps::kTouchActionKTable[] = {
   { eCSSKeyword_none,         NS_STYLE_TOUCH_ACTION_NONE },
   { eCSSKeyword_auto,         NS_STYLE_TOUCH_ACTION_AUTO },
   { eCSSKeyword_pan_x,        NS_STYLE_TOUCH_ACTION_PAN_X },
   { eCSSKeyword_pan_y,        NS_STYLE_TOUCH_ACTION_PAN_Y },
   { eCSSKeyword_manipulation, NS_STYLE_TOUCH_ACTION_MANIPULATION },
   { eCSSKeyword_UNKNOWN,      -1 }
 };
 
-const KTableValue nsCSSProps::kTopLayerKTable[] = {
+const KTableEntry nsCSSProps::kTopLayerKTable[] = {
   { eCSSKeyword_none,     NS_STYLE_TOP_LAYER_NONE },
   { eCSSKeyword_top,      NS_STYLE_TOP_LAYER_TOP },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kTransformBoxKTable[] = {
+const KTableEntry nsCSSProps::kTransformBoxKTable[] = {
   { eCSSKeyword_border_box, NS_STYLE_TRANSFORM_BOX_BORDER_BOX },
   { eCSSKeyword_fill_box, NS_STYLE_TRANSFORM_BOX_FILL_BOX },
   { eCSSKeyword_view_box, NS_STYLE_TRANSFORM_BOX_VIEW_BOX },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kTransitionTimingFunctionKTable[] = {
+const KTableEntry nsCSSProps::kTransitionTimingFunctionKTable[] = {
   { eCSSKeyword_ease, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE },
   { eCSSKeyword_linear, NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR },
   { eCSSKeyword_ease_in, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN },
   { eCSSKeyword_ease_out, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT },
   { eCSSKeyword_ease_in_out, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT },
   { eCSSKeyword_step_start, NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_START },
   { eCSSKeyword_step_end, NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_END },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kUnicodeBidiKTable[] = {
+const KTableEntry nsCSSProps::kUnicodeBidiKTable[] = {
   { eCSSKeyword_normal, NS_STYLE_UNICODE_BIDI_NORMAL },
   { eCSSKeyword_embed, NS_STYLE_UNICODE_BIDI_EMBED },
   { eCSSKeyword_bidi_override, NS_STYLE_UNICODE_BIDI_OVERRIDE },
   { eCSSKeyword__moz_isolate, NS_STYLE_UNICODE_BIDI_ISOLATE },
   { eCSSKeyword__moz_isolate_override, NS_STYLE_UNICODE_BIDI_ISOLATE_OVERRIDE },
   { eCSSKeyword__moz_plaintext, NS_STYLE_UNICODE_BIDI_PLAINTEXT },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kUserFocusKTable[] = {
+const KTableEntry nsCSSProps::kUserFocusKTable[] = {
   { eCSSKeyword_none,           NS_STYLE_USER_FOCUS_NONE },
   { eCSSKeyword_normal,         NS_STYLE_USER_FOCUS_NORMAL },
   { eCSSKeyword_ignore,         NS_STYLE_USER_FOCUS_IGNORE },
   { eCSSKeyword_select_all,     NS_STYLE_USER_FOCUS_SELECT_ALL },
   { eCSSKeyword_select_before,  NS_STYLE_USER_FOCUS_SELECT_BEFORE },
   { eCSSKeyword_select_after,   NS_STYLE_USER_FOCUS_SELECT_AFTER },
   { eCSSKeyword_select_same,    NS_STYLE_USER_FOCUS_SELECT_SAME },
   { eCSSKeyword_select_menu,    NS_STYLE_USER_FOCUS_SELECT_MENU },
   { eCSSKeyword_UNKNOWN,        -1 }
 };
 
-const KTableValue nsCSSProps::kUserInputKTable[] = {
+const KTableEntry nsCSSProps::kUserInputKTable[] = {
   { eCSSKeyword_none,     NS_STYLE_USER_INPUT_NONE },
   { eCSSKeyword_auto,     NS_STYLE_USER_INPUT_AUTO },
   { eCSSKeyword_enabled,  NS_STYLE_USER_INPUT_ENABLED },
   { eCSSKeyword_disabled, NS_STYLE_USER_INPUT_DISABLED },
   { eCSSKeyword_UNKNOWN,  -1 }
 };
 
-const KTableValue nsCSSProps::kUserModifyKTable[] = {
+const KTableEntry nsCSSProps::kUserModifyKTable[] = {
   { eCSSKeyword_read_only,  NS_STYLE_USER_MODIFY_READ_ONLY },
   { eCSSKeyword_read_write, NS_STYLE_USER_MODIFY_READ_WRITE },
   { eCSSKeyword_write_only, NS_STYLE_USER_MODIFY_WRITE_ONLY },
   { eCSSKeyword_UNKNOWN,    -1 }
 };
 
-const KTableValue nsCSSProps::kUserSelectKTable[] = {
+const KTableEntry nsCSSProps::kUserSelectKTable[] = {
   { eCSSKeyword_none,       NS_STYLE_USER_SELECT_NONE },
   { eCSSKeyword_auto,       NS_STYLE_USER_SELECT_AUTO },
   { eCSSKeyword_text,       NS_STYLE_USER_SELECT_TEXT },
   { eCSSKeyword_element,    NS_STYLE_USER_SELECT_ELEMENT },
   { eCSSKeyword_elements,   NS_STYLE_USER_SELECT_ELEMENTS },
   { eCSSKeyword_all,        NS_STYLE_USER_SELECT_ALL },
   { eCSSKeyword_toggle,     NS_STYLE_USER_SELECT_TOGGLE },
   { eCSSKeyword_tri_state,  NS_STYLE_USER_SELECT_TRI_STATE },
   { eCSSKeyword__moz_all,   NS_STYLE_USER_SELECT_MOZ_ALL },
   { eCSSKeyword__moz_none,  NS_STYLE_USER_SELECT_NONE },
   { eCSSKeyword__moz_text,  NS_STYLE_USER_SELECT_MOZ_TEXT },
   { eCSSKeyword_UNKNOWN,    -1 }
 };
 
-const KTableValue nsCSSProps::kVerticalAlignKTable[] = {
+const KTableEntry nsCSSProps::kVerticalAlignKTable[] = {
   { eCSSKeyword_baseline, NS_STYLE_VERTICAL_ALIGN_BASELINE },
   { eCSSKeyword_sub, NS_STYLE_VERTICAL_ALIGN_SUB },
   { eCSSKeyword_super, NS_STYLE_VERTICAL_ALIGN_SUPER },
   { eCSSKeyword_top, NS_STYLE_VERTICAL_ALIGN_TOP },
   { eCSSKeyword_text_top, NS_STYLE_VERTICAL_ALIGN_TEXT_TOP },
   { eCSSKeyword_middle, NS_STYLE_VERTICAL_ALIGN_MIDDLE },
   { eCSSKeyword__moz_middle_with_baseline, NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE },
   { eCSSKeyword_bottom, NS_STYLE_VERTICAL_ALIGN_BOTTOM },
   { eCSSKeyword_text_bottom, NS_STYLE_VERTICAL_ALIGN_TEXT_BOTTOM },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kVisibilityKTable[] = {
+const KTableEntry nsCSSProps::kVisibilityKTable[] = {
   { eCSSKeyword_visible, NS_STYLE_VISIBILITY_VISIBLE },
   { eCSSKeyword_hidden, NS_STYLE_VISIBILITY_HIDDEN },
   { eCSSKeyword_collapse, NS_STYLE_VISIBILITY_COLLAPSE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kWhitespaceKTable[] = {
+const KTableEntry nsCSSProps::kWhitespaceKTable[] = {
   { eCSSKeyword_normal, NS_STYLE_WHITESPACE_NORMAL },
   { eCSSKeyword_pre, NS_STYLE_WHITESPACE_PRE },
   { eCSSKeyword_nowrap, NS_STYLE_WHITESPACE_NOWRAP },
   { eCSSKeyword_pre_wrap, NS_STYLE_WHITESPACE_PRE_WRAP },
   { eCSSKeyword_pre_line, NS_STYLE_WHITESPACE_PRE_LINE },
   { eCSSKeyword__moz_pre_space, NS_STYLE_WHITESPACE_PRE_SPACE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kWidthKTable[] = {
+const KTableEntry nsCSSProps::kWidthKTable[] = {
   { eCSSKeyword__moz_max_content, NS_STYLE_WIDTH_MAX_CONTENT },
   { eCSSKeyword__moz_min_content, NS_STYLE_WIDTH_MIN_CONTENT },
   { eCSSKeyword__moz_fit_content, NS_STYLE_WIDTH_FIT_CONTENT },
   { eCSSKeyword__moz_available, NS_STYLE_WIDTH_AVAILABLE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kWindowDraggingKTable[] = {
+const KTableEntry nsCSSProps::kWindowDraggingKTable[] = {
   { eCSSKeyword_drag, NS_STYLE_WINDOW_DRAGGING_DRAG },
   { eCSSKeyword_no_drag, NS_STYLE_WINDOW_DRAGGING_NO_DRAG },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kWindowShadowKTable[] = {
+const KTableEntry nsCSSProps::kWindowShadowKTable[] = {
   { eCSSKeyword_none, NS_STYLE_WINDOW_SHADOW_NONE },
   { eCSSKeyword_default, NS_STYLE_WINDOW_SHADOW_DEFAULT },
   { eCSSKeyword_menu, NS_STYLE_WINDOW_SHADOW_MENU },
   { eCSSKeyword_tooltip, NS_STYLE_WINDOW_SHADOW_TOOLTIP },
   { eCSSKeyword_sheet, NS_STYLE_WINDOW_SHADOW_SHEET },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kWordBreakKTable[] = {
+const KTableEntry nsCSSProps::kWordBreakKTable[] = {
   { eCSSKeyword_normal, NS_STYLE_WORDBREAK_NORMAL },
   { eCSSKeyword_break_all, NS_STYLE_WORDBREAK_BREAK_ALL },
   { eCSSKeyword_keep_all, NS_STYLE_WORDBREAK_KEEP_ALL },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kWordWrapKTable[] = {
+const KTableEntry nsCSSProps::kWordWrapKTable[] = {
   { eCSSKeyword_normal, NS_STYLE_WORDWRAP_NORMAL },
   { eCSSKeyword_break_word, NS_STYLE_WORDWRAP_BREAK_WORD },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kWritingModeKTable[] = {
+const KTableEntry nsCSSProps::kWritingModeKTable[] = {
   { eCSSKeyword_horizontal_tb, NS_STYLE_WRITING_MODE_HORIZONTAL_TB },
   { eCSSKeyword_vertical_lr, NS_STYLE_WRITING_MODE_VERTICAL_LR },
   { eCSSKeyword_vertical_rl, NS_STYLE_WRITING_MODE_VERTICAL_RL },
   { eCSSKeyword_sideways_lr, NS_STYLE_WRITING_MODE_SIDEWAYS_LR },
   { eCSSKeyword_sideways_rl, NS_STYLE_WRITING_MODE_SIDEWAYS_RL },
   { eCSSKeyword_lr, NS_STYLE_WRITING_MODE_HORIZONTAL_TB },
   { eCSSKeyword_lr_tb, NS_STYLE_WRITING_MODE_HORIZONTAL_TB },
   { eCSSKeyword_rl, NS_STYLE_WRITING_MODE_HORIZONTAL_TB },
   { eCSSKeyword_rl_tb, NS_STYLE_WRITING_MODE_HORIZONTAL_TB },
   { eCSSKeyword_tb, NS_STYLE_WRITING_MODE_VERTICAL_RL },
   { eCSSKeyword_tb_rl, NS_STYLE_WRITING_MODE_VERTICAL_RL },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
 // Specific keyword tables for XUL.properties
-const KTableValue nsCSSProps::kBoxAlignKTable[] = {
+const KTableEntry nsCSSProps::kBoxAlignKTable[] = {
   { eCSSKeyword_stretch, NS_STYLE_BOX_ALIGN_STRETCH },
   { eCSSKeyword_start, NS_STYLE_BOX_ALIGN_START },
   { eCSSKeyword_center, NS_STYLE_BOX_ALIGN_CENTER },
   { eCSSKeyword_baseline, NS_STYLE_BOX_ALIGN_BASELINE },
   { eCSSKeyword_end, NS_STYLE_BOX_ALIGN_END },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kBoxDirectionKTable[] = {
+const KTableEntry nsCSSProps::kBoxDirectionKTable[] = {
   { eCSSKeyword_normal, NS_STYLE_BOX_DIRECTION_NORMAL },
   { eCSSKeyword_reverse, NS_STYLE_BOX_DIRECTION_REVERSE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kBoxOrientKTable[] = {
+const KTableEntry nsCSSProps::kBoxOrientKTable[] = {
   { eCSSKeyword_horizontal, NS_STYLE_BOX_ORIENT_HORIZONTAL },
   { eCSSKeyword_vertical, NS_STYLE_BOX_ORIENT_VERTICAL },
   { eCSSKeyword_inline_axis, NS_STYLE_BOX_ORIENT_HORIZONTAL },
   { eCSSKeyword_block_axis, NS_STYLE_BOX_ORIENT_VERTICAL },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kBoxPackKTable[] = {
+const KTableEntry nsCSSProps::kBoxPackKTable[] = {
   { eCSSKeyword_start, NS_STYLE_BOX_PACK_START },
   { eCSSKeyword_center, NS_STYLE_BOX_PACK_CENTER },
   { eCSSKeyword_end, NS_STYLE_BOX_PACK_END },
   { eCSSKeyword_justify, NS_STYLE_BOX_PACK_JUSTIFY },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
 // keyword tables for SVG properties
 
-const KTableValue nsCSSProps::kDominantBaselineKTable[] = {
+const KTableEntry nsCSSProps::kDominantBaselineKTable[] = {
   { eCSSKeyword_auto, NS_STYLE_DOMINANT_BASELINE_AUTO },
   { eCSSKeyword_use_script, NS_STYLE_DOMINANT_BASELINE_USE_SCRIPT },
   { eCSSKeyword_no_change, NS_STYLE_DOMINANT_BASELINE_NO_CHANGE },
   { eCSSKeyword_reset_size, NS_STYLE_DOMINANT_BASELINE_RESET_SIZE },
   { eCSSKeyword_alphabetic, NS_STYLE_DOMINANT_BASELINE_ALPHABETIC },
   { eCSSKeyword_hanging, NS_STYLE_DOMINANT_BASELINE_HANGING },
   { eCSSKeyword_ideographic, NS_STYLE_DOMINANT_BASELINE_IDEOGRAPHIC },
   { eCSSKeyword_mathematical, NS_STYLE_DOMINANT_BASELINE_MATHEMATICAL },
   { eCSSKeyword_central, NS_STYLE_DOMINANT_BASELINE_CENTRAL },
   { eCSSKeyword_middle, NS_STYLE_DOMINANT_BASELINE_MIDDLE },
   { eCSSKeyword_text_after_edge, NS_STYLE_DOMINANT_BASELINE_TEXT_AFTER_EDGE },
   { eCSSKeyword_text_before_edge, NS_STYLE_DOMINANT_BASELINE_TEXT_BEFORE_EDGE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFillRuleKTable[] = {
+const KTableEntry nsCSSProps::kFillRuleKTable[] = {
   { eCSSKeyword_nonzero, NS_STYLE_FILL_RULE_NONZERO },
   { eCSSKeyword_evenodd, NS_STYLE_FILL_RULE_EVENODD },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kClipShapeSizingKTable[] = {
+const KTableEntry nsCSSProps::kClipShapeSizingKTable[] = {
   { eCSSKeyword_content_box,   NS_STYLE_CLIP_SHAPE_SIZING_CONTENT },
   { eCSSKeyword_padding_box,   NS_STYLE_CLIP_SHAPE_SIZING_PADDING },
   { eCSSKeyword_border_box,    NS_STYLE_CLIP_SHAPE_SIZING_BORDER },
   { eCSSKeyword_margin_box,    NS_STYLE_CLIP_SHAPE_SIZING_MARGIN },
   { eCSSKeyword_fill_box,      NS_STYLE_CLIP_SHAPE_SIZING_FILL },
   { eCSSKeyword_stroke_box,    NS_STYLE_CLIP_SHAPE_SIZING_STROKE },
   { eCSSKeyword_view_box,      NS_STYLE_CLIP_SHAPE_SIZING_VIEW },
   { eCSSKeyword_UNKNOWN,       -1 }
 };
 
-const KTableValue nsCSSProps::kShapeRadiusKTable[] = {
+const KTableEntry nsCSSProps::kShapeRadiusKTable[] = {
   { eCSSKeyword_closest_side, NS_RADIUS_CLOSEST_SIDE },
   { eCSSKeyword_farthest_side, NS_RADIUS_FARTHEST_SIDE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kFilterFunctionKTable[] = {
+const KTableEntry nsCSSProps::kFilterFunctionKTable[] = {
   { eCSSKeyword_blur, NS_STYLE_FILTER_BLUR },
   { eCSSKeyword_brightness, NS_STYLE_FILTER_BRIGHTNESS },
   { eCSSKeyword_contrast, NS_STYLE_FILTER_CONTRAST },
   { eCSSKeyword_grayscale, NS_STYLE_FILTER_GRAYSCALE },
   { eCSSKeyword_invert, NS_STYLE_FILTER_INVERT },
   { eCSSKeyword_opacity, NS_STYLE_FILTER_OPACITY },
   { eCSSKeyword_saturate, NS_STYLE_FILTER_SATURATE },
   { eCSSKeyword_sepia, NS_STYLE_FILTER_SEPIA },
   { eCSSKeyword_hue_rotate, NS_STYLE_FILTER_HUE_ROTATE },
   { eCSSKeyword_drop_shadow, NS_STYLE_FILTER_DROP_SHADOW },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kImageRenderingKTable[] = {
+const KTableEntry nsCSSProps::kImageRenderingKTable[] = {
   { eCSSKeyword_auto, NS_STYLE_IMAGE_RENDERING_AUTO },
   { eCSSKeyword_optimizespeed, NS_STYLE_IMAGE_RENDERING_OPTIMIZESPEED },
   { eCSSKeyword_optimizequality, NS_STYLE_IMAGE_RENDERING_OPTIMIZEQUALITY },
   { eCSSKeyword__moz_crisp_edges, NS_STYLE_IMAGE_RENDERING_CRISPEDGES },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kMaskTypeKTable[] = {
+const KTableEntry nsCSSProps::kMaskTypeKTable[] = {
   { eCSSKeyword_luminance, NS_STYLE_MASK_TYPE_LUMINANCE },
   { eCSSKeyword_alpha, NS_STYLE_MASK_TYPE_ALPHA },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kShapeRenderingKTable[] = {
+const KTableEntry nsCSSProps::kShapeRenderingKTable[] = {
   { eCSSKeyword_auto, NS_STYLE_SHAPE_RENDERING_AUTO },
   { eCSSKeyword_optimizespeed, NS_STYLE_SHAPE_RENDERING_OPTIMIZESPEED },
   { eCSSKeyword_crispedges, NS_STYLE_SHAPE_RENDERING_CRISPEDGES },
   { eCSSKeyword_geometricprecision, NS_STYLE_SHAPE_RENDERING_GEOMETRICPRECISION },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kStrokeLinecapKTable[] = {
+const KTableEntry nsCSSProps::kStrokeLinecapKTable[] = {
   { eCSSKeyword_butt, NS_STYLE_STROKE_LINECAP_BUTT },
   { eCSSKeyword_round, NS_STYLE_STROKE_LINECAP_ROUND },
   { eCSSKeyword_square, NS_STYLE_STROKE_LINECAP_SQUARE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kStrokeLinejoinKTable[] = {
+const KTableEntry nsCSSProps::kStrokeLinejoinKTable[] = {
   { eCSSKeyword_miter, NS_STYLE_STROKE_LINEJOIN_MITER },
   { eCSSKeyword_round, NS_STYLE_STROKE_LINEJOIN_ROUND },
   { eCSSKeyword_bevel, NS_STYLE_STROKE_LINEJOIN_BEVEL },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
 // Lookup table to store the sole objectValue keyword to let SVG glyphs inherit
 // certain stroke-* properties from the outer text object
-const KTableValue nsCSSProps::kStrokeContextValueKTable[] = {
+const KTableEntry nsCSSProps::kStrokeContextValueKTable[] = {
   { eCSSKeyword_context_value, NS_STYLE_STROKE_PROP_CONTEXT_VALUE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kTextAnchorKTable[] = {
+const KTableEntry nsCSSProps::kTextAnchorKTable[] = {
   { eCSSKeyword_start, NS_STYLE_TEXT_ANCHOR_START },
   { eCSSKeyword_middle, NS_STYLE_TEXT_ANCHOR_MIDDLE },
   { eCSSKeyword_end, NS_STYLE_TEXT_ANCHOR_END },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kTextRenderingKTable[] = {
+const KTableEntry nsCSSProps::kTextRenderingKTable[] = {
   { eCSSKeyword_auto, NS_STYLE_TEXT_RENDERING_AUTO },
   { eCSSKeyword_optimizespeed, NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED },
   { eCSSKeyword_optimizelegibility, NS_STYLE_TEXT_RENDERING_OPTIMIZELEGIBILITY },
   { eCSSKeyword_geometricprecision, NS_STYLE_TEXT_RENDERING_GEOMETRICPRECISION },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kVectorEffectKTable[] = {
+const KTableEntry nsCSSProps::kVectorEffectKTable[] = {
   { eCSSKeyword_none, NS_STYLE_VECTOR_EFFECT_NONE },
   { eCSSKeyword_non_scaling_stroke, NS_STYLE_VECTOR_EFFECT_NON_SCALING_STROKE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kColorInterpolationKTable[] = {
+const KTableEntry nsCSSProps::kColorInterpolationKTable[] = {
   { eCSSKeyword_auto, NS_STYLE_COLOR_INTERPOLATION_AUTO },
   { eCSSKeyword_srgb, NS_STYLE_COLOR_INTERPOLATION_SRGB },
   { eCSSKeyword_linearrgb, NS_STYLE_COLOR_INTERPOLATION_LINEARRGB },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
-const KTableValue nsCSSProps::kColumnFillKTable[] = {
+const KTableEntry nsCSSProps::kColumnFillKTable[] = {
   { eCSSKeyword_auto, NS_STYLE_COLUMN_FILL_AUTO },
   { eCSSKeyword_balance, NS_STYLE_COLUMN_FILL_BALANCE },
   { eCSSKeyword_UNKNOWN, -1 }
 };
 
 static inline bool
-IsKeyValSentinel(const KTableValue& aTableEntry)
+IsKeyValSentinel(const KTableEntry& aTableEntry)
 {
   return aTableEntry.mKeyword == eCSSKeyword_UNKNOWN &&
          aTableEntry.mValue == -1;
 }
 
 int32_t
 nsCSSProps::FindIndexOfKeyword(nsCSSKeyword aKeyword,
-                               const KTableValue aTable[])
+                               const KTableEntry aTable[])
 {
   if (eCSSKeyword_UNKNOWN == aKeyword) {
     // NOTE: we can have keyword tables where eCSSKeyword_UNKNOWN is used
     // not only for the sentinel, but also in the middle of the table to
     // knock out values that have been disabled by prefs, e.g. kDisplayKTable.
     // So we deal with eCSSKeyword_UNKNOWN up front to avoid returning a valid
     // index in the loop below.
     return -1;
   }
   for (int32_t i = 0; ; ++i) {
-    const KTableValue& entry = aTable[i];
+    const KTableEntry& entry = aTable[i];
     if (::IsKeyValSentinel(entry)) {
       break;
     }
     if (aKeyword == entry.mKeyword) {
       return i;
     }
   }
   return -1;
 }
 
 bool
-nsCSSProps::FindKeyword(nsCSSKeyword aKeyword, const KTableValue aTable[],
+nsCSSProps::FindKeyword(nsCSSKeyword aKeyword, const KTableEntry aTable[],
                         int32_t& aResult)
 {
   int32_t index = FindIndexOfKeyword(aKeyword, aTable);
   if (index >= 0) {
     aResult = aTable[index].mValue;
     return true;
   }
   return false;
 }
 
 nsCSSKeyword
-nsCSSProps::ValueToKeywordEnum(int32_t aValue, const KTableValue aTable[])
+nsCSSProps::ValueToKeywordEnum(int32_t aValue, const KTableEntry aTable[])
 {
   typedef decltype(aTable[0].mValue) table_value_type;
   NS_ASSERTION(table_value_type(aValue) == aValue, "Value out of range");
   for (int32_t i = 0; ; ++i) {
-    const KTableValue& entry = aTable[i];
+    const KTableEntry& entry = aTable[i];
     if (::IsKeyValSentinel(entry)) {
       break;
     }
     if (aValue == entry.mValue) {
       return entry.mKeyword;
     }
   }
   return eCSSKeyword_UNKNOWN;
 }
 
 const nsAFlatCString&
-nsCSSProps::ValueToKeyword(int32_t aValue, const KTableValue aTable[])
+nsCSSProps::ValueToKeyword(int32_t aValue, const KTableEntry aTable[])
 {
   nsCSSKeyword keyword = ValueToKeywordEnum(aValue, aTable);
   if (keyword == eCSSKeyword_UNKNOWN) {
     static nsDependentCString sNullStr("");
     return sNullStr;
   } else {
     return nsCSSKeywords::GetStringValue(keyword);
   }
 }
 
-/* static */ const KTableValue* const
+/* static */ const KTableEntry* const
 nsCSSProps::kKeywordTableTable[eCSSProperty_COUNT_no_shorthands] = {
   #define CSS_PROP(name_, id_, method_, flags_, pref_, parsevariant_,     \
                    kwtable_, stylestruct_, stylestructoffset_, animtype_) \
     kwtable_,
   #define CSS_PROP_LIST_INCLUDE_LOGICAL
   #include "nsCSSPropList.h"
   #undef CSS_PROP_LIST_INCLUDE_LOGICAL
   #undef CSS_PROP
 };
 
 const nsAFlatCString&
 nsCSSProps::LookupPropertyValue(nsCSSProperty aProp, int32_t aValue)
 {
   MOZ_ASSERT(aProp >= 0 && aProp < eCSSProperty_COUNT,
              "property out of range");
-  typedef decltype(KTableValue::mValue) table_value_type;
+  typedef decltype(KTableEntry::mValue) table_value_type;
   NS_ASSERTION(table_value_type(aValue) == aValue, "Value out of range");
 
-  const KTableValue* kwtable = nullptr;
+  const KTableEntry* kwtable = nullptr;
   if (aProp < eCSSProperty_COUNT_no_shorthands)
     kwtable = kKeywordTableTable[aProp];
 
   if (kwtable)
     return ValueToKeyword(aValue, kwtable);
 
   static nsDependentCString sNullStr("");
   return sNullStr;
@@ -2832,17 +2832,17 @@ nsCSSProps::kLogicalGroupTable[eCSSPrope
 #undef CSS_PROP_LOGICAL_GROUP_AXIS
 #undef CSS_PROP_LOGICAL_GROUP_SHORTHAND
 };
 
 // Mapping of logical longhand properties to their logical group (which
 // represents the physical longhands the logical properties an correspond
 // to).  The format is pairs of values, where the first is the logical
 // longhand property (an nsCSSProperty) and the second is the logical group
-// (an nsCSSPropertyLogicalGroup), stored in a flat array (like KTableValue
+// (an nsCSSPropertyLogicalGroup), stored in a flat array (like KTableEntry
 // arrays).
 static const int gLogicalGroupMappingTable[] = {
 #define CSS_PROP_LOGICAL(name_, id_, method_, flags_, pref_, parsevariant_, \
                          kwtable_, group_, stylestruct_,                    \
                          stylestructoffset_, animtype_)                     \
   eCSSProperty_##id_, eCSSPropertyLogicalGroup_##group_,
 #include "nsCSSPropList.h"
 #undef CSS_PROP_LOGICAL
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -302,17 +302,17 @@ enum nsStyleAnimType {
   eStyleAnimType_Shadow,
 
   // property not animatable
   eStyleAnimType_None
 };
 
 class nsCSSProps {
 public:
-  struct KTableValue {
+  struct KTableEntry {
     nsCSSKeyword mKeyword;
     int16_t mValue;
   };
 
   static void AddRefTable(void);
   static void ReleaseTable(void);
 
   enum EnabledState {
@@ -385,32 +385,32 @@ public:
   // Get a color name for a predefined color value like buttonhighlight or activeborder
   // Sets the aStr param to the name of the propertyID
   static bool GetColorName(int32_t aPropID, nsCString &aStr);
 
   // Returns the index of |aKeyword| in |aTable|, if it exists there;
   // otherwise, returns -1.
   // NOTE: Generally, clients should call FindKeyword() instead of this method.
   static int32_t FindIndexOfKeyword(nsCSSKeyword aKeyword,
-                                    const KTableValue aTable[]);
+                                    const KTableEntry aTable[]);
 
   // Find |aKeyword| in |aTable|, if found set |aValue| to its corresponding value.
   // If not found, return false and do not set |aValue|.
-  static bool FindKeyword(nsCSSKeyword aKeyword, const KTableValue aTable[],
+  static bool FindKeyword(nsCSSKeyword aKeyword, const KTableEntry aTable[],
                           int32_t& aValue);
   // Return the first keyword in |aTable| that has the corresponding value |aValue|.
   // Return |eCSSKeyword_UNKNOWN| if not found.
   static nsCSSKeyword ValueToKeywordEnum(int32_t aValue, 
-                                         const KTableValue aTable[]);
+                                         const KTableEntry aTable[]);
   // Ditto but as a string, return "" when not found.
   static const nsAFlatCString& ValueToKeyword(int32_t aValue,
-                                              const KTableValue aTable[]);
+                                              const KTableEntry aTable[]);
 
   static const nsStyleStructID kSIDTable[eCSSProperty_COUNT_no_shorthands];
-  static const KTableValue* const kKeywordTableTable[eCSSProperty_COUNT_no_shorthands];
+  static const KTableEntry* const kKeywordTableTable[eCSSProperty_COUNT_no_shorthands];
   static const nsStyleAnimType kAnimTypeTable[eCSSProperty_COUNT_no_shorthands];
   static const ptrdiff_t
     kStyleStructOffsetTable[eCSSProperty_COUNT_no_shorthands];
 
 private:
   static const uint32_t        kFlagsTable[eCSSProperty_COUNT];
 
 public:
@@ -625,190 +625,190 @@ public:
 // therefore a pair of macros by consumers for the start and end of the loop.
 #define CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(it_, prop_, enabledstate_)       \
   for (const nsCSSProperty *it_ = nsCSSProps::SubpropertyEntryFor(prop_),     \
                             es_ = (nsCSSProperty) (enabledstate_);            \
        *it_ != eCSSProperty_UNKNOWN; ++it_)                                   \
     if (nsCSSProps::IsEnabled(*it_, (nsCSSProps::EnabledState) es_))
 
   // Keyword/Enum value tables
-  static const KTableValue kAnimationDirectionKTable[];
-  static const KTableValue kAnimationFillModeKTable[];
-  static const KTableValue kAnimationIterationCountKTable[];
-  static const KTableValue kAnimationPlayStateKTable[];
-  static const KTableValue kAnimationTimingFunctionKTable[];
-  static const KTableValue kAppearanceKTable[];
-  static const KTableValue kAzimuthKTable[];
-  static const KTableValue kBackfaceVisibilityKTable[];
-  static const KTableValue kTransformStyleKTable[];
-  static const KTableValue kBackgroundAttachmentKTable[];
-  static const KTableValue kBackgroundOriginKTable[];
-  static const KTableValue kBackgroundPositionKTable[];
-  static const KTableValue kBackgroundRepeatKTable[];
-  static const KTableValue kBackgroundRepeatPartKTable[];
-  static const KTableValue kBackgroundSizeKTable[];
-  static const KTableValue kBlendModeKTable[];
-  static const KTableValue kBorderCollapseKTable[];
-  static const KTableValue kBorderColorKTable[];
-  static const KTableValue kBorderImageRepeatKTable[];
-  static const KTableValue kBorderImageSliceKTable[];
-  static const KTableValue kBorderStyleKTable[];
-  static const KTableValue kBorderWidthKTable[];
-  static const KTableValue kBoxAlignKTable[];
-  static const KTableValue kBoxDecorationBreakKTable[];
-  static const KTableValue kBoxDirectionKTable[];
-  static const KTableValue kBoxOrientKTable[];
-  static const KTableValue kBoxPackKTable[];
-  static const KTableValue kClipShapeSizingKTable[];
-  static const KTableValue kCounterRangeKTable[];
-  static const KTableValue kCounterSpeakAsKTable[];
-  static const KTableValue kCounterSymbolsSystemKTable[];
-  static const KTableValue kCounterSystemKTable[];
-  static const KTableValue kDominantBaselineKTable[];
-  static const KTableValue kShapeRadiusKTable[];
-  static const KTableValue kFillRuleKTable[];
-  static const KTableValue kFilterFunctionKTable[];
-  static const KTableValue kImageRenderingKTable[];
-  static const KTableValue kShapeRenderingKTable[];
-  static const KTableValue kStrokeLinecapKTable[];
-  static const KTableValue kStrokeLinejoinKTable[];
-  static const KTableValue kStrokeContextValueKTable[];
-  static const KTableValue kVectorEffectKTable[];
-  static const KTableValue kTextAnchorKTable[];
-  static const KTableValue kTextRenderingKTable[];
-  static const KTableValue kColorInterpolationKTable[];
-  static const KTableValue kColumnFillKTable[];
-  static const KTableValue kBoxPropSourceKTable[];
-  static const KTableValue kBoxShadowTypeKTable[];
-  static const KTableValue kBoxSizingKTable[];
-  static const KTableValue kCaptionSideKTable[];
+  static const KTableEntry kAnimationDirectionKTable[];
+  static const KTableEntry kAnimationFillModeKTable[];
+  static const KTableEntry kAnimationIterationCountKTable[];
+  static const KTableEntry kAnimationPlayStateKTable[];
+  static const KTableEntry kAnimationTimingFunctionKTable[];
+  static const KTableEntry kAppearanceKTable[];
+  static const KTableEntry kAzimuthKTable[];
+  static const KTableEntry kBackfaceVisibilityKTable[];
+  static const KTableEntry kTransformStyleKTable[];
+  static const KTableEntry kBackgroundAttachmentKTable[];
+  static const KTableEntry kBackgroundOriginKTable[];
+  static const KTableEntry kBackgroundPositionKTable[];
+  static const KTableEntry kBackgroundRepeatKTable[];
+  static const KTableEntry kBackgroundRepeatPartKTable[];
+  static const KTableEntry kBackgroundSizeKTable[];
+  static const KTableEntry kBlendModeKTable[];
+  static const KTableEntry kBorderCollapseKTable[];
+  static const KTableEntry kBorderColorKTable[];
+  static const KTableEntry kBorderImageRepeatKTable[];
+  static const KTableEntry kBorderImageSliceKTable[];
+  static const KTableEntry kBorderStyleKTable[];
+  static const KTableEntry kBorderWidthKTable[];
+  static const KTableEntry kBoxAlignKTable[];
+  static const KTableEntry kBoxDecorationBreakKTable[];
+  static const KTableEntry kBoxDirectionKTable[];
+  static const KTableEntry kBoxOrientKTable[];
+  static const KTableEntry kBoxPackKTable[];
+  static const KTableEntry kClipShapeSizingKTable[];
+  static const KTableEntry kCounterRangeKTable[];
+  static const KTableEntry kCounterSpeakAsKTable[];
+  static const KTableEntry kCounterSymbolsSystemKTable[];
+  static const KTableEntry kCounterSystemKTable[];
+  static const KTableEntry kDominantBaselineKTable[];
+  static const KTableEntry kShapeRadiusKTable[];
+  static const KTableEntry kFillRuleKTable[];
+  static const KTableEntry kFilterFunctionKTable[];
+  static const KTableEntry kImageRenderingKTable[];
+  static const KTableEntry kShapeRenderingKTable[];
+  static const KTableEntry kStrokeLinecapKTable[];
+  static const KTableEntry kStrokeLinejoinKTable[];
+  static const KTableEntry kStrokeContextValueKTable[];
+  static const KTableEntry kVectorEffectKTable[];
+  static const KTableEntry kTextAnchorKTable[];
+  static const KTableEntry kTextRenderingKTable[];
+  static const KTableEntry kColorInterpolationKTable[];
+  static const KTableEntry kColumnFillKTable[];
+  static const KTableEntry kBoxPropSourceKTable[];
+  static const KTableEntry kBoxShadowTypeKTable[];
+  static const KTableEntry kBoxSizingKTable[];
+  static const KTableEntry kCaptionSideKTable[];
   // Not const because we modify its entries when the pref
   // "layout.css.float-logical-values.enabled" changes:
-  static KTableValue kClearKTable[];
-  static const KTableValue kColorKTable[];
-  static const KTableValue kContentKTable[];
-  static const KTableValue kControlCharacterVisibilityKTable[];
-  static const KTableValue kCursorKTable[];
-  static const KTableValue kDirectionKTable[];
+  static KTableEntry kClearKTable[];
+  static const KTableEntry kColorKTable[];
+  static const KTableEntry kContentKTable[];
+  static const KTableEntry kControlCharacterVisibilityKTable[];
+  static const KTableEntry kCursorKTable[];
+  static const KTableEntry kDirectionKTable[];
   // Not const because we modify its entries when various 
   // "layout.css.*.enabled" prefs changes:
-  static KTableValue kDisplayKTable[];
-  static const KTableValue kElevationKTable[];
-  static const KTableValue kEmptyCellsKTable[];
+  static KTableEntry kDisplayKTable[];
+  static const KTableEntry kElevationKTable[];
+  static const KTableEntry kEmptyCellsKTable[];
   // -- tables for the align-/justify-content/items/self properties --
-  static const KTableValue kAlignAllKeywords[];
-  static const KTableValue kAlignOverflowPosition[]; // <overflow-position>
-  static const KTableValue kAlignSelfPosition[];     // <self-position>
-  static const KTableValue kAlignLegacy[];           // 'legacy'
-  static const KTableValue kAlignLegacyPosition[];   // 'left/right/center'
-  static const KTableValue kAlignAutoStretchBaseline[]; // 'auto/stretch/baseline/last-baseline'
-  static const KTableValue kAlignAutoBaseline[]; // 'auto/baseline/last-baseline'
-  static const KTableValue kAlignContentDistribution[]; // <content-distribution>
-  static const KTableValue kAlignContentPosition[]; // <content-position>
-  static const KTableValue kAlignSelfKTable[];
-  static const KTableValue kJustifyContentKTable[];
+  static const KTableEntry kAlignAllKeywords[];
+  static const KTableEntry kAlignOverflowPosition[]; // <overflow-position>
+  static const KTableEntry kAlignSelfPosition[];     // <self-position>
+  static const KTableEntry kAlignLegacy[];           // 'legacy'
+  static const KTableEntry kAlignLegacyPosition[];   // 'left/right/center'
+  static const KTableEntry kAlignAutoStretchBaseline[]; // 'auto/stretch/baseline/last-baseline'
+  static const KTableEntry kAlignAutoBaseline[]; // 'auto/baseline/last-baseline'
+  static const KTableEntry kAlignContentDistribution[]; // <content-distribution>
+  static const KTableEntry kAlignContentPosition[]; // <content-position>
+  static const KTableEntry kAlignSelfKTable[];
+  static const KTableEntry kJustifyContentKTable[];
   // ------------------------------------------------------------------
-  static const KTableValue kFlexDirectionKTable[];
-  static const KTableValue kFlexWrapKTable[];
+  static const KTableEntry kFlexDirectionKTable[];
+  static const KTableEntry kFlexWrapKTable[];
   // Not const because we modify its entries when the pref
   // "layout.css.float-logical-values.enabled" changes:
-  static KTableValue kFloatKTable[];
-  static const KTableValue kFloatEdgeKTable[];
-  static const KTableValue kFontKTable[];
-  static const KTableValue kFontKerningKTable[];
-  static const KTableValue kFontSizeKTable[];
-  static const KTableValue kFontSmoothingKTable[];
-  static const KTableValue kFontStretchKTable[];
-  static const KTableValue kFontStyleKTable[];
-  static const KTableValue kFontSynthesisKTable[];
-  static const KTableValue kFontVariantKTable[];
-  static const KTableValue kFontVariantAlternatesKTable[];
-  static const KTableValue kFontVariantAlternatesFuncsKTable[];
-  static const KTableValue kFontVariantCapsKTable[];
-  static const KTableValue kFontVariantEastAsianKTable[];
-  static const KTableValue kFontVariantLigaturesKTable[];
-  static const KTableValue kFontVariantNumericKTable[];
-  static const KTableValue kFontVariantPositionKTable[];
-  static const KTableValue kFontWeightKTable[];
-  static const KTableValue kGridAutoFlowKTable[];
-  static const KTableValue kGridTrackBreadthKTable[];
-  static const KTableValue kHyphensKTable[];
-  static const KTableValue kImageOrientationKTable[];
-  static const KTableValue kImageOrientationFlipKTable[];
-  static const KTableValue kIsolationKTable[];
-  static const KTableValue kIMEModeKTable[];
-  static const KTableValue kLineHeightKTable[];
-  static const KTableValue kListStylePositionKTable[];
-  static const KTableValue kListStyleKTable[];
-  static const KTableValue kMaskTypeKTable[];
-  static const KTableValue kMathVariantKTable[];
-  static const KTableValue kMathDisplayKTable[];
-  static const KTableValue kContainKTable[];
-  static const KTableValue kContextOpacityKTable[];
-  static const KTableValue kContextPatternKTable[];
-  static const KTableValue kObjectFitKTable[];
-  static const KTableValue kOrientKTable[];
-  static const KTableValue kOutlineStyleKTable[];
-  static const KTableValue kOutlineColorKTable[];
-  static const KTableValue kOverflowKTable[];
-  static const KTableValue kOverflowSubKTable[];
-  static const KTableValue kOverflowClipBoxKTable[];
-  static const KTableValue kPageBreakKTable[];
-  static const KTableValue kPageBreakInsideKTable[];
-  static const KTableValue kPageMarksKTable[];
-  static const KTableValue kPageSizeKTable[];
-  static const KTableValue kPitchKTable[];
-  static const KTableValue kPointerEventsKTable[];
+  static KTableEntry kFloatKTable[];
+  static const KTableEntry kFloatEdgeKTable[];
+  static const KTableEntry kFontKTable[];
+  static const KTableEntry kFontKerningKTable[];
+  static const KTableEntry kFontSizeKTable[];
+  static const KTableEntry kFontSmoothingKTable[];
+  static const KTableEntry kFontStretchKTable[];
+  static const KTableEntry kFontStyleKTable[];
+  static const KTableEntry kFontSynthesisKTable[];
+  static const KTableEntry kFontVariantKTable[];
+  static const KTableEntry kFontVariantAlternatesKTable[];
+  static const KTableEntry kFontVariantAlternatesFuncsKTable[];
+  static const KTableEntry kFontVariantCapsKTable[];
+  static const KTableEntry kFontVariantEastAsianKTable[];
+  static const KTableEntry kFontVariantLigaturesKTable[];
+  static const KTableEntry kFontVariantNumericKTable[];
+  static const KTableEntry kFontVariantPositionKTable[];
+  static const KTableEntry kFontWeightKTable[];
+  static const KTableEntry kGridAutoFlowKTable[];
+  static const KTableEntry kGridTrackBreadthKTable[];
+  static const KTableEntry kHyphensKTable[];
+  static const KTableEntry kImageOrientationKTable[];
+  static const KTableEntry kImageOrientationFlipKTable[];
+  static const KTableEntry kIsolationKTable[];
+  static const KTableEntry kIMEModeKTable[];
+  static const KTableEntry kLineHeightKTable[];
+  static const KTableEntry kListStylePositionKTable[];
+  static const KTableEntry kListStyleKTable[];
+  static const KTableEntry kMaskTypeKTable[];
+  static const KTableEntry kMathVariantKTable[];
+  static const KTableEntry kMathDisplayKTable[];
+  static const KTableEntry kContainKTable[];
+  static const KTableEntry kContextOpacityKTable[];
+  static const KTableEntry kContextPatternKTable[];
+  static const KTableEntry kObjectFitKTable[];
+  static const KTableEntry kOrientKTable[];
+  static const KTableEntry kOutlineStyleKTable[];
+  static const KTableEntry kOutlineColorKTable[];
+  static const KTableEntry kOverflowKTable[];
+  static const KTableEntry kOverflowSubKTable[];
+  static const KTableEntry kOverflowClipBoxKTable[];
+  static const KTableEntry kPageBreakKTable[];
+  static const KTableEntry kPageBreakInsideKTable[];
+  static const KTableEntry kPageMarksKTable[];
+  static const KTableEntry kPageSizeKTable[];
+  static const KTableEntry kPitchKTable[];
+  static const KTableEntry kPointerEventsKTable[];
   // Not const because we modify its entries when the pref
   // "layout.css.sticky.enabled" changes:
-  static KTableValue kPositionKTable[];
-  static const KTableValue kRadialGradientShapeKTable[];
-  static const KTableValue kRadialGradientSizeKTable[];
-  static const KTableValue kRadialGradientLegacySizeKTable[];
-  static const KTableValue kResizeKTable[];
-  static const KTableValue kRubyAlignKTable[];
-  static const KTableValue kRubyPositionKTable[];
-  static const KTableValue kScrollBehaviorKTable[];
-  static const KTableValue kScrollSnapTypeKTable[];
-  static const KTableValue kSpeakKTable[];
-  static const KTableValue kSpeakHeaderKTable[];
-  static const KTableValue kSpeakNumeralKTable[];
-  static const KTableValue kSpeakPunctuationKTable[];
-  static const KTableValue kSpeechRateKTable[];
-  static const KTableValue kStackSizingKTable[];
-  static const KTableValue kTableLayoutKTable[];
+  static KTableEntry kPositionKTable[];
+  static const KTableEntry kRadialGradientShapeKTable[];
+  static const KTableEntry kRadialGradientSizeKTable[];
+  static const KTableEntry kRadialGradientLegacySizeKTable[];
+  static const KTableEntry kResizeKTable[];
+  static const KTableEntry kRubyAlignKTable[];
+  static const KTableEntry kRubyPositionKTable[];
+  static const KTableEntry kScrollBehaviorKTable[];
+  static const KTableEntry kScrollSnapTypeKTable[];
+  static const KTableEntry kSpeakKTable[];
+  static const KTableEntry kSpeakHeaderKTable[];
+  static const KTableEntry kSpeakNumeralKTable[];
+  static const KTableEntry kSpeakPunctuationKTable[];
+  static const KTableEntry kSpeechRateKTable[];
+  static const KTableEntry kStackSizingKTable[];
+  static const KTableEntry kTableLayoutKTable[];
   // Not const because we modify its entries when the pref
   // "layout.css.text-align-true-value.enabled" changes:
-  static KTableValue kTextAlignKTable[];
-  static KTableValue kTextAlignLastKTable[];
-  static const KTableValue kTextCombineUprightKTable[];
-  static const KTableValue kTextDecorationLineKTable[];
-  static const KTableValue kTextDecorationStyleKTable[];
-  static const KTableValue kTextOrientationKTable[];
-  static const KTableValue kTextOverflowKTable[];
-  static const KTableValue kTextTransformKTable[];
-  static const KTableValue kTouchActionKTable[];
-  static const KTableValue kTopLayerKTable[];
-  static const KTableValue kTransformBoxKTable[];
-  static const KTableValue kTransitionTimingFunctionKTable[];
-  static const KTableValue kUnicodeBidiKTable[];
-  static const KTableValue kUserFocusKTable[];
-  static const KTableValue kUserInputKTable[];
-  static const KTableValue kUserModifyKTable[];
-  static const KTableValue kUserSelectKTable[];
-  static const KTableValue kVerticalAlignKTable[];
-  static const KTableValue kVisibilityKTable[];
-  static const KTableValue kVolumeKTable[];
-  static const KTableValue kWhitespaceKTable[];
-  static const KTableValue kWidthKTable[]; // also min-width, max-width
-  static const KTableValue kWindowDraggingKTable[];
-  static const KTableValue kWindowShadowKTable[];
-  static const KTableValue kWordBreakKTable[];
-  static const KTableValue kWordWrapKTable[];
-  static const KTableValue kWritingModeKTable[];
+  static KTableEntry kTextAlignKTable[];
+  static KTableEntry kTextAlignLastKTable[];
+  static const KTableEntry kTextCombineUprightKTable[];
+  static const KTableEntry kTextDecorationLineKTable[];
+  static const KTableEntry kTextDecorationStyleKTable[];
+  static const KTableEntry kTextOrientationKTable[];
+  static const KTableEntry kTextOverflowKTable[];
+  static const KTableEntry kTextTransformKTable[];
+  static const KTableEntry kTouchActionKTable[];
+  static const KTableEntry kTopLayerKTable[];
+  static const KTableEntry kTransformBoxKTable[];
+  static const KTableEntry kTransitionTimingFunctionKTable[];
+  static const KTableEntry kUnicodeBidiKTable[];
+  static const KTableEntry kUserFocusKTable[];
+  static const KTableEntry kUserInputKTable[];
+  static const KTableEntry kUserModifyKTable[];
+  static const KTableEntry kUserSelectKTable[];
+  static const KTableEntry kVerticalAlignKTable[];
+  static const KTableEntry kVisibilityKTable[];
+  static const KTableEntry kVolumeKTable[];
+  static const KTableEntry kWhitespaceKTable[];
+  static const KTableEntry kWidthKTable[]; // also min-width, max-width
+  static const KTableEntry kWindowDraggingKTable[];
+  static const KTableEntry kWindowShadowKTable[];
+  static const KTableEntry kWordBreakKTable[];
+  static const KTableEntry kWordWrapKTable[];
+  static const KTableEntry kWritingModeKTable[];
 };
 
 inline nsCSSProps::EnabledState operator|(nsCSSProps::EnabledState a,
                                           nsCSSProps::EnabledState b)
 {
   return nsCSSProps::EnabledState(int(a) | int(b));
 }
 
diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -1786,17 +1786,17 @@ nsComputedDOMStyle::DoGetFontVariantPosi
   }
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::GetBackgroundList(uint8_t nsStyleBackground::Layer::* aMember,
                                       uint32_t nsStyleBackground::* aCount,
-                                      const KTableValue aTable[])
+                                      const KTableEntry aTable[])
 {
   const nsStyleBackground* bg = StyleBackground();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   for (uint32_t i = 0, i_end = bg->*aCount; i < i_end; ++i) {
     nsROCSSPrimitiveValue *val = new nsROCSSPrimitiveValue;
     valueList->AppendCSSValue(val);
@@ -3289,17 +3289,17 @@ nsComputedDOMStyle::DoGetVerticalAlign()
   SetValueToCoord(val, StyleTextReset()->mVerticalAlign, false,
                   &nsComputedDOMStyle::GetLineHeightCoord,
                   nsCSSProps::kVerticalAlignKTable);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::CreateTextAlignValue(uint8_t aAlign, bool aAlignTrue,
-                                         const KTableValue aTable[])
+                                         const KTableEntry aTable[])
 {
   nsROCSSPrimitiveValue* val = new nsROCSSPrimitiveValue;
   val->SetIdent(nsCSSProps::ValueToKeywordEnum(aAlign, aTable));
   if (!aAlignTrue) {
     return val;
   }
 
   nsROCSSPrimitiveValue* first = new nsROCSSPrimitiveValue;
@@ -4845,17 +4845,17 @@ nsComputedDOMStyle::GetBorderStyleFor(mo
   return val;
 }
 
 void
 nsComputedDOMStyle::SetValueToCoord(nsROCSSPrimitiveValue* aValue,
                                     const nsStyleCoord& aCoord,
                                     bool aClampNegativeCalc,
                                     PercentageBaseGetter aPercentageBaseGetter,
-                                    const KTableValue aTable[],
+                                    const KTableEntry aTable[],
                                     nscoord aMinAppUnits,
                                     nscoord aMaxAppUnits)
 {
   NS_PRECONDITION(aValue, "Must have a value to work with");
 
   switch (aCoord.GetUnit()) {
     case eStyleUnit_Normal:
       aValue->SetIdent(eCSSKeyword_normal);
diff --git a/layout/style/nsComputedDOMStyle.h b/layout/style/nsComputedDOMStyle.h
--- a/layout/style/nsComputedDOMStyle.h
+++ b/layout/style/nsComputedDOMStyle.h
@@ -43,17 +43,17 @@ class nsStyleGradient;
 struct nsStyleImage;
 class nsStyleSides;
 struct nsTimingFunction;
 
 class nsComputedDOMStyle final : public nsDOMCSSDeclaration
                                , public nsStubMutationObserver
 {
 public:
-  typedef nsCSSProps::KTableValue KTableValue;
+  typedef nsCSSProps::KTableEntry KTableEntry;
 
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS_AMBIGUOUS(nsComputedDOMStyle,
                                                                    nsICSSDeclaration)
 
   NS_DECL_NSICSSDECLARATION
 
   NS_DECL_NSIDOMCSSSTYLEDECLARATION_HELPER
@@ -122,17 +122,17 @@ private:
                  "property getter should have been marked layout-dependent");
   }
 
   nsMargin GetAdjustedValuesForBoxSizing();
 
   // Helper method for DoGetTextAlign[Last].
   mozilla::dom::CSSValue* CreateTextAlignValue(uint8_t aAlign,
                                                bool aAlignTrue,
-                                               const KTableValue aTable[]);
+                                               const KTableEntry aTable[]);
   // This indicates error by leaving mStyleContext null.
   void UpdateCurrentStyleSources(bool aNeedsLayoutFlush);
   void ClearCurrentStyleSources();
 
   // Helper functions called by UpdateCurrentStyleSources.
   void ClearStyleContext();
   void SetResolvedStyleContext(RefPtr<nsStyleContext>&& aContext);
   void SetFrameStyleContext(nsStyleContext* aContext);
@@ -185,17 +185,17 @@ private:
   bool GetLineHeightCoord(nscoord& aCoord);
 
   mozilla::dom::CSSValue* GetCSSShadowArray(nsCSSShadowArray* aArray,
                                             const nscolor& aDefaultColor,
                                             bool aIsBoxShadow);
 
   mozilla::dom::CSSValue* GetBackgroundList(uint8_t nsStyleBackground::Layer::* aMember,
                                             uint32_t nsStyleBackground::* aCount,
-                                            const KTableValue aTable[]);
+                                            const KTableEntry aTable[]);
 
   void GetCSSGradientString(const nsStyleGradient* aGradient,
                             nsAString& aString);
   void GetImageRectString(nsIURI* aURI,
                           const nsStyleSides& aCropRect,
                           nsString& aString);
   mozilla::dom::CSSValue* GetScrollSnapPoints(const nsStyleCoord& aCoord);
   void AppendTimingFunction(nsDOMCSSValueList *aValueList,
@@ -561,17 +561,17 @@ private:
    *
    * XXXbz should caller pass in some sort of bitfield indicating which units
    * can be expected or something?
    */
   void SetValueToCoord(nsROCSSPrimitiveValue* aValue,
                        const nsStyleCoord& aCoord,
                        bool aClampNegativeCalc,
                        PercentageBaseGetter aPercentageBaseGetter = nullptr,
-                       const KTableValue aTable[] = nullptr,
+                       const KTableEntry aTable[] = nullptr,
                        nscoord aMinAppUnits = nscoord_MIN,
                        nscoord aMaxAppUnits = nscoord_MAX);
 
   /**
    * If aCoord is a eStyleUnit_Coord returns the nscoord.  If it's
    * eStyleUnit_Percent, attempts to resolve the percentage base and returns
    * the resulting nscoord.  If it's some other unit or a percentge base can't
    * be determined, returns aDefaultValue.
diff --git a/layout/style/nsMediaFeatures.cpp b/layout/style/nsMediaFeatures.cpp
--- a/layout/style/nsMediaFeatures.cpp
+++ b/layout/style/nsMediaFeatures.cpp
@@ -15,23 +15,23 @@
 #include "mozilla/LookAndFeel.h"
 #endif
 #include "nsCSSRuleProcessor.h"
 #include "nsDeviceContext.h"
 #include "nsIDocument.h"
 
 using namespace mozilla;
 
-static const nsCSSProps::KTableValue kOrientationKeywords[] = {
+static const nsCSSProps::KTableEntry kOrientationKeywords[] = {
   { eCSSKeyword_portrait,                 NS_STYLE_ORIENTATION_PORTRAIT },
   { eCSSKeyword_landscape,                NS_STYLE_ORIENTATION_LANDSCAPE },
   { eCSSKeyword_UNKNOWN,                  -1 }
 };
 
-static const nsCSSProps::KTableValue kScanKeywords[] = {
+static const nsCSSProps::KTableEntry kScanKeywords[] = {
   { eCSSKeyword_progressive,              NS_STYLE_SCAN_PROGRESSIVE },
   { eCSSKeyword_interlace,                NS_STYLE_SCAN_INTERLACE },
   { eCSSKeyword_UNKNOWN,                  -1 }
 };
 
 #ifdef XP_WIN
 struct WindowsThemeName {
     LookAndFeel::WindowsTheme id;
diff --git a/layout/style/nsMediaFeatures.h b/layout/style/nsMediaFeatures.h
--- a/layout/style/nsMediaFeatures.h
+++ b/layout/style/nsMediaFeatures.h
@@ -57,17 +57,17 @@ struct nsMediaFeature {
 
     union {
       // In static arrays, it's the first member that's initialized.  We
       // need that to be void* so we can initialize both other types.
       // This member should never be accessed by name.
       const void* mInitializer_;
       // If mValueType == eEnumerated:  const int32_t*: keyword table in
       //   the same format as the keyword tables in nsCSSProps.
-      const nsCSSProps::KTableValue* mKeywordTable;
+      const nsCSSProps::KTableEntry* mKeywordTable;
       // If mGetter == GetSystemMetric (which implies mValueType ==
       //   eBoolInteger): nsIAtom * const *, for the system metric.
       nsIAtom * const * mMetric;
     } mData;
 
     // A function that returns the current value for this feature for a
     // given presentation.  If it returns eCSSUnit_Null, the feature is
     // not present.
