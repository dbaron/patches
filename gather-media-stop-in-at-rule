From: L. David Baron <dbaron@dbaron.org>

Make GatherMedia() stop at block or semicolon in invalid cases.  (Bug 604172)  r=bzbarsky  (NOTE: passed try on mac 32-bit debug)

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -318,18 +318,18 @@ protected:
 
   PRBool ParseRuleSet(RuleAppendFunc aAppendFunc, void* aProcessData,
                       PRBool aInsideBraces = PR_FALSE);
   PRBool ParseAtRule(RuleAppendFunc aAppendFunc, void* aProcessData);
   PRBool ParseCharsetRule(RuleAppendFunc aAppendFunc, void* aProcessData);
   PRBool ParseImportRule(RuleAppendFunc aAppendFunc, void* aProcessData);
   PRBool GatherURL(nsString& aURL);
   PRBool GatherMedia(nsMediaList* aMedia,
-                     PRUnichar aStopSymbol);
-  PRBool ParseMediaQuery(PRUnichar aStopSymbol, nsMediaQuery **aQuery,
+                     PRBool aInAtRule);
+  PRBool ParseMediaQuery(PRBool aInAtRule, nsMediaQuery **aQuery,
                          PRBool *aParsedSomething, PRBool *aHitStop);
   PRBool ParseMediaQueryExpression(nsMediaQuery* aQuery);
   void ProcessImport(const nsString& aURLSpec,
                      nsMediaList* aMedia,
                      RuleAppendFunc aAppendFunc,
                      void* aProcessData);
   PRBool ParseGroupRule(nsICSSGroupRule* aRule, RuleAppendFunc aAppendFunc,
                         void* aProcessData);
@@ -1173,17 +1173,17 @@ CSSParserImpl::ParseMediaList(const nsSu
   // http://www.w3.org/TR/1999/REC-html401-19991224/types.html#type-media-descriptors
   // which wouldn't work for media queries since they remove all but the
   // first word.  However, they're changed in
   // http://www.whatwg.org/specs/web-apps/current-work/multipage/section-document.html#media2
   // (as of 2008-05-29) which says that the media attribute just points
   // to a media query.  (The main substative difference is the relative
   // precedence of commas and paretheses.)
 
-  if (!GatherMedia(aMediaList, PRUnichar(0))) {
+  if (!GatherMedia(aMediaList, PR_FALSE)) {
     aMediaList->Clear();
     aMediaList->SetNonEmpty(); // don't match anything
     if (!mHTMLMediaMode) {
       OUTPUT_ERROR();
     }
   }
   nsresult rv = mScanner.GetLowLevelError();
   CLEAR_ERROR();
@@ -1563,41 +1563,41 @@ CSSParserImpl::GatherURL(nsString& aURL)
            mToken.mIdent.LowerCaseEqualsLiteral("url") &&
            GetURLInParens(aURL)) {
     return PR_TRUE;
   }
   return PR_FALSE;
 }
 
 PRBool
-CSSParserImpl::ParseMediaQuery(PRUnichar aStopSymbol,
+CSSParserImpl::ParseMediaQuery(PRBool aInAtRule,
                                nsMediaQuery **aQuery,
                                PRBool *aParsedSomething,
                                PRBool *aHitStop)
 {
   *aQuery = nsnull;
   *aParsedSomething = PR_FALSE;
   *aHitStop = PR_FALSE;
 
   // "If the comma-separated list is the empty list it is assumed to
   // specify the media query 'all'."  (css3-mediaqueries, section
   // "Media Queries")
   if (!GetToken(PR_TRUE)) {
     *aHitStop = PR_TRUE;
     // expected termination by EOF
-    if (aStopSymbol == PRUnichar(0))
+    if (!aInAtRule)
       return PR_TRUE;
 
     // unexpected termination by EOF
     REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
     return PR_TRUE;
   }
 
-  if (eCSSToken_Symbol == mToken.mType &&
-      mToken.mSymbol == aStopSymbol) {
+  if (eCSSToken_Symbol == mToken.mType && aInAtRule &&
+      (mToken.mSymbol == ';' || mToken.mSymbol == '{')) {
     *aHitStop = PR_TRUE;
     UngetToken();
     return PR_TRUE;
   }
   UngetToken();
 
   *aParsedSomething = PR_TRUE;
 
@@ -1644,26 +1644,26 @@ CSSParserImpl::ParseMediaQuery(PRUnichar
     }
     query->SetType(mediaType);
   }
 
   for (;;) {
     if (!GetToken(PR_TRUE)) {
       *aHitStop = PR_TRUE;
       // expected termination by EOF
-      if (aStopSymbol == PRUnichar(0))
+      if (!aInAtRule)
         break;
 
       // unexpected termination by EOF
       REPORT_UNEXPECTED_EOF(PEGatherMediaEOF);
       break;
     }
 
-    if (eCSSToken_Symbol == mToken.mType &&
-        mToken.mSymbol == aStopSymbol) {
+    if (eCSSToken_Symbol == mToken.mType && aInAtRule &&
+        (mToken.mSymbol == ';' || mToken.mSymbol == '{')) {
       *aHitStop = PR_TRUE;
       UngetToken();
       break;
     }
     if (eCSSToken_Symbol == mToken.mType && mToken.mSymbol == ',') {
       // Done with the expressions for this query
       break;
     }
@@ -1681,32 +1681,37 @@ CSSParserImpl::ParseMediaQuery(PRUnichar
   *aQuery = query.forget();
   return PR_TRUE;
 }
 
 // Returns false only when there is a low-level error in the scanner
 // (out-of-memory).
 PRBool
 CSSParserImpl::GatherMedia(nsMediaList* aMedia,
-                           PRUnichar aStopSymbol)
+                           PRBool aInAtRule)
 {
   for (;;) {
     nsAutoPtr<nsMediaQuery> query;
     PRBool parsedSomething, hitStop;
-    if (!ParseMediaQuery(aStopSymbol, getter_Transfers(query),
+    if (!ParseMediaQuery(aInAtRule, getter_Transfers(query),
                          &parsedSomething, &hitStop)) {
       NS_ASSERTION(!hitStop, "should return true when hit stop");
       if (NS_FAILED(mScanner.GetLowLevelError())) {
         return PR_FALSE;
       }
-      const PRUnichar stopChars[] =
-        { PRUnichar(','), aStopSymbol /* may be null */, PRUnichar(0) };
-      SkipUntilOneOf(stopChars);
+      if (aInAtRule) {
+        const PRUnichar stopChars[] =
+          { PRUnichar(','), PRUnichar('{'), PRUnichar(';'), PRUnichar(0) };
+        SkipUntilOneOf(stopChars);
+      } else {
+        SkipUntil(',');
+      }
       // Rely on SkipUntilOneOf leaving mToken around as the last token read.
-      if (mToken.mType == eCSSToken_Symbol && mToken.mSymbol == aStopSymbol) {
+      if (mToken.mType == eCSSToken_Symbol && aInAtRule &&
+          (mToken.mSymbol == '{' || mToken.mSymbol == ';')) {
         UngetToken();
         hitStop = PR_TRUE;
       }
     }
     if (parsedSomething) {
       aMedia->SetNonEmpty();
     }
     if (query) {
@@ -1879,17 +1884,17 @@ CSSParserImpl::ParseImportRule(RuleAppen
 
   nsAutoString url;
   if (!GatherURL(url)) {
     REPORT_UNEXPECTED_TOKEN(PEImportNotURI);
     return PR_FALSE;
   }
 
   if (!ExpectSymbol(';', PR_TRUE)) {
-    if (!GatherMedia(media, ';') ||
+    if (!GatherMedia(media, PR_TRUE) ||
         !ExpectSymbol(';', PR_TRUE)) {
       REPORT_UNEXPECTED_TOKEN(PEImportUnexpected);
       // don't advance section, simply ignore invalid @import
       return PR_FALSE;
     }
 
     // Safe to assert this, since we ensured that there is something
     // other than the ';' coming after the @import's url() token.
@@ -1988,17 +1993,17 @@ PRBool
 CSSParserImpl::ParseMediaRule(RuleAppendFunc aAppendFunc, void* aData)
 {
   nsRefPtr<nsMediaList> media = new nsMediaList();
   if (!media) {
     mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     return PR_FALSE;
   }
 
-  if (GatherMedia(media, '{')) {
+  if (GatherMedia(media, PR_TRUE)) {
     // XXXbz this could use better error reporting throughout the method
     nsRefPtr<nsCSSMediaRule> rule(new nsCSSMediaRule());
     // Append first, so when we do SetMedia() the rule
     // knows what its stylesheet is.
     if (rule && ParseGroupRule(rule, aAppendFunc, aData)) {
       rule->SetMedia(media);
       return PR_TRUE;
     }
