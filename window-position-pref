From: L. David Baron <dbaron@dbaron.org>

Add preference to GTK2 widget code to report window position as 0,0, to debug how much of a performance problem the window position is when nytimes.com tabs are open.

diff --git a/modules/libpref/init/all.js b/modules/libpref/init/all.js
--- a/modules/libpref/init/all.js
+++ b/modules/libpref/init/all.js
@@ -4825,16 +4825,20 @@ pref("dom.vr.add-test-devices", 0);
 // poses to callers of the WebVR API.  This currently only has an effect for
 // Oculus Rift on SDK 0.8 or greater.  It is disabled by default for now due to
 // frame uniformity issues with e10s.
 pref("dom.vr.poseprediction.enabled", false);
 // true = show the VR textures in our compositing output; false = don't.
 // true might have performance impact
 pref("gfx.vr.mirror-textures", false);
 
+// Pref to debug how much of a performance problem getting the window
+// position is.
+pref("widget.gtk2.ignore-window-position", false);
+
 // MMS UA Profile settings
 pref("wap.UAProf.url", "");
 pref("wap.UAProf.tagname", "x-wap-profile");
 
 // MMS version 1.1 = 0x11 (or decimal 17)
 // MMS version 1.3 = 0x13 (or decimal 19)
 // @see OMA-TS-MMS_ENC-V1_3-20110913-A clause 7.3.34
 pref("dom.mms.version", 19);
diff --git a/widget/gtk/nsWindow.cpp b/widget/gtk/nsWindow.cpp
--- a/widget/gtk/nsWindow.cpp
+++ b/widget/gtk/nsWindow.cpp
@@ -346,16 +346,17 @@ private:
 
 static NS_DEFINE_IID(kCDragServiceCID,  NS_DRAGSERVICE_CID);
 
 // The window from which the focus manager asks us to dispatch key events.
 static nsWindow         *gFocusWindow          = nullptr;
 static bool              gBlockActivateEvent   = false;
 static bool              gGlobalsInitialized   = false;
 static bool              gRaiseWindows         = true;
+static bool              gIgnoreWindowPosition = false;
 static nsWindow         *gPluginFocusWindow    = nullptr;
 
 #if GTK_CHECK_VERSION(3,4,0)
 static uint32_t          gLastTouchID = 0;
 #endif
 
 #define NS_WINDOW_TITLE_MAX_LENGTH 4095
 
@@ -1484,20 +1485,24 @@ nsWindow::SetFocus(bool aRaise)
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::GetScreenBounds(LayoutDeviceIntRect& aRect)
 {
     if (mIsTopLevel && mContainer) {
+        if (gIgnoreWindowPosition) {
+            aRect.MoveTo(0, 0);
+        } else {
         // use the point including window decorations
         gint x, y;
         gdk_window_get_root_origin(gtk_widget_get_window(GTK_WIDGET(mContainer)), &x, &y);
         aRect.MoveTo(GdkPointToDevicePixels({ x, y }));
+        }
     } else {
         aRect.MoveTo(WidgetToScreenOffset());
     }
     // mBounds.Size() is the window bounds, not the window-manager frame
     // bounds (bug 581863).  gdk_window_get_frame_extents would give the
     // frame bounds, but mBounds.Size() is returned here for consistency
     // with Resize.
     aRect.SizeTo(mBounds.Size());
@@ -6203,16 +6208,19 @@ drag_data_received_event_cb(GtkWidget *a
 }
 
 static nsresult
 initialize_prefs(void)
 {
     gRaiseWindows =
         Preferences::GetBool("mozilla.widget.raise-on-setfocus", true);
 
+    Preferences::AddBoolVarCache(&gIgnoreWindowPosition,
+                                 "widget.gtk2.ignore-window-position");
+
     return NS_OK;
 }
 
 static GdkWindow *
 get_inner_gdk_window (GdkWindow *aWindow,
                       gint x, gint y,
                       gint *retx, gint *rety)
 {
