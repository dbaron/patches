From: L. David Baron <dbaron@dbaron.org>

Bug 828312 patch 11:  Don't generate change hints for restyling of later continuations, since the handling of the change hints from the first continuation is required to do the necessary work.

diff --git a/layout/base/nsFrameManager.cpp b/layout/base/nsFrameManager.cpp
--- a/layout/base/nsFrameManager.cpp
+++ b/layout/base/nsFrameManager.cpp
@@ -859,24 +859,26 @@ nsFrameManager::ReparentStyleContext(nsI
         if (!copyFromContinuation) {
           TryStartingTransition(GetPresContext(), aFrame->GetContent(),
                                 oldContext, &newContext);
         }
 #endif
 
         // Make sure to call CalcStyleDifference so that the new context ends
         // up resolving all the structs the old context resolved.
-        DebugOnly<nsChangeHint> styleChange =
-          oldContext->CalcStyleDifference(newContext, nsChangeHint(0));
-        // The style change is always 0 because we have the same rulenode and
-        // CalcStyleDifference optimizes us away.  That's OK, though:
-        // reparenting should never trigger a frame reconstruct, and whenever
-        // it's happening we already plan to reflow and repaint the frames.
-        NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
-                     "Our frame tree is likely to be bogus!");
+        if (!copyFromContinuation) {
+          DebugOnly<nsChangeHint> styleChange =
+            oldContext->CalcStyleDifference(newContext, nsChangeHint(0));
+          // The style change is always 0 because we have the same rulenode and
+          // CalcStyleDifference optimizes us away.  That's OK, though:
+          // reparenting should never trigger a frame reconstruct, and whenever
+          // it's happening we already plan to reflow and repaint the frames.
+          NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
+                       "Our frame tree is likely to be bogus!");
+        }
         
         aFrame->SetStyleContext(newContext);
 
         nsIFrame::ChildListIterator lists(aFrame);
         for (; !lists.IsDone(); lists.Next()) {
           nsFrameList::Enumerator childFrames(lists.CurrentList());
           for (; !childFrames.AtEnd(); childFrames.Next()) {
             nsIFrame* child = childFrames.get();
@@ -923,17 +925,17 @@ nsFrameManager::ReparentStyleContext(nsI
             newExtraContext = mStyleSet->ReparentStyleContext(oldExtraContext,
                                                               newContext,
                                                               nullptr);
             if (newExtraContext) {
               if (newExtraContext != oldExtraContext) {
                 // Make sure to call CalcStyleDifference so that the new
                 // context ends up resolving all the structs the old context
                 // resolved.
-                styleChange =
+                DebugOnly<nsChangeHint> styleChange =
                   oldExtraContext->CalcStyleDifference(newExtraContext,
                                                        nsChangeHint(0));
                 // The style change is always 0 because we have the same
                 // rulenode and CalcStyleDifference optimizes us away.  That's
                 // OK, though: reparenting should never trigger a frame
                 // reconstruct, and whenever it's happening we already plan to
                 // reflow and repaint the frames.
                 NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
@@ -1274,23 +1276,30 @@ nsFrameManager::ReResolveStyleContext(ns
           newContext = oldContext;
         }
       }
 
       if (newContext != oldContext) {
         if (!copyFromContinuation) {
           TryStartingTransition(aPresContext, aFrame->GetContent(),
                                 oldContext, &newContext);
+
+          CaptureChange(oldContext, newContext, aFrame, content, aChangeList,
+                        aMinChange, aParentFrameHintsNotHandledForDescendants,
+                        nonInheritedHints, assumeDifferenceHint);
         }
 
-        CaptureChange(oldContext, newContext, aFrame, content, aChangeList,
-                      aMinChange, aParentFrameHintsNotHandledForDescendants,
-                      nonInheritedHints, assumeDifferenceHint);
         if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
-          // if frame gets regenerated, let it keep old context
+          // If the frame gets regenerated, let it keep its old context,
+          // which is important to maintain various invariants about
+          // frame types matching their style contexts.
+          // Note that this check even makes sense if we didn't call
+          // CaptureChange because of copyFromContinuation being true,
+          // since we'll have copied the existing context from the
+          // previous continuation, so newContext == oldContext.
           aFrame->SetStyleContext(newContext);
         }
       }
       oldContext->Release();
     }
     else {
       NS_ERROR("resolve style context failed");
       newContext = oldContext;  // new context failed, recover...
