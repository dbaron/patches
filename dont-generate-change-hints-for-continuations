From: L. David Baron <dbaron@dbaron.org>

Bug 828312 patch 11:  Don't generate change hints for restyling of later continuations, since the handling of the change hints from the first continuation is required to do the necessary work.

TODO: causes:
TEST-UNEXPECTED-FAIL | chrome://mochitests/content/chrome/dom/tests/mochitest/chrome/test_focused_link_scroll.xul | Assertion count 1 is greater than expected range 0-0 assertions.
###!!! ASSERTION: Shouldn't be trying to restyle non-elements directly: '!aContent || aContent->IsElement()', file ../../../layout/base/nsStyleChangeList.cpp, line 65

(See historical patch reresolve-from-prev-continuation and comments in bug for why.)

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1859,24 +1859,26 @@ RestyleManager::ReparentStyleContext(nsI
       if (!copyFromContinuation) {
         TryStartingTransition(mPresContext, aFrame->GetContent(),
                               oldContext, &newContext);
       }
 #endif
 
       // Make sure to call CalcStyleDifference so that the new context ends
       // up resolving all the structs the old context resolved.
-      DebugOnly<nsChangeHint> styleChange =
-        oldContext->CalcStyleDifference(newContext, nsChangeHint(0));
-      // The style change is always 0 because we have the same rulenode and
-      // CalcStyleDifference optimizes us away.  That's OK, though:
-      // reparenting should never trigger a frame reconstruct, and whenever
-      // it's happening we already plan to reflow and repaint the frames.
-      NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
-                   "Our frame tree is likely to be bogus!");
+      if (!copyFromContinuation) {
+        DebugOnly<nsChangeHint> styleChange =
+          oldContext->CalcStyleDifference(newContext, nsChangeHint(0));
+        // The style change is always 0 because we have the same rulenode and
+        // CalcStyleDifference optimizes us away.  That's OK, though:
+        // reparenting should never trigger a frame reconstruct, and whenever
+        // it's happening we already plan to reflow and repaint the frames.
+        NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
+                     "Our frame tree is likely to be bogus!");
+      }
 
       aFrame->SetStyleContext(newContext);
 
       nsIFrame::ChildListIterator lists(aFrame);
       for (; !lists.IsDone(); lists.Next()) {
         nsFrameList::Enumerator childFrames(lists.CurrentList());
         for (; !childFrames.AtEnd(); childFrames.Next()) {
           nsIFrame* child = childFrames.get();
@@ -1922,17 +1924,17 @@ RestyleManager::ReparentStyleContext(nsI
         newExtraContext = mPresContext->StyleSet()->
                             ReparentStyleContext(oldExtraContext,
                                                  newContext, nullptr);
         if (newExtraContext) {
           if (newExtraContext != oldExtraContext) {
             // Make sure to call CalcStyleDifference so that the new
             // context ends up resolving all the structs the old context
             // resolved.
-            styleChange =
+            DebugOnly<nsChangeHint> styleChange =
               oldExtraContext->CalcStyleDifference(newExtraContext,
                                                    nsChangeHint(0));
             // The style change is always 0 because we have the same
             // rulenode and CalcStyleDifference optimizes us away.  That's
             // OK, though: reparenting should never trigger a frame
             // reconstruct, and whenever it's happening we already plan to
             // reflow and repaint the frames.
             NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
@@ -2333,21 +2335,28 @@ ElementRestyler::RestyleSelf(nsRestyleHi
       newContext = oldContext;
     }
   }
 
   if (newContext != oldContext) {
     if (!copyFromContinuation) {
       TryStartingTransition(mPresContext, mFrame->GetContent(),
                             oldContext, &newContext);
+
+      CaptureChange(oldContext, newContext, assumeDifferenceHint);
     }
 
-    CaptureChange(oldContext, newContext, assumeDifferenceHint);
     if (!(mHintsHandled & nsChangeHint_ReconstructFrame)) {
-      // if frame gets regenerated, let it keep old context
+      // If the frame gets regenerated, let it keep its old context,
+      // which is important to maintain various invariants about
+      // frame types matching their style contexts.
+      // Note that this check even makes sense if we didn't call
+      // CaptureChange because of copyFromContinuation being true,
+      // since we'll have copied the existing context from the
+      // previous continuation, so newContext == oldContext.
       mFrame->SetStyleContext(newContext);
     }
   }
   oldContext = nullptr;
 
   // do additional contexts
   // XXXbz might be able to avoid selector matching here in some
   // cases; won't worry about it for now.
