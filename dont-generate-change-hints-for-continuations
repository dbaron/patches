From: L. David Baron <dbaron@dbaron.org>

Bug 828312 patch 11:  Don't generate change hints for restyling of later continuations, since the handling of the change hints from the first continuation is required to do the necessary work.  r=bzbarsky

This depends on bug 898333 in order to avoid causing:
TEST-UNEXPECTED-FAIL | chrome://mochitests/content/chrome/dom/tests/mochitest/chrome/test_focused_link_scroll.xul | Assertion count 1 is greater than expected range 0-0 assertions.
due to the assertion:
###!!! ASSERTION: Shouldn't be trying to restyle non-elements directly: '!aContent || aContent->IsElement()', file ../../../layout/base/nsStyleChangeList.cpp, line 62

The assertion count change in layout/generic/crashtests/571995.xhtml is
expected because it changes us from having 7 of:
###!!! ASSERTION: Shouldn't be trying to restyle non-elements directly: '!aContent || aContent->IsElement()', file ../../../layout/base/nsStyleChangeList.cpp, line 62
with the stack:
  mozilla::ElementRestyler::CaptureChange(nsStyleContext*, nsStyleContext*, nsChangeHint) [layout/base/nsChangeHint.h:191]
  mozilla::ElementRestyler::RestyleSelf(nsRestyleHint) [layout/base/RestyleManager.cpp:2304]
to only having one.  This is expected since this patch changes
RestyleSelf to only call CaptureChange for the first continuation or
block-in-inline sibling.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1913,24 +1913,26 @@ RestyleManager::ReparentStyleContext(nsI
       if (!copyFromContinuation) {
         TryStartingTransition(mPresContext, aFrame->GetContent(),
                               oldContext, &newContext);
       }
 #endif
 
       // Make sure to call CalcStyleDifference so that the new context ends
       // up resolving all the structs the old context resolved.
-      DebugOnly<nsChangeHint> styleChange =
-        oldContext->CalcStyleDifference(newContext, nsChangeHint(0));
-      // The style change is always 0 because we have the same rulenode and
-      // CalcStyleDifference optimizes us away.  That's OK, though:
-      // reparenting should never trigger a frame reconstruct, and whenever
-      // it's happening we already plan to reflow and repaint the frames.
-      NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
-                   "Our frame tree is likely to be bogus!");
+      if (!copyFromContinuation) {
+        DebugOnly<nsChangeHint> styleChange =
+          oldContext->CalcStyleDifference(newContext, nsChangeHint(0));
+        // The style change is always 0 because we have the same rulenode and
+        // CalcStyleDifference optimizes us away.  That's OK, though:
+        // reparenting should never trigger a frame reconstruct, and whenever
+        // it's happening we already plan to reflow and repaint the frames.
+        NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
+                     "Our frame tree is likely to be bogus!");
+      }
 
       aFrame->SetStyleContext(newContext);
 
       nsIFrame::ChildListIterator lists(aFrame);
       for (; !lists.IsDone(); lists.Next()) {
         nsFrameList::Enumerator childFrames(lists.CurrentList());
         for (; !childFrames.AtEnd(); childFrames.Next()) {
           nsIFrame* child = childFrames.get();
@@ -1976,17 +1978,17 @@ RestyleManager::ReparentStyleContext(nsI
         newExtraContext = mPresContext->StyleSet()->
                             ReparentStyleContext(oldExtraContext,
                                                  newContext, nullptr);
         if (newExtraContext) {
           if (newExtraContext != oldExtraContext) {
             // Make sure to call CalcStyleDifference so that the new
             // context ends up resolving all the structs the old context
             // resolved.
-            styleChange =
+            DebugOnly<nsChangeHint> styleChange =
               oldExtraContext->CalcStyleDifference(newExtraContext,
                                                    nsChangeHint(0));
             // The style change is always 0 because we have the same
             // rulenode and CalcStyleDifference optimizes us away.  That's
             // OK, though: reparenting should never trigger a frame
             // reconstruct, and whenever it's happening we already plan to
             // reflow and repaint the frames.
             NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
@@ -2102,17 +2104,16 @@ ElementRestyler::ElementRestyler(ParentC
   , mVisibleKidsOfHiddenElement(aParentRestyler.mVisibleKidsOfHiddenElement)
 #endif
 {
 }
 
 void
 ElementRestyler::CaptureChange(nsStyleContext* aOldContext,
                                nsStyleContext* aNewContext,
-                               nsIFrame* aContinuation, // TEMPORARY
                                nsChangeHint aChangeToAssume)
 {
   // Check some invariants about replacing one style context with another.
   NS_ASSERTION(aOldContext->GetPseudo() == aNewContext->GetPseudo(),
                "old and new style contexts should have the same pseudo");
   NS_ASSERTION(aOldContext->GetPseudoType() == aNewContext->GetPseudoType(),
                "old and new style contexts should have the same pseudo");
 
@@ -2128,17 +2129,17 @@ ElementRestyler::CaptureChange(nsStyleCo
   if ((ourChange & nsChangeHint_UpdateEffects) &&
       mContent && !mContent->IsElement()) {
     ourChange = NS_SubtractHint(ourChange, nsChangeHint_UpdateEffects);
   }
 
   NS_UpdateHint(ourChange, aChangeToAssume);
   if (NS_UpdateHint(mHintsHandled, ourChange)) {
     if (!(ourChange & nsChangeHint_ReconstructFrame) || mContent) {
-      mChangeList->AppendChange(aContinuation, mContent, ourChange);
+      mChangeList->AppendChange(mFrame, mContent, ourChange);
     }
   }
   NS_UpdateHint(mHintsNotHandledForDescendants,
                 NS_HintsNotHandledForDescendantsIn(ourChange));
 }
 
 /**
  * Recompute style for mFrame (which should not have a prev continuation
@@ -2186,25 +2187,19 @@ ElementRestyler::Restyle(nsRestyleHint a
   if (childRestyleHint == eRestyle_Self) {
     childRestyleHint = nsRestyleHint(0);
   }
 
   {
     nsRefPtr<nsStyleContext> oldContext = mFrame->StyleContext();
 
     // TEMPORARY:  Call RestyleSelf multiple times for each frame.
-    nsChangeHint hintsHandled = mHintsHandled;
 
     for (nsIFrame* f = mFrame; f;
          f = GetNextContinuationWithSameStyle(f, oldContext)) {
-      // restore for each continuation, since we need the change hint
-      // posted for each continuation and failing to restore would
-      // suppress that.
-      mHintsHandled = hintsHandled;
-
       RestyleSelf(f, aRestyleHint);
     }
   }
 
   RestyleChildren(childRestyleHint);
 }
 
 void
@@ -2369,21 +2364,28 @@ ElementRestyler::RestyleSelf(nsIFrame* a
       newContext = oldContext;
     }
   }
 
   if (newContext != oldContext) {
     if (!copyFromContinuation) {
       TryStartingTransition(mPresContext, aSelf->GetContent(),
                             oldContext, &newContext);
+
+      CaptureChange(oldContext, newContext, assumeDifferenceHint);
     }
 
-    CaptureChange(oldContext, newContext, aSelf, assumeDifferenceHint);
     if (!(mHintsHandled & nsChangeHint_ReconstructFrame)) {
-      // if frame gets regenerated, let it keep old context
+      // If the frame gets regenerated, let it keep its old context,
+      // which is important to maintain various invariants about
+      // frame types matching their style contexts.
+      // Note that this check even makes sense if we didn't call
+      // CaptureChange because of copyFromContinuation being true,
+      // since we'll have copied the existing context from the
+      // previous continuation, so newContext == oldContext.
       aSelf->SetStyleContext(newContext);
     }
   }
   oldContext = nullptr;
 
   // do additional contexts
   // XXXbz might be able to avoid selector matching here in some
   // cases; won't worry about it for now.
@@ -2411,18 +2413,17 @@ ElementRestyler::RestyleSelf(nsIFrame* a
       newExtraContext = styleSet->ResolvePseudoElementStyle(mContent->AsElement(),
                                                             extraPseudoType,
                                                             newContext);
     }
 
     MOZ_ASSERT(newExtraContext);
 
     if (oldExtraContext != newExtraContext) {
-      CaptureChange(oldExtraContext, newExtraContext, aSelf,
-                    assumeDifferenceHint);
+      CaptureChange(oldExtraContext, newExtraContext, assumeDifferenceHint);
       if (!(mHintsHandled & nsChangeHint_ReconstructFrame)) {
         aSelf->SetAdditionalStyleContext(contextIndex, newExtraContext);
       }
     }
   }
 }
 
 void
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -331,17 +331,16 @@ private:
    */
   void RestyleChildren(nsRestyleHint aChildRestyleHint);
 
   /**
    * Helper for RestyleSelf().
    */
   void CaptureChange(nsStyleContext* aOldContext,
                      nsStyleContext* aNewContext,
-                     nsIFrame* aContinuation, // TEMPORARY
                      nsChangeHint aChangeToAssume);
 
   /**
    * Helpers for RestyleChildren().
    */
   void RestyleUndisplayedChildren(nsRestyleHint aChildRestyleHint);
   void RestyleBeforePseudo();
   void RestyleAfterPseudo(nsIFrame* aFrame);
diff --git a/layout/generic/crashtests/crashtests.list b/layout/generic/crashtests/crashtests.list
--- a/layout/generic/crashtests/crashtests.list
+++ b/layout/generic/crashtests/crashtests.list
@@ -384,17 +384,17 @@ load 547843-1.xhtml
 load 551635-1.html
 asserts(3) load 553504-1.xhtml # nscoord_MAX assertions (bug 575011)
 load 564368-1.xhtml
 load 564968.xhtml
 load 570160.html
 load 570289-1.html
 load 571618-1.svg
 asserts(1) load 571975-1.html # bug 574889
-asserts(7) load 571995.xhtml # 761848
+asserts(1) load 571995.xhtml # 761848
 load 574958.xhtml
 asserts(0-4) load 578977.html # bug 757305
 load 580504-1.xhtml
 load 585598-1.xhtml
 asserts(0-11) load 586806-1.html # Bug 439258
 load 586806-2.html
 load 586806-3.html
 load 586973-1.html
