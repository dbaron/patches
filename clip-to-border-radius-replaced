From: L. David Baron <dbaron@dbaron.org>

Clip replaced elements (for now, images, canvases, videos, and windowless plugins) to the border radius.  (Bug 485501)

diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -1771,16 +1771,48 @@ nsIFrame::BuildDisplayListForChild(nsDis
   // because in the absence of z-index this is the correct order for them.
   // This doesn't affect correctness because the positioned descendants list
   // is sorted by z-order and content in BuildDisplayListForStackingContext,
   // but it means that sort routine needs to do less work.
   aLists.PositionedDescendants()->AppendToTop(&extraPositionedDescendants);
   return NS_OK;
 }
 
+nsresult
+nsIFrame::DisplayReplacedContentInBorderRadius(nsDisplayListBuilder* aBuilder,
+                                               const nsRect& aDirtyRect,
+                                               const nsDisplayListSet& aLists)
+{
+  nscoord radii[8];
+  if (GetContentBoxBorderRadii(radii)) {
+    // If we have a border-radius, we have to clip our content to that
+    // radius.
+    nsDisplayListCollection set;
+    nsresult rv = BuildReplacedContentDisplayList(aBuilder, aDirtyRect, set);
+    nsRect clipRect = GetContentRect() - GetPosition() +
+                      aBuilder->ToReferenceFrame(this);
+    OverflowClip(aBuilder, set, aLists, clipRect, radii, PR_FALSE, PR_TRUE);
+
+    return rv;
+  }
+
+  return BuildReplacedContentDisplayList(aBuilder, aDirtyRect, aLists);
+}
+
+/* virtual */ nsresult
+nsIFrame::BuildReplacedContentDisplayList(nsDisplayListBuilder* aBuilder,
+                                          const nsRect& aDirtyRect,
+                                          const nsDisplayListSet& aLists)
+{
+  NS_ABORT_IF_FALSE(PR_FALSE,
+                    "subclasses using DisplayReplacedContentInBorderRadius "
+                    "must override BuildReplacedContentDisplayList");
+  return NS_ERROR_UNEXPECTED;
+}
+
 NS_IMETHODIMP  
 nsFrame::GetContentForEvent(nsPresContext* aPresContext,
                             nsEvent* aEvent,
                             nsIContent** aContent)
 {
   nsIFrame* f = nsLayoutUtils::GetNonGeneratedAncestor(this);
   *aContent = f->GetContent();
   NS_IF_ADDREF(*aContent);
diff --git a/layout/generic/nsHTMLCanvasFrame.cpp b/layout/generic/nsHTMLCanvasFrame.cpp
--- a/layout/generic/nsHTMLCanvasFrame.cpp
+++ b/layout/generic/nsHTMLCanvasFrame.cpp
@@ -278,17 +278,26 @@ nsHTMLCanvasFrame::BuildDisplayList(nsDi
                                     const nsDisplayListSet& aLists)
 {
   if (!IsVisibleForPainting(aBuilder))
     return NS_OK;
 
   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  rv = aLists.Content()->AppendNewToTop(
+  return DisplayReplacedContentInBorderRadius(aBuilder, aDirtyRect, aLists);
+}
+
+/* virtual */ nsresult
+nsHTMLCanvasFrame::BuildReplacedContentDisplayList(
+                     nsDisplayListBuilder* aBuilder,
+                     const nsRect& aDirtyRect,
+                     const nsDisplayListSet& aLists)
+{
+  nsresult rv = aLists.Content()->AppendNewToTop(
       new (aBuilder) nsDisplayCanvas(aBuilder, this));
   NS_ENSURE_SUCCESS(rv, rv);
 
   return DisplaySelectionOverlay(aBuilder, aLists.Content(),
                                  nsISelectionDisplay::DISPLAY_IMAGES);
 }
 
 nsIAtom*
diff --git a/layout/generic/nsHTMLCanvasFrame.h b/layout/generic/nsHTMLCanvasFrame.h
--- a/layout/generic/nsHTMLCanvasFrame.h
+++ b/layout/generic/nsHTMLCanvasFrame.h
@@ -60,16 +60,20 @@ public:
 
   NS_DECL_FRAMEARENA_HELPERS
 
   nsHTMLCanvasFrame(nsStyleContext* aContext) : nsSplittableFrame(aContext) {}
 
   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists);
+  virtual nsresult
+  BuildReplacedContentDisplayList(nsDisplayListBuilder* aBuilder,
+                                  const nsRect& aDirtyRect,
+                                  const nsDisplayListSet& aLists);
 
   already_AddRefed<Layer> BuildLayer(nsDisplayListBuilder* aBuilder,
                                      LayerManager* aManager,
                                      nsDisplayItem* aItem);
 
   /* get the size of the canvas's image */
   nsIntSize GetCanvasSize();
 
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -1124,16 +1124,34 @@ public:
    */
   nsresult BuildDisplayListForChild(nsDisplayListBuilder*   aBuilder,
                                     nsIFrame*               aChild,
                                     const nsRect&           aDirtyRect,
                                     const nsDisplayListSet& aLists,
                                     PRUint32                aFlags = 0);
 
   /**
+   * A helper for replaced elements that want to clip their content to a
+   * border radius, but only need clipping at all when they have a
+   * border radius.
+   */
+  nsresult DisplayReplacedContentInBorderRadius(nsDisplayListBuilder* aBuilder,
+                                                const nsRect& aDirtyRect,
+                                                const nsDisplayListSet& aLists);
+
+  /**
+   * A helper to be implemented for classes using
+   * DisplayReplacedContentInBorderRadius.
+   */
+  virtual nsresult
+  BuildReplacedContentDisplayList(nsDisplayListBuilder* aBuilder,
+                                  const nsRect& aDirtyRect,
+                                  const nsDisplayListSet& aLists);
+
+  /**
    * Does this frame need a view?
    */
   virtual PRBool NeedsView() { return PR_FALSE; }
 
   /**
    * Returns whether this frame has a transform matrix applied to it.  This is true
    * if we have the -moz-transform property or if we're an SVGForeignObjectFrame.
    */
diff --git a/layout/generic/nsImageFrame.cpp b/layout/generic/nsImageFrame.cpp
--- a/layout/generic/nsImageFrame.cpp
+++ b/layout/generic/nsImageFrame.cpp
@@ -1192,20 +1192,30 @@ nsImageFrame::BuildDisplayList(nsDisplay
     return NS_OK;
 
   // REVIEW: We don't need any special logic here for deciding which layer
   // to put the background in ... it goes in aLists.BorderBackground() and
   // then if we have a block parent, it will put our background in the right
   // place.
   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
   NS_ENSURE_SUCCESS(rv, rv);
+
+  return DisplayReplacedContentInBorderRadius(aBuilder, aDirtyRect, aLists);
+}
+
+/* virtual */ nsresult
+nsImageFrame::BuildReplacedContentDisplayList(nsDisplayListBuilder* aBuilder,
+                                              const nsRect& aDirtyRect,
+                                              const nsDisplayListSet& aLists)
+{
+  nsresult rv;
   // REVIEW: Checking mRect.IsEmpty() makes no sense to me, so I removed it.
   // It can't have been protecting us against bad situations with zero-size
   // images since adding a border would make the rect non-empty.
-    
+
   if (mComputedSize.width != 0 && mComputedSize.height != 0) {
     nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
     NS_ASSERTION(imageLoader, "Not an image loading content?");
 
     nsCOMPtr<imgIRequest> currentRequest;
     if (imageLoader) {
       imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
                               getter_AddRefs(currentRequest));
diff --git a/layout/generic/nsImageFrame.h b/layout/generic/nsImageFrame.h
--- a/layout/generic/nsImageFrame.h
+++ b/layout/generic/nsImageFrame.h
@@ -103,16 +103,20 @@ public:
 
   virtual void DestroyFrom(nsIFrame* aDestructRoot);
   NS_IMETHOD Init(nsIContent*      aContent,
                   nsIFrame*        aParent,
                   nsIFrame*        aPrevInFlow);
   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists);
+  virtual nsresult
+  BuildReplacedContentDisplayList(nsDisplayListBuilder* aBuilder,
+                                  const nsRect& aDirtyRect,
+                                  const nsDisplayListSet& aLists);
   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);
   virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);
   virtual nsSize GetIntrinsicRatio();
   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
                     nsHTMLReflowMetrics&     aDesiredSize,
                     const nsHTMLReflowState& aReflowState,
                     nsReflowStatus&          aStatus);
   
diff --git a/layout/generic/nsObjectFrame.cpp b/layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp
+++ b/layout/generic/nsObjectFrame.cpp
@@ -1320,34 +1320,40 @@ nsObjectFrame::BuildDisplayList(nsDispla
                                 const nsDisplayListSet& aLists)
 {
   // XXX why are we painting collapsed object frames?
   if (!IsVisibleOrCollapsedForPainting(aBuilder))
     return NS_OK;
     
   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
   NS_ENSURE_SUCCESS(rv, rv);
-  
-  nsPresContext::nsPresContextType type = PresContext()->Type();
 
   // If we are painting in Print Preview do nothing....
-  if (type == nsPresContext::eContext_PrintPreview)
+  if (PresContext()->Type() == nsPresContext::eContext_PrintPreview)
     return NS_OK;
 
   DO_GLOBAL_REFLOW_COUNT_DSP("nsObjectFrame");
 
 #ifndef XP_MACOSX
   if (mWidget && aBuilder->IsInTransform()) {
     // Windowed plugins should not be rendered inside a transform.
     return NS_OK;
   }
 #endif
 
+  return DisplayReplacedContentInBorderRadius(aBuilder, aDirtyRect, aLists);
+}
+
+/* virtual */ nsresult
+nsObjectFrame::BuildReplacedContentDisplayList(nsDisplayListBuilder* aBuilder,
+                                               const nsRect& aDirtyRect,
+                                               const nsDisplayListSet& aLists)
+{
   // determine if we are printing
-  if (type == nsPresContext::eContext_Print)
+  if (PresContext()->Type() == nsPresContext::eContext_Print)
     return aLists.Content()->AppendNewToTop(new (aBuilder)
         nsDisplayGeneric(aBuilder, this, PaintPrintPlugin, "PrintPlugin",
                          nsDisplayItem::TYPE_PRINT_PLUGIN));
 
   return aLists.Content()->AppendNewToTop(new (aBuilder)
       nsDisplayPlugin(aBuilder, this));
 }
 
diff --git a/layout/generic/nsObjectFrame.h b/layout/generic/nsObjectFrame.h
--- a/layout/generic/nsObjectFrame.h
+++ b/layout/generic/nsObjectFrame.h
@@ -80,16 +80,20 @@ public:
                     const nsHTMLReflowState& aReflowState,
                     nsReflowStatus& aStatus);
   NS_IMETHOD DidReflow(nsPresContext* aPresContext,
                        const nsHTMLReflowState* aReflowState,
                        nsDidReflowStatus aStatus);
   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists);
+  virtual nsresult
+  BuildReplacedContentDisplayList(nsDisplayListBuilder* aBuilder,
+                                  const nsRect& aDirtyRect,
+                                  const nsDisplayListSet& aLists);
 
   NS_IMETHOD  HandleEvent(nsPresContext* aPresContext,
                           nsGUIEvent* aEvent,
                           nsEventStatus* aEventStatus);
 
 #ifdef XP_MACOSX
   NS_IMETHOD HandlePress(nsPresContext* aPresContext,
                          nsGUIEvent*    aEvent,
diff --git a/layout/generic/nsVideoFrame.cpp b/layout/generic/nsVideoFrame.cpp
--- a/layout/generic/nsVideoFrame.cpp
+++ b/layout/generic/nsVideoFrame.cpp
@@ -53,16 +53,17 @@
 #include "nsPresContext.h"
 #include "nsTransform2D.h"
 #include "nsContentCreatorFunctions.h"
 #include "nsBoxLayoutState.h"
 #include "nsBoxFrame.h"
 #include "nsImageFrame.h"
 #include "nsIImageLoadingContent.h"
 #include "nsDisplayList.h"
+#include "nsCSSRendering.h"
 
 #ifdef ACCESSIBILITY
 #include "nsIServiceManager.h"
 #include "nsIAccessibilityService.h"
 #endif
 
 using namespace mozilla;
 using namespace mozilla::layers;
@@ -412,16 +413,26 @@ nsVideoFrame::BuildDisplayList(nsDisplay
   if (!IsVisibleForPainting(aBuilder))
     return NS_OK;
 
   DO_GLOBAL_REFLOW_COUNT_DSP("nsVideoFrame");
 
   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  return DisplayReplacedContentInBorderRadius(aBuilder, aDirtyRect, aLists);
+}
+
+/* virtual */ nsresult
+nsVideoFrame::BuildReplacedContentDisplayList(nsDisplayListBuilder* aBuilder,
+                                              const nsRect& aDirtyRect,
+                                              const nsDisplayListSet& aLists)
+{
+  nsresult rv;
+
   if (HasVideoElement() && !ShouldDisplayPoster()) {
     rv = aLists.Content()->AppendNewToTop(
       new (aBuilder) nsDisplayVideo(aBuilder, this));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   // Add child frames to display list. We expect up to two children, an image
   // frame for the poster, and the box frame for the video controls.
diff --git a/layout/generic/nsVideoFrame.h b/layout/generic/nsVideoFrame.h
--- a/layout/generic/nsVideoFrame.h
+++ b/layout/generic/nsVideoFrame.h
@@ -65,16 +65,20 @@ public:
   nsVideoFrame(nsStyleContext* aContext);
 
   NS_DECL_QUERYFRAME
   NS_DECL_FRAMEARENA_HELPERS
 
   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists);
+  virtual nsresult
+  BuildReplacedContentDisplayList(nsDisplayListBuilder* aBuilder,
+                                  const nsRect& aDirtyRect,
+                                  const nsDisplayListSet& aLists);
 
   NS_IMETHOD AttributeChanged(PRInt32 aNameSpaceID,
                               nsIAtom* aAttribute,
                               PRInt32 aModType);
 
   /* get the size of the video's display */
   nsSize GetVideoIntrinsicSize(nsIRenderingContext *aRenderingContext);
   virtual nsSize GetIntrinsicRatio();
