From: L. David Baron <dbaron@dbaron.org>

Clip replaced elements (for now, images, canvases, videos, and windowless plugins) to the border radius.  (Bug 485501)  (TODO: Does this still work for video given the layers changes?)  (FIXME: Doesn't work for canvas anymore post layers changes)

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -3854,8 +3854,56 @@ nsContextBoxBlur::DoPaint()
 }
 
 gfxContext*
 nsContextBoxBlur::GetContext()
 {
   return mContext;
 }
 
+nsAutoClipToBorderRadius::nsAutoClipToBorderRadius(
+                            nsIRenderingContext &aRenderingContext,
+                            nsIFrame *aFrame, nsPoint aOffsetToFrame)
+{
+  // This has some code in common with SetupBackgroundClip and
+  // PaintBackgroundWithSC, but it looks hard to refactor, and this
+  // isn't too bad.
+  const nsStyleBorder *border = aFrame->GetStyleBorder();
+  nscoord radii[8];
+  nsSize frameSize = aFrame->GetSize();
+  PRBool haveRoundedCorners = nsIFrame::ComputeBorderRadius(
+                                border->mBorderRadius, frameSize, frameSize,
+                                aFrame->GetSkipSides(), radii);
+  if (haveRoundedCorners) {
+    PRInt32 appUnitsPerPixel = aFrame->PresContext()->AppUnitsPerDevPixel();
+
+    gfxCornerSizes pixelRadii;
+    ComputePixelRadii(radii, appUnitsPerPixel, &pixelRadii);
+
+    nsMargin bp = aFrame->GetUsedBorderAndPadding();
+    aFrame->ApplySkipSides(bp);
+    gfxFloat bpSizes[4] = {
+      gfxFloat(bp.top / appUnitsPerPixel),
+      gfxFloat(bp.right / appUnitsPerPixel),
+      gfxFloat(bp.bottom / appUnitsPerPixel),
+      gfxFloat(bp.left / appUnitsPerPixel)
+    };
+    nsCSSBorderRenderer::ComputeInnerRadii(pixelRadii, bpSizes, &pixelRadii);
+
+    gfxRect contentArea(RectToGfxRect(aFrame->GetContentRect() -
+                                        aFrame->GetPosition() +
+                                        aOffsetToFrame,
+                                      appUnitsPerPixel));
+    contentArea.Round();
+    contentArea.Condition();
+
+    if (contentArea.IsEmpty()) {
+      // Our caller shouldn't be drawing anything anyway.
+      return;
+    }
+
+    gfxContext *ctx = aRenderingContext.ThebesContext();
+    gfxContextAutoSaveRestore::SetContext(ctx);
+    ctx->NewPath();
+    ctx->RoundedRectangle(contentArea, pixelRadii);
+    ctx->Clip();
+  }
+}
diff --git a/layout/base/nsCSSRendering.h b/layout/base/nsCSSRendering.h
--- a/layout/base/nsCSSRendering.h
+++ b/layout/base/nsCSSRendering.h
@@ -466,9 +466,28 @@ public:
 
 protected:
   gfxAlphaBoxBlur blur;
   nsRefPtr<gfxContext> mContext;
   gfxContext* mDestinationCtx;
   
 };
 
+/**
+ * If the frame has a border radius, save the context state and clip to
+ * the border radius in the constructor, and restore the context state
+ * in the destructor.
+ *
+ * If the frame does NOT have a border-radius, do nothing (no save +
+ * restore).
+ */
+// FIXME: Add NS_NONTEMPORARY_CLASS if that lands first!
+// (And (or maybe only) to the gfxContext* classes too!)
+class NS_STACK_CLASS nsAutoClipToBorderRadius
+                         : public gfxContextAutoSaveRestore
+{
+public:
+  // FIXME: Add MOZILLA_GUARD_OBJECT_* if that lands first!
+  nsAutoClipToBorderRadius(nsIRenderingContext &aRenderingContext,
+                           nsIFrame *aFrame, nsPoint aOffsetToFrame);
+};
+
 #endif /* nsCSSRendering_h___ */
diff --git a/layout/generic/nsImageFrame.cpp b/layout/generic/nsImageFrame.cpp
--- a/layout/generic/nsImageFrame.cpp
+++ b/layout/generic/nsImageFrame.cpp
@@ -1094,16 +1094,17 @@ nsImageFrame::DisplayAltFeedback(nsIRend
 
   aRenderingContext.PopState();
 }
 
 static void PaintAltFeedback(nsIFrame* aFrame, nsIRenderingContext* aCtx,
      const nsRect& aDirtyRect, nsPoint aPt)
 {
   nsImageFrame* f = static_cast<nsImageFrame*>(aFrame);
+  // FIXME: Should we use an nsAutoClipToBorderRadius here?
   f->DisplayAltFeedback(*aCtx,
                         aDirtyRect,
                         IMAGE_OK(f->GetContent()->IntrinsicState(), PR_TRUE)
                            ? nsImageFrame::gIconLoad->mLoadingImage
                            : nsImageFrame::gIconLoad->mBrokenImage,
                         aPt);
 }
 
@@ -1155,16 +1156,18 @@ nsDisplayImage::Paint(nsDisplayListBuild
                  : (PRUint32) imgIContainer::FLAG_NONE);
 }
 
 void
 nsImageFrame::PaintImage(nsIRenderingContext& aRenderingContext, nsPoint aPt,
                          const nsRect& aDirtyRect, imgIContainer* aImage,
                          PRUint32 aFlags)
 {
+  nsAutoClipToBorderRadius brClip(aRenderingContext, this, aPt);
+
   // Render the image into our content area (the area inside
   // the borders and padding)
   NS_ASSERTION(GetInnerArea().width == mComputedSize.width, "bad width");
   nsRect inner = GetInnerArea() + aPt;
   nsRect dest(inner.TopLeft(), mComputedSize);
   dest.y -= GetContinuationOffset();
 
   nsLayoutUtils::DrawSingleImage(&aRenderingContext, aImage,
diff --git a/layout/generic/nsObjectFrame.cpp b/layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp
+++ b/layout/generic/nsObjectFrame.cpp
@@ -130,16 +130,17 @@ enum { XKeyPress = KeyPress };
 #include "nsDataHashtable.h"
 #include "nsDOMClassInfo.h"
 #include "nsFocusManager.h"
 #include "nsLayoutUtils.h"
 #include "nsFrameManager.h"
 #include "nsComponentManagerUtils.h"
 #include "nsIObserverService.h"
 #include "nsIScrollableFrame.h"
+#include "nsCSSRendering.h"
 
 // headers for plugin scriptability
 #include "nsIScriptGlobalObject.h"
 #include "nsIScriptContext.h"
 #include "nsIXPConnect.h"
 #include "nsIXPCScriptable.h"
 #include "nsIClassInfo.h"
 #include "nsIDOMClientRect.h"
@@ -1158,16 +1159,18 @@ nsObjectFrame::DidReflow(nsPresContext* 
 
   return rv;
 }
 
 /* static */ void
 nsObjectFrame::PaintPrintPlugin(nsIFrame* aFrame, nsIRenderingContext* aCtx,
                                 const nsRect& aDirtyRect, nsPoint aPt)
 {
+  nsAutoClipToBorderRadius brClip(*aCtx, aFrame, aPt);
+
   nsPoint pt = aPt + aFrame->GetUsedBorderAndPadding().TopLeft();
   nsIRenderingContext::AutoPushTranslation translate(aCtx, pt.x, pt.y);
   // FIXME - Bug 385435: Doesn't aDirtyRect need translating too?
   static_cast<nsObjectFrame*>(aFrame)->PrintPlugin(*aCtx, aDirtyRect);
 }
 
 nsRect
 nsDisplayPlugin::GetBounds(nsDisplayListBuilder* aBuilder)
@@ -1175,16 +1178,19 @@ nsDisplayPlugin::GetBounds(nsDisplayList
   return mFrame->GetContentRect() - mFrame->GetPosition() +
     ToReferenceFrame();
 }
 
 void
 nsDisplayPlugin::Paint(nsDisplayListBuilder* aBuilder,
                        nsIRenderingContext* aCtx)
 {
+  nsAutoClipToBorderRadius brClip(*aCtx, mFrame,
+                                  aBuilder->ToReferenceFrame(mFrame));
+
   nsObjectFrame* f = static_cast<nsObjectFrame*>(mFrame);
   f->PaintPlugin(*aCtx, mVisibleRect, GetBounds(aBuilder));
 }
 
 PRBool
 nsDisplayPlugin::ComputeVisibility(nsDisplayListBuilder* aBuilder,
                                    nsRegion* aVisibleRegion)
 {
diff --git a/layout/generic/nsVideoFrame.cpp b/layout/generic/nsVideoFrame.cpp
--- a/layout/generic/nsVideoFrame.cpp
+++ b/layout/generic/nsVideoFrame.cpp
@@ -53,16 +53,17 @@
 #include "nsPresContext.h"
 #include "nsTransform2D.h"
 #include "nsContentCreatorFunctions.h"
 #include "nsBoxLayoutState.h"
 #include "nsBoxFrame.h"
 #include "nsImageFrame.h"
 #include "nsIImageLoadingContent.h"
 #include "nsDisplayList.h"
+#include "nsCSSRendering.h"
 
 #ifdef ACCESSIBILITY
 #include "nsIServiceManager.h"
 #include "nsIAccessibilityService.h"
 #endif
 
 using namespace mozilla;
 using namespace mozilla::layers;
@@ -177,16 +178,18 @@ nsVideoFrame::BuildLayer(nsDisplayListBu
                          nsDisplayItem* aItem)
 {
   nsRect area = GetContentRect() - GetPosition() + aItem->ToReferenceFrame();
   nsHTMLVideoElement* element = static_cast<nsHTMLVideoElement*>(GetContent());
   nsIntSize videoSize = element->GetVideoSize(nsIntSize(0, 0));
   if (videoSize.width <= 0 || videoSize.height <= 0 || area.IsEmpty())
     return nsnull;
 
+  //nsAutoClipToBorderRadius brClip(aRenderingContext, this, aPt);
+
   nsRefPtr<ImageContainer> container = element->GetImageContainer();
   // If we have a container with a different layer manager, try to hand
   // off the container to the new one.
   if (container && container->Manager() != aManager) {
     // we don't care about the return type here -- if the set didn't take, it'll
     // be handled when we next check the manager
     container->SetLayerManager(aManager);
   }
