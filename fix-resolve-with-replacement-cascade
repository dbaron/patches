From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Make nsStyleSet::ResolveStyleWithReplacement handle replacing the empty set, make it set IsImportantRule on rule nodes correctly, and merge the bogus ResolveStyleWithRules into it.

diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1238,40 +1238,16 @@ nsStyleSet::ResolveStyleForRules(nsStyle
   }
 
   return GetContext(aParentContext, ruleWalker.CurrentNode(), nullptr,
                     nullptr, nsCSSPseudoElements::ePseudo_NotPseudoElement,
                     nullptr, eNoFlags);
 }
 
 already_AddRefed<nsStyleContext>
-nsStyleSet::ResolveStyleForRules(nsStyleContext* aParentContext,
-                                 nsStyleContext* aOldStyle,
-                                 const nsTArray<RuleAndLevel>& aRules)
-{
-  nsRuleWalker ruleWalker(mRuleTree, mAuthorStyleDisabled);
-  for (int32_t i = aRules.Length() - 1; i >= 0; --i) {
-    ruleWalker.SetLevel(aRules[i].mLevel, false, false);
-    ruleWalker.ForwardOnPossiblyCSSRule(aRules[i].mRule);
-  }
-
-  uint32_t flags = eNoFlags;
-  if (aOldStyle->IsLinkContext()) {
-    flags |= eIsLink;
-  }
-  if (aOldStyle->RelevantLinkVisited()) {
-    flags |= eIsVisitedLink;
-  }
-
-  return GetContext(aParentContext, ruleWalker.CurrentNode(), nullptr,
-                    nullptr, nsCSSPseudoElements::ePseudo_NotPseudoElement,
-                    nullptr, flags);
-}
-
-already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleByAddingRules(nsStyleContext* aBaseContext,
                                       const nsCOMArray<nsIStyleRule> &aRules)
 {
   NS_ENSURE_FALSE(mInShutdown, nullptr);
 
   nsRuleWalker ruleWalker(mRuleTree, mAuthorStyleDisabled);
   ruleWalker.SetCurrentNode(aBaseContext->RuleNode());
   // FIXME: Perhaps this should be passed in, but it probably doesn't
@@ -1300,79 +1276,138 @@ nsStyleSet::ResolveStyleByAddingRules(ns
     flags |= eIsVisitedLink;
   }
   return GetContext(aBaseContext->GetParent(), ruleNode, visitedRuleNode,
                     aBaseContext->GetPseudo(),
                     aBaseContext->GetPseudoType(),
                     nullptr, flags);
 }
 
+struct RuleNodeInfo {
+  nsIStyleRule* mRule;
+  uint8_t mLevel;
+  bool mIsImportant;
+};
+
+struct CascadeLevel {
+  uint8_t mLevel;
+  bool mIsImportant;
+  nsRestyleHint mLevelReplacementHint;
+};
+
+static const CascadeLevel gCascadeLevels[] = {
+  { nsStyleSet::eAgentSheet,      false, nsRestyleHint(0) },
+  { nsStyleSet::eUserSheet,       false, nsRestyleHint(0) },
+  { nsStyleSet::ePresHintSheet,   false, nsRestyleHint(0) },
+  { nsStyleSet::eDocSheet,        false, nsRestyleHint(0) },
+  { nsStyleSet::eScopedDocSheet,  false, nsRestyleHint(0) },
+  { nsStyleSet::eStyleAttrSheet,  false, nsRestyleHint(0) },
+  { nsStyleSet::eOverrideSheet,   false, nsRestyleHint(0) },
+  { nsStyleSet::eAnimationSheet,  false, eRestyle_CSSAnimations },
+  { nsStyleSet::eScopedDocSheet,  true,  nsRestyleHint(0) },
+  { nsStyleSet::eDocSheet,        true,  nsRestyleHint(0) },
+  { nsStyleSet::eStyleAttrSheet,  true,  nsRestyleHint(0) },
+  { nsStyleSet::eOverrideSheet,   true,  nsRestyleHint(0) },
+  { nsStyleSet::eUserSheet,       true,  nsRestyleHint(0) },
+  { nsStyleSet::eAgentSheet,      true,  nsRestyleHint(0) },
+  { nsStyleSet::eTransitionSheet, false, eRestyle_CSSTransitions },
+};
+
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleWithReplacement(Element* aElement,
                                         nsStyleContext* aParentStyleContext,
                                         nsStyleContext* aOldStyleContext,
                                         nsRestyleHint aReplacements)
 {
   MOZ_ASSERT(!(aReplacements & ~(eRestyle_CSSTransitions |
                                  eRestyle_CSSAnimations)),
              "unexpected replacement bits");
 
-  nsRuleNode* ruleNode = aOldStyleContext->RuleNode();
-  nsTArray<nsStyleSet::RuleAndLevel> rules;
-  do {
-    if (ruleNode->IsRoot()) {
-      break;
+  nsTArray<RuleNodeInfo> rules;
+  for (nsRuleNode* ruleNode = aOldStyleContext->RuleNode(); !ruleNode->IsRoot();
+       ruleNode = ruleNode->GetParent()) {
+    RuleNodeInfo* curRule = rules.AppendElement();
+    curRule->mRule = ruleNode->GetRule();
+    curRule->mLevel = ruleNode->GetLevel();
+    curRule->mIsImportant = ruleNode->IsImportantRule();
+  }
+
+  nsRuleWalker ruleWalker(mRuleTree, mAuthorStyleDisabled);
+  auto rulesIndex = rules.Length();
+
+  for (const CascadeLevel *level = gCascadeLevels,
+                       *levelEnd = ArrayEnd(gCascadeLevels);
+       level != levelEnd; ++level) {
+    ruleWalker.SetLevel(level->mLevel, level->mIsImportant, false);
+
+    bool doReplace = level->mLevelReplacementHint & aReplacements;
+    if (doReplace) {
+      switch (level->mLevelReplacementHint) {
+      case eRestyle_CSSAnimations:
+        {
+          nsAnimationManager* animationManager =
+            PresContext()->AnimationManager();
+          ElementAnimations* ea = animationManager->GetElementAnimations(
+            aElement, aOldStyleContext->GetPseudoType(), false);
+          NS_ASSERTION(ea,
+            "Rule has level eAnimationSheet without animation on manager");
+
+          animationManager->EnsureStyleRuleFor(ea);
+          ruleWalker.ForwardOnPossiblyCSSRule(ea->mStyleRule);
+        }
+        break;
+      case eRestyle_CSSTransitions:
+        {
+          nsPresContext* presContext = PresContext();
+          ElementTransitions *et =
+            presContext->TransitionManager()->GetElementTransitions(
+              aElement,
+              aOldStyleContext->GetPseudoType(),
+              false);
+          NS_ASSERTION(et,
+            "Rule has level eTransitionSheet without transition on manager");
+
+          et->EnsureStyleRuleFor(presContext->RefreshDriver()->MostRecentRefresh());
+          ruleWalker.ForwardOnPossiblyCSSRule(et->mStyleRule);
+        }
+        break;
+      default:
+        break;
+      }
     }
 
-    nsStyleSet::RuleAndLevel curRule;
-    curRule.mLevel = ruleNode->GetLevel();
-    curRule.mRule = ruleNode->GetRule();
+    while (rulesIndex != 0) {
+      --rulesIndex;
+      const RuleNodeInfo& ruleInfo = rules[rulesIndex];
 
-    // FIXME: This will eventually need to handle adding a rule where we
-    // don't currently have one!
+      if (ruleInfo.mLevel != level->mLevel ||
+          ruleInfo.mIsImportant != level->mIsImportant) {
+        ++rulesIndex;
+        break;
+      }
 
-    switch (curRule.mLevel) {
-    case nsStyleSet::eAnimationSheet:
-      if (aReplacements & eRestyle_CSSAnimations) {
-        nsAnimationManager* animationManager = PresContext()->AnimationManager();
-        ElementAnimations* ea = animationManager->GetElementAnimations(
-          aElement, aOldStyleContext->GetPseudoType(), false);
-        NS_ASSERTION(ea,
-          "Rule has level eAnimationSheet without animation on manager");
-
-        animationManager->EnsureStyleRuleFor(ea);
-        curRule.mRule = ea->mStyleRule;
+      if (!doReplace) {
+        ruleWalker.ForwardOnPossiblyCSSRule(ruleInfo.mRule);
       }
-      break;
-    case nsStyleSet::eTransitionSheet:
-      if (aReplacements & eRestyle_CSSTransitions) {
-        nsPresContext* presContext = PresContext();
-        ElementTransitions *et =
-          presContext->TransitionManager()->GetElementTransitions(
-            aElement,
-            aOldStyleContext->GetPseudoType(),
-            false);
-        NS_ASSERTION(et,
-          "Rule has level eTransitionSheet without transition on manager");
-
-        et->EnsureStyleRuleFor(presContext->RefreshDriver()->MostRecentRefresh());
-        curRule.mRule = et->mStyleRule;
-      }
-      break;
-    default:
-      break;
     }
-
-    if (curRule.mRule) {
-      rules.AppendElement(curRule);
-    }
-  } while ((ruleNode = ruleNode->GetParent()));
+  }
 
   // FIXME: Does this handle visited contexts correctly???
-  return ResolveStyleForRules(aParentStyleContext, aOldStyleContext, rules);
+
+  uint32_t flags = eNoFlags;
+  if (aOldStyleContext->IsLinkContext()) {
+    flags |= eIsLink;
+  }
+  if (aOldStyleContext->RelevantLinkVisited()) {
+    flags |= eIsVisitedLink;
+  }
+
+  return GetContext(aParentStyleContext, ruleWalker.CurrentNode(), nullptr,
+                    nullptr, nsCSSPseudoElements::ePseudo_NotPseudoElement,
+                    nullptr, flags);
 }
 
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForNonElement(nsStyleContext* aParentContext)
 {
   return GetContext(aParentContext, mRuleTree, nullptr,
                     nsCSSAnonBoxes::mozNonElement,
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -94,31 +94,16 @@ class nsStyleSet
                   TreeMatchContext& aTreeMatchContext);
 
   // Get a style context (with the given parent) for the
   // sequence of style rules in the |aRules| array.
   already_AddRefed<nsStyleContext>
   ResolveStyleForRules(nsStyleContext* aParentContext,
                        const nsTArray< nsCOMPtr<nsIStyleRule> > &aRules);
 
-  // used in ResolveStyleForRules below
-  struct RuleAndLevel
-  {
-    nsIStyleRule* mRule;
-    uint8_t mLevel;
-  };
-
-  // Get a new style context for aElement for the rules in aRules
-  // aRules is an array of rules and their levels in reverse order,
-  // that is from the leaf-most to the root-most rule in the rule tree.
-  already_AddRefed<nsStyleContext>
-  ResolveStyleForRules(nsStyleContext* aParentContext,
-                       nsStyleContext* aOldStyle,
-                       const nsTArray<RuleAndLevel>& aRules);
-
   // Get a style context that represents aBaseContext, but as though
   // it additionally matched the rules in the aRules array (in that
   // order, as more specific than any other rules).
   already_AddRefed<nsStyleContext>
   ResolveStyleByAddingRules(nsStyleContext* aBaseContext,
                             const nsCOMArray<nsIStyleRule> &aRules);
 
   // Resolve style by making replacements in the list of style rules as
