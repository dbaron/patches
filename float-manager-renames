Rename flags and methods from space manager to float manager.  (Bug 191448)

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -2280,17 +2280,17 @@ nsCSSFrameConstructor::CreateInputFrame(
       return ConstructRadioControlFrame(aFrame, aContent, aStyleContext);
 
     case NS_FORM_INPUT_FILE:
     {
       *aFrame = NS_NewFileControlFrame(mPresShell, aStyleContext);
 
       if (*aFrame) {
         // The (block-like) file control frame should have a space manager
-        (*aFrame)->AddStateBits(NS_BLOCK_SPACE_MGR);
+        (*aFrame)->AddStateBits(NS_BLOCK_FLOAT_MGR);
         return NS_OK;
       }
       else {
         return NS_ERROR_OUT_OF_MEMORY;
       }
     }
 
     case NS_FORM_INPUT_HIDDEN:
@@ -4301,17 +4301,17 @@ nsCSSFrameConstructor::ConstructDocEleme
       } else {
         return NS_ERROR_FAILURE;
       }
     }
     else 
 #endif
     {
       contentFrame = NS_NewBlockFrame(mPresShell, styleContext,
-        NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
+        NS_BLOCK_FLOAT_MGR|NS_BLOCK_MARGIN_ROOT);
       if (!contentFrame)
         return NS_ERROR_OUT_OF_MEMORY;
       nsFrameItems frameItems;
       rv = ConstructBlock(aState, display, aDocElement,
                           aState.GetGeometricParent(display, aParentFrame),
                           aParentFrame, styleContext, &contentFrame,
                           frameItems, display->IsPositioned());
       if (NS_FAILED(rv) || !frameItems.childList)
@@ -4820,17 +4820,17 @@ nsCSSFrameConstructor::ConstructButtonFr
   
   
   nsRefPtr<nsStyleContext> styleContext;
   styleContext = mPresShell->StyleSet()->ResolvePseudoStyleFor(aContent,
                                                                nsCSSAnonBoxes::buttonContent,
                                                                aStyleContext);
                                                                
   nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, styleContext,
-                                          NS_BLOCK_SPACE_MGR);
+                                          NS_BLOCK_FLOAT_MGR);
 
   if (NS_UNLIKELY(!blockFrame)) {
     buttonFrame->Destroy();
     return NS_ERROR_OUT_OF_MEMORY;
   }
   rv = InitAndRestoreFrame(aState, aContent, buttonFrame, nsnull, blockFrame);
   if (NS_FAILED(rv)) {
     blockFrame->Destroy();
@@ -4917,17 +4917,17 @@ nsCSSFrameConstructor::ConstructSelectFr
     sel->GetMultiple(&multipleSelect);
      // Construct a combobox if size=1 or no size is specified and its multiple select
     if (((1 == size || 0 == size) || (kNoSizeSpecified  == size)) && (PR_FALSE == multipleSelect)) {
         // Construct a frame-based combo box.
         // The frame-based combo box is built out of three parts. A display area, a button and
         // a dropdown list. The display area and button are created through anonymous content.
         // The drop-down list's frame is created explicitly. The combobox frame shares its content
         // with the drop-down list.
-      PRUint32 flags = NS_BLOCK_SPACE_MGR;
+      PRUint32 flags = NS_BLOCK_FLOAT_MGR;
       nsIFrame* comboboxFrame = NS_NewComboboxControlFrame(mPresShell, aStyleContext, flags);
 
       // Save the history state so we don't restore during construction
       // since the complete tree is required before we restore.
       nsILayoutHistoryState *historyState = aState.mFrameState;
       aState.mFrameState = nsnull;
       // Initialize the combobox frame
       InitAndRestoreFrame(aState, aContent,
@@ -5019,17 +5019,17 @@ nsCSSFrameConstructor::ConstructSelectFr
       if (listFrame) {
         rv = NS_OK;
       }
       else {
         rv = NS_ERROR_OUT_OF_MEMORY;
       }
 
       nsIFrame* scrolledFrame = NS_NewSelectsAreaFrame(
-        mPresShell, aStyleContext, NS_BLOCK_SPACE_MGR);
+        mPresShell, aStyleContext, NS_BLOCK_FLOAT_MGR);
 
       // ******* this code stolen from Initialze ScrollFrame ********
       // please adjust this code to use BuildScrollFrame.
 
       InitializeSelectFrame(aState, listFrame, scrolledFrame, aContent,
                             aParentFrame, aStyleContext, PR_FALSE, aFrameItems);
 
       aNewFrame = listFrame;
@@ -5162,17 +5162,17 @@ nsCSSFrameConstructor::ConstructFieldSet
 
   // Resolve style and initialize the frame
   nsRefPtr<nsStyleContext> styleContext;
   styleContext = mPresShell->StyleSet()->ResolvePseudoStyleFor(aContent,
                                                                nsCSSAnonBoxes::fieldsetContent,
                                                                aStyleContext);
   
   nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, styleContext,
-                                          NS_BLOCK_SPACE_MGR |
+                                          NS_BLOCK_FLOAT_MGR |
                                           NS_BLOCK_MARGIN_ROOT);
   InitAndRestoreFrame(aState, aContent, newFrame, nsnull, blockFrame);
 
   nsresult rv = aState.AddChild(newFrame, aFrameItems, aContent, aStyleContext,
                                 aParentFrame);
   if (NS_FAILED(rv)) {
     return rv;
   }
@@ -5885,21 +5885,21 @@ nsCSSFrameConstructor::ConstructXULFrame
       else if (aTag == nsGkAtoms::text || aTag == nsGkAtoms::label ||
                aTag == nsGkAtoms::description) {
         if ((aTag == nsGkAtoms::label || aTag == nsGkAtoms::description) && 
             (! aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::value))) {
           // XXX we should probably be calling ConstructBlock here to handle
           // things like columns etc
           if (aTag == nsGkAtoms::label) {
             newFrame = NS_NewXULLabelFrame(mPresShell, aStyleContext,
-                                           NS_BLOCK_SPACE_MGR |
+                                           NS_BLOCK_FLOAT_MGR |
                                            NS_BLOCK_MARGIN_ROOT);
           } else {
             newFrame = NS_NewBlockFrame(mPresShell, aStyleContext,
-                                        NS_BLOCK_SPACE_MGR |
+                                        NS_BLOCK_FLOAT_MGR |
                                         NS_BLOCK_MARGIN_ROOT);
           }
         }
         else {
           newFrame = NS_NewTextBoxFrame(mPresShell, aStyleContext);
         }
       }
       // End of TEXT CONSTRUCTION logic
@@ -6463,17 +6463,17 @@ nsCSSFrameConstructor::ConstructFrameByD
                                  aParentFrame,
                                  nsCSSAnonBoxes::scrolledContent,
                                  PR_FALSE, newFrame);
     
     // Initialize it
     // pass a temporary stylecontext, the correct one will be set later
     nsIFrame* scrolledFrame =
         NS_NewBlockFrame(mPresShell, aStyleContext,
-                         NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT);
+                         NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT);
 
     nsFrameItems blockItem;
     rv = ConstructBlock(aState,
                         scrolledContentStyle->GetStyleDisplay(), aContent,
                         newFrame, newFrame, scrolledContentStyle,
                         &scrolledFrame, blockItem, aDisplay->IsPositioned());
     NS_ASSERTION(blockItem.childList == scrolledFrame,
                  "Scrollframe's frameItems should be exactly the scrolled frame");
@@ -6538,17 +6538,17 @@ nsCSSFrameConstructor::ConstructFrameByD
             (NS_STYLE_DISPLAY_INLINE == aDisplay->mDisplay))) {
     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
       ProcessPseudoFrames(aState, aFrameItems); 
     }
     // Is it block-level or inline-level?
     if (aDisplay->IsBlockInside()) {
       // Create a wrapper frame. Only need space manager if it's inline-block
       PRUint32 flags = (aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_BLOCK ?
-                        NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT : 0);
+                        NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT : 0);
       newFrame = NS_NewRelativeItemWrapperFrame(mPresShell, aStyleContext, 
                                                 flags);
       // XXXbz should we be passing in a non-null aContentParentFrame?
       ConstructBlock(aState, aDisplay, aContent,
                      aParentFrame, nsnull, aStyleContext, &newFrame,
                      aFrameItems, PR_TRUE);
       addedToFrameList = PR_TRUE;
     } else {
@@ -6566,17 +6566,17 @@ nsCSSFrameConstructor::ConstructFrameByD
            (NS_STYLE_DISPLAY_RUN_IN == aDisplay->mDisplay) ||
            (NS_STYLE_DISPLAY_COMPACT == aDisplay->mDisplay) ||
            (NS_STYLE_DISPLAY_INLINE_BLOCK == aDisplay->mDisplay)) {
     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
       ProcessPseudoFrames(aState, aFrameItems); 
     }
     PRUint32 flags = 0;
     if (NS_STYLE_DISPLAY_INLINE_BLOCK == aDisplay->mDisplay) {
-      flags = NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT;
+      flags = NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT;
     }
     // Create the block frame
     newFrame = NS_NewBlockFrame(mPresShell, aStyleContext, flags);
     if (newFrame) { // That worked so construct the block and its children
       // XXXbz should we be passing in a non-null aContentParentFrame?
       rv = ConstructBlock(aState, aDisplay, aContent,
                           aParentFrame, nsnull, aStyleContext, &newFrame,
                           aFrameItems, PR_FALSE);
@@ -6824,17 +6824,17 @@ nsCSSFrameConstructor::FlushAccumulatedB
   blockContext = styleSet->ResolvePseudoStyleFor(aContent,
                                                  nsCSSAnonBoxes::mozMathMLAnonymousBlock,
                                                  parentContext);
 
   // then, create a block frame that will wrap the child frames. Make it a
   // MathML frame so that Get(Absolute/Float)ContainingBlockFor know that this
   // is not a suitable block.
   nsIFrame* blockFrame = NS_NewMathMLmathBlockFrame(mPresShell, blockContext,
-                          NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT);
+                          NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT);
   if (NS_UNLIKELY(!blockFrame))
     return NS_ERROR_OUT_OF_MEMORY;
 
   InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, blockFrame);
   for (nsIFrame* f = aBlockItems->childList; f; f = f->GetNextSibling()) {
     ReparentFrame(aState.mFrameManager, blockFrame, f);
   }
   // abs-pos and floats are disabled in MathML children so we don't have to
@@ -7258,17 +7258,17 @@ nsCSSFrameConstructor::ConstructSVGFrame
       // Resolve pseudo style and create an inner block frame
       // XXX this breaks style inheritance
       nsRefPtr<nsStyleContext> innerPseudoStyle;
       innerPseudoStyle = mPresShell->StyleSet()->
         ResolvePseudoStyleFor(aContent,
                               nsCSSAnonBoxes::mozSVGForeignContent, aStyleContext);
     
       nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, innerPseudoStyle,
-                                              NS_BLOCK_SPACE_MGR |
+                                              NS_BLOCK_FLOAT_MGR |
                                                 NS_BLOCK_MARGIN_ROOT);
       if (NS_UNLIKELY(!blockFrame))
         return NS_ERROR_OUT_OF_MEMORY;
     
       // Claim to be relatively positioned so that we end up being the
       // absolute containing block.
       nsFrameConstructorSaveState saveState;
       aState.PushFloatContainingBlock(nsnull, saveState, PR_FALSE, PR_FALSE);
@@ -11420,17 +11420,17 @@ nsCSSFrameConstructor::ProcessChildren(n
                                     nsIScriptError::warningFlag,
                                     "FrameConstructor");
 
     nsRefPtr<nsStyleContext> blockSC = mPresShell->StyleSet()->
       ResolvePseudoStyleFor(aContent,
                             nsCSSAnonBoxes::mozXULAnonymousBlock,
                             frameStyleContext);
     nsIFrame *blockFrame = NS_NewBlockFrame(mPresShell, blockSC);
-    // We might, in theory, want to set NS_BLOCK_SPACE_MGR and
+    // We might, in theory, want to set NS_BLOCK_FLOAT_MGR and
     // NS_BLOCK_MARGIN_ROOT, but I think it's a bad idea given that
     // a real block placed here wouldn't get those set on it.
 
     InitAndRestoreFrame(aState, aContent, aFrame, nsnull,
                         blockFrame, PR_FALSE);
 
     NS_ASSERTION(!blockFrame->HasView(), "need to do view reparenting");
     for (nsIFrame *f = aFrameItems.childList; f; f = f->GetNextSibling()) {
diff --git a/layout/build/nsLayoutStatics.cpp b/layout/build/nsLayoutStatics.cpp
--- a/layout/build/nsLayoutStatics.cpp
+++ b/layout/build/nsLayoutStatics.cpp
@@ -63,17 +63,17 @@
 #include "nsStyledElement.h"
 #include "nsGlobalWindow.h"
 #include "nsGkAtoms.h"
 #include "nsImageFrame.h"
 #include "nsLayoutStylesheetCache.h"
 #include "nsNodeInfo.h"
 #include "nsRange.h"
 #include "nsRepeatService.h"
-#include "nsSpaceManager.h"
+#include "nsFloatManager.h"
 #include "nsSprocketLayout.h"
 #include "nsStackLayout.h"
 #include "nsStyleSet.h"
 #include "nsTextControlFrame.h"
 #include "nsXBLWindowKeyHandler.h"
 #include "txMozillaXSLTProcessor.h"
 #include "nsDOMStorage.h"
 #include "nsCellMap.h"
@@ -311,17 +311,17 @@ nsLayoutStatics::Shutdown()
   nsSprocketLayout::Shutdown();
 #endif
 
 #ifdef MOZ_MATHML
   nsMathMLOperators::ReleaseTable();
 #endif
 
   nsCSSFrameConstructor::ReleaseGlobals();
-  nsSpaceManager::Shutdown();
+  nsFloatManager::Shutdown();
   nsImageFrame::ReleaseGlobals();
 
   nsCSSScanner::ReleaseGlobals();
 
   NS_IF_RELEASE(nsRuleNode::gLangService);
   nsStyledElement::Shutdown();
 
   nsTextFragment::Shutdown();
diff --git a/layout/forms/nsIsIndexFrame.cpp b/layout/forms/nsIsIndexFrame.cpp
--- a/layout/forms/nsIsIndexFrame.cpp
+++ b/layout/forms/nsIsIndexFrame.cpp
@@ -82,17 +82,17 @@ nsIFrame*
 NS_NewIsIndexFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 {
   return new (aPresShell) nsIsIndexFrame(aContext);
 }
 
 nsIsIndexFrame::nsIsIndexFrame(nsStyleContext* aContext) :
   nsBlockFrame(aContext)
 {
-  SetFlags(NS_BLOCK_SPACE_MGR);
+  SetFlags(NS_BLOCK_FLOAT_MGR);
 }
 
 nsIsIndexFrame::~nsIsIndexFrame()
 {
 }
 
 void
 nsIsIndexFrame::Destroy()
diff --git a/layout/forms/nsLegendFrame.cpp b/layout/forms/nsLegendFrame.cpp
--- a/layout/forms/nsLegendFrame.cpp
+++ b/layout/forms/nsLegendFrame.cpp
@@ -54,17 +54,17 @@
 
 static NS_DEFINE_IID(kLegendFrameCID, NS_LEGEND_FRAME_CID);
  
 nsIFrame*
 NS_NewLegendFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 {
   nsIFrame* f = new (aPresShell) nsLegendFrame(aContext);
   if (f) {
-    f->AddStateBits(NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT);
+    f->AddStateBits(NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT);
   }
   return f;
 }
 
 nsIAtom*
 nsLegendFrame::GetType() const
 {
   return nsGkAtoms::legendFrame; 
diff --git a/layout/forms/nsSelectsAreaFrame.cpp b/layout/forms/nsSelectsAreaFrame.cpp
--- a/layout/forms/nsSelectsAreaFrame.cpp
+++ b/layout/forms/nsSelectsAreaFrame.cpp
@@ -43,19 +43,19 @@
 #include "nsDisplayList.h"
 
 nsIFrame*
 NS_NewSelectsAreaFrame(nsIPresShell* aShell, nsStyleContext* aContext, PRUint32 aFlags)
 {
   nsSelectsAreaFrame* it = new (aShell) nsSelectsAreaFrame(aContext);
 
   if (it) {
-    // We need NS_BLOCK_SPACE_MGR to ensure that the options inside the select
+    // We need NS_BLOCK_FLOAT_MGR to ensure that the options inside the select
     // aren't expanded by right floats outside the select.
-    it->SetFlags(aFlags | NS_BLOCK_SPACE_MGR);
+    it->SetFlags(aFlags | NS_BLOCK_FLOAT_MGR);
   }
 
   return it;
 }
 
 //---------------------------------------------------------
 PRBool 
 nsSelectsAreaFrame::IsOptionElement(nsIContent* aContent)
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -65,17 +65,17 @@
 #include "nsIFontMetrics.h"
 #include "nsHTMLParts.h"
 #include "nsGkAtoms.h"
 #include "nsIDOMEvent.h"
 #include "nsGenericHTMLElement.h"
 #include "prprf.h"
 #include "nsStyleChangeList.h"
 #include "nsFrameSelection.h"
-#include "nsSpaceManager.h"
+#include "nsFloatManager.h"
 #include "nsIntervalSet.h"
 #include "prenv.h"
 #include "plstr.h"
 #include "nsGUIEvent.h"
 #include "nsLayoutErrors.h"
 #include "nsAutoPtr.h"
 #include "nsIServiceManager.h"
 #include "nsIScrollableFrame.h"
@@ -106,32 +106,32 @@ static const int MIN_LINES_NEEDING_CURSO
 
 PRBool nsBlockFrame::gLamePaintMetrics;
 PRBool nsBlockFrame::gLameReflowMetrics;
 PRBool nsBlockFrame::gNoisy;
 PRBool nsBlockFrame::gNoisyDamageRepair;
 PRBool nsBlockFrame::gNoisyIntrinsic;
 PRBool nsBlockFrame::gNoisyReflow;
 PRBool nsBlockFrame::gReallyNoisyReflow;
-PRBool nsBlockFrame::gNoisySpaceManager;
+PRBool nsBlockFrame::gNoisyFloatManager;
 PRBool nsBlockFrame::gVerifyLines;
 PRBool nsBlockFrame::gDisableResizeOpt;
 
 PRInt32 nsBlockFrame::gNoiseIndent;
 
 struct BlockDebugFlags {
   const char* name;
   PRBool* on;
 };
 
 static const BlockDebugFlags gFlags[] = {
   { "reflow", &nsBlockFrame::gNoisyReflow },
   { "really-noisy-reflow", &nsBlockFrame::gReallyNoisyReflow },
   { "intrinsic", &nsBlockFrame::gNoisyIntrinsic },
-  { "space-manager", &nsBlockFrame::gNoisySpaceManager },
+  { "float-manager", &nsBlockFrame::gNoisyFloatManager },
   { "verify-lines", &nsBlockFrame::gVerifyLines },
   { "damage-repair", &nsBlockFrame::gNoisyDamageRepair },
   { "lame-paint-metrics", &nsBlockFrame::gLamePaintMetrics },
   { "lame-reflow-metrics", &nsBlockFrame::gLameReflowMetrics },
   { "disable-resize-opt", &nsBlockFrame::gDisableResizeOpt },
 };
 #define NUM_DEBUG_FLAGS (sizeof(gFlags) / sizeof(gFlags[0]))
 
@@ -887,25 +887,25 @@ nsBlockFrame::Reflow(nsPresContext*     
   }
 #endif
 
   // See comment below about oldSize. Use *only* for the
   // abs-pos-containing-block-size-change optimization!
   nsSize oldSize = GetSize();
 
   // Should we create a space manager?
-  nsAutoSpaceManager autoSpaceManager(const_cast<nsHTMLReflowState &>(aReflowState));
+  nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState &>(aReflowState));
 
   // XXXldb If we start storing the space manager in the frame rather
   // than keeping it around only during reflow then we should create it
   // only when there are actually floats to manage.  Otherwise things
   // like tables will gain significant bloat.
-  PRBool needSpaceManager = nsBlockFrame::BlockNeedsSpaceManager(this);
-  if (needSpaceManager)
-    autoSpaceManager.CreateSpaceManager(aPresContext);
+  PRBool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
+  if (needFloatManager)
+    autoFloatManager.CreateFloatManager(aPresContext);
 
   // OK, some lines may be reflowed. Blow away any saved line cursor because
   // we may invalidate the nondecreasing combinedArea.y/yMost invariant,
   // and we may even delete the line with the line cursor.
   ClearLineCursor();
 
   if (IsFrameTreeTooDeep(aReflowState, aMetrics)) {
 #ifdef DEBUG_kipp
@@ -918,17 +918,17 @@ nsBlockFrame::Reflow(nsPresContext*     
     }
 #endif
     aStatus = NS_FRAME_COMPLETE;
     return NS_OK;
   }
 
   PRBool marginRoot = BlockIsMarginRoot(this);
   nsBlockReflowState state(aReflowState, aPresContext, this, aMetrics,
-                           marginRoot, marginRoot, needSpaceManager);
+                           marginRoot, marginRoot, needFloatManager);
 
 #ifdef IBMBIDI
   if (GetStateBits() & NS_BLOCK_NEEDS_BIDI_RESOLUTION)
     static_cast<nsBlockFrame*>(GetFirstContinuation())->ResolveBidi();
 #endif // IBMBIDI
 
   if (RenumberLists(aPresContext)) {
     AddStateBits(NS_FRAME_HAS_DIRTY_CHILDREN);
@@ -973,17 +973,17 @@ nsBlockFrame::Reflow(nsPresContext*     
                  "Somehow we failed to fit all content, even though we have unlimited space!");
     if (NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
       // find the nearest block ancestor that uses the same space manager
       for (const nsHTMLReflowState* ancestorRS = aReflowState.parentReflowState; 
            ancestorRS; 
            ancestorRS = ancestorRS->parentReflowState) {
         nsIFrame* ancestor = ancestorRS->frame;
         if (nsLayoutUtils::GetAsBlock(ancestor) &&
-            aReflowState.mSpaceManager == ancestorRS->mSpaceManager) {
+            aReflowState.mFloatManager == ancestorRS->mFloatManager) {
           // Put the continued floats in ancestor since it uses the same space manager
           nsFrameList* ancestorPlace =
             ((nsBlockFrame*)ancestor)->GetOverflowPlaceholders();
           // The ancestor should have this list, since it's being reflowed. But maybe
           // it isn't because of reflow roots or something.
           if (ancestorPlace) {
             for (nsIFrame* f = state.mOverflowPlaceholders.FirstChild();
                  f; f = f->GetNextSibling()) {
@@ -1178,18 +1178,18 @@ nsBlockFrame::Reflow(nsPresContext*     
   // Determine if we need to repaint our border, background or outline
   CheckInvalidateSizeChange(aMetrics);
 
   FinishAndStoreOverflow(&aMetrics);
 
   // Clear the space manager pointer in the block reflow state so we
   // don't waste time translating the coordinate system back on a dead
   // space manager.
-  if (needSpaceManager)
-    state.mSpaceManager = nsnull;
+  if (needFloatManager)
+    state.mFloatManager = nsnull;
 
   aStatus = state.mReflowStatus;
 
 #ifdef DEBUG
   if (gNoisyReflow) {
     IndentBy(stdout, gNoiseIndent);
     ListTag(stdout);
     printf(": status=%x (%scomplete) metrics=%d,%d carriedMargin=%d",
@@ -1306,17 +1306,17 @@ nsBlockFrame::ComputeFinalSize(const nsH
     if (bottomEdgeOfChildren < aState.mReflowState.availableHeight)
     {
       // Truncate bottom margin if it doesn't fit to our available height.
       bottomEdgeOfChildren =
         PR_MIN(bottomEdgeOfChildren + aState.mPrevBottomMargin.get(),
                aState.mReflowState.availableHeight);
     }
   }
-  if (aState.GetFlag(BRS_SPACE_MGR)) {
+  if (aState.GetFlag(BRS_FLOAT_MGR)) {
     // Include the space manager's state to properly account for the
     // bottom margin of any floated elements; e.g., inside a table cell.
     nscoord floatHeight =
       aState.ClearFloats(bottomEdgeOfChildren, NS_STYLE_CLEAR_LEFT_AND_RIGHT);
     bottomEdgeOfChildren = PR_MAX(bottomEdgeOfChildren, floatHeight);
   }
 
   // Compute final height
@@ -1629,19 +1629,19 @@ nsBlockFrame::PrepareResizeReflow(nsBloc
  * |aDeltaY| indicates how much it will later be slid (assuming it
  * doesn't get marked dirty and reflowed entirely).
  */
 void
 nsBlockFrame::PropagateFloatDamage(nsBlockReflowState& aState,
                                    nsLineBox* aLine,
                                    nscoord aDeltaY)
 {
-  nsSpaceManager *spaceManager = aState.mReflowState.mSpaceManager;
+  nsFloatManager *spaceManager = aState.mReflowState.mFloatManager;
   NS_ASSERTION((aState.mReflowState.parentReflowState &&
-                aState.mReflowState.parentReflowState->mSpaceManager == spaceManager) ||
+                aState.mReflowState.parentReflowState->mFloatManager == spaceManager) ||
                 aState.mReflowState.mBlockDelta == 0, "Bad block delta passed in");
 
   // Check to see if there are any floats; if there aren't, there can't
   // be any float damage
   if (!spaceManager->HasAnyFloats())
     return;
 
   // Check the damage region recorded in the float damage.
@@ -2984,20 +2984,20 @@ nsBlockFrame::ReflowBlockFrame(nsBlockRe
     
     // Reflow the block into the available space
     // construct the html reflow state for the block. ReflowBlock 
     // will initialize it
     nsHTMLReflowState blockHtmlRS(aState.mPresContext, aState.mReflowState, frame, 
                                   nsSize(availSpace.width, availSpace.height));
     blockHtmlRS.mFlags.mHasClearance = aLine->HasClearance();
     
-    nsSpaceManager::SavedState spaceManagerState;
+    nsFloatManager::SavedState spaceManagerState;
     if (mayNeedRetry) {
       blockHtmlRS.mDiscoveredClearance = &clearanceFrame;
-      aState.mSpaceManager->PushState(&spaceManagerState);
+      aState.mFloatManager->PushState(&spaceManagerState);
     } else if (!applyTopMargin) {
       blockHtmlRS.mDiscoveredClearance = aState.mReflowState.mDiscoveredClearance;
     }
     
     nsReflowStatus frameReflowStatus = NS_FRAME_COMPLETE;
     rv = brc.ReflowBlock(availSpace, applyTopMargin, aState.mPrevBottomMargin,
                          clearance, aState.IsAdjacentWithTop(),
                          aLine.get(), blockHtmlRS, frameReflowStatus, aState);
@@ -3008,17 +3008,17 @@ nsBlockFrame::ReflowBlockFrame(nsBlockRe
     if (!mayNeedRetry && clearanceFrame &&
         frame->GetRect().y != passOriginalY) {
       Invalidate(frame->GetOverflowRect() + frame->GetPosition());
     }
     
     NS_ENSURE_SUCCESS(rv, rv);
     
     if (mayNeedRetry && clearanceFrame) {
-      aState.mSpaceManager->PopState(&spaceManagerState);
+      aState.mFloatManager->PopState(&spaceManagerState);
       aState.mY = startingY;
       aState.mPrevBottomMargin = incomingMargin;
       continue;
     }
     
     aState.mPrevChild = frame;
     
 #if defined(REFLOW_STATUS_COVERAGE)
@@ -3237,28 +3237,28 @@ nsBlockFrame::ReflowInlineFrames(nsBlock
   LineReflowStatus lineReflowStatus = LINE_REFLOW_REDO_NEXT_BAND;
   PRBool movedPastFloat = PR_FALSE;
   do {
     PRBool allowPullUp = PR_TRUE;
     nsIContent* forceBreakInContent = nsnull;
     PRInt32 forceBreakOffset = -1;
     gfxBreakPriority forceBreakPriority = eNoBreak;
     do {
-      nsSpaceManager::SavedState spaceManagerState;
-      aState.mReflowState.mSpaceManager->PushState(&spaceManagerState);
+      nsFloatManager::SavedState spaceManagerState;
+      aState.mReflowState.mFloatManager->PushState(&spaceManagerState);
 
       // Once upon a time we allocated the first 30 nsLineLayout objects
       // on the stack, and then we switched to the heap.  At that time
       // these objects were large (1100 bytes on a 32 bit system).
       // Then the nsLineLayout object was shrunk to 156 bytes by
       // removing some internal buffers.  Given that it is so much
       // smaller, the complexity of 2 different ways of allocating
       // no longer makes sense.  Now we always allocate on the stack.
       nsLineLayout lineLayout(aState.mPresContext,
-                              aState.mReflowState.mSpaceManager,
+                              aState.mReflowState.mFloatManager,
                               &aState.mReflowState, &aLine);
       lineLayout.Init(&aState, aState.mMinLineHeight, aState.mLineNumber);
       if (forceBreakInContent) {
         lineLayout.ForceBreakAtPosition(forceBreakInContent, forceBreakOffset);
       }
       rv = DoReflowInlineFrames(aState, lineLayout, aLine,
                                 aKeepReflowGoing, &lineReflowStatus,
                                 allowPullUp);
@@ -3271,17 +3271,17 @@ nsBlockFrame::ReflowInlineFrames(nsBlock
           // If there is no saved break position, then this will set
           // set forceBreakInContent to null and we won't back up, which is
           // correct.
           forceBreakInContent = lineLayout.GetLastOptionalBreakPosition(&forceBreakOffset, &forceBreakPriority);
         } else {
           forceBreakInContent = nsnull;
         }
         // restore the space manager state
-        aState.mReflowState.mSpaceManager->PopState(&spaceManagerState);
+        aState.mReflowState.mFloatManager->PopState(&spaceManagerState);
         // Clear out float lists
         aState.mCurrentLineFloats.DeleteAll();
         aState.mBelowCurrentLineFloats.DeleteAll();
       }
       
 #ifdef DEBUG
       spins++;
       if (1000 == spins) {
@@ -4973,32 +4973,32 @@ static void MarkAllDescendantLinesDirty(
         MarkAllDescendantLinesDirty(bf);
       }
     }
     line->MarkDirty();
     ++line;
   }
 }
 
-static void MarkSameSpaceManagerLinesDirty(nsBlockFrame* aBlock)
-{
-  nsBlockFrame* blockWithSpaceMgr = aBlock;
-  while (!(blockWithSpaceMgr->GetStateBits() & NS_BLOCK_SPACE_MGR)) {
-    nsBlockFrame* bf = nsLayoutUtils::GetAsBlock(blockWithSpaceMgr->GetParent());
+static void MarkSameFloatManagerLinesDirty(nsBlockFrame* aBlock)
+{
+  nsBlockFrame* blockWithFloatMgr = aBlock;
+  while (!(blockWithFloatMgr->GetStateBits() & NS_BLOCK_FLOAT_MGR)) {
+    nsBlockFrame* bf = nsLayoutUtils::GetAsBlock(blockWithFloatMgr->GetParent());
     if (!bf) {
       break;
     }
-    blockWithSpaceMgr = bf;
+    blockWithFloatMgr = bf;
   }
     
   // Mark every line at and below the line where the float was
   // dirty, and mark their lines dirty too. We could probably do
   // something more efficient --- e.g., just dirty the lines that intersect
   // the float vertically.
-  MarkAllDescendantLinesDirty(blockWithSpaceMgr);
+  MarkAllDescendantLinesDirty(blockWithFloatMgr);
 }
 
 /**
  * Returns PR_TRUE if aFrame is a block that has one or more float children.
  */
 static PRBool BlockHasAnyFloats(nsIFrame* aFrame)
 {
   nsBlockFrame* block = nsLayoutUtils::GetAsBlock(aFrame);
@@ -5029,32 +5029,32 @@ nsBlockFrame::RemoveFrame(nsIAtom*  aLis
   nsFrame::ListTag(stdout, aOldFrame);
   printf("\n");
 #endif
 
   if (nsnull == aListName) {
     PRBool hasFloats = BlockHasAnyFloats(aOldFrame);
     rv = DoRemoveFrame(aOldFrame, REMOVE_FIXED_CONTINUATIONS);
     if (hasFloats) {
-      MarkSameSpaceManagerLinesDirty(this);
+      MarkSameFloatManagerLinesDirty(this);
     }
   }
   else if (nsGkAtoms::absoluteList == aListName) {
     return mAbsoluteContainer.RemoveFrame(this, aListName, aOldFrame);
   }
   else if (nsGkAtoms::floatList == aListName) {
     nsIFrame* curFrame = aOldFrame;
     // Make sure to delete all the continuations for the float frame
     // we are removing; this way is a bit messy, but so is the rest of the code.
     // See bug 390762.
     do {
       nsIFrame* continuation = curFrame->GetNextContinuation();
       nsBlockFrame* curParent = static_cast<nsBlockFrame*>(curFrame->GetParent());
       curParent->RemoveFloat(curFrame);
-      MarkSameSpaceManagerLinesDirty(curParent);
+      MarkSameFloatManagerLinesDirty(curParent);
       curFrame = continuation;
     } while (curFrame);
   }
 #ifdef IBMBIDI
   else if (nsGkAtoms::nextBidi == aListName) {
     // Skip the call to |FrameNeedsReflow| below by returning now.
     return DoRemoveFrame(aOldFrame, REMOVE_FIXED_CONTINUATIONS);
   }
@@ -6771,17 +6771,17 @@ nsBlockFrame::CheckFloats(nsBlockReflowS
     // be larger than necessary, causing this block to get an
     // incorrect desired height (or width).  Some of these floats
     // may not actually have been added to the space manager because
     // they weren't reflowed before being pushed; that's OK,
     // RemoveRegions will ignore them. It is safe to do this here
     // because we know from here on the space manager will only be
     // used for its XMost and YMost, not to place new floats and
     // lines.
-    aState.mSpaceManager->RemoveTrailingRegions(oofs.FirstChild());
+    aState.mFloatManager->RemoveTrailingRegions(oofs.FirstChild());
   }
 }
 
 /* static */
 PRBool
 nsBlockFrame::BlockIsMarginRoot(nsIFrame* aBlock)
 {
   NS_PRECONDITION(aBlock, "Must have a frame");
@@ -6790,33 +6790,33 @@ nsBlockFrame::BlockIsMarginRoot(nsIFrame
   nsIFrame* parent = aBlock->GetParent();
   return (aBlock->GetStateBits() & NS_BLOCK_MARGIN_ROOT) ||
     (parent && !parent->IsFloatContainingBlock() &&
      parent->GetType() != nsGkAtoms::columnSetFrame);
 }
 
 /* static */
 PRBool
-nsBlockFrame::BlockNeedsSpaceManager(nsIFrame* aBlock)
+nsBlockFrame::BlockNeedsFloatManager(nsIFrame* aBlock)
 {
   NS_PRECONDITION(aBlock, "Must have a frame");
   NS_ASSERTION(nsLayoutUtils::GetAsBlock(aBlock), "aBlock must be a block");
 
   nsIFrame* parent = aBlock->GetParent();
-  return (aBlock->GetStateBits() & NS_BLOCK_SPACE_MGR) ||
+  return (aBlock->GetStateBits() & NS_BLOCK_FLOAT_MGR) ||
     (parent && !parent->IsFloatContainingBlock());
 }
 
 /* static */
 PRBool
 nsBlockFrame::BlockCanIntersectFloats(nsIFrame* aFrame)
 {
   return aFrame->IsFrameOfType(nsIFrame::eBlockFrame) &&
          !aFrame->IsFrameOfType(nsIFrame::eReplaced) &&
-         !(aFrame->GetStateBits() & NS_BLOCK_SPACE_MGR);
+         !(aFrame->GetStateBits() & NS_BLOCK_FLOAT_MGR);
 }
 
 // Note that this width can vary based on the vertical position.
 // However, the cases where it varies are the cases where the width fits
 // in the available space given, which means that variation shouldn't
 // matter.
 /* static */
 nsBlockFrame::ReplacedElementWidthToClear
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -281,17 +281,17 @@ public:
   
   PRBool HandleOverflowPlaceholdersForPulledFrame(
     nsBlockReflowState& aState, nsIFrame* aFrame);
 
   PRBool HandleOverflowPlaceholdersOnPulledLine(
     nsBlockReflowState& aState, nsLineBox* aLine);
 
   static PRBool BlockIsMarginRoot(nsIFrame* aBlock);
-  static PRBool BlockNeedsSpaceManager(nsIFrame* aBlock);
+  static PRBool BlockNeedsFloatManager(nsIFrame* aBlock);
 
   /**
    * Returns whether aFrame is a block frame that will wrap its contents
    * around floats intruding on it from the outside.  (aFrame need not
    * be a block frame, but if it's not, the result will be false.)
    */
   static PRBool BlockCanIntersectFloats(nsIFrame* aFrame);
 
@@ -674,17 +674,17 @@ private:
 public:
   static PRBool gLamePaintMetrics;
   static PRBool gLameReflowMetrics;
   static PRBool gNoisy;
   static PRBool gNoisyDamageRepair;
   static PRBool gNoisyIntrinsic;
   static PRBool gNoisyReflow;
   static PRBool gReallyNoisyReflow;
-  static PRBool gNoisySpaceManager;
+  static PRBool gNoisyFloatManager;
   static PRBool gVerifyLines;
   static PRBool gDisableResizeOpt;
 
   static PRInt32 gNoiseIndent;
 
   static const char* kReflowCommandType[];
 
 protected:
diff --git a/layout/generic/nsBlockReflowContext.cpp b/layout/generic/nsBlockReflowContext.cpp
--- a/layout/generic/nsBlockReflowContext.cpp
+++ b/layout/generic/nsBlockReflowContext.cpp
@@ -36,17 +36,17 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* class that a parent frame uses to reflow a block frame */
 
 #include "nsBlockReflowContext.h"
 #include "nsLineLayout.h"
-#include "nsSpaceManager.h"
+#include "nsFloatManager.h"
 #include "nsIFontMetrics.h"
 #include "nsPresContext.h"
 #include "nsFrameManager.h"
 #include "nsIContent.h"
 #include "nsStyleContext.h"
 #include "nsHTMLContainerFrame.h"
 #include "nsBlockFrame.h"
 #include "nsLineBox.h"
@@ -276,17 +276,17 @@ nsBlockReflowContext::ReflowBlock(const 
   if (aLine) {
     // Compute x/y coordinate where reflow will begin. Use the rules
     // from 10.3.3 to determine what to apply. At this point in the
     // reflow auto left/right margins will have a zero value.
 
     nscoord x = mSpace.x + aFrameRS.mComputedMargin.left;
     nscoord y = mSpace.y + mTopMargin.get() + aClearance;
 
-    if ((mFrame->GetStateBits() & NS_BLOCK_SPACE_MGR) == 0)
+    if ((mFrame->GetStateBits() & NS_BLOCK_FLOAT_MGR) == 0)
       aFrameRS.mBlockDelta = mOuterReflowState.mBlockDelta + y - aLine->mBounds.y;
 
     mX = x;
     mY = y;
 
     // Compute the translation to be used for adjusting the spacemanagager
     // coordinate system for the frame.  The spacemanager coordinates are
     // <b>inside</b> the callers border+padding, but the x/y coordinates
@@ -301,19 +301,19 @@ nsBlockReflowContext::ReflowBlock(const 
   // Let frame know that we are reflowing it
   mFrame->WillReflow(mPresContext);
 
 #ifdef DEBUG
   mMetrics.width = nscoord(0xdeadbeef);
   mMetrics.height = nscoord(0xdeadbeef);
 #endif
 
-  mOuterReflowState.mSpaceManager->Translate(tx, ty);
+  mOuterReflowState.mFloatManager->Translate(tx, ty);
   rv = mFrame->Reflow(mPresContext, mMetrics, aFrameRS, aFrameReflowStatus);
-  mOuterReflowState.mSpaceManager->Translate(-tx, -ty);
+  mOuterReflowState.mFloatManager->Translate(-tx, -ty);
 
 #ifdef DEBUG
   if (!NS_INLINE_IS_BREAK_BEFORE(aFrameReflowStatus)) {
     if (CRAZY_WIDTH(mMetrics.width) || CRAZY_HEIGHT(mMetrics.height)) {
       printf("nsBlockReflowContext: ");
       nsFrame::ListTag(stdout, mFrame);
       printf(" metrics=%d,%d!\n", mMetrics.width, mMetrics.height);
     }
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -59,17 +59,17 @@
 #endif
 
 nsBlockReflowState::nsBlockReflowState(const nsHTMLReflowState& aReflowState,
                                        nsPresContext* aPresContext,
                                        nsBlockFrame* aFrame,
                                        const nsHTMLReflowMetrics& aMetrics,
                                        PRBool aTopMarginRoot,
                                        PRBool aBottomMarginRoot,
-                                       PRBool aBlockNeedsSpaceManager)
+                                       PRBool aBlockNeedsFloatManager)
   : mBlock(aFrame),
     mPresContext(aPresContext),
     mReflowState(aReflowState),
     mOverflowTracker(aPresContext, aFrame, PR_FALSE),
     mPrevBottomMargin(),
     mLineNumber(0),
     mFlags(0),
     mFloatBreakType(NS_STYLE_CLEAR_NONE)
@@ -84,29 +84,29 @@ nsBlockReflowState::nsBlockReflowState(c
     SetFlag(BRS_ISTOPMARGINROOT, PR_TRUE);
   }
   if (aBottomMarginRoot || 0 != aReflowState.mComputedBorderPadding.bottom) {
     SetFlag(BRS_ISBOTTOMMARGINROOT, PR_TRUE);
   }
   if (GetFlag(BRS_ISTOPMARGINROOT)) {
     SetFlag(BRS_APPLYTOPMARGIN, PR_TRUE);
   }
-  if (aBlockNeedsSpaceManager) {
-    SetFlag(BRS_SPACE_MGR, PR_TRUE);
+  if (aBlockNeedsFloatManager) {
+    SetFlag(BRS_FLOAT_MGR, PR_TRUE);
   }
   
-  mSpaceManager = aReflowState.mSpaceManager;
+  mFloatManager = aReflowState.mFloatManager;
 
-  NS_ASSERTION(mSpaceManager,
-               "SpaceManager should be set in nsBlockReflowState" );
-  if (mSpaceManager) {
+  NS_ASSERTION(mFloatManager,
+               "FloatManager should be set in nsBlockReflowState" );
+  if (mFloatManager) {
     // Translate into our content area and then save the 
     // coordinate system origin for later.
-    mSpaceManager->Translate(borderPadding.left, borderPadding.top);
-    mSpaceManager->GetTranslation(mSpaceManagerX, mSpaceManagerY);
+    mFloatManager->Translate(borderPadding.left, borderPadding.top);
+    mFloatManager->GetTranslation(mFloatManagerX, mFloatManagerY);
   }
 
   mReflowStatus = NS_FRAME_COMPLETE;
 
   mPresContext = aPresContext;
   mNextInFlow = static_cast<nsBlockFrame*>(mBlock->GetNextInFlow());
 
   NS_ASSERTION(NS_UNCONSTRAINEDSIZE != aReflowState.ComputedWidth(),
@@ -129,17 +129,17 @@ nsBlockReflowState::nsBlockReflowState(c
   else {
     // When we are not in a paginated situation then we always use
     // an constrained height.
     SetFlag(BRS_UNCONSTRAINEDHEIGHT, PR_TRUE);
     mContentArea.height = mBottomEdge = NS_UNCONSTRAINEDSIZE;
   }
 
   mY = borderPadding.top;
-  mBand.Init(mSpaceManager, mContentArea);
+  mBand.Init(mFloatManager, mContentArea);
 
   mPrevChild = nsnull;
   mCurrentLine = aFrame->end_lines();
 
   mMinLineHeight = nsHTMLReflowState::CalcLineHeight(aReflowState.frame);
 
   // Calculate mOutsideBulletX
   GetAvailableSpace();
@@ -165,19 +165,19 @@ nsBlockReflowState::SetupOverflowPlaceho
 
 nsBlockReflowState::~nsBlockReflowState()
 {
   NS_ASSERTION(mOverflowPlaceholders.IsEmpty(),
                "Leaking overflow placeholder frames");
 
   // Restore the coordinate system, unless the space manager is null,
   // which means it was just destroyed.
-  if (mSpaceManager) {
+  if (mFloatManager) {
     const nsMargin& borderPadding = BorderPadding();
-    mSpaceManager->Translate(-borderPadding.left, -borderPadding.top);
+    mFloatManager->Translate(-borderPadding.left, -borderPadding.top);
   }
 
   if (mBlock->GetStateBits() & NS_BLOCK_HAS_OVERFLOW_PLACEHOLDERS) {
     mBlock->UnsetProperty(nsGkAtoms::overflowPlaceholdersProperty);
     mBlock->RemoveStateBits(NS_BLOCK_HAS_OVERFLOW_PLACEHOLDERS);
   }
 }
 
@@ -337,18 +337,18 @@ nsBlockReflowState::ComputeBlockAvailSpa
 }
 
 void
 nsBlockReflowState::GetAvailableSpace(nscoord aY, PRBool aRelaxHeightConstraint)
 {
 #ifdef DEBUG
   // Verify that the caller setup the coordinate system properly
   nscoord wx, wy;
-  mSpaceManager->GetTranslation(wx, wy);
-  NS_ASSERTION((wx == mSpaceManagerX) && (wy == mSpaceManagerY),
+  mFloatManager->GetTranslation(wx, wy);
+  NS_ASSERTION((wx == mFloatManagerX) && (wy == mFloatManagerY),
                "bad coord system");
 #endif
 
   mBand.GetAvailableSpace(aY - BorderPadding().top, aRelaxHeightConstraint,
                           mAvailSpaceRect);
 
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
@@ -422,63 +422,63 @@ nsBlockReflowState::RecoverFloats(nsLine
       if (aDeltaY != 0) {
         fc->mRegion.y += aDeltaY;
         nsPoint p = floatFrame->GetPosition();
         floatFrame->SetPosition(nsPoint(p.x, p.y + aDeltaY));
         nsContainerFrame::PositionFrameView(floatFrame);
         nsContainerFrame::PositionChildViews(floatFrame);
       }
 #ifdef DEBUG
-      if (nsBlockFrame::gNoisyReflow || nsBlockFrame::gNoisySpaceManager) {
+      if (nsBlockFrame::gNoisyReflow || nsBlockFrame::gNoisyFloatManager) {
         nscoord tx, ty;
-        mSpaceManager->GetTranslation(tx, ty);
+        mFloatManager->GetTranslation(tx, ty);
         nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
         printf("RecoverFloats: txy=%d,%d (%d,%d) ",
-               tx, ty, mSpaceManagerX, mSpaceManagerY);
+               tx, ty, mFloatManagerX, mFloatManagerY);
         nsFrame::ListTag(stdout, floatFrame);
         printf(" aDeltaY=%d region={%d,%d,%d,%d}\n",
                aDeltaY, fc->mRegion.x, fc->mRegion.y,
                fc->mRegion.width, fc->mRegion.height);
       }
 #endif
-      mSpaceManager->AddRectRegion(floatFrame, fc->mRegion);
+      mFloatManager->AddRectRegion(floatFrame, fc->mRegion);
       fc = fc->Next();
     }
   } else if (aLine->IsBlock()) {
     nsBlockFrame *kid = nsLayoutUtils::GetAsBlock(aLine->mFirstChild);
     // don't recover any state inside a block that has its own space
     // manager (we don't currently have any blocks like this, though,
     // thanks to our use of extra frames for 'overflow')
-    if (kid && !nsBlockFrame::BlockNeedsSpaceManager(kid)) {
+    if (kid && !nsBlockFrame::BlockNeedsFloatManager(kid)) {
       nscoord tx = kid->mRect.x, ty = kid->mRect.y;
 
       // If the element is relatively positioned, then adjust x and y
       // accordingly so that we consider relatively positioned frames
       // at their original position.
       if (NS_STYLE_POSITION_RELATIVE == kid->GetStyleDisplay()->mPosition) {
         nsPoint *offsets = static_cast<nsPoint*>
                                       (mPresContext->PropertyTable()->GetProperty(kid,
                                        nsGkAtoms::computedOffsetProperty));
 
         if (offsets) {
           tx -= offsets->x;
           ty -= offsets->y;
         }
       }
  
-      mSpaceManager->Translate(tx, ty);
+      mFloatManager->Translate(tx, ty);
       for (nsBlockFrame::line_iterator line = kid->begin_lines(),
                                    line_end = kid->end_lines();
            line != line_end;
            ++line)
         // Pass 0, not the real DeltaY, since these floats aren't
         // moving relative to their parent block, only relative to
         // the space manager.
         RecoverFloats(line, 0);
-      mSpaceManager->Translate(-tx, -ty);
+      mFloatManager->Translate(-tx, -ty);
     }
   }
 }
 
 /**
  * Everything done in this function is done O(N) times for each pass of
  * reflow so it is O(N*M) where M is the number of incremental reflow
  * passes.  That's bad.  Don't do stuff here.
@@ -498,27 +498,27 @@ nsBlockReflowState::RecoverStateFrom(nsL
   mCurrentLine = aLine;
 
   // Place floats for this line into the space manager
   if (aLine->HasFloats() || aLine->IsBlock()) {
     // Undo border/padding translation since the nsFloatCache's
     // coordinates are relative to the frame not relative to the
     // border/padding.
     const nsMargin& bp = BorderPadding();
-    mSpaceManager->Translate(-bp.left, -bp.top);
+    mFloatManager->Translate(-bp.left, -bp.top);
 
     RecoverFloats(aLine, aDeltaY);
 
 #ifdef DEBUG
-    if (nsBlockFrame::gNoisyReflow || nsBlockFrame::gNoisySpaceManager) {
-      mSpaceManager->List(stdout);
+    if (nsBlockFrame::gNoisyReflow || nsBlockFrame::gNoisyFloatManager) {
+      mFloatManager->List(stdout);
     }
 #endif
     // And then put the translation back again
-    mSpaceManager->Translate(bp.left, bp.top);
+    mFloatManager->Translate(bp.left, bp.top);
   }
 }
 
 PRBool
 nsBlockReflowState::IsImpactedByFloat() const
 {
 #ifdef REALLY_NOISY_REFLOW
   printf("nsBlockReflowState::IsImpactedByFloat %p returned %d\n", 
@@ -579,20 +579,20 @@ nsBlockReflowState::AddFloat(nsLineLayou
       (aLineLayout.LineIsEmpty() ||
        mBlock->ComputeFloatWidth(*this, aPlaceholder) <= aAvailableWidth)) {
     // Because we are in the middle of reflowing a placeholder frame
     // within a line (and possibly nested in an inline frame or two
     // that's a child of our block) we need to restore the space
     // manager's translation to the space that the block resides in
     // before placing the float.
     nscoord ox, oy;
-    mSpaceManager->GetTranslation(ox, oy);
-    nscoord dx = ox - mSpaceManagerX;
-    nscoord dy = oy - mSpaceManagerY;
-    mSpaceManager->Translate(-dx, -dy);
+    mFloatManager->GetTranslation(ox, oy);
+    nscoord dx = ox - mFloatManagerX;
+    nscoord dy = oy - mFloatManagerY;
+    mFloatManager->Translate(-dx, -dy);
 
     // And then place it
     PRBool isLeftFloat;
     // force it to fit if we're at the top of the block and we can't
     // break before this
     PRBool forceFit = IsAdjacentWithTop() && !aLineLayout.LineIsBreakable();
     placed = FlowAndPlaceFloat(fc, &isLeftFloat, aReflowStatus, forceFit);
     NS_ASSERTION(placed || !forceFit,
@@ -622,17 +622,17 @@ nsBlockReflowState::AddFloat(nsLineLayou
         // Make sure we propagate the truncated status; this signals the
         // block to push the line to the next page.
         aReflowStatus |= NS_FRAME_TRUNCATED;
       }
       delete fc;
     }
 
     // Restore coordinate system
-    mSpaceManager->Translate(dx, dy);
+    mFloatManager->Translate(dx, dy);
   }
   else {
     // Always claim to be placed; we don't know whether we fit yet, so we
     // deal with this in PlaceBelowCurrentLineFloats
     placed = PR_TRUE;
     // This float will be placed after the line is done (it is a
     // below-current-line float).
     mBelowCurrentLineFloats.Append(fc);
@@ -770,17 +770,17 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
   // Grab the float's display information
   const nsStyleDisplay* floatDisplay = floatFrame->GetStyleDisplay();
 
   // The float's old region, so we can propagate damage.
   nsRect oldRegion = aFloatCache->mRegion;
 
   // Enforce CSS2 9.5.1 rule [2], i.e., make sure that a float isn't
   // ``above'' another float that preceded it in the flow.
-  mY = NS_MAX(mSpaceManager->GetLowestRegionTop() + BorderPadding().top, mY);
+  mY = NS_MAX(mFloatManager->GetLowestRegionTop() + BorderPadding().top, mY);
 
   // See if the float should clear any preceding floats...
   // XXX We need to mark this float somehow so that it gets reflowed
   // when floats are inserted before it.
   if (NS_STYLE_CLEAR_NONE != floatDisplay->mBreakType) {
     // XXXldb Does this handle vertical margins correctly?
     mY = ClearFloats(mY, floatDisplay->mBreakType);
   }
@@ -939,17 +939,17 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
     region.width = 0;
   }
   if (region.height < 0) {
     region.height = 0;
   }
 #ifdef DEBUG
   nsresult rv =
 #endif
-  mSpaceManager->AddRectRegion(floatFrame, region);
+  mFloatManager->AddRectRegion(floatFrame, region);
   NS_ABORT_IF_FALSE(NS_SUCCEEDED(rv), "bad float placement");
 
   // Save away the floats region in the spacemanager, after making
   // it relative to the containing block's frame instead of relative
   // to the spacemanager translation (which is inset by the
   // border+padding).
   // XXX Maybe RecoverFloats should calc/add in the borderPadding itself?
   // It's kind of confusing to have the spacemanager translation be different
@@ -961,25 +961,25 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
   // space manager.
   if (aFloatCache->mRegion != oldRegion) {
     // XXXwaterson conservative: we could probably get away with noting
     // less damage; e.g., if only height has changed, then only note the
     // area into which the float has grown or from which the float has
     // shrunk.
     nscoord top = NS_MIN(region.y, oldRegion.y);
     nscoord bottom = NS_MAX(region.YMost(), oldRegion.YMost());
-    mSpaceManager->IncludeInDamage(top, bottom);
+    mFloatManager->IncludeInDamage(top, bottom);
   }
 
 #ifdef NOISY_SPACEMANAGER
   nscoord tx, ty;
-  mSpaceManager->GetTranslation(tx, ty);
+  mFloatManager->GetTranslation(tx, ty);
   nsFrame::ListTag(stdout, mBlock);
   printf(": FlowAndPlaceFloat: AddRectRegion: txy=%d,%d (%d,%d) {%d,%d,%d,%d}\n",
-         tx, ty, mSpaceManagerX, mSpaceManagerY,
+         tx, ty, mFloatManagerX, mFloatManagerY,
          aFloatCache->mRegion.x, aFloatCache->mRegion.y,
          aFloatCache->mRegion.width, aFloatCache->mRegion.height);
 #endif
 
   // Calculate the actual origin of the float frame's border rect
   // relative to the parent block; floatX/Y must be converted from space-manager
   // coordinates to parent coordinates, and the margin must be added in
   // to get the border rect
@@ -1081,24 +1081,24 @@ nsBlockReflowState::ClearFloats(nscoord 
     printf("clear floats: in: aY=%d(%d)\n",
            aY, aY - BorderPadding().top);
   }
 #endif
 
 #ifdef NOISY_FLOAT_CLEARING
   printf("nsBlockReflowState::ClearFloats: aY=%d breakType=%d\n",
          aY, aBreakType);
-  mSpaceManager->List(stdout);
+  mFloatManager->List(stdout);
 #endif
   
   const nsMargin& bp = BorderPadding();
   nscoord newY = aY;
 
   if (aBreakType != NS_STYLE_CLEAR_NONE) {
-    newY = bp.top + mSpaceManager->ClearFloats(newY - bp.top, aBreakType);
+    newY = bp.top + mFloatManager->ClearFloats(newY - bp.top, aBreakType);
   }
 
   if (aReplacedBlock) {
     for (;;) {
       GetAvailableSpace(newY, PR_FALSE);
       nsBlockFrame::ReplacedElementWidthToClear replacedWidth =
         nsBlockFrame::WidthToClearPastFloats(*this, aReplacedBlock);
       if (mBand.GetFloatCount() == 0 ||
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -51,32 +51,32 @@
   // block reflow state flags
 #define BRS_UNCONSTRAINEDHEIGHT   0x00000001
 #define BRS_ISTOPMARGINROOT       0x00000002  // Is this frame a root for top/bottom margin collapsing?
 #define BRS_ISBOTTOMMARGINROOT    0x00000004
 #define BRS_APPLYTOPMARGIN        0x00000008  // See ShouldApplyTopMargin
 #define BRS_ISFIRSTINFLOW         0x00000010
 // Set when mLineAdjacentToTop is valid
 #define BRS_HAVELINEADJACENTTOTOP 0x00000020
-// Set when the block has the equivalent of NS_BLOCK_SPACE_MGR
-#define BRS_SPACE_MGR             0x00000040
+// Set when the block has the equivalent of NS_BLOCK_FLOAT_MGR
+#define BRS_FLOAT_MGR             0x00000040
 // Set when nsLineLayout::LineIsEmpty was true at the end of reflowing
 // the current line
 #define BRS_LINE_LAYOUT_EMPTY     0x00000080
 #define BRS_ISOVERFLOWCONTAINER   0x00000100
 #define BRS_LASTFLAG              BRS_ISOVERFLOWCONTAINER
 
 class nsBlockReflowState {
 public:
   nsBlockReflowState(const nsHTMLReflowState& aReflowState,
                      nsPresContext* aPresContext,
                      nsBlockFrame* aFrame,
                      const nsHTMLReflowMetrics& aMetrics,
                      PRBool aTopMarginRoot, PRBool aBottomMarginRoot,
-                     PRBool aBlockNeedsSpaceManager);
+                     PRBool aBlockNeedsFloatManager);
 
   ~nsBlockReflowState();
 
   // Set up a property on the block that points to our temporary mOverflowPlaceholders
   // list, if that list is or could become non-empty during this reflow. Must be
   // called after the block has done DrainOverflowLines because DrainOverflowLines
   // can setup mOverflowPlaceholders even if the block is in unconstrained height
   // reflow (it may have previously been reflowed with constrained height).
@@ -187,24 +187,24 @@ public:
 
   // The block frame that is using this object
   nsBlockFrame* mBlock;
 
   nsPresContext* mPresContext;
 
   const nsHTMLReflowState& mReflowState;
 
-  nsSpaceManager* mSpaceManager;
+  nsFloatManager* mFloatManager;
 
   // The coordinates within the spacemanager where the block is being
   // placed <b>after</b> taking into account the blocks border and
   // padding. This, therefore, represents the inner "content area" (in
   // spacemanager coordinates) where child frames will be placed,
   // including child blocks and floats.
-  nscoord mSpaceManagerX, mSpaceManagerY;
+  nscoord mFloatManagerX, mFloatManagerY;
 
   // XXX get rid of this
   nsReflowStatus mReflowStatus;
 
   // The x-position we should place an outside bullet relative to.
   // This is the border-box edge of the principal box.  However, if a line box
   // would be displaced by floats, we want to displace it by the same amount.
   // That is, we act as though the edge of the floats is the content-edge of
diff --git a/layout/generic/nsHTMLParts.h b/layout/generic/nsHTMLParts.h
--- a/layout/generic/nsHTMLParts.h
+++ b/layout/generic/nsHTMLParts.h
@@ -67,17 +67,17 @@ class nsTableColFrame;
  *
  * NS_BLOCK_HAS_FIRST_LETTER_CHILD means that there is an inflow first-letter
  *  frame among the block's descendants. If there is a floating first-letter
  *  frame, or the block has first-letter style but has no first letter, this
  *  bit is not set.
  */
 #define NS_BLOCK_NO_AUTO_MARGINS            0x00200000
 #define NS_BLOCK_MARGIN_ROOT                0x00400000
-#define NS_BLOCK_SPACE_MGR                  0x00800000
+#define NS_BLOCK_FLOAT_MGR                  0x00800000
 #define NS_BLOCK_HAS_FIRST_LETTER_STYLE     0x20000000
 #define NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET   0x40000000
 #define NS_BLOCK_HAS_FIRST_LETTER_CHILD     0x80000000
 // These are the bits that get inherited from a block frame to its
 // next-in-flows and are not private to blocks
 #define NS_BLOCK_FLAGS_MASK                 0xF0E00000 
 
 // Factory methods for creating html layout objects
@@ -104,24 +104,24 @@ NS_NewSelectsAreaFrame(nsIPresShell* aPr
 inline nsIFrame*
 NS_NewTableCellInnerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
   return NS_NewBlockFrame(aPresShell, aContext);
 }
 
 // This type of BlockFrame is a margin root, but does not shrink wrap
 inline nsIFrame*
 NS_NewAbsoluteItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
-  return NS_NewBlockFrame(aPresShell, aContext, NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
+  return NS_NewBlockFrame(aPresShell, aContext, NS_BLOCK_FLOAT_MGR|NS_BLOCK_MARGIN_ROOT);
 }
 
 // This type of BlockFrame shrink wraps
 inline nsIFrame*
 NS_NewFloatingItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
   return NS_NewBlockFrame(aPresShell, aContext,
-    NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
+    NS_BLOCK_FLOAT_MGR|NS_BLOCK_MARGIN_ROOT);
 }
 
 // This type of BlockFrame doesn't use its own space manager and
 // doesn't shrink wrap.
 inline nsIFrame*
 NS_NewRelativeItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags) {
   return NS_NewBlockFrame(aPresShell, aContext, aFlags);
 }
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -91,17 +91,17 @@ nsHTMLReflowState::nsHTMLReflowState(nsP
   , mReflowDepth(0)
 {
   NS_PRECONDITION(aPresContext, "no pres context");
   NS_PRECONDITION(aRenderingContext, "no rendering context");
   NS_PRECONDITION(aFrame, "no frame");
   parentReflowState = nsnull;
   availableWidth = aAvailableSpace.width;
   availableHeight = aAvailableSpace.height;
-  mSpaceManager = nsnull;
+  mFloatManager = nsnull;
   mLineLayout = nsnull;
   mFlags.mSpecialHeightReflow = PR_FALSE;
   mFlags.mIsTopOfPage = PR_FALSE;
   mFlags.mTableIsSplittable = PR_FALSE;
   mFlags.mNextInFlowUntouched = PR_FALSE;
   mFlags.mAssumingHScrollbar = mFlags.mAssumingVScrollbar = PR_FALSE;
   mFlags.mHasClearance = PR_FALSE;
   mFlags.mHeightDependsOnAncestorCell = PR_FALSE;
@@ -150,17 +150,17 @@ nsHTMLReflowState::nsHTMLReflowState(nsP
   // time, as a resize?
   if (!mFlags.mSpecialHeightReflow)
     frame->AddStateBits(parentReflowState->frame->GetStateBits() &
                         NS_FRAME_IS_DIRTY);
 
   availableWidth = aAvailableSpace.width;
   availableHeight = aAvailableSpace.height;
 
-  mSpaceManager = aParentReflowState.mSpaceManager;
+  mFloatManager = aParentReflowState.mFloatManager;
   if (frame->IsFrameOfType(nsIFrame::eLineParticipant))
     mLineLayout = aParentReflowState.mLineLayout;
   else
     mLineLayout = nsnull;
   mFlags.mIsTopOfPage = aParentReflowState.mFlags.mIsTopOfPage;
   mFlags.mNextInFlowUntouched = aParentReflowState.mFlags.mNextInFlowUntouched &&
     CheckNextInFlowParenthood(aFrame, aParentReflowState.frame);
   mFlags.mAssumingHScrollbar = mFlags.mAssumingVScrollbar = PR_FALSE;
diff --git a/layout/generic/nsHTMLReflowState.h b/layout/generic/nsHTMLReflowState.h
--- a/layout/generic/nsHTMLReflowState.h
+++ b/layout/generic/nsHTMLReflowState.h
@@ -41,17 +41,17 @@
 #define nsHTMLReflowState_h___
 
 #include "nsMargin.h"
 #include "nsStyleCoord.h"
 #include "nsIFrame.h"
 
 class nsPresContext;
 class nsIRenderingContext;
-class nsSpaceManager;
+class nsFloatManager;
 class nsLineLayout;
 class nsIPercentHeightObserver;
 
 struct nsStyleDisplay;
 struct nsStyleVisibility;
 struct nsStylePosition;
 struct nsStyleBorder;
 struct nsStyleMargin;
@@ -240,17 +240,17 @@ struct nsHTMLReflowState : public nsCSSO
   // fit in this height.
   nscoord              availableHeight;
 
   // The type of frame, from css's perspective. This value is
   // initialized by the Init method below.
   nsCSSFrameType   mFrameType;
 
   // pointer to the space manager associated with this area
-  nsSpaceManager* mSpaceManager;
+  nsFloatManager* mFloatManager;
 
   // The amount the in-flow position of the block is moving vertically relative
   // to its previous in-flow position (i.e. the amount the line containing the
   // block is moving).
   // This should be zero for anything which is not a block outside, and it
   // should be zero for anything which has a non-block parent.
   // The intended use of this value is to allow the accurate determination
   // of the potential impact of a float
diff --git a/layout/generic/nsLineBox.cpp b/layout/generic/nsLineBox.cpp
--- a/layout/generic/nsLineBox.cpp
+++ b/layout/generic/nsLineBox.cpp
@@ -36,17 +36,17 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* representation of one line within a block frame, a CSS line box */
 
 #include "nsLineBox.h"
-#include "nsSpaceManager.h"
+#include "nsFloatManager.h"
 #include "nsLineLayout.h"
 #include "prprf.h"
 #include "nsBlockFrame.h"
 #include "nsGkAtoms.h"
 #include "nsFrameManager.h"
 #ifdef IBMBIDI
 #include "nsBidiPresUtils.h"
 #endif
diff --git a/layout/generic/nsLineBox.h b/layout/generic/nsLineBox.h
--- a/layout/generic/nsLineBox.h
+++ b/layout/generic/nsLineBox.h
@@ -41,17 +41,17 @@
 /* representation of one line within a block frame, a CSS line box */
 
 #ifndef nsLineBox_h___
 #define nsLineBox_h___
 
 #include "nsPlaceholderFrame.h"
 #include "nsILineIterator.h"
 
-class nsSpaceManager;
+class nsFloatManager;
 class nsLineBox;
 class nsFloatCache;
 class nsFloatCacheList;
 class nsFloatCacheFreeList;
 
 // State cached after reflowing a float. This state is used during
 // incremental reflow when we avoid reflowing a float.
 class nsFloatCache {
diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -47,17 +47,17 @@
 #include "plarena.h"
 
 #include "nsCOMPtr.h"
 #include "nsLineLayout.h"
 #include "nsBlockFrame.h"
 #include "nsInlineFrame.h"
 #include "nsStyleConsts.h"
 #include "nsHTMLContainerFrame.h"
-#include "nsSpaceManager.h"
+#include "nsFloatManager.h"
 #include "nsStyleContext.h"
 #include "nsPresContext.h"
 #include "nsIFontMetrics.h"
 #include "nsIThebesFontMetrics.h"
 #include "nsIRenderingContext.h"
 #include "nsGkAtoms.h"
 #include "nsPlaceholderFrame.h"
 #include "nsIDocument.h"
@@ -88,32 +88,32 @@
 //----------------------------------------------------------------------
 
 #define FIX_BUG_50257
 
 #define PLACED_LEFT  0x1
 #define PLACED_RIGHT 0x2
 
 nsLineLayout::nsLineLayout(nsPresContext* aPresContext,
-                           nsSpaceManager* aSpaceManager,
+                           nsFloatManager* aFloatManager,
                            const nsHTMLReflowState* aOuterReflowState,
                            const nsLineList::iterator* aLine)
   : mPresContext(aPresContext),
-    mSpaceManager(aSpaceManager),
+    mFloatManager(aFloatManager),
     mBlockReflowState(aOuterReflowState),
     mLastOptionalBreakContent(nsnull),
     mForceBreakContent(nsnull),
     mLastOptionalBreakContentOffset(-1),
     mForceBreakContentOffset(-1),
     mLastOptionalBreakPriority(eNoBreak),
     mBlockRS(nsnull),/* XXX temporary */
     mMinLineHeight(0),
     mTextIndent(0)
 {
-  NS_ASSERTION(aSpaceManager || aOuterReflowState->frame->GetType() ==
+  NS_ASSERTION(aFloatManager || aOuterReflowState->frame->GetType() ==
                                   nsGkAtoms::letterFrame,
                "space manager should be present");
   MOZ_COUNT_CTOR(nsLineLayout);
 
   // Stash away some style data that we need
   mStyleText = aOuterReflowState->frame->GetStyleText();
   mTextAlign = mStyleText->mTextAlign;
   mLineNumber = 0;
@@ -836,17 +836,17 @@ nsLineLayout::ReflowFrame(nsIFrame* aFra
   // border+padding before translating.
   nsHTMLReflowMetrics metrics;
 #ifdef DEBUG
   metrics.width = nscoord(0xdeadbeef);
   metrics.height = nscoord(0xdeadbeef);
 #endif
   nscoord tx = x - psd->mReflowState->mComputedBorderPadding.left;
   nscoord ty = y - psd->mReflowState->mComputedBorderPadding.top;
-  mSpaceManager->Translate(tx, ty);
+  mFloatManager->Translate(tx, ty);
 
   nsIAtom* frameType = aFrame->GetType();
   PRInt32 savedOptionalBreakOffset;
   gfxBreakPriority savedOptionalBreakPriority;
   nsIContent* savedOptionalBreakContent =
     GetLastOptionalBreakPosition(&savedOptionalBreakOffset,
                                  &savedOptionalBreakPriority);
 
@@ -944,17 +944,17 @@ nsLineLayout::ReflowFrame(nsIFrame* aFra
       if (pfd->mSpan) {
         isEmpty = !pfd->mSpan->mHasNonemptyContent && pfd->mFrame->IsSelfEmpty();
       } else {
         isEmpty = pfd->mFrame->IsEmpty();
       }
     }
   }
 
-  mSpaceManager->Translate(-tx, -ty);
+  mFloatManager->Translate(-tx, -ty);
 
   NS_ASSERTION(metrics.width>=0, "bad width");
   NS_ASSERTION(metrics.height>=0,"bad height");
   if (metrics.width<0) metrics.width=0;
   if (metrics.height<0) metrics.height=0;
 
 #ifdef DEBUG
   // Note: break-before means ignore the reflow metrics since the
diff --git a/layout/generic/nsLineLayout.h b/layout/generic/nsLineLayout.h
--- a/layout/generic/nsLineLayout.h
+++ b/layout/generic/nsLineLayout.h
@@ -54,24 +54,24 @@
 #include "nsDeque.h"
 #include "nsLineBox.h"
 #include "nsBlockReflowState.h"
 #include "plarena.h"
 #include "gfxTypes.h"
 
 class nsBlockFrame;
 
-class nsSpaceManager;
+class nsFloatManager;
 class nsPlaceholderFrame;
 struct nsStyleText;
 
 class nsLineLayout {
 public:
   nsLineLayout(nsPresContext* aPresContext,
-               nsSpaceManager* aSpaceManager,
+               nsFloatManager* aFloatManager,
                const nsHTMLReflowState* aOuterReflowState,
                const nsLineList::iterator* aLine);
   ~nsLineLayout();
 
   void Init(nsBlockReflowState* aState, nscoord aMinLineHeight,
             PRInt32 aLineNumber) {
     mBlockRS = aState;
     mMinLineHeight = aMinLineHeight;
@@ -368,17 +368,17 @@ public:
    * start content edge is:
    * <code>GetCurrentFrameXDistanceFromBlock() - lineContainer->GetUsedBorderAndPadding().left</code>
    * Note the use of <code>.left</code> for both LTR and RTL line containers.
    */
   nscoord GetCurrentFrameXDistanceFromBlock();
 
 protected:
   // This state is constant for a given block frame doing line layout
-  nsSpaceManager* mSpaceManager;
+  nsFloatManager* mFloatManager;
   const nsStyleText* mStyleText; // for the block
   const nsHTMLReflowState* mBlockReflowState;
 
   nsIContent* mLastOptionalBreakContent;
   nsIContent* mForceBreakContent;
   PRInt32     mLastOptionalBreakContentOffset;
   PRInt32     mForceBreakContentOffset;
   gfxBreakPriority mLastOptionalBreakPriority;
diff --git a/layout/generic/nsSpaceManager.cpp b/layout/generic/nsSpaceManager.cpp
--- a/layout/generic/nsSpaceManager.cpp
+++ b/layout/generic/nsSpaceManager.cpp
@@ -36,17 +36,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 /*
  * class that manages regions of 2-D space, originally designed
  * generally but actually specific to space occupied by floats
  */
 
-#include "nsSpaceManager.h"
+#include "nsFloatManager.h"
 #include "nsPoint.h"
 #include "nsRect.h"
 #include "nsSize.h"
 #include <stdlib.h>
 #include "nsVoidArray.h"
 #include "nsIFrame.h"
 #include "nsString.h"
 #include "nsIPresShell.h"
@@ -55,29 +55,29 @@
 #include "nsHashSets.h"
 #ifdef DEBUG
 #include "nsIFrameDebug.h"
 #endif
 
 /////////////////////////////////////////////////////////////////////////////
 // BandList
 
-PRInt32 nsSpaceManager::sCachedSpaceManagerCount = 0;
-void* nsSpaceManager::sCachedSpaceManagers[NS_SPACE_MANAGER_CACHE_SIZE];
+PRInt32 nsFloatManager::sCachedFloatManagerCount = 0;
+void* nsFloatManager::sCachedFloatManagers[NS_SPACE_MANAGER_CACHE_SIZE];
 
 #define NSCOORD_MIN (-2147483647 - 1) /* minimum signed value */
 
-nsSpaceManager::BandList::BandList()
-  : nsSpaceManager::BandRect(NSCOORD_MIN, NSCOORD_MIN, NSCOORD_MIN, NSCOORD_MIN, (nsIFrame*)nsnull)
+nsFloatManager::BandList::BandList()
+  : nsFloatManager::BandRect(NSCOORD_MIN, NSCOORD_MIN, NSCOORD_MIN, NSCOORD_MIN, (nsIFrame*)nsnull)
 {
   PR_INIT_CLIST(this);
 }
 
 void
-nsSpaceManager::BandList::Clear()
+nsFloatManager::BandList::Clear()
 {
   if (!IsEmpty()) {
     BandRect* bandRect = Head();
   
     while (bandRect != this) {
       BandRect* nxt = bandRect->Next();
   
       delete bandRect;
@@ -100,107 +100,107 @@ PSArenaAllocCB(size_t aSize, void* aClos
 // PresShell Arena free callback (for nsIntervalSet use below)
 static void
 PSArenaFreeCB(size_t aSize, void* aPtr, void* aClosure)
 {
   static_cast<nsIPresShell*>(aClosure)->FreeFrame(aSize, aPtr);
 }
 
 /////////////////////////////////////////////////////////////////////////////
-// nsSpaceManager
+// nsFloatManager
 
-nsSpaceManager::nsSpaceManager(nsIPresShell* aPresShell)
+nsFloatManager::nsFloatManager(nsIPresShell* aPresShell)
   : mLowestTop(NSCOORD_MIN),
     mFloatDamage(PSArenaAllocCB, PSArenaFreeCB, aPresShell),
     mHaveCachedLeftYMost(PR_TRUE),
     mHaveCachedRightYMost(PR_TRUE),
     mMaximalLeftYMost(nscoord_MIN),
     mMaximalRightYMost(nscoord_MIN),
     mCachedBandPosition(nsnull)
 {
-  MOZ_COUNT_CTOR(nsSpaceManager);
+  MOZ_COUNT_CTOR(nsFloatManager);
   mX = mY = 0;
   mFrameInfoMap = nsnull;
 }
 
 void
-nsSpaceManager::ClearFrameInfo()
+nsFloatManager::ClearFrameInfo()
 {
   while (mFrameInfoMap) {
     FrameInfo*  next = mFrameInfoMap->mNext;
     delete mFrameInfoMap;
     mFrameInfoMap = next;
   }
 }
 
-nsSpaceManager::~nsSpaceManager()
+nsFloatManager::~nsFloatManager()
 {
-  MOZ_COUNT_DTOR(nsSpaceManager);
+  MOZ_COUNT_DTOR(nsFloatManager);
   mBandList.Clear();
   ClearFrameInfo();
 }
 
 // static
-void* nsSpaceManager::operator new(size_t aSize) CPP_THROW_NEW
+void* nsFloatManager::operator new(size_t aSize) CPP_THROW_NEW
 {
-  if (sCachedSpaceManagerCount > 0) {
+  if (sCachedFloatManagerCount > 0) {
     // We have cached unused instances of this class, return a cached
     // instance in stead of always creating a new one.
-    return sCachedSpaceManagers[--sCachedSpaceManagerCount];
+    return sCachedFloatManagers[--sCachedFloatManagerCount];
   }
 
   // The cache is empty, this means we haveto create a new instance using
   // the global |operator new|.
   return nsMemory::Alloc(aSize);
 }
 
 void
-nsSpaceManager::operator delete(void* aPtr, size_t aSize)
+nsFloatManager::operator delete(void* aPtr, size_t aSize)
 {
   if (!aPtr)
     return;
   // This space manager is no longer used, if there's still room in
   // the cache we'll cache this space manager, unless the layout
   // module was already shut down.
 
-  if (sCachedSpaceManagerCount < NS_SPACE_MANAGER_CACHE_SIZE &&
-      sCachedSpaceManagerCount >= 0) {
+  if (sCachedFloatManagerCount < NS_SPACE_MANAGER_CACHE_SIZE &&
+      sCachedFloatManagerCount >= 0) {
     // There's still space in the cache for more instances, put this
     // instance in the cache in stead of deleting it.
 
-    sCachedSpaceManagers[sCachedSpaceManagerCount++] = aPtr;
+    sCachedFloatManagers[sCachedFloatManagerCount++] = aPtr;
     return;
   }
 
   // The cache is full, or the layout module has been shut down,
   // delete this space manager.
   nsMemory::Free(aPtr);
 }
 
 
 /* static */
-void nsSpaceManager::Shutdown()
+void nsFloatManager::Shutdown()
 {
   // The layout module is being shut down, clean up the cache and
   // disable further caching.
 
   PRInt32 i;
 
-  for (i = 0; i < sCachedSpaceManagerCount; i++) {
-    void* spaceManager = sCachedSpaceManagers[i];
+  for (i = 0; i < sCachedFloatManagerCount; i++) {
+    void* spaceManager = sCachedFloatManagers[i];
     if (spaceManager)
       nsMemory::Free(spaceManager);
   }
 
   // Disable further caching.
-  sCachedSpaceManagerCount = -1;
+  sCachedFloatManagerCount = -1;
 }
 
 PRBool
-nsSpaceManager::YMost(nscoord& aYMost) const
+nsFloatManager::YMost(nscoord& aYMost) const
 {
   PRBool result;
 
   if (mBandList.IsEmpty()) {
     aYMost = 0;
     result = PR_FALSE;
 
   } else {
@@ -224,17 +224,17 @@ nsSpaceManager::YMost(nscoord& aYMost) c
  * sense.  See bug 403129)
  *
  * @param aBand the first rect in the band
  * @param aY the y-offset in world coordinates
  * @param aMaxSize the size to use to constrain the band data
  * @param aBandData the object to populate with available and unavailable space
  */
 nsresult
-nsSpaceManager::GetBandAvailableSpace(const BandRect* aBand,
+nsFloatManager::GetBandAvailableSpace(const BandRect* aBand,
                                       nscoord         aY,
                                       const nsSize&   aMaxSize,
                                       nsBandData&     aBandData) const
 {
   nscoord          topOfBand = aBand->mTop;
   nscoord          localY = aY - mY;
   nscoord          height = PR_MIN(aBand->mBottom - aY, aMaxSize.height);
   nsBandTrapezoid* trapezoid = aBandData.mTrapezoids;
@@ -329,17 +329,17 @@ nsSpaceManager::GetBandAvailableSpace(co
     *trapezoid = nsRect(left - mX, localY, rightEdge - left, height);
     aBandData.mCount++;
   }
 
   return NS_OK;
 }
 
 nsresult
-nsSpaceManager::GetBandData(nscoord       aYOffset,
+nsFloatManager::GetBandData(nscoord       aYOffset,
                             const nsSize& aMaxSize,
                             nsBandData&   aBandData) const
 {
   NS_PRECONDITION(aBandData.mSize >= 1, "bad band data");
   nsresult  result = NS_OK;
 
   // Convert the y-offset to world coordinates
   nscoord   y = mY + aYOffset;
@@ -385,18 +385,18 @@ nsSpaceManager::GetBandData(nscoord     
 }
 
 /**
  * Skips to the start of the next band.
  *
  * @param aBandRect A rect within the band
  * @returns The start of the next band, or nsnull of this is the last band.
  */
-nsSpaceManager::BandRect*
-nsSpaceManager::GetNextBand(const BandRect* aBandRect) const
+nsFloatManager::BandRect*
+nsFloatManager::GetNextBand(const BandRect* aBandRect) const
 {
   nscoord topOfBand = aBandRect->mTop;
 
   aBandRect = aBandRect->Next();
   while (aBandRect != &mBandList) {
     // Check whether this rect is part of the same band
     if (aBandRect->mTop != topOfBand) {
       // We found the start of the next band
@@ -411,18 +411,18 @@ nsSpaceManager::GetNextBand(const BandRe
 }
 
 /**
  * Skips to the start of the previous band.
  *
  * @param aBandRect The first rect within a band
  * @returns The start of the previous band, or nsnull of this is the first band.
  */
-nsSpaceManager::BandRect*
-nsSpaceManager::GetPrevBand(const BandRect* aBandRect) const
+nsFloatManager::BandRect*
+nsFloatManager::GetPrevBand(const BandRect* aBandRect) const
 {
   NS_ASSERTION(aBandRect->Prev() == &mBandList ||
                aBandRect->Prev()->mBottom <= aBandRect->mTop,
                "aBandRect should be first rect within its band");
 
   BandRect* prev = aBandRect->Prev();
   nscoord topOfBand = prev->mTop;
 
@@ -444,17 +444,17 @@ nsSpaceManager::GetPrevBand(const BandRe
 /**
  * Divides the current band into two vertically
  *
  * @param aBandRect the first rect in the band
  * @param aBottom where to split the band. This becomes the bottom of the top
  *          part
  */
 void
-nsSpaceManager::DivideBand(BandRect* aBandRect, nscoord aBottom)
+nsFloatManager::DivideBand(BandRect* aBandRect, nscoord aBottom)
 {
   NS_PRECONDITION(aBottom < aBandRect->mBottom, "bad height");
   nscoord   topOfBand = aBandRect->mTop;
   BandRect* nextBand = GetNextBand(aBandRect);
 
   if (nsnull == nextBand) {
     nextBand = (BandRect*)&mBandList;
   }
@@ -467,17 +467,17 @@ nsSpaceManager::DivideBand(BandRect* aBa
     nextBand->InsertBefore(bottomBandRect);
 
     // Move to the next rect in the band
     aBandRect = aBandRect->Next();
   }
 }
 
 PRBool
-nsSpaceManager::CanJoinBands(BandRect* aBand, BandRect* aPrevBand)
+nsFloatManager::CanJoinBands(BandRect* aBand, BandRect* aPrevBand)
 {
   PRBool  result;
   nscoord topOfBand = aBand->mTop;
   nscoord topOfPrevBand = aPrevBand->mTop;
 
   // The bands can be joined if:
   // - they're adjacent
   // - they have the same number of rects
@@ -522,17 +522,17 @@ nsSpaceManager::CanJoinBands(BandRect* a
 
 /**
  * Tries to join the two adjacent bands. Returns PR_TRUE if successful and
  * PR_FALSE otherwise
  *
  * If the two bands are joined, the previous band is the band that's deleted
  */
 PRBool
-nsSpaceManager::JoinBands(BandRect* aBand, BandRect* aPrevBand)
+nsFloatManager::JoinBands(BandRect* aBand, BandRect* aPrevBand)
 {
   if (CanJoinBands(aBand, aPrevBand)) {
     BandRect* startOfNextBand = aBand;
     // We're going to be removing aPrevBand, so if mCachedBandPosition points
     // to it just advance it to startOfNextBand.
     if (mCachedBandPosition == aPrevBand) {
       SetCachedBandPosition(startOfNextBand);
     }
@@ -561,17 +561,17 @@ nsSpaceManager::JoinBands(BandRect* aBan
 
 /**
  * Adds a new rect to a band.
  *
  * @param aBand the first rect in the band
  * @param aBandRect the band rect to add to the band
  */
 void
-nsSpaceManager::AddRectToBand(BandRect* aBand, BandRect* aBandRect)
+nsFloatManager::AddRectToBand(BandRect* aBand, BandRect* aBandRect)
 {
   NS_PRECONDITION((aBand->mTop == aBandRect->mTop) &&
                   (aBand->mBottom == aBandRect->mBottom), "bad band");
   NS_PRECONDITION(1 == aBandRect->mFrames.Count(), "shared band rect");
   nscoord topOfBand = aBand->mTop;
 
   // Figure out where in the band horizontally to insert the rect
   do {
@@ -742,17 +742,17 @@ nsSpaceManager::AddRectToBand(BandRect* 
 //          |  B  |    +-----+  +-----+    |  R  |  |  B  |
 //          |     |                        |     |  +-----+
 //          +-----+                        +-----+
 // +-----+
 // |  R  |
 // +-----+
 //
 void
-nsSpaceManager::InsertBandRect(BandRect* aBandRect)
+nsFloatManager::InsertBandRect(BandRect* aBandRect)
 {
   // If there are no existing bands or this rect is below the bottommost
   // band, then add a new band
   nscoord yMost;
   if (!YMost(yMost) || (aBandRect->mTop >= yMost)) {
     mBandList.Append(aBandRect);
     SetCachedBandPosition(aBandRect);
     return;
@@ -842,17 +842,17 @@ nsSpaceManager::InsertBandRect(BandRect*
         SetCachedBandPosition(aBandRect);
         break;
       }
     }
   }
 }
 
 nsresult
-nsSpaceManager::AddRectRegion(nsIFrame* aFrame, const nsRect& aUnavailableSpace)
+nsFloatManager::AddRectRegion(nsIFrame* aFrame, const nsRect& aUnavailableSpace)
 {
   NS_PRECONDITION(nsnull != aFrame, "null frame");
 
   // Convert the frame to world coordinates
   nsRect  rect(aUnavailableSpace.x + mX, aUnavailableSpace.y + mY,
                aUnavailableSpace.width, aUnavailableSpace.height);
 
   if (rect.y > mLowestTop)
@@ -877,17 +877,17 @@ nsSpaceManager::AddRectRegion(nsIFrame* 
   }
 
   // Insert the band rect
   InsertBandRect(bandRect);
   return NS_OK;
 }
 
 nsresult
-nsSpaceManager::RemoveTrailingRegions(nsIFrame* aFrameList) {
+nsFloatManager::RemoveTrailingRegions(nsIFrame* aFrameList) {
   nsVoidHashSet frameSet;
 
   frameSet.Init(1);
   for (nsIFrame* f = aFrameList; f; f = f->GetNextSibling()) {
     frameSet.Put(f);
   }
 
   // Pop frame regions off as long as they're in the set of frames to
@@ -903,17 +903,17 @@ nsSpaceManager::RemoveTrailingRegions(ns
                  "Frame region deletion was requested but we couldn't delete it");
   }
 #endif
 
   return NS_OK;
 }
 
 nsresult
-nsSpaceManager::RemoveRegion(nsIFrame* aFrame)
+nsFloatManager::RemoveRegion(nsIFrame* aFrame)
 {
   // Get the frame info associated with aFrame
   FrameInfo*  frameInfo = GetFrameInfoFor(aFrame);
 
   if (nsnull == frameInfo) {
     NS_WARNING("no region associated with aFrame");
     return NS_ERROR_INVALID_ARG;
   }
@@ -1016,17 +1016,17 @@ nsSpaceManager::RemoveRegion(nsIFrame* a
     }
   }
 
   DestroyFrameInfo(frameInfo);
   return NS_OK;
 }
 
 void
-nsSpaceManager::PushState(SavedState* aState)
+nsFloatManager::PushState(SavedState* aState)
 {
   NS_PRECONDITION(aState, "Need a place to save state");
 
   // This is a cheap push implementation, which
   // only saves the (x,y) and last frame in the mFrameInfoMap
   // which is enough info to get us back to where we should be
   // when pop is called.
   //
@@ -1053,17 +1053,17 @@ nsSpaceManager::PushState(SavedState* aS
   if (mFrameInfoMap) {
     aState->mLastFrame = mFrameInfoMap->mFrame;
   } else {
     aState->mLastFrame = nsnull;
   }
 }
 
 void
-nsSpaceManager::PopState(SavedState* aState)
+nsFloatManager::PopState(SavedState* aState)
 {
   NS_PRECONDITION(aState, "No state to restore?");
 
   // This is a quick and dirty pop implementation, to
   // match the current implementation of PushState(). The
   // idea here is to remove any frames that have been added
   // to the mFrameInfoMap since the last call to PushState().
 
@@ -1092,36 +1092,36 @@ nsSpaceManager::PopState(SavedState* aSt
   mLowestTop = aState->mLowestTop;
   mHaveCachedLeftYMost = aState->mHaveCachedLeftYMost;
   mHaveCachedRightYMost = aState->mHaveCachedRightYMost;
   mMaximalLeftYMost = aState->mMaximalLeftYMost;
   mMaximalRightYMost = aState->mMaximalRightYMost;
 }
 
 nscoord
-nsSpaceManager::GetLowestRegionTop()
+nsFloatManager::GetLowestRegionTop()
 {
   if (mLowestTop == NSCOORD_MIN)
     return mLowestTop;
   return mLowestTop - mY;
 }
 
 #ifdef DEBUG
 void
-DebugListSpaceManager(nsSpaceManager *aSpaceManager)
+DebugListFloatManager(nsFloatManager *aFloatManager)
 {
-  aSpaceManager->List(stdout);
+  aFloatManager->List(stdout);
 }
 
 nsresult
-nsSpaceManager::List(FILE* out)
+nsFloatManager::List(FILE* out)
 {
   nsAutoString tmp;
 
-  fprintf(out, "SpaceManager@%p", this);
+  fprintf(out, "FloatManager@%p", this);
   fprintf(out, " xy=%d,%d <\n", mX, mY);
   if (mBandList.IsEmpty()) {
     fprintf(out, "  no bands\n");
   }
   else {
     BandRect* band = mBandList.Head();
     do {
       PRInt32 const n = band->mFrames.Count();
@@ -1144,32 +1144,32 @@ nsSpaceManager::List(FILE* out)
       band = band->Next();
     } while (band != mBandList.Head());
   }
   fprintf(out, ">\n");
   return NS_OK;
 }
 #endif
 
-nsSpaceManager::FrameInfo*
-nsSpaceManager::GetFrameInfoFor(nsIFrame* aFrame)
+nsFloatManager::FrameInfo*
+nsFloatManager::GetFrameInfoFor(nsIFrame* aFrame)
 {
   FrameInfo*  result = nsnull;
 
   for (result = mFrameInfoMap; result; result = result->mNext) {
     if (result->mFrame == aFrame) {
       break;
     }
   }
 
   return result;
 }
 
-nsSpaceManager::FrameInfo*
-nsSpaceManager::CreateFrameInfo(nsIFrame* aFrame, const nsRect& aRect)
+nsFloatManager::FrameInfo*
+nsFloatManager::CreateFrameInfo(nsIFrame* aFrame, const nsRect& aRect)
 {
   FrameInfo*  frameInfo = new FrameInfo(aFrame, aRect);
 
   if (frameInfo) {
     // Link it into the list
     frameInfo->mNext = mFrameInfoMap;
     mFrameInfoMap = frameInfo;
 
@@ -1185,17 +1185,17 @@ nsSpaceManager::CreateFrameInfo(nsIFrame
              floatType == NS_STYLE_FLOAT_RIGHT) {
       mMaximalRightYMost = ymost;
     }
   }
   return frameInfo;
 }
 
 void
-nsSpaceManager::DestroyFrameInfo(FrameInfo* aFrameInfo)
+nsFloatManager::DestroyFrameInfo(FrameInfo* aFrameInfo)
 {
   // See if it's at the head of the list
   if (mFrameInfoMap == aFrameInfo) {
     mFrameInfoMap = aFrameInfo->mNext;
 
   } else {
     FrameInfo*  prev;
     
@@ -1224,17 +1224,17 @@ nsSpaceManager::DestroyFrameInfo(FrameIn
       mHaveCachedRightYMost = PR_FALSE;
     }
   }
 
   delete aFrameInfo;
 }
 
 nscoord
-nsSpaceManager::ClearFloats(nscoord aY, PRUint8 aBreakType)
+nsFloatManager::ClearFloats(nscoord aY, PRUint8 aBreakType)
 {
   nscoord bottom = aY + mY;
 
   if ((!mHaveCachedLeftYMost && aBreakType != NS_STYLE_CLEAR_RIGHT) ||
       (!mHaveCachedRightYMost && aBreakType != NS_STYLE_CLEAR_LEFT)) {
     // Recover our maximal YMost values.  Might need both if this is a
     // NS_STYLE_CLEAR_LEFT_AND_RIGHT
     nscoord maximalLeftYMost = mHaveCachedLeftYMost ? mMaximalLeftYMost : nscoord_MIN;
@@ -1285,18 +1285,18 @@ nsSpaceManager::ClearFloats(nscoord aY, 
       break;
   }
 
   bottom -= mY;
 
   return bottom;
 }
 
-nsSpaceManager::BandRect*
-nsSpaceManager::GuessBandWithTopAbove(nscoord aYOffset) const
+nsFloatManager::BandRect*
+nsFloatManager::GuessBandWithTopAbove(nscoord aYOffset) const
 {
   NS_ASSERTION(!mBandList.IsEmpty(), "no bands");
   BandRect* band = nsnull;
   if (mCachedBandPosition) {
     band = mCachedBandPosition;
     // Now seek backward so that we're guaranteed to be the topmost
     // band which might contain the y-offset or be below it.
     while (band && band->mTop > aYOffset) {
@@ -1309,93 +1309,93 @@ nsSpaceManager::GuessBandWithTopAbove(ns
   }
   
   return mBandList.Head();
 }
 
 /////////////////////////////////////////////////////////////////////////////
 // FrameInfo
 
-nsSpaceManager::FrameInfo::FrameInfo(nsIFrame* aFrame, const nsRect& aRect)
+nsFloatManager::FrameInfo::FrameInfo(nsIFrame* aFrame, const nsRect& aRect)
   : mFrame(aFrame), mRect(aRect), mNext(0)
 {
-  MOZ_COUNT_CTOR(nsSpaceManager::FrameInfo);
+  MOZ_COUNT_CTOR(nsFloatManager::FrameInfo);
 }
 
 #ifdef NS_BUILD_REFCNT_LOGGING
-nsSpaceManager::FrameInfo::~FrameInfo()
+nsFloatManager::FrameInfo::~FrameInfo()
 {
-  MOZ_COUNT_DTOR(nsSpaceManager::FrameInfo);
+  MOZ_COUNT_DTOR(nsFloatManager::FrameInfo);
 }
 #endif
 
 /////////////////////////////////////////////////////////////////////////////
 // BandRect
 
-nsSpaceManager::BandRect::BandRect(nscoord    aLeft,
+nsFloatManager::BandRect::BandRect(nscoord    aLeft,
                                    nscoord    aTop,
                                    nscoord    aRight,
                                    nscoord    aBottom,
                                    nsIFrame*  aFrame)
 {
   MOZ_COUNT_CTOR(BandRect);
   mLeft = aLeft;
   mTop = aTop;
   mRight = aRight;
   mBottom = aBottom;
   AddFrame(aFrame);
 }
 
-nsSpaceManager::BandRect::BandRect(nscoord      aLeft,
+nsFloatManager::BandRect::BandRect(nscoord      aLeft,
                                    nscoord      aTop,
                                    nscoord      aRight,
                                    nscoord      aBottom,
                                    nsSmallVoidArray& aFrames)
 {
   MOZ_COUNT_CTOR(BandRect);
   mLeft = aLeft;
   mTop = aTop;
   mRight = aRight;
   mBottom = aBottom;
   mFrames = aFrames;
 }
 
-nsSpaceManager::BandRect::~BandRect()
+nsFloatManager::BandRect::~BandRect()
 {
   MOZ_COUNT_DTOR(BandRect);
 }
 
-nsSpaceManager::BandRect*
-nsSpaceManager::BandRect::SplitVertically(nscoord aBottom)
+nsFloatManager::BandRect*
+nsFloatManager::BandRect::SplitVertically(nscoord aBottom)
 {
   NS_PRECONDITION((aBottom > mTop) && (aBottom < mBottom), "bad argument");
 
   // Create a new band rect for the bottom part
   BandRect* bottomBandRect = new BandRect(mLeft, aBottom, mRight, mBottom, mFrames);
                                            
   // This band rect becomes the top part, so adjust the bottom edge
   mBottom = aBottom;
   return bottomBandRect;
 }
 
-nsSpaceManager::BandRect*
-nsSpaceManager::BandRect::SplitHorizontally(nscoord aRight)
+nsFloatManager::BandRect*
+nsFloatManager::BandRect::SplitHorizontally(nscoord aRight)
 {
   NS_PRECONDITION((aRight > mLeft) && (aRight < mRight), "bad argument");
   
   // Create a new band rect for the right part
   BandRect* rightBandRect = new BandRect(aRight, mTop, mRight, mBottom, mFrames);
                                            
   // This band rect becomes the left part, so adjust the right edge
   mRight = aRight;
   return rightBandRect;
 }
 
 PRBool
-nsSpaceManager::BandRect::HasSameFrameList(const BandRect* aBandRect) const
+nsFloatManager::BandRect::HasSameFrameList(const BandRect* aBandRect) const
 {
   const PRInt32 count = mFrames.Count();
 
   // Check whether they're occupied by the same number of frames
   if (count != aBandRect->mFrames.Count()) {
     return PR_FALSE;
   }
   // For each frame occupying this band rect check whether it also occupies
@@ -1409,17 +1409,17 @@ nsSpaceManager::BandRect::HasSameFrameLi
   return PR_TRUE;
 }
 
 /**
  * Internal helper function that counts the number of rects in this band
  * including the current band rect
  */
 PRInt32
-nsSpaceManager::BandRect::Length() const
+nsFloatManager::BandRect::Length() const
 {
   PRInt32   len = 1;
   BandRect* bandRect = Next();
 
   // Because there's a header cell we know we'll either find the next band
   // (which has a different y-offset) or the header cell which has an invalid
   // y-offset
   while (bandRect->mTop == mTop) {
@@ -1428,50 +1428,50 @@ nsSpaceManager::BandRect::Length() const
   }
 
   return len;
 }
 
 
 //----------------------------------------------------------------------
 
-nsAutoSpaceManager::~nsAutoSpaceManager()
+nsAutoFloatManager::~nsAutoFloatManager()
 {
   // Restore the old space manager in the reflow state if necessary.
   if (mNew) {
 #ifdef NOISY_SPACEMANAGER
     printf("restoring old space manager %p\n", mOld);
 #endif
 
-    mReflowState.mSpaceManager = mOld;
+    mReflowState.mFloatManager = mOld;
 
 #ifdef NOISY_SPACEMANAGER
     if (mOld) {
       static_cast<nsFrame *>(mReflowState.frame)->ListTag(stdout);
       printf(": space-manager %p after reflow\n", mOld);
       mOld->List(stdout);
     }
 #endif
 
     delete mNew;
   }
 }
 
 nsresult
-nsAutoSpaceManager::CreateSpaceManager(nsPresContext *aPresContext)
+nsAutoFloatManager::CreateFloatManager(nsPresContext *aPresContext)
 {
   // Create a new space manager and install it in the reflow
   // state. `Remember' the old space manager so we can restore it
   // later.
-  mNew = new nsSpaceManager(aPresContext->PresShell());
+  mNew = new nsFloatManager(aPresContext->PresShell());
   if (! mNew)
     return NS_ERROR_OUT_OF_MEMORY;
 
 #ifdef NOISY_SPACEMANAGER
   printf("constructed new space manager %p (replacing %p)\n",
-         mNew, mReflowState.mSpaceManager);
+         mNew, mReflowState.mFloatManager);
 #endif
 
   // Set the space manager in the existing reflow state
-  mOld = mReflowState.mSpaceManager;
-  mReflowState.mSpaceManager = mNew;
+  mOld = mReflowState.mFloatManager;
+  mReflowState.mFloatManager = mNew;
   return NS_OK;
 }
diff --git a/layout/generic/nsSpaceManager.h b/layout/generic/nsSpaceManager.h
--- a/layout/generic/nsSpaceManager.h
+++ b/layout/generic/nsSpaceManager.h
@@ -36,18 +36,18 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 /*
  * class that manages regions of 2-D space, originally designed
  * generally but actually specific to space occupied by floats
  */
 
-#ifndef nsSpaceManager_h___
-#define nsSpaceManager_h___
+#ifndef nsFloatManager_h___
+#define nsFloatManager_h___
 
 #include "prclist.h"
 #include "nsIntervalSet.h"
 #include "nsISupports.h"
 #include "nsCoord.h"
 #include "nsRect.h"
 #include "nsVoidArray.h"
 
@@ -140,20 +140,20 @@ struct nsBandData {
 };
 
 /**
  * Class for dealing with bands of available space. The space manager
  * defines a coordinate space (relative to the frame that created the
  * space manager) with an origin at (0, 0) that grows down and to the
  * right.
  */
-class nsSpaceManager {
+class nsFloatManager {
 public:
-  nsSpaceManager(nsIPresShell* aPresShell);
-  ~nsSpaceManager();
+  nsFloatManager(nsIPresShell* aPresShell);
+  ~nsFloatManager();
 
   void* operator new(size_t aSize) CPP_THROW_NEW;
   void operator delete(void* aPtr, size_t aSize);
 
   static void Shutdown();
   /**
    * Translate the current origin by the specified (dx, dy). This
    * creates a new local coordinate space relative to the current
@@ -247,17 +247,17 @@ public:
     nsIFrame *mLastFrame;
     nscoord mX, mY;
     nscoord mLowestTop;
     nscoord mMaximalLeftYMost;
     nscoord mMaximalRightYMost;
     PRPackedBool mHaveCachedLeftYMost;
     PRPackedBool mHaveCachedRightYMost;
     
-    friend class nsSpaceManager;
+    friend class nsFloatManager;
   };
 
   PRBool HasAnyFloats() { return mFrameInfoMap != nsnull; }
 
   /**
    * Methods for dealing with the propagation of float damage during
    * reflow.
    */
@@ -447,45 +447,45 @@ protected:
                  aBandRect == mBandList.Head() ||
                  aBandRect->Prev()->mBottom != aBandRect->mBottom,
                  "aBandRect should be first rect within its band");
     mCachedBandPosition = aBandRect;
   }
 
 
 private:
-  static PRInt32 sCachedSpaceManagerCount;
-  static void* sCachedSpaceManagers[NS_SPACE_MANAGER_CACHE_SIZE];
+  static PRInt32 sCachedFloatManagerCount;
+  static void* sCachedFloatManagers[NS_SPACE_MANAGER_CACHE_SIZE];
 
-  nsSpaceManager(const nsSpaceManager&);  // no implementation
-  void operator=(const nsSpaceManager&);  // no implementation
+  nsFloatManager(const nsFloatManager&);  // no implementation
+  void operator=(const nsFloatManager&);  // no implementation
 };
 
 /**
  * A helper class to manage maintenance of the space manager during
  * nsBlockFrame::Reflow. It automatically restores the old space
  * manager in the reflow state when the object goes out of scope.
  */
-class nsAutoSpaceManager {
+class nsAutoFloatManager {
 public:
-  nsAutoSpaceManager(nsHTMLReflowState& aReflowState)
+  nsAutoFloatManager(nsHTMLReflowState& aReflowState)
     : mReflowState(aReflowState),
       mNew(nsnull),
       mOld(nsnull) {}
 
-  ~nsAutoSpaceManager();
+  ~nsAutoFloatManager();
 
   /**
    * Create a new space manager for the specified frame. This will
    * `remember' the old space manager, and install the new space
    * manager in the reflow state.
    */
   nsresult
-  CreateSpaceManager(nsPresContext *aPresContext);
+  CreateFloatManager(nsPresContext *aPresContext);
 
 protected:
   nsHTMLReflowState &mReflowState;
-  nsSpaceManager *mNew;
-  nsSpaceManager *mOld;
+  nsFloatManager *mNew;
+  nsFloatManager *mOld;
 };
 
-#endif /* nsSpaceManager_h___ */
+#endif /* nsFloatManager_h___ */
 
diff --git a/layout/mathml/base/src/nsMathMLContainerFrame.h b/layout/mathml/base/src/nsMathMLContainerFrame.h
--- a/layout/mathml/base/src/nsMathMLContainerFrame.h
+++ b/layout/mathml/base/src/nsMathMLContainerFrame.h
@@ -451,17 +451,17 @@ public:
     return nsBlockFrame::IsFrameOfType(aFlags &
               ~(nsIFrame::eMathML | nsIFrame::eExcludesIgnorableWhitespace));
   }
 
 protected:
   nsMathMLmathBlockFrame(nsStyleContext* aContext) : nsBlockFrame(aContext) {
     // We should always have a space manager.  Not that things can really try
     // to float out of us anyway, but we need one for line layout.
-    AddStateBits(NS_BLOCK_SPACE_MGR);
+    AddStateBits(NS_BLOCK_FLOAT_MGR);
   }
   virtual ~nsMathMLmathBlockFrame() {}
 };
 
 // --------------
 
 class nsMathMLmathInlineFrame : public nsInlineFrame {
 public:
diff --git a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
--- a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
+++ b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
@@ -36,17 +36,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsSVGForeignObjectFrame.h"
 
 #include "nsIDOMSVGForeignObjectElem.h"
 #include "nsIDOMSVGMatrix.h"
 #include "nsIDOMSVGSVGElement.h"
-#include "nsSpaceManager.h"
+#include "nsFloatManager.h"
 #include "nsSVGOuterSVGFrame.h"
 #include "nsRegion.h"
 #include "nsGkAtoms.h"
 #include "nsLayoutUtils.h"
 #include "nsSVGUtils.h"
 #include "nsIURI.h"
 #include "nsSVGRect.h"
 #include "nsSVGMatrix.h"
diff --git a/layout/tables/nsTableOuterFrame.cpp b/layout/tables/nsTableOuterFrame.cpp
--- a/layout/tables/nsTableOuterFrame.cpp
+++ b/layout/tables/nsTableOuterFrame.cpp
@@ -60,17 +60,17 @@
 #define NS_TABLE_FRAME_CAPTION_LIST_INDEX 0
 #define NO_SIDE 100
 
 // caption frame
 nsTableCaptionFrame::nsTableCaptionFrame(nsStyleContext* aContext):
   nsBlockFrame(aContext)
 {
   // shrink wrap 
-  SetFlags(NS_BLOCK_SPACE_MGR);
+  SetFlags(NS_BLOCK_FLOAT_MGR);
 }
 
 nsTableCaptionFrame::~nsTableCaptionFrame()
 {
 }
 
 nsIAtom*
 nsTableCaptionFrame::GetType() const
diff --git a/layout/xul/base/src/nsBoxFrame.cpp b/layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp
+++ b/layout/xul/base/src/nsBoxFrame.cpp
@@ -67,17 +67,17 @@
 #include "nsBoxLayoutState.h"
 #include "nsBoxFrame.h"
 #include "nsStyleContext.h"
 #include "nsPresContext.h"
 #include "nsCOMPtr.h"
 #include "nsINameSpaceManager.h"
 #include "nsGkAtoms.h"
 #include "nsIContent.h"
-#include "nsSpaceManager.h"
+#include "nsFloatManager.h"
 #include "nsHTMLParts.h"
 #include "nsIViewManager.h"
 #include "nsIView.h"
 #include "nsIPresShell.h"
 #include "nsFrameNavigator.h"
 #include "nsCSSRendering.h"
 #include "nsIServiceManager.h"
 #include "nsIBoxLayout.h"
