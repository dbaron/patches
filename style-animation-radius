From: L. David Baron <dbaron@dbaron.org>

Add support for animation of -moz-{border,outline}-radius-*.  (Bug 523450)

diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -310,100 +310,100 @@ CSS_PROP_BORDER(
     -moz-border-radius-topleft,
     _moz_border_radius_topLeft,
     MozBorderRadiusTopleft,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER,
     Margin,
     mBorderRadius.mTopLeft,
     eCSSType_ValuePair,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleBorder, mBorderRadius),
+    eStyleAnimType_Corner_TopLeft)
 CSS_PROP_BORDER(
     -moz-border-radius-topright,
     _moz_border_radius_topRight,
     MozBorderRadiusTopright,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER,
     Margin,
     mBorderRadius.mTopRight,
     eCSSType_ValuePair,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleBorder, mBorderRadius),
+    eStyleAnimType_Corner_TopRight)
 CSS_PROP_BORDER(
     -moz-border-radius-bottomright,
     _moz_border_radius_bottomRight,
     MozBorderRadiusBottomright,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER,
     Margin,
     mBorderRadius.mBottomRight,
     eCSSType_ValuePair,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleBorder, mBorderRadius),
+    eStyleAnimType_Corner_BottomRight)
 CSS_PROP_BORDER(
     -moz-border-radius-bottomleft,
     _moz_border_radius_bottomLeft,
     MozBorderRadiusBottomleft,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER,
     Margin,
     mBorderRadius.mBottomLeft,
     eCSSType_ValuePair,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleBorder, mBorderRadius),
+    eStyleAnimType_Corner_BottomLeft)
 CSS_PROP_SHORTHAND(
     -moz-outline-radius,
     _moz_outline_radius,
     MozOutlineRadius,
     0)
 CSS_PROP_OUTLINE(
     -moz-outline-radius-topleft,
     _moz_outline_radius_topLeft,
     MozOutlineRadiusTopleft,
     0,
     Margin,
     mOutlineRadius.mTopLeft,
     eCSSType_ValuePair,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleOutline, mOutlineRadius),
+    eStyleAnimType_Corner_TopLeft)
 CSS_PROP_OUTLINE(
     -moz-outline-radius-topright,
     _moz_outline_radius_topRight,
     MozOutlineRadiusTopright,
     0,
     Margin,
     mOutlineRadius.mTopRight,
     eCSSType_ValuePair,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleOutline, mOutlineRadius),
+    eStyleAnimType_Corner_TopRight)
 CSS_PROP_OUTLINE(
     -moz-outline-radius-bottomright,
     _moz_outline_radius_bottomRight,
     MozOutlineRadiusBottomright,
     0,
     Margin,
     mOutlineRadius.mBottomRight,
     eCSSType_ValuePair,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleOutline, mOutlineRadius),
+    eStyleAnimType_Corner_BottomRight)
 CSS_PROP_OUTLINE(
     -moz-outline-radius-bottomleft,
     _moz_outline_radius_bottomLeft,
     MozOutlineRadiusBottomleft,
     0,
     Margin,
     mOutlineRadius.mBottomLeft,
     eCSSType_ValuePair,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleOutline, mOutlineRadius),
+    eStyleAnimType_Corner_BottomLeft)
 CSS_PROP_TEXT(
     -moz-tab-size,
     _moz_tab_size,
     MozTabSize,
     0,
     Text,
     mTabSize,
     eCSSType_Value,
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -78,16 +78,23 @@ enum nsStyleAnimType {
 
   // same as Coord, except for one side of an nsStyleSides
   // listed in the same order as the NS_STYLE_* constants
   eStyleAnimType_Sides_Top,
   eStyleAnimType_Sides_Right,
   eStyleAnimType_Sides_Bottom,
   eStyleAnimType_Sides_Left,
 
+  // similar, but for the *pair* of coord members of an nsStyleCorners
+  // for the relevant corner
+  eStyleAnimType_Corner_TopLeft,
+  eStyleAnimType_Corner_TopRight,
+  eStyleAnimType_Corner_BottomRight,
+  eStyleAnimType_Corner_BottomLeft,
+
   // nscoord values
   eStyleAnimType_nscoord,
 
   // enumerated values (stored in a PRUint8)
   // In order for a property to use this unit, _all_ of its enumerated values
   // must be listed in its keyword table, so that any enumerated value can be
   // converted into a string via a nsCSSValue of type eCSSUnit_Enumerated.
   eStyleAnimType_EnumU8,
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -180,16 +180,52 @@ nsStyleAnimation::ComputeDistance(const 
       double diffA = startA - endA;
       double diffR = startR - endR;
       double diffG = startG - endG;
       double diffB = startB - endB;
       aDistance = sqrt(diffA * diffA + diffR * diffR +
                        diffG * diffG + diffB * diffB);
       break;
     }
+    case eUnit_CSSValuePair: {
+      const nsCSSValuePair *pair1 = aStartValue.GetCSSValuePairValue();
+      const nsCSSValuePair *pair2 = aEndValue.GetCSSValuePairValue();
+      if (pair1->mXValue.GetUnit() != pair2->mXValue.GetUnit() ||
+          pair1->mYValue.GetUnit() != pair2->mYValue.GetUnit()) {
+        // At least until we have calc()
+        return PR_FALSE;
+      }
+
+      double distance = 0.0;
+      static nsCSSValue nsCSSValuePair::* const pairValues[] = {
+        &nsCSSValuePair::mXValue, &nsCSSValuePair::mYValue
+      };
+      for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(pairValues); ++i) {
+        nsCSSValue nsCSSValuePair::*member = pairValues[i];
+        NS_ABORT_IF_FALSE((pair1->*member).GetUnit() ==
+                            (pair2->*member).GetUnit(),
+                          "should have returned above");
+        double diff;
+        switch ((pair1->*member).GetUnit()) {
+          case eCSSUnit_Pixel:
+            diff = (pair1->*member).GetFloatValue() -
+                   (pair2->*member).GetFloatValue();
+          case eCSSUnit_Percent:
+            diff = (pair1->*member).GetPercentValue() -
+                   (pair2->*member).GetPercentValue();
+          default:
+            NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
+            return PR_FALSE;
+        }
+        distance += diff * diff;
+      }
+
+      aDistance = sqrt(distance);
+      break;
+    }
     case eUnit_Dasharray: {
       // NOTE: This produces results on substantially different scales
       // for length values and percentage values, which might even be
       // mixed in the same property value.  This means the result isn't
       // particularly useful for paced animation.
 
       // Call AddWeighted to make us lists of the same length.
       Value normValue1, normValue2;
@@ -447,16 +483,59 @@ nsStyleAnimation::AddWeighted(double aCo
         PRUint8 Rres = ClampColor((R1 * aCoeff1 + R2 * aCoeff2) * factor);
         PRUint8 Gres = ClampColor((G1 * aCoeff1 + G2 * aCoeff2) * factor);
         PRUint8 Bres = ClampColor((B1 * aCoeff1 + B2 * aCoeff2) * factor);
         resultColor = NS_RGBA(Rres, Gres, Bres, Ares);
       }
       aResultValue.SetColorValue(resultColor);
       break;
     }
+    case eUnit_CSSValuePair: {
+      const nsCSSValuePair *pair1 = aValue1.GetCSSValuePairValue();
+      const nsCSSValuePair *pair2 = aValue2.GetCSSValuePairValue();
+      if (pair1->mXValue.GetUnit() != pair2->mXValue.GetUnit() ||
+          pair1->mYValue.GetUnit() != pair2->mYValue.GetUnit()) {
+        // At least until we have calc()
+        return PR_FALSE;
+      }
+
+      nsAutoPtr<nsCSSValuePair> result(new nsCSSValuePair);
+      if (!result) {
+        return PR_FALSE;
+      }
+      static nsCSSValue nsCSSValuePair::* const pairValues[] = {
+        &nsCSSValuePair::mXValue, &nsCSSValuePair::mYValue
+      };
+      for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(pairValues); ++i) {
+        nsCSSValue nsCSSValuePair::*member = pairValues[i];
+        NS_ABORT_IF_FALSE((pair1->*member).GetUnit() ==
+                            (pair2->*member).GetUnit(),
+                          "should have returned above");
+        switch ((pair1->*member).GetUnit()) {
+          case eCSSUnit_Pixel:
+            (result->*member).SetFloatValue(
+              aCoeff1 * (pair1->*member).GetFloatValue() +
+              aCoeff2 * (pair2->*member).GetFloatValue(),
+              eCSSUnit_Pixel);
+            break;
+          case eCSSUnit_Percent:
+            (result->*member).SetPercentValue(
+              aCoeff1 * (pair1->*member).GetPercentValue() +
+              aCoeff2 * (pair2->*member).GetPercentValue());
+            break;
+          default:
+            NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
+            return PR_FALSE;
+        }
+      }
+
+      aResultValue.SetCSSValuePairValue(result.forget(), eUnit_CSSValuePair,
+                                        PR_TRUE);
+      break;
+    }
     case eUnit_Dasharray: {
       const nsCSSValueList *list1 = aValue1.GetCSSValueListValue();
       const nsCSSValueList *list2 = aValue2.GetCSSValueListValue();
 
       PRUint32 len1 = 0, len2 = 0;
       for (const nsCSSValueList *v = list1; v; v = v->mNext) {
         ++len1;
       }
@@ -714,16 +793,22 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
           SetBothValuesTo(val);
       } else {
         NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
                           "type mismatch");
         static_cast<nsCSSValue*>(aSpecifiedValue)->
           SetColorValue(aComputedValue.GetColorValue());
       }
       break;
+    case eUnit_CSSValuePair:
+      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
+                          eCSSType_ValuePair, "type mismatch");
+      *static_cast<nsCSSValuePair*>(aSpecifiedValue) =
+        *aComputedValue.GetCSSValuePairValue();
+      break;
     case eUnit_Dasharray:
     case eUnit_Shadow:
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
                           eCSSType_ValueList, "type mismatch");
       *static_cast<nsCSSValueList**>(aSpecifiedValue) =
         aComputedValue.GetCSSValueListValue();
       break;
     default:
@@ -829,16 +914,33 @@ StyleCoordToValue(const nsStyleCoord& aC
       aValue.SetIntValue(aCoord.GetIntValue(),
                          nsStyleAnimation::eUnit_Enumerated);
     case eStyleUnit_Integer:
       return PR_FALSE;
   }
   return PR_TRUE;
 }
 
+static void
+StyleCoordToCSSValue(const nsStyleCoord& aCoord, nsCSSValue& aCSSValue)
+{
+  switch (aCoord.GetUnit()) {
+    case eStyleUnit_Coord:
+      aCSSValue.SetFloatValue(nsPresContext::AppUnitsToFloatCSSPixels(
+                                aCoord.GetCoordValue()),
+                              eCSSUnit_Pixel);
+      break;
+    case eStyleUnit_Percent:
+      aCSSValue.SetPercentValue(aCoord.GetPercentValue());
+      break;
+    default:
+      NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
+  }
+}
+
 PRBool
 nsStyleAnimation::ExtractComputedValue(nsCSSProperty aProperty,
                                        nsStyleContext* aStyleContext,
                                        Value& aComputedValue)
 {
   NS_ABORT_IF_FALSE(0 <= aProperty &&
                     aProperty < eCSSProperty_COUNT_no_shorthands,
                     "bad property");
@@ -965,16 +1067,46 @@ nsStyleAnimation::ExtractComputedValue(n
                          == NS_SIDE_BOTTOM);
       PR_STATIC_ASSERT(eStyleAnimType_Sides_Left - eStyleAnimType_Sides_Top
                          == NS_SIDE_LEFT);
       const nsStyleCoord &coord = static_cast<const nsStyleSides*>(
         StyleDataAtOffset(styleStruct, ssOffset))->
           Get(animType - eStyleAnimType_Sides_Top);
       return StyleCoordToValue(coord, aComputedValue);
     }
+    case eStyleAnimType_Corner_TopLeft:
+    case eStyleAnimType_Corner_TopRight:
+    case eStyleAnimType_Corner_BottomRight:
+    case eStyleAnimType_Corner_BottomLeft: {
+      PR_STATIC_ASSERT(0 == NS_CORNER_TOP_LEFT);
+      PR_STATIC_ASSERT(eStyleAnimType_Corner_TopRight -
+                         eStyleAnimType_Corner_TopLeft
+                       == NS_CORNER_TOP_RIGHT);
+      PR_STATIC_ASSERT(eStyleAnimType_Corner_BottomRight -
+                         eStyleAnimType_Corner_TopLeft
+                       == NS_CORNER_BOTTOM_RIGHT);
+      PR_STATIC_ASSERT(eStyleAnimType_Corner_BottomLeft -
+                         eStyleAnimType_Corner_TopLeft
+                       == NS_CORNER_BOTTOM_LEFT);
+      const nsStyleCorners *corners = static_cast<const nsStyleCorners*>(
+        StyleDataAtOffset(styleStruct, ssOffset));
+      PRUint8 fullCorner = animType - eStyleAnimType_Corner_TopLeft;
+      const nsStyleCoord &horiz =
+        corners->Get(NS_FULL_TO_HALF_CORNER(fullCorner, PR_FALSE));
+      const nsStyleCoord &vert =
+        corners->Get(NS_FULL_TO_HALF_CORNER(fullCorner, PR_TRUE));
+      nsCSSValuePair *pair = new nsCSSValuePair;
+      if (!pair) {
+        return PR_FALSE;
+      }
+      StyleCoordToCSSValue(horiz, pair->mXValue);
+      StyleCoordToCSSValue(vert, pair->mYValue);
+      aComputedValue.SetCSSValuePairValue(pair, eUnit_CSSValuePair, PR_TRUE);
+      return PR_TRUE;
+    }
     case eStyleAnimType_nscoord:
       aComputedValue.SetCoordValue(*static_cast<const nscoord*>(
         StyleDataAtOffset(styleStruct, ssOffset)));
       return PR_TRUE;
     case eStyleAnimType_EnumU8:
       aComputedValue.SetIntValue(*static_cast<const PRUint8*>(
         StyleDataAtOffset(styleStruct, ssOffset)), eUnit_Enumerated);
       return PR_TRUE;
@@ -1112,20 +1244,34 @@ nsStyleAnimation::Value::operator=(const
       break;
     case eUnit_Percent:
     case eUnit_Float:
       mValue.mFloat = aOther.mValue.mFloat;
       break;
     case eUnit_Color:
       mValue.mColor = aOther.mValue.mColor;
       break;
+    case eUnit_CSSValuePair:
+      NS_ABORT_IF_FALSE(aOther.mValue.mCSSValuePair,
+                        "value pairs may not be null");
+      mValue.mCSSValuePair = new nsCSSValuePair(*aOther.mValue.mCSSValuePair);
+      if (!mValue.mCSSValuePair) {
+        mUnit = eUnit_Null;
+      }
+      break;
     case eUnit_Dasharray:
     case eUnit_Shadow:
+      NS_ABORT_IF_FALSE(mUnit != eUnit_Dasharray || aOther.mValue.mCSSValueList,
+                        "dasharrays may not be null");
       mValue.mCSSValueList = aOther.mValue.mCSSValueList
                                ? aOther.mValue.mCSSValueList->Clone() : nsnull;
+      if (mUnit == eUnit_Dasharray && !mValue.mCSSValueList) {
+        mUnit = eUnit_Null;
+      }
+      break;
   }
 
   return *this;
 }
 
 void
 nsStyleAnimation::Value::SetNormalValue()
 {
@@ -1183,22 +1329,43 @@ void
 nsStyleAnimation::Value::SetColorValue(nscolor aColor)
 {
   FreeValue();
   mUnit = eUnit_Color;
   mValue.mColor = aColor;
 }
 
 void
+nsStyleAnimation::Value::SetCSSValuePairValue(nsCSSValuePair *aValuePair,
+                                              Unit aUnit,
+                                              PRBool aTakeOwnership)
+{
+  FreeValue();
+  NS_ABORT_IF_FALSE(IsCSSValuePairUnit(aUnit), "bad unit");
+  NS_ABORT_IF_FALSE(aValuePair != nsnull, "value pairs may not be null");
+  mUnit = aUnit;
+  if (aTakeOwnership) {
+    mValue.mCSSValuePair = aValuePair;
+  } else {
+    mValue.mCSSValuePair = new nsCSSValuePair(*aValuePair);
+    if (!mValue.mCSSValuePair) {
+      mUnit = eUnit_Null;
+    }
+  }
+}
+
+void
 nsStyleAnimation::Value::SetCSSValueListValue(nsCSSValueList *aValueList,
                                               Unit aUnit,
                                               PRBool aTakeOwnership)
 {
   FreeValue();
-  NS_ASSERTION(IsCSSValueListUnit(aUnit), "bad unit");
+  NS_ABORT_IF_FALSE(IsCSSValueListUnit(aUnit), "bad unit");
+  NS_ABORT_IF_FALSE(aUnit != eUnit_Dasharray || aValueList != nsnull,
+                    "dasharrays may not be null");
   mUnit = aUnit;
   if (aTakeOwnership) {
     mValue.mCSSValueList = aValueList;
   } else {
     mValue.mCSSValueList = aValueList ? aValueList->Clone() : nsnull;
   }
 }
 
@@ -1227,16 +1394,18 @@ nsStyleAnimation::Value::operator==(cons
       return mValue.mInt == aOther.mValue.mInt;
     case eUnit_Coord:
       return mValue.mCoord == aOther.mValue.mCoord;
     case eUnit_Percent:
     case eUnit_Float:
       return mValue.mFloat == aOther.mValue.mFloat;
     case eUnit_Color:
       return mValue.mColor == aOther.mValue.mColor;
+    case eUnit_CSSValuePair:
+      return *mValue.mCSSValuePair == *aOther.mValue.mCSSValuePair;
     case eUnit_Dasharray:
     case eUnit_Shadow:
       return nsCSSValueList::Equal(mValue.mCSSValueList,
                                    aOther.mValue.mCSSValueList);
   }
 
   NS_NOTREACHED("incomplete case");
   return PR_FALSE;
diff --git a/layout/style/nsStyleAnimation.h b/layout/style/nsStyleAnimation.h
--- a/layout/style/nsStyleAnimation.h
+++ b/layout/style/nsStyleAnimation.h
@@ -48,16 +48,17 @@
 #include "nsCoord.h"
 #include "nsColor.h"
 
 class nsCSSDeclaration;
 class nsIContent;
 class nsPresContext;
 class nsStyleContext;
 struct nsCSSValueList;
+struct nsCSSValuePair;
 
 /**
  * Utility class to handle animated style values
  */
 class nsStyleAnimation {
 public:
   class Value;
 
@@ -221,28 +222,30 @@ public:
     eUnit_Normal,
     eUnit_Auto,
     eUnit_None,
     eUnit_Enumerated,
     eUnit_Coord,
     eUnit_Percent,
     eUnit_Float,
     eUnit_Color,
+    eUnit_CSSValuePair, // nsCSSValuePair* (never null)
     eUnit_Dasharray, // nsCSSValueList* (never null)
     eUnit_Shadow  // nsCSSValueList* (may be null)
   };
 
   class Value {
   private:
     Unit mUnit;
     union {
       PRInt32 mInt;
       nscoord mCoord;
       float mFloat;
       nscolor mColor;
+      nsCSSValuePair* mCSSValuePair;
       nsCSSValueList* mCSSValueList;
     } mValue;
   public:
     Unit GetUnit() const {
       NS_ASSERTION(mUnit != eUnit_Null, "uninitialized");
       return mUnit;
     }
 
@@ -267,16 +270,20 @@ public:
     float GetFloatValue() const {
       NS_ASSERTION(mUnit == eUnit_Float, "unit mismatch");
       return mValue.mFloat;
     }
     nscolor GetColorValue() const {
       NS_ASSERTION(mUnit == eUnit_Color, "unit mismatch");
       return mValue.mColor;
     }
+    nsCSSValuePair* GetCSSValuePairValue() const {
+      NS_ASSERTION(IsCSSValuePairUnit(mUnit), "unit mismatch");
+      return mValue.mCSSValuePair;
+    }
     nsCSSValueList* GetCSSValueListValue() const {
       NS_ASSERTION(IsCSSValueListUnit(mUnit), "unit mismatch");
       return mValue.mCSSValueList;
     }
 
     explicit Value(Unit aUnit = eUnit_Null) : mUnit(aUnit) {
       NS_ASSERTION(aUnit == eUnit_Null || aUnit == eUnit_Normal ||
                    aUnit == eUnit_Auto || aUnit == eUnit_None,
@@ -301,25 +308,30 @@ public:
     void SetNoneValue();
     void SetIntValue(PRInt32 aInt, Unit aUnit);
     void SetCoordValue(nscoord aCoord);
     void SetPercentValue(float aPercent);
     void SetFloatValue(float aFloat);
     void SetColorValue(nscolor aColor);
     void SetCSSValueListValue(nsCSSValueList *aValue, Unit aUnit,
                               PRBool aTakeOwnership);
+    void SetCSSValuePairValue(nsCSSValuePair *aValue, Unit aUnit,
+                              PRBool aTakeOwnership);
 
     Value& operator=(const Value& aOther);
 
     PRBool operator==(const Value& aOther) const;
     PRBool operator!=(const Value& aOther) const
       { return !(*this == aOther); }
 
   private:
     void FreeValue();
 
+    static PRBool IsCSSValuePairUnit(Unit aUnit) {
+      return aUnit == eUnit_CSSValuePair;
+    }
     static PRBool IsCSSValueListUnit(Unit aUnit) {
       return aUnit == eUnit_Dasharray || aUnit == eUnit_Shadow;
     }
   };
 };
 
 #endif
diff --git a/layout/style/test/test_transitions_per_property.html b/layout/style/test/test_transitions_per_property.html
--- a/layout/style/test/test_transitions_per_property.html
+++ b/layout/style/test/test_transitions_per_property.html
@@ -42,20 +42,28 @@ function has_num(str)
 }
 
 function any_unit_to_num(str)
 {
     return Number(String(str).match(/^([\d.]+)/)[1]);
 }
 
 var supported_properties = {
+    "-moz-border-radius-bottomleft": [ test_radius_transition ],
+    "-moz-border-radius-bottomright": [ test_radius_transition ],
+    "-moz-border-radius-topleft": [ test_radius_transition ],
+    "-moz-border-radius-topright": [ test_radius_transition ],
     "-moz-box-shadow": [ test_shadow_transition ],
     "-moz-column-gap": [ test_length_transition ],
     "-moz-column-rule-color": [ test_color_transition ],
     "-moz-column-width": [ test_length_transition ],
+    "-moz-outline-radius-bottomleft": [ test_radius_transition ],
+    "-moz-outline-radius-bottomright": [ test_radius_transition ],
+    "-moz-outline-radius-topleft": [ test_radius_transition ],
+    "-moz-outline-radius-topright": [ test_radius_transition ],
     "background-color": [ test_color_transition ],
     "border-bottom-color": [ test_color_transition ],
     "border-bottom-width": [ test_length_transition ],
     "border-left-color": [ test_color_transition ],
     "border-left-width": [ test_length_transition ],
     "border-right-color": [ test_color_transition ],
     "border-right-width": [ test_length_transition ],
     "border-top-color": [ test_color_transition ],
@@ -354,12 +362,55 @@ function test_dasharray_transition(prop)
   div.style.setProperty(prop, "2,50%,6,8", "");
   is(cs.getPropertyValue(prop), "2, 50%, 6, 8",
      "dasharray-valued property " + prop + ": non-interpolability of mixed units");
   div.style.setProperty(prop, "4,20%,2,2", "");
   is(cs.getPropertyValue(prop), "3, 35%, 4, 5",
      "dasharray-valued property " + prop + ": interpolation of dasharray");
 }
 
+function test_radius_transition(prop) {
+  div.style.setProperty("-moz-transition-property", "none", "");
+
+  // FIXME: Test a square for now, since we haven't updated to the spec
+  // for vertical components being relative to the height.
+  div.style.setProperty("width", "200px", "");
+  div.style.setProperty("height", "200px", "");
+  div.style.setProperty("border", "none", "");
+  div.style.setProperty("padding", "0", "");
+
+  div.style.setProperty(prop, "3px", "");
+  is(cs.getPropertyValue(prop), "3px",
+     "radius-valued property " + prop +
+     ": computed value before transition");
+  div.style.setProperty("-moz-transition-property", prop, "");
+  div.style.setProperty(prop, "9px", "");
+  is(cs.getPropertyValue(prop), "6px",
+     "radius-valued property " + prop + ": interpolation of radius");
+  div.style.setProperty(prop, "5%", "");
+  is(cs.getPropertyValue(prop), "10px",
+     "radius-valued property " + prop + ": non-interpolability of unit change");
+  div.style.setProperty(prop, "25%", "");
+  is(cs.getPropertyValue(prop), "30px",
+     "radius-valued property " + prop + ": interpolation of radius");
+  div.style.setProperty(prop, "3px 8px", "");
+  is(cs.getPropertyValue(prop), "3px 8px",
+     "radius-valued property " + prop + ": non-interpolability of unit change");
+  div.style.setProperty(prop, "9px 10px", "");
+  is(cs.getPropertyValue(prop), "6px 9px",
+     "radius-valued property " + prop + ": interpolation of radius");
+  div.style.setProperty(prop, "5% 15%", "");
+  is(cs.getPropertyValue(prop), "10px 30px",
+     "radius-valued property " + prop + ": non-interpolability of unit change");
+  div.style.setProperty(prop, "25%", "");
+  is(cs.getPropertyValue(prop), "30px 40px",
+     "radius-valued property " + prop + ": interpolation of radius");
+
+  div.style.removeProperty("width");
+  div.style.removeProperty("height");
+  div.style.removeProperty("border");
+  div.style.removeProperty("padding");
+}
+
 </script>
 </pre>
 </body>
 </html>
