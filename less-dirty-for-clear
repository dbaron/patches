From: L. David Baron <dbaron@dbaron.org>

Avoid marking lines dirty because of clearance inside during append-only reflows.  (Bug 481128)  (NOT YET COMPATIBLE WITH IREFLOW)

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -2637,16 +2637,18 @@ nsPresContext::ReflowStarted(bool aInter
   // start.
   mHasPendingInterrupt = false;
 
   mInterruptChecksToSkip = sInterruptChecksToSkip;
 
   if (mInterruptsEnabled) {
     mReflowStartTime = TimeStamp::Now();
   }
+
+  mBelowSomethingDirty = false;
 }
 
 bool
 nsPresContext::CheckForInterrupt(nsIFrame* aFrame)
 {
   if (mHasPendingInterrupt) {
     mShell->FrameNeedsToContinueReflow(aFrame);
     return true;
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -1017,16 +1017,25 @@ public:
   }
 
   void SetExistThrottledUpdates(bool aExistThrottledUpdates) {
     mExistThrottledUpdates = aExistThrottledUpdates;
   }
 
   bool IsDeviceSizePageSize();
 
+  /**
+   * State that is cleared each reflow, to indicate that something
+   * earlier in the document was dirty during this reflow.  This is
+   * helpful for optimizing incremental reflows that occur during
+   * document loading to avoid O(N^2) algorithms.
+   */
+  void SetBelowSomethingDirty() { mBelowSomethingDirty = true; }
+  bool IsBelowSomethingDirty() { return mBelowSomethingDirty; }
+
 protected:
   friend class nsRunnableMethod<nsPresContext>;
   NS_HIDDEN_(void) ThemeChangedInternal();
   NS_HIDDEN_(void) SysColorChangedInternal();
   NS_HIDDEN_(void) UIResolutionChangedInternal();
 
   static NS_HIDDEN_(bool)
   UIResolutionChangedSubdocumentCallback(nsIDocument* aDocument, void* aData);
@@ -1310,16 +1319,18 @@ protected:
   // the document rather than to change the document's dimensions
   unsigned              mSupressResizeReflow : 1;
 
   unsigned              mIsVisual : 1;
 
   unsigned              mProcessingRestyles : 1;
   unsigned              mProcessingAnimationStyleChange : 1;
 
+  unsigned              mBelowSomethingDirty : 1;
+
   unsigned              mFireAfterPaintEvents : 1;
 
   unsigned              mIsChrome : 1;
 
   // Should we paint flash in this context? Do not use this variable directly.
   // Use GetPaintFlashing() method instead.
   mutable unsigned mPaintFlashing : 1;
   mutable unsigned mPaintFlashingInitialized : 1;
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1904,16 +1904,17 @@ nsBlockFrame::ReflowDirtyLines(nsBlockRe
 
     if (selfDirty)
       line->MarkDirty();
 
     // This really sucks, but we have to look inside any blocks that have clear
     // elements inside them.
     // XXX what can we do smarter here?
     if (!line->IsDirty() && line->IsBlock() &&
+        aState.mPresContext->IsBelowSomethingDirty() &&
         (line->mFirstChild->GetStateBits() & NS_BLOCK_HAS_CLEAR_CHILDREN)) {
       line->MarkDirty();
     }
 
     nsIFrame *replacedBlock = nullptr;
     if (line->IsBlock() &&
         !nsBlockFrame::BlockCanIntersectFloats(line->mFirstChild)) {
       replacedBlock = line->mFirstChild;
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -4162,16 +4162,21 @@ nsFrame::WillReflow(nsPresContext* aPres
   // bug 81268
   NS_ASSERTION(!(mState & NS_FRAME_IN_REFLOW),
                "nsFrame::WillReflow: frame is already in reflow");
 #endif
 
   NS_FRAME_TRACE_MSG(NS_FRAME_TRACE_CALLS,
                      ("WillReflow: oldState=%x", mState));
   mState |= NS_FRAME_IN_REFLOW;
+
+  if (mState & NS_FRAME_IS_DIRTY) {
+    PresContext()->SetBelowSomethingDirty();
+  }
+
   return NS_OK;
 }
 
 nsresult
 nsFrame::DidReflow(nsPresContext*           aPresContext,
                    const nsHTMLReflowState*  aReflowState,
                    nsDidReflowStatus         aStatus)
 {
