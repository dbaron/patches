From: L. David Baron <dbaron@dbaron.org>

Avoid marking lines dirty because of clearance inside during append-only reflows.  (Bug 481128)  (NOT YET COMPATIBLE WITH IREFLOW)

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -2127,16 +2127,18 @@ nsPresContext::ReflowStarted(PRBool aInt
   // we ever change that, then we need to update the code in
   // PresShell::DoReflow to only add the just-reflown root to dirty roots if
   // it's actually dirty.  Otherwise we can end up adding a root that has no
   // interruptible descendants, just because we detected an interrupt at reflow
   // start.
   mHasPendingInterrupt = PR_FALSE;
 
   mInterruptChecksToSkip = sInterruptChecksToSkip;
+
+  mBelowSomethingDirty = PR_FALSE;
 }
 
 PRBool
 nsPresContext::CheckForInterrupt(nsIFrame* aFrame)
 {
   if (mHasPendingInterrupt) {
     mShell->FrameNeedsToContinueReflow(aFrame);
     return PR_TRUE;
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -894,16 +894,26 @@ public:
 
 #ifdef MOZ_SMIL
   /**
    * Indicates that the given element's SMIL Override Style has changed,
    * and as a result, we need to update our display.
    */
   void SMILOverrideStyleChanged(nsIContent* aContent);
 #endif // MOZ_SMIL
+
+  /**
+   * State that is cleared each reflow, to indicate that something
+   * earlier in the document was dirty during this reflow.  This is
+   * helpful for optimizing incremental reflows that occur during
+   * document loading to avoid O(N^2) algorithms.
+   */
+  void SetBelowSomethingDirty() { mBelowSomethingDirty = PR_TRUE; }
+  PRBool IsBelowSomethingDirty() { return mBelowSomethingDirty; }
+
 protected:
   friend class nsRunnableMethod<nsPresContext>;
   NS_HIDDEN_(void) ThemeChangedInternal();
   NS_HIDDEN_(void) SysColorChangedInternal();
 
   NS_HIDDEN_(void) SetImgAnimations(nsIContent *aParent, PRUint16 aMode);
 #ifdef MOZ_SMIL
   NS_HIDDEN_(void) SetSMILAnimations(nsIDocument *aDoc, PRUint16 aNewMode,
@@ -1054,16 +1064,18 @@ protected:
   // resize reflow is supressed when the only change has been to zoom
   // the document rather than to change the document's dimensions
   unsigned              mSupressResizeReflow : 1;
 
   unsigned              mIsVisual : 1;
 
   unsigned              mProcessingAnimationStyleChange : 1;
 
+  unsigned              mBelowSomethingDirty : 1;
+
 #ifdef DEBUG
   PRBool                mInitialized;
 #endif
 
 
 protected:
 
   virtual ~nsPresContext() NS_HIDDEN;
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1755,16 +1755,17 @@ nsBlockFrame::ReflowDirtyLines(nsBlockRe
 
     if (selfDirty)
       line->MarkDirty();
 
     // This really sucks, but we have to look inside any blocks that have clear
     // elements inside them.
     // XXX what can we do smarter here?
     if (!line->IsDirty() && line->IsBlock() &&
+        aState.mPresContext->IsBelowSomethingDirty() &&
         (line->mFirstChild->GetStateBits() & NS_BLOCK_HAS_CLEAR_CHILDREN)) {
       line->MarkDirty();
     }
 
     nsIFrame *replacedBlock = nsnull;
     if (line->IsBlock() &&
         !nsBlockFrame::BlockCanIntersectFloats(line->mFirstChild)) {
       replacedBlock = line->mFirstChild;
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -3290,16 +3290,21 @@ nsFrame::WillReflow(nsPresContext* aPres
   // bug 81268
   NS_ASSERTION(!(mState & NS_FRAME_IN_REFLOW),
                "nsFrame::WillReflow: frame is already in reflow");
 #endif
 
   NS_FRAME_TRACE_MSG(NS_FRAME_TRACE_CALLS,
                      ("WillReflow: oldState=%x", mState));
   mState |= NS_FRAME_IN_REFLOW;
+
+  if (mState & NS_FRAME_IS_DIRTY) {
+    PresContext()->SetBelowSomethingDirty();
+  }
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsFrame::DidReflow(nsPresContext*           aPresContext,
                    const nsHTMLReflowState*  aReflowState,
                    nsDidReflowStatus         aStatus)
 {
