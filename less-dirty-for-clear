From: L. David Baron <dbaron@dbaron.org>

Avoid marking lines dirty because of clearance inside during append-only reflows.  (Bug 481128)  (NOT YET COMPATIBLE WITH IREFLOW)

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -2239,16 +2239,18 @@ nsPresContext::ReflowStarted(bool aInter
   // start.
   mHasPendingInterrupt = false;
 
   mInterruptChecksToSkip = sInterruptChecksToSkip;
 
   if (mInterruptsEnabled) {
     mReflowStartTime = TimeStamp::Now();
   }
+
+  mBelowSomethingDirty = false;
 }
 
 bool
 nsPresContext::CheckForInterrupt(nsIFrame* aFrame)
 {
   if (mHasPendingInterrupt) {
     mShell->FrameNeedsToContinueReflow(aFrame);
     return true;
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -981,16 +981,25 @@ public:
 
     result += sizeof(nsPresContext);
 
     return result;
   }
 
   bool IsRootContentDocument();
 
+  /**
+   * State that is cleared each reflow, to indicate that something
+   * earlier in the document was dirty during this reflow.  This is
+   * helpful for optimizing incremental reflows that occur during
+   * document loading to avoid O(N^2) algorithms.
+   */
+  void SetBelowSomethingDirty() { mBelowSomethingDirty = true; }
+  bool IsBelowSomethingDirty() { return mBelowSomethingDirty; }
+
 protected:
   friend class nsRunnableMethod<nsPresContext>;
   NS_HIDDEN_(void) ThemeChangedInternal();
   NS_HIDDEN_(void) SysColorChangedInternal();
 
   NS_HIDDEN_(void) SetImgAnimations(nsIContent *aParent, PRUint16 aMode);
 #ifdef MOZ_SMIL
   NS_HIDDEN_(void) SetSMILAnimations(nsIDocument *aDoc, PRUint16 aNewMode,
@@ -1157,16 +1166,18 @@ protected:
   // the document rather than to change the document's dimensions
   unsigned              mSupressResizeReflow : 1;
 
   unsigned              mIsVisual : 1;
 
   unsigned              mProcessingRestyles : 1;
   unsigned              mProcessingAnimationStyleChange : 1;
 
+  unsigned              mBelowSomethingDirty : 1;
+
   unsigned              mContainsUpdatePluginGeometryFrame : 1;
   unsigned              mFireAfterPaintEvents : 1;
 
   // Cache whether we are chrome or not because it is expensive.  
   // mIsChromeIsCached tells us if mIsChrome is valid or we need to get the
   // value the slow way.
   mutable unsigned      mIsChromeIsCached : 1;
   mutable unsigned      mIsChrome : 1;
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1829,16 +1829,17 @@ nsBlockFrame::ReflowDirtyLines(nsBlockRe
 
     if (selfDirty)
       line->MarkDirty();
 
     // This really sucks, but we have to look inside any blocks that have clear
     // elements inside them.
     // XXX what can we do smarter here?
     if (!line->IsDirty() && line->IsBlock() &&
+        aState.mPresContext->IsBelowSomethingDirty() &&
         (line->mFirstChild->GetStateBits() & NS_BLOCK_HAS_CLEAR_CHILDREN)) {
       line->MarkDirty();
     }
 
     nsIFrame *replacedBlock = nsnull;
     if (line->IsBlock() &&
         !nsBlockFrame::BlockCanIntersectFloats(line->mFirstChild)) {
       replacedBlock = line->mFirstChild;
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -3760,16 +3760,21 @@ nsFrame::WillReflow(nsPresContext* aPres
   // bug 81268
   NS_ASSERTION(!(mState & NS_FRAME_IN_REFLOW),
                "nsFrame::WillReflow: frame is already in reflow");
 #endif
 
   NS_FRAME_TRACE_MSG(NS_FRAME_TRACE_CALLS,
                      ("WillReflow: oldState=%x", mState));
   mState |= NS_FRAME_IN_REFLOW;
+
+  if (mState & NS_FRAME_IS_DIRTY) {
+    PresContext()->SetBelowSomethingDirty();
+  }
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsFrame::DidReflow(nsPresContext*           aPresContext,
                    const nsHTMLReflowState*  aReflowState,
                    nsDidReflowStatus         aStatus)
 {
