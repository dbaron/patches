From: L. David Baron <dbaron@dbaron.org>

Remove support for fallback background colors.  (Bug 496721)

diff --git a/accessible/src/base/nsTextAttrs.cpp b/accessible/src/base/nsTextAttrs.cpp
--- a/accessible/src/base/nsTextAttrs.cpp
+++ b/accessible/src/base/nsTextAttrs.cpp
@@ -526,18 +526,18 @@ nsBGColorTextAttr::Format(const nscolor&
   aFormattedValue = value;
 }
 
 PRBool
 nsBGColorTextAttr::GetColor(nsIFrame *aFrame, nscolor *aColor)
 {
   const nsStyleBackground *styleBackground = aFrame->GetStyleBackground();
 
-  if (NS_GET_A(styleBackground->mFallbackBackgroundColor) > 0) {
-    *aColor = styleBackground->mFallbackBackgroundColor;
+  if (NS_GET_A(styleBackground->mBackgroundColor) > 0) {
+    *aColor = styleBackground->mBackgroundColor;
     return PR_TRUE;
   }
 
   nsIFrame *parentFrame = aFrame->GetParent();
   if (!parentFrame) {
     *aColor = aFrame->PresContext()->DefaultBackgroundColor();
     return PR_TRUE;
   }
diff --git a/content/html/content/src/nsGenericHTMLElement.cpp b/content/html/content/src/nsGenericHTMLElement.cpp
--- a/content/html/content/src/nsGenericHTMLElement.cpp
+++ b/content/html/content/src/nsGenericHTMLElement.cpp
@@ -1981,26 +1981,22 @@ nsGenericHTMLElement::MapBackgroundInto(
 
 void
 nsGenericHTMLElement::MapBGColorInto(const nsMappedAttributes* aAttributes,
                                      nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
     return;
 
-  if (aData->mColorData->mBackColor.mXValue.GetUnit() == eCSSUnit_Null &&
+  if (aData->mColorData->mBackColor.GetUnit() == eCSSUnit_Null &&
       aData->mPresContext->UseDocumentColors()) {
-    NS_ASSERTION(aData->mColorData->mBackColor.mYValue.GetUnit() ==
-                   eCSSUnit_Null,
-                 "half a property?");
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::bgcolor);
     nscolor color;
     if (value && value->GetColorValue(color)) {
-      aData->mColorData->mBackColor.mXValue.SetColorValue(color);
-      aData->mColorData->mBackColor.mYValue.SetColorValue(color);
+      aData->mColorData->mBackColor.SetColorValue(color);
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapBackgroundAttributesInto(const nsMappedAttributes* aAttributes,
                                                   nsRuleData* aData)
 {
diff --git a/content/mathml/content/src/nsMathMLElement.cpp b/content/mathml/content/src/nsMathMLElement.cpp
--- a/content/mathml/content/src/nsMathMLElement.cpp
+++ b/content/mathml/content/src/nsMathMLElement.cpp
@@ -372,25 +372,20 @@ nsMathMLElement::MapMathMLAttributesInto
   }
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)) {
     const nsAttrValue* value =
       aAttributes->GetAttr(nsGkAtoms::mathbackground_);
     if (!value) {
       value = aAttributes->GetAttr(nsGkAtoms::background);
     }
-    if (value &&
-        aData->mColorData->mBackColor.mXValue.GetUnit() == eCSSUnit_Null) {
-      NS_ASSERTION(aData->mColorData->mBackColor.mYValue.GetUnit()
-                     == eCSSUnit_Null,
-                   "half a property?");
+    if (value && aData->mColorData->mBackColor.GetUnit() == eCSSUnit_Null) {
       nscolor color;
       if (value->GetColorValue(color)) {
-        aData->mColorData->mBackColor.mXValue.SetColorValue(color);
-        aData->mColorData->mBackColor.mYValue.SetColorValue(color);
+        aData->mColorData->mBackColor.SetColorValue(color);
       }
     }
   }
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Color)) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::mathcolor_);
     if (!value) {
       value = aAttributes->GetAttr(nsGkAtoms::color);
diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -1532,35 +1532,28 @@ nsCSSRendering::PaintBackgroundWithSC(ns
   PRBool drawBackgroundColor = PR_TRUE;
   PRBool usePrintSettings = aForFrame->HonorPrintBackgroundSettings();
   if (usePrintSettings) {
     drawBackgroundImage = aPresContext->GetBackgroundImageDraw();
     drawBackgroundColor = aPresContext->GetBackgroundColorDraw();
   }
 
   nsStyleBackground::Image bottomImage(aColor.BottomLayer().mImage);
-  PRBool useFallbackColor = PR_FALSE;
-  if (bottomImage.mSpecified) {
-    if (!drawBackgroundImage ||
-        !UseImageRequestForBackground(bottomImage.mRequest)) {
-      bottomImage.mRequest = nsnull;
-    }
-    useFallbackColor = bottomImage.mRequest == nsnull;
-  } else {
-    NS_ASSERTION(bottomImage.mRequest == nsnull, "malformed image struct");
+  if (!drawBackgroundImage ||
+      !UseImageRequestForBackground(bottomImage.mRequest)) {
+    bottomImage.mRequest = nsnull;
   }
 
   // If GetBackgroundColorDraw() is false, we are still expected to
   // draw color in the background of any frame that's not completely
   // transparent, but we are expected to use white instead of whatever
   // color was specified.
   nscolor bgColor;
   if (drawBackgroundColor) {
-    bgColor = useFallbackColor ? aColor.mFallbackBackgroundColor
-                               : aColor.mBackgroundColor;
+    bgColor = aColor.mBackgroundColor;
     if (NS_GET_A(bgColor) == 0)
       drawBackgroundColor = PR_FALSE;
   } else {
     bgColor = NS_RGB(255, 255, 255);
     if (drawBackgroundImage || !aColor.IsTransparent())
       drawBackgroundColor = PR_TRUE;
   }
 
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -3136,17 +3136,16 @@ nsLayoutUtils::GetFrameTransparency(nsIF
       !aFrame->GetFirstChild(nsnull)) {
     return eTransparencyOpaque;
   }
 
   const nsStyleBackground* bg;
   if (!nsCSSRendering::FindBackground(aFrame->PresContext(), aFrame, &bg))
     return eTransparencyTransparent;
   if (NS_GET_A(bg->mBackgroundColor) < 255 ||
-      NS_GET_A(bg->mFallbackBackgroundColor) < 255 ||
       // bottom layer's clip is used for the color
       bg->BottomLayer().mClip != NS_STYLE_BG_CLIP_BORDER)
     return eTransparencyTransparent;
   return eTransparencyOpaque;
 }
 
 static PRBool
 IsNonzeroCoord(const nsStyleCoord& aCoord)
diff --git a/layout/reftests/backgrounds/fallback-color-1.xhtml b/layout/reftests/backgrounds/fallback-color-1.xhtml
deleted file mode 100644
--- a/layout/reftests/backgrounds/fallback-color-1.xhtml
+++ /dev/null
@@ -1,25 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml">
-	<head>
-		<title>css3-background: fallback colors</title>
-		<link rel="author" title="L. David Baron" href="http://dbaron.org/" />
-		<link rel="author" title="Mozilla Corporation" href="http://mozilla.com/" />
-		<link rel="help" href="http://dev.w3.org/csswg/css3-background/#background-color" />
-		<meta name="flags" content="" />
-		<meta name="assert" content="Fallback color only applied when there is an image." />
-		<style type="text/css"><![CDATA[
-
-		div {
-			width: 100px;
-			height: 100px;
-			background: lime red;
-		}
-
-		]]></style>
-	</head>
-	<body>
-
-	<div></div>
-
-	</body>
-</html>
diff --git a/layout/reftests/backgrounds/fallback-color-2.xhtml b/layout/reftests/backgrounds/fallback-color-2.xhtml
deleted file mode 100644
--- a/layout/reftests/backgrounds/fallback-color-2.xhtml
+++ /dev/null
@@ -1,25 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml">
-	<head>
-		<title>css3-background: fallback colors</title>
-		<link rel="author" title="L. David Baron" href="http://dbaron.org/" />
-		<link rel="author" title="Mozilla Corporation" href="http://mozilla.com/" />
-		<link rel="help" href="http://dev.w3.org/csswg/css3-background/#background-color" />
-		<meta name="flags" content="" />
-		<meta name="assert" content="Fallback color only applied when there is an image." />
-		<style type="text/css"><![CDATA[
-
-		div {
-			width: 100px;
-			height: 100px;
-			background-color: lime red;
-		}
-
-		]]></style>
-	</head>
-	<body>
-
-	<div></div>
-
-	</body>
-</html>
diff --git a/layout/reftests/backgrounds/fallback-color-3.xhtml b/layout/reftests/backgrounds/fallback-color-3.xhtml
deleted file mode 100644
--- a/layout/reftests/backgrounds/fallback-color-3.xhtml
+++ /dev/null
@@ -1,25 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml">
-	<head>
-		<title>css3-background: fallback colors</title>
-		<link rel="author" title="L. David Baron" href="http://dbaron.org/" />
-		<link rel="author" title="Mozilla Corporation" href="http://mozilla.com/" />
-		<link rel="help" href="http://dev.w3.org/csswg/css3-background/#background-color" />
-		<meta name="flags" content="" />
-		<meta name="assert" content="Fallback color not applied when background image loads successfully." />
-		<style type="text/css"><![CDATA[
-
-		div {
-			width: 100px;
-			height: 100px;
-			background: url(transparent-32x32.png) lime red;
-		}
-
-		]]></style>
-	</head>
-	<body>
-
-	<div></div>
-
-	</body>
-</html>
diff --git a/layout/reftests/backgrounds/fallback-color-4.xhtml b/layout/reftests/backgrounds/fallback-color-4.xhtml
deleted file mode 100644
--- a/layout/reftests/backgrounds/fallback-color-4.xhtml
+++ /dev/null
@@ -1,25 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml">
-	<head>
-		<title>css3-background: fallback colors</title>
-		<link rel="author" title="L. David Baron" href="http://dbaron.org/" />
-		<link rel="author" title="Mozilla Corporation" href="http://mozilla.com/" />
-		<link rel="help" href="http://dev.w3.org/csswg/css3-background/#background-color" />
-		<meta name="flags" content="" />
-		<meta name="assert" content="Fallback color applied when background image corrupted." />
-		<style type="text/css"><![CDATA[
-
-		div {
-			width: 100px;
-			height: 100px;
-			background: url(malformed.png) red lime;
-		}
-
-		]]></style>
-	</head>
-	<body>
-
-	<div></div>
-
-	</body>
-</html>
diff --git a/layout/reftests/backgrounds/fallback-color-5.xhtml b/layout/reftests/backgrounds/fallback-color-5.xhtml
deleted file mode 100644
--- a/layout/reftests/backgrounds/fallback-color-5.xhtml
+++ /dev/null
@@ -1,25 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml">
-	<head>
-		<title>css3-background: fallback colors</title>
-		<link rel="author" title="L. David Baron" href="http://dbaron.org/" />
-		<link rel="author" title="Mozilla Corporation" href="http://mozilla.com/" />
-		<link rel="help" href="http://dev.w3.org/csswg/css3-background/#background-color" />
-		<meta name="flags" content="" />
-		<meta name="assert" content="Fallback color applied when background image missing." />
-		<style type="text/css"><![CDATA[
-
-		div {
-			width: 100px;
-			height: 100px;
-			background: url(404.png) red lime;
-		}
-
-		]]></style>
-	</head>
-	<body>
-
-	<div></div>
-
-	</body>
-</html>
diff --git a/layout/reftests/backgrounds/fallback-color-6.xhtml b/layout/reftests/backgrounds/fallback-color-6.xhtml
deleted file mode 100644
--- a/layout/reftests/backgrounds/fallback-color-6.xhtml
+++ /dev/null
@@ -1,25 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml">
-	<head>
-		<title>css3-background: fallback colors</title>
-		<link rel="author" title="L. David Baron" href="http://dbaron.org/" />
-		<link rel="author" title="Mozilla Corporation" href="http://mozilla.com/" />
-		<link rel="help" href="http://dev.w3.org/csswg/css3-background/#background-color" />
-		<meta name="flags" content="" />
-		<meta name="assert" content="Fallback color is based on whether the *bottom-most* image is corrupted." />
-		<style type="text/css"><![CDATA[
-
-		div {
-			width: 100px;
-			height: 100px;
-			background: url(transparent-32x32.png), url(malformed.png) red lime;
-		}
-
-		]]></style>
-	</head>
-	<body>
-
-	<div></div>
-
-	</body>
-</html>
diff --git a/layout/reftests/backgrounds/fallback-color-7.xhtml b/layout/reftests/backgrounds/fallback-color-7.xhtml
deleted file mode 100644
--- a/layout/reftests/backgrounds/fallback-color-7.xhtml
+++ /dev/null
@@ -1,25 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml">
-	<head>
-		<title>css3-background: fallback colors</title>
-		<link rel="author" title="L. David Baron" href="http://dbaron.org/" />
-		<link rel="author" title="Mozilla Corporation" href="http://mozilla.com/" />
-		<link rel="help" href="http://dev.w3.org/csswg/css3-background/#background-color" />
-		<meta name="flags" content="" />
-		<meta name="assert" content="Fallback color is based on whether the *bottom-most* image is corrupted." />
-		<style type="text/css"><![CDATA[
-
-		div {
-			width: 100px;
-			height: 100px;
-			background: url(malformed.png), url(transparent-32x32.png) lime red;
-		}
-
-		]]></style>
-	</head>
-	<body>
-
-	<div></div>
-
-	</body>
-</html>
diff --git a/layout/reftests/backgrounds/fallback-color-8.xhtml b/layout/reftests/backgrounds/fallback-color-8.xhtml
deleted file mode 100644
--- a/layout/reftests/backgrounds/fallback-color-8.xhtml
+++ /dev/null
@@ -1,25 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml">
-	<head>
-		<title>css3-background: fallback colors</title>
-		<link rel="author" title="L. David Baron" href="http://dbaron.org/" />
-		<link rel="author" title="Mozilla Corporation" href="http://mozilla.com/" />
-		<link rel="help" href="http://dev.w3.org/csswg/css3-background/#background-color" />
-		<meta name="flags" content="" />
-		<meta name="assert" content="Fallback color is based on whether the *bottom-most* image is missing." />
-		<style type="text/css"><![CDATA[
-
-		div {
-			width: 100px;
-			height: 100px;
-			background: url(transparent-32x32.png), url(404.png) red lime;
-		}
-
-		]]></style>
-	</head>
-	<body>
-
-	<div></div>
-
-	</body>
-</html>
diff --git a/layout/reftests/backgrounds/fallback-color-9.xhtml b/layout/reftests/backgrounds/fallback-color-9.xhtml
deleted file mode 100644
--- a/layout/reftests/backgrounds/fallback-color-9.xhtml
+++ /dev/null
@@ -1,25 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml">
-	<head>
-		<title>css3-background: fallback colors</title>
-		<link rel="author" title="L. David Baron" href="http://dbaron.org/" />
-		<link rel="author" title="Mozilla Corporation" href="http://mozilla.com/" />
-		<link rel="help" href="http://dev.w3.org/csswg/css3-background/#background-color" />
-		<meta name="flags" content="" />
-		<meta name="assert" content="Fallback color is based on whether the *bottom-most* image is missing." />
-		<style type="text/css"><![CDATA[
-
-		div {
-			width: 100px;
-			height: 100px;
-			background: url(404.png), url(transparent-32x32.png) lime red;
-		}
-
-		]]></style>
-	</head>
-	<body>
-
-	<div></div>
-
-	</body>
-</html>
diff --git a/layout/reftests/backgrounds/fallback-color-ref.xhtml b/layout/reftests/backgrounds/fallback-color-ref.xhtml
deleted file mode 100644
--- a/layout/reftests/backgrounds/fallback-color-ref.xhtml
+++ /dev/null
@@ -1,24 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml">
-	<head>
-		<title>css3-background: fallback colors</title>
-		<link rel="author" title="L. David Baron" href="http://dbaron.org/" />
-		<link rel="author" title="Mozilla Corporation" href="http://mozilla.com/" />
-		<link rel="help" href="http://dev.w3.org/csswg/css3-background/#background-color" />
-		<meta name="flags" content="" />
-		<style type="text/css"><![CDATA[
-
-		div {
-			width: 100px;
-			height: 100px;
-			background: url(lime-32x32.png);
-		}
-
-		]]></style>
-	</head>
-	<body>
-
-	<div></div>
-
-	</body>
-</html>
diff --git a/layout/reftests/backgrounds/reftest.list b/layout/reftests/backgrounds/reftest.list
--- a/layout/reftests/backgrounds/reftest.list
+++ b/layout/reftests/backgrounds/reftest.list
@@ -1,18 +1,8 @@
-== fallback-color-1.xhtml fallback-color-ref.xhtml
-== fallback-color-2.xhtml fallback-color-ref.xhtml
-== fallback-color-3.xhtml fallback-color-ref.xhtml
-== fallback-color-4.xhtml fallback-color-ref.xhtml
-== fallback-color-5.xhtml fallback-color-ref.xhtml
-== fallback-color-6.xhtml fallback-color-ref.xhtml
-== fallback-color-7.xhtml fallback-color-ref.xhtml
-== fallback-color-8.xhtml fallback-color-ref.xhtml
-== fallback-color-9.xhtml fallback-color-ref.xhtml
-!= fallback-color-ref.xhtml about:blank
 == layers-stacking-order.xhtml layers-stacking-order-ref.xhtml
 == layers-layer-count-cascade-1.xhtml layers-layer-count-1-ref.xhtml
 == layers-layer-count-inheritance-1.xhtml layers-layer-count-1-ref.xhtml
 == layers-layer-count-cascade-2.xhtml layers-layer-count-2-ref.xhtml
 == layers-layer-count-inheritance-2.xhtml layers-layer-count-2-ref.xhtml
 == continuous-inline-1a.html continuous-inline-1-ref.html
 == continuous-inline-1b.html continuous-inline-1-ref.html
 == continuous-inline-1c.html continuous-inline-1-ref.html
diff --git a/layout/reftests/bugs/289480.html b/layout/reftests/bugs/289480.html
--- a/layout/reftests/bugs/289480.html
+++ b/layout/reftests/bugs/289480.html
@@ -93,17 +93,17 @@
    .parser { /* comment parsing test -- comment ends before the end of this line, the backslash should have no effect: \*/ }
    .parser { margin: 0 5em 1em; padding: 0 1em; width: 2em; height: 1em; error: \}; background: yellow; } /* setup with parsing test */
    * html .parser {  background: gray; }
    \.parser { padding: 2em; }
    .parser { m\argin: 2em; };
    .parser { height: 3em; }
    .parser { width: 200; }
    .parser { border: 5em solid red ! error; }
-   .parser { background: red pink pink; }
+   .parser { background: red pink; }
 
    /* line fourteen (last line of face): table */
    ul { display: table; padding: 0; margin: -1em 7em 0; background: red; }
    ul li { padding: 0; margin: 0; }
    ul li.first-part { display: table-cell; height: 1em; width: 1em; background: black; }
    ul li.second-part { display: table; height: 1em; width: 1em; background: black; } /* anonymous table cell wraps around this */
    ul li.third-part { display: table-cell; height: 0.5em; /* gets stretched to fit row */ width: 1em; background: black; }
    ul li.fourth-part { list-style: none; height: 1em; width: 1em; background: black; } /* anonymous table cell wraps around this */
diff --git a/layout/style/nsCSSDataBlock.cpp b/layout/style/nsCSSDataBlock.cpp
--- a/layout/style/nsCSSDataBlock.cpp
+++ b/layout/style/nsCSSDataBlock.cpp
@@ -211,29 +211,61 @@ nsCSSCompressedDataBlock::MapRuleInfoInt
                             }
                         }
                         *target = *val;
                         if (iProp == eCSSProperty_font_family) {
                             // XXX Are there other things like this?
                             aRuleData->mFontData->mFamilyFromHTML = PR_FALSE;
                         }
                         else if (iProp == eCSSProperty_color ||
+                                 iProp == eCSSProperty_background_color ||
                                  iProp == eCSSProperty_border_top_color ||
                                  iProp == eCSSProperty_border_right_color_value ||
                                  iProp == eCSSProperty_border_right_color_ltr_source ||
                                  iProp == eCSSProperty_border_right_color_rtl_source ||
                                  iProp == eCSSProperty_border_bottom_color ||
                                  iProp == eCSSProperty_border_left_color_value ||
                                  iProp == eCSSProperty_border_left_color_ltr_source ||
                                  iProp == eCSSProperty_border_left_color_rtl_source ||
                                  iProp == eCSSProperty__moz_column_rule_color ||
                                  iProp == eCSSProperty_outline_color) {
                             if (ShouldIgnoreColors(aRuleData)) {
-                                // Ignore 'color', 'border-*-color', etc.
-                                *target = nsCSSValue();
+                                if (iProp == eCSSProperty_background_color) {
+                                    // Force non-'transparent' background colors
+                                    // to the user's default.  We have the value
+                                    // in the form it was specified at this
+                                    // point, so we have to look for both the
+                                    // keyword 'transparent' and its equivalent
+                                    // in rgba notation.
+                                    nsCSSValue &colorVal = target->mXValue;
+                                    nsCSSUnit u = colorVal.GetUnit();
+                                    nsDependentString buf;
+                            
+                                    if ((u == eCSSUnit_Color &&
+                                         NS_GET_A(colorVal.GetColorValue())
+                                         > 0) ||
+                                        (u == eCSSUnit_Ident &&
+                                         !nsGkAtoms::transparent->
+                                         Equals(colorVal.GetStringValue(buf))) ||
+                                        (u == eCSSUnit_EnumColor)) {
+                                        colorVal.SetColorValue(aRuleData->
+                                            mPresContext->
+                                            DefaultBackgroundColor());
+                                    }
+                                    // We could consider using the fallback
+                                    // background color for both values, but it
+                                    // might not make sense if the author didn't
+                                    // specify an image.  But since we're
+                                    // dropping author images, we'll just use
+                                    // the non-fallback for both.
+                                    target->mYValue = target->mXValue;
+                                } else {
+                                    // Ignore 'color', 'border-*-color', etc.
+                                    *target = nsCSSValue();
+                                }
                             }
                         }
                     }
                     cursor += CDBValueStorage_advance;
                 } break;
 
                 case eCSSType_Rect: {
                     const nsCSSRect* val = RectAtCursor(cursor);
@@ -256,47 +288,16 @@ nsCSSCompressedDataBlock::MapRuleInfoInt
                                  val->mYValue.GetUnit() != eCSSUnit_Null, "oops");
                     nsCSSValuePair* target = static_cast<nsCSSValuePair*>(prop);
                     NS_ASSERTION((target->mXValue.GetUnit() == eCSSUnit_Null)
                               == (target->mYValue.GetUnit() == eCSSUnit_Null),
                                  "half a property?");
                     if (target->mXValue.GetUnit() == eCSSUnit_Null) {
                         target->mXValue = val->mXValue;
                         target->mYValue = val->mYValue;
-                        if (iProp == eCSSProperty_background_color &&
-                            ShouldIgnoreColors(aRuleData)) {
-                            // Force non-'transparent' background colors
-                            // to the user's default.  We have the value
-                            // in the form it was specified at this
-                            // point, so we have to look for both the
-                            // keyword 'transparent' and its equivalent
-                            // in rgba notation.
-                            nsCSSValue &colorVal = target->mXValue;
-                            nsCSSUnit u = colorVal.GetUnit();
-                            nsDependentString buf;
-                            
-                            if ((u == eCSSUnit_Color &&
-                                 NS_GET_A(colorVal.GetColorValue())
-                                 > 0) ||
-                                (u == eCSSUnit_Ident &&
-                                 !nsGkAtoms::transparent->
-                                 Equals(colorVal.GetStringValue(buf))) ||
-                                (u == eCSSUnit_EnumColor)) {
-                                colorVal.SetColorValue(aRuleData->
-                                    mPresContext->
-                                    DefaultBackgroundColor());
-                            }
-                            // We could consider using the fallback
-                            // background color for both values, but it
-                            // might not make sense if the author didn't
-                            // specify an image.  But since we're
-                            // dropping author images, we'll just use
-                            // the non-fallback for both.
-                            target->mYValue = target->mXValue;
-                        }
                     }
                     cursor += CDBValuePairStorage_advance;
                 } break;
 
                 case eCSSType_ValueList:
                     if (iProp == eCSSProperty_background_image ||
                         iProp == eCSSProperty_content) {
                         for (nsCSSValueList* l = ValueListAtCursor(cursor);
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -421,17 +421,16 @@ protected:
   struct BackgroundItemSimpleValueInfo {
     nsCSSValue BackgroundItem::*member;
     nsCSSProperty propID;
   };
 
   PRBool ParseBackgroundItem(BackgroundItem& aItem, PRBool aFirstItem);
 
   PRBool ParseBackgroundList(nsCSSProperty aPropID); // a single value prop-id
-  PRBool ParseBackgroundColor(PRBool aInShorthand);
   PRBool ParseBackgroundPosition();
   PRBool ParseBoxPositionValues(nsCSSValuePair& aOut);
   PRBool ParseBorderColor();
   PRBool ParseBorderColors(nsCSSValueList** aResult,
                            nsCSSProperty aProperty);
   PRBool ParseBorderImage();
   PRBool ParseBorderSpacing();
   PRBool ParseBorderSide(const nsCSSProperty aPropIDs[],
@@ -5047,18 +5046,16 @@ CSSParserImpl::ParseProperty(nsCSSProper
     return ParseTransitionProperty();
   case eCSSProperty_transition_timing_function:
     return ParseTransitionTimingFunction();
   case eCSSProperty_transition_duration:
   case eCSSProperty_transition_delay:
     return ParseTransitionTime(aPropID);
   case eCSSProperty_background:
     return ParseBackground();
-  case eCSSProperty_background_color:
-    return ParseBackgroundColor(PR_FALSE);
   case eCSSProperty_background_position:
     return ParseBackgroundPosition();
   case eCSSProperty_background_attachment:
   case eCSSProperty__moz_background_clip:
   case eCSSProperty_background_image:
   case eCSSProperty__moz_background_origin:
   case eCSSProperty_background_repeat:
     return ParseBackgroundList(aPropID);
@@ -5313,17 +5310,16 @@ CSSParserImpl::ParseSingleValueProperty(
   switch (aPropID) {
   case eCSSProperty_UNKNOWN:
   case eCSSProperty_background:
   case eCSSProperty_transition:
   case eCSSProperty_transition_property:
   case eCSSProperty_transition_timing_function:
   case eCSSProperty_transition_duration:
   case eCSSProperty_transition_delay:
-  case eCSSProperty_background_color:
   case eCSSProperty_background_position:
   case eCSSProperty_border:
   case eCSSProperty_border_color:
   case eCSSProperty_border_bottom_colors:
   case eCSSProperty_border_image:
   case eCSSProperty_border_left_colors:
   case eCSSProperty_border_right_colors:
   case eCSSProperty_border_end_color:
@@ -5433,16 +5429,18 @@ CSSParserImpl::ParseSingleValueProperty(
   case eCSSProperty_background_attachment:
     // Used only internally.
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundAttachmentKTable);
   case eCSSProperty__moz_background_clip:
     // Used only internally.
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundClipKTable);
+  case eCSSProperty_background_color:
+    return ParseVariant(aValue, VARIANT_HC, nsnull);
   case eCSSProperty_background_image:
     // Used only internally.
     return ParseVariant(aValue, VARIANT_HUO, nsnull);
   case eCSSProperty__moz_background_inline_policy:
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundInlinePolicyKTable);
   case eCSSProperty__moz_background_origin:
     // Used only internally.
@@ -6191,17 +6189,18 @@ CSSParserImpl::ParseBackgroundItem(CSSPa
         // When we support 'no-clip', this needs to be conditional on haveClip:
         aItem.mClip = aItem.mOrigin;
       // We'd support 'no-clip' as an additional |else| here.
 #endif
       } else {
         if (haveColor)
           return PR_FALSE;
         haveColor = PR_TRUE;
-        if (!ParseBackgroundColor(PR_TRUE)) {
+        if (!ParseSingleValueProperty(mTempData.mColor.mBackColor,
+                                      eCSSProperty_background_color)) {
           return PR_FALSE;
         }
         aItem.mLastItem = PR_TRUE;
       }
     } else if (eCSSToken_Function == tt &&
                mToken.mIdent.LowerCaseEqualsLiteral("url")) {
       if (haveImage)
         return PR_FALSE;
@@ -6216,19 +6215,20 @@ CSSParserImpl::ParseBackgroundItem(CSSPa
       havePosition = PR_TRUE;
       if (!ParseBoxPositionValues(aItem.mPosition)) {
         return PR_FALSE;
       }
     } else {
       if (haveColor)
         return PR_FALSE;
       haveColor = PR_TRUE;
-      // Note: ParseBackgroundColor parses 'inherit' and 'initial', but
+      // Note: This parses 'inherit' and 'initial', but
       // we've already checked for them, so it's ok.
-      if (!ParseBackgroundColor(PR_TRUE)) {
+      if (!ParseSingleValueProperty(mTempData.mColor.mBackColor,
+                                    eCSSProperty_background_color)) {
         return PR_FALSE;
       }
       aItem.mLastItem = PR_TRUE;
     }
     haveSomething = PR_TRUE;
   }
 
   return haveSomething;
@@ -6270,42 +6270,16 @@ CSSParserImpl::ParseBackgroundList(nsCSS
     *source = head;
     mTempData.SetPropertyBit(aPropID);
     return PR_TRUE;
   }
   delete head;
   return PR_FALSE;
 }
 
-PRBool
-CSSParserImpl::ParseBackgroundColor(PRBool aInShorthand)
-{
-  nsCSSValuePair &backColor = mTempData.mColor.mBackColor;
-  mTempData.SetPropertyBit(eCSSProperty_background_color);
-  if (!ParseVariant(backColor.mXValue,
-                    aInShorthand ? VARIANT_COLOR : VARIANT_HC, nsnull)) {
-    return PR_FALSE;
-  }
-  backColor.mYValue = backColor.mXValue;
-  switch (backColor.mXValue.GetUnit()) {
-    case eCSSUnit_Inherit:
-    case eCSSUnit_Initial:
-      NS_ASSERTION(!aInShorthand,
-                   "should not get inherit or initial in shorthand");
-      return ExpectEndProperty(); // we're done
-    default:
-      break;
-  }
-
-  // Ignore success, since the value is optional.
-  ParseVariant(backColor.mYValue, VARIANT_COLOR, nsnull);
-
-  return aInShorthand || ExpectEndProperty();
-}
-
 // This function is very similar to ParseBackgroundList.
 PRBool
 CSSParserImpl::ParseBackgroundPosition()
 {
   // aPropID is a single value prop-id
   nsCSSValuePair valuePair;
   nsCSSValuePairList *head = nsnull, **tail = &head;
   for (;;) {
diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -287,17 +287,17 @@ CSS_PROP_OUTLINE(-moz-outline-radius-bot
 CSS_PROP_OUTLINE(-moz-outline-radius-bottomleft, _moz_outline_radius_bottomLeft, MozOutlineRadiusBottomleft, 0, Margin, mOutlineRadius.mBottomLeft, eCSSType_ValuePair, nsnull)
 #ifndef CSS_PROP_LIST_EXCLUDE_INTERNAL
 CSS_PROP_FONT(-x-system-font, _x_system_font, X, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE, Font, mSystemFont, eCSSType_Value, kFontKTable)
 #endif
 CSS_PROP_BACKENDONLY(azimuth, azimuth, Azimuth, 0, Aural, mAzimuth, eCSSType_Value, kAzimuthKTable)
 CSS_PROP_SHORTHAND(background, background, Background, 0)
 CSS_PROP_BACKGROUND(background-attachment, background_attachment, BackgroundAttachment, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE | CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Color, mBackAttachment, eCSSType_ValueList, kBackgroundAttachmentKTable)
 CSS_PROP_BACKGROUND(-moz-background-clip, _moz_background_clip, MozBackgroundClip, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE | CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Color, mBackClip, eCSSType_ValueList, kBackgroundClipKTable)
-CSS_PROP_BACKGROUND(background-color, background_color, BackgroundColor, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE, Color, mBackColor, eCSSType_ValuePair, nsnull)
+CSS_PROP_BACKGROUND(background-color, background_color, BackgroundColor, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE, Color, mBackColor, eCSSType_Value, nsnull)
 CSS_PROP_BACKGROUND(background-image, background_image, BackgroundImage, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE | CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Color, mBackImage, eCSSType_ValueList, nsnull)
 CSS_PROP_BACKGROUND(-moz-background-inline-policy, _moz_background_inline_policy, MozBackgroundInlinePolicy, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE, Color, mBackInlinePolicy, eCSSType_Value, kBackgroundInlinePolicyKTable)
 CSS_PROP_BACKGROUND(-moz-background-origin, _moz_background_origin, MozBackgroundOrigin, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE | CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Color, mBackOrigin, eCSSType_ValueList, kBackgroundOriginKTable)
 CSS_PROP_BACKGROUND(background-position, background_position, BackgroundPosition, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE | CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Color, mBackPosition, eCSSType_ValuePairList, kBackgroundPositionKTable)
 CSS_PROP_BACKGROUND(background-repeat, background_repeat, BackgroundRepeat, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE | CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Color, mBackRepeat, eCSSType_ValueList, kBackgroundRepeatKTable)
 CSS_PROP_DISPLAY(-moz-binding, binding, MozBinding, 0, Display, mBinding, eCSSType_Value, nsnull) // XXX bug 3935
 CSS_PROP_SHORTHAND(border, border, Border, 0)
 CSS_PROP_SHORTHAND(border-bottom, border_bottom, BorderBottom, 0)
diff --git a/layout/style/nsCSSStruct.h b/layout/style/nsCSSStruct.h
--- a/layout/style/nsCSSStruct.h
+++ b/layout/style/nsCSSStruct.h
@@ -302,17 +302,17 @@ private:
   nsRuleDataFont(const nsRuleDataFont& aOther); // NOT IMPLEMENTED
 };
 
 struct nsCSSColor : public nsCSSStruct  {
   nsCSSColor(void);
   ~nsCSSColor(void);
 
   nsCSSValue      mColor;
-  nsCSSValuePair  mBackColor;
+  nsCSSValue      mBackColor;
   nsCSSValueList* mBackImage;
   nsCSSValueList* mBackRepeat;
   nsCSSValueList* mBackAttachment;
   nsCSSValuePairList* mBackPosition;
   nsCSSValueList* mBackClip;
   nsCSSValueList* mBackOrigin;
   nsCSSValue      mBackInlinePolicy;
 private:
diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -1214,52 +1214,27 @@ nsComputedDOMStyle::GetBackgroundClip(ns
                            &nsStyleBackground::mClipCount,
                            nsCSSProps::kBackgroundClipKTable,
                            aValue);
 }
 
 nsresult
 nsComputedDOMStyle::GetBackgroundColor(nsIDOMCSSValue** aValue)
 {
-  const nsStyleBackground* bg = GetStyleBackground();
-  nsresult rv;
-
-  if (bg->mBackgroundColor == bg->mFallbackBackgroundColor) {
-    nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-    NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
-
-    rv = SetToRGBAColor(val, bg->mBackgroundColor);
-    if (NS_FAILED(rv)) {
-      delete val;
-      return rv;
-    }
-    rv = CallQueryInterface(val, aValue);
-  } else {
-    nsDOMCSSValueList *valueList = GetROCSSValueList(PR_FALSE);
-    NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
-
-    for (PRUint32 i = 0; i < 2; ++i) {
-      nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-      if (!val || !valueList->AppendCSSValue(val)) {
-        delete val;
-        delete valueList;
-        return NS_ERROR_OUT_OF_MEMORY;
-      }
-
-      rv = SetToRGBAColor(val, (i == 0) ? bg->mBackgroundColor
-                                        : bg->mFallbackBackgroundColor);
-      if (NS_FAILED(rv)) {
-        delete valueList;
-        return rv;
-      }
-    }
-    rv = CallQueryInterface(valueList, aValue);
-  }
-
-  return rv;
+  nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
+  NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
+
+  const nsStyleBackground* color = GetStyleBackground();
+  nsresult rv = SetToRGBAColor(val, color->mBackgroundColor);
+  if (NS_FAILED(rv)) {
+    delete val;
+    return rv;
+  }
+
+  return CallQueryInterface(val, aValue);
 }
 
 nsresult
 nsComputedDOMStyle::GetBackgroundImage(nsIDOMCSSValue** aValue)
 {
   const nsStyleBackground* bg = GetStyleBackground();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -4270,36 +4270,26 @@ nsRuleNode::ComputeBackgroundData(void* 
                                   const nsRuleDataStruct& aData, 
                                   nsStyleContext* aContext, 
                                   nsRuleNode* aHighestNode,
                                   const RuleDetail aRuleDetail,
                                   const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Background, (), bg, parentBG, Color, colorData)
 
-  // background-color: color, string, inherit [pair]
-  if (eCSSUnit_Initial == colorData.mBackColor.mXValue.GetUnit()) {
+  // background-color: color, string, inherit
+  if (eCSSUnit_Initial == colorData.mBackColor.GetUnit()) {
     bg->mBackgroundColor = NS_RGBA(0, 0, 0, 0);
-  } else if (!SetColor(colorData.mBackColor.mXValue,
-                       parentBG->mBackgroundColor, mPresContext,
-                       aContext, bg->mBackgroundColor, canStoreInRuleTree)) {
+  } else if (!SetColor(colorData.mBackColor, parentBG->mBackgroundColor,
+                       mPresContext, aContext, bg->mBackgroundColor,
+                       canStoreInRuleTree)) {
     NS_ASSERTION(eCSSUnit_Null == colorData.mBackColor.mXValue.GetUnit(),
                  "unexpected color unit");
   }
 
-  if (eCSSUnit_Initial == colorData.mBackColor.mYValue.GetUnit()) {
-    bg->mFallbackBackgroundColor = NS_RGBA(0, 0, 0, 0);
-  } else if (!SetColor(colorData.mBackColor.mYValue,
-                       parentBG->mFallbackBackgroundColor, mPresContext,
-                       aContext, bg->mFallbackBackgroundColor,
-                       canStoreInRuleTree)) {
-    NS_ASSERTION(eCSSUnit_Null == colorData.mBackColor.mYValue.GetUnit(),
-                 "unexpected color unit");
-  }
-
   PRUint32 maxItemCount = 1;
   PRBool rebuild = PR_FALSE;
 
   // background-image: url (stored as image), none, inherit [list]
   SetBackgroundList(aContext, colorData.mBackImage, bg->mLayers,
                     parentBG->mLayers, &nsStyleBackground::Layer::mImage,
                     nsStyleBackground::Image(), parentBG->mImageCount,
                     bg->mImageCount, maxItemCount, rebuild, canStoreInRuleTree);
@@ -5989,18 +5979,17 @@ nsRuleNode::HasAuthorSpecifiedRules(nsSt
 
   /* We're relying on the use of |aStyleContext| not mutating it! */
   nsRuleData ruleData(inheritBits,
                       aStyleContext->PresContext(), aStyleContext);
   ruleData.mColorData = &colorData;
   ruleData.mMarginData = &marginData;
 
   nsCSSValue* backgroundValues[] = {
-    &colorData.mBackColor.mXValue,
-    &colorData.mBackColor.mYValue,
+    &colorData.mBackColor,
     &firstBackgroundImage
   };
 
   nsCSSValue* borderValues[] = {
     &marginData.mBorderColor.mTop,
     &marginData.mBorderStyle.mTop,
     &marginData.mBorderWidth.mTop,
     &marginData.mBorderColor.mRight,
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -1214,34 +1214,32 @@ nsChangeHint nsStyleColor::MaxDifference
 nsStyleBackground::nsStyleBackground()
   : mAttachmentCount(1)
   , mClipCount(1)
   , mOriginCount(1)
   , mRepeatCount(1)
   , mPositionCount(1)
   , mImageCount(1)
   , mBackgroundColor(NS_RGBA(0, 0, 0, 0))
-  , mFallbackBackgroundColor(NS_RGBA(0, 0, 0, 0))
   , mBackgroundInlinePolicy(NS_STYLE_BG_INLINE_POLICY_CONTINUOUS)
 {
   Layer *onlyLayer = mLayers.AppendElement();
   NS_ASSERTION(onlyLayer, "auto array must have room for 1 element");
   onlyLayer->SetInitialValues();
 }
 
 nsStyleBackground::nsStyleBackground(const nsStyleBackground& aSource)
   : mAttachmentCount(aSource.mAttachmentCount)
   , mClipCount(aSource.mClipCount)
   , mOriginCount(aSource.mOriginCount)
   , mRepeatCount(aSource.mRepeatCount)
   , mPositionCount(aSource.mPositionCount)
   , mImageCount(aSource.mImageCount)
   , mLayers(aSource.mLayers) // deep copy
   , mBackgroundColor(aSource.mBackgroundColor)
-  , mFallbackBackgroundColor(aSource.mFallbackBackgroundColor)
   , mBackgroundInlinePolicy(aSource.mBackgroundInlinePolicy)
 {
   // If the deep copy of mLayers failed, truncate the counts.
   PRUint32 count = mLayers.Length();
   if (count != aSource.mLayers.Length()) {
     NS_WARNING("truncating counts due to out-of-memory");
     mAttachmentCount = PR_MAX(mAttachmentCount, count);
     mClipCount = PR_MAX(mClipCount, count);
@@ -1254,17 +1252,16 @@ nsStyleBackground::nsStyleBackground(con
 
 nsStyleBackground::~nsStyleBackground()
 {
 }
 
 nsChangeHint nsStyleBackground::CalcDifference(const nsStyleBackground& aOther) const
 {
   if (mBackgroundColor != aOther.mBackgroundColor ||
-      mFallbackBackgroundColor != aOther.mFallbackBackgroundColor ||
       mBackgroundInlinePolicy != aOther.mBackgroundInlinePolicy ||
       mImageCount != aOther.mImageCount)
     return NS_STYLE_HINT_VISUAL;
 
   // We checked the image count above.
   NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, this) {
     if (mLayers[i] != aOther.mLayers[i])
       return NS_STYLE_HINT_VISUAL;
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -268,17 +268,16 @@ struct nsStyleBackground {
   nsAutoTArray<Layer, 1> mLayers;
 
   const Layer& BottomLayer() const { return mLayers[mImageCount - 1]; }
 
   #define NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(var_, stylebg_) \
     for (PRUint32 var_ = (stylebg_)->mImageCount; var_-- != 0; )
 
   nscolor mBackgroundColor;       // [reset]
-  nscolor mFallbackBackgroundColor; // [reset]
 
   // FIXME: This (now background-break in css3-background) should
   // probably move into a different struct so that everything in
   // nsStyleBackground is set by the background shorthand.
   PRUint8 mBackgroundInlinePolicy; // [reset] See nsStyleConsts.h
 
   // True if this background is completely transparent.
   PRBool IsTransparent() const;
diff --git a/layout/style/test/property_database.js b/layout/style/test/property_database.js
--- a/layout/style/test/property_database.js
+++ b/layout/style/test/property_database.js
@@ -661,18 +661,18 @@ var gCSSProperties = {
 		initial_values: [ "scroll" ],
 		other_values: [ "fixed", "scroll,scroll", "fixed, scroll", "scroll, fixed, scroll", "fixed, fixed" ],
 		invalid_values: []
 	},
 	"background-color": {
 		domProp: "backgroundColor",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
-		initial_values: [ "transparent", "transparent transparent", "rgba(255, 127, 15, 0)", "hsla(240, 97%, 50%, 0.0)", "rgba(0, 0, 0, 0)", "rgba(255,255,255,-3.7)" ],
-		other_values: [ "green", "rgb(255, 0, 128)", "#fc2", "#96ed2a", "black", "rgba(255,255,0,3)", "transparent green", "green transparent", "blue fuchsia", "rgb(3,4,5) hsl(240, 50%, 50%)" ],
+		initial_values: [ "transparent", "rgba(255, 127, 15, 0)", "hsla(240, 97%, 50%, 0.0)", "rgba(0, 0, 0, 0)", "rgba(255,255,255,-3.7)" ],
+		other_values: [ "green", "rgb(255, 0, 128)", "#fc2", "#96ed2a", "black", "rgba(255,255,0,3)" ],
 		invalid_values: [ "#0", "#00", "#0000", "#00000", "#0000000", "#00000000", "#000000000", "rgb(255.0,0.387,3489)" ]
 	},
 	"background-image": {
 		domProp: "backgroundImage",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "none" ],
 		other_values: [ "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==)", "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==')", 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==")',
