From: L. David Baron <dbaron@dbaron.org>

Add bug numbers for the FIXME comments in CSS transitions patches.  (Bug 435441)

diff --git a/content/base/src/nsGenericElement.cpp b/content/base/src/nsGenericElement.cpp
--- a/content/base/src/nsGenericElement.cpp
+++ b/content/base/src/nsGenericElement.cpp
@@ -2689,17 +2689,17 @@ nsGenericElement::UnbindFromTree(PRBool 
     }
 
     document->ClearBoxObjectFor(this);
   }
 
   // Ensure that CSS transitions don't continue on an element at a
   // different place in the tree (even if reinserted before next
   // animation refresh).
-  // FIXME: Need a test for this.
+  // FIXME (Bug 522599): Need a test for this.
   if (HasFlag(NODE_HAS_PROPERTIES)) {
     DeleteProperty(nsGkAtoms::transitionsOfBeforeProperty);
     DeleteProperty(nsGkAtoms::transitionsOfAfterProperty);
     DeleteProperty(nsGkAtoms::transitionsProperty);
   }
 
   // Unset this since that's what the old code effectively did.
   UnsetFlags(NODE_FORCE_XBL_BINDINGS);
diff --git a/layout/reftests/css-transitions/transitions-inline-already-wrapped-1.html b/layout/reftests/css-transitions/transitions-inline-already-wrapped-1.html
--- a/layout/reftests/css-transitions/transitions-inline-already-wrapped-1.html
+++ b/layout/reftests/css-transitions/transitions-inline-already-wrapped-1.html
@@ -5,21 +5,21 @@
 </style>
 <script type="text/javascript">
 
 window.onload = run;
 
 function run() {
   var test = document.getElementById("test");
   var unused = test.offsetWidth;
-  // FIXME: It's a bug that we need to do this at all: the way we change
-  // style data essentially violates style rule immutability because we
-  // assume that all of the difference calculation will use
-  // PeekStyleData, which is no longer true with transitions.
-  // See the FIXME in nsTransitionManager::ConsiderStartingTransition.
+  // FIXME (Bug 522595): It's a bug that we need to do this at all: the
+  // way we change style data essentially violates style rule
+  // immutability because we assume that all of the difference
+  // calculation will use PeekStyleData, which is no longer true with
+  // transitions.
   unused = getComputedStyle(test, "").color;
   test.style.color = "red";
   unused = test.offsetWidth;
   unused = getComputedStyle(test, "").color;
   document.documentElement.removeAttribute("class");
 }
 
 </script>
diff --git a/layout/reftests/css-transitions/transitions-inline-rewrap-1.html b/layout/reftests/css-transitions/transitions-inline-rewrap-1.html
--- a/layout/reftests/css-transitions/transitions-inline-rewrap-1.html
+++ b/layout/reftests/css-transitions/transitions-inline-rewrap-1.html
@@ -5,21 +5,21 @@
 </style>
 <script type="text/javascript">
 
 window.onload = run;
 
 function run() {
   var test = document.getElementById("test");
   var unused = test.offsetWidth;
-  // FIXME: It's a bug that we need to do this at all: the way we change
-  // style data essentially violates style rule immutability because we
-  // assume that all of the difference calculation will use
-  // PeekStyleData, which is no longer true with transitions.
-  // See the FIXME in nsTransitionManager::ConsiderStartingTransition.
+  // FIXME (Bug 522595): It's a bug that we need to do this at all: the
+  // way we change style data essentially violates style rule
+  // immutability because we assume that all of the difference
+  // calculation will use PeekStyleData, which is no longer true with
+  // transitions.
   unused = getComputedStyle(test, "").color;
   test.style.color = "red";
   unused = test.offsetWidth;
   unused = getComputedStyle(test, "").color;
   test.parentNode.style.width = "3em";
   unused = test.offsetWidth;
   unused = getComputedStyle(test, "").color;
   document.documentElement.removeAttribute("class");
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -3725,17 +3725,17 @@ nsRuleNode::ComputeDisplayData(void* aSt
 
   // Fill in the transitions we just allocated with the appropriate values.
   for (PRUint32 i = 0; i < numTransitions; ++i) {
     nsTransition *transition = &display->mTransitions[i];
 
     if (i >= delay.num) {
       transition->SetDelay(display->mTransitions[i % delay.num].GetDelay());
     } else if (delay.inherited) {
-      // FIXME (for all transition properties): write a test that
+      // FIXME (Bug 522599) (for all transition properties): write a test that
       // detects when this was wrong for i >= delay.num if parent had
       // count for this property not equal to length
       NS_ABORT_IF_FALSE(i < parentDisplay->mTransitionDelayCount,
                         "delay.num computed incorrectly");
       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
                         "should have made canStoreInRuleTree false above");
       transition->SetDelay(parentDisplay->mTransitions[i].GetDelay());
     } else if (delay.list) {
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -1909,18 +1909,18 @@ nsChangeHint nsStyleDisplay::CalcDiffere
       }
   }
   
   // Note:  Our current behavior for handling changes to transition
   // properties is to do nothing.  In other words, the transition
   // property that matters is what it is when the transition begins, and
   // we don't stop a transition later because the transition property
   // changed.
-  // FIXME:  Need to test for this and write it in the spec, if it's
-  // compatible with other browsers.  Test for behavior at
+  // FIXME (Bug 522599):  Need to test for this and write it in the
+  // spec, if it's compatible with other browsers.  Test for behavior at
   // http://dbaron.org/css/test/2009/transitions/dynamic-transition-change
   
   return hint;
 }
 
 #ifdef DEBUG
 /* static */
 nsChangeHint nsStyleDisplay::MaxDifference()
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -200,22 +200,22 @@ ElementTransitionsPropertyDtor(void     
 NS_IMPL_ISUPPORTS1(ElementTransitionsStyleRule, nsIStyleRule)
 
 NS_IMETHODIMP
 ElementTransitionsStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   nsStyleContext *contextParent = aRuleData->mStyleContext->GetParent();
   if (contextParent && contextParent->HasPseudoElementData()) {
     // Don't apply transitions to things inside of pseudo-elements.
-    // FIXME: Add tests for this.
+    // FIXME (Bug 522599): Add tests for this.
     return NS_OK;
   }
 
   ElementTransitions *et = ElementData();
-  NS_ENSURE_TRUE(et, NS_OK); // FIXME: Why can this be null?
+  NS_ENSURE_TRUE(et, NS_OK); // FIXME (Bug 522597): Why can this be null?
   for (PRUint32 i = 0, i_end = et->mPropertyTransitions.Length();
        i < i_end; ++i)
   {
     ElementPropertyTransition &pt = et->mPropertyTransitions[i];
     if (aRuleData->mSIDs & nsCachedStyleData::GetBitForSID(
                              nsCSSProps::kSIDTable[pt.mProperty]))
     {
       double timePortion =
@@ -373,25 +373,25 @@ nsTransitionManager::StyleContextChanged
   if (pseudo && (pseudo != nsCSSPseudoElements::before &&
                  pseudo != nsCSSPseudoElements::after)) {
     return nsnull;
   }
   if (aNewStyleContext->GetParent() &&
       aNewStyleContext->GetParent()->HasPseudoElementData()) {
     // Ignore transitions on things that inherit properties from
     // pseudo-elements.
-    // FIXME: Add tests for this.
+    // FIXME (Bug 522599): Add tests for this.
     return nsnull;
   }
 
-  // FIXME: When we have multiple continuations, we actually repeat this
-  // for each one, and if we have transitions we create separate cover
-  // rules for each one.  However, since we're attaching the transition
-  // data to the element, during the animation we create the same style
-  // rule, so it's not too horrible.
+  // FIXME (Bug 522563): When we have multiple continuations, we
+  // actually repeat this for each one, and if we have transitions we
+  // create separate cover rules for each one.  However, since we're
+  // attaching the transition data to the element, during the animation
+  // we create the same style rule, so it's not too horrible.
 
   // Per http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html
   // I'll consider only the transitions from the number of items in
   // 'transition-property' on down, and later ones will override earlier
   // ones (tracked using |whichStarted|).
   PRBool startedAny = PR_FALSE;
   nsCSSPropertySet whichStarted;
   ElementTransitions *et = nsnull;
@@ -496,21 +496,21 @@ nsTransitionManager::ConsiderStartingTra
   }
 
   if (nsCSSProps::kAnimTypeTable[aProperty] == eStyleAnimType_None) {
     return;
   }
 
   ElementPropertyTransition pt;
   nsStyleCoord dummyValue;
-  // FIXME: This call on the old style context gets incorrect style data
-  // since we don't quite enforce style rule immutability:  we didn't
-  // need to worry about callers calling GetStyleData rather than
-  // PeekStyleData after a style rule becomes "old" before transitions
-  // existed.
+  // FIXME (Bug 522595): This call on the old style context gets
+  // incorrect style data since we don't quite enforce style rule
+  // immutability:  we didn't need to worry about callers calling
+  // GetStyleData rather than PeekStyleData after a style rule becomes
+  // "old" before transitions existed.
   PRBool shouldAnimate =
     nsStyleAnimation::ExtractComputedValue(aProperty, aOldStyleContext,
                                            pt.mStartValue) &&
     nsStyleAnimation::ExtractComputedValue(aProperty, aNewStyleContext,
                                            pt.mEndValue) &&
     pt.mStartValue != pt.mEndValue &&
     // Check that we can interpolate between these values
     // (If this is ever a performance problem, we could add a
diff --git a/layout/style/test/test_transitions.html b/layout/style/test/test_transitions.html
--- a/layout/style/test/test_transitions.html
+++ b/layout/style/test/test_transitions.html
@@ -325,17 +325,17 @@ function make_display_test(initially_non
     div.appendChild(p);
     return p;
 }
 from_none_test   = make_display_test(true,  "transition from display:none");
 to_none_test     = make_display_test(false, "transition to display:none");
 always_none_test = make_display_test(true,  "transition always display:none");
 var display_tests = [ from_none_test, to_none_test, always_none_test ];
 
-// FIXME: Test a transition that reverses partway through.
+// FIXME (Bug 522599): Test a transition that reverses partway through.
 
 var lateref = make_reference_p();
 var laterefcs = getComputedStyle(lateref, "");
 
 // flush style changes
 var x = getComputedStyle(div, "").color;
 
 // Start our timer as close as possible to when we start the first
