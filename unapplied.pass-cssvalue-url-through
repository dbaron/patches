From: L. David Baron <dbaron@dbaron.org>

Pass mozilla::css::URLValue objects through the style system so that we can send correct Referer headers.

TODO: Fix paint server handling in StyleAnimationValue too (from bug 607537).

diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -5558,17 +5558,17 @@ nsComputedDOMStyle::GetSVGPaintFor(bool 
       SetToRGBAColor(val, paint->mPaint.mColor);
       break;
     }
     case eStyleSVGPaintType_Server:
     {
       RefPtr<nsDOMCSSValueList> valueList = GetROCSSValueList(false);
       RefPtr<nsROCSSPrimitiveValue> fallback = new nsROCSSPrimitiveValue;
 
-      val->SetURI(paint->mPaint.mPaintServer);
+      val->SetURI(paint->mPaint.mPaintServer->GetURI());
       SetToRGBAColor(fallback, paint->mFallbackColor);
 
       valueList->AppendCSSValue(val.forget());
       valueList->AppendCSSValue(fallback.forget());
       return valueList.forget();
     }
     case eStyleSVGPaintType_ContextFill:
     {
@@ -5600,47 +5600,47 @@ nsComputedDOMStyle::DoGetStroke()
 already_AddRefed<CSSValue>
 nsComputedDOMStyle::DoGetMarkerEnd()
 {
   RefPtr<nsROCSSPrimitiveValue> val = new nsROCSSPrimitiveValue;
 
   const nsStyleSVG* svg = StyleSVG();
 
   if (svg->mMarkerEnd)
-    val->SetURI(svg->mMarkerEnd);
+    val->SetURI(svg->mMarkerEnd->GetURI());
   else
     val->SetIdent(eCSSKeyword_none);
 
   return val.forget();
 }
 
 already_AddRefed<CSSValue>
 nsComputedDOMStyle::DoGetMarkerMid()
 {
   RefPtr<nsROCSSPrimitiveValue> val = new nsROCSSPrimitiveValue;
 
   const nsStyleSVG* svg = StyleSVG();
 
   if (svg->mMarkerMid)
-    val->SetURI(svg->mMarkerMid);
+    val->SetURI(svg->mMarkerMid->GetURI());
   else
     val->SetIdent(eCSSKeyword_none);
 
   return val.forget();
 }
 
 already_AddRefed<CSSValue>
 nsComputedDOMStyle::DoGetMarkerStart()
 {
   RefPtr<nsROCSSPrimitiveValue> val = new nsROCSSPrimitiveValue;
 
   const nsStyleSVG* svg = StyleSVG();
 
   if (svg->mMarkerStart)
-    val->SetURI(svg->mMarkerStart);
+    val->SetURI(svg->mMarkerStart->GetURI());
   else
     val->SetIdent(eCSSKeyword_none);
 
   return val.forget();
 }
 
 already_AddRefed<CSSValue>
 nsComputedDOMStyle::DoGetStrokeDasharray()
@@ -6026,17 +6026,17 @@ nsComputedDOMStyle::DoGetClipPath()
     case StyleClipPathType::Shape:
       return CreatePrimitiveValueForClipPath(svg->mClipPath.GetBasicShape(),
                                              svg->mClipPath.GetSizingBox());
     case StyleClipPathType::Box:
       return CreatePrimitiveValueForClipPath(nullptr,
                                              svg->mClipPath.GetSizingBox());
     case StyleClipPathType::URL: {
       RefPtr<nsROCSSPrimitiveValue> val = new nsROCSSPrimitiveValue;
-      val->SetURI(svg->mClipPath.GetURL());
+      val->SetURI(svg->mClipPath.GetURL()->GetURI());
       return val.forget();
     }
     case StyleClipPathType::None_: {
       RefPtr<nsROCSSPrimitiveValue> val = new nsROCSSPrimitiveValue;
       val->SetIdent(eCSSKeyword_none);
       return val.forget();
     }
     default:
@@ -6057,17 +6057,17 @@ nsComputedDOMStyle::SetCssTextToCoord(ns
 
 already_AddRefed<CSSValue>
 nsComputedDOMStyle::CreatePrimitiveValueForStyleFilter(
   const nsStyleFilter& aStyleFilter)
 {
   RefPtr<nsROCSSPrimitiveValue> value = new nsROCSSPrimitiveValue;
   // Handle url().
   if (aStyleFilter.GetType() == NS_STYLE_FILTER_URL) {
-    value->SetURI(aStyleFilter.GetURL());
+    value->SetURI(aStyleFilter.GetURL()->GetURI());
     return value.forget();
   }
 
   // Filter function name and opening parenthesis.
   nsAutoString filterFunctionString;
   AppendASCIItoUTF16(
     nsCSSProps::ValueToKeyword(aStyleFilter.GetType(),
                                nsCSSProps::kFilterFunctionKTable),
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -9249,18 +9249,18 @@ SetSVGPaint(const nsCSSValue& aValue, co
                       color, aConditions)) {
     aResult.SetType(eStyleSVGPaintType_Color);
     aResult.mPaint.mColor = color;
   } else if (aValue.GetUnit() == eCSSUnit_Pair) {
     const nsCSSValuePair& pair = aValue.GetPairValue();
 
     if (pair.mXValue.GetUnit() == eCSSUnit_URL) {
       aResult.SetType(eStyleSVGPaintType_Server);
-      aResult.mPaint.mPaintServer = pair.mXValue.GetURLValue();
-      NS_IF_ADDREF(aResult.mPaint.mPaintServer);
+      aResult.mPaint.mPaintServer = pair.mXValue.GetURLStructValue();
+      aResult.mPaint.mPaintServer->AddRef();
     } else if (pair.mXValue.GetUnit() == eCSSUnit_Enumerated) {
 
       switch (pair.mXValue.GetIntValue()) {
       case NS_COLOR_CONTEXT_FILL:
         aResult.SetType(eStyleSVGPaintType_ContextFill);
         break;
       case NS_COLOR_CONTEXT_STROKE:
         aResult.SetType(eStyleSVGPaintType_ContextStroke);
@@ -9367,43 +9367,43 @@ nsRuleNode::ComputeSVGData(void* aStartS
            svg->mFillRule, conditions,
            SETVAL_ENUMERATED | SETVAL_UNSET_INHERIT,
            parentSVG->mFillRule,
            NS_STYLE_FILL_RULE_NONZERO);
 
   // marker-end: url, none, inherit
   const nsCSSValue* markerEndValue = aRuleData->ValueForMarkerEnd();
   if (eCSSUnit_URL == markerEndValue->GetUnit()) {
-    svg->mMarkerEnd = markerEndValue->GetURLValue();
+    svg->mMarkerEnd = markerEndValue->GetURLStructValue();
   } else if (eCSSUnit_None == markerEndValue->GetUnit() ||
              eCSSUnit_Initial == markerEndValue->GetUnit()) {
     svg->mMarkerEnd = nullptr;
   } else if (eCSSUnit_Inherit == markerEndValue->GetUnit() ||
              eCSSUnit_Unset == markerEndValue->GetUnit()) {
     conditions.SetUncacheable();
     svg->mMarkerEnd = parentSVG->mMarkerEnd;
   }
 
   // marker-mid: url, none, inherit
   const nsCSSValue* markerMidValue = aRuleData->ValueForMarkerMid();
   if (eCSSUnit_URL == markerMidValue->GetUnit()) {
-    svg->mMarkerMid = markerMidValue->GetURLValue();
+    svg->mMarkerMid = markerMidValue->GetURLStructValue();
   } else if (eCSSUnit_None == markerMidValue->GetUnit() ||
              eCSSUnit_Initial == markerMidValue->GetUnit()) {
     svg->mMarkerMid = nullptr;
   } else if (eCSSUnit_Inherit == markerMidValue->GetUnit() ||
              eCSSUnit_Unset == markerMidValue->GetUnit()) {
     conditions.SetUncacheable();
     svg->mMarkerMid = parentSVG->mMarkerMid;
   }
 
   // marker-start: url, none, inherit
   const nsCSSValue* markerStartValue = aRuleData->ValueForMarkerStart();
   if (eCSSUnit_URL == markerStartValue->GetUnit()) {
-    svg->mMarkerStart = markerStartValue->GetURLValue();
+    svg->mMarkerStart = markerStartValue->GetURLStructValue();
   } else if (eCSSUnit_None == markerStartValue->GetUnit() ||
              eCSSUnit_Initial == markerStartValue->GetUnit()) {
     svg->mMarkerStart = nullptr;
   } else if (eCSSUnit_Inherit == markerStartValue->GetUnit() ||
              eCSSUnit_Unset == markerStartValue->GetUnit()) {
     conditions.SetUncacheable();
     svg->mMarkerStart = parentSVG->mMarkerStart;
   }
@@ -9775,17 +9775,17 @@ static bool
 SetStyleFilterToCSSValue(nsStyleFilter* aStyleFilter,
                          const nsCSSValue& aValue,
                          nsStyleContext* aStyleContext,
                          nsPresContext* aPresContext,
                          RuleNodeCacheConditions& aConditions)
 {
   nsCSSUnit unit = aValue.GetUnit();
   if (unit == eCSSUnit_URL) {
-    nsIURI* url = aValue.GetURLValue();
+    mozilla::css::URLValue* url = aValue.GetURLStructValue();
     if (!url)
       return false;
     aStyleFilter->SetURL(url);
     return true;
   }
 
   MOZ_ASSERT(unit == eCSSUnit_Function, "expected a filter function");
 
@@ -9885,17 +9885,17 @@ nsRuleNode::ComputeSVGResetData(void* aS
       svgReset->mClipPath = nsStyleClipPath();
       break;
     case eCSSUnit_Inherit:
       conditions.SetUncacheable();
       svgReset->mClipPath = parentSVGReset->mClipPath;
       break;
     case eCSSUnit_URL: {
       svgReset->mClipPath = nsStyleClipPath();
-      nsIURI* url = clipPathValue->GetURLValue();
+      mozilla::css::URLValue* url = clipPathValue->GetURLStructValue();
       if (url) {
         svgReset->mClipPath.SetURL(url);
       }
       break;
     }
     case eCSSUnit_Array: {
       svgReset->mClipPath = nsStyleClipPath();
       SetStyleClipPathToCSSValue(&svgReset->mClipPath, clipPathValue, aContext,
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -1081,17 +1081,17 @@ nsStyleClipPath::ReleaseRef()
     mURL->Release();
   }
   // mBasicShap, mURL, etc. are all pointers in a union of pointers. Nulling
   // one of them nulls all of them:
   mURL = nullptr;
 }
 
 void
-nsStyleClipPath::SetURL(nsIURI* aURL)
+nsStyleClipPath::SetURL(mozilla::css::URLValue* aURL)
 {
   NS_ASSERTION(aURL, "expected pointer");
   ReleaseRef();
   mURL = aURL;
   mURL->AddRef();
   mType = StyleClipPathType::URL;
 }
 
@@ -1202,17 +1202,17 @@ nsStyleFilter::SetFilterParameter(const 
                                   int32_t aType)
 {
   ReleaseRef();
   mFilterParameter = aFilterParameter;
   mType = aType;
 }
 
 void
-nsStyleFilter::SetURL(nsIURI* aURL)
+nsStyleFilter::SetURL(mozilla::css::URLValue* aURL)
 {
   NS_ASSERTION(aURL, "expected pointer");
   ReleaseRef();
   mURL = aURL;
   mURL->AddRef();
   mType = NS_STYLE_FILTER_URL;
 }
 
@@ -1345,17 +1345,17 @@ nsStyleSVGPaint::Reset()
 {
   SetType(nsStyleSVGPaintType(0));
 }
 
 void
 nsStyleSVGPaint::SetType(nsStyleSVGPaintType aType)
 {
   if (mType == eStyleSVGPaintType_Server) {
-    NS_IF_RELEASE(mPaint.mPaintServer);
+    mPaint.mPaintServer->Release();
     mPaint.mPaintServer = nullptr;
   } else {
     mPaint.mColor = NS_RGB(0, 0, 0);
   }
   mType = aType;
 }
 
 nsStyleSVGPaint&
@@ -1365,17 +1365,17 @@ nsStyleSVGPaint::operator=(const nsStyle
     return *this;
   }
 
   SetType(aOther.mType);
 
   mFallbackColor = aOther.mFallbackColor;
   if (mType == eStyleSVGPaintType_Server) {
     mPaint.mPaintServer = aOther.mPaint.mPaintServer;
-    NS_IF_ADDREF(mPaint.mPaintServer);
+    mPaint.mPaintServer->AddRef();
   } else {
     mPaint.mColor = aOther.mPaint.mColor;
   }
   return *this;
 }
 
 bool nsStyleSVGPaint::operator==(const nsStyleSVGPaint& aOther) const
 {
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -33,17 +33,16 @@
 #include "nsCSSValue.h"
 #include "imgRequestProxy.h"
 #include "Orientation.h"
 #include "CounterStyleManager.h"
 #include <cstddef> // offsetof()
 #include <utility>
 
 class nsIFrame;
-class nsIURI;
 class nsStyleContext;
 class nsTextFrame;
 class imgIContainer;
 struct nsStyleVisibility;
 
 // Includes nsStyleStructID.
 #include "nsStyleStructFwd.h"
 
@@ -3273,17 +3272,17 @@ enum nsStyleSVGOpacitySource : uint8_t {
   eStyleSVGOpacitySource_ContextFillOpacity,
   eStyleSVGOpacitySource_ContextStrokeOpacity
 };
 
 struct nsStyleSVGPaint
 {
   union {
     nscolor mColor;
-    nsIURI *mPaintServer;
+    mozilla::css::URLValue *mPaintServer;
   } mPaint;
   nsStyleSVGPaintType mType;
   nscolor mFallbackColor;
 
   explicit nsStyleSVGPaint(nsStyleSVGPaintType aType = nsStyleSVGPaintType(0));
   nsStyleSVGPaint(const nsStyleSVGPaint& aSource);
   ~nsStyleSVGPaint();
   void Reset();
@@ -3325,19 +3324,19 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
     // not handled for descendants, and never returns
     // nsChangeHint_ClearAncestorIntrinsics at all.
     return nsChangeHint_NeedReflow;
   }
   static inline uint32_t ComputationDependencies();
 
   nsStyleSVGPaint  mFill;             // [inherited]
   nsStyleSVGPaint  mStroke;           // [inherited]
-  nsCOMPtr<nsIURI> mMarkerEnd;        // [inherited]
-  nsCOMPtr<nsIURI> mMarkerMid;        // [inherited]
-  nsCOMPtr<nsIURI> mMarkerStart;      // [inherited]
+  RefPtr<mozilla::css::URLValue> mMarkerEnd; // [inherited]
+  RefPtr<mozilla::css::URLValue> mMarkerMid; // [inherited]
+  RefPtr<mozilla::css::URLValue> mMarkerStart; // [inherited]
   nsTArray<nsStyleCoord> mStrokeDasharray;  // [inherited] coord, percent, factor
 
   nsStyleCoord     mStrokeDashoffset; // [inherited] coord, percent, factor
   nsStyleCoord     mStrokeWidth;      // [inherited] coord, percent, factor
 
   float            mFillOpacity;      // [inherited]
   float            mStrokeMiterlimit; // [inherited]
   float            mStrokeOpacity;    // [inherited]
@@ -3540,21 +3539,21 @@ struct nsStyleClipPath
   bool operator!=(const nsStyleClipPath& aOther) const {
     return !(*this == aOther);
   }
 
   mozilla::StyleClipPathType GetType() const {
     return mType;
   }
 
-  nsIURI* GetURL() const {
+  mozilla::css::URLValue* GetURL() const {
     NS_ASSERTION(mType == mozilla::StyleClipPathType::URL, "wrong clip-path type");
     return mURL;
   }
-  void SetURL(nsIURI* aURL);
+  void SetURL(mozilla::css::URLValue* aURL);
 
   nsStyleBasicShape* GetBasicShape() const {
     NS_ASSERTION(mType == mozilla::StyleClipPathType::Shape, "wrong clip-path type");
     return mBasicShape;
   }
 
   void SetBasicShape(nsStyleBasicShape* mBasicShape,
                      mozilla::StyleClipShapeSizing aSizingBox =
@@ -3564,17 +3563,17 @@ struct nsStyleClipPath
   void SetSizingBox(mozilla::StyleClipShapeSizing aSizingBox);
 
 private:
   void ReleaseRef();
   void* operator new(size_t) = delete;
 
   union {
     nsStyleBasicShape* mBasicShape;
-    nsIURI* mURL;
+    mozilla::css::URLValue* mURL;
   };
   mozilla::StyleClipPathType    mType;
   mozilla::StyleClipShapeSizing mSizingBox;
 };
 
 struct nsStyleFilter
 {
   nsStyleFilter();
@@ -3596,35 +3595,35 @@ struct nsStyleFilter
     NS_ASSERTION(mType != NS_STYLE_FILTER_DROP_SHADOW &&
                  mType != NS_STYLE_FILTER_URL &&
                  mType != NS_STYLE_FILTER_NONE, "wrong filter type");
     return mFilterParameter;
   }
   void SetFilterParameter(const nsStyleCoord& aFilterParameter,
                           int32_t aType);
 
-  nsIURI* GetURL() const {
+  mozilla::css::URLValue* GetURL() const {
     NS_ASSERTION(mType == NS_STYLE_FILTER_URL, "wrong filter type");
     return mURL;
   }
-  void SetURL(nsIURI* aURL);
+  void SetURL(mozilla::css::URLValue* aURL);
 
   nsCSSShadowArray* GetDropShadow() const {
     NS_ASSERTION(mType == NS_STYLE_FILTER_DROP_SHADOW, "wrong filter type");
     return mDropShadow;
   }
   void SetDropShadow(nsCSSShadowArray* aDropShadow);
 
 private:
   void ReleaseRef();
 
   int32_t mType; // see NS_STYLE_FILTER_* constants in nsStyleConsts.h
   nsStyleCoord mFilterParameter; // coord, percent, factor, angle
   union {
-    nsIURI* mURL;
+    mozilla::css::URLValue* mURL;
     nsCSSShadowArray* mDropShadow;
   };
 };
 
 template<>
 struct nsTArray_CopyChooser<nsStyleFilter>
 {
   typedef nsTArray_CopyWithConstructors<nsStyleFilter> Type;
diff --git a/layout/svg/nsSVGEffects.cpp b/layout/svg/nsSVGEffects.cpp
--- a/layout/svg/nsSVGEffects.cpp
+++ b/layout/svg/nsSVGEffects.cpp
@@ -172,23 +172,25 @@ nsSVGRenderingObserver::ContentRemoved(n
  * nsSVGIDRenderingObserver object also adds itself to an
  * nsSVGRenderingObserverList object belonging to the referenced
  * element.
  *
  * XXX: it would be nice to have a clear and concise executive summary of the
  * benefits/necessity of maintaining a second observer list.
  */
 
-nsSVGIDRenderingObserver::nsSVGIDRenderingObserver(nsIURI* aURI,
+nsSVGIDRenderingObserver::nsSVGIDRenderingObserver(mozilla::css::URLValue* aURI,
                                                    nsIContent* aObservingContent,
                                                    bool aReferenceImage)
   : mElement(this)
 {
   // Start watching the target element
-  mElement.Reset(aObservingContent, aURI, true, aReferenceImage);
+  // FIXME: Should pass more information from mozilla::css::URLValue.
+  mElement.Reset(aObservingContent, aURI ? aURI->GetURI() : nullptr,
+                 true, aReferenceImage);
   StartListening();
 }
 
 nsSVGIDRenderingObserver::~nsSVGIDRenderingObserver()
 {
   StopListening();
 }
 
@@ -510,34 +512,34 @@ GetEffectProperty(nsIURI *aURI, nsIFrame
     return prop;
   prop = new T(aURI, aFrame, false);
   NS_ADDREF(prop);
   props.Set(aProperty, prop);
   return prop;
 }
 
 nsSVGMarkerProperty *
-nsSVGEffects::GetMarkerProperty(nsIURI *aURI, nsIFrame *aFrame,
+nsSVGEffects::GetMarkerProperty(mozilla::css::URLValue *aURI, nsIFrame *aFrame,
   const mozilla::FramePropertyDescriptor<nsSVGMarkerProperty>* aProperty)
 {
   MOZ_ASSERT(aFrame->GetType() == nsGkAtoms::svgPathGeometryFrame &&
              static_cast<nsSVGPathGeometryElement*>(aFrame->GetContent())->IsMarkable(),
              "Bad frame");
   return GetEffectProperty(aURI, aFrame, aProperty);
 }
 
 nsSVGTextPathProperty *
-nsSVGEffects::GetTextPathProperty(nsIURI *aURI, nsIFrame *aFrame,
+nsSVGEffects::GetTextPathProperty(mozilla::css::URLValue *aURI, nsIFrame *aFrame,
   const mozilla::FramePropertyDescriptor<nsSVGTextPathProperty>* aProperty)
 {
   return GetEffectProperty(aURI, aFrame, aProperty);
 }
 
 nsSVGPaintingProperty *
-nsSVGEffects::GetPaintingProperty(nsIURI *aURI, nsIFrame *aFrame,
+nsSVGEffects::GetPaintingProperty(mozilla::css::URLValue *aURI, nsIFrame *aFrame,
   const mozilla::FramePropertyDescriptor<nsSVGPaintingProperty>* aProperty)
 {
   return GetEffectProperty(aURI, aFrame, aProperty);
 }
 
 nsSVGPaintingProperty *
 nsSVGEffects::GetPaintingPropertyForURI(nsIURI *aURI, nsIFrame *aFrame,
   URIObserverHashtablePropertyDescriptor aProperty)
diff --git a/layout/svg/nsSVGEffects.h b/layout/svg/nsSVGEffects.h
--- a/layout/svg/nsSVGEffects.h
+++ b/layout/svg/nsSVGEffects.h
@@ -16,16 +16,17 @@
 #include "nsInterfaceHashtable.h"
 #include "nsISupportsBase.h"
 #include "nsISupportsImpl.h"
 #include "nsReferencedElement.h"
 #include "nsStubMutationObserver.h"
 #include "nsSVGUtils.h"
 #include "nsTHashtable.h"
 #include "nsURIHashKey.h"
+#include "nsCSSValue.h"
 #include "nsCycleCollectionParticipant.h"
 
 class nsIAtom;
 class nsIPresShell;
 class nsIURI;
 class nsSVGClipPathFrame;
 class nsSVGPaintServerFrame;
 class nsSVGFilterFrame;
@@ -108,18 +109,19 @@ protected:
  * When a frame references a supporting resource, we create a property
  * object derived from nsSVGIDRenderingObserver to manage the relationship. The
  * property object is attached to the referencing frame.
  */
 class nsSVGIDRenderingObserver : public nsSVGRenderingObserver
 {
 public:
   typedef mozilla::dom::Element Element;
-  nsSVGIDRenderingObserver(nsIURI* aURI, nsIContent* aObservingContent,
-                         bool aReferenceImage);
+  nsSVGIDRenderingObserver(mozilla::css::URLValue* aURI,
+                           nsIContent* aObservingContent,
+                           bool aReferenceImage);
   virtual ~nsSVGIDRenderingObserver();
 
 protected:
   Element* GetTarget() override { return mElement.get(); }
 
   // This is called when the referenced resource changes.
   virtual void DoUpdate() override;
 
@@ -297,27 +299,29 @@ protected:
   virtual void DoUpdate() override;
 
   nsSVGFrameReferenceFromProperty mFrameReference;
 };
 
 class nsSVGMarkerProperty final: public nsSVGRenderingObserverProperty
 {
 public:
-  nsSVGMarkerProperty(nsIURI *aURI, nsIFrame *aFrame, bool aReferenceImage)
+  nsSVGMarkerProperty(mozilla::css::URLValue *aURI, nsIFrame *aFrame,
+                      bool aReferenceImage)
     : nsSVGRenderingObserverProperty(aURI, aFrame, aReferenceImage) {}
 
 protected:
   virtual void DoUpdate() override;
 };
 
 class nsSVGTextPathProperty final : public nsSVGRenderingObserverProperty
 {
 public:
-  nsSVGTextPathProperty(nsIURI *aURI, nsIFrame *aFrame, bool aReferenceImage)
+  nsSVGTextPathProperty(mozilla::css::URLValue *aURI, nsIFrame *aFrame,
+                        bool aReferenceImage)
     : nsSVGRenderingObserverProperty(aURI, aFrame, aReferenceImage)
     , mValid(true) {}
 
   virtual bool ObservesReflow() override { return false; }
 
 protected:
   virtual void DoUpdate() override;
 
@@ -328,17 +332,18 @@ private:
   bool TargetIsValid();
 
   bool mValid;
 };
 
 class nsSVGPaintingProperty final : public nsSVGRenderingObserverProperty
 {
 public:
-  nsSVGPaintingProperty(nsIURI *aURI, nsIFrame *aFrame, bool aReferenceImage)
+  nsSVGPaintingProperty(mozilla::css::URLValue *aURI, nsIFrame *aFrame,
+                        bool aReferenceImage)
     : nsSVGRenderingObserverProperty(aURI, aFrame, aReferenceImage) {}
 
 protected:
   virtual void DoUpdate() override;
 };
 
 class nsSVGMaskProperty final : public nsISupports
 {
@@ -566,29 +571,29 @@ public:
    */
   static void InvalidateDirectRenderingObservers(Element *aElement, uint32_t aFlags = 0);
   static void InvalidateDirectRenderingObservers(nsIFrame *aFrame, uint32_t aFlags = 0);
 
   /**
    * Get an nsSVGMarkerProperty for the frame, creating a fresh one if necessary
    */
   static nsSVGMarkerProperty *
-  GetMarkerProperty(nsIURI *aURI, nsIFrame *aFrame,
+  GetMarkerProperty(mozilla::css::URLValue *aURI, nsIFrame *aFrame,
     const mozilla::FramePropertyDescriptor<nsSVGMarkerProperty>* aProperty);
   /**
    * Get an nsSVGTextPathProperty for the frame, creating a fresh one if necessary
    */
   static nsSVGTextPathProperty *
-  GetTextPathProperty(nsIURI *aURI, nsIFrame *aFrame,
+  GetTextPathProperty(mozilla::css::URLValue *aURI, nsIFrame *aFrame,
     const mozilla::FramePropertyDescriptor<nsSVGTextPathProperty>* aProperty);
   /**
    * Get an nsSVGPaintingProperty for the frame, creating a fresh one if necessary
    */
   static nsSVGPaintingProperty *
-  GetPaintingProperty(nsIURI *aURI, nsIFrame *aFrame,
+  GetPaintingProperty(mozilla::css::URLValue *aURI, nsIFrame *aFrame,
       const mozilla::FramePropertyDescriptor<nsSVGPaintingProperty>* aProperty);
   /**
    * Get an nsSVGPaintingProperty for the frame for that URI, creating a fresh
    * one if necessary
    */
   static nsSVGPaintingProperty *
   GetPaintingPropertyForURI(nsIURI *aURI, nsIFrame *aFrame,
                             URIObserverHashtablePropertyDescriptor aProp);
diff --git a/layout/svg/nsSVGGradientFrame.cpp b/layout/svg/nsSVGGradientFrame.cpp
--- a/layout/svg/nsSVGGradientFrame.cpp
+++ b/layout/svg/nsSVGGradientFrame.cpp
@@ -327,19 +327,24 @@ nsSVGGradientFrame::GetReferencedGradien
       return nullptr; // no URL
     }
 
     // Convert href to an nsIURI
     nsCOMPtr<nsIURI> targetURI;
     nsCOMPtr<nsIURI> base = mContent->GetBaseURI();
     nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(targetURI), href,
                                               mContent->GetUncomposedDoc(), base);
+    RefPtr<mozilla::css::URLValue> url =
+      new mozilla::css::URLValue(targetURI,
+                                 nsCSSValue::BufferFromString(href),
+                                 mContent->GetOwnerDoc()->GetDocumentURI(),
+                                 mContent->NodePrincipal());
 
     property =
-      nsSVGEffects::GetPaintingProperty(targetURI, this,
+      nsSVGEffects::GetPaintingProperty(url, this,
                                         nsSVGEffects::HrefAsPaintingProperty());
     if (!property)
       return nullptr;
   }
 
   nsIFrame *result = property->GetReferencedFrame();
   if (!result)
     return nullptr;
diff --git a/layout/svg/nsSVGPatternFrame.cpp b/layout/svg/nsSVGPatternFrame.cpp
--- a/layout/svg/nsSVGPatternFrame.cpp
+++ b/layout/svg/nsSVGPatternFrame.cpp
@@ -562,19 +562,24 @@ nsSVGPatternFrame::GetReferencedPattern(
       return nullptr; // no URL
     }
 
     // Convert href to an nsIURI
     nsCOMPtr<nsIURI> targetURI;
     nsCOMPtr<nsIURI> base = mContent->GetBaseURI();
     nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(targetURI), href,
                                               mContent->GetUncomposedDoc(), base);
+    RefPtr<mozilla::css::URLValue> url =
+      new mozilla::css::URLValue(targetURI,
+                                 nsCSSValue::BufferFromString(href),
+                                 mContent->GetOwnerDoc()->GetDocumentURI(),
+                                 mContent->NodePrincipal());
 
     property =
-      nsSVGEffects::GetPaintingProperty(targetURI, this,
+      nsSVGEffects::GetPaintingProperty(url, this,
                                         nsSVGEffects::HrefAsPaintingProperty());
     if (!property)
       return nullptr;
   }
 
   nsIFrame *result = property->GetReferencedFrame();
   if (!result)
     return nullptr;
