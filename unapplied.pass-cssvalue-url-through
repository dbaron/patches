From: L. David Baron <dbaron@dbaron.org>

Pass mozilla::css::URLValue objects through the style system so that we can send correct Referer headers.

TODO: Fix paint server handling in StyleAnimationValue too (from bug 607537).

diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -123,22 +123,22 @@ static bool AreShadowArraysEqual(nsCSSSh
 //
 void
 FragmentOrURL::SetValue(const nsCSSValue* aValue)
 {
   mozilla::css::URLValue *urlVal = aValue->GetURLStructValue();
   MOZ_ASSERT_IF(urlVal->GetLocalURLFlag(), urlVal->GetURI());
   mIsLocalRef = urlVal->GetLocalURLFlag();
 
-  mURL = urlVal->GetURI();
+  mURL = urlVal;
 
 #ifdef DEBUG
   if (mIsLocalRef) {
     bool hasRef = false;
-    mURL->GetHasRef(&hasRef);
+    mURL->GetURI()->GetHasRef(&hasRef);
     MOZ_ASSERT(hasRef);
   }
 #endif
 }
 
 void
 FragmentOrURL::SetNull()
 {
@@ -164,49 +164,49 @@ FragmentOrURL::operator==(const Fragment
 
   return EqualURIs(aOther.mURL, mURL);
 }
 
 bool
 FragmentOrURL::EqualsExceptRef(nsIURI* aURI) const
 {
   bool ret = false;
-  mURL->EqualsExceptRef(aURI, &ret);
+  mURL->GetURI()->EqualsExceptRef(aURI, &ret);
   return ret;
 }
 
 void
 FragmentOrURL::GetSourceString(nsString &aRef) const
 {
   MOZ_ASSERT(mURL);
 
   nsCString cref;
   if (mIsLocalRef) {
-    mURL->GetRef(cref);
+    mURL->GetURI()->GetRef(cref);
     cref.Insert('#', 0);
   } else {
-    mURL->GetSpec(cref);
+    mURL->GetURI()->GetSpec(cref);
   }
 
   aRef = NS_ConvertUTF8toUTF16(cref);
 }
 
 already_AddRefed<nsIURI>
 FragmentOrURL::Resolve(nsIURI* aURI) const
 {
   nsCOMPtr<nsIURI> result;
 
   if (mIsLocalRef) {
     nsCString ref;
-    mURL->GetRef(ref);
+    mURL->GetURI()->GetRef(ref);
 
     aURI->Clone(getter_AddRefs(result));
     result->SetRef(ref);
   } else {
-    result = mURL;
+    result = mURL->GetURI();
   }
 
   return result.forget();
 }
 
 already_AddRefed<nsIURI>
 FragmentOrURL::Resolve(nsIContent* aContent) const
 {
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -34,17 +34,16 @@
 #include "nsCSSValue.h"
 #include "imgRequestProxy.h"
 #include "Orientation.h"
 #include "CounterStyleManager.h"
 #include <cstddef> // offsetof()
 #include <utility>
 
 class nsIFrame;
-class nsIURI;
 class nsStyleContext;
 class nsTextFrame;
 class imgIContainer;
 struct nsStyleVisibility;
 
 // Includes nsStyleStructID.
 #include "nsStyleStructFwd.h"
 
@@ -123,28 +122,29 @@ struct FragmentOrURL
   FragmentOrURL& operator=(const FragmentOrURL& aOther);
   bool operator==(const FragmentOrURL& aOther) const;
   bool operator!=(const FragmentOrURL& aOther) const {
     return !(*this == aOther);
   }
 
   bool EqualsExceptRef(nsIURI* aURI) const;
 
-  nsIURI* GetSourceURL() const { return mURL; }
+  nsIURI* GetSourceURL() const { return mURL->GetURI(); }
+  mozilla::css::URLValue* GetURLValue() const { return mURL; }
   void GetSourceString(nsString& aRef) const;
 
   // When matching a url with mIsLocalRef set, resolve it against aURI;
   // Otherwise, ignore aURL and return mURL directly.
   already_AddRefed<nsIURI> Resolve(nsIURI* aURI) const;
   already_AddRefed<nsIURI> Resolve(nsIContent* aContent) const;
 
   bool IsLocalRef() const { return mIsLocalRef; }
 
 private:
-  nsCOMPtr<nsIURI> mURL;
+  RefPtr<mozilla::css::URLValue> mURL;
   bool    mIsLocalRef;
 };
 
 // The lifetime of these objects is managed by the presshell's arena.
 struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsStyleFont
 {
   nsStyleFont(const nsFont& aFont, StyleStructContext aContext);
   nsStyleFont(const nsStyleFont& aStyleFont);
diff --git a/layout/svg/nsSVGEffects.cpp b/layout/svg/nsSVGEffects.cpp
--- a/layout/svg/nsSVGEffects.cpp
+++ b/layout/svg/nsSVGEffects.cpp
@@ -173,23 +173,25 @@ nsSVGRenderingObserver::ContentRemoved(n
  * nsSVGIDRenderingObserver object also adds itself to an
  * nsSVGRenderingObserverList object belonging to the referenced
  * element.
  *
  * XXX: it would be nice to have a clear and concise executive summary of the
  * benefits/necessity of maintaining a second observer list.
  */
 
-nsSVGIDRenderingObserver::nsSVGIDRenderingObserver(nsIURI* aURI,
+nsSVGIDRenderingObserver::nsSVGIDRenderingObserver(mozilla::css::URLValue* aURI,
                                                    nsIContent* aObservingContent,
                                                    bool aReferenceImage)
   : mElement(this)
 {
   // Start watching the target element
-  mElement.Reset(aObservingContent, aURI, true, aReferenceImage);
+  // FIXME: Should pass more information from mozilla::css::URLValue.
+  mElement.Reset(aObservingContent, aURI ? aURI->GetURI() : nullptr,
+                 true, aReferenceImage);
   StartListening();
 }
 
 nsSVGIDRenderingObserver::~nsSVGIDRenderingObserver()
 {
   StopListening();
 }
 
@@ -518,34 +520,34 @@ GetEffectProperty(nsIURI* aURI, nsIFrame
     return prop;
   prop = new T(aURI, aFrame, false);
   NS_ADDREF(prop);
   props.Set(aProperty, prop);
   return prop;
 }
 
 nsSVGMarkerProperty*
-nsSVGEffects::GetMarkerProperty(nsIURI* aURI, nsIFrame* aFrame,
+nsSVGEffects::GetMarkerProperty(mozilla::css::URLValue* aURI, nsIFrame* aFrame,
   const mozilla::FramePropertyDescriptor<nsSVGMarkerProperty>* aProperty)
 {
   MOZ_ASSERT(aFrame->GetType() == nsGkAtoms::svgPathGeometryFrame &&
              static_cast<nsSVGPathGeometryElement*>(aFrame->GetContent())->IsMarkable(),
              "Bad frame");
   return GetEffectProperty(aURI, aFrame, aProperty);
 }
 
 nsSVGTextPathProperty*
-nsSVGEffects::GetTextPathProperty(nsIURI* aURI, nsIFrame* aFrame,
+nsSVGEffects::GetTextPathProperty(mozilla::css::URLValue* aURI, nsIFrame* aFrame,
   const mozilla::FramePropertyDescriptor<nsSVGTextPathProperty>* aProperty)
 {
   return GetEffectProperty(aURI, aFrame, aProperty);
 }
 
 nsSVGPaintingProperty*
-nsSVGEffects::GetPaintingProperty(nsIURI* aURI, nsIFrame* aFrame,
+nsSVGEffects::GetPaintingProperty(mozilla::css::URLValue* aURI, nsIFrame* aFrame,
   const mozilla::FramePropertyDescriptor<nsSVGPaintingProperty>* aProperty)
 {
   return GetEffectProperty(aURI, aFrame, aProperty);
 }
 
 nsSVGPaintingProperty*
 nsSVGEffects::GetPaintingPropertyForURI(nsIURI* aURI, nsIFrame* aFrame,
   URIObserverHashtablePropertyDescriptor aProperty)
diff --git a/layout/svg/nsSVGEffects.h b/layout/svg/nsSVGEffects.h
--- a/layout/svg/nsSVGEffects.h
+++ b/layout/svg/nsSVGEffects.h
@@ -16,16 +16,17 @@
 #include "nsInterfaceHashtable.h"
 #include "nsISupportsBase.h"
 #include "nsISupportsImpl.h"
 #include "nsReferencedElement.h"
 #include "nsStubMutationObserver.h"
 #include "nsSVGUtils.h"
 #include "nsTHashtable.h"
 #include "nsURIHashKey.h"
+#include "nsCSSValue.h"
 #include "nsCycleCollectionParticipant.h"
 
 class nsIAtom;
 class nsIPresShell;
 class nsIURI;
 class nsSVGClipPathFrame;
 class nsSVGPaintServerFrame;
 class nsSVGFilterFrame;
@@ -108,18 +109,19 @@ protected:
  * When a frame references a supporting resource, we create a property
  * object derived from nsSVGIDRenderingObserver to manage the relationship. The
  * property object is attached to the referencing frame.
  */
 class nsSVGIDRenderingObserver : public nsSVGRenderingObserver
 {
 public:
   typedef mozilla::dom::Element Element;
-  nsSVGIDRenderingObserver(nsIURI* aURI, nsIContent* aObservingContent,
-                         bool aReferenceImage);
+  nsSVGIDRenderingObserver(mozilla::css::URLValue* aURI,
+                           nsIContent* aObservingContent,
+                           bool aReferenceImage);
   virtual ~nsSVGIDRenderingObserver();
 
 protected:
   Element* GetTarget() override { return mElement.get(); }
 
   // This is called when the referenced resource changes.
   virtual void DoUpdate() override;
 
@@ -299,27 +301,29 @@ protected:
   virtual void DoUpdate() override;
 
   nsSVGFrameReferenceFromProperty mFrameReference;
 };
 
 class nsSVGMarkerProperty final: public nsSVGRenderingObserverProperty
 {
 public:
-  nsSVGMarkerProperty(nsIURI* aURI, nsIFrame* aFrame, bool aReferenceImage)
+  nsSVGMarkerProperty(mozilla::css::URLValue* aURI, nsIFrame* aFrame,
+                      bool aReferenceImage)
     : nsSVGRenderingObserverProperty(aURI, aFrame, aReferenceImage) {}
 
 protected:
   virtual void DoUpdate() override;
 };
 
 class nsSVGTextPathProperty final : public nsSVGRenderingObserverProperty
 {
 public:
-  nsSVGTextPathProperty(nsIURI* aURI, nsIFrame* aFrame, bool aReferenceImage)
+  nsSVGTextPathProperty(mozilla::css::URLValue* aURI, nsIFrame* aFrame,
+                        bool aReferenceImage)
     : nsSVGRenderingObserverProperty(aURI, aFrame, aReferenceImage)
     , mValid(true) {}
 
   virtual bool ObservesReflow() override { return false; }
 
 protected:
   virtual void DoUpdate() override;
 
@@ -330,17 +334,18 @@ private:
   bool TargetIsValid();
 
   bool mValid;
 };
 
 class nsSVGPaintingProperty final : public nsSVGRenderingObserverProperty
 {
 public:
-  nsSVGPaintingProperty(nsIURI* aURI, nsIFrame* aFrame, bool aReferenceImage)
+  nsSVGPaintingProperty(mozilla::css::URLValue* aURI, nsIFrame* aFrame,
+                        bool aReferenceImage)
     : nsSVGRenderingObserverProperty(aURI, aFrame, aReferenceImage) {}
 
 protected:
   virtual void DoUpdate() override;
 };
 
 class nsSVGMaskProperty final : public nsISupports
 {
@@ -568,29 +573,29 @@ public:
    */
   static void InvalidateDirectRenderingObservers(Element* aElement, uint32_t aFlags = 0);
   static void InvalidateDirectRenderingObservers(nsIFrame* aFrame, uint32_t aFlags = 0);
 
   /**
    * Get an nsSVGMarkerProperty for the frame, creating a fresh one if necessary
    */
   static nsSVGMarkerProperty *
-  GetMarkerProperty(nsIURI* aURI, nsIFrame* aFrame,
+  GetMarkerProperty(mozilla::css::URLValue* aURI, nsIFrame* aFrame,
     const mozilla::FramePropertyDescriptor<nsSVGMarkerProperty>* aProperty);
   /**
    * Get an nsSVGTextPathProperty for the frame, creating a fresh one if necessary
    */
   static nsSVGTextPathProperty *
-  GetTextPathProperty(nsIURI* aURI, nsIFrame* aFrame,
+  GetTextPathProperty(mozilla::css::URLValue* aURI, nsIFrame* aFrame,
     const mozilla::FramePropertyDescriptor<nsSVGTextPathProperty>* aProperty);
   /**
    * Get an nsSVGPaintingProperty for the frame, creating a fresh one if necessary
    */
   static nsSVGPaintingProperty*
-  GetPaintingProperty(nsIURI* aURI, nsIFrame* aFrame,
+  GetPaintingProperty(mozilla::css::URLValue* aURI, nsIFrame* aFrame,
       const mozilla::FramePropertyDescriptor<nsSVGPaintingProperty>* aProperty);
   /**
    * Get an nsSVGPaintingProperty for the frame for that URI, creating a fresh
    * one if necessary
    */
   static nsSVGPaintingProperty*
   GetPaintingPropertyForURI(nsIURI* aURI, nsIFrame* aFrame,
                             URIObserverHashtablePropertyDescriptor aProp);
diff --git a/layout/svg/nsSVGGradientFrame.cpp b/layout/svg/nsSVGGradientFrame.cpp
--- a/layout/svg/nsSVGGradientFrame.cpp
+++ b/layout/svg/nsSVGGradientFrame.cpp
@@ -327,19 +327,24 @@ nsSVGGradientFrame::GetReferencedGradien
       return nullptr; // no URL
     }
 
     // Convert href to an nsIURI
     nsCOMPtr<nsIURI> targetURI;
     nsCOMPtr<nsIURI> base = mContent->GetBaseURI();
     nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(targetURI), href,
                                               mContent->GetUncomposedDoc(), base);
+    RefPtr<mozilla::css::URLValue> url =
+      new mozilla::css::URLValue(targetURI,
+                                 nsCSSValue::BufferFromString(href),
+                                 mContent->GetOwnerDoc()->GetDocumentURI(),
+                                 mContent->NodePrincipal());
 
     property =
-      nsSVGEffects::GetPaintingProperty(targetURI, this,
+      nsSVGEffects::GetPaintingProperty(url, this,
                                         nsSVGEffects::HrefAsPaintingProperty());
     if (!property)
       return nullptr;
   }
 
   nsIFrame *result = property->GetReferencedFrame();
   if (!result)
     return nullptr;
diff --git a/layout/svg/nsSVGPatternFrame.cpp b/layout/svg/nsSVGPatternFrame.cpp
--- a/layout/svg/nsSVGPatternFrame.cpp
+++ b/layout/svg/nsSVGPatternFrame.cpp
@@ -562,19 +562,24 @@ nsSVGPatternFrame::GetReferencedPattern(
       return nullptr; // no URL
     }
 
     // Convert href to an nsIURI
     nsCOMPtr<nsIURI> targetURI;
     nsCOMPtr<nsIURI> base = mContent->GetBaseURI();
     nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(targetURI), href,
                                               mContent->GetUncomposedDoc(), base);
+    RefPtr<mozilla::css::URLValue> url =
+      new mozilla::css::URLValue(targetURI,
+                                 nsCSSValue::BufferFromString(href),
+                                 mContent->GetOwnerDoc()->GetDocumentURI(),
+                                 mContent->NodePrincipal());
 
     property =
-      nsSVGEffects::GetPaintingProperty(targetURI, this,
+      nsSVGEffects::GetPaintingProperty(url, this,
                                         nsSVGEffects::HrefAsPaintingProperty());
     if (!property)
       return nullptr;
   }
 
   nsIFrame *result = property->GetReferencedFrame();
   if (!result)
     return nullptr;
