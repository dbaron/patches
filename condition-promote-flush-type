From: L. David Baron <dbaron@dbaron.org>

Bug 1368348 - Condition changing flush type for media queries on media queries actually being present.

This modifies code that was originally added in changeset
b62942dc462209526159c654454d968a345020f2 for bug 156716.

For what it's worth, Chromium appears to have tests for size-dependent
media queries, but it only uses them to determine whether
getComputedStyle() results require flushing layout.  That is, it appears
to give out-of-date results for flushes other than getComputedStyle()
when a parent requires layout that would change a media query.

TODO: Fix two stylo-only mochitest failures:
  TEST-UNEXPECTED-FAIL | layout/style/test/test_bug453896_deck.html | all and (width: 157px) should apply
  TEST-UNEXPECTED-FAIL | layout/style/test/test_media_queries.html | all and (width: 117px) should apply

MozReview-Commit-ID: ETxokFiNc5T

diff --git a/dom/base/nsDocument.cpp b/dom/base/nsDocument.cpp
--- a/dom/base/nsDocument.cpp
+++ b/dom/base/nsDocument.cpp
@@ -8045,24 +8045,32 @@ nsDocument::FlushPendingNotifications(Fl
     return;
   }
 
   // If we have a parent we must flush the parent too to ensure that our
   // container is reflowed if its size was changed.  But if it's not safe to
   // flush ourselves, then don't flush the parent, since that can cause things
   // like resizes of our frame's widget, which we can't handle while flushing
   // is unsafe.
-  // Since media queries mean that a size change of our container can
-  // affect style, we need to promote a style flush on ourself to a
-  // layout flush on our parent, since we need our container to be the
-  // correct size to determine the correct style.
   if (mParentDocument && IsSafeToFlush()) {
     FlushType parentType = aType;
-    if (aType >= FlushType::Style)
-      parentType = std::max(FlushType::Layout, aType);
+
+    // Since media queries mean that a size change of our container can
+    // affect style, if we have media queries on our size, we need to
+    // promote a style flush on ourself to a layout flush on our parent,
+    // since we need our container to be the correct size to determine
+    // the correct style.
+    if (aType >= FlushType::Style) {
+      nsIPresShell* shell = GetShell();
+      nsPresContext* presContext = shell ? shell->GetPresContext() : nullptr;
+      if (presContext && presContext->HasSizeMediaQueries()) {
+        parentType = std::max(FlushType::Layout, aType);
+      }
+    }
+
     mParentDocument->FlushPendingNotifications(parentType);
   }
 
   if (nsIPresShell* shell = GetShell()) {
     shell->FlushPendingNotifications(aType);
   }
 }
 
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -289,17 +289,18 @@ nsPresContext::nsPresContext(nsIDocument
     mIsChrome(false),
     mIsChromeOriginImage(false),
     mPaintFlashing(false),
     mPaintFlashingInitialized(false),
     mHasWarnedAboutPositionedTableParts(false),
     mHasWarnedAboutTooLargeDashedOrDottedRadius(false),
     mQuirkSheetAdded(false),
     mNeedsPrefUpdate(false),
-    mHadNonBlankPaint(false)
+    mHadNonBlankPaint(false),
+    mHasSizeMediaQueries(false)
 #ifdef RESTYLE_LOGGING
     , mRestyleLoggingEnabled(false)
 #endif
 #ifdef DEBUG
     , mInitialized(false)
 #endif
 {
   PodZero(&mBorderWidthTable);
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -1180,16 +1180,24 @@ public:
   bool HasWarnedAboutTooLargeDashedOrDottedRadius() const {
     return mHasWarnedAboutTooLargeDashedOrDottedRadius;
   }
 
   void SetHasWarnedAboutTooLargeDashedOrDottedRadius() {
     mHasWarnedAboutTooLargeDashedOrDottedRadius = true;
   }
 
+  bool HasSizeMediaQueries() const {
+    return mHasSizeMediaQueries;
+  }
+
+  void SetHasSizeMediaQueries() {
+    mHasSizeMediaQueries = true;
+  }
+
   nsBidi& GetBidiEngine();
 
   /**
    * State that is cleared each reflow, to indicate that something
    * earlier in the document was dirty during this reflow.  This is
    * helpful for optimizing incremental reflows that occur during
    * document loading to avoid O(N^2) algorithms.
    */
@@ -1508,16 +1516,19 @@ protected:
   unsigned              mQuirkSheetAdded : 1;
 
   // Is there a pref update to process once we have a container?
   unsigned              mNeedsPrefUpdate : 1;
 
   // Has NotifyNonBlankPaint been called on this PresContext?
   unsigned              mHadNonBlankPaint : 1;
 
+  // Do we have any media queries on our size?
+  unsigned              mHasSizeMediaQueries : 1;
+
 #ifdef RESTYLE_LOGGING
   // Should we output debug information about restyling for this document?
   unsigned mRestyleLoggingEnabled : 1;
 #endif
 
 #ifdef DEBUG
   unsigned mInitialized : 1;
 #endif
diff --git a/layout/style/nsMediaFeatures.cpp b/layout/style/nsMediaFeatures.cpp
--- a/layout/style/nsMediaFeatures.cpp
+++ b/layout/style/nsMediaFeatures.cpp
@@ -82,16 +82,20 @@ static nsSize
 GetSize(nsPresContext* aPresContext)
 {
   nsSize size;
   if (aPresContext->IsRootPaginatedDocument())
     // We want the page size, including unprintable areas and margins.
     size = aPresContext->GetPageSize();
   else
     size = aPresContext->GetVisibleArea().Size();
+
+  // FIXME: Does this need to be proxied to the main thread for stylo?
+  aPresContext->SetHasSizeMediaQueries();
+
   return size;
 }
 
 static void
 GetWidth(nsPresContext* aPresContext, const nsMediaFeature*,
          nsCSSValue& aResult)
 {
   nsSize size = GetSize(aPresContext);
