From: L. David Baron <dbaron@dbaron.org>

Bug 1329601 - Condition changing flush type for media queries on media queries actually being present.

This modifies code that was originally added in changeset
b62942dc462209526159c654454d968a345020f2 for bug 156716.

MozReview-Commit-ID: ETxokFiNc5T

diff --git a/dom/base/nsDocument.cpp b/dom/base/nsDocument.cpp
--- a/dom/base/nsDocument.cpp
+++ b/dom/base/nsDocument.cpp
@@ -8059,24 +8059,34 @@ nsDocument::FlushPendingNotifications(Fl
     return;
   }
 
   // If we have a parent we must flush the parent too to ensure that our
   // container is reflowed if its size was changed.  But if it's not safe to
   // flush ourselves, then don't flush the parent, since that can cause things
   // like resizes of our frame's widget, which we can't handle while flushing
   // is unsafe.
-  // Since media queries mean that a size change of our container can
-  // affect style, we need to promote a style flush on ourself to a
-  // layout flush on our parent, since we need our container to be the
-  // correct size to determine the correct style.
   if (mParentDocument && IsSafeToFlush()) {
     FlushType parentType = aType;
-    if (aType >= FlushType::Style)
-      parentType = std::max(FlushType::Layout, aType);
+
+    // Since media queries mean that a size change of our container can
+    // affect style, if we have media queries on our size, we need to
+    // promote a style flush on ourself to a layout flush on our parent,
+    // since we need our container to be the correct size to determine
+    // the correct style.
+    if (aType >= FlushType::Style) {
+      nsIPresShell* shell = GetShell();
+      nsPresContext* presContext = shell ? shell->GetPresContext() : nullptr;
+      if (presContext && presContext->HasSizeMediaQueries()) {
+        parentType = std::max(FlushType::Layout, aType);
+      }
+    }
+
+    // FIXME: If parentType is FlushType::Style, why do we need to
+    // promote the flush to the parent?
     mParentDocument->FlushPendingNotifications(parentType);
   }
 
   if (nsIPresShell* shell = GetShell()) {
     shell->FlushPendingNotifications(aType);
   }
 }
 
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -285,17 +285,18 @@ nsPresContext::nsPresContext(nsIDocument
     mIsChrome(false),
     mIsChromeOriginImage(false),
     mPaintFlashing(false),
     mPaintFlashingInitialized(false),
     mHasWarnedAboutPositionedTableParts(false),
     mHasWarnedAboutTooLargeDashedOrDottedRadius(false),
     mQuirkSheetAdded(false),
     mNeedsPrefUpdate(false),
-    mHadNonBlankPaint(false)
+    mHadNonBlankPaint(false),
+    mHasSizeMediaQueries(false)
 #ifdef RESTYLE_LOGGING
     , mRestyleLoggingEnabled(false)
 #endif
 #ifdef DEBUG
     , mInitialized(false)
 #endif
 {
   PodZero(&mBorderWidthTable);
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -1190,16 +1190,24 @@ public:
   bool HasWarnedAboutTooLargeDashedOrDottedRadius() const {
     return mHasWarnedAboutTooLargeDashedOrDottedRadius;
   }
 
   void SetHasWarnedAboutTooLargeDashedOrDottedRadius() {
     mHasWarnedAboutTooLargeDashedOrDottedRadius = true;
   }
 
+  bool SetHasSizeMediaQueries() {
+    mHasSizeMediaQueries = true;
+  }
+
+  bool HasSizeMediaQueries() const {
+    return mHasSizeMediaQueries;
+  }
+
   nsBidi& GetBidiEngine();
 
   /**
    * State that is cleared each reflow, to indicate that something
    * earlier in the document was dirty during this reflow.  This is
    * helpful for optimizing incremental reflows that occur during
    * document loading to avoid O(N^2) algorithms.
    */
@@ -1520,16 +1528,19 @@ protected:
   unsigned              mQuirkSheetAdded : 1;
 
   // Is there a pref update to process once we have a container?
   unsigned              mNeedsPrefUpdate : 1;
 
   // Has NotifyNonBlankPaint been called on this PresContext?
   unsigned              mHadNonBlankPaint : 1;
 
+  // Do we have any media queries on our size?
+  unsigned              mHasSizeMediaQueries : 1;
+
 #ifdef RESTYLE_LOGGING
   // Should we output debug information about restyling for this document?
   bool                  mRestyleLoggingEnabled;
 #endif
 
 #ifdef DEBUG
   bool                  mInitialized;
 #endif
diff --git a/layout/style/nsMediaFeatures.cpp b/layout/style/nsMediaFeatures.cpp
--- a/layout/style/nsMediaFeatures.cpp
+++ b/layout/style/nsMediaFeatures.cpp
@@ -82,16 +82,20 @@ static nsSize
 GetSize(nsPresContext* aPresContext)
 {
   nsSize size;
   if (aPresContext->IsRootPaginatedDocument())
     // We want the page size, including unprintable areas and margins.
     size = aPresContext->GetPageSize();
   else
     size = aPresContext->GetVisibleArea().Size();
+
+  // FIXME: Does this need to be proxied to the main thread for stylo?
+  aPresContext->SetHasSizeMediaQueries();
+
   return size;
 }
 
 static void
 GetWidth(nsPresContext* aPresContext, const nsMediaFeature*,
          nsCSSValue& aResult)
 {
   nsSize size = GetSize(aPresContext);
