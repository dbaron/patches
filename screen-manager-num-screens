Remove mNumScreens since it duplicates the length of mCachedScreenArray.  (Bug 403706)  r+sr=roc

diff --git a/widget/src/gtk2/nsScreenManagerGtk.cpp b/widget/src/gtk2/nsScreenManagerGtk.cpp
--- a/widget/src/gtk2/nsScreenManagerGtk.cpp
+++ b/widget/src/gtk2/nsScreenManagerGtk.cpp
@@ -50,17 +50,16 @@ typedef Bool (*_XnrmIsActive_fn)(Display
 typedef Bool (*_XnrmIsActive_fn)(Display *dpy);
 typedef XineramaScreenInfo* (*_XnrmQueryScreens_fn)(Display *dpy, int *number);
 
 nsScreenManagerGtk :: nsScreenManagerGtk ( )
 {
   // nothing else to do. I guess we could cache a bunch of information
   // here, but we want to ask the device at runtime in case anything
   // has changed.
-  mNumScreens = 0;
 }
 
 
 nsScreenManagerGtk :: ~nsScreenManagerGtk()
 {
   // nothing to see here.
 }
 
@@ -68,64 +67,60 @@ nsScreenManagerGtk :: ~nsScreenManagerGt
 // addref, release, QI
 NS_IMPL_ISUPPORTS1(nsScreenManagerGtk, nsIScreenManager)
 
 
 // this function will make sure that everything has been initialized.
 nsresult
 nsScreenManagerGtk :: EnsureInit(void)
 {
-  if (mNumScreens == 0) {
+  if (mCachedScreenArray.Count() == 0) {
     XineramaScreenInfo *screenInfo = NULL;
+    int numScreens;
 
     // We are leaking xineramalib, but there is no other way to do this.
     PRLibrary* xineramalib = PR_LoadLibrary("libXinerama.so.1");
     if (xineramalib) {
       _XnrmIsActive_fn _XnrmIsActive = (_XnrmIsActive_fn)
           PR_FindFunctionSymbol(xineramalib, "XineramaIsActive");
 
       _XnrmQueryScreens_fn _XnrmQueryScreens = (_XnrmQueryScreens_fn)
           PR_FindFunctionSymbol(xineramalib, "XineramaQueryScreens");
           
       // get the number of screens via xinerama
       if (_XnrmIsActive && _XnrmQueryScreens &&
           _XnrmIsActive(GDK_DISPLAY())) {
-        screenInfo = _XnrmQueryScreens(GDK_DISPLAY(), &mNumScreens);
+        screenInfo = _XnrmQueryScreens(GDK_DISPLAY(), &numScreens);
       }
     }
     // screenInfo == NULL if either Xinerama couldn't be loaded or
     // isn't running on the current display
     if (!screenInfo) {
-      mNumScreens = 1;
       nsRefPtr<nsScreenGtk> screen = new nsScreenGtk();
-      if (!screen)
+      if (!screen || !mCachedScreenArray.AppendObject(screen)) {
         return NS_ERROR_OUT_OF_MEMORY;
+      }
 
       screen->Init();
-
-      mCachedScreenArray.AppendObject(screen);
     }
     // If Xinerama is enabled and there's more than one screen, fill
     // in the info for all of the screens.  If that's not the case
     // then nsScreenGTK() defaults to the screen width + height
     else {
 #ifdef DEBUG
-      printf("Xinerama superpowers activated for %d screens!\n", mNumScreens);
+      printf("Xinerama superpowers activated for %d screens!\n", numScreens);
 #endif
-      int i;
-      for (i=0; i < mNumScreens; i++) {
+      for (int i = 0; i < numScreens; ++i) {
         nsRefPtr<nsScreenGtk> screen = new nsScreenGtk();
-        if (!screen) {
+        if (!screen || !mCachedScreenArray.AppendObject(screen)) {
           return NS_ERROR_OUT_OF_MEMORY;
         }
 
         // initialize this screen object
         screen->Init(&screenInfo[i]);
-
-        mCachedScreenArray.AppendObject(screen);
       }
     }
 
     if (screenInfo) {
       XFree(screenInfo);
     }
   }
 
@@ -152,17 +147,17 @@ nsScreenManagerGtk :: ScreenForRect ( PR
     NS_ERROR("nsScreenManagerGtk::EnsureInit() failed from ScreenForRect\n");
     return rv;
   }
   // which screen ( index from zero ) should we return?
   PRUint32 which = 0;
   // Optimize for the common case.  If the number of screens is only
   // one then this will fall through with which == 0 and will get the
   // primary screen.
-  if (mNumScreens > 1) {
+  if (mCachedScreenArray.Count() > 1) {
     // walk the list of screens and find the one that has the most
     // surface area.
     PRUint32 area = 0;
     nsRect   windowRect(aX, aY, aWidth, aHeight);
     for (PRInt32 i = 0, i_end = mCachedScreenArray.Count(); i < i_end; ++i) {
       PRInt32  x, y, width, height;
       x = y = width = height = 0;
       mCachedScreenArray[i]->GetRect(&x, &y, &width, &height);
@@ -214,17 +209,17 @@ nsScreenManagerGtk :: GetNumberOfScreens
 nsScreenManagerGtk :: GetNumberOfScreens(PRUint32 *aNumberOfScreens)
 {
   nsresult rv;
   rv = EnsureInit();
   if (NS_FAILED(rv)) {
     NS_ERROR("nsScreenManagerGtk::EnsureInit() failed from GetNumberOfScreens\n");
     return rv;
   }
-  *aNumberOfScreens = mNumScreens;
+  *aNumberOfScreens = mCachedScreenArray.Count();
   return NS_OK;
   
 } // GetNumberOfScreens
 
 NS_IMETHODIMP
 nsScreenManagerGtk :: ScreenForNativeWidget (void *aWidget, nsIScreen **outScreen)
 {
   // I don't know how to go from GtkWindow to nsIScreen, especially
diff --git a/widget/src/gtk2/nsScreenManagerGtk.h b/widget/src/gtk2/nsScreenManagerGtk.h
--- a/widget/src/gtk2/nsScreenManagerGtk.h
+++ b/widget/src/gtk2/nsScreenManagerGtk.h
@@ -54,17 +54,13 @@ public:
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSISCREENMANAGER
 
 private:
 
   nsresult EnsureInit(void);
 
-  // cache the primary screen object to avoid memory allocation every
-  // time
+  // Cached screen array.  Its length is the number of screens we have.
   nsCOMArray<nsIScreen> mCachedScreenArray;
-  // how many screens do we have?
-  int mNumScreens;
-
 };
 
 #endif  // nsScreenManagerGtk_h___ 
