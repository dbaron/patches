Allow screen manager array to be larger than mNumScreens (but don't make it happen yet).  (Bug 403706)

diff --git a/widget/src/gtk2/nsScreenManagerGtk.cpp b/widget/src/gtk2/nsScreenManagerGtk.cpp
--- a/widget/src/gtk2/nsScreenManagerGtk.cpp
+++ b/widget/src/gtk2/nsScreenManagerGtk.cpp
@@ -90,42 +90,41 @@ nsScreenManagerGtk :: EnsureInit(void)
           _XnrmIsActive(GDK_DISPLAY())) {
         screenInfo = _XnrmQueryScreens(GDK_DISPLAY(), &mNumScreens);
       }
     }
     // screenInfo == NULL if either Xinerama couldn't be loaded or
     // isn't running on the current display
     if (!screenInfo) {
       mNumScreens = 1;
+
       nsRefPtr<nsScreenGtk> screen = new nsScreenGtk();
-      if (!screen)
+      if (!screen || !mCachedScreenArray.AppendObject(screen)) {
+        mNumScreens = 0;
         return NS_ERROR_OUT_OF_MEMORY;
+      }
 
       screen->Init();
-
-      mCachedScreenArray.AppendObject(screen);
     }
     // If Xinerama is enabled and there's more than one screen, fill
     // in the info for all of the screens.  If that's not the case
     // then nsScreenGTK() defaults to the screen width + height
     else {
 #ifdef DEBUG
       printf("Xinerama superpowers activated for %d screens!\n", mNumScreens);
 #endif
-      int i;
-      for (i=0; i < mNumScreens; i++) {
+      for (int i = 0; i < mNumScreens; ++i) {
         nsRefPtr<nsScreenGtk> screen = new nsScreenGtk();
-        if (!screen) {
+        if (!screen || !mCachedScreenArray.AppendObject(screen)) {
+          mNumScreens = 0;
           return NS_ERROR_OUT_OF_MEMORY;
         }
 
         // initialize this screen object
         screen->Init(&screenInfo[i]);
-
-        mCachedScreenArray.AppendObject(screen);
       }
     }
 
     if (screenInfo) {
       XFree(screenInfo);
     }
   }
 
@@ -157,17 +156,17 @@ nsScreenManagerGtk :: ScreenForRect ( PR
   // Optimize for the common case.  If the number of screens is only
   // one then this will fall through with which == 0 and will get the
   // primary screen.
   if (mNumScreens > 1) {
     // walk the list of screens and find the one that has the most
     // surface area.
     PRUint32 area = 0;
     nsRect   windowRect(aX, aY, aWidth, aHeight);
-    for (PRInt32 i = 0, i_end = mCachedScreenArray.Count(); i < i_end; ++i) {
+    for (PRInt32 i = 0, i_end = mNumScreens; i < i_end; ++i) {
       PRInt32  x, y, width, height;
       x = y = width = height = 0;
       mCachedScreenArray[i]->GetRect(&x, &y, &width, &height);
       // calculate the surface area
       nsRect screenRect(x, y, width, height);
       screenRect.IntersectRect(screenRect, windowRect);
       PRUint32 tempArea = screenRect.width * screenRect.height;
       if (tempArea >= area) {
diff --git a/widget/src/gtk2/nsScreenManagerGtk.h b/widget/src/gtk2/nsScreenManagerGtk.h
--- a/widget/src/gtk2/nsScreenManagerGtk.h
+++ b/widget/src/gtk2/nsScreenManagerGtk.h
@@ -54,17 +54,20 @@ public:
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSISCREENMANAGER
 
 private:
 
   nsresult EnsureInit(void);
 
-  // cache the primary screen object to avoid memory allocation every
-  // time
+  // Cached screen array.  This may have more objects in it than the
+  // number of screens if the number of screens changes dynamically over
+  // time, but we want to re-use the same screen objects.  It is never,
+  // however, smaller than mNumScreens.
   nsCOMArray<nsIScreen> mCachedScreenArray;
+
   // how many screens do we have?
   int mNumScreens;
 
 };
 
 #endif  // nsScreenManagerGtk_h___ 
