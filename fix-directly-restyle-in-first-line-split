From: L. David Baron <dbaron@dbaron.org>

Bug 945105 patch 2:  Replace changes to ComputeStyleChangeFor with a check of GetPrevContinuationWithSameStyle to avoid the duplication in a way that still doesn't break direct restyling of an element whose continuations have different styles.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -2845,31 +2845,44 @@ RestyleManager::ComputeStyleChangeFor(ns
 
   nsIFrame* frame = aFrame;
   nsIFrame* frame2 = aFrame;
 
   NS_ASSERTION(!frame->GetPrevContinuation(), "must start with the first in flow");
 
   // We want to start with this frame and walk all its next-in-flows,
   // as well as all its special siblings and their next-in-flows,
-  // reresolving style on all the frames we encounter in this walk.
+  // reresolving style on all the frames we encounter in this walk that
+  // we didn't reach already.  In the normal case, this will mean only
+  // restyling the first two block-in-inline splits and no
+  // continuations, and skipping everything else.  However, when we have
+  // a style change for something inside a style difference (e.g., a
+  // style change on an element that extends from inside a styled
+  // ::first-line to outside of that first line), we might restyle more
+  // than that.
 
   FramePropertyTable* propTable = mPresContext->PropertyTable();
 
   TreeMatchContext treeMatchContext(true,
                                     nsRuleWalker::eRelevantLinkUnvisited,
                                     mPresContext->Document());
   nsIContent *parent = content ? content->GetParent() : nullptr;
   Element *parentElement =
     parent && parent->IsElement() ? parent->AsElement() : nullptr;
   treeMatchContext.InitAncestors(parentElement);
   nsTArray<nsIContent*> visibleKidsOfHiddenElement;
   do {
     // Outer loop over special siblings
     do {
+      if (GetPrevContinuationWithSameStyle(frame)) {
+        // We already handled this element when dealing with its earlier
+        // continuation.
+        continue;
+      }
+
       // Inner loop over next-in-flows of the current frame
       ElementRestyler restyler(mPresContext, frame, aChangeList,
                                aMinChange, aRestyleTracker,
                                treeMatchContext,
                                visibleKidsOfHiddenElement);
 
       restyler.Restyle(aRestyleDescendants ? eRestyle_Subtree : eRestyle_Self);
 
