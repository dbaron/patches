Back out patch to make mousethrough attribute apply to all elements.  b=380094  a=roc

diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -3352,35 +3352,6 @@ nsFrame::AttributeChanged(PRInt32       
                           PRInt32         aModType)
 {
   return NS_OK;
-}
-
-PRBool nsFrame::GetMouseThrough() const
-{
-  eMouseThrough mousethrough = unset;
-
-  if (mContent) {
-    static nsIContent::AttrValuesArray strings[] =
-      {&nsGkAtoms::never, &nsGkAtoms::always, nsnull};
-    static const eMouseThrough values[] = {never, always};
-    PRInt32 index = mContent->FindAttrValueIn(kNameSpaceID_None,
-        nsGkAtoms::mousethrough, strings, eCaseMatters);
-    if (index >= 0) {
-      mousethrough = values[index];
-    }
-  }
-
-  switch(mousethrough)
-  {
-    case always:
-      return PR_TRUE;
-    case never:
-      return PR_FALSE;
-    case unset:
-      if (mParent)
-        return mParent->GetMouseThrough();
-  }
-
-  return PR_FALSE;
 }
 
 // Flow member functions
diff --git a/layout/generic/nsFrame.h b/layout/generic/nsFrame.h
--- a/layout/generic/nsFrame.h
+++ b/layout/generic/nsFrame.h
@@ -206,8 +206,6 @@ public:
                                         PRInt8 aOutSideLimit
                                         );
 
-  PRBool GetMouseThrough() const;
-
   /**
    * Find the nearest frame with a mouse capturer. If no
    * parent has mouse capture this will return null.
diff --git a/layout/xul/base/src/nsBoxFrame.cpp b/layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp
+++ b/layout/xul/base/src/nsBoxFrame.cpp
@@ -136,7 +136,8 @@ nsBoxFrame::nsBoxFrame(nsIPresShell* aPr
                        nsStyleContext* aContext,
                        PRBool aIsRoot,
                        nsIBoxLayout* aLayoutManager) :
-  nsContainerFrame(aContext)
+  nsContainerFrame(aContext),
+  mMouseThrough(unset)
 {
   mState |= NS_FRAME_IS_BOX;
   mState |= NS_STATE_IS_HORIZONTAL;
@@ -223,10 +224,45 @@ nsBoxFrame::Init(nsIContent*      aConte
       GetDebugPref(GetPresContext());
 #endif
 
+  mMouseThrough = unset;
+
+  UpdateMouseThrough();
+
   // register access key
   rv = RegUnregAccessKey(PR_TRUE);
 
   return rv;
+}
+
+void nsBoxFrame::UpdateMouseThrough()
+{
+  if (mContent) {
+    static nsIContent::AttrValuesArray strings[] =
+      {&nsGkAtoms::never, &nsGkAtoms::always, nsnull};
+    static const eMouseThrough values[] = {never, always};
+    PRInt32 index = mContent->FindAttrValueIn(kNameSpaceID_None,
+        nsGkAtoms::mousethrough, strings, eCaseMatters);
+    if (index >= 0) {
+      mMouseThrough = values[index];
+    }
+  }
+}
+
+PRBool
+nsBoxFrame::GetMouseThrough() const
+{
+  switch(mMouseThrough)
+  {
+    case always:
+      return PR_TRUE;
+    case never:
+      return PR_FALSE;
+    case unset:
+      if (mParent && mParent->IsBoxFrame())
+        return mParent->GetMouseThrough();
+  }
+
+  return PR_FALSE;
 }
 
 void
@@ -1081,6 +1117,7 @@ nsBoxFrame::AttributeChanged(PRInt32 aNa
       aAttribute == nsGkAtoms::orient       ||
       aAttribute == nsGkAtoms::pack         ||
       aAttribute == nsGkAtoms::dir          ||
+      aAttribute == nsGkAtoms::mousethrough ||
       aAttribute == nsGkAtoms::equalsize) {
 
     if (aAttribute == nsGkAtoms::align  ||
@@ -1144,6 +1181,9 @@ nsBoxFrame::AttributeChanged(PRInt32 aNa
     else if (aAttribute == nsGkAtoms::left ||
              aAttribute == nsGkAtoms::top) {
       mState &= ~NS_STATE_STACK_NOT_POSITIONED;
+    }
+    else if (aAttribute == nsGkAtoms::mousethrough) {
+      UpdateMouseThrough();
     }
 
     PresContext()->PresShell()->
diff --git a/layout/xul/base/src/nsBoxFrame.h b/layout/xul/base/src/nsBoxFrame.h
--- a/layout/xul/base/src/nsBoxFrame.h
+++ b/layout/xul/base/src/nsBoxFrame.h
@@ -99,6 +99,7 @@ public:
   virtual Halignment GetHAlign() const { return mHalign; }
   NS_IMETHOD DoLayout(nsBoxLayoutState& aBoxLayoutState);
 
+  virtual PRBool GetMouseThrough() const;
   virtual PRBool ComputesOwnOverflowArea() { return PR_FALSE; }
 
   // ----- child and sibling operations ---
@@ -254,6 +255,7 @@ private:
     void DrawLine(nsIRenderingContext& aRenderingContext,  PRBool aHorizontal, nscoord x1, nscoord y1, nscoord x2, nscoord y2);
     void FillRect(nsIRenderingContext& aRenderingContext,  PRBool aHorizontal, nscoord x, nscoord y, nscoord width, nscoord height);
 #endif
+    void UpdateMouseThrough();
 
     void CacheAttributes();
 
@@ -261,6 +263,8 @@ private:
     Halignment mHalign;
     Valignment mValign;
 
+    eMouseThrough mMouseThrough;
+
 #ifdef DEBUG_LAYOUT
     static PRBool gDebug;
     static nsIBox* mDebugChild;
diff --git a/layout/xul/base/src/nsLeafBoxFrame.cpp b/layout/xul/base/src/nsLeafBoxFrame.cpp
--- a/layout/xul/base/src/nsLeafBoxFrame.cpp
+++ b/layout/xul/base/src/nsLeafBoxFrame.cpp
@@ -73,7 +73,7 @@ NS_NewLeafBoxFrame (nsIPresShell* aPresS
 } // NS_NewLeafBoxFrame
 
 nsLeafBoxFrame::nsLeafBoxFrame(nsIPresShell* aShell, nsStyleContext* aContext)
-    : nsLeafFrame(aContext)
+    : nsLeafFrame(aContext), mMouseThrough(unset)
 {
     mState |= NS_FRAME_IS_BOX;
 }
@@ -110,8 +110,57 @@ nsLeafBoxFrame::Init(
            view->CreateWidget(kWidgetCID);   
     }
   }
+  
+  mMouseThrough = unset;
+
+  UpdateMouseThrough();
 
   return rv;
+}
+
+NS_IMETHODIMP
+nsLeafBoxFrame::AttributeChanged(PRInt32 aNameSpaceID,
+                                 nsIAtom* aAttribute,
+                                 PRInt32 aModType)
+{
+  nsresult rv = nsLeafFrame::AttributeChanged(aNameSpaceID, aAttribute,
+                                              aModType);
+
+  if (aAttribute == nsGkAtoms::mousethrough) 
+    UpdateMouseThrough();
+
+  return rv;
+}
+
+void nsLeafBoxFrame::UpdateMouseThrough()
+{
+  if (mContent) {
+    static nsIContent::AttrValuesArray strings[] =
+      {&nsGkAtoms::never, &nsGkAtoms::always, nsnull};
+    switch (mContent->FindAttrValueIn(kNameSpaceID_None,
+                                      nsGkAtoms::mousethrough,
+                                      strings, eCaseMatters)) {
+      case 0: mMouseThrough = never; break;
+      case 1: mMouseThrough = always; break;
+    }
+  }
+}
+
+PRBool
+nsLeafBoxFrame::GetMouseThrough() const
+{
+  switch (mMouseThrough)
+  {
+    case always:
+      return PR_TRUE;
+    case never:
+      return PR_FALSE;
+    case unset:
+      if (mParent && mParent->IsBoxFrame())
+        return mParent->GetMouseThrough();
+  }
+
+  return PR_FALSE;
 }
 
 NS_IMETHODIMP
diff --git a/layout/xul/base/src/nsLeafBoxFrame.h b/layout/xul/base/src/nsLeafBoxFrame.h
--- a/layout/xul/base/src/nsLeafBoxFrame.h
+++ b/layout/xul/base/src/nsLeafBoxFrame.h
@@ -94,6 +94,11 @@ public:
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists);
 
+  NS_IMETHOD AttributeChanged(PRInt32 aNameSpaceID,
+                              nsIAtom* aAttribute,
+                              PRInt32 aModType);
+
+  virtual PRBool GetMouseThrough() const;
   virtual PRBool ComputesOwnOverflowArea() { return PR_FALSE; }
 
 protected:
@@ -111,6 +116,14 @@ protected:
 
  nsLeafBoxFrame(nsIPresShell* aShell, nsStyleContext* aContext);
 
+protected:
+  eMouseThrough mMouseThrough;
+
+private:
+
+ void UpdateMouseThrough();
+
+
 }; // class nsLeafBoxFrame
 
 #endif /* nsLeafBoxFrame_h___ */
