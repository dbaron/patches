From: L. David Baron <dbaron@dbaron.org>

Replace force-fit with setting mIsTopOfPage correctly.  (Bug 563584)  (FIXME: write tests)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -5528,22 +5528,16 @@ nsBlockFrame::AdjustFloatAvailableSpace(
     availWidth = aState.mContentArea.width;
   }
   else {
     // This quirk matches the one in nsBlockReflowState::FlowAndPlaceFloat
     // give tables only the available space
     // if they can shrink we may not be constrained to place
     // them in the next line
     availWidth = aFloatAvailableSpace.width;
-    // round down to twips per pixel so that we fit
-    // needed when prev. float has procentage width
-    // (maybe is a table flaw that makes table chose to round up
-    // but I don't want to change that, too risky)
-    nscoord twp = nsPresContext::CSSPixelsToAppUnits(1);
-    availWidth -=  availWidth % twp;
   }
 
   // aState.mY is relative to the border-top, make it relative to the content-top
   nscoord contentYOffset = aState.mY - aState.BorderPadding().top;
   nscoord availHeight = NS_UNCONSTRAINEDSIZE == aState.mContentArea.height
                         ? NS_UNCONSTRAINEDSIZE
                         : NS_MAX(0, aState.mContentArea.height - contentYOffset);
 
@@ -5580,16 +5574,17 @@ nsBlockFrame::ComputeFloatWidth(nsBlockR
     floatRS.mComputedMargin.LeftRight();
 }
 
 nsresult
 nsBlockFrame::ReflowFloat(nsBlockReflowState& aState,
                           const nsRect&       aAdjustedAvailableSpace,
                           nsIFrame*           aFloat,
                           nsMargin&           aFloatMargin,
+                          PRBool              aFloatPushedDown,
                           nsReflowStatus&     aReflowStatus)
 {
   NS_PRECONDITION(aFloat->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
                   "aFloat must be an out-of-flow frame");
   // Reflow the float.
   aReflowStatus = NS_FRAME_COMPLETE;
 
 #ifdef NOISY_FLOAT
@@ -5599,17 +5594,27 @@ nsBlockFrame::ReflowFloat(nsBlockReflowS
           aFloatAvailableSpace.width, aFloatAvailableSpace.height
   );
 #endif
 
   nsHTMLReflowState floatRS(aState.mPresContext, aState.mReflowState, aFloat,
                             nsSize(aAdjustedAvailableSpace.width,
                                    aAdjustedAvailableSpace.height));
 
-  // Setup a block reflow state to reflow the float.
+  // Normally the mIsTopOfPage state is copied from the parent reflow
+  // state.  However, when reflowing a float, if we've placed other
+  // floats that force this float *down* or *narrower*, we should unset
+  // the mIsTopOfPage state.
+  if (floatRS.mFlags.mIsTopOfPage &&
+      (aFloatPushedDown ||
+       aAdjustedAvailableSpace.width != aState.mContentArea.width)) {
+    floatRS.mFlags.mIsTopOfPage = PR_FALSE;
+  }
+
+  // Setup a block reflow context to reflow the float.
   nsBlockReflowContext brc(aState.mPresContext, aState.mReflowState);
 
   // Reflow the float
   PRBool isAdjacentWithTop = aState.IsAdjacentWithTop();
 
   nsIFrame* clearanceFrame = nsnull;
   nsresult rv;
   do {
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -583,16 +583,20 @@ protected:
   // An incomplete aReflowStatus indicates the float should be split
   // but only if the available height is constrained.
   // aAdjustedAvailableSpace is the result of calling
   // nsBlockFrame::AdjustFloatAvailableSpace.
   nsresult ReflowFloat(nsBlockReflowState& aState,
                        const nsRect&       aAdjustedAvailableSpace,
                        nsIFrame*           aFloat,
                        nsMargin&           aFloatMargin,
+                       // Whether the float's position
+                       // (aAdjustedAvailableSpace) has been pushed down
+                       // due to the presence of other floats.
+                       PRBool              aFloatPushedDown,
                        nsReflowStatus&     aReflowStatus);
 
   //----------------------------------------
   // Methods for pushing/pulling lines/frames
 
   /**
    * Create a next-in-flow, if necessary, for aFrame. If a new frame is
    * created, place it in aLine if aLine is not null.
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -808,18 +808,19 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
     // means the margin edge of the float can't be higher than the
     // content edge of the block that contains it.)
     floatY = 0;
   }
 
   // Reflow the float after computing its vertical position so it knows
   // where to break.
   nsMargin floatMargin; // computed margin
+  PRBool pushedDown = mY != saveY;
   mBlock->ReflowFloat(*this, adjustedAvailableSpace, aFloat,
-                      floatMargin, aReflowStatus);
+                      floatMargin, pushedDown, aReflowStatus);
   if (aFloat->GetPrevInFlow())
     floatMargin.top = 0;
   if (NS_FRAME_IS_NOT_COMPLETE(aReflowStatus))
     floatMargin.bottom = 0;
 
   // Calculate the actual origin of the float frame's border rect
   // relative to the parent block; floatX/Y must be converted from space-manager
   // coordinates to parent coordinates, and the margin must be added in
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -417,19 +417,21 @@ typedef PRUint32 nsReflowStatus;
 // Take a completion status and add to it the desire to have a
 // line-break after. For this macro we do need the completion status
 // because the user of the status will need to know whether to
 // continue the frame or not.
 #define NS_INLINE_LINE_BREAK_AFTER(_completionStatus)                   \
   ((_completionStatus) | NS_INLINE_BREAK | NS_INLINE_BREAK_AFTER |      \
    NS_INLINE_MAKE_BREAK_TYPE(NS_STYLE_CLEAR_LINE))
 
-// The frame (not counting a continuation) did not fit in the available height and 
-// wasn't at the top of a page. If it was at the top of a page, then it is not 
-// possible to reflow it again with more height, so we don't set it in that case.
+// A frame is "truncated" if the part of the frame before the first
+// possible break point was unable to fit in the available vertical
+// space.  Therefore, the entire frame should be moved to the next page.
+// A frame that begins at the top of the page must never be "truncated".
+// Doing so would likely cause an infinite loop.
 #define NS_FRAME_TRUNCATED  0x0010
 #define NS_FRAME_IS_TRUNCATED(status) \
   (0 != ((status) & NS_FRAME_TRUNCATED))
 #define NS_FRAME_SET_TRUNCATION(status, aReflowState, aMetrics) \
   aReflowState.SetTruncated(aMetrics, &status);
 
 // Merge the incompleteness, truncation and NS_FRAME_REFLOW_NEXTINFLOW
 // status from aSecondary into aPrimary.
