Fold DoParseMediaList into ParseMediaList, since it is no longer necessary now that we don't do special parsing for media lists in HTML.  (Bug 156716)  r+sr=bzbarsky

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -245,21 +245,16 @@ protected:
   nsresult InitScanner(nsIUnicharInputStream* aInput, nsIURI* aSheetURI,
                        PRUint32 aLineNumber, nsIURI* aBaseURI,
                        nsIPrincipal* aSheetPrincipal);
   // the caller must hold on to aBuffer until parsing is done
   nsresult InitScanner(const nsSubstring& aString, nsIURI* aSheetURI,
                        PRUint32 aLineNumber, nsIURI* aBaseURI,
                        nsIPrincipal* aSheetPrincipal);
   nsresult ReleaseScanner(void);
-
-  nsresult DoParseMediaList(const nsSubstring& aBuffer,
-                            nsIURI* aURL, // for error reporting
-                            PRUint32 aLineNumber, // for error reporting
-                            nsMediaList* aMediaList);
 
   PRBool GetToken(nsresult& aErrorCode, PRBool aSkipWS);
   void UngetToken();
 
   void AssertInitialState() {
     NS_PRECONDITION(!mHTMLMediaMode, "Bad initial state");
     NS_PRECONDITION(!mUnresolvablePrefixException, "Bad initial state");
     NS_PRECONDITION(!mParsingCompoundProperty, "Bad initial state");
@@ -1116,16 +1111,22 @@ CSSParserImpl::ParseMediaList(const nsSu
                               PRUint32 aLineNumber, // for error reporting
                               nsMediaList* aMediaList,
                               PRBool aHTMLMode)
 {
   // XXX Are there cases where the caller wants to keep what it already
   // has in case of parser error?
   aMediaList->Clear();
 
+  // fake base URL since media lists don't have URLs in them
+  nsresult rv = InitScanner(aBuffer, aURL, aLineNumber, aURL, nsnull);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
   AssertInitialState();
   NS_ASSERTION(aHTMLMode == PR_TRUE || aHTMLMode == PR_FALSE,
                "invalid PRBool");
   mHTMLMediaMode = aHTMLMode;
 
     // XXXldb We need to make the scanner not skip CSS comments!  (Or
     // should we?)
 
@@ -1133,49 +1134,27 @@ CSSParserImpl::ParseMediaList(const nsSu
   // http://www.w3.org/TR/1999/REC-html401-19991224/types.html#type-media-descriptors
   // which wouldn't work for media queries since they remove all but the
   // first word.  However, they're changed in
   // http://www.whatwg.org/specs/web-apps/current-work/multipage/section-document.html#media2
   // (as of 2008-05-29) which says that the media attribute just points
   // to a media query.  (The main substative difference is the relative
   // precedence of commas and paretheses.)
 
-  nsresult rv = DoParseMediaList(aBuffer, aURL, aLineNumber, aMediaList);
-
-  if (aHTMLMode) {
-    mHTMLMediaMode = PR_FALSE;
-  }
-
-  return rv;
-}
-
-// All parameters but the first are the same as for |ParseMediaList|,
-// but for HTML we get the buffer in chunks according to the HTML spec's
-// parsing rules instead of in one piece.
-nsresult
-CSSParserImpl::DoParseMediaList(const nsSubstring& aBuffer,
-                                nsIURI* aURL, // for error reporting
-                                PRUint32 aLineNumber, // for error reporting
-                                nsMediaList* aMediaList)
-{
-  // fake base URL since media lists don't have URLs in them
-  nsresult rv = InitScanner(aBuffer, aURL, aLineNumber, aURL, nsnull);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
   if (!GatherMedia(rv, aMediaList, PRUnichar(0))) {
     aMediaList->Clear();
     aMediaList->SetNonEmpty(); // don't match anything
     if (!mHTMLMediaMode) {
       OUTPUT_ERROR();
     }
   }
   CLEAR_ERROR();
   ReleaseScanner();
+  mHTMLMediaMode = PR_FALSE;
+
   return rv;
 }
 
 NS_IMETHODIMP
 CSSParserImpl::ParseColorString(const nsSubstring& aBuffer,
                                 nsIURI* aURL, // for error reporting
                                 PRUint32 aLineNumber, // for error reporting
                                 nscolor* aColor)
