When displacing blocks that don't interact with floats around floats, displace the border box rather than the margin box.  b=427129, 377664  Simultaneously, only displace when the width actually won't go down to an amount that fits (i.e., if it will go to an amount smaller than the intrinsic minimum width, let it).  b=427782

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -6789,21 +6789,17 @@ OneWidthToClearPastFloats(nsPresContext*
                           nscoord aCBWidth,
                           nsIFrame* aFrame)
 {
-  // We need to compute percent widths, since intrinsic width
-  // computation doesn't.
-  if (aFrame->GetStylePosition()->mWidth.GetUnit() == eStyleUnit_Percent) {
-    // All we really need here is the result of ComputeSize, and we
-    // could *almost* get that from an nsCSSOffsetState, except for the
-    // last argument.
-    nsSize availSpace(aCBWidth, NS_UNCONSTRAINEDSIZE);
-    nsHTMLReflowState reflowState(aPresContext, aParentReflowState,
-                                  aFrame, availSpace);
-    return reflowState.ComputedWidth();
-  }
-
-  return nsLayoutUtils::IntrinsicForContainer(aParentReflowState.rendContext,
-                                              aFrame,
-                                              nsLayoutUtils::MIN_WIDTH);
+  // We actually don't want the min width here; see bug 427782; we only
+  // want to displace if the width won't compute to a value small enough
+  // to fit.
+  // All we really need here is the result of ComputeSize, and we
+  // could *almost* get that from an nsCSSOffsetState, except for the
+  // last argument.
+  nsSize availSpace(aCBWidth, NS_UNCONSTRAINEDSIZE);
+  nsHTMLReflowState reflowState(aPresContext, aParentReflowState,
+                                aFrame, availSpace);
+  return reflowState.ComputedWidth() +
+         reflowState.mComputedBorderPadding.LeftRight();
 }
 
 /* static */
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -257,8 +257,27 @@ nsBlockReflowState::ComputeBlockAvailSpa
     // The frame is clueless about the space manager and therefore we
     // only give it free space. An example is a table frame - the
     // tables do not flow around floats.
-    aResult.x = mAvailSpaceRect.x + borderPadding.left;
-    aResult.width = mAvailSpaceRect.width;
+    // However, we can let its margins intersect floats.
+    NS_ASSERTION(mAvailSpaceRect.x >= 0, "bad avail space rect x");
+    NS_ASSERTION(mAvailSpaceRect.XMost() <= mContentArea.width,
+                 "bad avail space rect width");
+    if (mAvailSpaceRect.width == mContentArea.width) {
+      // We don't need to compute margins when there are no floats around.
+      aResult.x = borderPadding.left;
+      aResult.width = mContentArea.width;
+    } else {
+      nsCSSOffsetState os(aFrame, mReflowState.rendContext, mContentArea.width);
+      nscoord leftFloatXOffset = mAvailSpaceRect.x;
+      nscoord leftOffset = PR_MAX(leftFloatXOffset,
+                                  os.mComputedMargin.left) -
+                           os.mComputedMargin.left;
+      nscoord rightFloatXOffset = mContentArea.width - mAvailSpaceRect.XMost();
+      nscoord rightOffset = PR_MAX(rightFloatXOffset,
+                                   os.mComputedMargin.right) -
+                            os.mComputedMargin.right;
+      aResult.x = borderPadding.left + leftOffset;
+      aResult.width = mContentArea.width - leftOffset - rightOffset;
+    }
   }
 
 #ifdef REALLY_NOISY_REFLOW
