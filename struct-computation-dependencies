From: L. David Baron <dbaron@dbaron.org>

Bug 1122781 patch 1 - Add method for style struct computation dependencies.

(Inspired by bug 1098151.)

diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -165,16 +165,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   ~nsStyleFont() {
     MOZ_COUNT_DTOR(nsStyleFont);
   }
   void FinishStyle(nsPresContext*, const nsStyleFont*) {}
   const static bool kHasFinishStyle = false;
 
   nsChangeHint CalcDifference(const nsStyleFont& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   /**
    * Return aSize multiplied by the current text zoom factor (in aPresContext).
    * aSize is allowed to be negative, but the caller is expected to deal with
    * negative results.  The result is clamped to nscoord_MIN .. nscoord_MAX.
    */
   static nscoord ZoomText(const nsPresContext* aPresContext, nscoord aSize);
   /**
    * Return aSize divided by the current text zoom factor (in aPresContext).
@@ -602,16 +604,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
 
   nscolor CalcComplexColor(const mozilla::StyleComplexColor& aColor) const {
     return mozilla::LinearBlendColors(aColor.mColor, mColor,
                                       aColor.mForegroundRatio);
   }
 
   nsChangeHint CalcDifference(const nsStyleColor& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   void* operator new(size_t sz, nsStyleColor* aSelf) { return aSelf; }
   void* operator new(size_t sz, nsPresContext* aContext) {
     return aContext->PresShell()->
       AllocateByObjectID(mozilla::eArenaObjectID_nsStyleColor, sz);
   }
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleColor();
     aContext->PresShell()->
@@ -885,16 +889,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void* operator new(size_t sz, nsPresContext* aContext) {
     return aContext->PresShell()->
       AllocateByObjectID(mozilla::eArenaObjectID_nsStyleBackground, sz);
   }
   void Destroy(nsPresContext* aContext);
 
   nsChangeHint CalcDifference(const nsStyleBackground& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   // Return the background color as nscolor.
   nscolor BackgroundColor(const nsIFrame* aFrame) const;
   nscolor BackgroundColor(nsStyleContext* aContext) const;
 
   // True if this background is completely transparent.
   bool IsTransparent(const nsIFrame* aFrame) const;
   bool IsTransparent(nsStyleContext* aContext) const;
 
@@ -928,16 +934,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void* operator new(size_t sz, nsPresContext* aContext) {
     return aContext->PresShell()->
       AllocateByObjectID(mozilla::eArenaObjectID_nsStyleMargin, sz);
   }
   void Destroy(nsPresContext* aContext);
 
   nsChangeHint CalcDifference(const nsStyleMargin& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   bool GetMargin(nsMargin& aMargin) const
   {
     if (!mMargin.ConvertsToLength()) {
       return false;
     }
 
     NS_FOR_CSS_SIDES(side) {
       aMargin.Side(side) = mMargin.ToLength(side);
@@ -967,16 +975,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void* operator new(size_t sz, nsPresContext* aContext) {
     return aContext->PresShell()->
       AllocateByObjectID(mozilla::eArenaObjectID_nsStylePadding, sz);
   }
   void Destroy(nsPresContext* aContext);
 
   nsChangeHint CalcDifference(const nsStylePadding& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   nsStyleSides  mPadding;         // [reset] coord, percent, calc
 
   bool IsWidthDependent() const {
     return !mPadding.ConvertsToLength();
   }
 
   bool GetPadding(nsMargin& aPadding) const
   {
@@ -1134,16 +1144,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void* operator new(size_t sz, nsPresContext* aContext) {
     return aContext->PresShell()->
       AllocateByObjectID(mozilla::eArenaObjectID_nsStyleBorder, sz);
   }
   void Destroy(nsPresContext* aContext);
 
   nsChangeHint CalcDifference(const nsStyleBorder& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   // Return whether aStyle is a visible style.  Invisible styles cause
   // the relevant computed border width to be 0.
   // Note that this does *not* consider the effects of 'border-image':
   // if border-style is none, but there is a loaded border image,
   // HasVisibleStyle will be false even though there *is* a border.
   bool HasVisibleStyle(mozilla::Side aSide) const
   {
     return IsVisibleBorderStyle(mBorderStyle[aSide]);
@@ -1317,16 +1329,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
     this->~nsStyleOutline();
     aContext->PresShell()->
       FreeByObjectID(mozilla::eArenaObjectID_nsStyleOutline, this);
   }
 
   void RecalcData();
   nsChangeHint CalcDifference(const nsStyleOutline& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   nsStyleCorners  mOutlineRadius; // [reset] coord, percent, calc
 
   // This is the specified value of outline-width, but with length values
   // computed to absolute.  mActualOutlineWidth stores the outline-width
   // value used by layout.  (We must store mOutlineWidth for the same
   // style struct resolution reasons that we do nsStyleBorder::mBorder;
   // see that field's comment.)
   nscoord       mOutlineWidth;    // [reset] coord, enum (see nsStyleConsts.h)
@@ -1389,16 +1403,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
     this->~nsStyleList();
     aContext->PresShell()->
       FreeByObjectID(mozilla::eArenaObjectID_nsStyleList, this);
   }
 
   nsChangeHint CalcDifference(const nsStyleList& aNewData,
                               const nsStyleDisplay* aOldDisplay) const;
 
+  static inline uint32_t ComputationDependencies();
+
   static void Shutdown() {
     sInitialQuotes = nullptr;
     sNoneQuotes = nullptr;
   }
 
   imgRequestProxy* GetListStyleImage() const
   {
     return mListStyleImage ? mListStyleImage->get() : nullptr;
@@ -1591,16 +1607,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
     this->~nsStylePosition();
     aContext->PresShell()->
       FreeByObjectID(mozilla::eArenaObjectID_nsStylePosition, this);
   }
 
   nsChangeHint CalcDifference(const nsStylePosition& aNewData,
                               const nsStyleVisibility* aOldStyleVisibility) const;
 
+  static inline uint32_t ComputationDependencies();
+
   /**
    * Return the used value for 'align-self' given our parent StyleContext
    * aParent (or null for the root).
    */
   uint8_t UsedAlignSelf(nsStyleContext* aParent) const;
 
   /**
    * Return the used value for 'justify-self' given our parent StyleContext
@@ -1822,16 +1840,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   // nsStyleContext::HasTextDecorationLines.
   bool HasTextDecorationLines() const {
     return mTextDecorationLine != NS_STYLE_TEXT_DECORATION_LINE_NONE &&
            mTextDecorationLine != NS_STYLE_TEXT_DECORATION_LINE_OVERRIDE_ALL;
   }
 
   nsChangeHint CalcDifference(const nsStyleTextReset& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   nsStyleTextOverflow mTextOverflow;    // [reset] enum, string
 
   uint8_t mTextDecorationLine;          // [reset] see nsStyleConsts.h
   uint8_t mTextDecorationStyle;         // [reset] see nsStyleConsts.h
   uint8_t mUnicodeBidi;                 // [reset] see nsStyleConsts.h
   nscoord mInitialLetterSink;           // [reset] 0 means normal
   float mInitialLetterSize;             // [reset] 0.0f means normal
   mozilla::StyleComplexColor mTextDecorationColor; // [reset]
@@ -1853,16 +1873,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleText();
     aContext->PresShell()->
       FreeByObjectID(mozilla::eArenaObjectID_nsStyleText, this);
   }
 
   nsChangeHint CalcDifference(const nsStyleText& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   uint8_t mTextAlign;                   // [inherited] see nsStyleConsts.h
   uint8_t mTextAlignLast;               // [inherited] see nsStyleConsts.h
   bool mTextAlignTrue : 1;              // [inherited] see nsStyleConsts.h
   bool mTextAlignLastTrue : 1;          // [inherited] see nsStyleConsts.h
   mozilla::StyleTextJustify mTextJustify;   // [inherited]
   uint8_t mTextTransform;               // [inherited] see nsStyleConsts.h
   mozilla::StyleWhiteSpace mWhiteSpace;     // [inherited] see nsStyleConsts.h
   uint8_t mWordBreak;                   // [inherited] see nsStyleConsts.h
@@ -2073,16 +2095,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleVisibility();
     aContext->PresShell()->
       FreeByObjectID(mozilla::eArenaObjectID_nsStyleVisibility, this);
   }
 
   nsChangeHint CalcDifference(const nsStyleVisibility& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   nsStyleImageOrientation mImageOrientation;  // [inherited]
   uint8_t mDirection;                  // [inherited] see nsStyleConsts.h NS_STYLE_DIRECTION_*
   uint8_t mVisible;                    // [inherited]
   uint8_t mImageRendering;             // [inherited] see nsStyleConsts.h
   uint8_t mWritingMode;                // [inherited] see nsStyleConsts.h
   uint8_t mTextOrientation;            // [inherited] see nsStyleConsts.h
   uint8_t mColorAdjust;                // [inherited] see nsStyleConsts.h
 
@@ -2494,16 +2518,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleDisplay();
     aContext->PresShell()->
       FreeByObjectID(mozilla::eArenaObjectID_nsStyleDisplay, this);
   }
 
   nsChangeHint CalcDifference(const nsStyleDisplay& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   // We guarantee that if mBinding is non-null, so are mBinding->GetURI() and
   // mBinding->mOriginPrincipal.
   RefPtr<mozilla::css::URLValue> mBinding; // [reset]
   mozilla::StyleDisplay mDisplay;          // [reset] see nsStyleConsts.h StyleDisplay
   mozilla::StyleDisplay mOriginalDisplay;  // [reset] saved mDisplay for
                                            //         position:absolute/fixed
                                            //         and float:left/right;
                                            //         otherwise equal to
@@ -2883,16 +2909,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleTable();
     aContext->PresShell()->
       FreeByObjectID(mozilla::eArenaObjectID_nsStyleTable, this);
   }
 
   nsChangeHint CalcDifference(const nsStyleTable& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   uint8_t       mLayoutStrategy;// [reset] see nsStyleConsts.h NS_STYLE_TABLE_LAYOUT_*
   int32_t       mSpan;          // [reset] the number of columns spanned by a colgroup or col
 };
 
 struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsStyleTableBorder
 {
   explicit nsStyleTableBorder(const nsPresContext* aContext);
   nsStyleTableBorder(const nsStyleTableBorder& aOther);
@@ -2908,16 +2936,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleTableBorder();
     aContext->PresShell()->
       FreeByObjectID(mozilla::eArenaObjectID_nsStyleTableBorder, this);
   }
 
   nsChangeHint CalcDifference(const nsStyleTableBorder& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   nscoord       mBorderSpacingCol;// [inherited]
   nscoord       mBorderSpacingRow;// [inherited]
   uint8_t       mBorderCollapse;// [inherited]
   uint8_t       mCaptionSide;   // [inherited]
   uint8_t       mEmptyCells;    // [inherited]
 };
 
 enum nsStyleContentType {
@@ -3080,16 +3110,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void* operator new(size_t sz, nsPresContext* aContext) {
     return aContext->PresShell()->
       AllocateByObjectID(mozilla::eArenaObjectID_nsStyleContent, sz);
   }
   void Destroy(nsPresContext* aContext);
 
   nsChangeHint CalcDifference(const nsStyleContent& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   uint32_t ContentCount() const { return mContents.Length(); } // [reset]
 
   const nsStyleContentData& ContentAt(uint32_t aIndex) const {
     return mContents[aIndex];
   }
 
   nsStyleContentData& ContentAt(uint32_t aIndex) { return mContents[aIndex]; }
 
@@ -3155,16 +3187,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleUIReset();
     aContext->PresShell()->
       FreeByObjectID(mozilla::eArenaObjectID_nsStyleUIReset, this);
   }
 
   nsChangeHint CalcDifference(const nsStyleUIReset& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   mozilla::StyleUserSelect     mUserSelect;     // [reset](selection-style)
   uint8_t mForceBrokenImageIcon; // [reset] (0 if not forcing, otherwise forcing)
   uint8_t                      mIMEMode;        // [reset]
   mozilla::StyleWindowDragging mWindowDragging; // [reset]
   uint8_t                      mWindowShadow;   // [reset]
   float                        mWindowOpacity;  // [reset]
   RefPtr<nsCSSValueSharedList> mSpecifiedWindowTransform; // [reset]
   nsStyleCoord                 mWindowTransformOrigin[2]; // [reset] percent, coord, calc
@@ -3209,16 +3243,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleUserInterface();
     aContext->PresShell()->
       FreeByObjectID(mozilla::eArenaObjectID_nsStyleUserInterface, this);
   }
 
   nsChangeHint CalcDifference(const nsStyleUserInterface& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   mozilla::StyleUserInput   mUserInput;       // [inherited]
   mozilla::StyleUserModify  mUserModify;      // [inherited] (modify-content)
   mozilla::StyleUserFocus   mUserFocus;       // [inherited] (auto-select)
   uint8_t                   mPointerEvents;   // [inherited] see nsStyleConsts.h
 
   uint8_t mCursor;                            // [inherited] See nsStyleConsts.h
   nsTArray<nsCursorImage> mCursorImages;      // [inherited] images and coords
   mozilla::StyleComplexColor mCaretColor;     // [inherited]
@@ -3242,16 +3278,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleXUL();
     aContext->PresShell()->
       FreeByObjectID(mozilla::eArenaObjectID_nsStyleXUL, this);
   }
 
   nsChangeHint CalcDifference(const nsStyleXUL& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   float         mBoxFlex;               // [reset] see nsStyleConsts.h
   uint32_t      mBoxOrdinal;            // [reset] see nsStyleConsts.h
   mozilla::StyleBoxAlign mBoxAlign;         // [reset]
   mozilla::StyleBoxDirection mBoxDirection; // [reset]
   mozilla::StyleBoxOrient mBoxOrient;       // [reset]
   mozilla::StyleBoxPack mBoxPack;           // [reset]
   mozilla::StyleStackSizing mStackSizing;   // [reset] see nsStyleConsts.h
 };
@@ -3272,16 +3310,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleColumn();
     aContext->PresShell()->
       FreeByObjectID(mozilla::eArenaObjectID_nsStyleColumn, this);
   }
 
   nsChangeHint CalcDifference(const nsStyleColumn& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   /**
    * This is the maximum number of columns we can process. It's used in both
    * nsColumnSetFrame and nsRuleNode.
    */
   static const uint32_t kMaxColumnCount = 1000;
 
   uint32_t     mColumnCount; // [reset] see nsStyleConsts.h
   nsStyleCoord mColumnWidth; // [reset] coord, auto
@@ -3407,16 +3447,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleSVG();
     aContext->PresShell()->
       FreeByObjectID(mozilla::eArenaObjectID_nsStyleSVG, this);
   }
 
   nsChangeHint CalcDifference(const nsStyleSVG& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   nsStyleSVGPaint  mFill;             // [inherited]
   nsStyleSVGPaint  mStroke;           // [inherited]
   RefPtr<mozilla::css::URLValue> mMarkerEnd;   // [inherited]
   RefPtr<mozilla::css::URLValue> mMarkerMid;   // [inherited]
   RefPtr<mozilla::css::URLValue> mMarkerStart; // [inherited]
   nsTArray<nsStyleCoord> mStrokeDasharray;  // [inherited] coord, percent, factor
   nsTArray<RefPtr<nsAtom>> mContextProps;
 
@@ -3602,16 +3644,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void* operator new(size_t sz, nsPresContext* aContext) {
     return aContext->PresShell()->
       AllocateByObjectID(mozilla::eArenaObjectID_nsStyleSVGReset, sz);
   }
   void Destroy(nsPresContext* aContext);
 
   nsChangeHint CalcDifference(const nsStyleSVGReset& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   bool HasClipPath() const {
     return mClipPath.GetType() != mozilla::StyleShapeSourceType::None;
   }
 
   bool HasMask() const;
 
   bool HasNonScalingStroke() const {
     return mVectorEffect == NS_STYLE_VECTOR_EFFECT_NON_SCALING_STROKE;
@@ -3649,16 +3693,18 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleVariables();
     aContext->PresShell()->
       FreeByObjectID(mozilla::eArenaObjectID_nsStyleVariables, this);
   }
 
   nsChangeHint CalcDifference(const nsStyleVariables& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
 #ifdef MOZ_OLD_STYLE
   mozilla::CSSVariableValues mVariables;
 #endif
 };
 
 struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsStyleEffects
 {
   explicit nsStyleEffects(const nsPresContext* aContext);
@@ -3675,28 +3721,222 @@ struct MOZ_NEEDS_MEMMOVABLE_MEMBERS nsSt
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleEffects();
     aContext->PresShell()->
       FreeByObjectID(mozilla::eArenaObjectID_nsStyleEffects, this);
   }
 
   nsChangeHint CalcDifference(const nsStyleEffects& aNewData) const;
 
+  static inline uint32_t ComputationDependencies();
+
   bool HasFilters() const {
     return !mFilters.IsEmpty();
   }
 
   nsTArray<nsStyleFilter>  mFilters;   // [reset]
   RefPtr<nsCSSShadowArray> mBoxShadow; // [reset] nullptr for 'none'
   nsRect  mClip;                       // [reset] offsets from UL border edge
   float   mOpacity;                    // [reset]
   uint8_t mClipFlags;                  // [reset] see nsStyleConsts.h
   uint8_t mMixBlendMode;               // [reset] see nsStyleConsts.h
 };
 
+/*
+ * The computation of one style struct can depend on the data in
+ * another, either on the same element or (maybe) on a different
+ * element (e.g., the parent, which is always different, or the root
+ * element, which may or may not be different).  Since many of these
+ * dependencies are conditional on a particular value of the property,
+ * it might be difficult to detect a circular dependency.
+ *
+ * Thus to avoid circular dependencies, we require that each style
+ * struct have a method returning the bits for all the style structs
+ * that its computation might depend on (which must include its own
+ * bit), and we assert during the computation of one style struct that
+ * all computation calls are within the allowed set.
+ *
+ * This will catch errors because either:
+ *  (1) we'll be unable to get these functions to compile or to return
+ *      (since all dependent structs are handled by calling *their*
+ *      methods), or
+ *  (2) because we'll trigger the assertions.
+ */
+
+/* static */ inline uint32_t
+nsStyleFont::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Font) |
+         nsStyleVisibility::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleColor::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Color) |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleList::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(List) |
+         nsStyleFont::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleText::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Text) |
+         nsStyleFont::ComputationDependencies() |
+         nsStyleColor::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleVisibility::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Visibility) |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleUserInterface::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(UserInterface) |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleTableBorder::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(TableBorder) |
+         nsStyleFont::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleSVG::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(SVG) |
+         nsStyleFont::ComputationDependencies() |
+         nsStyleColor::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleVariables::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Variables);
+}
+
+/* static */ inline uint32_t
+nsStyleBackground::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Background) |
+         nsStyleFont::ComputationDependencies() |
+         nsStyleColor::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStylePosition::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Position) |
+         nsStyleFont::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleTextReset::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(TextReset) |
+         nsStyleFont::ComputationDependencies() |
+         nsStyleColor::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleDisplay::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Display) |
+         nsStyleFont::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleContent::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Content) |
+         nsStyleFont::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleUIReset::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(UIReset) |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleTable::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Table) |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleMargin::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Margin) |
+         nsStyleFont::ComputationDependencies() |
+         nsStyleVisibility::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStylePadding::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Padding) |
+         nsStyleFont::ComputationDependencies() |
+         nsStyleVisibility::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleBorder::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Border) |
+         nsStyleFont::ComputationDependencies() |
+         nsStyleColor::ComputationDependencies() |
+         nsStyleVisibility::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleOutline::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Outline) |
+         nsStyleFont::ComputationDependencies() |
+         nsStyleColor::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleXUL::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(XUL) |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleSVGReset::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(SVGReset) |
+         nsStyleColor::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleColumn::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Column) |
+         nsStyleFont::ComputationDependencies() |
+         nsStyleColor::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
+/* static */ inline uint32_t
+nsStyleEffects::ComputationDependencies() {
+  return NS_STYLE_INHERIT_BIT(Effects) |
+         nsStyleFont::ComputationDependencies() |
+         nsStyleColor::ComputationDependencies() |
+         nsStyleVariables::ComputationDependencies();
+}
+
 #define STATIC_ASSERT_TYPE_LAYOUTS_MATCH(T1, T2)                               \
   static_assert(sizeof(T1) == sizeof(T2),                                      \
       "Size mismatch between " #T1 " and " #T2);                               \
   static_assert(alignof(T1) == alignof(T2),                                    \
       "Align mismatch between " #T1 " and " #T2);                              \
 
 #define STATIC_ASSERT_FIELD_OFFSET_MATCHES(T1, T2, field)                      \
   static_assert(offsetof(T1, field) == offsetof(T2, field),                    \
