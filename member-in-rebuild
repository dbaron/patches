From: L. David Baron <dbaron@dbaron.org>

Bug 1115812 patch 7 - Store the state of whether we're currently rebuilding all style data in a member variable, to prepare for future merging of the rebuild into other code.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -60,16 +60,17 @@ FrameTagToString(const nsIFrame* aFrame)
   aFrame->ListTag(result);
   return result;
 }
 #endif
 
 RestyleManager::RestyleManager(nsPresContext* aPresContext)
   : mPresContext(aPresContext)
   , mDoRebuildAllStyleData(false)
+  , mInRebuildAllStyleData(false)
   , mObservingRefreshDriver(false)
   , mInStyleRefresh(false)
   , mSkipAnimationRules(false)
   , mPostAnimationRestyles(false)
   , mIsProcessingAnimationStyleChange(false)
   , mHoverGeneration(0)
   , mLastUpdateForThrottledAnimations(aPresContext->RefreshDriver()->
                                         MostRecentRefresh())
@@ -1522,16 +1523,18 @@ RestyleManager::RebuildAllStyleData(nsCh
   // by just posting a style change -- except we really need to restyle
   // the root frame rather than the root element's primary frame.
   ProcessPendingRestyles();
 }
 
 void
 RestyleManager::DoRebuildAllStyleData(RestyleTracker& aRestyleTracker)
 {
+  mInRebuildAllStyleData = true;
+
   // Tell the style set to get the old rule tree out of the way
   // so we can recalculate while maintaining rule tree immutability
   nsresult rv = mPresContext->StyleSet()->BeginReconstruct();
   if (NS_FAILED(rv)) {
     return;
   }
 
   // Until we get rid of these phases in bug 960465, we need to add
@@ -1544,22 +1547,26 @@ RestyleManager::DoRebuildAllStyleData(Re
   // Note that we can ignore the return value of ComputeStyleChangeFor
   // because we never need to reframe the root frame
   // Note: The restyle tracker we pass in here doesn't matter.
   ComputeAndProcessStyleChange(mPresContext->PresShell()->GetRootFrame(),
                                nsChangeHint(0), aRestyleTracker,
                                eRestyle_ForceDescendants);
   FlushOverflowChangedTracker();
 
-  // Tell the style set it's safe to destroy the old rule tree.  We
-  // must do this after the ProcessRestyledFrames call in case the
-  // change list has frame reconstructs in it (since frames to be
-  // reconstructed will still have their old style context pointers
-  // until they are destroyed).
-  mPresContext->StyleSet()->EndReconstruct();
+  if (mInRebuildAllStyleData) {
+    // Tell the style set it's safe to destroy the old rule tree.  We
+    // must do this after the ProcessRestyledFrames call in case the
+    // change list has frame reconstructs in it (since frames to be
+    // reconstructed will still have their old style context pointers
+    // until they are destroyed).
+    mPresContext->StyleSet()->EndReconstruct();
+
+    mInRebuildAllStyleData = false;
+  }
 }
 
 void
 RestyleManager::ProcessPendingRestyles()
 {
   NS_PRECONDITION(mPresContext->Document(), "No document?  Pshaw!");
   NS_PRECONDITION(!nsContentUtils::IsSafeToRunScript(),
                   "Missing a script blocker!");
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -462,16 +462,17 @@ private:
   // false if it could not process the position change, and a reflow should
   // be performed instead.
   bool RecomputePosition(nsIFrame* aFrame);
 
 private:
   nsPresContext* mPresContext; // weak, disconnected in Disconnect
 
   bool mDoRebuildAllStyleData : 1;
+  bool mInRebuildAllStyleData : 1;
   // True if we're already waiting for a refresh notification
   bool mObservingRefreshDriver : 1;
   // True if we're in the middle of a nsRefreshDriver refresh
   bool mInStyleRefresh : 1;
   // Whether rule matching should skip styles associated with animation
   bool mSkipAnimationRules : 1;
   // Whether rule matching should post animation restyles when it skips
   // styles associated with animation.  Only true when
