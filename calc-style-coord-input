From: L. David Baron <dbaron@dbaron.org>

Make a common base class for calc ops that use nsStyleCoord as input.  (Bug 585715)  r=bzbarsky

diff --git a/layout/style/CSSCalc.h b/layout/style/CSSCalc.h
--- a/layout/style/CSSCalc.h
+++ b/layout/style/CSSCalc.h
@@ -33,16 +33,17 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 #ifndef CSSCalc_h_
 #define CSSCalc_h_
 
 #include "nsCSSValue.h"
+#include "nsStyleCoord.h"
 #include <math.h>
 
 namespace mozilla {
 
 namespace css {
 
 /**
  * ComputeCalc computes the result of a calc() expression tree.
@@ -147,32 +148,87 @@ ComputeCalc(const typename CalcOps::inpu
       return result;
     }
     default: {
       return aOps.ComputeLeafValue(aValue);
     }
   }
 }
 
+#define CHECK_UNIT(u_)                                                        \
+  PR_STATIC_ASSERT(int(eCSSUnit_Calc_##u_) + 14 == int(eStyleUnit_Calc_##u_));\
+  PR_STATIC_ASSERT(eCSSUnit_Calc_##u_ >= eCSSUnit_Calc_Plus);                 \
+  PR_STATIC_ASSERT(eCSSUnit_Calc_##u_ <= eCSSUnit_Calc_Maximum);
+
+CHECK_UNIT(Plus)
+CHECK_UNIT(Minus)
+CHECK_UNIT(Times_L)
+CHECK_UNIT(Times_R)
+CHECK_UNIT(Divided)
+CHECK_UNIT(Minimum)
+CHECK_UNIT(Maximum)
+
+#undef CHECK_UNIT
+
+inline nsStyleUnit
+ConvertCalcUnit(nsCSSUnit aUnit)
+{
+  NS_ABORT_IF_FALSE(eCSSUnit_Calc_Plus <= aUnit &&
+                    aUnit <= eCSSUnit_Calc_Maximum, "out of range");
+  return nsStyleUnit(aUnit + 14);
+}
+
+inline nsCSSUnit
+ConvertCalcUnit(nsStyleUnit aUnit)
+{
+  NS_ABORT_IF_FALSE(eStyleUnit_Calc_Plus <= aUnit &&
+                    aUnit <= eStyleUnit_Calc_Maximum, "out of range");
+  return nsCSSUnit(aUnit - 14);
+}
+
 /**
  * The input unit operation for input_type being nsCSSValue.
  */
 struct CSSValueInputCalcOps
 {
   typedef nsCSSValue input_type;
   typedef nsCSSValue::Array input_array_type;
 
   static nsCSSUnit GetUnit(const nsCSSValue& aValue)
   {
     return aValue.GetUnit();
   }
 
 };
 
 /**
+ * The input unit operation for input_type being nsStyleCoord
+ */
+struct StyleCoordInputCalcOps
+{
+  typedef nsStyleCoord input_type;
+  typedef nsStyleCoord::Array input_array_type;
+
+  static nsCSSUnit GetUnit(const nsStyleCoord& aValue)
+  {
+    if (aValue.IsCalcUnit()) {
+      return css::ConvertCalcUnit(aValue.GetUnit());
+    }
+    return eCSSUnit_Null;
+  }
+
+  float ComputeNumber(const nsStyleCoord& aValue)
+  {
+    NS_ABORT_IF_FALSE(PR_FALSE, "SpecifiedToComputedCalcOps should not "
+                                "leave numbers in structure");
+    return 0.0f;
+  }
+};
+
+/**
  * Basic*CalcOps provide a partial implementation of the CalcOps
  * template parameter to ComputeCalc, for those callers whose merging
  * just consists of mathematics (rather than tree construction).
  */
 
 struct BasicCoordCalcOps
 {
   typedef nscoord result_type;
@@ -270,47 +326,16 @@ struct NumbersAlreadyNormalizedOps : pub
 {
   float ComputeNumber(const nsCSSValue& aValue)
   {
     NS_ABORT_IF_FALSE(aValue.GetUnit() == eCSSUnit_Number, "unexpected unit");
     return aValue.GetFloatValue();
   }
 };
 
-#define CHECK_UNIT(u_)                                                        \
-  PR_STATIC_ASSERT(int(eCSSUnit_Calc_##u_) + 14 == int(eStyleUnit_Calc_##u_));\
-  PR_STATIC_ASSERT(eCSSUnit_Calc_##u_ >= eCSSUnit_Calc_Plus);                 \
-  PR_STATIC_ASSERT(eCSSUnit_Calc_##u_ <= eCSSUnit_Calc_Maximum);
-
-CHECK_UNIT(Plus)
-CHECK_UNIT(Minus)
-CHECK_UNIT(Times_L)
-CHECK_UNIT(Times_R)
-CHECK_UNIT(Divided)
-CHECK_UNIT(Minimum)
-CHECK_UNIT(Maximum)
-
-#undef CHECK_UNIT
-
-inline nsStyleUnit
-ConvertCalcUnit(nsCSSUnit aUnit)
-{
-  NS_ABORT_IF_FALSE(eCSSUnit_Calc_Plus <= aUnit &&
-                    aUnit <= eCSSUnit_Calc_Maximum, "out of range");
-  return nsStyleUnit(aUnit + 14);
-}
-
-inline nsCSSUnit
-ConvertCalcUnit(nsStyleUnit aUnit)
-{
-  NS_ABORT_IF_FALSE(eStyleUnit_Calc_Plus <= aUnit &&
-                    aUnit <= eStyleUnit_Calc_Maximum, "out of range");
-  return nsCSSUnit(aUnit - 14);
-}
-
 /**
  * SerializeCalc appends the serialization of aValue to a string.
  *
  * It is templatized over a CalcOps class that is expected to provide:
  *
  *   // input_type and input_array_type have a bunch of very specific
  *   // expectations (which happen to be met by two classes (nsCSSValue
  *   // and nsStyleCoord).  There must be methods (roughly):
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -507,29 +507,19 @@ SpecifiedCalcToComputedCalc(const nsCSSV
                             nsStyleContext* aStyleContext,
                             PRBool& aCanStoreInRuleTree)
 {
   SpecifiedToComputedCalcOps ops(aStyleContext, aStyleContext->PresContext(),
                                  aCanStoreInRuleTree);
   aCoord = ComputeCalc(aValue, ops);
 }
 
-struct ComputeComputedCalcCalcOps : public css::BasicCoordCalcOps
+struct ComputeComputedCalcCalcOps : public css::StyleCoordInputCalcOps,
+                                    public css::BasicCoordCalcOps
 {
-  typedef nsStyleCoord input_type;
-  typedef nsStyleCoord::Array input_array_type;
-
-  static nsCSSUnit GetUnit(const nsStyleCoord& aValue)
-  {
-    if (aValue.IsCalcUnit()) {
-      return css::ConvertCalcUnit(aValue.GetUnit());
-    }
-    return eCSSUnit_Null;
-  }
-
   const nscoord mPercentageBasis;
 
   ComputeComputedCalcCalcOps(nscoord aPercentageBasis)
     : mPercentageBasis(aPercentageBasis)
   {
   }
 
   result_type ComputeLeafValue(const nsStyleCoord& aValue)
@@ -538,23 +528,16 @@ struct ComputeComputedCalcCalcOps : publ
     if (aValue.GetUnit() == eStyleUnit_Percent) {
       result = NSCoordSaturatingMultiply(mPercentageBasis,
                                          aValue.GetPercentValue());
     } else {
       result = aValue.GetCoordValue();
     }
     return result;
   }
-
-  float ComputeNumber(const nsStyleCoord& aValue)
-  {
-    NS_ABORT_IF_FALSE(PR_FALSE, "SpecifiedToComputedCalcOps should not "
-                                "leave numbers in structure");
-    return 0.0f;
-  }
 };
 
 // This is our public API for handling calc() expressions that involve
 // percentages.
 /* static */ nscoord
 nsRuleNode::ComputeComputedCalc(const nsStyleCoord& aValue,
                                 nscoord aPercentageBasis)
 {
