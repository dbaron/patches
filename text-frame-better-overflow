From: L. David Baron <dbaron@dbaron.org>

Bug 1140486 patch 2 - Make nsTextFrame::UpdateOverflow include the visual overflow from the text metrics by calling existing RecomputeOverflow.  r=jfkthame

UpdateOverflow and RecomputeOverflow need to remain two separate
functions since RecomputeOverflow is called from line layout, prior to
setting the overflow areas, whereas UpdateOverflow needs to reset the
overflow areas and (via its return value) propagate the change to
ancestors.  However, they should share more code than they do today.

The only substantive (non-error-handling) change this is making is that
it's adding the MeasureText call, manipulation of the resulting
boundingBox, and inclusion of that bounding box in the visual overflow.
This is exactly the change that I'm trying to make in this bug.

It's also changing the error handling if EnsureTextRun returns null, but
I don't think we need to worry about that case much.

diff --git a/layout/generic/nsTextFrame.cpp b/layout/generic/nsTextFrame.cpp
--- a/layout/generic/nsTextFrame.cpp
+++ b/layout/generic/nsTextFrame.cpp
@@ -8991,28 +8991,19 @@ nsTextFrame::HasAnyNoncollapsedCharacter
   int32_t skippedOffset = iter.ConvertOriginalToSkipped(offset);
   int32_t skippedOffsetEnd = iter.ConvertOriginalToSkipped(offsetEnd);
   return skippedOffset != skippedOffsetEnd;
 }
 
 bool
 nsTextFrame::UpdateOverflow()
 {
-  const nsRect rect(nsPoint(0, 0), GetSize());
-  nsOverflowAreas overflowAreas(rect, rect);
-
   if (GetStateBits() & NS_FRAME_FIRST_REFLOW) {
     return false;
   }
-  gfxSkipCharsIterator iter = EnsureTextRun(nsTextFrame::eInflated);
-  if (!mTextRun) {
-    return false;
-  }
-  PropertyProvider provider(this, iter, nsTextFrame::eInflated);
-  provider.InitializeForDisplay(true);
 
   nsIFrame* decorationsBlock;
   if (IsFloatingFirstLetterChild()) {
     decorationsBlock = GetParent();
   } else {
     nsIFrame* f = this;
     for (;;) {
       nsBlockFrame* fBlock = nsLayoutUtils::GetAsBlock(f);
@@ -9024,18 +9015,18 @@ nsTextFrame::UpdateOverflow()
       f = f->GetParent();
       if (!f) {
         NS_ERROR("Couldn't find any block ancestor (for text decorations)");
         return false;
       }
     }
   }
 
-  UnionAdditionalOverflow(PresContext(), decorationsBlock, provider,
-                          &overflowAreas.VisualOverflow(), true);
+  nsOverflowAreas overflowAreas = RecomputeOverflow(decorationsBlock);
+
   return FinishAndStoreOverflow(overflowAreas, GetSize());
 }
 
 void
 nsTextFrame::AssignJustificationGaps(
     const mozilla::JustificationAssignment& aAssign)
 {
   int32_t encoded = (aAssign.mGapsAtStart << 8) | aAssign.mGapsAtEnd;
