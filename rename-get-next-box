From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsBox::GetNextBox to GetNextXULBox.  r=dholbert

Written purely with sed, over .h and .cpp files in layout/.

MozReview-Commit-ID: 2idhqJgZLTe

diff --git a/layout/xul/ScrollBoxObject.cpp b/layout/xul/ScrollBoxObject.cpp
--- a/layout/xul/ScrollBoxObject.cpp
+++ b/layout/xul/ScrollBoxObject.cpp
@@ -147,28 +147,28 @@ void ScrollBoxObject::ScrollByIndex(int3
           break;
         }
       } else {
         diff = rect.y + rect.height/2;// use the center, to avoid rounding errors
         if (diff > cp.y) {
           break;
         }
       }
-      child = nsBox::GetNextBox(child);
+      child = nsBox::GetNextXULBox(child);
       curIndex++;
     }
 
     int32_t count = 0;
 
     if (dindexes == 0)
       return;
 
     if (dindexes > 0) {
       while(child) {
-        child = nsBox::GetNextBox(child);
+        child = nsBox::GetNextXULBox(child);
         if (child) {
           rect = child->GetRect();
         }
         count++;
         if (count >= dindexes) {
           break;
         }
       }
@@ -177,17 +177,17 @@ void ScrollBoxObject::ScrollByIndex(int3
       child = nsBox::GetChildXULBox(scrolledBox);
       while(child) {
         rect = child->GetRect();
         if (count >= curIndex + dindexes) {
           break;
         }
 
         count++;
-        child = nsBox::GetNextBox(child);
+        child = nsBox::GetNextXULBox(child);
 
       }
    }
 
    nscoord csspixel = nsPresContext::CSSPixelsToAppUnits(1);
    if (horiz) {
        // In the left-to-right case we scroll so that the left edge of the
        // selected child is scrolled to the left edge of the scrollbox.
diff --git a/layout/xul/grid/nsGrid.cpp b/layout/xul/grid/nsGrid.cpp
--- a/layout/xul/grid/nsGrid.cpp
+++ b/layout/xul/grid/nsGrid.cpp
@@ -272,17 +272,17 @@ nsGrid::FindRowsAndColumns(nsIFrame** aR
            return;
       }
     }
 
     if (scrollFrame) {
       child = oldBox;
     }
 
-    child = nsBox::GetNextBox(child);
+    child = nsBox::GetNextXULBox(child);
   }
 }
 
 /**
  * Count the number of rows and columns in the given box. aRowCount well become the actual number
  * rows defined in the xul. aComputedColumnCount will become the number of columns by counting the number
  * of cells in each row.
  */
@@ -411,17 +411,17 @@ nsGrid::PopulateCellMap(nsGridRow* aRows
            continue;
          }
 
          if (aIsHorizontal)
            GetCellAt(j,i)->SetBoxInRow(child);
          else
            GetCellAt(i,j)->SetBoxInColumn(child);
 
-         child = nsBox::GetNextBox(child);
+         child = nsBox::GetNextXULBox(child);
 
          j++;
        }
      }
   }
 }
 
 /**
diff --git a/layout/xul/grid/nsGridRowGroupFrame.cpp b/layout/xul/grid/nsGridRowGroupFrame.cpp
--- a/layout/xul/grid/nsGridRowGroupFrame.cpp
+++ b/layout/xul/grid/nsGridRowGroupFrame.cpp
@@ -47,17 +47,17 @@ nsGridRowGroupFrame::GetXULFlex()
     return 0;
 
   // ok we are flexible add up our children
   nscoord totalFlex = 0;
   nsIFrame* child = nsBox::GetChildXULBox(this);
   while (child)
   {
     totalFlex += child->GetXULFlex();
-    child = GetNextBox(child);
+    child = GetNextXULBox(child);
   }
 
   mFlex = totalFlex;
 
   return totalFlex;
 }
 
 
diff --git a/layout/xul/grid/nsGridRowGroupLayout.cpp b/layout/xul/grid/nsGridRowGroupLayout.cpp
--- a/layout/xul/grid/nsGridRowGroupLayout.cpp
+++ b/layout/xul/grid/nsGridRowGroupLayout.cpp
@@ -164,17 +164,17 @@ nsGridRowGroupLayout::DirtyRows(nsIFrame
       // walk into scrollframes
       nsIFrame* deepChild = nsGrid::GetScrolledBox(child);
 
       // walk into other monuments
       nsIGridPart* monument = nsGrid::GetPartFromBox(deepChild);
       if (monument) 
         monument->DirtyRows(deepChild, aState);
 
-      child = nsBox::GetNextBox(child);
+      child = nsBox::GetNextXULBox(child);
     }
   }
 }
 
 
 void
 nsGridRowGroupLayout::CountRowsColumns(nsIFrame* aBox, int32_t& aRowCount, int32_t& aComputedColumnCount)
 {
@@ -186,22 +186,22 @@ nsGridRowGroupLayout::CountRowsColumns(n
     while(child) {
       
       // first see if it is a scrollframe. If so walk down into it and get the scrolled child
       nsIFrame* deepChild = nsGrid::GetScrolledBox(child);
 
       nsIGridPart* monument = nsGrid::GetPartFromBox(deepChild);
       if (monument) {
         monument->CountRowsColumns(deepChild, aRowCount, aComputedColumnCount);
-        child = nsBox::GetNextBox(child);
+        child = nsBox::GetNextXULBox(child);
         deepChild = child;
         continue;
       }
 
-      child = nsBox::GetNextBox(child);
+      child = nsBox::GetNextXULBox(child);
 
       // if not a monument. Then count it. It will be a bogus row
       aRowCount++;
     }
 
     mRowCount = aRowCount - startCount;
   }
 }
@@ -221,24 +221,24 @@ nsGridRowGroupLayout::BuildRows(nsIFrame
     while(child) {
       
       // first see if it is a scrollframe. If so walk down into it and get the scrolled child
       nsIFrame* deepChild = nsGrid::GetScrolledBox(child);
 
       nsIGridPart* monument = nsGrid::GetPartFromBox(deepChild);
       if (monument) {
         rowCount += monument->BuildRows(deepChild, &aRows[rowCount]);
-        child = nsBox::GetNextBox(child);
+        child = nsBox::GetNextXULBox(child);
         deepChild = child;
         continue;
       }
 
       aRows[rowCount].Init(child, true);
 
-      child = nsBox::GetNextBox(child);
+      child = nsBox::GetNextXULBox(child);
 
       // if not a monument. Then count it. It will be a bogus row
       rowCount++;
     }
   }
 
   return rowCount;
 }
diff --git a/layout/xul/grid/nsGridRowLayout.cpp b/layout/xul/grid/nsGridRowLayout.cpp
--- a/layout/xul/grid/nsGridRowLayout.cpp
+++ b/layout/xul/grid/nsGridRowLayout.cpp
@@ -107,17 +107,17 @@ nsGridRowLayout::GetGrid(nsIFrame* aBox,
        if (layout == aRequestor) {
           index = count;
           break;
        }
        count += gridRow->GetRowCount();
      } else 
        count++;
 
-     child = nsBox::GetNextBox(child);
+     child = nsBox::GetNextXULBox(child);
    }
 
    // if we didn't find ourselves then the tree isn't properly formed yet
    // this could happen during initial construction so lets just
    // fail.
    if (index == -1) {
      *aIndex = -1;
      return nullptr;
@@ -142,17 +142,17 @@ nsGridRowLayout::GetTotalMargin(nsIFrame
   nsIGridPart* part = GetParentGridPart(aBox, &parent);
   if (part && parent) {
     // if we are the first or last child walk upward and add margins.
 
     // make sure we check for a scrollbox
     aBox = nsGrid::GetScrollBox(aBox);
 
     // see if we have a next to see if we are last
-    nsIFrame* next = nsBox::GetNextBox(aBox);
+    nsIFrame* next = nsBox::GetNextXULBox(aBox);
 
     // get the parent first child to see if we are first
     nsIFrame* child = nsBox::GetChildXULBox(parent);
 
     margin = part->GetTotalMargin(parent, aIsHorizontal);
 
     // if first or last
     if (child == aBox || next == nullptr) {
diff --git a/layout/xul/grid/nsGridRowLeafLayout.cpp b/layout/xul/grid/nsGridRowLeafLayout.cpp
--- a/layout/xul/grid/nsGridRowLeafLayout.cpp
+++ b/layout/xul/grid/nsGridRowLeafLayout.cpp
@@ -200,17 +200,17 @@ nsGridRowLeafLayout::PopulateBoxSizes(ns
         start = current;
         last = start;
       } else {
         last->next = current;
         last = current;
       }
 
       if (child && !column->mIsBogus)
-        child = nsBox::GetNextBox(child);
+        child = nsBox::GetNextXULBox(child);
 
     }
     aBoxSizes = start;
   }
 
   nsSprocketLayout::PopulateBoxSizes(aBox, aState, aBoxSizes, aMinSize, aMaxSize, aFlexes);
 }
 
@@ -298,17 +298,17 @@ void
 nsGridRowLeafLayout::CountRowsColumns(nsIFrame* aBox, int32_t& aRowCount, int32_t& aComputedColumnCount)
 {
   if (aBox) {
     nsIFrame* child = nsBox::GetChildXULBox(aBox);
 
     // count the children
     int32_t columnCount = 0;
     while(child) {
-      child = nsBox::GetNextBox(child);
+      child = nsBox::GetNextXULBox(child);
       columnCount++;
     }
 
     // if our count is greater than the current column count
     if (columnCount > aComputedColumnCount) 
       aComputedColumnCount = columnCount;
 
     aRowCount++;
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -133,17 +133,17 @@ nsBox::BeginLayout(nsBoxLayoutState& aSt
   // XXXldb Is this still needed?
   mState |= NS_FRAME_HAS_DIRTY_CHILDREN;
 
   if (GetStateBits() & NS_FRAME_IS_DIRTY)
   {
     // If the parent is dirty, all the children are dirty (nsHTMLReflowState
     // does this too).
     nsIFrame* box;
-    for (box = GetChildXULBox(this); box; box = GetNextBox(box))
+    for (box = GetChildXULBox(this); box; box = GetNextXULBox(box))
       box->AddStateBits(NS_FRAME_IS_DIRTY);
   }
 
   // Another copy-over from nsHTMLReflowState.
   // Since we are in reflow, we don't need to store these properties anymore.
   FrameProperties props = Properties();
   props.Delete(UsedBorderProperty());
   props.Delete(UsedPaddingProperty());
@@ -925,17 +925,17 @@ nsBox::BoundsCheck(const nsSize& aMinSiz
 nsBox::GetChildXULBox(const nsIFrame* aFrame)
 {
   // box layout ends at box-wrapped frames, so don't allow these frames
   // to report child boxes.
   return aFrame->IsXULBoxFrame() ? aFrame->PrincipalChildList().FirstChild() : nullptr;
 }
 
 /*static*/ nsIFrame*
-nsBox::GetNextBox(const nsIFrame* aFrame)
+nsBox::GetNextXULBox(const nsIFrame* aFrame)
 {
   return aFrame->GetParent() &&
     aFrame->GetParent()->IsXULBoxFrame() ? aFrame->GetNextSibling() : nullptr;
 }
 
 /*static*/ nsIFrame*
 nsBox::GetParentBox(const nsIFrame* aFrame)
 {
@@ -963,17 +963,17 @@ nsBox::GetDebugBoxAt( const nsPoint& aPo
 
   *aBox = nullptr;
   while (nullptr != child) {
     nsresult rv = child->GetDebugBoxAt(aPoint - child->GetOffsetTo(this), &hit);
 
     if (NS_SUCCEEDED(rv) && hit) {
       *aBox = hit;
     }
-    child = GetNextBox(child);
+    child = GetNextXULBox(child);
   }
 
   // found a child
   if (*aBox) {
     return NS_OK;
   }
 
   return NS_ERROR_FAILURE;
diff --git a/layout/xul/nsBox.h b/layout/xul/nsBox.h
--- a/layout/xul/nsBox.h
+++ b/layout/xul/nsBox.h
@@ -73,17 +73,17 @@ rollbox.
   static void AddMargin(nsIFrame* aChild, nsSize& aSize);
   static void AddMargin(nsSize& aSize, const nsMargin& aMargin);
 
   static nsSize BoundsCheckMinMax(const nsSize& aMinSize, const nsSize& aMaxSize);
   static nsSize BoundsCheck(const nsSize& aMinSize, const nsSize& aPrefSize, const nsSize& aMaxSize);
   static nscoord BoundsCheck(nscoord aMinSize, nscoord aPrefSize, nscoord aMaxSize);
 
   static nsIFrame* GetChildXULBox(const nsIFrame* aFrame);
-  static nsIFrame* GetNextBox(const nsIFrame* aFrame);
+  static nsIFrame* GetNextXULBox(const nsIFrame* aFrame);
   static nsIFrame* GetParentBox(const nsIFrame* aFrame);
 
 protected:
 
 #ifdef DEBUG_LAYOUT
   virtual void AppendAttribute(const nsAutoString& aAttribute, const nsAutoString& aValue, nsAutoString& aResult);
 
   virtual void ListBox(nsAutoString& aResult);
diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -1505,17 +1505,17 @@ nsBoxFrame::PaintXULDebugOverlay(DrawTar
       if (isHorizontal) 
           borderSize = cr.width;
       else 
           borderSize = cr.height;
 
       DrawSpacer(GetPresContext(), aDrawTarget, isHorizontal, flex, x, y, borderSize, spacerSize);
     }
 
-    kid = GetNextBox(kid);
+    kid = GetNextXULBox(kid);
   }
 }
 #endif
 
 #ifdef DEBUG_LAYOUT
 void
 nsBoxFrame::GetBoxName(nsAutoString& aName)
 {
@@ -1818,17 +1818,17 @@ nsBoxFrame::DisplayDebugInfoFor(nsIFrame
                         calc,
                         flex,
                         ascent
                     );
 
                     return NS_OK;   
             }
 
-          child = GetNextBox(child);
+          child = GetNextXULBox(child);
           count++;
         }
     } else {
     }
 
     mDebugChild = nullptr;
 
     return NS_OK;
@@ -1836,17 +1836,17 @@ nsBoxFrame::DisplayDebugInfoFor(nsIFrame
 
 void
 nsBoxFrame::SetDebugOnChildList(nsBoxLayoutState& aState, nsIFrame* aChild, bool aDebug)
 {
     nsIFrame* child = nsBox::GetChildXULBox(this);
      while (child)
      {
         child->SetDebug(aState, aDebug);
-        child = GetNextBox(child);
+        child = GetNextXULBox(child);
      }
 }
 
 nsresult
 nsBoxFrame::GetFrameSizeWithMargin(nsIFrame* aBox, nsSize& aSize)
 {
   nsRect rect(aBox->GetRect());
   nsMargin margin(0,0,0,0);
@@ -1950,17 +1950,17 @@ nsBoxFrame::RelayoutChildAtOrdinal(nsIFr
     if (ord < child->GetXULOrdinal()) {
       break;
     }
 
     if (child != aChild) {
       newPrevSib = child;
     }
 
-    child = GetNextBox(child);
+    child = GetNextXULBox(child);
   }
 
   if (aChild->GetPrevSibling() == newPrevSib) {
     // This box is not moving.
     return NS_OK;
   }
 
   // Take |aChild| out of its old position in the child list.
diff --git a/layout/xul/nsDeckFrame.cpp b/layout/xul/nsDeckFrame.cpp
--- a/layout/xul/nsDeckFrame.cpp
+++ b/layout/xul/nsDeckFrame.cpp
@@ -215,17 +215,17 @@ nsDeckFrame::DoLayout(nsBoxLayoutState& 
 
   nscoord count = 0;
   while (box) 
   {
     // make collapsed children not show up
     if (count != mIndex) 
       HideBox(box);
 
-    box = GetNextBox(box);
+    box = GetNextXULBox(box);
     count++;
   }
 
   aState.SetLayoutFlags(oldFlags);
 
   return rv;
 }
 
diff --git a/layout/xul/nsListBoxLayout.cpp b/layout/xul/nsListBoxLayout.cpp
--- a/layout/xul/nsListBoxLayout.cpp
+++ b/layout/xul/nsListBoxLayout.cpp
@@ -180,17 +180,17 @@ nsListBoxLayout::LayoutInternal(nsIFrame
 
     // Ok now the available size gets smaller and we move the
     // starting position of the next child down some.
     nscoord size = childRect.height + margin.top + margin.bottom;
 
     yOffset += size;
     availableHeight -= size;
     
-    box = nsBox::GetNextBox(box);
+    box = nsBox::GetNextXULBox(box);
   }
   
   // We have enough available height left to add some more rows
   // Since we can't do this during layout, we post a callback
   // that will be processed after the reflow completes.
   body->PostReflowCallback();
     
   // if rows were pushed down or pulled up because some rows were added
diff --git a/layout/xul/nsSplitterFrame.cpp b/layout/xul/nsSplitterFrame.cpp
--- a/layout/xul/nsSplitterFrame.cpp
+++ b/layout/xul/nsSplitterFrame.cpp
@@ -707,17 +707,17 @@ nsSplitterFrameInner::MouseDown(nsIDOMEv
                 mChildInfosAfter[mChildInfosAfterCount].flex    = flex;
                 mChildInfosAfter[mChildInfosAfterCount].index   = count;
                 mChildInfosAfter[mChildInfosAfterCount].changed = mChildInfosAfter[mChildInfosAfterCount].current;
                 mChildInfosAfterCount++;
             }
         } 
     }
     
-    childBox = nsBox::GetNextBox(childBox);
+    childBox = nsBox::GetNextXULBox(childBox);
     count++;
   }
 
   if (!mParentBox->IsNormalDirection()) {
     // The before array is really the after array, and the order needs to be reversed.
     // First reverse both arrays.
     Reverse(mChildInfosBefore, mChildInfosBeforeCount);
     Reverse(mChildInfosAfter, mChildInfosAfterCount);
@@ -898,17 +898,17 @@ nsSplitterFrameInner::AdjustChildren(nsP
 static nsIFrame* GetChildBoxForContent(nsIFrame* aParentBox, nsIContent* aContent)
 {
   nsIFrame* childBox = nsBox::GetChildXULBox(aParentBox);
 
   while (nullptr != childBox) {
     if (childBox->GetContent() == aContent) {
       return childBox;
     }
-    childBox = nsBox::GetNextBox(childBox);
+    childBox = nsBox::GetNextXULBox(childBox);
   }
   return nullptr;
 }
 
 void
 nsSplitterFrameInner::AdjustChildren(nsPresContext* aPresContext, nsSplitterInfo* aChildInfos, int32_t aCount, bool aIsHorizontal)
 {
   ///printf("------- AdjustChildren------\n");
@@ -917,17 +917,17 @@ nsSplitterFrameInner::AdjustChildren(nsP
 
   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
 
   // first set all the widths.
   nsIFrame* child =  nsBox::GetChildXULBox(mOuter);
   while(child)
   {
     SetPreferredSize(state, child, onePixel, aIsHorizontal, nullptr);
-    child = nsBox::GetNextBox(child);
+    child = nsBox::GetNextXULBox(child);
   }
 
   // now set our changed widths.
   for (int i=0; i < aCount; i++) 
   {
     nscoord   pref       = aChildInfos[i].changed;
     nsIFrame* childBox     = GetChildBoxForContent(mParentBox, aChildInfos[i].childElem);
 
diff --git a/layout/xul/nsSprocketLayout.cpp b/layout/xul/nsSprocketLayout.cpp
--- a/layout/xul/nsSprocketLayout.cpp
+++ b/layout/xul/nsSprocketLayout.cpp
@@ -172,17 +172,17 @@ nsSprocketLayout::XULLayout(nsIFrame* aB
 {
   // See if we are collapsed. If we are, then simply iterate over all our
   // children and give them a rect of 0 width and height.
   if (aBox->IsXULCollapsed()) {
     nsIFrame* child = nsBox::GetChildXULBox(aBox);
     while(child) 
     {
       nsBoxFrame::LayoutChildAt(aState, child, nsRect(0,0,0,0));  
-      child = nsBox::GetNextBox(child);
+      child = nsBox::GetNextXULBox(child);
     }
     return NS_OK;
   }
 
   nsBoxLayoutState::AutoReflowDepth depth(aState);
   mozilla::AutoStackArena arena;
 
   // ----- figure out our size ----------
@@ -560,17 +560,17 @@ nsSprocketLayout::XULLayout(nsIFrame* aB
       // Now update our x/y finally.
       x = nextX;
       y = nextY;
      
       // Move to the next child.
       childComputedBoxSize = childComputedBoxSize->next;
       childBoxSize = childBoxSize->next;
 
-      child = nsBox::GetNextBox(child);
+      child = nsBox::GetNextXULBox(child);
       count++;
     }
 
     // Sanity-checking code to ensure we don't do an infinite # of passes.
     passes++;
     NS_ASSERTION(passes < 10, "A Box's child is constantly growing!!!!!");
     if (passes > 10)
       break;
@@ -624,17 +624,17 @@ nsSprocketLayout::XULLayout(nsIFrame* aB
 
     // reposition all our children
     while (child) 
     {
       nsRect childRect(child->GetRect());
       childRect.x += (x - origX);
       childRect.y += (y - origY);
       child->SetXULBounds(aState, childRect);
-      child = nsBox::GetNextBox(child);
+      child = nsBox::GetNextXULBox(child);
     }
   }
 
   // Perform out-of-axis alignment for non-stretch alignments
   if (!(frameState & NS_STATE_AUTO_STRETCH)) {
     AlignChildren(aBox, aState);
   }
   
@@ -709,17 +709,17 @@ nsSprocketLayout::PopulateBoxSizes(nsIFr
     } else {
       flex = start->flex;
       start = start->next;
     }
     
     if (flex > 0) 
        aFlexes++;
    
-    child = GetNextBox(child);
+    child = GetNextXULBox(child);
   }
 #endif
 
   // get pref, min, max
   child = nsBox::GetChildXULBox(aBox);
   currentBox = aBoxSizes;
   nsBoxSize* last = nullptr;
 
@@ -833,17 +833,17 @@ nsSprocketLayout::PopulateBoxSizes(nsIFr
 
       if (maxSize.height < aMaxSize)
         aMaxSize = maxSize.height;
     }
 
     currentBox->collapsed = collapsed;
     aFlexes += currentBox->flex;
 
-    child = nsBox::GetNextBox(child);
+    child = nsBox::GetNextXULBox(child);
 
     last = currentBox;
     currentBox = currentBox->next;
 
   }
 
   if (childCount > 0) {
     nscoord maxAllowedFlex = nscoord_MAX / childCount;
@@ -1001,17 +1001,17 @@ nsSprocketLayout::AlignChildren(nsIFrame
 
       childRect.x = x;
     }
 
     if (childRect.TopLeft() != child->GetPosition()) {
       child->SetXULBounds(aState, childRect);
     }
 
-    child = nsBox::GetNextBox(child);
+    child = nsBox::GetNextXULBox(child);
   }
 }
 
 void
 nsSprocketLayout::ChildResized(nsIFrame* aBox,
                          nsBoxLayoutState& aState, 
                          nsIFrame* aChild,
                          nsBoxSize* aChildBoxSize,
@@ -1338,17 +1338,17 @@ nsSprocketLayout::GetXULPrefSize(nsIFram
               biggestPref = pref.height;
           }
         }
 
         AddLargestSize(vpref, pref, isHorizontal);
         count++;
       }
 
-      child = nsBox::GetNextBox(child);
+      child = nsBox::GetNextXULBox(child);
    }
 
    if (isEqual) {
       if (isHorizontal)
          vpref.width = biggestPref*count;
       else
          vpref.height = biggestPref*count;
    }
@@ -1406,17 +1406,17 @@ nsSprocketLayout::GetXULMinSize(nsIFrame
           }
         }
 
         AddMargin(child, min);
         AddLargestSize(minSize, min, isHorizontal);
         count++;
       }
 
-      child = nsBox::GetNextBox(child);
+      child = nsBox::GetNextXULBox(child);
    }
 
    
    if (isEqual) {
       if (isHorizontal)
          minSize.width = biggestMin*count;
       else
          minSize.height = biggestMin*count;
@@ -1466,17 +1466,17 @@ nsSprocketLayout::GetXULMaxSize(nsIFrame
           } else {
             if (max.height < smallestMax)
               smallestMax = max.height;
           }
         }
         count++;
       }
 
-      child = nsBox::GetNextBox(child);
+      child = nsBox::GetNextXULBox(child);
    }
 
    if (isEqual) {
      if (isHorizontal) {
          if (smallestMax != NS_INTRINSICSIZE)
             maxSize.width = smallestMax*count;
          else
             maxSize.width = NS_INTRINSICSIZE;
@@ -1524,17 +1524,17 @@ nsSprocketLayout::GetAscent(nsIFrame* aB
           if (ascent > vAscent)
             vAscent = ascent;
         } else {
           if (vAscent == 0)
             vAscent = ascent;
         }
       //}
 
-      child = nsBox::GetNextBox(child);      
+      child = nsBox::GetNextXULBox(child);      
    }
 
    nsMargin borderPadding;
    aBox->GetBorderAndPadding(borderPadding);
 
    return vAscent + borderPadding.top;
 }
 
diff --git a/layout/xul/nsStackLayout.cpp b/layout/xul/nsStackLayout.cpp
--- a/layout/xul/nsStackLayout.cpp
+++ b/layout/xul/nsStackLayout.cpp
@@ -71,17 +71,17 @@ nsStackLayout::GetXULPrefSize(nsIFrame* 
       AddMargin(child, pref);
       nsMargin offset;
       GetOffset(child, offset);
       pref.width += offset.LeftRight();
       pref.height += offset.TopBottom();
       AddLargestSize(prefSize, pref);
     }
 
-    child = nsBox::GetNextBox(child);
+    child = nsBox::GetNextXULBox(child);
   }
 
   AddBorderAndPadding(aBox, prefSize);
 
   return prefSize;
 }
 
 nsSize
@@ -97,17 +97,17 @@ nsStackLayout::GetXULMinSize(nsIFrame* a
       AddMargin(child, min);
       nsMargin offset;
       GetOffset(child, offset);
       min.width += offset.LeftRight();
       min.height += offset.TopBottom();
       AddLargestSize(minSize, min);
     }
 
-    child = nsBox::GetNextBox(child);
+    child = nsBox::GetNextXULBox(child);
   }
 
   AddBorderAndPadding(aBox, minSize);
 
   return minSize;
 }
 
 nsSize
@@ -126,17 +126,17 @@ nsStackLayout::GetXULMaxSize(nsIFrame* a
       AddMargin(child, max);
       nsMargin offset;
       GetOffset(child, offset);
       max.width += offset.LeftRight();
       max.height += offset.TopBottom();
       AddSmallestSize(maxSize, max);
     }
 
-    child = nsBox::GetNextBox(child);
+    child = nsBox::GetNextXULBox(child);
   }
 
   AddBorderAndPadding(aBox, maxSize);
 
   return maxSize;
 }
 
 
@@ -149,17 +149,17 @@ nsStackLayout::GetAscent(nsIFrame* aBox,
   while (child) {  
     nscoord ascent = child->GetXULBoxAscent(aState);
     nsMargin margin;
     child->GetMargin(margin);
     ascent += margin.top;
     if (ascent > vAscent)
       vAscent = ascent;
 
-    child = nsBox::GetNextBox(child);
+    child = nsBox::GetNextXULBox(child);
   }
 
   return vAscent;
 }
 
 uint8_t
 nsStackLayout::GetOffset(nsIFrame* aChild, nsMargin& aOffset)
 {
@@ -354,17 +354,17 @@ nsStackLayout::XULLayout(nsIFrame* aBox,
 
             if (offset.TopBottom() + childRect.height > clientRect.height) {
               clientRect.height = childRect.height + offset.TopBottom();
               grow = true;
             }
           }
        }
 
-       child = nsBox::GetNextBox(child);
+       child = nsBox::GetNextXULBox(child);
      }
    } while (grow);
    
    // if some HTML inside us got bigger we need to force ourselves to
    // get bigger
    nsRect bounds(aBox->GetRect());
    nsMargin bp;
    aBox->GetBorderAndPadding(bp);
