From: L. David Baron <dbaron@dbaron.org>

Bug 978833 patch 13 - Stop calling DeclarationChanged since we don't need to replace style rules any longer.

(I wonder whether the DOMCSSDeclarationImpl::GetCSSDeclaration fixes an
existing bug with DOM modification to shared sheets that have never been
used for styling... since I'd think in that case we'd decide that we can
modify the existing declaration, which is owned by a rule that's shared
between sheets.)

diff --git a/layout/style/StyleRule.cpp b/layout/style/StyleRule.cpp
--- a/layout/style/StyleRule.cpp
+++ b/layout/style/StyleRule.cpp
@@ -1199,16 +1199,22 @@ DOMCSSDeclarationImpl::DropReference(voi
 {
   mRule = nullptr;
 }
 
 css::Declaration*
 DOMCSSDeclarationImpl::GetCSSDeclaration(Operation aOperation)
 {
   if (mRule) {
+    if (aOperation != eOperation_Read) {
+      nsCOMPtr<nsIStyleSheet> sheet = mRule->GetStyleSheet();
+      if (sheet) {
+        sheet->WillDirty();
+      }
+    }
     return mRule->GetDeclaration();
   } else {
     return nullptr;
   }
 }
 
 void
 DOMCSSDeclarationImpl::GetCSSParsingEnvironment(CSSParsingEnvironment& aCSSParseEnv)
@@ -1239,29 +1245,22 @@ DOMCSSDeclarationImpl::SetCSSDeclaration
   nsCOMPtr<nsIDocument> owningDoc;
   nsCOMPtr<nsIStyleSheet> sheet = mRule->GetStyleSheet();
   if (sheet) {
     owningDoc = sheet->GetOwningDocument();
   }
 
   mozAutoDocUpdate updateBatch(owningDoc, UPDATE_STYLE, true);
 
-  RefPtr<css::StyleRule> oldRule = mRule;
-  mRule = oldRule->DeclarationChanged(aDecl, true).take();
-  if (!mRule)
-    return NS_ERROR_OUT_OF_MEMORY;
-  nsrefcnt cnt = mRule->Release();
-  if (cnt == 0) {
-    NS_NOTREACHED("container didn't take ownership");
-    mRule = nullptr;
-    return NS_ERROR_UNEXPECTED;
+  if (sheet) {
+    sheet->DidDirty();
   }
 
   if (owningDoc) {
-    owningDoc->StyleRuleChanged(sheet, oldRule, mRule);
+    owningDoc->StyleRuleChanged(sheet, mRule, mRule);
   }
   return NS_OK;
 }
 
 nsIDocument*
 DOMCSSDeclarationImpl::DocToUpdate()
 {
   return nullptr;
diff --git a/layout/style/nsDOMCSSAttrDeclaration.cpp b/layout/style/nsDOMCSSAttrDeclaration.cpp
--- a/layout/style/nsDOMCSSAttrDeclaration.cpp
+++ b/layout/style/nsDOMCSSAttrDeclaration.cpp
@@ -67,30 +67,27 @@ NS_IMPL_QUERY_TAIL_INHERITING(nsDOMCSSDe
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(nsDOMCSSAttributeDeclaration)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsDOMCSSAttributeDeclaration)
 
 nsresult
 nsDOMCSSAttributeDeclaration::SetCSSDeclaration(css::Declaration* aDecl)
 {
   NS_ASSERTION(mElement, "Must have Element to set the declaration!");
-  css::StyleRule* oldRule =
+  css::StyleRule* rule =
     mIsSMILOverride ? mElement->GetSMILOverrideStyleRule() :
     mElement->GetInlineStyleRule();
-  NS_ASSERTION(oldRule, "Element must have rule");
+  NS_ASSERTION(rule, "Element must have rule");
 
-  RefPtr<css::StyleRule> newRule =
-    oldRule->DeclarationChanged(aDecl, false);
-  if (!newRule) {
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-
+  // FIXME: For now, we'll just set the same rule to cause
+  // notifications; in the long term we probably want a better way to do
+  // this.
   return
-    mIsSMILOverride ? mElement->SetSMILOverrideStyleRule(newRule, true) :
-    mElement->SetInlineStyleRule(newRule, nullptr, true);
+    mIsSMILOverride ? mElement->SetSMILOverrideStyleRule(rule, true) :
+    mElement->SetInlineStyleRule(rule, nullptr, true);
 }
 
 nsIDocument*
 nsDOMCSSAttributeDeclaration::DocToUpdate()
 {
   // We need OwnerDoc() rather than GetCurrentDoc() because it might
   // be the BeginUpdate call that inserts mElement into the document.
   return mElement->OwnerDoc();
