From: L. David Baron <dbaron@dbaron.org>

Bug 992077 patch 3 - Stop using OverflowChangedTracker::CHILDREN_AND_PARENT_CHANGED for the UpdateOverflow and related hints.

This makes UpdateOverflow hint handling (which definitely did previously
need CHILDREN_AND_PARENT_CHANGED) and handling of related hints (which I
believe never actually needed CHILDREN_AND_PARENT_CHANGED) use the
CHILDREN_CHANGED hint in the overflow changed tracker, since use of
CHILDREN_AND_PARENT_CHANGED is no longer needed following the
introduction of the UpdateParentOverflow hint in patch 2.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -584,17 +584,17 @@ RestyleManager::StyleChangeReflow(nsIFra
   } while (aFrame);
 }
 
 void
 RestyleManager::AddSubtreeToOverflowTracker(nsIFrame* aFrame) 
 {
   mOverflowChangedTracker.AddFrame(
       aFrame,
-      OverflowChangedTracker::CHILDREN_AND_PARENT_CHANGED);
+      OverflowChangedTracker::CHILDREN_CHANGED);
   nsIFrame::ChildListIterator lists(aFrame);
   for (; !lists.IsDone(); lists.Next()) {
     nsFrameList::Enumerator childFrames(lists.CurrentList());
     for (; !childFrames.AtEnd(); childFrames.Next()) {
       nsIFrame* child = childFrames.get();
       AddSubtreeToOverflowTracker(child);
     }
   }
@@ -850,17 +850,17 @@ RestyleManager::ProcessRestyledFrames(ns
           for ( ; childFrame; childFrame = childFrame->GetNextSibling()) {
             MOZ_ASSERT(childFrame->IsFrameOfType(nsIFrame::eSVG),
                        "Not expecting non-SVG children");
             // If |childFrame| is dirty or has dirty children, we don't bother
             // updating overflows since that will happen when it's reflowed.
             if (!(childFrame->GetStateBits() &
                   (NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN))) {
               mOverflowChangedTracker.AddFrame(childFrame,
-                           OverflowChangedTracker::CHILDREN_AND_PARENT_CHANGED);
+                           OverflowChangedTracker::CHILDREN_CHANGED);
             }
             NS_ASSERTION(!nsLayoutUtils::GetNextContinuationOrIBSplitSibling(childFrame),
                          "SVG frames should not have continuations "
                          "or ib-split siblings");
             NS_ASSERTION(childFrame->GetParent() == hintFrame,
                          "SVG child frame not expected to have different parent");
           }
         }
@@ -869,21 +869,21 @@ RestyleManager::ProcessRestyledFrames(ns
         if (!(frame->GetStateBits() &
               (NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN))) {
           if (hint & (nsChangeHint_UpdateOverflow |
                       nsChangeHint_UpdateSubtreeOverflow |
                       nsChangeHint_UpdatePostTransformOverflow)) {
             OverflowChangedTracker::ChangeKind changeKind;
             // If we have both nsChangeHint_UpdateOverflow and
             // nsChangeHint_UpdatePostTransformOverflow,
-            // CHILDREN_AND_PARENT_CHANGED is selected as it is
+            // CHILDREN_CHANGED is selected as it is
             // strictly stronger.
             if (hint & (nsChangeHint_UpdateOverflow |
                         nsChangeHint_UpdateSubtreeOverflow)) {
-              changeKind = OverflowChangedTracker::CHILDREN_AND_PARENT_CHANGED;
+              changeKind = OverflowChangedTracker::CHILDREN_CHANGED;
             } else {
               changeKind = OverflowChangedTracker::TRANSFORM_CHANGED;
             }
             for (nsIFrame *cont = frame; cont; cont =
                    nsLayoutUtils::GetNextContinuationOrIBSplitSibling(cont)) {
               mOverflowChangedTracker.AddFrame(cont, changeKind);
             }
           }
