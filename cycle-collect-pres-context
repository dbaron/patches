Add nsPresContext and nsEventStateManager to cycle collection.  b=385376

diff --git a/content/events/src/nsEventStateManager.cpp b/content/events/src/nsEventStateManager.cpp
--- a/content/events/src/nsEventStateManager.cpp
+++ b/content/events/src/nsEventStateManager.cpp
@@ -602,8 +602,80 @@ nsEventStateManager::Observe(nsISupports
   return NS_OK;
 }
 
-
-NS_IMPL_ISUPPORTS3(nsEventStateManager, nsIEventStateManager, nsIObserver, nsISupportsWeakReference)
+NS_IMPL_CYCLE_COLLECTION_CLASS(nsEventStateManager)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsEventStateManager)
+   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIEventStateManager)
+   NS_INTERFACE_MAP_ENTRY(nsIEventStateManager)
+   NS_INTERFACE_MAP_ENTRY(nsIObserver)
+   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsEventStateManager, nsIEventStateManager)
+NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS(nsEventStateManager, nsIEventStateManager)
+
+PR_STATIC_CALLBACK(PRBool)
+TraverseAccessKeyContent(nsHashKey *aKey, void *aData, void* aClosure)
+{
+  nsCycleCollectionTraversalCallback *cb =
+    static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
+  nsIContent *content =
+    static_cast<nsIContent*>(aData);
+
+  cb->NoteXPCOMChild(content);
+
+  return kHashEnumerateNext;
+}
+
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsEventStateManager)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mCurrentTargetContent);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mLastMouseOverElement);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mGestureDownContent);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mGestureDownFrameOwner);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mLastLeftMouseDownContent);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mLastMiddleMouseDownContent);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mLastRightMouseDownContent);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mActiveContent);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mHoverContent);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mDragOverContent);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mURLTargetContent);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mCurrentFocus);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mLastFocus);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mLastContentFocus);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mFirstBlurEvent);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mFirstFocusEvent);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mFirstMouseOverEventElement);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mFirstMouseOutEventElement);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mDocument);
+  if (mAccessKeys) {
+    mAccessKeys->Enumerate(TraverseAccessKeyContent, &cb);
+  }
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
+
+NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsEventStateManager)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mCurrentTargetContent);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mLastMouseOverElement);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mGestureDownContent);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mGestureDownFrameOwner);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mLastLeftMouseDownContent);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mLastMiddleMouseDownContent);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mLastRightMouseDownContent);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mActiveContent);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mHoverContent);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mDragOverContent);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mURLTargetContent);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mCurrentFocus);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mLastFocus);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mLastContentFocus);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mFirstBlurEvent);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mFirstFocusEvent);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mFirstMouseOverEventElement);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mFirstMouseOutEventElement);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mDocument);
+  delete tmp->mAccessKeys;
+  tmp->mAccessKeys = nsnull;
+NS_IMPL_CYCLE_COLLECTION_UNLINK_END
+
 
 NS_IMETHODIMP
 nsEventStateManager::PreHandleEvent(nsPresContext* aPresContext,
diff --git a/content/events/src/nsEventStateManager.h b/content/events/src/nsEventStateManager.h
--- a/content/events/src/nsEventStateManager.h
+++ b/content/events/src/nsEventStateManager.h
@@ -77,7 +77,7 @@ public:
   nsEventStateManager();
   virtual ~nsEventStateManager();
 
-  NS_DECL_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_NSIOBSERVER
 
   NS_IMETHOD Init();
@@ -154,6 +154,9 @@ public:
   {
     return sUserInputEventDepth > 0;
   }
+
+  NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsEventStateManager,
+                                           nsIEventStateManager)
 
 protected:
   /**
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -286,6 +286,60 @@ nsPresContext::~nsPresContext()
 
 NS_IMPL_ISUPPORTS1(nsPresContext, nsIObserver)
 
+NS_IMPL_CYCLE_COLLECTION_CLASS(nsPresContext)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsPresContext)
+   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIObserver)
+   NS_INTERFACE_MAP_ENTRY(nsIObserver)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(nsPresContext)
+NS_IMPL_CYCLE_COLLECTING_RELEASE(nsPresContext)
+
+PR_STATIC_CALLBACK(PLDHashOperator)
+TraverseImageLoader(const void * aKey, nsCOMPtr<nsImageLoader>& aData,
+                    void* aClosure)
+{
+  nsCycleCollectionTraversalCallback *cb =
+    static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
+
+  cb->NoteXPCOMChild(aData);
+
+  return PL_DHASH_NEXT;
+}
+
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsPresContext)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mDocument);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mDeviceContext); // worth bothering?
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mEventManager);
+  // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mLookAndFeel); // a service
+  // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mLangGroup); // an atom
+
+  tmp->mImageLoaders.Enumerate(TraverseImageLoader, &cb);
+
+  // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mTheme); // a service
+  // NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mLangService); // a service
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mPrintSettings);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_COMPTR(mPrefChangedTimer);
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
+
+NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsPresContext)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mDocument);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_RAWPTR(mDeviceContext); // worth bothering?
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_RAWPTR(mEventManager);
+  // NS_IMPL_CYCLE_COLLECTION_UNLINK_RAWPTR(mLookAndFeel); // a service
+  // NS_IMPL_CYCLE_COLLECTION_UNLINK_RAWPTR(mLangGroup); // an atom
+
+  tmp->mImageLoaders.Enumerate(destroy_loads, &cb);
+  tmp->mImageLoaders.Clear();
+
+  // NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mTheme); // a service
+  // NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mLangService); // a service
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mPrintSettings);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_COMPTR(mPrefChangedTimer);
+NS_IMPL_CYCLE_COLLECTION_UNLINK_END
+
+
 #define MAKE_FONT_PREF_KEY(_pref, _s0, _s1) \
  _pref.Assign(_s0); \
  _pref.Append(_s1);
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -139,9 +139,10 @@ enum nsLayoutPhase {
 
 class nsPresContext : public nsIObserver {
 public:
-  NS_DECL_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_NSIOBSERVER
   NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
+  NS_DECL_CYCLE_COLLECTION_CLASS(nsPresContext)
 
   enum nsPresContextType {
     eContext_Galley,       // unpaginated screen presentation
