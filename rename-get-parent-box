From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsBox::GetParentBox to GetParentXULBox.

This is a manual subset of changes written with sed, over .h and .cpp
files in layout/.

MozReview-Commit-ID: FqTrLBFZMF5

diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -1935,17 +1935,17 @@ GetMouseThrough(const nsIFrame* aFrame)
 
   const nsIFrame* frame = aFrame;
   while (frame) {
     if (frame->GetStateBits() & NS_FRAME_MOUSE_THROUGH_ALWAYS) {
       return true;
     } else if (frame->GetStateBits() & NS_FRAME_MOUSE_THROUGH_NEVER) {
       return false;
     }
-    frame = nsBox::GetParentBox(frame);
+    frame = nsBox::GetParentXULBox(frame);
   }
   return false;
 }
 
 static bool
 IsFrameReceivingPointerEvents(nsIFrame* aFrame)
 {
   nsSubDocumentFrame* frame = do_QueryFrame(aFrame);
diff --git a/layout/xul/grid/nsGrid.cpp b/layout/xul/grid/nsGrid.cpp
--- a/layout/xul/grid/nsGrid.cpp
+++ b/layout/xul/grid/nsGrid.cpp
@@ -1087,23 +1087,23 @@ nsGrid::GetRowFlex(int32_t aIndex, bool 
     //   </rows>
     // </grid>
 
     // so the answer is simple: 1) Walk our parent chain. 2) If we find
     // someone who is not flexible and they aren't the rows immediately in
     // the grid. 3) Then we are not flexible
 
     box = GetScrollBox(box);
-    nsIFrame* parent = nsBox::GetParentBox(box);
+    nsIFrame* parent = nsBox::GetParentXULBox(box);
     nsIFrame* parentsParent=nullptr;
 
     while(parent)
     {
       parent = GetScrollBox(parent);
-      parentsParent = nsBox::GetParentBox(parent);
+      parentsParent = nsBox::GetParentXULBox(parent);
 
       // if our parents parent is not a grid
       // the get its flex. If its 0 then we are
       // not flexible.
       if (parentsParent) {
         if (!IsGrid(parentsParent)) {
           nscoord flex = parent->GetXULFlex();
           nsIFrame::AddCSSFlex(parent, flex);
@@ -1220,34 +1220,34 @@ nsGrid::GetScrolledBox(nsIFrame* aChild)
  */
 nsIFrame*
 nsGrid::GetScrollBox(nsIFrame* aChild)
 {
   if (!aChild)
     return nullptr;
 
   // get parent
-  nsIFrame* parent = nsBox::GetParentBox(aChild);
+  nsIFrame* parent = nsBox::GetParentXULBox(aChild);
 
   // walk up until we find a scrollframe or a part
   // if it's a scrollframe return it.
   // if it's a parent then the child passed does not
   // have a scroll frame immediately wrapped around it.
   while (parent) {
     nsIScrollableFrame *scrollFrame = do_QueryFrame(parent);
     // scrollframe? Yep return it.
     if (scrollFrame)
       return parent;
 
     nsCOMPtr<nsIGridPart> parentGridRow = GetPartFromBox(parent);
     // if a part then just return the child
     if (parentGridRow) 
       break;
 
-    parent = nsBox::GetParentBox(parent);
+    parent = nsBox::GetParentXULBox(parent);
   }
 
   return aChild;
 }
 
 
 
 #ifdef DEBUG_grid
diff --git a/layout/xul/grid/nsGridRowLayout.cpp b/layout/xul/grid/nsGridRowLayout.cpp
--- a/layout/xul/grid/nsGridRowLayout.cpp
+++ b/layout/xul/grid/nsGridRowLayout.cpp
@@ -59,17 +59,17 @@ nsGridRowLayout::GetParentGridPart(nsIFr
   // parents.
   *aParentBox = nullptr;
   
   // walk up through any scrollboxes
   aBox = nsGrid::GetScrollBox(aBox);
 
   // get the parent
   if (aBox)
-    aBox = nsBox::GetParentBox(aBox);
+    aBox = nsBox::GetParentXULBox(aBox);
 
   if (aBox)
   {
     nsIGridPart* parentGridRow = nsGrid::GetPartFromBox(aBox);
     if (parentGridRow && parentGridRow->CanContain(this)) {
       *aParentBox = aBox;
       return parentGridRow;
     }
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -932,17 +932,17 @@ nsBox::GetChildXULBox(const nsIFrame* aF
 /*static*/ nsIFrame*
 nsBox::GetNextXULBox(const nsIFrame* aFrame)
 {
   return aFrame->GetParent() &&
     aFrame->GetParent()->IsXULBoxFrame() ? aFrame->GetNextSibling() : nullptr;
 }
 
 /*static*/ nsIFrame*
-nsBox::GetParentBox(const nsIFrame* aFrame)
+nsBox::GetParentXULBox(const nsIFrame* aFrame)
 {
   return aFrame->GetParent() &&
     aFrame->GetParent()->IsXULBoxFrame() ? aFrame->GetParent() : nullptr;
 }
 
 #ifdef DEBUG_LAYOUT
 nsresult
 nsBox::SetDebug(nsBoxLayoutState& aState, bool aDebug)
diff --git a/layout/xul/nsBox.h b/layout/xul/nsBox.h
--- a/layout/xul/nsBox.h
+++ b/layout/xul/nsBox.h
@@ -74,17 +74,17 @@ rollbox.
   static void AddMargin(nsSize& aSize, const nsMargin& aMargin);
 
   static nsSize BoundsCheckMinMax(const nsSize& aMinSize, const nsSize& aMaxSize);
   static nsSize BoundsCheck(const nsSize& aMinSize, const nsSize& aPrefSize, const nsSize& aMaxSize);
   static nscoord BoundsCheck(nscoord aMinSize, nscoord aPrefSize, nscoord aMaxSize);
 
   static nsIFrame* GetChildXULBox(const nsIFrame* aFrame);
   static nsIFrame* GetNextXULBox(const nsIFrame* aFrame);
-  static nsIFrame* GetParentBox(const nsIFrame* aFrame);
+  static nsIFrame* GetParentXULBox(const nsIFrame* aFrame);
 
 protected:
 
 #ifdef DEBUG_LAYOUT
   virtual void AppendAttribute(const nsAutoString& aAttribute, const nsAutoString& aValue, nsAutoString& aResult);
 
   virtual void ListBox(nsAutoString& aResult);
 #endif
diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -1223,17 +1223,17 @@ nsBoxFrame::AttributeChanged(int32_t aNa
     else if (aAttribute == nsGkAtoms::mousethrough) {
       UpdateMouseThrough();
     }
 
     PresContext()->PresShell()->
       FrameNeedsReflow(this, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
   }
   else if (aAttribute == nsGkAtoms::ordinal) {
-    nsIFrame* parent = GetParentBox(this);
+    nsIFrame* parent = GetParentXULBox(this);
     // If our parent is not a box, there's not much we can do... but in that
     // case our ordinal doesn't matter anyway, so that's ok.
     // Also don't bother with popup frames since they are kept on the 
     // kPopupList and RelayoutChildAtOrdinal() only handles
     // principal children.
     if (parent && !(GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
         StyleDisplay()->mDisplay != NS_STYLE_DISPLAY_POPUP) {
       parent->RelayoutChildAtOrdinal(this);
diff --git a/layout/xul/nsSplitterFrame.cpp b/layout/xul/nsSplitterFrame.cpp
--- a/layout/xul/nsSplitterFrame.cpp
+++ b/layout/xul/nsSplitterFrame.cpp
@@ -300,28 +300,28 @@ nsSplitterFrame::Init(nsIContent*       
   mInner->mParentBox = nullptr;
 }
 
 NS_IMETHODIMP
 nsSplitterFrame::DoLayout(nsBoxLayoutState& aState)
 {
   if (GetStateBits() & NS_FRAME_FIRST_REFLOW) 
   {
-    mInner->mParentBox = nsBox::GetParentBox(this);
+    mInner->mParentBox = nsBox::GetParentXULBox(this);
     mInner->UpdateState();
   }
 
   return nsBoxFrame::DoLayout(aState);
 }
 
 
 void
 nsSplitterFrame::GetInitialOrientation(bool& aIsHorizontal)
 {
-  nsIFrame* box = nsBox::GetParentBox(this);
+  nsIFrame* box = nsBox::GetParentXULBox(this);
   if (box) {
     aIsHorizontal = !box->IsHorizontal();
   }
   else
     nsBoxFrame::GetInitialOrientation(aIsHorizontal);
 }
 
 NS_IMETHODIMP
@@ -612,17 +612,17 @@ nsSplitterFrameInner::MouseDown(nsIDOMEv
   if (button != 0)
      return NS_OK;
 
   if (mOuter->GetContent()->
         AttrValueIs(kNameSpaceID_None, nsGkAtoms::disabled,
                     nsGkAtoms::_true, eCaseMatters))
     return NS_OK;
 
-  mParentBox = nsBox::GetParentBox(mOuter);
+  mParentBox = nsBox::GetParentXULBox(mOuter);
   if (!mParentBox)
     return NS_OK;
 
   // get our index
   nsPresContext* outerPresContext = mOuter->PresContext();
   const nsFrameList& siblingList(mParentBox->PrincipalChildList());
   int32_t childIndex = siblingList.IndexOf(mOuter);
   // if it's 0 (or not found) then stop right here.
