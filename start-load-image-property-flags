From: L. David Baron <dbaron@dbaron.org>

Use property flags for which properties need StartLoadImage called.

diff --git a/layout/style/nsCSSDataBlock.cpp b/layout/style/nsCSSDataBlock.cpp
--- a/layout/style/nsCSSDataBlock.cpp
+++ b/layout/style/nsCSSDataBlock.cpp
@@ -170,31 +170,44 @@ ShouldIgnoreColors(nsRuleData *aRuleData
            !aRuleData->mPresContext->UseDocumentColors();
 }
 
 /**
  * Tries to call |nsCSSValue::StartImageLoad()| on an image source.
  * Image sources are specified by |url()| or |-moz-image-rect()| function.
  */
 static void
-TryToStartImageLoad(const nsCSSValue& aValue, nsIDocument* aDocument)
+TryToStartImageLoadOnValue(const nsCSSValue& aValue, nsIDocument* aDocument)
 {
   if (aValue.GetUnit() == eCSSUnit_URL) {
     aValue.StartImageLoad(aDocument);
   }
   else if (aValue.EqualsFunction(eCSSKeyword__moz_image_rect)) {
     nsCSSValue::Array* arguments = aValue.GetArrayValue();
     NS_ABORT_IF_FALSE(arguments->Count() == 6, "unexpected num of arguments");
 
     const nsCSSValue& image = arguments->Item(1);
     if (image.GetUnit() == eCSSUnit_URL)
       image.StartImageLoad(aDocument);
   }
 }
 
+static void
+TryToStartImageLoad(const nsCSSValue& aValue, nsIDocument* aDocument,
+                    PRBool aImageInArrayValue)
+{
+  if (aImageInArrayValue) {
+    if (aValue.GetUnit() == eCSSUnit_Array) {
+      TryToStartImageLoadOnValue(aValue.GetArrayValue()->Item(0), aDocument);
+    }
+  } else {
+    TryToStartImageLoadOnValue(aValue, aDocument);
+  }
+}
+
 nsresult
 nsCSSCompressedDataBlock::MapRuleInfoInto(nsRuleData *aRuleData) const
 {
     // If we have no data for these structs, then return immediately.
     // This optimization should make us return most of the time, so we
     // have to worry much less (although still some) about the speed of
     // the rest of the function.
     if (!(aRuleData->mSIDs & mStyleBits))
@@ -213,24 +226,22 @@ nsCSSCompressedDataBlock::MapRuleInfoInt
             void *prop =
                 nsCSSExpandedDataBlock::RuleDataPropertyAt(aRuleData, iProp);
             switch (nsCSSProps::kTypeTable[iProp]) {
                 case eCSSType_Value: {
                     nsCSSValue* target = static_cast<nsCSSValue*>(prop);
                     if (target->GetUnit() == eCSSUnit_Null) {
                         const nsCSSValue *val = ValueAtCursor(cursor);
                         NS_ASSERTION(val->GetUnit() != eCSSUnit_Null, "oops");
-                        if (iProp == eCSSProperty_list_style_image) {
-                            TryToStartImageLoad(*val, doc);
-                        } else if (iProp == eCSSProperty_border_image) {
-                            if (val->GetUnit() == eCSSUnit_Array) {
-                                const nsCSSValue& image
-                                    = val->GetArrayValue()->Item(0);
-                                TryToStartImageLoad(image, doc);
-                            }
+                        if (nsCSSProps::PropHasFlags(iProp,
+                                CSS_PROPERTY_START_IMAGE_LOADS)) {
+                            PRBool inArray =
+                                nsCSSProps::PropHasFlags(iProp,
+                                    CSS_PROPERTY_IMAGE_IS_IN_ARRAY_0);
+                            TryToStartImageLoad(*val, doc, inArray);
                         }
                         *target = *val;
                         if (iProp == eCSSProperty_font_family) {
                             // XXX Are there other things like this?
                             aRuleData->mFontData->mFamilyFromHTML = PR_FALSE;
                         }
                         if (nsCSSProps::PropHasFlags(iProp,
                                 CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED) &&
@@ -288,30 +299,24 @@ nsCSSCompressedDataBlock::MapRuleInfoInt
                     }
                     cursor += CDBValuePairStorage_advance;
                 } break;
 
                 case eCSSType_ValueList:
                 case eCSSType_ValuePairList: {
                     void** target = static_cast<void**>(prop);
                     if (!*target) {
-                        if (iProp == eCSSProperty_background_image ||
-                            iProp == eCSSProperty_content) {
+                        if (nsCSSProps::PropHasFlags(iProp,
+                                CSS_PROPERTY_START_IMAGE_LOADS)) {
+                            PRBool inArray =
+                                nsCSSProps::PropHasFlags(iProp,
+                                    CSS_PROPERTY_IMAGE_IS_IN_ARRAY_0);
                             for (nsCSSValueList* l = ValueListAtCursor(cursor);
                                  l; l = l->mNext) {
-                                TryToStartImageLoad(l->mValue, doc);
-                            }
-                        } else if (iProp == eCSSProperty_cursor) {
-                            for (nsCSSValueList* l = ValueListAtCursor(cursor);
-                                 l; l = l->mNext) {
-                                if (l->mValue.GetUnit() == eCSSUnit_Array) {
-                                    const nsCSSValue& image =
-                                        l->mValue.GetArrayValue()->Item(0);
-                                    TryToStartImageLoad(image, doc);
-                                }
+                                TryToStartImageLoad(l->mValue, doc, inArray);
                             }
                         }
 
                         void* val = PointerAtCursor(cursor);
                         NS_ASSERTION(val, "oops");
                         *target = val;
 
                         if (nsCSSProps::PropHasFlags(iProp,
diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -474,17 +474,18 @@ CSS_PROP_BACKGROUND(
     offsetof(nsStyleBackground, mBackgroundColor),
     eStyleAnimType_Color)
 CSS_PROP_BACKGROUND(
     background-image,
     background_image,
     BackgroundImage,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS |
-        CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
+        CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED |
+        CSS_PROPERTY_START_IMAGE_LOADS,
     Color,
     mBackImage,
     eCSSType_ValueList,
     nsnull,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BACKGROUND(
     -moz-background-inline-policy,
@@ -686,17 +687,19 @@ CSS_PROP_BORDER(
     kBorderWidthKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 #endif
 CSS_PROP_BORDER(
     -moz-border-image,
     border_image,
     MozBorderImage,
-    CSS_PROPERTY_APPLIES_TO_FIRST_LETTER,
+    CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
+        CSS_PROPERTY_START_IMAGE_LOADS |
+        CSS_PROPERTY_IMAGE_IS_IN_ARRAY_0,
     Margin,
     mBorderImage,
     eCSSType_Value,
     kBorderImageKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_SHORTHAND(
     border-left,
@@ -1282,17 +1285,17 @@ CSS_PROP_COLUMN(
     eCSSType_Value,
     kBorderWidthKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_Custom)
 CSS_PROP_CONTENT(
     content,
     content,
     Content,
-    0,
+    CSS_PROPERTY_START_IMAGE_LOADS,
     Content,
     mContent,
     eCSSType_ValueList,
     kContentKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_CONTENT(
     counter-increment,
@@ -1338,17 +1341,19 @@ CSS_PROP_BACKENDONLY(
     Aural,
     mCueBefore,
     eCSSType_Value,
     nsnull)
 CSS_PROP_USERINTERFACE(
     cursor,
     cursor,
     Cursor,
-    CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
+    CSS_PROPERTY_VALUE_LIST_USES_COMMAS |
+        CSS_PROPERTY_START_IMAGE_LOADS |
+        CSS_PROPERTY_IMAGE_IS_IN_ARRAY_0,
     UserInterface,
     mCursor,
     eCSSType_ValueList,
     kCursorKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_VISIBILITY(
     direction,
@@ -1579,17 +1584,17 @@ CSS_PROP_SHORTHAND(
     list-style,
     list_style,
     ListStyle,
     0)
 CSS_PROP_LIST(
     list-style-image,
     list_style_image,
     ListStyleImage,
-    0,
+    CSS_PROPERTY_START_IMAGE_LOADS,
     List,
     mImage,
     eCSSType_Value,
     nsnull,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_LIST(
     list-style-position,
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -51,25 +51,39 @@
 #include "nsStyleStruct.h"
 #include "nsCSSKeywords.h"
 
 // Flags for the kFlagsTable bitfield (flags_ in nsCSSPropList.h)
 
 // A property that is a *-ltr-source or *-rtl-source property for one of
 // the directional pseudo-shorthand properties.
 #define CSS_PROPERTY_DIRECTIONAL_SOURCE           (1<<0)
+
 #define CSS_PROPERTY_VALUE_LIST_USES_COMMAS       (1<<1) /* otherwise spaces */
+
 #define CSS_PROPERTY_APPLIES_TO_FIRST_LETTER      (1<<2)
 #define CSS_PROPERTY_APPLIES_TO_FIRST_LINE        (1<<3)
 #define CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE \
   (CSS_PROPERTY_APPLIES_TO_FIRST_LETTER | CSS_PROPERTY_APPLIES_TO_FIRST_LINE)
+
 // Note that 'background-color' is ignored differently from the other
 // properties that have this set, but that's just special-cased.
 #define CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED (1<<4)
 
+// A property that needs to have image loads started when a URL value
+// for the property is used for an element.  Supported only for
+// eCSSType_Value and eCSSType_ValueList.
+#define CSS_PROPERTY_START_IMAGE_LOADS            (1<<5)
+
+// Should be set only for properties with START_IMAGE_LOADS.  Indicates
+// that the property has an array value with a URL/image value at index
+// 0 in the array, rather than the URL/image being in the value or value
+// list.
+#define CSS_PROPERTY_IMAGE_IS_IN_ARRAY_0          (1<<6)
+
 /**
  * Types of animatable values.
  */
 enum nsStyleAnimType {
   // requires a custom implementation in
   // nsStyleAnimation::ExtractComputedValue
   eStyleAnimType_Custom,
 
