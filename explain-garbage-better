In ExplainLiveExpectedGarbage, print only the externally-referenced nodes from which the expected garbage is reachable.

diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -415,6 +415,15 @@ public:
 
 };
 
+#ifdef DEBUG_CC
+
+struct ReversedEdge {
+    PtrInfo *mTarget;
+    ReversedEdge *mNext;
+};
+
+#endif
+
 
 enum NodeColor { black, white, grey };
 
@@ -436,7 +445,14 @@ struct PtrInfo
 #ifdef DEBUG_CC
     size_t mBytes;
     char *mName;
+
+    // For finding roots in ExplainLiveExpectedGarbage (when there are
+    // missing calls to suspect or failures to unlink).
     PRUint32 mSCCIndex; // strongly connected component
+
+    // For finding roots in ExplainLiveExpectedGarbage (when nodes
+    // expected to be garbage are black).
+    ReversedEdge* mReversedEdges; // linked list
 #endif
 
     PtrInfo(void *aPointer, nsCycleCollectionParticipant *aParticipant)
@@ -451,7 +467,8 @@ struct PtrInfo
 #ifdef DEBUG_CC
         , mBytes(0),
           mName(nsnull),
-          mSCCIndex(0)
+          mSCCIndex(0),
+          mReversedEdges(nsnull)
 #endif
     {
     }
@@ -582,6 +599,9 @@ struct GCGraph
     NodePool mNodes;
     EdgePool mEdges;
     PRUint32 mRootCount;
+#ifdef DEBUG_CC
+    ReversedEdge *mReversedEdges;
+#endif
 
     GCGraph() : mRootCount(0) {
         sCurrGraph = this;
@@ -848,7 +868,10 @@ struct nsCycleCollector
     FILE *mPtrLog;
 
     void MaybeDrawGraphs(GCGraph &graph);
+
     void ExplainLiveExpectedGarbage();
+    PRBool CreateReversedEdges(GCGraph &graph);
+    void DestroyReversedEdges(GCGraph &graph);
     void ShouldBeFreed(nsISupports *n);
     void WasFreed(nsISupports *n);
     PointerSet mExpectedGarbage;
@@ -2342,6 +2365,53 @@ nsCycleCollector::ExplainLiveExpectedGar
     }    
 }
 
+PRBool
+nsCycleCollector::CreateReversedEdges(GCGraph &graph)
+{
+    // Count the edges in the graph.
+    PRUint32 edgeCount = 0;
+    NodePool::Enumerator countQueue(graph.mNodes);
+    while (!countQueue.IsDone()) {
+        PtrInfo *pi = countQueue.GetNext();
+        for (EdgePool::Iterator e = pi->mFirstChild, e_end = pi->mLastChild;
+             e != e_end; ++e, ++edgeCount) {
+        }
+    }
+
+    // Allocate a pool to hold all of the edges.
+    graph.mReversedEdges = new ReversedEdge[edgeCount];
+    if (graph.mReversedEdges == nsnull)
+        return PR_FALSE;
+
+    // Fill in the reversed edges by scanning all forward edges.
+    ReversedEdge *current = graph.mReversedEdges;
+    NodePool::Enumerator buildQueue(graph.mNodes);
+    while (!buildQueue.IsDone()) {
+        PtrInfo *pi = buildQueue.GetNext();
+        for (EdgePool::Iterator e = pi->mFirstChild, e_end = pi->mLastChild;
+             e != e_end; ++e) {
+            current->mNode = pi;
+            current->mNext = (*e)->mReversedEdges;
+            (*e)->mReversedEdges = current;
+            ++current;
+        }
+    }
+    NS_ASSERTION(current - graph.mReversedEdges == edgeCount, "misallocation");
+}
+
+void
+nsCycleCollector::DestroyReversedEdges(GCGraph &graph)
+{
+    NodePool::Enumerator queue(graph.mNodes);
+    while (!queue.IsDone()) {
+        PtrInfo *pi = queue.GetNext();
+        pi->mReversedEdges = nsnull;
+    }
+
+    delete graph.mReversedEdges;
+    graph.mReversedEdges = nsnull;
+}
+
 void
 nsCycleCollector::ShouldBeFreed(nsISupports *n)
 {
