From: L. David Baron <dbaron@dbaron.org>

Clip contents of elements with overflow != visible to the border radius.  (Bug 459144)

diff --git a/layout/forms/nsFileControlFrame.cpp b/layout/forms/nsFileControlFrame.cpp
--- a/layout/forms/nsFileControlFrame.cpp
+++ b/layout/forms/nsFileControlFrame.cpp
@@ -673,17 +673,18 @@ nsFileControlFrame::BuildDisplayList(nsD
   if (NS_FAILED(rv))
     return rv;
 
   tempList.BorderBackground()->DeleteAll();
 
   // Clip height only
   nsRect clipRect(aBuilder->ToReferenceFrame(this), GetSize());
   clipRect.width = GetOverflowRect().XMost();
-  rv = OverflowClip(aBuilder, tempList, aLists, clipRect);
+  nscoord radii[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+  rv = OverflowClip(aBuilder, tempList, aLists, clipRect, radii);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Disabled file controls don't pass mouse events to their children, so we
   // put an invisible item in the display list above the children
   // just to catch events
   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::disabled) && 
       IsVisibleForPainting(aBuilder)) {
     rv = aLists.Content()->AppendNewToTop(
diff --git a/layout/forms/nsHTMLButtonControlFrame.cpp b/layout/forms/nsHTMLButtonControlFrame.cpp
--- a/layout/forms/nsHTMLButtonControlFrame.cpp
+++ b/layout/forms/nsHTMLButtonControlFrame.cpp
@@ -177,18 +177,20 @@ nsHTMLButtonControlFrame::BuildDisplayLi
   set.Content()->AppendToTop(&onTop);
 
   // clips to our padding box for <input>s but not <button>s, unless
   // they have non-visible overflow..
   if (IsInput() || GetStyleDisplay()->mOverflowX != NS_STYLE_OVERFLOW_VISIBLE) {
     nsMargin border = GetStyleBorder()->GetActualBorder();
     nsRect rect(aBuilder->ToReferenceFrame(this), GetSize());
     rect.Deflate(border);
-  
-    nsresult rv = OverflowClip(aBuilder, set, aLists, rect);
+    nscoord radii[8];
+    GetPaddingBoxBorderRadii(radii);
+
+    nsresult rv = OverflowClip(aBuilder, set, aLists, rect, radii);
     NS_ENSURE_SUCCESS(rv, rv);
   } else {
     set.MoveTo(aLists);
   }
   
   nsresult rv = DisplayOutline(aBuilder, aLists);
   NS_ENSURE_SUCCESS(rv, rv);
 
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -1249,39 +1249,62 @@ public:
   /**
    * Create a wrapper to apply overflow clipping for aContainer.
    * @param aClipBorderBackground set to PR_TRUE to clip the BorderBackground()
    * list, otherwise it will not be clipped
    * @param aClipAll set to PR_TRUE to clip all descendants, even those for
    * which we aren't the containing block
    */
   nsOverflowClipWrapper(nsIFrame* aContainer, const nsRect& aRect,
+                        const nscoord aRadii[8],
                         PRBool aClipBorderBackground, PRBool aClipAll)
     : mContainer(aContainer), mRect(aRect),
-      mClipBorderBackground(aClipBorderBackground), mClipAll(aClipAll) {}
+      mClipBorderBackground(aClipBorderBackground), mClipAll(aClipAll),
+      mHaveRadius(PR_FALSE)
+  {
+    memcpy(mRadii, aRadii, sizeof(mRadii));
+    NS_FOR_CSS_HALF_CORNERS(corner) {
+      if (aRadii[corner] > 0) {
+        mHaveRadius = PR_TRUE;
+        break;
+      }
+    }
+  }
   virtual PRBool WrapBorderBackground() { return mClipBorderBackground; }
   virtual nsDisplayItem* WrapList(nsDisplayListBuilder* aBuilder,
                                   nsIFrame* aFrame, nsDisplayList* aList) {
     // We are not a stacking context root. There is no valid underlying
     // frame for the whole list. These items are all in-flow descendants so
     // we can safely just clip them.
+    if (mHaveRadius) {
+      return new (aBuilder) nsDisplayClipBorderRadius(aBuilder, nsnull, aList,
+        mRect, mRadii, mContainer->PresContext()->AppUnitsPerDevPixel());
+    }
     return new (aBuilder) nsDisplayClip(aBuilder, nsnull, aList, mRect);
   }
   virtual nsDisplayItem* WrapItem(nsDisplayListBuilder* aBuilder,
                                   nsDisplayItem* aItem) {
     nsIFrame* f = aItem->GetUnderlyingFrame();
-    if (mClipAll || nsLayoutUtils::IsProperAncestorFrame(mContainer, f, nsnull))
+    if (mClipAll ||
+        nsLayoutUtils::IsProperAncestorFrame(mContainer, f, nsnull)) {
+      if (mHaveRadius) {
+        return new (aBuilder) nsDisplayClipBorderRadius(aBuilder, f, aItem,
+          mRect, mRadii, mContainer->PresContext()->AppUnitsPerDevPixel());
+      }
       return new (aBuilder) nsDisplayClip(aBuilder, f, aItem, mRect);
+    }
     return aItem;
   }
 protected:
   nsIFrame*    mContainer;
   nsRect       mRect;
+  nscoord      mRadii[8];
   PRPackedBool mClipBorderBackground;
   PRPackedBool mClipAll;
+  PRPackedBool mHaveRadius;
 };
 
 class nsAbsPosClipWrapper : public nsDisplayWrapper
 {
 public:
   nsAbsPosClipWrapper(const nsRect& aRect)
     : mRect(aRect) {}
   virtual nsDisplayItem* WrapList(nsDisplayListBuilder* aBuilder,
@@ -1320,49 +1343,51 @@ protected:
   PRUint8 mColorCorrection;
 };
 
 nsresult
 nsIFrame::OverflowClip(nsDisplayListBuilder*   aBuilder,
                        const nsDisplayListSet& aFromSet,
                        const nsDisplayListSet& aToSet,
                        const nsRect&           aClipRect,
+                       const nscoord           aClipRadii[8],
                        PRBool                  aClipBorderBackground,
                        PRBool                  aClipAll)
 {
-  nsOverflowClipWrapper wrapper(this, aClipRect, aClipBorderBackground, aClipAll);
+  nsOverflowClipWrapper wrapper(this, aClipRect, aClipRadii,
+                                aClipBorderBackground, aClipAll);
   return wrapper.WrapLists(aBuilder, this, aFromSet, aToSet);
 }
 
 static nsresult
 BuildDisplayListWithWrappers(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
     const nsRect& aDirtyRect, const nsDisplayListSet& aSet,
-    const nsRect& aClipRect, PRBool aApplyOverflowClip,
-    PRBool aChangeColorCorrection)
+    const nsRect& aClipRect, const nscoord aClipRadii[8],
+    PRBool aApplyOverflowClip, PRBool aChangeColorCorrection)
 {
   NS_PRECONDITION(aApplyOverflowClip || aChangeColorCorrection,
                   "shouldn't have been called");
   nsDisplayListCollection set;
   nsresult rv = aFrame->BuildDisplayList(aBuilder, aDirtyRect, set);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = aBuilder->DisplayCaret(aFrame, aDirtyRect, aSet.Content());
   NS_ENSURE_SUCCESS(rv, rv);
 
   // REVIEW: Are there any other callers (e.g., other callers of
   // nsIFrame::OverflowClip()) that need to do this wrapping for
   // color-correction?
   if (aApplyOverflowClip && aChangeColorCorrection) {
     nsDisplayListCollection set2;
-    rv = aFrame->OverflowClip(aBuilder, set, set2, aClipRect);
+    rv = aFrame->OverflowClip(aBuilder, set, set2, aClipRect, aClipRadii);
     NS_ENSURE_SUCCESS(rv, rv);
     nsChangeColorCorrectionWrapper
       ccWrap(aFrame->GetStyleVisibility()->mColorCorrection);
     rv = ccWrap.WrapLists(aBuilder, aFrame, set2, aSet);
   } else if (aApplyOverflowClip) {
-    rv = aFrame->OverflowClip(aBuilder, set, aSet, aClipRect);
+    rv = aFrame->OverflowClip(aBuilder, set, aSet, aClipRect, aClipRadii);
   } else {
     NS_ASSERTION(aChangeColorCorrection, "unexpected");
     nsChangeColorCorrectionWrapper
       ccWrap(aFrame->GetStyleVisibility()->mColorCorrection);
     rv = ccWrap.WrapLists(aBuilder, aFrame, set, aSet);
   }
   
   return rv;
@@ -1476,17 +1501,20 @@ nsIFrame::BuildDisplayListForStackingCon
   // in the sort. Consider a position:relative inline element that breaks
   // across lines and has absolutely positioned children; all the abs-pos
   // children should be z-ordered after all the boxes for the position:relative
   // element itself.
   set.PositionedDescendants()->SortByZOrder(aBuilder, GetContent());
   
   nsRect overflowClip;
   if (ApplyOverflowClipping(aBuilder, this, disp, &overflowClip)) {
-    nsOverflowClipWrapper wrapper(this, overflowClip, PR_FALSE, PR_FALSE);
+    nscoord radii[8];
+    this->GetPaddingBoxBorderRadii(radii);
+    nsOverflowClipWrapper wrapper(this, overflowClip, radii,
+                                  PR_FALSE, PR_FALSE);
     rv = wrapper.WrapListsInPlace(aBuilder, this, set);
     NS_ENSURE_SUCCESS(rv, rv);
   }
   // We didn't use overflowClip to restrict the dirty rect, since some of the
   // descendants may not be clipped by it. Even if we end up with unnecessary
   // display items, they'll be pruned during ComputeVisibility.  
 
   nsDisplayList resultList;
@@ -1677,18 +1705,22 @@ nsIFrame::BuildDisplayListForChild(nsDis
   PRBool isPositioned = disp->IsPositioned();
   if (isComposited || isPositioned || disp->IsFloating() ||
       (aFlags & DISPLAY_CHILD_FORCE_STACKING_CONTEXT)) {
     // If you change this, also change IsPseudoStackingContextFromStyle()
     pseudoStackingContext = PR_TRUE;
   }
   
   nsRect overflowClip;
+  nscoord overflowClipRadii[8];
   PRBool applyOverflowClip =
     ApplyOverflowClipping(aBuilder, aChild, disp, &overflowClip);
+  if (applyOverflowClip) {
+    aChild->GetPaddingBoxBorderRadii(overflowClipRadii);
+  }
   PRBool changeColorCorrection =
     aChild->GetStyleVisibility()->mColorCorrection != 
     GetStyleVisibility()->mColorCorrection;
   // Don't use overflowClip to restrict the dirty rect, since some of the
   // descendants may not be clipped by it. Even if we end up with unnecessary
   // display items, they'll be pruned during ComputeVisibility. Note that
   // this overflow-clipping here only applies to overflow:-moz-hidden-unscrollable;
   // overflow:hidden etc creates an nsHTML/XULScrollFrame which does its own
@@ -1697,17 +1729,18 @@ nsIFrame::BuildDisplayListForChild(nsDis
   nsDisplayListBuilder::AutoIsRootSetter rootSetter(aBuilder, pseudoStackingContext);
   nsresult rv;
   if (!pseudoStackingContext) {
     // THIS IS THE COMMON CASE.
     // Not a pseudo or real stacking context. Do the simple thing and
     // return early.
     if (applyOverflowClip || changeColorCorrection) {
       rv = BuildDisplayListWithWrappers(aBuilder, aChild, dirty, aLists,
-                                        overflowClip, applyOverflowClip,
+                                        overflowClip, overflowClipRadii,
+                                        applyOverflowClip,
                                         changeColorCorrection);
     } else {
       rv = aChild->BuildDisplayList(aBuilder, dirty, aLists);
       if (NS_SUCCEEDED(rv)) {
         rv = aBuilder->DisplayCaret(aChild, dirty, aLists.Content());
       }
     }
 #ifdef NS_DEBUG
@@ -1741,16 +1774,17 @@ nsIFrame::BuildDisplayListForChild(nsDis
       // dirty/clippedDirtyRect are in aChild coordinates
       clippedDirtyRect.IntersectRect(clippedDirtyRect,
                                      clipRect - aBuilder->ToReferenceFrame(aChild));
     }
     
     if (applyOverflowClip || changeColorCorrection) {
       rv = BuildDisplayListWithWrappers(aBuilder, aChild, clippedDirtyRect,
                                         pseudoStack, overflowClip,
+                                        overflowClipRadii,
                                         applyOverflowClip,
                                         changeColorCorrection);
     } else {
       rv = aChild->BuildDisplayList(aBuilder, clippedDirtyRect, pseudoStack);
       if (NS_SUCCEEDED(rv)) {
         rv = aBuilder->DisplayCaret(aChild, dirty, pseudoStack.Content());
       }
     }
diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -1803,22 +1803,27 @@ nsGfxScrollFrameInner::BuildDisplayList(
   // MarkOutOfFlowChildrenForDisplayList, so it's safe to restrict our
   // dirty rect here.
   dirtyRect.IntersectRect(aDirtyRect, mScrollPort);
   
   nsDisplayListCollection set;
   rv = mOuter->BuildDisplayListForChild(aBuilder, mScrolledFrame, dirtyRect, set);
   NS_ENSURE_SUCCESS(rv, rv);
   nsRect clip = mScrollPort + aBuilder->ToReferenceFrame(mOuter);
+  nscoord radii[8];
+  // Our override of GetBorderRadii ensures we never have a radius at
+  // the corners where we have a scrollbar.
+  mOuter->GetPaddingBoxBorderRadii(radii);
   // mScrolledFrame may have given us a background, e.g., the scrolled canvas
   // frame below the viewport. If so, we want it to be clipped. We also want
   // to end up on our BorderBackground list.
   // If we are the viewport scrollframe, then clip all our descendants (to ensure
   // that fixed-pos elements get clipped by us).
-  rv = mOuter->OverflowClip(aBuilder, set, aLists, clip, PR_TRUE, mIsRoot);
+  rv = mOuter->OverflowClip(aBuilder, set, aLists, clip, radii,
+                            PR_TRUE, mIsRoot);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Place the resizer in the display list in our Content() list above
   // scrolled content in the Content() list.
   // This ensures that the resizer appears above the content and the mouse can
   // still target the resizer even when scrollbars are hidden.
   if (hasResizer && mScrollCornerBox) {
     rv = mOuter->BuildDisplayListForChild(aBuilder, mScrollCornerBox, aDirtyRect, scrollParts,
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -1084,21 +1084,24 @@ public:
   /**
    * Clips the display items of aFromSet, putting the results in aToSet.
    * Only items corresponding to frames which are descendants of this frame
    * are clipped. In other words, descendant elements whose CSS boxes do not
    * have this frame as a container are not clipped. Also,
    * border/background/outline items for this frame are not clipped,
    * unless aClipBorderBackground is set to PR_TRUE. (We need this because
    * a scrollframe must overflow-clip its scrolled child's background/borders.)
+   *
+   * Indices into aClipRadii are the NS_CORNER_* constants in nsStyleConsts.h
    */
   nsresult OverflowClip(nsDisplayListBuilder*   aBuilder,
                         const nsDisplayListSet& aFromSet,
                         const nsDisplayListSet& aToSet,
                         const nsRect&           aClipRect,
+                        const nscoord           aClipRadii[8],
                         PRBool                  aClipBorderBackground = PR_FALSE,
                         PRBool                  aClipAll = PR_FALSE);
 
   enum {
     DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT = 0x01,
     DISPLAY_CHILD_FORCE_STACKING_CONTEXT = 0x02,
     DISPLAY_CHILD_INLINE = 0x04
   };
