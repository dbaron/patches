From: L. David Baron <dbaron@dbaron.org>

Bug 1055865 patch 3 - Fork a bit of code between the floating and non-floating branches in nsFirstLetterFrame::Reflow.

This patch makes no changes other than duplicating the code previously
after the if/else on both branches of the if/else.

The next two patches in this series will completely rewrite the half in
the non-floating (i.e., inline) codepath (the else branch).

diff --git a/layout/generic/nsFirstLetterFrame.cpp b/layout/generic/nsFirstLetterFrame.cpp
--- a/layout/generic/nsFirstLetterFrame.cpp
+++ b/layout/generic/nsFirstLetterFrame.cpp
@@ -209,44 +209,57 @@ nsFirstLetterFrame::Reflow(nsPresContext
     kid->Reflow(aPresContext, kidMetrics, rs, aReflowStatus);
 
     ll.EndLineReflow();
     ll.SetInFirstLetter(false);
 
     // In the floating first-letter case, we need to set this ourselves;
     // nsLineLayout::BeginSpan will set it in the other case
     mBaseline = kidMetrics.BlockStartAscent();
+
+    // Place and size the child and update the output metrics
+    LogicalSize convertedSize = kidMetrics.Size(lineWM).ConvertTo(wm, lineWM);
+    kid->SetRect(nsRect(bp.IStart(wm), bp.BStart(wm),
+                        convertedSize.ISize(wm), convertedSize.BSize(wm)));
+    kid->FinishAndStoreOverflow(&kidMetrics);
+    kid->DidReflow(aPresContext, nullptr, nsDidReflowStatus::FINISHED);
+
+    convertedSize.ISize(wm) += bp.IStartEnd(wm);
+    convertedSize.BSize(wm) += bp.BStartEnd(wm);
+    aMetrics.SetSize(wm, convertedSize);
+    aMetrics.SetBlockStartAscent(kidMetrics.BlockStartAscent() +
+                                 bp.BStart(wm));
   }
   else {
     // Pretend we are a span and reflow the child frame
     nsLineLayout* ll = aReflowState.mLineLayout;
     bool          pushedFrame;
 
     ll->SetInFirstLetter(
       mStyleContext->GetPseudo() == nsCSSPseudoElements::firstLetter);
     ll->BeginSpan(this, &aReflowState, bp.IStart(wm),
                   availSize.ISize(wm), &mBaseline);
     ll->ReflowFrame(kid, aReflowStatus, &kidMetrics, pushedFrame);
     ll->EndSpan(this);
     ll->SetInFirstLetter(false);
+
+    // Place and size the child and update the output metrics
+    LogicalSize convertedSize = kidMetrics.Size(lineWM).ConvertTo(wm, lineWM);
+    kid->SetRect(nsRect(bp.IStart(wm), bp.BStart(wm),
+                        convertedSize.ISize(wm), convertedSize.BSize(wm)));
+    kid->FinishAndStoreOverflow(&kidMetrics);
+    kid->DidReflow(aPresContext, nullptr, nsDidReflowStatus::FINISHED);
+
+    convertedSize.ISize(wm) += bp.IStartEnd(wm);
+    convertedSize.BSize(wm) += bp.BStartEnd(wm);
+    aMetrics.SetSize(wm, convertedSize);
+    aMetrics.SetBlockStartAscent(kidMetrics.BlockStartAscent() +
+                                 bp.BStart(wm));
   }
 
-  // Place and size the child and update the output metrics
-  LogicalSize convertedSize = kidMetrics.Size(lineWM).ConvertTo(wm, lineWM);
-  kid->SetRect(nsRect(bp.IStart(wm), bp.BStart(wm),
-                      convertedSize.ISize(wm), convertedSize.BSize(wm)));
-  kid->FinishAndStoreOverflow(&kidMetrics);
-  kid->DidReflow(aPresContext, nullptr, nsDidReflowStatus::FINISHED);
-
-  convertedSize.ISize(wm) += bp.IStartEnd(wm);
-  convertedSize.BSize(wm) += bp.BStartEnd(wm);
-  aMetrics.SetSize(wm, convertedSize);
-  aMetrics.SetBlockStartAscent(kidMetrics.BlockStartAscent() +
-                               bp.BStart(wm));
-
   // Ensure that the overflow rect contains the child textframe's overflow rect.
   // Note that if this is floating, the overline/underline drawable area is in
   // the overflow rect of the child textframe.
   aMetrics.UnionOverflowAreasWithDesiredBounds();
   ConsiderChildOverflow(aMetrics.mOverflowAreas, kid);
 
   if (!NS_INLINE_IS_BREAK_BEFORE(aReflowStatus)) {
     // Create a continuation or remove existing continuations based on
