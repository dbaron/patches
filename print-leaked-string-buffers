From: L. David Baron <dbaron@dbaron.org>

Debugging patch to print out contents of leaked string buffers.

No longer compiles now that the MT hash table variants were removed.

diff --git a/xpcom/string/src/nsSubstring.cpp b/xpcom/string/src/nsSubstring.cpp
--- a/xpcom/string/src/nsSubstring.cpp
+++ b/xpcom/string/src/nsSubstring.cpp
@@ -18,16 +18,18 @@
 #include <stdlib.h>
 #include "nsSubstring.h"
 #include "nsString.h"
 #include "nsStringBuffer.h"
 #include "nsDependentString.h"
 #include "nsMemory.h"
 #include "prprf.h"
 #include "nsStaticAtom.h"
+#include "nsHashSet.h"
+#include "nsHashKeys.h"
 #include "nsCOMPtr.h"
 
 #include "mozilla/IntegerPrintfMacros.h"
 #ifdef XP_WIN
 #include <windows.h>
 #include <process.h>
 #define getpid() _getpid()
 #define pthread_self() GetCurrentThreadId()
@@ -43,21 +45,42 @@ using mozilla::Atomic;
 static char16_t gNullChar = 0;
 
 char*      nsCharTraits<char>     ::sEmptyBuffer = (char*) &gNullChar;
 char16_t* nsCharTraits<char16_t>::sEmptyBuffer =         &gNullChar;
 
 // ---------------------------------------------------------------------------
 
 #ifdef ENABLE_STRING_STATS
+
+static PLDHashOperator
+PrintLeakedString(nsStringBuffer* aBuffer, void* userArg)
+{
+  uint32_t size = aBuffer->StorageSize();
+  const char *data = static_cast<char*>(aBuffer->Data());
+  printf("Leaked string aBuffer %p, storage size %u:\n",
+         static_cast<void*>(aBuffer), size);
+  for (uint32_t i = 0; i < size; ++i) {
+    printf("  string[%u] = 0x%02X", i, unsigned(data[i]));
+    if (' ' <= data[i] && data[i] <= '~') {
+      printf(" (%c)", data[i]);
+    }
+    printf("\n");
+  }
+  return PL_DHASH_NEXT;
+}
+
 class nsStringStats
   {
     public:
       nsStringStats()
-        : mAllocCount(0), mReallocCount(0), mFreeCount(0), mShareCount(0) {}
+        : mAllocCount(0), mReallocCount(0), mFreeCount(0), mShareCount(0)
+      {
+        mLiveStringBuffers.Init(1024);
+      }
 
       ~nsStringStats()
         {
           // this is a hack to suppress duplicate string stats printing
           // in seamonkey as a result of the string code being linked
           // into seamonkey and libxpcom! :-(
           if (!mAllocCount && !mAdoptCount)
             return;
@@ -65,16 +88,17 @@ class nsStringStats
           printf("nsStringStats\n");
           printf(" => mAllocCount:     % 10d\n", int(mAllocCount));
           printf(" => mReallocCount:   % 10d\n", int(mReallocCount));
           printf(" => mFreeCount:      % 10d", int(mFreeCount));
           if (mAllocCount > mFreeCount)
             printf("  --  LEAKED %d !!!\n", mAllocCount - mFreeCount);
           else
             printf("\n");
+          mLiveStringBuffers.EnumerateRead(PrintLeakedString, nullptr);
           printf(" => mShareCount:     % 10d\n", int(mShareCount));
           printf(" => mAdoptCount:     % 10d\n", int(mAdoptCount));
           printf(" => mAdoptFreeCount: % 10d", int(mAdoptFreeCount));
           if (mAdoptCount > mAdoptFreeCount)
             printf("  --  LEAKED %d !!!\n", mAdoptCount - mAdoptFreeCount);
           else
             printf("\n");
           printf(" => Process ID: %" PRIuPTR ", Thread ID: %" PRIuPTR "\n",
@@ -82,16 +106,17 @@ class nsStringStats
         }
 
       Atomic<int32_t> mAllocCount;
       Atomic<int32_t> mReallocCount;
       Atomic<int32_t> mFreeCount;
       Atomic<int32_t> mShareCount;
       Atomic<int32_t> mAdoptCount;
       Atomic<int32_t> mAdoptFreeCount;
+      nsHashSetMT< nsPtrHashKey<nsStringBuffer> > mLiveStringBuffers;
   };
 static nsStringStats gStringStats;
 #define STRING_STAT_INCREMENT(_s) (gStringStats.m ## _s ## Count)++
 #else
 #define STRING_STAT_INCREMENT(_s)
 #endif
 
 // ---------------------------------------------------------------------------
@@ -171,16 +196,19 @@ nsStringBuffer::AddRef()
 void
 nsStringBuffer::Release()
   {
     int32_t count = --mRefCount;
     NS_LOG_RELEASE(this, count, "nsStringBuffer");
     if (count == 0)
       {
         STRING_STAT_INCREMENT(Free);
+#ifdef ENABLE_STRING_STATS
+        gStringStats.mLiveStringBuffers.Remove(this);
+#endif
         free(this); // we were allocated with |malloc|
       }
   }
 
   /**
    * Alloc returns a pointer to a new string header with set capacity.
    */
 already_AddRefed<nsStringBuffer>
@@ -191,16 +219,19 @@ nsStringBuffer::Alloc(size_t size)
                  sizeof(nsStringBuffer) + size > size,
                  "mStorageSize will truncate");
 
     nsStringBuffer *hdr =
         (nsStringBuffer *) malloc(sizeof(nsStringBuffer) + size);
     if (hdr)
       {
         STRING_STAT_INCREMENT(Alloc);
+#ifdef ENABLE_STRING_STATS
+        gStringStats.mLiveStringBuffers.Add(hdr);
+#endif
 
         hdr->mRefCount = 1;
         hdr->mStorageSize = size;
         NS_LOG_ADDREF(hdr, 1, "nsStringBuffer", sizeof(*hdr));
       }
     return dont_AddRef(hdr);
   }
 
@@ -217,23 +248,28 @@ nsStringBuffer::Realloc(nsStringBuffer* 
     // no point in trying to save ourselves if we hit this assertion
     NS_ASSERTION(!hdr->IsReadonly(), "|Realloc| attempted on readonly string");
 
     // Treat this as a release and addref for refcounting purposes, since we
     // just asserted that the refcount is 1.  If we don't do that, refcount
     // logging will claim we've leaked all sorts of stuff.
     NS_LOG_RELEASE(hdr, 0, "nsStringBuffer");
     
-    hdr = (nsStringBuffer*) realloc(hdr, sizeof(nsStringBuffer) + size);
-    if (hdr) {
-      NS_LOG_ADDREF(hdr, 1, "nsStringBuffer", sizeof(*hdr));
-      hdr->mStorageSize = size;
+    nsStringBuffer* new_hdr =
+      (nsStringBuffer*) realloc(hdr, sizeof(nsStringBuffer) + size);
+    if (new_hdr) {
+      NS_LOG_ADDREF(new_hdr, 1, "nsStringBuffer", sizeof(*new_hdr));
+      new_hdr->mStorageSize = size;
+#ifdef ENABLE_STRING_STATS
+      gStringStats.mLiveStringBuffers.Remove(hdr);
+      gStringStats.mLiveStringBuffers.Add(new_hdr);
+#endif
     }
 
-    return hdr;
+    return new_hdr;
   }
 
 nsStringBuffer*
 nsStringBuffer::FromString(const nsAString& str)
   {
     const nsAStringAccessor* accessor =
         static_cast<const nsAStringAccessor*>(&str);
 
