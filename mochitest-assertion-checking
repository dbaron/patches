From: L. David Baron <dbaron@dbaron.org>

Add mochitest support (currently semi-disabled) for making tests fail when an unexpected number of assertions fire.  (Bug 404077)

This adds support for assertion checking in all mochitest suites except
for mochitest-browser-chrome.  The checking works much like it does in
reftest, except for the mechanism for annotating expected assertions,
SimpleTest.expectAssertions() (see its in-code documentation).

The support is initially disabled in that:
 (1) It doesn't cause the tests to report failure (and thus turn the
     tree orange).
 (2) It prints TEST-DETCEPXENU-FAIL/PASS instead of
     TEST-UNEXPECTED-FAIL/PASS (so that it doesn't show up in log
     highlighting).

The assertion checking only works within the test runner (which runs
multiple tests); it does not function when running only a single test.

TODO:
 * fix assertion test_resizer (bug 631289)
 * fix leaks in mochitest-plain-1

diff --git a/testing/mochitest/tests/SimpleTest/SimpleTest.js b/testing/mochitest/tests/SimpleTest/SimpleTest.js
--- a/testing/mochitest/tests/SimpleTest/SimpleTest.js
+++ b/testing/mochitest/tests/SimpleTest/SimpleTest.js
@@ -280,16 +280,54 @@ SimpleTest.waitForExplicitFinish = funct
  * finish.
  */
 SimpleTest.requestLongerTimeout = function (factor) {
     if (parentRunner) {
         parentRunner.requestLongerTimeout(factor);
     }
 }
 
+/**
+ * Note that the given range of assertions is to be expected.  When
+ * this function is not called, 0 assertions are expected.  When only
+ * one argument is given, that number of assertions are expected.
+ *
+ * A test where we expect to have assertions (which should largely be a
+ * transitional mechanism to get assertion counts down from our current
+ * situation) can call the SimpleTest.expectAssertions() function, with
+ * either one or two arguments:  one argument gives an exact number
+ * expected, and two arguments give a range.  For example, a test might do
+ * one of the following:
+ *
+ *   // Currently triggers two assertions (bug NNNNNN).
+ *   SimpleTest.expectAssertions(2);
+ *
+ *   // Currently triggers one assertion on Mac (bug NNNNNN).
+ *   if (navigator.platform.indexOf("Mac") == 0) {
+ *     SimpleTest.expectAssertions(1);
+ *   }
+ *
+ *   // Currently triggers two assertions on all platforms (bug NNNNNN),
+ *   // but intermittently triggers two additional assertions (bug NNNNNN)
+ *   // on Windows.
+ *   if (navigator.platform.indexOf("Win") == 0) {
+ *     SimpleTest.expectAssertions(2, 4);
+ *   } else {
+ *     SimpleTest.expectAssertions(2);
+ *   }
+ *
+ *   // Intermittently triggers up to three assertions (bug NNNNNN).
+ *   SimpleTest.expectAssertions(0, 3);
+ */
+SimpleTest.expectAssertions = function(min, max) {
+    if (parentRunner) {
+        parentRunner.expectAssertions(min, max);
+    }
+}
+
 SimpleTest.waitForFocus_started = false;
 SimpleTest.waitForFocus_loaded = false;
 SimpleTest.waitForFocus_focused = false;
 
 /**
  * If the page is not yet loaded, waits for the load event. In addition, if
  * the page is not yet focused, focuses and waits for the window to be
  * focused. Calls the callback when completed. If the current page is
diff --git a/testing/mochitest/tests/SimpleTest/TestRunner.js b/testing/mochitest/tests/SimpleTest/TestRunner.js
--- a/testing/mochitest/tests/SimpleTest/TestRunner.js
+++ b/testing/mochitest/tests/SimpleTest/TestRunner.js
@@ -31,31 +31,46 @@ function contentAsyncEvent(type, data) {
  *
  *  * Avoid moving iframes: That causes reloads on mozilla and opera.
  *
  *
 **/
 var TestRunner = {};
 TestRunner.logEnabled = false;
 TestRunner._currentTest = 0;
+TestRunner._lastTestFinished = -1;
 TestRunner.currentTestURL = "";
 TestRunner._urls = [];
+TestRunner._lastAssertionCount = 0;
+TestRunner._expectedMinAsserts = 0;
+TestRunner._expectedMaxAsserts = 0;
 
 TestRunner.timeout = 5 * 60 * 1000; // 5 minutes.
 TestRunner.maxTimeouts = 4; // halt testing after too many timeouts
 
 // running in e10s build and need to use IPC?
 if (typeof SpecialPowers != 'undefined') {
     TestRunner.ipcMode = SpecialPowers.hasContentProcesses();
 } else {
     TestRunner.ipcMode = false;
 }
 
 TestRunner._expectingProcessCrash = false;
 
+try {
+  netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+  var DEBUG_CONTRACTID = "@mozilla.org/xpcom/debug;1";
+  var CC = Components.classes;
+  var CI = Components.interfaces;
+  var CR = Components.results;
+  TestRunner._debug = CC[DEBUG_CONTRACTID].getService(CI.nsIDebug2);
+} catch (e) {
+  TestRunner._debug = null;
+}
+
 /**
  * Make sure the tests don't hang indefinitely.
 **/
 TestRunner._numTimeouts = 0;
 TestRunner._currentTestStartTime = new Date().valueOf();
 TestRunner._timeoutFactor = 1;
 
 TestRunner._checkForHangs = function() {
@@ -86,16 +101,24 @@ TestRunner._checkForHangs = function() {
     TestRunner.deferred = callLater(30, TestRunner._checkForHangs);
   }
 }
 
 TestRunner.requestLongerTimeout = function(factor) {
     TestRunner._timeoutFactor = factor;
 }
 
+TestRunner.expectAssertions = function(min, max) {
+    if (typeof(max) == "undefined") {
+        max = min;
+    }
+    TestRunner._expectedMinAsserts = min;
+    TestRunner._expectedMaxAsserts = max;
+}
+
 /**
  * This function is called after generating the summary.
 **/
 TestRunner.onComplete = null;
 
 /**
  * If logEnabled is true, this is the logger that will be used.
 **/
@@ -192,16 +215,18 @@ TestRunner.runNextTest = function() {
     {
         var url = TestRunner._urls[TestRunner._currentTest];
         TestRunner.currentTestURL = url;
 
         $("current-test-path").innerHTML = url;
 
         TestRunner._currentTestStartTime = new Date().valueOf();
         TestRunner._timeoutFactor = 1;
+        TestRunner._expectedMinAsserts = 0;
+        TestRunner._expectedMaxAsserts = 0;
 
         TestRunner.log("TEST-START | " + url); // used by automation.py
 
         TestRunner._makeIframe(url, 0);
     } else {
         $("current-test").innerHTML = "<b>Finished</b>";
         TestRunner._makeIframe("about:blank", 0);
 
@@ -239,16 +264,28 @@ TestRunner.expectChildProcessCrash = fun
 
     TestRunner._expectingProcessCrash = true;
 };
 
 /**
  * This stub is called by SimpleTest when a test is finished.
 **/
 TestRunner.testFinished = function(tests) {
+    // Sometimes a test calls finish() multiple times before we have a
+    // chance to unload it.  At some point in the future we should make
+    // this an error.
+    if (TestRunner._currentTest == TestRunner._lastTestFinished) {
+        // 
+        TestRunner.logger.log("TEST-INFO | " +
+                              TestRunner._urls[TestRunner._currentTest] +
+                              " | called finish() multiple times");
+        return;
+    }
+    TestRunner._lastTestFinished = TestRunner._currentTest;
+
     function cleanUpCrashDumpFiles() {
         if (!SpecialPowers.removeExpectedCrashDumpFiles(TestRunner._expectingProcessCrash)) {
             TestRunner.error("TEST-UNEXPECTED-FAIL | " +
                              TestRunner.currentTestURL +
                              " | This test did not leave any crash dumps behind, but we were expecting some!");
             tests.push({ result: false });
         }
         var unexpectedCrashDumpFiles =
@@ -269,30 +306,64 @@ TestRunner.testFinished = function(tests
 
     function runNextTest() {
         var runtime = new Date().valueOf() - TestRunner._currentTestStartTime;
         TestRunner.log("TEST-END | " +
                        TestRunner._urls[TestRunner._currentTest] +
                        " | finished in " + runtime + "ms");
 
         TestRunner.updateUI(tests);
-        TestRunner._currentTest++;
-        TestRunner.runNextTest();
+
+        var iframe = $('testframe');
+        // For some reason, if we use an onload handler rather than an
+        // inline script, then tests that call finish() multiple times cause
+        // the onload to fail to fire in some cases (e.g., test_audio1 and
+        // test_audio2, in succession, which both call finish three times).
+        iframe.src = "data:text/html,<script>(parent.TestRunner || parent.wrappedJSObject.TestRunner).testUnloaded()<\/script>";
     }
 
     if (typeof SpecialPowers != 'undefined') {
         SpecialPowers.executeAfterFlushingMessageQueue(function() {
             cleanUpCrashDumpFiles();
             runNextTest();
         });
     } else {
         runNextTest();
     }
 };
 
+TestRunner.testUnloaded = function() {
+    if (TestRunner._debug) {
+        netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+        if (TestRunner._debug.isDebugBuild) {
+            var newAssertionCount = TestRunner._debug.assertionCount;
+            var numAsserts = newAssertionCount - TestRunner._lastAssertionCount;
+            TestRunner._lastAssertionCount = newAssertionCount;
+
+            var url = TestRunner._urls[TestRunner._currentTest];
+            var max = TestRunner._expectedMaxAsserts;
+            var min = TestRunner._expectedMinAsserts;
+            if (numAsserts > max) {
+                // WHEN ENABLING, change "log" to "error" and "DETCEPXENU"
+                // to "UNEXPECTED".
+                TestRunner.logger.log("TEST-DETCEPXENU-FAIL | " + url + " | Assertion count " + numAsserts + " is greater than expected range " + min + "-" + max + " assertions.");
+            } else if (numAsserts > 0) {
+                TestRunner.logger.log("TEST-KNOWN-FAIL | " + url + " | Assertion count " + numAsserts + " within expected range " + min + "-" + max + " assertions.");
+            }
+            if (numAsserts < min) {
+                // WHEN ENABLING, change "log" to "error" and "DETCEPXENU"
+                // to "UNEXPECTED".
+                TestRunner.logger.log("TEST-DETCEPXENU-PASS | " + url + " | Assertion count " + numAsserts + " is less than expected range " + min + "-" + max + " assertions.");
+            }
+        }
+    }
+    TestRunner._currentTest++;
+    TestRunner.runNextTest();
+};
+
 /**
  * Get the results.
  */
 TestRunner.countResults = function(tests) {
   var nOK = 0;
   var nNotOK = 0;
   var nTodo = 0;
   for (var i = 0; i < tests.length; ++i) {
