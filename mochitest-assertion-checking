From: L. David Baron <dbaron@dbaron.org>

Add mochitest support (currently semi-disabled) for making tests fail when an unexpected number of assertions fire.  (Bug 404077)

This adds support for assertion checking in all mochitest suites except
for mochitest-browser-chrome.  The checking works much like it does in
reftest, except for the mechanism for annotating expected assertions,
SimpleTest.expectAssertions() (see its in-code documentation).

The support is initially disabled in that:
 (1) It doesn't cause the tests to report failure (and thus turn the
     tree orange).
 (2) It prints TEST-DETCEPXENU-FAIL/PASS instead of
     TEST-UNEXPECTED-FAIL/PASS (so that it doesn't show up in log
     highlighting).

diff --git a/testing/mochitest/tests/SimpleTest/SimpleTest.js b/testing/mochitest/tests/SimpleTest/SimpleTest.js
--- a/testing/mochitest/tests/SimpleTest/SimpleTest.js
+++ b/testing/mochitest/tests/SimpleTest/SimpleTest.js
@@ -282,16 +282,54 @@ SimpleTest.waitForExplicitFinish = funct
  * finish.
  */
 SimpleTest.requestLongerTimeout = function (factor) {
     if (parentRunner) {
         parentRunner.requestLongerTimeout(factor);
     }
 }
 
+/**
+ * Note that the given range of assertions is to be expected.  When
+ * this function is not called, 0 assertions are expected.  When only
+ * one argument is given, that number of assertions are expected.
+ *
+ * A test where we expect to have assertions (which should largely be a
+ * transitional mechanism to get assertion counts down from our current
+ * situation) can call the SimpleTest.expectAssertions() function, with
+ * either one or two arguments:  one argument gives an exact number
+ * expected, and two arguments give a range.  For example, a test might do
+ * one of the following:
+ *
+ *   // Currently triggers two assertions (bug NNNNNN).
+ *   SimpleTest.expectAssertions(2);
+ *
+ *   // Currently triggers one assertion on Mac (bug NNNNNN).
+ *   if (navigator.platform.indexOf("Mac") == 0) {
+ *     SimpleTest.expectAssertions(1);
+ *   }
+ *
+ *   // Currently triggers two assertions on all platforms (bug NNNNNN),
+ *   // but intermittently triggers two additional assertions (bug NNNNNN)
+ *   // on Windows.
+ *   if (navigator.platform.indexOf("Win") == 0) {
+ *     SimpleTest.expectAssertions(2, 4);
+ *   } else {
+ *     SimpleTest.expectAssertions(2);
+ *   }
+ *
+ *   // Intermittently triggers up to three assertions (bug NNNNNN).
+ *   SimpleTest.expectAssertions(0, 3);
+ */
+SimpleTest.expectAssertions = function(min, max) {
+    if (parentRunner) {
+        parentRunner.expectAssertions(min, max);
+    }
+}
+
 SimpleTest.waitForFocus_started = false;
 SimpleTest.waitForFocus_loaded = false;
 SimpleTest.waitForFocus_focused = false;
 
 /**
  * If the page is not yet loaded, waits for the load event. In addition, if
  * the page is not yet focused, focuses and waits for the window to be
  * focused. Calls the callback when completed. If the current page is
diff --git a/testing/mochitest/tests/SimpleTest/TestRunner.js b/testing/mochitest/tests/SimpleTest/TestRunner.js
--- a/testing/mochitest/tests/SimpleTest/TestRunner.js
+++ b/testing/mochitest/tests/SimpleTest/TestRunner.js
@@ -33,30 +33,44 @@ function contentAsyncEvent(type, data) {
  *
  *
 **/
 var TestRunner = {};
 TestRunner.logEnabled = false;
 TestRunner._currentTest = 0;
 TestRunner.currentTestURL = "";
 TestRunner._urls = [];
+TestRunner._lastAssertionCount = 0;
+TestRunner._expectedMinAsserts = 0;
+TestRunner._expectedMaxAsserts = 0;
 
 TestRunner.timeout = 5 * 60 * 1000; // 5 minutes.
 TestRunner.maxTimeouts = 4; // halt testing after too many timeouts
 
 TestRunner.ipcMode = false; // running in e10s build and need to use IPC?
 try {
   netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
   var ipcsanity = Components.classes["@mozilla.org/preferences-service;1"]
                     .getService(Components.interfaces.nsIPrefBranch);
   ipcsanity.setIntPref("mochitest.ipcmode", 0);
 } catch (e) {
   TestRunner.ipcMode = true;
 }
 
+try {
+  netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+  var DEBUG_CONTRACTID = "@mozilla.org/xpcom/debug;1";
+  var CC = Components.classes;
+  var CI = Components.interfaces;
+  var CR = Components.results;
+  TestRunner._debug = CC[DEBUG_CONTRACTID].getService(CI.nsIDebug2);
+} catch (e) {
+  TestRunner._debug = null;
+}
+
 /**
  * Make sure the tests don't hang indefinitely.
 **/
 TestRunner._numTimeouts = 0;
 TestRunner._currentTestStartTime = new Date().valueOf();
 TestRunner._timeoutFactor = 1;
 
 TestRunner._checkForHangs = function() {
@@ -87,16 +101,24 @@ TestRunner._checkForHangs = function() {
     TestRunner.deferred = callLater(30, TestRunner._checkForHangs);
   }
 }
 
 TestRunner.requestLongerTimeout = function(factor) {
     TestRunner._timeoutFactor = factor;
 }
 
+TestRunner.expectAssertions = function(min, max) {
+    if (typeof(max) == "undefined") {
+        max = min;
+    }
+    TestRunner._expectedMinAsserts = min;
+    TestRunner._expectedMaxAsserts = max;
+}
+
 /**
  * This function is called after generating the summary.
 **/
 TestRunner.onComplete = null;
 
 /**
  * If logEnabled is true, this is the logger that will be used.
 **/
@@ -176,16 +198,18 @@ TestRunner.runNextTest = function() {
     {
         var url = TestRunner._urls[TestRunner._currentTest];
         TestRunner.currentTestURL = url;
 
         $("current-test-path").innerHTML = url;
 
         TestRunner._currentTestStartTime = new Date().valueOf();
         TestRunner._timeoutFactor = 1;
+        TestRunner._expectedMinAsserts = 0;
+        TestRunner._expectedMaxAsserts = 0;
 
         if (TestRunner.logEnabled)
             TestRunner.logger.log("TEST-START | " + url); // used by automation.py
 
         TestRunner._makeIframe(url, 0);
     } else {
         $("current-test").innerHTML = "<b>Finished</b>";
         TestRunner._makeIframe("about:blank", 0);
@@ -227,16 +251,45 @@ TestRunner.testFinished = function(tests
     if (TestRunner.logEnabled) {
         var runtime = new Date().valueOf() - TestRunner._currentTestStartTime;
         TestRunner.logger.log("TEST-END | " +
                               TestRunner._urls[TestRunner._currentTest] +
                               " | finished in " + runtime + "ms");
     }
 
     TestRunner.updateUI(tests);
+
+    var iframe = $('testframe');
+    iframe.src = "data:text/html,<body onload='(parent.TestRunner || parent.wrappedJSObject.TestRunner).testUnloaded()'>";
+};
+
+TestRunner.testUnloaded = function() {
+    if (TestRunner._debug) {
+        netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+        if (TestRunner._debug.isDebugBuild) {
+            var newAssertionCount = TestRunner._debug.assertionCount;
+            var numAsserts = newAssertionCount - TestRunner._lastAssertionCount;
+            TestRunner._lastAssertionCount = newAssertionCount;
+
+            var url = TestRunner._urls[TestRunner._currentTest];
+            var max = TestRunner._expectedMaxAsserts;
+            var min = TestRunner._expectedMinAsserts;
+            if (numAsserts > max) {
+                // WHEN ENABLING, change "log" to "error" and "DETCEPXENU"
+                // to "UNEXPECTED".
+                TestRunner.logger.log("TEST-DETCEPXENU-FAIL | " + url + " | Assertion count " + numAsserts + " is greater than expected range " + min + "-" + max + " assertions.");
+            }
+            if (numAsserts < min) {
+                // WHEN ENABLING, change "log" to "error" and "DETCEPXENU"
+                // to "UNEXPECTED".
+                TestRunner.logger.log("TEST-DETCEPXENU-PASS | " + url + " | Assertion count " + numAsserts + " is less than expected range " + min + "-" + max + " assertions.");
+            }
+        }
+    }
+
     TestRunner._currentTest++;
     TestRunner.runNextTest();
 };
 
 /**
  * Get the results.
  */
 TestRunner.countResults = function(tests) {
