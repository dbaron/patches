From: L. David Baron <dbaron@dbaron.org>

Add calc() support for 'font-size' property, which is the only property for which percents are computed to lengths in nsRuleNode.  (Bug 363249)

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -5960,17 +5960,18 @@ CSSParserImpl::ParseSingleValueProperty(
                         nsCSSProps::kFloatKTable);
   case eCSSProperty_float_edge:
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kFloatEdgeKTable);
   case eCSSProperty_font_family:
     return ParseFamily(aValue);
   case eCSSProperty_font_size:
     return ParseNonNegativeVariant(aValue,
-                                   VARIANT_HKLP | VARIANT_SYSFONT,
+                                   VARIANT_HKLP | VARIANT_SYSFONT |
+                                     VARIANT_CALC,
                                    nsCSSProps::kFontSizeKTable);
   case eCSSProperty_font_size_adjust:
     return ParseVariant(aValue, VARIANT_HON | VARIANT_SYSFONT,
                         nsnull);
   case eCSSProperty_font_stretch:
     return ParseVariant(aValue, VARIANT_HK | VARIANT_SYSFONT,
                         nsCSSProps::kFontStretchKTable);
   case eCSSProperty_font_style:
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -2641,16 +2641,69 @@ ComputeScriptLevelSize(const nsStyleFont
     // scriptminsize can only make sizes larger than the unconstrained size
     NS_ASSERTION(*aUnconstrainedSize <= scriptLevelSize, "How can this ever happen?");
     // Apply constraint #2
     return NS_MIN(scriptLevelSize, NS_MAX(*aUnconstrainedSize, minScriptSize));
   }
 }
 #endif
 
+struct SetFontSizeCalcOps : public mozilla::css::BasicCoordCalcOps,
+                            public mozilla::css::NumbersAlreadyNormalizedOps
+{
+  struct ComputeData {
+    // All of the parameters to CalcLengthWith except aValue.
+    nscoord mParentSize;
+    const nsStyleFont* mParentFont;
+    nsPresContext* mPresContext;
+    PRBool mAtRoot;
+    PRBool& mCanStoreInRuleTree;
+
+    ComputeData(nscoord aParentSize, const nsStyleFont* aParentFont,
+                nsPresContext* aPresContext, PRBool aAtRoot,
+                PRBool& aCanStoreInRuleTree)
+      : mParentSize(aParentSize),
+        mParentFont(aParentFont),
+        mPresContext(aPresContext),
+        mAtRoot(aAtRoot),
+        mCanStoreInRuleTree(aCanStoreInRuleTree)
+    {
+    }
+  };
+
+  static result_type ComputeLeafValue(const nsCSSValue& aValue,
+                                      const ComputeData& aClosure)
+  {
+    nscoord size;
+    if (aValue.IsLengthUnit()) {
+      // Note that font-based length units use the parent's size
+      // unadjusted for scriptlevel changes. A scriptlevel change
+      // between us and the parent is simply ignored.
+      size = CalcLengthWith(aValue, aClosure.mParentSize, aClosure.mParentFont,
+                            nsnull, aClosure.mPresContext, aClosure.mAtRoot,
+                            PR_TRUE, aClosure.mCanStoreInRuleTree);
+      if (aValue.IsFixedLengthUnit() || aValue.GetUnit() == eCSSUnit_Pixel) {
+        size = nsStyleFont::ZoomText(aClosure.mPresContext, size);
+      }
+    }
+    else if (eCSSUnit_Percent == aValue.GetUnit()) {
+      aClosure.mCanStoreInRuleTree = PR_FALSE;
+      // Note that % units use the parent's size unadjusted for scriptlevel
+      // changes. A scriptlevel change between us and the parent is simply
+      // ignored.
+      size = NSToCoordRound(aClosure.mParentSize * aValue.GetPercentValue());
+    } else {
+      NS_ABORT_IF_FALSE(PR_FALSE, "unexpected value");
+      size = aClosure.mParentSize;
+    }
+
+    return size;
+  }
+};
+
 /* static */ void
 nsRuleNode::SetFontSize(nsPresContext* aPresContext,
                         const nsRuleDataFont& aFontData,
                         const nsStyleFont* aFont,
                         const nsStyleFont* aParentFont,
                         nscoord* aSize,
                         const nsFont& aSystemFont,
                         nscoord aParentSize,
@@ -2702,33 +2755,31 @@ nsRuleNode::SetFontSize(nsPresContext* a
         NS_ASSERTION(*aSize < parentSize ||
                      parentSize <= nsPresContext::CSSPixelsToAppUnits(1),
                      "FindNextSmallerFontSize failed");
       }
     } else {
       NS_NOTREACHED("unexpected value");
     }
   }
-  else if (aFontData.mSize.IsLengthUnit()) {
-    // Note that font-based length units use the parent's size unadjusted
-    // for scriptlevel changes. A scriptlevel change between us and the parent
-    // is simply ignored.
-    *aSize = CalcLengthWith(aFontData.mSize, aParentSize, aParentFont, nsnull,
-                            aPresContext, aAtRoot, PR_TRUE,
-                            aCanStoreInRuleTree);
-    zoom = aFontData.mSize.IsFixedLengthUnit() ||
-           aFontData.mSize.GetUnit() == eCSSUnit_Pixel;
-  }
-  else if (eCSSUnit_Percent == aFontData.mSize.GetUnit()) {
-    aCanStoreInRuleTree = PR_FALSE;
-    // Note that % units use the parent's size unadjusted for scriptlevel
-    // changes. A scriptlevel change between us and the parent is simply
-    // ignored.
-    *aSize = NSToCoordRound(aParentSize *
-                            aFontData.mSize.GetPercentValue());
+  else if (aFontData.mSize.IsLengthUnit() ||
+           aFontData.mSize.GetUnit() == eCSSUnit_Percent ||
+           aFontData.mSize.IsCalcUnit()) {
+    SetFontSizeCalcOps::ComputeData data(aParentSize, aParentFont,
+                                         aPresContext, aAtRoot,
+                                         aCanStoreInRuleTree);
+    *aSize =
+      mozilla::css::ComputeCalc<SetFontSizeCalcOps>(aFontData.mSize, data);
+    if (*aSize < 0) {
+      NS_ABORT_IF_FALSE(aFontData.mSize.IsCalcUnit(),
+                        "negative lengths and percents should be rejected "
+                        "by parser");
+      *aSize = 0;
+    }
+    // Zoom is handled inside the calc ops when needed.
     zoom = PR_FALSE;
   }
   else if (eCSSUnit_System_Font == aFontData.mSize.GetUnit()) {
     // this becomes our cascading size
     *aSize = aSystemFont.size;
     zoom = PR_TRUE;
   }
   else if (eCSSUnit_Inherit == aFontData.mSize.GetUnit()) {
diff --git a/layout/style/test/property_database.js b/layout/style/test/property_database.js
--- a/layout/style/test/property_database.js
+++ b/layout/style/test/property_database.js
@@ -1399,19 +1399,33 @@ var gCSSProperties = {
 		initial_values: [ "serif" ],
 		other_values: [ "sans-serif", "Times New Roman, serif", "'Times New Roman', serif", "cursive", "fantasy", "\"Times New Roman", "Times, \"Times New Roman" ],
 		invalid_values: [ "\"Times New\" Roman" ]
 	},
 	"font-size": {
 		domProp: "fontSize",
 		inherited: true,
 		type: CSS_TYPE_LONGHAND,
-		initial_values: [ "medium" ],
-		other_values: [ "large", "2em", "50%", "xx-small", "36pt", "8px" ],
-		invalid_values: []
+		initial_values: [ "medium",
+			"1rem",
+			"-moz-calc(1rem)",
+			"-moz-calc(0.75rem + 200% - 125% + 0.25rem - 75%)"
+		],
+		other_values: [ "large", "2em", "50%", "xx-small", "36pt", "8px",
+			"0px",
+			"0%",
+			"-moz-calc(2em)",
+			"-moz-min(36pt, 2em)",
+			"-moz-max(50%, 8px)",
+			"-moz-min(36pt + 75%, 30% + 2em + 2px)",
+			"-moz-calc(-2em)",
+			"-moz-calc(-50%)",
+			"-moz-calc(-1px)"
+		],
+		invalid_values: [ "-2em", "-50%", "-1px" ]
 	},
 	"font-size-adjust": {
 		domProp: "fontSizeAdjust",
 		inherited: true,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "none" ],
 		other_values: [ "0.3", "0.5", "0.7" ],
 		invalid_values: []
