From: L. David Baron <dbaron@dbaron.org>

Bug 781360 patch 3a: Rename {nsIFrame,nsStyleContext,nsComputedDOMStyle}::GetStyle* to Style*, since they can never return null.  Automated changes only.

diff --git a/accessible/src/base/StyleInfo.cpp b/accessible/src/base/StyleInfo.cpp
--- a/accessible/src/base/StyleInfo.cpp
+++ b/accessible/src/base/StyleInfo.cpp
@@ -22,36 +22,36 @@ StyleInfo::StyleInfo(dom::Element* aElem
                                                          aPresShell);
 }
 
 void
 StyleInfo::Display(nsAString& aValue)
 {
   aValue.Truncate();
   AppendASCIItoUTF16(
-    nsCSSProps::ValueToKeyword(mStyleContext->GetStyleDisplay()->mDisplay,
+    nsCSSProps::ValueToKeyword(mStyleContext->StyleDisplay()->mDisplay,
                                nsCSSProps::kDisplayKTable), aValue);
 }
 
 void
 StyleInfo::TextAlign(nsAString& aValue)
 {
   aValue.Truncate();
   AppendASCIItoUTF16(
-    nsCSSProps::ValueToKeyword(mStyleContext->GetStyleText()->mTextAlign,
+    nsCSSProps::ValueToKeyword(mStyleContext->StyleText()->mTextAlign,
                                nsCSSProps::kTextAlignKTable), aValue);
 }
 
 void
 StyleInfo::TextIndent(nsAString& aValue)
 {
   aValue.Truncate();
 
   const nsStyleCoord& styleCoord =
-    mStyleContext->GetStyleText()->mTextIndent;
+    mStyleContext->StyleText()->mTextIndent;
 
   nscoord coordVal = 0;
   switch (styleCoord.GetUnit()) {
     case eStyleUnit_Coord:
       coordVal = styleCoord.GetCoordValue();
       break;
 
     case eStyleUnit_Percent:
diff --git a/accessible/src/base/TextAttrs.cpp b/accessible/src/base/TextAttrs.cpp
--- a/accessible/src/base/TextAttrs.cpp
+++ b/accessible/src/base/TextAttrs.cpp
@@ -344,17 +344,17 @@ TextAttrsMgr::BGColorTextAttr::
   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::backgroundColor,
                          formattedValue);
 }
 
 bool
 TextAttrsMgr::BGColorTextAttr::
   GetColor(nsIFrame* aFrame, nscolor* aColor)
 {
-  const nsStyleBackground* styleBackground = aFrame->GetStyleBackground();
+  const nsStyleBackground* styleBackground = aFrame->StyleBackground();
 
   if (NS_GET_A(styleBackground->mBackgroundColor) > 0) {
     *aColor = styleBackground->mBackgroundColor;
     return true;
   }
 
   nsIFrame *parentFrame = aFrame->GetParent();
   if (!parentFrame) {
@@ -375,33 +375,33 @@ TextAttrsMgr::BGColorTextAttr::
 ////////////////////////////////////////////////////////////////////////////////
 // ColorTextAttr
 ////////////////////////////////////////////////////////////////////////////////
 
 TextAttrsMgr::ColorTextAttr::
   ColorTextAttr(nsIFrame* aRootFrame, nsIFrame* aFrame) :
   TTextAttr<nscolor>(!aFrame)
 {
-  mRootNativeValue = aRootFrame->GetStyleColor()->mColor;
+  mRootNativeValue = aRootFrame->StyleColor()->mColor;
   mIsRootDefined = true;
 
   if (aFrame) {
-    mNativeValue = aFrame->GetStyleColor()->mColor;
+    mNativeValue = aFrame->StyleColor()->mColor;
     mIsDefined = true;
   }
 }
 
 bool
 TextAttrsMgr::ColorTextAttr::
   GetValueFor(Accessible* aAccessible, nscolor* aValue)
 {
   nsIContent* elm = nsCoreUtils::GetDOMElementFor(aAccessible->GetContent());
   nsIFrame* frame = elm->GetPrimaryFrame();
   if (frame) {
-    *aValue = frame->GetStyleColor()->mColor;
+    *aValue = frame->StyleColor()->mColor;
     return true;
   }
 
   return false;
 }
 
 void
 TextAttrsMgr::ColorTextAttr::
@@ -461,33 +461,33 @@ TextAttrsMgr::FontFamilyTextAttr::
 ////////////////////////////////////////////////////////////////////////////////
 
 TextAttrsMgr::FontSizeTextAttr::
   FontSizeTextAttr(nsIFrame* aRootFrame, nsIFrame* aFrame) :
   TTextAttr<nscoord>(!aFrame)
 {
   mDC = aRootFrame->PresContext()->DeviceContext();
 
-  mRootNativeValue = aRootFrame->GetStyleFont()->mSize;
+  mRootNativeValue = aRootFrame->StyleFont()->mSize;
   mIsRootDefined = true;
 
   if (aFrame) {
-    mNativeValue = aFrame->GetStyleFont()->mSize;
+    mNativeValue = aFrame->StyleFont()->mSize;
     mIsDefined = true;
   }
 }
 
 bool
 TextAttrsMgr::FontSizeTextAttr::
   GetValueFor(Accessible* aAccessible, nscoord* aValue)
 {
   nsIContent* content = nsCoreUtils::GetDOMElementFor(aAccessible->GetContent());
   nsIFrame* frame = content->GetPrimaryFrame();
   if (frame) {
-    *aValue = frame->GetStyleFont()->mSize;
+    *aValue = frame->StyleFont()->mSize;
     return true;
   }
 
   return false;
 }
 
 void
 TextAttrsMgr::FontSizeTextAttr::
@@ -517,33 +517,33 @@ TextAttrsMgr::FontSizeTextAttr::
 ////////////////////////////////////////////////////////////////////////////////
 // FontStyleTextAttr
 ////////////////////////////////////////////////////////////////////////////////
 
 TextAttrsMgr::FontStyleTextAttr::
   FontStyleTextAttr(nsIFrame* aRootFrame, nsIFrame* aFrame) :
   TTextAttr<nscoord>(!aFrame)
 {
-  mRootNativeValue = aRootFrame->GetStyleFont()->mFont.style;
+  mRootNativeValue = aRootFrame->StyleFont()->mFont.style;
   mIsRootDefined = true;
 
   if (aFrame) {
-    mNativeValue = aFrame->GetStyleFont()->mFont.style;
+    mNativeValue = aFrame->StyleFont()->mFont.style;
     mIsDefined = true;
   }
 }
 
 bool
 TextAttrsMgr::FontStyleTextAttr::
   GetValueFor(Accessible* aAccessible, nscoord* aValue)
 {
   nsIContent* elm = nsCoreUtils::GetDOMElementFor(aAccessible->GetContent());
   nsIFrame* frame = elm->GetPrimaryFrame();
   if (frame) {
-    *aValue = frame->GetStyleFont()->mFont.style;
+    *aValue = frame->StyleFont()->mFont.style;
     return true;
   }
 
   return false;
 }
 
 void
 TextAttrsMgr::FontStyleTextAttr::
@@ -667,23 +667,23 @@ TextAttrsMgr::AutoGeneratedTextAttr::
 
 ////////////////////////////////////////////////////////////////////////////////
 // TextDecorTextAttr
 ////////////////////////////////////////////////////////////////////////////////
 
 TextAttrsMgr::TextDecorValue::
   TextDecorValue(nsIFrame* aFrame)
 {
-  const nsStyleTextReset* textReset = aFrame->GetStyleTextReset();
+  const nsStyleTextReset* textReset = aFrame->StyleTextReset();
   mStyle = textReset->GetDecorationStyle();
 
   bool isForegroundColor = false;
   textReset->GetDecorationColor(mColor, isForegroundColor);
   if (isForegroundColor)
-    mColor = aFrame->GetStyleColor()->mColor;
+    mColor = aFrame->StyleColor()->mColor;
 
   mLine = textReset->mTextDecorationLine &
     (NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE |
      NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH);
 }
 
 TextAttrsMgr::TextDecorTextAttr::
   TextDecorTextAttr(nsIFrame* aRootFrame, nsIFrame* aFrame) :
@@ -799,17 +799,17 @@ TextAttrsMgr::TextPosTextAttr::
       break;
   }
 }
 
 TextAttrsMgr::TextPosValue
 TextAttrsMgr::TextPosTextAttr::
   GetTextPosValue(nsIFrame* aFrame) const
 {
-  const nsStyleCoord& styleCoord = aFrame->GetStyleTextReset()->mVerticalAlign;
+  const nsStyleCoord& styleCoord = aFrame->StyleTextReset()->mVerticalAlign;
   switch (styleCoord.GetUnit()) {
     case eStyleUnit_Enumerated:
       switch (styleCoord.GetIntValue()) {
         case NS_STYLE_VERTICAL_ALIGN_BASELINE:
           return eTextPosBaseline;
         case NS_STYLE_VERTICAL_ALIGN_SUB:
           return eTextPosSub;
         case NS_STYLE_VERTICAL_ALIGN_SUPER:
diff --git a/accessible/src/base/nsAccessibilityService.cpp b/accessible/src/base/nsAccessibilityService.cpp
--- a/accessible/src/base/nsAccessibilityService.cpp
+++ b/accessible/src/base/nsAccessibilityService.cpp
@@ -738,17 +738,17 @@ nsAccessibilityService::GetOrCreateAcces
   if (!aNode->IsContent())
     return nullptr;
 
   nsIContent* content = aNode->AsContent();
   nsIFrame* frame = content->GetPrimaryFrame();
 
   // Check frame and its visibility. Note, hidden frame allows visible
   // elements in subtree.
-  if (!frame || !frame->GetStyleVisibility()->IsVisible()) {
+  if (!frame || !frame->StyleVisibility()->IsVisible()) {
     if (aIsSubtreeHidden && !frame)
       *aIsSubtreeHidden = true;
 
     return nullptr;
   }
 
   if (frame->GetContent() != content) {
     // Not the main content for this frame. This happens because <area>
diff --git a/accessible/src/base/nsTextEquivUtils.cpp b/accessible/src/base/nsTextEquivUtils.cpp
--- a/accessible/src/base/nsTextEquivUtils.cpp
+++ b/accessible/src/base/nsTextEquivUtils.cpp
@@ -96,17 +96,17 @@ nsTextEquivUtils::AppendTextEquivFromCon
     return NS_OK;
 
   gInitiatorAcc = aInitiatorAcc;
 
   // If the given content is not visible or isn't accessible then go down
   // through the DOM subtree otherwise go down through accessible subtree and
   // calculate the flat string.
   nsIFrame *frame = aContent->GetPrimaryFrame();
-  bool isVisible = frame && frame->GetStyleVisibility()->IsVisible();
+  bool isVisible = frame && frame->StyleVisibility()->IsVisible();
 
   nsresult rv = NS_ERROR_FAILURE;
   bool goThroughDOMSubtree = true;
 
   if (isVisible) {
     Accessible* accessible =
       gInitiatorAcc->Document()->GetAccessible(aContent);
     if (accessible) {
@@ -131,17 +131,17 @@ nsTextEquivUtils::AppendTextEquivFromTex
 
     nsIContent *parentContent = aContent->GetParent();
     if (parentContent) {
       nsIFrame *frame = parentContent->GetPrimaryFrame();
       if (frame) {
         // If this text is inside a block level frame (as opposed to span
         // level), we need to add spaces around that block's text, so we don't
         // get words jammed together in final name.
-        const nsStyleDisplay* display = frame->GetStyleDisplay();
+        const nsStyleDisplay* display = frame->StyleDisplay();
         if (display->IsBlockOutsideStyle() ||
             display->mDisplay == NS_STYLE_DISPLAY_TABLE_CELL) {
           isHTMLBlock = true;
           if (!aString->IsEmpty()) {
             aString->Append(PRUnichar(' '));
           }
         }
       }
diff --git a/accessible/src/generic/Accessible.cpp b/accessible/src/generic/Accessible.cpp
--- a/accessible/src/generic/Accessible.cpp
+++ b/accessible/src/generic/Accessible.cpp
@@ -615,17 +615,17 @@ uint64_t
 Accessible::VisibilityState()
 {
   nsIFrame* frame = GetFrame();
   if (!frame)
     return states::INVISIBLE;
 
   // Walk the parent frame chain to see if there's invisible parent or the frame
   // is in background tab.
-  if (!frame->GetStyleVisibility()->IsVisible())
+  if (!frame->StyleVisibility()->IsVisible())
     return states::INVISIBLE;
 
   nsIFrame* curFrame = frame;
   nsPoint framePos(0, 0);
   do {
     nsView* view = curFrame->GetView();
     if (view && view->GetVisibility() == nsViewVisibility_kHide)
       return states::INVISIBLE;
@@ -655,17 +655,17 @@ Accessible::VisibilityState()
         scrollPortRect.Deflate(kMinPixels, kMinPixels);
         if (!scrollPortRect.Intersects(frameRect))
           return states::OFFSCREEN;
       }
     }
 
     if (!parentFrame) {
       parentFrame = nsLayoutUtils::GetCrossDocParentFrame(curFrame);
-      if (parentFrame && !parentFrame->GetStyleVisibility()->IsVisible())
+      if (parentFrame && !parentFrame->StyleVisibility()->IsVisible())
         return states::INVISIBLE;
     }
 
     curFrame = parentFrame;
   } while (curFrame);
 
   // Zero area rects can occur in the first frame of a multi-frame text flow,
   // in which case the rendered text is not empty and the frame should not be
@@ -712,17 +712,17 @@ Accessible::NativeState()
   nsIFrame *frame = GetFrame();
   if (frame) {
     if (frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
       state |= states::FLOATING;
 
     // XXX we should look at layout for non XUL box frames, but need to decide
     // how that interacts with ARIA.
     if (HasOwnContent() && mContent->IsXUL() && frame->IsBoxFrame()) {
-      const nsStyleXUL* xulStyle = frame->GetStyleXUL();
+      const nsStyleXUL* xulStyle = frame->StyleXUL();
       if (xulStyle && frame->IsBoxFrame()) {
         // In XUL all boxes are either vertical or horizontal
         if (xulStyle->mBoxOrient == NS_STYLE_BOX_ORIENT_VERTICAL)
           state |= states::VERTICAL;
         else
           state |= states::HORIZONTAL;
       }
     }
@@ -1532,17 +1532,17 @@ Accessible::State()
     state |= states::EXPANDABLE;
 
   // For some reasons DOM node may have not a frame. We tract such accessibles
   // as invisible.
   nsIFrame *frame = GetFrame();
   if (!frame)
     return state;
 
-  const nsStyleDisplay* display = frame->GetStyleDisplay();
+  const nsStyleDisplay* display = frame->StyleDisplay();
   if (display && display->mOpacity == 1.0f &&
       !(state & states::INVISIBLE)) {
     state |= states::OPAQUE1;
   }
 
   return state;
 }
 
diff --git a/accessible/src/html/HTMLTableAccessible.cpp b/accessible/src/html/HTMLTableAccessible.cpp
--- a/accessible/src/html/HTMLTableAccessible.cpp
+++ b/accessible/src/html/HTMLTableAccessible.cpp
@@ -1047,17 +1047,17 @@ HTMLTableAccessible::IsProbablyLayoutTab
   uint32_t childCount = ChildCount();
   nscolor rowColor = 0;
   nscolor prevRowColor;
   for (uint32_t childIdx = 0; childIdx < childCount; childIdx++) {
     Accessible* child = GetChildAt(childIdx);
     if (child->Role() == roles::ROW) {
       prevRowColor = rowColor;
       nsIFrame* rowFrame = child->GetFrame();
-      rowColor = rowFrame->GetStyleBackground()->mBackgroundColor;
+      rowColor = rowFrame->StyleBackground()->mBackgroundColor;
 
       if (childIdx > 0 && prevRowColor != rowColor)
         RETURN_LAYOUT_ANSWER(false, "2 styles of row background color, non-bordered");
     }
   }
 
   // Check for many rows
   const int32_t kMaxLayoutRows = 20;
diff --git a/accessible/src/windows/ia2/ia2AccessibleComponent.cpp b/accessible/src/windows/ia2/ia2AccessibleComponent.cpp
--- a/accessible/src/windows/ia2/ia2AccessibleComponent.cpp
+++ b/accessible/src/windows/ia2/ia2AccessibleComponent.cpp
@@ -87,17 +87,17 @@ ia2AccessibleComponent::get_foreground(I
   A11Y_TRYBLOCK_BEGIN
 
   AccessibleWrap* acc = static_cast<AccessibleWrap*>(this);
   if (acc->IsDefunct())
     return CO_E_OBJNOTCONNECTED;
 
   nsIFrame* frame = acc->GetFrame();
   if (frame)
-    *aForeground = frame->GetStyleColor()->mColor;
+    *aForeground = frame->StyleColor()->mColor;
 
   return S_OK;
 
   A11Y_TRYBLOCK_END
 }
 
 STDMETHODIMP
 ia2AccessibleComponent::get_background(IA2Color* aBackground)
@@ -105,15 +105,15 @@ ia2AccessibleComponent::get_background(I
   A11Y_TRYBLOCK_BEGIN
 
   AccessibleWrap* acc = static_cast<AccessibleWrap*>(this);
   if (acc->IsDefunct())
     return CO_E_OBJNOTCONNECTED;
 
   nsIFrame* frame = acc->GetFrame();
   if (frame)
-    *aBackground = frame->GetStyleBackground()->mBackgroundColor;
+    *aBackground = frame->StyleBackground()->mBackgroundColor;
 
   return S_OK;
 
   A11Y_TRYBLOCK_END
 }
 
diff --git a/accessible/tests/mochitest/name/test_list.html b/accessible/tests/mochitest/name/test_list.html
--- a/accessible/tests/mochitest/name/test_list.html
+++ b/accessible/tests/mochitest/name/test_list.html
@@ -68,17 +68,17 @@
   </script>
 
 </head>
 
 <body>
 
   <a target="_blank"
      href="https://bugzilla.mozilla.org/show_bug.cgi?id=634200"
-     title="crash [@ nsIFrame::GetStyleVisibility() ]">
+     title="crash [@ nsIFrame::StyleVisibility() ]">
     Mozilla Bug 634200
   </a>
   <p id="display"></p>
   <div id="content" style="display: none"></div>
   <pre id="test">
   </pre>
 
   <ol id="list">
diff --git a/content/base/src/Element.cpp b/content/base/src/Element.cpp
--- a/content/base/src/Element.cpp
+++ b/content/base/src/Element.cpp
@@ -328,17 +328,17 @@ Element::GetBindingURL(nsIDocument *aDoc
   // Get the computed -moz-binding directly from the style context
   nsPresContext *pctx = shell->GetPresContext();
   NS_ENSURE_TRUE(pctx, false);
 
   nsRefPtr<nsStyleContext> sc = pctx->StyleSet()->ResolveStyleFor(this,
                                                                   nullptr);
   NS_ENSURE_TRUE(sc, false);
 
-  *aResult = sc->GetStyleDisplay()->mBinding;
+  *aResult = sc->StyleDisplay()->mBinding;
 
   return true;
 }
 
 JSObject*
 Element::WrapObject(JSContext *aCx, JSObject *aScope,
                     bool *aTriedToWrap)
 {
@@ -588,17 +588,17 @@ static nsSize GetScrollRectSizeForOverfl
     return nsSize(0,0);
   }
 
   nsRect paddingRect = aFrame->GetPaddingRectRelativeToSelf();
   nsOverflowAreas overflowAreas(paddingRect, paddingRect);
   nsLayoutUtils::UnionChildOverflow(aFrame, overflowAreas);
   return nsLayoutUtils::GetScrolledRect(aFrame,
       overflowAreas.ScrollableOverflow(), paddingRect.Size(),
-      aFrame->GetStyleVisibility()->mDirection).Size();
+      aFrame->StyleVisibility()->mDirection).Size();
 }
 
 int32_t
 Element::ScrollHeight()
 {
   if (IsSVG())
     return 0;
 
@@ -636,17 +636,17 @@ Element::GetClientAreaRect()
   nsIFrame* styledFrame;
   nsIScrollableFrame* sf = GetScrollFrame(&styledFrame);
 
   if (sf) {
     return sf->GetScrollPortRect();
   }
 
   if (styledFrame &&
-      (styledFrame->GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_INLINE ||
+      (styledFrame->StyleDisplay()->mDisplay != NS_STYLE_DISPLAY_INLINE ||
        styledFrame->IsFrameOfType(nsIFrame::eReplaced))) {
     // Special case code to make client area work even when there isn't
     // a scroll view, see bug 180552, bug 227567.
     return styledFrame->GetPaddingRect() - styledFrame->GetPositionIgnoringScrolling();
   }
 
   // SVG nodes reach here and just return 0
   return nsRect(0, 0, 0, 0);
diff --git a/content/base/src/nsDocumentEncoder.cpp b/content/base/src/nsDocumentEncoder.cpp
--- a/content/base/src/nsDocumentEncoder.cpp
+++ b/content/base/src/nsDocumentEncoder.cpp
@@ -112,17 +112,17 @@ protected:
         nsIFrame* frame = content->GetPrimaryFrame();
         if (!frame) {
           if (aNode->IsNodeOfType(nsINode::eTEXT)) {
             // We have already checked that our parent is visible.
             return true;
           }
           return false;
         }
-        bool isVisible = frame->GetStyleVisibility()->IsVisible();
+        bool isVisible = frame->StyleVisibility()->IsVisible();
         if (!isVisible && aNode->IsNodeOfType(nsINode::eTEXT))
           return false;
       }
     }
     return true;
   }
 
   static bool IsTag(nsIContent* aContent, nsIAtom* aAtom);
diff --git a/content/canvas/src/CanvasRenderingContext2D.cpp b/content/canvas/src/CanvasRenderingContext2D.cpp
--- a/content/canvas/src/CanvasRenderingContext2D.cpp
+++ b/content/canvas/src/CanvasRenderingContext2D.cpp
@@ -2054,21 +2054,21 @@ CanvasRenderingContext2D::SetFont(const 
 
   nsRefPtr<nsStyleContext> sc =
       styleSet->ResolveStyleForRules(parentContext, rules);
   if (!sc) {
     error.Throw(NS_ERROR_FAILURE);
     return;
   }
 
-  const nsStyleFont* fontStyle = sc->GetStyleFont();
+  const nsStyleFont* fontStyle = sc->StyleFont();
 
   NS_ASSERTION(fontStyle, "Could not obtain font style");
 
-  nsIAtom* language = sc->GetStyleFont()->mLanguage;
+  nsIAtom* language = sc->StyleFont()->mLanguage;
   if (!language) {
     language = presShell->GetPresContext()->GetLanguageFromCharset();
   }
 
   // use CSS pixels instead of dev pixels to avoid being affected by page zoom
   const uint32_t aupcp = nsPresContext::AppUnitsPerCSSPixel();
   // un-zoom the font size to avoid being affected by text-only zoom
   //
@@ -2479,17 +2479,17 @@ CanvasRenderingContext2D::DrawOrMeasureT
     nsRefPtr<nsStyleContext> canvasStyle =
       nsComputedDOMStyle::GetStyleContextForElement(mCanvasElement,
                                                     nullptr,
                                                     presShell);
     if (!canvasStyle) {
       return NS_ERROR_FAILURE;
     }
 
-    isRTL = canvasStyle->GetStyleVisibility()->mDirection ==
+    isRTL = canvasStyle->StyleVisibility()->mDirection ==
       NS_STYLE_DIRECTION_RTL;
   } else {
     isRTL = GET_BIDI_OPTION_DIRECTION(document->GetBidiOptions()) == IBMBIDI_TEXTDIRECTION_RTL;
   }
 
   gfxFontGroup* currentFontStyle = GetCurrentFontStyle();
   NS_ASSERTION(currentFontStyle, "font group is null");
 
diff --git a/content/events/src/nsEventStateManager.cpp b/content/events/src/nsEventStateManager.cpp
--- a/content/events/src/nsEventStateManager.cpp
+++ b/content/events/src/nsEventStateManager.cpp
@@ -2479,17 +2479,17 @@ nsEventStateManager::DoScrollZoom(nsIFra
 }
 
 static nsIFrame*
 GetParentFrameToScroll(nsIFrame* aFrame)
 {
   if (!aFrame)
     return nullptr;
 
-  if (aFrame->GetStyleDisplay()->mPosition == NS_STYLE_POSITION_FIXED &&
+  if (aFrame->StyleDisplay()->mPosition == NS_STYLE_POSITION_FIXED &&
       nsLayoutUtils::IsReallyFixedPos(aFrame))
     return aFrame->PresContext()->GetPresShell()->GetRootScrollFrame();
 
   return aFrame->GetParent();
 }
 
 void
 nsEventStateManager::DispatchLegacyMouseScrollEvents(nsIFrame* aTargetFrame,
@@ -3125,17 +3125,17 @@ nsEventStateManager::PostHandleEvent(nsP
       }
 
       nsCOMPtr<nsIContent> activeContent;
       if (nsEventStatus_eConsumeNoDefault != *aStatus) {
         nsCOMPtr<nsIContent> newFocus;      
         bool suppressBlur = false;
         if (mCurrentTarget) {
           mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(newFocus));
-          const nsStyleUserInterface* ui = mCurrentTarget->GetStyleUserInterface();
+          const nsStyleUserInterface* ui = mCurrentTarget->StyleUserInterface();
           suppressBlur = (ui->mUserFocus == NS_STYLE_USER_FOCUS_IGNORE);
           activeContent = mCurrentTarget->GetContent();
         }
 
         nsIFrame* currFrame = mCurrentTarget;
 
         // When a root content which isn't editable but has an editable HTML
         // <body> element is clicked, we should redirect the focus to the
@@ -3160,17 +3160,17 @@ nsEventStateManager::PostHandleEvent(nsP
           }
         }
 
         // When the mouse is pressed, the default action is to focus the
         // target. Look for the nearest enclosing focusable frame.
         while (currFrame) {
           // If the mousedown happened inside a popup, don't
           // try to set focus on one of its containing elements
-          const nsStyleDisplay* display = currFrame->GetStyleDisplay();
+          const nsStyleDisplay* display = currFrame->StyleDisplay();
           if (display->mDisplay == NS_STYLE_DISPLAY_POPUP) {
             newFocus = nullptr;
             break;
           }
 
           int32_t tabIndexUnused;
           if (currFrame->IsFocusable(&tabIndexUnused, true)) {
             newFocus = currFrame->GetContent();
@@ -4785,17 +4785,17 @@ nsEventStateManager::SetContentState(nsI
   if (aState == NS_EVENT_STATE_HOVER || aState == NS_EVENT_STATE_ACTIVE) {
     // Hover and active are hierarchical
     updateAncestors = true;
 
     // check to see that this state is allowed by style. Check dragover too?
     // XXX Is this even what we want?
     if (mCurrentTarget)
     {
-      const nsStyleUserInterface* ui = mCurrentTarget->GetStyleUserInterface();
+      const nsStyleUserInterface* ui = mCurrentTarget->StyleUserInterface();
       if (ui->mUserInput == NS_STYLE_USER_INPUT_NONE)
         return false;
     }
 
     if (aState == NS_EVENT_STATE_ACTIVE) {
       if (aContent != mActiveContent) {
         notifyContent1 = aContent;
         notifyContent2 = mActiveContent;
diff --git a/content/html/content/src/HTMLOptGroupElement.cpp b/content/html/content/src/HTMLOptGroupElement.cpp
--- a/content/html/content/src/HTMLOptGroupElement.cpp
+++ b/content/html/content/src/HTMLOptGroupElement.cpp
@@ -69,17 +69,17 @@ HTMLOptGroupElement::PreHandleEvent(nsEv
   // Do not process any DOM events if the element is disabled
   // XXXsmaug This is not the right thing to do. But what is?
   if (HasAttr(kNameSpaceID_None, nsGkAtoms::disabled)) {
     return NS_OK;
   }
 
   nsIFrame* frame = GetPrimaryFrame();
   if (frame) {
-    const nsStyleUserInterface* uiStyle = frame->GetStyleUserInterface();
+    const nsStyleUserInterface* uiStyle = frame->StyleUserInterface();
     if (uiStyle->mUserInput == NS_STYLE_USER_INPUT_NONE ||
         uiStyle->mUserInput == NS_STYLE_USER_INPUT_DISABLED) {
       return NS_OK;
     }
   }
 
   return nsGenericHTMLElement::PreHandleEvent(aVisitor);
 }
diff --git a/content/html/content/src/nsGenericHTMLElement.cpp b/content/html/content/src/nsGenericHTMLElement.cpp
--- a/content/html/content/src/nsGenericHTMLElement.cpp
+++ b/content/html/content/src/nsGenericHTMLElement.cpp
@@ -465,18 +465,18 @@ nsGenericHTMLElement::GetOffsetRect(nsRe
       if (html_doc) {
         offsetParent = static_cast<nsHTMLDocument*>(html_doc.get())->GetBody();
       }
     }
   }
 
   // Subtract the parent border unless it uses border-box sizing.
   if (parent &&
-      parent->GetStylePosition()->mBoxSizing != NS_STYLE_BOX_SIZING_BORDER) {
-    const nsStyleBorder* border = parent->GetStyleBorder();
+      parent->StylePosition()->mBoxSizing != NS_STYLE_BOX_SIZING_BORDER) {
+    const nsStyleBorder* border = parent->StyleBorder();
     origin.x -= border->GetComputedBorderWidth(NS_SIDE_LEFT);
     origin.y -= border->GetComputedBorderWidth(NS_SIDE_TOP);
   }
 
   // XXX We should really consider subtracting out padding for
   // content-box sizing, but we should see what IE does....
 
   // Convert to pixels.
@@ -2694,17 +2694,17 @@ nsGenericHTMLFormElement::FormIdUpdated(
 }
 
 bool 
 nsGenericHTMLFormElement::IsElementDisabledForEvents(uint32_t aMessage, 
                                                     nsIFrame* aFrame)
 {
   bool disabled = IsDisabled();
   if (!disabled && aFrame) {
-    const nsStyleUserInterface* uiStyle = aFrame->GetStyleUserInterface();
+    const nsStyleUserInterface* uiStyle = aFrame->StyleUserInterface();
     disabled = uiStyle->mUserInput == NS_STYLE_USER_INPUT_NONE ||
       uiStyle->mUserInput == NS_STYLE_USER_INPUT_DISABLED;
 
   }
   return disabled && aMessage != NS_MOUSE_MOVE;
 }
 
 void
diff --git a/content/html/content/src/nsTextEditorState.cpp b/content/html/content/src/nsTextEditorState.cpp
--- a/content/html/content/src/nsTextEditorState.cpp
+++ b/content/html/content/src/nsTextEditorState.cpp
@@ -1598,17 +1598,17 @@ nsTextEditorState::InitializeRootNode()
   if (wrapCols >= 0) {
     classValue.AppendLiteral(" wrap");
   }
   if (!IsSingleLineTextControl()) {
     // We can't just inherit the overflow because setting visible overflow will
     // crash when the number of lines exceeds the height of the textarea and
     // setting -moz-hidden-unscrollable overflow (NS_STYLE_OVERFLOW_CLIP)
     // doesn't paint the caret for some reason.
-    const nsStyleDisplay* disp = mBoundFrame->GetStyleDisplay();
+    const nsStyleDisplay* disp = mBoundFrame->StyleDisplay();
     if (disp->mOverflowX != NS_STYLE_OVERFLOW_VISIBLE &&
         disp->mOverflowX != NS_STYLE_OVERFLOW_CLIP) {
       classValue.AppendLiteral(" inherit-overflow");
     }
   }
   nsresult rv = mRootNode->SetAttr(kNameSpaceID_None, nsGkAtoms::_class,
                                    classValue, false);
   NS_ENSURE_SUCCESS(rv, rv);
diff --git a/content/svg/content/src/SVGContentUtils.cpp b/content/svg/content/src/SVGContentUtils.cpp
--- a/content/svg/content/src/SVGContentUtils.cpp
+++ b/content/svg/content/src/SVGContentUtils.cpp
@@ -78,17 +78,17 @@ SVGContentUtils::GetFontSize(nsIFrame *a
 float
 SVGContentUtils::GetFontSize(nsStyleContext *aStyleContext)
 {
   NS_ABORT_IF_FALSE(aStyleContext, "NULL style context in GetFontSize");
 
   nsPresContext *presContext = aStyleContext->PresContext();
   NS_ABORT_IF_FALSE(presContext, "NULL pres context in GetFontSize");
 
-  nscoord fontSize = aStyleContext->GetStyleFont()->mSize;
+  nscoord fontSize = aStyleContext->StyleFont()->mSize;
   return nsPresContext::AppUnitsToFloatCSSPixels(fontSize) / 
          presContext->TextZoom();
 }
 
 float
 SVGContentUtils::GetFontXHeight(Element *aElement)
 {
   if (!aElement)
diff --git a/content/svg/content/src/nsSVGFilters.cpp b/content/svg/content/src/nsSVGFilters.cpp
--- a/content/svg/content/src/nsSVGFilters.cpp
+++ b/content/svg/content/src/nsSVGFilters.cpp
@@ -2758,18 +2758,18 @@ nsSVGFEFloodElement::Filter(nsSVGFilterI
                             const nsTArray<const Image*>& aSources,
                             const Image* aTarget,
                             const nsIntRect& aDataRect)
 {
   nsIFrame* frame = GetPrimaryFrame();
   if (!frame) return NS_ERROR_FAILURE;
   nsStyleContext* style = frame->StyleContext();
 
-  nscolor floodColor = style->GetStyleSVGReset()->mFloodColor;
-  float floodOpacity = style->GetStyleSVGReset()->mFloodOpacity;
+  nscolor floodColor = style->StyleSVGReset()->mFloodColor;
+  float floodOpacity = style->StyleSVGReset()->mFloodOpacity;
 
   gfxContext ctx(aTarget->mImage);
   ctx.SetColor(gfxRGBA(NS_GET_R(floodColor) / 255.0,
                        NS_GET_G(floodColor) / 255.0,
                        NS_GET_B(floodColor) / 255.0,
                        NS_GET_A(floodColor) / 255.0 * floodOpacity));
   ctx.Rectangle(aTarget->mFilterPrimitiveSubregion);
   ctx.Fill();
@@ -4989,17 +4989,17 @@ nsSVGFELightingElement::Filter(nsSVGFilt
   nsCOMPtr<nsIDOMSVGFEDistantLightElement> distantLight;
   nsCOMPtr<nsIDOMSVGFEPointLightElement> pointLight;
   nsCOMPtr<nsIDOMSVGFESpotLightElement> spotLight;
 
   nsIFrame* frame = GetPrimaryFrame();
   if (!frame) return NS_ERROR_FAILURE;
   nsStyleContext* style = frame->StyleContext();
 
-  nscolor lightColor = style->GetStyleSVGReset()->mLightingColor;
+  nscolor lightColor = style->StyleSVGReset()->mLightingColor;
 
   // find specified light  
   for (nsCOMPtr<nsIContent> child = nsINode::GetFirstChild();
        child;
        child = child->GetNextSibling()) {
     distantLight = do_QueryInterface(child);
     pointLight = do_QueryInterface(child);
     spotLight = do_QueryInterface(child);
diff --git a/content/svg/content/src/nsSVGFilters.h b/content/svg/content/src/nsSVGFilters.h
--- a/content/svg/content/src/nsSVGFilters.h
+++ b/content/svg/content/src/nsSVGFilters.h
@@ -194,17 +194,17 @@ protected:
   // testing whether the input 'aInputIndex' should be SRGB, or
   // if aInputIndex is -1 returns true if the output will be SRGB
   virtual bool OperatesOnSRGB(nsSVGFilterInstance* aInstance,
                                 int32_t aInputIndex, Image* aImage) {
     nsIFrame* frame = GetPrimaryFrame();
     if (!frame) return false;
 
     nsStyleContext* style = frame->StyleContext();
-    return style->GetStyleSVG()->mColorInterpolationFilters ==
+    return style->StyleSVG()->mColorInterpolationFilters ==
              NS_STYLE_COLOR_INTERPOLATION_SRGB;
   }
 
   // nsSVGElement specializations:
   virtual LengthAttributesInfo GetLengthInfo();
 
   // nsIDOMSVGFitlerPrimitiveStandardAttributes values
   enum { X, Y, WIDTH, HEIGHT };
diff --git a/content/xul/content/src/nsXULPopupListener.cpp b/content/xul/content/src/nsXULPopupListener.cpp
--- a/content/xul/content/src/nsXULPopupListener.cpp
+++ b/content/xul/content/src/nsXULPopupListener.cpp
@@ -227,17 +227,17 @@ nsXULPopupListener::FireFocusOnTargetCon
     // strong reference to keep this from going away between events
     // XXXbz between what events?  We don't use this local at all!
     nsRefPtr<nsPresContext> context = shell->GetPresContext();
  
     nsCOMPtr<nsIContent> content = do_QueryInterface(aTargetNode);
     nsIFrame* targetFrame = content->GetPrimaryFrame();
     if (!targetFrame) return NS_ERROR_FAILURE;
 
-    const nsStyleUserInterface* ui = targetFrame->GetStyleUserInterface();
+    const nsStyleUserInterface* ui = targetFrame->StyleUserInterface();
     bool suppressBlur = (ui->mUserFocus == NS_STYLE_USER_FOCUS_IGNORE);
 
     nsCOMPtr<nsIDOMElement> element;
     nsCOMPtr<nsIContent> newFocus = do_QueryInterface(content);
 
     nsIFrame* currFrame = targetFrame;
     // Look for the nearest enclosing focusable frame.
     while (currFrame) {
diff --git a/dom/base/nsFocusManager.cpp b/dom/base/nsFocusManager.cpp
--- a/dom/base/nsFocusManager.cpp
+++ b/dom/base/nsFocusManager.cpp
@@ -1455,17 +1455,17 @@ nsFocusManager::CheckIfFocusable(nsICont
   }
 
   // if this is a child frame content node, check if it is visible and
   // call the content node's IsFocusable method instead of the frame's
   // IsFocusable method. This skips checking the style system and ensures that
   // offscreen browsers can still be focused.
   nsIDocument* subdoc = doc->GetSubDocumentFor(aContent);
   if (subdoc && IsWindowVisible(subdoc->GetWindow())) {
-    const nsStyleUserInterface* ui = frame->GetStyleUserInterface();
+    const nsStyleUserInterface* ui = frame->StyleUserInterface();
     int32_t tabIndex = (ui->mUserFocus == NS_STYLE_USER_FOCUS_IGNORE ||
                         ui->mUserFocus == NS_STYLE_USER_FOCUS_NONE) ? -1 : 0;
     return aContent->IsFocusable(&tabIndex, aFlags & FLAG_BYMOUSE) ? aContent : nullptr;
   }
   
   return frame->IsFocusable(nullptr, aFlags & FLAG_BYMOUSE) ? aContent : nullptr;
 }
 
diff --git a/editor/libeditor/base/nsEditor.cpp b/editor/libeditor/base/nsEditor.cpp
--- a/editor/libeditor/base/nsEditor.cpp
+++ b/editor/libeditor/base/nsEditor.cpp
@@ -96,17 +96,17 @@
 #include "nsRange.h"                    // for nsRange
 #include "nsReadableUtils.h"            // for EmptyString, ToNewCString
 #include "nsString.h"                   // for nsAutoString, nsString, etc
 #include "nsStringFwd.h"                // for nsAFlatString
 #include "nsStyleConsts.h"              // for NS_STYLE_DIRECTION_RTL, etc
 #include "nsStyleContext.h"             // for nsStyleContext
 #include "nsStyleSheetTxns.h"           // for AddStyleSheetTxn, etc
 #include "nsStyleStruct.h"              // for nsStyleDisplay, nsStyleText, etc
-#include "nsStyleStructFwd.h"           // for nsIFrame::GetStyleUIReset, etc
+#include "nsStyleStructFwd.h"           // for nsIFrame::StyleUIReset, etc
 #include "nsTextEditUtils.h"            // for nsTextEditUtils
 #include "nsThreadUtils.h"              // for nsRunnable
 #include "nsTransactionManager.h"       // for nsTransactionManager
 #include "prtime.h"                     // for PR_Now
 
 class nsIOutputStream;
 class nsIParserService;
 class nsITransferable;
@@ -2102,17 +2102,17 @@ nsEditor::GetPreferredIMEState(IMEState 
   }
 
   nsCOMPtr<nsIContent> content = GetRoot();
   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
 
   nsIFrame* frame = content->GetPrimaryFrame();
   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
 
-  switch (frame->GetStyleUIReset()->mIMEMode) {
+  switch (frame->StyleUIReset()->mIMEMode) {
     case NS_STYLE_IME_MODE_AUTO:
       if (IsPasswordEditor())
         aState->mEnabled = IMEState::PASSWORD;
       break;
     case NS_STYLE_IME_MODE_DISABLED:
       // we should use password state for |ime-mode: disabled;|.
       aState->mEnabled = IMEState::PASSWORD;
       break;
@@ -3648,17 +3648,17 @@ IsElementVisible(dom::Element* aElement)
   // Now it might be that we have no frame because we're in a
   // display:none subtree, or it might be that we're just dealing with
   // lazy frame construction and it hasn't happened yet.  Check which
   // one it is.
   nsRefPtr<nsStyleContext> styleContext =
     nsComputedDOMStyle::GetStyleContextForElementNoFlush(aElement,
                                                          nullptr, nullptr);
   if (styleContext) {
-    return styleContext->GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_NONE;
+    return styleContext->StyleDisplay()->mDisplay != NS_STYLE_DISPLAY_NONE;
   }
   return false;
 }
 
 bool 
 nsEditor::IsEditable(nsIDOMNode *aNode)
 {
   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
@@ -3964,17 +3964,17 @@ nsEditor::IsPreformatted(nsIDOMNode *aNo
   {
     // Consider nodes without a style context to be NOT preformatted:
     // For instance, this is true of JS tags inside the body (which show
     // up as #text nodes but have no style context).
     *aResult = false;
     return NS_OK;
   }
 
-  const nsStyleText* styleText = elementStyle->GetStyleText();
+  const nsStyleText* styleText = elementStyle->StyleText();
 
   *aResult = styleText->WhiteSpaceIsSignificant();
   return NS_OK;
 }
 
 
 ///////////////////////////////////////////////////////////////////////////
 // SplitNodeDeep: this splits a node "deeply", splitting children as 
@@ -5051,17 +5051,17 @@ nsEditor::DetermineCurrentDirection()
   if (!(mFlags & (nsIPlaintextEditor::eEditorLeftToRight |
                   nsIPlaintextEditor::eEditorRightToLeft))) {
 
     nsIFrame* frame = rootElement->GetPrimaryFrame();
     NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
 
     // Set the flag here, to enable us to use the same code path below.
     // It will be flipped before returning from the function.
-    if (frame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
+    if (frame->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
       mFlags |= nsIPlaintextEditor::eEditorRightToLeft;
     } else {
       mFlags |= nsIPlaintextEditor::eEditorLeftToRight;
     }
   }
 
   return NS_OK;
 }
diff --git a/embedding/components/find/src/nsFind.cpp b/embedding/components/find/src/nsFind.cpp
--- a/embedding/components/find/src/nsFind.cpp
+++ b/embedding/components/find/src/nsFind.cpp
@@ -756,17 +756,17 @@ bool nsFind::IsVisibleNode(nsIDOMNode *a
     return false;
 
   nsIFrame *frame = content->GetPrimaryFrame();
   if (!frame) {
     // No frame! Not visible then.
     return false;
   }
 
-  return frame->GetStyleVisibility()->IsVisible();
+  return frame->StyleVisibility()->IsVisible();
 }
 
 bool nsFind::SkipNode(nsIContent* aContent)
 {
   nsIAtom *atom;
 
 #ifdef HAVE_BIDI_ITERATOR
   atom = aContent->Tag();
diff --git a/extensions/spellcheck/src/mozInlineSpellWordUtil.cpp b/extensions/spellcheck/src/mozInlineSpellWordUtil.cpp
--- a/extensions/spellcheck/src/mozInlineSpellWordUtil.cpp
+++ b/extensions/spellcheck/src/mozInlineSpellWordUtil.cpp
@@ -444,17 +444,17 @@ IsBreakElement(nsINode* aNode)
 
   // If we don't have a frame, we don't consider ourselves a break
   // element.  In particular, words can span us.
   if (!element->GetPrimaryFrame())
     return false;
 
   // Anything that's not an inline element is a break element.
   // XXXbz should replaced inlines be break elements, though?
-  return element->GetPrimaryFrame()->GetStyleDisplay()->mDisplay !=
+  return element->GetPrimaryFrame()->StyleDisplay()->mDisplay !=
     NS_STYLE_DISPLAY_INLINE;
 }
 
 struct CheckLeavingBreakElementClosure {
   bool          mLeftBreakElement;
 };
 
 static void
diff --git a/layout/base/nsBidiPresUtils.cpp b/layout/base/nsBidiPresUtils.cpp
--- a/layout/base/nsBidiPresUtils.cpp
+++ b/layout/base/nsBidiPresUtils.cpp
@@ -58,18 +58,18 @@ struct BidiParagraphData {
   void Init(nsBlockFrame *aBlockFrame)
   {
     mContentToFrameIndex.Init();
     mBidiEngine = new nsBidi();
     mPrevContent = nullptr;
     mParagraphDepth = 0;
 
     bool styleDirectionIsRTL =
-      (NS_STYLE_DIRECTION_RTL == aBlockFrame->GetStyleVisibility()->mDirection);
-    if (aBlockFrame->GetStyleTextReset()->mUnicodeBidi &
+      (NS_STYLE_DIRECTION_RTL == aBlockFrame->StyleVisibility()->mDirection);
+    if (aBlockFrame->StyleTextReset()->mUnicodeBidi &
         NS_STYLE_UNICODE_BIDI_PLAINTEXT) {
       // unicode-bidi: plaintext: the Bidi algorithm will determine the
       // directionality of the paragraph according to the first strong
       // directional character, defaulting to LTR if there is none.
       mParaLevel = NSBIDI_DEFAULT_LTR;
     } else {
       mParaLevel = styleDirectionIsRTL ? NSBIDI_RTL : NSBIDI_LTR;
     }
@@ -126,19 +126,19 @@ struct BidiParagraphData {
     mReset = true;
     mLogicalFrames.Clear();
     mLinePerFrame.Clear();
     mContentToFrameIndex.Clear();
     mBuffer.SetLength(0);
     mPrevFrame = aBpd->mPrevFrame;
     mParagraphDepth = aBpd->mParagraphDepth + 1;
 
-    const nsStyleTextReset* text = aBDIFrame->GetStyleTextReset();
+    const nsStyleTextReset* text = aBDIFrame->StyleTextReset();
     bool isRTL = (NS_STYLE_DIRECTION_RTL ==
-                  aBDIFrame->GetStyleVisibility()->mDirection);
+                  aBDIFrame->StyleVisibility()->mDirection);
 
     if (text->mUnicodeBidi & NS_STYLE_UNICODE_BIDI_PLAINTEXT) {
       mParaLevel = NSBIDI_DEFAULT_LTR;
     } else {
       mParaLevel = mParagraphDepth * 2;
       if (isRTL) ++mParaLevel;
     }
 
@@ -585,20 +585,20 @@ CreateContinuation(nsIFrame*  aFrame,
 nsresult
 nsBidiPresUtils::Resolve(nsBlockFrame* aBlockFrame)
 {
   BidiParagraphData bpd;
   bpd.Init(aBlockFrame);
 
   // Handle bidi-override being set on the block itself before calling
   // TraverseFrames.
-  const nsStyleTextReset* text = aBlockFrame->GetStyleTextReset();
+  const nsStyleTextReset* text = aBlockFrame->StyleTextReset();
   PRUnichar ch = 0;
   if (text->mUnicodeBidi & NS_STYLE_UNICODE_BIDI_OVERRIDE) {
-    const nsStyleVisibility* vis = aBlockFrame->GetStyleVisibility();
+    const nsStyleVisibility* vis = aBlockFrame->StyleVisibility();
     if (NS_STYLE_DIRECTION_RTL == vis->mDirection) {
       ch = kRLO;
     }
     else if (NS_STYLE_DIRECTION_LTR == vis->mDirection) {
       ch = kLRO;
     }
     if (ch != 0) {
       bpd.PushBidiControl(ch);
@@ -948,18 +948,18 @@ nsBidiPresUtils::TraverseFrames(nsBlockF
         nsPlaceholderFrame::GetRealFrameForPlaceholder(childFrame);
       if (realFrame->GetType() == nsGkAtoms::letterFrame) {
         frame = realFrame;
       }
     }
 
     PRUnichar ch = 0;
     if (frame->IsFrameOfType(nsIFrame::eBidiInlineContainer)) {
-      const nsStyleVisibility* vis = frame->GetStyleVisibility();
-      const nsStyleTextReset* text = frame->GetStyleTextReset();
+      const nsStyleVisibility* vis = frame->StyleVisibility();
+      const nsStyleTextReset* text = frame->StyleTextReset();
       if (text->mUnicodeBidi & NS_STYLE_UNICODE_BIDI_OVERRIDE) {
         if (NS_STYLE_DIRECTION_RTL == vis->mDirection) {
           ch = kRLO;
         }
         else if (NS_STYLE_DIRECTION_LTR == vis->mDirection) {
           ch = kLRO;
         }
       } else if (text->mUnicodeBidi & NS_STYLE_UNICODE_BIDI_EMBED) {
@@ -987,17 +987,17 @@ nsBidiPresUtils::TraverseFrames(nsBlockF
       nsIContent* content = frame->GetContent();
       aBpd->AppendFrame(frame, aLineIter, content);
 
       // Append the content of the frame to the paragraph buffer
       nsIAtom* frameType = frame->GetType();
       if (nsGkAtoms::textFrame == frameType) {
         if (content != aBpd->mPrevContent) {
           aBpd->mPrevContent = content;
-          if (!frame->GetStyleText()->NewlineIsSignificant()) {
+          if (!frame->StyleText()->NewlineIsSignificant()) {
             content->AppendTextTo(aBpd->mBuffer);
           } else {
             /*
              * For preformatted text we have to do bidi resolution on each line
              * separately. 
              */
             nsAutoString text;
             content->AppendTextTo(text);
@@ -1116,17 +1116,17 @@ nsBidiPresUtils::TraverseFrames(nsBlockF
           ResolveParagraphWithinBlock(aBlockFrame, aBpd);
         }
       }
     } else {
       // For a non-leaf frame, recurse into TraverseFrames
       nsIFrame* kid = frame->GetFirstPrincipalChild();
       nsIFrame* overflowKid = frame->GetFirstChild(nsIFrame::kOverflowList);
       if (kid || overflowKid) {
-        const nsStyleTextReset* text = frame->GetStyleTextReset();
+        const nsStyleTextReset* text = frame->StyleTextReset();
         if (text->mUnicodeBidi & NS_STYLE_UNICODE_BIDI_ISOLATE ||
             text->mUnicodeBidi & NS_STYLE_UNICODE_BIDI_PLAINTEXT) {
           // css "unicode-bidi: isolate" and html5 bdi: 
           //  resolve the element as a separate paragraph
           BidiParagraphData* subParagraph = aBpd->GetSubParagraph();
 
           /*
            * As at the beginning of the loop, it's important to check for
@@ -1236,17 +1236,17 @@ nsBidiPresUtils::GetFrameBaseLevel(nsIFr
 }
 
 void
 nsBidiPresUtils::IsLeftOrRightMost(nsIFrame*              aFrame,
                                    nsContinuationStates*  aContinuationStates,
                                    bool&                aIsLeftMost /* out */,
                                    bool&                aIsRightMost /* out */)
 {
-  const nsStyleVisibility* vis = aFrame->GetStyleVisibility();
+  const nsStyleVisibility* vis = aFrame->StyleVisibility();
   bool isLTR = (NS_STYLE_DIRECTION_LTR == vis->mDirection);
 
   /*
    * Since we lay out frames from left to right (in both LTR and RTL), visiting a
    * frame with 'mFirstVisualFrame == nullptr', means it's the first appearance of
    * one of its continuation chain frames on the line.
    * To determine if it's the last visual frame of its continuation chain on the line
    * or not, we count the number of frames of the chain on the line, and then reduce
@@ -1435,17 +1435,17 @@ nsBidiPresUtils::InitContinuationStates(
     }
   }
 }
 
 void
 nsBidiPresUtils::RepositionInlineFrames(BidiLineData *aBld,
                                         nsIFrame* aFirstChild)
 {
-  const nsStyleVisibility* vis = aFirstChild->GetStyleVisibility();
+  const nsStyleVisibility* vis = aFirstChild->StyleVisibility();
   bool isLTR = (NS_STYLE_DIRECTION_LTR == vis->mDirection);
   nscoord leftSpace = 0;
 
   // This method is called from nsBlockFrame::PlaceLine via the call to
   // bidiUtils->ReorderFrames, so this is guaranteed to be after the inlines
   // have been reflowed, which is required for GetUsedMargin/Border/Padding
   nsMargin margin = aFirstChild->GetUsedMargin();
   if (!aFirstChild->GetPrevContinuation() &&
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -1050,17 +1050,17 @@ nsFrameConstructorState::PushAbsoluteCon
 
   mAbsoluteItems = 
     nsAbsoluteItems(AdjustAbsoluteContainingBlock(aNewAbsoluteContainingBlock));
 
   /* See if we're wiring the fixed-pos and abs-pos lists together.  This happens iff
    * we're a transformed element.
    */
   mFixedPosIsAbsPos = aNewAbsoluteContainingBlock &&
-    aNewAbsoluteContainingBlock->GetStyleDisplay()->HasTransform(aNewAbsoluteContainingBlock);
+    aNewAbsoluteContainingBlock->StyleDisplay()->HasTransform(aNewAbsoluteContainingBlock);
 
   if (aNewAbsoluteContainingBlock) {
     aNewAbsoluteContainingBlock->MarkAsAbsoluteContainingBlock();
   }
 }
 
 void
 nsFrameConstructorState::PushFloatContainingBlock(nsIFrame* aNewFloatContainingBlock,
@@ -1130,17 +1130,17 @@ nsFrameConstructorState::AddChild(nsIFra
                                   bool aCanBePositioned,
                                   bool aCanBeFloated,
                                   bool aIsOutOfFlowPopup,
                                   bool aInsertAfter,
                                   nsIFrame* aInsertAfterFrame)
 {
   NS_PRECONDITION(!aNewFrame->GetNextSibling(), "Shouldn't happen");
   
-  const nsStyleDisplay* disp = aNewFrame->GetStyleDisplay();
+  const nsStyleDisplay* disp = aNewFrame->StyleDisplay();
   
   // The comments in GetGeometricParent regarding root table frames
   // all apply here, unfortunately.
 
   bool needPlaceholder = false;
   nsFrameState placeholderType;
   nsFrameItems* frameItems = &aFrameItems;
 #ifdef MOZ_XUL
@@ -1569,17 +1569,17 @@ nsCSSFrameConstructor::CreateGenConTextN
 already_AddRefed<nsIContent>
 nsCSSFrameConstructor::CreateGeneratedContent(nsFrameConstructorState& aState,
                                               nsIContent*     aParentContent,
                                               nsStyleContext* aStyleContext,
                                               uint32_t        aContentIndex)
 {
   // Get the content value
   const nsStyleContentData &data =
-    aStyleContext->GetStyleContent()->ContentAt(aContentIndex);
+    aStyleContext->StyleContent()->ContentAt(aContentIndex);
   nsStyleContentType type = data.mType;
 
   if (eStyleContentType_Image == type) {
     if (!data.mContent.mImage) {
       // CSS had something specified that couldn't be converted to an
       // image object
       return nullptr;
     }
@@ -1771,17 +1771,17 @@ nsCSSFrameConstructor::CreateGeneratedCo
   container->SetNativeAnonymous();
 
   rv = container->BindToTree(mDocument, aParentContent, aParentContent, true);
   if (NS_FAILED(rv)) {
     container->UnbindFromTree();
     return;
   }
 
-  uint32_t contentCount = pseudoStyleContext->GetStyleContent()->ContentCount();
+  uint32_t contentCount = pseudoStyleContext->StyleContent()->ContentCount();
   for (uint32_t contentIndex = 0; contentIndex < contentCount; contentIndex++) {
     nsCOMPtr<nsIContent> content =
       CreateGeneratedContent(aState, aParentContent, pseudoStyleContext,
                              contentIndex);
     if (content) {
       container->AppendChildTo(content, false);
     }
   }
@@ -1882,17 +1882,17 @@ nsCSSFrameConstructor::AdjustParentFrame
                                          const FrameConstructionData* aFCData,
                                          nsStyleContext*              aStyleContext)
 {
   NS_PRECONDITION(aStyleContext, "Must have child's style context");
   NS_PRECONDITION(aFCData, "Must have frame construction data");
 
   bool tablePart = ((aFCData->mBits & FCDATA_IS_TABLE_PART) != 0);
 
-  if (tablePart && aStyleContext->GetStyleDisplay()->mDisplay ==
+  if (tablePart && aStyleContext->StyleDisplay()->mDisplay ==
       NS_STYLE_DISPLAY_TABLE_CAPTION) {
     aParentFrame = AdjustCaptionParentFrame(aParentFrame);
   }
 }
 
 // Pull all the captions present in aItems out  into aCaptions
 static void
 PullOutCaptionFrames(nsFrameItems& aItems, nsFrameItems& aCaptions)
@@ -1939,17 +1939,17 @@ nsCSSFrameConstructor::ConstructTable(ns
   // Create the outer table frame which holds the caption and inner table frame
   nsIFrame* newFrame;
   if (kNameSpaceID_MathML == nameSpaceID)
     newFrame = NS_NewMathMLmtableOuterFrame(mPresShell, outerStyleContext);
   else
     newFrame = NS_NewTableOuterFrame(mPresShell, outerStyleContext);
 
   nsIFrame* geometricParent =
-    aState.GetGeometricParent(outerStyleContext->GetStyleDisplay(),
+    aState.GetGeometricParent(outerStyleContext->StyleDisplay(),
                               aParentFrame);
 
   // Init the table outer frame
   InitAndRestoreFrame(aState, content, geometricParent, nullptr, newFrame);  
 
   // Create the inner table frame
   nsIFrame* innerFrame;
   if (kNameSpaceID_MathML == nameSpaceID)
@@ -1973,17 +1973,17 @@ nsCSSFrameConstructor::ConstructTable(ns
     // Set mRootElementFrame before processing children.
     mRootElementFrame = newFrame;
   }
 
   nsFrameItems childItems;
 
   // Process children
   nsFrameConstructorSaveState absoluteSaveState;
-  const nsStyleDisplay* display = outerStyleContext->GetStyleDisplay();
+  const nsStyleDisplay* display = outerStyleContext->StyleDisplay();
 
   // Mark the table frame as an absolute container if needed
   newFrame->AddStateBits(NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN);
   if (display->IsPositioned(aParentFrame)) {
     aState.PushAbsoluteContainingBlock(newFrame, absoluteSaveState);
   }
   if (aItem.mFCData->mBits & FCDATA_USE_CHILD_ITEMS) {
     rv = ConstructFramesFromItemList(aState, aItem.mChildItems,
@@ -2257,17 +2257,17 @@ nsCSSFrameConstructor::PropagateScrollTo
 
   // Check the style on the document root element
   nsStyleSet *styleSet = mPresShell->StyleSet();
   nsRefPtr<nsStyleContext> rootStyle;
   rootStyle = styleSet->ResolveStyleFor(docElement, nullptr);
   if (!rootStyle) {
     return nullptr;
   }
-  if (CheckOverflow(presContext, rootStyle->GetStyleDisplay())) {
+  if (CheckOverflow(presContext, rootStyle->StyleDisplay())) {
     // tell caller we stole the overflow style from the root element
     return docElement;
   }
   
   // Don't look in the BODY for non-HTML documents or HTML documents
   // with non-HTML roots
   // XXX this should be earlier; we shouldn't even look at the document root
   // for non-HTML documents. Fix this once we support explicit CSS styling
@@ -2289,17 +2289,17 @@ nsCSSFrameConstructor::PropagateScrollTo
   }
 
   nsRefPtr<nsStyleContext> bodyStyle;
   bodyStyle = styleSet->ResolveStyleFor(bodyElement->AsElement(), rootStyle);
   if (!bodyStyle) {
     return nullptr;
   }
 
-  if (CheckOverflow(presContext, bodyStyle->GetStyleDisplay())) {
+  if (CheckOverflow(presContext, bodyStyle->StyleDisplay())) {
     // tell caller we stole the overflow style from the body element
     return bodyElement;
   }
 
   return nullptr;
 }
 
 nsresult
@@ -2346,17 +2346,17 @@ nsCSSFrameConstructor::ConstructDocEleme
   // siblings.
   aDocElement->UnsetFlags(ELEMENT_ALL_RESTYLE_FLAGS);
 
   // --------- CREATE AREA OR BOX FRAME -------
   nsRefPtr<nsStyleContext> styleContext;
   styleContext = mPresShell->StyleSet()->ResolveStyleFor(aDocElement,
                                                          nullptr);
 
-  const nsStyleDisplay* display = styleContext->GetStyleDisplay();
+  const nsStyleDisplay* display = styleContext->StyleDisplay();
 
   // Ensure that our XBL bindings are installed.
   if (display->mBinding) {
     // Get the XBL loader.
     nsresult rv;
     bool resolveStyle;
     
     nsXBLService* xblService = nsXBLService::GetInstance();
@@ -2375,17 +2375,17 @@ nsCSSFrameConstructor::ConstructDocEleme
       // after all of its kids' constructors.  So tell the binding
       // manager about it right now.
       mDocument->BindingManager()->AddToAttachedQueue(binding);
     }
 
     if (resolveStyle) {
       styleContext = mPresShell->StyleSet()->ResolveStyleFor(aDocElement,
                                                              nullptr);
-      display = styleContext->GetStyleDisplay();
+      display = styleContext->StyleDisplay();
     }
   }
 
   // --------- IF SCROLLABLE WRAP IN SCROLLFRAME --------
 
 #ifdef DEBUG
   NS_ASSERTION(!display->IsScrollableOverflow() || 
                state.mPresContext->IsPaginated() ||
@@ -2452,17 +2452,17 @@ nsCSSFrameConstructor::ConstructDocEleme
       static const FrameConstructionData rootSVGData = FCDATA_DECL(0, nullptr);
       nsRefPtr<nsStyleContext> extraRef(styleContext);
       FrameConstructionItem item(&rootSVGData, aDocElement,
                                  aDocElement->Tag(), kNameSpaceID_SVG,
                                  nullptr, extraRef.forget(), true);
 
       nsFrameItems frameItems;
       rv = ConstructOuterSVG(state, item, mDocElementContainingBlock,
-                             styleContext->GetStyleDisplay(),
+                             styleContext->StyleDisplay(),
                              frameItems, &contentFrame);
       if (NS_FAILED(rv))
         return rv;
       if (!contentFrame || frameItems.IsEmpty())
         return NS_ERROR_FAILURE;
       *aNewFrame = frameItems.FirstChild();
       NS_ASSERTION(frameItems.OnlyChild(), "multiple root element frames");
     } else {
@@ -2483,17 +2483,17 @@ nsCSSFrameConstructor::ConstructDocEleme
       nsRefPtr<nsStyleContext> extraRef(styleContext);
       FrameConstructionItem item(&rootTableData, aDocElement,
                                  aDocElement->Tag(), kNameSpaceID_None,
                                  nullptr, extraRef.forget(), true);
 
       nsFrameItems frameItems;
       // if the document is a table then just populate it.
       rv = ConstructTable(state, item, mDocElementContainingBlock,
-                          styleContext->GetStyleDisplay(),
+                          styleContext->StyleDisplay(),
                           frameItems, &contentFrame);
       if (NS_FAILED(rv))
         return rv;
       if (!contentFrame || frameItems.IsEmpty())
         return NS_ERROR_FAILURE;
       *aNewFrame = frameItems.FirstChild();
       NS_ASSERTION(frameItems.OnlyChild(), "multiple root element frames");
     } else {
@@ -3066,17 +3066,17 @@ nsCSSFrameConstructor::InitializeSelectF
                                              nsIFrame*                scrolledFrame,
                                              nsIContent*              aContent,
                                              nsIFrame*                aParentFrame,
                                              nsStyleContext*          aStyleContext,
                                              bool                     aBuildCombobox,
                                              PendingBinding*          aPendingBinding,
                                              nsFrameItems&            aFrameItems)
 {
-  const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
+  const nsStyleDisplay* display = aStyleContext->StyleDisplay();
 
   // Initialize it
   nsIFrame* geometricParent = aState.GetGeometricParent(display, aParentFrame);
     
   // We don't call InitAndRestoreFrame for scrollFrame because we can only
   // restore the frame state after its parts have been created (in particular,
   // the scrollable view). So we have to split Init and Restore.
 
@@ -3376,18 +3376,18 @@ nsCSSFrameConstructor::FindHTMLData(Elem
                "Unexpected parent for fieldset content anon box");
   if (aTag == nsGkAtoms::legend &&
       (!aParentFrame ||
        (aParentFrame->GetType() != nsGkAtoms::fieldSetFrame &&
         aParentFrame->StyleContext()->GetPseudo() !=
           nsCSSAnonBoxes::fieldsetContent) ||
        !aElement->GetParent() ||
        !aElement->GetParent()->IsHTML(nsGkAtoms::fieldset) ||
-       aStyleContext->GetStyleDisplay()->IsFloatingStyle() ||
-       aStyleContext->GetStyleDisplay()->IsAbsolutelyPositionedStyle())) {
+       aStyleContext->StyleDisplay()->IsFloatingStyle() ||
+       aStyleContext->StyleDisplay()->IsAbsolutelyPositionedStyle())) {
     // <legend> is only special inside fieldset, check both the frame tree
     // parent and content tree parent due to XBL issues. For floated or
     // absolutely positioned legends we want to construct by display type and
     // not do special legend stuff.
     // XXXbz it would be nice if we could just decide this based on the parent
     // tag, and hence just use a SIMPLE_TAG_CHAIN for legend below, but the
     // fact that with XBL we could end up with this legend element in some
     // totally weird insertion point makes that chancy, I think.
@@ -3603,17 +3603,17 @@ nsCSSFrameConstructor::ConstructFrameFro
   // Don't create a subdocument frame for iframes if we're creating extra frames
   if (aState.mCreatingExtraFrames && aItem.mContent->IsHTML() &&
       aItem.mContent->Tag() == nsGkAtoms::iframe)
   {
     return NS_OK;
   }
 
   nsStyleContext* const styleContext = aItem.mStyleContext;
-  const nsStyleDisplay* display = styleContext->GetStyleDisplay();
+  const nsStyleDisplay* display = styleContext->StyleDisplay();
   nsIContent* const content = aItem.mContent;
 
   // Push the content as a style ancestor now, so we don't have to do
   // it in our various full-constructor functions.  In particular,
   // since a number of full-constructor functions don't actually call
   // ProcessChildren in some cases (e.g. for CSS anonymous table boxes
   // or for situations where only anonymouse children are having
   // frames constructed), this is the best place to bottleneck the
@@ -3699,17 +3699,17 @@ nsCSSFrameConstructor::ConstructFrameFro
         return rv;
       }
 
       SetInitialSingleChild(newFrame, blockFrame);
 
       // Now figure out whether newFrame or blockFrame should be the
       // absolute container.  It should be the latter if it's
       // positioned, otherwise the former.
-      const nsStyleDisplay* blockDisplay = blockContext->GetStyleDisplay();
+      const nsStyleDisplay* blockDisplay = blockContext->StyleDisplay();
       if (blockDisplay->IsPositioned(blockFrame)) {
         maybeAbsoluteContainingBlockDisplay = blockDisplay;
         maybeAbsoluteContainingBlock = blockFrame;
       }
       
       // Our kids should go into the blockFrame
       newFrame = blockFrame;
     }
@@ -4152,32 +4152,32 @@ nsCSSFrameConstructor::FindXULMenubarDat
 }
 #endif /* XP_MACOSX */
 
 /* static */
 const nsCSSFrameConstructor::FrameConstructionData*
 nsCSSFrameConstructor::FindXULListBoxBodyData(Element* aElement,
                                               nsStyleContext* aStyleContext)
 {
-  if (aStyleContext->GetStyleDisplay()->mDisplay !=
+  if (aStyleContext->StyleDisplay()->mDisplay !=
         NS_STYLE_DISPLAY_GRID_GROUP) {
     return nullptr;
   }
 
   static const FrameConstructionData sListBoxBodyData =
     SCROLLABLE_XUL_FCDATA(NS_NewListBoxBodyFrame);
   return &sListBoxBodyData;
 }
 
 /* static */
 const nsCSSFrameConstructor::FrameConstructionData*
 nsCSSFrameConstructor::FindXULListItemData(Element* aElement,
                                            nsStyleContext* aStyleContext)
 {
-  if (aStyleContext->GetStyleDisplay()->mDisplay !=
+  if (aStyleContext->StyleDisplay()->mDisplay !=
         NS_STYLE_DISPLAY_GRID_LINE) {
     return nullptr;
   }
 
   static const FrameConstructionData sListItemData =
     SCROLLABLE_XUL_FCDATA(NS_NewListItemFrame);
   return &sListItemData;
 }
@@ -4232,17 +4232,17 @@ nsCSSFrameConstructor::BeginBuildingScro
 
   nsRefPtr<nsStyleContext> contentStyle = aContentStyle;
 
   if (!gfxScrollFrame) {
     // Build a XULScrollFrame when the child is a box, otherwise an
     // HTMLScrollFrame
     // XXXbz this is the lone remaining consumer of IsXULDisplayType.
     // I wonder whether we can eliminate that somehow.
-    if (IsXULDisplayType(aContentStyle->GetStyleDisplay())) {
+    if (IsXULDisplayType(aContentStyle->StyleDisplay())) {
       gfxScrollFrame = NS_NewXULScrollFrame(mPresShell, contentStyle, aIsRoot);
     } else {
       gfxScrollFrame = NS_NewHTMLScrollFrame(mPresShell, contentStyle, aIsRoot);
     }
 
     InitAndRestoreFrame(aState, aContent, aParentFrame, nullptr, gfxScrollFrame);
   }
 
@@ -4479,17 +4479,17 @@ nsCSSFrameConstructor::ConstructScrollab
 
   // Create our block frame
   // pass a temporary stylecontext, the correct one will be set later
   nsIFrame* scrolledFrame =
     NS_NewBlockFormattingContext(mPresShell, styleContext);
 
   nsFrameItems blockItem;
   nsresult rv = ConstructBlock(aState,
-                               scrolledContentStyle->GetStyleDisplay(), content,
+                               scrolledContentStyle->StyleDisplay(), content,
                                *aNewFrame, *aNewFrame, scrolledContentStyle,
                                &scrolledFrame, blockItem,
                                aDisplay->IsPositioned(scrolledFrame),
                                aItem.mPendingBinding);
   if (MOZ_UNLIKELY(NS_FAILED(rv))) {
     // XXXbz any cleanup needed here?
     return rv;
   }
@@ -4685,17 +4685,17 @@ nsCSSFrameConstructor::FindMathMLData(El
   if (aNameSpaceID != kNameSpaceID_MathML) 
     return nullptr;
 
   // Handle <math> specially, because it sometimes produces inlines
   if (aTag == nsGkAtoms::math) {
     // This needs to match the test in EnsureBlockDisplay in
     // nsRuleNode.cpp.  Though the behavior here for the display:table
     // case is pretty weird...
-    if (aStyleContext->GetStyleDisplay()->IsBlockOutsideStyle()) {
+    if (aStyleContext->StyleDisplay()->IsBlockOutsideStyle()) {
       static const FrameConstructionData sBlockMathData =
         FCDATA_DECL(FCDATA_FORCE_NULL_ABSPOS_CONTAINER |
                     FCDATA_WRAP_KIDS_IN_BLOCKS,
                     NS_CreateNewMathMLmathBlockFrame);
       return &sBlockMathData;
     }
 
     static const FrameConstructionData sInlineMathData =
@@ -4756,17 +4756,17 @@ nsCSSFrameConstructor::ConstructOuterSVG
   nsStyleContext* const styleContext = aItem.mStyleContext;
 
   nsresult rv = NS_OK;
 
   // Create the nsSVGOuterSVGFrame:
   nsIFrame* newFrame = NS_NewSVGOuterSVGFrame(mPresShell, styleContext);
 
   nsIFrame* geometricParent =
-    aState.GetGeometricParent(styleContext->GetStyleDisplay(),
+    aState.GetGeometricParent(styleContext->StyleDisplay(),
                               aParentFrame);
 
   InitAndRestoreFrame(aState, content, geometricParent, nullptr, newFrame);
 
   // Create the pseudo SC for the anonymous wrapper child as a child of the SC:
   nsRefPtr<nsStyleContext> scForAnon;
   scForAnon = mPresShell->StyleSet()->
     ResolveAnonymousBoxStyle(nsCSSAnonBoxes::mozSVGOuterSVGAnonChild,
@@ -5083,17 +5083,17 @@ nsCSSFrameConstructor::AddPageBreakItem(
   // that's easier to re-resolve and it doesn't matter in practice.
   // (Getting different parents can result in framechange hints, e.g.,
   // for user-modify.)
   pseudoStyle =
     mPresShell->StyleSet()->
       ResolveAnonymousBoxStyle(nsCSSAnonBoxes::pageBreak,
                                aMainStyleContext->GetParent());
 
-  NS_ASSERTION(pseudoStyle->GetStyleDisplay()->mDisplay ==
+  NS_ASSERTION(pseudoStyle->StyleDisplay()->mDisplay ==
                  NS_STYLE_DISPLAY_BLOCK, "Unexpected display");
 
   static const FrameConstructionData sPageBreakData =
     FCDATA_DECL(FCDATA_SKIP_FRAMESET, NS_NewPageBreakFrame);
 
   // Lie about the tag and namespace so we don't trigger anything
   // interesting during frame construction.
   aItems.AppendItem(&sPageBreakData, aContent, nsCSSAnonBoxes::pageBreak,
@@ -5212,17 +5212,17 @@ nsCSSFrameConstructor::AddFrameConstruct
 {
   NS_PRECONDITION(aContent->IsNodeOfType(nsINode::eTEXT) ||
                   aContent->IsElement(),
                   "Shouldn't get anything else here!");
 
   // The following code allows the user to specify the base tag
   // of an element using XBL.  XUL and HTML objects (like boxes, menus, etc.)
   // can then be extended arbitrarily.
-  const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
+  const nsStyleDisplay* display = aStyleContext->StyleDisplay();
   nsRefPtr<nsStyleContext> styleContext(aStyleContext);
   PendingBinding* pendingBinding = nullptr;
   if ((aFlags & ITEM_ALLOW_XBL_BASE) && display->mBinding)
   {
     // Ensure that our XBL bindings are installed.
 
     nsXBLService* xblService = nsXBLService::GetInstance();
     if (!xblService)
@@ -5243,17 +5243,17 @@ nsCSSFrameConstructor::AddFrameConstruct
       pendingBinding = newPendingBinding;
       // aState takes over owning newPendingBinding
       aState.AddPendingBinding(newPendingBinding.forget());
     }
 
     if (resolveStyle) {
       styleContext =
         ResolveStyleContext(styleContext->GetParent(), aContent, &aState);
-      display = styleContext->GetStyleDisplay();
+      display = styleContext->StyleDisplay();
       aStyleContext = styleContext;
     }
 
     aTag = mDocument->BindingManager()->ResolveTag(aContent, &aNameSpaceID);
   }
 
   bool isGeneratedContent = ((aFlags & ITEM_IS_GENERATED_CONTENT) != 0);
 
@@ -5426,17 +5426,17 @@ nsCSSFrameConstructor::AddFrameConstruct
     // Compute a boolean isInline which is guaranteed to be false for blocks
     // (but may also be false for some inlines).
     bool isInline =
       // Table-internal things are inline-outside if and only if they're kids of
       // inlines, since they'll trigger construction of inline-table
       // pseudos.
       ((bits & FCDATA_IS_TABLE_PART) &&
        (!aParentFrame || // No aParentFrame means inline
-        aParentFrame->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_INLINE)) ||
+        aParentFrame->StyleDisplay()->mDisplay == NS_STYLE_DISPLAY_INLINE)) ||
       // Things that are inline-outside but aren't inline frames are inline
       (aParentFrame ? display->IsInlineOutside(aParentFrame) :
                       display->IsInlineOutsideStyle()) ||
       // Popups that are certainly out of flow.
       isPopup;
 
     // Set mIsAllInline conservatively.  It just might be that even an inline
     // that has mIsAllInline false doesn't need an {ib} split.  So this is just
@@ -5575,17 +5575,17 @@ nsCSSFrameConstructor::ConstructFramesFr
     // container's frame construction item is marked with
     // mIsGeneratedContent, and we might not have an aParentFrame.)
     // We don't do it for content that may have XBL anonymous siblings,
     // because they make it difficult to correctly create the frame
     // due to dynamic changes.
     // We don't do it for SVG text, since we might need to position and
     // measure the white space glyphs due to x/y/dx/dy attributes.
     if (AtLineBoundary(aIter) &&
-        !styleContext->GetStyleText()->WhiteSpaceOrNewlineIsSignificant() &&
+        !styleContext->StyleText()->WhiteSpaceOrNewlineIsSignificant() &&
         aIter.List()->ParentHasNoXBLChildren() &&
         !(aState.mAdditionalStateBits & NS_FRAME_GENERATED_CONTENT) &&
         (item.mFCData->mBits & FCDATA_IS_LINE_PARTICIPANT) &&
         !(item.mFCData->mBits & FCDATA_IS_SVG_TEXT) &&
         item.IsWhitespace(aState))
       return NS_OK;
 
     return ConstructTextFrame(item.mFCData, aState, item.mContent,
@@ -5687,17 +5687,17 @@ nsCSSFrameConstructor::GetAbsoluteContai
     // block (see the exceptions below).  Otherwise, we'll start looking at the
     // parent frame, unless we're dealing with a scrollframe.
     // Scrollframes are special since they're not positioned, but their
     // scrolledframe might be.  So, we need to check this special case to return
     // the correct containing block (the scrolledframe) in that case.
     // If we're looking for a fixed-pos containing block and the frame is
     // not transformed, skip it.
     if (!frame->IsPositioned() ||
-        (aType == FIXED_POS && !frame->GetStyleDisplay()->HasTransform(frame))) {
+        (aType == FIXED_POS && !frame->StyleDisplay()->HasTransform(frame))) {
       continue;
     }
     nsIFrame* absPosCBCandidate = nullptr;
     if (frame->GetType() == nsGkAtoms::scrollFrame) {
       nsIScrollableFrame* scrollFrame = do_QueryFrame(frame);
       absPosCBCandidate = scrollFrame->GetScrolledFrame();
     } else {
       // Only first continuations can be containing blocks.
@@ -5903,17 +5903,17 @@ nsCSSFrameConstructor::AppendFramesToPar
     FindFirstBlock(firstBlockEnumerator);
 
     nsFrameList inlineKids = aFrameList.ExtractHead(firstBlockEnumerator);
     if (!inlineKids.IsEmpty()) {
       AppendFrames(aParentFrame, kPrincipalList, inlineKids);
     }
 
     if (!aFrameList.IsEmpty()) {
-      const nsStyleDisplay* parentDisplay = aParentFrame->GetStyleDisplay();
+      const nsStyleDisplay* parentDisplay = aParentFrame->StyleDisplay();
       bool positioned =
         parentDisplay->mPosition == NS_STYLE_POSITION_RELATIVE &&
         !aParentFrame->IsSVGText();
       nsFrameItems ibSiblings;
       CreateIBSiblings(aState, aParentFrame, positioned, aFrameList,
                        ibSiblings);
 
       // Make sure to trigger reflow of the inline that used to be our
@@ -5973,17 +5973,17 @@ nsCSSFrameConstructor::IsValidSibling(ns
       if (!styleParent) {
         NS_NOTREACHED("Shouldn't happen");
         return false;
       }
       // XXXbz when this code is killed, the state argument to
       // ResolveStyleContext can be made non-optional.
       styleContext = ResolveStyleContext(styleParent, aContent, nullptr);
       if (!styleContext) return false;
-      const nsStyleDisplay* display = styleContext->GetStyleDisplay();
+      const nsStyleDisplay* display = styleContext->StyleDisplay();
       aDisplay = display->mDisplay;
     }
     if (nsGkAtoms::menuFrame == parentType) {
       return
         (NS_STYLE_DISPLAY_POPUP == aDisplay) ==
         (NS_STYLE_DISPLAY_POPUP == siblingDisplay);
     }
     // To have decent performance we want to return false in cases in which
@@ -7927,22 +7927,22 @@ DoApplyRenderingChangeToTree(nsIFrame* a
   }
 }
 
 static void
 ApplyRenderingChangeToTree(nsPresContext* aPresContext,
                            nsIFrame* aFrame,
                            nsChangeHint aChange)
 {
-  // We check GetStyleDisplay()->HasTransform() in addition to checking
+  // We check StyleDisplay()->HasTransform() in addition to checking
   // IsTransformed() since we can get here for some frames that don't support
   // CSS transforms.
   NS_ASSERTION(!(aChange & nsChangeHint_UpdateTransformLayer) ||
                aFrame->IsTransformed() ||
-               aFrame->GetStyleDisplay()->HasTransformStyle(),
+               aFrame->StyleDisplay()->HasTransformStyle(),
                "Unexpected UpdateTransformLayer hint");
 
   nsIPresShell *shell = aPresContext->PresShell();
   if (shell->IsPaintingSuppressed()) {
     // Don't allow synchronous rendering changes when painting is turned off.
     aChange = NS_SubtractHint(aChange, nsChangeHint_RepaintFrame);
     if (!aChange) {
       return;
@@ -8145,17 +8145,17 @@ FrameHasPositionedPlaceholderDescendants
            !childFrames.AtEnd(); childFrames.Next()) {
         nsIFrame* f = childFrames.get();
         if (f->GetType() == nsGkAtoms::placeholderFrame) {
           nsIFrame* outOfFlow = nsPlaceholderFrame::GetRealFrameForPlaceholder(f);
           // If SVG text frames could appear here, they could confuse us since
           // they ignore their position style ... but they can't.
           NS_ASSERTION(!outOfFlow->IsSVGText(),
                        "SVG text frames can't be out of flow");
-          if (aPositionMask & (1 << outOfFlow->GetStyleDisplay()->mPosition)) {
+          if (aPositionMask & (1 << outOfFlow->StyleDisplay()->mPosition)) {
             return true;
           }
         }
         if (FrameHasPositionedPlaceholderDescendants(f, aPositionMask)) {
           return true;
         }
       }
     }
@@ -8422,18 +8422,18 @@ nsCSSFrameConstructor::RestyleElement(El
 
   // If we're restyling the root element and there are 'rem' units in
   // use, handle dynamic changes to the definition of a 'rem' here.
   if (GetPresContext()->UsesRootEMUnits() && aPrimaryFrame) {
     nsStyleContext *oldContext = aPrimaryFrame->StyleContext();
     if (!oldContext->GetParent()) { // check that we're the root element
       nsRefPtr<nsStyleContext> newContext = mPresShell->StyleSet()->
         ResolveStyleFor(aElement, nullptr /* == oldContext->GetParent() */);
-      if (oldContext->GetStyleFont()->mFont.size !=
-          newContext->GetStyleFont()->mFont.size) {
+      if (oldContext->StyleFont()->mFont.size !=
+          newContext->StyleFont()->mFont.size) {
         // The basis for 'rem' units has changed.
         newContext = nullptr;
         DoRebuildAllStyleData(aRestyleTracker, nsChangeHint(0));
         if (aMinHint == 0) {
           return;
         }
         aPrimaryFrame = aElement->GetPrimaryFrame();
       }
@@ -8481,17 +8481,17 @@ nsCSSFrameConstructor::ContentStateChang
     // If it's generated content, ignore LOADING/etc state changes on it.
     if (!primaryFrame->IsGeneratedContentFrame() &&
         aStateMask.HasAtLeastOneOfStates(NS_EVENT_STATE_BROKEN |
                                          NS_EVENT_STATE_USERDISABLED |
                                          NS_EVENT_STATE_SUPPRESSED |
                                          NS_EVENT_STATE_LOADING)) {
       hint = nsChangeHint_ReconstructFrame;
     } else {
-      uint8_t app = primaryFrame->GetStyleDisplay()->mAppearance;
+      uint8_t app = primaryFrame->StyleDisplay()->mAppearance;
       if (app) {
         nsITheme *theme = presContext->GetTheme();
         if (theme && theme->ThemeSupportsWidget(presContext,
                                                 primaryFrame, app)) {
           bool repaint = false;
           theme->WidgetStateChanged(primaryFrame, app, nullptr, &repaint);
           if (repaint) {
             NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
@@ -8588,17 +8588,17 @@ nsCSSFrameConstructor::AttributeChanged(
         rootBox->AddTooltipSupport(aElement);
     }
   }
 
 #endif // MOZ_XUL
 
   if (primaryFrame) {
     // See if we have appearance information for a theme.
-    const nsStyleDisplay* disp = primaryFrame->GetStyleDisplay();
+    const nsStyleDisplay* disp = primaryFrame->StyleDisplay();
     if (disp->mAppearance) {
       nsPresContext* presContext = mPresShell->GetPresContext();
       nsITheme *theme = presContext->GetTheme();
       if (theme && theme->ThemeSupportsWidget(presContext, primaryFrame, disp->mAppearance)) {
         bool repaint = false;
         theme->WidgetStateChanged(primaryFrame, disp->mAppearance, aAttribute, &repaint);
         if (repaint)
           NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
@@ -9195,17 +9195,17 @@ nsCSSFrameConstructor::MaybeRecreateFram
     return NS_OK;
   }
 
   // The parent has a frame, so try resolving a new context.
   nsRefPtr<nsStyleContext> newContext = mPresShell->StyleSet()->
     ResolveStyleFor(aElement, oldContext->GetParent());
 
   ChangeUndisplayedContent(aElement, newContext);
-  const nsStyleDisplay* disp = newContext->GetStyleDisplay();
+  const nsStyleDisplay* disp = newContext->StyleDisplay();
   if (disp->mDisplay == NS_STYLE_DISPLAY_NONE) {
     // We can skip trying to recreate frames here, but only if our style
     // context does not have a binding URI that differs from our old one.
     // Otherwise, we should try to recreate, because we may want to apply the
     // new binding
     if (!disp->mBinding) {
       return NS_OK;
     }
@@ -9728,17 +9728,17 @@ nsCSSFrameConstructor::CreateNeededAnonF
                                 pseudoType,
                                 iter.item().mNameSpaceID,
                                 // no pending binding
                                 nullptr,
                                 wrapperStyle.forget(),
                                 true);
 
     newItem->mIsAllInline = newItem->mHasInlineEnds =
-      newItem->mStyleContext->GetStyleDisplay()->IsInlineOutsideStyle();
+      newItem->mStyleContext->StyleDisplay()->IsInlineOutsideStyle();
     newItem->mIsBlock = !newItem->mIsAllInline;
 
     NS_ABORT_IF_FALSE(!newItem->mIsAllInline && newItem->mIsBlock,
                       "expecting anonymous flex items to be block-level "
                       "(this will make a difference when we encounter "
                       "'flex-align: baseline')");
 
     // Anonymous flex items induce line boundaries around their
@@ -9914,17 +9914,17 @@ nsCSSFrameConstructor::CreateNeededTable
     }
 
     const PseudoParentData& pseudoData = sPseudoParentData[wrapperType];
     nsIAtom* pseudoType = *pseudoData.mPseudoType;
     nsStyleContext* parentStyle = aParentFrame->StyleContext();
     nsIContent* parentContent = aParentFrame->GetContent();
 
     if (pseudoType == nsCSSAnonBoxes::table &&
-        parentStyle->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_INLINE) {
+        parentStyle->StyleDisplay()->mDisplay == NS_STYLE_DISPLAY_INLINE) {
       pseudoType = nsCSSAnonBoxes::inlineTable;
     }
 
     nsRefPtr<nsStyleContext> wrapperStyle =
       mPresShell->StyleSet()->ResolveAnonymousBoxStyle(pseudoType, parentStyle);
     FrameConstructionItem* newItem =
       new FrameConstructionItem(&pseudoData.mFCData,
                                 // Use the content of our parent frame
@@ -9941,17 +9941,17 @@ nsCSSFrameConstructor::CreateNeededTable
                                 true);
 
     // Here we're cheating a tad... technically, table-internal items should be
     // inline if aParentFrame is inline, but they'll get wrapped in an
     // inline-table in the end, so it'll all work out.  In any case, arguably
     // we don't need to maintain this state at this point... but it's better
     // to, I guess.
     newItem->mIsAllInline = newItem->mHasInlineEnds =
-      newItem->mStyleContext->GetStyleDisplay()->IsInlineOutsideStyle();
+      newItem->mStyleContext->StyleDisplay()->IsInlineOutsideStyle();
 
     // Table pseudo frames always induce line boundaries around their
     // contents.
     newItem->mChildItems.SetLineBoundaryAtStart(true);
     newItem->mChildItems.SetLineBoundaryAtEnd(true);
     // The parent of the items in aItems is also the parent of the items
     // in mChildItems
     newItem->mChildItems.SetParentHasNoXBLChildren(
@@ -10165,17 +10165,17 @@ nsCSSFrameConstructor::ProcessChildren(n
   if (aFrame->IsBoxFrame() && itemsToConstruct.AnyItemsNeedBlockParent()) {
     // XXXbz we could do this on the FrameConstructionItemList level,
     // no?  And if we cared we could look through the item list
     // instead of groveling through the framelist here..
     nsIContent *badKid = AnyKidsNeedBlockParent(aFrameItems.FirstChild());
     nsDependentAtomString parentTag(aContent->Tag()), kidTag(badKid->Tag());
     const PRUnichar* params[] = { parentTag.get(), kidTag.get() };
     nsStyleContext *frameStyleContext = aFrame->StyleContext();
-    const nsStyleDisplay *display = frameStyleContext->GetStyleDisplay();
+    const nsStyleDisplay *display = frameStyleContext->StyleDisplay();
     const char *message =
       (display->mDisplay == NS_STYLE_DISPLAY_INLINE_BOX)
         ? "NeededToWrapXULInlineBox" : "NeededToWrapXUL";
     nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
                                     "FrameConstructor", mDocument,
                                     nsContentUtils::eXUL_PROPERTIES,
                                     message,
                                     params, ArrayLength(params));
@@ -10547,17 +10547,17 @@ nsCSSFrameConstructor::CreateFloatingLet
   nsStyleSet *styleSet = mPresShell->StyleSet();
 
   letterFrame = NS_NewFirstLetterFrame(mPresShell, aStyleContext);
   // We don't want to use a text content for a non-text frame (because we want
   // its primary frame to be a text frame).  So use its parent for the
   // first-letter.
   nsIContent* letterContent = aTextContent->GetParent();
   nsIFrame* containingBlock = aState.GetGeometricParent(
-    aStyleContext->GetStyleDisplay(), aParentFrame);
+    aStyleContext->StyleDisplay(), aParentFrame);
   InitAndRestoreFrame(aState, letterContent, containingBlock, nullptr,
                       letterFrame);
 
   // Init the text frame to refer to the letter frame. Make sure we
   // get a proper style context for it (the one passed in is for the
   // letter frame and will have the float property set on it; the text
   // frame shouldn't have that set).
   nsRefPtr<nsStyleContext> textSC;
@@ -10659,17 +10659,17 @@ nsCSSFrameConstructor::CreateLetterFrame
     NS_ASSERTION(aBlockContinuation == GetFloatContainingBlock(aParentFrame),
                  "Containing block is confused");
     nsFrameConstructorState state(mPresShell,
                                   GetAbsoluteContainingBlock(aParentFrame, FIXED_POS),
                                   GetAbsoluteContainingBlock(aParentFrame, ABS_POS),
                                   aBlockContinuation);
 
     // Create the right type of first-letter frame
-    const nsStyleDisplay* display = sc->GetStyleDisplay();
+    const nsStyleDisplay* display = sc->StyleDisplay();
     if (display->IsFloating(aParentFrame)) {
       // Make a floating first-letter frame
       CreateFloatingLetterFrame(state, aBlockFrame, aTextContent, textFrame,
                                 blockContent, aParentFrame, sc, aResult);
     }
     else {
       // Make an inflow first-letter frame
       nsIFrame* letterFrame = NS_NewFirstLetterFrame(mPresShell, sc);
@@ -11052,17 +11052,17 @@ nsCSSFrameConstructor::CreateListBoxCont
     // If we ever initialize the ancestor filter on |state|, make sure
     // to push the right parent!
 
     nsRefPtr<nsStyleContext> styleContext;
     styleContext = ResolveStyleContext(aParentFrame, aChild, &state);
 
     // Pre-check for display "none" - only if we find that, do we create
     // any frame at all
-    const nsStyleDisplay* display = styleContext->GetStyleDisplay();
+    const nsStyleDisplay* display = styleContext->StyleDisplay();
 
     if (NS_STYLE_DISPLAY_NONE == display->mDisplay) {
       *aNewFrame = nullptr;
       return NS_OK;
     }
 
     BeginUpdate();
 
@@ -11117,17 +11117,17 @@ nsCSSFrameConstructor::ConstructBlock(ns
                                       bool                     aAbsPosContainer,
                                       PendingBinding*          aPendingBinding)
 {
   // Create column wrapper if necessary
   nsIFrame* blockFrame = *aNewFrame;
   NS_ASSERTION(blockFrame->GetType() == nsGkAtoms::blockFrame, "not a block frame?");
   nsIFrame* parent = aParentFrame;
   nsRefPtr<nsStyleContext> blockStyle = aStyleContext;
-  const nsStyleColumn* columns = aStyleContext->GetStyleColumn();
+  const nsStyleColumn* columns = aStyleContext->StyleColumn();
 
   if (columns->mColumnCount != NS_STYLE_COLUMN_COUNT_AUTO
       || columns->mColumnWidth.GetUnit() != eStyleUnit_Auto) {
     nsIFrame* columnSetFrame = nullptr;
     columnSetFrame = NS_NewColumnSetFrame(mPresShell, aStyleContext, 0);
 
     InitAndRestoreFrame(aState, aContent, aParentFrame, nullptr, columnSetFrame);
     blockStyle = mPresShell->StyleSet()->
@@ -12443,17 +12443,17 @@ nsCSSFrameConstructor::FrameConstruction
   NeedsAnonFlexItem(const nsFrameConstructorState& aState)
 {
   if (mFCData->mBits & FCDATA_IS_LINE_PARTICIPANT) {
     // This will be an inline non-replaced box.
     return true;
   }
 
   if (!(mFCData->mBits & FCDATA_DISALLOW_OUT_OF_FLOW) &&
-      aState.GetGeometricParent(mStyleContext->GetStyleDisplay(), nullptr)) {
+      aState.GetGeometricParent(mStyleContext->StyleDisplay(), nullptr)) {
     // We're abspos or fixedpos, which means we'll spawn a placeholder which
     // we'll need to wrap in an anonymous flex item.  So, we just treat
     // _this_ frame as if _it_ needs to be wrapped in an anonymous flex item,
     // and then when we spawn the placeholder, it'll end up in the right spot.
     return true;
   }
 
   return false;
@@ -12607,34 +12607,34 @@ nsCSSFrameConstructor::RecomputePosition
   // have a view somewhere in their descendants, because the corresponding view
   // needs to be repositioned properly as well.
   if (aFrame->HasView() ||
       (aFrame->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW)) {
     StyleChangeReflow(aFrame, nsChangeHint_NeedReflow);
     return false;
   }
 
-  const nsStyleDisplay* display = aFrame->GetStyleDisplay();
+  const nsStyleDisplay* display = aFrame->StyleDisplay();
   // Changes to the offsets of a non-positioned element can safely be ignored.
   if (display->mPosition == NS_STYLE_POSITION_STATIC) {
     return true;
   }
 
   aFrame->SchedulePaint();
 
   // For relative positioning, we can simply update the frame rect
   if (display->mPosition == NS_STYLE_POSITION_RELATIVE) {
     nsIFrame* cb = aFrame->GetContainingBlock();
     const nsSize size = cb->GetSize();
     const nsPoint oldOffsets = aFrame->GetRelativeOffset();
     nsMargin newOffsets;
 
     // Move the frame
     nsHTMLReflowState::ComputeRelativeOffsets(
-        cb->GetStyleVisibility()->mDirection,
+        cb->StyleVisibility()->mDirection,
         aFrame, size.width, size.height, newOffsets);
     NS_ASSERTION(newOffsets.left == -newOffsets.right &&
                  newOffsets.top == -newOffsets.bottom,
                  "ComputeRelativeOffsets should return valid results");
     aFrame->SetPosition(aFrame->GetPosition() - oldOffsets +
                         nsPoint(newOffsets.left, newOffsets.top));
 
     return true;
@@ -12643,17 +12643,17 @@ nsCSSFrameConstructor::RecomputePosition
   // For absolute positioning, the width can potentially change if width is
   // auto and either of left or right are not.  The height can also potentially
   // change if height is auto and either of top or bottom are not.  In these
   // cases we fall back to a reflow, and in all other cases, we attempt to
   // move the frame here.
   // Note that it is possible for the dimensions to not change in the above
   // cases, so we should be a little smarter here and only fall back to reflow
   // when the dimensions will really change (bug 745485).
-  const nsStylePosition* position = aFrame->GetStylePosition();
+  const nsStylePosition* position = aFrame->StylePosition();
   if (position->mWidth.GetUnit() != eStyleUnit_Auto &&
       position->mHeight.GetUnit() != eStyleUnit_Auto) {
     // For the absolute positioning case, set up a fake HTML reflow state for
     // the frame, and then get the offsets from it.
     nsRefPtr<nsRenderingContext> rc = aFrame->PresContext()->GetPresShell()->
       GetReferenceRenderingContext();
 
     // Construct a bogus parent reflow state so that there's a usable
diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -92,17 +92,17 @@ struct InlineBackgroundData
 
     nscoord x;
     if (mBidiEnabled) {
       x = mLineContinuationPoint;
 
       // Scan continuations on the same line as aFrame and accumulate the widths
       // of frames that are to the left (if this is an LTR block) or right
       // (if it's RTL) of the current one.
-      bool isRtlBlock = (mBlockFrame->GetStyleVisibility()->mDirection ==
+      bool isRtlBlock = (mBlockFrame->StyleVisibility()->mDirection ==
                            NS_STYLE_DIRECTION_RTL);
       nscoord curOffset = aFrame->GetOffsetTo(mBlockFrame).x;
 
       // No need to use our GetPrevContinuation/GetNextContinuation methods
       // here, since ib special siblings are certainly not on the same line.
 
       nsIFrame* inlineFrame = aFrame->GetPrevContinuation();
       // If the continuation is fluid we know inlineFrame is not on the same line.
@@ -581,17 +581,17 @@ nsCSSRendering::PaintBorder(nsPresContex
                             nsIFrame* aForFrame,
                             const nsRect& aDirtyRect,
                             const nsRect& aBorderArea,
                             nsStyleContext* aStyleContext,
                             int aSkipSides)
 {
   SAMPLE_LABEL("nsCSSRendering", "PaintBorder");
   nsStyleContext *styleIfVisited = aStyleContext->GetStyleIfVisited();
-  const nsStyleBorder *styleBorder = aStyleContext->GetStyleBorder();
+  const nsStyleBorder *styleBorder = aStyleContext->StyleBorder();
   // Don't check RelevantLinkVisited here, since we want to take the
   // same amount of time whether or not it's true.
   if (!styleIfVisited) {
     PaintBorderWithStyleBorder(aPresContext, aRenderingContext, aForFrame,
                                aDirtyRect, aBorderArea, *styleBorder,
                                aStyleContext, aSkipSides);
     return;
   }
@@ -631,31 +631,31 @@ nsCSSRendering::PaintBorderWithStyleBord
   nscoord             twipsRadii[8];
   nsCompatibility     compatMode = aPresContext->CompatibilityMode();
 
   SN("++ PaintBorder");
 
   // Check to see if we have an appearance defined.  If so, we let the theme
   // renderer draw the border.  DO not get the data from aForFrame, since the passed in style context
   // may be different!  Always use |aStyleContext|!
-  const nsStyleDisplay* displayData = aStyleContext->GetStyleDisplay();
+  const nsStyleDisplay* displayData = aStyleContext->StyleDisplay();
   if (displayData->mAppearance) {
     nsITheme *theme = aPresContext->GetTheme();
     if (theme && theme->ThemeSupportsWidget(aPresContext, aForFrame, displayData->mAppearance))
       return; // Let the theme handle it.
   }
 
   if (aStyleBorder.IsBorderImageLoaded()) {
     DrawBorderImage(aPresContext, aRenderingContext, aForFrame,
                     aBorderArea, aStyleBorder, aDirtyRect);
     return;
   }
 
   // Get our style context's color struct.
-  const nsStyleColor* ourColor = aStyleContext->GetStyleColor();
+  const nsStyleColor* ourColor = aStyleContext->StyleColor();
 
   // in NavQuirks mode we want to use the parent's context as a starting point
   // for determining the background color
   nsIFrame* bgFrame = nsCSSRendering::FindNonTransparentBackgroundFrame
     (aForFrame, compatMode == eCompatibility_NavQuirks ? true : false);
   nsStyleContext* bgContext = bgFrame->StyleContext();
   nscolor bgColor =
     bgContext->GetVisitedDependentColor(eCSSProperty_background_color);
@@ -663,17 +663,17 @@ nsCSSRendering::PaintBorderWithStyleBord
   border = aStyleBorder.GetComputedBorder();
   if ((0 == border.left) && (0 == border.right) &&
       (0 == border.top) && (0 == border.bottom)) {
     // Empty border area
     return;
   }
 
   nsSize frameSize = aForFrame->GetSize();
-  if (&aStyleBorder == aForFrame->GetStyleBorder() &&
+  if (&aStyleBorder == aForFrame->StyleBorder() &&
       frameSize == aBorderArea.Size()) {
     aForFrame->GetBorderRadii(twipsRadii);
   } else {
     nsIFrame::ComputeBorderRadii(aStyleBorder.mBorderRadius, frameSize,
                                  aBorderArea.Size(), aSkipSides, twipsRadii);
   }
 
   // Turn off rendering for all of the zero sized sides
@@ -774,17 +774,17 @@ nsCSSRendering::PaintOutline(nsPresConte
                              nsIFrame* aForFrame,
                              const nsRect& aDirtyRect,
                              const nsRect& aBorderArea,
                              nsStyleContext* aStyleContext)
 {
   nscoord             twipsRadii[8];
 
   // Get our style context's color struct.
-  const nsStyleOutline* ourOutline = aStyleContext->GetStyleOutline();
+  const nsStyleOutline* ourOutline = aStyleContext->StyleOutline();
 
   nscoord width;
   ourOutline->GetOutlineWidth(width);
 
   if (width == 0) {
     // Empty outline
     return;
   }
@@ -1005,17 +1005,17 @@ nsCSSRendering::FindNonTransparentBackgr
   }
   if (!frame) {
     frame = aFrame;
   }
 
   while (frame) {
     // No need to call GetVisitedDependentColor because it always uses
     // this alpha component anyway.
-    if (NS_GET_A(frame->GetStyleBackground()->mBackgroundColor) > 0)
+    if (NS_GET_A(frame->StyleBackground()->mBackgroundColor) > 0)
       break;
 
     if (frame->IsThemed())
       break;
 
     nsIFrame* parent = nsLayoutUtils::GetParentOrPlaceholderFor(frame);
     if (!parent)
       break;
@@ -1037,17 +1037,17 @@ nsCSSRendering::IsCanvasFrame(nsIFrame* 
          frameType == nsGkAtoms::rootFrame ||
          frameType == nsGkAtoms::pageContentFrame ||
          frameType == nsGkAtoms::viewportFrame;
 }
 
 nsIFrame*
 nsCSSRendering::FindBackgroundStyleFrame(nsIFrame* aForFrame)
 {
-  const nsStyleBackground* result = aForFrame->GetStyleBackground();
+  const nsStyleBackground* result = aForFrame->StyleBackground();
 
   // Check if we need to do propagation from BODY rather than HTML.
   if (!result->IsTransparent()) {
     return aForFrame;
   }
 
   nsIContent* content = aForFrame->GetContent();
   // The root element content can't be null. We wouldn't know what
@@ -1145,17 +1145,17 @@ FindElementBackground(nsIFrame* aForFram
     return true; // this wasn't the background that was propagated
 
   // This can be called even when there's no root element yet, during frame
   // construction, via nsLayoutUtils::FrameHasTransparency and
   // nsContainerFrame::SyncFrameViewProperties.
   if (!aRootElementFrame)
     return true;
 
-  const nsStyleBackground* htmlBG = aRootElementFrame->GetStyleBackground();
+  const nsStyleBackground* htmlBG = aRootElementFrame->StyleBackground();
   return !htmlBG->IsTransparent();
 }
 
 bool
 nsCSSRendering::FindBackground(nsPresContext* aPresContext,
                                nsIFrame* aForFrame,
                                nsStyleContext** aBackgroundSC)
 {
@@ -1187,28 +1187,28 @@ nsCSSRendering::EndFrameTreesLocked()
 
 void
 nsCSSRendering::PaintBoxShadowOuter(nsPresContext* aPresContext,
                                     nsRenderingContext& aRenderingContext,
                                     nsIFrame* aForFrame,
                                     const nsRect& aFrameArea,
                                     const nsRect& aDirtyRect)
 {
-  const nsStyleBorder* styleBorder = aForFrame->GetStyleBorder();
+  const nsStyleBorder* styleBorder = aForFrame->StyleBorder();
   nsCSSShadowArray* shadows = styleBorder->mBoxShadow;
   if (!shadows)
     return;
   nscoord twipsPerPixel = aPresContext->DevPixelsToAppUnits(1);
 
   bool hasBorderRadius;
   bool nativeTheme; // mutually exclusive with hasBorderRadius
   gfxCornerSizes borderRadii;
 
   // Get any border radius, since box-shadow must also have rounded corners if the frame does
-  const nsStyleDisplay* styleDisplay = aForFrame->GetStyleDisplay();
+  const nsStyleDisplay* styleDisplay = aForFrame->StyleDisplay();
   nsITheme::Transparency transparency;
   if (aForFrame->IsThemed(styleDisplay, &transparency)) {
     // We don't respect border-radius for native-themed widgets
     hasBorderRadius = false;
     // For opaque (rectangular) theme widgets we can take the generic
     // border-box path with border-radius disabled.
     nativeTheme = transparency != nsITheme::eOpaque;
   } else {
@@ -1294,17 +1294,17 @@ nsCSSRendering::PaintBoxShadowOuter(nsPr
     MOZ_ASSERT(shadowContext == renderContext ||
                shadowContext == blurringArea.GetContext());
 
     // Set the shadow color; if not specified, use the foreground color
     nscolor shadowColor;
     if (shadowItem->mHasColor)
       shadowColor = shadowItem->mColor;
     else
-      shadowColor = aForFrame->GetStyleColor()->mColor;
+      shadowColor = aForFrame->StyleColor()->mColor;
 
     renderContext->Save();
     renderContext->SetColor(gfxRGBA(shadowColor));
 
     // Draw the shape of the frame so it can be blurred. Recall how nsContextBoxBlur
     // doesn't make any temporary surfaces if blur is 0 and it just returns the original
     // surface? If we have no blur, we're painting this fill on the actual content surface
     // (renderContext == shadowContext) which is why we set up the color and clip
@@ -1366,17 +1366,17 @@ nsCSSRendering::PaintBoxShadowOuter(nsPr
 
 void
 nsCSSRendering::PaintBoxShadowInner(nsPresContext* aPresContext,
                                     nsRenderingContext& aRenderingContext,
                                     nsIFrame* aForFrame,
                                     const nsRect& aFrameArea,
                                     const nsRect& aDirtyRect)
 {
-  const nsStyleBorder* styleBorder = aForFrame->GetStyleBorder();
+  const nsStyleBorder* styleBorder = aForFrame->StyleBorder();
   nsCSSShadowArray* shadows = styleBorder->mBoxShadow;
   if (!shadows)
     return;
   if (aForFrame->IsThemed() && aForFrame->GetContent() &&
       !nsContentUtils::IsChromeDoc(aForFrame->GetContent()->GetCurrentDoc())) {
     // There's no way of getting hold of a shape corresponding to a
     // "padding-box" for native-themed widgets, so just don't draw
     // inner box-shadows for them. But we allow chrome to paint inner
@@ -1488,17 +1488,17 @@ nsCSSRendering::PaintBoxShadowInner(nsPr
     MOZ_ASSERT(shadowContext == renderContext ||
                shadowContext == blurringArea.GetContext());
 
     // Set the shadow color; if not specified, use the foreground color
     nscolor shadowColor;
     if (shadowItem->mHasColor)
       shadowColor = shadowItem->mColor;
     else
-      shadowColor = aForFrame->GetStyleColor()->mColor;
+      shadowColor = aForFrame->StyleColor()->mColor;
 
     renderContext->Save();
     renderContext->SetColor(gfxRGBA(shadowColor));
 
     // Clip the context to the area of the frame's padding rect, so no part of the
     // shadow is painted outside. Also cut out anything beyond where the inset shadow
     // will be.
     gfxRect shadowGfxRect =
@@ -1549,31 +1549,31 @@ nsCSSRendering::PaintBackground(nsPresCo
 
   nsStyleContext *sc;
   if (!FindBackground(aPresContext, aForFrame, &sc)) {
     // We don't want to bail out if moz-appearance is set on a root
     // node. If it has a parent content node, bail because it's not
     // a root, otherwise keep going in order to let the theme stuff
     // draw the background. The canvas really should be drawing the
     // bg, but there's no way to hook that up via css.
-    if (!aForFrame->GetStyleDisplay()->mAppearance) {
+    if (!aForFrame->StyleDisplay()->mAppearance) {
       return;
     }
 
     nsIContent* content = aForFrame->GetContent();
     if (!content || content->GetParent()) {
       return;
     }
 
     sc = aForFrame->StyleContext();
   }
 
   PaintBackgroundWithSC(aPresContext, aRenderingContext, aForFrame,
                         aDirtyRect, aBorderArea, sc,
-                        *aForFrame->GetStyleBorder(), aFlags,
+                        *aForFrame->StyleBorder(), aFlags,
                         aBGClipRect, aLayer);
 }
 
 void
 nsCSSRendering::PaintBackgroundColor(nsPresContext* aPresContext,
                                      nsRenderingContext& aRenderingContext,
                                      nsIFrame* aForFrame,
                                      const nsRect& aDirtyRect,
@@ -1586,31 +1586,31 @@ nsCSSRendering::PaintBackgroundColor(nsP
 
   nsStyleContext *sc;
   if (!FindBackground(aPresContext, aForFrame, &sc)) {
     // We don't want to bail out if moz-appearance is set on a root
     // node. If it has a parent content node, bail because it's not
     // a root, other wise keep going in order to let the theme stuff
     // draw the background. The canvas really should be drawing the
     // bg, but there's no way to hook that up via css.
-    if (!aForFrame->GetStyleDisplay()->mAppearance) {
+    if (!aForFrame->StyleDisplay()->mAppearance) {
       return;
     }
 
     nsIContent* content = aForFrame->GetContent();
     if (!content || content->GetParent()) {
       return;
     }
 
     sc = aForFrame->StyleContext();
   }
 
   PaintBackgroundColorWithSC(aPresContext, aRenderingContext, aForFrame,
                              aDirtyRect, aBorderArea, sc,
-                             *aForFrame->GetStyleBorder(), aFlags);
+                             *aForFrame->StyleBorder(), aFlags);
 }
 
 static bool
 IsOpaqueBorderEdge(const nsStyleBorder& aBorder, mozilla::css::Side aSide)
 {
   if (aBorder.GetComputedBorder().Side(aSide) == 0)
     return true;
   switch (aBorder.GetBorderStyle(aSide)) {
@@ -1836,17 +1836,17 @@ nsCSSRendering::DetermineBackgroundColor
   aDrawBackgroundImage = true;
   aDrawBackgroundColor = true;
 
   if (aFrame->HonorPrintBackgroundSettings()) {
     aDrawBackgroundImage = aPresContext->GetBackgroundImageDraw();
     aDrawBackgroundColor = aPresContext->GetBackgroundColorDraw();
   }
 
-  const nsStyleBackground *bg = aStyleContext->GetStyleBackground();
+  const nsStyleBackground *bg = aStyleContext->StyleBackground();
   nscolor bgColor;
   if (aDrawBackgroundColor) {
     bgColor =
       aStyleContext->GetVisitedDependentColor(eCSSProperty_background_color);
     if (NS_GET_A(bgColor) == 0) {
       aDrawBackgroundColor = false;
     }
   } else {
@@ -2472,17 +2472,17 @@ nsCSSRendering::PaintBackgroundWithSC(ns
                                       int32_t aLayer)
 {
   NS_PRECONDITION(aForFrame,
                   "Frame is expected to be provided to PaintBackground");
 
   // Check to see if we have an appearance defined.  If so, we let the theme
   // renderer draw the background and bail out.
   // XXXzw this ignores aBGClipRect.
-  const nsStyleDisplay* displayData = aForFrame->GetStyleDisplay();
+  const nsStyleDisplay* displayData = aForFrame->StyleDisplay();
   if (displayData->mAppearance) {
     nsITheme *theme = aPresContext->GetTheme();
     if (theme && theme->ThemeSupportsWidget(aPresContext, aForFrame,
                                             displayData->mAppearance)) {
       nsRect drawing(aBorderArea);
       theme->GetWidgetOverflow(aPresContext->DeviceContext(),
                                aForFrame, displayData->mAppearance, &drawing);
       drawing.IntersectRect(drawing, aDirtyRect);
@@ -2510,17 +2510,17 @@ nsCSSRendering::PaintBackgroundWithSC(ns
   nscolor bgColor = DetermineBackgroundColor(aPresContext,
                                              aBackgroundSC,
                                              aForFrame,
                                              drawBackgroundImage,
                                              drawBackgroundColor);
 
   // If we're drawing a specific layer, we don't want to draw the
   // background color.
-  const nsStyleBackground *bg = aBackgroundSC->GetStyleBackground();
+  const nsStyleBackground *bg = aBackgroundSC->StyleBackground();
   if (drawBackgroundColor && aLayer >= 0) {
     drawBackgroundColor = false;
   }
 
   // At this point, drawBackgroundImage and drawBackgroundColor are
   // true if and only if we are actually supposed to paint an image or
   // color into aDirtyRect, respectively.
   if (!drawBackgroundImage && !drawBackgroundColor)
@@ -2531,17 +2531,17 @@ nsCSSRendering::PaintBackgroundWithSC(ns
   nscoord appUnitsPerPixel = aPresContext->AppUnitsPerDevPixel();
 
   // Same coordinate space as aBorderArea & aBGClipRect
   gfxCornerSizes bgRadii;
   bool haveRoundedCorners;
   {
     nscoord radii[8];
     nsSize frameSize = aForFrame->GetSize();
-    if (&aBorder == aForFrame->GetStyleBorder() &&
+    if (&aBorder == aForFrame->StyleBorder() &&
         frameSize == aBorderArea.Size()) {
       haveRoundedCorners = aForFrame->GetBorderRadii(radii);
     } else {
       haveRoundedCorners = nsIFrame::ComputeBorderRadii(aBorder.mBorderRadius,
                                    frameSize, aBorderArea.Size(),
                                    aForFrame->GetSkipSides(), radii);
     }
     if (haveRoundedCorners)
@@ -2690,17 +2690,17 @@ nsCSSRendering::PaintBackgroundColorWith
                                            const nsStyleBorder& aBorder,
                                            uint32_t aFlags)
 {
   NS_PRECONDITION(aForFrame,
                   "Frame is expected to be provided to PaintBackground");
 
   // Check to see if we have an appearance defined.  If so, we let the theme
   // renderer draw the background and bail out.
-  const nsStyleDisplay* displayData = aForFrame->GetStyleDisplay();
+  const nsStyleDisplay* displayData = aForFrame->StyleDisplay();
   if (displayData->mAppearance) {
     nsITheme *theme = aPresContext->GetTheme();
     if (theme && theme->ThemeSupportsWidget(aPresContext, aForFrame,
                                             displayData->mAppearance)) {
       NS_ERROR("Shouldn't be trying to paint a background color if we are themed!");
       return;
     }
   }
@@ -2725,17 +2725,17 @@ nsCSSRendering::PaintBackgroundColorWith
   nscoord appUnitsPerPixel = aPresContext->AppUnitsPerDevPixel();
 
   // Same coordinate space as aBorderArea
   gfxCornerSizes bgRadii;
   bool haveRoundedCorners;
   {
     nscoord radii[8];
     nsSize frameSize = aForFrame->GetSize();
-    if (&aBorder == aForFrame->GetStyleBorder() &&
+    if (&aBorder == aForFrame->StyleBorder() &&
         frameSize == aBorderArea.Size()) {
       haveRoundedCorners = aForFrame->GetBorderRadii(radii);
     } else {
       haveRoundedCorners = nsIFrame::ComputeBorderRadii(aBorder.mBorderRadius,
                                    frameSize, aBorderArea.Size(),
                                    aForFrame->GetSkipSides(), radii);
     }
     if (haveRoundedCorners)
@@ -2745,17 +2745,17 @@ nsCSSRendering::PaintBackgroundColorWith
   // The background is rendered over the 'background-clip' area,
   // which is normally equal to the border area but may be reduced
   // to the padding area by CSS.  Also, if the border is solid, we
   // don't need to draw outside the padding area.  In either case,
   // if the borders are rounded, make sure we use the same inner
   // radii as the border code will.
   // The background-color is drawn based on the bottom
   // background-clip.
-  const nsStyleBackground *bg = aBackgroundSC->GetStyleBackground();
+  const nsStyleBackground *bg = aBackgroundSC->StyleBackground();
   uint8_t currentBackgroundClip = bg->BottomLayer().mClip;
   bool isSolidBorder =
     (aFlags & PAINTBG_WILL_PAINT_BORDER) && IsOpaqueBorder(aBorder);
   if (isSolidBorder && currentBackgroundClip == NS_STYLE_BG_CLIP_BORDER) {
     // If we have rounded corners, we need to inflate the background
     // drawing area a bit to avoid seams between the border and
     // background.
     currentBackgroundClip = haveRoundedCorners ?
@@ -3779,17 +3779,17 @@ nsCSSRendering::ExpandPaintingRectForDec
   // Note that when we paint the decoration lines in relative positioned
   // box, we should paint them like all of the boxes are positioned as static.
   nscoord relativeX = 0;
   for (nsIFrame* f = aFrame; f; f = f->GetParent()) {
     block = do_QueryFrame(f);
     if (block) {
       break;
     }
-    relativeX += f->GetRelativeOffset(f->GetStyleDisplay()).x;
+    relativeX += f->GetRelativeOffset(f->StyleDisplay()).x;
   }
 
   NS_ENSURE_TRUE(block, aClippedRect);
 
   nscoord frameXInBlockAppUnits = aFrame->GetOffsetTo(block).x - relativeX;
   nsPresContext *pc = aFrame->PresContext();
   gfxFloat frameXInBlock = pc->AppUnitsToGfxUnits(frameXInBlockAppUnits);
   int32_t rectXInBlock = int32_t(NS_round(frameXInBlock + aXInFrame));
diff --git a/layout/base/nsCaret.cpp b/layout/base/nsCaret.cpp
--- a/layout/base/nsCaret.cpp
+++ b/layout/base/nsCaret.cpp
@@ -663,17 +663,17 @@ nsCaret::DrawAtPositionWithHint(nsIDOMNo
   int32_t   theFrameOffset = 0;
 
   nsresult rv = GetCaretFrameForNodeOffset(contentNode, aOffset, aFrameHint, aBidiLevel,
                                            &theFrame, &theFrameOffset);
   if (NS_FAILED(rv) || !theFrame)
     return false;
 
   // now we have a frame, check whether it's appropriate to show the caret here
-  const nsStyleUserInterface* userinterface = theFrame->GetStyleUserInterface();
+  const nsStyleUserInterface* userinterface = theFrame->StyleUserInterface();
   if ((!mIgnoreUserModify &&
        userinterface->mUserModify == NS_STYLE_USER_MODIFY_READ_ONLY) ||
       (userinterface->mUserInput == NS_STYLE_USER_INPUT_NONE) ||
       (userinterface->mUserInput == NS_STYLE_USER_INPUT_DISABLED))
   {
     return false;
   }  
 
@@ -1067,17 +1067,17 @@ nsCaret::UpdateCaretRects(nsIFrame* aFra
   nscoord bidiIndicatorSize;
   nsresult rv =
     GetGeometryForFrame(aFrame, aFrameOffset, &mCaretRect, &bidiIndicatorSize);
   if (NS_FAILED(rv)) {
     return false;
   }
 
   // on RTL frames the right edge of mCaretRect must be equal to framePos
-  const nsStyleVisibility* vis = aFrame->GetStyleVisibility();
+  const nsStyleVisibility* vis = aFrame->StyleVisibility();
   if (NS_STYLE_DIRECTION_RTL == vis->mDirection)
     mCaretRect.x -= mCaretRect.width;
 
 #ifdef IBMBIDI
   mHookRect.SetEmpty();
 
   // Simon -- make a hook to draw to the left or right of the caret to show keyboard language direction
   bool isCaretRTL = false;
@@ -1144,16 +1144,16 @@ nsCaret::SetIgnoreUserModify(bool aIgnor
 {
   if (!aIgnoreUserModify && mIgnoreUserModify && mDrawn) {
     // We're turning off mIgnoreUserModify. If the caret's drawn
     // in a read-only node we must erase it, else the next call
     // to DrawCaret() won't erase the old caret, due to the new
     // mIgnoreUserModify value.
     nsIFrame *frame = GetCaretFrame();
     if (frame) {
-      const nsStyleUserInterface* userinterface = frame->GetStyleUserInterface();
+      const nsStyleUserInterface* userinterface = frame->StyleUserInterface();
       if (userinterface->mUserModify == NS_STYLE_USER_MODIFY_READ_ONLY) {
         StopBlinking();
       }
     }
   }
   mIgnoreUserModify = aIgnoreUserModify;
 }
diff --git a/layout/base/nsCounterManager.cpp b/layout/base/nsCounterManager.cpp
--- a/layout/base/nsCounterManager.cpp
+++ b/layout/base/nsCounterManager.cpp
@@ -181,17 +181,17 @@ nsCounterList::RecalcAll()
 nsCounterManager::nsCounterManager()
 {
     mNames.Init(16);
 }
 
 bool
 nsCounterManager::AddCounterResetsAndIncrements(nsIFrame *aFrame)
 {
-    const nsStyleContent *styleContent = aFrame->GetStyleContent();
+    const nsStyleContent *styleContent = aFrame->StyleContent();
     if (!styleContent->CounterIncrementCount() &&
         !styleContent->CounterResetCount())
         return false;
 
     // Add in order, resets first, so all the comparisons will be optimized
     // for addition at the end of the list.
     int32_t i, i_end;
     bool dirty = false;
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -384,17 +384,17 @@ AddAnimationsAndTransitionsToLayer(Layer
     float scale = nsDeviceContext::AppUnitsPerCSSPixel();
     gfxPoint3D offsetToTransformOrigin =
       nsDisplayTransform::GetDeltaToMozTransformOrigin(frame, scale, &bounds);
     gfxPoint3D offsetToPerspectiveOrigin =
       nsDisplayTransform::GetDeltaToMozPerspectiveOrigin(frame, scale);
     nscoord perspective = 0.0;
     nsStyleContext* parentStyleContext = frame->StyleContext()->GetParent();
     if (parentStyleContext) {
-      const nsStyleDisplay* disp = parentStyleContext->GetStyleDisplay();
+      const nsStyleDisplay* disp = parentStyleContext->StyleDisplay();
       if (disp && disp->mChildPerspective.GetUnit() == eStyleUnit_Coord) {
         perspective = disp->mChildPerspective.GetCoordValue();
       }
     }
     nsPoint origin = aItem->ToReferenceFrame();
 
     data = TransformData(origin, offsetToTransformOrigin,
                          offsetToPerspectiveOrigin, bounds, perspective,
@@ -911,17 +911,17 @@ TreatAsOpaque(nsDisplayItem* aItem, nsDi
     // effectively ignored, as it should be.
     // We treat leaf chrome items as opaque to ensure that they cover
     // content plugins, for security reasons.
     // Non-leaf chrome items don't render contents of their own so shouldn't
     // be treated as opaque (and their bounds is just the union of their
     // children, which might be a large area their contents don't really cover).
     nsIFrame* f = aItem->GetUnderlyingFrame();
     if (f && f->PresContext()->IsChrome() && !aItem->GetChildren() &&
-        f->GetStyleDisplay()->mOpacity != 0.0) {
+        f->StyleDisplay()->mOpacity != 0.0) {
       opaque = aItem->GetBounds(aBuilder, &snap);
     }
   }
   return opaque;
 }
 
 static nsRect
 GetDisplayPortBounds(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
@@ -1326,17 +1326,17 @@ void nsDisplayList::HitTest(nsDisplayLis
         // so flush these into the destination array before processing our frame list.
         FlushFramesArray(temp, aOutFrames);
       }
 
       for (uint32_t j = 0; j < outFrames.Length(); j++) {
         nsIFrame *f = outFrames.ElementAt(j);
         // Handle the XUL 'mousethrough' feature and 'pointer-events'.
         if (!GetMouseThrough(f) &&
-            f->GetStyleVisibility()->GetEffectivePointerEvents(f) != NS_STYLE_POINTER_EVENTS_NONE) {
+            f->StyleVisibility()->GetEffectivePointerEvents(f) != NS_STYLE_POINTER_EVENTS_NONE) {
           writeFrames->AppendElement(f);
         }
       }
     }
   }
   // Clear any remaining preserve-3d transforms.
   FlushFramesArray(temp, aOutFrames);
   NS_ASSERTION(aState->mItemBuffer.Length() == uint32_t(itemBufferStart),
@@ -1515,17 +1515,17 @@ RegisterThemeGeometry(nsDisplayListBuild
     if (f->IsTransformed())
       return;
     // Bail out if we're not in the displayRoot's document
     if (!f->GetParent() && f != displayRoot)
       return;
   }
 
   nsRect borderBox(aFrame->GetOffsetTo(displayRoot), aFrame->GetSize());
-  aBuilder->RegisterThemeGeometry(aFrame->GetStyleDisplay()->mAppearance,
+  aBuilder->RegisterThemeGeometry(aFrame->StyleDisplay()->mAppearance,
       borderBox.ToNearestPixels(aFrame->PresContext()->AppUnitsPerDevPixel()));
 }
 
 nsDisplayBackgroundImage::nsDisplayBackgroundImage(nsDisplayListBuilder* aBuilder,
                                                    nsIFrame* aFrame,
                                                    uint32_t aLayer,
                                                    bool aIsThemed,
                                                    const nsStyleBackground* aBackgroundStyle)
@@ -1533,17 +1533,17 @@ nsDisplayBackgroundImage::nsDisplayBackg
   , mBackgroundStyle(aBackgroundStyle)
   , mLayer(aLayer)
   , mIsThemed(aIsThemed)
   , mIsBottommostLayer(true)
 {
   MOZ_COUNT_CTOR(nsDisplayBackgroundImage);
 
   if (mIsThemed) {
-    const nsStyleDisplay* disp = mFrame->GetStyleDisplay();
+    const nsStyleDisplay* disp = mFrame->StyleDisplay();
     mFrame->IsThemed(disp, &mThemeTransparency);
     // Perform necessary RegisterThemeGeometry
     if (disp->mAppearance == NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR ||
         disp->mAppearance == NS_THEME_TOOLBAR) {
       RegisterThemeGeometry(aBuilder, aFrame);
     } else if (disp->mAppearance == NS_THEME_WIN_BORDERLESS_GLASS ||
                disp->mAppearance == NS_THEME_WIN_GLASS) {
       aBuilder->SetGlassDisplayItem(this);
@@ -1570,17 +1570,17 @@ nsDisplayBackgroundImage::~nsDisplayBack
 #endif
 }
 
 #ifdef MOZ_DUMP_PAINTING
 void
 nsDisplayBackgroundImage::WriteDebugInfo(FILE *aOutput)
 {
   if (mIsThemed) {
-    fprintf(aOutput, "(themed, appearance:%d) ", mFrame->GetStyleDisplay()->mAppearance);
+    fprintf(aOutput, "(themed, appearance:%d) ", mFrame->StyleDisplay()->mAppearance);
   }
 
 }
 #endif
 
 /*static*/ nsresult
 nsDisplayBackgroundImage::AppendBackgroundItemsToTop(nsDisplayListBuilder* aBuilder,
                                                      nsIFrame* aFrame,
@@ -1588,17 +1588,17 @@ nsDisplayBackgroundImage::AppendBackgrou
                                                      nsDisplayBackgroundImage** aBackground)
 {
   nsStyleContext* bgSC = nullptr;
   const nsStyleBackground* bg = nullptr;
   nsPresContext* presContext = aFrame->PresContext();
   bool isThemed = aFrame->IsThemed();
   if (!isThemed &&
       nsCSSRendering::FindBackground(presContext, aFrame, &bgSC)) {
-    bg = bgSC->GetStyleBackground();
+    bg = bgSC->StyleBackground();
   }
 
   bool drawBackgroundColor = false;
   nscolor color;
   if (!nsCSSRendering::IsCanvasFrame(aFrame) && bg) {
     bool drawBackgroundImage;
     color =
       nsCSSRendering::DetermineBackgroundColor(presContext, bgSC, aFrame,
@@ -2023,17 +2023,17 @@ nsDisplayBackgroundImage::GetOpaqueRegio
 
   return result;
 }
 
 bool
 nsDisplayBackgroundImage::IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor) {
   // theme background overrides any other background
   if (mIsThemed) {
-    const nsStyleDisplay* disp = mFrame->GetStyleDisplay();
+    const nsStyleDisplay* disp = mFrame->StyleDisplay();
     if (disp->mAppearance == NS_THEME_WIN_BORDERLESS_GLASS ||
         disp->mAppearance == NS_THEME_WIN_GLASS) {
       *aColor = NS_RGBA(0,0,0,0);
       return true;
     }
     return false;
   }
 
@@ -2177,17 +2177,17 @@ nsDisplayBackgroundImage::GetBounds(nsDi
 nsRect
 nsDisplayBackgroundImage::GetBoundsInternal() {
   nsPresContext* presContext = mFrame->PresContext();
 
   if (mIsThemed) {
     nsRect r(nsPoint(0,0), mFrame->GetSize());
     presContext->GetTheme()->
         GetWidgetOverflow(presContext->DeviceContext(), mFrame,
-                          mFrame->GetStyleDisplay()->mAppearance, &r);
+                          mFrame->StyleDisplay()->mAppearance, &r);
 #ifdef XP_MACOSX
     // Bug 748219
     r.Inflate(mFrame->PresContext()->AppUnitsPerDevPixel());
 #endif
 
     return r + ToReferenceFrame();
   }
 
@@ -2252,17 +2252,17 @@ nsDisplayBackgroundColor::GetOpaqueRegio
 bool
 nsDisplayBackgroundColor::IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor) 
 {
   *aColor = mColor;
 
   if (!mBackgroundStyle)
     return true;
 
-  return (!nsLayoutUtils::HasNonZeroCorner(mFrame->GetStyleBorder()->mBorderRadius) &&
+  return (!nsLayoutUtils::HasNonZeroCorner(mFrame->StyleBorder()->mBorderRadius) &&
           mBackgroundStyle->BottomLayer().mClip == NS_STYLE_BG_CLIP_BORDER);
 }
 
 void
 nsDisplayBackgroundColor::HitTest(nsDisplayListBuilder* aBuilder,
                                   const nsRect& aRect,
                                   HitTestState* aState,
                                   nsTArray<nsIFrame*> *aOutFrames)
@@ -2296,17 +2296,17 @@ bool
 nsDisplayOutline::ComputeVisibility(nsDisplayListBuilder* aBuilder,
                                     nsRegion* aVisibleRegion,
                                     const nsRect& aAllowVisibleRegionExpansion) {
   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
                                         aAllowVisibleRegionExpansion)) {
     return false;
   }
 
-  const nsStyleOutline* outline = mFrame->GetStyleOutline();
+  const nsStyleOutline* outline = mFrame->StyleOutline();
   nsRect borderBox(ToReferenceFrame(), mFrame->GetSize());
   if (borderBox.Contains(aVisibleRegion->GetBounds()) &&
       !nsLayoutUtils::HasNonZeroCorner(outline->mOutlineRadius)) {
     if (outline->mOutlineOffset >= 0) {
       // the visible region is entirely inside the border-rect, and the outline
       // isn't rendered inside the border-rect, so the outline is not visible
       return false;
     }
@@ -2345,17 +2345,17 @@ nsDisplayBorder::ComputeVisibility(nsDis
                                         aAllowVisibleRegionExpansion)) {
     return false;
   }
 
   nsRect paddingRect = mFrame->GetPaddingRect() - mFrame->GetPosition() +
     ToReferenceFrame();
   const nsStyleBorder *styleBorder;
   if (paddingRect.Contains(aVisibleRegion->GetBounds()) &&
-      !(styleBorder = mFrame->GetStyleBorder())->IsBorderImageLoaded() &&
+      !(styleBorder = mFrame->StyleBorder())->IsBorderImageLoaded() &&
       !nsLayoutUtils::HasNonZeroCorner(styleBorder->mBorderRadius)) {
     // the visible region is entirely inside the content rect, and no part
     // of the border is rendered inside the content rect, so we are not
     // visible
     // Skip this if there's a border-image (which draws a background
     // too) or if there is a border-radius (which makes the border draw
     // further in).
     return false;
@@ -2396,17 +2396,17 @@ nsDisplayBorder::Paint(nsDisplayListBuil
                               mFrame->StyleContext(),
                               mFrame->GetSkipSides());
 }
 
 nsRect
 nsDisplayBorder::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap)
 {
   nsRect borderBounds(ToReferenceFrame(), mFrame->GetSize());
-  borderBounds.Inflate(mFrame->GetStyleBorder()->GetImageOutset());
+  borderBounds.Inflate(mFrame->StyleBorder()->GetImageOutset());
   *aSnap = true;
   return borderBounds;
 }
 
 // Given a region, compute a conservative approximation to it as a list
 // of rectangles that aren't vertically adjacent (i.e., vertically
 // adjacent or overlapping rectangles are combined).
 // Right now this is only approximate, some vertically overlapping rectangles
@@ -2799,27 +2799,27 @@ nsRegion nsDisplayOpacity::GetOpaqueRegi
   return nsRegion();
 }
 
 // nsDisplayOpacity uses layers for rendering
 already_AddRefed<Layer>
 nsDisplayOpacity::BuildLayer(nsDisplayListBuilder* aBuilder,
                              LayerManager* aManager,
                              const ContainerParameters& aContainerParameters) {
-  if (mFrame->GetStyleDisplay()->mOpacity == 0 && mFrame->GetContent() &&
+  if (mFrame->StyleDisplay()->mOpacity == 0 && mFrame->GetContent() &&
       !nsLayoutUtils::HasAnimationsForCompositor(mFrame->GetContent(), eCSSProperty_opacity)) {
     return nullptr;
   }
   nsRefPtr<Layer> container = aManager->GetLayerBuilder()->
     BuildContainerLayerFor(aBuilder, aManager, mFrame, this, mList,
                            aContainerParameters, nullptr);
   if (!container)
     return nullptr;
 
-  container->SetOpacity(mFrame->GetStyleDisplay()->mOpacity);
+  container->SetOpacity(mFrame->StyleDisplay()->mOpacity);
   AddAnimationsAndTransitionsToLayer(container, aBuilder,
                                      this, eCSSProperty_opacity);
   return container.forget();
 }
 
 /**
  * This doesn't take into account layer scaling --- the layer may be
  * rendered at a higher (or lower) resolution, affecting the retained layer
@@ -2963,17 +2963,17 @@ nsDisplayFixedPosition::BuildLayer(nsDis
                        aContainerParameters.mYScale,
                      NSAppUnitsToFloatPixels(containingBlockSize.width, factor) *
                        aContainerParameters.mXScale,
                      NSAppUnitsToFloatPixels(containingBlockSize.height, factor) *
                        aContainerParameters.mYScale);
 
   gfxPoint anchor(anchorRect.x, anchorRect.y);
 
-  const nsStylePosition* position = mFixedPosFrame->GetStylePosition();
+  const nsStylePosition* position = mFixedPosFrame->StylePosition();
   if (position->mOffset.GetRightUnit() != eStyleUnit_Auto)
     anchor.x = anchorRect.XMost();
   if (position->mOffset.GetBottomUnit() != eStyleUnit_Auto)
     anchor.y = anchorRect.YMost();
 
   layer->SetFixedPositionAnchor(anchor);
 
   return layer.forget();
@@ -3588,17 +3588,17 @@ nsDisplayTransform::GetDeltaToMozTransfo
   NS_PRECONDITION(aFrame, "Can't get delta for a null frame!");
   NS_PRECONDITION(aFrame->IsTransformed(),
                   "Shouldn't get a delta for an untransformed frame!");
 
   /* For both of the coordinates, if the value of -moz-transform is a
    * percentage, it's relative to the size of the frame.  Otherwise, if it's
    * a distance, it's already computed for us!
    */
-  const nsStyleDisplay* display = aFrame->GetStyleDisplay();
+  const nsStyleDisplay* display = aFrame->StyleDisplay();
   nsRect boundingRect = (aBoundsOverride ? *aBoundsOverride :
                          nsDisplayTransform::GetFrameBoundsForTransform(aFrame));
 
   /* Allows us to access named variables by index. */
   float coords[3];
   const nscoord* dimensions[2] =
     {&boundingRect.width, &boundingRect.height};
 
@@ -3660,17 +3660,17 @@ nsDisplayTransform::GetDeltaToMozPerspec
    */
 
   //TODO: Should this be using our bounds or the parent's bounds?
   // How do we handle aBoundsOverride in the latter case?
   nsIFrame* parent = aFrame->GetParentStyleContextFrame();
   if (!parent) {
     return gfxPoint3D();
   }
-  const nsStyleDisplay* display = parent->GetStyleDisplay();
+  const nsStyleDisplay* display = parent->StyleDisplay();
   nsRect boundingRect = nsDisplayTransform::GetFrameBoundsForTransform(parent);
 
   /* Allows us to access named variables by index. */
   gfxPoint3D result;
   result.z = 0.0f;
   gfxFloat* coords[2] = {&result.x, &result.y};
   const nscoord* dimensions[2] =
     {&boundingRect.width, &boundingRect.height};
@@ -3705,25 +3705,25 @@ nsDisplayTransform::GetDeltaToMozPerspec
 
   return result - gfxOffset;
 }
 
 nsDisplayTransform::FrameTransformProperties::FrameTransformProperties(const nsIFrame* aFrame,
                                                                        float aAppUnitsPerPixel,
                                                                        const nsRect* aBoundsOverride)
   : mFrame(aFrame)
-  , mTransformList(aFrame->GetStyleDisplay()->mSpecifiedTransform)
+  , mTransformList(aFrame->StyleDisplay()->mSpecifiedTransform)
   , mToMozOrigin(GetDeltaToMozTransformOrigin(aFrame, aAppUnitsPerPixel, aBoundsOverride))
   , mToPerspectiveOrigin(GetDeltaToMozPerspectiveOrigin(aFrame, aAppUnitsPerPixel))
   , mChildPerspective(0)
 {
   const nsStyleDisplay* parentDisp = nullptr;
   nsStyleContext* parentStyleContext = aFrame->StyleContext()->GetParent();
   if (parentStyleContext) {
-    parentDisp = parentStyleContext->GetStyleDisplay();
+    parentDisp = parentStyleContext->StyleDisplay();
   }
   if (parentDisp && parentDisp->mChildPerspective.GetUnit() == eStyleUnit_Coord) {
     mChildPerspective = parentDisp->mChildPerspective.GetCoordValue();
   }
 }
 
 /* Wraps up the -moz-transform matrix in a change-of-basis matrix pair that
  * translates from local coordinate space to transform coordinate space, then
@@ -3920,17 +3920,17 @@ nsDisplayTransform::ShouldPrerenderTrans
 }
 
 /* If the matrix is singular, or a hidden backface is shown, the frame won't be visible or hit. */
 static bool IsFrameVisible(nsIFrame* aFrame, const gfx3DMatrix& aMatrix)
 {
   if (aMatrix.IsSingular()) {
     return false;
   }
-  if (aFrame->GetStyleDisplay()->mBackfaceVisibility == NS_STYLE_BACKFACE_VISIBILITY_HIDDEN &&
+  if (aFrame->StyleDisplay()->mBackfaceVisibility == NS_STYLE_BACKFACE_VISIBILITY_HIDDEN &&
       aMatrix.IsBackfaceVisible()) {
     return false;
   }
   return true;
 }
 
 const gfx3DMatrix&
 nsDisplayTransform::GetTransform(float aAppUnitsPerPixel)
@@ -4409,17 +4409,17 @@ nsDisplaySVGEffects::BuildLayer(nsDispla
       NS_ASSERTION(false, "why?");
       return nullptr;
     }
     if (!static_cast<const nsSVGElement*>(content)->HasValidDimensions()) {
       return nullptr; // The SVG spec says not to draw filters for this
     }
   }
 
-  float opacity = mFrame->GetStyleDisplay()->mOpacity;
+  float opacity = mFrame->StyleDisplay()->mOpacity;
   if (opacity == 0.0f)
     return nullptr;
 
   nsIFrame* firstFrame =
     nsLayoutUtils::GetFirstContinuationOrSpecialSibling(mFrame);
   nsSVGEffects::EffectProperties effectProperties =
     nsSVGEffects::GetEffectProperties(firstFrame);
 
@@ -4479,19 +4479,19 @@ nsDisplaySVGEffects::PrintEffects(FILE* 
   nsIFrame* firstFrame =
     nsLayoutUtils::GetFirstContinuationOrSpecialSibling(mFrame);
   nsSVGEffects::EffectProperties effectProperties =
     nsSVGEffects::GetEffectProperties(firstFrame);
   bool isOK = true;
   nsSVGClipPathFrame *clipPathFrame = effectProperties.GetClipPathFrame(&isOK);
   bool first = true;
   fprintf(aOutput, " effects=(");
-  if (mFrame->GetStyleDisplay()->mOpacity != 1.0f) {
+  if (mFrame->StyleDisplay()->mOpacity != 1.0f) {
     first = false;
-    fprintf(aOutput, "opacity(%f)", mFrame->GetStyleDisplay()->mOpacity);
+    fprintf(aOutput, "opacity(%f)", mFrame->StyleDisplay()->mOpacity);
   }
   if (clipPathFrame) {
     if (!first) {
       fprintf(aOutput, ", ");
     }
     fprintf(aOutput, "clip(%s)", clipPathFrame->IsTrivial() ? "trivial" : "non-trivial");
     first = false;
   }
diff --git a/layout/base/nsDisplayList.h b/layout/base/nsDisplayList.h
--- a/layout/base/nsDisplayList.h
+++ b/layout/base/nsDisplayList.h
@@ -2299,17 +2299,17 @@ public:
                                          const nsDisplayItemGeometry* aGeometry,
                                          nsRegion* aInvalidRegion) MOZ_OVERRIDE
   {
     // We don't need to compute an invalidation region since we have LayerTreeInvalidation
   }
   NS_DISPLAY_DECL_NAME("Opacity", TYPE_OPACITY)
 #ifdef MOZ_DUMP_PAINTING
   virtual void WriteDebugInfo(FILE *aOutput) {
-    fprintf(aOutput, "(opacity %f)", mFrame->GetStyleDisplay()->mOpacity);
+    fprintf(aOutput, "(opacity %f)", mFrame->StyleDisplay()->mOpacity);
   }
 #endif
 
   bool CanUseAsyncAnimations(nsDisplayListBuilder* aBuilder);
 };
 
 /**
  * A display item that has no purpose but to ensure its contents get
diff --git a/layout/base/nsFrameManager.cpp b/layout/base/nsFrameManager.cpp
--- a/layout/base/nsFrameManager.cpp
+++ b/layout/base/nsFrameManager.cpp
@@ -1059,17 +1059,17 @@ nsFrameManager::ReResolveStyleContext(ns
 
   // XXXbz the nsIFrame constructor takes an nsStyleContext, so how
   // could oldContext be null?
   if (oldContext) {
     oldContext->AddRef();
 
 #ifdef ACCESSIBILITY
     bool wasFrameVisible = nsIPresShell::IsAccessibilityActive() ?
-      oldContext->GetStyleVisibility()->IsVisible() : false;
+      oldContext->StyleVisibility()->IsVisible() : false;
 #endif
 
     nsIAtom* const pseudoTag = oldContext->GetPseudo();
     const nsCSSPseudoElements::Type pseudoType = oldContext->GetPseudoType();
     nsIContent* localContent = aFrame->GetContent();
     // |content| is the node that we used for rule matching of
     // normal elements (not pseudo-elements) and for which we generate
     // framechange hints if we need them.
@@ -1405,17 +1405,17 @@ nsFrameManager::ReResolveStyleContext(ns
                                       newContext,
                                       aTreeMatchContext);
         } else {
           undisplayedContext =
             styleSet->ReparentStyleContext(undisplayed->mStyle, newContext,
                                            undisplayed->mContent->AsElement());
         }
         if (undisplayedContext) {
-          const nsStyleDisplay* display = undisplayedContext->GetStyleDisplay();
+          const nsStyleDisplay* display = undisplayedContext->StyleDisplay();
           if (display->mDisplay != NS_STYLE_DISPLAY_NONE) {
             NS_ASSERTION(undisplayed->mContent,
                          "Must have undisplayed content");
             aChangeList->AppendChange(nullptr, undisplayed->mContent, 
                                       NS_STYLE_HINT_FRAMECHANGE);
             // The node should be removed from the undisplayed map when
             // we reframe it.
           } else {
@@ -1496,17 +1496,17 @@ nsFrameManager::ReResolveStyleContext(ns
       A11yNotificationType ourA11yNotification = eDontNotify;
       // Notify a11y for primary frame only if it's a root frame of visibility
       // changes or its parent frame was hidden while it stays visible and
       // it is not inside a {ib} split or is the first frame of {ib} split.
       if (nsIPresShell::IsAccessibilityActive() &&
           !aFrame->GetPrevContinuation() &&
           !nsLayoutUtils::FrameIsNonFirstInIBSplit(aFrame)) {
         if (aDesiredA11yNotifications == eSendAllNotifications) {
-          bool isFrameVisible = newContext->GetStyleVisibility()->IsVisible();
+          bool isFrameVisible = newContext->StyleVisibility()->IsVisible();
           if (isFrameVisible != wasFrameVisible) {
             if (isFrameVisible) {
               // Notify a11y the element (perhaps with its children) was shown.
               // We don't fall into this case if this element gets or stays shown
               // while its parent becomes hidden.
               kidsDesiredA11yNotification = eSkipNotifications;
               ourA11yNotification = eNotifyShown;
             } else {
@@ -1515,17 +1515,17 @@ nsFrameManager::ReResolveStyleContext(ns
               // visible children then we should notify a11y about that as if
               // they were inserted into tree. Notify a11y this element was
               // hidden.
               kidsDesiredA11yNotification = eNotifyIfShown;
               ourA11yNotification = eNotifyHidden;
             }
           }
         } else if (aDesiredA11yNotifications == eNotifyIfShown &&
-                   newContext->GetStyleVisibility()->IsVisible()) {
+                   newContext->StyleVisibility()->IsVisible()) {
           // Notify a11y that element stayed visible while its parent was
           // hidden.
           aVisibleKidsOfHiddenElement.AppendElement(aFrame->GetContent());
           kidsDesiredA11yNotification = eSkipNotifications;
         }
       }
 #endif
 
diff --git a/layout/base/nsFrameTraversal.cpp b/layout/base/nsFrameTraversal.cpp
--- a/layout/base/nsFrameTraversal.cpp
+++ b/layout/base/nsFrameTraversal.cpp
@@ -491,17 +491,17 @@ nsFrameIterator::GetPlaceholderFrame(nsI
 
   return result;
 }
 
 bool
 nsFrameIterator::IsPopupFrame(nsIFrame* aFrame)
 {
   return (aFrame &&
-          aFrame->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_POPUP);
+          aFrame->StyleDisplay()->mDisplay == NS_STYLE_DISPLAY_POPUP);
 }
 
 // nsVisualIterator implementation
 
 nsIFrame*
 nsVisualIterator::GetFirstChildInner(nsIFrame* aFrame) {
   return aFrame->PrincipalChildList().GetNextVisualFor(nullptr);
 }
diff --git a/layout/base/nsGenConList.h b/layout/base/nsGenConList.h
--- a/layout/base/nsGenConList.h
+++ b/layout/base/nsGenConList.h
@@ -58,17 +58,17 @@ struct nsGenConNode : public PRCList {
     return false;
   }
 
   virtual ~nsGenConNode() {} // XXX Avoid, perhaps?
 
 protected:
   void CheckFrameAssertions() {
     NS_ASSERTION(mContentIndex <
-                   int32_t(mPseudoFrame->GetStyleContent()->ContentCount()),
+                   int32_t(mPseudoFrame->StyleContent()->ContentCount()),
                  "index out of range");
       // We allow negative values of mContentIndex for 'counter-reset' and
       // 'counter-increment'.
 
     NS_ASSERTION(mContentIndex < 0 ||
                  mPseudoFrame->StyleContext()->GetPseudo() ==
                    nsCSSPseudoElements::before ||
                  mPseudoFrame->StyleContext()->GetPseudo() ==
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -589,17 +589,17 @@ nsLayoutUtils::GetChildListNameFor(nsIFr
     }
     else {
       id = nsIFrame::kOverflowContainersList;
     }
   }
   // See if the frame is moved out of the flow
   else if (aChildFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
     // Look at the style information to tell
-    const nsStyleDisplay* disp = aChildFrame->GetStyleDisplay();
+    const nsStyleDisplay* disp = aChildFrame->StyleDisplay();
 
     if (NS_STYLE_POSITION_ABSOLUTE == disp->mPosition) {
       id = nsIFrame::kAbsoluteList;
     } else if (NS_STYLE_POSITION_FIXED == disp->mPosition) {
       if (nsLayoutUtils::IsReallyFixedPos(aChildFrame)) {
         id = nsIFrame::kFixedList;
       } else {
         id = nsIFrame::kAbsoluteList;
@@ -2097,17 +2097,17 @@ nsLayoutUtils::PaintFrame(nsRenderingCon
 }
 
 int32_t
 nsLayoutUtils::GetZIndex(nsIFrame* aFrame) {
   if (!aFrame->IsPositioned() && !aFrame->IsFlexItem())
     return 0;
 
   const nsStylePosition* position =
-    aFrame->GetStylePosition();
+    aFrame->StylePosition();
   if (position->mZIndex.GetUnit() == eStyleUnit_Integer)
     return position->mZIndex.GetIntValue();
 
   // sort the auto and 0 elements together
   return 0;
 }
 
 /**
@@ -2302,17 +2302,17 @@ nsLayoutUtils::GetAllInFlowPaddingRectsU
           : accumulator.mResultRect;
 }
 
 nsRect
 nsLayoutUtils::GetTextShadowRectsUnion(const nsRect& aTextAndDecorationsRect,
                                        nsIFrame* aFrame,
                                        uint32_t aFlags)
 {
-  const nsStyleText* textStyle = aFrame->GetStyleText();
+  const nsStyleText* textStyle = aFrame->StyleText();
   if (!textStyle->HasTextShadow(aFrame))
     return aTextAndDecorationsRect;
 
   nsRect resultRect = aTextAndDecorationsRect;
   int32_t A2D = aFrame->PresContext()->AppUnitsPerDevPixel();
   for (uint32_t i = 0; i < textStyle->mTextShadow->Length(); ++i) {
     nsCSSShadowItem* shadow = textStyle->mTextShadow->ShadowAt(i);
     nsMargin blur = nsContextBoxBlur::GetBlurRadiusMargin(shadow->mRadius, A2D);
@@ -2342,25 +2342,25 @@ nsLayoutUtils::GetFontMetricsForFrame(co
 nsresult
 nsLayoutUtils::GetFontMetricsForStyleContext(nsStyleContext* aStyleContext,
                                              nsFontMetrics** aFontMetrics,
                                              float aInflation)
 {
   // pass the user font set object into the device context to pass along to CreateFontGroup
   gfxUserFontSet* fs = aStyleContext->PresContext()->GetUserFontSet();
 
-  nsFont font = aStyleContext->GetStyleFont()->mFont;
+  nsFont font = aStyleContext->StyleFont()->mFont;
   // We need to not run font.size through floats when it's large since
   // doing so would be lossy.  Fortunately, in such cases, aInflation is
   // guaranteed to be 1.0f.
   if (aInflation != 1.0f) {
     font.size = NSToCoordRound(font.size * aInflation);
   }
   return aStyleContext->PresContext()->DeviceContext()->GetMetricsFor(
-                  font, aStyleContext->GetStyleFont()->mLanguage,
+                  font, aStyleContext->StyleFont()->mLanguage,
                   fs, *aFontMetrics);
 }
 
 nsIFrame*
 nsLayoutUtils::FindChildContainingDescendant(nsIFrame* aParent, nsIFrame* aDescendantFrame)
 {
   nsIFrame* result = aDescendantFrame;
 
@@ -2540,17 +2540,17 @@ GetPercentHeight(const nsStyleCoord& aSt
              "GetAbsoluteCoord should have handled this");
 
   nsIFrame *f = aFrame->GetContainingBlock();
   if (!f) {
     NS_NOTREACHED("top of frame tree not a containing block");
     return false;
   }
 
-  const nsStylePosition *pos = f->GetStylePosition();
+  const nsStylePosition *pos = f->StylePosition();
   nscoord h;
   if (!GetAbsoluteCoord(pos->mHeight, h) &&
       !GetPercentHeight(pos->mHeight, f, h)) {
     NS_ASSERTION(pos->mHeight.GetUnit() == eStyleUnit_Auto ||
                  pos->mHeight.HasPercent(),
                  "unknown height unit");
     nsIAtom* fType = f->GetType();
     if (fType != nsGkAtoms::viewportFrame && fType != nsGkAtoms::canvasFrame &&
@@ -2678,17 +2678,17 @@ nsLayoutUtils::IntrinsicForContainer(nsR
 
   // If aFrame is a container for font size inflation, then shrink
   // wrapping inside of it should not apply font size inflation.
   AutoMaybeDisableFontInflation an(aFrame);
 
   nsIFrame::IntrinsicWidthOffsetData offsets =
     aFrame->IntrinsicWidthOffsets(aRenderingContext);
 
-  const nsStylePosition *stylePos = aFrame->GetStylePosition();
+  const nsStylePosition *stylePos = aFrame->StylePosition();
   uint8_t boxSizing = stylePos->mBoxSizing;
   const nsStyleCoord &styleWidth = stylePos->mWidth;
   const nsStyleCoord &styleMinWidth = stylePos->mMinWidth;
   const nsStyleCoord &styleMaxWidth = stylePos->mMaxWidth;
 
   // We build up two values starting with the content box, and then
   // adding padding, border and margin.  The result is normally
   // |result|.  Then, when we handle 'width', 'min-width', and
@@ -2765,23 +2765,23 @@ nsLayoutUtils::IntrinsicForContainer(nsR
         styleMaxHeight.GetUnit() != eStyleUnit_None) {
 
       nsSize ratio = aFrame->GetIntrinsicRatio();
 
       if (ratio.height != 0) {
         nscoord heightTakenByBoxSizing = 0;
         switch (boxSizing) {
         case NS_STYLE_BOX_SIZING_BORDER: {
-          const nsStyleBorder* styleBorder = aFrame->GetStyleBorder();
+          const nsStyleBorder* styleBorder = aFrame->StyleBorder();
           heightTakenByBoxSizing +=
             styleBorder->GetComputedBorder().TopBottom();
           // fall through
         }
         case NS_STYLE_BOX_SIZING_PADDING: {
-          const nsStylePadding* stylePadding = aFrame->GetStylePadding();
+          const nsStylePadding* stylePadding = aFrame->StylePadding();
           nscoord pad;
           if (GetAbsoluteCoord(stylePadding->mPadding.GetTop(), pad) ||
               GetPercentHeight(stylePadding->mPadding.GetTop(), aFrame, pad)) {
             heightTakenByBoxSizing += pad;
           }
           if (GetAbsoluteCoord(stylePadding->mPadding.GetBottom(), pad) ||
               GetPercentHeight(stylePadding->mPadding.GetBottom(), aFrame, pad)) {
             heightTakenByBoxSizing += pad;
@@ -2906,17 +2906,17 @@ nsLayoutUtils::IntrinsicForContainer(nsR
     if (result < minw)
       result = minw;
   }
 
   min = AddPercents(aType, min, pctTotal);
   if (result < min)
     result = min;
 
-  const nsStyleDisplay *disp = aFrame->GetStyleDisplay();
+  const nsStyleDisplay *disp = aFrame->StyleDisplay();
   if (aFrame->IsThemed(disp)) {
     nsIntSize size(0, 0);
     bool canOverride = true;
     nsPresContext *presContext = aFrame->PresContext();
     presContext->GetTheme()->
       GetMinimumWidgetSize(aRenderingContext, aFrame, disp->mAppearance,
                            &size, &canOverride);
 
@@ -3050,33 +3050,33 @@ nsLayoutUtils::ComputeHeightDependentVal
 
 /* static */ nsSize
 nsLayoutUtils::ComputeSizeWithIntrinsicDimensions(
                    nsRenderingContext* aRenderingContext, nsIFrame* aFrame,
                    const nsIFrame::IntrinsicSize& aIntrinsicSize,
                    nsSize aIntrinsicRatio, nsSize aCBSize,
                    nsSize aMargin, nsSize aBorder, nsSize aPadding)
 {
-  const nsStylePosition* stylePos = aFrame->GetStylePosition();
+  const nsStylePosition* stylePos = aFrame->StylePosition();
 
   // If we're a flex item, we'll compute our size a bit differently.
   const nsStyleCoord* widthStyleCoord = &(stylePos->mWidth);
   const nsStyleCoord* heightStyleCoord = &(stylePos->mHeight);
 
   bool isFlexItem = aFrame->IsFlexItem();
   bool isHorizontalFlexItem = false;
 
 #ifdef MOZ_FLEXBOX
   if (isFlexItem) {
     // Flex items use their "flex-basis" property in place of their main-size
     // property (e.g. "width") for sizing purposes, *unless* they have
     // "flex-basis:auto", in which case they use their main-size property after
     // all.
     uint32_t flexDirection =
-      aFrame->GetParent()->GetStylePosition()->mFlexDirection;
+      aFrame->GetParent()->StylePosition()->mFlexDirection;
     isHorizontalFlexItem =
       flexDirection == NS_STYLE_FLEX_DIRECTION_ROW ||
       flexDirection == NS_STYLE_FLEX_DIRECTION_ROW_REVERSE;
 
     // NOTE: The logic here should match the similar chunk for determining
     // widthStyleCoord and heightStyleCoord in nsFrame::ComputeSize().
     const nsStyleCoord* flexBasis = &(stylePos->mFlexBasis);
     if (flexBasis->GetUnit() != eStyleUnit_Auto) {
@@ -3469,17 +3469,17 @@ nsLayoutUtils::DrawString(const nsIFrame
                           nsPoint              aPoint,
                           uint8_t              aDirection)
 {
 #ifdef IBMBIDI
   nsresult rv = NS_ERROR_FAILURE;
   nsPresContext* presContext = aFrame->PresContext();
   if (presContext->BidiEnabled()) {
     if (aDirection == NS_STYLE_DIRECTION_INHERIT) {
-      aDirection = aFrame->GetStyleVisibility()->mDirection;
+      aDirection = aFrame->StyleVisibility()->mDirection;
     }
     nsBidiDirection direction =
       (NS_STYLE_DIRECTION_RTL == aDirection) ?
       NSBIDI_RTL : NSBIDI_LTR;
     rv = nsBidiPresUtils::RenderText(aString, aLength, direction,
                                      presContext, *aContext, *aContext,
                                      aPoint.x, aPoint.y);
   }
@@ -3495,17 +3495,17 @@ nscoord
 nsLayoutUtils::GetStringWidth(const nsIFrame*      aFrame,
                               nsRenderingContext* aContext,
                               const PRUnichar*     aString,
                               int32_t              aLength)
 {
 #ifdef IBMBIDI
   nsPresContext* presContext = aFrame->PresContext();
   if (presContext->BidiEnabled()) {
-    const nsStyleVisibility* vis = aFrame->GetStyleVisibility();
+    const nsStyleVisibility* vis = aFrame->StyleVisibility();
     nsBidiDirection direction =
       (NS_STYLE_DIRECTION_RTL == vis->mDirection) ?
       NSBIDI_RTL : NSBIDI_LTR;
     return nsBidiPresUtils::MeasureTextWidth(aString, aLength,
                                              direction, presContext, *aContext);
   }
 #endif // IBMBIDI
   aContext->SetTextRunRTL(false);
@@ -3516,17 +3516,17 @@ nsLayoutUtils::GetStringWidth(const nsIF
 nsLayoutUtils::PaintTextShadow(const nsIFrame* aFrame,
                                nsRenderingContext* aContext,
                                const nsRect& aTextRect,
                                const nsRect& aDirtyRect,
                                const nscolor& aForegroundColor,
                                TextShadowCallback aCallback,
                                void* aCallbackData)
 {
-  const nsStyleText* textStyle = aFrame->GetStyleText();
+  const nsStyleText* textStyle = aFrame->StyleText();
   if (!textStyle->HasTextShadow(aFrame))
     return;
 
   // Text shadow happens with the last value being painted at the back,
   // ie. it is painted first.
   gfxContext* aDestCtx = aContext->ThebesContext();
   for (uint32_t i = textStyle->mTextShadow->Length(); i > 0; --i) {
     nsCSSShadowItem* shadowDetails = textStyle->mTextShadow->ShadowAt(i - 1);
@@ -3779,17 +3779,17 @@ nsLayoutUtils::GetClosestLayer(nsIFrame*
 
 GraphicsFilter
 nsLayoutUtils::GetGraphicsFilterForFrame(nsIFrame* aForFrame)
 {
   GraphicsFilter defaultFilter = gfxPattern::FILTER_GOOD;
   nsIFrame *frame = nsCSSRendering::IsCanvasFrame(aForFrame) ?
     nsCSSRendering::FindBackgroundStyleFrame(aForFrame) : aForFrame;
 
-  switch (frame->GetStyleSVG()->mImageRendering) {
+  switch (frame->StyleSVG()->mImageRendering) {
   case NS_STYLE_IMAGE_RENDERING_OPTIMIZESPEED:
     return gfxPattern::FILTER_FAST;
   case NS_STYLE_IMAGE_RENDERING_OPTIMIZEQUALITY:
     return gfxPattern::FILTER_BEST;
   case NS_STYLE_IMAGE_RENDERING_CRISPEDGES:
     return gfxPattern::FILTER_NEAREST;
   default:
     return defaultFilter;
@@ -4302,26 +4302,26 @@ nsLayoutUtils::HasNonZeroCornerOnSide(co
       return true;
   }
   return false;
 }
 
 /* static */ nsTransparencyMode
 nsLayoutUtils::GetFrameTransparency(nsIFrame* aBackgroundFrame,
                                     nsIFrame* aCSSRootFrame) {
-  if (aCSSRootFrame->GetStyleDisplay()->mOpacity < 1.0f)
+  if (aCSSRootFrame->StyleDisplay()->mOpacity < 1.0f)
     return eTransparencyTransparent;
 
-  if (HasNonZeroCorner(aCSSRootFrame->GetStyleBorder()->mBorderRadius))
+  if (HasNonZeroCorner(aCSSRootFrame->StyleBorder()->mBorderRadius))
     return eTransparencyTransparent;
 
-  if (aCSSRootFrame->GetStyleDisplay()->mAppearance == NS_THEME_WIN_GLASS)
+  if (aCSSRootFrame->StyleDisplay()->mAppearance == NS_THEME_WIN_GLASS)
     return eTransparencyGlass;
 
-  if (aCSSRootFrame->GetStyleDisplay()->mAppearance == NS_THEME_WIN_BORDERLESS_GLASS)
+  if (aCSSRootFrame->StyleDisplay()->mAppearance == NS_THEME_WIN_BORDERLESS_GLASS)
     return eTransparencyBorderlessGlass;
 
   nsITheme::Transparency transparency;
   if (aCSSRootFrame->IsThemed(&transparency))
     return transparency == nsITheme::eTransparent
          ? eTransparencyTransparent
          : eTransparencyOpaque;
 
@@ -4333,17 +4333,17 @@ nsLayoutUtils::GetFrameTransparency(nsIF
     return eTransparencyOpaque;
   }
 
   nsStyleContext* bgSC;
   if (!nsCSSRendering::FindBackground(aBackgroundFrame->PresContext(),
                                       aBackgroundFrame, &bgSC)) {
     return eTransparencyTransparent;
   }
-  const nsStyleBackground* bg = bgSC->GetStyleBackground();
+  const nsStyleBackground* bg = bgSC->StyleBackground();
   if (NS_GET_A(bg->mBackgroundColor) < 255 ||
       // bottom layer's clip is used for the color
       bg->BottomLayer().mClip != NS_STYLE_BG_CLIP_BORDER)
     return eTransparencyTransparent;
   return eTransparencyOpaque;
 }
 
 static bool IsPopupFrame(nsIFrame* aFrame)
@@ -4393,17 +4393,17 @@ nsLayoutUtils::GetDisplayRootFrame(nsIFr
 nsLayoutUtils::GetTextRunFlagsForStyle(nsStyleContext* aStyleContext,
                                        const nsStyleFont* aStyleFont,
                                        nscoord aLetterSpacing)
 {
   uint32_t result = 0;
   if (aLetterSpacing != 0) {
     result |= gfxTextRunFactory::TEXT_DISABLE_OPTIONAL_LIGATURES;
   }
-  switch (aStyleContext->GetStyleSVG()->mTextRendering) {
+  switch (aStyleContext->StyleSVG()->mTextRendering) {
   case NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED:
     result |= gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
     break;
   case NS_STYLE_TEXT_RENDERING_AUTO:
     if (aStyleFont->mFont.size <
         aStyleContext->PresContext()->GetAutoQualityMinFontSize()) {
       result |= gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
     }
@@ -4469,17 +4469,17 @@ nsLayoutUtils::GetDeviceContextForScreen
   return nullptr;
 }
 
 /* static */ bool
 nsLayoutUtils::IsReallyFixedPos(nsIFrame* aFrame)
 {
   NS_PRECONDITION(aFrame->GetParent(),
                   "IsReallyFixedPos called on frame not in tree");
-  NS_PRECONDITION(aFrame->GetStyleDisplay()->mPosition ==
+  NS_PRECONDITION(aFrame->StyleDisplay()->mPosition ==
                     NS_STYLE_POSITION_FIXED,
                   "IsReallyFixedPos called on non-'position:fixed' frame");
 
   nsIAtom *parentType = aFrame->GetParent()->GetType();
   return parentType == nsGkAtoms::viewportFrame ||
          parentType == nsGkAtoms::pageContentFrame;
 }
 
@@ -5184,17 +5184,17 @@ MinimumFontSizeFor(nsPresContext* aPresC
 
 /* static */ float
 nsLayoutUtils::FontSizeInflationInner(const nsIFrame *aFrame,
                                       nscoord aMinFontSize)
 {
   // Note that line heights should be inflated by the same ratio as the
   // font size of the same text; thus we operate only on the font size
   // even when we're scaling a line height.
-  nscoord styleFontSize = aFrame->GetStyleFont()->mFont.size;
+  nscoord styleFontSize = aFrame->StyleFont()->mFont.size;
   if (styleFontSize <= 0) {
     // Never scale zero font size.
     return 1.0;
   }
 
   if (aMinFontSize <= 0) {
     // No need to scale.
     return 1.0;
@@ -5211,18 +5211,18 @@ nsLayoutUtils::FontSizeInflationInner(co
     // Also, if there is more than one frame corresponding to a single
     // content node, we want the outermost one.
     if (!(f->GetParent() && f->GetParent()->GetContent() == content) &&
         // ignore width/height on inlines since they don't apply
         fType != nsGkAtoms::inlineFrame &&
         // ignore width on radios and checkboxes since we enlarge them and
         // they have width/height in ua.css
         fType != nsGkAtoms::formControlFrame) {
-      nsStyleCoord stylePosWidth = f->GetStylePosition()->mWidth;
-      nsStyleCoord stylePosHeight = f->GetStylePosition()->mHeight;
+      nsStyleCoord stylePosWidth = f->StylePosition()->mWidth;
+      nsStyleCoord stylePosHeight = f->StylePosition()->mHeight;
       if (stylePosWidth.GetUnit() != eStyleUnit_Auto ||
           stylePosHeight.GetUnit() != eStyleUnit_Auto) {
 
         return 1.0;
       }
     }
   }
 
@@ -5273,17 +5273,17 @@ ShouldInflateFontsForContainer(const nsI
 {
   // We only want to inflate fonts for text that is in a place
   // with room to expand.  The question is what the best heuristic for
   // that is...
   // For now, we're going to use NS_FRAME_IN_CONSTRAINED_HEIGHT, which
   // indicates whether the frame is inside something with a constrained
   // height (propagating down the tree), but the propagation stops when
   // we hit overflow-y: scroll or auto.
-  const nsStyleText* styleText = aFrame->GetStyleText();
+  const nsStyleText* styleText = aFrame->StyleText();
 
   return styleText->mTextSizeAdjust != NS_STYLE_TEXT_SIZE_ADJUST_NONE &&
          !(aFrame->GetStateBits() & NS_FRAME_IN_CONSTRAINED_HEIGHT) &&
          // We also want to disable font inflation for containers that have
          // preformatted text.
          styleText->WhiteSpaceCanWrap();
 }
 
@@ -5406,17 +5406,17 @@ nsLayoutUtils::FontSizeInflationEnabled(
 
   return true;
 }
 
 /* static */ nsRect
 nsLayoutUtils::GetBoxShadowRectForFrame(nsIFrame* aFrame, 
                                         const nsSize& aFrameSize)
 {
-  nsCSSShadowArray* boxShadows = aFrame->GetStyleBorder()->mBoxShadow;
+  nsCSSShadowArray* boxShadows = aFrame->StyleBorder()->mBoxShadow;
   if (!boxShadows) {
     return nsRect();
   }
   
   nsRect shadows;
   int32_t A2D = aFrame->PresContext()->AppUnitsPerDevPixel();
   for (uint32_t i = 0; i < boxShadows->Length(); ++i) {
     nsRect tmpRect(nsPoint(0, 0), aFrameSize);
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -8688,17 +8688,17 @@ void ReflowCountMgr::PaintCount(const ch
       nsFont font("Times", NS_FONT_STYLE_NORMAL, NS_FONT_VARIANT_NORMAL,
                   NS_FONT_WEIGHT_NORMAL, NS_FONT_STRETCH_NORMAL, 0,
                   nsPresContext::CSSPixelsToAppUnits(11));
 
       nsRefPtr<nsFontMetrics> fm;
       aPresContext->DeviceContext()->GetMetricsFor(font,
         // We have one frame, therefore we must have a root...
         aPresContext->GetPresShell()->GetRootFrame()->
-          GetStyleFont()->mLanguage,
+          StyleFont()->mLanguage,
         aPresContext->GetUserFontSet(), *getter_AddRefs(fm));
 
       aRenderingContext->SetFont(fm);
       char buf[16];
       sprintf(buf, "%d", counter->mCount);
       nscoord x = 0, y = fm->MaxAscent();
       nscoord width, height = fm->MaxHeight();
       aRenderingContext->SetTextRunRTL(false);
diff --git a/layout/base/nsQuoteList.cpp b/layout/base/nsQuoteList.cpp
--- a/layout/base/nsQuoteList.cpp
+++ b/layout/base/nsQuoteList.cpp
@@ -31,17 +31,17 @@ nsQuoteNode::InitTextFrame(nsGenConList*
 }
 
 const nsString*
 nsQuoteNode::Text()
 {
   NS_ASSERTION(mType == eStyleContentType_OpenQuote ||
                mType == eStyleContentType_CloseQuote,
                "should only be called when mText should be non-null");
-  const nsStyleQuotes* styleQuotes = mPseudoFrame->GetStyleQuotes();
+  const nsStyleQuotes* styleQuotes = mPseudoFrame->StyleQuotes();
   int32_t quotesCount = styleQuotes->QuotesCount(); // 0 if 'quotes:none'
   int32_t quoteDepth = Depth();
 
   // Reuse the last pair when the depth is greater than the number of
   // pairs of quotes.  (Also make 'quotes: none' and close-quote from
   // a depth of 0 equivalent for the next test.)
   if (quoteDepth >= quotesCount)
     quoteDepth = quotesCount - 1;
diff --git a/layout/doc/adding-style-props.html b/layout/doc/adding-style-props.html
--- a/layout/doc/adding-style-props.html
+++ b/layout/doc/adding-style-props.html
@@ -461,17 +461,17 @@ nsCSSPropList.h</a>.
 OK, finally the style system is supporting the new property. It is time to
 actually make use of it now.<br>
   <br>
 In layout, retrieve the styleStruct that has the new property from the frame's
 style context. Access the new property and get its value. It is that simple.
 For this example, it looks like this, in nsImageFrame:<br>
   <pre>        PRBool forceIcon = PR_FALSE;
 
-        if (GetStyleUIReset()-&gt;mForceBrokenImageIcon) {
+        if (StyleUIReset()-&gt;mForceBrokenImageIcon) {
           forceIcon = PR_TRUE;
         }
 
 </pre>
 Create some testcases with style rules that use the new property, make sure
 it is being parsed correctly. Test it in an external stylesheet and in inline
 style. Test that it is inherited correctly, or not inherited as appropriate
 to your property. Update this document with any further details, or correcting
diff --git a/layout/forms/nsButtonFrameRenderer.cpp b/layout/forms/nsButtonFrameRenderer.cpp
--- a/layout/forms/nsButtonFrameRenderer.cpp
+++ b/layout/forms/nsButtonFrameRenderer.cpp
@@ -161,31 +161,31 @@ void nsDisplayButtonBorderBackground::Pa
   mBFR->PaintBorderAndBackground(pc, *aCtx, mVisibleRect, r,
                                  aBuilder->GetBackgroundPaintFlags());
 }
 
 void nsDisplayButtonForeground::Paint(nsDisplayListBuilder* aBuilder,
                                       nsRenderingContext* aCtx)
 {
   nsPresContext *presContext = mFrame->PresContext();
-  const nsStyleDisplay *disp = mFrame->GetStyleDisplay();
+  const nsStyleDisplay *disp = mFrame->StyleDisplay();
   if (!mFrame->IsThemed(disp) ||
       !presContext->GetTheme()->ThemeDrawsFocusForWidget(presContext, mFrame, disp->mAppearance)) {
     // draw the focus and outline borders
     nsRect r = nsRect(ToReferenceFrame(), mFrame->GetSize());
     mBFR->PaintOutlineAndFocusBorders(presContext, *aCtx, mVisibleRect, r);
   }
 }
 
 nsresult
 nsButtonFrameRenderer::DisplayButton(nsDisplayListBuilder* aBuilder,
                                      nsDisplayList* aBackground,
                                      nsDisplayList* aForeground)
 {
-  if (mFrame->GetStyleBorder()->mBoxShadow) {
+  if (mFrame->StyleBorder()->mBoxShadow) {
     nsresult rv = aBackground->AppendNewToTop(new (aBuilder)
         nsDisplayButtonBoxShadowOuter(aBuilder, this));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   nsresult rv = aBackground->AppendNewToTop(new (aBuilder)
       nsDisplayButtonBorderBackground(aBuilder, this));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -276,20 +276,20 @@ nsButtonFrameRenderer::GetButtonInnerFoc
 
 
 nsMargin
 nsButtonFrameRenderer::GetButtonOuterFocusBorderAndPadding()
 {
   nsMargin result(0,0,0,0);
 
   if (mOuterFocusStyle) {
-    if (!mOuterFocusStyle->GetStylePadding()->GetPadding(result)) {
+    if (!mOuterFocusStyle->StylePadding()->GetPadding(result)) {
       NS_NOTYETIMPLEMENTED("percentage padding");
     }
-    result += mOuterFocusStyle->GetStyleBorder()->GetComputedBorder();
+    result += mOuterFocusStyle->StyleBorder()->GetComputedBorder();
   }
 
   return result;
 }
 
 nsMargin
 nsButtonFrameRenderer::GetButtonBorderAndPadding()
 {
@@ -300,35 +300,35 @@ nsButtonFrameRenderer::GetButtonBorderAn
  * Gets the size of the buttons border this is the union of the normal and disabled borders.
  */
 nsMargin
 nsButtonFrameRenderer::GetButtonInnerFocusMargin()
 {
   nsMargin innerFocusMargin(0,0,0,0);
 
   if (mInnerFocusStyle) {
-    const nsStyleMargin* margin = mInnerFocusStyle->GetStyleMargin();
+    const nsStyleMargin* margin = mInnerFocusStyle->StyleMargin();
     if (!margin->GetMargin(innerFocusMargin)) {
       NS_NOTYETIMPLEMENTED("percentage margin");
     }
   }
 
   return innerFocusMargin;
 }
 
 nsMargin
 nsButtonFrameRenderer::GetButtonInnerFocusBorderAndPadding()
 {
   nsMargin result(0,0,0,0);
 
   if (mInnerFocusStyle) {
-    if (!mInnerFocusStyle->GetStylePadding()->GetPadding(result)) {
+    if (!mInnerFocusStyle->StylePadding()->GetPadding(result)) {
       NS_NOTYETIMPLEMENTED("percentage padding");
     }
-    result += mInnerFocusStyle->GetStyleBorder()->GetComputedBorder();
+    result += mInnerFocusStyle->StyleBorder()->GetComputedBorder();
   }
 
   return result;
 }
 
 // gets all the focus borders and padding that will be added to the regular border
 nsMargin
 nsButtonFrameRenderer::GetAddedButtonBorderAndPadding()
diff --git a/layout/forms/nsComboboxControlFrame.cpp b/layout/forms/nsComboboxControlFrame.cpp
--- a/layout/forms/nsComboboxControlFrame.cpp
+++ b/layout/forms/nsComboboxControlFrame.cpp
@@ -669,17 +669,17 @@ nsComboboxControlFrame::AbsolutelyPositi
     NS_DispatchToCurrentThread(new nsAsyncResize(this));
     return eDropDownPositionPendingResize;
   }
 
   // Position the drop-down below if there is room, otherwise place it
   // on the side that has more room.
   bool b = dropdownSize.height <= below || below >= above;
   nsPoint dropdownPosition(0, b ? GetRect().height : -dropdownSize.height);
-  if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
+  if (StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
     // Align the right edge of the drop-down with the right edge of the control.
     dropdownPosition.x = GetRect().width - dropdownSize.width;
   }
 
   // Don't position the view unless the position changed since it might cause
   // a call to NotifyGeometryChange() and an infinite loop here.
   const nsPoint currentPos = mDropdownFrame->GetPosition();
   const nsPoint newPos = dropdownPosition + translation;
@@ -838,17 +838,17 @@ nsComboboxControlFrame::Reflow(nsPresCon
     // The reflow callback queue doesn't AddRef so we keep it alive until
     // it's released in its ReflowFinished / ReflowCallbackCanceled.
     resize.forget();
   }
 
   // Get the width of the vertical scrollbar.  That will be the width of the
   // dropdown button.
   nscoord buttonWidth;
-  const nsStyleDisplay *disp = GetStyleDisplay();
+  const nsStyleDisplay *disp = StyleDisplay();
   if (IsThemed(disp) && !aPresContext->GetTheme()->ThemeNeedsComboboxDropmarker()) {
     buttonWidth = 0;
   }
   else {
     nsIScrollableFrame* scrollable = do_QueryFrame(mListControlFrame);
     NS_ASSERTION(scrollable, "List must be a scrollable frame");
     buttonWidth =
       scrollable->GetDesiredScrollbarSizes(PresContext(),
@@ -889,17 +889,17 @@ nsComboboxControlFrame::Reflow(nsPresCon
                     mButtonFrame->GetUsedBorderAndPadding().TopBottom()) ||
                  (aReflowState.ComputedHeight() < displayHeight &&
                   displayHeight ==
                     mDisplayFrame->GetUsedBorderAndPadding().TopBottom()),
                  "Different heights?");
   }
 #endif
 
-  if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
+  if (StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
     // Make sure the right edge of the button frame stays where it is now
     buttonRect.x -= buttonWidth - buttonRect.width;
   }
   buttonRect.width = buttonWidth;
   mButtonFrame->SetRect(buttonRect);
 
   return rv;
 }
@@ -1139,17 +1139,17 @@ nsComboboxControlFrame::HandleEvent(nsPr
 
   nsEventStates eventStates = mContent->AsElement()->State();
   if (eventStates.HasState(NS_EVENT_STATE_DISABLED)) {
     return NS_OK;
   }
 
   // If we have style that affects how we are selected, feed event down to
   // nsFrame::HandleEvent so that selection takes place when appropriate.
-  const nsStyleUserInterface* uiStyle = GetStyleUserInterface();
+  const nsStyleUserInterface* uiStyle = StyleUserInterface();
   if (uiStyle->mUserInput == NS_STYLE_USER_INPUT_NONE || uiStyle->mUserInput == NS_STYLE_USER_INPUT_DISABLED)
     return nsBlockFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
 
   return NS_OK;
 }
 
 
 nsresult
@@ -1560,17 +1560,17 @@ nsComboboxControlFrame::BuildDisplayList
   }
 
   // draw a focus indicator only when focus rings should be drawn
   nsIDocument* doc = mContent->GetCurrentDoc();
   if (doc) {
     nsPIDOMWindow* window = doc->GetWindow();
     if (window && window->ShouldShowFocusRing()) {
       nsPresContext *presContext = PresContext();
-      const nsStyleDisplay *disp = GetStyleDisplay();
+      const nsStyleDisplay *disp = StyleDisplay();
       if ((!IsThemed(disp) ||
            !presContext->GetTheme()->ThemeDrawsFocusForWidget(presContext, this, disp->mAppearance)) &&
           mDisplayFrame && IsVisibleForPainting(aBuilder)) {
         nsresult rv = aLists.Content()->AppendNewToTop(
             new (aBuilder) nsDisplayComboboxFocus(aBuilder, this));
         NS_ENSURE_SUCCESS(rv, rv);
       }
     }
@@ -1594,17 +1594,17 @@ void nsComboboxControlFrame::PaintFocus(
   // REVIEW: Why does the old code paint mDisplayFrame again? We've
   // already painted it in the children above. So clipping it here won't do
   // us much good.
 
   /////////////////////
   // draw focus
 
   aRenderingContext.SetLineStyle(nsLineStyle_kDotted);
-  aRenderingContext.SetColor(GetStyleColor()->mColor);
+  aRenderingContext.SetColor(StyleColor()->mColor);
 
   //aRenderingContext.DrawRect(clipRect);
 
   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
   clipRect.width -= onePixel;
   clipRect.height -= onePixel;
   aRenderingContext.DrawLine(clipRect.TopLeft(), clipRect.TopRight());
   aRenderingContext.DrawLine(clipRect.TopRight(), clipRect.BottomRight());
diff --git a/layout/forms/nsFieldSetFrame.cpp b/layout/forms/nsFieldSetFrame.cpp
--- a/layout/forms/nsFieldSetFrame.cpp
+++ b/layout/forms/nsFieldSetFrame.cpp
@@ -181,17 +181,17 @@ NS_IMETHODIMP
 nsFieldSetFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                   const nsRect&           aDirtyRect,
                                   const nsDisplayListSet& aLists) {
   // Paint our background and border in a special way.
   // REVIEW: We don't really need to check frame emptiness here; if it's empty,
   // the background/border display item won't do anything, and if it isn't empty,
   // we need to paint the outline
   if (IsVisibleForPainting(aBuilder)) {
-    if (GetStyleBorder()->mBoxShadow) {
+    if (StyleBorder()->mBoxShadow) {
       nsresult rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
           nsDisplayBoxShadowOuter(aBuilder, this));
       NS_ENSURE_SUCCESS(rv, rv);
     }
 
     // don't bother checking to see if we really have a border or background.
     // we usually will have a border.
     nsresult rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
@@ -230,17 +230,17 @@ nsFieldSetFrame::BuildDisplayList(nsDisp
   contentDisplayItems.MoveTo(aLists);
   return NS_OK;
 }
 
 void
 nsFieldSetFrame::PaintBorderBackground(nsRenderingContext& aRenderingContext,
     nsPoint aPt, const nsRect& aDirtyRect, uint32_t aBGFlags)
 {
-  const nsStyleBorder* borderStyle = GetStyleBorder();
+  const nsStyleBorder* borderStyle = StyleBorder();
        
   nscoord topBorder = borderStyle->GetComputedBorderWidth(NS_SIDE_TOP);
   nscoord yoff = 0;
   nsPresContext* presContext = PresContext();
      
   // if the border is smaller than the legend. Move the border down
   // to be centered on the legend. 
   // FIXME: This means border-radius clamping is incorrect; we should
diff --git a/layout/forms/nsFileControlFrame.cpp b/layout/forms/nsFileControlFrame.cpp
--- a/layout/forms/nsFileControlFrame.cpp
+++ b/layout/forms/nsFileControlFrame.cpp
@@ -578,17 +578,17 @@ nsFileControlFrame::GetFormProperty(nsIA
 }
 
 NS_IMETHODIMP
 nsFileControlFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                      const nsRect&           aDirtyRect,
                                      const nsDisplayListSet& aLists)
 {
   // box-shadow
-  if (GetStyleBorder()->mBoxShadow) {
+  if (StyleBorder()->mBoxShadow) {
     nsresult rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
         nsDisplayBoxShadowOuter(aBuilder, this));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   // Our background is inherited to the text input, and we don't really want to
   // paint it or out padding and borders (which we never have anyway, per
   // styles in forms.css) -- doing it just makes us look ugly in some cases and
diff --git a/layout/forms/nsFormControlFrame.cpp b/layout/forms/nsFormControlFrame.cpp
--- a/layout/forms/nsFormControlFrame.cpp
+++ b/layout/forms/nsFormControlFrame.cpp
@@ -132,17 +132,17 @@ nsFormControlFrame::SetFocus(bool aOn, b
 }
 
 NS_METHOD
 nsFormControlFrame::HandleEvent(nsPresContext* aPresContext, 
                                           nsGUIEvent* aEvent,
                                           nsEventStatus* aEventStatus)
 {
   // Check for user-input:none style
-  const nsStyleUserInterface* uiStyle = GetStyleUserInterface();
+  const nsStyleUserInterface* uiStyle = StyleUserInterface();
   if (uiStyle->mUserInput == NS_STYLE_USER_INPUT_NONE ||
       uiStyle->mUserInput == NS_STYLE_USER_INPUT_DISABLED)
     return nsFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
 
   return NS_OK;
 }
 
 void
diff --git a/layout/forms/nsGfxButtonControlFrame.cpp b/layout/forms/nsGfxButtonControlFrame.cpp
--- a/layout/forms/nsGfxButtonControlFrame.cpp
+++ b/layout/forms/nsGfxButtonControlFrame.cpp
@@ -199,17 +199,17 @@ nsGfxButtonControlFrame::GetLabel(nsXPID
     // because the value is localized for non-english platforms, thus
     // it might not be the string "Reset", "Submit Query", or "Browse..."
     rv = GetDefaultLabel(aLabel);
   }
 
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Compress whitespace out of label if needed.
-  if (!GetStyleText()->WhiteSpaceIsSignificant()) {
+  if (!StyleText()->WhiteSpaceIsSignificant()) {
     aLabel.CompressWhitespace();
   } else if (aLabel.Length() > 2 && aLabel.First() == ' ' &&
              aLabel.CharAt(aLabel.Length() - 1) == ' ') {
     // This is a bit of a hack.  The reason this is here is as follows: we now
     // have default padding on our buttons to make them non-ugly.
     // Unfortunately, IE-windows does not have such padding, so people will
     // stick values like " ok " (with the spaces) in the buttons in an attempt
     // to make them look decent.  Unfortunately, if they do this the button
@@ -273,14 +273,14 @@ nsGfxButtonControlFrame::HandleEvent(nsP
                                       nsGUIEvent*     aEvent,
                                       nsEventStatus*  aEventStatus)
 {
   // Override the HandleEvent to prevent the nsFrame::HandleEvent
   // from being called. The nsFrame::HandleEvent causes the button label
   // to be selected (Drawn with an XOR rectangle over the label)
 
   // do we have user-input style?
-  const nsStyleUserInterface* uiStyle = GetStyleUserInterface();
+  const nsStyleUserInterface* uiStyle = StyleUserInterface();
   if (uiStyle->mUserInput == NS_STYLE_USER_INPUT_NONE || uiStyle->mUserInput == NS_STYLE_USER_INPUT_DISABLED)
     return nsFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
   
   return NS_OK;
 }
diff --git a/layout/forms/nsGfxCheckboxControlFrame.cpp b/layout/forms/nsGfxCheckboxControlFrame.cpp
--- a/layout/forms/nsGfxCheckboxControlFrame.cpp
+++ b/layout/forms/nsGfxCheckboxControlFrame.cpp
@@ -40,33 +40,33 @@ PaintCheckMark(nsIFrame* aFrame,
   nsPoint paintPolygon[checkNumPoints];
   // Convert checkmark for screen rendering
   for (int32_t polyIndex = 0; polyIndex < checkNumPoints; polyIndex++) {
     paintPolygon[polyIndex] = paintCenter +
                               nsPoint(checkPolygonX[polyIndex] * paintScale,
                                       checkPolygonY[polyIndex] * paintScale);
   }
 
-  aCtx->SetColor(aFrame->GetStyleColor()->mColor);
+  aCtx->SetColor(aFrame->StyleColor()->mColor);
   aCtx->FillPolygon(paintPolygon, checkNumPoints);
 }
 
 static void
 PaintIndeterminateMark(nsIFrame* aFrame,
                        nsRenderingContext* aCtx,
                        const nsRect& aDirtyRect,
                        nsPoint aPt)
 {
   nsRect rect(aPt, aFrame->GetSize());
   rect.Deflate(aFrame->GetUsedBorderAndPadding());
 
   rect.y += (rect.height - rect.height/4) / 2;
   rect.height /= 4;
 
-  aCtx->SetColor(aFrame->GetStyleColor()->mColor);
+  aCtx->SetColor(aFrame->StyleColor()->mColor);
   aCtx->FillRect(rect);
 }
 
 //------------------------------------------------------------
 nsIFrame*
 NS_NewGfxCheckboxControlFrame(nsIPresShell* aPresShell,
                               nsStyleContext* aContext)
 {
diff --git a/layout/forms/nsGfxRadioControlFrame.cpp b/layout/forms/nsGfxRadioControlFrame.cpp
--- a/layout/forms/nsGfxRadioControlFrame.cpp
+++ b/layout/forms/nsGfxRadioControlFrame.cpp
@@ -50,17 +50,17 @@ PaintCheckedRadioButton(nsIFrame* aFrame
 {
   // The dot is an ellipse 2px on all sides smaller than the content-box,
   // drawn in the foreground color.
   nsRect rect(aPt, aFrame->GetSize());
   rect.Deflate(aFrame->GetUsedBorderAndPadding());
   rect.Deflate(nsPresContext::CSSPixelsToAppUnits(2),
                nsPresContext::CSSPixelsToAppUnits(2));
 
-  aCtx->SetColor(aFrame->GetStyleColor()->mColor);
+  aCtx->SetColor(aFrame->StyleColor()->mColor);
   aCtx->FillEllipse(rect);
 }
 
 NS_IMETHODIMP
 nsGfxRadioControlFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                          const nsRect&           aDirtyRect,
                                          const nsDisplayListSet& aLists)
 {
diff --git a/layout/forms/nsHTMLButtonControlFrame.cpp b/layout/forms/nsHTMLButtonControlFrame.cpp
--- a/layout/forms/nsHTMLButtonControlFrame.cpp
+++ b/layout/forms/nsHTMLButtonControlFrame.cpp
@@ -131,18 +131,18 @@ nsHTMLButtonControlFrame::BuildDisplayLi
     // That should put the display items in set.Content()
   }
   
   // Put the foreground outline and focus rects on top of the children
   set.Content()->AppendToTop(&onTop);
 
   // clips to our padding box for <input>s but not <button>s, unless
   // they have non-visible overflow..
-  if (IsInput() || GetStyleDisplay()->mOverflowX != NS_STYLE_OVERFLOW_VISIBLE) {
-    nsMargin border = GetStyleBorder()->GetComputedBorder();
+  if (IsInput() || StyleDisplay()->mOverflowX != NS_STYLE_OVERFLOW_VISIBLE) {
+    nsMargin border = StyleBorder()->GetComputedBorder();
     nsRect rect(aBuilder->ToReferenceFrame(this), GetSize());
     rect.Deflate(border);
     nscoord radii[8];
     GetPaddingBoxBorderRadii(radii);
 
     nsresult rv = OverflowClip(aBuilder, set, aLists, rect, radii);
     NS_ENSURE_SUCCESS(rv, rv);
   } else {
diff --git a/layout/forms/nsImageControlFrame.cpp b/layout/forms/nsImageControlFrame.cpp
--- a/layout/forms/nsImageControlFrame.cpp
+++ b/layout/forms/nsImageControlFrame.cpp
@@ -168,17 +168,17 @@ nsImageControlFrame::HandleEvent(nsPresC
   NS_ENSURE_ARG_POINTER(aEventStatus);
 
   // Don't do anything if the event has already been handled by someone
   if (nsEventStatus_eConsumeNoDefault == *aEventStatus) {
     return NS_OK;
   }
 
   // do we have user-input style?
-  const nsStyleUserInterface* uiStyle = GetStyleUserInterface();
+  const nsStyleUserInterface* uiStyle = StyleUserInterface();
   if (uiStyle->mUserInput == NS_STYLE_USER_INPUT_NONE || uiStyle->mUserInput == NS_STYLE_USER_INPUT_DISABLED)
     return nsFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
 
   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::disabled)) { // XXX cache disabled
     return NS_OK;
   }
 
   *aEventStatus = nsEventStatus_eIgnore;
@@ -207,17 +207,17 @@ nsImageControlFrame::SetFocus(bool aOn, 
 }
 
 NS_IMETHODIMP
 nsImageControlFrame::GetCursor(const nsPoint&    aPoint,
                                nsIFrame::Cursor& aCursor)
 {
   // Use style defined cursor if one is provided, otherwise when
   // the cursor style is "auto" we use the pointer cursor.
-  FillCursorInformationFromStyle(GetStyleUserInterface(), aCursor);
+  FillCursorInformationFromStyle(StyleUserInterface(), aCursor);
 
   if (NS_STYLE_CURSOR_AUTO == aCursor.mCursor) {
     aCursor.mCursor = NS_STYLE_CURSOR_POINTER;
   }
 
   return NS_OK;
 }
 
diff --git a/layout/forms/nsLegendFrame.cpp b/layout/forms/nsLegendFrame.cpp
--- a/layout/forms/nsLegendFrame.cpp
+++ b/layout/forms/nsLegendFrame.cpp
@@ -12,17 +12,17 @@
 #include "nsGkAtoms.h"
 #include "nsStyleConsts.h"
 #include "nsFormControlFrame.h"
 
 nsIFrame*
 NS_NewLegendFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 {
 #ifdef DEBUG
-  const nsStyleDisplay* disp = aContext->GetStyleDisplay();
+  const nsStyleDisplay* disp = aContext->StyleDisplay();
   NS_ASSERTION(!disp->IsAbsolutelyPositionedStyle() && !disp->IsFloatingStyle(),
                "Legends should not be positioned and should not float");
 #endif
 
   nsIFrame* f = new (aPresShell) nsLegendFrame(aContext);
   if (f) {
     f->AddStateBits(NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT);
   }
@@ -63,17 +63,17 @@ nsLegendFrame::Reflow(nsPresContext*    
 }
 
 // REVIEW: We don't need to override BuildDisplayList, nsBlockFrame will honour
 // our visibility setting
 int32_t nsLegendFrame::GetAlign()
 {
   int32_t intValue = NS_STYLE_TEXT_ALIGN_LEFT;
 #ifdef IBMBIDI
-  if (mParent && NS_STYLE_DIRECTION_RTL == mParent->GetStyleVisibility()->mDirection) {
+  if (mParent && NS_STYLE_DIRECTION_RTL == mParent->StyleVisibility()->mDirection) {
     intValue = NS_STYLE_TEXT_ALIGN_RIGHT;
   }
 #endif // IBMBIDI
 
   nsGenericHTMLElement *content = nsGenericHTMLElement::FromContent(mContent);
 
   if (content) {
     const nsAttrValue* attr = content->GetParsedAttr(nsGkAtoms::align);
diff --git a/layout/forms/nsListControlFrame.cpp b/layout/forms/nsListControlFrame.cpp
--- a/layout/forms/nsListControlFrame.cpp
+++ b/layout/forms/nsListControlFrame.cpp
@@ -930,17 +930,17 @@ nsListControlFrame::HandleEvent(nsPresCo
     printf("Mouse in ListFrame <UNKNOWN> [%d]\n", aEvent->message);
   }*/
 
   if (nsEventStatus_eConsumeNoDefault == *aEventStatus)
     return NS_OK;
 
   // do we have style that affects how we are selected?
   // do we have user-input style?
-  const nsStyleUserInterface* uiStyle = GetStyleUserInterface();
+  const nsStyleUserInterface* uiStyle = StyleUserInterface();
   if (uiStyle->mUserInput == NS_STYLE_USER_INPUT_NONE || uiStyle->mUserInput == NS_STYLE_USER_INPUT_DISABLED)
     return nsFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
 
   nsEventStates eventStates = mContent->AsElement()->State();
   if (eventStates.HasState(NS_EVENT_STATE_DISABLED))
     return NS_OK;
 
   return nsHTMLScrollFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
@@ -1620,17 +1620,17 @@ nsListControlFrame::AboutToDropDown()
   // backgrounds. We compose with the PresContext default background color,
   // which is always opaque, in case we don't end up with an opaque color.
   // This gives us a very poor approximation of translucency.
   nsIFrame* comboboxFrame = do_QueryFrame(mComboboxFrame);
   nsStyleContext* context = comboboxFrame->StyleContext()->GetParent();
   mLastDropdownBackstopColor = NS_RGBA(0,0,0,0);
   while (NS_GET_A(mLastDropdownBackstopColor) < 255 && context) {
     mLastDropdownBackstopColor =
-      NS_ComposeColors(context->GetStyleBackground()->mBackgroundColor,
+      NS_ComposeColors(context->StyleBackground()->mBackgroundColor,
                        mLastDropdownBackstopColor);
     context = context->GetParent();
   }
   mLastDropdownBackstopColor =
     NS_ComposeColors(PresContext()->DefaultBackgroundColor(),
                      mLastDropdownBackstopColor);
 
   if (mIsAllContentHere && mIsAllFramesHere && mHasBeenInitialized) {
@@ -1805,17 +1805,17 @@ nsListControlFrame::MouseUp(nsIDOMEvent*
       CaptureMouseEvents(false);
       return NS_ERROR_FAILURE; // means consume event
     } else {
       CaptureMouseEvents(false);
       return NS_OK;
     }
   }
 
-  const nsStyleVisibility* vis = GetStyleVisibility();
+  const nsStyleVisibility* vis = StyleVisibility();
       
   if (!vis->IsVisible()) {
     return NS_OK;
   }
 
   if (IsInDropDownMode()) {
     // XXX This is a bit of a hack, but.....
     // But the idea here is to make sure you get an "onclick" event when you mouse
diff --git a/layout/forms/nsMeterFrame.cpp b/layout/forms/nsMeterFrame.cpp
--- a/layout/forms/nsMeterFrame.cpp
+++ b/layout/forms/nsMeterFrame.cpp
@@ -135,17 +135,17 @@ NS_IMETHODIMP nsMeterFrame::Reflow(nsPre
 }
 
 void
 nsMeterFrame::ReflowBarFrame(nsIFrame*                aBarFrame,
                              nsPresContext*           aPresContext,
                              const nsHTMLReflowState& aReflowState,
                              nsReflowStatus&          aStatus)
 {
-  bool vertical = GetStyleDisplay()->mOrient == NS_STYLE_ORIENT_VERTICAL;
+  bool vertical = StyleDisplay()->mOrient == NS_STYLE_ORIENT_VERTICAL;
   nsHTMLReflowState reflowState(aPresContext, aReflowState, aBarFrame,
                                 nsSize(aReflowState.ComputedWidth(),
                                        NS_UNCONSTRAINEDSIZE));
   nscoord size = vertical ? aReflowState.ComputedHeight()
                           : aReflowState.ComputedWidth();
   nscoord xoffset = aReflowState.mComputedBorderPadding.left;
   nscoord yoffset = aReflowState.mComputedBorderPadding.top;
 
@@ -158,17 +158,17 @@ nsMeterFrame::ReflowBarFrame(nsIFrame*  
   meterElement->GetMin(&min);
   meterElement->GetValue(&value);
 
   position = max - min;
   position = position != 0 ? (value - min) / position : 1;
 
   size = NSToCoordRound(size * position);
 
-  if (!vertical && GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
+  if (!vertical && StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
     xoffset += aReflowState.ComputedWidth() - size;
   }
 
   // The bar position is *always* constrained.
   if (vertical) {
     // We want the bar to begin at the bottom.
     yoffset += aReflowState.ComputedHeight() - size;
 
@@ -225,17 +225,17 @@ nsMeterFrame::ComputeAutoSize(nsRenderin
   nsRefPtr<nsFontMetrics> fontMet;
   NS_ENSURE_SUCCESS(nsLayoutUtils::GetFontMetricsForFrame(this,
                                                           getter_AddRefs(fontMet)),
                     nsSize(0, 0));
 
   nsSize autoSize;
   autoSize.height = autoSize.width = fontMet->Font().size; // 1em
 
-  if (GetStyleDisplay()->mOrient == NS_STYLE_ORIENT_VERTICAL) {
+  if (StyleDisplay()->mOrient == NS_STYLE_ORIENT_VERTICAL) {
     autoSize.height *= 5; // 5em
   } else {
     autoSize.width *= 5; // 5em
   }
 
   return autoSize;
 }
 
@@ -243,18 +243,18 @@ nscoord
 nsMeterFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
 {
   nsRefPtr<nsFontMetrics> fontMet;
   NS_ENSURE_SUCCESS(
       nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fontMet)), 0);
 
   nscoord minWidth = fontMet->Font().size; // 1em
 
-  if (GetStyleDisplay()->mOrient == NS_STYLE_ORIENT_AUTO ||
-      GetStyleDisplay()->mOrient == NS_STYLE_ORIENT_HORIZONTAL) {
+  if (StyleDisplay()->mOrient == NS_STYLE_ORIENT_AUTO ||
+      StyleDisplay()->mOrient == NS_STYLE_ORIENT_HORIZONTAL) {
     // The orientation is horizontal
     minWidth *= 5; // 5em
   }
 
   return minWidth;
 }
 
 nscoord
@@ -265,16 +265,16 @@ nsMeterFrame::GetPrefWidth(nsRenderingCo
 
 bool
 nsMeterFrame::ShouldUseNativeStyle() const
 {
   // Use the native style if these conditions are satisfied:
   // - both frames use the native appearance;
   // - neither frame has author specified rules setting the border or the
   //   background.
-  return GetStyleDisplay()->mAppearance == NS_THEME_METERBAR &&
-         mBarDiv->GetPrimaryFrame()->GetStyleDisplay()->mAppearance == NS_THEME_METERBAR_CHUNK &&
+  return StyleDisplay()->mAppearance == NS_THEME_METERBAR &&
+         mBarDiv->GetPrimaryFrame()->StyleDisplay()->mAppearance == NS_THEME_METERBAR_CHUNK &&
          !PresContext()->HasAuthorSpecifiedRules(const_cast<nsMeterFrame*>(this),
                                                  NS_AUTHOR_SPECIFIED_BORDER | NS_AUTHOR_SPECIFIED_BACKGROUND) &&
          !PresContext()->HasAuthorSpecifiedRules(mBarDiv->GetPrimaryFrame(),
                                                  NS_AUTHOR_SPECIFIED_BORDER | NS_AUTHOR_SPECIFIED_BACKGROUND);
 }
 
diff --git a/layout/forms/nsProgressFrame.cpp b/layout/forms/nsProgressFrame.cpp
--- a/layout/forms/nsProgressFrame.cpp
+++ b/layout/forms/nsProgressFrame.cpp
@@ -143,17 +143,17 @@ NS_IMETHODIMP nsProgressFrame::Reflow(ns
 }
 
 void
 nsProgressFrame::ReflowBarFrame(nsIFrame*                aBarFrame,
                                 nsPresContext*           aPresContext,
                                 const nsHTMLReflowState& aReflowState,
                                 nsReflowStatus&          aStatus)
 {
-  bool vertical = GetStyleDisplay()->mOrient == NS_STYLE_ORIENT_VERTICAL;
+  bool vertical = StyleDisplay()->mOrient == NS_STYLE_ORIENT_VERTICAL;
   nsHTMLReflowState reflowState(aPresContext, aReflowState, aBarFrame,
                                 nsSize(aReflowState.ComputedWidth(),
                                        NS_UNCONSTRAINEDSIZE));
   nscoord size = vertical ? aReflowState.ComputedHeight()
                           : aReflowState.ComputedWidth();
   nscoord xoffset = aReflowState.mComputedBorderPadding.left;
   nscoord yoffset = aReflowState.mComputedBorderPadding.top;
 
@@ -163,17 +163,17 @@ nsProgressFrame::ReflowBarFrame(nsIFrame
   progressElement->GetPosition(&position);
 
   // Force the bar's size to match the current progress.
   // When indeterminate, the progress' size will be 100%.
   if (position >= 0.0) {
     size *= position;
   }
 
-  if (!vertical && GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
+  if (!vertical && StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
     xoffset += aReflowState.ComputedWidth() - size;
   }
 
   // The bar size is fixed in these cases:
   // - the progress position is determined: the bar size is fixed according
   //   to it's value.
   // - the progress position is indeterminate and the bar appearance should be
   //   shown as native: the bar size is forced to 100%.
@@ -241,17 +241,17 @@ nsProgressFrame::ComputeAutoSize(nsRende
   NS_ENSURE_SUCCESS(nsLayoutUtils::GetFontMetricsForFrame(this,
                                                           getter_AddRefs(fontMet),
                                                           inflation),
                     nsSize(0, 0));
 
   nsSize autoSize;
   autoSize.height = autoSize.width = fontMet->Font().size; // 1em
 
-  if (GetStyleDisplay()->mOrient == NS_STYLE_ORIENT_VERTICAL) {
+  if (StyleDisplay()->mOrient == NS_STYLE_ORIENT_VERTICAL) {
     autoSize.height *= 10; // 10em
   } else {
     autoSize.width *= 10; // 10em
   }
 
   return autoSize;
 }
 
@@ -259,18 +259,18 @@ nscoord
 nsProgressFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
 {
   nsRefPtr<nsFontMetrics> fontMet;
   NS_ENSURE_SUCCESS(
       nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fontMet)), 0);
 
   nscoord minWidth = fontMet->Font().size; // 1em
 
-  if (GetStyleDisplay()->mOrient == NS_STYLE_ORIENT_AUTO ||
-      GetStyleDisplay()->mOrient == NS_STYLE_ORIENT_HORIZONTAL) {
+  if (StyleDisplay()->mOrient == NS_STYLE_ORIENT_AUTO ||
+      StyleDisplay()->mOrient == NS_STYLE_ORIENT_HORIZONTAL) {
     // The orientation is horizontal
     minWidth *= 10; // 10em
   }
 
   return minWidth;
 }
 
 nscoord
@@ -281,16 +281,16 @@ nsProgressFrame::GetPrefWidth(nsRenderin
 
 bool
 nsProgressFrame::ShouldUseNativeStyle() const
 {
   // Use the native style if these conditions are satisfied:
   // - both frames use the native appearance;
   // - neither frame has author specified rules setting the border or the
   //   background.
-  return GetStyleDisplay()->mAppearance == NS_THEME_PROGRESSBAR &&
-         mBarDiv->GetPrimaryFrame()->GetStyleDisplay()->mAppearance == NS_THEME_PROGRESSBAR_CHUNK &&
+  return StyleDisplay()->mAppearance == NS_THEME_PROGRESSBAR &&
+         mBarDiv->GetPrimaryFrame()->StyleDisplay()->mAppearance == NS_THEME_PROGRESSBAR_CHUNK &&
          !PresContext()->HasAuthorSpecifiedRules(const_cast<nsProgressFrame*>(this),
                                                  NS_AUTHOR_SPECIFIED_BORDER | NS_AUTHOR_SPECIFIED_BACKGROUND) &&
          !PresContext()->HasAuthorSpecifiedRules(mBarDiv->GetPrimaryFrame(),
                                                  NS_AUTHOR_SPECIFIED_BORDER | NS_AUTHOR_SPECIFIED_BACKGROUND);
 }
 
diff --git a/layout/forms/nsTextControlFrame.cpp b/layout/forms/nsTextControlFrame.cpp
--- a/layout/forms/nsTextControlFrame.cpp
+++ b/layout/forms/nsTextControlFrame.cpp
@@ -220,26 +220,26 @@ nsTextControlFrame::CalcIntrinsicSize(ns
       aIntrinsicSize.width += 1;
     }
 
     // Also add in the padding of our value div child.  Note that it hasn't
     // been reflowed yet, so we can't get its used padding, but it shouldn't be
     // using percentage padding anyway.
     nsMargin childPadding;
     nsIFrame* firstChild = GetFirstPrincipalChild();
-    if (firstChild && firstChild->GetStylePadding()->GetPadding(childPadding)) {
+    if (firstChild && firstChild->StylePadding()->GetPadding(childPadding)) {
       aIntrinsicSize.width += childPadding.LeftRight();
     } else {
       NS_ERROR("Percentage padding on value div?");
     }
   }
 
   // Increment width with cols * letter-spacing.
   {
-    const nsStyleCoord& lsCoord = GetStyleText()->mLetterSpacing;
+    const nsStyleCoord& lsCoord = StyleText()->mLetterSpacing;
     if (eStyleUnit_Coord == lsCoord.GetUnit()) {
       nscoord letterSpacing = lsCoord.GetCoordValue();
       if (letterSpacing != 0) {
         aIntrinsicSize.width += cols * letterSpacing;
       }
     }
   }
 
@@ -484,17 +484,17 @@ nsTextControlFrame::ComputeAutoSize(nsRe
   nsSize autoSize;
   nsresult rv = CalcIntrinsicSize(aRenderingContext, autoSize, inflation);
   if (NS_FAILED(rv)) {
     // What now?
     autoSize.SizeTo(0, 0);
   }
 #ifdef DEBUG
   // Note: Ancestor ComputeAutoSize only computes a width if we're auto-width
-  else if (GetStylePosition()->mWidth.GetUnit() == eStyleUnit_Auto) {
+  else if (StylePosition()->mWidth.GetUnit() == eStyleUnit_Auto) {
     nsSize ancestorAutoSize =
       nsContainerFrame::ComputeAutoSize(aRenderingContext,
                                         aCBSize, aAvailableWidth,
                                         aMargin, aBorder,
                                         aPadding, aShrinkWrap);
     // Disabled when there's inflation; see comment in GetPrefSize.
     NS_ASSERTION(inflation != 1.0f || ancestorAutoSize.width == autoSize.width,
                  "Incorrect size computed by ComputeAutoSize?");
diff --git a/layout/generic/TextOverflow.cpp b/layout/generic/TextOverflow.cpp
--- a/layout/generic/TextOverflow.cpp
+++ b/layout/generic/TextOverflow.cpp
@@ -81,17 +81,17 @@ IsHorizontalOverflowVisible(nsIFrame* aF
 {
   NS_PRECONDITION(nsLayoutUtils::GetAsBlock(aFrame) != nullptr,
                   "expected a block frame");
 
   nsIFrame* f = aFrame;
   while (f && f->StyleContext()->GetPseudo()) {
     f = f->GetParent();
   }
-  return !f || f->GetStyleDisplay()->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE;
+  return !f || f->StyleDisplay()->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE;
 }
 
 static nsDisplayItem*
 ClipMarker(nsDisplayListBuilder* aBuilder,
            nsIFrame*             aFrame,
            nsDisplayItem*        aMarker,
            const nsRect&         aContentArea,
            nsRect*               aMarkerRect)
@@ -225,17 +225,17 @@ nsDisplayTextOverflowMarker::PaintTextTo
 void
 TextOverflow::Init(nsDisplayListBuilder*   aBuilder,
                    nsIFrame*               aBlockFrame)
 {
   mBuilder = aBuilder;
   mBlock = aBlockFrame;
   mContentArea = aBlockFrame->GetContentRectRelativeToSelf();
   mScrollableFrame = nsLayoutUtils::GetScrollableFrameFor(aBlockFrame);
-  uint8_t direction = aBlockFrame->GetStyleVisibility()->mDirection;
+  uint8_t direction = aBlockFrame->StyleVisibility()->mDirection;
   mBlockIsRTL = direction == NS_STYLE_DIRECTION_RTL;
   mAdjustForPixelSnapping = false;
 #ifdef MOZ_XUL
   if (!mScrollableFrame) {
     nsIAtom* pseudoType = aBlockFrame->StyleContext()->GetPseudo();
     if (pseudoType == nsCSSAnonBoxes::mozXULAnonymousBlock) {
       mScrollableFrame =
         nsLayoutUtils::GetScrollableFrameFor(aBlockFrame->GetParent());
@@ -255,17 +255,17 @@ TextOverflow::Init(nsDisplayListBuilder*
       // Scrolling to the end position can leave some text still overflowing due
       // to pixel snapping behaviour in our scrolling code.
       mAdjustForPixelSnapping = mCanHaveHorizontalScrollbar;
     }
     mContentArea.MoveBy(mScrollableFrame->GetScrollPosition());
     nsIFrame* scrollFrame = do_QueryFrame(mScrollableFrame);
     scrollFrame->AddStateBits(NS_SCROLLFRAME_INVALIDATE_CONTENTS_ON_SCROLL);
   }
-  const nsStyleTextReset* style = aBlockFrame->GetStyleTextReset();
+  const nsStyleTextReset* style = aBlockFrame->StyleTextReset();
   mLeft.Init(style->mTextOverflow.GetLeft(direction));
   mRight.Init(style->mTextOverflow.GetRight(direction));
   // The left/right marker string is setup in ExamineLineFrames when a line
   // has overflow on that side.
 }
 
 /* static */ TextOverflow*
 TextOverflow::WillProcessLines(nsDisplayListBuilder*   aBuilder,
@@ -289,17 +289,17 @@ TextOverflow::ExamineFrameSubtree(nsIFra
                                   InnerClipEdges* aClippedMarkerEdges)
 {
   const nsIAtom* frameType = aFrame->GetType();
   if (frameType == nsGkAtoms::brFrame ||
       frameType == nsGkAtoms::placeholderFrame) {
     return;
   }
   const bool isAtomic = IsAtomicElement(aFrame, frameType);
-  if (aFrame->GetStyleVisibility()->IsVisible()) {
+  if (aFrame->StyleVisibility()->IsVisible()) {
     nsRect childRect = aFrame->GetScrollableOverflowRect() +
                        aFrame->GetOffsetTo(mBlock);
     bool overflowLeft = childRect.x < aContentArea.x;
     bool overflowRight = childRect.XMost() > aContentArea.XMost();
     if (overflowLeft) {
       mLeft.mHasOverflow = true;
     }
     if (overflowRight) {
@@ -646,17 +646,17 @@ TextOverflow::PruneDisplayListContents(n
   }
   aList->AppendToTop(&saved);
 }
 
 /* static */ bool
 TextOverflow::CanHaveTextOverflow(nsDisplayListBuilder* aBuilder,
                                   nsIFrame*             aBlockFrame)
 {
-  const nsStyleTextReset* style = aBlockFrame->GetStyleTextReset();
+  const nsStyleTextReset* style = aBlockFrame->StyleTextReset();
   // Nothing to do for text-overflow:clip or if 'overflow-x:visible'
   // or if we're just building items for event processing.
   if ((style->mTextOverflow.mLeft.mType == NS_STYLE_TEXT_OVERFLOW_CLIP &&
        style->mTextOverflow.mRight.mType == NS_STYLE_TEXT_OVERFLOW_CLIP) ||
       IsHorizontalOverflowVisible(aBlockFrame) ||
       aBuilder->IsForEventDelivery()) {
     return false;
   }
diff --git a/layout/generic/nsAbsoluteContainingBlock.cpp b/layout/generic/nsAbsoluteContainingBlock.cpp
--- a/layout/generic/nsAbsoluteContainingBlock.cpp
+++ b/layout/generic/nsAbsoluteContainingBlock.cpp
@@ -191,17 +191,17 @@ static inline bool IsFixedMarginSize(con
 static inline bool IsFixedOffset(const nsStyleCoord& aCoord)
   { return aCoord.ConvertsToLength(); }
 
 bool
 nsAbsoluteContainingBlock::FrameDependsOnContainer(nsIFrame* f,
                                                    bool aCBWidthChanged,
                                                    bool aCBHeightChanged)
 {
-  const nsStylePosition* pos = f->GetStylePosition();
+  const nsStylePosition* pos = f->StylePosition();
   // See if f's position might have changed because it depends on a
   // placeholder's position
   // This can happen in the following cases:
   // 1) Vertical positioning.  "top" must be auto and "bottom" must be auto
   //    (otherwise the vertical position is completely determined by
   //    whichever of them is not auto and the height).
   // 2) Horizontal positioning.  "left" must be auto and "right" must be auto
   //    (otherwise the horizontal position is completely determined by
@@ -213,18 +213,18 @@ nsAbsoluteContainingBlock::FrameDependsO
       (pos->mOffset.GetLeftUnit() == eStyleUnit_Auto &&
        pos->mOffset.GetRightUnit() == eStyleUnit_Auto)) {
     return true;
   }
   if (!aCBWidthChanged && !aCBHeightChanged) {
     // skip getting style data
     return false;
   }
-  const nsStylePadding* padding = f->GetStylePadding();
-  const nsStyleMargin* margin = f->GetStyleMargin();
+  const nsStylePadding* padding = f->StylePadding();
+  const nsStyleMargin* margin = f->StyleMargin();
   if (aCBWidthChanged) {
     // See if f's width might have changed.
     // If border-left, border-right, padding-left, padding-right,
     // width, min-width, and max-width are all lengths, 'none', or enumerated,
     // then our frame width does not depend on the parent width.
     // Note that borders never depend on the parent width
     // XXX All of the enumerated values except -moz-available are ok too.
     if (pos->WidthDependsOnContainer() ||
@@ -237,17 +237,17 @@ nsAbsoluteContainingBlock::FrameDependsO
 
     // See if f's position might have changed. If we're RTL then the
     // rules are slightly different. We'll assume percentage or auto
     // margins will always induce a dependency on the size
     if (!IsFixedMarginSize(margin->mMargin.GetLeft()) ||
         !IsFixedMarginSize(margin->mMargin.GetRight())) {
       return true;
     }
-    if (f->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
+    if (f->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
       // Note that even if 'left' is a length, our position can
       // still depend on the containing block width, because if
       // 'right' is also a length we will discard 'left' and be
       // positioned relative to the containing block right edge.
       // 'left' length and 'right' auto is the only combination
       // we can be sure of.
       if (!IsFixedOffset(pos->mOffset.GetLeft()) ||
           pos->mOffset.GetRightUnit() != eStyleUnit_Auto) {
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -307,17 +307,17 @@ nsBlockFrame::DestroyFrom(nsIFrame* aDes
 
 /* virtual */ nsILineIterator*
 nsBlockFrame::GetLineIterator()
 {
   nsLineIterator* it = new nsLineIterator;
   if (!it)
     return nullptr;
 
-  const nsStyleVisibility* visibility = GetStyleVisibility();
+  const nsStyleVisibility* visibility = StyleVisibility();
   nsresult rv = it->Init(mLines, visibility->mDirection == NS_STYLE_DIRECTION_RTL);
   if (NS_FAILED(rv)) {
     delete it;
     return nullptr;
   }
   return it;
 }
 
@@ -734,17 +734,17 @@ nsBlockFrame::GetMinWidth(nsRenderingCon
                         line->mFirstChild, nsLayoutUtils::MIN_WIDTH);
         data.ForceBreak(aRenderingContext);
       } else {
         if (!curFrame->GetPrevContinuation() &&
             line == curFrame->begin_lines()) {
           // Only add text-indent if it has no percentages; using a
           // percentage basis of 0 unconditionally would give strange
           // behavior for calc(10%-3px).
-          const nsStyleCoord &indent = GetStyleText()->mTextIndent;
+          const nsStyleCoord &indent = StyleText()->mTextIndent;
           if (indent.ConvertsToLength())
             data.currentLine += nsRuleNode::ComputeCoordPercentCalc(indent, 0);
         }
         // XXX Bug NNNNNN Should probably handle percentage text-indent.
 
         data.line = &line;
         data.lineContainer = curFrame;
         nsIFrame *kid = line->mFirstChild;
@@ -814,17 +814,17 @@ nsBlockFrame::GetPrefWidth(nsRenderingCo
                         line->mFirstChild, nsLayoutUtils::PREF_WIDTH);
         data.ForceBreak(aRenderingContext);
       } else {
         if (!curFrame->GetPrevContinuation() &&
             line == curFrame->begin_lines()) {
           // Only add text-indent if it has no percentages; using a
           // percentage basis of 0 unconditionally would give strange
           // behavior for calc(10%-3px).
-          const nsStyleCoord &indent = GetStyleText()->mTextIndent;
+          const nsStyleCoord &indent = StyleText()->mTextIndent;
           if (indent.ConvertsToLength())
             data.currentLine += nsRuleNode::ComputeCoordPercentCalc(indent, 0);
         }
         // XXX Bug NNNNNN Should probably handle percentage text-indent.
 
         data.line = &line;
         data.lineContainer = curFrame;
         nsIFrame *kid = line->mFirstChild;
@@ -1590,30 +1590,30 @@ IsAlignedLeft(uint8_t aAlignment,
           (NS_STYLE_TEXT_ALIGN_END == aAlignment &&
            NS_STYLE_DIRECTION_RTL == aDirection)) &&
          !(NS_STYLE_UNICODE_BIDI_PLAINTEXT & aUnicodeBidi));
 }
 
 nsresult
 nsBlockFrame::PrepareResizeReflow(nsBlockReflowState& aState)
 {
-  const nsStyleText* styleText = GetStyleText();
-  const nsStyleTextReset* styleTextReset = GetStyleTextReset();
+  const nsStyleText* styleText = StyleText();
+  const nsStyleTextReset* styleTextReset = StyleTextReset();
   // See if we can try and avoid marking all the lines as dirty
   bool tryAndSkipLines =
     // The block must be LTR (bug 806284)
-    GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR &&
+    StyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR &&
     // The text must be left-aligned.
     IsAlignedLeft(styleText->mTextAlign, 
                   aState.mReflowState.mStyleVisibility->mDirection,
                   styleTextReset->mUnicodeBidi,
                   this) &&
     // The left content-edge must be a constant distance from the left
     // border-edge.
-    !GetStylePadding()->mPadding.GetLeft().HasPercent();
+    !StylePadding()->mPadding.GetLeft().HasPercent();
 
 #ifdef DEBUG
   if (gDisableResizeOpt) {
     tryAndSkipLines = false;
   }
   if (gNoisyReflow) {
     if (!tryAndSkipLines) {
       IndentBy(stdout, gNoiseIndent);
@@ -2711,17 +2711,17 @@ nsBlockFrame::AttributeChanged(int32_t  
     // XXX Not sure if this is necessary anymore
     if (RenumberLists(presContext)) {
       presContext->PresShell()->
         FrameNeedsReflow(this, nsIPresShell::eStyleChange,
                          NS_FRAME_HAS_DIRTY_CHILDREN);
     }
   }
   else if (nsGkAtoms::value == aAttribute) {
-    const nsStyleDisplay* styleDisplay = GetStyleDisplay();
+    const nsStyleDisplay* styleDisplay = StyleDisplay();
     if (NS_STYLE_DISPLAY_LIST_ITEM == styleDisplay->mDisplay) {
       // Search for the closest ancestor that's a block frame. We
       // make the assumption that all related list items share a
       // common block parent.
       // XXXldb I think that's a bad assumption.
       nsBlockFrame* blockParent = nsLayoutUtils::FindNearestBlockAncestor(this);
 
       // Tell the enclosing block frame to renumber list items within
@@ -2762,24 +2762,24 @@ IsNonAutoNonZeroHeight(const nsStyleCoor
 nsBlockFrame::IsSelfEmpty()
 {
   // Blocks which are margin-roots (including inline-blocks) cannot be treated
   // as empty for margin-collapsing and other purposes. They're more like
   // replaced elements.
   if (GetStateBits() & NS_BLOCK_MARGIN_ROOT)
     return false;
 
-  const nsStylePosition* position = GetStylePosition();
+  const nsStylePosition* position = StylePosition();
 
   if (IsNonAutoNonZeroHeight(position->mMinHeight) ||
       IsNonAutoNonZeroHeight(position->mHeight))
     return false;
 
-  const nsStyleBorder* border = GetStyleBorder();
-  const nsStylePadding* padding = GetStylePadding();
+  const nsStyleBorder* border = StyleBorder();
+  const nsStylePadding* padding = StylePadding();
   if (border->GetComputedBorderWidth(NS_SIDE_TOP) != 0 ||
       border->GetComputedBorderWidth(NS_SIDE_BOTTOM) != 0 ||
       !nsLayoutUtils::IsPaddingZero(padding->mPadding.GetTop()) ||
       !nsLayoutUtils::IsPaddingZero(padding->mPadding.GetBottom())) {
     return false;
   }
 
   if (HasOutsideBullet() && !BulletIsEmpty()) {
@@ -2878,17 +2878,17 @@ nsBlockFrame::ReflowBlockFrame(nsBlockRe
 
   nsIFrame* frame = aLine->mFirstChild;
   if (!frame) {
     NS_ASSERTION(false, "program error - unexpected empty line"); 
     return NS_ERROR_NULL_POINTER; 
   }
 
   // Prepare the block reflow engine
-  const nsStyleDisplay* display = frame->GetStyleDisplay();
+  const nsStyleDisplay* display = frame->StyleDisplay();
   nsBlockReflowContext brc(aState.mPresContext, aState.mReflowState);
 
   uint8_t breakType = display->mBreakType;
   if (NS_STYLE_CLEAR_NONE != aState.mFloatBreakType) {
     breakType = nsLayoutUtils::CombineBreakType(breakType,
                                                 aState.mFloatBreakType);
     aState.mFloatBreakType = NS_STYLE_CLEAR_NONE;
   }
@@ -3494,22 +3494,22 @@ nsBlockFrame::DoReflowInlineFrames(nsBlo
   // because it might get disabled there
   aLine->EnableResizeReflowOptimization();
 
   // For unicode-bidi: plaintext, we need to get the direction of the line from
   // the resolved paragraph level of the first frame on the line, not the block
   // frame, because the block frame could be split by hard line breaks into
   // multiple paragraphs with different base direction
   uint8_t direction;
-  if (GetStyleTextReset()->mUnicodeBidi & NS_STYLE_UNICODE_BIDI_PLAINTEXT) {
+  if (StyleTextReset()->mUnicodeBidi & NS_STYLE_UNICODE_BIDI_PLAINTEXT) {
     FramePropertyTable *propTable = aState.mPresContext->PropertyTable();
     direction =  NS_PTR_TO_INT32(propTable->Get(aLine->mFirstChild,
                                                 BaseLevelProperty())) & 1;
   } else {
-    direction = GetStyleVisibility()->mDirection;
+    direction = StyleVisibility()->mDirection;
   }
 
   aLineLayout.BeginLineReflow(x, aState.mY,
                               availWidth, availHeight,
                               aFloatAvailableSpace.mHasFloats,
                               false, /*XXX isTopOfPage*/
                               direction);
 
@@ -3925,20 +3925,20 @@ nsBlockFrame::SplitFloat(nsBlockReflowSt
     NS_ENSURE_SUCCESS(rv, rv);
   }
   if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aFloatStatus))
     aFloat->GetNextInFlow()->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
 
   // The containing block is now overflow-incomplete.
   NS_FRAME_SET_OVERFLOW_INCOMPLETE(aState.mReflowStatus);
 
-  if (aFloat->GetStyleDisplay()->mFloats == NS_STYLE_FLOAT_LEFT) {
+  if (aFloat->StyleDisplay()->mFloats == NS_STYLE_FLOAT_LEFT) {
     aState.mFloatManager->SetSplitLeftFloatAcrossBreak();
   } else {
-    NS_ABORT_IF_FALSE(aFloat->GetStyleDisplay()->mFloats ==
+    NS_ABORT_IF_FALSE(aFloat->StyleDisplay()->mFloats ==
                         NS_STYLE_FLOAT_RIGHT, "unexpected float side");
     aState.mFloatManager->SetSplitRightFloatAcrossBreak();
   }
 
   aState.AppendPushedFloat(nextInFlow);
   return NS_OK;
 }
 
@@ -4159,17 +4159,17 @@ nsBlockFrame::PlaceLine(nsBlockReflowSta
       lastHeight = 0;
     }
   }
 #endif
 
   // Only block frames horizontally align their children because
   // inline frames "shrink-wrap" around their children (therefore
   // there is no extra horizontal space).
-  const nsStyleText* styleText = GetStyleText();
+  const nsStyleText* styleText = StyleText();
 
   /**
    * text-align-last defaults to the same value as text-align when
    * text-align-last is set to auto (except when text-align is set to justify),
    * so in that case we don't need to set isLastLine.
    *
    * In other words, isLastLine really means isLastLineAndWeCare.
    */
@@ -4183,17 +4183,17 @@ nsBlockFrame::PlaceLine(nsBlockReflowSta
   // XXX: not only bidi: right alignment can be broken after
   // RelativePositionFrames!!!
   // XXXldb Is something here considering relatively positioned frames at
   // other than their original positions?
 #ifdef IBMBIDI
   // XXXldb Why don't we do this earlier?
   if (aState.mPresContext->BidiEnabled()) {
     if (!aState.mPresContext->IsVisualMode() ||
-        GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
+        StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
       nsBidiPresUtils::ReorderFrames(aLine->mFirstChild, aLine->GetChildCount());
     } // not visual mode
   } // bidi enabled
 #endif // IBMBIDI
 
   // From here on, pfd->mBounds rectangles are incorrect because bidi
   // might have moved frames around!
   nsOverflowAreas overflowAreas;
@@ -4837,17 +4837,17 @@ nsBlockFrame::InsertFrames(ChildListID a
 static bool
 ShouldPutNextSiblingOnNewLine(nsIFrame* aLastFrame)
 {
   nsIAtom* type = aLastFrame->GetType();
   if (type == nsGkAtoms::brFrame)
     return true;
   if (type == nsGkAtoms::textFrame)
     return aLastFrame->HasTerminalNewline() &&
-           aLastFrame->GetStyleText()->NewlineIsSignificant();
+           aLastFrame->StyleText()->NewlineIsSignificant();
   return false;
 }
 
 nsresult
 nsBlockFrame::AddFrames(nsFrameList& aFrameList, nsIFrame* aPrevSibling)
 {
   // Clear our line cursor, since our lines may change.
   ClearLineCursor();
@@ -5744,17 +5744,17 @@ nsBlockFrame::DeleteNextInFlowChild(nsPr
 nsRect
 nsBlockFrame::AdjustFloatAvailableSpace(nsBlockReflowState& aState,
                                         const nsRect& aFloatAvailableSpace,
                                         nsIFrame* aFloatFrame)
 {
   // Compute the available width. By default, assume the width of the
   // containing block.
   nscoord availWidth;
-  const nsStyleDisplay* floatDisplay = aFloatFrame->GetStyleDisplay();
+  const nsStyleDisplay* floatDisplay = aFloatFrame->StyleDisplay();
 
   if (NS_STYLE_DISPLAY_TABLE != floatDisplay->mDisplay ||
       eCompatibility_NavQuirks != aState.mPresContext->CompatibilityMode() ) {
     availWidth = aState.mContentArea.width;
   }
   else {
     // This quirk matches the one in nsBlockReflowState::FlowAndPlaceFloat
     // give tables only the available space
@@ -6552,20 +6552,20 @@ nsBlockFrame::SetInitialChildList(ChildL
     while (1) {
       nsIFrame* parent = possibleListItem->GetParent();
       if (parent->GetContent() != GetContent()) {
         break;
       }
       possibleListItem = parent;
     }
     if (NS_STYLE_DISPLAY_LIST_ITEM ==
-          possibleListItem->GetStyleDisplay()->mDisplay &&
+          possibleListItem->StyleDisplay()->mDisplay &&
         !GetPrevInFlow()) {
       // Resolve style for the bullet frame
-      const nsStyleList* styleList = GetStyleList();
+      const nsStyleList* styleList = StyleList();
       nsCSSPseudoElements::Type pseudoType;
       switch (styleList->mListStyleType) {
         case NS_STYLE_LIST_STYLE_DISC:
         case NS_STYLE_LIST_STYLE_CIRCLE:
         case NS_STYLE_LIST_STYLE_SQUARE:
           pseudoType = nsCSSPseudoElements::ePseudo_mozListBullet;
           break;
         default:
@@ -6606,30 +6606,30 @@ nsBlockFrame::SetInitialChildList(ChildL
   }
 
   return NS_OK;
 }
 
 bool
 nsBlockFrame::BulletIsEmpty() const
 {
-  NS_ASSERTION(mContent->GetPrimaryFrame()->GetStyleDisplay()->mDisplay ==
+  NS_ASSERTION(mContent->GetPrimaryFrame()->StyleDisplay()->mDisplay ==
                  NS_STYLE_DISPLAY_LIST_ITEM && HasOutsideBullet(),
                "should only care when we have an outside bullet");
-  const nsStyleList* list = GetStyleList();
+  const nsStyleList* list = StyleList();
   return list->mListStyleType == NS_STYLE_LIST_STYLE_NONE &&
          !list->GetListStyleImage();
 }
 
 void
 nsBlockFrame::GetBulletText(nsAString& aText) const
 {
   aText.Truncate();
 
-  const nsStyleList* myList = GetStyleList();
+  const nsStyleList* myList = StyleList();
   if (myList->GetListStyleImage() ||
       myList->mListStyleType == NS_STYLE_LIST_STYLE_DISC) {
     aText.Assign(kDiscCharacter);
   }
   else if (myList->mListStyleType == NS_STYLE_LIST_STYLE_CIRCLE) {
     aText.Assign(kCircleCharacter);
   }
   else if (myList->mListStyleType == NS_STYLE_LIST_STYLE_SQUARE) {
@@ -6751,17 +6751,17 @@ nsBlockFrame::RenumberListsFor(nsPresCon
   NS_PRECONDITION(aPresContext && aKid && aOrdinal, "null params are immoral!");
 
   // add in a sanity check for absurdly deep frame trees.  See bug 42138
   if (MAX_DEPTH_FOR_LIST_RENUMBERING < aDepth)
     return false;
 
   // if the frame is a placeholder, then get the out of flow frame
   nsIFrame* kid = nsPlaceholderFrame::GetRealFrameFor(aKid);
-  const nsStyleDisplay* display = kid->GetStyleDisplay();
+  const nsStyleDisplay* display = kid->StyleDisplay();
 
   // drill down through any wrappers to the real frame
   kid = kid->GetContentInsertionFrame();
 
   // possible there is no content insertion frame
   if (!kid)
     return false;
 
diff --git a/layout/generic/nsBlockReflowContext.cpp b/layout/generic/nsBlockReflowContext.cpp
--- a/layout/generic/nsBlockReflowContext.cpp
+++ b/layout/generic/nsBlockReflowContext.cpp
@@ -153,17 +153,17 @@ nsBlockReflowContext::ComputeCollapsedTo
           {
             nsSize availSpace(outerReflowState->ComputedWidth(),
                               outerReflowState->ComputedHeight());
             nsHTMLReflowState innerReflowState(prescontext,
                                                *outerReflowState, kid,
                                                availSpace);
             // Record that we're being optimistic by assuming the kid
             // has no clearance
-            if (kid->GetStyleDisplay()->mBreakType != NS_STYLE_CLEAR_NONE) {
+            if (kid->StyleDisplay()->mBreakType != NS_STYLE_CLEAR_NONE) {
               *aMayNeedRetry = true;
             }
             if (ComputeCollapsedTopMargin(innerReflowState, aMargin, aClearanceFrame, aMayNeedRetry, &isEmpty)) {
               line->MarkDirty();
               dirtiedLine = true;
             }
             if (isEmpty)
               aMargin->Include(innerReflowState.mComputedMargin.bottom);
@@ -395,17 +395,17 @@ nsBlockReflowContext::PlaceBlock(const n
       return false;
     }
   }
 
   aInFlowBounds = nsRect(x, y - backupContainingBlockAdvance,
                          mMetrics.width, mMetrics.height);
   
   // Apply CSS relative positioning
-  const nsStyleDisplay* styleDisp = mFrame->GetStyleDisplay();
+  const nsStyleDisplay* styleDisp = mFrame->StyleDisplay();
   if (NS_STYLE_POSITION_RELATIVE == styleDisp->mPosition) {
     x += aReflowState.mComputedOffsets.left;
     y += aReflowState.mComputedOffsets.top;
   }
   
   // Now place the frame and complete the reflow process
   nsContainerFrame::FinishReflowChild(mFrame, mPresContext, &aReflowState, mMetrics, x, y, 0);
 
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -188,17 +188,17 @@ nsBlockReflowState::ComputeBlockAvailSpa
   // rather than just using MIN_WIDTH.
   NS_ASSERTION(nsBlockFrame::BlockCanIntersectFloats(aFrame) == 
                  !aBlockAvoidsFloats,
                "unexpected replaced width");
   if (!aBlockAvoidsFloats) {
     if (aFloatAvailableSpace.mHasFloats) {
       // Use the float-edge property to determine how the child block
       // will interact with the float.
-      const nsStyleBorder* borderStyle = aFrame->GetStyleBorder();
+      const nsStyleBorder* borderStyle = aFrame->StyleBorder();
       switch (borderStyle->mFloatEdge) {
         default:
         case NS_STYLE_FLOAT_EDGE_CONTENT:  // content and only content does runaround of floats
           // The child block will flow around the float. Therefore
           // give it all of the available space.
           aResult.x = mContentArea.x;
           aResult.width = mContentArea.width;
           break;
@@ -584,17 +584,17 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
   // necessary because any adjustments to mY during the float
   // placement are for the float only, not for any non-floating
   // content.
   AutoRestore<nscoord> restoreY(mY);
   // FIXME: Should give AutoRestore a getter for the value to avoid this.
   const nscoord saveY = mY;
 
   // Grab the float's display information
-  const nsStyleDisplay* floatDisplay = aFloat->GetStyleDisplay();
+  const nsStyleDisplay* floatDisplay = aFloat->StyleDisplay();
 
   // The float's old region, so we can propagate damage.
   nsRect oldRegion = nsFloatManager::GetRegionFor(aFloat);
 
   // Enforce CSS2 9.5.1 rule [2], i.e., make sure that a float isn't
   // ``above'' another float that preceded it in the flow.
   mY = std::max(mFloatManager->GetLowestFloatTop(), mY);
 
@@ -784,17 +784,17 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
     return false;
   }
 
   // We can't use aFloat->ShouldAvoidBreakInside(mReflowState) here since
   // its mIsTopOfPage may be true even though the float isn't at the
   // top when floatY > 0.
   if (mContentArea.height != NS_UNCONSTRAINEDSIZE &&
       !mustPlaceFloat && (!mReflowState.mFlags.mIsTopOfPage || floatY > 0) &&
-      NS_STYLE_PAGE_BREAK_AVOID == aFloat->GetStyleDisplay()->mBreakInside &&
+      NS_STYLE_PAGE_BREAK_AVOID == aFloat->StyleDisplay()->mBreakInside &&
       (!NS_FRAME_IS_FULLY_COMPLETE(reflowStatus) ||
        aFloat->GetSize().height + floatMargin.TopBottom() >
          mContentArea.YMost() - floatY) &&
       !aFloat->GetPrevInFlow()) {
     PushFloatPastBreak(aFloat);
     return false;
   }
 
@@ -876,20 +876,20 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
 void
 nsBlockReflowState::PushFloatPastBreak(nsIFrame *aFloat)
 {
   // This ensures that we:
   //  * don't try to place later but smaller floats (which CSS says
   //    must have their tops below the top of this float)
   //  * don't waste much time trying to reflow this float again until
   //    after the break
-  if (aFloat->GetStyleDisplay()->mFloats == NS_STYLE_FLOAT_LEFT) {
+  if (aFloat->StyleDisplay()->mFloats == NS_STYLE_FLOAT_LEFT) {
     mFloatManager->SetPushedLeftFloatPastBreak();
   } else {
-    NS_ABORT_IF_FALSE(aFloat->GetStyleDisplay()->mFloats ==
+    NS_ABORT_IF_FALSE(aFloat->StyleDisplay()->mFloats ==
                         NS_STYLE_FLOAT_RIGHT,
                       "unexpected float value");
     mFloatManager->SetPushedRightFloatPastBreak();
   }
 
   // Put the float on the pushed floats list, even though it
   // isn't actually a continuation.
   DebugOnly<nsresult> rv = mBlock->StealFrame(mPresContext, aFloat);
diff --git a/layout/generic/nsBulletFrame.cpp b/layout/generic/nsBulletFrame.cpp
--- a/layout/generic/nsBulletFrame.cpp
+++ b/layout/generic/nsBulletFrame.cpp
@@ -83,25 +83,25 @@ bool
 nsBulletFrame::IsEmpty()
 {
   return IsSelfEmpty();
 }
 
 bool
 nsBulletFrame::IsSelfEmpty() 
 {
-  return GetStyleList()->mListStyleType == NS_STYLE_LIST_STYLE_NONE;
+  return StyleList()->mListStyleType == NS_STYLE_LIST_STYLE_NONE;
 }
 
 /* virtual */ void
 nsBulletFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
   nsFrame::DidSetStyleContext(aOldStyleContext);
 
-  imgRequestProxy *newRequest = GetStyleList()->GetListStyleImage();
+  imgRequestProxy *newRequest = StyleList()->GetListStyleImage();
 
   if (newRequest) {
 
     if (!mListener) {
       mListener = new nsBulletListener();
       mListener->SetFrame(this);
     }
 
@@ -152,17 +152,17 @@ nsBulletFrame::DidSetStyleContext(nsStyl
   if (aOldStyleContext) {
     nsAccessibilityService* accService = nsIPresShell::AccService();
     if (accService) {
       const nsStyleList* oldStyleList = aOldStyleContext->PeekStyleList();
       if (oldStyleList) {
         bool hadBullet = oldStyleList->GetListStyleImage() ||
             oldStyleList->mListStyleType != NS_STYLE_LIST_STYLE_NONE;
 
-        const nsStyleList* newStyleList = GetStyleList();
+        const nsStyleList* newStyleList = StyleList();
         bool hasBullet = newStyleList->GetListStyleImage() ||
             newStyleList->mListStyleType != NS_STYLE_LIST_STYLE_NONE;
 
         if (hadBullet != hasBullet) {
           accService->UpdateListBullet(PresContext()->GetPresShell(), mContent,
                                        hasBullet);
         }
       }
@@ -257,17 +257,17 @@ nsBulletFrame::BuildDisplayList(nsDispla
   return aLists.Content()->AppendNewToTop(
       new (aBuilder) nsDisplayBullet(aBuilder, this));
 }
 
 void
 nsBulletFrame::PaintBullet(nsRenderingContext& aRenderingContext, nsPoint aPt,
                            const nsRect& aDirtyRect)
 {
-  const nsStyleList* myList = GetStyleList();
+  const nsStyleList* myList = StyleList();
   uint8_t listStyleType = myList->mListStyleType;
 
   if (myList->GetListStyleImage() && mImageRequest) {
     uint32_t status;
     mImageRequest->GetImageStatus(&status);
     if (status & imgIRequest::STATUS_LOAD_COMPLETE &&
         !(status & imgIRequest::STATUS_ERROR)) {
       nsCOMPtr<imgIContainer> imageCon;
@@ -1263,17 +1263,17 @@ nsBulletFrame::AppendCounterText(int32_t
   }
   return success;
 }
 
 bool
 nsBulletFrame::GetListItemText(const nsStyleList& aListStyle,
                                nsString& result)
 {
-  const nsStyleVisibility* vis = GetStyleVisibility();
+  const nsStyleVisibility* vis = StyleVisibility();
 
   NS_ASSERTION(aListStyle.mListStyleType != NS_STYLE_LIST_STYLE_NONE &&
                aListStyle.mListStyleType != NS_STYLE_LIST_STYLE_DISC &&
                aListStyle.mListStyleType != NS_STYLE_LIST_STYLE_CIRCLE &&
                aListStyle.mListStyleType != NS_STYLE_LIST_STYLE_SQUARE,
                "we should be using specialized code for these types");
   bool success =
     AppendCounterText(aListStyle.mListStyleType, mOrdinal, result);
@@ -1301,17 +1301,17 @@ void
 nsBulletFrame::GetDesiredSize(nsPresContext*  aCX,
                               nsRenderingContext *aRenderingContext,
                               nsHTMLReflowMetrics& aMetrics,
                               float aFontSizeInflation)
 {
   // Reset our padding.  If we need it, we'll set it below.
   mPadding.SizeTo(0, 0, 0, 0);
   
-  const nsStyleList* myList = GetStyleList();
+  const nsStyleList* myList = StyleList();
   nscoord ascent;
 
   RemoveStateBits(BULLET_FRAME_IMAGE_LOADING);
 
   if (myList->GetListStyleImage() && mImageRequest) {
     uint32_t status;
     mImageRequest->GetImageStatus(&status);
     if (status & imgIRequest::STATUS_SIZE_AVAILABLE &&
@@ -1598,17 +1598,17 @@ nsBulletFrame::GetBaseline() const
 {
   nscoord ascent = 0, bottomPadding;
   if (GetStateBits() & BULLET_FRAME_IMAGE_LOADING) {
     ascent = GetRect().height;
   } else {
     nsRefPtr<nsFontMetrics> fm;
     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm),
                                           GetFontSizeInflation());
-    const nsStyleList* myList = GetStyleList();
+    const nsStyleList* myList = StyleList();
     switch (myList->mListStyleType) {
       case NS_STYLE_LIST_STYLE_NONE:
         break;
 
       case NS_STYLE_LIST_STYLE_DISC:
       case NS_STYLE_LIST_STYLE_CIRCLE:
       case NS_STYLE_LIST_STYLE_SQUARE:
         ascent = fm->MaxAscent();
diff --git a/layout/generic/nsCanvasFrame.cpp b/layout/generic/nsCanvasFrame.cpp
--- a/layout/generic/nsCanvasFrame.cpp
+++ b/layout/generic/nsCanvasFrame.cpp
@@ -289,29 +289,29 @@ nsCanvasFrame::BuildDisplayList(nsDispla
 {
   nsresult rv;
 
   if (GetPrevInFlow()) {
     DisplayOverflowContainers(aBuilder, aDirtyRect, aLists);
   }
 
   // Force a background to be shown. We may have a background propagated to us,
-  // in which case GetStyleBackground wouldn't have the right background
+  // in which case StyleBackground wouldn't have the right background
   // and the code in nsFrame::DisplayBorderBackgroundOutline might not give us
   // a background.
   // We don't have any border or outline, and our background draws over
   // the overflow area, so just add nsDisplayCanvasBackground instead of
   // calling DisplayBorderBackgroundOutline.
   if (IsVisibleForPainting(aBuilder)) {
     nsStyleContext* bgSC;
     const nsStyleBackground* bg = nullptr;
     bool isThemed = IsThemed();
     if (!isThemed &&
         nsCSSRendering::FindBackground(PresContext(), this, &bgSC)) {
-      bg = bgSC->GetStyleBackground();
+      bg = bgSC->StyleBackground();
     }
     aLists.BorderBackground()->AppendNewToTop(
         new (aBuilder) nsDisplayCanvasBackgroundColor(aBuilder, this));
   
     if (isThemed) {
       return aLists.BorderBackground()->AppendNewToTop(
         new (aBuilder) nsDisplayCanvasBackgroundImage(aBuilder, this, 0, isThemed, nullptr));
     }
@@ -356,17 +356,17 @@ nsCanvasFrame::BuildDisplayList(nsDispla
   }
   printf("%p - Focus: %s   c: %p  DoPaint:%s\n", docShell.get(), hasFocus?"Y":"N", 
          focusContent.get(), mDoPaintFocus?"Y":"N");
 #endif
 
   if (!mDoPaintFocus)
     return NS_OK;
   // Only paint the focus if we're visible
-  if (!GetStyleVisibility()->IsVisible())
+  if (!StyleVisibility()->IsVisible())
     return NS_OK;
   
   return aLists.Outlines()->AppendNewToTop(new (aBuilder)
       nsDisplayCanvasFocus(aBuilder, this));
 }
 
 void
 nsCanvasFrame::PaintFocus(nsRenderingContext& aRenderingContext, nsPoint aPt)
@@ -379,17 +379,17 @@ nsCanvasFrame::PaintFocus(nsRenderingCon
     focusRect.width = portRect.width;
     focusRect.height = portRect.height;
     focusRect.MoveBy(scrollableFrame->GetScrollPosition());
   }
 
  // XXX use the root frame foreground color, but should we find BODY frame
  // for HTML documents?
   nsIFrame* root = mFrames.FirstChild();
-  const nsStyleColor* color = root ? root->GetStyleColor() : GetStyleColor();
+  const nsStyleColor* color = root ? root->StyleColor() : StyleColor();
   if (!color) {
     NS_ERROR("current color cannot be found");
     return;
   }
 
   nsCSSRendering::PaintFocus(PresContext(), aRenderingContext,
                              focusRect, color->mColor);
 }
@@ -476,17 +476,17 @@ nsCanvasFrame::Reflow(nsPresContext*    
       // Tell our kid it's being vertically resized too.  Bit of a
       // hack for framesets.
       kidReflowState.mFlags.mVResize = true;
     }
 
     nsPoint kidPt(kidReflowState.mComputedMargin.left,
                   kidReflowState.mComputedMargin.top);
     // Apply CSS relative positioning
-    const nsStyleDisplay* styleDisp = kidFrame->GetStyleDisplay();
+    const nsStyleDisplay* styleDisp = kidFrame->StyleDisplay();
     if (NS_STYLE_POSITION_RELATIVE == styleDisp->mPosition) {
       kidPt += nsPoint(kidReflowState.mComputedOffsets.left,
                        kidReflowState.mComputedOffsets.top);
     }
 
     // Reflow the frame
     ReflowChild(kidFrame, aPresContext, kidDesiredSize, kidReflowState,
                 kidPt.x, kidPt.y, 0, aStatus);
diff --git a/layout/generic/nsColumnSetFrame.cpp b/layout/generic/nsColumnSetFrame.cpp
--- a/layout/generic/nsColumnSetFrame.cpp
+++ b/layout/generic/nsColumnSetFrame.cpp
@@ -192,18 +192,18 @@ nsColumnSetFrame::PaintColumnRule(nsRend
   nsIFrame* child = mFrames.FirstChild();
   if (!child)
     return;  // no columns
 
   nsIFrame* nextSibling = child->GetNextSibling();
   if (!nextSibling)
     return;  // 1 column only - this means no gap to draw on
 
-  bool isRTL = GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
-  const nsStyleColumn* colStyle = GetStyleColumn();
+  bool isRTL = StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
+  const nsStyleColumn* colStyle = StyleColumn();
 
   uint8_t ruleStyle;
   // Per spec, inset => ridge and outset => groove
   if (colStyle->mColumnRuleStyle == NS_STYLE_BORDER_STYLE_INSET)
     ruleStyle = NS_STYLE_BORDER_STYLE_RIDGE;
   else if (colStyle->mColumnRuleStyle == NS_STYLE_BORDER_STYLE_OUTSET)
     ruleStyle = NS_STYLE_BORDER_STYLE_GROOVE;
   else
@@ -291,31 +291,31 @@ GetAvailableContentHeight(const nsHTMLRe
   return std::max(0, aReflowState.availableHeight - borderPaddingHeight);
 }
 
 static nscoord
 GetColumnGap(nsColumnSetFrame*    aFrame,
              const nsStyleColumn* aColStyle)
 {
   if (eStyleUnit_Normal == aColStyle->mColumnGap.GetUnit())
-    return aFrame->GetStyleFont()->mFont.size;
+    return aFrame->StyleFont()->mFont.size;
   if (eStyleUnit_Coord == aColStyle->mColumnGap.GetUnit()) {
     nscoord colGap = aColStyle->mColumnGap.GetCoordValue();
     NS_ASSERTION(colGap >= 0, "negative column gap");
     return colGap;
   }
 
   NS_NOTREACHED("Unknown gap type");
   return 0;
 }
 
 nsColumnSetFrame::ReflowConfig
 nsColumnSetFrame::ChooseColumnStrategy(const nsHTMLReflowState& aReflowState)
 {
-  const nsStyleColumn* colStyle = GetStyleColumn();
+  const nsStyleColumn* colStyle = StyleColumn();
   nscoord availContentWidth = GetAvailableContentWidth(aReflowState);
   if (aReflowState.ComputedWidth() != NS_INTRINSICSIZE) {
     availContentWidth = aReflowState.ComputedWidth();
   }
   nscoord colHeight = GetAvailableContentHeight(aReflowState);
   if (aReflowState.ComputedHeight() != NS_INTRINSICSIZE) {
     colHeight = aReflowState.ComputedHeight();
   } else if (aReflowState.mComputedMaxHeight != NS_INTRINSICSIZE) {
@@ -435,17 +435,17 @@ static void MoveChildTo(nsIFrame* aParen
 
 nscoord
 nsColumnSetFrame::GetMinWidth(nsRenderingContext *aRenderingContext) {
   nscoord width = 0;
   DISPLAY_MIN_WIDTH(this, width);
   if (mFrames.FirstChild()) {
     width = mFrames.FirstChild()->GetMinWidth(aRenderingContext);
   }
-  const nsStyleColumn* colStyle = GetStyleColumn();
+  const nsStyleColumn* colStyle = StyleColumn();
   nscoord colWidth;
   if (colStyle->mColumnWidth.GetUnit() == eStyleUnit_Coord) {
     colWidth = colStyle->mColumnWidth.GetCoordValue();
     // As available width reduces to zero, we reduce our number of columns
     // to one, and don't enforce the column width, so just return the min
     // of the child's min-width with any specified column width.
     width = std::min(width, colWidth);
   } else {
@@ -467,17 +467,17 @@ nsColumnSetFrame::GetMinWidth(nsRenderin
 nscoord
 nsColumnSetFrame::GetPrefWidth(nsRenderingContext *aRenderingContext) {
   // Our preferred width is our desired column width, if specified, otherwise
   // the child's preferred width, times the number of columns, plus the width
   // of any required column gaps
   // XXX what about forced column breaks here?
   nscoord result = 0;
   DISPLAY_PREF_WIDTH(this, result);
-  const nsStyleColumn* colStyle = GetStyleColumn();
+  const nsStyleColumn* colStyle = StyleColumn();
   nscoord colGap = GetColumnGap(this, colStyle);
 
   nscoord colWidth;
   if (colStyle->mColumnWidth.GetUnit() == eStyleUnit_Coord) {
     colWidth = colStyle->mColumnWidth.GetCoordValue();
   } else if (mFrames.FirstChild()) {
     colWidth = mFrames.FirstChild()->GetPrefWidth(aRenderingContext);
   } else {
@@ -503,17 +503,17 @@ nsColumnSetFrame::ReflowChildren(nsHTMLR
                                  nsReflowStatus&          aStatus,
                                  const ReflowConfig&      aConfig,
                                  bool                     aUnboundedLastColumn,
                                  nsCollapsingMargin*      aBottomMarginCarriedOut,
                                  ColumnBalanceData&       aColData)
 {
   aColData.Reset();
   bool allFit = true;
-  bool RTL = GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
+  bool RTL = StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
   bool shrinkingHeightOnly = !NS_SUBTREE_DIRTY(this) &&
     mLastBalanceHeight > aConfig.mColMaxHeight;
   
 #ifdef DEBUG_roc
   printf("*** Doing column reflow pass: mLastBalanceHeight=%d, mColMaxHeight=%d, RTL=%d\n, mBalanceColCount=%d, mColWidth=%d, mColGap=%d\n",
          mLastBalanceHeight, aConfig.mColMaxHeight, RTL, aConfig.mBalanceColCount,
          aConfig.mColWidth, aConfig.mColGap);
 #endif
diff --git a/layout/generic/nsContainerFrame.cpp b/layout/generic/nsContainerFrame.cpp
--- a/layout/generic/nsContainerFrame.cpp
+++ b/layout/generic/nsContainerFrame.cpp
@@ -702,17 +702,17 @@ nsContainerFrame::SyncWindowProperties(n
 
   nsIFrame *rootFrame = aPresContext->PresShell()->FrameConstructor()->GetRootElementStyleFrame();
   if (!rootFrame)
     return;
 
   nsTransparencyMode mode = nsLayoutUtils::GetFrameTransparency(aFrame, rootFrame);
   nsIWidget* viewWidget = aView->GetWidget();
   viewWidget->SetTransparencyMode(mode);
-  windowWidget->SetWindowShadowStyle(rootFrame->GetStyleUIReset()->mWindowShadow);
+  windowWidget->SetWindowShadowStyle(rootFrame->StyleUIReset()->mWindowShadow);
 
   if (!aRC)
     return;
   
   nsBoxLayoutState aState(aPresContext, aRC);
   nsSize minSize = rootFrame->GetMinSize(aState);
   nsSize maxSize = rootFrame->GetMaxSize(aState);
 
@@ -792,32 +792,32 @@ nsContainerFrame::SyncFrameViewPropertie
     aStyleContext = aFrame->StyleContext();
   }
 
   // Make sure visibility is correct. This only affects nsSubdocumentFrame.
   if (0 == (aFlags & NS_FRAME_NO_VISIBILITY) &&
       !aFrame->SupportsVisibilityHidden()) {
     // See if the view should be hidden or visible
     vm->SetViewVisibility(aView,
-        aStyleContext->GetStyleVisibility()->IsVisible()
+        aStyleContext->StyleVisibility()->IsVisible()
             ? nsViewVisibility_kShow : nsViewVisibility_kHide);
   }
 
   // See if the frame is being relatively positioned or absolutely
   // positioned
   bool isPositioned = aFrame->IsPositioned();
 
   int32_t zIndex = 0;
   bool    autoZIndex = false;
 
   if (!isPositioned) {
     autoZIndex = true;
   } else {
     // Make sure z-index is correct
-    const nsStylePosition* position = aStyleContext->GetStylePosition();
+    const nsStylePosition* position = aStyleContext->StylePosition();
 
     if (position->mZIndex.GetUnit() == eStyleUnit_Integer) {
       zIndex = position->mZIndex.GetIntValue();
     } else if (position->mZIndex.GetUnit() == eStyleUnit_Auto) {
       autoZIndex = true;
     }
   }
 
@@ -839,27 +839,27 @@ nsContainerFrame::DoInlineIntrinsicWidth
 {
   if (GetPrevInFlow())
     return; // Already added.
 
   NS_PRECONDITION(aType == nsLayoutUtils::MIN_WIDTH ||
                   aType == nsLayoutUtils::PREF_WIDTH, "bad type");
 
   mozilla::css::Side startSide, endSide;
-  if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR) {
+  if (StyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR) {
     startSide = NS_SIDE_LEFT;
     endSide = NS_SIDE_RIGHT;
   } else {
     startSide = NS_SIDE_RIGHT;
     endSide = NS_SIDE_LEFT;
   }
 
-  const nsStylePadding *stylePadding = GetStylePadding();
-  const nsStyleBorder *styleBorder = GetStyleBorder();
-  const nsStyleMargin *styleMargin = GetStyleMargin();
+  const nsStylePadding *stylePadding = StylePadding();
+  const nsStyleBorder *styleBorder = StyleBorder();
+  const nsStyleMargin *styleMargin = StyleMargin();
 
   // This goes at the beginning no matter how things are broken and how
   // messy the bidi situations are, since per CSS2.1 section 8.6
   // (implemented in bug 328168), the startSide border is always on the
   // first line.
   // This frame is a first-in-flow, but it might have a previous bidi
   // continuation, in which case that continuation should handle the startSide
   // border.
@@ -921,17 +921,17 @@ nsContainerFrame::ComputeAutoSize(nsRend
                                   nsSize aPadding, bool aShrinkWrap)
 {
   nsSize result(0xdeadbeef, NS_UNCONSTRAINEDSIZE);
   nscoord availBased = aAvailableWidth - aMargin.width - aBorder.width -
                        aPadding.width;
   // replaced elements always shrink-wrap
   if (aShrinkWrap || IsFrameOfType(eReplaced)) {
     // don't bother setting it if the result won't be used
-    if (GetStylePosition()->mWidth.GetUnit() == eStyleUnit_Auto) {
+    if (StylePosition()->mWidth.GetUnit() == eStyleUnit_Auto) {
       result.width = ShrinkWidthToFit(aRenderingContext, availBased);
     }
   } else {
     result.width = availBased;
   }
   return result;
 }
 
diff --git a/layout/generic/nsFirstLetterFrame.cpp b/layout/generic/nsFirstLetterFrame.cpp
--- a/layout/generic/nsFirstLetterFrame.cpp
+++ b/layout/generic/nsFirstLetterFrame.cpp
@@ -189,22 +189,22 @@ nsFirstLetterFrame::Reflow(nsPresContext
     nsLineLayout ll(aPresContext, nullptr, &aReflowState, nullptr);
 
     // For unicode-bidi: plaintext, we need to get the direction of the line
     // from the resolved paragraph level of the child, not the block frame,
     // because the block frame could be split by hard line breaks into
     // multiple paragraphs with different base direction
     uint8_t direction;
     nsIFrame* containerFrame = ll.GetLineContainerFrame();
-    if (containerFrame->GetStyleTextReset()->mUnicodeBidi &
+    if (containerFrame->StyleTextReset()->mUnicodeBidi &
         NS_STYLE_UNICODE_BIDI_PLAINTEXT) {
       FramePropertyTable *propTable = aPresContext->PropertyTable();
       direction = NS_PTR_TO_INT32(propTable->Get(kid, BaseLevelProperty())) & 1;
     } else {
-      direction = containerFrame->GetStyleVisibility()->mDirection;
+      direction = containerFrame->StyleVisibility()->mDirection;
     }
     ll.BeginLineReflow(bp.left, bp.top, availSize.width, NS_UNCONSTRAINEDSIZE,
                        false, true, direction);
     rs.mLineLayout = &ll;
     ll.SetInFirstLetter(true);
     ll.SetFirstLetterStyleOK(true);
 
     kid->WillReflow(aPresContext);
diff --git a/layout/generic/nsFlexContainerFrame.cpp b/layout/generic/nsFlexContainerFrame.cpp
--- a/layout/generic/nsFlexContainerFrame.cpp
+++ b/layout/generic/nsFlexContainerFrame.cpp
@@ -110,17 +110,17 @@ GetReverseAxis(AxisOrientationType aAxis
   return reversedAxis;
 }
 
 // Returns aFrame's computed value for 'height' or 'width' -- whichever is in
 // the same dimension as aAxis.
 static inline const nsStyleCoord&
 GetSizePropertyForAxis(const nsIFrame* aFrame, AxisOrientationType aAxis)
 {
-  const nsStylePosition* stylePos = aFrame->GetStylePosition();
+  const nsStylePosition* stylePos = aFrame->StylePosition();
 
   return IsAxisHorizontal(aAxis) ?
     stylePos->mWidth :
     stylePos->mHeight;
 }
 
 static nscoord
 MarginComponentForSide(const nsMargin& aMargin, Side aSide)
@@ -513,18 +513,18 @@ IsOrderLEQWithDOMFallback(nsIFrame* aFra
 {
   if (aFrame1 == aFrame2) {
     // Anything is trivially LEQ itself, so we return "true" here... but it's
     // probably bad if we end up actually needing this, so let's assert.
     NS_ERROR("Why are we checking if a frame is LEQ itself?");
     return true;
   }
 
-  int32_t order1 = aFrame1->GetStylePosition()->mOrder;
-  int32_t order2 = aFrame2->GetStylePosition()->mOrder;
+  int32_t order1 = aFrame1->StylePosition()->mOrder;
+  int32_t order2 = aFrame2->StylePosition()->mOrder;
 
   if (order1 != order2) {
     return order1 < order2;
   }
 
   // Same "order" value --> use DOM position.
   nsIContent* content1 = GetContentForComparison(aFrame1);
   nsIContent* content2 = GetContentForComparison(aFrame2);
@@ -546,18 +546,18 @@ IsOrderLEQWithDOMFallback(nsIFrame* aFra
  *
  * @return true if the computed "order" property of aFrame1 is less than or
  *         equal to that of aFrame2.  Otherwise, returns false.
  */
 bool
 IsOrderLEQ(nsIFrame* aFrame1,
            nsIFrame* aFrame2)
 {
-  int32_t order1 = aFrame1->GetStylePosition()->mOrder;
-  int32_t order2 = aFrame2->GetStylePosition()->mOrder;
+  int32_t order1 = aFrame1->StylePosition()->mOrder;
+  int32_t order2 = aFrame2->StylePosition()->mOrder;
 
   return order1 <= order2;
 }
 
 bool
 nsFlexContainerFrame::IsHorizontal()
 {
   const FlexboxAxisTracker axisTracker(this);
@@ -576,17 +576,17 @@ nsFlexContainerFrame::AppendFlexItemForC
   // main-size and the computed values of min / max main-size property.
   // (This reflow state will _not_ be used for reflow.)
   nsHTMLReflowState childRS(aPresContext, aParentReflowState, aChildFrame,
                             nsSize(aParentReflowState.ComputedWidth(),
                                    aParentReflowState.ComputedHeight()));
 
   // FLEX GROW & SHRINK WEIGHTS
   // --------------------------
-  const nsStylePosition* stylePos = aChildFrame->GetStylePosition();
+  const nsStylePosition* stylePos = aChildFrame->StylePosition();
   float flexGrow   = stylePos->mFlexGrow;
   float flexShrink = stylePos->mFlexShrink;
 
   // MAIN SIZES (flex base size, min/max size)
   // -----------------------------------------
   nscoord flexBaseSize =
     aAxisTracker.GetMainComponent(nsSize(childRS.ComputedWidth(),
                                          childRS.ComputedHeight()));
@@ -606,17 +606,17 @@ nsFlexContainerFrame::AppendFlexItemForC
   // available width.  This is the same as our "min-content" height --
   // so if we have "min-height:auto", we need to use this value as our
   // min-height.
   bool needToMeasureMaxContentHeight = false;
   if (!IsAxisHorizontal(aAxisTracker.GetMainAxis())) {
     bool isMainSizeAuto = (NS_UNCONSTRAINEDSIZE == flexBaseSize);
     bool isMainMinSizeAuto =
       (eStyleUnit_Auto ==
-       aChildFrame->GetStylePosition()->mMinHeight.GetUnit());
+       aChildFrame->StylePosition()->mMinHeight.GetUnit());
 
     needToMeasureMaxContentHeight = isMainSizeAuto || isMainMinSizeAuto;
 
     if (needToMeasureMaxContentHeight) {
       // Give the item a special reflow with "mIsFlexContainerMeasuringHeight"
       // set.  This tells it to behave as if it had "height: auto", regardless
       // of what the "height" property is actually set to.
       nsHTMLReflowState
@@ -686,17 +686,17 @@ nsFlexContainerFrame::AppendFlexItemForC
     aAxisTracker.GetCrossComponent(nsSize(childRS.mComputedMaxWidth,
                                           childRS.mComputedMaxHeight));
 
   // SPECIAL-CASE FOR WIDGET-IMPOSED SIZES
   // Check if we're a themed widget, in which case we might have a minimum
   // main & cross size imposed by our widget (which we can't go below), or
   // (more severe) our widget might have only a single valid size.
   bool isFixedSizeWidget = false;
-  const nsStyleDisplay* disp = aChildFrame->GetStyleDisplay();
+  const nsStyleDisplay* disp = aChildFrame->StyleDisplay();
   if (aChildFrame->IsThemed(disp)) {
     nsIntSize widgetMinSize(0, 0);
     bool canOverride = true;
     aPresContext->GetTheme()->
       GetMinimumWidgetSize(childRS.rendContext, aChildFrame,
                            disp->mAppearance,
                            &widgetMinSize, &canOverride);
 
@@ -779,38 +779,38 @@ FlexItem::FlexItem(nsIFrame* aChildFrame
     mCrossPosn(0),
     mAscent(0),
     mShareOfFlexWeightSoFar(0.0f),
     mIsFrozen(false),
     mHadMinViolation(false),
     mHadMaxViolation(false),
     mHadMeasuringReflow(false),
     mIsStretched(false),
-    mAlignSelf(aChildFrame->GetStylePosition()->mAlignSelf)
+    mAlignSelf(aChildFrame->StylePosition()->mAlignSelf)
 {
   MOZ_ASSERT(aChildFrame, "expecting a non-null child frame");
 
   // Assert that any "auto" margin components are set to 0.
   // (We'll resolve them later; until then, we want to treat them as 0-sized.)
 #ifdef DEBUG
   {
-    const nsStyleSides& styleMargin = mFrame->GetStyleMargin()->mMargin;
+    const nsStyleSides& styleMargin = mFrame->StyleMargin()->mMargin;
     NS_FOR_CSS_SIDES(side) {
       if (styleMargin.GetUnit(side) == eStyleUnit_Auto) {
         MOZ_ASSERT(GetMarginComponentForSide(side) == 0,
                    "Someone else tried to resolve our auto margin");
       }
     }
   }
 #endif // DEBUG
 
   // Resolve "align-self: auto" to parent's "align-items" value.
   if (mAlignSelf == NS_STYLE_ALIGN_SELF_AUTO) {
     mAlignSelf =
-      mFrame->StyleContext()->GetParent()->GetStylePosition()->mAlignItems;
+      mFrame->StyleContext()->GetParent()->StylePosition()->mAlignItems;
   }
 
   // If the flex item's inline axis is the same as the cross axis, then
   // 'align-self:baseline' is identical to 'flex-start'. If that's the case, we
   // just directly convert our align-self value here, so that we don't have to
   // handle this with special cases elsewhere.
   // Moreover: for the time being (until we support writing-modes),
   // all inline axes are horizontal -- so we can just check if the cross axis
@@ -823,17 +823,17 @@ FlexItem::FlexItem(nsIFrame* aChildFrame
     mAlignSelf = NS_STYLE_ALIGN_ITEMS_FLEX_START;
   }
 }
 
 uint32_t
 FlexItem::GetNumAutoMarginsInAxis(AxisOrientationType aAxis) const
 {
   uint32_t numAutoMargins = 0;
-  const nsStyleSides& styleMargin = mFrame->GetStyleMargin()->mMargin;
+  const nsStyleSides& styleMargin = mFrame->StyleMargin()->mMargin;
   for (uint32_t i = 0; i < eNumAxisEdges; i++) {
     Side side = kAxisOrientationToSidesMap[aAxis][i];
     if (styleMargin.GetUnit(side) == eStyleUnit_Auto) {
       numAutoMargins++;
     }
   }
 
   // Mostly for clarity:
@@ -1061,17 +1061,17 @@ nsFlexContainerFrame::GetFrameName(nsASt
 //    normal flow, except that 'z-index' values other than 'auto' create
 //    a stacking context even if 'position' is 'static'.
 // http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#painting
 uint32_t
 GetDisplayFlagsForFlexItem(nsIFrame* aFrame)
 {
   MOZ_ASSERT(aFrame->IsFlexItem(), "Should only be called on flex items");
 
-  const nsStylePosition* pos = aFrame->GetStylePosition();
+  const nsStylePosition* pos = aFrame->StylePosition();
   if (pos->mZIndex.GetUnit() == eStyleUnit_Integer) {
     return nsIFrame::DISPLAY_CHILD_FORCE_STACKING_CONTEXT;
   }
   return 0;
 }
 
 NS_IMETHODIMP
 nsFlexContainerFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
@@ -1439,17 +1439,17 @@ MainAxisPositionTracker::
   }
 
   if (mPackingSpaceRemaining > 0) {
     for (uint32_t i = 0; i < aItems.Length(); i++) {
       mNumAutoMarginsInMainAxis += aItems[i].GetNumAutoMarginsInAxis(mAxis);
     }
   }
 
-  mJustifyContent = aFlexContainerFrame->GetStylePosition()->mJustifyContent;
+  mJustifyContent = aFlexContainerFrame->StylePosition()->mJustifyContent;
   // If packing space is negative, 'justify' behaves like 'start', and
   // 'distribute' behaves like 'center'.  In those cases, it's simplest to
   // just pretend we have a different 'justify-content' value and share code.
   if (mPackingSpaceRemaining < 0) {
     if (mJustifyContent == NS_STYLE_JUSTIFY_CONTENT_SPACE_BETWEEN) {
       mJustifyContent = NS_STYLE_JUSTIFY_CONTENT_FLEX_START;
     } else if (mJustifyContent == NS_STYLE_JUSTIFY_CONTENT_SPACE_AROUND) {
       mJustifyContent = NS_STYLE_JUSTIFY_CONTENT_CENTER;
@@ -1511,17 +1511,17 @@ MainAxisPositionTracker::
              "extra space should either go to packing space or to "
              "auto margins, but not to both");
 }
 
 void
 MainAxisPositionTracker::ResolveAutoMarginsInMainAxis(FlexItem& aItem)
 {
   if (mNumAutoMarginsInMainAxis) {
-    const nsStyleSides& styleMargin = aItem.Frame()->GetStyleMargin()->mMargin;
+    const nsStyleSides& styleMargin = aItem.Frame()->StyleMargin()->mMargin;
     for (uint32_t i = 0; i < eNumAxisEdges; i++) {
       Side side = kAxisOrientationToSidesMap[mAxis][i];
       if (styleMargin.GetUnit(side) == eStyleUnit_Auto) {
         // NOTE: This integer math will skew the distribution of remainder
         // app-units towards the end, which is fine.
         nscoord curAutoMarginSize =
           mPackingSpaceRemaining / mNumAutoMarginsInMainAxis;
 
@@ -1716,17 +1716,17 @@ SingleLineCrossAxisPositionTracker::
 
   uint32_t numAutoMargins = aItem.GetNumAutoMarginsInAxis(mAxis);
   if (numAutoMargins == 0) {
     return; // No auto margins --> nothing to do.
   }
 
   // OK, we have at least one auto margin and we have some available space.
   // Give each auto margin a share of the space.
-  const nsStyleSides& styleMargin = aItem.Frame()->GetStyleMargin()->mMargin;
+  const nsStyleSides& styleMargin = aItem.Frame()->StyleMargin()->mMargin;
   for (uint32_t i = 0; i < eNumAxisEdges; i++) {
     Side side = kAxisOrientationToSidesMap[mAxis][i];
     if (styleMargin.GetUnit(side) == eStyleUnit_Auto) {
       MOZ_ASSERT(aItem.GetMarginComponentForSide(side) == 0,
                  "Expecting auto margins to have value '0' before we "
                  "update them");
 
       // NOTE: integer divison is fine here; numAutoMargins is either 1 or 2.
@@ -1786,19 +1786,19 @@ SingleLineCrossAxisPositionTracker::
       NS_NOTREACHED("Unexpected align-self value");
       break;
   }
 }
 
 FlexboxAxisTracker::FlexboxAxisTracker(nsFlexContainerFrame* aFlexContainerFrame)
 {
   uint32_t flexDirection =
-    aFlexContainerFrame->GetStylePosition()->mFlexDirection;
+    aFlexContainerFrame->StylePosition()->mFlexDirection;
   uint32_t cssDirection =
-    aFlexContainerFrame->GetStyleVisibility()->mDirection;
+    aFlexContainerFrame->StyleVisibility()->mDirection;
 
   MOZ_ASSERT(cssDirection == NS_STYLE_DIRECTION_LTR ||
              cssDirection == NS_STYLE_DIRECTION_RTL,
              "Unexpected computed value for 'direction' property");
   // (Not asserting for flexDirection here; it's checked by the switch below.)
 
   // These are defined according to writing-modes' definitions of
   // start/end (for the inline dimension) and before/after (for the block
@@ -2071,17 +2071,17 @@ nsFlexContainerFrame::Reflow(nsPresConte
   if (IsFrameTreeTooDeep(aReflowState, aDesiredSize, aStatus)) {
     return NS_OK;
   }
 
   // We (and our children) can only depend on our ancestor's height if we have
   // a percent-height.  (There are actually other cases, too -- e.g. if our
   // parent is itself a vertical flex container and we're flexible -- but we'll
   // let our ancestors handle those sorts of cases.)
-  if (GetStylePosition()->mHeight.HasPercent()) {
+  if (StylePosition()->mHeight.HasPercent()) {
     AddStateBits(NS_FRAME_CONTAINS_RELATIVE_HEIGHT);
   }
 
 #ifdef DEBUG
   SanityCheckAnonymousFlexItems();
 #endif // DEBUG
 
   // If our subtree is dirty (i.e. some of our descendants have changed), we
@@ -2313,17 +2313,17 @@ nsFlexContainerFrame::Reflow(nsPresConte
       // handle incomplete childReflowStatuses. But for now, we give our kids
       // unconstrained available height, which means they should always
       // complete.
       MOZ_ASSERT(NS_FRAME_IS_COMPLETE(childReflowStatus),
                  "We gave flex item unconstrained available height, so it "
                  "should be complete");
 
       // Apply CSS relative positioning
-      const nsStyleDisplay* styleDisp = curItem.Frame()->GetStyleDisplay();
+      const nsStyleDisplay* styleDisp = curItem.Frame()->StyleDisplay();
       if (NS_STYLE_POSITION_RELATIVE == styleDisp->mPosition) {
         physicalPosn.x += childReflowState.mComputedOffsets.left;
         physicalPosn.y += childReflowState.mComputedOffsets.top;
       }
 
       rv = FinishReflowChild(curItem.Frame(), aPresContext,
                              &childReflowState, childDesiredSize,
                              physicalPosn.x, physicalPosn.y, 0);
diff --git a/layout/generic/nsFloatManager.cpp b/layout/generic/nsFloatManager.cpp
--- a/layout/generic/nsFloatManager.cpp
+++ b/layout/generic/nsFloatManager.cpp
@@ -196,17 +196,17 @@ nsFloatManager::GetFlowArea(nscoord aYOf
       // This float is in our band.
 
       // Shrink our band's height if needed.
       if (floatBottom < bottom && aInfoType == BAND_FROM_POINT) {
         bottom = floatBottom;
       }
 
       // Shrink our band's width if needed.
-      if (fi.mFrame->GetStyleDisplay()->mFloats == NS_STYLE_FLOAT_LEFT) {
+      if (fi.mFrame->StyleDisplay()->mFloats == NS_STYLE_FLOAT_LEFT) {
         // A left float.
         nscoord rightEdge = fi.mRect.XMost();
         if (rightEdge > left) {
           left = rightEdge;
           // Only set haveFloats to true if the float is inside our
           // containing block.  This matches the spec for what some
           // callers want and disagrees for other callers, so we should
           // probably provide better information at some point.
@@ -240,17 +240,17 @@ nsFloatManager::AddFloat(nsIFrame* aFloa
   if (HasAnyFloats()) {
     FloatInfo &tail = mFloats[mFloats.Length() - 1];
     info.mLeftYMost = tail.mLeftYMost;
     info.mRightYMost = tail.mRightYMost;
   } else {
     info.mLeftYMost = nscoord_MIN;
     info.mRightYMost = nscoord_MIN;
   }
-  uint8_t floatStyle = aFloatFrame->GetStyleDisplay()->mFloats;
+  uint8_t floatStyle = aFloatFrame->StyleDisplay()->mFloats;
   NS_ASSERTION(floatStyle == NS_STYLE_FLOAT_LEFT ||
                floatStyle == NS_STYLE_FLOAT_RIGHT, "unexpected float");
   nscoord& sideYMost = (floatStyle == NS_STYLE_FLOAT_LEFT) ? info.mLeftYMost
                                                            : info.mRightYMost;
   nscoord thisYMost = info.mRect.YMost();
   if (thisYMost > sideYMost)
     sideYMost = thisYMost;
 
@@ -267,17 +267,17 @@ nsFloatManager::CalculateRegionFor(nsIFr
   nsRect region = aFloat->GetRect();
 
   // Float region includes its margin
   region.Inflate(aMargin);
 
   // If the element is relatively positioned, then adjust x and y
   // accordingly so that we consider relatively positioned frames
   // at their original position.
-  const nsStyleDisplay* display = aFloat->GetStyleDisplay();
+  const nsStyleDisplay* display = aFloat->StyleDisplay();
   region -= aFloat->GetRelativeOffset(display);
 
   // Don't store rectangles with negative margin-box width or height in
   // the float manager; it can't deal with them.
   if (region.width < 0) {
     // Preserve the right margin-edge for left floats and the left
     // margin-edge for right floats
     if (NS_STYLE_FLOAT_LEFT == display->mFloats) {
diff --git a/layout/generic/nsFontInflationData.cpp b/layout/generic/nsFontInflationData.cpp
--- a/layout/generic/nsFontInflationData.cpp
+++ b/layout/generic/nsFontInflationData.cpp
@@ -257,17 +257,17 @@ nsFontInflationData::FindEdgeInflatableF
         continue;
       }
 
       if (kid->GetType() == nsGkAtoms::textFrame) {
         nsIContent *content = kid->GetContent();
         if (content && kid == content->GetPrimaryFrame()) {
           uint32_t len = nsTextFrameUtils::
             ComputeApproximateLengthWithWhitespaceCompression(
-              content, kid->GetStyleText());
+              content, kid->StyleText());
           if (len != 0) {
             return kid;
           }
         }
       } else {
         nsIFrame *kidResult =
           FindEdgeInflatableFrameIn(kid, aDirection);
         if (kidResult) {
@@ -301,17 +301,17 @@ DoCharCountOfLargestOption(nsIFrame *aCo
     } else {
       // REVIEW: Check the frame structure for this!
       optionResult = 0;
       for (nsIFrame *optionChild = option->GetFirstPrincipalChild();
            optionChild; optionChild = optionChild->GetNextSibling()) {
         if (optionChild->GetType() == nsGkAtoms::textFrame) {
           optionResult += nsTextFrameUtils::
             ComputeApproximateLengthWithWhitespaceCompression(
-              optionChild->GetContent(), optionChild->GetStyleText());
+              optionChild->GetContent(), optionChild->StyleText());
         }
       }
     }
     if (optionResult > result) {
       result = optionResult;
     }
   }
   return result;
@@ -343,41 +343,41 @@ nsFontInflationData::ScanTextIn(nsIFrame
       }
 
       nsIAtom *fType = kid->GetType();
       if (fType == nsGkAtoms::textFrame) {
         nsIContent *content = kid->GetContent();
         if (content && kid == content->GetPrimaryFrame()) {
           uint32_t len = nsTextFrameUtils::
             ComputeApproximateLengthWithWhitespaceCompression(
-              content, kid->GetStyleText());
+              content, kid->StyleText());
           if (len != 0) {
-            nscoord fontSize = kid->GetStyleFont()->mFont.size;
+            nscoord fontSize = kid->StyleFont()->mFont.size;
             if (fontSize > 0) {
               mTextAmount += fontSize * len;
             }
           }
         }
       } else if (fType == nsGkAtoms::textInputFrame) {
         // We don't want changes to the amount of text in a text input
         // to change what we count towards inflation.
-        nscoord fontSize = kid->GetStyleFont()->mFont.size;
+        nscoord fontSize = kid->StyleFont()->mFont.size;
         int32_t charCount = static_cast<nsTextControlFrame*>(kid)->GetCols();
         mTextAmount += charCount * fontSize;
       } else if (fType == nsGkAtoms::comboboxControlFrame) {
         // See textInputFrame above (with s/amount of text/selected option/).
         // Don't just recurse down to the list control inside, since we
         // need to exclude the display frame.
-        nscoord fontSize = kid->GetStyleFont()->mFont.size;
+        nscoord fontSize = kid->StyleFont()->mFont.size;
         int32_t charCount = CharCountOfLargestOption(
           static_cast<nsComboboxControlFrame*>(kid)->GetDropDown());
         mTextAmount += charCount * fontSize;
       } else if (fType == nsGkAtoms::listControlFrame) {
         // See textInputFrame above (with s/amount of text/selected option/).
-        nscoord fontSize = kid->GetStyleFont()->mFont.size;
+        nscoord fontSize = kid->StyleFont()->mFont.size;
         int32_t charCount = CharCountOfLargestOption(kid);
         mTextAmount += charCount * fontSize;
       } else {
         // recursive step
         ScanTextIn(kid);
       }
 
       if (mTextAmount >= mTextThreshold) {
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -290,17 +290,17 @@ nsIFrame::CheckAndClearPaintedState()
     }
   }
   return result;
 }
 
 bool
 nsIFrame::IsVisibleConsideringAncestors(uint32_t aFlags) const
 {
-  if (!GetStyleVisibility()->IsVisible()) {
+  if (!StyleVisibility()->IsVisible()) {
     return false;
   }
 
   const nsIFrame* frame = this;
   while (frame) {
     nsView* view = frame->GetView();
     if (view && view->GetVisibility() == nsViewVisibility_kHide)
       return false;
@@ -319,17 +319,17 @@ nsIFrame::IsVisibleConsideringAncestors(
       if (!parent)
         break;
 
       if ((aFlags & nsIFrame::VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY) == 0 &&
           parent->PresContext()->IsChrome() && !frame->PresContext()->IsChrome()) {
         break;
       }
 
-      if (!parent->GetStyleVisibility()->IsVisible())
+      if (!parent->StyleVisibility()->IsVisible())
         return false;
 
       frame = parent;
     }
   }
 
   return true;
 }
@@ -524,17 +524,17 @@ nsFrame::Init(nsIContent*      aContent,
     nsFrameState state = mParent->GetStateBits();
 
     // Make bits that are currently off (see constructor) the same:
     mState |= state & (NS_FRAME_INDEPENDENT_SELECTION |
                        NS_FRAME_GENERATED_CONTENT |
                        NS_FRAME_IS_SVG_TEXT |
                        NS_FRAME_IN_POPUP);
   }
-  const nsStyleDisplay *disp = GetStyleDisplay();
+  const nsStyleDisplay *disp = StyleDisplay();
   if (disp->HasTransform(this)) {
     // The frame gets reconstructed if we toggle the -moz-transform
     // property, so we can set this bit here and then ignore it.
     mState |= NS_FRAME_MAY_BE_TRANSFORMED;
   }
 
   if (nsLayoutUtils::FontSizeInflationEnabled(PresContext()) || !GetParent()
 #ifdef DEBUG
@@ -730,19 +730,19 @@ nsFrame::DidSetStyleContext(nsStyleConte
   // does not have the same image, clear the image load notifier
   // (which keeps the image loading, if it still is) for the frame.
   // We want to do this conservatively because some frames paint their
   // backgrounds from some other frame's style data, and we don't want
   // to clear those notifiers unless we have to.  (They'll be reset
   // when we paint, although we could miss a notification in that
   // interval.)
   const nsStyleBackground *oldBG = aOldStyleContext ?
-                                   aOldStyleContext->GetStyleBackground() :
+                                   aOldStyleContext->StyleBackground() :
                                    nullptr;
-  const nsStyleBackground *newBG = GetStyleBackground();
+  const nsStyleBackground *newBG = StyleBackground();
   if (oldBG) {
     NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, oldBG) {
       // If there is an image in oldBG that's not in newBG, drop it.
       if (i >= newBG->mImageCount ||
           oldBG->mLayers[i].mImage != newBG->mLayers[i].mImage) {
         const nsStyleImage& oldImage = oldBG->mLayers[i].mImage;
         if (oldImage.GetType() != eStyleImageType_Image) {
           continue;
@@ -773,45 +773,45 @@ nsFrame::DidSetStyleContext(nsStyleConte
     // calls GetUsed(Margin|Border|Padding)() before the next reflow, we
     // can give an accurate answer.
     // We don't want to set the property if one already exists.
     FrameProperties props = Properties();
     nsMargin oldValue(0, 0, 0, 0);
     nsMargin newValue(0, 0, 0, 0);
     const nsStyleMargin* oldMargin = aOldStyleContext->PeekStyleMargin();
     if (oldMargin && oldMargin->GetMargin(oldValue)) {
-      if ((!GetStyleMargin()->GetMargin(newValue) || oldValue != newValue) &&
+      if ((!StyleMargin()->GetMargin(newValue) || oldValue != newValue) &&
           !props.Get(UsedMarginProperty())) {
         props.Set(UsedMarginProperty(), new nsMargin(oldValue));
       }
     }
 
     const nsStylePadding* oldPadding = aOldStyleContext->PeekStylePadding();
     if (oldPadding && oldPadding->GetPadding(oldValue)) {
-      if ((!GetStylePadding()->GetPadding(newValue) || oldValue != newValue) &&
+      if ((!StylePadding()->GetPadding(newValue) || oldValue != newValue) &&
           !props.Get(UsedPaddingProperty())) {
         props.Set(UsedPaddingProperty(), new nsMargin(oldValue));
       }
     }
 
     const nsStyleBorder* oldBorder = aOldStyleContext->PeekStyleBorder();
     if (oldBorder) {
       oldValue = oldBorder->GetComputedBorder();
-      newValue = GetStyleBorder()->GetComputedBorder();
+      newValue = StyleBorder()->GetComputedBorder();
       if (oldValue != newValue &&
           !props.Get(UsedBorderProperty())) {
         props.Set(UsedBorderProperty(), new nsMargin(oldValue));
       }
     }
   }
 
   imgIRequest *oldBorderImage = aOldStyleContext
-    ? aOldStyleContext->GetStyleBorder()->GetBorderImage()
+    ? aOldStyleContext->StyleBorder()->GetBorderImage()
     : nullptr;
-  imgIRequest *newBorderImage = GetStyleBorder()->GetBorderImage();
+  imgIRequest *newBorderImage = StyleBorder()->GetBorderImage();
   // FIXME (Bug 759996): The following is no longer true.
   // For border-images, we can't be as conservative (we need to set the
   // new loaders if there has been any change) since the CalcDifference
   // call depended on the result of GetComputedBorder() and that result
   // depends on whether the image has loaded, start the image load now
   // so that we'll get notified when it completes loading and can do a
   // restyle.  Otherwise, the image might finish loading from the
   // network before we start listening to its notifications, and then
@@ -830,17 +830,17 @@ nsFrame::DidSetStyleContext(nsStyleConte
       imageLoader->AssociateRequestToFrame(newBorderImage, this);
     }
   }
 
   // If the page contains markup that overrides text direction, and
   // does not contain any characters that would activate the Unicode
   // bidi algorithm, we need to call |SetBidiEnabled| on the pres
   // context before reflow starts.  See bug 115921.
-  if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
+  if (StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
     PresContext()->SetBidiEnabled();
   }
 }
 
 // MSVC fails with link error "one or more multiply defined symbols found",
 // gcc fails with "hidden symbol `nsIFrame::kPrincipalList' isn't defined"
 // etc if they are not defined.
 #ifndef _MSC_VER
@@ -874,17 +874,17 @@ nsIFrame::GetUsedMargin() const
   nsMargin *m = static_cast<nsMargin*>
                            (Properties().Get(UsedMarginProperty()));
   if (m) {
     margin = *m;
   } else {
 #ifdef DEBUG
     bool hasMargin = 
 #endif
-    GetStyleMargin()->GetMargin(margin);
+    StyleMargin()->GetMargin(margin);
     NS_ASSERTION(hasMargin, "We should have a margin here! (out of memory?)");
   }
   return margin;
 }
 
 /* virtual */ nsMargin
 nsIFrame::GetUsedBorder() const
 {
@@ -892,17 +892,17 @@ nsIFrame::GetUsedBorder() const
   if (((mState & NS_FRAME_FIRST_REFLOW) &&
        !(mState & NS_FRAME_IN_REFLOW)) ||
       (mState & NS_FRAME_IS_SVG_TEXT))
     return border;
 
   // Theme methods don't use const-ness.
   nsIFrame *mutable_this = const_cast<nsIFrame*>(this);
 
-  const nsStyleDisplay *disp = GetStyleDisplay();
+  const nsStyleDisplay *disp = StyleDisplay();
   if (mutable_this->IsThemed(disp)) {
     nsIntMargin result;
     nsPresContext *presContext = PresContext();
     presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
                                              mutable_this, disp->mAppearance,
                                              &result);
     border.left = presContext->DevPixelsToAppUnits(result.left);
     border.top = presContext->DevPixelsToAppUnits(result.top);
@@ -911,34 +911,34 @@ nsIFrame::GetUsedBorder() const
     return border;
   }
 
   nsMargin *b = static_cast<nsMargin*>
                            (Properties().Get(UsedBorderProperty()));
   if (b) {
     border = *b;
   } else {
-    border = GetStyleBorder()->GetComputedBorder();
+    border = StyleBorder()->GetComputedBorder();
   }
   return border;
 }
 
 /* virtual */ nsMargin
 nsIFrame::GetUsedPadding() const
 {
   nsMargin padding(0, 0, 0, 0);
   if (((mState & NS_FRAME_FIRST_REFLOW) &&
        !(mState & NS_FRAME_IN_REFLOW)) ||
       (mState & NS_FRAME_IS_SVG_TEXT))
     return padding;
 
   // Theme methods don't use const-ness.
   nsIFrame *mutable_this = const_cast<nsIFrame*>(this);
 
-  const nsStyleDisplay *disp = GetStyleDisplay();
+  const nsStyleDisplay *disp = StyleDisplay();
   if (mutable_this->IsThemed(disp)) {
     nsPresContext *presContext = PresContext();
     nsIntMargin widget;
     if (presContext->GetTheme()->GetWidgetPadding(presContext->DeviceContext(),
                                                   mutable_this,
                                                   disp->mAppearance,
                                                   &widget)) {
       padding.top = presContext->DevPixelsToAppUnits(widget.top);
@@ -952,17 +952,17 @@ nsIFrame::GetUsedPadding() const
   nsMargin *p = static_cast<nsMargin*>
                            (Properties().Get(UsedPaddingProperty()));
   if (p) {
     padding = *p;
   } else {
 #ifdef DEBUG
     bool hasPadding = 
 #endif
-    GetStylePadding()->GetPadding(padding);
+    StylePadding()->GetPadding(padding);
     NS_ASSERTION(hasPadding, "We should have padding here! (out of memory?)");
   }
   return padding;
 }
 
 void
 nsIFrame::ApplySkipSides(nsMargin& aMargin) const
 {
@@ -992,92 +992,92 @@ nsIFrame::GetPaddingRect() const
 {
   return GetPaddingRectRelativeToSelf() + GetPosition();
 }
 
 bool
 nsIFrame::IsTransformed() const
 {
   return ((mState & NS_FRAME_MAY_BE_TRANSFORMED) &&
-          (GetStyleDisplay()->HasTransform(this) ||
+          (StyleDisplay()->HasTransform(this) ||
            IsSVGTransformed() ||
            (mContent &&
             nsLayoutUtils::HasAnimationsForCompositor(mContent,
                                                       eCSSProperty_transform) &&
             IsFrameOfType(eSupportsCSSTransforms) &&
             mContent->GetPrimaryFrame() == this)));
 }
 
 bool
 nsIFrame::HasOpacity() const
 {
-  return GetStyleDisplay()->mOpacity < 1.0f || (mContent &&
+  return StyleDisplay()->mOpacity < 1.0f || (mContent &&
            nsLayoutUtils::HasAnimationsForCompositor(mContent,
                                                      eCSSProperty_opacity) &&
            mContent->GetPrimaryFrame() == this);
 }
 
 bool
 nsIFrame::IsSVGTransformed(gfxMatrix *aOwnTransforms,
                            gfxMatrix *aFromParentTransforms) const
 {
   return false;
 }
 
 bool
 nsIFrame::Preserves3DChildren() const
 {
-  if (GetStyleDisplay()->mTransformStyle != NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D ||
-      !GetStyleDisplay()->HasTransform(this))
+  if (StyleDisplay()->mTransformStyle != NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D ||
+      !StyleDisplay()->HasTransform(this))
       return false;
 
   // If we're all scroll frame, then all descendants will be clipped, so we can't preserve 3d.
   if (GetType() == nsGkAtoms::scrollFrame)
       return false;
 
   nsRect temp;
-  return (!ApplyOverflowClipping(nullptr, this, GetStyleDisplay(), &temp) &&
-      !ApplyClipPropClipping(nullptr, GetStyleDisplay(), this, &temp) &&
+  return (!ApplyOverflowClipping(nullptr, this, StyleDisplay(), &temp) &&
+      !ApplyClipPropClipping(nullptr, StyleDisplay(), this, &temp) &&
       !nsSVGIntegrationUtils::UsingEffectsForFrame(this));
 }
 
 bool
 nsIFrame::Preserves3D() const
 {
   if (!GetParent() || !GetParent()->Preserves3DChildren() ||
-      !GetStyleDisplay()->HasTransform(this)) {
+      !StyleDisplay()->HasTransform(this)) {
     return false;
   }
   return true;
 }
 
 bool
 nsIFrame::HasPerspective() const
 {
   if (!IsTransformed()) {
     return false;
   }
   const nsStyleDisplay* parentDisp = nullptr;
   nsStyleContext* parentStyleContext = StyleContext()->GetParent();
   if (parentStyleContext) {
-    parentDisp = parentStyleContext->GetStyleDisplay();
+    parentDisp = parentStyleContext->StyleDisplay();
   }
 
   if (parentDisp &&
       parentDisp->mChildPerspective.GetUnit() == eStyleUnit_Coord &&
       parentDisp->mChildPerspective.GetCoordValue() > 0.0) {
     return true;
   }
   return false;
 }
 
 bool
 nsIFrame::ChildrenHavePerspective() const
 {
-  const nsStyleDisplay *disp = GetStyleDisplay();
+  const nsStyleDisplay *disp = StyleDisplay();
   if (disp &&
       disp->mChildPerspective.GetUnit() == eStyleUnit_Coord &&
       disp->mChildPerspective.GetCoordValue() > 0.0) {
     return true;
   }
   return false;
 }
 
@@ -1214,17 +1214,17 @@ nsIFrame::GetBorderRadii(nscoord aRadii[
     // border radius, but since we don't, we're better off assuming
     // zero.
     NS_FOR_CSS_HALF_CORNERS(corner) {
       aRadii[corner] = 0;
     }
     return false;
   }
   nsSize size = GetSize();
-  return ComputeBorderRadii(GetStyleBorder()->mBorderRadius, size, size,
+  return ComputeBorderRadii(StyleBorder()->mBorderRadius, size, size,
                             GetSkipSides(), aRadii);
 }
 
 bool
 nsIFrame::GetPaddingBoxBorderRadii(nscoord aRadii[8]) const
 {
   if (!GetBorderRadii(aRadii))
     return false;
@@ -1455,17 +1455,17 @@ nsFrame::DisplaySelectionOverlay(nsDispl
   return aList->AppendNewToTop(new (aBuilder)
       nsDisplaySelectionOverlay(aBuilder, this, selectionValue));
 }
 
 nsresult
 nsFrame::DisplayOutlineUnconditional(nsDisplayListBuilder*   aBuilder,
                                      const nsDisplayListSet& aLists)
 {
-  if (GetStyleOutline()->GetOutlineStyle() == NS_STYLE_BORDER_STYLE_NONE)
+  if (StyleOutline()->GetOutlineStyle() == NS_STYLE_BORDER_STYLE_NONE)
     return NS_OK;
     
   return aLists.Outlines()->AppendNewToTop(
       new (aBuilder) nsDisplayOutline(aBuilder, this));
 }
 
 nsresult
 nsFrame::DisplayOutline(nsDisplayListBuilder*   aBuilder,
@@ -1487,32 +1487,32 @@ nsIFrame::DisplayCaret(nsDisplayListBuil
   return aList->AppendNewToTop(
       new (aBuilder) nsDisplayCaret(aBuilder, this, aBuilder->GetCaret()));
 }
 
 nscolor
 nsIFrame::GetCaretColorAt(int32_t aOffset)
 {
   // Use text color.
-  return GetStyleColor()->mColor;
+  return StyleColor()->mColor;
 }
 
 nsresult
 nsFrame::DisplayBackgroundUnconditional(nsDisplayListBuilder*   aBuilder,
                                         const nsDisplayListSet& aLists,
                                         bool                    aForceBackground,
                                         nsDisplayBackgroundImage**   aBackground)
 {
   *aBackground = nullptr;
 
   // Here we don't try to detect background propagation. Frames that might
   // receive a propagated background should just set aForceBackground to
   // true.
   if (aBuilder->IsForEventDelivery() || aForceBackground ||
-      !GetStyleBackground()->IsTransparent() || GetStyleDisplay()->mAppearance) {
+      !StyleBackground()->IsTransparent() || StyleDisplay()->mAppearance) {
     return nsDisplayBackgroundImage::AppendBackgroundItemsToTop(aBuilder, this,
                                                            aLists.BorderBackground(),
                                                            aBackground);
   }
 
   return NS_OK;
 }
 
@@ -1522,17 +1522,17 @@ nsFrame::DisplayBorderBackgroundOutline(
                                         bool                    aForceBackground)
 {
   // The visibility check belongs here since child elements have the
   // opportunity to override the visibility property and display even if
   // their parent is hidden.
   if (!IsVisibleForPainting(aBuilder))
     return NS_OK;
 
-  nsCSSShadowArray* shadows = GetStyleBorder()->mBoxShadow;
+  nsCSSShadowArray* shadows = StyleBorder()->mBoxShadow;
   if (shadows && shadows->HasShadowWithInset(false)) {
     nsresult rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
         nsDisplayBoxShadowOuter(aBuilder, this));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   nsDisplayBackgroundImage* bg;
   nsresult rv =
@@ -1542,17 +1542,17 @@ nsFrame::DisplayBorderBackgroundOutline(
   if (shadows && shadows->HasShadowWithInset(true)) {
     rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
         nsDisplayBoxShadowInner(aBuilder, this));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   // If there's a themed background, we should not create a border item.
   // It won't be rendered.
-  if ((!bg || !bg->IsThemed()) && GetStyleBorder()->HasBorder()) {
+  if ((!bg || !bg->IsThemed()) && StyleBorder()->HasBorder()) {
     rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
         nsDisplayBorder(aBuilder, this));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   return DisplayOutlineUnconditional(aBuilder, aLists);
 }
 
@@ -1861,17 +1861,17 @@ nsIFrame::BuildDisplayListForStackingCon
     return NS_OK;
 
   // Replaced elements have their visibility handled here, because
   // they're visually atomic
   if (IsFrameOfType(eReplaced) && !IsVisibleForPainting(aBuilder))
     return NS_OK;
 
   nsRect clipPropClip;
-  const nsStyleDisplay* disp = GetStyleDisplay();
+  const nsStyleDisplay* disp = StyleDisplay();
   // We can stop right away if this is a zero-opacity stacking context and
   // we're painting, and we're not animating opacity. Don't do this
   // if we're going to compute plugin geometry, since opacity-0 plugins
   // need to have display items built for them.
   if (disp->mOpacity == 0.0 && aBuilder->IsForPainting() &&
       !aBuilder->WillComputePluginGeometry() &&
       !nsLayoutUtils::HasAnimationsForCompositor(mContent,
                                                  eCSSProperty_opacity)) {
@@ -2182,26 +2182,26 @@ nsIFrame::BuildDisplayListForChild(nsDis
       // situations where we're going to ignore a scrollframe's clipping;
       // we wouldn't want to clip the dirty area to the scrollframe's
       // bounds in that case.
     }
   }
 
   // XXX need to have inline-block and inline-table set pseudoStackingContext
   
-  const nsStyleDisplay* ourDisp = GetStyleDisplay();
+  const nsStyleDisplay* ourDisp = StyleDisplay();
   // REVIEW: Taken from nsBoxFrame::Paint
   // Don't paint our children if the theme object is a leaf.
   if (IsThemed(ourDisp) &&
       !PresContext()->GetTheme()->WidgetIsContainer(ourDisp->mAppearance))
     return NS_OK;
 
   // Child is composited if it's transformed, partially transparent, or has
   // SVG effects.
-  const nsStyleDisplay* disp = child->GetStyleDisplay();
+  const nsStyleDisplay* disp = child->StyleDisplay();
   bool isVisuallyAtomic = child->HasOpacity()
     || child->IsTransformed()
     || nsSVGIntegrationUtils::UsingEffectsForFrame(child);
 
   bool isPositioned = !isSVG && disp->IsPositioned(child);
   if (isVisuallyAtomic || isPositioned || (!isSVG && disp->IsFloating(child)) ||
       ((disp->mClipFlags & NS_STYLE_CLIP_RECT) &&
        IsSVGContentWithCSSClip(child)) ||
@@ -2254,17 +2254,17 @@ nsIFrame::BuildDisplayListForChild(nsDis
 #ifdef DEBUG
     DisplayDebugBorders(aBuilder, child, aLists);
 #endif
     return rv;
   }
   
   nsDisplayList list;
   nsDisplayList extraPositionedDescendants;
-  const nsStylePosition* pos = child->GetStylePosition();
+  const nsStylePosition* pos = child->StylePosition();
   if ((isPositioned && pos->mZIndex.GetUnit() == eStyleUnit_Integer) ||
       isVisuallyAtomic || (aFlags & DISPLAY_CHILD_FORCE_STACKING_CONTEXT)) {
     // True stacking context
     rv = child->BuildDisplayListForStackingContext(aBuilder, dirty, &list);
     if (NS_SUCCEEDED(rv)) {
       rv = aBuilder->DisplayCaret(child, dirty, &list);
     }
   } else {
@@ -2585,17 +2585,17 @@ nsFrame::IsSelectable(bool* aSelectable,
   //    TEXT     -> NONE     -> AUTO -> _MOZ_ALL, the returned value is TEXT
   //    _MOZ_ALL -> TEXT     -> AUTO -> AUTO,     the returned value is _MOZ_ALL
   //    AUTO     -> CELL     -> TEXT -> AUTO,     the returned value is TEXT
   //
   uint8_t selectStyle  = NS_STYLE_USER_SELECT_AUTO;
   nsIFrame* frame      = (nsIFrame*)this;
 
   while (frame) {
-    const nsStyleUIReset* userinterface = frame->GetStyleUIReset();
+    const nsStyleUIReset* userinterface = frame->StyleUIReset();
     switch (userinterface->mUserSelect) {
       case NS_STYLE_USER_SELECT_ALL:
       case NS_STYLE_USER_SELECT_MOZ_ALL:
         // override the previous values
         selectStyle = userinterface->mUserSelect;
         break;
       default:
         // otherwise return the first value which is not 'auto'
@@ -3307,25 +3307,25 @@ struct FrameTarget {
 
 // See function implementation for information
 static FrameTarget GetSelectionClosestFrame(nsIFrame* aFrame, nsPoint aPoint,
                                             uint32_t aFlags);
 
 static bool SelfIsSelectable(nsIFrame* aFrame, uint32_t aFlags)
 {
   if ((aFlags & nsIFrame::SKIP_HIDDEN) &&
-      !aFrame->GetStyleVisibility()->IsVisible()) {
+      !aFrame->StyleVisibility()->IsVisible()) {
     return false;
   }
   return !aFrame->IsGeneratedContentFrame() &&
-    aFrame->GetStyleUIReset()->mUserSelect != NS_STYLE_USER_SELECT_NONE;
+    aFrame->StyleUIReset()->mUserSelect != NS_STYLE_USER_SELECT_NONE;
 }
 
 static bool SelectionDescendToKids(nsIFrame* aFrame) {
-  uint8_t style = aFrame->GetStyleUIReset()->mUserSelect;
+  uint8_t style = aFrame->StyleUIReset()->mUserSelect;
   nsIFrame* parent = aFrame->GetParent();
   // If we are only near (not directly over) then don't traverse
   // frames with independent selection (e.g. text and list controls)
   // unless we're already inside such a frame (see bug 268497).  Note that this
   // prevents any of the users of this method from entering form controls.
   // XXX We might want some way to allow using the up-arrow to go into a form
   // control, but the focus didn't work right anyway; it'd probably be enough
   // if the left and right arrows could enter textboxes (which I don't believe
@@ -3562,17 +3562,17 @@ nsIFrame::ContentOffsets OffsetsForSingl
     offsets.associateWithNext = true;
     return offsets;
   }
 
   // Figure out whether the offsets should be over, after, or before the frame
   nsRect rect(nsPoint(0, 0), aFrame->GetSize());
 
   bool isBlock = aFrame->GetDisplay() != NS_STYLE_DISPLAY_INLINE;
-  bool isRtl = (aFrame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL);
+  bool isRtl = (aFrame->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL);
   if ((isBlock && rect.y < aPoint.y) ||
       (!isBlock && ((isRtl  && rect.x + rect.width / 2 > aPoint.x) || 
                     (!isRtl && rect.x + rect.width / 2 < aPoint.x)))) {
     offsets.offset = range.end;
     if (rect.Contains(aPoint))
       offsets.secondaryOffset = range.start;
     else
       offsets.secondaryOffset = range.end;
@@ -3588,17 +3588,17 @@ nsIFrame::ContentOffsets OffsetsForSingl
 }
 
 static nsIFrame* AdjustFrameForSelectionStyles(nsIFrame* aFrame) {
   nsIFrame* adjustedFrame = aFrame;
   for (nsIFrame* frame = aFrame; frame; frame = frame->GetParent())
   {
     // These are the conditions that make all children not able to handle
     // a cursor.
-    if (frame->GetStyleUIReset()->mUserSelect == NS_STYLE_USER_SELECT_ALL ||
+    if (frame->StyleUIReset()->mUserSelect == NS_STYLE_USER_SELECT_ALL ||
         frame->IsGeneratedContentFrame()) {
       adjustedFrame = frame;
     }
   }
   return adjustedFrame;
 }
 
 nsIFrame::ContentOffsets nsIFrame::GetContentOffsetsFromPoint(nsPoint aPoint,
@@ -3614,17 +3614,17 @@ nsIFrame::ContentOffsets nsIFrame::GetCo
     //
     // The offset is forced not to end up in generated content; content offsets
     // cannot represent content outside of the document's content tree.
 
     adjustedFrame = AdjustFrameForSelectionStyles(this);
 
     // -moz-user-select: all needs special handling, because clicking on it
     // should lead to the whole frame being selected
-    if (adjustedFrame && adjustedFrame->GetStyleUIReset()->mUserSelect ==
+    if (adjustedFrame && adjustedFrame->StyleUIReset()->mUserSelect ==
         NS_STYLE_USER_SELECT_ALL) {
       nsPoint adjustedPoint = aPoint + this->GetOffsetTo(adjustedFrame);
       return OffsetsForSingleFrame(adjustedFrame, adjustedPoint);
     }
 
     // For other cases, try to find a closest frame starting from the parent of
     // the unselectable frame
     if (adjustedFrame != this)
@@ -3685,17 +3685,17 @@ nsIFrame::ContentOffsets nsFrame::CalcCo
 {
   return OffsetsForSingleFrame(this, aPoint);
 }
 
 NS_IMETHODIMP
 nsFrame::GetCursor(const nsPoint& aPoint,
                    nsIFrame::Cursor& aCursor)
 {
-  FillCursorInformationFromStyle(GetStyleUserInterface(), aCursor);
+  FillCursorInformationFromStyle(StyleUserInterface(), aCursor);
   if (NS_STYLE_CURSOR_AUTO == aCursor.mCursor) {
     // If this is editable, I-beam cursor is better for most elements.
     aCursor.mCursor =
       (mContent && mContent->IsEditable()) ? NS_STYLE_CURSOR_TEXT :
                                              NS_STYLE_CURSOR_DEFAULT;
   }
 
 
@@ -3743,17 +3743,17 @@ nsFrame::GetPrefWidth(nsRenderingContext
 }
 
 /* virtual */ void
 nsFrame::AddInlineMinWidth(nsRenderingContext *aRenderingContext,
                            nsIFrame::InlineMinWidthData *aData)
 {
   NS_ASSERTION(GetParent(), "Must have a parent if we get here!");
   bool canBreak = !CanContinueTextRun() &&
-    GetParent()->GetStyleText()->WhiteSpaceCanWrap();
+    GetParent()->StyleText()->WhiteSpaceCanWrap();
   
   if (canBreak)
     aData->OptionallyBreak(aRenderingContext);
   aData->trailingWhitespace = 0;
   aData->skipWhitespace = false;
   aData->trailingTextFrame = nullptr;
   aData->currentLine += nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
                             this, nsLayoutUtils::MIN_WIDTH);
@@ -3816,17 +3816,17 @@ nsIFrame::InlinePrefWidthData::ForceBrea
     nscoord floats_done = 0,
             // preferred widths accumulated for floats that have not yet
             // been cleared past
             floats_cur_left = 0,
             floats_cur_right = 0;
 
     for (uint32_t i = 0, i_end = floats.Length(); i != i_end; ++i) {
       const FloatInfo& floatInfo = floats[i];
-      const nsStyleDisplay *floatDisp = floatInfo.Frame()->GetStyleDisplay();
+      const nsStyleDisplay *floatDisp = floatInfo.Frame()->StyleDisplay();
       if (floatDisp->mBreakType == NS_STYLE_CLEAR_LEFT ||
           floatDisp->mBreakType == NS_STYLE_CLEAR_RIGHT ||
           floatDisp->mBreakType == NS_STYLE_CLEAR_LEFT_AND_RIGHT) {
         nscoord floats_cur = NSCoordSaturatingAdd(floats_cur_left,
                                                   floats_cur_right);
         if (floats_cur > floats_done)
           floats_done = floats_cur;
         if (floatDisp->mBreakType != NS_STYLE_CLEAR_RIGHT)
@@ -3899,33 +3899,33 @@ AddCoord(const nsStyleCoord& aStyle,
   }
 }
 
 /* virtual */ nsIFrame::IntrinsicWidthOffsetData
 nsFrame::IntrinsicWidthOffsets(nsRenderingContext* aRenderingContext)
 {
   IntrinsicWidthOffsetData result;
 
-  const nsStyleMargin *styleMargin = GetStyleMargin();
+  const nsStyleMargin *styleMargin = StyleMargin();
   AddCoord(styleMargin->mMargin.GetLeft(), aRenderingContext, this,
            &result.hMargin, &result.hPctMargin, false);
   AddCoord(styleMargin->mMargin.GetRight(), aRenderingContext, this,
            &result.hMargin, &result.hPctMargin, false);
 
-  const nsStylePadding *stylePadding = GetStylePadding();
+  const nsStylePadding *stylePadding = StylePadding();
   AddCoord(stylePadding->mPadding.GetLeft(), aRenderingContext, this,
            &result.hPadding, &result.hPctPadding, true);
   AddCoord(stylePadding->mPadding.GetRight(), aRenderingContext, this,
            &result.hPadding, &result.hPctPadding, true);
 
-  const nsStyleBorder *styleBorder = GetStyleBorder();
+  const nsStyleBorder *styleBorder = StyleBorder();
   result.hBorder += styleBorder->GetComputedBorderWidth(NS_SIDE_LEFT);
   result.hBorder += styleBorder->GetComputedBorderWidth(NS_SIDE_RIGHT);
 
-  const nsStyleDisplay *disp = GetStyleDisplay();
+  const nsStyleDisplay *disp = StyleDisplay();
   if (IsThemed(disp)) {
     nsPresContext *presContext = PresContext();
 
     nsIntMargin border;
     presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
                                              this, disp->mAppearance,
                                              &border);
     result.hBorder = presContext->DevPixelsToAppUnits(border.LeftRight());
@@ -3959,17 +3959,17 @@ nsFrame::ComputeSize(nsRenderingContext 
                      nsSize aCBSize, nscoord aAvailableWidth,
                      nsSize aMargin, nsSize aBorder, nsSize aPadding,
                      uint32_t aFlags)
 {
   nsSize result = ComputeAutoSize(aRenderingContext, aCBSize, aAvailableWidth,
                                   aMargin, aBorder, aPadding,
                                   aFlags & eShrinkWrap);
   nsSize boxSizingAdjust(0,0);
-  const nsStylePosition *stylePos = GetStylePosition();
+  const nsStylePosition *stylePos = StylePosition();
 
   switch (stylePos->mBoxSizing) {
     case NS_STYLE_BOX_SIZING_BORDER:
       boxSizingAdjust += aBorder;
       // fall through
     case NS_STYLE_BOX_SIZING_PADDING:
       boxSizingAdjust += aPadding;
   }
@@ -3982,17 +3982,17 @@ nsFrame::ComputeSize(nsRenderingContext 
   bool isHorizontalFlexItem = false;
  
 #ifdef MOZ_FLEXBOX
   if (isFlexItem) {
     // Flex items use their "flex-basis" property in place of their main-size
     // property (e.g. "width") for sizing purposes, *unless* they have
     // "flex-basis:auto", in which case they use their main-size property after
     // all.
-    uint32_t flexDirection = mParent->GetStylePosition()->mFlexDirection;
+    uint32_t flexDirection = mParent->StylePosition()->mFlexDirection;
     isHorizontalFlexItem =
       flexDirection == NS_STYLE_FLEX_DIRECTION_ROW ||
       flexDirection == NS_STYLE_FLEX_DIRECTION_ROW_REVERSE;
 
     // NOTE: The logic here should match the similar chunk for determining
     // widthStyleCoord and heightStyleCoord in
     // nsLayoutUtils::ComputeSizeWithIntrinsicDimensions().
     const nsStyleCoord* flexBasis = &(stylePos->mFlexBasis);
@@ -4080,17 +4080,17 @@ nsFrame::ComputeSize(nsRenderingContext 
       nscoord minHeight =
         nsLayoutUtils::ComputeHeightValue(aCBSize.height, 
                                           boxSizingAdjust.height, 
                                           stylePos->mMinHeight);
       result.height = std::max(minHeight, result.height);
     }
   }
 
-  const nsStyleDisplay *disp = GetStyleDisplay();
+  const nsStyleDisplay *disp = StyleDisplay();
   if (IsThemed(disp)) {
     nsIntSize widget(0, 0);
     bool canOverride = true;
     nsPresContext *presContext = PresContext();
     presContext->GetTheme()->
       GetMinimumWidgetSize(aRenderingContext, this, disp->mAppearance,
                            &widget, &canOverride);
 
@@ -4118,19 +4118,19 @@ nsRect
 nsIFrame::ComputeTightBounds(gfxContext* aContext) const
 {
   return GetVisualOverflowRect();
 }
 
 nsRect
 nsFrame::ComputeSimpleTightBounds(gfxContext* aContext) const
 {
-  if (GetStyleOutline()->GetOutlineStyle() != NS_STYLE_BORDER_STYLE_NONE ||
-      GetStyleBorder()->HasBorder() || !GetStyleBackground()->IsTransparent() ||
-      GetStyleDisplay()->mAppearance) {
+  if (StyleOutline()->GetOutlineStyle() != NS_STYLE_BORDER_STYLE_NONE ||
+      StyleBorder()->HasBorder() || !StyleBackground()->IsTransparent() ||
+      StyleDisplay()->mAppearance) {
     // Not necessarily tight, due to clipping, negative
     // outline-offset, and lots of other issues, but that's OK
     return GetVisualOverflowRect();
   }
 
   nsRect r(0, 0, 0, 0);
   ChildListIterator lists(this);
   for (; !lists.IsDone(); lists.Next()) {
@@ -4148,17 +4148,17 @@ nsFrame::ComputeAutoSize(nsRenderingCont
                          nsSize aCBSize, nscoord aAvailableWidth,
                          nsSize aMargin, nsSize aBorder, nsSize aPadding,
                          bool aShrinkWrap)
 {
   // Use basic shrink-wrapping as a default implementation.
   nsSize result(0xdeadbeef, NS_UNCONSTRAINEDSIZE);
 
   // don't bother setting it if the result won't be used
-  if (GetStylePosition()->mWidth.GetUnit() == eStyleUnit_Auto) {
+  if (StylePosition()->mWidth.GetUnit() == eStyleUnit_Auto) {
     nscoord availBased = aAvailableWidth - aMargin.width - aBorder.width -
                          aPadding.width;
     result.width = ShrinkWidthToFit(aRenderingContext, availBased);
   }
   return result;
 }
 
 nscoord
@@ -5117,30 +5117,30 @@ ComputeOutlineAndEffectsRect(nsIFrame* a
                              const nsSize& aNewSize,
                              bool aStoreRectProperties) {
   nsRect r = aOverflowRect;
 
   if (aFrame->GetStateBits() & NS_FRAME_SVG_LAYOUT) {
     // For SVG frames, we only need to account for filters.
     // TODO: We could also take account of clipPath and mask to reduce the
     // visual overflow, but that's not essential.
-    if (aFrame->GetStyleSVGReset()->mFilter) {
+    if (aFrame->StyleSVGReset()->mFilter) {
       if (aStoreRectProperties) {
         aFrame->Properties().
           Set(nsIFrame::PreEffectsBBoxProperty(), new nsRect(r));
       }
       r = nsSVGUtils::GetPostFilterVisualOverflowRect(aFrame, aOverflowRect);
     }
     return r;
   }
 
   // box-shadow
   r.UnionRect(r, nsLayoutUtils::GetBoxShadowRectForFrame(aFrame, aNewSize));
 
-  const nsStyleOutline* outline = aFrame->GetStyleOutline();
+  const nsStyleOutline* outline = aFrame->StyleOutline();
   uint8_t outlineStyle = outline->GetOutlineStyle();
   if (outlineStyle != NS_STYLE_BORDER_STYLE_NONE) {
     nscoord width;
 #ifdef DEBUG
     bool result = 
 #endif
       outline->GetOutlineWidth(width);
     NS_ASSERTION(result, "GetOutlineWidth had no cached outline width");
@@ -5168,17 +5168,17 @@ ComputeOutlineAndEffectsRect(nsIFrame* a
   // (1) It's important we not check whether there's a border-image
   //     since the style hint for a change in border image doesn't cause
   //     reflow, and that's probably more important than optimizing the
   //     overflow areas for the silly case of border-image-outset without
   //     border-image
   // (2) It's important that we not check whether the border-image
   //     is actually loaded, since that would require us to reflow when
   //     the image loads.
-  const nsStyleBorder* styleBorder = aFrame->GetStyleBorder();
+  const nsStyleBorder* styleBorder = aFrame->StyleBorder();
   nsMargin outsetMargin = styleBorder->GetImageOutset();
 
   if (outsetMargin != nsMargin(0, 0, 0, 0)) {
     nsRect outsetRect(nsPoint(0, 0), aNewSize);
     outsetRect.Inflate(outsetMargin);
     r.UnionRect(r, outsetRect);
   }
 
@@ -5527,25 +5527,25 @@ nsFrame::XMLQuote(nsString& aString)
       i += 5;
     }
   }
 }
 #endif
 
 bool
 nsIFrame::IsVisibleForPainting(nsDisplayListBuilder* aBuilder) {
-  if (!GetStyleVisibility()->IsVisible())
+  if (!StyleVisibility()->IsVisible())
     return false;
   nsISelection* sel = aBuilder->GetBoundingSelection();
   return !sel || IsVisibleInSelection(sel);
 }
 
 bool
 nsIFrame::IsVisibleForPainting() {
-  if (!GetStyleVisibility()->IsVisible())
+  if (!StyleVisibility()->IsVisible())
     return false;
 
   nsPresContext* pc = PresContext();
   if (!pc->IsRenderingOnlySelection())
     return true;
 
   nsCOMPtr<nsISelectionController> selcon(do_QueryInterface(pc->PresShell()));
   if (selcon) {
@@ -5561,17 +5561,17 @@ nsIFrame::IsVisibleForPainting() {
 bool
 nsIFrame::IsVisibleInSelection(nsDisplayListBuilder* aBuilder) {
   nsISelection* sel = aBuilder->GetBoundingSelection();
   return !sel || IsVisibleInSelection(sel);
 }
 
 bool
 nsIFrame::IsVisibleOrCollapsedForPainting(nsDisplayListBuilder* aBuilder) {
-  if (!GetStyleVisibility()->IsVisibleOrCollapsed())
+  if (!StyleVisibility()->IsVisibleOrCollapsed())
     return false;
   nsISelection* sel = aBuilder->GetBoundingSelection();
   return !sel || IsVisibleInSelection(sel);
 }
 
 bool
 nsIFrame::IsVisibleInSelection(nsISelection* aSelection)
 {
@@ -6074,17 +6074,17 @@ FindBlockFrameOrBR(nsIFrame* aFrame, nsD
     if (result.mContent)
       result.mOffset = result.mContent->IndexOf(content) + 
         (aDirection == eDirPrevious ? 1 : 0);
     return result;
   }
 
   // If this is a preformatted text frame, see if it ends with a newline
   if (aFrame->HasTerminalNewline() &&
-      aFrame->GetStyleText()->NewlineIsSignificant()) {
+      aFrame->StyleText()->NewlineIsSignificant()) {
     int32_t startOffset, endOffset;
     aFrame->GetOffsets(startOffset, endOffset);
     result.mContent = aFrame->GetContent();
     result.mOffset = endOffset - (aDirection == eDirPrevious ? 0 : 1);
     return result;
   }
 
   // Iterate over children and call ourselves recursively
@@ -6234,17 +6234,17 @@ nsIFrame::PeekOffset(nsPeekOffsetStruct*
       aPos->mResultContent = range.content;
       // Output offset is relative to content, not frame
       aPos->mContentOffset = offset < 0 ? range.end : range.start + offset;
       // If we're dealing with a text frame and moving backward positions us at
       // the end of that line, decrease the offset by one to make sure that
       // we're placed before the linefeed character on the previous line.
       if (offset < 0 && jumpedLine &&
           aPos->mDirection == eDirPrevious &&
-          current->GetStyleText()->NewlineIsSignificant() &&
+          current->StyleText()->NewlineIsSignificant() &&
           current->HasTerminalNewline()) {
         --aPos->mContentOffset;
       }
       
       break;
     }
     case eSelectWordNoSpace:
       // eSelectWordNoSpace means that we should not be eating any whitespace when
@@ -6308,17 +6308,17 @@ nsIFrame::PeekOffset(nsPeekOffsetStruct*
           // non-whitespace, and we already encountered non-whitespace.
           if (NS_FAILED(result) ||
               (jumpedLine && !wordSelectEatSpace && state.mSawBeforeType)) {
             done = true;
             // If we've crossed the line boundary, check to make sure that we
             // have not consumed a trailing newline as whitesapce if it's significant.
             if (jumpedLine && wordSelectEatSpace &&
                 current->HasTerminalNewline() &&
-                current->GetStyleText()->NewlineIsSignificant()) {
+                current->StyleText()->NewlineIsSignificant()) {
               offsetAdjustment = -1;
             }
           } else {
             if (jumpedLine) {
               state.mContext.Truncate();
             }
             current = nextFrame;
             offset = nextFrameOffset;
@@ -6946,17 +6946,17 @@ nsIFrame::FinishAndStoreOverflow(nsOverf
                  r->Contains(nsRect(nsPoint(0,0), aNewSize)),
                  "Computed overflow area must contain frame bounds");
   }
 
   // If we clip our children, clear accumulated overflow area. The
   // children are actually clipped to the padding-box, but since the
   // overflow area should include the entire border-box, just set it to
   // the border-box here.
-  const nsStyleDisplay* disp = GetStyleDisplay();
+  const nsStyleDisplay* disp = StyleDisplay();
   NS_ASSERTION((disp->mOverflowY == NS_STYLE_OVERFLOW_CLIP) ==
                (disp->mOverflowX == NS_STYLE_OVERFLOW_CLIP),
                "If one overflow is clip, the other should be too");
   if (nsFrame::ApplyOverflowClipping(this, disp)) {
     // The contents are actually clipped to the padding area 
     aOverflowAreas.SetAllTo(bounds);
   }
 
@@ -7423,17 +7423,17 @@ nsIFrame::IsFocusable(int32_t *aTabIndex
 {
   int32_t tabIndex = -1;
   if (aTabIndex) {
     *aTabIndex = -1; // Default for early return is not focusable
   }
   bool isFocusable = false;
 
   if (mContent && mContent->IsElement() && IsVisibleConsideringAncestors()) {
-    const nsStyleUserInterface* ui = GetStyleUserInterface();
+    const nsStyleUserInterface* ui = StyleUserInterface();
     if (ui->mUserFocus != NS_STYLE_USER_FOCUS_IGNORE &&
         ui->mUserFocus != NS_STYLE_USER_FOCUS_NONE) {
       // Pass in default tabindex of -1 for nonfocusable and 0 for focusable
       tabIndex = 0;
     }
     isFocusable = mContent->IsFocusable(&tabIndex, aWithMouse);
     if (!isFocusable && !aWithMouse &&
         GetType() == nsGkAtoms::scrollFrame &&
@@ -7507,26 +7507,26 @@ ConvertSVGDominantBaselineToVerticalAlig
 }
 
 uint8_t
 nsIFrame::VerticalAlignEnum() const
 {
   if (mState & NS_FRAME_IS_SVG_TEXT) {
     uint8_t dominantBaseline;
     for (const nsIFrame* frame = this; frame; frame = frame->GetParent()) {
-      dominantBaseline = frame->GetStyleSVGReset()->mDominantBaseline;
+      dominantBaseline = frame->StyleSVGReset()->mDominantBaseline;
       if (dominantBaseline != NS_STYLE_DOMINANT_BASELINE_AUTO ||
           frame->GetType() == nsGkAtoms::svgTextFrame) {
         break;
       }
     }
     return ConvertSVGDominantBaselineToVerticalAlign(dominantBaseline);
   }
 
-  const nsStyleCoord& verticalAlign = GetStyleTextReset()->mVerticalAlign;
+  const nsStyleCoord& verticalAlign = StyleTextReset()->mVerticalAlign;
   if (verticalAlign.GetUnit() == eStyleUnit_Enumerated) {
     return verticalAlign.GetIntValue();
   }
 
   return eInvalidVerticalAlign;
 }
 
 /* static */
diff --git a/layout/generic/nsFrame.h b/layout/generic/nsFrame.h
--- a/layout/generic/nsFrame.h
+++ b/layout/generic/nsFrame.h
@@ -276,17 +276,17 @@ public:
    * that should be returned when 'width', 'height', and
    * min/max-width/height are all 'auto' or equivalent.
    *
    * In general, frames that can accept any computed width/height should
    * override only ComputeAutoSize, and frames that cannot do so need to
    * override ComputeSize to enforce their width/height invariants.
    *
    * Implementations may optimize by returning a garbage width if
-   * GetStylePosition()->mWidth.GetUnit() != eStyleUnit_Auto, and
+   * StylePosition()->mWidth.GetUnit() != eStyleUnit_Auto, and
    * likewise for height, since in such cases the result is guaranteed
    * to be unused.
    */
   virtual nsSize ComputeAutoSize(nsRenderingContext *aRenderingContext,
                                  nsSize aCBSize, nscoord aAvailableWidth,
                                  nsSize aMargin, nsSize aBorder,
                                  nsSize aPadding, bool aShrinkWrap);
 
@@ -408,17 +408,17 @@ public:
   virtual const void* GetStyleDataExternal(nsStyleStructID aSID) const;
 
 
   /**
    * @return true if we should avoid a page/column break in this frame.
    */
   bool ShouldAvoidBreakInside(const nsHTMLReflowState& aReflowState) const {
     return !aReflowState.mFlags.mIsTopOfPage &&
-           NS_STYLE_PAGE_BREAK_AVOID == GetStyleDisplay()->mBreakInside &&
+           NS_STYLE_PAGE_BREAK_AVOID == StyleDisplay()->mBreakInside &&
            !GetPrevInFlow();
   }
 
 #ifdef DEBUG
   /**
    * Tracing method that writes a method enter/exit routine to the
    * nspr log using the nsIFrame log module. The tracing is only
    * done when the NS_FRAME_TRACE_CALLS bit is set in the log module's
diff --git a/layout/generic/nsFrameSetFrame.cpp b/layout/generic/nsFrameSetFrame.cpp
--- a/layout/generic/nsFrameSetFrame.cpp
+++ b/layout/generic/nsFrameSetFrame.cpp
@@ -1431,17 +1431,17 @@ nsHTMLFramesetFrame::EndMouseDrag(nsPres
   mDragger = nullptr;
   gDragInProgress = false;
 }
 
 nsIFrame*
 NS_NewHTMLFramesetFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 {
 #ifdef DEBUG
-  const nsStyleDisplay* disp = aContext->GetStyleDisplay();
+  const nsStyleDisplay* disp = aContext->StyleDisplay();
   NS_ASSERTION(!disp->IsAbsolutelyPositionedStyle() && !disp->IsFloatingStyle(),
                "Framesets should not be positioned and should not float");
 #endif
 
   return new (aPresShell) nsHTMLFramesetFrame(aContext);
 }
 
 NS_IMPL_FRAMEARENA_HELPERS(nsHTMLFramesetFrame)
diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -2155,17 +2155,17 @@ nsGfxScrollFrameInner::GetScrollbarStyle
 {
   nsPresContext* presContext = mOuter->PresContext();
   if (!presContext->IsDynamic() &&
       !(mIsRoot && presContext->HasPaginatedScrolling())) {
     return ScrollbarStyles(NS_STYLE_OVERFLOW_HIDDEN, NS_STYLE_OVERFLOW_HIDDEN);
   }
 
   if (!mIsRoot) {
-    const nsStyleDisplay* disp = mOuter->GetStyleDisplay();
+    const nsStyleDisplay* disp = mOuter->StyleDisplay();
     return ScrollbarStyles(disp->mOverflowX, disp->mOverflowY);
   }
 
   ScrollbarStyles result = presContext->GetViewportOverflowOverride();
   nsCOMPtr<nsISupports> container = presContext->GetContainer();
   nsCOMPtr<nsIScrollable> scrollable = do_QueryInterface(container);
   if (scrollable) {
     HandleScrollPref(scrollable, nsIScrollable::ScrollOrientation_X,
@@ -2602,17 +2602,17 @@ nsGfxScrollFrameInner::CreateAnonymousCo
   if (presContext->Document()->IsBeingUsedAsImage() ||
       (!presContext->IsDynamic() &&
        !(mIsRoot && presContext->HasPaginatedScrolling()))) {
     mNeverHasVerticalScrollbar = mNeverHasHorizontalScrollbar = true;
     return NS_OK;
   }
 
   // Check if the frame is resizable.
-  int8_t resizeStyle = mOuter->GetStyleDisplay()->mResize;
+  int8_t resizeStyle = mOuter->StyleDisplay()->mResize;
   bool isResizable = resizeStyle != NS_STYLE_RESIZE_NONE;
 
   nsIScrollableFrame *scrollable = do_QueryFrame(mOuter);
 
   // If we're the scrollframe for the root, then we want to construct
   // our scrollbar frames no matter what.  That way later dynamic
   // changes to propagated overflow styles will show or hide
   // scrollbars on the viewport without requiring frame reconstruction
@@ -3104,17 +3104,17 @@ nsGfxScrollFrameInner::IsLTR() const
 
     if (root) {
       nsIFrame *rootsFrame = root->GetPrimaryFrame();
       if (rootsFrame)
         frame = rootsFrame;
     }
   }
 
-  return frame->GetStyleVisibility()->mDirection != NS_STYLE_DIRECTION_RTL;
+  return frame->StyleVisibility()->mDirection != NS_STYLE_DIRECTION_RTL;
 }
 
 bool
 nsGfxScrollFrameInner::IsScrollbarOnRight() const
 {
   nsPresContext *presContext = mOuter->PresContext();
 
   // The position of the scrollbar in top-level windows depends on the pref
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -99,17 +99,17 @@ static bool CheckNextInFlowParenthood(ns
  * bullets to be rendered with font inflation enabled.
  */
 static  nscoord
 FontSizeInflationListMarginAdjustment(const nsIFrame* aFrame)
 {
   float inflation = nsLayoutUtils::FontSizeInflationFor(aFrame);
   if (aFrame->IsFrameOfType(nsIFrame::eBlockFrame)) {
     const nsBlockFrame* blockFrame = static_cast<const nsBlockFrame*>(aFrame);
-    const nsStyleList* styleList = aFrame->GetStyleList();
+    const nsStyleList* styleList = aFrame->StyleList();
 
     // We only want to adjust the margins if we're dealing with an ordered
     // list.
     if (inflation > 1.0f &&
         blockFrame->HasBullet() &&
         styleList->mListStyleType != NS_STYLE_LIST_STYLE_NONE &&
         styleList->mListStyleType != NS_STYLE_LIST_STYLE_DISC &&
         styleList->mListStyleType != NS_STYLE_LIST_STYLE_CIRCLE &&
@@ -295,39 +295,39 @@ nsHTMLReflowState::Init(nsPresContext* a
                         const nsMargin* aBorder,
                         const nsMargin* aPadding)
 {
   NS_WARN_IF_FALSE(availableWidth != NS_UNCONSTRAINEDSIZE,
                    "have unconstrained width; this should only result from "
                    "very large sizes, not attempts at intrinsic width "
                    "calculation");
 
-  mStylePosition = frame->GetStylePosition();
-  mStyleDisplay = frame->GetStyleDisplay();
-  mStyleVisibility = frame->GetStyleVisibility();
-  mStyleBorder = frame->GetStyleBorder();
-  mStyleMargin = frame->GetStyleMargin();
-  mStylePadding = frame->GetStylePadding();
-  mStyleText = frame->GetStyleText();
+  mStylePosition = frame->StylePosition();
+  mStyleDisplay = frame->StyleDisplay();
+  mStyleVisibility = frame->StyleVisibility();
+  mStyleBorder = frame->StyleBorder();
+  mStyleMargin = frame->StyleMargin();
+  mStylePadding = frame->StylePadding();
+  mStyleText = frame->StyleText();
 
   nsIAtom* type = frame->GetType();
 
   InitFrameType(type);
   InitCBReflowState();
 
   InitConstraints(aPresContext, aContainingBlockWidth, aContainingBlockHeight,
                   aBorder, aPadding, type);
 
   InitResizeFlags(aPresContext, type);
 
   nsIFrame *parent = frame->GetParent();
   if (parent &&
       (parent->GetStateBits() & NS_FRAME_IN_CONSTRAINED_HEIGHT) &&
       !(parent->GetType() == nsGkAtoms::scrollFrame &&
-        parent->GetStyleDisplay()->mOverflowY != NS_STYLE_OVERFLOW_HIDDEN)) {
+        parent->StyleDisplay()->mOverflowY != NS_STYLE_OVERFLOW_HIDDEN)) {
     frame->AddStateBits(NS_FRAME_IN_CONSTRAINED_HEIGHT);
   } else if (type == nsGkAtoms::svgForeignObjectFrame) {
     // An SVG foreignObject frame is inherently constrained height.
     frame->AddStateBits(NS_FRAME_IN_CONSTRAINED_HEIGHT);
   } else if ((mStylePosition->mHeight.GetUnit() != eStyleUnit_Auto ||
               mStylePosition->mMaxHeight.GetUnit() != eStyleUnit_None) &&
               // Don't set NS_FRAME_IN_CONSTRAINED_HEIGHT on body or html
               // elements.
@@ -335,17 +335,17 @@ nsHTMLReflowState::Init(nsPresContext* a
             !(frame->GetContent()->IsHTML(nsGkAtoms::body) ||
               frame->GetContent()->IsHTML(nsGkAtoms::html)))) {
 
     // If our height was specified as a percentage, then this could
     // actually resolve to 'auto', based on:
     // http://www.w3.org/TR/CSS21/visudet.html#the-height-property
     nsIFrame* containingBlk = frame;
     while (containingBlk) {
-      const nsStylePosition* stylePos = containingBlk->GetStylePosition();
+      const nsStylePosition* stylePos = containingBlk->StylePosition();
       if ((stylePos->mHeight.IsCoordPercentCalcUnit() &&
            !stylePos->mHeight.HasPercent()) ||
           (stylePos->mMaxHeight.IsCoordPercentCalcUnit() &&
            !stylePos->mMaxHeight.HasPercent())) {
         frame->AddStateBits(NS_FRAME_IN_CONSTRAINED_HEIGHT);
         break;
       } else if ((stylePos->mHeight.IsCoordPercentCalcUnit() &&
                   stylePos->mHeight.HasPercent()) ||
@@ -657,20 +657,20 @@ nsHTMLReflowState::InitFrameType(nsIAtom
 
   DISPLAY_INIT_TYPE(frame, this);
 
   if (aFrameType == nsGkAtoms::tableFrame) {
     mFrameType = NS_CSS_FRAME_TYPE_BLOCK;
     return;
   }
 
-  NS_ASSERTION(frame->GetStyleDisplay()->IsAbsolutelyPositionedStyle() ==
+  NS_ASSERTION(frame->StyleDisplay()->IsAbsolutelyPositionedStyle() ==
                  disp->IsAbsolutelyPositionedStyle(),
                "Unexpected position style");
-  NS_ASSERTION(frame->GetStyleDisplay()->IsFloatingStyle() ==
+  NS_ASSERTION(frame->StyleDisplay()->IsFloatingStyle() ==
                  disp->IsFloatingStyle(), "Unexpected float style");
   if (frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
     if (disp->IsAbsolutelyPositioned(frame)) {
       frameType = NS_CSS_FRAME_TYPE_ABSOLUTE;
       //XXXfr hack for making frames behave properly when in overflow container lists
       //      see bug 154892; need to revisit later
       if (frame->GetPrevInFlow())
         frameType = NS_CSS_FRAME_TYPE_BLOCK;
@@ -736,17 +736,17 @@ nsHTMLReflowState::InitFrameType(nsIAtom
 
 /* static */ void
 nsHTMLReflowState::ComputeRelativeOffsets(uint8_t aCBDirection,
                                           nsIFrame* aFrame,
                                           nscoord aContainingBlockWidth,
                                           nscoord aContainingBlockHeight,
                                           nsMargin& aComputedOffsets)
 {
-  const nsStylePosition* position = aFrame->GetStylePosition();
+  const nsStylePosition* position = aFrame->StylePosition();
 
   // Compute the 'left' and 'right' values. 'Left' moves the boxes to the right,
   // and 'right' moves the boxes to the left. The computed values are always:
   // left=-right
   bool    leftIsAuto = eStyleUnit_Auto == position->mOffset.GetLeftUnit();
   bool    rightIsAuto = eStyleUnit_Auto == position->mOffset.GetRightUnit();
 
   // If neither 'left' not 'right' are auto, then we're over-constrained and
@@ -1081,17 +1081,17 @@ nsHTMLReflowState::CalculateHypothetical
                                    insideBoxSizing, outsideBoxSizing,
                                    mStylePosition->mWidth) + 
                  insideBoxSizing + outsideBoxSizing;
       knowBoxWidth = true;
     }
   }
   
   // Get the 'direction' of the block
-  const nsStyleVisibility* blockVis = aContainingBlock->GetStyleVisibility();
+  const nsStyleVisibility* blockVis = aContainingBlock->StyleVisibility();
 
   // Get the placeholder x-offset and y-offset in the coordinate
   // space of its containing block
   // XXXbz the placeholder is not fully reflowed yet if our containing block is
   // relatively positioned...
   nsPoint placeholderOffset = aPlaceholderFrame->GetOffsetTo(aContainingBlock);
 
   // First, determine the hypothetical box's mTop.  We want to check the
@@ -1322,17 +1322,17 @@ nsHTMLReflowState::InitAbsoluteConstrain
   }
 
   // Use the horizontal component of the hypothetical box in the cases
   // where it's needed.
   if (leftIsAuto && rightIsAuto) {
     // Use the direction of the original ("static-position") containing block
     // to dictate whether 'left' or 'right' is treated like 'static-position'.
     if (NS_STYLE_DIRECTION_LTR == placeholderFrame->GetContainingBlock()
-                                    ->GetStyleVisibility()->mDirection) {
+                                    ->StyleVisibility()->mDirection) {
       NS_ASSERTION(hypotheticalBox.mLeftIsExact, "should always have "
                    "exact value on containing block's start side");
       mComputedOffsets.left = hypotheticalBox.mLeft;
       leftIsAuto = false;
     } else {
       NS_ASSERTION(hypotheticalBox.mRightIsExact, "should always have "
                    "exact value on containing block's start side");
       mComputedOffsets.right = containingBlockWidth - hypotheticalBox.mRight;
@@ -1797,17 +1797,17 @@ static eNormalLineHeightControl GetNorma
   return sNormalLineHeightControl;
 }
 
 static inline bool
 IsSideCaption(nsIFrame* aFrame, const nsStyleDisplay* aStyleDisplay)
 {
   if (aStyleDisplay->mDisplay != NS_STYLE_DISPLAY_TABLE_CAPTION)
     return false;
-  uint8_t captionSide = aFrame->GetStyleTableBorder()->mCaptionSide;
+  uint8_t captionSide = aFrame->StyleTableBorder()->mCaptionSide;
   return captionSide == NS_STYLE_CAPTION_SIDE_LEFT ||
          captionSide == NS_STYLE_CAPTION_SIDE_RIGHT;
 }
 
 #ifdef MOZ_FLEXBOX
 static nsFlexContainerFrame*
 GetFlexContainer(nsIFrame* aFrame)
 {
@@ -2081,17 +2081,17 @@ nsHTMLReflowState::InitConstraints(nsPre
 #endif // MOZ_FLEXBOX
           )
         CalculateBlockSideMargins(availableWidth, mComputedWidth, aFrameType);
     }
   }
   // Check for blinking text and permission to display it
   mFlags.mBlinks = (parentReflowState && parentReflowState->mFlags.mBlinks);
   if (!mFlags.mBlinks && BlinkIsAllowed()) {
-    const nsStyleTextReset* st = frame->GetStyleTextReset();
+    const nsStyleTextReset* st = frame->StyleTextReset();
     mFlags.mBlinks = (st->mTextBlink != NS_STYLE_TEXT_BLINK_NONE);
   }
 }
 
 static void
 UpdateProp(FrameProperties& aProps,
            const FramePropertyDescriptor* aProperty,
            bool aNeeded,
@@ -2131,17 +2131,17 @@ nsCSSOffsetState::InitOffsets(nscoord aC
   // XXX We need to include 'auto' horizontal margins in this too!
   // ... but if we did that, we'd need to fix nsFrame::GetUsedMargin
   // to use it even when the margins are all zero (since sometimes
   // they get treated as auto)
   ::UpdateProp(props, nsIFrame::UsedMarginProperty(), needMarginProp,
                mComputedMargin);
 
 
-  const nsStyleDisplay *disp = frame->GetStyleDisplay();
+  const nsStyleDisplay *disp = frame->StyleDisplay();
   bool isThemed = frame->IsThemed(disp);
   bool needPaddingProp;
   nsIntMargin widget;
   if (isThemed &&
       presContext->GetTheme()->GetWidgetPadding(presContext->DeviceContext(),
                                                 frame, disp->mAppearance,
                                                 &widget)) {
     mComputedPadding.top = presContext->DevPixelsToAppUnits(widget.top);
@@ -2151,17 +2151,17 @@ nsCSSOffsetState::InitOffsets(nscoord aC
     needPaddingProp = false;
   }
   else if (frame->GetStateBits() & NS_FRAME_IS_SVG_TEXT) {
     mComputedPadding.SizeTo(0, 0, 0, 0);
     needPaddingProp = false;
   }
   else if (aPadding) { // padding is an input arg
     mComputedPadding = *aPadding;
-    needPaddingProp = frame->GetStylePadding()->IsWidthDependent();
+    needPaddingProp = frame->StylePadding()->IsWidthDependent();
   }
   else {
     needPaddingProp = ComputePadding(aContainingBlockWidth, aFrameType);
   }
 
   if (isThemed) {
     nsIntMargin widget;
     presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
@@ -2178,17 +2178,17 @@ nsCSSOffsetState::InitOffsets(nscoord aC
   }
   else if (frame->GetStateBits() & NS_FRAME_IS_SVG_TEXT) {
     mComputedBorderPadding.SizeTo(0, 0, 0, 0);
   }
   else if (aBorder) {  // border is an input arg
     mComputedBorderPadding = *aBorder;
   }
   else {
-    mComputedBorderPadding = frame->GetStyleBorder()->GetComputedBorder();
+    mComputedBorderPadding = frame->StyleBorder()->GetComputedBorder();
   }
   mComputedBorderPadding += mComputedPadding;
 
   if (aFrameType == nsGkAtoms::tableFrame) {
     nsTableFrame *tableFrame = static_cast<nsTableFrame*>(frame);
 
     if (tableFrame->IsBorderCollapse()) {
       // border-collapsed tables don't use any of their padding, and
@@ -2351,32 +2351,32 @@ GetNormalLineHeight(nsFontMetrics* aFont
   return normalLineHeight;
 }
 
 static inline nscoord
 ComputeLineHeight(nsStyleContext* aStyleContext,
                   nscoord aBlockHeight,
                   float aFontSizeInflation)
 {
-  const nsStyleCoord& lhCoord = aStyleContext->GetStyleText()->mLineHeight;
+  const nsStyleCoord& lhCoord = aStyleContext->StyleText()->mLineHeight;
 
   if (lhCoord.GetUnit() == eStyleUnit_Coord) {
     nscoord result = lhCoord.GetCoordValue();
     if (aFontSizeInflation != 1.0f) {
       result = NSToCoordRound(result * aFontSizeInflation);
     }
     return result;
   }
 
   if (lhCoord.GetUnit() == eStyleUnit_Factor)
     // For factor units the computed value of the line-height property 
     // is found by multiplying the factor by the font's computed size
     // (adjusted for min-size prefs and text zoom).
     return NSToCoordRound(lhCoord.GetFactorValue() * aFontSizeInflation *
-                          aStyleContext->GetStyleFont()->mFont.size);
+                          aStyleContext->StyleFont()->mFont.size);
 
   NS_ASSERTION(lhCoord.GetUnit() == eStyleUnit_Normal ||
                lhCoord.GetUnit() == eStyleUnit_Enumerated,
                "bad line-height unit");
   
   if (lhCoord.GetUnit() == eStyleUnit_Enumerated) {
     NS_ASSERTION(lhCoord.GetIntValue() == NS_STYLE_LINE_HEIGHT_BLOCK_HEIGHT,
                  "bad line-height value");
@@ -2422,17 +2422,17 @@ bool
 nsCSSOffsetState::ComputeMargin(nscoord aContainingBlockWidth)
 {
   // SVG text frames have no margin.
   if (frame->GetStateBits() & NS_FRAME_IS_SVG_TEXT) {
     return false;
   }
 
   // If style style can provide us the margin directly, then use it.
-  const nsStyleMargin *styleMargin = frame->GetStyleMargin();
+  const nsStyleMargin *styleMargin = frame->StyleMargin();
   bool isWidthDependent = !styleMargin->GetMargin(mComputedMargin);
   if (isWidthDependent) {
     // We have to compute the value
     mComputedMargin.left = nsLayoutUtils::
       ComputeWidthDependentValue(aContainingBlockWidth,
                                  styleMargin->mMargin.GetLeft());
     mComputedMargin.right = nsLayoutUtils::
       ComputeWidthDependentValue(aContainingBlockWidth,
@@ -2448,32 +2448,32 @@ nsCSSOffsetState::ComputeMargin(nscoord 
     mComputedMargin.bottom = nsLayoutUtils::
       ComputeWidthDependentValue(aContainingBlockWidth,
                                  styleMargin->mMargin.GetBottom());
   }
 
   nscoord marginAdjustment = FontSizeInflationListMarginAdjustment(frame);
 
   if (marginAdjustment > 0) {
-    const nsStyleVisibility* visibility = frame->GetStyleVisibility();
+    const nsStyleVisibility* visibility = frame->StyleVisibility();
     if (visibility->mDirection == NS_STYLE_DIRECTION_RTL) {
       mComputedMargin.right = mComputedMargin.right + marginAdjustment;
     } else {
       mComputedMargin.left = mComputedMargin.left + marginAdjustment;
     }
   }
 
   return isWidthDependent;
 }
 
 bool
 nsCSSOffsetState::ComputePadding(nscoord aContainingBlockWidth, nsIAtom* aFrameType)
 {
   // If style can provide us the padding directly, then use it.
-  const nsStylePadding *stylePadding = frame->GetStylePadding();
+  const nsStylePadding *stylePadding = frame->StylePadding();
   bool isWidthDependent = !stylePadding->GetPadding(mComputedPadding);
   // a table row/col group, row/col doesn't have padding
   // XXXldb Neither do border-collapse tables.
   if (nsGkAtoms::tableRowGroupFrame == aFrameType ||
       nsGkAtoms::tableColGroupFrame == aFrameType ||
       nsGkAtoms::tableRowFrame      == aFrameType ||
       nsGkAtoms::tableColFrame      == aFrameType) {
     mComputedPadding.SizeTo(0,0,0,0);
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -784,18 +784,18 @@ public:
    * of this function.
    */
   virtual const void* GetStyleDataExternal(nsStyleStructID aSID) const = 0;
 
   /**
    * Define typesafe getter functions for each style struct by
    * preprocessing the list of style structs.  These functions are the
    * preferred way to get style data.  The macro creates functions like:
-   *   const nsStyleBorder* GetStyleBorder();
-   *   const nsStyleColor* GetStyleColor();
+   *   const nsStyleBorder* StyleBorder();
+   *   const nsStyleColor* StyleColor();
    */
 
 #ifdef _IMPL_NS_LAYOUT
   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)                      \
     const nsStyle##name_ * GetStyle##name_ () const {                         \
       NS_ASSERTION(mStyleContext, "No style context found!");                 \
       return mStyleContext->GetStyle##name_ ();                               \
     }
@@ -972,19 +972,19 @@ public:
    */
   virtual nsMargin GetUsedMargin() const;
 
   /**
    * Return the distance between the border edge of the frame (which is
    * its rect) and the padding edge of the frame. Like GetRect(), returns
    * the dimensions as of the most recent reflow.
    *
-   * Note that this differs from GetStyleBorder()->GetBorder() in that
+   * Note that this differs from StyleBorder()->GetBorder() in that
    * this describes region of the frame's box, and
-   * GetStyleBorder()->GetBorder() describes a border.  They differ only
+   * StyleBorder()->GetBorder() describes a border.  They differ only
    * for tables, particularly border-collapse tables.
    */
   virtual nsMargin GetUsedBorder() const;
 
   /**
    * Return the distance between the padding edge of the frame and the
    * content edge of the frame.  Like GetRect(), returns the dimensions
    * as of the most recent reflow.
@@ -1173,17 +1173,17 @@ public:
    * Get the preferred caret color at the offset.
    *
    * @param aOffset is offset of the content.
    */
   virtual nscolor GetCaretColorAt(int32_t aOffset);
 
  
   bool IsThemed(nsITheme::Transparency* aTransparencyState = nullptr) const {
-    return IsThemed(GetStyleDisplay(), aTransparencyState);
+    return IsThemed(StyleDisplay(), aTransparencyState);
   }
   bool IsThemed(const nsStyleDisplay* aDisp,
                   nsITheme::Transparency* aTransparencyState = nullptr) const {
     nsIFrame* mutable_this = const_cast<nsIFrame*>(this);
     if (!aDisp->mAppearance)
       return false;
     nsPresContext* pc = PresContext();
     nsITheme *theme = pc->GetTheme();
@@ -2568,17 +2568,17 @@ public:
 
   /**
    * Determines whether this frame is a pseudo stacking context, looking
    * only as style --- i.e., assuming that it's in-flow and not a replaced
    * element and not an SVG element.
    * XXX maybe check IsTransformed()?
    */
   bool IsPseudoStackingContextFromStyle() {
-    const nsStyleDisplay* disp = GetStyleDisplay();
+    const nsStyleDisplay* disp = StyleDisplay();
     return disp->mOpacity != 1.0f ||
            disp->IsPositioned(this) ||
            disp->IsFloating(this);
   }
   
   virtual bool HonorPrintBackgroundSettings() { return true; }
 
   /**
@@ -3260,54 +3260,54 @@ FrameLinkEnumerator(const nsFrameList& a
   mFrame = aPrevFrame ? aPrevFrame->GetNextSibling() : aList.FirstChild();
 }
 
 #include "nsStyleStructInlines.h"
 
 bool
 nsIFrame::IsFloating() const
 {
-  return GetStyleDisplay()->IsFloating(this);
+  return StyleDisplay()->IsFloating(this);
 }
 
 bool
 nsIFrame::IsPositioned() const
 {
-  return GetStyleDisplay()->IsPositioned(this);
+  return StyleDisplay()->IsPositioned(this);
 }
 
 bool
 nsIFrame::IsRelativelyPositioned() const
 {
-  return GetStyleDisplay()->IsRelativelyPositioned(this);
+  return StyleDisplay()->IsRelativelyPositioned(this);
 }
 
 bool
 nsIFrame::IsAbsolutelyPositioned() const
 {
-  return GetStyleDisplay()->IsAbsolutelyPositioned(this);
+  return StyleDisplay()->IsAbsolutelyPositioned(this);
 }
 
 bool
 nsIFrame::IsBlockInside() const
 {
-  return GetStyleDisplay()->IsBlockInside(this);
+  return StyleDisplay()->IsBlockInside(this);
 }
 
 bool
 nsIFrame::IsBlockOutside() const
 {
-  return GetStyleDisplay()->IsBlockOutside(this);
+  return StyleDisplay()->IsBlockOutside(this);
 }
 
 bool
 nsIFrame::IsInlineOutside() const
 {
-  return GetStyleDisplay()->IsInlineOutside(this);
+  return StyleDisplay()->IsInlineOutside(this);
 }
 
 uint8_t
 nsIFrame::GetDisplay() const
 {
-  return GetStyleDisplay()->GetDisplay(this);
+  return StyleDisplay()->GetDisplay(this);
 }
 
 #endif /* nsIFrame_h___ */
diff --git a/layout/generic/nsImageFrame.cpp b/layout/generic/nsImageFrame.cpp
--- a/layout/generic/nsImageFrame.cpp
+++ b/layout/generic/nsImageFrame.cpp
@@ -463,17 +463,17 @@ nsImageFrame::SourceRectToDest(const nsI
 
 /* static */
 bool
 nsImageFrame::ShouldCreateImageFrameFor(Element* aElement,
                                         nsStyleContext* aStyleContext)
 {
   nsEventStates state = aElement->State();
   if (IMAGE_OK(state,
-               HaveFixedSize(aStyleContext->GetStylePosition()))) {
+               HaveFixedSize(aStyleContext->StylePosition()))) {
     // Image is fine; do the image frame thing
     return true;
   }
 
   // Check if we want to use a placeholder box with an icon or just
   // let the presShell make us into inline text.  Decide as follows:
   //
   //  - if our special "force icons" style is set, show an icon
@@ -481,17 +481,17 @@ nsImageFrame::ShouldCreateImageFrameFor(
   //  - else:
   //  - if QuirksMode, and there is no alt attribute, and this is not an
   //    <object> (which could not possibly have such an attribute), show an
   //    icon.
   //  - if QuirksMode, and the IMG has a size show an icon.
   //  - otherwise, skip the icon
   bool useSizedBox;
   
-  if (aStyleContext->GetStyleUIReset()->mForceBrokenImageIcon) {
+  if (aStyleContext->StyleUIReset()->mForceBrokenImageIcon) {
     useSizedBox = true;
   }
   else if (gIconLoad && gIconLoad->mPrefForceInlineAltText) {
     useSizedBox = false;
   }
   else {
     if (aStyleContext->PresContext()->CompatibilityMode() !=
         eCompatibility_NavQuirks) {
@@ -507,17 +507,17 @@ nsImageFrame::ShouldCreateImageFrameFor(
       // text).
       if (!aElement->HasAttr(kNameSpaceID_None, nsGkAtoms::alt) &&
           localName != nsGkAtoms::object &&
           localName != nsGkAtoms::input) {
         useSizedBox = true;
       }
       else {
         // check whether we have fixed size
-        useSizedBox = HaveFixedSize(aStyleContext->GetStylePosition());
+        useSizedBox = HaveFixedSize(aStyleContext->StylePosition());
       }
     }
   }
   
   return useSizedBox;
 }
 
 nsresult
@@ -685,17 +685,17 @@ nsImageFrame::NotifyNewCurrentRequest(im
     InvalidateFrame();
   }
 }
 
 nsresult
 nsImageFrame::FrameChanged(imgIRequest *aRequest,
                            imgIContainer *aContainer)
 {
-  if (!GetStyleVisibility()->IsVisible()) {
+  if (!StyleVisibility()->IsVisible()) {
     return NS_OK;
   }
 
   if (IsPendingLoad(aContainer)) {
     // We don't care about it
     return NS_OK;
   }
 
@@ -990,17 +990,17 @@ nsImageFrame::MeasureString(const PRUnic
 // between words if a word would extend past the edge of the rectangle
 void
 nsImageFrame::DisplayAltText(nsPresContext*      aPresContext,
                              nsRenderingContext& aRenderingContext,
                              const nsString&      aAltText,
                              const nsRect&        aRect)
 {
   // Set font and color
-  aRenderingContext.SetColor(GetStyleColor()->mColor);
+  aRenderingContext.SetColor(StyleColor()->mColor);
   nsRefPtr<nsFontMetrics> fm;
   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm),
     nsLayoutUtils::FontSizeInflationFor(this));
   aRenderingContext.SetFont(fm);
 
   // Format the text to display within the formatting rect
 
   nscoord maxAscent = fm->MaxAscent();
@@ -1025,17 +1025,17 @@ nsImageFrame::DisplayAltText(nsPresConte
     uint32_t  maxFit;  // number of characters that fit
     nscoord strWidth = MeasureString(str, strLen, aRect.width, maxFit,
                                      aRenderingContext);
     
     // Display the text
     nsresult rv = NS_ERROR_FAILURE;
 
     if (aPresContext->BidiEnabled()) {
-      const nsStyleVisibility* vis = GetStyleVisibility();
+      const nsStyleVisibility* vis = StyleVisibility();
       if (vis->mDirection == NS_STYLE_DIRECTION_RTL)
         rv = nsBidiPresUtils::RenderText(str, maxFit, NSBIDI_RTL,
                                          aPresContext, aRenderingContext,
                                          aRenderingContext,
                                          aRect.XMost() - strWidth, y + maxAscent);
       else
         rv = nsBidiPresUtils::RenderText(str, maxFit, NSBIDI_LTR,
                                          aPresContext, aRenderingContext,
@@ -1138,17 +1138,17 @@ nsImageFrame::DisplayAltFeedback(nsRende
   }
 
   // Clip so we don't render outside the inner rect
   aRenderingContext.PushState();
   aRenderingContext.IntersectClip(inner);
 
   // Check if we should display image placeholders
   if (gIconLoad->mPrefShowPlaceholders) {
-    const nsStyleVisibility* vis = GetStyleVisibility();
+    const nsStyleVisibility* vis = StyleVisibility();
     nscoord size = nsPresContext::CSSPixelsToAppUnits(ICON_SIZE);
 
     bool iconUsed = false;
 
     // If we weren't previously displaying an icon, register ourselves
     // as an observer for load and animation updates and flag that we're
     // doing so now.
     if (aRequest && !mDisplayingIcon) {
@@ -1701,17 +1701,17 @@ nsImageFrame::GetCursor(const nsPoint& a
       // XXX Using the image as the parent style context isn't
       // technically correct, but it's probably the right thing to do
       // here, since it means that areas on which the cursor isn't
       // specified will inherit the style from the image.
       nsRefPtr<nsStyleContext> areaStyle = 
         PresContext()->PresShell()->StyleSet()->
           ResolveStyleFor(area->AsElement(), StyleContext());
       if (areaStyle) {
-        FillCursorInformationFromStyle(areaStyle->GetStyleUserInterface(),
+        FillCursorInformationFromStyle(areaStyle->StyleUserInterface(),
                                        aCursor);
         if (NS_STYLE_CURSOR_AUTO == aCursor.mCursor) {
           aCursor.mCursor = NS_STYLE_CURSOR_DEFAULT;
         }
         return NS_OK;
       }
     }
   }
@@ -2026,31 +2026,31 @@ IsInAutoWidthTableCellForQuirk(nsIFrame 
   if (eCompatibility_NavQuirks != aFrame->PresContext()->CompatibilityMode())
     return false;
   // Check if the parent of the closest nsBlockFrame has auto width.
   nsBlockFrame *ancestor = nsLayoutUtils::FindNearestBlockAncestor(aFrame);
   if (ancestor->StyleContext()->GetPseudo() == nsCSSAnonBoxes::cellContent) {
     // Assume direct parent is a table cell frame.
     nsFrame *grandAncestor = static_cast<nsFrame*>(ancestor->GetParent());
     return grandAncestor &&
-      grandAncestor->GetStylePosition()->mWidth.GetUnit() == eStyleUnit_Auto;
+      grandAncestor->StylePosition()->mWidth.GetUnit() == eStyleUnit_Auto;
   }
   return false;
 }
 
 /* virtual */ void
 nsImageFrame::AddInlineMinWidth(nsRenderingContext *aRenderingContext,
                                 nsIFrame::InlineMinWidthData *aData)
 {
 
   NS_ASSERTION(GetParent(), "Must have a parent if we get here!");
   
   bool canBreak =
     !CanContinueTextRun() &&
-    GetParent()->GetStyleText()->WhiteSpaceCanWrap() &&
+    GetParent()->StyleText()->WhiteSpaceCanWrap() &&
     !IsInAutoWidthTableCellForQuirk(this);
 
   if (canBreak)
     aData->OptionallyBreak(aRenderingContext);
  
   aData->trailingWhitespace = 0;
   aData->skipWhitespace = false;
   aData->trailingTextFrame = nullptr;
diff --git a/layout/generic/nsInlineFrame.cpp b/layout/generic/nsInlineFrame.cpp
--- a/layout/generic/nsInlineFrame.cpp
+++ b/layout/generic/nsInlineFrame.cpp
@@ -97,34 +97,34 @@ nsInlineFrame::IsSelfEmpty()
 {
 #if 0
   // I used to think inline frames worked this way, but it seems they
   // don't.  At least not in our codebase.
   if (GetPresContext()->CompatibilityMode() == eCompatibility_FullStandards) {
     return false;
   }
 #endif
-  const nsStyleMargin* margin = GetStyleMargin();
-  const nsStyleBorder* border = GetStyleBorder();
-  const nsStylePadding* padding = GetStylePadding();
+  const nsStyleMargin* margin = StyleMargin();
+  const nsStyleBorder* border = StyleBorder();
+  const nsStylePadding* padding = StylePadding();
   // XXX Top and bottom removed, since they shouldn't affect things, but this
   // doesn't really match with nsLineLayout.cpp's setting of
   // ZeroEffectiveSpanBox, anymore, so what should this really be?
   bool haveRight =
     border->GetComputedBorderWidth(NS_SIDE_RIGHT) != 0 ||
     !nsLayoutUtils::IsPaddingZero(padding->mPadding.GetRight()) ||
     !IsMarginZero(margin->mMargin.GetRight());
   bool haveLeft =
     border->GetComputedBorderWidth(NS_SIDE_LEFT) != 0 ||
     !nsLayoutUtils::IsPaddingZero(padding->mPadding.GetLeft()) ||
     !IsMarginZero(margin->mMargin.GetLeft());
   if (haveLeft || haveRight) {
     if (GetStateBits() & NS_FRAME_IS_SPECIAL) {
       bool haveStart, haveEnd;
-      if (NS_STYLE_DIRECTION_LTR == GetStyleVisibility()->mDirection) {
+      if (NS_STYLE_DIRECTION_LTR == StyleVisibility()->mDirection) {
         haveStart = haveLeft;
         haveEnd = haveRight;
       } else {
         haveStart = haveRight;
         haveEnd = haveLeft;
       }
       // For special frames, ignore things we know we'll skip in GetSkipSides.
       // XXXbz should we be doing this for non-special frames too, in a more
@@ -883,17 +883,17 @@ nsInlineFrame::GetSkipSides() const
   }
 
   if (GetStateBits() & NS_FRAME_IS_SPECIAL) {
     // All but the last part of an {ib} split should skip the "end" side (as
     // determined by this frame's direction) and all but the first part of such
     // a split should skip the "start" side.  But figuring out which part of
     // the split we are involves getting our first continuation, which might be
     // expensive.  So don't bother if we already have the relevant bits set.
-    bool ltr = (NS_STYLE_DIRECTION_LTR == GetStyleVisibility()->mDirection);
+    bool ltr = (NS_STYLE_DIRECTION_LTR == StyleVisibility()->mDirection);
     int startBit = (1 << (ltr ? NS_SIDE_LEFT : NS_SIDE_RIGHT));
     int endBit = (1 << (ltr ? NS_SIDE_RIGHT : NS_SIDE_LEFT));
     if (((startBit | endBit) & skip) != (startBit | endBit)) {
       // We're missing one of the skip bits, so check whether we need to set it.
       // Only get the first continuation once, as an optimization.
       nsIFrame* firstContinuation = GetFirstContinuation();
       if (nsLayoutUtils::FrameIsNonLastInIBSplit(firstContinuation)) {
         skip |= endBit;
diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -81,17 +81,17 @@ nsLineLayout::nsLineLayout(nsPresContext
     mLineAtStart(false)
 {
   NS_ASSERTION(aFloatManager || aOuterReflowState->frame->GetType() ==
                                   nsGkAtoms::letterFrame,
                "float manager should be present");
   MOZ_COUNT_CTOR(nsLineLayout);
 
   // Stash away some style data that we need
-  mStyleText = aOuterReflowState->frame->GetStyleText();
+  mStyleText = aOuterReflowState->frame->StyleText();
   mLineNumber = 0;
   mTotalPlacedFrames = 0;
   mTopEdge = 0;
   mTrimmableWidth = 0;
 
   mInflationMinFontSize =
     nsLayoutUtils::InflationMinFontSizeFor(aOuterReflowState->frame);
 
@@ -408,17 +408,17 @@ nsLineLayout::BeginSpan(nsIFrame* aFrame
     psd->mParent = mCurrentSpan;
     psd->mReflowState = aSpanReflowState;
     psd->mLeftEdge = aLeftEdge;
     psd->mX = aLeftEdge;
     psd->mRightEdge = aRightEdge;
     psd->mBaseline = aBaseline;
 
     psd->mNoWrap =
-      !aSpanReflowState->frame->GetStyleText()->WhiteSpaceCanWrap();
+      !aSpanReflowState->frame->StyleText()->WhiteSpaceCanWrap();
     psd->mDirection = aSpanReflowState->mStyleVisibility->mDirection;
     psd->mChangedFrameDirection = false;
 
     // Switch to new span
     mCurrentSpan = psd;
     mSpanDepth++;
   }
   return rv;
@@ -645,43 +645,43 @@ IsPercentageAware(const nsIFrame* aFrame
     return false;
   }
 
   // Some of these things don't apply to non-replaced inline frames
   // (that is, fType == nsGkAtoms::inlineFrame), but we won't bother making
   // things unnecessarily complicated, since they'll probably be set
   // quite rarely.
 
-  const nsStyleMargin* margin = aFrame->GetStyleMargin();
+  const nsStyleMargin* margin = aFrame->StyleMargin();
   if (HasPercentageUnitSide(margin->mMargin)) {
     return true;
   }
 
-  const nsStylePadding* padding = aFrame->GetStylePadding();
+  const nsStylePadding* padding = aFrame->StylePadding();
   if (HasPercentageUnitSide(padding->mPadding)) {
     return true;
   }
 
   // Note that borders can't be aware of percentages
 
-  const nsStylePosition* pos = aFrame->GetStylePosition();
+  const nsStylePosition* pos = aFrame->StylePosition();
 
   if ((pos->WidthDependsOnContainer() &&
        pos->mWidth.GetUnit() != eStyleUnit_Auto) ||
       pos->MaxWidthDependsOnContainer() ||
       pos->MinWidthDependsOnContainer() ||
       pos->OffsetHasPercent(NS_SIDE_RIGHT) ||
       pos->OffsetHasPercent(NS_SIDE_LEFT)) {
     return true;
   }
 
   if (eStyleUnit_Auto == pos->mWidth.GetUnit()) {
     // We need to check for frames that shrink-wrap when they're auto
     // width.
-    const nsStyleDisplay* disp = aFrame->GetStyleDisplay();
+    const nsStyleDisplay* disp = aFrame->StyleDisplay();
     if (disp->mDisplay == NS_STYLE_DISPLAY_INLINE_BLOCK ||
         disp->mDisplay == NS_STYLE_DISPLAY_INLINE_TABLE ||
         fType == nsGkAtoms::HTMLButtonControlFrame ||
         fType == nsGkAtoms::gfxButtonControlFrame ||
         fType == nsGkAtoms::fieldSetFrame ||
         fType == nsGkAtoms::comboboxDisplayFrame) {
       return true;
     }
@@ -1308,17 +1308,17 @@ nsLineLayout::PlaceFrame(PerFrameData* p
   }
 
   // Record ascent and update max-ascent and max-descent values
   if (aMetrics.ascent == nsHTMLReflowMetrics::ASK_FOR_BASELINE)
     pfd->mAscent = pfd->mFrame->GetBaseline();
   else
     pfd->mAscent = aMetrics.ascent;
 
-  bool ltr = (NS_STYLE_DIRECTION_LTR == pfd->mFrame->GetStyleVisibility()->mDirection);
+  bool ltr = (NS_STYLE_DIRECTION_LTR == pfd->mFrame->StyleVisibility()->mDirection);
   // Advance to next X coordinate
   psd->mX = pfd->mBounds.XMost() + (ltr ? pfd->mMargin.right : pfd->mMargin.left);
 
   // Count the number of non-empty frames on the line...
   if (!emptyFrame) {
     mTotalPlacedFrames++;
   }
 }
@@ -1707,17 +1707,17 @@ nsLineLayout::VerticalAlignFrames(PerSpa
                      inflation);
     nscoord contentHeight = spanFramePFD->mBounds.height -
       spanFramePFD->mBorderPadding.top - spanFramePFD->mBorderPadding.bottom;
 
     // Special-case for a ::first-letter frame, set the line height to
     // the frame height if the user has left line-height == normal 
     if (spanFramePFD->GetFlag(PFD_ISLETTERFRAME) &&
         !spanFrame->GetPrevInFlow() &&
-        spanFrame->GetStyleText()->mLineHeight.GetUnit() == eStyleUnit_Normal) {
+        spanFrame->StyleText()->mLineHeight.GetUnit() == eStyleUnit_Normal) {
       logicalHeight = spanFramePFD->mBounds.height;
     }
 
     nscoord leading = logicalHeight - contentHeight;
     psd->mTopLeading = leading / 2;
     psd->mBottomLeading = leading - psd->mTopLeading;
     psd->mLogicalHeight = logicalHeight;
 
@@ -1784,17 +1784,17 @@ nsLineLayout::VerticalAlignFrames(PerSpa
       // For other elements the logical height is the same as the
       // frames height plus its margins.
       logicalHeight = pfd->mBounds.height + pfd->mMargin.top +
         pfd->mMargin.bottom;
     }
 
     // Get vertical-align property
     const nsStyleCoord& verticalAlign =
-      frame->GetStyleTextReset()->mVerticalAlign;
+      frame->StyleTextReset()->mVerticalAlign;
     uint8_t verticalAlignEnum = frame->VerticalAlignEnum();
 #ifdef NOISY_VERTICAL_ALIGN
     printf("  [frame]");
     nsFrame::ListTag(stdout, frame);
     printf(": verticalAlignUnit=%d (enum == %d",
            verticalAlign.GetUnit(),
            ((eStyleUnit_Enumerated == verticalAlign.GetUnit())
             ? verticalAlign.GetIntValue()
@@ -1979,17 +1979,17 @@ nsLineLayout::VerticalAlignFrames(PerSpa
       //           in quirks.css have pseudo text contents with LF in them.
 #if 0
       if (!pfd->GetFlag(PFD_ISTEXTFRAME)) {
 #else
       // Only consider non empty text frames when line-height=normal
       bool canUpdate = !pfd->GetFlag(PFD_ISTEXTFRAME);
       if (!canUpdate && pfd->GetFlag(PFD_ISNONWHITESPACETEXTFRAME)) {
         canUpdate =
-          frame->GetStyleText()->mLineHeight.GetUnit() == eStyleUnit_Normal;
+          frame->StyleText()->mLineHeight.GetUnit() == eStyleUnit_Normal;
       }
       if (canUpdate) {
 #endif
         nscoord yTop, yBottom;
         if (frameSpan) {
           // For spans that were are now placing, use their position
           // plus their already computed min-Y and max-Y values for
           // computing yTop and yBottom.
diff --git a/layout/generic/nsObjectFrame.cpp b/layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp
+++ b/layout/generic/nsObjectFrame.cpp
@@ -811,17 +811,17 @@ nsObjectFrame::IsFocusable(int32_t *aTab
     *aTabIndex = -1;
   return nsObjectFrameSuper::IsFocusable(aTabIndex, aWithMouse);
 }
 
 bool
 nsObjectFrame::IsHidden(bool aCheckVisibilityStyle) const
 {
   if (aCheckVisibilityStyle) {
-    if (!GetStyleVisibility()->IsVisibleOrCollapsed())
+    if (!StyleVisibility()->IsVisibleOrCollapsed())
       return true;    
   }
 
   // only <embed> tags support the HIDDEN attribute
   if (mContent->Tag() == nsGkAtoms::embed) {
     // Yes, these are really the kooky ways that you could tell 4.x
     // not to hide the <embed> once you'd put the 'hidden' attribute
     // on the tag...
diff --git a/layout/generic/nsSimplePageSequence.cpp b/layout/generic/nsSimplePageSequence.cpp
--- a/layout/generic/nsSimplePageSequence.cpp
+++ b/layout/generic/nsSimplePageSequence.cpp
@@ -101,17 +101,17 @@ nsSimplePageSequenceFrame::nsSimplePageS
 {
   nscoord halfInch = PresContext()->CSSTwipsToAppUnits(NS_INCHES_TO_TWIPS(0.5));
   mMargin.SizeTo(halfInch, halfInch, halfInch, halfInch);
 
   // XXX Unsafe to assume successful allocation
   mPageData = new nsSharedPageData();
   mPageData->mHeadFootFont =
     new nsFont(*PresContext()->GetDefaultFont(kGenericFont_serif,
-                                              aContext->GetStyleFont()->mLanguage));
+                                              aContext->StyleFont()->mLanguage));
   mPageData->mHeadFootFont->size = nsPresContext::CSSPointsToAppUnits(10);
 
   nsresult rv;
   mPageData->mPrintOptions = do_GetService(sPrintOptionsContractID, &rv);
 
   // Doing this here so we only have to go get these formats once
   SetPageNumberFormat("pagenumber",  "%1$d", true);
   SetPageNumberFormat("pageofpages", "%1$d of %2$d", false);
diff --git a/layout/generic/nsSubDocumentFrame.cpp b/layout/generic/nsSubDocumentFrame.cpp
--- a/layout/generic/nsSubDocumentFrame.cpp
+++ b/layout/generic/nsSubDocumentFrame.cpp
@@ -199,17 +199,17 @@ nsSubDocumentFrame::ShowViewer()
   if (!PresContext()->IsDynamic()) {
     // We let the printing code take care of loading the document; just
     // create the inner view for it to use.
     (void) EnsureInnerView();
   } else {
     nsRefPtr<nsFrameLoader> frameloader = FrameLoader();
     if (frameloader) {
       nsIntSize margin = GetMarginAttributes();
-      const nsStyleDisplay* disp = GetStyleDisplay();
+      const nsStyleDisplay* disp = StyleDisplay();
       nsWeakFrame weakThis(this);
       mCallingShow = true;
       bool didCreateDoc =
         frameloader->Show(margin.width, margin.height,
                           ConvertOverflow(disp->mOverflowX),
                           ConvertOverflow(disp->mOverflowY),
                           this);
       if (!weakThis.IsAlive()) {
@@ -262,17 +262,17 @@ nsSubDocumentFrame::GetSubdocumentSize()
     return nsIntSize(presContext->AppUnitsToDevPixels(docSizeAppUnits.width),
                      presContext->AppUnitsToDevPixels(docSizeAppUnits.height));
   }
 }
 
 bool
 nsSubDocumentFrame::PassPointerEventsToChildren()
 {
-  if (GetStyleVisibility()->mPointerEvents != NS_STYLE_POINTER_EVENTS_NONE) {
+  if (StyleVisibility()->mPointerEvents != NS_STYLE_POINTER_EVENTS_NONE) {
     return true;
   }
   // Limit use of mozpasspointerevents to documents with embedded:apps/chrome
   // permission, because this could be used by the parent document to discover
   // which parts of the subdocument are transparent to events (if subdocument
   // uses pointer-events:none on its root element, which is admittedly
   // unlikely)
   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::mozpasspointerevents)) {
diff --git a/layout/generic/nsTextFrameThebes.cpp b/layout/generic/nsTextFrameThebes.cpp
--- a/layout/generic/nsTextFrameThebes.cpp
+++ b/layout/generic/nsTextFrameThebes.cpp
@@ -1507,29 +1507,29 @@ HasTerminalNewline(const nsTextFrame* aF
 
 static nscoord
 LetterSpacing(nsIFrame* aFrame, const nsStyleText* aStyleText = nullptr)
 {
   if (aFrame->IsSVGText()) {
     return 0;
   }
   if (!aStyleText) {
-    aStyleText = aFrame->GetStyleText();
+    aStyleText = aFrame->StyleText();
   }
   return StyleToCoord(aStyleText->mLetterSpacing);
 }
 
 static nscoord
 WordSpacing(nsIFrame* aFrame, const nsStyleText* aStyleText = nullptr)
 {
   if (aFrame->IsSVGText()) {
     return 0;
   }
   if (!aStyleText) {
-    aStyleText = aFrame->GetStyleText();
+    aStyleText = aFrame->StyleText();
   }
   return aStyleText->mWordSpacing;
 }
 
 bool
 BuildTextRunsScanner::ContinueTextRunAcrossFrames(nsTextFrame* aFrame1, nsTextFrame* aFrame2)
 {
   // We don't need to check font size inflation, since
@@ -1539,17 +1539,17 @@ BuildTextRunsScanner::ContinueTextRunAcr
   // already guaranteed to be the same as each other (and for the line
   // container).
   if (mBidiEnabled &&
       (NS_GET_EMBEDDING_LEVEL(aFrame1) != NS_GET_EMBEDDING_LEVEL(aFrame2) ||
        NS_GET_PARAGRAPH_DEPTH(aFrame1) != NS_GET_PARAGRAPH_DEPTH(aFrame2)))
     return false;
 
   nsStyleContext* sc1 = aFrame1->StyleContext();
-  const nsStyleText* textStyle1 = sc1->GetStyleText();
+  const nsStyleText* textStyle1 = sc1->StyleText();
   // If the first frame ends in a preformatted newline, then we end the textrun
   // here. This avoids creating giant textruns for an entire plain text file.
   // Note that we create a single text frame for a preformatted text node,
   // even if it has newlines in it, so typically we won't see trailing newlines
   // until after reflow has broken up the frame into one (or more) frames per
   // line. That's OK though.
   if (textStyle1->NewlineIsSignificant() && HasTerminalNewline(aFrame1))
     return false;
@@ -1561,26 +1561,26 @@ BuildTextRunsScanner::ContinueTextRunAcr
     // breaks text into different frames even though the text has the same
     // direction. We can't allow these two frames to share the same textrun
     // because that would violate our invariant that two flows in the same
     // textrun have different content elements.
     return false;
   }
 
   nsStyleContext* sc2 = aFrame2->StyleContext();
-  const nsStyleText* textStyle2 = sc2->GetStyleText();
+  const nsStyleText* textStyle2 = sc2->StyleText();
   if (sc1 == sc2)
     return true;
 
-  const nsStyleFont* fontStyle1 = sc1->GetStyleFont();
-  const nsStyleFont* fontStyle2 = sc2->GetStyleFont();
+  const nsStyleFont* fontStyle1 = sc1->StyleFont();
+  const nsStyleFont* fontStyle2 = sc2->StyleFont();
   nscoord letterSpacing1 = LetterSpacing(aFrame1);
   nscoord letterSpacing2 = LetterSpacing(aFrame2);
   return fontStyle1->mFont.BaseEquals(fontStyle2->mFont) &&
-    sc1->GetStyleFont()->mLanguage == sc2->GetStyleFont()->mLanguage &&
+    sc1->StyleFont()->mLanguage == sc2->StyleFont()->mLanguage &&
     textStyle1->mTextTransform == textStyle2->mTextTransform &&
     nsLayoutUtils::GetTextRunFlagsForStyle(sc1, fontStyle1, letterSpacing1) ==
       nsLayoutUtils::GetTextRunFlagsForStyle(sc2, fontStyle2, letterSpacing2);
 }
 
 void BuildTextRunsScanner::ScanFrame(nsIFrame* aFrame)
 {
   // First check if we can extend the current mapped frame block. This is common.
@@ -1819,22 +1819,22 @@ BuildTextRunsScanner::BuildTextRunForFra
   userData->mMappedFlowCount = mMappedFlows.Length();
   userData->mLastFlowIndex = 0;
 
   uint32_t currentTransformedTextOffset = 0;
 
   uint32_t nextBreakIndex = 0;
   nsTextFrame* nextBreakBeforeFrame = GetNextBreakBeforeFrame(&nextBreakIndex);
   bool enabledJustification = mLineContainer &&
-    (mLineContainer->GetStyleText()->mTextAlign == NS_STYLE_TEXT_ALIGN_JUSTIFY ||
-     mLineContainer->GetStyleText()->mTextAlignLast == NS_STYLE_TEXT_ALIGN_JUSTIFY) &&
+    (mLineContainer->StyleText()->mTextAlign == NS_STYLE_TEXT_ALIGN_JUSTIFY ||
+     mLineContainer->StyleText()->mTextAlignLast == NS_STYLE_TEXT_ALIGN_JUSTIFY) &&
     !mLineContainer->IsSVGText();
 
   // for word-break style
-  switch (mLineContainer->GetStyleText()->mWordBreak) {
+  switch (mLineContainer->StyleText()->mWordBreak) {
     case NS_STYLE_WORDBREAK_BREAK_ALL:
       mLineBreaker.SetWordBreak(nsILineBreaker::kWordBreak_BreakAll);
       break;
     case NS_STYLE_WORDBREAK_KEEP_ALL:
       mLineBreaker.SetWordBreak(nsILineBreaker::kWordBreak_KeepAll);
       break;
     default:
       mLineBreaker.SetWordBreak(nsILineBreaker::kWordBreak_Normal);
@@ -1846,28 +1846,28 @@ BuildTextRunsScanner::BuildTextRunForFra
   const nsStyleFont* fontStyle = nullptr;
   nsStyleContext* lastStyleContext = nullptr;
   for (i = 0; i < mMappedFlows.Length(); ++i) {
     MappedFlow* mappedFlow = &mMappedFlows[i];
     nsTextFrame* f = mappedFlow->mStartFrame;
 
     lastStyleContext = f->StyleContext();
     // Detect use of text-transform or font-variant anywhere in the run
-    textStyle = f->GetStyleText();
+    textStyle = f->StyleText();
     if (NS_STYLE_TEXT_TRANSFORM_NONE != textStyle->mTextTransform) {
       anyTextTransformStyle = true;
     }
     textFlags |= GetSpacingFlags(LetterSpacing(f));
     textFlags |= GetSpacingFlags(WordSpacing(f));
     nsTextFrameUtils::CompressionMode compression =
       CSSWhitespaceToCompressionMode[textStyle->mWhiteSpace];
     if (enabledJustification && !textStyle->WhiteSpaceIsSignificant()) {
       textFlags |= gfxTextRunFactory::TEXT_ENABLE_SPACING;
     }
-    fontStyle = f->GetStyleFont();
+    fontStyle = f->StyleFont();
     if (NS_STYLE_FONT_VARIANT_SMALL_CAPS == fontStyle->mFont.variant) {
       anySmallcapsStyle = true;
     }
 
     // Figure out what content is included in this flow.
     nsIContent* content = f->GetContent();
     const nsTextFragment* frag = content->GetText();
     int32_t contentStart = mappedFlow->mStartFrame->GetContentOffset();
@@ -2147,17 +2147,17 @@ BuildTextRunsScanner::SetupLineBreakerCo
   nsTextFrame* nextBreakBeforeFrame = GetNextBreakBeforeFrame(&nextBreakIndex);
 
   uint32_t i;
   const nsStyleText* textStyle = nullptr;
   for (i = 0; i < mMappedFlows.Length(); ++i) {
     MappedFlow* mappedFlow = &mMappedFlows[i];
     nsTextFrame* f = mappedFlow->mStartFrame;
 
-    textStyle = f->GetStyleText();
+    textStyle = f->StyleText();
     nsTextFrameUtils::CompressionMode compression =
       CSSWhitespaceToCompressionMode[textStyle->mWhiteSpace];
 
     // Figure out what content is included in this flow.
     nsIContent* content = f->GetContent();
     const nsTextFragment* frag = content->GetText();
     int32_t contentStart = mappedFlow->mStartFrame->GetContentOffset();
     int32_t contentEnd = mappedFlow->GetContentEnd();
@@ -2247,17 +2247,17 @@ HasCompressedLeadingWhitespace(nsTextFra
 }
 
 void
 BuildTextRunsScanner::SetupBreakSinksForTextRun(gfxTextRun* aTextRun,
                                                 const void* aTextPtr,
                                                 uint32_t    aFlags)
 {
   // textruns have uniform language
-  const nsStyleFont *styleFont = mMappedFlows[0].mStartFrame->GetStyleFont();
+  const nsStyleFont *styleFont = mMappedFlows[0].mStartFrame->StyleFont();
   // We should only use a language for hyphenation if it was specified
   // explicitly.
   nsIAtom* hyphenationLanguage =
     styleFont->mExplicitLanguage ? styleFont->mLanguage : nullptr;
   // We keep this pointed at the skip-chars data for the current mappedFlow.
   // This lets us cheaply check whether the flow has compressed initial
   // whitespace...
   gfxSkipCharsIterator iter(aTextRun->GetSkipChars());
@@ -2277,21 +2277,21 @@ BuildTextRunsScanner::SetupBreakSinksFor
       return;
 
     uint32_t length = iterNext.GetSkippedOffset() - offset;
     uint32_t flags = 0;
     nsIFrame* initialBreakController = mappedFlow->mAncestorControllingInitialBreak;
     if (!initialBreakController) {
       initialBreakController = mLineContainer;
     }
-    if (!initialBreakController->GetStyleText()->WhiteSpaceCanWrap()) {
+    if (!initialBreakController->StyleText()->WhiteSpaceCanWrap()) {
       flags |= nsLineBreaker::BREAK_SUPPRESS_INITIAL;
     }
     nsTextFrame* startFrame = mappedFlow->mStartFrame;
-    const nsStyleText* textStyle = startFrame->GetStyleText();
+    const nsStyleText* textStyle = startFrame->StyleText();
     if (!textStyle->WhiteSpaceCanWrap()) {
       flags |= nsLineBreaker::BREAK_SUPPRESS_INSIDE;
     }
     if (aTextRun->GetFlags() & nsTextFrameUtils::TEXT_NO_BREAKS) {
       flags |= nsLineBreaker::BREAK_SKIP_SETTING_NO_BREAKS;
     }
     if (textStyle->mTextTransform == NS_STYLE_TEXT_TRANSFORM_CAPITALIZE) {
       flags |= nsLineBreaker::BREAK_NEED_CAPITALIZATION;
@@ -2548,17 +2548,17 @@ nsTextFrame::GetTrimmedOffsets(const nsT
   // tree being too deep then the return value doesn't matter.
   NS_ASSERTION(!(GetStateBits() & NS_FRAME_FIRST_REFLOW) ||
                (GetParent()->GetStateBits() & NS_FRAME_TOO_DEEP_IN_FRAME_TREE),
                "Can only call this on frames that have been reflowed");
   NS_ASSERTION(!(GetStateBits() & NS_FRAME_IN_REFLOW),
                "Can only call this on frames that are not being reflowed");
 
   TrimmedOffsets offsets = { GetContentOffset(), GetContentLength() };
-  const nsStyleText* textStyle = GetStyleText();
+  const nsStyleText* textStyle = StyleText();
   // Note that pre-line newlines should still allow us to trim spaces
   // for display
   if (textStyle->WhiteSpaceIsSignificant())
     return offsets;
 
   if (GetStateBits() & TEXT_START_OF_LINE) {
     int32_t whitespaceCount =
       GetTrimmableWhitespaceCount(aFrag,
@@ -2650,17 +2650,17 @@ static int32_t FindChar(const nsTextFrag
         return (static_cast<const char*>(p) - str) + aOffset;
     }
   }
   return -1;
 }
 
 static bool IsChineseOrJapanese(nsIFrame* aFrame)
 {
-  nsIAtom* language = aFrame->GetStyleFont()->mLanguage;
+  nsIAtom* language = aFrame->StyleFont()->mLanguage;
   if (!language) {
     return false;
   }
   const PRUnichar *lang = language->GetUTF16String();
   return (!nsCRT::strncmp(lang, NS_LITERAL_STRING("ja").get(), 2) ||
           !nsCRT::strncmp(lang, NS_LITERAL_STRING("zh").get(), 2)) &&
          (language->GetLength() == 2 || lang[2] == '-');
 }
@@ -2715,17 +2715,17 @@ public:
   /**
    * Use this constructor after the frame has been reflowed and we don't
    * have other data around. Gets everything from the frame. EnsureTextRun
    * *must* be called before this!!!
    */
   PropertyProvider(nsTextFrame* aFrame, const gfxSkipCharsIterator& aStart,
                    nsTextFrame::TextRunType aWhichTextRun)
     : mTextRun(aFrame->GetTextRun(aWhichTextRun)), mFontGroup(nullptr),
-      mTextStyle(aFrame->GetStyleText()),
+      mTextStyle(aFrame->StyleText()),
       mFrag(aFrame->GetContent()->GetText()),
       mLineContainer(nullptr),
       mFrame(aFrame), mStart(aStart), mTempIterator(aStart),
       mTabWidths(nullptr), mTabWidthsAnalyzedLimit(0),
       mLength(aFrame->GetContentLength()),
       mWordSpacing(WordSpacing(aFrame)),
       mLetterSpacing(LetterSpacing(aFrame)),
       mJustificationSpacing(0),
@@ -2758,17 +2758,17 @@ public:
   /**
    * Find the start and end of the justifiable characters. Does not depend on the
    * position of aStart or aEnd, although it's most efficient if they are near the
    * start and end of the text frame.
    */
   void FindJustificationRange(gfxSkipCharsIterator* aStart,
                               gfxSkipCharsIterator* aEnd);
 
-  const nsStyleText* GetStyleText() { return mTextStyle; }
+  const nsStyleText* StyleText() { return mTextStyle; }
   nsTextFrame* GetFrame() { return mFrame; }
   // This may not be equal to the frame offset/length in because we may have
   // adjusted for whitespace trimming according to the state bits set in the frame
   // (for the static provider)
   const gfxSkipCharsIterator& GetStart() { return mStart; }
   // May return INT32_MAX if that was given to the constructor
   uint32_t GetOriginalLength() {
     NS_ASSERTION(mLength != INT32_MAX, "Length not known");
@@ -2940,17 +2940,17 @@ PropertyProvider::GetSpacingInternal(uin
           aSpacing[iter.GetSkippedOffset() - aStart].mAfter += mWordSpacing;
         }
       }
     }
   }
 
   // Ignore tab spacing rather than computing it, if the tab size is 0
   if (!aIgnoreTabs)
-    aIgnoreTabs = mFrame->GetStyleText()->mTabSize == 0;
+    aIgnoreTabs = mFrame->StyleText()->mTabSize == 0;
 
   // Now add tab spacing, if there is any
   if (!aIgnoreTabs) {
     CalcTabWidths(aStart, aLength);
     if (mTabWidths) {
       mTabWidths->ApplySpacing(aSpacing,
                                aStart - mStart.GetSkippedOffset(), aLength);
     }
@@ -2990,17 +2990,17 @@ PropertyProvider::GetSpacingInternal(uin
     }
   }
 }
 
 static gfxFloat
 ComputeTabWidthAppUnits(nsIFrame* aFrame, gfxTextRun* aTextRun)
 {
   // Get the number of spaces from CSS -moz-tab-size
-  const nsStyleText* textStyle = aFrame->GetStyleText();
+  const nsStyleText* textStyle = aFrame->StyleText();
   
   // Round the space width when converting to appunits the same way
   // textruns do
   gfxFloat spaceWidthAppUnits =
     NS_round(GetFirstFontMetrics(aTextRun->GetFontGroup()).spaceWidth *
               aTextRun->GetAppUnitsPerDevUnit());
   return textStyle->mTabSize * spaceWidthAppUnits;
 }
@@ -3491,17 +3491,17 @@ nsTextPaintStyle::EnsureSufficientContra
 
 nscolor
 nsTextPaintStyle::GetTextColor()
 {
   if (mFrame->IsSVGText()) {
     if (!mResolveColors)
       return NS_SAME_AS_FOREGROUND_COLOR;
 
-    const nsStyleSVG* style = mFrame->GetStyleSVG();
+    const nsStyleSVG* style = mFrame->StyleSVG();
     switch (style->mFill.mType) {
       case eStyleSVGPaintType_None:
         return NS_RGBA(0, 0, 0, 0);
       case eStyleSVGPaintType_Color:
         return nsLayoutUtils::GetColor(mFrame, eCSSProperty_fill);
       default:
         NS_ERROR("cannot resolve SVG paint to nscolor");
         return NS_RGBA(0, 0, 0, 255);
@@ -3682,17 +3682,17 @@ nsTextPaintStyle::InitSelectionColorsAnd
       mSelectionBGColor =
         sc->GetVisitedDependentColor(eCSSProperty_background_color);
       mSelectionTextColor = sc->GetVisitedDependentColor(eCSSProperty_color);
       mHasSelectionShadow =
         nsRuleNode::HasAuthorSpecifiedRules(sc,
                                             NS_AUTHOR_SPECIFIED_TEXT_SHADOW,
                                             true);
       if (mHasSelectionShadow) {
-        mSelectionShadow = sc->GetStyleText()->mTextShadow;
+        mSelectionShadow = sc->StyleText()->mTextShadow;
       }
       return true;
     }
   }
 
   nscolor selectionBGColor =
     LookAndFeel::GetColor(LookAndFeel::eColorID_TextSelectBackground);
 
@@ -4265,17 +4265,17 @@ nsTextFrame::~nsTextFrame()
     nsBlinkTimer::RemoveBlinkFrame(this);
   }
 }
 
 NS_IMETHODIMP
 nsTextFrame::GetCursor(const nsPoint& aPoint,
                        nsIFrame::Cursor& aCursor)
 {
-  FillCursorInformationFromStyle(GetStyleUserInterface(), aCursor);  
+  FillCursorInformationFromStyle(StyleUserInterface(), aCursor);  
   if (NS_STYLE_CURSOR_AUTO == aCursor.mCursor) {
     aCursor.mCursor = NS_STYLE_CURSOR_TEXT;
     // If this is editable, we should ignore tabindex value.
     if (mContent->IsEditable()) {
       return NS_OK;
     }
 
     // If tabindex >= 0, use default cursor to indicate it's not selectable
@@ -4744,17 +4744,17 @@ nsTextFrame::GetTextDecorations(
        fChild = f,
        f = nsLayoutUtils::GetParentOrPlaceholderFor(f))
   {
     nsStyleContext *const context = f->StyleContext();
     if (!context->HasTextDecorationLines()) {
       break;
     }
 
-    const nsStyleTextReset *const styleText = context->GetStyleTextReset();
+    const nsStyleTextReset *const styleText = context->StyleTextReset();
     const uint8_t textDecorations = styleText->mTextDecorationLine;
 
     if (!useOverride &&
         (NS_STYLE_TEXT_DECORATION_LINE_OVERRIDE_ALL & textDecorations)) {
       // This handles the <a href="blah.html"><font color="green">La 
       // la la</font></a> case. The link underline should be green.
       useOverride = true;
       overrideColor =
@@ -4857,17 +4857,17 @@ nsTextFrame::UnionAdditionalOverflow(nsP
     nsLayoutUtils::GetTextShadowRectsUnion(*aVisualOverflowRect, this);
   aVisualOverflowRect->UnionRect(*aVisualOverflowRect, shadowRect);
 
   if (IsFloatingFirstLetterChild()) {
     // The underline/overline drawable area must be contained in the overflow
     // rect when this is in floating first letter frame at *both* modes.
     nsIFrame* firstLetterFrame = aBlockReflowState.frame;
     uint8_t decorationStyle = firstLetterFrame->StyleContext()->
-                                GetStyleTextReset()->GetDecorationStyle();
+                                StyleTextReset()->GetDecorationStyle();
     // If the style is none, let's include decoration line rect as solid style
     // since changing the style from none to solid/dotted/dashed doesn't cause
     // reflow.
     if (decorationStyle == NS_STYLE_TEXT_DECORATION_STYLE_NONE) {
       decorationStyle = NS_STYLE_TEXT_DECORATION_STYLE_SOLID;
     }
     nsFontMetrics* fontMetrics = aProvider.GetFontMetrics();
     nscoord underlineOffset, underlineSize;
@@ -5540,17 +5540,17 @@ nsTextFrame::PaintTextWithSelectionColor
                                  gfxRect(aFramePt.x + x, aFramePt.y, advance,
                                  GetSize().height), aCallbacks);
       }
       iterator.UpdateWithAdvance(advance);
     }
   }
   
   // Draw text
-  const nsStyleText* textStyle = GetStyleText();
+  const nsStyleText* textStyle = StyleText();
   nsRect dirtyRect(aDirtyRect.x, aDirtyRect.y,
                    aDirtyRect.width, aDirtyRect.height);
   SelectionIterator iterator(prevailingSelections, aContentOffset, aContentLength,
                              aProvider, mTextRun, startXOffset);
   while (iterator.GetNextSegment(&xOffset, &offset, &length, &hyphenWidth,
                                  &type, &rangeStyle)) {
     nscolor foreground, background;
     GetSelectionTextColors(type, aTextPaintStyle, rangeStyle,
@@ -5735,17 +5735,17 @@ nsTextFrame::GetCaretColorAt(int32_t aOf
                   "aOffset must be in the frame's range");
   int32_t offsetInFrame = aOffset - contentOffset;
   if (offsetInFrame < 0 || offsetInFrame >= contentLength) {
     return result;
   }
 
   bool isSolidTextColor = true;
   if (IsSVGText()) {
-    const nsStyleSVG* style = GetStyleSVG();
+    const nsStyleSVG* style = StyleSVG();
     if (style->mFill.mType != eStyleSVGPaintType_None &&
         style->mFill.mType != eStyleSVGPaintType_Color) {
       isSolidTextColor = false;
     }
   }
 
   nsTextPaintStyle textPaintStyle(this);
   textPaintStyle.SetResolveColors(isSolidTextColor);
@@ -5939,17 +5939,17 @@ nsTextFrame::PaintText(nsRenderingContex
                                textPaintStyle, clipEdges, aObjectPaint,
                                aCallbacks)) {
       return;
     }
   }
 
   nscolor foregroundColor = textPaintStyle.GetTextColor();
   if (!aCallbacks) {
-    const nsStyleText* textStyle = GetStyleText();
+    const nsStyleText* textStyle = StyleText();
     if (textStyle->HasTextShadow(this)) {
       // Text shadow happens with the last value being painted at the back,
       // ie. it is painted first.
       gfxTextRun::Metrics shadowMetrics = 
         mTextRun->MeasureText(startOffset, maxLength, gfxFont::LOOSE_INK_EXTENTS,
                               nullptr, &provider);
       for (uint32_t i = textStyle->mTextShadow->Length(); i > 0; --i) {
         PaintOneShadow(startOffset, maxLength,
@@ -6286,17 +6286,17 @@ nsTextFrame::GetCharacterOffsetAtFramePo
     // caused characters to move backwards. We can't really handle that
     // in the current frame system because frames can't have negative
     // intrinsic widths.
     selectedOffset =
         provider.GetStart().GetOriginalOffset() + provider.GetOriginalLength();
     // If we're at the end of a preformatted line which has a terminating
     // linefeed, we want to reduce the offset by one to make sure that the
     // selection is placed before the linefeed character.
-    if (GetStyleText()->NewlineIsSignificant() &&
+    if (StyleText()->NewlineIsSignificant() &&
         HasTerminalNewline()) {
       --selectedOffset;
     }
   }
 
   offsets.content = GetContent();
   offsets.offset = offsets.secondaryOffset = selectedOffset;
   offsets.associateWithNext = mContentOffset == offsets.offset;
@@ -6662,17 +6662,17 @@ nsTextFrame::PeekOffsetCharacter(bool aF
       }
     }
     *aOffset = 0;
   } else {
     // If we're at the end of a line, look at the next continuation
     iter.SetOriginalOffset(startOffset);
     if (startOffset <= trimmed.GetEnd() &&
         !(startOffset < trimmed.GetEnd() &&
-          GetStyleText()->NewlineIsSignificant() &&
+          StyleText()->NewlineIsSignificant() &&
           iter.GetSkippedOffset() < mTextRun->GetLength() &&
           mTextRun->CharIsNewline(iter.GetSkippedOffset()))) {
       for (int32_t i = startOffset + 1; i <= trimmed.GetEnd(); ++i) {
         iter.SetOriginalOffset(i);
         if (i == trimmed.GetEnd() ||
             IsAcceptableCaretPosition(iter, aRespectClusters, mTextRun, this)) {
           *aOffset = i - mContentOffset;
           return true;
@@ -7036,17 +7036,17 @@ nsTextFrame::AddInlineMinWidthForFlow(ns
     EnsureTextRun(aTextRunType, ctx, aData->lineContainer,
                   aData->line, &flowEndInTextRun);
   gfxTextRun *textRun = GetTextRun(aTextRunType);
   if (!textRun)
     return;
 
   // Pass null for the line container. This will disable tab spacing, but that's
   // OK since we can't really handle tabs for intrinsic sizing anyway.
-  const nsStyleText* textStyle = GetStyleText();
+  const nsStyleText* textStyle = StyleText();
   const nsTextFragment* frag = mContent->GetText();
 
   // If we're hyphenating, the PropertyProvider needs the actual length;
   // otherwise we can just pass INT32_MAX to mean "all the text"
   int32_t len = INT32_MAX;
   bool hyphenating = frag->GetLength() > 0 &&
     (textStyle->mHyphens == NS_STYLE_HYPHENS_AUTO ||
      (textStyle->mHyphens == NS_STYLE_HYPHENS_MANUAL &&
@@ -7210,17 +7210,17 @@ nsTextFrame::AddInlinePrefWidthForFlow(n
                   aData->line, &flowEndInTextRun);
   gfxTextRun *textRun = GetTextRun(aTextRunType);
   if (!textRun)
     return;
 
   // Pass null for the line container. This will disable tab spacing, but that's
   // OK since we can't really handle tabs for intrinsic sizing anyway.
   
-  const nsStyleText* textStyle = GetStyleText();
+  const nsStyleText* textStyle = StyleText();
   const nsTextFragment* frag = mContent->GetText();
   PropertyProvider provider(textRun, textStyle, frag, this,
                             iter, INT32_MAX, nullptr, 0, aTextRunType);
 
   bool collapseWhitespace = !textStyle->WhiteSpaceIsSignificant();
   bool preformatNewlines = textStyle->NewlineIsSignificant();
   bool preformatTabs = textStyle->WhiteSpaceIsSignificant();
   gfxFloat tabWidth = -1;
@@ -7483,17 +7483,17 @@ nsTextFrame::SetLength(int32_t aLength, 
   if (aLineLayout &&
       (end != f->mContentOffset || (f->GetStateBits() & NS_FRAME_IS_DIRTY))) {
     aLineLayout->SetDirtyNextLine();
   }
 
   if (end < f->mContentOffset) {
     // Our frame is shrinking. Give the text to our next in flow.
     if (aLineLayout &&
-        GetStyleText()->WhiteSpaceIsSignificant() &&
+        StyleText()->WhiteSpaceIsSignificant() &&
         HasTerminalNewline() &&
         GetParent()->GetType() != nsGkAtoms::letterFrame &&
         (aSetLengthFlags & ALLOW_FRAME_CREATION_AND_DESTRUCTION)) {
       // Whatever text we hand to our next-in-flow will end up in a frame all of
       // its own, since it ends in a forced linebreak.  Might as well just put
       // it in a separate frame now.  This is important to prevent text run
       // churn; if we did not do that, then we'd likely end up rebuilding
       // textruns for all our following continuations.
@@ -7720,17 +7720,17 @@ nsTextFrame::ReflowText(nsLineLayout& aL
       nsBlinkTimer::RemoveBlinkFrame(this);
     }
   }
 
 #ifdef NOISY_BIDI
     printf("Reflowed textframe\n");
 #endif
 
-  const nsStyleText* textStyle = GetStyleText();
+  const nsStyleText* textStyle = StyleText();
 
   bool atStartOfLine = aLineLayout.LineAtStart();
   if (atStartOfLine) {
     AddStateBits(TEXT_START_OF_LINE);
   }
 
   uint32_t flowEndInTextRun;
   nsIFrame* lineContainer = aLineLayout.GetLineContainerFrame();
@@ -8167,18 +8167,18 @@ nsTextFrame::ReflowText(nsLineLayout& aL
       cachedNewlineOffset->mNewlineOffset = contentNewLineOffset;
     }
   } else if (cachedNewlineOffset) {
     mContent->DeleteProperty(nsGkAtoms::newline);
   }
 
   // Compute space and letter counts for justification, if required
   if (!textStyle->WhiteSpaceIsSignificant() &&
-      (lineContainer->GetStyleText()->mTextAlign == NS_STYLE_TEXT_ALIGN_JUSTIFY ||
-       lineContainer->GetStyleText()->mTextAlignLast == NS_STYLE_TEXT_ALIGN_JUSTIFY) &&
+      (lineContainer->StyleText()->mTextAlign == NS_STYLE_TEXT_ALIGN_JUSTIFY ||
+       lineContainer->StyleText()->mTextAlignLast == NS_STYLE_TEXT_ALIGN_JUSTIFY) &&
       !lineContainer->IsSVGText()) {
     AddStateBits(TEXT_JUSTIFICATION_ENABLED);    // This will include a space for trailing whitespace, if any is present.
     // This is corrected for in nsLineLayout::TrimWhiteSpaceIn.
     int32_t numJustifiableCharacters =
       provider.ComputeJustifiableCharacters(offset, charsFit);
 
     NS_ASSERTION(numJustifiableCharacters <= charsFit,
                  "Bad justifiable character count");
@@ -8224,17 +8224,17 @@ nsTextFrame::TrimTrailingWhiteSpace(nsRe
     EnsureTextRun(nsTextFrame::eInflated, ctx);
   NS_ENSURE_TRUE(mTextRun, result);
 
   uint32_t trimmedStart = start.GetSkippedOffset();
 
   const nsTextFragment* frag = mContent->GetText();
   TrimmedOffsets trimmed = GetTrimmedOffsets(frag, true);
   gfxSkipCharsIterator trimmedEndIter = start;
-  const nsStyleText* textStyle = GetStyleText();
+  const nsStyleText* textStyle = StyleText();
   gfxFloat delta = 0;
   uint32_t trimmedEnd = trimmedEndIter.ConvertOriginalToSkipped(trimmed.GetEnd());
   
   if (GetStateBits() & TEXT_TRIMMED_TRAILING_WHITESPACE) {
     // We pre-trimmed this frame, so the last character is justifiable
     result.mLastCharIsJustifiable = true;
   } else if (trimmed.GetEnd() < GetContentEnd()) {
     gfxSkipCharsIterator end = trimmedEndIter;
@@ -8390,17 +8390,17 @@ nsresult nsTextFrame::GetRenderedText(ns
     TrimmedOffsets trimmedContentOffsets = textFrame->GetTrimmedOffsets(textFrag, false);
     int32_t startOfLineSkipChars = trimmedContentOffsets.mStart - textFrame->mContentOffset;
     if (startOfLineSkipChars > 0) {
       skipCharsBuilder.SkipChars(startOfLineSkipChars);
       iter.SetOriginalOffset(trimmedContentOffsets.mStart);
     }
 
     // Keep and copy the appropriate chars withing the caller's requested range
-    const nsStyleText* textStyle = textFrame->GetStyleText();
+    const nsStyleText* textStyle = textFrame->StyleText();
     while (iter.GetOriginalOffset() < trimmedContentOffsets.GetEnd() &&
            keptCharsLength < aSkippedMaxLength) {
       // For each original char from content text
       if (iter.IsOriginalCharSkipped() || ++validCharsLength <= aSkippedStartOffset) {
         skipCharsBuilder.SkipChar();
       } else {
         ++keptCharsLength;
         skipCharsBuilder.KeepChar();
@@ -8476,17 +8476,17 @@ nsTextFrame::GetType() const
 /* virtual */ bool
 nsTextFrame::IsEmpty()
 {
   NS_ASSERTION(!(mState & TEXT_IS_ONLY_WHITESPACE) ||
                !(mState & TEXT_ISNOT_ONLY_WHITESPACE),
                "Invalid state");
   
   // XXXldb Should this check compatibility mode as well???
-  const nsStyleText* textStyle = GetStyleText();
+  const nsStyleText* textStyle = StyleText();
   if (textStyle->WhiteSpaceIsSignificant() &&
       textStyle->mWhiteSpace != NS_STYLE_WHITESPACE_PRE_DISCARD_NEWLINES) {
     // XXX shouldn't we return true if the length is zero?
     return false;
   }
 
   if (mState & TEXT_ISNOT_ONLY_WHITESPACE) {
     return false;
diff --git a/layout/generic/nsTextRunTransformations.cpp b/layout/generic/nsTextRunTransformations.cpp
--- a/layout/generic/nsTextRunTransformations.cpp
+++ b/layout/generic/nsTextRunTransformations.cpp
@@ -576,25 +576,25 @@ nsFontVariantTextRunFactory::RebuildText
     // character will need.
     if (i < length) {
       nsStyleContext* styleContext = styles[i];
       // Characters that aren't the start of a cluster are ignored here. They
       // get added to whatever lowercase/non-lowercase run we're in.
       if (!inner->IsClusterStart(i)) {
         chCase = runCase;
       } else {
-        if (styleContext->GetStyleFont()->mFont.variant == NS_STYLE_FONT_VARIANT_SMALL_CAPS) {
+        if (styleContext->StyleFont()->mFont.variant == NS_STYLE_FONT_VARIANT_SMALL_CAPS) {
           uint32_t ch = str[i];
           if (NS_IS_HIGH_SURROGATE(ch) && i < length - 1 && NS_IS_LOW_SURROGATE(str[i + 1])) {
             ch = SURROGATE_TO_UCS4(ch, str[i + 1]);
           }
           uint32_t ch2 = ToUpperCase(ch);
           if (ch != ch2 || mozilla::unicode::SpecialUpper(ch)) {
             chCase = kLowercase;
-          } else if (styleContext->GetStyleFont()->mLanguage == nsGkAtoms::el) {
+          } else if (styleContext->StyleFont()->mLanguage == nsGkAtoms::el) {
             // In Greek, check for characters that will be modified by the
             // GreekUpperCase mapping - this catches accented capitals where
             // the accent is to be removed (bug 307039). These are handled by
             // a transformed child run using the full-size font.
             GreekCasingState state = kStart; // don't need exact context here
             ch2 = GreekUpperCase(ch, &state);
             if (ch != ch2) {
               chCase = kSpecialUpper;
@@ -698,26 +698,26 @@ nsCaseTransformTextRunFactory::RebuildTe
   nsIUGenCategory::nsUGenCategory cat;
   GreekCasingState greekState = kStart;
   uint32_t i;
   for (i = 0; i < length; ++i) {
     uint32_t ch = str[i];
     nsStyleContext* styleContext = styles[i];
 
     uint8_t style = mAllUppercase ? NS_STYLE_TEXT_TRANSFORM_UPPERCASE
-      : styleContext->GetStyleText()->mTextTransform;
+      : styleContext->StyleText()->mTextTransform;
     int extraChars = 0;
     const mozilla::unicode::MultiCharMapping *mcm;
 
     if (NS_IS_HIGH_SURROGATE(ch) && i < length - 1 && NS_IS_LOW_SURROGATE(str[i + 1])) {
       ch = SURROGATE_TO_UCS4(ch, str[i + 1]);
     }
 
-    if (lang != styleContext->GetStyleFont()->mLanguage) {
-      lang = styleContext->GetStyleFont()->mLanguage;
+    if (lang != styleContext->StyleFont()->mLanguage) {
+      lang = styleContext->StyleFont()->mLanguage;
       if (lang == nsGkAtoms::tr || lang == nsGkAtoms::az ||
           lang == nsGkAtoms::ba || lang == nsGkAtoms::crh ||
           lang == nsGkAtoms::tt) {
         languageSpecificCasing = eTurkish;
       } else if (lang == nsGkAtoms::nl) {
         languageSpecificCasing = eDutch;
       } else if (lang == nsGkAtoms::el) {
         languageSpecificCasing = eGreek;
diff --git a/layout/inspector/src/inDOMUtils.cpp b/layout/inspector/src/inDOMUtils.cpp
--- a/layout/inspector/src/inDOMUtils.cpp
+++ b/layout/inspector/src/inDOMUtils.cpp
@@ -66,17 +66,17 @@ inDOMUtils::IsIgnorableWhitespace(nsIDOM
   if (!content->TextIsOnlyWhitespace()) {
     return NS_OK;
   }
 
   // Okay.  We have only white space.  Let's check the white-space
   // property now and make sure that this isn't preformatted text...
   nsIFrame* frame = content->GetPrimaryFrame();
   if (frame) {
-    const nsStyleText* text = frame->GetStyleText();
+    const nsStyleText* text = frame->StyleText();
     *aReturn = !text->WhiteSpaceIsSignificant();
   }
   else {
     // empty inter-tag text node without frame, e.g., in between <table>\n<tr>
     *aReturn = true;
   }
 
   return NS_OK;
diff --git a/layout/mathml/nsMathMLChar.cpp b/layout/mathml/nsMathMLChar.cpp
--- a/layout/mathml/nsMathMLChar.cpp
+++ b/layout/mathml/nsMathMLChar.cpp
@@ -915,17 +915,17 @@ SetFontFamily(nsStyleContext*      aStyl
 {
   const nsAString& family =
     aGlyphCode.font ? aGlyphTable->FontNameFor(aGlyphCode) : aDefaultFamily;
   if (! family.Equals(aFont.name)) {
     nsFont font = aFont;
     font.name = family;
     nsRefPtr<nsFontMetrics> fm;
     aRenderingContext.DeviceContext()->GetMetricsFor(font,
-      aStyleContext->GetStyleFont()->mLanguage,
+      aStyleContext->StyleFont()->mLanguage,
       aStyleContext->PresContext()->GetUserFontSet(),
       *getter_AddRefs(fm));
     // Set the font if it is an unicode table
     // or if the same family name has been found
     if (aGlyphTable == &gGlyphTableList->mUnicodeTable ||
         fm->GetThebesFontGroup()->GetFamilyNameAt(0) == family) {
       aFont.name = family;
       aRenderingContext.SetFont(fm);
@@ -991,17 +991,17 @@ private:
 // Returns true if the size is OK, false to keep searching.
 // Always updates the char if a better match is found.
 bool
 nsMathMLChar::StretchEnumContext::TryVariants(nsGlyphTable*    aGlyphTable,
                                               const nsAString& aFamily)
 {
   // Use our stretchy style context now that stretching is in progress
   nsStyleContext *sc = mChar->mStyleContext;
-  nsFont font = sc->GetStyleFont()->mFont;
+  nsFont font = sc->StyleFont()->mFont;
   // Ensure mRenderingContext.SetFont will be called:
   font.name.Truncate();
 
   bool isVertical = (mDirection == NS_STRETCH_DIRECTION_VERTICAL);
   bool largeop = (NS_STRETCH_LARGEOP & mStretchHint) != 0;
   bool largeopOnly =
     largeop && (NS_STRETCH_VARIABLE_MASK & mStretchHint) == 0;
   bool maxWidth = (NS_STRETCH_MAXWIDTH & mStretchHint) != 0;
@@ -1092,17 +1092,17 @@ nsMathMLChar::StretchEnumContext::TryPar
                                            const nsAString& aFamily)
 {
   if (!aGlyphTable->HasPartsOf(mPresContext, mChar))
     return false; // to next table
 
   // See if the parts of this table fit in the desired space //////////////////
 
   // Use our stretchy style context now that stretching is in progress
-  nsFont font = mChar->mStyleContext->GetStyleFont()->mFont;
+  nsFont font = mChar->mStyleContext->StyleFont()->mFont;
   // Ensure mRenderingContext.SetFont will be called:
   font.name.Truncate();
 
   // Compute the bounding metrics of all partial glyphs
   nsGlyphCode chdata[4];
   nsBoundingMetrics bmdata[4];
   nscoord sizedata[4];
   nsGlyphCode glue = aGlyphTable->GlueOf(mPresContext, mChar);
@@ -1240,17 +1240,17 @@ nsMathMLChar::StretchEnumContext::EnumCa
     gGlyphTableList->GetGlyphTableFor(aFamily);
 
   if (context->mTablesTried.Contains(glyphTable))
     return true; // already tried this one
 
   // Check font family if it is not a generic one
   // We test with the kNullGlyph
   nsStyleContext *sc = context->mChar->mStyleContext;
-  nsFont font = sc->GetStyleFont()->mFont;
+  nsFont font = sc->StyleFont()->mFont;
   if (!aGeneric && !SetFontFamily(sc, context->mRenderingContext,
                                   font, NULL, kNullGlyph, aFamily))
      return true; // Could not set the family
 
   context->mGlyphTable = glyphTable;
 
   // Now see if the table has a glyph that matches the container
 
@@ -1285,17 +1285,17 @@ nsMathMLChar::StretchInternal(nsPresCont
   // if we have been called before, and we didn't actually stretch, our
   // direction may have been set to NS_STRETCH_DIRECTION_UNSUPPORTED.
   // So first set our direction back to its instrinsic value
   nsStretchDirection direction = nsMathMLOperators::GetStretchyDirection(mData);
 
   // Set default font and get the default bounding metrics
   // mStyleContext is a leaf context used only when stretching happens.
   // For the base size, the default font should come from the parent context
-  nsFont font = mStyleContext->GetParent()->GetStyleFont()->mFont;
+  nsFont font = mStyleContext->GetParent()->StyleFont()->mFont;
 
   // Override with specific fonts if applicable for this character
   nsAutoString families;
   if (GetFontExtensionPref(mData[0], eExtension_base, families)) {
     font.name = families;
   }
 
   // Don't modify this nsMathMLChar when doing GetMaxWidth()
@@ -1303,17 +1303,17 @@ nsMathMLChar::StretchInternal(nsPresCont
   if (!maxWidth) {
     // Record the families in case there is no stretch.  But don't bother
     // storing families when they are just those from the StyleContext.
     mFamily = families;
   }
 
   nsRefPtr<nsFontMetrics> fm;
   aRenderingContext.DeviceContext()->GetMetricsFor(font,
-    mStyleContext->GetStyleFont()->mLanguage,
+    mStyleContext->StyleFont()->mLanguage,
     aPresContext->GetUserFontSet(), *getter_AddRefs(fm));
   aRenderingContext.SetFont(fm);
   aDesiredStretchSize =
     aRenderingContext.GetBoundingMetrics(mData.get(), uint32_t(mData.Length()));
 
   if (!maxWidth) {
     mUnscaledAscent = aDesiredStretchSize.ascent;
   }
@@ -1403,17 +1403,17 @@ nsMathMLChar::StretchInternal(nsPresCont
   //////////////////////////////////////////////////////////////////////////////
   // 2/3. Search for a glyph or set of part glyphs of appropriate size
   //////////////////////////////////////////////////////////////////////////////
 
   bool glyphFound = false;
   nsAutoString cssFamilies;
 
   if (!done) {
-    font = mStyleContext->GetStyleFont()->mFont;
+    font = mStyleContext->StyleFont()->mFont;
     cssFamilies = font.name;
   }
 
   // See if there are preferred fonts for the variants of this char
   if (!done && GetFontExtensionPref(mData[0], eExtension_variants, families)) {
     font.name = families;
 
     StretchEnumContext enumData(this, aPresContext, aRenderingContext,
@@ -1646,17 +1646,17 @@ public:
 private:
   nsStyleContext* mStyleContext;
   nsRect          mRect;
 };
 
 void nsDisplayMathMLCharBackground::Paint(nsDisplayListBuilder* aBuilder,
                                           nsRenderingContext* aCtx)
 {
-  const nsStyleBorder* border = mStyleContext->GetStyleBorder();
+  const nsStyleBorder* border = mStyleContext->StyleBorder();
   nsRect rect(mRect + ToReferenceFrame());
   nsCSSRendering::PaintBackgroundWithSC(mFrame->PresContext(), *aCtx, mFrame,
                                         mVisibleRect, rect,
                                         mStyleContext, *border,
                                         aBuilder->GetBackgroundPaintFlags());
 }
 
 class nsDisplayMathMLCharForeground : public nsDisplayItem {
@@ -1764,30 +1764,30 @@ nsMathMLChar::Display(nsDisplayListBuild
   nsStyleContext* styleContext = mStyleContext;
 
   if (mDrawNormal) {
     // normal drawing if there is nothing special about this char
     // Set default context to the parent context
     styleContext = parentContext;
   }
 
-  if (!styleContext->GetStyleVisibility()->IsVisible())
+  if (!styleContext->StyleVisibility()->IsVisible())
     return NS_OK;
 
   // if the leaf style context that we use for stretchy chars has a background
   // color we use it -- this feature is mostly used for testing and debugging
   // purposes. Normally, users will set the background on the container frame.
   // paint the selection background -- beware MathML frames overlap a lot
   if (aSelectedRect && !aSelectedRect->IsEmpty()) {
     rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
         nsDisplayMathMLSelectionRect(aBuilder, aForFrame, *aSelectedRect));
     NS_ENSURE_SUCCESS(rv, rv);
   }
   else if (mRect.width && mRect.height) {
-    const nsStyleBackground* backg = styleContext->GetStyleBackground();
+    const nsStyleBackground* backg = styleContext->StyleBackground();
     if (styleContext != parentContext &&
         NS_GET_A(backg->mBackgroundColor) > 0) {
       rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
           nsDisplayMathMLCharBackground(aBuilder, aForFrame, mRect,
                                         styleContext));
       NS_ENSURE_SUCCESS(rv, rv);
     }
     //else
@@ -1844,23 +1844,23 @@ nsMathMLChar::PaintForeground(nsPresCont
   nscolor fgColor = styleContext->GetVisitedDependentColor(eCSSProperty_color);
   if (aIsSelected) {
     // get color to use for selection from the look&feel object
     fgColor = LookAndFeel::GetColor(LookAndFeel::eColorID_TextSelectForeground,
                                     fgColor);
   }
   aRenderingContext.SetColor(fgColor);
 
-  nsFont theFont(styleContext->GetStyleFont()->mFont);
+  nsFont theFont(styleContext->StyleFont()->mFont);
   if (! mFamily.IsEmpty()) {
     theFont.name = mFamily;
   }
   nsRefPtr<nsFontMetrics> fm;
   aRenderingContext.DeviceContext()->GetMetricsFor(theFont,
-    styleContext->GetStyleFont()->mLanguage,
+    styleContext->StyleFont()->mLanguage,
     aPresContext->GetUserFontSet(),
     *getter_AddRefs(fm));
   aRenderingContext.SetFont(fm);
 
   aRenderingContext.PushState();
   nsRect r = mRect + aPt;
   ApplyTransforms(aRenderingContext, r);
 
diff --git a/layout/mathml/nsMathMLContainerFrame.cpp b/layout/mathml/nsMathMLContainerFrame.cpp
--- a/layout/mathml/nsMathMLContainerFrame.cpp
+++ b/layout/mathml/nsMathMLContainerFrame.cpp
@@ -1202,17 +1202,17 @@ public:
 
     if (!mChildFrame)
       return *this;
 
     eMathMLFrameType prevFrameType = mChildFrameType;
     InitMetricsForChild();
 
     // add inter frame spacing
-    const nsStyleFont* font = mParentFrame->GetStyleFont();
+    const nsStyleFont* font = mParentFrame->StyleFont();
     nscoord space =
       GetInterFrameSpacing(font->mScriptLevel,
                            prevFrameType, mChildFrameType,
                            &mFromFrameType, &mCarrySpace);
     mX += space * GetThinSpace(font);
     return *this;
   }
 
@@ -1372,17 +1372,17 @@ GetInterFrameSpacingFor(int32_t         
   while (childFrame) {
     prevFrameType = childFrameType;
     childFrameType = nsMathMLFrame::GetMathMLFrameTypeFor(childFrame);
     nscoord space = GetInterFrameSpacing(aScriptLevel,
       prevFrameType, childFrameType, &fromFrameType, &carrySpace);
     if (aChildFrame == childFrame) {
       // get thinspace
       nsStyleContext* parentContext = aParentFrame->StyleContext();
-      nscoord thinSpace = GetThinSpace(parentContext->GetStyleFont());
+      nscoord thinSpace = GetThinSpace(parentContext->StyleFont());
       // we are done
       return space * thinSpace;
     }
     childFrame = childFrame->GetNextSibling();
   }
 
   NS_NOTREACHED("child not in the childlist of its parent");
   return 0;
@@ -1394,17 +1394,17 @@ nsMathMLContainerFrame::FixInterFrameSpa
   nscoord gap = 0;
   nsIContent* parentContent = mParent->GetContent();
   if (MOZ_UNLIKELY(!parentContent)) {
     return 0;
   }
   nsIAtom *parentTag = parentContent->Tag();
   if (parentContent->GetNameSpaceID() == kNameSpaceID_MathML && 
       (parentTag == nsGkAtoms::math || parentTag == nsGkAtoms::mtd_)) {
-    gap = GetInterFrameSpacingFor(GetStyleFont()->mScriptLevel, mParent, this);
+    gap = GetInterFrameSpacingFor(StyleFont()->mScriptLevel, mParent, this);
     // add our own italic correction
     nscoord leftCorrection = 0, italicCorrection = 0;
     GetItalicCorrection(mBoundingMetrics, leftCorrection, italicCorrection);
     gap += leftCorrection;
     // see if we should shift our children to account for the correction
     if (gap) {
       nsIFrame* childFrame = mFrames.FirstChild();
       while (childFrame) {
diff --git a/layout/mathml/nsMathMLFrame.cpp b/layout/mathml/nsMathMLFrame.cpp
--- a/layout/mathml/nsMathMLFrame.cpp
+++ b/layout/mathml/nsMathMLFrame.cpp
@@ -218,17 +218,17 @@ nsMathMLFrame::GetPresentationDataFrom(n
     // stop if we reach the root <math> tag
     nsIContent* content = frame->GetContent();
     NS_ASSERTION(content || !frame->GetParent(), // no assert for the root
                  "dangling frame without a content node"); 
     if (!content)
       break;
 
     if (content->Tag() == nsGkAtoms::math) {
-      const nsStyleDisplay* display = frame->GetStyleDisplay();
+      const nsStyleDisplay* display = frame->StyleDisplay();
       if (display->mDisplay == NS_STYLE_DISPLAY_BLOCK) {
         aPresentationData.flags |= NS_MATHML_DISPLAYSTYLE;
       }
       FindAttrDisplaystyle(content, aPresentationData);
       FindAttrDirectionality(content, aPresentationData);
       aPresentationData.mstyle = frame->GetFirstContinuation();
       break;
     }
@@ -327,17 +327,17 @@ nsMathMLFrame::CalcLength(nsPresContext*
   }
   if (aCSSValue.IsPixelLengthUnit()) {
     return aCSSValue.GetPixelLength();
   }
 
   nsCSSUnit unit = aCSSValue.GetUnit();
 
   if (eCSSUnit_EM == unit) {
-    const nsStyleFont* font = aStyleContext->GetStyleFont();
+    const nsStyleFont* font = aStyleContext->StyleFont();
     return NSToCoordRound(aCSSValue.GetFloatValue() * (float)font->mFont.size);
   }
   else if (eCSSUnit_XHeight == unit) {
     nsRefPtr<nsFontMetrics> fm;
     nsLayoutUtils::GetFontMetricsForStyleContext(aStyleContext,
                                                  getter_AddRefs(fm));
     nscoord xHeight = fm->XHeight();
     return NSToCoordRound(aCSSValue.GetFloatValue() * (float)xHeight);
@@ -466,14 +466,14 @@ void nsDisplayMathMLBar::Paint(nsDisplay
   aCtx->SetColor(mFrame->GetVisitedDependentColor(eCSSProperty_color));
   aCtx->FillRect(mRect + ToReferenceFrame());
 }
 
 nsresult
 nsMathMLFrame::DisplayBar(nsDisplayListBuilder* aBuilder,
                           nsIFrame* aFrame, const nsRect& aRect,
                           const nsDisplayListSet& aLists) {
-  if (!aFrame->GetStyleVisibility()->IsVisible() || aRect.IsEmpty())
+  if (!aFrame->StyleVisibility()->IsVisible() || aRect.IsEmpty())
     return NS_OK;
 
   return aLists.Content()->AppendNewToTop(new (aBuilder)
       nsDisplayMathMLBar(aBuilder, aFrame, aRect));
 }
diff --git a/layout/mathml/nsMathMLmencloseFrame.cpp b/layout/mathml/nsMathMLmencloseFrame.cpp
--- a/layout/mathml/nsMathMLmencloseFrame.cpp
+++ b/layout/mathml/nsMathMLmencloseFrame.cpp
@@ -773,15 +773,15 @@ void nsDisplayNotation::Paint(nsDisplayL
 
 nsresult
 nsMathMLmencloseFrame::DisplayNotation(nsDisplayListBuilder* aBuilder,
                                        nsIFrame* aFrame, const nsRect& aRect,
                                        const nsDisplayListSet& aLists,
                                        nscoord aThickness,
                                        nsMencloseNotation aType)
 {
-  if (!aFrame->GetStyleVisibility()->IsVisible() || aRect.IsEmpty() ||
+  if (!aFrame->StyleVisibility()->IsVisible() || aRect.IsEmpty() ||
       aThickness <= 0)
     return NS_OK;
 
   return aLists.Content()->AppendNewToTop(new (aBuilder)
       nsDisplayNotation(aBuilder, aFrame, aRect, aThickness, aType));
 }
diff --git a/layout/mathml/nsMathMLmfencedFrame.cpp b/layout/mathml/nsMathMLmfencedFrame.cpp
--- a/layout/mathml/nsMathMLmfencedFrame.cpp
+++ b/layout/mathml/nsMathMLmfencedFrame.cpp
@@ -209,17 +209,17 @@ nsMathMLmfencedFrame::Reflow(nsPresConte
                              nsReflowStatus&          aStatus)
 {
   nsresult rv;
   aDesiredSize.width = aDesiredSize.height = 0;
   aDesiredSize.ascent = 0;
   aDesiredSize.mBoundingMetrics = nsBoundingMetrics();
 
   int32_t i;
-  const nsStyleFont* font = GetStyleFont();
+  const nsStyleFont* font = StyleFont();
   nsRefPtr<nsFontMetrics> fm;
   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
   aReflowState.rendContext->SetFont(fm);
   nscoord axisHeight, em;
   GetAxisHeight(*aReflowState.rendContext, fm, axisHeight);
   GetEmHeight(fm, em);
   // leading to be left at the top and the bottom of stretched chars
   nscoord leading = NSToCoordRound(0.2f * em); 
@@ -575,17 +575,17 @@ GetMaxCharWidth(nsPresContext*       aPr
 }
 
 /* virtual */ nscoord
 nsMathMLmfencedFrame::GetIntrinsicWidth(nsRenderingContext* aRenderingContext)
 {
   nscoord width = 0;
 
   nsPresContext* presContext = PresContext();
-  const nsStyleFont* font = GetStyleFont();
+  const nsStyleFont* font = StyleFont();
   nsRefPtr<nsFontMetrics> fm;
   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
   nscoord em;
   GetEmHeight(fm, em);
 
   if (mOpenChar) {
     width +=
       GetMaxCharWidth(presContext, aRenderingContext, mOpenChar,
diff --git a/layout/mathml/nsMathMLmfracFrame.cpp b/layout/mathml/nsMathMLmfracFrame.cpp
--- a/layout/mathml/nsMathMLmfracFrame.cpp
+++ b/layout/mathml/nsMathMLmfracFrame.cpp
@@ -588,15 +588,15 @@ void nsDisplayMathMLSlash::Paint(nsDispl
   gfxCtx->Fill();
 }
 
 nsresult
 nsMathMLmfracFrame::DisplaySlash(nsDisplayListBuilder* aBuilder,
                                  nsIFrame* aFrame, const nsRect& aRect,
                                  nscoord aThickness,
                                  const nsDisplayListSet& aLists) {
-  if (!aFrame->GetStyleVisibility()->IsVisible() || aRect.IsEmpty())
+  if (!aFrame->StyleVisibility()->IsVisible() || aRect.IsEmpty())
     return NS_OK;
 
   return aLists.Content()->AppendNewToTop(new (aBuilder)
       nsDisplayMathMLSlash(aBuilder, aFrame, aRect, aThickness,
                            NS_MATHML_IS_RTL(mPresentationData.flags)));
 }
diff --git a/layout/mathml/nsMathMLmmultiscriptsFrame.cpp b/layout/mathml/nsMathMLmmultiscriptsFrame.cpp
--- a/layout/mathml/nsMathMLmmultiscriptsFrame.cpp
+++ b/layout/mathml/nsMathMLmmultiscriptsFrame.cpp
@@ -136,17 +136,17 @@ nsMathMLmmultiscriptsFrame::Place(nsRend
   ////////////////////////////////////////
   // Initialize super/sub shifts that
   // depend only on the current font
   ////////////////////////////////////////
 
   ProcessAttributes();
 
   // get x-height (an ex)
-  const nsStyleFont* font = GetStyleFont();
+  const nsStyleFont* font = StyleFont();
   nsRefPtr<nsFontMetrics> fm;
   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
   aRenderingContext.SetFont(fm);
 
   nscoord xHeight = fm->XHeight();
 
   nscoord ruleSize;
   GetRuleThickness (aRenderingContext, fm, ruleSize);
diff --git a/layout/mathml/nsMathMLmoFrame.cpp b/layout/mathml/nsMathMLmoFrame.cpp
--- a/layout/mathml/nsMathMLmoFrame.cpp
+++ b/layout/mathml/nsMathMLmoFrame.cpp
@@ -368,17 +368,17 @@ nsMathMLmoFrame::ProcessOperatorData()
       GetEmHeight(fm, em);
 
       mEmbellishData.leadingSpace = NSToCoordRound(lspace * em);
       mEmbellishData.trailingSpace = NSToCoordRound(rspace * em);
 
       // tuning if we don't want too much extra space when we are a script.
       // (with its fonts, TeX sets lspace=0 & rspace=0 as soon as scriptlevel>0.
       // Our fonts can be anything, so...)
-      if (GetStyleFont()->mScriptLevel > 0) {
+      if (StyleFont()->mScriptLevel > 0) {
         if (NS_MATHML_OPERATOR_EMBELLISH_IS_ISOLATED(mFlags)) {
           // could be an isolated accent or script, e.g., x^{+}, just zero out
           mEmbellishData.leadingSpace = 0;
           mEmbellishData.trailingSpace  = 0;
         }
         else if (!NS_MATHML_OPERATOR_HAS_EMBELLISH_ANCESTOR(mFlags)) {
           mEmbellishData.leadingSpace /= 2;
           mEmbellishData.trailingSpace  /= 2;
diff --git a/layout/mathml/nsMathMLmsubsupFrame.cpp b/layout/mathml/nsMathMLmsubsupFrame.cpp
--- a/layout/mathml/nsMathMLmsubsupFrame.cpp
+++ b/layout/mathml/nsMathMLmsubsupFrame.cpp
@@ -229,17 +229,17 @@ nsMathMLmsubsupFrame::PlaceSubSupScript(
     supScriptShift3 = NSToCoordRound(scaler3 * supScriptShift1);
   }
 
   // get sup script shift depending on current script level and display style
   // Rule 18c, App. G, TeXbook
   nscoord supScriptShift;
   nsPresentationData presentationData;
   aFrame->GetPresentationData(presentationData);
-  if ( aFrame->GetStyleFont()->mScriptLevel == 0 &&
+  if ( aFrame->StyleFont()->mScriptLevel == 0 &&
        NS_MATHML_IS_DISPLAYSTYLE(presentationData.flags) &&
       !NS_MATHML_IS_COMPRESSED(presentationData.flags)) {
     // Style D in TeXbook
     supScriptShift = supScriptShift1;
   }
   else if (NS_MATHML_IS_COMPRESSED(presentationData.flags)) {
     // Style C' in TeXbook = D',T',S',SS'
     supScriptShift = supScriptShift3;
diff --git a/layout/mathml/nsMathMLmsupFrame.cpp b/layout/mathml/nsMathMLmsupFrame.cpp
--- a/layout/mathml/nsMathMLmsupFrame.cpp
+++ b/layout/mathml/nsMathMLmsupFrame.cpp
@@ -159,17 +159,17 @@ nsMathMLmsupFrame::PlaceSuperScript(nsPr
     supScriptShift3 = NSToCoordRound(scaler3 * supScriptShift1);
   }
 
   // get sup script shift depending on current script level and display style
   // Rule 18c, App. G, TeXbook
   nscoord supScriptShift;
   nsPresentationData presentationData;
   aFrame->GetPresentationData (presentationData);
-  if ( aFrame->GetStyleFont()->mScriptLevel == 0 && 
+  if ( aFrame->StyleFont()->mScriptLevel == 0 && 
        NS_MATHML_IS_DISPLAYSTYLE(presentationData.flags) &&
       !NS_MATHML_IS_COMPRESSED(presentationData.flags)) {
     // Style D in TeXbook
     supScriptShift = supScriptShift1;
   }
   else if (NS_MATHML_IS_COMPRESSED(presentationData.flags)) {
     // Style C' in TeXbook = D',T',S',SS'
     supScriptShift = supScriptShift3;
diff --git a/layout/mathml/nsMathMLmtableFrame.cpp b/layout/mathml/nsMathMLmtableFrame.cpp
--- a/layout/mathml/nsMathMLmtableFrame.cpp
+++ b/layout/mathml/nsMathMLmtableFrame.cpp
@@ -137,19 +137,19 @@ IsTable(uint8_t aDisplay)
 {
   if ((aDisplay == NS_STYLE_DISPLAY_TABLE) ||
       (aDisplay == NS_STYLE_DISPLAY_INLINE_TABLE))
     return true;
   return false;
 }
 
 #define DEBUG_VERIFY_THAT_FRAME_IS(_frame, _expected) \
-  NS_ASSERTION(NS_STYLE_DISPLAY_##_expected == _frame->GetStyleDisplay()->mDisplay, "internal error");
+  NS_ASSERTION(NS_STYLE_DISPLAY_##_expected == _frame->StyleDisplay()->mDisplay, "internal error");
 #define DEBUG_VERIFY_THAT_FRAME_IS_TABLE(_frame) \
-  NS_ASSERTION(IsTable(_frame->GetStyleDisplay()->mDisplay), "internal error");
+  NS_ASSERTION(IsTable(_frame->StyleDisplay()->mDisplay), "internal error");
 #else
 #define DEBUG_VERIFY_THAT_FRAME_IS(_frame, _expected)
 #define DEBUG_VERIFY_THAT_FRAME_IS_TABLE(_frame)
 #endif
 
 // map attributes that depend on the index of the row:
 // rowalign, rowlines, XXX need rowspacing too
 static void
diff --git a/layout/printing/nsPrintEngine.cpp b/layout/printing/nsPrintEngine.cpp
--- a/layout/printing/nsPrintEngine.cpp
+++ b/layout/printing/nsPrintEngine.cpp
@@ -1852,17 +1852,17 @@ nsPrintEngine::SetupToPrintContent()
 nsresult
 nsPrintEngine::ReflowDocList(nsPrintObject* aPO, bool aSetPixelScale)
 {
   NS_ENSURE_ARG_POINTER(aPO);
 
   // Check to see if the subdocument's element has been hidden by the parent document
   if (aPO->mParent && aPO->mParent->mPresShell) {
     nsIFrame* frame = aPO->mContent ? aPO->mContent->GetPrimaryFrame() : nullptr;
-    if (!frame || !frame->GetStyleVisibility()->IsVisible()) {
+    if (!frame || !frame->StyleVisibility()->IsVisible()) {
       SetPrintPO(aPO, false);
       aPO->mInvisible = true;
       return NS_OK;
     }
   }
 
   UpdateZoomRatio(aPO, aSetPixelScale);
 
diff --git a/layout/style/ImageLoader.cpp b/layout/style/ImageLoader.cpp
--- a/layout/style/ImageLoader.cpp
+++ b/layout/style/ImageLoader.cpp
@@ -336,17 +336,17 @@ ImageLoader::DoRedraw(FrameSet* aFrameSe
 {
   NS_ASSERTION(aFrameSet, "Must have a frame set");
   NS_ASSERTION(mDocument, "Should have returned earlier!");
 
   FrameSet::size_type length = aFrameSet->Length();
   for (FrameSet::size_type i = 0; i < length; i++) {
     nsIFrame* frame = aFrameSet->ElementAt(i);
 
-    if (frame->GetStyleVisibility()->IsVisible()) {
+    if (frame->StyleVisibility()->IsVisible()) {
       FrameLayerBuilder::IterateRetainedDataFor(frame, InvalidateImagesCallback);
     }
   }
 }
 
 NS_IMPL_ADDREF(ImageLoader)
 NS_IMPL_RELEASE(ImageLoader)
 
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -540,17 +540,17 @@ nsAnimationManager::CheckAnimationRule(n
                                        mozilla::dom::Element* aElement)
 {
   if (!mPresContext->IsProcessingAnimationStyleChange()) {
     // Everything that causes our animation data to change triggers a
     // style change, which in turn triggers a non-animation restyle.
     // Likewise, when we initially construct frames, we're not in a
     // style change, but also not in an animation restyle.
 
-    const nsStyleDisplay *disp = aStyleContext->GetStyleDisplay();
+    const nsStyleDisplay *disp = aStyleContext->StyleDisplay();
     ElementAnimations *ea =
       GetElementAnimations(aElement, aStyleContext->GetPseudoType(), false);
     if (!ea &&
         disp->mAnimationNameCount == 1 &&
         disp->mAnimations[0].GetName().IsEmpty()) {
       return nullptr;
     }
 
@@ -727,17 +727,17 @@ ResolvedStyleCache::Get(nsPresContext *a
 void
 nsAnimationManager::BuildAnimations(nsStyleContext* aStyleContext,
                                     InfallibleTArray<ElementAnimation>& aAnimations)
 {
   NS_ABORT_IF_FALSE(aAnimations.IsEmpty(), "expect empty array");
 
   ResolvedStyleCache resolvedStyles;
 
-  const nsStyleDisplay *disp = aStyleContext->GetStyleDisplay();
+  const nsStyleDisplay *disp = aStyleContext->StyleDisplay();
   TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
   for (uint32_t animIdx = 0, animEnd = disp->mAnimationNameCount;
        animIdx != animEnd; ++animIdx) {
     const nsAnimation& aSrc = disp->mAnimations[animIdx];
     ElementAnimation& aDest = *aAnimations.AppendElement();
 
     aDest.mName = aSrc.GetName();
     aDest.mIterationCount = aSrc.GetIterationCount();
@@ -926,17 +926,17 @@ nsAnimationManager::BuildSegment(Infalli
 
   segment.mFromValue = fromValue;
   segment.mToValue = toValue;
   segment.mFromKey = aFromKey;
   segment.mToKey = aToKey;
   const nsTimingFunction *tf;
   if (aFromDeclaration &&
       aFromDeclaration->HasProperty(eCSSProperty_animation_timing_function)) {
-    tf = &aFromContext->GetStyleDisplay()->mAnimations[0].GetTimingFunction();
+    tf = &aFromContext->StyleDisplay()->mAnimations[0].GetTimingFunction();
   } else {
     tf = &aAnimation.GetTimingFunction();
   }
   segment.mTimingFunction.Init(*tf);
 
   return true;
 }
 
diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -624,56 +624,56 @@ nsComputedDOMStyle::IndexedGetter(uint32
 
 // Property getters...
 
 CSSValue*
 nsComputedDOMStyle::DoGetBinding()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   if (display->mBinding) {
     val->SetURI(display->mBinding->GetURI());
   } else {
     val->SetIdent(eCSSKeyword_none);
   }
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetClear()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mBreakType,
+  val->SetIdent(nsCSSProps::ValueToKeywordEnum(StyleDisplay()->mBreakType,
                                                nsCSSProps::kClearKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetCssFloat()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mFloats,
+  val->SetIdent(nsCSSProps::ValueToKeywordEnum(StyleDisplay()->mFloats,
                                                nsCSSProps::kFloatKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBottom()
 {
   return GetOffsetWidthFor(NS_SIDE_BOTTOM);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetStackSizing()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetIdent(GetStyleXUL()->mStretchStack ? eCSSKeyword_stretch_to_fit :
+  val->SetIdent(StyleXUL()->mStretchStack ? eCSSKeyword_stretch_to_fit :
                 eCSSKeyword_ignore);
   return val;
 }
 
 void
 nsComputedDOMStyle::SetToRGBAColor(nsROCSSPrimitiveValue* aValue,
                                    nscolor aColor)
 {
@@ -698,34 +698,34 @@ nsComputedDOMStyle::SetToRGBAColor(nsROC
 
   aValue->SetColor(rgbColor);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetColor()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  SetToRGBAColor(val, GetStyleColor()->mColor);
+  SetToRGBAColor(val, StyleColor()->mColor);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetOpacity()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetNumber(GetStyleDisplay()->mOpacity);
+  val->SetNumber(StyleDisplay()->mOpacity);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetColumnCount()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 
-  const nsStyleColumn* column = GetStyleColumn();
+  const nsStyleColumn* column = StyleColumn();
 
   if (column->mColumnCount == NS_STYLE_COLUMN_COUNT_AUTO) {
     val->SetIdent(eCSSKeyword_auto);
   } else {
     val->SetNumber(column->mColumnCount);
   }
 
   return val;
@@ -733,84 +733,84 @@ nsComputedDOMStyle::DoGetColumnCount()
 
 CSSValue*
 nsComputedDOMStyle::DoGetColumnWidth()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 
   // XXX fix the auto case. When we actually have a column frame, I think
   // we should return the computed column width.
-  SetValueToCoord(val, GetStyleColumn()->mColumnWidth, true);
+  SetValueToCoord(val, StyleColumn()->mColumnWidth, true);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetColumnGap()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 
-  const nsStyleColumn* column = GetStyleColumn();
+  const nsStyleColumn* column = StyleColumn();
   if (column->mColumnGap.GetUnit() == eStyleUnit_Normal) {
-    val->SetAppUnits(GetStyleFont()->mFont.size);
+    val->SetAppUnits(StyleFont()->mFont.size);
   } else {
-    SetValueToCoord(val, GetStyleColumn()->mColumnGap, true);
+    SetValueToCoord(val, StyleColumn()->mColumnGap, true);
   }
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetColumnFill()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleColumn()->mColumnFill,
+    nsCSSProps::ValueToKeywordEnum(StyleColumn()->mColumnFill,
                                    nsCSSProps::kColumnFillKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetColumnRuleWidth()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetAppUnits(GetStyleColumn()->GetComputedColumnRuleWidth());
+  val->SetAppUnits(StyleColumn()->GetComputedColumnRuleWidth());
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetColumnRuleStyle()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleColumn()->mColumnRuleStyle,
+    nsCSSProps::ValueToKeywordEnum(StyleColumn()->mColumnRuleStyle,
                                    nsCSSProps::kBorderStyleKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetColumnRuleColor()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 
-  const nsStyleColumn* column = GetStyleColumn();
+  const nsStyleColumn* column = StyleColumn();
   nscolor ruleColor;
   if (column->mColumnRuleColorIsForeground) {
-    ruleColor = GetStyleColor()->mColor;
+    ruleColor = StyleColor()->mColor;
   } else {
     ruleColor = column->mColumnRuleColor;
   }
 
   SetToRGBAColor(val, ruleColor);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetContent()
 {
-  const nsStyleContent *content = GetStyleContent();
+  const nsStyleContent *content = StyleContent();
 
   if (content->ContentCount() == 0) {
     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
     val->SetIdent(eCSSKeyword_none);
     return val;
   }
 
   if (content->ContentCount() == 1 &&
@@ -910,17 +910,17 @@ nsComputedDOMStyle::DoGetContent()
   }
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetCounterIncrement()
 {
-  const nsStyleContent *content = GetStyleContent();
+  const nsStyleContent *content = StyleContent();
 
   if (content->CounterIncrementCount() == 0) {
     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
     val->SetIdent(eCSSKeyword_none);
     return val;
   }
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(false);
@@ -951,17 +951,17 @@ nsComputedDOMStyle::DoGetTransformOrigin
   /* We need to build up a list of two values.  We'll call them
    * width and height.
    */
 
   /* Store things as a value list */
   nsDOMCSSValueList* valueList = GetROCSSValueList(false);
 
   /* Now, get the values. */
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   nsROCSSPrimitiveValue* width = GetROCSSPrimitiveValue();
   SetValueToCoord(width, display->mTransformOrigin[0], false,
                   &nsComputedDOMStyle::GetFrameBoundsWidthForTransform);
   valueList->AppendCSSValue(width);
 
   nsROCSSPrimitiveValue* height = GetROCSSPrimitiveValue();
   SetValueToCoord(height, display->mTransformOrigin[1], false,
@@ -988,17 +988,17 @@ nsComputedDOMStyle::DoGetPerspectiveOrig
   /* We need to build up a list of two values.  We'll call them
    * width and height.
    */
 
   /* Store things as a value list */
   nsDOMCSSValueList* valueList = GetROCSSValueList(false);
 
   /* Now, get the values. */
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   nsROCSSPrimitiveValue* width = GetROCSSPrimitiveValue();
   SetValueToCoord(width, display->mPerspectiveOrigin[0], false,
                   &nsComputedDOMStyle::GetFrameBoundsWidthForTransform);
   valueList->AppendCSSValue(width);
 
   nsROCSSPrimitiveValue* height = GetROCSSPrimitiveValue();
   SetValueToCoord(height, display->mPerspectiveOrigin[1], false,
@@ -1007,54 +1007,54 @@ nsComputedDOMStyle::DoGetPerspectiveOrig
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetPerspective()
 {
     nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-    if (GetStyleDisplay()->mChildPerspective.GetUnit() == eStyleUnit_Coord &&
-        GetStyleDisplay()->mChildPerspective.GetCoordValue() == 0.0) {
+    if (StyleDisplay()->mChildPerspective.GetUnit() == eStyleUnit_Coord &&
+        StyleDisplay()->mChildPerspective.GetCoordValue() == 0.0) {
         val->SetIdent(eCSSKeyword_none);
     } else {
-        SetValueToCoord(val, GetStyleDisplay()->mChildPerspective, false);
+        SetValueToCoord(val, StyleDisplay()->mChildPerspective, false);
     }
     return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBackfaceVisibility()
 {
     nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
     val->SetIdent(
-        nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mBackfaceVisibility,
+        nsCSSProps::ValueToKeywordEnum(StyleDisplay()->mBackfaceVisibility,
                                        nsCSSProps::kBackfaceVisibilityKTable));
     return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTransformStyle()
 {
     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
     val->SetIdent(
-        nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mTransformStyle,
+        nsCSSProps::ValueToKeywordEnum(StyleDisplay()->mTransformStyle,
                                        nsCSSProps::kTransformStyleKTable));
     return val;
 }
 
 /* If the property is "none", hand back "none" wrapped in a value.
  * Otherwise, compute the aggregate transform matrix and hands it back in a
  * "matrix" wrapper.
  */
 CSSValue*
 nsComputedDOMStyle::DoGetTransform()
 {
   /* First, get the display data.  We'll need it. */
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   /* If there are no transforms, then we should construct a single-element
    * entry and hand it back.
    */
   if (!display->mSpecifiedTransform) {
     nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
     /* Set it to "none." */
@@ -1140,17 +1140,17 @@ nsComputedDOMStyle::DoGetTransform()
 
   val->SetString(resultString);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetCounterReset()
 {
-  const nsStyleContent *content = GetStyleContent();
+  const nsStyleContent *content = StyleContent();
 
   if (content->CounterResetCount() == 0) {
     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
     val->SetIdent(eCSSKeyword_none);
     return val;
   }
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(false);
@@ -1170,17 +1170,17 @@ nsComputedDOMStyle::DoGetCounterReset()
   }
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetQuotes()
 {
-  const nsStyleQuotes *quotes = GetStyleQuotes();
+  const nsStyleQuotes *quotes = StyleQuotes();
 
   if (quotes->QuotesCount() == 0) {
     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
     val->SetIdent(eCSSKeyword_none);
     return val;
   }
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(false);
@@ -1203,17 +1203,17 @@ nsComputedDOMStyle::DoGetQuotes()
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFontFamily()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  const nsStyleFont* font = GetStyleFont();
+  const nsStyleFont* font = StyleFont();
 
   nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocumentWeak);
   NS_ASSERTION(doc, "document is required");
   nsIPresShell* presShell = doc->GetShell();
   NS_ASSERTION(presShell, "pres shell is required");
   nsPresContext *presContext = presShell->GetPresContext();
   NS_ASSERTION(presContext, "pres context is required");
 
@@ -1236,121 +1236,121 @@ nsComputedDOMStyle::DoGetFontFamily()
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFontSize()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  // Note: GetStyleFont()->mSize is the 'computed size';
-  // GetStyleFont()->mFont.size is the 'actual size'
-  val->SetAppUnits(GetStyleFont()->mSize);
+  // Note: StyleFont()->mSize is the 'computed size';
+  // StyleFont()->mFont.size is the 'actual size'
+  val->SetAppUnits(StyleFont()->mSize);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFontSizeAdjust()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 
-  const nsStyleFont *font = GetStyleFont();
+  const nsStyleFont *font = StyleFont();
 
   if (font->mFont.sizeAdjust) {
     val->SetNumber(font->mFont.sizeAdjust);
   } else {
     val->SetIdent(eCSSKeyword_none);
   }
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFontStretch()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleFont()->mFont.stretch,
+  val->SetIdent(nsCSSProps::ValueToKeywordEnum(StyleFont()->mFont.stretch,
                                                nsCSSProps::kFontStretchKTable));
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFontStyle()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleFont()->mFont.style,
+  val->SetIdent(nsCSSProps::ValueToKeywordEnum(StyleFont()->mFont.style,
                                                nsCSSProps::kFontStyleKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFontWeight()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  const nsStyleFont* font = GetStyleFont();
+  const nsStyleFont* font = StyleFont();
 
   uint16_t weight = font->mFont.weight;
   NS_ASSERTION(weight % 100 == 0, "unexpected value of font-weight");
   val->SetNumber(weight);
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFontVariant()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleFont()->mFont.variant,
+    nsCSSProps::ValueToKeywordEnum(StyleFont()->mFont.variant,
                                    nsCSSProps::kFontVariantKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFontFeatureSettings()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  const nsStyleFont* font = GetStyleFont();
+  const nsStyleFont* font = StyleFont();
   if (font->mFont.fontFeatureSettings.IsEmpty()) {
     val->SetIdent(eCSSKeyword_normal);
   } else {
     nsAutoString result;
     nsStyleUtil::AppendFontFeatureSettings(font->mFont.fontFeatureSettings,
                                            result);
     val->SetString(result);
   }
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFontLanguageOverride()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  const nsStyleFont* font = GetStyleFont();
+  const nsStyleFont* font = StyleFont();
   if (font->mFont.languageOverride.IsEmpty()) {
     val->SetIdent(eCSSKeyword_normal);
   } else {
     nsString str;
     nsStyleUtil::AppendEscapedCSSString(font->mFont.languageOverride, str);
     val->SetString(str);
   }
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::GetBackgroundList(uint8_t nsStyleBackground::Layer::* aMember,
                                       uint32_t nsStyleBackground::* aCount,
                                       const int32_t aTable[])
 {
-  const nsStyleBackground* bg = GetStyleBackground();
+  const nsStyleBackground* bg = StyleBackground();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   for (uint32_t i = 0, i_end = bg->*aCount; i < i_end; ++i) {
     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
     valueList->AppendCSSValue(val);
     val->SetIdent(nsCSSProps::ValueToKeywordEnum(bg->mLayers[i].*aMember,
                                                  aTable));
@@ -1374,17 +1374,17 @@ nsComputedDOMStyle::DoGetBackgroundClip(
                            &nsStyleBackground::mClipCount,
                            nsCSSProps::kBackgroundOriginKTable);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBackgroundColor()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  SetToRGBAColor(val, GetStyleBackground()->mBackgroundColor);
+  SetToRGBAColor(val, StyleBackground()->mBackgroundColor);
   return val;
 }
 
 
 static void
 SetValueToCalc(const nsStyleCoord::Calc *aCalc, nsROCSSPrimitiveValue *aValue)
 {
   nsRefPtr<nsROCSSPrimitiveValue> val = new nsROCSSPrimitiveValue;
@@ -1670,17 +1670,17 @@ nsComputedDOMStyle::SetValueToStyleImage
       NS_NOTREACHED("unexpected image type");
       break;
   }
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBackgroundImage()
 {
-  const nsStyleBackground* bg = GetStyleBackground();
+  const nsStyleBackground* bg = StyleBackground();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   for (uint32_t i = 0, i_end = bg->mImageCount; i < i_end; ++i) {
     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
     valueList->AppendCSSValue(val);
 
     const nsStyleImage& image = bg->mLayers[i].mImage;
@@ -1690,33 +1690,33 @@ nsComputedDOMStyle::DoGetBackgroundImage
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBackgroundInlinePolicy()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(nsCSSProps::ValueToKeywordEnum(
-                  GetStyleBackground()->mBackgroundInlinePolicy,
+                  StyleBackground()->mBackgroundInlinePolicy,
                   nsCSSProps::kBackgroundInlinePolicyKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBackgroundOrigin()
 {
   return GetBackgroundList(&nsStyleBackground::Layer::mOrigin,
                            &nsStyleBackground::mOriginCount,
                            nsCSSProps::kBackgroundOriginKTable);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBackgroundPosition()
 {
-  const nsStyleBackground* bg = GetStyleBackground();
+  const nsStyleBackground* bg = StyleBackground();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   for (uint32_t i = 0, i_end = bg->mPositionCount; i < i_end; ++i) {
     nsDOMCSSValueList *itemList = GetROCSSValueList(false);
     valueList->AppendCSSValue(itemList);
 
     nsROCSSPrimitiveValue *valX = GetROCSSPrimitiveValue();
@@ -1749,17 +1749,17 @@ nsComputedDOMStyle::DoGetBackgroundPosit
   }
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBackgroundRepeat()
 {
-  const nsStyleBackground* bg = GetStyleBackground();
+  const nsStyleBackground* bg = StyleBackground();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   for (uint32_t i = 0, i_end = bg->mRepeatCount; i < i_end; ++i) {
     nsDOMCSSValueList *itemList = GetROCSSValueList(false);
     valueList->AppendCSSValue(itemList);
 
     nsROCSSPrimitiveValue *valX = GetROCSSPrimitiveValue();
@@ -1797,17 +1797,17 @@ nsComputedDOMStyle::DoGetBackgroundRepea
   }
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBackgroundSize()
 {
-  const nsStyleBackground* bg = GetStyleBackground();
+  const nsStyleBackground* bg = StyleBackground();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   for (uint32_t i = 0, i_end = bg->mSizeCount; i < i_end; ++i) {
     const nsStyleBackground::Size &size = bg->mLayers[i].mSize;
 
     switch (size.mWidthType) {
       case nsStyleBackground::Size::eContain:
@@ -1904,65 +1904,65 @@ nsComputedDOMStyle::DoGetPaddingRight()
   return GetPaddingWidthFor(NS_SIDE_RIGHT);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBorderCollapse()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleTableBorder()->mBorderCollapse,
+    nsCSSProps::ValueToKeywordEnum(StyleTableBorder()->mBorderCollapse,
                                    nsCSSProps::kBorderCollapseKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBorderSpacing()
 {
   nsDOMCSSValueList *valueList = GetROCSSValueList(false);
 
   nsROCSSPrimitiveValue* xSpacing = GetROCSSPrimitiveValue();
   valueList->AppendCSSValue(xSpacing);
 
   nsROCSSPrimitiveValue* ySpacing = GetROCSSPrimitiveValue();
   valueList->AppendCSSValue(ySpacing);
 
-  const nsStyleTableBorder *border = GetStyleTableBorder();
+  const nsStyleTableBorder *border = StyleTableBorder();
   xSpacing->SetAppUnits(border->mBorderSpacingX);
   ySpacing->SetAppUnits(border->mBorderSpacingY);
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetCaptionSide()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleTableBorder()->mCaptionSide,
+    nsCSSProps::ValueToKeywordEnum(StyleTableBorder()->mCaptionSide,
                                    nsCSSProps::kCaptionSideKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetEmptyCells()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleTableBorder()->mEmptyCells,
+    nsCSSProps::ValueToKeywordEnum(StyleTableBorder()->mEmptyCells,
                                    nsCSSProps::kEmptyCellsKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTableLayout()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleTable()->mLayoutStrategy,
+    nsCSSProps::ValueToKeywordEnum(StyleTable()->mLayoutStrategy,
                                    nsCSSProps::kTableLayoutKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBorderTopStyle()
 {
   return GetBorderStyleFor(NS_SIDE_TOP);
@@ -2009,38 +2009,38 @@ CSSValue*
 nsComputedDOMStyle::DoGetBorderTopColors()
 {
   return GetBorderColorsFor(NS_SIDE_TOP);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBorderBottomLeftRadius()
 {
-  return GetEllipseRadii(GetStyleBorder()->mBorderRadius,
+  return GetEllipseRadii(StyleBorder()->mBorderRadius,
                          NS_CORNER_BOTTOM_LEFT, true);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBorderBottomRightRadius()
 {
-  return GetEllipseRadii(GetStyleBorder()->mBorderRadius,
+  return GetEllipseRadii(StyleBorder()->mBorderRadius,
                          NS_CORNER_BOTTOM_RIGHT, true);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBorderTopLeftRadius()
 {
-  return GetEllipseRadii(GetStyleBorder()->mBorderRadius,
+  return GetEllipseRadii(StyleBorder()->mBorderRadius,
                          NS_CORNER_TOP_LEFT, true);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBorderTopRightRadius()
 {
-  return GetEllipseRadii(GetStyleBorder()->mBorderRadius,
+  return GetEllipseRadii(StyleBorder()->mBorderRadius,
                          NS_CORNER_TOP_RIGHT, true);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBorderTopWidth()
 {
   return GetBorderWidthFor(NS_SIDE_TOP);
 }
@@ -2110,36 +2110,36 @@ nsComputedDOMStyle::DoGetMarginRightWidt
 {
   return GetMarginWidthFor(NS_SIDE_RIGHT);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetMarkerOffset()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  SetValueToCoord(val, GetStyleContent()->mMarkerOffset, false);
+  SetValueToCoord(val, StyleContent()->mMarkerOffset, false);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetOrient()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mOrient,
+    nsCSSProps::ValueToKeywordEnum(StyleDisplay()->mOrient,
                                    nsCSSProps::kOrientKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetOutlineWidth()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  const nsStyleOutline* outline = GetStyleOutline();
+  const nsStyleOutline* outline = StyleOutline();
 
   nscoord width;
   if (outline->GetOutlineStyle() == NS_STYLE_BORDER_STYLE_NONE) {
     NS_ASSERTION(outline->GetOutlineWidth(width) && width == 0,
                  "unexpected width");
     width = 0;
   } else {
 #ifdef DEBUG
@@ -2153,65 +2153,65 @@ nsComputedDOMStyle::DoGetOutlineWidth()
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetOutlineStyle()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleOutline()->GetOutlineStyle(),
+    nsCSSProps::ValueToKeywordEnum(StyleOutline()->GetOutlineStyle(),
                                    nsCSSProps::kOutlineStyleKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetOutlineOffset()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  val->SetAppUnits(GetStyleOutline()->mOutlineOffset);
+  val->SetAppUnits(StyleOutline()->mOutlineOffset);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetOutlineRadiusBottomLeft()
 {
-  return GetEllipseRadii(GetStyleOutline()->mOutlineRadius,
+  return GetEllipseRadii(StyleOutline()->mOutlineRadius,
                          NS_CORNER_BOTTOM_LEFT, false);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetOutlineRadiusBottomRight()
 {
-  return GetEllipseRadii(GetStyleOutline()->mOutlineRadius,
+  return GetEllipseRadii(StyleOutline()->mOutlineRadius,
                          NS_CORNER_BOTTOM_RIGHT, false);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetOutlineRadiusTopLeft()
 {
-  return GetEllipseRadii(GetStyleOutline()->mOutlineRadius,
+  return GetEllipseRadii(StyleOutline()->mOutlineRadius,
                          NS_CORNER_TOP_LEFT, false);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetOutlineRadiusTopRight()
 {
-  return GetEllipseRadii(GetStyleOutline()->mOutlineRadius,
+  return GetEllipseRadii(StyleOutline()->mOutlineRadius,
                          NS_CORNER_TOP_RIGHT, false);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetOutlineColor()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
   nscolor color;
-  if (!GetStyleOutline()->GetOutlineColor(color))
-    color = GetStyleColor()->mColor;
+  if (!StyleOutline()->GetOutlineColor(color))
+    color = StyleColor()->mColor;
 
   SetToRGBAColor(val, color);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::GetEllipseRadii(const nsStyleCorners& aRadius,
                                     uint8_t aFullCorner,
@@ -2338,35 +2338,35 @@ nsComputedDOMStyle::GetCSSShadowArray(ns
   }
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBoxShadow()
 {
-  return GetCSSShadowArray(GetStyleBorder()->mBoxShadow,
-                           GetStyleColor()->mColor,
+  return GetCSSShadowArray(StyleBorder()->mBoxShadow,
+                           StyleColor()->mColor,
                            true);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetZIndex()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  SetValueToCoord(val, GetStylePosition()->mZIndex, false);
+  SetValueToCoord(val, StylePosition()->mZIndex, false);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetListStyleImage()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  const nsStyleList* list = GetStyleList();
+  const nsStyleList* list = StyleList();
 
   if (!list->GetListStyleImage()) {
     val->SetIdent(eCSSKeyword_none);
   } else {
     nsCOMPtr<nsIURI> uri;
     if (list->GetListStyleImage()) {
       list->GetListStyleImage()->GetURI(getter_AddRefs(uri));
     }
@@ -2376,37 +2376,37 @@ nsComputedDOMStyle::DoGetListStyleImage(
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetListStylePosition()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleList()->mListStylePosition,
+    nsCSSProps::ValueToKeywordEnum(StyleList()->mListStylePosition,
                                    nsCSSProps::kListStylePositionKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetListStyleType()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleList()->mListStyleType,
+    nsCSSProps::ValueToKeywordEnum(StyleList()->mListStyleType,
                                    nsCSSProps::kListStyleKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetImageRegion()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 
-  const nsStyleList* list = GetStyleList();
+  const nsStyleList* list = StyleList();
 
   if (list->mImageRegion.width <= 0 || list->mImageRegion.height <= 0) {
     val->SetIdent(eCSSKeyword_auto);
   } else {
     // create the cssvalues for the sides, stick them in the rect object
     nsROCSSPrimitiveValue *topVal    = GetROCSSPrimitiveValue();
     nsROCSSPrimitiveValue *rightVal  = GetROCSSPrimitiveValue();
     nsROCSSPrimitiveValue *bottomVal = GetROCSSPrimitiveValue();
@@ -2427,71 +2427,71 @@ CSSValue*
 nsComputedDOMStyle::DoGetLineHeight()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 
   nscoord lineHeight;
   if (GetLineHeightCoord(lineHeight)) {
     val->SetAppUnits(lineHeight);
   } else {
-    SetValueToCoord(val, GetStyleText()->mLineHeight, true,
+    SetValueToCoord(val, StyleText()->mLineHeight, true,
                     nullptr, nsCSSProps::kLineHeightKTable);
   }
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetVerticalAlign()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  SetValueToCoord(val, GetStyleTextReset()->mVerticalAlign, false,
+  SetValueToCoord(val, StyleTextReset()->mVerticalAlign, false,
                   &nsComputedDOMStyle::GetLineHeightCoord,
                   nsCSSProps::kVerticalAlignKTable);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTextAlign()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleText()->mTextAlign,
+    nsCSSProps::ValueToKeywordEnum(StyleText()->mTextAlign,
                                    nsCSSProps::kTextAlignKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTextAlignLast()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleText()->mTextAlignLast,
+    nsCSSProps::ValueToKeywordEnum(StyleText()->mTextAlignLast,
                                    nsCSSProps::kTextAlignLastKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetMozTextBlink()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleTextReset()->mTextBlink,
+    nsCSSProps::ValueToKeywordEnum(StyleTextReset()->mTextBlink,
                                    nsCSSProps::kTextBlinkKTable));
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTextDecoration()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  const nsStyleTextReset* textReset = GetStyleTextReset();
+  const nsStyleTextReset* textReset = StyleTextReset();
 
   // If decoration style or color wasn't initial value, the author knew the
   // text-decoration is a shorthand property in CSS 3.
   // Return NULL in such cases.
   if (textReset->GetDecorationStyle() != NS_STYLE_TEXT_DECORATION_STYLE_SOLID) {
     return nullptr;
   }
 
@@ -2538,32 +2538,32 @@ nsComputedDOMStyle::DoGetTextDecoration(
 
 CSSValue*
 nsComputedDOMStyle::DoGetTextDecorationColor()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
   nscolor color;
   bool isForeground;
-  GetStyleTextReset()->GetDecorationColor(color, isForeground);
+  StyleTextReset()->GetDecorationColor(color, isForeground);
   if (isForeground) {
-    color = GetStyleColor()->mColor;
+    color = StyleColor()->mColor;
   }
 
   SetToRGBAColor(val, color);
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTextDecorationLine()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  int32_t intValue = GetStyleTextReset()->mTextDecorationLine;
+  int32_t intValue = StyleTextReset()->mTextDecorationLine;
 
   if (NS_STYLE_TEXT_DECORATION_LINE_NONE == intValue) {
     val->SetIdent(eCSSKeyword_none);
   } else {
     nsAutoString decorationLineString;
     // Clear the -moz-anchor-decoration bit and the OVERRIDE_ALL bits -- we
     // don't want these to appear in the computed style.
     intValue &= ~(NS_STYLE_TEXT_DECORATION_LINE_PREF_ANCHORS |
@@ -2578,35 +2578,35 @@ nsComputedDOMStyle::DoGetTextDecorationL
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTextDecorationStyle()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleTextReset()->GetDecorationStyle(),
+    nsCSSProps::ValueToKeywordEnum(StyleTextReset()->GetDecorationStyle(),
                                    nsCSSProps::kTextDecorationStyleKTable));
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTextIndent()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  SetValueToCoord(val, GetStyleText()->mTextIndent, false,
+  SetValueToCoord(val, StyleText()->mTextIndent, false,
                   &nsComputedDOMStyle::GetCBContentWidth);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTextOverflow()
 {
-  const nsStyleTextReset *style = GetStyleTextReset();
+  const nsStyleTextReset *style = StyleTextReset();
   nsROCSSPrimitiveValue *first = GetROCSSPrimitiveValue();
   const nsStyleTextOverflowSide *side = style->mTextOverflow.GetFirstValue();
   if (side->mType == NS_STYLE_TEXT_OVERFLOW_STRING) {
     nsString str;
     nsStyleUtil::AppendEscapedCSSString(side->mString, str);
     first->SetString(str);
   } else {
     first->SetIdent(
@@ -2632,110 +2632,110 @@ nsComputedDOMStyle::DoGetTextOverflow()
   valueList->AppendCSSValue(first);
   valueList->AppendCSSValue(second);
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTextShadow()
 {
-  return GetCSSShadowArray(GetStyleText()->mTextShadow,
-                           GetStyleColor()->mColor,
+  return GetCSSShadowArray(StyleText()->mTextShadow,
+                           StyleColor()->mColor,
                            false);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTextTransform()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleText()->mTextTransform,
+    nsCSSProps::ValueToKeywordEnum(StyleText()->mTextTransform,
                                    nsCSSProps::kTextTransformKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTabSize()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  val->SetNumber(GetStyleText()->mTabSize);
+  val->SetNumber(StyleText()->mTabSize);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetLetterSpacing()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  SetValueToCoord(val, GetStyleText()->mLetterSpacing, false);
+  SetValueToCoord(val, StyleText()->mLetterSpacing, false);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetWordSpacing()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetAppUnits(GetStyleText()->mWordSpacing);
+  val->SetAppUnits(StyleText()->mWordSpacing);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetWhiteSpace()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleText()->mWhiteSpace,
+    nsCSSProps::ValueToKeywordEnum(StyleText()->mWhiteSpace,
                                    nsCSSProps::kWhitespaceKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetWindowShadow()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleUIReset()->mWindowShadow,
+    nsCSSProps::ValueToKeywordEnum(StyleUIReset()->mWindowShadow,
                                    nsCSSProps::kWindowShadowKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetWordBreak()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleText()->mWordBreak,
+    nsCSSProps::ValueToKeywordEnum(StyleText()->mWordBreak,
                                    nsCSSProps::kWordBreakKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetWordWrap()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleText()->mWordWrap,
+    nsCSSProps::ValueToKeywordEnum(StyleText()->mWordWrap,
                                    nsCSSProps::kWordWrapKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetHyphens()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleText()->mHyphens,
+    nsCSSProps::ValueToKeywordEnum(StyleText()->mHyphens,
                                    nsCSSProps::kHyphensKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTextSizeAdjust()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  switch (GetStyleText()->mTextSizeAdjust) {
+  switch (StyleText()->mTextSizeAdjust) {
     default:
       NS_NOTREACHED("unexpected value");
       // fall through
     case NS_STYLE_TEXT_SIZE_ADJUST_AUTO:
       val->SetIdent(eCSSKeyword_auto);
       break;
     case NS_STYLE_TEXT_SIZE_ADJUST_NONE:
       val->SetIdent(eCSSKeyword_none);
@@ -2744,59 +2744,59 @@ nsComputedDOMStyle::DoGetTextSizeAdjust(
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetPointerEvents()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleVisibility()->mPointerEvents,
+    nsCSSProps::ValueToKeywordEnum(StyleVisibility()->mPointerEvents,
                                    nsCSSProps::kPointerEventsKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetVisibility()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleVisibility()->mVisible,
+  val->SetIdent(nsCSSProps::ValueToKeywordEnum(StyleVisibility()->mVisible,
                                                nsCSSProps::kVisibilityKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetDirection()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleVisibility()->mDirection,
+    nsCSSProps::ValueToKeywordEnum(StyleVisibility()->mDirection,
                                    nsCSSProps::kDirectionKTable));
   return val;
 }
 
 MOZ_STATIC_ASSERT(NS_STYLE_UNICODE_BIDI_NORMAL == 0,
                   "unicode-bidi style constants not as expected");
 
 CSSValue*
 nsComputedDOMStyle::DoGetUnicodeBidi()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleTextReset()->mUnicodeBidi,
+    nsCSSProps::ValueToKeywordEnum(StyleTextReset()->mUnicodeBidi,
                                    nsCSSProps::kUnicodeBidiKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetCursor()
 {
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
-  const nsStyleUserInterface *ui = GetStyleUserInterface();
+  const nsStyleUserInterface *ui = StyleUserInterface();
 
   for (nsCursorImage *item = ui->mCursorArray,
          *item_end = ui->mCursorArray + ui->mCursorArrayLength;
        item < item_end; ++item) {
     nsDOMCSSValueList *itemList = GetROCSSValueList(false);
     valueList->AppendCSSValue(itemList);
 
     nsCOMPtr<nsIURI> uri;
@@ -2823,92 +2823,92 @@ nsComputedDOMStyle::DoGetCursor()
   valueList->AppendCSSValue(val);
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetAppearance()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mAppearance,
+  val->SetIdent(nsCSSProps::ValueToKeywordEnum(StyleDisplay()->mAppearance,
                                                nsCSSProps::kAppearanceKTable));
   return val;
 }
 
 
 CSSValue*
 nsComputedDOMStyle::DoGetBoxAlign()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleXUL()->mBoxAlign,
+  val->SetIdent(nsCSSProps::ValueToKeywordEnum(StyleXUL()->mBoxAlign,
                                                nsCSSProps::kBoxAlignKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBoxDirection()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleXUL()->mBoxDirection,
+    nsCSSProps::ValueToKeywordEnum(StyleXUL()->mBoxDirection,
                                    nsCSSProps::kBoxDirectionKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBoxFlex()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetNumber(GetStyleXUL()->mBoxFlex);
+  val->SetNumber(StyleXUL()->mBoxFlex);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBoxOrdinalGroup()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetNumber(GetStyleXUL()->mBoxOrdinal);
+  val->SetNumber(StyleXUL()->mBoxOrdinal);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBoxOrient()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleXUL()->mBoxOrient,
+    nsCSSProps::ValueToKeywordEnum(StyleXUL()->mBoxOrient,
                                    nsCSSProps::kBoxOrientKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBoxPack()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleXUL()->mBoxPack,
+  val->SetIdent(nsCSSProps::ValueToKeywordEnum(StyleXUL()->mBoxPack,
                                                nsCSSProps::kBoxPackKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBoxSizing()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStylePosition()->mBoxSizing,
+    nsCSSProps::ValueToKeywordEnum(StylePosition()->mBoxSizing,
                                    nsCSSProps::kBoxSizingKTable));
   return val;
 }
 
 /* Border image properties */
 
 CSSValue*
 nsComputedDOMStyle::DoGetBorderImageSource()
 {
-  const nsStyleBorder* border = GetStyleBorder();
+  const nsStyleBorder* border = StyleBorder();
 
   imgIRequest* imgSrc = border->GetBorderImage();
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
   if (imgSrc) {
     nsCOMPtr<nsIURI> uri;
     imgSrc->GetURI(getter_AddRefs(uri));
     val->SetURI(uri);
   } else {
@@ -2918,17 +2918,17 @@ nsComputedDOMStyle::DoGetBorderImageSour
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBorderImageSlice()
 {
   nsDOMCSSValueList* valueList = GetROCSSValueList(false);
 
-  const nsStyleBorder* border = GetStyleBorder();
+  const nsStyleBorder* border = StyleBorder();
   // Four slice numbers.
   NS_FOR_CSS_SIDES (side) {
     nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
     valueList->AppendCSSValue(val);
     SetValueToCoord(val, border->mBorderImageSlice.Get(side), true, nullptr);
   }
 
   // Fill keyword.
@@ -2939,51 +2939,51 @@ nsComputedDOMStyle::DoGetBorderImageSlic
   }
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBorderImageWidth()
 {
-  const nsStyleBorder* border = GetStyleBorder();
+  const nsStyleBorder* border = StyleBorder();
   nsDOMCSSValueList* valueList = GetROCSSValueList(false);
   NS_FOR_CSS_SIDES (side) {
     nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
     valueList->AppendCSSValue(val);
     SetValueToCoord(val, border->mBorderImageWidth.Get(side),
                     true, nullptr);
   }
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBorderImageOutset()
 {
   nsDOMCSSValueList *valueList = GetROCSSValueList(false);
 
-  const nsStyleBorder* border = GetStyleBorder();
+  const nsStyleBorder* border = StyleBorder();
   // four slice numbers
   NS_FOR_CSS_SIDES (side) {
     nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
     valueList->AppendCSSValue(val);
     SetValueToCoord(val, border->mBorderImageOutset.Get(side),
                     true, nullptr);
   }
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetBorderImageRepeat()
 {
   nsDOMCSSValueList* valueList = GetROCSSValueList(false);
 
-  const nsStyleBorder* border = GetStyleBorder();
+  const nsStyleBorder* border = StyleBorder();
 
   // horizontal repeat
   nsROCSSPrimitiveValue* valX = GetROCSSPrimitiveValue();
   valueList->AppendCSSValue(valX);
   valX->SetIdent(
     nsCSSProps::ValueToKeywordEnum(border->mBorderImageRepeatH,
                                    nsCSSProps::kBorderImageRepeatKTable));
 
@@ -2997,33 +2997,33 @@ nsComputedDOMStyle::DoGetBorderImageRepe
 }
 
 #ifdef MOZ_FLEXBOX
 CSSValue*
 nsComputedDOMStyle::DoGetAlignItems()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStylePosition()->mAlignItems,
+    nsCSSProps::ValueToKeywordEnum(StylePosition()->mAlignItems,
                                    nsCSSProps::kAlignItemsKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetAlignSelf()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  uint8_t computedAlignSelf = GetStylePosition()->mAlignSelf;
+  uint8_t computedAlignSelf = StylePosition()->mAlignSelf;
 
   if (computedAlignSelf == NS_STYLE_ALIGN_SELF_AUTO) {
     // "align-self: auto" needs to compute to parent's align-items value.
     nsStyleContext* parentStyleContext = mStyleContextHolder->GetParent();
     if (parentStyleContext) {
       computedAlignSelf =
-        parentStyleContext->GetStylePosition()->mAlignItems;
+        parentStyleContext->StylePosition()->mAlignItems;
     } else {
       // No parent --> use default.
       computedAlignSelf = NS_STYLE_ALIGN_ITEMS_INITIAL_VALUE;
     }
   }
 
   NS_ABORT_IF_FALSE(computedAlignSelf != NS_STYLE_ALIGN_SELF_AUTO,
                     "Should have swapped out 'auto' for something non-auto");
@@ -3044,158 +3044,158 @@ nsComputedDOMStyle::DoGetFlexBasis()
   //   if (i'm a flex item) {
   //     if (my flex container is horizontal) {
   //       percentageBaseGetter = &nsComputedDOMStyle::GetCBContentWidth;
   //     } else {
   //       percentageBaseGetter = &nsComputedDOMStyle::GetCBContentHeight;
   //     }
   //   }
 
-  SetValueToCoord(val, GetStylePosition()->mFlexBasis, true,
+  SetValueToCoord(val, StylePosition()->mFlexBasis, true,
                   nullptr, nsCSSProps::kWidthKTable);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFlexDirection()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStylePosition()->mFlexDirection,
+    nsCSSProps::ValueToKeywordEnum(StylePosition()->mFlexDirection,
                                    nsCSSProps::kFlexDirectionKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFlexGrow()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  val->SetNumber(GetStylePosition()->mFlexGrow);
+  val->SetNumber(StylePosition()->mFlexGrow);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFlexShrink()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  val->SetNumber(GetStylePosition()->mFlexShrink);
+  val->SetNumber(StylePosition()->mFlexShrink);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetOrder()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  val->SetNumber(GetStylePosition()->mOrder);
+  val->SetNumber(StylePosition()->mOrder);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetJustifyContent()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStylePosition()->mJustifyContent,
+    nsCSSProps::ValueToKeywordEnum(StylePosition()->mJustifyContent,
                                    nsCSSProps::kJustifyContentKTable));
   return val;
 }
 #endif // MOZ_FLEXBOX
 
 CSSValue*
 nsComputedDOMStyle::DoGetFloatEdge()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleBorder()->mFloatEdge,
+    nsCSSProps::ValueToKeywordEnum(StyleBorder()->mFloatEdge,
                                    nsCSSProps::kFloatEdgeKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetForceBrokenImageIcon()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetNumber(GetStyleUIReset()->mForceBrokenImageIcon);
+  val->SetNumber(StyleUIReset()->mForceBrokenImageIcon);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetIMEMode()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleUIReset()->mIMEMode,
+    nsCSSProps::ValueToKeywordEnum(StyleUIReset()->mIMEMode,
                                    nsCSSProps::kIMEModeKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetUserFocus()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleUserInterface()->mUserFocus,
+    nsCSSProps::ValueToKeywordEnum(StyleUserInterface()->mUserFocus,
                                    nsCSSProps::kUserFocusKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetUserInput()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleUserInterface()->mUserInput,
+    nsCSSProps::ValueToKeywordEnum(StyleUserInterface()->mUserInput,
                                    nsCSSProps::kUserInputKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetUserModify()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleUserInterface()->mUserModify,
+    nsCSSProps::ValueToKeywordEnum(StyleUserInterface()->mUserModify,
                                    nsCSSProps::kUserModifyKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetUserSelect()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleUIReset()->mUserSelect,
+    nsCSSProps::ValueToKeywordEnum(StyleUIReset()->mUserSelect,
                                    nsCSSProps::kUserSelectKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetDisplay()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mDisplay,
+  val->SetIdent(nsCSSProps::ValueToKeywordEnum(StyleDisplay()->mDisplay,
                                                nsCSSProps::kDisplayKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetPosition()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mPosition,
+  val->SetIdent(nsCSSProps::ValueToKeywordEnum(StyleDisplay()->mPosition,
                                                nsCSSProps::kPositionKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetClip()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   if (display->mClipFlags == NS_STYLE_CLIP_AUTO) {
     val->SetIdent(eCSSKeyword_auto);
   } else {
     // create the cssvalues for the sides, stick them in the rect object
     nsROCSSPrimitiveValue *topVal    = GetROCSSPrimitiveValue();
     nsROCSSPrimitiveValue *rightVal  = GetROCSSPrimitiveValue();
     nsROCSSPrimitiveValue *bottomVal = GetROCSSPrimitiveValue();
@@ -3229,17 +3229,17 @@ nsComputedDOMStyle::DoGetClip()
   }
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetOverflow()
 {
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   if (display->mOverflowX != display->mOverflowY) {
     // No value to return.  We can't express this combination of
     // values as a shorthand.
     return nullptr;
   }
 
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
@@ -3248,105 +3248,105 @@ nsComputedDOMStyle::DoGetOverflow()
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetOverflowX()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mOverflowX,
+    nsCSSProps::ValueToKeywordEnum(StyleDisplay()->mOverflowX,
                                    nsCSSProps::kOverflowSubKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetOverflowY()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mOverflowY,
+    nsCSSProps::ValueToKeywordEnum(StyleDisplay()->mOverflowY,
                                    nsCSSProps::kOverflowSubKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetResize()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mResize,
+  val->SetIdent(nsCSSProps::ValueToKeywordEnum(StyleDisplay()->mResize,
                                                nsCSSProps::kResizeKTable));
   return val;
 }
 
 
 CSSValue*
 nsComputedDOMStyle::DoGetPageBreakAfter()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 
-  const nsStyleDisplay *display = GetStyleDisplay();
+  const nsStyleDisplay *display = StyleDisplay();
 
   if (display->mBreakAfter) {
     val->SetIdent(eCSSKeyword_always);
   } else {
     val->SetIdent(eCSSKeyword_auto);
   }
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetPageBreakBefore()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 
-  const nsStyleDisplay *display = GetStyleDisplay();
+  const nsStyleDisplay *display = StyleDisplay();
 
   if (display->mBreakBefore) {
     val->SetIdent(eCSSKeyword_always);
   } else {
     val->SetIdent(eCSSKeyword_auto);
   }
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetPageBreakInside()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mBreakInside,
+  val->SetIdent(nsCSSProps::ValueToKeywordEnum(StyleDisplay()->mBreakInside,
                                                nsCSSProps::kPageBreakInsideKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetHeight()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 
   bool calcHeight = false;
 
   if (mInnerFrame) {
     calcHeight = true;
 
-    const nsStyleDisplay* displayData = GetStyleDisplay();
+    const nsStyleDisplay* displayData = StyleDisplay();
     if (displayData->mDisplay == NS_STYLE_DISPLAY_INLINE &&
         !(mInnerFrame->IsFrameOfType(nsIFrame::eReplaced))) {
       calcHeight = false;
     }
   }
 
   if (calcHeight) {
     AssertFlushedPendingReflows();
 
     val->SetAppUnits(mInnerFrame->GetContentRect().height);
   } else {
-    const nsStylePosition *positionData = GetStylePosition();
+    const nsStylePosition *positionData = StylePosition();
 
     nscoord minHeight =
       StyleCoordToNSCoord(positionData->mMinHeight,
                           &nsComputedDOMStyle::GetCBContentHeight, 0, true);
 
     nscoord maxHeight =
       StyleCoordToNSCoord(positionData->mMaxHeight,
                           &nsComputedDOMStyle::GetCBContentHeight,
@@ -3364,29 +3364,29 @@ nsComputedDOMStyle::DoGetWidth()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 
   bool calcWidth = false;
 
   if (mInnerFrame) {
     calcWidth = true;
 
-    const nsStyleDisplay *displayData = GetStyleDisplay();
+    const nsStyleDisplay *displayData = StyleDisplay();
     if (displayData->mDisplay == NS_STYLE_DISPLAY_INLINE &&
         !(mInnerFrame->IsFrameOfType(nsIFrame::eReplaced))) {
       calcWidth = false;
     }
   }
 
   if (calcWidth) {
     AssertFlushedPendingReflows();
 
     val->SetAppUnits(mInnerFrame->GetContentRect().width);
   } else {
-    const nsStylePosition *positionData = GetStylePosition();
+    const nsStylePosition *positionData = StylePosition();
 
     nscoord minWidth =
       StyleCoordToNSCoord(positionData->mMinWidth,
                           &nsComputedDOMStyle::GetCBContentWidth, 0, true);
 
     nscoord maxWidth =
       StyleCoordToNSCoord(positionData->mMaxWidth,
                           &nsComputedDOMStyle::GetCBContentWidth,
@@ -3398,36 +3398,36 @@ nsComputedDOMStyle::DoGetWidth()
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetMaxHeight()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  SetValueToCoord(val, GetStylePosition()->mMaxHeight, true,
+  SetValueToCoord(val, StylePosition()->mMaxHeight, true,
                   &nsComputedDOMStyle::GetCBContentHeight);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetMaxWidth()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  SetValueToCoord(val, GetStylePosition()->mMaxWidth, true,
+  SetValueToCoord(val, StylePosition()->mMaxWidth, true,
                   &nsComputedDOMStyle::GetCBContentWidth,
                   nsCSSProps::kWidthKTable);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetMinHeight()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  nsStyleCoord minHeight = GetStylePosition()->mMinHeight;
+  nsStyleCoord minHeight = StylePosition()->mMinHeight;
 
   if (eStyleUnit_Auto == minHeight.GetUnit()) {
     // In non-flexbox contexts, "min-height: auto" means "min-height: 0"
     // XXXdholbert For flex items, we should set |minHeight| to the
     // -moz-min-content keyword, instead of 0, once we support -moz-min-content
     // as a height value.
     minHeight.SetCoordValue(0);
   }
@@ -3437,17 +3437,17 @@ nsComputedDOMStyle::DoGetMinHeight()
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetMinWidth()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 
-  nsStyleCoord minWidth = GetStylePosition()->mMinWidth;
+  nsStyleCoord minWidth = StylePosition()->mMinWidth;
 
   if (eStyleUnit_Auto == minWidth.GetUnit()) {
     // "min-width: auto" means "0", unless we're a flex item in a horizontal
     // flex container, in which case it means "min-content"
     minWidth.SetCoordValue(0);
 #ifdef MOZ_FLEXBOX
     if (mOuterFrame && mOuterFrame->IsFlexItem()) {
       nsIFrame* flexContainer = mOuterFrame->GetParent();
@@ -3502,17 +3502,17 @@ nsComputedDOMStyle::GetROCSSValueList(bo
   NS_ASSERTION(valueList != 0, "ran out of memory");
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::GetOffsetWidthFor(mozilla::css::Side aSide)
 {
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   AssertFlushedPendingReflows();
 
   uint8_t position = display->mPosition;
   if (!mOuterFrame) {
     // GetRelativeOffset and GetAbsoluteOffset don't handle elements
     // without frames in any sensible way.  GetStaticOffset, however,
     // is perfect for that case.
@@ -3598,17 +3598,17 @@ MOZ_STATIC_ASSERT(NS_SIDE_TOP == 0 && NS
                   "box side constants not as expected for NS_OPPOSITE_SIDE");
 #define NS_OPPOSITE_SIDE(s_) mozilla::css::Side(((s_) + 2) & 3)
 
 CSSValue*
 nsComputedDOMStyle::GetRelativeOffset(mozilla::css::Side aSide)
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 
-  const nsStylePosition* positionData = GetStylePosition();
+  const nsStylePosition* positionData = StylePosition();
   int32_t sign = 1;
   nsStyleCoord coord = positionData->mOffset.Get(aSide);
 
   NS_ASSERTION(coord.GetUnit() == eStyleUnit_Coord ||
                coord.GetUnit() == eStyleUnit_Percent ||
                coord.GetUnit() == eStyleUnit_Auto ||
                coord.IsCalcUnit(),
                "Unexpected unit");
@@ -3628,43 +3628,43 @@ nsComputedDOMStyle::GetRelativeOffset(mo
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::GetStaticOffset(mozilla::css::Side aSide)
 
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  SetValueToCoord(val, GetStylePosition()->mOffset.Get(aSide), false);
+  SetValueToCoord(val, StylePosition()->mOffset.Get(aSide), false);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::GetPaddingWidthFor(mozilla::css::Side aSide)
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
   if (!mInnerFrame) {
-    SetValueToCoord(val, GetStylePadding()->mPadding.Get(aSide), true);
+    SetValueToCoord(val, StylePadding()->mPadding.Get(aSide), true);
   } else {
     AssertFlushedPendingReflows();
 
     val->SetAppUnits(mInnerFrame->GetUsedPadding().Side(aSide));
   }
 
   return val;
 }
 
 bool
 nsComputedDOMStyle::GetLineHeightCoord(nscoord& aCoord)
 {
   AssertFlushedPendingReflows();
 
   nscoord blockHeight = NS_AUTOHEIGHT;
-  if (GetStyleText()->mLineHeight.GetUnit() == eStyleUnit_Enumerated) {
+  if (StyleText()->mLineHeight.GetUnit() == eStyleUnit_Enumerated) {
     if (!mInnerFrame)
       return false;
 
     if (nsLayoutUtils::IsNonWrapperBlock(mInnerFrame)) {
       blockHeight = mInnerFrame->GetContentRect().height;
     } else {
       GetCBContentHeight(blockHeight);
     }
@@ -3673,30 +3673,30 @@ nsComputedDOMStyle::GetLineHeightCoord(n
   // lie about font size inflation since we lie about font size (since
   // the inflation only applies to text)
   aCoord = nsHTMLReflowState::CalcLineHeight(mStyleContextHolder,
                                              blockHeight, 1.0f);
 
   // CalcLineHeight uses font->mFont.size, but we want to use
   // font->mSize as the font size.  Adjust for that.  Also adjust for
   // the text zoom, if any.
-  const nsStyleFont* font = GetStyleFont();
+  const nsStyleFont* font = StyleFont();
   float fCoord = float(aCoord) / mPresShell->GetPresContext()->TextZoom();
   if (font->mFont.size != font->mSize) {
     fCoord = fCoord * (float(font->mSize) / float(font->mFont.size));
   }
   aCoord = NSToCoordRound(fCoord);
 
   return true;
 }
 
 CSSValue*
 nsComputedDOMStyle::GetBorderColorsFor(mozilla::css::Side aSide)
 {
-  const nsStyleBorder *border = GetStyleBorder();
+  const nsStyleBorder *border = StyleBorder();
 
   if (border->mBorderColors) {
     nsBorderColors* borderColors = border->mBorderColors[aSide];
     if (borderColors) {
       nsDOMCSSValueList *valueList = GetROCSSValueList(false);
 
       do {
         nsROCSSPrimitiveValue *primitive = GetROCSSPrimitiveValue();
@@ -3721,46 +3721,46 @@ nsComputedDOMStyle::GetBorderWidthFor(mo
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
   nscoord width;
   if (mInnerFrame) {
     AssertFlushedPendingReflows();
     width = mInnerFrame->GetUsedBorder().Side(aSide);
   } else {
-    width = GetStyleBorder()->GetComputedBorderWidth(aSide);
+    width = StyleBorder()->GetComputedBorderWidth(aSide);
   }
   val->SetAppUnits(width);
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::GetBorderColorFor(mozilla::css::Side aSide)
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
   nscolor color;
   bool foreground;
-  GetStyleBorder()->GetBorderColor(aSide, color, foreground);
+  StyleBorder()->GetBorderColor(aSide, color, foreground);
   if (foreground) {
-    color = GetStyleColor()->mColor;
+    color = StyleColor()->mColor;
   }
 
   SetToRGBAColor(val, color);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::GetMarginWidthFor(mozilla::css::Side aSide)
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
   if (!mInnerFrame) {
-    SetValueToCoord(val, GetStyleMargin()->mMargin.Get(aSide), false);
+    SetValueToCoord(val, StyleMargin()->mMargin.Get(aSide), false);
   } else {
     AssertFlushedPendingReflows();
 
     // For tables, GetUsedMargin always returns an empty margin, so we
     // should read the margin from the outer table frame instead.
     val->SetAppUnits(mOuterFrame->GetUsedMargin().Side(aSide));
     NS_ASSERTION(mOuterFrame == mInnerFrame ||
                  mInnerFrame->GetUsedMargin() == nsMargin(0, 0, 0, 0),
@@ -3770,17 +3770,17 @@ nsComputedDOMStyle::GetMarginWidthFor(mo
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::GetBorderStyleFor(mozilla::css::Side aSide)
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleBorder()->GetBorderStyle(aSide),
+    nsCSSProps::ValueToKeywordEnum(StyleBorder()->GetBorderStyle(aSide),
                                    nsCSSProps::kBorderStyleKTable));
   return val;
 }
 
 void
 nsComputedDOMStyle::SetValueToCoord(nsROCSSPrimitiveValue* aValue,
                                     const nsStyleCoord& aCoord,
                                     bool aClampNegativeCalc,
@@ -3988,17 +3988,17 @@ nsComputedDOMStyle::GetFrameBoundsHeight
   return true;
 }
 
 CSSValue*
 nsComputedDOMStyle::GetSVGPaintFor(bool aFill)
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  const nsStyleSVG* svg = GetStyleSVG();
+  const nsStyleSVG* svg = StyleSVG();
   const nsStyleSVGPaint* paint = nullptr;
 
   if (aFill)
     paint = &svg->mFill;
   else
     paint = &svg->mStroke;
 
   nsAutoString paintString;
@@ -4053,60 +4053,60 @@ nsComputedDOMStyle::DoGetStroke()
   return GetSVGPaintFor(false);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetMarkerEnd()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  const nsStyleSVG* svg = GetStyleSVG();
+  const nsStyleSVG* svg = StyleSVG();
 
   if (svg->mMarkerEnd)
     val->SetURI(svg->mMarkerEnd);
   else
     val->SetIdent(eCSSKeyword_none);
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetMarkerMid()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  const nsStyleSVG* svg = GetStyleSVG();
+  const nsStyleSVG* svg = StyleSVG();
 
   if (svg->mMarkerMid)
     val->SetURI(svg->mMarkerMid);
   else
     val->SetIdent(eCSSKeyword_none);
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetMarkerStart()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  const nsStyleSVG* svg = GetStyleSVG();
+  const nsStyleSVG* svg = StyleSVG();
 
   if (svg->mMarkerStart)
     val->SetURI(svg->mMarkerStart);
   else
     val->SetIdent(eCSSKeyword_none);
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetStrokeDasharray()
 {
-  const nsStyleSVG* svg = GetStyleSVG();
+  const nsStyleSVG* svg = StyleSVG();
 
   if (!svg->mStrokeDasharrayLength || !svg->mStrokeDasharray) {
     nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
     val->SetIdent(eCSSKeyword_none);
     return val;
   }
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
@@ -4120,279 +4120,279 @@ nsComputedDOMStyle::DoGetStrokeDasharray
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetStrokeDashoffset()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  SetValueToCoord(val, GetStyleSVG()->mStrokeDashoffset, false);
+  SetValueToCoord(val, StyleSVG()->mStrokeDashoffset, false);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetStrokeWidth()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  SetValueToCoord(val, GetStyleSVG()->mStrokeWidth, true);
+  SetValueToCoord(val, StyleSVG()->mStrokeWidth, true);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetVectorEffect()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleSVGReset()->mVectorEffect,
+  val->SetIdent(nsCSSProps::ValueToKeywordEnum(StyleSVGReset()->mVectorEffect,
                                                nsCSSProps::kVectorEffectKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFillOpacity()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetNumber(GetStyleSVG()->mFillOpacity);
+  val->SetNumber(StyleSVG()->mFillOpacity);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFloodOpacity()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetNumber(GetStyleSVGReset()->mFloodOpacity);
+  val->SetNumber(StyleSVGReset()->mFloodOpacity);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetStopOpacity()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetNumber(GetStyleSVGReset()->mStopOpacity);
+  val->SetNumber(StyleSVGReset()->mStopOpacity);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetStrokeMiterlimit()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetNumber(GetStyleSVG()->mStrokeMiterlimit);
+  val->SetNumber(StyleSVG()->mStrokeMiterlimit);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetStrokeOpacity()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  val->SetNumber(GetStyleSVG()->mStrokeOpacity);
+  val->SetNumber(StyleSVG()->mStrokeOpacity);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetClipRule()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(nsCSSProps::ValueToKeywordEnum(
-                  GetStyleSVG()->mClipRule, nsCSSProps::kFillRuleKTable));
+                  StyleSVG()->mClipRule, nsCSSProps::kFillRuleKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFillRule()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(nsCSSProps::ValueToKeywordEnum(
-                  GetStyleSVG()->mFillRule, nsCSSProps::kFillRuleKTable));
+                  StyleSVG()->mFillRule, nsCSSProps::kFillRuleKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetStrokeLinecap()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mStrokeLinecap,
+    nsCSSProps::ValueToKeywordEnum(StyleSVG()->mStrokeLinecap,
                                    nsCSSProps::kStrokeLinecapKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetStrokeLinejoin()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mStrokeLinejoin,
+    nsCSSProps::ValueToKeywordEnum(StyleSVG()->mStrokeLinejoin,
                                    nsCSSProps::kStrokeLinejoinKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTextAnchor()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mTextAnchor,
+    nsCSSProps::ValueToKeywordEnum(StyleSVG()->mTextAnchor,
                                    nsCSSProps::kTextAnchorKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetColorInterpolation()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mColorInterpolation,
+    nsCSSProps::ValueToKeywordEnum(StyleSVG()->mColorInterpolation,
                                    nsCSSProps::kColorInterpolationKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetColorInterpolationFilters()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mColorInterpolationFilters,
+    nsCSSProps::ValueToKeywordEnum(StyleSVG()->mColorInterpolationFilters,
                                    nsCSSProps::kColorInterpolationKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetDominantBaseline()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleSVGReset()->mDominantBaseline,
+    nsCSSProps::ValueToKeywordEnum(StyleSVGReset()->mDominantBaseline,
                                    nsCSSProps::kDominantBaselineKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetImageRendering()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mImageRendering,
+    nsCSSProps::ValueToKeywordEnum(StyleSVG()->mImageRendering,
                                    nsCSSProps::kImageRenderingKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetShapeRendering()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mShapeRendering,
+    nsCSSProps::ValueToKeywordEnum(StyleSVG()->mShapeRendering,
                                    nsCSSProps::kShapeRenderingKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTextRendering()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mTextRendering,
+    nsCSSProps::ValueToKeywordEnum(StyleSVG()->mTextRendering,
                                    nsCSSProps::kTextRenderingKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFloodColor()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  SetToRGBAColor(val, GetStyleSVGReset()->mFloodColor);
+  SetToRGBAColor(val, StyleSVGReset()->mFloodColor);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetLightingColor()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  SetToRGBAColor(val, GetStyleSVGReset()->mLightingColor);
+  SetToRGBAColor(val, StyleSVGReset()->mLightingColor);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetStopColor()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  SetToRGBAColor(val, GetStyleSVGReset()->mStopColor);
+  SetToRGBAColor(val, StyleSVGReset()->mStopColor);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetClipPath()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  const nsStyleSVGReset* svg = GetStyleSVGReset();
+  const nsStyleSVGReset* svg = StyleSVGReset();
 
   if (svg->mClipPath)
     val->SetURI(svg->mClipPath);
   else
     val->SetIdent(eCSSKeyword_none);
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetFilter()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  const nsStyleSVGReset* svg = GetStyleSVGReset();
+  const nsStyleSVGReset* svg = StyleSVGReset();
 
   if (svg->mFilter)
     val->SetURI(svg->mFilter);
   else
     val->SetIdent(eCSSKeyword_none);
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetMask()
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 
-  const nsStyleSVGReset* svg = GetStyleSVGReset();
+  const nsStyleSVGReset* svg = StyleSVGReset();
 
   if (svg->mMask)
     val->SetURI(svg->mMask);
   else
     val->SetIdent(eCSSKeyword_none);
 
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetMaskType()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   val->SetIdent(
-    nsCSSProps::ValueToKeywordEnum(GetStyleSVGReset()->mMaskType,
+    nsCSSProps::ValueToKeywordEnum(StyleSVGReset()->mMaskType,
                                    nsCSSProps::kMaskTypeKTable));
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetPaintOrder()
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   nsAutoString string;
-  uint8_t paintOrder = GetStyleSVG()->mPaintOrder;
+  uint8_t paintOrder = StyleSVG()->mPaintOrder;
   nsStyleUtil::AppendPaintOrderValue(paintOrder, string);
   val->SetString(string);
   return val;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTransitionDelay()
 {
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   NS_ABORT_IF_FALSE(display->mTransitionDelayCount > 0,
                     "first item must be explicit");
   uint32_t i = 0;
   do {
     const nsTransition *transition = &display->mTransitions[i];
@@ -4402,17 +4402,17 @@ nsComputedDOMStyle::DoGetTransitionDelay
   } while (++i < display->mTransitionDelayCount);
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTransitionDuration()
 {
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   NS_ABORT_IF_FALSE(display->mTransitionDurationCount > 0,
                     "first item must be explicit");
   uint32_t i = 0;
   do {
     const nsTransition *transition = &display->mTransitions[i];
@@ -4423,17 +4423,17 @@ nsComputedDOMStyle::DoGetTransitionDurat
   } while (++i < display->mTransitionDurationCount);
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTransitionProperty()
 {
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   NS_ABORT_IF_FALSE(display->mTransitionPropertyCount > 0,
                     "first item must be explicit");
   uint32_t i = 0;
   do {
     const nsTransition *transition = &display->mTransitions[i];
@@ -4489,17 +4489,17 @@ nsComputedDOMStyle::AppendTimingFunction
     }
   }
   timingFunction->SetString(tmp);
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetTransitionTimingFunction()
 {
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   NS_ABORT_IF_FALSE(display->mTransitionTimingFunctionCount > 0,
                     "first item must be explicit");
   uint32_t i = 0;
   do {
     AppendTimingFunction(valueList,
@@ -4507,17 +4507,17 @@ nsComputedDOMStyle::DoGetTransitionTimin
   } while (++i < display->mTransitionTimingFunctionCount);
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetAnimationName()
 {
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   NS_ABORT_IF_FALSE(display->mAnimationNameCount > 0,
                     "first item must be explicit");
   uint32_t i = 0;
   do {
     const nsAnimation *animation = &display->mAnimations[i];
@@ -4535,17 +4535,17 @@ nsComputedDOMStyle::DoGetAnimationName()
   } while (++i < display->mAnimationNameCount);
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetAnimationDelay()
 {
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   NS_ABORT_IF_FALSE(display->mAnimationDelayCount > 0,
                     "first item must be explicit");
   uint32_t i = 0;
   do {
     const nsAnimation *animation = &display->mAnimations[i];
@@ -4555,17 +4555,17 @@ nsComputedDOMStyle::DoGetAnimationDelay(
   } while (++i < display->mAnimationDelayCount);
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetAnimationDuration()
 {
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   NS_ABORT_IF_FALSE(display->mAnimationDurationCount > 0,
                     "first item must be explicit");
   uint32_t i = 0;
   do {
     const nsAnimation *animation = &display->mAnimations[i];
@@ -4576,17 +4576,17 @@ nsComputedDOMStyle::DoGetAnimationDurati
   } while (++i < display->mAnimationDurationCount);
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetAnimationTimingFunction()
 {
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   NS_ABORT_IF_FALSE(display->mAnimationTimingFunctionCount > 0,
                     "first item must be explicit");
   uint32_t i = 0;
   do {
     AppendTimingFunction(valueList,
@@ -4594,17 +4594,17 @@ nsComputedDOMStyle::DoGetAnimationTiming
   } while (++i < display->mAnimationTimingFunctionCount);
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetAnimationDirection()
 {
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   NS_ABORT_IF_FALSE(display->mAnimationDirectionCount > 0,
                     "first item must be explicit");
   uint32_t i = 0;
   do {
     const nsAnimation *animation = &display->mAnimations[i];
@@ -4616,17 +4616,17 @@ nsComputedDOMStyle::DoGetAnimationDirect
   } while (++i < display->mAnimationDirectionCount);
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetAnimationFillMode()
 {
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   NS_ABORT_IF_FALSE(display->mAnimationFillModeCount > 0,
                     "first item must be explicit");
   uint32_t i = 0;
   do {
     const nsAnimation *animation = &display->mAnimations[i];
@@ -4638,17 +4638,17 @@ nsComputedDOMStyle::DoGetAnimationFillMo
   } while (++i < display->mAnimationFillModeCount);
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetAnimationIterationCount()
 {
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   NS_ABORT_IF_FALSE(display->mAnimationIterationCountCount > 0,
                     "first item must be explicit");
   uint32_t i = 0;
   do {
     const nsAnimation *animation = &display->mAnimations[i];
@@ -4672,17 +4672,17 @@ nsComputedDOMStyle::DoGetAnimationIterat
   } while (++i < display->mAnimationIterationCountCount);
 
   return valueList;
 }
 
 CSSValue*
 nsComputedDOMStyle::DoGetAnimationPlayState()
 {
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(true);
 
   NS_ABORT_IF_FALSE(display->mAnimationPlayStateCount > 0,
                     "first item must be explicit");
   uint32_t i = 0;
   do {
     const nsAnimation *animation = &display->mAnimations[i];
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -321,48 +321,48 @@ static nscoord CalcLengthWith(const nsCS
     case eCSSUnit_RootEM: {
       aPresContext->SetUsesRootEMUnits(true);
       nscoord rootFontSize;
 
       // NOTE: Be very careful with |styleFont|, since we haven't set
       // aCanStoreInRuleTree to false yet, so we don't want to introduce
       // any dependencies on aStyleContext's data here.
       const nsStyleFont *styleFont =
-        aStyleFont ? aStyleFont : aStyleContext->GetStyleFont();
+        aStyleFont ? aStyleFont : aStyleContext->StyleFont();
 
       if (aUseProvidedRootEmSize) {
         // We should use the provided aFontSize as the reference length to
         // scale. This only happens when we are calculating font-size or
         // an equivalent (scriptminsize or CalcLengthWithInitialFont) on
         // the root element, in which case aFontSize is already the
         // value we want.
         if (aFontSize == -1) {
           // XXX Should this be styleFont->mSize instead to avoid taking
           // minfontsize prefs into account?
           aFontSize = styleFont->mFont.size;
         }
         rootFontSize = aFontSize;
       } else if (aStyleContext && !aStyleContext->GetParent()) {
         // This is the root element (XXX we don't really know this, but
         // nsRuleNode::SetFont makes the same assumption!), so we should
-        // use GetStyleFont on this context to get the root element's
+        // use StyleFont on this context to get the root element's
         // font size.
         rootFontSize = styleFont->mFont.size;
       } else {
         // This is not the root element or we are calculating something other
         // than font size, so rem is relative to the root element's font size.
         nsRefPtr<nsStyleContext> rootStyle;
         const nsStyleFont *rootStyleFont = styleFont;
         Element* docElement = aPresContext->Document()->GetRootElement();
 
         if (docElement) {
           rootStyle = aPresContext->StyleSet()->ResolveStyleFor(docElement,
                                                                 nullptr);
           if (rootStyle) {
-            rootStyleFont = rootStyle->GetStyleFont();
+            rootStyleFont = rootStyle->StyleFont();
           }
         }
 
         rootFontSize = rootStyleFont->mFont.size;
       }
 
       return ScaleCoord(aValue, float(rootFontSize));
     }
@@ -370,17 +370,17 @@ static nscoord CalcLengthWith(const nsCS
       // Fall through to the code for units that can't be stored in the
       // rule tree because they depend on font data.
       break;
   }
   // Common code for units that depend on the element's font data and
   // thus can't be stored in the rule tree:
   aCanStoreInRuleTree = false;
   const nsStyleFont *styleFont =
-    aStyleFont ? aStyleFont : aStyleContext->GetStyleFont();
+    aStyleFont ? aStyleFont : aStyleContext->StyleFont();
   if (aFontSize == -1) {
     // XXX Should this be styleFont->mSize instead to avoid taking minfontsize
     // prefs into account?
     aFontSize = styleFont->mFont.size;
   }
   switch (aValue.GetUnit()) {
     case eCSSUnit_EM: {
       // CSS2.1 specifies that this unit scales to the computed font
@@ -838,17 +838,17 @@ static bool SetColor(const nsCSSValue& a
             result = true;
           }
           break;
         case NS_COLOR_CURRENTCOLOR:
           // The data computed from this can't be shared in the rule tree
           // because they could be used on a node with a different color
           aCanStoreInRuleTree = false;
           if (aContext) {
-            aResult = aContext->GetStyleColor()->mColor;
+            aResult = aContext->StyleColor()->mColor;
             result = true;
           }
           break;
         case NS_COLOR_MOZ_DEFAULT_COLOR:
           if (aPresContext) {
             aResult = aPresContext->DefaultColor();
             result = true;
           }
@@ -2285,17 +2285,17 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
                       aLTRSource.GetIntValue() == NS_BOXPROP_SOURCE_LOGICAL;
   bool RTLlogical = aRTLSource.GetUnit() == eCSSUnit_Enumerated &&
                       aRTLSource.GetIntValue() == NS_BOXPROP_SOURCE_LOGICAL;
   if (LTRlogical || RTLlogical) {
     // We can't cache anything on the rule tree if we use any data from
     // the style context, since data cached in the rule tree could be
     // used with a style context with a different value.
     aCanStoreInRuleTree = false;
-    uint8_t dir = aContext->GetStyleVisibility()->mDirection;
+    uint8_t dir = aContext->StyleVisibility()->mDirection;
 
     if (dir == NS_STYLE_DIRECTION_LTR) {
       if (LTRlogical)
         aValueRect.*(nsCSSRect::sides[aSide]) = aLTRLogicalValue;
     } else {
       if (RTLlogical)
         aValueRect.*(nsCSSRect::sides[aSide]) = aRTLLogicalValue;
     }
@@ -3379,34 +3379,34 @@ nsRuleNode::SetGenericFont(nsPresContext
                            uint8_t aGenericFontID,
                            nsStyleFont* aFont)
 {
   // walk up the contexts until a context with the desired generic font
   nsAutoTArray<nsStyleContext*, 8> contextPath;
   contextPath.AppendElement(aContext);
   nsStyleContext* higherContext = aContext->GetParent();
   while (higherContext) {
-    if (higherContext->GetStyleFont()->mGenericID == aGenericFontID) {
+    if (higherContext->StyleFont()->mGenericID == aGenericFontID) {
       // done walking up the higher contexts
       break;
     }
     contextPath.AppendElement(higherContext);
     higherContext = higherContext->GetParent();
   }
 
   // re-apply the cascading rules, starting from the higher context
 
   // If we stopped earlier because we reached the root of the style tree,
   // we will start with the default generic font from the presentation
   // context. Otherwise we start with the higher context.
   const nsFont* defaultFont =
     aPresContext->GetDefaultFont(aGenericFontID, aFont->mLanguage);
   nsStyleFont parentFont(*defaultFont, aPresContext);
   if (higherContext) {
-    const nsStyleFont* tmpFont = higherContext->GetStyleFont();
+    const nsStyleFont* tmpFont = higherContext->StyleFont();
     parentFont = *tmpFont;
   }
   *aFont = parentFont;
 
   bool dummy;
   uint32_t fontBit = nsCachedStyleData::GetBitForSID(eStyleStruct_Font);
 
   // use placement new[] on the result of alloca() to allocate a
@@ -3688,34 +3688,34 @@ nsRuleNode::ComputeTextData(void* aStart
   }
 
   // line-height: normal, number, length, percent, inherit
   const nsCSSValue* lineHeightValue = aRuleData->ValueForLineHeight();
   if (eCSSUnit_Percent == lineHeightValue->GetUnit()) {
     canStoreInRuleTree = false;
     // Use |mFont.size| to pick up minimum font size.
     text->mLineHeight.SetCoordValue(
-        NSToCoordRound(float(aContext->GetStyleFont()->mFont.size) *
+        NSToCoordRound(float(aContext->StyleFont()->mFont.size) *
                        lineHeightValue->GetPercentValue()));
   }
   else if (eCSSUnit_Initial == lineHeightValue->GetUnit() ||
            eCSSUnit_System_Font == lineHeightValue->GetUnit()) {
     text->mLineHeight.SetNormalValue();
   }
   else {
     SetCoord(*lineHeightValue, text->mLineHeight, parentText->mLineHeight,
              SETCOORD_LEH | SETCOORD_FACTOR | SETCOORD_NORMAL,
              aContext, mPresContext, canStoreInRuleTree);
     if (lineHeightValue->IsLengthUnit() &&
         !lineHeightValue->IsRelativeLengthUnit()) {
       nscoord lh = nsStyleFont::ZoomText(mPresContext,
                                          text->mLineHeight.GetCoordValue());
 
       canStoreInRuleTree = false;
-      const nsStyleFont *font = aContext->GetStyleFont();
+      const nsStyleFont *font = aContext->StyleFont();
       nscoord minimumFontSize = mPresContext->MinFontSize(font->mLanguage);
 
       if (minimumFontSize > 0 && !mPresContext->IsChrome()) {
         if (font->mSize != 0) {
           lh = nscoord(float(lh) * float(font->mFont.size) / float(font->mSize));
         } else {
           lh = minimumFontSize;
         }
@@ -3865,17 +3865,17 @@ nsRuleNode::ComputeTextResetData(void* a
     aRuleData->ValueForTextDecorationColor();
   nscolor decorationColor;
   if (eCSSUnit_Inherit == decorationColorValue->GetUnit()) {
     canStoreInRuleTree = false;
     if (parentContext) {
       bool isForeground;
       parentText->GetDecorationColor(decorationColor, isForeground);
       if (isForeground) {
-        text->SetDecorationColor(parentContext->GetStyleColor()->mColor);
+        text->SetDecorationColor(parentContext->StyleColor()->mColor);
       } else {
         text->SetDecorationColor(decorationColor);
       }
     } else {
       text->SetDecorationColorToForeground();
     }
   }
   else if (eCSSUnit_EnumColor == decorationColorValue->GetUnit() &&
@@ -5074,17 +5074,17 @@ nsRuleNode::ComputeVisibilityData(void* 
                                   nsRuleNode* aHighestNode,
                                   const RuleDetail aRuleDetail,
                                   const bool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Visibility, (mPresContext),
                           visibility, parentVisibility)
 
   // IMPORTANT: No properties in this struct have lengths in them.  We
-  // depend on this since CalcLengthWith can call GetStyleVisibility()
+  // depend on this since CalcLengthWith can call StyleVisibility()
   // to get the language for resolving fonts!
 
   // direction: enum, inherit, initial
   SetDiscrete(*aRuleData->ValueForDirection(), visibility->mDirection,
               canStoreInRuleTree,
               SETDSC_ENUMERATED, parentVisibility->mDirection,
               (GET_BIDI_OPTION_DIRECTION(mPresContext->GetBidi())
                == IBMBIDI_TEXTDIRECTION_RTL)
@@ -6052,17 +6052,17 @@ nsRuleNode::ComputeBorderData(void* aSta
         if (parentContext) {
           parentBorder->GetBorderColor(side, borderColor, foreground);
           if (foreground) {
             // We want to inherit the color from the parent, not use the
             // color on the element where this chunk of style data will be
             // used.  We can ensure that the data for the parent are fully
             // computed (unlike for the element where this will be used, for
             // which the color could be specified on a more specific rule).
-            border->SetBorderColor(side, parentContext->GetStyleColor()->mColor);
+            border->SetBorderColor(side, parentContext->StyleColor()->mColor);
           } else
             border->SetBorderColor(side, borderColor);
         } else {
           // We're the root
           border->SetBorderToForeground(side);
         }
       }
       else if (SetColor(value, unused, mPresContext, aContext, borderColor,
@@ -6293,17 +6293,17 @@ nsRuleNode::ComputeOutlineData(void* aSt
       if (parentOutline->GetOutlineColor(outlineColor))
         outline->SetOutlineColor(outlineColor);
       else {
         // We want to inherit the color from the parent, not use the
         // color on the element where this chunk of style data will be
         // used.  We can ensure that the data for the parent are fully
         // computed (unlike for the element where this will be used, for
         // which the color could be specified on a more specific rule).
-        outline->SetOutlineColor(parentContext->GetStyleColor()->mColor);
+        outline->SetOutlineColor(parentContext->StyleColor()->mColor);
       }
     } else {
       outline->SetOutlineInitialColor();
     }
   }
   else if (SetColor(*outlineColorValue, unused, mPresContext,
                     aContext, outlineColor, canStoreInRuleTree))
     outline->SetOutlineColor(outlineColor);
@@ -6536,17 +6536,17 @@ nsRuleNode::ComputePositionData(void* aS
         if (!grandparentContext) {
           // No grandparent --> our parent is the root node, so its
           // "align-self: auto" computes to the default "align-items" value:
           inheritedAlignSelf = NS_STYLE_ALIGN_ITEMS_INITIAL_VALUE;
         } else {
           // Normal case -- we have a grandparent.
           // Its "align-items" value is what we should end up inheriting.
           const nsStylePosition* grandparentPos =
-            grandparentContext->GetStylePosition();
+            grandparentContext->StylePosition();
           inheritedAlignSelf = grandparentPos->mAlignItems;
         }
       }
     }
 
     pos->mAlignSelf = inheritedAlignSelf;
     canStoreInRuleTree = false;
   } else {
@@ -7133,17 +7133,17 @@ nsRuleNode::ComputeColumnData(void* aSta
 
   // column-rule-color: color, inherit
   const nsCSSValue& colorValue = *aRuleData->ValueForColumnRuleColor();
   if (eCSSUnit_Inherit == colorValue.GetUnit()) {
     canStoreInRuleTree = false;
     column->mColumnRuleColorIsForeground = false;
     if (parent->mColumnRuleColorIsForeground) {
       if (parentContext) {
-        column->mColumnRuleColor = parentContext->GetStyleColor()->mColor;
+        column->mColumnRuleColor = parentContext->StyleColor()->mColor;
       } else {
         nsStyleColor defaultColumnRuleColor(mPresContext);
         column->mColumnRuleColor = defaultColumnRuleColor.mColor;
       }
     } else {
       column->mColumnRuleColor = parent->mColumnRuleColor;
     }
   }
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -2479,17 +2479,17 @@ ExtractBorderColor(nsStyleContext* aStyl
                    mozilla::css::Side aSide, nsStyleAnimation::Value& aComputedValue)
 {
   nscolor color;
   bool foreground;
   static_cast<const nsStyleBorder*>(aStyleBorder)->
     GetBorderColor(aSide, color, foreground);
   if (foreground) {
     // FIXME: should add test for this
-    color = aStyleContext->GetStyleColor()->mColor;
+    color = aStyleContext->StyleColor()->mColor;
   }
   aComputedValue.SetColorValue(color);
 }
 
 static bool
 StyleCoordToValue(const nsStyleCoord& aCoord, nsStyleAnimation::Value& aValue)
 {
   switch (aCoord.GetUnit()) {
@@ -2650,27 +2650,27 @@ nsStyleAnimation::ExtractComputedValue(n
                              aComputedValue);
           break;
 
         case eCSSProperty_outline_color: {
           const nsStyleOutline *styleOutline =
             static_cast<const nsStyleOutline*>(styleStruct);
           nscolor color;
           if (!styleOutline->GetOutlineColor(color))
-            color = aStyleContext->GetStyleColor()->mColor;
+            color = aStyleContext->StyleColor()->mColor;
           aComputedValue.SetColorValue(color);
           break;
         }
 
         case eCSSProperty__moz_column_rule_color: {
           const nsStyleColumn *styleColumn =
             static_cast<const nsStyleColumn*>(styleStruct);
           nscolor color;
           if (styleColumn->mColumnRuleColorIsForeground) {
-            color = aStyleContext->GetStyleColor()->mColor;
+            color = aStyleContext->StyleColor()->mColor;
           } else {
             color = styleColumn->mColumnRuleColor;
           }
           aComputedValue.SetColorValue(color);
           break;
         }
 
         case eCSSProperty__moz_column_count: {
@@ -2697,17 +2697,17 @@ nsStyleAnimation::ExtractComputedValue(n
 
         case eCSSProperty_text_decoration_color: {
           const nsStyleTextReset *styleTextReset =
             static_cast<const nsStyleTextReset*>(styleStruct);
           nscolor color;
           bool isForeground;
           styleTextReset->GetDecorationColor(color, isForeground);
           if (isForeground) {
-            color = aStyleContext->GetStyleColor()->mColor;
+            color = aStyleContext->StyleColor()->mColor;
           }
           aComputedValue.SetColorValue(color);
           break;
         }
 
         case eCSSProperty_text_decoration_style: {
           uint8_t decorationStyle =
             static_cast<const nsStyleTextReset*>(styleStruct)->
diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -295,35 +295,35 @@ void
 nsStyleContext::ApplyStyleFixups()
 {
   // See if we have any text decorations.
   // First see if our parent has text decorations.  If our parent does, then we inherit the bit.
   if (mParent && mParent->HasTextDecorationLines()) {
     mBits |= NS_STYLE_HAS_TEXT_DECORATION_LINES;
   } else {
     // We might have defined a decoration.
-    const nsStyleTextReset* text = GetStyleTextReset();
+    const nsStyleTextReset* text = StyleTextReset();
     uint8_t decorationLine = text->mTextDecorationLine;
     if (decorationLine != NS_STYLE_TEXT_DECORATION_LINE_NONE &&
         decorationLine != NS_STYLE_TEXT_DECORATION_LINE_OVERRIDE_ALL) {
       mBits |= NS_STYLE_HAS_TEXT_DECORATION_LINES;
     }
   }
 
   if ((mParent && mParent->HasPseudoElementData()) || mPseudoTag) {
     mBits |= NS_STYLE_HAS_PSEUDO_ELEMENT_DATA;
   }
 
   // Correct tables.
-  const nsStyleDisplay* disp = GetStyleDisplay();
+  const nsStyleDisplay* disp = StyleDisplay();
   if (disp->mDisplay == NS_STYLE_DISPLAY_TABLE) {
     // -moz-center and -moz-right are used for HTML's alignment
     // This is covering the <div align="right"><table>...</table></div> case.
     // In this case, we don't want to inherit the text alignment into the table.
-    const nsStyleText* text = GetStyleText();
+    const nsStyleText* text = StyleText();
     
     if (text->mTextAlign == NS_STYLE_TEXT_ALIGN_MOZ_CENTER ||
         text->mTextAlign == NS_STYLE_TEXT_ALIGN_MOZ_RIGHT)
     {
       nsStyleText* uniqueText = (nsStyleText*)GetUniqueStyleData(eStyleStruct_Text);
       uniqueText->mTextAlign = NS_STYLE_TEXT_ALIGN_DEFAULT;
     }
   }
@@ -357,17 +357,17 @@ nsStyleContext::ApplyStyleFixups()
 
   // Adjust the "display" values of flex items (but not for raw text,
   // placeholders, or table-parts). CSS3 Flexbox section 4 says:
   //   # The computed 'display' of a flex item is determined
   //   # by applying the table in CSS 2.1 Chapter 9.7.
   // ...which converts inline-level elements to their block-level equivalents.
 #ifdef MOZ_FLEXBOX
   if (mParent) {
-    const nsStyleDisplay* parentDisp = mParent->GetStyleDisplay();
+    const nsStyleDisplay* parentDisp = mParent->StyleDisplay();
     if ((parentDisp->mDisplay == NS_STYLE_DISPLAY_FLEX ||
          parentDisp->mDisplay == NS_STYLE_DISPLAY_INLINE_FLEX) &&
         GetPseudo() != nsCSSAnonBoxes::mozNonElement) {
       uint8_t displayVal = disp->mDisplay;
       // Skip table parts.
       // NOTE: This list needs to be kept in sync with
       // nsCSSFrameConstructor.cpp's "sDisplayData" array -- specifically,
       // this should be the list of display-values that have
@@ -397,17 +397,17 @@ nsStyleContext::ApplyStyleFixups()
           mutable_display->mDisplay = displayVal;
         }
       }
     }
   }
 #endif // MOZ_FLEXBOX
 
   // Computer User Interface style, to trigger loads of cursors
-  GetStyleUserInterface();
+  StyleUserInterface();
 }
 
 nsChangeHint
 nsStyleContext::CalcStyleDifference(nsStyleContext* aOther,
                                     nsChangeHint aParentHintsNotHandledForDescendants)
 {
   SAMPLE_LABEL("nsStyleContext", "CalcStyleDifference");
 
@@ -518,92 +518,92 @@ nsStyleContext::CalcStyleDifference(nsSt
     bool change = false;
 
     // NB: Calling Peek on |this|, not |thisVis|, since callers may look
     // at a struct on |this| without looking at the same struct on
     // |thisVis| (including this function if we skip one of these checks
     // due to change being true already or due to the old style context
     // not having a style-if-visited), but not the other way around.
     if (PeekStyleColor()) {
-      if (thisVis->GetStyleColor()->mColor !=
-          otherVis->GetStyleColor()->mColor) {
+      if (thisVis->StyleColor()->mColor !=
+          otherVis->StyleColor()->mColor) {
         change = true;
       }
     }
 
     // NB: Calling Peek on |this|, not |thisVis| (see above).
     if (!change && PeekStyleBackground()) {
-      if (thisVis->GetStyleBackground()->mBackgroundColor !=
-          otherVis->GetStyleBackground()->mBackgroundColor) {
+      if (thisVis->StyleBackground()->mBackgroundColor !=
+          otherVis->StyleBackground()->mBackgroundColor) {
         change = true;
       }
     }
 
     // NB: Calling Peek on |this|, not |thisVis| (see above).
     if (!change && PeekStyleBorder()) {
-      const nsStyleBorder *thisVisBorder = thisVis->GetStyleBorder();
-      const nsStyleBorder *otherVisBorder = otherVis->GetStyleBorder();
+      const nsStyleBorder *thisVisBorder = thisVis->StyleBorder();
+      const nsStyleBorder *otherVisBorder = otherVis->StyleBorder();
       NS_FOR_CSS_SIDES(side) {
         bool thisFG, otherFG;
         nscolor thisColor, otherColor;
         thisVisBorder->GetBorderColor(side, thisColor, thisFG);
         otherVisBorder->GetBorderColor(side, otherColor, otherFG);
         if (thisFG != otherFG || (!thisFG && thisColor != otherColor)) {
           change = true;
           break;
         }
       }
     }
 
     // NB: Calling Peek on |this|, not |thisVis| (see above).
     if (!change && PeekStyleOutline()) {
-      const nsStyleOutline *thisVisOutline = thisVis->GetStyleOutline();
-      const nsStyleOutline *otherVisOutline = otherVis->GetStyleOutline();
+      const nsStyleOutline *thisVisOutline = thisVis->StyleOutline();
+      const nsStyleOutline *otherVisOutline = otherVis->StyleOutline();
       bool haveColor;
       nscolor thisColor, otherColor;
       if (thisVisOutline->GetOutlineInitialColor() != 
             otherVisOutline->GetOutlineInitialColor() ||
           (haveColor = thisVisOutline->GetOutlineColor(thisColor)) != 
             otherVisOutline->GetOutlineColor(otherColor) ||
           (haveColor && thisColor != otherColor)) {
         change = true;
       }
     }
 
     // NB: Calling Peek on |this|, not |thisVis| (see above).
     if (!change && PeekStyleColumn()) {
-      const nsStyleColumn *thisVisColumn = thisVis->GetStyleColumn();
-      const nsStyleColumn *otherVisColumn = otherVis->GetStyleColumn();
+      const nsStyleColumn *thisVisColumn = thisVis->StyleColumn();
+      const nsStyleColumn *otherVisColumn = otherVis->StyleColumn();
       if (thisVisColumn->mColumnRuleColor != otherVisColumn->mColumnRuleColor ||
           thisVisColumn->mColumnRuleColorIsForeground !=
             otherVisColumn->mColumnRuleColorIsForeground) {
         change = true;
       }
     }
 
     // NB: Calling Peek on |this|, not |thisVis| (see above).
     if (!change && PeekStyleTextReset()) {
-      const nsStyleTextReset *thisVisTextReset = thisVis->GetStyleTextReset();
-      const nsStyleTextReset *otherVisTextReset = otherVis->GetStyleTextReset();
+      const nsStyleTextReset *thisVisTextReset = thisVis->StyleTextReset();
+      const nsStyleTextReset *otherVisTextReset = otherVis->StyleTextReset();
       nscolor thisVisDecColor, otherVisDecColor;
       bool thisVisDecColorIsFG, otherVisDecColorIsFG;
       thisVisTextReset->GetDecorationColor(thisVisDecColor,
                                            thisVisDecColorIsFG);
       otherVisTextReset->GetDecorationColor(otherVisDecColor,
                                             otherVisDecColorIsFG);
       if (thisVisDecColorIsFG != otherVisDecColorIsFG ||
           (!thisVisDecColorIsFG && thisVisDecColor != otherVisDecColor)) {
         change = true;
       }
     }
 
     // NB: Calling Peek on |this|, not |thisVis| (see above).
     if (!change && PeekStyleSVG()) {
-      const nsStyleSVG *thisVisSVG = thisVis->GetStyleSVG();
-      const nsStyleSVG *otherVisSVG = otherVis->GetStyleSVG();
+      const nsStyleSVG *thisVisSVG = thisVis->StyleSVG();
+      const nsStyleSVG *otherVisSVG = otherVis->StyleSVG();
       if (thisVisSVG->mFill != otherVisSVG->mFill ||
           thisVisSVG->mStroke != otherVisSVG->mStroke) {
         change = true;
       }
     }
 
     if (change) {
       NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -231,18 +231,18 @@ public:
    * faster.
    */
   const void* NS_FASTCALL GetStyleData(nsStyleStructID aSID);
 
   /**
    * Define typesafe getter functions for each style struct by
    * preprocessing the list of style structs.  These functions are the
    * preferred way to get style data.  The macro creates functions like:
-   *   const nsStyleBorder* GetStyleBorder();
-   *   const nsStyleColor* GetStyleColor();
+   *   const nsStyleBorder* StyleBorder();
+   *   const nsStyleColor* StyleColor();
    */
   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)  \
     const nsStyle##name_ * GetStyle##name_() {            \
       return DoGetStyle##name_(true);                  \
     }
   #include "nsStyleStructList.h"
   #undef STYLE_STRUCT
 
@@ -325,17 +325,17 @@ public:
    */
   void* Alloc(size_t aSize);
 
   /**
    * Start the background image loads for this style context.
    */
   void StartBackgroundImageLoads() {
     // Just get our background struct; that should do the trick
-    GetStyleBackground();
+    StyleBackground();
   }
 
 #ifdef DEBUG
   void List(FILE* out, int32_t aIndent);
 #endif
 
 protected:
   void AddChild(nsStyleContext* aChild);
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -829,17 +829,17 @@ nsStyleSet::GetContext(nsStyleContext* a
   }
 
   if (aElementForAnimation && aElementForAnimation->IsHTML(nsGkAtoms::body) &&
       aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement &&
       PresContext()->CompatibilityMode() == eCompatibility_NavQuirks) {
     nsIDocument* doc = aElementForAnimation->GetCurrentDoc();
     if (doc && doc->GetBodyElement() == aElementForAnimation) {
       // Update the prescontext's body color
-      PresContext()->SetBodyTextColor(result->GetStyleColor()->mColor);
+      PresContext()->SetBodyTextColor(result->StyleColor()->mColor);
     }
   }
 
   return result.forget();
 }
 
 void
 nsStyleSet::AddImportantRules(nsRuleNode* aCurrLevelNode,
@@ -1394,18 +1394,18 @@ nsStyleSet::ProbePseudoElementStyle(Elem
                aParentElement, flags);
 
   // For :before and :after pseudo-elements, having display: none or no
   // 'content' property is equivalent to not having the pseudo-element
   // at all.
   if (result &&
       (pseudoTag == nsCSSPseudoElements::before ||
        pseudoTag == nsCSSPseudoElements::after)) {
-    const nsStyleDisplay *display = result->GetStyleDisplay();
-    const nsStyleContent *content = result->GetStyleContent();
+    const nsStyleDisplay *display = result->StyleDisplay();
+    const nsStyleContent *content = result->StyleContent();
     // XXXldb What is contentCount for |content: ""|?
     if (display->mDisplay == NS_STYLE_DISPLAY_NONE ||
         content->ContentCount() == 0) {
       result = nullptr;
     }
   }
 
   return result.forget();
diff --git a/layout/style/nsStyleStructInlines.h b/layout/style/nsStyleStructInlines.h
--- a/layout/style/nsStyleStructInlines.h
+++ b/layout/style/nsStyleStructInlines.h
@@ -156,15 +156,15 @@ nsStyleVisibility::GetEffectivePointerEv
 {
   if (aFrame->GetContent() && !aFrame->GetContent()->GetParent()) {
     // The root element has a cluster of frames associated with it
     // (root scroll frame, canvas frame, the actual primary frame). Make
     // those take their pointer-events value from the root element's primary
     // frame.
     nsIFrame* f = aFrame->GetContent()->GetPrimaryFrame();
     if (f) {
-      return f->GetStyleVisibility()->mPointerEvents;
+      return f->StyleVisibility()->mPointerEvents;
     }
   }
   return mPointerEvents;
 }
 
 #endif /* !defined(nsStyleStructInlines_h_) */
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -452,17 +452,17 @@ nsTransitionManager::StyleContextChanged
                   "pseudo type mismatch");
 
   // NOTE: Things in this function (and ConsiderStartingTransition)
   // should never call PeekStyleData because we don't preserve gotten
   // structs across reframes.
 
   // Return sooner (before the startedAny check below) for the most
   // common case: no transitions specified or running.
-  const nsStyleDisplay *disp = aNewStyleContext->GetStyleDisplay();
+  const nsStyleDisplay *disp = aNewStyleContext->StyleDisplay();
   nsCSSPseudoElements::Type pseudoType = aNewStyleContext->GetPseudoType();
   if (pseudoType != nsCSSPseudoElements::ePseudo_NotPseudoElement) {
     if (pseudoType != nsCSSPseudoElements::ePseudo_before &&
         pseudoType != nsCSSPseudoElements::ePseudo_after) {
       return nullptr;
     }
 
     NS_ASSERTION((pseudoType == nsCSSPseudoElements::ePseudo_before &&
diff --git a/layout/svg/nsSVGContainerFrame.cpp b/layout/svg/nsSVGContainerFrame.cpp
--- a/layout/svg/nsSVGContainerFrame.cpp
+++ b/layout/svg/nsSVGContainerFrame.cpp
@@ -200,17 +200,17 @@ nsSVGDisplayContainerFrame::PaintSVG(nsR
                                      const nsIntRect *aDirtyRect)
 {
   NS_ASSERTION(!NS_SVGDisplayListPaintingEnabled() ||
                (mState & NS_STATE_SVG_NONDISPLAY_CHILD) ||
                PresContext()->IsGlyph(),
                "If display lists are enabled, only painting of non-display "
                "SVG should take this code path");
 
-  const nsStyleDisplay *display = GetStyleDisplay();
+  const nsStyleDisplay *display = StyleDisplay();
   if (display->mOpacity == 0.0)
     return NS_OK;
 
   for (nsIFrame* kid = mFrames.FirstChild(); kid;
        kid = kid->GetNextSibling()) {
     nsSVGUtils::PaintFrameWithEffects(aContext, aDirtyRect, kid);
   }
 
diff --git a/layout/svg/nsSVGEffects.cpp b/layout/svg/nsSVGEffects.cpp
--- a/layout/svg/nsSVGEffects.cpp
+++ b/layout/svg/nsSVGEffects.cpp
@@ -442,17 +442,17 @@ nsSVGEffects::GetPaintingPropertyForURI(
 }
 
 nsSVGEffects::EffectProperties
 nsSVGEffects::GetEffectProperties(nsIFrame *aFrame)
 {
   NS_ASSERTION(!aFrame->GetPrevContinuation(), "aFrame should be first continuation");
 
   EffectProperties result;
-  const nsStyleSVGReset *style = aFrame->GetStyleSVGReset();
+  const nsStyleSVGReset *style = aFrame->StyleSVGReset();
   result.mFilter = static_cast<nsSVGFilterProperty*>
     (GetEffectProperty(style->mFilter, aFrame, FilterProperty(),
                        CreateFilterProperty));
   result.mClipPath =
     GetPaintingProperty(style->mClipPath, aFrame, ClipPathProperty());
   result.mMask =
     GetPaintingProperty(style->mMask, aFrame, MaskProperty());
   return result;
@@ -520,38 +520,38 @@ nsSVGEffects::UpdateEffects(nsIFrame *aF
   props.Delete(MarkerMiddleProperty());
   props.Delete(MarkerEndProperty());
   props.Delete(FillProperty());
   props.Delete(StrokeProperty());
   props.Delete(BackgroundImageProperty());
 
   // Ensure that the filter is repainted correctly
   // We can't do that in DoUpdate as the referenced frame may not be valid
-  GetEffectProperty(aFrame->GetStyleSVGReset()->mFilter,
+  GetEffectProperty(aFrame->StyleSVGReset()->mFilter,
                     aFrame, FilterProperty(), CreateFilterProperty);
 
   if (aFrame->GetType() == nsGkAtoms::svgPathGeometryFrame &&
       static_cast<nsSVGPathGeometryElement*>(aFrame->GetContent())->IsMarkable()) {
     // Set marker properties here to avoid reference loops
-    const nsStyleSVG *style = aFrame->GetStyleSVG();
+    const nsStyleSVG *style = aFrame->StyleSVG();
     GetEffectProperty(style->mMarkerStart, aFrame, MarkerBeginProperty(),
                       CreateMarkerProperty);
     GetEffectProperty(style->mMarkerMid, aFrame, MarkerMiddleProperty(),
                       CreateMarkerProperty);
     GetEffectProperty(style->mMarkerEnd, aFrame, MarkerEndProperty(),
                       CreateMarkerProperty);
   }
 }
 
 nsSVGFilterProperty *
 nsSVGEffects::GetFilterProperty(nsIFrame *aFrame)
 {
   NS_ASSERTION(!aFrame->GetPrevContinuation(), "aFrame should be first continuation");
 
-  if (!aFrame->GetStyleSVGReset()->mFilter)
+  if (!aFrame->StyleSVGReset()->mFilter)
     return nullptr;
 
   return static_cast<nsSVGFilterProperty *>
     (aFrame->Properties().Get(FilterProperty()));
 }
 
 static PLDHashOperator
 GatherEnumerator(nsPtrHashKey<nsSVGRenderingObserver>* aEntry, void* aArg)
diff --git a/layout/svg/nsSVGForeignObjectFrame.cpp b/layout/svg/nsSVGForeignObjectFrame.cpp
--- a/layout/svg/nsSVGForeignObjectFrame.cpp
+++ b/layout/svg/nsSVGForeignObjectFrame.cpp
@@ -255,17 +255,17 @@ nsSVGForeignObjectFrame::PaintSVG(nsRend
     if (kidDirtyRect.IsEmpty())
       return NS_OK;
   }
 
   gfxContext *gfx = aContext->ThebesContext();
 
   gfx->Save();
 
-  if (GetStyleDisplay()->IsScrollableOverflow()) {
+  if (StyleDisplay()->IsScrollableOverflow()) {
     float x, y, width, height;
     static_cast<nsSVGElement*>(mContent)->
       GetAnimatedLengthValues(&x, &y, &width, &height, nullptr);
 
     gfxRect clipRect =
       nsSVGUtils::GetClipRectForFrame(this, 0.0f, 0.0f, width, height);
     nsSVGUtils::SetClipRect(gfx, canvasTM, clipRect);
   }
diff --git a/layout/svg/nsSVGGeometryFrame.cpp b/layout/svg/nsSVGGeometryFrame.cpp
--- a/layout/svg/nsSVGGeometryFrame.cpp
+++ b/layout/svg/nsSVGGeometryFrame.cpp
@@ -30,16 +30,16 @@ nsSVGGeometryFrame::Init(nsIContent* aCo
   return rv;
 }
 
 //----------------------------------------------------------------------
 
 uint16_t
 nsSVGGeometryFrame::GetClipRule()
 {
-  return GetStyleSVG()->mClipRule;
+  return StyleSVG()->mClipRule;
 }
 
 uint16_t
 nsSVGGeometryFrame::GetHitTestFlags()
 {
   return nsSVGUtils::GetGeometryHitTestFlags(this);
 }
diff --git a/layout/svg/nsSVGGlyphFrame.cpp b/layout/svg/nsSVGGlyphFrame.cpp
--- a/layout/svg/nsSVGGlyphFrame.cpp
+++ b/layout/svg/nsSVGGlyphFrame.cpp
@@ -352,44 +352,44 @@ nsSVGGlyphFrame::GetType() const
   return nsGkAtoms::svgGlyphFrame;
 }
 
 NS_IMETHODIMP
 nsSVGGlyphFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                   const nsRect&           aDirtyRect,
                                   const nsDisplayListSet& aLists)
 {
-  if (GetStyleFont()->mFont.size <= 0) {
+  if (StyleFont()->mFont.size <= 0) {
     return NS_OK;
   }
   return aLists.Content()->AppendNewToTop(
            new (aBuilder) nsDisplaySVGGlyphs(aBuilder, this));
 }
 
 //----------------------------------------------------------------------
 // nsISVGChildFrame methods
 
 NS_IMETHODIMP
 nsSVGGlyphFrame::PaintSVG(nsRenderingContext *aContext,
                           const nsIntRect *aDirtyRect)
 {
-  if (!GetStyleVisibility()->IsVisible())
+  if (!StyleVisibility()->IsVisible())
     return NS_OK;
 
-  if (GetStyleFont()->mFont.size <= 0) {
+  if (StyleFont()->mFont.size <= 0) {
     // Don't even try to paint, or cairo will go into an error state.
     return NS_OK;
   }
 
   AutoCanvasTMForMarker autoCanvasTMFor(this, FOR_PAINTING);
 
   gfxContext *gfx = aContext->ThebesContext();
   uint16_t renderMode = SVGAutoRenderState::GetRenderMode(aContext);
 
-  switch (GetStyleSVG()->mTextRendering) {
+  switch (StyleSVG()->mTextRendering) {
   case NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED:
     gfx->SetAntialiasMode(gfxContext::MODE_ALIASED);
     break;
   default:
     gfx->SetAntialiasMode(gfxContext::MODE_COVERAGE);
     break;
   }
 
@@ -663,17 +663,17 @@ nsSVGGlyphFrame::GetBBoxContribution(con
   // AddBoundingBoxesToPath() call with CurrentLineWidth()/SetLineWidth()
   // calls to record and then reset the stroke width.
 
   gfxRect pathExtents = tmpCtx->GetUserPathExtent();
 
   // Account for fill:
   if ((aFlags & nsSVGUtils::eBBoxIncludeFillGeometry) ||
       ((aFlags & nsSVGUtils::eBBoxIncludeFill) &&
-       GetStyleSVG()->mFill.mType != eStyleSVGPaintType_None)) {
+       StyleSVG()->mFill.mType != eStyleSVGPaintType_None)) {
     bbox = pathExtents;
   }
 
   // Account for stroke:
   if ((aFlags & nsSVGUtils::eBBoxIncludeStrokeGeometry) ||
       ((aFlags & nsSVGUtils::eBBoxIncludeStroke) &&
        nsSVGUtils::HasStroke(this))) {
     bbox.UnionEdges(nsSVGUtils::PathExtentsToMaxStrokeExtents(pathExtents,
@@ -903,17 +903,17 @@ nsSVGGlyphFrame::GetBaselineOffset(float
 {
   gfxTextRun::Metrics metrics =
     mTextRun->MeasureText(0, mTextRun->GetLength(),
                           gfxFont::LOOSE_INK_EXTENTS, nullptr, nullptr);
 
   uint16_t dominantBaseline;
 
   for (nsIFrame *frame = GetParent(); frame; frame = frame->GetParent()) {
-    dominantBaseline = frame->GetStyleSVGReset()->mDominantBaseline;
+    dominantBaseline = frame->StyleSVGReset()->mDominantBaseline;
     if (dominantBaseline != NS_STYLE_DOMINANT_BASELINE_AUTO ||
         frame->GetType() == nsGkAtoms::svgTextFrame) {
       break;
     }
   }
 
   gfxFloat baselineAppUnits;
   switch (dominantBaseline) {
@@ -952,17 +952,17 @@ nsSVGGlyphFrame::SetupCairoState(gfxCont
   if (SetupCairoStroke(aContext, aOuterObjectPaint, thisObjectPaint)) {
     toDraw = DrawMode(toDraw | gfxFont::GLYPH_STROKE);
   }
 
   if (SetupCairoFill(aContext, aOuterObjectPaint, thisObjectPaint)) {
     toDraw = DrawMode(toDraw | gfxFont::GLYPH_FILL);
   }
 
-  uint32_t paintOrder = GetStyleSVG()->mPaintOrder;
+  uint32_t paintOrder = StyleSVG()->mPaintOrder;
   while (paintOrder) {
     uint32_t component =
       paintOrder & ((1 << NS_STYLE_PAINT_ORDER_BITWIDTH) - 1);
     if (component == NS_STYLE_PAINT_ORDER_FILL) {
       break;
     }
     if (component == NS_STYLE_PAINT_ORDER_STROKE) {
       toDraw = DrawMode(toDraw | gfxFont::GLYPH_STROKE_UNDERNEATH);
@@ -980,17 +980,17 @@ bool
 nsSVGGlyphFrame::SetupCairoStroke(gfxContext *aContext,
                                   gfxTextObjectPaint *aOuterObjectPaint,
                                   SVGTextObjectPaint *aThisObjectPaint)
 {
   if (!nsSVGUtils::HasStroke(this, aOuterObjectPaint)) {
     return false;
   }
 
-  const nsStyleSVG *style = GetStyleSVG();
+  const nsStyleSVG *style = StyleSVG();
   nsSVGUtils::SetupCairoStrokeHitGeometry(this, aContext, aOuterObjectPaint);
   float opacity = nsSVGUtils::GetOpacity(style->mStrokeOpacitySource,
                                          style->mStrokeOpacity,
                                          aOuterObjectPaint);
 
   SetupInheritablePaint(aContext, opacity, aOuterObjectPaint,
                         aThisObjectPaint->mStrokePaint, &nsStyleSVG::mStroke,
                         nsSVGEffects::StrokeProperty());
@@ -1000,17 +1000,17 @@ nsSVGGlyphFrame::SetupCairoStroke(gfxCon
   return opacity != 0.0f;
 }
 
 bool
 nsSVGGlyphFrame::SetupCairoFill(gfxContext *aContext,
                                 gfxTextObjectPaint *aOuterObjectPaint,
                                 SVGTextObjectPaint *aThisObjectPaint)
 {
-  const nsStyleSVG *style = GetStyleSVG();
+  const nsStyleSVG *style = StyleSVG();
   if (style->mFill.mType == eStyleSVGPaintType_None) {
     aThisObjectPaint->SetFillOpacity(0.0f);
     return false;
   }
 
   float opacity = nsSVGUtils::GetOpacity(style->mFillOpacitySource,
                                          style->mFillOpacity,
                                          aOuterObjectPaint);
@@ -1027,17 +1027,17 @@ nsSVGGlyphFrame::SetupCairoFill(gfxConte
 void
 nsSVGGlyphFrame::SetupInheritablePaint(gfxContext *aContext,
                                        float& aOpacity,
                                        gfxTextObjectPaint *aOuterObjectPaint,
                                        SVGTextObjectPaint::Paint& aTargetPaint,
                                        nsStyleSVGPaint nsStyleSVG::*aFillOrStroke,
                                        const FramePropertyDescriptor *aProperty)
 {
-  const nsStyleSVG *style = GetStyleSVG();
+  const nsStyleSVG *style = StyleSVG();
   nsSVGPaintServerFrame *ps =
     nsSVGEffects::GetPaintServer(this, &(style->*aFillOrStroke), aProperty);
 
   if (ps && ps->SetupPaintServer(aContext, this, aFillOrStroke, aOpacity)) {
     aTargetPaint.SetPaintServer(this, aContext->CurrentMatrix(), ps);
   } else if (SetupObjectPaint(aContext, aFillOrStroke, aOpacity, aOuterObjectPaint)) {
     aTargetPaint.SetObjectPaint(aOuterObjectPaint, (style->*aFillOrStroke).mType);
   } else {
@@ -1062,17 +1062,17 @@ nsSVGGlyphFrame::SetupObjectPaint(gfxCon
                                   float& aOpacity,
                                   gfxTextObjectPaint *aOuterObjectPaint)
 {
   if (!aOuterObjectPaint) {
     NS_WARNING("Outer object paint value used outside SVG glyph");
     return false;
   }
 
-  const nsStyleSVG *style = GetStyleSVG();
+  const nsStyleSVG *style = StyleSVG();
   const nsStyleSVGPaint &paint = style->*aFillOrStroke;
 
   if (paint.mType != eStyleSVGPaintType_ObjectFill &&
       paint.mType != eStyleSVGPaintType_ObjectStroke) {
     return false;
   }
 
   gfxMatrix current = aContext->CurrentMatrix();
@@ -1542,17 +1542,17 @@ nsSVGGlyphFrame::GetEffectiveRotate(int3
     // rotate is applied for extra characters too
     aRotate.AppendElement(rotate[rotate.Length() - 1]);
   }
 }
 
 uint16_t
 nsSVGGlyphFrame::GetTextAnchor()
 {
-  return GetStyleSVG()->mTextAnchor;
+  return StyleSVG()->mTextAnchor;
 }
 
 bool
 nsSVGGlyphFrame::IsAbsolutelyPositioned()
 {
   bool hasTextPathAncestor = false;
   for (nsIFrame *frame = GetParent();
        frame != nullptr;
@@ -1746,17 +1746,17 @@ nsSVGGlyphFrame::ClearTextRun()
   mTextRun = nullptr;
 }
 
 bool
 nsSVGGlyphFrame::EnsureTextRun(float *aDrawScale, float *aMetricsScale,
                                bool aForceGlobalTransform)
 {
   // Compute the size at which the text should render (excluding the CTM)
-  const nsStyleFont* fontData = GetStyleFont();
+  const nsStyleFont* fontData = StyleFont();
   // Since SVG has its own scaling, we really don't want
   // fonts in SVG to respond to the browser's "TextZoom"
   // (Ctrl++,Ctrl+-)
   nsPresContext *presContext = PresContext();
   float textZoom = presContext->TextZoom();
   double size =
     presContext->AppUnitsToFloatCSSPixels(fontData->mSize) / textZoom;
 
@@ -1793,20 +1793,20 @@ nsSVGGlyphFrame::EnsureTextRun(float *aD
      * new text chunk, so we always set the base direction according to the
      * direction property
      *
      * See also XXXsmontagu comments in nsSVGTextFrame::UpdateGlyphPositioning
      */
     
     // Get the unicodeBidi property from the parent, because it doesn't
     // inherit
-    bool bidiOverride = !!(mParent->GetStyleTextReset()->mUnicodeBidi &
+    bool bidiOverride = !!(mParent->StyleTextReset()->mUnicodeBidi &
                            NS_STYLE_UNICODE_BIDI_OVERRIDE);
     nsBidiLevel baseDirection =
-      GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL ?
+      StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL ?
         NSBIDI_RTL : NSBIDI_LTR;
     nsBidiPresUtils::CopyLogicalToVisual(text, visualText,
                                          baseDirection, bidiOverride);
     if (!visualText.IsEmpty()) {
       text = visualText;
     }
 
     gfxMatrix m;
@@ -1818,42 +1818,42 @@ nsSVGGlyphFrame::EnsureTextRun(float *aD
     }
 
     // The context scale is the ratio of the length of the transformed
     // diagonal vector (1,1) to the length of the untransformed diagonal
     // (which is sqrt(2)).
     gfxPoint p = m.Transform(gfxPoint(1, 1)) - m.Transform(gfxPoint(0, 0));
     double contextScale = SVGContentUtils::ComputeNormalizedHypotenuse(p.x, p.y);
 
-    if (GetStyleSVG()->mTextRendering ==
+    if (StyleSVG()->mTextRendering ==
         NS_STYLE_TEXT_RENDERING_GEOMETRICPRECISION) {
       textRunSize = PRECISE_SIZE;
     } else {
       textRunSize = size*contextScale;
       textRunSize = std::max(textRunSize, double(CLAMP_MIN_SIZE));
       textRunSize = std::min(textRunSize, double(CLAMP_MAX_SIZE));
     }
 
     const nsFont& font = fontData->mFont;
     bool printerFont = (presContext->Type() == nsPresContext::eContext_PrintPreview ||
                           presContext->Type() == nsPresContext::eContext_Print);
     gfxFontStyle fontStyle(font.style, font.weight, font.stretch, textRunSize,
-                           GetStyleFont()->mLanguage,
+                           StyleFont()->mLanguage,
                            font.sizeAdjust, font.systemFont,
                            printerFont,
                            font.languageOverride);
 
     font.AddFontFeaturesToStyle(&fontStyle);
 
     nsRefPtr<gfxFontGroup> fontGroup =
       gfxPlatform::GetPlatform()->CreateFontGroup(font.name, &fontStyle, presContext->GetUserFontSet());
 
     uint32_t flags = gfxTextRunFactory::TEXT_NEED_BOUNDING_BOX |
       GetTextRunFlags(text.Length()) |
-      nsLayoutUtils::GetTextRunFlagsForStyle(StyleContext(), GetStyleFont(), 0);
+      nsLayoutUtils::GetTextRunFlagsForStyle(StyleContext(), StyleFont(), 0);
 
     // XXX We should use a better surface here! But then we'd have to
     // change things so we can ensure we always have the "right" sort of
     // surface available, by creating the textrun only at the right times
     nsRefPtr<gfxContext> tmpCtx = MakeTmpCtx();
     tmpCtx->SetMatrix(m);
 
     // Use only the fonts' internal word caching here.
diff --git a/layout/svg/nsSVGGradientFrame.cpp b/layout/svg/nsSVGGradientFrame.cpp
--- a/layout/svg/nsSVGGradientFrame.cpp
+++ b/layout/svg/nsSVGGradientFrame.cpp
@@ -118,18 +118,18 @@ nsSVGGradientFrame::GetStopInformation(i
 
     aNum->GetAnimVal(aOffset);
     if (*aOffset < 0.0f)
       *aOffset = 0.0f;
     else if (*aOffset > 1.0f)
       *aOffset = 1.0f;
   }
 
-  *aStopColor   = stopFrame->GetStyleSVGReset()->mStopColor;
-  *aStopOpacity = stopFrame->GetStyleSVGReset()->mStopOpacity;
+  *aStopColor   = stopFrame->StyleSVGReset()->mStopColor;
+  *aStopOpacity = stopFrame->StyleSVGReset()->mStopOpacity;
 }
 
 uint16_t
 nsSVGGradientFrame::GetEnumValue(uint32_t aIndex, nsIContent *aDefault)
 {
   const nsSVGEnum& thisEnum =
     static_cast<dom::SVGGradientElement*>(mContent)->mEnumAttributes[aIndex];
 
diff --git a/layout/svg/nsSVGImageFrame.cpp b/layout/svg/nsSVGImageFrame.cpp
--- a/layout/svg/nsSVGImageFrame.cpp
+++ b/layout/svg/nsSVGImageFrame.cpp
@@ -280,17 +280,17 @@ nsSVGImageFrame::TransformContextForPain
 //----------------------------------------------------------------------
 // nsISVGChildFrame methods:
 NS_IMETHODIMP
 nsSVGImageFrame::PaintSVG(nsRenderingContext *aContext,
                           const nsIntRect *aDirtyRect)
 {
   nsresult rv = NS_OK;
 
-  if (!GetStyleVisibility()->IsVisible())
+  if (!StyleVisibility()->IsVisible())
     return NS_OK;
 
   float x, y, width, height;
   SVGImageElement *imgElem = static_cast<SVGImageElement*>(mContent);
   imgElem->GetAnimatedLengthValues(&x, &y, &width, &height, nullptr);
   NS_ASSERTION(width > 0 && height > 0,
                "Should only be painting things with valid width/height");
 
@@ -304,32 +304,32 @@ nsSVGImageFrame::PaintSVG(nsRenderingCon
     if (currentRequest)
       currentRequest->GetImage(getter_AddRefs(mImageContainer));
   }
 
   if (mImageContainer) {
     gfxContext* ctx = aContext->ThebesContext();
     gfxContextAutoSaveRestore autoRestorer(ctx);
 
-    if (GetStyleDisplay()->IsScrollableOverflow()) {
+    if (StyleDisplay()->IsScrollableOverflow()) {
       gfxRect clipRect = nsSVGUtils::GetClipRectForFrame(this, x, y,
                                                          width, height);
       nsSVGUtils::SetClipRect(ctx, GetCanvasTM(FOR_PAINTING), clipRect);
     }
 
     if (!TransformContextForPainting(ctx)) {
       return NS_ERROR_FAILURE;
     }
 
     // fill-opacity doesn't affect <image>, so if we're allowed to
     // optimize group opacity, the opacity used for compositing the
     // image into the current canvas is just the group opacity.
     float opacity = 1.0f;
     if (nsSVGUtils::CanOptimizeOpacity(this)) {
-      opacity = GetStyleDisplay()->mOpacity;
+      opacity = StyleDisplay()->mOpacity;
     }
 
     if (opacity != 1.0f) {
       ctx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
     }
 
     nscoord appUnitsPerDevPx = PresContext()->AppUnitsPerDevPixel();
     nsRect dirtyRect; // only used if aDirtyRect is non-null
@@ -411,17 +411,17 @@ nsSVGImageFrame::PaintSVG(nsRenderingCon
 NS_IMETHODIMP_(nsIFrame*)
 nsSVGImageFrame::GetFrameForPoint(const nsPoint &aPoint)
 {
   // Special case for raster images -- we only want to accept points that fall
   // in the underlying image's (transformed) native bounds.  That region
   // doesn't necessarily map to our <image> element's [x,y,width,height].  So,
   // we have to look up the native image size & our image transform in order
   // to filter out points that fall outside that area.
-  if (GetStyleDisplay()->IsScrollableOverflow() && mImageContainer) {
+  if (StyleDisplay()->IsScrollableOverflow() && mImageContainer) {
     if (mImageContainer->GetType() == imgIContainer::TYPE_RASTER) {
       int32_t nativeWidth, nativeHeight;
       if (NS_FAILED(mImageContainer->GetWidth(&nativeWidth)) ||
           NS_FAILED(mImageContainer->GetHeight(&nativeHeight)) ||
           nativeWidth == 0 || nativeHeight == 0) {
         return nullptr;
       }
 
@@ -522,30 +522,30 @@ nsSVGImageFrame::ReflowSVG()
   }
 }
 
 uint16_t
 nsSVGImageFrame::GetHitTestFlags()
 {
   uint16_t flags = 0;
 
-  switch(GetStyleVisibility()->mPointerEvents) {
+  switch(StyleVisibility()->mPointerEvents) {
     case NS_STYLE_POINTER_EVENTS_NONE:
       break;
     case NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED:
     case NS_STYLE_POINTER_EVENTS_AUTO:
-      if (GetStyleVisibility()->IsVisible()) {
+      if (StyleVisibility()->IsVisible()) {
         /* XXX: should check pixel transparency */
         flags |= SVG_HIT_TEST_FILL;
       }
       break;
     case NS_STYLE_POINTER_EVENTS_VISIBLEFILL:
     case NS_STYLE_POINTER_EVENTS_VISIBLESTROKE:
     case NS_STYLE_POINTER_EVENTS_VISIBLE:
-      if (GetStyleVisibility()->IsVisible()) {
+      if (StyleVisibility()->IsVisible()) {
         flags |= SVG_HIT_TEST_FILL;
       }
       break;
     case NS_STYLE_POINTER_EVENTS_PAINTED:
       /* XXX: should check pixel transparency */
       flags |= SVG_HIT_TEST_FILL;
       break;
     case NS_STYLE_POINTER_EVENTS_FILL:
diff --git a/layout/svg/nsSVGInnerSVGFrame.cpp b/layout/svg/nsSVGInnerSVGFrame.cpp
--- a/layout/svg/nsSVGInnerSVGFrame.cpp
+++ b/layout/svg/nsSVGInnerSVGFrame.cpp
@@ -62,17 +62,17 @@ nsSVGInnerSVGFrame::PaintSVG(nsRendering
 {
   NS_ASSERTION(!NS_SVGDisplayListPaintingEnabled() ||
                (mState & NS_STATE_SVG_NONDISPLAY_CHILD),
                "If display lists are enabled, only painting of non-display "
                "SVG should take this code path");
 
   gfxContextAutoSaveRestore autoSR;
 
-  if (GetStyleDisplay()->IsScrollableOverflow()) {
+  if (StyleDisplay()->IsScrollableOverflow()) {
     float x, y, width, height;
     static_cast<SVGSVGElement*>(mContent)->
       GetAnimatedLengthValues(&x, &y, &width, &height, nullptr);
 
     if (width <= 0 || height <= 0) {
       return NS_OK;
     }
 
@@ -218,17 +218,17 @@ nsSVGInnerSVGFrame::AttributeChanged(int
 NS_IMETHODIMP_(nsIFrame*)
 nsSVGInnerSVGFrame::GetFrameForPoint(const nsPoint &aPoint)
 {
   NS_ASSERTION(!NS_SVGDisplayListHitTestingEnabled() ||
                (mState & NS_STATE_SVG_NONDISPLAY_CHILD),
                "If display lists are enabled, only hit-testing of non-display "
                "SVG should take this code path");
 
-  if (GetStyleDisplay()->IsScrollableOverflow()) {
+  if (StyleDisplay()->IsScrollableOverflow()) {
     nsSVGElement *content = static_cast<nsSVGElement*>(mContent);
     nsSVGContainerFrame *parent = static_cast<nsSVGContainerFrame*>(mParent);
 
     float clipX, clipY, clipWidth, clipHeight;
     content->GetAnimatedLengthValues(&clipX, &clipY, &clipWidth, &clipHeight, nullptr);
 
     if (!nsSVGUtils::HitTestRect(parent->GetCanvasTM(FOR_HIT_TESTING),
                                  clipX, clipY, clipWidth, clipHeight,
diff --git a/layout/svg/nsSVGIntegrationUtils.cpp b/layout/svg/nsSVGIntegrationUtils.cpp
--- a/layout/svg/nsSVGIntegrationUtils.cpp
+++ b/layout/svg/nsSVGIntegrationUtils.cpp
@@ -143,17 +143,17 @@ GetPreEffectsVisualOverflowUnion(nsIFram
 
 bool
 nsSVGIntegrationUtils::UsingEffectsForFrame(const nsIFrame* aFrame)
 {
   // Even when SVG display lists are disabled, returning true for SVG frames
   // does not adversely affect any of our callers. Therefore we don't bother
   // checking the SDL prefs here, since we don't know if we're being called for
   // painting or hit-testing anyway.
-  const nsStyleSVGReset *style = aFrame->GetStyleSVGReset();
+  const nsStyleSVGReset *style = aFrame->StyleSVGReset();
   return (style->mFilter || style->mClipPath || style->mMask);
 }
 
 /* static */ nsPoint
 nsSVGIntegrationUtils::GetOffsetToUserSpace(nsIFrame* aFrame)
 {
   if ((aFrame->GetStateBits() & NS_FRAME_SVG_LAYOUT)) {
     // Do NOT call GetAllInFlowRectsUnion for SVG - it will get the
@@ -427,17 +427,17 @@ nsSVGIntegrationUtils::PaintFramesWithEf
       NS_ASSERTION(false, "why?");
       return;
     }
     if (!static_cast<const nsSVGElement*>(content)->HasValidDimensions()) {
       return; // The SVG spec says not to draw _anything_
     }
   }
 
-  float opacity = aFrame->GetStyleDisplay()->mOpacity;
+  float opacity = aFrame->StyleDisplay()->mOpacity;
   if (opacity == 0.0f) {
     return;
   }
   if (opacity != 1.0f &&
       hasSVGLayout && nsSVGUtils::CanOptimizeOpacity(aFrame)) {
     opacity = 1.0f;
   }
 
diff --git a/layout/svg/nsSVGMarkerFrame.cpp b/layout/svg/nsSVGMarkerFrame.cpp
--- a/layout/svg/nsSVGMarkerFrame.cpp
+++ b/layout/svg/nsSVGMarkerFrame.cpp
@@ -117,17 +117,17 @@ nsSVGMarkerFrame::PaintMark(nsRenderingC
 
   mStrokeWidth = aStrokeWidth;
   mX = aMark->x;
   mY = aMark->y;
   mAutoAngle = aMark->angle;
 
   gfxContext *gfx = aContext->ThebesContext();
 
-  if (GetStyleDisplay()->IsScrollableOverflow()) {
+  if (StyleDisplay()->IsScrollableOverflow()) {
     gfx->Save();
     gfxRect clipRect =
       nsSVGUtils::GetClipRectForFrame(this, viewBox.x, viewBox.y,
                                       viewBox.width, viewBox.height);
     nsSVGUtils::SetClipRect(gfx, GetCanvasTM(nsISVGChildFrame::FOR_PAINTING),
                             clipRect);
   }
 
@@ -136,17 +136,17 @@ nsSVGMarkerFrame::PaintMark(nsRenderingC
     nsISVGChildFrame* SVGFrame = do_QueryFrame(kid);
     if (SVGFrame) {
       // The CTM of each frame referencing us may be different.
       SVGFrame->NotifySVGChanged(nsISVGChildFrame::TRANSFORM_CHANGED);
       nsSVGUtils::PaintFrameWithEffects(aContext, nullptr, kid);
     }
   }
 
-  if (GetStyleDisplay()->IsScrollableOverflow())
+  if (StyleDisplay()->IsScrollableOverflow())
     gfx->Restore();
 
   return NS_OK;
 }
 
 SVGBBox
 nsSVGMarkerFrame::GetMarkBBoxContribution(const gfxMatrix &aToBBoxUserspace,
                                           uint32_t aFlags,
diff --git a/layout/svg/nsSVGMaskFrame.cpp b/layout/svg/nsSVGMaskFrame.cpp
--- a/layout/svg/nsSVGMaskFrame.cpp
+++ b/layout/svg/nsSVGMaskFrame.cpp
@@ -111,22 +111,22 @@ nsSVGMaskFrame::ComputeMaskAlpha(nsRende
     nsSVGUtils::PaintFrameWithEffects(&tmpCtx, nullptr, kid);
   }
 
   uint8_t *data   = image->Data();
   int32_t  stride = image->Stride();
 
   nsIntRect rect(0, 0, surfaceSize.width, surfaceSize.height);
   nsSVGUtils::UnPremultiplyImageDataAlpha(data, stride, rect);
-  if (GetStyleSVG()->mColorInterpolation ==
+  if (StyleSVG()->mColorInterpolation ==
       NS_STYLE_COLOR_INTERPOLATION_LINEARRGB) {
     nsSVGUtils::ConvertImageDataToLinearRGB(data, stride, rect);
   }
 
-  if (GetStyleSVGReset()->mMaskType == NS_STYLE_MASK_TYPE_LUMINANCE) {
+  if (StyleSVGReset()->mMaskType == NS_STYLE_MASK_TYPE_LUMINANCE) {
     for (int32_t y = 0; y < surfaceSize.height; y++) {
       for (int32_t x = 0; x < surfaceSize.width; x++) {
         uint8_t *pixel = data + stride * y + 4 * x;
 
         /* linearRGB -> intensity */
         uint8_t alpha =
           static_cast<uint8_t>
                      ((pixel[GFX_ARGB32_OFFSET_R] * 0.2125 +
diff --git a/layout/svg/nsSVGOuterSVGFrame.cpp b/layout/svg/nsSVGOuterSVGFrame.cpp
--- a/layout/svg/nsSVGOuterSVGFrame.cpp
+++ b/layout/svg/nsSVGOuterSVGFrame.cpp
@@ -622,17 +622,17 @@ nsDisplayOuterSVG::ComputeInvalidationRe
   nsDisplayItem::ComputeInvalidationRegion(aBuilder, aGeometry, aInvalidRegion);
   aInvalidRegion->Or(*aInvalidRegion, result);
 }
 
 // helper
 static inline bool
 DependsOnIntrinsicSize(const nsIFrame* aEmbeddingFrame)
 {
-  const nsStylePosition *pos = aEmbeddingFrame->GetStylePosition();
+  const nsStylePosition *pos = aEmbeddingFrame->StylePosition();
   const nsStyleCoord &width = pos->mWidth;
   const nsStyleCoord &height = pos->mHeight;
 
   // XXX it would be nice to know if the size of aEmbeddingFrame's containing
   // block depends on aEmbeddingFrame, then we'd know if we can return false
   // for eStyleUnit_Percent too.
   return !width.ConvertsToLength() ||
          !height.ConvertsToLength();
diff --git a/layout/svg/nsSVGPathGeometryFrame.cpp b/layout/svg/nsSVGPathGeometryFrame.cpp
--- a/layout/svg/nsSVGPathGeometryFrame.cpp
+++ b/layout/svg/nsSVGPathGeometryFrame.cpp
@@ -177,20 +177,20 @@ nsSVGPathGeometryFrame::BuildDisplayList
 
 //----------------------------------------------------------------------
 // nsISVGChildFrame methods
 
 NS_IMETHODIMP
 nsSVGPathGeometryFrame::PaintSVG(nsRenderingContext *aContext,
                                  const nsIntRect *aDirtyRect)
 {
-  if (!GetStyleVisibility()->IsVisible())
+  if (!StyleVisibility()->IsVisible())
     return NS_OK;
 
-  uint32_t paintOrder = GetStyleSVG()->mPaintOrder;
+  uint32_t paintOrder = StyleSVG()->mPaintOrder;
   if (paintOrder == NS_STYLE_PAINT_ORDER_NORMAL) {
     Render(aContext, eRenderFill | eRenderStroke);
     PaintMarkers(aContext);
   } else {
     while (paintOrder) {
       uint32_t component =
         paintOrder & ((1 << NS_STYLE_PAINT_ORDER_BITWIDTH) - 1);
       switch (component) {
@@ -226,17 +226,17 @@ nsSVGPathGeometryFrame::GetFrameForPoint
     hitTestFlags = GetHitTestFlags();
     // XXX once bug 614732 is fixed, aPoint won't need any conversion in order
     // to compare it with mRect.
     nsPoint point =
       nsSVGUtils::TransformOuterSVGPointToChildFrame(aPoint, canvasTM, PresContext());
     if (!hitTestFlags || ((hitTestFlags & SVG_HIT_TEST_CHECK_MRECT) &&
                           !mRect.Contains(point)))
       return nullptr;
-    fillRule = GetStyleSVG()->mFillRule;
+    fillRule = StyleSVG()->mFillRule;
   }
 
   bool isHit = false;
 
   nsRefPtr<gfxContext> tmpCtx =
     new gfxContext(gfxPlatform::GetPlatform()->ScreenReferenceSurface());
 
   GeneratePath(tmpCtx, canvasTM);
@@ -386,17 +386,17 @@ nsSVGPathGeometryFrame::GetBBoxContribut
   // # If the stroke is very thin, cairo won't paint any stroke, and so the
   //   stroke bounds that it will return will be empty.
 
   gfxRect pathExtents = tmpCtx->GetUserPathExtent();
 
   // Account for fill:
   if ((aFlags & nsSVGUtils::eBBoxIncludeFillGeometry) ||
       ((aFlags & nsSVGUtils::eBBoxIncludeFill) &&
-       GetStyleSVG()->mFill.mType != eStyleSVGPaintType_None)) {
+       StyleSVG()->mFill.mType != eStyleSVGPaintType_None)) {
     bbox = pathExtents;
   }
 
   // Account for stroke:
   if ((aFlags & nsSVGUtils::eBBoxIncludeStrokeGeometry) ||
       ((aFlags & nsSVGUtils::eBBoxIncludeStroke) &&
        nsSVGUtils::HasStroke(this))) {
     // We can't use tmpCtx->GetUserStrokeExtent() since it doesn't work for
@@ -488,17 +488,17 @@ nsSVGPathGeometryFrame::GetCanvasTM(uint
 // nsSVGPathGeometryFrame methods:
 
 nsSVGPathGeometryFrame::MarkerProperties
 nsSVGPathGeometryFrame::GetMarkerProperties(nsSVGPathGeometryFrame *aFrame)
 {
   NS_ASSERTION(!aFrame->GetPrevContinuation(), "aFrame should be first continuation");
 
   MarkerProperties result;
-  const nsStyleSVG *style = aFrame->GetStyleSVG();
+  const nsStyleSVG *style = aFrame->StyleSVG();
   result.mMarkerStart =
     nsSVGEffects::GetMarkerProperty(style->mMarkerStart, aFrame,
                                     nsSVGEffects::MarkerBeginProperty());
   result.mMarkerMid =
     nsSVGEffects::GetMarkerProperty(style->mMarkerMid, aFrame,
                                     nsSVGEffects::MarkerMiddleProperty());
   result.mMarkerEnd =
     nsSVGEffects::GetMarkerProperty(style->mMarkerEnd, aFrame,
@@ -536,17 +536,17 @@ nsSVGPathGeometryFrame::MarkerProperties
 void
 nsSVGPathGeometryFrame::Render(nsRenderingContext *aContext,
                                uint32_t aRenderComponents)
 {
   gfxContext *gfx = aContext->ThebesContext();
 
   uint16_t renderMode = SVGAutoRenderState::GetRenderMode(aContext);
 
-  switch (GetStyleSVG()->mShapeRendering) {
+  switch (StyleSVG()->mShapeRendering) {
   case NS_STYLE_SHAPE_RENDERING_OPTIMIZESPEED:
   case NS_STYLE_SHAPE_RENDERING_CRISPEDGES:
     gfx->SetAntialiasMode(gfxContext::MODE_ALIASED);
     break;
   default:
     gfx->SetAntialiasMode(gfxContext::MODE_COVERAGE);
     break;
   }
@@ -602,17 +602,17 @@ nsSVGPathGeometryFrame::GeneratePath(gfx
     aContext->IdentityMatrix();
     aContext->NewPath();
     return;
   }
 
   aContext->MultiplyAndNudgeToIntegers(aTransform);
 
   // Hack to let SVGPathData::ConstructPath know if we have square caps:
-  const nsStyleSVG* style = GetStyleSVG();
+  const nsStyleSVG* style = StyleSVG();
   if (style->mStrokeLinecap == NS_STYLE_STROKE_LINECAP_SQUARE) {
     aContext->SetLineCap(gfxContext::LINE_CAP_SQUARE);
   }
 
   aContext->NewPath();
   static_cast<nsSVGPathGeometryElement*>(mContent)->ConstructPath(aContext);
 }
 
diff --git a/layout/svg/nsSVGSwitchFrame.cpp b/layout/svg/nsSVGSwitchFrame.cpp
--- a/layout/svg/nsSVGSwitchFrame.cpp
+++ b/layout/svg/nsSVGSwitchFrame.cpp
@@ -108,17 +108,17 @@ NS_IMETHODIMP
 nsSVGSwitchFrame::PaintSVG(nsRenderingContext* aContext,
                            const nsIntRect *aDirtyRect)
 {
   NS_ASSERTION(!NS_SVGDisplayListPaintingEnabled() ||
                (mState & NS_STATE_SVG_NONDISPLAY_CHILD),
                "If display lists are enabled, only painting of non-display "
                "SVG should take this code path");
 
-  if (GetStyleDisplay()->mOpacity == 0.0)
+  if (StyleDisplay()->mOpacity == 0.0)
     return NS_OK;
 
   nsIFrame *kid = GetActiveChildFrame();
   if (kid) {
     nsSVGUtils::PaintFrameWithEffects(aContext, aDirtyRect, kid);
   }
   return NS_OK;
 }
diff --git a/layout/svg/nsSVGTextFrame.cpp b/layout/svg/nsSVGTextFrame.cpp
--- a/layout/svg/nsSVGTextFrame.cpp
+++ b/layout/svg/nsSVGTextFrame.cpp
@@ -435,17 +435,17 @@ nsSVGTextFrame::UpdateGlyphPositioning(b
      * whenever the 'direction' property is rtl.
      *
      * This is probably the "right" thing to do, but other browsers don't do it,
      * so I am leaving it inside #if 0 for now for interoperability.
      *
      * See also XXXsmontagu comments in nsSVGGlyphFrame::EnsureTextRun
      */
 #if 0
-    if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
+    if (StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
       if (anchor == NS_STYLE_TEXT_ANCHOR_END) {
         anchor = NS_STYLE_TEXT_ANCHOR_START;
       } else if (anchor == NS_STYLE_TEXT_ANCHOR_START) {
         anchor = NS_STYLE_TEXT_ANCHOR_END;
       }
     }
 #endif
 
diff --git a/layout/svg/nsSVGTextFrame2.cpp b/layout/svg/nsSVGTextFrame2.cpp
--- a/layout/svg/nsSVGTextFrame2.cpp
+++ b/layout/svg/nsSVGTextFrame2.cpp
@@ -1553,17 +1553,17 @@ public:
   }
 
 private:
   /**
    * Initializes the iterator and advances to the first item.
    */
   void Init()
   {
-    mBaselines.AppendElement(mRootFrame->GetStyleSVGReset()->mDominantBaseline);
+    mBaselines.AppendElement(mRootFrame->StyleSVGReset()->mDominantBaseline);
     Next();
   }
 
   /**
    * Pushes the specified frame's computed dominant-baseline value.
    * If the value of the property is "auto", then the parent frame's
    * computed value is used.
    */
@@ -1699,17 +1699,17 @@ TextFrameIterator::Next()
   }
 
   return Current();
 }
 
 void
 TextFrameIterator::PushBaseline(nsIFrame* aNextFrame)
 {
-  uint8_t baseline = aNextFrame->GetStyleSVGReset()->mDominantBaseline;
+  uint8_t baseline = aNextFrame->StyleSVGReset()->mDominantBaseline;
   if (baseline != NS_STYLE_DOMINANT_BASELINE_AUTO) {
     mBaselines.AppendElement(baseline);
   } else {
     mBaselines.AppendElement(mBaselines[mBaselines.Length() - 1]);
   }
 }
 
 void
@@ -1926,17 +1926,17 @@ TextRenderedRunIterator::Next()
     nsTextFrame::TrimmedOffsets trimmedOffsets =
       frame->GetTrimmedOffsets(frame->GetContent()->GetText(), true);
     TrimOffsets(offset, length, trimmedOffsets);
 
     // Determine if we should skip this rendered run.
     bool skip = !mFrameIterator.IsWithinSubtree() ||
                 Root()->mPositions[mTextElementCharIndex].mHidden;
     if (mFilter == eVisibleFrames) {
-      skip = skip || !frame->GetStyleVisibility()->IsVisible();
+      skip = skip || !frame->StyleVisibility()->IsVisible();
     }
 
     // Update our global character index to move past the characters
     // corresponding to this rendered run.
     mTextElementCharIndex += untrimmedLength;
 
     // If we have moved past the end of the current frame's content, we need to
     // advance to the next frame.
@@ -2304,17 +2304,17 @@ CharIterator::IsOriginalCharTrimmed() co
   }
 
   // A character is trimmed if it is outside the mTrimmedOffset/mTrimmedLength
   // range and it is not a significant newline character.
   uint32_t index = mSkipCharsIterator.GetOriginalOffset();
   return !((index >= mTrimmedOffset &&
             index < mTrimmedOffset + mTrimmedLength) ||
            (index >= mTrimmedOffset + mTrimmedLength &&
-            mFrameForTrimCheck->GetStyleText()->NewlineIsSignificant() &&
+            mFrameForTrimCheck->StyleText()->NewlineIsSignificant() &&
             mFrameForTrimCheck->GetContent()->GetText()->CharAt(index) == '\n'));
 }
 
 void
 CharIterator::GetOriginalGlyphOffsets(uint32_t& aOriginalOffset,
                                       uint32_t& aOriginalLength) const
 {
   gfxSkipCharsIterator it = TextFrame()->EnsureTextRun(nsTextFrame::eInflated);
@@ -2655,32 +2655,32 @@ SVGTextDrawPathCallbacks::FillWithOpacit
 void
 SVGTextDrawPathCallbacks::SetupContext()
 {
   gfx->Save();
 
   // XXX This is copied from nsSVGGlyphFrame::Render, but cairo doesn't actually
   // seem to do anything with the antialias mode.  So we can perhaps remove it,
   // or make SetAntialiasMode set cairo text antialiasing too.
-  switch (mFrame->GetStyleSVG()->mTextRendering) {
+  switch (mFrame->StyleSVG()->mTextRendering) {
   case NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED:
     gfx->SetAntialiasMode(gfxContext::MODE_ALIASED);
     break;
   default:
     gfx->SetAntialiasMode(gfxContext::MODE_COVERAGE);
     break;
   }
 }
 
 void
 SVGTextDrawPathCallbacks::HandleTextGeometry()
 {
   if (mRenderMode != SVGAutoRenderState::NORMAL) {
     // We're in a clip path.
-    if (mFrame->GetStyleSVG()->mClipRule == NS_STYLE_FILL_RULE_EVENODD)
+    if (mFrame->StyleSVG()->mClipRule == NS_STYLE_FILL_RULE_EVENODD)
       gfx->SetFillRule(gfxContext::FILL_RULE_EVEN_ODD);
     else
       gfx->SetFillRule(gfxContext::FILL_RULE_WINDING);
 
     if (mRenderMode == SVGAutoRenderState::CLIP_MASK) {
       gfx->SetColor(gfxRGBA(1.0f, 1.0f, 1.0f, 1.0f));
       gfx->Fill();
     }
@@ -3327,17 +3327,17 @@ nsSVGTextFrame2::ReflowSVG()
 
   gfxRect r;
   TextRenderedRunIterator it(this, TextRenderedRunIterator::eAllFrames);
   for (TextRenderedRun run = it.Current(); run.mFrame; run = it.Next()) {
     uint32_t runFlags = 0;
     uint16_t hitTestFlags = nsSVGUtils::GetGeometryHitTestFlags(run.mFrame);
 
     if ((hitTestFlags & SVG_HIT_TEST_FILL) ||
-        run.mFrame->GetStyleSVG()->mFill.mType == eStyleSVGPaintType_None) {
+        run.mFrame->StyleSVG()->mFill.mType == eStyleSVGPaintType_None) {
       runFlags |= TextRenderedRun::eIncludeFill;
     }
     if ((hitTestFlags & SVG_HIT_TEST_STROKE) ||
         nsSVGUtils::HasStroke(run.mFrame)) {
       runFlags |= TextRenderedRun::eIncludeStroke;
     }
 
     if (runFlags) {
@@ -3389,17 +3389,17 @@ nsSVGTextFrame2::ReflowSVG()
  */
 static uint32_t
 TextRenderedRunFlagsForBBoxContribution(const TextRenderedRun& aRun,
                                         uint32_t aBBoxFlags)
 {
   uint32_t flags = 0;
   if ((aBBoxFlags & nsSVGUtils::eBBoxIncludeFillGeometry) ||
       ((aBBoxFlags & nsSVGUtils::eBBoxIncludeFill) &&
-       aRun.mFrame->GetStyleSVG()->mFill.mType != eStyleSVGPaintType_None)) {
+       aRun.mFrame->StyleSVG()->mFill.mType != eStyleSVGPaintType_None)) {
     flags |= TextRenderedRun::eIncludeFill;
   }
   if ((aBBoxFlags & nsSVGUtils::eBBoxIncludeStrokeGeometry) ||
       ((aBBoxFlags & nsSVGUtils::eBBoxIncludeStroke) &&
        nsSVGUtils::HasStroke(aRun.mFrame))) {
     flags |= TextRenderedRun::eIncludeStroke;
   }
   return flags;
@@ -4416,19 +4416,19 @@ nsSVGTextFrame2::DoAnchoring()
         }
       }
       it.Next();
       index = end = it.TextElementCharIndex();
     } while (!it.AtEnd() && !mPositions[end].mStartOfChunk);
 
     if (left != std::numeric_limits<gfxFloat>::infinity()) {
       bool isRTL =
-        chunkFrame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
+        chunkFrame->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
       TextAnchorSide anchor =
-        ConvertLogicalTextAnchorToPhysical(chunkFrame->GetStyleSVG()->mTextAnchor,
+        ConvertLogicalTextAnchorToPhysical(chunkFrame->StyleSVG()->mTextAnchor,
                                            isRTL);
 
       ShiftAnchoredChunk(mPositions, start, end, left, right, anchor);
     }
 
     start = it.TextElementCharIndex();
   }
 }
@@ -4547,17 +4547,17 @@ nsSVGTextFrame2::ShouldRenderAsPath(nsRe
   // Rendering to a clip path.
   if (SVGAutoRenderState::GetRenderMode(aContext) != SVGAutoRenderState::NORMAL) {
     aShouldPaintSVGGlyphs = false;
     return true;
   }
 
   aShouldPaintSVGGlyphs = true;
 
-  const nsStyleSVG* style = aFrame->GetStyleSVG();
+  const nsStyleSVG* style = aFrame->StyleSVG();
 
   // Fill is a non-solid paint, has a non-default fill-rule or has
   // non-1 opacity.
   if (!(style->mFill.mType == eStyleSVGPaintType_None ||
         (style->mFill.mType == eStyleSVGPaintType_Color &&
          style->mFillRule == NS_STYLE_FILL_RULE_NONZERO &&
          style->mFillOpacity == 1))) {
     return true;
@@ -4682,20 +4682,20 @@ nsSVGTextFrame2::UpdateFontSizeScaleFact
   // Find the minimum and maximum font sizes used over all the
   // nsTextFrames.
   TextFrameIterator it(this);
   nsTextFrame* f = it.Current();
   while (f) {
     if (!geometricPrecision) {
       // Unfortunately we can't treat text-rendering:geometricPrecision
       // separately for each text frame.
-      geometricPrecision = f->GetStyleSVG()->mTextRendering ==
+      geometricPrecision = f->StyleSVG()->mTextRendering ==
                              NS_STYLE_TEXT_RENDERING_GEOMETRICPRECISION;
     }
-    nscoord size = f->GetStyleFont()->mFont.size;
+    nscoord size = f->StyleFont()->mFont.size;
     if (size) {
       min = std::min(min, size);
       max = std::max(max, size);
     }
     f = it.Next();
   }
 
   if (min == nscoord_MAX) {
@@ -4997,17 +4997,17 @@ nsSVGTextFrame2::SetupCairoState(gfxCont
 }
 
 bool
 nsSVGTextFrame2::SetupCairoStroke(gfxContext* aContext,
                                   nsIFrame* aFrame,
                                   gfxTextObjectPaint* aOuterObjectPaint,
                                   SVGTextObjectPaint* aThisObjectPaint)
 {
-  const nsStyleSVG *style = aFrame->GetStyleSVG();
+  const nsStyleSVG *style = aFrame->StyleSVG();
   if (style->mStroke.mType == eStyleSVGPaintType_None) {
     aThisObjectPaint->SetStrokeOpacity(0.0f);
     return false;
   }
 
   gfxContextMatrixAutoSaveRestore matrixRestore(aContext);
   aContext->IdentityMatrix();
 
@@ -5026,17 +5026,17 @@ nsSVGTextFrame2::SetupCairoStroke(gfxCon
 }
 
 bool
 nsSVGTextFrame2::SetupCairoFill(gfxContext* aContext,
                                 nsIFrame* aFrame,
                                 gfxTextObjectPaint* aOuterObjectPaint,
                                 SVGTextObjectPaint* aThisObjectPaint)
 {
-  const nsStyleSVG *style = aFrame->GetStyleSVG();
+  const nsStyleSVG *style = aFrame->StyleSVG();
   if (style->mFill.mType == eStyleSVGPaintType_None) {
     aThisObjectPaint->SetFillOpacity(0.0f);
     return false;
   }
 
   float opacity = nsSVGUtils::GetOpacity(style->mFillOpacitySource,
                                          style->mFillOpacity,
                                          aOuterObjectPaint);
@@ -5054,17 +5054,17 @@ void
 nsSVGTextFrame2::SetupInheritablePaint(gfxContext* aContext,
                                        nsIFrame* aFrame,
                                        float& aOpacity,
                                        gfxTextObjectPaint* aOuterObjectPaint,
                                        SVGTextObjectPaint::Paint& aTargetPaint,
                                        nsStyleSVGPaint nsStyleSVG::*aFillOrStroke,
                                        const FramePropertyDescriptor* aProperty)
 {
-  const nsStyleSVG *style = aFrame->GetStyleSVG();
+  const nsStyleSVG *style = aFrame->StyleSVG();
   nsSVGPaintServerFrame *ps =
     nsSVGEffects::GetPaintServer(aFrame, &(style->*aFillOrStroke), aProperty);
 
   if (ps && ps->SetupPaintServer(aContext, aFrame, aFillOrStroke, aOpacity)) {
     aTargetPaint.SetPaintServer(aFrame, aContext->CurrentMatrix(), ps);
   } else if (SetupObjectPaint(aContext, aFrame, aFillOrStroke, aOpacity, aOuterObjectPaint)) {
     aTargetPaint.SetObjectPaint(aOuterObjectPaint, (style->*aFillOrStroke).mType);
   } else {
@@ -5086,17 +5086,17 @@ nsSVGTextFrame2::SetupObjectPaint(gfxCon
                                   nsStyleSVGPaint nsStyleSVG::*aFillOrStroke,
                                   float& aOpacity,
                                   gfxTextObjectPaint* aOuterObjectPaint)
 {
   if (!aOuterObjectPaint) {
     return false;
   }
 
-  const nsStyleSVG *style = aFrame->GetStyleSVG();
+  const nsStyleSVG *style = aFrame->StyleSVG();
   const nsStyleSVGPaint &paint = style->*aFillOrStroke;
 
   if (paint.mType != eStyleSVGPaintType_ObjectFill &&
       paint.mType != eStyleSVGPaintType_ObjectStroke) {
     return false;
   }
 
   gfxMatrix current = aContext->CurrentMatrix();
diff --git a/layout/svg/nsSVGUtils.cpp b/layout/svg/nsSVGUtils.cpp
--- a/layout/svg/nsSVGUtils.cpp
+++ b/layout/svg/nsSVGUtils.cpp
@@ -434,17 +434,17 @@ nsSVGUtils::InvalidateBounds(nsIFrame *a
     if ((aFrame->GetStateBits() & NS_FRAME_IS_DIRTY)) {
       // This ancestor frame has already been invalidated, so nothing to do.
       return;
     }
     if (aFrame->GetStateBits() & NS_STATE_IS_OUTER_SVG) {
       break;
     }
     if (aFrame->GetType() == nsGkAtoms::svgInnerSVGFrame &&
-        aFrame->GetStyleDisplay()->IsScrollableOverflow()) {
+        aFrame->StyleDisplay()->IsScrollableOverflow()) {
       // Clip rect to the viewport established by this inner-<svg>:
       float x, y, width, height;
       static_cast<SVGSVGElement*>(aFrame->GetContent())->
         GetAnimatedLengthValues(&x, &y, &width, &height, nullptr);
       if (width <= 0.0f || height <= 0.0f) {
         return; // Nothing to invalidate
       }
       nsRect viewportRect =
@@ -764,17 +764,17 @@ nsSVGUtils::PaintFrameWithEffects(nsRend
                aFrame->PresContext()->IsGlyph(),
                "If display lists are enabled, only painting of non-display "
                "SVG should take this code path");
 
   nsISVGChildFrame *svgChildFrame = do_QueryFrame(aFrame);
   if (!svgChildFrame)
     return;
 
-  float opacity = aFrame->GetStyleDisplay()->mOpacity;
+  float opacity = aFrame->StyleDisplay()->mOpacity;
   if (opacity == 0.0f)
     return;
 
   const nsIContent* content = aFrame->GetContent();
   if (content->IsSVG() &&
       !static_cast<const nsSVGElement*>(content)->HasValidDimensions()) {
     return;
   }
@@ -1087,17 +1087,17 @@ nsSVGUtils::HitTestRect(const gfxMatrix 
   return rect.x <= p.x && p.x <= rect.XMost() &&
          rect.y <= p.y && p.y <= rect.YMost();
 }
 
 gfxRect
 nsSVGUtils::GetClipRectForFrame(nsIFrame *aFrame,
                                 float aX, float aY, float aWidth, float aHeight)
 {
-  const nsStyleDisplay* disp = aFrame->GetStyleDisplay();
+  const nsStyleDisplay* disp = aFrame->StyleDisplay();
 
   if (!(disp->mClipFlags & NS_STYLE_CLIP_RECT)) {
     NS_ASSERTION(disp->mClipFlags == NS_STYLE_CLIP_AUTO,
                  "We don't know about this type of clip.");
     return gfxRect(aX, aY, aWidth, aHeight);
   }
 
   if (disp->mOverflowX == NS_STYLE_OVERFLOW_HIDDEN ||
@@ -1280,24 +1280,24 @@ nsSVGUtils::CanOptimizeOpacity(nsIFrame 
   if (!(aFrame->GetStateBits() & NS_FRAME_SVG_LAYOUT)) {
     return false;
   }
   nsIAtom *type = aFrame->GetType();
   if (type != nsGkAtoms::svgImageFrame &&
       type != nsGkAtoms::svgPathGeometryFrame) {
     return false;
   }
-  if (aFrame->GetStyleSVGReset()->mFilter) {
+  if (aFrame->StyleSVGReset()->mFilter) {
     return false;
   }
   // XXX The SVG WG is intending to allow fill, stroke and markers on <image>
   if (type == nsGkAtoms::svgImageFrame) {
     return true;
   }
-  const nsStyleSVG *style = aFrame->GetStyleSVG();
+  const nsStyleSVG *style = aFrame->StyleSVG();
   if (style->mMarkerStart || style->mMarkerMid || style->mMarkerEnd) {
     return false;
   }
   if (style->mFill.mType == eStyleSVGPaintType_None ||
       style->mFillOpacity <= 0 ||
       !HasStroke(aFrame)) {
     return true;
   }
@@ -1346,17 +1346,17 @@ nsSVGUtils::GetFirstNonAAncestorFrame(ns
     }
   }
   return nullptr;
 }
 
 gfxMatrix
 nsSVGUtils::GetStrokeTransform(nsIFrame *aFrame)
 {
-  if (aFrame->GetStyleSVGReset()->mVectorEffect ==
+  if (aFrame->StyleSVGReset()->mVectorEffect ==
       NS_STYLE_VECTOR_EFFECT_NON_SCALING_STROKE) {
  
     if (aFrame->GetContent()->IsNodeOfType(nsINode::eTEXT)) {
       aFrame = aFrame->GetParent();
     }
 
     nsIContent *content = aFrame->GetContent();
     NS_ABORT_IF_FALSE(content->IsSVG(), "bad cast");
@@ -1415,17 +1415,17 @@ nsSVGUtils::PathExtentsToMaxStrokeExtent
 /*static*/ gfxRect
 nsSVGUtils::PathExtentsToMaxStrokeExtents(const gfxRect& aPathExtents,
                                           nsSVGPathGeometryFrame* aFrame,
                                           const gfxMatrix& aMatrix)
 {
   double styleExpansionFactor = 0.5;
 
   if (static_cast<nsSVGPathGeometryElement*>(aFrame->GetContent())->IsMarkable()) {
-    const nsStyleSVG* style = aFrame->GetStyleSVG();
+    const nsStyleSVG* style = aFrame->StyleSVG();
 
     if (style->mStrokeLinecap == NS_STYLE_STROKE_LINECAP_SQUARE) {
       styleExpansionFactor = M_SQRT1_2;
     }
 
     if (style->mStrokeLinejoin == NS_STYLE_STROKE_LINEJOIN_MITER &&
         styleExpansionFactor < style->mStrokeMiterlimit &&
         aFrame->GetContent()->Tag() != nsGkAtoms::line) {
@@ -1440,25 +1440,25 @@ nsSVGUtils::PathExtentsToMaxStrokeExtent
 }
 
 // ----------------------------------------------------------------------
 
 /* static */ nscolor
 nsSVGUtils::GetFallbackOrPaintColor(gfxContext *aContext, nsStyleContext *aStyleContext,
                                     nsStyleSVGPaint nsStyleSVG::*aFillOrStroke)
 {
-  const nsStyleSVGPaint &paint = aStyleContext->GetStyleSVG()->*aFillOrStroke;
+  const nsStyleSVGPaint &paint = aStyleContext->StyleSVG()->*aFillOrStroke;
   nsStyleContext *styleIfVisited = aStyleContext->GetStyleIfVisited();
   bool isServer = paint.mType == eStyleSVGPaintType_Server ||
                   paint.mType == eStyleSVGPaintType_ObjectFill ||
                   paint.mType == eStyleSVGPaintType_ObjectStroke;
   nscolor color = isServer ? paint.mFallbackColor : paint.mPaint.mColor;
   if (styleIfVisited) {
     const nsStyleSVGPaint &paintIfVisited =
-      styleIfVisited->GetStyleSVG()->*aFillOrStroke;
+      styleIfVisited->StyleSVG()->*aFillOrStroke;
     // To prevent Web content from detecting if a user has visited a URL
     // (via URL loading triggered by paint servers or performance
     // differences between paint servers or between a paint server and a
     // color), we do not allow whether links are visited to change which
     // paint server is used or switch between paint servers and simple
     // colors.  A :visited style may only override a simple color with
     // another simple color.
     if (paintIfVisited.mType == eStyleSVGPaintType_Color &&
@@ -1483,17 +1483,17 @@ SetupFallbackOrPaintColor(gfxContext *aC
                              NS_GET_G(color)/255.0,
                              NS_GET_B(color)/255.0,
                              NS_GET_A(color)/255.0 * aOpacity));
 }
 
 static float
 MaybeOptimizeOpacity(nsIFrame *aFrame, float aFillOrStrokeOpacity)
 {
-  float opacity = aFrame->GetStyleDisplay()->mOpacity;
+  float opacity = aFrame->StyleDisplay()->mOpacity;
   if (opacity < 1 && nsSVGUtils::CanOptimizeOpacity(aFrame)) {
     return aFillOrStrokeOpacity * opacity;
   }
   return aFillOrStrokeOpacity;
 }
 
 /* static */ bool
 nsSVGUtils::SetupObjectPaint(gfxContext *aContext,
@@ -1526,17 +1526,17 @@ nsSVGUtils::SetupObjectPaint(gfxContext 
 
   return true;
 }
 
 bool
 nsSVGUtils::SetupCairoFillPaint(nsIFrame *aFrame, gfxContext* aContext,
                                 gfxTextObjectPaint *aObjectPaint)
 {
-  const nsStyleSVG* style = aFrame->GetStyleSVG();
+  const nsStyleSVG* style = aFrame->StyleSVG();
   if (style->mFill.mType == eStyleSVGPaintType_None)
     return false;
 
   if (style->mFillRule == NS_STYLE_FILL_RULE_EVENODD)
     aContext->SetFillRule(gfxContext::FILL_RULE_EVEN_ODD);
   else
     aContext->SetFillRule(gfxContext::FILL_RULE_WINDING);
 
@@ -1561,17 +1561,17 @@ nsSVGUtils::SetupCairoFillPaint(nsIFrame
 
   return true;
 }
 
 bool
 nsSVGUtils::SetupCairoStrokePaint(nsIFrame *aFrame, gfxContext* aContext,
                                   gfxTextObjectPaint *aObjectPaint)
 {
-  const nsStyleSVG* style = aFrame->GetStyleSVG();
+  const nsStyleSVG* style = aFrame->StyleSVG();
   if (style->mStroke.mType == eStyleSVGPaintType_None)
     return false;
 
   float opacity = MaybeOptimizeOpacity(aFrame,
                                        GetOpacity(style->mStrokeOpacitySource,
                                                   style->mStrokeOpacity,
                                                   aObjectPaint));
 
@@ -1621,26 +1621,26 @@ nsSVGUtils::GetOpacity(nsStyleSVGOpacity
     NS_NOTREACHED("Unknown object opacity inheritance type for SVG glyph");
   }
   return opacity;
 }
 
 bool
 nsSVGUtils::HasStroke(nsIFrame* aFrame, gfxTextObjectPaint *aObjectPaint)
 {
-  const nsStyleSVG *style = aFrame->GetStyleSVG();
+  const nsStyleSVG *style = aFrame->StyleSVG();
   return style->mStroke.mType != eStyleSVGPaintType_None &&
          style->mStrokeOpacity > 0 &&
          GetStrokeWidth(aFrame, aObjectPaint) > 0;
 }
 
 float
 nsSVGUtils::GetStrokeWidth(nsIFrame* aFrame, gfxTextObjectPaint *aObjectPaint)
 {
-  const nsStyleSVG *style = aFrame->GetStyleSVG();
+  const nsStyleSVG *style = aFrame->StyleSVG();
   if (aObjectPaint && style->mStrokeWidthFromObject) {
     return aObjectPaint->GetStrokeWidth();
   }
 
   nsIContent* content = aFrame->GetContent();
   if (content->IsNodeOfType(nsINode::eTEXT)) {
     content = content->GetParent();
   }
@@ -1658,17 +1658,17 @@ nsSVGUtils::SetupCairoStrokeGeometry(nsI
   float width = GetStrokeWidth(aFrame, aObjectPaint);
   if (width <= 0)
     return;
   aContext->SetLineWidth(width);
 
   // Apply any stroke-specific transform
   aContext->Multiply(GetStrokeTransform(aFrame));
 
-  const nsStyleSVG* style = aFrame->GetStyleSVG();
+  const nsStyleSVG* style = aFrame->StyleSVG();
   
   switch (style->mStrokeLinecap) {
   case NS_STYLE_STROKE_LINECAP_BUTT:
     aContext->SetLineCap(gfxContext::LINE_CAP_BUTT);
     break;
   case NS_STYLE_STROKE_LINECAP_ROUND:
     aContext->SetLineCap(gfxContext::LINE_CAP_ROUND);
     break;
@@ -1693,17 +1693,17 @@ nsSVGUtils::SetupCairoStrokeGeometry(nsI
 }
 
 static bool
 GetStrokeDashData(nsIFrame* aFrame,
                   FallibleTArray<gfxFloat>& aDashes,
                   gfxFloat* aDashOffset,
                   gfxTextObjectPaint *aObjectPaint)
 {
-  const nsStyleSVG* style = aFrame->GetStyleSVG();
+  const nsStyleSVG* style = aFrame->StyleSVG();
   nsPresContext *presContext = aFrame->PresContext();
   nsIContent *content = aFrame->GetContent();
   nsSVGElement *ctx = static_cast<nsSVGElement*>
     (content->IsNodeOfType(nsINode::eTEXT) ?
      content->GetParent() : content);
 
   gfxFloat totalLength = 0.0;
   if (aObjectPaint && style->mStrokeDasharrayFromObject) {
@@ -1773,51 +1773,51 @@ nsSVGUtils::SetupCairoStrokeHitGeometry(
   }
 }
 
 uint16_t
 nsSVGUtils::GetGeometryHitTestFlags(nsIFrame* aFrame)
 {
   uint16_t flags = 0;
 
-  switch(aFrame->GetStyleVisibility()->mPointerEvents) {
+  switch(aFrame->StyleVisibility()->mPointerEvents) {
   case NS_STYLE_POINTER_EVENTS_NONE:
     break;
   case NS_STYLE_POINTER_EVENTS_AUTO:
   case NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED:
-    if (aFrame->GetStyleVisibility()->IsVisible()) {
-      if (aFrame->GetStyleSVG()->mFill.mType != eStyleSVGPaintType_None)
+    if (aFrame->StyleVisibility()->IsVisible()) {
+      if (aFrame->StyleSVG()->mFill.mType != eStyleSVGPaintType_None)
         flags |= SVG_HIT_TEST_FILL;
-      if (aFrame->GetStyleSVG()->mStroke.mType != eStyleSVGPaintType_None)
+      if (aFrame->StyleSVG()->mStroke.mType != eStyleSVGPaintType_None)
         flags |= SVG_HIT_TEST_STROKE;
-      if (aFrame->GetStyleSVG()->mStrokeOpacity > 0)
+      if (aFrame->StyleSVG()->mStrokeOpacity > 0)
         flags |= SVG_HIT_TEST_CHECK_MRECT;
     }
     break;
   case NS_STYLE_POINTER_EVENTS_VISIBLEFILL:
-    if (aFrame->GetStyleVisibility()->IsVisible()) {
+    if (aFrame->StyleVisibility()->IsVisible()) {
       flags |= SVG_HIT_TEST_FILL;
     }
     break;
   case NS_STYLE_POINTER_EVENTS_VISIBLESTROKE:
-    if (aFrame->GetStyleVisibility()->IsVisible()) {
+    if (aFrame->StyleVisibility()->IsVisible()) {
       flags |= SVG_HIT_TEST_STROKE;
     }
     break;
   case NS_STYLE_POINTER_EVENTS_VISIBLE:
-    if (aFrame->GetStyleVisibility()->IsVisible()) {
+    if (aFrame->StyleVisibility()->IsVisible()) {
       flags |= SVG_HIT_TEST_FILL | SVG_HIT_TEST_STROKE;
     }
     break;
   case NS_STYLE_POINTER_EVENTS_PAINTED:
-    if (aFrame->GetStyleSVG()->mFill.mType != eStyleSVGPaintType_None)
+    if (aFrame->StyleSVG()->mFill.mType != eStyleSVGPaintType_None)
       flags |= SVG_HIT_TEST_FILL;
-    if (aFrame->GetStyleSVG()->mStroke.mType != eStyleSVGPaintType_None)
+    if (aFrame->StyleSVG()->mStroke.mType != eStyleSVGPaintType_None)
       flags |= SVG_HIT_TEST_STROKE;
-    if (aFrame->GetStyleSVG()->mStrokeOpacity)
+    if (aFrame->StyleSVG()->mStrokeOpacity)
       flags |= SVG_HIT_TEST_CHECK_MRECT;
     break;
   case NS_STYLE_POINTER_EVENTS_FILL:
     flags |= SVG_HIT_TEST_FILL;
     break;
   case NS_STYLE_POINTER_EVENTS_STROKE:
     flags |= SVG_HIT_TEST_STROKE;
     break;
diff --git a/layout/tables/BasicTableLayoutStrategy.cpp b/layout/tables/BasicTableLayoutStrategy.cpp
--- a/layout/tables/BasicTableLayoutStrategy.cpp
+++ b/layout/tables/BasicTableLayoutStrategy.cpp
@@ -76,17 +76,17 @@ struct CellWidthInfo {
 
 // Used for both column and cell calculations.  The parts needed only
 // for cells are skipped when aIsCell is false.
 static CellWidthInfo
 GetWidthInfo(nsRenderingContext *aRenderingContext,
              nsIFrame *aFrame, bool aIsCell)
 {
     nscoord minCoord, prefCoord;
-    const nsStylePosition *stylePos = aFrame->GetStylePosition();
+    const nsStylePosition *stylePos = aFrame->StylePosition();
     bool isQuirks = aFrame->PresContext()->CompatibilityMode() ==
                     eCompatibility_NavQuirks;
     nscoord boxSizingToBorderEdge = 0;
     if (aIsCell) {
         // If aFrame is a container for font size inflation, then shrink
         // wrapping inside of it should not apply font size inflation.
         AutoMaybeDisableFontInflation an(aFrame);
 
diff --git a/layout/tables/FixedTableLayoutStrategy.cpp b/layout/tables/FixedTableLayoutStrategy.cpp
--- a/layout/tables/FixedTableLayoutStrategy.cpp
+++ b/layout/tables/FixedTableLayoutStrategy.cpp
@@ -61,17 +61,17 @@ FixedTableLayoutStrategy::GetMinWidth(ns
 
     for (int32_t col = 0; col < colCount; ++col) {
         nsTableColFrame *colFrame = mTableFrame->GetColFrame(col);
         if (!colFrame) {
             NS_ERROR("column frames out of sync with cell map");
             continue;
         }
         const nsStyleCoord *styleWidth =
-            &colFrame->GetStylePosition()->mWidth;
+            &colFrame->StylePosition()->mWidth;
         if (styleWidth->ConvertsToLength()) {
             result += nsLayoutUtils::ComputeWidthValue(aRenderingContext,
                         colFrame, 0, 0, 0, *styleWidth);
         } else if (styleWidth->GetUnit() == eStyleUnit_Percent) {
             // do nothing
         } else {
             NS_ASSERTION(styleWidth->GetUnit() == eStyleUnit_Auto ||
                          styleWidth->GetUnit() == eStyleUnit_Enumerated ||
@@ -80,17 +80,17 @@ FixedTableLayoutStrategy::GetMinWidth(ns
 
             // The 'table-layout: fixed' algorithm considers only cells
             // in the first row.
             bool originates;
             int32_t colSpan;
             nsTableCellFrame *cellFrame =
                 cellMap->GetCellInfoAt(0, col, &originates, &colSpan);
             if (cellFrame) {
-                styleWidth = &cellFrame->GetStylePosition()->mWidth;
+                styleWidth = &cellFrame->StylePosition()->mWidth;
                 if (styleWidth->ConvertsToLength() ||
                     (styleWidth->GetUnit() == eStyleUnit_Enumerated &&
                      (styleWidth->GetIntValue() == NS_STYLE_WIDTH_MAX_CONTENT ||
                       styleWidth->GetIntValue() == NS_STYLE_WIDTH_MIN_CONTENT))) {
                     nscoord cellWidth = nsLayoutUtils::IntrinsicForContainer(
                         aRenderingContext, cellFrame, nsLayoutUtils::MIN_WIDTH);
                     if (colSpan > 1) {
                         // If a column-spanning cell is in the first
@@ -202,17 +202,17 @@ FixedTableLayoutStrategy::ComputeColumnW
         if (!colFrame) {
             oldColWidths.AppendElement(0);
             NS_ERROR("column frames out of sync with cell map");
             continue;
         }
         oldColWidths.AppendElement(colFrame->GetFinalWidth());
         colFrame->ResetPrefPercent();
         const nsStyleCoord *styleWidth =
-            &colFrame->GetStylePosition()->mWidth;
+            &colFrame->StylePosition()->mWidth;
         nscoord colWidth;
         if (styleWidth->ConvertsToLength()) {
             colWidth = nsLayoutUtils::ComputeWidthValue(
                          aReflowState.rendContext,
                          colFrame, 0, 0, 0, *styleWidth);
             specTotal += colWidth;
         } else if (styleWidth->GetUnit() == eStyleUnit_Percent) {
             float pct = styleWidth->GetPercentValue();
@@ -227,17 +227,17 @@ FixedTableLayoutStrategy::ComputeColumnW
 
             // The 'table-layout: fixed' algorithm considers only cells
             // in the first row.
             bool originates;
             int32_t colSpan;
             nsTableCellFrame *cellFrame =
                 cellMap->GetCellInfoAt(0, col, &originates, &colSpan);
             if (cellFrame) {
-                styleWidth = &cellFrame->GetStylePosition()->mWidth;
+                styleWidth = &cellFrame->StylePosition()->mWidth;
                 if (styleWidth->ConvertsToLength() ||
                     (styleWidth->GetUnit() == eStyleUnit_Enumerated &&
                      (styleWidth->GetIntValue() == NS_STYLE_WIDTH_MAX_CONTENT ||
                       styleWidth->GetIntValue() == NS_STYLE_WIDTH_MIN_CONTENT))) {
                     // XXX This should use real percentage padding
                     // Note that the difference between MIN_WIDTH and
                     // PREF_WIDTH shouldn't matter for any of these
                     // values of styleWidth; use MIN_WIDTH for symmetry
diff --git a/layout/tables/nsCellMap.cpp b/layout/tables/nsCellMap.cpp
--- a/layout/tables/nsCellMap.cpp
+++ b/layout/tables/nsCellMap.cpp
@@ -234,17 +234,17 @@ nsTableCellMap::GetMapFor(const nsTableR
   if (map) {
     return map;
   }
 
   // if aRowGroup is a repeated header or footer find the header or footer it was repeated from
   if (aRowGroup->IsRepeatable()) {
     nsTableFrame* fifTable = static_cast<nsTableFrame*>(mTableFrame.GetFirstInFlow());
 
-    const nsStyleDisplay* display = aRowGroup->GetStyleDisplay();
+    const nsStyleDisplay* display = aRowGroup->StyleDisplay();
     nsTableRowGroupFrame* rgOrig =
       (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == display->mDisplay) ?
       fifTable->GetTHead() : fifTable->GetTFoot();
     // find the row group cell map using the original header/footer
     if (rgOrig && rgOrig != aRowGroup) {
       return GetMapFor(rgOrig, aStartHint);
     }
   }
@@ -2532,17 +2532,17 @@ void nsCellMap::ExpandZeroColSpans(nsTab
     }
   }
 }
 #ifdef DEBUG
 void nsCellMap::Dump(bool aIsBorderCollapse) const
 {
   printf("\n  ***** START GROUP CELL MAP DUMP ***** %p\n", (void*)this);
   nsTableRowGroupFrame* rg = GetRowGroup();
-  const nsStyleDisplay* display = rg->GetStyleDisplay();
+  const nsStyleDisplay* display = rg->StyleDisplay();
   switch (display->mDisplay) {
   case NS_STYLE_DISPLAY_TABLE_HEADER_GROUP:
     printf("  thead ");
     break;
   case NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP:
     printf("  tfoot ");
     break;
   case NS_STYLE_DISPLAY_TABLE_ROW_GROUP:
diff --git a/layout/tables/nsTableCellFrame.cpp b/layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp
+++ b/layout/tables/nsTableCellFrame.cpp
@@ -305,17 +305,17 @@ nsTableCellFrame::DecorateForSelection(n
         bordercolor =
           LookAndFeel::GetColor(LookAndFeel::eColorID_TextSelectBackground);
       }
       nscoord threePx = nsPresContext::CSSPixelsToAppUnits(3);
       if ((mRect.width > threePx) && (mRect.height > threePx))
       {
         //compare bordercolor to ((nsStyleColor *)myColor)->mBackgroundColor)
         bordercolor = EnsureDifferentColors(bordercolor,
-                                            GetStyleBackground()->mBackgroundColor);
+                                            StyleBackground()->mBackgroundColor);
         nsRenderingContext::AutoPushTranslation
             translate(&aRenderingContext, aPt);
         nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
 
         aRenderingContext.SetColor(bordercolor);
         aRenderingContext.DrawLine(onePixel, 0, mRect.width, 0);
         aRenderingContext.DrawLine(0, onePixel, 0, mRect.height);
         aRenderingContext.DrawLine(onePixel, mRect.height, mRect.width, mRect.height);
@@ -345,17 +345,17 @@ nsTableCellFrame::PaintBackground(nsRend
 }
 
 // Called by nsTablePainter
 void
 nsTableCellFrame::PaintCellBackground(nsRenderingContext& aRenderingContext,
                                       const nsRect& aDirtyRect, nsPoint aPt,
                                       uint32_t aFlags)
 {
-  if (!GetStyleVisibility()->IsVisible())
+  if (!StyleVisibility()->IsVisible())
     return;
 
   PaintBackground(aRenderingContext, aDirtyRect, aPt, aFlags);
 }
 
 class nsDisplayTableCellBackground : public nsDisplayTableItem {
 public:
   nsDisplayTableCellBackground(nsDisplayListBuilder* aBuilder,
@@ -423,44 +423,44 @@ NS_IMETHODIMP
 nsTableCellFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                    const nsRect&           aDirtyRect,
                                    const nsDisplayListSet& aLists)
 {
   DO_GLOBAL_REFLOW_COUNT_DSP("nsTableCellFrame");
   if (IsVisibleInSelection(aBuilder)) {
     nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
     int32_t emptyCellStyle = GetContentEmpty() && !tableFrame->IsBorderCollapse() ?
-                                GetStyleTableBorder()->mEmptyCells
+                                StyleTableBorder()->mEmptyCells
                                 : NS_STYLE_TABLE_EMPTY_CELLS_SHOW;
     // take account of 'empty-cells'
-    if (GetStyleVisibility()->IsVisible() &&
+    if (StyleVisibility()->IsVisible() &&
         (NS_STYLE_TABLE_EMPTY_CELLS_HIDE != emptyCellStyle)) {
     
     
       bool isRoot = aBuilder->IsAtRootOfPseudoStackingContext();
       if (!isRoot) {
         nsDisplayTableItem* currentItem = aBuilder->GetCurrentTableItem();
         if (currentItem) {
           currentItem->UpdateForFrameBackground(this);
         }
       }
     
       // display outset box-shadows if we need to.
-      const nsStyleBorder* borderStyle = GetStyleBorder();
+      const nsStyleBorder* borderStyle = StyleBorder();
       bool hasBoxShadow = !!borderStyle->mBoxShadow;
       if (hasBoxShadow) {
         nsresult rv = aLists.BorderBackground()->AppendNewToTop(
             new (aBuilder) nsDisplayBoxShadowOuter(aBuilder, this));
         NS_ENSURE_SUCCESS(rv, rv);
       }
     
       // display background if we need to.
       if (aBuilder->IsForEventDelivery() ||
           (((!tableFrame->IsBorderCollapse() || isRoot) &&
-          (!GetStyleBackground()->IsTransparent() || GetStyleDisplay()->mAppearance)))) {
+          (!StyleBackground()->IsTransparent() || StyleDisplay()->mAppearance)))) {
         // The cell background was not painted by the nsTablePainter,
         // so we need to do it. We have special background processing here
         // so we need to duplicate some code from nsFrame::DisplayBorderBackgroundOutline
         nsDisplayTableItem* item =
           new (aBuilder) nsDisplayTableCellBackground(aBuilder, this);
         nsresult rv = aLists.BorderBackground()->AppendNewToTop(item);
         NS_ENSURE_SUCCESS(rv, rv);
         item->UpdateForFrameBackground(this);
@@ -619,17 +619,17 @@ nsTableCellFrame::UpdateOverflow()
   return FinishAndStoreOverflow(overflowAreas, GetSize());
 }
 
 // Per CSS 2.1, we map 'sub', 'super', 'text-top', 'text-bottom',
 // length, percentage, and calc() values to 'baseline'.
 uint8_t
 nsTableCellFrame::GetVerticalAlign() const
 {
-  const nsStyleCoord& verticalAlign = GetStyleTextReset()->mVerticalAlign;
+  const nsStyleCoord& verticalAlign = StyleTextReset()->mVerticalAlign;
   if (verticalAlign.GetUnit() == eStyleUnit_Enumerated) {
     uint8_t value = verticalAlign.GetIntValue();
     if (value == NS_STYLE_VERTICAL_ALIGN_TOP ||
         value == NS_STYLE_VERTICAL_ALIGN_MIDDLE ||
         value == NS_STYLE_VERTICAL_ALIGN_BOTTOM) {
       return value;
     }
   }
@@ -1016,17 +1016,17 @@ NS_NewTableCellFrame(nsIPresShell*   aPr
     return new (aPresShell) nsTableCellFrame(aContext);
 }
 
 NS_IMPL_FRAMEARENA_HELPERS(nsBCTableCellFrame)
 
 nsMargin*
 nsTableCellFrame::GetBorderWidth(nsMargin&  aBorder) const
 {
-  aBorder = GetStyleBorder()->GetComputedBorder();
+  aBorder = StyleBorder()->GetComputedBorder();
   return &aBorder;
 }
 
 nsIAtom*
 nsTableCellFrame::GetType() const
 {
   return nsGkAtoms::tableCellFrame;
 }
@@ -1146,21 +1146,21 @@ nsBCTableCellFrame::PaintBackground(nsRe
                                     nsPoint              aPt,
                                     uint32_t             aFlags)
 {
   // make border-width reflect the half of the border-collapse
   // assigned border that's inside the cell
   nsMargin borderWidth;
   GetBorderWidth(borderWidth);
 
-  nsStyleBorder myBorder(*GetStyleBorder());
+  nsStyleBorder myBorder(*StyleBorder());
   // We're making an ephemeral stack copy here, so just copy this debug-only
   // member to prevent assertions.
 #ifdef DEBUG
-  myBorder.mImageTracked = GetStyleBorder()->mImageTracked;
+  myBorder.mImageTracked = StyleBorder()->mImageTracked;
 #endif
 
   NS_FOR_CSS_SIDES(side) {
     myBorder.SetBorderWidth(side, borderWidth.Side(side));
   }
 
   nsRect rect(aPt, GetSize());
   // bypassing nsCSSRendering::PaintBackground is safe because this kind
diff --git a/layout/tables/nsTableColFrame.cpp b/layout/tables/nsTableColFrame.cpp
--- a/layout/tables/nsTableColFrame.cpp
+++ b/layout/tables/nsTableColFrame.cpp
@@ -89,30 +89,30 @@ NS_METHOD nsTableColFrame::Reflow(nsPres
                                   nsHTMLReflowMetrics&     aDesiredSize,
                                   const nsHTMLReflowState& aReflowState,
                                   nsReflowStatus&          aStatus)
 {
   DO_GLOBAL_REFLOW_COUNT("nsTableColFrame");
   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
   aDesiredSize.width=0;
   aDesiredSize.height=0;
-  const nsStyleVisibility* colVis = GetStyleVisibility();
+  const nsStyleVisibility* colVis = StyleVisibility();
   bool collapseCol = (NS_STYLE_VISIBILITY_COLLAPSE == colVis->mVisible);
   if (collapseCol) {
     nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
     tableFrame->SetNeedToCollapse(true);
   }
   aStatus = NS_FRAME_COMPLETE;
   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
   return NS_OK;
 }
 
 int32_t nsTableColFrame::GetSpan()
 {
-  return GetStyleTable()->mSpan;
+  return StyleTable()->mSpan;
 }
 
 #ifdef DEBUG
 void nsTableColFrame::Dump(int32_t aIndent)
 {
   char* indent = new char[aIndent + 1];
   if (!indent) return;
   for (int32_t i = 0; i < aIndent + 1; i++) {
diff --git a/layout/tables/nsTableColGroupFrame.cpp b/layout/tables/nsTableColGroupFrame.cpp
--- a/layout/tables/nsTableColGroupFrame.cpp
+++ b/layout/tables/nsTableColGroupFrame.cpp
@@ -355,17 +355,17 @@ NS_METHOD nsTableColGroupFrame::Reflow(n
                                        const nsHTMLReflowState& aReflowState,
                                        nsReflowStatus&          aStatus)
 {
   DO_GLOBAL_REFLOW_COUNT("nsTableColGroupFrame");
   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
   NS_ASSERTION(nullptr!=mContent, "bad state -- null content for frame");
   nsresult rv=NS_OK;
   
-  const nsStyleVisibility* groupVis = GetStyleVisibility();
+  const nsStyleVisibility* groupVis = StyleVisibility();
   bool collapseGroup = (NS_STYLE_VISIBILITY_COLLAPSE == groupVis->mVisible);
   if (collapseGroup) {
     nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
     tableFrame->SetNeedToCollapse(true);
   }
   // for every content child that (is a column thingy and does not already have a frame)
   // create a frame and adjust it's style
   
@@ -401,29 +401,29 @@ nsTableColFrame * nsTableColGroupFrame::
     childFrame = mFrames.FirstChild();
   }
   else {
     childFrame = childFrame->GetNextSibling();
   }
   while (childFrame)
   {
     if (NS_STYLE_DISPLAY_TABLE_COLUMN ==
-        childFrame->GetStyleDisplay()->mDisplay)
+        childFrame->StyleDisplay()->mDisplay)
     {
       result = (nsTableColFrame *)childFrame;
       break;
     }
     childFrame = childFrame->GetNextSibling();
   }
   return result;
 }
 
 int32_t nsTableColGroupFrame::GetSpan()
 {
-  return GetStyleTable()->mSpan;
+  return StyleTable()->mSpan;
 }
 
 void nsTableColGroupFrame::SetContinuousBCBorderWidth(uint8_t     aForSide,
                                                       BCPixelSize aPixelValue)
 {
   switch (aForSide) {
     case NS_SIDE_TOP:
       mTopContBorderWidth = aPixelValue;
diff --git a/layout/tables/nsTableFrame.cpp b/layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp
+++ b/layout/tables/nsTableFrame.cpp
@@ -172,17 +172,17 @@ nsTableFrame::Init(nsIContent*      aCon
   NS_PRECONDITION(!aPrevInFlow ||
                   aPrevInFlow->GetType() == nsGkAtoms::tableFrame,
                   "prev-in-flow must be of same type");
 
   // Let the base class do its processing
   nsresult rv = nsContainerFrame::Init(aContent, aParent, aPrevInFlow);
 
   // see if border collapse is on, if so set it
-  const nsStyleTableBorder* tableStyle = GetStyleTableBorder();
+  const nsStyleTableBorder* tableStyle = StyleTableBorder();
   bool borderCollapse = (NS_STYLE_BORDER_COLLAPSE == tableStyle->mBorderCollapse);
   SetBorderCollapse(borderCollapse);
 
   // Create the cell map if this frame is the first-in-flow.
   if (!aPrevInFlow) {
     mCellMap = new nsTableCellMap(*this, borderCollapse);
     if (!mCellMap)
       return NS_ERROR_OUT_OF_MEMORY;
@@ -235,26 +235,26 @@ IsRepeatedFrame(nsIFrame* kidFrame)
           kidFrame->GetType() == nsGkAtoms::tableRowGroupFrame) &&
          (kidFrame->GetStateBits() & NS_REPEATED_ROW_OR_ROWGROUP);
 }
 
 bool
 nsTableFrame::PageBreakAfter(nsIFrame* aSourceFrame,
                              nsIFrame* aNextFrame)
 {
-  const nsStyleDisplay* display = aSourceFrame->GetStyleDisplay();
+  const nsStyleDisplay* display = aSourceFrame->StyleDisplay();
   nsTableRowGroupFrame* prevRg = do_QueryFrame(aSourceFrame);
   // don't allow a page break after a repeated element ...
   if ((display->mBreakAfter || (prevRg && prevRg->HasInternalBreakAfter())) &&
       !IsRepeatedFrame(aSourceFrame)) {
     return !(aNextFrame && IsRepeatedFrame(aNextFrame)); // or before
   }
 
   if (aNextFrame) {
-    display = aNextFrame->GetStyleDisplay();
+    display = aNextFrame->StyleDisplay();
     // don't allow a page break before a repeated element ...
      nsTableRowGroupFrame* nextRg = do_QueryFrame(aNextFrame);
     if ((display->mBreakBefore ||
         (nextRg && nextRg->HasInternalBreakBefore())) &&
         !IsRepeatedFrame(aNextFrame)) {
       return !IsRepeatedFrame(aSourceFrame); // or after
     }
   }
@@ -281,17 +281,17 @@ nsTableFrame::SetInitialChildList(ChildL
   }
 
   // XXXbz the below code is an icky cesspit that's only needed in its current
   // form for two reasons:
   // 1) Both rowgroups and column groups come in on the principal child list.
   while (aChildList.NotEmpty()) {
     nsIFrame* childFrame = aChildList.FirstChild();
     aChildList.RemoveFirstChild();
-    const nsStyleDisplay* childDisplay = childFrame->GetStyleDisplay();
+    const nsStyleDisplay* childDisplay = childFrame->StyleDisplay();
 
     if (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == childDisplay->mDisplay) {
       NS_ASSERTION(nsGkAtoms::tableColGroupFrame == childFrame->GetType(),
                    "This is not a colgroup");
       mColGroups.AppendFrame(nullptr, childFrame);
     }
     else { // row groups and unknown frames go on the main list for now
       mFrames.AppendFrame(nullptr, childFrame);
@@ -473,17 +473,17 @@ void nsTableFrame::ResetRowIndices(const
     excludeRowGroupsEnumerator.Next();
   }
 
   for (uint32_t rgX = 0; rgX < rowGroups.Length(); rgX++) {
     nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
     if (!excludeRowGroups.GetEntry(rgFrame)) {
       const nsFrameList& rowFrames = rgFrame->PrincipalChildList();
       for (nsFrameList::Enumerator rows(rowFrames); !rows.AtEnd(); rows.Next()) {
-        if (NS_STYLE_DISPLAY_TABLE_ROW==rows.get()->GetStyleDisplay()->mDisplay) {
+        if (NS_STYLE_DISPLAY_TABLE_ROW==rows.get()->StyleDisplay()->mDisplay) {
           ((nsTableRowFrame *)rows.get())->SetRowIndex(rowIndex);
           rowIndex++;
         }
       }
     }
   }
 }
 void nsTableFrame::InsertColGroups(int32_t                   aStartColIndex,
@@ -1046,17 +1046,17 @@ nsDisplayTableItem::IsVaryingRelativeToM
 }
 
 /* static */ void
 nsDisplayTableItem::UpdateForFrameBackground(nsIFrame* aFrame)
 {
   nsStyleContext *bgSC;
   if (!nsCSSRendering::FindBackground(aFrame->PresContext(), aFrame, &bgSC))
     return;
-  if (!bgSC->GetStyleBackground()->HasFixedBackground())
+  if (!bgSC->StyleBackground()->HasFixedBackground())
     return;
 
   mPartHasFixedBackground = true;
 }
 
 class nsDisplayTableBorderBackground : public nsDisplayTableItem {
 public:
   nsDisplayTableBorderBackground(nsDisplayListBuilder* aBuilder,
@@ -1148,17 +1148,17 @@ nsTableFrame::DisplayGenericTablePart(ns
     nsDisplayTableItem* currentItem = aBuilder->GetCurrentTableItem();
     // currentItem may be null, when none of the table parts have a
     // background or border
     if (currentItem) {
       currentItem->UpdateForFrameBackground(aFrame);
     }
 
     // Paint the outset box-shadows for the table frames
-    bool hasBoxShadow = aFrame->GetStyleBorder()->mBoxShadow != nullptr;
+    bool hasBoxShadow = aFrame->StyleBorder()->mBoxShadow != nullptr;
     if (hasBoxShadow) {
       nsresult rv = lists->BorderBackground()->AppendNewToTop(
           new (aBuilder) nsDisplayBoxShadowOuter(aBuilder, aFrame));
       NS_ENSURE_SUCCESS(rv, rv);
     }
 
     // Create dedicated background display items per-frame when we're
     // handling events.
@@ -1231,17 +1231,17 @@ NS_IMETHODIMP
 nsTableFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                const nsRect&           aDirtyRect,
                                const nsDisplayListSet& aLists)
 {
   DO_GLOBAL_REFLOW_COUNT_DSP_COLOR("nsTableFrame", NS_RGB(255,128,255));
 
   nsDisplayTableItem* item = nullptr;
   if (IsVisibleInSelection(aBuilder)) {
-    if (GetStyleVisibility()->IsVisible()) {
+    if (StyleVisibility()->IsVisible()) {
       nsMargin deflate = GetDeflationForBackground(PresContext());
       // If 'deflate' is (0,0,0,0) then we can paint the table background
       // in its own display item, so do that to take advantage of
       // opacity and visibility optimizations
       if (deflate == nsMargin(0, 0, 0, 0)) {
         nsDisplayBackgroundImage* bg;
         nsresult rv = DisplayBackgroundUnconditional(aBuilder, aLists, false, &bg);
         NS_ENSURE_SUCCESS(rv, rv);
@@ -1287,17 +1287,17 @@ nsTableFrame::PaintTableBorderBackground
                                  presContext, aRenderingContext,
                                  aDirtyRect, aPt, aBGPaintFlags);
   nsMargin deflate = GetDeflationForBackground(presContext);
   // If 'deflate' is (0,0,0,0) then we'll paint the table background
   // in a separate display item, so don't do it here.
   nsresult rv = painter.PaintTable(this, deflate, deflate != nsMargin(0, 0, 0, 0));
   if (NS_FAILED(rv)) return;
 
-  if (GetStyleVisibility()->IsVisible()) {
+  if (StyleVisibility()->IsVisible()) {
     if (!IsBorderCollapse()) {
       int skipSides = GetSkipSides();
       nsRect rect(aPt, mRect.Size());
       nsCSSRendering::PaintBorder(presContext, aRenderingContext, this,
                                   aDirtyRect, rect, mStyleContext, skipSides);
     }
     else {
       // XXX we should probably get rid of this translation at some stage
@@ -1329,30 +1329,30 @@ nsTableFrame::SetColumnDimensions(nscoor
 {
   nscoord cellSpacingX = GetCellSpacingX();
   nscoord cellSpacingY = GetCellSpacingY();
   nscoord colHeight = aHeight -= aBorderPadding.top + aBorderPadding.bottom +
                                  2* cellSpacingY;
 
   nsTableIterator iter(mColGroups);
   nsIFrame* colGroupFrame = iter.First();
-  bool tableIsLTR = GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR;
+  bool tableIsLTR = StyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR;
   int32_t colX =tableIsLTR ? 0 : std::max(0, GetColCount() - 1);
   int32_t tableColIncr = tableIsLTR ? 1 : -1;
   nsPoint colGroupOrigin(aBorderPadding.left + cellSpacingX,
                          aBorderPadding.top + cellSpacingY);
   while (colGroupFrame) {
     MOZ_ASSERT(colGroupFrame->GetType() == nsGkAtoms::tableColGroupFrame);
     nscoord colGroupWidth = 0;
     nsTableIterator iterCol(*colGroupFrame);
     nsIFrame* colFrame = iterCol.First();
     nsPoint colOrigin(0,0);
     while (colFrame) {
       if (NS_STYLE_DISPLAY_TABLE_COLUMN ==
-          colFrame->GetStyleDisplay()->mDisplay) {
+          colFrame->StyleDisplay()->mDisplay) {
         NS_ASSERTION(colX < GetColCount(), "invalid number of columns");
         nscoord colWidth = GetColumnWidth(colX);
         nsRect colRect(colOrigin.x, colOrigin.y, colWidth, colHeight);
         colFrame->SetRect(colRect);
         colOrigin.x += colWidth + cellSpacingX;
         colGroupWidth += colWidth + cellSpacingX;
         colX += tableColIncr;
       }
@@ -1819,17 +1819,17 @@ NS_METHOD nsTableFrame::Reflow(nsPresCon
 
 bool
 nsTableFrame::UpdateOverflow()
 {
   nsRect bounds(nsPoint(0, 0), GetSize());
 
   // As above in Reflow, make sure the table overflow area includes the table
   // rect, and check for collapsed borders leaking out.
-  if (!ApplyOverflowClipping(this, GetStyleDisplay())) {
+  if (!ApplyOverflowClipping(this, StyleDisplay())) {
     nsMargin bcMargin = GetExcludedOuterBCBorder();
     bounds.Inflate(bcMargin);
   }
 
   nsOverflowAreas overflowAreas(bounds, bounds);
   nsLayoutUtils::UnionChildOverflow(this, overflowAreas);
 
   return FinishAndStoreOverflow(overflowAreas, GetSize());
@@ -1863,17 +1863,17 @@ nsTableFrame::ReflowTable(nsHTMLReflowMe
 
 nsIFrame*
 nsTableFrame::GetFirstBodyRowGroupFrame()
 {
   nsIFrame* headerFrame = nullptr;
   nsIFrame* footerFrame = nullptr;
 
   for (nsIFrame* kidFrame = mFrames.FirstChild(); nullptr != kidFrame; ) {
-    const nsStyleDisplay* childDisplay = kidFrame->GetStyleDisplay();
+    const nsStyleDisplay* childDisplay = kidFrame->StyleDisplay();
 
     // We expect the header and footer row group frames to be first, and we only
     // allow one header and one footer
     if (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == childDisplay->mDisplay) {
       if (headerFrame) {
         // We already have a header frame and so this header frame is treated
         // like an ordinary body row group frame
         return kidFrame;
@@ -1983,25 +1983,25 @@ nscoord
 nsTableFrame::GetCollapsedWidth(nsMargin aBorderPadding)
 {
   NS_ASSERTION(!GetPrevInFlow(), "GetCollapsedWidth called on next in flow");
   nscoord cellSpacingX = GetCellSpacingX();
   nscoord width = cellSpacingX;
   width += aBorderPadding.left + aBorderPadding.right;
   for (nsIFrame* groupFrame = mColGroups.FirstChild(); groupFrame;
          groupFrame = groupFrame->GetNextSibling()) {
-    const nsStyleVisibility* groupVis = groupFrame->GetStyleVisibility();
+    const nsStyleVisibility* groupVis = groupFrame->StyleVisibility();
     bool collapseGroup = (NS_STYLE_VISIBILITY_COLLAPSE == groupVis->mVisible);
     nsTableColGroupFrame* cgFrame = (nsTableColGroupFrame*)groupFrame;
     for (nsTableColFrame* colFrame = cgFrame->GetFirstColumn(); colFrame;
          colFrame = colFrame->GetNextCol()) {
-      const nsStyleDisplay* colDisplay = colFrame->GetStyleDisplay();
+      const nsStyleDisplay* colDisplay = colFrame->StyleDisplay();
       int32_t colX = colFrame->GetColIndex();
       if (NS_STYLE_DISPLAY_TABLE_COLUMN == colDisplay->mDisplay) {
-        const nsStyleVisibility* colVis = colFrame->GetStyleVisibility();
+        const nsStyleVisibility* colVis = colFrame->StyleVisibility();
         bool collapseCol = (NS_STYLE_VISIBILITY_COLLAPSE == colVis->mVisible);
         int32_t colWidth = GetColumnWidth(colX);
         if (!collapseGroup && !collapseCol) {
           width += colWidth;
           if (ColumnHasCellSpacingBefore(colX))
             width += cellSpacingX;
         }
         else {
@@ -2058,17 +2058,17 @@ nsTableFrame::AppendFrames(ChildListID  
   // for everything else, we need to look at each frame individually
   // XXX The frame construction code should be separating out child frames
   // based on the type, bug 343048.
   while (!aFrameList.IsEmpty()) {
     nsIFrame* f = aFrameList.FirstChild();
     aFrameList.RemoveFrame(f);
 
     // See what kind of frame we have
-    const nsStyleDisplay* display = f->GetStyleDisplay();
+    const nsStyleDisplay* display = f->StyleDisplay();
 
     if (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == display->mDisplay) {
       nsTableColGroupFrame* lastColGroup =
         nsTableColGroupFrame::GetLastRealColGroup(this);
       int32_t startColIndex = (lastColGroup)
         ? lastColGroup->GetStartColumnIndex() + lastColGroup->GetColCount() : 0;
       mColGroups.InsertFrame(nullptr, lastColGroup, f);
       // Insert the colgroup and its cols into the table
@@ -2122,33 +2122,33 @@ nsTableFrame::InsertFrames(ChildListID  
       (!aPrevFrame && GetChildList(aListID).IsEmpty())) {
     // Treat this like an append; still a workaround for bug 343048.
     return AppendFrames(aListID, aFrameList);
   }
 
   // Collect ColGroupFrames into a separate list and insert those separately
   // from the other frames (bug 759249).
   ChildListInsertions insertions[2]; // ColGroup, other
-  const nsStyleDisplay* display = aFrameList.FirstChild()->GetStyleDisplay();
+  const nsStyleDisplay* display = aFrameList.FirstChild()->StyleDisplay();
   nsFrameList::FrameLinkEnumerator e(aFrameList);
   for (; !aFrameList.IsEmpty(); e.Next()) {
     nsIFrame* next = e.NextFrame();
-    if (!next || next->GetStyleDisplay()->mDisplay != display->mDisplay) {
+    if (!next || next->StyleDisplay()->mDisplay != display->mDisplay) {
       nsFrameList head = aFrameList.ExtractHead(e);
       if (display->mDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP) {
         insertions[0].mID = kColGroupList;
         insertions[0].mList.AppendFrames(nullptr, head);
       } else {
         insertions[1].mID = kPrincipalList;
         insertions[1].mList.AppendFrames(nullptr, head);
       }
       if (!next) {
         break;
       }
-      display = next->GetStyleDisplay();
+      display = next->StyleDisplay();
     }
   }
   for (uint32_t i = 0; i < ArrayLength(insertions); ++i) {
     // We pass aPrevFrame for both ColGroup and other frames since
     // HomogenousInsertFrames will only use it if it's a suitable
     // prev-sibling for the frames in the frame list.
     if (!insertions[i].mList.IsEmpty()) {
       HomogenousInsertFrames(insertions[i].mID, aPrevFrame,
@@ -2159,29 +2159,29 @@ nsTableFrame::InsertFrames(ChildListID  
 }
 
 void
 nsTableFrame::HomogenousInsertFrames(ChildListID     aListID,
                                      nsIFrame*       aPrevFrame,
                                      nsFrameList&    aFrameList)
 {
   // See what kind of frame we have
-  const nsStyleDisplay* display = aFrameList.FirstChild()->GetStyleDisplay();
+  const nsStyleDisplay* display = aFrameList.FirstChild()->StyleDisplay();
 #ifdef DEBUG
   // Verify that either all siblings have display:table-column-group, or they
   // all have display values different from table-column-group.
   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
-    const nsStyleDisplay* nextDisplay = e.get()->GetStyleDisplay();
+    const nsStyleDisplay* nextDisplay = e.get()->StyleDisplay();
     MOZ_ASSERT((display->mDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP) ==
                (nextDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP),
                "heterogenous childlist");
   }
 #endif
   if (aPrevFrame) {
-    const nsStyleDisplay* prevDisplay = aPrevFrame->GetStyleDisplay();
+    const nsStyleDisplay* prevDisplay = aPrevFrame->StyleDisplay();
     // Make sure they belong on the same frame list
     if ((display->mDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP) !=
         (prevDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP)) {
       // the previous frame is not valid, see comment at ::AppendFrames
       // XXXbz Using content indices here means XBL will get screwed
       // over...  Oh, well.
       nsIFrame* pseudoFrame = aFrameList.FirstChild();
       nsIContent* parentContent = GetContent();
@@ -2323,17 +2323,17 @@ nsTableFrame::DoRemoveFrame(ChildListID 
 }
 
 NS_IMETHODIMP
 nsTableFrame::RemoveFrame(ChildListID     aListID,
                           nsIFrame*       aOldFrame)
 {
   NS_ASSERTION(aListID == kColGroupList ||
                NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP !=
-                 aOldFrame->GetStyleDisplay()->mDisplay,
+                 aOldFrame->StyleDisplay()->mDisplay,
                "Wrong list name; use kColGroupList iff colgroup");
   nsIPresShell* shell = PresContext()->PresShell();
   nsTableFrame* lastParent = nullptr;
   while (aOldFrame) {
     nsIFrame* oldFrameNextContinuation = aOldFrame->GetNextContinuation();
     nsTableFrame* parent = static_cast<nsTableFrame*>(aOldFrame->GetParent());
     if (parent != lastParent) {
       parent->DrainSelfOverflowList();
@@ -2462,17 +2462,17 @@ nsTableFrame::GetExcludedOuterBCBorder()
 static
 void GetSeparateModelBorderPadding(const nsHTMLReflowState* aReflowState,
                                    nsStyleContext&          aStyleContext,
                                    nsMargin&                aBorderPadding)
 {
   // XXXbz Either we _do_ have a reflow state and then we can use its
   // mComputedBorderPadding or we don't and then we get the padding
   // wrong!
-  const nsStyleBorder* border = aStyleContext.GetStyleBorder();
+  const nsStyleBorder* border = aStyleContext.StyleBorder();
   aBorderPadding = border->GetComputedBorder();
   if (aReflowState) {
     aBorderPadding += aReflowState->mComputedPadding;
   }
 }
 
 nsMargin
 nsTableFrame::GetChildAreaOffset(const nsHTMLReflowState* aReflowState) const
@@ -2542,17 +2542,17 @@ nsTableFrame::OrderRowGroups(RowGroupArr
                              nsTableRowGroupFrame** aFoot) const
 {
   aChildren.Clear();
   nsTableRowGroupFrame* head = nullptr;
   nsTableRowGroupFrame* foot = nullptr;
 
   nsIFrame* kidFrame = mFrames.FirstChild();
   while (kidFrame) {
-    const nsStyleDisplay* kidDisplay = kidFrame->GetStyleDisplay();
+    const nsStyleDisplay* kidDisplay = kidFrame->StyleDisplay();
     nsTableRowGroupFrame* rowGroup =
       static_cast<nsTableRowGroupFrame*>(kidFrame);
 
     switch (kidDisplay->mDisplay) {
     case NS_STYLE_DISPLAY_TABLE_HEADER_GROUP:
       if (head) { // treat additional thead like tbody
         aChildren.AppendElement(rowGroup);
       }
@@ -2600,17 +2600,17 @@ nsTableFrame::OrderRowGroups(RowGroupArr
     *aFoot = foot;
 }
 
 nsTableRowGroupFrame*
 nsTableFrame::GetTHead() const
 {
   nsIFrame* kidFrame = mFrames.FirstChild();
   while (kidFrame) {
-    if (kidFrame->GetStyleDisplay()->mDisplay ==
+    if (kidFrame->StyleDisplay()->mDisplay ==
           NS_STYLE_DISPLAY_TABLE_HEADER_GROUP) {
       return static_cast<nsTableRowGroupFrame*>(kidFrame);
     }
 
     // Get the next sibling but skip it if it's also the next-in-flow, since
     // a next-in-flow will not be part of the current table.
     while (kidFrame) {
       nsIFrame* nif = kidFrame->GetNextInFlow();
@@ -2623,17 +2623,17 @@ nsTableFrame::GetTHead() const
   return nullptr;
 }
 
 nsTableRowGroupFrame*
 nsTableFrame::GetTFoot() const
 {
   nsIFrame* kidFrame = mFrames.FirstChild();
   while (kidFrame) {
-    if (kidFrame->GetStyleDisplay()->mDisplay ==
+    if (kidFrame->StyleDisplay()->mDisplay ==
           NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP) {
       return static_cast<nsTableRowGroupFrame*>(kidFrame);
     }
 
     // Get the next sibling but skip it if it's also the next-in-flow, since
     // a next-in-flow will not be part of the current table.
     while (kidFrame) {
       nsIFrame* nif = kidFrame->GetNextInFlow();
@@ -3364,26 +3364,26 @@ int32_t nsTableFrame::GetColumnWidth(int
 }
 
 // XXX: could cache this.  But be sure to check style changes if you do!
 nscoord nsTableFrame::GetCellSpacingX()
 {
   if (IsBorderCollapse())
     return 0;
 
-  return GetStyleTableBorder()->mBorderSpacingX;
+  return StyleTableBorder()->mBorderSpacingX;
 }
 
 // XXX: could cache this. But be sure to check style changes if you do!
 nscoord nsTableFrame::GetCellSpacingY()
 {
   if (IsBorderCollapse())
     return 0;
 
-  return GetStyleTableBorder()->mBorderSpacingY;
+  return StyleTableBorder()->mBorderSpacingY;
 }
 
 
 /* virtual */ nscoord
 nsTableFrame::GetBaseline() const
 {
   nscoord ascent = 0;
   RowGroupArray orderedRowGroups;
@@ -3422,17 +3422,17 @@ nsTableFrame::GetTableFrame(nsIFrame* aF
   }
   NS_RUNTIMEABORT("unable to find table parent");
   return nullptr;
 }
 
 bool
 nsTableFrame::IsAutoHeight()
 {
-  const nsStyleCoord &height = GetStylePosition()->mHeight;
+  const nsStyleCoord &height = StylePosition()->mHeight;
   // Don't consider calc() here like this quirk for percent.
   return height.GetUnit() == eStyleUnit_Auto ||
          (height.GetUnit() == eStyleUnit_Percent &&
           height.GetPercentValue() <= 0.0f);
 }
 
 nscoord
 nsTableFrame::CalcBorderBoxHeight(const nsHTMLReflowState& aState)
@@ -3445,23 +3445,23 @@ nsTableFrame::CalcBorderBoxHeight(const 
   height = std::max(0, height);
 
   return height;
 }
 
 bool
 nsTableFrame::IsAutoLayout()
 {
-  if (GetStyleTable()->mLayoutStrategy == NS_STYLE_TABLE_LAYOUT_AUTO)
+  if (StyleTable()->mLayoutStrategy == NS_STYLE_TABLE_LAYOUT_AUTO)
     return true;
   // a fixed-layout inline-table must have a width
   // and tables with 'width: -moz-max-content' must be auto-layout
   // (at least as long as FixedTableLayoutStrategy::GetPrefWidth returns
   // nscoord_MAX)
-  const nsStyleCoord &width = GetStylePosition()->mWidth;
+  const nsStyleCoord &width = StylePosition()->mWidth;
   return (width.GetUnit() == eStyleUnit_Auto) ||
          (width.GetUnit() == eStyleUnit_Enumerated &&
           width.GetIntValue() == NS_STYLE_WIDTH_MAX_CONTENT);
 }
 
 #ifdef DEBUG
 NS_IMETHODIMP
 nsTableFrame::GetFrameName(nsAString& aResult) const
@@ -3622,17 +3622,17 @@ void nsTableIterator::Init(nsIFrame* aFi
   mCount          = -1;
 
   if (!mFirstChild) {
     return;
   }
 
   nsTableFrame* table = nsTableFrame::GetTableFrame(mFirstChild);
   mLeftToRight = (NS_STYLE_DIRECTION_LTR ==
-                  table->GetStyleVisibility()->mDirection);
+                  table->StyleVisibility()->mDirection);
 
   if (!mLeftToRight) {
     mCount = 0;
     nsIFrame* nextChild = mFirstChild->GetNextSibling();
     while (nullptr != nextChild) {
       mCount++;
       mFirstChild = nextChild;
       nextChild = nextChild->GetNextSibling();
@@ -3946,17 +3946,17 @@ struct BCMapCellInfo
 
 };
 
 
 BCMapCellInfo::BCMapCellInfo(nsTableFrame* aTableFrame)
 {
   mTableFrame = aTableFrame;
   mTableIsLTR =
-    aTableFrame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR;
+    aTableFrame->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR;
   if (mTableIsLTR) {
     mStartSide = NS_SIDE_LEFT;
     mEndSide = NS_SIDE_RIGHT;
   }
   else {
     mStartSide = NS_SIDE_RIGHT;
     mEndSide = NS_SIDE_LEFT;
   }
@@ -4413,17 +4413,17 @@ GetColorAndStyle(const nsIFrame*  aFrame
                  mozilla::css::Side aSide,
                  uint8_t&         aStyle,
                  nscolor&         aColor,
                  bool             aTableIsLTR)
 {
   NS_PRECONDITION(aFrame, "null frame");
   // initialize out arg
   aColor = 0;
-  const nsStyleBorder* styleData = aFrame->GetStyleBorder();
+  const nsStyleBorder* styleData = aFrame->StyleBorder();
   if(!aTableIsLTR) { // revert the directions
     if (NS_SIDE_RIGHT == aSide) {
       aSide = NS_SIDE_LEFT;
     }
     else if (NS_SIDE_LEFT == aSide) {
       aSide = NS_SIDE_RIGHT;
     }
   }
@@ -4479,17 +4479,17 @@ GetColorAndStyle(const nsIFrame*  aFrame
                  BCPixelSize&     aWidth)
 {
   GetColorAndStyle(aFrame, aSide, aStyle, aColor, aTableIsLTR);
   if ((NS_STYLE_BORDER_STYLE_NONE == aStyle) ||
       (NS_STYLE_BORDER_STYLE_HIDDEN == aStyle)) {
     aWidth = 0;
     return;
   }
-  const nsStyleBorder* styleData = aFrame->GetStyleBorder();
+  const nsStyleBorder* styleData = aFrame->StyleBorder();
   nscoord width;
   if(!aTableIsLTR) { // revert the directions
     if (NS_SIDE_RIGHT == aSide) {
       aSide = NS_SIDE_LEFT;
     }
     else if (NS_SIDE_LEFT == aSide) {
       aSide = NS_SIDE_RIGHT;
     }
@@ -4523,17 +4523,17 @@ nsTableFrame::BCRecalcNeeded(nsStyleCont
   // Attention: the old style context is the one we're forgetting,
   // and hence possibly completely bogus for GetStyle* purposes.
   // We use PeekStyleData instead.
 
   const nsStyleBorder* oldStyleData = aOldStyleContext->PeekStyleBorder();
   if (!oldStyleData)
     return false;
 
-  const nsStyleBorder* newStyleData = aNewStyleContext->GetStyleBorder();
+  const nsStyleBorder* newStyleData = aNewStyleContext->StyleBorder();
   nsChangeHint change = newStyleData->CalcDifference(*oldStyleData);
   if (!change)
     return false;
   if (change & nsChangeHint_NeedReflow)
     return true; // the caller only needs to mark the bc damage area
   if (change & nsChangeHint_RepaintFrame) {
     // we need to recompute the borders and the caller needs to mark
     // the bc damage area
@@ -6124,23 +6124,23 @@ BCPaintBorderIterator::BCPaintBorderIter
   mNumTableRows  = mTable->GetRowCount();
   mNumTableCols  = mTable->GetColCount();
 
   // Get the ordered row groups
   mTable->OrderRowGroups(mRowGroups);
   // initialize to a non existing index
   mRepeatedHeaderRowIndex = -99;
 
-  mTableIsLTR = mTable->GetStyleVisibility()->mDirection ==
+  mTableIsLTR = mTable->StyleVisibility()->mDirection ==
                    NS_STYLE_DIRECTION_LTR;
   mColInc = (mTableIsLTR) ? 1 : -1;
 
   nsIFrame* bgFrame =
     nsCSSRendering::FindNonTransparentBackgroundFrame(aTable);
-  mTableBgColor = bgFrame->GetStyleBackground();
+  mTableBgColor = bgFrame->StyleBackground();
 }
 
 bool
 BCPaintBorderIterator::SetDamageArea(const nsRect& aDirtyRect)
 {
 
   uint32_t startRowIndex, endRowIndex, startColIndex, endColIndex;
   startRowIndex = endRowIndex = startColIndex = endColIndex = 0;
@@ -6384,17 +6384,17 @@ BCPaintBorderIterator::SetNewRowGroup()
 
     if (SetNewRow(mRg->GetFirstRow())) {
       mCellMap = mTableCellMap->GetMapFor(fifRg, nullptr);
       if (!mCellMap) ABORT1(false);
     }
     if (mRg && mTable->GetPrevInFlow() && !mRg->GetPrevInFlow()) {
       // if mRowGroup doesn't have a prev in flow, then it may be a repeated
       // header or footer
-      const nsStyleDisplay* display = mRg->GetStyleDisplay();
+      const nsStyleDisplay* display = mRg->StyleDisplay();
       if (mRowIndex == mDamageArea.y) {
         mIsRepeatedHeader = (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == display->mDisplay);
       }
       else {
         mIsRepeatedFooter = (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == display->mDisplay);
       }
     }
   }
diff --git a/layout/tables/nsTableFrame.h b/layout/tables/nsTableFrame.h
--- a/layout/tables/nsTableFrame.h
+++ b/layout/tables/nsTableFrame.h
@@ -31,20 +31,20 @@ struct nsStylePosition;
 struct BCPropertyData;
 
 static inline bool IS_TABLE_CELL(nsIAtom* frameType) {
   return nsGkAtoms::tableCellFrame == frameType ||
     nsGkAtoms::bcTableCellFrame == frameType;
 }
 
 static inline bool FrameHasBorderOrBackground(nsIFrame* f) {
-  return (f->GetStyleVisibility()->IsVisible() &&
-          (!f->GetStyleBackground()->IsTransparent() ||
-           f->GetStyleDisplay()->mAppearance ||
-           f->GetStyleBorder()->HasBorder()));
+  return (f->StyleVisibility()->IsVisible() &&
+          (!f->StyleBackground()->IsTransparent() ||
+           f->StyleDisplay()->mAppearance ||
+           f->StyleBorder()->HasBorder()));
 }
 
 class nsDisplayTableItem : public nsDisplayItem
 {
 public:
   nsDisplayTableItem(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame) : 
       nsDisplayItem(aBuilder, aFrame),
       mPartHasFixedBackground(false) {}
diff --git a/layout/tables/nsTableOuterFrame.cpp b/layout/tables/nsTableOuterFrame.cpp
--- a/layout/tables/nsTableOuterFrame.cpp
+++ b/layout/tables/nsTableOuterFrame.cpp
@@ -66,17 +66,17 @@ nsTableCaptionFrame::ComputeAutoSize(nsR
 {
   nsSize result = nsBlockFrame::ComputeAutoSize(aRenderingContext, aCBSize,
                     aAvailableWidth, aMargin, aBorder, aPadding, aShrinkWrap);
 
   // If we're a container for font size inflation, then shrink
   // wrapping inside of us should not apply font size inflation.
   AutoMaybeDisableFontInflation an(this);
 
-  uint8_t captionSide = GetStyleTableBorder()->mCaptionSide;
+  uint8_t captionSide = StyleTableBorder()->mCaptionSide;
   if (captionSide == NS_STYLE_CAPTION_SIDE_LEFT ||
       captionSide == NS_STYLE_CAPTION_SIDE_RIGHT) {
     result.width = GetMinWidth(aRenderingContext);
   } else if (captionSide == NS_STYLE_CAPTION_SIDE_TOP ||
              captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM) {
     // The outer frame constrains our available width to the width of
     // the table.  Grow if our min-width is bigger than that, but not
     // larger than the containing block width.  (It would really be nice
@@ -564,28 +564,28 @@ nsTableOuterFrame::ComputeAutoSize(nsRen
 
   return nsSize(width, NS_UNCONSTRAINEDSIZE);
 }
 
 uint8_t
 nsTableOuterFrame::GetCaptionSide()
 {
   if (mCaptionFrames.NotEmpty()) {
-    return mCaptionFrames.FirstChild()->GetStyleTableBorder()->mCaptionSide;
+    return mCaptionFrames.FirstChild()->StyleTableBorder()->mCaptionSide;
   }
   else {
     return NO_SIDE; // no caption
   }
 }
 
 uint8_t
 nsTableOuterFrame::GetCaptionVerticalAlign()
 {
   const nsStyleCoord& va =
-    mCaptionFrames.FirstChild()->GetStyleTextReset()->mVerticalAlign;
+    mCaptionFrames.FirstChild()->StyleTextReset()->mVerticalAlign;
   return (va.GetUnit() == eStyleUnit_Enumerated)
            ? va.GetIntValue()
            : NS_STYLE_VERTICAL_ALIGN_TOP;
 }
 
 void
 nsTableOuterFrame::SetDesiredSize(uint8_t         aCaptionSide,
                                   const nsMargin& aInnerMargin,
diff --git a/layout/tables/nsTablePainter.cpp b/layout/tables/nsTablePainter.cpp
--- a/layout/tables/nsTablePainter.cpp
+++ b/layout/tables/nsTablePainter.cpp
@@ -144,17 +144,17 @@ TableBackgroundPainter::TableBackgroundD
 }
 
 void
 TableBackgroundPainter::TableBackgroundData::SetData()
 {
   NS_PRECONDITION(mFrame, "null frame");
   if (mFrame->IsVisibleForPainting()) {
     mVisible = true;
-    mBorder = mFrame->GetStyleBorder();
+    mBorder = mFrame->StyleBorder();
   }
 }
 
 void
 TableBackgroundPainter::TableBackgroundData::SetFull(nsIFrame* aFrame)
 {
   NS_PRECONDITION(aFrame, "null frame");
   SetFrame(aFrame);
@@ -164,17 +164,17 @@ TableBackgroundPainter::TableBackgroundD
 inline bool
 TableBackgroundPainter::TableBackgroundData::ShouldSetBCBorder()
 {
   /* we only need accurate border data when positioning background images*/
   if (!mVisible) {
     return false;
   }
 
-  const nsStyleBackground *bg = mFrame->GetStyleBackground();
+  const nsStyleBackground *bg = mFrame->StyleBackground();
   NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, bg) {
     if (!bg->mLayers[i].mImage.IsEmpty())
       return true;
   }
   return false;
 }
 
 nsresult
@@ -579,17 +579,17 @@ TableBackgroundPainter::PaintRow(nsTable
 
 nsresult
 TableBackgroundPainter::PaintCell(nsTableCellFrame* aCell,
                                   bool aPassSelf)
 {
   NS_PRECONDITION(aCell, "null frame");
 
   const nsStyleTableBorder* cellTableStyle;
-  cellTableStyle = aCell->GetStyleTableBorder();
+  cellTableStyle = aCell->StyleTableBorder();
   if (!(NS_STYLE_TABLE_EMPTY_CELLS_SHOW == cellTableStyle->mEmptyCells ||
         NS_STYLE_TABLE_EMPTY_CELLS_SHOW_BACKGROUND == cellTableStyle->mEmptyCells)
       && aCell->GetContentEmpty() && !mIsBorderCollapse) {
     return NS_OK;
   }
 
   int32_t colIndex;
   aCell->GetColIndex(colIndex);
diff --git a/layout/tables/nsTableRowFrame.cpp b/layout/tables/nsTableRowFrame.cpp
--- a/layout/tables/nsTableRowFrame.cpp
+++ b/layout/tables/nsTableRowFrame.cpp
@@ -135,17 +135,17 @@ nsTableRowFrame::Init(nsIContent*      a
                       nsIFrame*        aParent,
                       nsIFrame*        aPrevInFlow)
 {
   nsresult  rv;
 
   // Let the base class do its initialization
   rv = nsContainerFrame::Init(aContent, aParent, aPrevInFlow);
 
-  NS_ASSERTION(NS_STYLE_DISPLAY_TABLE_ROW == GetStyleDisplay()->mDisplay,
+  NS_ASSERTION(NS_STYLE_DISPLAY_TABLE_ROW == StyleDisplay()->mDisplay,
                "wrong display on table row frame");
 
   if (aPrevInFlow) {
     // Set the row index
     nsTableRowFrame* rowFrame = (nsTableRowFrame*)aPrevInFlow;
     
     SetRowIndex(rowFrame->GetRowIndex());
   }
@@ -483,17 +483,17 @@ nsTableRowFrame::UpdateHeight(nscoord   
 nscoord
 nsTableRowFrame::CalcHeight(const nsHTMLReflowState& aReflowState)
 {
   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
   nscoord computedHeight = (NS_UNCONSTRAINEDSIZE == aReflowState.ComputedHeight())
                             ? 0 : aReflowState.ComputedHeight();
   ResetHeight(computedHeight);
 
-  const nsStylePosition* position = GetStylePosition();
+  const nsStylePosition* position = StylePosition();
   if (position->mHeight.ConvertsToLength()) {
     SetFixedHeight(nsRuleNode::ComputeCoordPercentCalc(position->mHeight, 0));
   }
   else if (eStyleUnit_Percent == position->mHeight.GetUnit()) {
     SetPctHeight(position->mHeight.GetPercentValue());
   }
   // calc() with percentages is treated like 'auto' on table rows.
 
@@ -596,17 +596,17 @@ nsTableRowFrame::GetSkipSides() const
 // Modifies the desired height that is passed in.
 nsresult
 nsTableRowFrame::CalculateCellActualHeight(nsTableCellFrame* aCellFrame,
                                            nscoord&          aDesiredHeight)
 {
   nscoord specifiedHeight = 0;
   
   // Get the height specified in the style information
-  const nsStylePosition* position = aCellFrame->GetStylePosition();
+  const nsStylePosition* position = aCellFrame->StylePosition();
 
   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
   int32_t rowSpan = tableFrame->GetEffectiveRowSpan(*aCellFrame);
   
   switch (position->mHeight.GetUnit()) {
     case eStyleUnit_Calc: {
       if (position->mHeight.CalcHasPercent()) {
         // Treat this like "auto"
@@ -698,20 +698,20 @@ GetSpaceBetween(int32_t       aPrevColIn
   if (aIsLeftToRight) {
     for (colX = aPrevColIndex + 1; aColIndex > colX; colX++) {
       bool isCollapsed = false;
       if (!aCheckVisibility) {
         space += aTableFrame.GetColumnWidth(colX);
       }
       else {
         nsTableColFrame* colFrame = aTableFrame.GetColFrame(colX);
-        const nsStyleVisibility* colVis = colFrame->GetStyleVisibility();
+        const nsStyleVisibility* colVis = colFrame->StyleVisibility();
         bool collapseCol = (NS_STYLE_VISIBILITY_COLLAPSE == colVis->mVisible);
         nsIFrame* cgFrame = colFrame->GetParent();
-        const nsStyleVisibility* groupVis = cgFrame->GetStyleVisibility();
+        const nsStyleVisibility* groupVis = cgFrame->StyleVisibility();
         bool collapseGroup = (NS_STYLE_VISIBILITY_COLLAPSE ==
                                 groupVis->mVisible);
         isCollapsed = collapseCol || collapseGroup;
         if (!isCollapsed)
           space += aTableFrame.GetColumnWidth(colX);
       }
       if (!isCollapsed && aTableFrame.ColumnHasCellSpacingBefore(colX)) {
         space += aCellSpacingX;
@@ -722,20 +722,20 @@ GetSpaceBetween(int32_t       aPrevColIn
     int32_t lastCol = aColIndex + aColSpan - 1;
     for (colX = aPrevColIndex - 1; colX > lastCol; colX--) {
       bool isCollapsed = false;
       if (!aCheckVisibility) {
         space += aTableFrame.GetColumnWidth(colX);
       }
       else {
         nsTableColFrame* colFrame = aTableFrame.GetColFrame(colX);
-        const nsStyleVisibility* colVis = colFrame->GetStyleVisibility();
+        const nsStyleVisibility* colVis = colFrame->StyleVisibility();
         bool collapseCol = (NS_STYLE_VISIBILITY_COLLAPSE == colVis->mVisible);
         nsIFrame* cgFrame = colFrame->GetParent();
-        const nsStyleVisibility* groupVis = cgFrame->GetStyleVisibility();
+        const nsStyleVisibility* groupVis = cgFrame->StyleVisibility();
         bool collapseGroup = (NS_STYLE_VISIBILITY_COLLAPSE ==
                                 groupVis->mVisible);
         isCollapsed = collapseCol || collapseGroup;
         if (!isCollapsed)
           space += aTableFrame.GetColumnWidth(colX);
       }
       if (!isCollapsed && aTableFrame.ColumnHasCellSpacingBefore(colX)) {
         space += aCellSpacingX;
@@ -1010,17 +1010,17 @@ nsTableRowFrame::Reflow(nsPresContext*  
                         const nsHTMLReflowState& aReflowState,
                         nsReflowStatus&          aStatus)
 {
   DO_GLOBAL_REFLOW_COUNT("nsTableRowFrame");
   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
   nsresult rv = NS_OK;
 
   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
-  const nsStyleVisibility* rowVis = GetStyleVisibility();
+  const nsStyleVisibility* rowVis = StyleVisibility();
   bool collapseRow = (NS_STYLE_VISIBILITY_COLLAPSE == rowVis->mVisible);
   if (collapseRow) {
     tableFrame->SetNeedToCollapse(true);
   }
 
   // see if a special height reflow needs to occur due to having a pct height
   nsTableFrame::CheckRequestSpecialHeightReflow(aReflowState);
 
@@ -1102,17 +1102,17 @@ nsTableRowFrame::ReflowCellFrame(nsPresC
 }
 
 nscoord
 nsTableRowFrame::CollapseRowIfNecessary(nscoord aRowOffset,
                                         nscoord aWidth,
                                         bool    aCollapseGroup,
                                         bool& aDidCollapse)
 {
-  const nsStyleVisibility* rowVis = GetStyleVisibility();
+  const nsStyleVisibility* rowVis = StyleVisibility();
   bool collapseRow = (NS_STYLE_VISIBILITY_COLLAPSE == rowVis->mVisible);
   nsTableFrame* tableFrame = static_cast<nsTableFrame*>(
     nsTableFrame::GetTableFrame(this)->GetFirstInFlow());
   if (collapseRow) {
     tableFrame->SetNeedToCollapse(true);
   }
 
   if (aRowOffset != 0) {
@@ -1189,46 +1189,46 @@ nsTableRowFrame::CollapseRowIfNecessary(
         int32_t startIndex = (iter.IsLeftToRight()) ?
                              cellColIndex : cellColIndex + (cellColSpan - 1);
         int32_t actualColSpan = cellColSpan;
         bool isVisible = false;
         for (int32_t colX = startIndex; actualColSpan > 0;
              colX += colIncrement, actualColSpan--) {
 
           nsTableColFrame* colFrame = tableFrame->GetColFrame(colX);
-          const nsStyleVisibility* colVis = colFrame->GetStyleVisibility();
+          const nsStyleVisibility* colVis = colFrame->StyleVisibility();
           bool collapseCol = (NS_STYLE_VISIBILITY_COLLAPSE ==
                                 colVis->mVisible);
           nsIFrame* cgFrame = colFrame->GetParent();
-          const nsStyleVisibility* groupVis = cgFrame->GetStyleVisibility();
+          const nsStyleVisibility* groupVis = cgFrame->StyleVisibility();
           bool collapseGroup = (NS_STYLE_VISIBILITY_COLLAPSE ==
                                   groupVis->mVisible);
           bool isCollapsed = collapseCol || collapseGroup;
           if (!isCollapsed) {
             cRect.width += tableFrame->GetColumnWidth(colX);
             isVisible = true;
             if ((actualColSpan > 1)) {
               nsTableColFrame* nextColFrame =
                 tableFrame->GetColFrame(colX + colIncrement);
               const nsStyleVisibility* nextColVis =
-              nextColFrame->GetStyleVisibility();
+              nextColFrame->StyleVisibility();
               if ( (NS_STYLE_VISIBILITY_COLLAPSE != nextColVis->mVisible) &&
                   tableFrame->ColumnHasCellSpacingBefore(colX + colIncrement)) {
                 cRect.width += cellSpacingX;
               }
             }
           }
         }
         x += cRect.width;
         if (isVisible)
           x += cellSpacingX;
         int32_t actualRowSpan = tableFrame->GetEffectiveRowSpan(*cellFrame);
         nsTableRowFrame* rowFrame = GetNextRow();
         for (actualRowSpan--; actualRowSpan > 0 && rowFrame; actualRowSpan--) {
-          const nsStyleVisibility* nextRowVis = rowFrame->GetStyleVisibility();
+          const nsStyleVisibility* nextRowVis = rowFrame->StyleVisibility();
           bool collapseNextRow = (NS_STYLE_VISIBILITY_COLLAPSE ==
                                     nextRowVis->mVisible);
           if (!collapseNextRow) {
             nsRect nextRect = rowFrame->GetRect();
             cRect.height += nextRect.height + cellSpacingY;
           }
           rowFrame = rowFrame->GetNextRow();
         }
@@ -1305,17 +1305,17 @@ nsTableRowFrame::GetType() const
 
 nsTableRowFrame*  
 nsTableRowFrame::GetNextRow() const
 {
   nsIFrame* childFrame = GetNextSibling();
   while (childFrame) {
     nsTableRowFrame *rowFrame = do_QueryFrame(childFrame);
     if (rowFrame) {
-	  NS_ASSERTION(NS_STYLE_DISPLAY_TABLE_ROW == childFrame->GetStyleDisplay()->mDisplay, "wrong display type on rowframe");
+	  NS_ASSERTION(NS_STYLE_DISPLAY_TABLE_ROW == childFrame->StyleDisplay()->mDisplay, "wrong display type on rowframe");
       return rowFrame;
     }
     childFrame = childFrame->GetNextSibling();
   }
   return nullptr;
 }
 
 NS_DECLARE_FRAME_PROPERTY(RowUnpaginatedHeightProperty, nullptr)
@@ -1372,17 +1372,17 @@ void nsTableRowFrame::InitHasCellWithSty
 
   for (nsIFrame* kidFrame = iter.First(); kidFrame; kidFrame = iter.Next()) {
     nsTableCellFrame *cellFrame = do_QueryFrame(kidFrame);
     if (!cellFrame) {
       NS_NOTREACHED("Table row has a non-cell child.");
       continue;
     }
     // Ignore row-spanning cells
-    const nsStyleCoord &cellHeight = cellFrame->GetStylePosition()->mHeight;
+    const nsStyleCoord &cellHeight = cellFrame->StylePosition()->mHeight;
     if (aTableFrame->GetEffectiveRowSpan(*cellFrame) == 1 &&
         cellHeight.GetUnit() != eStyleUnit_Auto &&
          /* calc() with percentages treated like 'auto' */
         (!cellHeight.IsCalcUnit() || !cellHeight.HasPercent())) {
       AddStateBits(NS_ROW_HAS_CELL_WITH_STYLE_HEIGHT);
       return;
     }
   }
diff --git a/layout/tables/nsTableRowGroupFrame.cpp b/layout/tables/nsTableRowGroupFrame.cpp
--- a/layout/tables/nsTableRowGroupFrame.cpp
+++ b/layout/tables/nsTableRowGroupFrame.cpp
@@ -37,17 +37,17 @@ NS_QUERYFRAME_HEAD(nsTableRowGroupFrame)
   NS_QUERYFRAME_ENTRY(nsTableRowGroupFrame)
 NS_QUERYFRAME_TAIL_INHERITING(nsContainerFrame)
 
 int32_t
 nsTableRowGroupFrame::GetRowCount()
 {
 #ifdef DEBUG
   for (nsFrameList::Enumerator e(mFrames); !e.AtEnd(); e.Next()) {
-    NS_ASSERTION(e.get()->GetStyleDisplay()->mDisplay ==
+    NS_ASSERTION(e.get()->StyleDisplay()->mDisplay ==
                    NS_STYLE_DISPLAY_TABLE_ROW,
                  "Unexpected display");
     NS_ASSERTION(e.get()->GetType() == nsGkAtoms::tableRowFrame,
                  "Unexpected frame type");
   }
 #endif
   
   return mFrames.GetLength();
@@ -70,17 +70,17 @@ int32_t nsTableRowGroupFrame::GetStartRo
   return result;
 }
 
 void  nsTableRowGroupFrame::AdjustRowIndices(int32_t aRowIndex,
                                              int32_t anAdjustment)
 {
   nsIFrame* rowFrame = GetFirstPrincipalChild();
   for ( ; rowFrame; rowFrame = rowFrame->GetNextSibling()) {
-    if (NS_STYLE_DISPLAY_TABLE_ROW==rowFrame->GetStyleDisplay()->mDisplay) {
+    if (NS_STYLE_DISPLAY_TABLE_ROW==rowFrame->StyleDisplay()->mDisplay) {
       int32_t index = ((nsTableRowFrame*)rowFrame)->GetRowIndex();
       if (index >= aRowIndex)
         ((nsTableRowFrame *)rowFrame)->SetRowIndex(index+anAdjustment);
     }
   }
 }
 nsresult
 nsTableRowGroupFrame::InitRepeatedFrame(nsPresContext*        aPresContext,
@@ -384,17 +384,17 @@ nsTableRowGroupFrame::ReflowChildren(nsP
                  oldKidRect, oldKidVisualOverflow);
       aReflowState.y += cellSpacingY;
 
       if (!reflowAllKids) {
         if (IsSimpleRowFrame(aReflowState.tableFrame, kidFrame)) {
           // Inform the row of its new height.
           rowFrame->DidResize();
           // the overflow area may have changed inflate the overflow area
-          const nsStylePosition *stylePos = GetStylePosition();
+          const nsStylePosition *stylePos = StylePosition();
           nsStyleUnit unit = stylePos->mHeight.GetUnit();
           if (aReflowState.tableFrame->IsAutoHeight() &&
               unit != eStyleUnit_Coord) {
             // Because other cells in the row may need to be aligned
             // differently, repaint the entire row
             nsRect kidRect(0, aReflowState.y,
                            desiredSize.width, desiredSize.height);
             InvalidateFrame();
@@ -784,17 +784,17 @@ nsTableRowGroupFrame::CalculateRowHeight
   aDesiredSize.height = rowGroupHeight; // Adjust our desired size
 }
 
 nscoord
 nsTableRowGroupFrame::CollapseRowGroupIfNecessary(nscoord aYTotalOffset,
                                                   nscoord aWidth)
 {
   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
-  const nsStyleVisibility* groupVis = GetStyleVisibility();
+  const nsStyleVisibility* groupVis = StyleVisibility();
   bool collapseGroup = (NS_STYLE_VISIBILITY_COLLAPSE == groupVis->mVisible);
   if (collapseGroup) {
     tableFrame->SetNeedToCollapse(true);
   }
 
   nsOverflowAreas overflow;
 
   nsTableRowFrame* rowFrame= GetFirstRow();
@@ -1276,17 +1276,17 @@ nsTableRowGroupFrame::Reflow(nsPresConte
   // Row geometry may be going to change so we need to invalidate any row cursor.
   ClearRowCursor();
 
   // see if a special height reflow needs to occur due to having a pct height
   nsTableFrame::CheckRequestSpecialHeightReflow(aReflowState);
 
   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
   nsRowGroupReflowState state(aReflowState, tableFrame);
-  const nsStyleVisibility* groupVis = GetStyleVisibility();
+  const nsStyleVisibility* groupVis = StyleVisibility();
   bool collapseGroup = (NS_STYLE_VISIBILITY_COLLAPSE == groupVis->mVisible);
   if (collapseGroup) {
     tableFrame->SetNeedToCollapse(true);
   }
 
   // Check for an overflow list
   MoveOverflowToChildList(aPresContext);
 
@@ -1366,17 +1366,17 @@ nsTableRowGroupFrame::AppendFrames(Child
   // collect the new row frames in an array
   // XXXbz why are we doing the QI stuff?  There shouldn't be any non-rows here.
   nsAutoTArray<nsTableRowFrame*, 8> rows;
   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
     nsTableRowFrame *rowFrame = do_QueryFrame(e.get());
     NS_ASSERTION(rowFrame, "Unexpected frame; frame constructor screwed up");
     if (rowFrame) {
       NS_ASSERTION(NS_STYLE_DISPLAY_TABLE_ROW ==
-                     e.get()->GetStyleDisplay()->mDisplay,
+                     e.get()->StyleDisplay()->mDisplay,
                    "wrong display type on rowframe");      
       rows.AppendElement(rowFrame);
     }
   }
 
   int32_t rowIndex = GetRowCount();
   // Append the frames to the sibling chain
   mFrames.AppendFrames(nullptr, aFrameList);
@@ -1409,17 +1409,17 @@ nsTableRowGroupFrame::InsertFrames(Child
   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
   nsTArray<nsTableRowFrame*> rows;
   bool gotFirstRow = false;
   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
     nsTableRowFrame *rowFrame = do_QueryFrame(e.get());
     NS_ASSERTION(rowFrame, "Unexpected frame; frame constructor screwed up");
     if (rowFrame) {
       NS_ASSERTION(NS_STYLE_DISPLAY_TABLE_ROW ==
-                     e.get()->GetStyleDisplay()->mDisplay,
+                     e.get()->StyleDisplay()->mDisplay,
                    "wrong display type on rowframe");      
       rows.AppendElement(rowFrame);
       if (!gotFirstRow) {
         rowFrame->SetFirstInserted(true);
         gotFirstRow = true;
         tableFrame->SetRowInserted(true);
       }
     }
@@ -1539,27 +1539,27 @@ nsTableRowGroupFrame::GetType() const
 
 /** find page break before the first row **/
 bool 
 nsTableRowGroupFrame::HasInternalBreakBefore() const
 {
  nsIFrame* firstChild = mFrames.FirstChild(); 
   if (!firstChild)
     return false;
-  return firstChild->GetStyleDisplay()->mBreakBefore;
+  return firstChild->StyleDisplay()->mBreakBefore;
 }
 
 /** find page break after the last row **/
 bool 
 nsTableRowGroupFrame::HasInternalBreakAfter() const
 {
   nsIFrame* lastChild = mFrames.LastChild(); 
   if (!lastChild)
     return false;
-  return lastChild->GetStyleDisplay()->mBreakAfter;
+  return lastChild->StyleDisplay()->mBreakAfter;
 }
 /* ----- global methods ----- */
 
 nsIFrame*
 NS_NewTableRowGroupFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 {
   return new (aPresShell) nsTableRowGroupFrame(aContext);
 }
@@ -1620,17 +1620,17 @@ nsTableRowGroupFrame::GetNumLines()
   return GetRowCount();
 }
 
 bool
 nsTableRowGroupFrame::GetDirection()
 {
   nsTableFrame* table = nsTableFrame::GetTableFrame(this);
   return (NS_STYLE_DIRECTION_RTL ==
-          table->GetStyleVisibility()->mDirection);
+          table->StyleVisibility()->mDirection);
 }
   
 NS_IMETHODIMP
 nsTableRowGroupFrame::GetLine(int32_t    aLineNumber, 
                               nsIFrame** aFirstFrameOnLine, 
                               int32_t*   aNumFramesOnLine,
                               nsRect&    aLineBounds, 
                               uint32_t*  aLineFlags)
@@ -1723,17 +1723,17 @@ nsTableRowGroupFrame::FindFrameAt(int32_
      CellData* data = cellMap->GetDataAt(aLineNumber, i);
      if (data && data->IsOrig()) {
        frame = (nsIFrame*)data->GetCellFrame();
        break;
      }
    }
    NS_ASSERTION(frame, "cellmap is lying");
    bool isRTL = (NS_STYLE_DIRECTION_RTL ==
-                   table->GetStyleVisibility()->mDirection);
+                   table->StyleVisibility()->mDirection);
    
    nsIFrame* closestFromLeft = nullptr;
    nsIFrame* closestFromRight = nullptr;
    int32_t n = numCells;
    nsIFrame* firstFrame = frame;
    while (n--) {
      nsRect rect = frame->GetRect();
      if (rect.width > 0) {
diff --git a/layout/xul/base/public/nsXULPopupManager.h b/layout/xul/base/public/nsXULPopupManager.h
--- a/layout/xul/base/public/nsXULPopupManager.h
+++ b/layout/xul/base/public/nsXULPopupManager.h
@@ -112,17 +112,17 @@ PR_STATIC_ASSERT((NS_VK_HOME == NS_VK_EN
 /**
  * DirectionFromKeyCodeTable: two arrays, the first for left-to-right and the
  * other for right-to-left, that map keycodes to values of
  * nsNavigationDirection.
  */
 extern const nsNavigationDirection DirectionFromKeyCodeTable[2][6];
 
 #define NS_DIRECTION_FROM_KEY_CODE(frame, keycode)                     \
-  (DirectionFromKeyCodeTable[frame->GetStyleVisibility()->mDirection]  \
+  (DirectionFromKeyCodeTable[frame->StyleVisibility()->mDirection]  \
                             [keycode - NS_VK_END])
 
 // nsMenuChainItem holds info about an open popup. Items are stored in a
 // doubly linked list. Note that the linked list is stored beginning from
 // the lowest child in a chain of menus, as this is the active submenu.
 class nsMenuChainItem
 {
 private:
diff --git a/layout/xul/base/src/nsBox.cpp b/layout/xul/base/src/nsBox.cpp
--- a/layout/xul/base/src/nsBox.cpp
+++ b/layout/xul/base/src/nsBox.cpp
@@ -303,41 +303,41 @@ nsIFrame::GetBorderAndPadding(nsMargin& 
   return rv;
 }
 
 NS_IMETHODIMP
 nsBox::GetBorder(nsMargin& aMargin)
 {
   aMargin.SizeTo(0,0,0,0);
     
-  const nsStyleDisplay* disp = GetStyleDisplay();
+  const nsStyleDisplay* disp = StyleDisplay();
   if (disp->mAppearance && gTheme) {
     // Go to the theme for the border.
     nsPresContext *context = PresContext();
     if (gTheme->ThemeSupportsWidget(context, this, disp->mAppearance)) {
       nsIntMargin margin(0, 0, 0, 0);
       gTheme->GetWidgetBorder(context->DeviceContext(), this,
                               disp->mAppearance, &margin);
       aMargin.top = context->DevPixelsToAppUnits(margin.top);
       aMargin.right = context->DevPixelsToAppUnits(margin.right);
       aMargin.bottom = context->DevPixelsToAppUnits(margin.bottom);
       aMargin.left = context->DevPixelsToAppUnits(margin.left);
       return NS_OK;
     }
   }
 
-  aMargin = GetStyleBorder()->GetComputedBorder();
+  aMargin = StyleBorder()->GetComputedBorder();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsBox::GetPadding(nsMargin& aMargin)
 {
-  const nsStyleDisplay *disp = GetStyleDisplay();
+  const nsStyleDisplay *disp = StyleDisplay();
   if (disp->mAppearance && gTheme) {
     // Go to the theme for the padding.
     nsPresContext *context = PresContext();
     if (gTheme->ThemeSupportsWidget(context, this, disp->mAppearance)) {
       nsIntMargin margin(0, 0, 0, 0);
       bool useThemePadding;
 
       useThemePadding = gTheme->GetWidgetPadding(context->DeviceContext(),
@@ -349,26 +349,26 @@ nsBox::GetPadding(nsMargin& aMargin)
         aMargin.bottom = context->DevPixelsToAppUnits(margin.bottom);
         aMargin.left = context->DevPixelsToAppUnits(margin.left);
         return NS_OK;
       }
     }
   }
 
   aMargin.SizeTo(0,0,0,0);
-  GetStylePadding()->GetPadding(aMargin);
+  StylePadding()->GetPadding(aMargin);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsBox::GetMargin(nsMargin& aMargin)
 {
   aMargin.SizeTo(0,0,0,0);
-  GetStyleMargin()->GetMargin(aMargin);
+  StyleMargin()->GetMargin(aMargin);
 
   return NS_OK;
 }
 
 void
 nsBox::SizeNeedsRecalc(nsSize& aSize)
 {
   aSize.width  = -1;
@@ -461,17 +461,17 @@ nsBox::GetFlex(nsBoxLayoutState& aState)
   nsIFrame::AddCSSFlex(aState, this, flex);
 
   return flex;
 }
 
 uint32_t
 nsIFrame::GetOrdinal()
 {
-  uint32_t ordinal = GetStyleXUL()->mBoxOrdinal;
+  uint32_t ordinal = StyleXUL()->mBoxOrdinal;
 
   // When present, attribute value overrides CSS.
   nsIContent* content = GetContent();
   if (content && content->IsXUL()) {
     nsresult error;
     nsAutoString value;
 
     content->GetAttr(kNameSpaceID_None, nsGkAtoms::ordinal, value);
@@ -490,17 +490,17 @@ nsBox::GetBoxAscent(nsBoxLayoutState& aS
     return 0;
 
   return GetPrefSize(aState).height;
 }
 
 bool
 nsBox::IsCollapsed()
 {
-  return GetStyleVisibility()->mVisible == NS_STYLE_VISIBILITY_COLLAPSE;
+  return StyleVisibility()->mVisible == NS_STYLE_VISIBILITY_COLLAPSE;
 }
 
 nsresult
 nsIFrame::Layout(nsBoxLayoutState& aState)
 {
   NS_ASSERTION(aState.GetRenderingContext(), "must have rendering context");
 
   nsBox *box = static_cast<nsBox*>(this);
@@ -513,17 +513,17 @@ nsIFrame::Layout(nsBoxLayoutState& aStat
   box->EndLayout(aState);
 
   return NS_OK;
 }
 
 bool
 nsBox::DoesClipChildren()
 {
-  const nsStyleDisplay* display = GetStyleDisplay();
+  const nsStyleDisplay* display = StyleDisplay();
   NS_ASSERTION((display->mOverflowY == NS_STYLE_OVERFLOW_CLIP) ==
                (display->mOverflowX == NS_STYLE_OVERFLOW_CLIP),
                "If one overflow is clip, the other should be too");
   return display->mOverflowX == NS_STYLE_OVERFLOW_CLIP;
 }
 
 nsresult
 nsBox::SyncLayout(nsBoxLayoutState& aState)
@@ -598,17 +598,17 @@ nsIFrame::Redraw(nsBoxLayoutState& aStat
 
 bool
 nsIFrame::AddCSSPrefSize(nsIFrame* aBox, nsSize& aSize, bool &aWidthSet, bool &aHeightSet)
 {
     aWidthSet = false;
     aHeightSet = false;
 
     // add in the css min, max, pref
-    const nsStylePosition* position = aBox->GetStylePosition();
+    const nsStylePosition* position = aBox->StylePosition();
 
     // see if the width or height was specifically set
     // XXX Handle eStyleUnit_Enumerated?
     // (Handling the eStyleUnit_Enumerated types requires
     // GetPrefSize/GetMinSize methods that don't consider
     // (min-/max-/)(width/height) properties.)
     const nsStyleCoord &width = position->mWidth;
     if (width.GetUnit() == eStyleUnit_Coord) {
@@ -674,17 +674,17 @@ nsIFrame::AddCSSMinSize(nsBoxLayoutState
                       bool &aWidthSet, bool &aHeightSet)
 {
     aWidthSet = false;
     aHeightSet = false;
 
     bool canOverride = true;
 
     // See if a native theme wants to supply a minimum size.
-    const nsStyleDisplay* display = aBox->GetStyleDisplay();
+    const nsStyleDisplay* display = aBox->StyleDisplay();
     if (display->mAppearance) {
       nsITheme *theme = aState.PresContext()->GetTheme();
       if (theme && theme->ThemeSupportsWidget(aState.PresContext(), aBox, display->mAppearance)) {
         nsIntSize size;
         nsRenderingContext* rendContext = aState.GetRenderingContext();
         if (rendContext) {
           theme->GetMinimumWidgetSize(rendContext, aBox,
                                       display->mAppearance, &size, &canOverride);
@@ -696,17 +696,17 @@ nsIFrame::AddCSSMinSize(nsBoxLayoutState
             aSize.height = aState.PresContext()->DevPixelsToAppUnits(size.height);
             aHeightSet = true;
           }
         }
       }
     }
 
     // add in the css min, max, pref
-    const nsStylePosition* position = aBox->GetStylePosition();
+    const nsStylePosition* position = aBox->StylePosition();
 
     // same for min size. Unfortunately min size is always set to 0. So for now
     // we will assume 0 (as a coord) means not set.
     const nsStyleCoord &minWidth = position->mMinWidth;
     if ((minWidth.GetUnit() == eStyleUnit_Coord &&
          minWidth.GetCoordValue() != 0) ||
         (minWidth.IsCalcUnit() && !minWidth.CalcHasPercent())) {
         nscoord min = nsRuleNode::ComputeCoordPercentCalc(minWidth, 0);
@@ -781,17 +781,17 @@ nsIFrame::AddCSSMinSize(nsBoxLayoutState
 
 bool
 nsIFrame::AddCSSMaxSize(nsIFrame* aBox, nsSize& aSize, bool &aWidthSet, bool &aHeightSet)
 {
     aWidthSet = false;
     aHeightSet = false;
 
     // add in the css min, max, pref
-    const nsStylePosition* position = aBox->GetStylePosition();
+    const nsStylePosition* position = aBox->StylePosition();
 
     // and max
     // see if the width or height was specifically set
     // XXX Handle eStyleUnit_Enumerated?
     // (Handling the eStyleUnit_Enumerated types requires
     // GetPrefSize/GetMinSize methods that don't consider
     // (min-/max-/)(width/height) properties.)
     const nsStyleCoord maxWidth = position->mMaxWidth;
@@ -839,17 +839,17 @@ nsIFrame::AddCSSMaxSize(nsIFrame* aBox, 
 }
 
 bool
 nsIFrame::AddCSSFlex(nsBoxLayoutState& aState, nsIFrame* aBox, nscoord& aFlex)
 {
     bool flexSet = false;
 
     // get the flexibility
-    aFlex = aBox->GetStyleXUL()->mBoxFlex;
+    aFlex = aBox->StyleXUL()->mBoxFlex;
 
     // attribute value overrides CSS
     nsIContent* content = aBox->GetContent();
     if (content && content->IsXUL()) {
         nsresult error;
         nsAutoString value;
 
         content->GetAttr(kNameSpaceID_None, nsGkAtoms::flex, value);
diff --git a/layout/xul/base/src/nsBoxFrame.cpp b/layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp
+++ b/layout/xul/base/src/nsBoxFrame.cpp
@@ -320,17 +320,17 @@ nsBoxFrame::GetInitialHAlignment(nsBoxFr
   if (index > 0) {    
     aHalign = values[index];
     return true;
   }
 
   // Now that we've checked for the attribute it's time to check CSS.  For 
   // horizontal boxes we're checking PACK.  For vertical boxes we are checking
   // ALIGN.
-  const nsStyleXUL* boxInfo = GetStyleXUL();
+  const nsStyleXUL* boxInfo = StyleXUL();
   if (IsHorizontal()) {
     switch (boxInfo->mBoxPack) {
       case NS_STYLE_BOX_PACK_START:
         aHalign = nsBoxFrame::hAlign_Left;
         return true;
       case NS_STYLE_BOX_PACK_CENTER:
         aHalign = nsBoxFrame::hAlign_Center;
         return true;
@@ -395,17 +395,17 @@ nsBoxFrame::GetInitialVAlignment(nsBoxFr
   if (index > 0) {
     aValign = values[index];
     return true;
   }
 
   // Now that we've checked for the attribute it's time to check CSS.  For 
   // horizontal boxes we're checking ALIGN.  For vertical boxes we are checking
   // PACK.
-  const nsStyleXUL* boxInfo = GetStyleXUL();
+  const nsStyleXUL* boxInfo = StyleXUL();
   if (IsHorizontal()) {
     switch (boxInfo->mBoxAlign) {
       case NS_STYLE_BOX_ALIGN_START:
         aValign = nsBoxFrame::vAlign_Top;
         return true;
       case NS_STYLE_BOX_ALIGN_CENTER:
         aValign = nsBoxFrame::vAlign_Middle;
         return true;
@@ -441,17 +441,17 @@ nsBoxFrame::GetInitialVAlignment(nsBoxFr
 void
 nsBoxFrame::GetInitialOrientation(bool& aIsHorizontal)
 {
  // see if we are a vertical or horizontal box.
   if (!GetContent())
     return;
 
   // Check the style system first.
-  const nsStyleXUL* boxInfo = GetStyleXUL();
+  const nsStyleXUL* boxInfo = StyleXUL();
   if (boxInfo->mBoxOrient == NS_STYLE_BOX_ORIENT_HORIZONTAL)
     aIsHorizontal = true;
   else 
     aIsHorizontal = false;
 
   // Now see if we have an attribute.  The attribute overrides
   // the style system value.
   static nsIContent::AttrValuesArray strings[] =
@@ -467,23 +467,23 @@ void
 nsBoxFrame::GetInitialDirection(bool& aIsNormal)
 {
   if (!GetContent())
     return;
 
   if (IsHorizontal()) {
     // For horizontal boxes only, we initialize our value based off the CSS 'direction' property.
     // This means that BiDI users will end up with horizontally inverted chrome.
-    aIsNormal = (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR); // If text runs RTL then so do we.
+    aIsNormal = (StyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR); // If text runs RTL then so do we.
   }
   else
     aIsNormal = true; // Assume a normal direction in the vertical case.
 
   // Now check the style system to see if we should invert aIsNormal.
-  const nsStyleXUL* boxInfo = GetStyleXUL();
+  const nsStyleXUL* boxInfo = StyleXUL();
   if (boxInfo->mBoxDirection == NS_STYLE_BOX_DIRECTION_REVERSE)
     aIsNormal = !aIsNormal; // Invert our direction.
   
   // Now see if we have an attribute.  The attribute overrides
   // the style system value.
   if (IsHorizontal()) {
     static nsIContent::AttrValuesArray strings[] =
       {&nsGkAtoms::reverse, &nsGkAtoms::ltr, &nsGkAtoms::rtl, nullptr};
@@ -531,17 +531,17 @@ nsBoxFrame::GetInitialAutoStretch(bool& 
   int32_t index = GetContent()->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::align,
       strings, eCaseMatters);
   if (index != nsIContent::ATTR_MISSING && index != 0) {
     aStretch = index == 1;
     return true;
   }
 
   // Check the CSS box-align property.
-  const nsStyleXUL* boxInfo = GetStyleXUL();
+  const nsStyleXUL* boxInfo = StyleXUL();
   aStretch = (boxInfo->mBoxAlign == NS_STYLE_BOX_ALIGN_STRETCH);
 
   return true;
 }
 
 NS_IMETHODIMP
 nsBoxFrame::DidReflow(nsPresContext*           aPresContext,
                       const nsHTMLReflowState*  aReflowState,
@@ -1219,17 +1219,17 @@ nsBoxFrame::AttributeChanged(int32_t aNa
     nsBoxLayoutState state(PresContext());
     nsIFrame* parent = GetParentBox();
     // If our parent is not a box, there's not much we can do... but in that
     // case our ordinal doesn't matter anyway, so that's ok.
     // Also don't bother with popup frames since they are kept on the 
     // kPopupList and RelayoutChildAtOrdinal() only handles
     // principal children.
     if (parent && !(GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
-        GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_POPUP) {
+        StyleDisplay()->mDisplay != NS_STYLE_DISPLAY_POPUP) {
       parent->RelayoutChildAtOrdinal(state, this);
       // XXXldb Should this instead be a tree change on the child or parent?
       PresContext()->PresShell()->
         FrameNeedsReflow(parent, nsIPresShell::eStyleChange,
                          NS_FRAME_IS_DIRTY);
     }
   }
   // If the accesskey changed, register for the new value
@@ -1296,17 +1296,17 @@ nsBoxFrame::BuildDisplayList(nsDisplayLi
   // forcelayer is only supported on XUL elements with box layout
   bool forceLayer =
     GetContent()->HasAttr(kNameSpaceID_None, nsGkAtoms::layer) &&
     GetContent()->IsXUL();
 
   // Check for frames that are marked as a part of the region used
   // in calculating glass margins on Windows.
   if (GetContent()->IsXUL()) {
-      const nsStyleDisplay* styles = GetStyleDisplay();
+      const nsStyleDisplay* styles = StyleDisplay();
       if (styles && styles->mAppearance == NS_THEME_WIN_EXCLUDE_GLASS) {
         nsRect rect = nsRect(aBuilder->ToReferenceFrame(this), GetSize());
         aBuilder->AddExcludedGlassRegion(rect);
       }
   }
 
   nsDisplayListCollection tempLists;
   const nsDisplayListSet& destination = forceLayer ? tempLists : aLists;
diff --git a/layout/xul/base/src/nsBoxObject.cpp b/layout/xul/base/src/nsBoxObject.cpp
--- a/layout/xul/base/src/nsBoxObject.cpp
+++ b/layout/xul/base/src/nsBoxObject.cpp
@@ -179,22 +179,22 @@ nsBoxObject::GetOffsetRect(nsIntRect& aR
 
       // Add the parent's origin to our own to get to the
       // right coordinate system
       origin += next->GetPositionOfChildIgnoringScrolling(parent);
       parent = next;
     }
   
     // For the origin, add in the border for the frame
-    const nsStyleBorder* border = frame->GetStyleBorder();
+    const nsStyleBorder* border = frame->StyleBorder();
     origin.x += border->GetComputedBorderWidth(NS_SIDE_LEFT);
     origin.y += border->GetComputedBorderWidth(NS_SIDE_TOP);
 
     // And subtract out the border for the parent
-    const nsStyleBorder* parentBorder = parent->GetStyleBorder();
+    const nsStyleBorder* parentBorder = parent->StyleBorder();
     origin.x -= parentBorder->GetComputedBorderWidth(NS_SIDE_LEFT);
     origin.y -= parentBorder->GetComputedBorderWidth(NS_SIDE_TOP);
 
     aRect.x = nsPresContext::AppUnitsToIntCSSPixels(origin.x);
     aRect.y = nsPresContext::AppUnitsToIntCSSPixels(origin.y);
     
     // Get the union of all rectangles in this and continuation frames.
     // It doesn't really matter what we use as aRelativeTo here, since
diff --git a/layout/xul/base/src/nsDeckFrame.cpp b/layout/xul/base/src/nsDeckFrame.cpp
--- a/layout/xul/base/src/nsDeckFrame.cpp
+++ b/layout/xul/base/src/nsDeckFrame.cpp
@@ -145,17 +145,17 @@ nsDeckFrame::GetSelectedBox()
 }
 
 NS_IMETHODIMP
 nsDeckFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists)
 {
   // if a tab is hidden all its children are too.
-  if (!GetStyleVisibility()->mVisible)
+  if (!StyleVisibility()->mVisible)
     return NS_OK;
     
   // REVIEW: The old code skipped painting of background/borders/outline for this
   // frame and painting of debug boxes ... I've put it back.
   return nsBoxFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
 }
 
 NS_IMETHODIMP
diff --git a/layout/xul/base/src/nsGroupBoxFrame.cpp b/layout/xul/base/src/nsGroupBoxFrame.cpp
--- a/layout/xul/base/src/nsGroupBoxFrame.cpp
+++ b/layout/xul/base/src/nsGroupBoxFrame.cpp
@@ -122,29 +122,29 @@ nsGroupBoxFrame::BuildDisplayList(nsDisp
   return BuildDisplayListForChildren(aBuilder, aDirtyRect, aLists);
   // REVIEW: Debug borders now painted by nsFrame::BuildDisplayListForChild
 }
 
 void
 nsGroupBoxFrame::PaintBorderBackground(nsRenderingContext& aRenderingContext,
     nsPoint aPt, const nsRect& aDirtyRect) {
   int skipSides = 0;
-  const nsStyleBorder* borderStyleData = GetStyleBorder();
+  const nsStyleBorder* borderStyleData = StyleBorder();
   const nsMargin& border = borderStyleData->GetComputedBorder();
   nscoord yoff = 0;
   nsPresContext* presContext = PresContext();
 
   nsRect groupRect;
   nsIFrame* groupBox = GetCaptionBox(presContext, groupRect);
 
   if (groupBox) {        
     // if the border is smaller than the legend. Move the border down
     // to be centered on the legend. 
     nsMargin groupMargin;
-    groupBox->GetStyleMargin()->GetMargin(groupMargin);
+    groupBox->StyleMargin()->GetMargin(groupMargin);
     groupRect.Inflate(groupMargin);
  
     if (border.top < groupRect.height)
         yoff = (groupRect.height - border.top)/2 + groupRect.y;
   }
 
   nsRect rect(aPt.x, aPt.y + yoff, mRect.width, mRect.height - yoff);
 
diff --git a/layout/xul/base/src/nsImageBoxFrame.cpp b/layout/xul/base/src/nsImageBoxFrame.cpp
--- a/layout/xul/base/src/nsImageBoxFrame.cpp
+++ b/layout/xul/base/src/nsImageBoxFrame.cpp
@@ -241,21 +241,21 @@ nsImageBoxFrame::UpdateImage()
         nsLayoutUtils::RegisterImageRequestIfAnimated(presContext,
                                                       mImageRequest,
                                                       &mRequestRegistered);
       }
     }
   } else {
     // Only get the list-style-image if we aren't being drawn
     // by a native theme.
-    uint8_t appearance = GetStyleDisplay()->mAppearance;
+    uint8_t appearance = StyleDisplay()->mAppearance;
     if (!(appearance && nsBox::gTheme &&
           nsBox::gTheme->ThemeSupportsWidget(nullptr, this, appearance))) {
       // get the list-style-image
-      imgRequestProxy *styleRequest = GetStyleList()->GetListStyleImage();
+      imgRequestProxy *styleRequest = StyleList()->GetListStyleImage();
       if (styleRequest) {
         styleRequest->Clone(mListener, getter_AddRefs(mImageRequest));
       }
     }
   }
 
   if (!mImageRequest) {
     // We have no image, so size to 0
@@ -420,24 +420,24 @@ nsImageBoxFrame::GetContainer(LayerManag
 // When the style context changes, make sure that all of our image is up to date.
 //
 /* virtual */ void
 nsImageBoxFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
   nsLeafBoxFrame::DidSetStyleContext(aOldStyleContext);
 
   // Fetch our subrect.
-  const nsStyleList* myList = GetStyleList();
+  const nsStyleList* myList = StyleList();
   mSubRect = myList->mImageRegion; // before |mSuppressStyleCheck| test!
 
   if (mUseSrcAttr || mSuppressStyleCheck)
     return; // No more work required, since the image isn't specified by style.
 
   // If we're using a native theme implementation, we shouldn't draw anything.
-  const nsStyleDisplay* disp = GetStyleDisplay();
+  const nsStyleDisplay* disp = StyleDisplay();
   if (disp->mAppearance && nsBox::gTheme &&
       nsBox::gTheme->ThemeSupportsWidget(nullptr, this, disp->mAppearance))
     return;
 
   // If list-style-image changes, we have a new image.
   nsCOMPtr<nsIURI> oldURI, newURI;
   if (mImageRequest)
     mImageRequest->GetURI(getter_AddRefs(oldURI));
diff --git a/layout/xul/base/src/nsListBoxBodyFrame.cpp b/layout/xul/base/src/nsListBoxBodyFrame.cpp
--- a/layout/xul/base/src/nsListBoxBodyFrame.cpp
+++ b/layout/xul/base/src/nsListBoxBodyFrame.cpp
@@ -663,20 +663,20 @@ nsListBoxBodyFrame::ComputeIntrinsicWidt
     nsRefPtr<nsStyleContext> styleContext;
     nsPresContext *presContext = aBoxLayoutState.PresContext();
     styleContext = presContext->StyleSet()->
       ResolveStyleFor(firstRowContent->AsElement(), nullptr);
 
     nscoord width = 0;
     nsMargin margin(0,0,0,0);
 
-    if (styleContext->GetStylePadding()->GetPadding(margin))
+    if (styleContext->StylePadding()->GetPadding(margin))
       width += margin.LeftRight();
-    width += styleContext->GetStyleBorder()->GetComputedBorder().LeftRight();
-    if (styleContext->GetStyleMargin()->GetMargin(margin))
+    width += styleContext->StyleBorder()->GetComputedBorder().LeftRight();
+    if (styleContext->StyleMargin()->GetMargin(margin))
       width += margin.LeftRight();
 
 
     ChildIterator iter, last;
     uint32_t i = 0;
     for (ChildIterator::Init(mContent, &iter, &last);
          iter != last && i < 100;
          ++iter, ++i) {
diff --git a/layout/xul/base/src/nsMenuPopupFrame.cpp b/layout/xul/base/src/nsMenuPopupFrame.cpp
--- a/layout/xul/base/src/nsMenuPopupFrame.cpp
+++ b/layout/xul/base/src/nsMenuPopupFrame.cpp
@@ -311,21 +311,21 @@ nsMenuPopupFrame::CreateWidgetForView(ns
   }
 
   return NS_OK;
 }
 
 uint8_t
 nsMenuPopupFrame::GetShadowStyle()
 {
-  uint8_t shadow = GetStyleUIReset()->mWindowShadow;
+  uint8_t shadow = StyleUIReset()->mWindowShadow;
   if (shadow != NS_STYLE_WINDOW_SHADOW_DEFAULT)
     return shadow;
 
-  switch (GetStyleDisplay()->mAppearance) {
+  switch (StyleDisplay()->mAppearance) {
     case NS_THEME_TOOLTIP:
       return NS_STYLE_WINDOW_SHADOW_TOOLTIP;
     case NS_THEME_MENUPOPUP:
       return NS_STYLE_WINDOW_SHADOW_MENU;
   }
   return NS_STYLE_WINDOW_SHADOW_DEFAULT;
 }
 
@@ -913,17 +913,17 @@ nsMenuPopupFrame::AdjustPositionForAncho
       break;
   }
 
   // If the alignment is on the right edge of the popup, move the popup left
   // by the width. Similarly, if the alignment is on the bottom edge of the
   // popup, move the popup up by the height. In addition, account for the
   // margins of the popup on the edge on which it is aligned.
   nsMargin margin(0, 0, 0, 0);
-  GetStyleMargin()->GetMargin(margin);
+  StyleMargin()->GetMargin(margin);
   switch (popupAlign) {
     case POPUPALIGNMENT_TOPRIGHT:
       pnt.MoveBy(-mRect.width - margin.right, margin.top);
       break;
     case POPUPALIGNMENT_BOTTOMLEFT:
       pnt.MoveBy(margin.left, -mRect.height - margin.bottom);
       break;
     case POPUPALIGNMENT_BOTTOMRIGHT:
@@ -1138,17 +1138,17 @@ nsMenuPopupFrame::SetPopupPosition(nsIFr
   // For anchored popups, the anchor rectangle. For non-anchored popups, the
   // size will be 0.
   nsRect anchorRect = parentRect;
 
   // indicators of whether the popup should be flipped or resized.
   FlipStyle hFlip = FlipStyle_None, vFlip = FlipStyle_None;
 
   nsMargin margin(0, 0, 0, 0);
-  GetStyleMargin()->GetMargin(margin);
+  StyleMargin()->GetMargin(margin);
 
   // the screen rectangle of the root frame, in dev pixels.
   nsRect rootScreenRect = rootFrame->GetScreenRectInAppUnits();
 
   nsDeviceContext* devContext = presContext->DeviceContext();
   nscoord offsetForContextMenu = 0;
 
   if (IsAnchored()) {
@@ -1843,17 +1843,17 @@ nsMenuPopupFrame::MoveTo(int32_t aLeft, 
     return;
   }
 
   // reposition the popup at the specified coordinates. Don't clear the anchor
   // and position, because the popup can be reset to its anchor position by
   // using (-1, -1) as coordinates. Subtract off the margin as it will be
   // added to the position when SetPopupPosition is called.
   nsMargin margin(0, 0, 0, 0);
-  GetStyleMargin()->GetMargin(margin);
+  StyleMargin()->GetMargin(margin);
 
   // Workaround for bug 788189.  See also bug 708278 comment #25 and following.
   if (mAdjustOffsetForContextMenu) {
     nscoord offsetForContextMenu =
       nsPresContext::CSSPixelsToAppUnits(CONTEXT_MENU_OFFSET_PIXELS);
     margin.left += offsetForContextMenu;
     margin.top += offsetForContextMenu;
   }
diff --git a/layout/xul/base/src/nsMenuPopupFrame.h b/layout/xul/base/src/nsMenuPopupFrame.h
--- a/layout/xul/base/src/nsMenuPopupFrame.h
+++ b/layout/xul/base/src/nsMenuPopupFrame.h
@@ -361,18 +361,18 @@ protected:
    * Return whether the popup direction should be RTL.
    * If the popup has an anchor, its direction is the anchor direction.
    * Otherwise, its the general direction of the UI.
    *
    * Return whether the popup direction should be RTL.
    */
   bool IsDirectionRTL() const {
     return mAnchorContent && mAnchorContent->GetPrimaryFrame()
-      ? mAnchorContent->GetPrimaryFrame()->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL
-      : GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
+      ? mAnchorContent->GetPrimaryFrame()->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL
+      : StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
   }
 
   // Create a popup view for this frame. The view is added a child of the root
   // view, and is initially hidden.
   nsresult CreatePopupView();
 
   nsString     mIncrementalString;  // for incremental typing navigation
 
diff --git a/layout/xul/base/src/nsResizerFrame.cpp b/layout/xul/base/src/nsResizerFrame.cpp
--- a/layout/xul/base/src/nsResizerFrame.cpp
+++ b/layout/xul/base/src/nsResizerFrame.cpp
@@ -77,17 +77,17 @@ nsResizerFrame::HandleEvent(nsPresContex
           nsIFrame* frameToResize = contentToResize->GetPrimaryFrame();
           if (!frameToResize)
             break;
 
           // cache the content rectangle for the frame to resize
           // GetScreenRectInAppUnits returns the border box rectangle, so
           // adjust to get the desired content rectangle.
           nsRect rect = frameToResize->GetScreenRectInAppUnits();
-          switch (frameToResize->GetStylePosition()->mBoxSizing) {
+          switch (frameToResize->StylePosition()->mBoxSizing) {
             case NS_STYLE_BOX_SIZING_CONTENT:
               rect.Deflate(frameToResize->GetUsedPadding());
             case NS_STYLE_BOX_SIZING_PADDING:
               rect.Deflate(frameToResize->GetUsedBorder());
             default:
               break;
           }
 
@@ -524,17 +524,17 @@ nsResizerFrame::GetDirection()
   if (!GetContent())
     return directions[0]; // default: topleft
 
   int32_t index = GetContent()->FindAttrValueIn(kNameSpaceID_None,
                                                 nsGkAtoms::dir,
                                                 strings, eCaseMatters);
   if(index < 0)
     return directions[0]; // default: topleft
-  else if (index >= 8 && GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
+  else if (index >= 8 && StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
     // Directions 8 and higher are RTL-aware directions and should reverse the
     // horizontal component if RTL.
     Direction direction = directions[index];
     direction.mHorizontal *= -1;
     return direction;
   }
   return directions[index];
 }
diff --git a/layout/xul/base/src/nsSplitterFrame.cpp b/layout/xul/base/src/nsSplitterFrame.cpp
--- a/layout/xul/base/src/nsSplitterFrame.cpp
+++ b/layout/xul/base/src/nsSplitterFrame.cpp
@@ -481,17 +481,17 @@ nsSplitterFrameInner::MouseDrag(nsPresCo
     nscoord oldPos = pos;
 
     ResizeChildTo(aPresContext, pos, mChildInfosBefore, mChildInfosAfter, mChildInfosBeforeCount, mChildInfosAfterCount, bounded);
 
     State currentState = GetState();
     bool supportsBefore = SupportsCollapseDirection(Before);
     bool supportsAfter = SupportsCollapseDirection(After);
 
-    const bool isRTL = mOuter->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
+    const bool isRTL = mOuter->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
     bool pastEnd = oldPos > 0 && oldPos > pos;
     bool pastBegin = oldPos < 0 && oldPos < pos;
     if (isRTL) {
       // Swap the boundary checks in RTL mode
       bool tmp = pastEnd;
       pastEnd = pastBegin;
       pastBegin = tmp;
     }
diff --git a/layout/xul/base/src/nsSprocketLayout.cpp b/layout/xul/base/src/nsSprocketLayout.cpp
--- a/layout/xul/base/src/nsSprocketLayout.cpp
+++ b/layout/xul/base/src/nsSprocketLayout.cpp
@@ -63,17 +63,17 @@ void
 nsSprocketLayout::GetFrameState(nsIFrame* aBox, nsFrameState& aState)
 {
    aState = aBox->GetStateBits();
 }
 
 static uint8_t
 GetFrameDirection(nsIFrame* aBox)
 {
-   return aBox->GetStyleVisibility()->mDirection;
+   return aBox->StyleVisibility()->mDirection;
 }
 
 static void
 HandleBoxPack(nsIFrame* aBox, const nsFrameState& aFrameState, nscoord& aX, nscoord& aY, 
               const nsRect& aOriginalRect, const nsRect& aClientRect)
 {
   // In the normal direction we lay out our kids in the positive direction (e.g., |x| will get
   // bigger for a horizontal box, and |y| will get bigger for a vertical box).  In the reverse
diff --git a/layout/xul/base/src/nsStackLayout.cpp b/layout/xul/base/src/nsStackLayout.cpp
--- a/layout/xul/base/src/nsStackLayout.cpp
+++ b/layout/xul/base/src/nsStackLayout.cpp
@@ -60,17 +60,17 @@ nsStackLayout::nsStackLayout()
 
 nsSize
 nsStackLayout::GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   nsSize prefSize (0, 0);
 
   nsIFrame* child = aBox->GetChildBox();
   while (child) {
-    if (child->GetStyleXUL()->mStretchStack) {
+    if (child->StyleXUL()->mStretchStack) {
       nsSize pref = child->GetPrefSize(aState);
 
       AddMargin(child, pref);
       nsMargin offset;
       GetOffset(aState, child, offset);
       pref.width += offset.LeftRight();
       pref.height += offset.TopBottom();
       AddLargestSize(prefSize, pref);
@@ -86,17 +86,17 @@ nsStackLayout::GetPrefSize(nsIFrame* aBo
 
 nsSize
 nsStackLayout::GetMinSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   nsSize minSize (0, 0);
 
   nsIFrame* child = aBox->GetChildBox();
   while (child) {
-    if (child->GetStyleXUL()->mStretchStack) {
+    if (child->StyleXUL()->mStretchStack) {
       nsSize min = child->GetMinSize(aState);
 
       AddMargin(child, min);
       nsMargin offset;
       GetOffset(aState, child, offset);
       min.width += offset.LeftRight();
       min.height += offset.TopBottom();
       AddLargestSize(minSize, min);
@@ -112,17 +112,17 @@ nsStackLayout::GetMinSize(nsIFrame* aBox
 
 nsSize
 nsStackLayout::GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   nsSize maxSize (NS_INTRINSICSIZE, NS_INTRINSICSIZE);
 
   nsIFrame* child = aBox->GetChildBox();
   while (child) {
-    if (child->GetStyleXUL()->mStretchStack) {
+    if (child->StyleXUL()->mStretchStack) {
       nsSize min = child->GetMinSize(aState);
       nsSize max = child->GetMaxSize(aState);
 
       max = nsBox::BoundsCheckMinMax(min, max);
 
       AddMargin(child, max);
       nsMargin offset;
       GetOffset(aState, child, offset);
@@ -171,17 +171,17 @@ nsStackLayout::GetOffset(nsBoxLayoutStat
   // wasting time fetching attributes.
   if (aChild->IsBoxFrame() &&
       (aChild->GetStateBits() & NS_STATE_STACK_NOT_POSITIONED))
     return 0;
 
   uint8_t offsetSpecified = 0;
   nsIContent* content = aChild->GetContent();
   if (content) {
-    bool ltr = aChild->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR;
+    bool ltr = aChild->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR;
     nsAutoString value;
     nsresult error;
 
     content->GetAttr(kNameSpaceID_None, nsGkAtoms::start, value);
     if (!value.IsEmpty()) {
       value.Trim("%");
       if (ltr) {
         aOffset.left =
@@ -338,17 +338,17 @@ nsStackLayout::Layout(nsIFrame* aBox, ns
 
           // Flow the child.
           child->Layout(aState);
 
           // Get the child's new rect.
           childRect = child->GetRect();
           childRect.Inflate(margin);
 
-          if (child->GetStyleXUL()->mStretchStack) {
+          if (child->StyleXUL()->mStretchStack) {
             // Did the child push back on us and get bigger?
             if (offset.LeftRight() + childRect.width > clientRect.width) {
               clientRect.width = childRect.width + offset.LeftRight();
               grow = true;
             }
 
             if (offset.TopBottom() + childRect.height > clientRect.height) {
               clientRect.height = childRect.height + offset.TopBottom();
diff --git a/layout/xul/base/src/nsTextBoxFrame.cpp b/layout/xul/base/src/nsTextBoxFrame.cpp
--- a/layout/xul/base/src/nsTextBoxFrame.cpp
+++ b/layout/xul/base/src/nsTextBoxFrame.cpp
@@ -319,17 +319,17 @@ nsDisplayXULTextBox::Paint(nsDisplayList
   gfxContextAutoDisableSubpixelAntialiasing disable(aCtx->ThebesContext(),
                                                     mDisableSubpixelAA);
 
   // Paint the text shadow before doing any foreground stuff
   nsRect drawRect = static_cast<nsTextBoxFrame*>(mFrame)->mTextDrawRect +
                     ToReferenceFrame();
   nsLayoutUtils::PaintTextShadow(mFrame, aCtx,
                                  drawRect, mVisibleRect,
-                                 mFrame->GetStyleColor()->mColor,
+                                 mFrame->StyleColor()->mColor,
                                  PaintTextShadowCallback,
                                  (void*)this);
 
   PaintTextToContext(aCtx, nsPoint(0, 0), nullptr);
 }
 
 void
 nsDisplayXULTextBox::PaintTextToContext(nsRenderingContext* aCtx,
@@ -402,17 +402,17 @@ nsTextBoxFrame::DrawText(nsRenderingCont
     uint8_t decorMask = NS_STYLE_TEXT_DECORATION_LINE_LINES_MASK;
 
     nsIFrame* f = this;
     do {  // find decoration colors
       nsStyleContext* context = f->StyleContext();
       if (!context->HasTextDecorationLines()) {
         break;
       }
-      const nsStyleTextReset* styleText = context->GetStyleTextReset();
+      const nsStyleTextReset* styleText = context->StyleTextReset();
       
       if (decorMask & styleText->mTextDecorationLine) {  // a decoration defined here
         nscolor color;
         if (aOverrideColor) {
           color = *aOverrideColor;
         } else {
           bool isForeground;
           styleText->GetDecorationColor(color, isForeground);
@@ -493,24 +493,24 @@ nsTextBoxFrame::DrawText(nsRenderingCont
     nsRefPtr<nsRenderingContext> refContext =
         PresContext()->PresShell()->GetReferenceRenderingContext();
 
     aRenderingContext.SetFont(fontMet);
     refContext->SetFont(fontMet);
 
     CalculateUnderline(*refContext);
 
-    aRenderingContext.SetColor(aOverrideColor ? *aOverrideColor : GetStyleColor()->mColor);
+    aRenderingContext.SetColor(aOverrideColor ? *aOverrideColor : StyleColor()->mColor);
 
 #ifdef IBMBIDI
     nsresult rv = NS_ERROR_FAILURE;
 
     if (mState & NS_FRAME_IS_BIDI) {
       presContext->SetBidiEnabled();
-      const nsStyleVisibility* vis = GetStyleVisibility();
+      const nsStyleVisibility* vis = StyleVisibility();
       nsBidiDirection direction = (NS_STYLE_DIRECTION_RTL == vis->mDirection) ? NSBIDI_RTL : NSBIDI_LTR;
       if (mAccessKeyInfo && mAccessKeyInfo->mAccesskeyIndex != kNotFound) {
           // We let the RenderText function calculate the mnemonic's
           // underline position for us.
           nsBidiPositionResolve posResolve;
           posResolve.logicalIndex = mAccessKeyInfo->mAccesskeyIndex;
           rv = nsBidiPresUtils::RenderText(mCroppedTitle.get(), mCroppedTitle.Length(), direction,
                                            presContext, aRenderingContext,
@@ -887,17 +887,17 @@ nsTextBoxFrame::DoLayout(nsBoxLayoutStat
         }
         mNeedsReflowCallback = false;
     }
 
     nsresult rv = nsLeafBoxFrame::DoLayout(aBoxLayoutState);
 
     CalcDrawRect(*aBoxLayoutState.GetRenderingContext());
 
-    const nsStyleText* textStyle = GetStyleText();
+    const nsStyleText* textStyle = StyleText();
     
     nsRect scrollBounds(nsPoint(0, 0), GetSize());
     nsRect textRect = mTextDrawRect;
     
     nsRefPtr<nsFontMetrics> fontMet;
     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fontMet));
     nsBoundingMetrics metrics = 
       fontMet->GetInkBoundsForVisualOverflow(mCroppedTitle.get(),
@@ -924,17 +924,17 @@ nsTextBoxFrame::DoLayout(nsBoxLayoutStat
     FinishAndStoreOverflow(overflow, GetSize());
 
     return rv;
 }
 
 nsRect
 nsTextBoxFrame::GetComponentAlphaBounds()
 {
-  if (GetStyleText()->mTextShadow) {
+  if (StyleText()->mTextShadow) {
     return GetVisualOverflowRectRelativeToSelf();
   }
   return mTextDrawRect;
 }
 
 bool
 nsTextBoxFrame::ComputesOwnOverflowArea()
 {
@@ -997,18 +997,18 @@ nsTextBoxFrame::CalcDrawRect(nsRendering
     // determine if and at which position to put the underline
     UpdateAccessIndex();
 
     // make the rect as small as our (cropped) text.
     nscoord outerWidth = textRect.width;
     textRect.width = titleWidth;
 
     // Align our text within the overall rect by checking our text-align property.
-    const nsStyleVisibility* vis = GetStyleVisibility();
-    const nsStyleText* textStyle = GetStyleText();
+    const nsStyleVisibility* vis = StyleVisibility();
+    const nsStyleText* textStyle = StyleText();
 
     if (textStyle->mTextAlign == NS_STYLE_TEXT_ALIGN_CENTER)
       textRect.x += (outerWidth - textRect.width)/2;
     else if (textStyle->mTextAlign == NS_STYLE_TEXT_ALIGN_RIGHT ||
              (textStyle->mTextAlign == NS_STYLE_TEXT_ALIGN_DEFAULT &&
               vis->mDirection == NS_STYLE_DIRECTION_RTL) ||
              (textStyle->mTextAlign == NS_STYLE_TEXT_ALIGN_END &&
               vis->mDirection == NS_STYLE_DIRECTION_LTR)) {
diff --git a/layout/xul/tree/nsTreeBodyFrame.cpp b/layout/xul/tree/nsTreeBodyFrame.cpp
--- a/layout/xul/tree/nsTreeBodyFrame.cpp
+++ b/layout/xul/tree/nsTreeBodyFrame.cpp
@@ -140,20 +140,20 @@ nsTreeBodyFrame::~nsTreeBodyFrame()
   DetachImageListeners();
   delete mSlots;
 }
 
 static void
 GetBorderPadding(nsStyleContext* aContext, nsMargin& aMargin)
 {
   aMargin.SizeTo(0, 0, 0, 0);
-  if (!aContext->GetStylePadding()->GetPadding(aMargin)) {
+  if (!aContext->StylePadding()->GetPadding(aMargin)) {
     NS_NOTYETIMPLEMENTED("percentage padding");
   }
-  aMargin += aContext->GetStyleBorder()->GetComputedBorder();
+  aMargin += aContext->StyleBorder()->GetComputedBorder();
 }
 
 static void
 AdjustForBorderPadding(nsStyleContext* aContext, nsRect& aRect)
 {
   nsMargin borderPadding(0, 0, 0, 0);
   GetBorderPadding(aContext, borderPadding);
   aRect.Deflate(borderPadding);
@@ -1091,17 +1091,17 @@ nsresult
 nsTreeBodyFrame::GetCoordsForCellItem(int32_t aRow, nsITreeColumn* aCol, const nsACString& aElement, 
                                       int32_t *aX, int32_t *aY, int32_t *aWidth, int32_t *aHeight)
 {
   *aX = 0;
   *aY = 0;
   *aWidth = 0;
   *aHeight = 0;
 
-  bool isRTL = GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
+  bool isRTL = StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
   nscoord currX = mInnerBox.x - mHorzPosition;
 
   // The Rect for the requested item. 
   nsRect theRect;
 
   nsPresContext* presContext = PresContext();
 
   for (nsTreeColumn* currCol = mColumns->GetFirstColumn(); currCol; currCol = currCol->GetNext()) {
@@ -1138,17 +1138,17 @@ nsTreeBodyFrame::GetCoordsForCellItem(in
 
     NS_NAMED_LITERAL_CSTRING(cell, "cell");
     if (currCol->IsCycler() || cell.Equals(aElement)) {
       // If the current Column is a Cycler, then the Rect is just the cell - the margins. 
       // Similarly, if we're just being asked for the cell rect, provide it. 
 
       theRect = cellRect;
       nsMargin cellMargin;
-      cellContext->GetStyleMargin()->GetMargin(cellMargin);
+      cellContext->StyleMargin()->GetMargin(cellMargin);
       theRect.Deflate(cellMargin);
       break;
     }
 
     // Since we're not looking for the cell, and since the cell isn't a cycler,
     // we're looking for some subcomponent, and now we need to subtract the 
     // borders and padding of the cell from cellRect so this does not 
     // interfere with our computations.
@@ -1187,17 +1187,17 @@ nsTreeBodyFrame::GetCoordsForCellItem(in
         // If we're looking for the twisty Rect, just return the size
         theRect = twistyRect;
         break;
       }
       
       // Now we need to add in the margins of the twisty element, so that we 
       // can find the offset of the next element in the cell. 
       nsMargin twistyMargin;
-      twistyContext->GetStyleMargin()->GetMargin(twistyMargin);
+      twistyContext->StyleMargin()->GetMargin(twistyMargin);
       twistyRect.Inflate(twistyMargin);
 
       // Adjust our working X value with the twisty width (image size, margins,
       // borders, padding.
       if (!isRTL)
         cellX += twistyRect.width;
     }
 
@@ -1209,17 +1209,17 @@ nsTreeBodyFrame::GetCoordsForCellItem(in
       theRect = imageSize;
       theRect.x = cellX;
       theRect.y = cellRect.y;
       break;
     }
 
     // Add in the margins of the cell image.
     nsMargin imageMargin;
-    imageContext->GetStyleMargin()->GetMargin(imageMargin);
+    imageContext->StyleMargin()->GetMargin(imageMargin);
     imageSize.Inflate(imageMargin);
 
     // Increment cellX by the image width
     if (!isRTL)
       cellX += imageSize.width;
     
     // Cell Text 
     nsAutoString cellText;
@@ -1241,17 +1241,17 @@ nsTreeBodyFrame::GetCoordsForCellItem(in
     nsStyleContext* textContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecelltext);
 
     nsRefPtr<nsFontMetrics> fm;
     nsLayoutUtils::GetFontMetricsForStyleContext(textContext,
                                                  getter_AddRefs(fm));
     nscoord height = fm->MaxHeight();
 
     nsMargin textMargin;
-    textContext->GetStyleMargin()->GetMargin(textMargin);
+    textContext->StyleMargin()->GetMargin(textMargin);
     textRect.Deflate(textMargin);
 
     // Center the text. XXX Obey vertical-align style prop?
     if (height < textRect.height) {
       textRect.y += (textRect.height - height) / 2;
       textRect.height = height;
     }
 
@@ -1472,32 +1472,32 @@ nsTreeBodyFrame::GetItemWithinCellAt(nsc
 
   // Resolve style for the cell.
   nsStyleContext* cellContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecell);
 
   // Obtain the margins for the cell and then deflate our rect by that 
   // amount.  The cell is assumed to be contained within the deflated rect.
   nsRect cellRect(aCellRect);
   nsMargin cellMargin;
-  cellContext->GetStyleMargin()->GetMargin(cellMargin);
+  cellContext->StyleMargin()->GetMargin(cellMargin);
   cellRect.Deflate(cellMargin);
 
   // Adjust the rect for its border and padding.
   AdjustForBorderPadding(cellContext, cellRect);
 
   if (aX < cellRect.x || aX >= cellRect.x + cellRect.width) {
     // The user clicked within the cell's margins/borders/padding.  This constitutes a click on the cell.
     return nsCSSAnonBoxes::moztreecell;
   }
 
   nscoord currX = cellRect.x;
   nscoord remainingWidth = cellRect.width;
 
   // Handle right alignment hit testing.
-  bool isRTL = GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
+  bool isRTL = StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
 
   nsPresContext* presContext = PresContext();
   nsRefPtr<nsRenderingContext> rc =
     presContext->PresShell()->GetReferenceRenderingContext();
   if (!rc)
     return nsCSSAnonBoxes::moztreecell;
 
   if (aColumn->IsPrimary()) {
@@ -1533,17 +1533,17 @@ nsTreeBodyFrame::GetItemWithinCellAt(nsc
     nsRect imageSize;
     GetTwistyRect(aRowIndex, aColumn, imageSize, twistyRect, presContext,
                   *rc, twistyContext);
 
     // We will treat a click as hitting the twisty if it happens on the margins, borders, padding,
     // or content of the twisty object.  By allowing a "slop" into the margin, we make it a little
     // bit easier for a user to hit the twisty.  (We don't want to be too picky here.)
     nsMargin twistyMargin;
-    twistyContext->GetStyleMargin()->GetMargin(twistyMargin);
+    twistyContext->StyleMargin()->GetMargin(twistyMargin);
     twistyRect.Inflate(twistyMargin);
     if (isRTL)
       twistyRect.x = currX + remainingWidth - twistyRect.width;
 
     // Now we test to see if aX is actually within the twistyRect.  If it is, and if the item should
     // have a twisty, then we return "twisty".  If it is within the rect but we shouldn't have a twisty,
     // then we return "cell".
     if (aX >= twistyRect.x && aX < twistyRect.x + twistyRect.width) {
@@ -1561,17 +1561,17 @@ nsTreeBodyFrame::GetItemWithinCellAt(nsc
   // Now test to see if the user hit the icon for the cell.
   nsRect iconRect(currX, cellRect.y, remainingWidth, cellRect.height);
   
   // Resolve style for the image.
   nsStyleContext* imageContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreeimage);
 
   nsRect iconSize = GetImageSize(aRowIndex, aColumn, false, imageContext);
   nsMargin imageMargin;
-  imageContext->GetStyleMargin()->GetMargin(imageMargin);
+  imageContext->StyleMargin()->GetMargin(imageMargin);
   iconSize.Inflate(imageMargin);
   iconRect.width = iconSize.width;
   if (isRTL)
     iconRect.x = currX + remainingWidth - iconRect.width;
 
   if (aX >= iconRect.x && aX < iconRect.x + iconRect.width) {
     // The user clicked on the image.
     return nsCSSAnonBoxes::moztreeimage;
@@ -1587,17 +1587,17 @@ nsTreeBodyFrame::GetItemWithinCellAt(nsc
   // necessary
   CheckTextForBidi(cellText);
 
   nsRect textRect(currX, cellRect.y, remainingWidth, cellRect.height);
 
   nsStyleContext* textContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecelltext);
 
   nsMargin textMargin;
-  textContext->GetStyleMargin()->GetMargin(textMargin);
+  textContext->StyleMargin()->GetMargin(textMargin);
   textRect.Deflate(textMargin);
 
   AdjustForBorderPadding(textContext, textRect);
 
   nsRefPtr<nsFontMetrics> fm;
   nsLayoutUtils::GetFontMetricsForStyleContext(textContext,
                                                getter_AddRefs(fm));
   rc->SetFont(fm);
@@ -1693,29 +1693,29 @@ nsTreeBodyFrame::GetCellWidth(int32_t aR
 
     nsRect imageSize;
     nsRect twistyRect(cellRect);
     GetTwistyRect(aRow, aCol, imageSize, twistyRect, PresContext(),
                   *aRenderingContext, twistyContext);
 
     // Add in the margins of the twisty element.
     nsMargin twistyMargin;
-    twistyContext->GetStyleMargin()->GetMargin(twistyMargin);
+    twistyContext->StyleMargin()->GetMargin(twistyMargin);
     twistyRect.Inflate(twistyMargin);
 
     aDesiredSize += twistyRect.width;
   }
 
   nsStyleContext* imageContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreeimage);
 
   // Account for the width of the cell image.
   nsRect imageSize = GetImageSize(aRow, aCol, false, imageContext);
   // Add in the margins of the cell image.
   nsMargin imageMargin;
-  imageContext->GetStyleMargin()->GetMargin(imageMargin);
+  imageContext->StyleMargin()->GetMargin(imageMargin);
   imageSize.Inflate(imageMargin);
 
   aDesiredSize += imageSize.width;
   
   // Get the cell text.
   nsAutoString cellText;
   mView->GetCellText(aRow, aCol, cellText);
   // We're going to measure this text so we need to ensure bidi is enabled if
@@ -2057,17 +2057,17 @@ nsTreeBodyFrame::GetTwistyRect(int32_t a
     aImageRect.height = aTwistyRect.height;
   if (aImageRect.width > aTwistyRect.width)
     aImageRect.width = aTwistyRect.width;
   else
     aTwistyRect.width = aImageRect.width;
 
   bool useTheme = false;
   nsITheme *theme = nullptr;
-  const nsStyleDisplay* twistyDisplayData = aTwistyContext->GetStyleDisplay();
+  const nsStyleDisplay* twistyDisplayData = aTwistyContext->StyleDisplay();
   if (twistyDisplayData->mAppearance) {
     theme = aPresContext->GetTheme();
     if (theme && theme->ThemeSupportsWidget(aPresContext, nullptr, twistyDisplayData->mAppearance))
       useTheme = true;
   }
 
   if (useTheme) {
     nsIntSize minTwistySizePx(0,0);
@@ -2097,17 +2097,17 @@ nsTreeBodyFrame::GetImage(int32_t aRowIn
   mView->GetImageSrc(aRowIndex, aCol, imageSrc);
   nsRefPtr<imgRequestProxy> styleRequest;
   if (!aUseContext && !imageSrc.IsEmpty()) {
     aAllowImageRegions = false;
   }
   else {
     // Obtain the URL from the style context.
     aAllowImageRegions = true;
-    styleRequest = aStyleContext->GetStyleList()->GetListStyleImage();
+    styleRequest = aStyleContext->StyleList()->GetListStyleImage();
     if (!styleRequest)
       return NS_OK;
     nsCOMPtr<nsIURI> uri;
     styleRequest->GetURI(getter_AddRefs(uri));
     nsAutoCString spec;
     uri->GetSpec(spec);
     CopyUTF8toUTF16(spec, imageSrc);
   }
@@ -2224,18 +2224,18 @@ nsRect nsTreeBodyFrame::GetImageSize(int
   bool needHeight = false;
 
   // We have to load image even though we already have a size.
   // Don't change this, otherwise things start to go crazy.
   bool useImageRegion = true;
   nsCOMPtr<imgIContainer> image;
   GetImage(aRowIndex, aCol, aUseContext, aStyleContext, useImageRegion, getter_AddRefs(image));
 
-  const nsStylePosition* myPosition = aStyleContext->GetStylePosition();
-  const nsStyleList* myList = aStyleContext->GetStyleList();
+  const nsStylePosition* myPosition = aStyleContext->StylePosition();
+  const nsStyleList* myList = aStyleContext->StyleList();
 
   if (useImageRegion) {
     r.x += myList->mImageRegion.x;
     r.y += myList->mImageRegion.y;
   }
 
   if (myPosition->mWidth.GetUnit() == eStyleUnit_Coord)  {
     int32_t val = myPosition->mWidth.GetCoordValue();
@@ -2296,17 +2296,17 @@ nsTreeBodyFrame::GetImageDestSize(nsStyl
   nsSize size(0,0);
 
   // We need to get the width and height.
   bool needWidth = false;
   bool needHeight = false;
 
   // Get the style position to see if the CSS has specified the
   // destination width/height.
-  const nsStylePosition* myPosition = aStyleContext->GetStylePosition();
+  const nsStylePosition* myPosition = aStyleContext->StylePosition();
 
   if (myPosition->mWidth.GetUnit() == eStyleUnit_Coord) {
     // CSS has specified the destination width.
     size.width = myPosition->mWidth.GetCoordValue();
   }
   else {
     // We'll need to get the width of the image/region.
     needWidth = true;
@@ -2320,17 +2320,17 @@ nsTreeBodyFrame::GetImageDestSize(nsStyl
     // We'll need to get the height of the image/region.
     needHeight = true;
   }
 
   if (needWidth || needHeight) {
     // We need to get the size of the image/region.
     nsSize imageSize(0,0);
 
-    const nsStyleList* myList = aStyleContext->GetStyleList();
+    const nsStyleList* myList = aStyleContext->StyleList();
 
     if (useImageRegion && myList->mImageRegion.width > 0) {
       // CSS has specified an image region.
       // Use the width of the image region.
       imageSize.width = myList->mImageRegion.width;
     }
     else if (image) {
       nscoord width;
@@ -2386,17 +2386,17 @@ nsTreeBodyFrame::GetImageDestSize(nsStyl
 // in CSS.
 nsRect
 nsTreeBodyFrame::GetImageSourceRect(nsStyleContext* aStyleContext,
                                     bool useImageRegion,
                                     imgIContainer* image)
 {
   nsRect r(0,0,0,0);
 
-  const nsStyleList* myList = aStyleContext->GetStyleList();
+  const nsStyleList* myList = aStyleContext->StyleList();
 
   if (useImageRegion &&
       (myList->mImageRegion.width > 0 || myList->mImageRegion.height > 0)) {
     // CSS has specified an image region.
     r = myList->mImageRegion;
   }
   else if (image) {
     // Use the actual image size.
@@ -2412,17 +2412,17 @@ nsTreeBodyFrame::GetImageSourceRect(nsSt
 
 int32_t nsTreeBodyFrame::GetRowHeight()
 {
   // Look up the correct height.  It is equal to the specified height
   // + the specified margins.
   mScratchArray->Clear();
   nsStyleContext* rowContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreerow);
   if (rowContext) {
-    const nsStylePosition* myPosition = rowContext->GetStylePosition();
+    const nsStylePosition* myPosition = rowContext->StylePosition();
 
     nscoord minHeight = 0;
     if (myPosition->mMinHeight.GetUnit() == eStyleUnit_Coord)
       minHeight = myPosition->mMinHeight.GetCoordValue();
 
     nscoord height = 0;
     if (myPosition->mHeight.GetUnit() == eStyleUnit_Coord)
       height = myPosition->mHeight.GetCoordValue();
@@ -2434,33 +2434,33 @@ int32_t nsTreeBodyFrame::GetRowHeight()
       height = nsPresContext::AppUnitsToIntCSSPixels(height);
       height += height % 2;
       height = nsPresContext::CSSPixelsToAppUnits(height);
 
       // XXX Check box-sizing to determine if border/padding should augment the height
       // Inflate the height by our margins.
       nsRect rowRect(0,0,0,height);
       nsMargin rowMargin;
-      rowContext->GetStyleMargin()->GetMargin(rowMargin);
+      rowContext->StyleMargin()->GetMargin(rowMargin);
       rowRect.Inflate(rowMargin);
       height = rowRect.height;
       return height;
     }
   }
 
   return nsPresContext::CSSPixelsToAppUnits(18); // As good a default as any.
 }
 
 int32_t nsTreeBodyFrame::GetIndentation()
 {
   // Look up the correct indentation.  It is equal to the specified indentation width.
   mScratchArray->Clear();
   nsStyleContext* indentContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreeindentation);
   if (indentContext) {
-    const nsStylePosition* myPosition = indentContext->GetStylePosition();
+    const nsStylePosition* myPosition = indentContext->StylePosition();
     if (myPosition->mWidth.GetUnit() == eStyleUnit_Coord)  {
       nscoord val = myPosition->mWidth.GetCoordValue();
       return val;
     }
   }
 
   return nsPresContext::CSSPixelsToAppUnits(16); // As good a default as any.
 }
@@ -2511,17 +2511,17 @@ nsTreeBodyFrame::GetCursor(const nsPoint
     nsTreeColumn* col;
     nsIAtom* child;
     GetCellAt(aPoint.x, aPoint.y, &row, &col, &child);
 
     if (child) {
       // Our scratch array is already prefilled.
       nsStyleContext* childContext = GetPseudoStyleContext(child);
 
-      FillCursorInformationFromStyle(childContext->GetStyleUserInterface(),
+      FillCursorInformationFromStyle(childContext->StyleUserInterface(),
                                      aCursor);
       if (aCursor.mCursor == NS_STYLE_CURSOR_AUTO)
         aCursor.mCursor = NS_STYLE_CURSOR_DEFAULT;
 
       return NS_OK;
     }
   }
 
@@ -2882,17 +2882,17 @@ nsTreeBodyFrame::PaintColumn(nsTreeColum
   // Resolve style for the column.  It contains all the info we need to lay ourselves
   // out and to paint.
   nsStyleContext* colContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecolumn);
 
   // Obtain the margins for the cell and then deflate our rect by that 
   // amount.  The cell is assumed to be contained within the deflated rect.
   nsRect colRect(aColumnRect);
   nsMargin colMargin;
-  colContext->GetStyleMargin()->GetMargin(colMargin);
+  colContext->StyleMargin()->GetMargin(colMargin);
   colRect.Deflate(colMargin);
 
   PaintBackgroundLayer(colContext, aPresContext, aRenderingContext, colRect, aDirtyRect);
 }
 
 void
 nsTreeBodyFrame::PaintRow(int32_t              aRowIndex,
                           const nsRect&        aRowRect,
@@ -2918,25 +2918,25 @@ nsTreeBodyFrame::PaintRow(int32_t       
   // Resolve style for the row.  It contains all the info we need to lay ourselves
   // out and to paint.
   nsStyleContext* rowContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreerow);
 
   // Obtain the margins for the row and then deflate our rect by that 
   // amount.  The row is assumed to be contained within the deflated rect.
   nsRect rowRect(aRowRect);
   nsMargin rowMargin;
-  rowContext->GetStyleMargin()->GetMargin(rowMargin);
+  rowContext->StyleMargin()->GetMargin(rowMargin);
   rowRect.Deflate(rowMargin);
 
   // Paint our borders and background for our row rect.
   // If a -moz-appearance is provided, use theme drawing only if the current row
   // is not selected (since we draw the selection as part of drawing the background).
   bool useTheme = false;
   nsITheme *theme = nullptr;
-  const nsStyleDisplay* displayData = rowContext->GetStyleDisplay();
+  const nsStyleDisplay* displayData = rowContext->StyleDisplay();
   if (displayData->mAppearance) {
     theme = aPresContext->GetTheme();
     if (theme && theme->ThemeSupportsWidget(aPresContext, nullptr, displayData->mAppearance))
       useTheme = true;
   }
   bool isSelected = false;
   nsCOMPtr<nsITreeSelection> selection;
   mView->GetSelection(getter_AddRefs(selection));
@@ -3053,47 +3053,47 @@ nsTreeBodyFrame::PaintSeparator(int32_t 
                                 nsPresContext*      aPresContext,
                                 nsRenderingContext& aRenderingContext,
                                 const nsRect&        aDirtyRect)
 {
   // Resolve style for the separator.
   nsStyleContext* separatorContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreeseparator);
   bool useTheme = false;
   nsITheme *theme = nullptr;
-  const nsStyleDisplay* displayData = separatorContext->GetStyleDisplay();
+  const nsStyleDisplay* displayData = separatorContext->StyleDisplay();
   if ( displayData->mAppearance ) {
     theme = aPresContext->GetTheme();
     if (theme && theme->ThemeSupportsWidget(aPresContext, nullptr, displayData->mAppearance))
       useTheme = true;
   }
 
   // use -moz-appearance if provided.
   if (useTheme) {
     nsRect dirty;
     dirty.IntersectRect(aSeparatorRect, aDirtyRect);
     theme->DrawWidgetBackground(&aRenderingContext, this,
                                 displayData->mAppearance, aSeparatorRect, dirty); 
   }
   else {
-    const nsStylePosition* stylePosition = separatorContext->GetStylePosition();
+    const nsStylePosition* stylePosition = separatorContext->StylePosition();
 
     // Obtain the height for the separator or use the default value.
     nscoord height;
     if (stylePosition->mHeight.GetUnit() == eStyleUnit_Coord)
       height = stylePosition->mHeight.GetCoordValue();
     else {
       // Use default height 2px.
       height = nsPresContext::CSSPixelsToAppUnits(2);
     }
 
     // Obtain the margins for the separator and then deflate our rect by that 
     // amount. The separator is assumed to be contained within the deflated rect.
     nsRect separatorRect(aSeparatorRect.x, aSeparatorRect.y, aSeparatorRect.width, height);
     nsMargin separatorMargin;
-    separatorContext->GetStyleMargin()->GetMargin(separatorMargin);
+    separatorContext->StyleMargin()->GetMargin(separatorMargin);
     separatorRect.Deflate(separatorMargin);
 
     // Center the separator.
     separatorRect.y += (aSeparatorRect.height - height) / 2;
 
     PaintBackgroundLayer(separatorContext, aPresContext, aRenderingContext, separatorRect, aDirtyRect);
   }
 }
@@ -3114,23 +3114,23 @@ nsTreeBodyFrame::PaintCell(int32_t      
   // XXX Automatically fill in the following props: open, closed, container, leaf, selected, focused, and the col ID.
   PrefillPropertyArray(aRowIndex, aColumn);
   mView->GetCellProperties(aRowIndex, aColumn, mScratchArray);
 
   // Resolve style for the cell.  It contains all the info we need to lay ourselves
   // out and to paint.
   nsStyleContext* cellContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecell);
 
-  bool isRTL = GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
+  bool isRTL = StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
 
   // Obtain the margins for the cell and then deflate our rect by that 
   // amount.  The cell is assumed to be contained within the deflated rect.
   nsRect cellRect(aCellRect);
   nsMargin cellMargin;
-  cellContext->GetStyleMargin()->GetMargin(cellMargin);
+  cellContext->StyleMargin()->GetMargin(cellMargin);
   cellRect.Deflate(cellMargin);
 
   // Paint our borders and background for our row rect.
   PaintBackgroundLayer(cellContext, aPresContext, aRenderingContext, cellRect, aDirtyRect);
 
   // Adjust the rect for its border and padding.
   AdjustForBorderPadding(cellContext, cellRect);
 
@@ -3152,42 +3152,42 @@ nsTreeBodyFrame::PaintCell(int32_t      
     if (!isRTL)
       currX += mIndentation * level;
     remainingWidth -= mIndentation * level;
 
     // Resolve the style to use for the connecting lines.
     nsStyleContext* lineContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreeline);
     
     if (mIndentation && level &&
-        lineContext->GetStyleVisibility()->IsVisibleOrCollapsed()) {
+        lineContext->StyleVisibility()->IsVisibleOrCollapsed()) {
       // Paint the thread lines.
 
       // Get the size of the twisty. We don't want to paint the twisty
       // before painting of connecting lines since it would paint lines over
       // the twisty. But we need to leave a place for it.
       nsStyleContext* twistyContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreetwisty);
 
       nsRect imageSize;
       nsRect twistyRect(aCellRect);
       GetTwistyRect(aRowIndex, aColumn, imageSize, twistyRect, aPresContext,
                     aRenderingContext, twistyContext);
 
       nsMargin twistyMargin;
-      twistyContext->GetStyleMargin()->GetMargin(twistyMargin);
+      twistyContext->StyleMargin()->GetMargin(twistyMargin);
       twistyRect.Inflate(twistyMargin);
 
       aRenderingContext.PushState();
 
-      const nsStyleBorder* borderStyle = lineContext->GetStyleBorder();
+      const nsStyleBorder* borderStyle = lineContext->StyleBorder();
       nscolor color;
       bool foreground;
       borderStyle->GetBorderColor(NS_SIDE_LEFT, color, foreground);
       if (foreground) {
         // GetBorderColor didn't touch color, thus grab it from the treeline context
-        color = lineContext->GetStyleColor()->mColor;
+        color = lineContext->StyleColor()->mColor;
       }
       aRenderingContext.SetColor(color);
       uint8_t style;
       style = borderStyle->GetBorderStyle(NS_SIDE_LEFT);
       aRenderingContext.SetLineStyle(ConvertBorderStyleToLineStyle(style));
 
       nscoord srcX = currX + twistyRect.width - mIndentation / 2;
       nscoord lineY = (aRowIndex - mTopRowIndex) * mRowHeight + aPt.y;
@@ -3241,17 +3241,17 @@ nsTreeBodyFrame::PaintCell(int32_t      
 
   // Now paint our element, but only if we aren't a cycler column.
   // XXX until we have the ability to load images, allow the view to 
   // insert text into cycler columns...
   if (!aColumn->IsCycler()) {
     nsRect elementRect(currX, cellRect.y, remainingWidth, cellRect.height);
     nsRect dirtyRect;
     if (dirtyRect.IntersectRect(aDirtyRect, elementRect)) {
-      bool textRTL = cellContext->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
+      bool textRTL = cellContext->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
       switch (aColumn->GetType()) {
         case nsITreeColumn::TYPE_TEXT:
           PaintText(aRowIndex, aColumn, elementRect, aPresContext, aRenderingContext, aDirtyRect, currX,
                     textRTL);
           break;
         case nsITreeColumn::TYPE_CHECKBOX:
           PaintCheckbox(aRowIndex, aColumn, elementRect, aPresContext, aRenderingContext, aDirtyRect);
           break;
@@ -3284,17 +3284,17 @@ nsTreeBodyFrame::PaintTwisty(int32_t    
                              nsPresContext*      aPresContext,
                              nsRenderingContext& aRenderingContext,
                              const nsRect&        aDirtyRect,
                              nscoord&             aRemainingWidth,
                              nscoord&             aCurrX)
 {
   NS_PRECONDITION(aColumn && aColumn->GetFrame(), "invalid column passed");
 
-  bool isRTL = GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
+  bool isRTL = StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
   nscoord rightEdge = aCurrX + aRemainingWidth;
   // Paint the twisty, but only if we are a non-empty container.
   bool shouldPaint = false;
   bool isContainer = false;
   mView->IsContainer(aRowIndex, &isContainer);
   if (isContainer) {
     bool isContainerEmpty = false;
     mView->IsContainerEmpty(aRowIndex, &isContainerEmpty);
@@ -3304,17 +3304,17 @@ nsTreeBodyFrame::PaintTwisty(int32_t    
 
   // Resolve style for the twisty.
   nsStyleContext* twistyContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreetwisty);
 
   // Obtain the margins for the twisty and then deflate our rect by that 
   // amount.  The twisty is assumed to be contained within the deflated rect.
   nsRect twistyRect(aTwistyRect);
   nsMargin twistyMargin;
-  twistyContext->GetStyleMargin()->GetMargin(twistyMargin);
+  twistyContext->StyleMargin()->GetMargin(twistyMargin);
   twistyRect.Deflate(twistyMargin);
 
   nsRect imageSize;
   nsITheme* theme = GetTwistyRect(aRowIndex, aColumn, imageSize, twistyRect,
                                   aPresContext, aRenderingContext, twistyContext);
 
   // Subtract out the remaining width.  This is done even when we don't actually paint a twisty in 
   // this cell, so that cells in different rows still line up.
@@ -3332,17 +3332,17 @@ nsTreeBodyFrame::PaintTwisty(int32_t    
       if (isRTL)
         twistyRect.x = rightEdge - twistyRect.width;
       // yeah, I know it says we're drawing a background, but a twisty is really a fg
       // object since it doesn't have anything that gecko would want to draw over it. Besides,
       // we have to prevent imagelib from drawing it.
       nsRect dirty;
       dirty.IntersectRect(twistyRect, aDirtyRect);
       theme->DrawWidgetBackground(&aRenderingContext, this, 
-                                  twistyContext->GetStyleDisplay()->mAppearance, twistyRect, dirty);
+                                  twistyContext->StyleDisplay()->mAppearance, twistyRect, dirty);
     }
     else {
       // Time to paint the twisty.
       // Adjust the rect for its border and padding.
       nsMargin bp(0,0,0,0);
       GetBorderPadding(twistyContext, bp);
       twistyRect.Deflate(bp);
       if (isRTL)
@@ -3377,29 +3377,29 @@ nsTreeBodyFrame::PaintImage(int32_t     
                             nsPresContext*       aPresContext,
                             nsRenderingContext& aRenderingContext,
                             const nsRect&        aDirtyRect,
                             nscoord&             aRemainingWidth,
                             nscoord&             aCurrX)
 {
   NS_PRECONDITION(aColumn && aColumn->GetFrame(), "invalid column passed");
 
-  bool isRTL = GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
+  bool isRTL = StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
   nscoord rightEdge = aCurrX + aRemainingWidth;
   // Resolve style for the image.
   nsStyleContext* imageContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreeimage);
 
   // Obtain opacity value for the image.
-  float opacity = imageContext->GetStyleDisplay()->mOpacity;
+  float opacity = imageContext->StyleDisplay()->mOpacity;
 
   // Obtain the margins for the image and then deflate our rect by that
   // amount.  The image is assumed to be contained within the deflated rect.
   nsRect imageRect(aImageRect);
   nsMargin imageMargin;
-  imageContext->GetStyleMargin()->GetMargin(imageMargin);
+  imageContext->StyleMargin()->GetMargin(imageMargin);
   imageRect.Deflate(imageMargin);
 
   // Get the image.
   bool useImageRegion = true;
   nsCOMPtr<imgIContainer> image;
   GetImage(aRowIndex, aColumn, false, imageContext, useImageRegion, getter_AddRefs(image));
 
   // Get the image destination size.
@@ -3526,40 +3526,40 @@ nsTreeBodyFrame::PaintText(int32_t      
                            nsPresContext*      aPresContext,
                            nsRenderingContext& aRenderingContext,
                            const nsRect&        aDirtyRect,
                            nscoord&             aCurrX,
                            bool                 aTextRTL)
 {
   NS_PRECONDITION(aColumn && aColumn->GetFrame(), "invalid column passed");
 
-  bool isRTL = GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
+  bool isRTL = StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
 
   // Now obtain the text for our cell.
   nsAutoString text;
   mView->GetCellText(aRowIndex, aColumn, text);
   // We're going to paint this text so we need to ensure bidi is enabled if
   // necessary
   CheckTextForBidi(text);
 
   if (text.Length() == 0)
     return; // Don't paint an empty string. XXX What about background/borders? Still paint?
 
   // Resolve style for the text.  It contains all the info we need to lay ourselves
   // out and to paint.
   nsStyleContext* textContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecelltext);
 
   // Obtain opacity value for the image.
-  float opacity = textContext->GetStyleDisplay()->mOpacity;
+  float opacity = textContext->StyleDisplay()->mOpacity;
 
   // Obtain the margins for the text and then deflate our rect by that 
   // amount.  The text is assumed to be contained within the deflated rect.
   nsRect textRect(aTextRect);
   nsMargin textMargin;
-  textContext->GetStyleMargin()->GetMargin(textMargin);
+  textContext->StyleMargin()->GetMargin(textMargin);
   textRect.Deflate(textMargin);
 
   // Adjust the rect for its border and padding.
   nsMargin bp(0,0,0,0);
   GetBorderPadding(textContext, bp);
   textRect.Deflate(bp);
 
   // Compute our text size.
@@ -3587,20 +3587,20 @@ nsTreeBodyFrame::PaintText(int32_t      
     aCurrX += textRect.width + textMargin.LeftRight();
 
   PaintBackgroundLayer(textContext, aPresContext, aRenderingContext, textRect, aDirtyRect);
 
   // Time to paint our text.
   textRect.Deflate(bp);
 
   // Set our color.
-  aRenderingContext.SetColor(textContext->GetStyleColor()->mColor);
+  aRenderingContext.SetColor(textContext->StyleColor()->mColor);
 
   // Draw decorations.
-  uint8_t decorations = textContext->GetStyleTextReset()->mTextDecorationLine;
+  uint8_t decorations = textContext->StyleTextReset()->mTextDecorationLine;
 
   nscoord offset;
   nscoord size;
   if (decorations & (NS_FONT_DECORATION_OVERLINE | NS_FONT_DECORATION_UNDERLINE)) {
     fontMet->GetUnderline(offset, size);
     if (decorations & NS_FONT_DECORATION_OVERLINE)
       aRenderingContext.FillRect(textRect.x, textRect.y, textRect.width, size);
     if (decorations & NS_FONT_DECORATION_UNDERLINE)
@@ -3642,27 +3642,27 @@ nsTreeBodyFrame::PaintCheckbox(int32_t  
   nsStyleContext* checkboxContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecheckbox);
 
   nscoord rightEdge = aCheckboxRect.XMost();
 
   // Obtain the margins for the checkbox and then deflate our rect by that 
   // amount.  The checkbox is assumed to be contained within the deflated rect.
   nsRect checkboxRect(aCheckboxRect);
   nsMargin checkboxMargin;
-  checkboxContext->GetStyleMargin()->GetMargin(checkboxMargin);
+  checkboxContext->StyleMargin()->GetMargin(checkboxMargin);
   checkboxRect.Deflate(checkboxMargin);
   
   nsRect imageSize = GetImageSize(aRowIndex, aColumn, true, checkboxContext);
 
   if (imageSize.height > checkboxRect.height)
     imageSize.height = checkboxRect.height;
   if (imageSize.width > checkboxRect.width)
     imageSize.width = checkboxRect.width;
 
-  if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL)
+  if (StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL)
     checkboxRect.x = rightEdge - checkboxRect.width;
 
   // Paint our borders and background for our image rect.
   PaintBackgroundLayer(checkboxContext, aPresContext, aRenderingContext, checkboxRect, aDirtyRect);
 
   // Time to paint the checkbox.
   // Adjust the rect for its border and padding.
   nsMargin bp(0,0,0,0);
@@ -3705,45 +3705,45 @@ nsTreeBodyFrame::PaintProgressMeter(int3
   // to lay ourselves out and to paint.
   nsStyleContext* meterContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreeprogressmeter);
 
   // Obtain the margins for the progress meter and then deflate our rect by that 
   // amount. The progress meter is assumed to be contained within the deflated
   // rect.
   nsRect meterRect(aProgressMeterRect);
   nsMargin meterMargin;
-  meterContext->GetStyleMargin()->GetMargin(meterMargin);
+  meterContext->StyleMargin()->GetMargin(meterMargin);
   meterRect.Deflate(meterMargin);
 
   // Paint our borders and background for our progress meter rect.
   PaintBackgroundLayer(meterContext, aPresContext, aRenderingContext, meterRect, aDirtyRect);
 
   // Time to paint our progress. 
   int32_t state;
   mView->GetProgressMode(aRowIndex, aColumn, &state);
   if (state == nsITreeView::PROGRESS_NORMAL) {
     // Adjust the rect for its border and padding.
     AdjustForBorderPadding(meterContext, meterRect);
 
     // Set our color.
-    aRenderingContext.SetColor(meterContext->GetStyleColor()->mColor);
+    aRenderingContext.SetColor(meterContext->StyleColor()->mColor);
 
     // Now obtain the value for our cell.
     nsAutoString value;
     mView->GetCellValue(aRowIndex, aColumn, value);
 
     nsresult rv;
     int32_t intValue = value.ToInteger(&rv);
     if (intValue < 0)
       intValue = 0;
     else if (intValue > 100)
       intValue = 100;
 
     nscoord meterWidth = NSToCoordRound((float)intValue / 100 * meterRect.width);
-    if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL)
+    if (StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL)
       meterRect.x += meterRect.width - meterWidth; // right align
     meterRect.width = meterWidth;
     bool useImageRegion = true;
     nsCOMPtr<imgIContainer> image;
     GetImage(aRowIndex, aColumn, true, meterContext, useImageRegion, getter_AddRefs(image));
     if (image) {
       int32_t width, height;
       image->GetWidth(&width);
@@ -3807,17 +3807,17 @@ nsTreeBodyFrame::PaintDropFeedback(const
   }
 
   PrefillPropertyArray(mSlots->mDropRow, primaryCol);
 
   // Resolve the style to use for the drop feedback.
   nsStyleContext* feedbackContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreedropfeedback);
 
   // Paint only if it is visible.
-  if (feedbackContext->GetStyleVisibility()->IsVisibleOrCollapsed()) {
+  if (feedbackContext->StyleVisibility()->IsVisibleOrCollapsed()) {
     int32_t level;
     mView->GetLevel(mSlots->mDropRow, &level);
 
     // If our previous or next row has greater level use that for 
     // correct visual indentation.
     if (mSlots->mDropOrient == nsITreeView::DROP_BEFORE) {
       if (mSlots->mDropRow > 0) {
         int32_t previousLevel;
@@ -3839,22 +3839,22 @@ nsTreeBodyFrame::PaintDropFeedback(const
 
     if (primaryCol){
       nsStyleContext* twistyContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreetwisty);
       nsRect imageSize;
       nsRect twistyRect;
       GetTwistyRect(mSlots->mDropRow, primaryCol, imageSize, twistyRect, aPresContext,
                     aRenderingContext, twistyContext);
       nsMargin twistyMargin;
-      twistyContext->GetStyleMargin()->GetMargin(twistyMargin);
+      twistyContext->StyleMargin()->GetMargin(twistyMargin);
       twistyRect.Inflate(twistyMargin);
       currX += twistyRect.width;
     }
 
-    const nsStylePosition* stylePosition = feedbackContext->GetStylePosition();
+    const nsStylePosition* stylePosition = feedbackContext->StylePosition();
 
     // Obtain the width for the drop feedback or use default value.
     nscoord width;
     if (stylePosition->mWidth.GetUnit() == eStyleUnit_Coord)
       width = stylePosition->mWidth.GetCoordValue();
     else {
       // Use default width 50px.
       width = nsPresContext::CSSPixelsToAppUnits(50);
@@ -3868,34 +3868,34 @@ nsTreeBodyFrame::PaintDropFeedback(const
       // Use default height 2px.
       height = nsPresContext::CSSPixelsToAppUnits(2);
     }
 
     // Obtain the margins for the drop feedback and then deflate our rect
     // by that amount.
     nsRect feedbackRect(currX, aDropFeedbackRect.y, width, height);
     nsMargin margin;
-    feedbackContext->GetStyleMargin()->GetMargin(margin);
+    feedbackContext->StyleMargin()->GetMargin(margin);
     feedbackRect.Deflate(margin);
 
     feedbackRect.y += (aDropFeedbackRect.height - height) / 2;
 
     // Finally paint the drop feedback.
     PaintBackgroundLayer(feedbackContext, aPresContext, aRenderingContext, feedbackRect, aDirtyRect);
   }
 }
 
 void
 nsTreeBodyFrame::PaintBackgroundLayer(nsStyleContext*      aStyleContext,
                                       nsPresContext*      aPresContext,
                                       nsRenderingContext& aRenderingContext,
                                       const nsRect&        aRect,
                                       const nsRect&        aDirtyRect)
 {
-  const nsStyleBorder* myBorder = aStyleContext->GetStyleBorder();
+  const nsStyleBorder* myBorder = aStyleContext->StyleBorder();
 
   nsCSSRendering::PaintBackgroundWithSC(aPresContext, aRenderingContext,
                                         this, aDirtyRect, aRect,
                                         aStyleContext, *myBorder,
                                         nsCSSRendering::PAINTBG_SYNC_DECODE_IMAGES);
 
   nsCSSRendering::PaintBorderWithStyleBorder(aPresContext, aRenderingContext,
                                              this, aDirtyRect, aRect,
diff --git a/layout/xul/tree/nsTreeColFrame.cpp b/layout/xul/tree/nsTreeColFrame.cpp
--- a/layout/xul/tree/nsTreeColFrame.cpp
+++ b/layout/xul/tree/nsTreeColFrame.cpp
@@ -82,17 +82,17 @@ nsDisplayXULTreeColSplitterTarget::HitTe
   bool right = false;
   if (mFrame->GetSize().width - nsPresContext::CSSPixelsToAppUnits(4) <= rect.XMost()) {
     right = true;
   } else if (nsPresContext::CSSPixelsToAppUnits(4) > rect.x) {
     left = true;
   }
 
   // Swap left and right for RTL trees in order to find the correct splitter
-  if (mFrame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
+  if (mFrame->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
     bool tmp = left;
     left = right;
     right = tmp;
   }
 
   if (left || right) {
     // We are a header. Look for the correct splitter.
     nsIFrame* child;
diff --git a/layout/xul/tree/nsTreeColumns.cpp b/layout/xul/tree/nsTreeColumns.cpp
--- a/layout/xul/tree/nsTreeColumns.cpp
+++ b/layout/xul/tree/nsTreeColumns.cpp
@@ -100,17 +100,17 @@ nsresult
 nsTreeColumn::GetRect(nsTreeBodyFrame* aBodyFrame, nscoord aY, nscoord aHeight, nsRect* aResult)
 {
   nsIFrame* frame = GetFrame();
   if (!frame) {
     *aResult = nsRect();
     return NS_ERROR_FAILURE;
   }
 
-  bool isRTL = aBodyFrame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
+  bool isRTL = aBodyFrame->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
   *aResult = frame->GetRect();
   aResult->y = aY;
   aResult->height = aHeight;
   if (isRTL)
     aResult->x += aBodyFrame->mAdjustWidth;
   else if (IsLastVisible(aBodyFrame))
     aResult->width += aBodyFrame->mAdjustWidth;
   return NS_OK;
@@ -269,20 +269,20 @@ nsTreeColumn::Invalidate()
   // If we have an Id, cache the Id as an atom.
   if (!mId.IsEmpty()) {
     mAtom = do_GetAtom(mId);
   }
 
   // Cache our index.
   nsTreeUtils::GetColumnIndex(mContent, &mIndex);
 
-  const nsStyleVisibility* vis = frame->GetStyleVisibility();
+  const nsStyleVisibility* vis = frame->StyleVisibility();
 
   // Cache our text alignment policy.
-  const nsStyleText* textStyle = frame->GetStyleText();
+  const nsStyleText* textStyle = frame->StyleText();
 
   mTextAlignment = textStyle->mTextAlign;
   // DEFAULT or END alignment sometimes means RIGHT
   if ((mTextAlignment == NS_STYLE_TEXT_ALIGN_DEFAULT &&
        vis->mDirection == NS_STYLE_DIRECTION_RTL) ||
       (mTextAlignment == NS_STYLE_TEXT_ALIGN_END &&
        vis->mDirection == NS_STYLE_DIRECTION_LTR)) {
     mTextAlignment = NS_STYLE_TEXT_ALIGN_RIGHT;
diff --git a/toolkit/components/typeaheadfind/nsTypeAheadFind.cpp b/toolkit/components/typeaheadfind/nsTypeAheadFind.cpp
--- a/toolkit/components/typeaheadfind/nsTypeAheadFind.cpp
+++ b/toolkit/components/typeaheadfind/nsTypeAheadFind.cpp
@@ -1093,17 +1093,17 @@ nsTypeAheadFind::IsRangeVisible(nsIPresS
   nsCOMPtr<nsIContent> content(do_QueryInterface(node));
   if (!content)
     return false;
 
   nsIFrame *frame = content->GetPrimaryFrame();
   if (!frame)    
     return false;  // No frame! Not visible then.
 
-  if (!frame->GetStyleVisibility()->IsVisible())
+  if (!frame->StyleVisibility()->IsVisible())
     return false;
 
   // Detect if we are _inside_ a text control, or something else with its own
   // selection controller.
   if (aUsesIndependentSelection) {
     *aUsesIndependentSelection = 
       (frame->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION);
   }
diff --git a/widget/cocoa/nsNativeThemeCocoa.mm b/widget/cocoa/nsNativeThemeCocoa.mm
--- a/widget/cocoa/nsNativeThemeCocoa.mm
+++ b/widget/cocoa/nsNativeThemeCocoa.mm
@@ -210,17 +210,17 @@ static BOOL IsToolbarStyleContainer(nsIF
   if (!content)
     return NO;
 
   if (content->Tag() == nsGkAtoms::toolbar ||
       content->Tag() == nsGkAtoms::toolbox ||
       content->Tag() == nsGkAtoms::statusbar)
     return YES;
 
-  switch (aFrame->GetStyleDisplay()->mAppearance) {
+  switch (aFrame->StyleDisplay()->mAppearance) {
     case NS_THEME_TOOLBAR:
     case NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR:
     case NS_THEME_STATUSBAR:
       return YES;
     default:
       return NO;
   }
 }
@@ -746,17 +746,17 @@ static void DrawCellWithSnapping(NSCell 
   NS_OBJC_END_TRY_ABORT_BLOCK;
 }
 
 static float VerticalAlignFactor(nsIFrame *aFrame)
 {
   if (!aFrame)
     return 0.5f; // default: center
 
-  const nsStyleCoord& va = aFrame->GetStyleTextReset()->mVerticalAlign;
+  const nsStyleCoord& va = aFrame->StyleTextReset()->mVerticalAlign;
   uint8_t intval = (va.GetUnit() == eStyleUnit_Enumerated)
                      ? va.GetIntValue()
                      : NS_STYLE_VERTICAL_ALIGN_MIDDLE;
   switch (intval) {
     case NS_STYLE_VERTICAL_ALIGN_TOP:
     case NS_STYLE_VERTICAL_ALIGN_TEXT_TOP:
       return 0.0f;
 
@@ -1688,17 +1688,17 @@ nsNativeThemeCocoa::GetScrollbarDrawInfo
 
   int32_t curpos = CheckIntAttr(aFrame, nsGkAtoms::curpos, 0);
   int32_t minpos = CheckIntAttr(aFrame, nsGkAtoms::minpos, 0);
   int32_t maxpos = CheckIntAttr(aFrame, nsGkAtoms::maxpos, 100);
   int32_t thumbSize = CheckIntAttr(aFrame, nsGkAtoms::pageincrement, 10);
 
   bool isHorizontal = aFrame->GetContent()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::orient, 
                                                           nsGkAtoms::horizontal, eCaseMatters);
-  bool isSmall = aFrame->GetStyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL;
+  bool isSmall = aFrame->StyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL;
 
   aTdi.version = 0;
   aTdi.kind = isSmall ? kThemeSmallScrollBar : kThemeMediumScrollBar;
   aTdi.bounds.origin = CGPointZero;
   aTdi.bounds.size = aSize;
   aTdi.min = minpos;
   aTdi.max = maxpos;
   aTdi.value = curpos;
@@ -2181,17 +2181,17 @@ nsNativeThemeCocoa::DrawWidgetBackground
       DrawSearchField(cgContext, macRect, aFrame, eventState);
       break;
 
     case NS_THEME_PROGRESSBAR:
       if (!QueueAnimatedContentForRefresh(aFrame->GetContent(), 30)) {
         NS_WARNING("Unable to animate progressbar!");
       }
       DrawProgress(cgContext, macRect, IsIndeterminateProgress(aFrame, eventState),
-                   aFrame->GetStyleDisplay()->mOrient != NS_STYLE_ORIENT_VERTICAL,
+                   aFrame->StyleDisplay()->mOrient != NS_STYLE_ORIENT_VERTICAL,
 		   GetProgressValue(aFrame), GetProgressMaxValue(aFrame), aFrame);
       break;
 
     case NS_THEME_PROGRESSBAR_VERTICAL:
       DrawProgress(cgContext, macRect, IsIndeterminateProgress(aFrame, eventState),
                    false, GetProgressValue(aFrame),
                    GetProgressMaxValue(aFrame), aFrame);
       break;
@@ -2464,17 +2464,17 @@ nsNativeThemeCocoa::GetWidgetBorder(nsDe
       if (!nsCocoaFeatures::OnLionOrLater()) {
         // There's only an endcap to worry about when both arrows are on the bottom
         NSString *buttonPlacement = [[NSUserDefaults standardUserDefaults] objectForKey:@"AppleScrollBarVariant"];
         if (!buttonPlacement || [buttonPlacement isEqualToString:@"DoubleMax"]) {
           bool isHorizontal = (aWidgetType == NS_THEME_SCROLLBAR_TRACK_HORIZONTAL);
 
           nsIFrame *scrollbarFrame = GetParentScrollbarFrame(aFrame);
           if (!scrollbarFrame) return NS_ERROR_FAILURE;
-          bool isSmall = (scrollbarFrame->GetStyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL);
+          bool isSmall = (scrollbarFrame->StyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL);
 
           // There isn't a metric for this, so just hardcode a best guess at the value.
           // This value is even less exact due to the fact that the endcap is partially concave.
           int32_t endcapSize = isSmall ? 5 : 6;
 
           if (isHorizontal)
             aResult->SizeTo(endcapSize, 0, 0, 0);
           else
@@ -2688,17 +2688,17 @@ nsNativeThemeCocoa::GetMinimumWidgetSize
     case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
     {
       // Find our parent scrollbar frame in order to find out whether we're in
       // a small or a large scrollbar.
       nsIFrame *scrollbarFrame = GetParentScrollbarFrame(aFrame);
       if (!scrollbarFrame)
         return NS_ERROR_FAILURE;
 
-      bool isSmall = (scrollbarFrame->GetStyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL);
+      bool isSmall = (scrollbarFrame->StyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL);
       bool isHorizontal = (aWidgetType == NS_THEME_SCROLLBAR_THUMB_HORIZONTAL);
       int32_t& minSize = isHorizontal ? aResult->width : aResult->height;
       minSize = isSmall ? kSmallScrollbarThumbMinSize : kRegularScrollbarThumbMinSize;
       break;
     }
 
     case NS_THEME_SCROLLBAR:
     case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
@@ -2707,17 +2707,17 @@ nsNativeThemeCocoa::GetMinimumWidgetSize
       // yeah, i know i'm cheating a little here, but i figure that it
       // really doesn't matter if the scrollbar is vertical or horizontal
       // and the width metric is a really good metric for every piece
       // of the scrollbar.
 
       nsIFrame *scrollbarFrame = GetParentScrollbarFrame(aFrame);
       if (!scrollbarFrame) return NS_ERROR_FAILURE;
 
-      int32_t themeMetric = (scrollbarFrame->GetStyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL) ?
+      int32_t themeMetric = (scrollbarFrame->StyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL) ?
                             kThemeMetricSmallScrollBarWidth :
                             kThemeMetricScrollBarWidth;
       SInt32 scrollbarWidth = 0;
       ::GetThemeMetric(themeMetric, &scrollbarWidth);
       aResult->SizeTo(scrollbarWidth, scrollbarWidth);
       *aIsOverridable = false;
       break;
     }
@@ -2726,17 +2726,17 @@ nsNativeThemeCocoa::GetMinimumWidgetSize
     case NS_THEME_SCROLLBAR_BUTTON_DOWN:
     case NS_THEME_SCROLLBAR_BUTTON_LEFT:
     case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
     {
       nsIFrame *scrollbarFrame = GetParentScrollbarFrame(aFrame);
       if (!scrollbarFrame) return NS_ERROR_FAILURE;
 
       // Since there is no NS_THEME_SCROLLBAR_BUTTON_UP_SMALL we need to ask the parent what appearance style it has.
-      int32_t themeMetric = (scrollbarFrame->GetStyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL) ?
+      int32_t themeMetric = (scrollbarFrame->StyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL) ?
                             kThemeMetricSmallScrollBarWidth :
                             kThemeMetricScrollBarWidth;
       SInt32 scrollbarWidth = 0;
       ::GetThemeMetric(themeMetric, &scrollbarWidth);
 
       // It seems that for both sizes of scrollbar, the buttons are one pixel "longer".
       if (aWidgetType == NS_THEME_SCROLLBAR_BUTTON_LEFT || aWidgetType == NS_THEME_SCROLLBAR_BUTTON_RIGHT)
         aResult->SizeTo(scrollbarWidth+1, scrollbarWidth);
diff --git a/widget/gtk2/nsNativeThemeGTK.cpp b/widget/gtk2/nsNativeThemeGTK.cpp
--- a/widget/gtk2/nsNativeThemeGTK.cpp
+++ b/widget/gtk2/nsNativeThemeGTK.cpp
@@ -126,17 +126,17 @@ static void SetWidgetStateSafe(uint8_t *
   aSafeVector[key >> 3] |= (1 << (key & 7));
 }
 
 static GtkTextDirection GetTextDirection(nsIFrame* aFrame)
 {
   if (!aFrame)
     return GTK_TEXT_DIR_NONE;
 
-  switch (aFrame->GetStyleVisibility()->mDirection) {
+  switch (aFrame->StyleVisibility()->mDirection) {
     case NS_STYLE_DIRECTION_RTL:
       return GTK_TEXT_DIR_RTL;
     case NS_STYLE_DIRECTION_LTR:
       return GTK_TEXT_DIR_LTR;
   }
 
   return GTK_TEXT_DIR_NONE;
 }
@@ -529,17 +529,17 @@ nsNativeThemeGTK::GetGtkWidgetAndState(u
     break;
   case NS_THEME_PROGRESSBAR_CHUNK:
   case NS_THEME_PROGRESSBAR_CHUNK_VERTICAL:
     {
       nsIFrame* stateFrame = aFrame->GetParent();
       nsEventStates eventStates = GetContentState(stateFrame, aWidgetType);
 
       aGtkWidgetType = IsIndeterminateProgress(stateFrame, eventStates)
-                         ? (stateFrame->GetStyleDisplay()->mOrient == NS_STYLE_ORIENT_VERTICAL)
+                         ? (stateFrame->StyleDisplay()->mOrient == NS_STYLE_ORIENT_VERTICAL)
                            ? MOZ_GTK_PROGRESS_CHUNK_VERTICAL_INDETERMINATE
                            : MOZ_GTK_PROGRESS_CHUNK_INDETERMINATE
                          : MOZ_GTK_PROGRESS_CHUNK;
     }
     break;
   case NS_THEME_TAB_SCROLLARROW_BACK:
   case NS_THEME_TAB_SCROLLARROW_FORWARD:
     if (aWidgetFlags)
diff --git a/widget/windows/nsNativeThemeWin.cpp b/widget/windows/nsNativeThemeWin.cpp
--- a/widget/windows/nsNativeThemeWin.cpp
+++ b/widget/windows/nsNativeThemeWin.cpp
@@ -733,17 +733,17 @@ nsNativeThemeWin::GetThemePartAndState(n
       aState = (aWidgetType - NS_THEME_SCROLLBAR_BUTTON_UP)*4;
       nsEventStates eventState = GetContentState(aFrame, aWidgetType);
       if (!aFrame)
         aState += TS_NORMAL;
       else if (IsDisabled(aFrame, eventState))
         aState += TS_DISABLED;
       else {
         nsIFrame *parent = aFrame->GetParent();
-        nsEventStates parentState = GetContentState(parent, parent->GetStyleDisplay()->mAppearance);
+        nsEventStates parentState = GetContentState(parent, parent->StyleDisplay()->mAppearance);
         if (eventState.HasAllStates(NS_EVENT_STATE_HOVER | NS_EVENT_STATE_ACTIVE))
           aState += TS_ACTIVE;
         else if (eventState.HasState(NS_EVENT_STATE_HOVER))
           aState += TS_HOVER;
         else if (WinUtils::GetWindowsVersion() >= WinUtils::VISTA_VERSION &&
                  parentState.HasState(NS_EVENT_STATE_HOVER))
           aState = (aWidgetType - NS_THEME_SCROLLBAR_BUTTON_UP) + SP_BUTTON_IMPLICIT_HOVER_BASE;
         else
@@ -2680,17 +2680,17 @@ nsresult nsNativeThemeWin::ClassicGetThe
         aState |= DFCS_INACTIVE;
       else if (IsOpenButton(aFrame))
         aState |= DFCS_PUSHED;
       else if (IsCheckedButton(aFrame))
         aState |= DFCS_CHECKED;
       else {
         if (contentState.HasAllStates(NS_EVENT_STATE_ACTIVE | NS_EVENT_STATE_HOVER)) {
           aState |= DFCS_PUSHED;
-          const nsStyleUserInterface *uiData = aFrame->GetStyleUserInterface();
+          const nsStyleUserInterface *uiData = aFrame->StyleUserInterface();
           // The down state is flat if the button is focusable
           if (uiData->mUserFocus == NS_STYLE_USER_FOCUS_NORMAL) {
             if (!aFrame->GetContent()->IsHTML())
               aState |= DFCS_FLAT;
 
             aFocused = true;
           }
         }
diff --git a/widget/xpwidgets/nsNativeTheme.cpp b/widget/xpwidgets/nsNativeTheme.cpp
--- a/widget/xpwidgets/nsNativeTheme.cpp
+++ b/widget/xpwidgets/nsNativeTheme.cpp
@@ -227,17 +227,17 @@ nsNativeTheme::IsWidgetStyled(nsPresCont
   if (aWidgetType == NS_THEME_RESIZER) {
     nsIFrame* parentFrame = aFrame->GetParent();
     if (parentFrame && parentFrame->GetType() == nsGkAtoms::scrollFrame) {
       // if the parent is a scrollframe, the resizer should be native themed
       // only if the scrollable area doesn't override the widget style.
       parentFrame = parentFrame->GetParent();
       if (parentFrame) {
         return IsWidgetStyled(aPresContext, parentFrame,
-                              parentFrame->GetStyleDisplay()->mAppearance);
+                              parentFrame->StyleDisplay()->mAppearance);
       }
     }
   }
 
   /**
    * Progress bar appearance should be the same for the bar and the container
    * frame. nsProgressFrame owns the logic and will tell us what we should do.
    */
@@ -295,17 +295,17 @@ nsNativeTheme::IsDisabled(nsIFrame* aFra
   // be counted as true.
   return content->AttrValueIs(kNameSpaceID_None, nsGkAtoms::disabled,
                               NS_LITERAL_STRING("true"), eCaseMatters);
 }
 
 bool
 nsNativeTheme::IsFrameRTL(nsIFrame* aFrame)
 {
-  return aFrame && aFrame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
+  return aFrame && aFrame->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
 }
 
 // scrollbar button:
 int32_t
 nsNativeTheme::GetScrollbarButtonType(nsIFrame* aFrame)
 {
   if (!aFrame)
     return 0;
@@ -456,24 +456,24 @@ nsNativeTheme::IsIndeterminateProgress(n
                                            NS_LITERAL_STRING("undetermined"),
                                            eCaseMatters);
 }
 
 bool
 nsNativeTheme::IsVerticalProgress(nsIFrame* aFrame)
 {
   return aFrame &&
-         aFrame->GetStyleDisplay()->mOrient == NS_STYLE_ORIENT_VERTICAL;
+         aFrame->StyleDisplay()->mOrient == NS_STYLE_ORIENT_VERTICAL;
 }
 
 bool
 nsNativeTheme::IsVerticalMeter(nsIFrame* aFrame)
 {
   NS_PRECONDITION(aFrame, "You have to pass a non-null aFrame");
-  return aFrame->GetStyleDisplay()->mOrient == NS_STYLE_ORIENT_VERTICAL;
+  return aFrame->StyleDisplay()->mOrient == NS_STYLE_ORIENT_VERTICAL;
 }
 
 // menupopup:
 bool
 nsNativeTheme::IsSubmenu(nsIFrame* aFrame, bool* aLeftOfParent)
 {
   if (!aFrame)
     return false;
@@ -586,14 +586,14 @@ nsNativeTheme::GetAdjacentSiblingFrameWi
   // Find the next visible sibling.
   nsIFrame* sibling = aFrame;
   do {
     sibling = aNextSibling ? sibling->GetNextSibling() : sibling->GetPrevSibling();
   } while (sibling && sibling->GetRect().width == 0);
 
   // Check same appearance and adjacency.
   if (!sibling ||
-      sibling->GetStyleDisplay()->mAppearance != aFrame->GetStyleDisplay()->mAppearance ||
+      sibling->StyleDisplay()->mAppearance != aFrame->StyleDisplay()->mAppearance ||
       (sibling->GetRect().XMost() != aFrame->GetRect().x &&
        aFrame->GetRect().XMost() != sibling->GetRect().x))
     return nullptr;
   return sibling;
 }
