From: L. David Baron <dbaron@dbaron.org>

Move ReadTransforms from nsRuleNode to nsStyleTransformMatrix.  (Bug 531344)  r=dholbert

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -3892,48 +3892,16 @@ nsRuleNode::ComputeUIResetData(void* aSt
   // -moz-window-shadow: enum, inherit, initial
   SetDiscrete(uiData.mWindowShadow, ui->mWindowShadow, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentUI->mWindowShadow,
               NS_STYLE_WINDOW_SHADOW_DEFAULT, 0, 0, 0, 0);
 
   COMPUTE_END_RESET(UIReset, ui)
 }
 
-/* Given a -moz-transform token stream, accumulates them into an
- * nsStyleTransformMatrix
- *
- * @param aList The nsCSSValueList of arrays to read into transform functions.
- * @param aContext The style context to use for unit conversion.
- * @param aPresContext The presentation context to use for unit conversion
- * @param aCanStoreInRuleTree This is set to PR_FALSE if the value cannot be stored in the rule tree.
- * @return An nsStyleTransformMatrix corresponding to the net transform.
- */
-static nsStyleTransformMatrix ReadTransforms(const nsCSSValueList* aList,
-                                             nsStyleContext* aContext,
-                                             nsPresContext* aPresContext,
-                                             PRBool &aCanStoreInRuleTree)
-{
-  nsStyleTransformMatrix result;
-
-  for (const nsCSSValueList* curr = aList; curr != nsnull; curr = curr->mNext) {
-    const nsCSSValue &currElem = curr->mValue;
-    NS_ASSERTION(currElem.GetUnit() == eCSSUnit_Function,
-                 "Stream should consist solely of functions!");
-    NS_ASSERTION(currElem.GetArrayValue()->Count() >= 1,
-                 "Incoming function is too short!");
-
-    /* Read in a single transform matrix, then accumulate it with the total. */
-    nsStyleTransformMatrix currMatrix;
-    currMatrix.SetToTransformFunction(currElem.GetArrayValue(), aContext,
-                                      aPresContext, aCanStoreInRuleTree);
-    result *= currMatrix;
-  }
-  return result;
-}
-
 // A simple helper function to get the length of a nsCSSValueList
 inline static PRUint32 GetValueListLength(nsCSSValueList* aValueList)
 {
   PRUint32 len = 0;
   nsCSSValueList* val = aValueList;
   while (val) {
     len++;
     val = val->mNext;
@@ -4474,18 +4442,18 @@ nsRuleNode::ComputeDisplayData(void* aSt
       display->mSpecifiedTransform = nsnull;
     }
     /* Otherwise, we are looking at a list of CSS tokens.  We'll read each of
      * them in as an array of nsTransformFunction objects, then will accumulate
      * them all together to form the final transform matrix.
      */
     else {
       display->mSpecifiedTransform = head; // weak pointer, owned by rule
-      display->mTransform =
-        ReadTransforms(head, aContext, mPresContext, canStoreInRuleTree);
+      display->mTransform = nsStyleTransformMatrix::ReadTransforms(head,
+                              aContext, mPresContext, canStoreInRuleTree);
     }
   }
 
   /* Convert -moz-transform-origin. */
   if (displayData.mTransformOrigin.mXValue.GetUnit() != eCSSUnit_Null ||
       displayData.mTransformOrigin.mXValue.GetUnit() != eCSSUnit_Null) {
 
     /* If X coordinate is an enumerated type, handle it explicitly. */
diff --git a/layout/style/nsStyleTransformMatrix.cpp b/layout/style/nsStyleTransformMatrix.cpp
--- a/layout/style/nsStyleTransformMatrix.cpp
+++ b/layout/style/nsStyleTransformMatrix.cpp
@@ -42,16 +42,17 @@
 #include "nsAutoPtr.h"
 #include "nsCSSValue.h"
 #include "nsStyleContext.h"
 #include "nsPresContext.h"
 #include "nsRuleNode.h"
 #include "nsCSSKeywords.h"
 #include "nsMathUtils.h"
 #include "CSSCalc.h"
+#include "nsCSSStruct.h"
 
 namespace css = mozilla::css;
 
 /* Note on floating point precision: The transform matrix is an array
  * of single precision 'float's, and so are most of the input values
  * we get from the style system, but intermediate calculations
  * involving angles need to be done in 'double'.
  */
@@ -590,16 +591,49 @@ nsStyleTransformMatrix::SetToTransformFu
     ProcessMatrix(mMain, mDelta, mX, mY, aData, aContext, aPresContext,
                   aCanStoreInRuleTree);
     break;
   default:
     NS_NOTREACHED("Unknown transform function!");
   }
 }
 
+/* Given a -moz-transform token stream, accumulates them into an
+ * nsStyleTransformMatrix
+ *
+ * @param aList The nsCSSValueList of arrays to read into transform functions.
+ * @param aContext The style context to use for unit conversion.
+ * @param aPresContext The presentation context to use for unit conversion
+ * @param aCanStoreInRuleTree This is set to PR_FALSE if the value cannot be stored in the rule tree.
+ * @return An nsStyleTransformMatrix corresponding to the net transform.
+ */
+/* static */ nsStyleTransformMatrix
+nsStyleTransformMatrix::ReadTransforms(const nsCSSValueList* aList,
+                                       nsStyleContext* aContext,
+                                       nsPresContext* aPresContext,
+                                       PRBool &aCanStoreInRuleTree)
+{
+  nsStyleTransformMatrix result;
+
+  for (const nsCSSValueList* curr = aList; curr != nsnull; curr = curr->mNext) {
+    const nsCSSValue &currElem = curr->mValue;
+    NS_ASSERTION(currElem.GetUnit() == eCSSUnit_Function,
+                 "Stream should consist solely of functions!");
+    NS_ASSERTION(currElem.GetArrayValue()->Count() >= 1,
+                 "Incoming function is too short!");
+
+    /* Read in a single transform matrix, then accumulate it with the total. */
+    nsStyleTransformMatrix currMatrix;
+    currMatrix.SetToTransformFunction(currElem.GetArrayValue(), aContext,
+                                      aPresContext, aCanStoreInRuleTree);
+    result *= currMatrix;
+  }
+  return result;
+}
+
 /* Does an element-by-element comparison and returns whether or not the
  * matrices are equal.
  */
 PRBool
 nsStyleTransformMatrix::operator ==(const nsStyleTransformMatrix &aOther) const
 {
   for (PRInt32 index = 0; index < 4; ++index)
     if (mMain[index] != aOther.mMain[index])
diff --git a/layout/style/nsStyleTransformMatrix.h b/layout/style/nsStyleTransformMatrix.h
--- a/layout/style/nsStyleTransformMatrix.h
+++ b/layout/style/nsStyleTransformMatrix.h
@@ -40,16 +40,18 @@
 
 #ifndef nsStyleTransformMatrix_h_
 #define nsStyleTransformMatrix_h_
 
 #include "nsCSSValue.h"
 #include "gfxMatrix.h"
 #include "nsRect.h"
 
+struct nsCSSValueList;
+
 /**
  * A class representing a style transformation matrix.  The class actually
  * wraps three different matrices, a constant matrix and two matrices
  * whose values are scaled by the width and the height of the bounding
  * rectangle for the object to transform.  Thus, given a frame rectangle
  * of dimensions (width, height) and a point (x, y) to transform, the matrix
  * corresponds to the transform operation
  *
@@ -116,16 +118,24 @@ class nsStyleTransformMatrix
    *                            in the rule tree, otherwise untouched.
    */
   void SetToTransformFunction(const nsCSSValue::Array* aData,
                               nsStyleContext* aContext,
                               nsPresContext* aPresContext,
                               PRBool& aCanStoreInRuleTree);
 
   /**
+   * The same as SetToTransformFunction, but for a list of transform
+   * functions.
+   */
+  static nsStyleTransformMatrix ReadTransforms(const nsCSSValueList* aList,
+                                               nsStyleContext* aContext,
+                                               nsPresContext* aPresContext,
+                                               PRBool &aCanStoreInRuleTree);
+  /**
    * Sets this matrix to be the identity matrix.
    */
   void SetToIdentity();
 
   /**
    * Returns the value of the entry at the 2x2 submatrix of the
    * transform matrix that defines the non-affine linear transform.
    * The order is given as
