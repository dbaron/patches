From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::GetBorderAndPadding to GetXULBorderAndPadding.

Written purely with sed, over .h and .cpp files in layout/.

MozReview-Commit-ID: A8rWLW213Uo

diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -8613,17 +8613,17 @@ nsFrame::RefreshSizeCache(nsBoxLayoutSta
     nsBoxLayoutMetrics* metrics = BoxMetrics();
     if (!DoesNeedRecalc(metrics->mBlockPrefSize))
       return NS_OK;
 
     // the rect we plan to size to.
     nsRect rect = GetRect();
 
     nsMargin bp(0,0,0,0);
-    GetBorderAndPadding(bp);
+    GetXULBorderAndPadding(bp);
 
     {
       // If we're a container for font size inflation, then shrink
       // wrapping inside of us should not apply font size inflation.
       AutoMaybeDisableFontInflation an(this);
 
       metrics->mBlockPrefSize.width =
         GetPrefISize(rendContext) + bp.LeftRight();
diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -1382,17 +1382,17 @@ nsXULScrollFrame::GetType() const
 nscoord
 nsXULScrollFrame::GetXULBoxAscent(nsBoxLayoutState& aState)
 {
   if (!mHelper.mScrolledFrame)
     return 0;
 
   nscoord ascent = mHelper.mScrolledFrame->GetXULBoxAscent(aState);
   nsMargin m(0,0,0,0);
-  GetBorderAndPadding(m);
+  GetXULBorderAndPadding(m);
   ascent += m.top;
   GetMargin(m);
   ascent += m.top;
 
   return ascent;
 }
 
 nsSize
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2906,17 +2906,17 @@ public:
   // area. It's enough to just call XULLayout or SyncLayout on the
   // box. You can pass true to aRemoveOverflowArea as a
   // convenience.
   virtual void SetXULBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
                             bool aRemoveOverflowAreas = false) = 0;
   nsresult XULLayout(nsBoxLayoutState& aBoxLayoutState);
   // Box methods.  Note that these do NOT just get the CSS border, padding,
   // etc.  They also talk to nsITheme.
-  virtual nsresult GetBorderAndPadding(nsMargin& aBorderAndPadding);
+  virtual nsresult GetXULBorderAndPadding(nsMargin& aBorderAndPadding);
   virtual nsresult GetBorder(nsMargin& aBorder)=0;
   virtual nsresult GetPadding(nsMargin& aBorderAndPadding)=0;
   virtual nsresult GetMargin(nsMargin& aMargin)=0;
   virtual void SetLayoutManager(nsBoxLayout* aLayout) { }
   virtual nsBoxLayout* GetLayoutManager() { return nullptr; }
   nsresult GetClientRect(nsRect& aContentRect);
 
   // For nsSprocketLayout
diff --git a/layout/xul/grid/nsGrid.cpp b/layout/xul/grid/nsGrid.cpp
--- a/layout/xul/grid/nsGrid.cpp
+++ b/layout/xul/grid/nsGrid.cpp
@@ -649,17 +649,17 @@ nsGrid::GetRowOffsets(int32_t aIndex, ns
   nsMargin totalMargin(0,0,0,0);
 
   // if there is a box and it's not bogus take its
   // borders padding into account
   if (box && !row->mIsBogus)
   {
     if (!box->IsXULCollapsed())
     {
-       // get real border and padding. GetBorderAndPadding
+       // get real border and padding. GetXULBorderAndPadding
        // is redefined on nsGridRowLeafFrame. If we called it here
        // we would be in finite recurson.
        box->GetBorder(border);
        box->GetPadding(padding);
 
        totalBorderPadding += border;
        totalBorderPadding += padding;
      }
@@ -718,17 +718,17 @@ nsGrid::GetRowOffsets(int32_t aIndex, ns
       {
         // ignore collapsed children
         if (!box->IsXULCollapsed())
         {
            // include the margin of the columns. To the row
            // at this point border/padding and margins all added
            // up to more needed space.
            margin = GetBoxTotalMargin(box, !aIsHorizontal);
-           // get real border and padding. GetBorderAndPadding
+           // get real border and padding. GetXULBorderAndPadding
            // is redefined on nsGridRowLeafFrame. If we called it here
            // we would be in finite recurson.
            box->GetBorder(border);
            box->GetPadding(padding);
            totalChildBorderPadding += border;
            totalChildBorderPadding += padding;
            totalChildBorderPadding += margin;
         }
diff --git a/layout/xul/grid/nsGridRowGroupLayout.cpp b/layout/xul/grid/nsGridRowGroupLayout.cpp
--- a/layout/xul/grid/nsGridRowGroupLayout.cpp
+++ b/layout/xul/grid/nsGridRowGroupLayout.cpp
@@ -251,15 +251,15 @@ nsGridRowGroupLayout::GetTotalMargin(nsI
   nsMargin margin = nsGridRowLayout::GetTotalMargin(aBox, aIsHorizontal);
   
   // make sure we have the scrollframe on the outside if it has one.
   // that's where the border is.
   aBox = nsGrid::GetScrollBox(aBox);
 
   // add our border/padding to it
   nsMargin borderPadding(0,0,0,0);
-  aBox->GetBorderAndPadding(borderPadding);
+  aBox->GetXULBorderAndPadding(borderPadding);
   margin += borderPadding;
 
   return margin;
 }
 
 
diff --git a/layout/xul/grid/nsGridRowLeafFrame.cpp b/layout/xul/grid/nsGridRowLeafFrame.cpp
--- a/layout/xul/grid/nsGridRowLeafFrame.cpp
+++ b/layout/xul/grid/nsGridRowLeafFrame.cpp
@@ -28,20 +28,20 @@ NS_NewGridRowLeafFrame(nsIPresShell* aPr
 
 NS_IMPL_FRAMEARENA_HELPERS(nsGridRowLeafFrame)
 
 /*
  * Our border and padding could be affected by our columns or rows.
  * Let's go check it out.
  */
 nsresult
-nsGridRowLeafFrame::GetBorderAndPadding(nsMargin& aBorderAndPadding)
+nsGridRowLeafFrame::GetXULBorderAndPadding(nsMargin& aBorderAndPadding)
 {
   // if our columns have made our padding larger add it in.
-  nsresult rv = nsBoxFrame::GetBorderAndPadding(aBorderAndPadding);
+  nsresult rv = nsBoxFrame::GetXULBorderAndPadding(aBorderAndPadding);
 
   nsIGridPart* part = nsGrid::GetPartFromBox(this);
   if (!part)
     return rv;
     
   int32_t index = 0;
   nsGrid* grid = part->GetGrid(this, &index);
 
diff --git a/layout/xul/grid/nsGridRowLeafFrame.h b/layout/xul/grid/nsGridRowLeafFrame.h
--- a/layout/xul/grid/nsGridRowLeafFrame.h
+++ b/layout/xul/grid/nsGridRowLeafFrame.h
@@ -39,16 +39,16 @@ public:
   }
 #endif
 
   nsGridRowLeafFrame(nsStyleContext* aContext,
                      bool aIsRoot,
                      nsBoxLayout* aLayoutManager):
     nsBoxFrame(aContext, aIsRoot, aLayoutManager) {}
 
-  virtual nsresult GetBorderAndPadding(nsMargin& aBorderAndPadding) override;
+  virtual nsresult GetXULBorderAndPadding(nsMargin& aBorderAndPadding) override;
 
 }; // class nsGridRowLeafFrame
 
 
 
 #endif
 
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -209,17 +209,17 @@ nsBox::RelayoutChildAtOrdinal(nsIFrame* 
 
 nsresult
 nsIFrame::GetClientRect(nsRect& aClientRect)
 {
   aClientRect = mRect;
   aClientRect.MoveTo(0,0);
 
   nsMargin borderPadding;
-  GetBorderAndPadding(borderPadding);
+  GetXULBorderAndPadding(borderPadding);
 
   aClientRect.Deflate(borderPadding);
 
   if (aClientRect.width < 0)
      aClientRect.width = 0;
 
   if (aClientRect.height < 0)
      aClientRect.height = 0;
@@ -279,17 +279,17 @@ nsBox::SetXULBounds(nsBoxLayoutState& aS
 void
 nsBox::GetLayoutFlags(uint32_t& aFlags)
 {
   aFlags = 0;
 }
 
 
 nsresult
-nsIFrame::GetBorderAndPadding(nsMargin& aBorderAndPadding)
+nsIFrame::GetXULBorderAndPadding(nsMargin& aBorderAndPadding)
 {
   aBorderAndPadding.SizeTo(0, 0, 0, 0);
   nsresult rv = GetBorder(aBorderAndPadding);
   if (NS_FAILED(rv))
     return rv;
 
   nsMargin padding;
   rv = GetPadding(padding);
@@ -868,17 +868,17 @@ nsBox::AddBorderAndPadding(nsSize& aSize
 {
   AddBorderAndPadding(this, aSize);
 }
 
 void
 nsBox::AddBorderAndPadding(nsIFrame* aBox, nsSize& aSize)
 {
   nsMargin borderPadding(0,0,0,0);
-  aBox->GetBorderAndPadding(borderPadding);
+  aBox->GetXULBorderAndPadding(borderPadding);
   AddMargin(aSize, borderPadding);
 }
 
 void
 nsBox::AddMargin(nsIFrame* aChild, nsSize& aSize)
 {
   nsMargin margin(0,0,0,0);
   aChild->GetMargin(margin);
diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -590,19 +590,19 @@ nsBoxFrame::GetMinISize(nsRenderingConte
   DISPLAY_MIN_WIDTH(this, result);
 
   nsBoxLayoutState state(PresContext(), aRenderingContext);
   nsSize minSize = GetXULMinSize(state);
 
   // GetXULMinSize returns border-box width, and we want to return content
   // width.  Since Reflow uses the reflow state's border and padding, we
   // actually just want to subtract what GetXULMinSize added, which is the
-  // result of GetBorderAndPadding.
+  // result of GetXULBorderAndPadding.
   nsMargin bp;
-  GetBorderAndPadding(bp);
+  GetXULBorderAndPadding(bp);
 
   result = minSize.width - bp.LeftRight();
   result = std::max(result, 0);
 
   return result;
 }
 
 /* virtual */ nscoord
@@ -612,19 +612,19 @@ nsBoxFrame::GetPrefISize(nsRenderingCont
   DISPLAY_PREF_WIDTH(this, result);
 
   nsBoxLayoutState state(PresContext(), aRenderingContext);
   nsSize prefSize = GetXULPrefSize(state);
 
   // GetXULPrefSize returns border-box width, and we want to return content
   // width.  Since Reflow uses the reflow state's border and padding, we
   // actually just want to subtract what GetXULPrefSize added, which is the
-  // result of GetBorderAndPadding.
+  // result of GetXULBorderAndPadding.
   nsMargin bp;
-  GetBorderAndPadding(bp);
+  GetXULBorderAndPadding(bp);
 
   result = prefSize.width - bp.LeftRight();
   result = std::max(result, 0);
 
   return result;
 }
 
 void
@@ -662,17 +662,17 @@ nsBoxFrame::Reflow(nsPresContext*       
   nsBoxLayoutState state(aPresContext, aReflowState.rendContext,
                          &aReflowState, aReflowState.mReflowDepth);
 
   WritingMode wm = aReflowState.GetWritingMode();
   LogicalSize computedSize(wm, aReflowState.ComputedISize(),
                            aReflowState.ComputedBSize());
 
   LogicalMargin m = aReflowState.ComputedLogicalBorderPadding();
-  // GetBorderAndPadding(m);
+  // GetXULBorderAndPadding(m);
 
   LogicalSize prefSize(wm);
 
   // if we are told to layout intrinsic then get our preferred size.
   NS_ASSERTION(computedSize.ISize(wm) != NS_INTRINSICSIZE,
                "computed inline size should always be computed");
   if (computedSize.BSize(wm) == NS_INTRINSICSIZE) {
     nsSize physicalPrefSize = GetXULPrefSize(state);
@@ -1718,17 +1718,17 @@ nsBoxFrame::DisplayDebugInfoFor(nsIFrame
 
     nscoord x = aPoint.x;
     nscoord y = aPoint.y;
 
     // get the area inside our border but not our debug margins.
     nsRect insideBorder(aBox->mRect);
     insideBorder.MoveTo(0,0):
     nsMargin border(0,0,0,0);
-    aBox->GetBorderAndPadding(border);
+    aBox->GetXULBorderAndPadding(border);
     insideBorder.Deflate(border);
 
     bool isHorizontal = IsHorizontal();
 
     if (!insideBorder.Contains(nsPoint(x,y)))
         return NS_ERROR_FAILURE;
 
     //printf("%%%%%% inside box %%%%%%%\n");
diff --git a/layout/xul/nsGroupBoxFrame.cpp b/layout/xul/nsGroupBoxFrame.cpp
--- a/layout/xul/nsGroupBoxFrame.cpp
+++ b/layout/xul/nsGroupBoxFrame.cpp
@@ -20,17 +20,17 @@ using namespace mozilla::image;
 
 class nsGroupBoxFrame : public nsBoxFrame {
 public:
   NS_DECL_FRAMEARENA_HELPERS
 
   explicit nsGroupBoxFrame(nsStyleContext* aContext):
     nsBoxFrame(aContext) {}
 
-  virtual nsresult GetBorderAndPadding(nsMargin& aBorderAndPadding) override;
+  virtual nsresult GetXULBorderAndPadding(nsMargin& aBorderAndPadding) override;
 
   virtual void BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                 const nsRect&           aDirtyRect,
                                 const nsDisplayListSet& aLists) override;
 
 #ifdef DEBUG_FRAME_DUMP
   virtual nsresult GetFrameName(nsAString& aResult) const override {
     return MakeFrameName(NS_LITERAL_STRING("GroupBoxFrame"), aResult);
@@ -279,14 +279,14 @@ nsGroupBoxFrame::GetCaptionBox(nsRect& a
        aCaptionRect.x += parentRect.x;
        aCaptionRect.y += parentRect.y;
     }
 
     return child;
 }
 
 nsresult
-nsGroupBoxFrame::GetBorderAndPadding(nsMargin& aBorderAndPadding)
+nsGroupBoxFrame::GetXULBorderAndPadding(nsMargin& aBorderAndPadding)
 {
   aBorderAndPadding.SizeTo(0,0,0,0);
   return NS_OK;
 }
 
diff --git a/layout/xul/nsImageBoxFrame.cpp b/layout/xul/nsImageBoxFrame.cpp
--- a/layout/xul/nsImageBoxFrame.cpp
+++ b/layout/xul/nsImageBoxFrame.cpp
@@ -555,17 +555,17 @@ nsImageBoxFrame::GetXULPrefSize(nsBoxLay
   if (!mUseSrcAttr && (mSubRect.width > 0 || mSubRect.height > 0))
     size = mSubRect.Size();
   else
     size = mImageSize;
 
   nsSize intrinsicSize = size;
 
   nsMargin borderPadding(0,0,0,0);
-  GetBorderAndPadding(borderPadding);
+  GetXULBorderAndPadding(borderPadding);
   size.width += borderPadding.LeftRight();
   size.height += borderPadding.TopBottom();
 
   bool widthSet, heightSet;
   nsIFrame::AddCSSPrefSize(this, size, widthSet, heightSet);
   NS_ASSERTION(size.width != NS_INTRINSICSIZE && size.height != NS_INTRINSICSIZE,
                "non-intrinsic size expected");
 
diff --git a/layout/xul/nsLeafBoxFrame.cpp b/layout/xul/nsLeafBoxFrame.cpp
--- a/layout/xul/nsLeafBoxFrame.cpp
+++ b/layout/xul/nsLeafBoxFrame.cpp
@@ -131,19 +131,19 @@ nsLeafBoxFrame::GetMinISize(nsRenderingC
   nsBoxLayoutState state(PresContext(), aRenderingContext);
 
   WritingMode wm = GetWritingMode();
   LogicalSize minSize(wm, GetXULMinSize(state));
 
   // GetXULMinSize returns border-box size, and we want to return content
   // inline-size.  Since Reflow uses the reflow state's border and padding, we
   // actually just want to subtract what GetXULMinSize added, which is the
-  // result of GetBorderAndPadding.
+  // result of GetXULBorderAndPadding.
   nsMargin bp;
-  GetBorderAndPadding(bp);
+  GetXULBorderAndPadding(bp);
 
   result = minSize.ISize(wm) - LogicalMargin(wm, bp).IStartEnd(wm);
 
   return result;
 }
 
 /* virtual */ nscoord
 nsLeafBoxFrame::GetPrefISize(nsRenderingContext *aRenderingContext)
@@ -153,19 +153,19 @@ nsLeafBoxFrame::GetPrefISize(nsRendering
   nsBoxLayoutState state(PresContext(), aRenderingContext);
 
   WritingMode wm = GetWritingMode();
   LogicalSize prefSize(wm, GetXULPrefSize(state));
 
   // GetXULPrefSize returns border-box size, and we want to return content
   // inline-size.  Since Reflow uses the reflow state's border and padding, we
   // actually just want to subtract what GetXULPrefSize added, which is the
-  // result of GetBorderAndPadding.
+  // result of GetXULBorderAndPadding.
   nsMargin bp;
-  GetBorderAndPadding(bp);
+  GetXULBorderAndPadding(bp);
 
   result = prefSize.ISize(wm) - LogicalMargin(wm, bp).IStartEnd(wm);
 
   return result;
 }
 
 nscoord
 nsLeafBoxFrame::GetIntrinsicISize()
@@ -240,17 +240,17 @@ nsLeafBoxFrame::Reflow(nsPresContext*   
   // create the layout state
   nsBoxLayoutState state(aPresContext, aReflowState.rendContext);
 
   nsSize computedSize(aReflowState.ComputedWidth(),aReflowState.ComputedHeight());
 
   nsMargin m;
   m = aReflowState.ComputedPhysicalBorderPadding();
 
-  //GetBorderAndPadding(m);
+  //GetXULBorderAndPadding(m);
 
   // this happens sometimes. So lets handle it gracefully.
   if (aReflowState.ComputedHeight() == 0) {
     nsSize minSize = GetXULMinSize(state);
     computedSize.height = minSize.height - m.top - m.bottom;
   }
 
   nsSize prefSize(0,0);
diff --git a/layout/xul/nsMenuFrame.cpp b/layout/xul/nsMenuFrame.cpp
--- a/layout/xul/nsMenuFrame.cpp
+++ b/layout/xul/nsMenuFrame.cpp
@@ -1354,17 +1354,17 @@ nsMenuFrame::SizeToPopup(nsBoxLayoutStat
 
       // Produce a size such that:
       //  (1) the menu and its popup can be the same width
       //  (2) there's enough room in the menu for the content and its
       //      border-padding
       //  (3) there's enough room in the popup for the content and its
       //      scrollbar
       nsMargin borderPadding;
-      GetBorderAndPadding(borderPadding);
+      GetXULBorderAndPadding(borderPadding);
 
       // if there is a scroll frame, add the desired width of the scrollbar as well
       nsIScrollableFrame* scrollFrame = do_QueryFrame(popupFrame->PrincipalChildList().FirstChild());
       nscoord scrollbarWidth = 0;
       if (scrollFrame) {
         scrollbarWidth =
           scrollFrame->GetDesiredScrollbarSizes(&aState).LeftRight();
       }
diff --git a/layout/xul/nsSprocketLayout.cpp b/layout/xul/nsSprocketLayout.cpp
--- a/layout/xul/nsSprocketLayout.cpp
+++ b/layout/xul/nsSprocketLayout.cpp
@@ -590,17 +590,17 @@ nsSprocketLayout::XULLayout(nsIFrame* aB
     computedBoxSizes = computedBoxSizes->next;
     delete toDelete;
   }
 
   if (childResized) {
     // See if one of our children forced us to get bigger
     nsRect tmpClientRect(originalClientRect);
     nsMargin bp(0,0,0,0);
-    aBox->GetBorderAndPadding(bp);
+    aBox->GetXULBorderAndPadding(bp);
     tmpClientRect.Inflate(bp);
 
     if (tmpClientRect.width > originalSize.width || tmpClientRect.height > originalSize.height)
     {
       // if it did reset our bounds.
       nsRect bounds(aBox->GetRect());
       if (tmpClientRect.width > originalSize.width)
         bounds.width = tmpClientRect.width;
@@ -1528,17 +1528,17 @@ nsSprocketLayout::GetAscent(nsIFrame* aB
             vAscent = ascent;
         }
       //}
 
       child = nsBox::GetNextXULBox(child);      
    }
 
    nsMargin borderPadding;
-   aBox->GetBorderAndPadding(borderPadding);
+   aBox->GetXULBorderAndPadding(borderPadding);
 
    return vAscent + borderPadding.top;
 }
 
 void
 nsSprocketLayout::SetLargestSize(nsSize& aSize1, const nsSize& aSize2, bool aIsHorizontal)
 {
   if (aIsHorizontal)
diff --git a/layout/xul/nsStackLayout.cpp b/layout/xul/nsStackLayout.cpp
--- a/layout/xul/nsStackLayout.cpp
+++ b/layout/xul/nsStackLayout.cpp
@@ -362,17 +362,17 @@ nsStackLayout::XULLayout(nsIFrame* aBox,
        child = nsBox::GetNextXULBox(child);
      }
    } while (grow);
    
    // if some HTML inside us got bigger we need to force ourselves to
    // get bigger
    nsRect bounds(aBox->GetRect());
    nsMargin bp;
-   aBox->GetBorderAndPadding(bp);
+   aBox->GetXULBorderAndPadding(bp);
    clientRect.Inflate(bp);
 
    if (clientRect.width > bounds.width || clientRect.height > bounds.height)
    {
      if (clientRect.width > bounds.width)
        bounds.width = clientRect.width;
      if (clientRect.height > bounds.height)
        bounds.height = clientRect.height;
diff --git a/layout/xul/nsTextBoxFrame.cpp b/layout/xul/nsTextBoxFrame.cpp
--- a/layout/xul/nsTextBoxFrame.cpp
+++ b/layout/xul/nsTextBoxFrame.cpp
@@ -1057,17 +1057,17 @@ nsTextBoxFrame::CalcTextSize(nsBoxLayout
 
 void
 nsTextBoxFrame::CalcDrawRect(nsRenderingContext &aRenderingContext)
 {
     WritingMode wm = GetWritingMode();
 
     LogicalRect textRect(wm, LogicalPoint(wm, 0, 0), GetLogicalSize(wm));
     nsMargin borderPadding;
-    GetBorderAndPadding(borderPadding);
+    GetXULBorderAndPadding(borderPadding);
     textRect.Deflate(wm, LogicalMargin(wm, borderPadding));
 
     // determine (cropped) title and underline position
     // determine (cropped) title which fits in aRect, and its width
     // (where "width" is the text measure along its baseline, i.e. actually
     // a physical height in vertical writing modes)
     nscoord titleWidth =
         CalculateTitleForWidth(aRenderingContext, textRect.ISize(wm));
@@ -1152,17 +1152,17 @@ nsTextBoxFrame::GetXULMinSize(nsBoxLayou
 nscoord
 nsTextBoxFrame::GetXULBoxAscent(nsBoxLayoutState& aBoxLayoutState)
 {
     CalcTextSize(aBoxLayoutState);
 
     nscoord ascent = mAscent;
 
     nsMargin m(0,0,0,0);
-    GetBorderAndPadding(m);
+    GetXULBorderAndPadding(m);
 
     WritingMode wm = GetWritingMode();
     ascent += LogicalMargin(wm, m).BStart(wm);
 
     return ascent;
 }
 
 #ifdef DEBUG_FRAME_DUMP
