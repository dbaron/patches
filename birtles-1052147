# HG changeset patch
# User Brian Birtles <birtles@gmail.com>
# Date 1407825899 -32400
#      Tue Aug 12 15:44:59 2014 +0900
# Node ID 79d8759a6e60ee4050250f9f3c10b68463d09be1
# Parent  4266a283cc93c994e1faa74ea1b5f7cc2e187a48
Bug 1052147 - Initialize AnimationPlayer::mPlayState to running state

The assertion in nsTimeStamp::operator >= occasionally fails due to a null RHS
timestamp when called from AnimationPlayer::GetCurrentTimeDuration, which, in
turn, is called from AnimationPlayer::SetSource.

The issue appears to be that we're not explicitly initializing
AnimationPlayer.mPlayState. This value can be running (0) or paused (1) but we
only ever compare against the paused state (i.e. every other value is
effectively treated as running). So for compilers that don't initialize
integer member variables to 0 we'll occasionally end up in the paused state
but with mPauseStart not set to a valid (non-null) TimeStamp. This creates
an inconsistent state since we assume that when we're paused mPauseStart is
non-null, hence the assertion fails.

This gets tickled because, since bug 1040543, we call
AnimationPlayer::SetSource from nsAnimationManager::BuildAnimations *before* we
set mPlayState and mPauseStart.

This patch initializes mPlayState to the running state so we don't accidentally
end up in an inconsistent state.

It also removes some (now unnecessary) initialization of mPlayState and
mPauseStart from nsTransitionManager::ConsiderStartingTransition.

In future we could also consider reworking nsAnimationManager::BuildAnimations
so that we call SetSource on the new animation player *after* setting up its
play state. That may be more correct and would further avoid this problem but
may not be necessary since all this code is likely to change in the near future.

diff --git a/dom/animation/AnimationPlayer.h b/dom/animation/AnimationPlayer.h
--- a/dom/animation/AnimationPlayer.h
+++ b/dom/animation/AnimationPlayer.h
@@ -27,17 +27,18 @@ namespace dom {
 
 class AnimationPlayer MOZ_FINAL : public nsWrapperCache
 {
 protected:
   virtual ~AnimationPlayer() { }
 
 public:
   explicit AnimationPlayer(AnimationTimeline* aTimeline)
-    : mIsRunningOnCompositor(false)
+    : mPlayState(NS_STYLE_ANIMATION_PLAY_STATE_RUNNING)
+    , mIsRunningOnCompositor(false)
     , mTimeline(aTimeline)
   {
     SetIsDOMBinding();
   }
 
   NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(AnimationPlayer)
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(AnimationPlayer)
 
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -513,18 +513,16 @@ nsTransitionManager::ConsiderStartingTra
   segment.mFromValue = startValue;
   segment.mToValue = endValue;
   segment.mFromKey = 0;
   segment.mToKey = 1;
   segment.mTimingFunction.Init(tf);
 
   nsRefPtr<dom::AnimationPlayer> player = new dom::AnimationPlayer(timeline);
   player->mStartTime = timeline->GetCurrentTimeStamp();
-  player->mPlayState = NS_STYLE_ANIMATION_PLAY_STATE_RUNNING;
-  player->mPauseStart = TimeStamp();
   player->SetSource(pt);
 
   if (!aElementTransitions) {
     aElementTransitions =
       GetElementTransitions(aElement, aNewStyleContext->GetPseudoType(),
                             true);
     if (!aElementTransitions) {
       NS_WARNING("allocating CommonAnimationManager failed");
