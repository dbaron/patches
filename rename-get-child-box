From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsBox::GetChildBox to GetChildXULBox.  r?dholbert

Written purely with sed, over .h and .cpp files in layout/.

MozReview-Commit-ID: 61Fye82NdT4

diff --git a/layout/xul/ScrollBoxObject.cpp b/layout/xul/ScrollBoxObject.cpp
--- a/layout/xul/ScrollBoxObject.cpp
+++ b/layout/xul/ScrollBoxObject.cpp
@@ -87,17 +87,17 @@ static nsIFrame* GetScrolledBox(BoxObjec
   if (!scrollFrame) {
     NS_WARNING("ScrollBoxObject attached to something that's not a scroll frame!");
     return nullptr;
   }
 
   nsIFrame* scrolledFrame = scrollFrame->GetScrolledFrame();
   if (!scrolledFrame)
     return nullptr;
-  return nsBox::GetChildBox(scrolledFrame);
+  return nsBox::GetChildXULBox(scrolledFrame);
 }
 
 void ScrollBoxObject::ScrollByIndex(int32_t dindexes, ErrorResult& aRv)
 {
     nsIScrollableFrame* sf = GetScrollFrame();
     if (!sf) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
@@ -107,17 +107,17 @@ void ScrollBoxObject::ScrollByIndex(int3
     if (!scrolledBox) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
 
     nsRect rect;
 
     // now get the scrolled boxes first child.
-    nsIFrame* child = nsBox::GetChildBox(scrolledBox);
+    nsIFrame* child = nsBox::GetChildXULBox(scrolledBox);
 
     bool horiz = scrolledBox->IsHorizontal();
     nsPoint cp = sf->GetScrollPosition();
     nscoord diff = 0;
     int32_t curIndex = 0;
     bool isLTR = scrolledBox->IsNormalDirection();
 
     int32_t frameWidth = 0;
@@ -169,17 +169,17 @@ void ScrollBoxObject::ScrollByIndex(int3
         }
         count++;
         if (count >= dindexes) {
           break;
         }
       }
 
    } else if (dindexes < 0) {
-      child = nsBox::GetChildBox(scrolledBox);
+      child = nsBox::GetChildXULBox(scrolledBox);
       while(child) {
         rect = child->GetRect();
         if (count >= curIndex + dindexes) {
           break;
         }
 
         count++;
         child = nsBox::GetNextBox(child);
diff --git a/layout/xul/grid/nsGrid.cpp b/layout/xul/grid/nsGrid.cpp
--- a/layout/xul/grid/nsGrid.cpp
+++ b/layout/xul/grid/nsGrid.cpp
@@ -240,17 +240,17 @@ nsGrid::FindRowsAndColumns(nsIFrame** aR
 {
   *aRows = nullptr;
   *aColumns = nullptr;
 
   // find the boxes that contain our rows and columns
   nsIFrame* child = nullptr;
   // if we have <grid></grid> then mBox will be null (bug 125689)
   if (mBox)
-    child = nsBox::GetChildBox(mBox);
+    child = nsBox::GetChildXULBox(mBox);
 
   while(child)
   {
     nsIFrame* oldBox = child;
     nsIScrollableFrame *scrollFrame = do_QueryFrame(child);
     if (scrollFrame) {
        nsIFrame* scrolledFrame = scrollFrame->GetScrolledFrame();
        NS_ASSERTION(scrolledFrame,"Error no scroll frame!!");
@@ -392,17 +392,17 @@ nsGrid::PopulateCellMap(nsGridRow* aRows
      nsGridRow* row = &aRows[i];
 
      // skip bogus rows. They have no cells
      if (row->mIsBogus) 
        continue;
 
      child = row->mBox;
      if (child) {
-       child = nsBox::GetChildBox(child);
+       child = nsBox::GetChildXULBox(child);
 
        j = 0;
 
        while(child && j < aColumnCount)
        {
          // skip bogus column. They have no cells
          nsGridRow* column = &aColumns[j];
          if (column->mIsBogus) 
diff --git a/layout/xul/grid/nsGridRowGroupFrame.cpp b/layout/xul/grid/nsGridRowGroupFrame.cpp
--- a/layout/xul/grid/nsGridRowGroupFrame.cpp
+++ b/layout/xul/grid/nsGridRowGroupFrame.cpp
@@ -43,17 +43,17 @@ nsGridRowGroupFrame::GetXULFlex()
   if (!DoesNeedRecalc(mFlex))
      return mFlex;
 
   if (nsBoxFrame::GetXULFlex() == 0)
     return 0;
 
   // ok we are flexible add up our children
   nscoord totalFlex = 0;
-  nsIFrame* child = nsBox::GetChildBox(this);
+  nsIFrame* child = nsBox::GetChildXULBox(this);
   while (child)
   {
     totalFlex += child->GetXULFlex();
     child = GetNextBox(child);
   }
 
   mFlex = totalFlex;
 
diff --git a/layout/xul/grid/nsGridRowGroupLayout.cpp b/layout/xul/grid/nsGridRowGroupLayout.cpp
--- a/layout/xul/grid/nsGridRowGroupLayout.cpp
+++ b/layout/xul/grid/nsGridRowGroupLayout.cpp
@@ -152,17 +152,17 @@ void
 nsGridRowGroupLayout::DirtyRows(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   if (aBox) {
     // mark us dirty
     // XXXldb We probably don't want to walk up the ancestor chain
     // calling MarkIntrinsicISizesDirty for every row group.
     aState.PresShell()->FrameNeedsReflow(aBox, nsIPresShell::eTreeChange,
                                          NS_FRAME_IS_DIRTY);
-    nsIFrame* child = nsBox::GetChildBox(aBox);
+    nsIFrame* child = nsBox::GetChildXULBox(aBox);
 
     while(child) {
 
       // walk into scrollframes
       nsIFrame* deepChild = nsGrid::GetScrolledBox(child);
 
       // walk into other monuments
       nsIGridPart* monument = nsGrid::GetPartFromBox(deepChild);
@@ -176,17 +176,17 @@ nsGridRowGroupLayout::DirtyRows(nsIFrame
 
 
 void
 nsGridRowGroupLayout::CountRowsColumns(nsIFrame* aBox, int32_t& aRowCount, int32_t& aComputedColumnCount)
 {
   if (aBox) {
     int32_t startCount = aRowCount;
 
-    nsIFrame* child = nsBox::GetChildBox(aBox);
+    nsIFrame* child = nsBox::GetChildXULBox(aBox);
 
     while(child) {
       
       // first see if it is a scrollframe. If so walk down into it and get the scrolled child
       nsIFrame* deepChild = nsGrid::GetScrolledBox(child);
 
       nsIGridPart* monument = nsGrid::GetPartFromBox(deepChild);
       if (monument) {
@@ -211,17 +211,17 @@ nsGridRowGroupLayout::CountRowsColumns(n
  * Fill out the given row structure recursively
  */
 int32_t 
 nsGridRowGroupLayout::BuildRows(nsIFrame* aBox, nsGridRow* aRows)
 { 
   int32_t rowCount = 0;
 
   if (aBox) {
-    nsIFrame* child = nsBox::GetChildBox(aBox);
+    nsIFrame* child = nsBox::GetChildXULBox(aBox);
 
     while(child) {
       
       // first see if it is a scrollframe. If so walk down into it and get the scrolled child
       nsIFrame* deepChild = nsGrid::GetScrolledBox(child);
 
       nsIGridPart* monument = nsGrid::GetPartFromBox(deepChild);
       if (monument) {
diff --git a/layout/xul/grid/nsGridRowLayout.cpp b/layout/xul/grid/nsGridRowLayout.cpp
--- a/layout/xul/grid/nsGridRowLayout.cpp
+++ b/layout/xul/grid/nsGridRowLayout.cpp
@@ -88,17 +88,17 @@ nsGridRowLayout::GetGrid(nsIFrame* aBox,
       nsIFrame* parentBox; // nsIFrame is implemented by nsIFrame and is not refcounted.
       nsIGridPart* parent = GetParentGridPart(aBox, &parentBox);
       if (parent)
          return parent->GetGrid(parentBox, aIndex, this);
       return nullptr;
    }
 
    int32_t index = -1;
-   nsIFrame* child = nsBox::GetChildBox(aBox);
+   nsIFrame* child = nsBox::GetChildXULBox(aBox);
    int32_t count = 0;
    while(child)
    {
      // if there is a scrollframe walk inside it to its child
      nsIFrame* childBox = nsGrid::GetScrolledBox(child);
 
      nsBoxLayout* layout = childBox->GetLayoutManager();
      nsIGridPart* gridRow = nsGrid::GetPartFromBox(childBox);
@@ -145,17 +145,17 @@ nsGridRowLayout::GetTotalMargin(nsIFrame
 
     // make sure we check for a scrollbox
     aBox = nsGrid::GetScrollBox(aBox);
 
     // see if we have a next to see if we are last
     nsIFrame* next = nsBox::GetNextBox(aBox);
 
     // get the parent first child to see if we are first
-    nsIFrame* child = nsBox::GetChildBox(parent);
+    nsIFrame* child = nsBox::GetChildXULBox(parent);
 
     margin = part->GetTotalMargin(parent, aIsHorizontal);
 
     // if first or last
     if (child == aBox || next == nullptr) {
 
        // if it's not the first child remove the top margin
        // we don't need it.
diff --git a/layout/xul/grid/nsGridRowLeafLayout.cpp b/layout/xul/grid/nsGridRowLeafLayout.cpp
--- a/layout/xul/grid/nsGridRowLeafLayout.cpp
+++ b/layout/xul/grid/nsGridRowLeafLayout.cpp
@@ -109,17 +109,17 @@ nsGridRowLeafLayout::PopulateBoxSizes(ns
   // If we are a row lets change the sizes to match our columns. If we are a column then do the opposite
   // and make them match or rows.
   if (grid) {
     nsGridRow* column;
     int32_t count = grid->GetColumnCount(isHorizontal); 
     nsBoxSize* start = nullptr;
     nsBoxSize* last = nullptr;
     nsBoxSize* current = nullptr;
-    nsIFrame* child = nsBox::GetChildBox(aBox);
+    nsIFrame* child = nsBox::GetChildXULBox(aBox);
     for (int i=0; i < count; i++)
     {
       column = grid->GetColumnAt(i,isHorizontal); 
 
       // make sure the value was computed before we use it.
       // !isHorizontal is passed in to invert the behavior of these methods.
       nscoord pref =
         grid->GetPrefRowHeight(aState, i, !isHorizontal); // GetPrefColumnWidth
@@ -293,17 +293,17 @@ nsGridRowLeafLayout::DirtyRows(nsIFrame*
                                          NS_FRAME_IS_DIRTY);
   }
 }
 
 void
 nsGridRowLeafLayout::CountRowsColumns(nsIFrame* aBox, int32_t& aRowCount, int32_t& aComputedColumnCount)
 {
   if (aBox) {
-    nsIFrame* child = nsBox::GetChildBox(aBox);
+    nsIFrame* child = nsBox::GetChildXULBox(aBox);
 
     // count the children
     int32_t columnCount = 0;
     while(child) {
       child = nsBox::GetNextBox(child);
       columnCount++;
     }
 
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -133,17 +133,17 @@ nsBox::BeginLayout(nsBoxLayoutState& aSt
   // XXXldb Is this still needed?
   mState |= NS_FRAME_HAS_DIRTY_CHILDREN;
 
   if (GetStateBits() & NS_FRAME_IS_DIRTY)
   {
     // If the parent is dirty, all the children are dirty (nsHTMLReflowState
     // does this too).
     nsIFrame* box;
-    for (box = GetChildBox(this); box; box = GetNextBox(box))
+    for (box = GetChildXULBox(this); box; box = GetNextBox(box))
       box->AddStateBits(NS_FRAME_IS_DIRTY);
   }
 
   // Another copy-over from nsHTMLReflowState.
   // Since we are in reflow, we don't need to store these properties anymore.
   FrameProperties props = Properties();
   props.Delete(UsedBorderProperty());
   props.Delete(UsedPaddingProperty());
@@ -917,17 +917,17 @@ nsBox::BoundsCheckMinMax(const nsSize& a
 nsSize
 nsBox::BoundsCheck(const nsSize& aMinSize, const nsSize& aPrefSize, const nsSize& aMaxSize)
 {
   return nsSize(BoundsCheck(aMinSize.width, aPrefSize.width, aMaxSize.width),
                 BoundsCheck(aMinSize.height, aPrefSize.height, aMaxSize.height));
 }
 
 /*static*/ nsIFrame*
-nsBox::GetChildBox(const nsIFrame* aFrame)
+nsBox::GetChildXULBox(const nsIFrame* aFrame)
 {
   // box layout ends at box-wrapped frames, so don't allow these frames
   // to report child boxes.
   return aFrame->IsXULBoxFrame() ? aFrame->PrincipalChildList().FirstChild() : nullptr;
 }
 
 /*static*/ nsIFrame*
 nsBox::GetNextBox(const nsIFrame* aFrame)
@@ -953,17 +953,17 @@ nsBox::SetDebug(nsBoxLayoutState& aState
 NS_IMETHODIMP
 nsBox::GetDebugBoxAt( const nsPoint& aPoint,
                       nsIFrame**     aBox)
 {
   nsRect thisRect(nsPoint(0,0), GetSize());
   if (!thisRect.Contains(aPoint))
     return NS_ERROR_FAILURE;
 
-  nsIFrame* child = nsBox::GetChildBox(this);
+  nsIFrame* child = nsBox::GetChildXULBox(this);
   nsIFrame* hit = nullptr;
 
   *aBox = nullptr;
   while (nullptr != child) {
     nsresult rv = child->GetDebugBoxAt(aPoint - child->GetOffsetTo(this), &hit);
 
     if (NS_SUCCEEDED(rv) && hit) {
       *aBox = hit;
diff --git a/layout/xul/nsBox.h b/layout/xul/nsBox.h
--- a/layout/xul/nsBox.h
+++ b/layout/xul/nsBox.h
@@ -72,17 +72,17 @@ rollbox.
   static void AddBorderAndPadding(nsIFrame* aBox, nsSize& aSize);
   static void AddMargin(nsIFrame* aChild, nsSize& aSize);
   static void AddMargin(nsSize& aSize, const nsMargin& aMargin);
 
   static nsSize BoundsCheckMinMax(const nsSize& aMinSize, const nsSize& aMaxSize);
   static nsSize BoundsCheck(const nsSize& aMinSize, const nsSize& aPrefSize, const nsSize& aMaxSize);
   static nscoord BoundsCheck(nscoord aMinSize, nscoord aPrefSize, nscoord aMaxSize);
 
-  static nsIFrame* GetChildBox(const nsIFrame* aFrame);
+  static nsIFrame* GetChildXULBox(const nsIFrame* aFrame);
   static nsIFrame* GetNextBox(const nsIFrame* aFrame);
   static nsIFrame* GetParentBox(const nsIFrame* aFrame);
 
 protected:
 
 #ifdef DEBUG_LAYOUT
   virtual void AppendAttribute(const nsAutoString& aAttribute, const nsAutoString& aValue, nsAutoString& aResult);
 
diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -1470,17 +1470,17 @@ nsBoxFrame::PaintXULDebugOverlay(DrawTar
 
   nsRect inner(mRect);
   inner.MoveTo(aPt);
   inner.Deflate(debugMargin);
   inner.Deflate(border);
 
   nscoord onePixel = GetPresContext()->IntScaledPixelsToTwips(1);
 
-  kid = nsBox::GetChildBox(this);
+  kid = nsBox::GetChildXULBox(this);
   while (nullptr != kid) {
     bool isHorizontal = IsHorizontal();
 
     nscoord x, y, borderSize, spacerSize;
     
     nsRect cr(kid->mRect);
     nsMargin margin;
     kid->GetMargin(margin);
@@ -1729,17 +1729,17 @@ nsBoxFrame::DisplayDebugInfoFor(nsIFrame
     bool isHorizontal = IsHorizontal();
 
     if (!insideBorder.Contains(nsPoint(x,y)))
         return NS_ERROR_FAILURE;
 
     //printf("%%%%%% inside box %%%%%%%\n");
 
     int count = 0;
-    nsIFrame* child = nsBox::GetChildBox(aBox);
+    nsIFrame* child = nsBox::GetChildXULBox(aBox);
 
     nsMargin m;
     nsMargin m2;
     GetDebugBorder(m);
     PixelMarginToTwips(m);
 
     GetDebugMargin(m2);
     PixelMarginToTwips(m2);
@@ -1832,17 +1832,17 @@ nsBoxFrame::DisplayDebugInfoFor(nsIFrame
     mDebugChild = nullptr;
 
     return NS_OK;
 }
 
 void
 nsBoxFrame::SetDebugOnChildList(nsBoxLayoutState& aState, nsIFrame* aChild, bool aDebug)
 {
-    nsIFrame* child = nsBox::GetChildBox(this);
+    nsIFrame* child = nsBox::GetChildXULBox(this);
      while (child)
      {
         child->SetDebug(aState, aDebug);
         child = GetNextBox(child);
      }
 }
 
 nsresult
diff --git a/layout/xul/nsDeckFrame.cpp b/layout/xul/nsDeckFrame.cpp
--- a/layout/xul/nsDeckFrame.cpp
+++ b/layout/xul/nsDeckFrame.cpp
@@ -206,17 +206,17 @@ nsDeckFrame::DoLayout(nsBoxLayoutState& 
   // We will do that.
   uint32_t oldFlags = aState.LayoutFlags();
   aState.SetLayoutFlags(NS_FRAME_NO_SIZE_VIEW | NS_FRAME_NO_VISIBILITY);
 
   // do a normal layout
   nsresult rv = nsBoxFrame::DoLayout(aState);
 
   // run though each child. Hide all but the selected one
-  nsIFrame* box = nsBox::GetChildBox(this);
+  nsIFrame* box = nsBox::GetChildXULBox(this);
 
   nscoord count = 0;
   while (box) 
   {
     // make collapsed children not show up
     if (count != mIndex) 
       HideBox(box);
 
diff --git a/layout/xul/nsGroupBoxFrame.cpp b/layout/xul/nsGroupBoxFrame.cpp
--- a/layout/xul/nsGroupBoxFrame.cpp
+++ b/layout/xul/nsGroupBoxFrame.cpp
@@ -251,31 +251,31 @@ nsGroupBoxFrame::PaintBorderBackground(n
 
   return result;
 }
 
 nsIFrame*
 nsGroupBoxFrame::GetCaptionBox(nsRect& aCaptionRect)
 {
     // first child is our grouped area
-    nsIFrame* box = nsBox::GetChildBox(this);
+    nsIFrame* box = nsBox::GetChildXULBox(this);
 
     // no area fail.
     if (!box)
       return nullptr;
 
     // get the first child in the grouped area, that is the caption
-    box = nsBox::GetChildBox(box);
+    box = nsBox::GetChildXULBox(box);
 
     // nothing in the area? fail
     if (!box)
       return nullptr;
 
     // now get the caption itself. It is in the caption frame.
-    nsIFrame* child = nsBox::GetChildBox(box);
+    nsIFrame* child = nsBox::GetChildXULBox(box);
 
     if (child) {
        // convert to our coordinates.
        nsRect parentRect(box->GetRect());
        aCaptionRect = child->GetRect();
        aCaptionRect.x += parentRect.x;
        aCaptionRect.y += parentRect.y;
     }
diff --git a/layout/xul/nsListBoxLayout.cpp b/layout/xul/nsListBoxLayout.cpp
--- a/layout/xul/nsListBoxLayout.cpp
+++ b/layout/xul/nsListBoxLayout.cpp
@@ -131,17 +131,17 @@ nsListBoxLayout::LayoutInternal(nsIFrame
     bool fixed = (body->GetFixedRowSize() != -1);
     if (fixed)
       availableHeight = 10;
     else
       return NS_OK;
   }
 
   // run through all our currently created children
-  nsIFrame* box = nsBox::GetChildBox(body);
+  nsIFrame* box = nsBox::GetChildXULBox(body);
 
   // if the reason is resize or initial we must relayout.
   nscoord rowHeight = body->GetRowHeightAppUnits();
 
   while (box) {
     // If this box is dirty or if it has dirty children, we
     // call layout on it.
     nsRect childRect(box->GetRect());
diff --git a/layout/xul/nsMenuPopupFrame.cpp b/layout/xul/nsMenuPopupFrame.cpp
--- a/layout/xul/nsMenuPopupFrame.cpp
+++ b/layout/xul/nsMenuPopupFrame.cpp
@@ -440,17 +440,17 @@ nsMenuPopupFrame::LayoutPopup(nsBoxLayou
     if (!shouldPosition && !aSizedToPopup) {
       RemoveStateBits(NS_FRAME_FIRST_REFLOW);
       return;
     }
   }
 
   // if the popup has just been opened, make sure the scrolled window is at 0,0
   if (mIsOpenChanged) {
-    nsIScrollableFrame *scrollframe = do_QueryFrame(nsBox::GetChildBox(this));
+    nsIScrollableFrame *scrollframe = do_QueryFrame(nsBox::GetChildXULBox(this));
     if (scrollframe) {
       nsWeakFrame weakFrame(this);
       scrollframe->ScrollTo(nsPoint(0,0), nsIScrollableFrame::INSTANT);
       if (!weakFrame.IsAlive()) {
         return;
       }
     }
   }
diff --git a/layout/xul/nsSliderFrame.cpp b/layout/xul/nsSliderFrame.cpp
--- a/layout/xul/nsSliderFrame.cpp
+++ b/layout/xul/nsSliderFrame.cpp
@@ -327,17 +327,17 @@ nsSliderFrame::BuildDisplayList(nsDispla
 }
 
 void
 nsSliderFrame::BuildDisplayListForChildren(nsDisplayListBuilder*   aBuilder,
                                            const nsRect&           aDirtyRect,
                                            const nsDisplayListSet& aLists)
 {
   // if we are too small to have a thumb don't paint it.
-  nsIFrame* thumb = nsBox::GetChildBox(this);
+  nsIFrame* thumb = nsBox::GetChildXULBox(this);
 
   if (thumb) {
     nsRect thumbRect(thumb->GetRect());
     nsMargin m;
     thumb->GetMargin(m);
     thumbRect.Inflate(m);
 
     nsRect crect;
@@ -385,17 +385,17 @@ nsSliderFrame::BuildDisplayListForChildr
   
   nsBoxFrame::BuildDisplayListForChildren(aBuilder, aDirtyRect, aLists);
 }
 
 NS_IMETHODIMP
 nsSliderFrame::DoLayout(nsBoxLayoutState& aState)
 {
   // get the thumb should be our only child
-  nsIFrame* thumbBox = nsBox::GetChildBox(this);
+  nsIFrame* thumbBox = nsBox::GetChildXULBox(this);
 
   if (!thumbBox) {
     SyncLayout(aState);
     return NS_OK;
   }
 
   EnsureOrient();
 
diff --git a/layout/xul/nsSplitterFrame.cpp b/layout/xul/nsSplitterFrame.cpp
--- a/layout/xul/nsSplitterFrame.cpp
+++ b/layout/xul/nsSplitterFrame.cpp
@@ -652,17 +652,17 @@ nsSplitterFrameInner::MouseDown(nsIDOMEv
   mChildInfosBefore = MakeUnique<nsSplitterInfo[]>(childCount);
   mChildInfosAfter  = MakeUnique<nsSplitterInfo[]>(childCount);
 
   // create info 2 lists. One of the children before us and one after.
   int32_t count = 0;
   mChildInfosBeforeCount = 0;
   mChildInfosAfterCount = 0;
 
-  nsIFrame* childBox = nsBox::GetChildBox(mParentBox);
+  nsIFrame* childBox = nsBox::GetChildXULBox(mParentBox);
 
   while (nullptr != childBox) 
   { 
     nsIContent* content = childBox->GetContent();
     nsIDocument* doc = content->OwnerDoc();
     int32_t dummy;
     nsIAtom* atom = doc->BindingManager()->ResolveTag(content, &dummy);
 
@@ -892,17 +892,17 @@ nsSplitterFrameInner::AdjustChildren(nsP
   AdjustChildren(aPresContext, mChildInfosBefore.get(),
                  mChildInfosBeforeCount, isHorizontal);
   AdjustChildren(aPresContext, mChildInfosAfter.get(),
                  mChildInfosAfterCount, isHorizontal);
 }
 
 static nsIFrame* GetChildBoxForContent(nsIFrame* aParentBox, nsIContent* aContent)
 {
-  nsIFrame* childBox = nsBox::GetChildBox(aParentBox);
+  nsIFrame* childBox = nsBox::GetChildXULBox(aParentBox);
 
   while (nullptr != childBox) {
     if (childBox->GetContent() == aContent) {
       return childBox;
     }
     childBox = nsBox::GetNextBox(childBox);
   }
   return nullptr;
@@ -913,17 +913,17 @@ nsSplitterFrameInner::AdjustChildren(nsP
 {
   ///printf("------- AdjustChildren------\n");
 
   nsBoxLayoutState state(aPresContext);
 
   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
 
   // first set all the widths.
-  nsIFrame* child =  nsBox::GetChildBox(mOuter);
+  nsIFrame* child =  nsBox::GetChildXULBox(mOuter);
   while(child)
   {
     SetPreferredSize(state, child, onePixel, aIsHorizontal, nullptr);
     child = nsBox::GetNextBox(child);
   }
 
   // now set our changed widths.
   for (int i=0; i < aCount; i++) 
diff --git a/layout/xul/nsSprocketLayout.cpp b/layout/xul/nsSprocketLayout.cpp
--- a/layout/xul/nsSprocketLayout.cpp
+++ b/layout/xul/nsSprocketLayout.cpp
@@ -168,17 +168,17 @@ HandleBoxPack(nsIFrame* aBox, const nsFr
 }
 
 NS_IMETHODIMP
 nsSprocketLayout::XULLayout(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   // See if we are collapsed. If we are, then simply iterate over all our
   // children and give them a rect of 0 width and height.
   if (aBox->IsXULCollapsed()) {
-    nsIFrame* child = nsBox::GetChildBox(aBox);
+    nsIFrame* child = nsBox::GetChildXULBox(aBox);
     while(child) 
     {
       nsBoxFrame::LayoutChildAt(aState, child, nsRect(0,0,0,0));  
       child = nsBox::GetNextBox(child);
     }
     return NS_OK;
   }
 
@@ -294,17 +294,17 @@ nsSprocketLayout::XULLayout(nsIFrame* aB
     origY = y;
 
     // Now we iterate over our box children and our box size lists in 
     // parallel.  For each child, we look at its sizes and figure out
     // where to place it.
     nsComputedBoxSize* childComputedBoxSize = computedBoxSizes;
     nsBoxSize* childBoxSize                 = boxSizes;
 
-    nsIFrame* child = nsBox::GetChildBox(aBox);
+    nsIFrame* child = nsBox::GetChildXULBox(aBox);
 
     int32_t count = 0;
     while (child || (childBoxSize && childBoxSize->bogus))
     { 
       // If for some reason, our lists are not the same length, we guard
       // by bailing out of the loop.
       if (childBoxSize == nullptr) {
         NS_NOTREACHED("Lists not the same length.");
@@ -615,17 +615,17 @@ nsSprocketLayout::XULLayout(nsIFrame* aB
   // Because our size grew, we now have to readjust because of box packing.  Repack
   // in order to update our x and y to the correct values.
   HandleBoxPack(aBox, frameState, x, y, originalClientRect, clientRect);
 
   // Compare against our original x and y and only worry about adjusting the children if
   // we really did have to change the positions because of packing (typically for 'center'
   // or 'end' pack values).
   if (x != origX || y != origY) {
-    nsIFrame* child = nsBox::GetChildBox(aBox);
+    nsIFrame* child = nsBox::GetChildXULBox(aBox);
 
     // reposition all our children
     while (child) 
     {
       nsRect childRect(child->GetRect());
       childRect.x += (x - origX);
       childRect.y += (y - origY);
       child->SetXULBounds(aState, childRect);
@@ -672,17 +672,17 @@ nsSprocketLayout::PopulateBoxSizes(nsIFr
   // then it does not matter what its preferred size is
   // there is nothing to flex it relative. This is great
   // because we can avoid asking for a preferred size in this
   // case. Why is this good? Well you might have html inside it
   // and asking html for its preferred size is rather expensive.
   // so we can just optimize it out this way.
 
   // set flexes
-  nsIFrame* child = nsBox::GetChildBox(aBox);
+  nsIFrame* child = nsBox::GetChildXULBox(aBox);
 
   aFlexes = 0;
   nsBoxSize* currentBox = nullptr;
 
 #if 0
   nsBoxSize* start = aBoxSizes;
   
   while(child)
@@ -714,17 +714,17 @@ nsSprocketLayout::PopulateBoxSizes(nsIFr
     if (flex > 0) 
        aFlexes++;
    
     child = GetNextBox(child);
   }
 #endif
 
   // get pref, min, max
-  child = nsBox::GetChildBox(aBox);
+  child = nsBox::GetChildXULBox(aBox);
   currentBox = aBoxSizes;
   nsBoxSize* last = nullptr;
 
   nscoord maxFlex = 0;
   int32_t childCount = 0;
 
   while(child)
   {
@@ -940,17 +940,17 @@ nsSprocketLayout::AlignChildren(nsIFrame
     if (valign == nsBoxFrame::vAlign_BaseLine) {
       maxAscent = aBox->GetXULBoxAscent(aState);
     }
   } else {
     isLTR = GetFrameDirection(aBox) == NS_STYLE_DIRECTION_LTR;
     halign = aBox->GetHAlign();
   }
 
-  nsIFrame* child = nsBox::GetChildBox(aBox);
+  nsIFrame* child = nsBox::GetChildXULBox(aBox);
   while (child) {
 
     nsMargin margin;
     child->GetMargin(margin);
     nsRect childRect = child->GetRect();
 
     if (isHorizontal) {
       const nscoord startAlign = clientRect.y + margin.top;
@@ -1309,17 +1309,17 @@ nsSprocketLayout::GetXULPrefSize(nsIFram
    nsSize vpref (0, 0); 
    bool isHorizontal = IsHorizontal(aBox);
 
    nscoord biggestPref = 0;
 
    // run through all the children and get their min, max, and preferred sizes
    // return us the size of the box
 
-   nsIFrame* child = nsBox::GetChildBox(aBox);
+   nsIFrame* child = nsBox::GetChildXULBox(aBox);
    nsFrameState frameState = nsFrameState(0);
    GetFrameState(aBox, frameState);
    bool isEqual = !!(frameState & NS_STATE_EQUAL_SIZE);
    int32_t count = 0;
    
    while (child) 
    {  
       // ignore collapsed children
@@ -1366,17 +1366,17 @@ nsSprocketLayout::GetXULMinSize(nsIFrame
    bool isHorizontal = IsHorizontal(aBox);
 
    nscoord biggestMin = 0;
 
 
    // run through all the children and get their min, max, and preferred sizes
    // return us the size of the box
 
-   nsIFrame* child = nsBox::GetChildBox(aBox);
+   nsIFrame* child = nsBox::GetChildXULBox(aBox);
    nsFrameState frameState = nsFrameState(0);
    GetFrameState(aBox, frameState);
    bool isEqual = !!(frameState & NS_STATE_EQUAL_SIZE);
    int32_t count = 0;
 
    while (child) 
    {  
        // ignore collapsed children
@@ -1435,17 +1435,17 @@ nsSprocketLayout::GetXULMaxSize(nsIFrame
   bool isHorizontal = IsHorizontal(aBox);
 
    nscoord smallestMax = NS_INTRINSICSIZE;
    nsSize maxSize (NS_INTRINSICSIZE, NS_INTRINSICSIZE);
 
    // run through all the children and get their min, max, and preferred sizes
    // return us the size of the box
 
-   nsIFrame* child = nsBox::GetChildBox(aBox);
+   nsIFrame* child = nsBox::GetChildXULBox(aBox);
    nsFrameState frameState = nsFrameState(0);
    GetFrameState(aBox, frameState);
    bool isEqual = !!(frameState & NS_STATE_EQUAL_SIZE);
    int32_t count = 0;
 
    while (child) 
    {  
       // ignore collapsed children
@@ -1500,17 +1500,17 @@ nsSprocketLayout::GetAscent(nsIFrame* aB
 {
    nscoord vAscent = 0;
 
    bool isHorizontal = IsHorizontal(aBox);
 
    // run through all the children and get their min, max, and preferred sizes
    // return us the size of the box
    
-   nsIFrame* child = nsBox::GetChildBox(aBox);
+   nsIFrame* child = nsBox::GetChildXULBox(aBox);
    
    while (child) 
    {  
       // ignore collapsed children
       //if (!child->IsXULCollapsed())
       //{
         // if completely redefined don't even ask our child for its size.
         nscoord ascent = child->GetXULBoxAscent(aState);
diff --git a/layout/xul/nsStackLayout.cpp b/layout/xul/nsStackLayout.cpp
--- a/layout/xul/nsStackLayout.cpp
+++ b/layout/xul/nsStackLayout.cpp
@@ -58,17 +58,17 @@ nsStackLayout::nsStackLayout()
  * (the default) will be included in the size computations.
  */
 
 nsSize
 nsStackLayout::GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   nsSize prefSize (0, 0);
 
-  nsIFrame* child = nsBox::GetChildBox(aBox);
+  nsIFrame* child = nsBox::GetChildXULBox(aBox);
   while (child) {
     if (child->StyleXUL()->mStretchStack) {
       nsSize pref = child->GetXULPrefSize(aState);
 
       AddMargin(child, pref);
       nsMargin offset;
       GetOffset(child, offset);
       pref.width += offset.LeftRight();
@@ -84,17 +84,17 @@ nsStackLayout::GetXULPrefSize(nsIFrame* 
   return prefSize;
 }
 
 nsSize
 nsStackLayout::GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   nsSize minSize (0, 0);
 
-  nsIFrame* child = nsBox::GetChildBox(aBox);
+  nsIFrame* child = nsBox::GetChildXULBox(aBox);
   while (child) {
     if (child->StyleXUL()->mStretchStack) {
       nsSize min = child->GetXULMinSize(aState);
 
       AddMargin(child, min);
       nsMargin offset;
       GetOffset(child, offset);
       min.width += offset.LeftRight();
@@ -110,17 +110,17 @@ nsStackLayout::GetXULMinSize(nsIFrame* a
   return minSize;
 }
 
 nsSize
 nsStackLayout::GetXULMaxSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   nsSize maxSize (NS_INTRINSICSIZE, NS_INTRINSICSIZE);
 
-  nsIFrame* child = nsBox::GetChildBox(aBox);
+  nsIFrame* child = nsBox::GetChildXULBox(aBox);
   while (child) {
     if (child->StyleXUL()->mStretchStack) {
       nsSize min = child->GetXULMinSize(aState);
       nsSize max = child->GetXULMaxSize(aState);
 
       max = nsBox::BoundsCheckMinMax(min, max);
 
       AddMargin(child, max);
@@ -140,17 +140,17 @@ nsStackLayout::GetXULMaxSize(nsIFrame* a
 }
 
 
 nscoord
 nsStackLayout::GetAscent(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   nscoord vAscent = 0;
 
-  nsIFrame* child = nsBox::GetChildBox(aBox);
+  nsIFrame* child = nsBox::GetChildXULBox(aBox);
   while (child) {  
     nscoord ascent = child->GetXULBoxAscent(aState);
     nsMargin margin;
     child->GetMargin(margin);
     ascent += margin.top;
     if (ascent > vAscent)
       vAscent = ascent;
 
@@ -255,17 +255,17 @@ NS_IMETHODIMP
 nsStackLayout::XULLayout(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   nsRect clientRect;
   aBox->GetClientRect(clientRect);
 
   bool grow;
 
   do {
-    nsIFrame* child = nsBox::GetChildBox(aBox);
+    nsIFrame* child = nsBox::GetChildXULBox(aBox);
     grow = false;
 
     while (child) 
     {  
       nsMargin margin;
       child->GetMargin(margin);
       nsRect childRect(clientRect);
       childRect.Deflate(margin);
