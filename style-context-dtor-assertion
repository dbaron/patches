From: L. David Baron <dbaron@dbaron.org>

Bug 1060194 - Add assertion in destructor of style contexts that should have been destroyed earlier.

diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -79,16 +79,21 @@ nsStyleContext::nsStyleContext(nsStyleCo
   #undef eStyleStruct_LastItem
 }
 
 nsStyleContext::~nsStyleContext()
 {
   NS_ASSERTION((nullptr == mChild) && (nullptr == mEmptyChild), "destructing context with children");
 
   nsPresContext *presContext = mRuleNode->PresContext();
+  nsStyleSet* styleSet = presContext->PresShell()->StyleSet();
+
+  NS_ASSERTION(styleSet->GetRuleTree() == mRuleNode->RuleTree() ||
+               styleSet->IsInRuleTreeReconstruct(),
+               "destroying style context from old rule tree too late");
 
 #ifdef DEBUG
 #if 0
   // Assert that the style structs we are about to destroy are not referenced
   // anywhere else in the style context tree.  These checks are expensive,
   // which is why they are not enabled even #ifdef DEBUG.
   nsStyleContext* root = this;
   while (root->mParent) {
@@ -100,18 +105,17 @@ nsStyleContext::~nsStyleContext()
   // In DEBUG builds we perform a more limited check just of the children
   // of this style context.
   AssertStructsNotUsedElsewhere(this, 2);
 #endif
 #endif
 
   mRuleNode->Release();
 
-  presContext->PresShell()->StyleSet()->
-    NotifyStyleContextDestroyed(presContext, this);
+  styleSet->NotifyStyleContextDestroyed(presContext, this);
 
   if (mParent) {
     mParent->RemoveChild(this);
     mParent->Release();
   }
 
   // Free up our data structs.
   mCachedInheritedData.DestroyStructs(mBits, presContext);
