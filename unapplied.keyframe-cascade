From: L. David Baron <dbaron@dbaron.org>

Instead of ignoring entire rules when keyframe rules have the same selectors, cascade and only ignore one property when that property is overridden.

diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -686,27 +686,44 @@ nsAnimationManager::BuildAnimations(nsSt
     keyframes.EnumerateRead(AppendKeyframeData, &sortedKeyframes);
     sortedKeyframes.Sort(KeyframeDataComparator());
 
     if (sortedKeyframes.Length() == 0) {
       // no segments
       continue;
     }
 
-    // In the first loop through the keyframes rules, record the
-    // properties that are present in any of them.
+    // Record the properties that are present in any keyframe rules we
+    // are using.
     nsCSSPropertySet properties;
-
-    for (XXX) {
-      css::Declaration *decl = kfRule->Declaration();
+    for (PRUint32 j = 1, j_end = sortedKeyframes.Length(); j != j_end; ++j) {
+      css::Declaration *decl = sortedKeyframes[j].mRule->Declaration();
       for (PRUint32 k = 0, k_end = decl->Count(); k != k_end; ++k) {
         properties.AddProperty(decl->OrderValueAt(k));
       }
     }
 
+    for (nsCSSProperty prop = nsCSSProperty(0);
+         prop < eCSSProperty_COUNT_no_shorthands;
+         prop = nsCSSProperty(prop + 1)) {
+      if (!properties.HasProperty(prop) ||
+          nsCSSProps::kAnimTypeTable[prop] == eStyleAnimType_None) {
+        continue;
+      }
+
+
+    }
+
+
+    if (!(aFromDeclaration && aFromDeclaration->HasProperty(prop)) &&
+        !(aToDeclaration && aToDeclaration->HasProperty(prop))) {
+      // Don't store an animation if neither declaration has the property.
+      continue;
+    }
+
     KeyframeData fromKeyframe = sortedKeyframes[0];
     nsRefPtr<nsStyleContext> fromContext =
       resolvedStyles.Get(mPresContext, aStyleContext,
                          fromKeyframe.mRule);
 
     // If there's no rule for 0%, there's implicitly an empty rule.
     if (fromKeyframe.mKey != 0.0f) {
       BuildSegment(aDest.mSegments, aSrc,
@@ -736,62 +753,49 @@ nsAnimationManager::BuildAnimations(nsSt
                    fromKeyframe.mKey, fromContext,
                    fromKeyframe.mRule->Declaration(),
                    1.0f, aStyleContext, nsnull);
     }
   }
 }
 
 void
-nsAnimationManager::BuildSegment(InfallibleTArray<AnimationSegment>& aSegments,
+nsAnimationManager::BuildSegment(InfallibleTArray<AnimationPropertySegment>&
+                                   aSegments,
                                  const nsAnimation& aAnimation,
                                  float aFromKey, nsStyleContext* aFromContext,
                                  mozilla::css::Declaration* aFromDeclaration,
                                  float aToKey, nsStyleContext* aToContext,
                                  mozilla::css::Declaration* aToDeclaration)
 {
-  AnimationSegment &segment = *aSegments.AppendElement();
+  nsStyleAnimation::Value fromValue, toValue, dummyValue;
+  if (ExtractComputedValueForTransition(prop, aFromContext, fromValue) &&
+      ExtractComputedValueForTransition(prop, aToContext, toValue) &&
+      // Check that we can interpolate between these values
+      // (If this is ever a performance problem, we could add a
+      // CanInterpolate method, but it seems fine for now.)
+      nsStyleAnimation::Interpolate(prop, fromValue, toValue,
+                                    0.5, dummyValue)) {
+    AnimationPropertySegment &segment = *aSegments.AppendElement();
 
-  segment.mFromKey = aFromKey;
-  segment.mToKey = aToKey;
-  const nsTimingFunction *tf;
-  if (aFromDeclaration &&
-      aFromDeclaration->HasProperty(eCSSProperty_animation_timing_function)) {
-    tf = &aFromContext->GetStyleDisplay()->mAnimations[0].GetTimingFunction();
-  } else {
-    tf = &aAnimation.GetTimingFunction();
-  }
-  segment.mTimingFunction.Init(*tf);
+    // FIXME: still the right thing when we can't interpolate?
+    segment.mFromValue = fromValue;
+    segment.mToValue = toValue;
 
-  for (nsCSSProperty prop = nsCSSProperty(0);
-       prop < eCSSProperty_COUNT_no_shorthands;
-       prop = nsCSSProperty(prop + 1)) {
-    if (nsCSSProps::kAnimTypeTable[prop] == eStyleAnimType_None) {
-      continue;
+    segment.mFromKey = aFromKey;
+    segment.mToKey = aToKey;
+    const nsTimingFunction *tf;
+    if (aFromDeclaration &&
+        aFromDeclaration->HasProperty(eCSSProperty_animation_timing_function)) {
+      tf = &aFromContext->GetStyleDisplay()->mAnimations[0].GetTimingFunction();
+    } else {
+      tf = &aAnimation.GetTimingFunction();
     }
+    segment.mTimingFunction.Init(*tf);
 
-    if (!(aFromDeclaration && aFromDeclaration->HasProperty(prop)) &&
-        !(aToDeclaration && aToDeclaration->HasProperty(prop))) {
-      // Don't store an animation if neither declaration has the property.
-      continue;
-    }
-
-    nsStyleAnimation::Value fromValue, toValue, dummyValue;
-    if (ExtractComputedValueForTransition(prop, aFromContext, fromValue) &&
-        ExtractComputedValueForTransition(prop, aToContext, toValue) &&
-        // Check that we can interpolate between these values
-        // (If this is ever a performance problem, we could add a
-        // CanInterpolate method, but it seems fine for now.)
-        nsStyleAnimation::Interpolate(prop, fromValue, toValue,
-                                      0.5, dummyValue)) {
-      AnimationSegmentProperty &p = *segment.mProperties.AppendElement();
-      p.mProperty = prop;
-      p.mFromValue = fromValue;
-      p.mToValue = toValue;
-    }
   }
 }
 
 nsIStyleRule*
 nsAnimationManager::GetAnimationRule(mozilla::dom::Element* aElement,
                                      nsCSSPseudoElements::Type aPseudoType)
 {
   NS_ABORT_IF_FALSE(
