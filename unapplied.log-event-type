From: L. David Baron <dbaron@dbaron.org>

Log type of event on Linux and Mac.

TODO: Should condition on *runtime* PR logging check.

diff --git a/xpcom/threads/nsThread.cpp b/xpcom/threads/nsThread.cpp
--- a/xpcom/threads/nsThread.cpp
+++ b/xpcom/threads/nsThread.cpp
@@ -627,20 +627,34 @@ nsThread::InitCurrentThread()
 
 NS_IMETHODIMP
 nsThread::DispatchFromScript(nsIRunnable* aEvent, uint32_t aFlags)
 {
   nsCOMPtr<nsIRunnable> event(aEvent);
   return mEventTarget->Dispatch(event.forget(), aFlags);
 }
 
+#include "nsStackWalk.h"
+
+static char gBuf[1024];
+
+static const char*
+GetTypeName(void* ptr)
+{
+  nsCodeAddressDetails details;
+  void *vptr = *(void**)ptr;
+  NS_DescribeCodeAddress(vptr, &details);
+  NS_FormatCodeAddressDetails(vptr, &details, gBuf, sizeof(gBuf));
+  return gBuf;
+}
+
 NS_IMETHODIMP
 nsThread::Dispatch(already_AddRefed<nsIRunnable> aEvent, uint32_t aFlags)
 {
-  LOG(("THRD(%p) Dispatch [%p %x]\n", this, /* XXX aEvent */nullptr, aFlags));
+  LOG(("THRD(%p) Dispatch [%p(%s) %x]\n", this, /* XXX aEvent */nullptr, GetTypeName(aEvent), aFlags));
 
   return mEventTarget->Dispatch(Move(aEvent), aFlags);
 }
 
 NS_IMETHODIMP
 nsThread::DelayedDispatch(already_AddRefed<nsIRunnable> aEvent, uint32_t aDelayMs)
 {
   return mEventTarget->DelayedDispatch(Move(aEvent), aDelayMs);
@@ -968,17 +982,17 @@ nsThread::ProcessNextEvent(bool aMayWait
 
     if (activation.isSome()) {
       activation.ref().SetEvent(event, priority);
     }
 
     *aResult = (event.get() != nullptr);
 
     if (event) {
-      LOG(("THRD(%p) running [%p]\n", this, event.get()));
+      LOG(("THRD(%p) running [%p(%s)]\n", this, event.get(), GetTypeName(event)));
 
       if (MAIN_THREAD == mIsMainThread) {
         HangMonitor::NotifyActivity();
       }
 
 #ifndef RELEASE_OR_BETA
       Maybe<Telemetry::AutoTimer<Telemetry::MAIN_THREAD_RUNNABLE_MS>> timer;
       Maybe<Telemetry::AutoTimer<Telemetry::IDLE_RUNNABLE_BUDGET_OVERUSE_MS>> idleTimer;
