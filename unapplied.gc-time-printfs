From: L. David Baron <dbaron@dbaron.org>

Printfs of elapsed time for cycle collection and JS GC.

diff --git a/js/src/jsgc.cpp b/js/src/jsgc.cpp
--- a/js/src/jsgc.cpp
+++ b/js/src/jsgc.cpp
@@ -4684,19 +4684,28 @@ Collect(JSRuntime *rt, bool incremental,
 
     for (CompartmentsIter c(rt); !c.done(); c.next())
         compartmentCount++;
 
     rt->gcShouldCleanUpEverything = ShouldCleanUpEverything(rt, reason, gckind);
 
     gcstats::AutoGCSlice agc(rt->gcStats, collectedCount, zoneCount, compartmentCount, reason);
 
+#ifdef DEBUG_dbaron
+    fprintf(stderr, "Doing JS GC number %u...\n", unsigned(rt->gcNumber));
+    int64_t start = JS_Now();
+#endif
+
     bool repeat = false;
 
     do {
+#ifdef DEBUG_dbaron
+        fprintf(stderr, "  Doing JS GC iteration.\n");
+#endif
+
         /*
          * Let the API user decide to defer a GC if it wants to (unless this
          * is the last context). Invoke the callback regardless.
          */
         if (rt->gcIncrementalState == NO_INCREMENTAL) {
             gcstats::AutoPhase ap(rt->gcStats, gcstats::PHASE_GC_BEGIN);
             if (JSGCCallback callback = rt->gcCallback)
                 callback(rt, JSGC_BEGIN, rt->gcCallbackData);
@@ -4718,16 +4727,21 @@ Collect(JSRuntime *rt, bool incremental,
         /*
          * If we reset an existing GC, we need to start a new one. Also, we
          * repeat GCs that happen during shutdown (the gcShouldCleanUpEverything
          * case) until we can be sure that no additional garbage is created
          * (which typically happens if roots are dropped during finalizers).
          */
         repeat = (rt->gcPoke && rt->gcShouldCleanUpEverything) || wasReset;
     } while (repeat);
+
+#ifdef DEBUG_dbaron
+    int64_t diff = (JS_Now() - start) / 1000;
+    fprintf(stderr, "... JS_GC took %ld milliseconds.\n", (long)diff);
+#endif
 }
 
 void
 js::GC(JSRuntime *rt, JSGCInvocationKind gckind, JS::gcreason::Reason reason)
 {
     Collect(rt, false, SliceBudget::Unlimited, gckind, reason);
 }
 
