From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::Redraw to XULRedraw.  r=dholbert

Written purely with sed, over .h and .cpp files in layout/, except for
the removal of one comment change in nsSliderFrame.cpp.

MozReview-Commit-ID: 2jpzaby0S9r

diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2922,17 +2922,17 @@ public:
 
   // For nsSprocketLayout
   virtual Valignment GetXULVAlign() const = 0;
   virtual Halignment GetXULHAlign() const = 0;
 
   bool IsXULHorizontal() const { return (mState & NS_STATE_IS_HORIZONTAL) != 0; }
   bool IsXULNormalDirection() const { return (mState & NS_STATE_IS_DIRECTION_NORMAL) != 0; }
 
-  nsresult Redraw(nsBoxLayoutState& aState);
+  nsresult XULRedraw(nsBoxLayoutState& aState);
   virtual nsresult RelayoutChildAtOrdinal(nsIFrame* aChild)=0;
 
 #ifdef DEBUG_LAYOUT
   virtual nsresult SetDebug(nsBoxLayoutState& aState, bool aDebug)=0;
   virtual nsresult GetDebug(bool& aDebug)=0;
 
   virtual nsresult DumpBox(FILE* out)=0;
 #endif
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -530,17 +530,17 @@ nsBox::SyncLayout(nsBoxLayoutState& aSta
   if (IsXULCollapsed()) {
     CollapseChild(aState, this, true);
     return NS_OK;
   }
   */
   
 
   if (GetStateBits() & NS_FRAME_IS_DIRTY)
-     Redraw(aState);
+     XULRedraw(aState);
 
   RemoveStateBits(NS_FRAME_HAS_DIRTY_CHILDREN | NS_FRAME_IS_DIRTY
                   | NS_FRAME_FIRST_REFLOW | NS_FRAME_IN_REFLOW);
 
   nsPresContext* presContext = aState.PresContext();
 
   uint32_t flags = 0;
   GetLayoutFlags(flags);
@@ -577,17 +577,17 @@ nsBox::SyncLayout(nsBoxLayoutState& aSta
     nsContainerFrame::SyncFrameViewAfterReflow(presContext, this, view,
                                                visualOverflow, flags);
   } 
 
   return NS_OK;
 }
 
 nsresult
-nsIFrame::Redraw(nsBoxLayoutState& aState)
+nsIFrame::XULRedraw(nsBoxLayoutState& aState)
 {
   if (aState.PaintingDisabled())
     return NS_OK;
 
   // nsStackLayout, at least, expects us to repaint descendants even
   // if a damage rect is provided
   InvalidateFrameSubtree();
 
diff --git a/layout/xul/nsImageBoxFrame.cpp b/layout/xul/nsImageBoxFrame.cpp
--- a/layout/xul/nsImageBoxFrame.cpp
+++ b/layout/xul/nsImageBoxFrame.cpp
@@ -712,17 +712,17 @@ nsImageBoxFrame::OnSizeAvailable(imgIReq
 
   return NS_OK;
 }
 
 nsresult
 nsImageBoxFrame::OnDecodeComplete(imgIRequest* aRequest)
 {
   nsBoxLayoutState state(PresContext());
-  this->Redraw(state);
+  this->XULRedraw(state);
   return NS_OK;
 }
 
 nsresult
 nsImageBoxFrame::OnLoadComplete(imgIRequest* aRequest, nsresult aStatus)
 {
   if (NS_SUCCEEDED(aStatus)) {
     // Fire an onload DOM event.
diff --git a/layout/xul/nsListBoxLayout.cpp b/layout/xul/nsListBoxLayout.cpp
--- a/layout/xul/nsListBoxLayout.cpp
+++ b/layout/xul/nsListBoxLayout.cpp
@@ -192,17 +192,17 @@ nsListBoxLayout::LayoutInternal(nsIFrame
   // Since we can't do this during layout, we post a callback
   // that will be processed after the reflow completes.
   body->PostReflowCallback();
     
   // if rows were pushed down or pulled up because some rows were added
   // before them then redraw everything under the inserted rows. The inserted
   // rows will automatically be redrawn because the were marked dirty on insertion.
   if (redrawStart > -1) {
-    aBox->Redraw(aState);
+    aBox->XULRedraw(aState);
   }
 
   return NS_OK;
 }
 
 // Creation Routines ///////////////////////////////////////////////////////////////////////
 
 already_AddRefed<nsBoxLayout> NS_NewListBoxLayout()
diff --git a/layout/xul/nsSliderFrame.cpp b/layout/xul/nsSliderFrame.cpp
--- a/layout/xul/nsSliderFrame.cpp
+++ b/layout/xul/nsSliderFrame.cpp
@@ -463,17 +463,17 @@ nsSliderFrame::DoLayout(nsBoxLayoutState
 
   nsRect oldThumbRect(thumbBox->GetRect());
   LayoutChildAt(aState, thumbBox, thumbRect);
 
   SyncLayout(aState);
 
   // Redraw only if thumb changed size.
   if (!oldThumbRect.IsEqualInterior(thumbRect))
-    Redraw(aState);
+    XULRedraw(aState);
 
   return NS_OK;
 }
 
 
 nsresult
 nsSliderFrame::HandleEvent(nsPresContext* aPresContext,
                            WidgetGUIEvent* aEvent,
diff --git a/layout/xul/nsTextBoxFrame.cpp b/layout/xul/nsTextBoxFrame.cpp
--- a/layout/xul/nsTextBoxFrame.cpp
+++ b/layout/xul/nsTextBoxFrame.cpp
@@ -81,17 +81,17 @@ nsTextBoxFrame::AttributeChanged(int32_t
     UpdateAttributes(aAttribute, aResize, aRedraw);
 
     if (aResize) {
         PresContext()->PresShell()->
             FrameNeedsReflow(this, nsIPresShell::eStyleChange,
                              NS_FRAME_IS_DIRTY);
     } else if (aRedraw) {
         nsBoxLayoutState state(PresContext());
-        Redraw(state);
+        XULRedraw(state);
     }
 
     // If the accesskey changed, register for the new value
     // The old value has been unregistered in nsXULElement::SetAttr
     if (aAttribute == nsGkAtoms::accesskey || aAttribute == nsGkAtoms::control)
         RegUnregAccessKey(true);
 
     return NS_OK;
