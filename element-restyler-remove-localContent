From: L. David Baron <dbaron@dbaron.org>

Remove the localContent variable in favor of writing mFrame->GetContent().

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -2016,17 +2016,17 @@ ElementRestyler::Restyle(nsIContent     
                          RestyleTracker&    aRestyleTracker,
                          DesiredA11yNotifications aDesiredA11yNotifications,
                          nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
                          TreeMatchContext &aTreeMatchContext)
 {
   // It would be nice if we could make stronger assertions here; they
   // would let us simplify the ?: expressions below setting |content|
   // and |pseudoContent| in sensible ways as well as making what
-  // |localContent|, |content|, and |pseudoContent| mean make more
+  // |mFrame->GetContent()|, |content|, and |pseudoContent| mean make more
   // sense.  However, we can't, because of frame trees like the one in
   // https://bugzilla.mozilla.org/show_bug.cgi?id=472353#c14 .  Once we
   // fix bug 242277 we should be able to make this make more sense.
   NS_ASSERTION(mFrame->GetContent() || !aParentContent ||
                !aParentContent->GetParent(),
                "frame must have content (unless at the top of the tree)");
   // XXXldb get new context from prev-in-flow if possible, to avoid
   // duplication.  (Or should we just let |GetContext| handle that?)
@@ -2048,23 +2048,23 @@ ElementRestyler::Restyle(nsIContent     
 
 #ifdef ACCESSIBILITY
     bool wasFrameVisible = nsIPresShell::IsAccessibilityActive() ?
       oldContext->StyleVisibility()->IsVisible() : false;
 #endif
 
     nsIAtom* const pseudoTag = oldContext->GetPseudo();
     const nsCSSPseudoElements::Type pseudoType = oldContext->GetPseudoType();
-    nsIContent* localContent = mFrame->GetContent();
     // |content| is the node that we used for rule matching of
     // normal elements (not pseudo-elements) and for which we generate
     // framechange hints if we need them.
     // XXXldb Why does it make sense to use aParentContent?  (See
     // comment above assertion at start of function.)
-    nsIContent* content = localContent ? localContent : aParentContent;
+    nsIContent* content = mFrame->GetContent() ? mFrame->GetContent()
+                                               : aParentContent;
 
     if (content && content->IsElement()) {
       content->OwnerDoc()->FlushPendingLinkUpdates();
       RestyleTracker::RestyleData restyleData;
       if (aRestyleTracker.GetRestyleData(content->AsElement(), &restyleData)) {
         if (NS_UpdateHint(mMinChange, restyleData.mChangeHint)) {
           aChangeList->AppendChange(mFrame, content, restyleData.mChangeHint);
         }
@@ -2191,17 +2191,17 @@ ElementRestyler::Restyle(nsIContent     
     if (copyFromContinuation) {
       // Just use the style context from the frame's previous
       // continuation (see assertion about mFrame->GetNextContinuation()
       // above, which we would have previously hit for mFrame's previous
       // continuation).
       newContext = prevContinuationContext;
     }
     else if (pseudoTag == nsCSSAnonBoxes::mozNonElement) {
-      NS_ASSERTION(localContent,
+      NS_ASSERTION(mFrame->GetContent(),
                    "non pseudo-element frame without content node");
       newContext = styleSet->ResolveStyleForNonElement(parentContext);
     }
     else if (!aRestyleHint && !prevContinuation) {
       // Unfortunately, if prevContinuation is non-null then we may have
       // already stolen the restyle tracker entry for this element while
       // processing prevContinuation.  So we don't know whether aRestyleHint
       // should really be 0 here or whether it should be eRestyle_Self.  Be
@@ -2245,17 +2245,17 @@ ElementRestyler::Restyle(nsIContent     
                          nsCSSPseudoElements::ePseudo_PseudoElementCount,
                        "Unexpected pseudo type");
           newContext = styleSet->ResolvePseudoElementStyle(element,
                                                            pseudoType,
                                                            parentContext);
         }
       }
       else {
-        NS_ASSERTION(localContent,
+        NS_ASSERTION(mFrame->GetContent(),
                      "non pseudo-element frame without content node");
         // Skip flex-item style fixup for anonymous subtrees:
         TreeMatchContext::AutoFlexItemStyleFixupSkipper
           flexFixupSkipper(aTreeMatchContext,
                            element->IsRootOfNativeAnonymousSubtree());
         newContext = styleSet->ResolveStyleFor(element, parentContext,
                                                aTreeMatchContext);
       }
@@ -2355,18 +2355,18 @@ ElementRestyler::Restyle(nsIContent     
     bool checkUndisplayed;
     nsIContent* undisplayedParent;
     nsCSSFrameConstructor* frameConstructor = mPresContext->FrameConstructor();
     if (pseudoTag) {
       checkUndisplayed = mFrame == frameConstructor->
                                      GetDocElementContainingBlock();
       undisplayedParent = nullptr;
     } else {
-      checkUndisplayed = !!localContent;
-      undisplayedParent = localContent;
+      checkUndisplayed = !!mFrame->GetContent();
+      undisplayedParent = mFrame->GetContent();
     }
     if (checkUndisplayed) {
       UndisplayedNode* undisplayed =
         frameConstructor->GetAllUndisplayedContentIn(undisplayedParent);
       for (TreeMatchContext::AutoAncestorPusher
              pushAncestor(undisplayed, aTreeMatchContext,
                           undisplayedParent ? undisplayedParent->AsElement()
                                             : nullptr);
@@ -2438,17 +2438,17 @@ ElementRestyler::Restyle(nsIContent     
             NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
         // Check for a new :before pseudo and an existing :before
         // frame, but only if the frame is the first continuation.
         nsIFrame* prevContinuation = mFrame->GetPrevContinuation();
         if (!prevContinuation) {
           // Checking for a :before frame is cheaper than getting the
           // :before style context.
           if (!nsLayoutUtils::GetBeforeFrame(mFrame) &&
-              nsLayoutUtils::HasPseudoStyle(localContent, newContext,
+              nsLayoutUtils::HasPseudoStyle(mFrame->GetContent(), newContext,
                                             nsCSSPseudoElements::ePseudo_before,
                                             mPresContext)) {
             // Have to create the new :before frame
             NS_UpdateHint(mMinChange, nsChangeHint_ReconstructFrame);
             aChangeList->AppendChange(mFrame, content,
                                       nsChangeHint_ReconstructFrame);
           }
         }
@@ -2469,17 +2469,17 @@ ElementRestyler::Restyle(nsIContent     
             NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
         // Check for new :after content, but only if the frame is the
         // last continuation.
         nsIFrame* nextContinuation = mFrame->GetNextContinuation();
 
         if (!nextContinuation) {
           // Getting the :after frame is more expensive than getting the pseudo
           // context, so get the pseudo context first.
-          if (nsLayoutUtils::HasPseudoStyle(localContent, newContext,
+          if (nsLayoutUtils::HasPseudoStyle(mFrame->GetContent(), newContext,
                                             nsCSSPseudoElements::ePseudo_after,
                                             mPresContext) &&
               !nsLayoutUtils::GetAfterFrame(mFrame)) {
             // have to create the new :after frame
             NS_UpdateHint(mMinChange, nsChangeHint_ReconstructFrame);
             aChangeList->AppendChange(mFrame, content,
                                       nsChangeHint_ReconstructFrame);
           }
