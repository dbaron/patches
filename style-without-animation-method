From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Add method to return a modified version of a style context, with all or part of the animation data removed.

diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -109,25 +109,33 @@ public:
 
   // Whether rule matching should skip styles associated with animation
   bool SkipAnimationRules() const {
     MOZ_ASSERT(mSkipAnimationRules || !mPostAnimationRestyles,
                "inconsistent state");
     return mSkipAnimationRules;
   }
 
+  void SetSkipAnimationRules(bool aSkipAnimationRules) {
+    mSkipAnimationRules = aSkipAnimationRules;
+  }
+
   // Whether rule matching should post animation restyles when it skips
   // styles associated with animation.  Only true when
   // SkipAnimationRules() is also true.
   bool PostAnimationRestyles() const {
     MOZ_ASSERT(mSkipAnimationRules || !mPostAnimationRestyles,
                "inconsistent state");
     return mPostAnimationRestyles;
   }
 
+  void SetPostAnimationRestyles(bool aPostAnimationRestyles) {
+    mPostAnimationRestyles = aPostAnimationRestyles;
+  }
+
   // Whether we're currently in the animation phase of restyle
   // processing (to be eliminated in bug 960465)
   bool IsProcessingAnimationStyleChange() const {
     return mIsProcessingAnimationStyleChange;
   }
 
   /**
    * Reparent the style contexts of this frame subtree.  The parent frame of
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -398,16 +398,42 @@ ResolvedStyleCache::Get(nsPresContext *a
     nsRefPtr<nsStyleContext> resultStrong = aPresContext->StyleSet()->
       ResolveStyleByAddingRules(aParentStyleContext, rules);
     mCache.Put(aKeyframe, resultStrong);
     result = resultStrong;
   }
   return result;
 }
 
+already_AddRefed<nsStyleContext>
+nsAnimationManager::StyleWithoutAnimation(dom::Element* aTarget,
+                                          nsStyleContext* aStyleContext)
+{
+  RestyleManager* restyleManager = mPresContext->RestyleManager();
+  // FIXME: Right now oldSkipAnimationRules will always be true, but bug
+  // 960465 will change it to always being false.  Once that happens, we
+  // can remove it.
+  bool oldSkipAnimationRules = restyleManager->SkipAnimationRules();
+  restyleManager->SetSkipAnimationRules(true);
+  // FIXME: Right now oldPostAnimationRestyles will always be true, but
+  // bug 960465 will change it to always being false, and also make the
+  // entire variable unnecessary.  Once that happens, we can remove it.
+  bool oldPostAnimationRestyles = restyleManager->PostAnimationRestyles();
+  restyleManager->SetPostAnimationRestyles(false);
+
+  nsRefPtr<nsStyleContext> result = mPresContext->StyleSet()->
+    ResolveStyleWithReplacement(aTarget, aStyleContext->GetParent(),
+                                aStyleContext, eRestyle_ChangeAnimationPhase);
+
+  restyleManager->SetPostAnimationRestyles(oldPostAnimationRestyles);
+  restyleManager->SetSkipAnimationRules(oldSkipAnimationRules);
+
+  return result.forget();
+}
+
 void
 nsAnimationManager::BuildAnimations(nsStyleContext* aStyleContext,
                                     dom::Element* aTarget,
                                     dom::AnimationTimeline* aTimeline,
                                     AnimationPlayerPtrArray& aPlayers)
 {
   NS_ABORT_IF_FALSE(aPlayers.IsEmpty(), "expect empty array");
 
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -227,16 +227,19 @@ private:
                        mozilla::AnimationPlayerPtrArray& aAnimations);
   bool BuildSegment(InfallibleTArray<mozilla::AnimationPropertySegment>&
                       aSegments,
                     nsCSSProperty aProperty,
                     const mozilla::StyleAnimation& aAnimation,
                     float aFromKey, nsStyleContext* aFromContext,
                     mozilla::css::Declaration* aFromDeclaration,
                     float aToKey, nsStyleContext* aToContext);
+  already_AddRefed<nsStyleContext>
+    StyleWithoutAnimation(mozilla::dom::Element* aTarget,
+                          nsStyleContext* aStyleContext);
 
   // The guts of DispatchEvents
   void DoDispatchEvents();
 
   mozilla::EventArray mPendingEvents;
 };
 
 #endif /* !defined(nsAnimationManager_h_) */
