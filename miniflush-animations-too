From: L. David Baron <dbaron@dbaron.org>

Bug 996796 patch 1 - Perform a miniflush on both animations and transitions before processing restyles.

This affects the correctness of transitions that take over from a
running animation.  (In the current code this can happen on a single
element; once the cascading changes in bug 960465 are complete it can
only happen via inheritance.)

The final two added tests fail without the patch and pass with the patch.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1455,16 +1455,17 @@ RestyleManager::ProcessPendingRestyles()
   // resulting from any throttled animations (animations that we're
   // running entirely on the compositor thread) is up-to-date, so that
   // if any style changes we cause trigger transitions, we have the
   // correct old style for starting the transition.
   if (nsLayoutUtils::AreAsyncAnimationsEnabled() &&
       mPendingRestyles.Count() > 0) {
     ++mAnimationGeneration;
     mPresContext->TransitionManager()->UpdateAllThrottledStyles();
+    mPresContext->AnimationManager()->UpdateAllThrottledStyles();
   }
 
   mPendingRestyles.ProcessRestyles();
 
 #ifdef DEBUG
   uint32_t oldPendingRestyleCount = mPendingRestyles.Count();
 #endif
 
diff --git a/layout/style/test/test_animations_omta_start.html b/layout/style/test/test_animations_omta_start.html
--- a/layout/style/test/test_animations_omta_start.html
+++ b/layout/style/test/test_animations_omta_start.html
@@ -117,17 +117,117 @@ function testBackwardsFill() {
       waitForAllPaints(function() {
         var transform = gUtils.getOMTAStyle(target, "transform");
         ok(matricesRoughlyEqual(convertTo3dMatrix(transform),
                                 convertTo3dMatrix("matrix(1, 0, 0, 1, 1, 0)")),
            "transform is set on compositor thread after delayed start " +
            "with backwards fill");
         target.removeAttribute("style");
         gUtils.restoreNormalRefresh();
-        SimpleTest.finish();
+        testTransitionTakingOver();
+      });
+    });
+  });
+}
+
+function testTransitionTakingOver() {
+  gUtils.advanceTimeAndRefresh(0);
+
+  var parent = newTarget();
+  var child = newTarget();
+  parent.appendChild(child);
+  parent.style.transform = "translate(0px)";
+  parent.style.animation = "10s anim-transform-2 linear";
+  parent.style.opacity = "1.0";
+  child.style.transform = "inherit";
+  child.style.transition = "10s transform linear";
+  child.style.opacity = "1.0";
+
+  var childCS = getComputedStyle(child, "");
+
+  gUtils.advanceTimeAndRefresh(0);
+  waitForAllPaints(function() {
+    gUtils.advanceTimeAndRefresh(4000);
+    waitForAllPaints(function() {
+      child.style.transform = "translate(100px)";
+      var transform = gUtils.getOMTAStyle(child, "transform");
+      // FIXME Bug 1031688: Bug with inheritance!
+      todo_is(transform, "matrix(1, 0, 0, 1, 40, 0)",
+         "transition that interrupted animation is correct");
+      gUtils.advanceTimeAndRefresh(0);
+      waitForAllPaints(function() {
+        var transform = gUtils.getOMTAStyle(child, "transform");
+        is(transform, "matrix(1, 0, 0, 1, 40, 0)",
+           "transition that interrupted animation is correct");
+        gUtils.advanceTimeAndRefresh(5000);
+        waitForAllPaints(function() {
+          var transform = gUtils.getOMTAStyle(child, "transform");
+          is(transform, "matrix(1, 0, 0, 1, 70, 0)",
+             "transition that interrupted animation is correct");
+          is(childCS.transform, "matrix(1, 0, 0, 1, 70, 0)",
+             "transition that interrupted animation is correct");
+          parent.removeAttribute("style");
+          child.removeAttribute("style");
+          gUtils.restoreNormalRefresh();
+          testTransitionTakingOver2();
+        });
+      });
+    });
+  });
+}
+
+// This is identical to testTransitionTakingOver except that the
+// transition has a shorter time.  This exhibits different behavior in
+// cases where, because of the strange behavior of the transitions spec
+// where the interpolated value at the start of an animation has a
+// different computed value (in the can-trigger-a-transition sense) than
+// the value that starts the animation (translate3d(0,0,0) vs.
+// translateX(0), for example), because if that happens, then the
+// bogus transition has finished before we make changes.
+function testTransitionTakingOver2() {
+  gUtils.advanceTimeAndRefresh(0);
+
+  var parent = newTarget();
+  var child = newTarget();
+  parent.appendChild(child);
+  parent.style.transform = "translate(0px)";
+  parent.style.animation = "10s anim-transform-2 linear";
+  parent.style.opacity = "1.0";
+  child.style.transform = "inherit";
+  child.style.transition = "1s transform linear";
+  child.style.opacity = "1.0";
+
+  var childCS = getComputedStyle(child, "");
+
+  gUtils.advanceTimeAndRefresh(0);
+  waitForAllPaints(function() {
+    gUtils.advanceTimeAndRefresh(4000);
+    waitForAllPaints(function() {
+      child.style.transform = "translate(100px)";
+      var transform = gUtils.getOMTAStyle(child, "transform");
+      // FIXME Bug 1031688: Bug with inheritance!
+      todo_is(transform, "matrix(1, 0, 0, 1, 40, 0)",
+         "transition that interrupted animation is correct");
+      gUtils.advanceTimeAndRefresh(0);
+      waitForAllPaints(function() {
+        var transform = gUtils.getOMTAStyle(child, "transform");
+        is(transform, "matrix(1, 0, 0, 1, 40, 0)",
+           "transition that interrupted animation is correct");
+        gUtils.advanceTimeAndRefresh(500);
+        waitForAllPaints(function() {
+          var transform = gUtils.getOMTAStyle(child, "transform");
+          is(transform, "matrix(1, 0, 0, 1, 70, 0)",
+             "transition that interrupted animation is correct");
+          is(childCS.transform, "matrix(1, 0, 0, 1, 70, 0)",
+             "transition that interrupted animation is correct");
+          parent.removeAttribute("style");
+          child.removeAttribute("style");
+          gUtils.restoreNormalRefresh();
+          SimpleTest.finish();
+        });
       });
     });
   });
 }
 
 </script>
 </pre>
 </body>
