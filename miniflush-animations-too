From: L. David Baron <dbaron@dbaron.org>

Bug 996796 patch 1 - Perform a miniflush on both animations and transitions before processing restyles.  r=birtles

This affects the correctness of transitions that take over from a
running animation.  (In the current code this can happen on a single
element; once the cascading changes in bug 960465 are complete it can
only happen via inheritance.)

This version of the patch changes to do the test using opacity rather
than transform, since testing using transforms encountered issues
related to bug 1031688:  the presence of phantom transitions due to the
interaction of the computed value rules for transforms distinguishing
between values that the interpolation rules consider identical.  (These
problems only appear after patch 24 in this bug changes the coalescing
order between a parent with animations and a child with transitions so
that the parent is handled before the child, instead of transitions
being handled before animations.)

The final two added tests fail without the patch and pass with the patch.
(With the opacity version, the third to last test also fails without the
patch, probably due to the value not having yet been sent to the layer.
This was not an issue pre-patch with the original test using transform,
though.  I haven't tested that this happened with patch 0, though, so it
might have been the issue patch 0 fixes.)

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1461,16 +1461,17 @@ RestyleManager::ProcessPendingRestyles()
   // resulting from any throttled animations (animations that we're
   // running entirely on the compositor thread) is up-to-date, so that
   // if any style changes we cause trigger transitions, we have the
   // correct old style for starting the transition.
   if (nsLayoutUtils::AreAsyncAnimationsEnabled() &&
       mPendingRestyles.Count() > 0) {
     ++mAnimationGeneration;
     mPresContext->TransitionManager()->UpdateAllThrottledStyles();
+    mPresContext->AnimationManager()->UpdateAllThrottledStyles();
   }
 
   mPendingRestyles.ProcessRestyles();
 
 #ifdef DEBUG
   uint32_t oldPendingRestyleCount = mPendingRestyles.Count();
 #endif
 
diff --git a/layout/style/test/test_animations_omta_start.html b/layout/style/test/test_animations_omta_start.html
--- a/layout/style/test/test_animations_omta_start.html
+++ b/layout/style/test/test_animations_omta_start.html
@@ -12,16 +12,20 @@ https://bugzilla.mozilla.org/show_bug.cg
     src="/tests/SimpleTest/paint_listener.js"></script>
   <script type="application/javascript" src="animation_utils.js"></script>
   <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
   <style type="text/css">
     @keyframes anim-opacity {
        0% { opacity: 0.5 }
        100% { opacity: 0.5 }
     }
+    @keyframes anim-opacity-2 {
+       0% { opacity: 0.0 }
+       100% { opacity: 1.0 }
+    }
     @keyframes anim-transform {
        0% { transform: translate(50px); }
        100% { transform: translate(50px); }
     }
     @keyframes anim-transform-2 {
        0% { transform: translate(0px); }
        100% { transform: translate(100px); }
     }
@@ -117,17 +121,62 @@ function testBackwardsFill() {
       waitForAllPaints(function() {
         var transform = gUtils.getOMTAStyle(target, "transform");
         ok(matricesRoughlyEqual(convertTo3dMatrix(transform),
                                 convertTo3dMatrix("matrix(1, 0, 0, 1, 1, 0)")),
            "transform is set on compositor thread after delayed start " +
            "with backwards fill");
         target.remove();
         gUtils.restoreNormalRefresh();
-        SimpleTest.finish();
+        testTransitionTakingOver();
+      });
+    });
+  });
+}
+
+function testTransitionTakingOver() {
+  gUtils.advanceTimeAndRefresh(0);
+
+  var parent = newTarget();
+  var child = newTarget();
+  parent.appendChild(child);
+  parent.style.opacity = "0.0";
+  parent.style.animation = "10s anim-opacity-2 linear";
+  child.style.opacity = "inherit";
+  child.style.transition = "10s opacity linear";
+
+  var childCS = getComputedStyle(child, "");
+
+  gUtils.advanceTimeAndRefresh(0);
+  waitForAllPaints(function() {
+    gUtils.advanceTimeAndRefresh(4000);
+    waitForAllPaints(function() {
+      child.style.opacity = "1.0";
+      var opacity = gUtils.getOMTAStyle(child, "opacity");
+      // FIXME Bug 1039799 (or lower priority followup): Animations
+      // inherited from an animating parent element don't get shipped to
+      // the compositor thread.
+      todo_is(opacity, "0.4",
+         "transition that interrupted animation is correct");
+      gUtils.advanceTimeAndRefresh(0);
+      waitForAllPaints(function() {
+        var opacity = gUtils.getOMTAStyle(child, "opacity");
+        is(opacity, "0.4",
+           "transition that interrupted animation is correct");
+        gUtils.advanceTimeAndRefresh(5000);
+        waitForAllPaints(function() {
+          opacity = gUtils.getOMTAStyle(child, "opacity");
+          is(opacity, "0.7",
+             "transition that interrupted animation is correct");
+          is(childCS.opacity, "0.7",
+             "transition that interrupted animation is correct");
+          parent.remove();
+          gUtils.restoreNormalRefresh();
+          SimpleTest.finish();
+        });
       });
     });
   });
 }
 
 </script>
 </pre>
 </body>
