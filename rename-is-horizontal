From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::IsHorizontal to IsXULHorizontal, and related methods.

This is a manual subset of changes written with sed, over .h and .cpp
files in layout/.

This also renames a static method on nsSprocketLayout.

Note that nsFlexContainerFrame and nsRangeFrame also have IsHorizontal
methods that are not renamed here, but this can be found to be
relatively safe because none of the IsHorizontal methods are virtual.

MozReview-Commit-ID: Jsdy7I4Q7mX

diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -1201,17 +1201,17 @@ ScrollFrameHelper::ScrollByWhole(nsScrol
   ScrollByUnit(aScrollbar, nsIScrollableFrame::INSTANT, aDirection,
                nsIScrollableFrame::WHOLE, aSnap);
 }
 
 void
 ScrollFrameHelper::ScrollByLine(nsScrollbarFrame* aScrollbar, int32_t aDirection,
                                 nsIScrollbarMediator::ScrollSnapMode aSnap)
 {
-  bool isHorizontal = aScrollbar->IsHorizontal();
+  bool isHorizontal = aScrollbar->IsXULHorizontal();
   nsIntPoint delta;
   if (isHorizontal) {
     const double kScrollMultiplier =
       Preferences::GetInt("toolkit.scrollbox.horizontalScrollDistance",
                           NS_DEFAULT_HORIZONTAL_SCROLL_DISTANCE);
     delta.x = aDirection * kScrollMultiplier;
     if (GetLineScrollAmount().width * delta.x > GetPageScrollAmount().width) {
       // The scroll frame is so small that the delta would be more
@@ -1247,17 +1247,17 @@ ScrollFrameHelper::RepeatButtonScroll(ns
 }
 
 void
 ScrollFrameHelper::ThumbMoved(nsScrollbarFrame* aScrollbar,
                               nscoord aOldPos,
                               nscoord aNewPos)
 {
   MOZ_ASSERT(aScrollbar != nullptr);
-  bool isHorizontal = aScrollbar->IsHorizontal();
+  bool isHorizontal = aScrollbar->IsXULHorizontal();
   nsPoint current = GetScrollPosition();
   nsPoint dest = current;
   if (isHorizontal) {
     dest.x = IsLTR() ? aNewPos : aNewPos - GetScrollRange().width;
   } else {
     dest.y = aNewPos;
   }
   nsRect allowedRange = GetOnePixelRangeAroundPoint(dest, isHorizontal);
@@ -1287,17 +1287,17 @@ ScrollFrameHelper::ScrollbarReleased(nsS
 void
 ScrollFrameHelper::ScrollByUnit(nsScrollbarFrame* aScrollbar,
                                 nsIScrollableFrame::ScrollMode aMode,
                                 int32_t aDirection,
                                 nsIScrollableFrame::ScrollUnit aUnit,
                                 nsIScrollbarMediator::ScrollSnapMode aSnap)
 {
   MOZ_ASSERT(aScrollbar != nullptr);
-  bool isHorizontal = aScrollbar->IsHorizontal();
+  bool isHorizontal = aScrollbar->IsXULHorizontal();
   nsIntPoint delta;
   if (isHorizontal) {
     delta.x = aDirection;
   } else {
     delta.y = aDirection;
   }
   nsIntPoint overflow;
   ScrollBy(delta, aUnit, aMode, &overflow, nsGkAtoms::other,
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2919,17 +2919,17 @@ public:
   virtual void SetXULLayoutManager(nsBoxLayout* aLayout) { }
   virtual nsBoxLayout* GetXULLayoutManager() { return nullptr; }
   nsresult GetXULClientRect(nsRect& aContentRect);
 
   // For nsSprocketLayout
   virtual Valignment GetXULVAlign() const = 0;
   virtual Halignment GetXULHAlign() const = 0;
 
-  bool IsHorizontal() const { return (mState & NS_STATE_IS_HORIZONTAL) != 0; }
+  bool IsXULHorizontal() const { return (mState & NS_STATE_IS_HORIZONTAL) != 0; }
   bool IsNormalDirection() const { return (mState & NS_STATE_IS_DIRECTION_NORMAL) != 0; }
 
   nsresult Redraw(nsBoxLayoutState& aState);
   virtual nsresult RelayoutChildAtOrdinal(nsIFrame* aChild)=0;
 
 #ifdef DEBUG_LAYOUT
   virtual nsresult SetDebug(nsBoxLayoutState& aState, bool aDebug)=0;
   virtual nsresult GetDebug(bool& aDebug)=0;
diff --git a/layout/xul/ScrollBoxObject.cpp b/layout/xul/ScrollBoxObject.cpp
--- a/layout/xul/ScrollBoxObject.cpp
+++ b/layout/xul/ScrollBoxObject.cpp
@@ -109,17 +109,17 @@ void ScrollBoxObject::ScrollByIndex(int3
       return;
     }
 
     nsRect rect;
 
     // now get the scrolled boxes first child.
     nsIFrame* child = nsBox::GetChildXULBox(scrolledBox);
 
-    bool horiz = scrolledBox->IsHorizontal();
+    bool horiz = scrolledBox->IsXULHorizontal();
     nsPoint cp = sf->GetScrollPosition();
     nscoord diff = 0;
     int32_t curIndex = 0;
     bool isLTR = scrolledBox->IsNormalDirection();
 
     int32_t frameWidth = 0;
     if (!isLTR && horiz) {
       GetWidth(&frameWidth);
diff --git a/layout/xul/grid/nsGrid.cpp b/layout/xul/grid/nsGrid.cpp
--- a/layout/xul/grid/nsGrid.cpp
+++ b/layout/xul/grid/nsGrid.cpp
@@ -257,17 +257,17 @@ nsGrid::FindRowsAndColumns(nsIFrame** aR
        child = do_QueryFrame(scrolledFrame);
     }
 
     nsCOMPtr<nsIGridPart> monument = GetPartFromBox(child);
     if (monument)
     {
       nsGridRowGroupLayout* rowGroup = monument->CastToRowGroupLayout();
       if (rowGroup) {
-         bool isHorizontal = !nsSprocketLayout::IsHorizontal(child);
+         bool isHorizontal = !nsSprocketLayout::IsXULHorizontal(child);
          if (isHorizontal)
            *aRows = child;
          else
            *aColumns = child;
 
          if (*aRows && *aColumns)
            return;
       }
diff --git a/layout/xul/grid/nsGridRowGroupLayout.cpp b/layout/xul/grid/nsGridRowGroupLayout.cpp
--- a/layout/xul/grid/nsGridRowGroupLayout.cpp
+++ b/layout/xul/grid/nsGridRowGroupLayout.cpp
@@ -38,17 +38,17 @@ nsGridRowGroupLayout::~nsGridRowGroupLay
 {
 }
 
 void
 nsGridRowGroupLayout::ChildAddedOrRemoved(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   int32_t index = 0;
   nsGrid* grid = GetGrid(aBox, &index);
-  bool isHorizontal = IsHorizontal(aBox);
+  bool isHorizontal = IsXULHorizontal(aBox);
 
   if (grid)
     grid->RowAddedOrRemoved(aState, index, isHorizontal);
 }
 
 void
 nsGridRowGroupLayout::AddWidth(nsSize& aSize, nscoord aSize2, bool aIsHorizontal)
 {
@@ -74,17 +74,17 @@ nsGridRowGroupLayout::GetXULPrefSize(nsI
   */
 
   int32_t index = 0;
   nsGrid* grid = GetGrid(aBox, &index);
 
   if (grid) 
   {
     // make sure we add in extra columns sizes as well
-    bool isHorizontal = IsHorizontal(aBox);
+    bool isHorizontal = IsXULHorizontal(aBox);
     int32_t extraColumns = grid->GetExtraColumnCount(isHorizontal);
     int32_t start = grid->GetColumnCount(isHorizontal) - grid->GetExtraColumnCount(isHorizontal);
     for (int32_t i=0; i < extraColumns; i++)
     {
       nscoord pref =
         grid->GetPrefRowHeight(aState, i+start, !isHorizontal); // GetPrefColumnWidth
 
       AddWidth(vpref, pref, isHorizontal);
@@ -100,17 +100,17 @@ nsGridRowGroupLayout::GetXULMaxSize(nsIF
  nsSize maxSize = nsGridRowLayout::GetXULMaxSize(aBox, aState); 
 
   int32_t index = 0;
   nsGrid* grid = GetGrid(aBox, &index);
 
   if (grid) 
   {
     // make sure we add in extra columns sizes as well
-    bool isHorizontal = IsHorizontal(aBox);
+    bool isHorizontal = IsXULHorizontal(aBox);
     int32_t extraColumns = grid->GetExtraColumnCount(isHorizontal);
     int32_t start = grid->GetColumnCount(isHorizontal) - grid->GetExtraColumnCount(isHorizontal);
     for (int32_t i=0; i < extraColumns; i++)
     {
       nscoord max =
         grid->GetMaxRowHeight(aState, i+start, !isHorizontal); // GetMaxColumnWidth
 
       AddWidth(maxSize, max, isHorizontal);
@@ -126,17 +126,17 @@ nsGridRowGroupLayout::GetXULMinSize(nsIF
   nsSize minSize = nsGridRowLayout::GetXULMinSize(aBox, aState); 
 
   int32_t index = 0;
   nsGrid* grid = GetGrid(aBox, &index);
 
   if (grid) 
   {
     // make sure we add in extra columns sizes as well
-    bool isHorizontal = IsHorizontal(aBox);
+    bool isHorizontal = IsXULHorizontal(aBox);
     int32_t extraColumns = grid->GetExtraColumnCount(isHorizontal);
     int32_t start = grid->GetColumnCount(isHorizontal) - grid->GetExtraColumnCount(isHorizontal);
     for (int32_t i=0; i < extraColumns; i++)
     {
       nscoord min = 
         grid->GetMinRowHeight(aState, i+start, !isHorizontal); // GetMinColumnWidth
       AddWidth(minSize, min, isHorizontal);
     }
diff --git a/layout/xul/grid/nsGridRowLeafFrame.cpp b/layout/xul/grid/nsGridRowLeafFrame.cpp
--- a/layout/xul/grid/nsGridRowLeafFrame.cpp
+++ b/layout/xul/grid/nsGridRowLeafFrame.cpp
@@ -43,17 +43,17 @@ nsGridRowLeafFrame::GetXULBorderAndPaddi
     return rv;
     
   int32_t index = 0;
   nsGrid* grid = part->GetGrid(this, &index);
 
   if (!grid) 
     return rv;
 
-  bool isHorizontal = IsHorizontal();
+  bool isHorizontal = IsXULHorizontal();
 
   int32_t firstIndex = 0;
   int32_t lastIndex = 0;
   nsGridRow* firstRow = nullptr;
   nsGridRow* lastRow = nullptr;
   grid->GetFirstAndLastRow(firstIndex, lastIndex, firstRow, lastRow, isHorizontal);
 
   // only the first and last rows can be affected.
diff --git a/layout/xul/grid/nsGridRowLeafLayout.cpp b/layout/xul/grid/nsGridRowLeafLayout.cpp
--- a/layout/xul/grid/nsGridRowLeafLayout.cpp
+++ b/layout/xul/grid/nsGridRowLeafLayout.cpp
@@ -34,17 +34,17 @@ nsGridRowLeafLayout::~nsGridRowLeafLayou
 {
 }
 
 nsSize
 nsGridRowLeafLayout::GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   int32_t index = 0;
   nsGrid* grid = GetGrid(aBox, &index);
-  bool isHorizontal = IsHorizontal(aBox);
+  bool isHorizontal = IsXULHorizontal(aBox);
 
   // If we are not in a grid. Then we just work like a box. But if we are in a grid
   // ask the grid for our size.
   if (!grid) {
     return nsGridRowLayout::GetXULPrefSize(aBox, aState); 
   }
   else {
     return grid->GetPrefRowSize(aState, index, isHorizontal);
@@ -52,33 +52,33 @@ nsGridRowLeafLayout::GetXULPrefSize(nsIF
   }
 }
 
 nsSize
 nsGridRowLeafLayout::GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   int32_t index = 0;
   nsGrid* grid = GetGrid(aBox, &index);
-  bool isHorizontal = IsHorizontal(aBox);
+  bool isHorizontal = IsXULHorizontal(aBox);
 
   if (!grid)
     return nsGridRowLayout::GetXULMinSize(aBox, aState); 
   else {
     nsSize minSize = grid->GetMinRowSize(aState, index, isHorizontal);
     AddBorderAndPadding(aBox, minSize);
     return minSize;
   }
 }
 
 nsSize
 nsGridRowLeafLayout::GetXULMaxSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   int32_t index = 0;
   nsGrid* grid = GetGrid(aBox, &index);
-  bool isHorizontal = IsHorizontal(aBox);
+  bool isHorizontal = IsXULHorizontal(aBox);
 
   if (!grid)
     return nsGridRowLayout::GetXULMaxSize(aBox, aState); 
   else {
     nsSize maxSize;
     maxSize = grid->GetMaxRowSize(aState, index, isHorizontal);
     AddBorderAndPadding(aBox, maxSize);
     return maxSize;
@@ -87,28 +87,28 @@ nsGridRowLeafLayout::GetXULMaxSize(nsIFr
 
 /** If a child is added or removed or changes size
   */
 void
 nsGridRowLeafLayout::ChildAddedOrRemoved(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   int32_t index = 0;
   nsGrid* grid = GetGrid(aBox, &index);
-  bool isHorizontal = IsHorizontal(aBox);
+  bool isHorizontal = IsXULHorizontal(aBox);
 
   if (grid)
     grid->CellAddedOrRemoved(aState, index, isHorizontal);
 }
 
 void
 nsGridRowLeafLayout::PopulateBoxSizes(nsIFrame* aBox, nsBoxLayoutState& aState, nsBoxSize*& aBoxSizes, nscoord& aMinSize, nscoord& aMaxSize, int32_t& aFlexes)
 {
   int32_t index = 0;
   nsGrid* grid = GetGrid(aBox, &index);
-  bool isHorizontal = IsHorizontal(aBox);
+  bool isHorizontal = IsXULHorizontal(aBox);
 
   // Our base class SprocketLayout is giving us a chance to change the box sizes before layout
   // If we are a row lets change the sizes to match our columns. If we are a column then do the opposite
   // and make them match or rows.
   if (grid) {
     nsGridRow* column;
     int32_t count = grid->GetColumnCount(isHorizontal); 
     nsBoxSize* start = nullptr;
@@ -219,17 +219,17 @@ nsGridRowLeafLayout::ComputeChildSizes(n
                            nsBoxLayoutState& aState, 
                            nscoord& aGivenSize, 
                            nsBoxSize* aBoxSizes, 
                            nsComputedBoxSize*& aComputedBoxSizes)
 { 
   // see if we are in a scrollable frame. If we are then there could be scrollbars present
   // if so we need to subtract them out to make sure our columns line up.
   if (aBox) {
-    bool isHorizontal = aBox->IsHorizontal();
+    bool isHorizontal = aBox->IsXULHorizontal();
 
     // go up the parent chain looking for scrollframes
     nscoord diff = 0;
     nsIFrame* parentBox;
     (void)GetParentGridPart(aBox, &parentBox);
     while (parentBox) {
       nsIFrame* scrollbox = nsGrid::GetScrollBox(parentBox);
       nsIScrollableFrame *scrollable = do_QueryFrame(scrollbox);
diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -310,17 +310,17 @@ nsBoxFrame::GetInitialHAlignment(nsBoxFr
   if (index >= 0) {
     aHalign = alignValues[index];
     return true;
   }
       
   // Now that the deprecated stuff is out of the way, we move on to check the appropriate 
   // attribute.  For horizontal boxes, we are checking the PACK attribute.  For vertical boxes
   // we are checking the ALIGN attribute.
-  nsIAtom* attrName = IsHorizontal() ? nsGkAtoms::pack : nsGkAtoms::align;
+  nsIAtom* attrName = IsXULHorizontal() ? nsGkAtoms::pack : nsGkAtoms::align;
   static nsIContent::AttrValuesArray strings[] =
     {&nsGkAtoms::_empty, &nsGkAtoms::start, &nsGkAtoms::center, &nsGkAtoms::end, nullptr};
   static const Halignment values[] =
     {hAlign_Left/*not used*/, hAlign_Left, hAlign_Center, hAlign_Right};
   index = GetContent()->FindAttrValueIn(kNameSpaceID_None, attrName,
       strings, eCaseMatters);
 
   if (index == nsIContent::ATTR_VALUE_NO_MATCH) {
@@ -331,17 +331,17 @@ nsBoxFrame::GetInitialHAlignment(nsBoxFr
     aHalign = values[index];
     return true;
   }
 
   // Now that we've checked for the attribute it's time to check CSS.  For 
   // horizontal boxes we're checking PACK.  For vertical boxes we are checking
   // ALIGN.
   const nsStyleXUL* boxInfo = StyleXUL();
-  if (IsHorizontal()) {
+  if (IsXULHorizontal()) {
     switch (boxInfo->mBoxPack) {
       case NS_STYLE_BOX_PACK_START:
         aHalign = nsBoxFrame::hAlign_Left;
         return true;
       case NS_STYLE_BOX_PACK_CENTER:
         aHalign = nsBoxFrame::hAlign_Center;
         return true;
       case NS_STYLE_BOX_PACK_END:
@@ -385,17 +385,17 @@ nsBoxFrame::GetInitialVAlignment(nsBoxFr
   if (index >= 0) {
     aValign = valignValues[index];
     return true;
   }
 
   // Now that the deprecated stuff is out of the way, we move on to check the appropriate 
   // attribute.  For horizontal boxes, we are checking the ALIGN attribute.  For vertical boxes
   // we are checking the PACK attribute.
-  nsIAtom* attrName = IsHorizontal() ? nsGkAtoms::align : nsGkAtoms::pack;
+  nsIAtom* attrName = IsXULHorizontal() ? nsGkAtoms::align : nsGkAtoms::pack;
   static nsIContent::AttrValuesArray strings[] =
     {&nsGkAtoms::_empty, &nsGkAtoms::start, &nsGkAtoms::center,
      &nsGkAtoms::baseline, &nsGkAtoms::end, nullptr};
   static const Valignment values[] =
     {vAlign_Top/*not used*/, vAlign_Top, vAlign_Middle, vAlign_BaseLine, vAlign_Bottom};
   index = GetContent()->FindAttrValueIn(kNameSpaceID_None, attrName,
       strings, eCaseMatters);
   if (index == nsIContent::ATTR_VALUE_NO_MATCH) {
@@ -406,17 +406,17 @@ nsBoxFrame::GetInitialVAlignment(nsBoxFr
     aValign = values[index];
     return true;
   }
 
   // Now that we've checked for the attribute it's time to check CSS.  For 
   // horizontal boxes we're checking ALIGN.  For vertical boxes we are checking
   // PACK.
   const nsStyleXUL* boxInfo = StyleXUL();
-  if (IsHorizontal()) {
+  if (IsXULHorizontal()) {
     switch (boxInfo->mBoxAlign) {
       case NS_STYLE_BOX_ALIGN_START:
         aValign = nsBoxFrame::vAlign_Top;
         return true;
       case NS_STYLE_BOX_ALIGN_CENTER:
         aValign = nsBoxFrame::vAlign_Middle;
         return true;
       case NS_STYLE_BOX_ALIGN_BASELINE:
@@ -474,32 +474,32 @@ nsBoxFrame::GetInitialOrientation(bool& 
 }
 
 void
 nsBoxFrame::GetInitialDirection(bool& aIsNormal)
 {
   if (!GetContent())
     return;
 
-  if (IsHorizontal()) {
+  if (IsXULHorizontal()) {
     // For horizontal boxes only, we initialize our value based off the CSS 'direction' property.
     // This means that BiDI users will end up with horizontally inverted chrome.
     aIsNormal = (StyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR); // If text runs RTL then so do we.
   }
   else
     aIsNormal = true; // Assume a normal direction in the vertical case.
 
   // Now check the style system to see if we should invert aIsNormal.
   const nsStyleXUL* boxInfo = StyleXUL();
   if (boxInfo->mBoxDirection == NS_STYLE_BOX_DIRECTION_REVERSE)
     aIsNormal = !aIsNormal; // Invert our direction.
   
   // Now see if we have an attribute.  The attribute overrides
   // the style system value.
-  if (IsHorizontal()) {
+  if (IsXULHorizontal()) {
     static nsIContent::AttrValuesArray strings[] =
       {&nsGkAtoms::reverse, &nsGkAtoms::ltr, &nsGkAtoms::rtl, nullptr};
     int32_t index = GetContent()->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::dir,
         strings, eCaseMatters);
     if (index >= 0) {
       bool values[] = {!aIsNormal, true, false};
       aIsNormal = values[index];
     }
@@ -1401,17 +1401,17 @@ nsBoxFrame::PaintXULDebugBackground(Draw
 {
   nsMargin border;
   GetXULBorder(border);
 
   nsMargin debugBorder;
   nsMargin debugMargin;
   nsMargin debugPadding;
 
-  bool isHorizontal = IsHorizontal();
+  bool isHorizontal = IsXULHorizontal();
 
   GetDebugBorder(debugBorder);
   PixelMarginToTwips(debugBorder);
 
   GetDebugMargin(debugMargin);
   PixelMarginToTwips(debugMargin);
 
   GetDebugPadding(debugPadding);
@@ -1472,17 +1472,17 @@ nsBoxFrame::PaintXULDebugOverlay(DrawTar
   inner.MoveTo(aPt);
   inner.Deflate(debugMargin);
   inner.Deflate(border);
 
   nscoord onePixel = GetPresContext()->IntScaledPixelsToTwips(1);
 
   kid = nsBox::GetChildXULBox(this);
   while (nullptr != kid) {
-    bool isHorizontal = IsHorizontal();
+    bool isHorizontal = IsXULHorizontal();
 
     nscoord x, y, borderSize, spacerSize;
     
     nsRect cr(kid->mRect);
     nsMargin margin;
     kid->GetXULMargin(margin);
     cr.Inflate(margin);
     
@@ -1644,17 +1644,17 @@ nsBoxFrame::DrawSpacer(nsPresContext* aP
         FillRect(aDrawTarget, aHorizontal, x, y, spacerSize/2, spacerSize);
 }
 
 void
 nsBoxFrame::GetDebugBorder(nsMargin& aInset)
 {
     aInset.SizeTo(2,2,2,2);
 
-    if (IsHorizontal()) 
+    if (IsXULHorizontal()) 
        aInset.top = 10;
     else 
        aInset.left = 10;
 }
 
 void
 nsBoxFrame::GetDebugMargin(nsMargin& aInset)
 {
@@ -1721,17 +1721,17 @@ nsBoxFrame::DisplayDebugInfoFor(nsIFrame
 
     // get the area inside our border but not our debug margins.
     nsRect insideBorder(aBox->mRect);
     insideBorder.MoveTo(0,0):
     nsMargin border(0,0,0,0);
     aBox->GetXULBorderAndPadding(border);
     insideBorder.Deflate(border);
 
-    bool isHorizontal = IsHorizontal();
+    bool isHorizontal = IsXULHorizontal();
 
     if (!insideBorder.Contains(nsPoint(x,y)))
         return NS_ERROR_FAILURE;
 
     //printf("%%%%%% inside box %%%%%%%\n");
 
     int count = 0;
     nsIFrame* child = nsBox::GetChildXULBox(aBox);
diff --git a/layout/xul/nsScrollbarFrame.cpp b/layout/xul/nsScrollbarFrame.cpp
--- a/layout/xul/nsScrollbarFrame.cpp
+++ b/layout/xul/nsScrollbarFrame.cpp
@@ -175,31 +175,31 @@ nsScrollbarFrame::GetXULMargin(nsMargin&
   if (LookAndFeel::GetInt(LookAndFeel::eIntID_UseOverlayScrollbars) != 0) {
     nsPresContext* presContext = PresContext();
     nsITheme* theme = presContext->GetTheme();
     if (theme) {
       LayoutDeviceIntSize size;
       bool isOverridable;
       theme->GetMinimumWidgetSize(presContext, this, NS_THEME_SCROLLBAR, &size,
                                   &isOverridable);
-      if (IsHorizontal()) {
+      if (IsXULHorizontal()) {
         aMargin.top = -presContext->DevPixelsToAppUnits(size.height);
       }
       else {
         aMargin.left = -presContext->DevPixelsToAppUnits(size.width);
       }
       rv = NS_OK;
     }
   }
 
   if (NS_FAILED(rv)) {
     rv = nsBox::GetXULMargin(aMargin);
   }
 
-  if (NS_SUCCEEDED(rv) && !IsHorizontal()) {
+  if (NS_SUCCEEDED(rv) && !IsXULHorizontal()) {
     nsIScrollbarMediator* scrollFrame = GetScrollbarMediator();
     if (scrollFrame && !scrollFrame->IsScrollbarOnRight()) {
       Swap(aMargin.left, aMargin.right);
     }
   }
 
   return rv;
 }
diff --git a/layout/xul/nsSliderFrame.cpp b/layout/xul/nsSliderFrame.cpp
--- a/layout/xul/nsSliderFrame.cpp
+++ b/layout/xul/nsSliderFrame.cpp
@@ -415,31 +415,31 @@ nsSliderFrame::DoLayout(nsBoxLayoutState
   // get the scrollbar
   nsIFrame* scrollbarBox = GetScrollbar();
   nsCOMPtr<nsIContent> scrollbar;
   scrollbar = GetContentOfBox(scrollbarBox);
 
   // get the thumb's pref size
   nsSize thumbSize = thumbBox->GetXULPrefSize(aState);
 
-  if (IsHorizontal())
+  if (IsXULHorizontal())
     thumbSize.height = clientRect.height;
   else
     thumbSize.width = clientRect.width;
 
   int32_t curPos = GetCurrentPosition(scrollbar);
   int32_t minPos = GetMinPosition(scrollbar);
   int32_t maxPos = GetMaxPosition(scrollbar);
   int32_t pageIncrement = GetPageIncrement(scrollbar);
 
   maxPos = std::max(minPos, maxPos);
   curPos = clamped(curPos, minPos, maxPos);
 
-  nscoord& availableLength = IsHorizontal() ? clientRect.width : clientRect.height;
-  nscoord& thumbLength = IsHorizontal() ? thumbSize.width : thumbSize.height;
+  nscoord& availableLength = IsXULHorizontal() ? clientRect.width : clientRect.height;
+  nscoord& thumbLength = IsXULHorizontal() ? thumbSize.width : thumbSize.height;
 
   if ((pageIncrement + maxPos - minPos) > 0 && thumbBox->GetXULFlex() > 0) {
     float ratio = float(pageIncrement) / float(maxPos - minPos + pageIncrement);
     thumbLength = std::max(thumbLength, NSToCoordRound(availableLength * ratio));
   }
 
   // Round the thumb's length to device pixels.
   nsPresContext* presContext = PresContext();
@@ -453,17 +453,17 @@ nsSliderFrame::DoLayout(nsBoxLayoutState
   // right or bottom and increase leftwards or upwards. In this case, use the
   // offset from the end instead of the beginning.
   bool reverse = mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::dir,
                                          nsGkAtoms::reverse, eCaseMatters);
   nscoord pos = reverse ? (maxPos - curPos) : (curPos - minPos);
 
   // set the thumb's coord to be the current pos * the ratio.
   nsRect thumbRect(clientRect.x, clientRect.y, thumbSize.width, thumbSize.height);
-  int32_t& thumbPos = (IsHorizontal() ? thumbRect.x : thumbRect.y);
+  int32_t& thumbPos = (IsXULHorizontal() ? thumbRect.x : thumbRect.y);
   thumbPos += NSToCoordRound(pos * mRatio);
 
   nsRect oldThumbRect(thumbBox->GetRect());
   LayoutChildAt(aState, thumbBox, thumbRect);
 
   SyncLayout(aState);
 
   // Redraw only if thumb changed size.
@@ -491,17 +491,17 @@ nsSliderFrame::HandleEvent(nsPresContext
   if (!mDragFinished && !isDraggingThumb()) {
     StopDrag();
     return NS_OK;
   }
 
   nsIFrame* scrollbarBox = GetScrollbar();
   nsCOMPtr<nsIContent> scrollbar;
   scrollbar = GetContentOfBox(scrollbarBox);
-  bool isHorizontal = IsHorizontal();
+  bool isHorizontal = IsXULHorizontal();
 
   if (isDraggingThumb())
   {
     switch (aEvent->mMessage) {
     case eTouchMove:
     case eMouseMove: {
       if (mScrollingWithAPZ) {
         break;
@@ -754,27 +754,27 @@ nsSliderFrame::CurrentPositionChanged()
 
   // figure out the new rect
   nsRect newThumbRect(thumbRect);
 
   bool reverse = mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::dir,
                                          nsGkAtoms::reverse, eCaseMatters);
   nscoord pos = reverse ? (maxPos - curPos) : (curPos - minPos);
 
-  if (IsHorizontal())
+  if (IsXULHorizontal())
      newThumbRect.x = clientRect.x + NSToCoordRound(pos * mRatio);
   else
      newThumbRect.y = clientRect.y + NSToCoordRound(pos * mRatio);
 
   // avoid putting the scroll thumb at subpixel positions which cause needless invalidations
   nscoord appUnitsPerPixel = PresContext()->AppUnitsPerDevPixel();
   nsPoint snappedThumbLocation = ToAppUnits(
       newThumbRect.TopLeft().ToNearestPixels(appUnitsPerPixel),
       appUnitsPerPixel);
-  if (IsHorizontal()) {
+  if (IsXULHorizontal()) {
     newThumbRect.x = snappedThumbLocation.x;
   } else {
     newThumbRect.y = snappedThumbLocation.y;
   }
 
   // set the rect
   thumbFrame->SetRect(newThumbRect);
 
@@ -816,17 +816,17 @@ static void UpdateAttribute(nsIContent* 
 // of the scrollbar thumb, e.g. when dragging the slider. This function scrolls
 // the content in such a way that thumbRect.x/.y becomes aNewThumbPos.
 void
 nsSliderFrame::SetCurrentThumbPosition(nsIContent* aScrollbar, nscoord aNewThumbPos,
                                        bool aIsSmooth, bool aMaySnap)
 {
   nsRect crect;
   GetXULClientRect(crect);
-  nscoord offset = IsHorizontal() ? crect.x : crect.y;
+  nscoord offset = IsXULHorizontal() ? crect.x : crect.y;
   int32_t newPos = NSToIntRound((aNewThumbPos - offset) / mRatio);
   
   if (aMaySnap && mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::snap,
                                         nsGkAtoms::_true, eCaseMatters)) {
     // If snap="true", then the slider may only be set to min + (increment * x).
     // Otherwise, the slider may be set to any positive integer.
     int32_t increment = GetIncrement(aScrollbar);
     newPos = NSToIntRound(newPos / float(increment)) * increment;
@@ -963,17 +963,17 @@ nsSliderFrame::StartAPZDrag()
   CSSIntRect sliderTrackCSS = CSSIntRect::FromAppUnitsRounded(sliderTrack);
 
   uint64_t inputblockId = InputAPZContext::GetInputBlockId();
   uint32_t presShellId = PresContext()->PresShell()->GetPresShellId();
   AsyncDragMetrics dragMetrics(scrollTargetId, presShellId, inputblockId,
                                NSAppUnitsToIntPixels(mDragStart,
                                  float(AppUnitsPerCSSPixel())),
                                sliderTrackCSS,
-                               IsHorizontal() ? AsyncDragMetrics::HORIZONTAL :
+                               IsXULHorizontal() ? AsyncDragMetrics::HORIZONTAL :
                                                 AsyncDragMetrics::VERTICAL);
 
   if (!nsLayoutUtils::HasDisplayPort(scrollableContent)) {
     return false;
   }
 
   // When we start an APZ drag, we wont get mouse events for the drag.
   // APZ will consume them all and only notify us of the new scroll position.
@@ -996,17 +996,17 @@ nsSliderFrame::StartDrag(nsIDOMEvent* aE
   if (!ShouldScrollForEvent(event)) {
     return NS_OK;
   }
 
   nsPoint pt;
   if (!GetEventPoint(event, pt)) {
     return NS_OK;
   }
-  bool isHorizontal = IsHorizontal();
+  bool isHorizontal = IsXULHorizontal();
   nscoord pos = isHorizontal ? pt.x : pt.y;
 
   // If we should scroll-to-click, first place the middle of the slider thumb
   // under the mouse.
   nsCOMPtr<nsIContent> scrollbar;
   nscoord newpos = pos;
   bool scrollToClick = ShouldScrollToClickForEvent(event);
   if (scrollToClick) {
@@ -1230,17 +1230,17 @@ nsSliderFrame::IsEventOverThumb(WidgetGU
   nsRect thumbRect = thumbFrame->GetRect();
 #if defined(MOZ_WIDGET_GTK)
   /* Scrollbar track can have padding, so it's better to check that eventPoint
    * is inside of actual thumb, not just its one axis. The part of the scrollbar
    * track adjacent to thumb can actually receive events in GTK3 */
   return eventPoint.x >= thumbRect.x && eventPoint.x < thumbRect.XMost() &&
          eventPoint.y >= thumbRect.y && eventPoint.y < thumbRect.YMost();
 #else
-  bool isHorizontal = IsHorizontal();
+  bool isHorizontal = IsXULHorizontal();
   nscoord eventPos = isHorizontal ? eventPoint.x : eventPoint.y;
   nscoord thumbStart = isHorizontal ? thumbRect.x : thumbRect.y;
   nscoord thumbEnd = isHorizontal ? thumbRect.XMost() : thumbRect.YMost();
 
   return eventPos >= thumbStart && eventPos < thumbEnd;
 #endif
 }
 
@@ -1267,17 +1267,17 @@ nsSliderFrame::HandlePress(nsPresContext
   
   nsRect thumbRect = thumbFrame->GetRect();
   
   nscoord change = 1;
   nsPoint eventPoint;
   if (!GetEventPoint(aEvent, eventPoint)) {
     return NS_OK;
   }
-  if (IsHorizontal() ? eventPoint.x < thumbRect.x 
+  if (IsXULHorizontal() ? eventPoint.x < thumbRect.x 
                      : eventPoint.y < thumbRect.y)
     change = -1;
 
   mChange = change;
   DragThumb(true);
   // On Linux we want to keep scrolling in the direction indicated by |change|
   // until the mouse is released. On the other platforms we want to stop
   // scrolling as soon as the scrollbar thumb has reached the current mouse
@@ -1378,17 +1378,17 @@ nsSliderFrame::Notify(void)
 
     nsIFrame* thumbFrame = mFrames.FirstChild();
     if (!thumbFrame) {
       StopRepeat();
       return;
     }
     nsRect thumbRect = thumbFrame->GetRect();
 
-    bool isHorizontal = IsHorizontal();
+    bool isHorizontal = IsXULHorizontal();
 
     // See if the thumb has moved past our destination point.
     // if it has we want to stop.
     if (isHorizontal) {
         if (mChange < 0) {
             if (thumbRect.x < mDestinationPoint.x)
                 stop = true;
         } else {
diff --git a/layout/xul/nsSplitterFrame.cpp b/layout/xul/nsSplitterFrame.cpp
--- a/layout/xul/nsSplitterFrame.cpp
+++ b/layout/xul/nsSplitterFrame.cpp
@@ -224,17 +224,17 @@ nsSplitterFrame::DestroyFrom(nsIFrame* a
 
 nsresult
 nsSplitterFrame::GetCursor(const nsPoint&    aPoint,
                            nsIFrame::Cursor& aCursor)
 {
   return nsBoxFrame::GetCursor(aPoint, aCursor);
 
   /*
-    if (IsHorizontal())
+    if (IsXULHorizontal())
       aCursor = NS_STYLE_CURSOR_N_RESIZE;
     else
       aCursor = NS_STYLE_CURSOR_W_RESIZE;
 
     return NS_OK;
   */
 }
 
@@ -275,17 +275,17 @@ nsSplitterFrame::Init(nsIContent*       
   mInner->mState = nsSplitterFrameInner::Open;
   mInner->mDragging = false;
 
   // determine orientation of parent, and if vertical, set orient to vertical
   // on splitter content, then re-resolve style
   // XXXbz this is pretty messed up, since this can change whether we should
   // have a frame at all.  This really needs a better solution.
   if (aParent && aParent->IsXULBoxFrame()) {
-    if (!aParent->IsHorizontal()) {
+    if (!aParent->IsXULHorizontal()) {
       if (!nsContentUtils::HasNonEmptyAttr(aContent, kNameSpaceID_None,
                                            nsGkAtoms::orient)) {
         aContent->SetAttr(kNameSpaceID_None, nsGkAtoms::orient,
                           NS_LITERAL_STRING("vertical"), false);
         nsStyleContext* parentStyleContext = StyleContext()->GetParent();
         RefPtr<nsStyleContext> newContext = PresContext()->StyleSet()->
           ResolveStyleFor(aContent->AsElement(), parentStyleContext);
         SetStyleContextWithoutNotification(newContext);
@@ -313,17 +313,17 @@ nsSplitterFrame::DoLayout(nsBoxLayoutSta
 }
 
 
 void
 nsSplitterFrame::GetInitialOrientation(bool& aIsHorizontal)
 {
   nsIFrame* box = nsBox::GetParentXULBox(this);
   if (box) {
-    aIsHorizontal = !box->IsHorizontal();
+    aIsHorizontal = !box->IsXULHorizontal();
   }
   else
     nsBoxFrame::GetInitialOrientation(aIsHorizontal);
 }
 
 NS_IMETHODIMP
 nsSplitterFrame::HandlePress(nsPresContext* aPresContext,
                              WidgetGUIEvent* aEvent,
@@ -439,17 +439,17 @@ nsSplitterFrameInner::MouseUp(nsPresCont
 void
 nsSplitterFrameInner::MouseDrag(nsPresContext* aPresContext,
                                 WidgetGUIEvent* aEvent)
 {
   if (mDragging && mOuter) {
 
     //printf("Dragging\n");
 
-    bool isHorizontal = !mOuter->IsHorizontal();
+    bool isHorizontal = !mOuter->IsXULHorizontal();
     // convert coord to pixels
     nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent,
                                                               mParentBox);
     nscoord pos = isHorizontal ? pt.x : pt.y;
 
     // mDragStart is in frame coordinates
     nscoord start = mDragStart;
 
@@ -639,17 +639,17 @@ nsSplitterFrameInner::MouseDown(nsIDOMEv
     outerPresContext->PresShell()->CreateReferenceRenderingContext());
   nsBoxLayoutState state(outerPresContext, &rc);
   mCurrentPos = 0;
   mPressed = true;
 
   mDidDrag = false;
 
   EnsureOrient();
-  bool isHorizontal = !mOuter->IsHorizontal();
+  bool isHorizontal = !mOuter->IsXULHorizontal();
   
   ResizeType resizeBefore = GetResizeBefore();
   ResizeType resizeAfter  = GetResizeAfter();
 
   mChildInfosBefore = MakeUnique<nsSplitterInfo[]>(childCount);
   mChildInfosAfter  = MakeUnique<nsSplitterInfo[]>(childCount);
 
   // create info 2 lists. One of the children before us and one after.
@@ -882,17 +882,17 @@ nsSplitterFrameInner::EnsureOrient()
   else
     mOuter->mState &= ~NS_STATE_IS_HORIZONTAL;
 }
 
 void
 nsSplitterFrameInner::AdjustChildren(nsPresContext* aPresContext)
 {
   EnsureOrient();
-  bool isHorizontal = !mOuter->IsHorizontal();
+  bool isHorizontal = !mOuter->IsXULHorizontal();
 
   AdjustChildren(aPresContext, mChildInfosBefore.get(),
                  mChildInfosBeforeCount, isHorizontal);
   AdjustChildren(aPresContext, mChildInfosAfter.get(),
                  mChildInfosAfterCount, isHorizontal);
 }
 
 static nsIFrame* GetChildBoxForContent(nsIFrame* aParentBox, nsIContent* aContent)
diff --git a/layout/xul/nsSprocketLayout.cpp b/layout/xul/nsSprocketLayout.cpp
--- a/layout/xul/nsSprocketLayout.cpp
+++ b/layout/xul/nsSprocketLayout.cpp
@@ -49,17 +49,17 @@ nsSprocketLayout::Shutdown()
   NS_IF_RELEASE(gInstance);
 }
 
 nsSprocketLayout::nsSprocketLayout()
 {
 }
 
 bool 
-nsSprocketLayout::IsHorizontal(nsIFrame* aBox)
+nsSprocketLayout::IsXULHorizontal(nsIFrame* aBox)
 {
    return (aBox->GetStateBits() & NS_STATE_IS_HORIZONTAL) != 0;
 }
 
 void
 nsSprocketLayout::GetFrameState(nsIFrame* aBox, nsFrameState& aState)
 {
    aState = aBox->GetStateBits();
@@ -214,30 +214,30 @@ nsSprocketLayout::XULLayout(nsIFrame* aB
   nscoord max = 0;
   int32_t flexes = 0;
   PopulateBoxSizes(aBox, aState, boxSizes, min, max, flexes);
   
   // The |size| variable will hold the total size of children along the axis of
   // the box.  Continuing with the example begun in the comment above, size would
   // be 150 pixels.
   nscoord size = clientRect.width;
-  if (!IsHorizontal(aBox))
+  if (!IsXULHorizontal(aBox))
     size = clientRect.height;
   ComputeChildSizes(aBox, aState, size, boxSizes, computedBoxSizes);
 
   // After the call to ComputeChildSizes, the |size| variable contains the
   // total required size of all the children.  We adjust our clientRect in the
   // appropriate dimension to match this size.  In our example, we now assign
   // 150 pixels into the clientRect.width.
   //
   // The variables |min| and |max| hold the minimum required size box must be 
   // in the OPPOSITE orientation, e.g., for a horizontal box, |min| is the minimum
   // height we require to enclose our children, and |max| is the maximum height
   // required to enclose our children.
-  if (IsHorizontal(aBox)) {
+  if (IsXULHorizontal(aBox)) {
     clientRect.width = size;
     if (clientRect.height < min)
       clientRect.height = min;
 
     if (frameState & NS_STATE_AUTO_STRETCH) {
       if (clientRect.height > max)
         clientRect.height = max;
     }
@@ -657,17 +657,17 @@ nsSprocketLayout::PopulateBoxSizes(nsIFr
   //if (frameState & NS_STATE_CURRENTLY_IN_DEBUG)
   //   printf("In debug\n");
 
   aMinSize = 0;
   aMaxSize = NS_INTRINSICSIZE;
 
   bool isHorizontal;
 
-  if (IsHorizontal(aBox))
+  if (IsXULHorizontal(aBox))
      isHorizontal = true;
   else
      isHorizontal = false;
 
   // this is a nice little optimization
   // it turns out that if we only have 1 flexable child
   // then it does not matter what its preferred size is
   // there is nothing to flex it relative. This is great
@@ -895,17 +895,17 @@ nsSprocketLayout::ComputeChildsNextPosit
                                       nscoord& aNextY, 
                                       const nsRect& aCurrentChildSize)
 {
   // Get the position along the box axis for the child.
   // The out-of-axis position is not set.
   nsFrameState frameState = nsFrameState(0);
   GetFrameState(aBox, frameState);
 
-  if (IsHorizontal(aBox)) {
+  if (IsXULHorizontal(aBox)) {
     // horizontal box's children.
     if (frameState & NS_STATE_IS_DIRECTION_NORMAL)
       aNextX = aCurX + aCurrentChildSize.width;
     else
       aNextX = aCurX - aCurrentChildSize.width;
 
   } else {
     // vertical box's children.
@@ -1022,17 +1022,17 @@ nsSprocketLayout::ChildResized(nsIFrame*
                          nsRect& aChildActualRect, 
                          nsRect& aContainingRect,
                          int32_t aFlexes, 
                          bool& aFinished)
                          
 {
       nsRect childCurrentRect(aChildLayoutRect);
 
-      bool isHorizontal = IsHorizontal(aBox);
+      bool isHorizontal = IsXULHorizontal(aBox);
       nscoord childLayoutWidth  = GET_WIDTH(aChildLayoutRect,isHorizontal);
       nscoord& childActualWidth  = GET_WIDTH(aChildActualRect,isHorizontal);
       nscoord& containingWidth   = GET_WIDTH(aContainingRect,isHorizontal);   
       
       //nscoord childLayoutHeight = GET_HEIGHT(aChildLayoutRect,isHorizontal);
       nscoord& childActualHeight = GET_HEIGHT(aChildActualRect,isHorizontal);
       nscoord& containingHeight  = GET_HEIGHT(aContainingRect,isHorizontal);
 
@@ -1302,17 +1302,17 @@ nsSprocketLayout::ComputeChildSizes(nsIF
   }
 }
 
 
 nsSize
 nsSprocketLayout::GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
    nsSize vpref (0, 0); 
-   bool isHorizontal = IsHorizontal(aBox);
+   bool isHorizontal = IsXULHorizontal(aBox);
 
    nscoord biggestPref = 0;
 
    // run through all the children and get their min, max, and preferred sizes
    // return us the size of the box
 
    nsIFrame* child = nsBox::GetChildXULBox(aBox);
    nsFrameState frameState = nsFrameState(0);
@@ -1358,17 +1358,17 @@ nsSprocketLayout::GetXULPrefSize(nsIFram
 
   return vpref;
 }
 
 nsSize
 nsSprocketLayout::GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
    nsSize minSize (0, 0);
-   bool isHorizontal = IsHorizontal(aBox);
+   bool isHorizontal = IsXULHorizontal(aBox);
 
    nscoord biggestMin = 0;
 
 
    // run through all the children and get their min, max, and preferred sizes
    // return us the size of the box
 
    nsIFrame* child = nsBox::GetChildXULBox(aBox);
@@ -1427,17 +1427,17 @@ nsSprocketLayout::GetXULMinSize(nsIFrame
 
   return minSize;
 }
 
 nsSize
 nsSprocketLayout::GetXULMaxSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
 
-  bool isHorizontal = IsHorizontal(aBox);
+  bool isHorizontal = IsXULHorizontal(aBox);
 
    nscoord smallestMax = NS_INTRINSICSIZE;
    nsSize maxSize (NS_INTRINSICSIZE, NS_INTRINSICSIZE);
 
    // run through all the children and get their min, max, and preferred sizes
    // return us the size of the box
 
    nsIFrame* child = nsBox::GetChildXULBox(aBox);
@@ -1495,17 +1495,17 @@ nsSprocketLayout::GetXULMaxSize(nsIFrame
 }
 
 
 nscoord
 nsSprocketLayout::GetAscent(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
    nscoord vAscent = 0;
 
-   bool isHorizontal = IsHorizontal(aBox);
+   bool isHorizontal = IsXULHorizontal(aBox);
 
    // run through all the children and get their min, max, and preferred sizes
    // return us the size of the box
    
    nsIFrame* child = nsBox::GetChildXULBox(aBox);
    
    while (child) 
    {  
diff --git a/layout/xul/nsSprocketLayout.h b/layout/xul/nsSprocketLayout.h
--- a/layout/xul/nsSprocketLayout.h
+++ b/layout/xul/nsSprocketLayout.h
@@ -72,17 +72,17 @@ public:
 
   virtual nsSize GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetAscent(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
 
   nsSprocketLayout();
 
-  static bool IsHorizontal(nsIFrame* aBox);
+  static bool IsXULHorizontal(nsIFrame* aBox);
 
   static void SetLargestSize(nsSize& aSize1, const nsSize& aSize2, bool aIsHorizontal);
   static void SetSmallestSize(nsSize& aSize1, const nsSize& aSize2, bool aIsHorizontal);
 
   static void AddLargestSize(nsSize& aSize, const nsSize& aSizeToAdd, bool aIsHorizontal);
   static void AddSmallestSize(nsSize& aSize, const nsSize& aSizeToAdd, bool aIsHorizontal);
   static void AddCoord(nscoord& aCoord, nscoord aCoordToAdd);
 
diff --git a/layout/xul/tree/nsTreeBodyFrame.cpp b/layout/xul/tree/nsTreeBodyFrame.cpp
--- a/layout/xul/tree/nsTreeBodyFrame.cpp
+++ b/layout/xul/tree/nsTreeBodyFrame.cpp
@@ -797,17 +797,17 @@ FindScrollParts(nsIFrame* aCurrFrame, ns
     if (f) {
       aResult->mColumnsFrame = aCurrFrame;
       aResult->mColumnsScrollFrame = f;
     }
   }
   
   nsScrollbarFrame *sf = do_QueryFrame(aCurrFrame);
   if (sf) {
-    if (!aCurrFrame->IsHorizontal()) {
+    if (!aCurrFrame->IsXULHorizontal()) {
       if (!aResult->mVScrollbar) {
         aResult->mVScrollbar = sf;
       }
     } else {
       if (!aResult->mHScrollbar) {
         aResult->mHScrollbar = sf;
       }
     }
@@ -4358,17 +4358,17 @@ nsTreeBodyFrame::RepeatButtonScroll(nsSc
   ScrollParts parts = GetScrollParts();
   int32_t increment = aScrollbar->GetIncrement();
   int32_t direction = 0;
   if (increment < 0) {
     direction = -1;
   } else if (increment > 0) {
     direction = 1;
   }
-  bool isHorizontal = aScrollbar->IsHorizontal();
+  bool isHorizontal = aScrollbar->IsXULHorizontal();
 
   nsWeakFrame weakFrame(this);
   if (isHorizontal) {
     int32_t curpos = aScrollbar->MoveToNewPosition();
     if (weakFrame.IsAlive()) {
       ScrollHorzInternal(parts, curpos);
     }
   } else {
