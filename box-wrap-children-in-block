Make boxes that have non-box non-block children wrap all their children in a block.  b=321402

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -6182,10 +6182,24 @@ nsCSSFrameConstructor::ConstructXULFrame
     // Process the child content if requested
     nsFrameItems childItems;
     if (!newFrame->IsLeaf()) {
+      nsIFrame *insertionPoint = newFrame;
+      if (aContent == mXULContentReframingForWrapper) {
+        nsRefPtr<nsStyleContext> blockSC = mPresShell->StyleSet()->
+          ResolvePseudoStyleFor(aContent, nsCSSAnonBoxes::mozAnonymousBlock,
+                                aStyleContext);
+        nsIFrame *blockFrame = NS_NewBlockFrame(mPresShell, blockSC);
+        // We might, in theory, want to set NS_BLOCK_SPACE_MGR and
+        // NS_BLOCK_MARGIN_ROOT, but I think it's a bad idea given that
+        // a real block placed here wouldn't get those set on it.
+        newFrame->AppendFrames(nsnull, blockFrame);
+        newFrame->AddStateBits(NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK);
+        insertionPoint = blockFrame;
+      }
+
       // XXXbz don't we need calls to ShouldBuildChildFrames
       // elsewhere too?  Why only for XUL?
       if (mDocument->BindingManager()->ShouldBuildChildFrames(aContent)) {
-        rv = ProcessChildren(aState, aContent, newFrame, PR_FALSE,
+        rv = ProcessChildren(aState, aContent, insertionPoint, PR_FALSE,
                              childItems, PR_FALSE);
       }
     }
@@ -12841,6 +12855,55 @@ nsCSSFrameConstructor::ProcessInlineChil
   return rv;
 }
 
+static void
+DestroyNewlyCreatedFrames(nsFrameConstructorState& aState,
+                          nsIFrame* aParentFrame,
+                          const nsFrameItems& aFrameList)
+{
+  // Ok, reverse tracks: wipe out the frames we just created
+  nsFrameManager *frameManager = aState.mFrameManager;
+
+  // Destroy the frames. As we do make sure any content to frame mappings
+  // or entries in the undisplayed content map are removed
+  frameManager->ClearAllUndisplayedContentIn(aParentFrame->GetContent());
+
+  CleanupFrameReferences(frameManager, aFrameList.childList);
+  if (aState.mAbsoluteItems.childList) {
+    CleanupFrameReferences(frameManager, aState.mAbsoluteItems.childList);
+  }
+  if (aState.mFixedItems.childList) {
+    CleanupFrameReferences(frameManager, aState.mFixedItems.childList);
+  }
+  if (aState.mFloatedItems.childList) {
+    CleanupFrameReferences(frameManager, aState.mFloatedItems.childList);
+  }
+#ifdef MOZ_XUL
+  if (aState.mPopupItems.childList) {
+    CleanupFrameReferences(frameManager, aState.mPopupItems.childList);
+  }
+#endif
+  nsFrameList tmp(aFrameList.childList);
+  tmp.DestroyFrames();
+
+  tmp.SetFrames(aState.mAbsoluteItems.childList);
+  tmp.DestroyFrames();
+  aState.mAbsoluteItems.childList = nsnull;
+
+  tmp.SetFrames(aState.mFixedItems.childList);
+  tmp.DestroyFrames();
+  aState.mFixedItems.childList = nsnull;
+
+  tmp.SetFrames(aState.mFloatedItems.childList);
+  tmp.DestroyFrames();
+  aState.mFloatedItems.childList = nsnull;
+
+#ifdef MOZ_XUL
+  tmp.SetFrames(aState.mPopupItems.childList);
+  tmp.DestroyFrames();
+  aState.mPopupItems.childList = nsnull;
+#endif
+}
+
 PRBool
 nsCSSFrameConstructor::WipeContainingBlock(nsFrameConstructorState& aState,
                                            nsIFrame* aContainingBlock,
@@ -12853,8 +12916,33 @@ nsCSSFrameConstructor::WipeContainingBlo
     return PR_FALSE;
   }
   
-  // Before we go and append the frames, check for a special
-  // situation: an inline frame that will now contain block
+  // Before we go and append the frames, we must check for two
+  // special situations.
+
+  // Situation #1 is a XUL frame that contains frames that are required
+  // to be wrapped in blocks.
+  if (aFrame->IsBoxFrame() &&
+      !(aFrame->GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK)) {
+    PRBool needWrapper = PR_FALSE;
+    for (nsIFrame *k = aFrameList.childList; k; k = k->GetNextSibling()) {
+      if (k->IsFrameOfType(nsIFrame::eLineParticipant) &&
+          k->GetType() != nsGkAtoms::textFrame) {
+        needWrapper = PR_TRUE;
+        break;
+      }
+    }
+
+    if (needWrapper) {
+      // XXX print warning to the JS console.
+      DestroyNewlyCreatedFrames(aState, aFrame, aFrameList);
+      mXULContentReframingForWrapper = aFrame->GetContent();
+      RecreateFramesForContent(mXULContentReframingForWrapper);
+      mXULContentReframingForWrapper = nsnull;
+      return PR_TRUE;
+    }
+  }
+
+  // Situation #2 is an inline frame that will now contain block
   // frames. This is a no-no and the frame construction logic knows
   // how to fix this.  See defition of IsInlineFrame() for what "an
   // inline" is.  Whether we have "a block" is tested for by
@@ -12916,48 +13004,7 @@ nsCSSFrameConstructor::WipeContainingBlo
     }
   }
 
-  // Ok, reverse tracks: wipe out the frames we just created
-  nsFrameManager *frameManager = aState.mFrameManager;
-
-  // Destroy the frames. As we do make sure any content to frame mappings
-  // or entries in the undisplayed content map are removed
-  frameManager->ClearAllUndisplayedContentIn(aFrame->GetContent());
-
-  CleanupFrameReferences(frameManager, aFrameList.childList);
-  if (aState.mAbsoluteItems.childList) {
-    CleanupFrameReferences(frameManager, aState.mAbsoluteItems.childList);
-  }
-  if (aState.mFixedItems.childList) {
-    CleanupFrameReferences(frameManager, aState.mFixedItems.childList);
-  }
-  if (aState.mFloatedItems.childList) {
-    CleanupFrameReferences(frameManager, aState.mFloatedItems.childList);
-  }
-#ifdef MOZ_XUL
-  if (aState.mPopupItems.childList) {
-    CleanupFrameReferences(frameManager, aState.mPopupItems.childList);
-  }
-#endif
-  nsFrameList tmp(aFrameList.childList);
-  tmp.DestroyFrames();
-
-  tmp.SetFrames(aState.mAbsoluteItems.childList);
-  tmp.DestroyFrames();
-  aState.mAbsoluteItems.childList = nsnull;
-
-  tmp.SetFrames(aState.mFixedItems.childList);
-  tmp.DestroyFrames();
-  aState.mFixedItems.childList = nsnull;
-
-  tmp.SetFrames(aState.mFloatedItems.childList);
-  tmp.DestroyFrames();
-  aState.mFloatedItems.childList = nsnull;
-
-#ifdef MOZ_XUL
-  tmp.SetFrames(aState.mPopupItems.childList);
-  tmp.DestroyFrames();
-  aState.mPopupItems.childList = nsnull;
-#endif
+  DestroyNewlyCreatedFrames(aState, aFrame, aFrameList);
 
   // If we don't have a containing block, start with aFrame and look for one.
   if (!aContainingBlock) {
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -1115,6 +1115,7 @@ private:
   nsRevocableEventPtr<RestyleEvent> mRestyleEvent;
 
   nsCOMPtr<nsILayoutHistoryState> mTempFrameTreeState;
+  nsCOMPtr<nsIContent> mXULContentReframingForWrapper;
 
   nsDataHashtable<nsISupportsHashKey, RestyleData> mPendingRestyles;
 
diff --git a/layout/xul/base/src/nsBoxFrame.cpp b/layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp
+++ b/layout/xul/base/src/nsBoxFrame.cpp
@@ -1038,8 +1038,12 @@ nsBoxFrame::InsertFrames(nsIAtom*       
    NS_PRECONDITION(!aListName, "We don't support out-of-flow kids");
    nsBoxLayoutState state(PresContext());
 
+   // XXX CHECK THE FRAMES FOR THINGS THAT REQUIRE BLOCK-WRAPPING
+
    // insert the child frames
    mFrames.InsertFrames(this, aPrevFrame, aFrameList);
+
+   // XXX IF BLOCK_WRAPPING NEEDED, DO IT HERE
 
    // notify the layout manager
    if (mLayoutManager)
@@ -1065,8 +1069,12 @@ nsBoxFrame::AppendFrames(nsIAtom*       
    NS_PRECONDITION(!aListName, "We don't support out-of-flow kids");
    nsBoxLayoutState state(PresContext());
 
+   // XXX CHECK THE FRAMES FOR THINGS THAT REQUIRE BLOCK-WRAPPING
+
    // append the new frames
    mFrames.AppendFrames(this, aFrameList);
+
+   // XXX IF BLOCK_WRAPPING NEEDED, DO IT HERE
 
    // notify the layout manager
    if (mLayoutManager)
diff --git a/layout/xul/base/src/nsBoxFrame.h b/layout/xul/base/src/nsBoxFrame.h
--- a/layout/xul/base/src/nsBoxFrame.h
+++ b/layout/xul/base/src/nsBoxFrame.h
@@ -55,12 +55,12 @@ class nsBoxLayoutState;
 #define NS_STATE_STACK_NOT_POSITIONED    0x00200000
 //#define NS_STATE_IS_HORIZONTAL           0x00400000  moved to nsIFrame.h
 #define NS_STATE_AUTO_STRETCH            0x00800000
-//#define NS_STATE_IS_ROOT                 0x01000000  moved to nsIFrame.h
+//#define NS_STATE_IS_ROOT                 0x01000000  moved to nsBox.h
 #define NS_STATE_CURRENTLY_IN_DEBUG      0x02000000
-//#define NS_STATE_SET_TO_DEBUG            0x04000000  moved to nsIFrame.h
-//#define NS_STATE_DEBUG_WAS_SET           0x08000000  moved to nsIFrame.h
+//#define NS_STATE_SET_TO_DEBUG            0x04000000  moved to nsBox.h
+//#define NS_STATE_DEBUG_WAS_SET           0x08000000  moved to nsBox.h
 #define NS_STATE_IS_COLLAPSED            0x10000000
-//#define NS_STATE_STYLE_CHANGE            0x20000000  moved to nsIFrame.h
+#define NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK 0x20000000
 #define NS_STATE_EQUAL_SIZE              0x40000000
 //#define NS_STATE_IS_DIRECTION_NORMAL     0x80000000  moved to nsIFrame.h
 
@@ -133,6 +133,9 @@ public:
 
   NS_IMETHOD  RemoveFrame(nsIAtom*        aListName,
                           nsIFrame*       aOldFrame);
+
+  // FIXME: Implement GetContentInsertionFrame to check
+  // NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK
 
   NS_IMETHOD  SetInitialChildList(nsIAtom*        aListName,
                                   nsIFrame*       aChildList);
