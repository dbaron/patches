Make boxes that have non-box non-block children wrap all their children in a block.  b=321402

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -9228,6 +9228,38 @@ nsCSSFrameConstructor::ReinsertContent(n
   return res;
 }
 
+nsresult
+nsCSSFrameConstructor::StartReconstructAllChildren(nsIFrame* aFrame)
+{
+  // XXX We need to do ClearAllUndisplayedContentIn if this frame is the
+  // style context parent for its content node's children.
+
+  PRInt32 listIndex = 0;
+  nsIAtom* childList = nsnull;
+
+  do {
+    for (nsIFrame* child = aFrame->GetFirstChild(childList); child;
+         child = child->GetNextSibling()) {
+      CaptureStateFor(child, mTempFrameTreeState);
+      RemoveChildFrame(child);
+    }
+    childList = aFrame->GetAdditionalChildListName(listIndex++);
+  } while (childList);
+  return NS_OK;
+}
+
+nsresult
+nsCSSFrameConstructor::FinishReconstructAllChildren(nsIFrame* aFrame)
+{
+  nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
+                                GetAbsoluteContainingBlock(parentFrame),
+                                GetFloatContainingBlock(parentFrame),
+                                mTempFrameTreeState);
+  // XXX WRITE ME
+  // ProcessChildren (with the frame tree state passed to ContentInserted)
+  return NS_OK;
+}
+
 /**
  * Called when a frame subtree is about to be deleted. Two important
  * things happen:
@@ -9424,11 +9456,10 @@ nsCSSFrameConstructor::ContentRemoved(ns
 
   nsFrameManager *frameManager = mPresShell->FrameManager();
   nsPresContext *presContext = mPresShell->GetPresContext();
-  nsresult                  rv = NS_OK;
 
   // Find the child frame that maps the content
   nsIFrame* childFrame =
-    mPresShell->FrameManager()->GetPrimaryFrameFor(aChild, aIndexInContainer);
+    frameManager->GetPrimaryFrameFor(aChild, aIndexInContainer);
 
   if (! childFrame) {
     frameManager->ClearUndisplayedContentIn(aChild, aContainer);
@@ -9441,148 +9472,165 @@ nsCSSFrameConstructor::ContentRemoved(ns
 
 #endif // MOZ_XUL
 
-  if (childFrame) {
-    InvalidateCanvasIfNeeded(childFrame);
-    
-    // If the frame we are manipulating is a special frame then do
-    // something different instead of just inserting newly created
-    // frames.
-    // NOTE: if we are in ReinsertContent, 
-    //       then do not reframe as we are already doing just that!
-    if (!aInReinsertContent &&
-        MaybeRecreateContainerForIBSplitterFrame(childFrame, &rv)) {
-      return rv;
-    }
-
-    // Get the childFrame's parent frame
-    nsIFrame* parentFrame = childFrame->GetParent();
-
-    if (parentFrame->GetType() == nsGkAtoms::frameSetFrame &&
-        IsSpecialFramesetChild(aChild)) {
-      // Just reframe the parent, since framesets are weird like that.
-      return RecreateFramesForContent(parentFrame->GetContent());
-    }
-
-    // Examine the containing-block for the removed content and see if
-    // :first-letter style applies.
-    nsIFrame* containingBlock = GetFloatContainingBlock(parentFrame);
-    PRBool haveFLS = containingBlock && HasFirstLetterStyle(containingBlock);
-    if (haveFLS) {
-      // Trap out to special routine that handles adjusting a blocks
-      // frame tree when first-letter style is present.
+  if (!childFrame)
+    return NS_OK;
+
+  // If the frame we are manipulating is a special frame then do
+  // something different instead of just inserting newly created
+  // frames.
+  // NOTE: if we are in ReinsertContent, 
+  //       then do not reframe as we are already doing just that!
+  nsresult rv = NS_OK;
+  if (!aInReinsertContent &&
+      MaybeRecreateContainerForIBSplitterFrame(childFrame, &rv)) {
+    return rv;
+  }
+
+  // Get childFrame's parent frame
+  nsIFrame* parentFrame = childFrame->GetParent();
+
+  if (parentFrame->GetType() == nsGkAtoms::frameSetFrame &&
+      IsSpecialFramesetChild(aChild)) {
+    // Just reframe the parent, since framesets are weird like that.
+    return RecreateFramesForContent(parentFrame->GetContent());
+  }
+  
+  // Examine the containing-block for the removed content and see if
+  // :first-letter style applies.
+  nsIFrame* containingBlock = GetFloatContainingBlock(parentFrame);
+  PRBool haveFLS = containingBlock && HasFirstLetterStyle(containingBlock);
+  if (haveFLS) {
+    // Trap out to special routine that handles adjusting a blocks
+    // frame tree when first-letter style is present.
 #ifdef NOISY_FIRST_LETTER
-      printf("ContentRemoved: containingBlock=");
-      nsFrame::ListTag(stdout, containingBlock);
-      printf(" parentFrame=");
-      nsFrame::ListTag(stdout, parentFrame);
-      printf(" childFrame=");
-      nsFrame::ListTag(stdout, childFrame);
-      printf("\n");
+    printf("ContentRemoved: containingBlock=");
+    nsFrame::ListTag(stdout, containingBlock);
+    printf(" parentFrame=");
+    nsFrame::ListTag(stdout, parentFrame);
+    printf(" childFrame=");
+    nsFrame::ListTag(stdout, childFrame);
+    printf("\n");
 #endif
 
-      // First update the containing blocks structure by removing the
-      // existing letter frames. This makes the subsequent logic
-      // simpler.
-      RemoveLetterFrames(presContext, mPresShell, frameManager,
-                         containingBlock);
-
-      // Recover childFrame and parentFrame
-      childFrame = mPresShell->GetPrimaryFrameFor(aChild);
-      if (!childFrame) {
-        frameManager->ClearUndisplayedContentIn(aChild, aContainer);
-        return NS_OK;
-      }
-      parentFrame = childFrame->GetParent();
+    // First update the containing blocks structure by removing the
+    // existing letter frames. This makes the subsequent logic
+    // simpler.
+    RemoveLetterFrames(presContext, mPresShell, frameManager,
+                       containingBlock);
+
+    // Recover childFrame and parentFrame
+    childFrame = mPresShell->GetPrimaryFrameFor(aChild);
+    if (!childFrame) {
+      frameManager->ClearUndisplayedContentIn(aChild, aContainer);
+      return NS_OK;
+    }
+    parentFrame = childFrame->GetParent();
 
 #ifdef NOISY_FIRST_LETTER
-      printf("  ==> revised parentFrame=");
-      nsFrame::ListTag(stdout, parentFrame);
-      printf(" childFrame=");
-      nsFrame::ListTag(stdout, childFrame);
-      printf("\n");
+    printf("  ==> revised parentFrame=");
+    nsFrame::ListTag(stdout, parentFrame);
+    printf(" childFrame=");
+    nsFrame::ListTag(stdout, childFrame);
+    printf("\n");
 #endif
-    }
+  }
 
 #ifdef DEBUG
-    if (gReallyNoisyContentUpdates) {
-      printf("nsCSSFrameConstructor::ContentRemoved: childFrame=");
-      nsFrame::ListTag(stdout, childFrame);
-      printf("\n");
-
-      nsIFrameDebug* fdbg = nsnull;
-      CallQueryInterface(parentFrame, &fdbg);
-      if (fdbg)
-        fdbg->List(stdout, 0);
-    }
+  if (gReallyNoisyContentUpdates) {
+    printf("nsCSSFrameConstructor::ContentRemoved: childFrame=");
+    nsFrame::ListTag(stdout, childFrame);
+    printf("\n");
+
+    nsIFrameDebug* fdbg = nsnull;
+    CallQueryInterface(parentFrame, &fdbg);
+    if (fdbg)
+      fdbg->List(stdout, 0);
+  }
 #endif
 
-    // Walk the frame subtree deleting any out-of-flow frames, and
-    // remove the mapping from content objects to frames
-    ::DeletingFrameSubtree(frameManager, childFrame);
-
-    // See if the child frame is an out-of-flow
-    if (childFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
-      nsPlaceholderFrame* placeholderFrame =
-        frameManager->GetPlaceholderFrameFor(childFrame);
-      NS_ASSERTION(placeholderFrame, "No placeholder for out-of-flow?");
-
-      UnregisterPlaceholderChain(frameManager, placeholderFrame);
-
-      // Now we remove the out-of-flow frame
-      // XXX has to be done first for now: for floats, the block's line list
-      // contains an array of pointers to the placeholder - we have to
-      // remove the float first (which gets rid of the lines
-      // reference to the placeholder and float) and then remove the
-      // placeholder
-      rv = frameManager->RemoveFrame(parentFrame,
-                                     GetChildListNameFor(childFrame),
-                                     childFrame);
-
-      // Remove the placeholder frame first (XXX second for now) (so
-      // that it doesn't retain a dangling pointer to memory)
-      nsIFrame* placeholderParent = placeholderFrame->GetParent();
-      ::DeletingFrameSubtree(frameManager, placeholderFrame);
-      rv |= frameManager->RemoveFrame(placeholderParent,
-                                      nsnull, placeholderFrame);
-    } else {
-      // Notify the parent frame that it should delete the frame
-      // check for a table caption which goes on an additional child list with a different parent
-      nsIFrame* outerTableFrame; 
-      if (GetCaptionAdjustedParent(parentFrame, childFrame, &outerTableFrame)) {
-        rv = frameManager->RemoveFrame(outerTableFrame,
-                                       nsGkAtoms::captionList,
-                                       childFrame);
-      }
-      else {
-        rv = frameManager->RemoveFrame(parentFrame, nsnull, childFrame);
-      }
-    }
-
-    if (mInitialContainingBlock == childFrame) {
-      mInitialContainingBlock = nsnull;
-      mInitialContainingBlockIsAbsPosContainer = PR_FALSE;
-    }
-
-    if (haveFLS && mInitialContainingBlock) {
-      NS_ASSERTION(containingBlock == GetFloatContainingBlock(parentFrame),
-                   "What happened here?");
-      nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
-                                    GetAbsoluteContainingBlock(parentFrame),
-                                    containingBlock);
-      RecoverLetterFrames(state, containingBlock);
-    }
+
+  return RemoveChildFrame(childFrame);
+}
+
+static nsresult
+nsCSSFrameConstructor::RemoveChildFrame(nsIFrame *aChildFrame)
+{
+  nsresult rv = NS_OK;
+  nsFrameManager *frameManager = mPresShell->FrameManager();
+  nsPresContext *presContext = mPresShell->GetPresContext();
+  nsIFrame* parentFrame = aChildFrame->GetParent();
+
+  InvalidateCanvasIfNeeded(aChildFrame);
+
+  // Should we check first-letter style here (rather than ContentRemoved?)
+
+  // Walk the frame subtree deleting any out-of-flow frames, and
+  // remove the mapping from content objects to frames
+  ::DeletingFrameSubtree(frameManager, aChildFrame);
+
+  // See if the child frame is an out-of-flow
+  if (aChildFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
+    nsPlaceholderFrame* placeholderFrame =
+      frameManager->GetPlaceholderFrameFor(aChildFrame);
+    NS_ASSERTION(placeholderFrame, "No placeholder for out-of-flow?");
+
+    UnregisterPlaceholderChain(frameManager, placeholderFrame);
+
+    // Now we remove the out-of-flow frame
+    // XXX has to be done first for now: for floats, the block's line list
+    // contains an array of pointers to the placeholder - we have to
+    // remove the float first (which gets rid of the lines
+    // reference to the placeholder and float) and then remove the
+    // placeholder
+    rv = frameManager->RemoveFrame(parentFrame,
+                                   GetChildListNameFor(aChildFrame),
+                                   aChildFrame);
+
+    // Remove the placeholder frame first (XXX second for now) (so
+    // that it doesn't retain a dangling pointer to memory)
+    nsIFrame* placeholderParent = placeholderFrame->GetParent();
+    ::DeletingFrameSubtree(frameManager, placeholderFrame);
+    rv |= frameManager->RemoveFrame(placeholderParent,
+                                    nsnull, placeholderFrame);
+  } else {
+    // Notify the parent frame that it should delete the frame
+    // check for a table caption which goes on an additional child list with a different parent
+    nsIFrame* outerTableFrame; 
+    if (GetCaptionAdjustedParent(parentFrame, aChildFrame, &outerTableFrame)) {
+      rv = frameManager->RemoveFrame(outerTableFrame,
+                                     nsGkAtoms::captionList,
+                                     aChildFrame);
+    }
+    else {
+      rv = frameManager->RemoveFrame(parentFrame, nsnull, aChildFrame);
+    }
+  }
+
+  if (mInitialContainingBlock == aChildFrame) {
+    mInitialContainingBlock = nsnull;
+    mInitialContainingBlockIsAbsPosContainer = PR_FALSE;
+  }
+
+  if (haveFLS && mInitialContainingBlock) {
+    NS_ASSERTION(containingBlock == GetFloatContainingBlock(parentFrame),
+                 "What happened here?");
+    nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
+                                  GetAbsoluteContainingBlock(parentFrame),
+                                  containingBlock);
+    RecoverLetterFrames(state, containingBlock);
+  }
 
 #ifdef DEBUG
-    if (gReallyNoisyContentUpdates && parentFrame) {
-      nsIFrameDebug* fdbg = nsnull;
-      CallQueryInterface(parentFrame, &fdbg);
-      if (fdbg) {
-        printf("nsCSSFrameConstructor::ContentRemoved: resulting frame model:\n");
-        fdbg->List(stdout, 0);
-      }
-    }
+  if (gReallyNoisyContentUpdates && parentFrame) {
+    nsIFrameDebug* fdbg = nsnull;
+    CallQueryInterface(parentFrame, &fdbg);
+    if (fdbg) {
+      printf("nsCSSFrameConstructor::ContentRemoved: resulting frame model:\n");
+      fdbg->List(stdout, 0);
+    }
+  }
 #endif
-  }
+}
 
   return rv;
 }
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -159,6 +159,15 @@ public:
   // itself.
   nsresult ProcessRestyledFrames(nsStyleChangeList& aRestyleArray);
 
+  /**
+   * StartReconstructAllChildren and FinishReconstructAllChildren must
+   * be called as a pair; the first destroys all the child frames and
+   * the second recreates them.  In between, the caller can do things
+   * like change (and construct/destroy) the content insertion frame.
+   */
+  nsresult StartReconstructAllChildren(nsIFrame* aFrame);
+  nsresult FinishReconstructAllChildren(nsIFrame* aFrame);
+
 private:
   // Note: It's the caller's responsibility to make sure to wrap a
   // ProcessOneRestyle call in a view update batch.
@@ -482,7 +491,6 @@ private:
 
   // END TABLE SECTION
 
-protected:
   static nsresult CreatePlaceholderFrameFor(nsIPresShell*    aPresShell, 
                                             nsIContent*      aContent,
                                             nsIFrame*        aFrame,
@@ -491,7 +499,6 @@ protected:
                                             nsIFrame*        aPrevInFlow,
                                             nsIFrame**       aPlaceholderFrame);
 
-private:
   // @param OUT aNewFrame the new radio control frame
   nsresult ConstructRadioControlFrame(nsIFrame**         aNewFrame,
                                       nsIContent*        aContent,
@@ -755,6 +762,8 @@ private:
   nsresult MaybeRecreateFramesForContent(nsIContent*      aContent);
 
   nsresult RecreateFramesForContent(nsIContent*      aContent);
+
+  nsresult RemoveChildFrame(nsIFrame* aFrame);
 
   // If removal of aFrame from the frame tree requires reconstruction of some
   // containing block (either of aFrame or of its parent) due to {ib} splits,
diff --git a/layout/xul/base/src/nsBoxFrame.cpp b/layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp
+++ b/layout/xul/base/src/nsBoxFrame.cpp
@@ -1029,8 +1029,12 @@ nsBoxFrame::InsertFrames(nsIAtom*       
    NS_PRECONDITION(!aListName, "We don't support out-of-flow kids");
    nsBoxLayoutState state(PresContext());
 
+   // XXX CHECK THE FRAMES FOR THINGS THAT REQUIRE BLOCK-WRAPPING
+
    // insert the child frames
    mFrames.InsertFrames(this, aPrevFrame, aFrameList);
+
+   // XXX IF BLOCK_WRAPPING NEEDED, DO IT HERE
 
    // notify the layout manager
    if (mLayoutManager)
@@ -1056,8 +1060,12 @@ nsBoxFrame::AppendFrames(nsIAtom*       
    NS_PRECONDITION(!aListName, "We don't support out-of-flow kids");
    nsBoxLayoutState state(PresContext());
 
+   // XXX CHECK THE FRAMES FOR THINGS THAT REQUIRE BLOCK-WRAPPING
+
    // append the new frames
    mFrames.AppendFrames(this, aFrameList);
+
+   // XXX IF BLOCK_WRAPPING NEEDED, DO IT HERE
 
    // notify the layout manager
    if (mLayoutManager)
diff --git a/layout/xul/base/src/nsBoxFrame.h b/layout/xul/base/src/nsBoxFrame.h
--- a/layout/xul/base/src/nsBoxFrame.h
+++ b/layout/xul/base/src/nsBoxFrame.h
@@ -55,12 +55,12 @@ class nsBoxLayoutState;
 #define NS_STATE_STACK_NOT_POSITIONED    0x00200000
 //#define NS_STATE_IS_HORIZONTAL           0x00400000  moved to nsIFrame.h
 #define NS_STATE_AUTO_STRETCH            0x00800000
-//#define NS_STATE_IS_ROOT                 0x01000000  moved to nsIFrame.h
+//#define NS_STATE_IS_ROOT                 0x01000000  moved to nsBox.h
 #define NS_STATE_CURRENTLY_IN_DEBUG      0x02000000
-//#define NS_STATE_SET_TO_DEBUG            0x04000000  moved to nsIFrame.h
-//#define NS_STATE_DEBUG_WAS_SET           0x08000000  moved to nsIFrame.h
+//#define NS_STATE_SET_TO_DEBUG            0x04000000  moved to nsBox.h
+//#define NS_STATE_DEBUG_WAS_SET           0x08000000  moved to nsBox.h
 #define NS_STATE_IS_COLLAPSED            0x10000000
-//#define NS_STATE_STYLE_CHANGE            0x20000000  moved to nsIFrame.h
+#define NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK 0x20000000
 #define NS_STATE_EQUAL_SIZE              0x40000000
 //#define NS_STATE_IS_DIRECTION_NORMAL     0x80000000  moved to nsIFrame.h
 
@@ -133,6 +133,9 @@ public:
 
   NS_IMETHOD  RemoveFrame(nsIAtom*        aListName,
                           nsIFrame*       aOldFrame);
+
+  // FIXME: Implement GetContentInsertionFrame to check
+  // NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK
 
   NS_IMETHOD  SetInitialChildList(nsIAtom*        aListName,
                                   nsIFrame*       aChildList);
