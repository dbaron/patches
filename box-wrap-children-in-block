Make boxes that have non-box non-block children wrap all their children in a block.  b=321402

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -461,6 +461,19 @@ IsInlineFrame(const nsIFrame* aFrame)
   return aFrame->IsFrameOfType(nsIFrame::eLineParticipant);
 }
 
+static PRBool
+AnyKidsNeedBlockParent(nsIFrame *aFrameList)
+{
+  for (nsIFrame *k = aFrameList; k; k = k->GetNextSibling()) {
+    // XXX Should we really need to do this for text frames?  Will we
+    // ever do it for whitespace-only text frames?
+    if (k->IsFrameOfType(nsIFrame::eLineParticipant)) {
+      return PR_TRUE;
+    }
+  }
+  return PR_FALSE;
+}
+
 //----------------------------------------------------------------------
 //
 // When inline frames get weird and have block frames in them, we
@@ -6187,9 +6200,36 @@ nsCSSFrameConstructor::ConstructXULFrame
       if (mDocument->BindingManager()->ShouldBuildChildFrames(aContent)) {
         rv = ProcessChildren(aState, aContent, newFrame, PR_FALSE,
                              childItems, PR_FALSE);
+        if (AnyKidsNeedBlockParent(childItems.childList)) {
+
+          // XXX print warning to the JS console.
+
+          nsRefPtr<nsStyleContext> blockSC = mPresShell->StyleSet()->
+            ResolvePseudoStyleFor(aContent,
+                                  nsCSSAnonBoxes::mozXULAnonymousBlock,
+                                  aStyleContext);
+          nsIFrame *blockFrame = NS_NewBlockFrame(mPresShell, blockSC);
+          // We might, in theory, want to set NS_BLOCK_SPACE_MGR and
+          // NS_BLOCK_MARGIN_ROOT, but I think it's a bad idea given that
+          // a real block placed here wouldn't get those set on it.
+
+          for (nsIFrame *f = childItems.childList; f; f = f->GetNextSibling()) {
+            f->SetParent(blockFrame);
+          }
+          blockFrame->Init(aContent, newFrame, nsnull);
+          blockFrame->AddStateBits(newFrame->GetStateBits() &
+                                   NS_FRAME_HAS_CHILD_WITH_VIEW);
+          blockFrame->AppendFrames(nsnull, childItems.childList);
+          childItems.~nsFrameItems();
+          new (&childItems) nsFrameItems();
+
+          childItems.AddChild(blockFrame);
+          newFrame->AddStateBits(NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK);
+        }
       }
     }
       
+    // XXX These should go after the wrapper!
     CreateAnonymousFrames(aTag, aState, aContent, newFrame, PR_FALSE,
                           childItems);
 
@@ -7489,8 +7529,7 @@ nsCSSFrameConstructor::ConstructSVGFrame
       // absolute containing block.
       nsFrameConstructorSaveState saveState;
       aState.PushFloatContainingBlock(nsnull, saveState, PR_FALSE, PR_FALSE);
-      const nsStyleDisplay* disp = innerPseudoStyle->GetStyleDisplay();
-      rv = ConstructBlock(aState, disp, aContent,
+      rv = ConstructBlock(aState, innerPseudoStyle->GetStyleDisplay(), aContent,
                           newFrame, newFrame, innerPseudoStyle,
                           &blockFrame, childItems, PR_TRUE);
       // Give the blockFrame a view so that GetOffsetTo works for descendants
@@ -12527,8 +12566,8 @@ nsCSSFrameConstructor::ConstructBlock(ns
   return rv;
 }
 
-PRBool
-nsCSSFrameConstructor::AreAllKidsInline(nsIFrame* aFrameList)
+static PRBool
+AreAllKidsInline(nsIFrame* aFrameList)
 {
   nsIFrame* kid = aFrameList;
   while (kid) {
@@ -12855,6 +12894,55 @@ nsCSSFrameConstructor::ProcessInlineChil
   return rv;
 }
 
+static void
+DestroyNewlyCreatedFrames(nsFrameConstructorState& aState,
+                          nsIFrame* aParentFrame,
+                          const nsFrameItems& aFrameList)
+{
+  // Ok, reverse tracks: wipe out the frames we just created
+  nsFrameManager *frameManager = aState.mFrameManager;
+
+  // Destroy the frames. As we do make sure any content to frame mappings
+  // or entries in the undisplayed content map are removed
+  frameManager->ClearAllUndisplayedContentIn(aParentFrame->GetContent());
+
+  CleanupFrameReferences(frameManager, aFrameList.childList);
+  if (aState.mAbsoluteItems.childList) {
+    CleanupFrameReferences(frameManager, aState.mAbsoluteItems.childList);
+  }
+  if (aState.mFixedItems.childList) {
+    CleanupFrameReferences(frameManager, aState.mFixedItems.childList);
+  }
+  if (aState.mFloatedItems.childList) {
+    CleanupFrameReferences(frameManager, aState.mFloatedItems.childList);
+  }
+#ifdef MOZ_XUL
+  if (aState.mPopupItems.childList) {
+    CleanupFrameReferences(frameManager, aState.mPopupItems.childList);
+  }
+#endif
+  nsFrameList tmp(aFrameList.childList);
+  tmp.DestroyFrames();
+
+  tmp.SetFrames(aState.mAbsoluteItems.childList);
+  tmp.DestroyFrames();
+  aState.mAbsoluteItems.childList = nsnull;
+
+  tmp.SetFrames(aState.mFixedItems.childList);
+  tmp.DestroyFrames();
+  aState.mFixedItems.childList = nsnull;
+
+  tmp.SetFrames(aState.mFloatedItems.childList);
+  tmp.DestroyFrames();
+  aState.mFloatedItems.childList = nsnull;
+
+#ifdef MOZ_XUL
+  tmp.SetFrames(aState.mPopupItems.childList);
+  tmp.DestroyFrames();
+  aState.mPopupItems.childList = nsnull;
+#endif
+}
+
 PRBool
 nsCSSFrameConstructor::WipeContainingBlock(nsFrameConstructorState& aState,
                                            nsIFrame* aContainingBlock,
@@ -12867,8 +12955,20 @@ nsCSSFrameConstructor::WipeContainingBlo
     return PR_FALSE;
   }
   
-  // Before we go and append the frames, check for a special
-  // situation: an inline frame that will now contain block
+  // Before we go and append the frames, we must check for two
+  // special situations.
+
+  // Situation #1 is a XUL frame that contains frames that are required
+  // to be wrapped in blocks.
+  if (aFrame->IsBoxFrame() &&
+      !(aFrame->GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK) &&
+      AnyKidsNeedBlockParent(aFrameList.childList)) {
+    DestroyNewlyCreatedFrames(aState, aFrame, aFrameList);
+    RecreateFramesForContent(aFrame->GetContent());
+    return PR_TRUE;
+  }
+
+  // Situation #2 is an inline frame that will now contain block
   // frames. This is a no-no and the frame construction logic knows
   // how to fix this.  See defition of IsInlineFrame() for what "an
   // inline" is.  Whether we have "a block" is tested for by
@@ -12930,48 +13030,7 @@ nsCSSFrameConstructor::WipeContainingBlo
     }
   }
 
-  // Ok, reverse tracks: wipe out the frames we just created
-  nsFrameManager *frameManager = aState.mFrameManager;
-
-  // Destroy the frames. As we do make sure any content to frame mappings
-  // or entries in the undisplayed content map are removed
-  frameManager->ClearAllUndisplayedContentIn(aFrame->GetContent());
-
-  CleanupFrameReferences(frameManager, aFrameList.childList);
-  if (aState.mAbsoluteItems.childList) {
-    CleanupFrameReferences(frameManager, aState.mAbsoluteItems.childList);
-  }
-  if (aState.mFixedItems.childList) {
-    CleanupFrameReferences(frameManager, aState.mFixedItems.childList);
-  }
-  if (aState.mFloatedItems.childList) {
-    CleanupFrameReferences(frameManager, aState.mFloatedItems.childList);
-  }
-#ifdef MOZ_XUL
-  if (aState.mPopupItems.childList) {
-    CleanupFrameReferences(frameManager, aState.mPopupItems.childList);
-  }
-#endif
-  nsFrameList tmp(aFrameList.childList);
-  tmp.DestroyFrames();
-
-  tmp.SetFrames(aState.mAbsoluteItems.childList);
-  tmp.DestroyFrames();
-  aState.mAbsoluteItems.childList = nsnull;
-
-  tmp.SetFrames(aState.mFixedItems.childList);
-  tmp.DestroyFrames();
-  aState.mFixedItems.childList = nsnull;
-
-  tmp.SetFrames(aState.mFloatedItems.childList);
-  tmp.DestroyFrames();
-  aState.mFloatedItems.childList = nsnull;
-
-#ifdef MOZ_XUL
-  tmp.SetFrames(aState.mPopupItems.childList);
-  tmp.DestroyFrames();
-  aState.mPopupItems.childList = nsnull;
-#endif
+  DestroyNewlyCreatedFrames(aState, aFrame, aFrameList);
 
   // If we don't have a containing block, start with aFrame and look for one.
   if (!aContainingBlock) {
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -885,8 +885,6 @@ private:
                                  nsFrameItems&            aFrameItems,
                                  PRBool*                  aKidsAllInline);
 
-  PRBool AreAllKidsInline(nsIFrame* aFrameList);
-
   // Determine whether we need to wipe out what we just did and start over
   // because we're doing something like adding block kids to an inline frame
   // (and therefore need an {ib} split).  If aIsAppend is true, aPrevSibling is
diff --git a/layout/style/nsCSSAnonBoxList.h b/layout/style/nsCSSAnonBoxList.h
--- a/layout/style/nsCSSAnonBoxList.h
+++ b/layout/style/nsCSSAnonBoxList.h
@@ -57,6 +57,7 @@ CSS_ANON_BOX(mozAnonymousBlock, ":-moz-a
 CSS_ANON_BOX(mozAnonymousBlock, ":-moz-anonymous-block")
 CSS_ANON_BOX(mozAnonymousPositionedBlock, ":-moz-anonymous-positioned-block")
 CSS_ANON_BOX(mozMathMLAnonymousBlock, ":-moz-mathml-anonymous-block")
+CSS_ANON_BOX(mozXULAnonymousBlock, ":-moz-xul-anonymous-block")
 
 CSS_ANON_BOX(mozLineFrame, ":-moz-line-frame")
 
diff --git a/layout/style/ua.css b/layout/style/ua.css
--- a/layout/style/ua.css
+++ b/layout/style/ua.css
@@ -127,6 +127,12 @@
   display: block !important;
   position: static !important;
   /* XXX shouldn't unicode-bidi inherit? */
+}
+
+*|*::-moz-xul-anonymous-block {
+  display: block ! important;
+  position: static ! important;
+  float: none ! important;
 }
 
 *|*::-moz-scrolled-content, *|*::-moz-scrolled-canvas,
diff --git a/layout/xul/base/src/nsBoxFrame.cpp b/layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp
+++ b/layout/xul/base/src/nsBoxFrame.cpp
@@ -1087,7 +1087,13 @@ nsBoxFrame::AppendFrames(nsIAtom*       
    return NS_OK;
 }
 
-
+/* virtual */ nsIFrame*
+nsBoxFrame::GetContentInsertionFrame()
+{
+  if (GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK)
+    return GetFirstChild(nsnull)->GetContentInsertionFrame();
+  return nsContainerFrame::GetContentInsertionFrame();
+}
 
 NS_IMETHODIMP
 nsBoxFrame::AttributeChanged(PRInt32 aNameSpaceID,
diff --git a/layout/xul/base/src/nsBoxFrame.h b/layout/xul/base/src/nsBoxFrame.h
--- a/layout/xul/base/src/nsBoxFrame.h
+++ b/layout/xul/base/src/nsBoxFrame.h
@@ -55,12 +55,12 @@ class nsBoxLayoutState;
 #define NS_STATE_STACK_NOT_POSITIONED    0x00200000
 //#define NS_STATE_IS_HORIZONTAL           0x00400000  moved to nsIFrame.h
 #define NS_STATE_AUTO_STRETCH            0x00800000
-//#define NS_STATE_IS_ROOT                 0x01000000  moved to nsIFrame.h
+//#define NS_STATE_IS_ROOT                 0x01000000  moved to nsBox.h
 #define NS_STATE_CURRENTLY_IN_DEBUG      0x02000000
-//#define NS_STATE_SET_TO_DEBUG            0x04000000  moved to nsIFrame.h
-//#define NS_STATE_DEBUG_WAS_SET           0x08000000  moved to nsIFrame.h
+//#define NS_STATE_SET_TO_DEBUG            0x04000000  moved to nsBox.h
+//#define NS_STATE_DEBUG_WAS_SET           0x08000000  moved to nsBox.h
 #define NS_STATE_IS_COLLAPSED            0x10000000
-//#define NS_STATE_STYLE_CHANGE            0x20000000  moved to nsIFrame.h
+#define NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK 0x20000000
 #define NS_STATE_EQUAL_SIZE              0x40000000
 //#define NS_STATE_IS_DIRECTION_NORMAL     0x80000000  moved to nsIFrame.h
 
@@ -133,6 +133,8 @@ public:
 
   NS_IMETHOD  RemoveFrame(nsIAtom*        aListName,
                           nsIFrame*       aOldFrame);
+
+  virtual nsIFrame* GetContentInsertionFrame();
 
   NS_IMETHOD  SetInitialChildList(nsIAtom*        aListName,
                                   nsIFrame*       aChildList);
