Make boxes that have non-box non-block children wrap all their children in a block.  b=321402

diff --git a/dom/locales/en-US/chrome/layout/xul.properties b/dom/locales/en-US/chrome/layout/xul.properties
--- a/dom/locales/en-US/chrome/layout/xul.properties
+++ b/dom/locales/en-US/chrome/layout/xul.properties
@@ -35,3 +35,4 @@
 
 MissingOverlay=Failed to load overlay from %1$S.
 PINotInProlog=<?%1$S?> processing instruction does not have any effect outside the prolog anymore (see bug 360119).
+NeededToWrapXUL=XUL box for %1$S element contained an inline %2$S child, forcing all its children to be wrapped in a block.
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -101,6 +101,7 @@
 #include "nsITheme.h"
 #include "nsContentCID.h"
 #include "nsContentUtils.h"
+#include "nsIScriptError.h"
 #include "nsIDocShell.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsObjectFrame.h"
@@ -461,6 +462,24 @@ IsInlineFrame(const nsIFrame* aFrame)
   return aFrame->IsFrameOfType(nsIFrame::eLineParticipant);
 }
 
+/**
+ * If any children require a block parent, return the first such child.
+ * Otherwise return null.
+ */
+static nsIContent*
+AnyKidsNeedBlockParent(nsIFrame *aFrameList)
+{
+  for (nsIFrame *k = aFrameList; k; k = k->GetNextSibling()) {
+    // Line participants, such as text and inline frames, can't be
+    // directly inside a XUL box; they must be wrapped in an
+    // intermediate block.
+    if (k->IsFrameOfType(nsIFrame::eLineParticipant)) {
+      return k->GetContent();
+    }
+  }
+  return nsnull;
+}
+
 //----------------------------------------------------------------------
 //
 // When inline frames get weird and have block frames in them, we
@@ -6187,9 +6206,50 @@ nsCSSFrameConstructor::ConstructXULFrame
       if (mDocument->BindingManager()->ShouldBuildChildFrames(aContent)) {
         rv = ProcessChildren(aState, aContent, newFrame, PR_FALSE,
                              childItems, PR_FALSE);
+        nsIContent *badKid;
+        if (newFrame->IsBoxFrame() &&
+            (badKid = AnyKidsNeedBlockParent(childItems.childList))) {
+          nsAutoString parentTag, kidTag;
+          aContent->Tag()->ToString(parentTag);
+          badKid->Tag()->ToString(kidTag);
+          const PRUnichar* params[] = { parentTag.get(), kidTag.get() };
+          nsContentUtils::ReportToConsole(nsContentUtils::eXUL_PROPERTIES,
+                                          "NeededToWrapXUL",
+                                          params, NS_ARRAY_LENGTH(params),
+                                          mDocument->GetDocumentURI(),
+                                          EmptyString(), 0, 0, // not useful
+                                          nsIScriptError::warningFlag,
+                                          "FrameConstructor");
+
+          nsRefPtr<nsStyleContext> blockSC = mPresShell->StyleSet()->
+            ResolvePseudoStyleFor(aContent,
+                                  nsCSSAnonBoxes::mozXULAnonymousBlock,
+                                  aStyleContext);
+          nsIFrame *blockFrame = NS_NewBlockFrame(mPresShell, blockSC);
+          // We might, in theory, want to set NS_BLOCK_SPACE_MGR and
+          // NS_BLOCK_MARGIN_ROOT, but I think it's a bad idea given that
+          // a real block placed here wouldn't get those set on it.
+
+          InitAndRestoreFrame(aState, aContent, newFrame, nsnull,
+                              blockFrame, PR_FALSE);
+
+          NS_ASSERTION(!blockFrame->HasView(), "need to do view reparenting");
+          for (nsIFrame *f = childItems.childList; f; f = f->GetNextSibling()) {
+            f->SetParent(blockFrame);
+          }
+          blockFrame->AddStateBits(newFrame->GetStateBits() &
+                                   NS_FRAME_HAS_CHILD_WITH_VIEW);
+
+          blockFrame->AppendFrames(nsnull, childItems.childList);
+          childItems = nsFrameItems();
+          childItems.AddChild(blockFrame);
+
+          newFrame->AddStateBits(NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK);
+        }
       }
     }
       
+    // XXX These should go after the wrapper!
     CreateAnonymousFrames(aTag, aState, aContent, newFrame, PR_FALSE,
                           childItems);
 
@@ -7475,8 +7535,7 @@ nsCSSFrameConstructor::ConstructSVGFrame
       // absolute containing block.
       nsFrameConstructorSaveState saveState;
       aState.PushFloatContainingBlock(nsnull, saveState, PR_FALSE, PR_FALSE);
-      const nsStyleDisplay* disp = innerPseudoStyle->GetStyleDisplay();
-      rv = ConstructBlock(aState, disp, aContent,
+      rv = ConstructBlock(aState, innerPseudoStyle->GetStyleDisplay(), aContent,
                           newFrame, newFrame, innerPseudoStyle,
                           &blockFrame, childItems, PR_TRUE);
       // Give the blockFrame a view so that GetOffsetTo works for descendants
@@ -9586,6 +9645,16 @@ nsCSSFrameConstructor::ContentRemoved(ns
     if (possibleMathMLAncestor->IsFrameOfType(nsIFrame::eMathML))
       return RecreateFramesForContent(possibleMathMLAncestor->GetContent());
 #endif
+
+    // Undo XUL wrapping if it's no longer needed.
+    if (parentFrame->IsBoxFrame() &&
+        (parentFrame->GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK) &&
+        // check if this frame is the only one needing wrapping
+        aChild == AnyKidsNeedBlockParent(parentFrame->GetFirstChild(nsnull)->
+                                           GetFirstChild(nsnull)) &&
+        !AnyKidsNeedBlockParent(childFrame->GetNextSibling())) {
+      return RecreateFramesForContent(parentFrame->GetContent());
+    }
     
     // Examine the containing-block for the removed content and see if
     // :first-letter style applies.
@@ -12518,8 +12587,8 @@ nsCSSFrameConstructor::ConstructBlock(ns
   return rv;
 }
 
-PRBool
-nsCSSFrameConstructor::AreAllKidsInline(nsIFrame* aFrameList)
+static PRBool
+AreAllKidsInline(nsIFrame* aFrameList)
 {
   nsIFrame* kid = aFrameList;
   while (kid) {
@@ -12846,6 +12915,55 @@ nsCSSFrameConstructor::ProcessInlineChil
   return rv;
 }
 
+static void
+DestroyNewlyCreatedFrames(nsFrameConstructorState& aState,
+                          nsIFrame* aParentFrame,
+                          const nsFrameItems& aFrameList)
+{
+  // Ok, reverse tracks: wipe out the frames we just created
+  nsFrameManager *frameManager = aState.mFrameManager;
+
+  // Destroy the frames. As we do make sure any content to frame mappings
+  // or entries in the undisplayed content map are removed
+  frameManager->ClearAllUndisplayedContentIn(aParentFrame->GetContent());
+
+  CleanupFrameReferences(frameManager, aFrameList.childList);
+  if (aState.mAbsoluteItems.childList) {
+    CleanupFrameReferences(frameManager, aState.mAbsoluteItems.childList);
+  }
+  if (aState.mFixedItems.childList) {
+    CleanupFrameReferences(frameManager, aState.mFixedItems.childList);
+  }
+  if (aState.mFloatedItems.childList) {
+    CleanupFrameReferences(frameManager, aState.mFloatedItems.childList);
+  }
+#ifdef MOZ_XUL
+  if (aState.mPopupItems.childList) {
+    CleanupFrameReferences(frameManager, aState.mPopupItems.childList);
+  }
+#endif
+  nsFrameList tmp(aFrameList.childList);
+  tmp.DestroyFrames();
+
+  tmp.SetFrames(aState.mAbsoluteItems.childList);
+  tmp.DestroyFrames();
+  aState.mAbsoluteItems.childList = nsnull;
+
+  tmp.SetFrames(aState.mFixedItems.childList);
+  tmp.DestroyFrames();
+  aState.mFixedItems.childList = nsnull;
+
+  tmp.SetFrames(aState.mFloatedItems.childList);
+  tmp.DestroyFrames();
+  aState.mFloatedItems.childList = nsnull;
+
+#ifdef MOZ_XUL
+  tmp.SetFrames(aState.mPopupItems.childList);
+  tmp.DestroyFrames();
+  aState.mPopupItems.childList = nsnull;
+#endif
+}
+
 PRBool
 nsCSSFrameConstructor::WipeContainingBlock(nsFrameConstructorState& aState,
                                            nsIFrame* aContainingBlock,
@@ -12858,8 +12976,20 @@ nsCSSFrameConstructor::WipeContainingBlo
     return PR_FALSE;
   }
   
-  // Before we go and append the frames, check for a special
-  // situation: an inline frame that will now contain block
+  // Before we go and append the frames, we must check for two
+  // special situations.
+
+  // Situation #1 is a XUL frame that contains frames that are required
+  // to be wrapped in blocks.
+  if (aFrame->IsBoxFrame() &&
+      !(aFrame->GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK) &&
+      AnyKidsNeedBlockParent(aFrameList.childList)) {
+    DestroyNewlyCreatedFrames(aState, aFrame, aFrameList);
+    RecreateFramesForContent(aFrame->GetContent());
+    return PR_TRUE;
+  }
+
+  // Situation #2 is an inline frame that will now contain block
   // frames. This is a no-no and the frame construction logic knows
   // how to fix this.  See defition of IsInlineFrame() for what "an
   // inline" is.  Whether we have "a block" is tested for by
@@ -12921,48 +13051,7 @@ nsCSSFrameConstructor::WipeContainingBlo
     }
   }
 
-  // Ok, reverse tracks: wipe out the frames we just created
-  nsFrameManager *frameManager = aState.mFrameManager;
-
-  // Destroy the frames. As we do make sure any content to frame mappings
-  // or entries in the undisplayed content map are removed
-  frameManager->ClearAllUndisplayedContentIn(aFrame->GetContent());
-
-  CleanupFrameReferences(frameManager, aFrameList.childList);
-  if (aState.mAbsoluteItems.childList) {
-    CleanupFrameReferences(frameManager, aState.mAbsoluteItems.childList);
-  }
-  if (aState.mFixedItems.childList) {
-    CleanupFrameReferences(frameManager, aState.mFixedItems.childList);
-  }
-  if (aState.mFloatedItems.childList) {
-    CleanupFrameReferences(frameManager, aState.mFloatedItems.childList);
-  }
-#ifdef MOZ_XUL
-  if (aState.mPopupItems.childList) {
-    CleanupFrameReferences(frameManager, aState.mPopupItems.childList);
-  }
-#endif
-  nsFrameList tmp(aFrameList.childList);
-  tmp.DestroyFrames();
-
-  tmp.SetFrames(aState.mAbsoluteItems.childList);
-  tmp.DestroyFrames();
-  aState.mAbsoluteItems.childList = nsnull;
-
-  tmp.SetFrames(aState.mFixedItems.childList);
-  tmp.DestroyFrames();
-  aState.mFixedItems.childList = nsnull;
-
-  tmp.SetFrames(aState.mFloatedItems.childList);
-  tmp.DestroyFrames();
-  aState.mFloatedItems.childList = nsnull;
-
-#ifdef MOZ_XUL
-  tmp.SetFrames(aState.mPopupItems.childList);
-  tmp.DestroyFrames();
-  aState.mPopupItems.childList = nsnull;
-#endif
+  DestroyNewlyCreatedFrames(aState, aFrame, aFrameList);
 
   // If we don't have a containing block, start with aFrame and look for one.
   if (!aContainingBlock) {
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -885,8 +885,6 @@ private:
                                  nsFrameItems&            aFrameItems,
                                  PRBool*                  aKidsAllInline);
 
-  PRBool AreAllKidsInline(nsIFrame* aFrameList);
-
   // Determine whether we need to wipe out what we just did and start over
   // because we're doing something like adding block kids to an inline frame
   // (and therefore need an {ib} split).  If aIsAppend is true, aPrevSibling is
diff --git a/layout/reftests/bugs/321402-1.html b/layout/reftests/bugs/321402-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/321402-1.html
@@ -0,0 +1,2 @@
+<!DOCTYPE HTML>
+<span style="display:-moz-inline-box">hello world</span>
diff --git a/layout/reftests/bugs/321402-2.html b/layout/reftests/bugs/321402-2.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/321402-2.html
@@ -0,0 +1,2 @@
+<!DOCTYPE HTML>
+<span style="display:-moz-inline-box"><span style="background:green">&nbsp;</span></span>
diff --git a/layout/reftests/bugs/321402-3-ref.xul b/layout/reftests/bugs/321402-3-ref.xul
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/321402-3-ref.xul
@@ -0,0 +1,6 @@
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        xmlns:html="http://www.w3.org/1999/xhtml">
+  <vbox flex="1">
+    <label value="hello world" />
+  </vbox>
+</window>
diff --git a/layout/reftests/bugs/321402-3.xul b/layout/reftests/bugs/321402-3.xul
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/321402-3.xul
@@ -0,0 +1,8 @@
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        xmlns:html="http://www.w3.org/1999/xhtml">
+  <vbox flex="1">
+    <html:span style="display:inline" flex="1" /> <!-- causes block wrapping -->
+    <box flex="1" />
+    <label value="hello world" />
+  </vbox>
+</window>
diff --git a/layout/reftests/bugs/321402-4-ref.xul b/layout/reftests/bugs/321402-4-ref.xul
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/321402-4-ref.xul
@@ -0,0 +1,8 @@
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        xmlns:html="http://www.w3.org/1999/xhtml">
+  <vbox flex="1">
+    <html:span style="display:inline" flex="1" /> <!-- causes block wrapping -->
+    <box flex="1" />
+    <label value="hello world" />
+  </vbox>
+</window>
diff --git a/layout/reftests/bugs/321402-4.xul b/layout/reftests/bugs/321402-4.xul
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/321402-4.xul
@@ -0,0 +1,21 @@
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        xmlns:html="http://www.w3.org/1999/xhtml">
+        class="reftest-wait" onload="setTimeout(run, 0)">
+  <script type="text/javascript"><![CDATA[
+    function run() {
+      const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+      const HTML_NS = "http://www.w3.org/1999/xhtml";
+      var vbox = document.getElementsByTagName("vbox")[0];
+      var span = document.createElementNS(HTML_NS, "html:span");
+      vbox.insertBefore(span, vbox.firstChild); // causes block wrapping
+      setTimeout(finish, 0);
+    }
+    function finish() {
+      document.documentElement.removeAttribute("class");
+    }
+  ]]></script>
+  <vbox flex="1">
+    <box flex="1" />
+    <label value="hello world" />
+  </vbox>
+</window>
diff --git a/layout/reftests/bugs/321402-5-ref.xul b/layout/reftests/bugs/321402-5-ref.xul
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/321402-5-ref.xul
@@ -0,0 +1,8 @@
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        xmlns:html="http://www.w3.org/1999/xhtml">
+  <vbox flex="1">
+    <box flex="1" />
+    <label value="hello world" />
+    <html:span style="display:inline" flex="1" /> <!-- causes block wrapping -->
+  </vbox>
+</window>
diff --git a/layout/reftests/bugs/321402-5.xul b/layout/reftests/bugs/321402-5.xul
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/321402-5.xul
@@ -0,0 +1,21 @@
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        xmlns:html="http://www.w3.org/1999/xhtml">
+        class="reftest-wait" onload="setTimeout(run, 0)">
+  <script type="text/javascript"><![CDATA[
+    function run() {
+      const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+      const HTML_NS = "http://www.w3.org/1999/xhtml";
+      var vbox = document.getElementsByTagName("vbox")[0];
+      var span = document.createElementNS(HTML_NS, "html:span");
+      vbox.appendChild(span); // causes block wrapping
+      setTimeout(finish, 0);
+    }
+    function finish() {
+      document.documentElement.removeAttribute("class");
+    }
+  ]]></script>
+  <vbox flex="1">
+    <box flex="1" />
+    <label value="hello world" />
+  </vbox>
+</window>
diff --git a/layout/reftests/bugs/321402-6-ref.xul b/layout/reftests/bugs/321402-6-ref.xul
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/321402-6-ref.xul
@@ -0,0 +1,7 @@
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        xmlns:html="http://www.w3.org/1999/xhtml">
+  <vbox flex="1">
+    <box flex="1" />
+    <label value="hello world" />
+  </vbox>
+</window>
diff --git a/layout/reftests/bugs/321402-6.xul b/layout/reftests/bugs/321402-6.xul
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/321402-6.xul
@@ -0,0 +1,21 @@
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        xmlns:html="http://www.w3.org/1999/xhtml">
+        class="reftest-wait" onload="setTimeout(run, 0)">
+  <script type="text/javascript"><![CDATA[
+    function run() {
+      const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+      const HTML_NS = "http://www.w3.org/1999/xhtml";
+      var span = document.getElementsByTagNameNS(HTML_NS, "html:span")[0];
+      span.parentNode.removeChild(span);
+      setTimeout(finish, 0);
+    }
+    function finish() {
+      document.documentElement.removeAttribute("class");
+    }
+  ]]></script>
+  <vbox flex="1">
+    <html:span style="display:inline" flex="1" /> <!-- causes block wrapping -->
+    <box flex="1" />
+    <label value="hello world" />
+  </vbox>
+</window>
diff --git a/layout/reftests/bugs/reftest.list b/layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list
+++ b/layout/reftests/bugs/reftest.list
@@ -130,6 +130,10 @@ fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") ==
 != 315620-1b.html 315620-1-ref.html
 == 315620-2a.xhtml 315620-2-ref.xhtml
 != 315620-2b.xhtml 315620-2-ref.xhtml
+!= 321402-1.html about:blank
+!= 321402-2.html about:blank
+== 321402-3.xul 321402-3-ref.xul
+== 321402-4.xul 321402-4-ref.xul
 == 322461-1.xml 322461-1-ref.html
 == 323656-1.html 323656-1-ref.html
 == 323656-2.html 323656-2-ref.html
diff --git a/layout/style/nsCSSAnonBoxList.h b/layout/style/nsCSSAnonBoxList.h
--- a/layout/style/nsCSSAnonBoxList.h
+++ b/layout/style/nsCSSAnonBoxList.h
@@ -57,6 +57,7 @@ CSS_ANON_BOX(mozAnonymousBlock, ":-moz-a
 CSS_ANON_BOX(mozAnonymousBlock, ":-moz-anonymous-block")
 CSS_ANON_BOX(mozAnonymousPositionedBlock, ":-moz-anonymous-positioned-block")
 CSS_ANON_BOX(mozMathMLAnonymousBlock, ":-moz-mathml-anonymous-block")
+CSS_ANON_BOX(mozXULAnonymousBlock, ":-moz-xul-anonymous-block")
 
 CSS_ANON_BOX(mozLineFrame, ":-moz-line-frame")
 
diff --git a/layout/style/ua.css b/layout/style/ua.css
--- a/layout/style/ua.css
+++ b/layout/style/ua.css
@@ -127,6 +127,12 @@
   display: block !important;
   position: static !important;
   /* XXX shouldn't unicode-bidi inherit? */
+}
+
+*|*::-moz-xul-anonymous-block {
+  display: block ! important;
+  position: static ! important;
+  float: none ! important;
 }
 
 *|*::-moz-scrolled-content, *|*::-moz-scrolled-canvas,
diff --git a/layout/xul/base/src/nsBoxFrame.cpp b/layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp
+++ b/layout/xul/base/src/nsBoxFrame.cpp
@@ -1087,7 +1087,13 @@ nsBoxFrame::AppendFrames(nsIAtom*       
    return NS_OK;
 }
 
-
+/* virtual */ nsIFrame*
+nsBoxFrame::GetContentInsertionFrame()
+{
+  if (GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK)
+    return GetFirstChild(nsnull)->GetContentInsertionFrame();
+  return nsContainerFrame::GetContentInsertionFrame();
+}
 
 NS_IMETHODIMP
 nsBoxFrame::AttributeChanged(PRInt32 aNameSpaceID,
diff --git a/layout/xul/base/src/nsBoxFrame.h b/layout/xul/base/src/nsBoxFrame.h
--- a/layout/xul/base/src/nsBoxFrame.h
+++ b/layout/xul/base/src/nsBoxFrame.h
@@ -55,12 +55,12 @@ class nsBoxLayoutState;
 #define NS_STATE_STACK_NOT_POSITIONED    0x00200000
 //#define NS_STATE_IS_HORIZONTAL           0x00400000  moved to nsIFrame.h
 #define NS_STATE_AUTO_STRETCH            0x00800000
-//#define NS_STATE_IS_ROOT                 0x01000000  moved to nsIFrame.h
+//#define NS_STATE_IS_ROOT                 0x01000000  moved to nsBox.h
 #define NS_STATE_CURRENTLY_IN_DEBUG      0x02000000
-//#define NS_STATE_SET_TO_DEBUG            0x04000000  moved to nsIFrame.h
-//#define NS_STATE_DEBUG_WAS_SET           0x08000000  moved to nsIFrame.h
+//#define NS_STATE_SET_TO_DEBUG            0x04000000  moved to nsBox.h
+//#define NS_STATE_DEBUG_WAS_SET           0x08000000  moved to nsBox.h
 #define NS_STATE_IS_COLLAPSED            0x10000000
-//#define NS_STATE_STYLE_CHANGE            0x20000000  moved to nsIFrame.h
+#define NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK 0x20000000
 #define NS_STATE_EQUAL_SIZE              0x40000000
 //#define NS_STATE_IS_DIRECTION_NORMAL     0x80000000  moved to nsIFrame.h
 
@@ -133,6 +133,8 @@ public:
 
   NS_IMETHOD  RemoveFrame(nsIAtom*        aListName,
                           nsIFrame*       aOldFrame);
+
+  virtual nsIFrame* GetContentInsertionFrame();
 
   NS_IMETHOD  SetInitialChildList(nsIAtom*        aListName,
                                   nsIFrame*       aChildList);
