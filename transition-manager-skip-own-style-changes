From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch 10 - nsTransitionManager should skip style changes that it posted while starting transitions.

This will be needed when (in later patches) we stop separating animation
phases.

diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -823,16 +823,24 @@ AnimationPlayerCollection::CanThrottleAn
 void
 AnimationPlayerCollection::UpdateAnimationGeneration(
   nsPresContext* aPresContext)
 {
   mAnimationGeneration =
     aPresContext->RestyleManager()->GetAnimationGeneration();
 }
 
+void
+AnimationPlayerCollection::UpdateCheckGeneration(
+  nsPresContext* aPresContext)
+{
+  mCheckGeneration =
+    aPresContext->RestyleManager()->GetAnimationGeneration();
+}
+
 bool
 AnimationPlayerCollection::HasCurrentAnimations() const
 {
   for (size_t playerIdx = mPlayers.Length(); playerIdx-- != 0; ) {
     if (mPlayers[playerIdx]->HasCurrentSource()) {
       return true;
     }
   }
diff --git a/layout/style/AnimationCommon.h b/layout/style/AnimationCommon.h
--- a/layout/style/AnimationCommon.h
+++ b/layout/style/AnimationCommon.h
@@ -210,16 +210,17 @@ enum EnsureStyleRuleFlags {
 struct AnimationPlayerCollection : public PRCList
 {
   AnimationPlayerCollection(dom::Element *aElement, nsIAtom *aElementProperty,
                             mozilla::css::CommonAnimationManager *aManager)
     : mElement(aElement)
     , mElementProperty(aElementProperty)
     , mManager(aManager)
     , mAnimationGeneration(0)
+    , mCheckGeneration(0)
     , mNeedsRefreshes(true)
 #ifdef DEBUG
     , mCalledPropertyDtor(false)
 #endif
   {
     MOZ_COUNT_CTOR(AnimationPlayerCollection);
     PR_INIT_CLIST(this);
   }
@@ -364,16 +365,26 @@ struct AnimationPlayerCollection : publi
   // mAnimationGeneration is the sequence number of the last flush where a
   // transition/animation changed.  We keep a similar count on the
   // corresponding layer so we can check that the layer is up to date with
   // the animation manager.
   uint64_t mAnimationGeneration;
   // Update mAnimationGeneration to nsCSSFrameConstructor's count
   void UpdateAnimationGeneration(nsPresContext* aPresContext);
 
+  // For CSS transitions only, we also record the most recent generation
+  // for which we've done the transition update, so that we avoid doing
+  // it more than once per style change.  This should be greater than or
+  // equal to mAnimationGeneration, except when the generation counter
+  // cycles, or when animations are updated through the DOM Animation
+  // interfaces.
+  uint64_t mCheckGeneration;
+  // Update mAnimationGeneration to nsCSSFrameConstructor's count
+  void UpdateCheckGeneration(nsPresContext* aPresContext);
+
   // Returns true if there is an animation that has yet to finish.
   bool HasCurrentAnimations() const;
   // Returns true if there is an animation of the specified property that
   // has yet to finish.
   bool HasCurrentAnimationsForProperty(nsCSSProperty aProperty) const;
 
   // The refresh time associated with mStyleRule.
   TimeStamp mStyleRuleRefreshTime;
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -176,16 +176,27 @@ nsTransitionManager::StyleContextChanged
     GetAnimationPlayers(aElement, pseudoType, false);
   if (!collection &&
       disp->mTransitionPropertyCount == 1 &&
       disp->mTransitions[0].GetDelay() == 0.0f &&
       disp->mTransitions[0].GetDuration() == 0.0f) {
     return;
   }
 
+  if (collection &&
+      collection->mCheckGeneration ==
+        mPresContext->RestyleManager()->GetAnimationGeneration()) {
+    // When we start a new transition, we immediately post a restyle.
+    // If the animation generation on the collection is current, that
+    // means *this* is that restyle, since we bump the animation
+    // generation on the restyle manager whenever there's a real style
+    // change (i.e., one where mInAnimationOnlyStyleUpdate isn't true,
+    // which causes us to return above).  Thus we shouldn't do anything.
+    return;
+  }
 
   // FIXME (bug 960465): This test should go away.
   if (newStyleContext->PresContext()->RestyleManager()->
         IsProcessingAnimationStyleChange()) {
     return;
   }
 
   if (newStyleContext->GetParent() &&
@@ -363,16 +374,17 @@ nsTransitionManager::StyleContextChanged
       }
     }
   }
 
   if (collection) {
     // Set the style rule refresh time to null so that EnsureStyleRuleFor
     // creates a new style rule if we started *or* stopped transitions.
     collection->mStyleRuleRefreshTime = TimeStamp();
+    collection->UpdateCheckGeneration(mPresContext);
   }
 
   // Replace the new style context by appending the cover rule.
   nsCOMArray<nsIStyleRule> rules;
   if (startedAny) {
     rules.AppendObject(coverRule);
   }
   *aNewStyleContext = mPresContext->StyleSet()->
