From: L. David Baron <dbaron@dbaron.org>

Track which frames were float continuations that need to be pulled to the next block rather than figuring it out again when it's time to pull them.  (This allows first-in-flows to be float continuations.)  (Bug 563584)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1009,18 +1009,23 @@ nsBlockFrame::Reflow(nsPresContext*     
   rv = ReflowDirtyLines(state);
   NS_ASSERTION(NS_SUCCEEDED(rv), "reflow dirty lines failed");
   if (NS_FAILED(rv)) return rv;
 
   NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
   NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
 
   // Put continued floats at the end of mFloats
-  if (state.mFloatContinuations.NotEmpty())
+  if (state.mFloatContinuations.NotEmpty()) {
+    PRInt32 len = state.mFloatContinuations.GetLength();
     mFloats.AppendFrames(nsnull, state.mFloatContinuations);
+    aPresContext->PropertyTable()->
+      Set(this, nsBlockFrame::FloatContinuationCountProperty(),
+          NS_INT32_TO_PTR(len));
+  }
 
   // If we end in a BR with clear and affected floats continue,
   // we need to continue, too.
   if (NS_UNCONSTRAINEDSIZE != aReflowState.availableHeight &&
       NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
       state.mFloatManager->ClearContinues(FindTrailingClear())) {
     NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
   }
@@ -3958,34 +3963,37 @@ nsBlockFrame::CreateContinuationFor(nsBl
   return NS_OK;
 }
 
 nsresult
 nsBlockFrame::SplitFloat(nsBlockReflowState& aState,
                          nsIFrame*           aFloat,
                          nsReflowStatus      aFloatStatus)
 {
-  nsIFrame* nextInFlow = nsnull;
-  if (!aFloat->GetNextInFlow()) {
+  nsIFrame* nextInFlow = aFloat->GetNextInFlow();
+  if (nextInFlow) {
+    nsContainerFrame *oldParent =
+      static_cast<nsContainerFrame*>(nextInFlow->GetParent());
+    nsresult rv = oldParent->StealFrame(aState.mPresContext, nextInFlow);
+    NS_ASSERTION(NS_SUCCEEDED(rv), "StealFrame failed");
+    ReparentFrame(nextInFlow, oldParent, this);
+  } else {
     nsresult rv = aState.mPresContext->PresShell()->FrameConstructor()->
       CreateContinuingFrame(aState.mPresContext, aFloat, this, &nextInFlow);
     NS_ENSURE_SUCCESS(rv, rv);
   }
   if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aFloatStatus))
     aFloat->GetNextInFlow()->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
 
   // Float continuations can only trigger overflow
   NS_FRAME_SET_OVERFLOW_INCOMPLETE(aFloatStatus);
   // Make sure the containing block knows about the float's status
   NS_MergeReflowStatusInto(&aState.mReflowStatus, aFloatStatus);
 
-  if (nextInFlow) {
-    // Next in flow was created above.
-    aState.AppendFloatContinuation(nextInFlow);
-  }
+  aState.AppendFloatContinuation(nextInFlow);
   return NS_OK;
 }
 
 static nsFloatCache*
 GetLastFloat(nsLineBox* aLine)
 {
   nsFloatCache* fc = aLine->GetFirstFloat();
   while (fc && fc->Next()) {
@@ -4491,63 +4499,68 @@ nsBlockFrame::DrainOverflowLines(nsBlock
     }
     delete ourOverflowLines;
   }
 
   return PR_TRUE;
 }
 
 // This function assumes our prev-in-flow has completed reflow and its
-// mFloats contains at most two frames that belong to the same flow chain,
-// the second one being a last-in-flow continuation intended for this block.
+// mFloats may, depending on its FloatContinuationCountProperty(), contain
+// frames at the end of its float list that should be pulled to this block.
 void
 nsBlockFrame::DrainFloatContinuations(nsBlockReflowState& aState)
 {
   // Cache any continuations of our own floats that we're still holding onto
   // so they're out of the way. This should only happen if we're re-Reflow'd
   // before our next-in-flow gets a chance to pull these continuations.
-  nsFrameList floatContinuations;
-  nsPresContext* presContext = PresContext();
-  for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
-    nsIFrame* nif = f->GetNextInFlow();
-    if (!nif) continue;
-    if (nif->GetParent() == this) {
-      NS_ASSERTION(!nif->GetNextInFlow(),
-                   "Unexpected next-in-flow for float continuation");
-      StealFrame(presContext, nif);
-      floatContinuations.AppendFrame(nsnull, nif);
-    }
-  }
-  if (floatContinuations.NotEmpty()) {
+  nsPresContext* presContext = aState.mPresContext;
+  PRInt32 len = NS_PTR_TO_INT32(presContext->PropertyTable()->Remove(
+    this, nsBlockFrame::FloatContinuationCountProperty()));
+  if (len > 0) {
+    nsIFrame *f = mFloats.LastChild();
+    while (len != 0) {
+      f = f->GetPrevSibling();
+      --len;
+    }
     aState.SetupFloatContinuationList();
-    aState.mFloatContinuations.AppendFrames(nsnull, floatContinuations);
+    if (f) {
+      nsFrameList floatContinuations = mFloats.RemoveFramesAfter(f);
+      aState.mFloatContinuations.AppendFrames(nsnull, floatContinuations);
+    } else {
+      // Move all of mFloats.
+      aState.mFloatContinuations.AppendFrames(nsnull, mFloats);
+    }
   }
 
   // Walk our prev-in-flow's floats and prepend their continuations to our
   // floats list. This pulls any continuations we need to take from our
   // prev-in-flow and makes sure our continuations of its floats are in the
   // proper order.
   nsBlockFrame* prevBlock = static_cast<nsBlockFrame*>(GetPrevInFlow());
   if (!prevBlock)
     return;
-  for (nsIFrame* pf = prevBlock->mFloats.FirstChild(); pf; pf = pf->GetNextSibling()) {
-    nsIFrame* nif = pf->GetNextInFlow();
-    if (!nif)
-      continue;
-    nsContainerFrame* nifParent = static_cast<nsContainerFrame*>(nif->GetParent());
-    nifParent->StealFrame(presContext, nif);
-    if (nif->GetParent() != this) {
-      NS_ASSERTION(!nif->GetNextInFlow(),
-                   "Unexpected next-in-flow for float continuation");
-      ReparentFrame(nif, nifParent, this);
-    }
-    floatContinuations.AppendFrame(this, nif);
-  }
-  if (floatContinuations.NotEmpty())
-    mFloats.InsertFrames(nsnull, nsnull, floatContinuations);
+  len = NS_PTR_TO_INT32(presContext->PropertyTable()->Remove(
+    prevBlock, nsBlockFrame::FloatContinuationCountProperty()));
+  if (len > 0) {
+    nsIFrame *f = prevBlock->mFloats.LastChild();
+    while (len != 0) {
+      ReparentFrame(f, prevBlock, this);
+      f = f->GetPrevSibling();
+      --len;
+    }
+
+    if (f) {
+      nsFrameList floatContinuations = prevBlock->mFloats.RemoveFramesAfter(f);
+      mFloats.InsertFrames(nsnull, nsnull, floatContinuations);
+    } else {
+      // Move all of prevBlock->mFloats.
+      mFloats.InsertFrames(nsnull, nsnull, prevBlock->mFloats);
+    }
+  }
 
 #ifdef DEBUG
   for (nsIFrame* f = mFloats.FirstChild(); f ; f = f->GetNextSibling()) {
     for (nsIFrame* c = f->GetFirstInFlow(); c ; c = c->GetNextInFlow()) {
       NS_ASSERTION(c == f || c->GetParent() != this || !mFloats.ContainsFrame(c),
                    "Two floats with same parent in same floats list, expect weird errors.");
     }
   }
@@ -5770,16 +5783,17 @@ nsBlockFrame::FindTrailingClear()
 }
 
 nsresult
 nsBlockFrame::ReflowFloatContinuations(nsBlockReflowState& aState,
                                        nsRect&             aBounds,
                                        nsReflowStatus&     aStatus)
 {
   nsresult rv = NS_OK;
+  // FIXME
   for (nsIFrame* f = mFloats.FirstChild(); f && f->GetPrevInFlow();
        f = f->GetNextSibling()) {
     if (NS_SUBTREE_DIRTY(f) || aState.mReflowState.ShouldReflowAllKids()) {
       // Cache old bounds
       nsRect oldRect = f->GetRect();
       nsRect oldOverflow = f->GetOverflowRect();
 
       // Reflow
@@ -6095,16 +6109,17 @@ nsBlockFrame::BuildDisplayList(nsDisplay
   }
 #endif
 
   DisplayBorderBackgroundOutline(aBuilder, aLists);
 
   if (GetPrevInFlow()) {
     DisplayOverflowContainers(aBuilder, aDirtyRect, aLists);
     for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
+      // FIXME
       if (f->GetPrevInFlow())
          BuildDisplayListForChild(aBuilder, f, aDirtyRect, aLists);
     }
   }
 
   aBuilder->MarkFramesForDisplayList(this, mFloats, aDirtyRect);
   aBuilder->MarkFramesForDisplayList(this, mAbsoluteContainer.GetChildList(),
                                      aDirtyRect);
@@ -6761,16 +6776,22 @@ nsBlockFrame::CheckFloats(nsBlockReflowS
       continue;
     storedFloats.AppendElement(f);
     if (i < lineFloats.Length() && lineFloats.ElementAt(i) != f) {
       equal = PR_FALSE;
     }
     ++i;
   }
 
+  // Don't worry about the float continuations on the list.  (FIXME: Did
+  // this warning fire all the time before too?)
+  PRInt32 fcCount = NS_PTR_TO_INT32(aState.mPresContext->PropertyTable()->Get(
+    this, nsBlockFrame::FloatContinuationCountProperty()));
+  storedFloats.RemoveElementsAt(storedFloats.Length() - fcCount, fcCount);
+
   if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
     NS_WARNING("nsBlockFrame::CheckFloats: Explicit float list is out of sync with float cache");
 #if defined(DEBUG_roc)
     nsFrame::RootFrameList(PresContext(), stdout, 0);
     for (i = 0; i < lineFloats.Length(); ++i) {
       printf("Line float: %p\n", lineFloats.ElementAt(i));
     }
     for (i = 0; i < storedFloats.Length(); ++i) {
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -92,17 +92,22 @@ class nsIntervalSet;
  * flow frames whose placeholders are in the overflow list.
  * -- A given piece of content has at most one placeholder
  * frame in a block's normal child list.
  * -- While a block is being reflowed, it may have a FloatContinuationProperty
  * frame property that points to an nsFrameList in its
  * nsBlockReflowState. This list contains continuations for
  * floats whose prev-in-flow is in the block's regular float
  * list. The list is always empty/non-existent after the
- * block has been reflowed.
+ * block has been reflowed.  (However, after it has been
+ * reflowed and before the continuations are moved to the
+ * next block, it has a FloatContinuationCountProperty
+ * indicating how many of the elements at the end of its
+ * float list are continuations that should be pulled to
+ * the block's continuation.)
  * -- In all these frame lists, if there are two frames for
  * the same content appearing in the list, then the frames
  * appear with the prev-in-flow before the next-in-flow.
  * -- While reflowing a block, its overflow line list
  * will usually be empty but in some cases will have lines
  * (while we reflow the block at its shrink-wrap width).
  * In this case any new overflowing content must be
  * prepended to the overflow lines.
@@ -152,16 +157,17 @@ public:
   reverse_line_iterator rbegin_lines() { return mLines.rbegin(); }
   reverse_line_iterator rend_lines() { return mLines.rend(); }
   const_reverse_line_iterator rbegin_lines() const { return mLines.rbegin(); }
   const_reverse_line_iterator rend_lines() const { return mLines.rend(); }
 
   friend nsIFrame* NS_NewBlockFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
 
   NS_DECLARE_FRAME_PROPERTY(FloatContinuationProperty, nsnull)
+  NS_DECLARE_FRAME_PROPERTY(FloatContinuationCountProperty, nsnull)
 
   // nsQueryFrame
   NS_DECL_QUERYFRAME
 
   // nsIFrame
   NS_IMETHOD Init(nsIContent*      aContent,
                   nsIFrame*        aParent,
                   nsIFrame*        aPrevInFlow);
