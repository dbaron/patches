# HG changeset patch
# User Boris Zbarsky <bzbarsky@mit.edu>
# Date 1308979307 14400
Bug 667079.  Make sure to set the right containing block size for inner tables no matter what.  r=dbaron

diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -1578,17 +1578,19 @@ nsHTMLReflowState::ComputeContainingBloc
       aContainingBlockHeight += aContainingBlockRS->mComputedPadding.TopBottom();
     }
   } else {
     // an element in quirks mode gets a containing block based on looking for a
     // parent with a non-auto height if the element has a percent height
     // Note: We don't emulate this quirk for percents in calc().
     if (NS_AUTOHEIGHT == aContainingBlockHeight) {
       if (eCompatibility_NavQuirks == aPresContext->CompatibilityMode() &&
-          mStylePosition->mHeight.GetUnit() == eStyleUnit_Percent) {
+          (mStylePosition->mHeight.GetUnit() == eStyleUnit_Percent ||
+           (frame->GetType() == nsGkAtoms::tableOuterFrame &&
+            frame->GetFirstChild(nsnull)->GetStylePosition()->mHeight.GetUnit() == eStyleUnit_Percent))) {
         aContainingBlockHeight = CalcQuirkContainingBlockHeight(aContainingBlockRS);
       }
     }
   }
 }
 
 // Prefs callback to pick up changes
 static int
@@ -1854,16 +1856,21 @@ nsHTMLReflowState::InitConstraints(nsPre
                    mComputedHeight >= 0, "Bogus height");
 
       // Exclude inline tables from the block margin calculations
       if (isBlock && !IsSideCaption(frame, mStyleDisplay) &&
           frame->GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_INLINE_TABLE)
         CalculateBlockSideMargins(availableWidth, mComputedWidth, aFrameType);
     }
   }
+
+  // Save our containing block dimensions
+  mContainingBlockWidth = aContainingBlockWidth;
+  mContainingBlockHeight = aContainingBlockHeight;
+
   // Check for blinking text and permission to display it
   mFlags.mBlinks = (parentReflowState && parentReflowState->mFlags.mBlinks);
   if (!mFlags.mBlinks && BlinkIsAllowed()) {
     const nsStyleTextReset* st = frame->GetStyleTextReset();
     mFlags.mBlinks = (st->mTextBlink != NS_STYLE_TEXT_BLINK_NONE);
   }
 }
 
diff --git a/layout/generic/nsHTMLReflowState.h b/layout/generic/nsHTMLReflowState.h
--- a/layout/generic/nsHTMLReflowState.h
+++ b/layout/generic/nsHTMLReflowState.h
@@ -309,16 +309,19 @@ public:
   nsMargin         mComputedOffsets;
 
   // Computed values for 'min-width/max-width' and 'min-height/max-height'
   // XXXldb The width ones here should go; they should be needed only
   // internally.
   nscoord          mComputedMinWidth, mComputedMaxWidth;
   nscoord          mComputedMinHeight, mComputedMaxHeight;
 
+  // Our saved containing block dimensions.
+  nscoord          mContainingBlockWidth, mContainingBlockHeight;
+
   // Cached pointers to the various style structs used during intialization
   const nsStyleDisplay*    mStyleDisplay;
   const nsStyleVisibility* mStyleVisibility;
   const nsStylePosition*   mStylePosition;
   const nsStyleBorder*     mStyleBorder;
   const nsStyleMargin*     mStyleMargin;
   const nsStylePadding*    mStylePadding;
   const nsStyleText*       mStyleText;
diff --git a/layout/reftests/bugs/10209-1.html b/layout/reftests/bugs/10209-1.html
--- a/layout/reftests/bugs/10209-1.html
+++ b/layout/reftests/bugs/10209-1.html
@@ -3,14 +3,14 @@
 @font-face {
   font-family: Ahem;
   src: url(../fonts/Ahem.ttf);
 }
 * {
   font-family: Ahem;
 }
 </style>
-<body style="font-size: 100px; padding-top: 5px">
-  <div style="position: relative; display: inline;">
-    <table style="height: 50%; position: absolute; width: 50px; background: green">
+<body style="font-size: 100px; line-height: 1">
+  <div style="position: relative; display: inline; color: white">x
+    <table style="height: 50%; position: absolute; width: 50px; background: green; top: 0; left: 0">
     </table>
   </div>
 </body>
diff --git a/layout/reftests/bugs/667079-1-ref.html b/layout/reftests/bugs/667079-1-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/667079-1-ref.html
@@ -0,0 +1,4 @@
+<!DOCTYPE HTML>
+<body style="font-size: 100px;">
+  <div style="position: relative; display: inline; background: red;">X<table style="height: 100%; position: absolute; width: 100%; background: green; top: 0; left: 0"></table></div>
+</body>
diff --git a/layout/reftests/bugs/667079-1.html b/layout/reftests/bugs/667079-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/667079-1.html
@@ -0,0 +1,5 @@
+<!DOCTYPE HTML>
+<body onload="document.body.style.fontSize = '100px'"
+      style="font-size: 50px;">
+  <div style="position: relative; display: inline; background: red;">X<table style="height: 100%; position: absolute; width: 100%; background: green; top: 0; left: 0"></table></div>
+</body>
diff --git a/layout/reftests/bugs/reftest.list b/layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list
+++ b/layout/reftests/bugs/reftest.list
@@ -13,19 +13,19 @@
 == 9458-width-2a.html 9458-width-2-ref.html
 == 9458-width-2b.html 9458-width-2-ref.html
 == 9458-zorder-1.html 9458-zorder-ref.html
 == 9458-zorder-2.html 9458-zorder-ref.html
 == 9458-zorder-3.html 9458-zorder-ref-inline.html
 == 9458-zorder-4.html 9458-zorder-ref-inline-block.html
 == 9458-zorder-5.html 9458-zorder-ref-inline-block.html
 == 10036-1.html 10036-1-ref.html
-skip-if(!cocoaWidget) HTTP(..) == 10209-1.html 10209-ref.html # Bug 667079
+HTTP(..) == 10209-1.html 10209-ref.html
 HTTP(..) == 10209-2.html 10209-ref.html
-asserts(4) skip-if(!cocoaWidget) HTTP(..) == 10209-3.html 10209-3-ref.html # Assertions: bug 666606, skip because of bug 667079
+HTTP(..) == 10209-3.html 10209-3-ref.html
 == 18217-basic-1.html 18217-basic-1-ref.html
 == 18217-basic-2a.html 18217-basic-2-ref.html
 == 18217-basic-2b.html 18217-basic-2-ref.html
 == 18217-valign-1.html 18217-valign-1-ref.html
 == 18217-height-1.html 18217-height-1-ref.html
 == 18217-height-2.html 18217-height-2-ref.html
 == 18217-width-1a.html 18217-width-1-ref.html
 == 18217-width-1b.html 18217-width-1-ref.html
@@ -1645,8 +1645,9 @@ fails-if(layersGPUAccelerated&&cocoaWidg
 HTTP(..) == 654057-1.html 654057-1-ref.html
 fails-if(layersGPUAccelerated&&cocoaWidget) == 654950-1.html 654950-1-ref.html # Quartz alpha blending doesn't match GL alpha blending
 == 652775-1.html 652775-1-ref.html
 == 655549-1.html 655549-1-ref.html
 != 656875.html about:blank
 == 658952.html 658952-ref.html
 == 664127-1.xul 664127-1-ref.xul
 == 660682-1.html 660682-1-ref.html
+== 667079-1.html 667079-1-ref.html
diff --git a/layout/tables/nsTableOuterFrame.cpp b/layout/tables/nsTableOuterFrame.cpp
--- a/layout/tables/nsTableOuterFrame.cpp
+++ b/layout/tables/nsTableOuterFrame.cpp
@@ -424,30 +424,43 @@ nsTableOuterFrame::GetParentStyleContext
   *aProviderFrame = mInnerTableFrame;
   *aIsChild = PR_TRUE;
   return NS_OK;
 }
 
 // INCREMENTAL REFLOW HELPER FUNCTIONS 
 
 void
-nsTableOuterFrame::InitChildReflowState(nsPresContext&    aPresContext,                     
+nsTableOuterFrame::InitChildReflowState(nsPresContext&    aPresContext,
+                                        const nsHTMLReflowState& aOuterRS,
                                         nsHTMLReflowState& aReflowState)
                                     
 {
   nsMargin collapseBorder;
   nsMargin collapsePadding(0,0,0,0);
   nsMargin* pCollapseBorder  = nsnull;
   nsMargin* pCollapsePadding = nsnull;
   if ((aReflowState.frame == mInnerTableFrame) && (mInnerTableFrame->IsBorderCollapse())) {
     collapseBorder  = mInnerTableFrame->GetIncludedOuterBCBorder();
     pCollapseBorder = &collapseBorder;
     pCollapsePadding = &collapsePadding;
   }
-  aReflowState.Init(&aPresContext, -1, -1, pCollapseBorder, pCollapsePadding);
+  nscoord containingBlockWidth, containingBlockHeight;
+  if (aReflowState.frame == mCaptionFrame) {
+    containingBlockWidth = containingBlockHeight = -1;
+  } else {
+    NS_ABORT_IF_FALSE(aReflowState.frame == mInnerTableFrame,
+                      "Unexpected frame");
+    // For inner table frames, the containing block is the same as for
+    // the outer table frame.
+    containingBlockWidth = aOuterRS.mContainingBlockWidth;
+    containingBlockHeight = aOuterRS.mContainingBlockHeight;
+  }
+  aReflowState.Init(&aPresContext, containingBlockWidth, containingBlockHeight,
+                    pCollapseBorder, pCollapsePadding);
 }
 
 // get the margin and padding data. nsHTMLReflowState doesn't handle the
 // case of auto margins
 void
 nsTableOuterFrame::GetChildMargin(nsPresContext*           aPresContext,
                                   const nsHTMLReflowState& aOuterRS,
                                   nsIFrame*                aChildFrame,
@@ -457,17 +470,17 @@ nsTableOuterFrame::GetChildMargin(nsPres
   // construct a reflow state to compute margin and padding. Auto margins
   // will not be computed at this time.
 
   // create and init the child reflow state
   // XXX We really shouldn't construct a reflow state to do this.
   nsHTMLReflowState childRS(aPresContext, aOuterRS, aChildFrame,
                             nsSize(aAvailWidth, aOuterRS.availableHeight),
                             -1, -1, PR_FALSE);
-  InitChildReflowState(*aPresContext, childRS);
+  InitChildReflowState(*aPresContext, aOuterRS, childRS);
 
   aMargin = childRS.mComputedMargin;
 }
 
 static nsSize
 GetContainingBlockSize(const nsHTMLReflowState& aOuterRS)
 {
   nsSize size(0,0);
@@ -895,17 +908,17 @@ nsTableOuterFrame::OuterBeginReflowChild
   }
   nsSize availSize(aAvailWidth, availHeight);
   // create and init the child reflow state, using placement new on
   // stack space allocated by the caller, so that the caller can destroy
   // it
   nsHTMLReflowState &childRS = * new (aChildRSSpace)
     nsHTMLReflowState(aPresContext, aOuterRS, aChildFrame, availSize,
                       -1, -1, PR_FALSE);
-  InitChildReflowState(*aPresContext, childRS);
+  InitChildReflowState(*aPresContext, aOuterRS, childRS);
 
   // see if we need to reset top of page due to a caption
   if (mCaptionFrame) {
     PRUint8 captionSide = GetCaptionSide();
     if (((captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM ||
           captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE) &&
          mCaptionFrame == aChildFrame) || 
         ((captionSide == NS_STYLE_CAPTION_SIDE_TOP ||
diff --git a/layout/tables/nsTableOuterFrame.h b/layout/tables/nsTableOuterFrame.h
--- a/layout/tables/nsTableOuterFrame.h
+++ b/layout/tables/nsTableOuterFrame.h
@@ -189,17 +189,18 @@ public:
   NS_IMETHOD GetRowAndColumnByIndex(PRInt32 aIndex, PRInt32 *aRow, PRInt32 *aColumn);
 
 protected:
 
 
   nsTableOuterFrame(nsStyleContext* aContext);
   virtual ~nsTableOuterFrame();
 
-  void InitChildReflowState(nsPresContext&    aPresContext,                     
+  void InitChildReflowState(nsPresContext&    aPresContext,
+                            const nsHTMLReflowState& aOuterRS,
                             nsHTMLReflowState& aReflowState);
 
   /** Always returns 0, since the outer table frame has no border of its own
     * The inner table frame can answer this question in a meaningful way.
     * @see nsHTMLContainerFrame::GetSkipSides */
   virtual PRIntn GetSkipSides() const;
 
   PRUint8 GetCaptionSide(); // NS_STYLE_CAPTION_SIDE_* or NO_SIDE
