Delete old private data array after setting the new one on the thread.

diff --git a/nsprpub/pr/src/threads/prtpd.c b/nsprpub/pr/src/threads/prtpd.c
--- a/nsprpub/pr/src/threads/prtpd.c
+++ b/nsprpub/pr/src/threads/prtpd.c
@@ -186,6 +186,7 @@ PR_IMPLEMENT(PRStatus) PR_SetThreadPriva
 
     if ((NULL == self->privateData) || (self->tpdLength <= index))
     {
+        void *original = NULL;
         void *extension = PR_CALLOC(_pr_tpd_length * sizeof(void*));
         if (NULL == extension)
         {
@@ -196,10 +197,17 @@ PR_IMPLEMENT(PRStatus) PR_SetThreadPriva
             (void)memcpy(
                 extension, self->privateData,
                 self->tpdLength * sizeof(void*));
-            PR_DELETE(self->privateData);
+            original = self->privateData;
         }
         self->tpdLength = _pr_tpd_length;
         self->privateData = (void**)extension;
+        if (NULL != original) {
+            /*
+            ** Need to delete after setting self->privateData in case a
+            ** debugging tool that hooks free calls PR_GetPrivateData.
+            */
+            PR_DELETE(original);
+        }
     }
     /*
     ** There wasn't much chance of having to call the destructor
