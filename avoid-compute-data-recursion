Avoid potential recursion into Compute*Data on the same rule node (for an inherited struct), which can cause a leak.  b=383979

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -1761,6 +1761,11 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
  * @param rdata_ Variable (declared here) holding the nsCSS* used here.
  */
 #define COMPUTE_START_INHERITED(type_, ctorargs_, data_, parentdata_, rdtype_, rdata_) \
+  NS_ASSERTION(aRuleDetail != eRuleFullInherited &&                           \
+               aRuleDetail != eRulePartialInherited &&                        \
+               aRuleDetail != eRuleNone,                                      \
+               "should not have bothered calling Compute*Data");              \
+                                                                              \
   nsStyleContext* parentContext = aContext->GetParent();                      \
                                                                               \
   const nsRuleData##rdtype_& rdata_ =                                         \
@@ -1769,7 +1774,12 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
   const nsStyle##type_* parentdata_ = nsnull;                                 \
   PRBool inherited = aInherited;                                              \
                                                                               \
-  if (parentContext && aRuleDetail != eRuleFullReset)                         \
+  /* If |inherited| might by false by the time we're done, we can't call */   \
+  /* parentContext->GetStyle##type_() since it could recur into setting */    \
+  /* the same struct on the same rule node, causing a leak. */                \
+  if (parentContext && aRuleDetail != eRuleFullReset &&                       \
+      (!aStartStruct ||                                                       \
+       (aRuleDetail != eRulePartialReset && aRuleDetail != eRuleNone)))       \
     parentdata_ = parentContext->GetStyle##type_();                           \
   if (aStartStruct)                                                           \
     /* We only need to compute the delta between this computed data and */    \
@@ -1777,7 +1787,6 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
     data_ = new (mPresContext)                                                \
             nsStyle##type_(*static_cast<nsStyle##type_*>(aStartStruct));      \
   else {                                                                      \
-    /* XXXldb What about eRuleFullInherited?  Which path is faster? */        \
     if (aRuleDetail != eRuleFullMixed && aRuleDetail != eRuleFullReset) {     \
       /* No question. We will have to inherit. Go ahead and init */           \
       /* with inherited vals from parent. */                                  \
@@ -1809,6 +1818,9 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
  * @param rdata_ Variable (declared here) holding the nsCSS* used here.
  */
 #define COMPUTE_START_RESET(type_, ctorargs_, data_, parentdata_, rdtype_, rdata_) \
+  NS_ASSERTION(aRuleDetail != eRuleFullInherited,                             \
+               "should not have bothered calling Compute*Data");              \
+                                                                              \
   nsStyleContext* parentContext = aContext->GetParent();                      \
                                                                               \
   const nsRuleData##rdtype_& rdata_ =                                         \
@@ -1825,6 +1837,9 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
   if (NS_UNLIKELY(!data_))                                                    \
     return nsnull;  /* Out Of Memory */                                       \
                                                                               \
+  /* If |inherited| might by false by the time we're done, we can't call */   \
+  /* parentContext->GetStyle##type_() since it could recur into setting */    \
+  /* the same struct on the same rule node, causing a leak. */                \
   const nsStyle##type_* parentdata_ = data_;                                  \
   if (parentContext &&                                                        \
       aRuleDetail != eRuleFullReset &&                                        \
