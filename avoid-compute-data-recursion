Avoid potential recursion into Compute*Data on the same rule node (for an inherited struct), which can cause a leak.  b=383979

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -709,18 +709,26 @@ CheckFontCallback(const nsRuleDataStruct
 
   // em, ex, percent, 'larger', and 'smaller' values on font-size depend
   // on the parent context's font-size
+  // Likewise, 'lighter' and 'bolder' values of 'font-weight' depend on
+  // the parent.
   const nsCSSValue& size = fontData.mSize;
+  const nsCSSValue& weight = fontData.mWeight;
   if ((size.IsRelativeLengthUnit() && size.GetUnit() != eCSSUnit_Pixel) ||
       size.GetUnit() == eCSSUnit_Percent ||
       (size.GetUnit() == eCSSUnit_Enumerated &&
        (size.GetIntValue() == NS_STYLE_FONT_SIZE_SMALLER ||
-        size.GetIntValue() == NS_STYLE_FONT_SIZE_LARGER))) {
+        size.GetIntValue() == NS_STYLE_FONT_SIZE_LARGER)) ||
+      (weight.GetUnit() == eCSSUnit_Enumerated &&
+       (weight.GetIntValue() == NS_STYLE_FONT_WEIGHT_BOLDER ||
+        weight.GetIntValue() == NS_STYLE_FONT_WEIGHT_LIGHTER))) {
     NS_ASSERTION(aResult == nsRuleNode::eRulePartialReset ||
                  aResult == nsRuleNode::eRuleFullReset ||
                  aResult == nsRuleNode::eRulePartialMixed ||
                  aResult == nsRuleNode::eRuleFullMixed,
                  "we know we already have a reset-counted property");
-    // promote reset to mixed since we have something inherited
+    // Promote reset to mixed since we have something that depends on
+    // the parent.  But never promote to inherited since that could
+    // cause inheritance of the exact value.
     if (aResult == nsRuleNode::eRulePartialReset)
       aResult = nsRuleNode::eRulePartialMixed;
     else if (aResult == nsRuleNode::eRuleFullReset)
@@ -1422,6 +1430,11 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
     ruleNode = ruleNode->mParent;
   }
 
+  NS_ASSERTION(!startStruct || (detail != eRuleFullReset &&
+                                detail != eRuleFullMixed &&
+                                detail != eRuleFullInherited),
+               "can't have start struct and be fully specified");
+
   PRBool isReset = nsCachedStyleData::IsReset(aSID);
   if (!highestNode)
     highestNode = rootNode;
@@ -1439,8 +1452,10 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
     PropagateDependentBit(bit, ruleNode);
     return startStruct;
   }
-  else if (!startStruct && ((!isReset && (detail == eRuleNone || detail == eRulePartialInherited)) 
-                             || detail == eRuleFullInherited)) {
+  // FIXME Do we need to check for mPostResolveCallback?
+  if ((!startStruct && !isReset &&
+       (detail == eRuleNone || detail == eRulePartialInherited)) ||
+      detail == eRuleFullInherited) {
     // We specified no non-inherited information and neither did any of
     // our parent rules.
 
@@ -1765,6 +1780,9 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
  * @param rdata_ Variable (declared here) holding the nsCSS* used here.
  */
 #define COMPUTE_START_INHERITED(type_, ctorargs_, data_, parentdata_, rdtype_, rdata_) \
+  NS_ASSERTION(aRuleDetail != eRuleFullInherited,                             \
+               "should not have bothered calling Compute*Data");              \
+                                                                              \
   nsStyleContext* parentContext = aContext->GetParent();                      \
                                                                               \
   const nsRuleData##rdtype_& rdata_ =                                         \
@@ -1773,7 +1791,12 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
   const nsStyle##type_* parentdata_ = nsnull;                                 \
   PRBool inherited = aInherited;                                              \
                                                                               \
-  if (parentContext && aRuleDetail != eRuleFullReset)                         \
+  /* If |inherited| might be false by the time we're done, we can't call */   \
+  /* parentContext->GetStyle##type_() since it could recur into setting */    \
+  /* the same struct on the same rule node, causing a leak. */                \
+  if (parentContext && aRuleDetail != eRuleFullReset &&                       \
+      (!aStartStruct || (aRuleDetail != eRulePartialReset &&                  \
+                         aRuleDetail != eRuleNone)))                          \
     parentdata_ = parentContext->GetStyle##type_();                           \
   if (aStartStruct)                                                           \
     /* We only need to compute the delta between this computed data and */    \
@@ -1781,7 +1804,6 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
     data_ = new (mPresContext)                                                \
             nsStyle##type_(*static_cast<nsStyle##type_*>(aStartStruct));      \
   else {                                                                      \
-    /* XXXldb What about eRuleFullInherited?  Which path is faster? */        \
     if (aRuleDetail != eRuleFullMixed && aRuleDetail != eRuleFullReset) {     \
       /* No question. We will have to inherit. Go ahead and init */           \
       /* with inherited vals from parent. */                                  \
@@ -1813,6 +1835,9 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
  * @param rdata_ Variable (declared here) holding the nsCSS* used here.
  */
 #define COMPUTE_START_RESET(type_, ctorargs_, data_, parentdata_, rdtype_, rdata_) \
+  NS_ASSERTION(aRuleDetail != eRuleFullInherited,                             \
+               "should not have bothered calling Compute*Data");              \
+                                                                              \
   nsStyleContext* parentContext = aContext->GetParent();                      \
                                                                               \
   const nsRuleData##rdtype_& rdata_ =                                         \
@@ -1829,6 +1854,9 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
   if (NS_UNLIKELY(!data_))                                                    \
     return nsnull;  /* Out Of Memory */                                       \
                                                                               \
+  /* If |inherited| might be false by the time we're done, we can't call */   \
+  /* parentContext->GetStyle##type_() since it could recur into setting */    \
+  /* the same struct on the same rule node, causing a leak. */                \
   const nsStyle##type_* parentdata_ = data_;                                  \
   if (parentContext &&                                                        \
       aRuleDetail != eRuleFullReset &&                                        \
@@ -2339,10 +2367,9 @@ nsRuleNode::ComputeFontData(nsStyleStruc
   // Now compute our font struct
   if (generic == kGenericFont_NONE) {
     // continue the normal processing
-    // our default font is the most recent generic font
-    // XXXldb Probably should be the serif/sans-serif pref instead.
+    // our default font is the user's default (serif or sans-serif)
     const nsFont* defaultFont =
-      mPresContext->GetDefaultFont(parentFont->mFlags & NS_STYLE_FONT_FACE_MASK);
+      mPresContext->GetDefaultFont(kPresContext_DefaultVariableFont_ID);
 
     nsRuleNode::SetFont(mPresContext, aContext, minimumFontSize, PR_FALSE,
                         fontData, *defaultFont, parentFont, font, inherited);
