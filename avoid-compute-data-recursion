Avoid potential recursion into Compute*Data on the same rule node (for an inherited struct), which can cause a leak.  b=383979

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -1422,6 +1422,11 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
     ruleNode = ruleNode->mParent;
   }
 
+  NS_ASSERTION(!startStruct || (detail != eRuleFullReset &&
+                                detail != eRuleFullMixed &&
+                                detail != eRuleFullInherited),
+               "can't have start struct and be fully specified");
+
   PRBool isReset = nsCachedStyleData::IsReset(aSID);
   if (!highestNode)
     highestNode = rootNode;
@@ -1439,8 +1444,10 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
     PropagateDependentBit(bit, ruleNode);
     return startStruct;
   }
-  else if (!startStruct && ((!isReset && (detail == eRuleNone || detail == eRulePartialInherited)) 
-                             || detail == eRuleFullInherited)) {
+  // FIXME Do we need to check for mPostResolveCallback?
+  if ((!startStruct && !isReset &&
+       (detail == eRuleNone || detail == eRulePartialInherited)) ||
+      detail == eRuleFullInherited) {
     // We specified no non-inherited information and neither did any of
     // our parent rules.
 
@@ -1765,6 +1772,9 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
  * @param rdata_ Variable (declared here) holding the nsCSS* used here.
  */
 #define COMPUTE_START_INHERITED(type_, ctorargs_, data_, parentdata_, rdtype_, rdata_) \
+  NS_ASSERTION(aRuleDetail != eRuleFullInherited,                             \
+               "should not have bothered calling Compute*Data");              \
+                                                                              \
   nsStyleContext* parentContext = aContext->GetParent();                      \
                                                                               \
   const nsRuleData##rdtype_& rdata_ =                                         \
@@ -1773,7 +1783,12 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
   const nsStyle##type_* parentdata_ = nsnull;                                 \
   PRBool inherited = aInherited;                                              \
                                                                               \
-  if (parentContext && aRuleDetail != eRuleFullReset)                         \
+  /* If |inherited| might be false by the time we're done, we can't call */   \
+  /* parentContext->GetStyle##type_() since it could recur into setting */    \
+  /* the same struct on the same rule node, causing a leak. */                \
+  if (parentContext && aRuleDetail != eRuleFullReset &&                       \
+      (!aStartStruct || (aRuleDetail != eRulePartialReset &&                  \
+                         aRuleDetail != eRuleNone)))                          \
     parentdata_ = parentContext->GetStyle##type_();                           \
   if (aStartStruct)                                                           \
     /* We only need to compute the delta between this computed data and */    \
@@ -1781,7 +1796,6 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
     data_ = new (mPresContext)                                                \
             nsStyle##type_(*static_cast<nsStyle##type_*>(aStartStruct));      \
   else {                                                                      \
-    /* XXXldb What about eRuleFullInherited?  Which path is faster? */        \
     if (aRuleDetail != eRuleFullMixed && aRuleDetail != eRuleFullReset) {     \
       /* No question. We will have to inherit. Go ahead and init */           \
       /* with inherited vals from parent. */                                  \
@@ -1813,6 +1827,9 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
  * @param rdata_ Variable (declared here) holding the nsCSS* used here.
  */
 #define COMPUTE_START_RESET(type_, ctorargs_, data_, parentdata_, rdtype_, rdata_) \
+  NS_ASSERTION(aRuleDetail != eRuleFullInherited,                             \
+               "should not have bothered calling Compute*Data");              \
+                                                                              \
   nsStyleContext* parentContext = aContext->GetParent();                      \
                                                                               \
   const nsRuleData##rdtype_& rdata_ =                                         \
@@ -1829,6 +1846,9 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
   if (NS_UNLIKELY(!data_))                                                    \
     return nsnull;  /* Out Of Memory */                                       \
                                                                               \
+  /* If |inherited| might be false by the time we're done, we can't call */   \
+  /* parentContext->GetStyle##type_() since it could recur into setting */    \
+  /* the same struct on the same rule node, causing a leak. */                \
   const nsStyle##type_* parentdata_ = data_;                                  \
   if (parentContext &&                                                        \
       aRuleDetail != eRuleFullReset &&                                        \
@@ -2339,10 +2359,9 @@ nsRuleNode::ComputeFontData(nsStyleStruc
   // Now compute our font struct
   if (generic == kGenericFont_NONE) {
     // continue the normal processing
-    // our default font is the most recent generic font
-    // XXXldb Probably should be the serif/sans-serif pref instead.
+    // our default font is the user's default (serif or sans-serif)
     const nsFont* defaultFont =
-      mPresContext->GetDefaultFont(parentFont->mFlags & NS_STYLE_FONT_FACE_MASK);
+      mPresContext->GetDefaultFont(kPresContext_DefaultVariableFont_ID);
 
     nsRuleNode::SetFont(mPresContext, aContext, minimumFontSize, PR_FALSE,
                         fontData, *defaultFont, parentFont, font, inherited);
