From: L. David Baron <dbaron@dbaron.org>

Bug 1367576 - Cache results of getting GTK widget borders.  r?karlt

See comments in the header file.

This also clears out mSafeWidgetStates in ThemeChanged since that seems
like a good thing to do, and marks nsNativeThemeGTK as final to avoid
the cost of the virtual function call to ThemeChanged in the
constructor.

MozReview-Commit-ID: 5Zne4eGbGlh

diff --git a/widget/gtk/nsNativeThemeGTK.cpp b/widget/gtk/nsNativeThemeGTK.cpp
--- a/widget/gtk/nsNativeThemeGTK.cpp
+++ b/widget/gtk/nsNativeThemeGTK.cpp
@@ -65,18 +65,17 @@ nsNativeThemeGTK::nsNativeThemeGTK()
     return;
   }
 
   // We have to call moz_gtk_shutdown before the event loop stops running.
   nsCOMPtr<nsIObserverService> obsServ =
     mozilla::services::GetObserverService();
   obsServ->AddObserver(this, "xpcom-shutdown", false);
 
-  memset(mDisabledWidgetTypes, 0, sizeof(mDisabledWidgetTypes));
-  memset(mSafeWidgetStates, 0, sizeof(mSafeWidgetStates));
+  ThemeChanged();
 }
 
 nsNativeThemeGTK::~nsNativeThemeGTK() {
 }
 
 NS_IMETHODIMP
 nsNativeThemeGTK::Observe(nsISupports *aSubject, const char *aTopic,
                           const char16_t *aData)
@@ -1264,19 +1263,29 @@ nsNativeThemeGTK::GetCachedWidgetBorder(
                                         nsIntMargin* aResult)
 {
   aResult->SizeTo(0, 0, 0, 0);
 
   WidgetNodeType gtkWidgetType;
   gint unusedFlags;
   if (GetGtkWidgetAndState(aWidgetType, aFrame, gtkWidgetType, nullptr,
                            &unusedFlags)) {
-    moz_gtk_get_widget_border(gtkWidgetType, &aResult->left, &aResult->top,
-                              &aResult->right, &aResult->bottom, aDirection,
-                              IsFrameContentNodeInNamespace(aFrame, kNameSpaceID_XHTML));
+    MOZ_ASSERT(0 <= gtkWidgetType && gtkWidgetType < MOZ_GTK_WIDGET_NODE_COUNT);
+    uint8_t cacheIndex = gtkWidgetType / 8;
+    uint8_t cacheBit = 1u << (gtkWidgetType % 8);
+
+    if (mBorderCacheValid[cacheIndex] & cacheBit) {
+      *aResult = mBorderCache[gtkWidgetType];
+    } else {
+      moz_gtk_get_widget_border(gtkWidgetType, &aResult->left, &aResult->top,
+                                &aResult->right, &aResult->bottom, aDirection,
+                                IsFrameContentNodeInNamespace(aFrame, kNameSpaceID_XHTML));
+      mBorderCacheValid[cacheIndex] |= cacheBit;
+      mBorderCache[gtkWidgetType] = *aResult;
+    }
   }
 }
 
 NS_IMETHODIMP
 nsNativeThemeGTK::GetWidgetBorder(nsDeviceContext* aContext, nsIFrame* aFrame,
                                   uint8_t aWidgetType, nsIntMargin* aResult)
 {
   GtkTextDirection direction = GetTextDirection(aFrame);
@@ -1776,16 +1785,18 @@ nsNativeThemeGTK::WidgetStateChanged(nsI
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsNativeThemeGTK::ThemeChanged()
 {
   memset(mDisabledWidgetTypes, 0, sizeof(mDisabledWidgetTypes));
+  memset(mSafeWidgetStates, 0, sizeof(mSafeWidgetStates));
+  memset(mBorderCacheValid, 0, sizeof(mBorderCacheValid));
   return NS_OK;
 }
 
 NS_IMETHODIMP_(bool)
 nsNativeThemeGTK::ThemeSupportsWidget(nsPresContext* aPresContext,
                                       nsIFrame* aFrame,
                                       uint8_t aWidgetType)
 {
diff --git a/widget/gtk/nsNativeThemeGTK.h b/widget/gtk/nsNativeThemeGTK.h
--- a/widget/gtk/nsNativeThemeGTK.h
+++ b/widget/gtk/nsNativeThemeGTK.h
@@ -10,19 +10,19 @@
 #include "nsCOMPtr.h"
 #include "nsIAtom.h"
 #include "nsIObserver.h"
 #include "nsNativeTheme.h"
 
 #include <gtk/gtk.h>
 #include "gtkdrawing.h"
 
-class nsNativeThemeGTK: private nsNativeTheme,
-                        public nsITheme,
-                        public nsIObserver {
+class nsNativeThemeGTK final : private nsNativeTheme,
+                               public nsITheme,
+                               public nsIObserver {
 public:
   NS_DECL_ISUPPORTS_INHERITED
 
   NS_DECL_NSIOBSERVER
 
   // The nsITheme interface.
   NS_IMETHOD DrawWidgetBackground(nsRenderingContext* aContext,
                                   nsIFrame* aFrame, uint8_t aWidgetType,
@@ -84,13 +84,18 @@ private:
 
   void RefreshWidgetWindow(nsIFrame* aFrame);
   WidgetNodeType NativeThemeToGtkTheme(uint8_t aWidgetType, nsIFrame* aFrame);
 
   uint8_t mDisabledWidgetTypes[32];
   uint8_t mSafeWidgetStates[1024];    // 256 widgets * 32 bits per widget
   static const char* sDisabledEngines[];
 
+  // Because moz_gtk_get_widget_border can be slow, we cache its results
+  // by widget type.  Each bit in mBorderCacheValid says whether the
+  // corresponding entry in mBorderCache is valid.
   void GetCachedWidgetBorder(nsIFrame* aFrame, uint8_t aWidgetType,
                              GtkTextDirection aDirection, nsIntMargin* aResult);
+  uint8_t mBorderCacheValid[(MOZ_GTK_WIDGET_NODE_COUNT + 7) / 8];
+  nsIntMargin mBorderCache[MOZ_GTK_WIDGET_NODE_COUNT];
 };
 
 #endif
