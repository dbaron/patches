From: L. David Baron <dbaron@dbaron.org>

Keep PLDHashTable's second hash small to reduce the size of jumps across memory and improve cache behavior.

FIXME: But wasn't it bad that the << is by sizeLog2 rather than
hashShift!?  Can't that just leave a run of 1s or 0s in hash2, if
sizeLog2 > 16?  (Given the comments about kMaxCapacity, it seems like
that happens!)  And it's not just the 0s that appeared from the
shifting, but also the low bit of aHash is always 0 (because we removed
the collision flag).

MozReview-Commit-ID: JvnxAMBY711

diff --git a/xpcom/ds/PLDHashTable.cpp b/xpcom/ds/PLDHashTable.cpp
--- a/xpcom/ds/PLDHashTable.cpp
+++ b/xpcom/ds/PLDHashTable.cpp
@@ -255,18 +255,24 @@ PLDHashTable::Hash1(PLDHashNumber aHash0
 
 // Double hashing needs the second hash code to be relatively prime to table
 // size, so we simply make hash2 odd.
 void
 PLDHashTable::Hash2(PLDHashNumber aHash,
                     uint32_t& aHash2Out, uint32_t& aSizeMaskOut)
 {
   uint32_t sizeLog2 = kHashBits - mHashShift;
-  aHash2Out = ((aHash << sizeLog2) >> mHashShift) | 1;
   aSizeMaskOut = (PLDHashNumber(1) << sizeLog2) - 1;
+  // Keep the jumps from the second hash small, to improve cache behavior.
+  uint16_t hashShift = mHashShift;
+  if (sizeLog2 > 6) {
+    sizeLog2 = 6;
+    hashShift = kHashBits - 6;
+  }
+  aHash2Out = ((aHash << sizeLog2) >> hashShift) | 1;
 }
 
 // Reserve mKeyHash 0 for free entries and 1 for removed-entry sentinels. Note
 // that a removed-entry sentinel need be stored only if the removed entry had
 // a colliding entry added after it. Therefore we can use 1 as the collision
 // flag in addition to the removed-entry sentinel value. Multiplicative hash
 // uses the high order bits of mKeyHash, so this least-significant reservation
 // should not hurt the hash function's effectiveness much.
