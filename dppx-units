From: L. David Baron <dbaron@dbaron.org>

Implement dppx units [css3-images] for resolution media query.  (Bug 741644)

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -1837,16 +1837,18 @@ CSSParserImpl::ParseMediaQueryExpression
         UngetToken();
         break;
       }
       // No worries about whether unitless zero is allowed, since the
       // value must be positive (and we checked that above).
       NS_ASSERTION(!mToken.mIdent.IsEmpty(), "unit lied");
       if (mToken.mIdent.LowerCaseEqualsLiteral("dpi")) {
         expr->mValue.SetFloatValue(mToken.mNumber, eCSSUnit_Inch);
+      } else if (mToken.mIdent.LowerCaseEqualsLiteral("dppx")) {
+        expr->mValue.SetFloatValue(mToken.mNumber, eCSSUnit_Pixel);
       } else if (mToken.mIdent.LowerCaseEqualsLiteral("dpcm")) {
         expr->mValue.SetFloatValue(mToken.mNumber, eCSSUnit_Centimeter);
       } else {
         rv = false;
       }
       break;
     case nsMediaFeature::eEnumerated:
       rv = ParseVariant(expr->mValue, VARIANT_KEYWORD,
diff --git a/layout/style/nsCSSStyleSheet.cpp b/layout/style/nsCSSStyleSheet.cpp
--- a/layout/style/nsCSSStyleSheet.cpp
+++ b/layout/style/nsCSSStyleSheet.cpp
@@ -245,27 +245,35 @@ nsMediaExpression::Matches(nsPresContext
                 requiredNum = required.GetArrayValue()->Item(0).GetIntValue(),
                 requiredDen = required.GetArrayValue()->Item(1).GetIntValue();
         cmp = DoCompare(actualNum * requiredDen, requiredNum * actualDen);
       }
       break;
     case nsMediaFeature::eResolution:
       {
         NS_ASSERTION(actual.GetUnit() == eCSSUnit_Inch ||
+                     actual.GetUnit() == eCSSUnit_Pixel ||
                      actual.GetUnit() == eCSSUnit_Centimeter,
                      "bad actual value");
         NS_ASSERTION(required.GetUnit() == eCSSUnit_Inch ||
+                     required.GetUnit() == eCSSUnit_Pixel ||
                      required.GetUnit() == eCSSUnit_Centimeter,
                      "bad required value");
         float actualDPI = actual.GetFloatValue();
-        if (actual.GetUnit() == eCSSUnit_Centimeter)
+        if (actual.GetUnit() == eCSSUnit_Centimeter) {
           actualDPI = actualDPI * 2.54f;
+        } else if (actual.GetUnit() == eCSSUnit_Pixel) {
+          actualDPI = actualDPI * 96.0f;
+        }
         float requiredDPI = required.GetFloatValue();
-        if (required.GetUnit() == eCSSUnit_Centimeter)
+        if (required.GetUnit() == eCSSUnit_Centimeter) {
           requiredDPI = requiredDPI * 2.54f;
+        } else if (required.GetUnit() == eCSSUnit_Pixel) {
+          requiredDPI = requiredDPI * 96.0f;
+        }
         cmp = DoCompare(actualDPI, requiredDPI);
       }
       break;
     case nsMediaFeature::eEnumerated:
       {
         NS_ASSERTION(actual.GetUnit() == eCSSUnit_Enumerated,
                      "bad actual value");
         NS_ASSERTION(required.GetUnit() == eCSSUnit_Enumerated,
@@ -427,16 +435,18 @@ nsMediaQuery::AppendToString(nsAString& 
             array->Item(1).AppendToString(eCSSProperty_z_index, aString);
           }
           break;
         case nsMediaFeature::eResolution:
           {
             aString.AppendFloat(expr.mValue.GetFloatValue());
             if (expr.mValue.GetUnit() == eCSSUnit_Inch) {
               aString.AppendLiteral("dpi");
+            } else if (expr.mValue.GetUnit() == eCSSUnit_Pixel) {
+              aString.AppendLiteral("dppx");
             } else {
               NS_ASSERTION(expr.mValue.GetUnit() == eCSSUnit_Centimeter,
                            "bad unit");
               aString.AppendLiteral("dpcm");
             }
           }
           break;
         case nsMediaFeature::eEnumerated:
diff --git a/layout/style/nsMediaFeatures.h b/layout/style/nsMediaFeatures.h
--- a/layout/style/nsMediaFeatures.h
+++ b/layout/style/nsMediaFeatures.h
@@ -29,17 +29,18 @@ struct nsMediaFeature {
     enum ValueType {
         // All value types allow eCSSUnit_Null to indicate that no value
         // was given (in addition to the types listed below).
         eLength,     // values are such that nsCSSValue::IsLengthUnit() is true
         eInteger,    // values are eCSSUnit_Integer
         eFloat,      // values are eCSSUnit_Number
         eBoolInteger,// values are eCSSUnit_Integer (0, -0, or 1 only)
         eIntRatio,   // values are eCSSUnit_Array of two eCSSUnit_Integer
-        eResolution, // values are in eCSSUnit_Inch (for dpi) or
+        eResolution, // values are in eCSSUnit_Inch (for dpi),
+                     //   eCSSUnit_Pixel (for dppx), or
                      //   eCSSUnit_Centimeter (for dpcm)
         eEnumerated, // values are eCSSUnit_Enumerated (uses keyword table)
         eIdent       // values are eCSSUnit_Ident
         // Note that a number of pieces of code (both for parsing and
         // for matching of valueless expressions) assume that all numeric
         // value types cannot be negative.  The parsing code also does
         // not allow zeros in eIntRatio types.
     };
