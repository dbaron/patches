From: L. David Baron <dbaron@dbaron.org>

Bug 828312 patch 6:  Don't loop over continuations in DoApplyRenderingChangeToTree.  r=bzbarsky

The model for processing of style changes means that when a frame with
continuations has style changes, we process the style change for every
continuation.  While it may well be worth switching this to a different
model in which we only process the style change for the first
continuation and then apply it to all the continuations, that's not the
model we currently use, and we don't need to loop over continuations.

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -7637,17 +7637,18 @@ UpdateViewsForTree(nsIFrame* aFrame,
         // only do frames that don't have placeholders
         if (nsGkAtoms::placeholderFrame == child->GetType()) {
           // do the out-of-flow frame and its continuations
           nsIFrame* outOfFlowFrame =
             nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
           do {
             DoApplyRenderingChangeToTree(outOfFlowFrame, aFrameManager,
                                          aChange);
-          } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
+          } while ((outOfFlowFrame = nsLayoutUtils::
+                      GetNextContinuationOrSpecialSibling(outOfFlowFrame)));
         } else if (lists.CurrentID() == nsIFrame::kPopupList) {
           DoApplyRenderingChangeToTree(child, aFrameManager,
                                        aChange);
         } else {  // regular frame
           UpdateViewsForTree(child, aFrameManager, aChange);
         }
       }
     }
@@ -7698,106 +7699,104 @@ GetFrameForChildrenOnlyTransformHint(nsI
 static void
 DoApplyRenderingChangeToTree(nsIFrame* aFrame,
                              nsFrameManager* aFrameManager,
                              nsChangeHint aChange)
 {
   NS_PRECONDITION(gInApplyRenderingChangeToTree,
                   "should only be called within ApplyRenderingChangeToTree");
 
-  for ( ; aFrame; aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame)) {
-    // Get view if this frame has one and trigger an update. If the
-    // frame doesn't have a view, find the nearest containing view
-    // (adjusting r's coordinate system to reflect the nesting) and
-    // update there.
-    // We don't need to update transforms in UpdateViewsForTree, because
-    // there can't be any out-of-flows or popups that need to be transformed;
-    // all out-of-flow descendants of the transformed element must also be
-    // descendants of the transformed frame.
-    UpdateViewsForTree(aFrame, aFrameManager,
-                       nsChangeHint(aChange & (nsChangeHint_RepaintFrame |
-                                               nsChangeHint_SyncFrameView |
-                                               nsChangeHint_UpdateOpacityLayer)));
-    // This must be set to true if the rendering change needs to
-    // invalidate content.  If it's false, a composite-only paint
-    // (empty transaction) will be scheduled.
-    bool needInvalidatingPaint = false;
-
-    // if frame has view, will already be invalidated
-    if (aChange & nsChangeHint_RepaintFrame) {
-      if (aFrame->IsFrameOfType(nsIFrame::eSVG) &&
-          !(aFrame->GetStateBits() & NS_STATE_IS_OUTER_SVG)) {
-        if (aChange & nsChangeHint_UpdateEffects) {
-          needInvalidatingPaint = true;
-          nsSVGEffects::InvalidateRenderingObservers(aFrame);
-          // Need to update our overflow rects:
-          nsSVGUtils::ScheduleReflowSVG(aFrame);
-        } else {
-          needInvalidatingPaint = true;
-          // Just invalidate our area:
-          nsSVGEffects::InvalidateRenderingObservers(aFrame);
-          aFrame->InvalidateFrameSubtree();
-        }
+  // Get view if this frame has one and trigger an update. If the
+  // frame doesn't have a view, find the nearest containing view
+  // (adjusting r's coordinate system to reflect the nesting) and
+  // update there.
+  // We don't need to update transforms in UpdateViewsForTree, because
+  // there can't be any out-of-flows or popups that need to be transformed;
+  // all out-of-flow descendants of the transformed element must also be
+  // descendants of the transformed frame.
+  UpdateViewsForTree(aFrame, aFrameManager,
+                     nsChangeHint(aChange & (nsChangeHint_RepaintFrame |
+                                             nsChangeHint_SyncFrameView |
+                                             nsChangeHint_UpdateOpacityLayer)));
+  // This must be set to true if the rendering change needs to
+  // invalidate content.  If it's false, a composite-only paint
+  // (empty transaction) will be scheduled.
+  bool needInvalidatingPaint = false;
+
+  // if frame has view, will already be invalidated
+  if (aChange & nsChangeHint_RepaintFrame) {
+    if (aFrame->IsFrameOfType(nsIFrame::eSVG) &&
+        !(aFrame->GetStateBits() & NS_STATE_IS_OUTER_SVG)) {
+      if (aChange & nsChangeHint_UpdateEffects) {
+        needInvalidatingPaint = true;
+        nsSVGEffects::InvalidateRenderingObservers(aFrame);
+        // Need to update our overflow rects:
+        nsSVGUtils::ScheduleReflowSVG(aFrame);
       } else {
         needInvalidatingPaint = true;
+        // Just invalidate our area:
+        nsSVGEffects::InvalidateRenderingObservers(aFrame);
         aFrame->InvalidateFrameSubtree();
       }
-    }
-    if (aChange & nsChangeHint_UpdateTextPath) {
-      if (aFrame->GetType() == nsGkAtoms::svgTextPathFrame) {
-        // Invalidate and reflow the entire nsSVGTextFrame:
-        static_cast<nsSVGTextPathFrame*>(aFrame)->NotifyGlyphMetricsChange();
-      } else if (aFrame->IsSVGText()) {
-        // Invalidate and reflow the entire nsSVGTextFrame2:
-        NS_ASSERTION(aFrame->GetContent()->IsSVG(nsGkAtoms::textPath),
-                     "expected frame for a <textPath> element");
-        nsIFrame* text = nsLayoutUtils::GetClosestFrameOfType(
-                                                      aFrame,
-                                                      nsGkAtoms::svgTextFrame2);
-        NS_ASSERTION(text, "expected to find an ancestor nsSVGTextFrame2");
-        static_cast<nsSVGTextFrame2*>(text)->NotifyGlyphMetricsChange();
-      } else {
-        NS_ABORT_IF_FALSE(false, "unexpected frame got "
-                                 "nsChangeHint_UpdateTextPath");
-      }
-    }
-    if (aChange & nsChangeHint_UpdateOpacityLayer) {
-      // FIXME/bug 796697: we can get away with empty transactions for
-      // opacity updates in many cases.
+    } else {
       needInvalidatingPaint = true;
-      aFrame->MarkLayersActive(nsChangeHint_UpdateOpacityLayer);
-      if (nsSVGIntegrationUtils::UsingEffectsForFrame(aFrame)) {
-        // SVG effects paints the opacity without using
-        // nsDisplayOpacity. We need to invalidate manually.
-        aFrame->InvalidateFrameSubtree();
-      }
-    }
-    if ((aChange & nsChangeHint_UpdateTransformLayer) &&
-        aFrame->IsTransformed()) {
-      aFrame->MarkLayersActive(nsChangeHint_UpdateTransformLayer);
-      // If we're not already going to do an invalidating paint, see
-      // if we can get away with only updating the transform on a
-      // layer for this frame, and not scheduling an invalidating
-      // paint.
-      if (!needInvalidatingPaint) {
-        needInvalidatingPaint |= !aFrame->TryUpdateTransformOnly();
-      }
-    }
-    if (aChange & nsChangeHint_ChildrenOnlyTransform) {
-      needInvalidatingPaint = true;
-      nsIFrame* childFrame =
-        GetFrameForChildrenOnlyTransformHint(aFrame)->GetFirstPrincipalChild();
-      for ( ; childFrame; childFrame = childFrame->GetNextSibling()) {
-        childFrame->MarkLayersActive(nsChangeHint_UpdateTransformLayer);
-      }
-    }
-    aFrame->SchedulePaint(needInvalidatingPaint ?
-                          nsIFrame::PAINT_DEFAULT :
-                          nsIFrame::PAINT_COMPOSITE_ONLY);
-  }
+      aFrame->InvalidateFrameSubtree();
+    }
+  }
+  if (aChange & nsChangeHint_UpdateTextPath) {
+    if (aFrame->GetType() == nsGkAtoms::svgTextPathFrame) {
+      // Invalidate and reflow the entire nsSVGTextFrame:
+      static_cast<nsSVGTextPathFrame*>(aFrame)->NotifyGlyphMetricsChange();
+    } else if (aFrame->IsSVGText()) {
+      // Invalidate and reflow the entire nsSVGTextFrame2:
+      NS_ASSERTION(aFrame->GetContent()->IsSVG(nsGkAtoms::textPath),
+                   "expected frame for a <textPath> element");
+      nsIFrame* text = nsLayoutUtils::GetClosestFrameOfType(
+                                                    aFrame,
+                                                    nsGkAtoms::svgTextFrame2);
+      NS_ASSERTION(text, "expected to find an ancestor nsSVGTextFrame2");
+      static_cast<nsSVGTextFrame2*>(text)->NotifyGlyphMetricsChange();
+    } else {
+      NS_ABORT_IF_FALSE(false, "unexpected frame got "
+                               "nsChangeHint_UpdateTextPath");
+    }
+  }
+  if (aChange & nsChangeHint_UpdateOpacityLayer) {
+    // FIXME/bug 796697: we can get away with empty transactions for
+    // opacity updates in many cases.
+    needInvalidatingPaint = true;
+    aFrame->MarkLayersActive(nsChangeHint_UpdateOpacityLayer);
+    if (nsSVGIntegrationUtils::UsingEffectsForFrame(aFrame)) {
+      // SVG effects paints the opacity without using
+      // nsDisplayOpacity. We need to invalidate manually.
+      aFrame->InvalidateFrameSubtree();
+    }
+  }
+  if ((aChange & nsChangeHint_UpdateTransformLayer) &&
+      aFrame->IsTransformed()) {
+    aFrame->MarkLayersActive(nsChangeHint_UpdateTransformLayer);
+    // If we're not already going to do an invalidating paint, see
+    // if we can get away with only updating the transform on a
+    // layer for this frame, and not scheduling an invalidating
+    // paint.
+    if (!needInvalidatingPaint) {
+      needInvalidatingPaint |= !aFrame->TryUpdateTransformOnly();
+    }
+  }
+  if (aChange & nsChangeHint_ChildrenOnlyTransform) {
+    needInvalidatingPaint = true;
+    nsIFrame* childFrame =
+      GetFrameForChildrenOnlyTransformHint(aFrame)->GetFirstPrincipalChild();
+    for ( ; childFrame; childFrame = childFrame->GetNextSibling()) {
+      childFrame->MarkLayersActive(nsChangeHint_UpdateTransformLayer);
+    }
+  }
+  aFrame->SchedulePaint(needInvalidatingPaint ?
+                        nsIFrame::PAINT_DEFAULT :
+                        nsIFrame::PAINT_COMPOSITE_ONLY);
 }
 
 static void
 ApplyRenderingChangeToTree(nsPresContext* aPresContext,
                            nsIFrame* aFrame,
                            nsChangeHint aChange)
 {
   // We check StyleDisplay()->HasTransform() in addition to checking
