From: L. David Baron <dbaron@dbaron.org>

Don't shrink line heights in quirks mode when the line has a bullet.  (Bug 179596, etc.)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -2243,17 +2243,38 @@ nsBlockFrame::ReflowDirtyLines(nsBlockRe
   // Handle an odd-ball case: a list-item with no lines
   if (mBullet && HaveOutsideBullet() && mLines.empty()) {
     nsHTMLReflowMetrics metrics;
     ReflowBullet(aState, metrics,
                  aState.mReflowState.mComputedBorderPadding.top);
 
     // There are no lines so we have to fake up some y motion so that
     // we end up with *some* height.
-    aState.mY += metrics.height;
+
+    if (metrics.ascent == nsHTMLReflowMetrics::ASK_FOR_BASELINE &&
+        !nsLayoutUtils::GetFirstLineBaseline(mBullet, &metrics.ascent)) {
+      metrics.ascent = metrics.height;
+    }
+
+    nsIRenderingContext *rc = aState.mReflowState.rendContext;
+    nsLayoutUtils::SetFontFromStyle(rc, GetStyleContext());
+    nsCOMPtr<nsIFontMetrics> fm;
+    rc->GetFontMetrics(*getter_AddRefs(fm));
+
+    nscoord minAscent =
+      nsLayoutUtils::GetCenteredFontBaseline(fm, aState.mMinLineHeight);
+    nscoord minDescent = aState.mMinLineHeight - minAscent;
+
+    aState.mY += PR_MAX(minAscent, metrics.ascent) +
+                 PR_MAX(minDescent, metrics.height - metrics.ascent);
+
+    nscoord offset = minAscent - metrics.ascent;
+    if (offset > 0) {
+      mBullet->SetRect(mBullet->GetRect() + nsPoint(0, offset));
+    }
   }
 
   if (foundAnyClears) {
     AddStateBits(NS_BLOCK_HAS_CLEAR_CHILDREN);
   } else {
     RemoveStateBits(NS_BLOCK_HAS_CLEAR_CHILDREN);
   }
 
@@ -2717,16 +2738,19 @@ IsPaddingZero(nsStyleUnit aUnit, const n
 nsBlockFrame::IsSelfEmpty()
 {
   // Blocks which are margin-roots (including inline-blocks) cannot be treated
   // as empty for margin-collapsing and other purposes. They're more like
   // replaced elements.
   if (GetStateBits() & NS_BLOCK_MARGIN_ROOT)
     return PR_FALSE;
 
+  if (mBullet)
+    return PR_FALSE;
+
   const nsStylePosition* position = GetStylePosition();
 
   switch (position->mMinHeight.GetUnit()) {
     case eStyleUnit_Coord:
       if (position->mMinHeight.GetCoordValue() != 0)
         return PR_FALSE;
       break;
     case eStyleUnit_Percent:
diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -1323,16 +1323,18 @@ nsLineLayout::PlaceFrame(PerFrameData* p
 }
 
 nsresult
 nsLineLayout::AddBulletFrame(nsIFrame* aFrame,
                              const nsHTMLReflowMetrics& aMetrics)
 {
   NS_ASSERTION(mCurrentSpan == mRootSpan, "bad linelayout user");
 
+  SetFlag(LL_HASBULLET, PR_TRUE);
+
   PerFrameData* pfd;
   nsresult rv = NewPerFrameData(&pfd);
   if (NS_SUCCEEDED(rv)) {
     mRootSpan->AppendFrame(pfd);
     pfd->mFrame = aFrame;
     pfd->mMargin.SizeTo(0, 0, 0, 0);
     pfd->mBorderPadding.SizeTo(0, 0, 0, 0);
     pfd->mFlags = 0;  // all flags default to false
@@ -2003,53 +2005,38 @@ nsLineLayout::VerticalAlignFrames(PerSpa
   // the block.
   if (psd == mRootSpan) {
     // We should factor in the block element's minimum line-height (as
     // defined in section 10.8.1 of the css2 spec) assuming that
     // mZeroEffectiveSpanBox is not set on the root span.  This only happens
     // in some cases in quirks mode:
     //  (1) if the root span contains non-whitespace text directly (this
     //      is handled by mZeroEffectiveSpanBox
-    //  (2) if this is the first line of an LI element (whether or not
-    //      there is a bullet (NN4/IE5 quirk)
+    //  (2) if this line has a bullet
     //  (3) if this is the last line of an LI, DT, or DD element
     //      (The last line before a block also counts, but not before a
     //      BR) (NN4/IE5 quirk)
-    PRBool applyMinLH = !(psd->mZeroEffectiveSpanBox); // (1) above
-    PRBool isFirstLine = !mLineNumber; // if the line number is 0
+
+    // (1) and (2) above
+    PRBool applyMinLH = !psd->mZeroEffectiveSpanBox || GetFlag(LL_HASBULLET);
     PRBool isLastLine = (!mLineBox->IsLineWrapped() && !GetFlag(LL_LINEENDSINBR));
-    PRBool foundLI = PR_FALSE;  // hack to fix bug 50480.
-    //XXX: rather than remembering if we've found an LI, we really should be checking
-    //     for the existence of a bullet frame.  Likewise, the code below should not
-    //     be checking for any particular content tag type, but rather should
-    //     be checking for the existence of a bullet frame to determine if it's a list element or not.
-    if (!applyMinLH && (isFirstLine || isLastLine)) {
+    if (!applyMinLH && isLastLine) {
       nsIContent* blockContent = mRootSpan->mFrame->mFrame->GetContent();
       if (blockContent) {
         nsIAtom *blockTagAtom = blockContent->Tag();
-        // (2) above, if the first line of LI
-        if (isFirstLine && blockTagAtom == nsGkAtoms::li) {
-          // if the line is empty, then don't force the min height
-          // (see bug 75963)
-          if (!IsZeroHeight()) {
-            applyMinLH = PR_TRUE;
-            foundLI = PR_TRUE;
-          }
-        }
         // (3) above, if the last line of LI, DT, or DD
-        else if (!applyMinLH && isLastLine &&
-                 ((blockTagAtom == nsGkAtoms::li) ||
-                  (blockTagAtom == nsGkAtoms::dt) ||
-                  (blockTagAtom == nsGkAtoms::dd))) {
+        if (blockTagAtom == nsGkAtoms::li ||
+            blockTagAtom == nsGkAtoms::dt ||
+            blockTagAtom == nsGkAtoms::dd) {
           applyMinLH = PR_TRUE;
         }
       }
     }
     if (applyMinLH) {
-      if (psd->mHasNonemptyContent || preMode || foundLI) {
+      if (psd->mHasNonemptyContent || preMode || GetFlag(LL_HASBULLET)) {
 #ifdef NOISY_VERTICAL_ALIGN
         printf("  [span]==> adjusting min/maxY: currentValues: %d,%d", minY, maxY);
 #endif
         nscoord minimumLineHeight = mMinLineHeight;
         nscoord yTop =
           -nsLayoutUtils::GetCenteredFontBaseline(fm, minimumLineHeight);
         nscoord yBottom = yTop + minimumLineHeight;
 
diff --git a/layout/generic/nsLineLayout.h b/layout/generic/nsLineLayout.h
--- a/layout/generic/nsLineLayout.h
+++ b/layout/generic/nsLineLayout.h
@@ -150,17 +150,18 @@ protected:
 #define LL_IMPACTEDBYFLOATS            0x00000040
 #define LL_LASTFLOATWASLETTERFRAME     0x00000080
 #define LL_LINEISEMPTY                 0x00000100
 #define LL_LINEENDSINBR                0x00000200
 #define LL_NEEDBACKUP                  0x00000400
 #define LL_INFIRSTLINE                 0x00000800
 #define LL_GOTLINEBOX                  0x00001000
 #define LL_INFIRSTLETTER               0x00002000
-#define LL_LASTFLAG                    LL_INFIRSTLETTER
+#define LL_HASBULLET                   0x00004000
+#define LL_LASTFLAG                    LL_HASBULLET
 
   void SetFlag(PRUint32 aFlag, PRBool aValue)
   {
     NS_ASSERTION(aFlag<=LL_LASTFLAG, "bad flag");
     NS_ASSERTION(aValue==PR_FALSE || aValue==PR_TRUE, "bad value");
     if (aValue) { // set flag
       mFlags |= aFlag;
     }
