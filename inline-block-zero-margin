From: L. David Baron <dbaron@dbaron.org>

Bug 709014 patch 1:  Honor margin-left and margin-right on elements in inline layout that have 0 width and/or height (commonly, inline-blocks).

Prior to this patch, we failed to honor:
 * margin-left on elements in inline layout with 0 width and 0 height
 * margin-right on elements in inline layout with 0 width
I think that was because the code in CanPlaceFrame to discard both
margins when the width was 0 was running after the left-margin was
applied, unless the later code in PlaceFrame (checking both width 0 and
height 0) un-applied that left margin.

diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -1128,57 +1128,50 @@ nsLineLayout::CanPlaceFrame(PerFrameData
                             bool aCanRollBackBeforeFrame,
                             nsHTMLReflowMetrics& aMetrics,
                             nsReflowStatus& aStatus,
                             bool* aOptionalBreakAfterFits)
 {
   NS_PRECONDITION(pfd && pfd->mFrame, "bad args, null pointers for frame data");
   
   *aOptionalBreakAfterFits = true;
-  // Compute right margin to use
-  if (0 != pfd->mBounds.width) {
-    // XXXwaterson this is probably not exactly right; e.g., embeddings, etc.
-    bool ltr = (NS_STYLE_DIRECTION_LTR == aFrameDirection);
 
-    /*
-     * We want to only apply the end margin if we're the last continuation and
-     * either not in an {ib} split or the last inline in it.  In all other
-     * cases we want to zero it out.  That means zeroing it out if any of these
-     * conditions hold:
-     * 1) The frame is not complete (in this case it will get a next-in-flow)
-     * 2) The frame is complete but has a non-fluid continuation on its
-     *    continuation chain.  Note that if it has a fluid continuation, that
-     *    continuation will get destroyed later, so we don't want to drop the
-     *    end-margin in that case.
-     * 3) The frame is in an {ib} split and is not the last part.
-     *
-     * However, none of that applies if this is a letter frame (XXXbz why?)
-     */
-    if ((NS_FRAME_IS_NOT_COMPLETE(aStatus) ||
-         pfd->mFrame->LastInFlow()->GetNextContinuation() ||
-         pfd->mFrame->FrameIsNonLastInIBSplit())
-        && !pfd->GetFlag(PFD_ISLETTERFRAME)) {
-      if (ltr)
-        pfd->mMargin.right = 0;
-      else
-        pfd->mMargin.left = 0;
-    }
-  }
-  else {
-    // Don't apply margin to empty frames.
-    pfd->mMargin.left = pfd->mMargin.right = 0;
+  // XXXwaterson this is probably not exactly right; e.g., embeddings, etc.
+  bool ltr = NS_STYLE_DIRECTION_LTR == aFrameDirection;
+
+  /*
+   * We want to only apply the end margin if we're the last continuation and
+   * either not in an {ib} split or the last inline in it.  In all other
+   * cases we want to zero it out.  That means zeroing it out if any of these
+   * conditions hold:
+   * 1) The frame is not complete (in this case it will get a next-in-flow)
+   * 2) The frame is complete but has a non-fluid continuation on its
+   *    continuation chain.  Note that if it has a fluid continuation, that
+   *    continuation will get destroyed later, so we don't want to drop the
+   *    end-margin in that case.
+   * 3) The frame is in an {ib} split and is not the last part.
+   *
+   * However, none of that applies if this is a letter frame (XXXbz why?)
+   */
+  if ((NS_FRAME_IS_NOT_COMPLETE(aStatus) ||
+       pfd->mFrame->LastInFlow()->GetNextContinuation() ||
+       pfd->mFrame->FrameIsNonLastInIBSplit())
+      && !pfd->GetFlag(PFD_ISLETTERFRAME)) {
+    if (ltr)
+      pfd->mMargin.right = 0;
+    else
+      pfd->mMargin.left = 0;
   }
 
   PerSpanData* psd = mCurrentSpan;
   if (psd->mNoWrap) {
     // When wrapping is off, everything fits.
     return true;
   }
 
-  bool ltr = NS_STYLE_DIRECTION_LTR == aFrameDirection;
   nscoord endMargin = ltr ? pfd->mMargin.right : pfd->mMargin.left;
 
 #ifdef NOISY_CAN_PLACE_FRAME
   if (nullptr != psd->mFrame) {
     nsFrame::ListTag(stdout, psd->mFrame->mFrame);
   }
   else {
     nsFrame::ListTag(stdout, mBlockReflowState->frame);
@@ -1285,37 +1278,33 @@ nsLineLayout::CanPlaceFrame(PerFrameData
 }
 
 /**
  * Place the frame. Update running counters.
  */
 void
 nsLineLayout::PlaceFrame(PerFrameData* pfd, nsHTMLReflowMetrics& aMetrics)
 {
-  // If frame is zero width then do not apply its left and right margins.
-  PerSpanData* psd = mCurrentSpan;
-  bool emptyFrame = false;
-  if ((0 == pfd->mBounds.width) && (0 == pfd->mBounds.height)) {
-    pfd->mBounds.x = psd->mX;
-    pfd->mBounds.y = mTopEdge;
-    emptyFrame = true;
-  }
-
   // Record ascent and update max-ascent and max-descent values
   if (aMetrics.TopAscent() == nsHTMLReflowMetrics::ASK_FOR_BASELINE)
     pfd->mAscent = pfd->mFrame->GetBaseline();
   else
     pfd->mAscent = aMetrics.TopAscent();
 
   bool ltr = (NS_STYLE_DIRECTION_LTR == pfd->mFrame->StyleVisibility()->mDirection);
   // Advance to next X coordinate
-  psd->mX = pfd->mBounds.XMost() + (ltr ? pfd->mMargin.right : pfd->mMargin.left);
+  mCurrentSpan->mX = pfd->mBounds.XMost() +
+                     (ltr ? pfd->mMargin.right : pfd->mMargin.left);
 
-  // Count the number of non-empty frames on the line...
-  if (!emptyFrame) {
+  // Count the number of non-placeholder frames on the line...
+  if (pfd->mFrame->GetType() == nsGkAtoms::placeholderFrame) {
+    NS_ASSERTION(pfd->mBounds.width == 0 && pfd->mBounds.height == 0,
+                 "placeholders should have 0 width/height (checking "
+                 "equivalence with old code in this function)");
+  } else {
     mTotalPlacedFrames++;
   }
 }
 
 void
 nsLineLayout::AddBulletFrame(nsIFrame* aFrame,
                              const nsHTMLReflowMetrics& aMetrics)
 {
diff --git a/layout/reftests/inline/inline-block-width.html b/layout/reftests/inline/inline-block-width.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/inline/inline-block-width.html
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<title>margin-left on zero-sized inline-block</title>
+<style>
+span { display: inline-block; height: 0; width: 100px }
+</style>
+hello <span></span>world</span>
diff --git a/layout/reftests/inline/inline-block-zero.html b/layout/reftests/inline/inline-block-zero.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/inline/inline-block-zero.html
@@ -0,0 +1,3 @@
+<!DOCTYPE HTML>
+<title>margin-left on zero-sized inline-block</title>
+hello world
diff --git a/layout/reftests/inline/reftest.list b/layout/reftests/inline/reftest.list
new file mode 100644
--- /dev/null
+++ b/layout/reftests/inline/reftest.list
@@ -0,0 +1,5 @@
+== zero-inline-block-margin-left.html zero-inline-block-margin-ref.html
+== zero-inline-block-margin-right.html zero-inline-block-margin-ref.html
+== zero-inline-block-margin-ref.html zero-inline-block-margin-ref2.html
+== inline-block-width.html zero-inline-block-margin-ref.html
+!= inline-block-width.html inline-block-zero.html
diff --git a/layout/reftests/inline/zero-inline-block-margin-left.html b/layout/reftests/inline/zero-inline-block-margin-left.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/inline/zero-inline-block-margin-left.html
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<title>margin-left on zero-sized inline-block</title>
+<style>
+span { display: inline-block; height: 0; width: 0; margin-left: 100px }
+</style>
+hello <span></span>world
diff --git a/layout/reftests/inline/zero-inline-block-margin-ref.html b/layout/reftests/inline/zero-inline-block-margin-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/inline/zero-inline-block-margin-ref.html
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<title>margin-left on zero-sized inline-block</title>
+<style>
+span { margin-left: 100px }
+</style>
+hello <span>world</span>
diff --git a/layout/reftests/inline/zero-inline-block-margin-ref2.html b/layout/reftests/inline/zero-inline-block-margin-ref2.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/inline/zero-inline-block-margin-ref2.html
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<title>margin-left on zero-sized inline-block</title>
+<style>
+span { margin-right: 100px }
+</style>
+<span>hello</span> world
diff --git a/layout/reftests/inline/zero-inline-block-margin-right.html b/layout/reftests/inline/zero-inline-block-margin-right.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/inline/zero-inline-block-margin-right.html
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<title>margin-left on zero-sized inline-block</title>
+<style>
+span { display: inline-block; height: 0; width: 0; margin-right: 100px }
+</style>
+hello <span></span>world
diff --git a/layout/reftests/reftest.list b/layout/reftests/reftest.list
--- a/layout/reftests/reftest.list
+++ b/layout/reftests/reftest.list
@@ -187,16 +187,19 @@ skip-if(B2G) include image-element/refte
 skip-if(B2G) include image-rect/reftest.list
 
 # image-region/
 skip-if(B2G) include image-region/reftest.list
 
 # indic shaping with harfbuzz
 skip-if(B2G) include indic-shaping/reftest.list
 
+# inline layout
+include inline/reftest.list
+
 # inline borders and padding
 skip-if(B2G) include inline-borderpadding/reftest.list
 
 # layers/
 include layers/reftest.list
 
 # line-breaking/
 skip-if(B2G) include line-breaking/reftest.list
