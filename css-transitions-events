From: L. David Baron <dbaron@dbaron.org>

Implement events part of CSS transitions: add support for the transitionend DOM event.  (Bug 531585)  r=smaug

diff --git a/content/base/src/nsContentUtils.cpp b/content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp
+++ b/content/base/src/nsContentUtils.cpp
@@ -500,16 +500,18 @@ nsContentUtils::InitializeEventTable() {
     { &nsGkAtoms::onMozMagnifyGestureStart,      { NS_SIMPLE_GESTURE_MAGNIFY_START, EventNameType_None } },
     { &nsGkAtoms::onMozMagnifyGestureUpdate,     { NS_SIMPLE_GESTURE_MAGNIFY_UPDATE, EventNameType_None } },
     { &nsGkAtoms::onMozMagnifyGesture,           { NS_SIMPLE_GESTURE_MAGNIFY, EventNameType_None } },
     { &nsGkAtoms::onMozRotateGestureStart,       { NS_SIMPLE_GESTURE_ROTATE_START, EventNameType_None } },
     { &nsGkAtoms::onMozRotateGestureUpdate,      { NS_SIMPLE_GESTURE_ROTATE_UPDATE, EventNameType_None } },
     { &nsGkAtoms::onMozRotateGesture,            { NS_SIMPLE_GESTURE_ROTATE, EventNameType_None } },
     { &nsGkAtoms::onMozTapGesture,               { NS_SIMPLE_GESTURE_TAP, EventNameType_None } },
     { &nsGkAtoms::onMozPressTapGesture,          { NS_SIMPLE_GESTURE_PRESSTAP, EventNameType_None } },
+
+    { &nsGkAtoms::ontransitionend,               { NS_TRANSITION_END, EventNameType_None }},
   };
 
   sEventTable = new nsDataHashtable<nsISupportsHashKey, EventNameMapping>;
   if (!sEventTable ||
       !sEventTable->Init(int(NS_ARRAY_LENGTH(eventArray) / 0.75) + 1)) {
     delete sEventTable;
     sEventTable = nsnull;
     return PR_FALSE;
diff --git a/content/base/src/nsGkAtomList.h b/content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h
+++ b/content/base/src/nsGkAtomList.h
@@ -673,16 +673,17 @@ GK_ATOM(onpopupshown, "onpopupshown")
 GK_ATOM(onRequest, "onRequest")
 GK_ATOM(onreset, "onreset")
 GK_ATOM(onresize, "onresize")
 GK_ATOM(onscroll, "onscroll")
 GK_ATOM(onselect, "onselect")
 GK_ATOM(onset, "onset")
 GK_ATOM(onsubmit, "onsubmit")
 GK_ATOM(ontext, "ontext")
+GK_ATOM(ontransitionend, "ontransitionend")
 GK_ATOM(onunderflow, "onunderflow")
 GK_ATOM(onunload, "onunload")
 GK_ATOM(open, "open")
 GK_ATOM(optgroup, "optgroup")
 GK_ATOM(option, "option")
 GK_ATOM(_or, "or")
 GK_ATOM(order, "order")
 GK_ATOM(ordinal, "ordinal")
diff --git a/content/events/public/nsIPrivateDOMEvent.h b/content/events/public/nsIPrivateDOMEvent.h
--- a/content/events/public/nsIPrivateDOMEvent.h
+++ b/content/events/public/nsIPrivateDOMEvent.h
@@ -110,9 +110,11 @@ nsresult
 NS_NewDOMNotifyPaintEvent(nsIDOMEvent** aResult, nsPresContext* aPresContext,
                           nsEvent* aEvent,
                           PRUint32 aEventType = 0,
                           nsInvalidateRequestList* aInvalidateRequests = nsnull);
 nsresult
 NS_NewDOMSimpleGestureEvent(nsIDOMEvent** aInstancePtrResult, nsPresContext* aPresContext, class nsSimpleGestureEvent* aEvent);
 nsresult
 NS_NewDOMScrollAreaEvent(nsIDOMEvent** aInstancePtrResult, nsPresContext* aPresContext, class nsScrollAreaEvent* aEvent);
+nsresult
+NS_NewDOMTransitionEvent(nsIDOMEvent** aInstancePtrResult, nsPresContext* aPresContext, class nsTransitionEvent* aEvent);
 #endif // nsIPrivateDOMEvent_h__
diff --git a/content/events/src/Makefile.in b/content/events/src/Makefile.in
--- a/content/events/src/Makefile.in
+++ b/content/events/src/Makefile.in
@@ -76,16 +76,17 @@ CPPSRCS		= \
 		nsContentEventHandler.cpp \
 		nsEventListenerService.cpp \
 		nsDOMProgressEvent.cpp \
 		nsDOMDataTransfer.cpp \
 		nsDOMNotifyPaintEvent.cpp \
 		nsDOMSimpleGestureEvent.cpp \
 		nsDOMEventTargetHelper.cpp \
 		nsDOMScrollAreaEvent.cpp \
+		nsDOMTransitionEvent.cpp \
 		$(NULL)
 
 # we don't want the shared lib, but we want to force the creation of a static lib.
 FORCE_STATIC_LIB = 1
 
 include $(topsrcdir)/config/rules.mk
 
 LOCAL_INCLUDES	= \
diff --git a/content/events/src/nsDOMEvent.cpp b/content/events/src/nsDOMEvent.cpp
--- a/content/events/src/nsDOMEvent.cpp
+++ b/content/events/src/nsDOMEvent.cpp
@@ -87,17 +87,18 @@ static const char* const sEventNames[] =
   "MozMagnifyGestureStart",
   "MozMagnifyGestureUpdate",
   "MozMagnifyGesture",
   "MozRotateGestureStart",
   "MozRotateGestureUpdate",
   "MozRotateGesture",
   "MozTapGesture",
   "MozPressTapGesture",
-  "MozScrolledAreaChanged"
+  "MozScrolledAreaChanged",
+  "transitionend"
 };
 
 static char *sPopupAllowedEvents;
 
 
 nsDOMEvent::nsDOMEvent(nsPresContext* aPresContext, nsEvent* aEvent)
 {
   mPresContext = aPresContext;
@@ -700,16 +701,20 @@ nsDOMEvent::SetEventType(const nsAString
       mEvent->message = NS_SIMPLE_GESTURE_ROTATE_UPDATE;
     else if (atom == nsGkAtoms::onMozRotateGesture)
       mEvent->message = NS_SIMPLE_GESTURE_ROTATE;
     else if (atom == nsGkAtoms::onMozPressTapGesture)
       mEvent->message = NS_SIMPLE_GESTURE_PRESSTAP;
     else if (atom == nsGkAtoms::onMozTapGesture)
       mEvent->message = NS_SIMPLE_GESTURE_TAP;
   }
+  else if (mEvent->eventStructType == NS_TRANSITION_EVENT) {
+    if (atom == nsGkAtoms::ontransitionend)
+      mEvent->message = NS_TRANSITION_END;
+  }
 
   if (mEvent->message == NS_USER_DEFINED_EVENT)
     mEvent->userType = atom;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -1002,16 +1007,26 @@ NS_METHOD nsDOMEvent::DuplicatePrivateDa
         new nsSimpleGestureEvent(PR_FALSE, msg, nsnull, 0, 0.0);
       NS_ENSURE_TRUE(simpleGestureEvent, NS_ERROR_OUT_OF_MEMORY);
       isInputEvent = PR_TRUE;
       simpleGestureEvent->direction = oldSimpleGestureEvent->direction;
       simpleGestureEvent->delta = oldSimpleGestureEvent->delta;
       newEvent = simpleGestureEvent;
       break;
     }
+    case NS_TRANSITION_EVENT:
+    {
+      nsTransitionEvent* oldTransitionEvent =
+        static_cast<nsTransitionEvent*>(mEvent);
+      newEvent = new nsTransitionEvent(PR_FALSE, msg,
+                                       oldTransitionEvent->propertyName,
+                                       oldTransitionEvent->elapsedTime);
+      NS_ENSURE_TRUE(newEvent, NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
     default:
     {
       NS_WARNING("Unknown event type!!!");
       return NS_ERROR_FAILURE;
     }
   }
 
   NS_ENSURE_TRUE(newEvent, NS_ERROR_OUT_OF_MEMORY);
@@ -1490,16 +1505,18 @@ const char* nsDOMEvent::GetEventName(PRU
   case NS_SIMPLE_GESTURE_ROTATE:
     return sEventNames[eDOMEvents_MozRotateGesture];
   case NS_SIMPLE_GESTURE_TAP:
     return sEventNames[eDOMEvents_MozTapGesture];
   case NS_SIMPLE_GESTURE_PRESSTAP:
     return sEventNames[eDOMEvents_MozPressTapGesture];
   case NS_SCROLLEDAREACHANGED:
     return sEventNames[eDOMEvents_MozScrolledAreaChanged];
+  case NS_TRANSITION_END:
+    return sEventNames[eDOMEvents_transitionend];
   default:
     break;
   }
   // XXXldb We can hit this case for nsEvent objects that we didn't
   // create and that are not user defined events since this function and
   // SetEventType are incomplete.  (But fixing that requires fixing the
   // arrays in nsEventListenerManager too, since the events for which
   // this is a problem generally *are* created by nsDOMEvent.)
diff --git a/content/events/src/nsDOMEvent.h b/content/events/src/nsDOMEvent.h
--- a/content/events/src/nsDOMEvent.h
+++ b/content/events/src/nsDOMEvent.h
@@ -166,17 +166,18 @@ public:
     eDOMEvents_MozMagnifyGestureStart,
     eDOMEvents_MozMagnifyGestureUpdate,
     eDOMEvents_MozMagnifyGesture,
     eDOMEvents_MozRotateGestureStart,
     eDOMEvents_MozRotateGestureUpdate,
     eDOMEvents_MozRotateGesture,
     eDOMEvents_MozTapGesture,
     eDOMEvents_MozPressTapGesture,
-    eDOMEvents_MozScrolledAreaChanged
+    eDOMEvents_MozScrolledAreaChanged,
+    eDOMEvents_transitionend
   };
 
   nsDOMEvent(nsPresContext* aPresContext, nsEvent* aEvent);
   virtual ~nsDOMEvent();
 
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsDOMEvent, nsIDOMEvent)
 
diff --git a/content/events/src/nsDOMTransitionEvent.cpp b/content/events/src/nsDOMTransitionEvent.cpp
new file mode 100644
--- /dev/null
+++ b/content/events/src/nsDOMTransitionEvent.cpp
@@ -0,0 +1,114 @@
+/* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsDOMTransitionEvent.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsDOMTransitionEvent.h"
+#include "nsGUIEvent.h"
+
+nsDOMTransitionEvent::nsDOMTransitionEvent(nsPresContext *aPresContext,
+                                           nsTransitionEvent *aEvent)
+  : nsDOMEvent(aPresContext, aEvent ? aEvent
+                                    : new nsTransitionEvent(PR_FALSE, 0,
+                                                            EmptyString(),
+                                                            0.0))
+{
+  if (aEvent) {
+    mEventIsInternal = PR_FALSE;
+  }
+  else {
+    mEventIsInternal = PR_TRUE;
+    mEvent->time = PR_Now();
+  }
+}
+
+nsDOMTransitionEvent::~nsDOMTransitionEvent()
+{
+  if (mEventIsInternal) {
+    delete TransitionEvent();
+    mEvent = nsnull;
+  }
+}
+
+NS_INTERFACE_MAP_BEGIN(nsDOMTransitionEvent)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMTransitionEvent)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(TransitionEvent)
+NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)
+
+NS_IMPL_ADDREF_INHERITED(nsDOMTransitionEvent, nsDOMEvent)
+NS_IMPL_RELEASE_INHERITED(nsDOMTransitionEvent, nsDOMEvent)
+
+NS_IMETHODIMP
+nsDOMTransitionEvent::GetPropertyName(nsAString & aPropertyName)
+{
+  aPropertyName = TransitionEvent()->propertyName;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsDOMTransitionEvent::GetElapsedTime(float *aElapsedTime)
+{
+  *aElapsedTime = TransitionEvent()->elapsedTime;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsDOMTransitionEvent::InitTransitionEvent(const nsAString & typeArg,
+                                          PRBool canBubbleArg,
+                                          PRBool cancelableArg,
+                                          const nsAString & propertyNameArg,
+                                          float elapsedTimeArg)
+{
+  nsresult rv = nsDOMEvent::InitEvent(typeArg, canBubbleArg, cancelableArg);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  TransitionEvent()->propertyName = propertyNameArg;
+  TransitionEvent()->elapsedTime = elapsedTimeArg;
+
+  return NS_OK;
+}
+
+nsresult
+NS_NewDOMTransitionEvent(nsIDOMEvent **aInstancePtrResult,
+                         nsPresContext *aPresContext,
+                         nsTransitionEvent *aEvent)
+{
+  nsDOMTransitionEvent *it = new nsDOMTransitionEvent(aPresContext, aEvent);
+  if (!it) {
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  return CallQueryInterface(it, aInstancePtrResult);
+}
diff --git a/content/events/src/nsDOMTransitionEvent.h b/content/events/src/nsDOMTransitionEvent.h
new file mode 100644
--- /dev/null
+++ b/content/events/src/nsDOMTransitionEvent.h
@@ -0,0 +1,66 @@
+/* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsDOMTransitionEvent.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsDOMTransitionEvent_h_
+#define nsDOMTransitionEvent_h_
+
+#include "nsDOMEvent.h"
+#include "nsIDOMTransitionEvent.h"
+#include "nsString.h"
+
+class nsTransitionEvent;
+
+class nsDOMTransitionEvent : public nsDOMEvent,
+                             public nsIDOMTransitionEvent
+{
+public:
+  nsDOMTransitionEvent(nsPresContext *aPresContext,
+                       nsTransitionEvent *aEvent);
+  ~nsDOMTransitionEvent();
+
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_FORWARD_TO_NSDOMEVENT
+  NS_DECL_NSIDOMTRANSITIONEVENT
+
+private:
+  nsTransitionEvent* TransitionEvent() {
+    NS_ABORT_IF_FALSE(mEvent->eventStructType == NS_TRANSITION_EVENT,
+                      "unexpected struct type");
+    return static_cast<nsTransitionEvent*>(mEvent);
+  }
+};
+
+#endif /* !defined(nsDOMTransitionEvent_h_) */
diff --git a/content/events/src/nsEventDispatcher.cpp b/content/events/src/nsEventDispatcher.cpp
--- a/content/events/src/nsEventDispatcher.cpp
+++ b/content/events/src/nsEventDispatcher.cpp
@@ -716,16 +716,19 @@ nsEventDispatcher::CreateEvent(nsPresCon
 #endif // MOZ_SVG
 
     case NS_COMMAND_EVENT:
       return NS_NewDOMCommandEvent(aDOMEvent, aPresContext,
                                    static_cast<nsCommandEvent*>(aEvent));
     case NS_SIMPLE_GESTURE_EVENT:
       return NS_NewDOMSimpleGestureEvent(aDOMEvent, aPresContext,
                                          static_cast<nsSimpleGestureEvent*>(aEvent));
+    case NS_TRANSITION_EVENT:
+      return NS_NewDOMTransitionEvent(aDOMEvent, aPresContext,
+                                      static_cast<nsTransitionEvent*>(aEvent));
     }
 
     // For all other types of events, create a vanilla event object.
     return NS_NewDOMEvent(aDOMEvent, aPresContext, aEvent);
   }
 
   // And if we didn't get an event, check the type argument.
 
@@ -784,11 +787,15 @@ nsEventDispatcher::CreateEvent(nsPresCon
   if (aEventType.LowerCaseEqualsLiteral("simplegestureevent"))
     return NS_NewDOMSimpleGestureEvent(aDOMEvent, aPresContext, nsnull);
   if (aEventType.LowerCaseEqualsLiteral("beforeunloadevent"))
     return NS_NewDOMBeforeUnloadEvent(aDOMEvent, aPresContext, nsnull);
   if (aEventType.LowerCaseEqualsLiteral("pagetransition"))
     return NS_NewDOMPageTransitionEvent(aDOMEvent, aPresContext, nsnull);
   if (aEventType.LowerCaseEqualsLiteral("scrollareaevent"))
     return NS_NewDOMScrollAreaEvent(aDOMEvent, aPresContext, nsnull);
+  // FIXME: Should get spec to say what the right string is here!  This
+  // is probably wrong!
+  if (aEventType.LowerCaseEqualsLiteral("transitionevent"))
+    return NS_NewDOMTransitionEvent(aDOMEvent, aPresContext, nsnull);
 
   return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
 }
diff --git a/dom/base/nsDOMClassInfo.cpp b/dom/base/nsDOMClassInfo.cpp
--- a/dom/base/nsDOMClassInfo.cpp
+++ b/dom/base/nsDOMClassInfo.cpp
@@ -229,16 +229,17 @@
 #include "nsIDOMMutationEvent.h"
 #include "nsIDOMSmartCardEvent.h"
 #include "nsIDOMXULCommandEvent.h"
 #include "nsIDOMPageTransitionEvent.h"
 #include "nsIDOMMessageEvent.h"
 #include "nsPaintRequest.h"
 #include "nsIDOMNotifyPaintEvent.h"
 #include "nsIDOMScrollAreaEvent.h"
+#include "nsIDOMTransitionEvent.h"
 #include "nsIDOMNSDocumentStyle.h"
 #include "nsIDOMDocumentRange.h"
 #include "nsIDOMDocumentTraversal.h"
 #include "nsIDOMDocumentXBL.h"
 #include "nsIDOMDocumentView.h"
 #include "nsIDOMElementCSSInlineStyle.h"
 #include "nsIDOMLinkStyle.h"
 #include "nsIDOMHTMLDocument.h"
@@ -1361,16 +1362,18 @@ static nsDOMClassInfoData sClassInfoData
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(PaintRequestList, nsPaintRequestListSH,
                            ARRAY_SCRIPTABLE_FLAGS)
 
   NS_DEFINE_CLASSINFO_DATA(ScrollAreaEvent, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(EventListenerInfo, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(TransitionEvent, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
 };
 
 // Objects that shuld be constructable through |new Name();|
 struct nsContractIDMapData
 {
   PRInt32 mDOMClassInfoID;
   const char *mContractID;
 };
@@ -3782,16 +3785,21 @@ nsDOMClassInfo::Init()
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMScrollAreaEvent)
     DOM_CLASSINFO_UI_EVENT_MAP_ENTRIES
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(EventListenerInfo, nsIEventListenerInfo)
     DOM_CLASSINFO_MAP_ENTRY(nsIEventListenerInfo)
   DOM_CLASSINFO_MAP_END
 
+  DOM_CLASSINFO_MAP_BEGIN(TransitionEvent, nsIDOMTransitionEvent)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMTransitionEvent)
+    DOM_CLASSINFO_EVENT_MAP_ENTRIES
+  DOM_CLASSINFO_MAP_END
+
 #ifdef NS_DEBUG
   {
     PRUint32 i = NS_ARRAY_LENGTH(sClassInfoData);
 
     if (i != eDOMClassInfoIDCount) {
       NS_ERROR("The number of items in sClassInfoData doesn't match the "
                "number of nsIDOMClassInfo ID's, this is bad! Fix it!");
 
diff --git a/dom/base/nsDOMClassInfoID.h b/dom/base/nsDOMClassInfoID.h
--- a/dom/base/nsDOMClassInfoID.h
+++ b/dom/base/nsDOMClassInfoID.h
@@ -484,16 +484,18 @@ enum nsDOMClassInfoID {
 
   eDOMClassInfo_PaintRequest_id,
   eDOMClassInfo_PaintRequestList_id,
 
   eDOMClassInfo_ScrollAreaEvent_id,
 
   eDOMClassInfo_EventListenerInfo_id,
 
+  eDOMClassInfo_TransitionEvent_id,
+
   // This one better be the last one in this list
   eDOMClassInfoIDCount
 };
 
 /**
  * nsIClassInfo helper macros
  */
 
diff --git a/dom/interfaces/events/Makefile.in b/dom/interfaces/events/Makefile.in
--- a/dom/interfaces/events/Makefile.in
+++ b/dom/interfaces/events/Makefile.in
@@ -77,11 +77,12 @@ XPIDLSRCS =					\
 	nsIDOMMessageEvent.idl			\
 	nsIDOMNotifyPaintEvent.idl              \
 	nsIDOMPaintRequest.idl			\
 	nsIDOMPaintRequestList.idl		\
 	nsIDOMSimpleGestureEvent.idl		\
 	nsIDOMNSMouseEvent.idl			\
 	nsIDOMOrientationEvent.idl              \
 	nsIDOMScrollAreaEvent.idl		\
+	nsIDOMTransitionEvent.idl		\
 	$(NULL)
 
 include $(topsrcdir)/config/rules.mk
diff --git a/dom/interfaces/events/nsIDOMTransitionEvent.idl b/dom/interfaces/events/nsIDOMTransitionEvent.idl
new file mode 100644
--- /dev/null
+++ b/dom/interfaces/events/nsIDOMTransitionEvent.idl
@@ -0,0 +1,55 @@
+/* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsIDOMTransitionEvent.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMEvent.idl"
+
+/**
+ * Transition events are defined in:
+ * http://www.w3.org/TR/css3-transitions/#transition-events-
+ * http://dev.w3.org/csswg/css3-transitions/#transition-events-
+ */
+
+[scriptable, uuid(3e49ea4c-6f23-4aff-bd8f-e587edf514ec)]
+interface nsIDOMTransitionEvent : nsIDOMEvent {
+  readonly attribute DOMString           propertyName;
+  readonly attribute float               elapsedTime;
+  void               initTransitionEvent(in DOMString typeArg, 
+                                         in boolean canBubbleArg, 
+                                         in boolean cancelableArg, 
+                                         in DOMString propertyNameArg,
+                                         in float elapsedTimeArg);
+};
diff --git a/widget/public/nsGUIEvent.h b/widget/public/nsGUIEvent.h
--- a/widget/public/nsGUIEvent.h
+++ b/widget/public/nsGUIEvent.h
@@ -86,17 +86,17 @@ class nsHashKey;
 #define NS_SCROLLPORT_EVENT               18
 #define NS_MUTATION_EVENT                 19 // |nsMutationEvent| in content
 #define NS_ACCESSIBLE_EVENT               20
 #define NS_FORM_EVENT                     21
 #define NS_FOCUS_EVENT                    22
 #define NS_POPUP_EVENT                    23
 #define NS_COMMAND_EVENT                  24
 #define NS_SCROLLAREA_EVENT               25
-
+#define NS_TRANSITION_EVENT               26
 
 #define NS_UI_EVENT                       27
 #ifdef MOZ_SVG
 #define NS_SVG_EVENT                      30
 #define NS_SVGZOOM_EVENT                  31
 #endif // MOZ_SVG
 
 #define NS_QUERY_CONTENT_EVENT            33
@@ -443,16 +443,18 @@ class nsHashKey;
 // Event to gesture notification
 #define NS_GESTURENOTIFY_EVENT_START 3900
 
 #define NS_ORIENTATION_EVENT         4000
 
 #define NS_SCROLLAREA_EVENT_START    4100
 #define NS_SCROLLEDAREACHANGED       (NS_SCROLLAREA_EVENT_START)
 
+#define NS_TRANSITION_EVENT_START    4200
+#define NS_TRANSITION_END            (NS_TRANSITION_EVENT_START)
 
 /**
  * Return status for event processors, nsEventStatus, is defined in
  * nsEvent.h.
  */
 
 /**
  * different types of (top-level) window z-level positioning
@@ -1324,16 +1326,31 @@ public:
       direction(directionArg), delta(deltaArg)
   {
   }
 
   PRUint32 direction;   // See nsIDOMSimpleGestureEvent for values
   PRFloat64 delta;      // Delta for magnify and rotate events
 };
 
+class nsTransitionEvent : public nsEvent
+{
+public:
+  nsTransitionEvent(PRBool isTrusted, PRUint32 msg,
+                    const nsString &propertyNameArg, float elapsedTimeArg)
+    : nsEvent(isTrusted, msg, NS_TRANSITION_EVENT),
+      propertyName(propertyNameArg), elapsedTime(elapsedTimeArg)
+  {
+  }
+
+  nsString propertyName;
+  float elapsedTime;
+};
+
+
 /**
  * Event status for D&D Event
  */
 enum nsDragDropEventStatus {  
   /// The event is a enter
   nsDragDropEventStatus_eDragEntered,            
   /// The event is exit
   nsDragDropEventStatus_eDragExited, 
