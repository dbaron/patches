From: L. David Baron <dbaron@dbaron.org>

Bug 451791 patch 2 - Report block non-empty to its parent block during margin collapsing if we encounter clearance.  r=roc

The goal of ComputeCollapsedBStartMargin is to collapse all of the
margins that collapse with a block's top margin.  It does this by
scanning forward through the child list until it finds something that
blocks collapsing; it descends into children through recursion.  When we
find a non-empty block or line, we stop collapsing and report to the
parent that the child is non-empty so that it stops collapsing as well.

This patch changes our behavior when we have clearance to do the same
thing that we do for non-empty lines or blocks (which makes both
occurrences of |goto done| be preceded by the same code).  Without the
patch we would fail to report being non-empty to the parent (and instead
report emptiness based on the IsEmpty() method).  This meant that,
without the patch, if a block has a child with clearance but also has
IsEmpty() true, we would stop scanning margins in that block after the
clearance, but start searching again for margins in the block's parent,
starting with the block's bottom margin.  This patch sets *aBlockIsEmpty
to true in that case so that we do not pick up again in the block's
parent (or, potentially, grandparent, etc.).

diff --git a/layout/generic/nsBlockReflowContext.cpp b/layout/generic/nsBlockReflowContext.cpp
--- a/layout/generic/nsBlockReflowContext.cpp
+++ b/layout/generic/nsBlockReflowContext.cpp
@@ -131,16 +131,20 @@ nsBlockReflowContext::ComputeCollapsedBS
         if (line->IsInline()) {
           isEmpty = line->IsEmpty();
         } else {
           nsIFrame* kid = line->mFirstChild;
           if (kid == aClearanceFrame) {
             line->SetHasClearance();
             line->MarkDirty();
             dirtiedLine = true;
+            if (!setBlockIsEmpty && aBlockIsEmpty) {
+              setBlockIsEmpty = true;
+              *aBlockIsEmpty = false;
+            }
             goto done;
           }
           // Here is where we recur. Now that we have determined that a
           // generational collapse is required we need to compute the
           // child blocks margin and so in so that we can look into
           // it. For its margins to be computed we need to have a reflow
           // state for it.
 
diff --git a/layout/reftests/margin-collapsing/reftest.list b/layout/reftests/margin-collapsing/reftest.list
--- a/layout/reftests/margin-collapsing/reftest.list
+++ b/layout/reftests/margin-collapsing/reftest.list
@@ -761,18 +761,18 @@ fails-if(Android&&AndroidVersion==18) !=
 == block-float-1a-dyn.html block-float-1a-ref.html
 == block-float-1b-dyn.html block-float-1b-ref.html
 == block-float-2a-dyn.html block-float-2a-ref.html
 == block-float-2b-dyn.html block-float-2b-ref.html
 == block-float-3a-dyn.html block-float-3a-ref.html
 == block-float-3b-dyn.html block-float-3b-ref.html
 # Tests for various cases where clearance is applied and collapsing is
 # prevented or only allows for certain margins.
-fails == block-clear-1a.html block-clear-1a-ref.html # Bug 451791
-fails == block-clear-1b.html block-clear-1b-ref.html # Bug 451791
+== block-clear-1a.html block-clear-1a-ref.html
+== block-clear-1b.html block-clear-1b-ref.html
 == block-clear-2.html block-clear-2-ref.html
 != block-clear-2.html block-clear-2-noref.html
 == block-clear-3a.html block-clear-3-ref-left.html
 == block-clear-3b.html block-clear-3-ref-right.html
 == block-clear-3c.html block-clear-3-ref-left.html
 == block-clear-3d.html block-clear-3-ref-right.html
 == block-clear-3e.html block-clear-3-ref-left.html
 == block-clear-3f.html block-clear-3-ref-right.html
