From: L. David Baron <dbaron@dbaron.org>

Do the same for PlaceBelowCurrentLineFloats:  don't propagate the truncation of a float into the line's reflow status.  (Bug 563584)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -4204,27 +4204,20 @@ nsBlockFrame::PlaceLine(nsBlockReflowSta
 
   aState.mY = newY;
   
   // Add the already placed current-line floats to the line
   aLine->AppendFloats(aState.mCurrentLineFloats);
 
   // Any below current line floats to place?
   if (aState.mBelowCurrentLineFloats.NotEmpty()) {
-    // Reflow the below-current-line floats, then add them to the
-    // lines float list if there aren't any truncated floats.
-    if (aState.PlaceBelowCurrentLineFloats(aState.mBelowCurrentLineFloats)) {
-      aLine->AppendFloats(aState.mBelowCurrentLineFloats);
-    }
-    else { 
-      // At least one float is truncated, so fix up any placeholders that got split and
-      // push the line. XXX It may be better to put the float on the next line, but this
-      // is not common enough to justify the complexity. Or maybe it is now...
-      PushTruncatedPlaceholderLine(aState, aLine, *aKeepReflowGoing);
-    }
+    // Reflow the below-current-line floats, which places on the line's
+    // float list.
+    aState.PlaceBelowCurrentLineFloats(aState.mBelowCurrentLineFloats);
+    aLine->AppendFloats(aState.mBelowCurrentLineFloats);
   }
 
   // When a line has floats, factor them into the combined-area
   // computations.
   if (aLine->HasFloats()) {
     // Combine the float combined area (stored in aState) and the
     // value computed by the line layout code.
     nsRect lineCombinedArea(aLine->GetCombinedArea());
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -945,43 +945,38 @@ nsBlockReflowState::PushFloatPastBreak(n
   AppendFloatContinuation(aFloat);
 
   NS_FRAME_SET_OVERFLOW_INCOMPLETE(mReflowStatus);
 }
 
 /**
  * Place below-current-line floats.
  */
-PRBool
+void
 nsBlockReflowState::PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aList)
 {
   nsFloatCache* fc = aList.Head();
   while (fc) {
-    {
 #ifdef DEBUG
-      if (nsBlockFrame::gNoisyReflow) {
-        nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
-        printf("placing bcl float: ");
-        nsFrame::ListTag(stdout, fc->mFloat);
-        printf("\n");
-      }
+    if (nsBlockFrame::gNoisyReflow) {
+      nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
+      printf("placing bcl float: ");
+      nsFrame::ListTag(stdout, fc->mFloat);
+      printf("\n");
+    }
 #endif
-      // Place the float
-      nsReflowStatus reflowStatus;
-      PRBool placed = FlowAndPlaceFloat(fc->mFloat, reflowStatus);
-
-      if (!placed) {
-        // return before processing all of the floats, since the line will be pushed.
-        // FIXME: This seems like it should be handled elsewhere...
-        return PR_FALSE;
-      }
+    // Place the float
+    nsReflowStatus reflowStatus;
+    PRBool placed = FlowAndPlaceFloat(fc->mFloat, reflowStatus);
+    nsFloatCache *next = fc->Next();
+    if (!placed) {
+      aList.Remove(fc);
     }
-    fc = fc->Next();
+    fc = next;
   }
-  return PR_TRUE;
 }
 
 nscoord
 nsBlockReflowState::ClearFloats(nscoord aY, PRUint8 aBreakType,
                                 nsIFrame *aReplacedBlock)
 {
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -110,17 +110,17 @@ public:
                   nsReflowStatus&     aReflowStatus);
 private:
   PRBool CanPlaceFloat(nscoord aFloatWidth,
                        const nsFlowAreaRect& aFloatAvailableSpace);
   PRBool FlowAndPlaceFloat(nsIFrame*       aFloat,
                            nsReflowStatus& aReflowStatus);
   void PushFloatPastBreak(nsIFrame* aFloat);
 public:
-  PRBool PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aFloats);
+  void PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aFloats);
 
   // Returns the first coordinate >= aY that clears the
   // floats indicated by aBreakType and has enough width between floats
   // (or no floats remaining) to accomodate aReplacedBlock.
   nscoord ClearFloats(nscoord aY, PRUint8 aBreakType,
                       nsIFrame *aReplacedBlock = nsnull);
 
   PRBool IsAdjacentWithTop() const {
