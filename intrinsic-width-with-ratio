Implement correct intrinsic width calculation (for container) for elements with specified height properties and an intrinsic ratio.  b=364066

diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -1250,6 +1250,60 @@ static PRBool GetAbsoluteCoord(const nsS
   return PR_FALSE;
 }
 
+static PRBool
+GetPercentHeight(const nsStyleCoord& aStyle,
+                 nsIRenderingContext* aRenderingContext,
+                 nsIFrame* aFrame,
+                 nscoord& aResult)
+{
+  if (eStyleUnit_Percent == aStyle.GetUnit())
+    return PR_FALSE;
+
+  for (nsIFrame *f = aFrame->GetParent(); f && !f->IsContainingBlock();
+       f = f->GetParent())
+    ;
+  if (!f) {
+    NS_NOTREACHED("top of frame tree not a containing block");
+    return PR_FALSE;
+  }
+
+  const nsStylePosition *pos = f->GetStylePosition();
+  nscoord h;
+  if (!GetAbsoluteCoord(pos->mHeight, aRenderingContext, f, h) &&
+      !GetPercentCoord(pos->mHeight, aRenderingContext, f, h)) {
+    NS_ASSERTION(pos->mHeight.GetUnit() == eStyleUnit_Auto,
+                 "unknown height unit");
+    // There's no basis for the percentage height, so it acts like auto.
+    // Should we consider a max-height < min-height pair a basis for
+    // percentage heights?  The spec is somewhat unclear, and not doing
+    // so is simpler and avoids troubling discontinuities in behavior,
+    // so I'll choose not to. -LDB
+    return PR_FALSE;
+  }
+
+  nscoord maxh;
+  if (GetAbsoluteCoord(pos->mMaxHeight, aRenderingContext, f, maxh) ||
+      GetPercentCoord(pos->mMaxHeight, aRenderingContext, f, maxh)) {
+    if (maxh < h)
+      h = maxh;
+  } else {
+    NS_ASSERTION(pos->mMaxHeight.GetUnit() == eStyleUnit_Null,
+                 "unknown max-height unit");
+  }
+
+  nscoord minh;
+  if (GetAbsoluteCoord(pos->mMinHeight, aRenderingContext, f, minh) ||
+      GetPercentCoord(pos->mMinHeight, aRenderingContext, f, minh)) {
+    if (minh > h)
+      h = minh;
+  } else {
+    NS_NOTREACHED("unknown min-height unit");
+  }
+
+  aResult = NSToCoordRound(aStyle.GetPercentValue() * h);
+  return PR_TRUE;
+}
+
 // Handles only -moz-intrinsic and -moz-min-intrinsic, and
 // -moz-shrink-wrap for min-width and max-width, since the others
 // (-moz-shrink-wrap for width, and -moz-fill) have no effect on
@@ -1366,6 +1420,40 @@ nsLayoutUtils::IntrinsicForContainer(nsI
     printf(" %s intrinsic width from frame is %d.\n",
            aType == MIN_WIDTH ? "min" : "pref", result);
 #endif
+
+    // Handle elements with an intrinsic ratio (or size) and a specified
+    // height, min-height, or max-height.
+    const nsStyleCoord &styleHeight = stylePos->mHeight;
+    const nsStyleCoord &styleMinHeight = stylePos->mMinHeight;
+    const nsStyleCoord &styleMaxHeight = stylePos->mMaxHeight;
+    if (styleHeight.GetUnit() != eStyleUnit_Auto ||
+        !(styleMinHeight.GetUnit() == eStyleUnit_Coord &&
+          styleMinHeight.GetCoordValue() == 0) ||
+        styleMaxHeight.GetUnit() != eStyleUnit_Null) {
+      nsSize ratio = aFrame->GetIntrinsicRatio(aRenderingContext);
+      if (ratio.height != 0) {
+
+        nscoord h;
+        if (GetAbsoluteCoord(styleHeight, aRenderingContext, aFrame, h) ||
+            GetPercentHeight(styleHeight, aRenderingContext, aFrame, h)) {
+          result = h * ratio.width / ratio.height;
+        }
+
+        if (GetAbsoluteCoord(styleMaxHeight, aRenderingContext, aFrame, h) ||
+            GetPercentHeight(styleMaxHeight, aRenderingContext, aFrame, h)) {
+          h = h * ratio.width / ratio.height;
+          if (h < result)
+            result = h;
+        }
+
+        if (GetAbsoluteCoord(styleMinHeight, aRenderingContext, aFrame, h) ||
+            GetPercentHeight(styleMinHeight, aRenderingContext, aFrame, h)) {
+          h = h * ratio.width / ratio.height;
+          if (h > result)
+            result = h;
+        }
+      }
+    }
   }
       
   if (aFrame->GetType() == nsGkAtoms::tableFrame) {
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -3101,6 +3101,12 @@ nsFrame::IntrinsicWidthOffsets(nsIRender
   }
 
   return result;
+}
+
+/* virtual */ nsSize
+nsFrame::GetIntrinsicRatio(nsIRenderingContext* aRenderingContext)
+{
+  return nsSize(0, 0);
 }
 
 inline PRBool
diff --git a/layout/generic/nsFrame.h b/layout/generic/nsFrame.h
--- a/layout/generic/nsFrame.h
+++ b/layout/generic/nsFrame.h
@@ -277,6 +277,7 @@ public:
                                   InlinePrefWidthData *aData);
   virtual IntrinsicWidthOffsetData
     IntrinsicWidthOffsets(nsIRenderingContext* aRenderingContext);
+  virtual nsSize GetIntrinsicRatio(nsIRenderingContext* aRenderingContext);
 
   virtual nsSize ComputeSize(nsIRenderingContext *aRenderingContext,
                              nsSize aCBSize, nscoord aAvailableWidth,
diff --git a/layout/generic/nsHTMLCanvasFrame.cpp b/layout/generic/nsHTMLCanvasFrame.cpp
--- a/layout/generic/nsHTMLCanvasFrame.cpp
+++ b/layout/generic/nsHTMLCanvasFrame.cpp
@@ -100,6 +100,12 @@ nsHTMLCanvasFrame::GetPrefWidth(nsIRende
 }
 
 /* virtual */ nsSize
+nsHTMLCanvasFrame::GetIntrinsicRatio(nsIRenderingContext* aRenderingContext)
+{
+  return GetCanvasSize();
+}
+
+/* virtual */ nsSize
 nsHTMLCanvasFrame::ComputeSize(nsIRenderingContext *aRenderingContext,
                                nsSize aCBSize, nscoord aAvailableWidth,
                                nsSize aMargin, nsSize aBorder, nsSize aPadding,
diff --git a/layout/generic/nsHTMLCanvasFrame.h b/layout/generic/nsHTMLCanvasFrame.h
--- a/layout/generic/nsHTMLCanvasFrame.h
+++ b/layout/generic/nsHTMLCanvasFrame.h
@@ -65,6 +65,7 @@ public:
 
   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);
   virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);
+  virtual nsSize GetIntrinsicRatio(nsIRenderingContext* aRenderingContext);
 
   virtual nsSize ComputeSize(nsIRenderingContext *aRenderingContext,
                              nsSize aCBSize, nscoord aAvailableWidth,
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -1177,6 +1177,17 @@ public:
   virtual IntrinsicWidthOffsetData
     IntrinsicWidthOffsets(nsIRenderingContext* aRenderingContext) = 0;
 
+  /*
+   * Get the intrinsic ratio of this element, or nsSize(0,0) if it has
+   * no intrinsic ratio.  The intrinsic ratio is the ratio of the
+   * height/width of a box with an intrinsic size or the intrinsic
+   * aspect ratio of a scalable vector image without an intrinsic size.
+   *
+   * Either one of the sides may be zero, indicating a zero or infinite
+   * ratio.
+   */
+  virtual nsSize GetIntrinsicRatio(nsIRenderingContext* aRenderingContext) = 0;
+
   /**
    * Compute the size that a frame will occupy.  Called while
    * constructing the nsHTMLReflowState to be used to Reflow the frame,
diff --git a/layout/generic/nsImageFrame.cpp b/layout/generic/nsImageFrame.cpp
--- a/layout/generic/nsImageFrame.cpp
+++ b/layout/generic/nsImageFrame.cpp
@@ -773,6 +773,13 @@ nsImageFrame::GetPrefWidth(nsIRenderingC
   return result;
 }
 
+/* virtual */ nsSize
+nsImageFrame::GetIntrinsicRatio(nsIRenderingContext* aRenderingContext)
+{
+  EnsureIntrinsicSize(GetPresContext());
+  return mIntrinsicSize;
+}
+
 NS_IMETHODIMP
 nsImageFrame::Reflow(nsPresContext*          aPresContext,
                      nsHTMLReflowMetrics&     aMetrics,
diff --git a/layout/generic/nsImageFrame.h b/layout/generic/nsImageFrame.h
--- a/layout/generic/nsImageFrame.h
+++ b/layout/generic/nsImageFrame.h
@@ -108,6 +108,7 @@ public:
                               const nsDisplayListSet& aLists);
   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);
   virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);
+  virtual nsSize GetIntrinsicRatio(nsIRenderingContext* aRenderingContext);
   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
                     nsHTMLReflowMetrics&     aDesiredSize,
                     const nsHTMLReflowState& aReflowState,
diff --git a/layout/svg/base/src/nsSVGOuterSVGFrame.h b/layout/svg/base/src/nsSVGOuterSVGFrame.h
--- a/layout/svg/base/src/nsSVGOuterSVGFrame.h
+++ b/layout/svg/base/src/nsSVGOuterSVGFrame.h
@@ -67,6 +67,9 @@ private:
 
 public:
   // nsIFrame:
+  // XXX Should this implement intrinsic width methods (esp.
+  // GetIntrinsicRatio)?
+
   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
                     nsHTMLReflowMetrics&     aDesiredSize,
                     const nsHTMLReflowState& aReflowState,
