Fix bug 25888 for inline frames other than bullets:  redo line reflow when the line's height pushes it into the way of other floats.  (Bug 25888)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1656,19 +1656,18 @@ nsBlockFrame::PropagateFloatDamage(nsBlo
   if (aDeltaY + aState.mReflowState.mBlockDelta != 0) {
     if (aLine->IsBlock()) {
       // Unconditionally reflow sliding blocks; we only really need to reflow
       // if there's a float impacting this block, but the current float manager
       // makes it difficult to check that.  Therefore, we let the child block
       // decide what it needs to reflow.
       aLine->MarkDirty();
     } else {
-      // Note that this check will become incorrect once bug 25888 is fixed
-      // because we are only checking the top of the line
-      aState.GetAvailableSpace(aLine->mBounds.y + aDeltaY, PR_FALSE);
+      aState.GetAvailableSpaceForHeight(aLine->mBounds.y + aDeltaY,
+                                        aLine->mBounds.height, PR_FALSE);
       PRBool wasImpactedByFloat = aLine->IsImpactedByFloat();
       PRBool isImpactedByFloat = aState.IsImpactedByFloat();
 
 #ifdef REALLY_NOISY_REFLOW
     printf("nsBlockFrame::PropagateFloatDamage %p was = %d, is=%d\n", 
        this, wasImpactedByFloat, isImpactedByFloat);
 #endif
 
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -361,16 +361,46 @@ nsBlockReflowState::GetAvailableSpace(ns
     printf("GetAvailableSpace: band=%d,%d,%d,%d hasfloats=%d\n",
            mAvailSpaceRect.x, mAvailSpaceRect.y,
            mAvailSpaceRect.width, mAvailSpaceRect.height,
            mBandHasFloats);
   }
 #endif
 }
 
+void
+nsBlockReflowState::GetAvailableSpaceForHeight(nscoord aY, nscoord aHeight)
+{
+#ifdef DEBUG
+  // Verify that the caller setup the coordinate system properly
+  nscoord wx, wy;
+  mFloatManager->GetTranslation(wx, wy);
+  NS_ASSERTION((wx == mFloatManagerX) && (wy == mFloatManagerY),
+               "bad coord system");
+#endif
+
+  PRBool hasFloats;
+  mAvailSpaceRect = 
+    mFloatManager->GetFlowArea(aY - BorderPadding().top, 
+                               nsFloatManager::WIDTH_WITHIN_HEIGHT,
+                               aHeight, mContentArea.width,
+                               &hasFloats);
+  mBandHasFloats = hasFloats;
+
+#ifdef DEBUG
+  if (nsBlockFrame::gNoisyReflow) {
+    nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
+    printf("GetAvailableSpaceForHeight: space=%d,%d,%d,%d hasfloats=%d\n",
+           mAvailSpaceRect.x, mAvailSpaceRect.y,
+           mAvailSpaceRect.width, mAvailSpaceRect.height,
+           mBandHasFloats);
+  }
+#endif
+}
+
 /*
  * Reconstruct the vertical margin before the line |aLine| in order to
  * do an incremental reflow that begins with |aLine| without reflowing
  * the line before it.  |aLine| may point to the fencepost at the end of
  * the line list, and it is used this way since we (for now, anyway)
  * always need to recover margins at the end of a block.
  *
  * The reconstruction involves walking backward through the line list to
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -84,16 +84,17 @@ public:
 
   /**
    * Get the available reflow space for the current y coordinate. The
    * available space is relative to our coordinate system (0,0) is our
    * upper left corner.
    */
   void GetAvailableSpace() { GetAvailableSpace(mY, PR_FALSE); }
   void GetAvailableSpace(nscoord aY, PRBool aRelaxHeightConstraint);
+  void GetAvailableSpaceForHeight(nscoord aY, nscoord aHeight);
 
   /*
    * The following functions all return PR_TRUE if they were able to
    * place the float, PR_FALSE if the float did not fit in available
    * space.
    */
   PRBool InitFloat(nsLineLayout&       aLineLayout,
                    nsPlaceholderFrame* aPlaceholderFrame,
