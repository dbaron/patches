From: L. David Baron <dbaron@dbaron.org>

Switch nsLayoutUtils inflation methods to the new setup with state on the pres context.  (Bug 706609)

diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -4606,102 +4606,49 @@ ShouldInflateFontsForContainer(const nsI
   // height (propagating down the tree), but the propagation stops when
   // we hit overflow-y: scroll or auto.
   return aFrame->GetStyleText()->mTextSizeAdjust !=
            NS_STYLE_TEXT_SIZE_ADJUST_NONE &&
          !(aFrame->GetStateBits() & NS_FRAME_IN_CONSTRAINED_HEIGHT);
 }
 
 nscoord
-nsLayoutUtils::InflationMinFontSizeFor(const nsHTMLReflowState &aReflowState)
+nsLayoutUtils::InflationMinFontSizeFor(const nsIFrame *aFrame,
+                                       WidthDetermination aWidthDetermination)
 {
 #ifdef DEBUG
-  {
-    const nsHTMLReflowState *rs = &aReflowState;
-    nsIFrame *f = aReflowState.frame;
-    for (; rs; rs = rs->parentReflowState, f = f->GetParent()) {
-      NS_ABORT_IF_FALSE(rs->frame == f,
-                        "reflow state parentage must match frame parentage");
-      nsIScrollableFrame *sf;
-      NS_ABORT_IF_FALSE(rs->parentReflowState ||
-                        IsContainerForFontSizeInflation(f) ||
-                        // OK if NS_FRAME_IN_REFLOW is not set on
-                        // (non-null) parent, since its ancestors have a
-                        // real size.  (Do we set NS_FRAME_IN_REFLOW
-                        // correctly for xul?)
-                        !(f->GetParent()->GetStateBits() &
-                          NS_FRAME_IN_REFLOW) ||
-                        // ugly exception, but ok because the
-                        // child is a container
-                        (f->GetType() == nsGkAtoms::scrollFrame &&
-                         (sf = do_QueryFrame(f)) &&
-                         (IsContainerForFontSizeInflation(
-                            sf->GetScrolledFrame()))),
-                        "must hit container at top of reflow state chain");
+  if (aWidthDetermination == eNotInReflow) {
+    // Check that neither this frame nor any of its ancestors are
+    // currently being reflowed.
+    // It's ok for box frames (but not arbitrary ancestors of box frames)
+    // since they set their size before reflow.
+    if (!(aFrame->IsBoxFrame() && IsContainerForFontSizeInflation(aFrame))) {
+      for (const nsIFrame *f = aFrame; f; f = f->GetParent()) {
+        NS_ABORT_IF_FALSE(!(f->GetStateBits() & NS_FRAME_IN_REFLOW),
+                          "must call nsHTMLReflowState& version during reflow");
+      }
     }
+    // It's ok if frames are dirty, or even if they've never been
+    // reflowed, since they will be eventually and then we'll get the
+    // right size.
   }
 #endif
 
-  if (!FontSizeInflationEnabled(aReflowState.frame->PresContext())) {
+  if (!FontSizeInflationEnabled(aFrame->PresContext())) {
     return 0;
   }
 
-  nsIFrame *reflowRoot = nsnull;
-  for (const nsHTMLReflowState *rs = &aReflowState; rs;
-       reflowRoot = rs->frame, rs = rs->parentReflowState) {
-    if (IsContainerForFontSizeInflation(rs->frame)) {
-      if (!ShouldInflateFontsForContainer(rs->frame)) {
-        return 0;
-      }
-
-      NS_ABORT_IF_FALSE(rs->ComputedWidth() != NS_INTRINSICSIZE,
-                        "must have a computed width");
-      return MinimumFontSizeFor(aReflowState.frame->PresContext(),
-                                rs->ComputedWidth());
+  if (aWidthDetermination == eInReflow) {
+    nsPresContext *presContext = aFrame->PresContext();
+    nsIFrame *container = presContext->mCurrentInflationContainer;
+    if (!container || !ShouldInflateFontsForContainer(container)) {
+      return 0;
     }
-  }
-
-  // We've hit the end of the reflow state chain.  There are two
-  // possibilities now:  we're either at a reflow root or we're crossing
-  // into flexbox layout.  (Note that sometimes we cross into and out of
-  // flexbox layout on the same frame, e.g., for nsTextControlFrame,
-  // which breaks the reflow state parentage chain.)
-  // This code depends on:
-  //  * When we cross from HTML to XUL and then on the child jump back
-  //    to HTML again, we link the reflow states correctly (see hack in
-  //    nsFrame::BoxReflow setting reflowState.parentReflowState).
-  //  * For any other cases, the XUL frame is a font size inflation
-  //    container, so we won't cross back into HTML (see the conditions
-  //    under which we test the assertion in
-  //    InflationMinFontSizeFor(const nsIFrame *).
-
-  return InflationMinFontSizeFor(reflowRoot->GetParent());
-}
-
-nscoord
-nsLayoutUtils::InflationMinFontSizeFor(const nsIFrame *aFrame)
-{
-#ifdef DEBUG
-  // Check that neither this frame nor any of its ancestors are
-  // currently being reflowed.
-  // It's ok for box frames (but not arbitrary ancestors of box frames)
-  // since they set their size before reflow.
-  if (!(aFrame->IsBoxFrame() && IsContainerForFontSizeInflation(aFrame))) {
-    for (const nsIFrame *f = aFrame; f; f = f->GetParent()) {
-      NS_ABORT_IF_FALSE(!(f->GetStateBits() & NS_FRAME_IN_REFLOW),
-                        "must call nsHTMLReflowState& version during reflow");
-    }
-  }
-  // It's ok if frames are dirty, or even if they've never been
-  // reflowed, since they will be eventually and then we'll get the
-  // right size.
-#endif
-
-  if (!FontSizeInflationEnabled(aFrame->PresContext())) {
-    return 0;
+    return MinimumFontSizeFor(presContext,
+                              presContext->mCurrentInflationContainerWidth);
   }
 
   for (const nsIFrame *f = aFrame; f; f = f->GetParent()) {
     if (IsContainerForFontSizeInflation(f)) {
       if (!ShouldInflateFontsForContainer(f)) {
         return 0;
       }
 
@@ -4710,103 +4657,45 @@ nsLayoutUtils::InflationMinFontSizeFor(c
     }
   }
 
   NS_ABORT_IF_FALSE(false, "root should always be container");
 
   return 0;
 }
 
-/* static */ nscoord
-nsLayoutUtils::InflationMinFontSizeFor(const nsIFrame *aFrame,
-                                       nscoord aInflationContainerWidth)
-{
-  if (!FontSizeInflationEnabled(aFrame->PresContext())) {
-    return 0;
-  }
-
-  for (const nsIFrame *f = aFrame; f; f = f->GetParent()) {
-    if (IsContainerForFontSizeInflation(f)) {
-      if (!ShouldInflateFontsForContainer(f)) {
-        return 0;
-      }
-
-      // The caller is (sketchily) asserting that it picked the right
-      // container when passing aInflationContainerWidth.  We only do
-      // this for text inputs and a few other limited situations.
-      return MinimumFontSizeFor(aFrame->PresContext(),
-                                aInflationContainerWidth);
-    }
-  }
-
-  NS_ABORT_IF_FALSE(false, "root should always be container");
-
-  return 0;
-}
-
 float
-nsLayoutUtils::FontSizeInflationFor(const nsHTMLReflowState &aReflowState)
+nsLayoutUtils::FontSizeInflationFor(const nsIFrame *aFrame,
+                                    WidthDetermination aWidthDetermination)
 {
 #ifdef DEBUG
-  {
-    const nsHTMLReflowState *rs = &aReflowState;
-    const nsIFrame *f = aReflowState.frame;
-    for (; rs; rs = rs->parentReflowState, f = f->GetParent()) {
-      NS_ABORT_IF_FALSE(rs->frame == f,
-                        "reflow state parentage must match frame parentage");
+  if (aWidthDetermination == eNotInReflow) {
+    // Check that neither this frame nor any of its ancestors are
+    // currently being reflowed.
+    // It's ok for box frames (but not arbitrary ancestors of box frames)
+    // since they set their size before reflow.
+    if (!(aFrame->IsBoxFrame() && IsContainerForFontSizeInflation(aFrame))) {
+      for (const nsIFrame *f = aFrame; f; f = f->GetParent()) {
+        NS_ABORT_IF_FALSE(!(f->GetStateBits() & NS_FRAME_IN_REFLOW),
+                          "must call nsHTMLReflowState& version during reflow");
+      }
     }
+    // It's ok if frames are dirty, or even if they've never been
+    // reflowed, since they will be eventually and then we'll get the
+    // right size.
   }
 #endif
 
-  if (!FontSizeInflationEnabled(aReflowState.frame->PresContext())) {
-    return 1.0;
-  }
-
-  return FontSizeInflationInner(aReflowState.frame,
-             InflationMinFontSizeFor(aReflowState));
-}
-
-float
-nsLayoutUtils::FontSizeInflationFor(const nsIFrame *aFrame)
-{
-#ifdef DEBUG
-  // Check that neither this frame nor any of its ancestors are
-  // currently being reflowed.
-  // It's ok for box frames (but not arbitrary ancestors of box frames)
-  // since they set their size before reflow.
-  if (!(aFrame->IsBoxFrame() && IsContainerForFontSizeInflation(aFrame))) {
-    for (const nsIFrame *f = aFrame; f; f = f->GetParent()) {
-      NS_ABORT_IF_FALSE(!(f->GetStateBits() & NS_FRAME_IN_REFLOW),
-                        "must call nsHTMLReflowState& version during reflow");
-    }
-  }
-  // It's ok if frames are dirty, or even if they've never been
-  // reflowed, since they will be eventually and then we'll get the
-  // right size.
-#endif
-
   if (!FontSizeInflationEnabled(aFrame->PresContext())) {
     return 1.0;
   }
 
   return FontSizeInflationInner(aFrame,
-                                InflationMinFontSizeFor(aFrame));
-}
-
-/* static */ float
-nsLayoutUtils::FontSizeInflationFor(const nsIFrame *aFrame,
-                                    nscoord aInflationContainerWidth)
-{
-  if (!FontSizeInflationEnabled(aFrame->PresContext())) {
-    return 1.0;
-  }
-
-  return FontSizeInflationInner(aFrame,
                                 InflationMinFontSizeFor(aFrame,
-                                  aInflationContainerWidth));
+                                                        aWidthDetermination));
 }
 
 /* static */ bool
 nsLayoutUtils::FontSizeInflationEnabled(nsPresContext *aPresContext)
 {
   return (sFontSizeInflationEmPerLine != 0 ||
           sFontSizeInflationMinTwips != 0) &&
          !aPresContext->IsChrome();
diff --git a/layout/base/nsLayoutUtils.h b/layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h
+++ b/layout/base/nsLayoutUtils.h
@@ -1484,44 +1484,41 @@ public:
     return aFrame->GetStateBits() & NS_FRAME_FONT_INFLATION_CONTAINER;
   }
 
   /**
    * Return the font size inflation *ratio* for a given frame.  This is
    * the factor by which font sizes should be inflated; it is never
    * smaller than 1.
    *
-   * There are three variants: pass a reflow state if the frame or any
-   * of its ancestors are currently being reflowed and a frame
-   * otherwise, or, if you know the width of the inflation container (a
-   * somewhat sketchy assumption), its width.
+   * The WidthDetermination parameter says how we determine the width of
+   * the nearest inflation container:  when not in reflow we look at the
+   * frame tree; when in  reflow we look at state stored on the pres
+   * context.
    */
-  static float FontSizeInflationFor(const nsHTMLReflowState &aReflowState);
-  static float FontSizeInflationFor(const nsIFrame *aFrame);
+  enum WidthDetermination { eNotInReflow, eInReflow };
   static float FontSizeInflationFor(const nsIFrame *aFrame,
-                                    nscoord aInflationContainerWidth);
+                                    WidthDetermination aWidthDetermination);
 
   /**
    * Perform the first half of the computation of FontSizeInflationFor
    * (see above).
    * This includes determining whether inflation should be performed
    * within this container and returning 0 if it should not be.
    *
    * The result is guaranteed not to vary between line participants
    * (inlines, text frames) within a line.
    *
    * The result should not be used directly since font sizes slightly
    * above the minimum should always be adjusted as done by
    * FontSizeInflationInner.
    */
-  static nscoord InflationMinFontSizeFor(const nsHTMLReflowState
-                                                 &aReflowState);
-  static nscoord InflationMinFontSizeFor(const nsIFrame *aFrame);
   static nscoord InflationMinFontSizeFor(const nsIFrame *aFrame,
-                                         nscoord aInflationContainerWidth);
+                                         WidthDetermination
+                                           aWidthDetermination);
 
   /**
    * Perform the second half of the computation done by
    * FontSizeInflationFor (see above).
    *
    * aMinFontSize must be the result of one of the
    *   InflationMinFontSizeFor methods above.
    */
