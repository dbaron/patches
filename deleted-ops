From: L. David Baron <dbaron@dbaron.org>

Bug 1271182 - Add some deleted assignment operators and copy constructors.

These are generally good practice for reference-counted objects; they
catch cases where these operations are used by accident, breaking
reference-counting.

MozReview-Commit-ID: EvRkNCymOqT

diff --git a/xpcom/glue/nsThreadUtils.h b/xpcom/glue/nsThreadUtils.h
--- a/xpcom/glue/nsThreadUtils.h
+++ b/xpcom/glue/nsThreadUtils.h
@@ -227,31 +227,39 @@ class Runnable : public nsIRunnable
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIRUNNABLE
 
   Runnable() {}
 
 protected:
   virtual ~Runnable() {}
+private:
+  Runnable(const Runnable&) = delete;
+  Runnable& operator=(const Runnable&) = delete;
+  Runnable& operator=(const Runnable&&) = delete;
 };
 
 // This class is designed to be subclassed.
 class CancelableRunnable : public Runnable,
                            public nsICancelableRunnable
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
   // nsICancelableRunnable
   virtual nsresult Cancel() override;
 
   CancelableRunnable() {}
 
 protected:
   virtual ~CancelableRunnable() {}
+private:
+  CancelableRunnable(const CancelableRunnable&) = delete;
+  CancelableRunnable& operator=(const CancelableRunnable&) = delete;
+  CancelableRunnable& operator=(const CancelableRunnable&&) = delete;
 };
 
 } // namespace mozilla
 
 // An event that can be used to call a C++11 functions or function objects,
 // including lambdas. The function must have no required arguments, and must
 // return void.
 template<typename Function>
diff --git a/xpcom/threads/TimerThread.cpp b/xpcom/threads/TimerThread.cpp
--- a/xpcom/threads/TimerThread.cpp
+++ b/xpcom/threads/TimerThread.cpp
@@ -183,16 +183,20 @@ public:
 
   void SetTimer(already_AddRefed<nsTimerImpl> aTimer)
   {
     mTimer = aTimer;
     mGeneration = mTimer->GetGeneration();
   }
 
 private:
+  nsTimerEvent(const nsTimerEvent&) = delete;
+  nsTimerEvent& operator=(const nsTimerEvent&) = delete;
+  nsTimerEvent& operator=(const nsTimerEvent&&) = delete;
+
   ~nsTimerEvent()
   {
     MOZ_COUNT_DTOR(nsTimerEvent);
 
     MOZ_ASSERT(!sCanDeleteAllocator || sAllocatorUsers > 0,
                "This will result in us attempting to deallocate the nsTimerEvent allocator twice");
     sAllocatorUsers--;
   }
