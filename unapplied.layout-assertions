From: L. David Baron <dbaron@dbaron.org>

Add assertions that we don't execute script, fire events, or mutate the document during frame construction, reflow, or painting.  (Bug 335053, Bug 335054)

diff --git a/content/base/public/nsContentUtils.h b/content/base/public/nsContentUtils.h
--- a/content/base/public/nsContentUtils.h
+++ b/content/base/public/nsContentUtils.h
@@ -1494,16 +1494,27 @@ public:
                              // If non-null aHolder will keep the jsval alive
                              // while there's a ref to it
                              nsIXPConnectJSObjectHolder** aHolder = nsnull,
                              PRBool aAllowWrapping = PR_FALSE)
   {
     return WrapNative(cx, scope, native, nsnull, vp, aHolder, aAllowWrapping);
   }
 
+  /**
+   * Assert that no presentation of the given document is currently in
+   * layout operation during which it is not safe to execute script.
+   */
+#ifdef DEBUG
+  static void AssertLayoutSafeForScript(nsIDocument *aDocument);
+  static PRBool sIsPaintingTree;
+#else
+  static inline void AssertLayoutSafeForScript(nsIDocument *aDocument) {}
+#endif
+
 private:
 
   static PRBool InitializeEventTable();
 
   static nsresult doReparentContentWrapper(nsIContent *aChild,
                                            JSContext *cx,
                                            JSObject *aOldGlobal,
                                            JSObject *aNewGlobal,
diff --git a/content/base/src/nsContentUtils.cpp b/content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp
+++ b/content/base/src/nsContentUtils.cpp
@@ -135,16 +135,19 @@ static NS_DEFINE_CID(kXTFServiceCID, NS_
 #include "nsTPtrArray.h"
 #include "nsGUIEvent.h"
 #include "nsMutationEvent.h"
 #include "nsIMEStateManager.h"
 #include "nsContentErrors.h"
 #include "nsUnicharUtilCIID.h"
 #include "nsICaseConversion.h"
 #include "nsCompressedCharMap.h"
+#include "nsIPresShell.h"
+#include "nsPresContext.h"
+#include "nsPresShellIterator.h"
 #include "nsINativeKeyBindings.h"
 #include "nsIDOMNSUIEvent.h"
 #include "nsIDOMNSEvent.h"
 #include "nsIPrivateDOMEvent.h"
 #include "nsXULPopupManager.h"
 #include "nsIPermissionManager.h"
 #include "nsIScriptObjectPrincipal.h"
 #include "nsIRunnable.h"
@@ -183,16 +186,19 @@ static NS_DEFINE_CID(kXTFServiceCID, NS_
 #include "jsinterp.h"
 
 const char kLoadAsData[] = "loadAsData";
 
 static const char kJSStackContractID[] = "@mozilla.org/js/xpc/ContextStack;1";
 static NS_DEFINE_CID(kParserServiceCID, NS_PARSERSERVICE_CID);
 static NS_DEFINE_CID(kCParserCID, NS_PARSER_CID);
 
+#ifdef DEBUG
+PRBool nsContentUtils::sIsPaintingTree = PR_FALSE;
+#endif
 nsIDOMScriptObjectFactory *nsContentUtils::sDOMScriptObjectFactory = nsnull;
 nsIXPConnect *nsContentUtils::sXPConnect;
 nsIScriptSecurityManager *nsContentUtils::sSecurityManager;
 nsIThreadJSContextStack *nsContentUtils::sThreadJSContextStack;
 nsIParserService *nsContentUtils::sParserService = nsnull;
 nsINameSpaceManager *nsContentUtils::sNameSpaceManager;
 nsIIOService *nsContentUtils::sIOService;
 #ifdef MOZ_XTF
@@ -4211,16 +4217,37 @@ nsContentUtils::TriggerLink(nsIContent *
   }
 
   // Only pass off the click event if the script security manager says it's ok.
   if (NS_SUCCEEDED(proceed)) {
     handler->OnLinkClick(aContent, aLinkURI, aTargetSpec.get());
   }
 }
 
+#ifdef DEBUG
+/* static */
+void
+nsContentUtils::AssertLayoutSafeForScript(nsIDocument *aDocument)
+{
+  nsPresShellIterator iter(aDocument);
+  nsCOMPtr<nsIPresShell> shell;
+  while ((shell = iter.GetNextShell())) {
+    nsPresContext *presContext = shell->GetPresContext();
+    if (!sIsPaintingTree) {
+      NS_ASSERTION(presContext->LayoutPhaseCount(eLayoutPhase_Paint) == 0,
+                   "should not execute script during paint");
+    }
+    NS_ASSERTION(presContext->LayoutPhaseCount(eLayoutPhase_Reflow) == 0,
+                 "should not execute script during reflow");
+    NS_ASSERTION(presContext->LayoutPhaseCount(eLayoutPhase_FrameC) == 0,
+                 "should not execute script during frame construction");
+  }
+}
+#endif
+
 /* static */
 nsIWidget*
 nsContentUtils::GetTopLevelWidget(nsIWidget* aWidget)
 {
   if (!aWidget)
     return nsnull;
 
   return aWidget->GetTopLevelWidget();
diff --git a/content/base/src/nsDocument.h b/content/base/src/nsDocument.h
--- a/content/base/src/nsDocument.h
+++ b/content/base/src/nsDocument.h
@@ -1097,19 +1097,22 @@ protected:
                               PRBool aPersisted);
 
   // nsContentList match functions for GetElementsByClassName
   static PRBool MatchClassNames(nsIContent* aContent, PRInt32 aNamespaceID,
                                 nsIAtom* aAtom, void* aData);
 
   static void DestroyClassNameArray(void* aData);
 
-#define NS_DOCUMENT_NOTIFY_OBSERVERS(func_, params_)                  \
-  NS_OBSERVER_ARRAY_NOTIFY_OBSERVERS(mObservers, nsIDocumentObserver, \
-                                     func_, params_);
+#define NS_DOCUMENT_NOTIFY_OBSERVERS(func_, params_)                          \
+  PR_BEGIN_MACRO                                                              \
+    nsContentUtils::AssertLayoutSafeForScript(this);                          \
+    NS_OBSERVER_ARRAY_NOTIFY_OBSERVERS(mObservers, nsIDocumentObserver,       \
+                                       func_, params_);                       \
+  PR_END_MACRO
   
 #ifdef DEBUG
   void VerifyRootContentState();
 #endif
 
   nsDocument(const char* aContentType);
   virtual ~nsDocument();
 
diff --git a/content/base/src/nsNodeUtils.cpp b/content/base/src/nsNodeUtils.cpp
--- a/content/base/src/nsNodeUtils.cpp
+++ b/content/base/src/nsNodeUtils.cpp
@@ -57,35 +57,34 @@
 #include "nsBindingManager.h"
 #include "nsGenericHTMLElement.h"
 #ifdef MOZ_MEDIA
 #include "nsHTMLMediaElement.h"
 #endif // MOZ_MEDIA
 
 // This macro expects the ownerDocument of content_ to be in scope as
 // |nsIDocument* doc|
-#define IMPL_MUTATION_NOTIFICATION(func_, content_, params_)      \
-  PR_BEGIN_MACRO                                                  \
-  nsINode* node = content_;                                       \
-  NS_ASSERTION(node->GetOwnerDoc() == doc, "Bogus document");     \
-  if (doc) {                                                      \
-    static_cast<nsIMutationObserver*>(doc->BindingManager())->    \
-      func_ params_;                                              \
-  }                                                               \
-  do {                                                            \
-    nsINode::nsSlots* slots = node->GetExistingSlots();           \
-    if (slots && !slots->mMutationObservers.IsEmpty()) {          \
-      /* No need to explicitly notify the first observer first    \
-         since that'll happen anyway. */                          \
-      NS_OBSERVER_ARRAY_NOTIFY_OBSERVERS(                         \
-        slots->mMutationObservers, nsIMutationObserver,           \
-        func_, params_);                                          \
-    }                                                             \
-    node = node->GetNodeParent();                                 \
-  } while (node);                                                 \
+#define IMPL_MUTATION_NOTIFICATION(func_, content_, params_)                    \
+  PR_BEGIN_MACRO                                                                \
+  nsContentUtils::AssertLayoutSafeForScript(content_->GetOwnerDoc());           \
+  nsINode* node = content_;                                                     \
+  NS_ASSERTION(node->GetOwnerDoc() == doc, "Bogus document");                   \
+  if (doc) {                                                                    \
+    static_cast<nsIMutationObserver*>(doc->BindingManager())-> func_ params_;   \
+  }                                                                             \
+  do {                                                                          \
+    nsINode::nsSlots* slots = node->GetExistingSlots();                         \
+    if (slots && !slots->mMutationObservers.IsEmpty()) {                        \
+      /* No need to explicitly notify the first observer first                  \
+         since that'll happen anyway. */                                        \
+      NS_OBSERVER_ARRAY_NOTIFY_OBSERVERS(                                       \
+        slots->mMutationObservers, nsIMutationObserver, func_, params_);        \
+    }                                                                           \
+    node = node->GetNodeParent();                                               \
+  } while (node);                                                               \
   PR_END_MACRO
 
 
 void
 nsNodeUtils::CharacterDataWillChange(nsIContent* aContent,
                                      CharacterDataChangeInfo* aInfo)
 {
   nsIDocument* doc = aContent->GetOwnerDoc();
diff --git a/content/events/src/nsEventDispatcher.cpp b/content/events/src/nsEventDispatcher.cpp
--- a/content/events/src/nsEventDispatcher.cpp
+++ b/content/events/src/nsEventDispatcher.cpp
@@ -437,16 +437,18 @@ nsEventDispatcher::Dispatch(nsISupports*
                             nsPresContext* aPresContext,
                             nsEvent* aEvent,
                             nsIDOMEvent* aDOMEvent,
                             nsEventStatus* aEventStatus,
                             nsDispatchingCallback* aCallback,
                             nsCOMArray<nsPIDOMEventTarget>* aTargets)
 {
   NS_ASSERTION(aEvent, "Trying to dispatch without nsEvent!");
+  if (aPresContext) // XXX And otherwise?
+    nsContentUtils::AssertLayoutSafeForScript(aPresContext->Document());
   NS_ENSURE_TRUE(!NS_IS_EVENT_IN_DISPATCH(aEvent),
                  NS_ERROR_ILLEGAL_VALUE);
   NS_ASSERTION(!aTargets || !aEvent->message, "Wrong parameters!");
 
   if (aEvent->flags & NS_EVENT_FLAG_ONLY_CHROME_DISPATCH) {
     nsCOMPtr<nsINode> node = do_QueryInterface(aTarget);
     if (!node) {
       nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(aTarget);
diff --git a/dom/base/nsJSEnvironment.cpp b/dom/base/nsJSEnvironment.cpp
--- a/dom/base/nsJSEnvironment.cpp
+++ b/dom/base/nsJSEnvironment.cpp
@@ -3496,28 +3496,39 @@ PRBool
 nsJSContext::IsContextInitialized()
 {
   return mIsInitialized;
 }
 
 void
 nsJSContext::FinalizeContext()
 {
-  ;
 }
 
 void
 nsJSContext::GC()
 {
   FireGCTimer(PR_FALSE);
 }
 
 void
 nsJSContext::ScriptEvaluated(PRBool aTerminated)
 {
+#ifdef DEBUG
+  {
+    nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(GetGlobalObject());
+    if (win) {
+      nsCOMPtr<nsIDocument> doc = do_QueryInterface(win->GetExtantDocument());
+      if (doc) {
+        nsContentUtils::AssertLayoutSafeForScript(doc);
+      }
+    }
+  }
+#endif
+
   if (aTerminated && mTerminations) {
     // Make sure to null out mTerminations before doing anything that
     // might cause new termination funcs to be added!
     nsJSContext::TerminationFuncClosure* start = mTerminations;
     mTerminations = nsnull;
 
     for (nsJSContext::TerminationFuncClosure* cur = start;
          cur;
diff --git a/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp b/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp
--- a/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp
+++ b/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp
@@ -102,21 +102,24 @@
 #include "imgILoader.h"
 #include "nsINodeInfo.h"
 #include "nsContentUtils.h"
 #include "nsLayoutUtils.h"
 #include "nsIScrollableFrame.h"
 #include "nsEventDispatcher.h"
 #include "nsDisplayList.h"
 #include "nsTreeBoxObject.h"
+#include "mozilla/AutoRestore.h"
 
 #ifdef IBMBIDI
 #include "nsBidiPresUtils.h"
 #endif
 
+using mozilla::AutoRestore;
+
 static NS_DEFINE_CID(kWidgetCID, NS_CHILD_CID);
 
 // Enumeration function that cancels all the image requests in our cache
 static PLDHashOperator
 CancelImageRequest(const nsAString& aKey,
                    nsTreeImageCacheEntry aEntry, void* aData)
 {
   aEntry.request->CancelAndForgetObserver(NS_BINDING_ABORTED);
@@ -2833,16 +2836,21 @@ nsTreeBodyFrame::BuildDisplayList(nsDisp
   return aLists.Content()->AppendNewToTop(new (aBuilder)
       nsDisplayGeneric(this, ::PaintTreeBody, "XULTreeBody"));
 }
 
 void
 nsTreeBodyFrame::PaintTreeBody(nsIRenderingContext& aRenderingContext,
                                const nsRect& aDirtyRect, nsPoint aPt)
 {
+#ifdef DEBUG
+  AutoRestore<PRBool> savePainting(nsContentUtils::sIsPaintingTree);
+  nsContentUtils::sIsPaintingTree = PR_TRUE;
+#endif
+
   // Update our available height and our page count.
   CalcInnerBox();
   aRenderingContext.PushState();
   aRenderingContext.SetClipRect(mInnerBox + aPt, nsClipCombine_kIntersect);
   PRInt32 oldPageCount = mPageLength;
   if (!mHasFixedRowCount)
     mPageLength = mInnerBox.height/mRowHeight;
 
