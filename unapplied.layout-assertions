From: L. David Baron <dbaron@dbaron.org>

Add assertions that we don't execute script, fire events, or mutate the document during frame construction, reflow, or painting.  (Bug 335053, Bug 335054)

diff --git a/content/base/public/nsContentUtils.h b/content/base/public/nsContentUtils.h
--- a/content/base/public/nsContentUtils.h
+++ b/content/base/public/nsContentUtils.h
@@ -1711,16 +1711,27 @@ public:
   static void RemoveNewlines(nsString &aString);
 
   /**
    * Convert Windows and Mac platform linebreaks to \n.
    * @param aString the string to convert the newlines inside [in/out]
    */
   static void PlatformToDOMLineBreaks(nsString &aString);
 
+  /**
+   * Assert that no presentation of the given document is currently in
+   * layout operation during which it is not safe to execute script.
+   */
+#ifdef DEBUG
+  static void AssertLayoutSafeForScript(nsIDocument *aDocument);
+  static bool sIsPaintingTree;
+#else
+  static inline void AssertLayoutSafeForScript(nsIDocument *aDocument) {}
+#endif
+
   static bool IsHandlingKeyBoardEvent()
   {
     return sIsHandlingKeyBoardEvent;
   }
 
   static void SetIsHandlingKeyBoardEvent(bool aHandling)
   {
     sIsHandlingKeyBoardEvent = aHandling;
diff --git a/content/base/src/nsContentUtils.cpp b/content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp
+++ b/content/base/src/nsContentUtils.cpp
@@ -84,16 +84,18 @@
 #include "nsEventListenerManager.h"
 #include "nsAttrName.h"
 #include "nsIDOMUserDataHandler.h"
 #include "nsContentCreatorFunctions.h"
 #include "nsMutationEvent.h"
 #include "nsIMEStateManager.h"
 #include "nsError.h"
 #include "nsUnicharUtilCIID.h"
+#include "nsIPresShell.h"
+#include "nsPresContext.h"
 #include "nsINativeKeyBindings.h"
 #include "nsXULPopupManager.h"
 #include "nsIPermissionManager.h"
 #include "nsIScriptObjectPrincipal.h"
 #include "nsNullPrincipal.h"
 #include "nsIRunnable.h"
 #include "nsDOMJSUtils.h"
 #include "nsGenericHTMLElement.h"
@@ -181,16 +183,19 @@ class imgLoader;
 
 using namespace mozilla::dom;
 using namespace mozilla::layers;
 using namespace mozilla::widget;
 using namespace mozilla;
 
 const char kLoadAsData[] = "loadAsData";
 
+#ifdef DEBUG
+bool nsContentUtils::sIsPaintingTree = false;
+#endif
 nsIDOMScriptObjectFactory *nsContentUtils::sDOMScriptObjectFactory = nullptr;
 nsIXPConnect *nsContentUtils::sXPConnect;
 nsIScriptSecurityManager *nsContentUtils::sSecurityManager;
 nsIThreadJSContextStack *nsContentUtils::sThreadJSContextStack;
 nsIParserService *nsContentUtils::sParserService = nullptr;
 nsINameSpaceManager *nsContentUtils::sNameSpaceManager;
 nsIIOService *nsContentUtils::sIOService;
 imgLoader *nsContentUtils::sImgLoader;
@@ -4699,16 +4704,36 @@ nsContentUtils::GetLinkLocation(Element*
   if (hrefURI) {
     nsAutoCString specUTF8;
     nsresult rv = hrefURI->GetSpec(specUTF8);
     if (NS_SUCCEEDED(rv))
       CopyUTF8toUTF16(specUTF8, aLocationString);
   }
 }
 
+#ifdef DEBUG
+/* static */
+void
+nsContentUtils::AssertLayoutSafeForScript(nsIDocument *aDocument)
+{
+  nsCOMPtr<nsIPresShell> shell = aDocument->GetPrimaryShell();
+  if (shell) {
+    nsPresContext *presContext = shell->GetPresContext();
+    if (!sIsPaintingTree) {
+      NS_ASSERTION(presContext->LayoutPhaseCount(eLayoutPhase_Paint) == 0,
+                   "should not execute script during paint");
+    }
+    NS_ASSERTION(presContext->LayoutPhaseCount(eLayoutPhase_Reflow) == 0,
+                 "should not execute script during reflow");
+    NS_ASSERTION(presContext->LayoutPhaseCount(eLayoutPhase_FrameC) == 0,
+                 "should not execute script during frame construction");
+  }
+}
+#endif
+
 /* static */
 nsIWidget*
 nsContentUtils::GetTopLevelWidget(nsIWidget* aWidget)
 {
   if (!aWidget)
     return nullptr;
 
   return aWidget->GetTopLevelWidget();
diff --git a/content/base/src/nsDocument.h b/content/base/src/nsDocument.h
--- a/content/base/src/nsDocument.h
+++ b/content/base/src/nsDocument.h
@@ -1115,20 +1115,23 @@ protected:
                               const nsAString& aType,
                               bool aPersisted);
 
   virtual nsPIDOMWindow *GetWindowInternal() const;
   virtual nsPIDOMWindow *GetInnerWindowInternal();
   virtual nsIScriptGlobalObject* GetScriptHandlingObjectInternal() const;
   virtual bool InternalAllowXULXBL();
 
-#define NS_DOCUMENT_NOTIFY_OBSERVERS(func_, params_)                        \
-  NS_OBSERVER_ARRAY_NOTIFY_XPCOM_OBSERVERS(mObservers, nsIDocumentObserver, \
-                                           func_, params_);
-  
+#define NS_DOCUMENT_NOTIFY_OBSERVERS(func_, params_)                          \
+  PR_BEGIN_MACRO                                                              \
+    nsContentUtils::AssertLayoutSafeForScript(this);                          \
+    NS_OBSERVER_ARRAY_NOTIFY_XPCOM_OBSERVERS(mObservers, nsIDocumentObserver, \
+                                             func_, params_);                 \
+  PR_END_MACRO
+
 #ifdef DEBUG
   void VerifyRootContentState();
 #endif
 
   nsDocument(const char* aContentType);
   virtual ~nsDocument();
 
   void EnsureOnloadBlocker();
diff --git a/content/base/src/nsNodeUtils.cpp b/content/base/src/nsNodeUtils.cpp
--- a/content/base/src/nsNodeUtils.cpp
+++ b/content/base/src/nsNodeUtils.cpp
@@ -38,16 +38,17 @@ using namespace mozilla::dom;
 // |nsIDocument* doc|
 #define IMPL_MUTATION_NOTIFICATION(func_, content_, params_)      \
   PR_BEGIN_MACRO                                                  \
   bool needsEnterLeave = doc->MayHaveDOMMutationObservers();      \
   if (needsEnterLeave) {                                          \
     nsDOMMutationObserver::EnterMutationHandling();               \
   }                                                               \
   nsINode* node = content_;                                       \
+  nsContentUtils::AssertLayoutSafeForScript(node->OwnerDoc());    \
   NS_ASSERTION(node->OwnerDoc() == doc, "Bogus document");        \
   if (doc) {                                                      \
     doc->BindingManager()->func_ params_;                         \
   }                                                               \
   do {                                                            \
     nsINode::nsSlots* slots = node->GetExistingSlots();           \
     if (slots && !slots->mMutationObservers.IsEmpty()) {          \
       /* No need to explicitly notify the first observer first    \
diff --git a/content/events/src/nsEventDispatcher.cpp b/content/events/src/nsEventDispatcher.cpp
--- a/content/events/src/nsEventDispatcher.cpp
+++ b/content/events/src/nsEventDispatcher.cpp
@@ -468,16 +468,18 @@ nsEventDispatcher::Dispatch(nsISupports*
                             nsEvent* aEvent,
                             nsIDOMEvent* aDOMEvent,
                             nsEventStatus* aEventStatus,
                             nsDispatchingCallback* aCallback,
                             nsCOMArray<nsIDOMEventTarget>* aTargets)
 {
   SAMPLE_LABEL("nsEventDispatcher", "Dispatch");
   NS_ASSERTION(aEvent, "Trying to dispatch without nsEvent!");
+  if (aPresContext) // XXX And otherwise?
+    nsContentUtils::AssertLayoutSafeForScript(aPresContext->Document());
   NS_ENSURE_TRUE(!aEvent->mFlags.mIsBeingDispatched,
                  NS_ERROR_ILLEGAL_VALUE);
   NS_ASSERTION(!aTargets || !aEvent->message, "Wrong parameters!");
 
   // If we're dispatching an already created DOMEvent object, make
   // sure it is initialized!
   // If aTargets is non-null, the event isn't going to be dispatched.
   NS_ENSURE_TRUE(aEvent->message || !aDOMEvent || aTargets,
diff --git a/dom/base/nsJSEnvironment.cpp b/dom/base/nsJSEnvironment.cpp
--- a/dom/base/nsJSEnvironment.cpp
+++ b/dom/base/nsJSEnvironment.cpp
@@ -2527,16 +2527,28 @@ bool
 nsJSContext::IsContextInitialized()
 {
   return mIsInitialized;
 }
 
 void
 nsJSContext::ScriptEvaluated(bool aTerminated)
 {
+#ifdef DEBUG
+  {
+    nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(GetGlobalObject());
+    if (win) {
+      nsCOMPtr<nsIDocument> doc = do_QueryInterface(win->GetExtantDocument());
+      if (doc) {
+        nsContentUtils::AssertLayoutSafeForScript(doc);
+      }
+    }
+  }
+#endif
+
   if (aTerminated && mTerminations) {
     // Make sure to null out mTerminations before doing anything that
     // might cause new termination funcs to be added!
     nsJSContext::TerminationFuncClosure* start = mTerminations;
     mTerminations = nullptr;
 
     for (nsJSContext::TerminationFuncClosure* cur = start;
          cur;
diff --git a/layout/xul/tree/nsTreeBodyFrame.cpp b/layout/xul/tree/nsTreeBodyFrame.cpp
--- a/layout/xul/tree/nsTreeBodyFrame.cpp
+++ b/layout/xul/tree/nsTreeBodyFrame.cpp
@@ -57,16 +57,17 @@
 #include "nsContentUtils.h"
 #include "nsLayoutUtils.h"
 #include "nsIScrollableFrame.h"
 #include "nsEventDispatcher.h"
 #include "nsDisplayList.h"
 #include "nsTreeBoxObject.h"
 #include "nsRenderingContext.h"
 #include "nsIScriptableRegion.h"
+#include "mozilla/AutoRestore.h"
 #include <algorithm>
 
 #ifdef ACCESSIBILITY
 #include "nsAccessibilityService.h"
 #endif
 #ifdef IBMBIDI
 #include "nsBidiUtils.h"
 #endif
@@ -2794,16 +2795,21 @@ nsTreeBodyFrame::BuildDisplayList(nsDisp
     nsDisplayGeneric(aBuilder, this, ::PaintTreeBody, "XULTreeBody",
                      nsDisplayItem::TYPE_XUL_TREE_BODY));
 }
 
 void
 nsTreeBodyFrame::PaintTreeBody(nsRenderingContext& aRenderingContext,
                                const nsRect& aDirtyRect, nsPoint aPt)
 {
+#ifdef DEBUG
+  AutoRestore<bool> savePainting(nsContentUtils::sIsPaintingTree);
+  nsContentUtils::sIsPaintingTree = true;
+#endif
+
   // Update our available height and our page count.
   CalcInnerBox();
   aRenderingContext.PushState();
   aRenderingContext.IntersectClip(mInnerBox + aPt);
   int32_t oldPageCount = mPageLength;
   if (!mHasFixedRowCount)
     mPageLength = mInnerBox.height/mRowHeight;
 
