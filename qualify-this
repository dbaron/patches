From: Eli Friedman <sharparrow1@yahoo.com>

Consistently qualify access to dependent base classes to fix compilation errors on correct C++ compilers (such as clang).  (Bug 573210)  r=dbaron

diff --git a/xpcom/base/nsAutoRef.h b/xpcom/base/nsAutoRef.h
--- a/xpcom/base/nsAutoRef.h
+++ b/xpcom/base/nsAutoRef.h
@@ -296,17 +296,17 @@ public:
     // reference without interfering with the reference to copy.
     explicit nsCountedRef(RawRef aRefToCopy)
         : BaseClass(aRefToCopy)
     {
         SafeAddRef();
     }
     ThisClass& operator=(RawRef aRefToCopy)
     {
-        own(aRefToCopy);
+        this->own(aRefToCopy);
         SafeAddRef();
         return *this;
     }
 
     // Construction and assignment from an nsReturnRef function return value,
     // which expects to give up ownership, transfers ownership.
     explicit nsCountedRef(const nsReturningRef<T>& aReturning)
         : BaseClass(aReturning)
@@ -318,17 +318,17 @@ public:
         return *this;
     }
 
 protected:
     // Increase the reference count if there is a resource.
     void SafeAddRef()
     {
         if (this->HaveResource())
-            AddRef(this->get());
+            this->AddRef(this->get());
     }
 };
 
 /**
  * template <class T> class nsReturnRef
  *
  * A type for function return values that hold a reference to a resource that
  * must be released.  See also |nsAutoRef<T>::out()|.
@@ -685,13 +685,13 @@ protected:
         LocalSimpleRef ref(aRefToRelease);
         SimpleRef::operator=(ref);
     }
 
     // Release a resource if there is one.
     void SafeRelease()
     {
         if (this->HaveResource())
-            Release(this->get());
+            this->Release(this->get());
     }
 };
 
 #endif // !defined(nsAutoRef_h_)
diff --git a/xpcom/glue/nsBaseHashtable.h b/xpcom/glue/nsBaseHashtable.h
--- a/xpcom/glue/nsBaseHashtable.h
+++ b/xpcom/glue/nsBaseHashtable.h
@@ -118,17 +118,17 @@ public:
    * @param pData data associated with this key will be placed at this
    *   pointer.  If you only need to check if the key exists, pData
    *   may be null.
    * @return PR_TRUE if the key exists. If key does not exist, pData is not
    *   modified.
    */
   PRBool Get(KeyType aKey, UserDataType* pData NS_OUTPARAM) const
   {
-    EntryType* ent = GetEntry(aKey);
+    EntryType* ent = this->GetEntry(aKey);
 
     if (!ent)
       return PR_FALSE;
 
     if (pData)
       *pData = ent->mData;
 
     return PR_TRUE;
@@ -140,46 +140,46 @@ public:
    *
    * @param aKey the key to retrieve
    * @return The found value, or NULL if no entry was found with the given key.
    * @note If NULL values are stored in the table, it is not possible to
    *       distinguish between a NULL value and a missing entry.
    */
   UserDataType Get(KeyType aKey) const
   {
-    EntryType* ent = GetEntry(aKey);
+    EntryType* ent = this->GetEntry(aKey);
     if (!ent)
       return NULL;
 
     return ent->mData;
   }
 
   /**
    * put a new value for the associated key
    * @param aKey the key to put
    * @param aData the new data
    * @return always PR_TRUE, unless memory allocation failed
    */
   PRBool Put(KeyType aKey, UserDataType aData)
   {
-    EntryType* ent = PutEntry(aKey);
+    EntryType* ent = this->PutEntry(aKey);
 
     if (!ent)
       return PR_FALSE;
 
     ent->mData = aData;
 
     return PR_TRUE;
   }
 
   /**
    * remove the data for the associated key
    * @param aKey the key to remove from the hashtable
    */
-  void Remove(KeyType aKey) { RemoveEntry(aKey); }
+  void Remove(KeyType aKey) { this->RemoveEntry(aKey); }
 
   /**
    * function type provided by the application for enumeration.
    * @param aKey the key being enumerated
    * @param aData data being enumerated
    * @parm userArg passed unchanged from Enumerate
    * @return either
    *   @link PLDHashOperator::PL_DHASH_NEXT PL_DHASH_NEXT @endlink or
diff --git a/xpcom/glue/nsClassHashtable.h b/xpcom/glue/nsClassHashtable.h
--- a/xpcom/glue/nsClassHashtable.h
+++ b/xpcom/glue/nsClassHashtable.h
@@ -52,16 +52,17 @@
  */
 template<class KeyClass,class T>
 class nsClassHashtable :
   public nsBaseHashtable< KeyClass, nsAutoPtr<T>, T* >
 {
 public:
   typedef typename KeyClass::KeyType KeyType;
   typedef T* UserDataType;
+  typedef nsBaseHashtable< KeyClass, nsAutoPtr<T>, T* > base_type;
 
   /**
    * @copydoc nsBaseHashtable::Get
    * @param pData if the key doesn't exist, pData will be set to nsnull.
    */
   PRBool Get(KeyType aKey, UserDataType* pData) const;
 };
 
@@ -75,16 +76,17 @@ public:
  */
 template<class KeyClass,class T>
 class nsClassHashtableMT :
   public nsBaseHashtableMT< KeyClass, nsAutoPtr<T>, T* >
 {
 public:
   typedef typename KeyClass::KeyType KeyType;
   typedef T* UserDataType;
+  typedef nsBaseHashtableMT< KeyClass, nsAutoPtr<T>, T* > base_type;
 
   /**
    * @copydoc nsBaseHashtable::Get
    * @param pData if the key doesn't exist, pData will be set to nsnull.
    */
   PRBool Get(KeyType aKey, UserDataType* pData) const;
 };
 
@@ -92,18 +94,17 @@ public:
 //
 // nsClassHashtable definitions
 //
 
 template<class KeyClass,class T>
 PRBool
 nsClassHashtable<KeyClass,T>::Get(KeyType aKey, T** retVal) const
 {
-  typename nsBaseHashtable<KeyClass,nsAutoPtr<T>,T*>::EntryType* ent =
-    GetEntry(aKey);
+  typename base_type::EntryType* ent = this->GetEntry(aKey);
 
   if (ent)
   {
     if (retVal)
       *retVal = ent->mData;
 
     return PR_TRUE;
   }
@@ -120,18 +121,17 @@ nsClassHashtable<KeyClass,T>::Get(KeyTyp
 //
 
 template<class KeyClass,class T>
 PRBool
 nsClassHashtableMT<KeyClass,T>::Get(KeyType aKey, T** retVal) const
 {
   PR_Lock(this->mLock);
 
-  typename nsBaseHashtableMT<KeyClass,nsAutoPtr<T>,T*>::EntryType* ent =
-    GetEntry(aKey);
+  typename base_type::EntryType* ent = this->GetEntry(aKey);
 
   if (ent)
   {
     if (retVal)
       *retVal = ent->mData;
 
     PR_Unlock(this->mLock);
 
diff --git a/xpcom/glue/nsInterfaceHashtable.h b/xpcom/glue/nsInterfaceHashtable.h
--- a/xpcom/glue/nsInterfaceHashtable.h
+++ b/xpcom/glue/nsInterfaceHashtable.h
@@ -52,16 +52,18 @@
  */
 template<class KeyClass,class Interface>
 class nsInterfaceHashtable :
   public nsBaseHashtable< KeyClass, nsCOMPtr<Interface> , Interface* >
 {
 public:
   typedef typename KeyClass::KeyType KeyType;
   typedef Interface* UserDataType;
+  typedef nsBaseHashtable< KeyClass, nsCOMPtr<Interface> , Interface* >
+          base_type;
 
   /**
    * @copydoc nsBaseHashtable::Get
    * @param pData This is an XPCOM getter, so pData is already_addrefed.
    *   If the key doesn't exist, pData will be set to nsnull.
    */
   PRBool Get(KeyType aKey, UserDataType* pData NS_OUTPARAM) const;
 
@@ -82,16 +84,18 @@ public:
  */
 template<class KeyClass,class Interface>
 class nsInterfaceHashtableMT :
   public nsBaseHashtableMT< KeyClass, nsCOMPtr<Interface> , Interface* >
 {
 public:
   typedef typename KeyClass::KeyType KeyType;
   typedef Interface* UserDataType;
+  typedef nsBaseHashtableMT< KeyClass, nsCOMPtr<Interface> , Interface* >
+          base_type;
 
   /**
    * @copydoc nsBaseHashtable::Get
    * @param pData This is an XPCOM getter, so pData is already_addrefed.
    *   If the key doesn't exist, pData will be set to nsnull.
    */
   PRBool Get(KeyType aKey, UserDataType* pData NS_OUTPARAM) const;
 
@@ -105,18 +109,17 @@ public:
 // nsInterfaceHashtable definitions
 //
 
 template<class KeyClass,class Interface>
 PRBool
 nsInterfaceHashtable<KeyClass,Interface>::Get
   (KeyType aKey, UserDataType* pInterface) const
 {
-  typename nsBaseHashtable<KeyClass, nsCOMPtr<Interface>, Interface*>::EntryType* ent =
-    GetEntry(aKey);
+  typename base_type::EntryType* ent = this->GetEntry(aKey);
 
   if (ent)
   {
     if (pInterface)
     {
       *pInterface = ent->mData;
 
       NS_IF_ADDREF(*pInterface);
@@ -133,18 +136,17 @@ nsInterfaceHashtable<KeyClass,Interface>
   return PR_FALSE;
 }
 
 template<class KeyClass,class Interface>
 Interface*
 nsInterfaceHashtable<KeyClass,Interface>::GetWeak
   (KeyType aKey, PRBool* aFound) const
 {
-  typename nsBaseHashtable<KeyClass, nsCOMPtr<Interface>, Interface*>::EntryType* ent =
-    GetEntry(aKey);
+  typename base_type::EntryType* ent = this->GetEntry(aKey);
 
   if (ent)
   {
     if (aFound)
       *aFound = PR_TRUE;
 
     return ent->mData;
   }
@@ -161,18 +163,17 @@ nsInterfaceHashtable<KeyClass,Interface>
 
 template<class KeyClass,class Interface>
 PRBool
 nsInterfaceHashtableMT<KeyClass,Interface>::Get
   (KeyType aKey, UserDataType* pInterface) const
 {
   PR_Lock(this->mLock);
 
-  typename nsBaseHashtableMT<KeyClass, nsCOMPtr<Interface>, Interface*>::EntryType* ent =
-    GetEntry(aKey);
+  typename base_type::EntryType* ent = this->GetEntry(aKey);
 
   if (ent)
   {
     if (pInterface)
     {
       *pInterface = ent->mData;
 
       NS_IF_ADDREF(*pInterface);
diff --git a/xpcom/glue/nsRefPtrHashtable.h b/xpcom/glue/nsRefPtrHashtable.h
--- a/xpcom/glue/nsRefPtrHashtable.h
+++ b/xpcom/glue/nsRefPtrHashtable.h
@@ -53,16 +53,17 @@
  */
 template<class KeyClass, class RefPtr>
 class nsRefPtrHashtable :
   public nsBaseHashtable< KeyClass, nsRefPtr<RefPtr> , RefPtr* >
 {
 public:
   typedef typename KeyClass::KeyType KeyType;
   typedef RefPtr* UserDataType;
+  typedef nsBaseHashtable< KeyClass, nsRefPtr<RefPtr> , RefPtr* > base_type;
 
   /**
    * @copydoc nsBaseHashtable::Get
    * @param pData This is an XPCOM getter, so pData is already_addrefed.
    *   If the key doesn't exist, pData will be set to nsnull.
    */
   PRBool Get(KeyType aKey, UserDataType* pData) const;
 
@@ -83,16 +84,17 @@ public:
  */
 template<class KeyClass, class RefPtr>
 class nsRefPtrHashtableMT :
   public nsBaseHashtableMT< KeyClass, nsRefPtr<RefPtr> , RefPtr* >
 {
 public:
   typedef typename KeyClass::KeyType KeyType;
   typedef RefPtr* UserDataType;
+  typedef nsBaseHashtableMT< KeyClass, nsRefPtr<RefPtr> , RefPtr* > base_type;
 
   /**
    * @copydoc nsBaseHashtable::Get
    * @param pData This is an XPCOM getter, so pData is already_addrefed.
    *   If the key doesn't exist, pData will be set to nsnull.
    */
   PRBool Get(KeyType aKey, UserDataType* pData) const;
 
@@ -106,18 +108,17 @@ public:
 // nsRefPtrHashtable definitions
 //
 
 template<class KeyClass, class RefPtr>
 PRBool
 nsRefPtrHashtable<KeyClass,RefPtr>::Get
   (KeyType aKey, UserDataType* pRefPtr) const
 {
-  typename nsBaseHashtable<KeyClass, nsRefPtr<RefPtr>, RefPtr*>::EntryType* ent =
-    GetEntry(aKey);
+  typename base_type::EntryType* ent = this->GetEntry(aKey);
 
   if (ent)
   {
     if (pRefPtr)
     {
       *pRefPtr = ent->mData;
 
       NS_IF_ADDREF(*pRefPtr);
@@ -134,18 +135,17 @@ nsRefPtrHashtable<KeyClass,RefPtr>::Get
   return PR_FALSE;
 }
 
 template<class KeyClass, class RefPtr>
 RefPtr*
 nsRefPtrHashtable<KeyClass,RefPtr>::GetWeak
   (KeyType aKey, PRBool* aFound) const
 {
-  typename nsBaseHashtable<KeyClass, nsRefPtr<RefPtr>, RefPtr*>::EntryType* ent =
-    GetEntry(aKey);
+  typename base_type::EntryType* ent = this->GetEntry(aKey);
 
   if (ent)
   {
     if (aFound)
       *aFound = PR_TRUE;
 
     return ent->mData;
   }
@@ -162,18 +162,17 @@ nsRefPtrHashtable<KeyClass,RefPtr>::GetW
 
 template<class KeyClass, class RefPtr>
 PRBool
 nsRefPtrHashtableMT<KeyClass,RefPtr>::Get
   (KeyType aKey, UserDataType* pRefPtr) const
 {
   PR_Lock(this->mLock);
 
-  typename nsBaseHashtableMT<KeyClass, nsRefPtr<RefPtr>, RefPtr*>::EntryType* ent =
-    GetEntry(aKey);
+  typename base_type::EntryType* ent = this->GetEntry(aKey);
 
   if (ent)
   {
     if (pRefPtr)
     {
       *pRefPtr = ent->mData;
 
       NS_IF_ADDREF(*pRefPtr);
diff --git a/xpcom/glue/nsTPtrArray.h b/xpcom/glue/nsTPtrArray.h
--- a/xpcom/glue/nsTPtrArray.h
+++ b/xpcom/glue/nsTPtrArray.h
@@ -59,23 +59,23 @@ class nsTPtrArray : public nsTArray<E*> 
     //
     // Initialization methods
     //
 
     nsTPtrArray() {}
 
     // Initialize this array and pre-allocate some number of elements.
     explicit nsTPtrArray(size_type capacity) {
-      SetCapacity(capacity);
+      this->SetCapacity(capacity);
     }
     
     // The array's copy-constructor performs a 'deep' copy of the given array.
     // @param other  The array object to copy.
     nsTPtrArray(const self_type& other) {
-      AppendElements(other);
+      this->AppendElements(other);
     }
 
     //
     // Accessor methods
     //
 
     // Forward SafeElementAt to avoid shadowing (and warnings thereof)
     elem_type& SafeElementAt(index_type i, elem_type& def) {
