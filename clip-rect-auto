Distinguish clip:rect(auto,auto,auto,auto) from clip:auto as the spec requires.  (Bug 372063)  r+sr=bzbarsky

diff --git a/layout/reftests/box-properties/clip-auto-ref.html b/layout/reftests/box-properties/clip-auto-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/box-properties/clip-auto-ref.html
@@ -0,0 +1,4 @@
+<!DOCTYPE HTML>
+<title>test for 'clip: auto'</title>
+<div style="position: absolute; top: 0px; left: 0px; width: 300px; height: 300px; background: blue">
+</div>
diff --git a/layout/reftests/box-properties/clip-auto.html b/layout/reftests/box-properties/clip-auto.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/box-properties/clip-auto.html
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<title>test for 'clip: auto'</title>
+<div style="position: absolute; top: 100px; left: 100px; width: 100px; height: 100px; clip: auto">
+  <div style="width: 300px; height: 300px; margin: -100px; background: blue">
+  </div>
+</div>
diff --git a/layout/reftests/box-properties/clip-rect-auto-ref.html b/layout/reftests/box-properties/clip-rect-auto-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/box-properties/clip-rect-auto-ref.html
@@ -0,0 +1,4 @@
+<!DOCTYPE HTML>
+<title>test for 'clip: auto'</title>
+<div style="position: absolute; top: 100px; left: 100px; width: 100px; height: 100px; background: blue">
+</div>
diff --git a/layout/reftests/box-properties/clip-rect-auto.html b/layout/reftests/box-properties/clip-rect-auto.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/box-properties/clip-rect-auto.html
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<title>test for 'clip: auto'</title>
+<div style="position: absolute; top: 100px; left: 100px; width: 100px; height: 100px; clip: rect(auto,auto,auto,auto)">
+  <div style="width: 300px; height: 300px; margin: -100px; background: blue">
+  </div>
+</div>
diff --git a/layout/reftests/box-properties/reftest.list b/layout/reftests/box-properties/reftest.list
--- a/layout/reftests/box-properties/reftest.list
+++ b/layout/reftests/box-properties/reftest.list
@@ -16,8 +16,10 @@
 == box-sizing-2.html box-sizing-2-ref.html
 == box-sizing-3.html box-sizing-1-ref.html
 == box-sizing-4.html box-sizing-4-ref.html
 == abspos-non-replaced-width-offset-margin.html abspos-non-replaced-width-offset-margin-ref.html
 == abspos-replaced-width-offset-margin.html abspos-replaced-width-offset-margin-ref.html
 == CSS21-t100303.xhtml CSS21-t100303-ref.xhtml
 == CSS21-t100303-simple.xhtml CSS21-t100303-ref.xhtml
 == CSS21-t100801-vertical-align.xhtml CSS21-t100801-vertical-align-ref.xhtml
+== clip-auto.html clip-auto-ref.html
+== clip-rect-auto.html clip-rect-auto-ref.html
diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -163,25 +163,28 @@ PRBool nsCSSDeclaration::AppendValueToSt
   if (storage) {
     switch (nsCSSProps::kTypeTable[aProperty]) {
       case eCSSType_Value: {
         const nsCSSValue *val = static_cast<const nsCSSValue*>(storage);
         AppendCSSValueToString(aProperty, *val, aResult);
       } break;
       case eCSSType_Rect: {
         const nsCSSRect *rect = static_cast<const nsCSSRect*>(storage);
-        if (rect->mTop.GetUnit() == eCSSUnit_Inherit ||
-            rect->mTop.GetUnit() == eCSSUnit_Initial) {
-          NS_ASSERTION(rect->mRight.GetUnit() == rect->mTop.GetUnit(),
-                       "Top inherit or initial, right isn't.  Fix the parser!");
-          NS_ASSERTION(rect->mBottom.GetUnit() == rect->mTop.GetUnit(),
-                       "Top inherit or initial, bottom isn't.  Fix the parser!");
-          NS_ASSERTION(rect->mLeft.GetUnit() == rect->mTop.GetUnit(),
-                       "Top inherit or initial, left isn't.  Fix the parser!");
-          AppendCSSValueToString(aProperty, rect->mTop, aResult);
+        const nsCSSUnit topUnit = rect->mTop.GetUnit();
+        if (topUnit == eCSSUnit_Inherit ||
+            topUnit == eCSSUnit_Initial ||
+            topUnit == eCSSUnit_RectIsAuto) {
+          NS_ASSERTION(rect->mRight.GetUnit() == topUnit &&
+                       rect->mBottom.GetUnit() == topUnit &&
+                       rect->mLeft.GetUnit() == topUnit,
+                       "parser should make all sides have the same unit");
+          if (topUnit == eCSSUnit_RectIsAuto)
+            aResult.AppendLiteral("auto");
+          else
+            AppendCSSValueToString(aProperty, rect->mTop, aResult);
         } else {
           aResult.AppendLiteral("rect(");
           AppendCSSValueToString(aProperty, rect->mTop, aResult);
           NS_NAMED_LITERAL_STRING(comma, ", ");
           aResult.Append(comma);
           AppendCSSValueToString(aProperty, rect->mRight, aResult);
           aResult.Append(comma);
           AppendCSSValueToString(aProperty, rect->mBottom, aResult);
@@ -437,17 +440,21 @@ nsCSSDeclaration::AppendCSSValueToString
   switch (unit) {
     case eCSSUnit_Null:         break;
     case eCSSUnit_Auto:         aResult.AppendLiteral("auto");     break;
     case eCSSUnit_Inherit:      aResult.AppendLiteral("inherit");  break;
     case eCSSUnit_Initial:      aResult.AppendLiteral("-moz-initial"); break;
     case eCSSUnit_None:         aResult.AppendLiteral("none");     break;
     case eCSSUnit_Normal:       aResult.AppendLiteral("normal");   break;
     case eCSSUnit_System_Font:  aResult.AppendLiteral("-moz-use-system-font"); break;
-    case eCSSUnit_Dummy:        break;
+    case eCSSUnit_Dummy:
+    case eCSSUnit_DummyInherit:
+    case eCSSUnit_RectIsAuto:
+      NS_NOTREACHED("should never serialize");
+      break;
 
     case eCSSUnit_String:       break;
     case eCSSUnit_URL:          break;
     case eCSSUnit_Image:        break;
     case eCSSUnit_Array:        break;
     case eCSSUnit_Attr:
     case eCSSUnit_Counter:
     case eCSSUnit_Counters:     aResult.Append(PRUnichar(')'));    break;
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -6650,17 +6650,17 @@ CSSParserImpl::DoParseRect(nsCSSRect& aR
   if (! GetToken(PR_TRUE)) {
     return PR_FALSE;
   }
   if (eCSSToken_Ident == mToken.mType) {
     nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(mToken.mIdent);
     switch (keyword) {
       case eCSSKeyword_auto:
         if (ExpectEndProperty()) {
-          aRect.SetAllSidesTo(nsCSSValue(eCSSUnit_Auto));
+          aRect.SetAllSidesTo(nsCSSValue(eCSSUnit_RectIsAuto));
           return PR_TRUE;
         }
         break;
       case eCSSKeyword_inherit:
         if (ExpectEndProperty()) {
           aRect.SetAllSidesTo(nsCSSValue(eCSSUnit_Inherit));
           return PR_TRUE;
         }
diff --git a/layout/style/nsCSSValue.cpp b/layout/style/nsCSSValue.cpp
--- a/layout/style/nsCSSValue.cpp
+++ b/layout/style/nsCSSValue.cpp
@@ -122,17 +122,17 @@ nsCSSValue::nsCSSValue(nsCSSValue::Image
 {
   mValue.mImage = aValue;
   mValue.mImage->AddRef();
 }
 
 nsCSSValue::nsCSSValue(const nsCSSValue& aCopy)
   : mUnit(aCopy.mUnit)
 {
-  if (mUnit <= eCSSUnit_DummyInherit) {
+  if (mUnit <= eCSSUnit_RectIsAuto) {
     // nothing to do, but put this important case first
   }
   else if (eCSSUnit_Percent <= mUnit) {
     mValue.mFloat = aCopy.mValue.mFloat;
   }
   else if (UnitHasStringValue()) {
     mValue.mString = aCopy.mValue.mString;
     mValue.mString->AddRef();
@@ -167,17 +167,17 @@ nsCSSValue& nsCSSValue::operator=(const 
     new (this) nsCSSValue(aCopy);
   }
   return *this;
 }
 
 PRBool nsCSSValue::operator==(const nsCSSValue& aOther) const
 {
   if (mUnit == aOther.mUnit) {
-    if (mUnit <= eCSSUnit_DummyInherit) {
+    if (mUnit <= eCSSUnit_RectIsAuto) {
       return PR_TRUE;
     }
     else if (UnitHasStringValue()) {
       return (NS_strcmp(GetBufferValue(mValue.mString),
                         GetBufferValue(aOther.mValue.mString)) == 0);
     }
     else if ((eCSSUnit_Integer <= mUnit) && (mUnit <= eCSSUnit_EnumColor)) {
       return mValue.mInt == aOther.mValue.mInt;
@@ -381,16 +381,22 @@ void nsCSSValue::SetDummyValue()
 }
 
 void nsCSSValue::SetDummyInheritValue()
 {
   Reset();
   mUnit = eCSSUnit_DummyInherit;
 }
 
+void nsCSSValue::SetRectIsAutoValue()
+{
+  Reset();
+  mUnit = eCSSUnit_RectIsAuto;
+}
+
 void nsCSSValue::StartImageLoad(nsIDocument* aDocument) const
 {
   NS_PRECONDITION(eCSSUnit_URL == mUnit, "Not a URL value!");
   nsCSSValue::Image* image =
     new nsCSSValue::Image(mValue.mURL->mURI,
                           mValue.mURL->mString,
                           mValue.mURL->mReferrer,
                           mValue.mURL->mOriginPrincipal,
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -92,16 +92,17 @@ enum nsCSSUnit {
   eCSSUnit_Initial      = 3,      // (n/a) value is default UA value
   eCSSUnit_None         = 4,      // (n/a) value is none
   eCSSUnit_Normal       = 5,      // (n/a) value is normal (algorithmic, different than auto)
   eCSSUnit_System_Font  = 6,      // (n/a) value is -moz-use-system-font
   eCSSUnit_Dummy        = 7,      // (n/a) a fake but specified value, used
                                   //       only in temporary values
   eCSSUnit_DummyInherit = 8,      // (n/a) a fake but specified value, used
                                   //       only in temporary values
+  eCSSUnit_RectIsAuto   = 9,      // (n/a) 'auto' for an entire rect()
   eCSSUnit_String       = 10,     // (PRUnichar*) a string value
   eCSSUnit_Attr         = 11,     // (PRUnichar*) a attr(string) value
   eCSSUnit_Local_Font   = 12,     // (PRUnichar*) a local font name
   eCSSUnit_Font_Format  = 13,     // (PRUnichar*) a font format name
   eCSSUnit_Array        = 20,     // (nsCSSValue::Array*) a list of values
   eCSSUnit_Counter      = 21,     // (nsCSSValue::Array*) a counter(string,[string]) value
   eCSSUnit_Counters     = 22,     // (nsCSSValue::Array*) a counters(string,string[,string]) value
   eCSSUnit_Function     = 23,     // (nsCSSValue::Array*) a function with parameters.  First elem of array is name,
@@ -169,17 +170,17 @@ public:
 
   struct Image;
   friend struct Image;
   
   // for valueless units only (null, auto, inherit, none, normal)
   explicit nsCSSValue(nsCSSUnit aUnit = eCSSUnit_Null)
     : mUnit(aUnit)
   {
-    NS_ASSERTION(aUnit <= eCSSUnit_DummyInherit, "not a valueless unit");
+    NS_ASSERTION(aUnit <= eCSSUnit_RectIsAuto, "not a valueless unit");
   }
 
   nsCSSValue(PRInt32 aValue, nsCSSUnit aUnit) NS_HIDDEN;
   nsCSSValue(float aValue, nsCSSUnit aUnit) NS_HIDDEN;
   nsCSSValue(const nsString& aValue, nsCSSUnit aUnit) NS_HIDDEN;
   explicit nsCSSValue(nscolor aValue) NS_HIDDEN;
   nsCSSValue(Array* aArray, nsCSSUnit aUnit) NS_HIDDEN;
   explicit nsCSSValue(URL* aValue) NS_HIDDEN;
@@ -312,16 +313,17 @@ public:
   NS_HIDDEN_(void)  SetAutoValue();
   NS_HIDDEN_(void)  SetInheritValue();
   NS_HIDDEN_(void)  SetInitialValue();
   NS_HIDDEN_(void)  SetNoneValue();
   NS_HIDDEN_(void)  SetNormalValue();
   NS_HIDDEN_(void)  SetSystemFontValue();
   NS_HIDDEN_(void)  SetDummyValue();
   NS_HIDDEN_(void)  SetDummyInheritValue();
+  NS_HIDDEN_(void)  SetRectIsAutoValue();
   NS_HIDDEN_(void)  StartImageLoad(nsIDocument* aDocument)
                                    const;  // Not really const, but pretending
 
   // Returns an already addrefed buffer.  Can return null on allocation
   // failure.
   static nsStringBuffer* BufferFromString(const nsString& aValue);
   
   struct Array {
diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -2771,21 +2771,17 @@ nsComputedDOMStyle::GetClip(nsIDOMCSSVal
 
   const nsStyleDisplay* display = GetStyleDisplay();
 
   nsresult rv = NS_OK;
   nsROCSSPrimitiveValue *topVal = nsnull;
   nsROCSSPrimitiveValue *rightVal = nsnull;
   nsROCSSPrimitiveValue *bottomVal = nsnull;
   nsROCSSPrimitiveValue *leftVal = nsnull;
-  if (display->mClipFlags == NS_STYLE_CLIP_AUTO ||
-      display->mClipFlags == (NS_STYLE_CLIP_TOP_AUTO |
-                              NS_STYLE_CLIP_RIGHT_AUTO |
-                              NS_STYLE_CLIP_BOTTOM_AUTO |
-                              NS_STYLE_CLIP_LEFT_AUTO)) {
+  if (display->mClipFlags == NS_STYLE_CLIP_AUTO) {
     val->SetIdent(nsGkAtoms::_auto);
   } else {
     // create the cssvalues for the sides, stick them in the rect object
     topVal = GetROCSSPrimitiveValue();
     rightVal = GetROCSSPrimitiveValue();
     bottomVal = GetROCSSPrimitiveValue();
     leftVal = GetROCSSPrimitiveValue();
     if (topVal && rightVal && bottomVal && leftVal) {
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -3430,73 +3430,63 @@ nsRuleNode::ComputeDisplayData(void* aSt
   }
 
   // clip property: length, auto, inherit
   if (eCSSUnit_Inherit == displayData.mClip.mTop.GetUnit()) { // if one is inherit, they all are
     inherited = PR_TRUE;
     display->mClipFlags = parentDisplay->mClipFlags;
     display->mClip = parentDisplay->mClip;
   }
-  // if one is initial, they all are
-  else if (eCSSUnit_Initial == displayData.mClip.mTop.GetUnit()) {
+  // if one is initial or auto (rect), they all are
+  else if (eCSSUnit_Initial == displayData.mClip.mTop.GetUnit() ||
+           eCSSUnit_RectIsAuto == displayData.mClip.mTop.GetUnit()) {
     display->mClipFlags = NS_STYLE_CLIP_AUTO;
     display->mClip.SetRect(0,0,0,0);
   }
-  else {
-    PRBool  fullAuto = PR_TRUE;
-
+  else if (eCSSUnit_Null != displayData.mClip.mTop.GetUnit()) {
     display->mClipFlags = 0; // clear it
 
     if (eCSSUnit_Auto == displayData.mClip.mTop.GetUnit()) {
       display->mClip.y = 0;
       display->mClipFlags |= NS_STYLE_CLIP_TOP_AUTO;
     } 
     else if (displayData.mClip.mTop.IsLengthUnit()) {
       display->mClip.y = CalcLength(displayData.mClip.mTop, aContext, mPresContext, inherited);
-      fullAuto = PR_FALSE;
     }
     if (eCSSUnit_Auto == displayData.mClip.mBottom.GetUnit()) {
       // Setting to NS_MAXSIZE for the 'auto' case ensures that
       // the clip rect is nonempty. It is important that mClip be
       // nonempty if the actual clip rect could be nonempty.
       display->mClip.height = NS_MAXSIZE;
       display->mClipFlags |= NS_STYLE_CLIP_BOTTOM_AUTO;
     } 
     else if (displayData.mClip.mBottom.IsLengthUnit()) {
       display->mClip.height = CalcLength(displayData.mClip.mBottom, aContext, mPresContext, inherited) -
                               display->mClip.y;
-      fullAuto = PR_FALSE;
     }
     if (eCSSUnit_Auto == displayData.mClip.mLeft.GetUnit()) {
       display->mClip.x = 0;
       display->mClipFlags |= NS_STYLE_CLIP_LEFT_AUTO;
     } 
     else if (displayData.mClip.mLeft.IsLengthUnit()) {
       display->mClip.x = CalcLength(displayData.mClip.mLeft, aContext, mPresContext, inherited);
-      fullAuto = PR_FALSE;
     }
     if (eCSSUnit_Auto == displayData.mClip.mRight.GetUnit()) {
       // Setting to NS_MAXSIZE for the 'auto' case ensures that
       // the clip rect is nonempty. It is important that mClip be
       // nonempty if the actual clip rect could be nonempty.
       display->mClip.width = NS_MAXSIZE;
       display->mClipFlags |= NS_STYLE_CLIP_RIGHT_AUTO;
     } 
     else if (displayData.mClip.mRight.IsLengthUnit()) {
       display->mClip.width = CalcLength(displayData.mClip.mRight, aContext, mPresContext, inherited) -
                              display->mClip.x;
-      fullAuto = PR_FALSE;
     }
     display->mClipFlags &= ~NS_STYLE_CLIP_TYPE_MASK;
-    if (fullAuto) {
-      display->mClipFlags |= NS_STYLE_CLIP_AUTO;
-    }
-    else {
-      display->mClipFlags |= NS_STYLE_CLIP_RECT;
-    }
+    display->mClipFlags |= NS_STYLE_CLIP_RECT;
   }
 
   if (display->mDisplay != NS_STYLE_DISPLAY_NONE) {
     // CSS2 9.7 specifies display type corrections dealing with 'float'
     // and 'position'.  Since generated content can't be floated or
     // positioned, we can deal with it here.
 
     if (nsCSSPseudoElements::firstLetter == aContext->GetPseudoType()) {
@@ -4489,21 +4479,22 @@ nsRuleNode::ComputeListData(void* aStart
               SETDSC_ENUMERATED, parentList->mListStylePosition,
               NS_STYLE_LIST_STYLE_POSITION_OUTSIDE, 0, 0, 0, 0);
 
   // image region property: length, auto, inherit
   if (eCSSUnit_Inherit == listData.mImageRegion.mTop.GetUnit()) { // if one is inherit, they all are
     inherited = PR_TRUE;
     list->mImageRegion = parentList->mImageRegion;
   }
-  // if one is -moz-initial, they all are
-  else if (eCSSUnit_Initial == listData.mImageRegion.mTop.GetUnit()) {
+  // if one is -moz-initial or auto (rect), they all are
+  else if (eCSSUnit_Initial == listData.mImageRegion.mTop.GetUnit() ||
+           eCSSUnit_RectIsAuto == listData.mImageRegion.mTop.GetUnit()) {
     list->mImageRegion.Empty();
   }
-  else {
+  else if (eCSSUnit_Null != listData.mImageRegion.mTop.GetUnit()) {
     if (eCSSUnit_Auto == listData.mImageRegion.mTop.GetUnit())
       list->mImageRegion.y = 0;
     else if (listData.mImageRegion.mTop.IsLengthUnit())
       list->mImageRegion.y = CalcLength(listData.mImageRegion.mTop, aContext, mPresContext, inherited);
       
     if (eCSSUnit_Auto == listData.mImageRegion.mBottom.GetUnit())
       list->mImageRegion.height = 0;
     else if (listData.mImageRegion.mBottom.IsLengthUnit())
diff --git a/layout/style/test/test_value_computation.html b/layout/style/test/test_value_computation.html
--- a/layout/style/test/test_value_computation.html
+++ b/layout/style/test/test_value_computation.html
@@ -35,18 +35,16 @@
 
 /** Test for computation of values in property database **/
 
 var gNotAccepted = {
   "list-style": [ "none disc outside" ],
 };
 
 var gBadComputed = {
-  "clip": [ "rect(auto,auto,auto,auto)" ],
-
   // The 'medium' keyword should be computing to '3px', not 'medium'.
   "outline-width": [ "3px" ],
 
   // These values are treated as auto.
   "page-break-after": [ "avoid" ],
   "page-break-before": [ "avoid" ],
 
   // These are probably bogus tests...
