From: L. David Baron <dbaron@dbaron.org>

Transition events and animation events are not cancelable.

diff --git a/content/events/test/test_eventctors.html b/content/events/test/test_eventctors.html
--- a/content/events/test/test_eventctors.html
+++ b/content/events/test/test_eventctors.html
@@ -719,12 +719,38 @@ while (testWheelProps.length) {
       is(e[def], defaultWheelEventValues[def],
          "WheelEvent: Wrong default value for " + def + "!");
     } else {
       is(e[def], p[def], "WheelEvent: Wrong event init value for " + def + "!");
     }
   }
 }
 
+// TransitionEvent
+e = new TransitionEvent("hello", { propertyName: "color", elapsedTime: 3.5, pseudoElement: "", foobar: "baz" })
+is("propertyName" in e, true, "Transition events have propertyName property");
+is("foobar" in e, false, "Transition events do not copy random properties from event init");
+is(e.propertyName, "color", "Transition event copies propertyName from TransitionEventInit");
+is(e.elapsedTime, 3.5, "Transition event copies elapsedTime from TransitionEventInit");
+is(e.pseudoElement, "", "Transition event copies pseudoElement from TransitionEventInit");
+is(e.bubbles, false, "Lack of bubbles property in TransitionEventInit");
+is(e.cancelable, false, "Lack of cancelable property in TransitionEventInit");
+is(e.type, "hello", "Wrong event type!");
+is(e.isTrusted, false, "Event shouldn't be trusted!");
+is(e.eventPhase, Event.NONE, "Wrong event phase");
+
+// AnimationEvent
+e = new AnimationEvent("hello", { animationName: "bounce3", elapsedTime: 3.5, pseudoElement: "", foobar: "baz" })
+is("animationName" in e, true, "Animation events have animationName property");
+is("foobar" in e, false, "Animation events do not copy random properties from event init");
+is(e.animationName, "bounce3", "Animation event copies animationName from AnimationEventInit");
+is(e.elapsedTime, 3.5, "Animation event copies elapsedTime from AnimationEventInit");
+is(e.pseudoElement, "", "Animation event copies pseudoElement from AnimationEventInit");
+is(e.bubbles, false, "Lack of bubbles property in AnimationEventInit");
+is(e.cancelable, false, "Lack of cancelable property in AnimationEventInit");
+is(e.type, "hello", "Wrong event type!");
+is(e.isTrusted, false, "Event shouldn't be trusted!");
+is(e.eventPhase, Event.NONE, "Wrong event phase");
+
 </script>
 </pre>
 </body>
 </html>
diff --git a/layout/style/test/test_animations.html b/layout/style/test/test_animations.html
--- a/layout/style/test/test_animations.html
+++ b/layout/style/test/test_animations.html
@@ -250,17 +250,17 @@ function test_fill_mode(fill_mode, fills
   advance_clock(2000);
   if (fills_backwards)
     is(cs.marginLeft, "0px", desc + "does affect value during delay (2s)");
   else
     is(cs.marginLeft, "30px", desc + "doesn't affect value during delay (2s)");
   check_events([], "before start in test_fill_mode");
   advance_clock(1000);
   check_events([{ type: 'animationstart', target: div,
-                  bubbles: true, cancelable: true,
+                  bubbles: true, cancelable: false,
                   animationName: 'anim1', elapsedTime: 0.0,
                   pseudoElement: "" }],
                "right after start in test_fill_mode");
   if (fills_backwards)
     is(cs.marginLeft, "0px", desc + "affects value at start of animation");
   advance_clock(125);
   is(cs.marginLeft, "2px", desc + "affects value during animation");
   advance_clock(2375);
@@ -269,17 +269,17 @@ function test_fill_mode(fill_mode, fills
   is(cs.marginLeft, "80px", desc + "affects value during animation");
   advance_clock(2500);
   is(cs.marginLeft, "90px", desc + "affects value during animation");
   advance_clock(2375);
   is(cs.marginLeft, "99.5px", desc + "affects value during animation");
   check_events([], "before end in test_fill_mode");
   advance_clock(125);
   check_events([{ type: 'animationend', target: div,
-                  bubbles: true, cancelable: true,
+                  bubbles: true, cancelable: false,
                   animationName: 'anim1', elapsedTime: 10.0,
                   pseudoElement: "" }],
                "right after end in test_fill_mode");
   if (fills_forwards)
     is(cs.marginLeft, "100px", desc + "affects value at end of animation");
   advance_clock(10);
   if (fills_forwards)
     is(cs.marginLeft, "100px", desc + "does affect value after animation");
diff --git a/layout/style/test/test_transitions_events.html b/layout/style/test/test_transitions_events.html
--- a/layout/style/test/test_transitions_events.html
+++ b/layout/style/test/test_transitions_events.html
@@ -207,16 +207,20 @@ started_test();
   function(event) {
     event.stopPropagation();
 
     ok(!got_two_target, "transitionend on two on target");
     is(event.propertyName, "margin-left",
        "propertyName for transitionend on two");
     is(event.elapsedTime, 1,
        "elapsedTime for transitionend on two");
+    is(event.bubbles, true,
+       "transitionend events should bubble");
+    is(event.cancelable, false,
+       "transitionend events should not be cancelable");
     is(cs("two").marginLeft, "10px",
        "computed style for transitionend on two");
     got_two_target = true;
     finished_test();
   }, false);
 
 started_test();
 $("two").className = "bar";
diff --git a/widget/ContentEvents.h b/widget/ContentEvents.h
--- a/widget/ContentEvents.h
+++ b/widget/ContentEvents.h
@@ -223,16 +223,17 @@ public:
 
   InternalTransitionEvent(bool aIsTrusted, uint32_t aMessage,
                           const nsAString& aPropertyName, float aElapsedTime,
                           const nsAString& aPseudoElement) :
     WidgetEvent(aIsTrusted, aMessage, NS_TRANSITION_EVENT),
     propertyName(aPropertyName), elapsedTime(aElapsedTime),
     pseudoElement(aPseudoElement)
   {
+    mFlags.mCancelable = false;
   }
 
   nsString propertyName;
   float elapsedTime;
   nsString pseudoElement;
 
   void AssignTransitionEventData(const InternalTransitionEvent& aEvent,
                                  bool aCopyTargets)
@@ -258,16 +259,17 @@ public:
 
   InternalAnimationEvent(bool aIsTrusted, uint32_t aMessage,
                          const nsAString& aAnimationName, float aElapsedTime,
                          const nsAString& aPseudoElement) :
     WidgetEvent(aIsTrusted, aMessage, NS_ANIMATION_EVENT),
     animationName(aAnimationName), elapsedTime(aElapsedTime),
     pseudoElement(aPseudoElement)
   {
+    mFlags.mCancelable = false;
   }
 
   nsString animationName;
   float elapsedTime;
   nsString pseudoElement;
 
   void AssignAnimationEventData(const InternalAnimationEvent& aEvent,
                                 bool aCopyTargets)
