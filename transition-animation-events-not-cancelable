From: L. David Baron <dbaron@dbaron.org>

Transition events and animation events are not cancelable.

diff --git a/content/events/test/test_eventctors.html b/content/events/test/test_eventctors.html
--- a/content/events/test/test_eventctors.html
+++ b/content/events/test/test_eventctors.html
@@ -719,12 +719,16 @@ while (testWheelProps.length) {
       is(e[def], defaultWheelEventValues[def],
          "WheelEvent: Wrong default value for " + def + "!");
     } else {
       is(e[def], p[def], "WheelEvent: Wrong event init value for " + def + "!");
     }
   }
 }
 
+// TransitionEvent
+
+// AnimationEvent
+
 </script>
 </pre>
 </body>
 </html>
diff --git a/layout/style/test/test_animations.html b/layout/style/test/test_animations.html
--- a/layout/style/test/test_animations.html
+++ b/layout/style/test/test_animations.html
@@ -250,17 +250,17 @@ function test_fill_mode(fill_mode, fills
   advance_clock(2000);
   if (fills_backwards)
     is(cs.marginLeft, "0px", desc + "does affect value during delay (2s)");
   else
     is(cs.marginLeft, "30px", desc + "doesn't affect value during delay (2s)");
   check_events([], "before start in test_fill_mode");
   advance_clock(1000);
   check_events([{ type: 'animationstart', target: div,
-                  bubbles: true, cancelable: true,
+                  bubbles: true, cancelable: false,
                   animationName: 'anim1', elapsedTime: 0.0,
                   pseudoElement: "" }],
                "right after start in test_fill_mode");
   if (fills_backwards)
     is(cs.marginLeft, "0px", desc + "affects value at start of animation");
   advance_clock(125);
   is(cs.marginLeft, "2px", desc + "affects value during animation");
   advance_clock(2375);
@@ -269,17 +269,17 @@ function test_fill_mode(fill_mode, fills
   is(cs.marginLeft, "80px", desc + "affects value during animation");
   advance_clock(2500);
   is(cs.marginLeft, "90px", desc + "affects value during animation");
   advance_clock(2375);
   is(cs.marginLeft, "99.5px", desc + "affects value during animation");
   check_events([], "before end in test_fill_mode");
   advance_clock(125);
   check_events([{ type: 'animationend', target: div,
-                  bubbles: true, cancelable: true,
+                  bubbles: true, cancelable: false,
                   animationName: 'anim1', elapsedTime: 10.0,
                   pseudoElement: "" }],
                "right after end in test_fill_mode");
   if (fills_forwards)
     is(cs.marginLeft, "100px", desc + "affects value at end of animation");
   advance_clock(10);
   if (fills_forwards)
     is(cs.marginLeft, "100px", desc + "does affect value after animation");
diff --git a/layout/style/test/test_transitions_events.html b/layout/style/test/test_transitions_events.html
--- a/layout/style/test/test_transitions_events.html
+++ b/layout/style/test/test_transitions_events.html
@@ -207,16 +207,20 @@ started_test();
   function(event) {
     event.stopPropagation();
 
     ok(!got_two_target, "transitionend on two on target");
     is(event.propertyName, "margin-left",
        "propertyName for transitionend on two");
     is(event.elapsedTime, 1,
        "elapsedTime for transitionend on two");
+    is(event.bubbles, true,
+       "transitionend events should bubble");
+    is(event.cancelable, false,
+       "transitionend events should not be cancelable");
     is(cs("two").marginLeft, "10px",
        "computed style for transitionend on two");
     got_two_target = true;
     finished_test();
   }, false);
 
 started_test();
 $("two").className = "bar";
diff --git a/widget/ContentEvents.h b/widget/ContentEvents.h
--- a/widget/ContentEvents.h
+++ b/widget/ContentEvents.h
@@ -223,16 +223,17 @@ public:
 
   InternalTransitionEvent(bool aIsTrusted, uint32_t aMessage,
                           const nsAString& aPropertyName, float aElapsedTime,
                           const nsAString& aPseudoElement) :
     WidgetEvent(aIsTrusted, aMessage, NS_TRANSITION_EVENT),
     propertyName(aPropertyName), elapsedTime(aElapsedTime),
     pseudoElement(aPseudoElement)
   {
+    mFlags.mCancelable = false;
   }
 
   nsString propertyName;
   float elapsedTime;
   nsString pseudoElement;
 
   void AssignTransitionEventData(const InternalTransitionEvent& aEvent,
                                  bool aCopyTargets)
@@ -258,16 +259,17 @@ public:
 
   InternalAnimationEvent(bool aIsTrusted, uint32_t aMessage,
                          const nsAString& aAnimationName, float aElapsedTime,
                          const nsAString& aPseudoElement) :
     WidgetEvent(aIsTrusted, aMessage, NS_ANIMATION_EVENT),
     animationName(aAnimationName), elapsedTime(aElapsedTime),
     pseudoElement(aPseudoElement)
   {
+    mFlags.mCancelable = false;
   }
 
   nsString animationName;
   float elapsedTime;
   nsString pseudoElement;
 
   void AssignAnimationEventData(const InternalAnimationEvent& aEvent,
                                 bool aCopyTargets)
