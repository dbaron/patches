From: L. David Baron <dbaron@dbaron.org>

Bug 1223653 patch 2 - Use an enum class for NS_STYLE_BOX_SIZING_*.

diff --git a/dom/html/nsGenericHTMLElement.cpp b/dom/html/nsGenericHTMLElement.cpp
--- a/dom/html/nsGenericHTMLElement.cpp
+++ b/dom/html/nsGenericHTMLElement.cpp
@@ -399,17 +399,17 @@ nsGenericHTMLElement::GetOffsetRect(CSSI
       if (html_doc) {
         offsetParent = static_cast<nsHTMLDocument*>(html_doc.get())->GetBody();
       }
     }
   }
 
   // Subtract the parent border unless it uses border-box sizing.
   if (parent &&
-      parent->StylePosition()->mBoxSizing != NS_STYLE_BOX_SIZING_BORDER) {
+      parent->StylePosition()->mBoxSizing != StyleBoxSizing::Border) {
     const nsStyleBorder* border = parent->StyleBorder();
     origin.x -= border->GetComputedBorderWidth(NS_SIDE_LEFT);
     origin.y -= border->GetComputedBorderWidth(NS_SIDE_TOP);
   }
 
   // XXX We should really consider subtracting out padding for
   // content-box sizing, but we should see what IE does....
 
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -4427,17 +4427,17 @@ static int32_t gNoiseIndent = 0;
  * @param aFlags same as for IntrinsicForContainer
  * @param aContainerWM the container's WM
  */
 static nscoord
 AddIntrinsicSizeOffset(nsRenderingContext* aRenderingContext,
                        nsIFrame* aFrame,
                        const nsIFrame::IntrinsicISizeOffsetData& aOffsets,
                        nsLayoutUtils::IntrinsicISizeType aType,
-                       uint8_t aBoxSizing,
+                       StyleBoxSizing aBoxSizing,
                        nscoord aContentSize,
                        nscoord aContentMinSize,
                        const nsStyleCoord& aStyleSize,
                        const nscoord* aFixedMinSize,
                        const nsStyleCoord& aStyleMinSize,
                        const nscoord* aFixedMaxSize,
                        const nsStyleCoord& aStyleMaxSize,
                        uint32_t aFlags,
@@ -4448,29 +4448,29 @@ AddIntrinsicSizeOffset(nsRenderingContex
   nscoord coordOutsideSize = 0;
   float pctOutsideSize = 0;
   float pctTotal = 0.0f;
 
   if (!(aFlags & nsLayoutUtils::IGNORE_PADDING)) {
     coordOutsideSize += aOffsets.hPadding;
     pctOutsideSize += aOffsets.hPctPadding;
 
-    if (aBoxSizing == NS_STYLE_BOX_SIZING_PADDING) {
+    if (aBoxSizing == StyleBoxSizing::Padding) {
       min += coordOutsideSize;
       result = NSCoordSaturatingAdd(result, coordOutsideSize);
       pctTotal += pctOutsideSize;
 
       coordOutsideSize = 0;
       pctOutsideSize = 0.0f;
     }
   }
 
   coordOutsideSize += aOffsets.hBorder;
 
-  if (aBoxSizing == NS_STYLE_BOX_SIZING_BORDER) {
+  if (aBoxSizing == StyleBoxSizing::Border) {
     min += coordOutsideSize;
     result = NSCoordSaturatingAdd(result, coordOutsideSize);
     pctTotal += pctOutsideSize;
 
     coordOutsideSize = 0;
     pctOutsideSize = 0.0f;
   }
 
@@ -4588,17 +4588,17 @@ nsLayoutUtils::IntrinsicForAxis(Physical
   // If aFrame is a container for font size inflation, then shrink
   // wrapping inside of it should not apply font size inflation.
   AutoMaybeDisableFontInflation an(aFrame);
 
   // We want the size this frame will contribute to the parent's inline-size,
   // so we work in the parent's writing mode; but if aFrame is orthogonal to
   // its parent, we'll need to look at its BSize instead of min/pref-ISize.
   const nsStylePosition* stylePos = aFrame->StylePosition();
-  uint8_t boxSizing = stylePos->mBoxSizing;
+  StyleBoxSizing boxSizing = stylePos->mBoxSizing;
 
   const nsStyleCoord& styleMinISize =
     horizontalAxis ? stylePos->mMinWidth : stylePos->mMinHeight;
   const nsStyleCoord& styleISize =
     (aFlags & MIN_INTRINSIC_ISIZE) ? styleMinISize :
     (horizontalAxis ? stylePos->mWidth : stylePos->mHeight);
   MOZ_ASSERT(!(aFlags & MIN_INTRINSIC_ISIZE) ||
              styleISize.GetUnit() == eStyleUnit_Auto ||
@@ -4645,17 +4645,17 @@ nsLayoutUtils::IntrinsicForAxis(Physical
   // we'll never need the intrinsic dimensions.
   if (styleISize.GetUnit() == eStyleUnit_Enumerated &&
       (styleISize.GetIntValue() == NS_STYLE_WIDTH_MAX_CONTENT ||
        styleISize.GetIntValue() == NS_STYLE_WIDTH_MIN_CONTENT)) {
     // -moz-fit-content and -moz-available enumerated widths compute intrinsic
     // widths just like auto.
     // For -moz-max-content and -moz-min-content, we handle them like
     // specified widths, but ignore box-sizing.
-    boxSizing = NS_STYLE_BOX_SIZING_CONTENT;
+    boxSizing = StyleBoxSizing::Content;
   } else if (!styleISize.ConvertsToLength() &&
              !(haveFixedMinISize && haveFixedMaxISize && maxISize <= minISize)) {
 #ifdef DEBUG_INTRINSIC_WIDTH
     ++gNoiseIndent;
 #endif
     if (MOZ_UNLIKELY(aAxis != ourInlineAxis)) {
       // We need aFrame's block-dir size.
       if (aFlags & BAIL_IF_REFLOW_NEEDED) {
@@ -4707,24 +4707,24 @@ nsLayoutUtils::IntrinsicForAxis(Physical
       nscoord ratioISize = (horizontalAxis ? ratio.width  : ratio.height);
       nscoord ratioBSize = (horizontalAxis ? ratio.height : ratio.width);
       if (ratioBSize != 0) {
         AddStateBitToAncestors(aFrame,
             NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE);
 
         nscoord bSizeTakenByBoxSizing = 0;
         switch (boxSizing) {
-        case NS_STYLE_BOX_SIZING_BORDER: {
+        case StyleBoxSizing::Border: {
           const nsStyleBorder* styleBorder = aFrame->StyleBorder();
           bSizeTakenByBoxSizing +=
             horizontalAxis ? styleBorder->GetComputedBorder().TopBottom()
                            : styleBorder->GetComputedBorder().LeftRight();
           // fall through
         }
-        case NS_STYLE_BOX_SIZING_PADDING: {
+        case StyleBoxSizing::Padding: {
           if (!(aFlags & IGNORE_PADDING)) {
             const nsStyleSides& stylePadding =
               aFrame->StylePadding()->mPadding;
             const nsStyleCoord& paddingStart =
               stylePadding.Get(horizontalAxis ? NS_SIDE_TOP : NS_SIDE_LEFT);
             const nsStyleCoord& paddingEnd =
               stylePadding.Get(horizontalAxis ? NS_SIDE_BOTTOM : NS_SIDE_RIGHT);
             nscoord pad;
@@ -4734,17 +4734,17 @@ nsLayoutUtils::IntrinsicForAxis(Physical
             }
             if (GetAbsoluteCoord(paddingEnd, pad) ||
                 GetPercentBSize(paddingEnd, aFrame, pad)) {
               bSizeTakenByBoxSizing += pad;
             }
           }
           // fall through
         }
-        case NS_STYLE_BOX_SIZING_CONTENT:
+        case StyleBoxSizing::Content:
         default:
           break;
         }
 
         nscoord h;
         if (GetAbsoluteCoord(styleBSize, h) ||
             GetPercentBSize(styleBSize, aFrame, h)) {
           h = std::max(0, h - bSizeTakenByBoxSizing);
@@ -5111,21 +5111,25 @@ nsLayoutUtils::ComputeSizeWithIntrinsicD
   // a * (b / c) because of its reduced accuracy relative to a * b / c
   // or (a * b) / c (which are equivalent).
 
   const bool isAutoISize = inlineStyleCoord->GetUnit() == eStyleUnit_Auto;
   const bool isAutoBSize = IsAutoBSize(*blockStyleCoord, aCBSize.BSize(aWM));
 
   LogicalSize boxSizingAdjust(aWM);
   switch (stylePos->mBoxSizing) {
-    case NS_STYLE_BOX_SIZING_BORDER:
+    case StyleBoxSizing::Border:
       boxSizingAdjust += aBorder;
       // fall through
-    case NS_STYLE_BOX_SIZING_PADDING:
+    case StyleBoxSizing::Padding:
       boxSizingAdjust += aPadding;
+      // fall through
+    case StyleBoxSizing::Content:
+      // nothing
+      break;
   }
   nscoord boxSizingToMarginEdgeISize =
     aMargin.ISize(aWM) + aBorder.ISize(aWM) + aPadding.ISize(aWM) -
       boxSizingAdjust.ISize(aWM);
 
   nscoord iSize, minISize, maxISize, bSize, minBSize, maxBSize;
 
   if (!isAutoISize) {
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -4295,21 +4295,25 @@ nsFrame::ComputeSize(nsRenderingContext 
   LogicalSize result = ComputeAutoSize(aRenderingContext, aWM,
                                        aCBSize, aAvailableISize,
                                        aMargin, aBorder, aPadding,
                                        aFlags & ComputeSizeFlags::eShrinkWrap);
   LogicalSize boxSizingAdjust(aWM);
   const nsStylePosition *stylePos = StylePosition();
 
   switch (stylePos->mBoxSizing) {
-    case NS_STYLE_BOX_SIZING_BORDER:
+    case StyleBoxSizing::Border:
       boxSizingAdjust += aBorder;
       // fall through
-    case NS_STYLE_BOX_SIZING_PADDING:
+    case StyleBoxSizing::Padding:
       boxSizingAdjust += aPadding;
+      // fall through
+    case StyleBoxSizing::Content:
+      // nothing
+      break;
   }
   nscoord boxSizingToMarginEdgeISize =
     aMargin.ISize(aWM) + aBorder.ISize(aWM) + aPadding.ISize(aWM) -
     boxSizingAdjust.ISize(aWM);
 
   const nsStyleCoord* inlineStyleCoord = &stylePos->ISize(aWM);
   const nsStyleCoord* blockStyleCoord = &stylePos->BSize(aWM);
 
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -246,50 +246,56 @@ nsCSSOffsetState::ComputeISizeValue(nsco
                                           aContainingBlockISize,
                                           aContentEdgeToBoxSizing,
                                           aBoxSizingToMarginEdge,
                                           aCoord);
 }
 
 nscoord
 nsCSSOffsetState::ComputeISizeValue(nscoord aContainingBlockISize,
-                                    uint8_t aBoxSizing,
+                                    StyleBoxSizing aBoxSizing,
                                     const nsStyleCoord& aCoord)
 {
   WritingMode wm = GetWritingMode();
   nscoord inside = 0, outside = ComputedLogicalBorderPadding().IStartEnd(wm) +
                                 ComputedLogicalMargin().IStartEnd(wm);
   switch (aBoxSizing) {
-    case NS_STYLE_BOX_SIZING_BORDER:
+    case StyleBoxSizing::Border:
       inside = ComputedLogicalBorderPadding().IStartEnd(wm);
       break;
-    case NS_STYLE_BOX_SIZING_PADDING:
+    case StyleBoxSizing::Padding:
       inside = ComputedLogicalPadding().IStartEnd(wm);
       break;
+    case StyleBoxSizing::Content:
+      // nothing
+      break;
   }
   outside -= inside;
 
   return ComputeISizeValue(aContainingBlockISize, inside,
                            outside, aCoord);
 }
 
 nscoord
 nsCSSOffsetState::ComputeBSizeValue(nscoord aContainingBlockBSize,
-                                    uint8_t aBoxSizing,
+                                    StyleBoxSizing aBoxSizing,
                                     const nsStyleCoord& aCoord)
 {
   WritingMode wm = GetWritingMode();
   nscoord inside = 0;
   switch (aBoxSizing) {
-    case NS_STYLE_BOX_SIZING_BORDER:
+    case StyleBoxSizing::Border:
       inside = ComputedLogicalBorderPadding().BStartEnd(wm);
       break;
-    case NS_STYLE_BOX_SIZING_PADDING:
+    case StyleBoxSizing::Padding:
       inside = ComputedLogicalPadding().BStartEnd(wm);
       break;
+    case StyleBoxSizing::Content:
+      // nothing
+      break;
   }
   return nsLayoutUtils::ComputeBSizeValue(aContainingBlockBSize,
                                           inside, aCoord);
 }
 
 void
 nsHTMLReflowState::SetComputedWidth(nscoord aComputedWidth)
 {
@@ -1128,21 +1134,25 @@ nsHTMLReflowState::CalculateBorderPaddin
                                 mStyleMargin->mMargin.Get(endSide));
     }
     marginStartEnd = start + end;
   }
 
   nscoord outside = paddingStartEnd + borderStartEnd + marginStartEnd;
   nscoord inside = 0;
   switch (mStylePosition->mBoxSizing) {
-    case NS_STYLE_BOX_SIZING_BORDER:
+    case StyleBoxSizing::Border:
       inside += borderStartEnd;
       // fall through
-    case NS_STYLE_BOX_SIZING_PADDING:
+    case StyleBoxSizing::Padding:
       inside += paddingStartEnd;
+      // fall through
+    case StyleBoxSizing::Content:
+      // nothing
+      break;
   }
   outside -= inside;
   *aInsideBoxSizing = inside;
   *aOutsideBoxSizing = outside;
   return;
 }
 
 /**
diff --git a/layout/generic/nsHTMLReflowState.h b/layout/generic/nsHTMLReflowState.h
--- a/layout/generic/nsHTMLReflowState.h
+++ b/layout/generic/nsHTMLReflowState.h
@@ -245,21 +245,21 @@ protected:
    */
   inline nscoord ComputeISizeValue(nscoord aContainingBlockISize,
                                    nscoord aContentEdgeToBoxSizing,
                                    nscoord aBoxSizingToMarginEdge,
                                    const nsStyleCoord& aCoord);
   // same as previous, but using mComputedBorderPadding, mComputedPadding,
   // and mComputedMargin
   nscoord ComputeISizeValue(nscoord aContainingBlockISize,
-                            uint8_t aBoxSizing,
+                            mozilla::StyleBoxSizing aBoxSizing,
                             const nsStyleCoord& aCoord);
 
   nscoord ComputeBSizeValue(nscoord aContainingBlockBSize,
-                            uint8_t aBoxSizing,
+                            mozilla::StyleBoxSizing aBoxSizing,
                             const nsStyleCoord& aCoord);
 };
 
 /**
  * State passed to a frame during reflow or intrinsic size calculation.
  *
  * XXX Refactor so only a base class (nsSizingState?) is used for intrinsic
  * size calculation.
diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -528,22 +528,25 @@ nsMargin
 nsComputedDOMStyle::GetAdjustedValuesForBoxSizing()
 {
   // We want the width/height of whatever parts 'width' or 'height' controls,
   // which can be different depending on the value of the 'box-sizing' property.
   const nsStylePosition* stylePos = StylePosition();
 
   nsMargin adjustment;
   switch(stylePos->mBoxSizing) {
-    case NS_STYLE_BOX_SIZING_BORDER:
+    case StyleBoxSizing::Border:
       adjustment += mInnerFrame->GetUsedBorder();
       // fall through
-
-    case NS_STYLE_BOX_SIZING_PADDING:
+    case StyleBoxSizing::Padding:
       adjustment += mInnerFrame->GetUsedPadding();
+      // fall through
+    case StyleBoxSizing::Content:
+      // nothing
+      break;
   }
 
   return adjustment;
 }
 
 /* static */
 nsIPresShell*
 nsComputedDOMStyle::GetPresShellForContent(nsIContent* aContent)
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -7863,17 +7863,21 @@ nsRuleNode::ComputePositionData(void* aS
              SETCOORD_UNSET_INITIAL,
            aContext, mPresContext, conditions);
 
   // box-sizing: enum, inherit, initial
   SetDiscrete(*aRuleData->ValueForBoxSizing(),
               pos->mBoxSizing, conditions,
               SETDSC_ENUMERATED | SETDSC_UNSET_INITIAL,
               parentPos->mBoxSizing,
-              NS_STYLE_BOX_SIZING_CONTENT, 0, 0, 0, 0);
+              StyleBoxSizing::Content,
+              StyleBoxSizing::Content /* ignored */,
+              StyleBoxSizing::Content /* ignored */,
+              StyleBoxSizing::Content /* ignored */,
+              StyleBoxSizing::Content /* ignored */);
 
   // align-content: enum, inherit, initial
   const auto& alignContentValue = *aRuleData->ValueForAlignContent();
   if (MOZ_UNLIKELY(alignContentValue.GetUnit() == eCSSUnit_Inherit)) {
     if (MOZ_LIKELY(parentContext)) {
       pos->mAlignContent =
         parentPos->ComputedAlignContent(parentContext->StyleDisplay());
     } else {
diff --git a/layout/style/nsStyleConsts.h b/layout/style/nsStyleConsts.h
--- a/layout/style/nsStyleConsts.h
+++ b/layout/style/nsStyleConsts.h
@@ -52,19 +52,25 @@ static inline mozilla::css::Side operato
 
 #define NS_SIDE_IS_VERTICAL(side_) ((side_) % 2)
 #define NS_SIDE_TO_FULL_CORNER(side_, second_) \
   (((side_) + !!(second_)) % 4)
 #define NS_SIDE_TO_HALF_CORNER(side_, second_, parallel_) \
   ((((side_) + !!(second_))*2 + ((side_) + !(parallel_))%2) % 8)
 
 // box-sizing
-#define NS_STYLE_BOX_SIZING_CONTENT       0
-#define NS_STYLE_BOX_SIZING_PADDING       1
-#define NS_STYLE_BOX_SIZING_BORDER        2
+namespace mozilla {
+
+enum class StyleBoxSizing : uint8_t {
+  Content,
+  Padding,
+  Border
+};
+
+} // namespace mozilla
 
 // clip-path sizing
 #define NS_STYLE_CLIP_SHAPE_SIZING_NOBOX   0
 #define NS_STYLE_CLIP_SHAPE_SIZING_CONTENT 1
 #define NS_STYLE_CLIP_SHAPE_SIZING_PADDING 2
 #define NS_STYLE_CLIP_SHAPE_SIZING_BORDER  3
 #define NS_STYLE_CLIP_SHAPE_SIZING_MARGIN  4
 #define NS_STYLE_CLIP_SHAPE_SIZING_FILL    5
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -1430,17 +1430,17 @@ nsStylePosition::nsStylePosition(void)
   // The initial value of grid-auto-columns and grid-auto-rows is 'auto',
   // which computes to 'minmax(auto, auto)'.
   mGridAutoColumnsMin.SetAutoValue();
   mGridAutoColumnsMax.SetAutoValue();
   mGridAutoRowsMin.SetAutoValue();
   mGridAutoRowsMax.SetAutoValue();
 
   mGridAutoFlow = NS_STYLE_GRID_AUTO_FLOW_ROW;
-  mBoxSizing = NS_STYLE_BOX_SIZING_CONTENT;
+  mBoxSizing = StyleBoxSizing::Content;
   mAlignContent = NS_STYLE_ALIGN_AUTO;
   mAlignItems = NS_STYLE_ALIGN_AUTO;
   mAlignSelf = NS_STYLE_ALIGN_AUTO;
   mJustifyContent = NS_STYLE_JUSTIFY_AUTO;
   mJustifyItems = NS_STYLE_JUSTIFY_AUTO;
   mJustifySelf = NS_STYLE_JUSTIFY_AUTO;
   mFlexDirection = NS_STYLE_FLEX_DIRECTION_ROW;
   mFlexWrap = NS_STYLE_FLEX_WRAP_NOWRAP;
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -1453,17 +1453,17 @@ struct nsStylePosition {
   nsStyleCoord  mMinHeight;             // [reset] coord, percent, calc
   nsStyleCoord  mMaxHeight;             // [reset] coord, percent, calc, none
   nsStyleCoord  mFlexBasis;             // [reset] coord, percent, enum, calc, auto
   nsStyleCoord  mGridAutoColumnsMin;    // [reset] coord, percent, enum, calc, flex
   nsStyleCoord  mGridAutoColumnsMax;    // [reset] coord, percent, enum, calc, flex
   nsStyleCoord  mGridAutoRowsMin;       // [reset] coord, percent, enum, calc, flex
   nsStyleCoord  mGridAutoRowsMax;       // [reset] coord, percent, enum, calc, flex
   uint8_t       mGridAutoFlow;          // [reset] enumerated. See nsStyleConsts.h
-  uint8_t       mBoxSizing;             // [reset] see nsStyleConsts.h
+  mozilla::StyleBoxSizing mBoxSizing;   // [reset] see nsStyleConsts.h
 private:
   friend class nsRuleNode;
   // Helper for the ComputedAlign/Justify* methods.
   uint8_t MapLeftRightToStart(uint8_t aAlign, mozilla::LogicalAxis aAxis,
                               const nsStyleDisplay* aDisplay) const;
 
   uint16_t      mAlignContent;          // [reset] fallback value in the high byte
   uint8_t       mAlignItems;            // [reset] see nsStyleConsts.h
diff --git a/layout/tables/BasicTableLayoutStrategy.cpp b/layout/tables/BasicTableLayoutStrategy.cpp
--- a/layout/tables/BasicTableLayoutStrategy.cpp
+++ b/layout/tables/BasicTableLayoutStrategy.cpp
@@ -116,26 +116,25 @@ GetISizeInfo(nsRenderingContext *aRender
         // for bsize).
         // For this reason, we also do not use box-sizing for just one of
         // them, as this may be confusing.
         if (isQuirks) {
             boxSizingToBorderEdge = offsets.hPadding + offsets.hBorder;
         }
         else {
             switch (stylePos->mBoxSizing) {
-                case NS_STYLE_BOX_SIZING_CONTENT:
+                case StyleBoxSizing::Content:
                     boxSizingToBorderEdge = offsets.hPadding + offsets.hBorder;
                     break;
-                case NS_STYLE_BOX_SIZING_PADDING:
+                case StyleBoxSizing::Padding:
                     minCoord += offsets.hPadding;
                     prefCoord += offsets.hPadding;
                     boxSizingToBorderEdge = offsets.hBorder;
                     break;
-                default:
-                    // NS_STYLE_BOX_SIZING_BORDER
+                case StyleBoxSizing::Border:
                     minCoord += offsets.hPadding + offsets.hBorder;
                     prefCoord += offsets.hPadding + offsets.hBorder;
                     break;
             }
         }
     } else {
         minCoord = 0;
         prefCoord = 0;
diff --git a/layout/tables/FixedTableLayoutStrategy.cpp b/layout/tables/FixedTableLayoutStrategy.cpp
--- a/layout/tables/FixedTableLayoutStrategy.cpp
+++ b/layout/tables/FixedTableLayoutStrategy.cpp
@@ -255,23 +255,23 @@ FixedTableLayoutStrategy::ComputeColumnI
           // XXX This should use real percentage padding
           nsIFrame::IntrinsicISizeOffsetData offsets =
             cellFrame->IntrinsicISizeOffsets();
           float pct = styleISize->GetPercentValue();
           colISize = NSToCoordFloor(pct * float(tableISize));
 
           nscoord boxSizingAdjust = 0;
           switch (cellFrame->StylePosition()->mBoxSizing) {
-            case NS_STYLE_BOX_SIZING_CONTENT:
+            case StyleBoxSizing::Content:
               boxSizingAdjust += offsets.hPadding;
               // Fall through
-            case NS_STYLE_BOX_SIZING_PADDING:
+            case StyleBoxSizing::Padding:
               boxSizingAdjust += offsets.hBorder;
               // Fall through
-            case NS_STYLE_BOX_SIZING_BORDER:
+            case StyleBoxSizing::Border:
               // Don't add anything
               break;
           }
           colISize += boxSizingAdjust;
 
           pct /= float(colSpan);
           colFrame->AddPrefPercent(pct);
           pctTotal += pct;
diff --git a/layout/tables/nsTableRowFrame.cpp b/layout/tables/nsTableRowFrame.cpp
--- a/layout/tables/nsTableRowFrame.cpp
+++ b/layout/tables/nsTableRowFrame.cpp
@@ -664,26 +664,25 @@ nsTableRowFrame::CalculateCellActualBSiz
       nscoord outsideBoxSizing = 0;
       // In quirks mode, table cell isize should be content-box, but bsize
       // should be border-box.
       // Because of this historic anomaly, we do not use quirk.css
       // (since we can't specify one value of box-sizing for isize and another
       // for bsize)
       if (PresContext()->CompatibilityMode() != eCompatibility_NavQuirks) {
         switch (position->mBoxSizing) {
-          case NS_STYLE_BOX_SIZING_CONTENT:
+          case StyleBoxSizing::Content:
             outsideBoxSizing =
               aCellFrame->GetLogicalUsedBorderAndPadding(aWM).BStartEnd(aWM);
             break;
-          case NS_STYLE_BOX_SIZING_PADDING:
+          case StyleBoxSizing::Padding:
             outsideBoxSizing =
               aCellFrame->GetLogicalUsedBorder(aWM).BStartEnd(aWM);
             break;
-          default:
-            // NS_STYLE_BOX_SIZING_BORDER
+          case StyleBoxSizing::Border:
             break;
         }
       }
 
       specifiedBSize =
         nsRuleNode::ComputeCoordPercentCalc(bsizeStyleCoord, 0) +
         outsideBoxSizing;
 
diff --git a/layout/xul/nsResizerFrame.cpp b/layout/xul/nsResizerFrame.cpp
--- a/layout/xul/nsResizerFrame.cpp
+++ b/layout/xul/nsResizerFrame.cpp
@@ -76,22 +76,24 @@ nsResizerFrame::HandleEvent(nsPresContex
           if (!frameToResize)
             break;
 
           // cache the content rectangle for the frame to resize
           // GetScreenRectInAppUnits returns the border box rectangle, so
           // adjust to get the desired content rectangle.
           nsRect rect = frameToResize->GetScreenRectInAppUnits();
           switch (frameToResize->StylePosition()->mBoxSizing) {
-            case NS_STYLE_BOX_SIZING_CONTENT:
+            case StyleBoxSizing::Content:
               rect.Deflate(frameToResize->GetUsedPadding());
-            case NS_STYLE_BOX_SIZING_PADDING:
+              // fall through
+            case StyleBoxSizing::Padding:
               rect.Deflate(frameToResize->GetUsedBorder());
-            default:
-              break;
+              // fall through
+            case StyleBoxSizing::Content:
+              // nothing
           }
 
           mMouseDownRect =
             LayoutDeviceIntRect::FromAppUnitsToNearest(rect, aPresContext->AppUnitsPerDevPixel());
           doDefault = false;
         }
         else {
           // If there is no window, then resizing isn't allowed.
