From: L. David Baron <dbaron@dbaron.org>

Pass the media feature to media feature value getters.  (Bug 522149)

diff --git a/layout/style/nsMediaFeatures.cpp b/layout/style/nsMediaFeatures.cpp
--- a/layout/style/nsMediaFeatures.cpp
+++ b/layout/style/nsMediaFeatures.cpp
@@ -68,26 +68,28 @@ GetSize(nsPresContext* aPresContext)
         // We want the page size, including unprintable areas and margins.
         size = aPresContext->GetPageSize();
     else
         size = aPresContext->GetVisibleArea().Size();
     return size;
 }
 
 static nsresult
-GetWidth(nsPresContext* aPresContext, nsCSSValue& aResult)
+GetWidth(nsPresContext* aPresContext, const nsMediaFeature*,
+         nsCSSValue& aResult)
 {
     nsSize size = GetSize(aPresContext);
     float pixelWidth = aPresContext->AppUnitsToFloatCSSPixels(size.width);
     aResult.SetFloatValue(pixelWidth, eCSSUnit_Pixel);
     return NS_OK;
 }
 
 static nsresult
-GetHeight(nsPresContext* aPresContext, nsCSSValue& aResult)
+GetHeight(nsPresContext* aPresContext, const nsMediaFeature*,
+          nsCSSValue& aResult)
 {
     nsSize size = GetSize(aPresContext);
     float pixelHeight = aPresContext->AppUnitsToFloatCSSPixels(size.height);
     aResult.SetFloatValue(pixelHeight, eCSSUnit_Pixel);
     return NS_OK;
 }
 
 inline static nsIDeviceContext*
@@ -113,35 +115,38 @@ GetDeviceSize(nsPresContext* aPresContex
         size = aPresContext->GetPageSize();
     else
         GetDeviceContextFor(aPresContext)->
             GetDeviceSurfaceDimensions(size.width, size.height);
     return size;
 }
 
 static nsresult
-GetDeviceWidth(nsPresContext* aPresContext, nsCSSValue& aResult)
+GetDeviceWidth(nsPresContext* aPresContext, const nsMediaFeature*,
+               nsCSSValue& aResult)
 {
     nsSize size = GetDeviceSize(aPresContext);
     float pixelWidth = aPresContext->AppUnitsToFloatCSSPixels(size.width);
     aResult.SetFloatValue(pixelWidth, eCSSUnit_Pixel);
     return NS_OK;
 }
 
 static nsresult
-GetDeviceHeight(nsPresContext* aPresContext, nsCSSValue& aResult)
+GetDeviceHeight(nsPresContext* aPresContext, const nsMediaFeature*,
+                nsCSSValue& aResult)
 {
     nsSize size = GetDeviceSize(aPresContext);
     float pixelHeight = aPresContext->AppUnitsToFloatCSSPixels(size.height);
     aResult.SetFloatValue(pixelHeight, eCSSUnit_Pixel);
     return NS_OK;
 }
 
 static nsresult
-GetOrientation(nsPresContext* aPresContext, nsCSSValue& aResult)
+GetOrientation(nsPresContext* aPresContext, const nsMediaFeature*,
+               nsCSSValue& aResult)
 {
     nsSize size = GetSize(aPresContext);
     PRInt32 orientation;
     if (size.width > size.height) {
         orientation = NS_STYLE_ORIENTATION_LANDSCAPE;
     } else {
         // Per spec, square viewports should be 'portrait'
         orientation = NS_STYLE_ORIENTATION_PORTRAIT;
@@ -161,30 +166,33 @@ MakeArray(const nsSize& aSize, nsCSSValu
     a->Item(0).SetIntValue(aSize.width, eCSSUnit_Integer);
     a->Item(1).SetIntValue(aSize.height, eCSSUnit_Integer);
 
     aResult.SetArrayValue(a, eCSSUnit_Array);
     return NS_OK;
 }
 
 static nsresult
-GetAspectRatio(nsPresContext* aPresContext, nsCSSValue& aResult)
+GetAspectRatio(nsPresContext* aPresContext, const nsMediaFeature*,
+               nsCSSValue& aResult)
 {
     return MakeArray(GetSize(aPresContext), aResult);
 }
 
 static nsresult
-GetDeviceAspectRatio(nsPresContext* aPresContext, nsCSSValue& aResult)
+GetDeviceAspectRatio(nsPresContext* aPresContext, const nsMediaFeature*,
+                     nsCSSValue& aResult)
 {
     return MakeArray(GetDeviceSize(aPresContext), aResult);
 }
 
 
 static nsresult
-GetColor(nsPresContext* aPresContext, nsCSSValue& aResult)
+GetColor(nsPresContext* aPresContext, const nsMediaFeature*,
+         nsCSSValue& aResult)
 {
     // FIXME:  This implementation is bogus.  nsThebesDeviceContext
     // doesn't provide reliable information (should be fixed in bug
     // 424386).
     // FIXME: On a monochrome device, return 0!
     nsIDeviceContext *dx = GetDeviceContextFor(aPresContext);
     PRUint32 depth;
     dx->GetDepth(depth);
@@ -192,59 +200,64 @@ GetColor(nsPresContext* aPresContext, ns
     // and round down, since the spec says to use the smallest when the
     // color components differ.
     depth /= 3;
     aResult.SetIntValue(PRInt32(depth), eCSSUnit_Integer);
     return NS_OK;
 }
 
 static nsresult
-GetColorIndex(nsPresContext* aPresContext, nsCSSValue& aResult)
+GetColorIndex(nsPresContext* aPresContext, const nsMediaFeature*,
+              nsCSSValue& aResult)
 {
     // We should return zero if the device does not use a color lookup
     // table.  Stuart says that our handling of displays with 8-bit
     // color is bad enough that we never change the lookup table to
     // match what we're trying to display, so perhaps we should always
     // return zero.  Given that there isn't any better information
     // exposed, we don't have much other choice.
     aResult.SetIntValue(0, eCSSUnit_Integer);
     return NS_OK;
 }
 
 static nsresult
-GetMonochrome(nsPresContext* aPresContext, nsCSSValue& aResult)
+GetMonochrome(nsPresContext* aPresContext, const nsMediaFeature*,
+              nsCSSValue& aResult)
 {
     // For color devices we should return 0.
     // FIXME: On a monochrome device, return the actual color depth, not
     // 0!
     aResult.SetIntValue(0, eCSSUnit_Integer);
     return NS_OK;
 }
 
 static nsresult
-GetResolution(nsPresContext* aPresContext, nsCSSValue& aResult)
+GetResolution(nsPresContext* aPresContext, const nsMediaFeature*,
+              nsCSSValue& aResult)
 {
     // Resolution values are in device pixels, not CSS pixels.
     nsIDeviceContext *dx = GetDeviceContextFor(aPresContext);
     float dpi = float(dx->AppUnitsPerInch()) / float(dx->AppUnitsPerDevPixel());
     aResult.SetFloatValue(dpi, eCSSUnit_Inch);
     return NS_OK;
 }
 
 static nsresult
-GetScan(nsPresContext* aPresContext, nsCSSValue& aResult)
+GetScan(nsPresContext* aPresContext, const nsMediaFeature*,
+        nsCSSValue& aResult)
 {
     // Since Gecko doesn't support the 'tv' media type, the 'scan'
     // feature is never present.
     aResult.Reset();
     return NS_OK;
 }
 
 static nsresult
-GetGrid(nsPresContext* aPresContext, nsCSSValue& aResult)
+GetGrid(nsPresContext* aPresContext, const nsMediaFeature*,
+        nsCSSValue& aResult)
 {
     // Gecko doesn't support grid devices (e.g., ttys), so the 'grid'
     // feature is always 0.
     aResult.SetIntValue(0, eCSSUnit_Integer);
     return NS_OK;
 }
 
 /*
diff --git a/layout/style/nsMediaFeatures.h b/layout/style/nsMediaFeatures.h
--- a/layout/style/nsMediaFeatures.h
+++ b/layout/style/nsMediaFeatures.h
@@ -42,17 +42,19 @@
 
 #include "nscore.h"
 
 class nsIAtom;
 class nsPresContext;
 class nsCSSValue;
 
 typedef nsresult
-(* nsMediaFeatureValueGetter)(nsPresContext* aPresContext, nsCSSValue& aResult);
+(* nsMediaFeatureValueGetter)(nsPresContext* aPresContext,
+                              const nsMediaFeature* aFeature,
+                              nsCSSValue& aResult);
 
 struct nsMediaFeature {
     nsIAtom **mName; // extra indirection to point to nsGkAtoms members
 
     enum RangeType { eMinMaxAllowed, eMinMaxNotAllowed };
     RangeType mRangeType;
 
     enum ValueType {
