Improve performance when trace-malloc is built but not used by adding a fast-path around the locking.

diff -r e7583464e251 tools/trace-malloc/lib/nsTraceMalloc.c
--- a/tools/trace-malloc/lib/nsTraceMalloc.c	Sat Feb 24 00:10:21 2007 -0800
+++ b/tools/trace-malloc/lib/nsTraceMalloc.c	Sat Feb 24 00:10:31 2007 -0800
@@ -304,6 +304,15 @@ static char      *sdlogname = NULL; /* f
  */
 static uint32 suppress_tracing = 0;
 
+/*
+ * This enables/disables trace-malloc logging.
+ *
+ * It is separate from suppress_tracing so that we do not have to pay
+ * the performance cost of repeated PR_EnterMonitor/PR_ExitMonitor and
+ * PR_IntervalNow calls when trace-malloc is disabled.
+ */
+static int tracing_enabled = 1;
+
 #define TM_ENTER_MONITOR()                                                    \
     PR_BEGIN_MACRO                                                            \
         if (tmmon)                                                            \
@@ -1478,7 +1487,7 @@ malloc(size_t size)
     PLHashEntry *he;
     allocation *alloc;
 
-    if (!PR_Initialized()) {
+    if (!PR_Initialized() || !tracing_enabled) {
         return __libc_malloc(size);
     }
 
@@ -1530,7 +1539,7 @@ calloc(size_t count, size_t size)
      *
      * Delaying NSPR calls until NSPR is initialized helps.
      */
-    if (!PR_Initialized()) {
+    if (!PR_Initialized() || !tracing_enabled) {
         return __libc_calloc(count, size);
     }
 
@@ -1576,7 +1585,7 @@ realloc(__ptr_t ptr, size_t size)
     allocation *alloc;
     FILE *trackfp = NULL;
 
-    if (!PR_Initialized()) {
+    if (!PR_Initialized() || !tracing_enabled) {
         return __libc_realloc(ptr, size);
     }
 
@@ -1670,7 +1679,7 @@ valloc(size_t size)
     PLHashEntry *he;
     allocation *alloc;
 
-    if (!PR_Initialized()) {
+    if (!PR_Initialized() || !tracing_enabled) {
         return __libc_valloc(size);
     }
 
@@ -1711,7 +1720,7 @@ memalign(size_t boundary, size_t size)
     PLHashEntry *he;
     allocation *alloc;
 
-    if (!PR_Initialized()) {
+    if (!PR_Initialized() || !tracing_enabled) {
         return __libc_memalign(boundary, size);
     }
 
@@ -1763,7 +1772,7 @@ free(__ptr_t ptr)
     uint32 serial = 0, size = 0;
     PRUint32 start, end;
 
-    if (!PR_Initialized()) {
+    if (!PR_Initialized() || !tracing_enabled) {
         __libc_free(ptr);
         return;
     }
@@ -1829,10 +1838,11 @@ PR_IMPLEMENT(void) NS_TraceMallocStartup
 {
     /* We must be running on the primordial thread. */
     PR_ASSERT(suppress_tracing == 0);
+    PR_ASSERT(tracing_enabled == 1);
     PR_ASSERT(logfp == &default_logfile);
-    suppress_tracing = (logfd < 0);
-
-    if (suppress_tracing == 0) {
+    tracing_enabled = (logfd >= 0);
+
+    if (tracing_enabled) {
         /* Log everything in logfp (aka default_logfile)'s buffer to logfd. */
         logfp->fd = logfd;
         logfile_list = &default_logfile;
@@ -1846,7 +1856,7 @@ PR_IMPLEMENT(void) NS_TraceMallocStartup
 
 #ifdef XP_WIN32
     /* Register listeners for win32. */
-    if (suppress_tracing == 0) {
+    if (tracing_enabled) {
         StartupHooker();
     }
 #endif
@@ -2029,7 +2039,7 @@ PR_IMPLEMENT(void) NS_TraceMallocShutdow
         PR_DestroyMonitor(mon);
     }
 #ifdef XP_WIN32
-    if (suppress_tracing == 0) {
+    if (tracing_enabled) {
         ShutdownHooker();
     }
 #endif
@@ -2042,14 +2052,14 @@ PR_IMPLEMENT(void) NS_TraceMallocDisable
     TM_ENTER_MONITOR();
     for (fp = logfile_list; fp; fp = fp->next)
         flush_logfile(fp);
-    suppress_tracing++;
+    tracing_enabled = 0;
     TM_EXIT_MONITOR();
 }
 
 PR_IMPLEMENT(void) NS_TraceMallocEnable()
 {
     TM_ENTER_MONITOR();
-    suppress_tracing--;
+    tracing_enabled = 1;
     TM_EXIT_MONITOR();
 }
 
@@ -2269,6 +2279,9 @@ MallocCallback(void *ptr, size_t size, P
     callsite *site;
     PLHashEntry *he;
     allocation *alloc;
+
+    if (!tracing_enabled)
+        return;
 
     TM_ENTER_MONITOR();
     tmstats.malloc_calls++;
@@ -2299,6 +2312,9 @@ CallocCallback(void *ptr, size_t count, 
     callsite *site;
     PLHashEntry *he;
     allocation *alloc;
+
+    if (!tracing_enabled)
+        return;
 
     TM_ENTER_MONITOR();
     tmstats.calloc_calls++;
@@ -2333,6 +2349,9 @@ ReallocCallback(void * oldptr, void *ptr
     PLHashEntry **hep, *he;
     allocation *alloc;
 
+    if (!tracing_enabled)
+        return;
+
     TM_ENTER_MONITOR();
     tmstats.realloc_calls++;
     if (suppress_tracing == 0) {
@@ -2402,6 +2421,9 @@ FreeCallback(void * ptr, PRUint32 start,
     PLHashEntry **hep, *he;
     callsite *site;
     allocation *alloc;
+
+    if (!tracing_enabled)
+        return;
 
     TM_ENTER_MONITOR();
     tmstats.free_calls++;
