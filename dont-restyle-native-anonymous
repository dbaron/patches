Don't restyle slow selectors for changes to native anonymous content.  (Bug 436453)

diff --git a/content/base/public/nsIContent.h b/content/base/public/nsIContent.h
--- a/content/base/public/nsIContent.h
+++ b/content/base/public/nsIContent.h
@@ -182,16 +182,35 @@ public:
         break;
       }
       content = content->GetBindingParent();
     }
     return PR_FALSE;
 #else
     return HasFlag(NODE_IS_IN_ANONYMOUS_SUBTREE);
 #endif
+  }
+
+  /**
+   * Returns true if and only if this node has a parent, but is not in
+   * its parent's child list.
+   */
+  virtual PRBool IsAnonymous() const;
+
+  /**
+   * Returns true if and only if there is NOT a path through child lists
+   * from the top of this node's parent chain back to this node.
+   */
+  PRBool IsInAnonymousSubtree() const
+  {
+    // Check IsInNativeAnonymousSubtree first only because it's faster;
+    // GetBindingParent() alone should be equivalent.
+    NS_ASSERTION(!IsInNativeAnonymousSubtree() || GetBindingParent(),
+                 "must have binding parent when in native anonymous subtree");
+    return IsInNativeAnonymousSubtree() || GetBindingParent();
   }
 
   /**
    * Get the namespace that this element's tag is defined in
    * @return the namespace
    */
   PRInt32 GetNameSpaceID() const
   {
@@ -559,18 +578,23 @@ public:
     // This is in another editable content, use the result of it.
     if (editableAncestor)
       return editableAncestor->GetDesiredIMEState();
     return IME_STATUS_ENABLE;
   }
 
   /**
    * Gets content node with the binding responsible for our construction (and
-   * existence).  Used by anonymous content (XBL-generated). null for all
-   * explicit content.
+   * existence).  Used by anonymous content (XBL-generated).
+   *
+   * For native-anonymous content, gets the root of the native anonymous
+   * subtree instead.
+   *
+   * null for all explicit content (i.e., content reachable from the top
+   * of its GetParent() chain via child lists).
    *
    * @return the binding parent
    */
   virtual nsIContent *GetBindingParent() const = 0;
 
   /**
    * Get the base URI for any relative URIs within this piece of
    * content. Generally, this is the document's base URI, but certain
diff --git a/content/base/src/nsGenericElement.cpp b/content/base/src/nsGenericElement.cpp
--- a/content/base/src/nsGenericElement.cpp
+++ b/content/base/src/nsGenericElement.cpp
@@ -441,16 +441,49 @@ nsIContent::FindFirstNonNativeAnonymous(
     } else {
       content = content->GetBindingParent();
     }
   }
 
   return possibleResult;
 }
 
+/* virtual */ PRBool nsIContent::IsAnonymous() const
+{
+  if (IsNativeAnonymous()) {
+    return PR_TRUE;
+  }
+
+  // Any node that is in an anonymous subtree has a non-null binding
+  // parent.  For native-anonymous content, the binding parent is set to
+  // the root of the native-anonymous subtree; for other anonymous
+  // content the binding parent is set to the element above that, the
+  // element with the binding.
+  nsIContent *bindingParent = GetBindingParent();
+  if (!bindingParent || bindingParent != GetParent()) {
+    return PR_FALSE;
+  }
+
+  if (!bindingParent->IsNativeAnonymous()) {
+    return PR_TRUE;
+  }
+
+  // To distinguish between the case of:
+  //   + a normal child of a native-anonymous node
+  //   + an XBL-bound anonymous child of a native-anonymous node
+  // we need to actually walk the child list.  There should really be a
+  // better way to do this.
+  for (PRUint32 i = 0, iEnd = bindingParent->GetChildCount(); i < iEnd; ++i) {
+    if (bindingParent->GetChildAt(i) == this) {
+      return PR_FALSE;
+    }
+  }
+  return PR_TRUE;
+}
+
 //----------------------------------------------------------------------
 
 nsChildContentList::~nsChildContentList()
 {
   MOZ_COUNT_DTOR(nsChildContentList);
 }
 
 NS_IMETHODIMP
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -13148,16 +13148,29 @@ nsresult nsCSSFrameConstructor::RemoveFi
   return rv;
 }
 
 void
 nsCSSFrameConstructor::RestyleForAppend(nsIContent* aContainer,
                                         PRInt32 aNewIndexInContainer)
 {
   NS_ASSERTION(aContainer, "must have container for append");
+#ifdef DEBUG
+  {
+    for (PRInt32 index = aNewIndexInContainer;; ++index) {
+      nsIContent *content = aContainer->GetChildAt(index);
+      if (!content) {
+        NS_ASSERTION(index != aNewIndexInContainer, "yikes, nothing appended");
+        break;
+      }
+      NS_ASSERTION(!content->IsAnonymous(),
+                   "anonymous nodes should not be in child lists");
+    }
+  }
+#endif
   PRUint32 selectorFlags =
     aContainer->GetFlags() & (NODE_ALL_SELECTOR_FLAGS &
                               ~NODE_HAS_SLOW_SELECTOR_NOAPPEND);
   if (selectorFlags == 0)
     return;
 
   if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
     PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
@@ -13202,16 +13215,18 @@ nsCSSFrameConstructor::RestyleForAppend(
 // notification before the removal happened (and sometimes
 // CharacterDataChanged is more like a removal than an addition).
 // The comments are written and variables are named in terms of it being
 // a ContentInserted notification.
 void
 nsCSSFrameConstructor::RestyleForInsertOrChange(nsIContent* aContainer,
                                                 nsIContent* aChild)
 {
+  NS_ASSERTION(!aChild->IsAnonymous(),
+               "anonymous nodes should not be in child lists");
   PRUint32 selectorFlags =
     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
   if (selectorFlags == 0)
     return;
 
   if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
                        NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
     PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
@@ -13281,16 +13296,18 @@ nsCSSFrameConstructor::RestyleForInsertO
   }
 }
 
 void
 nsCSSFrameConstructor::RestyleForRemove(nsIContent* aContainer,
                                         nsIContent* aOldChild,
                                         PRInt32 aIndexInContainer)
 {
+  NS_ASSERTION(!aOldChild->IsAnonymous(),
+               "anonymous nodes should not be in child lists");
   PRUint32 selectorFlags =
     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
   if (selectorFlags == 0)
     return;
 
   if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
                        NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
     PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -4622,17 +4622,17 @@ PresShell::CharacterDataChanged(nsIDocum
   }
 
   // Call this here so it only happens for real content mutations and
   // not cases when the frame constructor calls its own methods to force
   // frame reconstruction.
   nsIContent *container = aContent->GetParent();
   PRUint32 selectorFlags =
     container ? (container->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
-  if (selectorFlags != 0) {
+  if (selectorFlags != 0 && !aContent->IsAnonymous()) {
     PRUint32 index;
     if (aInfo->mAppend &&
         container->GetChildAt((index = container->GetChildCount() - 1)) ==
           aContent)
       mFrameConstructor->RestyleForAppend(container, index);
     else
       mFrameConstructor->RestyleForInsertOrChange(container, aContent);
   }
