diff --git a/Makefile.in b/Makefile.in
--- a/Makefile.in
+++ b/Makefile.in
@@ -91,8 +91,8 @@ include $(topsrcdir)/config/rules.mk
 
 # After we build tier toolkit, go back and build the tools from previous dirs
 tier_toolkit::
+	$(MAKE) tools_tier_xpcom
 	$(MAKE) tools_tier_js
-	$(MAKE) tools_tier_xpcom
 	$(MAKE) tools_tier_necko
 	$(MAKE) tools_tier_gecko
 	$(MAKE) tools_tier_toolkit
diff --git a/js/src/Makefile.in b/js/src/Makefile.in
--- a/js/src/Makefile.in
+++ b/js/src/Makefile.in
@@ -162,7 +162,7 @@ DASH_R		= -r
 
 include $(topsrcdir)/config/config.mk
 
-EXTRA_DSO_LDOPTS += $(NSPR_LIBS)
+EXTRA_DSO_LDOPTS += $(NSPR_LIBS) $(XPCOM_LIBS)
 
 # When using gcc the assembly is inlined in the C-file (see jslock.c)
 ifeq ($(OS_ARCH),SunOS)
diff --git a/js/src/jsapi.c b/js/src/jsapi.c
--- a/js/src/jsapi.c
+++ b/js/src/jsapi.c
@@ -88,6 +88,10 @@
 
 #if JS_HAS_GENERATORS
 #include "jsiter.h"
+#endif
+
+#ifdef MOZILLA_CLIENT
+#include "nsTraceRefcnt.h"
 #endif
 
 #ifdef HAVE_VA_LIST_AS_ARRAY
@@ -3996,13 +4000,16 @@ JS_PUBLIC_API(jsrefcount)
 JS_PUBLIC_API(jsrefcount)
 JS_HoldPrincipals(JSContext *cx, JSPrincipals *principals)
 {
-    return JS_ATOMIC_INCREMENT(&principals->refcount);
+    jsrefcount rc = JS_ATOMIC_INCREMENT(&principals->refcount);
+    NS_LOG_ADDREF(principals, rc, "JSPrincipals", sizeof(JSPrincipals));
+    return rc;
 }
 
 JS_PUBLIC_API(jsrefcount)
 JS_DropPrincipals(JSContext *cx, JSPrincipals *principals)
 {
     jsrefcount rc = JS_ATOMIC_DECREMENT(&principals->refcount);
+    NS_LOG_RELEASE(principals, rc, "JSPrincipals");
     if (rc == 0)
         principals->destroy(cx, principals);
     return rc;
diff --git a/js/src/jsgc.c b/js/src/jsgc.c
--- a/js/src/jsgc.c
+++ b/js/src/jsgc.c
@@ -73,6 +73,10 @@
 #include "jsscope.h"
 #include "jsscript.h"
 #include "jsstr.h"
+
+#ifdef MOZILLA_CLIENT
+#include "nsTraceRefcnt.h"
+#endif
 
 #if JS_HAS_XML_SUPPORT
 #include "jsxml.h"
@@ -1210,6 +1214,11 @@ js_NewGCThing(JSContext *cx, uintN flags
 #ifdef JS_THREADSAFE
   success:
 #endif
+
+#if defined(TOO_MUCH_GC) && defined(MOZILLA_CLIENT)
+    NS_LogCtor(thing, "JSGCThing", sizeof(JSGCThing));
+#endif
+
     lrs = cx->localRootStack;
     if (lrs) {
         /*
@@ -1235,10 +1244,20 @@ js_NewGCThing(JSContext *cx, uintN flags
          * depending on a pigeon-hole newborn per type per context.
          */
         cx->weakRoots.newborn[flags & GCF_TYPEMASK] = thing;
+/* XXXldb Should this be checked in? */
+#ifdef WAY_TOO_MUCH_GC
+        rt->gcPoke = JS_TRUE;
+#endif
     }
 
     /* We can't fail now, so update flags. */
     *flagp = (uint8)flags;
+
+#ifdef MOZILLA_CLIENT
+    if (flags & GCF_LOCK) {
+        NS_LOG_ADDREF(thing, 1, "js_LockGCThing", 1);
+    }
+#endif
 
     /*
      * Clear thing before unlocking in case a GC run is about to scan it,
@@ -1372,7 +1391,15 @@ js_LockGCThingRT(JSRuntime *rt, void *th
             JS_ASSERT(lhe->count >= 1);
             lhe->count++;
         }
-    }
+#ifdef MOZILLA_CLIENT
+        NS_LOG_ADDREF(thing, lhe->count, "js_LockGCThing", 1);
+#endif
+    }
+#ifdef MOZILLA_CLIENT
+    else {
+        NS_LOG_ADDREF(thing, 1, "js_LockGCThing", 1);
+    }
+#endif
 
     *flagp = (uint8)(flags | GCF_LOCK);
     METER(rt->gcStats.lock++);
@@ -1403,8 +1430,14 @@ js_UnlockGCThingRT(JSRuntime *rt, void *
              JS_DHASH_ENTRY_IS_FREE(&lhe->hdr))) {
             /* Shallow GC-thing with an implicit lock count of 1. */
             JS_ASSERT(!GC_THING_IS_DEEP(flags & GCF_TYPEMASK, thing));
+#ifdef MOZILLA_CLIENT
+            NS_LOG_RELEASE(thing, 0, "js_LockGCThing");
+#endif
         } else {
             /* Basis or nested unlock of a deep thing, or nested of shallow. */
+#ifdef MOZILLA_CLIENT
+            NS_LOG_RELEASE(thing, lhe->count - 1, "js_LockGCThing");
+#endif
             if (--lhe->count != 0)
                 goto out;
             JS_DHashTableOperate(rt->gcLocksHash, thing, JS_DHASH_REMOVE);
@@ -2356,6 +2389,10 @@ restart:
     JS_ASSERT(!rt->gcUnscannedArenaStackTop);
     JS_ASSERT(rt->gcUnscannedBagSize == 0);
 
+#ifdef DEBUG_dbaron_off
+    printf("Doing JS GC.\n");
+#endif
+
     /*
      * Mark phase.
      */
@@ -2433,6 +2470,11 @@ restart:
                 if (flags & GCF_MARK) {
                     *flagp &= ~GCF_MARK;
                 } else if (!(flags & (GCF_LOCK | GCF_FINAL))) {
+#if defined(TOO_MUCH_GC) && defined(MOZILLA_CLIENT)
+                    NS_LogDtor(firstPage + offset,
+                               "JSGCThing", sizeof(JSGCThing));
+#endif
+
                     /* Call the finalizer with GCF_FINAL ORed into flags. */
                     type = flags & GCF_TYPEMASK;
                     finalizer = gc_finalizers[type];
diff --git a/js/src/jsscript.c b/js/src/jsscript.c
--- a/js/src/jsscript.c
+++ b/js/src/jsscript.c
@@ -62,6 +62,10 @@
 #include "jsxdrapi.h"
 #endif
 
+#ifdef MOZILLA_CLIENT
+#include "nsTraceRefcnt.h"
+#endif
+
 #if JS_HAS_SCRIPT_OBJECT
 
 static const char js_script_exec[] = "Script.prototype.exec";
@@ -526,6 +530,9 @@ js_XDRScript(JSXDRState *xdr, JSScript *
             if (!cx->runtime->principalsTranscoder(xdr, &principals))
                 goto error;
             script->principals = principals;
+#if defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+            NS_LogOwnerAddRef(script, script->principals);
+#endif
         }
     }
 
@@ -1404,6 +1411,9 @@ js_NewScriptFromCG(JSContext *cx, JSCode
     if (cg->principals) {
         script->principals = cg->principals;
         JSPRINCIPALS_HOLD(cx, script->principals);
+#if defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+        NS_LogOwnerAddRef(script, script->principals);
+#endif
     }
 
     if (!js_FinishTakingSrcNotes(cx, cg, SCRIPT_NOTES(script)))
@@ -1465,8 +1475,12 @@ js_DestroyScript(JSContext *cx, JSScript
     js_CallDestroyScriptHook(cx, script);
 
     JS_ClearScriptTraps(cx, script);
-    if (script->principals)
+    if (script->principals) {
+#if defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+        NS_LogOwnerRelease(script, script->principals);
+#endif
         JSPRINCIPALS_DROP(cx, script->principals);
+    }
     if (JS_GSN_CACHE(cx).script == script)
         JS_CLEAR_GSN_CACHE(cx);
     JS_free(cx, script);
diff --git a/toolkit/toolkit-tiers.mk b/toolkit/toolkit-tiers.mk
--- a/toolkit/toolkit-tiers.mk
+++ b/toolkit/toolkit-tiers.mk
@@ -40,8 +40,8 @@ endif
 endif
 
 include $(topsrcdir)/config/nspr/build.mk
+include $(topsrcdir)/xpcom/build.mk
 include $(topsrcdir)/js/src/build.mk
-include $(topsrcdir)/xpcom/build.mk
 include $(topsrcdir)/netwerk/build.mk
 
 TIERS += \
diff --git a/xpcom/base/nsTraceRefcntImpl.cpp b/xpcom/base/nsTraceRefcntImpl.cpp
--- a/xpcom/base/nsTraceRefcntImpl.cpp
+++ b/xpcom/base/nsTraceRefcntImpl.cpp
@@ -1174,7 +1174,15 @@ NS_LogCOMPtrAddRef(void* aCOMPtr, nsISup
 #if defined(NS_IMPL_REFCNT_LOGGING) && defined(HAVE_CPP_DYNAMIC_CAST_TO_VOID_PTR)
   // Get the most-derived object.
   void *object = dynamic_cast<void *>(aObject);
-
+  NS_LogOwnerAddRef(aCOMPtr, object);
+#endif
+}
+
+
+EXPORT_XPCOM_API(void)
+NS_LogOwnerAddRef(void* aOwner, void* object)
+{
+#if defined(NS_IMPL_REFCNT_LOGGING)
   // This is a very indirect way of finding out what the class is
   // of the object being logged.  If we're logging a specific type,
   // then 
@@ -1199,7 +1207,7 @@ NS_LogCOMPtrAddRef(void* aCOMPtr, nsISup
 
     if (gCOMPtrLog && loggingThisObject) {
       fprintf(gCOMPtrLog, "\n<?> 0x%08X %d nsCOMPtrAddRef %d 0x%08X\n",
-              NS_PTR_TO_INT32(object), serialno, count?(*count):-1, NS_PTR_TO_INT32(aCOMPtr));
+              NS_PTR_TO_INT32(object), serialno, count?(*count):-1, NS_PTR_TO_INT32(aOwner));
       nsTraceRefcntImpl::WalkTheStack(gCOMPtrLog);
     }
 
@@ -1215,7 +1223,14 @@ NS_LogCOMPtrRelease(void* aCOMPtr, nsISu
 #if defined(NS_IMPL_REFCNT_LOGGING) && defined(HAVE_CPP_DYNAMIC_CAST_TO_VOID_PTR)
   // Get the most-derived object.
   void *object = dynamic_cast<void *>(aObject);
-
+  NS_LogOwnerRelease(aCOMPtr, object);
+#endif
+}
+
+EXPORT_XPCOM_API(void)
+NS_LogOwnerRelease(void* aOwner, void* object)
+{
+#if defined(NS_IMPL_REFCNT_LOGGING)
   // This is a very indirect way of finding out what the class is
   // of the object being logged.  If we're logging a specific type,
   // then 
@@ -1240,7 +1255,7 @@ NS_LogCOMPtrRelease(void* aCOMPtr, nsISu
 
     if (gCOMPtrLog && loggingThisObject) {
       fprintf(gCOMPtrLog, "\n<?> 0x%08X %d nsCOMPtrRelease %d 0x%08X\n",
-              NS_PTR_TO_INT32(object), serialno, count?(*count):-1, NS_PTR_TO_INT32(aCOMPtr));
+              NS_PTR_TO_INT32(object), serialno, count?(*count):-1, NS_PTR_TO_INT32(aOwner));
       nsTraceRefcntImpl::WalkTheStack(gCOMPtrLog);
     }
 
diff --git a/xpcom/build/nsXPCOM.h b/xpcom/build/nsXPCOM.h
--- a/xpcom/build/nsXPCOM.h
+++ b/xpcom/build/nsXPCOM.h
@@ -64,6 +64,8 @@
 # define NS_LogDtor                  NS_LogDtor_P
 # define NS_LogCOMPtrAddRef          NS_LogCOMPtrAddRef_P
 # define NS_LogCOMPtrRelease         NS_LogCOMPtrRelease_P
+# define NS_LogOwnerAddRef           NS_LogOwnerAddRef_P
+# define NS_LogOwnerRelease          NS_LogOwnerRelease_P
 #endif
 
 #include "nscore.h"
@@ -454,6 +456,21 @@ NS_LogCOMPtrRelease(void *aCOMPtr, nsISu
 NS_LogCOMPtrRelease(void *aCOMPtr, nsISupports *aObject);
 
 /**
+ * Log reference counting performed on behalf of an owner other than an
+ * nsCOMPtr, for a non-nsISupports object (i.e., the pointer must be
+ * accurate and cannot be a pointer to an offset interface).  Processing
+ * tools can use the stacktraces printed by these functions to simplify
+ * reports about leaked objects generated from the data printed by
+ * NS_LogAddRef/NS_LogRelease.
+ */
+
+XPCOM_API(void)
+NS_LogOwnerAddRef(void *aOwner, void *aObject);
+
+XPCOM_API(void)
+NS_LogOwnerRelease(void *aOwner, void *aObject);
+
+/**
  * Categories (in the category manager service) used by XPCOM:
  */
 
diff --git a/xpcom/build/nsXPCOMPrivate.h b/xpcom/build/nsXPCOMPrivate.h
--- a/xpcom/build/nsXPCOMPrivate.h
+++ b/xpcom/build/nsXPCOMPrivate.h
@@ -110,6 +110,7 @@ typedef void       (* LogReleaseFunc)(vo
 typedef void       (* LogReleaseFunc)(void*, nsrefcnt, const char*);
 typedef void       (* LogCtorFunc)(void*, const char*, PRUint32);
 typedef void       (* LogCOMPtrFunc)(void*, nsISupports*);
+typedef void       (* LogOwnerFunc)(void*, void*);
 
 typedef nsresult   (* GetXPTCallStubFunc)(REFNSIID, nsIXPTCProxy*, nsISomeInterface**);
 typedef void       (* DestroyXPTCallStubFunc)(nsISomeInterface*);
@@ -183,6 +184,8 @@ typedef struct XPCOMFunctions{
     DestroyXPTCallStubFunc destroyXPTCallStubFunc;
     InvokeByIndexFunc invokeByIndexFunc;
 
+    LogOwnerFunc logOwnerAddRefFunc;
+    LogOwnerFunc logOwnerReleaseFunc;
 } XPCOMFunctions;
 
 typedef nsresult (PR_CALLBACK *GetFrozenFunctionsFunc)(XPCOMFunctions *entryPoints, const char* libraryPath);
diff --git a/xpcom/stub/nsXPComStub.cpp b/xpcom/stub/nsXPComStub.cpp
--- a/xpcom/stub/nsXPComStub.cpp
+++ b/xpcom/stub/nsXPComStub.cpp
@@ -115,6 +115,9 @@ static const XPCOMFunctions kFrozenFunct
     &NS_GetXPTCallStub_P,
     &NS_DestroyXPTCallStub_P,
     &NS_InvokeByIndex_P
+
+    , &NS_LogOwnerAddRef_P
+    , &NS_LogOwnerRelease_P
 };
 
 EXPORT_XPCOM_API(nsresult)
@@ -336,6 +339,20 @@ NS_InvokeByIndex(nsISupports* that, PRUi
                  PRUint32 paramCount, nsXPTCVariant* params)
 {
   return NS_InvokeByIndex_P(that, methodIndex, paramCount, params);
+}
+
+#undef NS_LogOwnerAddRef
+EXPORT_XPCOM_API(void)
+NS_LogOwnerAddRef(void *aOwner, void* aObject)
+{
+  NS_LogOwnerAddRef_P(aOwner, aObject);
+}
+
+#undef NS_LogOwnerRelease
+EXPORT_XPCOM_API(void)
+NS_LogOwnerRelease(void *aOwner, void* aObject)
+{
+  NS_LogOwnerRelease_P(aOwner, aObject);
 }
 
 /*
