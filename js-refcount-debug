diff --git a/Makefile.in b/Makefile.in
--- a/Makefile.in
+++ b/Makefile.in
@@ -87,8 +87,8 @@ include $(topsrcdir)/config/rules.mk
 
 # After we build tier toolkit, go back and build the tools from previous dirs
 tier_toolkit::
+	$(MAKE) tools_tier_xpcom
 	$(MAKE) tools_tier_js
-	$(MAKE) tools_tier_xpcom
 	$(MAKE) tools_tier_necko
 	$(MAKE) tools_tier_gecko
 	$(MAKE) tools_tier_toolkit
diff --git a/js/src/Makefile.in b/js/src/Makefile.in
--- a/js/src/Makefile.in
+++ b/js/src/Makefile.in
@@ -180,7 +180,7 @@ endif
 
 include $(topsrcdir)/config/config.mk
 
-EXTRA_DSO_LDOPTS += $(NSPR_LIBS)
+EXTRA_DSO_LDOPTS += $(NSPR_LIBS) $(XPCOM_LIBS)
 
 # When using gcc the assembly is inlined in the C-file (see jslock.c)
 ifeq ($(OS_ARCH),SunOS)
diff --git a/js/src/jsapi.c b/js/src/jsapi.c
--- a/js/src/jsapi.c
+++ b/js/src/jsapi.c
@@ -85,6 +85,10 @@
 
 #if JS_HAS_XML_SUPPORT
 #include "jsxml.h"
+#endif
+
+#ifdef MOZILLA_CLIENT
+#include "nsTraceRefcnt.h"
 #endif
 
 #ifdef HAVE_VA_LIST_AS_ARRAY
@@ -4017,13 +4021,16 @@ JS_PUBLIC_API(jsrefcount)
 JS_PUBLIC_API(jsrefcount)
 JS_HoldPrincipals(JSContext *cx, JSPrincipals *principals)
 {
-    return JS_ATOMIC_INCREMENT(&principals->refcount);
+    jsrefcount rc = JS_ATOMIC_INCREMENT(&principals->refcount);
+    NS_LOG_ADDREF(principals, rc, "JSPrincipals", sizeof(JSPrincipals));
+    return rc;
 }
 
 JS_PUBLIC_API(jsrefcount)
 JS_DropPrincipals(JSContext *cx, JSPrincipals *principals)
 {
     jsrefcount rc = JS_ATOMIC_DECREMENT(&principals->refcount);
+    NS_LOG_RELEASE(principals, rc, "JSPrincipals");
     if (rc == 0)
         principals->destroy(cx, principals);
     return rc;
diff --git a/js/src/jsgc.c b/js/src/jsgc.c
--- a/js/src/jsgc.c
+++ b/js/src/jsgc.c
@@ -73,6 +73,10 @@
 #include "jsscope.h"
 #include "jsscript.h"
 #include "jsstr.h"
+
+#ifdef MOZILLA_CLIENT
+#include "nsTraceRefcnt.h"
+#endif
 
 #if JS_HAS_XML_SUPPORT
 #include "jsxml.h"
@@ -1483,6 +1487,11 @@ js_NewGCThing(JSContext *cx, uintN flags
 #ifdef JS_THREADSAFE
   success:
 #endif
+
+#if defined(TOO_MUCH_GC) && defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+    NS_LogCtor(thing, "JSGCThing", sizeof(JSGCThing));
+#endif
+
     lrs = cx->localRootStack;
     if (lrs) {
         /*
@@ -1508,10 +1517,20 @@ js_NewGCThing(JSContext *cx, uintN flags
          * depending on a pigeon-hole newborn per type per context.
          */
         cx->weakRoots.newborn[flags & GCF_TYPEMASK] = thing;
+/* XXXldb Should this be checked in? */
+#ifdef WAY_TOO_MUCH_GC
+        rt->gcPoke = JS_TRUE;
+#endif
     }
 
     /* We can't fail now, so update flags. */
     *flagp = (uint8)flags;
+
+#ifdef MOZILLA_CLIENT
+    if (flags & GCF_LOCK) {
+        NS_LOG_ADDREF(thing, 1, "js_LockGCThing", 1);
+    }
+#endif
 
 #ifdef DEBUG_gchist
     gchist[gchpos].lastDitch = doGC;
@@ -1639,7 +1658,15 @@ js_LockGCThingRT(JSRuntime *rt, void *th
             JS_ASSERT(lhe->count >= 1);
             lhe->count++;
         }
-    }
+#ifdef MOZILLA_CLIENT
+        NS_LOG_ADDREF(thing, lhe->count, "js_LockGCThing", 1);
+#endif
+    }
+#ifdef MOZILLA_CLIENT
+    else {
+        NS_LOG_ADDREF(thing, 1, "js_LockGCThing", 1);
+    }
+#endif
 
     *flagp = (uint8)(flags | GCF_LOCK);
     METER(rt->gcStats.lock++);
@@ -1670,8 +1697,14 @@ js_UnlockGCThingRT(JSRuntime *rt, void *
              JS_DHASH_ENTRY_IS_FREE(&lhe->hdr))) {
             /* Shallow GC-thing with an implicit lock count of 1. */
             JS_ASSERT(!GC_THING_IS_DEEP(flags & GCF_TYPEMASK, thing));
+#ifdef MOZILLA_CLIENT
+            NS_LOG_RELEASE(thing, 0, "js_LockGCThing");
+#endif
         } else {
             /* Basis or nested unlock of a deep thing, or nested of shallow. */
+#ifdef MOZILLA_CLIENT
+            NS_LOG_RELEASE(thing, lhe->count - 1, "js_LockGCThing");
+#endif
             if (--lhe->count != 0)
                 goto out;
             JS_DHashTableOperate(rt->gcLocksHash, thing, JS_DHASH_REMOVE);
@@ -2536,6 +2569,10 @@ restart:
     JS_ASSERT(!rt->gcUntracedArenaStackTop);
     JS_ASSERT(rt->gcTraceLaterCount == 0);
 
+#ifdef DEBUG_dbaron_off
+    printf("Doing JS GC.\n");
+#endif
+
     /*
      * Mark phase.
      */
@@ -2634,6 +2671,10 @@ restart:
                 } else if (!(flags & GCF_FINAL)) {
                     /* Call the finalizer with GCF_FINAL ORed into flags. */
                     thing = FLAGP_TO_THING(flagp, thingSize);
+#if defined(TOO_MUCH_GC) && defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+                    NS_LogDtor(thing, "JSGCThing", sizeof(JSGCThing));
+#endif
+
                     *flagp = (uint8)(flags | GCF_FINAL);
                     type = flags & GCF_TYPEMASK;
                     switch (type) {
diff --git a/js/src/jsscript.c b/js/src/jsscript.c
--- a/js/src/jsscript.c
+++ b/js/src/jsscript.c
@@ -63,6 +63,10 @@
 #include "jsxdrapi.h"
 #endif
 
+#ifdef MOZILLA_CLIENT
+#include "nsTraceRefcnt.h"
+#endif
+
 #if JS_HAS_SCRIPT_OBJECT
 
 static const char js_script_exec_str[]    = "Script.prototype.exec";
@@ -541,6 +545,9 @@ js_XDRScript(JSXDRState *xdr, JSScript *
             if (!cx->runtime->principalsTranscoder(xdr, &principals))
                 goto error;
             script->principals = principals;
+#if defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+            NS_LogOwnerAddRef(script, script->principals);
+#endif
         }
     }
 
@@ -1324,6 +1331,9 @@ js_NewScript(JSContext *cx, uint32 lengt
     script = (JSScript *) JS_malloc(cx, size);
     if (!script)
         return NULL;
+#if defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+    NS_LogCtor(script, "JSScript", sizeof(*script));
+#endif
     memset(script, 0, sizeof(JSScript));
     script->length = length;
     script->version = cx->version;
@@ -1425,8 +1435,12 @@ js_NewScriptFromCG(JSContext *cx, JSCode
     script->lineno = cg->firstLine;
     script->depth = cg->maxStackDepth;
     script->principals = cg->treeContext.parseContext->principals;
-    if (script->principals)
+    if (script->principals) {
         JSPRINCIPALS_HOLD(cx, script->principals);
+#if defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+        NS_LogOwnerAddRef(script, script->principals);
+#endif
+    }
 
     if (!js_FinishTakingSrcNotes(cx, cg, SCRIPT_NOTES(script)))
         goto bad;
@@ -1484,11 +1498,18 @@ void
 void
 js_DestroyScript(JSContext *cx, JSScript *script)
 {
+#if defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+    NS_LogDtor(script, "JSScript", sizeof(*script));
+#endif
     js_CallDestroyScriptHook(cx, script);
 
     JS_ClearScriptTraps(cx, script);
-    if (script->principals)
+    if (script->principals) {
+#if defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+        NS_LogOwnerRelease(script, script->principals);
+#endif
         JSPRINCIPALS_DROP(cx, script->principals);
+    }
     if (JS_GSN_CACHE(cx).script == script)
         JS_CLEAR_GSN_CACHE(cx);
     JS_free(cx, script);
diff --git a/toolkit/toolkit-tiers.mk b/toolkit/toolkit-tiers.mk
--- a/toolkit/toolkit-tiers.mk
+++ b/toolkit/toolkit-tiers.mk
@@ -40,8 +40,8 @@ endif
 endif
 
 include $(topsrcdir)/config/nspr/build.mk
+include $(topsrcdir)/xpcom/build.mk
 include $(topsrcdir)/js/src/build.mk
-include $(topsrcdir)/xpcom/build.mk
 include $(topsrcdir)/netwerk/build.mk
 
 TIERS += \
diff --git a/xpcom/base/nsTraceRefcntImpl.cpp b/xpcom/base/nsTraceRefcntImpl.cpp
--- a/xpcom/base/nsTraceRefcntImpl.cpp
+++ b/xpcom/base/nsTraceRefcntImpl.cpp
@@ -930,7 +930,7 @@ NS_LogAddRef(void* aPtr, nsrefcnt aRefcn
     PRBool loggingThisType = (!gTypesToLog || LogThisType(aClazz));
     PRInt32 serialno = 0;
     if (gSerialNumbers && loggingThisType) {
-      serialno = GetSerialNumber(aPtr, aRefcnt == 1);
+      serialno = GetSerialNumber(aPtr, PR_TRUE);
       PRInt32* count = GetRefCount(aPtr);
       if(count)
         (*count)++;
@@ -981,7 +981,7 @@ NS_LogRelease(void* aPtr, nsrefcnt aRefc
     PRBool loggingThisType = (!gTypesToLog || LogThisType(aClazz));
     PRInt32 serialno = 0;
     if (gSerialNumbers && loggingThisType) {
-      serialno = GetSerialNumber(aPtr, PR_FALSE);
+      serialno = GetSerialNumber(aPtr, PR_TRUE);
       PRInt32* count = GetRefCount(aPtr);
       if(count)
         (*count)--;
@@ -1079,7 +1079,7 @@ NS_LogDtor(void* aPtr, const char* aType
     PRBool loggingThisType = (!gTypesToLog || LogThisType(aType));
     PRInt32 serialno = 0;
     if (gSerialNumbers && loggingThisType) {
-      serialno = GetSerialNumber(aPtr, PR_FALSE);
+      serialno = GetSerialNumber(aPtr, PR_TRUE);
       RecycleSerialNumberPtr(aPtr);
     }
 
@@ -1105,7 +1105,15 @@ NS_LogCOMPtrAddRef(void* aCOMPtr, nsISup
 #if defined(NS_IMPL_REFCNT_LOGGING) && defined(HAVE_CPP_DYNAMIC_CAST_TO_VOID_PTR)
   // Get the most-derived object.
   void *object = dynamic_cast<void *>(aObject);
-
+  NS_LogOwnerAddRef(aCOMPtr, object);
+#endif
+}
+
+
+EXPORT_XPCOM_API(void)
+NS_LogOwnerAddRef(void* aOwner, void* object)
+{
+#if defined(NS_IMPL_REFCNT_LOGGING)
   // This is a very indirect way of finding out what the class is
   // of the object being logged.  If we're logging a specific type,
   // then 
@@ -1130,7 +1138,7 @@ NS_LogCOMPtrAddRef(void* aCOMPtr, nsISup
 
     if (gCOMPtrLog && loggingThisObject) {
       fprintf(gCOMPtrLog, "\n<?> 0x%08X %d nsCOMPtrAddRef %d 0x%08X\n",
-              NS_PTR_TO_INT32(object), serialno, count?(*count):-1, NS_PTR_TO_INT32(aCOMPtr));
+              NS_PTR_TO_INT32(object), serialno, count?(*count):-1, NS_PTR_TO_INT32(aOwner));
       nsTraceRefcntImpl::WalkTheStack(gCOMPtrLog);
     }
 
@@ -1146,7 +1154,14 @@ NS_LogCOMPtrRelease(void* aCOMPtr, nsISu
 #if defined(NS_IMPL_REFCNT_LOGGING) && defined(HAVE_CPP_DYNAMIC_CAST_TO_VOID_PTR)
   // Get the most-derived object.
   void *object = dynamic_cast<void *>(aObject);
-
+  NS_LogOwnerRelease(aCOMPtr, object);
+#endif
+}
+
+EXPORT_XPCOM_API(void)
+NS_LogOwnerRelease(void* aOwner, void* object)
+{
+#if defined(NS_IMPL_REFCNT_LOGGING)
   // This is a very indirect way of finding out what the class is
   // of the object being logged.  If we're logging a specific type,
   // then 
@@ -1171,7 +1186,7 @@ NS_LogCOMPtrRelease(void* aCOMPtr, nsISu
 
     if (gCOMPtrLog && loggingThisObject) {
       fprintf(gCOMPtrLog, "\n<?> 0x%08X %d nsCOMPtrRelease %d 0x%08X\n",
-              NS_PTR_TO_INT32(object), serialno, count?(*count):-1, NS_PTR_TO_INT32(aCOMPtr));
+              NS_PTR_TO_INT32(object), serialno, count?(*count):-1, NS_PTR_TO_INT32(aOwner));
       nsTraceRefcntImpl::WalkTheStack(gCOMPtrLog);
     }
 
diff --git a/xpcom/build/nsXPCOM.h b/xpcom/build/nsXPCOM.h
--- a/xpcom/build/nsXPCOM.h
+++ b/xpcom/build/nsXPCOM.h
@@ -66,6 +66,8 @@
 # define NS_LogCOMPtrRelease         NS_LogCOMPtrRelease_P
 # define NS_CycleCollectorSuspect    NS_CycleCollectorSuspect_P
 # define NS_CycleCollectorForget     NS_CycleCollectorForget_P
+# define NS_LogOwnerAddRef           NS_LogOwnerAddRef_P
+# define NS_LogOwnerRelease          NS_LogOwnerRelease_P
 #endif
 
 #include "nscore.h"
@@ -467,6 +469,21 @@ NS_CycleCollectorForget(nsISupports *n);
 NS_CycleCollectorForget(nsISupports *n);
 
 /**
+ * Log reference counting performed on behalf of an owner other than an
+ * nsCOMPtr, for a non-nsISupports object (i.e., the pointer must be
+ * accurate and cannot be a pointer to an offset interface).  Processing
+ * tools can use the stacktraces printed by these functions to simplify
+ * reports about leaked objects generated from the data printed by
+ * NS_LogAddRef/NS_LogRelease.
+ */
+
+XPCOM_API(void)
+NS_LogOwnerAddRef(void *aOwner, void *aObject);
+
+XPCOM_API(void)
+NS_LogOwnerRelease(void *aOwner, void *aObject);
+
+/**
  * Categories (in the category manager service) used by XPCOM:
  */
 
diff --git a/xpcom/build/nsXPCOMPrivate.h b/xpcom/build/nsXPCOMPrivate.h
--- a/xpcom/build/nsXPCOMPrivate.h
+++ b/xpcom/build/nsXPCOMPrivate.h
@@ -114,6 +114,7 @@ typedef void       (* LogReleaseFunc)(vo
 typedef void       (* LogReleaseFunc)(void*, nsrefcnt, const char*);
 typedef void       (* LogCtorFunc)(void*, const char*, PRUint32);
 typedef void       (* LogCOMPtrFunc)(void*, nsISupports*);
+typedef void       (* LogOwnerFunc)(void*, void*);
 
 typedef nsresult   (* GetXPTCallStubFunc)(REFNSIID, nsIXPTCProxy*, nsISomeInterface**);
 typedef void       (* DestroyXPTCallStubFunc)(nsISomeInterface*);
@@ -194,6 +195,8 @@ typedef struct XPCOMFunctions{
     CStringSetIsVoidFunc cstringSetIsVoid;
     CStringGetIsVoidFunc cstringGetIsVoid;
 
+    LogOwnerFunc logOwnerAddRefFunc;
+    LogOwnerFunc logOwnerReleaseFunc;
 } XPCOMFunctions;
 
 typedef nsresult (PR_CALLBACK *GetFrozenFunctionsFunc)(XPCOMFunctions *entryPoints, const char* libraryPath);
diff --git a/xpcom/glue/standalone/nsXPCOMGlue.cpp b/xpcom/glue/standalone/nsXPCOMGlue.cpp
--- a/xpcom/glue/standalone/nsXPCOMGlue.cpp
+++ b/xpcom/glue/standalone/nsXPCOMGlue.cpp
@@ -564,3 +564,18 @@ NS_CycleCollectorForget(nsISupports* obj
 
     return xpcomFunctions.cycleForgetFunc(obj);
 }
+
+XPCOM_API(void)
+NS_LogOwnerAddRef(void *aOwner, void *aObject)
+{
+    if (xpcomFunctions.logOwnerAddRefFunc)
+        xpcomFunctions.logOwnerAddRefFunc(aOwner, aObject);
+}
+
+XPCOM_API(void)
+NS_LogOwnerRelease(void *aOwner, void *aObject)
+{
+    if (xpcomFunctions.logOwnerReleaseFunc)
+        xpcomFunctions.logOwnerReleaseFunc(aOwner, aObject);
+}
+
diff --git a/xpcom/stub/nsXPComStub.cpp b/xpcom/stub/nsXPComStub.cpp
--- a/xpcom/stub/nsXPComStub.cpp
+++ b/xpcom/stub/nsXPComStub.cpp
@@ -120,7 +120,9 @@ static const XPCOMFunctions kFrozenFunct
     &NS_StringSetIsVoid_P,
     &NS_StringGetIsVoid_P,
     &NS_CStringSetIsVoid_P,
-    &NS_CStringGetIsVoid_P
+    &NS_CStringGetIsVoid_P,
+    &NS_LogOwnerAddRef_P,
+    &NS_LogOwnerRelease_P
 };
 
 EXPORT_XPCOM_API(nsresult)
@@ -342,6 +344,20 @@ NS_InvokeByIndex(nsISupports* that, PRUi
                  PRUint32 paramCount, nsXPTCVariant* params)
 {
   return NS_InvokeByIndex_P(that, methodIndex, paramCount, params);
+}
+
+#undef NS_LogOwnerAddRef
+EXPORT_XPCOM_API(void)
+NS_LogOwnerAddRef(void *aOwner, void* aObject)
+{
+  NS_LogOwnerAddRef_P(aOwner, aObject);
+}
+
+#undef NS_LogOwnerRelease
+EXPORT_XPCOM_API(void)
+NS_LogOwnerRelease(void *aOwner, void* aObject)
+{
+  NS_LogOwnerRelease_P(aOwner, aObject);
 }
 
 /*
