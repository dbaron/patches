Various changes for debugging JavaScript-related leaks through nsTraceRefcnt.

diff --git a/Makefile.in b/Makefile.in
--- a/Makefile.in
+++ b/Makefile.in
@@ -92,18 +92,18 @@ export::
 	$(RM) -rf $(DIST)/sdk
 	$(MAKE) -C config export
 	$(MAKE) tier_nspr
 
 include $(topsrcdir)/config/rules.mk
 
 # After we build tier toolkit, go back and build the tools from previous dirs
 tier_toolkit::
+	$(MAKE) tools_tier_xpcom
 	$(MAKE) tools_tier_js
-	$(MAKE) tools_tier_xpcom
 	$(MAKE) tools_tier_necko
 	$(MAKE) tools_tier_gecko
 	$(MAKE) tools_tier_toolkit
 
 ifeq (netwerk,$(MOZ_BUILD_APP))
 tier_necko::
 	$(EXIT_ON_ERROR) \
 	$(foreach tier,$(TIERS),$(MAKE) tools_tier_$(tier); )
diff --git a/js/src/Makefile.in b/js/src/Makefile.in
--- a/js/src/Makefile.in
+++ b/js/src/Makefile.in
@@ -252,17 +252,17 @@ ifneq (,$(filter OS2 WINCE WINNT,$(OS_AR
 ifneq (,$(filter OS2 WINCE WINNT,$(OS_ARCH)))
 SDK_LIBRARY = $(IMPORT_LIBRARY)
 else
 SDK_LIBRARY = $(SHARED_LIBRARY)
 endif
 
 include $(topsrcdir)/config/config.mk
 
-EXTRA_DSO_LDOPTS += $(NSPR_LIBS)
+EXTRA_DSO_LDOPTS += $(NSPR_LIBS) $(XPCOM_LIBS)
 
 ifdef MOZ_MEMORY
 ifeq ($(OS_ARCH),SunOS)
 EXTRA_DSO_LDOPTS += $(call EXPAND_LIBNAME_PATH,jemalloc,$(DIST)/lib)
 endif
 endif
 
 # When using gcc the assembly is inlined in the C-file (see jslock.cpp)
diff --git a/js/src/jsapi.cpp b/js/src/jsapi.cpp
--- a/js/src/jsapi.cpp
+++ b/js/src/jsapi.cpp
@@ -86,16 +86,20 @@
 #if JS_HAS_FILE_OBJECT
 #include "jsfile.h"
 #endif
 
 #if JS_HAS_XML_SUPPORT
 #include "jsxml.h"
 #endif
 
+#ifdef MOZILLA_CLIENT
+#include "nsTraceRefcnt.h"
+#endif
+
 #ifdef HAVE_VA_LIST_AS_ARRAY
 #define JS_ADDRESSOF_VA_LIST(ap) ((va_list *)(ap))
 #else
 #define JS_ADDRESSOF_VA_LIST(ap) (&(ap))
 #endif
 
 #if defined(JS_THREADSAFE)
 #define CHECK_REQUEST(cx)                                                   \
@@ -4191,23 +4195,26 @@ JS_SetReservedSlot(JSContext *cx, JSObje
     slot = JSSLOT_START(clasp) + index;
     return OBJ_SET_REQUIRED_SLOT(cx, obj, slot, v);
 }
 
 #ifdef JS_THREADSAFE
 JS_PUBLIC_API(jsrefcount)
 JS_HoldPrincipals(JSContext *cx, JSPrincipals *principals)
 {
-    return JS_ATOMIC_INCREMENT(&principals->refcount);
+    jsrefcount rc = JS_ATOMIC_INCREMENT(&principals->refcount);
+    NS_LOG_ADDREF(principals, rc, "JSPrincipals", sizeof(JSPrincipals));
+    return rc;
 }
 
 JS_PUBLIC_API(jsrefcount)
 JS_DropPrincipals(JSContext *cx, JSPrincipals *principals)
 {
     jsrefcount rc = JS_ATOMIC_DECREMENT(&principals->refcount);
+    NS_LOG_RELEASE(principals, rc, "JSPrincipals");
     if (rc == 0)
         principals->destroy(cx, principals);
     return rc;
 }
 #endif
 
 JS_PUBLIC_API(JSPrincipalsTranscoder)
 JS_SetPrincipalsTranscoder(JSRuntime *rt, JSPrincipalsTranscoder px)
diff --git a/js/src/jsgc.cpp b/js/src/jsgc.cpp
--- a/js/src/jsgc.cpp
+++ b/js/src/jsgc.cpp
@@ -71,16 +71,20 @@
 #include "jslock.h"
 #include "jsnum.h"
 #include "jsobj.h"
 #include "jsparse.h"
 #include "jsscope.h"
 #include "jsscript.h"
 #include "jsstr.h"
 #include "jstracer.h"
+
+#ifdef MOZILLA_CLIENT
+#include "nsTraceRefcnt.h"
+#endif
 
 #if JS_HAS_XML_SUPPORT
 #include "jsxml.h"
 #endif
 
 /*
  * Check if posix_memalign is available.
  */
@@ -1858,16 +1862,21 @@ js_NewGCThing(JSContext *cx, uintN flags
 #endif
         break;
     }
 
     /* We successfully allocated the thing. */
 #ifdef JS_THREADSAFE
   success:
 #endif
+
+#if defined(TOO_MUCH_GC) && defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+    NS_LogCtor(thing, "JSGCThing", sizeof(JSGCThing));
+#endif
+
     lrs = cx->localRootStack;
     if (lrs) {
         /*
          * If we're in a local root scope, don't set newborn[type] at all, to
          * avoid entraining garbage from it for an unbounded amount of time
          * on this context.  A caller will leave the local root scope and pop
          * this reference, allowing thing to be GC'd if it has no other refs.
          * See JS_EnterLocalRootScope and related APIs.
@@ -1883,20 +1892,30 @@ js_NewGCThing(JSContext *cx, uintN flags
             goto fail;
         }
     } else {
         /*
          * No local root scope, so we're stuck with the old, fragile model of
          * depending on a pigeon-hole newborn per type per context.
          */
         cx->weakRoots.newborn[flags & GCF_TYPEMASK] = thing;
+/* XXXldb Should this be checked in? */
+#ifdef WAY_TOO_MUCH_GC
+        rt->gcPoke = JS_TRUE;
+#endif
     }
 
     /* We can't fail now, so update flags. */
     *flagp = (uint8)flags;
+
+#ifdef MOZILLA_CLIENT
+    if (flags & GCF_LOCK) {
+        NS_LOG_ADDREF(thing, 1, "js_LockGCThing", 1);
+    }
+#endif
 
 #ifdef DEBUG_gchist
     gchist[gchpos].lastDitch = doGC;
     gchist[gchpos].freeList = rt->gcArenaList[flindex].freeList;
     if (++gchpos == NGCHIST)
         gchpos = 0;
 #endif
 
@@ -2172,16 +2191,19 @@ js_LockGCThingRT(JSRuntime *rt, void *th
     shallow = GC_THING_IS_SHALLOW(flagp, thing);
 
     /*
      * Avoid adding a rt->gcLocksHash entry for shallow things until someone
      * nests a lock.
      */
     if (shallow && !(*flagp & GCF_LOCK)) {
         *flagp |= GCF_LOCK;
+#ifdef MOZILLA_CLIENT
+        NS_LOG_ADDREF(thing, 1, "js_LockGCThing", 1);
+#endif
         METER(rt->gcStats.lock++);
         ok = JS_TRUE;
         goto out;
     }
 
     if (!rt->gcLocksHash) {
         rt->gcLocksHash = JS_NewDHashTable(JS_DHashGetStubOps(), NULL,
                                            sizeof(JSGCLockHashEntry),
@@ -2201,16 +2223,19 @@ js_LockGCThingRT(JSRuntime *rt, void *th
     if (!lhe->thing) {
         lhe->thing = thing;
         lhe->count = 1;
     } else {
         JS_ASSERT(lhe->count >= 1);
         lhe->count++;
     }
 
+#ifdef MOZILLA_CLIENT
+    NS_LOG_ADDREF(thing, lhe->count, "js_LockGCThing", 1);
+#endif
     METER(rt->gcStats.lock++);
     ok = JS_TRUE;
   out:
     JS_UNLOCK_GC(rt);
     return ok;
 }
 
 JSBool
@@ -2230,21 +2255,27 @@ js_UnlockGCThingRT(JSRuntime *rt, void *
     if (shallow && !(*flagp & GCF_LOCK))
         goto out;
     if (!rt->gcLocksHash ||
         (lhe = (JSGCLockHashEntry *)
          JS_DHashTableOperate(rt->gcLocksHash, thing,
                               JS_DHASH_LOOKUP),
              JS_DHASH_ENTRY_IS_FREE(&lhe->hdr))) {
         /* Shallow entry is not in the hash -> clear its lock bit. */
-        if (shallow)
+        if (shallow) {
             *flagp &= ~GCF_LOCK;
-        else
+#ifdef MOZILLA_CLIENT
+            NS_LOG_RELEASE(thing, 0, "js_LockGCThing");
+#endif
+        } else
             goto out;
     } else {
+#ifdef MOZILLA_CLIENT
+        NS_LOG_RELEASE(thing, lhe->count - 1, "js_LockGCThing");
+#endif
         if (--lhe->count != 0)
             goto out;
         JS_DHashTableOperate(rt->gcLocksHash, thing, JS_DHASH_REMOVE);
     }
 
     rt->gcPoke = JS_TRUE;
     METER(rt->gcStats.unlock++);
   out:
@@ -3280,16 +3311,20 @@ js_GC(JSContext *cx, JSGCInvocationKind 
   restart:
     rt->gcNumber++;
     JS_ASSERT(!rt->gcUntracedArenaStackTop);
     JS_ASSERT(rt->gcTraceLaterCount == 0);
 
     /* Reset the property cache's type id generator so we can compress ids. */
     rt->shapeGen = 0;
 
+#ifdef DEBUG_dbaron_off
+    printf("Doing JS GC.\n");
+#endif
+
     /*
      * Mark phase.
      */
     JS_TRACER_INIT(&trc, cx, NULL);
     rt->gcMarkingTracer = &trc;
     JS_ASSERT(IS_GC_MARKING_TRACER(&trc));
 
     for (a = rt->gcDoubleArenaList.first; a; a = a->prev)
@@ -3376,16 +3411,20 @@ js_GC(JSContext *cx, JSGCInvocationKind 
                 flags = *flagp;
                 if (flags & (GCF_MARK | GCF_LOCK)) {
                     *flagp &= ~GCF_MARK;
                     allClear = JS_FALSE;
                     METER(nthings++);
                 } else {
                     thing = FLAGP_TO_THING(flagp, thingSize);
                     if (!(flags & GCF_FINAL)) {
+#if defined(TOO_MUCH_GC) && defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+                        NS_LogDtor(thing, "JSGCThing", sizeof(JSGCThing));
+#endif
+
                         /*
                          * Call the finalizer with GCF_FINAL ORed into flags.
                          */
                         *flagp = (uint8)(flags | GCF_FINAL);
                         type = flags & GCF_TYPEMASK;
                         switch (type) {
                           case GCX_OBJECT:
                             js_FinalizeObject(cx, (JSObject *) thing);
diff --git a/js/src/jsscript.cpp b/js/src/jsscript.cpp
--- a/js/src/jsscript.cpp
+++ b/js/src/jsscript.cpp
@@ -56,16 +56,20 @@
 #include "jsinterp.h"
 #include "jslock.h"
 #include "jsnum.h"
 #include "jsopcode.h"
 #include "jsparse.h"
 #include "jsscript.h"
 #if JS_HAS_XDR
 #include "jsxdrapi.h"
+#endif
+
+#ifdef MOZILLA_CLIENT
+#include "nsTraceRefcnt.h"
 #endif
 
 #if JS_HAS_SCRIPT_OBJECT
 
 static const char js_script_exec_str[]    = "Script.prototype.exec";
 static const char js_script_compile_str[] = "Script.prototype.compile";
 
 /*
@@ -563,16 +567,19 @@ js_XDRScript(JSXDRState *xdr, JSScript *
             if (!cx->runtime->principalsTranscoder) {
                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
                                      JSMSG_CANT_DECODE_PRINCIPALS);
                 goto error;
             }
             if (!cx->runtime->principalsTranscoder(xdr, &principals))
                 goto error;
             script->principals = principals;
+#if defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+            NS_LogOwnerAddRef(script, script->principals);
+#endif
         }
     }
 
     if (xdr->mode == JSXDR_DECODE) {
         const char *filename = script->filename;
         if (filename) {
             filename = js_SaveScriptFilename(cx, filename);
             if (!filename)
@@ -1359,16 +1366,19 @@ js_NewScript(JSContext *cx, uint32 lengt
     if (nregexps != 0)
         size += sizeof(JSObjectArray) + nregexps * sizeof(JSObject *);
     if (ntrynotes != 0)
         size += sizeof(JSTryNoteArray) + ntrynotes * sizeof(JSTryNote);
 
     script = (JSScript *) JS_malloc(cx, size);
     if (!script)
         return NULL;
+#if defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+    NS_LogCtor(script, "JSScript", sizeof(*script));
+#endif
     memset(script, 0, sizeof(JSScript));
     script->length = length;
     script->version = cx->version;
 
     cursor = (uint8 *)script + sizeof(JSScript);
     if (nobjects != 0) {
         script->objectsOffset = (uint8)(cursor - (uint8 *)script);
         cursor += sizeof(JSObjectArray);
@@ -1489,18 +1499,22 @@ js_NewScriptFromCG(JSContext *cx, JSCode
     if (script->nfixed + cg->maxStackDepth >= JS_BIT(16)) {
         js_ReportCompileErrorNumber(cx, CG_TS(cg), NULL, JSREPORT_ERROR,
                                     JSMSG_NEED_DIET, "script");
         goto bad;
     }
     script->nslots = script->nfixed + cg->maxStackDepth;
     script->staticDepth = cg->staticDepth;
     script->principals = cg->treeContext.parseContext->principals;
-    if (script->principals)
+    if (script->principals) {
         JSPRINCIPALS_HOLD(cx, script->principals);
+#if defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+        NS_LogOwnerAddRef(script, script->principals);
+#endif
+    }
 
     if (!js_FinishTakingSrcNotes(cx, cg, SCRIPT_NOTES(script)))
         goto bad;
     if (cg->ntrynotes != 0)
         js_FinishTakingTryNotes(cg, JS_SCRIPT_TRYNOTES(script));
     if (cg->objectList.length != 0)
         FinishParsedObjects(&cg->objectList, JS_SCRIPT_OBJECTS(script));
     if (cg->regexpList.length != 0)
@@ -1568,21 +1582,28 @@ js_CallDestroyScriptHook(JSContext *cx, 
     hook = cx->debugHooks->destroyScriptHook;
     if (hook)
         hook(cx, script, cx->debugHooks->destroyScriptHookData);
 }
 
 void
 js_DestroyScript(JSContext *cx, JSScript *script)
 {
+#if defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+    NS_LogDtor(script, "JSScript", sizeof(*script));
+#endif
     js_CallDestroyScriptHook(cx, script);
     JS_ClearScriptTraps(cx, script);
 
-    if (script->principals)
+    if (script->principals) {
+#if defined(MOZILLA_CLIENT) && defined(NS_BUILD_REFCNT_LOGGING)
+        NS_LogOwnerRelease(script, script->principals);
+#endif
         JSPRINCIPALS_DROP(cx, script->principals);
+    }
 
     if (JS_GSN_CACHE(cx).code == script->code)
         JS_CLEAR_GSN_CACHE(cx);
 
     /*
      * The GC flushes all property caches, so no need to purge just the
      * entries for this script.
      *
diff --git a/toolkit/toolkit-tiers.mk b/toolkit/toolkit-tiers.mk
--- a/toolkit/toolkit-tiers.mk
+++ b/toolkit/toolkit-tiers.mk
@@ -35,18 +35,18 @@
 #
 # ***** END LICENSE BLOCK *****
 
 ifdef LIBXUL_SDK
 $(error toolkit-tiers.mk is not compatible with --enable-libxul-sdk=)
 endif
 
 include $(topsrcdir)/config/nspr/build.mk
+include $(topsrcdir)/xpcom/build.mk
 include $(topsrcdir)/js/src/build.mk
-include $(topsrcdir)/xpcom/build.mk
 include $(topsrcdir)/netwerk/build.mk
 
 TIERS += \
 	external \
 	gecko \
 	toolkit \
 	$(NULL)
 
diff --git a/xpcom/base/nsTraceRefcntImpl.cpp b/xpcom/base/nsTraceRefcntImpl.cpp
--- a/xpcom/base/nsTraceRefcntImpl.cpp
+++ b/xpcom/base/nsTraceRefcntImpl.cpp
@@ -927,20 +927,20 @@ NS_LogAddRef(void* aPtr, nsrefcnt aRefcn
     }
 
     // Here's the case where neither NS_NEWXPCOM nor MOZ_COUNT_CTOR were used,
     // yet we still want to see creation information:
 
     PRBool loggingThisType = (!gTypesToLog || LogThisType(aClazz));
     PRInt32 serialno = 0;
     if (gSerialNumbers && loggingThisType) {
-      serialno = GetSerialNumber(aPtr, aRefcnt == 1);
-      NS_ASSERTION(serialno != 0,
+      NS_ASSERTION(aRefcnt == 1 || GetSerialNumber(aPtr, PR_FALSE),
                    "Serial number requested for unrecognized pointer!  "
                    "Are you memmoving a refcounted object?");
+      serialno = GetSerialNumber(aPtr, PR_TRUE);
       PRInt32* count = GetRefCount(aPtr);
       if(count)
         (*count)++;
 
     }
 
     PRBool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
     if (aRefcnt == 1 && gAllocLog && loggingThisType && loggingThisObject) {
@@ -981,20 +981,20 @@ NS_LogRelease(void* aPtr, nsrefcnt aRefc
       if (entry) {
         entry->Release(aRefcnt);
       }
     }
 
     PRBool loggingThisType = (!gTypesToLog || LogThisType(aClazz));
     PRInt32 serialno = 0;
     if (gSerialNumbers && loggingThisType) {
-      serialno = GetSerialNumber(aPtr, PR_FALSE);
-      NS_ASSERTION(serialno != 0,
+      NS_ASSERTION(GetSerialNumber(aPtr, PR_FALSE) != 0,
                    "Serial number requested for unrecognized pointer!  "
                    "Are you memmoving a refcounted object?");
+      serialno = GetSerialNumber(aPtr, PR_TRUE);
       PRInt32* count = GetRefCount(aPtr);
       if(count)
         (*count)--;
 
     }
 
     PRBool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
     if (gRefcntsLog && loggingThisType && loggingThisObject) {
@@ -1082,17 +1082,17 @@ NS_LogDtor(void* aPtr, const char* aType
       if (entry) {
         entry->Dtor();
       }
     }
 
     PRBool loggingThisType = (!gTypesToLog || LogThisType(aType));
     PRInt32 serialno = 0;
     if (gSerialNumbers && loggingThisType) {
-      serialno = GetSerialNumber(aPtr, PR_FALSE);
+      serialno = GetSerialNumber(aPtr, PR_TRUE);
       RecycleSerialNumberPtr(aPtr);
     }
 
     PRBool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
 
     // (If we're on a losing architecture, don't do this because we'll be
     // using LogDeleteXPCOM instead to get file and line numbers.)
     if (gAllocLog && loggingThisType && loggingThisObject) {
@@ -1108,17 +1108,25 @@ NS_LogDtor(void* aPtr, const char* aType
 
 
 EXPORT_XPCOM_API(void)
 NS_LogCOMPtrAddRef(void* aCOMPtr, nsISupports* aObject)
 {
 #if defined(NS_IMPL_REFCNT_LOGGING) && defined(HAVE_CPP_DYNAMIC_CAST_TO_VOID_PTR)
   // Get the most-derived object.
   void *object = dynamic_cast<void *>(aObject);
+  NS_LogOwnerAddRef(aCOMPtr, object);
+#endif
+}
 
+
+EXPORT_XPCOM_API(void)
+NS_LogOwnerAddRef(void* aOwner, void* object)
+{
+#if defined(NS_IMPL_REFCNT_LOGGING)
   // This is a very indirect way of finding out what the class is
   // of the object being logged.  If we're logging a specific type,
   // then
   if (!gTypesToLog || !gSerialNumbers) {
     return;
   }
   PRInt32 serialno = GetSerialNumber(object, PR_FALSE);
   if (serialno == 0) {
@@ -1133,33 +1141,40 @@ NS_LogCOMPtrAddRef(void* aCOMPtr, nsISup
     PRInt32* count = GetCOMPtrCount(object);
     if(count)
       (*count)++;
 
     PRBool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
 
     if (gCOMPtrLog && loggingThisObject) {
       fprintf(gCOMPtrLog, "\n<?> 0x%08X %d nsCOMPtrAddRef %d 0x%08X\n",
-              NS_PTR_TO_INT32(object), serialno, count?(*count):-1, NS_PTR_TO_INT32(aCOMPtr));
+              NS_PTR_TO_INT32(object), serialno, count?(*count):-1, NS_PTR_TO_INT32(aOwner));
       nsTraceRefcntImpl::WalkTheStack(gCOMPtrLog);
     }
 
     UNLOCK_TRACELOG();
   }
 #endif
 }
 
 
 EXPORT_XPCOM_API(void)
 NS_LogCOMPtrRelease(void* aCOMPtr, nsISupports* aObject)
 {
 #if defined(NS_IMPL_REFCNT_LOGGING) && defined(HAVE_CPP_DYNAMIC_CAST_TO_VOID_PTR)
   // Get the most-derived object.
   void *object = dynamic_cast<void *>(aObject);
+  NS_LogOwnerRelease(aCOMPtr, object);
+#endif
+}
 
+EXPORT_XPCOM_API(void)
+NS_LogOwnerRelease(void* aOwner, void* object)
+{
+#if defined(NS_IMPL_REFCNT_LOGGING)
   // This is a very indirect way of finding out what the class is
   // of the object being logged.  If we're logging a specific type,
   // then
   if (!gTypesToLog || !gSerialNumbers) {
     return;
   }
   PRInt32 serialno = GetSerialNumber(object, PR_FALSE);
   if (serialno == 0) {
@@ -1174,17 +1189,17 @@ NS_LogCOMPtrRelease(void* aCOMPtr, nsISu
     PRInt32* count = GetCOMPtrCount(object);
     if(count)
       (*count)--;
 
     PRBool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
 
     if (gCOMPtrLog && loggingThisObject) {
       fprintf(gCOMPtrLog, "\n<?> 0x%08X %d nsCOMPtrRelease %d 0x%08X\n",
-              NS_PTR_TO_INT32(object), serialno, count?(*count):-1, NS_PTR_TO_INT32(aCOMPtr));
+              NS_PTR_TO_INT32(object), serialno, count?(*count):-1, NS_PTR_TO_INT32(aOwner));
       nsTraceRefcntImpl::WalkTheStack(gCOMPtrLog);
     }
 
     UNLOCK_TRACELOG();
   }
 #endif
 }
 
diff --git a/xpcom/build/nsXPCOM.h b/xpcom/build/nsXPCOM.h
--- a/xpcom/build/nsXPCOM.h
+++ b/xpcom/build/nsXPCOM.h
@@ -61,16 +61,18 @@
 # define NS_LogAddRef                NS_LogAddRef_P
 # define NS_LogRelease               NS_LogRelease_P
 # define NS_LogCtor                  NS_LogCtor_P
 # define NS_LogDtor                  NS_LogDtor_P
 # define NS_LogCOMPtrAddRef          NS_LogCOMPtrAddRef_P
 # define NS_LogCOMPtrRelease         NS_LogCOMPtrRelease_P
 # define NS_CycleCollectorSuspect    NS_CycleCollectorSuspect_P
 # define NS_CycleCollectorForget     NS_CycleCollectorForget_P
+# define NS_LogOwnerAddRef           NS_LogOwnerAddRef_P
+# define NS_LogOwnerRelease          NS_LogOwnerRelease_P
 #endif
 
 #include "nscore.h"
 #include "nsXPCOMCID.h"
 
 #ifdef __cplusplus
 #define DECL_CLASS(c) class c
 #else
@@ -462,16 +464,31 @@ NS_LogCOMPtrRelease(void *aCOMPtr, nsISu
  */
 XPCOM_API(PRBool)
 NS_CycleCollectorSuspect(nsISupports *n);
 
 XPCOM_API(PRBool)
 NS_CycleCollectorForget(nsISupports *n);
 
 /**
+ * Log reference counting performed on behalf of an owner other than an
+ * nsCOMPtr, for a non-nsISupports object (i.e., the pointer must be
+ * accurate and cannot be a pointer to an offset interface).  Processing
+ * tools can use the stacktraces printed by these functions to simplify
+ * reports about leaked objects generated from the data printed by
+ * NS_LogAddRef/NS_LogRelease.
+ */
+
+XPCOM_API(void)
+NS_LogOwnerAddRef(void *aOwner, void *aObject);
+
+XPCOM_API(void)
+NS_LogOwnerRelease(void *aOwner, void *aObject);
+
+/**
  * Categories (in the category manager service) used by XPCOM:
  */
 
 /**
  * A category which is read after component registration but before
  * the "xpcom-startup" notifications. Each category entry is treated
  * as the contract ID of a service which implements
  * nsIDirectoryServiceProvider. Each directory service provider is
diff --git a/xpcom/build/nsXPCOMPrivate.h b/xpcom/build/nsXPCOMPrivate.h
--- a/xpcom/build/nsXPCOMPrivate.h
+++ b/xpcom/build/nsXPCOMPrivate.h
@@ -109,16 +109,17 @@ typedef void       (* DebugBreakFunc)(PR
                                       const char *aStr, const char *aExpr,
                                       const char *aFile, PRInt32 aLine);
 
 typedef void       (* xpcomVoidFunc)();
 typedef void       (* LogAddRefFunc)(void*, nsrefcnt, const char*, PRUint32);
 typedef void       (* LogReleaseFunc)(void*, nsrefcnt, const char*);
 typedef void       (* LogCtorFunc)(void*, const char*, PRUint32);
 typedef void       (* LogCOMPtrFunc)(void*, nsISupports*);
+typedef void       (* LogOwnerFunc)(void*, void*);
 
 typedef nsresult   (* GetXPTCallStubFunc)(REFNSIID, nsIXPTCProxy*, nsISomeInterface**);
 typedef void       (* DestroyXPTCallStubFunc)(nsISomeInterface*);
 typedef nsresult   (* InvokeByIndexFunc)(nsISupports*, PRUint32, PRUint32, nsXPTCVariant*);
 typedef PRBool     (* CycleCollectorFunc)(nsISupports*);
 
 // PRIVATE AND DEPRECATED
 typedef NS_CALLBACK(XPCOMExitRoutine)(void);
@@ -189,16 +190,18 @@ typedef struct XPCOMFunctions{
     InvokeByIndexFunc invokeByIndexFunc;
     CycleCollectorFunc cycleSuspectFunc;
     CycleCollectorFunc cycleForgetFunc;
     StringSetIsVoidFunc stringSetIsVoid;
     StringGetIsVoidFunc stringGetIsVoid;
     CStringSetIsVoidFunc cstringSetIsVoid;
     CStringGetIsVoidFunc cstringGetIsVoid;
 
+    LogOwnerFunc logOwnerAddRefFunc;
+    LogOwnerFunc logOwnerReleaseFunc;
 } XPCOMFunctions;
 
 typedef nsresult (PR_CALLBACK *GetFrozenFunctionsFunc)(XPCOMFunctions *entryPoints, const char* libraryPath);
 XPCOM_API(nsresult)
 NS_GetFrozenFunctions(XPCOMFunctions *entryPoints, const char* libraryPath);
 
 // think hard before changing this
 #define XPCOM_GLUE_VERSION 1
diff --git a/xpcom/glue/standalone/nsXPCOMGlue.cpp b/xpcom/glue/standalone/nsXPCOMGlue.cpp
--- a/xpcom/glue/standalone/nsXPCOMGlue.cpp
+++ b/xpcom/glue/standalone/nsXPCOMGlue.cpp
@@ -559,8 +559,23 @@ XPCOM_API(PRBool)
 XPCOM_API(PRBool)
 NS_CycleCollectorForget(nsISupports* obj)
 {
     if (!xpcomFunctions.cycleForgetFunc)
         return PR_FALSE;
 
     return xpcomFunctions.cycleForgetFunc(obj);
 }
+
+XPCOM_API(void)
+NS_LogOwnerAddRef(void *aOwner, void *aObject)
+{
+    if (xpcomFunctions.logOwnerAddRefFunc)
+        xpcomFunctions.logOwnerAddRefFunc(aOwner, aObject);
+}
+
+XPCOM_API(void)
+NS_LogOwnerRelease(void *aOwner, void *aObject)
+{
+    if (xpcomFunctions.logOwnerReleaseFunc)
+        xpcomFunctions.logOwnerReleaseFunc(aOwner, aObject);
+}
+
diff --git a/xpcom/stub/nsXPComStub.cpp b/xpcom/stub/nsXPComStub.cpp
--- a/xpcom/stub/nsXPComStub.cpp
+++ b/xpcom/stub/nsXPComStub.cpp
@@ -115,17 +115,19 @@ static const XPCOMFunctions kFrozenFunct
     &NS_GetXPTCallStub_P,
     &NS_DestroyXPTCallStub_P,
     &NS_InvokeByIndex_P,
     &NS_CycleCollectorSuspect_P,
     &NS_CycleCollectorForget_P,
     &NS_StringSetIsVoid_P,
     &NS_StringGetIsVoid_P,
     &NS_CStringSetIsVoid_P,
-    &NS_CStringGetIsVoid_P
+    &NS_CStringGetIsVoid_P,
+    &NS_LogOwnerAddRef_P,
+    &NS_LogOwnerRelease_P
 };
 
 EXPORT_XPCOM_API(nsresult)
 NS_GetFrozenFunctions(XPCOMFunctions *functions, const char* /* libraryPath */)
 {
     if (!functions)
         return NS_ERROR_OUT_OF_MEMORY;
 
@@ -339,16 +341,30 @@ NS_DestroyXPTCallStub(nsISomeInterface* 
 #undef NS_InvokeByIndex
 EXPORT_XPCOM_API(nsresult)
 NS_InvokeByIndex(nsISupports* that, PRUint32 methodIndex,
                  PRUint32 paramCount, nsXPTCVariant* params)
 {
   return NS_InvokeByIndex_P(that, methodIndex, paramCount, params);
 }
 
+#undef NS_LogOwnerAddRef
+EXPORT_XPCOM_API(void)
+NS_LogOwnerAddRef(void *aOwner, void* aObject)
+{
+  NS_LogOwnerAddRef_P(aOwner, aObject);
+}
+
+#undef NS_LogOwnerRelease
+EXPORT_XPCOM_API(void)
+NS_LogOwnerRelease(void *aOwner, void* aObject)
+{
+  NS_LogOwnerRelease_P(aOwner, aObject);
+}
+
 /*
  * Stubs for nsXPCOMPrivate.h
  */
 
 EXPORT_XPCOM_API(nsresult)
 NS_RegisterXPCOMExitRoutine(XPCOMExitRoutine exitRoutine, PRUint32 priority)
 {
   return NS_OK;
