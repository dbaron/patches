From: L. David Baron <dbaron@dbaron.org>

Bug 1089417 patch 11 - Flush pending media feature value changes where needed.

diff --git a/dom/base/nsDocument.cpp b/dom/base/nsDocument.cpp
--- a/dom/base/nsDocument.cpp
+++ b/dom/base/nsDocument.cpp
@@ -12678,18 +12678,26 @@ nsIDocument::FlushUserFontSet()
 
   if (!mFontFaceSetDirty) {
     return;
   }
 
   mFontFaceSetDirty = false;
 
   if (gfxPlatform::GetPlatform()->DownloadableFontsEnabled()) {
+    nsIPresShell* shell = GetShell();
+
+    // We have to flush pending media feature values changes before doing
+    // something that might rebuild CSS rule processors.
+    nsPresContext* presContext = shell->GetPresContext();
+    if (presContext) {
+      presContext->FlushPendingMediaFeatureValuesChanged();
+    }
+
     nsTArray<nsFontFaceRuleContainer> rules;
-    nsIPresShell* shell = GetShell();
     if (shell && !shell->StyleSet()->AppendFontFaceRules(rules)) {
       // FIXME: What if it had rules before?
       return;
     }
 
 
     if (!mFontFaceSet && !rules.IsEmpty()) {
       nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(GetScopeObject());
diff --git a/layout/base/GeckoRestyleManager.cpp b/layout/base/GeckoRestyleManager.cpp
--- a/layout/base/GeckoRestyleManager.cpp
+++ b/layout/base/GeckoRestyleManager.cpp
@@ -288,16 +288,21 @@ GeckoRestyleManager::ContentStateChanged
   // XXXbz it would be good if this function only took Elements, but
   // we'd have to make ESM guarantee that usefully.
   if (!aContent->IsElement()) {
     return;
   }
 
   Element* aElement = aContent->AsElement();
 
+  // We have to flush pending media feature values changes before doing
+  // something that might rebuild CSS rule processors.
+  // FIXME: Should this be in RestyleManagerBase?
+  mPresContext->FlushPendingMediaFeatureValuesChanged();
+
   nsChangeHint changeHint;
   ContentStateChangedInternal(aElement, aStateMask, &changeHint);
 
   // Assemble what we'll need to calculate the nsRestyleHint.
   nsIFrame* primaryFrame = aElement->GetPrimaryFrame();
   CSSPseudoElementType pseudoType = CSSPseudoElementType::NotPseudo;
   if (primaryFrame) {
     pseudoType = primaryFrame->StyleContext()->GetPseudoType();
@@ -362,16 +367,20 @@ GeckoRestyleManager::AttributeChanged(El
   MOZ_ASSERT(!mInStyleRefresh);
 
   // Hold onto the PresShell to prevent ourselves from being destroyed.
   // XXXbz how, exactly, would this attribute change cause us to be
   // destroyed from inside this function?
   nsCOMPtr<nsIPresShell> shell = PresContext()->GetPresShell();
   mozilla::Unused << shell; // Unused within this function
 
+  // We have to flush pending media feature values changes before doing
+  // something that might rebuild CSS rule processors.
+  mPresContext->FlushPendingMediaFeatureValuesChanged();
+
   // Get the frame associated with the content which is the highest in the frame tree
   nsIFrame* primaryFrame = aElement->GetPrimaryFrame();
 
 #if 0
   NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
      ("RestyleManager::AttributeChanged: content=%p[%s] frame=%p",
       aContent, ContentTag(aElement, 0), frame));
 #endif
diff --git a/layout/base/PresShell.cpp b/layout/base/PresShell.cpp
--- a/layout/base/PresShell.cpp
+++ b/layout/base/PresShell.cpp
@@ -4312,16 +4312,20 @@ PresShell::ContentStateChanged(nsIDocume
 void
 PresShell::DocumentStatesChanged(nsIDocument* aDocument, EventStates aStateMask)
 {
   NS_PRECONDITION(!mIsDocumentGone, "Unexpected DocumentStatesChanged");
   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
   MOZ_ASSERT(!aStateMask.IsEmpty());
 
   if (mDidInitialize) {
+    // We have to flush pending media feature values changes before doing
+    // something that might rebuild CSS rule processors.
+    mPresContext->FlushPendingMediaFeatureValuesChanged();
+
     if (mStyleSet->IsServo()) {
       mStyleSet->AsServo()->InvalidateStyleForDocumentStateChanges(aStateMask);
     } else {
 #ifdef MOZ_OLD_STYLE
       if (Element* rootElement = aDocument->GetRootElement()) {
         const bool needRestyle =
           mStyleSet->AsGecko()->HasDocumentStateDependentStyle(
             rootElement, aStateMask);
