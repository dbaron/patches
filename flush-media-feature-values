From: L. David Baron <dbaron@dbaron.org>

Bug 1089417 patch 11 - Flush pending media feature value changes where needed.

diff --git a/dom/base/nsDocument.cpp b/dom/base/nsDocument.cpp
--- a/dom/base/nsDocument.cpp
+++ b/dom/base/nsDocument.cpp
@@ -13458,18 +13458,26 @@ nsIDocument::FlushUserFontSet()
   if (!mGetUserFontSetCalled) {
     return; // No one cares about this font set yet, but we want to be careful
             // to not unset our mFontFaceSetDirty bit, so when someone really
             // does we'll create it.
   }
 
   if (mFontFaceSetDirty) {
     if (gfxPlatform::GetPlatform()->DownloadableFontsEnabled()) {
+      nsIPresShell* shell = GetShell();
+
+      // We have to flush pending media feature values changes before doing
+      // something that might rebuild CSS rule processors.
+      nsPresContext* presContext = shell->GetPresContext();
+      if (presContext) {
+        presContext->FlushPendingMediaFeatureValuesChanged();
+      }
+
       nsTArray<nsFontFaceRuleContainer> rules;
-      nsIPresShell* shell = GetShell();
       if (shell) {
         // XXXheycam ServoStyleSets don't support exposing @font-face rules yet.
         if (shell->StyleSet()->IsGecko()) {
           if (!shell->StyleSet()->AsGecko()->AppendFontFaceRules(rules)) {
             // FIXME: What if it had rules before?
             return;
           }
         } else {
diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1159,16 +1159,20 @@ RestyleManager::ContentStateChanged(nsIC
   // XXXbz it would be good if this function only took Elements, but
   // we'd have to make ESM guarantee that usefully.
   if (!aContent->IsElement()) {
     return NS_OK;
   }
 
   Element* aElement = aContent->AsElement();
 
+  // We have to flush pending media feature values changes before doing
+  // something that might rebuild CSS rule processors.
+  mPresContext->FlushPendingMediaFeatureValuesChanged();
+
   nsStyleSet* styleSet = StyleSet();
   NS_ASSERTION(styleSet, "couldn't get style set");
 
   nsChangeHint hint = NS_STYLE_HINT_NONE;
   // Any change to a content state that affects which frames we construct
   // must lead to a frame reconstruct here if we already have a frame.
   // Note that we never decide through non-CSS means to not create frames
   // based on content states, so if we already don't have a frame we don't
@@ -1265,16 +1269,20 @@ RestyleManager::AttributeChanged(Element
                                  int32_t aModType,
                                  const nsAttrValue* aOldValue)
 {
   // Hold onto the PresShell to prevent ourselves from being destroyed.
   // XXXbz how, exactly, would this attribute change cause us to be
   // destroyed from inside this function?
   nsCOMPtr<nsIPresShell> shell = mPresContext->GetPresShell();
 
+  // We have to flush pending media feature values changes before doing
+  // something that might rebuild CSS rule processors.
+  mPresContext->FlushPendingMediaFeatureValuesChanged();
+
   // Get the frame associated with the content which is the highest in the frame tree
   nsIFrame* primaryFrame = aElement->GetPrimaryFrame();
 
 #if 0
   NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
      ("RestyleManager::AttributeChanged: content=%p[%s] frame=%p",
       aContent, ContentTag(aElement, 0), frame));
 #endif
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -4185,23 +4185,27 @@ PresShell::DocumentStatesChanged(nsIDocu
     // XXXheycam ServoStyleSets don't support document state selectors,
     // but these are only used in chrome documents, which we are not
     // aiming to support yet.
     NS_ERROR("stylo: ServoStyleSets cannot respond to document state "
              "changes yet");
     return;
   }
 
-  if (mDidInitialize &&
-      styleSet->HasDocumentStateDependentStyle(mDocument->GetRootElement(),
-                                               aStateMask)) {
-    mPresContext->RestyleManager()->PostRestyleEvent(mDocument->GetRootElement(),
-                                                     eRestyle_Subtree,
-                                                     NS_STYLE_HINT_NONE);
-    VERIFY_STYLE_TREE;
+  if (mDidInitialize) {
+    // We have to flush pending media feature values changes before doing
+    // something that might rebuild CSS rule processors.
+    mPresContext->FlushPendingMediaFeatureValuesChanged();
+
+    Element* rootElement = mDocument->GetRootElement();
+    if (styleSet->HasDocumentStateDependentStyle(rootElement, aStateMask)) {
+      mPresContext->RestyleManager()->
+        PostRestyleEvent(rootElement, eRestyle_Subtree, NS_STYLE_HINT_NONE);
+      VERIFY_STYLE_TREE;
+    }
   }
 
   if (aStateMask.HasState(NS_DOCUMENT_STATE_WINDOW_INACTIVE)) {
     nsIFrame* root = mFrameConstructor->GetRootFrame();
     if (root) {
       root->SchedulePaint();
     }
   }
