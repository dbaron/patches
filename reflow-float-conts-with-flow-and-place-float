From: L. David Baron <dbaron@dbaron.org>

nsBlockFrame::ReflowFloatContinuations doesn't need anything in AddFloat other than FlowAndPlaceFloat.  (Bug 563584)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -5746,17 +5746,17 @@ nsBlockFrame::ReflowFloatContinuations(n
        f = f->GetNextSibling()) {
     if (NS_SUBTREE_DIRTY(f) || aState.mReflowState.ShouldReflowAllKids()) {
       // Cache old bounds
       nsRect oldRect = f->GetRect();
       nsRect oldOverflow = f->GetOverflowRect();
 
       // Reflow
       nsReflowStatus fStatus = NS_FRAME_COMPLETE;
-      aState.AddFloat(nsnull, f, aState.mContentArea.width, fStatus);
+      aState.FlowAndPlaceFloat(f, fStatus);
       if (!NS_FRAME_IS_FULLY_COMPLETE(fStatus)) {
         rv = SplitFloat(aState, f, fStatus);
         NS_ENSURE_SUCCESS(rv, rv);
         NS_FRAME_SET_OVERFLOW_INCOMPLETE(fStatus);
       }
       NS_MergeReflowStatusInto(&aStatus, fStatus);
 
       // Invalidate if there was a position or size change
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -538,17 +538,18 @@ nsBlockReflowState::RecoverStateFrom(nsL
 // float as well unless it won't fit next to what we already have.
 // But nobody else implements it that way...
 PRBool
 nsBlockReflowState::AddFloat(nsLineLayout*       aLineLayout,
                              nsIFrame*           aFloat,
                              nscoord             aAvailableWidth,
                              nsReflowStatus&     aReflowStatus)
 {
-  NS_PRECONDITION(!aLineLayout || mBlock->end_lines() != mCurrentLine, "null ptr");
+  NS_PRECONDITION(aLineLayout, "must have line layout");
+  NS_PRECONDITION(mBlock->end_lines() != mCurrentLine, "null ptr");
   NS_PRECONDITION(aFloat->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
                   "aFloat must be an out-of-flow frame");
 
   // Set the geometric parent of the float
   aFloat->SetParent(mBlock);
 
   aReflowStatus = NS_FRAME_COMPLETE;
 
@@ -566,37 +567,34 @@ nsBlockReflowState::AddFloat(nsLineLayou
   PRBool placed;
 
   // Now place the float immediately if possible. Otherwise stash it
   // away in mPendingFloats and place it later.
   // If one or more floats has already been pushed to the next line,
   // don't let this one go on the current line, since that would violate
   // float ordering.
   nsRect floatAvailableSpace = GetFloatAvailableSpace().mRect;
-  if (!aLineLayout ||
-      (mBelowCurrentLineFloats.IsEmpty() &&
-       (aLineLayout->LineIsEmpty() ||
-        mBlock->ComputeFloatWidth(*this, floatAvailableSpace, aFloat)
-        <= aAvailableWidth))) {
+  if (mBelowCurrentLineFloats.IsEmpty() &&
+      (aLineLayout->LineIsEmpty() ||
+       mBlock->ComputeFloatWidth(*this, floatAvailableSpace, aFloat)
+       <= aAvailableWidth)) {
     nsFloatManager::SavedState floatManagerState;
     mFloatManager->PushState(&floatManagerState);
 
     // And then place it
     placed = FlowAndPlaceFloat(aFloat, aReflowStatus);
     if (placed && !NS_FRAME_IS_TRUNCATED(aReflowStatus)) {
       // Pass on updated available space to the current inline reflow engine
       nsFlowAreaRect floatAvailSpace = GetFloatAvailableSpace(mY);
       nsRect availSpace(nsPoint(floatAvailSpace.mRect.x + BorderPadding().left,
                                 mY),
                         floatAvailSpace.mRect.Size());
-      if (aLineLayout) {
-        aLineLayout->UpdateBand(availSpace, aFloat);
-        // Record this float in the current-line list
-        mCurrentLineFloats.Append(mFloatCacheFreeList.Alloc(aFloat));
-      }
+      aLineLayout->UpdateBand(availSpace, aFloat);
+      // Record this float in the current-line list
+      mCurrentLineFloats.Append(mFloatCacheFreeList.Alloc(aFloat));
     }
     else {
       if (placed) {
         mFloatManager->PopState(&floatManagerState);
       } else {
         mFloatManager->AssertStateMatches(&floatManagerState);
       }
       if (IsAdjacentWithTop()) {
