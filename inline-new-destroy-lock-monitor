From: L. David Baron <dbaron@dbaron.org>

Make nsAutoLock::NewLock, nsAutoLock::DestroyLock, nsAutoMonitor::NewMonitor, and nsAutoMonitor::DestroyMonitor inline so that they have no overhead in non-DEBUG.  (Bug 594666)

NOTE: passed try builds and unit tests on all platforms, 2011-03-25

diff --git a/xpcom/glue/nsAutoLock.cpp b/xpcom/glue/nsAutoLock.cpp
--- a/xpcom/glue/nsAutoLock.cpp
+++ b/xpcom/glue/nsAutoLock.cpp
@@ -36,17 +36,16 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsAutoLock.h"
 
 #ifdef DEBUG
 
 #include "plhash.h"
 #include "prprf.h"
-#include "prlock.h"
 #include "prthread.h"
 #include "nsDebug.h"
 #include "nsVoidArray.h"
 
 #ifdef NS_TRACE_MALLOC
 # include <stdio.h>
 # include "nsTraceMalloc.h"
 #endif
@@ -132,44 +131,45 @@ _purge_one(PLHashEntry* he, PRIntn cnt, 
     nsNamedVector* vec = (nsNamedVector*) he->value;
 
     if (he->key == arg)
         return HT_ENUMERATE_REMOVE;
     vec->RemoveElement(arg);
     return HT_ENUMERATE_NEXT;
 }
 
-static void
-OnSemaphoreRecycle(void* addr)
+/* static */ void
+nsAutoLockBase::OnSemaphoreRecycle(void* addr)
 {
     if (OrderTable) { 
         PR_Lock(OrderTableLock);
         PL_HashTableEnumerateEntries(OrderTable, _purge_one, addr);
         PR_Unlock(OrderTableLock);
     }
 }
 
 static PLHashNumber
 _hash_pointer(const void* key)
 {
     return PLHashNumber(NS_PTR_TO_INT32(key)) >> 2;
 }
 
 // Must be single-threaded here, early in primordial thread.
-static void InitAutoLockStatics()
+/* static */ void
+nsAutoLockBase::InitAutoLockStatics()
 {
     (void) PR_NewThreadPrivateIndex(&LockStackTPI, 0);
     OrderTable = PL_NewHashTable(64, _hash_pointer,
                                  PL_CompareValues, PL_CompareValues,
                                  &_hash_alloc_ops, 0);
     if (OrderTable && !(OrderTableLock = PR_NewLock())) {
         PL_HashTableDestroy(OrderTable);
         OrderTable = 0;
     }
-    PR_CSetOnMonitorRecycle(OnSemaphoreRecycle);
+    PR_CSetOnMonitorRecycle(nsAutoLockBase::OnSemaphoreRecycle);
 }
 
 void _FreeAutoLockStatics()
 {
     PLHashTable* table = OrderTable;
     if (!table) return;
 
     // Called at shutdown, so we don't need to lock.
@@ -188,17 +188,18 @@ static nsNamedVector* GetVector(PLHashTa
     if (he)
         return (nsNamedVector*) he->value;
     nsNamedVector* vec = new nsNamedVector();
     if (vec)
         PL_HashTableRawAdd(table, hep, hash, key, vec);
     return vec;
 }
 
-static void OnSemaphoreCreated(const void* key, const char* name )
+/* static */ void
+nsAutoLockBase::OnSemaphoreCreated(const void* key, const char* name )
 {
     if (key && OrderTable) {
         nsNamedVector* value = new nsNamedVector(name);
         if (value) {
             PR_Lock(OrderTableLock);
             PL_HashTableAdd(OrderTable, key, value);
             PR_Unlock(OrderTableLock);
         }
@@ -385,50 +386,16 @@ nsAutoUnlockBase::nsAutoUnlockBase(void*
 nsAutoUnlockBase::~nsAutoUnlockBase()
 {
     if (mLock)
         mLock->Show();
 }
 
 #endif /* DEBUG */
 
-PRLock* nsAutoLock::NewLock(const char* name)
-{
-    PRLock* lock = PR_NewLock();
-#ifdef DEBUG
-    OnSemaphoreCreated(lock, name);
-#endif
-    return lock;
-}
-
-void nsAutoLock::DestroyLock(PRLock* lock)
-{
-#ifdef DEBUG
-    OnSemaphoreRecycle(lock);
-#endif
-    PR_DestroyLock(lock);
-}
-
-PRMonitor* nsAutoMonitor::NewMonitor(const char* name)
-{
-    PRMonitor* mon = PR_NewMonitor();
-#ifdef DEBUG
-    OnSemaphoreCreated(mon, name);
-#endif
-    return mon;
-}
-
-void nsAutoMonitor::DestroyMonitor(PRMonitor* mon)
-{
-#ifdef DEBUG
-    OnSemaphoreRecycle(mon);
-#endif
-    PR_DestroyMonitor(mon);
-}
-
 void nsAutoMonitor::Enter()
 {
 #ifdef DEBUG
     if (!mAddr) {
         NS_ERROR("It is not legal to enter a null monitor");
         return;
     }
     nsAutoLockBase* stackTop =
diff --git a/xpcom/glue/nsAutoLock.h b/xpcom/glue/nsAutoLock.h
--- a/xpcom/glue/nsAutoLock.h
+++ b/xpcom/glue/nsAutoLock.h
@@ -44,21 +44,21 @@
   For example,
 
     class Foo {
     private:
         PRLock* mLock;
 
     public:
         Foo(void) {
-            mLock = PR_NewLock();
+            mLock = nsAutoLock::NewLock("Foo::mLock");
         }
 
         ~Foo(void) {
-            PR_DestroyLock(mLock);
+            nsAutoLock::DestroyLock(mLock);
         }
 
         void ThreadSafeMethod(void) {
             // we're don't hold the lock yet...
 
             nsAutoLock lock(mLock);
             // ...but now we do.
 
@@ -122,16 +122,20 @@ class NS_COM_GLUE NS_STACK_CLASS nsAutoL
 protected:
     nsAutoLockBase() {}
     enum nsAutoLockType {eAutoLock, eAutoMonitor, eAutoCMonitor};
 
 #ifdef DEBUG
     nsAutoLockBase(void* addr, nsAutoLockType type);
     ~nsAutoLockBase();
 
+    static void     InitAutoLockStatics();
+    static void     OnSemaphoreRecycle(void* addr);
+    static void     OnSemaphoreCreated(const void* key, const char* name);
+
     void            Show();
     void            Hide();
 
     void*           mAddr;
     nsAutoLockBase* mDown;
     nsAutoLockType  mType;
 #else
     nsAutoLockBase(void* addr, nsAutoLockType type) {}
@@ -194,18 +198,33 @@ public:
      * Allocates a new PRLock for use with nsAutoLock. name is
      * not checked for uniqueness.
      * @param name A name which can reference this lock
      * @param lock A valid PRLock* that was created by nsAutoLock::NewLock()
      * @returns nsnull if failure
      *          A valid PRLock* if successful, which must be destroyed
      *          by nsAutoLock::DestroyLock()
      **/
-    static PRLock* NewLock(const char* name);
-    static void    DestroyLock(PRLock* lock);
+    static PRLock* NewLock(const char* name)
+    {
+        PRLock* lock = PR_NewLock();
+    #ifdef DEBUG
+        OnSemaphoreCreated(lock, name);
+    #endif
+        return lock;
+    }
+
+    static void DestroyLock(PRLock* lock)
+    {
+    #ifdef DEBUG
+        OnSemaphoreRecycle(lock);
+    #endif
+        PR_DestroyLock(lock);
+    }
+
 
     /**
      * Constructor
      * The constructor aquires the given lock.  The destructor
      * releases the lock.
      * 
      * @param aLock A valid PRLock* returned from the NSPR's 
      * PR_NewLock() function.
@@ -283,18 +302,32 @@ public:
     /**
      * NewMonitor
      * Allocates a new PRMonitor for use with nsAutoMonitor.
      * @param name A (unique /be?) name which can reference this monitor
      * @returns nsnull if failure
      *          A valid PRMonitor* is successful while must be destroyed
      *          by nsAutoMonitor::DestroyMonitor()
      **/
-    static PRMonitor* NewMonitor(const char* name);
-    static void       DestroyMonitor(PRMonitor* mon);
+    static PRMonitor* NewMonitor(const char* name)
+    {
+        PRMonitor* mon = PR_NewMonitor();
+    #ifdef DEBUG
+        OnSemaphoreCreated(mon, name);
+    #endif
+        return mon;
+    }
+
+    static void DestroyMonitor(PRMonitor* mon)
+    {
+    #ifdef DEBUG
+        OnSemaphoreRecycle(mon);
+    #endif
+        PR_DestroyMonitor(mon);
+    }
 
     
     /**
      * Constructor
      * The constructor locks the given monitor.  During destruction
      * the monitor will be unlocked.
      * 
      * @param mon A valid PRMonitor* returned from 
