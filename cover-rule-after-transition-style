From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Make the cover rule produce the correct after-transition style.

This switches to the new rules for how transitions start on descendants
when also starting on ancestors.

FIXME: Update the expectations for 10 failing tests in the "descendant
test" in layout/style/test/test_transitions.html .

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -209,28 +209,27 @@ nsTransitionManager::StyleContextChanged
   if (collection) {
     afterChangeStyle = newStyleContext->PresContext()->StyleSet()->
       ResolveStyleWithoutAnimation(aElement, newStyleContext,
                                    eRestyle_CSSTransitions);
   } else {
     afterChangeStyle = newStyleContext;
   }
 
-  // In the CSS working group discussion (2009 Jul 15 telecon,
-  // http://www.w3.org/mid/4A5E1470.4030904@inkedblade.net ) of
-  // http://lists.w3.org/Archives/Public/www-style/2009Jun/0121.html ,
-  // the working group decided that a transition property on an
-  // element should not cause any transitions if the property change
-  // is itself inheriting a value that is transitioning on an
-  // ancestor.  So, to get the correct behavior, we continue the
-  // restyle that caused this transition using a "covering" rule that
-  // covers up any changes on which we started transitions, so that
-  // descendants don't start their own transitions.  (In the case of
-  // negative transition delay, this covering rule produces different
-  // results than applying the transition rule immediately would).
+  // Here we need to produce a style rule (called the cover rule) that,
+  // when added to the after-change style defined in
+  // http://dev.w3.org/csswg/css-transitions/#starting (actually, the
+  // after-change style but with already-running transitions included),
+  // we produce the after-transition style.  This is needed to get
+  // correct behavior for both starting and stopping transitions on
+  // descendants.
+  //
+  // This requires that we cover any styles that started or stopped
+  // during this style change with the styles from afterChangeStyle.
+  //
   // Our caller is responsible for restyling again using this covering
   // rule.
 
   nsRefPtr<css::AnimValuesStyleRule> coverRule = new css::AnimValuesStyleRule;
 
   // Per http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html
   // I'll consider only the transitions from the number of items in
   // 'transition-property' on down, and later ones will override earlier
@@ -346,25 +345,35 @@ nsTransitionManager::StyleContextChanged
   NS_ABORT_IF_FALSE(!startedAny || collection,
                     "must have element transitions if we started "
                     "any transitions");
 
   if (collection) {
     // Set the style rule refresh time to null so that EnsureStyleRuleFor
     // creates a new style rule if we started *or* stopped transitions.
     collection->mStyleRuleRefreshTime = TimeStamp();
+    collection->mNeedsRefreshes = true;
+    TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+    collection->EnsureStyleRuleFor(now, EnsureStyleRule_IsNotThrottled);
   }
 
-  // Replace the new style context by appending the cover rule.
+  // We want to replace the new style context with what the transitions
+  // spec calls the after-transition style.  We can achieve this by
+  // adding the *new* transition rule (after this function) and the
+  // cover rule (to cover up the part of it that resulted from the
+  // transitions we just started).
   nsCOMArray<nsIStyleRule> rules;
+  if (collection && collection->mStyleRule) {
+    rules.AppendObject(collection->mStyleRule);
+  }
   if (startedAny) {
     rules.AppendObject(coverRule);
   }
   *aNewStyleContext = mPresContext->StyleSet()->
-                        ResolveStyleByAddingRules(*aNewStyleContext, rules);
+                        ResolveStyleByAddingRules(afterChangeStyle, rules);
 }
 
 void
 nsTransitionManager::ConsiderStartingTransition(
   nsCSSProperty aProperty,
   const StyleTransition& aTransition,
   dom::Element* aElement,
   AnimationPlayerCollection*& aElementTransitions,
@@ -577,17 +586,17 @@ nsTransitionManager::ConsiderStartingTra
     if (!players.AppendElement(player)) {
       NS_WARNING("out of memory");
       return;
     }
   }
   aElementTransitions->UpdateAnimationGeneration(mPresContext);
   aElementTransitions->PostRestyleForAnimation(presContext);
 
-  aCoverRule->AddValue(aProperty, startValue);
+  aCoverRule->AddValue(aProperty, endValue);
 
   *aStartedAny = true;
   aWhichStarted->AddProperty(aProperty);
 }
 
 /*
  * nsIStyleRuleProcessor implementation
  */
diff --git a/layout/style/test/test_transitions.html b/layout/style/test/test_transitions.html
--- a/layout/style/test/test_transitions.html
+++ b/layout/style/test/test_transitions.html
@@ -222,24 +222,23 @@ function make_reset_test(transition, des
     div.appendChild(p);
     is(getComputedStyle(p, "").marginLeft, "0px",
        "should be zero before changing value");
     return p;
 }
 var reset_test = make_reset_test("4s margin-left ease-out 4s", "transition-delay reset to starting point");
 var reset_test_reference = make_reset_test("4s margin-left linear -3s", "reference for previous test (reset test)");
 
-// Test that transitions on descendants do not trigger when the
+// Test that transitions on descendants start correctly when the
 // inherited value is itself transitioning.  In other words, when
 // ancestor and descendant both have a transition for the same property,
 // and the descendant inherits the property from the ancestor, the
-// descendant's transition is ignored (as part of the idea of not
-// starting transitions on changes that result from animation).
-// See http://lists.w3.org/Archives/Public/www-style/2009Jun/0121.html
-// and http://lists.w3.org/Archives/Public/www-style/2009Jul/0050.html
+// descendant's transition starts as specified, based on the concepts of
+// the before-change style, the after-change style, and the
+// after-transition style.
 var descendant_tests = [
     { parent_transition: "",
       child_transition: "4s text-indent" },
     { parent_transition: "4s text-indent",
       child_transition: "" },
     { parent_transition: "4s text-indent",
       child_transition: "16s text-indent" },
     { parent_transition: "4s text-indent",
@@ -625,21 +624,21 @@ is(getComputedStyle(reset_test_reference
 reset_reset_test();
 check_reset_test(0);
 for (var i = 1; i <= 8; ++i) {
     (function(j) {
         add_future_call(j, function() { check_reset_test(j); });
     })(i);
 }
 
-check_descendant_tests();
-add_future_call(2, check_descendant_tests);
-add_future_call(6, check_descendant_tests);
+check_descendant_tests(0);
+add_future_call(2, function() { check_descendant_tests(2) });
+add_future_call(6, function() { check_descendant_tests(6) });
 
-function check_descendant_tests() {
+function check_descendant_tests(time) {
     // text-indent: transition from 50px to 150px
     // letter-spacing: transition from 10px to 5px
     var values = {};
     values["text-indent"] = [ 50, 150 ];
     values["letter-spacing"] = [ 10, 5 ];
     var tf = timingFunctions["ease"];
 
     for (var i in descendant_tests) {
@@ -674,21 +673,23 @@ function check_descendant_tests() {
             var delay = (props.length > 2) ? parseInt(props[2]) : 0;
             var property = props[1];
             if (property != "text-indent" && property != "letter-spacing" &&
                 property != "all") {
                 ok(false, "fix this test (unexpected transition-property " +
                           property + " on child)");
             }
 
-            if (property != "letter-spacing" && child_ti_duration == 0) {
+            // Override the parent's transition with the child's as long
+            // as the child transition is still running.
+            if (property != "letter-spacing" && duration + delay < time) {
                 child_ti_duration = duration;
                 child_ti_delay = delay;
             }
-            if (property != "text-indent" && child_ls_duration == 0) {
+            if (property != "text-indent" && duration + delay < time) {
                 child_ls_duration = duration;
                 child_ls_delay = delay;
             }
         }
 
         var time_portions = {
           "text-indent":
             { duration: child_ti_duration, delay: child_ti_delay },
