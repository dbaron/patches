From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Make the cover rule produce the correct after-transition style.

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -208,28 +208,27 @@ nsTransitionManager::StyleContextChanged
   if (collection) {
     afterChangeStyle = aNewStyleContext->PresContext()->StyleSet()->
       ResolveStyleWithoutAnimation(aElement, aNewStyleContext,
                                    eRestyle_CSSTransitions);
   } else {
     afterChangeStyle = aNewStyleContext;
   }
 
-  // In the CSS working group discussion (2009 Jul 15 telecon,
-  // http://www.w3.org/mid/4A5E1470.4030904@inkedblade.net ) of
-  // http://lists.w3.org/Archives/Public/www-style/2009Jun/0121.html ,
-  // the working group decided that a transition property on an
-  // element should not cause any transitions if the property change
-  // is itself inheriting a value that is transitioning on an
-  // ancestor.  So, to get the correct behavior, we continue the
-  // restyle that caused this transition using a "covering" rule that
-  // covers up any changes on which we started transitions, so that
-  // descendants don't start their own transitions.  (In the case of
-  // negative transition delay, this covering rule produces different
-  // results than applying the transition rule immediately would).
+  // Here we need to produce a style rule (called the cover rule) that,
+  // when added to the after-change style defined in
+  // http://dev.w3.org/csswg/css-transitions/#starting (actually, the
+  // after-change style but with already-running transitions included),
+  // we produce the after-transition style.  This is needed to get
+  // correct behavior for both starting and stopping transitions on
+  // descendants.
+  //
+  // This requires that we cover any styles that started or stopped
+  // during this style change with the styles from afterChangeStyle.
+  //
   // Our caller is responsible for restyling again using this covering
   // rule.
 
   nsRefPtr<css::AnimValuesStyleRule> coverRule = new css::AnimValuesStyleRule;
 
   // Per http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html
   // I'll consider only the transitions from the number of items in
   // 'transition-property' on down, and later ones will override earlier
@@ -324,16 +323,18 @@ nsTransitionManager::StyleContextChanged
           // properties no longer in 'transition-property'
       if ((checkProperties &&
            !allTransitionProperties.HasProperty(prop.mProperty)) ||
           // properties whose computed values changed but delay and
           // duration are both zero
           !ExtractComputedValueForTransition(prop.mProperty, afterChangeStyle,
                                              currentValue) ||
           currentValue != segment.mToValue) {
+        // FIXME: Add to cover rule.
+
         // stop the transition
         players.RemoveElementAt(i);
         collection->UpdateAnimationGeneration(mPresContext);
       }
     } while (i != 0);
 
     if (players.IsEmpty()) {
       collection->Destroy();
@@ -445,16 +446,19 @@ nsTransitionManager::ConsiderStartingTra
   if (!shouldAnimate) {
     if (haveCurrentTransition) {
       // We're in the middle of a transition, and just got a non-transition
       // style change to something that we can't animate.  This might happen
       // because we got a non-transition style change changing to the current
       // in-progress value (which is particularly easy to cause when we're
       // currently in the 'transition-delay').  It also might happen because we
       // just got a style change to a value that can't be interpolated.
+
+      // FIXME: Add to cover rule.
+
       AnimationPlayerPtrArray& players = aElementTransitions->mPlayers;
       oldPT = nullptr; // Clear pointer so it doesn't dangle
       players.RemoveElementAt(currentIndex);
       aElementTransitions->UpdateAnimationGeneration(mPresContext);
 
       if (players.IsEmpty()) {
         aElementTransitions->Destroy();
         // |aElementTransitions| is now a dangling pointer!
@@ -570,17 +574,17 @@ nsTransitionManager::ConsiderStartingTra
     if (!players.AppendElement(player)) {
       NS_WARNING("out of memory");
       return;
     }
   }
   aElementTransitions->UpdateAnimationGeneration(mPresContext);
   aElementTransitions->PostRestyleForAnimation(presContext);
 
-  aCoverRule->AddValue(aProperty, startValue);
+  aCoverRule->AddValue(aProperty, endValue);
 
   *aStartedAny = true;
   aWhichStarted->AddProperty(aProperty);
 }
 
 /*
  * nsIStyleRuleProcessor implementation
  */
