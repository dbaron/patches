From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Make the cover rule produce the correct after-transition style.

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -327,42 +327,42 @@ nsTransitionManager::StyleContextChanged
 
   if (!startedAny) {
     return nullptr;
   }
 
   NS_ABORT_IF_FALSE(collection, "must have element transitions if we started "
                                 "any transitions");
 
-  // In the CSS working group discussion (2009 Jul 15 telecon,
-  // http://www.w3.org/mid/4A5E1470.4030904@inkedblade.net ) of
-  // http://lists.w3.org/Archives/Public/www-style/2009Jun/0121.html ,
-  // the working group decided that a transition property on an
-  // element should not cause any transitions if the property change
-  // is itself inheriting a value that is transitioning on an
-  // ancestor.  So, to get the correct behavior, we continue the
-  // restyle that caused this transition using a "covering" rule that
-  // covers up any changes on which we started transitions, so that
-  // descendants don't start their own transitions.  (In the case of
-  // negative transition delay, this covering rule produces different
-  // results than applying the transition rule immediately would).
+  // Here we need to produce a style rule (called the cover rule) that,
+  // when added to the after-change style defined in
+  // http://dev.w3.org/csswg/css-transitions/#starting (actually, the
+  // after-change style but with already-running transitions included),
+  // we produce the after-transition style.  This is needed to get
+  // correct behavior for both starting and stopping transitions on
+  // descendants.
+  //
+  // This requires that we cover any styles that started or stopped
+  // during this style change with the styles from WHAT EXACTLY?
+  //
   // Our caller is responsible for restyling again using this covering
   // rule.
 
   nsRefPtr<css::AnimValuesStyleRule> coverRule = new css::AnimValuesStyleRule;
 
   AnimationPlayerPtrArray& players = collection->mPlayers;
   for (size_t i = 0, i_end = players.Length(); i < i_end; ++i) {
     dom::Animation* anim = players[i]->GetSource();
     MOZ_ASSERT(anim && anim->Properties().Length() == 1,
                "Should have one animation property for a transition");
     MOZ_ASSERT(anim && anim->Properties()[0].mSegments.Length() == 1,
                "Animation property should have one segment for a transition");
     AnimationProperty& prop = anim->Properties()[0];
     AnimationPropertySegment& segment = prop.mSegments[0];
+    // FIXME
     if (whichStarted.HasProperty(prop.mProperty)) {
       coverRule->AddValue(prop.mProperty, segment.mFromValue);
     }
   }
 
   // Set the style rule refresh time to null so that EnsureStyleRuleFor
   // creates a new style rule.
   collection->mStyleRuleRefreshTime = TimeStamp();
