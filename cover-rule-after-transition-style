From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Make the cover rule produce the correct after-transition style.

FIXME: Is there a good way to remove transition styles additively, or do
we need to build on the afterChangeStyle instead?

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -209,28 +209,27 @@ nsTransitionManager::StyleContextChanged
   if (collection) {
     afterChangeStyle = newStyleContext->PresContext()->StyleSet()->
       ResolveStyleWithoutAnimation(aElement, newStyleContext,
                                    eRestyle_CSSTransitions);
   } else {
     afterChangeStyle = newStyleContext;
   }
 
-  // In the CSS working group discussion (2009 Jul 15 telecon,
-  // http://www.w3.org/mid/4A5E1470.4030904@inkedblade.net ) of
-  // http://lists.w3.org/Archives/Public/www-style/2009Jun/0121.html ,
-  // the working group decided that a transition property on an
-  // element should not cause any transitions if the property change
-  // is itself inheriting a value that is transitioning on an
-  // ancestor.  So, to get the correct behavior, we continue the
-  // restyle that caused this transition using a "covering" rule that
-  // covers up any changes on which we started transitions, so that
-  // descendants don't start their own transitions.  (In the case of
-  // negative transition delay, this covering rule produces different
-  // results than applying the transition rule immediately would).
+  // Here we need to produce a style rule (called the cover rule) that,
+  // when added to the after-change style defined in
+  // http://dev.w3.org/csswg/css-transitions/#starting (actually, the
+  // after-change style but with already-running transitions included),
+  // we produce the after-transition style.  This is needed to get
+  // correct behavior for both starting and stopping transitions on
+  // descendants.
+  //
+  // This requires that we cover any styles that started or stopped
+  // during this style change with the styles from afterChangeStyle.
+  //
   // Our caller is responsible for restyling again using this covering
   // rule.
 
   nsRefPtr<css::AnimValuesStyleRule> coverRule = new css::AnimValuesStyleRule;
 
   // Per http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html
   // I'll consider only the transitions from the number of items in
   // 'transition-property' on down, and later ones will override earlier
@@ -325,16 +324,18 @@ nsTransitionManager::StyleContextChanged
           // properties no longer in 'transition-property'
       if ((checkProperties &&
            !allTransitionProperties.HasProperty(prop.mProperty)) ||
           // properties whose computed values changed but delay and
           // duration are both zero
           !ExtractComputedValueForTransition(prop.mProperty, afterChangeStyle,
                                              currentValue) ||
           currentValue != segment.mToValue) {
+        // FIXME: Add to cover rule.
+
         // stop the transition
         player->Cancel();
         players.RemoveElementAt(i);
         collection->UpdateAnimationGeneration(mPresContext);
       }
     } while (i != 0);
 
     if (players.IsEmpty()) {
@@ -346,25 +347,35 @@ nsTransitionManager::StyleContextChanged
   NS_ABORT_IF_FALSE(!startedAny || collection,
                     "must have element transitions if we started "
                     "any transitions");
 
   if (collection) {
     // Set the style rule refresh time to null so that EnsureStyleRuleFor
     // creates a new style rule if we started *or* stopped transitions.
     collection->mStyleRuleRefreshTime = TimeStamp();
+    collection->mNeedsRefreshes = true;
+    TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+    collection->EnsureStyleRuleFor(now, EnsureStyleRule_IsNotThrottled);
   }
 
-  // Replace the new style context by appending the cover rule.
+  // We want to replace the new style context with what the transitions
+  // spec calls the after-transition style.  We can achieve this by
+  // adding the *new* transition rule (after this function) and the
+  // cover rule (to cover up the part of it that resulted from the
+  // transitions we just started).
   nsCOMArray<nsIStyleRule> rules;
+  if (collection && collection->mStyleRule) {
+    rules.AppendObject(collection->mStyleRule);
+  }
   if (startedAny) {
     rules.AppendObject(coverRule);
   }
   *aNewStyleContext = mPresContext->StyleSet()->
-                        ResolveStyleByAddingRules(*aNewStyleContext, rules);
+                        ResolveStyleByAddingRules(afterChangeStyle, rules);
 }
 
 void
 nsTransitionManager::ConsiderStartingTransition(
   nsCSSProperty aProperty,
   const StyleTransition& aTransition,
   dom::Element* aElement,
   AnimationPlayerCollection*& aElementTransitions,
@@ -452,16 +463,19 @@ nsTransitionManager::ConsiderStartingTra
   if (!shouldAnimate) {
     if (haveCurrentTransition) {
       // We're in the middle of a transition, and just got a non-transition
       // style change to something that we can't animate.  This might happen
       // because we got a non-transition style change changing to the current
       // in-progress value (which is particularly easy to cause when we're
       // currently in the 'transition-delay').  It also might happen because we
       // just got a style change to a value that can't be interpolated.
+
+      // FIXME: Add to cover rule.
+
       AnimationPlayerPtrArray& players = aElementTransitions->mPlayers;
       oldPT = nullptr; // Clear pointer so it doesn't dangle
       players.RemoveElementAt(currentIndex);
       aElementTransitions->UpdateAnimationGeneration(mPresContext);
 
       if (players.IsEmpty()) {
         aElementTransitions->Destroy();
         // |aElementTransitions| is now a dangling pointer!
@@ -577,17 +591,17 @@ nsTransitionManager::ConsiderStartingTra
     if (!players.AppendElement(player)) {
       NS_WARNING("out of memory");
       return;
     }
   }
   aElementTransitions->UpdateAnimationGeneration(mPresContext);
   aElementTransitions->PostRestyleForAnimation(presContext);
 
-  aCoverRule->AddValue(aProperty, startValue);
+  aCoverRule->AddValue(aProperty, endValue);
 
   *aStartedAny = true;
   aWhichStarted->AddProperty(aProperty);
 }
 
 /*
  * nsIStyleRuleProcessor implementation
  */
