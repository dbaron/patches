Eliminate unnecessary reference counting of gfxContext objects.  b=433640  r+sr=roc

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -2800,17 +2800,17 @@ nsCSSRendering::PaintBorder(nsPresContex
       borderColors[i] = 0x0;
     else if (foreground)
       borderColors[i] = ourColor->mColor;
   }
 
   SF(" borderStyles: %d %d %d %d\n", borderStyles[0], borderStyles[1], borderStyles[2], borderStyles[3]);
 
   // start drawing
-  nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
+  gfxContext *ctx = aRenderingContext.ThebesContext();
 
   ctx->Save();
 
 #if 0
   // this will draw a transparent red backround underneath the area between iRect and oRect
   ctx->Save();
   ctx->Rectangle(iRect);
   ctx->Clip();
@@ -2990,17 +2990,17 @@ nsCSSRendering::PaintOutline(nsPresConte
 
   // convert the border widths
   gfxFloat outlineWidths[4] = { width / twipsPerPixel,
                                 width / twipsPerPixel,
                                 width / twipsPerPixel,
                                 width / twipsPerPixel };
 
   // start drawing
-  nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
+  gfxContext *ctx = aRenderingContext.ThebesContext();
 
   ctx->Save();
 
   DrawBorders(ctx,
               oRect,
               iRect,
               outlineStyles,
               outlineWidths,
@@ -3734,17 +3734,17 @@ nsCSSRendering::PaintBackgroundWithSC(ns
       ComputeBackgroundAnchorPoint(aColor, bgOriginArea, bgClipArea, tileWidth, tileHeight, anchor);
     }
 
     // For scrolling attachment, the anchor is within the 'background-clip'
     anchor.x += bgClipArea.x - aBorderArea.x;
     anchor.y += bgClipArea.y - aBorderArea.y;
   }
 
-  nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
+  gfxContext *ctx = aRenderingContext.ThebesContext();
   ctx->Save();
 
   nscoord appUnitsPerPixel = aPresContext->DevPixelsToAppUnits(1);
 
   ctx->NewPath();
   ctx->Rectangle(RectToGfxRect(dirtyRect, appUnitsPerPixel), PR_TRUE);
   ctx->Clip();
 
@@ -4028,17 +4028,17 @@ nsCSSRendering::PaintRoundedBackground(n
                                        nsIRenderingContext& aRenderingContext,
                                        nsIFrame* aForFrame,
                                        const nsRect& aBgClipArea,
                                        const nsStyleBackground& aColor,
                                        const nsStyleBorder& aBorder,
                                        nscoord aTheRadius[4],
                                        PRBool aCanPaintNonWhite)
 {
-  nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
+  gfxContext *ctx = aRenderingContext.ThebesContext();
 
   // needed for our border thickness
   nscoord appUnitsPerPixel = aPresContext->AppUnitsPerDevPixel();
 
   nscolor color = aColor.mBackgroundColor;
   if (!aCanPaintNonWhite) {
     color = NS_RGB(255, 255, 255);
   }
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -2508,17 +2508,17 @@ nsLayoutUtils::DrawImage(nsIRenderingCon
     pxSrc.size.width = gfxFloat(w);
     pxSrc.size.height = gfxFloat(h);
   }
   gfxRect pxSubimage = pxSrc;
 
   nsCOMPtr<nsIDeviceContext> dc;
   aRenderingContext->GetDeviceContext(*getter_AddRefs(dc));
 
-  nsRefPtr<gfxContext> ctx = aRenderingContext->ThebesContext();
+  gfxContext *ctx = aRenderingContext->ThebesContext();
 
   // the dest rect is affected by the current transform; that'll be
   // handled by Image::Draw(), when we actually set up the rectangle.
   
   // Snap the edges of where layout wants the image to the nearest
   // pixel, but then convert back to gfxFloats for the rest of the math.
   gfxRect pxDest;
   {
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -5911,17 +5911,17 @@ nsBlockFrame::PaintTextDecorationLine(ns
     // It'll just increase the width (which can also happen to be
     // negative!).
     start += indent;
     width -= indent;
   }
       
   // Only paint if we have a positive width
   if (width > 0) {
-    nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
+    gfxContext *ctx = aRenderingContext.ThebesContext();
     gfxPoint pt(PresContext()->AppUnitsToGfxUnits(start + aPt.x),
                 PresContext()->AppUnitsToGfxUnits(aLine->mBounds.y + aPt.y));
     gfxSize size(PresContext()->AppUnitsToGfxUnits(width), aSize);
     nsCSSRendering::PaintDecorationLine(
       ctx, aColor, pt, size,
       PresContext()->AppUnitsToGfxUnits(aLine->GetAscent()),
       aOffset, aDecoration, NS_STYLE_BORDER_STYLE_SOLID);
   }
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -779,17 +779,17 @@ void nsDisplaySelectionOverlay::Paint(ns
   nsCOMPtr<nsILookAndFeel> look;
   look = do_GetService(kLookAndFeelCID, &result);
   if (NS_SUCCEEDED(result) && look)
     look->GetColor(colorID, color);
 
   gfxRGBA c(color);
   c.a = .5;
 
-  nsRefPtr<gfxContext> ctx = aCtx->ThebesContext();
+  gfxContext *ctx = aCtx->ThebesContext();
   ctx->SetColor(c);
 
   nsRect rect(aBuilder->ToReferenceFrame(mFrame), mFrame->GetSize());
   rect.IntersectRect(rect, aDirtyRect);
   rect.ScaleRoundOut(1.0f / mFrame->PresContext()->AppUnitsPerDevPixel());
   ctx->NewPath();
   ctx->Rectangle(gfxRect(rect.x, rect.y, rect.width, rect.height), PR_TRUE);
   ctx->Fill();
diff --git a/layout/generic/nsHTMLContainerFrame.cpp b/layout/generic/nsHTMLContainerFrame.cpp
--- a/layout/generic/nsHTMLContainerFrame.cpp
+++ b/layout/generic/nsHTMLContainerFrame.cpp
@@ -234,17 +234,17 @@ nsHTMLContainerFrame::PaintTextDecoratio
   nsMargin bp = GetUsedBorderAndPadding();
   PRIntn skip = GetSkipSides();
   NS_FOR_CSS_SIDES(side) {
     if (skip & (1 << side)) {
       bp.side(side) = 0;
     }
   }
   nscoord innerWidth = mRect.width - bp.left - bp.right;
-  nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
+  gfxContext *ctx = aRenderingContext.ThebesContext();
   gfxPoint pt(PresContext()->AppUnitsToGfxUnits(bp.left + aPt.x),
               PresContext()->AppUnitsToGfxUnits(bp.top + aPt.y));
   gfxSize size(PresContext()->AppUnitsToGfxUnits(innerWidth), aSize);
   nsCSSRendering::PaintDecorationLine(ctx, aColor, pt, size, aAscent, aOffset,
                                       aDecoration, NS_STYLE_BORDER_STYLE_SOLID);
 }
 
 void
diff --git a/layout/generic/nsObjectFrame.cpp b/layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp
+++ b/layout/generic/nsObjectFrame.cpp
@@ -1416,17 +1416,17 @@ nsObjectFrame::PaintPlugin(nsIRenderingC
       /*
        * Layout now has an optimized way of painting. Now we always get
        * a new drawing surface, sized to be just what's needed. Windowless
        * plugins need a transform applied to their origin so they paint
        * in the right place. Since |SetWindow| is no longer being used
        * to tell the plugin where it is, we dispatch a NPWindow through
        * |HandleEvent| to tell the plugin when its window moved
        */
-      nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
+      gfxContext *ctx = aRenderingContext.ThebesContext();
       gfxMatrix ctxMatrix = ctx->CurrentMatrix();
       if (ctxMatrix.HasNonTranslation()) {
         // soo; in the future, we should be able to render
         // the object content to an offscreen DC, and then
         // composite it in with the right transforms.
 
         // But, we don't bother doing that, because we don't
         // have the event handling story figured out yet.
