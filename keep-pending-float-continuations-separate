From: L. David Baron <dbaron@dbaron.org>

Manage float continuations to-be-pulled by the next-in-flow better by keeping them in a separate frame list until they're actually pulled.

diff --git a/content/base/src/nsGkAtomList.h b/content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h
+++ b/content/base/src/nsGkAtomList.h
@@ -373,16 +373,17 @@ GK_ATOM(fieldset, "fieldset")
 GK_ATOM(figcaption, "figcaption")
 GK_ATOM(figure, "figure")
 GK_ATOM(fixed, "fixed")
 GK_ATOM(fixedList, "Fixed-list")
 GK_ATOM(flags, "flags")
 GK_ATOM(flex, "flex")
 GK_ATOM(flexgroup, "flexgroup")
 GK_ATOM(floatList, "Float-list")
+GK_ATOM(floatContinuationsList, "FloatContinuations-list")
 GK_ATOM(floor, "floor")
 GK_ATOM(focus, "focus")
 GK_ATOM(following, "following")
 GK_ATOM(followingSibling, "following-sibling")
 GK_ATOM(font, "font")
 GK_ATOM(fontWeight, "font-weight")
 GK_ATOM(fontpicker, "fontpicker")
 GK_ATOM(footer, "footer")
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -559,30 +559,37 @@ nsBlockFrame::GetChildList(nsIAtom* aLis
     return overflowLines ? nsFrameList(overflowLines->front()->mFirstChild,
                                        overflowLines->back()->LastChild())
                          : nsFrameList::EmptyList();
   }
   else if (aListName == nsGkAtoms::overflowOutOfFlowList) {
     const nsFrameList* list = GetOverflowOutOfFlows();
     return list ? *list : nsFrameList::EmptyList();
   }
+  else if (aListName == nsGkAtoms::floatContinuationsList) {
+    // FIXME: Guard this with a state bit.
+    const nsFrameList* list =
+      GetPropTableFrames(PresContext(), FloatContinuationProperty());
+    return list ? *list : nsFrameList::EmptyList();
+  }
   else if (aListName == nsGkAtoms::floatList) {
     return mFloats;
   }
   else if (aListName == nsGkAtoms::bulletList) {
     return HaveOutsideBullet() ? nsFrameList(mBullet, mBullet)
                                : nsFrameList::EmptyList();
   }
   return nsContainerFrame::GetChildList(aListName);
 }
 
 #define NS_BLOCK_FRAME_OVERFLOW_OOF_LIST_INDEX  (NS_CONTAINER_LIST_COUNT_INCL_OC + 0)
 #define NS_BLOCK_FRAME_FLOAT_LIST_INDEX         (NS_CONTAINER_LIST_COUNT_INCL_OC + 1)
 #define NS_BLOCK_FRAME_BULLET_LIST_INDEX        (NS_CONTAINER_LIST_COUNT_INCL_OC + 2)
 #define NS_BLOCK_FRAME_ABSOLUTE_LIST_INDEX      (NS_CONTAINER_LIST_COUNT_INCL_OC + 3)
+#define NS_BLOCK_FRAME_FLOAT_CONTINUATIONS_LIST_INDEX (NS_CONTAINER_LIST_COUNT_INCL_OC + 4)
 // If adding/removing lists, don't forget to update the count in nsBlockFrame.h
 
 nsIAtom*
 nsBlockFrame::GetAdditionalChildListName(PRInt32 aIndex) const
 {
   if (aIndex < NS_CONTAINER_LIST_COUNT_INCL_OC)
     return nsContainerFrame::GetAdditionalChildListName(aIndex);
 
@@ -590,16 +597,18 @@ nsBlockFrame::GetAdditionalChildListName
   case NS_BLOCK_FRAME_FLOAT_LIST_INDEX:
     return nsGkAtoms::floatList;
   case NS_BLOCK_FRAME_BULLET_LIST_INDEX:
     return nsGkAtoms::bulletList;
   case NS_BLOCK_FRAME_OVERFLOW_OOF_LIST_INDEX:
     return nsGkAtoms::overflowOutOfFlowList;
   case NS_BLOCK_FRAME_ABSOLUTE_LIST_INDEX:
     return nsGkAtoms::absoluteList;
+  case NS_BLOCK_FRAME_FLOAT_CONTINUATIONS_LIST_INDEX:
+    return nsGkAtoms::floatContinuationsList;
   default:
     return nsnull;
   }
 }
 
 /* virtual */ PRBool
 nsBlockFrame::IsContainingBlock() const
 {
@@ -1008,21 +1017,16 @@ nsBlockFrame::Reflow(nsPresContext*     
   // Now reflow...
   rv = ReflowDirtyLines(state);
   NS_ASSERTION(NS_SUCCEEDED(rv), "reflow dirty lines failed");
   if (NS_FAILED(rv)) return rv;
 
   NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
   NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
 
-  // Put continued floats at the end of mFloats
-  if (state.mFloatContinuations.NotEmpty()) {
-    mFloats.AppendFrames(nsnull, state.mFloatContinuations);
-  }
-
   // If we end in a BR with clear and affected floats continue,
   // we need to continue, too.
   if (NS_UNCONSTRAINEDSIZE != aReflowState.availableHeight &&
       NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
       state.mFloatManager->ClearContinues(FindTrailingClear())) {
     NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
   }
 
@@ -4441,68 +4445,28 @@ nsBlockFrame::DrainOverflowLines(nsBlock
 }
 
 // This function assumes our prev-in-flow has completed reflow and its
 // mFloats may contain frames at the end of its float list, marked with
 // NS_FRAME_IS_FLOAT_CONTINUATION, that should be pulled to this block.
 void
 nsBlockFrame::DrainFloatContinuations(nsBlockReflowState& aState)
 {
-  // Cache any continuations of our own floats that we're still holding onto
-  // so they're out of the way. This should only happen if we're re-Reflow'd
-  // before our next-in-flow gets a chance to pull these continuations.
-  // However, if it's a "continuation" that's not actually a continuation,
-  // put it back on the floats list.
-  // FIXME: This is not compatible with doing float breaking in dynamic
-  // situations, since in those situations we could have current
-  // continuations at the end of our float list that were actually
-  // continuations from a previous frame to this one.  (However, it's
-  // not clear to me that we really need this code in the first place;
-  // the best solution might just be to remove it.)
-  nsIFrame *f = mFloats.LastChild();
-  if (f && (f->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION)) {
-    do {
-      f = f->GetPrevSibling();
-    } while (f && (f->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION));
-    aState.SetupFloatContinuationList();
-    nsFrameList floatContinuations;
-    if (f) {
-      floatContinuations = mFloats.RemoveFramesAfter(f);
-    } else {
-      floatContinuations.AppendFrames(nsnull, mFloats);
-    }
-    while (floatContinuations.NotEmpty()) {
-      nsIFrame *f = floatContinuations.RemoveFirstChild();
-      if (f->GetPrevContinuation()) {
-        aState.mFloatContinuations.AppendFrame(nsnull, f);
-      } else {
-        f->RemoveStateBits(NS_FRAME_IS_FLOAT_CONTINUATION);
-        mFloats.AppendFrame(nsnull, f);
-      }
-    }
-  }
-
   // Take any continuations we need to take from our prev-in-flow.
-  nsBlockFrame* prevBlock = static_cast<nsBlockFrame*>(GetPrevInFlow());
+  nsIFrame* prevBlock = GetPrevInFlow();
   if (!prevBlock)
     return;
-  f = prevBlock->mFloats.LastChild();
-  if (f && (f->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION)) {
-    do {
-      ReparentFrame(f, prevBlock, this);
-      f = f->GetPrevSibling();
-    } while (f && (f->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION));
-
-    if (f) {
-      nsFrameList floatContinuations = prevBlock->mFloats.RemoveFramesAfter(f);
-      mFloats.InsertFrames(nsnull, nsnull, floatContinuations);
-    } else {
-      // Move all of prevBlock->mFloats.
-      mFloats.InsertFrames(nsnull, nsnull, prevBlock->mFloats);
-    }
+  nsFrameList *list = static_cast<nsFrameList*>(
+    aState.mPresContext->PropertyTable()->Remove(prevBlock,
+                                                 FloatContinuationProperty()));
+  if (list) {
+    if (list->NotEmpty()) {
+      mFloats.InsertFrames(nsnull, nsnull, *list);
+    }
+    delete list;
   }
 
 #ifdef DEBUG
   for (nsIFrame* f = mFloats.FirstChild(); f ; f = f->GetNextSibling()) {
     for (nsIFrame* c = f->GetFirstInFlow(); c ; c = c->GetNextInFlow()) {
       NS_ASSERTION(c == f || c->GetParent() != this || !mFloats.ContainsFrame(c),
                    "Two floats with same parent in same floats list, expect weird errors.");
     }
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -79,17 +79,17 @@ class nsBlockInFlowLineIterator;
 class nsBulletFrame;
 class nsLineBox;
 class nsFirstLineFrame;
 class nsIntervalSet;
 /**
  * Child list name indices
  * @see #GetAdditionalChildListName()
  */
-#define NS_BLOCK_LIST_COUNT  (NS_CONTAINER_LIST_COUNT_INCL_OC + 4)
+#define NS_BLOCK_LIST_COUNT  (NS_CONTAINER_LIST_COUNT_INCL_OC + 5)
 
 /**
  * Some invariants:
  * -- The overflow out-of-flows list contains the out-of-
  * flow frames whose placeholders are in the overflow list.
  * -- A given piece of content has at most one placeholder
  * frame in a block's normal child list.
  * -- While a block is being reflowed, it may have a FloatContinuationProperty
@@ -161,17 +161,20 @@ public:
   const_line_iterator end_lines() const { return mLines.end(); }
   reverse_line_iterator rbegin_lines() { return mLines.rbegin(); }
   reverse_line_iterator rend_lines() { return mLines.rend(); }
   const_reverse_line_iterator rbegin_lines() const { return mLines.rbegin(); }
   const_reverse_line_iterator rend_lines() const { return mLines.rend(); }
 
   friend nsIFrame* NS_NewBlockFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
 
-  NS_DECLARE_FRAME_PROPERTY(FloatContinuationProperty, nsnull)
+  // This is a child list too, but we let nsBlockReflowState get to it
+  // directly too.
+  NS_DECLARE_FRAME_PROPERTY(FloatContinuationProperty,
+                            nsContainerFrame::DestroyFrameList)
 
   // nsQueryFrame
   NS_DECL_QUERYFRAME
 
   // nsIFrame
   NS_IMETHOD Init(nsIContent*      aContent,
                   nsIFrame*        aParent,
                   nsIFrame*        aPrevInFlow);
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -66,16 +66,17 @@ nsBlockReflowState::nsBlockReflowState(c
                                        nsBlockFrame* aFrame,
                                        const nsHTMLReflowMetrics& aMetrics,
                                        PRBool aTopMarginRoot,
                                        PRBool aBottomMarginRoot,
                                        PRBool aBlockNeedsFloatManager)
   : mBlock(aFrame),
     mPresContext(aPresContext),
     mReflowState(aReflowState),
+    mFloatContinuations(nsnull),
     mOverflowTracker(nsnull),
     mPrevBottomMargin(),
     mLineNumber(0),
     mFlags(0),
     mFloatBreakType(NS_STYLE_CLEAR_NONE)
 {
   SetFlag(BRS_ISFIRSTINFLOW, aFrame->GetPrevInFlow() == nsnull);
   SetFlag(BRS_ISOVERFLOWCONTAINER,
@@ -144,30 +145,22 @@ nsBlockReflowState::nsBlockReflowState(c
   mPrevChild = nsnull;
   mCurrentLine = aFrame->end_lines();
 
   mMinLineHeight = aReflowState.CalcLineHeight();
 }
 
 nsBlockReflowState::~nsBlockReflowState()
 {
-  NS_ASSERTION(mFloatContinuations.IsEmpty(),
-               "Leaking float continuation frames");
-
   // Restore the coordinate system, unless the float manager is null,
   // which means it was just destroyed.
   if (mFloatManager) {
     const nsMargin& borderPadding = BorderPadding();
     mFloatManager->Translate(-borderPadding.left, -borderPadding.top);
   }
-
-  if (GetFlag(BRS_PROPTABLE_FLOATCLIST)) {
-    mPresContext->PropertyTable()->
-      Delete(mBlock, nsBlockFrame::FloatContinuationProperty());
-  }
 }
 
 nsLineBox*
 nsBlockReflowState::NewLineBox(nsIFrame* aFrame,
                                PRInt32 aCount,
                                PRBool aIsBlock)
 {
   return NS_NewLineBox(mPresContext->PresShell(), aFrame, aCount, aIsBlock);
@@ -429,20 +422,34 @@ nsBlockReflowState::ReconstructMarginAbo
       break;
     }
   }
 }
 
 void
 nsBlockReflowState::SetupFloatContinuationList()
 {
+  NS_ABORT_IF_FALSE(!GetFlag(BRS_PROPTABLE_FLOATCLIST) == !mFloatContinuations,
+                    "flag mismatch");
   if (!GetFlag(BRS_PROPTABLE_FLOATCLIST)) {
-    mPresContext->PropertyTable()->
-      Set(mBlock, nsBlockFrame::FloatContinuationProperty(),
-          &mFloatContinuations);
+    // If we're being re-Reflow'd without our next-in-flow having been
+    // reflow, some float continuations from our previous reflow might
+    // still be on our float continuations list.  However, that's
+    // actually fine, since they'll all end up being stolen and
+    // reordered into the correct order again.
+    // FIXME: Check this!
+    // FIXME: I think this isn't needed anymore.
+    nsFrameList *list = mBlock->GetPropTableFrames(mPresContext,
+                          nsBlockFrame::FloatContinuationProperty());
+    if (!list) {
+      list = new nsFrameList();
+      mPresContext->PropertyTable()->
+        Set(mBlock, nsBlockFrame::FloatContinuationProperty(), list);
+    }
+    mFloatContinuations = list;
     SetFlag(BRS_PROPTABLE_FLOATCLIST, PR_TRUE);
   }
 }
 
 /**
  * Restore information about floats into the float manager for an
  * incremental reflow, and simultaneously push the floats by
  * |aDeltaY|, which is the amount |aLine| was pushed relative to its
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -219,27 +219,27 @@ public:
   // The content area to reflow child frames within. The x/y
   // coordinates are known to be mBorderPadding.left and
   // mBorderPadding.top. The width/height may be NS_UNCONSTRAINEDSIZE
   // if the container reflowing this frame has given the frame an
   // unconstrained area.
   nsSize mContentArea;
 
   // Continuation out-of-flow float frames that need to move to our
-  // next in flow are placed here during reflow. At the end of reflow
-  // they move to the end of the mFloats list.
-  nsFrameList mFloatContinuations;
+  // next in flow are placed here during reflow.  It's a pointer to
+  // a frame list stored in the block's property table.
+  nsFrameList *mFloatContinuations;
   // This method makes sure float continuations are accessible to
   // StealFrame. Call it before adding any frames to mFloatContinuations.
   void SetupFloatContinuationList();
   // Use this method to append to mFloatContinuations.
   void AppendFloatContinuation(nsIFrame* aFloatCont) {
     SetupFloatContinuationList();
     aFloatCont->AddStateBits(NS_FRAME_IS_FLOAT_CONTINUATION);
-    mFloatContinuations.AppendFrame(mBlock, aFloatCont);
+    mFloatContinuations->AppendFrame(mBlock, aFloatCont);
   }
 
   // Track child overflow continuations.
   nsOverflowContinuationTracker* mOverflowTracker;
 
   //----------------------------------------
 
   // This state is "running" state updated by the reflow of each line
