From: L. David Baron <dbaron@dbaron.org>

Remove no-longer-needed code for handling unconstrained containing block widths.  (Bug 585715)

diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -606,27 +606,16 @@ nsHTMLReflowState::ComputeRelativeOffset
                                           nsPresContext* aPresContext)
 {
   // Compute the 'left' and 'right' values. 'Left' moves the boxes to the right,
   // and 'right' moves the boxes to the left. The computed values are always:
   // left=-right
   PRBool  leftIsAuto = eStyleUnit_Auto == mStylePosition->mOffset.GetLeftUnit();
   PRBool  rightIsAuto = eStyleUnit_Auto == mStylePosition->mOffset.GetRightUnit();
 
-  // Check for percentage based values and an unconstrained containing
-  // block width. Treat them like 'auto'
-  if (NS_UNCONSTRAINEDSIZE == aContainingBlockWidth) {
-    if (mStylePosition->OffsetHasPercent(NS_SIDE_LEFT)) {
-      leftIsAuto = PR_TRUE;
-    }
-    if (mStylePosition->OffsetHasPercent(NS_SIDE_RIGHT)) {
-      rightIsAuto = PR_TRUE;
-    }
-  }
-
   // If neither 'left' not 'right' are auto, then we're over-constrained and
   // we ignore one of them
   if (!leftIsAuto && !rightIsAuto) {
     if (mCBReflowState &&
         NS_STYLE_DIRECTION_RTL == mCBReflowState->mStyleVisibility->mDirection) {
       leftIsAuto = PR_TRUE;
     } else {
       rightIsAuto = PR_TRUE;
@@ -2159,35 +2148,22 @@ nsHTMLReflowState::CalcLineHeight(nsStyl
 
 void
 nsCSSOffsetState::ComputeMargin(nscoord aContainingBlockWidth)
 {
   // If style style can provide us the margin directly, then use it.
   const nsStyleMargin *styleMargin = frame->GetStyleMargin();
   if (!styleMargin->GetMargin(mComputedMargin)) {
     // We have to compute the value
-    if (NS_UNCONSTRAINEDSIZE == aContainingBlockWidth) {
-      mComputedMargin.left = 0;
-      mComputedMargin.right = 0;
-
-      if (eStyleUnit_Coord == styleMargin->mMargin.GetLeftUnit()) {
-        mComputedMargin.left = styleMargin->mMargin.GetLeft().GetCoordValue();
-      }
-      if (eStyleUnit_Coord == styleMargin->mMargin.GetRightUnit()) {
-        mComputedMargin.right = styleMargin->mMargin.GetRight().GetCoordValue();
-      }
-
-    } else {
-      mComputedMargin.left = nsLayoutUtils::
-        ComputeWidthDependentValue(aContainingBlockWidth,
-                                   styleMargin->mMargin.GetLeft());
-      mComputedMargin.right = nsLayoutUtils::
-        ComputeWidthDependentValue(aContainingBlockWidth,
-                                   styleMargin->mMargin.GetRight());
-    }
+    mComputedMargin.left = nsLayoutUtils::
+      ComputeWidthDependentValue(aContainingBlockWidth,
+                                 styleMargin->mMargin.GetLeft());
+    mComputedMargin.right = nsLayoutUtils::
+      ComputeWidthDependentValue(aContainingBlockWidth,
+                                 styleMargin->mMargin.GetRight());
 
     // According to the CSS2 spec, margin percentages are
     // calculated with respect to the *width* of the containing
     // block, even for margin-top and margin-bottom.
     // XXX This isn't true for page boxes, if we implement them.
     mComputedMargin.top = nsLayoutUtils::
       ComputeWidthDependentValue(aContainingBlockWidth,
                                  styleMargin->mMargin.GetTop());
