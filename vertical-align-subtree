Make top and bottom values of vertical-align align the subtree rather than the element itself.  b=118501

diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -1491,18 +1491,17 @@ nsLineLayout::PlaceTopBottomFrames(PerSp
   for (PerFrameData* pfd = psd->mFirstFrame; pfd; pfd = pfd->mNext) {
     PerSpanData* span = pfd->mSpan;
 #ifdef DEBUG
     NS_ASSERTION(0xFF != pfd->mVerticalAlign, "umr");
 #endif
     switch (pfd->mVerticalAlign) {
       case VALIGN_TOP:
         if (span) {
-          pfd->mBounds.y = -aDistanceFromTop - pfd->mBorderPadding.top +
-            span->mTopLeading;
+          pfd->mBounds.y = -aDistanceFromTop - span->mMinY;
         }
         else {
           pfd->mBounds.y = -aDistanceFromTop + pfd->mMargin.top;
         }
         pfd->mFrame->SetRect(pfd->mBounds);
 #ifdef NOISY_VERTICAL_ALIGN
         printf("    ");
         nsFrame::ListTag(stdout, pfd->mFrame);
@@ -1510,19 +1509,17 @@ nsLineLayout::PlaceTopBottomFrames(PerSp
                pfd->mBounds.y, aDistanceFromTop,
                span ? pfd->mBorderPadding.top : 0,
                span ? span->mTopLeading : 0);
 #endif
         break;
       case VALIGN_BOTTOM:
         if (span) {
           // Compute bottom leading
-          pfd->mBounds.y = -aDistanceFromTop + aLineHeight -
-            pfd->mBounds.height + pfd->mBorderPadding.bottom -
-            span->mBottomLeading;
+          pfd->mBounds.y = -aDistanceFromTop + aLineHeight - span->mMaxY;
         }
         else {
           pfd->mBounds.y = -aDistanceFromTop + aLineHeight -
             pfd->mMargin.bottom - pfd->mBounds.height;
         }
         pfd->mFrame->SetRect(pfd->mBounds);
 #ifdef NOISY_VERTICAL_ALIGN
         printf("    ");
@@ -1827,28 +1824,44 @@ nsLineLayout::VerticalAlignFrames(PerSpa
             // offset to the baseline Y.
             fm->GetSuperscriptOffset(parentSuperscript);
             revisedBaselineY = baselineY - parentSuperscript;
             pfd->mBounds.y = revisedBaselineY - pfd->mAscent;
             pfd->mVerticalAlign = VALIGN_OTHER;
             break;
 
           case NS_STYLE_VERTICAL_ALIGN_TOP:
+          {
             pfd->mVerticalAlign = VALIGN_TOP;
-            if (logicalHeight > maxTopBoxHeight) {
-              maxTopBoxHeight = logicalHeight;
+            nscoord subtreeHeight = logicalHeight;
+            if (frameSpan) {
+              subtreeHeight = frameSpan->mMaxY - frameSpan->mMinY;
+              NS_ASSERTION(subtreeHeight >= logicalHeight,
+                           "unexpected subtree height");
+            }
+            if (subtreeHeight > maxTopBoxHeight) {
+              maxTopBoxHeight = subtreeHeight;
             }
             break;
+          }
 
           case NS_STYLE_VERTICAL_ALIGN_BOTTOM:
+          {
             pfd->mVerticalAlign = VALIGN_BOTTOM;
-            if (logicalHeight > maxBottomBoxHeight) {
-              maxBottomBoxHeight = logicalHeight;
+            nscoord subtreeHeight = logicalHeight;
+            if (frameSpan) {
+              subtreeHeight = frameSpan->mMaxY - frameSpan->mMinY;
+              NS_ASSERTION(subtreeHeight >= logicalHeight,
+                           "unexpected subtree height");
+            }
+            if (subtreeHeight > maxBottomBoxHeight) {
+              maxBottomBoxHeight = subtreeHeight;
             }
             break;
+          }
 
           case NS_STYLE_VERTICAL_ALIGN_MIDDLE:
             // Align the midpoint of the frame with 1/2 the parents
             // x-height above the baseline.
             fm->GetXHeight(parentXHeight);
             if (frameSpan) {
               pfd->mBounds.y = baselineY -
                 (parentXHeight + pfd->mBounds.height)/2;
