Don't do special parsing for media lists in HTML: match parentheses, even across commas, and allow media queries through.  (Bug 156716)  r+sr=bzbarsky

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -198,16 +198,22 @@ protected:
   nsresult DoParseMediaList(const nsSubstring& aBuffer,
                             nsIURI* aURL, // for error reporting
                             PRUint32 aLineNumber, // for error reporting
                             nsMediaList* aMediaList);
 
   PRBool GetToken(nsresult& aErrorCode, PRBool aSkipWS);
   PRBool GetURLToken(nsresult& aErrorCode);
   void UngetToken();
+
+  void AssertInitialState() {
+    NS_PRECONDITION(!mHTMLMediaMode, "Bad initial state");
+    NS_PRECONDITION(!mUnresolvablePrefixException, "Bad initial state");
+    NS_PRECONDITION(!mParsingCompoundProperty, "Bad initial state");
+  }
 
   PRBool ExpectSymbol(nsresult& aErrorCode, PRUnichar aSymbol, PRBool aSkipWS);
   PRBool ExpectEndProperty(nsresult& aErrorCode);
   nsSubstring* NextIdent(nsresult& aErrorCode);
   void SkipUntil(nsresult& aErrorCode, PRUnichar aStopSymbol);
   void SkipRuleSet(nsresult& aErrorCode);
   PRBool SkipAtRule(nsresult& aErrorCode);
   PRBool SkipDeclaration(nsresult& aErrorCode, PRBool aCheckForBraces);
@@ -725,16 +731,17 @@ CSSParserImpl::Parse(nsIUnicharInputStre
                      nsIPrincipal*          aSheetPrincipal,
                      PRUint32               aLineNumber,
                      PRBool                 aAllowUnsafeRules)
 {
   NS_PRECONDITION(aSheetPrincipal, "Must have principal here!");
   
   NS_ASSERTION(nsnull != aBaseURI, "need base URL");
   NS_ASSERTION(nsnull != aSheetURI, "need sheet URL");
+  AssertInitialState();
 
   NS_PRECONDITION(mSheet, "Must have sheet to parse into");
   NS_ENSURE_STATE(mSheet);
 
 #ifdef DEBUG
   nsCOMPtr<nsIURI> uri;
   mSheet->GetSheetURI(getter_AddRefs(uri));
   PRBool equal;
@@ -825,16 +832,17 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 CSSParserImpl::ParseStyleAttribute(const nsAString& aAttributeValue,
                                    nsIURI*                  aDocURL,
                                    nsIURI*                  aBaseURL,
                                    nsIPrincipal*            aNodePrincipal,
                                    nsICSSStyleRule**        aResult)
 {
   NS_PRECONDITION(aNodePrincipal, "Must have principal here!");
+  AssertInitialState();
   
   NS_ASSERTION(nsnull != aBaseURL, "need base URL");
 
   // XXX line number?
   nsresult rv = InitScanner(aAttributeValue, aDocURL, 0, aBaseURL, aNodePrincipal);
   if (! NS_SUCCEEDED(rv)) {
     return rv;
   }
@@ -881,16 +889,17 @@ CSSParserImpl::ParseAndAppendDeclaration
                                          nsIURI*           aBaseURL,
                                          nsIPrincipal*     aSheetPrincipal,
                                          nsCSSDeclaration* aDeclaration,
                                          PRBool            aParseOnlyOneDecl,
                                          PRBool*           aChanged,
                                          PRBool            aClearOldDecl)
 {
   NS_PRECONDITION(aSheetPrincipal, "Must have principal here!");
+  AssertInitialState();
   
 //  NS_ASSERTION(nsnull != aBaseURL, "need base URL");
   *aChanged = PR_FALSE;
 
   nsresult rv = InitScanner(aBuffer, aSheetURL, 0, aBaseURL, aSheetPrincipal);
   if (! NS_SUCCEEDED(rv)) {
     return rv;
   }
@@ -934,16 +943,17 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 CSSParserImpl::ParseRule(const nsAString&        aRule,
                          nsIURI*                 aSheetURL,
                          nsIURI*                 aBaseURL,
                          nsIPrincipal*           aSheetPrincipal,
                          nsCOMArray<nsICSSRule>& aResult)
 {
   NS_PRECONDITION(aSheetPrincipal, "Must have principal here!");
+  AssertInitialState();
   
   NS_ASSERTION(nsnull != aBaseURL, "need base URL");
 
   nsresult rv = InitScanner(aRule, aSheetURL, 0, aBaseURL, aSheetPrincipal);
   if (NS_FAILED(rv)) {
     return rv;
   }
 
@@ -972,16 +982,17 @@ CSSParserImpl::ParseProperty(const nsCSS
                              const nsAString& aPropValue,
                              nsIURI* aSheetURL,
                              nsIURI* aBaseURL,
                              nsIPrincipal* aSheetPrincipal,
                              nsCSSDeclaration* aDeclaration,
                              PRBool* aChanged)
 {
   NS_PRECONDITION(aSheetPrincipal, "Must have principal here!");
+  AssertInitialState();
   
   NS_ASSERTION(nsnull != aBaseURL, "need base URL");
   NS_ASSERTION(nsnull != aDeclaration, "Need declaration to parse into!");
   *aChanged = PR_FALSE;
 
   nsresult rv = InitScanner(aPropValue, aSheetURL, 0, aBaseURL, aSheetPrincipal);
   if (NS_FAILED(rv)) {
     return rv;
@@ -1036,53 +1047,38 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 CSSParserImpl::ParseMediaList(const nsSubstring& aBuffer,
                               nsIURI* aURL, // for error reporting
                               PRUint32 aLineNumber, // for error reporting
                               nsMediaList* aMediaList,
                               PRBool aHTMLMode)
 {
   aMediaList->Clear();
-  nsresult rv = NS_OK;
-
-  if (aHTMLMode) {
-    mHTMLMediaMode = PR_TRUE;
+
+  AssertInitialState();
+  NS_ASSERTION(aHTMLMode == PR_TRUE || aHTMLMode == PR_FALSE,
+               "invalid PRBool");
+  mHTMLMediaMode = aHTMLMode;
 
     // XXXldb We need to make the scanner not skip CSS comments!  (Or
     // should we?)
 
-    // Follow the parsing rules in 
-    // http://www.w3.org/TR/1999/REC-html401-19991224/types.html#type-media-descriptors
-
-    for (PRUint32 sub = 0, sub_end; sub < aBuffer.Length(); sub = sub_end + 1) {
-      sub_end = aBuffer.FindChar(PRUnichar(','), sub);
-      if (sub_end == PRUint32(kNotFound))
-        sub_end = aBuffer.Length();
-
-      PRUint32 parse_start, parse_end;
-      for (parse_start = sub;
-           parse_start < sub_end && nsCRT::IsAsciiSpace(aBuffer[parse_start]);
-           ++parse_start)
-        ;
-
-      for (parse_end = parse_start;
-           parse_end < sub_end &&
-           (nsCRT::IsAsciiAlpha(aBuffer[parse_end]) ||
-            nsCRT::IsAsciiDigit(aBuffer[parse_end]) ||
-            aBuffer[parse_end] == PRUnichar('-'));
-           ++parse_end)
-        ;
-
-      DoParseMediaList(Substring(aBuffer, parse_start, parse_end - parse_start),
-                       aURL, aLineNumber, aMediaList);
-    }
-
+  // For aHTMLMode, we used to follow the parsing rules in
+  // http://www.w3.org/TR/1999/REC-html401-19991224/types.html#type-media-descriptors
+  // which wouldn't work for media queries since they remove all but the
+  // first word.  However, they're changed in
+  // http://www.whatwg.org/specs/web-apps/current-work/multipage/section-document.html#media2
+  // (as of 2008-05-29) which says that the media attribute just points
+  // to a media query.  (The main substative difference is the relative
+  // precedence of commas and paretheses.)
+
+  nsresult rv = DoParseMediaList(aBuffer, aURL, aLineNumber, aMediaList);
+
+  if (aHTMLMode) {
     mHTMLMediaMode = PR_FALSE;
-  } else {
-    rv = DoParseMediaList(aBuffer, aURL, aLineNumber, aMediaList);
   }
 
   return rv;
 }
 
 // All parameters but the first are the same as for |ParseMediaList|,
 // but for HTML we get the buffer in chunks according to the HTML spec's
 // parsing rules instead of in one piece.
@@ -1107,16 +1103,17 @@ CSSParserImpl::DoParseMediaList(const ns
 }
 
 NS_IMETHODIMP
 CSSParserImpl::ParseColorString(const nsSubstring& aBuffer,
                                 nsIURI* aURL, // for error reporting
                                 PRUint32 aLineNumber, // for error reporting
                                 nscolor* aColor)
 {
+  AssertInitialState();
   nsresult rv = InitScanner(aBuffer, aURL, aLineNumber, aURL, nsnull);
   if (NS_FAILED(rv))
     return rv;
 
   nsCSSValue value;
   PRBool colorParsed = ParseColor(rv, value);
 
   OUTPUT_ERROR();
@@ -1161,18 +1158,17 @@ CSSParserImpl::ParseSelectorString(const
                                    nsIURI* aURL, // for error reporting
                                    PRUint32 aLineNumber, // for error reporting
                                    nsCSSSelectorList **aSelectorList)
 {
   nsresult rv = InitScanner(aSelectorString, aURL, aLineNumber, aURL, nsnull);
   if (NS_FAILED(rv))
     return rv;
 
-  NS_PRECONDITION(mUnresolvablePrefixException == PR_FALSE,
-                  "Bad initial state");
+  AssertInitialState();
 
   mUnresolvablePrefixException = PR_TRUE;
 
   PRBool success = ParseSelectorList(rv, *aSelectorList, PR_FALSE);
   OUTPUT_ERROR();
   ReleaseScanner();
 
   mUnresolvablePrefixException = PR_FALSE;
