From: L. David Baron <dbaron@dbaron.org>

Horrible hacks to deal with things that want an underlying frame.  (Bug 459144)

diff --git a/layout/base/FrameLayerBuilder.cpp b/layout/base/FrameLayerBuilder.cpp
--- a/layout/base/FrameLayerBuilder.cpp
+++ b/layout/base/FrameLayerBuilder.cpp
@@ -1002,16 +1002,30 @@ BuildTempManagerForInactiveLayer(nsDispl
   SetVisibleRectForLayer(layer, itemVisibleRect);
 
   tempManager->SetRoot(layer);
   // No painting should occur yet, since there is no target context.
   tempManager->EndTransaction(nsnull, nsnull);
   return tempManager.forget();
 }
 
+static nsIFrame*
+GetUnderlyingFrame(nsDisplayItem *item)
+{
+  for (;;) {
+    nsIFrame *f = item->GetUnderlyingFrame();
+    if (f)
+      return f;
+    NS_ABORT_IF_FALSE(item->GetType() ==
+                        nsDisplayItem::TYPE_CLIP_BORDER_RADIUS,
+                      "unexpected type");
+    item = item->GetList()->GetTop();
+  }
+}
+
 /*
  * Iterate through the non-clip items in aList and its descendants.
  * For each item we compute the effective clip rect. Each item is assigned
  * to a layer. We invalidate the areas in ThebesLayers where an item
  * has moved from one ThebesLayer to another. Also,
  * aState->mInvalidThebesContent is invalidated in every ThebesLayer.
  * We set the clip rect for items that generated their own layer.
  * (ThebesLayers don't need a clip rect on the layer, we clip the items
@@ -1102,17 +1116,17 @@ ContainerState::ProcessDisplayItems(cons
     } else {
       nsRefPtr<BasicLayerManager> tempLayerManager;
       if (layerState == LAYER_INACTIVE) {
         tempLayerManager = BuildTempManagerForInactiveLayer(mBuilder, item);
         if (!tempLayerManager)
           continue;
       }
 
-      nsIFrame* f = item->GetUnderlyingFrame();
+      nsIFrame* f = GetUnderlyingFrame(item);
       nsIFrame* activeScrolledRoot =
         nsLayoutUtils::GetActiveScrolledRootFor(f, mBuilder->ReferenceFrame());
       if (item->IsFixedAndCoveringViewport(mBuilder)) {
         // Make its active scrolled root be the active scrolled root of
         // the enclosing viewport, since it shouldn't be scrolled by scrolled
         // frames in its document. InvalidateFixedBackgroundFramesFromList in
         // nsGfxScrollFrame will not repaint this item when scrolling occurs.
         nsIFrame* viewportFrame =
@@ -1133,17 +1147,17 @@ ContainerState::ProcessDisplayItems(cons
                              layerState, tempLayerManager);
     }
   }
 }
 
 void
 ContainerState::InvalidateForLayerChange(nsDisplayItem* aItem, Layer* aNewLayer)
 {
-  nsIFrame* f = aItem->GetUnderlyingFrame();
+  nsIFrame* f = GetUnderlyingFrame(aItem); // KEY IS WRONG
   NS_ASSERTION(f, "Display items that render using Thebes must have a frame");
   PRUint32 key = aItem->GetPerFrameKey();
   NS_ASSERTION(key, "Display items that render using Thebes must have a key");
   Layer* oldLayer = mBuilder->LayerBuilder()->GetOldLayerFor(f, key);
   if (!oldLayer) {
     // Nothing to do here, this item didn't have a layer before
     return;
   }
@@ -1200,17 +1214,17 @@ FrameLayerBuilder::AddThebesDisplayItem(
 
 void
 FrameLayerBuilder::AddLayerDisplayItem(Layer* aLayer,
                                        nsDisplayItem* aItem)
 {
   if (aLayer->Manager() != mRetainingManager)
     return;
 
-  nsIFrame* f = aItem->GetUnderlyingFrame();
+  nsIFrame* f = GetUnderlyingFrame(aItem);
   DisplayItemDataEntry* entry = mNewDisplayItemData.PutEntry(f);
   if (entry) {
     entry->mData.AppendElement(DisplayItemData(aLayer, aItem->GetPerFrameKey()));
   }
 }
 
 nscolor
 FrameLayerBuilder::FindOpaqueColorCovering(nsDisplayListBuilder* aBuilder,
