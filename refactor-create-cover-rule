From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Create cover rule inside ConsiderStartingTransition rather than building it in a separate loop.

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -208,16 +208,33 @@ nsTransitionManager::StyleContextChanged
   if (collection) {
     afterChangeStyle = aNewStyleContext->PresContext()->StyleSet()->
       ResolveStyleWithoutAnimation(aElement, aNewStyleContext,
                                    eRestyle_CSSTransitions);
   } else {
     afterChangeStyle = aNewStyleContext;
   }
 
+  // In the CSS working group discussion (2009 Jul 15 telecon,
+  // http://www.w3.org/mid/4A5E1470.4030904@inkedblade.net ) of
+  // http://lists.w3.org/Archives/Public/www-style/2009Jun/0121.html ,
+  // the working group decided that a transition property on an
+  // element should not cause any transitions if the property change
+  // is itself inheriting a value that is transitioning on an
+  // ancestor.  So, to get the correct behavior, we continue the
+  // restyle that caused this transition using a "covering" rule that
+  // covers up any changes on which we started transitions, so that
+  // descendants don't start their own transitions.  (In the case of
+  // negative transition delay, this covering rule produces different
+  // results than applying the transition rule immediately would).
+  // Our caller is responsible for restyling again using this covering
+  // rule.
+
+  nsRefPtr<css::AnimValuesStyleRule> coverRule = new css::AnimValuesStyleRule;
+
   // Per http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html
   // I'll consider only the transitions from the number of items in
   // 'transition-property' on down, and later ones will override earlier
   // ones (tracked using |whichStarted|).
   bool startedAny = false;
   nsCSSPropertySet whichStarted;
   for (uint32_t i = disp->mTransitionPropertyCount; i-- != 0; ) {
     const StyleTransition& t = disp->mTransitions[i];
@@ -234,28 +251,28 @@ nsTransitionManager::StyleContextChanged
           property == eCSSProperty_UNKNOWN) {
         // Nothing to do, but need to exclude this from cases below.
       } else if (property == eCSSPropertyExtra_all_properties) {
         for (nsCSSProperty p = nsCSSProperty(0);
              p < eCSSProperty_COUNT_no_shorthands;
              p = nsCSSProperty(p + 1)) {
           ConsiderStartingTransition(p, t, aElement, collection,
                                      aOldStyleContext, afterChangeStyle,
-                                     &startedAny, &whichStarted);
+                                     &startedAny, &whichStarted, coverRule);
         }
       } else if (nsCSSProps::IsShorthand(property)) {
         CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(subprop, property) {
           ConsiderStartingTransition(*subprop, t, aElement, collection,
                                      aOldStyleContext, afterChangeStyle,
-                                     &startedAny, &whichStarted);
+                                     &startedAny, &whichStarted, coverRule);
         }
       } else {
         ConsiderStartingTransition(property, t, aElement, collection,
                                    aOldStyleContext, afterChangeStyle,
-                                   &startedAny, &whichStarted);
+                                   &startedAny, &whichStarted, coverRule);
       }
     }
   }
 
   // Stop any transitions for properties that are no longer in
   // 'transition-property'.
   // Also stop any transitions for properties that just changed (and are
   // still in the set of properties to transition), but we didn't just
@@ -326,64 +343,34 @@ nsTransitionManager::StyleContextChanged
 
   if (!startedAny) {
     return nullptr;
   }
 
   NS_ABORT_IF_FALSE(collection, "must have element transitions if we started "
                                 "any transitions");
 
-  // In the CSS working group discussion (2009 Jul 15 telecon,
-  // http://www.w3.org/mid/4A5E1470.4030904@inkedblade.net ) of
-  // http://lists.w3.org/Archives/Public/www-style/2009Jun/0121.html ,
-  // the working group decided that a transition property on an
-  // element should not cause any transitions if the property change
-  // is itself inheriting a value that is transitioning on an
-  // ancestor.  So, to get the correct behavior, we continue the
-  // restyle that caused this transition using a "covering" rule that
-  // covers up any changes on which we started transitions, so that
-  // descendants don't start their own transitions.  (In the case of
-  // negative transition delay, this covering rule produces different
-  // results than applying the transition rule immediately would).
-  // Our caller is responsible for restyling again using this covering
-  // rule.
-
-  nsRefPtr<css::AnimValuesStyleRule> coverRule = new css::AnimValuesStyleRule;
-
-  AnimationPlayerPtrArray& players = collection->mPlayers;
-  for (size_t i = 0, i_end = players.Length(); i < i_end; ++i) {
-    dom::Animation* anim = players[i]->GetSource();
-    MOZ_ASSERT(anim && anim->Properties().Length() == 1,
-               "Should have one animation property for a transition");
-    MOZ_ASSERT(anim && anim->Properties()[0].mSegments.Length() == 1,
-               "Animation property should have one segment for a transition");
-    AnimationProperty& prop = anim->Properties()[0];
-    AnimationPropertySegment& segment = prop.mSegments[0];
-    if (whichStarted.HasProperty(prop.mProperty)) {
-      coverRule->AddValue(prop.mProperty, segment.mFromValue);
-    }
-  }
-
   // Set the style rule refresh time to null so that EnsureStyleRuleFor
   // creates a new style rule.
   collection->mStyleRuleRefreshTime = TimeStamp();
 
   return coverRule.forget();
 }
 
 void
 nsTransitionManager::ConsiderStartingTransition(
   nsCSSProperty aProperty,
   const StyleTransition& aTransition,
   dom::Element* aElement,
   AnimationPlayerCollection*& aElementTransitions,
   nsStyleContext* aOldStyleContext,
   nsStyleContext* aNewStyleContext,
   bool* aStartedAny,
-  nsCSSPropertySet* aWhichStarted)
+  nsCSSPropertySet* aWhichStarted,
+  css::AnimValuesStyleRule* aCoverRule)
 {
   // IsShorthand itself will assert if aProperty is not a property.
   NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(aProperty),
                     "property out of range");
   NS_ASSERTION(!aElementTransitions ||
                aElementTransitions->mElement == aElement, "Element mismatch");
 
   if (aWhichStarted->HasProperty(aProperty)) {
@@ -583,16 +570,18 @@ nsTransitionManager::ConsiderStartingTra
     if (!players.AppendElement(player)) {
       NS_WARNING("out of memory");
       return;
     }
   }
   aElementTransitions->UpdateAnimationGeneration(mPresContext);
   aElementTransitions->PostRestyleForAnimation(presContext);
 
+  aCoverRule->AddValue(aProperty, startValue);
+
   *aStartedAny = true;
   aWhichStarted->AddProperty(aProperty);
 }
 
 /*
  * nsIStyleRuleProcessor implementation
  */
 
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
--- a/layout/style/nsTransitionManager.h
+++ b/layout/style/nsTransitionManager.h
@@ -160,14 +160,15 @@ private:
   void
   ConsiderStartingTransition(nsCSSProperty aProperty,
                              const mozilla::StyleTransition& aTransition,
                              mozilla::dom::Element* aElement,
                              AnimationPlayerCollection*& aElementTransitions,
                              nsStyleContext* aOldStyleContext,
                              nsStyleContext* aNewStyleContext,
                              bool* aStartedAny,
-                             nsCSSPropertySet* aWhichStarted);
+                             nsCSSPropertySet* aWhichStarted,
+                             mozilla::css::AnimValuesStyleRule* aCoverRule);
 
   bool mInAnimationOnlyStyleUpdate;
 };
 
 #endif /* !defined(nsTransitionManager_h_) */
