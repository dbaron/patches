Fix handling of specified widths on column-spanning cells.  b=363874  r=bernd  sr=roc

diff --git a/layout/reftests/bugs/363874-max-width-ref.html b/layout/reftests/bugs/363874-max-width-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/363874-max-width-ref.html
@@ -0,0 +1,19 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
+	"http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+	<title>Testcase, bug 363874</title>
+</head>
+<body>
+
+<table border width="100%">
+  <tr><td>100</td><td width="50">50</td></tr>
+</table>
+
+<table border>
+  <tr><td>aoeui aoeui aoeui aoeui aoeui aoeui aoeui aoeui aoeui</td></tr>
+  <tr><td width="100">100</td></tr>
+</table>
+
+</body>
+</html>
diff --git a/layout/reftests/bugs/363874-max-width.html b/layout/reftests/bugs/363874-max-width.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/363874-max-width.html
@@ -0,0 +1,19 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
+	"http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+	<title>Testcase, bug 363874</title>
+</head>
+<body>
+
+<table border width="100%">
+  <tr><td style="max-width: 100em">100</td><td width="50">50</td></tr>
+</table>
+
+<table border>
+  <tr><td style="max-width: 100em">aoeui aoeui aoeui aoeui aoeui aoeui aoeui aoeui aoeui</td></tr>
+  <tr><td width="100">100</td></tr>
+</table>
+
+</body>
+</html>
diff --git a/layout/reftests/bugs/363874-ref.html b/layout/reftests/bugs/363874-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/363874-ref.html
@@ -0,0 +1,15 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
+	"http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+	<title>Testcase, bug 363874</title>
+</head>
+<body>
+
+<table border="0" cellpadding="0" cellspacing="0">
+  <tr><td width="100">100</td><td width="50">50</td></tr>
+  <tr><td colspan="2" width="150">aoeui aoeui aoeui aoeui aoeui aoeui aoeui aoeui aoeui</td></tr>
+</table>
+
+</body>
+</html>
diff --git a/layout/reftests/bugs/363874.html b/layout/reftests/bugs/363874.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/363874.html
@@ -0,0 +1,15 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
+	"http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+	<title>Testcase, bug 363874</title>
+</head>
+<body>
+
+<table border="0" cellpadding="0" cellspacing="0">
+  <tr><td width="100">100</td><td width="50">50</td></tr>
+  <tr><td colspan="2">aoeui aoeui aoeui aoeui aoeui aoeui aoeui aoeui aoeui</td></tr>
+</table>
+
+</body>
+</html>
diff --git a/layout/reftests/bugs/reftest.list b/layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list
+++ b/layout/reftests/bugs/reftest.list
@@ -147,6 +147,8 @@ fails-if(MOZ_WIDGET_TOOLKIT!="windows") 
 == 363329-1.html 363329-1-ref.html
 == 363329-2.html 363329-2-ref.html
 == 363637-1.html 363637-1-ref.html
+== 363874.html 363874-ref.html
+== 363874-max-width.html 363874-max-width-ref.html
 == 364079-1.html 364079-1-ref.html
 == 364861-1.html 364861-1-ref.html
 == 364862-1.html 364862-1-ref.html
diff --git a/layout/tables/BasicTableLayoutStrategy.cpp b/layout/tables/BasicTableLayoutStrategy.cpp
--- a/layout/tables/BasicTableLayoutStrategy.cpp
+++ b/layout/tables/BasicTableLayoutStrategy.cpp
@@ -146,7 +146,6 @@ GetWidthInfo(nsIRenderingContext *aRende
         // XXX To really implement 'max-width' well, we'd need to store
         // it separately on the columns.
         case eStyleUnit_Coord: {
-                hasSpecifiedWidth = PR_TRUE;
                 nscoord w = aStylePos->mMaxWidth.GetCoordValue();
                 if (w < minCoord)
                     minCoord = w;
@@ -236,17 +235,13 @@ BasicTableLayoutStrategy::ComputeColumnI
             NS_ERROR("column frames out of sync with cell map");
             continue;
         }
-        colFrame->ResetMinCoord();
-        colFrame->ResetPrefCoord();
-        colFrame->ResetPrefPercent();
-        colFrame->ResetSpanMinCoord();
-        colFrame->ResetSpanPrefCoord();
-        colFrame->ResetSpanPrefPercent();
+        colFrame->ResetIntrinsics();
+        colFrame->ResetSpanIntrinsics();
 
         // Consider the widths on the column.
         CellWidthInfo colInfo = GetColWidthInfo(aRenderingContext, colFrame);
-        colFrame->AddMinCoord(colInfo.minCoord);
-        colFrame->AddPrefCoord(colInfo.prefCoord, colInfo.hasSpecifiedWidth);
+        colFrame->AddCoords(colInfo.minCoord, colInfo.prefCoord,
+                            colInfo.hasSpecifiedWidth);
         colFrame->AddPrefPercent(colInfo.prefPercent);
 
         // Consider the widths on the column-group.  Note that we follow
@@ -257,8 +252,8 @@ BasicTableLayoutStrategy::ComputeColumnI
                          nsGkAtoms::tableColGroupFrame,
                      "expected a column-group");
         colInfo = GetColWidthInfo(aRenderingContext, colFrame->GetParent());
-        colFrame->AddMinCoord(colInfo.minCoord);
-        colFrame->AddPrefCoord(colInfo.prefCoord, colInfo.hasSpecifiedWidth);
+        colFrame->AddCoords(colInfo.minCoord, colInfo.prefCoord,
+                            colInfo.hasSpecifiedWidth);
         colFrame->AddPrefPercent(colInfo.prefPercent);
 
         // Consider the contents of and the widths on the cells without
@@ -274,8 +269,8 @@ BasicTableLayoutStrategy::ComputeColumnI
 
             CellWidthInfo info = GetCellWidthInfo(aRenderingContext, cellFrame);
 
-            colFrame->AddMinCoord(info.minCoord);
-            colFrame->AddPrefCoord(info.prefCoord, info.hasSpecifiedWidth);
+            colFrame->AddCoords(info.minCoord, info.prefCoord,
+                                info.hasSpecifiedWidth);
             colFrame->AddPrefPercent(info.prefPercent);
         }
 #ifdef DEBUG_dbaron_off
@@ -295,9 +290,8 @@ BasicTableLayoutStrategy::ComputeColumnI
     // if they require adding to the widths resulting only from cells
     // with a smaller colspan, and therefore we must process them sorted
     // in increasing order by colspan.  For each colspan group, we
-    // accumulate the *additions* to the prior values in the column
-    // frame's Span* members, since this makes the distribution process
-    // simpler.
+    // accumulate new values to accumulate in the column frame's Span*
+    // members.
     //
     // Considering things only relative to the widths resulting from
     // cells with smaller colspans (rather than incrementally including
@@ -352,17 +346,25 @@ BasicTableLayoutStrategy::ComputeColumnI
                     info.prefCoord -= spacing;
                 }
 
-                totalSPref += scolFrame->GetPrefCoord();
+                nscoord curPref;
+                if (info.hasSpecifiedWidth &&
+                    !scolFrame->GetHasSpecifiedCoord()) {
+                    curPref = scolFrame->GetMinCoord();
+                } else {
+                    curPref = scolFrame->GetPrefCoord();
+                }
+
+                totalSPref += curPref;
                 totalSMin += scolFrame->GetMinCoord();
                 float scolPct = scolFrame->GetPrefPercent();
                 if (scolPct == 0.0f) {
-                    totalSNonPctPref += scolFrame->GetPrefCoord();
+                    totalSNonPctPref += curPref;
                     ++nonPctCount;
                 } else {
                     info.prefPercent -= scolPct;
                 }
                 info.minCoord -= scolFrame->GetMinCoord();
-                info.prefCoord -= scolFrame->GetPrefCoord();
+                info.prefCoord -= curPref;
             }
 
             if (info.minCoord < 0)
@@ -447,17 +449,27 @@ BasicTableLayoutStrategy::ComputeColumnI
                     coordRatio = 1.0f / float(scol_end - scol);
                 }
 
+                nscoord curPref;
+                if (info.hasSpecifiedWidth &&
+                    !scolFrame->GetHasSpecifiedCoord()) {
+                    curPref = scolFrame->GetMinCoord();
+                } else {
+                    curPref = scolFrame->GetPrefCoord();
+                }
+
                 // combine the two min-width distributions, and record
                 // min and pref
                 nscoord allocatedMinWithinPref =
                     NSToCoordRound(float(minWithinPref) * minRatio);
                 nscoord allocatedMinOutsidePref =
                     NSToCoordRound(float(minOutsidePref) * coordRatio);
-                scolFrame->AddSpanMinCoord(allocatedMinWithinPref +
-                                           allocatedMinOutsidePref);
                 nscoord allocatedPref =
                     NSToCoordRound(float(info.prefCoord) * coordRatio);
-                scolFrame->AddSpanPrefCoord(allocatedPref);
+                nscoord spanMin = scolFrame->GetMinCoord() +
+                        allocatedMinWithinPref + allocatedMinOutsidePref;
+                nscoord spanPref = curPref + allocatedPref;
+                scolFrame->AddSpanCoords(spanMin, spanPref,
+                                         info.hasSpecifiedWidth);
 
                 // To avoid accumulating rounding error from division,
                 // subtract everything to do with the column we've
@@ -466,10 +478,10 @@ BasicTableLayoutStrategy::ComputeColumnI
                 minOutsidePref -= allocatedMinOutsidePref;
                 info.prefCoord -= allocatedPref;
                 info.prefPercent -= allocatedPct;
-                totalSPref -= scolFrame->GetPrefCoord();
+                totalSPref -= curPref;
                 totalSMin -= scolFrame->GetMinCoord();
                 if (scolFrame->GetPrefPercent() == 0.0f) {
-                    totalSNonPctPref -= scolFrame->GetPrefCoord();
+                    totalSNonPctPref -= curPref;
                     --nonPctCount;
                 }
             }
@@ -494,27 +506,8 @@ BasicTableLayoutStrategy::ComputeColumnI
                 continue;
             }
 
-            // Since PrefCoord is really a shorthand for two values (XXX
-            // this isn't really a space savings since we have to store
-            // mHasSpecifiedCoord; we should probably just store the values
-            // since it's less confusing) and calling AddMinCoord can
-            // influence the result of GetPrefCoord, save the value as it
-            // was during the loop over spanning cells before messing with
-            // anything.
-            nscoord newPref =
-                colFrame->GetPrefCoord() + colFrame->GetSpanPrefCoord();
-            nscoord newMin =
-                colFrame->GetMinCoord() + colFrame->GetSpanMinCoord();
-            colFrame->AddMinCoord(newMin);
-            colFrame->AddPrefCoord(PR_MAX(newPref, newMin),
-                                   colFrame->GetHasSpecifiedCoord());
-            NS_ASSERTION(colFrame->GetMinCoord() <= colFrame->GetPrefCoord(),
-                         "min larger than pref");
-            colFrame->AddPrefPercent(colFrame->GetSpanPrefPercent());
-
-            colFrame->ResetSpanMinCoord();
-            colFrame->ResetSpanPrefCoord();
-            colFrame->ResetSpanPrefPercent();
+            colFrame->AccumulateSpanIntrinsics();
+            colFrame->ResetSpanIntrinsics();
 
 #ifdef DEBUG_dbaron_off
             printf("table %p col %d span %d: min=%d pref=%d spec=%d pct=%f\n",
diff --git a/layout/tables/nsTableColFrame.cpp b/layout/tables/nsTableColFrame.cpp
--- a/layout/tables/nsTableColFrame.cpp
+++ b/layout/tables/nsTableColFrame.cpp
@@ -55,12 +55,8 @@ nsTableColFrame::nsTableColFrame(nsStyle
 nsTableColFrame::nsTableColFrame(nsStyleContext* aContext) : nsFrame(aContext)
 {
   SetColType(eColContent);
-  ResetMinCoord();
-  ResetPrefCoord();
-  ResetPrefPercent();
-  ResetSpanMinCoord();
-  ResetSpanPrefCoord();
-  ResetSpanPrefPercent();
+  ResetIntrinsics();
+  ResetSpanIntrinsics();
   ResetFinalWidth();
 }
 
@@ -153,9 +149,10 @@ void nsTableColFrame::Dump(PRInt32 aInde
     printf(" anonymous-cell ");
     break;
   }
-  printf("\nm:%d c:%d p:%d sm:%d sc:%d sp:%d f:%d",
-         GetMinCoord(), GetPrefCoord(), GetPrefPercent(),
-         GetSpanMinCoord(), GetSpanPrefCoord(), GetSpanPrefPercent(),
+  printf("\nm:%d c:%d(%c) p:%f sm:%d sc:%d(%c) sp:%f f:%d",
+         mMinCoord, mPrefCoord, mHasSpecifiedCoord ? 's' : 'u', mPrefPercent,
+         mSpanMinCoord, mSpanPrefCoord, mSpanHasSpecifiedCoord ? 's' : 'u',
+         mSpanPrefPercent,
          GetFinalWidth());
   printf("\n%s**END COL DUMP** ", indent);
   delete [] indent;
diff --git a/layout/tables/nsTableColFrame.h b/layout/tables/nsTableColFrame.h
--- a/layout/tables/nsTableColFrame.h
+++ b/layout/tables/nsTableColFrame.h
@@ -135,94 +135,149 @@ public:
   void Dump(PRInt32 aIndent);
 #endif
 
-  // The largest min-width of the cells.
-  void ResetMinCoord() {
+  /**
+   * Restore the default values of the intrinsic widths, so that we can
+   * re-accumulate intrinsic widths from the cells in the column.
+   */
+  void ResetIntrinsics() {
     mMinCoord = 0;
-  }
-  void AddMinCoord(nscoord aMinCoord) {
+    mPrefCoord = 0;
+    mPrefPercent = 0.0f;
+    mHasSpecifiedCoord = PR_FALSE;
+  }
+
+  /**
+   * Restore the default value of the preferred percentage width (the
+   * only intrinsic width used by FixedTableLayoutStrategy.
+   */
+  void ResetPrefPercent() {
+    mPrefPercent = 0.0f;
+  }
+
+  /**
+   * Restore the default values of the temporary buffer for
+   * spanning-cell intrinsic widths (as we process spanning cells).
+   */
+  void ResetSpanIntrinsics() {
+    mSpanMinCoord = 0;
+    mSpanPrefCoord = 0;
+    mSpanPrefPercent = 0.0f;
+    mSpanHasSpecifiedCoord = PR_FALSE;
+  }
+
+  /**
+   * Add the widths for a cell or column element, or the contribution of
+   * the widths from a column-spanning cell:
+   * @param aMinCoord The minimum intrinsic width
+   * @param aPrefCoord The preferred intrinsic width or, if there is a
+   *   specified non-percentage width, max(specified width, minimum intrinsic
+   *   width).
+   * @param aHasSpecifiedCoord Whether there is a specified
+   *   non-percentage width.
+   *
+   * Note that the implementation of this functions is a bit tricky
+   * since mPrefCoord means different things depending on
+   * whether mHasSpecifiedCoord is true (and likewise for aPrefCoord and
+   * aHasSpecifiedCoord).  If mHasSpecifiedCoord is false, then
+   * all widths added had aHasSpecifiedCoord false and mPrefCoord is the
+   * largest of the pref widths.  But if mHasSpecifiedCoord is true,
+   * then mPrefCoord is the largest of (1) the pref widths for cells
+   * with aHasSpecifiedCoord true and (2) the min widths for cells with
+   * aHasSpecifiedCoord false.
+   */
+  void AddCoords(nscoord aMinCoord, nscoord aPrefCoord,
+                 PRBool aHasSpecifiedCoord) {
+    NS_ASSERTION(aMinCoord <= aPrefCoord, "intrinsic widths out of order");
+
+    if (aHasSpecifiedCoord && !mHasSpecifiedCoord) {
+      mPrefCoord = mMinCoord;
+      mHasSpecifiedCoord = PR_TRUE;
+    }
+    if (!aHasSpecifiedCoord && mHasSpecifiedCoord) {
+      aPrefCoord = aMinCoord; // NOTE: modifying argument
+    }
+
     if (aMinCoord > mMinCoord)
       mMinCoord = aMinCoord;
-    // Needed in case mHasSpecifiedCoord is true.
-    if (aMinCoord > mPrefCoord)
-      mPrefCoord = aMinCoord;
-  }
-  nscoord GetMinCoord() {
-    return mMinCoord;
-  }
-
-  // The largest pref-width of the cells
-  void ResetPrefCoord() {
-    mPrefCoord = 0;
-    mHasSpecifiedCoord = PR_FALSE;
-  }
-  void AddPrefCoord(nscoord aPrefCoord, PRBool aHasSpecifiedCoord) {
-    if (aHasSpecifiedCoord) {
-      if (!mHasSpecifiedCoord) {
-        mPrefCoord = mMinCoord;
-      }
-      mHasSpecifiedCoord = PR_TRUE;
-    }
-    if (aPrefCoord > mPrefCoord &&
-        (aHasSpecifiedCoord || !mHasSpecifiedCoord)) {
+    if (aPrefCoord > mPrefCoord)
       mPrefCoord = aPrefCoord;
-    }
-  }
-  nscoord GetPrefCoord() {
-    return mPrefCoord;
-  }
-
-  // Whether to expand greater than pref width more conservatively
-  // because the width was specified.
-  PRBool GetHasSpecifiedCoord() {
-    return mHasSpecifiedCoord;
-  }
-
-  // The largest specified percentage width of the cells.
-  void ResetPrefPercent() {
-    mPrefPercent = 0.0f;
-  }
+
+    NS_ASSERTION(mMinCoord <= mPrefCoord, "min larger than pref");
+  }
+
+  /**
+   * Add a percentage width specified on a cell or column element or the
+   * contribution to this column of a percentage width specified on a
+   * column-spanning cell.
+   */
   void AddPrefPercent(float aPrefPercent) {
     if (aPrefPercent > mPrefPercent)
       mPrefPercent = aPrefPercent;
   }
-  float GetPrefPercent() {
-    return mPrefPercent;
-  }
-
-  // The largest min-width of the cells (for column-spanning cells).
-  void ResetSpanMinCoord() {
-    mSpanMinCoord = 0;
-  }
-  void AddSpanMinCoord(nscoord aSpanMinCoord) {
+
+  /**
+   * Get the largest minimum intrinsic width for this column.
+   */
+  nscoord GetMinCoord() const { return mMinCoord; }
+  /**
+   * Get the largest preferred width for this column, or, if there were
+   * any specified non-percentage widths (see GetHasSpecifiedCoord), the
+   * largest minimum intrinsic width or specified width.
+   */
+  nscoord GetPrefCoord() const { return mPrefCoord; }
+  /**
+   * Get whether there were any specified widths contributing to this
+   * column.
+   */
+  PRBool GetHasSpecifiedCoord() const { return mHasSpecifiedCoord; }
+
+  /**
+   * Get the largest specified percentage width contributing to this
+   * column (returns 0 if there were none).
+   */
+  float GetPrefPercent() const { return mPrefPercent; }
+
+  /**
+   * Like AddCoords, but into a temporary buffer used for groups of
+   * column-spanning cells.
+   */
+  void AddSpanCoords(nscoord aSpanMinCoord, nscoord aSpanPrefCoord,
+                     PRBool aSpanHasSpecifiedCoord) {
+    NS_ASSERTION(aSpanMinCoord <= aSpanPrefCoord,
+                 "intrinsic widths out of order");
+
+    if (aSpanHasSpecifiedCoord && !mSpanHasSpecifiedCoord) {
+      mSpanPrefCoord = mSpanMinCoord;
+      mSpanHasSpecifiedCoord = PR_TRUE;
+    }
+    if (!aSpanHasSpecifiedCoord && mSpanHasSpecifiedCoord) {
+      aSpanPrefCoord = aSpanMinCoord; // NOTE: modifying argument
+    }
+
     if (aSpanMinCoord > mSpanMinCoord)
       mSpanMinCoord = aSpanMinCoord;
-  }
-  nscoord GetSpanMinCoord() {
-    return mSpanMinCoord;
-  }
-
-  // The largest pref-width of the column-spanning cells.
-  void ResetSpanPrefCoord() {
-    mSpanPrefCoord = 0;
-  }
-  void AddSpanPrefCoord(nscoord aSpanPrefCoord) {
     if (aSpanPrefCoord > mSpanPrefCoord)
       mSpanPrefCoord = aSpanPrefCoord;
-  }
-  nscoord GetSpanPrefCoord() {
-    return mSpanPrefCoord;
-  }
-
-  // The largest specified percentage width of the column-spanning cells.
-  void ResetSpanPrefPercent() {
-    mSpanPrefPercent = 0.0f;
-  }
+
+    NS_ASSERTION(mSpanMinCoord <= mSpanPrefCoord, "min larger than pref");
+  }
+
+  /*
+   * Accumulate percentage widths on column spanning cells into
+   * temporary variables.
+   */
   void AddSpanPrefPercent(float aSpanPrefPercent) {
     if (aSpanPrefPercent > mSpanPrefPercent)
       mSpanPrefPercent = aSpanPrefPercent;
   }
-  float GetSpanPrefPercent() {
-    return mSpanPrefPercent;
+
+  /*
+   * Accumulate the temporary variables for column spanning cells into
+   * the primary variables.
+   */
+  void AccumulateSpanIntrinsics() {
+    AddCoords(mSpanMinCoord, mSpanPrefCoord, mSpanHasSpecifiedCoord);
+    AddPrefPercent(mSpanPrefPercent);
   }
 
   // Used to adjust a column's pref percent so that the table's total
@@ -264,13 +319,14 @@ protected:
   BCPixelSize mBottomContBorderWidth;
 
   PRPackedBool mHasSpecifiedCoord;
+  PRPackedBool mSpanHasSpecifiedCoord; // XXX...
   nscoord mMinCoord;
   nscoord mPrefCoord;
   nscoord mSpanMinCoord; // XXX...
   nscoord mSpanPrefCoord; // XXX...
   float mPrefPercent;
   float mSpanPrefPercent; // XXX...
-  // ...XXX the three members marked above could be allocated as part of
+  // ...XXX the four members marked above could be allocated as part of
   // a separate array allocated only during
   // BasicTableLayoutStrategy::ComputeColumnIntrinsicWidths (and only
   // when colspans were present).
