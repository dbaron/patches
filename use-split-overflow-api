From: L. David Baron <dbaron@dbaron.org>

Change callers to use new nsIFrame overflow APIs.  (Bug 542595, patch 20)  r=roc  a2.0=blocking2.0:beta8

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -7578,17 +7578,17 @@ UpdateViewsForTree(nsIFrame* aFrame, nsI
           } while (outOfFlowFrame = outOfFlowFrame->GetNextContinuation());
         } else if (childList == nsGkAtoms::popupList) {
           DoApplyRenderingChangeToTree(child, aViewManager,
                                        aFrameManager, aChange);
         } else {  // regular frame
           if ((child->GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER) &&
               (aChange & nsChangeHint_RepaintFrame)) {
             FrameLayerBuilder::InvalidateThebesLayerContents(child,
-              child->GetOverflowRectRelativeToSelf());
+              child->GetVisualOverflowRectRelativeToSelf());
           }
           UpdateViewsForTree(child, aViewManager, aFrameManager, aChange);
         }
       }
       child = child->GetNextSibling();
     }
     childList = aFrame->GetAdditionalChildListName(listIndex++);
   } while (childList);
@@ -7633,23 +7633,23 @@ DoApplyRenderingChangeToTree(nsIFrame* a
         }
 #endif
       } else {
         aFrame->InvalidateOverflowRect();
       }
     }
     if (aChange & nsChangeHint_UpdateOpacityLayer) {
       aFrame->MarkLayersActive();
-      aFrame->InvalidateLayer(aFrame->GetOverflowRectRelativeToSelf(),
+      aFrame->InvalidateLayer(aFrame->GetVisualOverflowRectRelativeToSelf(),
                               nsDisplayItem::TYPE_OPACITY);
     }
     
     if (aChange & nsChangeHint_UpdateTransformLayer) {
       aFrame->MarkLayersActive();
-      aFrame->InvalidateLayer(aFrame->GetOverflowRectRelativeToSelf(),
+      aFrame->InvalidateLayer(aFrame->GetVisualOverflowRectRelativeToSelf(),
                               nsDisplayItem::TYPE_TRANSFORM);
     }
   }
 }
 
 static void
 ApplyRenderingChangeToTree(nsPresContext* aPresContext,
                            nsIFrame* aFrame,
diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -661,17 +661,20 @@ nsCSSRendering::PaintBorderWithStyleBord
 
 static nsRect
 GetOutlineInnerRect(nsIFrame* aFrame)
 {
   nsRect* savedOutlineInnerRect = static_cast<nsRect*>
     (aFrame->Properties().Get(nsIFrame::OutlineInnerRectProperty()));
   if (savedOutlineInnerRect)
     return *savedOutlineInnerRect;
-  return aFrame->GetOverflowRect();
+  // We probably want something narrower than either overflow rect here,
+  // but for now use the visual overflow in order to be consistent with
+  // ComputeOutlineAndEffectsRect in nsFrame.cpp.
+  return aFrame->GetVisualOverflowRect();
 }
 
 void
 nsCSSRendering::PaintOutline(nsPresContext* aPresContext,
                              nsIRenderingContext& aRenderingContext,
                              nsIFrame* aForFrame,
                              const nsRect& aDirtyRect,
                              const nsRect& aBorderArea,
@@ -1110,17 +1113,17 @@ nsCSSRendering::PaintBoxShadowOuter(nsPr
     NS_ASSERTION(aFrameArea.Size() == aForFrame->GetSize(), "unexpected size");
     hasBorderRadius = aForFrame->GetBorderRadii(twipsRadii);
     if (hasBorderRadius) {
       ComputePixelRadii(twipsRadii, twipsPerPixel, &borderRadii);
     }
   }
 
   nsRect frameRect =
-    nativeTheme ? aForFrame->GetOverflowRectRelativeToSelf() + aFrameArea.TopLeft() : aFrameArea;
+    nativeTheme ? aForFrame->GetVisualOverflowRectRelativeToSelf() + aFrameArea.TopLeft() : aFrameArea;
   gfxRect frameGfxRect(nsLayoutUtils::RectToGfxRect(frameRect, twipsPerPixel));
   frameGfxRect.Round();
 
   // We don't show anything that intersects with the frame we're blurring on. So tell the
   // blurrer not to do unnecessary work there.
   gfxRect skipGfxRect = frameGfxRect;
   PRBool useSkipGfxRect = PR_TRUE;
   if (nativeTheme) {
diff --git a/layout/base/nsCaret.cpp b/layout/base/nsCaret.cpp
--- a/layout/base/nsCaret.cpp
+++ b/layout/base/nsCaret.cpp
@@ -394,17 +394,17 @@ nsCaret::GetGeometryForFrame(nsIFrame* a
     // First, use the scrollFrame to get at the scrollable view that we're in.
     nsIScrollableFrame *sf = do_QueryFrame(scrollFrame);
     nsIFrame *scrolled = sf->GetScrolledFrame();
     nsRect caretInScroll = *aRect + aFrame->GetOffsetTo(scrolled);
 
     // Now see if thet caret extends beyond the view's bounds. If it does,
     // then snap it back, put it as close to the edge as it can.
     nscoord overflow = caretInScroll.XMost() -
-      scrolled->GetOverflowRectRelativeToSelf().width;
+      scrolled->GetVisualOverflowRectRelativeToSelf().width;
     if (overflow > 0)
       aRect->x -= overflow;
   }
 
   if (aBidiIndicatorSize)
     *aBidiIndicatorSize = caretMetrics.mBidiIndicatorSize;
 }
 
@@ -519,17 +519,17 @@ nsIFrame * nsCaret::GetCaretFrame(PRInt3
   return frame;
 }
 
 void nsCaret::InvalidateOutsideCaret()
 {
   nsIFrame *frame = GetCaretFrame();
 
   // Only invalidate if we are not fully contained by our frame's rect.
-  if (frame && !frame->GetOverflowRect().Contains(GetCaretRect()))
+  if (frame && !frame->GetVisualOverflowRect().Contains(GetCaretRect()))
     InvalidateRects(mCaretRect, GetHookRect(), frame);
 }
 
 void nsCaret::UpdateCaretPosition()
 {
   // We'll recalculate anyway if we're not drawn right now.
   if (!mDrawn)
     return;
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -114,17 +114,17 @@ static void MarkFrameForDisplay(nsIFrame
       break;
     }
   }
 }
 
 static void MarkOutOfFlowFrameForDisplay(nsIFrame* aDirtyFrame, nsIFrame* aFrame,
                                          const nsRect& aDirtyRect) {
   nsRect dirty = aDirtyRect - aFrame->GetOffsetTo(aDirtyFrame);
-  nsRect overflowRect = aFrame->GetOverflowRect();
+  nsRect overflowRect = aFrame->GetVisualOverflowRect();
   if (!dirty.IntersectRect(dirty, overflowRect))
     return;
   aFrame->Properties().Set(nsDisplayListBuilder::OutOfFlowDirtyRectProperty(),
                            new nsRect(dirty));
 
   MarkFrameForDisplay(aFrame, aDirtyFrame);
 }
 
@@ -889,17 +889,17 @@ nsDisplayBackground::GetBounds(nsDisplay
     return r + ToReferenceFrame();
   }
 
   return nsRect(ToReferenceFrame(), mFrame->GetSize());
 }
 
 nsRect
 nsDisplayOutline::GetBounds(nsDisplayListBuilder* aBuilder) {
-  return mFrame->GetOverflowRect() + ToReferenceFrame();
+  return mFrame->GetVisualOverflowRect() + ToReferenceFrame();
 }
 
 void
 nsDisplayOutline::Paint(nsDisplayListBuilder* aBuilder,
                         nsIRenderingContext* aCtx) {
   // TODO join outlines together
   nsPoint offset = ToReferenceFrame();
   nsCSSRendering::PaintOutline(mFrame->PresContext(), *aCtx, mFrame,
@@ -1017,17 +1017,17 @@ nsDisplayBoxShadowOuter::Paint(nsDisplay
     nsCSSRendering::PaintBoxShadowOuter(presContext, *aCtx, mFrame,
                                         borderRect, rects[i]);
     aCtx->PopState();
   }
 }
 
 nsRect
 nsDisplayBoxShadowOuter::GetBounds(nsDisplayListBuilder* aBuilder) {
-  return mFrame->GetOverflowRect() + ToReferenceFrame();
+  return mFrame->GetVisualOverflowRect() + ToReferenceFrame();
 }
 
 PRBool
 nsDisplayBoxShadowOuter::ComputeVisibility(nsDisplayListBuilder* aBuilder,
                                            nsRegion* aVisibleRegion) {
   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion))
     return PR_FALSE;
 
@@ -1855,17 +1855,17 @@ void nsDisplayTransform::HitTest(nsDispl
 
 }
 
 /* The bounding rectangle for the object is the overflow rectangle translated
  * by the reference point.
  */
 nsRect nsDisplayTransform::GetBounds(nsDisplayListBuilder *aBuilder)
 {
-  return mFrame->GetOverflowRect() + ToReferenceFrame();
+  return mFrame->GetVisualOverflowRect() + ToReferenceFrame();
 }
 
 /* The transform is opaque iff the transform consists solely of scales and
  * transforms and if the underlying content is opaque.  Thus if the transform
  * is of the form
  *
  * |a c e|
  * |b d f|
@@ -1986,17 +1986,17 @@ nsRect nsDisplayTransform::UntransformRe
   return nsLayoutUtils::MatrixTransformRect(aUntransformedBounds, matrix,
                                             factor);
 }
 
 #ifdef MOZ_SVG
 nsDisplaySVGEffects::nsDisplaySVGEffects(nsDisplayListBuilder* aBuilder,
                                          nsIFrame* aFrame, nsDisplayList* aList)
     : nsDisplayWrapList(aBuilder, aFrame, aList), mEffectsFrame(aFrame),
-      mBounds(aFrame->GetOverflowRectRelativeToSelf())
+      mBounds(aFrame->GetVisualOverflowRectRelativeToSelf())
 {
   MOZ_COUNT_CTOR(nsDisplaySVGEffects);
 }
 
 #ifdef NS_BUILD_REFCNT_LOGGING
 nsDisplaySVGEffects::~nsDisplaySVGEffects()
 {
   MOZ_COUNT_DTOR(nsDisplaySVGEffects);
diff --git a/layout/base/nsImageLoader.cpp b/layout/base/nsImageLoader.cpp
--- a/layout/base/nsImageLoader.cpp
+++ b/layout/base/nsImageLoader.cpp
@@ -232,17 +232,17 @@ nsImageLoader::DoRedraw(const nsRect* aD
 
   // Invalidate the entire frame
   // XXX We really only need to invalidate the client area of the frame...    
 
   nsRect bounds(nsPoint(0, 0), mFrame->GetSize());
 
   if (mFrame->GetType() == nsGkAtoms::canvasFrame) {
     // The canvas's background covers the whole viewport.
-    bounds = mFrame->GetOverflowRect();
+    bounds = mFrame->GetVisualOverflowRect();
   }
 
   // XXX this should be ok, but there is some crappy ass bug causing it not to work
   // XXX seems related to the "body fixup rule" dealing with the canvas and body frames...
 #if 0
   // Invalidate the entire frame only if the frame has a tiled background
   // image, otherwise just invalidate the intersection of the frame's bounds
   // with the damaged rect.
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -844,17 +844,17 @@ nsLayoutUtils::GetPopupFrameForEventCoor
     return nsnull;
   }
   nsTArray<nsIFrame*> popups = pm->GetVisiblePopups();
   PRUint32 i;
   // Search from top to bottom
   for (i = 0; i < popups.Length(); i++) {
     nsIFrame* popup = popups[i];
     if (popup->PresContext()->GetRootPresContext() == aPresContext &&
-        popup->GetOverflowRect().Contains(
+        popup->GetScrollableOverflowRect().Contains(
           GetEventCoordinatesRelativeTo(aEvent, popup))) {
       return popup;
     }
   }
 #endif
   return nsnull;
 }
 
@@ -1237,17 +1237,17 @@ nsLayoutUtils::PaintFrame(nsIRenderingCo
   if (aFlags & PAINT_WIDGET_LAYERS) {
     // This layer tree will be reused, so we'll need to calculate it
     // for the whole "visible" area of the window
     // 
     // |ignoreViewportScrolling| and |usingDisplayPort| are persistent
     // document-rendering state.  We rely on PresShell to flush
     // retained layers as needed when that persistent state changes.
     if (!presShell->UsingDisplayPort()) {
-      visibleRegion = aFrame->GetOverflowRectRelativeToSelf();
+      visibleRegion = aFrame->GetVisualOverflowRectRelativeToSelf();
     } else {
       visibleRegion = presShell->GetDisplayPort();
     }
   } else {
     visibleRegion = aDirtyRegion;
   }
 
   // If we're going to display something different from what we'd normally
@@ -2782,17 +2782,19 @@ CalculateBlockContentBottom(nsBlockFrame
 
 /* static */ nscoord
 nsLayoutUtils::CalculateContentBottom(nsIFrame* aFrame)
 {
   NS_PRECONDITION(aFrame, "null ptr");
 
   nscoord contentBottom = aFrame->GetRect().height;
 
-  if (aFrame->GetOverflowRect().height > contentBottom) {
+  // We want scrollable overflow rather than visual because this
+  // calculation is intended to affect layout.
+  if (aFrame->GetScrollableOverflowRect().height > contentBottom) {
     nsBlockFrame* blockFrame = GetAsBlock(aFrame);
     nsIAtom* childList = nsnull;
     PRIntn nextListID = 0;
     do {
       if (childList == nsnull && blockFrame) {
         contentBottom = NS_MAX(contentBottom, CalculateBlockContentBottom(blockFrame));
       }
       else if (childList != nsGkAtoms::overflowList &&
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -2539,17 +2539,17 @@ nsRootPresContext::GetPluginGeometryUpda
 {
   if (mRegisteredPlugins.Count() == 0)
     return;
 
   PluginGeometryClosure closure;
   closure.mRootFrame = mShell->FrameManager()->GetRootFrame();
   closure.mRootAPD = closure.mRootFrame->PresContext()->AppUnitsPerDevPixel();
   closure.mChangedSubtree = aChangedSubtree;
-  closure.mChangedRect = aChangedSubtree->GetOverflowRect() +
+  closure.mChangedRect = aChangedSubtree->GetVisualOverflowRect() +
       aChangedSubtree->GetOffsetToCrossDoc(closure.mRootFrame);
   PRInt32 subtreeAPD = aChangedSubtree->PresContext()->AppUnitsPerDevPixel();
   closure.mChangedRect =
     closure.mChangedRect.ConvertAppUnitsRoundOut(subtreeAPD, closure.mRootAPD);
   closure.mAffectedPlugins.Init();
   closure.mOutputConfigurations = aConfigurations;
   // Fill in closure.mAffectedPlugins and closure.mAffectedPluginBounds
   mRegisteredPlugins.EnumerateEntries(PluginBoundsEnumerator, &closure);
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -5546,17 +5546,17 @@ PresShell::CreateRangePaintInfo(nsIDOMRa
 
   if (!ancestorFrame)
     return nsnull;
 
   info = new RangePaintInfo(range, ancestorFrame);
   if (!info)
     return nsnull;
 
-  nsRect ancestorRect = ancestorFrame->GetOverflowRect();
+  nsRect ancestorRect = ancestorFrame->GetVisualOverflowRect();
 
   // get a display list containing the range
   if (aForPrimarySelection) {
     info->mBuilder.SetSelectedFramesOnly();
   }
   info->mBuilder.EnterPresShell(ancestorFrame, ancestorRect);
   ancestorFrame->BuildDisplayListForStackingContext(&info->mBuilder,
                                                     ancestorRect, &info->mList);
diff --git a/layout/forms/nsButtonFrameRenderer.cpp b/layout/forms/nsButtonFrameRenderer.cpp
--- a/layout/forms/nsButtonFrameRenderer.cpp
+++ b/layout/forms/nsButtonFrameRenderer.cpp
@@ -110,17 +110,17 @@ public:
   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder);
   NS_DISPLAY_DECL_NAME("ButtonBoxShadowOuter", TYPE_BUTTON_BOX_SHADOW_OUTER)
 private:
   nsButtonFrameRenderer* mBFR;
 };
 
 nsRect
 nsDisplayButtonBoxShadowOuter::GetBounds(nsDisplayListBuilder* aBuilder) {
-  return mFrame->GetOverflowRect() + ToReferenceFrame();
+  return mFrame->GetVisualOverflowRect() + ToReferenceFrame();
 }
 
 void
 nsDisplayButtonBoxShadowOuter::Paint(nsDisplayListBuilder* aBuilder,
                                      nsIRenderingContext* aCtx) {
   nsRect frameRect = nsRect(ToReferenceFrame(), mFrame->GetSize());
 
   nsRect buttonRect;
diff --git a/layout/forms/nsFileControlFrame.cpp b/layout/forms/nsFileControlFrame.cpp
--- a/layout/forms/nsFileControlFrame.cpp
+++ b/layout/forms/nsFileControlFrame.cpp
@@ -667,17 +667,17 @@ nsFileControlFrame::BuildDisplayList(nsD
   nsresult rv = nsBlockFrame::BuildDisplayList(aBuilder, aDirtyRect, tempList);
   if (NS_FAILED(rv))
     return rv;
 
   tempList.BorderBackground()->DeleteAll();
 
   // Clip height only
   nsRect clipRect(aBuilder->ToReferenceFrame(this), GetSize());
-  clipRect.width = GetOverflowRect().XMost();
+  clipRect.width = GetVisualOverflowRect().XMost();
   nscoord radii[8] = {0, 0, 0, 0, 0, 0, 0, 0};
   rv = OverflowClip(aBuilder, tempList, aLists, clipRect, radii);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Disabled file controls don't pass mouse events to their children, so we
   // put an invisible item in the display list above the children
   // just to catch events
   PRInt32 eventStates = mContent->IntrinsicState();
diff --git a/layout/forms/nsListControlFrame.cpp b/layout/forms/nsListControlFrame.cpp
--- a/layout/forms/nsListControlFrame.cpp
+++ b/layout/forms/nsListControlFrame.cpp
@@ -384,17 +384,17 @@ nsListControlFrame::InvalidateFocus()
   if (mFocused != this)
     return;
 
   nsIFrame* containerFrame = GetOptionsContainer();
   if (containerFrame) {
     // Invalidating from the containerFrame because that's where our focus
     // is drawn.
     // The origin of the scrollport is the origin of containerFrame.
-    nsRect invalidateArea = containerFrame->GetOverflowRect();
+    nsRect invalidateArea = containerFrame->GetVisualOverflowRect();
     nsRect emptyFallbackArea(0, 0, GetScrollPortRect().width, CalcFallbackRowHeight());
     invalidateArea.UnionRect(invalidateArea, emptyFallbackArea);
     containerFrame->Invalidate(invalidateArea);
   }
 }
 
 NS_QUERYFRAME_HEAD(nsListControlFrame)
   NS_QUERYFRAME_ENTRY(nsIFormControlFrame)
diff --git a/layout/forms/nsSelectsAreaFrame.cpp b/layout/forms/nsSelectsAreaFrame.cpp
--- a/layout/forms/nsSelectsAreaFrame.cpp
+++ b/layout/forms/nsSelectsAreaFrame.cpp
@@ -173,17 +173,18 @@ public:
     MOZ_COUNT_DTOR(nsDisplayListFocus);
   }
 #endif
 
   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
     // override bounds because the list item focus ring may extend outside
     // the nsSelectsAreaFrame
     nsListControlFrame* listFrame = GetEnclosingListFrame(GetUnderlyingFrame());
-    return listFrame->GetOverflowRect() + aBuilder->ToReferenceFrame(listFrame);
+    return listFrame->GetVisualOverflowRect() +
+           aBuilder->ToReferenceFrame(listFrame);
   }
   virtual void Paint(nsDisplayListBuilder* aBuilder,
                      nsIRenderingContext* aCtx) {
     nsListControlFrame* listFrame = GetEnclosingListFrame(GetUnderlyingFrame());
     // listFrame must be non-null or we wouldn't get called.
     listFrame->PaintFocus(*aCtx, aBuilder->ToReferenceFrame(listFrame));
   }
   NS_DISPLAY_DECL_NAME("ListFocus", TYPE_LIST_FOCUS)
diff --git a/layout/generic/nsAbsoluteContainingBlock.cpp b/layout/generic/nsAbsoluteContainingBlock.cpp
--- a/layout/generic/nsAbsoluteContainingBlock.cpp
+++ b/layout/generic/nsAbsoluteContainingBlock.cpp
@@ -394,17 +394,17 @@ nsAbsoluteContainingBlock::ReflowAbsolut
     PrettyUC(aReflowState.ComputedHeight(), height);
     printf("c=%s,%s \n", width, height);
   }
   AutoNoisyIndenter indent(nsBlockFrame::gNoisy);
 #endif // DEBUG
 
   // Store position and overflow rect so taht we can invalidate the correct
   // area if the position changes
-  nsRect oldOverflowRect(aKidFrame->GetOverflowRect() +
+  nsRect oldOverflowRect(aKidFrame->GetVisualOverflowRect() +
                          aKidFrame->GetPosition());
   nsRect oldRect = aKidFrame->GetRect();
 
   nsresult  rv;
   // Get the border values
   const nsMargin& border = aReflowState.mStyleBorder->GetActualBorder();
 
   nscoord availWidth = aContainingBlockWidth;
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -402,19 +402,22 @@ nsBlockFrame::List(FILE* out, PRInt32 aI
   }
 
   // Output the rect and state
   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
   if (0 != mState) {
     fprintf(out, " [state=%016llx]", mState);
   }
   nsBlockFrame* f = const_cast<nsBlockFrame*>(this);
-  if (f->HasOverflowRect()) {
-    nsRect overflowArea = f->GetOverflowRect();
-    fprintf(out, " [overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
+  if (f->HasOverflowAreas()) {
+    nsRect overflowArea = f->GetVisualOverflowRect();
+    fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
+            overflowArea.width, overflowArea.height);
+    overflowArea = f->GetScrollableOverflowRect();
+    fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
             overflowArea.width, overflowArea.height);
   }
   PRInt32 numInlineLines = 0;
   PRInt32 numBlockLines = 0;
   if (!mLines.empty()) {
     const_line_iterator line = begin_lines(), line_end = end_lines();
     for ( ; line != line_end; ++line) {
       if (line->IsBlock())
@@ -3210,17 +3213,17 @@ nsBlockFrame::ReflowBlockFrame(nsBlockRe
                            nsSize(availSpace.width, availSpace.height));
     } while (PR_TRUE);
 
     // If this was a second-pass reflow and the block's vertical position
     // changed, invalidates from the first pass might have happened in the
     // wrong places.  Invalidate the entire overflow rect at the new position.
     if (!mayNeedRetry && clearanceFrame &&
         frame->GetRect().y != passOriginalY) {
-      Invalidate(frame->GetOverflowRect() + frame->GetPosition());
+      Invalidate(frame->GetVisualOverflowRect() + frame->GetPosition());
     }
     
     NS_ENSURE_SUCCESS(rv, rv);
     
     if (mayNeedRetry && clearanceFrame) {
       aState.mFloatManager->PopState(&floatManagerState);
       aState.mY = startingY;
       aState.mPrevBottomMargin = incomingMargin;
@@ -5897,29 +5900,29 @@ nsBlockFrame::ReflowPushedFloats(nsBlock
        f = next) {
     // save next sibling now, since reflowing could push the entire
     // float, changing its siblings
     next = f->GetNextSibling();
 
     if (NS_SUBTREE_DIRTY(f) || aState.mReflowState.ShouldReflowAllKids()) {
       // Cache old bounds
       nsRect oldRect = f->GetRect();
-      nsRect oldOverflow = f->GetOverflowRect();
+      nsRect oldOverflow = f->GetVisualOverflowRect();
 
       // Reflow
       aState.FlowAndPlaceFloat(f);
 
       // Invalidate if there was a position or size change
       nsRect rect = f->GetRect();
       if (rect != oldRect) {
         nsRect dirtyRect = oldOverflow;
         dirtyRect.MoveBy(oldRect.x, oldRect.y);
         Invalidate(dirtyRect);
 
-        dirtyRect = f->GetOverflowRect();
+        dirtyRect = f->GetVisualOverflowRect();
         dirtyRect.MoveBy(rect.x, rect.y);
         Invalidate(dirtyRect);
       }
     }
     else {
       // Just reload the float region into the space manager
       nsRect region = nsFloatManager::GetRegionFor(f);
       aState.mFloatManager->AddFloat(f, region);
diff --git a/layout/generic/nsBlockReflowContext.cpp b/layout/generic/nsBlockReflowContext.cpp
--- a/layout/generic/nsBlockReflowContext.cpp
+++ b/layout/generic/nsBlockReflowContext.cpp
@@ -308,23 +308,22 @@ nsBlockReflowContext::ReflowBlock(const 
         (mMetrics.height == nscoord(0xdeadbeef))) {
       printf("nsBlockReflowContext: ");
       nsFrame::ListTag(stdout, mFrame);
       printf(" didn't set w/h %d,%d!\n", mMetrics.width, mMetrics.height);
     }
   }
 #endif
 
-  if (!mFrame->HasOverflowRect()) {
-    // Provide overflow area for child that doesn't have any
-    mMetrics.mOverflowArea.x = 0;
-    mMetrics.mOverflowArea.y = 0;
-    mMetrics.mOverflowArea.width = mMetrics.width;
-    mMetrics.mOverflowArea.height = mMetrics.height;
-  }
+  NS_ASSERTION(mMetrics.VisualOverflow().Contains(
+                 nsRect(0, 0, mMetrics.width, mMetrics.height)),
+               "overflow must contain frame bounds");
+  NS_ASSERTION(mMetrics.ScrollableOverflow().Contains(
+                 nsRect(0, 0, mMetrics.width, mMetrics.height)),
+               "overflow must contain frame bounds");
 
   if (!NS_INLINE_IS_BREAK_BEFORE(aFrameReflowStatus) ||
       (mFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
     // If frame is complete and has a next-in-flow, we need to delete
     // them now. Do not do this when a break-before is signaled because
     // the frame is going to get reflowed again (and may end up wanting
     // a next-in-flow where it ends up), unless it is an out of flow frame.
     if (NS_FRAME_IS_FULLY_COMPLETE(aFrameReflowStatus)) {
diff --git a/layout/generic/nsCanvasFrame.cpp b/layout/generic/nsCanvasFrame.cpp
--- a/layout/generic/nsCanvasFrame.cpp
+++ b/layout/generic/nsCanvasFrame.cpp
@@ -203,17 +203,17 @@ nsCanvasFrame::RemoveFrame(nsIAtom*     
 
   if (aOldFrame != mFrames.FirstChild())
     return NS_ERROR_FAILURE;
 
   // It's our one and only child frame
   // Damage the area occupied by the deleted frame
   // The child of the canvas probably can't have an outline, but why bother
   // thinking about that?
-  Invalidate(aOldFrame->GetOverflowRect() + aOldFrame->GetPosition());
+  Invalidate(aOldFrame->GetVisualOverflowRect() + aOldFrame->GetPosition());
 
   // Remove the frame and destroy it
   mFrames.DestroyFrame(aOldFrame);
 
   PresContext()->PresShell()->
     FrameNeedsReflow(this, nsIPresShell::eTreeChange,
                      NS_FRAME_HAS_DIRTY_CHILDREN);
   return NS_OK;
@@ -234,17 +234,19 @@ nsCanvasFrame::GetChildList(nsIAtom* aLi
   if (nsGkAtoms::absoluteList == aListName)
     return mAbsoluteContainer.GetChildList();
 
   return nsHTMLContainerFrame::GetChildList(aListName);
 }
 
 nsRect nsCanvasFrame::CanvasArea() const
 {
-  nsRect result(GetOverflowRect());
+  // Not clear which overflow rect we want here, but it probably doesn't
+  // matter.
+  nsRect result(GetVisualOverflowRect());
 
   nsIScrollableFrame *scrollableFrame = do_QueryFrame(GetParent());
   if (scrollableFrame) {
     nsRect portRect = scrollableFrame->GetScrollPortRect();
     result.UnionRect(result, nsRect(nsPoint(0, 0), portRect.Size()));
   }
   return result;
 }
@@ -517,17 +519,17 @@ nsCanvasFrame::Reflow(nsPresContext*    
     // If the child frame was just inserted, then we're responsible for making sure
     // it repaints
     if (kidDirty) {
       // But we have a new child, which will affect our background, so
       // invalidate our whole rect.
       // Note: Even though we request to be sized to our child's size, our
       // scroll frame ensures that we are always the size of the viewport.
       // Also note: GetPosition() on a CanvasFrame is always going to return
-      // (0, 0). We only want to invalidate GetRect() since GetOverflowRect()
+      // (0, 0). We only want to invalidate GetRect() since Get*OverflowRect()
       // could also include overflow to our top and left (out of the viewport)
       // which doesn't need to be painted.
       nsIFrame* viewport = PresContext()->GetPresShell()->GetRootFrame();
       viewport->Invalidate(nsRect(nsPoint(0, 0), viewport->GetSize()));
     } else {
       nsRect newKidRect = kidFrame->GetRect();
       if (newKidRect.TopLeft() == oldKidRect.TopLeft()) {
         InvalidateRectDifference(oldKidRect, kidFrame->GetRect());
diff --git a/layout/generic/nsColumnSetFrame.cpp b/layout/generic/nsColumnSetFrame.cpp
--- a/layout/generic/nsColumnSetFrame.cpp
+++ b/layout/generic/nsColumnSetFrame.cpp
@@ -438,17 +438,17 @@ PlaceFrameView(nsIFrame* aFrame)
     nsContainerFrame::PositionChildViews(aFrame);
 }
 
 static void MoveChildTo(nsIFrame* aParent, nsIFrame* aChild, nsPoint aOrigin) {
   if (aChild->GetPosition() == aOrigin) {
     return;
   }
   
-  nsRect r = aChild->GetOverflowRect();
+  nsRect r = aChild->GetVisualOverflowRect();
   r += aChild->GetPosition();
   aParent->Invalidate(r);
   r -= aChild->GetPosition();
   aChild->SetPosition(aOrigin);
   r += aOrigin;
   aParent->Invalidate(r);
   PlaceFrameView(aChild);
 }
@@ -598,18 +598,20 @@ nsColumnSetFrame::ReflowChildren(nsHTMLR
       && !(aUnboundedLastColumn && columnCount == aConfig.mBalanceColCount - 1)
       && !NS_SUBTREE_DIRTY(child->GetNextSibling());
     // If we need to pull up content from the prev-in-flow then this is not just
     // a height shrink. The prev in flow will have set the dirty bit.
     // Check the overflow rect YMost instead of just the child's content height. The child
     // may have overflowing content that cares about the available height boundary.
     // (It may also have overflowing content that doesn't care about the available height
     // boundary, but if so, too bad, this optimization is defeated.)
+    // We want scrollable overflow here since this is a calculation that
+    // affects layout.
     PRBool skipResizeHeightShrink = shrinkingHeightOnly
-      && child->GetOverflowRect().YMost() <= aConfig.mColMaxHeight;
+      && child->GetScrollableOverflowRect().YMost() <= aConfig.mColMaxHeight;
 
     nscoord childContentBottom = 0;
     if (!reflowNext && (skipIncremental || skipResizeHeightShrink)) {
       // This child does not need to be reflowed, but we may need to move it
       MoveChildTo(this, child, childOrigin);
       
       // If this is the last frame then make sure we get the right status
       nsIFrame* kidNext = child->GetNextSibling();
diff --git a/layout/generic/nsContainerFrame.cpp b/layout/generic/nsContainerFrame.cpp
--- a/layout/generic/nsContainerFrame.cpp
+++ b/layout/generic/nsContainerFrame.cpp
@@ -923,17 +923,17 @@ nsContainerFrame::ReflowOverflowContaine
       nsSize availSpace(prevRect.width, aReflowState.availableHeight);
       nsHTMLReflowMetrics desiredSize;
       nsHTMLReflowState frameState(aPresContext, aReflowState,
                                    frame, availSpace);
       nsReflowStatus frameStatus = NS_FRAME_COMPLETE;
 
       // Cache old bounds
       nsRect oldRect = frame->GetRect();
-      nsRect oldOverflow = frame->GetOverflowRect();
+      nsRect oldOverflow = frame->GetVisualOverflowRect();
 
       // Reflow
       rv = ReflowChild(frame, aPresContext, desiredSize, frameState,
                        prevRect.x, 0, aFlags, frameStatus, &tracker);
       NS_ENSURE_SUCCESS(rv, rv);
       //XXXfr Do we need to override any shrinkwrap effects here?
       // e.g. desiredSize.width = prevRect.width;
       rv = FinishReflowChild(frame, aPresContext, &frameState, desiredSize,
@@ -1544,19 +1544,22 @@ nsContainerFrame::List(FILE* out, PRInt3
     fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
   }
   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
   if (0 != mState) {
     fprintf(out, " [state=%016llx]", mState);
   }
   fprintf(out, " [content=%p]", static_cast<void*>(mContent));
   nsContainerFrame* f = const_cast<nsContainerFrame*>(this);
-  if (f->HasOverflowRect()) {
-    nsRect overflowArea = f->GetOverflowRect();
-    fprintf(out, " [overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
+  if (f->HasOverflowAreas()) {
+    nsRect overflowArea = f->GetVisualOverflowRect();
+    fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
+            overflowArea.width, overflowArea.height);
+    overflowArea = f->GetScrollableOverflowRect();
+    fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
             overflowArea.width, overflowArea.height);
   }
   fprintf(out, " [sc=%p]", static_cast<void*>(mStyleContext));
   nsIAtom* pseudoTag = mStyleContext->GetPseudo();
   if (pseudoTag) {
     nsAutoString atomString;
     pseudoTag->ToString(atomString);
     fprintf(out, " pst=%s",
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -1657,29 +1657,29 @@ nsIFrame::BuildDisplayListForChild(nsDis
   } else if (aBuilder->GetSelectedFramesOnly() &&
              aChild->IsLeaf() &&
              !(aChild->GetStateBits() & NS_FRAME_SELECTED_CONTENT)) {
     return NS_OK;
   }
 
   if (aBuilder->GetSelectedFramesOnly() &&
       (aChild->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
-    dirty = aChild->GetOverflowRect();
+    dirty = aChild->GetVisualOverflowRect();
   } else if (!(aChild->GetStateBits() & NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO)) {
     // No need to descend into aChild to catch placeholders for visible
     // positioned stuff. So see if we can short-circuit frame traversal here.
 
     // We can stop if aChild's frame subtree's intersection with the
     // dirty area is empty.
     // If the child is a scrollframe that we want to ignore, then we need
     // to descend into it because its scrolled child may intersect the dirty
     // area even if the scrollframe itself doesn't.
     if (aChild != aBuilder->GetIgnoreScrollFrame()) {
       nsRect childDirty;
-      if (!childDirty.IntersectRect(dirty, aChild->GetOverflowRect()))
+      if (!childDirty.IntersectRect(dirty, aChild->GetVisualOverflowRect()))
         return NS_OK;
       // Usually we could set dirty to childDirty now but there's no
       // benefit, and it can be confusing. It can especially confuse
       // situations where we're going to ignore a scrollframe's clipping;
       // we wouldn't want to clip the dirty area to the scrollframe's
       // bounds in that case.
     }
   }
@@ -4227,24 +4227,24 @@ nsIFrame::InvalidateRectDifference(const
   nsLayoutUtils::GetRectDifferenceStrips(aR1, aR2, &sizeHStrip, &sizeVStrip);
   Invalidate(sizeVStrip);
   Invalidate(sizeHStrip);
 }
 
 void
 nsIFrame::InvalidateFrameSubtree()
 {
-  Invalidate(GetOverflowRectRelativeToSelf());
+  Invalidate(GetVisualOverflowRectRelativeToSelf());
   FrameLayerBuilder::InvalidateThebesLayersInSubtree(this);
 }
 
 void
 nsIFrame::InvalidateOverflowRect()
 {
-  Invalidate(GetOverflowRectRelativeToSelf());
+  Invalidate(GetVisualOverflowRectRelativeToSelf());
 }
 
 NS_DECLARE_FRAME_PROPERTY(DeferInvalidatesProperty, nsIFrame::DestroyRegion)
 
 void
 nsIFrame::InvalidateRoot(const nsRect& aDamageRect, PRUint32 aFlags)
 {
   NS_ASSERTION(nsLayoutUtils::GetDisplayRootFrame(this) == this,
@@ -4343,16 +4343,21 @@ ComputeOutlineAndEffectsRect(nsIFrame* a
     if (width > 0) {
       if (aStoreRectProperties) {
         aFrame->Properties().
           Set(nsIFrame::OutlineInnerRectProperty(), new nsRect(r));
       }
 
       nscoord offset = outline->mOutlineOffset;
       nscoord inflateBy = NS_MAX(width + offset, 0);
+      // We probably want outline to be drawn around something smaller
+      // than the visual overflow rect (perhaps the scrollable overflow
+      // rect is correct).  When we change that, we need to keep this
+      // code (and the storing of properties just above) in sync with
+      // GetOutlineInnerRect in nsCSSRendering.cpp.
       r.Inflate(inflateBy, inflateBy);
       *aAnyOutlineOrEffects = PR_TRUE;
     }
   }
   
   // Note that we don't remove the outlineInnerRect if a frame loses outline
   // style. That would require an extra property lookup for every frame,
   // or a new frame state bit to track whether a property had been stored,
@@ -4443,17 +4448,17 @@ nsIFrame::GetVisualOverflowRectRelativeT
       return *preTransformBBox;
   }
   return GetVisualOverflowRect();
 }
 
 void
 nsFrame::CheckInvalidateSizeChange(nsHTMLReflowMetrics& aNewDesiredSize)
 {
-  nsIFrame::CheckInvalidateSizeChange(mRect, GetOverflowRect(),
+  nsIFrame::CheckInvalidateSizeChange(mRect, GetVisualOverflowRect(),
       nsSize(aNewDesiredSize.width, aNewDesiredSize.height));
 }
 
 static void
 InvalidateRectForFrameSizeChange(nsIFrame* aFrame, const nsRect& aRect)
 {
   nsStyleContext *bgSC;
   if (!nsCSSRendering::FindBackground(aFrame->PresContext(), aFrame, &bgSC)) {
@@ -4462,17 +4467,17 @@ InvalidateRectForFrameSizeChange(nsIFram
     rootFrame->Invalidate(nsRect(nsPoint(0, 0), rootFrame->GetSize()));
   }
 
   aFrame->Invalidate(aRect);
 }
 
 void
 nsIFrame::CheckInvalidateSizeChange(const nsRect& aOldRect,
-                                    const nsRect& aOldOverflowRect,
+                                    const nsRect& aOldVisualOverflowRect,
                                     const nsSize& aNewDesiredSize)
 {
   if (aNewDesiredSize == aOldRect.Size())
     return;
 
   // Below, we invalidate the old frame area (or, in the case of
   // outline, combined area) if the outline, border or background
   // settings indicate that something other than the difference
@@ -4487,20 +4492,21 @@ nsIFrame::CheckInvalidateSizeChange(cons
   // though root-invalidation is technically only needed in the case where
   // layer.RenderingMightDependOnFrameSize().  This allows us to simplify the
   // code somewhat and return immediately after invalidation in the earlier
   // cases.
 
   // Invalidate the entire old frame+outline if the frame has an outline
   PRBool anyOutlineOrEffects;
   nsRect r = ComputeOutlineAndEffectsRect(this, &anyOutlineOrEffects,
-                                          aOldOverflowRect, aNewDesiredSize,
+                                          aOldVisualOverflowRect,
+                                          aNewDesiredSize,
                                           PR_FALSE);
   if (anyOutlineOrEffects) {
-    r.UnionRect(aOldOverflowRect, r);
+    r.UnionRect(aOldVisualOverflowRect, r);
     InvalidateRectForFrameSizeChange(this, r);
     return;
   }
 
   // Invalidate the old frame border box if the frame has borders. Those
   // borders may be moving.
   const nsStyleBorder* border = GetStyleBorder();
   NS_FOR_CSS_SIDES(side) {
@@ -4628,19 +4634,22 @@ nsFrame::List(FILE* out, PRInt32 aIndent
   if (nsnull != prevInFlow) {
     fprintf(out, " prev-in-flow=%p", static_cast<void*>(prevInFlow));
   }
   if (nsnull != nextInFlow) {
     fprintf(out, " next-in-flow=%p", static_cast<void*>(nextInFlow));
   }
   fprintf(out, " [content=%p]", static_cast<void*>(mContent));
   nsFrame* f = const_cast<nsFrame*>(this);
-  if (f->HasOverflowRect()) {
-    nsRect overflowArea = f->GetOverflowRect();
-    fprintf(out, " [overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
+  if (f->HasOverflowAreas()) {
+    nsRect overflowArea = f->GetVisualOverflowRect();
+    fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
+            overflowArea.width, overflowArea.height);
+    overflowArea = f->GetScrollableOverflowRect();
+    fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
             overflowArea.width, overflowArea.height);
   }
   fprintf(out, " [sc=%p]", static_cast<void*>(mStyleContext));
   fputs("\n", out);
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -8136,29 +8145,42 @@ void nsFrame::DisplayReflowExit(nsPresCo
     char y[16];
     DR_state->PrettyUC(aMetrics.width, width);
     DR_state->PrettyUC(aMetrics.height, height);
     printf("Reflow d=%s,%s", width, height);
 
     if (!NS_FRAME_IS_FULLY_COMPLETE(aStatus)) {
       printf(" status=0x%x", aStatus);
     }
-    if (aFrame->HasOverflowRect()) {
-      DR_state->PrettyUC(aMetrics.mOverflowArea.x, x);
-      DR_state->PrettyUC(aMetrics.mOverflowArea.y, y);
-      DR_state->PrettyUC(aMetrics.mOverflowArea.width, width);
-      DR_state->PrettyUC(aMetrics.mOverflowArea.height, height);
-      printf(" o=(%s,%s) %s x %s", x, y, width, height);
-
-      nsRect storedOverflow = aFrame->GetOverflowRect();
+    if (aFrame->HasOverflowAreas()) {
+      DR_state->PrettyUC(aMetrics.VisualOverflow().x, x);
+      DR_state->PrettyUC(aMetrics.VisualOverflow().y, y);
+      DR_state->PrettyUC(aMetrics.VisualOverflow().width, width);
+      DR_state->PrettyUC(aMetrics.VisualOverflow().height, height);
+      printf(" vis-o=(%s,%s) %s x %s", x, y, width, height);
+
+      nsRect storedOverflow = aFrame->GetVisualOverflowRect();
       DR_state->PrettyUC(storedOverflow.x, x);
       DR_state->PrettyUC(storedOverflow.y, y);
       DR_state->PrettyUC(storedOverflow.width, width);
       DR_state->PrettyUC(storedOverflow.height, height);
-      printf(" sto=(%s,%s) %s x %s", x, y, width, height);
+      printf(" vis-sto=(%s,%s) %s x %s", x, y, width, height);
+
+      DR_state->PrettyUC(aMetrics.ScrollableOverflow().x, x);
+      DR_state->PrettyUC(aMetrics.ScrollableOverflow().y, y);
+      DR_state->PrettyUC(aMetrics.ScrollableOverflow().width, width);
+      DR_state->PrettyUC(aMetrics.ScrollableOverflow().height, height);
+      printf(" scr-o=(%s,%s) %s x %s", x, y, width, height);
+
+      storedOverflow = aFrame->GetScrollableOverflowRect();
+      DR_state->PrettyUC(storedOverflow.x, x);
+      DR_state->PrettyUC(storedOverflow.y, y);
+      DR_state->PrettyUC(storedOverflow.width, width);
+      DR_state->PrettyUC(storedOverflow.height, height);
+      printf(" scr-sto=(%s,%s) %s x %s", x, y, width, height);
     }
     printf("\n");
     if (DR_state->mDisplayPixelErrors) {
       PRInt32 p2t = aPresContext->AppUnitsPerDevPixel();
       CheckPixelError(aMetrics.width, p2t);
       CheckPixelError(aMetrics.height, p2t);
     }
   }
diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -528,17 +528,17 @@ nsHTMLScrollFrame::ReflowScrolledFrame(S
   // setting their mOverflowArea. This is wrong because every frame should
   // always set mOverflowArea. In fact nsObjectFrame and nsFrameFrame don't
   // support the 'outline' property because of this. Rather than fix the world
   // right now, just fix up the overflow area if necessary. Note that we don't
   // check HasOverflowRect() because it could be set even though the
   // overflow area doesn't include the frame bounds.
   aMetrics->UnionOverflowAreasWithDesiredBounds();
 
-  aState->mContentsOverflowArea = aMetrics->mOverflowArea;
+  aState->mContentsOverflowArea = aMetrics->ScrollableOverflow();
   aState->mReflowedContentsWithHScrollbar = aAssumeHScroll;
   aState->mReflowedContentsWithVScrollbar = aAssumeVScroll;
   
   return rv;
 }
 
 PRBool
 nsHTMLScrollFrame::GuessHScrollbarNeeded(const ScrollReflowState& aState)
@@ -626,17 +626,18 @@ nsHTMLScrollFrame::ReflowContents(Scroll
   // where the ideal case doesn't have a scrollbar?
   if ((aState->mReflowedContentsWithHScrollbar || aState->mReflowedContentsWithVScrollbar) &&
       aState->mStyles.mVertical != NS_STYLE_OVERFLOW_SCROLL &&
       aState->mStyles.mHorizontal != NS_STYLE_OVERFLOW_SCROLL) {
     nsSize insideBorderSize =
       ComputeInsideBorderSize(aState,
                               nsSize(kidDesiredSize.width, kidDesiredSize.height));
     nsRect scrolledRect =
-      mInner.GetScrolledRectInternal(kidDesiredSize.mOverflowArea, insideBorderSize);
+      mInner.GetScrolledRectInternal(kidDesiredSize.ScrollableOverflow(),
+                                     insideBorderSize);
     if (nsRect(nsPoint(0, 0), insideBorderSize).Contains(scrolledRect)) {
       // Let's pretend we had no scrollbars coming in here
       rv = ReflowScrolledFrame(aState, PR_FALSE, PR_FALSE,
                                &kidDesiredSize, PR_FALSE);
       NS_ENSURE_SUCCESS(rv, rv);
     }
   }
 
@@ -794,17 +795,17 @@ nsHTMLScrollFrame::Reflow(nsPresContext*
     reflowVScrollbar = NEEDS_REFLOW(mInner.mVScrollbarBox);
     reflowScrollCorner = NEEDS_REFLOW(mInner.mScrollCornerBox);
 
     #undef NEEDS_REFLOW
   }
 
   nsRect oldScrollAreaBounds = mInner.mScrollPort;
   nsRect oldScrolledAreaBounds =
-    mInner.mScrolledFrame->GetOverflowRectRelativeToParent();
+    mInner.mScrolledFrame->GetScrollableOverflowRectRelativeToParent();
   // Adjust to a multiple of device pixels to restore the invariant that
   // oldScrollPosition is a multiple of device pixels. This could have been
   // thrown out by a zoom change.
   nsIntPoint ptDevPx;
   nsPoint oldScrollPosition = mInner.GetScrollPosition();
   
   state.mComputedBorder = aReflowState.mComputedBorderPadding -
     aReflowState.mComputedPadding;
@@ -824,17 +825,17 @@ nsHTMLScrollFrame::Reflow(nsPresContext*
   }
 
   PRBool didHaveHScrollbar = mInner.mHasHorizontalScrollbar;
   PRBool didHaveVScrollbar = mInner.mHasVerticalScrollbar;
   mInner.mHasHorizontalScrollbar = state.mShowHScrollbar;
   mInner.mHasVerticalScrollbar = state.mShowVScrollbar;
   nsRect newScrollAreaBounds = mInner.mScrollPort;
   nsRect newScrolledAreaBounds =
-    mInner.mScrolledFrame->GetOverflowRectRelativeToParent();
+    mInner.mScrolledFrame->GetScrollableOverflowRectRelativeToParent();
   if (mInner.mSkippedScrollbarLayout ||
       reflowHScrollbar || reflowVScrollbar || reflowScrollCorner ||
       (GetStateBits() & NS_FRAME_IS_DIRTY) ||
       didHaveHScrollbar != state.mShowHScrollbar ||
       didHaveVScrollbar != state.mShowVScrollbar ||
       oldScrollAreaBounds != newScrollAreaBounds ||
       oldScrolledAreaBounds != newScrolledAreaBounds) {
     if (!mInner.mSupppressScrollbarUpdate) {
@@ -2530,17 +2531,17 @@ nsXULScrollFrame::LayoutScrollArea(nsBox
                                    const nsPoint& aScrollPosition)
 {
   PRUint32 oldflags = aState.LayoutFlags();
   nsRect childRect = nsRect(mInner.mScrollPort.TopLeft() - aScrollPosition,
                             mInner.mScrollPort.Size());
   PRInt32 flags = NS_FRAME_NO_MOVE_VIEW;
 
   nsRect originalRect = mInner.mScrolledFrame->GetRect();
-  nsRect originalOverflow = mInner.mScrolledFrame->GetOverflowRect();
+  nsRect originalVisOverflow = mInner.mScrolledFrame->GetVisualOverflowRect();
 
   nsSize minSize = mInner.mScrolledFrame->GetMinSize(aState);
   
   if (minSize.height > childRect.height)
     childRect.height = minSize.height;
   
   if (minSize.width > childRect.width)
     childRect.width = minSize.width;
@@ -2552,42 +2553,42 @@ nsXULScrollFrame::LayoutScrollArea(nsBox
   childRect = mInner.mScrolledFrame->GetRect();
 
   if (childRect.width < mInner.mScrollPort.width ||
       childRect.height < mInner.mScrollPort.height)
   {
     childRect.width = NS_MAX(childRect.width, mInner.mScrollPort.width);
     childRect.height = NS_MAX(childRect.height, mInner.mScrollPort.height);
 
-    // remove overflow area when we update the bounds,
+    // remove overflow areas when we update the bounds,
     // because we've already accounted for it
-    mInner.mScrolledFrame->SetBounds(aState, childRect);
-    mInner.mScrolledFrame->ClearOverflowRect();
+    // REVIEW: Have we accounted for both?
+    mInner.mScrolledFrame->SetBounds(aState, childRect, PR_TRUE);
   }
 
   nsRect finalRect = mInner.mScrolledFrame->GetRect();
-  nsRect finalOverflow = mInner.mScrolledFrame->GetOverflowRect();
+  nsRect finalVisOverflow = mInner.mScrolledFrame->GetVisualOverflowRect();
   // The position of the scrolled frame shouldn't change, but if it does or
   // the position of the overflow rect changes just invalidate both the old
   // and new overflow rect.
   if (originalRect.TopLeft() != finalRect.TopLeft() ||
-      originalOverflow.TopLeft() != finalOverflow.TopLeft())
+      originalVisOverflow.TopLeft() != finalVisOverflow.TopLeft())
   {
     // The old overflow rect needs to be adjusted if the frame's position
     // changed.
     mInner.mScrolledFrame->Invalidate(
-      originalOverflow + originalRect.TopLeft() - finalRect.TopLeft());
-    mInner.mScrolledFrame->Invalidate(finalOverflow);
-  } else if (!originalOverflow.IsExactEqual(finalOverflow)) {
+      originalVisOverflow + originalRect.TopLeft() - finalRect.TopLeft());
+    mInner.mScrolledFrame->Invalidate(finalVisOverflow);
+  } else if (!originalVisOverflow.IsExactEqual(finalVisOverflow)) {
     // If the overflow rect changed then invalidate the difference between the
     // old and new overflow rects.
     mInner.mScrolledFrame->CheckInvalidateSizeChange(
-      originalRect, originalOverflow, finalRect.Size());
+      originalRect, originalVisOverflow, finalRect.Size());
     mInner.mScrolledFrame->InvalidateRectDifference(
-      originalOverflow, finalOverflow);
+      originalVisOverflow, finalVisOverflow);
   }
 
   aState.SetLayoutFlags(oldflags);
 
 }
 
 void nsGfxScrollFrameInner::PostOverflowEvent()
 {
@@ -2985,25 +2986,27 @@ static void LayoutAndInvalidate(nsBoxLay
   // mHasVScrollbar/mHasHScrollbar is false, and this is called after those
   // flags have been set ... if a scrollbar is being hidden, we still need
   // to invalidate the scrollbar area here.
   // But we also need to invalidate the scrollbar itself in case it has
   // its own layer; we need to ensure that layer is updated.
   PRBool rectChanged = aBox->GetRect() != aRect;
   if (rectChanged) {
     if (aScrollbarIsBeingHidden) {
-      aBox->GetParent()->Invalidate(aBox->GetOverflowRect() + aBox->GetPosition());
+      aBox->GetParent()->Invalidate(aBox->GetVisualOverflowRect() +
+                                    aBox->GetPosition());
     } else {
       aBox->InvalidateFrameSubtree();
     }
   }
   nsBoxFrame::LayoutChildAt(aState, aBox, aRect);
   if (rectChanged) {
     if (aScrollbarIsBeingHidden) {
-      aBox->GetParent()->Invalidate(aBox->GetOverflowRect() + aBox->GetPosition());
+      aBox->GetParent()->Invalidate(aBox->GetVisualOverflowRect() +
+                                    aBox->GetPosition());
     } else {
       aBox->InvalidateFrameSubtree();
     }
   }
 }
 
 void
 nsGfxScrollFrameInner::AdjustScrollbarRectForResizer(
@@ -3227,17 +3230,17 @@ nsGfxScrollFrameInner::GetBorderRadii(ns
 
   return PR_TRUE;
 }
 
 nsRect
 nsGfxScrollFrameInner::GetScrolledRect() const
 {
   nsRect result =
-    GetScrolledRectInternal(mScrolledFrame->GetOverflowRect(),
+    GetScrolledRectInternal(mScrolledFrame->GetScrollableOverflowRect(),
                             mScrollPort.Size());
 
   NS_ASSERTION(result.width >= mScrollPort.width,
                "Scrolled rect smaller than scrollport?");
   NS_ASSERTION(result.height >= mScrollPort.height,
                "Scrolled rect smaller than scrollport?");
   return result;
 }
@@ -3384,15 +3387,15 @@ void
 nsGfxScrollFrameInner::FireScrolledAreaEvent()
 {
   mScrolledAreaEvent.Forget();
 
   nsScrollAreaEvent event(PR_TRUE, NS_SCROLLEDAREACHANGED, nsnull);
   nsPresContext *prescontext = mOuter->PresContext();
   nsIContent* content = mOuter->GetContent();
 
-  event.mArea = mScrolledFrame->GetOverflowRectRelativeToParent();
+  event.mArea = mScrolledFrame->GetScrollableOverflowRectRelativeToParent();
 
   nsIDocument *doc = content->GetCurrentDoc();
   if (doc) {
     nsEventDispatcher::Dispatch(doc, prescontext, &event, nsnull);
   }
 }
diff --git a/layout/generic/nsHTMLContainerFrame.cpp b/layout/generic/nsHTMLContainerFrame.cpp
--- a/layout/generic/nsHTMLContainerFrame.cpp
+++ b/layout/generic/nsHTMLContainerFrame.cpp
@@ -147,17 +147,17 @@ nsDisplayTextDecoration::Paint(nsDisplay
                                metrics.strikeoutOffset, ascent,
                                metrics.strikeoutSize, mDecoration);
   }
 }
 
 nsRect
 nsDisplayTextDecoration::GetBounds(nsDisplayListBuilder* aBuilder)
 {
-  return mFrame->GetOverflowRect() + ToReferenceFrame();
+  return mFrame->GetVisualOverflowRect() + ToReferenceFrame();
 }
 
 class nsDisplayTextShadow : public nsDisplayItem {
 public:
   nsDisplayTextShadow(nsDisplayListBuilder* aBuilder,
                       nsHTMLContainerFrame* aFrame,
                       const PRUint8 aDecoration,
                       nsLineBox* aLine)
@@ -319,17 +319,17 @@ nsDisplayTextShadow::Paint(nsDisplayList
     contextBoxBlur.DoPaint();
   }
 }
 
 nsRect
 nsDisplayTextShadow::GetBounds(nsDisplayListBuilder* aBuilder)
 {
   // Shadows are always painted in the overflow rect
-  return mFrame->GetOverflowRect() + ToReferenceFrame();
+  return mFrame->GetVisualOverflowRect() + ToReferenceFrame();
 }
 
 nsresult
 nsHTMLContainerFrame::DisplayTextDecorations(nsDisplayListBuilder* aBuilder,
                                              nsDisplayList* aBelowTextDecorations,
                                              nsDisplayList* aAboveTextDecorations,
                                              nsLineBox* aLine)
 {
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2487,17 +2487,17 @@ NS_PTR_TO_INT32(frame->Properties().Get(
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) = 0;
   virtual PRBool IsCollapsed(nsBoxLayoutState& aBoxLayoutState) = 0;
   // This does not alter the overflow area. If the caller is changing
   // the box size, the caller is responsible for updating the overflow
   // area. It's enough to just call Layout or SyncLayout on the
   // box. You can pass PR_TRUE to aRemoveOverflowArea as a
   // convenience.
   virtual void SetBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
-                         PRBool aRemoveOverflowArea = PR_FALSE)=0;
+                         PRBool aRemoveOverflowAreas = PR_FALSE) = 0;
   NS_HIDDEN_(nsresult) Layout(nsBoxLayoutState& aBoxLayoutState);
   nsIBox* GetChildBox() const
   {
     // box layout ends at box-wrapped frames, so don't allow these frames
     // to report child boxes.
     return IsBoxFrame() ? GetFirstChild(nsnull) : nsnull;
   }
   nsIBox* GetNextBox() const
@@ -2568,17 +2568,17 @@ NS_PTR_TO_INT32(frame->Properties().Get(
   /**
    * Same thing as nsFrame::CheckInvalidateSizeChange, but more flexible.  The
    * implementation of this method must not depend on the mRect or
    * GetVisualOverflowRect() of the frame!  Note that it's safe to
    * assume in this method that the frame origin didn't change.  If it
    * did, whoever moved the frame will invalidate as needed anyway.
    */
   void CheckInvalidateSizeChange(const nsRect& aOldRect,
-                                 const nsRect& aOldOverflowRect,
+                                 const nsRect& aOldVisualOverflowRect,
                                  const nsSize& aNewDesiredSize);
 
   /**
    * Get a line iterator for this frame, if supported.
    *
    * @return nsnull if no line iterator is supported.
    * @note dispose the line iterator using nsILineIterator::DisposeLineIterator
    */
diff --git a/layout/generic/nsPageContentFrame.cpp b/layout/generic/nsPageContentFrame.cpp
--- a/layout/generic/nsPageContentFrame.cpp
+++ b/layout/generic/nsPageContentFrame.cpp
@@ -112,23 +112,27 @@ nsPageContentFrame::Reflow(nsPresContext
     // take into account the combined area and any space taken up by
     // absolutely positioned elements
     nsMargin padding(0,0,0,0);
 
     // XXXbz this screws up percentage padding (sets padding to zero
     // in the percentage padding case)
     kidReflowState.mStylePadding->GetPadding(padding);
 
-    // First check the combined area
-    if (frame->HasOverflowRect()) {
+    // This is for shrink-to-fit, and therefore we want to use the
+    // scrollable overflow, since the purpose of shrink to fit is to
+    // make the content that ought to be reachable (represented by the
+    // scrollable overflow) fit in the page.
+    if (frame->HasOverflowAreas()) {
       // The background covers the content area and padding area, so check
       // for children sticking outside the child frame's padding edge
-      if (aDesiredSize.mOverflowArea.XMost() > aDesiredSize.width) {
+      nscoord xmost = aDesiredSize.ScrollableOverflow().XMost();
+      if (xmost > aDesiredSize.width) {
         mPD->mPageContentXMost =
-          aDesiredSize.mOverflowArea.XMost() +
+          xmost +
           kidReflowState.mStyleBorder->GetActualBorderWidth(NS_SIDE_RIGHT) +
           padding.right;
       }
     }
 
     // Place and size the child
     FinishReflowChild(frame, aPresContext, &kidReflowState, aDesiredSize, 0, 0, 0);
 
diff --git a/layout/generic/nsTextFrameThebes.cpp b/layout/generic/nsTextFrameThebes.cpp
--- a/layout/generic/nsTextFrameThebes.cpp
+++ b/layout/generic/nsTextFrameThebes.cpp
@@ -3933,17 +3933,17 @@ public:
   }
 #ifdef NS_BUILD_REFCNT_LOGGING
   virtual ~nsDisplayText() {
     MOZ_COUNT_DTOR(nsDisplayText);
   }
 #endif
 
   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
-    return mFrame->GetOverflowRect() + ToReferenceFrame();
+    return mFrame->GetVisualOverflowRect() + ToReferenceFrame();
   }
   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames) {
     if (nsRect(ToReferenceFrame(), mFrame->GetSize()).Intersects(aRect)) {
       aOutFrames->AppendElement(mFrame);
     }
   }
   virtual void Paint(nsDisplayListBuilder* aBuilder,
@@ -7058,19 +7058,24 @@ nsTextFrame::List(FILE* out, PRInt32 aIn
   if (0 != mState) {
     if (mState & NS_FRAME_SELECTED_CONTENT) {
       fprintf(out, " [state=%016llx] SELECTED", mState);
     } else {
       fprintf(out, " [state=%016llx]", mState);
     }
   }
   fprintf(out, " [content=%p]", static_cast<void*>(mContent));
-  if (HasOverflowRect()) {
-    nsRect overflowArea = GetOverflowRect();
-    fprintf(out, " [overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
+  if (HasOverflowAreas()) {
+    nsRect overflowArea = GetVisualOverflowRect();
+    fprintf(out, " [vis-overflow=%d,%d,%d,%d]",
+            overflowArea.x, overflowArea.y,
+            overflowArea.width, overflowArea.height);
+    overflowArea = GetScrollableOverflowRect();
+    fprintf(out, " [scr-overflow=%d,%d,%d,%d]",
+            overflowArea.x, overflowArea.y,
             overflowArea.width, overflowArea.height);
   }
   fprintf(out, " sc=%p", static_cast<void*>(mStyleContext));
   nsIAtom* pseudoTag = mStyleContext->GetPseudo();
   if (pseudoTag) {
     nsAutoString atomString;
     pseudoTag->ToString(atomString);
     fprintf(out, " pst=%s",
diff --git a/layout/svg/base/src/nsSVGIntegrationUtils.cpp b/layout/svg/base/src/nsSVGIntegrationUtils.cpp
--- a/layout/svg/base/src/nsSVGIntegrationUtils.cpp
+++ b/layout/svg/base/src/nsSVGIntegrationUtils.cpp
@@ -69,17 +69,17 @@ nsSVGIntegrationUtils::GetNonSVGUserSpac
 
 static nsRect
 GetPreEffectsOverflowRect(nsIFrame* aFrame)
 {
   nsRect* r = static_cast<nsRect*>
     (aFrame->Properties().Get(nsIFrame::PreEffectsBBoxProperty()));
   if (r)
     return *r;
-  return aFrame->GetOverflowRect();
+  return aFrame->GetVisualOverflowRect();
 }
 
 struct BBoxCollector : public nsLayoutUtils::BoxCallback {
   nsIFrame*     mReferenceFrame;
   nsIFrame*     mCurrentFrame;
   const nsRect& mCurrentFrameOverflowArea;
   nsRect        mResult;
 
@@ -147,17 +147,17 @@ nsSVGIntegrationUtils::GetInvalidAreaFor
     nsSVGEffects::GetEffectProperties(firstFrame);
   if (!effectProperties.mFilter)
     return aInvalidRect;
   nsSVGFilterFrame* filterFrame = nsSVGEffects::GetFilterFrame(firstFrame);
   if (!filterFrame) {
     // The frame is either not there or not currently available,
     // perhaps because we're in the middle of tearing stuff down.
     // Be conservative.
-    return aFrame->GetOverflowRect();
+    return aFrame->GetVisualOverflowRect();
   }
 
   PRInt32 appUnitsPerDevPixel = aFrame->PresContext()->AppUnitsPerDevPixel();
   nsRect userSpaceRect = GetNonSVGUserSpace(firstFrame);
   nsPoint offset = aFrame->GetOffsetTo(firstFrame) - userSpaceRect.TopLeft();
   nsRect r = aInvalidRect + offset;
   nsIntRect p = r.ToOutsidePixels(appUnitsPerDevPixel);
   p = filterFrame->GetInvalidationBBox(firstFrame, p);
diff --git a/layout/svg/base/src/nsSVGUtils.cpp b/layout/svg/base/src/nsSVGUtils.cpp
--- a/layout/svg/base/src/nsSVGUtils.cpp
+++ b/layout/svg/base/src/nsSVGUtils.cpp
@@ -615,17 +615,17 @@ nsSVGUtils::FindFilterInvalidation(nsIFr
       nsSVGDisplayContainerFrame* viewportFrame = GetNearestSVGViewport(aFrame);
       while (viewportFrame && !viewportFrame->GetStyleDisplay()->IsScrollableOverflow()) {
         viewportFrame = GetNearestSVGViewport(viewportFrame);
       }
       if (!viewportFrame) {
         viewportFrame = GetOuterSVGFrame(aFrame);
       }
       if (viewportFrame->GetType() == nsGkAtoms::svgOuterSVGFrame) {
-        nsRect r = viewportFrame->GetOverflowRect();
+        nsRect r = viewportFrame->GetVisualOverflowRect();
         // GetOverflowRect is relative to our border box, but we need it
         // relative to our content box.
         r.MoveBy(viewportFrame->GetPosition() - viewportFrame->GetContentRect().TopLeft());
         return r;
       }
       NS_ASSERTION(viewportFrame->GetType() == nsGkAtoms::svgInnerSVGFrame,
                    "Wrong frame type");
       nsSVGInnerSVGFrame* innerSvg = do_QueryFrame(static_cast<nsIFrame*>(viewportFrame));
diff --git a/layout/tables/nsTableFrame.cpp b/layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp
+++ b/layout/tables/nsTableFrame.cpp
@@ -1087,17 +1087,17 @@ nsTableFrame::GetAdditionalChildListName
   if (aIndex == NS_TABLE_FRAME_OVERFLOW_LIST_INDEX) {
     return nsGkAtoms::overflowList;
   }
   return nsnull;
 }
 
 nsRect
 nsDisplayTableItem::GetBounds(nsDisplayListBuilder* aBuilder) {
-  return mFrame->GetOverflowRect() + ToReferenceFrame();
+  return mFrame->GetVisualOverflowRect() + ToReferenceFrame();
 }
 
 PRBool
 nsDisplayTableItem::IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
                                                    nsIFrame* aFrame)
 {
   if (!mPartHasFixedBackground)
     return PR_FALSE;
diff --git a/layout/tables/nsTableRowGroupFrame.cpp b/layout/tables/nsTableRowGroupFrame.cpp
--- a/layout/tables/nsTableRowGroupFrame.cpp
+++ b/layout/tables/nsTableRowGroupFrame.cpp
@@ -1902,17 +1902,17 @@ nsTableRowGroupFrame::GetFirstRowContain
   property->mCursorIndex = cursorIndex;
   *aOverflowAbove = property->mOverflowAbove;
   return cursorFrame;
 }
 
 PRBool
 nsTableRowGroupFrame::FrameCursorData::AppendFrame(nsIFrame* aFrame)
 {
-  nsRect overflowRect = aFrame->GetOverflowRect();
+  nsRect overflowRect = aFrame->GetVisualOverflowRect();
   if (overflowRect.IsEmpty())
     return PR_TRUE;
   nscoord overflowAbove = -overflowRect.y;
   nscoord overflowBelow = overflowRect.YMost() - aFrame->GetSize().height;
   mOverflowAbove = NS_MAX(mOverflowAbove, overflowAbove);
   mOverflowBelow = NS_MAX(mOverflowBelow, overflowBelow);
   return mFrames.AppendElement(aFrame) != nsnull;
 }
diff --git a/layout/xul/base/src/nsBox.cpp b/layout/xul/base/src/nsBox.cpp
--- a/layout/xul/base/src/nsBox.cpp
+++ b/layout/xul/base/src/nsBox.cpp
@@ -263,17 +263,17 @@ nsIFrame::GetClientRect(nsRect& aClientR
      aClientRect.height = 0;
 
  // NS_ASSERTION(aClientRect.width >=0 && aClientRect.height >= 0, "Content Size < 0");
 
   return NS_OK;
 }
 
 void
-nsBox::SetBounds(nsBoxLayoutState& aState, const nsRect& aRect, PRBool aRemoveOverflowArea)
+nsBox::SetBounds(nsBoxLayoutState& aState, const nsRect& aRect, PRBool aRemoveOverflowAreas)
 {
     NS_BOX_ASSERTION(this, aRect.width >=0 && aRect.height >= 0, "SetBounds Size < 0");
 
     nsRect rect(mRect);
 
     PRUint32 flags = 0;
     GetLayoutFlags(flags);
 
@@ -283,19 +283,19 @@ nsBox::SetBounds(nsBoxLayoutState& aStat
 
     if ((flags & NS_FRAME_NO_MOVE_FRAME) == NS_FRAME_NO_MOVE_FRAME)
       SetSize(nsSize(aRect.width, aRect.height));
     else
       SetRect(aRect);
 
     // Nuke the overflow area. The caller is responsible for restoring
     // it if necessary.
-    if (aRemoveOverflowArea && HasOverflowRect()) {
+    if (aRemoveOverflowAreas) {
       // remove the previously stored overflow area
-      ClearOverflowRect();
+      ClearOverflowRects();
     }
 
     if (!(flags & NS_FRAME_NO_MOVE_VIEW))
     {
       nsContainerFrame::PositionFrameView(this);
       if ((rect.x != aRect.x) || (rect.y != aRect.y))
         nsContainerFrame::PositionChildViews(this);
     }
@@ -656,17 +656,17 @@ nsIFrame::Redraw(nsBoxLayoutState& aStat
 {
   if (aState.PaintingDisabled())
     return NS_OK;
 
   nsRect damageRect(0,0,0,0);
   if (aDamageRect)
     damageRect = *aDamageRect;
   else
-    damageRect = GetOverflowRect();
+    damageRect = GetVisualOverflowRect();
 
   Invalidate(damageRect);
   // nsStackLayout, at least, expects us to repaint descendants even
   // if a damage rect is provided
   FrameLayerBuilder::InvalidateThebesLayersInSubtree(this);
 
   return NS_OK;
 }
diff --git a/layout/xul/base/src/nsBox.h b/layout/xul/base/src/nsBox.h
--- a/layout/xul/base/src/nsBox.h
+++ b/layout/xul/base/src/nsBox.h
@@ -62,17 +62,17 @@ public:
   virtual nscoord GetFlex(nsBoxLayoutState& aBoxLayoutState);
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState);
 
   virtual nsSize GetMinSizeForScrollArea(nsBoxLayoutState& aBoxLayoutState);
 
   virtual PRBool IsCollapsed(nsBoxLayoutState& aBoxLayoutState);
 
   virtual void SetBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
-                         PRBool aRemoveOverflowArea = PR_FALSE);
+                         PRBool aRemoveOverflowAreas = PR_FALSE);
 
   NS_IMETHOD GetBorder(nsMargin& aBorderAndPadding);
   NS_IMETHOD GetPadding(nsMargin& aBorderAndPadding);
   NS_IMETHOD GetMargin(nsMargin& aMargin);
 
   NS_IMETHOD SetLayoutManager(nsIBoxLayout* aLayout);
   NS_IMETHOD GetLayoutManager(nsIBoxLayout** aLayout);
 
diff --git a/layout/xul/base/src/nsPopupSetFrame.cpp b/layout/xul/base/src/nsPopupSetFrame.cpp
--- a/layout/xul/base/src/nsPopupSetFrame.cpp
+++ b/layout/xul/base/src/nsPopupSetFrame.cpp
@@ -206,19 +206,24 @@ nsPopupSetFrame::List(FILE* out, PRInt32
     fprintf(out, " next-continuation=%p", static_cast<void*>(GetNextContinuation()));
   }
   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
   if (0 != mState) {
     fprintf(out, " [state=%016llx]", mState);
   }
   fprintf(out, " [content=%p]", static_cast<void*>(mContent));
   nsPopupSetFrame* f = const_cast<nsPopupSetFrame*>(this);
-  if (f->HasOverflowRect()) {
-    nsRect overflowArea = f->GetOverflowRect();
-    fprintf(out, " [overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
+  if (f->HasOverflowAreas()) {
+    nsRect overflowArea = f->GetVisualOverflowRect();
+    fprintf(out, " [vis-overflow=%d,%d,%d,%d]",
+            overflowArea.x, overflowArea.y,
+            overflowArea.width, overflowArea.height);
+    overflowArea = f->GetScrollableOverflowRect();
+    fprintf(out, " [scr-overflow=%d,%d,%d,%d]",
+            overflowArea.x, overflowArea.y,
             overflowArea.width, overflowArea.height);
   }
   fprintf(out, " [sc=%p]", static_cast<void*>(mStyleContext));
   nsIAtom* pseudoTag = mStyleContext->GetPseudo();
   if (pseudoTag) {
     nsAutoString atomString;
     pseudoTag->ToString(atomString);
     fprintf(out, " pst=%s",
diff --git a/layout/xul/base/src/nsTextBoxFrame.cpp b/layout/xul/base/src/nsTextBoxFrame.cpp
--- a/layout/xul/base/src/nsTextBoxFrame.cpp
+++ b/layout/xul/base/src/nsTextBoxFrame.cpp
@@ -353,17 +353,17 @@ nsDisplayXULTextBox::Paint(nsDisplayList
                            nsIRenderingContext* aCtx)
 {
   static_cast<nsTextBoxFrame*>(mFrame)->
     PaintTitle(*aCtx, mVisibleRect, ToReferenceFrame());
 }
 
 nsRect
 nsDisplayXULTextBox::GetBounds(nsDisplayListBuilder* aBuilder) {
-  return mFrame->GetOverflowRect() + ToReferenceFrame();
+  return mFrame->GetVisualOverflowRect() + ToReferenceFrame();
 }
 
 NS_IMETHODIMP
 nsTextBoxFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                  const nsRect&           aDirtyRect,
                                  const nsDisplayListSet& aLists)
 {
     if (!IsVisibleForPainting(aBuilder))
