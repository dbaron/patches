From: L. David Baron <dbaron@dbaron.org>

Bug 1216431 patch 1 - Don't trigger computation of new structs via testing of conditions for conditionally-stored structs on the rule node.

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -9452,17 +9452,17 @@ nsRuleNode::GetStyleData(nsStyleStructID
   MOZ_ASSERT(!aContext->GetCachedStyleData(aSID),
              "style context should not have cached data for struct");
 
   const void *data;
 
   // Never use cached data for animated style inside a pseudo-element;
   // see comment on cacheability in AnimValuesStyleRule::MapRuleInfoInto.
   if (!(HasAnimationData() && ParentHasPseudoElementData(aContext))) {
-    data = mStyleData.GetStyleData(aSID, aContext);
+    data = mStyleData.GetStyleData(aSID, aContext, aComputeData);
     if (MOZ_LIKELY(data != nullptr)) {
       // With this same bit set, we do two different things:
       // For reset structs, mark the struct as having been retrieved for
       // this context.
       // For inherited structs, mark the struct (which will be set on
       // the context by our caller) as not being owned by the context.
       aContext->AddStyleBit(nsCachedStyleData::GetBitForSID(aSID));
       return data; // We have a fully specified struct. Just return it.
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -155,20 +155,30 @@ struct nsConditionalResetStyleData
   void* GetStyleData(nsStyleStructID aSID) const {
     if (mConditionalBits & GetBitForSID(aSID)) {
       return nullptr;
     }
     return mEntries[aSID];
   }
 
   void* GetStyleData(nsStyleStructID aSID,
-                     nsStyleContext* aStyleContext) const {
+                     nsStyleContext* aStyleContext,
+                     bool aComputeData) const {
     if (!(mConditionalBits & GetBitForSID(aSID))) {
       return mEntries[aSID];
     }
+    if (!aComputeData) {
+      // If aComputeData is false, then any previously-computed data
+      // would have been cached on the style context.  Therefore it's
+      // unnecessary to check the conditional data.  It's also
+      // incorrect, because calling e->mConditions.Matches() below could
+      // cause additional structs to be computed, which is incorrect
+      // during CalcStyleDifference.
+      return nullptr;
+    }
     Entry* e = static_cast<Entry*>(mEntries[aSID]);
     MOZ_ASSERT(e, "if mConditionalBits bit is set, we must have at least one "
                   "conditional style struct");
     do {
       if (e->mConditions.Matches(aStyleContext)) {
         return e->mStyleStruct;
       }
       e = e->mNext;
@@ -269,20 +279,21 @@ struct nsCachedStyleData
       if (mInheritedData) {
         return mInheritedData->mStyleStructs[aSID];
       }
     }
     return nullptr;
   }
 
   void* NS_FASTCALL GetStyleData(const nsStyleStructID aSID,
-                                 nsStyleContext* aStyleContext) {
+                                 nsStyleContext* aStyleContext,
+                                 bool aComputeData) {
     if (IsReset(aSID)) {
       if (mResetData) {
-        return mResetData->GetStyleData(aSID, aStyleContext);
+        return mResetData->GetStyleData(aSID, aStyleContext, aComputeData);
       }
     } else {
       if (mInheritedData) {
         return mInheritedData->mStyleStructs[aSID];
       }
     }
     return nullptr;
   }
@@ -304,19 +315,21 @@ struct nsCachedStyleData
 
   // Typesafe and faster versions of the above
   #define STYLE_STRUCT_INHERITED(name_, checkdata_cb_)                         \
     nsStyle##name_ * NS_FASTCALL GetStyle##name_ () {                          \
       return mInheritedData ? static_cast<nsStyle##name_*>(                    \
         mInheritedData->mStyleStructs[eStyleStruct_##name_]) : nullptr;        \
     }
   #define STYLE_STRUCT_RESET(name_, checkdata_cb_)                             \
-    nsStyle##name_ * NS_FASTCALL GetStyle##name_ (nsStyleContext* aContext) {  \
+    nsStyle##name_ * NS_FASTCALL GetStyle##name_ (nsStyleContext* aContext,    \
+                                                  bool aComputeData) {         \
       return mResetData ? static_cast<nsStyle##name_*>(                        \
-        mResetData->GetStyleData(eStyleStruct_##name_, aContext)) : nullptr;   \
+        mResetData->GetStyleData(eStyleStruct_##name_, aContext, aComputeData))\
+                        : nullptr;                                             \
     }
   #include "nsStyleStructList.h"
   #undef STYLE_STRUCT_RESET
   #undef STYLE_STRUCT_INHERITED
 
   void Destroy(uint64_t aBits, nsPresContext* aContext) {
     if (mResetData)
       mResetData->Destroy(aBits, aContext);
@@ -931,17 +944,17 @@ public:
     MOZ_ASSERT(!ContextHasCachedData(aContext, eStyleStruct_##name_),         \
                "style context should not have cached data for struct");       \
                                                                               \
     const nsStyle##name_ *data;                                               \
                                                                               \
     /* Never use cached data for animated style inside a pseudo-element; */   \
     /* see comment on cacheability in AnimValuesStyleRule::MapRuleInfoInto */ \
     if (!(HasAnimationData() && ParentHasPseudoElementData(aContext))) {      \
-      data = mStyleData.GetStyle##name_(aContext);                            \
+      data = mStyleData.GetStyle##name_(aContext, aComputeData);              \
       if (MOZ_LIKELY(data != nullptr)) {                                      \
         /* Mark the struct as having been retrieved for this context. */      \
         /* Normally this would be aContext->AddStyleBit(), but aContext is */ \
         /* an incomplete type here, so we work around that with a param. */   \
         aContextStyleBits |= NS_STYLE_INHERIT_BIT(name_);                     \
         return data;                                                          \
       }                                                                       \
     }                                                                         \
