Don't eat up too much when we hit an error in the last media query in a list.  (Bug 461266)

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -276,16 +276,17 @@ protected:
     NS_PRECONDITION(!mParsingCompoundProperty, "Bad initial state");
   }
 
   PRBool ExpectSymbol(PRUnichar aSymbol, PRBool aSkipWS);
   PRBool ExpectEndProperty();
   PRBool CheckEndProperty();
   nsSubstring* NextIdent();
   void SkipUntil(PRUnichar aStopSymbol);
+  void SkipUntilOneOf(const PRUnichar* aStopSymbolChars);
   void SkipRuleSet();
   PRBool SkipAtRule();
   PRBool SkipDeclaration(PRBool aCheckForBraces);
   PRBool GetNonCloseParenToken(PRBool aSkipWS);
 
   PRBool PushGroup(nsICSSGroupRule* aRule);
   void PopGroup(void);
 
@@ -1602,20 +1603,25 @@ CSSParserImpl::GatherMedia(nsMediaList* 
 CSSParserImpl::GatherMedia(nsMediaList* aMedia,
                            PRUnichar aStopSymbol)
 {
   for (;;) {
     nsAutoPtr<nsMediaQuery> query;
     PRBool parsedSomething, hitStop;
     if (!ParseMediaQuery(aStopSymbol, getter_Transfers(query),
                          &parsedSomething, &hitStop)) {
+      NS_ASSERTION(!hitStop, "should return true when hit stop");
       if (NS_FAILED(mScanner.GetLowLevelError())) {
         return PR_FALSE;
       }
-      SkipUntil(',');
+      const PRUnichar stopChars[] =
+        { aStopSymbol, PRUnichar(','), PRUnichar(0) };
+      SkipUntilOneOf(stopChars);
+      hitStop =
+        mToken.mType == eCSSToken_Symbol && mToken.mSymbol == aStopSymbol;
     }
     if (parsedSomething) {
       aMedia->SetNonEmpty();
     }
     if (query) {
       nsresult rv = aMedia->AppendQuery(query);
       if (NS_FAILED(rv)) {
         mScanner.SetLowLevelError(rv);
@@ -2143,16 +2149,40 @@ CSSParserImpl::SkipUntil(PRUnichar aStop
   nsCSSToken* tk = &mToken;
   for (;;) {
     if (!GetToken(PR_TRUE)) {
       break;
     }
     if (eCSSToken_Symbol == tk->mType) {
       PRUnichar symbol = tk->mSymbol;
       if (symbol == aStopSymbol) {
+        break;
+      } else if ('{' == symbol) {
+        SkipUntil('}');
+      } else if ('[' == symbol) {
+        SkipUntil(']');
+      } else if ('(' == symbol) {
+        SkipUntil(')');
+      }
+    }
+  }
+}
+
+void
+CSSParserImpl::SkipUntilOneOf(const PRUnichar* aStopSymbolChars)
+{
+  nsCSSToken* tk = &mToken;
+  nsDependentString stopSymbolChars(aStopSymbolChars);
+  for (;;) {
+    if (!GetToken(PR_TRUE)) {
+      break;
+    }
+    if (eCSSToken_Symbol == tk->mType) {
+      PRUnichar symbol = tk->mSymbol;
+      if (stopSymbolChars.FindChar(symbol) != -1) {
         break;
       } else if ('{' == symbol) {
         SkipUntil('}');
       } else if ('[' == symbol) {
         SkipUntil(']');
       } else if ('(' == symbol) {
         SkipUntil(')');
       }
