Don't eat up too much when we hit an error in the last media query in a list.  (Bug 461266)  r+sr=bzbarsky

diff --git a/layout/reftests/bugs/461266-1-ref.html b/layout/reftests/bugs/461266-1-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/461266-1-ref.html
@@ -0,0 +1,17 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+    <title>Testcase for bug 461266</title>
+    <style type="text/css">
+        div {
+            height: 100px; width: 100px;
+            background-color: blue; 
+            float: right;
+        }
+    </style>
+</head>
+
+<body>
+  <div></div>
+</body>
+</html>
diff --git a/layout/reftests/bugs/461266-1.html b/layout/reftests/bugs/461266-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/461266-1.html
@@ -0,0 +1,20 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+    <title>Testcase for bug 461266</title>
+    <style type="text/css">
+      div { height: 100px; width: 100px; }
+
+      @media all and (min-width:0) {}
+      div { background-color: blue; }
+
+      /* This line stops parsing of following selectors  */
+      @media all and(min-width:0) {}
+      div { float: right; }
+    </style>
+</head>
+
+<body>
+  <div></div>
+</body>
+</html>
diff --git a/layout/reftests/bugs/reftest.list b/layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list
+++ b/layout/reftests/bugs/reftest.list
@@ -926,9 +926,10 @@ fails == 441259-2.html 441259-2-ref.html
 == 451168-1.html 451168-1-ref.html
 == 452964-1.html 452964-1-ref.html
 == 454361.html about:blank
 == 455105-1.html 455105-ref.html
 == 455105-2.html 455105-ref.html
 == 455280-1.xhtml 455280-1-ref.xhtml
 fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == 456147.xul 456147-ref.html # bug 456147, but not caused by it
 == 456484-1.html 456484-1-ref.html
+== 461266-1.html 461266-1-ref.html
 fails == 461512-1.html 461512-1-ref.html # Bug 461512
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -268,16 +268,17 @@ protected:
     NS_PRECONDITION(!mParsingCompoundProperty, "Bad initial state");
   }
 
   PRBool ExpectSymbol(PRUnichar aSymbol, PRBool aSkipWS);
   PRBool ExpectEndProperty();
   PRBool CheckEndProperty();
   nsSubstring* NextIdent();
   void SkipUntil(PRUnichar aStopSymbol);
+  void SkipUntilOneOf(const PRUnichar* aStopSymbolChars);
   void SkipRuleSet();
   PRBool SkipAtRule();
   PRBool SkipDeclaration(PRBool aCheckForBraces);
   PRBool GetNonCloseParenToken(PRBool aSkipWS);
 
   PRBool PushGroup(nsICSSGroupRule* aRule);
   void PopGroup(void);
 
@@ -1586,20 +1587,28 @@ CSSParserImpl::GatherMedia(nsMediaList* 
 CSSParserImpl::GatherMedia(nsMediaList* aMedia,
                            PRUnichar aStopSymbol)
 {
   for (;;) {
     nsAutoPtr<nsMediaQuery> query;
     PRBool parsedSomething, hitStop;
     if (!ParseMediaQuery(aStopSymbol, getter_Transfers(query),
                          &parsedSomething, &hitStop)) {
+      NS_ASSERTION(!hitStop, "should return true when hit stop");
       if (NS_FAILED(mScanner.GetLowLevelError())) {
         return PR_FALSE;
       }
-      SkipUntil(',');
+      const PRUnichar stopChars[] =
+        { PRUnichar(','), aStopSymbol /* may be null */, PRUnichar(0) };
+      SkipUntilOneOf(stopChars);
+      // Rely on SkipUntilOneOf leaving mToken around as the last token read.
+      if (mToken.mType == eCSSToken_Symbol && mToken.mSymbol == aStopSymbol) {
+        UngetToken();
+        hitStop = PR_TRUE;
+      }
     }
     if (parsedSomething) {
       aMedia->SetNonEmpty();
     }
     if (query) {
       nsresult rv = aMedia->AppendQuery(query);
       if (NS_FAILED(rv)) {
         mScanner.SetLowLevelError(rv);
@@ -2140,16 +2149,40 @@ CSSParserImpl::SkipUntil(PRUnichar aStop
   nsCSSToken* tk = &mToken;
   for (;;) {
     if (!GetToken(PR_TRUE)) {
       break;
     }
     if (eCSSToken_Symbol == tk->mType) {
       PRUnichar symbol = tk->mSymbol;
       if (symbol == aStopSymbol) {
+        break;
+      } else if ('{' == symbol) {
+        SkipUntil('}');
+      } else if ('[' == symbol) {
+        SkipUntil(']');
+      } else if ('(' == symbol) {
+        SkipUntil(')');
+      }
+    }
+  }
+}
+
+void
+CSSParserImpl::SkipUntilOneOf(const PRUnichar* aStopSymbolChars)
+{
+  nsCSSToken* tk = &mToken;
+  nsDependentString stopSymbolChars(aStopSymbolChars);
+  for (;;) {
+    if (!GetToken(PR_TRUE)) {
+      break;
+    }
+    if (eCSSToken_Symbol == tk->mType) {
+      PRUnichar symbol = tk->mSymbol;
+      if (stopSymbolChars.FindChar(symbol) != -1) {
         break;
       } else if ('{' == symbol) {
         SkipUntil('}');
       } else if ('[' == symbol) {
         SkipUntil(']');
       } else if ('(' == symbol) {
         SkipUntil(')');
       }
diff --git a/layout/style/test/test_media_queries.html b/layout/style/test/test_media_queries.html
--- a/layout/style/test/test_media_queries.html
+++ b/layout/style/test/test_media_queries.html
@@ -52,23 +52,21 @@ function run() {
   parse_test_style_element.type = "text/css";
   parse_test_style_element.disabled = true; // for performance, hopefully
   var parse_test_style_text = document.createTextNode("");
   parse_test_style_element.appendChild(parse_test_style_text);
   document.getElementsByTagName("head")[0]
     .appendChild(parse_test_style_element);
 
   function query_is_parseable(q) {
-    parse_test_style_text.data = "@media " + q + " {}";
+    parse_test_style_text.data = "@media screen, " + q + " {}";
     var sheet = parse_test_style_element.sheet; // XXX yikes, not live!
-    if (sheet.cssRules.length == 0)
-      return false;
     if (sheet.cssRules.length == 1 &&
         sheet.cssRules[0].type == CSSRule.MEDIA_RULE)
-      return true;
+      return sheet.cssRules[0].media.mediaText != "screen";
     ok(false, "unexpected result testing whether query " + q +
               " is parseable");
     return true; // doesn't matter, we already failed
   }
 
   function query_should_be_parseable(q) {
     ok(query_is_parseable(q), "query " + q + " should be parseable");
   }
