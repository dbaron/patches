From: Timothy Nikkel <tnikkel@gmail.com>

Bug 503791. ComboboxControlFrame should not assume that the origin of the screen is (0,0) because that is not true with more than one display.  r=dbaron

diff --git a/layout/forms/nsComboboxControlFrame.cpp b/layout/forms/nsComboboxControlFrame.cpp
--- a/layout/forms/nsComboboxControlFrame.cpp
+++ b/layout/forms/nsComboboxControlFrame.cpp
@@ -499,29 +499,24 @@ nsComboboxControlFrame::AbsolutelyPositi
    // for it's AbsoluteBounds. The problem with this approach, is that the dropdown lists y location can
    // change based on whether the dropdown is placed below or above the display frame.
    // The approach, taken here is to get use the absolute position of the display frame and use it's location
    // to determine if the dropdown will go offscreen.
 
    // Use the height calculated for the area frame so it includes both
    // the display and button heights.
   nscoord dropdownYOffset = GetRect().height;
-  nsPresContext* presContext = PresContext();
-// XXX: Enable this code to debug popping up above the display frame, rather than below it
   nsSize dropdownSize = mDropdownFrame->GetSize();
 
-  nscoord screenHeightInPixels = 0;
-  if (NS_SUCCEEDED(nsFormControlFrame::GetScreenHeight(presContext, screenHeightInPixels))) {
-    // Get the height of the dropdown list in pixels.
-    nscoord absoluteDropDownHeight = presContext->AppUnitsToDevPixels(dropdownSize.height);
-    // Check to see if the drop-down list will go offscreen
-    if (GetScreenRect().YMost() + absoluteDropDownHeight > screenHeightInPixels) {
-      // move the dropdown list up
-      dropdownYOffset = - (dropdownSize.height);
-    }
+  nsRect screen = nsFormControlFrame::GetUsableScreenRect(PresContext());
+
+  // Check to see if the drop-down list will go offscreen
+  if (GetScreenRectInAppUnits().YMost() + dropdownSize.height > screen.YMost()) {
+    // move the dropdown list up
+    dropdownYOffset = - (dropdownSize.height);
   }
 
   nsPoint dropdownPosition;
   const nsStyleVisibility* vis = GetStyleVisibility();
   if (vis->mDirection == NS_STYLE_DIRECTION_RTL) {
     // Align the right edge of the drop-down with the right edge of the control.
     dropdownPosition.x = GetRect().width - dropdownSize.width;
   } else {
diff --git a/layout/forms/nsFormControlFrame.cpp b/layout/forms/nsFormControlFrame.cpp
--- a/layout/forms/nsFormControlFrame.cpp
+++ b/layout/forms/nsFormControlFrame.cpp
@@ -172,27 +172,26 @@ nsFormControlFrame::SetFormProperty(nsIA
 
 nsresult
 nsFormControlFrame::GetFormProperty(nsIAtom* aName, nsAString& aValue) const
 {
   aValue.Truncate();
   return NS_OK;
 }
 
-nsresult 
-nsFormControlFrame::GetScreenHeight(nsPresContext* aPresContext,
-                                    nscoord& aHeight)
+// static
+nsRect
+nsFormControlFrame::GetUsableScreenRect(nsPresContext* aPresContext)
 {
   nsRect screen;
 
   nsIDeviceContext *context = aPresContext->DeviceContext();
   PRBool dropdownCanOverlapOSBar = PR_FALSE;
   nsILookAndFeel *lookAndFeel = aPresContext->LookAndFeel();
   lookAndFeel->GetMetric(nsILookAndFeel::eMetric_MenusCanOverlapOSBar,
                          dropdownCanOverlapOSBar);
   if ( dropdownCanOverlapOSBar )
-    context->GetRect ( screen );
+    context->GetRect(screen);
   else
     context->GetClientRect(screen);
 
-  aHeight = aPresContext->AppUnitsToDevPixels(screen.height);
-  return NS_OK;
+  return screen;
 }
diff --git a/layout/forms/nsFormControlFrame.h b/layout/forms/nsFormControlFrame.h
--- a/layout/forms/nsFormControlFrame.h
+++ b/layout/forms/nsFormControlFrame.h
@@ -95,20 +95,20 @@ public:
   virtual nsresult SetFormProperty(nsIAtom* aName, const nsAString& aValue);
 
   virtual nsresult GetFormProperty(nsIAtom* aName, nsAString& aValue) const; 
   
   // AccessKey Helper function
   static nsresult RegUnRegAccessKey(nsIFrame * aFrame, PRBool aDoReg);
 
   /**
-   * Helper routine to that returns the height of the screen
-   *
+   * Returns the usable screen rect in app units, eg the rect where we can
+   * draw dropdowns.
    */
-  static nsresult GetScreenHeight(nsPresContext* aPresContext, nscoord& aHeight);
+  static nsRect GetUsableScreenRect(nsPresContext* aPresContext);
 
 protected:
 
   virtual ~nsFormControlFrame();
 
   virtual nscoord GetIntrinsicWidth();
   virtual nscoord GetIntrinsicHeight();
 
diff --git a/layout/forms/nsListControlFrame.cpp b/layout/forms/nsListControlFrame.cpp
--- a/layout/forms/nsListControlFrame.cpp
+++ b/layout/forms/nsListControlFrame.cpp
@@ -725,34 +725,32 @@ nsListControlFrame::ReflowAsDropdown(nsP
     // but on 640x480 it is typically too big.
     // This takes the height of the screen divides it by two and then subtracts off 
     // an estimated height of the combobox. I estimate it by taking the max element size
     // of the drop down and multiplying it by 2 (this is arbitrary) then subtract off
     // the border and padding of the drop down (again rather arbitrary)
     // This all breaks down if the font of the combobox is a lot larger then the option items
     // or CSS style has set the height of the combobox to be rather large.
     // We can fix these cases later if they actually happen.
-    nscoord screenHeightInPixels = 0;
-    if (NS_SUCCEEDED(nsFormControlFrame::GetScreenHeight(aPresContext, screenHeightInPixels))) {
-      nscoord screenHeight = aPresContext->DevPixelsToAppUnits(screenHeightInPixels);
-      
-      nscoord availDropHgt = (screenHeight / 2) - (heightOfARow*2); // approx half screen minus combo size
-      availDropHgt -= aReflowState.mComputedBorderPadding.top + aReflowState.mComputedBorderPadding.bottom;
-      
-      nscoord hgt = visibleHeight + aReflowState.mComputedBorderPadding.top + aReflowState.mComputedBorderPadding.bottom;
-      if (heightOfARow > 0) {
-        if (hgt > availDropHgt) {
-          visibleHeight = (availDropHgt / heightOfARow) * heightOfARow;
-        }
-        mNumDisplayRows = visibleHeight / heightOfARow;
-      } else {
-        // Hmmm, not sure what to do here. Punt, and make both of them one
-        visibleHeight   = 1;
-        mNumDisplayRows = 1;
+    nsRect screen = nsFormControlFrame::GetUsableScreenRect(aPresContext);
+    nscoord screenHeight = screen.height;
+
+    nscoord availDropHgt = (screenHeight / 2) - (heightOfARow*2); // approx half screen minus combo size
+    availDropHgt -= aReflowState.mComputedBorderPadding.top + aReflowState.mComputedBorderPadding.bottom;
+
+    nscoord hgt = visibleHeight + aReflowState.mComputedBorderPadding.top + aReflowState.mComputedBorderPadding.bottom;
+    if (heightOfARow > 0) {
+      if (hgt > availDropHgt) {
+        visibleHeight = (availDropHgt / heightOfARow) * heightOfARow;
       }
+      mNumDisplayRows = visibleHeight / heightOfARow;
+    } else {
+      // Hmmm, not sure what to do here. Punt, and make both of them one
+      visibleHeight   = 1;
+      mNumDisplayRows = 1;
     }
 
     state.SetComputedHeight(mNumDisplayRows * heightOfARow);
     // Note: no need to apply min/max constraints, since we have no such
     // rules applied to the combobox dropdown.
     // XXXbz this is ending up too big!!  Figure out why.
   } else if (visibleHeight == 0) {
     // Looks like we have no options.  Just size us to a single row height.
