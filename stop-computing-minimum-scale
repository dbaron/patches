From: L. David Baron <dbaron@dbaron.org>

Bug 1153539 patch 3 - Stop computing minimum scale for off-main-thread animations of transforms, since it's no longer used.

diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -490,74 +490,65 @@ GetSuitableScale(float aMaxScale,
                               float(aVisibleDimension);
   // We want to rasterize based on the largest scale used during the
   // transform animation, unless that would make us rasterize something
   // larger than the screen.
   return std::min(aMaxScale, displayVisibleRatio);
 }
 
 static void
-GetMinAndMaxScaleForAnimationProperty(nsIContent* aContent,
-                                      AnimationCollection* aAnimations,
-                                      gfxSize& aMaxScale,
-                                      gfxSize& aMinScale)
+GetMaxScaleForAnimationProperty(nsIContent* aContent,
+                                AnimationCollection* aAnimations,
+                                gfxSize& aMaxScale)
 {
   for (size_t animIdx = aAnimations->mAnimations.Length(); animIdx-- != 0; ) {
     dom::Animation* anim = aAnimations->mAnimations[animIdx];
     if (!anim->GetEffect() || anim->GetEffect()->IsFinishedTransition()) {
       continue;
     }
     dom::KeyframeEffectReadOnly* effect = anim->GetEffect();
     for (size_t propIdx = effect->Properties().Length(); propIdx-- != 0; ) {
       AnimationProperty& prop = effect->Properties()[propIdx];
       if (prop.mProperty == eCSSProperty_transform) {
         for (uint32_t segIdx = prop.mSegments.Length(); segIdx-- != 0; ) {
           AnimationPropertySegment& segment = prop.mSegments[segIdx];
           gfxSize from = GetScaleForValue(segment.mFromValue,
                                           aContent->GetPrimaryFrame());
           aMaxScale.width = std::max<float>(aMaxScale.width, from.width);
           aMaxScale.height = std::max<float>(aMaxScale.height, from.height);
-          aMinScale.width = std::min<float>(aMinScale.width, from.width);
-          aMinScale.height = std::min<float>(aMinScale.height, from.height);
           gfxSize to = GetScaleForValue(segment.mToValue,
                                         aContent->GetPrimaryFrame());
           aMaxScale.width = std::max<float>(aMaxScale.width, to.width);
           aMaxScale.height = std::max<float>(aMaxScale.height, to.height);
-          aMinScale.width = std::min<float>(aMinScale.width, to.width);
-          aMinScale.height = std::min<float>(aMinScale.height, to.height);
         }
       }
     }
   }
 }
 
 gfxSize
 nsLayoutUtils::ComputeSuitableScaleForAnimation(nsIContent* aContent,
                                                 const nsSize& aVisibleSize,
                                                 const nsSize& aDisplaySize)
 {
   gfxSize maxScale(std::numeric_limits<gfxFloat>::min(),
                    std::numeric_limits<gfxFloat>::min());
-  gfxSize minScale(std::numeric_limits<gfxFloat>::max(),
-                   std::numeric_limits<gfxFloat>::max());
 
   AnimationCollection* animations =
     nsAnimationManager::GetAnimationsForCompositor(aContent,
                                                    eCSSProperty_transform);
   if (animations) {
-    GetMinAndMaxScaleForAnimationProperty(aContent, animations,
-                                          maxScale, minScale);
+    GetMaxScaleForAnimationProperty(aContent, animations, maxScale);
   }
 
   animations =
     nsTransitionManager::GetAnimationsForCompositor(aContent,
                                                     eCSSProperty_transform);
   if (animations) {
-    GetMinAndMaxScaleForAnimationProperty(aContent, animations,
-                                          maxScale, minScale);
+    GetMaxScaleForAnimationProperty(aContent, animations, maxScale);
   }
 
   if (maxScale.width == std::numeric_limits<gfxFloat>::min()) {
     // We didn't encounter a transform
     return gfxSize(1.0, 1.0);
   }
 
   return gfxSize(GetSuitableScale(maxScale.width,
