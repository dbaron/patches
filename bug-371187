Remove the remainder of the pixel rounding in the table code.  b=371187

diff -r 0e7c4e08fda1 layout/reftests/table-width/reftest.list
--- a/layout/reftests/table-width/reftest.list	Wed Feb 21 20:23:38 2007 -0800
+++ b/layout/reftests/table-width/reftest.list	Wed Feb 21 20:24:16 2007 -0800
@@ -38,9 +38,9 @@
 == balancing-1.html balancing-1-ref.html
 == balancing-2.html balancing-2-ref.html
 == cellpadding.html cellpadding-ref.html
-random == cellspacing.html cellspacing-ref.html # bug 371187 (via bug 371188)
-random == percent-basis.html percent-basis-ref.html # bug 371187 (plus bug 371188 too)
-fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") random == default-box-sizing-separate-standards.html default-box-sizing-separate-standards-ref.html # bug 361523, bug 371187
-fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") random == default-box-sizing-separate-quirks.html default-box-sizing-separate-quirks-ref.html # bug 361523, bug 371187
+== cellspacing.html cellspacing-ref.html
+== percent-basis.html percent-basis-ref.html
+fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == default-box-sizing-separate-standards.html default-box-sizing-separate-standards-ref.html # bug 361523
+fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") == default-box-sizing-separate-quirks.html default-box-sizing-separate-quirks-ref.html # bug 361523
 fails == default-box-sizing-collapse-standards.html default-box-sizing-collapse-standards-ref.html # bug 155955, bug 371180, bug 371182
 fails == default-box-sizing-collapse-quirks.html default-box-sizing-collapse-quirks-ref.html # bug 371180, bug 371182
diff -r 0e7c4e08fda1 layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp	Wed Feb 21 20:23:38 2007 -0800
+++ b/layout/tables/nsTableCellFrame.cpp	Wed Feb 21 20:23:50 2007 -0800
@@ -569,7 +569,6 @@ void nsTableCellFrame::VerticallyAlignCh
     case NS_STYLE_VERTICAL_ALIGN_MIDDLE:
       // Align the middle of the child frame with the middle of the content area, 
       kidYTop = (height - childHeight - bottomInset + topInset) / 2;
-      kidYTop = nsTableFrame::RoundToPixel(kidYTop, eAlwaysRoundDown);
   }
   // if the content is larger than the cell height align from top
   kidYTop = PR_MAX(0, kidYTop);
@@ -759,9 +758,6 @@ NS_METHOD nsTableCellFrame::Reflow(nsPre
 
   // work around pixel rounding errors, round down to ensure we don't exceed the avail height in
   nscoord availHeight = aReflowState.availableHeight;
-  if (NS_UNCONSTRAINEDSIZE != availHeight) {
-    availHeight = nsTableFrame::RoundToPixel(availHeight, eAlwaysRoundDown);
-  }
 
   // see if a special height reflow needs to occur due to having a pct height
   nsTableFrame::CheckRequestSpecialHeightReflow(aReflowState);
@@ -852,9 +848,6 @@ NS_METHOD nsTableCellFrame::Reflow(nsPre
 
   if (NS_UNCONSTRAINEDSIZE != cellHeight) {
     cellHeight += topInset + bottomInset;
-    // work around block rounding errors, round down to ensure we don't exceed the avail height in
-    nsPixelRound roundMethod = (NS_UNCONSTRAINEDSIZE == availHeight) ? eAlwaysRoundUp : eAlwaysRoundDown;
-    cellHeight = nsTableFrame::RoundToPixel(cellHeight, roundMethod); 
   }
 
   // next determine the cell's width
@@ -864,7 +857,6 @@ NS_METHOD nsTableCellFrame::Reflow(nsPre
   if (NS_UNCONSTRAINEDSIZE != cellWidth) {
     cellWidth += leftInset + rightInset;    
   }
-  cellWidth = nsTableFrame::RoundToPixel(cellWidth); // work around block rounding errors
 
   // set the cell's desired size and max element size
   aDesiredSize.width   = cellWidth;
diff -r 0e7c4e08fda1 layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp	Wed Feb 21 20:23:38 2007 -0800
+++ b/layout/tables/nsTableFrame.cpp	Wed Feb 21 20:23:50 2007 -0800
@@ -271,29 +271,6 @@ nsTableFrame::Destroy()
 {
   mColGroups.DestroyFrames();
   nsHTMLContainerFrame::Destroy();
-}
-
-nscoord 
-nsTableFrame::RoundToPixel(nscoord       aValue,
-                           nsPixelRound  aRound)
-{
-  nscoord fullPixel = nsPresContext::CSSPixelsToAppUnits(1);
-
-  PRInt32 excess = aValue % fullPixel;
-  if (0 == excess) 
-    return aValue;
-
-  nscoord halfPixel = nsPresContext::CSSPixelsToAppUnits(0.5f);
-  switch(aRound) {
-  case eRoundUpIfHalfOrMore:
-    if (excess >= halfPixel) { // eRoundUpIfHalfOrMore
-      return aValue + (fullPixel - excess);
-    }
-  case eAlwaysRoundDown:
-    return aValue - excess;
-  default: // eAlwaysRoundUp
-    return aValue + (fullPixel - excess);
-  }
 }
 
 // Make sure any views are positioned properly
@@ -3116,7 +3093,7 @@ nsTableFrame::DistributeHeightToRows(con
       while (rowFrame) {
         nsRect rowRect = rowFrame->GetRect();
         if ((amountUsed < aAmount) && rowFrame->HasPctHeight()) {
-          nscoord pctHeight = nsTableFrame::RoundToPixel(rowFrame->GetHeight(pctBasis));
+          nscoord pctHeight = rowFrame->GetHeight(pctBasis);
           nscoord amountForRow = PR_MIN(aAmount - amountUsed, pctHeight - rowRect.height);
           if (amountForRow > 0) {
             rowRect.height += amountForRow;
@@ -3220,7 +3197,7 @@ nsTableFrame::DistributeHeightToRows(con
           // give rows their percentage, except for the last row which gets the remainder
           nscoord amountForRow = (rowFrame == lastElligibleRow) 
                                  ? aAmount - amountUsed : NSToCoordRound(((float)(pctBasis)) * percent);
-          amountForRow = PR_MIN(nsTableFrame::RoundToPixel(amountForRow), aAmount - amountUsed);
+          amountForRow = PR_MIN(amountForRow, aAmount - amountUsed);
           // update the row height
           nsRect newRowRect(rowRect.x, yOriginRow, rowRect.width, rowRect.height + amountForRow);
           rowFrame->SetRect(newRowRect);
diff -r 0e7c4e08fda1 layout/tables/nsTableFrame.h
--- a/layout/tables/nsTableFrame.h	Wed Feb 21 20:23:38 2007 -0800
+++ b/layout/tables/nsTableFrame.h	Wed Feb 21 20:23:50 2007 -0800
@@ -59,8 +59,6 @@ struct nsTableReflowState;
 struct nsTableReflowState;
 struct nsStylePosition;
 
-enum nsPixelRound {eAlwaysRoundUp=0, eAlwaysRoundDown, eRoundUpIfHalfOrMore};
-
 /**
  * Child list name indices
  * @see #GetAdditionalChildListName()
@@ -116,9 +114,6 @@ public:
                            PRBool               aCreateIfNecessary = PR_FALSE);
 
   static float GetTwipsToPixels(nsPresContext* aPresContext);
-
-  static nscoord RoundToPixel(nscoord      aValue,
-                              nsPixelRound aRound= eAlwaysRoundUp);
 
   // See if a special height reflow will occur due to having a pct height when
   // the pct height basis may not yet be valid.
diff -r 0e7c4e08fda1 layout/tables/nsTableOuterFrame.cpp
--- a/layout/tables/nsTableOuterFrame.cpp	Wed Feb 21 20:23:38 2007 -0800
+++ b/layout/tables/nsTableOuterFrame.cpp	Wed Feb 21 20:23:50 2007 -0800
@@ -453,7 +453,7 @@ nscoord CalcAutoMargin(nscoord aAutoMarg
 {
   nscoord margin;
   if (NS_AUTOMARGIN == aOppositeMargin) 
-    margin = nsTableFrame::RoundToPixel((aContainBlockSize - aFrameSize) / 2);
+    margin = (aContainBlockSize - aFrameSize) / 2;
   else {
     margin = aContainBlockSize - aFrameSize - aOppositeMargin;
   }
@@ -805,8 +805,6 @@ nsTableOuterFrame::BalanceLeftRightCapti
   else {
     aCaptionWidth = (nscoord) ((capPercent / innerPercent) * aInnerWidth);
   }
-  aCaptionWidth = nsTableFrame::RoundToPixel(aCaptionWidth,
-                                             eAlwaysRoundDown);
 }
 
 nsresult 
@@ -1080,9 +1078,6 @@ nsTableOuterFrame::OuterReflowChild(nsPr
     
     NS_ASSERTION(NS_UNCONSTRAINEDSIZE != margin.bottom, "No unconstrainedsize arithmetic, please");
     availHeight -= margin.bottom;
-    
-    availHeight = nsTableFrame::RoundToPixel(availHeight,
-                                             eAlwaysRoundDown);
   }
   nsSize availSize(aAvailWidth, availHeight);
   // create and init the child reflow state, using placement new on
diff -r 0e7c4e08fda1 layout/tables/nsTableRowGroupFrame.cpp
--- a/layout/tables/nsTableRowGroupFrame.cpp	Wed Feb 21 20:23:38 2007 -0800
+++ b/layout/tables/nsTableRowGroupFrame.cpp	Wed Feb 21 20:23:50 2007 -0800
@@ -601,10 +601,10 @@ nsTableRowGroupFrame::CalculateRowHeight
     if (!rowFrame->GetPrevInFlow()) {
       if (rowFrame->HasPctHeight()) {
         rowInfo[rowIndex].hasPctHeight = PR_TRUE;
-        rowInfo[rowIndex].pctHeight = nsTableFrame::RoundToPixel(rowFrame->GetHeight(pctHeightBasis));
+        rowInfo[rowIndex].pctHeight = rowFrame->GetHeight(pctHeightBasis);
       }
       rowInfo[rowIndex].hasStyleHeight = rowFrame->HasStyleHeight();
-      nonPctHeight = nsTableFrame::RoundToPixel(PR_MAX(nonPctHeight, rowFrame->GetFixedHeight()));
+      nonPctHeight = PR_MAX(nonPctHeight, rowFrame->GetFixedHeight());
     }
     UpdateHeights(rowInfo[rowIndex], nonPctHeight, heightOfRows, heightOfUnStyledRows);
 
@@ -695,7 +695,7 @@ nsTableRowGroupFrame::CalculateRowHeight
                       // give rows their percentage, except for the first row which gets the remainder
                       nscoord extraForRow = (0 == spanX) ? extra - extraUsed  
                                                          : NSToCoordRound(((float)(extra)) * percent);
-                      extraForRow = PR_MIN(nsTableFrame::RoundToPixel(extraForRow), extra - extraUsed);
+                      extraForRow = PR_MIN(extraForRow, extra - extraUsed);
                       // update the row height
                       UpdateHeights(rowInfo[rowIndex + spanX], extraForRow, heightOfRows, heightOfUnStyledRows);
                       extraUsed += extraForRow;
@@ -723,7 +723,7 @@ nsTableRowGroupFrame::CalculateRowHeight
                     nscoord extraForRow = (numSpecialRowsSpanned - 1 == numSpecialRowsAllocated) 
                                           ? extra - extraUsed  
                                           : NSToCoordRound(((float)(extra)) * percent);
-                    extraForRow = PR_MIN(nsTableFrame::RoundToPixel(extraForRow), extra - extraUsed);
+                    extraForRow = PR_MIN(extraForRow, extra - extraUsed);
                     // update the row height
                     UpdateHeights(rowInfo[rowIndex + spanX], extraForRow, heightOfRows, heightOfUnStyledRows);
                     extraUsed += extraForRow;
@@ -776,7 +776,7 @@ nsTableRowGroupFrame::CalculateRowHeight
           nscoord extraForRow = (numRows - 1 == rowIndex) 
                                 ? extraComputedHeight - extraUsed  
                                 : NSToCoordRound(((float)extraComputedHeight) * percent);
-          extraForRow = PR_MIN(nsTableFrame::RoundToPixel(extraForRow), extraComputedHeight - extraUsed);
+          extraForRow = PR_MIN(extraForRow, extraComputedHeight - extraUsed);
           // update the row height
           UpdateHeights(rowInfo[rowIndex], extraForRow, heightOfRows, heightOfUnStyledRows);
           extraUsed += extraForRow;
@@ -1035,12 +1035,8 @@ nsTableRowGroupFrame::SplitRowGroup(nsPr
   nsTableRowFrame* prevRowFrame = nsnull;
   aDesiredSize.height = 0;
 
-  nscoord availWidth  = (NS_UNCONSTRAINEDSIZE == aReflowState.availableWidth) ?
-                        NS_UNCONSTRAINEDSIZE :
-                        nsTableFrame::RoundToPixel(aReflowState.availableWidth);
-  nscoord availHeight = (NS_UNCONSTRAINEDSIZE == aReflowState.availableHeight) ?
-                        NS_UNCONSTRAINEDSIZE :
-                        nsTableFrame::RoundToPixel(aReflowState.availableHeight);
+  nscoord availWidth  = aReflowState.availableWidth;
+  nscoord availHeight = aReflowState.availableHeight;
   
   PRBool  borderCollapse = ((nsTableFrame*)aTableFrame->GetFirstInFlow())->IsBorderCollapse();
   nscoord cellSpacingY   = aTableFrame->GetCellSpacingY();
