From: L. David Baron <dbaron@dbaron.org>

Pass through desired link-visitedness on the rule walker and construct if-visited style contexts in the style set when visited styles are present.  (Bug 147777)

diff --git a/layout/style/nsRuleWalker.h b/layout/style/nsRuleWalker.h
--- a/layout/style/nsRuleWalker.h
+++ b/layout/style/nsRuleWalker.h
@@ -36,17 +36,21 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 /*
  * a class that walks the lexicographic tree of rule nodes as style
  * rules are matched
  */
 
+#ifndef nsRuleWalker_h_
+#define nsRuleWalker_h_
+
 #include "nsRuleNode.h"
+#include "nsIStyleRule.h"
 
 class nsRuleWalker {
 public:
   nsRuleNode* CurrentNode() { return mCurrent; }
   void SetCurrentNode(nsRuleNode* aNode) {
     NS_ASSERTION(aNode, "Must have node here!");
     mCurrent = aNode;
   }
@@ -70,24 +74,64 @@ public:
     mLevel = aLevel;
     mImportance = aImportance;
     mCheckForImportantRules = aCheckForImportantRules;
   }
   PRUint8 GetLevel() const { return mLevel; }
   PRBool GetImportance() const { return mImportance; }
   PRBool GetCheckForImportantRules() const { return mCheckForImportantRules; }
 
+  // We define the visited-relevant link to be the link that is the
+  // nearest self-or-ancestor to the node being matched.
+  enum VisitedHandlingType {
+    // Do rule matching as though all links are unvisited.
+    eRelevantLinkUnvisited,
+    // Do rule matching as though the relevant link is visited and all
+    // other links are unvisited.
+    eRelevantLinkVisited,
+    // Do rule matching as though a rule should match if it would match
+    // given any set of visitedness states.  (used by users other than
+    // nsRuleWalker)
+    eLinksVisitedOrUnvisited
+  };
+
+  void ResetForVisitedMatching() {
+    Reset();
+    mVisitedHandling = eRelevantLinkVisited;
+  }
+  VisitedHandlingType VisitedHandling() const { return mVisitedHandling; }
+  void SetHaveRelevantLink() { mHaveRelevantLink = PR_TRUE; }
+  PRBool HaveRelevantLink() const { return mHaveRelevantLink; }
+
 private:
   nsRuleNode* mCurrent; // Our current position.  Never null.
   nsRuleNode* mRoot; // The root of the tree we're walking.
   PRUint8 mLevel; // an nsStyleSet::sheetType
   PRPackedBool mImportance;
   PRPackedBool mCheckForImportantRules; // If true, check for important rules as
                                         // we walk and set to false if we find
                                         // one.
 
+  // When mVisitedHandling is eRelevantLinkUnvisited, this is set to
+  // true on the RuleProcessorData *for the node being matched* if a a
+  // relevant link (see explanation in definition of VisitedHandling
+  // enum) was encountered during the matching process, which means that
+  // matching needs to be rerun with eRelevantLinkVisited.  Otherwise,
+  // its behavior is undefined (it might get set appropriately, or might
+  // not).
+  PRBool mHaveRelevantLink;
+
+  VisitedHandlingType mVisitedHandling;
+
 public:
-  nsRuleWalker(nsRuleNode* aRoot) :mCurrent(aRoot), mRoot(aRoot) {
+  nsRuleWalker(nsRuleNode* aRoot)
+    : mCurrent(aRoot)
+    , mRoot(aRoot)
+    , mHaveRelevantLink(PR_FALSE)
+    , mVisitedHandling(eRelevantLinkUnvisited)
+  {
     NS_ASSERTION(mCurrent, "Caller screwed up and gave us null node");
     MOZ_COUNT_CTOR(nsRuleWalker);
   }
   ~nsRuleWalker() { MOZ_COUNT_DTOR(nsRuleWalker); }
 };
+
+#endif /* !defined(nsRuleWalker_h_) */
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -424,52 +424,91 @@ EnumRulesMatching(nsIStyleRuleProcessor*
  * |GetContext| implements sharing of style contexts (not just the data
  * on the rule nodes) between siblings and cousins of the same
  * generation.  (It works for cousins of the same generation since
  * |aParentContext| could itself be a shared context.)
  */
 already_AddRefed<nsStyleContext>
 nsStyleSet::GetContext(nsStyleContext* aParentContext,
                        nsRuleNode* aRuleNode,
+                       // aVisitedRuleNode may be null; if it is null
+                       // it means that we don't need to force creation
+                       // of a StyleIfVisited.  (But if we make one
+                       // because aParentContext has one, then aRuleNode
+                       // should be used.)
+                       nsRuleNode* aVisitedRuleNode,
                        nsIAtom* aPseudoTag,
                        nsCSSPseudoElements::Type aPseudoType)
 {
   NS_PRECONDITION((!aPseudoTag &&
                    aPseudoType ==
                      nsCSSPseudoElements::ePseudo_NotPseudoElement) ||
                   (aPseudoTag &&
                    nsCSSPseudoElements::GetPseudoType(aPseudoTag) ==
                      aPseudoType),
                   "Pseudo mismatch");
 
-  nsStyleContext* result = nsnull;
+  // Ensure |aVisitedRuleNode != nsnull| corresponds to the need to
+  // create an if-visited style context, and that in that case, we have
+  // parentIfVisited set correctly.
+  nsStyleContext *parentIfVisited =
+    aParentContext ? aParentContext->GetStyleIfVisited() : nsnull;
+  if (parentIfVisited) {
+    if (!aVisitedRuleNode) {
+      aVisitedRuleNode = aRuleNode;
+    }
+  } else {
+    if (aVisitedRuleNode) {
+      parentIfVisited = aParentContext;
+    }
+  }
 
+  if (aIsLink) {
+    // If this node is a link, we want its visited's style context's
+    // parent to be the regular style context of its parent, because
+    // only the visitedness of the relevant link should influence style.
+    parentIfVisited = aParentContext;
+  }
+
+  nsRefPtr<nsStyleContext> result;
   if (aParentContext)
     result = aParentContext->FindChildWithRules(aPseudoTag, aRuleNode,
-                                                nsnull, PR_FALSE).get();
+                                                aVisitedRuleNode,
+                                                PR_FALSE);
 
 #ifdef NOISY_DEBUG
   if (result)
     fprintf(stdout, "--- SharedSC %d ---\n", ++gSharedCount);
   else
     fprintf(stdout, "+++ NewSC %d +++\n", ++gNewCount);
 #endif
 
   if (!result) {
     result = NS_NewStyleContext(aParentContext, aPseudoTag, aPseudoType,
-                                aRuleNode, PresContext()).get();
-    if (!aParentContext && result)
+                                aRuleNode, PresContext());
+    if (!result)
+      return nsnull;
+    if (aVisitedRuleNode) {
+      nsRefPtr<nsStyleContext> resultIfVisited =
+        NS_NewStyleContext(parentIfVisited, aPseudoTag, aPseudoType,
+                           aVisitedRuleNode, PresContext());
+      if (!resultIfVisited) {
+        return nsnull;
+      }
+      result->SetStyleIfVisited(resultIfVisited.forget());
+    }
+    if (!aParentContext)
       mRoots.AppendElement(result);
   }
   else {
     NS_ASSERTION(result->GetPseudoType() == aPseudoType, "Unexpected type");
     NS_ASSERTION(result->GetPseudo() == aPseudoTag, "Unexpected pseudo");
   }
 
-  return result;
+  return result.forget();
 }
 
 void
 nsStyleSet::AddImportantRules(nsRuleNode* aCurrLevelNode,
                               nsRuleNode* aLastPrevLevelNode,
                               nsRuleWalker* aRuleWalker)
 {
   NS_ASSERTION(aCurrLevelNode &&
@@ -743,17 +782,27 @@ nsStyleSet::ResolveStyleFor(nsIContent* 
   NS_ASSERTION(aContent && aContent->IsNodeOfType(nsINode::eELEMENT),
                "aContent must be element");
 
   nsRuleWalker ruleWalker(mRuleTree);
   ElementRuleProcessorData data(PresContext(), aContent, &ruleWalker);
   FileRules(EnumRulesMatching<ElementRuleProcessorData>, &data, aContent,
             &ruleWalker);
 
-  return GetContext(aParentContext, ruleWalker.CurrentNode(),
+  nsRuleNode *ruleNode = ruleWalker.CurrentNode();
+  nsRuleNode *visitedRuleNode = nsnull;
+
+  if (ruleWalker.HaveRelevantLink()) {
+    ruleWalker.ResetForVisitedMatching();
+    FileRules(EnumRulesMatching<ElementRuleProcessorData>, &data, aContent,
+              &ruleWalker);
+    visitedRuleNode = ruleWalker.CurrentNode();
+  }
+
+  return GetContext(aParentContext, ruleNode, visitedRuleNode,
                     nsnull, nsCSSPseudoElements::ePseudo_NotPseudoElement);
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForRules(nsStyleContext* aParentContext,
                                  const nsCOMArray<nsIStyleRule> &aRules)
 {
   NS_ENSURE_FALSE(mInShutdown, nsnull);
@@ -761,17 +810,17 @@ nsStyleSet::ResolveStyleForRules(nsStyle
   nsRuleWalker ruleWalker(mRuleTree);
   // FIXME: Perhaps this should be passed in, but it probably doesn't
   // matter.
   ruleWalker.SetLevel(eDocSheet, PR_FALSE, PR_FALSE);
   for (PRInt32 i = 0; i < aRules.Count(); i++) {
     ruleWalker.Forward(aRules.ObjectAt(i));
   }
 
-  return GetContext(aParentContext, ruleWalker.CurrentNode(),
+  return GetContext(aParentContext, ruleWalker.CurrentNode(), nsnull,
                     nsnull, nsCSSPseudoElements::ePseudo_NotPseudoElement);
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleByAddingRules(nsStyleContext* aBaseContext,
                                       const nsCOMArray<nsIStyleRule> &aRules)
 {
   NS_ENSURE_FALSE(mInShutdown, nsnull);
@@ -779,25 +828,37 @@ nsStyleSet::ResolveStyleByAddingRules(ns
   nsRuleWalker ruleWalker(mRuleTree);
   ruleWalker.SetCurrentNode(aBaseContext->GetRuleNode());
   // FIXME: Perhaps this should be passed in, but it probably doesn't
   // matter.
   ruleWalker.SetLevel(eDocSheet, PR_FALSE, PR_FALSE);
   for (PRInt32 i = 0; i < aRules.Count(); i++) {
     ruleWalker.Forward(aRules.ObjectAt(i));
   }
-  return GetContext(aBaseContext->GetParent(), ruleWalker.CurrentNode(),
+
+  nsRuleNode *ruleNode = ruleWalker.CurrentNode();
+  nsRuleNode *visitedRuleNode = nsnull;
+
+  if (aBaseContext->GetStyleIfVisited()) {
+    ruleWalker.SetCurrentNode(aBaseContext->GetStyleIfVisited()->GetRuleNode());
+    for (PRInt32 i = 0; i < aRules.Count(); i++) {
+      ruleWalker.Forward(aRules.ObjectAt(i));
+    }
+    visitedRuleNode = ruleWalker.CurrentNode();
+  }
+
+  return GetContext(aBaseContext->GetParent(), ruleNode, visitedRuleNode,
                     aBaseContext->GetPseudo(),
                     aBaseContext->GetPseudoType());
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForNonElement(nsStyleContext* aParentContext)
 {
-  return GetContext(aParentContext, mRuleTree,
+  return GetContext(aParentContext, mRuleTree, nsnull,
                     nsCSSAnonBoxes::mozNonElement,
                     nsCSSPseudoElements::ePseudo_AnonBox);
 }
 
 void
 nsStyleSet::WalkRestrictionRule(nsCSSPseudoElements::Type aPseudoType,
                                 nsRuleWalker* aRuleWalker)
 {
@@ -824,17 +885,27 @@ nsStyleSet::ResolvePseudoElementStyle(ns
 
   nsRuleWalker ruleWalker(mRuleTree);
   PseudoElementRuleProcessorData data(PresContext(), aParentContent,
                                       &ruleWalker, aType);
   WalkRestrictionRule(aType, &ruleWalker);
   FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
             aParentContent, &ruleWalker);
 
-  return GetContext(aParentContext, ruleWalker.CurrentNode(),
+  nsRuleNode *ruleNode = ruleWalker.CurrentNode();
+  nsRuleNode *visitedRuleNode = nsnull;
+
+  if (ruleWalker.HaveRelevantLink()) {
+    ruleWalker.ResetForVisitedMatching();
+    FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
+              aParentContent, &ruleWalker);
+    visitedRuleNode = ruleWalker.CurrentNode();
+  }
+
+  return GetContext(aParentContext, ruleNode, visitedRuleNode,
                     nsCSSPseudoElements::GetPseudoAtom(aType), aType);
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ProbePseudoElementStyle(nsIContent* aParentContent,
                                     nsCSSPseudoElements::Type aType,
                                     nsStyleContext* aParentContext)
 {
@@ -856,18 +927,28 @@ nsStyleSet::ProbePseudoElementStyle(nsIC
   FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
             aParentContent, &ruleWalker);
 
   nsRuleNode *ruleNode = ruleWalker.CurrentNode();
   if (ruleNode == adjustedRoot) {
     return nsnull;
   }
 
+  nsRuleNode *visitedRuleNode = nsnull;
+
+  if (ruleWalker.HaveRelevantLink()) {
+    ruleWalker.ResetForVisitedMatching();
+    FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
+              aParentContent, &ruleWalker);
+    visitedRuleNode = ruleWalker.CurrentNode();
+  }
+
   nsRefPtr<nsStyleContext> result =
-    GetContext(aParentContext, ruleNode, pseudoTag, aType);
+    GetContext(aParentContext, ruleNode, visitedRuleNode,
+               pseudoTag, aType);
 
   // For :before and :after pseudo-elements, having display: none or no
   // 'content' property is equivalent to not having the pseudo-element
   // at all.
   if (result &&
       (pseudoTag == nsCSSPseudoElements::before ||
        pseudoTag == nsCSSPseudoElements::after)) {
     const nsStyleDisplay *display = result->GetStyleDisplay();
@@ -897,17 +978,17 @@ nsStyleSet::ResolveAnonymousBoxStyle(nsI
     NS_PRECONDITION(isAnonBox, "Unexpected pseudo");
 #endif
 
   nsRuleWalker ruleWalker(mRuleTree);
   AnonBoxRuleProcessorData data(PresContext(), aPseudoTag, &ruleWalker);
   FileRules(EnumRulesMatching<AnonBoxRuleProcessorData>, &data, nsnull,
             &ruleWalker);
 
-  return GetContext(aParentContext, ruleWalker.CurrentNode(),
+  return GetContext(aParentContext, ruleWalker.CurrentNode(), nsnull,
                     aPseudoTag, nsCSSPseudoElements::ePseudo_AnonBox);
 }
 
 #ifdef MOZ_XUL
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveXULTreePseudoStyle(nsIContent* aParentContent,
                                       nsIAtom* aPseudoTag,
                                       nsStyleContext* aParentContext,
@@ -922,17 +1003,27 @@ nsStyleSet::ResolveXULTreePseudoStyle(ns
                "Unexpected pseudo");
 
   nsRuleWalker ruleWalker(mRuleTree);
   XULTreeRuleProcessorData data(PresContext(), aParentContent, &ruleWalker,
                                 aPseudoTag, aComparator);
   FileRules(EnumRulesMatching<XULTreeRuleProcessorData>, &data, aParentContent,
             &ruleWalker);
 
-  return GetContext(aParentContext, ruleWalker.CurrentNode(),
+  nsRuleNode *ruleNode = ruleWalker.CurrentNode();
+  nsRuleNode *visitedRuleNode = nsnull;
+
+  if (ruleWalker.HaveRelevantLink()) {
+    ruleWalker.ResetForVisitedMatching();
+    FileRules(EnumRulesMatching<XULTreeRuleProcessorData>, &data,
+              aParentContent, &ruleWalker);
+    visitedRuleNode = ruleWalker.CurrentNode();
+  }
+
+  return GetContext(aParentContext, ruleNode, visitedRuleNode,
                     aPseudoTag, nsCSSPseudoElements::ePseudo_XULTree);
 }
 #endif
 
 PRBool
 nsStyleSet::AppendFontFaceRules(nsPresContext* aPresContext,
                                 nsTArray<nsFontFaceRuleContainer>& aArray)
 {
@@ -1039,18 +1130,24 @@ nsStyleSet::ReparentStyleContext(nsStyle
   if (aStyleContext->GetParent() == aNewParentContext) {
     aStyleContext->AddRef();
     return aStyleContext;
   }
 
   nsIAtom* pseudoTag = aStyleContext->GetPseudo();
   nsCSSPseudoElements::Type pseudoType = aStyleContext->GetPseudoType();
   nsRuleNode* ruleNode = aStyleContext->GetRuleNode();
+  nsRuleNode* visitedRuleNode = nsnull;
+  nsStyleContext* visitedContext = aStyleContext->GetStyleIfVisited();
+  if (visitedContext) {
+     visitedRuleNode = visitedContext->GetRuleNode();
+  }
 
-  return GetContext(aNewParentContext, ruleNode, pseudoTag, pseudoType);
+  return GetContext(aNewParentContext, ruleNode, visitedRuleNode,
+                    pseudoTag, pseudoType);
 }
 
 struct StatefulData : public StateRuleProcessorData {
   StatefulData(nsPresContext* aPresContext,
                nsIContent* aContent, PRInt32 aStateMask)
     : StateRuleProcessorData(aPresContext, aContent, aStateMask),
       mHint(nsRestyleHint(0))
   {}
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -334,16 +334,17 @@ class nsStyleSet
   // of the rules and break out if the enumeration is halted.
   void WalkRuleProcessors(nsIStyleRuleProcessor::EnumFunc aFunc,
                           RuleProcessorData* aData,
                           PRBool aWalkAllXBLStylesheets);
 
   already_AddRefed<nsStyleContext>
   GetContext(nsStyleContext* aParentContext,
              nsRuleNode* aRuleNode,
+             nsRuleNode* aVisitedRuleNode,
              nsIAtom* aPseudoTag,
              nsCSSPseudoElements::Type aPseudoType);
 
   nsPresContext* PresContext() { return mRuleTree->GetPresContext(); }
 
   // The sheets in each array in mSheets are stored with the most significant
   // sheet last.
   nsCOMArray<nsIStyleSheet> mSheets[eSheetTypeCount];
