From: L. David Baron <dbaron@dbaron.org>

Pass through desired link-visitedness on the rule walker and construct if-visited style contexts in the style set when visited styles are present.  (Bug 147777)

diff --git a/layout/style/nsRuleWalker.h b/layout/style/nsRuleWalker.h
--- a/layout/style/nsRuleWalker.h
+++ b/layout/style/nsRuleWalker.h
@@ -36,17 +36,21 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 /*
  * a class that walks the lexicographic tree of rule nodes as style
  * rules are matched
  */
 
+#ifndef nsRuleWalker_h_
+#define nsRuleWalker_h_
+
 #include "nsRuleNode.h"
+#include "nsIStyleRule.h"
 
 class nsRuleWalker {
 public:
   nsRuleNode* CurrentNode() { return mCurrent; }
   void SetCurrentNode(nsRuleNode* aNode) {
     NS_ASSERTION(aNode, "Must have node here!");
     mCurrent = aNode;
   }
@@ -70,24 +74,64 @@ public:
     mLevel = aLevel;
     mImportance = aImportance;
     mCheckForImportantRules = aCheckForImportantRules;
   }
   PRUint8 GetLevel() const { return mLevel; }
   PRBool GetImportance() const { return mImportance; }
   PRBool GetCheckForImportantRules() const { return mCheckForImportantRules; }
 
+  // We define the visited-relevant link to be the link that is the
+  // nearest self-or-ancestor to the node being matched.
+  enum VisitedHandlingType {
+    // Do rule matching as though all links are unvisited.
+    eRelevantLinkUnvisited,
+    // Do rule matching as though the relevant link is visited and all
+    // other links are unvisited.
+    eRelevantLinkVisited,
+    // Do rule matching as though a rule should match if it would match
+    // given any set of visitedness states.  (used by users other than
+    // nsRuleWalker)
+    eLinksVisitedOrUnvisited
+  };
+
+  void ResetForVisitedMatching() {
+    Reset();
+    mVisitedHandling = eRelevantLinkVisited;
+  }
+  VisitedHandlingType VisitedHandling() const { return mVisitedHandling; }
+  void SetHaveRelevantLink() { mHaveRelevantLink = PR_TRUE; }
+  PRBool HaveRelevantLink() const { return mHaveRelevantLink; }
+
 private:
   nsRuleNode* mCurrent; // Our current position.  Never null.
   nsRuleNode* mRoot; // The root of the tree we're walking.
   PRUint8 mLevel; // an nsStyleSet::sheetType
   PRPackedBool mImportance;
   PRPackedBool mCheckForImportantRules; // If true, check for important rules as
                                         // we walk and set to false if we find
                                         // one.
 
+  // When mVisitedHandling is eRelevantLinkUnvisited, this is set to
+  // true on the RuleProcessorData *for the node being matched* if a a
+  // relevant link (see explanation in definition of VisitedHandling
+  // enum) was encountered during the matching process, which means that
+  // matching needs to be rerun with eRelevantLinkVisited.  Otherwise,
+  // its behavior is undefined (it might get set appropriately, or might
+  // not).
+  PRBool mHaveRelevantLink;
+
+  VisitedHandlingType mVisitedHandling;
+
 public:
-  nsRuleWalker(nsRuleNode* aRoot) :mCurrent(aRoot), mRoot(aRoot) {
+  nsRuleWalker(nsRuleNode* aRoot)
+    : mCurrent(aRoot)
+    , mRoot(aRoot)
+    , mHaveRelevantLink(PR_FALSE)
+    , mVisitedHandling(eRelevantLinkUnvisited)
+  {
     NS_ASSERTION(mCurrent, "Caller screwed up and gave us null node");
     MOZ_COUNT_CTOR(nsRuleWalker);
   }
   ~nsRuleWalker() { MOZ_COUNT_DTOR(nsRuleWalker); }
 };
+
+#endif /* !defined(nsRuleWalker_h_) */
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -425,52 +425,84 @@ EnumRulesMatching(nsIStyleRuleProcessor*
  * on the rule nodes) between siblings and cousins of the same
  * generation.  (It works for cousins of the same generation since
  * |aParentContext| could itself be a shared context.)
  */
 already_AddRefed<nsStyleContext>
 nsStyleSet::GetContext(nsPresContext* aPresContext, 
                        nsStyleContext* aParentContext, 
                        nsRuleNode* aRuleNode,
+                       // aVisitedRuleNode may be null; if it is null
+                       // it means that we don't need to force creation
+                       // of a StyleIfVisited.  (But if we make one
+                       // because aParentContext has one, then aRuleNode
+                       // should be used.)
+                       nsRuleNode* aVisitedRuleNode,
                        nsIAtom* aPseudoTag,
                        nsCSSPseudoElements::Type aPseudoType)
 {
   NS_PRECONDITION((!aPseudoTag &&
                    aPseudoType ==
                      nsCSSPseudoElements::ePseudo_NotPseudoElement) ||
                   (aPseudoTag &&
                    nsCSSPseudoElements::GetPseudoType(aPseudoTag) ==
                      aPseudoType),
                   "Pseudo mismatch");
 
-  nsStyleContext* result = nsnull;
-      
+  // Ensure |aVisitedRuleNode != nsnull| corresponds to the need to
+  // create an if-visited style context, and that in that case, we have
+  // parentIfVisited set correctly.
+  nsStyleContext *parentIfVisited =
+    aParentContext ? aParentContext->StyleIfVisited() : nsnull;
+  if (parentIfVisited) {
+    if (!aVisitedRuleNode) {
+      aVisitedRuleNode = aRuleNode;
+    }
+  } else {
+    if (aVisitedRuleNode) {
+      parentIfVisited = aParentContext;
+    }
+  }
+
+  nsRefPtr<nsStyleContext> result;
   if (aParentContext)
     result = aParentContext->FindChildWithRules(aPseudoTag, aRuleNode,
-                                                nsnull, PR_FALSE).get();
+                                                aVisitedRuleNode,
+                                                PR_FALSE);
 
 #ifdef NOISY_DEBUG
   if (result)
     fprintf(stdout, "--- SharedSC %d ---\n", ++gSharedCount);
   else
     fprintf(stdout, "+++ NewSC %d +++\n", ++gNewCount);
 #endif
 
   if (!result) {
     result = NS_NewStyleContext(aParentContext, aPseudoTag, aPseudoType,
-                                aRuleNode, aPresContext).get();
-    if (!aParentContext && result)
+                                aRuleNode, aPresContext);
+    if (!result)
+      return nsnull;
+    if (aVisitedRuleNode) {
+      nsRefPtr<nsStyleContext> resultIfVisited =
+        NS_NewStyleContext(parentIfVisited, aPseudoTag, aPseudoType,
+                           aVisitedRuleNode, aPresContext);
+      if (!resultIfVisited) {
+        return nsnull;
+      }
+      result->SetStyleIfVisited(resultIfVisited.forget());
+    }
+    if (!aParentContext)
       mRoots.AppendElement(result);
   }
   else {
     NS_ASSERTION(result->GetPseudoType() == aPseudoType, "Unexpected type");
     NS_ASSERTION(result->GetPseudo() == aPseudoTag, "Unexpected pseudo");
   }
 
-  return result;
+  return result.forget();
 }
 
 void
 nsStyleSet::AddImportantRules(nsRuleNode* aCurrLevelNode,
                               nsRuleNode* aLastPrevLevelNode,
                               nsRuleWalker* aRuleWalker)
 {
   NS_ASSERTION(aCurrLevelNode &&
@@ -744,18 +776,29 @@ nsStyleSet::ResolveStyleFor(nsIContent* 
   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eELEMENT),
                "content must be element");
 
   if (aContent && presContext) {
     nsRuleWalker ruleWalker(mRuleTree);
     ElementRuleProcessorData data(presContext, aContent, &ruleWalker);
     FileRules(EnumRulesMatching<ElementRuleProcessorData>, &data, aContent,
               &ruleWalker);
-    result = GetContext(presContext, aParentContext,
-                        ruleWalker.CurrentNode(), nsnull,
+
+    nsRuleNode *ruleNode = ruleWalker.CurrentNode();
+    nsRuleNode *visitedRuleNode = nsnull;
+
+    if (ruleWalker.HaveRelevantLink()) {
+      ruleWalker.ResetForVisitedMatching();
+      FileRules(EnumRulesMatching<ElementRuleProcessorData>, &data, aContent,
+                &ruleWalker);
+      visitedRuleNode = ruleWalker.CurrentNode();
+    }
+
+    result = GetContext(presContext, aParentContext, ruleNode, visitedRuleNode,
+                        nsnull,
                         nsCSSPseudoElements::ePseudo_NotPseudoElement).get();
   }
 
   return result;
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForRules(nsStyleContext* aParentContext,
@@ -769,17 +812,17 @@ nsStyleSet::ResolveStyleForRules(nsStyle
     nsRuleWalker ruleWalker(mRuleTree);
     // FIXME: Perhaps this should be passed in, but it probably doesn't
     // matter.
     ruleWalker.SetLevel(eDocSheet, PR_FALSE, PR_FALSE);
     for (PRInt32 i = 0; i < aRules.Count(); i++) {
       ruleWalker.Forward(aRules.ObjectAt(i));
     }
     result = GetContext(presContext, aParentContext,
-                        ruleWalker.CurrentNode(), nsnull,
+                        ruleWalker.CurrentNode(), nsnull, nsnull,
                         nsCSSPseudoElements::ePseudo_NotPseudoElement).get();
   }
   return result;
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleByAddingRules(nsStyleContext* aBaseContext,
                                       const nsCOMArray<nsIStyleRule> &aRules)
@@ -792,32 +835,44 @@ nsStyleSet::ResolveStyleByAddingRules(ns
     nsRuleWalker ruleWalker(mRuleTree);
     ruleWalker.SetCurrentNode(aBaseContext->GetRuleNode());
     // FIXME: Perhaps this should be passed in, but it probably doesn't
     // matter.
     ruleWalker.SetLevel(eDocSheet, PR_FALSE, PR_FALSE);
     for (PRInt32 i = 0; i < aRules.Count(); i++) {
       ruleWalker.Forward(aRules.ObjectAt(i));
     }
+
+    nsRuleNode *ruleNode = ruleWalker.CurrentNode();
+    nsRuleNode *visitedRuleNode = nsnull;
+
+    if (aBaseContext->StyleIfVisited()) {
+      ruleWalker.SetCurrentNode(aBaseContext->StyleIfVisited()->GetRuleNode());
+      for (PRInt32 i = 0; i < aRules.Count(); i++) {
+        ruleWalker.Forward(aRules.ObjectAt(i));
+      }
+      visitedRuleNode = ruleWalker.CurrentNode();
+    }
+
     result = GetContext(presContext, aBaseContext->GetParent(),
-                        ruleWalker.CurrentNode(),
+                        ruleNode, visitedRuleNode,
                         aBaseContext->GetPseudo(),
                         aBaseContext->GetPseudoType()).get();
   }
   return result;
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForNonElement(nsStyleContext* aParentContext)
 {
   nsStyleContext* result = nsnull;
   nsPresContext *presContext = PresContext();
 
   if (presContext) {
-    result = GetContext(presContext, aParentContext, mRuleTree,
+    result = GetContext(presContext, aParentContext, mRuleTree, nsnull,
                         nsCSSAnonBoxes::mozNonElement,
                         nsCSSPseudoElements::ePseudo_AnonBox).get();
   }
 
   return result;
 }
 
 void
@@ -848,17 +903,27 @@ nsStyleSet::ResolvePseudoElementStyle(ns
   nsRuleWalker ruleWalker(mRuleTree);
   nsPresContext *presContext = PresContext();
   PseudoElementRuleProcessorData data(presContext, aParentContent, &ruleWalker,
                                       aType);
   WalkRestrictionRule(aType, &ruleWalker);
   FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
             aParentContent, &ruleWalker);
 
-  return GetContext(presContext, aParentContext, ruleWalker.CurrentNode(),
+  nsRuleNode *ruleNode = ruleWalker.CurrentNode();
+  nsRuleNode *visitedRuleNode = nsnull;
+
+  if (ruleWalker.HaveRelevantLink()) {
+    ruleWalker.ResetForVisitedMatching();
+    FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
+              aParentContent, &ruleWalker);
+    visitedRuleNode = ruleWalker.CurrentNode();
+  }
+
+  return GetContext(presContext, aParentContext, ruleNode, visitedRuleNode,
                     nsCSSPseudoElements::GetPseudoAtom(aType), aType);
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ProbePseudoElementStyle(nsIContent* aParentContent,
                                     nsCSSPseudoElements::Type aType,
                                     nsStyleContext* aParentContext)
 {
@@ -883,18 +948,28 @@ nsStyleSet::ProbePseudoElementStyle(nsIC
   FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
             aParentContent, &ruleWalker);
 
   nsRuleNode *ruleNode = ruleWalker.CurrentNode();
   if (ruleNode == adjustedRoot) {
     return nsnull;
   }
 
+  nsRuleNode *visitedRuleNode = nsnull;
+
+  if (ruleWalker.HaveRelevantLink()) {
+    ruleWalker.ResetForVisitedMatching();
+    FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
+              aParentContent, &ruleWalker);
+    visitedRuleNode = ruleWalker.CurrentNode();
+  }
+
   nsRefPtr<nsStyleContext> result =
-    GetContext(presContext, aParentContext, ruleNode, pseudoTag, aType);
+    GetContext(presContext, aParentContext, ruleNode, visitedRuleNode,
+               pseudoTag, aType);
 
   // For :before and :after pseudo-elements, having display: none or no
   // 'content' property is equivalent to not having the pseudo-element
   // at all.
   if (result &&
       (pseudoTag == nsCSSPseudoElements::before ||
        pseudoTag == nsCSSPseudoElements::after)) {
     const nsStyleDisplay *display = result->GetStyleDisplay();
@@ -926,17 +1001,17 @@ nsStyleSet::ResolveAnonymousBoxStyle(nsI
 
   nsRuleWalker ruleWalker(mRuleTree);
   nsPresContext *presContext = PresContext();
   AnonBoxRuleProcessorData data(presContext, aPseudoTag, &ruleWalker);
   FileRules(EnumRulesMatching<AnonBoxRuleProcessorData>, &data, nsnull,
             &ruleWalker);
 
   return GetContext(presContext, aParentContext, ruleWalker.CurrentNode(),
-                    aPseudoTag, nsCSSPseudoElements::ePseudo_AnonBox);
+                    nsnull, aPseudoTag, nsCSSPseudoElements::ePseudo_AnonBox);
 }
 
 #ifdef MOZ_XUL
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveXULTreePseudoStyle(nsIContent* aParentContent,
                                       nsIAtom* aPseudoTag,
                                       nsStyleContext* aParentContext,
                                       nsICSSPseudoComparator* aComparator)
@@ -952,17 +1027,27 @@ nsStyleSet::ResolveXULTreePseudoStyle(ns
   nsRuleWalker ruleWalker(mRuleTree);
   nsPresContext *presContext = PresContext();
 
   XULTreeRuleProcessorData data(presContext, aParentContent, &ruleWalker,
                                 aPseudoTag, aComparator);
   FileRules(EnumRulesMatching<XULTreeRuleProcessorData>, &data, aParentContent,
             &ruleWalker);
 
-  return GetContext(presContext, aParentContext, ruleWalker.CurrentNode(),
+  nsRuleNode *ruleNode = ruleWalker.CurrentNode();
+  nsRuleNode *visitedRuleNode = nsnull;
+
+  if (ruleWalker.HaveRelevantLink()) {
+    ruleWalker.ResetForVisitedMatching();
+    FileRules(EnumRulesMatching<XULTreeRuleProcessorData>, &data,
+              aParentContent, &ruleWalker);
+    visitedRuleNode = ruleWalker.CurrentNode();
+  }
+
+  return GetContext(presContext, aParentContext, ruleNode, visitedRuleNode,
                     aPseudoTag, nsCSSPseudoElements::ePseudo_XULTree);
 }
 #endif
 
 PRBool
 nsStyleSet::AppendFontFaceRules(nsPresContext* aPresContext,
                                 nsTArray<nsFontFaceRuleContainer>& aArray)
 {
@@ -1069,20 +1154,25 @@ nsStyleSet::ReParentStyleContext(nsPresC
     if (aStyleContext->GetParent() == aNewParentContext) {
       aStyleContext->AddRef();
       return aStyleContext;
     }
     else {  // really a new parent
       nsIAtom* pseudoTag = aStyleContext->GetPseudo();
       nsCSSPseudoElements::Type pseudoType = aStyleContext->GetPseudoType();
       nsRuleNode* ruleNode = aStyleContext->GetRuleNode();
+      nsRuleNode* visitedRuleNode = nsnull;
+      nsStyleContext* visitedContext = aStyleContext->StyleIfVisited();
+      if (visitedContext) {
+         visitedRuleNode = visitedContext->GetRuleNode();
+      }
 
       already_AddRefed<nsStyleContext> result =
-        GetContext(aPresContext, aNewParentContext, ruleNode, pseudoTag,
-                   pseudoType);
+        GetContext(aPresContext, aNewParentContext, ruleNode, visitedRuleNode,
+                   pseudoTag, pseudoType);
       return result;
     }
   }
   return nsnull;
 }
 
 struct StatefulData : public StateRuleProcessorData {
   StatefulData(nsPresContext* aPresContext,
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -329,16 +329,17 @@ class nsStyleSet
   // Enumerate all the rules in a way that doesn't care about the order
   // of the rules and break out if the enumeration is halted.
   void WalkRuleProcessors(nsIStyleRuleProcessor::EnumFunc aFunc,
                           RuleProcessorData* aData);
 
   already_AddRefed<nsStyleContext> GetContext(nsPresContext* aPresContext,
                                               nsStyleContext* aParentContext,
                                               nsRuleNode* aRuleNode,
+                                              nsRuleNode* aVisitedRuleNode,
                                               nsIAtom* aPseudoTag,
                                               nsCSSPseudoElements::Type aPseudoType);
 
   nsPresContext* PresContext() { return mRuleTree->GetPresContext(); }
 
   // The sheets in each array in mSheets are stored with the most significant
   // sheet last.
   nsCOMArray<nsIStyleSheet> mSheets[eSheetTypeCount];
