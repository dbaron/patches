Invalidate the correct area when loading an image for which we've displayed the loading-image icon.  (Bug 409870)  r+sr=bzbarsky  r?=roc

diff --git a/gfx/public/nsTransform2D.h b/gfx/public/nsTransform2D.h
--- a/gfx/public/nsTransform2D.h
+++ b/gfx/public/nsTransform2D.h
@@ -106,11 +106,21 @@ public:
  /**
   * add a scale to a Transform via x, y pair
   *
   * @param    ptX x value to add as x scale
   * @param    ptY y value to add as y scale
   **/
 
   void AddScale(float ptX, float ptY) { m00 *= ptX; m11 *= ptY; }
+
+ /**
+  * Set the scale (overriding any previous calls to AddScale, but leaving
+  * any existing translation).
+  *
+  * @param    ptX x value to add as x scale
+  * @param    ptY y value to add as y scale
+  **/
+
+  void SetScale(float ptX, float ptY) { m00 = ptX; m11 = ptY; }
 };
 
 #endif
diff --git a/layout/generic/nsImageFrame.cpp b/layout/generic/nsImageFrame.cpp
--- a/layout/generic/nsImageFrame.cpp
+++ b/layout/generic/nsImageFrame.cpp
@@ -304,34 +304,38 @@ nsImageFrame::UpdateIntrinsicSize(imgICo
       mIntrinsicSize = newSize;
     }
   }
 
   return intrinsicSizeChanged;
 }
 
 void
-nsImageFrame::RecalculateTransform()
+nsImageFrame::RecalculateTransform(PRBool aInnerAreaChanged)
 {
   // In any case, we need to translate this over appropriately.  Set
   // translation _before_ setting scaling so that it does not get
   // scaled!
 
   // XXXbz does this introduce rounding errors because of the cast to
   // float?  Should we just manually add that stuff in every time
   // instead?
-  nsRect innerArea = GetInnerArea();
-  mTransform.SetToTranslate(float(innerArea.x),
-                            float(innerArea.y - GetContinuationOffset()));
+  if (aInnerAreaChanged) {
+    nsRect innerArea = GetInnerArea();
+    mTransform.SetToTranslate(float(innerArea.x),
+                              float(innerArea.y - GetContinuationOffset()));
+  }
   
   // Set the scale factors
   if (mIntrinsicSize.width != 0 && mIntrinsicSize.height != 0 &&
       mIntrinsicSize != mComputedSize) {
-    mTransform.AddScale(float(mComputedSize.width)  / float(mIntrinsicSize.width),
+    mTransform.SetScale(float(mComputedSize.width)  / float(mIntrinsicSize.width),
                         float(mComputedSize.height) / float(mIntrinsicSize.height));
+  } else {
+    mTransform.SetScale(1.0f, 1.0f);
   }
 }
 
 /*
  * These two functions basically do the same check.  The first one
  * checks that the given request is the current request for our
  * mContent.  The second checks that the given image container the
  * same as the image container on the current request for our
@@ -501,24 +505,34 @@ nsImageFrame::OnStartContainer(imgIReque
 
   if (IsPendingLoad(aRequest)) {
     // We don't care
     return NS_OK;
   }
   
   UpdateIntrinsicSize(aImage);
 
-  // Now we need to reflow if we have an unconstrained size and have
-  // already gotten the initial reflow
-  if (!(mState & IMAGE_SIZECONSTRAINED) && (mState & IMAGE_GOTINITIALREFLOW)) { 
-    nsIPresShell *presShell = presContext->GetPresShell();
-    NS_ASSERTION(presShell, "No PresShell.");
-    if (presShell) { 
-      presShell->FrameNeedsReflow(this, nsIPresShell::eStyleChange,
-                                  NS_FRAME_IS_DIRTY);
+  if (mState & IMAGE_GOTINITIALREFLOW) {
+    // If we previously set the intrinsic size (in EnsureIntrinsicSize)
+    // to the size of the loading-image icon and reflowed the frame,
+    // we'll have an mTransform computed from that intrinsic size.  But
+    // if we still have that transform when we get OnDataAvailable
+    // calls, we'll invalidate the wrong area.  So update the transform
+    // now.
+    RecalculateTransform(PR_FALSE);
+
+    // Now we need to reflow if we have an unconstrained size and have
+    // already gotten the initial reflow
+    if (!(mState & IMAGE_SIZECONSTRAINED)) { 
+      nsIPresShell *presShell = presContext->GetPresShell();
+      NS_ASSERTION(presShell, "No PresShell.");
+      if (presShell) { 
+        presShell->FrameNeedsReflow(this, nsIPresShell::eStyleChange,
+                                    NS_FRAME_IS_DIRTY);
+      }
     }
   }
 
   return NS_OK;
 }
 
 nsresult
 nsImageFrame::OnDataAvailable(imgIRequest *aRequest,
@@ -786,17 +800,17 @@ nsImageFrame::Reflow(nsPresContext*     
   // XXXldb These two bits are almost exact opposites (except in the
   // middle of the initial reflow); remove IMAGE_GOTINITIALREFLOW.
   if (GetStateBits() & NS_FRAME_FIRST_REFLOW) {
     mState |= IMAGE_GOTINITIALREFLOW;
   }
 
   mComputedSize = 
     nsSize(aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
-  RecalculateTransform();
+  RecalculateTransform(PR_TRUE);
 
   aMetrics.width = mComputedSize.width;
   aMetrics.height = mComputedSize.height;
 
   // add borders and padding
   aMetrics.width  += aReflowState.mComputedBorderPadding.LeftRight();
   aMetrics.height += aReflowState.mComputedBorderPadding.TopBottom();
   
diff --git a/layout/generic/nsImageFrame.h b/layout/generic/nsImageFrame.h
--- a/layout/generic/nsImageFrame.h
+++ b/layout/generic/nsImageFrame.h
@@ -248,17 +248,17 @@ private:
    * @return whether aImage's size did _not_
    *         match our previous intrinsic size
    */
   PRBool UpdateIntrinsicSize(imgIContainer* aImage);
 
   /**
    * This function will recalculate mTransform.
    */
-  void RecalculateTransform();
+  void RecalculateTransform(PRBool aInnerAreaChanged);
 
   /**
    * Helper functions to check whether the request or image container
    * corresponds to a load we don't care about.  Most of the decoder
    * observer methods will bail early if these return true.
    */
   PRBool IsPendingLoad(imgIRequest* aRequest) const;
   PRBool IsPendingLoad(imgIContainer* aContainer) const;
