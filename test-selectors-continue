From: L. David Baron <dbaron@dbaron.org>

Make test_selectors continue when a parsing test fails.

diff --git a/layout/style/test/test_selectors.html b/layout/style/test/test_selectors.html
--- a/layout/style/test/test_selectors.html
+++ b/layout/style/test/test_selectors.html
@@ -49,16 +49,29 @@ function run() {
             // It's a function.
             ifdoc.body.innerHTML = "";
             body_contents(ifdoc.body);
         }
         if (!namespaces) {
             namespaces = "";
         }
         style_text.data = namespaces + selector + "{ z-index: " + zi + " }";
+
+        var idx = style_text.parentNode.sheet.cssRules.length - 1;
+        if (namespaces == "") {
+            is(idx, 0, "unexpected rule index");
+        }
+        if (idx < 0 ||
+            style_text.parentNode.sheet.cssRules[idx].type !=
+                CSSRule.STYLE_RULE)
+        {
+            ok(false, "selector " + selector + " could not be parsed");
+            return;
+        }
+
         var should_match = match_fn(ifdoc);
         var should_not_match = notmatch_fn(ifdoc);
         if (should_match.length + should_not_match.length == 0) {
             ok(false, "nothing to check");
         }
 
         for (var i = 0; i < should_match.length; ++i) {
             var e = should_match[i];
@@ -71,20 +84,16 @@ function run() {
                "element in " + body_contents + " did not match " + selector);
         }
 
         // Now, since we're here, may as well make sure serialization
         // works correctly.  It need not produce the exact same text,
         // but it should produce a selector that matches the same
         // elements.
         zi = ++gCounter;
-        var idx = style_text.parentNode.sheet.cssRules.length - 1;
-        if (namespaces == "") {
-            is(idx, 0, "unexpected rule index");
-        }
         var ser1 = style_text.parentNode.sheet.cssRules[idx].selectorText;
         style_text.data = namespaces + ser1 + "{ z-index: " + zi + " }";
         for (var i = 0; i < should_match.length; ++i) {
             var e = should_match[i];
             is(ifwin.getComputedStyle(e, "").zIndex, zi,
                "element in " + body_contents + " matched " + ser1 +
                " which is the reserialization of " + selector);
         }
@@ -170,18 +179,21 @@ function run() {
 
     function test_parseable(selector)
     {
         ifdoc.body.innerHTML = "<p></p>";
 
         var zi = ++gCounter;
         style_text.data = "p, " + selector + "{ z-index: " + zi + " }";
         var should_match = ifdoc.getElementsByTagName("p")[0];
-        is(ifwin.getComputedStyle(should_match, "").zIndex, zi,
-           "selector " + selector + " was parsed");
+        var parsed = ifwin.getComputedStyle(should_match, "").zIndex == zi;
+        ok(parsed, "selector " + selector + " was parsed");
+        if (!parsed) {
+            return;
+        }
 
         // Test that it serializes to something that is also parseable.
         var ser1 = style_elem.sheet.cssRules[0].selectorText;
         zi = ++gCounter;
         style_text.data = ser1 + "{ z-index: " + zi + " }";
         is(ifwin.getComputedStyle(should_match, "").zIndex, zi,
            "serialization " + ser1 + " of selector p, " + selector +
            " was parsed");
@@ -233,16 +245,32 @@ function run() {
         is(ifwin.getComputedStyle(should_not_match, "").zIndex, "auto",
            "selector " + selector + " was a parser error");
         is(ifwin.getComputedStyle(should_match, "").zIndex, zi2,
            "selector " + selector + " error was recovered from");
         ifdoc.body.innerHTML = "";
         style_text.data = "";
     }
 
+    function test_unbalanced_unparseable(selector)
+    {
+        var zi1 = ++gCounter;
+        var zi2 = ++gCounter;
+        ifdoc.body.innerHTML = "<p></p>";
+        style_text.data = "p, " + selector + "{ z-index: " + zi1 + " }";
+        var should_not_match = ifdoc.getElementsByTagName("p")[0];
+        is(ifwin.getComputedStyle(should_not_match, "").zIndex, "auto",
+           "selector " + selector + " was a parser error");
+        is(style_text.parentNode.sheet.cssRules.length, 0,
+           "sheet should have no rules since " + selector + " is parse error");
+        ifdoc.body.innerHTML = "";
+        style_text.data = "";
+    }
+
+
     // [attr= ] selector
     test_parseable("[attr=\"x\"]");
     test_parseable("[attr='x']");
     test_parseable("[attr=x]");
     test_parseable("[attr=\"\"]");
     test_parseable("[attr='']");
     test_parseable("[attr=\"foo bar\"]");
 
@@ -763,24 +791,20 @@ function run() {
     test_selector_in_html("Span", setup_cased_spans,
                           bodychildset([0, 1, 2, 3, 4, 10]),
                           bodychildset([5, 6, 7, 8, 9, 11]));
     test_selector_in_html("SPAN", setup_cased_spans,
                           bodychildset([0, 1, 2, 3, 4, 11]),
                           bodychildset([5, 6, 7, 8, 9, 10]));
 
     // bug 528096 (tree pseudos)
-    test_selector_in_html(":-moz-tree-column((){} a", single_a,
-                          empty_set, set_single, html_default_ns);
-    test_selector_in_html(":-moz-tree-column(x(){} a", single_a,
-                          empty_set, set_single, html_default_ns);
-    test_selector_in_html(":-moz-tree-column(a b (){} a", single_a,
-                          empty_set, set_single, html_default_ns);
-    test_selector_in_html(":-moz-tree-column(a, b (){} a", single_a,
-                          empty_set, set_single, html_default_ns);
+    test_unbalanced_unparseable(":-moz-tree-column((){} a");
+    test_unbalanced_unparseable(":-moz-tree-column(x(){} a");
+    test_unbalanced_unparseable(":-moz-tree-column(a b (){} a");
+    test_unbalanced_unparseable(":-moz-tree-column(a, b (){} a");
 
     // Bug 543428 (escaping)
     test_selector_in_html("\\32|a", single_a, set_single, empty_set,
                           "@namespace \\32  url(http://www.w3.org/1999/xhtml);");
     test_selector_in_html("-\\32|a", single_a, set_single, empty_set,
                           "@namespace -\\32  url(http://www.w3.org/1999/xhtml);");
     test_selector_in_html("\\2|a", single_a, set_single, empty_set,
                           "@namespace \\0002  url(http://www.w3.org/1999/xhtml);");
