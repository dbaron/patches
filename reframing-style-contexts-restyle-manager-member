From: L. David Baron <dbaron@dbaron.org>

Bug 1110277 patch 4 - Add a RestyleManager member to ReframingStyleContexts.

This is needed for patch 7.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -979,16 +979,22 @@ RestyleManager::RestyleElement(Element* 
         newContext->StyleDisplay()->mDisplay == NS_STYLE_DISPLAY_CONTENTS) {
       // Style change for a display:contents node that did not recreate frames.
       ComputeAndProcessStyleChange(newContext, aElement, aMinHint,
                                    aRestyleTracker, aRestyleHint);
     }
   }
 }
 
+RestyleManager::ReframingStyleContexts::ReframingStyleContexts(
+                                          RestyleManager* aRestyleManager)
+  : mRestyleManager(aRestyleManager)
+{
+}
+
 static inline dom::Element*
 ElementForStyleContext(nsIContent* aParentContent,
                        nsIFrame* aFrame,
                        nsCSSPseudoElements::Type aPseudoType);
 
 // Forwarded nsIDocumentObserver method, to handle restyling (and
 // passing the notification to the frame).
 nsresult
@@ -3889,17 +3895,17 @@ RestyleManager::ComputeAndProcessStyleCh
                                              nsChangeHint       aMinChange,
                                              RestyleTracker&    aRestyleTracker,
                                              nsRestyleHint      aRestyleHint)
 {
   // Create a ReframingStyleContexts struct on the stack and put it in
   // our mReframingStyleContexts for the scope of this function.
   MOZ_ASSERT(!mReframingStyleContexts, "shouldn't call recursively");
   AutoRestore<ReframingStyleContexts*> ar(mReframingStyleContexts);
-  ReframingStyleContexts reframingStyleContexts;
+  ReframingStyleContexts reframingStyleContexts(this);
   mReframingStyleContexts = &reframingStyleContexts;
 
   nsStyleChangeList changeList;
   ElementRestyler::ComputeStyleChangeFor(aFrame, &changeList, aMinChange,
                                          aRestyleTracker, aRestyleHint);
   ProcessRestyledFrames(changeList);
 }
 
@@ -3909,17 +3915,17 @@ RestyleManager::ComputeAndProcessStyleCh
                                              nsChangeHint       aMinChange,
                                              RestyleTracker&    aRestyleTracker,
                                              nsRestyleHint      aRestyleHint)
 {
   // Create a ReframingStyleContexts struct on the stack and put it in
   // our mReframingStyleContexts for the scope of this function.
   MOZ_ASSERT(!mReframingStyleContexts, "shouldn't call recursively");
   AutoRestore<ReframingStyleContexts*> ar(mReframingStyleContexts);
-  ReframingStyleContexts reframingStyleContexts;
+  ReframingStyleContexts reframingStyleContexts(this);
   mReframingStyleContexts = &reframingStyleContexts;
 
   MOZ_ASSERT(aNewContext->StyleDisplay()->mDisplay == NS_STYLE_DISPLAY_CONTENTS);
   nsIFrame* frame = GetNearestAncestorFrame(aElement);
   MOZ_ASSERT(frame, "display:contents node in map although it's a "
                     "display:none descendant?");
   TreeMatchContext treeMatchContext(true,
                                     nsRuleWalker::eRelevantLinkUnvisited,
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -176,18 +176,26 @@ public:
    * In all cases, the content node in the hash table is the real
    * content node, not the anonymous content node we create for ::before
    * or ::after.  The content node passed to the Get and Put methods is,
    * however, the content node to be associate with the frame's style
    * context.
    */
   typedef nsRefPtrHashtable<nsRefPtrHashKey<nsIContent>, nsStyleContext>
             ReframingStyleContextTable;
-  class ReframingStyleContexts {
+  class MOZ_STACK_CLASS ReframingStyleContexts {
   public:
+    /**
+     * Construct a ReframingStyleContexts object.  The caller must
+     * ensure that aRestyleManager lives at least as long as the
+     * object.  (This is generally easy since the caller is typically a
+     * method of RestyleManager.)
+     */
+    explicit ReframingStyleContexts(RestyleManager* aRestyleManager);
+
     void Put(nsIContent* aContent, nsStyleContext* aStyleContext) {
       MOZ_ASSERT(aContent);
       nsCSSPseudoElements::Type pseudoType = aStyleContext->GetPseudoType();
       if (pseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
         mElementContexts.Put(aContent, aStyleContext);
       } else if (pseudoType == nsCSSPseudoElements::ePseudo_before) {
         MOZ_ASSERT(aContent->Tag() == nsGkAtoms::mozgeneratedcontentbefore);
         mBeforePseudoContexts.Put(aContent->GetParent(), aStyleContext);
@@ -210,16 +218,17 @@ public:
       if (aPseudoType == nsCSSPseudoElements::ePseudo_after) {
         MOZ_ASSERT(aContent->Tag() == nsGkAtoms::mozgeneratedcontentafter);
         return mAfterPseudoContexts.GetWeak(aContent->GetParent());
       }
       MOZ_ASSERT(false, "unexpected aPseudoType");
       return nullptr;
     }
   private:
+    RestyleManager* mRestyleManager;
     ReframingStyleContextTable mElementContexts;
     ReframingStyleContextTable mBeforePseudoContexts;
     ReframingStyleContextTable mAfterPseudoContexts;
   };
 
   /**
    * Return the current ReframingStyleContexts struct, or null if we're
    * not currently in a restyling operation.
