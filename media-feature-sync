From: L. David Baron <dbaron@dbaron.org>

Bug 1089417 patch 12 - Remove the ability to handle media feature value change asynchronously, which we only used at one caller (SetVisibleArea), and handle it synchronously.

I don't remember why this optimization was added, and it may not have
been based on a whole lot of evidence showing it was needed, given that
it was added in the initial implementation of media queries (bug 156716,
part 4).

If it turns out is needed, in order to make it work correctly, we need
to add this assertion in nsCSSRuleProcessor::GetRuleCascade :
+  NS_ASSERTION(!aPresContext->HasPendingMediaFeatureValuesChanged(),
+               "caller didn't flush pending media feature changes, "
+               "which means the restyles we need to do for those changes "
+               "will be lost");
(along with the getter on nsPresContext), and then add calls to
nsPresContext::FlushPendingMediaFeatureValuesChanged in the appropriate
places (definitely on many of the methods in nsStyleSet, and likely
elsewhere).

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1848,18 +1848,16 @@ nsPresContext::PostRebuildAllStyleDataEv
   }
   RestyleManager()->PostRebuildAllStyleDataEvent(aExtraHint, aRestyleHint);
 }
 
 void
 nsPresContext::MediaFeatureValuesChanged(nsRestyleHint aRestyleHint,
                                          nsChangeHint aChangeHint)
 {
-  mPendingMediaFeatureValuesChanged = false;
-
   // MediumFeaturesChanged updates the applied rules, so it always gets called.
   if (mShell && mShell->StyleSet()->MediumFeaturesChanged(this)) {
     aRestyleHint |= eRestyle_Subtree;
   }
 
   if (mUsesViewportUnits && mPendingViewportChange) {
     // Rebuild all style data without rerunning selector matching.
     aRestyleHint |= eRestyle_ForceDescendants;
@@ -1913,42 +1911,16 @@ nsPresContext::MediaFeatureValuesChanged
         d.callback->Call(*d.mql, result);
       }
     }
 
     // NOTE:  When |notifyList| goes out of scope, our destructor could run.
   }
 }
 
-void
-nsPresContext::PostMediaFeatureValuesChangedEvent()
-{
-  // FIXME: We should probably replace this event with use of
-  // nsRefreshDriver::AddStyleFlushObserver (except the pres shell would
-  // need to track whether it's been added).
-  if (!mPendingMediaFeatureValuesChanged) {
-    nsCOMPtr<nsIRunnable> ev =
-      NS_NewRunnableMethod(this, &nsPresContext::HandleMediaFeatureValuesChangedEvent);
-    if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
-      mPendingMediaFeatureValuesChanged = true;
-      mDocument->SetNeedStyleFlush();
-    }
-  }
-}
-
-void
-nsPresContext::HandleMediaFeatureValuesChangedEvent()
-{
-  // Null-check mShell in case the shell has been destroyed (and the
-  // event is the only thing holding the pres context alive).
-  if (mPendingMediaFeatureValuesChanged && mShell) {
-    MediaFeatureValuesChanged(nsRestyleHint(0));
-  }
-}
-
 nsCompatibility
 nsPresContext::CompatibilityMode() const
 {
   return Document()->GetCompatibilityMode();
 }
 
 void
 nsPresContext::SetPaginatedScrolling(bool aPaginated)
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -275,22 +275,16 @@ public:
    *    rerunning of selector matching
    *
    * For aChangeHint, see RestyleManager::RebuildAllStyleData.  (Passing
    * a nonzero aChangeHint forces rebuilding style data even if
    * nsRestyleHint(0) is passed.)
    */
   void MediaFeatureValuesChanged(nsRestyleHint aRestyleHint,
                                  nsChangeHint aChangeHint = nsChangeHint(0));
-  void PostMediaFeatureValuesChangedEvent();
-  void HandleMediaFeatureValuesChangedEvent();
-  void FlushPendingMediaFeatureValuesChanged() {
-    if (mPendingMediaFeatureValuesChanged)
-      MediaFeatureValuesChanged(nsRestyleHint(0));
-  }
 
   /**
    * Access compatibility mode for this context.  This is the same as
    * our document's compatibility mode.
    */
   nsCompatibility CompatibilityMode() const;
 
   /**
@@ -464,17 +458,17 @@ public:
    * nscoord units (as scaled by the device context).
    */
   void SetVisibleArea(const nsRect& r) {
     if (!r.IsEqualEdges(mVisibleArea)) {
       mVisibleArea = r;
       // Visible area does not affect media queries when paginated.
       if (!IsPaginated() && HasCachedStyleData()) {
         mPendingViewportChange = true;
-        PostMediaFeatureValuesChangedEvent();
+        MediaFeatureValuesChanged();
       }
     }
   }
 
   /**
    * Return true if this presentation context is a paginated
    * context.
    */
@@ -1332,17 +1326,16 @@ protected:
   unsigned              mCanPaginatedScroll : 1;
   unsigned              mDoScaledTwips : 1;
   unsigned              mIsRootPaginatedDocument : 1;
   unsigned              mPrefBidiDirection : 1;
   unsigned              mPrefScrollbarSide : 2;
   unsigned              mPendingSysColorChanged : 1;
   unsigned              mPendingThemeChanged : 1;
   unsigned              mPendingUIResolutionChanged : 1;
-  unsigned              mPendingMediaFeatureValuesChanged : 1;
   unsigned              mPrefChangePendingNeedsReflow : 1;
   unsigned              mIsEmulatingMedia : 1;
   // True if the requests in mInvalidateRequestsSinceLastPaint cover the
   // entire viewport
   unsigned              mAllInvalidated : 1;
 
   // Are we currently drawing an SVG glyph?
   unsigned              mIsGlyph : 1;
