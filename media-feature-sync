From: L. David Baron <dbaron@dbaron.org>

Bug 1089417 patch 11 - Remove the ability to handle media feature value change asynchronously, which we only used at one caller (SetVisibleArea), and handle it synchronously.

I don't remember why this optimization was added, and it may not have
been based on a whole lot of evidence showing it was needed, given that
it was added in the initial implementation of media queries (bug 156716,
part 4).

If it turns out is needed, in order to make it work correctly, we need
to add this assertion in nsCSSRuleProcessor::GetRuleCascade :
+  NS_ASSERTION(!aPresContext->HasPendingMediaFeatureValuesChanged(),
+               "caller didn't flush pending media feature changes, "
+               "which means the restyles we need to do for those changes "
+               "will be lost");
(along with the getter on nsPresContext), and then add calls to
nsPresContext::FlushPendingMediaFeatureValuesChanged in the appropriate
places (definitely on many of the methods in nsStyleSet, and likely
elsewhere).

I've been unable to write an automated test for this, because I can't
figure out how to do a resize that causes the width/height media
features to change but doesn't cause a reflow and thus cause the
root scrollbars to immediately trigger HasAttributeDependentStyle.

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1848,34 +1848,25 @@ nsPresContext::PostRebuildAllStyleDataEv
   }
   RestyleManager()->PostRebuildAllStyleDataEvent(aExtraHint, aRestyleHint);
 }
 
 void
 nsPresContext::MediaFeatureValuesChanged(nsRestyleHint aRestyleHint,
                                          nsChangeHint aChangeHint)
 {
-  mPendingMediaFeatureValuesChanged = false;
-
   // MediumFeaturesChanged updates the applied rules, so it always gets called.
   if (mShell && mShell->StyleSet()->MediumFeaturesChanged(this)) {
     aRestyleHint |= eRestyle_Subtree;
   }
 
-  if (mUsesViewportUnits && mPendingViewportChange) {
-    // Rebuild all style data without rerunning selector matching.
-    aRestyleHint |= eRestyle_ForceDescendants;
-  }
-
   if (aRestyleHint || aChangeHint) {
     RebuildAllStyleData(aChangeHint, aRestyleHint);
   }
 
-  mPendingViewportChange = false;
-
   if (mDocument->IsBeingUsedAsImage()) {
     MOZ_ASSERT(PR_CLIST_IS_EMPTY(mDocument->MediaQueryLists()));
     return;
   }
 
   MOZ_ASSERT(nsContentUtils::IsSafeToRunScript());
 
   // Media query list listeners should be notified from a queued task
@@ -1913,42 +1904,16 @@ nsPresContext::MediaFeatureValuesChanged
         d.callback->Call(*d.mql, result);
       }
     }
 
     // NOTE:  When |notifyList| goes out of scope, our destructor could run.
   }
 }
 
-void
-nsPresContext::PostMediaFeatureValuesChangedEvent()
-{
-  // FIXME: We should probably replace this event with use of
-  // nsRefreshDriver::AddStyleFlushObserver (except the pres shell would
-  // need to track whether it's been added).
-  if (!mPendingMediaFeatureValuesChanged) {
-    nsCOMPtr<nsIRunnable> ev =
-      NS_NewRunnableMethod(this, &nsPresContext::HandleMediaFeatureValuesChangedEvent);
-    if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
-      mPendingMediaFeatureValuesChanged = true;
-      mDocument->SetNeedStyleFlush();
-    }
-  }
-}
-
-void
-nsPresContext::HandleMediaFeatureValuesChangedEvent()
-{
-  // Null-check mShell in case the shell has been destroyed (and the
-  // event is the only thing holding the pres context alive).
-  if (mPendingMediaFeatureValuesChanged && mShell) {
-    MediaFeatureValuesChanged(nsRestyleHint(0));
-  }
-}
-
 nsCompatibility
 nsPresContext::CompatibilityMode() const
 {
   return Document()->GetCompatibilityMode();
 }
 
 void
 nsPresContext::SetPaginatedScrolling(bool aPaginated)
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -275,22 +275,16 @@ public:
    *    rerunning of selector matching
    *
    * For aChangeHint, see RestyleManager::RebuildAllStyleData.  (Passing
    * a nonzero aChangeHint forces rebuilding style data even if
    * nsRestyleHint(0) is passed.)
    */
   void MediaFeatureValuesChanged(nsRestyleHint aRestyleHint,
                                  nsChangeHint aChangeHint = nsChangeHint(0));
-  void PostMediaFeatureValuesChangedEvent();
-  void HandleMediaFeatureValuesChangedEvent();
-  void FlushPendingMediaFeatureValuesChanged() {
-    if (mPendingMediaFeatureValuesChanged)
-      MediaFeatureValuesChanged(nsRestyleHint(0));
-  }
 
   /**
    * Access compatibility mode for this context.  This is the same as
    * our document's compatibility mode.
    */
   nsCompatibility CompatibilityMode() const;
 
   /**
@@ -463,18 +457,21 @@ public:
    * Set the currently visible area. The units for r are standard
    * nscoord units (as scaled by the device context).
    */
   void SetVisibleArea(const nsRect& r) {
     if (!r.IsEqualEdges(mVisibleArea)) {
       mVisibleArea = r;
       // Visible area does not affect media queries when paginated.
       if (!IsPaginated() && HasCachedStyleData()) {
-        mPendingViewportChange = true;
-        PostMediaFeatureValuesChangedEvent();
+        // If we use viewport units, rebuild all style data without
+        // rerunning selector matching.
+        nsRestyleHint hint =
+          mUsesViewportUnits ? eRestyle_ForceDescendants : nsRestyleHint(0);
+        MediaFeatureValuesChanged(hint);
       }
     }
   }
 
   /**
    * Return true if this presentation context is a paginated
    * context.
    */
@@ -1304,34 +1301,30 @@ protected:
   unsigned              mCanPaginatedScroll : 1;
   unsigned              mDoScaledTwips : 1;
   unsigned              mIsRootPaginatedDocument : 1;
   unsigned              mPrefBidiDirection : 1;
   unsigned              mPrefScrollbarSide : 2;
   unsigned              mPendingSysColorChanged : 1;
   unsigned              mPendingThemeChanged : 1;
   unsigned              mPendingUIResolutionChanged : 1;
-  unsigned              mPendingMediaFeatureValuesChanged : 1;
   unsigned              mPrefChangePendingNeedsReflow : 1;
   unsigned              mIsEmulatingMedia : 1;
   // True if the requests in mInvalidateRequestsSinceLastPaint cover the
   // entire viewport
   unsigned              mAllInvalidated : 1;
 
   // Are we currently drawing an SVG glyph?
   unsigned              mIsGlyph : 1;
 
   // Does the associated document use root-em (rem) units?
   unsigned              mUsesRootEMUnits : 1;
   // Does the associated document use viewport units (vw/vh/vmin/vmax)?
   unsigned              mUsesViewportUnits : 1;
 
-  // Has there been a change to the viewport's dimensions?
-  unsigned              mPendingViewportChange : 1;
-
   // Is the current mFontFaceSet valid?
   unsigned              mFontFaceSetDirty : 1;
   // Has GetUserFontSet() been called?
   unsigned              mGetUserFontSetCalled : 1;
   // Do we currently have an event posted to call FlushUserFontSet?
   unsigned              mPostedFlushUserFontSet : 1;
 
   // Is the current mCounterStyleManager valid?
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -4271,17 +4271,16 @@ PresShell::FlushPendingNotifications(moz
     // construct frames for content right now that's still waiting to be
     // notified on,
     mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
 
     // Process pending restyles, since any flush of the presshell wants
     // up-to-date style data.
     if (!mIsDestroying) {
       mViewManager->FlushDelayedResize(false);
-      mPresContext->FlushPendingMediaFeatureValuesChanged();
 
       // Flush any pending update of the user font set, since that could
       // cause style changes (for updating ex/ch units, and to cause a
       // reflow).
       mPresContext->FlushUserFontSet();
 
       mPresContext->FlushCounterStyles();
 
