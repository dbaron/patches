From: L. David Baron <dbaron@dbaron.org>

Bug 1125455 patch 2 - Set mWinsInCascade for transitions based on whether there are animations.  r=birtles

diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -736,16 +736,24 @@ AnimationPlayerCollection::EnsureStyleRu
 
     for (size_t playerIdx = mPlayers.Length(); playerIdx-- != 0; ) {
       mPlayers[playerIdx]->ComposeStyle(mStyleRule, properties,
                                         mNeedsRefreshes);
     }
   }
 
   mManager->CheckNeedsRefresh();
+
+  // If one of our animations just started or stopped filling, we need
+  // to notify the transition manager.  This does the notification a bit
+  // more than necessary, but it's easier than doing it exactly.
+  if (mManager->IsAnimationManager()) {
+    mManager->mPresContext->TransitionManager()->
+      UpdateCascadeResultsWithAnimations(this);
+  }
 }
 
 bool
 AnimationPlayerCollection::CanThrottleTransformChanges(TimeStamp aTime)
 {
   if (!nsLayoutUtils::AreAsyncAnimationsEnabled()) {
     return false;
   }
diff --git a/layout/style/AnimationCommon.h b/layout/style/AnimationCommon.h
--- a/layout/style/AnimationCommon.h
+++ b/layout/style/AnimationCommon.h
@@ -19,16 +19,17 @@
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/Nullable.h"
 #include "nsStyleStruct.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/FloatingPoint.h"
 #include "nsCSSPseudoElements.h"
 #include "nsCycleCollectionParticipant.h"
+#include "nsCSSPropertySet.h"
 
 class nsIFrame;
 class nsPresContext;
 class nsStyleChangeList;
 
 namespace mozilla {
 
 class RestyleTracker;
@@ -186,16 +187,24 @@ public:
     return &p->mValue;
   }
 
   struct PropertyValuePair {
     nsCSSProperty mProperty;
     mozilla::StyleAnimationValue mValue;
   };
 
+  void AddPropertiesToSet(nsCSSPropertySet& aSet) const
+  {
+    for (size_t i = 0, i_end = mPropertyValuePairs.Length(); i < i_end; ++i) {
+      const PropertyValuePair &cv = mPropertyValuePairs[i];
+      aSet.AddProperty(cv.mProperty);
+    }
+  }
+
 private:
   ~AnimValuesStyleRule() {}
 
   InfallibleTArray<PropertyValuePair> mPropertyValuePairs;
 };
 
 } /* end css sub-namespace */
 
@@ -319,16 +328,29 @@ struct AnimationPlayerCollection : publi
     if (IsForBeforePseudo()) {
       return NS_LITERAL_STRING("::before");
     }
     MOZ_ASSERT(IsForAfterPseudo(),
                "::before & ::after should be the only pseudo-elements here");
     return NS_LITERAL_STRING("::after");
   }
 
+  nsCSSPseudoElements::Type PseudoElementType() const
+  {
+    if (IsForElement()) {
+      return nsCSSPseudoElements::ePseudo_NotPseudoElement;
+    }
+    if (IsForBeforePseudo()) {
+      return nsCSSPseudoElements::ePseudo_before;
+    }
+    MOZ_ASSERT(IsForAfterPseudo(),
+               "::before & ::after should be the only pseudo-elements here");
+    return nsCSSPseudoElements::ePseudo_after;
+  }
+
   mozilla::dom::Element* GetElementToRestyle() const;
 
   void PostRestyleForAnimation(nsPresContext *aPresContext) {
     mozilla::dom::Element* element = GetElementToRestyle();
     if (element) {
       nsRestyleHint hint = IsForTransitions() ? eRestyle_CSSTransitions
                                               : eRestyle_CSSAnimations;
       aPresContext->PresShell()->RestyleForAnimation(element, hint);
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -267,16 +267,21 @@ nsAnimationManager::CheckAnimationRule(n
   dom::AnimationTimeline* timeline = aElement->OwnerDoc()->Timeline();
   AnimationPlayerPtrArray newPlayers;
   if (!aStyleContext->IsInDisplayNoneSubtree()) {
     BuildAnimations(aStyleContext, aElement, timeline, newPlayers);
   }
 
   if (newPlayers.IsEmpty()) {
     if (collection) {
+      // There might be transitions that run now that animations don't
+      // override them.
+      mPresContext->TransitionManager()->
+        UpdateCascadeResultsWithAnimationsToBeDestroyed(collection);
+
       collection->Destroy();
     }
     return nullptr;
   }
 
   if (collection) {
     collection->mStyleRule = nullptr;
     collection->mStyleRuleRefreshTime = TimeStamp();
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -342,16 +342,18 @@ nsTransitionManager::StyleContextChanged
       collection = nullptr;
     }
   }
 
   MOZ_ASSERT(!startedAny || collection,
              "must have element transitions if we started any transitions");
 
   if (collection) {
+    UpdateCascadeResultsWithTransitions(collection);
+
     // Set the style rule refresh time to null so that EnsureStyleRuleFor
     // creates a new style rule if we started *or* stopped transitions.
     collection->mStyleRuleRefreshTime = TimeStamp();
     collection->UpdateCheckGeneration(mPresContext);
     collection->mNeedsRefreshes = true;
     TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
     collection->EnsureStyleRuleFor(now, EnsureStyleRule_IsNotThrottled);
   }
@@ -595,16 +597,100 @@ nsTransitionManager::ConsiderStartingTra
     }
   }
   aElementTransitions->UpdateAnimationGeneration(mPresContext);
 
   *aStartedAny = true;
   aWhichStarted->AddProperty(aProperty);
 }
 
+void
+nsTransitionManager::UpdateCascadeResultsWithTransitions(
+                       AnimationPlayerCollection* aTransitions)
+{
+  AnimationPlayerCollection* animations =
+    mPresContext->AnimationManager()->
+      GetAnimationPlayers(aTransitions->mElement,
+                          aTransitions->PseudoElementType(), false);
+  UpdateCascadeResults(aTransitions, animations);
+}
+
+void
+nsTransitionManager::UpdateCascadeResultsWithAnimations(
+                       const AnimationPlayerCollection* aAnimations)
+{
+  AnimationPlayerCollection* transitions =
+    mPresContext->TransitionManager()->
+      GetAnimationPlayers(aAnimations->mElement,
+                          aAnimations->PseudoElementType(), false);
+  UpdateCascadeResults(transitions, aAnimations);
+}
+
+void
+nsTransitionManager::UpdateCascadeResultsWithAnimationsToBeDestroyed(
+                       const AnimationPlayerCollection* aAnimations)
+{
+  AnimationPlayerCollection* transitions =
+    mPresContext->TransitionManager()->
+      GetAnimationPlayers(aAnimations->mElement,
+                          aAnimations->PseudoElementType(), false);
+  UpdateCascadeResults(transitions, nullptr);
+}
+
+void
+nsTransitionManager::UpdateCascadeResults(
+                       AnimationPlayerCollection* aTransitions,
+                       const AnimationPlayerCollection* aAnimations)
+{
+  if (!aTransitions) {
+    // Nothing to do.
+    return;
+  }
+
+  nsCSSPropertySet propertiesUsed;
+#ifdef DEBUG
+  nsCSSPropertySet propertiesWithTransitions;
+#endif
+
+  // http://dev.w3.org/csswg/css-transitions/#application says that
+  // transitions do not apply when the same property has a CSS Animation
+  // on that element (even though animations are lower in the cascade).
+  if (aAnimations && aAnimations->mStyleRule) {
+    aAnimations->mStyleRule->AddPropertiesToSet(propertiesUsed);
+  }
+
+  // Since we should never have more than one transition for the same
+  // property, it doesn't matter what order we iterate the transitions.
+  // But let's go the same way as animations.
+  bool changed = false;
+  AnimationPlayerPtrArray& players = aTransitions->mPlayers;
+  for (size_t playerIdx = players.Length(); playerIdx-- != 0; ) {
+    MOZ_ASSERT(players[playerIdx]->GetSource() &&
+               players[playerIdx]->GetSource()->Properties().Length() == 1,
+               "Should have one animation property for a transition");
+    AnimationProperty& prop = players[playerIdx]->GetSource()->Properties()[0];
+    bool newWinsInCascade = !propertiesUsed.HasProperty(prop.mProperty);
+    if (prop.mWinsInCascade != newWinsInCascade) {
+      changed = true;
+    }
+    prop.mWinsInCascade = newWinsInCascade;
+    // assert that we don't need to bother adding the transitioned
+    // properties into propertiesUsed
+#ifdef DEBUG
+    MOZ_ASSERT(!propertiesWithTransitions.HasProperty(prop.mProperty),
+               "we're assuming we have only one transition per property");
+    propertiesWithTransitions.AddProperty(prop.mProperty);
+#endif
+  }
+
+  if (changed) {
+    aTransitions->UpdateAnimationGeneration(mPresContext);
+  }
+}
+
 /*
  * nsIStyleRuleProcessor implementation
  */
 
 /* virtual */ size_t
 nsTransitionManager::SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const
 {
   return CommonAnimationManager::SizeOfExcludingThis(aMallocSizeOf);
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
--- a/layout/style/nsTransitionManager.h
+++ b/layout/style/nsTransitionManager.h
@@ -123,16 +123,25 @@ public:
    * *aNewStyleContext) to cover up some of the changes for the duration
    * of the restyling of descendants.  If it does, this function will
    * take care of causing the necessary restyle afterwards.
    */
   void StyleContextChanged(mozilla::dom::Element *aElement,
                            nsStyleContext *aOldStyleContext,
                            nsRefPtr<nsStyleContext>* aNewStyleContext /* inout */);
 
+  void UpdateCascadeResultsWithTransitions(
+         AnimationPlayerCollection* aTransitions);
+  void UpdateCascadeResultsWithAnimations(
+         const AnimationPlayerCollection* aAnimations);
+  void UpdateCascadeResultsWithAnimationsToBeDestroyed(
+         const AnimationPlayerCollection* aAnimations);
+  void UpdateCascadeResults(AnimationPlayerCollection* aTransitions,
+                            const AnimationPlayerCollection* aAnimations);
+
   void SetInAnimationOnlyStyleUpdate(bool aInAnimationOnlyUpdate) {
     mInAnimationOnlyStyleUpdate = aInAnimationOnlyUpdate;
   }
 
   bool InAnimationOnlyStyleUpdate() const {
     return mInAnimationOnlyStyleUpdate;
   }
 
