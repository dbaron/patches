From: L. David Baron <dbaron@dbaron.org>

Bug 1277448 patch 2 - Pass __func__ to NS_DebugBreak and friends.  r?froydnj

This will allow them to print the function name in patches 3 and 4.

Note that this does not modify the nsIDebug interface, since that
requires finding relevant JS callers, some of which may be in
extensions.

MozReview-Commit-ID: 43XNc0aTJmM

diff --git a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
--- a/dom/ipc/ContentChild.cpp
+++ b/dom/ipc/ContentChild.cpp
@@ -624,17 +624,17 @@ ContentChild::SetProcessName(const nsASt
     printf_stderr("\n\nCHILDCHILDCHILDCHILD\n  [%s] debug me @%d\n\n", name,
                   getpid());
     sleep(30);
 #elif defined(OS_WIN)
     // Windows has a decent JIT debugging story, so NS_DebugBreak does the
     // right thing.
     NS_DebugBreak(NS_DEBUG_BREAK,
                  "Invoking NS_DebugBreak() to debug child process",
-                 nullptr, __FILE__, __LINE__);
+                 nullptr, __FILE__, __func__, __LINE__);
 #endif
   }
 
   mProcessName = aName;
   mozilla::ipc::SetThisProcessName(NS_LossyConvertUTF16toASCII(aName).get());
 
   if (aDontOverride) {
     mCanOverrideProcessName = false;
diff --git a/ipc/chromium/src/base/logging.cc b/ipc/chromium/src/base/logging.cc
--- a/ipc/chromium/src/base/logging.cc
+++ b/ipc/chromium/src/base/logging.cc
@@ -41,17 +41,17 @@ Logger::~Logger()
   case LOG_FATAL:
     prlevel = LogLevel::Error;
     xpcomlevel = NS_DEBUG_ABORT;
     break;
   }
 
   MOZ_LOG(gChromiumPRLog, prlevel, ("%s:%i: %s", mFile, mLine, mMsg ? mMsg : "<no message>"));
   if (xpcomlevel != -1)
-    NS_DebugBreak(xpcomlevel, mMsg, NULL, mFile, mLine);
+    NS_DebugBreak(xpcomlevel, mMsg, NULL, mFile, nullptr, mLine);
 
   mozilla::SmprintfFree(mMsg);
 }
 
 void
 Logger::printf(const char* fmt, ...)
 {
   va_list args;
diff --git a/layout/xul/nsBox.h b/layout/xul/nsBox.h
--- a/layout/xul/nsBox.h
+++ b/layout/xul/nsBox.h
@@ -112,16 +112,17 @@ private:
   //nscoord mX;
   //nscoord mY;
 };
 
 #ifdef DEBUG_LAYOUT
 #define NS_BOX_ASSERTION(box,expr,str) \
   if (!(expr)) { \
        box->XULDumpBox(stdout); \
-       NS_DebugBreak(NSDebugAssertion, str, #expr, __FILE__, __LINE__); \
+       NS_DebugBreak(NSDebugAssertion, str, #expr, \
+                     __FILE__, __func__, __LINE__); \
   }
 #else
 #define NS_BOX_ASSERTION(box,expr,str) {}
 #endif
 
 #endif
 
diff --git a/security/sandbox/chromium-shim/sandbox/win/loggingCallbacks.h b/security/sandbox/chromium-shim/sandbox/win/loggingCallbacks.h
--- a/security/sandbox/chromium-shim/sandbox/win/loggingCallbacks.h
+++ b/security/sandbox/chromium-shim/sandbox/win/loggingCallbacks.h
@@ -62,17 +62,18 @@ Log(const char* aMessageType,
                    &msgStream, 0, nullptr);
     }
   }
 
   std::string msg = msgStream.str();
 #if defined(DEBUG)
   // Use NS_DebugBreak directly as we want child process prefix, but not source
   // file or line number.
-  NS_DebugBreak(NS_DEBUG_WARNING, nullptr, msg.c_str(), nullptr, -1);
+  NS_DebugBreak(NS_DEBUG_WARNING, nullptr, msg.c_str(), nullptr,
+                aFunctionName, -1);
 #endif
 
   if (nsContentUtils::IsInitialized()) {
     nsContentUtils::LogMessageToConsole(msg.c_str());
   }
 
   // As we don't always have the facility to log to console use MOZ_LOG as well.
   LOG_D("%s", msg.c_str());
diff --git a/toolkit/components/downloads/nsDownloadManager.cpp b/toolkit/components/downloads/nsDownloadManager.cpp
--- a/toolkit/components/downloads/nsDownloadManager.cpp
+++ b/toolkit/components/downloads/nsDownloadManager.cpp
@@ -2650,17 +2650,18 @@ NS_IMETHODIMP nsDownload::SetRedirects(n
 
 #ifdef MOZ_ENABLE_GIO
 static void gio_set_metadata_done(GObject *source_obj, GAsyncResult *res, gpointer user_data)
 {
   GError *err = nullptr;
   g_file_set_attributes_finish(G_FILE(source_obj), res, nullptr, &err);
   if (err) {
 #ifdef DEBUG
-    NS_DebugBreak(NS_DEBUG_WARNING, "Set file metadata failed: ", err->message, __FILE__, __LINE__);
+    NS_DebugBreak(NS_DEBUG_WARNING, "Set file metadata failed: ", err->message,
+                  __FILE__, __func__, __LINE__);
 #endif
     g_error_free(err);
   }
 }
 #endif
 
 nsresult
 nsDownload::SetState(DownloadState aState)
diff --git a/toolkit/components/jsdownloads/src/DownloadPlatform.cpp b/toolkit/components/jsdownloads/src/DownloadPlatform.cpp
--- a/toolkit/components/jsdownloads/src/DownloadPlatform.cpp
+++ b/toolkit/components/jsdownloads/src/DownloadPlatform.cpp
@@ -61,17 +61,18 @@ DownloadPlatform* DownloadPlatform::GetD
 
 #ifdef MOZ_ENABLE_GIO
 static void gio_set_metadata_done(GObject *source_obj, GAsyncResult *res, gpointer user_data)
 {
   GError *err = nullptr;
   g_file_set_attributes_finish(G_FILE(source_obj), res, nullptr, &err);
   if (err) {
 #ifdef DEBUG
-    NS_DebugBreak(NS_DEBUG_WARNING, "Set file metadata failed: ", err->message, __FILE__, __LINE__);
+    NS_DebugBreak(NS_DEBUG_WARNING, "Set file metadata failed: ", err->message,
+                  __FILE__, __func__, __LINE__);
 #endif
     g_error_free(err);
   }
 }
 #endif
 
 #ifdef XP_MACOSX
 // Caller is responsible for freeing any result (CF Create Rule)
diff --git a/toolkit/xre/nsEmbedFunctions.cpp b/toolkit/xre/nsEmbedFunctions.cpp
--- a/toolkit/xre/nsEmbedFunctions.cpp
+++ b/toolkit/xre/nsEmbedFunctions.cpp
@@ -548,17 +548,17 @@ XRE_InitChildProcess(int aArgc,
     printf_stderr("\n\nCHILDCHILDCHILDCHILD\n  debug me @ %d\n\n",
                   base::GetCurrentProcId());
     sleep(GetDebugChildPauseTime());
   }
 #elif defined(OS_WIN)
   if (PR_GetEnv("MOZ_DEBUG_CHILD_PROCESS")) {
     NS_DebugBreak(NS_DEBUG_BREAK,
                   "Invoking NS_DebugBreak() to debug child process",
-                  nullptr, __FILE__, __LINE__);
+                  nullptr, __FILE__, __func__, __LINE__);
   } else if (PR_GetEnv("MOZ_DEBUG_CHILD_PAUSE")) {
     printf_stderr("\n\nCHILDCHILDCHILDCHILD\n  debug me @ %d\n\n",
                   base::GetCurrentProcId());
     ::Sleep(GetDebugChildPauseTime());
   }
 #endif
 
   // child processes launched by GeckoChildProcessHost get this magic
diff --git a/toolkit/xre/nsSigHandlers.cpp b/toolkit/xre/nsSigHandlers.cpp
--- a/toolkit/xre/nsSigHandlers.cpp
+++ b/toolkit/xre/nsSigHandlers.cpp
@@ -132,33 +132,36 @@ my_glib_log_func(const gchar *log_domain
                  const gchar *message, gpointer user_data);
 }
 
 /* static */ void
 my_glib_log_func(const gchar *log_domain, GLogLevelFlags log_level,
                  const gchar *message, gpointer user_data)
 {
   if (log_level & (G_LOG_LEVEL_ERROR | G_LOG_FLAG_FATAL | G_LOG_FLAG_RECURSION)) {
-    NS_DebugBreak(NS_DEBUG_ASSERTION, message, "glib assertion", __FILE__, __LINE__);
+    NS_DebugBreak(NS_DEBUG_ASSERTION, message, "glib assertion",
+                  __FILE__, __func__, __LINE__);
   } else if (log_level & (G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING)) {
-    NS_DebugBreak(NS_DEBUG_WARNING, message, "glib warning", __FILE__, __LINE__);
+    NS_DebugBreak(NS_DEBUG_WARNING, message, "glib warning",
+                  __FILE__, __func__, __LINE__);
   }
 
   orig_log_func(log_domain, log_level, message, nullptr);
 }
 
 #endif
 
 #ifdef SA_SIGINFO
 static void fpehandler(int signum, siginfo_t *si, void *context)
 {
   /* Integer divide by zero or integer overflow. */
   /* Note: FPE_INTOVF is ignored on Intel, PowerPC and SPARC systems. */
   if (si->si_code == FPE_INTDIV || si->si_code == FPE_INTOVF) {
-    NS_DebugBreak(NS_DEBUG_ABORT, "Divide by zero", nullptr, __FILE__, __LINE__);
+    NS_DebugBreak(NS_DEBUG_ABORT, "Divide by zero", nullptr,
+                  __FILE__, __func__, __LINE__);
   }
 
 #ifdef XP_MACOSX
   ucontext_t *uc = (ucontext_t *)context;
 
 #if defined(__i386__) || defined(__amd64__)
   _STRUCT_FP_CONTROL *ctrl = &uc->uc_mcontext->__fs.__fpu_fcw;
   ctrl->__invalid = ctrl->__denorm = ctrl->__zdiv = ctrl->__ovrfl = ctrl->__undfl = ctrl->__precis = 1;
diff --git a/xpcom/base/nsDebug.h b/xpcom/base/nsDebug.h
--- a/xpcom/base/nsDebug.h
+++ b/xpcom/base/nsDebug.h
@@ -45,25 +45,26 @@
  *
  *   NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), "operation failed");
  *
  * @note This is C++-only
  */
 #ifdef __cplusplus
 #ifdef DEBUG
 inline MOZ_MUST_USE bool NS_warn_if_impl(bool aCondition, const char* aExpr,
-                                         const char* aFile, int32_t aLine)
+                                         const char* aFile,
+                                         const char* aFunction, int32_t aLine)
 {
   if (MOZ_UNLIKELY(aCondition)) {
-    NS_DebugBreak(NS_DEBUG_WARNING, nullptr, aExpr, aFile, aLine);
+    NS_DebugBreak(NS_DEBUG_WARNING, nullptr, aExpr, aFile, aFunction, aLine);
   }
   return aCondition;
 }
 #define NS_WARN_IF(condition) \
-  NS_warn_if_impl(condition, #condition, __FILE__, __LINE__)
+  NS_warn_if_impl(condition, #condition, __FILE__, __func__, __LINE__)
 #else
 #define NS_WARN_IF(condition) (bool)(condition)
 #endif
 #endif
 
 /**
  * Test an assertion for truth. If the expression is not true then
  * emit a warning.
@@ -72,17 +73,18 @@ inline MOZ_MUST_USE bool NS_warn_if_impl
  *
  * Note also that the non-debug version of this macro does <b>not</b>
  * evaluate the message argument.
  */
 #ifdef DEBUG
 #define NS_WARNING_ASSERTION(_expr, _msg)                     \
   do {                                                        \
     if (!(_expr)) {                                           \
-      NS_DebugBreak(NS_DEBUG_WARNING, _msg, #_expr, __FILE__, __LINE__); \
+      NS_DebugBreak(NS_DEBUG_WARNING, _msg, #_expr,           \
+                    __FILE__, __func__, __LINE__);            \
     }                                                         \
   } while(0)
 #else
 #define NS_WARNING_ASSERTION(_expr, _msg)  do { /* nothing */ } while(0)
 #endif
 
 /**
  * Test an assertion for truth. If the expression is not true then
@@ -92,18 +94,19 @@ inline MOZ_MUST_USE bool NS_warn_if_impl
  * evaluate the message argument.
  */
 #ifdef DEBUG
 inline void MOZ_PretendNoReturn()
   MOZ_PRETEND_NORETURN_FOR_STATIC_ANALYSIS {}
 #define NS_ASSERTION(expr, str)                               \
   do {                                                        \
     if (!(expr)) {                                            \
-      NS_DebugBreak(NS_DEBUG_ASSERTION, str, #expr, __FILE__, __LINE__); \
-      MOZ_PretendNoReturn();                                         \
+      NS_DebugBreak(NS_DEBUG_ASSERTION, str, #expr,           \
+                    __FILE__, __func__, __LINE__);            \
+      MOZ_PretendNoReturn();                                  \
     }                                                         \
   } while(0)
 #else
 #define NS_ASSERTION(expr, str)        do { /* nothing */ } while(0)
 #endif
 
 /**
  * NS_PRECONDITION/POSTCONDITION are synonyms for NS_ASSERTION.
@@ -113,82 +116,88 @@ inline void MOZ_PretendNoReturn()
 
 /**
  * This macros triggers a program failure if executed. It indicates that
  * an attempt was made to execute some unimplemented functionality.
  */
 #ifdef DEBUG
 #define NS_NOTYETIMPLEMENTED(str)                             \
   do {                                                        \
-    NS_DebugBreak(NS_DEBUG_ASSERTION, str, "NotYetImplemented", __FILE__, __LINE__); \
+    NS_DebugBreak(NS_DEBUG_ASSERTION, str, "NotYetImplemented", \
+                  __FILE__, __func__, __LINE__);              \
     MOZ_PretendNoReturn();                                    \
   } while(0)
 #else
 #define NS_NOTYETIMPLEMENTED(str)      do { /* nothing */ } while(0)
 #endif
 
 /**
  * This macros triggers a program failure if executed. It indicates that
  * an attempt was made to execute a codepath which should not be reachable.
  */
 #ifdef DEBUG
 #define NS_NOTREACHED(str)                                    \
   do {                                                        \
-    NS_DebugBreak(NS_DEBUG_ASSERTION, str, "Not Reached", __FILE__, __LINE__); \
+    NS_DebugBreak(NS_DEBUG_ASSERTION, str, "Not Reached",     \
+                  __FILE__, __func__, __LINE__);              \
     MOZ_PretendNoReturn();                                    \
   } while(0)
 #else
 #define NS_NOTREACHED(str)             do { /* nothing */ } while(0)
 #endif
 
 /**
  * Log an error message.
  */
 #ifdef DEBUG
 #define NS_ERROR(str)                                         \
   do {                                                        \
-    NS_DebugBreak(NS_DEBUG_ASSERTION, str, "Error", __FILE__, __LINE__); \
+    NS_DebugBreak(NS_DEBUG_ASSERTION, str, "Error",           \
+                  __FILE__, __func__, __LINE__);              \
     MOZ_PretendNoReturn();                                    \
   } while(0)
 #else
 #define NS_ERROR(str)                  do { /* nothing */ } while(0)
 #endif
 
 /**
  * Log a warning message.
  */
 #ifdef DEBUG
 #define NS_WARNING(str)                                       \
-  NS_DebugBreak(NS_DEBUG_WARNING, str, nullptr, __FILE__, __LINE__)
+  NS_DebugBreak(NS_DEBUG_WARNING, str, nullptr,               \
+                __FILE__, __func__, __LINE__)
 #else
 #define NS_WARNING(str)                do { /* nothing */ } while(0)
 #endif
 
 /**
  * Trigger an debug-only abort.
  *
  * @see NS_RUNTIMEABORT for release-mode asserts.
  */
 #ifdef DEBUG
 #define NS_ABORT()                                            \
   do {                                                        \
-    NS_DebugBreak(NS_DEBUG_ABORT, nullptr, nullptr, __FILE__, __LINE__); \
+    NS_DebugBreak(NS_DEBUG_ABORT, nullptr, nullptr,           \
+                  __FILE__, __func__, __LINE__);              \
     MOZ_PretendNoReturn();                                    \
   } while(0)
 #else
 #define NS_ABORT()                     do { /* nothing */ } while(0)
 #endif
 
 /**
  * Trigger a debugger breakpoint, only in debug builds.
  */
 #ifdef DEBUG
 #define NS_BREAK()                                            \
   do {                                                        \
-    NS_DebugBreak(NS_DEBUG_BREAK, nullptr, nullptr, __FILE__, __LINE__); \
+    NS_DebugBreak(NS_DEBUG_BREAK, nullptr, nullptr,           \
+                  __FILE__, __func__, __LINE__);              \
     MOZ_PretendNoReturn();                                    \
   } while(0)
 #else
 #define NS_BREAK()                     do { /* nothing */ } while(0)
 #endif
 
 /******************************************************************************
 ** Macros for static assertions.  These are used by the sixgill tool.
@@ -248,17 +257,18 @@ inline void MOZ_PretendNoReturn()
 ******************************************************************************/
 
 /**
  * Terminate execution <i>immediately</i>, and if possible on the current
  * platform, in such a way that execution can't be continued by other
  * code (e.g., by intercepting a signal).
  */
 #define NS_RUNTIMEABORT(msg)                                    \
-  NS_DebugBreak(NS_DEBUG_ABORT, msg, nullptr, __FILE__, __LINE__)
+  NS_DebugBreak(NS_DEBUG_ABORT, msg, nullptr,                   \
+                __FILE__, __func__, __LINE__)
 
 
 /* Macros for checking the trueness of an expression passed in within an
  * interface implementation.  These need to be compiled regardless of the
  * DEBUG flag. New code should use NS_WARN_IF(condition) instead!
  * @status deprecated
  */
 
diff --git a/xpcom/base/nsDebugImpl.cpp b/xpcom/base/nsDebugImpl.cpp
--- a/xpcom/base/nsDebugImpl.cpp
+++ b/xpcom/base/nsDebugImpl.cpp
@@ -118,38 +118,44 @@ nsDebugImpl::Release()
 {
   return 1;
 }
 
 NS_IMETHODIMP
 nsDebugImpl::Assertion(const char* aStr, const char* aExpr,
                        const char* aFile, int32_t aLine)
 {
-  NS_DebugBreak(NS_DEBUG_ASSERTION, aStr, aExpr, aFile, aLine);
+  // NOTE: We should perhaps add an aFunction parameter to the nsIDebug
+  // methods, but it doesn't currently seem worthwhile, since it requires
+  // finding all JS callers, including those in extensions.
+  NS_DebugBreak(NS_DEBUG_ASSERTION, aStr, aExpr, aFile, nullptr, aLine);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDebugImpl::Warning(const char* aStr, const char* aFile, int32_t aLine)
 {
-  NS_DebugBreak(NS_DEBUG_WARNING, aStr, nullptr, aFile, aLine);
+  // NOTE: See nsDebugImpl::Assertion above.
+  NS_DebugBreak(NS_DEBUG_WARNING, aStr, nullptr, aFile, nullptr, aLine);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDebugImpl::Break(const char* aFile, int32_t aLine)
 {
-  NS_DebugBreak(NS_DEBUG_BREAK, nullptr, nullptr, aFile, aLine);
+  // NOTE: See nsDebugImpl::Assertion above.
+  NS_DebugBreak(NS_DEBUG_BREAK, nullptr, nullptr, aFile, nullptr, aLine);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDebugImpl::Abort(const char* aFile, int32_t aLine)
 {
-  NS_DebugBreak(NS_DEBUG_ABORT, nullptr, nullptr, aFile, aLine);
+  // NOTE: See nsDebugImpl::Assertion above.
+  NS_DebugBreak(NS_DEBUG_ABORT, nullptr, nullptr, aFile, nullptr, aLine);
   return NS_OK;
 }
 
 // From toolkit/library/rust/lib.rs
 extern "C" void intentional_panic(const char* message);
 
 NS_IMETHODIMP
 nsDebugImpl::RustPanic(const char* aMessage)
@@ -305,17 +311,17 @@ FixedBuffer::append(const char* aBuf, si
     buffer[curlen] = '\0';
   }
 
   return true;
 }
 
 EXPORT_XPCOM_API(void)
 NS_DebugBreak(uint32_t aSeverity, const char* aStr, const char* aExpr,
-              const char* aFile, int32_t aLine)
+              const char* aFile, const char* aFunction, int32_t aLine)
 {
   FixedBuffer nonPIDBuf;
   FixedBuffer buf;
   const char* sevString = "WARNING";
 
   switch (aSeverity) {
     case NS_DEBUG_ASSERTION:
       sevString = "###!!! ASSERTION";
diff --git a/xpcom/build/nsXPCOM.h b/xpcom/build/nsXPCOM.h
--- a/xpcom/build/nsXPCOM.h
+++ b/xpcom/build/nsXPCOM.h
@@ -245,21 +245,23 @@ enum
  * environment variable, this function may cause the application to
  * print the warning, print a stacktrace, break into a debugger, or abort
  * immediately.
  *
  * @param aSeverity A NS_DEBUG_* value
  * @param aStr   A readable error message (ASCII, may be null)
  * @param aExpr  The expression evaluated (may be null)
  * @param aFile  The source file containing the assertion (may be null)
+ * @param aFile  The source function containing the assertion (may be null)
  * @param aLine  The source file line number (-1 indicates no line number)
  */
 XPCOM_API(void) NS_DebugBreak(uint32_t aSeverity,
                               const char* aStr, const char* aExpr,
-                              const char* aFile, int32_t aLine);
+                              const char* aFile, const char* aFunction,
+                              int32_t aLine);
 
 /**
  * Perform a stack-walk to a debugging log under various
  * circumstances. Used to aid debugging of leaked object graphs.
  *
  * The NS_Log* functions are available in both debug and release
  * builds of XPCOM, but the output will be useless unless binary
  * debugging symbols for all modules in the stacktrace are available.
