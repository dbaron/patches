From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Remove the cover rule code, which became unused in the previous patch.

FIXME: Remove modifications to it lower in patch queue!

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -221,32 +221,16 @@ nsTransitionManager::StyleContextChanged
     nsStyleSet* styleSet = mPresContext->StyleSet();
     afterChangeStyle =
       styleSet->ResolveStyleWithoutAnimation(aElement, newStyleContext,
                                              eRestyle_CSSTransitions);
   } else {
     afterChangeStyle = newStyleContext;
   }
 
-  // Here we need to produce a style rule (called the cover rule) that,
-  // when added to the after-change style defined in
-  // http://dev.w3.org/csswg/css-transitions/#starting (actually, the
-  // after-change style but with already-running transitions included),
-  // we produce the after-transition style.  This is needed to get
-  // correct behavior for both starting and stopping transitions on
-  // descendants.
-  //
-  // This requires that we cover any styles that started or stopped
-  // during this style change with the styles from afterChangeStyle.
-  //
-  // Our caller is responsible for restyling again using this covering
-  // rule.
-
-  nsRefPtr<css::AnimValuesStyleRule> coverRule = new css::AnimValuesStyleRule;
-
   // Per http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html
   // I'll consider only the transitions from the number of items in
   // 'transition-property' on down, and later ones will override earlier
   // ones (tracked using |whichStarted|).
   bool startedAny = false;
   nsCSSPropertySet whichStarted;
   for (uint32_t i = disp->mTransitionPropertyCount; i-- != 0; ) {
     const StyleTransition& t = disp->mTransitions[i];
@@ -263,29 +247,29 @@ nsTransitionManager::StyleContextChanged
           property == eCSSProperty_UNKNOWN) {
         // Nothing to do, but need to exclude this from cases below.
       } else if (property == eCSSPropertyExtra_all_properties) {
         for (nsCSSProperty p = nsCSSProperty(0);
              p < eCSSProperty_COUNT_no_shorthands;
              p = nsCSSProperty(p + 1)) {
           ConsiderStartingTransition(p, t, aElement, collection,
                                      aOldStyleContext, afterChangeStyle,
-                                     &startedAny, &whichStarted, coverRule);
+                                     &startedAny, &whichStarted);
         }
       } else if (nsCSSProps::IsShorthand(property)) {
         CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(
             subprop, property, nsCSSProps::eEnabledForAllContent) {
           ConsiderStartingTransition(*subprop, t, aElement, collection,
                                      aOldStyleContext, afterChangeStyle,
-                                     &startedAny, &whichStarted, coverRule);
+                                     &startedAny, &whichStarted);
         }
       } else {
         ConsiderStartingTransition(property, t, aElement, collection,
                                    aOldStyleContext, afterChangeStyle,
-                                   &startedAny, &whichStarted, coverRule);
+                                   &startedAny, &whichStarted);
       }
     }
   }
 
   // Stop any transitions for properties that are no longer in
   // 'transition-property'.
   // Also stop any transitions for properties that just changed (and are
   // still in the set of properties to transition), but we didn't just
@@ -384,18 +368,17 @@ void
 nsTransitionManager::ConsiderStartingTransition(
   nsCSSProperty aProperty,
   const StyleTransition& aTransition,
   dom::Element* aElement,
   AnimationPlayerCollection*& aElementTransitions,
   nsStyleContext* aOldStyleContext,
   nsStyleContext* aNewStyleContext,
   bool* aStartedAny,
-  nsCSSPropertySet* aWhichStarted,
-  css::AnimValuesStyleRule* aCoverRule)
+  nsCSSPropertySet* aWhichStarted)
 {
   // IsShorthand itself will assert if aProperty is not a property.
   NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(aProperty),
                     "property out of range");
   NS_ASSERTION(!aElementTransitions ||
                aElementTransitions->mElement == aElement, "Element mismatch");
 
   if (aWhichStarted->HasProperty(aProperty)) {
@@ -597,18 +580,16 @@ nsTransitionManager::ConsiderStartingTra
   } else {
     if (!players.AppendElement(player)) {
       NS_WARNING("out of memory");
       return;
     }
   }
   aElementTransitions->UpdateAnimationGeneration(mPresContext);
 
-  aCoverRule->AddValue(aProperty, startValue);
-
   *aStartedAny = true;
   aWhichStarted->AddProperty(aProperty);
 }
 
 /*
  * nsIStyleRuleProcessor implementation
  */
 
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
--- a/layout/style/nsTransitionManager.h
+++ b/layout/style/nsTransitionManager.h
@@ -157,15 +157,14 @@ private:
   void
   ConsiderStartingTransition(nsCSSProperty aProperty,
                              const mozilla::StyleTransition& aTransition,
                              mozilla::dom::Element* aElement,
                              AnimationPlayerCollection*& aElementTransitions,
                              nsStyleContext* aOldStyleContext,
                              nsStyleContext* aNewStyleContext,
                              bool* aStartedAny,
-                             nsCSSPropertySet* aWhichStarted,
-                             mozilla::css::AnimValuesStyleRule* aCoverRule);
+                             nsCSSPropertySet* aWhichStarted);
 
   bool mInAnimationOnlyStyleUpdate;
 };
 
 #endif /* !defined(nsTransitionManager_h_) */
