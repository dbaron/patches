From: L. David Baron <dbaron@dbaron.org>

Add method to munge the content state appropriately for how we're matching so that matching operations in HTML and CSS style sheets follow the new rules.  (Bug 147777)

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1108,18 +1108,20 @@ RuleProcessorData::ContentState()
     mContentState = 0;
     if (mPresContext) {
       mPresContext->EventStateManager()->GetContentState(mContent,
                                                          mContentState);
     } else {
       mContentState = mContent->IntrinsicState();
     }
 
-    // If we are not supposed to mark visited links as such, be sure to flip the
-    // bits appropriately.
+    // If we are not supposed to mark visited links as such, be sure to
+    // flip the bits appropriately.  We want to do this here, rather
+    // than in GetContentStateForVisitedHandling, so that we don't
+    // expose that :visited support is disabled to the Web page.
     if ((!gSupportVisitedPseudo ||
         gPrivateBrowsingObserver->InPrivateBrowsing()) &&
         (mContentState & NS_EVENT_STATE_VISITED)) {
       mContentState = (mContentState & ~PRUint32(NS_EVENT_STATE_VISITED)) |
                       NS_EVENT_STATE_UNVISITED;
     }
   }
   return mContentState;
@@ -1133,16 +1135,45 @@ RuleProcessorData::DocumentState()
 
 PRBool
 RuleProcessorData::IsLink()
 {
   PRUint32 state = ContentState();
   return (state & (NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED)) != 0;
 }
 
+PRUint32
+RuleProcessorData::GetContentStateForVisitedHandling(
+                     nsRuleWalker::VisitedHandlingType aVisitedHandling,
+                     PRBool aIsRelevantLink)
+{
+  PRUint32 contentState = ContentState();
+  if (contentState & (NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED)) {
+    NS_ABORT_IF_FALSE(IsLink(), "IsLink() should match state");
+    contentState &=
+      ~PRUint32(NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED);
+    if (aIsRelevantLink) {
+      switch (aVisitedHandling) {
+        case nsRuleWalker::eRelevantLinkUnvisited:
+          contentState |= NS_EVENT_STATE_UNVISITED;
+          break;
+        case nsRuleWalker::eRelevantLinkVisited:
+          contentState |= NS_EVENT_STATE_VISITED;
+          break;
+        case nsRuleWalker::eLinksVisitedOrUnvisited:
+          contentState |= NS_EVENT_STATE_UNVISITED | NS_EVENT_STATE_VISITED;
+          break;
+      }
+    } else {
+      contentState |= NS_EVENT_STATE_UNVISITED;
+    }
+  }
+  return contentState;
+}
+
 PRInt32
 RuleProcessorData::GetNthIndex(PRBool aIsOfType, PRBool aIsFromEnd,
                                PRBool aCheckEdgeOnly)
 {
   NS_ASSERTION(mParentContent, "caller should check mParentContent");
   NS_ASSERTION(!mPreviousSiblingData ||
                mPreviousSiblingData->mContent->IsNodeOfType(nsINode::eELEMENT),
                "Unexpected previous sibling data");
@@ -2007,17 +2038,20 @@ static PRBool SelectorMatches(RuleProces
         // In quirks mode, only make certain elements sensitive to
         // selectors ":hover" and ":active".
         return PR_FALSE;
       } else {
         if (aNodeMatchContext.mStateMask & statesToCheck) {
           if (aDependence)
             *aDependence = PR_TRUE;
         } else {
-          if (!(data.ContentState() & statesToCheck)) {
+          PRUint32 contentState = data.GetContentStateForVisitedHandling(
+                                    aTreeMatchContext.mVisitedHandling,
+                                    aNodeMatchContext.mIsRelevantLink);
+          if (!(contentState & statesToCheck)) {
             return PR_FALSE;
           }
         }
       }
     }
   }
 
   PRBool result = PR_TRUE;
diff --git a/layout/style/nsHTMLStyleSheet.cpp b/layout/style/nsHTMLStyleSheet.cpp
--- a/layout/style/nsHTMLStyleSheet.cpp
+++ b/layout/style/nsHTMLStyleSheet.cpp
@@ -233,17 +233,21 @@ nsHTMLStyleSheet::RulesMatching(ElementR
   if (content) {
     nsRuleWalker *ruleWalker = aData->mRuleWalker;
     if (aData->mIsHTMLContent) {
       nsIAtom* tag = aData->mContentTag;
 
       // if we have anchor colors, check if this is an anchor with an href
       if (tag == nsGkAtoms::a) {
         if (mLinkRule || mVisitedRule || mActiveRule) {
-          PRUint32 state = aData->ContentState();
+          PRUint32 state = aData->GetContentStateForVisitedHandling(
+                                    ruleWalker->VisitedHandling(),
+                                    // If the node being matched is a link,
+                                    // it's the relevant link.
+                                    aData->IsLink());
           if (mLinkRule && (state & NS_EVENT_STATE_UNVISITED)) {
             ruleWalker->Forward(mLinkRule);
             ruleWalker->SetHaveRelevantLink();
           }
           else if (mVisitedRule && (state & NS_EVENT_STATE_VISITED)) {
             ruleWalker->Forward(mVisitedRule);
             ruleWalker->SetHaveRelevantLink();
           }
diff --git a/layout/style/nsRuleProcessorData.h b/layout/style/nsRuleProcessorData.h
--- a/layout/style/nsRuleProcessorData.h
+++ b/layout/style/nsRuleProcessorData.h
@@ -44,22 +44,22 @@
 #ifndef nsRuleProcessorData_h_
 #define nsRuleProcessorData_h_
 
 #include "nsPresContext.h" // for nsCompatability
 #include "nsString.h"
 #include "nsChangeHint.h"
 #include "nsIContent.h"
 #include "nsCSSPseudoElements.h"
+#include "nsRuleWalker.h"
 
 class nsIStyleSheet;
 class nsPresContext;
 class nsIAtom;
 class nsICSSPseudoComparator;
-class nsRuleWalker;
 class nsAttrValue;
 
 // The implementation of the constructor and destructor are currently in
 // nsCSSRuleProcessor.cpp.
 
 struct RuleProcessorData {
   RuleProcessorData(nsPresContext* aPresContext,
                     nsIContent* aContent, 
@@ -106,16 +106,20 @@ private:
     return ::operator new(sz);
   }
 public:
   const nsString* GetLang();
   PRUint32 ContentState();
   PRUint32 DocumentState();
   PRBool IsLink();
 
+  PRUint32 GetContentStateForVisitedHandling(
+             nsRuleWalker::VisitedHandlingType aVisitedHandling,
+             PRBool aIsRelevantLink);
+
   // Returns a 1-based index of the child in its parent.  If the child
   // is not in its parent's child list (i.e., it is anonymous content),
   // returns 0.
   // If aCheckEdgeOnly is true, the function will return 1 if the result
   // is 1, and something other than 1 (maybe or maybe not a valid
   // result) otherwise.
   PRInt32 GetNthIndex(PRBool aIsOfType, PRBool aIsFromEnd,
                       PRBool aCheckEdgeOnly);
@@ -149,16 +153,18 @@ private:
   // If 0, the node is not at any index in its parent.
   // The first subscript is 0 for -child and 1 for -of-type, the second
   // subscript is 0 for nth- and 1 for nth-last-.
   PRInt32 mNthIndices[2][2];
 
   // mContentState is initialized lazily.
   PRInt32 mContentState;  // eventStateMgr->GetContentState() or
                           // mContent->IntrinsicState() if we have no ESM
+                          // adjusted for not supporting :visited (but with
+                          // visitedness information when we support it)
   PRPackedBool mGotContentState;
 };
 
 struct ElementRuleProcessorData : public RuleProcessorData {
   ElementRuleProcessorData(nsPresContext* aPresContext,
                            nsIContent* aContent, 
                            nsRuleWalker* aRuleWalker)
   : RuleProcessorData(aPresContext,aContent,aRuleWalker)
