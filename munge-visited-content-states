From: L. David Baron <dbaron@dbaron.org>

Munge the content state appropriately for how we're matching so that matching operations in HTML and CSS style sheets follow the new rules.  (Bug 147777)

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1106,23 +1106,43 @@ RuleProcessorData::ContentState()
     mContentState = 0;
     if (mPresContext) {
       mPresContext->EventStateManager()->GetContentState(mContent,
                                                          mContentState);
     } else {
       mContentState = mContent->IntrinsicState();
     }
 
-    // If we are not supposed to mark visited links as such, be sure to flip the
-    // bits appropriately.
-    if ((!gSupportVisitedPseudo ||
-        gPrivateBrowsingObserver->InPrivateBrowsing()) &&
-        (mContentState & NS_EVENT_STATE_VISITED)) {
-      mContentState = (mContentState & ~PRUint32(NS_EVENT_STATE_VISITED)) |
-                      NS_EVENT_STATE_UNVISITED;
+    if (mContentState & (NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED)) {
+      // FIXME: Write comments!
+
+      mContentState &=
+        ~PRUint32(NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED);
+
+      // If we are not supposed to mark visited links as such, be sure
+      // to flip the bits appropriately.
+      if (!gSupportVisitedPseudo ||
+          gPrivateBrowsingObserver->InPrivateBrowsing()) {
+        // We *could* implement this pref significantly more efficiently
+        // by never creating the StyleIfVisited or setting
+        // NS_STYLE_RELEVANT_LINK_VISITED, but this should do for now.
+        mContentState |= NS_EVENT_STATE_UNVISITED;
+      } else {
+        switch (mVisitedHandling) {
+          case RuleProcessorData::eRelevantLinkUnvisited:
+            mContentState |= NS_EVENT_STATE_UNVISITED;
+            break;
+          case RuleProcessorData::eRelevantLinkVisited:
+            mContentState |= NS_EVENT_STATE_VISITED;
+            break;
+          case RuleProcessorData::eLinksVisitedOrUnvisited:
+            mContentState |= NS_EVENT_STATE_UNVISITED | NS_EVENT_STATE_VISITED;
+            break;
+        }
+      }
     }
   }
   return mContentState;
 }
 
 PRBool
 RuleProcessorData::IsLink()
 {
diff --git a/layout/style/nsRuleProcessorData.h b/layout/style/nsRuleProcessorData.h
--- a/layout/style/nsRuleProcessorData.h
+++ b/layout/style/nsRuleProcessorData.h
@@ -174,16 +174,17 @@ private:
   // If 0, the node is not at any index in its parent.
   // The first subscript is 0 for -child and 1 for -of-type, the second
   // subscript is 0 for nth- and 1 for nth-last-.
   PRInt32 mNthIndices[2][2];
 
   // mContentState, mLinkState, mIsLink are initialized lazily.
   PRInt32 mContentState;  // eventStateMgr->GetContentState() or
                           // mContent->IntrinsicState() if we have no ESM
+                          // plus adjustments for visited/unvisited links
   PRPackedBool mGotContentState;
 };
 
 struct ElementRuleProcessorData : public RuleProcessorData {
   ElementRuleProcessorData(nsPresContext* aPresContext,
                            nsIContent* aContent, 
                            nsRuleWalker* aRuleWalker,
                            VisitedHandling aVisitedHandling)
