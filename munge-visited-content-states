From: L. David Baron <dbaron@dbaron.org>

Munge the content state appropriately for how we're matching so that matching operations in HTML and CSS style sheets follow the new rules.  (Bug 147777)  (FIXME:  Need to figure out how to propagate out the found-a-relevant-link information.)

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1108,23 +1108,43 @@ RuleProcessorData::ContentState()
       mPresContext->EventStateManager()->GetContentState(mContent,
                                                          mContentState);
     } else {
       mContentState = mContent->IntrinsicState();
     }
 
     mReallyVisited = (mContentState & NS_EVENT_STATE_VISITED) != 0;
 
-    // If we are not supposed to mark visited links as such, be sure to flip the
-    // bits appropriately.
-    if ((!gSupportVisitedPseudo ||
-        gPrivateBrowsingObserver->InPrivateBrowsing()) &&
-        (mContentState & NS_EVENT_STATE_VISITED)) {
-      mContentState = (mContentState & ~PRUint32(NS_EVENT_STATE_VISITED)) |
-                      NS_EVENT_STATE_UNVISITED;
+    if (mContentState & (NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED)) {
+      // FIXME: Write comments!
+
+      mContentState &=
+        ~PRUint32(NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED);
+
+      // If we are not supposed to mark visited links as such, be sure
+      // to flip the bits appropriately.
+      if (!gSupportVisitedPseudo ||
+          gPrivateBrowsingObserver->InPrivateBrowsing()) {
+        // We *could* implement this pref significantly more efficiently
+        // by never creating the StyleIfVisited or setting
+        // NS_STYLE_RELEVANT_LINK_VISITED, but this should do for now.
+        mContentState |= NS_EVENT_STATE_UNVISITED;
+      } else {
+        switch (mVisitedHandling) {
+          case RuleProcessorData::eRelevantLinkUnvisited:
+            mContentState |= NS_EVENT_STATE_UNVISITED;
+            break;
+          case RuleProcessorData::eRelevantLinkVisited:
+            mContentState |= NS_EVENT_STATE_VISITED;
+            break;
+          case RuleProcessorData::eLinksVisitedOrUnvisited:
+            mContentState |= NS_EVENT_STATE_UNVISITED | NS_EVENT_STATE_VISITED;
+            break;
+        }
+      }
     }
   }
   return mContentState;
 }
 
 PRBool
 RuleProcessorData::IsLink()
 {
diff --git a/layout/style/nsRuleProcessorData.h b/layout/style/nsRuleProcessorData.h
--- a/layout/style/nsRuleProcessorData.h
+++ b/layout/style/nsRuleProcessorData.h
@@ -175,16 +175,17 @@ private:
   // If 0, the node is not at any index in its parent.
   // The first subscript is 0 for -child and 1 for -of-type, the second
   // subscript is 0 for nth- and 1 for nth-last-.
   PRInt32 mNthIndices[2][2];
 
   // mContentState and mReallyVisited are initialized lazily.
   PRInt32 mContentState;  // eventStateMgr->GetContentState() or
                           // mContent->IntrinsicState() if we have no ESM
+                          // plus adjustments for visited/unvisited links
   PRPackedBool mGotContentState;
   PRPackedBool mReallyVisited; // If this is :visited (which was removed from
                                // ContentState())
 };
 
 struct ElementRuleProcessorData : public RuleProcessorData {
   ElementRuleProcessorData(nsPresContext* aPresContext,
                            nsIContent* aContent, 
