From: L. David Baron <dbaron@dbaron.org>

Add method to munge the content state appropriately for how we're matching so that matching operations in HTML and CSS style sheets follow the new rules.  (Bug 147777)  (FIXME:  Need to figure out how to propagate out the found-a-relevant-link information.)

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1106,18 +1106,20 @@ RuleProcessorData::ContentState()
     mContentState = 0;
     if (mPresContext) {
       mPresContext->EventStateManager()->GetContentState(mContent,
                                                          mContentState);
     } else {
       mContentState = mContent->IntrinsicState();
     }
 
-    // If we are not supposed to mark visited links as such, be sure to flip the
-    // bits appropriately.
+    // If we are not supposed to mark visited links as such, be sure to
+    // flip the bits appropriately.  We want to do this here, rather
+    // than in GetContentStateForVisitedHandling, so that we don't
+    // expose that :visited support is disabled to the Web page.
     if ((!gSupportVisitedPseudo ||
         gPrivateBrowsingObserver->InPrivateBrowsing()) &&
         (mContentState & NS_EVENT_STATE_VISITED)) {
       mContentState = (mContentState & ~PRUint32(NS_EVENT_STATE_VISITED)) |
                       NS_EVENT_STATE_UNVISITED;
     }
   }
   return mContentState;
@@ -1125,16 +1127,38 @@ RuleProcessorData::ContentState()
 
 PRBool
 RuleProcessorData::IsLink()
 {
   PRUint32 state = ContentState();
   return (state & (NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED)) != 0;
 }
 
+PRUint32
+RuleProcessorData::GetContentStateForVisitedHandling(VisitedHandling aVisitedHandling)
+{
+  PRUint32 contentState = mContentState;
+  if (contentState & (NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED)) {
+    contentState &=
+      ~PRUint32(NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED);
+    switch (aVisitedHandling) {
+      case RuleProcessorData::eRelevantLinkUnvisited:
+        contentState |= NS_EVENT_STATE_UNVISITED;
+        break;
+      case RuleProcessorData::eRelevantLinkVisited:
+        contentState |= NS_EVENT_STATE_VISITED;
+        break;
+      case RuleProcessorData::eLinksVisitedOrUnvisited:
+        contentState |= NS_EVENT_STATE_UNVISITED | NS_EVENT_STATE_VISITED;
+        break;
+    }
+  }
+  return contentState;
+}
+
 PRInt32
 RuleProcessorData::GetNthIndex(PRBool aIsOfType, PRBool aIsFromEnd,
                                PRBool aCheckEdgeOnly)
 {
   NS_ASSERTION(mParentContent, "caller should check mParentContent");
   NS_ASSERTION(!mPreviousSiblingData ||
                mPreviousSiblingData->mContent->IsNodeOfType(nsINode::eELEMENT),
                "Unexpected previous sibling data");
@@ -2002,17 +2026,19 @@ static PRBool SelectorMatches(RuleProces
         // In quirks mode, only make certain elements sensitive to
         // selectors ":hover" and ":active".
         return PR_FALSE;
       } else {
         if (aNodeMatchContext->mStateMask & statesToCheck) {
           if (aDependence)
             *aDependence = PR_TRUE;
         } else {
-          if (!(data.ContentState() & statesToCheck)) {
+          PRUint32 contentState =
+            data.GetContentStateForVisitedHandling(data.mVisitedHandling);
+          if (!(contentState & statesToCheck)) {
             return PR_FALSE;
           }
         }
       }
     }
   }
 
   PRBool result = PR_TRUE;
diff --git a/layout/style/nsHTMLStyleSheet.cpp b/layout/style/nsHTMLStyleSheet.cpp
--- a/layout/style/nsHTMLStyleSheet.cpp
+++ b/layout/style/nsHTMLStyleSheet.cpp
@@ -233,17 +233,18 @@ nsHTMLStyleSheet::RulesMatching(ElementR
   if (content) {
     nsRuleWalker *ruleWalker = aData->mRuleWalker;
     if (aData->mIsHTMLContent) {
       nsIAtom* tag = aData->mContentTag;
 
       // if we have anchor colors, check if this is an anchor with an href
       if (tag == nsGkAtoms::a) {
         if (mLinkRule || mVisitedRule || mActiveRule) {
-          PRUint32 state = aData->ContentState();
+          PRUint32 state = aData->GetContentStateForVisitedHandling(
+                                    aData->mVisitedHandling);
           if (mLinkRule && (state & NS_EVENT_STATE_UNVISITED)) {
             ruleWalker->Forward(mLinkRule);
             aData->mHaveRelevantLink = PR_TRUE;
           }
           else if (mVisitedRule && (state & NS_EVENT_STATE_VISITED)) {
             ruleWalker->Forward(mVisitedRule);
             aData->mHaveRelevantLink = PR_TRUE;
           }
diff --git a/layout/style/nsRuleProcessorData.h b/layout/style/nsRuleProcessorData.h
--- a/layout/style/nsRuleProcessorData.h
+++ b/layout/style/nsRuleProcessorData.h
@@ -121,16 +121,18 @@ private:
   void* operator new(size_t sz) CPP_THROW_NEW {
     return ::operator new(sz);
   }
 public:
   const nsString* GetLang();
   PRUint32 ContentState();
   PRBool IsLink();
 
+  PRUint32 GetContentStateForVisitedHandling(VisitedHandling aVisitedHandling);
+
   // Returns a 1-based index of the child in its parent.  If the child
   // is not in its parent's child list (i.e., it is anonymous content),
   // returns 0.
   // If aCheckEdgeOnly is true, the function will return 1 if the result
   // is 1, and something other than 1 (maybe or maybe not a valid
   // result) otherwise.
   PRInt32 GetNthIndex(PRBool aIsOfType, PRBool aIsFromEnd,
                       PRBool aCheckEdgeOnly);
@@ -181,16 +183,18 @@ private:
   // If 0, the node is not at any index in its parent.
   // The first subscript is 0 for -child and 1 for -of-type, the second
   // subscript is 0 for nth- and 1 for nth-last-.
   PRInt32 mNthIndices[2][2];
 
   // mContentState is initialized lazily.
   PRInt32 mContentState;  // eventStateMgr->GetContentState() or
                           // mContent->IntrinsicState() if we have no ESM
+                          // adjusted for not supporting :visited (but with
+                          // visitedness information when we support it)
   PRPackedBool mGotContentState;
 };
 
 struct ElementRuleProcessorData : public RuleProcessorData {
   ElementRuleProcessorData(nsPresContext* aPresContext,
                            nsIContent* aContent, 
                            nsRuleWalker* aRuleWalker,
                            VisitedHandling aVisitedHandling)
