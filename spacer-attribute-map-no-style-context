Make spacer attribute mapping code not depend on data in the style context (which attribute mapping code should not do).

diff --git a/content/html/content/src/nsHTMLSharedElement.cpp b/content/html/content/src/nsHTMLSharedElement.cpp
--- a/content/html/content/src/nsHTMLSharedElement.cpp
+++ b/content/html/content/src/nsHTMLSharedElement.cpp
@@ -47,7 +47,6 @@
 #include "nsPresContext.h"
 #include "nsRuleData.h"
 #include "nsMappedAttributes.h"
-#include "nsStyleContext.h"
 
 // XXX nav4 has type= start= (same as OL/UL)
 extern nsAttrValue::EnumTable kListTypeTable[];
@@ -238,71 +237,80 @@ SpacerMapAttributesIntoRule(const nsMapp
   nsGenericHTMLElement::MapImageMarginAttributeInto(aAttributes, aData);
   nsGenericHTMLElement::MapImageSizeAttributesInto(aAttributes, aData);
 
-  if (aData->mSID == eStyleStruct_Position) {
-    const nsStyleDisplay* display = aData->mStyleContext->GetStyleDisplay();
-
-    PRBool typeIsBlock = (display->mDisplay == NS_STYLE_DISPLAY_BLOCK);
-
-    if (typeIsBlock) {
-      // width: value
-      if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
-        const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
-        if (value && value->Type() == nsAttrValue::eInteger) {
-          aData->mPositionData->
-            mWidth.SetFloatValue((float)value->GetIntegerValue(),
-                                 eCSSUnit_Pixel);
-        } else if (value && value->Type() == nsAttrValue::ePercent) {
-          aData->mPositionData->
-            mWidth.SetPercentValue(value->GetPercentValue());
-        }
-      }
-
-      // height: value
-      if (aData->mPositionData->mHeight.GetUnit() == eCSSUnit_Null) {
-        const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::height);
-        if (value && value->Type() == nsAttrValue::eInteger) {
-          aData->mPositionData->
-            mHeight.SetFloatValue((float)value->GetIntegerValue(),
-                                  eCSSUnit_Pixel);
-        } else if (value && value->Type() == nsAttrValue::ePercent) {
-          aData->mPositionData->
-            mHeight.SetPercentValue(value->GetPercentValue());
+  if (aData->mSID == eStyleStruct_Position ||
+      aData->mSID == eStyleStruct_Display) {
+    PRBool typeIsBlock = PR_FALSE;
+    const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::type);
+    if (value && value->Type() == nsAttrValue::eString) {
+      nsAutoString tmp(value->GetStringValue());
+      if (tmp.LowerCaseEqualsLiteral("line") ||
+          tmp.LowerCaseEqualsLiteral("vert") ||
+          tmp.LowerCaseEqualsLiteral("vertical") ||
+          tmp.LowerCaseEqualsLiteral("block")) {
+        // This is not strictly 100% compatible: if the spacer is given
+        // a width of zero then it is basically ignored.
+        typeIsBlock = PR_TRUE;
+      }
+    }
+
+    if (aData->mSID == eStyleStruct_Position) {
+      if (typeIsBlock) {
+        // width: value
+        if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
+          const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
+          if (value && value->Type() == nsAttrValue::eInteger) {
+            aData->mPositionData->
+              mWidth.SetFloatValue((float)value->GetIntegerValue(),
+                                   eCSSUnit_Pixel);
+          } else if (value && value->Type() == nsAttrValue::ePercent) {
+            aData->mPositionData->
+              mWidth.SetPercentValue(value->GetPercentValue());
+          }
+        }
+
+        // height: value
+        if (aData->mPositionData->mHeight.GetUnit() == eCSSUnit_Null) {
+          const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::height);
+          if (value && value->Type() == nsAttrValue::eInteger) {
+            aData->mPositionData->
+              mHeight.SetFloatValue((float)value->GetIntegerValue(),
+                                    eCSSUnit_Pixel);
+          } else if (value && value->Type() == nsAttrValue::ePercent) {
+            aData->mPositionData->
+              mHeight.SetPercentValue(value->GetPercentValue());
+          }
+        }
+      } else {
+        // size: value
+        if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
+          const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::size);
+          if (value && value->Type() == nsAttrValue::eInteger)
+            aData->mPositionData->
+              mWidth.SetFloatValue((float)value->GetIntegerValue(),
+                                   eCSSUnit_Pixel);
         }
       }
     } else {
-      // size: value
-      if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
-        const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::size);
-        if (value && value->Type() == nsAttrValue::eInteger)
-          aData->mPositionData->
-            mWidth.SetFloatValue((float)value->GetIntegerValue(),
-                                 eCSSUnit_Pixel);
-      }
-    }
-  } else if (aData->mSID == eStyleStruct_Display) {
-    const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
-    if (value && value->Type() == nsAttrValue::eEnum) {
-      PRInt32 align = value->GetEnumValue();
-      if (aData->mDisplayData->mFloat.GetUnit() == eCSSUnit_Null) {
-        if (align == NS_STYLE_TEXT_ALIGN_LEFT)
-          aData->mDisplayData->mFloat.SetIntValue(NS_STYLE_FLOAT_LEFT,
-                                                  eCSSUnit_Enumerated);
-        else if (align == NS_STYLE_TEXT_ALIGN_RIGHT)
-          aData->mDisplayData->mFloat.SetIntValue(NS_STYLE_FLOAT_RIGHT,
-                                                  eCSSUnit_Enumerated);
-      }
-    }
-
-    if (aData->mDisplayData->mDisplay.GetUnit() == eCSSUnit_Null) {
-      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::type);
-      if (value && value->Type() == nsAttrValue::eString) {
-        nsAutoString tmp(value->GetStringValue());
-        if (tmp.LowerCaseEqualsLiteral("line") ||
-            tmp.LowerCaseEqualsLiteral("vert") ||
-            tmp.LowerCaseEqualsLiteral("vertical") ||
-            tmp.LowerCaseEqualsLiteral("block")) {
-          // This is not strictly 100% compatible: if the spacer is given
-          // a width of zero then it is basically ignored.
+      // Any new structs that don't need typeIsBlock should go outside
+      // the code that calculates it.
+      NS_ASSERTION(aData->mSID == eStyleStruct_Display,
+                   "SID must be display");
+
+      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
+      if (value && value->Type() == nsAttrValue::eEnum) {
+        PRInt32 align = value->GetEnumValue();
+        if (aData->mDisplayData->mFloat.GetUnit() == eCSSUnit_Null) {
+          if (align == NS_STYLE_TEXT_ALIGN_LEFT)
+            aData->mDisplayData->mFloat.SetIntValue(NS_STYLE_FLOAT_LEFT,
+                                                    eCSSUnit_Enumerated);
+          else if (align == NS_STYLE_TEXT_ALIGN_RIGHT)
+            aData->mDisplayData->mFloat.SetIntValue(NS_STYLE_FLOAT_RIGHT,
+                                                    eCSSUnit_Enumerated);
+        }
+      }
+
+      if (typeIsBlock) {
+        if (aData->mDisplayData->mDisplay.GetUnit() == eCSSUnit_Null) {
           aData->mDisplayData->mDisplay.SetIntValue(NS_STYLE_DISPLAY_BLOCK,
                                                     eCSSUnit_Enumerated);
         }
