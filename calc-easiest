From: L. David Baron <dbaron@dbaron.org>

Add calc() support for the easiest cases:  properties that take lengths but not percentages and take simple values only.

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -5792,24 +5792,24 @@ CSSParserImpl::ParseSingleValueProperty(
                         nsCSSProps::kBorderStyleKTable);
   case eCSSProperty_border_bottom_width:
   case eCSSProperty_border_end_width_value: // for internal use
   case eCSSProperty_border_left_width_value: // for internal use
   case eCSSProperty_border_right_width_value: // for internal use
   case eCSSProperty_border_start_width_value: // for internal use
   case eCSSProperty_border_top_width:
   case eCSSProperty__moz_column_rule_width:
-    return ParseNonNegativeVariant(aValue, VARIANT_HKL,
+    return ParseNonNegativeVariant(aValue, VARIANT_HKL | VARIANT_CALC,
                                    nsCSSProps::kBorderWidthKTable);
   case eCSSProperty__moz_column_count:
     // Need to reject 0 in addition to negatives.  If we accept 0, we
     // need to change NS_STYLE_COLUMN_COUNT_AUTO to something else.
     return ParsePositiveNonZeroVariant(aValue, VARIANT_AHI, nsnull);
   case eCSSProperty__moz_column_width:
-    return ParseNonNegativeVariant(aValue, VARIANT_AHL, nsnull);
+    return ParseNonNegativeVariant(aValue, VARIANT_AHL | VARIANT_CALC, nsnull);
   case eCSSProperty__moz_column_gap:
     return ParseNonNegativeVariant(aValue, VARIANT_HL | VARIANT_NORMAL, nsnull);
   case eCSSProperty_bottom:
   case eCSSProperty_top:
   case eCSSProperty_left:
   case eCSSProperty_right:
     return ParseVariant(aValue, VARIANT_AHLP, nsnull);
   case eCSSProperty_box_align:
@@ -5973,34 +5973,35 @@ CSSParserImpl::ParseSingleValueProperty(
     return ParseFontWeight(aValue);
   case eCSSProperty_ime_mode:
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kIMEModeKTable);
   case eCSSProperty__moz_tab_size:
     return ParseNonNegativeVariant(aValue, VARIANT_HI, nsnull);
   case eCSSProperty_letter_spacing:
   case eCSSProperty_word_spacing:
-    return ParseVariant(aValue, VARIANT_HL | VARIANT_NORMAL, nsnull);
+    return ParseVariant(aValue, VARIANT_HL | VARIANT_NORMAL | VARIANT_CALC,
+                        nsnull);
   case eCSSProperty_line_height:
     return ParseNonNegativeVariant(aValue, VARIANT_HLPN | VARIANT_KEYWORD | VARIANT_NORMAL | VARIANT_SYSFONT, nsCSSProps::kLineHeightKTable);
   case eCSSProperty_list_style_image:
     return ParseVariant(aValue, VARIANT_HUO, nsnull);
   case eCSSProperty_list_style_position:
     return ParseVariant(aValue, VARIANT_HK, nsCSSProps::kListStylePositionKTable);
   case eCSSProperty_list_style_type:
     return ParseVariant(aValue, VARIANT_HK, nsCSSProps::kListStyleKTable);
   case eCSSProperty_margin_bottom:
   case eCSSProperty_margin_end_value: // for internal use
   case eCSSProperty_margin_left_value: // for internal use
   case eCSSProperty_margin_right_value: // for internal use
   case eCSSProperty_margin_start_value: // for internal use
   case eCSSProperty_margin_top:
     return ParseVariant(aValue, VARIANT_AHLP, nsnull);
   case eCSSProperty_marker_offset:
-    return ParseVariant(aValue, VARIANT_AHL, nsnull);
+    return ParseVariant(aValue, VARIANT_AHL | VARIANT_CALC, nsnull);
   case eCSSProperty_marks:
     return ParseMarks(aValue);
   case eCSSProperty_max_height:
     return ParseNonNegativeVariant(aValue, VARIANT_HLPO, nsnull);
   case eCSSProperty_max_width:
     return ParseNonNegativeVariant(aValue, VARIANT_HKLPO,
                                    nsCSSProps::kWidthKTable);
   case eCSSProperty_min_height:
@@ -6018,17 +6019,17 @@ CSSParserImpl::ParseSingleValueProperty(
                         nsCSSProps::kOutlineColorKTable);
   case eCSSProperty_outline_style:
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kOutlineStyleKTable);
   case eCSSProperty_outline_width:
     return ParseNonNegativeVariant(aValue, VARIANT_HKL,
                                    nsCSSProps::kBorderWidthKTable);
   case eCSSProperty_outline_offset:
-    return ParseVariant(aValue, VARIANT_HL, nsnull);
+    return ParseVariant(aValue, VARIANT_HL | VARIANT_CALC, nsnull);
   case eCSSProperty_overflow_x:
   case eCSSProperty_overflow_y:
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kOverflowSubKTable);
   case eCSSProperty_padding_bottom:
   case eCSSProperty_padding_end_value: // for internal use
   case eCSSProperty_padding_left_value: // for internal use
   case eCSSProperty_padding_right_value: // for internal use
@@ -6931,21 +6932,22 @@ CSSParserImpl::ParseBorderImage()
 
   return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseBorderSpacing()
 {
   nsCSSValue  xValue;
-  if (ParseNonNegativeVariant(xValue, VARIANT_HL, nsnull)) {
+  if (ParseNonNegativeVariant(xValue, VARIANT_HL | VARIANT_CALC, nsnull)) {
     if (xValue.IsLengthUnit()) {
       // We have one length. Get the optional second length.
       nsCSSValue yValue;
-      if (ParseNonNegativeVariant(yValue, VARIANT_LENGTH, nsnull)) {
+      if (ParseNonNegativeVariant(yValue, VARIANT_LENGTH | VARIANT_CALC,
+                                  nsnull)) {
         // We have two numbers
         if (ExpectEndProperty()) {
           mTempData.mTable.mBorderSpacing.mXValue = xValue;
           mTempData.mTable.mBorderSpacing.mYValue = yValue;
           mTempData.SetPropertyBit(eCSSProperty_border_spacing);
           return PR_TRUE;
         }
         return PR_FALSE;
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -3316,17 +3316,18 @@ nsRuleNode::ComputeTextData(void* aStart
 
   // tab-size: integer, inherit
   SetDiscrete(textData.mTabSize, text->mTabSize, canStoreInRuleTree,
               SETDSC_INTEGER, parentText->mTabSize,
               NS_STYLE_TABSIZE_INITIAL, 0, 0, 0, 0);
 
   // letter-spacing: normal, length, inherit
   SetCoord(textData.mLetterSpacing, text->mLetterSpacing, parentText->mLetterSpacing,
-           SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL,
+           SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL |
+             SETCOORD_CALC_LENGTH_ONLY,
            aContext, mPresContext, canStoreInRuleTree);
 
   // text-shadow: none, list, inherit, initial
   nsCSSValueList* list = textData.mTextShadow;
   if (list) {
     text->mTextShadow = nsnull;
 
     // Don't need to handle none/initial explicitly: The above assignment
@@ -3412,17 +3413,18 @@ nsRuleNode::ComputeTextData(void* aStart
               SETDSC_ENUMERATED, parentText->mWhiteSpace,
               NS_STYLE_WHITESPACE_NORMAL, 0, 0, 0, 0);
 
   // word-spacing: normal, length, inherit
   nsStyleCoord tempCoord;
   if (SetCoord(textData.mWordSpacing, tempCoord,
                nsStyleCoord(parentText->mWordSpacing,
                             nsStyleCoord::CoordConstructor),
-               SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL,
+               SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL |
+                 SETCOORD_CALC_LENGTH_ONLY,
                aContext, mPresContext, canStoreInRuleTree)) {
     if (tempCoord.GetUnit() == eStyleUnit_Coord) {
       text->mWordSpacing = tempCoord.GetCoordValue();
     } else if (tempCoord.GetUnit() == eStyleUnit_Normal) {
       text->mWordSpacing = 0;
     } else {
       NS_NOTREACHED("unexpected unit");
     }
@@ -5089,18 +5091,18 @@ nsRuleNode::ComputeOutlineData(void* aSt
              mPresContext, canStoreInRuleTree);
   }
 
   // outline-offset: length, inherit
   nsStyleCoord tempCoord;
   if (SetCoord(marginData.mOutlineOffset, tempCoord,
                nsStyleCoord(parentOutline->mOutlineOffset,
                             nsStyleCoord::CoordConstructor),
-               SETCOORD_LH | SETCOORD_INITIAL_ZERO, aContext, mPresContext,
-               canStoreInRuleTree)) {
+               SETCOORD_LH | SETCOORD_INITIAL_ZERO | SETCOORD_CALC_LENGTH_ONLY,
+               aContext, mPresContext, canStoreInRuleTree)) {
     outline->mOutlineOffset = tempCoord.GetCoordValue();
   } else {
     NS_ASSERTION(marginData.mOutlineOffset.GetUnit() == eCSSUnit_Null,
                  "unexpected unit");
   }
 
   // outline-color: color, string, enum, inherit
   nscolor outlineColor;
@@ -5360,29 +5362,29 @@ nsRuleNode::ComputeTableBorderData(void*
               SETDSC_ENUMERATED, parentTable->mBorderCollapse,
               NS_STYLE_BORDER_SEPARATE, 0, 0, 0, 0);
 
   // border-spacing-x: length, inherit
   nsStyleCoord tempCoord;
   if (SetCoord(tableData.mBorderSpacing.mXValue, tempCoord,
                nsStyleCoord(parentTable->mBorderSpacingX,
                             nsStyleCoord::CoordConstructor),
-               SETCOORD_LH | SETCOORD_INITIAL_ZERO,
+               SETCOORD_LH | SETCOORD_INITIAL_ZERO | SETCOORD_CALC_LENGTH_ONLY,
                aContext, mPresContext, canStoreInRuleTree)) {
     table->mBorderSpacingX = tempCoord.GetCoordValue();
   } else {
     NS_ASSERTION(tableData.mBorderSpacing.mXValue.GetUnit() == eCSSUnit_Null,
                  "unexpected unit");
   }
 
   // border-spacing-y: length, inherit
   if (SetCoord(tableData.mBorderSpacing.mYValue, tempCoord,
                nsStyleCoord(parentTable->mBorderSpacingY,
                             nsStyleCoord::CoordConstructor),
-               SETCOORD_LH | SETCOORD_INITIAL_ZERO,
+               SETCOORD_LH | SETCOORD_INITIAL_ZERO | SETCOORD_CALC_LENGTH_ONLY,
                aContext, mPresContext, canStoreInRuleTree)) {
     table->mBorderSpacingY = tempCoord.GetCoordValue();
   } else {
     NS_ASSERTION(tableData.mBorderSpacing.mYValue.GetUnit() == eCSSUnit_Null,
                  "unexpected unit");
   }
 
   // caption-side: enum, inherit, initial
@@ -5576,18 +5578,19 @@ nsRuleNode::ComputeContentData(void* aSt
           ourReset = ourReset->mNext;
         }
       }
     }
   }
 
   // marker-offset: length, auto, inherit
   SetCoord(contentData.mMarkerOffset, content->mMarkerOffset, parentContent->mMarkerOffset,
-           SETCOORD_LH | SETCOORD_AUTO | SETCOORD_INITIAL_AUTO, aContext,
-           mPresContext, canStoreInRuleTree);
+           SETCOORD_LH | SETCOORD_AUTO | SETCOORD_INITIAL_AUTO |
+             SETCOORD_CALC_LENGTH_ONLY,
+           aContext, mPresContext, canStoreInRuleTree);
 
   COMPUTE_END_RESET(Content, content)
 }
 
 const void*
 nsRuleNode::ComputeQuotesData(void* aStartStruct,
                               const nsRuleDataStruct& aData,
                               nsStyleContext* aContext,
@@ -5694,19 +5697,20 @@ nsRuleNode::ComputeColumnData(void* aSta
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Column, (mPresContext), column, parent, Column, columnData)
 
   // column-width: length, auto, inherit
+  // FIXME: Need to clamp calc() results.
   SetCoord(columnData.mColumnWidth,
            column->mColumnWidth, parent->mColumnWidth,
-           SETCOORD_LAH | SETCOORD_INITIAL_AUTO,
+           SETCOORD_LAH | SETCOORD_INITIAL_AUTO | SETCOORD_CALC_LENGTH_ONLY,
            aContext, mPresContext, canStoreInRuleTree);
 
   // column-gap: length, percentage, inherit, normal
   SetCoord(columnData.mColumnGap,
            column->mColumnGap, parent->mColumnGap,
            SETCOORD_LPH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL,
            aContext, mPresContext, canStoreInRuleTree);
 
@@ -5737,16 +5741,17 @@ nsRuleNode::ComputeColumnData(void* aSta
     column->SetColumnRuleWidth(
         (mPresContext->GetBorderWidthTable())[widthValue.GetIntValue()]);
   }
   else if (eCSSUnit_Inherit == widthValue.GetUnit()) {
     column->SetColumnRuleWidth(parent->GetComputedColumnRuleWidth());
     canStoreInRuleTree = PR_FALSE;
   }
   else if (widthValue.IsLengthUnit()) {
+    // FIXME: Need to clamp calc!
     column->SetColumnRuleWidth(CalcLength(widthValue, aContext,
                                           mPresContext, canStoreInRuleTree));
   }
 
   // column-rule-style: enum, inherit
   const nsCSSValue& styleValue = columnData.mColumnRuleStyle;
   NS_ABORT_IF_FALSE(eCSSUnit_None != styleValue.GetUnit(),
                     "'none' should be handled as enumerated value");
diff --git a/layout/style/test/property_database.js b/layout/style/test/property_database.js
--- a/layout/style/test/property_database.js
+++ b/layout/style/test/property_database.js
@@ -383,18 +383,61 @@ var gCSSProperties = {
 		invalid_values: [ "20", "-1px", "50%" ]
 	},
 	"-moz-column-rule-width": {
 		domProp: "MozColumnRuleWidth",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		prerequisites: { "-moz-column-rule-style": "solid" },
 		initial_values: [ "medium" ],
-		other_values: [ "thin", "15px" ],
-		invalid_values: [ "20", "-1px", "red", "50%" ]
+		other_values: [ "thin", "15px",
+			/* valid calc() values */
+			"-moz-calc(-2px)",
+			"-moz-calc(2px)",
+			"-moz-calc(3em)",
+			"-moz-calc(3em + 2px)",
+			"-moz-calc( 3em + 2px)",
+			"-moz-calc(3em + 2px )",
+			"-moz-calc( 3em + 2px )",
+			"-moz-calc(3*25px)",
+			"-moz-calc(3 *25px)",
+			"-moz-calc(3 * 25px)",
+			"-moz-calc(3* 25px)",
+			"-moz-calc(25px*3)",
+			"-moz-calc(25px *3)",
+			"-moz-calc(25px* 3)",
+			"-moz-calc(25px * 3)",
+			"-moz-calc(3*25px + 1in)",
+			"-moz-calc(1in - 3em + 2px)",
+			"-moz-calc(1in - (3em + 2px))",
+			"-moz-calc((1in - 3em) + 2px)",
+			"-moz-min(1in, 30em)",
+			"-moz-calc(min(1in, 30em))",
+			"-moz-max(30em, 2px + 1in)",
+			"-moz-calc(max(30em, 2px + 1in))",
+			"-moz-min(2in, 30em,200px, min(500px ,40em))",
+			"-moz-calc(min(2in, 30em,200px, min(500px ,40em)))",
+			"-moz-min(2in)",
+			"-moz-max(20px)",
+			"-moz-calc(min(2em))",
+			"-moz-calc(max(1in))",
+			"-moz-calc(50px/2)",
+			"-moz-calc(50px/(2 - 1))"
+		],
+		invalid_values: [ "20", "-1px", "red", "50%",
+			/* invalid calc() values */
+			"-moz-calc(2em+ 2px)",
+			"-moz-calc(2em +2px)",
+			"-moz-calc(2em+2px)",
+			"-moz-min()",
+			"-moz-calc(min())",
+			"-moz-max()",
+			"-moz-calc(max())",
+			"-moz-calc(50px/(2 - 2))"
+		]
 	},
 	"-moz-column-rule-style": {
 		domProp: "MozColumnRuleStyle",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "none" ],
 		other_values: [ "solid", "hidden", "ridge", "groove", "inset", "outset", "double", "dotted", "dashed" ],
 		invalid_values: [ "20", "foo" ]
