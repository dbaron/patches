From: L. David Baron <dbaron@dbaron.org>

Make some of the DEBUG_CC code accessible to code in non-debug builds so it can be used by memory tools for Web developers.  (Bug 500233)  r+sr=peterv

diff --git a/content/base/src/nsCCUncollectableMarker.h b/content/base/src/nsCCUncollectableMarker.h
--- a/content/base/src/nsCCUncollectableMarker.h
+++ b/content/base/src/nsCCUncollectableMarker.h
@@ -31,32 +31,36 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsIObserver.h"
+#include "nsCycleCollectionParticipant.h"
 
 class nsCCUncollectableMarker : public nsIObserver
 {
   NS_DECL_ISUPPORTS
   NS_DECL_NSIOBSERVER
 
   /**
    * Inits a global nsCCUncollectableMarker. Should only be called once.
    */
   static nsresult Init();
 
   /**
    * Checks if we're collecting during a given generation
    */
-  static PRBool InGeneration(PRUint32 aGeneration) {
-    return aGeneration && aGeneration == sGeneration;
+  static PRBool InGeneration(nsCycleCollectionTraversalCallback &cb,
+                             PRUint32 aGeneration) {
+    return !cb.WantAllTraces() &&
+           aGeneration &&
+           aGeneration == sGeneration;
   }
 
   static PRUint32 sGeneration;
 
 private:
   nsCCUncollectableMarker() {}
 
 };
diff --git a/content/base/src/nsDocument.cpp b/content/base/src/nsDocument.cpp
--- a/content/base/src/nsDocument.cpp
+++ b/content/base/src/nsDocument.cpp
@@ -1718,17 +1718,17 @@ IdentifierMapEntryTraverse(nsIdentifierM
   return PL_DHASH_NEXT;
 }
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsDocument)
   // Always need to traverse script objects, so do that before we check
   // if we're uncollectable.
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
 
-  if (nsCCUncollectableMarker::InGeneration(tmp->GetMarkedCCGeneration())) {
+  if (nsCCUncollectableMarker::InGeneration(cb, tmp->GetMarkedCCGeneration())) {
     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
   }
 
   tmp->mIdentifierMap.EnumerateEntries(IdentifierMapEntryTraverse, &cb);
 
   tmp->mExternalResourceMap.Traverse(&cb);
 
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mNodeInfo)
diff --git a/content/base/src/nsGenericDOMDataNode.cpp b/content/base/src/nsGenericDOMDataNode.cpp
--- a/content/base/src/nsGenericDOMDataNode.cpp
+++ b/content/base/src/nsGenericDOMDataNode.cpp
@@ -86,17 +86,17 @@ NS_IMPL_CYCLE_COLLECTION_TRACE_END
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsGenericDOMDataNode)
   // Always need to traverse script objects, so do that before we check
   // if we're uncollectable.
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
 
   nsIDocument* currentDoc = tmp->GetCurrentDoc();
   if (currentDoc && nsCCUncollectableMarker::InGeneration(
-                      currentDoc->GetMarkedCCGeneration())) {
+                      cb, currentDoc->GetMarkedCCGeneration())) {
     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
   }
 
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mNodeInfo)
 
   nsIDocument* ownerDoc = tmp->GetOwnerDoc();
   if (ownerDoc) {
     ownerDoc->BindingManager()->Traverse(tmp, cb);
diff --git a/content/base/src/nsGenericElement.cpp b/content/base/src/nsGenericElement.cpp
--- a/content/base/src/nsGenericElement.cpp
+++ b/content/base/src/nsGenericElement.cpp
@@ -4004,17 +4004,17 @@ NS_IMPL_CYCLE_COLLECTION_TRACE_END
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsGenericElement)
   // Always need to traverse script objects, so do that before we check
   // if we're uncollectable.
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
 
   nsIDocument* currentDoc = tmp->GetCurrentDoc();
   if (currentDoc && nsCCUncollectableMarker::InGeneration(
-                      currentDoc->GetMarkedCCGeneration())) {
+                      cb, currentDoc->GetMarkedCCGeneration())) {
     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
   }
 
   nsIDocument* ownerDoc = tmp->GetOwnerDoc();
   if (ownerDoc) {
     ownerDoc->BindingManager()->Traverse(tmp, cb);
   }
 
diff --git a/content/html/document/src/nsHTMLDocument.cpp b/content/html/document/src/nsHTMLDocument.cpp
--- a/content/html/document/src/nsHTMLDocument.cpp
+++ b/content/html/document/src/nsHTMLDocument.cpp
@@ -233,17 +233,17 @@ nsHTMLDocument::nsHTMLDocument()
   mIsRegularHTML = PR_TRUE;
   mDefaultElementType = kNameSpaceID_XHTML;
   mCompatMode = eCompatibility_NavQuirks;
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLDocument)
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLDocument, nsDocument)
-  NS_ASSERTION(!nsCCUncollectableMarker::InGeneration(tmp->GetMarkedCCGeneration()),
+  NS_ASSERTION(!nsCCUncollectableMarker::InGeneration(cb, tmp->GetMarkedCCGeneration()),
                "Shouldn't traverse nsHTMLDocument!");
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mImageMaps)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mImages)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mApplets)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mEmbeds)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLinks)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mAnchors)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFragmentParser)
diff --git a/content/xul/document/src/nsXULDocument.cpp b/content/xul/document/src/nsXULDocument.cpp
--- a/content/xul/document/src/nsXULDocument.cpp
+++ b/content/xul/document/src/nsXULDocument.cpp
@@ -330,17 +330,17 @@ TraverseObservers(nsIURI* aKey, nsIObser
 
     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mOverlayLoadObservers/mPendingOverlayLoadNotifications value");
     cb->NoteXPCOMChild(aData);
 
     return PL_DHASH_NEXT;
 }
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXULDocument, nsXMLDocument)
-    NS_ASSERTION(!nsCCUncollectableMarker::InGeneration(tmp->GetMarkedCCGeneration()),
+    NS_ASSERTION(!nsCCUncollectableMarker::InGeneration(cb, tmp->GetMarkedCCGeneration()),
                  "Shouldn't traverse nsXULDocument!");
     // XXX tmp->mForwardReferences?
     // XXX tmp->mContextStack?
 
     // An element will only have a template builder as long as it's in the
     // document, so we'll traverse the table here instead of from the element.
     if (tmp->mTemplateBuilderTable)
         tmp->mTemplateBuilderTable->EnumerateRead(TraverseTemplateBuilders, &cb);
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -1012,17 +1012,17 @@ NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsGlobalWindow, nsIScriptGlobalObject)
 NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS(nsGlobalWindow,
                                            nsIScriptGlobalObject)
 
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsGlobalWindow)
   if (tmp->mDoc && nsCCUncollectableMarker::InGeneration(
-                     tmp->mDoc->GetMarkedCCGeneration())) {
+                     cb, tmp->mDoc->GetMarkedCCGeneration())) {
     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
   }
 
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mContext)
 
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mControllers)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mArguments)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mArgumentsLast)
diff --git a/js/src/xpconnect/src/nsXPConnect.cpp b/js/src/xpconnect/src/nsXPConnect.cpp
--- a/js/src/xpconnect/src/nsXPConnect.cpp
+++ b/js/src/xpconnect/src/nsXPConnect.cpp
@@ -646,31 +646,33 @@ struct TraversalTracer : public JSTracer
 };
 
 static void
 NoteJSChild(JSTracer *trc, void *thing, uint32 kind)
 {
     if(ADD_TO_CC(kind))
     {
         TraversalTracer *tracer = static_cast<TraversalTracer*>(trc);
-#if defined(DEBUG) && defined(DEBUG_CC)
-        // based on DumpNotify in jsapi.c
-        if (tracer->debugPrinter) {
-            char buffer[200];
-            tracer->debugPrinter(trc, buffer, sizeof(buffer));
-            tracer->cb.NoteNextEdgeName(buffer);
-        } else if (tracer->debugPrintIndex != (size_t)-1) {
-            char buffer[200];
-            JS_snprintf(buffer, sizeof(buffer), "%s[%lu]",
-                        static_cast<const char *>(tracer->debugPrintArg),
-                        tracer->debugPrintIndex);
-            tracer->cb.NoteNextEdgeName(buffer);
-        } else {
-            tracer->cb.NoteNextEdgeName(
-              static_cast<const char*>(tracer->debugPrintArg));
+#if defined(DEBUG)
+        if (NS_UNLIKELY(tracer->cb.WantDebugInfo())) {
+            // based on DumpNotify in jsapi.c
+            if (tracer->debugPrinter) {
+                char buffer[200];
+                tracer->debugPrinter(trc, buffer, sizeof(buffer));
+                tracer->cb.NoteNextEdgeName(buffer);
+            } else if (tracer->debugPrintIndex != (size_t)-1) {
+                char buffer[200];
+                JS_snprintf(buffer, sizeof(buffer), "%s[%lu]",
+                            static_cast<const char *>(tracer->debugPrintArg),
+                            tracer->debugPrintIndex);
+                tracer->cb.NoteNextEdgeName(buffer);
+            } else {
+                tracer->cb.NoteNextEdgeName(
+                  static_cast<const char*>(tracer->debugPrintArg));
+            }
         }
 #endif
         tracer->cb.NoteScriptChild(nsIProgrammingLanguage::JAVASCRIPT, thing);
     }
     else if(kind != JSTRACE_DOUBLE && kind != JSTRACE_STRING)
     {
         JS_TraceChildren(trc, thing, kind);
     }
@@ -727,17 +729,16 @@ nsXPConnect::Traverse(void *p, nsCycleCo
             dontTraverse = WrapperIsNotMainThreadOnly(wrapper);
             markJSObject = dontTraverse && wrapper->HasExternalReference();
         }
     }
 
     CCNodeType type;
 
 #ifdef DEBUG_CC
-    {
     // Note that the conditions under which we specify GCMarked vs.
     // GCUnmarked are different between ExplainLiveExpectedGarbage and
     // the normal case.  In the normal case, we're saying that anything
     // reachable from a JS runtime root is itself such a root.  This
     // doesn't actually break anything; it really just does some of the
     // cycle collector's work for it.  However, when debugging, we
     // (1) actually need to know what the root is and (2) don't want to
     // do an extra GC, so we use mJSRoots, built from JS_TraceRuntime,
@@ -747,159 +748,160 @@ nsXPConnect::Traverse(void *p, nsCycleCo
     {
         // ExplainLiveExpectedGarbage codepath
         PLDHashEntryHdr* entry =
             PL_DHashTableOperate(&mJSRoots, p, PL_DHASH_LOOKUP);
         type = markJSObject || PL_DHASH_ENTRY_IS_BUSY(entry) ? GCMarked :
                                                                GCUnmarked;
     }
     else
+#endif
     {
         // Normal codepath (matches non-DEBUG_CC codepath).
         type = !markJSObject && JS_IsAboutToBeFinalized(cx, p) ? GCUnmarked :
                                                                  GCMarked;
     }
 
-    char name[72];
-    if(traceKind == JSTRACE_OBJECT)
-    {
-        JSObject *obj = static_cast<JSObject*>(p);
-        JSClass *clazz = OBJ_GET_CLASS(cx, obj);
-        if(XPCNativeWrapper::IsNativeWrapperClass(clazz))
+    if (cb.WantDebugInfo()) {
+        char name[72];
+        if(traceKind == JSTRACE_OBJECT)
         {
-            XPCWrappedNative* wn;
-            if(XPCNativeWrapper::GetWrappedNative(cx, obj, &wn) && wn)
+            JSObject *obj = static_cast<JSObject*>(p);
+            JSClass *clazz = OBJ_GET_CLASS(cx, obj);
+            if(XPCNativeWrapper::IsNativeWrapperClass(clazz))
             {
-                XPCNativeScriptableInfo* si = wn->GetScriptableInfo();
-                if(si)
+                XPCWrappedNative* wn;
+                if(XPCNativeWrapper::GetWrappedNative(cx, obj, &wn) && wn)
                 {
-                    JS_snprintf(name, sizeof(name), "XPCNativeWrapper (%s)",
-                                si->GetJSClass()->name);
+                    XPCNativeScriptableInfo* si = wn->GetScriptableInfo();
+                    if(si)
+                    {
+                        JS_snprintf(name, sizeof(name), "XPCNativeWrapper (%s)",
+                                    si->GetJSClass()->name);
+                    }
+                    else
+                    {
+                        nsIClassInfo* ci = wn->GetClassInfo();
+                        char* className = nsnull;
+                        if(ci)
+                            ci->GetClassDescription(&className);
+                        if(className)
+                        {
+                            JS_snprintf(name, sizeof(name),
+                                        "XPCNativeWrapper (%s)", className);
+                            PR_Free(className);
+                        }
+                        else
+                        {
+                            XPCNativeSet* set = wn->GetSet();
+                            XPCNativeInterface** array =
+                                set->GetInterfaceArray();
+                            PRUint16 count = set->GetInterfaceCount();
+
+                            if(count > 0)
+                                JS_snprintf(name, sizeof(name),
+                                            "XPCNativeWrapper (%s)",
+                                            array[0]->GetNameString());
+                            else
+                                JS_snprintf(name, sizeof(name),
+                                            "XPCNativeWrapper");
+                        }
+                    }
                 }
                 else
                 {
-                    nsIClassInfo* ci = wn->GetClassInfo();
-                    char* className = nsnull;
-                    if(ci)
-                        ci->GetClassDescription(&className);
-                    if(className)
-                    {
-                        JS_snprintf(name, sizeof(name), "XPCNativeWrapper (%s)",
-                                    className);
-                        PR_Free(className);
-                    }
-                    else
-                    {
-                        XPCNativeSet* set = wn->GetSet();
-                        XPCNativeInterface** array = set->GetInterfaceArray();
-                        PRUint16 count = set->GetInterfaceCount();
-
-                        if(count > 0)
-                            JS_snprintf(name, sizeof(name),
-                                        "XPCNativeWrapper (%s)",
-                                        array[0]->GetNameString());
-                        else
-                            JS_snprintf(name, sizeof(name), "XPCNativeWrapper");
-                    }
+                    JS_snprintf(name, sizeof(name), "XPCNativeWrapper");
                 }
             }
             else
             {
-                JS_snprintf(name, sizeof(name), "XPCNativeWrapper");
+                XPCNativeScriptableInfo* si = nsnull;
+                if(IS_PROTO_CLASS(clazz))
+                {
+                    XPCWrappedNativeProto* p =
+                        (XPCWrappedNativeProto*) xpc_GetJSPrivate(obj);
+                    si = p->GetScriptableInfo();
+                }
+                if(si)
+                {
+                    JS_snprintf(name, sizeof(name), "JS Object (%s - %s)",
+                                clazz->name, si->GetJSClass()->name);
+                }
+                else if(clazz == &js_ScriptClass)
+                {
+                    JSScript* script = (JSScript*) xpc_GetJSPrivate(obj);
+                    if(script->filename)
+                    {
+                        JS_snprintf(name, sizeof(name),
+                                    "JS Object (Script - %s)",
+                                    script->filename);
+                    }
+                    else
+                    {
+                        JS_snprintf(name, sizeof(name), "JS Object (Script)");
+                    }
+                }
+                else if(clazz == &js_FunctionClass)
+                {
+                    JSFunction* fun = (JSFunction*) xpc_GetJSPrivate(obj);
+                    JSString* str = JS_GetFunctionId(fun);
+                    if(str)
+                    {
+                        NS_ConvertUTF16toUTF8
+                            fname(JS_GetStringChars(str));
+                        JS_snprintf(name, sizeof(name),
+                                    "JS Object (Function - %s)", fname.get());
+                    }
+                    else
+                    {
+                        JS_snprintf(name, sizeof(name), "JS Object (Function)");
+                    }
+                }
+                else
+                {
+                    JS_snprintf(name, sizeof(name), "JS Object (%s)",
+                                clazz->name);
+                }
             }
         }
         else
         {
-            XPCNativeScriptableInfo* si = nsnull;
-            if(IS_PROTO_CLASS(clazz))
-            {
-                XPCWrappedNativeProto* p =
-                    (XPCWrappedNativeProto*) xpc_GetJSPrivate(obj);
-                si = p->GetScriptableInfo();
-            }
-            if(si)
-            {
-                JS_snprintf(name, sizeof(name), "JS Object (%s - %s)",
-                            clazz->name, si->GetJSClass()->name);
-            }
-            else if(clazz == &js_ScriptClass)
-            {
-                JSScript* script = (JSScript*) xpc_GetJSPrivate(obj);
-                if(script->filename)
-                {
-                    JS_snprintf(name, sizeof(name), "JS Object (Script - %s)",
-                                script->filename);
-                }
-                else
-                {
-                    JS_snprintf(name, sizeof(name), "JS Object (Script)");
-                }
-            }
-            else if(clazz == &js_FunctionClass)
-            {
-                JSFunction* fun = (JSFunction*) xpc_GetJSPrivate(obj);
-                JSString* str = JS_GetFunctionId(fun);
-                if(str)
-                {
-                    NS_ConvertUTF16toUTF8
-                        fname(JS_GetStringChars(str));
-                    JS_snprintf(name, sizeof(name), "JS Object (Function - %s)",
-                                fname.get());
-                }
-                else
-                {
-                    JS_snprintf(name, sizeof(name), "JS Object (Function)");
-                }
-            }
-            else
-            {
-                JS_snprintf(name, sizeof(name), "JS Object (%s)", clazz->name);
-            }
+            static const char trace_types[JSTRACE_LIMIT][7] = {
+                "Object",
+                "Double",
+                "String",
+                "Xml"
+            };
+            JS_snprintf(name, sizeof(name), "JS %s", trace_types[traceKind]);
         }
+
+        if(traceKind == JSTRACE_OBJECT) {
+            JSObject *global = static_cast<JSObject*>(p), *parent;
+            while((parent = JS_GetParent(cx, global)))
+                global = parent;
+            char fullname[100];
+            JS_snprintf(fullname, sizeof(fullname),
+                        "%s (global=%p)", name, global);
+            cb.DescribeNode(type, 0, sizeof(JSObject), fullname);
+        } else {
+            cb.DescribeNode(type, 0, sizeof(JSObject), name);
+        }
+    } else {
+        cb.DescribeNode(type, 0, sizeof(JSObject), "JS Object");
     }
-    else
-    {
-        static const char trace_types[JSTRACE_LIMIT][7] = {
-            "Object",
-            "Double",
-            "String",
-            "Xml"
-        };
-        JS_snprintf(name, sizeof(name), "JS %s", trace_types[traceKind]);
-    }
-
-    if(traceKind == JSTRACE_OBJECT) {
-        JSObject *global = static_cast<JSObject*>(p), *parent;
-        while((parent = JS_GetParent(cx, global)))
-            global = parent;
-        char fullname[100];
-        JS_snprintf(fullname, sizeof(fullname), "%s (global=%p)", name, global);
-        cb.DescribeNode(type, 0, sizeof(JSObject), fullname);
-    } else {
-        cb.DescribeNode(type, 0, sizeof(JSObject), name);
-    }
-
-    }
-#else
-    type = !markJSObject && JS_IsAboutToBeFinalized(cx, p) ? GCUnmarked :
-                                                             GCMarked;
-    cb.DescribeNode(type, 0);
-#endif
 
     if(!ADD_TO_CC(traceKind))
         return NS_OK;
 
-#ifndef DEBUG_CC
     // There's no need to trace objects that have already been marked by the JS
     // GC. Any JS objects hanging from them will already be marked. Only do this
     // if DEBUG_CC is not defined, else we do want to know about all JS objects
     // to get better graphs and explanations.
-    if(type == GCMarked)
+    if(!cb.WantAllTraces() && type == GCMarked)
         return NS_OK;
-#endif
 
     TraversalTracer trc(cb);
 
     JS_TRACER_INIT(&trc, cx, NoteJSChild);
     JS_TraceChildren(&trc, p, traceKind);
 
     if(traceKind != JSTRACE_OBJECT || dontTraverse)
         return NS_OK;
@@ -963,23 +965,19 @@ public:
         JSContext *cx = static_cast<JSContext*>(n);
 
         // Add cx->requestDepth to the refcount, if there are outstanding
         // requests the context needs to be kept alive and adding unknown
         // edges will ensure that any cycles this context is in won't be
         // collected.
         PRInt32 refCount = nsXPConnect::GetXPConnect()->GetRequestDepth(cx) + 1;
 
-#ifdef DEBUG_CC
         cb.DescribeNode(RefCounted, refCount, sizeof(JSContext),
                         "JSContext");
-        cb.NoteNextEdgeName("[global object]");
-#else
-        cb.DescribeNode(RefCounted, refCount);
-#endif
+        NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[global object]");
         cb.NoteScriptChild(nsIProgrammingLanguage::JAVASCRIPT,
                            cx->globalObject);
 
         return NS_OK;
     }
 };
 
 static JSContextParticipant JSContext_cycleCollectorGlobal;
diff --git a/js/src/xpconnect/src/xpcjsruntime.cpp b/js/src/xpconnect/src/xpcjsruntime.cpp
--- a/js/src/xpconnect/src/xpcjsruntime.cpp
+++ b/js/src/xpconnect/src/xpcjsruntime.cpp
@@ -409,23 +409,23 @@ void XPCJSRuntime::AddXPConnectRoots(JSC
     // collector. This includes JSContexts that don't have outstanding requests,
     // because their global object wasn't marked by the JS GC. All other JS
     // roots were marked by the JS GC and will be colored correctly in the cycle
     // collector.
 
     JSContext *iter = nsnull, *acx;
     while((acx = JS_ContextIterator(GetJSRuntime(), &iter)))
     {
-#ifndef DEBUG_CC
-        // Only skip JSContexts with outstanding requests if DEBUG_CC is not
-        // defined, else we do want to know about all JSContexts to get better
-        // graphs and explanations.
-        if(nsXPConnect::GetXPConnect()->GetRequestDepth(acx) != 0)
+        // Only skip JSContexts with outstanding requests if the
+        // callback does not want all traces (a debug feature).
+        // Otherwise, we do want to know about all JSContexts to get
+        // better graphs and explanations.
+        if(!cb.WantAllTraces() &&
+           nsXPConnect::GetXPConnect()->GetRequestDepth(acx) != 0)
             continue;
-#endif
         cb.NoteRoot(nsIProgrammingLanguage::CPLUSPLUS, acx,
                     nsXPConnect::JSContextParticipant());
     }
 
     XPCWrappedNativeScope::SuspectAllWrappers(this, cx, cb);
 
     for(XPCRootSetElem *e = mVariantRoots; e ; e = e->GetNextRoot())
         cb.NoteXPCOMRoot(static_cast<XPCTraceableVariant*>(e));
diff --git a/js/src/xpconnect/src/xpcwrappedjs.cpp b/js/src/xpconnect/src/xpcwrappedjs.cpp
--- a/js/src/xpconnect/src/xpcwrappedjs.cpp
+++ b/js/src/xpconnect/src/xpcwrappedjs.cpp
@@ -52,27 +52,28 @@ NS_CYCLE_COLLECTION_CLASSNAME(nsXPCWrapp
    (void *p, nsCycleCollectionTraversalCallback &cb)
 {
     nsISupports *s = static_cast<nsISupports*>(p);
     NS_ASSERTION(CheckForRightISupports(s),
                  "not the nsISupports pointer we expect");
     nsXPCWrappedJS *tmp = Downcast(s);
 
     nsrefcnt refcnt = tmp->mRefCnt.get();
-#ifdef DEBUG_CC
-    char name[72];
-    if (tmp->GetClass())
-      JS_snprintf(name, sizeof(name), "nsXPCWrappedJS (%s)",
-                  tmp->GetClass()->GetInterfaceName());
-    else
-      JS_snprintf(name, sizeof(name), "nsXPCWrappedJS");
-    cb.DescribeNode(RefCounted, refcnt, sizeof(nsXPCWrappedJS), name);
-#else
-    cb.DescribeNode(RefCounted, refcnt);
-#endif
+    if (cb.WantDebugInfo()) {
+        char name[72];
+        if (tmp->GetClass())
+            JS_snprintf(name, sizeof(name), "nsXPCWrappedJS (%s)",
+                        tmp->GetClass()->GetInterfaceName());
+        else
+            JS_snprintf(name, sizeof(name), "nsXPCWrappedJS");
+        cb.DescribeNode(RefCounted, refcnt, sizeof(nsXPCWrappedJS), name);
+    } else {
+        cb.DescribeNode(RefCounted, refcnt, sizeof(nsXPCWrappedJS),
+                        "nsXPCWrappedJS");
+    }
 
     // nsXPCWrappedJS keeps its own refcount artificially at or above 1, see the
     // comment above nsXPCWrappedJS::AddRef.
     cb.NoteXPCOMChild(s);
 
     if(refcnt > 1)
         // nsXPCWrappedJS roots its mJSObj when its refcount is > 1, see
         // the comment above nsXPCWrappedJS::AddRef.
diff --git a/js/src/xpconnect/src/xpcwrappednative.cpp b/js/src/xpconnect/src/xpcwrappednative.cpp
--- a/js/src/xpconnect/src/xpcwrappednative.cpp
+++ b/js/src/xpconnect/src/xpcwrappednative.cpp
@@ -64,30 +64,31 @@ NS_CYCLE_COLLECTION_CLASSNAME(XPCWrapped
 NS_IMETHODIMP
 NS_CYCLE_COLLECTION_CLASSNAME(XPCWrappedNative)::Traverse(void *p,
                                                           nsCycleCollectionTraversalCallback &cb)
 {
     XPCWrappedNative *tmp = static_cast<XPCWrappedNative*>(p);
     if(!tmp->IsValid())
         return NS_OK;
 
-#ifdef DEBUG_CC
-    char name[72];
-    XPCNativeScriptableInfo* si = tmp->GetScriptableInfo();
-    if(si)
-        JS_snprintf(name, sizeof(name), "XPCWrappedNative (%s)",
-                    si->GetJSClass()->name);
-    else
-        JS_snprintf(name, sizeof(name), "XPCWrappedNative");
+    if (NS_UNLIKELY(cb.WantDebugInfo())) {
+        char name[72];
+        XPCNativeScriptableInfo* si = tmp->GetScriptableInfo();
+        if(si)
+            JS_snprintf(name, sizeof(name), "XPCWrappedNative (%s)",
+                        si->GetJSClass()->name);
+        else
+            JS_snprintf(name, sizeof(name), "XPCWrappedNative");
 
-    cb.DescribeNode(RefCounted, tmp->mRefCnt.get(), sizeof(XPCWrappedNative),
-                    name);
-#else
-    cb.DescribeNode(RefCounted, tmp->mRefCnt.get());
-#endif
+        cb.DescribeNode(RefCounted, tmp->mRefCnt.get(),
+                        sizeof(XPCWrappedNative), name);
+    } else {
+        cb.DescribeNode(RefCounted, tmp->mRefCnt.get(),
+                        sizeof(XPCWrappedNative), "XPCWrappedNative");
+    }
 
     if(tmp->mRefCnt.get() > 1) {
 
         // If our refcount is > 1, our reference to the flat JS object is
         // considered "strong", and we're going to traverse it. 
         //
         // If our refcount is <= 1, our reference to the flat JS object is
         // considered "weak", and we're *not* going to traverse it.
diff --git a/js/src/xpconnect/src/xpcwrappednativescope.cpp b/js/src/xpconnect/src/xpcwrappednativescope.cpp
--- a/js/src/xpconnect/src/xpcwrappednativescope.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativescope.cpp
@@ -407,21 +407,21 @@ WrappedNativeSuspecter(JSDHashTable *tab
 {
     SuspectClosure* closure = static_cast<SuspectClosure*>(arg);
     XPCWrappedNative* wrapper = ((Native2WrappedNativeMap::Entry*)hdr)->value;
     if(wrapper->IsValid())
     {
         NS_ASSERTION(NS_IsMainThread(), 
                      "Suspecting wrapped natives from non-main thread");
 
-#ifndef DEBUG_CC
-        // Only record objects that might be part of a cycle as roots.
-        if(!JS_IsAboutToBeFinalized(closure->cx, wrapper->GetFlatJSObject()))
+        // Only record objects that might be part of a cycle as roots, unless
+        // the callback wants all traces (a debug feature).
+        if(!(closure->cb.WantAllTraces()) && 
+           !JS_IsAboutToBeFinalized(closure->cx, wrapper->GetFlatJSObject()))
             return JS_DHASH_NEXT;
-#endif
 
         closure->cb.NoteRoot(nsIProgrammingLanguage::JAVASCRIPT,
                              wrapper->GetFlatJSObject(),
                              nsXPConnect::GetXPConnect());
     }
 
     return JS_DHASH_NEXT;
 }
diff --git a/layout/build/nsLayoutStatics.cpp b/layout/build/nsLayoutStatics.cpp
--- a/layout/build/nsLayoutStatics.cpp
+++ b/layout/build/nsLayoutStatics.cpp
@@ -234,23 +234,21 @@ nsLayoutStatics::Initialize()
   }
 
   rv = nsDOMStorageManager::Initialize();
   if (NS_FAILED(rv)) {
     NS_ERROR("Could not initialize nsDOMStorageManager");
     return rv;
   }
 
-#ifndef DEBUG_CC
   rv = nsCCUncollectableMarker::Init();
   if (NS_FAILED(rv)) {
     NS_ERROR("Could not initialize nsCCUncollectableMarker");
     return rv;
   }
-#endif
 
   nsCSSRuleProcessor::Startup();
 
 #ifdef MOZ_XUL
   rv = nsXULPopupManager::Init();
   if (NS_FAILED(rv)) {
     NS_ERROR("Could not initialize nsXULPopupManager");
     return rv;
diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -147,16 +147,24 @@
 
 #include <stdio.h>
 #include <string.h>
 #ifdef WIN32
 #include <io.h>
 #include <process.h>
 #endif
 
+#ifdef DEBUG_CC
+#define IF_DEBUG_CC_PARAM(_p) , _p
+#define IF_DEBUG_CC_ONLY_PARAM(_p) _p
+#else
+#define IF_DEBUG_CC_PARAM(_p)
+#define IF_DEBUG_CC_ONLY_PARAM(_p)
+#endif
+
 #define DEFAULT_SHUTDOWN_COLLECTIONS 5
 #ifdef DEBUG_CC
 #define SHUTDOWN_COLLECTIONS(params) params.mShutdownCollections
 #else
 #define SHUTDOWN_COLLECTIONS(params) DEFAULT_SHUTDOWN_COLLECTIONS
 #endif
 
 // Various parameters of this collector can be tuned using environment
@@ -1284,42 +1292,41 @@ public:
     }
 #endif
     void Traverse(PtrInfo* aPtrInfo);
 
     // nsCycleCollectionTraversalCallback methods.
     NS_IMETHOD_(void) NoteXPCOMRoot(nsISupports *root);
 
 private:
-#ifdef DEBUG_CC
     NS_IMETHOD_(void) DescribeNode(CCNodeType type, nsrefcnt refCount,
                                    size_t objSz, const char *objName);
-#else
-    NS_IMETHOD_(void) DescribeNode(CCNodeType type, nsrefcnt refCount);
-#endif
     NS_IMETHOD_(void) NoteRoot(PRUint32 langID, void *child,
                                nsCycleCollectionParticipant* participant);
     NS_IMETHOD_(void) NoteXPCOMChild(nsISupports *child);
     NS_IMETHOD_(void) NoteNativeChild(void *child,
                                      nsCycleCollectionParticipant *participant);
     NS_IMETHOD_(void) NoteScriptChild(PRUint32 langID, void *child);
-#ifdef DEBUG_CC
     NS_IMETHOD_(void) NoteNextEdgeName(const char* name);
-#endif
 };
 
 GCGraphBuilder::GCGraphBuilder(GCGraph &aGraph,
                                nsCycleCollectionLanguageRuntime **aRuntimes)
     : mNodeBuilder(aGraph.mNodes),
       mEdgeBuilder(aGraph.mEdges),
       mRuntimes(aRuntimes)
 {
     if (!PL_DHashTableInit(&mPtrToNodeMap, &PtrNodeOps, nsnull,
                            sizeof(PtrToNodeEntry), 32768))
         mPtrToNodeMap.ops = nsnull;
+#ifdef DEBUG_CC
+    // Do we need to set these all the time?
+    mFlags |= nsCycleCollectionTraversalCallback::WANT_DEBUG_INFO |
+              nsCycleCollectionTraversalCallback::WANT_ALL_TRACES;
+#endif
 }
 
 GCGraphBuilder::~GCGraphBuilder()
 {
     if (mPtrToNodeMap.ops)
         PL_DHashTableFinish(&mPtrToNodeMap);
 }
 
@@ -1399,22 +1406,18 @@ GCGraphBuilder::NoteRoot(PRUint32 langID
         Fault("adding root for unregistered language", root);
         return;
     }
 
     AddNode(root, participant, langID);
 }
 
 NS_IMETHODIMP_(void)
-#ifdef DEBUG_CC
 GCGraphBuilder::DescribeNode(CCNodeType type, nsrefcnt refCount,
                              size_t objSz, const char *objName)
-#else
-GCGraphBuilder::DescribeNode(CCNodeType type, nsrefcnt refCount)
-#endif
 {
 #ifdef DEBUG_CC
     mCurrPi->mBytes = objSz;
     mCurrPi->mName = PL_strdup(objName);
 #endif
 
     if (type == RefCounted) {
         if (refCount == 0 || refCount == PR_UINT32_MAX)
@@ -1512,23 +1515,23 @@ GCGraphBuilder::NoteScriptChild(PRUint32
         return;
     mEdgeBuilder.Add(childPi);
 #ifdef DEBUG_CC
     mCurrPi->mEdgeNames.AppendElement(edgeName);
 #endif
     ++childPi->mInternalRefs;
 }
 
-#ifdef DEBUG_CC
 NS_IMETHODIMP_(void)
 GCGraphBuilder::NoteNextEdgeName(const char* name)
 {
+#ifdef DEBUG_CC
     mNextEdgeName = name;
+#endif
 }
-#endif
 
 static PRBool
 AddPurpleRoot(GCGraphBuilder &builder, nsISupports *root)
 {
     root = canonicalize(root);
     NS_ASSERTION(root,
                  "Don't add objects that don't participate in collection!");
 
diff --git a/xpcom/glue/nsCycleCollectionParticipant.h b/xpcom/glue/nsCycleCollectionParticipant.h
--- a/xpcom/glue/nsCycleCollectionParticipant.h
+++ b/xpcom/glue/nsCycleCollectionParticipant.h
@@ -39,24 +39,16 @@
 #define nsCycleCollectionParticipant_h__
 
 #include "nsISupports.h"
 
 // NOTE: If you use header files to define DEBUG_CC, you must do so here
 // *and* in nsCycleCollector.h
 //#define DEBUG_CC
 
-#ifdef DEBUG_CC
-#define IF_DEBUG_CC_PARAM(_p) , _p
-#define IF_DEBUG_CC_ONLY_PARAM(_p) _p
-#else
-#define IF_DEBUG_CC_PARAM(_p)
-#define IF_DEBUG_CC_ONLY_PARAM(_p)
-#endif
-
 #define NS_CYCLECOLLECTIONPARTICIPANT_IID                                      \
 {                                                                              \
     0x9674489b,                                                                \
     0x1f6f,                                                                    \
     0x4550,                                                                    \
     { 0xa7, 0x30, 0xcc, 0xae, 0xdd, 0x10, 0x4c, 0xf9 }                         \
 }
 
@@ -92,37 +84,54 @@ class nsCycleCollectionParticipant;
 enum CCNodeType { RefCounted, GCMarked, GCUnmarked };
 
 class NS_NO_VTABLE nsCycleCollectionTraversalCallback
 {
 public:
     // If type is RefCounted you must call DescribeNode() with an accurate
     // refcount, otherwise cycle collection will fail, and probably crash.
     // If type is not refcounted then the refcount will be ignored.
-#ifdef DEBUG_CC
+    // If the callback cares about objsz or objname, it should
+    // put WANT_DEBUG_INFO in mFlags.
     NS_IMETHOD_(void) DescribeNode(CCNodeType type,
                                    nsrefcnt refcount,
                                    size_t objsz,
                                    const char *objname) = 0;
-#else
-    NS_IMETHOD_(void) DescribeNode(CCNodeType type,
-                                   nsrefcnt refcount) = 0;
-#endif
     NS_IMETHOD_(void) NoteXPCOMRoot(nsISupports *root) = 0;
     NS_IMETHOD_(void) NoteRoot(PRUint32 langID, void *root,
                                nsCycleCollectionParticipant* helper) = 0;
     NS_IMETHOD_(void) NoteScriptChild(PRUint32 langID, void *child) = 0;
     NS_IMETHOD_(void) NoteXPCOMChild(nsISupports *child) = 0;
     NS_IMETHOD_(void) NoteNativeChild(void *child,
                                       nsCycleCollectionParticipant *helper) = 0;
-#ifdef DEBUG_CC
+
     // Give a name to the edge associated with the next call to
     // NoteScriptChild, NoteXPCOMChild, or NoteNativeChild.
+    // Callbacks who care about this should set WANT_DEBUG_INFO in the
+    // flags.
     NS_IMETHOD_(void) NoteNextEdgeName(const char* name) = 0;
-#endif
+
+    enum {
+        // Values for flags:
+
+        // Caller should pass useful objsz and objname to DescribeNode
+        // and should call NoteNextEdgeName.
+        WANT_DEBUG_INFO = (1<<0),
+
+        // Caller should not skip objects that we know will be
+        // uncollectable.
+        WANT_ALL_TRACES = (1<<1)
+    };
+    PRUint32 Flags() const { return mFlags; }
+    PRBool WantDebugInfo() const { return (mFlags & WANT_DEBUG_INFO) != 0; }
+    PRBool WantAllTraces() const { return (mFlags & WANT_ALL_TRACES) != 0; }
+protected:
+    nsCycleCollectionTraversalCallback() : mFlags(0) {}
+
+    PRUint32 mFlags;
 };
 
 class NS_NO_VTABLE nsCycleCollectionParticipant
 {
 public:
     NS_DECLARE_STATIC_IID_ACCESSOR(NS_CYCLECOLLECTIONPARTICIPANT_IID)
 
     NS_IMETHOD Traverse(void *p, nsCycleCollectionTraversalCallback &cb) = 0;
@@ -316,23 +325,18 @@ public:
     return NS_OK;                                                              \
   }
 
 
 ///////////////////////////////////////////////////////////////////////////////
 // Helpers for implementing nsCycleCollectionParticipant::Traverse
 ///////////////////////////////////////////////////////////////////////////////
 
-#ifdef DEBUG_CC
 #define NS_IMPL_CYCLE_COLLECTION_DESCRIBE(_class, _refcnt)                     \
     cb.DescribeNode(RefCounted, _refcnt, sizeof(_class), #_class);
-#else
-#define NS_IMPL_CYCLE_COLLECTION_DESCRIBE(_class, _refcnt)                     \
-    cb.DescribeNode(RefCounted, _refcnt);
-#endif
 
 #define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_REFCNT(_class, _refcnt)        \
   NS_IMETHODIMP                                                                \
   NS_CYCLE_COLLECTION_CLASSNAME(_class)::Traverse                              \
                          (void *p,                                             \
                           nsCycleCollectionTraversalCallback &cb)              \
   {                                                                            \
     nsISupports *s = static_cast<nsISupports*>(p);                             \
@@ -369,23 +373,22 @@ public:
   NS_IMETHODIMP                                                                \
   NS_CYCLE_COLLECTION_CLASSNAME(_class)::Traverse                              \
                          (void *p,                                             \
                           nsCycleCollectionTraversalCallback &cb)              \
   {                                                                            \
     _class *tmp = static_cast<_class*>(p);                                     \
     NS_IMPL_CYCLE_COLLECTION_DESCRIBE(_class, tmp->mRefCnt.get())
 
-#ifdef DEBUG_CC
-  #define NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(_cb, _name)                       \
-    PR_BEGIN_MACRO (_cb).NoteNextEdgeName(_name); PR_END_MACRO
-#else
-  #define NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(_cb, _name)                       \
-    PR_BEGIN_MACRO PR_END_MACRO
-#endif
+#define NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(_cb, _name)                         \
+  PR_BEGIN_MACRO                                                               \
+    if (NS_UNLIKELY((_cb).WantDebugInfo())) {                                  \
+      (_cb).NoteNextEdgeName(_name);                                           \
+    }                                                                          \
+  PR_END_MACRO
 
 #define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(_field)                       \
   PR_BEGIN_MACRO                                                               \
     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, #_field);                           \
     cb.NoteXPCOMChild(tmp->_field);                                            \
   PR_END_MACRO;
 
 #define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(_field)                     \
