From: L. David Baron <dbaron@dbaron.org>

Revert changes in 0ff87d9d2d73 (Bug 541434) and adjust tests appropriately.  (Bug 569646)

diff --git a/layout/reftests/css-parsing/invalid-url-handling.xhtml b/layout/reftests/css-parsing/invalid-url-handling.xhtml
--- a/layout/reftests/css-parsing/invalid-url-handling.xhtml
+++ b/layout/reftests/css-parsing/invalid-url-handling.xhtml
@@ -67,41 +67,37 @@
   /* perfectly good URI token (image is a 404, though) */
   #eleven { background: url([) green; }
   </style>
   <style type="text/css">
   /* not a URI token, but brace matching should work */
   #twelve { background: url({"")}); background-color: green; }
   </style>
   <style type="text/css">
-  /* not a URI token, but brace matching should work */
-  #thirteen { background: url(["")]); background-color: green; }
+  /* invalid URI token absorbs the [ */
+  #thirteen { background: url([""); background-color: green; }
   </style>
   <style type="text/css">
   /* not a URI token; the opening ( is never matched */
   #fourteen { background-color: green; }
   #foo { background: url(() }
   #fourteen { background-color: red; }
   </style>
-  /* The next three tests test that when things don't match a URI
-     token, brace-matching is done properly.  (The first is a reference.) */
+  /* The next three tests test that invalid URI tokens absorb [ and { */
   <style type="text/css">
-  #fifteen { background-color: red }
   #foo { background: url(a()); }
   #fifteen { background-color: green }
   </style>
   <style type="text/css">
+  #foo { background: url([()); }
   #sixteen { background-color: green }
-  #foo { background: url([()); }
-  #sixteen { background-color: red }
   </style>
   <style type="text/css">
+  #foo { background: url({()); }
   #seventeen { background-color: green }
-  #foo { background: url([()); }
-  #seventeen { background-color: red }
   </style>
  </head>
  <body>
   <div id="one">This should have a green background</div>
   <div id="two">This should have a green background</div>
   <div id="three">This should have a green background</div>
   <div id="four">This should have a green background</div>
   <div id="five">This should have a green background</div>
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -297,17 +297,16 @@ protected:
     NS_PRECONDITION(!mParsingCompoundProperty, "Bad initial state");
   }
 
   PRBool ExpectSymbol(PRUnichar aSymbol, PRBool aSkipWS);
   PRBool ExpectEndProperty();
   PRBool CheckEndProperty();
   nsSubstring* NextIdent();
   void SkipUntil(PRUnichar aStopSymbol);
-  void SkipUntilStack(nsAutoTArray<PRUnichar, 16> &aStack);
   void SkipUntilOneOf(const PRUnichar* aStopSymbolChars);
   void SkipRuleSet(PRBool aInsideBraces);
   PRBool SkipAtRule();
   PRBool SkipDeclaration(PRBool aCheckForBraces);
 
   PRBool PushGroup(nsICSSGroupRule* aRule);
   void PopGroup(void);
 
@@ -1351,38 +1350,19 @@ CSSParserImpl::GetURLInParens(nsString& 
       return PR_FALSE;
     }
   } while (eCSSToken_WhiteSpace == mToken.mType);
 
   aURL = mToken.mIdent;
 
   if ((eCSSToken_String != mToken.mType && eCSSToken_URL != mToken.mType) ||
       !ExpectSymbol(')', PR_TRUE)) {
-    // in the failure case, we have to match parentheses, as if this
-    // weren't treated as a URL token by the tokenization
-
-    nsAutoTArray<PRUnichar, 16> stack;
-    stack.AppendElement(')');
-    if (eCSSToken_URL == mToken.mType || eCSSToken_InvalidURL == mToken.mType) {
-      for (PRUint32 i = 0, iEnd = mToken.mIdent.Length(); i < iEnd; ++i) {
-        PRUnichar symbol = mToken.mIdent[i];
-        NS_ASSERTION(symbol != '(' && symbol != ')',
-                     "should not be in eCSSToken_URL");
-        if ('[' == symbol) {
-          stack.AppendElement(']');
-        } else if ('{' == symbol) {
-          stack.AppendElement('}');
-        } else if ((']' == symbol && stack[stack.Length() - 1] == '[') ||
-                   ('}' == symbol && stack[stack.Length() - 1] == '{')) {
-          stack.RemoveElementAt(stack.Length() - 1);
-        }
-      }
-    }
-    SkipUntilStack(stack);
-
+    // in the failure case, we do not have to match parentheses, since
+    // this is now an invalid URL token.
+    SkipUntil(')');
     return PR_FALSE;
   }
 
   return PR_TRUE;
 }
 
 void
 CSSParserImpl::UngetToken()
@@ -2269,50 +2249,44 @@ CSSParserImpl::ParsePageRule(RuleAppendF
 {
   // XXX not yet implemented
   return PR_FALSE;
 }
 
 void
 CSSParserImpl::SkipUntil(PRUnichar aStopSymbol)
 {
+  nsCSSToken* tk = &mToken;
   nsAutoTArray<PRUnichar, 16> stack;
   stack.AppendElement(aStopSymbol);
-  SkipUntilStack(stack);
-}
-
-void
-CSSParserImpl::SkipUntilStack(nsAutoTArray<PRUnichar, 16>& aStack)
-{
-  nsCSSToken* tk = &mToken;
   for (;;) {
     if (!GetToken(PR_TRUE)) {
       break;
     }
     if (eCSSToken_Symbol == tk->mType) {
       PRUnichar symbol = tk->mSymbol;
-      PRUint32 stackTopIndex = aStack.Length() - 1;
-      if (symbol == aStack.ElementAt(stackTopIndex)) {
-        aStack.RemoveElementAt(stackTopIndex);
+      PRUint32 stackTopIndex = stack.Length() - 1;
+      if (symbol == stack.ElementAt(stackTopIndex)) {
+        stack.RemoveElementAt(stackTopIndex);
         if (stackTopIndex == 0) {
           break;
         }
 
       // Just handle out-of-memory by parsing incorrectly.  It's
       // highly unlikely we're dealing with a legitimate style sheet
       // anyway.
       } else if ('{' == symbol) {
-        aStack.AppendElement('}');
+        stack.AppendElement('}');
       } else if ('[' == symbol) {
-        aStack.AppendElement(']');
+        stack.AppendElement(']');
       } else if ('(' == symbol) {
-        aStack.AppendElement(')');
+        stack.AppendElement(')');
       }
     } else if (eCSSToken_Function == tk->mType) {
-      aStack.AppendElement(')');
+      stack.AppendElement(')');
     }
   }
 }
 
 void
 CSSParserImpl::SkipUntilOneOf(const PRUnichar* aStopSymbolChars)
 {
   nsCSSToken* tk = &mToken;
