From: L. David Baron <dbaron@dbaron.org>

Revert changes in 0ff87d9d2d73 (Bug 541434) and adjust tests appropriately.  (Bug 569646)

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -297,17 +297,16 @@ protected:
     NS_PRECONDITION(!mParsingCompoundProperty, "Bad initial state");
   }
 
   PRBool ExpectSymbol(PRUnichar aSymbol, PRBool aSkipWS);
   PRBool ExpectEndProperty();
   PRBool CheckEndProperty();
   nsSubstring* NextIdent();
   void SkipUntil(PRUnichar aStopSymbol);
-  void SkipUntilStack(nsAutoTArray<PRUnichar, 16> &aStack);
   void SkipUntilOneOf(const PRUnichar* aStopSymbolChars);
   void SkipRuleSet(PRBool aInsideBraces);
   PRBool SkipAtRule();
   PRBool SkipDeclaration(PRBool aCheckForBraces);
 
   PRBool PushGroup(nsICSSGroupRule* aRule);
   void PopGroup(void);
 
@@ -1354,35 +1353,20 @@ CSSParserImpl::GetURLInParens(nsString& 
 
   aURL = mToken.mIdent;
 
   if ((eCSSToken_String != mToken.mType && eCSSToken_URL != mToken.mType) ||
       !ExpectSymbol(')', PR_TRUE)) {
     // in the failure case, we have to match parentheses, as if this
     // weren't treated as a URL token by the tokenization
 
-    nsAutoTArray<PRUnichar, 16> stack;
-    stack.AppendElement(')');
-    if (eCSSToken_URL == mToken.mType || eCSSToken_InvalidURL == mToken.mType) {
-      for (PRUint32 i = 0, iEnd = mToken.mIdent.Length(); i < iEnd; ++i) {
-        PRUnichar symbol = mToken.mIdent[i];
-        NS_ASSERTION(symbol != '(' && symbol != ')',
-                     "should not be in eCSSToken_URL");
-        if ('[' == symbol) {
-          stack.AppendElement(']');
-        } else if ('{' == symbol) {
-          stack.AppendElement('}');
-        } else if ((']' == symbol && stack[stack.Length() - 1] == '[') ||
-                   ('}' == symbol && stack[stack.Length() - 1] == '{')) {
-          stack.RemoveElementAt(stack.Length() - 1);
-        }
-      }
-    }
-    SkipUntilStack(stack);
-
+    // XXX We really need to push aURL back into the buffer before this
+    // SkipUntil, but we won't do it as it will make no difference anyway,
+    // and it will make parsing slower.
+    SkipUntil(')');
     return PR_FALSE;
   }
 
   return PR_TRUE;
 }
 
 void
 CSSParserImpl::UngetToken()
@@ -2269,47 +2253,41 @@ CSSParserImpl::ParsePageRule(RuleAppendF
 {
   // XXX not yet implemented
   return PR_FALSE;
 }
 
 void
 CSSParserImpl::SkipUntil(PRUnichar aStopSymbol)
 {
+  nsCSSToken* tk = &mToken;
   nsAutoTArray<PRUnichar, 16> stack;
   stack.AppendElement(aStopSymbol);
-  SkipUntilStack(stack);
-}
-
-void
-CSSParserImpl::SkipUntilStack(nsAutoTArray<PRUnichar, 16>& aStack)
-{
-  nsCSSToken* tk = &mToken;
   for (;;) {
     if (!GetToken(PR_TRUE)) {
       break;
     }
     if (eCSSToken_Symbol == tk->mType) {
       PRUnichar symbol = tk->mSymbol;
-      PRUint32 stackTopIndex = aStack.Length() - 1;
-      if (symbol == aStack.ElementAt(stackTopIndex)) {
-        aStack.RemoveElementAt(stackTopIndex);
+      PRUint32 stackTopIndex = stack.Length() - 1;
+      if (symbol == stack.ElementAt(stackTopIndex)) {
+        stack.RemoveElementAt(stackTopIndex);
         if (stackTopIndex == 0) {
           break;
         }
 
       // Just handle out-of-memory by parsing incorrectly.  It's
       // highly unlikely we're dealing with a legitimate style sheet
       // anyway.
       } else if ('{' == symbol) {
-        aStack.AppendElement('}');
+        stack.AppendElement('}');
       } else if ('[' == symbol) {
-        aStack.AppendElement(']');
+        stack.AppendElement(']');
       } else if ('(' == symbol) {
-        aStack.AppendElement(')');
+        stack.AppendElement(')');
       }
     } else if (eCSSToken_Function == tk->mType) {
       aStack.AppendElement(')');
     }
   }
 }
 
 void
