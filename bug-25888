Ensure lines wrapping around floats check more than just the top pixel of the line.  b=25888

diff -r 55479730bc38 layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp	Mon Feb 12 16:51:35 2007 -0800
+++ b/layout/generic/nsBlockFrame.cpp	Tue Feb 13 18:16:13 2007 -0800
@@ -1554,6 +1554,7 @@ nsBlockFrame::PropagateFloatDamage(nsBlo
     //    XXXPerf: An optimization: if the line was and is completely
     //    impacted by a float and the float hasn't changed size,
     //    then we don't need to mark the line dirty.
+    // PASS HEIGHT HERE!
     aState.GetAvailableSpace(aLine->mBounds.y + aDeltaY, PR_FALSE);
     PRBool wasImpactedByFloat = aLine->IsImpactedByFloat();
     PRBool isImpactedByFloat = aState.IsImpactedByFloat();
diff -r 55479730bc38 layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp	Mon Feb 12 16:51:35 2007 -0800
+++ b/layout/generic/nsBlockReflowState.cpp	Tue Feb 13 18:17:53 2007 -0800
@@ -290,7 +290,7 @@ nsBlockReflowState::ComputeBlockAvailSpa
 }
 
 void
-nsBlockReflowState::GetAvailableSpace(nscoord aY, PRBool aRelaxHeightConstraint)
+nsBlockReflowState::GetAvailableSpace(nscoord aY, nscoord aHeight, PRBool aRelaxHeightConstraint)
 {
 #ifdef DEBUG
   // Verify that the caller setup the coordinate system properly
@@ -546,7 +546,7 @@ nsBlockReflowState::AddFloat(nsLineLayou
                  "If we asked for force-fit, it should have been placed");
     if (placed) {
       // Pass on updated available space to the current inline reflow engine
-      GetAvailableSpace(mY, forceFit);
+      GetAvailableSpace(mY, 0, forceFit);
       aLineLayout.UpdateBand(mAvailSpaceRect.x + BorderPadding().left, mY,
                              mAvailSpaceRect.width,
                              mAvailSpaceRect.height,
@@ -609,6 +609,10 @@ nsBlockReflowState::CanPlaceFloat(const 
       // At this point we know that there is enough horizontal space for
       // the float (somewhere). Lets see if there is enough vertical
       // space.
+      // XXXldb Why would there ever not be?  There can never be any
+      // floats below the current position that are already placed.  And
+      // I really hope we've handled the page/column breaking case
+      // already.
       if (mAvailSpaceRect.height < aFloatSize.height) {
         // The available height is too short. However, its possible that
         // there is enough open space below which is not impacted by a
@@ -658,7 +662,7 @@ nsBlockReflowState::CanPlaceFloat(const 
           }
 
           mY += mAvailSpaceRect.height;
-          GetAvailableSpace(mY, aForceFit);
+          GetAvailableSpace(mY, 0, aForceFit);
 
           if (0 == mBand.GetFloatCount()) {
             // Winner. This band has no floats on it, therefore
@@ -671,6 +675,7 @@ nsBlockReflowState::CanPlaceFloat(const 
           // coordinates must be entirely in the available space.
           if ((xa < mAvailSpaceRect.x) || (xb > mAvailSpaceRect.XMost())) {
             // The float can't go here.
+            // XXXldb This shouldn't be possible.
             result = PR_FALSE;
             break;
           }
@@ -686,7 +691,7 @@ nsBlockReflowState::CanPlaceFloat(const 
         // Restore Y coordinate and available space information
         // regardless of the outcome.
         mY = saveY;
-        GetAvailableSpace(mY, aForceFit);
+        GetAvailableSpace(mY, 0, aForceFit);
       }
     }
   }
@@ -727,7 +732,7 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
     mY = ClearFloats(mY, floatDisplay->mBreakType);
   }
     // Get the band of available space
-  GetAvailableSpace(mY, aForceFit);
+  GetAvailableSpace(mY, 0, aForceFit);
 
   NS_ASSERTION(floatFrame->GetParent() == mBlock,
                "Float frame has wrong parent");
@@ -774,7 +779,7 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
           eCompatibility_NavQuirks != mPresContext->CompatibilityMode() ) {
 
       mY += mAvailSpaceRect.height;
-      GetAvailableSpace(mY, aForceFit);
+      GetAvailableSpace(mY, 0, aForceFit);
     } else {
       // This quirk matches the one in nsBlockFrame::ReflowFloat
       // IE handles float tables in a very special way
@@ -813,7 +818,7 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
 
       // the table does not fit anymore in this line so advance to next band 
       mY += mAvailSpaceRect.height;
-      GetAvailableSpace(mY, aForceFit);
+      GetAvailableSpace(mY, 0, aForceFit);
       // reflow the float again now since we have more space
       // XXXldb We really don't need to Reflow in a loop, we just need
       // to ComputeSize in a loop (once ComputeSize depends on
diff -r 55479730bc38 layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h	Mon Feb 12 16:51:35 2007 -0800
+++ b/layout/generic/nsBlockReflowState.h	Tue Feb 13 18:17:09 2007 -0800
@@ -81,8 +81,9 @@ public:
    * available space is relative to our coordinate system (0,0) is our
    * upper left corner.
    */
-  void GetAvailableSpace() { GetAvailableSpace(mY, PR_FALSE); }
-  void GetAvailableSpace(nscoord aY, PRBool aRelaxHeightConstraint);
+  void GetAvailableSpace(nscoord aHeight = 0)
+    { GetAvailableSpace(mY, aHeight, PR_FALSE); }
+  void GetAvailableSpace(nscoord aY, nscoord aHeight, PRBool aRelaxHeightConstraint);
 
   /*
    * The following functions all return PR_TRUE if they were able to
