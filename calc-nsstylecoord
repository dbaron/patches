From: L. David Baron <dbaron@dbaron.org>

Add storage for calc() expressions to nsStyleCoord.  (Bug 363249)

diff --git a/layout/style/nsStyleCoord.cpp b/layout/style/nsStyleCoord.cpp
--- a/layout/style/nsStyleCoord.cpp
+++ b/layout/style/nsStyleCoord.cpp
@@ -77,22 +77,28 @@ nsStyleCoord::nsStyleCoord(float aValue,
   if (aUnit < eStyleUnit_Percent || aUnit >= eStyleUnit_Coord) {
     NS_NOTREACHED("not a float value");
     Reset();
   } else {
     mValue.mFloat = aValue;
   }
 }
 
+// FIXME: In C++0x we can rely on the default copy constructor since
+// default copy construction is defined properly for unions.  But when
+// can we actually use that?  (It seems to work in gcc 4.4.)
 nsStyleCoord& nsStyleCoord::operator=(const nsStyleCoord& aCopy)
 {
   mUnit = aCopy.mUnit;
   if ((eStyleUnit_Percent <= mUnit) && (mUnit < eStyleUnit_Coord)) {
     mValue.mFloat = aCopy.mValue.mFloat;
   }
+  else if (IsArrayValue()) {
+    mValue.mPointer = aCopy.mValue.mPointer;
+  }
   else {
     mValue.mInt = aCopy.mValue.mInt;
   }
   return *this;
 }
 
 PRBool nsStyleCoord::operator==(const nsStyleCoord& aOther) const
 {
@@ -153,16 +159,27 @@ void nsStyleCoord::SetAngleValue(float a
     mUnit = aUnit;
     mValue.mFloat = aValue;
   } else {
     NS_NOTREACHED("not an angle value");
     Reset();
   }
 }
 
+void nsStyleCoord::SetArrayValue(Array* aValue, nsStyleUnit aUnit)
+{
+  mUnit = aUnit;
+  if (IsArrayValue()) {
+    mValue.mPointer = aValue;
+  } else {
+    NS_NOTREACHED("not a pointer value");
+    Reset();
+  }
+}
+
 void nsStyleCoord::SetNormalValue()
 {
   mUnit = eStyleUnit_Normal;
   mValue.mInt = 0;
 }
 
 void nsStyleCoord::SetAutoValue()
 {
diff --git a/layout/style/nsStyleCoord.h b/layout/style/nsStyleCoord.h
--- a/layout/style/nsStyleCoord.h
+++ b/layout/style/nsStyleCoord.h
@@ -54,22 +54,36 @@ enum nsStyleUnit {
   eStyleUnit_None         = 3,      // (no value)
   eStyleUnit_Percent      = 10,     // (float) 1.0 == 100%
   eStyleUnit_Factor       = 11,     // (float) a multiplier
   eStyleUnit_Degree       = 12,     // (float) angle in degrees
   eStyleUnit_Grad         = 13,     // (float) angle in grads
   eStyleUnit_Radian       = 14,     // (float) angle in radians
   eStyleUnit_Coord        = 20,     // (nscoord) value is twips
   eStyleUnit_Integer      = 30,     // (int) value is simple integer
-  eStyleUnit_Enumerated   = 32      // (int) value has enumerated meaning
+  eStyleUnit_Enumerated   = 32,     // (int) value has enumerated meaning
+  // The following are all of the eCSSUnit_Calc_* types (but not
+  // eCSSUnit_Calc itself, since we don't need to distinguish
+  // calc(min()) from min() in compute dstyle).  They are all weak
+  // pointers to a calc tree allocated by nsStyleContext::Alloc.
+  // NOTE:  They are in the same order as the eCSSUnit_Calc_* values so
+  // that converting between the two sets is just addition/subtraction.
+  eStyleUnit_Calc_Plus    = 40,     // (Array*) + node within calc()
+  eStyleUnit_Calc_Minus   = 41,     // (Array*) - within calc
+  eStyleUnit_Calc_Times_L = 42,     // (Array*) num * val within calc
+  eStyleUnit_Calc_Times_R = 43,     // (Array*) val * num within calc
+  eStyleUnit_Calc_Divided = 44,     // (Array*) / within calc
+  eStyleUnit_Calc_Minimum = 45,     // (Array*) min() within calc
+  eStyleUnit_Calc_Maximum = 46      // (Array*) max() within calc
 };
 
 typedef union {
   PRInt32     mInt;   // nscoord is a PRInt32 for now
   float       mFloat;
+  void*       mPointer;
 } nsStyleUnion;
 
 /**
  * Class that hold a single size specification used by the style
  * system.  The size specification consists of two parts -- a number
  * and a unit.  The number is an integer, a floating point value, an
  * nscoord, or undefined, and the unit is an nsStyleUnit.  Checking
  * the unit is a must before asking for the value in any particular
@@ -96,33 +110,43 @@ public:
     NS_ASSERTION(mUnit != eStyleUnit_Null, "reading uninitialized value");
     return mUnit;
   }
 
   PRBool IsAngleValue() const {
     return eStyleUnit_Degree <= mUnit && mUnit <= eStyleUnit_Radian;
   }
 
+  PRBool IsCalcUnit() const {
+    return eStyleUnit_Calc_Plus <= mUnit && mUnit <= eStyleUnit_Calc_Maximum;
+  }
+
+  PRBool IsArrayValue() const {
+    return IsCalcUnit();
+  }
+
   nscoord     GetCoordValue() const;
   PRInt32     GetIntValue() const;
   float       GetPercentValue() const;
   float       GetFactorValue() const;
   float       GetAngleValue() const;
   double      GetAngleValueInRadians() const;
+  Array*      GetArrayValue() const;
   void        GetUnionValue(nsStyleUnion& aValue) const;
 
   void  Reset();  // sets to null
   void  SetCoordValue(nscoord aValue);
   void  SetIntValue(PRInt32 aValue, nsStyleUnit aUnit);
   void  SetPercentValue(float aValue);
   void  SetFactorValue(float aValue);
   void  SetAngleValue(float aValue, nsStyleUnit aUnit);
   void  SetNormalValue();
   void  SetAutoValue();
   void  SetNoneValue();
+  void  SetArrayValue(Array* aValue, nsStyleUnit aUnit);
 
 public: // FIXME: private!
   nsStyleUnit   mUnit;
   nsStyleUnion  mValue;
 };
 
 // A fixed-size array, that, like everything else in nsStyleCoord,
 // doesn't require that its destructors be called.
@@ -247,22 +271,28 @@ protected:
 // nsStyleCoord inlines
 //
 inline nsStyleCoord::nsStyleCoord(nscoord aValue, CoordConstructorType)
   : mUnit(eStyleUnit_Coord)
 {
   mValue.mInt = aValue;
 }
 
+// FIXME: In C++0x we can rely on the default copy constructor since
+// default copy construction is defined properly for unions.  But when
+// can we actually use that?  (It seems to work in gcc 4.4.)
 inline nsStyleCoord::nsStyleCoord(const nsStyleCoord& aCopy)
   : mUnit(aCopy.mUnit)
 {
   if ((eStyleUnit_Percent <= mUnit) && (mUnit < eStyleUnit_Coord)) {
     mValue.mFloat = aCopy.mValue.mFloat;
   }
+  else if (IsArrayValue()) {
+    mValue.mPointer = aCopy.mValue.mPointer;
+  }
   else {
     mValue.mInt = aCopy.mValue.mInt;
   }
 }
 
 inline nsStyleCoord::nsStyleCoord(const nsStyleUnion& aValue, nsStyleUnit aUnit)
   : mUnit(aUnit)
 {
@@ -321,16 +351,26 @@ inline float nsStyleCoord::GetAngleValue
   NS_ASSERTION(mUnit >= eStyleUnit_Degree &&
                mUnit <= eStyleUnit_Radian, "not an angle value");
   if (mUnit >= eStyleUnit_Degree && mUnit <= eStyleUnit_Radian) {
     return mValue.mFloat;
   }
   return 0.0f;
 }
 
+inline nsStyleCoord::Array* nsStyleCoord::GetArrayValue() const
+{
+  NS_ASSERTION(IsArrayValue(), "not a pointer value");
+  if (IsArrayValue()) {
+    return static_cast<Array*>(mValue.mPointer);
+  }
+  return nsnull;
+}
+
+
 inline void nsStyleCoord::GetUnionValue(nsStyleUnion& aValue) const
 {
   memcpy(&aValue, &mValue, sizeof(nsStyleUnion));
 }
 
 // -------------------------
 // nsStyleSides inlines
 //
