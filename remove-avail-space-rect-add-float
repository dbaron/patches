Switch away from nsBlockReflowState::mAvailSpaceRect in nsBlockReflowState::AddFloat.  (Bug 25888)

diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -601,19 +601,20 @@ nsBlockReflowState::AddFloat(nsLineLayou
     // force it to fit if we're at the top of the block and we can't
     // break before this
     PRBool forceFit = IsAdjacentWithTop() && !aLineLayout.LineIsBreakable();
     placed = FlowAndPlaceFloat(fc, &isLeftFloat, aReflowStatus, forceFit);
     NS_ASSERTION(placed || !forceFit,
                  "If we asked for force-fit, it should have been placed");
     if (forceFit || (placed && !NS_FRAME_IS_TRUNCATED(aReflowStatus))) {
       // Pass on updated available space to the current inline reflow engine
-      GetAvailableSpace(mY, forceFit);
-      nsRect availSpace(nsPoint(mAvailSpaceRect.x + BorderPadding().left, mY),
-                        mAvailSpaceRect.Size());
+      nsRect floatAvailSpace;
+      GetFloatAvailableSpace(mY, forceFit, floatAvailSpace);
+      nsRect availSpace(nsPoint(floatAvailSpace.x + BorderPadding().left, mY),
+                        floatAvailSpace.Size());
       aLineLayout.UpdateBand(availSpace, isLeftFloat,
                              aPlaceholder->GetOutOfFlowFrame());
       
       // Record this float in the current-line list
       mCurrentLineFloats.Append(fc);
       // If we can't break here, hide the fact that it's truncated
       // XXX We can probably do this more cleanly
       aReflowStatus &= ~NS_FRAME_TRUNCATED;
