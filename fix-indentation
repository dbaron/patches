From: L. David Baron <dbaron@dbaron.org>

Bug 898329 patch 9:  Fix indentation from previous patches.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1602,17 +1602,17 @@ VerifyStyleTree(nsPresContext* aPresCont
     }
   }
 
   // do additional contexts
   int32_t contextIndex = 0;
   for (nsStyleContext* extraContext;
        (extraContext = aFrame->GetAdditionalStyleContext(contextIndex));
        ++contextIndex) {
-      VerifyContextParent(aPresContext, aFrame, extraContext, context);
+    VerifyContextParent(aPresContext, aFrame, extraContext, context);
   }
 }
 
 void
 RestyleManager::DebugVerifyStyleTree(nsIFrame* aFrame)
 {
   if (aFrame) {
     nsStyleContext* context = aFrame->StyleContext();
@@ -1861,39 +1861,39 @@ RestyleManager::ReparentStyleContext(nsI
         }
       }
 
       // do additional contexts
       int32_t contextIndex = 0;
       for (nsStyleContext* oldExtraContext;
            (oldExtraContext = aFrame->GetAdditionalStyleContext(contextIndex));
            ++contextIndex) {
-          nsRefPtr<nsStyleContext> newExtraContext;
-          newExtraContext = mPresContext->StyleSet()->
-                              ReparentStyleContext(oldExtraContext,
-                                                   newContext, nullptr);
-          if (newExtraContext) {
-            if (newExtraContext != oldExtraContext) {
-              // Make sure to call CalcStyleDifference so that the new
-              // context ends up resolving all the structs the old context
-              // resolved.
-              styleChange =
-                oldExtraContext->CalcStyleDifference(newExtraContext,
-                                                     nsChangeHint(0));
-              // The style change is always 0 because we have the same
-              // rulenode and CalcStyleDifference optimizes us away.  That's
-              // OK, though: reparenting should never trigger a frame
-              // reconstruct, and whenever it's happening we already plan to
-              // reflow and repaint the frames.
-              NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
-                           "Our frame tree is likely to be bogus!");
-            }
+        nsRefPtr<nsStyleContext> newExtraContext;
+        newExtraContext = mPresContext->StyleSet()->
+                            ReparentStyleContext(oldExtraContext,
+                                                 newContext, nullptr);
+        if (newExtraContext) {
+          if (newExtraContext != oldExtraContext) {
+            // Make sure to call CalcStyleDifference so that the new
+            // context ends up resolving all the structs the old context
+            // resolved.
+            styleChange =
+              oldExtraContext->CalcStyleDifference(newExtraContext,
+                                                   nsChangeHint(0));
+            // The style change is always 0 because we have the same
+            // rulenode and CalcStyleDifference optimizes us away.  That's
+            // OK, though: reparenting should never trigger a frame
+            // reconstruct, and whenever it's happening we already plan to
+            // reflow and repaint the frames.
+            NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
+                         "Our frame tree is likely to be bogus!");
+          }
 
-            aFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
-          }
+          aFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
+        }
       }
 #ifdef DEBUG
       VerifyStyleTree(mPresContext, aFrame, newParentContext);
 #endif
     }
   }
 
   return NS_OK;
@@ -2066,603 +2066,603 @@ ElementRestyler::RestyleSelf(nsRestyleHi
   // We do need a reference to oldContext for the lifetime of this function, and it's possible
   // that the frame has the last reference to it, so AddRef it here.
 
   nsChangeHint assumeDifferenceHint = NS_STYLE_HINT_NONE;
   nsRefPtr<nsStyleContext> oldContext = mFrame->StyleContext();
   nsStyleSet* styleSet = mPresContext->StyleSet();
 
 #ifdef ACCESSIBILITY
-    mWasFrameVisible = nsIPresShell::IsAccessibilityActive() ?
-      oldContext->StyleVisibility()->IsVisible() : false;
+  mWasFrameVisible = nsIPresShell::IsAccessibilityActive() ?
+    oldContext->StyleVisibility()->IsVisible() : false;
 #endif
 
-    nsIAtom* const pseudoTag = oldContext->GetPseudo();
-    const nsCSSPseudoElements::Type pseudoType = oldContext->GetPseudoType();
+  nsIAtom* const pseudoTag = oldContext->GetPseudo();
+  const nsCSSPseudoElements::Type pseudoType = oldContext->GetPseudoType();
 
-    nsStyleContext* parentContext;
-    // Get the frame providing the parent style context.  If it is a
-    // child, then resolve the provider first.
-    nsIFrame* providerFrame = mFrame->GetParentStyleContextFrame();
-    bool isChild = providerFrame && providerFrame->GetParent() == mFrame;
-    if (!isChild) {
-      if (providerFrame)
-        parentContext = providerFrame->StyleContext();
-      else
-        parentContext = nullptr;
+  nsStyleContext* parentContext;
+  // Get the frame providing the parent style context.  If it is a
+  // child, then resolve the provider first.
+  nsIFrame* providerFrame = mFrame->GetParentStyleContextFrame();
+  bool isChild = providerFrame && providerFrame->GetParent() == mFrame;
+  if (!isChild) {
+    if (providerFrame)
+      parentContext = providerFrame->StyleContext();
+    else
+      parentContext = nullptr;
+  }
+  else {
+    MOZ_ASSERT(providerFrame->GetContent() == mFrame->GetContent(),
+               "Postcondition for GetParentStyleContextFrame() violated. "
+               "That means we need to add the current element to the "
+               "ancestor filter.");
+
+    // resolve the provider here (before mFrame below).
+
+    // assumeDifferenceHint forces the parent's change to be also
+    // applied to this frame, no matter what
+    // nsStyleContext::CalcStyleDifference says. CalcStyleDifference
+    // can't be trusted because it assumes any changes to the parent
+    // style context provider will be automatically propagated to
+    // the frame(s) with child style contexts.
+
+    ElementRestyler providerRestyler(PARENT_CONTEXT_FROM_CHILD_FRAME,
+                                     *this, providerFrame);
+    providerRestyler.Restyle(aRestyleHint);
+    assumeDifferenceHint = providerRestyler.MinChange();
+
+    // The provider's new context becomes the parent context of
+    // mFrame's context.
+    parentContext = providerFrame->StyleContext();
+    // Set |mResolvedChild| so we don't bother resolving the
+    // provider again.
+    mResolvedChild = providerFrame;
+  }
+
+  if (providerFrame != mFrame->GetParent()) {
+    // We don't actually know what the parent style context's
+    // non-inherited hints were, so assume the worst.
+    mParentFrameHintsNotHandledForDescendants =
+      nsChangeHint_Hints_NotHandledForDescendants;
+  }
+
+#ifdef DEBUG
+  {
+    // Check that our assumption that continuations of the same
+    // pseudo-type and with the same style context parent have the
+    // same style context is valid before the reresolution.  (We need
+    // to check the pseudo-type and style context parent because of
+    // :first-letter and :first-line, where we create styled and
+    // unstyled letter/line frames distinguished by pseudo-type, and
+    // then need to distinguish their descendants based on having
+    // different parents.)
+    nsIFrame *nextContinuation = mFrame->GetNextContinuation();
+    if (nextContinuation) {
+      nsStyleContext *nextContinuationContext =
+        nextContinuation->StyleContext();
+      NS_ASSERTION(oldContext == nextContinuationContext ||
+                   oldContext->GetPseudo() !=
+                     nextContinuationContext->GetPseudo() ||
+                   oldContext->GetParent() !=
+                     nextContinuationContext->GetParent(),
+                   "continuations should have the same style context");
+    }
+    // And assert the same thing for {ib} splits.  See the comments in
+    // GetPrevContinuationWithPossiblySameStyle for an explanation of
+    // why we step two forward in the special sibling chain.
+    if ((mFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
+        !mFrame->GetPrevContinuation()) {
+      nsIFrame *nextIBSibling = static_cast<nsIFrame*>(
+        mFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+      if (nextIBSibling) {
+        nextIBSibling = static_cast<nsIFrame*>(
+          nextIBSibling->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+      }
+      if (nextIBSibling) {
+        nsStyleContext *nextIBSiblingContext =
+          nextIBSibling->StyleContext();
+        NS_ASSERTION(oldContext == nextIBSiblingContext ||
+                     oldContext->GetPseudo() !=
+                       nextIBSiblingContext->GetPseudo() ||
+                     oldContext->GetParent() !=
+                       nextIBSiblingContext->GetParent(),
+                     "continuations should have the same style context");
+      }
+    }
+  }
+#endif
+
+  // do primary context
+  nsRefPtr<nsStyleContext> newContext;
+  nsIFrame *prevContinuation =
+    GetPrevContinuationWithPossiblySameStyle(mFrame);
+  nsStyleContext *prevContinuationContext;
+  bool copyFromContinuation =
+    prevContinuation &&
+    (prevContinuationContext = prevContinuation->StyleContext())
+      ->GetPseudo() == oldContext->GetPseudo() &&
+     prevContinuationContext->GetParent() == parentContext;
+  if (copyFromContinuation) {
+    // Just use the style context from the frame's previous
+    // continuation (see assertion about mFrame->GetNextContinuation()
+    // above, which we would have previously hit for mFrame's previous
+    // continuation).
+    newContext = prevContinuationContext;
+  }
+  else if (pseudoTag == nsCSSAnonBoxes::mozNonElement) {
+    NS_ASSERTION(mFrame->GetContent(),
+                 "non pseudo-element frame without content node");
+    newContext = styleSet->ResolveStyleForNonElement(parentContext);
+  }
+  else if (!aRestyleHint && !prevContinuation) {
+    // Unfortunately, if prevContinuation is non-null then we may have
+    // already stolen the restyle tracker entry for this element while
+    // processing prevContinuation.  So we don't know whether aRestyleHint
+    // should really be 0 here or whether it should be eRestyle_Self.  Be
+    // pessimistic and force an actual reresolve in that situation.  The good
+    // news is that in the common case when prevContinuation is non-null we
+    // just used prevContinuationContext anyway and aren't reaching this code
+    // to start with.
+    newContext =
+      styleSet->ReparentStyleContext(oldContext, parentContext,
+                                     ElementForStyleContext(mParentContent,
+                                                            mFrame,
+                                                            pseudoType));
+  } else if (pseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
+    newContext = styleSet->ResolveAnonymousBoxStyle(pseudoTag,
+                                                    parentContext);
+  }
+  else {
+    Element* element = ElementForStyleContext(mParentContent,
+                                              mFrame,
+                                              pseudoType);
+    if (pseudoTag) {
+      if (pseudoTag == nsCSSPseudoElements::before ||
+          pseudoTag == nsCSSPseudoElements::after) {
+        // XXX what other pseudos do we need to treat like this?
+        newContext = styleSet->ProbePseudoElementStyle(element,
+                                                       pseudoType,
+                                                       parentContext,
+                                                       mTreeMatchContext);
+        if (!newContext) {
+          // This pseudo should no longer exist; gotta reframe
+          NS_UpdateHint(mMinChange, nsChangeHint_ReconstructFrame);
+          mChangeList->AppendChange(mFrame, element,
+                                    nsChangeHint_ReconstructFrame);
+          // We're reframing anyway; just keep the same context
+          newContext = oldContext;
+        }
+      } else {
+        // Don't expect XUL tree stuff here, since it needs a comparator and
+        // all.
+        NS_ASSERTION(pseudoType <
+                       nsCSSPseudoElements::ePseudo_PseudoElementCount,
+                     "Unexpected pseudo type");
+        newContext = styleSet->ResolvePseudoElementStyle(element,
+                                                         pseudoType,
+                                                         parentContext);
+      }
     }
     else {
-      MOZ_ASSERT(providerFrame->GetContent() == mFrame->GetContent(),
-                 "Postcondition for GetParentStyleContextFrame() violated. "
-                 "That means we need to add the current element to the "
-                 "ancestor filter.");
+      NS_ASSERTION(mFrame->GetContent(),
+                   "non pseudo-element frame without content node");
+      // Skip flex-item style fixup for anonymous subtrees:
+      TreeMatchContext::AutoFlexItemStyleFixupSkipper
+        flexFixupSkipper(mTreeMatchContext,
+                         element->IsRootOfNativeAnonymousSubtree());
+      newContext = styleSet->ResolveStyleFor(element, parentContext,
+                                             mTreeMatchContext);
+    }
+  }
 
-      // resolve the provider here (before mFrame below).
+  if (!newContext) {
+    NS_RUNTIMEABORT("couldn't allocate new style context");
+  }
 
-      // assumeDifferenceHint forces the parent's change to be also
-      // applied to this frame, no matter what
-      // nsStyleContext::CalcStyleDifference says. CalcStyleDifference
-      // can't be trusted because it assumes any changes to the parent
-      // style context provider will be automatically propagated to
-      // the frame(s) with child style contexts.
+  if (!parentContext) {
+    if (oldContext->RuleNode() == newContext->RuleNode() &&
+        oldContext->IsLinkContext() == newContext->IsLinkContext() &&
+        oldContext->RelevantLinkVisited() ==
+          newContext->RelevantLinkVisited()) {
+      // We're the root of the style context tree and the new style
+      // context returned has the same rule node.  This means that
+      // we can use FindChildWithRules to keep a lot of the old
+      // style contexts around.  However, we need to start from the
+      // same root.
+      newContext = oldContext;
+    }
+  }
 
-      ElementRestyler providerRestyler(PARENT_CONTEXT_FROM_CHILD_FRAME,
-                                       *this, providerFrame);
-      providerRestyler.Restyle(aRestyleHint);
-      assumeDifferenceHint = providerRestyler.MinChange();
-
-      // The provider's new context becomes the parent context of
-      // mFrame's context.
-      parentContext = providerFrame->StyleContext();
-      // Set |mResolvedChild| so we don't bother resolving the
-      // provider again.
-      mResolvedChild = providerFrame;
+  if (newContext != oldContext) {
+    if (!copyFromContinuation) {
+      TryStartingTransition(mPresContext, mFrame->GetContent(),
+                            oldContext, &newContext);
     }
 
-    if (providerFrame != mFrame->GetParent()) {
-      // We don't actually know what the parent style context's
-      // non-inherited hints were, so assume the worst.
-      mParentFrameHintsNotHandledForDescendants =
-        nsChangeHint_Hints_NotHandledForDescendants;
+    CaptureChange(oldContext, newContext, assumeDifferenceHint);
+    if (!(mMinChange & nsChangeHint_ReconstructFrame)) {
+      // if frame gets regenerated, let it keep old context
+      mFrame->SetStyleContext(newContext);
     }
+  }
+  oldContext = nullptr;
 
-#ifdef DEBUG
-    {
-      // Check that our assumption that continuations of the same
-      // pseudo-type and with the same style context parent have the
-      // same style context is valid before the reresolution.  (We need
-      // to check the pseudo-type and style context parent because of
-      // :first-letter and :first-line, where we create styled and
-      // unstyled letter/line frames distinguished by pseudo-type, and
-      // then need to distinguish their descendants based on having
-      // different parents.)
-      nsIFrame *nextContinuation = mFrame->GetNextContinuation();
-      if (nextContinuation) {
-        nsStyleContext *nextContinuationContext =
-          nextContinuation->StyleContext();
-        NS_ASSERTION(oldContext == nextContinuationContext ||
-                     oldContext->GetPseudo() !=
-                       nextContinuationContext->GetPseudo() ||
-                     oldContext->GetParent() !=
-                       nextContinuationContext->GetParent(),
-                     "continuations should have the same style context");
-      }
-      // And assert the same thing for {ib} splits.  See the comments in
-      // GetPrevContinuationWithPossiblySameStyle for an explanation of
-      // why we step two forward in the special sibling chain.
-      if ((mFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
-          !mFrame->GetPrevContinuation()) {
-        nsIFrame *nextIBSibling = static_cast<nsIFrame*>(
-          mFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
-        if (nextIBSibling) {
-          nextIBSibling = static_cast<nsIFrame*>(
-            nextIBSibling->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
-        }
-        if (nextIBSibling) {
-          nsStyleContext *nextIBSiblingContext =
-            nextIBSibling->StyleContext();
-          NS_ASSERTION(oldContext == nextIBSiblingContext ||
-                       oldContext->GetPseudo() !=
-                         nextIBSiblingContext->GetPseudo() ||
-                       oldContext->GetParent() !=
-                         nextIBSiblingContext->GetParent(),
-                       "continuations should have the same style context");
+  // do additional contexts
+  // XXXbz might be able to avoid selector matching here in some
+  // cases; won't worry about it for now.
+  int32_t contextIndex = 0;
+  for (nsStyleContext* oldExtraContext;
+       (oldExtraContext = mFrame->GetAdditionalStyleContext(contextIndex));
+       ++contextIndex) {
+    nsRefPtr<nsStyleContext> newExtraContext;
+    nsIAtom* const extraPseudoTag = oldExtraContext->GetPseudo();
+    const nsCSSPseudoElements::Type extraPseudoType =
+      oldExtraContext->GetPseudoType();
+    NS_ASSERTION(extraPseudoTag &&
+                 extraPseudoTag != nsCSSAnonBoxes::mozNonElement,
+                 "extra style context is not pseudo element");
+    if (extraPseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
+      newExtraContext = styleSet->ResolveAnonymousBoxStyle(extraPseudoTag,
+                                                           newContext);
+    }
+    else {
+      // Don't expect XUL tree stuff here, since it needs a comparator and
+      // all.
+      NS_ASSERTION(extraPseudoType <
+                     nsCSSPseudoElements::ePseudo_PseudoElementCount,
+                   "Unexpected type");
+      newExtraContext = styleSet->ResolvePseudoElementStyle(mContent->AsElement(),
+                                                            extraPseudoType,
+                                                            newContext);
+    }
+    if (newExtraContext) {
+      if (oldExtraContext != newExtraContext) {
+        CaptureChange(oldExtraContext, newExtraContext, assumeDifferenceHint);
+        if (!(mMinChange & nsChangeHint_ReconstructFrame)) {
+          mFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
         }
       }
     }
-#endif
-
-    // do primary context
-    nsRefPtr<nsStyleContext> newContext;
-    nsIFrame *prevContinuation =
-      GetPrevContinuationWithPossiblySameStyle(mFrame);
-    nsStyleContext *prevContinuationContext;
-    bool copyFromContinuation =
-      prevContinuation &&
-      (prevContinuationContext = prevContinuation->StyleContext())
-        ->GetPseudo() == oldContext->GetPseudo() &&
-       prevContinuationContext->GetParent() == parentContext;
-    if (copyFromContinuation) {
-      // Just use the style context from the frame's previous
-      // continuation (see assertion about mFrame->GetNextContinuation()
-      // above, which we would have previously hit for mFrame's previous
-      // continuation).
-      newContext = prevContinuationContext;
-    }
-    else if (pseudoTag == nsCSSAnonBoxes::mozNonElement) {
-      NS_ASSERTION(mFrame->GetContent(),
-                   "non pseudo-element frame without content node");
-      newContext = styleSet->ResolveStyleForNonElement(parentContext);
-    }
-    else if (!aRestyleHint && !prevContinuation) {
-      // Unfortunately, if prevContinuation is non-null then we may have
-      // already stolen the restyle tracker entry for this element while
-      // processing prevContinuation.  So we don't know whether aRestyleHint
-      // should really be 0 here or whether it should be eRestyle_Self.  Be
-      // pessimistic and force an actual reresolve in that situation.  The good
-      // news is that in the common case when prevContinuation is non-null we
-      // just used prevContinuationContext anyway and aren't reaching this code
-      // to start with.
-      newContext =
-        styleSet->ReparentStyleContext(oldContext, parentContext,
-                                       ElementForStyleContext(mParentContent,
-                                                              mFrame,
-                                                              pseudoType));
-    } else if (pseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
-      newContext = styleSet->ResolveAnonymousBoxStyle(pseudoTag,
-                                                      parentContext);
-    }
-    else {
-      Element* element = ElementForStyleContext(mParentContent,
-                                                mFrame,
-                                                pseudoType);
-      if (pseudoTag) {
-        if (pseudoTag == nsCSSPseudoElements::before ||
-            pseudoTag == nsCSSPseudoElements::after) {
-          // XXX what other pseudos do we need to treat like this?
-          newContext = styleSet->ProbePseudoElementStyle(element,
-                                                         pseudoType,
-                                                         parentContext,
-                                                         mTreeMatchContext);
-          if (!newContext) {
-            // This pseudo should no longer exist; gotta reframe
-            NS_UpdateHint(mMinChange, nsChangeHint_ReconstructFrame);
-            mChangeList->AppendChange(mFrame, element,
-                                      nsChangeHint_ReconstructFrame);
-            // We're reframing anyway; just keep the same context
-            newContext = oldContext;
-          }
-        } else {
-          // Don't expect XUL tree stuff here, since it needs a comparator and
-          // all.
-          NS_ASSERTION(pseudoType <
-                         nsCSSPseudoElements::ePseudo_PseudoElementCount,
-                       "Unexpected pseudo type");
-          newContext = styleSet->ResolvePseudoElementStyle(element,
-                                                           pseudoType,
-                                                           parentContext);
-        }
-      }
-      else {
-        NS_ASSERTION(mFrame->GetContent(),
-                     "non pseudo-element frame without content node");
-        // Skip flex-item style fixup for anonymous subtrees:
-        TreeMatchContext::AutoFlexItemStyleFixupSkipper
-          flexFixupSkipper(mTreeMatchContext,
-                           element->IsRootOfNativeAnonymousSubtree());
-        newContext = styleSet->ResolveStyleFor(element, parentContext,
-                                               mTreeMatchContext);
-      }
-    }
-
-    if (!newContext) {
-      NS_RUNTIMEABORT("couldn't allocate new style context");
-    }
-
-      if (!parentContext) {
-        if (oldContext->RuleNode() == newContext->RuleNode() &&
-            oldContext->IsLinkContext() == newContext->IsLinkContext() &&
-            oldContext->RelevantLinkVisited() ==
-              newContext->RelevantLinkVisited()) {
-          // We're the root of the style context tree and the new style
-          // context returned has the same rule node.  This means that
-          // we can use FindChildWithRules to keep a lot of the old
-          // style contexts around.  However, we need to start from the
-          // same root.
-          newContext = oldContext;
-        }
-      }
-
-      if (newContext != oldContext) {
-        if (!copyFromContinuation) {
-          TryStartingTransition(mPresContext, mFrame->GetContent(),
-                                oldContext, &newContext);
-        }
-
-        CaptureChange(oldContext, newContext, assumeDifferenceHint);
-        if (!(mMinChange & nsChangeHint_ReconstructFrame)) {
-          // if frame gets regenerated, let it keep old context
-          mFrame->SetStyleContext(newContext);
-        }
-      }
-      oldContext = nullptr;
-
-    // do additional contexts
-    // XXXbz might be able to avoid selector matching here in some
-    // cases; won't worry about it for now.
-    int32_t contextIndex = 0;
-    for (nsStyleContext* oldExtraContext;
-         (oldExtraContext = mFrame->GetAdditionalStyleContext(contextIndex));
-         ++contextIndex) {
-        nsRefPtr<nsStyleContext> newExtraContext;
-        nsIAtom* const extraPseudoTag = oldExtraContext->GetPseudo();
-        const nsCSSPseudoElements::Type extraPseudoType =
-          oldExtraContext->GetPseudoType();
-        NS_ASSERTION(extraPseudoTag &&
-                     extraPseudoTag != nsCSSAnonBoxes::mozNonElement,
-                     "extra style context is not pseudo element");
-        if (extraPseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
-          newExtraContext = styleSet->ResolveAnonymousBoxStyle(extraPseudoTag,
-                                                               newContext);
-        }
-        else {
-          // Don't expect XUL tree stuff here, since it needs a comparator and
-          // all.
-          NS_ASSERTION(extraPseudoType <
-                         nsCSSPseudoElements::ePseudo_PseudoElementCount,
-                       "Unexpected type");
-          newExtraContext = styleSet->ResolvePseudoElementStyle(mContent->AsElement(),
-                                                                extraPseudoType,
-                                                                newContext);
-        }
-        if (newExtraContext) {
-          if (oldExtraContext != newExtraContext) {
-            CaptureChange(oldExtraContext, newExtraContext, assumeDifferenceHint);
-            if (!(mMinChange & nsChangeHint_ReconstructFrame)) {
-              mFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
-            }
-          }
-        }
-    }
+  }
 }
 
 void
 ElementRestyler::RestyleChildren(nsRestyleHint aChildRestyleHint)
 {
-    RestyleUndisplayedChildren(aChildRestyleHint);
+  RestyleUndisplayedChildren(aChildRestyleHint);
 
-    // Check whether we might need to create a new ::before frame.
-    // There's no need to do this if we're planning to reframe already
-    // or if we're not forcing restyles on kids.
-    // It's also important to check mMinChange since we use
-    // mFrame->StyleContext(), which is out of date if mMinChange has a
-    // ReconstructFrame hint.  Using an out of date style context could
-    // trigger assertions about mismatched rule trees.
-    if (!(mMinChange & nsChangeHint_ReconstructFrame) &&
-        aChildRestyleHint) {
-      RestyleBeforePseudo();
-    }
+  // Check whether we might need to create a new ::before frame.
+  // There's no need to do this if we're planning to reframe already
+  // or if we're not forcing restyles on kids.
+  // It's also important to check mMinChange since we use
+  // mFrame->StyleContext(), which is out of date if mMinChange has a
+  // ReconstructFrame hint.  Using an out of date style context could
+  // trigger assertions about mismatched rule trees.
+  if (!(mMinChange & nsChangeHint_ReconstructFrame) &&
+      aChildRestyleHint) {
+    RestyleBeforePseudo();
+  }
 
-    // Check whether we might need to create a new ::after frame.
-    // See comments above regarding :before.
-    if (!(mMinChange & nsChangeHint_ReconstructFrame) &&
-        aChildRestyleHint) {
-      RestyleAfterPseudo();
-    }
+  // Check whether we might need to create a new ::after frame.
+  // See comments above regarding :before.
+  if (!(mMinChange & nsChangeHint_ReconstructFrame) &&
+      aChildRestyleHint) {
+    RestyleAfterPseudo();
+  }
 
-    // There is no need to waste time crawling into a frame's children
-    // on a frame change.  The act of reconstructing frames will force
-    // new style contexts to be resolved on all of this frame's
-    // descendants anyway, so we want to avoid wasting time processing
-    // style contexts that we're just going to throw away anyway. - dwh
-    // It's also important to check mMinChange since reresolving the
-    // kids would use mFrame->StyleContext(), which is out of date if
-    // mMinChange has a ReconstructFrame hint; doing this could trigger
-    // assertions about mismatched rule trees.
-    if (!(mMinChange & nsChangeHint_ReconstructFrame)) {
-      InitializeAccessibilityNotifications();
+  // There is no need to waste time crawling into a frame's children
+  // on a frame change.  The act of reconstructing frames will force
+  // new style contexts to be resolved on all of this frame's
+  // descendants anyway, so we want to avoid wasting time processing
+  // style contexts that we're just going to throw away anyway. - dwh
+  // It's also important to check mMinChange since reresolving the
+  // kids would use mFrame->StyleContext(), which is out of date if
+  // mMinChange has a ReconstructFrame hint; doing this could trigger
+  // assertions about mismatched rule trees.
+  if (!(mMinChange & nsChangeHint_ReconstructFrame)) {
+    InitializeAccessibilityNotifications();
 
-      RestyleContentChildren(aChildRestyleHint);
+    RestyleContentChildren(aChildRestyleHint);
 
-      SendAccessibilityNotifications();
-    }
+    SendAccessibilityNotifications();
+  }
 }
 
 void
 ElementRestyler::RestyleUndisplayedChildren(nsRestyleHint aChildRestyleHint)
 {
-    // When the root element is display:none, we still construct *some*
-    // frames that have the root element as their mContent, down to the
-    // DocElementContainingBlock.
-    bool checkUndisplayed;
-    nsIContent* undisplayedParent;
-    nsCSSFrameConstructor* frameConstructor = mPresContext->FrameConstructor();
-    if (mFrame->StyleContext()->GetPseudo()) {
-      checkUndisplayed = mFrame == frameConstructor->
-                                     GetDocElementContainingBlock();
-      undisplayedParent = nullptr;
-    } else {
-      checkUndisplayed = !!mFrame->GetContent();
-      undisplayedParent = mFrame->GetContent();
-    }
-    if (checkUndisplayed &&
-        // No need to do this if we're planning to reframe already.
-        // It's also important to check mMinChange since we use
-        // mFrame->StyleContext(), which is out of date if mMinChange
-        // has a ReconstructFrame hint.  Using an out of date style
-        // context could trigger assertions about mismatched rule trees.
-        !(mMinChange & nsChangeHint_ReconstructFrame)) {
-      UndisplayedNode* undisplayed =
-        frameConstructor->GetAllUndisplayedContentIn(undisplayedParent);
-      for (TreeMatchContext::AutoAncestorPusher
-             pushAncestor(undisplayed, mTreeMatchContext,
-                          undisplayedParent ? undisplayedParent->AsElement()
-                                            : nullptr);
-           undisplayed; undisplayed = undisplayed->mNext) {
-        NS_ASSERTION(undisplayedParent ||
-                     undisplayed->mContent ==
-                       mPresContext->Document()->GetRootElement(),
-                     "undisplayed node child of null must be root");
-        NS_ASSERTION(!undisplayed->mStyle->GetPseudo(),
-                     "Shouldn't have random pseudo style contexts in the "
-                     "undisplayed map");
+  // When the root element is display:none, we still construct *some*
+  // frames that have the root element as their mContent, down to the
+  // DocElementContainingBlock.
+  bool checkUndisplayed;
+  nsIContent* undisplayedParent;
+  nsCSSFrameConstructor* frameConstructor = mPresContext->FrameConstructor();
+  if (mFrame->StyleContext()->GetPseudo()) {
+    checkUndisplayed = mFrame == frameConstructor->
+                                   GetDocElementContainingBlock();
+    undisplayedParent = nullptr;
+  } else {
+    checkUndisplayed = !!mFrame->GetContent();
+    undisplayedParent = mFrame->GetContent();
+  }
+  if (checkUndisplayed &&
+      // No need to do this if we're planning to reframe already.
+      // It's also important to check mMinChange since we use
+      // mFrame->StyleContext(), which is out of date if mMinChange
+      // has a ReconstructFrame hint.  Using an out of date style
+      // context could trigger assertions about mismatched rule trees.
+      !(mMinChange & nsChangeHint_ReconstructFrame)) {
+    UndisplayedNode* undisplayed =
+      frameConstructor->GetAllUndisplayedContentIn(undisplayedParent);
+    for (TreeMatchContext::AutoAncestorPusher
+           pushAncestor(undisplayed, mTreeMatchContext,
+                        undisplayedParent ? undisplayedParent->AsElement()
+                                          : nullptr);
+         undisplayed; undisplayed = undisplayed->mNext) {
+      NS_ASSERTION(undisplayedParent ||
+                   undisplayed->mContent ==
+                     mPresContext->Document()->GetRootElement(),
+                   "undisplayed node child of null must be root");
+      NS_ASSERTION(!undisplayed->mStyle->GetPseudo(),
+                   "Shouldn't have random pseudo style contexts in the "
+                   "undisplayed map");
 
-        // Get the parent of the undisplayed content and check if it is a XBL
-        // children element. Push the children element as an ancestor here because it does
-        // not have a frame and would not otherwise be pushed as an ancestor.
-        nsIContent* parent = undisplayed->mContent->GetParent();
-        bool pushInsertionPoint = parent && parent->IsActiveChildrenElement();
-        TreeMatchContext::AutoAncestorPusher
-          insertionPointPusher(pushInsertionPoint,
-                               mTreeMatchContext,
-                               parent && parent->IsElement() ? parent->AsElement() : nullptr);
+      // Get the parent of the undisplayed content and check if it is a XBL
+      // children element. Push the children element as an ancestor here because it does
+      // not have a frame and would not otherwise be pushed as an ancestor.
+      nsIContent* parent = undisplayed->mContent->GetParent();
+      bool pushInsertionPoint = parent && parent->IsActiveChildrenElement();
+      TreeMatchContext::AutoAncestorPusher
+        insertionPointPusher(pushInsertionPoint,
+                             mTreeMatchContext,
+                             parent && parent->IsElement() ? parent->AsElement() : nullptr);
 
-        nsRestyleHint thisChildHint = aChildRestyleHint;
-        RestyleTracker::RestyleData undisplayedRestyleData;
-        if (mRestyleTracker.GetRestyleData(undisplayed->mContent->AsElement(),
-                                           &undisplayedRestyleData)) {
-          thisChildHint =
-            nsRestyleHint(thisChildHint | undisplayedRestyleData.mRestyleHint);
-        }
-        nsRefPtr<nsStyleContext> undisplayedContext;
-        nsStyleSet* styleSet = mPresContext->StyleSet();
-        if (thisChildHint) {
-          undisplayedContext =
-            styleSet->ResolveStyleFor(undisplayed->mContent->AsElement(),
-                                      mFrame->StyleContext(),
-                                      mTreeMatchContext);
+      nsRestyleHint thisChildHint = aChildRestyleHint;
+      RestyleTracker::RestyleData undisplayedRestyleData;
+      if (mRestyleTracker.GetRestyleData(undisplayed->mContent->AsElement(),
+                                         &undisplayedRestyleData)) {
+        thisChildHint =
+          nsRestyleHint(thisChildHint | undisplayedRestyleData.mRestyleHint);
+      }
+      nsRefPtr<nsStyleContext> undisplayedContext;
+      nsStyleSet* styleSet = mPresContext->StyleSet();
+      if (thisChildHint) {
+        undisplayedContext =
+          styleSet->ResolveStyleFor(undisplayed->mContent->AsElement(),
+                                    mFrame->StyleContext(),
+                                    mTreeMatchContext);
+      } else {
+        undisplayedContext =
+          styleSet->ReparentStyleContext(undisplayed->mStyle,
+                                         mFrame->StyleContext(),
+                                         undisplayed->mContent->AsElement());
+      }
+      if (undisplayedContext) {
+        const nsStyleDisplay* display = undisplayedContext->StyleDisplay();
+        if (display->mDisplay != NS_STYLE_DISPLAY_NONE) {
+          NS_ASSERTION(undisplayed->mContent,
+                       "Must have undisplayed content");
+          mChangeList->AppendChange(nullptr, undisplayed->mContent,
+                                    NS_STYLE_HINT_FRAMECHANGE);
+          // The node should be removed from the undisplayed map when
+          // we reframe it.
         } else {
-          undisplayedContext =
-            styleSet->ReparentStyleContext(undisplayed->mStyle,
-                                           mFrame->StyleContext(),
-                                           undisplayed->mContent->AsElement());
-        }
-        if (undisplayedContext) {
-          const nsStyleDisplay* display = undisplayedContext->StyleDisplay();
-          if (display->mDisplay != NS_STYLE_DISPLAY_NONE) {
-            NS_ASSERTION(undisplayed->mContent,
-                         "Must have undisplayed content");
-            mChangeList->AppendChange(nullptr, undisplayed->mContent,
-                                      NS_STYLE_HINT_FRAMECHANGE);
-            // The node should be removed from the undisplayed map when
-            // we reframe it.
-          } else {
-            // update the undisplayed node with the new context
-            undisplayed->mStyle = undisplayedContext;
-          }
+          // update the undisplayed node with the new context
+          undisplayed->mStyle = undisplayedContext;
         }
       }
     }
+  }
 }
 
 void
 ElementRestyler::RestyleBeforePseudo()
 {
-      // Make sure not to do this for pseudo-frames or frames that
-      // can't have generated content.
-      if (!mFrame->StyleContext()->GetPseudo() &&
-          ((mFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
-           // Our content insertion frame might have gotten flagged
-           (mFrame->GetContentInsertionFrame()->GetStateBits() &
-            NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
-        // Check for a new :before pseudo and an existing :before
-        // frame, but only if the frame is the first continuation.
-        nsIFrame* prevContinuation = mFrame->GetPrevContinuation();
-        if (!prevContinuation) {
-          // Checking for a :before frame is cheaper than getting the
-          // :before style context.
-          if (!nsLayoutUtils::GetBeforeFrame(mFrame) &&
-              nsLayoutUtils::HasPseudoStyle(mFrame->GetContent(),
-                                            mFrame->StyleContext(),
-                                            nsCSSPseudoElements::ePseudo_before,
-                                            mPresContext)) {
-            // Have to create the new :before frame
-            NS_UpdateHint(mMinChange, nsChangeHint_ReconstructFrame);
-            mChangeList->AppendChange(mFrame, mContent,
-                                      nsChangeHint_ReconstructFrame);
-          }
-        }
+  // Make sure not to do this for pseudo-frames or frames that
+  // can't have generated content.
+  if (!mFrame->StyleContext()->GetPseudo() &&
+      ((mFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
+       // Our content insertion frame might have gotten flagged
+       (mFrame->GetContentInsertionFrame()->GetStateBits() &
+        NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
+    // Check for a new :before pseudo and an existing :before
+    // frame, but only if the frame is the first continuation.
+    nsIFrame* prevContinuation = mFrame->GetPrevContinuation();
+    if (!prevContinuation) {
+      // Checking for a :before frame is cheaper than getting the
+      // :before style context.
+      if (!nsLayoutUtils::GetBeforeFrame(mFrame) &&
+          nsLayoutUtils::HasPseudoStyle(mFrame->GetContent(),
+                                        mFrame->StyleContext(),
+                                        nsCSSPseudoElements::ePseudo_before,
+                                        mPresContext)) {
+        // Have to create the new :before frame
+        NS_UpdateHint(mMinChange, nsChangeHint_ReconstructFrame);
+        mChangeList->AppendChange(mFrame, mContent,
+                                  nsChangeHint_ReconstructFrame);
       }
+    }
+  }
 }
 
 void
 ElementRestyler::RestyleAfterPseudo()
 {
-      // Make sure not to do this for pseudo-frames or frames that
-      // can't have generated content.
-      if (!mFrame->StyleContext()->GetPseudo() &&
-          ((mFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
-           // Our content insertion frame might have gotten flagged
-           (mFrame->GetContentInsertionFrame()->GetStateBits() &
-            NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
-        // Check for new :after content, but only if the frame is the
-        // last continuation.
-        nsIFrame* nextContinuation = mFrame->GetNextContinuation();
+  // Make sure not to do this for pseudo-frames or frames that
+  // can't have generated content.
+  if (!mFrame->StyleContext()->GetPseudo() &&
+      ((mFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
+       // Our content insertion frame might have gotten flagged
+       (mFrame->GetContentInsertionFrame()->GetStateBits() &
+        NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
+    // Check for new :after content, but only if the frame is the
+    // last continuation.
+    nsIFrame* nextContinuation = mFrame->GetNextContinuation();
 
-        if (!nextContinuation) {
-          // Getting the :after frame is more expensive than getting the pseudo
-          // context, so get the pseudo context first.
-          if (nsLayoutUtils::HasPseudoStyle(mFrame->GetContent(),
-                                            mFrame->StyleContext(),
-                                            nsCSSPseudoElements::ePseudo_after,
-                                            mPresContext) &&
-              !nsLayoutUtils::GetAfterFrame(mFrame)) {
-            // have to create the new :after frame
-            NS_UpdateHint(mMinChange, nsChangeHint_ReconstructFrame);
-            mChangeList->AppendChange(mFrame, mContent,
-                                      nsChangeHint_ReconstructFrame);
-          }
-        }
+    if (!nextContinuation) {
+      // Getting the :after frame is more expensive than getting the pseudo
+      // context, so get the pseudo context first.
+      if (nsLayoutUtils::HasPseudoStyle(mFrame->GetContent(),
+                                        mFrame->StyleContext(),
+                                        nsCSSPseudoElements::ePseudo_after,
+                                        mPresContext) &&
+          !nsLayoutUtils::GetAfterFrame(mFrame)) {
+        // have to create the new :after frame
+        NS_UpdateHint(mMinChange, nsChangeHint_ReconstructFrame);
+        mChangeList->AppendChange(mFrame, mContent,
+                                  nsChangeHint_ReconstructFrame);
       }
+    }
+  }
 }
 
 void
 ElementRestyler::InitializeAccessibilityNotifications()
 {
 #ifdef ACCESSIBILITY
-      // Notify a11y for primary frame only if it's a root frame of visibility
-      // changes or its parent frame was hidden while it stays visible and
-      // it is not inside a {ib} split or is the first frame of {ib} split.
-      if (nsIPresShell::IsAccessibilityActive() &&
-          !mFrame->GetPrevContinuation() &&
-          !nsLayoutUtils::FrameIsNonFirstInIBSplit(mFrame)) {
-        if (mDesiredA11yNotifications == eSendAllNotifications) {
-          bool isFrameVisible = mFrame->StyleVisibility()->IsVisible();
-          if (isFrameVisible != mWasFrameVisible) {
-            if (isFrameVisible) {
-              // Notify a11y the element (perhaps with its children) was shown.
-              // We don't fall into this case if this element gets or stays shown
-              // while its parent becomes hidden.
-              mKidsDesiredA11yNotifications = eSkipNotifications;
-              mOurA11yNotification = eNotifyShown;
-            } else {
-              // The element is being hidden; its children may stay visible, or
-              // become visible after being hidden previously. If we'll find
-              // visible children then we should notify a11y about that as if
-              // they were inserted into tree. Notify a11y this element was
-              // hidden.
-              mKidsDesiredA11yNotifications = eNotifyIfShown;
-              mOurA11yNotification = eNotifyHidden;
-            }
-          }
-        } else if (mDesiredA11yNotifications == eNotifyIfShown &&
-                   mFrame->StyleVisibility()->IsVisible()) {
-          // Notify a11y that element stayed visible while its parent was
+  // Notify a11y for primary frame only if it's a root frame of visibility
+  // changes or its parent frame was hidden while it stays visible and
+  // it is not inside a {ib} split or is the first frame of {ib} split.
+  if (nsIPresShell::IsAccessibilityActive() &&
+      !mFrame->GetPrevContinuation() &&
+      !nsLayoutUtils::FrameIsNonFirstInIBSplit(mFrame)) {
+    if (mDesiredA11yNotifications == eSendAllNotifications) {
+      bool isFrameVisible = mFrame->StyleVisibility()->IsVisible();
+      if (isFrameVisible != mWasFrameVisible) {
+        if (isFrameVisible) {
+          // Notify a11y the element (perhaps with its children) was shown.
+          // We don't fall into this case if this element gets or stays shown
+          // while its parent becomes hidden.
+          mKidsDesiredA11yNotifications = eSkipNotifications;
+          mOurA11yNotification = eNotifyShown;
+        } else {
+          // The element is being hidden; its children may stay visible, or
+          // become visible after being hidden previously. If we'll find
+          // visible children then we should notify a11y about that as if
+          // they were inserted into tree. Notify a11y this element was
           // hidden.
-          mVisibleKidsOfHiddenElement.AppendElement(mFrame->GetContent());
-          mKidsDesiredA11yNotifications = eSkipNotifications;
+          mKidsDesiredA11yNotifications = eNotifyIfShown;
+          mOurA11yNotification = eNotifyHidden;
         }
       }
+    } else if (mDesiredA11yNotifications == eNotifyIfShown &&
+               mFrame->StyleVisibility()->IsVisible()) {
+      // Notify a11y that element stayed visible while its parent was
+      // hidden.
+      mVisibleKidsOfHiddenElement.AppendElement(mFrame->GetContent());
+      mKidsDesiredA11yNotifications = eSkipNotifications;
+    }
+  }
 #endif
 }
 
 void
 ElementRestyler::RestyleContentChildren(nsRestyleHint aChildRestyleHint)
 {
-      nsIFrame::ChildListIterator lists(mFrame);
-      for (TreeMatchContext::AutoAncestorPusher
-             pushAncestor(!lists.IsDone(),
-                          mTreeMatchContext,
-                          mContent && mContent->IsElement()
-                            ? mContent->AsElement() : nullptr);
-           !lists.IsDone(); lists.Next()) {
-        nsFrameList::Enumerator childFrames(lists.CurrentList());
-        for (; !childFrames.AtEnd(); childFrames.Next()) {
-          nsIFrame* child = childFrames.get();
-          if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
-            // Get the parent of the child frame's content and check if it is a XBL
-            // children element. Push the children element as an ancestor here because it does
-            // not have a frame and would not otherwise be pushed as an ancestor.
+  nsIFrame::ChildListIterator lists(mFrame);
+  for (TreeMatchContext::AutoAncestorPusher
+         pushAncestor(!lists.IsDone(),
+                      mTreeMatchContext,
+                      mContent && mContent->IsElement()
+                        ? mContent->AsElement() : nullptr);
+       !lists.IsDone(); lists.Next()) {
+    nsFrameList::Enumerator childFrames(lists.CurrentList());
+    for (; !childFrames.AtEnd(); childFrames.Next()) {
+      nsIFrame* child = childFrames.get();
+      if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
+        // Get the parent of the child frame's content and check if it is a XBL
+        // children element. Push the children element as an ancestor here because it does
+        // not have a frame and would not otherwise be pushed as an ancestor.
 
-            // Check if the frame has a content because |child| may be a nsPageFrame that does
-            // not have a content.
-            nsIContent* parent = child->GetContent() ? child->GetContent()->GetParent() : nullptr;
-            bool pushInsertionPoint = parent && parent->IsActiveChildrenElement();
-            TreeMatchContext::AutoAncestorPusher
-              insertionPointPusher(pushInsertionPoint, mTreeMatchContext,
-                                   parent && parent->IsElement() ? parent->AsElement() : nullptr);
+        // Check if the frame has a content because |child| may be a nsPageFrame that does
+        // not have a content.
+        nsIContent* parent = child->GetContent() ? child->GetContent()->GetParent() : nullptr;
+        bool pushInsertionPoint = parent && parent->IsActiveChildrenElement();
+        TreeMatchContext::AutoAncestorPusher
+          insertionPointPusher(pushInsertionPoint, mTreeMatchContext,
+                               parent && parent->IsElement() ? parent->AsElement() : nullptr);
 
-            // only do frames that are in flow
-            if (nsGkAtoms::placeholderFrame == child->GetType()) { // placeholder
-              // get out of flow frame and recur there
-              nsIFrame* outOfFlowFrame =
-                nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
-              NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
-              NS_ASSERTION(outOfFlowFrame != mResolvedChild,
-                           "out-of-flow frame not a true descendant");
+        // only do frames that are in flow
+        if (nsGkAtoms::placeholderFrame == child->GetType()) { // placeholder
+          // get out of flow frame and recur there
+          nsIFrame* outOfFlowFrame =
+            nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
+          NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
+          NS_ASSERTION(outOfFlowFrame != mResolvedChild,
+                       "out-of-flow frame not a true descendant");
 
-              // Note that the out-of-flow may not be a geometric descendant of
-              // the frame where we started the reresolve.  Therefore, even if
-              // mMinChange already includes nsChangeHint_AllReflowHints we don't
-              // want to pass that on to the out-of-flow reresolve, since that
-              // can lead to the out-of-flow not getting reflowed when it should
-              // be (eg a reresolve starting at <body> that involves reflowing
-              // the <body> would miss reflowing fixed-pos nodes that also need
-              // reflow).  In the cases when the out-of-flow _is_ a geometric
-              // descendant of a frame we already have a reflow hint for,
-              // reflow coalescing should keep us from doing the work twice.
+          // Note that the out-of-flow may not be a geometric descendant of
+          // the frame where we started the reresolve.  Therefore, even if
+          // mMinChange already includes nsChangeHint_AllReflowHints we don't
+          // want to pass that on to the out-of-flow reresolve, since that
+          // can lead to the out-of-flow not getting reflowed when it should
+          // be (eg a reresolve starting at <body> that involves reflowing
+          // the <body> would miss reflowing fixed-pos nodes that also need
+          // reflow).  In the cases when the out-of-flow _is_ a geometric
+          // descendant of a frame we already have a reflow hint for,
+          // reflow coalescing should keep us from doing the work twice.
 
-              // |nsFrame::GetParentStyleContextFrame| checks being out
-              // of flow so that this works correctly.
-              do {
-                ElementRestyler oofRestyler(*this, outOfFlowFrame,
-                                            FOR_OUT_OF_FLOW_CHILD);
-                oofRestyler.Restyle(aChildRestyleHint);
-              } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
+          // |nsFrame::GetParentStyleContextFrame| checks being out
+          // of flow so that this works correctly.
+          do {
+            ElementRestyler oofRestyler(*this, outOfFlowFrame,
+                                        FOR_OUT_OF_FLOW_CHILD);
+            oofRestyler.Restyle(aChildRestyleHint);
+          } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
 
-              // reresolve placeholder's context under the same parent
-              // as the out-of-flow frame
-              ElementRestyler phRestyler(*this, child, 0);
-              phRestyler.Restyle(aChildRestyleHint);
-            }
-            else {  // regular child frame
-              if (child != mResolvedChild) {
-                ElementRestyler childRestyler(*this, child, 0);
-                childRestyler.Restyle(aChildRestyleHint);
-              }
-            }
+          // reresolve placeholder's context under the same parent
+          // as the out-of-flow frame
+          ElementRestyler phRestyler(*this, child, 0);
+          phRestyler.Restyle(aChildRestyleHint);
+        }
+        else {  // regular child frame
+          if (child != mResolvedChild) {
+            ElementRestyler childRestyler(*this, child, 0);
+            childRestyler.Restyle(aChildRestyleHint);
           }
         }
       }
-      // XXX need to do overflow frames???
+    }
+  }
+  // XXX need to do overflow frames???
 }
 
 void
 ElementRestyler::SendAccessibilityNotifications()
 {
 #ifdef ACCESSIBILITY
-      // Send notifications about visibility changes.
-      if (mOurA11yNotification == eNotifyShown) {
-        nsAccessibilityService* accService = nsIPresShell::AccService();
-        if (accService) {
-          nsIPresShell* presShell = mFrame->PresContext()->GetPresShell();
-          nsIContent* content = mFrame->GetContent();
+  // Send notifications about visibility changes.
+  if (mOurA11yNotification == eNotifyShown) {
+    nsAccessibilityService* accService = nsIPresShell::AccService();
+    if (accService) {
+      nsIPresShell* presShell = mFrame->PresContext()->GetPresShell();
+      nsIContent* content = mFrame->GetContent();
 
-          accService->ContentRangeInserted(presShell, content->GetParent(),
-                                           content,
-                                           content->GetNextSibling());
-        }
-      } else if (mOurA11yNotification == eNotifyHidden) {
-        nsAccessibilityService* accService = nsIPresShell::AccService();
-        if (accService) {
-          nsIPresShell* presShell = mFrame->PresContext()->GetPresShell();
-          nsIContent* content = mFrame->GetContent();
-          accService->ContentRemoved(presShell, content->GetParent(), content);
+      accService->ContentRangeInserted(presShell, content->GetParent(),
+                                       content,
+                                       content->GetNextSibling());
+    }
+  } else if (mOurA11yNotification == eNotifyHidden) {
+    nsAccessibilityService* accService = nsIPresShell::AccService();
+    if (accService) {
+      nsIPresShell* presShell = mFrame->PresContext()->GetPresShell();
+      nsIContent* content = mFrame->GetContent();
+      accService->ContentRemoved(presShell, content->GetParent(), content);
 
-          // Process children staying shown.
-          uint32_t visibleContentCount = mVisibleKidsOfHiddenElement.Length();
-          for (uint32_t idx = 0; idx < visibleContentCount; idx++) {
-            nsIContent* childContent = mVisibleKidsOfHiddenElement[idx];
-            accService->ContentRangeInserted(presShell, childContent->GetParent(),
-                                             childContent,
-                                             childContent->GetNextSibling());
-          }
-          mVisibleKidsOfHiddenElement.Clear();
-        }
+      // Process children staying shown.
+      uint32_t visibleContentCount = mVisibleKidsOfHiddenElement.Length();
+      for (uint32_t idx = 0; idx < visibleContentCount; idx++) {
+        nsIContent* childContent = mVisibleKidsOfHiddenElement[idx];
+        accService->ContentRangeInserted(presShell, childContent->GetParent(),
+                                         childContent,
+                                         childContent->GetNextSibling());
       }
+      mVisibleKidsOfHiddenElement.Clear();
+    }
+  }
 #endif
 }
 
 void
 RestyleManager::ComputeStyleChangeFor(nsIFrame*          aFrame,
                                       nsStyleChangeList* aChangeList,
                                       nsChangeHint       aMinChange,
                                       RestyleTracker&    aRestyleTracker,
