diff -r 7e62a8403aac layout/tables/BasicTableLayoutStrategy.cpp
--- a/layout/tables/BasicTableLayoutStrategy.cpp	Fri Jan 12 10:38:46 2007 -0800
+++ b/layout/tables/BasicTableLayoutStrategy.cpp	Fri Jan 12 10:38:49 2007 -0800
@@ -329,7 +329,7 @@ BasicTableLayoutStrategy::ComputeColumnI
 
             // Accumulate information about the spanned columns, and
             // subtract the already-used space from |info|.
-            nscoord totalSPref = 0, totalSNonPctPref = 0;
+            nscoord totalSPref = 0, totalSMin = 0, totalSNonPctPref = 0;
             PRInt32 nonPctCount = 0;
             PRInt32 scol, scol_end;
             for (scol = col, scol_end = col + colSpan;
@@ -347,6 +347,7 @@ BasicTableLayoutStrategy::ComputeColumnI
                 }
 
                 totalSPref += scolFrame->GetPrefCoord();
+                totalSMin += scolFrame->GetMinCoord();
                 float scolPct = scolFrame->GetPrefPercent();
                 if (scolPct == 0.0f) {
                     totalSNonPctPref += scolFrame->GetPrefCoord();
@@ -376,6 +377,11 @@ BasicTableLayoutStrategy::ComputeColumnI
                 }
             }
 
+            nscoord minWithinPref =
+                PR_MIN(info.minCoord, totalSPref - totalSMin);
+            NS_ASSERTION(minWithinPref >= 0, "neither value can be negative");
+            info.minCoord -= minWithinPref;
+
             // ... and actually do the distribution.
             for (scol = col, scol_end = col + colSpan;
                  scol < scol_end; ++scol) {
@@ -394,6 +400,15 @@ BasicTableLayoutStrategy::ComputeColumnI
                     scolFrame->AddSpanPrefPercent(spp);
                 }
 
+                // Distribute any min that fits under the pref width
+                // within the difference between min and pref width.
+                float minRatio = 0.0f;
+                if (minWithinPref > 0) {
+                    minRatio = float(scolFrame->GetPrefCoord() -
+                                     scolFrame->GetMinCoord()) /
+                               float(totalSPref - totalSMin);
+                }
+
                 float coordRatio; // for both min and pref
                 if (totalSPref > 0) {
                     coordRatio = float(scolFrame->GetPrefCoord()) /
@@ -402,7 +417,8 @@ BasicTableLayoutStrategy::ComputeColumnI
                     coordRatio = 1.0f / float(colSpan);
                 }
                 scolFrame->AddSpanMinCoord(NSToCoordRound(
-                               float(info.minCoord) * coordRatio));
+                               float(info.minCoord) * coordRatio +
+                               float(minWithinPref) * minRatio));
                 scolFrame->AddSpanPrefCoord(NSToCoordRound(
                                float(info.prefCoord) * coordRatio));
             }
@@ -411,12 +427,6 @@ BasicTableLayoutStrategy::ComputeColumnI
         // Combine the results of the span analysis into the main results,
         // for each increment of colspan.
 
-        // Prevent percentages from adding to more than 100% by (to be
-        // compatible with other browsers) treating any percentages that would
-        // increase the total percentage to more than 100% as the number that
-        // would increase it to only 100% (which is 0% if we've already hit
-        // 100%).  This means layout depends on the order of columns.
-        float pct_used = 0.0f;
         for (col = 0, col_end = cellMap->GetColCount(); col < col_end; ++col) {
             nsTableColFrame *colFrame = tableFrame->GetColFrame(col);
             if (!colFrame) {
@@ -442,8 +452,6 @@ BasicTableLayoutStrategy::ComputeColumnI
                          "min larger than pref");
             colFrame->AddPrefPercent(colFrame->GetSpanPrefPercent());
 
-            colFrame->AdjustPrefPercent(&pct_used);
-
             colFrame->ResetSpanMinCoord();
             colFrame->ResetSpanPrefCoord();
             colFrame->ResetSpanPrefPercent();
@@ -456,6 +464,23 @@ BasicTableLayoutStrategy::ComputeColumnI
 #endif
         }
     }
+
+    // Prevent percentages from adding to more than 100% by (to be
+    // compatible with other browsers) treating any percentages that would
+    // increase the total percentage to more than 100% as the number that
+    // would increase it to only 100% (which is 0% if we've already hit
+    // 100%).  This means layout depends on the order of columns.
+    float pct_used = 0.0f;
+    for (col = 0, col_end = cellMap->GetColCount(); col < col_end; ++col) {
+        nsTableColFrame *colFrame = tableFrame->GetColFrame(col);
+        if (!colFrame) {
+            NS_ERROR("column frames out of sync with cell map");
+            continue;
+        }
+
+        colFrame->AdjustPrefPercent(&pct_used);
+    }
+
 #ifdef DEBUG_TABLE_STRATEGY
     printf("ComputeColumnIntrinsicWidths spanning\n");
     mTableFrame->Dump(PR_FALSE, PR_TRUE, PR_FALSE);
