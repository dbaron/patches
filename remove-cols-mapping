From: L. David Baron <dbaron@dbaron.org>

Bug 835169:  Remove unused mapping into style of table/td cols attribute.

diff --git a/content/html/content/src/HTMLTableElement.cpp b/content/html/content/src/HTMLTableElement.cpp
--- a/content/html/content/src/HTMLTableElement.cpp
+++ b/content/html/content/src/HTMLTableElement.cpp
@@ -914,18 +914,17 @@ HTMLTableElement::ParseAttribute(int32_t
                                  nsAttrValue& aResult)
 {
   /* ignore summary, just a string */
   if (aNamespaceID == kNameSpaceID_None) {
     if (aAttribute == nsGkAtoms::cellspacing ||
         aAttribute == nsGkAtoms::cellpadding) {
       return aResult.ParseNonNegativeIntValue(aValue);
     }
-    if (aAttribute == nsGkAtoms::cols ||
-        aAttribute == nsGkAtoms::border) {
+    if (aAttribute == nsGkAtoms::border) {
       return aResult.ParseIntWithBounds(aValue, 0);
     }
     if (aAttribute == nsGkAtoms::height) {
       return aResult.ParseSpecialIntValue(aValue);
     }
     if (aAttribute == nsGkAtoms::width) {
       if (aResult.ParseSpecialIntValue(aValue)) {
         // treat 0 width as auto
@@ -1000,25 +999,16 @@ MapAttributesIntoRule(const nsMappedAttr
     const nsAttrValue* value;
     // layout
     nsCSSValue* tableLayout = aData->ValueForTableLayout();
     if (tableLayout->GetUnit() == eCSSUnit_Null) {
       value = aAttributes->GetAttr(nsGkAtoms::layout);
       if (value && value->Type() == nsAttrValue::eEnum)
         tableLayout->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
-    // cols
-    value = aAttributes->GetAttr(nsGkAtoms::cols);
-    if (value) {
-      nsCSSValue* cols = aData->ValueForCols();
-      if (value->Type() == nsAttrValue::eInteger)
-        cols->SetIntValue(value->GetIntegerValue(), eCSSUnit_Integer);
-      else // COLS had no value, so it refers to all columns
-        cols->SetIntValue(NS_STYLE_TABLE_COLS_ALL, eCSSUnit_Enumerated);
-    }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Margin)) {
     // align; Check for enumerated type (it may be another type if
     // illegal)
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
 
     if (value && value->Type() == nsAttrValue::eEnum) {
       if (value->GetEnumValue() == NS_STYLE_TEXT_ALIGN_CENTER ||
@@ -1130,17 +1120,16 @@ MapAttributesIntoRule(const nsMappedAttr
 
 NS_IMETHODIMP_(bool)
 HTMLTableElement::IsAttributeMapped(const nsIAtom* aAttribute) const
 {
   static const MappedAttributeEntry attributes[] = {
     { &nsGkAtoms::layout },
     { &nsGkAtoms::cellpadding },
     { &nsGkAtoms::cellspacing },
-    { &nsGkAtoms::cols },
     { &nsGkAtoms::border },
     { &nsGkAtoms::width },
     { &nsGkAtoms::height },
     { &nsGkAtoms::hspace },
     { &nsGkAtoms::vspace },
     
     { &nsGkAtoms::bordercolor },
     
diff --git a/layout/base/nsStyleConsts.h b/layout/base/nsStyleConsts.h
--- a/layout/base/nsStyleConsts.h
+++ b/layout/base/nsStyleConsts.h
@@ -767,19 +767,16 @@ static inline mozilla::css::Side operato
 
 // See nsStyleTable
 #define NS_STYLE_TABLE_RULES_NONE               0
 #define NS_STYLE_TABLE_RULES_GROUPS             1
 #define NS_STYLE_TABLE_RULES_ROWS               2
 #define NS_STYLE_TABLE_RULES_COLS               3
 #define NS_STYLE_TABLE_RULES_ALL                4
 
-#define NS_STYLE_TABLE_COLS_NONE                (-1)
-#define NS_STYLE_TABLE_COLS_ALL                 int32_t(1 << 30)
-
 #define NS_STYLE_TABLE_LAYOUT_AUTO              0
 #define NS_STYLE_TABLE_LAYOUT_FIXED             1
 
 #define NS_STYLE_TABLE_EMPTY_CELLS_HIDE            0
 #define NS_STYLE_TABLE_EMPTY_CELLS_SHOW            1
 #define NS_STYLE_TABLE_EMPTY_CELLS_SHOW_BACKGROUND 2
 
 #define NS_STYLE_CAPTION_SIDE_TOP               0
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -6614,22 +6614,16 @@ nsRuleNode::ComputeTableData(void* aStar
   COMPUTE_START_RESET(Table, (), table, parentTable)
 
   // table-layout: enum, inherit, initial
   SetDiscrete(*aRuleData->ValueForTableLayout(),
               table->mLayoutStrategy, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentTable->mLayoutStrategy,
               NS_STYLE_TABLE_LAYOUT_AUTO, 0, 0, 0, 0);
 
-  // cols: enum, int (not a real CSS prop)
-  const nsCSSValue* colsValue = aRuleData->ValueForCols();
-  if (eCSSUnit_Enumerated == colsValue->GetUnit() ||
-      eCSSUnit_Integer == colsValue->GetUnit())
-    table->mCols = colsValue->GetIntValue();
-
   // span: pixels (not a real CSS prop)
   const nsCSSValue* spanValue = aRuleData->ValueForSpan();
   if (eCSSUnit_Enumerated == spanValue->GetUnit() ||
       eCSSUnit_Integer == spanValue->GetUnit())
     table->mSpan = spanValue->GetIntValue();
 
   COMPUTE_END_RESET(Table, table)
 }
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -1733,17 +1733,16 @@ struct nsStyleTable {
   nsChangeHint CalcDifference(const nsStyleTable& aOther) const;
   static nsChangeHint MaxDifference() {
     return NS_STYLE_HINT_FRAMECHANGE;
   }
 
   uint8_t       mLayoutStrategy;// [reset] see nsStyleConsts.h NS_STYLE_TABLE_LAYOUT_*
   uint8_t       mFrame;         // [reset] see nsStyleConsts.h NS_STYLE_TABLE_FRAME_*
   uint8_t       mRules;         // [reset] see nsStyleConsts.h NS_STYLE_TABLE_RULES_*
-  int32_t       mCols;          // [reset] an integer if set, or see nsStyleConsts.h NS_STYLE_TABLE_COLS_*
   int32_t       mSpan;          // [reset] the number of columns spanned by a colgroup or col
 };
 
 struct nsStyleTableBorder {
   nsStyleTableBorder(nsPresContext* aContext);
   nsStyleTableBorder(const nsStyleTableBorder& aOther);
   ~nsStyleTableBorder(void);
 
