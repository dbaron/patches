From: L. David Baron <dbaron@dbaron.org>

Bug 896138 patch 6:  Move restyle management code from nsFrameManager to RestyleManager.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -7,32 +7,39 @@
  * Code responsible for managing style changes: tracking what style
  * changes need to happen, scheduling them, and doing them.
  */
 
 #include "RestyleManager.h"
 #include "nsLayoutUtils.h"
 #include "GeckoProfiler.h"
 #include "nsStyleChangeList.h"
+#include "nsRuleProcessorData.h"
 #include "nsCSSFrameConstructor.h"
 #include "nsSVGEffects.h"
 #include "nsCSSRendering.h"
 #include "nsAnimationManager.h"
 #include "nsTransitionManager.h"
 #include "nsViewManager.h"
 #include "nsRenderingContext.h"
 #include "nsSVGIntegrationUtils.h"
+#include "nsCSSAnonBoxes.h"
 #include "nsContainerFrame.h"
 #include "nsPlaceholderFrame.h"
+#include "nsBlockFrame.h"
 #include "nsViewportFrame.h"
 #include "nsSVGTextFrame2.h"
 #include "nsSVGTextPathFrame.h"
 #include "nsIRootBox.h"
 #include "nsIDOMMutationEvent.h"
 
+#ifdef ACCESSIBILITY
+#include "nsAccessibilityService.h"
+#endif
+
 namespace mozilla {
 
 RestyleManager::RestyleManager(nsPresContext *aPresContext)
   : mPresContext(aPresContext)
   , mRebuildAllStyleData(false)
   , mObservingRefreshDriver(false)
   , mInStyleRefresh(false)
   , mPromoteReflowsToReframeRoot(false)
@@ -613,17 +620,17 @@ RestyleManager::ProcessRestyledFrames(ns
 
 #ifdef DEBUG
     // reget frame from content since it may have been regenerated...
     if (changeData->mContent) {
       if (!nsAnimationManager::ContentOrAncestorHasAnimation(changeData->mContent) &&
           !nsTransitionManager::ContentOrAncestorHasTransition(changeData->mContent)) {
         nsIFrame* frame = changeData->mContent->GetPrimaryFrame();
         if (frame) {
-          FrameConstructor()->DebugVerifyStyleTree(frame);
+          DebugVerifyStyleTree(frame);
         }
       }
     } else if (!changeData->mFrame ||
                changeData->mFrame->GetType() != nsGkAtoms::viewportFrame) {
       NS_WARNING("Unable to test style tree integrity -- no content node "
                  "(and not a viewport frame)");
     }
 #endif
@@ -669,17 +676,16 @@ RestyleManager::RestyleElement(Element  
       }
     }
   }
 
   if (aMinHint & nsChangeHint_ReconstructFrame) {
     FrameConstructor()->RecreateFramesForContent(aElement, false);
   } else if (aPrimaryFrame) {
     nsStyleChangeList changeList;
-    FrameConstructor()-> // NOTE: removed later in patch series
     ComputeStyleChangeFor(aPrimaryFrame, &changeList, aMinHint,
                           aRestyleTracker, aRestyleDescendants);
     ProcessRestyledFrames(changeList);
   } else {
     // no frames, reconstruct for content
     FrameConstructor()->MaybeRecreateFramesForElement(aElement);
   }
 }
@@ -913,17 +919,16 @@ RestyleManager::DoRebuildAllStyleData(Re
   // because we never need to reframe the root frame
   // XXX This could be made faster by not rerunning rule matching
   // (but note that nsPresShell::SetPreferenceStyleRules currently depends
   // on us re-running rule matching here
   nsStyleChangeList changeList;
   // XXX Does it matter that we're passing aExtraHint to the real root
   // frame and not the root node's primary frame?
   // Note: The restyle tracker we pass in here doesn't matter.
-  FrameConstructor()-> // NOTE: removed later in patch series
   ComputeStyleChangeFor(mPresContext->GetPresShell()->GetRootFrame(),
                         &changeList, aExtraHint,
                         aRestyleTracker, true);
   // Process the required changes
   ProcessRestyledFrames(changeList);
   FlushOverflowChangedTracker();
 
   // Tell the style set it's safe to destroy the old rule tree.  We
@@ -1193,9 +1198,1235 @@ RestyleManager::RecomputePosition(nsIFra
     return true;
   }
 
   // Fall back to a reflow
   StyleChangeReflow(aFrame, nsChangeHint_NeedReflow);
   return false;
 }
 
+#ifdef DEBUG
+static void
+DumpContext(nsIFrame* aFrame, nsStyleContext* aContext)
+{
+  if (aFrame) {
+    fputs("frame: ", stdout);
+    nsAutoString  name;
+    aFrame->GetFrameName(name);
+    fputs(NS_LossyConvertUTF16toASCII(name).get(), stdout);
+    fprintf(stdout, " (%p)", static_cast<void*>(aFrame));
+  }
+  if (aContext) {
+    fprintf(stdout, " style: %p ", static_cast<void*>(aContext));
+
+    nsIAtom* pseudoTag = aContext->GetPseudo();
+    if (pseudoTag) {
+      nsAutoString  buffer;
+      pseudoTag->ToString(buffer);
+      fputs(NS_LossyConvertUTF16toASCII(buffer).get(), stdout);
+      fputs(" ", stdout);
+    }
+    fputs("{}\n", stdout);
+  }
+}
+
+static void
+VerifySameTree(nsStyleContext* aContext1, nsStyleContext* aContext2)
+{
+  nsStyleContext* top1 = aContext1;
+  nsStyleContext* top2 = aContext2;
+  nsStyleContext* parent;
+  for (;;) {
+    parent = top1->GetParent();
+    if (!parent)
+      break;
+    top1 = parent;
+  }
+  for (;;) {
+    parent = top2->GetParent();
+    if (!parent)
+      break;
+    top2 = parent;
+  }
+  NS_ASSERTION(top1 == top2,
+               "Style contexts are not in the same style context tree");
+}
+
+static void
+VerifyContextParent(nsPresContext* aPresContext, nsIFrame* aFrame,
+                    nsStyleContext* aContext, nsStyleContext* aParentContext)
+{
+  // get the contexts not provided
+  if (!aContext) {
+    aContext = aFrame->StyleContext();
+  }
+
+  if (!aParentContext) {
+    // Get the correct parent context from the frame
+    //  - if the frame is a placeholder, we get the out of flow frame's context
+    //    as the parent context instead of asking the frame
+
+    // get the parent context from the frame (indirectly)
+    nsIFrame* providerFrame = aFrame->GetParentStyleContextFrame();
+    if (providerFrame)
+      aParentContext = providerFrame->StyleContext();
+    // aParentContext could still be null
+  }
+
+  NS_ASSERTION(aContext, "Failure to get required contexts");
+  nsStyleContext* actualParentContext = aContext->GetParent();
+
+  if (aParentContext) {
+    if (aParentContext != actualParentContext) {
+      DumpContext(aFrame, aContext);
+      if (aContext == aParentContext) {
+        NS_ERROR("Using parent's style context");
+      }
+      else {
+        NS_ERROR("Wrong parent style context");
+        fputs("Wrong parent style context: ", stdout);
+        DumpContext(nullptr, actualParentContext);
+        fputs("should be using: ", stdout);
+        DumpContext(nullptr, aParentContext);
+        VerifySameTree(actualParentContext, aParentContext);
+        fputs("\n", stdout);
+      }
+    }
+
+  }
+  else {
+    if (actualParentContext) {
+      NS_ERROR("Have parent context and shouldn't");
+      DumpContext(aFrame, aContext);
+      fputs("Has parent context: ", stdout);
+      DumpContext(nullptr, actualParentContext);
+      fputs("Should be null\n\n", stdout);
+    }
+  }
+
+  nsStyleContext* childStyleIfVisited = aContext->GetStyleIfVisited();
+  // Either childStyleIfVisited has aContext->GetParent()->GetStyleIfVisited()
+  // as the parent or it has a different rulenode from aContext _and_ has
+  // aContext->GetParent() as the parent.
+  if (childStyleIfVisited &&
+      !((childStyleIfVisited->RuleNode() != aContext->RuleNode() &&
+         childStyleIfVisited->GetParent() == aContext->GetParent()) ||
+        childStyleIfVisited->GetParent() ==
+          aContext->GetParent()->GetStyleIfVisited())) {
+    NS_ERROR("Visited style has wrong parent");
+    DumpContext(aFrame, aContext);
+    fputs("\n", stdout);
+  }
+}
+
+static void
+VerifyStyleTree(nsPresContext* aPresContext, nsIFrame* aFrame,
+                nsStyleContext* aParentContext)
+{
+  nsStyleContext*  context = aFrame->StyleContext();
+  VerifyContextParent(aPresContext, aFrame, context, nullptr);
+
+  nsIFrame::ChildListIterator lists(aFrame);
+  for (; !lists.IsDone(); lists.Next()) {
+    nsFrameList::Enumerator childFrames(lists.CurrentList());
+    for (; !childFrames.AtEnd(); childFrames.Next()) {
+      nsIFrame* child = childFrames.get();
+      if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
+        // only do frames that are in flow
+        if (nsGkAtoms::placeholderFrame == child->GetType()) {
+          // placeholder: first recurse and verify the out of flow frame,
+          // then verify the placeholder's context
+          nsIFrame* outOfFlowFrame =
+            nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
+
+          // recurse to out of flow frame, letting the parent context get resolved
+          do {
+            VerifyStyleTree(aPresContext, outOfFlowFrame, nullptr);
+          } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
+
+          // verify placeholder using the parent frame's context as
+          // parent context
+          VerifyContextParent(aPresContext, child, nullptr, nullptr);
+        }
+        else { // regular frame
+          VerifyStyleTree(aPresContext, child, nullptr);
+        }
+      }
+    }
+  }
+
+  // do additional contexts
+  int32_t contextIndex = -1;
+  while (1) {
+    nsStyleContext* extraContext = aFrame->GetAdditionalStyleContext(++contextIndex);
+    if (extraContext) {
+      VerifyContextParent(aPresContext, aFrame, extraContext, context);
+    }
+    else {
+      break;
+    }
+  }
+}
+
+void
+RestyleManager::DebugVerifyStyleTree(nsIFrame* aFrame)
+{
+  if (aFrame) {
+    nsStyleContext* context = aFrame->StyleContext();
+    nsStyleContext* parentContext = context->GetParent();
+    VerifyStyleTree(mPresContext, aFrame, parentContext);
+  }
+}
+
+#endif // DEBUG
+
+// aContent must be the content for the frame in question, which may be
+// :before/:after content
+static void
+TryStartingTransition(nsPresContext *aPresContext, nsIContent *aContent,
+                      nsStyleContext *aOldStyleContext,
+                      nsRefPtr<nsStyleContext> *aNewStyleContext /* inout */)
+{
+  if (!aContent || !aContent->IsElement()) {
+    return;
+  }
+
+  // Notify the transition manager, and if it starts a transition,
+  // it will give us back a transition-covering style rule which
+  // we'll use to get *another* style context.  We want to ignore
+  // any already-running transitions, but cover up any that we're
+  // currently starting with their start value so we don't start
+  // them again for descendants that inherit that value.
+  nsCOMPtr<nsIStyleRule> coverRule =
+    aPresContext->TransitionManager()->StyleContextChanged(
+      aContent->AsElement(), aOldStyleContext, *aNewStyleContext);
+  if (coverRule) {
+    nsCOMArray<nsIStyleRule> rules;
+    rules.AppendObject(coverRule);
+    *aNewStyleContext = aPresContext->StyleSet()->
+                          ResolveStyleByAddingRules(*aNewStyleContext, rules);
+  }
+}
+
+static inline dom::Element*
+ElementForStyleContext(nsIContent* aParentContent,
+                       nsIFrame* aFrame,
+                       nsCSSPseudoElements::Type aPseudoType)
+{
+  // We don't expect XUL tree stuff here.
+  NS_PRECONDITION(aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ||
+                  aPseudoType == nsCSSPseudoElements::ePseudo_AnonBox ||
+                  aPseudoType < nsCSSPseudoElements::ePseudo_PseudoElementCount,
+                  "Unexpected pseudo");
+  // XXX see the comments about the various element confusion in
+  // ReResolveStyleContext.
+  if (aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
+    return aFrame->GetContent()->AsElement();
+  }
+
+  if (aPseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
+    return nullptr;
+  }
+
+  if (aPseudoType == nsCSSPseudoElements::ePseudo_firstLetter) {
+    NS_ASSERTION(aFrame->GetType() == nsGkAtoms::letterFrame,
+                 "firstLetter pseudoTag without a nsFirstLetterFrame");
+    nsBlockFrame* block = nsBlockFrame::GetNearestAncestorBlock(aFrame);
+    return block->GetContent()->AsElement();
+  }
+
+  nsIContent* content = aParentContent ? aParentContent : aFrame->GetContent();
+  return content->AsElement();
+}
+
+static nsIFrame*
+GetPrevContinuationWithPossiblySameStyle(nsIFrame* aFrame)
+{
+  // Account for {ib} splits when looking for "prevContinuation".  In
+  // particular, for the first-continuation of a part of an {ib} split we
+  // want to use the special prevsibling of the special prevsibling of
+  // aFrame, which should have the same style context as aFrame itself.
+  // In particular, if aFrame is the first continuation of an inline part
+  // of an {ib} split then its special prevsibling is a block, and the
+  // special prevsibling of _that_ is an inline, just like aFrame.
+  // Similarly, if aFrame is the first continuation of a block part of an
+  // {ib} split (an {ib} wrapper block), then its special prevsibling is
+  // an inline and the special prevsibling of that is either another {ib}
+  // wrapper block block or null.
+  nsIFrame *prevContinuation = aFrame->GetPrevContinuation();
+  if (!prevContinuation && (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
+    // We're the first continuation, so we can just get the frame
+    // property directly
+    prevContinuation = static_cast<nsIFrame*>(
+      aFrame->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
+    if (prevContinuation) {
+      prevContinuation = static_cast<nsIFrame*>(
+        prevContinuation->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
+    }
+  }
+  return prevContinuation;
+}
+
+nsresult
+RestyleManager::ReparentStyleContext(nsIFrame* aFrame)
+{
+  if (nsGkAtoms::placeholderFrame == aFrame->GetType()) {
+    // Also reparent the out-of-flow and all its continuations.
+    nsIFrame* outOfFlow =
+      nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
+    NS_ASSERTION(outOfFlow, "no out-of-flow frame");
+    do {
+      ReparentStyleContext(outOfFlow);
+    } while ((outOfFlow = outOfFlow->GetNextContinuation()));
+  }
+
+  // DO NOT verify the style tree before reparenting.  The frame
+  // tree has already been changed, so this check would just fail.
+  nsStyleContext* oldContext = aFrame->StyleContext();
+  // XXXbz can oldContext really ever be null?
+  if (oldContext) {
+    nsRefPtr<nsStyleContext> newContext;
+    nsIFrame* providerFrame = aFrame->GetParentStyleContextFrame();
+    bool isChild = providerFrame && providerFrame->GetParent() == aFrame;
+    nsStyleContext* newParentContext = nullptr;
+    nsIFrame* providerChild = nullptr;
+    if (isChild) {
+      ReparentStyleContext(providerFrame);
+      newParentContext = providerFrame->StyleContext();
+      providerChild = providerFrame;
+    } else if (providerFrame) {
+      newParentContext = providerFrame->StyleContext();
+    } else {
+      NS_NOTREACHED("Reparenting something that has no usable parent? "
+                    "Shouldn't happen!");
+    }
+    // XXX need to do something here to produce the correct style context for
+    // an IB split whose first inline part is inside a first-line frame.
+    // Currently the first IB anonymous block's style context takes the first
+    // part's style context as parent, which is wrong since first-line style
+    // should not apply to the anonymous block.
+
+#ifdef DEBUG
+    {
+      // Check that our assumption that continuations of the same
+      // pseudo-type and with the same style context parent have the
+      // same style context is valid before the reresolution.  (We need
+      // to check the pseudo-type and style context parent because of
+      // :first-letter and :first-line, where we create styled and
+      // unstyled letter/line frames distinguished by pseudo-type, and
+      // then need to distinguish their descendants based on having
+      // different parents.)
+      nsIFrame *nextContinuation = aFrame->GetNextContinuation();
+      if (nextContinuation) {
+        nsStyleContext *nextContinuationContext =
+          nextContinuation->StyleContext();
+        NS_ASSERTION(oldContext == nextContinuationContext ||
+                     oldContext->GetPseudo() !=
+                       nextContinuationContext->GetPseudo() ||
+                     oldContext->GetParent() !=
+                       nextContinuationContext->GetParent(),
+                     "continuations should have the same style context");
+      }
+    }
+#endif
+
+    nsIFrame *prevContinuation =
+      GetPrevContinuationWithPossiblySameStyle(aFrame);
+    nsStyleContext *prevContinuationContext;
+    bool copyFromContinuation =
+      prevContinuation &&
+      (prevContinuationContext = prevContinuation->StyleContext())
+        ->GetPseudo() == oldContext->GetPseudo() &&
+       prevContinuationContext->GetParent() == newParentContext;
+    if (copyFromContinuation) {
+      // Just use the style context from the frame's previous
+      // continuation (see assertion about aFrame->GetNextContinuation()
+      // above, which we would have previously hit for aFrame's previous
+      // continuation).
+      newContext = prevContinuationContext;
+    } else {
+      nsIFrame* parentFrame = aFrame->GetParent();
+      Element* element =
+        ElementForStyleContext(parentFrame ? parentFrame->GetContent() : nullptr,
+                               aFrame,
+                               oldContext->GetPseudoType());
+      newContext = mPresContext->StyleSet()->
+                     ReparentStyleContext(oldContext, newParentContext, element);
+    }
+
+    if (newContext) {
+      if (newContext != oldContext) {
+        // We probably don't want to initiate transitions from
+        // ReparentStyleContext, since we call it during frame
+        // construction rather than in response to dynamic changes.
+        // Also see the comment at the start of
+        // nsTransitionManager::ConsiderStartingTransition.
+#if 0
+        if (!copyFromContinuation) {
+          TryStartingTransition(mPresContext, aFrame->GetContent(),
+                                oldContext, &newContext);
+        }
+#endif
+
+        // Make sure to call CalcStyleDifference so that the new context ends
+        // up resolving all the structs the old context resolved.
+        DebugOnly<nsChangeHint> styleChange =
+          oldContext->CalcStyleDifference(newContext, nsChangeHint(0));
+        // The style change is always 0 because we have the same rulenode and
+        // CalcStyleDifference optimizes us away.  That's OK, though:
+        // reparenting should never trigger a frame reconstruct, and whenever
+        // it's happening we already plan to reflow and repaint the frames.
+        NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
+                     "Our frame tree is likely to be bogus!");
+
+        aFrame->SetStyleContext(newContext);
+
+        nsIFrame::ChildListIterator lists(aFrame);
+        for (; !lists.IsDone(); lists.Next()) {
+          nsFrameList::Enumerator childFrames(lists.CurrentList());
+          for (; !childFrames.AtEnd(); childFrames.Next()) {
+            nsIFrame* child = childFrames.get();
+            // only do frames that are in flow
+            if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
+                child != providerChild) {
+#ifdef DEBUG
+              if (nsGkAtoms::placeholderFrame == child->GetType()) {
+                nsIFrame* outOfFlowFrame =
+                  nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
+                NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
+
+                NS_ASSERTION(outOfFlowFrame != providerChild,
+                             "Out of flow provider?");
+              }
+#endif
+              ReparentStyleContext(child);
+            }
+          }
+        }
+
+        // If this frame is part of an IB split, then the style context of
+        // the next part of the split might be a child of our style context.
+        // Reparent its style context just in case one of our ancestors
+        // (split or not) hasn't done so already). It's not a problem to
+        // reparent the same frame twice because the "if (newContext !=
+        // oldContext)" check will prevent us from redoing work.
+        if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
+            !aFrame->GetPrevContinuation()) {
+          nsIFrame* sib = static_cast<nsIFrame*>
+            (aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+          if (sib) {
+            ReparentStyleContext(sib);
+          }
+        }
+
+        // do additional contexts
+        int32_t contextIndex = -1;
+        while (1) {
+          nsStyleContext* oldExtraContext =
+            aFrame->GetAdditionalStyleContext(++contextIndex);
+          if (oldExtraContext) {
+            nsRefPtr<nsStyleContext> newExtraContext;
+            newExtraContext = mPresContext->StyleSet()->
+                                ReparentStyleContext(oldExtraContext,
+                                                     newContext, nullptr);
+            if (newExtraContext) {
+              if (newExtraContext != oldExtraContext) {
+                // Make sure to call CalcStyleDifference so that the new
+                // context ends up resolving all the structs the old context
+                // resolved.
+                styleChange =
+                  oldExtraContext->CalcStyleDifference(newExtraContext,
+                                                       nsChangeHint(0));
+                // The style change is always 0 because we have the same
+                // rulenode and CalcStyleDifference optimizes us away.  That's
+                // OK, though: reparenting should never trigger a frame
+                // reconstruct, and whenever it's happening we already plan to
+                // reflow and repaint the frames.
+                NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
+                             "Our frame tree is likely to be bogus!");
+              }
+
+              aFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
+            }
+          }
+          else {
+            break;
+          }
+        }
+#ifdef DEBUG
+        VerifyStyleTree(mPresContext, aFrame, newParentContext);
+#endif
+      }
+    }
+  }
+  return NS_OK;
+}
+
+static void
+CaptureChange(nsStyleContext* aOldContext, nsStyleContext* aNewContext,
+              nsIFrame* aFrame, nsIContent* aContent,
+              nsStyleChangeList* aChangeList,
+              /*inout*/nsChangeHint &aMinChange,
+              /*in*/nsChangeHint aParentHintsNotHandledForDescendants,
+              /*out*/nsChangeHint &aHintsNotHandledForDescendants,
+              nsChangeHint aChangeToAssume)
+{
+  nsChangeHint ourChange = aOldContext->CalcStyleDifference(aNewContext,
+                             aParentHintsNotHandledForDescendants);
+  NS_ASSERTION(!(ourChange & nsChangeHint_AllReflowHints) ||
+               (ourChange & nsChangeHint_NeedReflow),
+               "Reflow hint bits set without actually asking for a reflow");
+
+  // nsChangeHint_UpdateEffects is inherited, but it can be set due to changes
+  // in inherited properties (fill and stroke).  Avoid propagating it into
+  // text nodes.
+  if ((ourChange & nsChangeHint_UpdateEffects) &&
+      aContent && !aContent->IsElement()) {
+    ourChange = NS_SubtractHint(ourChange, nsChangeHint_UpdateEffects);
+  }
+
+  NS_UpdateHint(ourChange, aChangeToAssume);
+  if (NS_UpdateHint(aMinChange, ourChange)) {
+    if (!(ourChange & nsChangeHint_ReconstructFrame) || aContent) {
+      aChangeList->AppendChange(aFrame, aContent, ourChange);
+    }
+  }
+  aHintsNotHandledForDescendants = NS_HintsNotHandledForDescendantsIn(ourChange);
+}
+
+/**
+ * Recompute style for aFrame and accumulate changes into aChangeList
+ * given that aMinChange is already accumulated for an ancestor.
+ * aParentContent is the content node used to resolve the parent style
+ * context.  This means that, for pseudo-elements, it is the content
+ * that should be used for selector matching (rather than the fake
+ * content node attached to the frame).
+ *
+ * For aParentFrameHintsNotHandledForDescendants, see
+ * nsStyleContext::CalcStyleDifference.
+ */
+nsChangeHint
+RestyleManager::ReResolveStyleContext(nsPresContext     *aPresContext,
+                                      nsIFrame          *aFrame,
+                                      nsIContent        *aParentContent,
+                                      nsStyleChangeList *aChangeList,
+                                      nsChangeHint       aMinChange,
+                                      nsChangeHint       aParentFrameHintsNotHandledForDescendants,
+                                      nsRestyleHint      aRestyleHint,
+                                      RestyleTracker&    aRestyleTracker,
+                                      DesiredA11yNotifications aDesiredA11yNotifications,
+                                      nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
+                                      TreeMatchContext &aTreeMatchContext)
+{
+  // We need to generate a new change list entry for every frame whose style
+  // comparision returns one of these hints. These hints don't automatically
+  // update all their descendant frames.
+  aMinChange = NS_SubtractHint(aMinChange, NS_HintsNotHandledForDescendantsIn(aMinChange));
+
+  // It would be nice if we could make stronger assertions here; they
+  // would let us simplify the ?: expressions below setting |content|
+  // and |pseudoContent| in sensible ways as well as making what
+  // |localContent|, |content|, and |pseudoContent| mean make more
+  // sense.  However, we can't, because of frame trees like the one in
+  // https://bugzilla.mozilla.org/show_bug.cgi?id=472353#c14 .  Once we
+  // fix bug 242277 we should be able to make this make more sense.
+  NS_ASSERTION(aFrame->GetContent() || !aParentContent ||
+               !aParentContent->GetParent(),
+               "frame must have content (unless at the top of the tree)");
+  // XXXldb get new context from prev-in-flow if possible, to avoid
+  // duplication.  (Or should we just let |GetContext| handle that?)
+  // Getting the hint would be nice too, but that's harder.
+
+  // XXXbryner we may be able to avoid some of the refcounting goop here.
+  // We do need a reference to oldContext for the lifetime of this function, and it's possible
+  // that the frame has the last reference to it, so AddRef it here.
+
+  nsChangeHint assumeDifferenceHint = NS_STYLE_HINT_NONE;
+  // XXXbz oldContext should just be an nsRefPtr
+  nsStyleContext* oldContext = aFrame->StyleContext();
+  nsStyleSet* styleSet = aPresContext->StyleSet();
+
+  // XXXbz the nsIFrame constructor takes an nsStyleContext, so how
+  // could oldContext be null?
+  if (oldContext) {
+    oldContext->AddRef();
+
+#ifdef ACCESSIBILITY
+    bool wasFrameVisible = nsIPresShell::IsAccessibilityActive() ?
+      oldContext->StyleVisibility()->IsVisible() : false;
+#endif
+
+    nsIAtom* const pseudoTag = oldContext->GetPseudo();
+    const nsCSSPseudoElements::Type pseudoType = oldContext->GetPseudoType();
+    nsIContent* localContent = aFrame->GetContent();
+    // |content| is the node that we used for rule matching of
+    // normal elements (not pseudo-elements) and for which we generate
+    // framechange hints if we need them.
+    // XXXldb Why does it make sense to use aParentContent?  (See
+    // comment above assertion at start of function.)
+    nsIContent* content = localContent ? localContent : aParentContent;
+
+    if (content && content->IsElement()) {
+      content->OwnerDoc()->FlushPendingLinkUpdates();
+      RestyleTracker::RestyleData restyleData;
+      if (aRestyleTracker.GetRestyleData(content->AsElement(), &restyleData)) {
+        if (NS_UpdateHint(aMinChange, restyleData.mChangeHint)) {
+          aChangeList->AppendChange(aFrame, content, restyleData.mChangeHint);
+        }
+        aRestyleHint = nsRestyleHint(aRestyleHint | restyleData.mRestyleHint);
+      }
+    }
+
+    nsRestyleHint childRestyleHint = aRestyleHint;
+
+    if (childRestyleHint == eRestyle_Self) {
+      childRestyleHint = nsRestyleHint(0);
+    }
+
+    nsStyleContext* parentContext;
+    nsIFrame* resolvedChild = nullptr;
+    // Get the frame providing the parent style context.  If it is a
+    // child, then resolve the provider first.
+    nsIFrame* providerFrame = aFrame->GetParentStyleContextFrame();
+    bool isChild = providerFrame && providerFrame->GetParent() == aFrame;
+    if (!isChild) {
+      if (providerFrame)
+        parentContext = providerFrame->StyleContext();
+      else
+        parentContext = nullptr;
+    }
+    else {
+      MOZ_ASSERT(providerFrame->GetContent() == aFrame->GetContent(),
+                 "Postcondition for GetParentStyleContextFrame() violated. "
+                 "That means we need to add the current element to the "
+                 "ancestor filter.");
+
+      // resolve the provider here (before aFrame below).
+
+      // assumeDifferenceHint forces the parent's change to be also
+      // applied to this frame, no matter what
+      // nsStyleContext::CalcStyleDifference says. CalcStyleDifference
+      // can't be trusted because it assumes any changes to the parent
+      // style context provider will be automatically propagated to
+      // the frame(s) with child style contexts.
+
+      assumeDifferenceHint = ReResolveStyleContext(aPresContext, providerFrame,
+                                                   aParentContent, aChangeList,
+                                                   aMinChange,
+                                                   nsChangeHint_Hints_NotHandledForDescendants,
+                                                   aRestyleHint,
+                                                   aRestyleTracker,
+                                                   aDesiredA11yNotifications,
+                                                   aVisibleKidsOfHiddenElement,
+                                                   aTreeMatchContext);
+
+      // The provider's new context becomes the parent context of
+      // aFrame's context.
+      parentContext = providerFrame->StyleContext();
+      // Set |resolvedChild| so we don't bother resolving the
+      // provider again.
+      resolvedChild = providerFrame;
+    }
+
+    if (providerFrame != aFrame->GetParent()) {
+      // We don't actually know what the parent style context's
+      // non-inherited hints were, so assume the worst.
+      aParentFrameHintsNotHandledForDescendants =
+        nsChangeHint_Hints_NotHandledForDescendants;
+    }
+
+#ifdef DEBUG
+    {
+      // Check that our assumption that continuations of the same
+      // pseudo-type and with the same style context parent have the
+      // same style context is valid before the reresolution.  (We need
+      // to check the pseudo-type and style context parent because of
+      // :first-letter and :first-line, where we create styled and
+      // unstyled letter/line frames distinguished by pseudo-type, and
+      // then need to distinguish their descendants based on having
+      // different parents.)
+      nsIFrame *nextContinuation = aFrame->GetNextContinuation();
+      if (nextContinuation) {
+        nsStyleContext *nextContinuationContext =
+          nextContinuation->StyleContext();
+        NS_ASSERTION(oldContext == nextContinuationContext ||
+                     oldContext->GetPseudo() !=
+                       nextContinuationContext->GetPseudo() ||
+                     oldContext->GetParent() !=
+                       nextContinuationContext->GetParent(),
+                     "continuations should have the same style context");
+      }
+      // And assert the same thing for {ib} splits.  See the comments in
+      // GetPrevContinuationWithPossiblySameStyle for an explanation of
+      // why we step two forward in the special sibling chain.
+      if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
+          !aFrame->GetPrevContinuation()) {
+        nsIFrame *nextIBSibling = static_cast<nsIFrame*>(
+          aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+        if (nextIBSibling) {
+          nextIBSibling = static_cast<nsIFrame*>(
+            nextIBSibling->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+        }
+        if (nextIBSibling) {
+          nsStyleContext *nextIBSiblingContext =
+            nextIBSibling->StyleContext();
+          NS_ASSERTION(oldContext == nextIBSiblingContext ||
+                       oldContext->GetPseudo() !=
+                         nextIBSiblingContext->GetPseudo() ||
+                       oldContext->GetParent() !=
+                         nextIBSiblingContext->GetParent(),
+                       "continuations should have the same style context");
+        }
+      }
+    }
+#endif
+
+    // do primary context
+    nsRefPtr<nsStyleContext> newContext;
+    nsChangeHint nonInheritedHints = nsChangeHint(0);
+    nsIFrame *prevContinuation =
+      GetPrevContinuationWithPossiblySameStyle(aFrame);
+    nsStyleContext *prevContinuationContext;
+    bool copyFromContinuation =
+      prevContinuation &&
+      (prevContinuationContext = prevContinuation->StyleContext())
+        ->GetPseudo() == oldContext->GetPseudo() &&
+       prevContinuationContext->GetParent() == parentContext;
+    if (copyFromContinuation) {
+      // Just use the style context from the frame's previous
+      // continuation (see assertion about aFrame->GetNextContinuation()
+      // above, which we would have previously hit for aFrame's previous
+      // continuation).
+      newContext = prevContinuationContext;
+    }
+    else if (pseudoTag == nsCSSAnonBoxes::mozNonElement) {
+      NS_ASSERTION(localContent,
+                   "non pseudo-element frame without content node");
+      newContext = styleSet->ResolveStyleForNonElement(parentContext);
+    }
+    else if (!aRestyleHint && !prevContinuation) {
+      // Unfortunately, if prevContinuation is non-null then we may have
+      // already stolen the restyle tracker entry for this element while
+      // processing prevContinuation.  So we don't know whether aRestyleHint
+      // should really be 0 here or whether it should be eRestyle_Self.  Be
+      // pessimistic and force an actual reresolve in that situation.  The good
+      // news is that in the common case when prevContinuation is non-null we
+      // just used prevContinuationContext anyway and aren't reaching this code
+      // to start with.
+      newContext =
+        styleSet->ReparentStyleContext(oldContext, parentContext,
+                                       ElementForStyleContext(aParentContent,
+                                                              aFrame,
+                                                              pseudoType));
+    } else if (pseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
+      newContext = styleSet->ResolveAnonymousBoxStyle(pseudoTag,
+                                                      parentContext);
+    }
+    else {
+      Element* element = ElementForStyleContext(aParentContent,
+                                                aFrame,
+                                                pseudoType);
+      if (pseudoTag) {
+        if (pseudoTag == nsCSSPseudoElements::before ||
+            pseudoTag == nsCSSPseudoElements::after) {
+          // XXX what other pseudos do we need to treat like this?
+          newContext = styleSet->ProbePseudoElementStyle(element,
+                                                         pseudoType,
+                                                         parentContext,
+                                                         aTreeMatchContext);
+          if (!newContext) {
+            // This pseudo should no longer exist; gotta reframe
+            NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
+            aChangeList->AppendChange(aFrame, element,
+                                      nsChangeHint_ReconstructFrame);
+            // We're reframing anyway; just keep the same context
+            newContext = oldContext;
+          }
+        } else {
+          // Don't expect XUL tree stuff here, since it needs a comparator and
+          // all.
+          NS_ASSERTION(pseudoType <
+                         nsCSSPseudoElements::ePseudo_PseudoElementCount,
+                       "Unexpected pseudo type");
+          newContext = styleSet->ResolvePseudoElementStyle(element,
+                                                           pseudoType,
+                                                           parentContext);
+        }
+      }
+      else {
+        NS_ASSERTION(localContent,
+                     "non pseudo-element frame without content node");
+        // Skip flex-item style fixup for anonymous subtrees:
+        TreeMatchContext::AutoFlexItemStyleFixupSkipper
+          flexFixupSkipper(aTreeMatchContext,
+                           element->IsRootOfNativeAnonymousSubtree());
+        newContext = styleSet->ResolveStyleFor(element, parentContext,
+                                               aTreeMatchContext);
+      }
+    }
+
+    NS_ASSERTION(newContext, "failed to get new style context");
+    if (newContext) {
+      if (!parentContext) {
+        if (oldContext->RuleNode() == newContext->RuleNode() &&
+            oldContext->IsLinkContext() == newContext->IsLinkContext() &&
+            oldContext->RelevantLinkVisited() ==
+              newContext->RelevantLinkVisited()) {
+          // We're the root of the style context tree and the new style
+          // context returned has the same rule node.  This means that
+          // we can use FindChildWithRules to keep a lot of the old
+          // style contexts around.  However, we need to start from the
+          // same root.
+          newContext = oldContext;
+        }
+      }
+
+      if (newContext != oldContext) {
+        if (!copyFromContinuation) {
+          TryStartingTransition(aPresContext, aFrame->GetContent(),
+                                oldContext, &newContext);
+        }
+
+        CaptureChange(oldContext, newContext, aFrame, content, aChangeList,
+                      aMinChange, aParentFrameHintsNotHandledForDescendants,
+                      nonInheritedHints, assumeDifferenceHint);
+        if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
+          // if frame gets regenerated, let it keep old context
+          aFrame->SetStyleContext(newContext);
+        }
+      }
+      oldContext->Release();
+    }
+    else {
+      NS_ERROR("resolve style context failed");
+      newContext = oldContext;  // new context failed, recover...
+    }
+
+    // do additional contexts
+    // XXXbz might be able to avoid selector matching here in some
+    // cases; won't worry about it for now.
+    int32_t contextIndex = -1;
+    while (1 == 1) {
+      nsStyleContext* oldExtraContext = nullptr;
+      oldExtraContext = aFrame->GetAdditionalStyleContext(++contextIndex);
+      if (oldExtraContext) {
+        nsRefPtr<nsStyleContext> newExtraContext;
+        nsIAtom* const extraPseudoTag = oldExtraContext->GetPseudo();
+        const nsCSSPseudoElements::Type extraPseudoType =
+          oldExtraContext->GetPseudoType();
+        NS_ASSERTION(extraPseudoTag &&
+                     extraPseudoTag != nsCSSAnonBoxes::mozNonElement,
+                     "extra style context is not pseudo element");
+        if (extraPseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
+          newExtraContext = styleSet->ResolveAnonymousBoxStyle(extraPseudoTag,
+                                                               newContext);
+        }
+        else {
+          // Don't expect XUL tree stuff here, since it needs a comparator and
+          // all.
+          NS_ASSERTION(extraPseudoType <
+                         nsCSSPseudoElements::ePseudo_PseudoElementCount,
+                       "Unexpected type");
+          newExtraContext = styleSet->ResolvePseudoElementStyle(content->AsElement(),
+                                                                extraPseudoType,
+                                                                newContext);
+        }
+        if (newExtraContext) {
+          if (oldExtraContext != newExtraContext) {
+            nsChangeHint extraHintsNotHandledForDescendants = nsChangeHint(0);
+            CaptureChange(oldExtraContext, newExtraContext, aFrame, content,
+                          aChangeList, aMinChange,
+                          aParentFrameHintsNotHandledForDescendants,
+                          extraHintsNotHandledForDescendants,
+                          assumeDifferenceHint);
+            NS_UpdateHint(nonInheritedHints, extraHintsNotHandledForDescendants);
+            if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
+              aFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
+            }
+          }
+        }
+      }
+      else {
+        break;
+      }
+    }
+
+    // now look for undisplayed child content and pseudos
+
+    // When the root element is display:none, we still construct *some*
+    // frames that have the root element as their mContent, down to the
+    // DocElementContainingBlock.
+    bool checkUndisplayed;
+    nsIContent *undisplayedParent;
+    nsCSSFrameConstructor *frameConstructor = FrameConstructor();
+    if (pseudoTag) {
+      checkUndisplayed = aFrame == frameConstructor->
+                                     GetDocElementContainingBlock();
+      undisplayedParent = nullptr;
+    } else {
+      checkUndisplayed = !!localContent;
+      undisplayedParent = localContent;
+    }
+    if (checkUndisplayed) {
+      UndisplayedNode* undisplayed =
+        frameConstructor->GetAllUndisplayedContentIn(undisplayedParent);
+      for (TreeMatchContext::AutoAncestorPusher
+             pushAncestor(undisplayed, aTreeMatchContext,
+                          undisplayedParent ? undisplayedParent->AsElement()
+                                            : nullptr);
+           undisplayed; undisplayed = undisplayed->mNext) {
+        NS_ASSERTION(undisplayedParent ||
+                     undisplayed->mContent ==
+                       mPresContext->Document()->GetRootElement(),
+                     "undisplayed node child of null must be root");
+        NS_ASSERTION(!undisplayed->mStyle->GetPseudo(),
+                     "Shouldn't have random pseudo style contexts in the "
+                     "undisplayed map");
+
+        // Get the parent of the undisplayed content and check if it is a XBL
+        // children element. Push the children element as an ancestor here because it does
+        // not have a frame and would not otherwise be pushed as an ancestor.
+        nsIContent* parent = undisplayed->mContent->GetParent();
+        bool pushInsertionPoint = parent && parent->IsActiveChildrenElement();
+        TreeMatchContext::AutoAncestorPusher
+          insertionPointPusher(pushInsertionPoint,
+                               aTreeMatchContext,
+                               parent && parent->IsElement() ? parent->AsElement() : nullptr);
+
+        nsRestyleHint thisChildHint = childRestyleHint;
+        RestyleTracker::RestyleData undisplayedRestyleData;
+        if (aRestyleTracker.GetRestyleData(undisplayed->mContent->AsElement(),
+                                           &undisplayedRestyleData)) {
+          thisChildHint =
+            nsRestyleHint(thisChildHint | undisplayedRestyleData.mRestyleHint);
+        }
+        nsRefPtr<nsStyleContext> undisplayedContext;
+        if (thisChildHint) {
+          undisplayedContext =
+            styleSet->ResolveStyleFor(undisplayed->mContent->AsElement(),
+                                      newContext,
+                                      aTreeMatchContext);
+        } else {
+          undisplayedContext =
+            styleSet->ReparentStyleContext(undisplayed->mStyle, newContext,
+                                           undisplayed->mContent->AsElement());
+        }
+        if (undisplayedContext) {
+          const nsStyleDisplay* display = undisplayedContext->StyleDisplay();
+          if (display->mDisplay != NS_STYLE_DISPLAY_NONE) {
+            NS_ASSERTION(undisplayed->mContent,
+                         "Must have undisplayed content");
+            aChangeList->AppendChange(nullptr, undisplayed->mContent,
+                                      NS_STYLE_HINT_FRAMECHANGE);
+            // The node should be removed from the undisplayed map when
+            // we reframe it.
+          } else {
+            // update the undisplayed node with the new context
+            undisplayed->mStyle = undisplayedContext;
+          }
+        }
+      }
+    }
+
+    // Check whether we might need to create a new ::before frame.
+    // There's no need to do this if we're planning to reframe already
+    // or if we're not forcing restyles on kids.
+    if (!(aMinChange & nsChangeHint_ReconstructFrame) &&
+        childRestyleHint) {
+      // Make sure not to do this for pseudo-frames or frames that
+      // can't have generated content.
+      if (!pseudoTag &&
+          ((aFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
+           // Our content insertion frame might have gotten flagged
+           (aFrame->GetContentInsertionFrame()->GetStateBits() &
+            NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
+        // Check for a new :before pseudo and an existing :before
+        // frame, but only if the frame is the first continuation.
+        nsIFrame* prevContinuation = aFrame->GetPrevContinuation();
+        if (!prevContinuation) {
+          // Checking for a :before frame is cheaper than getting the
+          // :before style context.
+          if (!nsLayoutUtils::GetBeforeFrame(aFrame) &&
+              nsLayoutUtils::HasPseudoStyle(localContent, newContext,
+                                            nsCSSPseudoElements::ePseudo_before,
+                                            aPresContext)) {
+            // Have to create the new :before frame
+            NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
+            aChangeList->AppendChange(aFrame, content,
+                                      nsChangeHint_ReconstructFrame);
+          }
+        }
+      }
+    }
+
+    // Check whether we might need to create a new ::after frame.
+    // There's no need to do this if we're planning to reframe already
+    // or if we're not forcing restyles on kids.
+    if (!(aMinChange & nsChangeHint_ReconstructFrame) &&
+        childRestyleHint) {
+      // Make sure not to do this for pseudo-frames or frames that
+      // can't have generated content.
+      if (!pseudoTag &&
+          ((aFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
+           // Our content insertion frame might have gotten flagged
+           (aFrame->GetContentInsertionFrame()->GetStateBits() &
+            NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
+        // Check for new :after content, but only if the frame is the
+        // last continuation.
+        nsIFrame* nextContinuation = aFrame->GetNextContinuation();
+
+        if (!nextContinuation) {
+          // Getting the :after frame is more expensive than getting the pseudo
+          // context, so get the pseudo context first.
+          if (nsLayoutUtils::HasPseudoStyle(localContent, newContext,
+                                            nsCSSPseudoElements::ePseudo_after,
+                                            aPresContext) &&
+              !nsLayoutUtils::GetAfterFrame(aFrame)) {
+            // have to create the new :after frame
+            NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
+            aChangeList->AppendChange(aFrame, content,
+                                      nsChangeHint_ReconstructFrame);
+          }
+        }
+      }
+    }
+
+    // There is no need to waste time crawling into a frame's children
+    // on a frame change.  The act of reconstructing frames will force
+    // new style contexts to be resolved on all of this frame's
+    // descendants anyway, so we want to avoid wasting time processing
+    // style contexts that we're just going to throw away anyway. - dwh
+    if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
+
+      DesiredA11yNotifications kidsDesiredA11yNotification =
+        aDesiredA11yNotifications;
+#ifdef ACCESSIBILITY
+      A11yNotificationType ourA11yNotification = eDontNotify;
+      // Notify a11y for primary frame only if it's a root frame of visibility
+      // changes or its parent frame was hidden while it stays visible and
+      // it is not inside a {ib} split or is the first frame of {ib} split.
+      if (nsIPresShell::IsAccessibilityActive() &&
+          !aFrame->GetPrevContinuation() &&
+          !nsLayoutUtils::FrameIsNonFirstInIBSplit(aFrame)) {
+        if (aDesiredA11yNotifications == eSendAllNotifications) {
+          bool isFrameVisible = newContext->StyleVisibility()->IsVisible();
+          if (isFrameVisible != wasFrameVisible) {
+            if (isFrameVisible) {
+              // Notify a11y the element (perhaps with its children) was shown.
+              // We don't fall into this case if this element gets or stays shown
+              // while its parent becomes hidden.
+              kidsDesiredA11yNotification = eSkipNotifications;
+              ourA11yNotification = eNotifyShown;
+            } else {
+              // The element is being hidden; its children may stay visible, or
+              // become visible after being hidden previously. If we'll find
+              // visible children then we should notify a11y about that as if
+              // they were inserted into tree. Notify a11y this element was
+              // hidden.
+              kidsDesiredA11yNotification = eNotifyIfShown;
+              ourA11yNotification = eNotifyHidden;
+            }
+          }
+        } else if (aDesiredA11yNotifications == eNotifyIfShown &&
+                   newContext->StyleVisibility()->IsVisible()) {
+          // Notify a11y that element stayed visible while its parent was
+          // hidden.
+          aVisibleKidsOfHiddenElement.AppendElement(aFrame->GetContent());
+          kidsDesiredA11yNotification = eSkipNotifications;
+        }
+      }
+#endif
+
+      // now do children
+      nsIFrame::ChildListIterator lists(aFrame);
+      for (TreeMatchContext::AutoAncestorPusher
+             pushAncestor(!lists.IsDone(),
+                          aTreeMatchContext,
+                          content && content->IsElement() ? content->AsElement()
+                                                          : nullptr);
+           !lists.IsDone(); lists.Next()) {
+        nsFrameList::Enumerator childFrames(lists.CurrentList());
+        for (; !childFrames.AtEnd(); childFrames.Next()) {
+          nsIFrame* child = childFrames.get();
+          if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
+            // Get the parent of the child frame's content and check if it is a XBL
+            // children element. Push the children element as an ancestor here because it does
+            // not have a frame and would not otherwise be pushed as an ancestor.
+
+            // Check if the frame has a content because |child| may be a nsPageFrame that does
+            // not have a content.
+            nsIContent* parent = child->GetContent() ? child->GetContent()->GetParent() : nullptr;
+            bool pushInsertionPoint = parent && parent->IsActiveChildrenElement();
+            TreeMatchContext::AutoAncestorPusher
+              insertionPointPusher(pushInsertionPoint, aTreeMatchContext,
+                                   parent && parent->IsElement() ? parent->AsElement() : nullptr);
+
+            // only do frames that are in flow
+            if (nsGkAtoms::placeholderFrame == child->GetType()) { // placeholder
+              // get out of flow frame and recur there
+              nsIFrame* outOfFlowFrame =
+                nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
+              NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
+              NS_ASSERTION(outOfFlowFrame != resolvedChild,
+                           "out-of-flow frame not a true descendant");
+
+              // Note that the out-of-flow may not be a geometric descendant of
+              // the frame where we started the reresolve.  Therefore, even if
+              // aMinChange already includes nsChangeHint_AllReflowHints we don't
+              // want to pass that on to the out-of-flow reresolve, since that
+              // can lead to the out-of-flow not getting reflowed when it should
+              // be (eg a reresolve starting at <body> that involves reflowing
+              // the <body> would miss reflowing fixed-pos nodes that also need
+              // reflow).  In the cases when the out-of-flow _is_ a geometric
+              // descendant of a frame we already have a reflow hint for,
+              // reflow coalescing should keep us from doing the work twice.
+
+              // |nsFrame::GetParentStyleContextFrame| checks being out
+              // of flow so that this works correctly.
+              do {
+                ReResolveStyleContext(aPresContext, outOfFlowFrame,
+                                      content, aChangeList,
+                                      NS_SubtractHint(aMinChange,
+                                                      nsChangeHint_AllReflowHints),
+                                      nonInheritedHints,
+                                      childRestyleHint,
+                                      aRestyleTracker,
+                                      kidsDesiredA11yNotification,
+                                      aVisibleKidsOfHiddenElement,
+                                      aTreeMatchContext);
+              } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
+
+              // reresolve placeholder's context under the same parent
+              // as the out-of-flow frame
+              ReResolveStyleContext(aPresContext, child, content,
+                                    aChangeList, aMinChange,
+                                    nonInheritedHints,
+                                    childRestyleHint,
+                                    aRestyleTracker,
+                                    kidsDesiredA11yNotification,
+                                    aVisibleKidsOfHiddenElement,
+                                    aTreeMatchContext);
+            }
+            else {  // regular child frame
+              if (child != resolvedChild) {
+                ReResolveStyleContext(aPresContext, child, content,
+                                      aChangeList, aMinChange,
+                                      nonInheritedHints,
+                                      childRestyleHint,
+                                      aRestyleTracker,
+                                      kidsDesiredA11yNotification,
+                                      aVisibleKidsOfHiddenElement,
+                                      aTreeMatchContext);
+              }
+            }
+          }
+        }
+      }
+      // XXX need to do overflow frames???
+
+#ifdef ACCESSIBILITY
+      // Send notifications about visibility changes.
+      if (ourA11yNotification == eNotifyShown) {
+        nsAccessibilityService* accService = nsIPresShell::AccService();
+        if (accService) {
+          nsIPresShell* presShell = aFrame->PresContext()->GetPresShell();
+          nsIContent* content = aFrame->GetContent();
+
+          accService->ContentRangeInserted(presShell, content->GetParent(),
+                                           content,
+                                           content->GetNextSibling());
+        }
+      } else if (ourA11yNotification == eNotifyHidden) {
+        nsAccessibilityService* accService = nsIPresShell::AccService();
+        if (accService) {
+          nsIPresShell* presShell = aFrame->PresContext()->GetPresShell();
+          nsIContent* content = aFrame->GetContent();
+          accService->ContentRemoved(presShell, content->GetParent(), content);
+
+          // Process children staying shown.
+          uint32_t visibleContentCount = aVisibleKidsOfHiddenElement.Length();
+          for (uint32_t idx = 0; idx < visibleContentCount; idx++) {
+            nsIContent* content = aVisibleKidsOfHiddenElement[idx];
+            accService->ContentRangeInserted(presShell, content->GetParent(),
+                                             content, content->GetNextSibling());
+          }
+          aVisibleKidsOfHiddenElement.Clear();
+        }
+      }
+#endif
+    }
+  }
+
+  return aMinChange;
+}
+
+void
+RestyleManager::ComputeStyleChangeFor(nsIFrame          *aFrame,
+                                      nsStyleChangeList *aChangeList,
+                                      nsChangeHint       aMinChange,
+                                      RestyleTracker&    aRestyleTracker,
+                                      bool               aRestyleDescendants)
+{
+  PROFILER_LABEL("CSS", "ComputeStyleChangeFor");
+
+  nsIContent *content = aFrame->GetContent();
+  if (aMinChange) {
+    aChangeList->AppendChange(aFrame, content, aMinChange);
+  }
+
+  nsIFrame* frame = aFrame;
+  nsIFrame* frame2 = aFrame;
+
+  NS_ASSERTION(!frame->GetPrevContinuation(), "must start with the first in flow");
+
+  // We want to start with this frame and walk all its next-in-flows,
+  // as well as all its special siblings and their next-in-flows,
+  // reresolving style on all the frames we encounter in this walk.
+
+  FramePropertyTable *propTable = mPresContext->PropertyTable();
+
+  TreeMatchContext treeMatchContext(true,
+                                    nsRuleWalker::eRelevantLinkUnvisited,
+                                    mPresContext->Document());
+  nsIContent *parent = content ? content->GetParent() : nullptr;
+  Element *parentElement =
+    parent && parent->IsElement() ? parent->AsElement() : nullptr;
+  treeMatchContext.InitAncestors(parentElement);
+  nsTArray<nsIContent*> visibleKidsOfHiddenElement;
+  do {
+    // Outer loop over special siblings
+    do {
+      // Inner loop over next-in-flows of the current frame
+      nsChangeHint frameChange =
+        ReResolveStyleContext(mPresContext, frame, nullptr,
+                              aChangeList, aMinChange, nsChangeHint(0),
+                              aRestyleDescendants ?
+                                eRestyle_Subtree : eRestyle_Self,
+                              aRestyleTracker,
+                              eSendAllNotifications,
+                              visibleKidsOfHiddenElement,
+                              treeMatchContext);
+
+      if (frameChange & nsChangeHint_ReconstructFrame) {
+        // If it's going to cause a framechange, then don't bother
+        // with the continuations or special siblings since they'll be
+        // clobbered by the frame reconstruct anyway.
+        NS_ASSERTION(!frame->GetPrevContinuation(),
+                     "continuing frame had more severe impact than first-in-flow");
+        return;
+      }
+
+      frame = frame->GetNextContinuation();
+    } while (frame);
+
+    // Might we have special siblings?
+    if (!(frame2->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
+      // nothing more to do here
+      return;
+    }
+
+    frame2 = static_cast<nsIFrame*>
+      (propTable->Get(frame2, nsIFrame::IBSplitSpecialSibling()));
+    frame = frame2;
+  } while (frame2);
+}
+
 } // namespace mozilla
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -13,16 +13,17 @@
 
 #include "nsISupportsImpl.h"
 #include "nsChangeHint.h"
 #include "RestyleTracker.h"
 #include "nsPresContext.h"
 
 class nsRefreshDriver;
 class nsIFrame;
+struct TreeMatchContext;
 
 namespace mozilla {
 
 namespace dom {
   class Element;
 } // namespace dom
 
 class RestyleManager {
@@ -64,16 +65,45 @@ public:
   // Get an integer that increments every time there is a style change
   // as a result of a change to the :hover content state.
   uint32_t GetHoverGeneration() const { return mHoverGeneration; }
 
   // Get a counter that increments on every style change, that we use to
   // track whether off-main-thread animations are up-to-date.
   uint64_t GetAnimationGeneration() const { return mAnimationGeneration; }
 
+  /*
+   * Reparent the style contexts of this frame subtree.  The parent frame of
+   * aFrame must be changed to the new parent before this function is called;
+   * the new parent style context will be automatically computed based on the
+   * new position in the frame tree.
+   *
+   * @param aFrame the root of the subtree to reparent.  Must not be null.
+   */
+  NS_HIDDEN_(nsresult) ReparentStyleContext(nsIFrame* aFrame);
+
+  /*
+   * Re-resolve the style contexts for a frame tree, building
+   * aChangeList based on the resulting style changes, plus aMinChange
+   * applied to aFrame.
+   */
+  NS_HIDDEN_(void)
+    ComputeStyleChangeFor(nsIFrame* aFrame,
+                          nsStyleChangeList* aChangeList,
+                          nsChangeHint aMinChange,
+                          RestyleTracker& aRestyleTracker,
+                          bool aRestyleDescendants);
+
+#ifdef DEBUG
+  /**
+   * DEBUG ONLY method to verify integrity of style tree versus frame tree
+   */
+  NS_HIDDEN_(void) DebugVerifyStyleTree(nsIFrame* aFrame);
+#endif
+
   // Note: It's the caller's responsibility to make sure to wrap a
   // ProcessRestyledFrames call in a view update batch and a script blocker.
   // This function does not call ProcessAttachedQueue() on the binding manager.
   // If the caller wants that to happen synchronously, it needs to handle that
   // itself.
   nsresult ProcessRestyledFrames(nsStyleChangeList& aRestyleArray);
 
   // Process any pending restyles. This should be called after
@@ -120,16 +150,46 @@ public:
   }
 
   void FlushOverflowChangedTracker() 
   {
     mOverflowChangedTracker.Flush();
   }
 
 private:
+  enum DesiredA11yNotifications {
+    eSkipNotifications,
+    eSendAllNotifications,
+    eNotifyIfShown
+  };
+
+  enum A11yNotificationType {
+    eDontNotify,
+    eNotifyShown,
+    eNotifyHidden
+  };
+
+  // Use eRestyle_Self for the aRestyleHint argument to mean
+  // "reresolve our style context but not kids", use eRestyle_Subtree
+  // to mean "reresolve our style context and kids", and use
+  // nsRestyleHint(0) to mean recompute a new style context for our
+  // current parent and existing rulenode, and the same for kids.
+  NS_HIDDEN_(nsChangeHint)
+    ReResolveStyleContext(nsPresContext    *aPresContext,
+                          nsIFrame          *aFrame,
+                          nsIContent        *aParentContent,
+                          nsStyleChangeList *aChangeList, 
+                          nsChangeHint       aMinChange,
+                          nsChangeHint       aParentFrameHintsNotHandledForDescendants,
+                          nsRestyleHint      aRestyleHint,
+                          RestyleTracker&    aRestyleTracker,
+                          DesiredA11yNotifications aDesiredA11yNotifications,
+                          nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
+                          TreeMatchContext &aTreeMatchContext);
+
   /**
    * Notify the frame constructor that an element needs to have its
    * style recomputed.
    * @param aElement: The element to be restyled.
    * @param aRestyleHint: Which nodes need to have selector matching run
    *                      on them.
    * @param aMinChangeHint: A minimum change hint for aContent and its
    *                        descendants.
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -422,31 +422,32 @@ AnyKidsNeedBlockParent(nsIFrame *aFrameL
       return k->GetContent();
     }
   }
   return nullptr;
 }
 
 // Reparent a frame into a wrapper frame that is a child of its old parent.
 static void
-ReparentFrame(nsFrameManager* aFrameManager,
+ReparentFrame(RestyleManager* aRestyleManager,
               nsIFrame* aNewParentFrame,
               nsIFrame* aFrame)
 {
   aFrame->SetParent(aNewParentFrame);
-  aFrameManager->ReparentStyleContext(aFrame);
+  aRestyleManager->ReparentStyleContext(aFrame);
 }
 
 static void
-ReparentFrames(nsFrameManager* aFrameManager,
+ReparentFrames(nsCSSFrameConstructor* aFrameConstructor,
                nsIFrame* aNewParentFrame,
                const nsFrameList& aFrameList)
 {
+  RestyleManager *restyleManager = aFrameConstructor->RestyleManager();
   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
-    ReparentFrame(aFrameManager, aNewParentFrame, e.get());
+    ReparentFrame(restyleManager, aNewParentFrame, e.get());
   }
 }
 
 //----------------------------------------------------------------------
 //
 // When inline frames get weird and have block frames in them, we
 // annotate them to help us respond to incremental content changes
 // more easily.
diff --git a/layout/base/nsFrameManager.cpp b/layout/base/nsFrameManager.cpp
--- a/layout/base/nsFrameManager.cpp
+++ b/layout/base/nsFrameManager.cpp
@@ -24,20 +24,17 @@
 #include "nsCSSFrameConstructor.h"
 #include "nsStyleContext.h"
 #include "nsStyleChangeList.h"
 #include "nsIServiceManager.h"
 #include "nsCOMPtr.h"
 #include "prthread.h"
 #include "plhash.h"
 #include "nsPlaceholderFrame.h"
-#include "nsContainerFrame.h"
-#include "nsBlockFrame.h"
 #include "nsGkAtoms.h"
-#include "nsCSSAnonBoxes.h"
 #include "nsCSSPseudoElements.h"
 #ifdef DEBUG
 #include "nsIStyleRule.h"
 #endif
 #include "nsILayoutHistoryState.h"
 #include "nsPresState.h"
 #include "nsIContent.h"
 #include "nsINameSpaceManager.h"
@@ -52,47 +49,28 @@
 #include "nsIForm.h"
 #include "nsContentUtils.h"
 #include "nsReadableUtils.h"
 #include "nsUnicharUtils.h"
 #include "nsError.h"
 #include "nsLayoutUtils.h"
 #include "nsAutoPtr.h"
 #include "imgIRequest.h"
-#include "nsTransitionManager.h"
-#include "RestyleTracker.h"
 #include "nsAbsoluteContainingBlock.h"
 #include "ChildIterator.h"
 
 #include "nsFrameManager.h"
-#include "nsRuleProcessorData.h"
 #include "GeckoProfiler.h"
 
-#ifdef ACCESSIBILITY
-#include "nsAccessibilityService.h"
-#endif
-
   #ifdef DEBUG
-    //#define NOISY_DEBUG
     //#define DEBUG_UNDISPLAYED_MAP
   #else
-    #undef NOISY_DEBUG
     #undef DEBUG_UNDISPLAYED_MAP
   #endif
 
-  #ifdef NOISY_DEBUG
-    #define NOISY_TRACE(_msg) \
-      printf("%s",_msg);
-    #define NOISY_TRACE_FRAME(_msg,_frame) \
-      printf("%s ",_msg); nsFrame::ListTag(stdout,_frame); printf("\n");
-  #else
-    #define NOISY_TRACE(_msg);
-    #define NOISY_TRACE_FRAME(_msg,_frame);
-  #endif
-
 using namespace mozilla;
 using namespace mozilla::dom;
 
 //----------------------------------------------------------------------
 
 struct PlaceholderMapEntry : public PLDHashEntryHdr {
   // key (the out of flow frame) can be obtained through placeholder frame
   nsPlaceholderFrame *placeholderFrame;
@@ -472,1244 +450,16 @@ void
 nsFrameManager::NotifyDestroyingFrame(nsIFrame* aFrame)
 {
   nsIContent* content = aFrame->GetContent();
   if (content && content->GetPrimaryFrame() == aFrame) {
     ClearAllUndisplayedContentIn(content);
   }
 }
 
-#ifdef DEBUG
-static void
-DumpContext(nsIFrame* aFrame, nsStyleContext* aContext)
-{
-  if (aFrame) {
-    fputs("frame: ", stdout);
-    nsAutoString  name;
-    aFrame->GetFrameName(name);
-    fputs(NS_LossyConvertUTF16toASCII(name).get(), stdout);
-    fprintf(stdout, " (%p)", static_cast<void*>(aFrame));
-  }
-  if (aContext) {
-    fprintf(stdout, " style: %p ", static_cast<void*>(aContext));
-
-    nsIAtom* pseudoTag = aContext->GetPseudo();
-    if (pseudoTag) {
-      nsAutoString  buffer;
-      pseudoTag->ToString(buffer);
-      fputs(NS_LossyConvertUTF16toASCII(buffer).get(), stdout);
-      fputs(" ", stdout);
-    }
-    fputs("{}\n", stdout);
-  }
-}
-
-static void
-VerifySameTree(nsStyleContext* aContext1, nsStyleContext* aContext2)
-{
-  nsStyleContext* top1 = aContext1;
-  nsStyleContext* top2 = aContext2;
-  nsStyleContext* parent;
-  for (;;) {
-    parent = top1->GetParent();
-    if (!parent)
-      break;
-    top1 = parent;
-  }
-  for (;;) {
-    parent = top2->GetParent();
-    if (!parent)
-      break;
-    top2 = parent;
-  }
-  NS_ASSERTION(top1 == top2,
-               "Style contexts are not in the same style context tree");
-}
-
-static void
-VerifyContextParent(nsPresContext* aPresContext, nsIFrame* aFrame, 
-                    nsStyleContext* aContext, nsStyleContext* aParentContext)
-{
-  // get the contexts not provided
-  if (!aContext) {
-    aContext = aFrame->StyleContext();
-  }
-
-  if (!aParentContext) {
-    // Get the correct parent context from the frame
-    //  - if the frame is a placeholder, we get the out of flow frame's context 
-    //    as the parent context instead of asking the frame
-
-    // get the parent context from the frame (indirectly)
-    nsIFrame* providerFrame = aFrame->GetParentStyleContextFrame();
-    if (providerFrame)
-      aParentContext = providerFrame->StyleContext();
-    // aParentContext could still be null
-  }
-
-  NS_ASSERTION(aContext, "Failure to get required contexts");
-  nsStyleContext* actualParentContext = aContext->GetParent();
-
-  if (aParentContext) {
-    if (aParentContext != actualParentContext) {
-      DumpContext(aFrame, aContext);
-      if (aContext == aParentContext) {
-        NS_ERROR("Using parent's style context");
-      }
-      else {
-        NS_ERROR("Wrong parent style context");
-        fputs("Wrong parent style context: ", stdout);
-        DumpContext(nullptr, actualParentContext);
-        fputs("should be using: ", stdout);
-        DumpContext(nullptr, aParentContext);
-        VerifySameTree(actualParentContext, aParentContext);
-        fputs("\n", stdout);
-      }
-    }
-
-  }
-  else {
-    if (actualParentContext) {
-      NS_ERROR("Have parent context and shouldn't");
-      DumpContext(aFrame, aContext);
-      fputs("Has parent context: ", stdout);
-      DumpContext(nullptr, actualParentContext);
-      fputs("Should be null\n\n", stdout);
-    }
-  }
-
-  nsStyleContext* childStyleIfVisited = aContext->GetStyleIfVisited();
-  // Either childStyleIfVisited has aContext->GetParent()->GetStyleIfVisited()
-  // as the parent or it has a different rulenode from aContext _and_ has
-  // aContext->GetParent() as the parent.
-  if (childStyleIfVisited &&
-      !((childStyleIfVisited->RuleNode() != aContext->RuleNode() &&
-         childStyleIfVisited->GetParent() == aContext->GetParent()) ||
-        childStyleIfVisited->GetParent() ==
-          aContext->GetParent()->GetStyleIfVisited())) {
-    NS_ERROR("Visited style has wrong parent");
-    DumpContext(aFrame, aContext);
-    fputs("\n", stdout);
-  }
-}
-
-static void
-VerifyStyleTree(nsPresContext* aPresContext, nsIFrame* aFrame,
-                nsStyleContext* aParentContext)
-{
-  nsStyleContext*  context = aFrame->StyleContext();
-  VerifyContextParent(aPresContext, aFrame, context, nullptr);
-
-  nsIFrame::ChildListIterator lists(aFrame);
-  for (; !lists.IsDone(); lists.Next()) {
-    nsFrameList::Enumerator childFrames(lists.CurrentList());
-    for (; !childFrames.AtEnd(); childFrames.Next()) {
-      nsIFrame* child = childFrames.get();
-      if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
-        // only do frames that are in flow
-        if (nsGkAtoms::placeholderFrame == child->GetType()) { 
-          // placeholder: first recurse and verify the out of flow frame,
-          // then verify the placeholder's context
-          nsIFrame* outOfFlowFrame =
-            nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
-
-          // recurse to out of flow frame, letting the parent context get resolved
-          do {
-            VerifyStyleTree(aPresContext, outOfFlowFrame, nullptr);
-          } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
-
-          // verify placeholder using the parent frame's context as
-          // parent context
-          VerifyContextParent(aPresContext, child, nullptr, nullptr);
-        }
-        else { // regular frame
-          VerifyStyleTree(aPresContext, child, nullptr);
-        }
-      }
-    }
-  }
-  
-  // do additional contexts 
-  int32_t contextIndex = -1;
-  while (1) {
-    nsStyleContext* extraContext = aFrame->GetAdditionalStyleContext(++contextIndex);
-    if (extraContext) {
-      VerifyContextParent(aPresContext, aFrame, extraContext, context);
-    }
-    else {
-      break;
-    }
-  }
-}
-
-void
-nsFrameManager::DebugVerifyStyleTree(nsIFrame* aFrame)
-{
-  if (aFrame) {
-    nsStyleContext* context = aFrame->StyleContext();
-    nsStyleContext* parentContext = context->GetParent();
-    VerifyStyleTree(GetPresContext(), aFrame, parentContext);
-  }
-}
-
-#endif // DEBUG
-
-// aContent must be the content for the frame in question, which may be
-// :before/:after content
-static void
-TryStartingTransition(nsPresContext *aPresContext, nsIContent *aContent,
-                      nsStyleContext *aOldStyleContext,
-                      nsRefPtr<nsStyleContext> *aNewStyleContext /* inout */)
-{
-  if (!aContent || !aContent->IsElement()) {
-    return;
-  }
-
-  // Notify the transition manager, and if it starts a transition,
-  // it will give us back a transition-covering style rule which
-  // we'll use to get *another* style context.  We want to ignore
-  // any already-running transitions, but cover up any that we're
-  // currently starting with their start value so we don't start
-  // them again for descendants that inherit that value.
-  nsCOMPtr<nsIStyleRule> coverRule = 
-    aPresContext->TransitionManager()->StyleContextChanged(
-      aContent->AsElement(), aOldStyleContext, *aNewStyleContext);
-  if (coverRule) {
-    nsCOMArray<nsIStyleRule> rules;
-    rules.AppendObject(coverRule);
-    *aNewStyleContext = aPresContext->StyleSet()->
-                          ResolveStyleByAddingRules(*aNewStyleContext, rules);
-  }
-}
-
-static inline Element*
-ElementForStyleContext(nsIContent* aParentContent,
-                       nsIFrame* aFrame,
-                       nsCSSPseudoElements::Type aPseudoType)
-{
-  // We don't expect XUL tree stuff here.
-  NS_PRECONDITION(aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ||
-                  aPseudoType == nsCSSPseudoElements::ePseudo_AnonBox ||
-                  aPseudoType < nsCSSPseudoElements::ePseudo_PseudoElementCount,
-                  "Unexpected pseudo");
-  // XXX see the comments about the various element confusion in
-  // ReResolveStyleContext.
-  if (aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
-    return aFrame->GetContent()->AsElement();
-  }
-
-  if (aPseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
-    return nullptr;
-  }
-
-  if (aPseudoType == nsCSSPseudoElements::ePseudo_firstLetter) {
-    NS_ASSERTION(aFrame->GetType() == nsGkAtoms::letterFrame,
-                 "firstLetter pseudoTag without a nsFirstLetterFrame");
-    nsBlockFrame* block = nsBlockFrame::GetNearestAncestorBlock(aFrame);
-    return block->GetContent()->AsElement();
-  }
-
-  nsIContent* content = aParentContent ? aParentContent : aFrame->GetContent();
-  return content->AsElement();
-}
-
-static nsIFrame*
-GetPrevContinuationWithPossiblySameStyle(nsIFrame* aFrame)
-{
-  // Account for {ib} splits when looking for "prevContinuation".  In
-  // particular, for the first-continuation of a part of an {ib} split we
-  // want to use the special prevsibling of the special prevsibling of
-  // aFrame, which should have the same style context as aFrame itself.
-  // In particular, if aFrame is the first continuation of an inline part
-  // of an {ib} split then its special prevsibling is a block, and the
-  // special prevsibling of _that_ is an inline, just like aFrame.
-  // Similarly, if aFrame is the first continuation of a block part of an
-  // {ib} split (an {ib} wrapper block), then its special prevsibling is
-  // an inline and the special prevsibling of that is either another {ib}
-  // wrapper block block or null.
-  nsIFrame *prevContinuation = aFrame->GetPrevContinuation();
-  if (!prevContinuation && (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
-    // We're the first continuation, so we can just get the frame
-    // property directly
-    prevContinuation = static_cast<nsIFrame*>(
-      aFrame->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
-    if (prevContinuation) {
-      prevContinuation = static_cast<nsIFrame*>(
-        prevContinuation->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
-    }
-  }
-  return prevContinuation;
-}
-
-nsresult
-nsFrameManager::ReparentStyleContext(nsIFrame* aFrame)
-{
-  if (nsGkAtoms::placeholderFrame == aFrame->GetType()) {
-    // Also reparent the out-of-flow and all its continuations.
-    nsIFrame* outOfFlow =
-      nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
-    NS_ASSERTION(outOfFlow, "no out-of-flow frame");
-    do {
-      ReparentStyleContext(outOfFlow);
-    } while ((outOfFlow = outOfFlow->GetNextContinuation()));
-  }
-
-  // DO NOT verify the style tree before reparenting.  The frame
-  // tree has already been changed, so this check would just fail.
-  nsStyleContext* oldContext = aFrame->StyleContext();
-  // XXXbz can oldContext really ever be null?
-  if (oldContext) {
-    nsRefPtr<nsStyleContext> newContext;
-    nsIFrame* providerFrame = aFrame->GetParentStyleContextFrame();
-    bool isChild = providerFrame && providerFrame->GetParent() == aFrame;
-    nsStyleContext* newParentContext = nullptr;
-    nsIFrame* providerChild = nullptr;
-    if (isChild) {
-      ReparentStyleContext(providerFrame);
-      newParentContext = providerFrame->StyleContext();
-      providerChild = providerFrame;
-    } else if (providerFrame) {
-      newParentContext = providerFrame->StyleContext();
-    } else {
-      NS_NOTREACHED("Reparenting something that has no usable parent? "
-                    "Shouldn't happen!");
-    }
-    // XXX need to do something here to produce the correct style context for
-    // an IB split whose first inline part is inside a first-line frame.
-    // Currently the first IB anonymous block's style context takes the first
-    // part's style context as parent, which is wrong since first-line style
-    // should not apply to the anonymous block.
-
-#ifdef DEBUG
-    {
-      // Check that our assumption that continuations of the same
-      // pseudo-type and with the same style context parent have the
-      // same style context is valid before the reresolution.  (We need
-      // to check the pseudo-type and style context parent because of
-      // :first-letter and :first-line, where we create styled and
-      // unstyled letter/line frames distinguished by pseudo-type, and
-      // then need to distinguish their descendants based on having
-      // different parents.)
-      nsIFrame *nextContinuation = aFrame->GetNextContinuation();
-      if (nextContinuation) {
-        nsStyleContext *nextContinuationContext =
-          nextContinuation->StyleContext();
-        NS_ASSERTION(oldContext == nextContinuationContext ||
-                     oldContext->GetPseudo() !=
-                       nextContinuationContext->GetPseudo() ||
-                     oldContext->GetParent() !=
-                       nextContinuationContext->GetParent(),
-                     "continuations should have the same style context");
-      }
-    }
-#endif
-
-    nsIFrame *prevContinuation =
-      GetPrevContinuationWithPossiblySameStyle(aFrame);
-    nsStyleContext *prevContinuationContext;
-    bool copyFromContinuation =
-      prevContinuation &&
-      (prevContinuationContext = prevContinuation->StyleContext())
-        ->GetPseudo() == oldContext->GetPseudo() &&
-       prevContinuationContext->GetParent() == newParentContext;
-    if (copyFromContinuation) {
-      // Just use the style context from the frame's previous
-      // continuation (see assertion about aFrame->GetNextContinuation()
-      // above, which we would have previously hit for aFrame's previous
-      // continuation).
-      newContext = prevContinuationContext;
-    } else {
-      nsIFrame* parentFrame = aFrame->GetParent();
-      Element* element =
-        ElementForStyleContext(parentFrame ? parentFrame->GetContent() : nullptr,
-                               aFrame,
-                               oldContext->GetPseudoType());
-      newContext = mStyleSet->ReparentStyleContext(oldContext,
-                                                   newParentContext,
-                                                   element);
-    }
-
-    if (newContext) {
-      if (newContext != oldContext) {
-        // We probably don't want to initiate transitions from
-        // ReparentStyleContext, since we call it during frame
-        // construction rather than in response to dynamic changes.
-        // Also see the comment at the start of
-        // nsTransitionManager::ConsiderStartingTransition.
-#if 0
-        if (!copyFromContinuation) {
-          TryStartingTransition(GetPresContext(), aFrame->GetContent(),
-                                oldContext, &newContext);
-        }
-#endif
-
-        // Make sure to call CalcStyleDifference so that the new context ends
-        // up resolving all the structs the old context resolved.
-        DebugOnly<nsChangeHint> styleChange =
-          oldContext->CalcStyleDifference(newContext, nsChangeHint(0));
-        // The style change is always 0 because we have the same rulenode and
-        // CalcStyleDifference optimizes us away.  That's OK, though:
-        // reparenting should never trigger a frame reconstruct, and whenever
-        // it's happening we already plan to reflow and repaint the frames.
-        NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
-                     "Our frame tree is likely to be bogus!");
-        
-        aFrame->SetStyleContext(newContext);
-
-        nsIFrame::ChildListIterator lists(aFrame);
-        for (; !lists.IsDone(); lists.Next()) {
-          nsFrameList::Enumerator childFrames(lists.CurrentList());
-          for (; !childFrames.AtEnd(); childFrames.Next()) {
-            nsIFrame* child = childFrames.get();
-            // only do frames that are in flow
-            if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
-                child != providerChild) {
-#ifdef DEBUG
-              if (nsGkAtoms::placeholderFrame == child->GetType()) {
-                nsIFrame* outOfFlowFrame =
-                  nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
-                NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
-
-                NS_ASSERTION(outOfFlowFrame != providerChild,
-                             "Out of flow provider?");
-              }
-#endif
-              ReparentStyleContext(child);
-            }
-          }
-        }
-
-        // If this frame is part of an IB split, then the style context of
-        // the next part of the split might be a child of our style context.
-        // Reparent its style context just in case one of our ancestors
-        // (split or not) hasn't done so already). It's not a problem to
-        // reparent the same frame twice because the "if (newContext !=
-        // oldContext)" check will prevent us from redoing work.
-        if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
-            !aFrame->GetPrevContinuation()) {
-          nsIFrame* sib = static_cast<nsIFrame*>
-            (aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
-          if (sib) {
-            ReparentStyleContext(sib);
-          }
-        }
-
-        // do additional contexts 
-        int32_t contextIndex = -1;
-        while (1) {
-          nsStyleContext* oldExtraContext =
-            aFrame->GetAdditionalStyleContext(++contextIndex);
-          if (oldExtraContext) {
-            nsRefPtr<nsStyleContext> newExtraContext;
-            newExtraContext = mStyleSet->ReparentStyleContext(oldExtraContext,
-                                                              newContext,
-                                                              nullptr);
-            if (newExtraContext) {
-              if (newExtraContext != oldExtraContext) {
-                // Make sure to call CalcStyleDifference so that the new
-                // context ends up resolving all the structs the old context
-                // resolved.
-                styleChange =
-                  oldExtraContext->CalcStyleDifference(newExtraContext,
-                                                       nsChangeHint(0));
-                // The style change is always 0 because we have the same
-                // rulenode and CalcStyleDifference optimizes us away.  That's
-                // OK, though: reparenting should never trigger a frame
-                // reconstruct, and whenever it's happening we already plan to
-                // reflow and repaint the frames.
-                NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
-                             "Our frame tree is likely to be bogus!");
-              }
-              
-              aFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
-            }
-          }
-          else {
-            break;
-          }
-        }
-#ifdef DEBUG
-        VerifyStyleTree(GetPresContext(), aFrame, newParentContext);
-#endif
-      }
-    }
-  }
-  return NS_OK;
-}
-
-static void
-CaptureChange(nsStyleContext* aOldContext, nsStyleContext* aNewContext,
-              nsIFrame* aFrame, nsIContent* aContent,
-              nsStyleChangeList* aChangeList,
-              /*inout*/nsChangeHint &aMinChange,
-              /*in*/nsChangeHint aParentHintsNotHandledForDescendants,
-              /*out*/nsChangeHint &aHintsNotHandledForDescendants,
-              nsChangeHint aChangeToAssume)
-{
-  nsChangeHint ourChange = aOldContext->CalcStyleDifference(aNewContext,
-                             aParentHintsNotHandledForDescendants);
-  NS_ASSERTION(!(ourChange & nsChangeHint_AllReflowHints) ||
-               (ourChange & nsChangeHint_NeedReflow),
-               "Reflow hint bits set without actually asking for a reflow");
-
-  // nsChangeHint_UpdateEffects is inherited, but it can be set due to changes
-  // in inherited properties (fill and stroke).  Avoid propagating it into
-  // text nodes.
-  if ((ourChange & nsChangeHint_UpdateEffects) &&
-      aContent && !aContent->IsElement()) {
-    ourChange = NS_SubtractHint(ourChange, nsChangeHint_UpdateEffects);
-  }
-
-  NS_UpdateHint(ourChange, aChangeToAssume);
-  if (NS_UpdateHint(aMinChange, ourChange)) {
-    if (!(ourChange & nsChangeHint_ReconstructFrame) || aContent) {
-      aChangeList->AppendChange(aFrame, aContent, ourChange);
-    }
-  }
-  aHintsNotHandledForDescendants = NS_HintsNotHandledForDescendantsIn(ourChange);
-}
-
-/**
- * Recompute style for aFrame and accumulate changes into aChangeList
- * given that aMinChange is already accumulated for an ancestor.
- * aParentContent is the content node used to resolve the parent style
- * context.  This means that, for pseudo-elements, it is the content
- * that should be used for selector matching (rather than the fake
- * content node attached to the frame).
- *
- * For aParentFrameHintsNotHandledForDescendants, see
- * nsStyleContext::CalcStyleDifference.
- */
-nsChangeHint
-nsFrameManager::ReResolveStyleContext(nsPresContext     *aPresContext,
-                                      nsIFrame          *aFrame,
-                                      nsIContent        *aParentContent,
-                                      nsStyleChangeList *aChangeList, 
-                                      nsChangeHint       aMinChange,
-                                      nsChangeHint       aParentFrameHintsNotHandledForDescendants,
-                                      nsRestyleHint      aRestyleHint,
-                                      RestyleTracker&    aRestyleTracker,
-                                      DesiredA11yNotifications aDesiredA11yNotifications,
-                                      nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
-                                      TreeMatchContext &aTreeMatchContext)
-{
-  // We need to generate a new change list entry for every frame whose style
-  // comparision returns one of these hints. These hints don't automatically
-  // update all their descendant frames.
-  aMinChange = NS_SubtractHint(aMinChange, NS_HintsNotHandledForDescendantsIn(aMinChange));
-
-  // It would be nice if we could make stronger assertions here; they
-  // would let us simplify the ?: expressions below setting |content|
-  // and |pseudoContent| in sensible ways as well as making what
-  // |localContent|, |content|, and |pseudoContent| mean make more
-  // sense.  However, we can't, because of frame trees like the one in
-  // https://bugzilla.mozilla.org/show_bug.cgi?id=472353#c14 .  Once we
-  // fix bug 242277 we should be able to make this make more sense.
-  NS_ASSERTION(aFrame->GetContent() || !aParentContent ||
-               !aParentContent->GetParent(),
-               "frame must have content (unless at the top of the tree)");
-  // XXXldb get new context from prev-in-flow if possible, to avoid
-  // duplication.  (Or should we just let |GetContext| handle that?)
-  // Getting the hint would be nice too, but that's harder.
-
-  // XXXbryner we may be able to avoid some of the refcounting goop here.
-  // We do need a reference to oldContext for the lifetime of this function, and it's possible
-  // that the frame has the last reference to it, so AddRef it here.
-
-  nsChangeHint assumeDifferenceHint = NS_STYLE_HINT_NONE;
-  // XXXbz oldContext should just be an nsRefPtr
-  nsStyleContext* oldContext = aFrame->StyleContext();
-  nsStyleSet* styleSet = aPresContext->StyleSet();
-
-  // XXXbz the nsIFrame constructor takes an nsStyleContext, so how
-  // could oldContext be null?
-  if (oldContext) {
-    oldContext->AddRef();
-
-#ifdef ACCESSIBILITY
-    bool wasFrameVisible = nsIPresShell::IsAccessibilityActive() ?
-      oldContext->StyleVisibility()->IsVisible() : false;
-#endif
-
-    nsIAtom* const pseudoTag = oldContext->GetPseudo();
-    const nsCSSPseudoElements::Type pseudoType = oldContext->GetPseudoType();
-    nsIContent* localContent = aFrame->GetContent();
-    // |content| is the node that we used for rule matching of
-    // normal elements (not pseudo-elements) and for which we generate
-    // framechange hints if we need them.
-    // XXXldb Why does it make sense to use aParentContent?  (See
-    // comment above assertion at start of function.)
-    nsIContent* content = localContent ? localContent : aParentContent;
-
-    if (content && content->IsElement()) {
-      content->OwnerDoc()->FlushPendingLinkUpdates();
-      RestyleTracker::RestyleData restyleData;
-      if (aRestyleTracker.GetRestyleData(content->AsElement(), &restyleData)) {
-        if (NS_UpdateHint(aMinChange, restyleData.mChangeHint)) {
-          aChangeList->AppendChange(aFrame, content, restyleData.mChangeHint);
-        }
-        aRestyleHint = nsRestyleHint(aRestyleHint | restyleData.mRestyleHint);
-      }
-    }
-
-    nsRestyleHint childRestyleHint = aRestyleHint;
-
-    if (childRestyleHint == eRestyle_Self) {
-      childRestyleHint = nsRestyleHint(0);
-    }
-
-    nsStyleContext* parentContext;
-    nsIFrame* resolvedChild = nullptr;
-    // Get the frame providing the parent style context.  If it is a
-    // child, then resolve the provider first.
-    nsIFrame* providerFrame = aFrame->GetParentStyleContextFrame();
-    bool isChild = providerFrame && providerFrame->GetParent() == aFrame;
-    if (!isChild) {
-      if (providerFrame)
-        parentContext = providerFrame->StyleContext();
-      else
-        parentContext = nullptr;
-    }
-    else {
-      MOZ_ASSERT(providerFrame->GetContent() == aFrame->GetContent(),
-                 "Postcondition for GetParentStyleContextFrame() violated. "
-                 "That means we need to add the current element to the "
-                 "ancestor filter.");
-
-      // resolve the provider here (before aFrame below).
-
-      // assumeDifferenceHint forces the parent's change to be also
-      // applied to this frame, no matter what
-      // nsStyleContext::CalcStyleDifference says. CalcStyleDifference
-      // can't be trusted because it assumes any changes to the parent
-      // style context provider will be automatically propagated to
-      // the frame(s) with child style contexts.
-
-      assumeDifferenceHint = ReResolveStyleContext(aPresContext, providerFrame,
-                                                   aParentContent, aChangeList,
-                                                   aMinChange,
-                                                   nsChangeHint_Hints_NotHandledForDescendants,
-                                                   aRestyleHint,
-                                                   aRestyleTracker,
-                                                   aDesiredA11yNotifications,
-                                                   aVisibleKidsOfHiddenElement,
-                                                   aTreeMatchContext);
-
-      // The provider's new context becomes the parent context of
-      // aFrame's context.
-      parentContext = providerFrame->StyleContext();
-      // Set |resolvedChild| so we don't bother resolving the
-      // provider again.
-      resolvedChild = providerFrame;
-    }
-
-    if (providerFrame != aFrame->GetParent()) {
-      // We don't actually know what the parent style context's
-      // non-inherited hints were, so assume the worst.
-      aParentFrameHintsNotHandledForDescendants =
-        nsChangeHint_Hints_NotHandledForDescendants;
-    }
-
-#ifdef DEBUG
-    {
-      // Check that our assumption that continuations of the same
-      // pseudo-type and with the same style context parent have the
-      // same style context is valid before the reresolution.  (We need
-      // to check the pseudo-type and style context parent because of
-      // :first-letter and :first-line, where we create styled and
-      // unstyled letter/line frames distinguished by pseudo-type, and
-      // then need to distinguish their descendants based on having
-      // different parents.)
-      nsIFrame *nextContinuation = aFrame->GetNextContinuation();
-      if (nextContinuation) {
-        nsStyleContext *nextContinuationContext =
-          nextContinuation->StyleContext();
-        NS_ASSERTION(oldContext == nextContinuationContext ||
-                     oldContext->GetPseudo() !=
-                       nextContinuationContext->GetPseudo() ||
-                     oldContext->GetParent() !=
-                       nextContinuationContext->GetParent(),
-                     "continuations should have the same style context");
-      }
-      // And assert the same thing for {ib} splits.  See the comments in
-      // GetPrevContinuationWithPossiblySameStyle for an explanation of
-      // why we step two forward in the special sibling chain.
-      if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
-          !aFrame->GetPrevContinuation()) {
-        nsIFrame *nextIBSibling = static_cast<nsIFrame*>(
-          aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
-        if (nextIBSibling) {
-          nextIBSibling = static_cast<nsIFrame*>(
-            nextIBSibling->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
-        }
-        if (nextIBSibling) {
-          nsStyleContext *nextIBSiblingContext =
-            nextIBSibling->StyleContext();
-          NS_ASSERTION(oldContext == nextIBSiblingContext ||
-                       oldContext->GetPseudo() !=
-                         nextIBSiblingContext->GetPseudo() ||
-                       oldContext->GetParent() !=
-                         nextIBSiblingContext->GetParent(),
-                       "continuations should have the same style context");
-        }
-      }
-    }
-#endif
-
-    // do primary context
-    nsRefPtr<nsStyleContext> newContext;
-    nsChangeHint nonInheritedHints = nsChangeHint(0);
-    nsIFrame *prevContinuation =
-      GetPrevContinuationWithPossiblySameStyle(aFrame);
-    nsStyleContext *prevContinuationContext;
-    bool copyFromContinuation =
-      prevContinuation &&
-      (prevContinuationContext = prevContinuation->StyleContext())
-        ->GetPseudo() == oldContext->GetPseudo() &&
-       prevContinuationContext->GetParent() == parentContext;
-    if (copyFromContinuation) {
-      // Just use the style context from the frame's previous
-      // continuation (see assertion about aFrame->GetNextContinuation()
-      // above, which we would have previously hit for aFrame's previous
-      // continuation).
-      newContext = prevContinuationContext;
-    }
-    else if (pseudoTag == nsCSSAnonBoxes::mozNonElement) {
-      NS_ASSERTION(localContent,
-                   "non pseudo-element frame without content node");
-      newContext = styleSet->ResolveStyleForNonElement(parentContext);
-    }
-    else if (!aRestyleHint && !prevContinuation) {
-      // Unfortunately, if prevContinuation is non-null then we may have
-      // already stolen the restyle tracker entry for this element while
-      // processing prevContinuation.  So we don't know whether aRestyleHint
-      // should really be 0 here or whether it should be eRestyle_Self.  Be
-      // pessimistic and force an actual reresolve in that situation.  The good
-      // news is that in the common case when prevContinuation is non-null we
-      // just used prevContinuationContext anyway and aren't reaching this code
-      // to start with.
-      newContext =
-        styleSet->ReparentStyleContext(oldContext, parentContext,
-                                       ElementForStyleContext(aParentContent,
-                                                              aFrame,
-                                                              pseudoType));
-    } else if (pseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
-      newContext = styleSet->ResolveAnonymousBoxStyle(pseudoTag,
-                                                      parentContext);
-    }
-    else {
-      Element* element = ElementForStyleContext(aParentContent,
-                                                aFrame,
-                                                pseudoType);
-      if (pseudoTag) {
-        if (pseudoTag == nsCSSPseudoElements::before ||
-            pseudoTag == nsCSSPseudoElements::after) {
-          // XXX what other pseudos do we need to treat like this?
-          newContext = styleSet->ProbePseudoElementStyle(element,
-                                                         pseudoType,
-                                                         parentContext,
-                                                         aTreeMatchContext);
-          if (!newContext) {
-            // This pseudo should no longer exist; gotta reframe
-            NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
-            aChangeList->AppendChange(aFrame, element,
-                                      nsChangeHint_ReconstructFrame);
-            // We're reframing anyway; just keep the same context
-            newContext = oldContext;
-          }
-        } else {
-          // Don't expect XUL tree stuff here, since it needs a comparator and
-          // all.
-          NS_ASSERTION(pseudoType <
-                         nsCSSPseudoElements::ePseudo_PseudoElementCount,
-                       "Unexpected pseudo type");
-          newContext = styleSet->ResolvePseudoElementStyle(element,
-                                                           pseudoType,
-                                                           parentContext);
-        }
-      }
-      else {
-        NS_ASSERTION(localContent,
-                     "non pseudo-element frame without content node");
-        // Skip flex-item style fixup for anonymous subtrees:
-        TreeMatchContext::AutoFlexItemStyleFixupSkipper
-          flexFixupSkipper(aTreeMatchContext,
-                           element->IsRootOfNativeAnonymousSubtree());
-        newContext = styleSet->ResolveStyleFor(element, parentContext,
-                                               aTreeMatchContext);
-      }
-    }
-
-    NS_ASSERTION(newContext, "failed to get new style context");
-    if (newContext) {
-      if (!parentContext) {
-        if (oldContext->RuleNode() == newContext->RuleNode() &&
-            oldContext->IsLinkContext() == newContext->IsLinkContext() &&
-            oldContext->RelevantLinkVisited() ==
-              newContext->RelevantLinkVisited()) {
-          // We're the root of the style context tree and the new style
-          // context returned has the same rule node.  This means that
-          // we can use FindChildWithRules to keep a lot of the old
-          // style contexts around.  However, we need to start from the
-          // same root.
-          newContext = oldContext;
-        }
-      }
-
-      if (newContext != oldContext) {
-        if (!copyFromContinuation) {
-          TryStartingTransition(aPresContext, aFrame->GetContent(),
-                                oldContext, &newContext);
-        }
-
-        CaptureChange(oldContext, newContext, aFrame, content, aChangeList,
-                      aMinChange, aParentFrameHintsNotHandledForDescendants,
-                      nonInheritedHints, assumeDifferenceHint);
-        if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
-          // if frame gets regenerated, let it keep old context
-          aFrame->SetStyleContext(newContext);
-        }
-      }
-      oldContext->Release();
-    }
-    else {
-      NS_ERROR("resolve style context failed");
-      newContext = oldContext;  // new context failed, recover...
-    }
-
-    // do additional contexts
-    // XXXbz might be able to avoid selector matching here in some
-    // cases; won't worry about it for now.
-    int32_t contextIndex = -1;
-    while (1 == 1) {
-      nsStyleContext* oldExtraContext = nullptr;
-      oldExtraContext = aFrame->GetAdditionalStyleContext(++contextIndex);
-      if (oldExtraContext) {
-        nsRefPtr<nsStyleContext> newExtraContext;
-        nsIAtom* const extraPseudoTag = oldExtraContext->GetPseudo();
-        const nsCSSPseudoElements::Type extraPseudoType =
-          oldExtraContext->GetPseudoType();
-        NS_ASSERTION(extraPseudoTag &&
-                     extraPseudoTag != nsCSSAnonBoxes::mozNonElement,
-                     "extra style context is not pseudo element");
-        if (extraPseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
-          newExtraContext = styleSet->ResolveAnonymousBoxStyle(extraPseudoTag,
-                                                               newContext);
-        }
-        else {
-          // Don't expect XUL tree stuff here, since it needs a comparator and
-          // all.
-          NS_ASSERTION(extraPseudoType <
-                         nsCSSPseudoElements::ePseudo_PseudoElementCount,
-                       "Unexpected type");
-          newExtraContext = styleSet->ResolvePseudoElementStyle(content->AsElement(),
-                                                                extraPseudoType,
-                                                                newContext);
-        }
-        if (newExtraContext) {
-          if (oldExtraContext != newExtraContext) {
-            nsChangeHint extraHintsNotHandledForDescendants = nsChangeHint(0);
-            CaptureChange(oldExtraContext, newExtraContext, aFrame, content,
-                          aChangeList, aMinChange,
-                          aParentFrameHintsNotHandledForDescendants,
-                          extraHintsNotHandledForDescendants,
-                          assumeDifferenceHint);
-            NS_UpdateHint(nonInheritedHints, extraHintsNotHandledForDescendants);
-            if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
-              aFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
-            }
-          }
-        }
-      }
-      else {
-        break;
-      }
-    }
-
-    // now look for undisplayed child content and pseudos
-
-    // When the root element is display:none, we still construct *some*
-    // frames that have the root element as their mContent, down to the
-    // DocElementContainingBlock.
-    bool checkUndisplayed;
-    nsIContent *undisplayedParent;
-    if (pseudoTag) {
-      checkUndisplayed = aFrame == mPresShell->FrameConstructor()->
-                                     GetDocElementContainingBlock();
-      undisplayedParent = nullptr;
-    } else {
-      checkUndisplayed = !!localContent;
-      undisplayedParent = localContent;
-    }
-    if (checkUndisplayed && mUndisplayedMap) {
-      UndisplayedNode* undisplayed =
-        mUndisplayedMap->GetFirstNode(undisplayedParent);
-      for (TreeMatchContext::AutoAncestorPusher
-             pushAncestor(undisplayed, aTreeMatchContext,
-                          undisplayedParent ? undisplayedParent->AsElement()
-                                            : nullptr);
-           undisplayed; undisplayed = undisplayed->mNext) {
-        NS_ASSERTION(undisplayedParent ||
-                     undisplayed->mContent ==
-                       mPresShell->GetDocument()->GetRootElement(),
-                     "undisplayed node child of null must be root");
-        NS_ASSERTION(!undisplayed->mStyle->GetPseudo(),
-                     "Shouldn't have random pseudo style contexts in the "
-                     "undisplayed map");
-
-        // Get the parent of the undisplayed content and check if it is a XBL
-        // children element. Push the children element as an ancestor here because it does
-        // not have a frame and would not otherwise be pushed as an ancestor.
-        nsIContent* parent = undisplayed->mContent->GetParent();
-        bool pushInsertionPoint = parent && parent->IsActiveChildrenElement();
-        TreeMatchContext::AutoAncestorPusher
-          insertionPointPusher(pushInsertionPoint,
-                               aTreeMatchContext,
-                               parent && parent->IsElement() ? parent->AsElement() : nullptr);
-
-        nsRestyleHint thisChildHint = childRestyleHint;
-        RestyleTracker::RestyleData undisplayedRestyleData;
-        if (aRestyleTracker.GetRestyleData(undisplayed->mContent->AsElement(),
-                                           &undisplayedRestyleData)) {
-          thisChildHint =
-            nsRestyleHint(thisChildHint | undisplayedRestyleData.mRestyleHint);
-        }
-        nsRefPtr<nsStyleContext> undisplayedContext;
-        if (thisChildHint) {
-          undisplayedContext =
-            styleSet->ResolveStyleFor(undisplayed->mContent->AsElement(),
-                                      newContext,
-                                      aTreeMatchContext);
-        } else {
-          undisplayedContext =
-            styleSet->ReparentStyleContext(undisplayed->mStyle, newContext,
-                                           undisplayed->mContent->AsElement());
-        }
-        if (undisplayedContext) {
-          const nsStyleDisplay* display = undisplayedContext->StyleDisplay();
-          if (display->mDisplay != NS_STYLE_DISPLAY_NONE) {
-            NS_ASSERTION(undisplayed->mContent,
-                         "Must have undisplayed content");
-            aChangeList->AppendChange(nullptr, undisplayed->mContent, 
-                                      NS_STYLE_HINT_FRAMECHANGE);
-            // The node should be removed from the undisplayed map when
-            // we reframe it.
-          } else {
-            // update the undisplayed node with the new context
-            undisplayed->mStyle = undisplayedContext;
-          }
-        }
-      }
-    }
-
-    // Check whether we might need to create a new ::before frame.
-    // There's no need to do this if we're planning to reframe already
-    // or if we're not forcing restyles on kids.
-    if (!(aMinChange & nsChangeHint_ReconstructFrame) &&
-        childRestyleHint) {
-      // Make sure not to do this for pseudo-frames or frames that
-      // can't have generated content.
-      if (!pseudoTag &&
-          ((aFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
-           // Our content insertion frame might have gotten flagged
-           (aFrame->GetContentInsertionFrame()->GetStateBits() &
-            NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
-        // Check for a new :before pseudo and an existing :before
-        // frame, but only if the frame is the first continuation.
-        nsIFrame* prevContinuation = aFrame->GetPrevContinuation();
-        if (!prevContinuation) {
-          // Checking for a :before frame is cheaper than getting the
-          // :before style context.
-          if (!nsLayoutUtils::GetBeforeFrame(aFrame) &&
-              nsLayoutUtils::HasPseudoStyle(localContent, newContext,
-                                            nsCSSPseudoElements::ePseudo_before,
-                                            aPresContext)) {
-            // Have to create the new :before frame
-            NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
-            aChangeList->AppendChange(aFrame, content,
-                                      nsChangeHint_ReconstructFrame);
-          }
-        }
-      }
-    }
-
-    // Check whether we might need to create a new ::after frame.
-    // There's no need to do this if we're planning to reframe already
-    // or if we're not forcing restyles on kids.
-    if (!(aMinChange & nsChangeHint_ReconstructFrame) &&
-        childRestyleHint) {
-      // Make sure not to do this for pseudo-frames or frames that
-      // can't have generated content.
-      if (!pseudoTag &&
-          ((aFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
-           // Our content insertion frame might have gotten flagged
-           (aFrame->GetContentInsertionFrame()->GetStateBits() &
-            NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
-        // Check for new :after content, but only if the frame is the
-        // last continuation.
-        nsIFrame* nextContinuation = aFrame->GetNextContinuation();
-
-        if (!nextContinuation) {
-          // Getting the :after frame is more expensive than getting the pseudo
-          // context, so get the pseudo context first.
-          if (nsLayoutUtils::HasPseudoStyle(localContent, newContext,
-                                            nsCSSPseudoElements::ePseudo_after,
-                                            aPresContext) &&
-              !nsLayoutUtils::GetAfterFrame(aFrame)) {
-            // have to create the new :after frame
-            NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
-            aChangeList->AppendChange(aFrame, content,
-                                      nsChangeHint_ReconstructFrame);
-          }
-        }      
-      }
-    }
-
-    // There is no need to waste time crawling into a frame's children
-    // on a frame change.  The act of reconstructing frames will force
-    // new style contexts to be resolved on all of this frame's
-    // descendants anyway, so we want to avoid wasting time processing
-    // style contexts that we're just going to throw away anyway. - dwh
-    if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
-
-      DesiredA11yNotifications kidsDesiredA11yNotification =
-        aDesiredA11yNotifications;
-#ifdef ACCESSIBILITY
-      A11yNotificationType ourA11yNotification = eDontNotify;
-      // Notify a11y for primary frame only if it's a root frame of visibility
-      // changes or its parent frame was hidden while it stays visible and
-      // it is not inside a {ib} split or is the first frame of {ib} split.
-      if (nsIPresShell::IsAccessibilityActive() &&
-          !aFrame->GetPrevContinuation() &&
-          !nsLayoutUtils::FrameIsNonFirstInIBSplit(aFrame)) {
-        if (aDesiredA11yNotifications == eSendAllNotifications) {
-          bool isFrameVisible = newContext->StyleVisibility()->IsVisible();
-          if (isFrameVisible != wasFrameVisible) {
-            if (isFrameVisible) {
-              // Notify a11y the element (perhaps with its children) was shown.
-              // We don't fall into this case if this element gets or stays shown
-              // while its parent becomes hidden.
-              kidsDesiredA11yNotification = eSkipNotifications;
-              ourA11yNotification = eNotifyShown;
-            } else {
-              // The element is being hidden; its children may stay visible, or
-              // become visible after being hidden previously. If we'll find
-              // visible children then we should notify a11y about that as if
-              // they were inserted into tree. Notify a11y this element was
-              // hidden.
-              kidsDesiredA11yNotification = eNotifyIfShown;
-              ourA11yNotification = eNotifyHidden;
-            }
-          }
-        } else if (aDesiredA11yNotifications == eNotifyIfShown &&
-                   newContext->StyleVisibility()->IsVisible()) {
-          // Notify a11y that element stayed visible while its parent was
-          // hidden.
-          aVisibleKidsOfHiddenElement.AppendElement(aFrame->GetContent());
-          kidsDesiredA11yNotification = eSkipNotifications;
-        }
-      }
-#endif
-
-      // now do children
-      nsIFrame::ChildListIterator lists(aFrame);
-      for (TreeMatchContext::AutoAncestorPusher
-             pushAncestor(!lists.IsDone(),
-                          aTreeMatchContext,
-                          content && content->IsElement() ? content->AsElement()
-                                                          : nullptr);
-           !lists.IsDone(); lists.Next()) {
-        nsFrameList::Enumerator childFrames(lists.CurrentList());
-        for (; !childFrames.AtEnd(); childFrames.Next()) {
-          nsIFrame* child = childFrames.get();
-          if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
-            // Get the parent of the child frame's content and check if it is a XBL
-            // children element. Push the children element as an ancestor here because it does
-            // not have a frame and would not otherwise be pushed as an ancestor.
-
-            // Check if the frame has a content because |child| may be a nsPageFrame that does
-            // not have a content.
-            nsIContent* parent = child->GetContent() ? child->GetContent()->GetParent() : nullptr;
-            bool pushInsertionPoint = parent && parent->IsActiveChildrenElement();
-            TreeMatchContext::AutoAncestorPusher
-              insertionPointPusher(pushInsertionPoint, aTreeMatchContext,
-                                   parent && parent->IsElement() ? parent->AsElement() : nullptr);
-
-            // only do frames that are in flow
-            if (nsGkAtoms::placeholderFrame == child->GetType()) { // placeholder
-              // get out of flow frame and recur there
-              nsIFrame* outOfFlowFrame =
-                nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
-              NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
-              NS_ASSERTION(outOfFlowFrame != resolvedChild,
-                           "out-of-flow frame not a true descendant");
-
-              // Note that the out-of-flow may not be a geometric descendant of
-              // the frame where we started the reresolve.  Therefore, even if
-              // aMinChange already includes nsChangeHint_AllReflowHints we don't
-              // want to pass that on to the out-of-flow reresolve, since that
-              // can lead to the out-of-flow not getting reflowed when it should
-              // be (eg a reresolve starting at <body> that involves reflowing
-              // the <body> would miss reflowing fixed-pos nodes that also need
-              // reflow).  In the cases when the out-of-flow _is_ a geometric
-              // descendant of a frame we already have a reflow hint for,
-              // reflow coalescing should keep us from doing the work twice.
-
-              // |nsFrame::GetParentStyleContextFrame| checks being out
-              // of flow so that this works correctly.
-              do {
-                ReResolveStyleContext(aPresContext, outOfFlowFrame,
-                                      content, aChangeList,
-                                      NS_SubtractHint(aMinChange,
-                                                      nsChangeHint_AllReflowHints),
-                                      nonInheritedHints,
-                                      childRestyleHint,
-                                      aRestyleTracker,
-                                      kidsDesiredA11yNotification,
-                                      aVisibleKidsOfHiddenElement,
-                                      aTreeMatchContext);
-              } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
-
-              // reresolve placeholder's context under the same parent
-              // as the out-of-flow frame
-              ReResolveStyleContext(aPresContext, child, content,
-                                    aChangeList, aMinChange,
-                                    nonInheritedHints,
-                                    childRestyleHint,
-                                    aRestyleTracker,
-                                    kidsDesiredA11yNotification,
-                                    aVisibleKidsOfHiddenElement,
-                                    aTreeMatchContext);
-            }
-            else {  // regular child frame
-              if (child != resolvedChild) {
-                ReResolveStyleContext(aPresContext, child, content,
-                                      aChangeList, aMinChange,
-                                      nonInheritedHints,
-                                      childRestyleHint,
-                                      aRestyleTracker,
-                                      kidsDesiredA11yNotification,
-                                      aVisibleKidsOfHiddenElement,
-                                      aTreeMatchContext);
-              } else {
-                NOISY_TRACE_FRAME("child frame already resolved as descendant, skipping",aFrame);
-              }
-            }
-          }
-        }
-      }
-      // XXX need to do overflow frames???
-
-#ifdef ACCESSIBILITY
-      // Send notifications about visibility changes.
-      if (ourA11yNotification == eNotifyShown) {
-        nsAccessibilityService* accService = nsIPresShell::AccService();
-        if (accService) {
-          nsIPresShell* presShell = aFrame->PresContext()->GetPresShell();
-          nsIContent* content = aFrame->GetContent();
-
-          accService->ContentRangeInserted(presShell, content->GetParent(),
-                                           content,
-                                           content->GetNextSibling());
-        }
-      } else if (ourA11yNotification == eNotifyHidden) {
-        nsAccessibilityService* accService = nsIPresShell::AccService();
-        if (accService) {
-          nsIPresShell* presShell = aFrame->PresContext()->GetPresShell();
-          nsIContent* content = aFrame->GetContent();
-          accService->ContentRemoved(presShell, content->GetParent(), content);
-
-          // Process children staying shown.
-          uint32_t visibleContentCount = aVisibleKidsOfHiddenElement.Length();
-          for (uint32_t idx = 0; idx < visibleContentCount; idx++) {
-            nsIContent* content = aVisibleKidsOfHiddenElement[idx];
-            accService->ContentRangeInserted(presShell, content->GetParent(),
-                                             content, content->GetNextSibling());
-          }
-          aVisibleKidsOfHiddenElement.Clear();
-        }
-      }
-#endif
-    }
-  }
-
-  return aMinChange;
-}
-
-void
-nsFrameManager::ComputeStyleChangeFor(nsIFrame          *aFrame, 
-                                      nsStyleChangeList *aChangeList,
-                                      nsChangeHint       aMinChange,
-                                      RestyleTracker&    aRestyleTracker,
-                                      bool               aRestyleDescendants)
-{
-  PROFILER_LABEL("CSS", "ComputeStyleChangeFor");
-
-  nsIContent *content = aFrame->GetContent();
-  if (aMinChange) {
-    aChangeList->AppendChange(aFrame, content, aMinChange);
-  }
-
-  nsIFrame* frame = aFrame;
-  nsIFrame* frame2 = aFrame;
-
-  NS_ASSERTION(!frame->GetPrevContinuation(), "must start with the first in flow");
-
-  // We want to start with this frame and walk all its next-in-flows,
-  // as well as all its special siblings and their next-in-flows,
-  // reresolving style on all the frames we encounter in this walk.
-
-  FramePropertyTable *propTable = GetPresContext()->PropertyTable();
-
-  TreeMatchContext treeMatchContext(true,
-                                    nsRuleWalker::eRelevantLinkUnvisited,
-                                    mPresShell->GetDocument());
-  nsIContent *parent = content ? content->GetParent() : nullptr;
-  Element *parentElement =
-    parent && parent->IsElement() ? parent->AsElement() : nullptr;
-  treeMatchContext.InitAncestors(parentElement);
-  nsTArray<nsIContent*> visibleKidsOfHiddenElement;
-  do {
-    // Outer loop over special siblings
-    do {
-      // Inner loop over next-in-flows of the current frame
-      nsChangeHint frameChange =
-        ReResolveStyleContext(GetPresContext(), frame, nullptr,
-                              aChangeList, aMinChange, nsChangeHint(0),
-                              aRestyleDescendants ?
-                                eRestyle_Subtree : eRestyle_Self,
-                              aRestyleTracker,
-                              eSendAllNotifications,
-                              visibleKidsOfHiddenElement,
-                              treeMatchContext);
-
-      if (frameChange & nsChangeHint_ReconstructFrame) {
-        // If it's going to cause a framechange, then don't bother
-        // with the continuations or special siblings since they'll be
-        // clobbered by the frame reconstruct anyway.
-        NS_ASSERTION(!frame->GetPrevContinuation(),
-                     "continuing frame had more severe impact than first-in-flow");
-        return;
-      }
-
-      frame = frame->GetNextContinuation();
-    } while (frame);
-
-    // Might we have special siblings?
-    if (!(frame2->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
-      // nothing more to do here
-      return;
-    }
-    
-    frame2 = static_cast<nsIFrame*>
-      (propTable->Get(frame2, nsIFrame::IBSplitSpecialSibling()));
-    frame = frame2;
-  } while (frame2);
-}
-
 // Capture state for a given frame.
 // Accept a content id here, in some cases we may not have content (scroll position)
 void
 nsFrameManager::CaptureFrameStateFor(nsIFrame* aFrame,
                                      nsILayoutHistoryState* aState)
 {
   if (!aFrame || !aState) {
     NS_WARNING("null frame, or state");
diff --git a/layout/base/nsFrameManager.h b/layout/base/nsFrameManager.h
--- a/layout/base/nsFrameManager.h
+++ b/layout/base/nsFrameManager.h
@@ -20,18 +20,16 @@
 #define _nsFrameManager_h_
 
 #include "nsIFrame.h"
 #include "nsIStatefulFrame.h"
 #include "nsChangeHint.h"
 #include "nsFrameManagerBase.h"
 
 namespace mozilla {
-class RestyleTracker;
-
 /**
  * Node in a linked list, containing the style for an element that
  * does not have a frame but whose parent does have a frame.
  */
 struct UndisplayedNode {
   UndisplayedNode(nsIContent* aContent, nsStyleContext* aStyle)
     : mContent(aContent),
       mStyle(aStyle),
@@ -56,32 +54,29 @@ struct UndisplayedNode {
 
   nsCOMPtr<nsIContent>      mContent;
   nsRefPtr<nsStyleContext>  mStyle;
   UndisplayedNode*          mNext;
 };
 
 } // namespace mozilla
 
-struct TreeMatchContext;
-
 /**
  * Frame manager interface. The frame manager serves two purposes:
  * <li>provides a service for mapping from content to frame and from
  * out-of-flow frame to placeholder frame.
  * <li>handles structural modifications to the frame model. If the frame model
  * lock can be acquired, then the changes are processed immediately; otherwise,
  * they're queued and processed later.
  *
  * Do not add virtual methods to this class, or bryner will punish you.
  */
 
 class nsFrameManager : public nsFrameManagerBase
 {
-  typedef mozilla::RestyleTracker RestyleTracker;
   typedef nsIFrame::ChildListID ChildListID;
 
 public:
   nsFrameManager(nsIPresShell *aPresShell, nsStyleSet* aStyleSet) NS_HIDDEN {
     mPresShell = aPresShell;
     mStyleSet = aStyleSet;
     MOZ_ASSERT(mPresShell, "need a pres shell");
     MOZ_ASSERT(mStyleSet, "need a style set");
@@ -132,38 +127,16 @@ public:
 
   /*
    * Notification that a frame is about to be destroyed. This allows any
    * outstanding references to the frame to be cleaned up.
    */
   NS_HIDDEN_(void)     NotifyDestroyingFrame(nsIFrame* aFrame);
 
   /*
-   * Reparent the style contexts of this frame subtree.  The parent frame of
-   * aFrame must be changed to the new parent before this function is called;
-   * the new parent style context will be automatically computed based on the
-   * new position in the frame tree.
-   *
-   * @param aFrame the root of the subtree to reparent.  Must not be null.
-   */
-  NS_HIDDEN_(nsresult) ReparentStyleContext(nsIFrame* aFrame);
-
-  /*
-   * Re-resolve the style contexts for a frame tree, building
-   * aChangeList based on the resulting style changes, plus aMinChange
-   * applied to aFrame.
-   */
-  NS_HIDDEN_(void)
-    ComputeStyleChangeFor(nsIFrame* aFrame,
-                          nsStyleChangeList* aChangeList,
-                          nsChangeHint aMinChange,
-                          RestyleTracker& aRestyleTracker,
-                          bool aRestyleDescendants);
-
-  /*
    * Capture/restore frame state for the frame subtree rooted at aFrame.
    * aState is the document state storage object onto which each frame
    * stores its state.  Callers of CaptureFrameState are responsible for
    * traversing next continuations of special siblings of aFrame as
    * needed; this method will only work with actual frametree descendants
    * of aFrame.
    */
 
@@ -177,53 +150,15 @@ public:
    * Add/restore state for one frame
    */
   NS_HIDDEN_(void) CaptureFrameStateFor(nsIFrame*              aFrame,
                                         nsILayoutHistoryState* aState);
 
   NS_HIDDEN_(void) RestoreFrameStateFor(nsIFrame*              aFrame,
                                         nsILayoutHistoryState* aState);
 
-#ifdef DEBUG
-  /**
-   * DEBUG ONLY method to verify integrity of style tree versus frame tree
-   */
-  NS_HIDDEN_(void) DebugVerifyStyleTree(nsIFrame* aFrame);
-#endif
-
   NS_HIDDEN_(nsIPresShell*) GetPresShell() const { return mPresShell; }
   NS_HIDDEN_(nsPresContext*) GetPresContext() const {
     return mPresShell->GetPresContext();
   }
-
-private:
-  enum DesiredA11yNotifications {
-    eSkipNotifications,
-    eSendAllNotifications,
-    eNotifyIfShown
-  };
-
-  enum A11yNotificationType {
-    eDontNotify,
-    eNotifyShown,
-    eNotifyHidden
-  };
-
-  // Use eRestyle_Self for the aRestyleHint argument to mean
-  // "reresolve our style context but not kids", use eRestyle_Subtree
-  // to mean "reresolve our style context and kids", and use
-  // nsRestyleHint(0) to mean recompute a new style context for our
-  // current parent and existing rulenode, and the same for kids.
-  NS_HIDDEN_(nsChangeHint)
-    ReResolveStyleContext(nsPresContext    *aPresContext,
-                          nsIFrame          *aFrame,
-                          nsIContent        *aParentContent,
-                          nsStyleChangeList *aChangeList, 
-                          nsChangeHint       aMinChange,
-                          nsChangeHint       aParentFrameHintsNotHandledForDescendants,
-                          nsRestyleHint      aRestyleHint,
-                          RestyleTracker&    aRestyleTracker,
-                          DesiredA11yNotifications aDesiredA11yNotifications,
-                          nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
-                          TreeMatchContext &aTreeMatchContext);
 };
 
 #endif
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -535,17 +535,17 @@ PRLogModuleInfo* PresShell::gLog;
 #endif
 
 #ifdef DEBUG
 static void
 VerifyStyleTree(nsPresContext* aPresContext, nsFrameManager* aFrameManager)
 {
   if (nsFrame::GetVerifyStyleTreeEnable()) {
     nsIFrame* rootFrame = aFrameManager->GetRootFrame();
-    aFrameManager->DebugVerifyStyleTree(rootFrame);
+    aPresContext->RestyleManager()->DebugVerifyStyleTree(rootFrame);
   }
 }
 #define VERIFY_STYLE_TREE ::VerifyStyleTree(mPresContext, mFrameConstructor)
 #else
 #define VERIFY_STYLE_TREE
 #endif
 
 static bool gVerifyReflowEnabled;
diff --git a/layout/forms/nsFieldSetFrame.cpp b/layout/forms/nsFieldSetFrame.cpp
--- a/layout/forms/nsFieldSetFrame.cpp
+++ b/layout/forms/nsFieldSetFrame.cpp
@@ -11,17 +11,17 @@
 #include "nsIDOMHTMLLegendElement.h"
 #include "nsCSSRendering.h"
 #include <algorithm>
 #include "nsIContent.h"
 #include "nsIFrame.h"
 #include "nsISupports.h"
 #include "nsIAtom.h"
 #include "nsPresContext.h"
-#include "nsFrameManager.h"
+#include "RestyleManager.h"
 #include "nsHTMLParts.h"
 #include "nsGkAtoms.h"
 #include "nsStyleConsts.h"
 #include "nsFont.h"
 #include "nsCOMPtr.h"
 #include "nsIServiceManager.h"
 #include "nsDisplayList.h"
 #include "nsRenderingContext.h"
@@ -675,23 +675,23 @@ nsFieldSetFrame::AccessibleType()
 {
   return a11y::eHTMLGroupboxType;
 }
 #endif
 
 void
 nsFieldSetFrame::ReparentFrameList(const nsFrameList& aFrameList)
 {
-  nsFrameManager* frameManager = PresContext()->FrameManager();
+  RestyleManager* restyleManager = PresContext()->RestyleManager();
   nsIFrame* inner = GetInner();
   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
     NS_ASSERTION(GetLegend() || e.get()->GetType() != nsGkAtoms::legendFrame,
                  "The fieldset's legend is not allowed in this list");
     e.get()->SetParent(inner);
-    frameManager->ReparentStyleContext(e.get());
+    restyleManager->ReparentStyleContext(e.get());
   }
 }
 
 nscoord
 nsFieldSetFrame::GetBaseline() const
 {
   // We know inner is a block, so calling GetBaseline() on it will do
   // the right thing (that being to return the baseline of the last line).
diff --git a/layout/generic/nsFirstLetterFrame.cpp b/layout/generic/nsFirstLetterFrame.cpp
--- a/layout/generic/nsFirstLetterFrame.cpp
+++ b/layout/generic/nsFirstLetterFrame.cpp
@@ -10,16 +10,17 @@
 #include "nsPresContext.h"
 #include "nsStyleContext.h"
 #include "nsIContent.h"
 #include "nsLineLayout.h"
 #include "nsGkAtoms.h"
 #include "nsAutoPtr.h"
 #include "nsStyleSet.h"
 #include "nsFrameManager.h"
+#include "RestyleManager.h"
 #include "nsPlaceholderFrame.h"
 #include "nsCSSFrameConstructor.h"
 
 using namespace mozilla;
 using namespace mozilla::layout;
 
 nsIFrame*
 NS_NewFirstLetterFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
@@ -76,21 +77,21 @@ nsFirstLetterFrame::Init(nsIContent*    
 
   nsContainerFrame::Init(aContent, aParent, aPrevInFlow);
 }
 
 NS_IMETHODIMP
 nsFirstLetterFrame::SetInitialChildList(ChildListID  aListID,
                                         nsFrameList& aChildList)
 {
-  nsFrameManager *frameManager = PresContext()->FrameManager();
+  RestyleManager *restyleManager = PresContext()->RestyleManager();
 
   for (nsFrameList::Enumerator e(aChildList); !e.AtEnd(); e.Next()) {
     NS_ASSERTION(e.get()->GetParent() == this, "Unexpected parent");
-    frameManager->ReparentStyleContext(e.get());
+    restyleManager->ReparentStyleContext(e.get());
   }
 
   mFrames.SetFrames(aChildList);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsFirstLetterFrame::GetChildFrameContainingOffset(int32_t inContentOffset,
diff --git a/layout/generic/nsInlineFrame.cpp b/layout/generic/nsInlineFrame.cpp
--- a/layout/generic/nsInlineFrame.cpp
+++ b/layout/generic/nsInlineFrame.cpp
@@ -13,17 +13,17 @@
 #include "nsGkAtoms.h"
 #include "nsHTMLParts.h"
 #include "nsStyleContext.h"
 #include "nsIPresShell.h"
 #include "nsPresContext.h"
 #include "nsRenderingContext.h"
 #include "nsCSSAnonBoxes.h"
 #include "nsAutoPtr.h"
-#include "nsFrameManager.h"
+#include "RestyleManager.h"
 #include "nsDisplayList.h"
 #include "mozilla/Likely.h"
 
 #ifdef DEBUG
 #undef NOISY_PUSHING
 #endif
 
 using namespace mozilla;
@@ -279,21 +279,21 @@ nsInlineFrame::ReparentFloatsForInlineCh
   }
 }
 
 static void
 ReparentChildListStyle(nsPresContext* aPresContext,
                        const nsFrameList::Slice& aFrames,
                        nsIFrame* aParentFrame)
 {
-  nsFrameManager *frameManager = aPresContext->FrameManager();
+  RestyleManager *restyleManager = aPresContext->RestyleManager();
 
   for (nsFrameList::Enumerator e(aFrames); !e.AtEnd(); e.Next()) {
     NS_ASSERTION(e.get()->GetParent() == aParentFrame, "Bogus parentage");
-    frameManager->ReparentStyleContext(e.get());
+    restyleManager->ReparentStyleContext(e.get());
   }
 }
 
 NS_IMETHODIMP
 nsInlineFrame::Reflow(nsPresContext*          aPresContext,
                       nsHTMLReflowMetrics&     aMetrics,
                       const nsHTMLReflowState& aReflowState,
                       nsReflowStatus&          aStatus)
@@ -379,21 +379,21 @@ nsInlineFrame::Reflow(nsPresContext*    
         // previous lazilySetParentPointer Reflow so we need to ensure
         // the correct parent pointer now since we're not setting it
         // lazily in this Reflow.
         nsIFrame* firstChild = overflowFrames->FirstChild();
         if (lineContainer && lineContainer->GetPrevContinuation()) {
           ReparentFloatsForInlineChild(lineContainer, firstChild, true);
         }
         const bool inFirstLine = aReflowState.mLineLayout->GetInFirstLine();
-        nsFrameManager* fm = PresContext()->FrameManager();
+        RestyleManager* restyleManager = PresContext()->RestyleManager();
         for (nsIFrame* f = firstChild; f; f = f->GetNextSibling()) {
           f->SetParent(this);
           if (inFirstLine) {
-            fm->ReparentStyleContext(f);
+            restyleManager->ReparentStyleContext(f);
           }
         }
       }
       mFrames.AppendFrames(nullptr, *overflowFrames);
     }
   }
 
   // Set our own reflow state (additional state above and beyond
@@ -456,17 +456,17 @@ nsInlineFrame::ReflowFrames(nsPresContex
                             nsHTMLReflowMetrics& aMetrics,
                             nsReflowStatus& aStatus)
 {
   nsresult rv = NS_OK;
   aStatus = NS_FRAME_COMPLETE;
 
   nsLineLayout* lineLayout = aReflowState.mLineLayout;
   bool inFirstLine = aReflowState.mLineLayout->GetInFirstLine();
-  nsFrameManager* frameManager = aPresContext->FrameManager();
+  RestyleManager* restyleManager = aPresContext->RestyleManager();
   bool ltr = (NS_STYLE_DIRECTION_LTR == aReflowState.mStyleVisibility->mDirection);
   nscoord leftEdge = 0;
   // Don't offset by our start borderpadding if we have a prev continuation or
   // if we're in a part of an {ib} split other than the first one.
   if (!GetPrevContinuation() &&
       !nsLayoutUtils::FrameIsNonFirstInIBSplit(this)) {
     leftEdge = ltr ? aReflowState.mComputedBorderPadding.left
                    : aReflowState.mComputedBorderPadding.right;
@@ -501,17 +501,17 @@ nsInlineFrame::ReflowFrames(nsPresContex
           // easily avoid it because we don't know where 'frame' originally
           // came from. If we really really have to optimize this we could
           // cache whether frame->GetParent() is under its containing blocks
           // overflowList or not.
           ReparentFloatsForInlineChild(irs.mLineContainer, child, false);
         }
         child->SetParent(this);
         if (inFirstLine) {
-          frameManager->ReparentStyleContext(child);
+          restyleManager->ReparentStyleContext(child);
         }
         // We also need to do the same for |frame|'s next-in-flows that are in
         // the sibling list. Otherwise, if we reflow |frame| and it's complete
         // we'll crash when trying to delete its next-in-flow.
         // This scenario doesn't happen often, but it can happen.
         nsIFrame* nextSibling = child->GetNextSibling();
         child = child->GetNextInFlow();
         if (MOZ_UNLIKELY(child)) {
@@ -535,17 +535,17 @@ nsInlineFrame::ReflowFrames(nsPresContex
                        "unexpected frame type");
           nsIFrame* nextInFlow = child->GetNextInFlow();
           for ( ; nextInFlow; nextInFlow = nextInFlow->GetNextInFlow()) {
             NS_ASSERTION(nextInFlow->GetType() == nsGkAtoms::textFrame,
                          "unexpected frame type");
             if (mFrames.ContainsFrame(nextInFlow)) {
               nextInFlow->SetParent(this);
               if (inFirstLine) {
-                frameManager->ReparentStyleContext(nextInFlow);
+                restyleManager->ReparentStyleContext(nextInFlow);
               }
             }
             else {
 #ifdef DEBUG              
               // Once we find a next-in-flow that isn't ours none of the
               // remaining next-in-flows should be either.
               for ( ; nextInFlow; nextInFlow = nextInFlow->GetNextInFlow()) {
                 NS_ASSERTION(!mFrames.ContainsFrame(nextInFlow),
@@ -985,17 +985,17 @@ nsIFrame*
 nsFirstLineFrame::PullOneFrame(nsPresContext* aPresContext, InlineReflowState& irs,
                                bool* aIsComplete)
 {
   nsIFrame* frame = nsInlineFrame::PullOneFrame(aPresContext, irs, aIsComplete);
   if (frame && !GetPrevInFlow()) {
     // We are a first-line frame. Fixup the child frames
     // style-context that we just pulled.
     NS_ASSERTION(frame->GetParent() == this, "Incorrect parent?");
-    aPresContext->FrameManager()->ReparentStyleContext(frame);
+    aPresContext->RestyleManager()->ReparentStyleContext(frame);
   }
   return frame;
 }
 
 NS_IMETHODIMP
 nsFirstLineFrame::Reflow(nsPresContext* aPresContext,
                          nsHTMLReflowMetrics& aMetrics,
                          const nsHTMLReflowState& aReflowState,
