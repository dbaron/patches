From: L. David Baron <dbaron@dbaron.org>

Fix another case of bad border-radius corners (and document a third that's not fixed).  (Bug 500141)  r=roc  a2.0=blocking

diff --git a/layout/base/nsCSSRenderingBorders.cpp b/layout/base/nsCSSRenderingBorders.cpp
--- a/layout/base/nsCSSRenderingBorders.cpp
+++ b/layout/base/nsCSSRenderingBorders.cpp
@@ -415,36 +415,39 @@ typedef enum {
   SIDE_CLIP_TRAPEZOID_FULL,
 
   // clip to the rectangle formed by the given side; a specific
   // overlap algorithm is used; see the function for details.
   // this is currently used for dashing.
   SIDE_CLIP_RECTANGLE
 } SideClipType;
 
-// Given three points, p0, p1, and midPoint, move p1 to the point
-// nearest the midpoint, while maintaing the slope of the line.  p0 and
-// p1 must be distinct.
+// Given three points, p0, p1, and midPoint, move p1 further in to the
+// rectangle (of which aMidPoint is the center) so that it reaches the
+// closer of the horizontal or vertical lines intersecting the midpoint,
+// while maintaing the slope of the line.  p0 and p1 must be distinct.
+// FIXME: Extending only to the midpoint isn't actually sufficient for
+// boxes with asymmetric radii.
 static void
 MaybeMoveToMidPoint(gfxPoint& aP0, gfxPoint& aP1, const gfxPoint& aMidPoint)
 {
   gfxPoint ps = aP1 - aP0;
 
   if (ps.x == 0.0) {
     if (ps.y == 0.0) {
       NS_NOTREACHED("points should be different");
     } else {
       aP1.y = aMidPoint.y;
     }
   } else {
     if (ps.y == 0.0) {
       aP1.x = aMidPoint.x;
     } else {
       gfxFloat k = NS_MIN((aMidPoint.x - aP0.x) / ps.x,
-                          (aMidPoint.y - aP1.y) / ps.y);
+                          (aMidPoint.y - aP0.y) / ps.y);
       aP1 = aP0 + ps * k;
     }
   }
 }
 
 void
 nsCSSBorderRenderer::DoSideClipSubPath(mozilla::css::Side aSide)
 {
