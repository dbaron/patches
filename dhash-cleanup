Consolidate duplicated code into the beginning of the double-hashing loop.  b=374906  r=brendan

diff --git a/js/src/jsdhash.c b/js/src/jsdhash.c
--- a/js/src/jsdhash.c
+++ b/js/src/jsdhash.c
@@ -424,37 +424,31 @@ SearchTable(JSDHashTable *table, const v
     sizeMask = JS_BITMASK(sizeLog2);
 
     /* Save the first removed entry pointer so JS_DHASH_ADD can recycle it. */
-    if (ENTRY_IS_REMOVED(entry)) {
-        firstRemoved = entry;
-    } else {
-        firstRemoved = NULL;
-        if (op == JS_DHASH_ADD)
-            entry->keyHash |= COLLISION_FLAG;
-    }
+    firstRemoved = NULL;
 
     for (;;) {
-        METER(table->stats.steps++);
-        hash1 -= hash2;
-        hash1 &= sizeMask;
-
-        entry = ADDRESS_ENTRY(table, hash1);
-        if (JS_DHASH_ENTRY_IS_FREE(entry)) {
-            METER(table->stats.misses++);
-            return (firstRemoved && op == JS_DHASH_ADD) ? firstRemoved : entry;
-        }
-
-        if (MATCH_ENTRY_KEYHASH(entry, keyHash) &&
-            matchEntry(table, entry, key)) {
-            METER(table->stats.hits++);
-            return entry;
-        }
-
-        if (ENTRY_IS_REMOVED(entry)) {
+        if (JS_UNLIKELY(ENTRY_IS_REMOVED(entry))) {
             if (!firstRemoved)
                 firstRemoved = entry;
         } else {
             if (op == JS_DHASH_ADD)
                 entry->keyHash |= COLLISION_FLAG;
+        }
+
+        METER(table->stats.steps++);
+        hash1 -= hash2;
+        hash1 &= sizeMask;
+
+        entry = ADDRESS_ENTRY(table, hash1);
+        if (JS_DHASH_ENTRY_IS_FREE(entry)) {
+            METER(table->stats.misses++);
+            return (firstRemoved && op == JS_DHASH_ADD) ? firstRemoved : entry;
+        }
+
+        if (MATCH_ENTRY_KEYHASH(entry, keyHash) &&
+            matchEntry(table, entry, key)) {
+            METER(table->stats.hits++);
+            return entry;
         }
     }
 
@@ -499,10 +493,10 @@ FindFreeEntry(JSDHashTable *table, JSDHa
     hash2 = HASH2(keyHash, sizeLog2, hashShift);
     sizeMask = JS_BITMASK(sizeLog2);
 
-    JS_ASSERT(!ENTRY_IS_REMOVED(entry));
-    entry->keyHash |= COLLISION_FLAG;
-
     for (;;) {
+        JS_ASSERT(!ENTRY_IS_REMOVED(entry));
+        entry->keyHash |= COLLISION_FLAG;
+
         METER(table->stats.steps++);
         hash1 -= hash2;
         hash1 &= sizeMask;
@@ -512,9 +506,6 @@ FindFreeEntry(JSDHashTable *table, JSDHa
             METER(table->stats.misses++);
             return entry;
         }
-
-        JS_ASSERT(!ENTRY_IS_REMOVED(entry));
-        entry->keyHash |= COLLISION_FLAG;
     }
 
     /* NOTREACHED */
diff --git a/js/src/plify_jsdhash.sed b/js/src/plify_jsdhash.sed
--- a/js/src/plify_jsdhash.sed
+++ b/js/src/plify_jsdhash.sed
@@ -30,5 +30,7 @@ s/JS_NewDHashTable/PL_NewDHashTable/
 s/JS_NewDHashTable/PL_NewDHashTable/
 s/JS_ASSERT(0)/NS_NOTREACHED("0")/
 s/\( *\)JS_ASSERT(\(.*\));/\1NS_ASSERTION(\2,\n\1             "\2");/
+s/JS_UNLIKELY/NS_UNLIKELY/g
+s/JS_LIKELY/NS_LIKELY/g
 s/JS_/PR_/g
 s/fprintf(stderr,/printf_stderr(/
diff --git a/xpcom/glue/pldhash.c b/xpcom/glue/pldhash.c
--- a/xpcom/glue/pldhash.c
+++ b/xpcom/glue/pldhash.c
@@ -430,37 +430,31 @@ SearchTable(PLDHashTable *table, const v
     sizeMask = PR_BITMASK(sizeLog2);
 
     /* Save the first removed entry pointer so PL_DHASH_ADD can recycle it. */
-    if (ENTRY_IS_REMOVED(entry)) {
-        firstRemoved = entry;
-    } else {
-        firstRemoved = NULL;
-        if (op == PL_DHASH_ADD)
-            entry->keyHash |= COLLISION_FLAG;
-    }
+    firstRemoved = NULL;
 
     for (;;) {
-        METER(table->stats.steps++);
-        hash1 -= hash2;
-        hash1 &= sizeMask;
-
-        entry = ADDRESS_ENTRY(table, hash1);
-        if (PL_DHASH_ENTRY_IS_FREE(entry)) {
-            METER(table->stats.misses++);
-            return (firstRemoved && op == PL_DHASH_ADD) ? firstRemoved : entry;
-        }
-
-        if (MATCH_ENTRY_KEYHASH(entry, keyHash) &&
-            matchEntry(table, entry, key)) {
-            METER(table->stats.hits++);
-            return entry;
-        }
-
-        if (ENTRY_IS_REMOVED(entry)) {
+        if (NS_UNLIKELY(ENTRY_IS_REMOVED(entry))) {
             if (!firstRemoved)
                 firstRemoved = entry;
         } else {
             if (op == PL_DHASH_ADD)
                 entry->keyHash |= COLLISION_FLAG;
+        }
+
+        METER(table->stats.steps++);
+        hash1 -= hash2;
+        hash1 &= sizeMask;
+
+        entry = ADDRESS_ENTRY(table, hash1);
+        if (PL_DHASH_ENTRY_IS_FREE(entry)) {
+            METER(table->stats.misses++);
+            return (firstRemoved && op == PL_DHASH_ADD) ? firstRemoved : entry;
+        }
+
+        if (MATCH_ENTRY_KEYHASH(entry, keyHash) &&
+            matchEntry(table, entry, key)) {
+            METER(table->stats.hits++);
+            return entry;
         }
     }
 
@@ -506,11 +500,11 @@ FindFreeEntry(PLDHashTable *table, PLDHa
     hash2 = HASH2(keyHash, sizeLog2, hashShift);
     sizeMask = PR_BITMASK(sizeLog2);
 
-    NS_ASSERTION(!ENTRY_IS_REMOVED(entry),
-                 "!ENTRY_IS_REMOVED(entry)");
-    entry->keyHash |= COLLISION_FLAG;
-
     for (;;) {
+        NS_ASSERTION(!ENTRY_IS_REMOVED(entry),
+                     "!ENTRY_IS_REMOVED(entry)");
+        entry->keyHash |= COLLISION_FLAG;
+
         METER(table->stats.steps++);
         hash1 -= hash2;
         hash1 &= sizeMask;
@@ -520,10 +514,6 @@ FindFreeEntry(PLDHashTable *table, PLDHa
             METER(table->stats.misses++);
             return entry;
         }
-
-        NS_ASSERTION(!ENTRY_IS_REMOVED(entry),
-                     "!ENTRY_IS_REMOVED(entry)");
-        entry->keyHash |= COLLISION_FLAG;
     }
 
     /* NOTREACHED */
