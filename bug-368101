Make SVG foreignObject frames reflow roots, instead of their child, so that marking the child dirty still keeps the change constrained to the foreignObject.  b=368101  r+sr=roc

diff -r ae79c58da0da layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp	Thu Jan 25 15:11:32 2007 -0800
+++ b/layout/base/nsCSSFrameConstructor.cpp	Thu Jan 25 15:11:35 2007 -0800
@@ -7339,8 +7339,7 @@ nsCSSFrameConstructor::ConstructSVGFrame
     
       nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, innerPseudoStyle,
                                               NS_BLOCK_SPACE_MGR |
-                                                NS_BLOCK_MARGIN_ROOT |
-                                                NS_FRAME_REFLOW_ROOT);
+                                                NS_BLOCK_MARGIN_ROOT);
       if (NS_UNLIKELY(!blockFrame))
         return NS_ERROR_OUT_OF_MEMORY;
     
diff -r ae79c58da0da layout/svg/base/src/nsSVGForeignObjectFrame.cpp
--- a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp	Thu Jan 25 15:11:32 2007 -0800
+++ b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp	Thu Jan 25 15:11:35 2007 -0800
@@ -82,6 +82,7 @@ nsSVGForeignObjectFrame::nsSVGForeignObj
   : nsSVGForeignObjectFrameBase(aContext),
     mPropagateTransform(PR_TRUE), mInReflow(PR_FALSE)
 {
+  AddStateBits(NS_FRAME_REFLOW_ROOT);
 }
 
 //----------------------------------------------------------------------
@@ -142,6 +143,31 @@ nsSVGForeignObjectFrame::DidSetStyleCont
   nsSVGUtils::StyleEffects(this);
   return NS_OK;
 }
+
+NS_IMETHODIMP
+nsSVGForeignObjectFrame::Reflow(nsPresContext*           aPresContext,
+                                nsHTMLReflowMetrics&     aDesiredSize,
+                                const nsHTMLReflowState& aReflowState,
+                                nsReflowStatus&          aStatus)
+{
+  NS_ASSERTION(!aReflowState.parentReflowState,
+               "should only get reflow from being reflow root");
+  NS_ASSERTION(aReflowState.mComputedWidth == GetSize().width &&
+               aReflowState.mComputedHeight == GetSize().height,
+               "reflow roots should be reflown at existing size and "
+               "svg.css should ensure we have no padding/border/margin");
+
+  DoReflow();
+
+  aDesiredSize.width = aReflowState.mComputedWidth;
+  aDesiredSize.height = aReflowState.mComputedHeight;
+  aDesiredSize.mOverflowArea =
+    nsRect(nsPoint(0, 0), nsSize(aDesiredSize.width, aDesiredSize.height));
+  aStatus = NS_FRAME_COMPLETE;
+
+  return NS_OK;
+}
+
 
 //----------------------------------------------------------------------
 // nsISVGValueObserver methods:
diff -r ae79c58da0da layout/svg/base/src/nsSVGForeignObjectFrame.h
--- a/layout/svg/base/src/nsSVGForeignObjectFrame.h	Thu Jan 25 15:11:32 2007 -0800
+++ b/layout/svg/base/src/nsSVGForeignObjectFrame.h	Thu Jan 25 15:11:35 2007 -0800
@@ -79,6 +79,11 @@ public:
 
   NS_IMETHOD DidSetStyleContext();
 
+  NS_IMETHOD Reflow(nsPresContext*           aPresContext,
+                    nsHTMLReflowMetrics&     aDesiredSize,
+                    const nsHTMLReflowState& aReflowState,
+                    nsReflowStatus&          aStatus);
+
   /**
    * Get the "type" of the frame
    *
diff -r ae79c58da0da layout/svg/base/src/svg.css
--- a/layout/svg/base/src/svg.css	Thu Jan 25 15:11:32 2007 -0800
+++ b/layout/svg/base/src/svg.css	Thu Jan 25 15:11:35 2007 -0800
@@ -72,6 +72,4 @@ foreignObject {
 *|*::-moz-svg-foreign-content {
   display: block !important;
   position: static !important;
-  /* so we don't report overflow that confuses the reflow root code */
-  overflow: -moz-hidden-unscrollable ! important;
 }
