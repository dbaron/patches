From: Ms2ger <ms2ger@gmail.com>

Bug 835439:  Remove support for the table[layout] attribute.  r=dbaron

diff --git a/content/html/content/src/HTMLTableElement.cpp b/content/html/content/src/HTMLTableElement.cpp
--- a/content/html/content/src/HTMLTableElement.cpp
+++ b/content/html/content/src/HTMLTableElement.cpp
@@ -895,22 +895,16 @@ static const nsAttrValue::EnumTable kRul
   { "none",   NS_STYLE_TABLE_RULES_NONE },
   { "groups", NS_STYLE_TABLE_RULES_GROUPS },
   { "rows",   NS_STYLE_TABLE_RULES_ROWS },
   { "cols",   NS_STYLE_TABLE_RULES_COLS },
   { "all",    NS_STYLE_TABLE_RULES_ALL },
   { 0 }
 };
 
-static const nsAttrValue::EnumTable kLayoutTable[] = {
-  { "auto",   NS_STYLE_TABLE_LAYOUT_AUTO },
-  { "fixed",  NS_STYLE_TABLE_LAYOUT_FIXED },
-  { 0 }
-};
-
 
 bool
 HTMLTableElement::ParseAttribute(int32_t aNamespaceID,
                                  nsIAtom* aAttribute,
                                  const nsAString& aValue,
                                  nsAttrValue& aResult)
 {
   /* ignore summary, just a string */
@@ -942,19 +936,16 @@ HTMLTableElement::ParseAttribute(int32_t
     }
     if (aAttribute == nsGkAtoms::bgcolor ||
         aAttribute == nsGkAtoms::bordercolor) {
       return aResult.ParseColor(aValue);
     }
     if (aAttribute == nsGkAtoms::frame) {
       return aResult.ParseEnumValue(aValue, kFrameTable, false);
     }
-    if (aAttribute == nsGkAtoms::layout) {
-      return aResult.ParseEnumValue(aValue, kLayoutTable, false);
-    }
     if (aAttribute == nsGkAtoms::rules) {
       return aResult.ParseEnumValue(aValue, kRulesTable, false);
     }
     if (aAttribute == nsGkAtoms::hspace ||
         aAttribute == nsGkAtoms::vspace) {
       return aResult.ParseIntWithBounds(aValue, 0);
     }
   }
@@ -990,26 +981,16 @@ MapAttributesIntoRule(const nsMappedAttr
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::cellspacing);
     nsCSSValue* borderSpacing = aData->ValueForBorderSpacing();
     if (value && value->Type() == nsAttrValue::eInteger &&
         borderSpacing->GetUnit() == eCSSUnit_Null) {
       borderSpacing->
         SetFloatValue(float(value->GetIntegerValue()), eCSSUnit_Pixel);
     }
   }
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Table)) {
-    const nsAttrValue* value;
-    // layout
-    nsCSSValue* tableLayout = aData->ValueForTableLayout();
-    if (tableLayout->GetUnit() == eCSSUnit_Null) {
-      value = aAttributes->GetAttr(nsGkAtoms::layout);
-      if (value && value->Type() == nsAttrValue::eEnum)
-        tableLayout->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
-    }
-  }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Margin)) {
     // align; Check for enumerated type (it may be another type if
     // illegal)
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
 
     if (value && value->Type() == nsAttrValue::eEnum) {
       if (value->GetEnumValue() == NS_STYLE_TEXT_ALIGN_CENTER ||
           value->GetEnumValue() == NS_STYLE_TEXT_ALIGN_MOZ_CENTER) {
@@ -1117,17 +1098,16 @@ MapAttributesIntoRule(const nsMappedAttr
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(bool)
 HTMLTableElement::IsAttributeMapped(const nsIAtom* aAttribute) const
 {
   static const MappedAttributeEntry attributes[] = {
-    { &nsGkAtoms::layout },
     { &nsGkAtoms::cellpadding },
     { &nsGkAtoms::cellspacing },
     { &nsGkAtoms::border },
     { &nsGkAtoms::width },
     { &nsGkAtoms::height },
     { &nsGkAtoms::hspace },
     { &nsGkAtoms::vspace },
     
