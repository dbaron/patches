From: Ms2ger <ms2ger@gmail.com>

Bug 835439:  Remove support for the table[layout] attribute.  r=dbaron

diff --git a/content/html/content/src/HTMLTableElement.cpp b/content/html/content/src/HTMLTableElement.cpp
--- a/content/html/content/src/HTMLTableElement.cpp
+++ b/content/html/content/src/HTMLTableElement.cpp
@@ -896,22 +896,16 @@ static const nsAttrValue::EnumTable kRul
   { "none",   NS_STYLE_TABLE_RULES_NONE },
   { "groups", NS_STYLE_TABLE_RULES_GROUPS },
   { "rows",   NS_STYLE_TABLE_RULES_ROWS },
   { "cols",   NS_STYLE_TABLE_RULES_COLS },
   { "all",    NS_STYLE_TABLE_RULES_ALL },
   { 0 }
 };
 
-static const nsAttrValue::EnumTable kLayoutTable[] = {
-  { "auto",   NS_STYLE_TABLE_LAYOUT_AUTO },
-  { "fixed",  NS_STYLE_TABLE_LAYOUT_FIXED },
-  { 0 }
-};
-
 
 bool
 HTMLTableElement::ParseAttribute(int32_t aNamespaceID,
                                  nsIAtom* aAttribute,
                                  const nsAString& aValue,
                                  nsAttrValue& aResult)
 {
   /* ignore summary, just a string */
@@ -944,19 +938,16 @@ HTMLTableElement::ParseAttribute(int32_t
     }
     if (aAttribute == nsGkAtoms::bgcolor ||
         aAttribute == nsGkAtoms::bordercolor) {
       return aResult.ParseColor(aValue);
     }
     if (aAttribute == nsGkAtoms::frame) {
       return aResult.ParseEnumValue(aValue, kFrameTable, false);
     }
-    if (aAttribute == nsGkAtoms::layout) {
-      return aResult.ParseEnumValue(aValue, kLayoutTable, false);
-    }
     if (aAttribute == nsGkAtoms::rules) {
       return aResult.ParseEnumValue(aValue, kRulesTable, false);
     }
   }
 
   return nsGenericHTMLElement::ParseBackgroundAttribute(aNamespaceID,
                                                         aAttribute, aValue,
                                                         aResult) ||
@@ -986,26 +977,18 @@ MapAttributesIntoRule(const nsMappedAttr
     nsCSSValue* borderSpacing = aData->ValueForBorderSpacing();
     if (value && value->Type() == nsAttrValue::eInteger &&
         borderSpacing->GetUnit() == eCSSUnit_Null) {
       borderSpacing->
         SetFloatValue(float(value->GetIntegerValue()), eCSSUnit_Pixel);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Table)) {
-    const nsAttrValue* value;
-    // layout
-    nsCSSValue* tableLayout = aData->ValueForTableLayout();
-    if (tableLayout->GetUnit() == eCSSUnit_Null) {
-      value = aAttributes->GetAttr(nsGkAtoms::layout);
-      if (value && value->Type() == nsAttrValue::eEnum)
-        tableLayout->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
-    }
     // cols
-    value = aAttributes->GetAttr(nsGkAtoms::cols);
+    const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::cols);
     if (value) {
       nsCSSValue* cols = aData->ValueForCols();
       if (value->Type() == nsAttrValue::eInteger)
         cols->SetIntValue(value->GetIntegerValue(), eCSSUnit_Integer);
       else // COLS had no value, so it refers to all columns
         cols->SetIntValue(NS_STYLE_TABLE_COLS_ALL, eCSSUnit_Enumerated);
     }
   }
@@ -1094,17 +1077,16 @@ MapAttributesIntoRule(const nsMappedAttr
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(bool)
 HTMLTableElement::IsAttributeMapped(const nsIAtom* aAttribute) const
 {
   static const MappedAttributeEntry attributes[] = {
-    { &nsGkAtoms::layout },
     { &nsGkAtoms::cellpadding },
     { &nsGkAtoms::cellspacing },
     { &nsGkAtoms::cols },
     { &nsGkAtoms::border },
     { &nsGkAtoms::width },
     { &nsGkAtoms::height },
     
     { &nsGkAtoms::bordercolor },
