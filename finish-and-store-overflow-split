From: L. David Baron <dbaron@dbaron.org>

Change FinishAndStoreOverflow API to take two overflow areas.  (Bug 542595)

diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -6088,142 +6088,163 @@ inline PRBool
 IsInlineFrame(nsIFrame *aFrame)
 {
   nsIAtom *type = aFrame->GetType();
   return type == nsGkAtoms::inlineFrame ||
          type == nsGkAtoms::positionedInlineFrame;
 }
 
 void 
-nsIFrame::FinishAndStoreOverflow(nsRect* aOverflowArea, nsSize aNewSize)
+nsIFrame::FinishAndStoreOverflow(nsOverflowAreas& aOverflowAreas,
+                                 nsSize aNewSize)
 {
   // This is now called FinishAndStoreOverflow() instead of 
   // StoreOverflow() because frame-generic ways of adding overflow
   // can happen here, e.g. CSS2 outline and native theme.
-  NS_ASSERTION(aNewSize.width == 0 || aNewSize.height == 0 ||
-               aOverflowArea->Contains(nsRect(nsPoint(0, 0), aNewSize)),
-               "Computed overflow area must contain frame bounds");
+  NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+    NS_ASSERTION(aNewSize.width == 0 || aNewSize.height == 0 ||
+                 aOverflowAreas[otype].Contains(nsRect(nsPoint(0,0), aNewSize)),
+                 "Computed overflow area must contain frame bounds");
+  }
 
   // If we clip our children, clear accumulated overflow area. The
   // children are actually clipped to the padding-box, but since the
   // overflow area should include the entire border-box, just set it to
   // the border-box here.
   const nsStyleDisplay *disp = GetStyleDisplay();
   NS_ASSERTION((disp->mOverflowY == NS_STYLE_OVERFLOW_CLIP) ==
                (disp->mOverflowX == NS_STYLE_OVERFLOW_CLIP),
                "If one overflow is clip, the other should be too");
   if (disp->mOverflowX == NS_STYLE_OVERFLOW_CLIP) {
     // The contents are actually clipped to the padding area 
-    *aOverflowArea = nsRect(nsPoint(0, 0), aNewSize);
+    NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+      aOverflowAreas[otype] = nsRect(nsPoint(0, 0), aNewSize);
+    }
   }
 
   // Overflow area must always include the frame's top-left and bottom-right,
   // even if the frame rect is empty.
   // Pending a real fix for bug 426879, don't do this for inline frames
   // with zero width.
   if (aNewSize.width != 0 || !IsInlineFrame(this)) {
-    aOverflowArea->UnionRectIncludeEmpty(*aOverflowArea,
-                                         nsRect(nsPoint(0, 0), aNewSize));
+    NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+      aOverflowAreas[otype].UnionRectIncludeEmpty(aOverflowAreas[otype],
+                                              nsRect(nsPoint(0, 0), aNewSize));
+    }
   }
 
   // Note that NS_STYLE_OVERFLOW_CLIP doesn't clip the frame background,
   // so we add theme background overflow here so it's not clipped.
   if (!IsBoxWrapped() && IsThemed(disp)) {
     nsRect r(nsPoint(0, 0), aNewSize);
     nsPresContext *presContext = PresContext();
     if (presContext->GetTheme()->
           GetWidgetOverflow(presContext->DeviceContext(), this,
                             disp->mAppearance, &r)) {
-      aOverflowArea->UnionRectIncludeEmpty(*aOverflowArea, r);
-    }
-  }
-  
+      NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+        aOverflowAreas[otype].UnionRectIncludeEmpty(aOverflowAreas[otype], r);
+      }
+    }
+  }
+
+  // REVIEW: Nothing in here should affect scrollable overflow, except
+  // possibly SVG effects.  But I tend to think they shouldn't.
   PRBool hasOutlineOrEffects;
-  *aOverflowArea =
+  aOverflowAreas[eVisualOverflow] =
     ComputeOutlineAndEffectsRect(this, &hasOutlineOrEffects,
-                                 *aOverflowArea, aNewSize, PR_TRUE);
+                                 aOverflowAreas[eVisualOverflow], aNewSize,
+                                 PR_TRUE);
 
   // Absolute position clipping
   PRBool didHaveAbsPosClip = (GetStateBits() & NS_FRAME_HAS_CLIP) != 0;
   nsRect absPosClipRect;
   PRBool hasAbsPosClip = GetAbsPosClipRect(disp, &absPosClipRect, aNewSize);
   if (hasAbsPosClip) {
-    aOverflowArea->IntersectRect(*aOverflowArea, absPosClipRect);
+    NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+      aOverflowAreas[otype].IntersectRect(aOverflowAreas[otype], absPosClipRect);
+    }
     AddStateBits(NS_FRAME_HAS_CLIP);
   } else {
     RemoveStateBits(NS_FRAME_HAS_CLIP);
   }
 
   /* If we're transformed, transform the overflow rect by the current transformation. */
   PRBool hasTransform = IsTransformed();
   if (hasTransform) {
-    Properties().
-      Set(nsIFrame::PreTransformBBoxProperty(), new nsRect(*aOverflowArea));
+    Properties().Set(nsIFrame::PreTransformBBoxProperty(),
+                     new nsRect(aOverflowAreas[eVisualOverflow]));
     /* Since our size might not actually have been computed yet, we need to make sure that we use the
      * correct dimensions by overriding the stored bounding rectangle with the value the caller has
      * ensured us we'll use.
      */
     nsRect newBounds(nsPoint(0, 0), aNewSize);
-    *aOverflowArea = nsDisplayTransform::TransformRect(*aOverflowArea, this, nsPoint(0, 0), &newBounds);
-  }
-
-  PRBool overflowChanged;
-  if (!aOverflowArea->IsExactEqual(nsRect(nsPoint(0, 0), aNewSize))) {
-    overflowChanged = !aOverflowArea->IsExactEqual(GetOverflowRect());
-    SetOverflowRect(*aOverflowArea);
-  }
-  else {
-    if (HasOverflowRect()) {
-      // remove the previously stored overflow area 
-      ClearOverflowRect();
-      overflowChanged = PR_TRUE;
-    } else {
-      overflowChanged = PR_FALSE;
-    }
-  }
-
-  if (overflowChanged) {
+    // REVIEW: Transform affects both overflow areas.
+    NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+      aOverflowAreas[otype] = nsDisplayTransform::TransformRect(aOverflowAreas[otype],
+                                this, nsPoint(0, 0), &newBounds);
+    }
+  }
+
+  PRBool overflowChanged[2];
+  NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+    if (!aOverflowAreas[otype].IsExactEqual(nsRect(nsPoint(0, 0), aNewSize))) {
+      overflowChanged[otype] = !aOverflowAreas[otype].IsExactEqual(GetOverflowRect(otype));
+      SetOverflowRect(otype, aOverflowAreas[otype]);
+    }
+    else {
+      if (HasOverflowRect(otype)) {
+        // remove the previously stored overflow area 
+        ClearOverflowRect(otype);
+        overflowChanged[otype] = PR_TRUE;
+      } else {
+        overflowChanged[otype] = PR_FALSE;
+      }
+    }
+  }
+
+  if (overflowChanged[eVisualOverflow]) {
     if (hasOutlineOrEffects) {
       // When there's an outline or box-shadow or SVG effects,
       // changes to those styles might require repainting of the old and new
       // overflow areas. Repainting of the old overflow area is handled in
       // nsCSSFrameConstructor::DoApplyRenderingChangeToTree in response
       // to nsChangeHint_RepaintFrame. Since the new overflow area is not
       // known at that time, we have to handle it here.
       // If the overflow area hasn't changed, then we don't have to do
       // anything here since repainting the old overflow area was enough.
       // If there is no outline or other effects now, then we don't have
       // to do anything here since removing those styles can't require
       // repainting of areas that weren't in the old overflow area.
-      Invalidate(*aOverflowArea);
+      Invalidate(aOverflowAreas.VisualOverflow());
     } else if (hasAbsPosClip || didHaveAbsPosClip) {
       // If we are (or were) clipped by the 'clip' property, and our
       // overflow area changes, it might be because the clipping changed.
       // The nsChangeHint_RepaintFrame for the style change will only
       // repaint the old overflow area, so if the overflow area has
       // changed (in particular, if it grows), we have to repaint the
       // new area here.
-      Invalidate(*aOverflowArea);
+      Invalidate(aOverflowAreas.VisualOverflow());
     } else if (hasTransform) {
       // When there's a transform, changes to that style might require
       // repainting of the old and new overflow areas in the widget.
       // Repainting of the frame itself will not be required if there's
       // a retained layer, so we can call InvalidateLayer here
       // which will avoid repainting ThebesLayers if possible.
       // nsCSSFrameConstructor::DoApplyRenderingChangeToTree repaints
       // the old overflow area in the widget in response to
       // nsChangeHint_UpdateTransformLayer. But since the new overflow
       // area is not known at that time, we have to handle it here.
       // If the overflow area hasn't changed, then it doesn't matter that
       // we didn't reach here since repainting the old overflow area was enough.
       // If there is no transform now, then the container layer for
       // the transform will go away and the frame contents will change
       // ThebesLayers, forcing it to be invalidated, so it doesn't matter
       // that we didn't reach here.
-      InvalidateLayer(*aOverflowArea, nsDisplayItem::TYPE_TRANSFORM);
+      InvalidateLayer(aOverflowAreas.VisualOverflow(),
+                      nsDisplayItem::TYPE_TRANSFORM);
     }
   }
 }
 
 void
 nsFrame::ConsiderChildOverflow(nsOverflowAreas& aOverflowAreas,
                                nsIFrame* aChildFrame)
 {
@@ -6844,17 +6865,17 @@ nsFrame::DoLayout(nsBoxLayoutState& aSta
       SetSize(nsSize(ourRect.width, ourRect.height));
     }
   }
 
   // Should we do this if IsCollapsed() is true?
   nsSize size(GetSize());
   desiredSize.mOverflowArea.UnionRect(desiredSize.mOverflowArea,
                                       nsRect(nsPoint(0, 0), size));
-  FinishAndStoreOverflow(&desiredSize.mOverflowArea, size);
+  FinishAndStoreOverflow(desiredSize.mOverflowAreas, size);
 
   SyncLayout(aState);
 
   return rv;
 }
 
 nsresult
 nsFrame::BoxReflow(nsBoxLayoutState&        aState,
diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -677,33 +677,34 @@ nsHTMLScrollFrame::ReflowContents(Scroll
 void
 nsHTMLScrollFrame::PlaceScrollArea(const ScrollReflowState& aState,
                                    const nsPoint& aScrollPosition)
 {
   nsIFrame *scrolledFrame = mInner.mScrolledFrame;
   // Set the x,y of the scrolled frame to the correct value
   scrolledFrame->SetPosition(mInner.mScrollPort.TopLeft() - aScrollPosition);
 
-  nsRect scrolledArea;
+  nsOverflowAreas scrolledArea;
   // Preserve the width or height of empty rects
   nsSize portSize = mInner.mScrollPort.Size();
   nsRect scrolledRect = mInner.GetScrolledRectInternal(aState.mContentsOverflowArea, portSize);
-  scrolledArea.UnionRectIncludeEmpty(scrolledRect,
-                                     nsRect(nsPoint(0,0), portSize));
+  scrolledArea[0].UnionRectIncludeEmpty(scrolledRect,
+                                        nsRect(nsPoint(0,0), portSize));
+  scrolledArea[1] = scrolledArea[0];
 
   // Store the new overflow area. Note that this changes where an outline
   // of the scrolled frame would be painted, but scrolled frames can't have
   // outlines (the outline would go on this scrollframe instead).
   // Using FinishAndStoreOverflow is needed so the overflow rect
   // gets set correctly.  It also messes with the overflow rect in the
   // -moz-hidden-unscrollable case, but scrolled frames can't have
   // 'overflow' either.
   // This needs to happen before SyncFrameViewAfterReflow so
   // HasOverflowRect() will return the correct value.
-  scrolledFrame->FinishAndStoreOverflow(&scrolledArea,
+  scrolledFrame->FinishAndStoreOverflow(scrolledArea,
                                         scrolledFrame->GetSize());
 
   // Note that making the view *exactly* the size of the scrolled area
   // is critical, since the view scrolling code uses the size of the
   // scrolled view to clamp scroll requests.
   // Normally the scrolledFrame won't have a view but in some cases it
   // might create its own.
   nsContainerFrame::SyncFrameViewAfterReflow(scrolledFrame->PresContext(),
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2125,20 +2125,22 @@ public:
    */
   nsRect GetVisualOverflowRectRelativeToSelf() const;
 
   /**
    * Store the overflow area in the frame's mOverflow.mDeltas fields or
    * as a frame property in the frame manager so that it can be retrieved
    * later without reflowing the frame.
    */
-  void FinishAndStoreOverflow(nsRect* aOverflowArea, nsSize aNewSize);
+  void FinishAndStoreOverflow(nsOverflowAreas& aOverflowAreas,
+                              nsSize aNewSize);
 
   void FinishAndStoreOverflow(nsHTMLReflowMetrics* aMetrics) {
-    FinishAndStoreOverflow(&aMetrics->mOverflowArea, nsSize(aMetrics->width, aMetrics->height));
+    FinishAndStoreOverflow(aMetrics->mOverflowAreas,
+                           nsSize(aMetrics->width, aMetrics->height));
   }
 
   /**
    * Returns whether the frame has an overflow rect that is different from
    * its border-box.
    */
   PRBool HasVisualOverflowRect() const {
     return mOverflow[eVisualOverflow].mType != NS_FRAME_OVERFLOW_NONE;
diff --git a/layout/tables/nsTableFrame.cpp b/layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp
+++ b/layout/tables/nsTableFrame.cpp
@@ -1987,30 +1987,32 @@ nsTableFrame::AdjustForCollapsingRowsCol
   // collapse the rows and/or row groups as necessary
   // Get the ordered children
   RowGroupArray rowGroups;
   OrderRowGroups(rowGroups);
 
   nsTableFrame* firstInFlow = static_cast<nsTableFrame*> (GetFirstInFlow());
   nscoord width = firstInFlow->GetCollapsedWidth(aBorderPadding);
   nscoord rgWidth = width - 2 * GetCellSpacingX();
-  nsRect overflowArea(0, 0, 0, 0);
+  nsOverflowAreas overflow;
   // Walk the list of children
   for (PRUint32 childX = 0; childX < rowGroups.Length(); childX++) {
     nsTableRowGroupFrame* rgFrame = rowGroups[childX];
     NS_ASSERTION(rgFrame, "Must have row group frame here");
     yTotalOffset += rgFrame->CollapseRowGroupIfNecessary(yTotalOffset, rgWidth);
-    ConsiderChildOverflow(overflowArea, rgFrame);
+    ConsiderChildOverflow(overflow, rgFrame);
   }
 
   aDesiredSize.height -= yTotalOffset;
   aDesiredSize.width   = width;
-  overflowArea.UnionRect(nsRect(0, 0, aDesiredSize.width, aDesiredSize.height),
-                         overflowArea);
-  FinishAndStoreOverflow(&overflowArea,
+  NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+    nsRect bounds(0, 0, aDesiredSize.width, aDesiredSize.height);
+    overflow[otype].UnionRect(overflow[otype], bounds);
+  }
+  FinishAndStoreOverflow(overflow,
                          nsSize(aDesiredSize.width, aDesiredSize.height));
 }
 
 
 nscoord
 nsTableFrame::GetCollapsedWidth(nsMargin aBorderPadding)
 {
   NS_ASSERTION(!GetPrevInFlow(), "GetCollapsedWidth called on next in flow");
@@ -3009,25 +3011,23 @@ void ResizeCells(nsTableFrame& aTableFra
     groupDesiredSize.mOverflowArea = nsRect(0, 0, groupDesiredSize.width,
                                       groupDesiredSize.height);
     nsTableRowFrame* rowFrame = rgFrame->GetFirstRow();
     while (rowFrame) {
       rowFrame->DidResize();
       rgFrame->ConsiderChildOverflow(groupDesiredSize.mOverflowArea, rowFrame);
       rowFrame = rowFrame->GetNextRow();
     }
-    rgFrame->FinishAndStoreOverflow(&groupDesiredSize.mOverflowArea,
-                                    nsSize(groupDesiredSize.width, groupDesiredSize.height));
+    rgFrame->FinishAndStoreOverflow(&groupDesiredSize);
     // make the coordinates of |desiredSize.mOverflowArea| incorrect
     // since it's about to go away:
     groupDesiredSize.mOverflowArea.MoveBy(rgFrame->GetPosition());
     tableDesiredSize.mOverflowArea.UnionRect(tableDesiredSize.mOverflowArea, groupDesiredSize.mOverflowArea);
   }
-  aTableFrame.FinishAndStoreOverflow(&tableDesiredSize.mOverflowArea,
-                                     nsSize(tableDesiredSize.width, tableDesiredSize.height));
+  aTableFrame.FinishAndStoreOverflow(&tableDesiredSize);
 }
 
 void
 nsTableFrame::DistributeHeightToRows(const nsHTMLReflowState& aReflowState,
                                      nscoord                  aAmount)
 {
   nscoord cellSpacingY = GetCellSpacingY();
 
diff --git a/layout/tables/nsTableRowFrame.cpp b/layout/tables/nsTableRowFrame.cpp
--- a/layout/tables/nsTableRowFrame.cpp
+++ b/layout/tables/nsTableRowFrame.cpp
@@ -1276,16 +1276,17 @@ nsTableRowFrame::CollapseRowIfNecessary(
           cellFrame->InvalidateFrameSubtree();
         }
         
         cellFrame->SetRect(cRect);
 
         // XXXbz This looks completely bogus in the cases when we didn't
         // collapse the cell!
         nsRect cellOverflow = nsRect(0, 0, cRect.width, cRect.height);
+        // FIXME
         cellFrame->FinishAndStoreOverflow(&cellOverflow, nsSize(cRect.width,
                                               cRect.height));
         nsTableFrame::RePositionViews(cellFrame);
         ConsiderChildOverflow(overflowArea, cellFrame);
                 
         if (aRowOffset == 0) {
           nsTableFrame::InvalidateFrame(cellFrame, oldCellRect,
                                         oldCellOverflowRect, PR_FALSE);
@@ -1293,16 +1294,17 @@ nsTableRowFrame::CollapseRowIfNecessary(
       }
       kidFrame = iter.Next(); // Get the next child
     }
   }
 
   SetRect(rowRect);
   overflowArea.UnionRect(nsRect(0,0,rowRect.width, rowRect.height),
                          overflowArea);
+  // FIXME
   FinishAndStoreOverflow(&overflowArea, nsSize(rowRect.width,
                                               rowRect.height));
 
   nsTableFrame::RePositionViews(this);
   nsTableFrame::InvalidateFrame(this, oldRect, oldOverflowRect, PR_FALSE);
   return shift;
 }
 
diff --git a/layout/tables/nsTableRowGroupFrame.cpp b/layout/tables/nsTableRowGroupFrame.cpp
--- a/layout/tables/nsTableRowGroupFrame.cpp
+++ b/layout/tables/nsTableRowGroupFrame.cpp
@@ -882,16 +882,17 @@ nsTableRowGroupFrame::CollapseRowGroupIf
 
   if (aYTotalOffset != 0) {
     InvalidateFrameSubtree();
   }
   
   SetRect(groupRect);
   overflowArea.UnionRect(nsRect(0, 0, groupRect.width, groupRect.height),
                          overflowArea);
+  // FIXME
   FinishAndStoreOverflow(&overflowArea, nsSize(groupRect.width,
                                               groupRect.height));
   nsTableFrame::RePositionViews(this);
   nsTableFrame::InvalidateFrame(this, oldGroupRect, oldGroupOverflowRect,
                                 PR_FALSE);
 
   return yGroupOffset;
 }
