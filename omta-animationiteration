From: L. David Baron <dbaron@dbaron.org>

Bug 822891:  Make animationiteration events fire when we're running off-main-thread animations and throttling style changes.

diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -166,27 +166,38 @@ ElementAnimations::EnsureStyleRuleFor(Ti
   // of animation behaviour (the styles of the animation disappear, or the fill
   // mode behaviour). This loop checks for any finishing animations and forces
   // the style recalculation if we find any.
   if (aIsThrottled) {
     for (uint32_t animIdx = mAnimations.Length(); animIdx-- != 0; ) {
       ElementAnimation &anim = mAnimations[animIdx];
 
       if (anim.mProperties.Length() == 0 ||
-          anim.mIterationDuration.ToMilliseconds() <= 0.0 ||
-          anim.IsPaused()) {
+          anim.mIterationDuration.ToMilliseconds() <= 0.0) {
         continue;
       }
 
+      uint32_t oldLastNotification = anim.mLastNotification;
+
+      // We need to call GetPositionInIteration here to populate
+      // aEventsToDispatch.
+      // The ElapsedDurationAt() call here handles pausing.  But:
+      // FIXME: avoid recalculating every time when paused.
+      double positionInIteration =
+        GetPositionInIteration(anim.ElapsedDurationAt(aRefreshTime),
+                               anim.mIterationDuration, anim.mIterationCount,
+                               anim.mDirection, IsForElement(),
+                               &anim, this, &aEventsToDispatch);
+
       // XXX We shouldn't really be using mLastNotification as a general
       // indicator that the animation has finished, it should be reserved for
       // events. If we use it differently in the future this use might need
       // changing.
-      if ((aRefreshTime - anim.mStartTime) / anim.mIterationDuration >= anim.mIterationCount && 
-          anim.mLastNotification != ElementAnimation::LAST_NOTIFICATION_END) {
+      if (anim.mLastNotification == ElementAnimation::LAST_NOTIFICATION_END &&
+          anim.mLastNotification != oldLastNotification) {
         aIsThrottled = false;
         break;
       }
     }
   }
 
   if (aIsThrottled) {
     mStyleRuleRefreshTime = aRefreshTime;
