Handle padding and border correctly for reflow states constructed without a parent (reflow roots, things inside nsIBoxes).  b=366952

diff -r ffdd89fb4d99 layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp	Tue Jan 16 21:09:17 2007 -0800
+++ b/layout/generic/nsFrame.cpp	Tue Jan 16 21:09:20 2007 -0800
@@ -6045,27 +6045,10 @@ nsFrame::BoxReflow(nsBoxLayoutState&    
   // ok now reflow the child into the spacers calculated space
   if (needsReflow) {
 
-    nsMargin border(0,0,0,0);
-    GetBorderAndPadding(border);
-
-
     aDesiredSize.width = 0;
     aDesiredSize.height = 0;
 
-    nsSize size(aWidth, aHeight);
-
     // create a reflow state to tell our child to flow at the given size.
-    if (size.height != NS_INTRINSICSIZE) {
-        size.height -= (border.top + border.bottom);
-        if (size.height < 0)
-          size.height = 0;
-    }
-
-    if (size.width != NS_INTRINSICSIZE) {
-        size.width -= (border.left + border.right);
-        if (size.width < 0)
-          size.width = 0;
-    }
 
     // Construct a bogus parent reflow state so that there's a usable
     // containing block reflow state.
@@ -6092,6 +6075,7 @@ nsFrame::BoxReflow(nsBoxLayoutState&    
     if (parentSize.height != NS_INTRINSICSIZE)
       parentReflowState.mComputedHeight = parentSize.height;
     parentReflowState.mComputedMargin.SizeTo(0, 0, 0, 0);
+    // XXX use box methods
     parentFrame->GetPadding(parentReflowState.mComputedPadding);
     parentFrame->GetBorder(parentReflowState.mComputedBorderPadding);
     parentReflowState.mComputedBorderPadding +=
@@ -6109,10 +6093,18 @@ nsFrame::BoxReflow(nsBoxLayoutState&    
 
     // mComputedWidth and mComputedHeight are content-box, not
     // border-box
-    if (size.width != NS_INTRINSICSIZE)
-      reflowState.mComputedWidth = size.width;
-    if (size.height != NS_INTRINSICSIZE)
-      reflowState.mComputedHeight = size.height;
+    if (aWidth != NS_INTRINSICSIZE) {
+      reflowState.mComputedWidth =
+        aWidth - reflowState.mComputedBorderPadding.LeftRight();
+      if (reflowState.mComputedWidth < 0)
+        reflowState.mComputedWidth = 0;
+    }
+    if (aHeight != NS_INTRINSICSIZE) {
+      reflowState.mComputedHeight =
+        aHeight - reflowState.mComputedBorderPadding.TopBottom();
+      if (reflowState.mComputedHeight < 0)
+        reflowState.mComputedHeight = 0;
+    }
 
     // Box layout calls SetRect before Layout, whereas non-box layout
     // calls SetRect after Reflow.
@@ -6171,8 +6163,10 @@ nsFrame::BoxReflow(nsBoxLayoutState&    
              else {
               if (aDesiredSize.width > aWidth)
               {
-                 reflowState.mComputedWidth = aDesiredSize.width - (border.left + border.right);
-                 reflowState.availableWidth = reflowState.mComputedWidth;
+                 reflowState.mComputedWidth = aDesiredSize.width - reflowState.mComputedBorderPadding.LeftRight();
+                 if (reflowState.mComputedWidth < 0)
+                   reflowState.mComputedWidth = 0;
+                 reflowState.availableWidth = aDesiredSize.width;
                  DidReflow(aPresContext, &reflowState, NS_FRAME_REFLOW_FINISHED);
                  #ifdef DEBUG_REFLOW
                   nsAdaptorAddIndents();
diff -r ffdd89fb4d99 layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp	Tue Jan 16 21:09:17 2007 -0800
+++ b/layout/generic/nsHTMLReflowState.cpp	Tue Jan 16 21:09:20 2007 -0800
@@ -1434,12 +1434,19 @@ nsHTMLReflowState::InitConstraints(nsPre
   // height equal to the available space
   if (nsnull == parentReflowState) {
     // XXXldb This doesn't mean what it used to!
-    mComputedWidth = availableWidth;
-    mComputedHeight = availableHeight;
+    InitOffsets(aContainingBlockWidth, aBorder, aPadding);
+    // Override mComputedMargin since reflow roots start from the
+    // frame's boundary, which is inside the margin.
     mComputedMargin.SizeTo(0, 0, 0, 0);
-    mComputedPadding.SizeTo(0, 0, 0, 0);
-    mComputedBorderPadding.SizeTo(0, 0, 0, 0);
     mComputedOffsets.SizeTo(0, 0, 0, 0);
+
+    mComputedWidth = availableWidth - mComputedBorderPadding.LeftRight();
+    if (mComputedWidth < 0)
+      mComputedWidth = 0;
+    mComputedHeight = availableHeight - mComputedBorderPadding.TopBottom();
+    if (mComputedHeight < 0)
+      mComputedHeight = 0;
+
     mComputedMinWidth = mComputedMinHeight = 0;
     mComputedMaxWidth = mComputedMaxHeight = NS_UNCONSTRAINEDSIZE;
   } else {
