From: L. David Baron <dbaron@dbaron.org>

Convert nsIFrame APIs from having a single overflow rect to having two distinct overflow rects.  (Bug 542595)

diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -4381,58 +4381,59 @@ nsIFrame::GetRelativeOffset(const nsStyl
     if (offsets) {
       return *offsets;
     }
   }
   return nsPoint(0,0);
 }
 
 nsRect
-nsIFrame::GetOverflowRect() const
+nsIFrame::GetOverflowRect(OverflowType aType) const
 {
   // Note that in some cases the overflow area might not have been
   // updated (yet) to reflect any outline set on the frame or the area
   // of child frames. That's OK because any reflow that updates these
   // areas will invalidate the appropriate area, so any (mis)uses of
   // this method will be fixed up.
 
-  if (mOverflow.mType == NS_FRAME_OVERFLOW_LARGE) {
+  if (mOverflow[aType].mType == NS_FRAME_OVERFLOW_LARGE) {
     // there is an overflow rect, and it's not stored as deltas but as
     // a separately-allocated rect
-    return *const_cast<nsIFrame*>(this)->GetOverflowAreaProperty(PR_FALSE);
+    return *const_cast<nsIFrame*>(this)->
+             GetOverflowAreaProperty(aType,PR_FALSE);
   }
 
   // Calculate the rect using deltas from the frame's border rect.
   // Note that the mOverflow.mDeltas fields are unsigned, but we will often
   // need to return negative values for the left and top, so take care
   // to cast away the unsigned-ness.
-  return nsRect(-(PRInt32)mOverflow.mDeltas.mLeft,
-                -(PRInt32)mOverflow.mDeltas.mTop,
-                mRect.width + mOverflow.mDeltas.mRight +
-                              mOverflow.mDeltas.mLeft,
-                mRect.height + mOverflow.mDeltas.mBottom +
-                               mOverflow.mDeltas.mTop);
+  return nsRect(-(PRInt32)mOverflow[aType].mDeltas.mLeft,
+                -(PRInt32)mOverflow[aType].mDeltas.mTop,
+                mRect.width + mOverflow[aType].mDeltas.mRight +
+                              mOverflow[aType].mDeltas.mLeft,
+                mRect.height + mOverflow[aType].mDeltas.mBottom +
+                               mOverflow[aType].mDeltas.mTop);
 }
 
 nsRect
-nsIFrame::GetOverflowRectRelativeToParent() const
-{
-  return GetOverflowRect() + mRect.TopLeft();
-}
-  
+nsIFrame::GetScrollableOverflowRectRelativeToParent() const
+{
+  return GetScrollableOverflowRect() + mRect.TopLeft();
+}
+
 nsRect
-nsIFrame::GetOverflowRectRelativeToSelf() const
+nsIFrame::GetVisualOverflowRectRelativeToSelf() const
 {
   if (IsTransformed()) {
     nsRect* preTransformBBox = static_cast<nsRect*>
       (Properties().Get(PreTransformBBoxProperty()));
     if (preTransformBBox)
       return *preTransformBBox;
   }
-  return GetOverflowRect();
+  return GetVisualOverflowRect();
 }
 
 void
 nsFrame::CheckInvalidateSizeChange(nsHTMLReflowMetrics& aNewDesiredSize)
 {
   nsIFrame::CheckInvalidateSizeChange(mRect, GetOverflowRect(),
       nsSize(aNewDesiredSize.width, aNewDesiredSize.height));
 }
@@ -4536,17 +4537,17 @@ nsIFrame::CheckInvalidateSizeChange(cons
 #define MAX_FRAME_DEPTH (MAX_REFLOW_DEPTH+4)
 
 PRBool
 nsFrame::IsFrameTreeTooDeep(const nsHTMLReflowState& aReflowState,
                             nsHTMLReflowMetrics& aMetrics)
 {
   if (aReflowState.mReflowDepth >  MAX_FRAME_DEPTH) {
     mState |= NS_FRAME_TOO_DEEP_IN_FRAME_TREE;
-    ClearOverflowRect();
+    ClearOverflowRects();
     aMetrics.width = 0;
     aMetrics.height = 0;
     aMetrics.ascent = 0;
     aMetrics.mCarriedOutBottomMargin.Zero();
     aMetrics.mOverflowArea.x = 0;
     aMetrics.mOverflowArea.y = 0;
     aMetrics.mOverflowArea.width = 0;
     aMetrics.mOverflowArea.height = 0;
@@ -5964,84 +5965,98 @@ nsFrame::ChildIsDirty(nsIFrame* aChild)
 #ifdef ACCESSIBILITY
 already_AddRefed<nsAccessible>
 nsFrame::CreateAccessible()
 {
   return nsnull;
 }
 #endif
 
-NS_DECLARE_FRAME_PROPERTY(OverflowAreaProperty, nsIFrame::DestroyRect)
+// A hand-rolled NS_DECLARE_FRAME_PROPERTY:
+static const FramePropertyDescriptor*
+OverflowAreaProperty(nsIFrame::OverflowType aType)
+{
+  static NS_PROPERTY_DESCRIPTOR_CONST FramePropertyDescriptor descriptors[2] = {
+    { nsIFrame::DestroyRect, nsnull },
+    { nsIFrame::DestroyRect, nsnull },
+  };
+  return &descriptors[aType];
+}
 
 void
-nsIFrame::ClearOverflowRect()
-{
-  Properties().Delete(OverflowAreaProperty());
-  mOverflow.mType = NS_FRAME_OVERFLOW_NONE;
+nsIFrame::ClearOverflowRects()
+{
+  for (PRUint32 i = 0; i < 2; ++i) {
+    OverflowType type = OverflowType(i);
+    Properties().Delete(OverflowAreaProperty(type));
+    mOverflow[type].mType = NS_FRAME_OVERFLOW_NONE;
+  }
 }
 
 /** Create or retrieve the previously stored overflow area, if the frame does 
  * not overflow and no creation is required return nsnull.
  * @param aCreateIfNecessary  create a new nsRect for the overflow area
  * @return pointer to the overflow area rectangle 
  */
 nsRect*
-nsIFrame::GetOverflowAreaProperty(PRBool aCreateIfNecessary) 
-{
-  if (!((mOverflow.mType == NS_FRAME_OVERFLOW_LARGE) ||
+nsIFrame::GetOverflowAreaProperty(OverflowAreaType aType,
+                                  PRBool aCreateIfNecessary) 
+{
+  if (!((mOverflow[aType].mType == NS_FRAME_OVERFLOW_LARGE) ||
         aCreateIfNecessary)) {
     return nsnull;
   }
 
   FrameProperties props = Properties();
-  void *value = props.Get(OverflowAreaProperty());
+  void *value = props.Get(OverflowAreaProperty(aType));
 
   if (value) {
     return (nsRect*)value;  // the property already exists
   } else if (aCreateIfNecessary) {
     // The property isn't set yet, so allocate a new rect, set the property,
     // and return the newly allocated rect
     nsRect*  overflow = new nsRect(0, 0, 0, 0);
-    props.Set(OverflowAreaProperty(), overflow);
+    props.Set(OverflowAreaProperty(aType), overflow);
     return overflow;
   }
 
   NS_NOTREACHED("Frame abuses GetOverflowAreaProperty()");
   return nsnull;
 }
 
 /** Set the overflowArea rect, storing it as deltas or a separate rect
  * depending on its size in relation to the primary frame rect.
  */
 void
-nsIFrame::SetOverflowRect(const nsRect& aRect)
+nsIFrame::SetOverflowRect(OverflowType aType,
+                          const nsRect& aRect)
 {
   PRUint32 l = -aRect.x, // left edge: positive delta is leftwards
            t = -aRect.y, // top: positive is upwards
            r = aRect.XMost() - mRect.width, // right: positive is rightwards
            b = aRect.YMost() - mRect.height; // bottom: positive is downwards
   if (l <= NS_FRAME_OVERFLOW_DELTA_MAX &&
       t <= NS_FRAME_OVERFLOW_DELTA_MAX &&
       r <= NS_FRAME_OVERFLOW_DELTA_MAX &&
       b <= NS_FRAME_OVERFLOW_DELTA_MAX &&
       (l | t | r | b) != 0) {
     // It's a "small" overflow area so we store the deltas for each edge
     // directly in the frame, rather than allocating a separate rect.
     // Note that we do NOT store in this way if *all* the deltas are zero,
     // as that would be indistinguishable from the complete absence of
     // an overflow rect.
-    Properties().Delete(OverflowAreaProperty());
-    mOverflow.mDeltas.mLeft   = l;
-    mOverflow.mDeltas.mTop    = t;
-    mOverflow.mDeltas.mRight  = r;
-    mOverflow.mDeltas.mBottom = b;
+    Properties().Delete(OverflowAreaProperty(aType));
+    mOverflow[aType].mDeltas.mLeft   = l;
+    mOverflow[aType].mDeltas.mTop    = t;
+    mOverflow[aType].mDeltas.mRight  = r;
+    mOverflow[aType].mDeltas.mBottom = b;
   } else {
     // it's a large overflow area that we need to store as a property
-    mOverflow.mType = NS_FRAME_OVERFLOW_LARGE;
-    nsRect* overflowArea = GetOverflowAreaProperty(PR_TRUE); 
+    mOverflow[aType].mType = NS_FRAME_OVERFLOW_LARGE;
+    nsRect* overflowArea = GetOverflowAreaProperty(aType, PR_TRUE); 
     NS_ASSERTION(overflowArea, "should have created rect");
     *overflowArea = aRect;
   }
 }
 
 inline PRBool
 IsInlineFrame(nsIFrame *aFrame)
 {
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -769,42 +769,41 @@ public:
    * Bounding rect of the frame. The values are in app units, and the origin is
    * relative to the upper-left of the geometric parent. The size includes the
    * content area, borders, and padding.
    *
    * Note: moving or sizing the frame does not affect the view's size or
    * position.
    */
   nsRect GetRect() const { return mRect; }
-  nsPoint GetPosition() const { return nsPoint(mRect.x, mRect.y); }
-  nsSize GetSize() const { return nsSize(mRect.width, mRect.height); }
+  nsPoint GetPosition() const { return mRect.TopLeft(); }
+  nsSize GetSize() const { return mRect.Size(); }
 
   /**
    * When we change the size of the frame's border-box rect, we may need to
    * reset the overflow rect if it was previously stored as deltas.
    * (If it is currently a "large" overflow and could be re-packed as deltas,
    * we don't bother as the cost of the allocation has already been paid.)
    */
   void SetRect(const nsRect& aRect) {
-    if (HasOverflowRect() && mOverflow.mType != NS_FRAME_OVERFLOW_LARGE) {
-      nsRect r = GetOverflowRect();
+    if ((HasVisualOverflowRect() &&
+         mOverflow[eVisualOverflow].mType != NS_FRAME_OVERFLOW_LARGE) ||
+        (HasScrollableOverflowRect() &&
+         mOverflow[eScrollableOverflow].mType != NS_FRAME_OVERFLOW_LARGE)) {
+      nsRect vis = GetVisualOverflowRect();
+      nsRect scr = GetScrollableOverflowRect();
       mRect = aRect;
-      SetOverflowRect(r);
+      SetOverflowRect(eVisualOverflow, vis);
+      SetOverflowRect(eScrollableOverflow, scr);
     } else {
       mRect = aRect;
     }
   }
   void SetSize(const nsSize& aSize) {
-    if (HasOverflowRect() && mOverflow.mType != NS_FRAME_OVERFLOW_LARGE) {
-      nsRect r = GetOverflowRect();
-      mRect.SizeTo(aSize);
-      SetOverflowRect(r);
-    } else {
-      mRect.SizeTo(aSize);
-    }
+    SetRect(nsRect(mRect.TopLeft(), aSize));
   }
   void SetPosition(const nsPoint& aPt) { mRect.MoveTo(aPt); }
 
   /**
    * Return frame's computed offset due to relative positioning
    */
   nsPoint GetRelativeOffset(const nsStyleDisplay* aDisplay = nsnull) const;
 
@@ -2042,95 +2041,111 @@ public:
    * Invalidate the entire frame subtree for this frame. Invalidates this
    * frame's overflow rect, and also ensures that all ThebesLayer children
    * of ContainerLayers associated with frames in this subtree are
    * completely invalidated.
    */
   void InvalidateFrameSubtree();
 
   /**
-   * Invalidate the overflow area for this frame. Invalidates this
-   * frame's overflow rect. Does not necessarily cause ThebesLayers for
-   * descendant frames to be repainted; only this frame can be relied on
-   * to be repainted.
+   * Invalidates this frame's visual overflow rect. Does not necessarily
+   * cause ThebesLayers for descendant frames to be repainted; only this
+   * frame can be relied on to be repainted.
    */
   void InvalidateOverflowRect();
 
   /**
-   * Computes a rect that encompasses everything that might be painted by
+   * Returns a rect that encompasses everything that might be painted by
    * this frame.  This includes this frame, all its descendent frames, this
    * frame's outline, and descentant frames' outline, but does not include
    * areas clipped out by the CSS "overflow" and "clip" properties.
    *
-   * HasOverflowRect() (below) will return PR_TRUE when this overflow rect
-   * has been explicitly set, even if it matches mRect.
+   * HasVisualOverflowRect() (below) will return PR_TRUE when this
+   * overflow rect has been explicitly set, even if it matches mRect.
    * XXX Note: because of a space optimization using the formula above,
    * during reflow this function does not give accurate data if
    * FinishAndStoreOverflow has been called but mRect hasn't yet been
    * updated yet.
    *
    * @return the rect relative to this frame's origin, but after
    * CSS transforms have been applied (i.e. not really this frame's coordinate
    * system, and may not contain the frame's border-box, e.g. if there
    * is a CSS transform scaling it down)
    */
-  nsRect GetOverflowRect() const;
+  nsRect GetVisualOverflowRect() const {
+    return GetOverflowRect(eVisualOverflow);
+  }
 
   /**
-   * Computes a rect that encompasses everything that might be painted by
-   * this frame.  This includes this frame, all its descendent frames, this
-   * frame's outline, and descentant frames' outline, but does not include
-   * areas clipped out by the CSS "overflow" and "clip" properties.
+   * Returns a rect that encompasses the area of this frame that the
+   * user should be able to scroll to reach.  This is similar to
+   * GetVisualOverflowRect, but does not include outline or shadows, and
+   * may in the future include some margins.  It does not include areas
+   * clipped out by the CSS "overflow" and "clip" properties.
    *
-   * HasOverflowRect() (below) will return PR_TRUE when this overflow rect
-   * is different from nsRect(0, 0, GetRect().width, GetRect().height).
+   * HasScrollableOverflowRect() (below) will return PR_TRUE when this
+   * overflow rect has been explicitly set, even if it matches mRect.
    * XXX Note: because of a space optimization using the formula above,
    * during reflow this function does not give accurate data if
    * FinishAndStoreOverflow has been called but mRect hasn't yet been
    * updated yet.
    *
+   * @return the rect relative to this frame's origin, but after
+   * CSS transforms have been applied (i.e. not really this frame's coordinate
+   * system, and may not contain the frame's border-box, e.g. if there
+   * is a CSS transform scaling it down)
+   */
+  nsRect GetScrollableOverflowRect() const {
+    return GetOverflowRect(eScrollableOverflow);
+  }
+
+  /**
+   * Same as GetScrollableOverflowRect, except relative to the parent
+   * frame.
+   *
    * @return the rect relative to the parent frame, in the parent frame's
    * coordinate system
    */
-  nsRect GetOverflowRectRelativeToParent() const;
+  nsRect GetScrollableOverflowRectRelativeToParent() const;
 
   /**
-   * Computes a rect that encompasses everything that might be painted by
-   * this frame.  This includes this frame, all its descendent frames, this
-   * frame's outline, and descentant frames' outline, but does not include
-   * areas clipped out by the CSS "overflow" and "clip" properties.
+   * Like GetVisualOverflowRect, except in this frame's
+   * coordinate system (before transforms are applied).
    *
    * @return the rect relative to this frame, before any CSS transforms have
    * been applied, i.e. in this frame's coordinate system
    */
-  nsRect GetOverflowRectRelativeToSelf() const;
+  nsRect GetVisualOverflowRectRelativeToSelf() const;
 
   /**
    * Store the overflow area in the frame's mOverflow.mDeltas fields or
    * as a frame property in the frame manager so that it can be retrieved
    * later without reflowing the frame.
    */
   void FinishAndStoreOverflow(nsRect* aOverflowArea, nsSize aNewSize);
 
   void FinishAndStoreOverflow(nsHTMLReflowMetrics* aMetrics) {
     FinishAndStoreOverflow(&aMetrics->mOverflowArea, nsSize(aMetrics->width, aMetrics->height));
   }
 
   /**
    * Returns whether the frame has an overflow rect that is different from
    * its border-box.
    */
-  PRBool HasOverflowRect() const {
-    return mOverflow.mType != NS_FRAME_OVERFLOW_NONE;
+  PRBool HasVisualOverflowRect() const {
+    return mOverflow[eVisualOverflow].mType != NS_FRAME_OVERFLOW_NONE;
+  }
+  PRBool HasScrollableOverflowRect() const {
+    return mOverflow[eScrollableOverflow].mType != NS_FRAME_OVERFLOW_NONE;
   }
 
   /**
-   * Removes any stored overflow rect from the frame.
+   * Removes any stored overflow rects (visual and scrollable) from the frame.
    */
-  void ClearOverflowRect();
+  void ClearOverflowRects();
 
   /**
    * Determine whether borders should not be painted on certain sides of the
    * frame.
    */
   virtual PRIntn GetSkipSides() const { return 0; }
 
   /** Selection related calls
@@ -2526,19 +2541,19 @@ NS_PTR_TO_INT32(frame->Properties().Get(
    *         the returned value is a 'best effort' in case errors
    *         are encountered rummaging through the frame.
    */
   nsPeekOffsetStruct GetExtremeCaretPosition(PRBool aStart);
 
   /**
    * Same thing as nsFrame::CheckInvalidateSizeChange, but more flexible.  The
    * implementation of this method must not depend on the mRect or
-   * GetOverflowRect() of the frame!  Note that it's safe to assume in this
-   * method that the frame origin didn't change.  If it did, whoever moved the
-   * frame will invalidate as needed anyway.
+   * GetVisualOverflowRect() of the frame!  Note that it's safe to
+   * assume in this method that the frame origin didn't change.  If it
+   * did, whoever moved the frame will invalidate as needed anyway.
    */
   void CheckInvalidateSizeChange(const nsRect& aOldRect,
                                  const nsRect& aOldOverflowRect,
                                  const nsSize& aNewDesiredSize);
 
   /**
    * Get a line iterator for this frame, if supported.
    *
@@ -2566,29 +2581,31 @@ protected:
   nsFrameState     mState;
 
   // When there is an overflow area only slightly larger than mRect,
   // we store a set of four 1-byte deltas from the edges of mRect
   // rather than allocating a whole separate rectangle property.
   // Note that these are unsigned values, all measured "outwards"
   // from the edges of mRect, so /mLeft/ and /mTop/ are reversed from
   // our normal coordinate system.
-  // If mOverflow.mType == NS_FRAME_OVERFLOW_LARGE, then the
+  // If mOverflow[i].mType == NS_FRAME_OVERFLOW_LARGE, then the
   // delta values are not meaningful and the overflow area is stored
   // as a separate rect property.
   union {
     PRUint32  mType;
     struct {
       PRUint8 mLeft;
       PRUint8 mTop;
       PRUint8 mRight;
       PRUint8 mBottom;
     } mDeltas;
-  } mOverflow;
-  
+  } mOverflow[2]; // indexed by OverflowType
+
+  enum OverflowType { eVisualOverflow, eScrollableOverflow }
+
   // Helpers
   /**
    * For frames that have top-level windows (top-level viewports,
    * comboboxes, menupoups) this function will invalidate the window.
    */
   void InvalidateRoot(const nsRect& aDamageRect, PRUint32 aFlags);
 
   /**
@@ -2672,18 +2689,20 @@ protected:
    * @param  aPos See description in nsFrameSelection.h. The following fields are
    *              used by this method: 
    *              Input: mDirection
    *              Output: mResultContent, mContentOffset
    */
    nsresult PeekOffsetParagraph(nsPeekOffsetStruct *aPos);
 
 private:
-  nsRect* GetOverflowAreaProperty(PRBool aCreateIfNecessary = PR_FALSE);
-  void SetOverflowRect(const nsRect& aRect);
+  nsRect* GetOverflowAreaProperty(OverflowType aType,
+                                  PRBool aCreateIfNecessary = PR_FALSE);
+  void SetOverflowRect(OverflowType aType, const nsRect& aRect);
+  nsRect GetOverflowRect(OverflowType aType) const;
   nsPoint GetOffsetToCrossDoc(const nsIFrame* aOther, const PRInt32 aAPD) const;
 
 #ifdef NS_DEBUG
 public:
   // Formerly nsIFrameDebug
   NS_IMETHOD  List(FILE* out, PRInt32 aIndent) const = 0;
   NS_IMETHOD  GetFrameName(nsAString& aResult) const = 0;
   NS_IMETHOD_(nsFrameState)  GetDebugStateBits() const = 0;
