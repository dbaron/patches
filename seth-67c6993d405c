
# HG changeset patch
# User Seth Fowler <seth@mozilla.com>
# Date 1415403612 28800
# Node ID 67c6993d405c89a32e1b76352eb07076b4a8f572
# Parent  0944ccd05e57caa0a5c919fbea6f3ac59a318459
Bug 969406 - Make ImageLoader force painting on FRAME_COMPLETE but not FRAME_CHANGED. r=mattwoodrow

diff --git a/layout/style/ImageLoader.cpp b/layout/style/ImageLoader.cpp
--- a/layout/style/ImageLoader.cpp
+++ b/layout/style/ImageLoader.cpp
@@ -345,44 +345,47 @@ void InvalidateImagesCallback(nsIFrame* 
   nsDisplayItem::Type type = nsDisplayItem::GetDisplayItemTypeFromKey(aItem->GetDisplayItemKey());
   uint8_t flags = nsDisplayItem::GetDisplayItemFlagsForType(type);
 
   if (flags & nsDisplayItem::TYPE_RENDERS_NO_IMAGES) {
     return;
   }
 
   aItem->Invalidate();
+  aFrame->SchedulePaint();
 
   // Update ancestor rendering observers (-moz-element etc)
   nsIFrame *f = aFrame;
   while (f && !f->HasAnyStateBits(NS_FRAME_DESCENDANT_NEEDS_PAINT)) {
     nsSVGEffects::InvalidateDirectRenderingObservers(f);
     f = nsLayoutUtils::GetCrossDocParentFrame(f);
   }
 }
 
 void
-ImageLoader::DoRedraw(FrameSet* aFrameSet)
+ImageLoader::DoRedraw(FrameSet* aFrameSet, bool aForcePaint)
 {
   NS_ASSERTION(aFrameSet, "Must have a frame set");
   NS_ASSERTION(mDocument, "Should have returned earlier!");
 
   FrameSet::size_type length = aFrameSet->Length();
   for (FrameSet::size_type i = 0; i < length; i++) {
     nsIFrame* frame = aFrameSet->ElementAt(i);
 
     if (frame->StyleVisibility()->IsVisible()) {
       if (frame->IsFrameOfType(nsIFrame::eTablePart)) {
         // Tables don't necessarily build border/background display items
         // for the individual table part frames, so IterateRetainedDataFor
         // might not find the right display item.
         frame->InvalidateFrame();
       } else {
         FrameLayerBuilder::IterateRetainedDataFor(frame, InvalidateImagesCallback);
-        frame->SchedulePaint();
+        if (aForcePaint) {
+          frame->SchedulePaint();
+        }
       }
     }
   }
 }
 
 NS_IMPL_ADDREF(ImageLoader)
 NS_IMPL_RELEASE(ImageLoader)
 
@@ -461,17 +464,20 @@ ImageLoader::OnStopFrame(imgIRequest *aR
 
   FrameSet* frameSet = nullptr;
   if (!mRequestToFrameMap.Get(aRequest, &frameSet)) {
     return NS_OK;
   }
 
   NS_ASSERTION(frameSet, "This should never be null!");
 
-  DoRedraw(frameSet);
+  // Since we just finished decoding a frame, we always want to paint, in case
+  // we're now able to paint an image that we couldn't paint before (and hence
+  // that we don't have retained data for).
+  DoRedraw(frameSet, /* aForcePaint = */ true);
 
   return NS_OK;
 }
 
 nsresult
 ImageLoader::FrameChanged(imgIRequest *aRequest)
 {
   if (!mDocument || mInClone) {
@@ -480,17 +486,17 @@ ImageLoader::FrameChanged(imgIRequest *a
 
   FrameSet* frameSet = nullptr;
   if (!mRequestToFrameMap.Get(aRequest, &frameSet)) {
     return NS_OK;
   }
 
   NS_ASSERTION(frameSet, "This should never be null!");
 
-  DoRedraw(frameSet);
+  DoRedraw(frameSet, /* aForcePaint = */ false);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ImageLoader::BlockOnload(imgIRequest* aRequest)
 {
   if (!mDocument) {
diff --git a/layout/style/ImageLoader.h b/layout/style/ImageLoader.h
--- a/layout/style/ImageLoader.h
+++ b/layout/style/ImageLoader.h
@@ -85,17 +85,17 @@ private:
   typedef nsClassHashtable<nsPtrHashKey<nsIFrame>,
                            RequestSet> FrameToRequestMap;
 
   void AddImage(Image* aCSSImage);
   void RemoveImage(Image* aCSSImage);
 
   nsPresContext* GetPresContext();
 
-  void DoRedraw(FrameSet* aFrameSet);
+  void DoRedraw(FrameSet* aFrameSet, bool aForcePaint);
 
   static PLDHashOperator
   SetAnimationModeEnumerator(nsISupports* aKey, FrameSet* aValue,
                              void* aClosure);
 
   static PLDHashOperator
   DeregisterRequestEnumerator(nsISupports* aKey, FrameSet* aValue,
                               void* aClosure);

