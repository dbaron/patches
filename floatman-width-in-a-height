Implement a method on the float manager to get the largest width available within a height (rather than just at a point).  (Bug 25888)

diff --git a/layout/generic/nsFloatManager.cpp b/layout/generic/nsFloatManager.cpp
--- a/layout/generic/nsFloatManager.cpp
+++ b/layout/generic/nsFloatManager.cpp
@@ -224,16 +224,94 @@ nsFloatManager::GetBand(nscoord aYOffset
     }
   }
 
   *aHasFloats = haveFloats;
   nscoord height = (bottom == nscoord_MAX) ? nscoord_MAX : (bottom - top);
   return nsRect(left - mX, top - mY, right - left, height);
 }
 
+void
+nsFloatManager::GetMinBandWidthIn(nscoord aY, nscoord aHeight,
+                                  nscoord aContentAreaWidth,
+                                  nscoord* aLeft, nscoord* aWidth) const
+{
+  NS_ASSERTION(aHeight >= 0, "unexpected height");
+  NS_ASSERTION(aContentAreaWidth >= 0, "unexpected content area width");
+
+  nscoord top = aYOffset + mY;
+  if (top < nscoord_MIN) {
+    NS_NOTREACHED("bad value");
+    top = nscoord_MIN;
+  }
+
+  // If there are no floats at all, or we're below the last one, return
+  // quickly.
+  PRUint32 floatCount = mFloats.Length();
+  if (floatCount == 0 ||
+      (mFloats[floatCount-1].mLeftYMost <= top &&
+       mFloats[floatCount-1].mRightYMost <= top)) {
+    *aLeft = 0;
+    *aWidth = aContentAreaWidth;
+    return;
+  }
+
+  nscoord bottom = top + aHeight;
+  if (bottom < top || bottom > nscoord_MAX) {
+    NS_NOTREACHED("bad value");
+    bottom = nscoord_MAX;
+  }
+  nscoord left = mX;
+  nscoord right = aContentAreaWidth + mX;
+  if (right < left) {
+    NS_NOTREACHED("bad value");
+    right = left;
+  }
+
+  // Walk backwards through the floats until we either hit the front of
+  // the list or we're above |top|.
+  for (PRUint32 i = mFloats.Length(); i > 0; --i) {
+    const FloatInfo &fi = mFloats[i-1];
+    if (fi.mLeftYMost <= top && fi.mRightYMost <= top) {
+      // There aren't any more floats that could intersect this band.
+      break;
+    }
+    if (fi.mRect.IsEmpty()) {
+      // For compatibility, ignore floats with empty rects, even though it
+      // disagrees with the spec.  (We might want to fix this in the
+      // future, though.)
+      continue;
+    }
+    nscoord floatTop = fi.mRect.y, floatBottom = fi.mRect.YMost();
+    NS_ASSERTION(floatBottom >= floatTop, "negative height float?");
+    if (floatTop >= bottom || floatBottom <= top) {
+      // This float does not intersect our space.
+      continue;
+    }
+
+    // Shrink our band's width if needed.
+    if (fi.mFrame->GetStyleDisplay()->mFloats == NS_STYLE_FLOAT_LEFT) {
+      // A left float.
+      nscoord rightEdge = fi.mRect.XMost();
+      if (rightEdge > left) {
+        left = rightEdge;
+      }
+    } else {
+      // A right float.
+      nscoord leftEdge = fi.mRect.x;
+      if (leftEdge < right) {
+        right = leftEdge;
+      }
+    }
+  }
+
+  *aLeft = left - mX;
+  *aWidth = right - left;
+}
+
 nsresult
 nsFloatManager::AddFloat(nsIFrame* aFloatFrame, const nsRect& aMarginRect)
 {
   NS_ASSERTION(aMarginRect.width >= 0, "negative width!");
   NS_ASSERTION(aMarginRect.height >= 0, "negative height!");
 
   FloatInfo info(aFloatFrame, aMarginRect + nsPoint(mX, mY));
 
diff --git a/layout/generic/nsFloatManager.h b/layout/generic/nsFloatManager.h
--- a/layout/generic/nsFloatManager.h
+++ b/layout/generic/nsFloatManager.h
@@ -101,16 +101,36 @@ public:
    *         narrower when floats are present.
    *
    * aY and aAvailSpace are positioned relative to the current translation
    */
   nsRect GetBand(nscoord aY, nscoord aMaxHeight, nscoord aContentAreaWidth,
                  PRBool* aHasFloats) const;
 
   /**
+   * Get information about the widest region that will fit inside of all
+   * the bands between aY and aY+aHeight.
+   *
+   * @param aY [in] top of vertical space within the content area
+   * @param aHeight [in] height of vertical space within the content area
+   * @param aContentAreaWidth [in] the width of the content area (whose left
+   *                          edge must be zero in the current translation)
+   * @param aLeft [out] left edge of content area that can fit next
+   *                    to floats in all bands in the vertical space
+   * @param aWidth [out] width of that content area (may be negative,
+   *                     which means there are some right floats that
+   *                     protrude left of left floats in other bands)
+   *
+   * All parameters are relative to the current translation.
+   */
+  void GetMinBandWidthIn(nscoord aY, nscoord aHeight,
+                         nscoord aContentAreaWidth,
+                         nscoord* aLeft, nscoord* aWidth) const;
+
+  /**
    * Add a float that comes after all floats previously added.  Its top
    * must be even with or below the top of all previous floats.
    *
    * aMarginRect is relative to the current translation.  The caller
    * must ensure aMarginRect.height >= 0 and aMarginRect.width >= 0.
    */
   nsresult AddFloat(nsIFrame* aFloatFrame, const nsRect& aMarginRect);
 
