From: L. David Baron <dbaron@dbaron.org>

Implement a method on the float manager to get the largest width available within a height (rather than just at a point).  (Bug 25888)  r+sr=roc

diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -341,20 +341,21 @@ nsBlockReflowState::GetFloatAvailableSpa
   // Verify that the caller setup the coordinate system properly
   nscoord wx, wy;
   mFloatManager->GetTranslation(wx, wy);
   NS_ASSERTION((wx == mFloatManagerX) && (wy == mFloatManagerY),
                "bad coord system");
 #endif
 
   nsFlowAreaRect result =
-    mFloatManager->GetBand(aY - BorderPadding().top, 
-                           aRelaxHeightConstraint ? nscoord_MAX
-                                                  : mContentArea.height,
-                           mContentArea.width, aState);
+    mFloatManager->GetFlowArea(aY - BorderPadding().top, 
+                               nsFloatManager::BAND_FROM_POINT,
+                               aRelaxHeightConstraint ? nscoord_MAX
+                                                      : mContentArea.height,
+                               mContentArea.width, aState);
   // Keep the width >= 0 for compatibility with nsSpaceManager.
   if (result.mRect.width < 0)
     result.mRect.width = 0;
 
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
     printf("GetAvailableSpace: band=%d,%d,%d,%d hasfloats=%d\n",
diff --git a/layout/generic/nsFloatManager.cpp b/layout/generic/nsFloatManager.cpp
--- a/layout/generic/nsFloatManager.cpp
+++ b/layout/generic/nsFloatManager.cpp
@@ -131,22 +131,21 @@ void nsFloatManager::Shutdown()
       nsMemory::Free(floatManager);
   }
 
   // Disable further caching.
   sCachedFloatManagerCount = -1;
 }
 
 nsFlowAreaRect
-nsFloatManager::GetBand(nscoord aYOffset,
-                        nscoord aMaxHeight,
-                        nscoord aContentAreaWidth,
-                        SavedState* aState) const
+nsFloatManager::GetFlowArea(nscoord aYOffset, BandInfoType aInfoType,
+                            nscoord aHeight, nscoord aContentAreaWidth,
+                            SavedState* aState) const
 {
-  NS_ASSERTION(aMaxHeight >= 0, "unexpected max height");
+  NS_ASSERTION(aHeight >= 0, "unexpected max height");
   NS_ASSERTION(aContentAreaWidth >= 0, "unexpected content area width");
 
   nscoord top = aYOffset + mY;
   if (top < nscoord_MIN) {
     NS_WARNING("bad value");
     top = nscoord_MIN;
   }
 
@@ -161,24 +160,25 @@ nsFloatManager::GetBand(nscoord aYOffset
     floatCount = mFloats.Length();
   }
 
   // If there are no floats at all, or we're below the last one, return
   // quickly.
   if (floatCount == 0 ||
       (mFloats[floatCount-1].mLeftYMost <= top &&
        mFloats[floatCount-1].mRightYMost <= top)) {
-    return nsFlowAreaRect(0, aYOffset, aContentAreaWidth, aMaxHeight, PR_FALSE);
+    return nsFlowAreaRect(0, aYOffset, aContentAreaWidth, aHeight, PR_FALSE);
   }
 
   nscoord bottom;
-  if (aMaxHeight == nscoord_MAX) {
+  if (aHeight == nscoord_MAX) {
+    NS_ASSERTION(aInfoType == BAND_FROM_POINT, "bad height");
     bottom = nscoord_MAX;
   } else {
-    bottom = top + aMaxHeight;
+    bottom = top + aHeight;
     if (bottom < top || bottom > nscoord_MAX) {
       NS_WARNING("bad value");
       bottom = nscoord_MAX;
     }
   }
   nscoord left = mX;
   nscoord right = aContentAreaWidth + mX;
   if (right < left) {
@@ -197,26 +197,33 @@ nsFloatManager::GetBand(nscoord aYOffset
     }
     if (fi.mRect.IsEmpty()) {
       // For compatibility, ignore floats with empty rects, even though it
       // disagrees with the spec.  (We might want to fix this in the
       // future, though.)
       continue;
     }
     nscoord floatTop = fi.mRect.y, floatBottom = fi.mRect.YMost();
-    if (floatTop > top) {
+    if (top < floatTop && aInfoType == BAND_FROM_POINT) {
       // This float is below our band.  Shrink our band's height if needed.
       if (floatTop < bottom) {
         bottom = floatTop;
       }
-    } else if (floatBottom > top) {
+    }
+    // If top == bottom (which happens only with WIDTH_WITHIN_HEIGHT),
+    // we include floats that begin at our 0-height vertical area.  We
+    // need to to this to satisfy the invariant that a
+    // WIDTH_WITHIN_HEIGHT call is at least as narrow on both sides as a
+    // BAND_WITHIN_POINT call beginning at its top.
+    else if (top < floatBottom &&
+             (floatTop < bottom || (floatTop == bottom && top == bottom))) {
       // This float is in our band.
 
       // Shrink our band's height if needed.
-      if (floatBottom < bottom) {
+      if (floatBottom < bottom && aInfoType == BAND_FROM_POINT) {
         bottom = floatBottom;
       }
 
       // Shrink our band's width if needed.
       if (fi.mFrame->GetStyleDisplay()->mFloats == NS_STYLE_FLOAT_LEFT) {
         // A left float.
         nscoord rightEdge = fi.mRect.XMost();
         if (rightEdge > left) {
diff --git a/layout/generic/nsFloatManager.h b/layout/generic/nsFloatManager.h
--- a/layout/generic/nsFloatManager.h
+++ b/layout/generic/nsFloatManager.h
@@ -102,44 +102,57 @@ public:
   /**
    * Returns the current translation from local coordinate space to
    * world coordinate space. This represents the accumulated calls to
    * Translate().
    */
   void GetTranslation(nscoord& aX, nscoord& aY) const { aX = mX; aY = mY; }
 
   /**
-   * Get information about the band containing vertical coordinate |aY|,
-   * but up to at most |aMaxHeight| (which may be nscoord_MAX).  This
-   * will return the tallest rectangle whose top is |aY| and in which
-   * there are no changes in what floats are on the sides of that
-   * rectangle, but will limit the height of the rectangle to
-   * |aMaxHeight|.  The left and right edges of the rectangle give the
-   * area available for line boxes in that space.
+   * Get information about the area available to content that flows
+   * around floats.  Two different types of space can be requested:
+   *   BAND_FROM_POINT: returns the band containing vertical coordinate
+   *     |aY| (though actually with the top truncated to begin at aY),
+   *     but up to at most |aHeight| (which may be nscoord_MAX).
+   *     This will return the tallest rectangle whose top is |aY| and in
+   *     which there are no changes in what floats are on the sides of
+   *     that rectangle, but will limit the height of the rectangle to
+   *     |aHeight|.  The left and right edges of the rectangle give the
+   *     area available for line boxes in that space.  The width of this
+   *     resulting rectangle will not be negative.
+   *   WIDTH_WITHIN_HEIGHT: This returns a rectangle whose top is aY and
+   *     whose height is exactly aHeight.  Its left and right edges give
+   *     the left and right edges of the space that can be used for line
+   *     boxes *throughout* that space.  (It is possible that more
+   *     horizontal space could be used in part of the space if a float
+   *     begins or ends in it.)  The width of the resulting rectangle
+   *     can be negative.
    *
    * @param aY [in] vertical coordinate for top of available space
    *           desired
-   * @param aMaxHeight [in] maximum height of available space desired
+   * @param aHeight [in] see above
    * @param aContentAreaWidth [in] the width of the content area (whose left
    *                          edge must be zero in the current translation)
    * @param aState [in] If null, use the current state, otherwise, do
    *                    computation based only on floats present in the given
    *                    saved state.
    * @return An nsFlowAreaRect whose:
    *           mRect is the resulting rectangle for line boxes.  It will not go
    *             left of 0, nor right of aContentAreaWidth, but will be
    *             narrower when floats are present.
    *          mBandHasFloats is whether there are floats at the sides of the
    *            return value including those that do not reduce the line box
    *            width at all (because they are entirely in the margins)
    *
    * aY and aAvailSpace are positioned relative to the current translation
    */
-  nsFlowAreaRect GetBand(nscoord aY, nscoord aMaxHeight,
-                         nscoord aContentAreaWidth, SavedState* aState) const;
+  enum BandInfoType { BAND_FROM_POINT, WIDTH_WITHIN_HEIGHT };
+  nsFlowAreaRect GetFlowArea(nscoord aY, BandInfoType aInfoType,
+                             nscoord aHeight, nscoord aContentAreaWidth,
+                             SavedState* aState) const;
 
   /**
    * Add a float that comes after all floats previously added.  Its top
    * must be even with or below the top of all previous floats.
    *
    * aMarginRect is relative to the current translation.  The caller
    * must ensure aMarginRect.height >= 0 and aMarginRect.width >= 0.
    */
