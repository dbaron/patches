Implement a method on the float manager to get the largest width available within a height (rather than just at a point).  (Bug 25888)

diff --git a/layout/generic/nsFloatManager.cpp b/layout/generic/nsFloatManager.cpp
--- a/layout/generic/nsFloatManager.cpp
+++ b/layout/generic/nsFloatManager.cpp
@@ -224,16 +224,26 @@ nsFloatManager::GetBand(nscoord aYOffset
     }
   }
 
   *aHasFloats = haveFloats;
   nscoord height = (bottom == nscoord_MAX) ? nscoord_MAX : (bottom - top);
   return nsRect(left - mX, top - mY, right - left, height);
 }
 
+void
+nsFloatManager::GetMinBandWidthIn(nscoord aY, nscoord aHeight,
+                                  nscoord* aLeft, nscoord* aWidth) const
+{
+  NS_ASSERTION(aHeight >= 0, "unexpected height");
+  NS_ASSERTION(aContentAreaWidth >= 0, "unexpected content area width");
+
+  NS_NOTYETIMPLEMENTED("write me");
+}
+
 nsresult
 nsFloatManager::AddFloat(nsIFrame* aFloatFrame, const nsRect& aMarginRect)
 {
   NS_ASSERTION(aMarginRect.width >= 0, "negative width!");
   NS_ASSERTION(aMarginRect.height >= 0, "negative height!");
 
   FloatInfo info(aFloatFrame, aMarginRect + nsPoint(mX, mY));
 
diff --git a/layout/generic/nsFloatManager.h b/layout/generic/nsFloatManager.h
--- a/layout/generic/nsFloatManager.h
+++ b/layout/generic/nsFloatManager.h
@@ -101,16 +101,36 @@ public:
    *         narrower when floats are present.
    *
    * aY and aAvailSpace are positioned relative to the current translation
    */
   nsRect GetBand(nscoord aY, nscoord aMaxHeight, nscoord aContentAreaWidth,
                  PRBool* aHasFloats) const;
 
   /**
+   * Get information about the widest region that will fit inside of all
+   * the bands between aY and aY+aHeight.
+   *
+   * @param aY [in] top of vertical space within the content area
+   * @param aHeight [in] height of vertical space within the content area
+   * @param aContentAreaWidth [in] the width of the content area (whose left
+   *                          edge must be zero in the current translation)
+   * @param aLeft [out] left edge of content area that can fit next
+   *                    to floats in all bands in the vertical space
+   * @param aWidth [out] width of that content area (may be negative,
+   *                     which means there are some right floats that
+   *                     protrude left of left floats in other bands)
+   *
+   * All parameters are relative to the current translation.
+   */
+  void GetMinBandWidthIn(nscoord aY, nscoord aHeight,
+                         nscoord aContentAreaWidth,
+                         nscoord* aLeft, nscoord* aWidth) const;
+
+  /**
    * Add a float that comes after all floats previously added.  Its top
    * must be even with or below the top of all previous floats.
    *
    * aMarginRect is relative to the current translation.  The caller
    * must ensure aMarginRect.height >= 0 and aMarginRect.width >= 0.
    */
   nsresult AddFloat(nsIFrame* aFloatFrame, const nsRect& aMarginRect);
 
