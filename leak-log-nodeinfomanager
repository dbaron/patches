Add leak logging for node info managers that can be added to leak-gauge.  b=414704

diff --git a/content/base/src/nsNodeInfoManager.cpp b/content/base/src/nsNodeInfoManager.cpp
--- a/content/base/src/nsNodeInfoManager.cpp
+++ b/content/base/src/nsNodeInfoManager.cpp
@@ -55,6 +55,16 @@
 #include "plarena.h"
 #include "nsMemory.h"
 #include "nsLayoutStatics.h"
+
+#ifdef MOZ_LOGGING
+// so we can get logging even in release builds
+#define FORCE_PR_LOG 1
+#endif
+#include "prlog.h"
+
+#ifdef PR_LOGGING
+static PRLogModuleInfo* gNodeInfoManagerLeakPRLog;
+#endif
 
 #define NS_SMALL_NODE_ARENA_SIZE \
   (512 * (sizeof(void*)/4))
@@ -258,6 +268,15 @@ nsNodeInfoManager::nsNodeInfoManager()
 {
   nsLayoutStatics::AddRef();
 
+#ifdef PR_LOGGING
+  if (!gNodeInfoManagerLeakPRLog)
+    gNodeInfoManagerLeakPRLog = PR_NewLogModule("NodeInfoManagerLeak");
+
+  if (gNodeInfoManagerLeakPRLog)
+    PR_LOG(gNodeInfoManagerLeakPRLog, PR_LOG_DEBUG,
+           ("NODEINFOMANAGER %p created", this));
+#endif
+
   mNodeInfoHash = PL_NewHashTable(32, GetNodeInfoInnerHashValue,
                                   NodeInfoInnerKeyCompare,
                                   PL_CompareValues, nsnull, nsnull);
@@ -271,6 +290,12 @@ nsNodeInfoManager::~nsNodeInfoManager()
 
   // Note: mPrincipal may be null here if we never got inited correctly
   NS_IF_RELEASE(mPrincipal);
+
+#ifdef PR_LOGGING
+  if (gNodeInfoManagerLeakPRLog)
+    PR_LOG(gNodeInfoManagerLeakPRLog, PR_LOG_DEBUG,
+           ("NODEINFOMANAGER %p destroyed", this));
+#endif
 
   nsLayoutStatics::Release();
 }
@@ -320,6 +345,12 @@ nsNodeInfoManager::Init(nsIDocument *aDo
   mDefaultPrincipal = mPrincipal;
 
   mDocument = aDocument;
+
+#ifdef PR_LOGGING
+  if (gNodeInfoManagerLeakPRLog)
+    PR_LOG(gNodeInfoManagerLeakPRLog, PR_LOG_DEBUG,
+           ("NODEINFOMANAGER %p Init document=%p", this, aDocument));
+#endif
 
   return NS_OK;
 }
diff --git a/tools/footprint/leak-gauge.html b/tools/footprint/leak-gauge.html
--- a/tools/footprint/leak-gauge.html
+++ b/tools/footprint/leak-gauge.html
@@ -48,9 +48,7 @@ pre.output { border: medium solid; paddi
 </style>
 <script type="text/javascript">
 
-function run() {
-    var result = "";
-
+function runfile(file) {
     // A hash of objects (keyed by the first word of the line in the log)
     // that have two public methods, handle_line and dump (to be called using
     // call, above), along with any private data they need.
@@ -121,7 +119,12 @@ function run() {
                         var m = rest.match(/^ (.*)$/);
                         if (!m)
                             throw "URI expected";
-                        this.docs[addr][m[1]] = true;
+                        var uri = m[1];
+                        var doc_info = this.docs[addr];
+                        doc_info[uri] = true;
+                        if ("nim" in doc_info) {
+                            doc_info["nim"][uri] = true;
+                        }
                     }
                 }
             },
@@ -130,7 +133,9 @@ function run() {
                     var doc = this.docs[addr];
                     result += "Leaked document at address " + addr + ".\n";
                     for (var uri in doc) {
-                        result += " ... with URI \"" + uri + "\".\n";
+                        if (uri != "nim") {
+                            result += " ... with URI \"" + uri + "\".\n";
+                        }
                     }
                 }
             },
@@ -181,33 +186,65 @@ function run() {
                 result += 'Leaked ' + len + ' out of ' +
                           this.count + " docshells\n";
             }
+        },
+        "NODEINFOMANAGER": {
+            count: 0,
+            nims: {},
+            handle_line: function(line) {
+                var match = line.match(/^([0-9a-f]*) (\S*)(.*)/);
+                if (match) {
+                    var addr = match[1];
+                    var verb = match[2];
+                    var rest = match[3];
+                    if (verb == "created") {
+                        this.nims[addr] = {};
+                        ++this.count;
+                    } else if (verb == "destroyed") {
+                        delete this.nims[addr];
+                    } else if (verb == "Init") {
+                        var m = rest.match(/^ document=(.*)$/);
+                        if (!m)
+                            throw "document pointer expected";
+                        var nim_info = this.nims[addr];
+                        var doc = m[1];
+                        if (doc != "0") {
+                            var doc_info = handlers["DOCUMENT"].docs[m[1]];
+                            for (var uri in doc_info) {
+                                nim_info[uri] = true;
+                            }
+                            doc_info["nim"] = nim_info;
+                        }
+                    }
+                }
+            },
+            dump: function() {
+                for (var addr in this.nims) {
+                    var nim = this.nims[addr];
+                    result += "Leaked content nodes associated with node info manager at address " + addr + ".\n";
+                    for (var uri in nim) {
+                        result += " ... with document URI \"" + uri + "\".\n";
+                    }
+                }
+            },
+            summary: function() {
+                var len = 0;
+                for (var w in this.nims)
+                    ++len;
+                result += 'Leaked content nodes in ' + len + ' out of ' +
+                          this.count + " documents\n";
+            }
         }
     };
 
-    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+    var result = "Results of processing log " + file.fileName + " :\n";
 
-    const cs = Components.classes;
-    const ifs = Components.interfaces;
-
-    var filePicker = cs["@mozilla.org/filepicker;1"].
-                         createInstance(ifs.nsIFilePicker);
-    filePicker.init(window, "Select NSPR Leak Log", ifs.nsIFilePicker.modeOpen);
-    if (filePicker.show() != ifs.nsIFilePicker.returnOK)
-        return;
-
-    var is = cs["@mozilla.org/network/file-input-stream;1"].
-                 createInstance(ifs.nsIFileInputStream);
-    const PR_RDONLY = 0x01;
-    is.init(filePicker.file, PR_RDONLY, 0, 0);
-    if (!(is instanceof ifs.nsILineInputStream))
-        return;
-    var line = { value: "" };
-    do {
-        var more = is.readLine(line);// yuck, returns false for last valid line
-
+    var contents = file.getAsText("iso-8859-1");
+    var lines = contents.split(/[\r\n]+/);
+    for (var j in lines) {
+        var line = lines[j];
         // strip off initial "-", thread id, and thread pointer; separate
         // first word and rest
-        var matches = line.value.match(/^\-?[0-9]*\[[0-9a-f]*\]: (\S*) (.*)$/);
+        var matches = line.match(/^\-?[0-9]*\[[0-9a-f]*\]: (\S*) (.*)$/);
         if (matches) {
             var handler = matches[1];
             var data = matches[2];
@@ -215,7 +252,7 @@ function run() {
                 handlers[handler].handle_line(data);
             }
         }
-    } while (more);
+    }
 
     for (var handler in handlers)
         handlers[handler].dump();
@@ -224,11 +261,23 @@ function run() {
     result += "Summary:\n";
     for (var handler in handlers)
         handlers[handler].summary();
+    result += "\n";
 
     var out = document.createElement("pre");
     out.className = "output";
     out.appendChild(document.createTextNode(result));
     document.body.appendChild(out);
+}
+
+function run() {
+    var input = document.getElementById("fileinput");
+    var files = input.files;
+    for (var i = 0; i < files.length; ++i)
+        runfile(files[i]);
+    // So the user can process the same filename again (after
+    // overwriting the log), clear the value on the form input so we
+    // will always get an onchange event.
+    input.value = "";
 }
 
 </script>
@@ -249,7 +298,7 @@ to figure out under what conditions the 
 to figure out under what conditions the leak occurs.</p>
 
 <p>The way to create this log is to set the environment variables:</p>
-<pre>  NSPR_LOG_MODULES=DOMLeak:5,DocumentLeak:5,nsDocShellLeak:5
+<pre>  NSPR_LOG_MODULES=DOMLeak:5,DocumentLeak:5,nsDocShellLeak:5,NodeInfoManagerLeak:5
   NSPR_LOG_FILE=nspr.log     <i>(or any other filename of your choice)</i></pre>
 <p>in your shell and then run the program.</p>
 <ul>
@@ -261,19 +310,16 @@ to figure out under what conditions the 
 <pre>    setenv VAR value</pre></li>
 </ul>
 
-<p><strong>This script will not work from a Web page.  It will work only
-in relatively recent Mozilla-based browsers and only when loaded as a
-file from your disk.  You will be asked to give it permission to execute
-arbitrary code.  You should only grant this permission if you trust this
-page.</strong></p>
-
 <p>Once you have this log from a complete run of the browser (you have
 to exit; otherwise it will look like everything leaked), you can load
-this page <em>from your disk</em> (be careful not to overwrite the log
-when starting the browser to load this page) and <a
-href="javascript:run()">enter the filename</a> of the log.  Then you'll
-see the output below, which will tell you which of certain core objects
-leaked and the URLs associated with those objects.</p>
+this page (be careful not to overwrite the log when starting the browser
+to load this page) and enter the filename of the log:</p>
+
+<p><input type="file" id="fileinput" onchange="run()"></p>
+
+<p>Then you'll see the output below, which will tell you which of
+certain core objects leaked and the URLs associated with those
+objects.</p>
 
 </body>
 </html>
diff --git a/tools/footprint/leak-gauge.pl b/tools/footprint/leak-gauge.pl
--- a/tools/footprint/leak-gauge.pl
+++ b/tools/footprint/leak-gauge.pl
@@ -47,7 +47,7 @@
 # to figure out under what conditions the leak occurs.
 #
 # The way to create this log is to set the environment variables:
-#   NSPR_LOG_MODULES=DOMLeak:5,DocumentLeak:5,nsDocShellLeak:5
+#   NSPR_LOG_MODULES=DOMLeak:5,DocumentLeak:5,nsDocShellLeak:5,NodeInfoManagerLeak:5
 #   NSPR_LOG_FILE=nspr.log     (or any other filename of your choice)
 # in your shell and then run the program.
 # * In a Windows command prompt, set environment variables with
@@ -139,7 +139,11 @@ my $handlers = {
                          $verb eq "StartDocumentLoad") {
                     $rest =~ /^ (.*)$/ || die "URI expected";
                     my $uri = $1;
-                    ${${$docs}{$addr}}{$uri} = 1;
+                    my $doc_info = ${$docs}{$addr};
+                    ${$doc_info}{$uri} = 1;
+                    if (exists(${$doc_info}{"nim"})) {
+                        ${$doc_info}{"nim"}{$uri} = 1;
+                    }
                 }
             }
         },
@@ -149,7 +153,7 @@ my $handlers = {
             foreach my $addr (keys(%{$docs})) {
                 print "Leaked document at address $addr.\n";
                 foreach my $uri (keys(%{${$docs}{$addr}})) {
-                    print " ... with URI \"$uri\".\n";
+                    print " ... with URI \"$uri\".\n" unless $uri eq "nim";
                 }
             }
         },
@@ -197,6 +201,51 @@ my $handlers = {
             print 'Leaked ' . keys(%{$shells}) . ' out of ' .
                   ${$self}{count} . " docshells\n";
         }
+    },
+    "NODEINFOMANAGER" => {
+        count => 0,
+        nims => {},
+        handle_line => sub($$) {
+            my ($self, $line) = @_;
+            my $nims = ${$self}{nims};
+            if ($line =~ /^([0-9a-f]*) (\S*)/) {
+                my ($addr, $verb, $rest) = ($1, $2, $');
+                if ($verb eq "created") {
+                    ${$nims}{$addr} = {};
+                    ++${$self}{count};
+                } elsif ($verb eq "destroyed") {
+                    delete ${$nims}{$addr};
+                } elsif ($verb eq "Init") {
+                    $rest =~ /^ document=(.*)$/ ||
+                        die "document pointer expected";
+                    my $doc = $1;
+                    if ($doc ne "") {
+                        my $nim_info = ${$nims}{$addr};
+                        my $doc_info = ${$handlers}{"DOCUMENT"}{docs}{$doc};
+                        foreach my $uri (keys(%{$doc_info})) {
+                            ${$nim_info}{$uri} = 1;
+                        }
+                        ${$doc_info}{"nim"} = $nim_info;
+                    }
+                }
+            }
+        },
+        dump => sub ($) {
+            my ($self) = @_;
+            my $nims = ${$self}{nims};
+            foreach my $addr (keys(%{$nims})) {
+                print "Leaked content nodes associated with node info manager at address $addr.\n";
+                foreach my $uri (keys(%{${$nims}{$addr}})) {
+                    print " ... with document URI \"$uri\".\n";
+                }
+            }
+        },
+        summary => sub($) {
+            my ($self) = @_;
+            my $nims = ${$self}{nims};
+            print 'Leaked content nodes within ' . keys(%{$nims}) . ' out of ' .
+                  ${$self}{count} . " documents\n";
+        }
     }
 };
 
