Add leak logging for node info managers that can be added to leak-gauge.  b=414704

diff --git a/content/base/src/nsNodeInfoManager.cpp b/content/base/src/nsNodeInfoManager.cpp
--- a/content/base/src/nsNodeInfoManager.cpp
+++ b/content/base/src/nsNodeInfoManager.cpp
@@ -55,6 +55,16 @@
 #include "plarena.h"
 #include "nsMemory.h"
 #include "nsLayoutStatics.h"
+
+#ifdef MOZ_LOGGING
+// so we can get logging even in release builds
+#define FORCE_PR_LOG 1
+#endif
+#include "prlog.h"
+
+#ifdef PR_LOGGING
+static PRLogModuleInfo* gNodeInfoManagerLeakPRLog;
+#endif
 
 #define NS_SMALL_NODE_ARENA_SIZE \
   (512 * (sizeof(void*)/4))
@@ -258,6 +268,15 @@ nsNodeInfoManager::nsNodeInfoManager()
 {
   nsLayoutStatics::AddRef();
 
+#ifdef PR_LOGGING
+  if (!gNodeInfoManagerLeakPRLog)
+    gNodeInfoManagerLeakPRLog = PR_NewLogModule("NodeInfoManagerLeak");
+
+  if (gNodeInfoManagerLeakPRLog)
+    PR_LOG(gNodeInfoManagerLeakPRLog, PR_LOG_DEBUG,
+           ("NODEINFOMANAGER %p created", this));
+#endif
+
   mNodeInfoHash = PL_NewHashTable(32, GetNodeInfoInnerHashValue,
                                   NodeInfoInnerKeyCompare,
                                   PL_CompareValues, nsnull, nsnull);
@@ -271,6 +290,12 @@ nsNodeInfoManager::~nsNodeInfoManager()
 
   // Note: mPrincipal may be null here if we never got inited correctly
   NS_IF_RELEASE(mPrincipal);
+
+#ifdef PR_LOGGING
+  if (gNodeInfoManagerLeakPRLog)
+    PR_LOG(gNodeInfoManagerLeakPRLog, PR_LOG_DEBUG,
+           ("NODEINFOMANAGER %p destroyed", this));
+#endif
 
   nsLayoutStatics::Release();
 }
@@ -320,6 +345,12 @@ nsNodeInfoManager::Init(nsIDocument *aDo
   mDefaultPrincipal = mPrincipal;
 
   mDocument = aDocument;
+
+#ifdef PR_LOGGING
+  if (gNodeInfoManagerLeakPRLog)
+    PR_LOG(gNodeInfoManagerLeakPRLog, PR_LOG_DEBUG,
+           ("NODEINFOMANAGER %p Init document=%s", this, aDocument));
+#endif
 
   return NS_OK;
 }
diff --git a/tools/footprint/leak-gauge.pl b/tools/footprint/leak-gauge.pl
--- a/tools/footprint/leak-gauge.pl
+++ b/tools/footprint/leak-gauge.pl
@@ -197,6 +197,48 @@ my $handlers = {
             print 'Leaked ' . keys(%{$shells}) . ' out of ' .
                   ${$self}{count} . " docshells\n";
         }
+    },
+    "NODEINFOMANAGER" => {
+        count => 0,
+        nims => {},
+        handle_line => sub($$) {
+            my ($self, $line) = @_;
+            my $nims = ${$self}{nims};
+            if ($line =~ /^([0-9a-f]*) (\S*)/) {
+                my ($addr, $verb, $rest) = ($1, $2, $');
+                if ($verb eq "created") {
+                    ${$nims}{$addr} = {};
+                    ++${$self}{count};
+                } elsif ($verb eq "destroyed") {
+                    delete ${$nims}{$addr};
+                } elsif ($verb eq "Init") {
+                    $rest =~ /^ document=(.*)$/ ||
+                        die "document pointer expected";
+                    my $doc = $1;
+                    my $nim_info = ${$nims}{$addr};
+                    my $doc_info = ${$handlers}{"DOCUMENT"}{docs}{$doc}{"nim"} = $nim_info;
+                    foreach my $uri (keys(%{$doc_info})) {
+                        ${$nim_info}{$uri} = 1 unless $uri eq "nim";
+                    }
+                }
+            }
+        },
+        dump => sub ($) {
+            my ($self) = @_;
+            my $nims = ${$self}{nims};
+            foreach my $addr (keys(%{$nims})) {
+                print "Leaked content nodes associated with node info manager at address $addr.\n";
+                foreach my $uri (keys(%{${$nims}{$addr}})) {
+                    print " ... with nimument URI \"$uri\".\n";
+                }
+            }
+        },
+        summary => sub($) {
+            my ($self) = @_;
+            my $nims = ${$self}{nims};
+            print 'Leaked content nodes within ' . keys(%{$nims}) . ' out of ' .
+                  ${$self}{count} . " nimuments\n";
+        }
     }
 };
 
