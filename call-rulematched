From: L. David Baron <dbaron@dbaron.org>

Call RuleMatched method on CSS rules when they are matched.  (Bug 522595)  r=bzbarsky

diff --git a/content/svg/content/src/nsSVGElement.cpp b/content/svg/content/src/nsSVGElement.cpp
--- a/content/svg/content/src/nsSVGElement.cpp
+++ b/content/svg/content/src/nsSVGElement.cpp
@@ -721,18 +721,20 @@ NS_IMETHODIMP
 nsSVGElement::WalkContentStyleRules(nsRuleWalker* aRuleWalker)
 {
 #ifdef DEBUG
 //  printf("nsSVGElement(%p)::WalkContentStyleRules()\n", this);
 #endif
   if (!mContentStyleRule)
     UpdateContentStyleRule();
 
-  if (mContentStyleRule)  
+  if (mContentStyleRule) {
+    mContentStyleRule->RuleMatched();
     aRuleWalker->Forward(mContentStyleRule);
+  }
 
   return NS_OK;
 }
 
 // PresentationAttributes-FillStroke
 /* static */ const nsGenericElement::MappedAttributeEntry
 nsSVGElement::sFillStrokeMap[] = {
   { &nsGkAtoms::fill },
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1997,16 +1997,17 @@ static void ContentEnumFunc(nsICSSStyleR
       // for performance, require that every implementation of
       // nsICSSStyleRule return the same pointer for nsIStyleRule (why
       // would anything multiply inherit nsIStyleRule anyway?)
 #ifdef DEBUG
       nsCOMPtr<nsIStyleRule> iRule = do_QueryInterface(aRule);
       NS_ASSERTION(static_cast<nsIStyleRule*>(aRule) == iRule.get(),
                    "Please fix QI so this performance optimization is valid");
 #endif
+      aRule->RuleMatched();
       data->mRuleWalker->Forward(static_cast<nsIStyleRule*>(aRule));
       // nsStyleSet will deal with the !important rule
     }
   }
 }
 
 NS_IMETHODIMP
 nsCSSRuleProcessor::RulesMatching(ElementRuleProcessorData *aData)
@@ -2065,16 +2066,17 @@ static void PseudoEnumFunc(nsICSSStyleRu
     // for performance, require that every implementation of
     // nsICSSStyleRule return the same pointer for nsIStyleRule (why
     // would anything multiply inherit nsIStyleRule anyway?)
 #ifdef DEBUG
     nsCOMPtr<nsIStyleRule> iRule = do_QueryInterface(aRule);
     NS_ASSERTION(static_cast<nsIStyleRule*>(aRule) == iRule.get(),
                  "Please fix QI so this performance optimization is valid");
 #endif
+    aRule->RuleMatched();
     data->mRuleWalker->Forward(static_cast<nsIStyleRule*>(aRule));
     // nsStyleSet will deal with the !important rule
   }
 }
 
 NS_IMETHODIMP
 nsCSSRuleProcessor::RulesMatching(PseudoRuleProcessorData* aData)
 {
diff --git a/layout/style/nsCSSStyleRule.cpp b/layout/style/nsCSSStyleRule.cpp
--- a/layout/style/nsCSSStyleRule.cpp
+++ b/layout/style/nsCSSStyleRule.cpp
@@ -1234,16 +1234,17 @@ public:
   virtual nsCSSSelectorList* Selector(void);
 
   virtual PRUint32 GetLineNumber(void) const;
   virtual void SetLineNumber(PRUint32 aLineNumber);
 
   virtual nsCSSDeclaration* GetDeclaration(void) const;
 
   virtual already_AddRefed<nsIStyleRule> GetImportantRule(void);
+  virtual void RuleMatched();
 
   NS_IMETHOD GetStyleSheet(nsIStyleSheet*& aSheet) const;
   NS_IMETHOD SetStyleSheet(nsICSSStyleSheet* aSheet);
   
   NS_IMETHOD SetParentRule(nsICSSGroupRule* aRule);
 
   virtual nsresult GetCssText(nsAString& aCssText);
   virtual nsresult SetCssText(const nsAString& aCssText);
@@ -1401,16 +1402,21 @@ already_AddRefed<nsIStyleRule> CSSStyleR
     if (!mImportantRule)
       return nsnull;
     NS_ADDREF(mImportantRule);
   }
   NS_ADDREF(mImportantRule);
   return mImportantRule;
 }
 
+/* virtual */ void
+CSSStyleRuleImpl::RuleMatched()
+{
+}
+
 NS_IMETHODIMP
 CSSStyleRuleImpl::GetStyleSheet(nsIStyleSheet*& aSheet) const
 {
 // XXX What about inner, etc.
   return nsCSSRule::GetStyleSheet(aSheet);
 }
 
 NS_IMETHODIMP
diff --git a/layout/style/nsHTMLCSSStyleSheet.cpp b/layout/style/nsHTMLCSSStyleSheet.cpp
--- a/layout/style/nsHTMLCSSStyleSheet.cpp
+++ b/layout/style/nsHTMLCSSStyleSheet.cpp
@@ -138,23 +138,27 @@ NS_IMPL_ISUPPORTS3(HTMLCSSStyleSheetImpl
 NS_IMETHODIMP
 HTMLCSSStyleSheetImpl::RulesMatching(ElementRuleProcessorData* aData)
 {
   nsIContent* content = aData->mContent;
   
   if (content) {
     // just get the one and only style rule from the content's STYLE attribute
     nsICSSStyleRule* rule = content->GetInlineStyleRule();
-    if (rule)
+    if (rule) {
+      rule->RuleMatched();
       aData->mRuleWalker->Forward(rule);
+    }
 
 #ifdef MOZ_SMIL
     rule = content->GetSMILOverrideStyleRule();
-    if (rule)
+    if (rule) {
+      rule->RuleMatched();
       aData->mRuleWalker->Forward(rule);
+    }
 #endif // MOZ_SMIL
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLCSSStyleSheetImpl::RulesMatching(PseudoRuleProcessorData* aData)
diff --git a/layout/style/nsICSSStyleRule.h b/layout/style/nsICSSStyleRule.h
--- a/layout/style/nsICSSStyleRule.h
+++ b/layout/style/nsICSSStyleRule.h
@@ -255,19 +255,20 @@ struct nsCSSSelectorList {
 private: 
   nsCSSSelectorList* Clone(PRBool aDeep) const;
 
   // These are not supported and are not implemented! 
   nsCSSSelectorList(const nsCSSSelectorList& aCopy);
   nsCSSSelectorList& operator=(const nsCSSSelectorList& aCopy); 
 };
 
-// IID for the nsICSSStyleRule interface {00803ccc-66e8-4ec8-a037-45e901bb5304}
-#define NS_ICSS_STYLE_RULE_IID     \
-{0x00803ccc, 0x66e8, 0x4ec8, {0xa0, 0x37, 0x45, 0xe9, 0x01, 0xbb, 0x53, 0x04}}
+// e665007e-5d4a-433a-9056-4310701c08b9
+#define NS_ICSS_STYLE_RULE_IID \
+{ 0xe665007e, 0x5d4a, 0x433a, \
+  { 0x90, 0x56, 0x43, 0x10, 0x70, 0x1c, 0x08, 0xb9 } }
 
 class nsICSSStyleRule : public nsICSSRule {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICSS_STYLE_RULE_IID)
 
   // null for style attribute
   virtual nsCSSSelectorList* Selector(void) = 0;
 
@@ -285,16 +286,22 @@ public:
    * |DeclarationChanged| handles replacing the object in the container
    * sheet or group rule if |aHandleContainer| is true.
    */
   virtual already_AddRefed<nsICSSStyleRule>
     DeclarationChanged(PRBool aHandleContainer) = 0;
 
   virtual already_AddRefed<nsIStyleRule> GetImportantRule(void) = 0;
 
+  /**
+   * The rule processor must call this method before calling
+   * nsRuleWalker::Forward on this rule during rule matching.
+   */
+  virtual void RuleMatched() = 0;
+
   // hooks for DOM rule
   virtual nsresult GetCssText(nsAString& aCssText) = 0;
   virtual nsresult SetCssText(const nsAString& aCssText) = 0;
   virtual nsresult GetParentStyleSheet(nsICSSStyleSheet** aSheet) = 0;
   virtual nsresult GetParentRule(nsICSSGroupRule** aParentRule) = 0;
   virtual nsresult GetSelectorText(nsAString& aSelectorText) = 0;
   virtual nsresult SetSelectorText(const nsAString& aSelectorText) = 0;
 };
