From: L. David Baron <dbaron@dbaron.org>

Add a fallible version of nsCSSValue::Array::Create. (Bug 520234)  r=bzbarsky

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -7992,17 +7992,17 @@ CSSParserImpl::ParseFontSrc(nsCSSValue& 
     if (!ExpectSymbol(',', PR_TRUE))
       break;
   }
 
   if (values.Length() == 0)
     return PR_FALSE;
 
   nsRefPtr<nsCSSValue::Array> srcVals
-    = nsCSSValue::Array::Create(values.Length());
+    = nsCSSValue::Array::Create(mozilla::fallible_t(), values.Length());
   if (!srcVals) {
     mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     return PR_FALSE;
   }
 
   PRUint32 i;
   for (i = 0; i < values.Length(); i++)
     srcVals->Item(i) = values[i];
@@ -8079,17 +8079,17 @@ CSSParserImpl::ParseFontRanges(nsCSSValu
     if (!ExpectSymbol(',', PR_TRUE))
       break;
   }
 
   if (ranges.Length() == 0)
     return PR_FALSE;
 
   nsRefPtr<nsCSSValue::Array> srcVals
-    = nsCSSValue::Array::Create(ranges.Length());
+    = nsCSSValue::Array::Create(mozilla::fallible_t(), ranges.Length());
   if (!srcVals) {
     mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     return PR_FALSE;
   }
 
   for (PRUint32 i = 0; i < ranges.Length(); i++)
     srcVals->Item(i).SetIntValue(ranges[i], eCSSUnit_Integer);
   aValue.SetArrayValue(srcVals, eCSSUnit_Array);
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -44,16 +44,17 @@
 #include "nsCRTGlue.h"
 #include "nsCSSKeywords.h"
 #include "nsCSSProperty.h"
 #include "nsColor.h"
 #include "nsCoord.h"
 #include "nsString.h"
 #include "nsStringBuffer.h"
 #include "nsTArray.h"
+#include "mozilla/mozalloc.h"
 
 class imgIRequest;
 class nsIDocument;
 class nsIPrincipal;
 class nsPresContext;
 class nsIURI;
 
 // Deletes a linked list iteratively to avoid blowing up the stack (bug 456196).
@@ -523,16 +524,21 @@ protected:
 
 struct nsCSSValue::Array {
 
   // return |Array| with reference count of zero
   static Array* Create(size_t aItemCount) {
     return new (aItemCount) Array(aItemCount);
   }
 
+  static Array* Create(const mozilla::fallible_t& aFallible,
+                       size_t aItemCount) {
+    return new (aFallible, aItemCount) Array(aItemCount);
+  }
+
   nsCSSValue& operator[](size_t aIndex) {
     NS_ABORT_IF_FALSE(aIndex < mCount, "out of range");
     return mArray[aIndex];
   }
 
   const nsCSSValue& operator[](size_t aIndex) const {
     NS_ABORT_IF_FALSE(aIndex < mCount, "out of range");
     return mArray[aIndex];
@@ -583,16 +589,23 @@ private:
   // alignment.
   nsCSSValue mArray[1];
 
   void* operator new(size_t aSelfSize, size_t aItemCount) CPP_THROW_NEW {
     NS_ABORT_IF_FALSE(aItemCount > 0, "cannot have a 0 item count");
     return ::operator new(aSelfSize + sizeof(nsCSSValue) * (aItemCount - 1));
   }
 
+  void* operator new(size_t aSelfSize, const mozilla::fallible_t& aFallible,
+                     size_t aItemCount) CPP_THROW_NEW {
+    NS_ABORT_IF_FALSE(aItemCount > 0, "cannot have a 0 item count");
+    return ::operator new(aSelfSize + sizeof(nsCSSValue) * (aItemCount - 1),
+                          aFallible);
+  }
+
   void operator delete(void* aPtr) { ::operator delete(aPtr); }
 
   nsCSSValue* First() { return mArray; }
 
   const nsCSSValue* First() const { return mArray; }
 
 #define CSSVALUE_LIST_FOR_EXTRA_VALUES(var)                                   \
   for (nsCSSValue *var = First() + 1, *var##_end = First() + mCount;          \
