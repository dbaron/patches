From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::IsBoxFrame to IsXULBoxFrame.

Written purely with sed, over .h and .cpp files in layout/.

But with additional manual changes in accessible/.

MozReview-Commit-ID: W0wUPoQsVH

diff --git a/accessible/generic/Accessible.cpp b/accessible/generic/Accessible.cpp
--- a/accessible/generic/Accessible.cpp
+++ b/accessible/generic/Accessible.cpp
@@ -429,19 +429,19 @@ Accessible::NativeState()
 
   nsIFrame *frame = GetFrame();
   if (frame) {
     if (frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
       state |= states::FLOATING;
 
     // XXX we should look at layout for non XUL box frames, but need to decide
     // how that interacts with ARIA.
-    if (HasOwnContent() && mContent->IsXULElement() && frame->IsBoxFrame()) {
+    if (HasOwnContent() && mContent->IsXULElement() && frame->IsXULBoxFrame()) {
       const nsStyleXUL* xulStyle = frame->StyleXUL();
-      if (xulStyle && frame->IsBoxFrame()) {
+      if (xulStyle && frame->IsXULBoxFrame()) {
         // In XUL all boxes are either vertical or horizontal
         if (xulStyle->mBoxOrient == NS_STYLE_BOX_ORIENT_VERTICAL)
           state |= states::VERTICAL;
         else
           state |= states::HORIZONTAL;
       }
     }
   }
diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -580,17 +580,17 @@ RestyleManager::RecomputePosition(nsIFra
   StyleChangeReflow(aFrame, nsChangeHint_NeedReflow);
   return false;
 }
 
 static bool
 HasBoxAncestor(nsIFrame* aFrame)
 {
   for (nsIFrame* f = aFrame; f; f = f->GetParent()) {
-    if (f->IsBoxFrame()) {
+    if (f->IsXULBoxFrame()) {
       return true;
     }
   }
   return false;
 }
 
 void
 RestyleManager::StyleChangeReflow(nsIFrame* aFrame, nsChangeHint aHint)
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -419,17 +419,17 @@ IsFrameForSVG(const nsIFrame* aFrame)
  * (at least, down to the level of descendants which themselves are
  * float-containing blocks -- those will manage the floating status of any
  * lower-level descendents inside them, of course).
  */
 static bool
 ShouldSuppressFloatingOfDescendants(nsIFrame* aFrame)
 {
   return aFrame->IsFrameOfType(nsIFrame::eMathML) ||
-    aFrame->IsBoxFrame() ||
+    aFrame->IsXULBoxFrame() ||
     ::IsFlexOrGridContainer(aFrame);
 }
 
 /**
  * If any children require a block parent, return the first such child.
  * Otherwise return null.
  */
 static nsIContent*
@@ -8292,17 +8292,17 @@ nsCSSFrameConstructor::ContentRemoved(ns
       LAYOUT_PHASE_TEMP_REENTER();
       return rv;
     }
 
     // Undo XUL wrapping if it's no longer needed.
     // (If we're in the XUL block-wrapping situation, parentFrame is the
     // wrapper frame.)
     nsIFrame* grandparentFrame = parentFrame->GetParent();
-    if (grandparentFrame && grandparentFrame->IsBoxFrame() &&
+    if (grandparentFrame && grandparentFrame->IsXULBoxFrame() &&
         (grandparentFrame->GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK) &&
         // check if this frame is the only one needing wrapping
         aChild == AnyKidsNeedBlockParent(parentFrame->PrincipalChildList().FirstChild()) &&
         !AnyKidsNeedBlockParent(childFrame->GetNextSibling())) {
       *aDidReconstruct = true;
       LAYOUT_PHASE_TEMP_EXIT();
       nsresult rv = RecreateFramesForContent(grandparentFrame->GetContent(), true,
                                              aFlags, aDestroyedFramesFor);
@@ -10692,38 +10692,38 @@ nsCSSFrameConstructor::ProcessChildren(n
                                  itemsToConstruct);
     }
   } else {
     ClearLazyBits(aContent->GetFirstChild(), nullptr);
   }
 
   ConstructFramesFromItemList(aState, itemsToConstruct, aFrame, aFrameItems);
 
-  NS_ASSERTION(!aAllowBlockStyles || !aFrame->IsBoxFrame(),
+  NS_ASSERTION(!aAllowBlockStyles || !aFrame->IsXULBoxFrame(),
                "can't be both block and box");
 
   if (haveFirstLetterStyle) {
     WrapFramesInFirstLetterFrame(aFrame, aFrameItems);
   }
   if (haveFirstLineStyle) {
     WrapFramesInFirstLineFrame(aState, aContent, aFrame, nullptr,
                                aFrameItems);
   }
 
   // We might end up with first-line frames that change
   // AnyKidsNeedBlockParent() without changing itemsToConstruct, but that
-  // should never happen for cases whan aFrame->IsBoxFrame().
-  NS_ASSERTION(!haveFirstLineStyle || !aFrame->IsBoxFrame(),
+  // should never happen for cases whan aFrame->IsXULBoxFrame().
+  NS_ASSERTION(!haveFirstLineStyle || !aFrame->IsXULBoxFrame(),
                "Shouldn't have first-line style if we're a box");
-  NS_ASSERTION(!aFrame->IsBoxFrame() ||
+  NS_ASSERTION(!aFrame->IsXULBoxFrame() ||
                itemsToConstruct.AnyItemsNeedBlockParent() ==
                  (AnyKidsNeedBlockParent(aFrameItems.FirstChild()) != nullptr),
                "Something went awry in our block parent calculations");
 
-  if (aFrame->IsBoxFrame() && itemsToConstruct.AnyItemsNeedBlockParent()) {
+  if (aFrame->IsXULBoxFrame() && itemsToConstruct.AnyItemsNeedBlockParent()) {
     // XXXbz we could do this on the FrameConstructionItemList level,
     // no?  And if we cared we could look through the item list
     // instead of groveling through the framelist here..
     nsStyleContext *frameStyleContext = aFrame->StyleContext();
     // Report a warning for non-GC frames, for chrome:
     if (!aFrame->IsGeneratedContentFrame() &&
         mPresShell->GetPresContext()->IsChrome()) {
       nsIContent *badKid = AnyKidsNeedBlockParent(aFrameItems.FirstChild());
@@ -12050,17 +12050,17 @@ nsCSSFrameConstructor::WipeContainingBlo
     return false;
   }
 
   // Before we go and append the frames, we must check for several
   // special situations.
 
   // Situation #1 is a XUL frame that contains frames that are required
   // to be wrapped in blocks.
-  if (aFrame->IsBoxFrame() &&
+  if (aFrame->IsXULBoxFrame() &&
       !(aFrame->GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK) &&
       aItems.AnyItemsNeedBlockParent()) {
     RecreateFramesForContent(aFrame->GetContent(), true,
                              REMOVE_FOR_RECONSTRUCTION, nullptr);
     return true;
   }
 
   nsIFrame* nextSibling = ::GetInsertNextSibling(aFrame, aPrevSibling);
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -1925,17 +1925,17 @@ void nsDisplayList::DeleteAll() {
   while ((item = RemoveBottom()) != nullptr) {
     item->~nsDisplayItem();
   }
 }
 
 static bool
 GetMouseThrough(const nsIFrame* aFrame)
 {
-  if (!aFrame->IsBoxFrame())
+  if (!aFrame->IsXULBoxFrame())
     return false;
 
   const nsIFrame* frame = aFrame;
   while (frame) {
     if (frame->GetStateBits() & NS_FRAME_MOUSE_THROUGH_ALWAYS) {
       return true;
     } else if (frame->GetStateBits() & NS_FRAME_MOUSE_THROUGH_NEVER) {
       return false;
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -180,18 +180,18 @@ InitBoxMetrics(nsIFrame* aFrame, bool aC
   metrics->mBlockAscent = 0;
   metrics->mLastSize.SizeTo(0, 0);
 }
 
 static bool
 IsBoxWrapped(const nsIFrame* aFrame)
 {
   return aFrame->GetParent() &&
-         aFrame->GetParent()->IsBoxFrame() &&
-         !aFrame->IsBoxFrame();
+         aFrame->GetParent()->IsXULBoxFrame() &&
+         !aFrame->IsXULBoxFrame();
 }
 
 // Formerly the nsIFrameDebug interface
 
 #ifdef DEBUG
 static bool gShowFrameBorders = false;
 
 void nsFrame::ShowFrameBorders(bool aEnable)
@@ -489,17 +489,17 @@ IsFontSizeInflationContainer(nsIFrame* a
                    // Given multiple frames for the same node, only the
                    // outer one should be considered a container.
                    // (Important, e.g., for nsSelectsAreaFrame.)
                    (aFrame->GetParent()->GetContent() == content) ||
                    (content && (content->IsAnyOfHTMLElements(nsGkAtoms::option,
                                                              nsGkAtoms::optgroup,
                                                              nsGkAtoms::select) ||
                                 content->IsInNativeAnonymousSubtree()))) &&
-                  !(aFrame->IsBoxFrame() && aFrame->GetParent()->IsBoxFrame());
+                  !(aFrame->IsXULBoxFrame() && aFrame->GetParent()->IsXULBoxFrame());
   NS_ASSERTION(!aFrame->IsFrameOfType(nsIFrame::eLineParticipant) ||
                isInline ||
                // br frames and mathml frames report being line
                // participants even when their position or display is
                // set
                aFrame->GetType() == nsGkAtoms::brFrame ||
                aFrame->IsFrameOfType(nsIFrame::eMathML),
                "line participants must not be containers");
@@ -5876,17 +5876,17 @@ nsFrame::UpdateOverflow()
 {
   MOZ_ASSERT(FrameMaintainsOverflow(),
              "Non-display SVG do not maintain visual overflow rects");
 
   nsRect rect(nsPoint(0, 0), GetSize());
   nsOverflowAreas overflowAreas(rect, rect);
 
   if (!DoesClipChildren() &&
-      !(IsCollapsed() && (IsBoxFrame() || ::IsBoxWrapped(this)))) {
+      !(IsCollapsed() && (IsXULBoxFrame() || ::IsBoxWrapped(this)))) {
     nsLayoutUtils::UnionChildOverflow(this, overflowAreas);
   }
 
   if (FinishAndStoreOverflow(overflowAreas, GetSize())) {
     nsView* view = GetView();
     if (view) {
       uint32_t flags = 0;
       GetLayoutFlags(flags);
diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -5289,17 +5289,17 @@ ScrollFrameHelper::LayoutScrollbars(nsBo
   double res = 1.0;
   if (overlayScrollBarsWithZoom) {
     scrollPortClampingSize = presShell->GetScrollPositionClampingScrollPortSize();
     res = presShell->GetCumulativeResolution();
   }
 
   // place the scrollcorner
   if (mScrollCornerBox || mResizerBox) {
-    NS_PRECONDITION(!mScrollCornerBox || mScrollCornerBox->IsBoxFrame(), "Must be a box frame!");
+    NS_PRECONDITION(!mScrollCornerBox || mScrollCornerBox->IsXULBoxFrame(), "Must be a box frame!");
 
     nsRect r(0, 0, 0, 0);
     if (aContentArea.x != mScrollPort.x || scrollbarOnLeft) {
       // scrollbar (if any) on left
       r.x = aContentArea.x;
       r.width = mScrollPort.x - aContentArea.x;
       NS_ASSERTION(r.width >= 0, "Scroll area should be inside client rect");
     } else {
@@ -5346,34 +5346,34 @@ ScrollFrameHelper::LayoutScrollbars(nsBo
       // otherwise lay out the resizer with an empty rectangle
       nsBoxFrame::LayoutChildAt(aState, mResizerBox, nsRect());
     }
   }
 
   nsPresContext* presContext = mScrolledFrame->PresContext();
   nsRect vRect;
   if (mVScrollbarBox) {
-    NS_PRECONDITION(mVScrollbarBox->IsBoxFrame(), "Must be a box frame!");
+    NS_PRECONDITION(mVScrollbarBox->IsXULBoxFrame(), "Must be a box frame!");
     vRect = mScrollPort;
     if (overlayScrollBarsWithZoom) {
       vRect.height = NSToCoordRound(res * scrollPortClampingSize.height);
     }
     vRect.width = aContentArea.width - mScrollPort.width;
     vRect.x = scrollbarOnLeft ? aContentArea.x : mScrollPort.x + NSToCoordRound(res * scrollPortClampingSize.width);
     if (mHasVerticalScrollbar) {
       nsMargin margin;
       mVScrollbarBox->GetMargin(margin);
       vRect.Deflate(margin);
     }
     AdjustScrollbarRectForResizer(mOuter, presContext, vRect, hasResizer, true);
   }
 
   nsRect hRect;
   if (mHScrollbarBox) {
-    NS_PRECONDITION(mHScrollbarBox->IsBoxFrame(), "Must be a box frame!");
+    NS_PRECONDITION(mHScrollbarBox->IsXULBoxFrame(), "Must be a box frame!");
     hRect = mScrollPort;
     if (overlayScrollBarsWithZoom) {
       hRect.width = NSToCoordRound(res * scrollPortClampingSize.width);
     }
     hRect.height = aContentArea.height - mScrollPort.height;
     hRect.y = mScrollPort.y + NSToCoordRound(res * scrollPortClampingSize.height);
     if (mHasHorizontalScrollbar) {
       nsMargin margin;
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -655,17 +655,17 @@ nsHTMLReflowState::InitResizeFlags(nsPre
   bool dependsOnCBBSize =
     (mStylePosition->BSizeDependsOnContainer(wm) &&
      // FIXME: condition this on not-abspos?
      mStylePosition->BSize(wm).GetUnit() != eStyleUnit_Auto) ||
     mStylePosition->MinBSizeDependsOnContainer(wm) ||
     mStylePosition->MaxBSizeDependsOnContainer(wm) ||
     mStylePosition->OffsetHasPercent(wm.PhysicalSide(eLogicalSideBStart)) ||
     mStylePosition->mOffset.GetBEndUnit(wm) != eStyleUnit_Auto ||
-    frame->IsBoxFrame();
+    frame->IsXULBoxFrame();
 
   if (mStyleText->mLineHeight.GetUnit() == eStyleUnit_Enumerated) {
     NS_ASSERTION(mStyleText->mLineHeight.GetIntValue() ==
                  NS_STYLE_LINE_HEIGHT_BLOCK_HEIGHT,
                  "bad line-height value");
 
     // line-height depends on block bsize
     frame->AddStateBits(NS_FRAME_CONTAINS_RELATIVE_BSIZE);
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2845,17 +2845,17 @@ public:
    * @param  [in, optional] aWithMouse, is this focus query for mouse clicking
    * @return whether the frame is focusable via mouse, kbd or script.
    */
   virtual bool IsFocusable(int32_t *aTabIndex = nullptr, bool aWithMouse = false);
 
   // BOX LAYOUT METHODS
   // These methods have been migrated from nsIBox and are in the process of
   // being refactored. DO NOT USE OUTSIDE OF XUL.
-  bool IsBoxFrame() const
+  bool IsXULBoxFrame() const
   {
     return IsFrameOfType(nsIFrame::eXULBox);
   }
 
   enum Halignment {
     hAlign_Left,
     hAlign_Right,
     hAlign_Center
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -921,31 +921,31 @@ nsBox::BoundsCheck(const nsSize& aMinSiz
                 BoundsCheck(aMinSize.height, aPrefSize.height, aMaxSize.height));
 }
 
 /*static*/ nsIFrame*
 nsBox::GetChildBox(const nsIFrame* aFrame)
 {
   // box layout ends at box-wrapped frames, so don't allow these frames
   // to report child boxes.
-  return aFrame->IsBoxFrame() ? aFrame->PrincipalChildList().FirstChild() : nullptr;
+  return aFrame->IsXULBoxFrame() ? aFrame->PrincipalChildList().FirstChild() : nullptr;
 }
 
 /*static*/ nsIFrame*
 nsBox::GetNextBox(const nsIFrame* aFrame)
 {
   return aFrame->GetParent() &&
-    aFrame->GetParent()->IsBoxFrame() ? aFrame->GetNextSibling() : nullptr;
+    aFrame->GetParent()->IsXULBoxFrame() ? aFrame->GetNextSibling() : nullptr;
 }
 
 /*static*/ nsIFrame*
 nsBox::GetParentBox(const nsIFrame* aFrame)
 {
   return aFrame->GetParent() &&
-    aFrame->GetParent()->IsBoxFrame() ? aFrame->GetParent() : nullptr;
+    aFrame->GetParent()->IsXULBoxFrame() ? aFrame->GetParent() : nullptr;
 }
 
 #ifdef DEBUG_LAYOUT
 nsresult
 nsBox::SetDebug(nsBoxLayoutState& aState, bool aDebug)
 {
     return NS_OK;
 }
diff --git a/layout/xul/nsListBoxBodyFrame.cpp b/layout/xul/nsListBoxBodyFrame.cpp
--- a/layout/xul/nsListBoxBodyFrame.cpp
+++ b/layout/xul/nsListBoxBodyFrame.cpp
@@ -1125,25 +1125,25 @@ nsListBoxBodyFrame::GetFirstItemBox(int3
 {
   if (aCreated)
    *aCreated = false;
 
   // Clear ourselves out.
   mBottomFrame = mTopFrame;
 
   if (mTopFrame) {
-    return mTopFrame->IsBoxFrame() ? mTopFrame : nullptr;
+    return mTopFrame->IsXULBoxFrame() ? mTopFrame : nullptr;
   }
 
   // top frame was cleared out
   mTopFrame = GetFirstFrame();
   mBottomFrame = mTopFrame;
 
   if (mTopFrame && mRowsToPrepend <= 0) {
-    return mTopFrame->IsBoxFrame() ? mTopFrame : nullptr;
+    return mTopFrame->IsXULBoxFrame() ? mTopFrame : nullptr;
   }
 
   // At this point, we either have no frames at all, 
   // or the user has scrolled upwards, leaving frames
   // to be created at the top.  Let's determine which
   // content needs a new frame first.
 
   nsCOMPtr<nsIContent> startContent;
@@ -1163,17 +1163,17 @@ nsListBoxBodyFrame::GetFirstItemBox(int3
   }
 
   if (startContent) {  
     nsIFrame* existingFrame;
     if (!IsListItemChild(this, startContent, &existingFrame)) {
       return GetFirstItemBox(++aOffset, aCreated);
     }
     if (existingFrame) {
-      return existingFrame->IsBoxFrame() ? existingFrame : nullptr;
+      return existingFrame->IsXULBoxFrame() ? existingFrame : nullptr;
     }
 
     // Either append the new frame, or prepend it (at index 0)
     // XXX check here if frame was even created, it may not have been if
     //     display: none was on listitem content
     bool isAppend = mRowsToPrepend <= 0;
     
     nsPresContext* presContext = PresContext();
@@ -1182,17 +1182,17 @@ nsListBoxBodyFrame::GetFirstItemBox(int3
     fc->CreateListBoxContent(this, nullptr, startContent, &topFrame, isAppend);
     mTopFrame = topFrame;
     if (mTopFrame) {
       if (aCreated)
         *aCreated = true;
 
       mBottomFrame = mTopFrame;
 
-      return mTopFrame->IsBoxFrame() ? mTopFrame : nullptr;
+      return mTopFrame->IsXULBoxFrame() ? mTopFrame : nullptr;
     } else
       return GetFirstItemBox(++aOffset, 0);
   }
 
   return nullptr;
 }
 
 //
@@ -1247,20 +1247,20 @@ nsListBoxBodyFrame::GetNextItemBox(nsIFr
     }
   }
 
   if (!result)
     return nullptr;
 
   mBottomFrame = result;
 
-  NS_ASSERTION(!result->IsBoxFrame() || result->GetParent() == this,
+  NS_ASSERTION(!result->IsXULBoxFrame() || result->GetParent() == this,
                "returning frame that is not in childlist");
 
-  return result->IsBoxFrame() ? result : nullptr;
+  return result->IsXULBoxFrame() ? result : nullptr;
 }
 
 bool
 nsListBoxBodyFrame::ContinueReflow(nscoord height) 
 {
 #ifdef ACCESSIBILITY
   if (nsIPresShell::IsAccessibilityActive()) {
     // Create all the frames at once so screen readers and
diff --git a/layout/xul/nsMenuFrame.cpp b/layout/xul/nsMenuFrame.cpp
--- a/layout/xul/nsMenuFrame.cpp
+++ b/layout/xul/nsMenuFrame.cpp
@@ -764,17 +764,17 @@ nsMenuFrame::SetDebug(nsBoxLayoutState& 
 
 nsresult
 nsMenuFrame::SetDebug(nsBoxLayoutState& aState, nsIFrame* aList, bool aDebug)
 {
       if (!aList)
           return NS_OK;
 
       while (aList) {
-        if (aList->IsBoxFrame())
+        if (aList->IsXULBoxFrame())
           aList->SetDebug(aState, aDebug);
 
         aList = aList->GetNextSibling();
       }
 
       return NS_OK;
 }
 #endif
diff --git a/layout/xul/nsSliderFrame.cpp b/layout/xul/nsSliderFrame.cpp
--- a/layout/xul/nsSliderFrame.cpp
+++ b/layout/xul/nsSliderFrame.cpp
@@ -687,17 +687,17 @@ nsSliderFrame::GetScrollbar()
   // if we are in a scrollbar then return the scrollbar's content node
   // if we are not then return ours.
    nsIFrame* scrollbar;
    nsScrollbarButtonFrame::GetParentWithTag(nsGkAtoms::scrollbar, this, scrollbar);
 
    if (scrollbar == nullptr)
        return this;
 
-   return scrollbar->IsBoxFrame() ? scrollbar : this;
+   return scrollbar->IsXULBoxFrame() ? scrollbar : this;
 }
 
 void
 nsSliderFrame::PageUpDown(nscoord change)
 {
   // on a page up or down get our page increment. We get this by getting the scrollbar we are in and
   // asking it for the current position and the page increment. If we are not in a scrollbar we will
   // get the values from our own node.
diff --git a/layout/xul/nsSplitterFrame.cpp b/layout/xul/nsSplitterFrame.cpp
--- a/layout/xul/nsSplitterFrame.cpp
+++ b/layout/xul/nsSplitterFrame.cpp
@@ -274,17 +274,17 @@ nsSplitterFrame::Init(nsIContent*       
   mInner->AddRef();
   mInner->mState = nsSplitterFrameInner::Open;
   mInner->mDragging = false;
 
   // determine orientation of parent, and if vertical, set orient to vertical
   // on splitter content, then re-resolve style
   // XXXbz this is pretty messed up, since this can change whether we should
   // have a frame at all.  This really needs a better solution.
-  if (aParent && aParent->IsBoxFrame()) {
+  if (aParent && aParent->IsXULBoxFrame()) {
     if (!aParent->IsHorizontal()) {
       if (!nsContentUtils::HasNonEmptyAttr(aContent, kNameSpaceID_None,
                                            nsGkAtoms::orient)) {
         aContent->SetAttr(kNameSpaceID_None, nsGkAtoms::orient,
                           NS_LITERAL_STRING("vertical"), false);
         nsStyleContext* parentStyleContext = StyleContext()->GetParent();
         RefPtr<nsStyleContext> newContext = PresContext()->StyleSet()->
           ResolveStyleFor(aContent->AsElement(), parentStyleContext);
@@ -834,17 +834,17 @@ nsSplitterFrameInner::UpdateState()
   State newState = GetState(); 
 
   if (newState == mState) {
     // No change.
     return;
   }
 
   if ((SupportsCollapseDirection(Before) || SupportsCollapseDirection(After)) &&
-      mOuter->GetParent()->IsBoxFrame()) {
+      mOuter->GetParent()->IsXULBoxFrame()) {
     // Find the splitter's immediate sibling.
     nsIFrame* splitterSibling;
     if (newState == CollapsedBefore || mState == CollapsedBefore) {
       splitterSibling = mOuter->GetPrevSibling();
     } else {
       splitterSibling = mOuter->GetNextSibling();
     }
 
diff --git a/layout/xul/nsStackLayout.cpp b/layout/xul/nsStackLayout.cpp
--- a/layout/xul/nsStackLayout.cpp
+++ b/layout/xul/nsStackLayout.cpp
@@ -164,17 +164,17 @@ uint8_t
 nsStackLayout::GetOffset(nsIFrame* aChild, nsMargin& aOffset)
 {
   aOffset = nsMargin(0, 0, 0, 0);
 
   // get the left, right, top and bottom offsets
 
   // As an optimization, we cache the fact that we are not positioned to avoid
   // wasting time fetching attributes.
-  if (aChild->IsBoxFrame() &&
+  if (aChild->IsXULBoxFrame() &&
       (aChild->GetStateBits() & NS_STATE_STACK_NOT_POSITIONED))
     return 0;
 
   uint8_t offsetSpecified = 0;
   nsIContent* content = aChild->GetContent();
   if (content) {
     bool ltr = aChild->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR;
     nsAutoString value;
@@ -236,17 +236,17 @@ nsStackLayout::GetOffset(nsIFrame* aChil
     if (!value.IsEmpty()) {
       value.Trim("%");
       aOffset.bottom =
         nsPresContext::CSSPixelsToAppUnits(value.ToInteger(&error));
       offsetSpecified |= SPECIFIED_BOTTOM;
     }
   }
 
-  if (!offsetSpecified && aChild->IsBoxFrame()) {
+  if (!offsetSpecified && aChild->IsXULBoxFrame()) {
     // If no offset was specified at all, then we cache this fact to avoid requerying
     // CSS or the content model.
     aChild->AddStateBits(NS_STATE_STACK_NOT_POSITIONED);
   }
 
   return offsetSpecified;
 }
 
