From: L. David Baron <dbaron@dbaron.org>

Bug 1115999 - Call ApplyRelativePositioning properly for table cells that we choose not to reflow.

I confirmed that the reftest passes with the patch.

diff --git a/layout/reftests/position-relative/1115999-1-ref.html b/layout/reftests/position-relative/1115999-1-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/position-relative/1115999-1-ref.html
@@ -0,0 +1,15 @@
+<!DOCTYPE HTML>
+<title>Testcase, bug 1115999</title>
+<style>
+html { overflow: hidden }
+html, body { margin: 0; border: 0; }
+table, tr, td { border: none; margin: 0; padding: 0; border-spacing: 0 }
+</style>
+
+<table>
+  <tr>
+    <td>one</td>
+    <td>two</td>
+    <td></td>
+  </tr>
+</table>
diff --git a/layout/reftests/position-relative/1115999-1.html b/layout/reftests/position-relative/1115999-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/position-relative/1115999-1.html
@@ -0,0 +1,28 @@
+<!DOCTYPE HTML>
+<title>Testcase, bug 1115999</title>
+<style>
+html { overflow: hidden }
+html, body { margin: 0; border: 0; }
+table, tr, td { border: none; margin: 0; padding: 0; border-spacing: 0 }
+</style>
+
+<table>
+  <tr>
+    <td>o</td>
+    <td style="position: relative">two</td>
+  </tr>
+</table>
+<script>
+
+document.body.offsetHeight;
+
+var row = document.getElementsByTagName("tr")[0];
+var cell = row.firstElementChild;
+cell.textContent = "one";
+
+document.body.offsetHeight;
+
+// Force a call to nsTableFrame::SetGeometryDirty.
+row.appendChild(document.createElement("td"));
+
+</script>
diff --git a/layout/reftests/position-relative/reftest.list b/layout/reftests/position-relative/reftest.list
--- a/layout/reftests/position-relative/reftest.list
+++ b/layout/reftests/position-relative/reftest.list
@@ -1,8 +1,9 @@
 == table-collapse-1.html table-collapse-1-ref.html
 == table-collapse-2.html table-collapse-2-ref.html
 == table-collapse-3.html table-collapse-3-ref.html
 == table-collapse-4.html table-collapse-4-ref.html
 == table-separate-1.html table-separate-1-ref.html
 == table-separate-2.html table-separate-2-ref.html
 == table-separate-3.html table-separate-3-ref.html
 == table-separate-4.html table-separate-4-ref.html
+== 1115999-1.html 1115999-1-ref.html
diff --git a/layout/tables/nsTableRowFrame.cpp b/layout/tables/nsTableRowFrame.cpp
--- a/layout/tables/nsTableRowFrame.cpp
+++ b/layout/tables/nsTableRowFrame.cpp
@@ -961,22 +961,24 @@ nsTableRowFrame::ReflowChildren(nsPresCo
       }
 
       // Place the child
       desiredSize.ISize(rowWM) = availCellWidth;
 
       if (kidReflowState) {
         // We reflowed. Apply relative positioning in the normal way.
         kidReflowState->ApplyRelativePositioning(&kidPosition);
-      } else {
-        // We didn't reflow. To take relative positioning into account,
-        // translate the new position by the vector from the previous 'normal'
-        // position to the previous position.
-        // XXX(seth): This doesn't work for 'position: sticky'.
-        kidPosition += kidRect.TopLeft() - origKidNormalPosition;
+      } else if (kidFrame->IsRelativelyPositioned()) {
+        // We didn't reflow.  Do the positioning part of what
+        // MovePositionBy does internally.  (This codepath should really
+        // be merged into the else below if we can.)
+        const nsMargin* computedOffsets = static_cast<nsMargin*>
+          (kidFrame->Properties().Get(nsIFrame::ComputedOffsetProperty()));
+        nsHTMLReflowState::ApplyRelativePositioning(kidFrame, *computedOffsets,
+                                                    &kidPosition);
       }
       FinishReflowChild(kidFrame, aPresContext, desiredSize, nullptr,
                         kidPosition.x, kidPosition.y, 0);
 
       nsTableFrame::InvalidateTableFrame(kidFrame, kidRect, kidVisualOverflow,
                                          firstReflow);
       
       x += desiredSize.Width();  
