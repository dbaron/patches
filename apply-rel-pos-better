From: L. David Baron <dbaron@dbaron.org>

Bug 1115999 - Call ApplyRelativePositioning properly for table cells that we choose not to reflow.

diff --git a/layout/tables/nsTableRowFrame.cpp b/layout/tables/nsTableRowFrame.cpp
--- a/layout/tables/nsTableRowFrame.cpp
+++ b/layout/tables/nsTableRowFrame.cpp
@@ -961,22 +961,22 @@ nsTableRowFrame::ReflowChildren(nsPresCo
       }
 
       // Place the child
       desiredSize.ISize(rowWM) = availCellWidth;
 
       if (kidReflowState) {
         // We reflowed. Apply relative positioning in the normal way.
         kidReflowState->ApplyRelativePositioning(&kidPosition);
-      } else {
-        // We didn't reflow. To take relative positioning into account,
-        // translate the new position by the vector from the previous 'normal'
-        // position to the previous position.
-        // XXX(seth): This doesn't work for 'position: sticky'.
-        kidPosition += kidRect.TopLeft() - origKidNormalPosition;
+      } else if (kidFrame->IsRelativelyPositioned()) {
+        // We didn't reflow.
+        const nsMargin* computedOffsets = static_cast<nsMargin*>
+          (Properties().Get(nsIFrame::ComputedOffsetProperty()));
+        nsHTMLReflowState::ApplyRelativePositioning(kidFrame, computedOffsets,
+                                                    &kidPosition);
       }
       FinishReflowChild(kidFrame, aPresContext, desiredSize, nullptr,
                         kidPosition.x, kidPosition.y, 0);
 
       nsTableFrame::InvalidateTableFrame(kidFrame, kidRect, kidVisualOverflow,
                                          firstReflow);
       
       x += desiredSize.Width();  
