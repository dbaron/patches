From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::SetBounds to SetXULBounds.  r=dholbert

This is a manual subset of changes written with sed, over .h and .cpp
files in layout/, with additional manual indentation fixes.

MozReview-Commit-ID: weRWGmQLjh

diff --git a/layout/generic/nsGfxScrollFrame.h b/layout/generic/nsGfxScrollFrame.h
--- a/layout/generic/nsGfxScrollFrame.h
+++ b/layout/generic/nsGfxScrollFrame.h
@@ -1440,17 +1440,17 @@ protected:
                          bool aRemoveOverflowAreas = false) {
     /* 
      * For RTL frames, restore the original scrolled position of the right
      * edge, then subtract the current width to find the physical position.
      */
     if (!mHelper.IsLTR()) {
       aRect.x = mHelper.mScrollPort.XMost() - aScrollPosition.x - aRect.width;
     }
-    mHelper.mScrolledFrame->SetBounds(aState, aRect, aRemoveOverflowAreas);
+    mHelper.mScrolledFrame->SetXULBounds(aState, aRect, aRemoveOverflowAreas);
   }
 
 private:
   friend class mozilla::ScrollFrameHelper;
   ScrollFrameHelper mHelper;
 };
 
 #endif /* nsGfxScrollFrame_h___ */
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2901,18 +2901,18 @@ public:
   virtual nscoord GetXULFlex() = 0;
   virtual nscoord GetXULBoxAscent(nsBoxLayoutState& aBoxLayoutState) = 0;
   virtual bool IsXULCollapsed() = 0;
   // This does not alter the overflow area. If the caller is changing
   // the box size, the caller is responsible for updating the overflow
   // area. It's enough to just call Layout or SyncLayout on the
   // box. You can pass true to aRemoveOverflowArea as a
   // convenience.
-  virtual void SetBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
-                         bool aRemoveOverflowAreas = false) = 0;
+  virtual void SetXULBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
+                            bool aRemoveOverflowAreas = false) = 0;
   nsresult Layout(nsBoxLayoutState& aBoxLayoutState);
   // Box methods.  Note that these do NOT just get the CSS border, padding,
   // etc.  They also talk to nsITheme.
   virtual nsresult GetBorderAndPadding(nsMargin& aBorderAndPadding);
   virtual nsresult GetBorder(nsMargin& aBorder)=0;
   virtual nsresult GetPadding(nsMargin& aBorderAndPadding)=0;
   virtual nsresult GetMargin(nsMargin& aMargin)=0;
   virtual void SetLayoutManager(nsBoxLayout* aLayout) { }
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -225,19 +225,19 @@ nsIFrame::GetClientRect(nsRect& aClientR
      aClientRect.height = 0;
 
  // NS_ASSERTION(aClientRect.width >=0 && aClientRect.height >= 0, "Content Size < 0");
 
   return NS_OK;
 }
 
 void
-nsBox::SetBounds(nsBoxLayoutState& aState, const nsRect& aRect, bool aRemoveOverflowAreas)
+nsBox::SetXULBounds(nsBoxLayoutState& aState, const nsRect& aRect, bool aRemoveOverflowAreas)
 {
-    NS_BOX_ASSERTION(this, aRect.width >=0 && aRect.height >= 0, "SetBounds Size < 0");
+    NS_BOX_ASSERTION(this, aRect.width >=0 && aRect.height >= 0, "SetXULBounds Size < 0");
 
     nsRect rect(mRect);
 
     uint32_t flags = 0;
     GetLayoutFlags(flags);
 
     uint32_t stateFlags = aState.LayoutFlags();
 
diff --git a/layout/xul/nsBox.h b/layout/xul/nsBox.h
--- a/layout/xul/nsBox.h
+++ b/layout/xul/nsBox.h
@@ -24,18 +24,18 @@ public:
   virtual nsSize GetXULMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetXULFlex() override;
   virtual nscoord GetXULBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual nsSize GetXULMinSizeForScrollArea(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual bool IsXULCollapsed() override;
 
-  virtual void SetBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
-                         bool aRemoveOverflowAreas = false) override;
+  virtual void SetXULBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
+                            bool aRemoveOverflowAreas = false) override;
 
   virtual nsresult GetBorder(nsMargin& aBorderAndPadding) override;
   virtual nsresult GetPadding(nsMargin& aBorderAndPadding) override;
   virtual nsresult GetMargin(nsMargin& aMargin) override;
 
   virtual Valignment GetVAlign() const override { return vAlign_Top; }
   virtual Halignment GetHAlign() const override { return hAlign_Left; }
 
diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -698,17 +698,17 @@ nsBoxFrame::Reflow(nsPresContext*       
                              blockDirBorderPadding;
   } else {
     computedSize.BSize(wm) += m.BStart(wm) + m.BEnd(wm);
   }
 
   nsSize physicalSize = computedSize.GetPhysicalSize(wm);
   nsRect r(mRect.x, mRect.y, physicalSize.width, physicalSize.height);
 
-  SetBounds(state, r);
+  SetXULBounds(state, r);
  
   // layout our children
   Layout(state);
   
   // ok our child could have gotten bigger. So lets get its bounds
   
   // get the ascent
   LogicalSize boxSize = GetLogicalSize(wm);
@@ -1919,17 +1919,17 @@ nsBoxFrame::CheckBoxOrder()
   }
 }
 
 nsresult
 nsBoxFrame::LayoutChildAt(nsBoxLayoutState& aState, nsIFrame* aBox, const nsRect& aRect)
 {
   // get the current rect
   nsRect oldRect(aBox->GetRect());
-  aBox->SetBounds(aState, aRect);
+  aBox->SetXULBounds(aState, aRect);
 
   bool layout = NS_SUBTREE_DIRTY(aBox);
   
   if (layout || (oldRect.width != aRect.width || oldRect.height != aRect.height))  {
     return aBox->Layout(aState);
   }
 
   return NS_OK;
diff --git a/layout/xul/nsLeafBoxFrame.cpp b/layout/xul/nsLeafBoxFrame.cpp
--- a/layout/xul/nsLeafBoxFrame.cpp
+++ b/layout/xul/nsLeafBoxFrame.cpp
@@ -293,27 +293,27 @@ nsLeafBoxFrame::Reflow(nsPresContext*   
   computedSize.height = std::max(0, computedSize.height - m.TopBottom());
   computedSize.height = NS_CSS_MINMAX(computedSize.height,
                                       aReflowState.ComputedMinHeight(),
                                       aReflowState.ComputedMaxHeight());
   computedSize.height += m.TopBottom();
 
   nsRect r(mRect.x, mRect.y, computedSize.width, computedSize.height);
 
-  SetBounds(state, r);
+  SetXULBounds(state, r);
  
   // layout our children
   Layout(state);
   
   // ok our child could have gotten bigger. So lets get its bounds
   aDesiredSize.Width() = mRect.width;
   aDesiredSize.Height() = mRect.height;
   aDesiredSize.SetBlockStartAscent(GetXULBoxAscent(state));
 
-  // the overflow rect is set in SetBounds() above
+  // the overflow rect is set in SetXULBounds() above
   aDesiredSize.mOverflowAreas = GetOverflowAreas();
 
 #ifdef DO_NOISY_REFLOW
   {
     printf("%p ** nsLBF(done) W:%d H:%d  ", this, aDesiredSize.Width(), aDesiredSize.Height());
 
     if (maxElementWidth) {
       printf("MW:%d\n", *maxElementWidth); 
diff --git a/layout/xul/nsListBoxLayout.cpp b/layout/xul/nsListBoxLayout.cpp
--- a/layout/xul/nsListBoxLayout.cpp
+++ b/layout/xul/nsListBoxLayout.cpp
@@ -156,31 +156,31 @@ nsListBoxLayout::LayoutInternal(nsIFrame
       childRect.width = clientRect.width;
       
       nsSize size = box->GetXULPrefSize(aState);
       body->SetRowHeight(size.height);
       
       childRect.height = rowHeight;
 
       childRect.Deflate(margin);
-      box->SetBounds(aState, childRect);
+      box->SetXULBounds(aState, childRect);
       box->Layout(aState);
     } else {
       // if the child did not need to be relayed out. Then its easy.
       // Place the child by just grabbing its rect and adjusting the y.
       int32_t newPos = yOffset+margin.top;
 
       // are we pushing down or pulling up any rows?
       // Then we may have to redraw everything below the moved 
       // rows.
       if (redrawStart == -1 && childRect.y != newPos)
         redrawStart = newPos;
 
       childRect.y = newPos;
-      box->SetBounds(aState, childRect);
+      box->SetXULBounds(aState, childRect);
     }
 
     // Ok now the available size gets smaller and we move the
     // starting position of the next child down some.
     nscoord size = childRect.height + margin.top + margin.bottom;
 
     yOffset += size;
     availableHeight -= size;
diff --git a/layout/xul/nsMenuPopupFrame.cpp b/layout/xul/nsMenuPopupFrame.cpp
--- a/layout/xul/nsMenuPopupFrame.cpp
+++ b/layout/xul/nsMenuPopupFrame.cpp
@@ -464,17 +464,17 @@ nsMenuPopupFrame::LayoutPopup(nsBoxLayou
   if (aSizedToPopup) {
     prefSize.width = aParentMenu->GetRect().width;
   }
   prefSize = BoundsCheck(minSize, prefSize, maxSize);
 
   // if the size changed then set the bounds to be the preferred size
   bool sizeChanged = (mPrefSize != prefSize);
   if (sizeChanged) {
-    SetBounds(aState, nsRect(0, 0, prefSize.width, prefSize.height), false);
+    SetXULBounds(aState, nsRect(0, 0, prefSize.width, prefSize.height), false);
     mPrefSize = prefSize;
   }
 
   bool needCallback = false;
 
   if (shouldPosition) {
     SetPopupPosition(aAnchor, false, aSizedToPopup);
     needCallback = true;
@@ -1519,17 +1519,17 @@ nsMenuPopupFrame::SetPopupPosition(nsIFr
     MoveViewTo(view, viewPoint.x, viewPoint.y);
 
   // Now that we've positioned the view, sync up the frame's origin.
   nsBoxFrame::SetPosition(viewPoint - GetParent()->GetOffsetTo(rootFrame));
 
   if (aSizedToPopup) {
     nsBoxLayoutState state(PresContext());
     // XXXndeakin can parentSize.width still extend outside?
-    SetBounds(state, mRect);
+    SetXULBounds(state, mRect);
   }
 
   return NS_OK;
 }
 
 /* virtual */ nsMenuFrame*
 nsMenuPopupFrame::GetCurrentMenuItem()
 {
diff --git a/layout/xul/nsSprocketLayout.cpp b/layout/xul/nsSprocketLayout.cpp
--- a/layout/xul/nsSprocketLayout.cpp
+++ b/layout/xul/nsSprocketLayout.cpp
@@ -450,17 +450,17 @@ nsSprocketLayout::Layout(nsIFrame* aBox,
           childRect.x = oldRect.x;
         }
       }
 
       // We computed a childRect.  Now we want to set the bounds of the child to be that rect.
       // If our old rect is different, then we know our size changed and we cache that fact
       // in the |sizeChanged| variable.
 
-      child->SetBounds(aState, childRect);
+      child->SetXULBounds(aState, childRect);
       bool sizeChanged = (childRect.width != oldRect.width ||
                             childRect.height != oldRect.height);
 
       if (sizeChanged) {
         // Our size is different.  Sanity check against our maximum allowed size to ensure
         // we didn't exceed it.
         nsSize minSize = child->GetXULMinSize(aState);
         nsSize maxSize = child->GetXULMaxSize(aState);
@@ -469,17 +469,17 @@ nsSprocketLayout::Layout(nsIFrame* aBox,
         // make sure the size is in our max size.
         if (childRect.width > maxSize.width)
           childRect.width = maxSize.width;
 
         if (childRect.height > maxSize.height)
           childRect.height = maxSize.height;
            
         // set it again
-        child->SetBounds(aState, childRect);
+        child->SetXULBounds(aState, childRect);
       }
 
       // If we already determined that layout was required or if our size has changed, then
       // we make sure to call layout on the child, since its children may need to be shifted
       // around as a result of the size change.
       if (layout || sizeChanged)
         child->Layout(aState);
       
@@ -545,17 +545,17 @@ nsSprocketLayout::Layout(nsIFrame* aBox,
         ComputeChildsNextPosition(aBox, x, y, nextX, nextY, newChildRect);
 
         if (newChildRect.width >= margin.left + margin.right && newChildRect.height >= margin.top + margin.bottom) 
           newChildRect.Deflate(margin);
 
         if (childRect.width >= margin.left + margin.right && childRect.height >= margin.top + margin.bottom) 
           childRect.Deflate(margin);
             
-        child->SetBounds(aState, newChildRect);
+        child->SetXULBounds(aState, newChildRect);
 
         // If we are the first box that changed size, then we don't need to do a second pass
         if (count == 0)
           finished = true;
       }
 
       // Now update our x/y finally.
       x = nextX;
@@ -603,17 +603,17 @@ nsSprocketLayout::Layout(nsIFrame* aBox,
       // if it did reset our bounds.
       nsRect bounds(aBox->GetRect());
       if (tmpClientRect.width > originalSize.width)
         bounds.width = tmpClientRect.width;
 
       if (tmpClientRect.height > originalSize.height)
         bounds.height = tmpClientRect.height;
 
-      aBox->SetBounds(aState, bounds);
+      aBox->SetXULBounds(aState, bounds);
     }
   }
 
   // Because our size grew, we now have to readjust because of box packing.  Repack
   // in order to update our x and y to the correct values.
   HandleBoxPack(aBox, frameState, x, y, originalClientRect, clientRect);
 
   // Compare against our original x and y and only worry about adjusting the children if
@@ -623,17 +623,17 @@ nsSprocketLayout::Layout(nsIFrame* aBox,
     nsIFrame* child = nsBox::GetChildBox(aBox);
 
     // reposition all our children
     while (child) 
     {
       nsRect childRect(child->GetRect());
       childRect.x += (x - origX);
       childRect.y += (y - origY);
-      child->SetBounds(aState, childRect);
+      child->SetXULBounds(aState, childRect);
       child = nsBox::GetNextBox(child);
     }
   }
 
   // Perform out-of-axis alignment for non-stretch alignments
   if (!(frameState & NS_STATE_AUTO_STRETCH)) {
     AlignChildren(aBox, aState);
   }
@@ -998,17 +998,17 @@ nsSprocketLayout::AlignChildren(nsIFrame
           x = isLTR ? rightAlign : leftAlign;
           break;
       }
 
       childRect.x = x;
     }
 
     if (childRect.TopLeft() != child->GetPosition()) {
-      child->SetBounds(aState, childRect);
+      child->SetXULBounds(aState, childRect);
     }
 
     child = nsBox::GetNextBox(child);
   }
 }
 
 void
 nsSprocketLayout::ChildResized(nsIFrame* aBox,
@@ -1130,17 +1130,17 @@ nsSprocketLayout::ChildResized(nsIFrame*
         // make sure we remove it before setting 
         // the bounds.
         nsMargin margin(0,0,0,0);
         aChild->GetMargin(margin);
         nsRect rect(aChildActualRect);
         if (rect.width >= margin.left + margin.right && rect.height >= margin.top + margin.bottom) 
           rect.Deflate(margin);
 
-        aChild->SetBounds(aState, rect);
+        aChild->SetXULBounds(aState, rect);
         aChild->Layout(aState);
       }
 
 }
 
 void
 nsSprocketLayout::InvalidateComputedSizes(nsComputedBoxSize* aComputedBoxSizes)
 {
diff --git a/layout/xul/nsStackLayout.cpp b/layout/xul/nsStackLayout.cpp
--- a/layout/xul/nsStackLayout.cpp
+++ b/layout/xul/nsStackLayout.cpp
@@ -331,17 +331,17 @@ nsStackLayout::Layout(nsIFrame* aBox, ns
             else if (offsetSpecified & SPECIFIED_BOTTOM) {
               nscoord height = child->GetXULPrefSize(aState).height;
               childRect.height = clamped(height, min.height, max.height);
               childRect.y = clientRect.YMost() - offset.bottom - margin.bottom - childRect.height;
             }
           }
 
           // Now place the child.
-          child->SetBounds(aState, childRect);
+          child->SetXULBounds(aState, childRect);
 
           // Flow the child.
           child->Layout(aState);
 
           // Get the child's new rect.
           childRect = child->GetRect();
           childRect.Inflate(margin);
 
@@ -372,14 +372,14 @@ nsStackLayout::Layout(nsIFrame* aBox, ns
 
    if (clientRect.width > bounds.width || clientRect.height > bounds.height)
    {
      if (clientRect.width > bounds.width)
        bounds.width = clientRect.width;
      if (clientRect.height > bounds.height)
        bounds.height = clientRect.height;
 
-     aBox->SetBounds(aState, bounds);
+     aBox->SetXULBounds(aState, bounds);
    }
 
    return NS_OK;
 }
 
diff --git a/layout/xul/tree/nsTreeBodyFrame.cpp b/layout/xul/tree/nsTreeBodyFrame.cpp
--- a/layout/xul/tree/nsTreeBodyFrame.cpp
+++ b/layout/xul/tree/nsTreeBodyFrame.cpp
@@ -399,24 +399,24 @@ nsTreeBodyFrame::ManageReflowCallback(co
            mHorzWidth != aHorzWidth && mOriginalHorzWidth == aHorzWidth) {
     PresContext()->PresShell()->CancelReflowCallback(this);
     mReflowCallbackPosted = false;
     mOriginalHorzWidth = -1;
   }
 }
 
 void
-nsTreeBodyFrame::SetBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
-                           bool aRemoveOverflowArea)
+nsTreeBodyFrame::SetXULBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
+                              bool aRemoveOverflowArea)
 {
   nscoord horzWidth = CalcHorzWidth(GetScrollParts());
   ManageReflowCallback(aRect, horzWidth);
   mHorzWidth = horzWidth;
 
-  nsLeafBoxFrame::SetBounds(aBoxLayoutState, aRect, aRemoveOverflowArea);
+  nsLeafBoxFrame::SetXULBounds(aBoxLayoutState, aRect, aRemoveOverflowArea);
 }
 
 
 bool
 nsTreeBodyFrame::ReflowFinished()
 {
   if (!mView) {
     nsWeakFrame weakFrame(this);
diff --git a/layout/xul/tree/nsTreeBodyFrame.h b/layout/xul/tree/nsTreeBodyFrame.h
--- a/layout/xul/tree/nsTreeBodyFrame.h
+++ b/layout/xul/tree/nsTreeBodyFrame.h
@@ -120,18 +120,18 @@ public:
   nsresult EndUpdateBatch();
   nsresult ClearStyleAndImageCaches();
 
   void CancelImageRequests();
 
   void ManageReflowCallback(const nsRect& aRect, nscoord aHorzWidth);
 
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual void SetBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
-                         bool aRemoveOverflowArea = false) override;
+  virtual void SetXULBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
+                            bool aRemoveOverflowArea = false) override;
 
   // nsIReflowCallback
   virtual bool ReflowFinished() override;
   virtual void ReflowCallbackCanceled() override;
 
   // nsICSSPseudoComparator
   virtual bool PseudoMatches(nsCSSSelector* aSelector) override;
 
diff --git a/layout/xul/tree/nsTreeColFrame.cpp b/layout/xul/tree/nsTreeColFrame.cpp
--- a/layout/xul/tree/nsTreeColFrame.cpp
+++ b/layout/xul/tree/nsTreeColFrame.cpp
@@ -138,22 +138,23 @@ nsTreeColFrame::AttributeChanged(int32_t
   if (aAttribute == nsGkAtoms::ordinal || aAttribute == nsGkAtoms::primary) {
     InvalidateColumns();
   }
 
   return rv;
 }
 
 void
-nsTreeColFrame::SetBounds(nsBoxLayoutState& aBoxLayoutState,
-                          const nsRect& aRect,
-                          bool aRemoveOverflowArea) {
+nsTreeColFrame::SetXULBounds(nsBoxLayoutState& aBoxLayoutState,
+                             const nsRect& aRect,
+                             bool aRemoveOverflowArea)
+{
   nscoord oldWidth = mRect.width;
 
-  nsBoxFrame::SetBounds(aBoxLayoutState, aRect, aRemoveOverflowArea);
+  nsBoxFrame::SetXULBounds(aBoxLayoutState, aRect, aRemoveOverflowArea);
   if (mRect.width != oldWidth) {
     nsITreeBoxObject* treeBoxObject = GetTreeBoxObject();
     if (treeBoxObject) {
       treeBoxObject->Invalidate();
     }
   }
 }
 
diff --git a/layout/xul/tree/nsTreeColFrame.h b/layout/xul/tree/nsTreeColFrame.h
--- a/layout/xul/tree/nsTreeColFrame.h
+++ b/layout/xul/tree/nsTreeColFrame.h
@@ -28,18 +28,18 @@ public:
   virtual void BuildDisplayListForChildren(nsDisplayListBuilder*   aBuilder,
                                            const nsRect&           aDirtyRect,
                                            const nsDisplayListSet& aLists) override;
 
   virtual nsresult AttributeChanged(int32_t aNameSpaceID,
                                     nsIAtom* aAttribute,
                                     int32_t aModType) override;
 
-  virtual void SetBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
-                         bool aRemoveOverflowArea = false) override;
+  virtual void SetXULBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
+                            bool aRemoveOverflowArea = false) override;
 
   friend nsIFrame* NS_NewTreeColFrame(nsIPresShell* aPresShell,
                                       nsStyleContext* aContext);
 
 protected:
   virtual ~nsTreeColFrame();
 
   /**
