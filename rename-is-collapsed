From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::IsCollapsed to IsXULCollapsed.

This is a manual subset of changes written with sed, over .h and .cpp
files in layout/.  There is also a Selection method called IsCollapsed.

MozReview-Commit-ID: 9JgnPv0Hkff

diff --git a/layout/forms/nsTextControlFrame.cpp b/layout/forms/nsTextControlFrame.cpp
--- a/layout/forms/nsTextControlFrame.cpp
+++ b/layout/forms/nsTextControlFrame.cpp
@@ -588,17 +588,17 @@ nsTextControlFrame::ReflowTextControlChi
 nsSize
 nsTextControlFrame::GetXULMinSize(nsBoxLayoutState& aState)
 {
   // XXXbz why?  Why not the nsBoxFrame sizes?
   return nsBox::GetXULMinSize(aState);
 }
 
 bool
-nsTextControlFrame::IsCollapsed()
+nsTextControlFrame::IsXULCollapsed()
 {
   // We're never collapsed in the box sense.
   return false;
 }
 
 bool
 nsTextControlFrame::IsLeaf() const
 {
diff --git a/layout/forms/nsTextControlFrame.h b/layout/forms/nsTextControlFrame.h
--- a/layout/forms/nsTextControlFrame.h
+++ b/layout/forms/nsTextControlFrame.h
@@ -58,17 +58,17 @@ public:
                   bool aShrinkWrap) override;
 
   virtual void Reflow(nsPresContext*           aPresContext,
                       nsHTMLReflowMetrics&     aDesiredSize,
                       const nsHTMLReflowState& aReflowState,
                       nsReflowStatus&          aStatus) override;
 
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual bool IsCollapsed() override;
+  virtual bool IsXULCollapsed() override;
 
   virtual bool IsLeaf() const override;
   
 #ifdef ACCESSIBILITY
   virtual mozilla::a11y::AccType AccessibleType() override;
 #endif
 
 #ifdef DEBUG_FRAME_DUMP
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -5876,17 +5876,17 @@ nsFrame::UpdateOverflow()
 {
   MOZ_ASSERT(FrameMaintainsOverflow(),
              "Non-display SVG do not maintain visual overflow rects");
 
   nsRect rect(nsPoint(0, 0), GetSize());
   nsOverflowAreas overflowAreas(rect, rect);
 
   if (!DoesClipChildren() &&
-      !(IsCollapsed() && (IsXULBoxFrame() || ::IsXULBoxWrapped(this)))) {
+      !(IsXULCollapsed() && (IsXULBoxFrame() || ::IsXULBoxWrapped(this)))) {
     nsLayoutUtils::UnionChildOverflow(this, overflowAreas);
   }
 
   if (FinishAndStoreOverflow(overflowAreas, GetSize())) {
     nsView* view = GetView();
     if (view) {
       uint32_t flags = 0;
       GetLayoutFlags(flags);
@@ -8699,17 +8699,17 @@ nsFrame::GetXULPrefSize(nsBoxLayoutState
   DISPLAY_PREF_SIZE(this, size);
   // If the size is cached, and there are no HTML constraints that we might
   // be depending on, then we just return the cached size.
   nsBoxLayoutMetrics *metrics = BoxMetrics();
   if (!DoesNeedRecalc(metrics->mPrefSize)) {
     return metrics->mPrefSize;
   }
 
-  if (IsCollapsed())
+  if (IsXULCollapsed())
     return size;
 
   // get our size in CSS.
   bool widthSet, heightSet;
   bool completelyRedefined = nsIFrame::AddCSSPrefSize(this, size, widthSet, heightSet);
 
   // Refresh our caches with new sizes.
   if (!completelyRedefined) {
@@ -8735,17 +8735,17 @@ nsFrame::GetXULMinSize(nsBoxLayoutState&
   DISPLAY_MIN_SIZE(this, size);
   // Don't use the cache if we have HTMLReflowState constraints --- they might have changed
   nsBoxLayoutMetrics *metrics = BoxMetrics();
   if (!DoesNeedRecalc(metrics->mMinSize)) {
     size = metrics->mMinSize;
     return size;
   }
 
-  if (IsCollapsed())
+  if (IsXULCollapsed())
     return size;
 
   // get our size in CSS.
   bool widthSet, heightSet;
   bool completelyRedefined =
     nsIFrame::AddCSSMinSize(aState, this, size, widthSet, heightSet);
 
   // Refresh our caches with new sizes.
@@ -8770,17 +8770,17 @@ nsFrame::GetXULMaxSize(nsBoxLayoutState&
   DISPLAY_MAX_SIZE(this, size);
   // Don't use the cache if we have HTMLReflowState constraints --- they might have changed
   nsBoxLayoutMetrics *metrics = BoxMetrics();
   if (!DoesNeedRecalc(metrics->mMaxSize)) {
     size = metrics->mMaxSize;
     return size;
   }
 
-  if (IsCollapsed())
+  if (IsXULCollapsed())
     return size;
 
   size = nsBox::GetXULMaxSize(aState);
   metrics->mMaxSize = size;
 
   return size;
 }
 
@@ -8798,17 +8798,17 @@ nsFrame::GetXULFlex()
 
 nscoord
 nsFrame::GetXULBoxAscent(nsBoxLayoutState& aState)
 {
   nsBoxLayoutMetrics *metrics = BoxMetrics();
   if (!DoesNeedRecalc(metrics->mAscent))
     return metrics->mAscent;
 
-  if (IsCollapsed()) {
+  if (IsXULCollapsed()) {
     metrics->mAscent = 0;
   } else {
     // Refresh our caches with new sizes.
     RefreshSizeCache(aState);
     metrics->mAscent = metrics->mBlockAscent;
   }
 
   return metrics->mAscent;
@@ -8827,17 +8827,17 @@ nsFrame::DoLayout(nsBoxLayoutState& aSta
   nsHTMLReflowMetrics desiredSize(outerWM);
   LogicalSize ourSize = GetLogicalSize(outerWM);
 
   if (rendContext) {
 
     BoxReflow(aState, presContext, desiredSize, rendContext,
               ourRect.x, ourRect.y, ourRect.width, ourRect.height);
 
-    if (IsCollapsed()) {
+    if (IsXULCollapsed()) {
       SetSize(nsSize(0, 0));
     } else {
 
       // if our child needs to be bigger. This might happend with
       // wrapping text. There is no way to predict its height until we
       // reflow it. Now that we know the height reshuffle upward.
       if (desiredSize.ISize(outerWM) > ourSize.ISize(outerWM) ||
           desiredSize.BSize(outerWM) > ourSize.BSize(outerWM)) {
@@ -8859,17 +8859,17 @@ nsFrame::DoLayout(nsBoxLayoutState& aSta
       }
 
       // ensure our size is what we think is should be. Someone could have
       // reset the frame to be smaller or something dumb like that. 
       SetSize(ourSize.ConvertTo(ourWM, outerWM));
     }
   }
 
-  // Should we do this if IsCollapsed() is true?
+  // Should we do this if IsXULCollapsed() is true?
   LogicalSize size(GetLogicalSize(outerWM));
   desiredSize.ISize(outerWM) = size.ISize(outerWM);
   desiredSize.BSize(outerWM) = size.BSize(outerWM);
   desiredSize.UnionOverflowAreasWithDesiredBounds();
 
   if (HasAbsolutelyPositionedChildren()) {
     // Set up a |reflowState| to pass into ReflowAbsoluteFrames
     nsHTMLReflowState reflowState(aState.PresContext(), this,
@@ -9094,17 +9094,17 @@ nsFrame::BoxReflow(nsBoxLayoutState&    
 
     NS_ASSERTION(NS_FRAME_IS_COMPLETE(status), "bad status");
 
     uint32_t layoutFlags = aState.LayoutFlags();
     nsContainerFrame::FinishReflowChild(this, aPresContext, aDesiredSize,
                                         &reflowState, aX, aY, layoutFlags | NS_FRAME_NO_MOVE_FRAME);
 
     // Save the ascent.  (bug 103925)
-    if (IsCollapsed()) {
+    if (IsXULCollapsed()) {
       metrics->mAscent = 0;
     } else {
       if (aDesiredSize.BlockStartAscent() ==
           nsHTMLReflowMetrics::ASK_FOR_BASELINE) {
         if (!nsLayoutUtils::GetFirstLineBaseline(wm, this, &metrics->mAscent))
           metrics->mAscent = GetLogicalBaseline(wm);
       } else
         metrics->mAscent = aDesiredSize.BlockStartAscent();
diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -800,17 +800,17 @@ nsHTMLScrollFrame::GetPadding(nsMargin& 
   // reaize that.  If we're stuck inside a XUL box, we need to claim no
   // padding.
   // @see also nsXULScrollFrame::GetPadding.
   aMargin.SizeTo(0,0,0,0);
   return NS_OK;
 }
 
 bool
-nsHTMLScrollFrame::IsCollapsed()
+nsHTMLScrollFrame::IsXULCollapsed()
 {
   // We're never collapsed in the box sense.
   return false;
 }
 
 // Return the <browser> if the scrollframe is for the root frame directly
 // inside a <browser>.
 static nsIContent*
diff --git a/layout/generic/nsGfxScrollFrame.h b/layout/generic/nsGfxScrollFrame.h
--- a/layout/generic/nsGfxScrollFrame.h
+++ b/layout/generic/nsGfxScrollFrame.h
@@ -695,17 +695,17 @@ public:
   virtual bool GetBorderRadii(const nsSize& aFrameSize, const nsSize& aBorderArea,
                               Sides aSkipSides, nscoord aRadii[8]) const override {
     return mHelper.GetBorderRadii(aFrameSize, aBorderArea, aSkipSides, aRadii);
   }
 
   virtual nscoord GetMinISize(nsRenderingContext *aRenderingContext) override;
   virtual nscoord GetPrefISize(nsRenderingContext *aRenderingContext) override;
   virtual nsresult GetPadding(nsMargin& aPadding) override;
-  virtual bool IsCollapsed() override;
+  virtual bool IsXULCollapsed() override;
   
   virtual void Reflow(nsPresContext*           aPresContext,
                       nsHTMLReflowMetrics&     aDesiredSize,
                       const nsHTMLReflowState& aReflowState,
                       nsReflowStatus&          aStatus) override;
 
   virtual bool UpdateOverflow() override {
     return mHelper.UpdateOverflow();
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2895,17 +2895,17 @@ public:
    */
   virtual nsSize GetXULMinSizeForScrollArea(nsBoxLayoutState& aBoxLayoutState) = 0;
 
   // Implemented in nsBox, used in nsBoxFrame
   uint32_t GetXULOrdinal();
 
   virtual nscoord GetXULFlex() = 0;
   virtual nscoord GetXULBoxAscent(nsBoxLayoutState& aBoxLayoutState) = 0;
-  virtual bool IsCollapsed() = 0;
+  virtual bool IsXULCollapsed() = 0;
   // This does not alter the overflow area. If the caller is changing
   // the box size, the caller is responsible for updating the overflow
   // area. It's enough to just call Layout or SyncLayout on the
   // box. You can pass true to aRemoveOverflowArea as a
   // convenience.
   virtual void SetBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
                          bool aRemoveOverflowAreas = false) = 0;
   nsresult Layout(nsBoxLayoutState& aBoxLayoutState);
diff --git a/layout/xul/grid/nsGrid.cpp b/layout/xul/grid/nsGrid.cpp
--- a/layout/xul/grid/nsGrid.cpp
+++ b/layout/xul/grid/nsGrid.cpp
@@ -593,28 +593,28 @@ nsGrid::GetFirstAndLastRow(int32_t& aFir
   // collaped we become the first row. Or if we are the 9th row and
   // 10 up to the last row are collapsed we then become the last.
 
   // see if we are first
   int32_t i;
   for (i=0; i < count; i++)
   {
      nsGridRow* row = GetRowAt(i,aIsHorizontal);
-     if (!row->IsCollapsed()) {
+     if (!row->IsXULCollapsed()) {
        aFirstIndex = i;
        aFirstRow = row;
        break;
      }
   }
 
   // see if we are last
   for (i=count-1; i >= 0; i--)
   {
      nsGridRow* row = GetRowAt(i,aIsHorizontal);
-     if (!row->IsCollapsed()) {
+     if (!row->IsXULCollapsed()) {
        aLastIndex = i;
        aLastRow = row;
        break;
      }
 
   }
 }
 
@@ -647,17 +647,17 @@ nsGrid::GetRowOffsets(int32_t aIndex, ns
   nsMargin padding(0,0,0,0);
   nsMargin totalBorderPadding(0,0,0,0);
   nsMargin totalMargin(0,0,0,0);
 
   // if there is a box and it's not bogus take its
   // borders padding into account
   if (box && !row->mIsBogus)
   {
-    if (!box->IsCollapsed())
+    if (!box->IsXULCollapsed())
     {
        // get real border and padding. GetBorderAndPadding
        // is redefined on nsGridRowLeafFrame. If we called it here
        // we would be in finite recurson.
        box->GetBorder(border);
        box->GetPadding(padding);
 
        totalBorderPadding += border;
@@ -712,17 +712,17 @@ nsGrid::GetRowOffsets(int32_t aIndex, ns
       nsMargin totalChildBorderPadding(0,0,0,0);
 
       nsGridRow* column = GetColumnAt(i,aIsHorizontal);
       nsIFrame* box = column->GetBox();
 
       if (box) 
       {
         // ignore collapsed children
-        if (!box->IsCollapsed())
+        if (!box->IsXULCollapsed())
         {
            // include the margin of the columns. To the row
            // at this point border/padding and margins all added
            // up to more needed space.
            margin = GetBoxTotalMargin(box, !aIsHorizontal);
            // get real border and padding. GetBorderAndPadding
            // is redefined on nsGridRowLeafFrame. If we called it here
            // we would be in finite recurson.
@@ -787,17 +787,17 @@ nsGrid::GetRowOffsets(int32_t aIndex, ns
  */
 nscoord
 nsGrid::GetPrefRowHeight(nsBoxLayoutState& aState, int32_t aIndex, bool aIsHorizontal)
 {
   RebuildIfNeeded();
 
   nsGridRow* row = GetRowAt(aIndex, aIsHorizontal);
 
-  if (row->IsCollapsed())
+  if (row->IsXULCollapsed())
     return 0;
 
   if (row->IsPrefSet()) 
     return row->mPref;
 
   nsIFrame* box = row->mBox;
 
   // set in CSS?
@@ -844,17 +844,17 @@ nsGrid::GetPrefRowHeight(nsBoxLayoutStat
   for (int32_t i=0; i < count; i++)
   {  
     if (aIsHorizontal)
      child = GetCellAt(i,aIndex);
     else
      child = GetCellAt(aIndex,i);
 
     // ignore collapsed children
-    if (!child->IsCollapsed())
+    if (!child->IsXULCollapsed())
     {
       nsSize childSize = child->GetXULPrefSize(aState);
 
       nsSprocketLayout::AddLargestSize(size, childSize, aIsHorizontal);
     }
   }
 
   row->mPref = GET_HEIGHT(size, aIsHorizontal) + top + bottom;
@@ -864,17 +864,17 @@ nsGrid::GetPrefRowHeight(nsBoxLayoutStat
 
 nscoord
 nsGrid::GetMinRowHeight(nsBoxLayoutState& aState, int32_t aIndex, bool aIsHorizontal)
 {
   RebuildIfNeeded();
 
   nsGridRow* row = GetRowAt(aIndex, aIsHorizontal);
 
-  if (row->IsCollapsed())
+  if (row->IsXULCollapsed())
     return 0;
 
   if (row->IsMinSet()) 
     return row->mMin;
 
   nsIFrame* box = row->mBox;
 
   // set in CSS?
@@ -919,17 +919,17 @@ nsGrid::GetMinRowHeight(nsBoxLayoutState
   for (int32_t i=0; i < count; i++)
   {  
     if (aIsHorizontal)
      child = GetCellAt(i,aIndex);
     else
      child = GetCellAt(aIndex,i);
 
     // ignore collapsed children
-    if (!child->IsCollapsed())
+    if (!child->IsXULCollapsed())
     {
       nsSize childSize = child->GetXULMinSize(aState);
 
       nsSprocketLayout::AddLargestSize(size, childSize, aIsHorizontal);
     }
   }
 
   row->mMin = GET_HEIGHT(size, aIsHorizontal);
@@ -939,17 +939,17 @@ nsGrid::GetMinRowHeight(nsBoxLayoutState
 
 nscoord
 nsGrid::GetMaxRowHeight(nsBoxLayoutState& aState, int32_t aIndex, bool aIsHorizontal)
 {
   RebuildIfNeeded();
 
   nsGridRow* row = GetRowAt(aIndex, aIsHorizontal);
 
-  if (row->IsCollapsed())
+  if (row->IsXULCollapsed())
     return 0;
 
   if (row->IsMaxSet()) 
     return row->mMax;
 
   nsIFrame* box = row->mBox;
 
   // set in CSS?
@@ -994,17 +994,17 @@ nsGrid::GetMaxRowHeight(nsBoxLayoutState
   for (int32_t i=0; i < count; i++)
   {  
     if (aIsHorizontal)
      child = GetCellAt(i,aIndex);
     else
      child = GetCellAt(aIndex,i);
 
     // ignore collapsed children
-    if (!child->IsCollapsed())
+    if (!child->IsXULCollapsed())
     {
       nsSize min = child->GetXULMinSize(aState);
       nsSize childSize = nsBox::BoundsCheckMinMax(min, child->GetXULMaxSize(aState));
       nsSprocketLayout::AddLargestSize(size, childSize, aIsHorizontal);
     }
   }
 
   row->mMax = GET_HEIGHT(size, aIsHorizontal) + top + bottom;
diff --git a/layout/xul/grid/nsGridCell.cpp b/layout/xul/grid/nsGridCell.cpp
--- a/layout/xul/grid/nsGridCell.cpp
+++ b/layout/xul/grid/nsGridCell.cpp
@@ -113,15 +113,15 @@ nsGridCell::GetXULMaxSize(nsBoxLayoutSta
     nsBoxLayout::AddSmallestSize(sum, max);
   }
 
   return sum;
 }
 
 
 bool
-nsGridCell::IsCollapsed()
+nsGridCell::IsXULCollapsed()
 {
-  return ((mBoxInColumn && mBoxInColumn->IsCollapsed()) ||
-          (mBoxInRow && mBoxInRow->IsCollapsed()));
+  return ((mBoxInColumn && mBoxInColumn->IsXULCollapsed()) ||
+          (mBoxInRow && mBoxInRow->IsXULCollapsed()));
 }
 
 
diff --git a/layout/xul/grid/nsGridCell.h b/layout/xul/grid/nsGridCell.h
--- a/layout/xul/grid/nsGridCell.h
+++ b/layout/xul/grid/nsGridCell.h
@@ -31,17 +31,17 @@ class nsGridCell final
 {
 public:
     nsGridCell();
     ~nsGridCell();
 
     nsSize      GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState);
     nsSize      GetXULMinSize(nsBoxLayoutState& aBoxLayoutState);
     nsSize      GetXULMaxSize(nsBoxLayoutState& aBoxLayoutState);
-    bool        IsCollapsed();
+    bool        IsXULCollapsed();
 
 // accessors
     nsIFrame*   GetBoxInColumn()               { return mBoxInColumn; }
     nsIFrame*   GetBoxInRow()                  { return mBoxInRow; }
     void        SetBoxInRow(nsIFrame* aBox)    { mBoxInRow = aBox; }
     void        SetBoxInColumn(nsIFrame* aBox) { mBoxInColumn = aBox; }
 
 private:
diff --git a/layout/xul/grid/nsGridRow.cpp b/layout/xul/grid/nsGridRow.cpp
--- a/layout/xul/grid/nsGridRow.cpp
+++ b/layout/xul/grid/nsGridRow.cpp
@@ -45,13 +45,13 @@ nsGridRow::Init(nsIFrame* aBox, bool aIs
 }
 
 nsGridRow::~nsGridRow()
 {
    MOZ_COUNT_DTOR(nsGridRow);
 }
 
 bool 
-nsGridRow::IsCollapsed()
+nsGridRow::IsXULCollapsed()
 {
-  return mBox && mBox->IsCollapsed();
+  return mBox && mBox->IsXULCollapsed();
 }
 
diff --git a/layout/xul/grid/nsGridRow.h b/layout/xul/grid/nsGridRow.h
--- a/layout/xul/grid/nsGridRow.h
+++ b/layout/xul/grid/nsGridRow.h
@@ -30,17 +30,17 @@ public:
 
 // accessors
    nsIFrame* GetBox()   { return mBox;          }
    bool IsPrefSet() { return (mPref != -1); }
    bool IsMinSet()  { return (mMin  != -1); }
    bool IsMaxSet()  { return (mMax  != -1); } 
    bool IsFlexSet() { return (mFlex != -1); }
    bool IsOffsetSet() { return (mTop != -1 && mBottom != -1); }
-   bool IsCollapsed();
+   bool IsXULCollapsed();
 
 public:
 
    bool    mIsBogus;
    nsIFrame* mBox;
    nscoord mFlex;
    nscoord mPref;
    nscoord mMin;
diff --git a/layout/xul/grid/nsGridRowLeafLayout.cpp b/layout/xul/grid/nsGridRowLeafLayout.cpp
--- a/layout/xul/grid/nsGridRowLeafLayout.cpp
+++ b/layout/xul/grid/nsGridRowLeafLayout.cpp
@@ -132,17 +132,17 @@ nsGridRowLeafLayout::PopulateBoxSizes(ns
       nscoord right  = 0;
       grid->GetRowOffsets(i, left, right, !isHorizontal); // GetColumnOffsets
       nsIFrame* box = column->GetBox();
       bool collapsed = false;
       nscoord topMargin = column->mTopMargin;
       nscoord bottomMargin = column->mBottomMargin;
 
       if (box) 
-        collapsed = box->IsCollapsed();
+        collapsed = box->IsXULCollapsed();
 
       pref = pref - (left + right);
       if (pref < 0)
         pref = 0;
 
       // if this is the first or last column. Take into account that
       // our row could have a border that could affect our left or right
       // padding from our columns. If the row has padding subtract it.
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -394,17 +394,17 @@ nsBox::DoesNeedRecalc(nscoord aCoord)
 nsSize
 nsBox::GetXULPrefSize(nsBoxLayoutState& aState)
 {
   NS_ASSERTION(aState.GetRenderingContext(), "must have rendering context");
 
   nsSize pref(0,0);
   DISPLAY_PREF_SIZE(this, pref);
 
-  if (IsCollapsed())
+  if (IsXULCollapsed())
     return pref;
 
   AddBorderAndPadding(pref);
   bool widthSet, heightSet;
   nsIFrame::AddCSSPrefSize(this, pref, widthSet, heightSet);
 
   nsSize minSize = GetXULMinSize(aState);
   nsSize maxSize = GetXULMaxSize(aState);
@@ -414,17 +414,17 @@ nsBox::GetXULPrefSize(nsBoxLayoutState& 
 nsSize
 nsBox::GetXULMinSize(nsBoxLayoutState& aState)
 {
   NS_ASSERTION(aState.GetRenderingContext(), "must have rendering context");
 
   nsSize min(0,0);
   DISPLAY_MIN_SIZE(this, min);
 
-  if (IsCollapsed())
+  if (IsXULCollapsed())
     return min;
 
   AddBorderAndPadding(min);
   bool widthSet, heightSet;
   nsIFrame::AddCSSMinSize(aState, this, min, widthSet, heightSet);
   return min;
 }
 
@@ -437,17 +437,17 @@ nsBox::GetXULMinSizeForScrollArea(nsBoxL
 nsSize
 nsBox::GetXULMaxSize(nsBoxLayoutState& aState)
 {
   NS_ASSERTION(aState.GetRenderingContext(), "must have rendering context");
 
   nsSize maxSize(NS_INTRINSICSIZE, NS_INTRINSICSIZE);
   DISPLAY_MAX_SIZE(this, maxSize);
 
-  if (IsCollapsed())
+  if (IsXULCollapsed())
     return maxSize;
 
   AddBorderAndPadding(maxSize);
   bool widthSet, heightSet;
   nsIFrame::AddCSSMaxSize(this, maxSize, widthSet, heightSet);
   return maxSize;
 }
 
@@ -479,24 +479,24 @@ nsIFrame::GetXULOrdinal()
   }
 
   return ordinal;
 }
 
 nscoord
 nsBox::GetXULBoxAscent(nsBoxLayoutState& aState)
 {
-  if (IsCollapsed())
+  if (IsXULCollapsed())
     return 0;
 
   return GetXULPrefSize(aState).height;
 }
 
 bool
-nsBox::IsCollapsed()
+nsBox::IsXULCollapsed()
 {
   return StyleVisibility()->mVisible == NS_STYLE_VISIBILITY_COLLAPSE;
 }
 
 nsresult
 nsIFrame::Layout(nsBoxLayoutState& aState)
 {
   NS_ASSERTION(aState.GetRenderingContext(), "must have rendering context");
@@ -522,17 +522,17 @@ nsBox::DoesClipChildren()
                "If one overflow is clip, the other should be too");
   return display->mOverflowX == NS_STYLE_OVERFLOW_CLIP;
 }
 
 nsresult
 nsBox::SyncLayout(nsBoxLayoutState& aState)
 {
   /*
-  if (IsCollapsed()) {
+  if (IsXULCollapsed()) {
     CollapseChild(aState, this, true);
     return NS_OK;
   }
   */
   
 
   if (GetStateBits() & NS_FRAME_IS_DIRTY)
      Redraw(aState);
@@ -552,17 +552,17 @@ nsBox::SyncLayout(nsBoxLayoutState& aSta
   nsRect visualOverflow;
 
   if (ComputesOwnOverflowArea()) {
     visualOverflow = GetVisualOverflowRect();
   }
   else {
     nsRect rect(nsPoint(0, 0), GetSize());
     nsOverflowAreas overflowAreas(rect, rect);
-    if (!DoesClipChildren() && !IsCollapsed()) {
+    if (!DoesClipChildren() && !IsXULCollapsed()) {
       // See if our child frames caused us to overflow after being laid
       // out. If so, store the overflow area.  This normally can't happen
       // in XUL, but it can happen with the CSS 'outline' property and
       // possibly with other exotic stuff (e.g. relatively positioned
       // frames in HTML inside XUL).
       nsLayoutUtils::UnionChildOverflow(this, overflowAreas);
     }
 
diff --git a/layout/xul/nsBox.h b/layout/xul/nsBox.h
--- a/layout/xul/nsBox.h
+++ b/layout/xul/nsBox.h
@@ -22,17 +22,17 @@ public:
   virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetXULFlex() override;
   virtual nscoord GetXULBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual nsSize GetXULMinSizeForScrollArea(nsBoxLayoutState& aBoxLayoutState) override;
 
-  virtual bool IsCollapsed() override;
+  virtual bool IsXULCollapsed() override;
 
   virtual void SetBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
                          bool aRemoveOverflowAreas = false) override;
 
   virtual nsresult GetBorder(nsMargin& aBorderAndPadding) override;
   virtual nsresult GetPadding(nsMargin& aBorderAndPadding) override;
   virtual nsresult GetMargin(nsMargin& aMargin) override;
 
diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -754,17 +754,17 @@ nsBoxFrame::GetXULPrefSize(nsBoxLayoutSt
   if (!DoesNeedRecalc(mPrefSize)) {
      return mPrefSize;
   }
 
 #ifdef DEBUG_LAYOUT
   PropagateDebug(aBoxLayoutState);
 #endif
 
-  if (IsCollapsed())
+  if (IsXULCollapsed())
     return size;
 
   // if the size was not completely redefined in CSS then ask our children
   bool widthSet, heightSet;
   if (!nsIFrame::AddCSSPrefSize(this, size, widthSet, heightSet))
   {
     if (mLayoutManager) {
       nsSize layoutSize = mLayoutManager->GetXULPrefSize(this, aBoxLayoutState);
@@ -790,17 +790,17 @@ nsBoxFrame::GetXULBoxAscent(nsBoxLayoutS
 {
   if (!DoesNeedRecalc(mAscent))
      return mAscent;
 
 #ifdef DEBUG_LAYOUT
   PropagateDebug(aBoxLayoutState);
 #endif
 
-  if (IsCollapsed())
+  if (IsXULCollapsed())
     return 0;
 
   if (mLayoutManager)
     mAscent = mLayoutManager->GetAscent(this, aBoxLayoutState);
   else
     mAscent = nsBox::GetXULBoxAscent(aBoxLayoutState);
 
   return mAscent;
@@ -817,17 +817,17 @@ nsBoxFrame::GetXULMinSize(nsBoxLayoutSta
   if (!DoesNeedRecalc(mMinSize)) {
     return mMinSize;
   }
 
 #ifdef DEBUG_LAYOUT
   PropagateDebug(aBoxLayoutState);
 #endif
 
-  if (IsCollapsed())
+  if (IsXULCollapsed())
     return size;
 
   // if the size was not completely redefined in CSS then ask our children
   bool widthSet, heightSet;
   if (!nsIFrame::AddCSSMinSize(aBoxLayoutState, this, size, widthSet, heightSet))
   {
     if (mLayoutManager) {
       nsSize layoutSize = mLayoutManager->GetXULMinSize(this, aBoxLayoutState);
@@ -857,17 +857,17 @@ nsBoxFrame::GetXULMaxSize(nsBoxLayoutSta
   if (!DoesNeedRecalc(mMaxSize)) {
     return mMaxSize;
   }
 
 #ifdef DEBUG_LAYOUT
   PropagateDebug(aBoxLayoutState);
 #endif
 
-  if (IsCollapsed())
+  if (IsXULCollapsed())
     return size;
 
   // if the size was not completely redefined in CSS then ask our children
   bool widthSet, heightSet;
   if (!nsIFrame::AddCSSMaxSize(this, size, widthSet, heightSet))
   {
     if (mLayoutManager) {
       nsSize layoutSize = mLayoutManager->GetXULMaxSize(this, aBoxLayoutState);
@@ -1496,17 +1496,17 @@ nsBoxFrame::PaintXULDebugOverlay(DrawTar
         cr.x = inner.x;
         x = cr.y;
         y = cr.x + onePixel;
         spacerSize = debugBorder.left - onePixel*4;
     }
 
     nscoord flex = kid->GetXULFlex();
 
-    if (!kid->IsCollapsed()) {
+    if (!kid->IsXULCollapsed()) {
       if (isHorizontal) 
           borderSize = cr.width;
       else 
           borderSize = cr.height;
 
       DrawSpacer(GetPresContext(), aDrawTarget, isHorizontal, flex, x, y, borderSize, spacerSize);
     }
 
diff --git a/layout/xul/nsMenuFrame.cpp b/layout/xul/nsMenuFrame.cpp
--- a/layout/xul/nsMenuFrame.cpp
+++ b/layout/xul/nsMenuFrame.cpp
@@ -1337,17 +1337,17 @@ nsMenuFrame::AppendFrames(ChildListID   
     return;
 
   nsBoxFrame::AppendFrames(aListID, aFrameList); 
 }
 
 bool
 nsMenuFrame::SizeToPopup(nsBoxLayoutState& aState, nsSize& aSize)
 {
-  if (!IsCollapsed()) {
+  if (!IsXULCollapsed()) {
     bool widthSet, heightSet;
     nsSize tmpSize(-1, 0);
     nsIFrame::AddCSSPrefSize(this, tmpSize, widthSet, heightSet);
     if (!widthSet && GetXULFlex() == 0) {
       nsMenuPopupFrame* popupFrame = GetPopup();
       if (!popupFrame)
         return false;
       tmpSize = popupFrame->GetXULPrefSize(aState);
diff --git a/layout/xul/nsSprocketLayout.cpp b/layout/xul/nsSprocketLayout.cpp
--- a/layout/xul/nsSprocketLayout.cpp
+++ b/layout/xul/nsSprocketLayout.cpp
@@ -167,17 +167,17 @@ HandleBoxPack(nsIFrame* aBox, const nsFr
   }
 }
 
 NS_IMETHODIMP
 nsSprocketLayout::Layout(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   // See if we are collapsed. If we are, then simply iterate over all our
   // children and give them a rect of 0 width and height.
-  if (aBox->IsCollapsed()) {
+  if (aBox->IsXULCollapsed()) {
     nsIFrame* child = nsBox::GetChildBox(aBox);
     while(child) 
     {
       nsBoxFrame::LayoutChildAt(aState, child, nsRect(0,0,0,0));  
       child = nsBox::GetNextBox(child);
     }
     return NS_OK;
   }
@@ -700,17 +700,17 @@ nsSprocketLayout::PopulateBoxSizes(nsIFr
         currentBox->next      = new (aState) nsBoxSize();
         currentBox      = currentBox->next;
       }
     
 
       flex = child->GetXULFlex();
 
       currentBox->flex = flex;
-      currentBox->collapsed = child->IsCollapsed();
+      currentBox->collapsed = child->IsXULCollapsed();
     } else {
       flex = start->flex;
       start = start->next;
     }
     
     if (flex > 0) 
        aFlexes++;
    
@@ -732,17 +732,17 @@ nsSprocketLayout::PopulateBoxSizes(nsIFr
       last = currentBox;
       currentBox = currentBox->next;
     }
     ++childCount;
     nsSize pref(0,0);
     nsSize minSize(0,0);
     nsSize maxSize(NS_INTRINSICSIZE,NS_INTRINSICSIZE);
     nscoord ascent = 0;
-    bool collapsed = child->IsCollapsed();
+    bool collapsed = child->IsXULCollapsed();
 
     if (!collapsed) {
     // only one flexible child? Cool we will just make its preferred size
     // 0 then and not even have to ask for it.
     //if (flexes != 1)  {
 
       pref = child->GetXULPrefSize(aState);
       minSize = child->GetXULMinSize(aState);
@@ -1318,17 +1318,17 @@ nsSprocketLayout::GetXULPrefSize(nsIFram
    nsFrameState frameState = nsFrameState(0);
    GetFrameState(aBox, frameState);
    bool isEqual = !!(frameState & NS_STATE_EQUAL_SIZE);
    int32_t count = 0;
    
    while (child) 
    {  
       // ignore collapsed children
-      if (!child->IsCollapsed())
+      if (!child->IsXULCollapsed())
       {
         nsSize pref = child->GetXULPrefSize(aState);
         AddMargin(child, pref);
 
         if (isEqual) {
           if (isHorizontal)
           {
             if (pref.width > biggestPref)
@@ -1375,17 +1375,17 @@ nsSprocketLayout::GetXULMinSize(nsIFrame
    nsFrameState frameState = nsFrameState(0);
    GetFrameState(aBox, frameState);
    bool isEqual = !!(frameState & NS_STATE_EQUAL_SIZE);
    int32_t count = 0;
 
    while (child) 
    {  
        // ignore collapsed children
-      if (!child->IsCollapsed())
+      if (!child->IsXULCollapsed())
       {
         nsSize min = child->GetXULMinSize(aState);
         nsSize pref(0,0);
         
         // if the child is not flexible then
         // its min size is its pref size.
         if (child->GetXULFlex() == 0) {
             pref = child->GetXULPrefSize(aState);
@@ -1444,17 +1444,17 @@ nsSprocketLayout::GetXULMaxSize(nsIFrame
    nsFrameState frameState = nsFrameState(0);
    GetFrameState(aBox, frameState);
    bool isEqual = !!(frameState & NS_STATE_EQUAL_SIZE);
    int32_t count = 0;
 
    while (child) 
    {  
       // ignore collapsed children
-      if (!child->IsCollapsed())
+      if (!child->IsXULCollapsed())
       {
         // if completely redefined don't even ask our child for its size.
         nsSize min = child->GetXULMinSize(aState);
         nsSize max = nsBox::BoundsCheckMinMax(min, child->GetXULMaxSize(aState));
 
         AddMargin(child, max);
         AddSmallestSize(maxSize, max, isHorizontal);
 
@@ -1505,17 +1505,17 @@ nsSprocketLayout::GetAscent(nsIFrame* aB
    // run through all the children and get their min, max, and preferred sizes
    // return us the size of the box
    
    nsIFrame* child = nsBox::GetChildBox(aBox);
    
    while (child) 
    {  
       // ignore collapsed children
-      //if (!child->IsCollapsed())
+      //if (!child->IsXULCollapsed())
       //{
         // if completely redefined don't even ask our child for its size.
         nscoord ascent = child->GetXULBoxAscent(aState);
 
         nsMargin margin;
         child->GetMargin(margin);
         ascent += margin.top;
 
