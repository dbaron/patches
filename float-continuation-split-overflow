From: L. David Baron <dbaron@dbaron.org>

Split overflow areas for block frame float continuations.  (Bug 542595)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1010,17 +1010,17 @@ nsBlockFrame::Reflow(nsPresContext*     
 
   // Now that we're done cleaning up our overflow container lists, we can
   // give |state| its nsOverflowContinuationTracker.
   nsOverflowContinuationTracker tracker(aPresContext, this, PR_FALSE);
   state.mOverflowTracker = &tracker;
 
   // Drain & handle pushed floats
   DrainPushedFloats(state);
-  nsRect fcBounds;
+  nsRect fcBounds[2];
   nsReflowStatus fcStatus = NS_FRAME_COMPLETE;
   rv = ReflowPushedFloats(state, fcBounds, fcStatus);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // If we're not dirty (which means we'll mark everything dirty later)
   // and our width has changed, mark the lines dirty that we need to
   // mark dirty for a resize reflow.
   if (aReflowState.mFlags.mHResize)
@@ -1103,19 +1103,19 @@ nsBlockFrame::Reflow(nsPresContext*     
     // Otherwise just leave the bullet where it is, up against our top padding.
   }
 
   // Compute our final size
   nscoord bottomEdgeOfChildren;
   ComputeFinalSize(aReflowState, state, aMetrics, &bottomEdgeOfChildren);
   ComputeOverflowAreas(aReflowState, aMetrics, bottomEdgeOfChildren);
   // Factor overflow container child bounds into the overflow area
-  aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea, ocBounds);
+  aMetrics.UnionOverflowAreasWith(ocBounds);
   // Factor pushed float child bounds into the overflow area
-  aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea, fcBounds);
+  aMetrics.UnionOverflowAreasWith(fcBounds);
 
   // Let the absolutely positioned container reflow any absolutely positioned
   // child frames that need to be reflowed, e.g., elements with a percentage
   // based width/height
   // We want to do this under either of two conditions:
   //  1. If we didn't do the incremental reflow above.
   //  2. If our size changed.
   // Even though it's the padding edge that's the containing block, we
@@ -5892,18 +5892,18 @@ nsBlockFrame::FindTrailingClear()
       return endLine->GetBreakTypeAfter();
     }
   }
   return NS_STYLE_CLEAR_NONE;
 }
 
 nsresult
 nsBlockFrame::ReflowPushedFloats(nsBlockReflowState& aState,
-                                       nsRect&             aBounds,
-                                       nsReflowStatus&     aStatus)
+                                 nsRect              aBounds[2],
+                                 nsReflowStatus&     aStatus)
 {
   nsresult rv = NS_OK;
   for (nsIFrame* f = mFloats.FirstChild(), *next;
        f && (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT);
        f = next) {
     // save next sibling now, since reflowing could push the entire
     // float, changing its siblings
     next = f->GetNextSibling();
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -472,18 +472,18 @@ protected:
   /** Load all our floats into the float manager (without reflowing them).
    *  Assumes float manager is in our own coordinate system.
    */
   void RecoverFloats(nsFloatManager& aFloatManager);
 
   /** Reflow pushed floats
    */
   nsresult ReflowPushedFloats(nsBlockReflowState& aState,
-                                    nsRect&             aBounds,
-                                    nsReflowStatus&     aStatus);
+                              nsRect              aBounds[2],
+                              nsReflowStatus&     aStatus);
 
   /** Find any trailing BR clear from the last line of the block (or its PIFs)
    */
   PRUint8 FindTrailingClear();
 
   /**
     * Remove a float from our float list and also the float cache
     * for the line its placeholder is on.
