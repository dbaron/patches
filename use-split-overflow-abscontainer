From: L. David Baron <dbaron@dbaron.org>

Use split overflow areas in nsAbsoluteContainer::Reflow.  (Bug 542595)

diff --git a/layout/generic/nsAbsoluteContainingBlock.cpp b/layout/generic/nsAbsoluteContainingBlock.cpp
--- a/layout/generic/nsAbsoluteContainingBlock.cpp
+++ b/layout/generic/nsAbsoluteContainingBlock.cpp
@@ -133,36 +133,40 @@ nsAbsoluteContainingBlock::Reflow(nsCont
                                   nsPresContext*           aPresContext,
                                   const nsHTMLReflowState& aReflowState,
                                   nsReflowStatus&          aReflowStatus,
                                   nscoord                  aContainingBlockWidth,
                                   nscoord                  aContainingBlockHeight,
                                   PRBool                   aConstrainHeight,
                                   PRBool                   aCBWidthChanged,
                                   PRBool                   aCBHeightChanged,
-                                  nsRect*                  aChildBounds)
+                                  nsRect*                  aOverflowAreas)
 {
   // Initialize OUT parameter
-  if (aChildBounds)
-    aChildBounds->SetRect(0, 0, 0, 0);
+  if (aOverflowAreas) {
+    NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+      aOverflowAreas[otype].SetRect(0, 0, 0, 0);
+    }
+  }
   nsReflowStatus reflowStatus = NS_FRAME_COMPLETE;
 
   PRBool reflowAll = aReflowState.ShouldReflowAllKids();
 
   nsIFrame* kidFrame;
   nsOverflowContinuationTracker tracker(aPresContext, aDelegatingFrame, PR_TRUE);
   for (kidFrame = mAbsoluteFrames.FirstChild(); kidFrame; kidFrame = kidFrame->GetNextSibling()) {
     PRBool kidNeedsReflow = reflowAll || NS_SUBTREE_DIRTY(kidFrame) ||
       FrameDependsOnContainer(kidFrame, aCBWidthChanged, aCBHeightChanged);
     if (kidNeedsReflow && !aPresContext->HasPendingInterrupt()) {
       // Reflow the frame
       nsReflowStatus  kidStatus = NS_FRAME_COMPLETE;
       ReflowAbsoluteFrame(aDelegatingFrame, aPresContext, aReflowState,
                           aContainingBlockWidth, aContainingBlockHeight,
-                          aConstrainHeight, kidFrame, kidStatus, aChildBounds);
+                          aConstrainHeight, kidFrame, kidStatus,
+                          aOverflowAreas);
       nsIFrame* nextFrame = kidFrame->GetNextInFlow();
       if (!NS_FRAME_IS_FULLY_COMPLETE(kidStatus)) {
         // Need a continuation
         if (!nextFrame) {
           nsresult rv = aPresContext->PresShell()->FrameConstructor()->
             CreateContinuingFrame(aPresContext, kidFrame, aDelegatingFrame, &nextFrame);
           NS_ENSURE_SUCCESS(rv, rv);
         }
@@ -179,19 +183,22 @@ nsAbsoluteContainingBlock::Reflow(nsCont
           tracker.Finish(kidFrame);
           static_cast<nsContainerFrame*>(nextFrame->GetParent())
             ->DeleteNextInFlowChild(aPresContext, nextFrame, PR_TRUE);
         }
       }
     }
     else {
       tracker.Skip(kidFrame, reflowStatus);
-      if (aChildBounds) {
-        aChildBounds->UnionRect(*aChildBounds, kidFrame->GetOverflowRect() +
-                                               kidFrame->GetPosition());
+      if (aOverflowAreas) {
+        NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+          aOverflowAreas[otype].UnionRect(aOverflowAreas[otype],
+                                          kidFrame->GetOverflowRect(otype) +
+                                            kidFrame->GetPosition());
+        }
       }
     }
 
     // Make a CheckForInterrupt call, here, not just HasPendingInterrupt.  That
     // will make sure that we end up reflowing aDelegatingFrame in cases when
     // one of our kids interrupted.  Otherwise we'd set the dirty or
     // dirty-children bit on the kid in the condition below, and then when
     // reflow completes and we go to mark dirty bits on all ancestors of that
@@ -371,17 +378,17 @@ nsresult
 nsAbsoluteContainingBlock::ReflowAbsoluteFrame(nsIFrame*                aDelegatingFrame,
                                                nsPresContext*          aPresContext,
                                                const nsHTMLReflowState& aReflowState,
                                                nscoord                  aContainingBlockWidth,
                                                nscoord                  aContainingBlockHeight,
                                                PRBool                   aConstrainHeight,
                                                nsIFrame*                aKidFrame,
                                                nsReflowStatus&          aStatus,
-                                               nsRect*                  aChildBounds)
+                                               nsRect*                  aOverflowAreas)
 {
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
     nsFrame::IndentBy(stdout,nsBlockFrame::gNoiseIndent);
     printf("abs pos ");
     if (aKidFrame) {
       nsAutoString name;
       aKidFrame->GetFrameName(name);
@@ -482,18 +489,17 @@ nsAbsoluteContainingBlock::ReflowAbsolut
                kidDesiredSize.width, kidDesiredSize.height);
   aKidFrame->SetRect(rect);
 
   nsIView* view = aKidFrame->GetView();
   if (view) {
     // Size and position the view and set its opacity, visibility, content
     // transparency, and clip
     nsContainerFrame::SyncFrameViewAfterReflow(aPresContext, aKidFrame,
-                                               view,
-                                               &kidDesiredSize.mOverflowArea);
+                        view, kidDesiredSize.mOverflowAreas[eVisualOverflow]);
   } else {
     nsContainerFrame::PositionChildViews(aKidFrame);
   }
 
   if (oldRect.TopLeft() != rect.TopLeft() || 
       (aDelegatingFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
     // The frame moved
     aKidFrame->GetParent()->Invalidate(oldOverflowRect);
@@ -521,19 +527,23 @@ nsAbsoluteContainingBlock::ReflowAbsolut
       aKidFrame->GetFrameName(name);
       printf("%s ", NS_LossyConvertUTF16toASCII(name).get());
     }
     printf("%p rect=%d,%d,%d,%d\n", static_cast<void*>(aKidFrame),
            rect.x, rect.y, rect.width, rect.height);
   }
 #endif
 
-  if (aChildBounds)
-    aChildBounds->UnionRect(*aChildBounds, kidDesiredSize.mOverflowArea +
-                                           rect.TopLeft());
+  if (aOverflowAreas) {
+    NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+      aOverflowAreas[otype].UnionRect(aOverflowAreas[otype],
+                                      kidDesiredSize.mOverflowAreas[otype] +
+                                        rect.TopLeft());
+    }
+  }
 
   return rv;
 }
 
 #ifdef DEBUG
  void nsAbsoluteContainingBlock::PrettyUC(nscoord aSize,
                         char*   aBuf)
 {
diff --git a/layout/generic/nsAbsoluteContainingBlock.h b/layout/generic/nsAbsoluteContainingBlock.h
--- a/layout/generic/nsAbsoluteContainingBlock.h
+++ b/layout/generic/nsAbsoluteContainingBlock.h
@@ -99,33 +99,32 @@ public:
   void RemoveFrame(nsIFrame*      aDelegatingFrame,
                    nsIAtom*       aListName,
                    nsIFrame*      aOldFrame);
 
   // Called by the delegating frame after it has done its reflow first. This
   // function will reflow any absolutely positioned child frames that need to
   // be reflowed, e.g., because the absolutely positioned child frame has
   // 'auto' for an offset, or a percentage based width or height.
-  // If aChildBounds is set, it returns (in the local coordinate space) the 
-  // bounding rect of the absolutely positioned child elements taking into 
-  // account their overflow area (if it is visible).
+  // If aOverflowAreas is set, it returns (in the local coordinate space) the
+  // two overflow areas of the absolutely positioned children.
   // @param aForceReflow if this is false, reflow for some absolutely
   //        positioned frames may be skipped based on whether they use
   //        placeholders for positioning and on whether the containing block
   //        width or height changed.
   nsresult Reflow(nsContainerFrame*        aDelegatingFrame,
                   nsPresContext*           aPresContext,
                   const nsHTMLReflowState& aReflowState,
                   nsReflowStatus&          aReflowStatus,
                   nscoord                  aContainingBlockWidth,
                   nscoord                  aContainingBlockHeight,
                   PRBool                   aConstrainHeight,
                   PRBool                   aCBWidthChanged,
                   PRBool                   aCBHeightChanged,
-                  nsRect*                  aChildBounds = nsnull);
+                  nsRect*                  aOverflowAreas = nsnull);
 
 
   void DestroyFrames(nsIFrame* aDelegatingFrame,
                      nsIFrame* aDestructRoot);
 
   PRBool  HasAbsoluteFrames() {return mAbsoluteFrames.NotEmpty();}
 
   // Mark our size-dependent absolute frames with NS_FRAME_HAS_DIRTY_CHILDREN
@@ -145,17 +144,17 @@ protected:
   nsresult ReflowAbsoluteFrame(nsIFrame*                aDelegatingFrame,
                                nsPresContext*          aPresContext,
                                const nsHTMLReflowState& aReflowState,
                                nscoord                  aContainingBlockWidth,
                                nscoord                  aContainingBlockHeight,
                                PRBool                   aConstrainHeight,
                                nsIFrame*                aKidFrame,
                                nsReflowStatus&          aStatus,
-                               nsRect*                  aChildBounds);
+                               nsRect*                  aOverflowAreas);
 
   // Mark our absolute frames dirty.  If aMarkAllDirty is true, all will be
   // marked with NS_FRAME_IS_DIRTY.  Otherwise, the size-dependant ones will be
   // marked with NS_FRAME_HAS_DIRTY_CHILDREN.
   void DoMarkFramesDirty(PRBool aMarkAllDirty);
 
 protected:
   nsFrameList mAbsoluteFrames;  // additional named child list
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1140,17 +1140,17 @@ nsBlockFrame::Reflow(nsPresContext*     
       // better than that, because we don't really know what our size will be,
       // and it might in fact not change on the followup reflow!
       if (haveInterrupt && (GetStateBits() & NS_FRAME_IS_DIRTY)) {
         mAbsoluteContainer.MarkAllFramesDirty();
       } else {
         mAbsoluteContainer.MarkSizeDependentFramesDirty();
       }
     } else {
-      nsRect childBounds;
+      nsRect childBounds[2];
       nsSize containingBlockSize =
         CalculateContainingBlockSizeForAbsolutes(aReflowState,
                                                  nsSize(aMetrics.width,
                                                         aMetrics.height));
 
       // Mark frames that depend on changes we just made to this frame as dirty:
       // Now we can assume that the padding edge hasn't moved.
       // We need to reflow the absolutes if one of them depends on
@@ -1167,22 +1167,22 @@ nsBlockFrame::Reflow(nsPresContext*     
         !(isRoot && NS_UNCONSTRAINEDSIZE == aReflowState.ComputedHeight()) &&
         aMetrics.height != oldSize.height;
 
       rv = mAbsoluteContainer.Reflow(this, aPresContext, aReflowState,
                                      state.mReflowStatus,
                                      containingBlockSize.width,
                                      containingBlockSize.height, PR_TRUE,
                                      cbWidthChanged, cbHeightChanged,
-                                     &childBounds);
+                                     childBounds);
 
       //XXXfr Why isn't this rv (and others in this file) checked/returned?
 
       // Factor the absolutely positioned child bounds into the overflow area
-      aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea, childBounds);
+      aMetrics.UnionOverflowAreasWith(childBounds);
     }
   }
 
   // Determine if we need to repaint our border, background or outline
   CheckInvalidateSizeChange(aMetrics);
 
   FinishAndStoreOverflow(&aMetrics);
 
diff --git a/layout/generic/nsCanvasFrame.cpp b/layout/generic/nsCanvasFrame.cpp
--- a/layout/generic/nsCanvasFrame.cpp
+++ b/layout/generic/nsCanvasFrame.cpp
@@ -550,22 +550,22 @@ nsCanvasFrame::Reflow(nsPresContext*    
 
     aDesiredSize.mOverflowArea.UnionRect(
       nsRect(0, 0, aDesiredSize.width, aDesiredSize.height),
       kidDesiredSize.mOverflowArea + kidPt);
 
     if (mAbsoluteContainer.HasAbsoluteFrames()) {
       PRBool widthChanged = aDesiredSize.width != mRect.width;
       PRBool heightChanged = aDesiredSize.height != mRect.height;
-      nsRect absPosBounds;
+      nsRect absPosBounds[2];
       mAbsoluteContainer.Reflow(this, aPresContext, aReflowState, aStatus,
                                 aDesiredSize.width, aDesiredSize.height,
                                 PR_TRUE, widthChanged, heightChanged,
                                 &absPosBounds);
-      aDesiredSize.mOverflowArea.UnionRect(aDesiredSize.mOverflowArea, absPosBounds);
+      aDesiredSize.UnionOverflowAreasWith(absPosBounds);
     }
 
     // Handle invalidating fixed-attachment backgrounds propagated to the
     // canvas when the canvas size (and therefore the background positioning
     // area's size) changes.  Such backgrounds are not invalidated in the
     // normal manner because the size of the original frame for that background
     // may not have changed.
     //
diff --git a/layout/generic/nsInlineFrame.cpp b/layout/generic/nsInlineFrame.cpp
--- a/layout/generic/nsInlineFrame.cpp
+++ b/layout/generic/nsInlineFrame.cpp
@@ -1260,20 +1260,24 @@ nsPositionedInlineFrame::Reflow(nsPresCo
     // The containing block for the abs pos kids is formed by our padding edge.
     nsMargin computedBorder =
       aReflowState.mComputedBorderPadding - aReflowState.mComputedPadding;
     nscoord containingBlockWidth =
       aDesiredSize.width - computedBorder.LeftRight();
     nscoord containingBlockHeight =
       aDesiredSize.height - computedBorder.TopBottom();
 
+    // REVIEW: This was very wrong before!
+    nsRect overflowAreas[2];
+
     // Factor the absolutely positioned child bounds into the overflow area
     // Don't include this frame's bounds, nor its inline descendants' bounds,
     // and don't store the overflow property.
     // That will all be done by nsLineLayout::RelativePositionFrames.
     rv = mAbsoluteContainer.Reflow(this, aPresContext, aReflowState, aStatus,
                                    containingBlockWidth, containingBlockHeight,
                                    PR_TRUE, PR_TRUE, PR_TRUE, // XXX could be optimized
-                                   &aDesiredSize.mOverflowArea);
+                                   overflowAreas);
+    aDesiredSize.UnionOverflowAreasWith(overflowAreas);
   }
 
   return rv;
 }
diff --git a/layout/generic/nsPageContentFrame.cpp b/layout/generic/nsPageContentFrame.cpp
--- a/layout/generic/nsPageContentFrame.cpp
+++ b/layout/generic/nsPageContentFrame.cpp
@@ -131,16 +131,17 @@ nsPageContentFrame::Reflow(nsPresContext
 
     // Place and size the child
     FinishReflowChild(frame, aPresContext, &kidReflowState, aDesiredSize, 0, 0, 0);
 
     NS_ASSERTION(aPresContext->IsDynamic() || !NS_FRAME_IS_FULLY_COMPLETE(aStatus) ||
                   !frame->GetNextInFlow(), "bad child flow list");
   }
   // Reflow our fixed frames 
+  // FIXME: Should we include their overflow areas in ours?
   nsReflowStatus fixedStatus = NS_FRAME_COMPLETE;
   mFixedContainer.Reflow(this, aPresContext, aReflowState, fixedStatus,
                          aReflowState.availableWidth,
                          aReflowState.availableHeight,
                          PR_FALSE, PR_TRUE, PR_TRUE); // XXX could be optimized
   NS_ASSERTION(NS_FRAME_IS_COMPLETE(fixedStatus), "fixed frames can be truncated, but not incomplete");
 
   // Return our desired size
