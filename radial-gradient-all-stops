From: L. David Baron <dbaron@dbaron.org>

Correctly handle non-repeating radial gradients in which all stops are at the same position.  (Bug 635222)

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -2073,20 +2073,21 @@ nsCSSRendering::PaintGradient(nsPresCont
   // stop positions will be normalized below by subtracting firstStop and then
   // multiplying by stopScale.
   double stopScale;
   double stopDelta = lastStop - firstStop;
   if (stopDelta < 1e-6 || lineLength < 1e-6 ||
       (aGradient->mShape != NS_STYLE_GRADIENT_SHAPE_LINEAR &&
        (radiusX < 1e-6 || radiusY < 1e-6))) {
     // Stops are all at the same place. Map all stops to 0.0.
-    // For radial gradients we need to fill with the last stop color,
-    // so just set both radii to 0.
+    // For repeating radial gradients we need to fill with the last stop
+    // color, so just set both radii to 0.
     stopScale = 0.0;
-    radiusX = radiusY = 0.0;
+    if (aGradient->mRepeating)
+      radiusX = radiusY = 0.0;
     lastStop = firstStop;
   } else {
     stopScale = 1.0/stopDelta;
   }
 
   // Create the gradient pattern.
   nsRefPtr<gfxPattern> gradientPattern;
   if (aGradient->mShape == NS_STYLE_GRADIENT_SHAPE_LINEAR) {
@@ -2110,16 +2111,21 @@ nsCSSRendering::PaintGradient(nsPresCont
   } else {
     NS_ASSERTION(firstStop >= 0.0,
                  "Negative stops not allowed for radial gradients");
 
     // To form an ellipse, we'll stretch a circle vertically, if necessary.
     // So our radii are based on radiusX.
     double innerRadius = radiusX*firstStop;
     double outerRadius = radiusX*lastStop;
+    if (stopScale == 0.0) {
+      // Stops are all at the same place.  See above (except we now have
+      // the inside vs. outside of an ellipse).
+      outerRadius = innerRadius + 1;
+    }
     gradientPattern = new gfxPattern(lineStart.x, lineStart.y, innerRadius,
                                      lineStart.x, lineStart.y, outerRadius);
     if (gradientPattern && radiusX != radiusY) {
       // Stretch the circles into ellipses vertically by setting a transform
       // in the pattern.
       // Recall that this is the transform from user space to pattern space.
       // So to stretch the ellipse by factor of P vertically, we scale
       // user coordinates by 1/P.
