From: L. David Baron <dbaron@dbaron.org>

Only allow escaped newlines inside strings (which includes url() tokens that contain strings).  (Bug 384672, patch 4)

diff --git a/layout/style/nsCSSScanner.cpp b/layout/style/nsCSSScanner.cpp
--- a/layout/style/nsCSSScanner.cpp
+++ b/layout/style/nsCSSScanner.cpp
@@ -1008,23 +1008,24 @@ nsCSSScanner::NextURL(nsCSSToken& aToken
 
 /**
  * Returns whether an escape was succesfully parsed; if it was not,
  * the backslash needs to be its own symbol token.
  */
 PRBool
 nsCSSScanner::ParseAndAppendEscape(nsString& aOutput, PRBool aInString)
 {
-  PRInt32 ch = Peek();
+  PRInt32 ch = Read();
   if (ch < 0) {
     return PR_FALSE;
   }
   if (IsHexDigit(ch)) {
     PRInt32 rv = 0;
     int i;
+    Pushback(ch);
     for (i = 0; i < 6; i++) { // up to six digits
       ch = Read();
       if (ch < 0) {
         // Whoops: error or premature eof
         break;
       }
       if (!IsHexDigit(ch) && !IsWhitespace(ch)) {
         Pushback(ch);
@@ -1061,18 +1062,26 @@ nsCSSScanner::ParseAndAppendEscape(nsStr
       if (IsWhitespace(ch))
         Pushback(ch);
     }
     return PR_TRUE;
   } 
   // "Any character except a hexidecimal digit can be escaped to
   // remove its special meaning by putting a backslash in front"
   // -- CSS1 spec section 7.1
-  ch = Read();  // Consume the escaped character
-  if ((ch > 0) && (ch != '\n')) {
+  if (ch == '\n') {
+    if (!aInString) {
+      // Outside of strings (which includes url() that contains a
+      // string), escaped newlines aren't special, and just tokenize as
+      // eCSSToken_Symbol (DELIM).
+      return PR_FALSE;
+    }
+    // In strings (and in url() containing a string), escaped newlines
+    // are just dropped to allow splitting over multiple lines.
+  } else {
     aOutput.Append(ch);
   }
 
   return PR_TRUE;
 }
 
 /**
  * Gather up the characters in an identifier. The identfier was
diff --git a/layout/style/test/test_parse_rule.html b/layout/style/test/test_parse_rule.html
--- a/layout/style/test/test_parse_rule.html
+++ b/layout/style/test/test_parse_rule.html
@@ -126,18 +126,17 @@ base + "/* #a {color: red} */",
 base + "#a {color: rgb(255, 0, 0%)}",
 base + "#a {color: rgb(100%, 0, 0)}",
 base + "#a {color: rgb(255.0, 0, 0)}",
 "#a {color: rgb(0, 128, 0)}",
 "#a {color: rgb(0%, 50%, 0%)}",
 "#a {color: rgb(0%, 49.999999999999%, 0%)}",
 ], prop: "color", pseudo: "",
 todo: {
-       "div[title~='weeqweqeweasd\\D\\A a']{color:green}" : 1,
-       "div {color:green}#a\\\n{color:red}" : 1
+       "div[title~='weeqweqeweasd\\D\\A a']{color:green}" : 1
       }
 },
 
 // Border tests
 // For testing lengths
 { base : base = "#a {border-style:solid}",
   tests : [
 // CSS1 section 7.1
diff --git a/layout/style/test/test_parse_url.html b/layout/style/test/test_parse_url.html
--- a/layout/style/test/test_parse_url.html
+++ b/layout/style/test/test_parse_url.html
@@ -175,12 +175,19 @@ div.style.listStyleImage = 'url(goo\\d)'
 is(div.style.listStyleImage, 'url("goo\\D ")', "URL allowed");
 div.style.listStyleImage = 'url(go\\o)';
 is(div.style.listStyleImage, 'url("goo")', "URL allowed");
 
 div.setAttribute("style", "color: url(/*); color: green");
 is(div.style.color, 'green',
    "URL tokenized correctly outside properties taking URLs");
 
+div.style.listStyleImage = 'url("foo\\\nbar1")';
+is(div.style.listStyleImage, 'url("foobar1")',
+   "escaped newline allowed in string form of URL");
+div.style.listStyleImage = 'url(foo\\\nbar2)';
+is(div.style.listStyleImage, 'url("foobar1")',
+   "escaped newline NOT allowed in NON-string form of URL");
+
 </script>
 </pre>
 </body>
 </html>
diff --git a/layout/style/test/test_selectors.html b/layout/style/test/test_selectors.html
--- a/layout/style/test/test_selectors.html
+++ b/layout/style/test/test_selectors.html
@@ -913,16 +913,23 @@ function run() {
     test_balanced_unparseable("p #");
     test_balanced_unparseable("p # ");
     test_balanced_unparseable("p #, p");
     test_balanced_unparseable("p # , p");
 
     // Test that a backslash alone is not treated as an escape.
     test_unparseable_via_api("#\\");
 
+    // Test that newline escapes are only supported in strings.
+    test_balanced_unparseable("di\\\nv");
+    test_balanced_unparseable("div \\\n p");
+    test_balanced_unparseable("div\\\n p");
+    test_balanced_unparseable("div \\\np");
+    test_balanced_unparseable("div\\\np");
+
     run_deferred_tests();
 }
 
 var deferred_tests = [];
 
 function defer_clonedoc_tests(docurl, onloadfunc)
 {
     deferred_tests.push( { docurl: docurl, onloadfunc: onloadfunc } );
