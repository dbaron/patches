From: L. David Baron <dbaron@dbaron.org>

Avoid early return from nsImageFrame::BuildDisplayList, so we don't go blank for some selection cases.  (Bug 599368)

diff --git a/layout/generic/nsImageFrame.cpp b/layout/generic/nsImageFrame.cpp
--- a/layout/generic/nsImageFrame.cpp
+++ b/layout/generic/nsImageFrame.cpp
@@ -1306,22 +1306,37 @@ nsImageFrame::BuildDisplayList(nsDisplay
             nsDisplayGeneric(aBuilder, this, PaintDebugImageMap, "DebugImageMap",
                              nsDisplayItem::TYPE_DEBUG_IMAGE_MAP));
         NS_ENSURE_SUCCESS(rv, rv);
       }
 #endif
     }
   }
 
+  if (ShouldDisplaySelection()) {
+    rv = DisplaySelectionOverlay(aBuilder, &replacedContent,
+                                 nsISelectionDisplay::DISPLAY_IMAGES);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
+  WrapReplacedContentForBorderRadius(aBuilder, &replacedContent, aLists);
+
+  return NS_OK;
+}
+
+
+bool
+nsImageFrame::ShouldDisplaySelection()
+{
   // XXX what on EARTH is this code for?
   nsresult result;
   nsPresContext* presContext = PresContext();
   PRInt16 displaySelection = presContext->PresShell()->GetSelectionFlags();
   if (!(displaySelection & nsISelectionDisplay::DISPLAY_IMAGES))
-    return NS_OK;//no need to check the blue border, we cannot be drawn selected
+    return false;//no need to check the blue border, we cannot be drawn selected
 //insert hook here for image selection drawing
 #if IMAGE_EDITOR_CHECK
   //check to see if this frame is in an editor context
   //isEditor check. this needs to be changed to have better way to check
   if (displaySelection == nsISelectionDisplay::DISPLAY_ALL) 
   {
     nsCOMPtr<nsISelectionController> selCon;
     result = GetSelectionController(presContext, getter_AddRefs(selCon));
@@ -1349,33 +1364,26 @@ nsImageFrame::BuildDisplayList(nsDisplay
               range->GetStartContainer(getter_AddRefs(rangeNode));
               range->GetStartOffset(&rangeOffset);
 
               if (parentNode && rangeNode && (rangeNode == parentNode) && rangeOffset == thisOffset)
               {
                 range->GetEndContainer(getter_AddRefs(rangeNode));
                 range->GetEndOffset(&rangeOffset);
                 if ((rangeNode == parentNode) && (rangeOffset == (thisOffset +1))) //+1 since that would mean this whole content is selected only
-                  return NS_OK; //do not allow nsFrame do draw any further selection
+                  return false; //do not allow nsFrame do draw any further selection
               }
             }
           }
         }
       }
     }
   }
 #endif
-  
-  rv = DisplaySelectionOverlay(aBuilder, &replacedContent,
-                               nsISelectionDisplay::DISPLAY_IMAGES);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  WrapReplacedContentForBorderRadius(aBuilder, &replacedContent, aLists);
-
-  return NS_OK;
+  return true;
 }
 
 NS_IMETHODIMP
 nsImageFrame::GetImageMap(nsPresContext *aPresContext, nsIImageMap **aImageMap)
 {
   nsImageMap *map = GetImageMap(aPresContext);
   return CallQueryInterface(map, aImageMap);
 }
diff --git a/layout/generic/nsImageFrame.h b/layout/generic/nsImageFrame.h
--- a/layout/generic/nsImageFrame.h
+++ b/layout/generic/nsImageFrame.h
@@ -234,16 +234,17 @@ private:
   // random helpers
   inline void SpecToURI(const nsAString& aSpec, nsIIOService *aIOService,
                         nsIURI **aURI);
 
   inline void GetLoadGroup(nsPresContext *aPresContext,
                            nsILoadGroup **aLoadGroup);
   nscoord GetContinuationOffset() const;
   void GetDocumentCharacterSet(nsACString& aCharset) const;
+  bool ShouldDisplaySelection();
 
   /**
    * Recalculate mIntrinsicSize from the image.
    *
    * @return whether aImage's size did _not_
    *         match our previous intrinsic size.
    */
   PRBool UpdateIntrinsicSize(imgIContainer* aImage);
