From: L. David Baron <dbaron@dbaron.org>

Avoid early return from nsImageFrame::BuildDisplayList, so we don't go blank for some selection cases.  (Bug 599368)

diff --git a/layout/generic/nsImageFrame.cpp b/layout/generic/nsImageFrame.cpp
--- a/layout/generic/nsImageFrame.cpp
+++ b/layout/generic/nsImageFrame.cpp
@@ -1306,22 +1306,37 @@ nsImageFrame::BuildDisplayList(nsDisplay
             nsDisplayGeneric(aBuilder, this, PaintDebugImageMap, "DebugImageMap",
                              nsDisplayItem::TYPE_DEBUG_IMAGE_MAP));
         NS_ENSURE_SUCCESS(rv, rv);
       }
 #endif
     }
   }
 
+  if (ShouldDisplaySelection()) {
+    rv = DisplaySelectionOverlay(aBuilder, &replacedContent,
+                                 nsISelectionDisplay::DISPLAY_IMAGES);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
+  WrapReplacedContentForBorderRadius(aBuilder, &replacedContent, aLists);
+
+  return NS_OK;
+}
+
+
+bool
+nsImageFrame::ShouldDisplaySelection()
+{
   // XXX what on EARTH is this code for?
   nsresult result;
   nsPresContext* presContext = PresContext();
   PRInt16 displaySelection = presContext->PresShell()->GetSelectionFlags();
   if (!(displaySelection & nsISelectionDisplay::DISPLAY_IMAGES))
-    return NS_OK;//no need to check the blue border, we cannot be drawn selected
+    return false;//no need to check the blue border, we cannot be drawn selected
 //insert hook here for image selection drawing
 #if IMAGE_EDITOR_CHECK
   //check to see if this frame is in an editor context
   //isEditor check. this needs to be changed to have better way to check
   if (displaySelection == nsISelectionDisplay::DISPLAY_ALL) 
   {
     nsCOMPtr<nsISelectionController> selCon;
     result = GetSelectionController(presContext, getter_AddRefs(selCon));
@@ -1349,33 +1364,26 @@ nsImageFrame::BuildDisplayList(nsDisplay
               range->GetStartContainer(getter_AddRefs(rangeNode));
               range->GetStartOffset(&rangeOffset);
 
               if (parentNode && rangeNode && (rangeNode == parentNode) && rangeOffset == thisOffset)
               {
                 range->GetEndContainer(getter_AddRefs(rangeNode));
                 range->GetEndOffset(&rangeOffset);
                 if ((rangeNode == parentNode) && (rangeOffset == (thisOffset +1))) //+1 since that would mean this whole content is selected only
-                  return NS_OK; //do not allow nsFrame do draw any further selection
+                  return false; //do not allow nsFrame do draw any further selection
               }
             }
           }
         }
       }
     }
   }
 #endif
-  
-  rv = DisplaySelectionOverlay(aBuilder, &replacedContent,
-                               nsISelectionDisplay::DISPLAY_IMAGES);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  WrapReplacedContentForBorderRadius(aBuilder, &replacedContent, aLists);
-
-  return NS_OK;
+  return true;
 }
 
 NS_IMETHODIMP
 nsImageFrame::GetImageMap(nsPresContext *aPresContext, nsIImageMap **aImageMap)
 {
   nsImageMap *map = GetImageMap(aPresContext);
   return CallQueryInterface(map, aImageMap);
 }
diff --git a/layout/generic/nsImageFrame.h b/layout/generic/nsImageFrame.h
--- a/layout/generic/nsImageFrame.h
+++ b/layout/generic/nsImageFrame.h
@@ -234,16 +234,17 @@ private:
   // random helpers
   inline void SpecToURI(const nsAString& aSpec, nsIIOService *aIOService,
                         nsIURI **aURI);
 
   inline void GetLoadGroup(nsPresContext *aPresContext,
                            nsILoadGroup **aLoadGroup);
   nscoord GetContinuationOffset() const;
   void GetDocumentCharacterSet(nsACString& aCharset) const;
+  bool ShouldDisplaySelection();
 
   /**
    * Recalculate mIntrinsicSize from the image.
    *
    * @return whether aImage's size did _not_
    *         match our previous intrinsic size.
    */
   PRBool UpdateIntrinsicSize(imgIContainer* aImage);
diff --git a/layout/generic/test/Makefile.in b/layout/generic/test/Makefile.in
--- a/layout/generic/test/Makefile.in
+++ b/layout/generic/test/Makefile.in
@@ -91,16 +91,17 @@ _TEST_FILES = \
 		test_bug470212.html \
 		test_bug496275.html \
 		test_bug503813.html \
 		test_bug508115.xul \
 		$(warning test_bug507902.html temporarily disabled - see bug 510001) \
 		test_bug514732.html \
 		test_bug527306.html \
 		test_bug597333.html \
+		test_image_selection.html \
 		test_invalidate_during_plugin_paint.html \
 		test_movement_by_characters.html \
 		test_movement_by_words.html \
 		test_plugin_clipping.xhtml \
 		test_plugin_clipping2.xhtml \
 		test_plugin_clipping_transformed.xhtml \
 		test_plugin_clipping_table.xhtml \
 		test_plugin_focus.html \
diff --git a/layout/generic/test/test_image_selection.html b/layout/generic/test/test_image_selection.html
new file mode 100644
--- /dev/null
+++ b/layout/generic/test/test_image_selection.html
@@ -0,0 +1,56 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=599368
+-->
+<head>
+  <title>Test for Bug 599368</title>
+  <script type="application/javascript" src="/MochiKit/packed.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/EventUtils.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/WindowSnapshot.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=599368">Mozilla Bug 599368</a>
+<iframe id="display" src="about:blank"></iframe>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 599368 **/
+
+SimpleTest.waitForExplicitFinish();
+
+window.addEventListener("load", step1, false);
+
+var gImage;
+var gIframe;
+
+function step1()
+{
+  gIframe = document.getElementById("display");
+  doc = gIframe.contentDocument;
+
+  gImage = doc.createElement('img');
+  var src = String(window.location).split("/");
+  src.pop();
+  src.push("file_Dolske.png");
+  src = src.join("/");
+  gImage.src = src;
+  doc.body.appendChild(gImage);
+
+  doc.designMode = "on";
+  setTimeout(step2, 0);
+}
+
+function step2() {
+  synthesizeMouse(gImage, 5, 5, {}, gIframe.contentWindow);
+}
+
+</script>
+</pre>
+</body>
+</html>
