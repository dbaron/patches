From: L. David Baron <dbaron@dbaron.org>

Reference-count CSS data blocks and make them immutable when their reference count is above 1.  (Bug 522595)

diff --git a/layout/style/nsCSSDataBlock.cpp b/layout/style/nsCSSDataBlock.cpp
--- a/layout/style/nsCSSDataBlock.cpp
+++ b/layout/style/nsCSSDataBlock.cpp
@@ -539,23 +539,25 @@ nsCSSCompressedDataBlock::Destroy()
                 cursor += CDBPointerStorage_advance;
             } break;
         }
     }
     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
     delete this;
 }
 
-/* static */ nsCSSCompressedDataBlock*
+/* static */ already_AddRefed<nsCSSCompressedDataBlock>
 nsCSSCompressedDataBlock::CreateEmptyBlock()
 {
     nsCSSCompressedDataBlock *result = new(0) nsCSSCompressedDataBlock();
     if (!result)
         return nsnull;
     result->mBlockEnd = result->Block();
+
+    result->AddRef();
     return result;
 }
 
 /*****************************************************************************/
 
 nsCSSExpandedDataBlock::nsCSSExpandedDataBlock()
 {
     AssertInitialState();
@@ -579,29 +581,41 @@ nsCSSExpandedDataBlock::kOffsetTable[eCS
           offsetof(nsRuleData, m##datastruct_##Data),                          \
           offsetof(nsRuleData##datastruct_, member_) },
     #include "nsCSSPropList.h"
     #undef CSS_PROP
     #undef CSS_PROP_BACKENDONLY
 };
 
 void
-nsCSSExpandedDataBlock::DoExpand(nsCSSCompressedDataBlock *aBlock,
+nsCSSExpandedDataBlock::DoExpand(nsRefPtr<nsCSSCompressedDataBlock> *aBlock,
                                  PRBool aImportant)
 {
-    NS_PRECONDITION(aBlock, "unexpected null block");
+    NS_PRECONDITION(*aBlock, "unexpected null block");
+
+    if (!(*aBlock)->IsMutable()) {
+        // FIXME (maybe): We really don't need to clone the block
+        // itself, just all the data inside it.
+        *aBlock = (*aBlock)->Clone();
+        if (!aBlock) {
+            // Not much we can do; just lose the properties.
+            NS_WARNING("out of memory");
+            return;
+        }
+        NS_ABORT_IF_FALSE((*aBlock)->IsMutable(), "we just cloned it");
+    }
 
     /*
      * Save needless copying and allocation by copying the memory
      * corresponding to the stored data in the compressed block, and
      * then, to avoid destructors, deleting the compressed block by
      * calling |delete| instead of using its |Destroy| method.
      */
-    const char* cursor = aBlock->Block();
-    const char* cursor_end = aBlock->BlockEnd();
+    const char* cursor = (*aBlock)->Block();
+    const char* cursor_end = (*aBlock)->BlockEnd();
     while (cursor < cursor_end) {
         nsCSSProperty iProp = PropertyAtCursor(cursor);
         NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
                      "out of range");
         NS_ASSERTION(!HasPropertyBit(iProp),
                      "compressed block has property multiple times");
         SetPropertyBit(iProp);
         if (aImportant)
@@ -658,31 +672,31 @@ nsCSSExpandedDataBlock::DoExpand(nsCSSCo
                 NS_ASSERTION(!*dest, "expanding into non-empty block");
                 *dest = val;
                 cursor += CDBPointerStorage_advance;
             } break;
         }
     }
     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
 
-    delete aBlock;
+    NS_ASSERTION((*aBlock)->mRefCnt == 1, "unexpected reference count");
+    delete aBlock->forget().get();
 }
 
 void
-nsCSSExpandedDataBlock::Expand(nsCSSCompressedDataBlock **aNormalBlock,
-                               nsCSSCompressedDataBlock **aImportantBlock)
+nsCSSExpandedDataBlock::Expand(
+                          nsRefPtr<nsCSSCompressedDataBlock> *aNormalBlock,
+                          nsRefPtr<nsCSSCompressedDataBlock> *aImportantBlock)
 {
     NS_PRECONDITION(*aNormalBlock, "unexpected null block");
     AssertInitialState();
 
-    DoExpand(*aNormalBlock, PR_FALSE);
-    *aNormalBlock = nsnull;
+    DoExpand(aNormalBlock, PR_FALSE);
     if (*aImportantBlock) {
-        DoExpand(*aImportantBlock, PR_TRUE);
-        *aImportantBlock = nsnull;
+        DoExpand(aImportantBlock, PR_TRUE);
     }
 }
 
 nsCSSExpandedDataBlock::ComputeSizeResult
 nsCSSExpandedDataBlock::ComputeSize()
 {
     ComputeSizeResult result = {0, 0};
     for (PRUint32 iHigh = 0; iHigh < nsCSSPropertySet::kChunkCount; ++iHigh) {
@@ -744,33 +758,32 @@ nsCSSExpandedDataBlock::ComputeSize()
     }
     return result;
 }
 
 void
 nsCSSExpandedDataBlock::Compress(nsCSSCompressedDataBlock **aNormalBlock,
                                  nsCSSCompressedDataBlock **aImportantBlock)
 {
-    nsCSSCompressedDataBlock *result_normal, *result_important;
+    nsRefPtr<nsCSSCompressedDataBlock> result_normal, result_important;
     char *cursor_normal, *cursor_important;
 
     ComputeSizeResult size = ComputeSize();
     
     result_normal = new(size.normal) nsCSSCompressedDataBlock();
     if (!result_normal) {
         *aNormalBlock = nsnull;
         *aImportantBlock = nsnull;
         return;
     }
     cursor_normal = result_normal->Block();
 
     if (size.important != 0) {
         result_important = new(size.important) nsCSSCompressedDataBlock();
         if (!result_important) {
-            delete result_normal;
             *aNormalBlock = nsnull;
             *aImportantBlock = nsnull;
             return;
         }
         cursor_important = result_important->Block();
     } else {
         result_important = nsnull;
     }
@@ -856,18 +869,18 @@ nsCSSExpandedDataBlock::Compress(nsCSSCo
     if (result_important) {
         result_important->mBlockEnd = cursor_important;
         NS_ASSERTION(result_important->DataSize() == ptrdiff_t(size.important),
                      "size miscalculation");
     }
 
     ClearSets();
     AssertInitialState();
-    *aNormalBlock = result_normal;
-    *aImportantBlock = result_important;
+    result_normal.forget(aNormalBlock);
+    result_important.forget(aImportantBlock);
 }
 
 void
 nsCSSExpandedDataBlock::Clear()
 {
     for (PRUint32 iHigh = 0; iHigh < nsCSSPropertySet::kChunkCount; ++iHigh) {
         if (!mPropertiesSet.HasPropertyInChunk(iHigh))
             continue;
diff --git a/layout/style/nsCSSDataBlock.h b/layout/style/nsCSSDataBlock.h
--- a/layout/style/nsCSSDataBlock.h
+++ b/layout/style/nsCSSDataBlock.h
@@ -40,27 +40,33 @@
  */
 
 #ifndef nsCSSDataBlock_h__
 #define nsCSSDataBlock_h__
 
 #include "nsCSSStruct.h"
 #include "nsCSSProps.h"
 #include "nsCSSPropertySet.h"
+#include "nsAutoPtr.h"
 
 struct nsRuleData;
 
 class nsCSSExpandedDataBlock;
 class nsCSSDeclaration;
 
 /**
  * An |nsCSSCompressedDataBlock| holds a usually-immutable chunk of
  * property-value data for a CSS declaration block (which we misname a
  * |nsCSSDeclaration|).  Mutation is accomplished through
  * |nsCSSExpandedDataBlock| or in some cases via direct slot access.
+ *
+ * Mutation is forbidden when the reference count is greater than one,
+ * since once a style rule has used a compressed data block, mutation of
+ * that block is forbidden, and any declarations that want to mutate it
+ * need to clone it first.
  */
 class nsCSSCompressedDataBlock {
 public:
     friend class nsCSSExpandedDataBlock;
     friend class nsCSSDeclaration;
 
     /**
      * Do what |nsIStyleRule::MapRuleInfoInto| needs to do for a style
@@ -117,56 +123,77 @@ public:
     }
 
     /**
      * Clone this block, or return null on out-of-memory.
      */
     nsCSSCompressedDataBlock* Clone() const;
 
     /**
-     * Delete all the data stored in this block, and the block itself.
-     */
-    void Destroy();
-
-    /**
      * Create a new nsCSSCompressedDataBlock holding no declarations.
      */
-    static nsCSSCompressedDataBlock* CreateEmptyBlock();
+    static already_AddRefed<nsCSSCompressedDataBlock> CreateEmptyBlock();
+
+    void AddRef() {
+        NS_ASSERTION(mRefCnt == 0 || mRefCnt == 1,
+                     "unexpected reference count");
+        ++mRefCnt;
+    }
+    void Release() {
+        NS_ASSERTION(mRefCnt == 1 || mRefCnt == 2,
+                     "unexpected reference count");
+        if (--mRefCnt == 0) {
+            Destroy();
+        }
+    }
+
+    PRBool IsMutable() const {
+        NS_ASSERTION(mRefCnt == 1 || mRefCnt == 2,
+                     "unexpected reference count");
+        return mRefCnt < 2;
+    }
 
 private:
     PRInt32 mStyleBits; // the structs for which we have data, according to
                         // |nsCachedStyleData::GetBitForSID|.
+    nsAutoRefCnt mRefCnt;
 
     enum { block_chars = 4 }; // put 4 chars in the definition of the class
                               // to ensure size not inflated by alignment
 
     void* operator new(size_t aBaseSize, size_t aDataSize) {
         // subtract off the extra size to store |mBlock_|
         return ::operator new(aBaseSize + aDataSize -
                               sizeof(char) * block_chars);
     }
 
     nsCSSCompressedDataBlock() : mStyleBits(0) {}
 
     // Only this class (through |Destroy|) or nsCSSExpandedDataBlock (in
     // |Expand|) can delete compressed data blocks.
     ~nsCSSCompressedDataBlock() { }
 
+    /**
+     * Delete all the data stored in this block, and the block itself.
+     */
+    void Destroy();
+
     char* mBlockEnd; // the byte after the last valid byte
     char mBlock_[block_chars]; // must be the last member!
 
     char* Block() { return mBlock_; }
     char* BlockEnd() { return mBlockEnd; }
     const char* Block() const { return mBlock_; }
     const char* BlockEnd() const { return mBlockEnd; }
     ptrdiff_t DataSize() const { return BlockEnd() - Block(); }
 
     // Direct slot access to our values.  See StorageFor above.  Can
     // return null.  Must not be called for shorthand properties.
     void* SlotForValue(nsCSSProperty aProperty) {
+      NS_ABORT_IF_FALSE(IsMutable(), "must be mutable");
       return const_cast<void*>(StorageFor(aProperty));
     }
 };
 
 class nsCSSExpandedDataBlock {
 public:
     nsCSSExpandedDataBlock();
     ~nsCSSExpandedDataBlock();
@@ -194,23 +221,23 @@ public:
 #endif
     nsCSSColumn mColumn;
 
     /**
      * Transfer all of the state from the compressed block to this
      * expanded block.  The state of this expanded block must be clear
      * beforehand.
      *
-     * The compressed block passed in IS DESTROYED by this method and
+     * The compressed block passed in IS RELEASED by this method and
      * set to null, and thus cannot be used again.  (This is necessary
      * because ownership of sub-objects is transferred to the expanded
-     * block.)
+     * block in many cases.)
      */
-    void Expand(nsCSSCompressedDataBlock **aNormalBlock,
-                nsCSSCompressedDataBlock **aImportantBlock);
+    void Expand(nsRefPtr<nsCSSCompressedDataBlock> *aNormalBlock,
+                nsRefPtr<nsCSSCompressedDataBlock> *aImportantBlock);
 
     /**
      * Allocate a new compressed block and transfer all of the state
      * from this expanded block to the new compressed block, clearing
      * the state of this expanded block.
      */
     void Compress(nsCSSCompressedDataBlock **aNormalBlock,
                   nsCSSCompressedDataBlock **aImportantBlock);
@@ -237,17 +264,18 @@ private:
      * Compute the size that will be occupied by the result of
      * |Compress|.
      */
     struct ComputeSizeResult {
         PRUint32 normal, important;
     };
     ComputeSizeResult ComputeSize();
 
-    void DoExpand(nsCSSCompressedDataBlock *aBlock, PRBool aImportant);
+    void DoExpand(nsRefPtr<nsCSSCompressedDataBlock> *aBlock,
+                  PRBool aImportant);
 
 #ifdef DEBUG
     void DoAssertInitialState();
 #endif
 
     struct PropertyOffsetInfo {
         // XXX These could probably be pointer-to-member, if the casting can
         // be done correctly.
diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -57,18 +57,16 @@
 #include "nsReadableUtils.h"
 #include "nsStyleUtil.h"
 
 #include "nsStyleConsts.h"
 
 #include "nsCOMPtr.h"
 
 nsCSSDeclaration::nsCSSDeclaration() 
-  : mData(nsnull),
-    mImportantData(nsnull)
 {
   // check that we can fit all the CSS properties into a PRUint8
   // for the mOrder array - if not, might need to use PRUint16!
   PR_STATIC_ASSERT(eCSSProperty_COUNT_no_shorthands - 1 <= PR_UINT8_MAX);
 
   MOZ_COUNT_CTOR(nsCSSDeclaration);
 }
 
@@ -78,23 +76,16 @@ nsCSSDeclaration::nsCSSDeclaration(const
     mImportantData(aCopy.mImportantData ? aCopy.mImportantData->Clone()
                                          : nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSDeclaration);
 }
 
 nsCSSDeclaration::~nsCSSDeclaration(void)
 {
-  if (mData) {
-    mData->Destroy();
-  }
-  if (mImportantData) {
-    mImportantData->Destroy();
-  }
-
   MOZ_COUNT_DTOR(nsCSSDeclaration);
 }
 
 nsresult
 nsCSSDeclaration::ValueAppended(nsCSSProperty aProperty)
 {
   NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(aProperty),
                     "shorthands forbidden");
@@ -103,30 +94,30 @@ nsCSSDeclaration::ValueAppended(nsCSSPro
   mOrder.AppendElement(aProperty);
   return NS_OK;
 }
 
 nsresult
 nsCSSDeclaration::RemoveProperty(nsCSSProperty aProperty)
 {
   nsCSSExpandedDataBlock data;
-  data.Expand(&mData, &mImportantData);
+  ExpandTo(&data);
   NS_ASSERTION(!mData && !mImportantData, "Expand didn't null things out");
 
   if (nsCSSProps::IsShorthand(aProperty)) {
     CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(p, aProperty) {
       data.ClearProperty(*p);
       mOrder.RemoveElement(*p);
     }
   } else {
     data.ClearProperty(aProperty);
     mOrder.RemoveElement(aProperty);
   }
 
-  data.Compress(&mData, &mImportantData);
+  CompressFrom(&data);
   return NS_OK;
 }
 
 nsresult
 nsCSSDeclaration::AppendComment(const nsAString& aComment)
 {
   return /* NS_ERROR_NOT_IMPLEMENTED, or not any longer that is */ NS_OK;
 }
diff --git a/layout/style/nsCSSDeclaration.h b/layout/style/nsCSSDeclaration.h
--- a/layout/style/nsCSSDeclaration.h
+++ b/layout/style/nsCSSDeclaration.h
@@ -107,17 +107,18 @@ public:
 
   /**
    * Transfer all of the state from |aExpandedData| into this declaration.
    * After calling, |aExpandedData| should be in its initial state.
    */
   void CompressFrom(nsCSSExpandedDataBlock *aExpandedData) {
     NS_ASSERTION(!mData, "oops");
     NS_ASSERTION(!mImportantData, "oops");
-    aExpandedData->Compress(&mData, &mImportantData);
+    aExpandedData->Compress(getter_AddRefs(mData),
+                            getter_AddRefs(mImportantData));
     aExpandedData->AssertInitialState();
   }
 
   /**
    * Transfer all of the state from this declaration into
    * |aExpandedData| and put this declaration temporarily into an
    * invalid state (ended by |CompressFrom| or |InitializeEmpty|) that
    * should last only during parsing.  During this time only
@@ -152,22 +153,18 @@ public:
     return slot;
   }
 
   /**
    * Clear the data, in preparation for its replacement with entirely
    * new data by a call to |CompressFrom|.
    */
   void ClearData() {
-    mData->Destroy();
     mData = nsnull;
-    if (mImportantData) {
-      mImportantData->Destroy();
-      mImportantData = nsnull;
-    }
+    mImportantData = nsnull;
     mOrder.Clear();
   }
 
 #ifdef DEBUG
   void List(FILE* out = stdout, PRInt32 aIndent = 0) const;
 #endif
   
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
@@ -232,13 +229,17 @@ private:
     
   nsCSSProperty OrderValueAt(PRUint32 aValue) const {
     return nsCSSProperty(mOrder.ElementAt(aValue));
   }
 
 private:
     nsAutoTArray<PRUint8, 8> mOrder;
     nsAutoRefCnt mRefCnt;
-    nsCSSCompressedDataBlock *mData; // never null, except while expanded
-    nsCSSCompressedDataBlock *mImportantData; // may be null
+
+    // never null, except while expanded
+    nsRefPtr<nsCSSCompressedDataBlock> mData;
+
+    // may be null
+    nsRefPtr<nsCSSCompressedDataBlock> mImportantData;
 };
 
 #endif /* nsCSSDeclaration_h___ */
