Replace space manager with a more limited float manager.  (Bug 191448)

diff --git a/layout/base/tests/Makefile.in b/layout/base/tests/Makefile.in
--- a/layout/base/tests/Makefile.in
+++ b/layout/base/tests/Makefile.in
@@ -38,47 +38,16 @@
 DEPTH		= ../../..
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 relativesrcdir	= layout/base/tests
 
 include $(DEPTH)/config/autoconf.mk
 
-ifeq (0,1) # false, since TestSpaceManager is broken
-
-MOZILLA_INTERNAL_API = 1
-
-REQUIRES	= xpcom \
-		  gfx \
-		  $(NULL)
-
-CPPSRCS		= \
-		TestSpaceManager.cpp \
-		$(NULL)
-
-SIMPLE_PROGRAMS	= $(CPPSRCS:.cpp=$(BIN_SUFFIX))
-
-LOCAL_INCLUDES	= \
-		-I$(srcdir)/../src \
-		$(NULL)
-
-EXTRA_DSO_LIBS	= gkbase_s gkgfx gkconbase_s gkconshared_s gkconhtmlstyle_s
-
-LIBS		+= \
-		$(LIBS_DIR) \
-		$(EXTRA_DSO_LIBS) \
-		$(MOZ_UNICHARUTIL_LIBS) \
-		$(MOZ_COMPONENT_LIBS) \
-		$(MOZ_JS_LIBS) \
-		$(TK_LIBS) \
-		$(NULL)
-
-endif # false
-
 include $(topsrcdir)/config/rules.mk
 
 DEFINES += -D_IMPL_NS_LAYOUT
 
 _TEST_FILES =	\
 		test_bug66619.html \
 		test_bug114649.html \
 		test_bug386575.xhtml \
diff --git a/layout/base/tests/TestSpaceManager.cpp b/layout/base/tests/TestSpaceManager.cpp
deleted file mode 100644
--- a/layout/base/tests/TestSpaceManager.cpp
+++ /dev/null
@@ -1,750 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-#include <stdio.h>
-#include "nscore.h"
-#include "nsCRT.h"
-#include "nsSpaceManager.h"
-
-class MySpaceManager: public nsSpaceManager {
-public:
-  MySpaceManager(nsIPresShell* aPresShell, nsIFrame* aFrame)
-      : nsSpaceManager(aPresShell, aFrame) {}
-
-  PRBool  TestAddBand();
-  PRBool  TestAddBandOverlap();
-  PRBool  TestAddRectToBand();
-  PRBool  TestRemoveRegion();
-  PRBool  TestGetBandData();
-
-  struct BandInfo {
-    nscoord   yOffset;
-    nscoord   height;
-    BandRect* firstRect;
-    PRIntn    numRects;
-  };
-
-  struct BandsInfo {
-    PRIntn   numBands;
-    BandInfo bands[25];
-  };
-
-protected:
-  void  GetBandsInfo(BandsInfo&);
-};
-
-void MySpaceManager::GetBandsInfo(BandsInfo& aBandsInfo)
-{
-  aBandsInfo.numBands = 0;
-
-  if (!mBandList.IsEmpty()) {
-    BandRect* band = mBandList.Head();
-    while (nsnull != band) {
-      BandInfo& info = aBandsInfo.bands[aBandsInfo.numBands];
-
-      info.yOffset = band->mTop;
-      info.height = band->mBottom - band->mTop;
-      info.firstRect = band;
-
-      aBandsInfo.numBands++;
-
-      // Get the next band, and count the number of rects in this band
-      info.numRects = 0;
-      while (info.yOffset == band->mTop) {
-        info.numRects++;
-
-        band = band->Next();
-        if (band == &mBandList) {
-          // No bands left
-          band = nsnull;
-          break;
-        }
-      }
-    }
-  }
-}
-
-///////////////////////////////////////////////////////////////////////////////
-//
-
-// Test of adding a rect region that causes a new band to be created (no
-// overlap with an existing band)
-//
-// This tests the following:
-// 1. when there are no existing bands
-// 2. adding a new band above the topmost band
-// 3. inserting a new band between two existing bands
-// 4. adding a new band below the bottommost band
-PRBool MySpaceManager::TestAddBand()
-{
-  BandsInfo bandsInfo;
-  nsresult  status;
-  
-  // Clear any existing regions
-  ClearRegions();
-  NS_ASSERTION(mBandList.IsEmpty(), "clear regions failed");
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #1. Add a rect region. Verify the return status, and that a band rect is
-  // added
-  status = AddRectRegion((nsIFrame*)0x01, nsRect(10, 100, 100, 100));
-  if (NS_FAILED(status)) {
-    printf("TestAddBand: add failed (#1)\n");
-    return PR_FALSE;
-  }
-  GetBandsInfo(bandsInfo);
-  if (bandsInfo.numBands != 1) {
-    printf("TestAddBand: wrong number of bands (#1): %i\n", bandsInfo.numBands);
-    return PR_FALSE;
-  }
-  if ((bandsInfo.bands[0].yOffset != 100) || (bandsInfo.bands[0].height != 100)) {
-    printf("TestAddBand: wrong band size (#1)\n");
-    return PR_FALSE;
-  }
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #2. Add another band rect completely above the first band rect
-  status = AddRectRegion((nsIFrame*)0x02, nsRect(10, -10, 100, 20));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  GetBandsInfo(bandsInfo);
-  if (bandsInfo.numBands != 2) {
-    printf("TestAddBand: wrong number of bands (#2): %i\n", bandsInfo.numBands);
-    return PR_FALSE;
-  }
-  if ((bandsInfo.bands[0].yOffset != -10) || (bandsInfo.bands[0].height != 20) ||
-      (bandsInfo.bands[1].yOffset != 100) || (bandsInfo.bands[1].height != 100)) {
-    printf("TestAddBand: wrong band sizes (#2)\n");
-    return PR_FALSE;
-  }
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #3. Now insert a new band between the two existing bands
-  status = AddRectRegion((nsIFrame*)0x03, nsRect(10, 40, 100, 30));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  GetBandsInfo(bandsInfo);
-  if (bandsInfo.numBands != 3) {
-    printf("TestAddBand: wrong number of bands (#3): %i\n", bandsInfo.numBands);
-    return PR_FALSE;
-  }
-  if ((bandsInfo.bands[0].yOffset != -10) || (bandsInfo.bands[0].height != 20) ||
-      (bandsInfo.bands[1].yOffset != 40) || (bandsInfo.bands[1].height != 30) ||
-      (bandsInfo.bands[2].yOffset != 100) || (bandsInfo.bands[2].height != 100)) {
-    printf("TestAddBand: wrong band sizes (#3)\n");
-    return PR_FALSE;
-  }
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #4. Append a new bottommost band
-  status = AddRectRegion((nsIFrame*)0x04, nsRect(10, 210, 100, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  GetBandsInfo(bandsInfo);
-  if (bandsInfo.numBands != 4) {
-    printf("TestAddBand: wrong number of bands (#4): %i\n", bandsInfo.numBands);
-    return PR_FALSE;
-  }
-  if ((bandsInfo.bands[0].yOffset != -10) || (bandsInfo.bands[0].height != 20) ||
-      (bandsInfo.bands[1].yOffset != 40) || (bandsInfo.bands[1].height != 30) ||
-      (bandsInfo.bands[2].yOffset != 100) || (bandsInfo.bands[2].height != 100) ||
-      (bandsInfo.bands[3].yOffset != 210) || (bandsInfo.bands[3].height != 100)) {
-    printf("TestAddBand: wrong band sizes (#4)\n");
-    return PR_FALSE;
-  }
-
-  return PR_TRUE;
-}
-
-// Test of adding a rect region that overlaps an existing band
-//
-// This tests the following:
-// 1. Adding a rect that's above and partially overlaps an existing band
-// 2. Adding a rect that's completely contained by an existing band
-// 3. Adding a rect that overlaps and is below an existing band
-// 3. Adding a rect that contains an existing band
-PRBool MySpaceManager::TestAddBandOverlap()
-{
-  BandsInfo bandsInfo;
-  nsresult  status;
-  
-  // Clear any existing regions
-  ClearRegions();
-  NS_ASSERTION(mBandList.IsEmpty(), "clear regions failed");
-
-  // Add a new band
-  status = AddRectRegion((nsIFrame*)0x01, nsRect(100, 25, 100, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #1. Add a rect region that's above and partially overlaps an existing band
-  status = AddRectRegion((nsIFrame*)0x02, nsRect(10, -25, 50, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  GetBandsInfo(bandsInfo);
-  if (bandsInfo.numBands != 3) {
-    printf("TestAddBandOverlap: wrong number of bands (#1): %i\n", bandsInfo.numBands);
-    return PR_FALSE;
-  }
-  if ((bandsInfo.bands[0].yOffset != -25) || (bandsInfo.bands[0].height != 50) ||
-      (bandsInfo.bands[1].yOffset != 25) || (bandsInfo.bands[1].height != 50) ||
-      (bandsInfo.bands[2].yOffset != 75) || (bandsInfo.bands[2].height != 50)) {
-    printf("TestAddBandOverlap: wrong band sizes (#1)\n");
-    return PR_FALSE;
-  }
-  if ((bandsInfo.bands[0].numRects != 1) ||
-      (bandsInfo.bands[1].numRects != 2) ||
-      (bandsInfo.bands[2].numRects != 1)) {
-    printf("TestAddBandOverlap: wrong number of rects (#1)\n");
-    return PR_FALSE;
-  }
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #2. Add a rect region that's contained by the first band
-  status = AddRectRegion((nsIFrame*)0x03, nsRect(200, -15, 50, 10));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  GetBandsInfo(bandsInfo);
-  if (bandsInfo.numBands != 5) {
-    printf("TestAddBandOverlap: wrong number of bands (#2): %i\n", bandsInfo.numBands);
-    return PR_FALSE;
-  }
-  if ((bandsInfo.bands[0].yOffset != -25) || (bandsInfo.bands[0].height != 10) ||
-      (bandsInfo.bands[1].yOffset != -15) || (bandsInfo.bands[1].height != 10) ||
-      (bandsInfo.bands[2].yOffset != -5) || (bandsInfo.bands[2].height != 30) ||
-      (bandsInfo.bands[3].yOffset != 25) || (bandsInfo.bands[3].height != 50) ||
-      (bandsInfo.bands[4].yOffset != 75) || (bandsInfo.bands[4].height != 50)) {
-    printf("TestAddBandOverlap: wrong band sizes (#2)\n");
-    return PR_FALSE;
-  }
-  if ((bandsInfo.bands[0].numRects != 1) ||
-      (bandsInfo.bands[1].numRects != 2) ||
-      (bandsInfo.bands[2].numRects != 1) ||
-      (bandsInfo.bands[3].numRects != 2) ||
-      (bandsInfo.bands[4].numRects != 1)) {
-    printf("TestAddBandOverlap: wrong number of rects (#2)\n");
-    return PR_FALSE;
-  }
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #3. Add a rect that overlaps and is below an existing band
-  status = AddRectRegion((nsIFrame*)0x04, nsRect(200, 100, 50, 50));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  GetBandsInfo(bandsInfo);
-  if (bandsInfo.numBands != 7) {
-    printf("TestAddBandOverlap: wrong number of bands (#3): %i\n", bandsInfo.numBands);
-    return PR_FALSE;
-  }
-  if ((bandsInfo.bands[0].yOffset != -25) || (bandsInfo.bands[0].height != 10) ||
-      (bandsInfo.bands[1].yOffset != -15) || (bandsInfo.bands[1].height != 10) ||
-      (bandsInfo.bands[2].yOffset != -5) || (bandsInfo.bands[2].height != 30) ||
-      (bandsInfo.bands[3].yOffset != 25) || (bandsInfo.bands[3].height != 50) ||
-      (bandsInfo.bands[4].yOffset != 75) || (bandsInfo.bands[4].height != 25) ||
-      (bandsInfo.bands[5].yOffset != 100) || (bandsInfo.bands[5].height != 25) ||
-      (bandsInfo.bands[6].yOffset != 125) || (bandsInfo.bands[6].height != 25)) {
-    printf("TestAddBandOverlap: wrong band sizes (#3)\n");
-    return PR_FALSE;
-  }
-  if ((bandsInfo.bands[0].numRects != 1) ||
-      (bandsInfo.bands[1].numRects != 2) ||
-      (bandsInfo.bands[2].numRects != 1) ||
-      (bandsInfo.bands[3].numRects != 2) ||
-      (bandsInfo.bands[4].numRects != 1) ||
-      (bandsInfo.bands[5].numRects != 2) ||
-      (bandsInfo.bands[6].numRects != 1)) {
-    printf("TestAddBandOverlap: wrong number of rects (#3)\n");
-    return PR_FALSE;
-  }
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #4. Now test adding a rect that contains an existing band
-  ClearRegions();
-  status = AddRectRegion((nsIFrame*)0x01, nsRect(100, 100, 100, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-
-  // Now add a rect that contains the existing band vertically
-  status = AddRectRegion((nsIFrame*)0x02, nsRect(200, 50, 100, 200));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-
-  GetBandsInfo(bandsInfo);
-  if (bandsInfo.numBands != 3) {
-    printf("TestAddBandOverlap: wrong number of bands (#4): %i\n", bandsInfo.numBands);
-    return PR_FALSE;
-  }
-  if ((bandsInfo.bands[0].yOffset != 50) || (bandsInfo.bands[0].height != 50) ||
-      (bandsInfo.bands[1].yOffset != 100) || (bandsInfo.bands[1].height != 100) ||
-      (bandsInfo.bands[2].yOffset != 200) || (bandsInfo.bands[2].height != 50)) {
-    printf("TestAddBandOverlap: wrong band sizes (#4)\n");
-    return PR_FALSE;
-  }
-  if ((bandsInfo.bands[0].numRects != 1) ||
-      (bandsInfo.bands[1].numRects != 2) ||
-      (bandsInfo.bands[2].numRects != 1)) {
-    printf("TestAddBandOverlap: wrong number of rects (#4)\n");
-    return PR_FALSE;
-  }
-
-  return PR_TRUE;
-}
-
-// Test of adding rects within an existing band
-//
-// This tests the following:
-// 1. Add a rect to the left of an existing rect
-// 2. Add a rect to the right of the rightmost rect
-// 3. Add a rect that's to the left of an existing rect and that overlaps it
-// 4. Add a rect that's to the right of an existing rect and that overlaps it
-// 5. Add a rect over top of an existing rect (existing rect contains new rect)
-// 6. Add a new rect that completely contains an existing rect
-PRBool MySpaceManager::TestAddRectToBand()
-{
-  BandsInfo bandsInfo;
-  BandRect* bandRect;
-  nsresult  status;
-
-  // Clear any existing regions
-  ClearRegions();
-  NS_ASSERTION(mBandList.IsEmpty(), "clear regions failed");
-
-  // Add a new band
-  status = AddRectRegion((nsIFrame*)0x01, nsRect(100, 100, 100, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #1. Add a rect region that's to the left of the existing rect
-  status = AddRectRegion((nsIFrame*)0x02, nsRect(10, 100, 50, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  GetBandsInfo(bandsInfo);
-  if (bandsInfo.numBands != 1) {
-    printf("TestAddRectToBand: wrong number of bands (#1): %i\n", bandsInfo.numBands);
-    return PR_FALSE;
-  }
-  if (bandsInfo.bands[0].numRects != 2) {
-    printf("TestAddRectToBand: wrong number of rects (#1): %i\n", bandsInfo.bands[0].numRects);
-    return PR_FALSE;
-  }
-  bandRect = bandsInfo.bands[0].firstRect;
-  if ((bandRect->mLeft != 10) || (bandRect->mRight != 60)) {
-    printf("TestAddRectToBand: wrong first rect (#1)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  if ((bandRect->mLeft != 100) || (bandRect->mRight != 200)) {
-    printf("TestAddRectToBand: wrong second rect (#1)\n");
-    return PR_FALSE;
-  }
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #2. Add a rect region that's to the right of the rightmost rect
-  status = AddRectRegion((nsIFrame*)0x03, nsRect(250, 100, 100, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  GetBandsInfo(bandsInfo);
-  NS_ASSERTION(bandsInfo.numBands == 1, "wrong number of bands");
-  if (bandsInfo.bands[0].numRects != 3) {
-    printf("TestAddRectToBand: wrong number of rects (#2): %i\n", bandsInfo.bands[0].numRects);
-    return PR_FALSE;
-  }
-  bandRect = bandsInfo.bands[0].firstRect;
-  if ((bandRect->mLeft != 10) || (bandRect->mRight != 60)) {
-    printf("TestAddRectToBand: wrong first rect (#2)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  if ((bandRect->mLeft != 100) || (bandRect->mRight != 200)) {
-    printf("TestAddRectToBand: wrong second rect (#2)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  if ((bandRect->mLeft != 250) || (bandRect->mRight != 350)) {
-    printf("TestAddRectToBand: wrong third rect (#2)\n");
-    return PR_FALSE;
-  }
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #3. Add a rect region that's to the left of an existing rect and that
-  // overlaps the rect
-  status = AddRectRegion((nsIFrame*)0x04, nsRect(80, 100, 40, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  GetBandsInfo(bandsInfo);
-  NS_ASSERTION(bandsInfo.numBands == 1, "wrong number of bands");
-  if (bandsInfo.bands[0].numRects != 5) {
-    printf("TestAddRectToBand: wrong number of rects (#3): %i\n", bandsInfo.bands[0].numRects);
-    return PR_FALSE;
-  }
-  bandRect = bandsInfo.bands[0].firstRect;
-  if ((bandRect->mLeft != 10) || (bandRect->mRight != 60)) {
-    printf("TestAddRectToBand: wrong first rect (#3)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  NS_ASSERTION(1 == bandRect->mNumFrames, "unexpected shared rect");
-  if ((bandRect->mLeft != 80) || (bandRect->mRight != 100)) {
-    printf("TestAddRectToBand: wrong second rect (#3)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  if ((bandRect->mLeft != 100) || (bandRect->mRight != 120) ||
-      (bandRect->mNumFrames != 2) || !bandRect->IsOccupiedBy((nsIFrame*)0x04)) {
-    printf("TestAddRectToBand: wrong third rect (#3)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  NS_ASSERTION(1 == bandRect->mNumFrames, "unexpected shared rect");
-  if ((bandRect->mLeft != 120) || (bandRect->mRight != 200)) {
-    printf("TestAddRectToBand: wrong fourth rect (#3)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  if ((bandRect->mLeft != 250) || (bandRect->mRight != 350)) {
-    printf("TestAddRectToBand: wrong fifth rect (#3)\n");
-    return PR_FALSE;
-  }
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #4. Add a rect region that's to the right of an existing rect and that
-  // overlaps the rect
-  status = AddRectRegion((nsIFrame*)0x05, nsRect(50, 100, 20, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  GetBandsInfo(bandsInfo);
-  NS_ASSERTION(bandsInfo.numBands == 1, "wrong number of bands");
-  if (bandsInfo.bands[0].numRects != 7) {
-    printf("TestAddRectToBand: wrong number of rects (#4): %i\n", bandsInfo.bands[0].numRects);
-    return PR_FALSE;
-  }
-  bandRect = bandsInfo.bands[0].firstRect;
-  NS_ASSERTION(1 == bandRect->mNumFrames, "unexpected shared rect");
-  if ((bandRect->mLeft != 10) || (bandRect->mRight != 50)) {
-    printf("TestAddRectToBand: wrong first rect (#4)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  if ((bandRect->mLeft != 50) || (bandRect->mRight != 60) ||
-      (bandRect->mNumFrames != 2) || !bandRect->IsOccupiedBy((nsIFrame*)0x05)) {
-    printf("TestAddRectToBand: wrong second rect (#4)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  NS_ASSERTION(1 == bandRect->mNumFrames, "unexpected shared rect");
-  if ((bandRect->mLeft != 60) || (bandRect->mRight != 70)) {
-    printf("TestAddRectToBand: wrong third rect (#4)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  NS_ASSERTION(1 == bandRect->mNumFrames, "unexpected shared rect");
-  if ((bandRect->mLeft != 80) || (bandRect->mRight != 100)) {
-    printf("TestAddRectToBand: wrong fourth rect (#4)\n");
-    return PR_FALSE;
-  }
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #5. Add a new rect over top of an existing rect (existing rect contains
-  // the new rect)
-  status = AddRectRegion((nsIFrame*)0x06, nsRect(20, 100, 20, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  GetBandsInfo(bandsInfo);
-  NS_ASSERTION(bandsInfo.numBands == 1, "wrong number of bands");
-  if (bandsInfo.bands[0].numRects != 9) {
-    printf("TestAddRectToBand: wrong number of rects (#5): %i\n", bandsInfo.bands[0].numRects);
-    return PR_FALSE;
-  }
-  bandRect = bandsInfo.bands[0].firstRect;
-  NS_ASSERTION(1 == bandRect->mNumFrames, "unexpected shared rect");
-  if ((bandRect->mLeft != 10) || (bandRect->mRight != 20)) {
-    printf("TestAddRectToBand: wrong first rect (#5)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  if ((bandRect->mLeft != 20) || (bandRect->mRight != 40) ||
-      (bandRect->mNumFrames != 2) || !bandRect->IsOccupiedBy((nsIFrame*)0x06)) {
-    printf("TestAddRectToBand: wrong second rect (#5)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  NS_ASSERTION(1 == bandRect->mNumFrames, "unexpected shared rect");
-  if ((bandRect->mLeft != 40) || (bandRect->mRight != 50)) {
-    printf("TestAddRectToBand: wrong third rect (#5)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  if ((bandRect->mLeft != 50) || (bandRect->mRight != 60) || (bandRect->mNumFrames != 2)) {
-    printf("TestAddRectToBand: wrong fourth rect (#5)\n");
-    return PR_FALSE;
-  }
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #6. Add a new rect that completely contains an existing rect
-  status = AddRectRegion((nsIFrame*)0x07, nsRect(0, 100, 30, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  GetBandsInfo(bandsInfo);
-  NS_ASSERTION(bandsInfo.numBands == 1, "wrong number of bands");
-  if (bandsInfo.bands[0].numRects != 11) {
-    printf("TestAddRectToBand: wrong number of rects (#6): %i\n", bandsInfo.bands[0].numRects);
-    return PR_FALSE;
-  }
-  bandRect = bandsInfo.bands[0].firstRect;
-  NS_ASSERTION(1 == bandRect->mNumFrames, "unexpected shared rect");
-  if ((bandRect->mLeft != 0) || (bandRect->mRight != 10)) {
-    printf("TestAddRectToBand: wrong first rect (#6)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  if ((bandRect->mLeft != 10) || (bandRect->mRight != 20) ||
-      (bandRect->mNumFrames != 2) || !bandRect->IsOccupiedBy((nsIFrame*)0x07)) {
-    printf("TestAddRectToBand: wrong second rect (#6)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  if ((bandRect->mLeft != 20) || (bandRect->mRight != 30) ||
-      (bandRect->mNumFrames != 3) || !bandRect->IsOccupiedBy((nsIFrame*)0x07)) {
-    printf("TestAddRectToBand: wrong third rect (#6)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  if ((bandRect->mLeft != 30) || (bandRect->mRight != 40) || (bandRect->mNumFrames != 2)) {
-    printf("TestAddRectToBand: wrong fourth rect (#6)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandRect->Next();
-  NS_ASSERTION(1 == bandRect->mNumFrames, "unexpected shared rect");
-  if ((bandRect->mLeft != 40) || (bandRect->mRight != 50)) {
-    printf("TestAddRectToBand: wrong fifth rect (#6)\n");
-    return PR_FALSE;
-  }
-
-  return PR_TRUE;
-}
-
-// Test of removing regions. We especially need to test that we correctly
-// coalesce adjacent rects and bands
-//
-// This tests the following:
-// 1. simple test of removing the one and only band rect
-// 2. removing a shared rect and verifying adjacent rects are coalesced
-// 3. removing a band rect and making sure adjacent bands are combined
-PRBool MySpaceManager::TestRemoveRegion()
-{
-  BandsInfo bandsInfo;
-  BandRect* bandRect;
-  nsresult  status;
-
-  // Clear any existing regions
-  ClearRegions();
-  NS_ASSERTION(mBandList.IsEmpty(), "clear regions failed");
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #1. A simple test of removing the one and only band rect
-  status = AddRectRegion((nsIFrame*)0x01, nsRect(10, 100, 100, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  status = RemoveRegion((nsIFrame*)0x01);
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  GetBandsInfo(bandsInfo);
-  if (bandsInfo.numBands != 0) {
-    printf("TestRemoveRegion: wrong number of bands (#1): %i\n", bandsInfo.numBands);
-    return PR_FALSE;
-  }
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #2. Test removing a rect that's shared. Make sure adjacent rects are
-  // coalesced
-  status = AddRectRegion((nsIFrame*)0x01, nsRect(10, 100, 100, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  status = AddRectRegion((nsIFrame*)0x02, nsRect(40, 100, 20, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-
-  // Verify there are three rects in the band
-  GetBandsInfo(bandsInfo);
-  if (bandsInfo.bands[0].numRects != 3) {
-    printf("TestRemoveRegion: wrong number of rects (#2): %i\n", bandsInfo.bands[0].numRects);
-    return PR_FALSE;
-  }
-
-  // Remove the region associated with the second frame
-  status = RemoveRegion((nsIFrame*)0x02);
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  GetBandsInfo(bandsInfo);
-  if (bandsInfo.bands[0].numRects != 1) {
-    printf("TestRemoveRegion: failed to coalesce adjacent rects (#2)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandsInfo.bands[0].firstRect;
-  if ((bandRect->mLeft != 10) || (bandRect->mRight != 110)) {
-    printf("TestRemoveRegion: wrong size rect (#2)\n");
-    return PR_FALSE;
-  }
-
-  /////////////////////////////////////////////////////////////////////////////
-  // #3. Test removing a band rect and making sure adjacent bands are combined
-  status = AddRectRegion((nsIFrame*)0x02, nsRect(10, 140, 20, 20));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-
-  // Verify there are three bands and that each band has three rects
-  GetBandsInfo(bandsInfo);
-  if (bandsInfo.numBands != 3) {
-    printf("TestRemoveRegion: wrong number of bands (#3): %i\n", bandsInfo.numBands);
-    return PR_FALSE;
-  }
-  if (bandsInfo.bands[0].numRects != 1) {
-    printf("TestRemoveRegion: band #1 wrong number of rects (#3): %i\n", bandsInfo.bands[0].numRects);
-    return PR_FALSE;
-  }
-  if (bandsInfo.bands[1].numRects != 2) {
-    printf("TestRemoveRegion: band #2 wrong number of rects (#3): %i\n", bandsInfo.bands[1].numRects);
-    return PR_FALSE;
-  }
-  if (bandsInfo.bands[2].numRects != 1) {
-    printf("TestRemoveRegion: band #3 wrong number of rects (#3): %i\n", bandsInfo.bands[2].numRects);
-    return PR_FALSE;
-  }
-
-  // Remove the region associated with the second frame
-  status = RemoveRegion((nsIFrame*)0x02);
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-  GetBandsInfo(bandsInfo);
-  if (bandsInfo.bands[0].numRects != 1) {
-    printf("TestRemoveRegion: failed to coalesce adjacent rects (#3)\n");
-    return PR_FALSE;
-  }
-  bandRect = bandsInfo.bands[0].firstRect;
-  if ((bandRect->mLeft != 10) || (bandRect->mRight != 110)) {
-    printf("TestRemoveRegion: wrong size rect (#3)\n");
-    return PR_FALSE;
-  }
-
-  return PR_TRUE;
-}
-
-// Test of getting the band data
-PRBool MySpaceManager::TestGetBandData()
-{
-  nsresult  status;
-  nscoord   yMost;
-
-  // Clear any existing regions
-  ClearRegions();
-  NS_ASSERTION(mBandList.IsEmpty(), "clear regions failed");
-
-  // Make sure YMost() returns the correct result
-  if (NS_ERROR_ABORT != YMost(yMost)) {
-    printf("TestGetBandData: YMost() returned wrong result (#1)\n");
-    return PR_FALSE;
-  }
-
-  // Make a band with three rects
-  status = AddRectRegion((nsIFrame*)0x01, nsRect(100, 100, 100, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-
-  status = AddRectRegion((nsIFrame*)0x02, nsRect(300, 100, 100, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-
-  status = AddRectRegion((nsIFrame*)0x03, nsRect(500, 100, 100, 100));
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-
-  // Verify that YMost() is correct
-  if ((NS_OK != YMost(yMost)) || (yMost != 200)) {
-    printf("TestGetBandData: YMost() returned wrong value (#2)\n");
-    return PR_FALSE;
-  }
-
-  // Get the band data using a very large clip rect and a band data struct
-  // that's large enough
-  nsBandData      bandData;
-  nsBandTrapezoid trapezoids[16];
-  bandData.mSize = 16;
-  bandData.mTrapezoids = trapezoids;
-  status = GetBandData(100, nsSize(10000,10000), bandData);
-  NS_ASSERTION(NS_SUCCEEDED(status), "unexpected status");
-
-  // Verify that there are seven trapezoids
-  if (bandData.mCount != 7) {
-    printf("TestGetBandData: wrong trapezoid count (#3)\n");
-    return PR_FALSE;
-  }
-  
-  // Get the band data using a very large clip rect and a band data struct
-  // that's too small
-  bandData.mSize = 3;
-  status = GetBandData(100, nsSize(10000,10000), bandData);
-  if (NS_SUCCEEDED(status)) {
-    printf("TestGetBandData: ignored band data count (#4)\n");
-    return PR_FALSE;
-  }
-
-  // Make sure the count has been updated to reflect the number of trapezoids
-  // required
-  if (bandData.mCount <= bandData.mSize) {
-    printf("TestGetBandData: bad band data count (#5)\n");
-    return PR_FALSE;
-  }
-
-  // XXX We need lots more tests here...
-
-  return PR_TRUE;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-//
-
-int main(int argc, char** argv)
-{
-  // Create a space manager
-  MySpaceManager* spaceMgr = new MySpaceManager(nsnull, nsnull);
-  
-  // Test adding rect regions
-  if (!spaceMgr->TestAddBand()) {
-    delete spaceMgr;
-    return -1;
-  }
-
-  // Test adding rect regions that overlap existing bands
-  if (!spaceMgr->TestAddBandOverlap()) {
-    delete spaceMgr;
-    return -1;
-  }
-
-  // Test adding rects within an existing band
-  if (!spaceMgr->TestAddRectToBand()) {
-    delete spaceMgr;
-    return -1;
-  }
-
-  // Test removing regions
-  if (!spaceMgr->TestRemoveRegion()) {
-    return -1;
-  }
-
-  // Test getting the band data
-  if (!spaceMgr->TestGetBandData()) {
-    return -1;
-  }
-
-  delete spaceMgr;
-  return 0;
-}
diff --git a/layout/build/nsLayoutStatics.cpp b/layout/build/nsLayoutStatics.cpp
--- a/layout/build/nsLayoutStatics.cpp
+++ b/layout/build/nsLayoutStatics.cpp
@@ -63,17 +63,17 @@
 #include "nsStyledElement.h"
 #include "nsGlobalWindow.h"
 #include "nsGkAtoms.h"
 #include "nsImageFrame.h"
 #include "nsLayoutStylesheetCache.h"
 #include "nsNodeInfo.h"
 #include "nsRange.h"
 #include "nsRepeatService.h"
-#include "nsSpaceManager.h"
+#include "nsFloatManager.h"
 #include "nsSprocketLayout.h"
 #include "nsStackLayout.h"
 #include "nsStyleSet.h"
 #include "nsTextControlFrame.h"
 #include "nsXBLWindowKeyHandler.h"
 #include "txMozillaXSLTProcessor.h"
 #include "nsDOMStorage.h"
 #include "nsCellMap.h"
@@ -311,17 +311,17 @@ nsLayoutStatics::Shutdown()
   nsSprocketLayout::Shutdown();
 #endif
 
 #ifdef MOZ_MATHML
   nsMathMLOperators::ReleaseTable();
 #endif
 
   nsCSSFrameConstructor::ReleaseGlobals();
-  nsSpaceManager::Shutdown();
+  nsFloatManager::Shutdown();
   nsImageFrame::ReleaseGlobals();
 
   nsCSSScanner::ReleaseGlobals();
 
   NS_IF_RELEASE(nsRuleNode::gLangService);
   nsStyledElement::Shutdown();
 
   nsTextFragment::Shutdown();
diff --git a/layout/generic/Makefile.in b/layout/generic/Makefile.in
--- a/layout/generic/Makefile.in
+++ b/layout/generic/Makefile.in
@@ -108,24 +108,24 @@ EXPORTS		+= \
 		nsBidiFrames.h      \
 		$(NULL)
 endif
 
 
 CPPSRCS		= \
 		nsAbsoluteContainingBlock.cpp \
 		nsBRFrame.cpp \
-		nsBlockBandData.cpp \
 		nsBlockFrame.cpp \
 		nsBlockReflowContext.cpp \
 		nsBlockReflowState.cpp \
 		nsBulletFrame.cpp \
 		nsColumnSetFrame.cpp \
 		nsContainerFrame.cpp \
 		nsFirstLetterFrame.cpp \
+		nsFloatManager.cpp \
 		nsFrame.cpp \
 		nsFrameFrame.cpp \
 		nsFrameList.cpp \
 		nsFrameSetFrame.cpp \
 		nsFrameUtil.cpp \
 		nsGfxScrollFrame.cpp \
 		nsHTMLCanvasFrame.cpp \
 		nsHTMLContainerFrame.cpp \
@@ -139,17 +139,16 @@ CPPSRCS		= \
 		nsLineBox.cpp \
 		nsLineLayout.cpp \
 		nsObjectFrame.cpp \
 		nsPageContentFrame.cpp \
 		nsPageFrame.cpp \
 		nsPlaceholderFrame.cpp \
 		nsSelection.cpp \
 		nsSimplePageSequence.cpp \
-		nsSpaceManager.cpp \
 		nsSpacerFrame.cpp \
 		nsSplittableFrame.cpp \
 		nsTextFrameThebes.cpp \
 		nsTextFrameUtils.cpp \
 		nsTextRunTransformations.cpp \
 		nsViewportFrame.cpp \
 		$(NULL)
 
diff --git a/layout/generic/nsBlockBandData.cpp b/layout/generic/nsBlockBandData.cpp
deleted file mode 100644
--- a/layout/generic/nsBlockBandData.cpp
+++ /dev/null
@@ -1,270 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-/* code for management of floats that implements space manager interfaces */
-
-#include "nsCOMPtr.h"
-#include "nsBlockBandData.h"
-#include "nsIFrame.h"
-#include "nsHTMLReflowState.h"
-#include "nsPresContext.h"
-#include "nsIPresShell.h"
-
-nsBlockBandData::nsBlockBandData()
-  : mSpaceManager(nsnull),
-    mSpaceManagerX(0),
-    mSpaceManagerY(0),
-    mSpace(0, 0)
-{
-  mSize = NS_BLOCK_BAND_DATA_TRAPS;
-  mTrapezoids = mData;
-}
-
-nsBlockBandData::~nsBlockBandData()
-{
-  if (mTrapezoids != mData) {
-    delete [] mTrapezoids;
-  }
-}
-
-nsresult
-nsBlockBandData::Init(nsSpaceManager* aSpaceManager,
-                      const nsSize& aSpace)
-{
-  NS_PRECONDITION(aSpaceManager, "null pointer");
-
-  mSpaceManager = aSpaceManager;
-  aSpaceManager->GetTranslation(mSpaceManagerX, mSpaceManagerY);
-
-  mSpace = aSpace;
-  mLeftFloats = 0;
-  mRightFloats = 0;
-  return NS_OK;
-}
-
-// Get the available reflow space for the current y coordinate. The
-// available space is relative to our coordinate system (0,0) is our
-// upper left corner.
-nsresult
-nsBlockBandData::GetAvailableSpace(nscoord aY, PRBool aRelaxHeightConstraint,
-                                   nsRect& aResult)
-{
-  // Get the raw band data for the given Y coordinate
-  nsresult rv = GetBandData(aY, aRelaxHeightConstraint);
-  if (NS_FAILED(rv)) { return rv; }
-
-  // Compute the bounding rect of the available space, i.e. space
-  // between any left and right floats.
-  ComputeAvailSpaceRect();
-  aResult = mAvailSpace;
-#ifdef REALLY_NOISY_COMPUTEAVAILSPACERECT
-  printf("nsBBD %p GetAvailableSpace(%d) returning (%d, %d, %d, %d)\n",
-          this, aY, aResult.x, aResult.y, aResult.width, aResult.height);
-#endif
-  return NS_OK;
-}
-
-// the code below should never loop more than a very few times.
-// this is a safety valve to see if we've gone off the deep end
-#define ERROR_TOO_MANY_ITERATIONS 1000
-
-/* nsBlockBandData methods should never call mSpaceManager->GetBandData directly.
- * They should always call nsBlockBandData::GetBandData() instead.
- */
-nsresult
-nsBlockBandData::GetBandData(nscoord aY, PRBool aRelaxHeightConstraint)
-{
-  NS_ASSERTION(mSpaceManager, "bad state, no space manager");
-  PRInt32 iterations =0;
-  nsSize space = mSpace;
-  if (aRelaxHeightConstraint) {
-    space.height = NS_UNCONSTRAINEDSIZE;
-  }
-  nsresult rv = mSpaceManager->GetBandData(aY, space, *this);
-  while (NS_FAILED(rv)) {
-    iterations++;
-    if (iterations>ERROR_TOO_MANY_ITERATIONS)
-    {
-      NS_ASSERTION(PR_FALSE, "too many iterations in nsBlockBandData::GetBandData");
-      return NS_ERROR_FAILURE;
-    }
-    // We need more space for our bands
-    NS_ASSERTION(mTrapezoids, "bad state, no mTrapezoids");
-    if (mTrapezoids && (mTrapezoids != mData)) {
-      delete [] mTrapezoids;
-    }
-    PRInt32 newSize = mSize * 2;
-    if (newSize<mCount) {
-      newSize = mCount;
-    }
-    mTrapezoids = new nsBandTrapezoid[newSize];
-    NS_POSTCONDITION(mTrapezoids, "failure allocating mTrapezoids");
-    if (!mTrapezoids) {
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-    mSize = newSize;
-    rv = mSpaceManager->GetBandData(aY, space, *this);
-  }
-  NS_POSTCONDITION(mCount<=mSize, "bad state, count > size");
-  return NS_OK;
-}
-
-
-
-/**
- * Computes the bounding rect of the available space, i.e. space
- * between any left and right floats. Uses the current trapezoid
- * data, see nsISpaceManager::GetBandData(). Also updates member
- * data "availSpace".
- */
-void
-nsBlockBandData::ComputeAvailSpaceRect()
-{
-#ifdef REALLY_NOISY_COMPUTEAVAILSPACERECT
-  printf("nsBlockBandData::ComputeAvailSpaceRect %p with count %d\n", this, mCount);
-#endif
-  if (0 == mCount) {
-    mAvailSpace.x = 0;
-    mAvailSpace.y = 0;
-    mAvailSpace.width = 0;
-    mAvailSpace.height = 0;
-    mLeftFloats = 0;
-    mRightFloats = 0;
-    return;
-  }
-
-  nsBandTrapezoid* trapezoid = mTrapezoids;
-  // The trapezoid to the left of the first right-floated trapezoid.
-  nsBandTrapezoid* rightTrapezoid = nsnull;
-
-  PRInt32 leftFloats = 0;
-  PRInt32 rightFloats = 0;
-  if (mCount > 1) {
-    // If there's more than one trapezoid that means there are floats
-    PRInt32 i;
-
-    // Examine each trapezoid in the band, counting up the number of
-    // left and right floats. Use the right-most float to
-    // determine where the right edge of the available space is.
-    NS_PRECONDITION(mCount<=mSize, "bad state, count > size");
-    for (i = 0; i < mCount; i++) {
-      trapezoid = &mTrapezoids[i];
-      if (trapezoid->mFrames) {
-#ifdef REALLY_NOISY_COMPUTEAVAILSPACERECT
-        printf("band %p checking !Avail trap %p with frame %p\n", this, trapezoid, trapezoid->mFrames);
-#endif
-        const nsSmallVoidArray* frames = trapezoid->mFrames;
-        const PRInt32 numFrames = frames->Count();
-        NS_ASSERTION(numFrames > 0, "bad trapezoid frame list");
-        for (PRInt32 j = 0; j < numFrames; j++) {
-          nsIFrame* f = static_cast<nsIFrame*>(frames->ElementAt(j));
-          const nsStyleDisplay* display = f->GetStyleDisplay();
-          if (NS_STYLE_FLOAT_LEFT == display->mFloats) {
-            leftFloats++;
-          }
-          else if (NS_STYLE_FLOAT_RIGHT == display->mFloats) {
-            rightFloats++;
-            if ((nsnull == rightTrapezoid) && (i > 0)) {
-              rightTrapezoid = &mTrapezoids[i - 1];
-            }
-          }
-        }
-      }
-    }
-  }
-  else if (mTrapezoids[0].mFrames) {
-    // We have a float using up all the available space
-    leftFloats = 1;
-  }
-#ifdef REALLY_NOISY_COMPUTEAVAILSPACERECT
-  printf("band %p has floats %d, %d\n", this, leftFloats, rightFloats);
-#endif
-  mLeftFloats = leftFloats;
-  mRightFloats = rightFloats;
-
-  // We look for available space in the last trapezoid before the
-  // first right float, or in the last trapezoid if there is no right
-  // float or no trapezoid before the first right float.
-  if (nsnull != rightTrapezoid) {
-    trapezoid = rightTrapezoid;
-  }
-  trapezoid->GetRect(mAvailSpace);
-
-  // When there is no available space, we still need a proper X
-  // coordinate to place objects that end up here anyway.
-  const nsSmallVoidArray* frames = trapezoid->mFrames;
-  if (frames) {
-    // It's not clear what coordinate to use when there is no
-    // available space and the space is multiply occupied...So: If
-    // any of the floats that are a part of the trapezoid are left
-    // floats then we move over to the right edge of the
-    // unavaliable space.
-    const PRInt32 numFrames = frames->Count();
-    NS_ASSERTION(numFrames > 0, "bad trapezoid frame list");
-    for (PRInt32 j = 0; j < numFrames; j++) {
-      nsIFrame* f = static_cast<nsIFrame*>(frames->ElementAt(j));
-      const nsStyleDisplay* display = f->GetStyleDisplay();
-      if (NS_STYLE_FLOAT_LEFT == display->mFloats) {
-        mAvailSpace.x = mAvailSpace.XMost();
-        break;
-      }
-    }
-    mAvailSpace.width = 0;
-  }
-
-  // Fixup width
-  if (NS_UNCONSTRAINEDSIZE == mSpace.width) {
-    mAvailSpace.width = NS_UNCONSTRAINEDSIZE;
-  }
-#ifdef REALLY_NOISY_COMPUTEAVAILSPACERECT
-  printf("  ComputeAvailSpaceRect settting state mAvailSpace (%d,%d,%d,%d)\n", 
-         mAvailSpace.x, mAvailSpace.y, mAvailSpace.width, mAvailSpace.height);
-#endif
-
-}
-
-#ifdef DEBUG
-void nsBlockBandData::List()
-{
-  printf("nsBlockBandData %p sm=%p, sm coord = (%d,%d), mSpace = (%d,%d)\n",
-          this, mSpaceManager, mSpaceManagerX, mSpaceManagerY,
-          mSpace.width, mSpace.height);
-  printf("  availSpace=(%d, %d, %d, %d), floats l=%d r=%d\n",
-          mAvailSpace.x, mAvailSpace.y, mAvailSpace.width, mAvailSpace.height,
-          mLeftFloats, mRightFloats);
-}
-#endif
diff --git a/layout/generic/nsBlockBandData.h b/layout/generic/nsBlockBandData.h
deleted file mode 100644
--- a/layout/generic/nsBlockBandData.h
+++ /dev/null
@@ -1,126 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-/* code for management of floats that implements space manager interfaces */
-
-#ifndef nsBlockBandData_h___
-#define nsBlockBandData_h___
-
-#include "nsSpaceManager.h"
-
-class nsPresContext;
-
-// Number of builtin nsBandTrapezoid's
-#define NS_BLOCK_BAND_DATA_TRAPS 6
-
-/**
- * Class used to manage processing of the space-manager band data.
- * Provides HTML/CSS specific behavior to the raw data.
- */
-class nsBlockBandData : public nsBandData {
-public:
-  nsBlockBandData();
-  ~nsBlockBandData();
-
-  // Initialize. This must be called before any of the other methods.
-  nsresult Init(nsSpaceManager* aSpaceManager, const nsSize& aSpace);
-
-  // Get some available space. Note that aY is relative to the current
-  // space manager translation.
-  nsresult GetAvailableSpace(nscoord aY, PRBool aRelaxHeightConstraint,
-                             nsRect& aResult);
-
-  // Get the raw trapezoid count for this band.
-  PRInt32 GetTrapezoidCount() const {
-    return mCount;
-  }
-
-  const nsBandTrapezoid* GetTrapezoid(PRInt32 aIndex) const {
-    return &mTrapezoids[aIndex];
-  }
-
-  // Get the number of floats that are impacting the current
-  // band. Note that this value is relative to the current translation
-  // in the space manager which means that some floats may be hidden
-  // by the translation and therefore won't be in the count.
-  PRInt32 GetFloatCount() const {
-    return mLeftFloats + mRightFloats;
-  }
-  PRInt32 GetLeftFloatCount() const {
-    return mLeftFloats;
-  }
-  PRInt32 GetRightFloatCount() const {
-    return mRightFloats;
-  }
-
-#ifdef DEBUG
-  void List();
-#endif
-
-protected:
-
-  /** utility method to calculate the band data at aY.
-    * nsBlockBandData methods should never call 
-    * mSpaceManager->GetBandData directly.
-    * They should always call this method instead so data members
-    * mTrapezoid, mCount, and mSize all get managed properly.
-    */
-  nsresult GetBandData(nscoord aY, PRBool aRelaxHeightConstraint);
-
-  // The spacemanager we are getting space from
-  nsSpaceManager* mSpaceManager;
-  nscoord mSpaceManagerX, mSpaceManagerY;
-
-  // Limit to the available space (set by Init)
-  nsSize mSpace;
-
-  // Trapezoids used during band processing
-  nsBandTrapezoid mData[NS_BLOCK_BAND_DATA_TRAPS];
-
-  // Bounding rect of available space between any left and right floats
-  nsRect mAvailSpace;
-
-  // Number of left/right floats in the current band. Note that this
-  // number may be less than the total number of floats present in
-  // the band, if our translation in the space manager "hides" some
-  // floats.
-  PRInt32 mLeftFloats, mRightFloats;
-
-  void ComputeAvailSpaceRect();
-};
-
-#endif /* nsBlockBandData_h___ */
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -45,17 +45,16 @@
  * rendering object for CSS display:block, inline-block, and list-item
  * boxes, also used for various anonymous boxes
  */
 
 #include "nsCOMPtr.h"
 #include "nsBlockFrame.h"
 #include "nsBlockReflowContext.h"
 #include "nsBlockReflowState.h"
-#include "nsBlockBandData.h"
 #include "nsBulletFrame.h"
 #include "nsLineBox.h"
 #include "nsInlineFrame.h"
 #include "nsLineLayout.h"
 #include "nsPlaceholderFrame.h"
 #include "nsStyleConsts.h"
 #include "nsFrameManager.h"
 #include "nsPresContext.h"
@@ -65,17 +64,17 @@
 #include "nsIFontMetrics.h"
 #include "nsHTMLParts.h"
 #include "nsGkAtoms.h"
 #include "nsIDOMEvent.h"
 #include "nsGenericHTMLElement.h"
 #include "prprf.h"
 #include "nsStyleChangeList.h"
 #include "nsFrameSelection.h"
-#include "nsSpaceManager.h"
+#include "nsFloatManager.h"
 #include "nsIntervalSet.h"
 #include "prenv.h"
 #include "plstr.h"
 #include "nsGUIEvent.h"
 #include "nsLayoutErrors.h"
 #include "nsAutoPtr.h"
 #include "nsIServiceManager.h"
 #include "nsIScrollableFrame.h"
@@ -886,26 +885,26 @@ nsBlockFrame::Reflow(nsPresContext*     
     ctc = nsLineBox::GetCtorCount();
   }
 #endif
 
   // See comment below about oldSize. Use *only* for the
   // abs-pos-containing-block-size-change optimization!
   nsSize oldSize = GetSize();
 
-  // Should we create a space manager?
-  nsAutoSpaceManager autoSpaceManager(const_cast<nsHTMLReflowState &>(aReflowState));
+  // Should we create a float manager?
+  nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState &>(aReflowState));
 
   // XXXldb If we start storing the space manager in the frame rather
   // than keeping it around only during reflow then we should create it
   // only when there are actually floats to manage.  Otherwise things
   // like tables will gain significant bloat.
   PRBool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
   if (needFloatManager)
-    autoSpaceManager.CreateSpaceManager(aPresContext);
+    autoFloatManager.CreateFloatManager(aPresContext);
 
   // OK, some lines may be reflowed. Blow away any saved line cursor because
   // we may invalidate the nondecreasing combinedArea.y/yMost invariant,
   // and we may even delete the line with the line cursor.
   ClearLineCursor();
 
   if (IsFrameTreeTooDeep(aReflowState, aMetrics)) {
 #ifdef DEBUG_kipp
@@ -973,18 +972,18 @@ nsBlockFrame::Reflow(nsPresContext*     
                  "Somehow we failed to fit all content, even though we have unlimited space!");
     if (NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
       // find the nearest block ancestor that uses the same space manager
       for (const nsHTMLReflowState* ancestorRS = aReflowState.parentReflowState; 
            ancestorRS; 
            ancestorRS = ancestorRS->parentReflowState) {
         nsIFrame* ancestor = ancestorRS->frame;
         if (nsLayoutUtils::GetAsBlock(ancestor) &&
-            aReflowState.mSpaceManager == ancestorRS->mSpaceManager) {
-          // Put the continued floats in ancestor since it uses the same space manager
+            aReflowState.mFloatManager == ancestorRS->mFloatManager) {
+          // Put the continued floats in ancestor since it uses the same float manager
           nsFrameList* ancestorPlace =
             ((nsBlockFrame*)ancestor)->GetOverflowPlaceholders();
           // The ancestor should have this list, since it's being reflowed. But maybe
           // it isn't because of reflow roots or something.
           if (ancestorPlace) {
             for (nsIFrame* f = state.mOverflowPlaceholders.FirstChild();
                  f; f = f->GetNextSibling()) {
               NS_ASSERTION(IsContinuationPlaceholder(f),
@@ -1179,17 +1178,17 @@ nsBlockFrame::Reflow(nsPresContext*     
   CheckInvalidateSizeChange(aMetrics);
 
   FinishAndStoreOverflow(&aMetrics);
 
   // Clear the space manager pointer in the block reflow state so we
   // don't waste time translating the coordinate system back on a dead
   // space manager.
   if (needFloatManager)
-    state.mSpaceManager = nsnull;
+    state.mFloatManager = nsnull;
 
   aStatus = state.mReflowStatus;
 
 #ifdef DEBUG
   if (gNoisyReflow) {
     IndentBy(stdout, gNoiseIndent);
     ListTag(stdout);
     printf(": status=%x (%scomplete) metrics=%d,%d carriedMargin=%d",
@@ -1629,36 +1628,36 @@ nsBlockFrame::PrepareResizeReflow(nsBloc
  * |aDeltaY| indicates how much it will later be slid (assuming it
  * doesn't get marked dirty and reflowed entirely).
  */
 void
 nsBlockFrame::PropagateFloatDamage(nsBlockReflowState& aState,
                                    nsLineBox* aLine,
                                    nscoord aDeltaY)
 {
-  nsSpaceManager *spaceManager = aState.mReflowState.mSpaceManager;
+  nsFloatManager *floatManager = aState.mReflowState.mFloatManager;
   NS_ASSERTION((aState.mReflowState.parentReflowState &&
-                aState.mReflowState.parentReflowState->mSpaceManager == spaceManager) ||
+                aState.mReflowState.parentReflowState->mFloatManager == floatManager) ||
                 aState.mReflowState.mBlockDelta == 0, "Bad block delta passed in");
 
   // Check to see if there are any floats; if there aren't, there can't
   // be any float damage
-  if (!spaceManager->HasAnyFloats())
+  if (!floatManager->HasAnyFloats())
     return;
 
   // Check the damage region recorded in the float damage.
-  if (spaceManager->HasFloatDamage()) {
+  if (floatManager->HasFloatDamage()) {
     // Need to check mBounds *and* mCombinedArea to find intersections 
     // with aLine's floats
     nscoord lineYA = aLine->mBounds.y + aDeltaY;
     nscoord lineYB = lineYA + aLine->mBounds.height;
     nscoord lineYCombinedA = aLine->GetCombinedArea().y + aDeltaY;
     nscoord lineYCombinedB = lineYCombinedA + aLine->GetCombinedArea().height;
-    if (spaceManager->IntersectsDamage(lineYA, lineYB) ||
-        spaceManager->IntersectsDamage(lineYCombinedA, lineYCombinedB)) {
+    if (floatManager->IntersectsDamage(lineYA, lineYB) ||
+        floatManager->IntersectsDamage(lineYCombinedA, lineYCombinedB)) {
       aLine->MarkDirty();
       return;
     }
   }
 
   // Check if the line is moving relative to the space manager
   if (aDeltaY + aState.mReflowState.mBlockDelta != 0) {
     if (aLine->IsBlock()) {
@@ -2984,20 +2983,20 @@ nsBlockFrame::ReflowBlockFrame(nsBlockRe
     
     // Reflow the block into the available space
     // construct the html reflow state for the block. ReflowBlock 
     // will initialize it
     nsHTMLReflowState blockHtmlRS(aState.mPresContext, aState.mReflowState, frame, 
                                   nsSize(availSpace.width, availSpace.height));
     blockHtmlRS.mFlags.mHasClearance = aLine->HasClearance();
     
-    nsSpaceManager::SavedState spaceManagerState;
+    nsFloatManager::SavedState floatManagerState;
     if (mayNeedRetry) {
       blockHtmlRS.mDiscoveredClearance = &clearanceFrame;
-      aState.mSpaceManager->PushState(&spaceManagerState);
+      aState.mFloatManager->PushState(&floatManagerState);
     } else if (!applyTopMargin) {
       blockHtmlRS.mDiscoveredClearance = aState.mReflowState.mDiscoveredClearance;
     }
     
     nsReflowStatus frameReflowStatus = NS_FRAME_COMPLETE;
     rv = brc.ReflowBlock(availSpace, applyTopMargin, aState.mPrevBottomMargin,
                          clearance, aState.IsAdjacentWithTop(),
                          aLine.get(), blockHtmlRS, frameReflowStatus, aState);
@@ -3008,17 +3007,17 @@ nsBlockFrame::ReflowBlockFrame(nsBlockRe
     if (!mayNeedRetry && clearanceFrame &&
         frame->GetRect().y != passOriginalY) {
       Invalidate(frame->GetOverflowRect() + frame->GetPosition());
     }
     
     NS_ENSURE_SUCCESS(rv, rv);
     
     if (mayNeedRetry && clearanceFrame) {
-      aState.mSpaceManager->PopState(&spaceManagerState);
+      aState.mFloatManager->PopState(&floatManagerState);
       aState.mY = startingY;
       aState.mPrevBottomMargin = incomingMargin;
       continue;
     }
     
     aState.mPrevChild = frame;
     
 #if defined(REFLOW_STATUS_COVERAGE)
@@ -3237,28 +3236,28 @@ nsBlockFrame::ReflowInlineFrames(nsBlock
   LineReflowStatus lineReflowStatus = LINE_REFLOW_REDO_NEXT_BAND;
   PRBool movedPastFloat = PR_FALSE;
   do {
     PRBool allowPullUp = PR_TRUE;
     nsIContent* forceBreakInContent = nsnull;
     PRInt32 forceBreakOffset = -1;
     gfxBreakPriority forceBreakPriority = eNoBreak;
     do {
-      nsSpaceManager::SavedState spaceManagerState;
-      aState.mReflowState.mSpaceManager->PushState(&spaceManagerState);
+      nsFloatManager::SavedState floatManagerState;
+      aState.mReflowState.mFloatManager->PushState(&floatManagerState);
 
       // Once upon a time we allocated the first 30 nsLineLayout objects
       // on the stack, and then we switched to the heap.  At that time
       // these objects were large (1100 bytes on a 32 bit system).
       // Then the nsLineLayout object was shrunk to 156 bytes by
       // removing some internal buffers.  Given that it is so much
       // smaller, the complexity of 2 different ways of allocating
       // no longer makes sense.  Now we always allocate on the stack.
       nsLineLayout lineLayout(aState.mPresContext,
-                              aState.mReflowState.mSpaceManager,
+                              aState.mReflowState.mFloatManager,
                               &aState.mReflowState, &aLine);
       lineLayout.Init(&aState, aState.mMinLineHeight, aState.mLineNumber);
       if (forceBreakInContent) {
         lineLayout.ForceBreakAtPosition(forceBreakInContent, forceBreakOffset);
       }
       rv = DoReflowInlineFrames(aState, lineLayout, aLine,
                                 aKeepReflowGoing, &lineReflowStatus,
                                 allowPullUp);
@@ -3271,17 +3270,17 @@ nsBlockFrame::ReflowInlineFrames(nsBlock
           // If there is no saved break position, then this will set
           // set forceBreakInContent to null and we won't back up, which is
           // correct.
           forceBreakInContent = lineLayout.GetLastOptionalBreakPosition(&forceBreakOffset, &forceBreakPriority);
         } else {
           forceBreakInContent = nsnull;
         }
         // restore the space manager state
-        aState.mReflowState.mSpaceManager->PopState(&spaceManagerState);
+        aState.mReflowState.mFloatManager->PopState(&floatManagerState);
         // Clear out float lists
         aState.mCurrentLineFloats.DeleteAll();
         aState.mBelowCurrentLineFloats.DeleteAll();
       }
       
 #ifdef DEBUG
       spins++;
       if (1000 == spins) {
@@ -6771,17 +6770,17 @@ nsBlockFrame::CheckFloats(nsBlockReflowS
     // be larger than necessary, causing this block to get an
     // incorrect desired height (or width).  Some of these floats
     // may not actually have been added to the space manager because
     // they weren't reflowed before being pushed; that's OK,
     // RemoveRegions will ignore them. It is safe to do this here
     // because we know from here on the space manager will only be
     // used for its XMost and YMost, not to place new floats and
     // lines.
-    aState.mSpaceManager->RemoveTrailingRegions(oofs.FirstChild());
+    aState.mFloatManager->RemoveTrailingRegions(oofs.FirstChild());
   }
 }
 
 /* static */
 PRBool
 nsBlockFrame::BlockIsMarginRoot(nsIFrame* aBlock)
 {
   NS_PRECONDITION(aBlock, "Must have a frame");
diff --git a/layout/generic/nsBlockReflowContext.cpp b/layout/generic/nsBlockReflowContext.cpp
--- a/layout/generic/nsBlockReflowContext.cpp
+++ b/layout/generic/nsBlockReflowContext.cpp
@@ -36,17 +36,17 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* class that a parent frame uses to reflow a block frame */
 
 #include "nsBlockReflowContext.h"
 #include "nsLineLayout.h"
-#include "nsSpaceManager.h"
+#include "nsFloatManager.h"
 #include "nsIFontMetrics.h"
 #include "nsPresContext.h"
 #include "nsFrameManager.h"
 #include "nsIContent.h"
 #include "nsStyleContext.h"
 #include "nsHTMLContainerFrame.h"
 #include "nsBlockFrame.h"
 #include "nsLineBox.h"
@@ -301,19 +301,19 @@ nsBlockReflowContext::ReflowBlock(const 
   // Let frame know that we are reflowing it
   mFrame->WillReflow(mPresContext);
 
 #ifdef DEBUG
   mMetrics.width = nscoord(0xdeadbeef);
   mMetrics.height = nscoord(0xdeadbeef);
 #endif
 
-  mOuterReflowState.mSpaceManager->Translate(tx, ty);
+  mOuterReflowState.mFloatManager->Translate(tx, ty);
   rv = mFrame->Reflow(mPresContext, mMetrics, aFrameRS, aFrameReflowStatus);
-  mOuterReflowState.mSpaceManager->Translate(-tx, -ty);
+  mOuterReflowState.mFloatManager->Translate(-tx, -ty);
 
 #ifdef DEBUG
   if (!NS_INLINE_IS_BREAK_BEFORE(aFrameReflowStatus)) {
     if (CRAZY_WIDTH(mMetrics.width) || CRAZY_HEIGHT(mMetrics.height)) {
       printf("nsBlockReflowContext: ");
       nsFrame::ListTag(stdout, mFrame);
       printf(" metrics=%d,%d!\n", mMetrics.width, mMetrics.height);
     }
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -88,25 +88,25 @@ nsBlockReflowState::nsBlockReflowState(c
   }
   if (GetFlag(BRS_ISTOPMARGINROOT)) {
     SetFlag(BRS_APPLYTOPMARGIN, PR_TRUE);
   }
   if (aBlockNeedsFloatManager) {
     SetFlag(BRS_FLOAT_MGR, PR_TRUE);
   }
   
-  mSpaceManager = aReflowState.mSpaceManager;
+  mFloatManager = aReflowState.mFloatManager;
 
-  NS_ASSERTION(mSpaceManager,
-               "SpaceManager should be set in nsBlockReflowState" );
-  if (mSpaceManager) {
+  NS_ASSERTION(mFloatManager,
+               "FloatManager should be set in nsBlockReflowState" );
+  if (mFloatManager) {
     // Translate into our content area and then save the 
     // coordinate system origin for later.
-    mSpaceManager->Translate(borderPadding.left, borderPadding.top);
-    mSpaceManager->GetTranslation(mSpaceManagerX, mSpaceManagerY);
+    mFloatManager->Translate(borderPadding.left, borderPadding.top);
+    mFloatManager->GetTranslation(mFloatManagerX, mFloatManagerY);
   }
 
   mReflowStatus = NS_FRAME_COMPLETE;
 
   mPresContext = aPresContext;
   mNextInFlow = static_cast<nsBlockFrame*>(mBlock->GetNextInFlow());
 
   NS_ASSERTION(NS_UNCONSTRAINEDSIZE != aReflowState.ComputedWidth(),
@@ -129,17 +129,16 @@ nsBlockReflowState::nsBlockReflowState(c
   else {
     // When we are not in a paginated situation then we always use
     // an constrained height.
     SetFlag(BRS_UNCONSTRAINEDHEIGHT, PR_TRUE);
     mContentArea.height = mBottomEdge = NS_UNCONSTRAINEDSIZE;
   }
 
   mY = borderPadding.top;
-  mBand.Init(mSpaceManager, mContentArea);
 
   mPrevChild = nsnull;
   mCurrentLine = aFrame->end_lines();
 
   mMinLineHeight = nsHTMLReflowState::CalcLineHeight(aReflowState.frame);
 
   // Calculate mOutsideBulletX
   GetAvailableSpace();
@@ -165,19 +164,19 @@ nsBlockReflowState::SetupOverflowPlaceho
 
 nsBlockReflowState::~nsBlockReflowState()
 {
   NS_ASSERTION(mOverflowPlaceholders.IsEmpty(),
                "Leaking overflow placeholder frames");
 
   // Restore the coordinate system, unless the space manager is null,
   // which means it was just destroyed.
-  if (mSpaceManager) {
+  if (mFloatManager) {
     const nsMargin& borderPadding = BorderPadding();
-    mSpaceManager->Translate(-borderPadding.left, -borderPadding.top);
+    mFloatManager->Translate(-borderPadding.left, -borderPadding.top);
   }
 
   if (mBlock->GetStateBits() & NS_BLOCK_HAS_OVERFLOW_PLACEHOLDERS) {
     mBlock->UnsetProperty(nsGkAtoms::overflowPlaceholdersProperty);
     mBlock->RemoveStateBits(NS_BLOCK_HAS_OVERFLOW_PLACEHOLDERS);
   }
 }
 
@@ -252,18 +251,17 @@ nsBlockReflowState::ComputeReplacedBlock
 // GetAvailableSpace has already been called.
 void
 nsBlockReflowState::ComputeBlockAvailSpace(nsIFrame* aFrame,
                                            const nsStyleDisplay* aDisplay,
                                            PRBool aBlockAvoidsFloats,
                                            nsRect& aResult)
 {
 #ifdef REALLY_NOISY_REFLOW
-  printf("CBAS frame=%p has float count %d\n", aFrame, mBand.GetFloatCount());
-  mBand.List();
+  printf("CBAS frame=%p has float count %u\n", aFrame, mBandFloatCount);
 #endif
   aResult.y = mY;
   aResult.height = GetFlag(BRS_UNCONSTRAINEDHEIGHT)
     ? NS_UNCONSTRAINEDSIZE
     : PR_MAX(0, mReflowState.availableHeight - mY);
   // mY might be greater than mBottomEdge if the block's top margin pushes
   // it off the page/column. Negative available height can confuse other code
   // and is nonsense in principle.
@@ -281,17 +279,17 @@ nsBlockReflowState::ComputeBlockAvailSpa
   // true but nsBlockFrame::BlockCanIntersectFloats is false,
   // nsBlockFrame::WidthToClearPastFloats would need to use the
   // shrink-wrap formula, max(MIN_WIDTH, min(avail width, PREF_WIDTH))
   // rather than just using MIN_WIDTH.
   NS_ASSERTION(nsBlockFrame::BlockCanIntersectFloats(aFrame) == 
                  !aBlockAvoidsFloats,
                "unexpected replaced width");
   if (!aBlockAvoidsFloats) {
-    if (mBand.GetFloatCount()) {
+    if (mBandFloatCount) {
       // Use the float-edge property to determine how the child block
       // will interact with the float.
       const nsStyleBorder* borderStyle = aFrame->GetStyleBorder();
       switch (borderStyle->mFloatEdge) {
         default:
         case NS_STYLE_FLOAT_EDGE_CONTENT:  // content and only content does runaround of floats
           // The child block will flow around the float. Therefore
           // give it all of the available space.
@@ -337,31 +335,33 @@ nsBlockReflowState::ComputeBlockAvailSpa
 }
 
 void
 nsBlockReflowState::GetAvailableSpace(nscoord aY, PRBool aRelaxHeightConstraint)
 {
 #ifdef DEBUG
   // Verify that the caller setup the coordinate system properly
   nscoord wx, wy;
-  mSpaceManager->GetTranslation(wx, wy);
-  NS_ASSERTION((wx == mSpaceManagerX) && (wy == mSpaceManagerY),
+  mFloatManager->GetTranslation(wx, wy);
+  NS_ASSERTION((wx == mFloatManagerX) && (wy == mFloatManagerY),
                "bad coord system");
 #endif
 
-  mBand.GetAvailableSpace(aY - BorderPadding().top, aRelaxHeightConstraint,
-                          mAvailSpaceRect);
+  mFloatManager->GetBandInfo(aY - BorderPadding().top, 
+                             aRelaxHeightConstraint ? nscoord_MAX
+                                                    : mContentArea.height,
+                             mAvailSpaceRect, &mBandFloatCount);
 
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
-    printf("GetAvailableSpace: band=%d,%d,%d,%d count=%d\n",
+    printf("GetAvailableSpace: band=%d,%d,%d,%d count=%u\n",
            mAvailSpaceRect.x, mAvailSpaceRect.y,
            mAvailSpaceRect.width, mAvailSpaceRect.height,
-           mBand.GetTrapezoidCount());
+           mBandFloatCount);
   }
 #endif
 }
 
 /*
  * Reconstruct the vertical margin before the line |aLine| in order to
  * do an incremental reflow that begins with |aLine| without reflowing
  * the line before it.  |aLine| may point to the fencepost at the end of
@@ -424,27 +424,27 @@ nsBlockReflowState::RecoverFloats(nsLine
         nsPoint p = floatFrame->GetPosition();
         floatFrame->SetPosition(nsPoint(p.x, p.y + aDeltaY));
         nsContainerFrame::PositionFrameView(floatFrame);
         nsContainerFrame::PositionChildViews(floatFrame);
       }
 #ifdef DEBUG
       if (nsBlockFrame::gNoisyReflow || nsBlockFrame::gNoisyFloatManager) {
         nscoord tx, ty;
-        mSpaceManager->GetTranslation(tx, ty);
+        mFloatManager->GetTranslation(tx, ty);
         nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
         printf("RecoverFloats: txy=%d,%d (%d,%d) ",
-               tx, ty, mSpaceManagerX, mSpaceManagerY);
+               tx, ty, mFloatManagerX, mFloatManagerY);
         nsFrame::ListTag(stdout, floatFrame);
         printf(" aDeltaY=%d region={%d,%d,%d,%d}\n",
                aDeltaY, fc->mRegion.x, fc->mRegion.y,
                fc->mRegion.width, fc->mRegion.height);
       }
 #endif
-      mSpaceManager->AddRectRegion(floatFrame, fc->mRegion);
+      mFloatManager->AddFloat(floatFrame, fc->mRegion);
       fc = fc->Next();
     }
   } else if (aLine->IsBlock()) {
     nsBlockFrame *kid = nsLayoutUtils::GetAsBlock(aLine->mFirstChild);
     // don't recover any state inside a block that has its own space
     // manager (we don't currently have any blocks like this, though,
     // thanks to our use of extra frames for 'overflow')
     if (kid && !nsBlockFrame::BlockNeedsFloatManager(kid)) {
@@ -459,26 +459,26 @@ nsBlockReflowState::RecoverFloats(nsLine
                                        nsGkAtoms::computedOffsetProperty));
 
         if (offsets) {
           tx -= offsets->x;
           ty -= offsets->y;
         }
       }
  
-      mSpaceManager->Translate(tx, ty);
+      mFloatManager->Translate(tx, ty);
       for (nsBlockFrame::line_iterator line = kid->begin_lines(),
                                    line_end = kid->end_lines();
            line != line_end;
            ++line)
         // Pass 0, not the real DeltaY, since these floats aren't
         // moving relative to their parent block, only relative to
         // the space manager.
         RecoverFloats(line, 0);
-      mSpaceManager->Translate(-tx, -ty);
+      mFloatManager->Translate(-tx, -ty);
     }
   }
 }
 
 /**
  * Everything done in this function is done O(N) times for each pass of
  * reflow so it is O(N*M) where M is the number of incremental reflow
  * passes.  That's bad.  Don't do stuff here.
@@ -498,38 +498,38 @@ nsBlockReflowState::RecoverStateFrom(nsL
   mCurrentLine = aLine;
 
   // Place floats for this line into the space manager
   if (aLine->HasFloats() || aLine->IsBlock()) {
     // Undo border/padding translation since the nsFloatCache's
     // coordinates are relative to the frame not relative to the
     // border/padding.
     const nsMargin& bp = BorderPadding();
-    mSpaceManager->Translate(-bp.left, -bp.top);
+    mFloatManager->Translate(-bp.left, -bp.top);
 
     RecoverFloats(aLine, aDeltaY);
 
 #ifdef DEBUG
     if (nsBlockFrame::gNoisyReflow || nsBlockFrame::gNoisyFloatManager) {
-      mSpaceManager->List(stdout);
+      mFloatManager->List(stdout);
     }
 #endif
     // And then put the translation back again
-    mSpaceManager->Translate(bp.left, bp.top);
+    mFloatManager->Translate(bp.left, bp.top);
   }
 }
 
 PRBool
 nsBlockReflowState::IsImpactedByFloat() const
 {
 #ifdef REALLY_NOISY_REFLOW
   printf("nsBlockReflowState::IsImpactedByFloat %p returned %d\n", 
-         this, mBand.GetFloatCount());
+         this, mBandFloatCount > 0);
 #endif
-  return mBand.GetFloatCount() > 0;
+  return mBandFloatCount > 0;
 }
 
 
 PRBool
 nsBlockReflowState::InitFloat(nsLineLayout&       aLineLayout,
                               nsPlaceholderFrame* aPlaceholder,
                               nscoord             aAvailableWidth,
                               nsReflowStatus&     aReflowStatus)
@@ -579,20 +579,20 @@ nsBlockReflowState::AddFloat(nsLineLayou
       (aLineLayout.LineIsEmpty() ||
        mBlock->ComputeFloatWidth(*this, aPlaceholder) <= aAvailableWidth)) {
     // Because we are in the middle of reflowing a placeholder frame
     // within a line (and possibly nested in an inline frame or two
     // that's a child of our block) we need to restore the space
     // manager's translation to the space that the block resides in
     // before placing the float.
     nscoord ox, oy;
-    mSpaceManager->GetTranslation(ox, oy);
-    nscoord dx = ox - mSpaceManagerX;
-    nscoord dy = oy - mSpaceManagerY;
-    mSpaceManager->Translate(-dx, -dy);
+    mFloatManager->GetTranslation(ox, oy);
+    nscoord dx = ox - mFloatManagerX;
+    nscoord dy = oy - mFloatManagerY;
+    mFloatManager->Translate(-dx, -dy);
 
     // And then place it
     PRBool isLeftFloat;
     // force it to fit if we're at the top of the block and we can't
     // break before this
     PRBool forceFit = IsAdjacentWithTop() && !aLineLayout.LineIsBreakable();
     placed = FlowAndPlaceFloat(fc, &isLeftFloat, aReflowStatus, forceFit);
     NS_ASSERTION(placed || !forceFit,
@@ -622,17 +622,17 @@ nsBlockReflowState::AddFloat(nsLineLayou
         // Make sure we propagate the truncated status; this signals the
         // block to push the line to the next page.
         aReflowStatus |= NS_FRAME_TRUNCATED;
       }
       delete fc;
     }
 
     // Restore coordinate system
-    mSpaceManager->Translate(dx, dy);
+    mFloatManager->Translate(dx, dy);
   }
   else {
     // Always claim to be placed; we don't know whether we fit yet, so we
     // deal with this in PlaceBelowCurrentLineFloats
     placed = PR_TRUE;
     // This float will be placed after the line is done (it is a
     // below-current-line float).
     mBelowCurrentLineFloats.Append(fc);
@@ -654,17 +654,17 @@ nsBlockReflowState::AddFloat(nsLineLayou
 
 PRBool
 nsBlockReflowState::CanPlaceFloat(const nsSize& aFloatSize,
                                   PRUint8 aFloats, PRBool aForceFit)
 {
   // If the current Y coordinate is not impacted by any floats
   // then by definition the float fits.
   PRBool result = PR_TRUE;
-  if (0 != mBand.GetFloatCount()) {
+  if (0 != mBandFloatCount) {
     // XXX We should allow overflow by up to half a pixel here (bug 21193).
     if (mAvailSpaceRect.width < aFloatSize.width) {
       // The available width is too narrow (and its been impacted by a
       // prior float)
       result = PR_FALSE;
     }
   }
 
@@ -720,17 +720,17 @@ nsBlockReflowState::CanPlaceFloat(const 
         // there is no more available space. We lose.
         result = PR_FALSE;
         break;
       }
 
       mY += mAvailSpaceRect.height;
       GetAvailableSpace(mY, aForceFit);
 
-      if (0 != mBand.GetFloatCount()) {
+      if (0 != mBandFloatCount) {
         if ((xa < mAvailSpaceRect.x) || (xb > mAvailSpaceRect.XMost())) {
           // The float can't go here.
           result = PR_FALSE;
           break;
         }
       }
 
       // See if there is now enough height for the float.
@@ -770,17 +770,17 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
   // Grab the float's display information
   const nsStyleDisplay* floatDisplay = floatFrame->GetStyleDisplay();
 
   // The float's old region, so we can propagate damage.
   nsRect oldRegion = aFloatCache->mRegion;
 
   // Enforce CSS2 9.5.1 rule [2], i.e., make sure that a float isn't
   // ``above'' another float that preceded it in the flow.
-  mY = NS_MAX(mSpaceManager->GetLowestRegionTop() + BorderPadding().top, mY);
+  mY = NS_MAX(mFloatManager->GetLowestFloatTop() + BorderPadding().top, mY);
 
   // See if the float should clear any preceding floats...
   // XXX We need to mark this float somehow so that it gets reflowed
   // when floats are inserted before it.
   if (NS_STYLE_CLEAR_NONE != floatDisplay->mBreakType) {
     // XXXldb Does this handle vertical margins correctly?
     mY = ClearFloats(mY, floatDisplay->mBreakType);
   }
@@ -939,17 +939,17 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
     region.width = 0;
   }
   if (region.height < 0) {
     region.height = 0;
   }
 #ifdef DEBUG
   nsresult rv =
 #endif
-  mSpaceManager->AddRectRegion(floatFrame, region);
+  mFloatManager->AddFloat(floatFrame, region);
   NS_ABORT_IF_FALSE(NS_SUCCEEDED(rv), "bad float placement");
 
   // Save away the floats region in the spacemanager, after making
   // it relative to the containing block's frame instead of relative
   // to the spacemanager translation (which is inset by the
   // border+padding).
   // XXX Maybe RecoverFloats should calc/add in the borderPadding itself?
   // It's kind of confusing to have the spacemanager translation be different
@@ -961,25 +961,25 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
   // space manager.
   if (aFloatCache->mRegion != oldRegion) {
     // XXXwaterson conservative: we could probably get away with noting
     // less damage; e.g., if only height has changed, then only note the
     // area into which the float has grown or from which the float has
     // shrunk.
     nscoord top = NS_MIN(region.y, oldRegion.y);
     nscoord bottom = NS_MAX(region.YMost(), oldRegion.YMost());
-    mSpaceManager->IncludeInDamage(top, bottom);
+    mFloatManager->IncludeInDamage(top, bottom);
   }
 
 #ifdef NOISY_SPACEMANAGER
   nscoord tx, ty;
-  mSpaceManager->GetTranslation(tx, ty);
+  mFloatManager->GetTranslation(tx, ty);
   nsFrame::ListTag(stdout, mBlock);
-  printf(": FlowAndPlaceFloat: AddRectRegion: txy=%d,%d (%d,%d) {%d,%d,%d,%d}\n",
-         tx, ty, mSpaceManagerX, mSpaceManagerY,
+  printf(": FlowAndPlaceFloat: AddFloat: txy=%d,%d (%d,%d) {%d,%d,%d,%d}\n",
+         tx, ty, mFloatManagerX, mFloatManagerY,
          aFloatCache->mRegion.x, aFloatCache->mRegion.y,
          aFloatCache->mRegion.width, aFloatCache->mRegion.height);
 #endif
 
   // Calculate the actual origin of the float frame's border rect
   // relative to the parent block; floatX/Y must be converted from space-manager
   // coordinates to parent coordinates, and the margin must be added in
   // to get the border rect
@@ -1081,32 +1081,32 @@ nsBlockReflowState::ClearFloats(nscoord 
     printf("clear floats: in: aY=%d(%d)\n",
            aY, aY - BorderPadding().top);
   }
 #endif
 
 #ifdef NOISY_FLOAT_CLEARING
   printf("nsBlockReflowState::ClearFloats: aY=%d breakType=%d\n",
          aY, aBreakType);
-  mSpaceManager->List(stdout);
+  mFloatManager->List(stdout);
 #endif
   
   const nsMargin& bp = BorderPadding();
   nscoord newY = aY;
 
   if (aBreakType != NS_STYLE_CLEAR_NONE) {
-    newY = bp.top + mSpaceManager->ClearFloats(newY - bp.top, aBreakType);
+    newY = bp.top + mFloatManager->ClearFloats(newY - bp.top, aBreakType);
   }
 
   if (aReplacedBlock) {
     for (;;) {
       GetAvailableSpace(newY, PR_FALSE);
       nsBlockFrame::ReplacedElementWidthToClear replacedWidth =
         nsBlockFrame::WidthToClearPastFloats(*this, aReplacedBlock);
-      if (mBand.GetFloatCount() == 0 ||
+      if (mBandFloatCount == 0 ||
           PR_MAX(mAvailSpaceRect.x, replacedWidth.marginLeft) +
             replacedWidth.borderBoxWidth +
             PR_MAX(mContentArea.width -
                      PR_MIN(mContentArea.width, mAvailSpaceRect.XMost()),
                    replacedWidth.marginRight) <=
           mContentArea.width) {
         break;
       }
@@ -1119,18 +1119,18 @@ nsBlockReflowState::ClearFloats(nscoord 
           // Stop trying to clear here; we'll just get pushed to the
           // next column or page and try again there.
           break;
         }
         NS_NOTREACHED("avail space rect with zero height!");
         newY += 1;
       }
     }
-    // Restore mBand and mAvailSpaceRect to the way they were.  This may
-    // well not be needed, and we should probably come up with
+    // Restore mBandFloatCount and mAvailSpaceRect to the way they were.
+    // This may well not be needed, and we should probably come up with
     // well-defined rules about when these members are valid so that
     // it's clearly not needed.
     GetAvailableSpace();
   }
 
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -38,17 +38,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* state used in reflow of block frames */
 
 #ifndef nsBlockReflowState_h__
 #define nsBlockReflowState_h__
 
-#include "nsBlockBandData.h"
+#include "nsFloatManager.h"
 #include "nsLineBox.h"
 #include "nsFrameList.h"
 #include "nsBlockFrame.h"
 
   // block reflow state flags
 #define BRS_UNCONSTRAINEDHEIGHT   0x00000001
 #define BRS_ISTOPMARGINROOT       0x00000002  // Is this frame a root for top/bottom margin collapsing?
 #define BRS_ISBOTTOMMARGINROOT    0x00000004
@@ -187,24 +187,24 @@ public:
 
   // The block frame that is using this object
   nsBlockFrame* mBlock;
 
   nsPresContext* mPresContext;
 
   const nsHTMLReflowState& mReflowState;
 
-  nsSpaceManager* mSpaceManager;
+  nsFloatManager* mFloatManager;
 
-  // The coordinates within the spacemanager where the block is being
+  // The coordinates within the float manager where the block is being
   // placed <b>after</b> taking into account the blocks border and
   // padding. This, therefore, represents the inner "content area" (in
   // spacemanager coordinates) where child frames will be placed,
   // including child blocks and floats.
-  nscoord mSpaceManagerX, mSpaceManagerY;
+  nscoord mFloatManagerX, mFloatManagerY;
 
   // XXX get rid of this
   nsReflowStatus mReflowStatus;
 
   // The x-position we should place an outside bullet relative to.
   // This is the border-box edge of the principal box.  However, if a line box
   // would be displaced by floats, we want to displace it by the same amount.
   // That is, we act as though the edge of the floats is the content-edge of
@@ -249,16 +249,21 @@ public:
 
   // The current Y coordinate in the block
   nscoord mY;
 
   // The available space within the current band.
   // (relative to the *content*-rect of the block)
   nsRect mAvailSpaceRect;
 
+  // The number of floats on the sides of mAvailSpaceRect, including
+  // floats that do not reduce mAvailSpaceRect because they are in the
+  // margins.
+  PRUint32 mBandFloatCount;
+
   // The combined area of all floats placed so far
   nsRect mFloatCombinedArea;
 
   nsFloatCacheFreeList mFloatCacheFreeList;
 
   // Previous child. This is used when pulling up a frame to update
   // the sibling list.
   nsIFrame* mPrevChild;
@@ -267,19 +272,16 @@ public:
   nsCollapsingMargin mPrevBottomMargin;
 
   // The current next-in-flow for the block. When lines are pulled
   // from a next-in-flow, this is used to know which next-in-flow to
   // pull from. When a next-in-flow is emptied of lines, we advance
   // this to the next next-in-flow.
   nsBlockFrame* mNextInFlow;
 
-  // The current band data for the current Y coordinate
-  nsBlockBandData mBand;
-
   //----------------------------------------
 
   // Temporary line-reflow state. This state is used during the reflow
   // of a given line, but doesn't have meaning before or after.
 
   // The list of floats that are "current-line" floats. These are
   // added to the line after the line has been reflowed, to keep the
   // list fiddling from being N^2.
diff --git a/layout/generic/nsSpaceManager.cpp b/layout/generic/nsFloatManager.cpp
rename from layout/generic/nsSpaceManager.cpp
rename to layout/generic/nsFloatManager.cpp
--- a/layout/generic/nsSpaceManager.cpp
+++ b/layout/generic/nsFloatManager.cpp
@@ -15,83 +15,41 @@
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
- *   Pierre Phaneuf <pp@ludusdesign.com>
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-/*
- * class that manages regions of 2-D space, originally designed
- * generally but actually specific to space occupied by floats
- */
+/* class that manages rules for positioning floats */
 
-#include "nsSpaceManager.h"
-#include "nsPoint.h"
-#include "nsRect.h"
-#include "nsSize.h"
-#include <stdlib.h>
-#include "nsVoidArray.h"
-#include "nsIFrame.h"
-#include "nsString.h"
+#include "nsFloatManager.h"
 #include "nsIPresShell.h"
 #include "nsMemory.h"
 #include "nsHTMLReflowState.h"
-#include "nsHashSets.h"
-#ifdef DEBUG
-#include "nsIFrameDebug.h"
-#endif
 
-/////////////////////////////////////////////////////////////////////////////
-// BandList
-
-PRInt32 nsSpaceManager::sCachedSpaceManagerCount = 0;
-void* nsSpaceManager::sCachedSpaceManagers[NS_SPACE_MANAGER_CACHE_SIZE];
-
-#define NSCOORD_MIN (-2147483647 - 1) /* minimum signed value */
-
-nsSpaceManager::BandList::BandList()
-  : nsSpaceManager::BandRect(NSCOORD_MIN, NSCOORD_MIN, NSCOORD_MIN, NSCOORD_MIN, (nsIFrame*)nsnull)
-{
-  PR_INIT_CLIST(this);
-}
-
-void
-nsSpaceManager::BandList::Clear()
-{
-  if (!IsEmpty()) {
-    BandRect* bandRect = Head();
-  
-    while (bandRect != this) {
-      BandRect* nxt = bandRect->Next();
-  
-      delete bandRect;
-      bandRect = nxt;
-    }
-  
-    PR_INIT_CLIST(this);
-  }
-}
+PRInt32 nsFloatManager::sCachedFloatManagerCount = 0;
+void* nsFloatManager::sCachedFloatManagers[NS_FLOAT_MANAGER_CACHE_SIZE];
 
 /////////////////////////////////////////////////////////////////////////////
 
 // PresShell Arena allocate callback (for nsIntervalSet use below)
 static void*
 PSArenaAllocCB(size_t aSize, void* aClosure)
 {
   return static_cast<nsIPresShell*>(aClosure)->AllocateFrame(aSize);
@@ -100,1378 +58,231 @@ PSArenaAllocCB(size_t aSize, void* aClos
 // PresShell Arena free callback (for nsIntervalSet use below)
 static void
 PSArenaFreeCB(size_t aSize, void* aPtr, void* aClosure)
 {
   static_cast<nsIPresShell*>(aClosure)->FreeFrame(aSize, aPtr);
 }
 
 /////////////////////////////////////////////////////////////////////////////
-// nsSpaceManager
+// nsFloatManager
 
-nsSpaceManager::nsSpaceManager(nsIPresShell* aPresShell)
-  : mLowestTop(NSCOORD_MIN),
-    mFloatDamage(PSArenaAllocCB, PSArenaFreeCB, aPresShell),
-    mHaveCachedLeftYMost(PR_TRUE),
-    mHaveCachedRightYMost(PR_TRUE),
-    mMaximalLeftYMost(nscoord_MIN),
-    mMaximalRightYMost(nscoord_MIN),
-    mCachedBandPosition(nsnull)
+nsFloatManager::nsFloatManager(nsIPresShell* aPresShell)
+  : mX(0), mY(0),
+    mFloatDamage(PSArenaAllocCB, PSArenaFreeCB, aPresShell)
 {
-  MOZ_COUNT_CTOR(nsSpaceManager);
-  mX = mY = 0;
-  mFrameInfoMap = nsnull;
+  MOZ_COUNT_CTOR(nsFloatManager);
+  PR_INIT_CLIST(mFloats);
 }
 
-void
-nsSpaceManager::ClearFrameInfo()
+nsFloatManager::~nsFloatManager()
 {
-  while (mFrameInfoMap) {
-    FrameInfo*  next = mFrameInfoMap->mNext;
-    delete mFrameInfoMap;
-    mFrameInfoMap = next;
-  }
-}
-
-nsSpaceManager::~nsSpaceManager()
-{
-  MOZ_COUNT_DTOR(nsSpaceManager);
-  mBandList.Clear();
-  ClearFrameInfo();
+  MOZ_COUNT_DTOR(nsFloatManager);
 }
 
 // static
-void* nsSpaceManager::operator new(size_t aSize) CPP_THROW_NEW
+void* nsFloatManager::operator new(size_t aSize) CPP_THROW_NEW
 {
-  if (sCachedSpaceManagerCount > 0) {
+  if (sCachedFloatManagerCount > 0) {
     // We have cached unused instances of this class, return a cached
     // instance in stead of always creating a new one.
-    return sCachedSpaceManagers[--sCachedSpaceManagerCount];
+    return sCachedFloatManagers[--sCachedFloatManagerCount];
   }
 
   // The cache is empty, this means we haveto create a new instance using
   // the global |operator new|.
   return nsMemory::Alloc(aSize);
 }
 
 void
-nsSpaceManager::operator delete(void* aPtr, size_t aSize)
+nsFloatManager::operator delete(void* aPtr, size_t aSize)
 {
   if (!aPtr)
     return;
   // This space manager is no longer used, if there's still room in
   // the cache we'll cache this space manager, unless the layout
   // module was already shut down.
 
-  if (sCachedSpaceManagerCount < NS_SPACE_MANAGER_CACHE_SIZE &&
-      sCachedSpaceManagerCount >= 0) {
+  if (sCachedFloatManagerCount < NS_FLOAT_MANAGER_CACHE_SIZE &&
+      sCachedFloatManagerCount >= 0) {
     // There's still space in the cache for more instances, put this
     // instance in the cache in stead of deleting it.
 
-    sCachedSpaceManagers[sCachedSpaceManagerCount++] = aPtr;
+    sCachedFloatManagers[sCachedFloatManagerCount++] = aPtr;
     return;
   }
 
   // The cache is full, or the layout module has been shut down,
   // delete this space manager.
   nsMemory::Free(aPtr);
 }
 
 
 /* static */
-void nsSpaceManager::Shutdown()
+void nsFloatManager::Shutdown()
 {
   // The layout module is being shut down, clean up the cache and
   // disable further caching.
 
   PRInt32 i;
 
-  for (i = 0; i < sCachedSpaceManagerCount; i++) {
-    void* spaceManager = sCachedSpaceManagers[i];
+  for (i = 0; i < sCachedFloatManagerCount; i++) {
+    void* spaceManager = sCachedFloatManagers[i];
     if (spaceManager)
       nsMemory::Free(spaceManager);
   }
 
   // Disable further caching.
-  sCachedSpaceManagerCount = -1;
+  sCachedFloatManagerCount = -1;
 }
 
-PRBool
-nsSpaceManager::YMost(nscoord& aYMost) const
+void
+nsFloatManager::GetBandInfo(nscoord       aYOffset,
+                            nscoord       aMaxHeight,
+                            nsRect&       aAvailSpace,
+                            PRUint32*     aFloatCount) const
 {
-  PRBool result;
-
-  if (mBandList.IsEmpty()) {
-    aYMost = 0;
-    result = PR_FALSE;
-
-  } else {
-    BandRect* lastRect = mBandList.Tail();
-
-    aYMost = lastRect->mBottom;
-    result = PR_TRUE;
-  }
-
-  return result;
+  NS_NOTYETIMPLEMENTED("write me");
 }
 
-/**
- * Internal function that returns the list of available and unavailable space
- * within the band
- *
- * Note: If the clip rectangle has 0 width and is aligned exactly at
- * aBand->mLeft or aBand->mRight, we count it as intersecting the band, and we
- * return an unavailable-space trapezoid for the band.  (The alternative would
- * be to return a zero-width available-space trapezoid, which would make no
- * sense.  See bug 403129)
- *
- * @param aBand the first rect in the band
- * @param aY the y-offset in world coordinates
- * @param aMaxSize the size to use to constrain the band data
- * @param aBandData the object to populate with available and unavailable space
- */
 nsresult
-nsSpaceManager::GetBandAvailableSpace(const BandRect* aBand,
-                                      nscoord         aY,
-                                      const nsSize&   aMaxSize,
-                                      nsBandData&     aBandData) const
+nsFloatManager::AddFloat(nsIFrame* aFloatFrame, const nsRect& aMarginRect)
 {
-  nscoord          topOfBand = aBand->mTop;
-  nscoord          localY = aY - mY;
-  nscoord          height = PR_MIN(aBand->mBottom - aY, aMaxSize.height);
-  nsBandTrapezoid* trapezoid = aBandData.mTrapezoids;
-  nscoord          rightEdge = mX + aMaxSize.width;
+  FloatInfo *info = new FloatInfo(aFloatFrame, aMarginRect + nsPoint(mX, mY));
+  if (!info)
+    return NS_ERROR_OUT_OF_MEMORY;
 
-  // Initialize the band data
-  aBandData.mCount = 0;
+  // Set mLeftYMost and mRightYMost.
+  if (HasAnyFloats()) {
+    FloatInfo *tail = FloatsTail();
+    info->mLeftYMost = tail->mLeftYMost;
+    info->mRightYMost = tail->mRightYMost;
+  } else {
+    info->mLeftYMost = nscoord_MIN;
+    info->mRightYMost = nscoord_MIN;
+  }
+  PRUint8 floatStyle = aFloatFrame->GetStyleDisplay()->mFloats;
+  NS_ASSERTION(floatStyle == NS_STYLE_FLOAT_LEFT ||
+               floatStyle == NS_STYLE_FLOAT_RIGHT, "unexpected float");
+  nscoord& sideYMost = (floatStyle == NS_STYLE_FLOAT_LEFT) ? info->mLeftYMost
+                                                           : info->mRightYMost;
+  nscoord thisYMost = info->mRect.YMost();
+  if (thisYMost > sideYMost)
+    sideYMost = thisYMost;
 
-  // Skip any rectangles that are to the left of the local coordinate space
-  while (aBand->mTop == topOfBand) {
-    if (aBand->mRight > mX ||
-        (aMaxSize.width == 0 && aBand->mRight == mX)) {
-      break;
-    }
-
-    // Get the next rect in the band
-    aBand = aBand->Next();
-  }
-
-  // This is used to track the current x-location within the band. This is in
-  // world coordinates
-  nscoord   left = mX;
-
-  // Process the remaining rectangles that are within the clip width
-  while ((aBand->mTop == topOfBand) && 
-         (aBand->mLeft < rightEdge || 
-          (aMaxSize.width == 0 && aBand->mLeft == mX))) {
-    // Compare the left edge of the occupied space with the current left
-    // coordinate
-    if (aBand->mLeft > left) {
-      // The rect is to the right of our current left coordinate, so we've
-      // found some available space
-      if (aBandData.mCount >= aBandData.mSize) {
-        // Not enough space in the array of trapezoids
-        aBandData.mCount += 2 * aBand->Length() + 2;  // estimate the number needed
-        return NS_ERROR_FAILURE;
-      }
-      trapezoid->mFrames = nsnull;
-
-      // Assign the trapezoid a rectangular shape. The trapezoid must be in the
-      // local coordinate space, so convert the current left coordinate
-      *trapezoid = nsRect(left - mX, localY, aBand->mLeft - left, height);
-
-      // Move to the next output rect
-      trapezoid++;
-      aBandData.mCount++;
-    }
-
-    // The rect represents unavailable space, so add another trapezoid
-    if (aBandData.mCount >= aBandData.mSize) {
-      // Not enough space in the array of trapezoids
-      aBandData.mCount += 2 * aBand->Length() + 1;  // estimate the number needed
-      return NS_ERROR_FAILURE;
-    }
-    NS_ASSERTION(aBand->mFrames.Count() > 0, "unexpected frame count");
-    trapezoid->mFrames = &aBand->mFrames;
-
-    nscoord x = aBand->mLeft;
-    // The first band can straddle the clip rect
-    if (x < mX) {
-      // Clip the left edge
-      x = mX;
-    }
-
-    // Assign the trapezoid a rectangular shape. The trapezoid must be in the
-    // local coordinate space, so convert the rects's left coordinate
-    *trapezoid = nsRect(x - mX, localY, aBand->mRight - x, height);
-
-    // Move to the next output rect
-    trapezoid++;
-    aBandData.mCount++;
-
-    // Adjust our current x-location within the band
-    left = aBand->mRight;
-
-    // Move to the next rect within the band
-    aBand = aBand->Next();
-  }
-
-  // No more rects left in the band. If we haven't yet reached the right edge,
-  // then all the remaining space is available
-  if (left < rightEdge || aBandData.mCount == 0) {
-    if (aBandData.mCount >= aBandData.mSize) {
-      // Not enough space in the array of trapezoids
-      aBandData.mCount++;
-      return NS_ERROR_FAILURE;
-    }
-    trapezoid->mFrames = nsnull;
-
-    // Assign the trapezoid a rectangular shape. The trapezoid must be in the
-    // local coordinate space, so convert the current left coordinate
-    *trapezoid = nsRect(left - mX, localY, rightEdge - left, height);
-    aBandData.mCount++;
-  }
+  PR_APPEND_LINK(info, &mFloats);
 
   return NS_OK;
 }
 
 nsresult
-nsSpaceManager::GetBandData(nscoord       aYOffset,
-                            const nsSize& aMaxSize,
-                            nsBandData&   aBandData) const
+nsFloatManager::RemoveTrailingRegions(nsIFrame* aFrameList)
 {
-  NS_PRECONDITION(aBandData.mSize >= 1, "bad band data");
-  nsresult  result = NS_OK;
-
-  // Convert the y-offset to world coordinates
-  nscoord   y = mY + aYOffset;
-
-  // If there are no unavailable rects or the offset is below the bottommost
-  // band, then all the space is available
-  nscoord yMost;
-  nscoord maxHeight = aMaxSize.height == NS_UNCONSTRAINEDSIZE ? NS_UNCONSTRAINEDSIZE 
-    : PR_MAX(0, aMaxSize.height - aYOffset);
-
-  if (!YMost(yMost) || (y >= yMost)) {
-    // All the requested space is available
-    aBandData.mCount = 1;
-    aBandData.mTrapezoids[0] = nsRect(0, aYOffset, aMaxSize.width, maxHeight);
-    aBandData.mTrapezoids[0].mFrames = nsnull;
-  } else {
-    // Find the first band that contains the y-offset or is below the y-offset
-    BandRect* band = GuessBandWithTopAbove(y);
-
-    aBandData.mCount = 0;
-    while (nsnull != band) {
-      if (band->mTop > y) {
-        // The band is below the y-offset. The area between the y-offset and
-        // the top of the band is available
-        aBandData.mCount = 1;
-        aBandData.mTrapezoids[0] =
-          nsRect(0, aYOffset, aMaxSize.width, PR_MIN(band->mTop - y, maxHeight));
-        aBandData.mTrapezoids[0].mFrames = nsnull;
-        break;
-      } else if (y < band->mBottom) {
-        // The band contains the y-offset. Return a list of available and
-        // unavailable rects within the band
-        return GetBandAvailableSpace(band, y, nsSize(aMaxSize.width, maxHeight), aBandData);
-      } else {
-        // Skip to the next band
-        band = GetNextBand(band);
-      }
-    }
-  }
-
-  NS_POSTCONDITION(aBandData.mCount > 0, "unexpected band data count");
-  return result;
-}
-
-/**
- * Skips to the start of the next band.
- *
- * @param aBandRect A rect within the band
- * @returns The start of the next band, or nsnull of this is the last band.
- */
-nsSpaceManager::BandRect*
-nsSpaceManager::GetNextBand(const BandRect* aBandRect) const
-{
-  nscoord topOfBand = aBandRect->mTop;
-
-  aBandRect = aBandRect->Next();
-  while (aBandRect != &mBandList) {
-    // Check whether this rect is part of the same band
-    if (aBandRect->mTop != topOfBand) {
-      // We found the start of the next band
-      return (BandRect*)aBandRect;
-    }
-
-    aBandRect = aBandRect->Next();
-  }
-
-  // No bands left
-  return nsnull;
-}
-
-/**
- * Skips to the start of the previous band.
- *
- * @param aBandRect The first rect within a band
- * @returns The start of the previous band, or nsnull of this is the first band.
- */
-nsSpaceManager::BandRect*
-nsSpaceManager::GetPrevBand(const BandRect* aBandRect) const
-{
-  NS_ASSERTION(aBandRect->Prev() == &mBandList ||
-               aBandRect->Prev()->mBottom <= aBandRect->mTop,
-               "aBandRect should be first rect within its band");
-
-  BandRect* prev = aBandRect->Prev();
-  nscoord topOfBand = prev->mTop;
-
-  while (prev != &mBandList) {
-    // Check whether the prev rect is part of the same band
-    if (prev->mTop != topOfBand) {
-      // We found the beginning of this band
-      return (BandRect*)aBandRect;
-    }
-
-    aBandRect = prev;
-    prev = aBandRect->Prev();
-  }
-
-  // No bands left
-  return nsnull;
-}
-
-/**
- * Divides the current band into two vertically
- *
- * @param aBandRect the first rect in the band
- * @param aBottom where to split the band. This becomes the bottom of the top
- *          part
- */
-void
-nsSpaceManager::DivideBand(BandRect* aBandRect, nscoord aBottom)
-{
-  NS_PRECONDITION(aBottom < aBandRect->mBottom, "bad height");
-  nscoord   topOfBand = aBandRect->mTop;
-  BandRect* nextBand = GetNextBand(aBandRect);
-
-  if (nsnull == nextBand) {
-    nextBand = (BandRect*)&mBandList;
-  }
-
-  while (topOfBand == aBandRect->mTop) {
-    // Split the band rect into two vertically
-    BandRect* bottomBandRect = aBandRect->SplitVertically(aBottom);
-
-    // Insert the new bottom part
-    nextBand->InsertBefore(bottomBandRect);
-
-    // Move to the next rect in the band
-    aBandRect = aBandRect->Next();
-  }
-}
-
-PRBool
-nsSpaceManager::CanJoinBands(BandRect* aBand, BandRect* aPrevBand)
-{
-  PRBool  result;
-  nscoord topOfBand = aBand->mTop;
-  nscoord topOfPrevBand = aPrevBand->mTop;
-
-  // The bands can be joined if:
-  // - they're adjacent
-  // - they have the same number of rects
-  // - each rect has the same left and right edge as its corresponding rect, and
-  //   the rects are occupied by the same frames
-  if (aPrevBand->mBottom == aBand->mTop) {
-    // Compare each of the rects in the two bands
-    while (PR_TRUE) {
-      if ((aBand->mLeft != aPrevBand->mLeft) || (aBand->mRight != aPrevBand->mRight)) {
-        // The rects have different edges
-        result = PR_FALSE;
-        break;
-      }
-
-      if (!aBand->HasSameFrameList(aPrevBand)) {
-        // The rects are occupied by different frames
-        result = PR_FALSE;
-        break;
-      }
-
-      // Move to the next rects within the bands
-      aBand = aBand->Next();
-      aPrevBand = aPrevBand->Next();
-
-      // Have we reached the end of either band?
-      PRBool  endOfBand = aBand->mTop != topOfBand;
-      PRBool  endOfPrevBand = aPrevBand->mTop != topOfPrevBand;
-
-      if (endOfBand || endOfPrevBand) {
-        result = endOfBand & endOfPrevBand;
-        break;  // all done
-      }
-    }
-
-  } else {
-    // The bands aren't adjacent
-    result = PR_FALSE;
-  }
-
-  return result;
-}
-
-/**
- * Tries to join the two adjacent bands. Returns PR_TRUE if successful and
- * PR_FALSE otherwise
- *
- * If the two bands are joined, the previous band is the band that's deleted
- */
-PRBool
-nsSpaceManager::JoinBands(BandRect* aBand, BandRect* aPrevBand)
-{
-  if (CanJoinBands(aBand, aPrevBand)) {
-    BandRect* startOfNextBand = aBand;
-    // We're going to be removing aPrevBand, so if mCachedBandPosition points
-    // to it just advance it to startOfNextBand.
-    if (mCachedBandPosition == aPrevBand) {
-      SetCachedBandPosition(startOfNextBand);
-    }
-
-    while (aPrevBand != startOfNextBand) {
-      // Adjust the top of the band we're keeping, and then move to the next
-      // rect within the band
-      aBand->mTop = aPrevBand->mTop;
-      aBand = aBand->Next();
-
-      // Delete the rect from the previous band
-      BandRect* next = aPrevBand->Next();
-
-      NS_ASSERTION(mCachedBandPosition != aPrevBand,
-                   "Removing mCachedBandPosition BandRect?");
-      aPrevBand->Remove();
-      delete aPrevBand;
-      aPrevBand = next;
-    }
-
-    return PR_TRUE;
-  }
-
-  return PR_FALSE;
-}
-
-/**
- * Adds a new rect to a band.
- *
- * @param aBand the first rect in the band
- * @param aBandRect the band rect to add to the band
- */
-void
-nsSpaceManager::AddRectToBand(BandRect* aBand, BandRect* aBandRect)
-{
-  NS_PRECONDITION((aBand->mTop == aBandRect->mTop) &&
-                  (aBand->mBottom == aBandRect->mBottom), "bad band");
-  NS_PRECONDITION(1 == aBandRect->mFrames.Count(), "shared band rect");
-  nscoord topOfBand = aBand->mTop;
-
-  // Figure out where in the band horizontally to insert the rect
-  do {
-    // Compare the left edge of the new rect with the left edge of the existing
-    // rect
-    if (aBandRect->mLeft < aBand->mLeft) {
-      // The new rect's left edge is to the left of the existing rect's left edge.
-      // Could be any of these cases (N is new rect, E is existing rect):
-      //
-      //   Case 1: left-of      Case 2: overlaps     Case 3: N.contains(E)
-      //   ---------------      ----------------     ---------------------
-      //   +-----+ +-----+      +-----+              +---------+
-      //   |  N  | |  E  |      |  N  |              |    N    |
-      //   +-----+ +-----+      +-----+              +---------+
-      //                           +-----+              +---+
-      //                           |  E  |              | E |
-      //                           +-----+              +---+
-      //
-      // Do the two rectangles overlap?
-      if (aBandRect->mRight <= aBand->mLeft) {
-        // No, the new rect is completely to the left of the existing rect
-        // (case #1). Insert a new rect
-        aBand->InsertBefore(aBandRect);
-        if (mCachedBandPosition == aBand) {
-          SetCachedBandPosition(aBandRect);
-        }
-        return;
-      }
-
-      // Yes, they overlap. Compare the right edges.
-      if (aBandRect->mRight > aBand->mRight) {
-        // The new rect's right edge is to the right of the existing rect's
-        // right edge (case #3). Split the new rect
-        BandRect* r1 = aBandRect->SplitHorizontally(aBand->mLeft);
-
-        // Insert the part of the new rect that's to the left of the existing
-        // rect as a new band rect
-        aBand->InsertBefore(aBandRect);
-        if (mCachedBandPosition == aBand) {
-          SetCachedBandPosition(aBandRect);
-        }
-
-        // Continue below with the part that overlaps the existing rect
-        aBandRect = r1;
-
-      } else {
-        if (aBand->mRight > aBandRect->mRight) {
-          // The existing rect extends past the new rect (case #2). Split the
-          // existing rect
-          BandRect* r1 = aBand->SplitHorizontally(aBandRect->mRight);
-
-          // Insert the new right half of the existing rect
-          aBand->InsertAfter(r1);
-        }
-
-        // Insert the part of the new rect that's to the left of the existing
-        // rect
-        aBandRect->mRight = aBand->mLeft;
-        aBand->InsertBefore(aBandRect);
-
-        if (mCachedBandPosition == aBand) {
-          SetCachedBandPosition(aBandRect);
-        }
-
-        // Mark the existing rect as shared
-        aBand->AddFrame(aBandRect->FrameAt(0));
-        return;
-      }
-    }
-      
-    if (aBandRect->mLeft > aBand->mLeft) {
-      // The new rect's left edge is to the right of the existing rect's left
-      // edge. Could be any one of these cases:
-      //
-      //   Case 4: right-of    Case 5: overlaps     Case 6: E.Contains(N)
-      //   ---------------    ----------------     ---------------------
-      //   +-----+ +-----+    +-----+              +------------+
-      //   |  E  | |  N  |    |  E  |              |      E     |
-      //   +-----+ +-----+    +-----+              +------------+
-      //                         +-----+              +-----+
-      //                         |  N  |              |  N  |
-      //                         +-----+              +-----+
-      //
-      if (aBandRect->mLeft >= aBand->mRight) {
-        // The new rect is to the right of the existing rect (case #4), so move
-        // to the next rect in the band
-        aBand = aBand->Next();
-        continue;
-      }
-
-      // The rects overlap, so divide the existing rect into two rects: the
-      // part to the left of the new rect, and the part that overlaps
-      BandRect* r1 = aBand->SplitHorizontally(aBandRect->mLeft);
-
-      // Insert the new right half of the existing rect, and make it the current
-      // rect
-      aBand->InsertAfter(r1);
-      aBand = r1;
-    }
-
-    // At this point the left edge of the new rect is the same as the left edge
-    // of the existing rect
-    NS_ASSERTION(aBandRect->mLeft == aBand->mLeft, "unexpected rect");
-
-    // Compare which rect is wider, the new rect or the existing rect
-    if (aBand->mRight > aBandRect->mRight) {
-      // The existing rect is wider (case #6). Divide the existing rect into
-      // two rects: the part that overlaps, and the part to the right of the
-      // new rect
-      BandRect* r1 = aBand->SplitHorizontally(aBandRect->mRight);
-
-      // Insert the new right half of the existing rect
-      aBand->InsertAfter(r1);
-
-      // Mark the overlap as being shared
-      aBand->AddFrame(aBandRect->FrameAt(0));
-
-      // We no longer need aBandRect, since the area it covers is covered by
-      // the part of aBand that SplitHorizontally left in place.  Just delete
-      // it.
-      delete aBandRect;
-      return;
-
-    } else {
-      // Indicate the frames share the existing rect
-      aBand->AddFrame(aBandRect->FrameAt(0));
-
-      if (aBand->mRight == aBandRect->mRight) {
-        // The new and existing rect have the same right edge. We're all done,
-        // and the new band rect is no longer needed
-        delete aBandRect;
-        return;
-      } else {
-        // The new rect is wider than the existing rect (cases #5). Set the
-        // new rect to be the overhang, and move to the next rect within the band
-        aBandRect->mLeft = aBand->mRight;
-        aBand = aBand->Next();
-        continue;
-      }
-    }
-  } while (aBand->mTop == topOfBand);
-
-  // Insert a new rect.  This is an insertion at the _end_ of the band, so we
-  // absolutely do not want to set mCachedBandPosition to aBandRect here.
-  aBand->InsertBefore(aBandRect);
-}
-
-// When comparing a rect to a band there are seven cases to consider.
-// 'R' is the rect and 'B' is the band.
-//
-//      Case 1              Case 2              Case 3              Case 4
-//      ------              ------              ------              ------
-// +-----+             +-----+                      +-----+             +-----+
-// |  R  |             |  R  |  +-----+    +-----+  |     |             |     |
-// +-----+             +-----+  |     |    |  R  |  |  B  |             |  B  |
-//          +-----+             |  B  |    +-----+  |     |    +-----+  |     |
-//          |     |             |     |             +-----+    |  R  |  +-----+
-//          |  B  |             +-----+                        +-----+
-//          |     |
-//          +-----+
-//
-//
-//
-//      Case 5              Case 6              Case 7
-//      ------              ------              ------
-//          +-----+    +-----+  +-----+    +-----+
-//          |     |    |  R  |  |  B  |    |     |  +-----+
-//          |  B  |    +-----+  +-----+    |  R  |  |  B  |
-//          |     |                        |     |  +-----+
-//          +-----+                        +-----+
-// +-----+
-// |  R  |
-// +-----+
-//
-void
-nsSpaceManager::InsertBandRect(BandRect* aBandRect)
-{
-  // If there are no existing bands or this rect is below the bottommost
-  // band, then add a new band
-  nscoord yMost;
-  if (!YMost(yMost) || (aBandRect->mTop >= yMost)) {
-    mBandList.Append(aBandRect);
-    SetCachedBandPosition(aBandRect);
-    return;
-  }
-
-  // Examine each band looking for a band that intersects this rect
-  // First guess a band whose top is above aBandRect->mTop.  We know
-  // aBandRect won't overlap any bands before that one.
-  BandRect* band = GuessBandWithTopAbove(aBandRect->mTop);
-
-  while (nsnull != band) {
-    // Compare the top edge of this rect with the top edge of the band
-    if (aBandRect->mTop < band->mTop) {
-      // The top edge of the rect is above the top edge of the band.
-      // Is there any overlap?
-      if (aBandRect->mBottom <= band->mTop) {
-        // Case #1. This rect is completely above the band, so insert a
-        // new band before the current band
-        band->InsertBefore(aBandRect);
-        SetCachedBandPosition(aBandRect);
-        break;  // we're all done
-      }
-
-      // Case #2 and case #7. Divide this rect, creating a new rect for
-      // the part that's above the band
-      BandRect* bandRect1 = new BandRect(aBandRect->mLeft, aBandRect->mTop,
-                                         aBandRect->mRight, band->mTop,
-                                         aBandRect->mFrames);
-
-      // Insert bandRect1 as a new band
-      band->InsertBefore(bandRect1);
-
-      // Modify this rect to exclude the part above the band
-      aBandRect->mTop = band->mTop;
-
-    } else if (aBandRect->mTop > band->mTop) {
-      // The top edge of the rect is below the top edge of the band. Is there
-      // any overlap?
-      if (aBandRect->mTop >= band->mBottom) {
-        // Case #5. This rect is below the current band. Skip to the next band
-        band = GetNextBand(band);
-        continue;
-      }
-
-      // Case #3 and case #4. Divide the current band into two bands with the
-      // top band being the part that's above the rect
-      DivideBand(band, aBandRect->mTop);
-
-      // Skip to the bottom band that we just created
-      band = GetNextBand(band);
-    }
-
-    // At this point the rect and the band should have the same y-offset
-    NS_ASSERTION(aBandRect->mTop == band->mTop, "unexpected band");
-
-    // Is the band higher than the rect?
-    if (band->mBottom > aBandRect->mBottom) {
-      // Divide the band into two bands with the top band the same height
-      // as the rect
-      DivideBand(band, aBandRect->mBottom);
-    }
-
-    if (aBandRect->mBottom == band->mBottom) {
-      // Add the rect to the band
-      SetCachedBandPosition(band);  // Do this before AddRectToBand
-      AddRectToBand(band, aBandRect);
-      break;
-
-    } else {
-      // Case #4 and case #7. The rect contains the band vertically. Divide
-      // the rect, creating a new rect for the part that overlaps the band
-      BandRect* bandRect1 = new BandRect(aBandRect->mLeft, aBandRect->mTop,
-                                         aBandRect->mRight, band->mBottom,
-                                         aBandRect->mFrames);
-
-      // Add bandRect1 to the band
-      AddRectToBand(band, bandRect1);
-
-      // Modify aBandRect to be the part below the band
-      aBandRect->mTop = band->mBottom;
-
-      // Continue with the next band
-      band = GetNextBand(band);
-      if (nsnull == band) {
-        // Append a new bottommost band
-        mBandList.Append(aBandRect);
-        SetCachedBandPosition(aBandRect);
-        break;
-      }
-    }
-  }
-}
-
-nsresult
-nsSpaceManager::AddRectRegion(nsIFrame* aFrame, const nsRect& aUnavailableSpace)
-{
-  NS_PRECONDITION(nsnull != aFrame, "null frame");
-
-  // Convert the frame to world coordinates
-  nsRect  rect(aUnavailableSpace.x + mX, aUnavailableSpace.y + mY,
-               aUnavailableSpace.width, aUnavailableSpace.height);
-
-  if (rect.y > mLowestTop)
-    mLowestTop = rect.y;
-
-  // Create a frame info structure
-  FrameInfo* frameInfo = CreateFrameInfo(aFrame, rect);
-  if (nsnull == frameInfo) {
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-
-  if (aUnavailableSpace.IsEmpty())
-    return NS_OK;
-
-  // Allocate a band rect
-  BandRect* bandRect = new BandRect(rect.x, rect.y, 
-                                    PR_MIN(rect.XMost(), nscoord_MAX),
-                                    PR_MIN(rect.YMost(), nscoord_MAX),
-                                    aFrame);
-  if (nsnull == bandRect) {
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-
-  // Insert the band rect
-  InsertBandRect(bandRect);
-  return NS_OK;
-}
-
-nsresult
-nsSpaceManager::RemoveTrailingRegions(nsIFrame* aFrameList) {
-  nsVoidHashSet frameSet;
-
-  frameSet.Init(1);
-  for (nsIFrame* f = aFrameList; f; f = f->GetNextSibling()) {
-    frameSet.Put(f);
-  }
-
-  // Pop frame regions off as long as they're in the set of frames to
-  // remove
-  while (mFrameInfoMap && frameSet.Contains(mFrameInfoMap->mFrame)) {
-    RemoveRegion(mFrameInfoMap->mFrame);
-  }
-
-#ifdef DEBUG
-  for (FrameInfo* frameInfo = mFrameInfoMap; frameInfo;
-       frameInfo = frameInfo->mNext) {
-    NS_ASSERTION(!frameSet.Contains(frameInfo->mFrame),
-                 "Frame region deletion was requested but we couldn't delete it");
-  }
-#endif
-
-  return NS_OK;
-}
-
-nsresult
-nsSpaceManager::RemoveRegion(nsIFrame* aFrame)
-{
-  // Get the frame info associated with aFrame
-  FrameInfo*  frameInfo = GetFrameInfoFor(aFrame);
-
-  if (nsnull == frameInfo) {
-    NS_WARNING("no region associated with aFrame");
-    return NS_ERROR_INVALID_ARG;
-  }
-
-  if (!frameInfo->mRect.IsEmpty()) {
-    NS_ASSERTION(!mBandList.IsEmpty(), "no bands");
-    BandRect* band = mBandList.Head();
-    BandRect* prevBand = nsnull;
-    PRBool    prevFoundMatchingRect = PR_FALSE;
-
-    // Iterate each band looking for rects tagged with aFrame
-    while (nsnull != band) {
-      BandRect* rect = band;
-      BandRect* prevRect = nsnull;
-      nscoord   topOfBand = band->mTop;
-      PRBool    foundMatchingRect = PR_FALSE;
-      PRBool    prevIsSharedRect = PR_FALSE;
-
-      // Iterate each rect in the band
-      do {
-        PRBool  isSharedRect = PR_FALSE;
-
-        if (rect->IsOccupiedBy(aFrame)) {
-          // Remember that we found a matching rect in this band
-          foundMatchingRect = PR_TRUE;
-
-          if (rect->mFrames.Count() > 1) {
-            // The band rect is occupied by more than one frame
-            rect->mFrames.RemoveElement(aFrame);
-
-            // Remember that this rect was being shared by more than one frame
-            // including aFrame
-            isSharedRect = PR_TRUE;
-          } else {
-            // The rect isn't shared so just delete it
-            BandRect* next = rect->Next();
-            rect->Remove();
-            if (rect == band) {
-              // The rect we're deleting is the start of the band
-              if (topOfBand == next->mTop) {
-                band = next;
-              } else {
-                band = nsnull;
-              }
-              if (mCachedBandPosition == rect) {
-                SetCachedBandPosition(band);
-              }                
-            }
-            delete rect;
-            rect = next;
-
-            // We don't need to try and coalesce adjacent rects in this case
-            prevRect = nsnull;
-            prevIsSharedRect = PR_FALSE;
-            continue;
-          }
-        }
-           
-        // If we found a shared rect occupied by aFrame, then we need to try
-        // and coalesce adjacent rects
-        if (prevIsSharedRect || (isSharedRect && (nsnull != prevRect))) {
-          NS_ASSERTION(nsnull != prevRect, "no previous rect");
-          if ((prevRect->mRight == rect->mLeft) && (prevRect->HasSameFrameList(rect))) {
-            // Modify the current rect's left edge, and delete the previous rect
-            rect->mLeft = prevRect->mLeft;
-            prevRect->Remove();
-            if (prevRect == band) {
-              // the rect we're deleting is the start of the band
-              band = rect;
-              if (mCachedBandPosition == prevRect) {
-                SetCachedBandPosition(band);
-              }
-            }
-            delete prevRect;
-          }
-        }
-
-        // Get the next rect in the band
-        prevRect = rect;
-        prevIsSharedRect = isSharedRect;
-        rect = rect->Next();
-      } while (rect->mTop == topOfBand);
-
-      if (nsnull != band) {
-        // If we found a rect occupied by aFrame in this band or the previous band
-        // then try to join the two bands
-        if ((nsnull != prevBand) && (foundMatchingRect || prevFoundMatchingRect)) {
-          // Try and join this band with the previous band
-          JoinBands(band, prevBand);
-        }
-      }
-
-      // Move to the next band
-      prevFoundMatchingRect = foundMatchingRect;
-      prevBand = band;
-      band = (rect == &mBandList) ? nsnull : rect;
-      if (!mCachedBandPosition) {
-        SetCachedBandPosition(band);
-      }
-    }
-  }
-
-  DestroyFrameInfo(frameInfo);
+  NS_NOTYETIMPLEMENTED("write me");
   return NS_OK;
 }
 
 void
-nsSpaceManager::PushState(SavedState* aState)
+nsFloatManager::PushState(SavedState* aState)
 {
   NS_PRECONDITION(aState, "Need a place to save state");
 
-  // This is a cheap push implementation, which
-  // only saves the (x,y) and last frame in the mFrameInfoMap
-  // which is enough info to get us back to where we should be
-  // when pop is called.
-  //
-  // This push/pop mechanism is used to undo any
-  // floats that were added during the unconstrained reflow
-  // in nsBlockReflowContext::DoReflowBlock(). (See bug 96736)
-  //
-  // It should also be noted that the state for mFloatDamage is
-  // intentionally not saved or restored in PushState() and PopState(),
-  // since that could lead to bugs where damage is missed/dropped when
-  // we move from position A to B (during the intermediate incremental
-  // reflow mentioned above) and then from B to C during the subsequent
-  // reflow. In the typical case A and C will be the same, but not always.
-  // Allowing mFloatDamage to accumulate the damage incurred during both
-  // reflows ensures that nothing gets missed.
-  aState->mX = mX;
-  aState->mY = mY;
-  aState->mLowestTop = mLowestTop;
-  aState->mHaveCachedLeftYMost = mHaveCachedLeftYMost;
-  aState->mHaveCachedRightYMost = mHaveCachedRightYMost;
-  aState->mMaximalLeftYMost = mMaximalLeftYMost;
-  aState->mMaximalRightYMost = mMaximalRightYMost;
-
-  if (mFrameInfoMap) {
-    aState->mLastFrame = mFrameInfoMap->mFrame;
-  } else {
-    aState->mLastFrame = nsnull;
-  }
+  NS_NOTYETIMPLEMENTED("write me");
 }
 
 void
-nsSpaceManager::PopState(SavedState* aState)
+nsFloatManager::PopState(SavedState* aState)
 {
   NS_PRECONDITION(aState, "No state to restore?");
 
-  // This is a quick and dirty pop implementation, to
-  // match the current implementation of PushState(). The
-  // idea here is to remove any frames that have been added
-  // to the mFrameInfoMap since the last call to PushState().
-
-  // Say we don't have cached left- and right-YMost, so that we don't
-  // try to check for it in RemoveRegion.  We'll restore these from
-  // the state anyway.
-  mHaveCachedLeftYMost = mHaveCachedRightYMost = PR_FALSE;
-
-  // mFrameInfoMap is LIFO so keep removing what it points
-  // to until we hit mLastFrame.
-  while (mFrameInfoMap && mFrameInfoMap->mFrame != aState->mLastFrame) {
-    RemoveRegion(mFrameInfoMap->mFrame);
-  }
-
-  // If we trip this assertion it means that someone added
-  // PushState()/PopState() calls around code that actually
-  // removed mLastFrame from mFrameInfoMap, which means our
-  // state is now out of sync with what we thought it should be.
-
-  NS_ASSERTION(((aState->mLastFrame && mFrameInfoMap) ||
-               (!aState->mLastFrame && !mFrameInfoMap)),
-               "Unexpected outcome!");
-
-  mX = aState->mX;
-  mY = aState->mY;
-  mLowestTop = aState->mLowestTop;
-  mHaveCachedLeftYMost = aState->mHaveCachedLeftYMost;
-  mHaveCachedRightYMost = aState->mHaveCachedRightYMost;
-  mMaximalLeftYMost = aState->mMaximalLeftYMost;
-  mMaximalRightYMost = aState->mMaximalRightYMost;
+  NS_NOTYETIMPLEMENTED("write me");
 }
 
 nscoord
-nsSpaceManager::GetLowestRegionTop()
+nsFloatManager::GetLowestFloatTop() const
 {
-  if (mLowestTop == NSCOORD_MIN)
-    return mLowestTop;
-  return mLowestTop - mY;
+  NS_NOTYETIMPLEMENTED("write me");
+  return 0;
 }
 
 #ifdef DEBUG
 void
-DebugListSpaceManager(nsSpaceManager *aSpaceManager)
+DebugListFloatManager(const nsFloatManager *aFloatManager)
 {
-  aSpaceManager->List(stdout);
+  aFloatManager->List(stdout);
 }
 
 nsresult
-nsSpaceManager::List(FILE* out)
+nsFloatManager::List(FILE* out) const
 {
-  nsAutoString tmp;
-
-  fprintf(out, "SpaceManager@%p", this);
-  fprintf(out, " xy=%d,%d <\n", mX, mY);
-  if (mBandList.IsEmpty()) {
-    fprintf(out, "  no bands\n");
-  }
-  else {
-    BandRect* band = mBandList.Head();
-    do {
-      PRInt32 const n = band->mFrames.Count();
-      fprintf(out, "  left=%d top=%d right=%d bottom=%d count=%d frames=",
-              band->mLeft, band->mTop, band->mRight, band->mBottom, n);
-
-      for (PRInt32 i = 0; i < n; i++) {
-        nsIFrame* frame = (nsIFrame*)band->mFrames.FastElementAt(i);
-        if (frame) {
-          nsIFrameDebug*  frameDebug;
-
-		  if (NS_SUCCEEDED(frame->QueryInterface(NS_GET_IID(nsIFrameDebug), (void**)&frameDebug))) {
-            frameDebug->GetFrameName(tmp);
-            fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);
-            fprintf(out, "@%p ", frame);
-          }
-        }
-      }
-      fprintf(out, "\n");
-      band = band->Next();
-    } while (band != mBandList.Head());
-  }
-  fprintf(out, ">\n");
+  NS_NOTYETIMPLEMENTED("write me");
   return NS_OK;
 }
 #endif
 
-nsSpaceManager::FrameInfo*
-nsSpaceManager::GetFrameInfoFor(nsIFrame* aFrame)
+nscoord
+nsFloatManager::ClearFloats(nscoord aY, PRUint8 aBreakType) const
 {
-  FrameInfo*  result = nsnull;
-
-  for (result = mFrameInfoMap; result; result = result->mNext) {
-    if (result->mFrame == aFrame) {
-      break;
-    }
-  }
-
-  return result;
-}
-
-nsSpaceManager::FrameInfo*
-nsSpaceManager::CreateFrameInfo(nsIFrame* aFrame, const nsRect& aRect)
-{
-  FrameInfo*  frameInfo = new FrameInfo(aFrame, aRect);
-
-  if (frameInfo) {
-    // Link it into the list
-    frameInfo->mNext = mFrameInfoMap;
-    mFrameInfoMap = frameInfo;
-
-    // Optimize for the common case case when the frame being added is
-    // likely to be near the bottom.
-    nscoord ymost = aRect.YMost();
-    PRUint8 floatType = aFrame->GetStyleDisplay()->mFloats;
-    if (mHaveCachedLeftYMost && ymost > mMaximalLeftYMost &&
-        floatType == NS_STYLE_FLOAT_LEFT) {
-      mMaximalLeftYMost = ymost;
-    }
-    else if (mHaveCachedRightYMost && ymost > mMaximalRightYMost &&
-             floatType == NS_STYLE_FLOAT_RIGHT) {
-      mMaximalRightYMost = ymost;
-    }
-  }
-  return frameInfo;
-}
-
-void
-nsSpaceManager::DestroyFrameInfo(FrameInfo* aFrameInfo)
-{
-  // See if it's at the head of the list
-  if (mFrameInfoMap == aFrameInfo) {
-    mFrameInfoMap = aFrameInfo->mNext;
-
-  } else {
-    FrameInfo*  prev;
-    
-    // Find the previous node in the list
-    for (prev = mFrameInfoMap; prev && (prev->mNext != aFrameInfo); prev = prev->mNext) {
-      ;
-    }
-
-    // Disconnect it from the list
-    NS_ASSERTION(prev, "element not in list");
-    if (prev) {
-      prev->mNext = aFrameInfo->mNext;
-    }
-  }
-
-  // Optimize for the case when the frame being removed is likely to be near
-  // the bottom, but do nothing if we have neither cached value -- that case is
-  // likely to be hit from PopState().
-  if (mHaveCachedLeftYMost || mHaveCachedRightYMost) {
-    PRUint8 floatType = aFrameInfo->mFrame->GetStyleDisplay()->mFloats;
-    if (floatType == NS_STYLE_FLOAT_LEFT) {
-      mHaveCachedLeftYMost = PR_FALSE;
-    }
-    else {
-      NS_ASSERTION(floatType == NS_STYLE_FLOAT_RIGHT, "Unexpected float type");
-      mHaveCachedRightYMost = PR_FALSE;
-    }
-  }
-
-  delete aFrameInfo;
-}
-
-nscoord
-nsSpaceManager::ClearFloats(nscoord aY, PRUint8 aBreakType)
-{
-  nscoord bottom = aY + mY;
-
-  if ((!mHaveCachedLeftYMost && aBreakType != NS_STYLE_CLEAR_RIGHT) ||
-      (!mHaveCachedRightYMost && aBreakType != NS_STYLE_CLEAR_LEFT)) {
-    // Recover our maximal YMost values.  Might need both if this is a
-    // NS_STYLE_CLEAR_LEFT_AND_RIGHT
-    nscoord maximalLeftYMost = mHaveCachedLeftYMost ? mMaximalLeftYMost : nscoord_MIN;
-    nscoord maximalRightYMost = mHaveCachedRightYMost ? mMaximalRightYMost : nscoord_MIN;
-
-    // Optimize for most floats not being near the bottom
-    for (FrameInfo *frame = mFrameInfoMap; frame; frame = frame->mNext) {
-      nscoord ymost = frame->mRect.YMost();
-      if (ymost > maximalLeftYMost) {
-        if (frame->mFrame->GetStyleDisplay()->mFloats == NS_STYLE_FLOAT_LEFT) {
-          NS_ASSERTION(!mHaveCachedLeftYMost, "Shouldn't happen");
-          maximalLeftYMost = ymost;
-          // No need to compare to the right ymost
-          continue;
-        }
-      }
-
-      if (ymost > maximalRightYMost) {
-        if (frame->mFrame->GetStyleDisplay()->mFloats == NS_STYLE_FLOAT_RIGHT) {
-          NS_ASSERTION(!mHaveCachedRightYMost, "Shouldn't happen");
-          maximalRightYMost = ymost;
-        }
-      }
-    }
-
-    mMaximalLeftYMost = maximalLeftYMost;
-    mMaximalRightYMost = maximalRightYMost;
-    mHaveCachedRightYMost = mHaveCachedLeftYMost = PR_TRUE;
-  }
-  
-  switch (aBreakType) {
-    case NS_STYLE_CLEAR_LEFT_AND_RIGHT:
-      NS_ASSERTION(mHaveCachedLeftYMost && mHaveCachedRightYMost,
-                   "Need cached values!");
-      bottom = PR_MAX(bottom, mMaximalLeftYMost);
-      bottom = PR_MAX(bottom, mMaximalRightYMost);
-      break;
-    case NS_STYLE_CLEAR_LEFT:
-      NS_ASSERTION(mHaveCachedLeftYMost, "Need cached value!");
-      bottom = PR_MAX(bottom, mMaximalLeftYMost);
-      break;
-    case NS_STYLE_CLEAR_RIGHT:
-      NS_ASSERTION(mHaveCachedRightYMost, "Need cached value!");
-      bottom = PR_MAX(bottom, mMaximalRightYMost);
-      break;
-    default:
-      // Do nothing
-      break;
-  }
-
-  bottom -= mY;
-
-  return bottom;
-}
-
-nsSpaceManager::BandRect*
-nsSpaceManager::GuessBandWithTopAbove(nscoord aYOffset) const
-{
-  NS_ASSERTION(!mBandList.IsEmpty(), "no bands");
-  BandRect* band = nsnull;
-  if (mCachedBandPosition) {
-    band = mCachedBandPosition;
-    // Now seek backward so that we're guaranteed to be the topmost
-    // band which might contain the y-offset or be below it.
-    while (band && band->mTop > aYOffset) {
-      band = GetPrevBand(band);
-    }
-  }
-
-  if (band) {
-    return band;
-  }
-  
-  return mBandList.Head();
+  NS_NOTYETIMPLEMENTED("write me");
+  return 0;
 }
 
 /////////////////////////////////////////////////////////////////////////////
-// FrameInfo
+// FloatInfo
 
-nsSpaceManager::FrameInfo::FrameInfo(nsIFrame* aFrame, const nsRect& aRect)
-  : mFrame(aFrame), mRect(aRect), mNext(0)
+nsSpaceManager::FloatInfo::FloatInfo(nsIFrame* aFrame, const nsRect& aRect)
+  : mFrame(aFrame), mRect(aRect)
 {
-  MOZ_COUNT_CTOR(nsSpaceManager::FrameInfo);
+  MOZ_COUNT_CTOR(nsSpaceManager::FloatInfo);
+  PR_INIT_CLIST(this);
 }
 
 #ifdef NS_BUILD_REFCNT_LOGGING
-nsSpaceManager::FrameInfo::~FrameInfo()
+nsSpaceManager::FloatInfo::~FloatInfo()
 {
-  MOZ_COUNT_DTOR(nsSpaceManager::FrameInfo);
+  MOZ_COUNT_DTOR(nsSpaceManager::FloatInfo);
 }
 #endif
 
-/////////////////////////////////////////////////////////////////////////////
-// BandRect
-
-nsSpaceManager::BandRect::BandRect(nscoord    aLeft,
-                                   nscoord    aTop,
-                                   nscoord    aRight,
-                                   nscoord    aBottom,
-                                   nsIFrame*  aFrame)
-{
-  MOZ_COUNT_CTOR(BandRect);
-  mLeft = aLeft;
-  mTop = aTop;
-  mRight = aRight;
-  mBottom = aBottom;
-  AddFrame(aFrame);
-}
-
-nsSpaceManager::BandRect::BandRect(nscoord      aLeft,
-                                   nscoord      aTop,
-                                   nscoord      aRight,
-                                   nscoord      aBottom,
-                                   nsSmallVoidArray& aFrames)
-{
-  MOZ_COUNT_CTOR(BandRect);
-  mLeft = aLeft;
-  mTop = aTop;
-  mRight = aRight;
-  mBottom = aBottom;
-  mFrames = aFrames;
-}
-
-nsSpaceManager::BandRect::~BandRect()
-{
-  MOZ_COUNT_DTOR(BandRect);
-}
-
-nsSpaceManager::BandRect*
-nsSpaceManager::BandRect::SplitVertically(nscoord aBottom)
-{
-  NS_PRECONDITION((aBottom > mTop) && (aBottom < mBottom), "bad argument");
-
-  // Create a new band rect for the bottom part
-  BandRect* bottomBandRect = new BandRect(mLeft, aBottom, mRight, mBottom, mFrames);
-                                           
-  // This band rect becomes the top part, so adjust the bottom edge
-  mBottom = aBottom;
-  return bottomBandRect;
-}
-
-nsSpaceManager::BandRect*
-nsSpaceManager::BandRect::SplitHorizontally(nscoord aRight)
-{
-  NS_PRECONDITION((aRight > mLeft) && (aRight < mRight), "bad argument");
-  
-  // Create a new band rect for the right part
-  BandRect* rightBandRect = new BandRect(aRight, mTop, mRight, mBottom, mFrames);
-                                           
-  // This band rect becomes the left part, so adjust the right edge
-  mRight = aRight;
-  return rightBandRect;
-}
-
-PRBool
-nsSpaceManager::BandRect::HasSameFrameList(const BandRect* aBandRect) const
-{
-  const PRInt32 count = mFrames.Count();
-
-  // Check whether they're occupied by the same number of frames
-  if (count != aBandRect->mFrames.Count()) {
-    return PR_FALSE;
-  }
-  // For each frame occupying this band rect check whether it also occupies
-  // aBandRect
-  for (PRInt32 i = 0; i < count; i++) {
-    if (-1 == aBandRect->mFrames.IndexOf(mFrames.FastElementAt(i))) {
-      return PR_FALSE;
-    }
-  }
-
-  return PR_TRUE;
-}
-
-/**
- * Internal helper function that counts the number of rects in this band
- * including the current band rect
- */
-PRInt32
-nsSpaceManager::BandRect::Length() const
-{
-  PRInt32   len = 1;
-  BandRect* bandRect = Next();
-
-  // Because there's a header cell we know we'll either find the next band
-  // (which has a different y-offset) or the header cell which has an invalid
-  // y-offset
-  while (bandRect->mTop == mTop) {
-    len++;
-    bandRect = bandRect->Next();
-  }
-
-  return len;
-}
-
-
 //----------------------------------------------------------------------
 
-nsAutoSpaceManager::~nsAutoSpaceManager()
+nsAutoFloatManager::~nsAutoFloatManager()
 {
-  // Restore the old space manager in the reflow state if necessary.
+  // Restore the old float manager in the reflow state if necessary.
   if (mNew) {
-#ifdef NOISY_SPACEMANAGER
-    printf("restoring old space manager %p\n", mOld);
+#ifdef NOISY_FLOATMANAGER
+    printf("restoring old float manager %p\n", mOld);
 #endif
 
-    mReflowState.mSpaceManager = mOld;
+    mReflowState.mFloatManager = mOld;
 
-#ifdef NOISY_SPACEMANAGER
+#ifdef NOISY_FLOATMANAGER
     if (mOld) {
       static_cast<nsFrame *>(mReflowState.frame)->ListTag(stdout);
       printf(": space-manager %p after reflow\n", mOld);
       mOld->List(stdout);
     }
 #endif
 
     delete mNew;
   }
 }
 
 nsresult
-nsAutoSpaceManager::CreateSpaceManager(nsPresContext *aPresContext)
+nsAutoFloatManager::CreateFloatManager(nsPresContext *aPresContext)
 {
-  // Create a new space manager and install it in the reflow
-  // state. `Remember' the old space manager so we can restore it
+  // Create a new float manager and install it in the reflow
+  // state. `Remember' the old float manager so we can restore it
   // later.
-  mNew = new nsSpaceManager(aPresContext->PresShell());
+  mNew = new nsFloatManager(aPresContext->PresShell());
   if (! mNew)
     return NS_ERROR_OUT_OF_MEMORY;
 
-#ifdef NOISY_SPACEMANAGER
-  printf("constructed new space manager %p (replacing %p)\n",
-         mNew, mReflowState.mSpaceManager);
+#ifdef NOISY_FLOATMANAGER
+  printf("constructed new float manager %p (replacing %p)\n",
+         mNew, mReflowState.mFloatManager);
 #endif
 
-  // Set the space manager in the existing reflow state
-  mOld = mReflowState.mSpaceManager;
-  mReflowState.mSpaceManager = mNew;
+  // Set the float manager in the existing reflow state
+  mOld = mReflowState.mFloatManager;
+  mReflowState.mFloatManager = mNew;
   return NS_OK;
 }
diff --git a/layout/generic/nsSpaceManager.h b/layout/generic/nsFloatManager.h
rename from layout/generic/nsSpaceManager.h
rename to layout/generic/nsFloatManager.h
--- a/layout/generic/nsSpaceManager.h
+++ b/layout/generic/nsFloatManager.h
@@ -16,476 +16,231 @@
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-/*
- * class that manages regions of 2-D space, originally designed
- * generally but actually specific to space occupied by floats
- */
+/* class that manages rules for positioning floats */
 
-#ifndef nsSpaceManager_h___
-#define nsSpaceManager_h___
+#ifndef nsFloatManager_h_
+#define nsFloatManager_h_
 
 #include "prclist.h"
 #include "nsIntervalSet.h"
-#include "nsISupports.h"
 #include "nsCoord.h"
 #include "nsRect.h"
-#include "nsVoidArray.h"
 
 class nsIPresShell;
 class nsIFrame;
-struct nsSize;
 struct nsHTMLReflowState;
 class nsPresContext;
 
-#define NS_SPACE_MANAGER_CACHE_SIZE 4
+#define NS_FLOAT_MANAGER_CACHE_SIZE 4
 
-/**
- * Information about a particular trapezoid within a band. The space described
- * by the trapezoid is in one of three states:
- * <ul>
- * <li>available
- * <li>occupied by one frame
- * <li>occupied by more than one frame
- * </ul>
- */
-struct nsBandTrapezoid {
-  nscoord   mTopY, mBottomY;            // top and bottom y-coordinates
-  nscoord   mTopLeftX, mBottomLeftX;    // left edge x-coordinates
-  nscoord   mTopRightX, mBottomRightX;  // right edge x-coordinates
-  const nsSmallVoidArray* mFrames; // list of frames occupying the space
-
-  // Get the height of the trapezoid
-  nscoord GetHeight() const {return mBottomY - mTopY;}
-
-  // Get the bounding rect of the trapezoid
-  inline void GetRect(nsRect& aRect) const;
-
-  // Set the trapezoid from a rectangle
-  inline void operator=(const nsRect& aRect);
-
-  // Do these trapezoids have the same geometry?
-  inline PRBool EqualGeometry(const nsBandTrapezoid& aTrap) const;
-
-  nsBandTrapezoid()
-    : mTopY(0),
-      mBottomY(0),
-      mTopLeftX(0),
-      mBottomLeftX(0),
-      mTopRightX(0),
-      mBottomRightX(0),
-      mFrames(nsnull)
-  {
-  }
-};
-
-inline void nsBandTrapezoid::GetRect(nsRect& aRect) const
-{
-  aRect.x = PR_MIN(mTopLeftX, mBottomLeftX);
-  aRect.y = mTopY;
-  aRect.width = PR_MAX(mTopRightX, mBottomRightX);
-  if (NS_MAXSIZE != aRect.width) {
-    aRect.width -= aRect.x;
-  }
-  aRect.height = (NS_MAXSIZE == mBottomY) ? NS_MAXSIZE : mBottomY - mTopY;
-}
-
-inline void nsBandTrapezoid::operator=(const nsRect& aRect)
-{
-  mTopLeftX = mBottomLeftX = aRect.x;
-  mTopRightX = mBottomRightX = aRect.XMost();
-  mTopY = aRect.y;
-  mBottomY = aRect.YMost();
-}
-
-inline PRBool nsBandTrapezoid::EqualGeometry(const nsBandTrapezoid& aTrap) const
-{
-  return (
-    mTopLeftX == aTrap.mTopLeftX &&
-    mBottomLeftX == aTrap.mBottomLeftX &&
-    mTopRightX == aTrap.mTopRightX &&
-    mBottomRightX == aTrap.mBottomRightX &&
-    mTopY == aTrap.mTopY &&
-    mBottomY == aTrap.mBottomY
-  );
-}
-
-/**
- * Structure used for describing the space within a band.
- * @see #GetBandData()
- */
-struct nsBandData {
-  PRInt32 mCount; // [out] actual number of trapezoids in the band data
-  PRInt32 mSize; // [in] the size of the array (number of trapezoids)
-  nsBandTrapezoid* mTrapezoids; // [out] array of length 'size'
-};
-
-/**
- * Class for dealing with bands of available space. The space manager
- * defines a coordinate space (relative to the frame that created the
- * space manager) with an origin at (0, 0) that grows down and to the
- * right.
- */
-class nsSpaceManager {
+class nsFloatManager {
 public:
-  nsSpaceManager(nsIPresShell* aPresShell);
-  ~nsSpaceManager();
+  nsFloatManager(nsIPresShell* aPresShell);
+  ~nsFloatManager();
 
   void* operator new(size_t aSize) CPP_THROW_NEW;
   void operator delete(void* aPtr, size_t aSize);
 
   static void Shutdown();
+
   /**
    * Translate the current origin by the specified (dx, dy). This
    * creates a new local coordinate space relative to the current
    * coordinate space.
    */
   void Translate(nscoord aDx, nscoord aDy) { mX += aDx; mY += aDy; }
 
   /**
    * Returns the current translation from local coordinate space to
    * world coordinate space. This represents the accumulated calls to
    * Translate().
    */
   void GetTranslation(nscoord& aX, nscoord& aY) const { aX = mX; aY = mY; }
-  /**
-   * Returns the y-most of the bottommost band or 0 if there are no bands.
-   *
-   * @return  PR_TRUE if there are bands and PR_FALSE if there are no bands
-   */
-  PRBool YMost(nscoord& aYMost) const;
 
   /**
-   * Returns a band starting at the specified y-offset. The band data
-   * indicates which parts of the band are available, and which parts
-   * are unavailable
+   * Get information about the band containing vertical coordinate |aY|,
+   * but up to at most |aMaxHeight| (which may be nscoord_MAX).  This
+   * will return the tallest rectangle whose top is |aY| and in which
+   * there are no changes in what floats are on the sides of that
+   * rectangle, but will limit the height of the rectangle to
+   * |aMaxHeight|.  The left and right edges of the rectangle give the
+   * area available for line boxes in that space.
    *
-   * The band data that is returned is in the coordinate space of the
-   * local coordinate system.
-   *
-   * The local coordinate space origin, the y-offset, and the max size
-   * describe a rectangle that's used to clip the underlying band of
-   * available space, i.e.
-   * {0, aYOffset, aMaxSize.width, aMaxSize.height} in the local
-   * coordinate space
-   *
-   * @param   aYOffset the y-offset of where the band begins. The coordinate is
-   *            relative to the upper-left corner of the local coordinate space
-   * @param   aMaxSize the size to use to constrain the band data
-   * @param   aBandData [in,out] used to return the list of trapezoids that
-   *            describe the available space and the unavailable space
-   * @return  NS_OK if successful and NS_ERROR_FAILURE if the band data is not
-   *            not large enough. The 'count' member of the band data struct
-   *            indicates how large the array of trapezoids needs to be
+   * @param aY [in] vertical coordinate for top of available space
+   *           desired
+   * @param aMaxHeight [in] maximum height of available space desired
+   * @param aAvailSpace [out] the resulting rectangle for line boxes
+   * @param aFloatCount [out] the number of floats on the sides of
+   *                    aAvailSpace, including those that do not reduce
+   *                    the line box width at all (because they are
+   *                    entirely in the margins)
    */
-  nsresult GetBandData(nscoord       aYOffset,
-                       const nsSize& aMaxSize,
-                       nsBandData&   aBandData) const;
+  void GetBandInfo(nscoord aY, nscoord aMaxHeight,
+                   nsRect& aAvailSpace, PRUint32* aFloatCount) const;
 
-  /**
-   * Add a rectangular region of unavailable space. The space is
-   * relative to the local coordinate system.
-   *
-   * The region is tagged with a frame
-   *
-   * @param   aFrame the frame used to identify the region. Must not be NULL
-   * @param   aUnavailableSpace the bounding rect of the unavailable space
-   * @return  NS_OK if successful
-   *          NS_ERROR_FAILURE if there is already a region tagged with aFrame
-   */
-  nsresult AddRectRegion(nsIFrame*     aFrame,
-                         const nsRect& aUnavailableSpace);
+  nsresult AddFloat(nsIFrame* aFloatFrame, const nsRect& aMarginRect);
 
   /**
    * Remove the regions associated with this floating frame and its
    * next-sibling list.  Some of the frames may never have been added;
    * we just skip those. This is not fully general; it only works as
    * long as the N frames to be removed are the last N frames to have
    * been added; if there's a frame in the middle of them that should
    * not be removed, YOU LOSE.
    *
    * This can only be done at the end of the life of this space manager. The only
    * methods it is safe to call after this are XMost() and YMost().
    */
   nsresult RemoveTrailingRegions(nsIFrame* aFrameList);
 
-protected:
-  /**
-   * Remove the region associated with aFrane.
-   *
-   * doesn't work in the general case!
-   *
-   * Returns NS_OK if successful and NS_ERROR_INVALID_ARG if there is no region
-   * tagged with aFrame
-   */
-  nsresult RemoveRegion(nsIFrame* aFrame);
-
-public:
   // Structure that stores the current state of a frame manager for
   // Save/Restore purposes.
+  struct SavedState;
+  friend struct SavedState;
   struct SavedState {
   private:
-    nsIFrame *mLastFrame;
+    FloatInfo *mLastFloatInfo;
     nscoord mX, mY;
-    nscoord mLowestTop;
-    nscoord mMaximalLeftYMost;
-    nscoord mMaximalRightYMost;
-    PRPackedBool mHaveCachedLeftYMost;
-    PRPackedBool mHaveCachedRightYMost;
     
-    friend class nsSpaceManager;
+    friend class nsFloatManager;
   };
 
-  PRBool HasAnyFloats() { return mFrameInfoMap != nsnull; }
+  PRBool HasAnyFloats() const { return !PR_CLIST_IS_EMPTY(&mFloats); }
 
   /**
    * Methods for dealing with the propagation of float damage during
    * reflow.
    */
-  PRBool HasFloatDamage()
+  PRBool HasFloatDamage() const
   {
     return !mFloatDamage.IsEmpty();
   }
 
   void IncludeInDamage(nscoord aIntervalBegin, nscoord aIntervalEnd)
   {
     mFloatDamage.IncludeInterval(aIntervalBegin + mY, aIntervalEnd + mY);
   }
 
-  PRBool IntersectsDamage(nscoord aIntervalBegin, nscoord aIntervalEnd)
+  PRBool IntersectsDamage(nscoord aIntervalBegin, nscoord aIntervalEnd) const
   {
     return mFloatDamage.Intersects(aIntervalBegin + mY, aIntervalEnd + mY);
   }
 
   /**
-   * Saves the current state of the space manager into aState.
+   * Saves the current state of the float manager into aState.
    */
   void PushState(SavedState* aState);
 
   /**
-   * Restores the space manager to the saved state.
+   * Restores the float manager to the saved state.
    * 
    * These states must be managed using stack discipline. PopState can only
    * be used after PushState has been used to save the state, and it can only
    * be used once --- although it can be omitted; saved states can be ignored.
    * States must be popped in the reverse order they were pushed. 
    */
   void PopState(SavedState* aState);
 
   /**
-   * Get the top of the last region placed into the space manager, to
+   * Get the top of the last float placed into the space manager, to
    * enforce the rule that a float can't be above an earlier float.
-   * Returns the minimum nscoord value if there are no regions.
+   * Returns the minimum nscoord value if there are no floats.
    */
-  nscoord GetLowestRegionTop();
+  nscoord GetLowestFloatTop() const;
 
   /**
    * Return the coordinate of the lowest float matching aBreakType in this
    * space manager. Returns aY if there are no matching floats.
    */
-  nscoord ClearFloats(nscoord aY, PRUint8 aBreakType);
+  nscoord ClearFloats(nscoord aY, PRUint8 aBreakType) const;
 
 #ifdef DEBUG
   /**
    * Dump the state of the spacemanager out to a file
    */
-  nsresult List(FILE* out);
+  nsresult List(FILE* out) const;
 #endif
 
-protected:
-  // Structure that maintains information about the region associated
-  // with a particular frame
-  struct FrameInfo {
-    nsIFrame* const mFrame;
-    nsRect          mRect;       // rectangular region
-    FrameInfo*      mNext;
+private:
 
-    FrameInfo(nsIFrame* aFrame, const nsRect& aRect);
+  struct FloatInfo : public PRCList {
+    nsIFrame *const mFrame;
+    nsRect mRect;
+    // The lowest bottoms of left/right floats up to and including this one.
+    nscoord mLeftYMost, mRightYMost;
+
+    FloatInfo* Next() { return static_cast<FloatInfo*>(PR_NEXT_LINK(this)); }
+    FloatInfo* Prev() { return static_cast<FloatInfo*>(PR_PREV_LINK(this)); }
+
+    FloatInfo(nsIFrame* aFrame, const nsRect& aRect);
 #ifdef NS_BUILD_REFCNT_LOGGING
-    ~FrameInfo();
+    ~FloatInfo();
 #endif
   };
 
-public:
-  // Doubly linked list of band rects
-  struct BandRect : PRCListStr {
-    nscoord   mLeft, mTop;
-    nscoord   mRight, mBottom;
-    nsSmallVoidArray mFrames;  // list of frames occupying the space
+  FloatInfo* FloatsHead()
+    { return static_cast<FloatInfo*>(PR_LIST_HEAD(&mFloats)); }
+  FloatInfo* FloatsTail()
+    { return static_cast<FloatInfo*>(PR_LIST_TAIL(&mFloats)); }
 
-    BandRect(nscoord aLeft, nscoord aTop,
-             nscoord aRight, nscoord aBottom,
-             nsIFrame* aFrame);
-    BandRect(nscoord aLeft, nscoord aTop,
-             nscoord aRight, nscoord aBottom,
-             nsSmallVoidArray& frames);
-    ~BandRect();
+  nscoord         mX, mY;     // translation from local to global coordinate space
+  PRCList         mFloats; /* of FloatInfo */
+  nsIntervalSet   mFloatDamage;
 
-    // List operations
-    BandRect* Next() const {return (BandRect*)PR_NEXT_LINK(this);}
-    BandRect* Prev() const {return (BandRect*)PR_PREV_LINK(this);}
-    void      InsertBefore(BandRect* aBandRect) {PR_INSERT_BEFORE(aBandRect, this);}
-    void      InsertAfter(BandRect* aBandRect) {PR_INSERT_AFTER(aBandRect, this);}
-    void      Remove() {PR_REMOVE_LINK(this);}
+  static PRInt32 sCachedFloatManagerCount;
+  static void* sCachedFloatManagers[NS_FLOAT_MANAGER_CACHE_SIZE];
 
-    // Split the band rect into two vertically, with this band rect becoming
-    // the top part, and a new band rect being allocated and returned for the
-    // bottom part
-    //
-    // Does not insert the new band rect into the linked list
-    BandRect* SplitVertically(nscoord aBottom);
-
-    // Split the band rect into two horizontally, with this band rect becoming
-    // the left part, and a new band rect being allocated and returned for the
-    // right part
-    //
-    // Does not insert the new band rect into the linked list
-    BandRect* SplitHorizontally(nscoord aRight);
-
-    // Accessor functions
-    PRBool  IsOccupiedBy(const nsIFrame* aFrame) const {
-      return (mFrames.IndexOf((void*)aFrame) != -1);
-    }
-    void    AddFrame(const nsIFrame* aFrame) {
-      mFrames.AppendElement((void*)aFrame);
-    }
-    void    RemoveFrame(const nsIFrame* aFrame) {
-      mFrames.RemoveElement((void*)aFrame);
-    }
-    nsIFrame * FrameAt(PRInt32 index) {
-      return static_cast<nsIFrame*>(mFrames.FastElementAt(index));
-    }
-    PRBool  HasSameFrameList(const BandRect* aBandRect) const;
-    PRInt32 Length() const;
-  };
-
-  // Circular linked list of band rects
-  struct BandList : BandRect {
-    BandList();
-
-    // Accessors
-    PRBool    IsEmpty() const {return PR_CLIST_IS_EMPTY((PRCListStr*)this);}
-    BandRect* Head() const {return (BandRect*)PR_LIST_HEAD(this);}
-    BandRect* Tail() const {return (BandRect*)PR_LIST_TAIL(this);}
-
-    // Operations
-    void      Append(BandRect* aBandRect) {PR_APPEND_LINK(aBandRect, this);}
-
-    // Remove and delete all the band rects in the list
-    void      Clear();
-  };
-
-protected:
-  nscoord         mX, mY;     // translation from local to global coordinate space
-  BandList        mBandList;  // header/sentinel for circular linked list of band rects
-  nscoord         mLowestTop;  // the lowest *top*
-  FrameInfo*      mFrameInfoMap;
-  nsIntervalSet   mFloatDamage;
-  PRPackedBool    mHaveCachedLeftYMost; // If true, mMaximalLeftYMost is set
-  PRPackedBool    mHaveCachedRightYMost; // If true, mMaximalRightYMost is set
-  nscoord         mMaximalLeftYMost;  // The maximal YMost of our FrameInfo
-                                      // rects for left floats.  Only makes
-                                      // sense when mHaveCachedLeftYMost is
-                                      // true.
-  nscoord         mMaximalRightYMost; // The maximal YMost of our FrameInfo
-                                      // rects for right floats.  Only makes
-                                      // sense when mHaveCachedLeftYMost is
-                                      // true.
-  // We keep track of the last BandRect* we worked with so that we can
-  // make use of locality of reference in situations where people want
-  // to do a bunch of operations in a row.
-  BandRect*       mCachedBandPosition;
-
-protected:
-  FrameInfo* GetFrameInfoFor(nsIFrame* aFrame);
-  FrameInfo* CreateFrameInfo(nsIFrame* aFrame, const nsRect& aRect);
-  void       DestroyFrameInfo(FrameInfo*);
-
-  void       ClearFrameInfo();
-
-  BandRect*  GetNextBand(const BandRect* aBandRect) const;
-  BandRect*  GetPrevBand(const BandRect* aBandRect) const;
-  void       DivideBand(BandRect* aBand, nscoord aBottom);
-  PRBool     CanJoinBands(BandRect* aBand, BandRect* aPrevBand);
-  PRBool     JoinBands(BandRect* aBand, BandRect* aPrevBand);
-  void       AddRectToBand(BandRect* aBand, BandRect* aBandRect);
-  void       InsertBandRect(BandRect* aBandRect);
-
-  nsresult   GetBandAvailableSpace(const BandRect* aBand,
-                                   nscoord         aY,
-                                   const nsSize&   aMaxSize,
-                                   nsBandData&     aAvailableSpace) const;
-
-  // Return a band guaranteed to have its top at or above aYOffset or the first
-  // band if there is no band with its top above aYOffset.  This method will
-  // use mCachedBandPosition to maybe get such a band that's not too far up.
-  // This function should not be called if there are no bands.
-  // This function never returns null.
-  BandRect*  GuessBandWithTopAbove(nscoord aYOffset) const;
-
-  void SetCachedBandPosition(BandRect* aBandRect) {
-    NS_ASSERTION(!aBandRect ||
-                 aBandRect == mBandList.Head() ||
-                 aBandRect->Prev()->mBottom != aBandRect->mBottom,
-                 "aBandRect should be first rect within its band");
-    mCachedBandPosition = aBandRect;
-  }
-
-
-private:
-  static PRInt32 sCachedSpaceManagerCount;
-  static void* sCachedSpaceManagers[NS_SPACE_MANAGER_CACHE_SIZE];
-
-  nsSpaceManager(const nsSpaceManager&);  // no implementation
-  void operator=(const nsSpaceManager&);  // no implementation
+  nsFloatManager(const nsFloatManager&);  // no implementation
+  void operator=(const nsFloatManager&);  // no implementation
 };
 
 /**
- * A helper class to manage maintenance of the space manager during
+ * A helper class to manage maintenance of the float manager during
  * nsBlockFrame::Reflow. It automatically restores the old space
  * manager in the reflow state when the object goes out of scope.
  */
-class nsAutoSpaceManager {
+class nsAutoFloatManager {
 public:
-  nsAutoSpaceManager(nsHTMLReflowState& aReflowState)
+  nsAutoFloatManager(nsHTMLReflowState& aReflowState)
     : mReflowState(aReflowState),
       mNew(nsnull),
       mOld(nsnull) {}
 
-  ~nsAutoSpaceManager();
+  ~nsAutoFloatManager();
 
   /**
-   * Create a new space manager for the specified frame. This will
-   * `remember' the old space manager, and install the new space
+   * Create a new float manager for the specified frame. This will
+   * `remember' the old float manager, and install the new space
    * manager in the reflow state.
    */
   nsresult
-  CreateSpaceManager(nsPresContext *aPresContext);
+  CreateFloatManager(nsPresContext *aPresContext);
 
 protected:
   nsHTMLReflowState &mReflowState;
-  nsSpaceManager *mNew;
-  nsSpaceManager *mOld;
+  nsFloatManager *mNew;
+  nsFloatManager *mOld;
 };
 
-#endif /* nsSpaceManager_h___ */
-
+#endif /* !defined(nsFloatManager_h_) */
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -91,17 +91,17 @@ nsHTMLReflowState::nsHTMLReflowState(nsP
   , mReflowDepth(0)
 {
   NS_PRECONDITION(aPresContext, "no pres context");
   NS_PRECONDITION(aRenderingContext, "no rendering context");
   NS_PRECONDITION(aFrame, "no frame");
   parentReflowState = nsnull;
   availableWidth = aAvailableSpace.width;
   availableHeight = aAvailableSpace.height;
-  mSpaceManager = nsnull;
+  mFloatManager = nsnull;
   mLineLayout = nsnull;
   mFlags.mSpecialHeightReflow = PR_FALSE;
   mFlags.mIsTopOfPage = PR_FALSE;
   mFlags.mTableIsSplittable = PR_FALSE;
   mFlags.mNextInFlowUntouched = PR_FALSE;
   mFlags.mAssumingHScrollbar = mFlags.mAssumingVScrollbar = PR_FALSE;
   mFlags.mHasClearance = PR_FALSE;
   mFlags.mHeightDependsOnAncestorCell = PR_FALSE;
@@ -150,17 +150,17 @@ nsHTMLReflowState::nsHTMLReflowState(nsP
   // time, as a resize?
   if (!mFlags.mSpecialHeightReflow)
     frame->AddStateBits(parentReflowState->frame->GetStateBits() &
                         NS_FRAME_IS_DIRTY);
 
   availableWidth = aAvailableSpace.width;
   availableHeight = aAvailableSpace.height;
 
-  mSpaceManager = aParentReflowState.mSpaceManager;
+  mFloatManager = aParentReflowState.mFloatManager;
   if (frame->IsFrameOfType(nsIFrame::eLineParticipant))
     mLineLayout = aParentReflowState.mLineLayout;
   else
     mLineLayout = nsnull;
   mFlags.mIsTopOfPage = aParentReflowState.mFlags.mIsTopOfPage;
   mFlags.mNextInFlowUntouched = aParentReflowState.mFlags.mNextInFlowUntouched &&
     CheckNextInFlowParenthood(aFrame, aParentReflowState.frame);
   mFlags.mAssumingHScrollbar = mFlags.mAssumingVScrollbar = PR_FALSE;
diff --git a/layout/generic/nsHTMLReflowState.h b/layout/generic/nsHTMLReflowState.h
--- a/layout/generic/nsHTMLReflowState.h
+++ b/layout/generic/nsHTMLReflowState.h
@@ -41,17 +41,17 @@
 #define nsHTMLReflowState_h___
 
 #include "nsMargin.h"
 #include "nsStyleCoord.h"
 #include "nsIFrame.h"
 
 class nsPresContext;
 class nsIRenderingContext;
-class nsSpaceManager;
+class nsFloatManager;
 class nsLineLayout;
 class nsIPercentHeightObserver;
 
 struct nsStyleDisplay;
 struct nsStyleVisibility;
 struct nsStylePosition;
 struct nsStyleBorder;
 struct nsStyleMargin;
@@ -239,18 +239,18 @@ struct nsHTMLReflowState : public nsCSSO
   // and margin (and similar for its complete ancestors) will need to
   // fit in this height.
   nscoord              availableHeight;
 
   // The type of frame, from css's perspective. This value is
   // initialized by the Init method below.
   nsCSSFrameType   mFrameType;
 
-  // pointer to the space manager associated with this area
-  nsSpaceManager* mSpaceManager;
+  // pointer to the float manager associated with this area
+  nsFloatManager* mFloatManager;
 
   // The amount the in-flow position of the block is moving vertically relative
   // to its previous in-flow position (i.e. the amount the line containing the
   // block is moving).
   // This should be zero for anything which is not a block outside, and it
   // should be zero for anything which has a non-block parent.
   // The intended use of this value is to allow the accurate determination
   // of the potential impact of a float
diff --git a/layout/generic/nsLineBox.cpp b/layout/generic/nsLineBox.cpp
--- a/layout/generic/nsLineBox.cpp
+++ b/layout/generic/nsLineBox.cpp
@@ -36,17 +36,16 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* representation of one line within a block frame, a CSS line box */
 
 #include "nsLineBox.h"
-#include "nsSpaceManager.h"
 #include "nsLineLayout.h"
 #include "prprf.h"
 #include "nsBlockFrame.h"
 #include "nsGkAtoms.h"
 #include "nsFrameManager.h"
 #ifdef IBMBIDI
 #include "nsBidiPresUtils.h"
 #endif
diff --git a/layout/generic/nsLineBox.h b/layout/generic/nsLineBox.h
--- a/layout/generic/nsLineBox.h
+++ b/layout/generic/nsLineBox.h
@@ -41,17 +41,16 @@
 /* representation of one line within a block frame, a CSS line box */
 
 #ifndef nsLineBox_h___
 #define nsLineBox_h___
 
 #include "nsPlaceholderFrame.h"
 #include "nsILineIterator.h"
 
-class nsSpaceManager;
 class nsLineBox;
 class nsFloatCache;
 class nsFloatCacheList;
 class nsFloatCacheFreeList;
 
 // State cached after reflowing a float. This state is used during
 // incremental reflow when we avoid reflowing a float.
 class nsFloatCache {
diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -47,17 +47,17 @@
 #include "plarena.h"
 
 #include "nsCOMPtr.h"
 #include "nsLineLayout.h"
 #include "nsBlockFrame.h"
 #include "nsInlineFrame.h"
 #include "nsStyleConsts.h"
 #include "nsHTMLContainerFrame.h"
-#include "nsSpaceManager.h"
+#include "nsFloatManager.h"
 #include "nsStyleContext.h"
 #include "nsPresContext.h"
 #include "nsIFontMetrics.h"
 #include "nsIThebesFontMetrics.h"
 #include "nsIRenderingContext.h"
 #include "nsGkAtoms.h"
 #include "nsPlaceholderFrame.h"
 #include "nsIDocument.h"
@@ -88,34 +88,34 @@
 //----------------------------------------------------------------------
 
 #define FIX_BUG_50257
 
 #define PLACED_LEFT  0x1
 #define PLACED_RIGHT 0x2
 
 nsLineLayout::nsLineLayout(nsPresContext* aPresContext,
-                           nsSpaceManager* aSpaceManager,
+                           nsFloatManager* aFloatManager,
                            const nsHTMLReflowState* aOuterReflowState,
                            const nsLineList::iterator* aLine)
   : mPresContext(aPresContext),
-    mSpaceManager(aSpaceManager),
+    mFloatManager(aFloatManager),
     mBlockReflowState(aOuterReflowState),
     mLastOptionalBreakContent(nsnull),
     mForceBreakContent(nsnull),
     mLastOptionalBreakContentOffset(-1),
     mForceBreakContentOffset(-1),
     mLastOptionalBreakPriority(eNoBreak),
     mBlockRS(nsnull),/* XXX temporary */
     mMinLineHeight(0),
     mTextIndent(0)
 {
-  NS_ASSERTION(aSpaceManager || aOuterReflowState->frame->GetType() ==
+  NS_ASSERTION(aFloatManager || aOuterReflowState->frame->GetType() ==
                                   nsGkAtoms::letterFrame,
-               "space manager should be present");
+               "float manager should be present");
   MOZ_COUNT_CTOR(nsLineLayout);
 
   // Stash away some style data that we need
   mStyleText = aOuterReflowState->frame->GetStyleText();
   mTextAlign = mStyleText->mTextAlign;
   mLineNumber = 0;
   mFlags = 0; // default all flags to false except those that follow here...
   mPlacedFloats = 0;
@@ -836,17 +836,17 @@ nsLineLayout::ReflowFrame(nsIFrame* aFra
   // border+padding before translating.
   nsHTMLReflowMetrics metrics;
 #ifdef DEBUG
   metrics.width = nscoord(0xdeadbeef);
   metrics.height = nscoord(0xdeadbeef);
 #endif
   nscoord tx = x - psd->mReflowState->mComputedBorderPadding.left;
   nscoord ty = y - psd->mReflowState->mComputedBorderPadding.top;
-  mSpaceManager->Translate(tx, ty);
+  mFloatManager->Translate(tx, ty);
 
   nsIAtom* frameType = aFrame->GetType();
   PRInt32 savedOptionalBreakOffset;
   gfxBreakPriority savedOptionalBreakPriority;
   nsIContent* savedOptionalBreakContent =
     GetLastOptionalBreakPosition(&savedOptionalBreakOffset,
                                  &savedOptionalBreakPriority);
 
@@ -944,17 +944,17 @@ nsLineLayout::ReflowFrame(nsIFrame* aFra
       if (pfd->mSpan) {
         isEmpty = !pfd->mSpan->mHasNonemptyContent && pfd->mFrame->IsSelfEmpty();
       } else {
         isEmpty = pfd->mFrame->IsEmpty();
       }
     }
   }
 
-  mSpaceManager->Translate(-tx, -ty);
+  mFloatManager->Translate(-tx, -ty);
 
   NS_ASSERTION(metrics.width>=0, "bad width");
   NS_ASSERTION(metrics.height>=0,"bad height");
   if (metrics.width<0) metrics.width=0;
   if (metrics.height<0) metrics.height=0;
 
 #ifdef DEBUG
   // Note: break-before means ignore the reflow metrics since the
diff --git a/layout/generic/nsLineLayout.h b/layout/generic/nsLineLayout.h
--- a/layout/generic/nsLineLayout.h
+++ b/layout/generic/nsLineLayout.h
@@ -54,24 +54,24 @@
 #include "nsDeque.h"
 #include "nsLineBox.h"
 #include "nsBlockReflowState.h"
 #include "plarena.h"
 #include "gfxTypes.h"
 
 class nsBlockFrame;
 
-class nsSpaceManager;
+class nsFloatManager;
 class nsPlaceholderFrame;
 struct nsStyleText;
 
 class nsLineLayout {
 public:
   nsLineLayout(nsPresContext* aPresContext,
-               nsSpaceManager* aSpaceManager,
+               nsFloatManager* aFloatManager,
                const nsHTMLReflowState* aOuterReflowState,
                const nsLineList::iterator* aLine);
   ~nsLineLayout();
 
   void Init(nsBlockReflowState* aState, nscoord aMinLineHeight,
             PRInt32 aLineNumber) {
     mBlockRS = aState;
     mMinLineHeight = aMinLineHeight;
@@ -368,17 +368,17 @@ public:
    * start content edge is:
    * <code>GetCurrentFrameXDistanceFromBlock() - lineContainer->GetUsedBorderAndPadding().left</code>
    * Note the use of <code>.left</code> for both LTR and RTL line containers.
    */
   nscoord GetCurrentFrameXDistanceFromBlock();
 
 protected:
   // This state is constant for a given block frame doing line layout
-  nsSpaceManager* mSpaceManager;
+  nsFloatManager* mFloatManager;
   const nsStyleText* mStyleText; // for the block
   const nsHTMLReflowState* mBlockReflowState;
 
   nsIContent* mLastOptionalBreakContent;
   nsIContent* mForceBreakContent;
   PRInt32     mLastOptionalBreakContentOffset;
   PRInt32     mForceBreakContentOffset;
   gfxBreakPriority mLastOptionalBreakPriority;
diff --git a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
--- a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
+++ b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
@@ -36,17 +36,16 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsSVGForeignObjectFrame.h"
 
 #include "nsIDOMSVGForeignObjectElem.h"
 #include "nsIDOMSVGMatrix.h"
 #include "nsIDOMSVGSVGElement.h"
-#include "nsSpaceManager.h"
 #include "nsSVGOuterSVGFrame.h"
 #include "nsRegion.h"
 #include "nsGkAtoms.h"
 #include "nsLayoutUtils.h"
 #include "nsSVGUtils.h"
 #include "nsIURI.h"
 #include "nsSVGRect.h"
 #include "nsSVGMatrix.h"
diff --git a/layout/xul/base/src/nsBoxFrame.cpp b/layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp
+++ b/layout/xul/base/src/nsBoxFrame.cpp
@@ -67,17 +67,16 @@
 #include "nsBoxLayoutState.h"
 #include "nsBoxFrame.h"
 #include "nsStyleContext.h"
 #include "nsPresContext.h"
 #include "nsCOMPtr.h"
 #include "nsINameSpaceManager.h"
 #include "nsGkAtoms.h"
 #include "nsIContent.h"
-#include "nsSpaceManager.h"
 #include "nsHTMLParts.h"
 #include "nsIViewManager.h"
 #include "nsIView.h"
 #include "nsIPresShell.h"
 #include "nsFrameNavigator.h"
 #include "nsCSSRendering.h"
 #include "nsIServiceManager.h"
 #include "nsIBoxLayout.h"
