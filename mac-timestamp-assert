From: L. David Baron <dbaron@dbaron.org>

Make the Darwin TimeStamp implementation assert when used before it is initialized.  (Bug 693821)

diff --git a/xpcom/ds/TimeStamp_darwin.cpp b/xpcom/ds/TimeStamp_darwin.cpp
--- a/xpcom/ds/TimeStamp_darwin.cpp
+++ b/xpcom/ds/TimeStamp_darwin.cpp
@@ -58,16 +58,17 @@ static PRUint64 sResolution;
 static PRUint64 sResolutionSigDigs;
 
 static const PRUint16 kNsPerUs   =       1000;
 static const PRUint64 kNsPerMs   =    1000000;
 static const PRUint64 kNsPerSec  = 1000000000;
 static const double kNsPerMsd    =    1000000.0;
 static const double kNsPerSecd   = 1000000000.0;
 
+static bool gInitialized = false;
 static double sNsPerTick;
 
 static PRUint64
 ClockTime()
 {
   // mach_absolute_time is it when it comes to ticks on the Mac.  Other calls
   // with less precision (such as TickCount) just call through to
   // mach_absolute_time.
@@ -106,53 +107,56 @@ ClockResolutionNs()
   return minres;
 }
 
 namespace mozilla {
 
 double
 TimeDuration::ToSeconds() const
 {
+  NS_ABORT_IF_FALSE(gInitialized, "calling TimeDuration too early");
   return (mValue * sNsPerTick) / kNsPerSecd;
 }
 
 double
 TimeDuration::ToSecondsSigDigits() const
 {
+  NS_ABORT_IF_FALSE(gInitialized, "calling TimeDuration too early");
   // don't report a value < mResolution ...
   PRInt64 valueSigDigs = sResolution * (mValue / sResolution);
   // and chop off insignificant digits
   valueSigDigs = sResolutionSigDigs * (valueSigDigs / sResolutionSigDigs);
   return (valueSigDigs * sNsPerTick) / kNsPerSecd;
 }
 
 TimeDuration
 TimeDuration::FromMilliseconds(double aMilliseconds)
 {
+  NS_ABORT_IF_FALSE(gInitialized, "calling TimeDuration too early");
   return TimeDuration::FromTicks(PRInt64((aMilliseconds * kNsPerMsd) / sNsPerTick));
 }
 
 TimeDuration
 TimeDuration::Resolution()
 {
+  NS_ABORT_IF_FALSE(gInitialized, "calling TimeDuration too early");
   return TimeDuration::FromTicks(PRInt64(sResolution));
 }
 
 struct TimeStampInitialization
 {
   TimeStampInitialization() {
     TimeStamp::Startup();
   }
   ~TimeStampInitialization() {
     TimeStamp::Shutdown();
   }
 };
 
 static TimeStampInitialization initOnce;
-static bool gInitialized = false;
 
 nsresult
 TimeStamp::Startup()
 {
   if (gInitialized)
     return NS_OK;
 
   mach_timebase_info_data_t timebaseInfo;
