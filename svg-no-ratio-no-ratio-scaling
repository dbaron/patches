From: L. David Baron <dbaron@dbaron.org>

Bug 1131812 - Don't do ratio scaling when applying min/max-width/height for images without an intrinsic ratio.

diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -4843,100 +4843,88 @@ nsLayoutUtils::ComputeSizeWithIntrinsicD
   }
 
   NS_ASSERTION(aIntrinsicRatio.width >= 0 && aIntrinsicRatio.height >= 0,
                "Intrinsic ratio has a negative component!");
   LogicalSize logicalRatio(aWM, aIntrinsicRatio);
 
   // Now calculate the used values for iSize and bSize:
 
-  if (isAutoISize) {
-    if (isAutoBSize) {
-
-      // 'auto' iSize, 'auto' bSize
-
-      // Get tentative values - CSS 2.1 sections 10.3.2 and 10.6.2:
-
-      nscoord tentISize, tentBSize;
-
-      if (hasIntrinsicISize) {
-        tentISize = intrinsicISize;
-      } else if (hasIntrinsicBSize && logicalRatio.BSize(aWM) > 0) {
-        tentISize = NSCoordMulDiv(intrinsicBSize, logicalRatio.ISize(aWM), logicalRatio.BSize(aWM));
-      } else if (logicalRatio.ISize(aWM) > 0) {
-        tentISize = aCBSize.ISize(aWM) - boxSizingToMarginEdgeISize; // XXX scrollbar?
-        if (tentISize < 0) tentISize = 0;
-      } else {
-        tentISize = nsPresContext::CSSPixelsToAppUnits(300);
-      }
-
-      if (hasIntrinsicBSize) {
-        tentBSize = intrinsicBSize;
-      } else if (logicalRatio.ISize(aWM) > 0) {
-        tentBSize = NSCoordMulDiv(tentISize, logicalRatio.BSize(aWM), logicalRatio.ISize(aWM));
-      } else {
-        tentBSize = nsPresContext::CSSPixelsToAppUnits(150);
-      }
-
-      nsSize autoSize =
-        ComputeAutoSizeWithIntrinsicDimensions(minISize, minBSize,
-                                               maxISize, maxBSize,
-                                               tentISize, tentBSize);
-      // The nsSize that ComputeAutoSizeWithIntrinsicDimensions returns will
-      // actually contain logical values if the parameters passed to it were
-      // logical coordinates, so we do NOT perform a physical-to-logical
-      // conversion here, but just assign the fields directly to our result.
-      return LogicalSize(aWM, autoSize.width, autoSize.height);
+  if (isAutoISize && isAutoBSize && aIntrinsicRatio != nsSize(0, 0)) {
+    // 'auto' iSize, 'auto' bSize, and an intrinsic ratio
+
+    // Get tentative values - CSS 2.1 sections 10.3.2 and 10.6.2:
+
+    nscoord tentISize, tentBSize;
+
+    if (hasIntrinsicISize) {
+      tentISize = intrinsicISize;
+    } else if (hasIntrinsicBSize && logicalRatio.BSize(aWM) > 0) {
+      tentISize = NSCoordMulDiv(intrinsicBSize, logicalRatio.ISize(aWM), logicalRatio.BSize(aWM));
+    } else if (logicalRatio.ISize(aWM) > 0) {
+      tentISize = aCBSize.ISize(aWM) - boxSizingToMarginEdgeISize; // XXX scrollbar?
+      if (tentISize < 0) tentISize = 0;
     } else {
-
-      // 'auto' iSize, non-'auto' bSize
-      bSize = NS_CSS_MINMAX(bSize, minBSize, maxBSize);
+      tentISize = nsPresContext::CSSPixelsToAppUnits(300);
+    }
+
+    if (hasIntrinsicBSize) {
+      tentBSize = intrinsicBSize;
+    } else if (logicalRatio.ISize(aWM) > 0) {
+      tentBSize = NSCoordMulDiv(tentISize, logicalRatio.BSize(aWM), logicalRatio.ISize(aWM));
+    } else {
+      tentBSize = nsPresContext::CSSPixelsToAppUnits(150);
+    }
+
+    nsSize autoSize =
+      ComputeAutoSizeWithIntrinsicDimensions(minISize, minBSize,
+                                             maxISize, maxBSize,
+                                             tentISize, tentBSize);
+    // The nsSize that ComputeAutoSizeWithIntrinsicDimensions returns will
+    // actually contain logical values if the parameters passed to it were
+    // logical coordinates, so we do NOT perform a physical-to-logical
+    // conversion here, but just assign the fields directly to our result.
+    return LogicalSize(aWM, autoSize.width, autoSize.height);
+  } else {
+    if (isAutoISize) {
       if (logicalRatio.BSize(aWM) > 0) {
         iSize = NSCoordMulDiv(bSize, logicalRatio.ISize(aWM), logicalRatio.BSize(aWM));
       } else if (hasIntrinsicISize) {
         iSize = intrinsicISize;
       } else {
         iSize = nsPresContext::CSSPixelsToAppUnits(300);
       }
-      iSize = NS_CSS_MINMAX(iSize, minISize, maxISize);
-
-    }
-  } else {
+    }
+    iSize = NS_CSS_MINMAX(iSize, minISize, maxISize);
+
     if (isAutoBSize) {
-
-      // non-'auto' iSize, 'auto' bSize
-      iSize = NS_CSS_MINMAX(iSize, minISize, maxISize);
       if (logicalRatio.ISize(aWM) > 0) {
         bSize = NSCoordMulDiv(iSize, logicalRatio.BSize(aWM), logicalRatio.ISize(aWM));
       } else if (hasIntrinsicBSize) {
         bSize = intrinsicBSize;
       } else {
         bSize = nsPresContext::CSSPixelsToAppUnits(150);
       }
-      bSize = NS_CSS_MINMAX(bSize, minBSize, maxBSize);
-
-    } else {
-
-      // non-'auto' iSize, non-'auto' bSize
-      iSize = NS_CSS_MINMAX(iSize, minISize, maxISize);
-      bSize = NS_CSS_MINMAX(bSize, minBSize, maxBSize);
-
-    }
+    }
+    bSize = NS_CSS_MINMAX(bSize, minBSize, maxBSize);
   }
 
   return LogicalSize(aWM, iSize, bSize);
 }
 
 nsSize
 nsLayoutUtils::ComputeAutoSizeWithIntrinsicDimensions(nscoord minWidth, nscoord minHeight,
                                                       nscoord maxWidth, nscoord maxHeight,
                                                       nscoord tentWidth, nscoord tentHeight)
 {
   // Now apply min/max-width/height - CSS 2.1 sections 10.4 and 10.7:
 
+  // Note that this code should only be called if the replaced element
+  // has an intrinsic ratio.
+
   if (minWidth > maxWidth)
     maxWidth = minWidth;
   if (minHeight > maxHeight)
     maxHeight = minHeight;
 
   nscoord heightAtMaxWidth, heightAtMinWidth,
           widthAtMaxHeight, widthAtMinHeight;
 
