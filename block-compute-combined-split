From: L. David Baron <dbaron@dbaron.org>

Compute nsBlockFrame::ComputeCombinedArea to split overflow areas.  (Bug 542595)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1101,17 +1101,17 @@ nsBlockFrame::Reflow(nsPresContext*     
       mBullet->SetRect(bbox);
     }
     // Otherwise just leave the bullet where it is, up against our top padding.
   }
 
   // Compute our final size
   nscoord bottomEdgeOfChildren;
   ComputeFinalSize(aReflowState, state, aMetrics, &bottomEdgeOfChildren);
-  ComputeCombinedArea(aReflowState, aMetrics, bottomEdgeOfChildren);
+  ComputeOverflowAreas(aReflowState, aMetrics, bottomEdgeOfChildren);
   // Factor overflow container child bounds into the overflow area
   aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea, ocBounds);
   // Factor pushed float child bounds into the overflow area
   aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea, fcBounds);
 
   // Let the absolutely positioned container reflow any absolutely positioned
   // child frames that need to be reflowed, e.g., elements with a percentage
   // based width/height
@@ -1433,70 +1433,86 @@ nsBlockFrame::ComputeFinalSize(const nsH
   if (CRAZY_WIDTH(aMetrics.width) || CRAZY_HEIGHT(aMetrics.height)) {
     ListTag(stdout);
     printf(": WARNING: desired:%d,%d\n", aMetrics.width, aMetrics.height);
   }
 #endif
 }
 
 void
-nsBlockFrame::ComputeCombinedArea(const nsHTMLReflowState& aReflowState,
-                                  nsHTMLReflowMetrics&     aMetrics,
-                                  nscoord                  aBottomEdgeOfChildren)
+nsBlockFrame::ComputeOverflowAreas(const nsHTMLReflowState& aReflowState,
+                                   nsHTMLReflowMetrics&     aMetrics,
+                                   nscoord                  aBottomEdgeOfChildren)
 {
-  // Compute the combined area of our children
+  // Compute the overflow areas of our children
   // XXX_perf: This can be done incrementally.  It is currently one of
   // the things that makes incremental reflow O(N^2).
-  nsRect area(0, 0, aMetrics.width, aMetrics.height);
+  nsRect areas[2];
+  NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+    areas[otype].SetRect(0, 0, aMetrics.width, aMetrics.height);
+  }
 
   if (NS_STYLE_OVERFLOW_CLIP != aReflowState.mStyleDisplay->mOverflowX) {
     PRBool inQuirks = (PresContext()->CompatibilityMode() == eCompatibility_NavQuirks);
     for (line_iterator line = begin_lines(), line_end = end_lines();
          line != line_end;
          ++line) {
 
       // Text-shadow overflows
       if (!inQuirks && line->IsInline()) {
-        nsRect shadowRect = nsLayoutUtils::GetTextShadowRectsUnion(line->GetCombinedArea(),
-                                                                   this);
-        area.UnionRect(area, shadowRect);
+        nsRect shadowRect = nsLayoutUtils::GetTextShadowRectsUnion(
+                              line->GetVisualOverflowArea(), this);
+        areas[eVisualOverflow].UnionRect(areas[eVisualOverflow], shadowRect);
       }
 
-      area.UnionRect(area, line->GetCombinedArea());
+      NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+        areas[otype].UnionRect(areas[otype], line->GetOverflowArea(otype));
+      }
     }
 
     // Factor the bullet in; normally the bullet will be factored into
-    // the line-box's combined area. However, if the line is a block
+    // the line-box's overflow areas. However, if the line is a block
     // line then it won't; if there are no lines, it won't. So just
     // factor it in anyway (it can't hurt if it was already done).
-    // XXXldb Can we just fix GetCombinedArea instead?
+    // XXXldb Can we just fix GetOverflowArea instead?
     if (mBullet) {
-      area.UnionRect(area, mBullet->GetRect());
+      nsRect r = mBullet->GetRect();
+      NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+        areas[otype].UnionRect(areas[otype], r);
+      }
     }
 
     // Factor in the bottom edge of the children. Child frames
     // will be added to the overflow area as we iterate through the lines,
     // but their margins won't, so we need to account for bottom margins
     // here. If we're a scrolled block then we also need to account
     // for the scrollframe's padding, which is logically below the
     // bottom margins of the children.
     nscoord bottomEdgeOfContents = aBottomEdgeOfChildren;
     if (GetStyleContext()->GetPseudo() == nsCSSAnonBoxes::scrolledContent) {
       // We're a scrolled frame; the scrollframe's padding should be added
       // to the bottom edge of the children
       bottomEdgeOfContents += aReflowState.mComputedPadding.bottom;
     }
-    area.height = NS_MAX(area.YMost(), bottomEdgeOfContents) - area.y;
+    // REVIEW: For now, we do this for both visual and scrollable area,
+    // although when we make scrollable overflow area not be a subset of
+    // visual, we can change this.
+    NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+      areas[otype].height =
+        NS_MAX(areas[otype].YMost(), bottomEdgeOfContents) - areas[otype].y;
+    }
   }
 #ifdef NOISY_COMBINED_AREA
   ListTag(stdout);
   printf(": ca=%d,%d,%d,%d\n", area.x, area.y, area.width, area.height);
 #endif
 
-  aMetrics.mOverflowArea = area;
+  NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+    aMetrics.mOverflowAreas[otype] = areas[otype];
+  }
 }
 
 nsresult
 nsBlockFrame::MarkLineDirty(line_iterator aLine, const nsLineList* aLineList)
 {
   // Mark aLine dirty
   aLine->MarkDirty();
   aLine->SetInvalidateTextRuns(PR_TRUE);
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -210,20 +210,21 @@ public:
 #endif
 
 #ifdef ACCESSIBILITY
   virtual already_AddRefed<nsAccessible> CreateAccessible();
 #endif
 
   // line cursor methods to speed up searching for the line(s)
   // containing a point. The basic idea is that we set the cursor
-  // property if the lines' combinedArea.ys and combinedArea.yMosts
-  // are non-decreasing (considering only non-empty combinedAreas;
-  // empty combinedAreas never participate in event handling or
-  // painting), and the block has sufficient number of lines. The
+  // property if the lines' overflowArea[eVisualOverflow].ys and
+  // overflowArea[eVisualOverflow].yMosts are non-decreasing
+  // (considering only non-empty overflowArea[eVisualOverflow]s; empty
+  // overflowArea[eVisualOverflow]s never participate in event handling
+  // or painting), and the block has sufficient number of lines. The
   // cursor property points to a "recently used" line. If we get a
   // series of requests that work on lines
   // "near" the cursor, then we can find those nearby lines quickly by
   // starting our search at the cursor.
 
   // Clear out line cursor because we're disturbing the lines (i.e., Reflow)
   void ClearLineCursor();
   // Get the first line that might contain y-coord 'y', or nsnull if you must search
@@ -391,19 +392,19 @@ protected:
 
   virtual PRIntn GetSkipSides() const;
 
   virtual void ComputeFinalSize(const nsHTMLReflowState& aReflowState,
                                 nsBlockReflowState&      aState,
                                 nsHTMLReflowMetrics&     aMetrics,
                                 nscoord*                 aBottomEdgeOfChildren);
 
-  void ComputeCombinedArea(const nsHTMLReflowState& aReflowState,
-                           nsHTMLReflowMetrics&     aMetrics,
-                           nscoord                  aBottomEdgeOfChildren);
+  void ComputeOverflowAreas(const nsHTMLReflowState& aReflowState,
+                            nsHTMLReflowMetrics&     aMetrics,
+                            nscoord                  aBottomEdgeOfChildren);
 
   /** add the frames in aFrameList to this block after aPrevSibling
     * this block thinks in terms of lines, but the frame construction code
     * knows nothing about lines at all. So we need to find the line that
     * contains aPrevSibling and add aFrameList after aPrevSibling on that line.
     * new lines are created as necessary to handle block data in aFrameList.
     * This function will clear aFrameList.
     */
