From: L. David Baron <dbaron@dbaron.org>

Bug 1089417 patch 4 - Define equality operators on nsMediaQueryResultCacheKey and the types it contains.

This is needed for the equality comparison in
nsCSSRuleProcessor::MediumFeaturesChanged in patch 8.

diff --git a/layout/style/nsIMediaList.h b/layout/style/nsIMediaList.h
--- a/layout/style/nsIMediaList.h
+++ b/layout/style/nsIMediaList.h
@@ -32,17 +32,26 @@ struct nsMediaExpression {
   enum Range { eMin, eMax, eEqual };
 
   const nsMediaFeature *mFeature;
   Range mRange;
   nsCSSValue mValue;
 
   // aActualValue must be obtained from mFeature->mGetter
   bool Matches(nsPresContext* aPresContext,
-                 const nsCSSValue& aActualValue) const;
+               const nsCSSValue& aActualValue) const;
+
+  bool operator==(const nsMediaExpression& aOther) const {
+    return mFeature == aOther.mFeature && // pointer equality fine (atom-like)
+           mRange == aOther.mRange &&
+           mValue == aOther.mValue;
+  }
+  bool operator!=(const nsMediaExpression& aOther) const {
+    return !(*this == aOther);
+  }
 };
 
 /**
  * An nsMediaQueryResultCacheKey records what feature/value combinations
  * a set of media query results are valid for.  This allows the caller
  * to quickly learn whether a prior result of media query evaluation is
  * still valid (e.g., due to a window size change) without rerunning all
  * of the evaluation and rebuilding the list of rules.
@@ -68,27 +77,55 @@ public:
   /**
    * Record that aExpression was tested while building the cached set
    * that this cache key is for, and that aExpressionMatches was whether
    * it matched.
    */
   void AddExpression(const nsMediaExpression* aExpression,
                      bool aExpressionMatches);
   bool Matches(nsPresContext* aPresContext) const;
+
+  /**
+   * An operator== that implements list equality, which isn't quite as
+   * good as set equality, but catches the trivial equality cases.
+   */
+  bool operator==(const nsMediaQueryResultCacheKey& aOther) const {
+    return mMedium == aOther.mMedium &&
+           mFeatureCache == aOther.mFeatureCache;
+  }
+  bool operator!=(const nsMediaQueryResultCacheKey& aOther) const {
+    return !(*this == aOther);
+  }
 private:
   struct ExpressionEntry {
     // FIXME: if we were better at maintaining invariants about clearing
     // rule cascades when media lists change, this could be a |const
     // nsMediaExpression*| instead.
     nsMediaExpression mExpression;
     bool mExpressionMatches;
+
+    bool operator==(const ExpressionEntry& aOther) const {
+      return mExpression == aOther.mExpression &&
+             mExpressionMatches == aOther.mExpressionMatches;
+    }
+    bool operator!=(const ExpressionEntry& aOther) const {
+      return !(*this == aOther);
+    }
   };
   struct FeatureEntry {
     const nsMediaFeature *mFeature;
     InfallibleTArray<ExpressionEntry> mExpressions;
+
+    bool operator==(const FeatureEntry& aOther) const {
+      return mFeature == aOther.mFeature &&
+             mExpressions == aOther.mExpressions;
+    }
+    bool operator!=(const FeatureEntry& aOther) const {
+      return !(*this == aOther);
+    }
   };
   nsCOMPtr<nsIAtom> mMedium;
   nsTArray<FeatureEntry> mFeatureCache;
 };
 
 class nsMediaQuery {
 public:
   nsMediaQuery()
