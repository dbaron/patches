From: L. David Baron <dbaron@dbaron.org>

Add per-property tests for CSS transitions to test the code in nsStyleAnimation.  (Bug 435441, Bug 504652)

diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -132,16 +132,17 @@ _TEST_FILES =	test_acid3_test46.html \
 		test_selectors.html \
 		test_selectors_on_anonymous_content.html \
 		test_shorthand_property_getters.html \
 		test_style_struct_copy_constructors.html \
 		test_system_font_serialization.html \
 		test_transitions_computed_values.html \
 		test_transitions_computed_value_combinations.html \
 		test_transitions.html \
+		test_transitions_per_property.html \
 		test_units_angle.html \
 		test_units_frequency.html \
 		test_units_length.html \
 		test_units_time.html \
 		test_value_computation.html \
 		test_value_storage.html \
 		test_visited_pref.html \
 		css_properties.js \
diff --git a/layout/style/test/test_transitions_per_property.html b/layout/style/test/test_transitions_per_property.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_transitions_per_property.html
@@ -0,0 +1,141 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=435441
+-->
+<head>
+  <title>Test for Bug 435441</title>
+  <script type="application/javascript" src="/MochiKit/packed.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript" src="property_database.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+  <style type="text/css">
+
+  #display > p { margin-top: 0; margin-bottom: 0; }
+
+  </style>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=435441">Mozilla Bug 435441</a>
+<div id="display">
+
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 435441 **/
+
+var supported_properties = {
+    "margin-top": [ test_length_transition, test_percent_transition ],
+    "margin-right": [ test_length_transition, test_percent_transition ],
+    "margin-bottom": [ test_length_transition, test_percent_transition ],
+    "margin-left": [ test_length_transition, test_percent_transition ],
+    "padding-top": [ test_length_transition, test_percent_transition ],
+    "padding-right": [ test_length_transition, test_percent_transition ],
+    "padding-bottom": [ test_length_transition, test_percent_transition ],
+    "padding-left": [ test_length_transition, test_percent_transition ],
+    "top": [ test_length_transition, test_percent_transition ],
+    "right": [ test_length_transition, test_percent_transition ],
+    "bottom": [ test_length_transition, test_percent_transition ],
+    "left": [ test_length_transition, test_percent_transition ],
+    "outline-width": [ test_length_transition, test_percent_transition ],
+    "width": [ test_length_transition, test_percent_transition ],
+    "min-width": [ test_length_transition, test_percent_transition ],
+    "max-width": [ test_length_transition, test_percent_transition ],
+    "height": [ test_length_transition, test_percent_transition ],
+    "min-height": [ test_length_transition, test_percent_transition ],
+    "max-height": [ test_length_transition, test_percent_transition ],
+    "vertical-align": [ test_length_transition, test_percent_transition ],
+    "letter-spacing": [ test_length_transition, test_percent_transition ],
+    "line-height": [ test_length_transition, test_percent_transition ],
+    "text-indent": [ test_length_transition, test_percent_transition ],
+    "marker-offset": [ test_length_transition, test_percent_transition ],
+    "-moz-column-width": [ test_length_transition, test_percent_transition ],
+    "-moz-column-gap": [ test_length_transition, test_percent_transition ],
+    "stroke-dashoffset": [ test_length_transition, test_percent_transition ],
+    "stroke-width": [ test_length_transition, test_percent_transition ],
+    "outline-offset": [ test_length_transition ],
+    "word-spacing": [ test_length_transition ]
+};
+
+var div = document.getElementById("display");
+var cs = getComputedStyle(div, "");
+
+var prop;
+for (prop in supported_properties) {
+  // Test that prop is in the property database.
+  ok(prop in gCSSProperties, "property " + prop + " in gCSSProperties");
+
+  // Test that the entry has at least one test function.
+  ok(supported_properties[prop].length > 0,
+     "property " + prop + " must have at least one test function");
+}
+
+// Test that transitions don't do anything (i.e., aren't supported) on
+// the properties not in our test list above (and not transition
+// properties themselves).
+for (prop in gCSSProperties) {
+  var info = gCSSProperties[prop];
+  if (!(prop in supported_properties) &&
+      info.type != CSS_TYPE_TRUE_SHORTHAND &&
+      !prop.match(/^-moz-transition-/)) {
+
+    if ("prerequisites" in info) {
+      var prereqs = info.prerequisites;
+      for (var prereq in prereqs) {
+        div.style.setProperty(prereq, prereqs[prereq], "");
+      }
+    }
+
+    var all_values = info.initial_values.concat(info.other_values);
+    var all_computed = [];
+    for (var idx in all_values) {
+      var val = all_values[idx];
+      div.style.setProperty(prop, val, "");
+      all_computed.push(cs.getPropertyValue(prop));
+    }
+    div.style.removeProperty(prop);
+
+    div.style.setProperty("-moz-transition", prop + " 20s linear", "");
+    for (var i = 0; i < all_values.length; ++i) {
+      for (var j = i + 1; j < all_values.length; ++j) {
+        div.style.setProperty(prop, all_values[i], "");
+        is(cs.getPropertyValue(prop), all_computed[i],
+           "transitions not supported for property " + prop +
+           " value " + all_values[i]);
+        div.style.setProperty(prop, all_values[j], "");
+        is(cs.getPropertyValue(prop), all_computed[j],
+           "transitions not supported for property " + prop +
+           " value " + all_values[j]);
+      }
+    }
+
+    div.style.removeProperty(prop);
+    div.style.removeProperty("-moz-transition");
+    if ("prerequisites" in info) {
+      var prereqs = info.prerequisites;
+      for (var prereq in prereqs) {
+        div.style.removeProperty(prereq);
+      }
+    }
+  }
+}
+
+for (prop in supported_properties) {
+  // FIXME: Run actual transition tests.
+
+  // Do 4-second linear transitions with -2 second transition delay.
+}
+
+function test_length_transition() {
+  // FIXME: write me
+}
+
+function test_percent_transition() {
+  // FIXME: write me
+}
+
+</script>
+</pre>
+</body>
+</html>
diff --git a/layout/style/test/transitions_common.js b/layout/style/test/transitions_common.js
new file mode 100644
--- /dev/null
+++ b/layout/style/test/transitions_common.js
@@ -0,0 +1,139 @@
+function px_to_num(str)
+{
+    return Number(String(str).match(/^([\d.]+)px$/)[1]);
+}
+
+// Run tests simultaneously so we don't have to take up too much time.
+SimpleTest.waitForExplicitFinish();
+var gTestsRunning = 0;
+function TestStarted() { ++gTestsRunning; }
+function TestFinished() { if (--gTestsRunning == 0) SimpleTest.finish(); }
+
+// An array of arrays of functions to be called at the outer index number
+// of seconds after the present.
+var gFutureCalls = [];
+
+function add_future_call(index, func)
+{
+    if (!(index in gFutureCalls)) {
+        gFutureCalls[index] = [];
+    }
+    gFutureCalls[index].push(func);
+    TestStarted();
+}
+var gStartTime1, gStartTime2;
+var gCurrentTime;
+function process_future_calls(index)
+{
+    var calls = gFutureCalls[index];
+    if (!calls)
+        return;
+    gCurrentTime = Date.now();
+    for (var i = 0; i < calls.length; ++i) {
+        calls[i]();
+        TestFinished();
+    }
+}
+
+function bezier(x1, y1, x2, y2) {
+    // Cubic bezier with control points (0, 0), (x1, y1), (x2, y2), and (1, 1).
+    function x_for_t(t) {
+        var omt = 1-t;
+        return 3 * omt * omt * t * x1 + 3 * omt * t * t * x2 + t * t * t;
+    }
+    function y_for_t(t) {
+        var omt = 1-t;
+        return 3 * omt * omt * t * y1 + 3 * omt * t * t * y2 + t * t * t;
+    }
+    function t_for_x(x) {
+        // Binary subdivision.
+        var mint = 0, maxt = 1;
+        for (var i = 0; i < 30; ++i) {
+            var guesst = (mint + maxt) / 2;
+            var guessx = x_for_t(guesst);
+            if (x < guessx)
+                maxt = guesst;
+            else
+                mint = guesst;
+        }
+        return (mint + maxt) / 2;
+    }
+    return function bezier_closure(x) {
+        if (x == 0) return 0;
+        if (x == 1) return 1;
+        return y_for_t(t_for_x(x));
+    }
+}
+
+function will_start_transitions()
+{
+    // Do not use setInterval because once it gets off in time, it stays off.
+    for (var i = 1; i <= 8; ++i) {
+        setTimeout(process_future_calls, i * 1000, i);
+    }
+    gStartTime1 = Date.now(); // set before any transitions have started
+}
+
+function did_start_transitions()
+{
+    gStartTime2 = Date.now(); // set after all transitions have started
+    gCurrentTime = gStartTime2;
+}
+
+/**
+ * Assert that a transition whose timing function yields the bezier
+ * |func|, running from |start_time| to |end_time| (both in seconds
+ * relative to when the transitions were started) should have produced
+ * computed value |cval| given that the transition was from
+ * |start_value| to |end_value| (both numbers in CSS pixels).
+ */
+function check_transition_value(func, start_time, end_time,
+                                start_value, end_value, cval, desc,
+                                xfail)
+{
+    function value_at(elapsed, error_portion) {
+        var time_portion = (elapsed - start_time) / (end_time - start_time);
+        if (time_portion < 0)
+            time_portion = 0;
+        else if (time_portion > 1)
+            time_portion = 1;
+        var value_portion = func(time_portion) + error_portion;
+        if (value_portion < 0)
+            value_portion = 0;
+        else if (value_portion > 1)
+            value_portion = 1;
+        return (1 - value_portion) * start_value + value_portion * end_value;
+    }
+
+    var time_range; // in seconds
+    var range;
+    if (gCurrentTime == gStartTime2) {
+        // No timers involved
+        time_range = [0, 0];
+        if (start_time < 0) {
+            range = [ value_at(0, -0.01), value_at(0, 0.01) ].
+                        sort(function compareNumbers(a,b) { return a - b; });
+        } else {
+            var val = value_at(0, 0);
+            range = [val, val];
+        }
+    } else {
+        // seconds
+        // FIXME: Why do we need so much tolerance at the low end of the
+        // range (primarily for Mac)?
+        time_range = [ (gCurrentTime - gStartTime2 - 40) / 1000,
+                       (Date.now() - gStartTime1 + 20) / 1000 ];
+        range = [ value_at(time_range[0], -0.01),
+                  value_at(time_range[1], 0.01) ].
+                    sort(function compareNumbers(a,b) { return a - b; });
+    }
+    var actual = px_to_num(cval);
+
+    var fn = xfail ? todo : ok;
+
+    fn(range[0] <= actual && actual <= range[1],
+       desc + ": computed value " + cval + " should be between " +
+       range[0].toFixed(6) + "px and " + range[1].toFixed(6) +
+       "px at time between " + time_range[0] + "s and " + time_range[1] + "s.");
+}
+
