From: L. David Baron <dbaron@dbaron.org>

Add per-property tests for CSS transitions to test the code in nsStyleAnimation.  (Bug 435441, Bug 504652)

diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -132,16 +132,17 @@ _TEST_FILES =	test_acid3_test46.html \
 		test_selectors.html \
 		test_selectors_on_anonymous_content.html \
 		test_shorthand_property_getters.html \
 		test_style_struct_copy_constructors.html \
 		test_system_font_serialization.html \
 		test_transitions_computed_values.html \
 		test_transitions_computed_value_combinations.html \
 		test_transitions.html \
+		test_transitions_per_property.html \
 		test_units_angle.html \
 		test_units_frequency.html \
 		test_units_length.html \
 		test_units_time.html \
 		test_value_computation.html \
 		test_value_storage.html \
 		test_visited_pref.html \
 		css_properties.js \
@@ -162,16 +163,17 @@ _TEST_FILES =	test_acid3_test46.html \
 		post-redirect-3.css \
 		xbl_bindings.xml \
 		empty.html \
 		media_queries_iframe.html \
 		media_queries_dynamic_xbl_binding.xml \
 		media_queries_dynamic_xbl_iframe.html \
 		media_queries_dynamic_xbl_style.css \
 		bug453896_iframe.html \
+		transitions_common.js \
 		$(NULL)
 
 _BROWSER_FILES = \
 		browser_bug453896.js \
 		bug453896_iframe.html \
 		media_queries_iframe.html \
 		$(NULL)
 
diff --git a/layout/style/test/test_transitions.html b/layout/style/test/test_transitions.html
--- a/layout/style/test/test_transitions.html
+++ b/layout/style/test/test_transitions.html
@@ -2,16 +2,17 @@
 <html>
 <!--
 https://bugzilla.mozilla.org/show_bug.cgi?id=435441
 -->
 <head>
   <title>Test for Bug 435441</title>
   <script type="application/javascript" src="/MochiKit/packed.js"></script>
   <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="application/javascript" src="transitions_common.js"></script>
   <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
   <style type="text/css">
 
   #display p { margin-top: 0; margin-bottom: 0; }
 
   </style>
 </head>
 <body>
@@ -19,83 +20,16 @@ https://bugzilla.mozilla.org/show_bug.cg
 <div id="display">
 
 </div>
 <pre id="test">
 <script type="application/javascript">
 
 /** Test for Bug 435441 **/
 
-function px_to_num(str)
-{
-    return Number(String(str).match(/^([\d.]+)px$/)[1]);
-}
-
-// Run tests simultaneously so we don't have to take up too much time.
-SimpleTest.waitForExplicitFinish();
-var gTestsRunning = 0;
-function TestStarted() { ++gTestsRunning; }
-function TestFinished() { if (--gTestsRunning == 0) SimpleTest.finish(); }
-
-// An array of arrays of functions to be called at the outer index number
-// of seconds after the present.
-var gFutureCalls = [];
-
-function add_future_call(index, func)
-{
-    if (!(index in gFutureCalls)) {
-        gFutureCalls[index] = [];
-    }
-    gFutureCalls[index].push(func);
-    TestStarted();
-}
-var gStartTime1, gStartTime2;
-var gCurrentTime;
-function process_future_calls(index)
-{
-    var calls = gFutureCalls[index];
-    if (!calls)
-        return;
-    gCurrentTime = Date.now();
-    for (var i = 0; i < calls.length; ++i) {
-        calls[i]();
-        TestFinished();
-    }
-}
-
-function bezier(x1, y1, x2, y2) {
-    // Cubic bezier with control points (0, 0), (x1, y1), (x2, y2), and (1, 1).
-    function x_for_t(t) {
-        var omt = 1-t;
-        return 3 * omt * omt * t * x1 + 3 * omt * t * t * x2 + t * t * t;
-    }
-    function y_for_t(t) {
-        var omt = 1-t;
-        return 3 * omt * omt * t * y1 + 3 * omt * t * t * y2 + t * t * t;
-    }
-    function t_for_x(x) {
-        // Binary subdivision.
-        var mint = 0, maxt = 1;
-        for (var i = 0; i < 30; ++i) {
-            var guesst = (mint + maxt) / 2;
-            var guessx = x_for_t(guesst);
-            if (x < guessx)
-                maxt = guesst;
-            else
-                mint = guesst;
-        }
-        return (mint + maxt) / 2;
-    }
-    return function bezier_closure(x) {
-        if (x == 0) return 0;
-        if (x == 1) return 1;
-        return y_for_t(t_for_x(x));
-    }
-}
-
 var timingFunctions = {
   // a map from the value of 'transition-timing-function' to an array of
   // the portions this function yields at 0 (always 0), 1/4, 1/2, and
   // 3/4 and all (always 1) of the way through the time of the
   // transition.  Each portion is represented as a value and an
   // acceptable error tolerance (based on a time error of 1%) for that
   // value.
 
@@ -319,21 +253,17 @@ var display_tests = [ from_none_test, to
 
 // FIXME: Test a transition that reverses partway through.
 
 // flush style changes
 var x = getComputedStyle(div, "").color;
 
 // Start our timer as close as possible to when we start the first
 // transition.
-// Do not use setInterval because once it gets off in time, it stays off.
-for (var i = 1; i <= 8; ++i) {
-    setTimeout(process_future_calls, i * 1000, i);
-}
-gStartTime1 = Date.now(); // set before any transitions have started
+will_start_transitions();
 
 // Start all the transitions.
 for (var test in tftests) {
     var p = tftests[test][0];
     p.style.textIndent = "100px";
 }
 for (var test in interrupt_tests) {
     var p = interrupt_tests[test][0];
@@ -357,75 +287,17 @@ from_none_test.style.textIndent = "100px
 from_none_test.style.display = "";
 to_none_test.style.textIndent = "100px";
 to_none_test.style.display = "none";
 always_none_test.style.textIndent = "100px";
 
 // flush style changes
 x = getComputedStyle(div, "").color;
 
-gStartTime2 = Date.now(); // set after all transitions have started
-gCurrentTime = gStartTime2;
-
-/**
- * Assert that a transition whose timing function yields the bezier
- * |func|, running from |start_time| to |end_time| (both in seconds
- * relative to when the transitions were started) should have produced
- * computed value |cval| given that the transition was from
- * |start_value| to |end_value| (both numbers in CSS pixels).
- */
-function check_transition_value(func, start_time, end_time,
-                                start_value, end_value, cval, desc,
-                                xfail)
-{
-    function value_at(elapsed, error_portion) {
-        var time_portion = (elapsed - start_time) / (end_time - start_time);
-        if (time_portion < 0)
-            time_portion = 0;
-        else if (time_portion > 1)
-            time_portion = 1;
-        var value_portion = func(time_portion) + error_portion;
-        if (value_portion < 0)
-            value_portion = 0;
-        else if (value_portion > 1)
-            value_portion = 1;
-        return (1 - value_portion) * start_value + value_portion * end_value;
-    }
-
-    var time_range; // in seconds
-    var range;
-    if (gCurrentTime == gStartTime2) {
-        // No timers involved
-        time_range = [0, 0];
-        if (start_time < 0) {
-            range = [ value_at(0, -0.01), value_at(0, 0.01) ].
-                        sort(function compareNumbers(a,b) { return a - b; });
-        } else {
-            var val = value_at(0, 0);
-            range = [val, val];
-        }
-    } else {
-        // seconds
-        // FIXME: Why do we need so much tolerance at the low end of the
-        // range (primarily for Mac)?
-        time_range = [ (gCurrentTime - gStartTime2 - 40) / 1000,
-                       (Date.now() - gStartTime1 + 20) / 1000 ];
-        range = [ value_at(time_range[0], -0.01),
-                  value_at(time_range[1], 0.01) ].
-                    sort(function compareNumbers(a,b) { return a - b; });
-    }
-    var actual = px_to_num(cval);
-
-    var fn = xfail ? todo : ok;
-
-    fn(range[0] <= actual && actual <= range[1],
-       desc + ": computed value " + cval + " should be between " +
-       range[0].toFixed(6) + "px and " + range[1].toFixed(6) +
-       "px at time between " + time_range[0] + "s and " + time_range[1] + "s.");
-}
+did_start_transitions();
 
 function check_tf_test()
 {
     for (var test in tftests) {
         var p = tftests[test][0];
         var tf = tftests[test][1];
 
         check_transition_value(timingFunctions[tf], 0, 8, 0, 100,
diff --git a/layout/style/test/test_transitions_per_property.html b/layout/style/test/test_transitions_per_property.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_transitions_per_property.html
@@ -0,0 +1,108 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=435441
+-->
+<head>
+  <title>Test for Bug 435441</title>
+  <script type="application/javascript" src="/MochiKit/packed.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript" src="property_database.js"></script>
+  <script type="application/javascript" src="transitions_common.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+  <style type="text/css">
+
+  #display > p { margin-top: 0; margin-bottom: 0; }
+
+  </style>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=435441">Mozilla Bug 435441</a>
+<div id="display">
+
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 435441 **/
+
+var supported_properties = {
+    "margin-top": [ test_length_transition, test_percent_transition ],
+    "margin-right": [ test_length_transition, test_percent_transition ],
+    "margin-bottom": [ test_length_transition, test_percent_transition ],
+    "margin-left": [ test_length_transition, test_percent_transition ],
+    "padding-top": [ test_length_transition, test_percent_transition ],
+    "padding-right": [ test_length_transition, test_percent_transition ],
+    "padding-bottom": [ test_length_transition, test_percent_transition ],
+    "padding-left": [ test_length_transition, test_percent_transition ],
+    "top": [ test_length_transition, test_percent_transition ],
+    "right": [ test_length_transition, test_percent_transition ],
+    "bottom": [ test_length_transition, test_percent_transition ],
+    "left": [ test_length_transition, test_percent_transition ],
+    "outline-width": [ test_length_transition, test_percent_transition ],
+    "width": [ test_length_transition, test_percent_transition ],
+    "min-width": [ test_length_transition, test_percent_transition ],
+    "max-width": [ test_length_transition, test_percent_transition ],
+    "height": [ test_length_transition, test_percent_transition ],
+    "min-height": [ test_length_transition, test_percent_transition ],
+    "max-height": [ test_length_transition, test_percent_transition ],
+    "vertical-align": [ test_length_transition, test_percent_transition ],
+    "letter-spacing": [ test_length_transition, test_percent_transition ],
+    "line-height": [ test_length_transition, test_percent_transition ],
+    "text-indent": [ test_length_transition, test_percent_transition ],
+    "marker-offset": [ test_length_transition, test_percent_transition ],
+    "-moz-column-width": [ test_length_transition, test_percent_transition ],
+    "-moz-column-gap": [ test_length_transition, test_percent_transition ],
+    "stroke-dashoffset": [ test_length_transition, test_percent_transition ],
+    "stroke-width": [ test_length_transition, test_percent_transition ],
+    "outline-offset": [ test_length_transition ],
+    "word-spacing": [ test_length_transition ]
+};
+
+var prop;
+for (prop in supported_properties) {
+  // Test that prop is in the property database.
+  ok(prop in gCSSProperties, "property " + prop + " in gCSSProperties");
+
+  // Test that the entry has at least one test function.
+  ok(supported_properties[prop].length > 0,
+     "property " + prop + " must have at least one test function");
+}
+
+for (prop in gCSSProperties) {
+  if (!(prop in supported_properties)) {
+    // FIXME: Test that transitions don't do anything.
+  }
+}
+
+will_start_transitions();
+
+for (prop in supported_properties) {
+  // FIXME: Start actual transition tests.
+
+  // Do 4-second transitions, and check once per second.
+}
+
+did_start_transitions();
+
+function test_length_transition() {
+  // FIXME: write me
+}
+
+function test_percent_transition() {
+  // FIXME: write me
+}
+
+function run_tests()
+{
+}
+
+add_future_call(1, run_tests);
+add_future_call(2, run_tests);
+add_future_call(3, run_tests);
+add_future_call(4, run_tests);
+
+</script>
+</pre>
+</body>
+</html>
diff --git a/layout/style/test/transitions_common.js b/layout/style/test/transitions_common.js
new file mode 100644
--- /dev/null
+++ b/layout/style/test/transitions_common.js
@@ -0,0 +1,139 @@
+function px_to_num(str)
+{
+    return Number(String(str).match(/^([\d.]+)px$/)[1]);
+}
+
+// Run tests simultaneously so we don't have to take up too much time.
+SimpleTest.waitForExplicitFinish();
+var gTestsRunning = 0;
+function TestStarted() { ++gTestsRunning; }
+function TestFinished() { if (--gTestsRunning == 0) SimpleTest.finish(); }
+
+// An array of arrays of functions to be called at the outer index number
+// of seconds after the present.
+var gFutureCalls = [];
+
+function add_future_call(index, func)
+{
+    if (!(index in gFutureCalls)) {
+        gFutureCalls[index] = [];
+    }
+    gFutureCalls[index].push(func);
+    TestStarted();
+}
+var gStartTime1, gStartTime2;
+var gCurrentTime;
+function process_future_calls(index)
+{
+    var calls = gFutureCalls[index];
+    if (!calls)
+        return;
+    gCurrentTime = Date.now();
+    for (var i = 0; i < calls.length; ++i) {
+        calls[i]();
+        TestFinished();
+    }
+}
+
+function bezier(x1, y1, x2, y2) {
+    // Cubic bezier with control points (0, 0), (x1, y1), (x2, y2), and (1, 1).
+    function x_for_t(t) {
+        var omt = 1-t;
+        return 3 * omt * omt * t * x1 + 3 * omt * t * t * x2 + t * t * t;
+    }
+    function y_for_t(t) {
+        var omt = 1-t;
+        return 3 * omt * omt * t * y1 + 3 * omt * t * t * y2 + t * t * t;
+    }
+    function t_for_x(x) {
+        // Binary subdivision.
+        var mint = 0, maxt = 1;
+        for (var i = 0; i < 30; ++i) {
+            var guesst = (mint + maxt) / 2;
+            var guessx = x_for_t(guesst);
+            if (x < guessx)
+                maxt = guesst;
+            else
+                mint = guesst;
+        }
+        return (mint + maxt) / 2;
+    }
+    return function bezier_closure(x) {
+        if (x == 0) return 0;
+        if (x == 1) return 1;
+        return y_for_t(t_for_x(x));
+    }
+}
+
+function will_start_transitions()
+{
+    // Do not use setInterval because once it gets off in time, it stays off.
+    for (var i = 1; i <= 8; ++i) {
+        setTimeout(process_future_calls, i * 1000, i);
+    }
+    gStartTime1 = Date.now(); // set before any transitions have started
+}
+
+function did_start_transitions()
+{
+    gStartTime2 = Date.now(); // set after all transitions have started
+    gCurrentTime = gStartTime2;
+}
+
+/**
+ * Assert that a transition whose timing function yields the bezier
+ * |func|, running from |start_time| to |end_time| (both in seconds
+ * relative to when the transitions were started) should have produced
+ * computed value |cval| given that the transition was from
+ * |start_value| to |end_value| (both numbers in CSS pixels).
+ */
+function check_transition_value(func, start_time, end_time,
+                                start_value, end_value, cval, desc,
+                                xfail)
+{
+    function value_at(elapsed, error_portion) {
+        var time_portion = (elapsed - start_time) / (end_time - start_time);
+        if (time_portion < 0)
+            time_portion = 0;
+        else if (time_portion > 1)
+            time_portion = 1;
+        var value_portion = func(time_portion) + error_portion;
+        if (value_portion < 0)
+            value_portion = 0;
+        else if (value_portion > 1)
+            value_portion = 1;
+        return (1 - value_portion) * start_value + value_portion * end_value;
+    }
+
+    var time_range; // in seconds
+    var range;
+    if (gCurrentTime == gStartTime2) {
+        // No timers involved
+        time_range = [0, 0];
+        if (start_time < 0) {
+            range = [ value_at(0, -0.01), value_at(0, 0.01) ].
+                        sort(function compareNumbers(a,b) { return a - b; });
+        } else {
+            var val = value_at(0, 0);
+            range = [val, val];
+        }
+    } else {
+        // seconds
+        // FIXME: Why do we need so much tolerance at the low end of the
+        // range (primarily for Mac)?
+        time_range = [ (gCurrentTime - gStartTime2 - 40) / 1000,
+                       (Date.now() - gStartTime1 + 20) / 1000 ];
+        range = [ value_at(time_range[0], -0.01),
+                  value_at(time_range[1], 0.01) ].
+                    sort(function compareNumbers(a,b) { return a - b; });
+    }
+    var actual = px_to_num(cval);
+
+    var fn = xfail ? todo : ok;
+
+    fn(range[0] <= actual && actual <= range[1],
+       desc + ": computed value " + cval + " should be between " +
+       range[0].toFixed(6) + "px and " + range[1].toFixed(6) +
+       "px at time between " + time_range[0] + "s and " + time_range[1] + "s.");
+}
+
