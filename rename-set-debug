From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::SetDebug to SetXULDebug.  r?dholbert

Written purely with sed, over .h and .cpp files in layout/.

MozReview-Commit-ID: KQYtO7JS2Zm

diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2926,17 +2926,17 @@ public:
 
   bool IsXULHorizontal() const { return (mState & NS_STATE_IS_HORIZONTAL) != 0; }
   bool IsXULNormalDirection() const { return (mState & NS_STATE_IS_DIRECTION_NORMAL) != 0; }
 
   nsresult XULRedraw(nsBoxLayoutState& aState);
   virtual nsresult XULRelayoutChildAtOrdinal(nsIFrame* aChild)=0;
 
 #ifdef DEBUG_LAYOUT
-  virtual nsresult SetDebug(nsBoxLayoutState& aState, bool aDebug)=0;
+  virtual nsresult SetXULDebug(nsBoxLayoutState& aState, bool aDebug)=0;
   virtual nsresult GetDebug(bool& aDebug)=0;
 
   virtual nsresult DumpBox(FILE* out)=0;
 #endif
 
   /**
    * @return true if this text frame ends with a newline character.  It
    * should return false if this is not a text frame.
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -94,21 +94,21 @@ nsBox::DumpBox(FILE* aFile)
 }
 
 void
 nsBox::PropagateDebug(nsBoxLayoutState& aState)
 {
   // propagate debug information
   if (mState & NS_STATE_DEBUG_WAS_SET) {
     if (mState & NS_STATE_SET_TO_DEBUG)
-      SetDebug(aState, true);
+      SetXULDebug(aState, true);
     else
-      SetDebug(aState, false);
+      SetXULDebug(aState, false);
   } else if (mState & NS_STATE_IS_ROOT) {
-    SetDebug(aState, gDebug);
+    SetXULDebug(aState, gDebug);
   }
 }
 #endif
 
 #ifdef DEBUG_LAYOUT
 void
 nsBox::GetBoxName(nsAutoString& aName)
 {
@@ -940,17 +940,17 @@ nsBox::GetNextXULBox(const nsIFrame* aFr
 nsBox::GetParentXULBox(const nsIFrame* aFrame)
 {
   return aFrame->GetParent() &&
     aFrame->GetParent()->IsXULBoxFrame() ? aFrame->GetParent() : nullptr;
 }
 
 #ifdef DEBUG_LAYOUT
 nsresult
-nsBox::SetDebug(nsBoxLayoutState& aState, bool aDebug)
+nsBox::SetXULDebug(nsBoxLayoutState& aState, bool aDebug)
 {
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsBox::GetDebugBoxAt( const nsPoint& aPoint,
                       nsIFrame**     aBox)
 {
diff --git a/layout/xul/nsBox.h b/layout/xul/nsBox.h
--- a/layout/xul/nsBox.h
+++ b/layout/xul/nsBox.h
@@ -39,17 +39,17 @@ public:
   virtual Valignment GetXULVAlign() const override { return vAlign_Top; }
   virtual Halignment GetXULHAlign() const override { return hAlign_Left; }
 
   virtual nsresult XULRelayoutChildAtOrdinal(nsIFrame* aChild) override;
 
 #ifdef DEBUG_LAYOUT
   NS_IMETHOD GetDebugBoxAt(const nsPoint& aPoint, nsIFrame** aBox);
   virtual nsresult GetDebug(bool& aDebug) override;
-  virtual nsresult SetDebug(nsBoxLayoutState& aState, bool aDebug) override;
+  virtual nsresult SetXULDebug(nsBoxLayoutState& aState, bool aDebug) override;
 
   virtual nsresult DumpBox(FILE* out) override;
   void PropagateDebug(nsBoxLayoutState& aState);
 #endif
 
   nsBox();
   virtual ~nsBox();
 
diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -960,17 +960,17 @@ nsBoxFrame::DestroyFrom(nsIFrame* aDestr
   // clean up the container box's layout manager and child boxes
   SetXULLayoutManager(nullptr);
 
   nsContainerFrame::DestroyFrom(aDestructRoot);
 } 
 
 #ifdef DEBUG_LAYOUT
 nsresult
-nsBoxFrame::SetDebug(nsBoxLayoutState& aState, bool aDebug)
+nsBoxFrame::SetXULDebug(nsBoxLayoutState& aState, bool aDebug)
 {
   // see if our state matches the given debug state
   bool debugSet = mState & NS_STATE_CURRENTLY_IN_DEBUG;
   bool debugChanged = (!aDebug && debugSet) || (aDebug && !debugSet);
 
   // if it doesn't then tell each child below us the new debug state
   if (debugChanged)
   {
@@ -1835,17 +1835,17 @@ nsBoxFrame::DisplayDebugInfoFor(nsIFrame
 }
 
 void
 nsBoxFrame::SetDebugOnChildList(nsBoxLayoutState& aState, nsIFrame* aChild, bool aDebug)
 {
     nsIFrame* child = nsBox::GetChildXULBox(this);
      while (child)
      {
-        child->SetDebug(aState, aDebug);
+        child->SetXULDebug(aState, aDebug);
         child = GetNextXULBox(child);
      }
 }
 
 nsresult
 nsBoxFrame::GetFrameSizeWithMargin(nsIFrame* aBox, nsSize& aSize)
 {
   nsRect rect(aBox->GetRect());
diff --git a/layout/xul/nsBoxFrame.h b/layout/xul/nsBoxFrame.h
--- a/layout/xul/nsBoxFrame.h
+++ b/layout/xul/nsBoxFrame.h
@@ -62,17 +62,17 @@ public:
   virtual nsresult XULRelayoutChildAtOrdinal(nsIFrame* aChild) override;
 
   virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetXULFlex() override;
   virtual nscoord GetXULBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
 #ifdef DEBUG_LAYOUT
-  virtual nsresult SetDebug(nsBoxLayoutState& aBoxLayoutState, bool aDebug) override;
+  virtual nsresult SetXULDebug(nsBoxLayoutState& aBoxLayoutState, bool aDebug) override;
   virtual nsresult GetDebug(bool& aDebug) override;
 #endif
   virtual Valignment GetXULVAlign() const override { return mValign; }
   virtual Halignment GetXULHAlign() const override { return mHalign; }
   NS_IMETHOD DoLayout(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual bool ComputesOwnOverflowArea() override { return false; }
 
@@ -215,17 +215,17 @@ protected:
 protected:
     void RegUnregAccessKey(bool aDoReg);
 
   void CheckBoxOrder();
 
 private: 
 
 #ifdef DEBUG_LAYOUT
-    nsresult SetDebug(nsPresContext* aPresContext, bool aDebug);
+    nsresult SetXULDebug(nsPresContext* aPresContext, bool aDebug);
     bool GetInitialDebug(bool& aDebug);
     void GetDebugPref();
 
     void GetDebugBorder(nsMargin& aInset);
     void GetDebugPadding(nsMargin& aInset);
     void GetDebugMargin(nsMargin& aInset);
 
     nsresult GetFrameSizeWithMargin(nsIFrame* aBox, nsSize& aSize);
diff --git a/layout/xul/nsMenuFrame.cpp b/layout/xul/nsMenuFrame.cpp
--- a/layout/xul/nsMenuFrame.cpp
+++ b/layout/xul/nsMenuFrame.cpp
@@ -739,43 +739,43 @@ nsMenuFrame::DoLayout(nsBoxLayoutState& 
     popupFrame->LayoutPopup(aState, this, GetAnchor()->GetPrimaryFrame(), sizeToPopup);
   }
 
   return rv;
 }
 
 #ifdef DEBUG_LAYOUT
 nsresult
-nsMenuFrame::SetDebug(nsBoxLayoutState& aState, bool aDebug)
+nsMenuFrame::SetXULDebug(nsBoxLayoutState& aState, bool aDebug)
 {
   // see if our state matches the given debug state
   bool debugSet = mState & NS_STATE_CURRENTLY_IN_DEBUG;
   bool debugChanged = (!aDebug && debugSet) || (aDebug && !debugSet);
 
   // if it doesn't then tell each child below us the new debug state
   if (debugChanged)
   {
-      nsBoxFrame::SetDebug(aState, aDebug);
+      nsBoxFrame::SetXULDebug(aState, aDebug);
       nsMenuPopupFrame* popupFrame = GetPopup();
       if (popupFrame)
-        SetDebug(aState, popupFrame, aDebug);
+        SetXULDebug(aState, popupFrame, aDebug);
   }
 
   return NS_OK;
 }
 
 nsresult
-nsMenuFrame::SetDebug(nsBoxLayoutState& aState, nsIFrame* aList, bool aDebug)
+nsMenuFrame::SetXULDebug(nsBoxLayoutState& aState, nsIFrame* aList, bool aDebug)
 {
       if (!aList)
           return NS_OK;
 
       while (aList) {
         if (aList->IsXULBoxFrame())
-          aList->SetDebug(aState, aDebug);
+          aList->SetXULDebug(aState, aDebug);
 
         aList = aList->GetNextSibling();
       }
 
       return NS_OK;
 }
 #endif
 
@@ -1291,17 +1291,17 @@ nsMenuFrame::InsertFrames(ChildListID   
                           nsIFrame*       aPrevFrame,
                           nsFrameList&    aFrameList)
 {
   if (!HasPopup() && (aListID == kPrincipalList || aListID == kPopupList)) {
     SetPopupFrame(aFrameList);
     if (HasPopup()) {
 #ifdef DEBUG_LAYOUT
       nsBoxLayoutState state(PresContext());
-      SetDebug(state, aFrameList, mState & NS_STATE_CURRENTLY_IN_DEBUG);
+      SetXULDebug(state, aFrameList, mState & NS_STATE_CURRENTLY_IN_DEBUG);
 #endif
 
       PresContext()->PresShell()->
         FrameNeedsReflow(this, nsIPresShell::eTreeChange,
                          NS_FRAME_HAS_DIRTY_CHILDREN);
     }
   }
 
@@ -1320,17 +1320,17 @@ nsMenuFrame::AppendFrames(ChildListID   
                           nsFrameList&    aFrameList)
 {
   if (!HasPopup() && (aListID == kPrincipalList || aListID == kPopupList)) {
     SetPopupFrame(aFrameList);
     if (HasPopup()) {
 
 #ifdef DEBUG_LAYOUT
       nsBoxLayoutState state(PresContext());
-      SetDebug(state, aFrameList, mState & NS_STATE_CURRENTLY_IN_DEBUG);
+      SetXULDebug(state, aFrameList, mState & NS_STATE_CURRENTLY_IN_DEBUG);
 #endif
       PresContext()->PresShell()->
         FrameNeedsReflow(this, nsIPresShell::eTreeChange,
                          NS_FRAME_HAS_DIRTY_CHILDREN);
     }
   }
 
   if (aFrameList.IsEmpty())
diff --git a/layout/xul/nsMenuFrame.h b/layout/xul/nsMenuFrame.h
--- a/layout/xul/nsMenuFrame.h
+++ b/layout/xul/nsMenuFrame.h
@@ -84,17 +84,17 @@ public:
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual void Init(nsIContent*       aContent,
                     nsContainerFrame* aParent,
                     nsIFrame*         aPrevInFlow) override;
 
 #ifdef DEBUG_LAYOUT
-  virtual nsresult SetDebug(nsBoxLayoutState& aState, bool aDebug) override;
+  virtual nsresult SetXULDebug(nsBoxLayoutState& aState, bool aDebug) override;
 #endif
 
   // The following methods are all overridden so that the menupopup
   // can be stored in a separate list, so that it doesn't impact reflow of the
   // actual menu item at all.
   virtual const nsFrameList& GetChildList(ChildListID aList) const override;
   virtual void GetChildLists(nsTArray<ChildList>* aLists) const override;
   virtual void DestroyFrom(nsIFrame* aDestructRoot) override;
@@ -258,17 +258,17 @@ protected:
   void StartBlinking(mozilla::WidgetGUIEvent* aEvent, bool aFlipChecked);
   void StopBlinking();
   void CreateMenuCommandEvent(mozilla::WidgetGUIEvent* aEvent,
                               bool aFlipChecked);
   void PassMenuCommandEventToPopupManager();
 
 protected:
 #ifdef DEBUG_LAYOUT
-  nsresult SetDebug(nsBoxLayoutState& aState, nsIFrame* aList, bool aDebug);
+  nsresult SetXULDebug(nsBoxLayoutState& aState, nsIFrame* aList, bool aDebug);
 #endif
   nsresult Notify(nsITimer* aTimer);
 
   bool mIsMenu; // Whether or not we can even have children or not.
   bool mChecked;              // are we checked?
   bool mIgnoreAccelTextChange; // temporarily set while determining the accelerator key
   nsMenuType mType;
 
diff --git a/layout/xul/nsSliderFrame.cpp b/layout/xul/nsSliderFrame.cpp
--- a/layout/xul/nsSliderFrame.cpp
+++ b/layout/xul/nsSliderFrame.cpp
@@ -397,19 +397,19 @@ nsSliderFrame::DoLayout(nsBoxLayoutState
     return NS_OK;
   }
 
   EnsureOrient();
 
 #ifdef DEBUG_LAYOUT
   if (mState & NS_STATE_DEBUG_WAS_SET) {
       if (mState & NS_STATE_SET_TO_DEBUG)
-          SetDebug(aState, true);
+          SetXULDebug(aState, true);
       else
-          SetDebug(aState, false);
+          SetXULDebug(aState, false);
   }
 #endif
 
   // get the content area inside our borders
   nsRect clientRect;
   GetXULClientRect(clientRect);
 
   // get the scrollbar
