From: L. David Baron <dbaron@dbaron.org>

Add poisoning for nsRuleData::mValueOffsets.  (Bug 636039, patch 19)

I tested manually that after:
 (a) removing the |ruleData.mValueOffsets[aSID] = 0;| in
     nsRuleNode::WalkRuleTree
 (b) removing the NS_ABORT_IF_FALSE(aRuleData->mValueOffsets[aSID] == 0,
     ...) from nsRuleNode::CheckSpecifiedProperties and
     UnsetPropertiesWithoutFlags
that we crash dereferencing the poison address in a SetCoord call inside
nsRuleNode::ComputeTextResetData

diff --git a/layout/base/nsPresArena.cpp b/layout/base/nsPresArena.cpp
--- a/layout/base/nsPresArena.cpp
+++ b/layout/base/nsPresArena.cpp
@@ -459,8 +459,14 @@ nsPresArena::AllocateByCode(nsQueryFrame
   return mState->Allocate(aCode, aSize);
 }
 
 void
 nsPresArena::FreeByCode(nsQueryFrame::FrameIID aCode, void* aPtr)
 {
   mState->Free(aCode, aPtr);
 }
+
+/* static */ PRUword
+nsPresArena::GetPoisonValue()
+{
+  return ARENA_POISON;
+}
diff --git a/layout/base/nsPresArena.h b/layout/base/nsPresArena.h
--- a/layout/base/nsPresArena.h
+++ b/layout/base/nsPresArena.h
@@ -71,14 +71,23 @@ public:
 
   // Pool allocation with recycler lists indexed by object-type code.
   // Every type code must always be used with the same object size.
   NS_HIDDEN_(void*) AllocateByCode(nsQueryFrame::FrameIID aCode, size_t aSize);
   NS_HIDDEN_(void)  FreeByCode(nsQueryFrame::FrameIID aCode, void* aPtr);
 
   PRUint32 Size();
 
+  /**
+   * Get the poison value that can be used to fill a memory space with
+   * an address that leads to a safe crash when dereferenced.
+   *
+   * The caller is responsible for ensuring that a pres shell has been
+   * initialized before calling this.
+   */
+  static PRUword GetPoisonValue();
+
 private:
   struct State;
   State* mState;
 };
 
 #endif
diff --git a/layout/style/nsRuleData.cpp b/layout/style/nsRuleData.cpp
--- a/layout/style/nsRuleData.cpp
+++ b/layout/style/nsRuleData.cpp
@@ -33,16 +33,59 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsRuleData.h"
 #include "nsCSSProps.h"
+#include "nsPresArena.h"
+
+inline size_t
+nsRuleData::GetPoisonOffset()
+{
+  // Fill in mValueOffsets such that mValueStorage + mValueOffsets[i]
+  // will yield the frame poison value for all uninitialized value
+  // offsets.
+  PR_STATIC_ASSERT(sizeof(PRUword) == sizeof(size_t));
+  PR_STATIC_ASSERT(PRUword(-1) > PRUword(0));
+  PR_STATIC_ASSERT(size_t(-1) > size_t(0));
+  PRUword framePoisonValue = nsPresArena::GetPoisonValue();
+  return size_t(framePoisonValue - PRUword(mValueStorage)) /
+         sizeof(nsCSSValue);
+}
+
+nsRuleData::nsRuleData(PRUint32 aSIDs, nsCSSValue* aValueStorage,
+                       nsPresContext* aContext, nsStyleContext* aStyleContext)
+  : mSIDs(aSIDs),
+    mCanStoreInRuleTree(PR_TRUE),
+    mPresContext(aContext),
+    mStyleContext(aStyleContext),
+    mPostResolveCallback(nsnull),
+    mValueStorage(aValueStorage)
+{
+  size_t framePoisonOffset = GetPoisonOffset();
+  for (size_t i = 0; i < nsStyleStructID_Length; ++i) {
+    mValueOffsets[i] = framePoisonOffset;
+  }
+}
+
+#ifdef DEBUG
+nsRuleData::~nsRuleData()
+{
+  // assert nothing in mSIDs has poison value
+  size_t framePoisonOffset = GetPoisonOffset();
+  for (size_t i = 0; i < nsStyleStructID_Length; ++i) {
+    NS_ABORT_IF_FALSE(!(mSIDs & (1 << i)) ||
+                      mValueOffsets[i] != framePoisonOffset,
+                      "value in SIDs was left with poison offset");
+  }
+}
+#endif
 
 nsCSSValue*
 nsRuleData::ValueFor(nsCSSProperty aProperty)
 {
   NS_ABORT_IF_FALSE(aProperty < eCSSProperty_COUNT_no_shorthands,
                     "invalid or shorthand property");
 
   nsStyleStructID sid = nsCSSProps::kSIDTable[aProperty];
diff --git a/layout/style/nsRuleData.h b/layout/style/nsRuleData.h
--- a/layout/style/nsRuleData.h
+++ b/layout/style/nsRuleData.h
@@ -51,54 +51,46 @@
 class nsPresContext;
 class nsStyleContext;
 struct nsRuleData;
 
 typedef void (*nsPostResolveFunc)(void* aStyleStruct, nsRuleData* aData);
 
 struct nsRuleData
 {
-  PRUint32 mSIDs;
+  const PRUint32 mSIDs;
   PRPackedBool mCanStoreInRuleTree;
   PRPackedBool mIsImportantRule;
   PRUint8 mLevel; // an nsStyleSet::sheetType
-  nsPresContext* mPresContext;
-  nsStyleContext* mStyleContext;
-  nsPostResolveFunc mPostResolveCallback;
+  nsPresContext* const mPresContext;
+  nsStyleContext* const mStyleContext;
+  const nsPostResolveFunc mPostResolveCallback;
 
   // We store nsCSSValues needed to compute the data for one or more
   // style structs (specified by the bitfield mSIDs).  These are stored
   // in a single array allocation (which our caller allocates; see
   // AutoCSSValueArray)   The offset of each property |prop| in
   // mValueStorage is the sum of
   // mValueOffsets[nsCSSProps::kSIDTable[prop]] and
   // nsCSSProps::PropertyIndexInStruct(prop).  The only place we gather
   // more than one style struct's data at a time is
   // nsRuleNode::HasAuthorSpecifiedRules; therefore some code that we
   // know is not called from HasAuthorSpecifiedRules assumes that the
   // mValueOffsets for the one struct in mSIDs is zero.
-  nsCSSValue* mValueStorage; // our user owns this array
+  nsCSSValue* const mValueStorage; // our user owns this array
   size_t mValueOffsets[nsStyleStructID_Length];
 
-  nsRuleData(PRUint32 aSIDs,
-             nsPresContext* aContext,
-             nsStyleContext* aStyleContext)
-    : mSIDs(aSIDs),
-      mCanStoreInRuleTree(PR_TRUE),
-      mPresContext(aContext),
-      mStyleContext(aStyleContext),
-      mPostResolveCallback(nsnull)
-  {
-    // FIXME: fill with poison value?
-  }
-  ~nsRuleData() {
-  #ifdef DEBUG
-    // FIXME: assert nothing in mSIDs has poison value
-  #endif
-  }
+  nsRuleData(PRUint32 aSIDs, nsCSSValue* aValueStorage,
+             nsPresContext* aContext, nsStyleContext* aStyleContext);
+
+#ifdef DEBUG
+  ~nsRuleData();
+#else
+  ~nsRuleData() {}
+#endif
 
   /**
    * Return a pointer to the value object within |this| corresponding
    * to property |aProperty|.
    *
    * This function must only be called if the given property is in
    * mSIDs.
    */
@@ -139,11 +131,14 @@ struct nsRuleData
   #define CSS_PROP_BACKENDONLY(name_, id_, method_, flags_, datastruct_,     \
                                member_, parsevariant_, kwtable_)             \
     /* empty; backend-only structs are not in nsRuleData  */
   #include "nsCSSPropList.h"
   #undef CSS_PROP
   #undef CSS_PROP_DOMPROP_PREFIXED
   #undef CSS_PROP_BACKENDONLY
 
+private:
+  inline size_t GetPoisonOffset();
+
 };
 
 #endif
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -1723,25 +1723,25 @@ private:
   nsCSSValue *mArray;
   size_t mCount;
 };
 
 const void*
 nsRuleNode::WalkRuleTree(const nsStyleStructID aSID,
                          nsStyleContext* aContext)
 {
-  nsRuleData ruleData(nsCachedStyleData::GetBitForSID(aSID),
-                      mPresContext, aContext);
   // use placement new[] on the result of alloca() to allocate a
   // variable-sized stack array, including execution of constructors,
   // and use an RAII class to run the destructors too.
   size_t nprops = nsCSSProps::PropertyCountInStruct(aSID);
   void* dataStorage = alloca(nprops * sizeof(nsCSSValue));
   AutoCSSValueArray dataArray(dataStorage, nprops);
-  ruleData.mValueStorage = dataArray.get();
+
+  nsRuleData ruleData(nsCachedStyleData::GetBitForSID(aSID),
+                      dataArray.get(), mPresContext, aContext);
   ruleData.mValueOffsets[aSID] = 0;
 
   // We start at the most specific rule in the tree.
   void* startStruct = nsnull;
 
   nsRuleNode* ruleNode = this;
   nsRuleNode* highestNode = nsnull; // The highest node in the rule tree
                                     // that has the same properties
@@ -2938,19 +2938,20 @@ nsRuleNode::SetGenericFont(nsPresContext
   // use placement new[] on the result of alloca() to allocate a
   // variable-sized stack array, including execution of constructors,
   // and use an RAII class to run the destructors too.
   size_t nprops = nsCSSProps::PropertyCountInStruct(eStyleStruct_Font);
   void* dataStorage = alloca(nprops * sizeof(nsCSSValue));
 
   for (PRInt32 i = contextPath.Length() - 1; i >= 0; --i) {
     nsStyleContext* context = contextPath[i];
-    nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Font), aPresContext, context);
     AutoCSSValueArray dataArray(dataStorage, nprops);
-    ruleData.mValueStorage = dataArray.get();
+
+    nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Font), dataArray.get(),
+                        aPresContext, context);
     ruleData.mValueOffsets[eStyleStruct_Font] = 0;
 
     // Trimmed down version of ::WalkRuleTree() to re-apply the style rules
     // Note that we *do* need to do this for our own data, since what is
     // in |fontData| in ComputeFontData is only for the rules below
     // aStartStruct.
     for (nsRuleNode* ruleNode = context->GetRuleNode(); ruleNode;
          ruleNode = ruleNode->GetParent()) {
@@ -6478,41 +6479,52 @@ nsRuleNode::HasAuthorSpecifiedRules(nsSt
     inheritBits |= NS_STYLE_INHERIT_BIT(Background);
 
   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BORDER)
     inheritBits |= NS_STYLE_INHERIT_BIT(Border);
 
   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_PADDING)
     inheritBits |= NS_STYLE_INHERIT_BIT(Padding);
 
-  /* We're relying on the use of |aStyleContext| not mutating it! */
-  nsRuleData ruleData(inheritBits,
-                      aStyleContext->PresContext(), aStyleContext);
-
   // properties in the SIDS, whether or not we care about them
-  size_t nprops = 0;
+  size_t nprops = 0, backgroundOffset, borderOffset, paddingOffset;
 
   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BACKGROUND) {
-    ruleData.mValueOffsets[eStyleStruct_Background] = nprops;
+    backgroundOffset = nprops;
     nprops += nsCSSProps::PropertyCountInStruct(eStyleStruct_Background);
   }
 
   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BORDER) {
-    ruleData.mValueOffsets[eStyleStruct_Border] = nprops;
+    borderOffset = nprops;
     nprops += nsCSSProps::PropertyCountInStruct(eStyleStruct_Border);
   }
 
   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_PADDING) {
-    ruleData.mValueOffsets[eStyleStruct_Padding] = nprops;
+    paddingOffset = nprops;
     nprops += nsCSSProps::PropertyCountInStruct(eStyleStruct_Padding);
   }
 
   void* dataStorage = alloca(nprops * sizeof(nsCSSValue));
   AutoCSSValueArray dataArray(dataStorage, nprops);
-  ruleData.mValueStorage = dataArray.get();
+
+  /* We're relying on the use of |aStyleContext| not mutating it! */
+  nsRuleData ruleData(inheritBits, dataArray.get(),
+                      aStyleContext->PresContext(), aStyleContext);
+
+  if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BACKGROUND) {
+    ruleData.mValueOffsets[eStyleStruct_Background] = backgroundOffset;
+  }
+
+  if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BORDER) {
+    ruleData.mValueOffsets[eStyleStruct_Border] = borderOffset;
+  }
+
+  if (ruleTypeMask & NS_AUTHOR_SPECIFIED_PADDING) {
+    ruleData.mValueOffsets[eStyleStruct_Padding] = paddingOffset;
+  }
 
   static const nsCSSProperty backgroundValues[] = {
     eCSSProperty_background_color,
     eCSSProperty_background_image,
   };
 
   static const nsCSSProperty borderValues[] = {
     eCSSProperty_border_top_color,
