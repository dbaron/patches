From: L. David Baron <dbaron@dbaron.org>

Add poisoning for nsRuleData::mValueOffsets.  (Bug 636039, patch 19)

diff --git a/layout/base/nsPresArena.cpp b/layout/base/nsPresArena.cpp
--- a/layout/base/nsPresArena.cpp
+++ b/layout/base/nsPresArena.cpp
@@ -459,8 +459,14 @@ nsPresArena::AllocateByCode(nsQueryFrame
   return mState->Allocate(aCode, aSize);
 }
 
 void
 nsPresArena::FreeByCode(nsQueryFrame::FrameIID aCode, void* aPtr)
 {
   mState->Free(aCode, aPtr);
 }
+
+/* static */ PRUWord
+nsPresArena::GetPoisonValue()
+{
+  return ARENA_POISON;
+}
diff --git a/layout/base/nsPresArena.h b/layout/base/nsPresArena.h
--- a/layout/base/nsPresArena.h
+++ b/layout/base/nsPresArena.h
@@ -71,14 +71,23 @@ public:
 
   // Pool allocation with recycler lists indexed by object-type code.
   // Every type code must always be used with the same object size.
   NS_HIDDEN_(void*) AllocateByCode(nsQueryFrame::FrameIID aCode, size_t aSize);
   NS_HIDDEN_(void)  FreeByCode(nsQueryFrame::FrameIID aCode, void* aPtr);
 
   PRUint32 Size();
 
+  /**
+   * Get the poison value that can be used to fill a memory space with
+   * an address that leads to a safe crash when dereferenced.
+   *
+   * The caller is responsible for ensuring that a pres shell has been
+   * initialized before calling this.
+   */
+  static PRUWord GetPoisonValue();
+
 private:
   struct State;
   State* mState;
 };
 
 #endif
diff --git a/layout/style/nsRuleData.cpp b/layout/style/nsRuleData.cpp
--- a/layout/style/nsRuleData.cpp
+++ b/layout/style/nsRuleData.cpp
@@ -33,16 +33,59 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsRuleData.h"
 #include "nsCSSProps.h"
+#include "nsPresArena.h"
+
+inline size_t
+nsRuleData::GetPoisonOffset()
+{
+  // Fill in mValueOffsets such that mValueStorage + mValueOffsets[i]
+  // will yield the frame poison value for all uninitialized value
+  // offsets.
+  PR_STATIC_ASSERT(sizeof(PRUWord) == sizeof(size_t));
+  PR_STATIC_ASSERT(PRUWord(-1) > PRUWord(0));
+  PR_STATIC_ASSERT(size_t(-1) > size_t(0));
+  PRUWord framePoisonValue = nsPresArena::GetPoisonValue();
+  return size_t(framePoisonValue - PRUWord(mValueStorage)) /
+         sizeof(nsCSSValue);
+}
+
+nsRuleData(PRUint32 aSIDs, nsCSSValue* aValueStorage,
+           nsPresContext* aContext, nsStyleContext* aStyleContext)
+  : mSIDs(aSIDs),
+    mCanStoreInRuleTree(PR_TRUE),
+    mPresContext(aContext),
+    mStyleContext(aStyleContext),
+    mPostResolveCallback(nsnull),
+    mValueStorage(aValueStorage)
+{
+  size_t framePoisonOffset = GetPoisonOffset();
+  for (size_t i = 0; i < nsStyleStructID_Length; ++i) {
+    mValueOffsets[i] = framePoisonOffset;
+  }
+}
+
+#ifdef DEBUG
+nsRuleData::~nsRuleData()
+{
+  // assert nothing in mSIDs has poison value
+  size_t framePoisonOffset = GetPoisonOffset();
+  for (size_t i = 0; i < nsStyleStructID_Length; ++i) {
+    NS_ABORT_IF_FALSE(!(mSIDs & (1 << i)) ||
+                      mValueOffsets[i] != framePoisonOffset;
+                      "value in SIDs was left with poison offset");
+  }
+}
+#endif
 
 nsCSSValue*
 nsRuleData::ValueFor(nsCSSProperty aProperty)
 {
   NS_ABORT_IF_FALSE(aProperty < eCSSProperty_COUNT_no_shorthands,
                     "invalid or shorthand property");
 
   nsStyleStructID sid = nsCSSProps::kSIDTable[aProperty];
diff --git a/layout/style/nsRuleData.h b/layout/style/nsRuleData.h
--- a/layout/style/nsRuleData.h
+++ b/layout/style/nsRuleData.h
@@ -51,54 +51,46 @@
 class nsPresContext;
 class nsStyleContext;
 struct nsRuleData;
 
 typedef void (*nsPostResolveFunc)(void* aStyleStruct, nsRuleData* aData);
 
 struct nsRuleData
 {
-  PRUint32 mSIDs;
+  const PRUint32 mSIDs;
   PRPackedBool mCanStoreInRuleTree;
   PRPackedBool mIsImportantRule;
   PRUint8 mLevel; // an nsStyleSet::sheetType
-  nsPresContext* mPresContext;
-  nsStyleContext* mStyleContext;
-  nsPostResolveFunc mPostResolveCallback;
+  nsPresContext* const mPresContext;
+  nsStyleContext* const mStyleContext;
+  const nsPostResolveFunc mPostResolveCallback;
 
   // We store nsCSSValues needed to compute the data for one or more
   // style structs (specified by the bitfield mSIDs).  These are stored
   // in a single array allocation (which our caller allocates; see
   // AutoCSSValueArray)   The offset of each property |prop| in
   // mValueStorage is the sum of
   // mValueOffsets[nsCSSProps::kSIDTable[prop]] and
   // nsCSSProps::PropertyIndexInStruct(prop).  The only place we gather
   // more than one style struct's data at a time is
   // nsRuleNode::HasAuthorSpecifiedRules; therefore some code that we
   // know is not called from HasAuthorSpecifiedRules assumes that the
   // mValueOffsets for the one struct in mSIDs is zero.
-  nsCSSValue* mValueStorage; // our user owns this array
+  nsCSSValue* const mValueStorage; // our user owns this array
   size_t mValueOffsets[nsStyleStructID_Length];
 
-  nsRuleData(PRUint32 aSIDs,
-             nsPresContext* aContext,
-             nsStyleContext* aStyleContext)
-    : mSIDs(aSIDs),
-      mCanStoreInRuleTree(PR_TRUE),
-      mPresContext(aContext),
-      mStyleContext(aStyleContext),
-      mPostResolveCallback(nsnull)
-  {
-    // FIXME: fill with poison value?
-  }
-  ~nsRuleData() {
-  #ifdef DEBUG
-    // FIXME: assert nothing in mSIDs has poison value
-  #endif
-  }
+  nsRuleData(PRUint32 aSIDs, nsCSSValue* aValueStorage,
+             nsPresContext* aContext, nsStyleContext* aStyleContext);
+
+#ifdef DEBUG
+  ~nsRuleData() {}
+#else
+  ~nsRuleData();
+#endif
 
   /**
    * Return a pointer to the value object within |this| corresponding
    * to property |aProperty|.
    *
    * This function must only be called if the given property is in
    * mSIDs.
    */
@@ -139,11 +131,14 @@ struct nsRuleData
   #define CSS_PROP_BACKENDONLY(name_, id_, method_, flags_, datastruct_,     \
                                member_, parsevariant_, kwtable_)             \
     /* empty; backend-only structs are not in nsRuleData  */
   #include "nsCSSPropList.h"
   #undef CSS_PROP
   #undef CSS_PROP_DOMPROP_PREFIXED
   #undef CSS_PROP_BACKENDONLY
 
+private:
+  inline size_t GetPoisonOffset();
+
 };
 
 #endif
