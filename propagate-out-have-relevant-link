From: L. David Baron <dbaron@dbaron.org>

Propagate whether we have a relevant link out of selector matching.  (Bug 147777)

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1221,18 +1221,23 @@ RuleProcessorData::GetNthIndex(PRBool aI
  * contains both input to and output from the matching.
  */
 struct TreeMatchContext {
   // Is this matching operation for the creation of a style context?
   // (If it is, we need to set slow selector bits on nodes indicating
   // that certain restyling needs to happen.)
   const PRBool mForStyling;
 
+  // Did this matching operation find a relevant link?  (If so, we'll
+  // need to construct a StyleIfVisited.)
+  PRBool mHaveRelevantLink;
+
   TreeMatchContext(PRBool aForStyling)
     : mForStyling(aForStyling)
+    , mHaveRelevantLink(PR_FALSE)
   {
   }
 };
 
 /**
  * A |NodeMatchContext| has data about matching a selector (without
  * combinators) against a single node.  It contains only input to the
  * matching.
@@ -1251,18 +1256,30 @@ struct NodeMatchContext {
   // NOTE: For |aStateMask| to work correctly, it's important that any
   // change that changes multiple state bits include all those state
   // bits in the notification.  Otherwise, if multiple states change but
   // we do separate notifications then we might determine the style is
   // not state-dependent when it really is (e.g., determining that a
   // :hover:active rule no longer matches when both states are unset).
   const PRInt32 mStateMask;
 
-  NodeMatchContext(PRInt32 aStateMask)
+  // Is this link the unique link whose visitedness can affect the style
+  // of the node being matched?  (That link is the nearest link to the
+  // node being matched that is itself or an ancestor.)
+  //
+  // Always false when TreeMatchContext::mForStyling is false.  (We
+  // could figure it out for SelectorListMatches, but we're starting
+  // from the middle of the selector list when doing
+  // Has{Attribute,State}DependentStyle, so we can't tell.  So when
+  // mForStyling is false, we have to assume we don't know.)
+  const PRBool mIsRelevantLink;
+
+  NodeMatchContext(PRInt32 aStateMask, PRBool aIsRelevantLink)
     : mStateMask(aStateMask)
+    , mIsRelevantLink(aIsRelevantLink)
   {
   }
 };
 
 static PRBool ValueIncludes(const nsSubstring& aValueList,
                             const nsSubstring& aValue,
                             const nsStringComparator& aComparator)
 {
@@ -2094,17 +2111,18 @@ static PRBool SelectorMatches(RuleProces
 //   ' ', the descendant combinator, is greedy
 //   '~', the indirect adjacent sibling combinator, is greedy
 //   '+' and '>', the direct adjacent sibling and child combinators, are not
 #define NS_IS_GREEDY_OPERATOR(ch) \
   ((ch) == PRUnichar(' ') || (ch) == PRUnichar('~'))
 
 static PRBool SelectorMatchesTree(RuleProcessorData& aPrevData,
                                   nsCSSSelector* aSelector,
-                                  TreeMatchContext& aTreeMatchContext)
+                                  TreeMatchContext& aTreeMatchContext,
+                                  PRBool aLookForRelevantLink)
 {
   nsCSSSelector* selector = aSelector;
   RuleProcessorData* prevdata = &aPrevData;
   while (selector) { // check compound selectors
     NS_ASSERTION(!selector->mNext ||
                  selector->mNext->mOperator != PRUnichar(0),
                  "compound selector without combinator");
 
@@ -2112,16 +2130,18 @@ static PRBool SelectorMatchesTree(RulePr
     // appropriate content (whether parent or previous sibling), create
     // one.
 
     // for adjacent sibling combinators, the content to test against the
     // selector is the previous sibling *element*
     RuleProcessorData* data;
     if (PRUnichar('+') == selector->mOperator ||
         PRUnichar('~') == selector->mOperator) {
+      // The relevant link must be an ancestor of the node being matched.
+      aLookForRelevantLink = PR_FALSE;
       data = prevdata->mPreviousSiblingData;
       if (!data) {
         nsIContent* content = prevdata->mContent;
         nsIContent* parent = prevdata->mParentContent;
         if (parent) {
           if (aTreeMatchContext.mForStyling)
             parent->SetFlags(NODE_HAS_SLOW_SELECTOR_NOAPPEND);
 
@@ -2153,17 +2173,28 @@ static PRBool SelectorMatchesTree(RulePr
                                            prevdata->mCompatMode);
           prevdata->mParentData = data;
         }
       }
     }
     if (! data) {
       return PR_FALSE;
     }
-    NodeMatchContext nodeContext(0);
+    NodeMatchContext nodeContext(0, aLookForRelevantLink && data->IsLink());
+    if (nodeContext.mIsRelevantLink) {
+      // If we find an ancestor of the matched node that is a link
+      // during the matching process, then it's the relevant link (see
+      // constructor call above).
+      // Since we are still matching against selectors that contain
+      // :visited (they'll just fail), we will always find such a node
+      // during the selector matching process if there is a relevant
+      // link that can influence selector matching.
+      aLookForRelevantLink = PR_FALSE;
+      aTreeMatchContext.mHaveRelevantLink = PR_TRUE;
+    }
     if (SelectorMatches(*data, selector, nodeContext, aTreeMatchContext)) {
       // to avoid greedy matching, we need to recur if this is a
       // descendant or general sibling combinator and the next
       // combinator is different, but we can make an exception for
       // sibling, then parent, since a sibling's parent is always the
       // same.
       if (NS_IS_GREEDY_OPERATOR(selector->mOperator) &&
           selector->mNext &&
@@ -2174,17 +2205,18 @@ static PRBool SelectorMatchesTree(RulePr
 
         // pretend the selector didn't match, and step through content
         // while testing the same selector
 
         // This approach is slightly strange in that when it recurs
         // it tests from the top of the content tree, down.  This
         // doesn't matter much for performance since most selectors
         // don't match.  (If most did, it might be faster...)
-        if (SelectorMatchesTree(*data, selector, aTreeMatchContext)) {
+        if (SelectorMatchesTree(*data, selector, aTreeMatchContext,
+                                aLookForRelevantLink)) {
           return PR_TRUE;
         }
       }
       selector = selector->mNext;
     }
     else {
       // for adjacent sibling and child combinators, if we didn't find
       // a match, we're done
@@ -2198,20 +2230,24 @@ static PRBool SelectorMatchesTree(RulePr
 }
 
 static void ContentEnumFunc(nsICSSStyleRule* aRule, nsCSSSelector* aSelector,
                             void* aData)
 {
   RuleProcessorData* data = (RuleProcessorData*)aData;
 
   TreeMatchContext treeContext(PR_TRUE);
-  NodeMatchContext nodeContext(0);
+  NodeMatchContext nodeContext(0, data->IsLink());
+  if (nodeContext.mIsRelevantLink) {
+    treeContext.mHaveRelevantLink = PR_TRUE;
+  }
   if (SelectorMatches(*data, aSelector, nodeContext, treeContext)) {
     nsCSSSelector *next = aSelector->mNext;
-    if (!next || SelectorMatchesTree(*data, next, treeContext)) {
+    if (!next || SelectorMatchesTree(*data, next, treeContext,
+                                     !nodeContext.mIsRelevantLink)) {
       // for performance, require that every implementation of
       // nsICSSStyleRule return the same pointer for nsIStyleRule (why
       // would anything multiply inherit nsIStyleRule anyway?)
 #ifdef DEBUG
       nsCOMPtr<nsIStyleRule> iRule = do_QueryInterface(aRule);
       NS_ASSERTION(static_cast<nsIStyleRule*>(aRule) == iRule.get(),
                    "Please fix QI so this performance optimization is valid");
 #endif
@@ -2350,20 +2386,21 @@ nsCSSRuleProcessor::HasStateDependentSty
 
       nsRestyleHint possibleChange = IsSiblingOperator(selector->mOperator) ?
         eRestyle_LaterSiblings : eRestyle_Self;
 
       // If hint already includes all the bits of possibleChange,
       // don't bother calling SelectorMatches, since even if it returns false
       // hint won't change.
       TreeMatchContext treeContext(PR_FALSE);
-      NodeMatchContext nodeContext(aData->mStateMask);
+      NodeMatchContext nodeContext(aData->mStateMask, PR_FALSE);
       if ((possibleChange & ~hint) &&
           SelectorMatches(*aData, selector, nodeContext, treeContext) &&
-          SelectorMatchesTree(*aData, selector->mNext, treeContext)) {
+          SelectorMatchesTree(*aData, selector->mNext, treeContext, PR_FALSE))
+      {
         hint = nsRestyleHint(hint | possibleChange);
       }
     }
   }
   return hint;
 }
 
 PRBool
@@ -2390,20 +2427,20 @@ AttributeEnumFunc(nsCSSSelector* aSelect
 
   nsRestyleHint possibleChange = IsSiblingOperator(aSelector->mOperator) ?
     eRestyle_LaterSiblings : eRestyle_Self;
 
   // If enumData->change already includes all the bits of possibleChange, don't
   // bother calling SelectorMatches, since even if it returns false
   // enumData->change won't change.
   TreeMatchContext treeContext(PR_FALSE);
-  NodeMatchContext nodeContext(0);
+  NodeMatchContext nodeContext(0, PR_FALSE);
   if ((possibleChange & ~(aData->change)) &&
       SelectorMatches(*data, aSelector, nodeContext, treeContext) &&
-      SelectorMatchesTree(*data, aSelector->mNext, treeContext)) {
+      SelectorMatchesTree(*data, aSelector->mNext, treeContext, PR_FALSE)) {
     aData->change = nsRestyleHint(aData->change | possibleChange);
   }
 }
 
 nsRestyleHint
 nsCSSRuleProcessor::HasAttributeDependentStyle(AttributeRuleProcessorData* aData)
 {
   NS_PRECONDITION(aData->mContent->IsNodeOfType(nsINode::eELEMENT),
@@ -2935,20 +2972,20 @@ nsCSSRuleProcessor::RefreshRuleCascade(n
 nsCSSRuleProcessor::SelectorListMatches(RuleProcessorData& aData,
                                         nsCSSSelectorList* aSelectorList)
 {
   while (aSelectorList) {
     nsCSSSelector* sel = aSelectorList->mSelectors;
     NS_ASSERTION(sel, "Should have *some* selectors");
     NS_ASSERTION(!sel->IsPseudoElement(), "Shouldn't have been called");
     TreeMatchContext treeContext(PR_FALSE);
-    NodeMatchContext nodeContext(0);
+    NodeMatchContext nodeContext(0, PR_FALSE);
     if (SelectorMatches(aData, sel, nodeContext, treeContext)) {
       nsCSSSelector* next = sel->mNext;
-      if (!next || SelectorMatchesTree(aData, next, treeContext)) {
+      if (!next || SelectorMatchesTree(aData, next, treeContext, PR_FALSE)) {
         return PR_TRUE;
       }
     }
 
     aSelectorList = aSelectorList->mNext;
   }
 
   return PR_FALSE;
