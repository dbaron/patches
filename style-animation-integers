From: L. David Baron <dbaron@dbaron.org>

Add support for interpolation of integer-valued properties (i.e., z-index) to nsStyleAnimation.  (Bug 524808)  r=dholbert

diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -2569,19 +2569,18 @@ CSS_PROP_POSITION(
     z-index,
     z_index,
     ZIndex,
     0,
     Position,
     mZIndex,
     eCSSType_Value,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
-
+    offsetof(nsStylePosition, mZIndex),
+    eStyleAnimType_Coord)
 CSS_PROP_XUL(
     -moz-box-align,
     box_align,
     MozBoxAlign,
     0,
     XUL,
     mBoxAlign,
     eCSSType_Value,
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -125,16 +125,22 @@ nsStyleAnimation::ComputeDistance(const 
 
   PRBool success = PR_TRUE;
   switch (commonUnit) {
     case eUnit_Null:
     case eUnit_None:
     case eUnit_Enumerated:
       success = PR_FALSE;
       break;
+    case eUnit_Integer: {
+      PRInt32 startInt = aStartValue.GetIntValue();
+      PRInt32 endInt = aEndValue.GetIntValue();
+      aDistance = PR_ABS(endInt - startInt);
+      break;
+    }
     case eUnit_Coord: {
       nscoord startCoord = aStartValue.GetCoordValue();
       nscoord endCoord = aEndValue.GetCoordValue();
       aDistance = fabs(double(endCoord - startCoord));
       break;
     }
     case eUnit_Percent: {
       float startPct = aStartValue.GetPercentValue();
@@ -429,16 +435,25 @@ nsStyleAnimation::AddWeighted(double aCo
 
   PRBool success = PR_TRUE;
   switch (commonUnit) {
     case eUnit_Null:
     case eUnit_None:
     case eUnit_Enumerated:
       success = PR_FALSE;
       break;
+    case eUnit_Integer: {
+      // http://dev.w3.org/csswg/css3-transitions/#animation-of-property-types-
+      // says we should use floor
+      aResultValue.SetIntValue(NS_floor(
+          aCoeff1 * double(aValue1.GetIntValue()) +
+          aCoeff2 * double(aValue2.GetIntValue())),
+        eUnit_Integer);
+      break;
+    }
     case eUnit_Coord: {
       aResultValue.SetCoordValue(NSToCoordRound(
         aCoeff1 * aValue1.GetCoordValue() +
         aCoeff2 * aValue2.GetCoordValue()));
       break;
     }
     case eUnit_Percent: {
       aResultValue.SetPercentValue(
@@ -756,16 +771,22 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
       }
       break;
     case eUnit_Enumerated:
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
                         "type mismatch");
       static_cast<nsCSSValue*>(aSpecifiedValue)->
         SetIntValue(aComputedValue.GetIntValue(), eCSSUnit_Enumerated);
       break;
+    case eUnit_Integer:
+      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
+                        "type mismatch");
+      static_cast<nsCSSValue*>(aSpecifiedValue)->
+        SetIntValue(aComputedValue.GetIntValue(), eCSSUnit_Integer);
+      break;
     case eUnit_Coord: {
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
                         "type mismatch");
       float pxVal = aPresContext->AppUnitsToFloatCSSPixels(
                                     aComputedValue.GetCoordValue());
       static_cast<nsCSSValue*>(aSpecifiedValue)->
         SetFloatValue(pxVal, eCSSUnit_Pixel);
       break;
@@ -908,18 +929,21 @@ StyleCoordToValue(const nsStyleCoord& aC
       aValue.SetFloatValue(aCoord.GetFactorValue());
       break;
     case eStyleUnit_Coord:
       aValue.SetCoordValue(aCoord.GetCoordValue());
       break;
     case eStyleUnit_Enumerated:
       aValue.SetIntValue(aCoord.GetIntValue(),
                          nsStyleAnimation::eUnit_Enumerated);
+      break;
     case eStyleUnit_Integer:
-      return PR_FALSE;
+      aValue.SetIntValue(aCoord.GetIntValue(),
+                         nsStyleAnimation::eUnit_Integer);
+      break;
   }
   return PR_TRUE;
 }
 
 static void
 StyleCoordToCSSValue(const nsStyleCoord& aCoord, nsCSSValue& aCSSValue)
 {
   switch (aCoord.GetUnit()) {
@@ -1189,19 +1213,21 @@ nsStyleAnimation::ExtractComputedValue(n
       return PR_TRUE;
     }
     case eStyleAnimType_None:
       NS_NOTREACHED("shouldn't use on non-animatable properties");
   }
   return PR_FALSE;
 }
 
-nsStyleAnimation::Value::Value(PRInt32 aInt, EnumeratedConstructorType)
+nsStyleAnimation::Value::Value(PRInt32 aInt, Unit aUnit,
+                               IntegerConstructorType)
 {
-  mUnit = eUnit_Enumerated;
+  NS_ASSERTION(IsIntUnit(aUnit), "unit must be of integer type");
+  mUnit = aUnit;
   mValue.mInt = aInt;
 }
 
 nsStyleAnimation::Value::Value(nscoord aLength, CoordConstructorType)
 {
   mUnit = eUnit_Coord;
   mValue.mCoord = aLength;
 }
@@ -1232,16 +1258,17 @@ nsStyleAnimation::Value::operator=(const
   mUnit = aOther.mUnit;
   switch (mUnit) {
     case eUnit_Null:
     case eUnit_Normal:
     case eUnit_Auto:
     case eUnit_None:
       break;
     case eUnit_Enumerated:
+    case eUnit_Integer:
       mValue.mInt = aOther.mValue.mInt;
       break;
     case eUnit_Coord:
       mValue.mCoord = aOther.mValue.mCoord;
       break;
     case eUnit_Percent:
     case eUnit_Float:
       mValue.mFloat = aOther.mValue.mFloat;
@@ -1291,16 +1318,17 @@ nsStyleAnimation::Value::SetNoneValue()
 {
   FreeValue();
   mUnit = eUnit_None;
 }
 
 void
 nsStyleAnimation::Value::SetIntValue(PRInt32 aInt, Unit aUnit)
 {
+  NS_ASSERTION(IsIntUnit(aUnit), "unit must be of integer type");
   FreeValue();
   mUnit = aUnit;
   mValue.mInt = aInt;
 }
 
 void
 nsStyleAnimation::Value::SetCoordValue(nscoord aLength)
 {
@@ -1386,16 +1414,17 @@ nsStyleAnimation::Value::operator==(cons
 
   switch (mUnit) {
     case eUnit_Null:
     case eUnit_Normal:
     case eUnit_Auto:
     case eUnit_None:
       return PR_TRUE;
     case eUnit_Enumerated:
+    case eUnit_Integer:
       return mValue.mInt == aOther.mValue.mInt;
     case eUnit_Coord:
       return mValue.mCoord == aOther.mValue.mCoord;
     case eUnit_Percent:
     case eUnit_Float:
       return mValue.mFloat == aOther.mValue.mFloat;
     case eUnit_Color:
       return mValue.mColor == aOther.mValue.mColor;
diff --git a/layout/style/nsStyleAnimation.h b/layout/style/nsStyleAnimation.h
--- a/layout/style/nsStyleAnimation.h
+++ b/layout/style/nsStyleAnimation.h
@@ -218,16 +218,17 @@ public:
    * The types and values for the values that we extract and animate.
    */
   enum Unit {
     eUnit_Null, // not initialized
     eUnit_Normal,
     eUnit_Auto,
     eUnit_None,
     eUnit_Enumerated,
+    eUnit_Integer,
     eUnit_Coord,
     eUnit_Percent,
     eUnit_Float,
     eUnit_Color,
     eUnit_BorderCorner, // nsCSSValuePair* (never null)
     eUnit_Dasharray, // nsCSSValueList* (never null)
     eUnit_Shadow  // nsCSSValueList* (may be null)
   };
@@ -251,17 +252,17 @@ public:
 
     // Accessor to let us verify assumptions about presence of null unit,
     // without tripping the assertion in GetUnit().
     PRBool IsNull() const {
       return mUnit == eUnit_Null;
     }
 
     PRInt32 GetIntValue() const {
-      NS_ASSERTION(mUnit == eUnit_Enumerated, "unit mismatch");
+      NS_ASSERTION(IsIntUnit(mUnit), "unit mismatch");
       return mValue.mInt;
     }
     nscoord GetCoordValue() const {
       NS_ASSERTION(mUnit == eUnit_Coord, "unit mismatch");
       return mValue.mCoord;
     }
     float GetPercentValue() const {
       NS_ASSERTION(mUnit == eUnit_Percent, "unit mismatch");
@@ -285,18 +286,18 @@ public:
     }
 
     explicit Value(Unit aUnit = eUnit_Null) : mUnit(aUnit) {
       NS_ASSERTION(aUnit == eUnit_Null || aUnit == eUnit_Normal ||
                    aUnit == eUnit_Auto || aUnit == eUnit_None,
                    "must be valueless unit");
     }
     Value(const Value& aOther) : mUnit(eUnit_Null) { *this = aOther; }
-    enum EnumeratedConstructorType { EnumeratedConstructor };
-    Value(PRInt32 aInt, EnumeratedConstructorType);
+    enum IntegerConstructorType { IntegerConstructor };
+    Value(PRInt32 aInt, Unit aUnit, IntegerConstructorType);
     enum CoordConstructorType { CoordConstructor };
     Value(nscoord aLength, CoordConstructorType);
     enum PercentConstructorType { PercentConstructor };
     Value(float aPercent, PercentConstructorType);
     enum FloatConstructorType { FloatConstructor };
     Value(float aFloat, FloatConstructorType);
     enum ColorConstructorType { ColorConstructor };
     Value(nscolor aColor, ColorConstructorType);
@@ -320,16 +321,19 @@ public:
 
     PRBool operator==(const Value& aOther) const;
     PRBool operator!=(const Value& aOther) const
       { return !(*this == aOther); }
 
   private:
     void FreeValue();
 
+    static PRBool IsIntUnit(Unit aUnit) {
+      return aUnit == eUnit_Enumerated || aUnit == eUnit_Integer;
+    }
     static PRBool IsCSSValuePairUnit(Unit aUnit) {
       return aUnit == eUnit_BorderCorner;
     }
     static PRBool IsCSSValueListUnit(Unit aUnit) {
       return aUnit == eUnit_Dasharray || aUnit == eUnit_Shadow;
     }
   };
 };
diff --git a/layout/style/test/test_transitions_per_property.html b/layout/style/test/test_transitions_per_property.html
--- a/layout/style/test/test_transitions_per_property.html
+++ b/layout/style/test/test_transitions_per_property.html
@@ -109,16 +109,17 @@ var supported_properties = {
     "stroke-opacity" : [ test_float_zeroToOne_transition ],
     "stroke-width": [ test_length_transition, test_percent_transition ],
     "text-indent": [ test_length_transition, test_percent_transition ],
     "text-shadow": [ test_shadow_transition ],
     "top": [ test_length_transition, test_percent_transition ],
     "vertical-align": [ test_length_transition, test_percent_transition ],
     "width": [ test_length_transition, test_percent_transition ],
     "word-spacing": [ test_length_transition ],
+    "z-index": [ test_zindex_transition ],
 };
 
 var div = document.getElementById("display");
 var cs = getComputedStyle(div, "");
 
 var prop;
 for (prop in supported_properties) {
   // Test that prop is in the property database.
@@ -405,12 +406,32 @@ function test_radius_transition(prop) {
      "radius-valued property " + prop + ": interpolation of radius");
 
   div.style.removeProperty("width");
   div.style.removeProperty("height");
   div.style.removeProperty("border");
   div.style.removeProperty("padding");
 }
 
+function test_zindex_transition(prop) {
+  div.style.setProperty("-moz-transition-property", "none", "");
+  div.style.setProperty(prop, "4", "");
+  is(cs.getPropertyValue(prop), "4",
+     "integer-valued property " + prop + ": computed value before transition");
+  div.style.setProperty("-moz-transition-property", prop, "");
+  div.style.setProperty(prop, "-5", "");
+  is(cs.getPropertyValue(prop), "-1",
+     "integer-valued property " + prop + ": interpolation of lengths");
+  div.style.setProperty(prop, "auto", "");
+  is(cs.getPropertyValue(prop), "auto",
+     "integer-valued property " + prop + ": auto not interpolable");
+  div.style.setProperty(prop, "-4", "");
+  is(cs.getPropertyValue(prop), "-4",
+     "integer-valued property " + prop + ": computed value before transition");
+  div.style.setProperty(prop, "8", "");
+  is(cs.getPropertyValue(prop), "2",
+     "integer-valued property " + prop + ": interpolation of lengths");
+}
+
 </script>
 </pre>
 </body>
 </html>
