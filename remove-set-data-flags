From: L. David Baron <dbaron@dbaron.org>

Bug 1343715 - Remove nsA[C]String::SetDataFlags.  r=dmajor

MozReview-Commit-ID: EDQbH9pZKtZ

diff --git a/xpcom/string/nsTDependentString.cpp b/xpcom/string/nsTDependentString.cpp
--- a/xpcom/string/nsTDependentString.cpp
+++ b/xpcom/string/nsTDependentString.cpp
@@ -24,18 +24,17 @@ nsTDependentString_CharT::Rebind(const s
   size_type strLength = str.Length();
 
   if (startPos > strLength) {
     startPos = strLength;
   }
 
   mData = const_cast<char_type*>(static_cast<const char_type*>(str.Data())) + startPos;
   mLength = strLength - startPos;
-
-  SetDataFlags(str.GetDataFlags() & (DataFlags::TERMINATED | DataFlags::LITERAL));
+  mDataFlags = str.GetDataFlags() & (DataFlags::TERMINATED | DataFlags::LITERAL);
 }
 
 void
 nsTDependentString_CharT::Rebind(const char_type* aStart, const char_type* aEnd)
 {
   MOZ_RELEASE_ASSERT(aStart <= aEnd, "Overflow!");
   Rebind(aStart, uint32_t(aEnd - aStart));
 }
diff --git a/xpcom/string/nsTDependentSubstring.cpp b/xpcom/string/nsTDependentSubstring.cpp
--- a/xpcom/string/nsTDependentSubstring.cpp
+++ b/xpcom/string/nsTDependentSubstring.cpp
@@ -14,31 +14,30 @@ nsTDependentSubstring_CharT::Rebind(cons
   size_type strLength = str.Length();
 
   if (startPos > strLength) {
     startPos = strLength;
   }
 
   mData = const_cast<char_type*>(static_cast<const char_type*>(str.Data())) + startPos;
   mLength = XPCOM_MIN(length, strLength - startPos);
-
-  SetDataFlags(DataFlags(0));
+  mDataFlags = DataFlags(0);
 }
 
 void
 nsTDependentSubstring_CharT::Rebind(const char_type* data, size_type length)
 {
   NS_ASSERTION(data, "nsTDependentSubstring must wrap a non-NULL buffer");
 
   // If we currently own a buffer, release it.
   Finalize();
 
   mData = const_cast<char_type*>(static_cast<const char_type*>(data));
   mLength = length;
-  SetDataFlags(DataFlags(0));
+  mDataFlags = DataFlags(0);
 }
 
 void
 nsTDependentSubstring_CharT::Rebind(const char_type* aStart, const char_type* aEnd)
 {
   MOZ_RELEASE_ASSERT(aStart <= aEnd, "Overflow!");
   Rebind(aStart, size_type(aEnd - aStart));
 }
diff --git a/xpcom/string/nsTString.cpp b/xpcom/string/nsTString.cpp
--- a/xpcom/string/nsTString.cpp
+++ b/xpcom/string/nsTString.cpp
@@ -15,17 +15,17 @@ nsTAdoptingString_CharT::operator=(const
     // We want to do what Adopt() does, but without actually incrementing
     // the Adopt count.  Note that we can be a little more straightforward
     // about this than Adopt() is, because we know that str.mData is
     // non-null.  Should we be able to assert that str is not void here?
     NS_ASSERTION(str.mData, "String with null mData?");
     Finalize();
     mData = str.mData;
     mLength = str.mLength;
-    SetDataFlags(DataFlags::TERMINATED | DataFlags::OWNED);
+    mDataFlags = DataFlags::TERMINATED | DataFlags::OWNED;
 
     // Make str forget the buffer we just took ownership of.
     new (mutable_str) self_type();
   } else {
     Assign(str);
 
     mutable_str->Truncate();
   }
@@ -36,12 +36,12 @@ nsTAdoptingString_CharT::operator=(const
 void
 nsTString_CharT::Rebind(const char_type* data, size_type length)
 {
   // If we currently own a buffer, release it.
   Finalize();
 
   mData = const_cast<char_type*>(data);
   mLength = length;
-  SetDataFlags(DataFlags::TERMINATED);
+  mDataFlags = DataFlags::TERMINATED;
   AssertValidDependentString();
 }
 
diff --git a/xpcom/string/nsTSubstring.cpp b/xpcom/string/nsTSubstring.cpp
--- a/xpcom/string/nsTSubstring.cpp
+++ b/xpcom/string/nsTSubstring.cpp
@@ -165,17 +165,17 @@ nsTSubstring_CharT::MutatePrep(size_type
     newDataFlags = DataFlags::TERMINATED | DataFlags::SHARED;
   }
 
   // save old data and flags
   *aOldData = mData;
   *aOldDataFlags = mDataFlags;
 
   mData = newData;
-  SetDataFlags(newDataFlags);
+  mDataFlags = newDataFlags;
 
   // mLength does not change
 
   // though we are not necessarily terminated at the moment, now is probably
   // still the best time to set DataFlags::TERMINATED.
 
   return true;
 }
@@ -408,17 +408,17 @@ nsTSubstring_CharT::AssignASCII(const ch
 }
 
 void
 nsTSubstring_CharT::AssignLiteral(const char_type* aData, size_type aLength)
 {
   ::ReleaseData(mData, mDataFlags);
   mData = const_cast<char_type*>(aData);
   mLength = aLength;
-  SetDataFlags(DataFlags::TERMINATED | DataFlags::LITERAL);
+  mDataFlags = DataFlags::TERMINATED | DataFlags::LITERAL;
 }
 
 void
 nsTSubstring_CharT::Assign(const self_type& aStr)
 {
   if (!Assign(aStr, mozilla::fallible)) {
     AllocFailed(aStr.Length());
   }
@@ -445,17 +445,17 @@ nsTSubstring_CharT::Assign(const self_ty
 
     // |aStr| should be null-terminated
     NS_ASSERTION(aStr.mDataFlags & DataFlags::TERMINATED, "shared, but not terminated");
 
     ::ReleaseData(mData, mDataFlags);
 
     mData = aStr.mData;
     mLength = aStr.mLength;
-    SetDataFlags(DataFlags::TERMINATED | DataFlags::SHARED);
+    mDataFlags = DataFlags::TERMINATED | DataFlags::SHARED;
 
     // get an owning reference to the mData
     nsStringBuffer::FromData(mData)->AddRef();
     return true;
   } else if (aStr.mDataFlags & DataFlags::LITERAL) {
     MOZ_ASSERT(aStr.mDataFlags & DataFlags::TERMINATED, "Unterminated literal");
 
     AssignLiteral(aStr.mData, aStr.mLength);
@@ -511,17 +511,17 @@ nsTSubstring_CharT::Adopt(char_type* aDa
     if (aLength == size_type(-1)) {
       aLength = char_traits::length(aData);
     }
 
     MOZ_RELEASE_ASSERT(CheckCapacity(aLength), "adopting a too-long string");
 
     mData = aData;
     mLength = aLength;
-    SetDataFlags(DataFlags::TERMINATED | DataFlags::OWNED);
+    mDataFlags = DataFlags::TERMINATED | DataFlags::OWNED;
 
     STRING_STAT_INCREMENT(Adopt);
     // Treat this as construction of a "StringAdopt" object for leak
     // tracking purposes.
     MOZ_LOG_CTOR(mData, "StringAdopt", 1);
   } else {
     SetIsVoid(true);
   }
@@ -685,17 +685,17 @@ nsTSubstring_CharT::SetCapacity(size_typ
 {
   // capacity does not include room for the terminating null char
 
   // if our capacity is reduced to zero, then free our buffer.
   if (aCapacity == 0) {
     ::ReleaseData(mData, mDataFlags);
     mData = char_traits::sEmptyBuffer;
     mLength = 0;
-    SetDataFlags(DataFlags::TERMINATED);
+    mDataFlags = DataFlags::TERMINATED;
     return true;
   }
 
   char_type* oldData;
   DataFlags oldFlags;
   if (!MutatePrep(aCapacity, &oldData, &oldFlags)) {
     return false;  // out-of-memory
   }
diff --git a/xpcom/string/nsTSubstring.h b/xpcom/string/nsTSubstring.h
--- a/xpcom/string/nsTSubstring.h
+++ b/xpcom/string/nsTSubstring.h
@@ -990,17 +990,17 @@ public:
    * If the string uses a shared buffer, this method
    * clears the pointer without releasing the buffer.
    */
   void ForgetSharedBuffer()
   {
     if (mDataFlags & DataFlags::SHARED) {
       mData = char_traits::sEmptyBuffer;
       mLength = 0;
-      SetDataFlags(DataFlags::TERMINATED);
+      mDataFlags = DataFlags::TERMINATED;
     }
   }
 
 public:
 
   /**
    * this is public to support automatic conversion of tuple to string
    * base type, which helps avoid converting to nsTAString.
@@ -1159,24 +1159,16 @@ protected:
       // use that value to flag immutability.
       NS_ASSERTION(aCapacity != size_type(-1), "Bogus capacity");
       return false;
     }
 
     return true;
   }
 
-  /**
-   * this helper function stores the specified dataFlags in mDataFlags
-   */
-  void SetDataFlags(DataFlags aDataFlags)
-  {
-    mDataFlags = aDataFlags;
-  }
-
   void NS_FASTCALL ReplaceLiteral(index_type aCutStart, size_type aCutLength,
                                   const char_type* aData, size_type aLength);
 
   static const size_type kMaxCapacity;
 public:
 
   // NOTE: this method is declared public _only_ for convenience for
   // callers who don't have access to the original nsLiteralString_CharT.
