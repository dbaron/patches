From: L. David Baron <dbaron@dbaron.org>

Make nsIFrame::DisplaySelectionOverlay take an nsDisplayList* instead of nsDisplayListSet&.  (Bug 485501)

diff --git a/layout/forms/nsComboboxControlFrame.cpp b/layout/forms/nsComboboxControlFrame.cpp
--- a/layout/forms/nsComboboxControlFrame.cpp
+++ b/layout/forms/nsComboboxControlFrame.cpp
@@ -1370,17 +1370,17 @@ nsComboboxControlFrame::BuildDisplayList
           mDisplayFrame && IsVisibleForPainting(aBuilder)) {
         nsresult rv = aLists.Content()->AppendNewToTop(
             new (aBuilder) nsDisplayComboboxFocus(aBuilder, this));
         NS_ENSURE_SUCCESS(rv, rv);
       }
     }
   }
 
-  return DisplaySelectionOverlay(aBuilder, aLists);
+  return DisplaySelectionOverlay(aBuilder, aLists.Content());
 }
 
 void nsComboboxControlFrame::PaintFocus(nsIRenderingContext& aRenderingContext,
                                         nsPoint aPt)
 {
   /* Do we need to do anything? */
   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::disabled) ||
       mFocused != this)
diff --git a/layout/forms/nsFileControlFrame.cpp b/layout/forms/nsFileControlFrame.cpp
--- a/layout/forms/nsFileControlFrame.cpp
+++ b/layout/forms/nsFileControlFrame.cpp
@@ -682,17 +682,17 @@ nsFileControlFrame::BuildDisplayList(nsD
   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::disabled) && 
       IsVisibleForPainting(aBuilder)) {
     rv = aLists.Content()->AppendNewToTop(
         new (aBuilder) nsDisplayEventReceiver(aBuilder, this));
     if (NS_FAILED(rv))
       return rv;
   }
 
-  return DisplaySelectionOverlay(aBuilder, aLists);
+  return DisplaySelectionOverlay(aBuilder, aLists.Content());
 }
 
 #ifdef ACCESSIBILITY
 already_AddRefed<nsAccessible>
 nsFileControlFrame::CreateAccessible()
 {
   // Accessible object exists just to hold onto its children, for later shutdown
   nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
diff --git a/layout/forms/nsHTMLButtonControlFrame.cpp b/layout/forms/nsHTMLButtonControlFrame.cpp
--- a/layout/forms/nsHTMLButtonControlFrame.cpp
+++ b/layout/forms/nsHTMLButtonControlFrame.cpp
@@ -190,17 +190,17 @@ nsHTMLButtonControlFrame::BuildDisplayLi
   } else {
     set.MoveTo(aLists);
   }
   
   nsresult rv = DisplayOutline(aBuilder, aLists);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // to draw border when selected in editor
-  return DisplaySelectionOverlay(aBuilder, aLists);
+  return DisplaySelectionOverlay(aBuilder, aLists.Content());
 }
 
 nscoord
 nsHTMLButtonControlFrame::GetMinWidth(nsIRenderingContext* aRenderingContext)
 {
   nscoord result;
   DISPLAY_MIN_WIDTH(this, result);
 
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -1006,17 +1006,17 @@ void nsDisplaySelectionOverlay::Paint(ns
 }
 
 /********************************************************
 * Refreshes each content's frame
 *********************************************************/
 
 nsresult
 nsFrame::DisplaySelectionOverlay(nsDisplayListBuilder*   aBuilder,
-                                 const nsDisplayListSet& aLists,
+                                 nsDisplayListSet*       aList,
                                  PRUint16                aContentType)
 {
 //check frame selection state
   if ((GetStateBits() & NS_FRAME_SELECTED_CONTENT) != NS_FRAME_SELECTED_CONTENT)
     return NS_OK;
   if (!IsVisibleForPainting(aBuilder))
     return NS_OK;
     
@@ -1053,17 +1053,17 @@ nsFrame::DisplaySelectionOverlay(nsDispl
     return NS_OK;
   
   while (details) {
     SelectionDetails *next = details->mNext;
     delete details;
     details = next;
   }
 
-  return aLists.Content()->AppendNewToTop(new (aBuilder)
+  return aList->AppendNewToTop(new (aBuilder)
       nsDisplaySelectionOverlay(aBuilder, this, selectionValue));
 }
 
 nsresult
 nsFrame::DisplayOutlineUnconditional(nsDisplayListBuilder*   aBuilder,
                                      const nsDisplayListSet& aLists)
 {
   if (GetStyleOutline()->GetOutlineStyle() == NS_STYLE_BORDER_STYLE_NONE)
diff --git a/layout/generic/nsFrame.h b/layout/generic/nsFrame.h
--- a/layout/generic/nsFrame.h
+++ b/layout/generic/nsFrame.h
@@ -544,17 +544,17 @@ protected:
 
   /**
    * To be called by |BuildDisplayLists| of this class or derived classes to add
    * a translucent overlay if this frame's content is selected.
    * @param aContentType an nsISelectionDisplay DISPLAY_ constant identifying
    * which kind of content this is for
    */
   nsresult DisplaySelectionOverlay(nsDisplayListBuilder* aBuilder,
-      const nsDisplayListSet& aLists, PRUint16 aContentType = nsISelectionDisplay::DISPLAY_FRAMES);
+      nsDisplayList* aList, PRUint16 aContentType = nsISelectionDisplay::DISPLAY_FRAMES);
 
   PRInt16 DisplaySelection(nsPresContext* aPresContext, PRBool isOkToTurnOn = PR_FALSE);
   
   // Style post processing hook
   virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 
 public:
   //given a frame five me the first/last leaf available
diff --git a/layout/generic/nsHTMLCanvasFrame.cpp b/layout/generic/nsHTMLCanvasFrame.cpp
--- a/layout/generic/nsHTMLCanvasFrame.cpp
+++ b/layout/generic/nsHTMLCanvasFrame.cpp
@@ -282,17 +282,17 @@ nsHTMLCanvasFrame::BuildDisplayList(nsDi
 
   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = aLists.Content()->AppendNewToTop(
       new (aBuilder) nsDisplayCanvas(aBuilder, this));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  return DisplaySelectionOverlay(aBuilder, aLists,
+  return DisplaySelectionOverlay(aBuilder, aLists.Content(),
                                  nsISelectionDisplay::DISPLAY_IMAGES);
 }
 
 nsIAtom*
 nsHTMLCanvasFrame::GetType() const
 {
   return nsGkAtoms::HTMLCanvasFrame;
 }
diff --git a/layout/generic/nsImageFrame.cpp b/layout/generic/nsImageFrame.cpp
--- a/layout/generic/nsImageFrame.cpp
+++ b/layout/generic/nsImageFrame.cpp
@@ -1309,17 +1309,17 @@ nsImageFrame::BuildDisplayList(nsDisplay
             }
           }
         }
       }
     }
   }
 #endif
   
-  return DisplaySelectionOverlay(aBuilder, aLists,
+  return DisplaySelectionOverlay(aBuilder, aLists.Content(),
                                  nsISelectionDisplay::DISPLAY_IMAGES);
 }
 
 NS_IMETHODIMP
 nsImageFrame::GetImageMap(nsPresContext *aPresContext, nsIImageMap **aImageMap)
 {
   nsImageMap *map = GetImageMap(aPresContext);
   return CallQueryInterface(map, aImageMap);
diff --git a/layout/generic/nsInlineFrame.cpp b/layout/generic/nsInlineFrame.cpp
--- a/layout/generic/nsInlineFrame.cpp
+++ b/layout/generic/nsInlineFrame.cpp
@@ -189,17 +189,17 @@ nsInlineFrame::BuildDisplayList(nsDispla
   nsresult rv = nsHTMLContainerFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
   NS_ENSURE_SUCCESS(rv, rv);
   
   // The sole purpose of this is to trigger display of the selection
   // window for Named Anchors, which don't have any children and
   // normally don't have any size, but in Editor we use CSS to display
   // an image to represent this "hidden" element.
   if (!mFrames.FirstChild()) {
-    rv = DisplaySelectionOverlay(aBuilder, aLists);
+    rv = DisplaySelectionOverlay(aBuilder, aLists.Content());
   }
   return rv;
 }
 
 //////////////////////////////////////////////////////////////////////
 // Reflow methods
 
 /* virtual */ void
diff --git a/layout/xul/base/src/nsBoxFrame.cpp b/layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp
+++ b/layout/xul/base/src/nsBoxFrame.cpp
@@ -1329,17 +1329,17 @@ nsBoxFrame::BuildDisplayList(nsDisplayLi
     NS_ENSURE_SUCCESS(rv, rv);
   }
 #endif
 
   rv = BuildDisplayListForChildren(aBuilder, aDirtyRect, destination);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // see if we have to draw a selection frame around this container
-  rv = DisplaySelectionOverlay(aBuilder, destination);
+  rv = DisplaySelectionOverlay(aBuilder, destination.Content());
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (forceLayer) {
     // This is a bit of a hack. Collect up all descendant display items
     // and merge them into a single Content() list. This can cause us
     // to violate CSS stacking order, but forceLayer is a magic
     // XUL-only extension anyway.
     nsDisplayList masterList;
