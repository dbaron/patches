From: L. David Baron <dbaron@dbaron.org>

Bug 879255:  Refactor fix for bug 613888, step 1:  create haveCurrentTransition variable.  r=nrc

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -687,34 +687,36 @@ nsTransitionManager::ConsiderStartingTra
     haveValues &&
     haveChange &&
     // Check that we can interpolate between these values
     // (If this is ever a performance problem, we could add a
     // CanInterpolate method, but it seems fine for now.)
     nsStyleAnimation::Interpolate(aProperty, pt.mStartValue, pt.mEndValue,
                                   0.5, dummyValue);
 
+  bool haveCurrentTransition = false;
   uint32_t currentIndex = nsTArray<ElementPropertyTransition>::NoIndex;
   if (aElementTransitions) {
     nsTArray<ElementPropertyTransition> &pts =
       aElementTransitions->mPropertyTransitions;
     for (uint32_t i = 0, i_end = pts.Length(); i < i_end; ++i) {
       if (pts[i].mProperty == aProperty) {
+        haveCurrentTransition = true;
         currentIndex = i;
         break;
       }
     }
   }
 
   nsPresContext *presContext = aNewStyleContext->PresContext();
 
   if (!shouldAnimate) {
     nsTArray<ElementPropertyTransition> &pts =
       aElementTransitions->mPropertyTransitions;
-    if (currentIndex != nsTArray<ElementPropertyTransition>::NoIndex &&
+    if (haveCurrentTransition &&
         (!haveValues || pts[currentIndex].mEndValue != pt.mEndValue)) {
       // We're in the middle of a transition, but just got a
       // non-transition style change changing to exactly the
       // current in-progress value.   (This is quite easy to cause
       // using 'transition-delay'.)
       //
       // We also check that this current in-progress value is different
       // from the end value; we don't want to cancel a transition that
@@ -743,17 +745,17 @@ nsTransitionManager::ConsiderStartingTra
     // The spec says a negative duration is treated as zero.
     duration = 0.0;
   }
   pt.mStartForReversingTest = pt.mStartValue;
   pt.mReversePortion = 1.0;
 
   // We need to check two things if we have a currently running
   // transition for this property.
-  if (currentIndex != nsTArray<ElementPropertyTransition>::NoIndex) {
+  if (haveCurrentTransition) {
     const ElementPropertyTransition &oldPT =
       aElementTransitions->mPropertyTransitions[currentIndex];
 
     if (oldPT.mEndValue == pt.mEndValue) {
       // If we got a style change that changed the value to the endpoint
       // of the currently running transition, we don't want to interrupt
       // its timing function.
       // WalkTransitionRule already called RestyleForAnimation.
@@ -814,17 +816,17 @@ nsTransitionManager::ConsiderStartingTra
     aElementTransitions->mPropertyTransitions;
 #ifdef DEBUG
   for (uint32_t i = 0, i_end = pts.Length(); i < i_end; ++i) {
     NS_ABORT_IF_FALSE(i == currentIndex ||
                       pts[i].mProperty != aProperty,
                       "duplicate transitions for property");
   }
 #endif
-  if (currentIndex != nsTArray<ElementPropertyTransition>::NoIndex) {
+  if (haveCurrentTransition) {
     pts[currentIndex] = pt;
   } else {
     if (!pts.AppendElement(pt)) {
       NS_WARNING("out of memory");
       return;
     }
   }
   aElementTransitions->UpdateAnimationGeneration(mPresContext);
