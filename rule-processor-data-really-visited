From: L. David Baron <dbaron@dbaron.org>

Make RuleProcessorData store whether the link was really visited separately from the content state (since a later patch will make the content state lie).  (Bug 147777)

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1106,16 +1106,18 @@ RuleProcessorData::ContentState()
     mContentState = 0;
     if (mPresContext) {
       mPresContext->EventStateManager()->GetContentState(mContent,
                                                          mContentState);
     } else {
       mContentState = mContent->IntrinsicState();
     }
 
+    mReallyVisited = (mContentState & NS_EVENT_STATE_VISITED) != 0;
+
     // If we are not supposed to mark visited links as such, be sure to flip the
     // bits appropriately.
     if ((!gSupportVisitedPseudo ||
         gPrivateBrowsingObserver->InPrivateBrowsing()) &&
         (mContentState & NS_EVENT_STATE_VISITED)) {
       mContentState = (mContentState & ~PRUint32(NS_EVENT_STATE_VISITED)) |
                       NS_EVENT_STATE_UNVISITED;
     }
@@ -1125,16 +1127,23 @@ RuleProcessorData::ContentState()
 
 PRBool
 RuleProcessorData::IsLink()
 {
   PRUint32 state = ContentState();
   return (state & (NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED)) != 0;
 }
 
+PRBool
+RuleProcessorData::IsReallyVisited()
+{
+  ContentState();
+  return mReallyVisited;
+}
+
 PRInt32
 RuleProcessorData::GetNthIndex(PRBool aIsOfType, PRBool aIsFromEnd,
                                PRBool aCheckEdgeOnly)
 {
   NS_ASSERTION(mParentContent, "caller should check mParentContent");
   NS_ASSERTION(!mPreviousSiblingData ||
                mPreviousSiblingData->mContent->IsNodeOfType(nsINode::eELEMENT),
                "Unexpected previous sibling data");
diff --git a/layout/style/nsRuleProcessorData.h b/layout/style/nsRuleProcessorData.h
--- a/layout/style/nsRuleProcessorData.h
+++ b/layout/style/nsRuleProcessorData.h
@@ -120,16 +120,17 @@ private:
   }
   void* operator new(size_t sz) CPP_THROW_NEW {
     return ::operator new(sz);
   }
 public:
   const nsString* GetLang();
   PRUint32 ContentState();
   PRBool IsLink();
+  PRBool IsReallyVisited();
 
   // Returns a 1-based index of the child in its parent.  If the child
   // is not in its parent's child list (i.e., it is anonymous content),
   // returns 0.
   // If aCheckEdgeOnly is true, the function will return 1 if the result
   // is 1, and something other than 1 (maybe or maybe not a valid
   // result) otherwise.
   PRInt32 GetNthIndex(PRBool aIsOfType, PRBool aIsFromEnd,
@@ -181,20 +182,22 @@ private:
   // This node's index for :nth-child(), :nth-last-child(),
   // :nth-of-type(), :nth-last-of-type().  If -2, needs to be computed.
   // If -1, needs to be computed but known not to be 1.
   // If 0, the node is not at any index in its parent.
   // The first subscript is 0 for -child and 1 for -of-type, the second
   // subscript is 0 for nth- and 1 for nth-last-.
   PRInt32 mNthIndices[2][2];
 
-  // mContentState, mLinkState, mIsLink are initialized lazily.
+  // mContentState and mReallyVisited are initialized lazily.
   PRInt32 mContentState;  // eventStateMgr->GetContentState() or
                           // mContent->IntrinsicState() if we have no ESM
   PRPackedBool mGotContentState;
+  PRPackedBool mReallyVisited; // If this is :visited (which was removed from
+                               // ContentState())
 };
 
 struct ElementRuleProcessorData : public RuleProcessorData {
   ElementRuleProcessorData(nsPresContext* aPresContext,
                            nsIContent* aContent, 
                            nsRuleWalker* aRuleWalker,
                            VisitedHandling aVisitedHandling)
   : RuleProcessorData(aPresContext, aContent, aRuleWalker, aVisitedHandling)
