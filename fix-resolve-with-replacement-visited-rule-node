From: L. David Baron <dbaron@dbaron.org>

Bug 996796 patch 12 - Fix the visited rule node handling in ResolveStyleWithReplacement.  r=heycam

The added test passes locally on Linux with OMT compositing and OMT
animations enabled.  However, it also passes without the patch because
the calls to FlushAnimations and FlushTransitions from
PresShell::FlushPendingNotifications cover up the damage done by bugs in
the animation-only style flush.

Unfortunately due to lack of global history on B2G and not running OMT
animations tests on any other platforms, the new test won't actually run
in automation right now.

diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1421,31 +1421,42 @@ nsStyleSet::ResolveStyleWithReplacement(
                                         nsStyleContext* aNewParentContext,
                                         nsStyleContext* aOldStyleContext,
                                         nsRestyleHint aReplacements)
 {
   nsRuleNode* ruleNode =
     RuleNodeWithReplacement(aElement, aOldStyleContext->RuleNode(),
                             aOldStyleContext->GetPseudoType(), aReplacements);
 
-  // FIXME: Does this handle visited contexts correctly???
+  nsRuleNode* visitedRuleNode = nullptr;
+  nsStyleContext* oldStyleIfVisited = aOldStyleContext->GetStyleIfVisited();
+  if (oldStyleIfVisited) {
+    if (oldStyleIfVisited->RuleNode() == aOldStyleContext->RuleNode()) {
+      visitedRuleNode = ruleNode;
+    } else {
+      visitedRuleNode =
+        RuleNodeWithReplacement(aElement, oldStyleIfVisited->RuleNode(),
+                                oldStyleIfVisited->GetPseudoType(),
+                                aReplacements);
+    }
+  }
 
   uint32_t flags = eNoFlags;
   if (aOldStyleContext->IsLinkContext()) {
     flags |= eIsLink;
 
     // GetContext handles propagating RelevantLinkVisited state from the
     // parent in non-link cases; all we need to pass in is if this link
     // is visited.
     if (aOldStyleContext->RelevantLinkVisited()) {
       flags |= eIsVisitedLink;
     }
   }
 
-  return GetContext(aNewParentContext, ruleNode, nullptr,
+  return GetContext(aNewParentContext, ruleNode, visitedRuleNode,
                     nullptr, nsCSSPseudoElements::ePseudo_NotPseudoElement,
                     nullptr, flags);
 }
 
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForNonElement(nsStyleContext* aParentContext)
 {
diff --git a/layout/style/test/test_animations_omta.html b/layout/style/test/test_animations_omta.html
--- a/layout/style/test/test_animations_omta.html
+++ b/layout/style/test/test_animations_omta.html
@@ -146,16 +146,19 @@ https://bugzilla.mozilla.org/show_bug.cg
     }
 
     .target {
       /* The animation target needs geometry in order to qualify for OMTA */
       width: 100px;
       height: 100px;
       background-color: white;
     }
+
+    #visitedLink:link { background-color: yellow }
+    #visitedLink:visited { background-color: blue }
   </style>
 </head>
 <body>
 <a target="_blank"
   href="https://bugzilla.mozilla.org/show_bug.cgi?id=964646">Mozilla Bug
   964646</a>
 <div id="display"></div>
 <pre id="test">
@@ -2019,16 +2022,67 @@ addAsyncAnimTest(function *() {
                   animationName: 'empty', elapsedTime: 0,
                   pseudoElement: "" }],
                "events at start of animation updated to use " +
                "empty keyframes rule");
 
   done_div();
 });
 
+// Bug 996796 patch 12 - test for correct visited styles during
+// animation-only style flush.
+addAsyncAnimTest(function *() {
+  var div1 = document.createElement("div");
+  div1.classList.add("target");
+  div1.style.height = "10px";
+  div1.style.animation = "anim2 linear 1s";
+
+  var visitedLink = document.createElement("a");
+  visitedLink.setAttribute("href", "");
+  visitedLink.setAttribute("id", "visitedLink");
+  visitedLink.classList.add("target");
+  visitedLink.style.display = "block";
+  visitedLink.style.height = "10px";
+  visitedLink.style.animation = "anim2 linear 1s";
+
+  gDisplay.appendChild(div1);
+  gDisplay.appendChild(visitedLink);
+
+  // Wait for animations to start and for visited link coloring.
+  yield waitForPaintsFlushed();
+
+  var bgColor = SpecialPowers.DOMWindowUtils
+    .getVisitedDependentComputedStyle(visitedLink, "", "background-color");
+  var isb2g = SpecialPowers.Services.appinfo.name == "B2G";
+  // No global history in B2G.
+  (isb2g ? todo_is : is)(bgColor, "rgb(0, 0, 255)",
+                         "initial visited link background color");
+
+  if (isb2g) {
+    // The above failure makes the rest of the test pointless.
+    return;
+  }
+
+  advance_clock(250);
+
+  // Trigger a style change on div1 that will force us to do a miniflush,
+  // but which will not trigger a style change on visitedLink.
+  div1.style.color = "blue";
+  advance_clock(250);
+
+  bgColor = SpecialPowers.DOMWindowUtils
+    .getVisitedDependentComputedStyle(visitedLink, "", "background-color");
+
+  is(bgColor, "rgb(0, 0, 255)",
+     "visited link background color after animation-only flush");
+
+  div1.remove();
+  visitedLink.remove();
+});
+
 //----------------------------------------------------------------------
 //
 // Helper functions from test_animations.html
 //
 //----------------------------------------------------------------------
 
 function new_div(style) {
   if (gDiv !== null) {
