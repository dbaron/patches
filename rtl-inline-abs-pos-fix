Remove no-longer-needed else clauses, and make the *IsExact members DEBUG-only.  b=419076  r+sr=bzbarsky

diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -753,20 +753,24 @@ nsHTMLReflowState::GetNearestContainingB
 // element we would have to reflow it in order to determine it desired width.
 // In that case depending on the progression direction either the left or
 // right edge would be marked as not being exact
 struct nsHypotheticalBox {
   // offsets from left edge of containing block (which is a padding edge)
   nscoord       mLeft, mRight;
   // offset from top edge of containing block (which is a padding edge)
   nscoord       mTop;
+#ifdef DEBUG
   PRPackedBool  mLeftIsExact, mRightIsExact;
+#endif
 
   nsHypotheticalBox() {
+#ifdef DEBUG
     mLeftIsExact = mRightIsExact = PR_FALSE;
+#endif
   }
 };
       
 static PRBool
 GetIntrinsicSizeFor(nsIFrame* aFrame, nsSize& aIntrinsicSize)
 {
   // See if it is an image frame
   PRBool    result = PR_FALSE;
@@ -1013,47 +1017,59 @@ nsHTMLReflowState::CalculateHypothetical
     // How we determine the hypothetical box depends on whether the element
     // would have been inline-level or block-level
     if (NS_STYLE_DISPLAY_INLINE == mStyleDisplay->mOriginalDisplay) {
       // The placeholder represents the left edge of the hypothetical box
       aHypotheticalBox.mLeft = placeholderOffset.x;
     } else {
       aHypotheticalBox.mLeft = aBlockLeftContentEdge;
     }
+#ifdef DEBUG
     aHypotheticalBox.mLeftIsExact = PR_TRUE;
+#endif
 
     if (knowBoxWidth) {
       aHypotheticalBox.mRight = aHypotheticalBox.mLeft + boxWidth;
+#ifdef DEBUG
       aHypotheticalBox.mRightIsExact = PR_TRUE;
+#endif
     } else {
       // We can't compute the right edge because we don't know the desired
       // width. So instead use the right content edge of the block parent,
       // but remember it's not exact
       aHypotheticalBox.mRight = aBlockLeftContentEdge + aBlockContentWidth;
+#ifdef DEBUG
       aHypotheticalBox.mRightIsExact = PR_FALSE;
+#endif
     }
 
   } else {
     // The placeholder represents the right edge of the hypothetical box
     if (NS_STYLE_DISPLAY_INLINE == mStyleDisplay->mOriginalDisplay) {
       aHypotheticalBox.mRight = placeholderOffset.x;
     } else {
       aHypotheticalBox.mRight = aBlockLeftContentEdge + aBlockContentWidth;
     }
+#ifdef DEBUG
     aHypotheticalBox.mRightIsExact = PR_TRUE;
+#endif
     
     if (knowBoxWidth) {
       aHypotheticalBox.mLeft = aHypotheticalBox.mRight - boxWidth;
+#ifdef DEBUG
       aHypotheticalBox.mLeftIsExact = PR_TRUE;
+#endif
     } else {
       // We can't compute the left edge because we don't know the desired
       // width. So instead use the left content edge of the block parent,
       // but remember it's not exact
       aHypotheticalBox.mLeft = aBlockLeftContentEdge;
+#ifdef DEBUG
       aHypotheticalBox.mLeftIsExact = PR_FALSE;
+#endif
     }
 
   }
 
   // The current coordinate space is that of the nearest block to the placeholder.
   // Convert to the coordinate space of the absolute containing block
   // One weird thing here is that for fixed-positioned elements we want to do
   // the conversion incorrectly; specifically we want to ignore any scrolling
@@ -1143,35 +1159,25 @@ nsHTMLReflowState::InitAbsoluteConstrain
   }
 
   // Use the horizontal component of the hypothetical box in the cases
   // where it's needed.
   if (leftIsAuto && rightIsAuto) {
     // Use the direction of the original ("static-position") containing block
     // to dictate whether 'left' or 'right' is treated like 'static-position'.
     if (NS_STYLE_DIRECTION_LTR == cbFrame->GetStyleVisibility()->mDirection) {
-      if (hypotheticalBox.mLeftIsExact) {
-        mComputedOffsets.left = hypotheticalBox.mLeft;
-        leftIsAuto = PR_FALSE;
-      } else {
-        // Well, we don't know 'left' so we have to use 'right' and
-        // then solve for 'left'
-        mComputedOffsets.right = hypotheticalBox.mRight;
-        rightIsAuto = PR_FALSE;
-      }
+      NS_ASSERTION(hypotheticalBox.mLeftIsExact, "should always have "
+                   "exact value on containing block's start side");
+      mComputedOffsets.left = hypotheticalBox.mLeft;
+      leftIsAuto = PR_FALSE;
     } else {
-      if (hypotheticalBox.mRightIsExact) {
-        mComputedOffsets.right = containingBlockWidth - hypotheticalBox.mRight;
-        rightIsAuto = PR_FALSE;
-      } else {
-        // Well, we don't know 'right' so we have to use 'left' and
-        // then solve for 'right'
-        mComputedOffsets.left = hypotheticalBox.mLeft;
-        leftIsAuto = PR_FALSE;
-      }
+      NS_ASSERTION(hypotheticalBox.mRightIsExact, "should always have "
+                   "exact value on containing block's start side");
+      mComputedOffsets.right = containingBlockWidth - hypotheticalBox.mRight;
+      rightIsAuto = PR_FALSE;
     }
   }
 
   // Initialize the 'top' and 'bottom' computed offsets
   PRBool      topIsAuto = PR_FALSE, bottomIsAuto = PR_FALSE;
   if (eStyleUnit_Auto == mStylePosition->mOffset.GetTopUnit()) {
     mComputedOffsets.top = 0;
     topIsAuto = PR_TRUE;
