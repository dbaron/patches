From: L. David Baron <dbaron@dbaron.org>

When a frame is themed, report a border-radius of 0.  (Bug 595652)  r=roc  a2.0=blocking2.0:betaN

diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -839,16 +839,29 @@ nsIFrame::OutsetBorderRadii(nscoord aRad
     if (aRadii[hc2] > 0)
       aRadii[hc2] += offset;
   }
 }
 
 /* virtual */ PRBool
 nsIFrame::GetBorderRadii(nscoord aRadii[8]) const
 {
+  if (IsThemed()) {
+    // When we're themed, the native theme code draws the border and
+    // background, and therefore it doesn't make sense to tell other
+    // code that's interested in border-radius that we have any radii.
+    //
+    // In an ideal world, we might have a way for the them to tell us an
+    // border radius, but since we don't, we're better off assuming
+    // zero.
+    NS_FOR_CSS_HALF_CORNERS(corner) {
+      aRadii[corner] = 0;
+    }
+    return PR_FALSE;
+  }
   nsSize size = GetSize();
   return ComputeBorderRadii(GetStyleBorder()->mBorderRadius, size, size,
                             GetSkipSides(), aRadii);
 }
 
 PRBool
 nsIFrame::GetPaddingBoxBorderRadii(nscoord aRadii[8]) const
 {
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -1057,29 +1057,32 @@ public:
   /**
    * Get the preferred caret color at the offset.
    *
    * @param aOffset is offset of the content.
    */
   virtual nscolor GetCaretColorAt(PRInt32 aOffset);
 
  
-  PRBool IsThemed(nsITheme::Transparency* aTransparencyState = nsnull) {
+  PRBool IsThemed(nsITheme::Transparency* aTransparencyState = nsnull) const {
     return IsThemed(GetStyleDisplay(), aTransparencyState);
   }
   PRBool IsThemed(const nsStyleDisplay* aDisp,
-                  nsITheme::Transparency* aTransparencyState = nsnull) {
+                  nsITheme::Transparency* aTransparencyState = nsnull) const {
+    nsIFrame* mutable_this = const_cast<nsIFrame*>(this);
     if (!aDisp->mAppearance)
       return PR_FALSE;
     nsPresContext* pc = PresContext();
     nsITheme *theme = pc->GetTheme();
-    if(!theme || !theme->ThemeSupportsWidget(pc, this, aDisp->mAppearance))
+    if(!theme ||
+       !theme->ThemeSupportsWidget(pc, mutable_this, aDisp->mAppearance))
       return PR_FALSE;
     if (aTransparencyState) {
-      *aTransparencyState = theme->GetWidgetTransparency(this, aDisp->mAppearance);
+      *aTransparencyState =
+        theme->GetWidgetTransparency(mutable_this, aDisp->mAppearance);
     }
     return PR_TRUE;
   }
   
   /**
    * Builds a display list for the content represented by this frame,
    * treating this frame as the root of a stacking context.
    * @param aDirtyRect content outside this rectangle can be ignored; the
