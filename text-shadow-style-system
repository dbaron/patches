From: Christian Biesinger <cbiesinger@gmail.com>, Michael Ventnor <ventnor.bugzilla@yahoo.com.au>

Implement the computed value of text-shadow in the style system.  (Bug 10713)  r+sr=dbaron

diff --git a/layout/style/forms.css b/layout/style/forms.css
--- a/layout/style/forms.css
+++ b/layout/style/forms.css
@@ -96,16 +96,17 @@ input {
   text-align: start;
   text-transform: none;
   word-spacing: normal;
   letter-spacing: normal;
   cursor: text;
   -moz-binding: url("chrome://global/content/platformHTMLBindings.xml#inputFields");
   text-indent: 0;
   -moz-user-select: text;
+  text-shadow: none;
 }
 
 input > .anonymous-div {
   white-space: pre;
 }
 
 textarea {
   margin: 1px 0 1px 0;
@@ -119,16 +120,17 @@ textarea {
   word-spacing: normal;
   letter-spacing: normal;
   vertical-align: text-bottom;
   cursor: text;
   -moz-binding: url("chrome://global/content/platformHTMLBindings.xml#textAreas");
   -moz-appearance: textfield-multiline;
   text-indent: 0;
   -moz-user-select: text;
+  text-shadow: none;
 }
 
 textarea > scrollbar {
   cursor: default;
 }
 
 textarea > .anonymous-div,
 input > .anonymous-div {
@@ -160,16 +162,17 @@ select {
   cursor: default;
   -moz-box-sizing: border-box;
   -moz-user-select: none;
   -moz-appearance: menulist;
   border-width: 2px;
   border-style: inset;
   text-indent: 0;
   overflow: -moz-hidden-unscrollable;
+  text-shadow: none;
 }
 
 /* Need the "select[size][multiple]" selector to override the settings on
    'select[size="1"]', eg if one has <select size="1" multiple> */
    
 select[size],
 select[multiple],
 select[size][multiple] {
@@ -477,16 +480,17 @@ input[type="submit"] {
   font: -moz-button;
   line-height: normal !important;
   white-space: pre;
   cursor: default;
   -moz-box-sizing: border-box;
   -moz-user-select: none;
   -moz-binding: none;
   text-align: center;
+  text-shadow: none;
 }
 
 button {
   /* Buttons should lay out like "normal" html, mostly */
   white-space: inherit;
   text-indent: 0;
 }
 
diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -487,17 +487,17 @@ CSS_PROP_BACKENDONLY(speak-numeral, spea
 CSS_PROP_BACKENDONLY(speak-numeral, speak_numeral, SpeakNumeral, Aural, mSpeakNumeral, eCSSType_Value, kSpeakNumeralKTable)
 CSS_PROP_BACKENDONLY(speak-punctuation, speak_punctuation, SpeakPunctuation, Aural, mSpeakPunctuation, eCSSType_Value, kSpeakPunctuationKTable)
 CSS_PROP_BACKENDONLY(speech-rate, speech_rate, SpeechRate, Aural, mSpeechRate, eCSSType_Value, kSpeechRateKTable)
 CSS_PROP_BACKENDONLY(stress, stress, Stress, Aural, mStress, eCSSType_Value, nsnull)
 CSS_PROP_TABLE(table-layout, table_layout, TableLayout, Table, mLayout, eCSSType_Value, kTableLayoutKTable)
 CSS_PROP_TEXT(text-align, text_align, TextAlign, Text, mTextAlign, eCSSType_Value, kTextAlignKTable)
 CSS_PROP_TEXTRESET(text-decoration, text_decoration, TextDecoration, Text, mDecoration, eCSSType_Value, kTextDecorationKTable)
 CSS_PROP_TEXT(text-indent, text_indent, TextIndent, Text, mTextIndent, eCSSType_Value, nsnull)
-CSS_PROP_BACKENDONLY(text-shadow, text_shadow, TextShadow, Text, mTextShadow, eCSSType_ValueList, nsnull)
+CSS_PROP_TEXT(text-shadow, text_shadow, TextShadow, Text, mTextShadow, eCSSType_ValueList, nsnull)
 CSS_PROP_TEXT(text-transform, text_transform, TextTransform, Text, mTextTransform, eCSSType_Value, kTextTransformKTable)
 CSS_PROP_POSITION(top, top, Top, Position, mOffset.mTop, eCSSType_Value, nsnull)
 CSS_PROP_TEXTRESET(unicode-bidi, unicode_bidi, UnicodeBidi, Text, mUnicodeBidi, eCSSType_Value, kUnicodeBidiKTable)
 CSS_PROP_USERINTERFACE(-moz-user-focus, user_focus, MozUserFocus, UserInterface, mUserFocus, eCSSType_Value, kUserFocusKTable) // XXX bug 3935
 CSS_PROP_USERINTERFACE(-moz-user-input, user_input, MozUserInput, UserInterface, mUserInput, eCSSType_Value, kUserInputKTable) // XXX ??? // XXX bug 3935
 CSS_PROP_USERINTERFACE(-moz-user-modify, user_modify, MozUserModify, UserInterface, mUserModify, eCSSType_Value, kUserModifyKTable) // XXX bug 3935
 CSS_PROP_UIRESET(-moz-user-select, user_select, MozUserSelect, UserInterface, mUserSelect, eCSSType_Value, kUserSelectKTable) // XXX bug 3935
 CSS_PROP_TEXTRESET(vertical-align, vertical_align, VerticalAlign, Text, mVerticalAlign, eCSSType_Value, kVerticalAlignKTable)
diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -20,16 +20,17 @@
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Daniel Glazman <glazman@netscape.com>
  *   Boris Zbarsky <bzbarsky@mit.edu>
  *   Christopher A. Aillon <christopher@aillon.com>
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   Christian Biesinger <cbiesinger@web.de>
+ *   Michael Ventnor <m.ventnor@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -1203,19 +1204,18 @@ nsComputedDOMStyle::GetBorderSpacing(nsI
   }
   if (!valueList->AppendCSSValue(ySpacing)) {
     delete valueList;
     delete ySpacing;
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   const nsStyleTableBorder *border = GetStyleTableBorder();
-  // border-spacing will always be a coord
-  xSpacing->SetAppUnits(border->mBorderSpacingX.GetCoordValue());
-  ySpacing->SetAppUnits(border->mBorderSpacingY.GetCoordValue());
+  SetValueToCoord(xSpacing, border->mBorderSpacingX);
+  SetValueToCoord(ySpacing, border->mBorderSpacingY);
 
   return CallQueryInterface(valueList, aValue);
 }
 
 nsresult
 nsComputedDOMStyle::GetCaptionSide(nsIDOMCSSValue** aValue)
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
@@ -1784,16 +1784,75 @@ nsComputedDOMStyle::GetTextIndent(nsIDOM
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 
   SetValueToCoord(val, GetStyleText()->mTextIndent,
                   &nsComputedDOMStyle::GetCBContentWidth);
 
   return CallQueryInterface(val, aValue);
+}
+
+nsresult
+nsComputedDOMStyle::GetTextShadow(nsIDOMCSSValue** aValue)
+{
+  const nsStyleText* text = GetStyleText();
+
+  if (!text->mShadowArray) {
+    nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
+    val->SetIdent(nsGkAtoms::none);
+    return CallQueryInterface(val, aValue);
+  }
+
+  static const nsStyleCoord nsTextShadowItem::*shadowValues[] = {
+    &nsTextShadowItem::mXOffset,
+    &nsTextShadowItem::mYOffset,
+    &nsTextShadowItem::mRadius
+  };
+
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  for (nsTextShadowItem *item = text->mShadowArray->ShadowAt(0),
+                    *item_end = item + text->mShadowArray->Length();
+       item < item_end; ++item) {
+    nsDOMCSSValueList *itemList = GetROCSSValueList(PR_FALSE);
+    if (!itemList || !valueList->AppendCSSValue(itemList)) {
+      delete itemList;
+      delete valueList;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    // Color is either the specified shadow color or the foreground color
+    nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
+    if (!val || !itemList->AppendCSSValue(val)) {
+      delete val;
+      delete valueList;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+    nscolor shadowColor;
+    if (item->mHasColor) {
+      shadowColor = item->mColor;
+    } else {
+      shadowColor = GetStyleColor()->mColor;
+    }
+    SetToRGBAColor(val, shadowColor);
+
+    // Set the offsets and blur radius
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(shadowValues); ++i) {
+      val = GetROCSSPrimitiveValue();
+      if (!val || !itemList->AppendCSSValue(val)) {
+        delete val;
+        delete valueList;
+        return NS_ERROR_OUT_OF_MEMORY;
+      }
+      SetValueToCoord(val, item->*(shadowValues[i]));
+    }
+  }
+  return CallQueryInterface(valueList, aValue);
 }
 
 nsresult
 nsComputedDOMStyle::GetTextTransform(nsIDOMCSSValue** aValue)
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 
@@ -3765,17 +3824,17 @@ nsComputedDOMStyle::GetQueryableProperty
     // COMPUTED_STYLE_MAP_ENTRY(speak_numeral,              SpeakNumeral),
     // COMPUTED_STYLE_MAP_ENTRY(speak_punctuation,          SpeakPunctuation),
     // COMPUTED_STYLE_MAP_ENTRY(speech_rate,                SpeechRate),
     // COMPUTED_STYLE_MAP_ENTRY(stress,                     Stress),
     COMPUTED_STYLE_MAP_ENTRY(table_layout,                  TableLayout),
     COMPUTED_STYLE_MAP_ENTRY(text_align,                    TextAlign),
     COMPUTED_STYLE_MAP_ENTRY(text_decoration,               TextDecoration),
     COMPUTED_STYLE_MAP_ENTRY(text_indent,                   TextIndent),
-    // COMPUTED_STYLE_MAP_ENTRY(text_shadow,                TextShadow),
+    COMPUTED_STYLE_MAP_ENTRY(text_shadow,                   TextShadow),
     COMPUTED_STYLE_MAP_ENTRY(text_transform,                TextTransform),
     COMPUTED_STYLE_MAP_ENTRY(top,                           Top),
     COMPUTED_STYLE_MAP_ENTRY(unicode_bidi,                  UnicodeBidi),
     COMPUTED_STYLE_MAP_ENTRY(vertical_align,                VerticalAlign),
     COMPUTED_STYLE_MAP_ENTRY(visibility,                    Visibility),
     // COMPUTED_STYLE_MAP_ENTRY(voice_family,               VoiceFamily),
     // COMPUTED_STYLE_MAP_ENTRY(volume,                     Volume),
     COMPUTED_STYLE_MAP_ENTRY(white_space,                   WhiteSpace),
diff --git a/layout/style/nsComputedDOMStyle.h b/layout/style/nsComputedDOMStyle.h
--- a/layout/style/nsComputedDOMStyle.h
+++ b/layout/style/nsComputedDOMStyle.h
@@ -231,16 +231,17 @@ private:
   nsresult GetImageRegion(nsIDOMCSSValue** aValue);
 
   /* Text Properties */
   nsresult GetLineHeight(nsIDOMCSSValue** aValue);
   nsresult GetTextAlign(nsIDOMCSSValue** aValue);
   nsresult GetTextDecoration(nsIDOMCSSValue** aValue);
   nsresult GetTextIndent(nsIDOMCSSValue** aValue);
   nsresult GetTextTransform(nsIDOMCSSValue** aValue);
+  nsresult GetTextShadow(nsIDOMCSSValue** aValue);
   nsresult GetLetterSpacing(nsIDOMCSSValue** aValue);
   nsresult GetWordSpacing(nsIDOMCSSValue** aValue);
   nsresult GetWhiteSpace(nsIDOMCSSValue** aValue);
 
   /* Visibility properties */
   nsresult GetOpacity(nsIDOMCSSValue** aValue);
   nsresult GetVisibility(nsIDOMCSSValue** aValue);
 
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -20,16 +20,18 @@
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Original Author: David W. Hyatt (hyatt@netscape.com)
  *   Daniel Glazman <glazman@netscape.com>
  *   Roger B. Sidje <rbs@maths.uq.edu.au>
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   L. David Baron <dbaron@dbaron.org>
+ *   Christian Biesinger <cbiesinger@web.de>
+ *   Michael Ventnor <m.ventnor@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -1138,29 +1140,29 @@ nsRuleNode::GetVisibilityData(nsStyleCon
 
 const void*
 nsRuleNode::GetTextData(nsStyleContext* aContext)
 {
   nsRuleDataText textData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Text), mPresContext, aContext);
   ruleData.mTextData = &textData;
 
-  return WalkRuleTree(eStyleStruct_Text, aContext, &ruleData, &textData);
+  const void* res = WalkRuleTree(eStyleStruct_Text, aContext, &ruleData, &textData);
+  textData.mTextShadow = nsnull; // We are sharing with some style rule.  It really owns the data.
+  return res;
 }
 
 const void*
 nsRuleNode::GetTextResetData(nsStyleContext* aContext)
 {
   nsRuleDataText textData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(TextReset), mPresContext, aContext);
   ruleData.mTextData = &textData;
 
-  const void* res = WalkRuleTree(eStyleStruct_TextReset, aContext, &ruleData, &textData);
-  textData.mTextShadow = nsnull; // We are sharing with some style rule.  It really owns the data.
-  return res;
+  return WalkRuleTree(eStyleStruct_TextReset, aContext, &ruleData, &textData);
 }
 
 const void*
 nsRuleNode::GetUserInterfaceData(nsStyleContext* aContext)
 {
   nsRuleDataUserInterface uiData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(UserInterface), mPresContext, aContext);
   ruleData.mUserInterfaceData = &uiData;
@@ -2622,16 +2624,65 @@ nsRuleNode::ComputeTextData(void* aStart
                             const RuleDetail aRuleDetail, PRBool aInherited)
 {
   COMPUTE_START_INHERITED(Text, (), text, parentText, Text, textData)
 
     // letter-spacing: normal, length, inherit
   SetCoord(textData.mLetterSpacing, text->mLetterSpacing, parentText->mLetterSpacing,
            SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL,
            aContext, mPresContext, inherited);
+
+  // text-shadow: none, list, inherit, initial
+  nsCSSValueList* list = textData.mTextShadow;
+  if (list) {
+    text->mShadowArray = nsnull;
+
+    // Don't need to handle none/initial explicitly: The above assignment
+    // takes care of that
+    if (eCSSUnit_Inherit == list->mValue.GetUnit()) {
+      inherited = PR_TRUE;
+      text->mShadowArray = parentText->mShadowArray;
+    } else if (eCSSUnit_Array == list->mValue.GetUnit()) {
+      // List of arrays
+      PRUint32 arrayLength = 0;
+      for (nsCSSValueList *list2 = list; list2; list2 = list2->mNext)
+        ++arrayLength;
+
+      NS_ASSERTION(arrayLength > 0, "Non-null text-shadow list, yet we counted 0 items.");
+      text->mShadowArray = new(arrayLength) nsTextShadowArray(arrayLength);
+      if (text->mShadowArray) {
+        for (nsTextShadowItem* item = text->mShadowArray->ShadowAt(0);
+             list;
+             list = list->mNext, ++item) {
+          nsCSSValue::Array *arr = list->mValue.GetArrayValue();
+          // OK to pass bad aParentCoord since we're not passing SETCOORD_INHERIT
+          SetCoord(arr->Item(0), item->mXOffset, nsStyleCoord(),
+                   SETCOORD_LENGTH, aContext, mPresContext, inherited);
+          SetCoord(arr->Item(1), item->mYOffset, nsStyleCoord(),
+                   SETCOORD_LENGTH, aContext, mPresContext, inherited);
+
+          // Blur radius is optional in the text-shadow rule. If not available,
+          // set it to 0.
+          if (arr->Item(2).GetUnit() != eCSSUnit_Null) {
+            SetCoord(arr->Item(2), item->mRadius, nsStyleCoord(),
+                     SETCOORD_LENGTH, aContext, mPresContext, inherited);
+          } else {
+            item->mRadius.SetCoordValue(0);
+          }
+
+          if (arr->Item(3).GetUnit() != eCSSUnit_Null) {
+            item->mHasColor = PR_TRUE;
+            // 2nd argument can be bogus since inherit is not a valid color
+            SetColor(arr->Item(3), 0, mPresContext, aContext, item->mColor,
+                     inherited);
+          }
+        }
+      }
+    }
+  }
 
   // line-height: normal, number, length, percent, inherit
   if (eCSSUnit_Percent == textData.mLineHeight.GetUnit()) {
     inherited = PR_TRUE;
     // Use |mFont.size| to pick up minimum font size.
     text->mLineHeight.SetCoordValue(
         nscoord(float(aContext->GetStyleFont()->mFont.size) *
                 textData.mLineHeight.GetPercentValue()));
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -17,16 +17,17 @@
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   David Hyatt (hyatt@netscape.com)
  *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Michael Ventnor <m.ventnor@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -1537,49 +1538,86 @@ nsChangeHint nsStyleTextReset::CalcDiffe
 /* static */
 nsChangeHint nsStyleTextReset::MaxDifference()
 {
   return NS_STYLE_HINT_REFLOW;
 }
 #endif
 
 // --------------------
+// nsTextShadowArray
+// nsTextShadowItem
+//
+
+nsrefcnt
+nsTextShadowArray::Release()
+{
+  mRefCnt--;
+  if (mRefCnt == 0) {
+    delete this;
+    return 0;
+  }
+  return mRefCnt;
+}
+
+// --------------------
 // nsStyleText
 //
 
-nsStyleText::nsStyleText(void) 
+nsStyleText::nsStyleText(void)
 { 
   mTextAlign = NS_STYLE_TEXT_ALIGN_DEFAULT;
   mTextTransform = NS_STYLE_TEXT_TRANSFORM_NONE;
   mWhiteSpace = NS_STYLE_WHITESPACE_NORMAL;
 
   mLetterSpacing.SetNormalValue();
   mLineHeight.SetNormalValue();
   mTextIndent.SetCoordValue(0);
   mWordSpacing.SetNormalValue();
+
+  mShadowArray = nsnull;
 }
 
-nsStyleText::nsStyleText(const nsStyleText& aSource) 
-{ 
-  memcpy((nsStyleText*)this, &aSource, sizeof(nsStyleText));
-}
+nsStyleText::nsStyleText(const nsStyleText& aSource)
+  : mTextAlign(aSource.mTextAlign),
+    mTextTransform(aSource.mTextTransform),
+    mWhiteSpace(aSource.mWhiteSpace),
+    mLetterSpacing(aSource.mLetterSpacing),
+    mLineHeight(aSource.mLineHeight),
+    mTextIndent(aSource.mTextIndent),
+    mWordSpacing(aSource.mWordSpacing),
+    mShadowArray(aSource.mShadowArray)
+{ }
 
 nsStyleText::~nsStyleText(void) { }
 
 nsChangeHint nsStyleText::CalcDifference(const nsStyleText& aOther) const
 {
-  if ((mTextAlign == aOther.mTextAlign) &&
-      (mTextTransform == aOther.mTextTransform) &&
-      (mWhiteSpace == aOther.mWhiteSpace) &&
-      (mLetterSpacing == aOther.mLetterSpacing) &&
-      (mLineHeight == aOther.mLineHeight) &&
-      (mTextIndent == aOther.mTextIndent) &&
-      (mWordSpacing == aOther.mWordSpacing))
+  if ((mTextAlign != aOther.mTextAlign) ||
+      (mTextTransform != aOther.mTextTransform) ||
+      (mWhiteSpace != aOther.mWhiteSpace) ||
+      (mLetterSpacing != aOther.mLetterSpacing) ||
+      (mLineHeight != aOther.mLineHeight) ||
+      (mTextIndent != aOther.mTextIndent) ||
+      (mWordSpacing != aOther.mWordSpacing))
+    return NS_STYLE_HINT_REFLOW;
+
+  if ((!mShadowArray && !aOther.mShadowArray) ||
+      mShadowArray == aOther.mShadowArray)
     return NS_STYLE_HINT_NONE;
-  return NS_STYLE_HINT_REFLOW;
+
+  if (!mShadowArray || !aOther.mShadowArray ||
+      (mShadowArray->Length() != aOther.mShadowArray->Length()))
+    return NS_STYLE_HINT_REFLOW;
+
+  for (PRUint32 i = 0; i < mShadowArray->Length(); ++i) {
+    if (*mShadowArray->ShadowAt(i) != *aOther.mShadowArray->ShadowAt(i))
+      return NS_STYLE_HINT_REFLOW;
+  }
+  return NS_STYLE_HINT_NONE;
 }
 
 #ifdef DEBUG
 /* static */
 nsChangeHint nsStyleText::MaxDifference()
 {
   return NS_STYLE_HINT_REFLOW;
 }
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -664,16 +664,90 @@ struct nsStyleTextReset {
 #endif
   
   PRUint8 mTextDecoration;              // [reset] see nsStyleConsts.h
   PRUint8 mUnicodeBidi;                 // [reset] see nsStyleConsts.h
 
   nsStyleCoord  mVerticalAlign;         // [reset] see nsStyleConsts.h for enums
 };
 
+struct nsTextShadowItem {
+  nsStyleCoord mXOffset;  // length (coord, chars)
+  nsStyleCoord mYOffset;  // length (coord, chars)
+  nsStyleCoord mRadius;   // length (coord, chars)
+  nscolor      mColor;
+  PRPackedBool mHasColor; // Whether mColor should be used
+
+  nsTextShadowItem() : mHasColor(PR_FALSE) {
+    MOZ_COUNT_CTOR(nsTextShadowItem);
+  }
+  ~nsTextShadowItem() {
+    MOZ_COUNT_DTOR(nsTextShadowItem);
+  }
+
+  PRBool operator==(const nsTextShadowItem& aOther) {
+    return (mXOffset == aOther.mXOffset &&
+            mYOffset == aOther.mYOffset &&
+            mRadius == aOther.mRadius &&
+            mHasColor == aOther.mHasColor &&
+            (!mHasColor || mColor == aOther.mColor));
+  }
+  PRBool operator!=(const nsTextShadowItem& aOther) {
+    return !(*this == aOther);
+  }
+};
+
+class nsTextShadowArray {
+  public:
+    void* operator new(size_t aBaseSize, PRUint32 aArrayLen) {
+      // We can allocate both this nsTextShadowArray and the
+      // actual array in one allocation. The amount of memory to
+      // allocate is equal to the class's size + the number of bytes for all
+      // but the first array item (because aBaseSize includes one
+      // item, see the private declarations)
+      return ::operator new(aBaseSize +
+                            (aArrayLen - 1) * sizeof(nsTextShadowItem));
+    }
+
+    nsTextShadowArray(PRUint32 aArrayLen) :
+      mLength(aArrayLen), mRefCnt(0)
+    {
+      MOZ_COUNT_CTOR(nsTextShadowArray);
+      for (PRUint32 i = 1; i < mLength; ++i) {
+        // Make sure we call the constructors of each nsTextShadowItem
+        // (the first one is called for us because we declared it under private)
+        new (&mArray[i]) nsTextShadowItem();
+      }
+    }
+    ~nsTextShadowArray() {
+      MOZ_COUNT_DTOR(nsTextShadowArray);
+      for (PRUint32 i = 1; i < mLength; ++i) {
+        mArray[i].~nsTextShadowItem();
+      }
+    }
+
+    nsrefcnt AddRef() { return ++mRefCnt; }
+    nsrefcnt Release();
+
+    PRUint32 Length() const { return mLength; }
+    nsTextShadowItem* ShadowAt(PRUint32 i) {
+      NS_ABORT_IF_FALSE(i < mLength, "Accessing too high an index in the text shadow array!");
+      return &mArray[i];
+    }
+    const nsTextShadowItem* ShadowAt(PRUint32 i) const {
+      NS_ABORT_IF_FALSE(i < mLength, "Accessing too high an index in the text shadow array!");
+      return &mArray[i];
+    }
+
+  private:
+    PRUint32 mLength;
+    PRUint32 mRefCnt;
+    nsTextShadowItem mArray[1]; // This MUST be the last item
+};
+
 struct nsStyleText {
   nsStyleText(void);
   nsStyleText(const nsStyleText& aOther);
   ~nsStyleText(void);
 
   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
     return aContext->AllocateFromShell(sz);
   }
@@ -690,16 +764,18 @@ struct nsStyleText {
   PRUint8 mTextAlign;                   // [inherited] see nsStyleConsts.h
   PRUint8 mTextTransform;               // [inherited] see nsStyleConsts.h
   PRUint8 mWhiteSpace;                  // [inherited] see nsStyleConsts.h
 
   nsStyleCoord  mLetterSpacing;         // [inherited] 
   nsStyleCoord  mLineHeight;            // [inherited] 
   nsStyleCoord  mTextIndent;            // [inherited] 
   nsStyleCoord  mWordSpacing;           // [inherited] 
+
+  nsRefPtr<nsTextShadowArray> mShadowArray; // [inherited] NULL in case of a zero-length
   
   PRBool WhiteSpaceIsSignificant() const {
     return mWhiteSpace == NS_STYLE_WHITESPACE_PRE ||
            mWhiteSpace == NS_STYLE_WHITESPACE_PRE_WRAP;
   }
 
   PRBool WhiteSpaceCanWrap() const {
     return mWhiteSpace == NS_STYLE_WHITESPACE_NORMAL ||
diff --git a/layout/style/test/property_database.js b/layout/style/test/property_database.js
--- a/layout/style/test/property_database.js
+++ b/layout/style/test/property_database.js
@@ -1494,22 +1494,22 @@ var gCSSProperties = {
 		inherited: true,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "0" ],
 		other_values: [ "2em", "5%", "-10px" ],
 		invalid_values: []
 	},
 	"text-shadow": {
 		domProp: "textShadow",
-		inherited: false,
-		backend_only: true,
+		inherited: true,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "none" ],
+		prerequisites: { "color": "blue" },
 		other_values: [ "2px 2px", "2px 2px 1px", "2px 2px green", "2px 2px 1px green", "green 2px 2px", "green 2px 2px 1px", "green 2px 2px, blue 1px 3px 4px", "currentColor 3px 3px", "blue 2px 2px, currentColor 1px 2px" ],
-		invalid_values: [ "3% 3%", "2px 2px 2px 2px", "2px 2px, none" ]
+		invalid_values: [ "3% 3%", "2px 2px 2px 2px", "2px 2px, none", "none, 2px 2px", "inherit, 2px 2px", "2px 2px, inherit" ]
 	},
 	"text-transform": {
 		domProp: "textTransform",
 		inherited: true,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "none" ],
 		other_values: [ "capitalize", "uppercase", "lowercase" ],
 		invalid_values: []
