Add support for -moz-intrinsic, -moz-min-intrinsic, -moz-shrink-wrap, and -moz-fill for width, min-width, and max-width.  b=311415

diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -1253,6 +1253,26 @@ static PRBool GetAbsoluteCoord(const nsS
   return PR_FALSE;
 }
 
+// Handles only -moz-intrinsic and -moz-min-intrinsic, since the others
+// (-moz-fill and -moz-shrink-wrap) have no effect on intrinsic widths.
+static PRBool
+GetIntrinsicCoord(const nsStyleCoord& aStyle
+                  nsIRenderingContext* aRenderingContext,
+                  nsIFrame* aFrame,
+                  nscoord& aResult)
+{
+  if (aStyle.GetUnit() == eStyleUnit_Enumerated &&
+      (aStyle.GetIntValue() == NS_STYLE_WIDTH_INTRINSIC ||
+       aStyle.GetIntValue() == NS_STYLE_WIDTH_MIN_INTRINSIC)) {
+    if (aStyle.GetIntValue() == NS_STYLE_WIDTH_INTRINSIC)
+      aResult = aFrame->GetPrefWidth(aRenderingContext);
+    else
+      aResult = aFrame->GetMinWidth(aRenderingContext);
+    return PR_TRUE;
+  }
+  return PR_FALSE;
+}
+
 #undef  DEBUG_INTRINSIC_WIDTH
 
 #ifdef DEBUG_INTRINSIC_WIDTH
@@ -1298,10 +1318,18 @@ nsLayoutUtils::IntrinsicForContainer(nsI
   // If we have a specified width (or a specified 'min-width' greater
   // than the specified 'max-width', which works out to the same thing),
   // don't even bother getting the frame's intrinsic width.
-  if (styleWidth.GetUnit() != eStyleUnit_Coord &&
-      (styleMinWidth.GetUnit() != eStyleUnit_Coord ||
-       styleMaxWidth.GetUnit() != eStyleUnit_Coord ||
-       styleMaxWidth.GetCoordValue() > styleMinWidth.GetCoordValue())) {
+  if (styleWidth.GetUnit() == eStyleUnit_Enumerated &&
+      (styleWidth.GetIntValue() == NS_STYLE_WIDTH_INTRINSIC ||
+       styleWidth.GetIntValue() == NS_STYLE_WIDTH_MIN_INTRINSIC)) {
+    // -moz-shrink-wrap and -moz-fill enumerated widths compute intrinsic
+    // widths just like auto.
+    // For -moz-intrinsic and -moz-min-intrinsic, we handle them like
+    // specified widths, but ignore -moz-box-sizing.
+    boxSizing = NS_STYLE_BOX_SIZING_CONTENT;
+  } else if (styleWidth.GetUnit() != eStyleUnit_Coord &&
+             (styleMinWidth.GetUnit() != eStyleUnit_Coord ||
+              styleMaxWidth.GetUnit() != eStyleUnit_Coord ||
+              styleMaxWidth.GetCoordValue() > styleMinWidth.GetCoordValue())) {
 #ifdef DEBUG_INTRINSIC_WIDTH
     ++gNoiseIndent;
 #endif
@@ -1364,7 +1392,8 @@ nsLayoutUtils::IntrinsicForContainer(nsI
   pctTotal += pctOutsideWidth;
 
   nscoord w;
-  if (GetAbsoluteCoord(styleWidth, aRenderingContext, aFrame, w)) {
+  if (GetAbsoluteCoord(styleWidth, aRenderingContext, aFrame, w) ||
+      GetIntrinsicCoord(styleWidth, aRenderingContext, aFrame, w)) {
     result = AddPercents(aType, w + coordOutsideWidth, pctOutsideWidth);
   }
   else if (aType == MIN_WIDTH && eStyleUnit_Percent == styleWidth.GetUnit() &&
@@ -1377,14 +1406,16 @@ nsLayoutUtils::IntrinsicForContainer(nsI
   }
 
   nscoord maxw;
-  if (GetAbsoluteCoord(styleMaxWidth, aRenderingContext, aFrame, maxw)) {
+  if (GetAbsoluteCoord(styleMaxWidth, aRenderingContext, aFrame, maxw) ||
+      GetIntrinsicCoord(styleMaxWidth, aRenderingContext, aFrame, maxw)) {
     maxw = AddPercents(aType, maxw + coordOutsideWidth, pctOutsideWidth);
     if (result > maxw)
       result = maxw;
   }
 
   nscoord minw;
-  if (GetAbsoluteCoord(styleMinWidth, aRenderingContext, aFrame, minw)) {
+  if (GetAbsoluteCoord(styleMinWidth, aRenderingContext, aFrame, minw) ||
+      GetIntrinsicCoord(styleMinWidth, aRenderingContext, aFrame, minw)) {
     minw = AddPercents(aType, minw + coordOutsideWidth, pctOutsideWidth);
     if (result < minw)
       result = minw;
@@ -1442,8 +1473,56 @@ nsLayoutUtils::ComputeWidthDependentValu
   if (eStyleUnit_Percent == aCoord.GetUnit()) {
     return NSToCoordFloor(aContainingBlockWidth * aCoord.GetPercentValue());
   }
+  NS_NOTREACHED("unexpected width value");
   return 0;
 }
+
+/* static */ nscoord
+nsLayoutUtils::ComputeWidthValue(
+                 nsIRenderingContext* aRenderingContext,
+                 nsIFrame*            aFrame,
+                 nscoord              aContainingBlockWidth,
+                 nscoord              aContentEdgeToBoxSizing,
+                 nscoord              aBoxSizingToMarginEdge,
+                 const nsStyleCoord&  aCoord)
+{
+  NS_PRECONDITION(aFrame, "non-null frame expected");
+  NS_PRECONDITION(aRenderingContext, "non-null rendering context expected");
+  NS_PRECONDITION(aContainingBlockWidth != NS_UNCONSTRAINEDSIZE,
+                  "unconstrained widths no longer supported");
+
+  nscoord result;
+  if (GetAbsoluteCoord(aCoord, aRenderingContext, aFrame, result)) {
+    return result - aContentEdgeToBoxSizing;
+  }
+  if (eStyleUnit_Percent == aCoord.GetUnit()) {
+    return NSToCoordFloor(aContainingBlockWidth * aCoord.GetPercentValue()) -
+           aContentEdgeToBoxSizing;
+  }
+  if (eStyleUnit_Enumerated == aCoord.GetUnit()) {
+    PRInt32 val = aCoord.GetIntValue();
+    switch (val) {
+      case NS_STYLE_WIDTH_INTRINSIC:
+        return aFrame->GetPrefWidth(aRenderingContext);
+      case NS_STYLE_WIDTH_MIN_INTRINSIC:
+        return aFrame->GetMinWidth(aRenderingContext);
+      case NS_STYLE_WIDTH_SHRINK_WRAP:
+        {
+          nscoord pref = aFrame->GetPrefWidth(aRenderingContext),
+                   min = aFrame->GetMinWidth(aRenderingContext),
+                  fill = aContainingBlockWidth -
+                         (aBoxSizingToMarginEdge + aContentEdgeToBoxSizing);
+          return PR_MAX(min, PR_MIN(pref, fill));
+        }
+      case NS_STYLE_WIDTH_FILL:
+        return aContainingBlockWidth -
+               (aBoxSizingToMarginEdge + aContentEdgeToBoxSizing);
+    }
+  }
+  NS_NOTREACHED("unexpected width value");
+  return 0;
+}
+
 
 /* static */ nscoord
 nsLayoutUtils::ComputeHeightDependentValue(
@@ -1474,6 +1553,7 @@ nsLayoutUtils::ComputeHeightDependentVal
       return NSToCoordFloor(aContainingBlockHeight * aCoord.GetPercentValue());
     }
   }
+  NS_NOTREACHED("unexpected height value");
   return 0;
 }
 
@@ -1493,7 +1573,7 @@ nsLayoutUtils::ComputeSizeWithIntrinsicD
 nsLayoutUtils::ComputeSizeWithIntrinsicDimensions(
                    nsIRenderingContext* aRenderingContext,
                    nsIFrame* aFrame, nsSize aIntrinsicSize, nsSize aCBSize,
-                   nsSize aBorder, nsSize aPadding)
+                   nsSize aMargin, nsSize aBorder, nsSize aPadding)
 {
   const nsStylePosition *stylePos = aFrame->GetStylePosition();
   // Handle intrinsic sizes and their interaction with
@@ -1515,30 +1595,32 @@ nsLayoutUtils::ComputeSizeWithIntrinsicD
     case NS_STYLE_BOX_SIZING_PADDING:
       boxSizingAdjust += aPadding;
   }
+  nscoord boxSizingToMarginEdgeWidth =
+    aMargin.width + aBorder.width + aPadding.width - boxSizingAdjust.width
 
   nscoord width, minWidth, maxWidth, height, minHeight, maxHeight;
 
   if (!isAutoWidth) {
-    width = nsLayoutUtils::ComputeWidthDependentValue(aRenderingContext,
-              aFrame, aCBSize.width, stylePos->mWidth) -
-            boxSizingAdjust.width;
+    width = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
+              aFrame, aCBSize.width, boxSizingAdjust.width,
+              boxSizingToMarginEdgeWidth, stylePos->mWidth);
     if (width < 0)
       width = 0;
   }
 
   if (stylePos->mMaxWidth.GetUnit() != eStyleUnit_Null) {
-    maxWidth = nsLayoutUtils::ComputeWidthDependentValue(aRenderingContext,
-                 aFrame, aCBSize.width, stylePos->mMaxWidth) -
-               boxSizingAdjust.width;
+    maxWidth = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
+                 aFrame, aCBSize.width, boxSizingAdjust.width
+                 boxSizingToMarginEdgeWidth, stylePos->mMaxWidth);
     if (maxWidth < 0)
       maxWidth = 0;
   } else {
     maxWidth = nscoord_MAX;
   }
 
-  minWidth = nsLayoutUtils::ComputeWidthDependentValue(aRenderingContext,
-               aFrame, aCBSize.width, stylePos->mMinWidth) -
-             boxSizingAdjust.width;
+  minWidth = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
+               aFrame, aCBSize.width, boxSizingAdjust.width
+               boxSizingToMarginEdgeWidth, stylePos->mMinWidth);
   if (minWidth < 0)
     minWidth = 0;
 
diff --git a/layout/base/nsLayoutUtils.h b/layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h
+++ b/layout/base/nsLayoutUtils.h
@@ -527,12 +527,33 @@ public:
                                        nsIFrame* aFrame,
                                        IntrinsicWidthType aType);
 
+  /*
+   * Convert nsStyleCoord to nscoord when percentages depend on the
+   * containing block width.
+   */
   static nscoord ComputeWidthDependentValue(
                    nsIRenderingContext* aRenderingContext,
                    nsIFrame*            aFrame,
                    nscoord              aContainingBlockWidth,
                    const nsStyleCoord&  aCoord);
 
+  /*
+   * Convert nsStyleCoord to nscoord when percentages depend on the
+   * containing block width, and enumerated values are for width,
+   * min-width, or max-width.
+   */
+  static nscoord ComputeWidthValue(
+                   nsIRenderingContext* aRenderingContext,
+                   nsIFrame*            aFrame,
+                   nscoord              aContainingBlockWidth,
+                   nscoord              aContentEdgeToBoxSizing,
+                   nscoord              aBoxSizingToMarginEdge,
+                   const nsStyleCoord&  aCoord);
+
+  /*
+   * Convert nsStyleCoord to nscoord when percentages depend on the
+   * containing block height.
+   */
   static nscoord ComputeHeightDependentValue(
                    nsIRenderingContext* aRenderingContext,
                    nsIFrame*            aFrame,
@@ -542,7 +563,7 @@ public:
   static nsSize ComputeSizeWithIntrinsicDimensions(
                     nsIRenderingContext* aRenderingContext,
                     nsIFrame* aFrame, nsSize aIntrinsicSize, nsSize aCBSize,
-                    nsSize aBorder, nsSize aPadding);
+                    nsSize aMargin, nsSize aBorder, nsSize aPadding);
 
   // Implement nsIFrame::GetPrefWidth in terms of nsIFrame::AddInlinePrefWidth
   static nscoord PrefWidthFromInline(nsIFrame* aFrame,
diff --git a/layout/base/nsStyleConsts.h b/layout/base/nsStyleConsts.h
--- a/layout/base/nsStyleConsts.h
+++ b/layout/base/nsStyleConsts.h
@@ -427,6 +427,12 @@
 #define NS_STYLE_FONT_PULL_DOWN_MENU						14
 #define NS_STYLE_FONT_LIST											15
 #define NS_STYLE_FONT_FIELD											16
+
+// See nsStylePosition::mWidth, mMinWidth, mMaxWidth
+#define NS_STYLE_WIDTH_INTRINSIC                0
+#define NS_STYLE_WIDTH_MIN_INTRINSIC            1
+#define NS_STYLE_WIDTH_SHRINK_WRAP              2
+#define NS_STYLE_WIDTH_FILL                     3
 
 // See nsStylePosition.mPosition
 #define NS_STYLE_POSITION_STATIC                0
diff --git a/layout/forms/nsGfxCheckboxControlFrame.cpp b/layout/forms/nsGfxCheckboxControlFrame.cpp
--- a/layout/forms/nsGfxCheckboxControlFrame.cpp
+++ b/layout/forms/nsGfxCheckboxControlFrame.cpp
@@ -257,6 +257,9 @@ nsGfxCheckboxControlFrame::PaintCheckBox
   const nsStyleBorder* myBorder = mCheckButtonFaceStyle->GetStyleBorder();
   const nsStyleBackground* myBackground = mCheckButtonFaceStyle->GetStyleBackground();
 
+  NS_ASSERTION(myPosition->mWidth.GetUnit() == eStyleUnit_Coord &&
+               myPosition->mHeight.GetUnit() == eStyleUnit_Coord,
+               "styles for :-moz-checkbox are incorrect or author-accessible");
   nscoord width = myPosition->mWidth.GetCoordValue();
   nscoord height = myPosition->mHeight.GetCoordValue();
   // Position the button centered within the control's rectangle.
diff --git a/layout/forms/nsGfxRadioControlFrame.cpp b/layout/forms/nsGfxRadioControlFrame.cpp
--- a/layout/forms/nsGfxRadioControlFrame.cpp
+++ b/layout/forms/nsGfxRadioControlFrame.cpp
@@ -135,6 +135,9 @@ nsGfxRadioControlFrame::PaintRadioButton
   const nsStylePadding* myPadding = mRadioButtonFaceStyle->GetStylePadding();
   const nsStylePosition* myPosition = mRadioButtonFaceStyle->GetStylePosition();
 
+  NS_ASSERTION(myPosition->mWidth.GetUnit() == eStyleUnit_Coord &&
+               myPosition->mHeight.GetUnit() == eStyleUnit_Coord,
+               "styles for :-moz-radio are incorrect or author-accessible");
   nscoord width = myPosition->mWidth.GetCoordValue();
   nscoord height = myPosition->mHeight.GetCoordValue();
   // Position the button centered within the radio control's rectangle.
diff --git a/layout/generic/nsAbsoluteContainingBlock.cpp b/layout/generic/nsAbsoluteContainingBlock.cpp
--- a/layout/generic/nsAbsoluteContainingBlock.cpp
+++ b/layout/generic/nsAbsoluteContainingBlock.cpp
@@ -229,6 +229,7 @@ nsAbsoluteContainingBlock::FrameDependsO
     // width, min-width, and max-width are all lengths, 'none', or enumerated,
     // then our frame width does not depend on the parent width.
     // Note that borders never depend on the parent width
+    // XXX All of the enumerated values except -moz-fill are ok too.
     if (pos->mWidth.GetUnit() != eStyleUnit_Coord ||
         pos->mMinWidth.GetUnit() != eStyleUnit_Coord ||
         !IsFixedMaxSize(pos->mMaxWidth.GetUnit()) ||
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -3143,29 +3143,31 @@ nsFrame::ComputeSize(nsIRenderingContext
     case NS_STYLE_BOX_SIZING_PADDING:
       boxSizingAdjust += aPadding;
   }
+  nscoord boxSizingToMarginEdgeWidth =
+    aMargin.width + aBorder.width + aPadding.width - boxSizingAdjust.width
 
   // Compute width
 
   if (stylePos->mWidth.GetUnit() != eStyleUnit_Auto) {
     result.width =
-      nsLayoutUtils::ComputeWidthDependentValue(aRenderingContext, this,
-        aCBSize.width, stylePos->mWidth) -
-      boxSizingAdjust.width;
+      nsLayoutUtils::ComputeWidthValue(aRenderingContext, this,
+        aCBSize.width, boxSizingAdjust.width, boxSizingToMarginEdgeWidth,
+        stylePos->mWidth);
   }
 
   if (stylePos->mMaxWidth.GetUnit() != eStyleUnit_Null) {
     nscoord maxWidth =
-      nsLayoutUtils::ComputeWidthDependentValue(aRenderingContext, this,
-        aCBSize.width, stylePos->mMaxWidth) -
-      boxSizingAdjust.width;
+      nsLayoutUtils::ComputeWidthValue(aRenderingContext, this,
+        aCBSize.width, boxSizingAdjust.width, boxSizingToMarginEdgeWidth,
+        stylePos->mMaxWidth);
     if (maxWidth < result.width)
       result.width = maxWidth;
   }
 
   nscoord minWidth =
-    nsLayoutUtils::ComputeWidthDependentValue(aRenderingContext, this,
-      aCBSize.width, stylePos->mMinWidth) -
-    boxSizingAdjust.width;
+    nsLayoutUtils::ComputeWidthValue(aRenderingContext, this,
+      aCBSize.width, boxSizingAdjust.width, boxSizingToMarginEdgeWidth,
+      stylePos->mMinWidth);
   if (minWidth > result.width)
     result.width = minWidth;
 
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -190,6 +190,19 @@ nsCSSOffsetState::ComputeWidthDependentV
                                                       aCoord);
 }
 
+inline nscoord
+nsCSSOffsetState::ComputeWidthValue(nscoord aContainingBlockWidth,
+                                    nscoord aContentEdgeToBoxSizing,
+                                    nscoord aBoxSizingToMarginEdge,
+                                    const nsStyleCoord& aCoord)
+{
+  return nsLayoutUtils::ComputeWidthValue(rendContext, frame,
+                                          aContainingBlockWidth,
+                                          aContentEdgeToBoxSizing,
+                                          aBoxSizingToMarginEdge,
+                                          aCoord);
+}
+
 inline void
 nsCSSOffsetState::ComputeHeightDependentValue(nscoord aContainingBlockHeight,
                                               const nsStyleCoord& aCoord,
@@ -633,8 +646,11 @@ GetIntrinsicSizeFor(nsIFrame* aFrame, ns
   return result;
 }
 
-nscoord
-nsHTMLReflowState::CalculateHorizBorderPaddingMargin(nscoord aContainingBlockWidth)
+void
+nsHTMLReflowState::CalculateHorizBorderPaddingMargin(
+                       nscoord aContainingBlockWidth,
+                       nscoord* aInsideBoxSizing,
+                       nscoord* aOutsideBoxSizing)
 {
   const nsMargin& border = mStyleBorder->GetBorder();
   nsMargin padding, margin;
@@ -675,8 +691,19 @@ nsHTMLReflowState::CalculateHorizBorderP
     }
   }
 
-  return padding.left + padding.right + border.left + border.right +
-         margin.left + margin.right;
+  nscoord outside =
+    padding.LeftRight() + border.LeftRight() + margin.LeftRight();
+  switch (mStylePosition->mBoxSizing) {
+    case NS_STYLE_BOX_SIZING_BORDER:
+      inside += border.LeftRight();
+      // fall through
+    case NS_STYLE_BOX_SIZING_PADDING:
+      inside += padding.LeftRight();
+  }
+  outside -= inside;
+  *aInsideBoxSizing = inside;
+  *aOutsideBoxSizing = outside;
+  return;
 }
 
 /**
@@ -721,10 +748,10 @@ nsHTMLReflowState::CalculateHypothetical
   // If it's a replaced element and it has a 'auto' value for 'width', see if we
   // can get the intrinsic size. This will allow us to exactly determine both the
   // left and right edges
-  nsStyleUnit widthUnit = mStylePosition->mWidth.GetUnit();
+  PRBool isAutoWidth = mStylePosition->mWidth.GetUnit() == eStyleUnit_Auto;
   nsSize      intrinsicSize;
   PRBool      knowIntrinsicSize = PR_FALSE;
-  if (NS_FRAME_IS_REPLACED(mFrameType) && (eStyleUnit_Auto == widthUnit)) {
+  if (NS_FRAME_IS_REPLACED(mFrameType) && isAutoWidth) {
     // See if we can get the intrinsic size of the element
     knowIntrinsicSize = GetIntrinsicSizeFor(frame, intrinsicSize);
   }
@@ -740,22 +767,23 @@ nsHTMLReflowState::CalculateHypothetical
 
   } else {
     // It's either a replaced inline-level element or a block-level element
-    nscoord horizBorderPaddingMargin;
 
     // Determine the total amount of horizontal border/padding/margin that
     // the element would have had if it had been in the flow. Note that we
     // ignore any 'auto' and 'inherit' values
-    horizBorderPaddingMargin = CalculateHorizBorderPaddingMargin(aBlockContentWidth);
-
-    if (NS_FRAME_IS_REPLACED(mFrameType) && (eStyleUnit_Auto == widthUnit)) {
+    nscoord insideBoxSizing, outsideBoxSizing;
+    CalculateHorizBorderPaddingMargin(aBlockContentWidth,
+                                      &insideBoxSizing, &outsideBoxSizing);
+
+    if (NS_FRAME_IS_REPLACED(mFrameType) && isAutoWidth) {
       // It's a replaced element with an 'auto' width so the box width is
       // its intrinsic size plus any border/padding/margin
       if (knowIntrinsicSize) {
-        boxWidth = intrinsicSize.width + horizBorderPaddingMargin;
+        boxWidth = intrinsicSize.width + outsideBoxSizing + insideBoxSizing;
         knowBoxWidth = PR_TRUE;
       }
 
-    } else if (eStyleUnit_Auto == widthUnit) {
+    } else if (isAutoWidth) {
       // The box width is the containing block width
       boxWidth = aBlockContentWidth;
       knowBoxWidth = PR_TRUE;
@@ -764,9 +792,9 @@ nsHTMLReflowState::CalculateHypothetical
       // We need to compute it. It's important we do this, because if it's
       // percentage based this computed value may be different from the comnputed
       // value calculated using the absolute containing block width
-      ComputeWidthDependentValue(aBlockContentWidth, mStylePosition->mWidth,
-                                 boxWidth);
-      boxWidth += horizBorderPaddingMargin;
+      boxWidth = ComputeWidthValue(aBlockContentWidth, mStylePosition->mWidth,
+                                   insideBoxSizing, outsideBoxSizing) + 
+                 insideBoxSizing + outsideBoxSizing;
       knowBoxWidth = PR_TRUE;
     }
   }
@@ -1611,8 +1639,20 @@ nsHTMLReflowState::InitConstraints(nsPre
       } else {
         NS_ASSERTION(widthUnit == mStylePosition->mWidth.GetUnit(),
                      "unexpected width unit change");
-        ComputeWidthDependentValue(aContainingBlockWidth,
-                                   mStylePosition->mWidth, mComputedWidth);
+        nscoord inside = 0, outside = mComputedBorderPadding.LeftRight() +
+                                      mComputedMargin.LeftRight();
+        switch (mStylePosition->mBoxSizing) {
+          case NS_STYLE_BOX_SIZING_BORDER:
+            inside = mComputedBorderPadding.LeftRight();
+            break;
+          case NS_STYLE_BOX_SIZING_PADDING:
+            inside = mComputedPadding.LeftRight();
+            break;
+        }
+        outside -= inside;
+
+        mComputedWidth = ComputeWidthValue(aContainingBlockWidth, inside,
+                                           outside, mStylePosition->mWidth);
       }
 
       // Calculate the computed height
@@ -2058,15 +2098,27 @@ nsHTMLReflowState::ComputeMinMaxValues(n
                                        nscoord aContainingBlockHeight,
                                        const nsHTMLReflowState* aContainingBlockRS)
 {
-  ComputeWidthDependentValue(aContainingBlockWidth, mStylePosition->mMinWidth,
-                             mComputedMinWidth);
+  nscoord inside = 0, outside = mComputedBorderPadding.LeftRight() +
+                                mComputedMargin.LeftRight();
+  switch (mStylePosition->mBoxSizing) {
+    case NS_STYLE_BOX_SIZING_BORDER:
+      inside = mComputedBorderPadding.LeftRight();
+      break;
+    case NS_STYLE_BOX_SIZING_PADDING:
+      inside = mComputedPadding.LeftRight();
+      break;
+  }
+  outside -= inside;
+
+  mComputedMinWidth = ComputeWidthValue(aContainingBlockWidth, inside,
+                                        outside, mStylePosition->mMinWidth);
 
   if (eStyleUnit_Null == mStylePosition->mMaxWidth.GetUnit()) {
     // Specified value of 'none'
     mComputedMaxWidth = NS_UNCONSTRAINEDSIZE;  // no limit
   } else {
-    ComputeWidthDependentValue(aContainingBlockWidth, mStylePosition->mMaxWidth,
-                               mComputedMaxWidth);
+    mComputedMaxWidth = ComputeWidthValue(aContainingBlockWidth, inside,
+                                          outside, mStylePosition->mMaxWidth);
   }
 
   // If the computed value of 'min-width' is greater than the value of
diff --git a/layout/generic/nsHTMLReflowState.h b/layout/generic/nsHTMLReflowState.h
--- a/layout/generic/nsHTMLReflowState.h
+++ b/layout/generic/nsHTMLReflowState.h
@@ -188,9 +188,31 @@ private:
   void ComputePadding(nscoord aContainingBlockWidth);
 
 protected:
+
+  /*
+   * Convert nsStyleCoord to nscoord when percentages depend on the
+   * containing block width.
+   */
+  // XXX Make aResult a return value
   inline void ComputeWidthDependentValue(nscoord aContainingBlockWidth,
                                          const nsStyleCoord& aCoord,
                                          nscoord& aResult);
+
+  /*
+   * Convert nsStyleCoord to nscoord when percentages depend on the
+   * containing block width, and enumerated values are for width,
+   * min-width, or max-width.
+   */
+  inline nscoord ComputeWidthValue(nscoord aContainingBlockWidth,
+                                   nscoord aContentEdgeToBoxSizing,
+                                   nscoord aBoxSizingToMarginEdge,
+                                   const nsStyleCoord& aCoord);
+
+  /*
+   * Convert nsStyleCoord to nscoord when percentages depend on the
+   * containing block height.
+   */
+  // XXX Make aResult a return value
   inline void ComputeHeightDependentValue(nscoord aContainingBlockHeight,
                                           const nsStyleCoord& aCoord,
                                           nscoord& aResult);
diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -702,6 +702,16 @@ HasPercentageUnitSide(const nsStyleSides
   return PR_FALSE;
 }
 
+inline PRBool
+WidthDependsOnContainer(const nsStyleCoord& aCoord)
+{
+  return aCoord.GetUnit() == eStyleUnit_Percent ||
+         (aCoord.GetUnit() == eStyleUnit_Enumerated &&
+          (aCoord.GetIntValue() == NS_STYLE_WIDTH_FILL ||
+          (aCoord.GetIntValue() == NS_STYLE_WIDTH_SHRINK_WRAP)));
+
+}
+
 static PRBool
 IsPercentageAware(const nsIFrame* aFrame)
 {
@@ -733,9 +743,9 @@ IsPercentageAware(const nsIFrame* aFrame
 
   const nsStylePosition* pos = aFrame->GetStylePosition();
 
-  if (eStyleUnit_Percent == pos->mWidth.GetUnit() ||
-      eStyleUnit_Percent == pos->mMaxWidth.GetUnit() ||
-      eStyleUnit_Percent == pos->mMinWidth.GetUnit() ||
+  if (WidthDependsOnContainer(pos->mWidth) ||
+      WidthDependsOnContainer(pos->mMaxWidth) ||
+      WidthDependsOnContainer(pos->mMinWidth) ||
       eStyleUnit_Percent == pos->mOffset.GetRightUnit() ||
       eStyleUnit_Percent == pos->mOffset.GetLeftUnit()) {
     return PR_TRUE;
diff --git a/layout/generic/nsSpacerFrame.cpp b/layout/generic/nsSpacerFrame.cpp
--- a/layout/generic/nsSpacerFrame.cpp
+++ b/layout/generic/nsSpacerFrame.cpp
@@ -109,6 +109,7 @@ SpacerFrame::Reflow(nsPresContext*      
   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
   aStatus = NS_FRAME_COMPLETE;
 
+  // XXX Should use containing block size!
   nsSize percentBase(aReflowState.availableWidth, aReflowState.availableHeight);
   if (percentBase.width == NS_UNCONSTRAINEDSIZE)
     percentBase.width = 0;
@@ -131,6 +132,11 @@ SpacerFrame::GetDesiredSize(nsHTMLReflow
   aMetrics.width = 0;
   aMetrics.height = 0;
 
+  // XXX This code doesn't handle some value types for width and height,
+  // doesn't handle min/max-width/height, doesn't handle border and
+  // padding, doesn't handle 'ch' units, doesn't handle the enumerated
+  // values on width, etc.  But it probably doesn't much matter.
+
   const nsStylePosition* position = GetStylePosition();
 
   PRUint8 type = GetType();
@@ -164,7 +170,7 @@ SpacerFrame::GetDesiredSize(nsHTMLReflow
     else if (eStyleUnit_Percent == unit) 
     {
       float factor = position->mHeight.GetPercentValue();
-      aMetrics.width = NSToCoordRound(factor * aPercentBase.height);
+      aMetrics.height = NSToCoordRound(factor * aPercentBase.height);
     }
     break;
   }
diff --git a/layout/style/nsCSSKeywordList.h b/layout/style/nsCSSKeywordList.h
--- a/layout/style/nsCSSKeywordList.h
+++ b/layout/style/nsCSSKeywordList.h
@@ -102,6 +102,7 @@ CSS_KEY(-moz-ethiopic-halehame-ti-et, _m
 CSS_KEY(-moz-ethiopic-halehame-ti-et, _moz_ethiopic_halehame_ti_et)
 CSS_KEY(-moz-field, _moz_field)
 CSS_KEY(-moz-fieldtext, _moz_fieldtext)
+CSS_KEY(-moz-fill, _moz_fill)
 CSS_KEY(-moz-grabbing, _moz_grabbing)
 CSS_KEY(-moz-grab, _moz_grab)
 CSS_KEY(-moz-grid-group, _moz_grid_group)
@@ -119,6 +120,7 @@ CSS_KEY(-moz-inline-box, _moz_inline_box
 CSS_KEY(-moz-inline-box, _moz_inline_box)
 CSS_KEY(-moz-inline-grid, _moz_inline_grid)
 CSS_KEY(-moz-inline-stack, _moz_inline_stack)
+CSS_KEY(-moz-intrinsic, _moz_intrinsic)
 CSS_KEY(-moz-japanese-formal, _moz_japanese_formal)
 CSS_KEY(-moz-japanese-informal, _moz_japanese_informal)
 CSS_KEY(-moz-kannada, _moz_kannada)
@@ -146,6 +148,7 @@ CSS_KEY(-moz-menuhovertext, _moz_menuhov
 CSS_KEY(-moz-menuhovertext, _moz_menuhovertext)
 CSS_KEY(-moz-menubarhovertext, _moz_menubarhovertext)
 CSS_KEY(-moz-middle-with-baseline, _moz_middle_with_baseline)
+CSS_KEY(-moz-min-intrinsic, _moz_min_intrinsic)
 CSS_KEY(-moz-myanmar, _moz_myanmar)
 CSS_KEY(-moz-none, _moz_none)
 CSS_KEY(-moz-oriya, _moz_oriya)
@@ -159,6 +162,7 @@ CSS_KEY(-moz-scrollbars-none, _moz_scrol
 CSS_KEY(-moz-scrollbars-none, _moz_scrollbars_none)
 CSS_KEY(-moz-scrollbars-vertical, _moz_scrollbars_vertical)
 CSS_KEY(-moz-show-background, _moz_show_background)
+CSS_KEY(-moz-shrink-wrap, _moz_shrink_wrap)
 CSS_KEY(-moz-simp-chinese-formal, _moz_simp_chinese_formal)
 CSS_KEY(-moz-simp-chinese-informal, _moz_simp_chinese_informal)
 CSS_KEY(-moz-spinning, _moz_spinning)
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -3516,6 +3516,7 @@ CSSParserImpl::DoTransferTempData(nsCSSD
 #define VARIANT_AHLP (VARIANT_AH | VARIANT_LP)
 #define VARIANT_AHI  (VARIANT_AH | VARIANT_INTEGER)
 #define VARIANT_AHK  (VARIANT_AH | VARIANT_KEYWORD)
+#define VARIANT_AHKLP (VARIANT_AHLP | VARIANT_KEYWORD)
 #define VARIANT_AUK  (VARIANT_AUTO | VARIANT_URL | VARIANT_KEYWORD)
 #define VARIANT_AHUK (VARIANT_AH | VARIANT_URL | VARIANT_KEYWORD)
 #define VARIANT_AHL  (VARIANT_AH | VARIANT_LENGTH)
@@ -3524,6 +3525,7 @@ CSSParserImpl::DoTransferTempData(nsCSSD
 #define VARIANT_HKF  (VARIANT_HK | VARIANT_FREQUENCY)
 #define VARIANT_HKL  (VARIANT_HK | VARIANT_LENGTH)
 #define VARIANT_HKLP (VARIANT_HK | VARIANT_LP)
+#define VARIANT_HKLPO (VARIANT_HKLP | VARIANT_NONE)
 #define VARIANT_HL   (VARIANT_INHERIT | VARIANT_LENGTH)
 #define VARIANT_HI   (VARIANT_INHERIT | VARIANT_INTEGER)
 #define VARIANT_HLP  (VARIANT_HL | VARIANT_PERCENT)
@@ -4574,8 +4576,10 @@ PRBool CSSParserImpl::ParseSingleValuePr
     return ParseVariant(aErrorCode, aValue, VARIANT_HK,
                         nsCSSProps::kBoxSizingKTable);
   case eCSSProperty_height:
+    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_AHLP, nsnull);
   case eCSSProperty_width:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_AHLP, nsnull);
+    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_AHKLP,
+                                nsCSSProps::kWidthKTable);
   case eCSSProperty_force_broken_image_icon:
     return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HI, nsnull);
   case eCSSProperty_caption_side:
@@ -4659,11 +4663,15 @@ PRBool CSSParserImpl::ParseSingleValuePr
   case eCSSProperty_marks:
     return ParseMarks(aErrorCode, aValue);
   case eCSSProperty_max_height:
+    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HLPO, nsnull);
   case eCSSProperty_max_width:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HLPO, nsnull);
+    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HKLPO,
+                                nsCSSProps::kWidthKTable);
   case eCSSProperty_min_height:
+    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HLP, nsnull);
   case eCSSProperty_min_width:
-    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HLP, nsnull);
+    return ParsePositiveVariant(aErrorCode, aValue, VARIANT_HKLP,
+                                nsCSSProps::kWidthKTable);
   case eCSSProperty_opacity:
     return ParseVariant(aErrorCode, aValue, VARIANT_HN, nsnull);
   case eCSSProperty_orphans:
diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -372,9 +372,9 @@ CSS_PROP_CONTENT(marker-offset, marker_o
 CSS_PROP_CONTENT(marker-offset, marker_offset, MarkerOffset, Content, mMarkerOffset, eCSSType_Value, nsnull)
 CSS_PROP_BACKENDONLY(marks, marks, Marks, Page, mMarks, eCSSType_Value, kPageMarksKTable)
 CSS_PROP_POSITION(max-height, max_height, MaxHeight, Position, mMaxHeight, eCSSType_Value, nsnull)
-CSS_PROP_POSITION(max-width, max_width, MaxWidth, Position, mMaxWidth, eCSSType_Value, nsnull)
+CSS_PROP_POSITION(max-width, max_width, MaxWidth, Position, mMaxWidth, eCSSType_Value, kWidthKTable)
 CSS_PROP_POSITION(min-height, min_height, MinHeight, Position, mMinHeight, eCSSType_Value, nsnull)
-CSS_PROP_POSITION(min-width, min_width, MinWidth, Position, mMinWidth, eCSSType_Value, nsnull)
+CSS_PROP_POSITION(min-width, min_width, MinWidth, Position, mMinWidth, eCSSType_Value, kWidthKTable)
 CSS_PROP_DISPLAY(opacity, opacity, Opacity, Display, mOpacity, eCSSType_Value, nsnull) // XXX bug 3935
 CSS_PROP_BACKENDONLY(orphans, orphans, Orphans, Breaks, mOrphans, eCSSType_Value, nsnull)
 CSS_PROP_SHORTHAND(outline, outline, Outline)
@@ -446,7 +446,7 @@ CSS_PROP_BACKENDONLY(volume, volume, Vol
 CSS_PROP_BACKENDONLY(volume, volume, Volume, Aural, mVolume, eCSSType_Value, kVolumeKTable)
 CSS_PROP_TEXT(white-space, white_space, WhiteSpace, Text, mWhiteSpace, eCSSType_Value, kWhitespaceKTable)
 CSS_PROP_BACKENDONLY(widows, widows, Widows, Breaks, mWidows, eCSSType_Value, nsnull)
-CSS_PROP_POSITION(width, width, Width, Position, mWidth, eCSSType_Value, nsnull)
+CSS_PROP_POSITION(width, width, Width, Position, mWidth, eCSSType_Value, kWidthKTable)
 CSS_PROP_TEXT(word-spacing, word_spacing, WordSpacing, Text, mWordSpacing, eCSSType_Value, nsnull)
 CSS_PROP_POSITION(z-index, z_index, ZIndex, Position, mZIndex, eCSSType_Value, nsnull)
 
diff --git a/layout/style/nsCSSProps.cpp b/layout/style/nsCSSProps.cpp
--- a/layout/style/nsCSSProps.cpp
+++ b/layout/style/nsCSSProps.cpp
@@ -941,6 +941,14 @@ const PRInt32 nsCSSProps::kWhitespaceKTa
   eCSSKeyword_UNKNOWN,-1
 };
 
+const PRInt32 nsCSSProps::kWidthKTable[] = {
+  eCSSKeyword__moz_intrinsic, NS_STYLE_WIDTH_INTRINSIC,
+  eCSSKeyword__moz_min_intrinsic, NS_STYLE_WIDTH_MIN_INTRINSIC,
+  eCSSKeyword__moz_shrink_wrap, NS_STYLE_WIDTH_SHRINK_WRAP,
+  eCSSKeyword__moz_fill, NS_STYLE_WIDTH_FILL,
+  eCSSKeyword_UNKNOWN,-1
+};
+
 // Specific keyword tables for XUL.properties
 const PRInt32 nsCSSProps::kBoxAlignKTable[] = {
   eCSSKeyword_stretch,  NS_STYLE_BOX_ALIGN_STRETCH,
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -189,6 +189,7 @@ public:
   static const PRInt32 kVisibilityKTable[];
   static const PRInt32 kVolumeKTable[];
   static const PRInt32 kWhitespaceKTable[];
+  static const PRInt32 kWidthKTable[]; // also min-width, max-width
 };
 
 #endif /* nsCSSProps_h___ */
diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -2229,8 +2229,8 @@ nsComputedDOMStyle::GetWidth(nsIDOMCSSVa
                           &nsComputedDOMStyle::GetCBContentWidth,
                           nscoord_MAX);
     
-    SetValueToCoord(val, positionData->mWidth, nsnull, nsnull,
-                    minWidth, maxWidth);
+    SetValueToCoord(val, positionData->mWidth, nsnull,
+                    nsCSSProps::kWidthKTable, minWidth, maxWidth);
   }
 
   return CallQueryInterface(val, aValue);
@@ -2255,7 +2255,8 @@ nsComputedDOMStyle::GetMaxWidth(nsIDOMCS
   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 
   SetValueToCoord(val, GetStylePosition()->mMaxWidth,
-                  &nsComputedDOMStyle::GetCBContentWidth);
+                  &nsComputedDOMStyle::GetCBContentWidth,
+                  nsCSSProps::kWidthKTable);
 
   return CallQueryInterface(val, aValue);
 }
@@ -2279,7 +2280,8 @@ nsComputedDOMStyle::GetMinWidth(nsIDOMCS
   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 
   SetValueToCoord(val, GetStylePosition()->mMinWidth,
-                  &nsComputedDOMStyle::GetCBContentWidth);
+                  &nsComputedDOMStyle::GetCBContentWidth,
+                  nsCSSProps::kWidthKTable);
 
   return CallQueryInterface(val, aValue);
 }
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -250,6 +250,7 @@ nscoord CalcLength(const nsCSSValue& aVa
 #define SETCOORD_LPH    (SETCOORD_LP | SETCOORD_INHERIT)
 #define SETCOORD_LPAH   (SETCOORD_LP | SETCOORD_AH)
 #define SETCOORD_LPEH   (SETCOORD_LP | SETCOORD_ENUMERATED | SETCOORD_INHERIT)
+#define SETCOORD_LPAEH  (SETCOORD_LPAH | SETCOORD_ENUMERATED)
 #define SETCOORD_LE     (SETCOORD_LENGTH | SETCOORD_ENUMERATED)
 #define SETCOORD_LEH    (SETCOORD_LE | SETCOORD_INHERIT)
 #define SETCOORD_IA     (SETCOORD_INTEGER | SETCOORD_AUTO)
@@ -3582,11 +3583,11 @@ nsRuleNode::ComputePositionData(nsStyleS
     pos->mWidth.SetIntValue((PRInt32)(posData.mWidth.GetFloatValue()), eStyleUnit_Proportional);
   else 
     SetCoord(posData.mWidth, pos->mWidth, parentPos->mWidth,
-             SETCOORD_LPAH, aContext, mPresContext, inherited);
+             SETCOORD_LPAEH, aContext, mPresContext, inherited);
   SetCoord(posData.mMinWidth, pos->mMinWidth, parentPos->mMinWidth,
-           SETCOORD_LPH, aContext, mPresContext, inherited);
+           SETCOORD_LPEH, aContext, mPresContext, inherited);
   if (! SetCoord(posData.mMaxWidth, pos->mMaxWidth, parentPos->mMaxWidth,
-                 SETCOORD_LPH, aContext, mPresContext, inherited)) {
+                 SETCOORD_LPEH, aContext, mPresContext, inherited)) {
     if (eCSSUnit_None == posData.mMaxWidth.GetUnit()) {
       pos->mMaxWidth.Reset();
     }
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -636,9 +636,9 @@ struct nsStylePosition : public nsStyleS
 #endif
   
   nsStyleSides  mOffset;                // [reset] XXX WHICH TYPES?
-  nsStyleCoord  mWidth;                 // [reset] coord, percent, auto
-  nsStyleCoord  mMinWidth;              // [reset] coord, percent
-  nsStyleCoord  mMaxWidth;              // [reset] coord, percent, null
+  nsStyleCoord  mWidth;                 // [reset] coord, percent, auto, enum
+  nsStyleCoord  mMinWidth;              // [reset] coord, percent, enum
+  nsStyleCoord  mMaxWidth;              // [reset] coord, percent, null, enum
   nsStyleCoord  mHeight;                // [reset] coord, percent, auto
   nsStyleCoord  mMinHeight;             // [reset] coord, percent
   nsStyleCoord  mMaxHeight;             // [reset] coord, percent, null
diff --git a/layout/style/test/property_database.js b/layout/style/test/property_database.js
--- a/layout/style/test/property_database.js
+++ b/layout/style/test/property_database.js
@@ -855,7 +855,7 @@ var gCSSProperties = {
 		initial_values: [ " auto" ],
 		/* XXX these have prerequisites */
 		other_values: [ "15px", "3em", "15%" ],
-		invalid_values: []
+		invalid_values: [ "none", "-moz-intrinsic", "-moz-min-intrinsic", "-moz-shrink-wrap", "-moz-fill" ]
 	},
 	"left": {
 		domProp: "left",
@@ -987,14 +987,14 @@ var gCSSProperties = {
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "none" ],
 		other_values: [ "30px", "50%", "0" ],
-		invalid_values: [ "auto" ]
+		invalid_values: [ "auto", "-moz-intrinsic", "-moz-min-intrinsic", "-moz-shrink-wrap", "-moz-fill" ]
 	},
 	"max-width": {
 		domProp: "maxWidth",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "none" ],
-		other_values: [ "30px", "50%", "0" ],
+		other_values: [ "30px", "50%", "0", "-moz-intrinsic", "-moz-min-intrinsic", "-moz-shrink-wrap", "-moz-fill" ],
 		invalid_values: [ "auto" ]
 	},
 	"min-height": {
@@ -1003,14 +1003,14 @@ var gCSSProperties = {
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "0" ],
 		other_values: [ "30px", "50%" ],
-		invalid_values: [ "auto", "none" ]
+		invalid_values: [ "auto", "none", "-moz-intrinsic", "-moz-min-intrinsic", "-moz-shrink-wrap", "-moz-fill" ]
 	},
 	"min-width": {
 		domProp: "minWidth",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "0" ],
-		other_values: [ "30px", "50%" ],
+		other_values: [ "30px", "50%", "-moz-intrinsic", "-moz-min-intrinsic", "-moz-shrink-wrap", "-moz-fill" ],
 		invalid_values: [ "auto", "none" ]
 	},
 	"opacity": {
@@ -1468,8 +1468,8 @@ var gCSSProperties = {
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ " auto" ],
 		/* XXX these have prerequisites */
-		other_values: [ "15px", "3em", "15%" ],
-		invalid_values: []
+		other_values: [ "15px", "3em", "15%", "-moz-intrinsic", "-moz-min-intrinsic", "-moz-shrink-wrap", "-moz-fill" ],
+		invalid_values: [ "none" ]
 	},
 	"word-spacing": {
 		domProp: "wordSpacing",
diff --git a/layout/tables/BasicTableLayoutStrategy.cpp b/layout/tables/BasicTableLayoutStrategy.cpp
--- a/layout/tables/BasicTableLayoutStrategy.cpp
+++ b/layout/tables/BasicTableLayoutStrategy.cpp
@@ -117,6 +117,8 @@ GetWidthInfo(nsIRenderingContext *aRende
     float prefPercent = 0.0f;
     PRBool hasSpecifiedWidth = PR_FALSE;
 
+    // XXXldb Should we consider -moz-box-sizing?
+
     switch (aStylePos->mWidth.GetUnit()) {
         case eStyleUnit_Coord: {
                 hasSpecifiedWidth = PR_TRUE;
@@ -138,19 +140,34 @@ GetWidthInfo(nsIRenderingContext *aRende
                 prefPercent = aStylePos->mWidth.GetPercentValue();
             }
             break;
+        case eStyleUnit_Enumerated: {
+                switch (aStylePos->mWidth.GetIntValue()) {
+                    case NS_STYLE_WIDTH_INTRINSIC:
+                        // 'width' only affects pref width, not min
+                        // width, so don't change anything
+                        break;
+                    case NS_STYLE_WIDTH_MIN_INTRINSIC:
+                        prefCoord = minCoord;
+                        break;
+                    case NS_STYLE_WIDTH_SHRINK_WRAP:
+                    case NS_STYLE_WIDTH_FILL:
+                        // act just like 'width: auto'
+                        break;
+                }
+            }
+            break;
         default:
             break;
     }
 
+    nscoord w;
+    PRBool handleW = PR_FALSE;
     switch (aStylePos->mMaxWidth.GetUnit()) {
         // XXX To really implement 'max-width' well, we'd need to store
         // it separately on the columns.
         case eStyleUnit_Coord: {
-                nscoord w = aStylePos->mMaxWidth.GetCoordValue();
-                if (w < minCoord)
-                    minCoord = w;
-                if (w < prefCoord)
-                    prefCoord = w;
+                w = aStylePos->mMaxWidth.GetCoordValue();
+                handleW = PR_TRUE;
             }
             break;
         case eStyleUnit_Percent: {
@@ -159,17 +176,39 @@ GetWidthInfo(nsIRenderingContext *aRende
                     prefPercent = p;
             }
             break;
+        case eStyleUnit_Enumerated: {
+                switch (aStylePos->mMaxWidth.GetIntValue()) {
+                    case NS_STYLE_WIDTH_INTRINSIC:
+                    case NS_STYLE_WIDTH_SHRINK_WRAP:
+                        // for 'max-width', '-moz-shrink-wrap' is like
+                        // '-moz-intrinsic'
+                        w = aCellFrame->GetPrefWidth(aRenderingContext);
+                        handleW = PR_TRUE;
+                        break;
+                    case NS_STYLE_WIDTH_MIN_INTRINSIC:
+                        w = aCellFrame->GetMinWidth(aRenderingContext);
+                        handleW = PR_TRUE;
+                        break;
+                    case NS_STYLE_WIDTH_FILL:
+                        // act just like 'width: auto'
+                        break;
+                }
+            }
+            break;
         default:
             break;
     }
-
+    if (handleW) {
+        if (w < minCoord)
+            minCoord = w;
+        if (w < prefCoord)
+            prefCoord = w;
+    }
+
+    handleW = PR_FALSE;
     switch (aStylePos->mMinWidth.GetUnit()) {
         case eStyleUnit_Coord: {
-                nscoord w = aStylePos->mMinWidth.GetCoordValue();
-                if (w > minCoord)
-                    minCoord = w;
-                if (w > prefCoord)
-                    prefCoord = w;
+                w = aStylePos->mMinWidth.GetCoordValue();
             }
             break;
         case eStyleUnit_Percent: {
@@ -178,8 +217,33 @@ GetWidthInfo(nsIRenderingContext *aRende
                     prefPercent = p;
             }
             break;
+        case eStyleUnit_Enumerated: {
+                switch (aStylePos->mMaxWidth.GetIntValue()) {
+                    case NS_STYLE_WIDTH_INTRINSIC:
+                        w = aCellFrame->GetPrefWidth(aRenderingContext);
+                        handleW = PR_TRUE;
+                        break;
+                    case NS_STYLE_WIDTH_MIN_INTRINSIC:
+                    case NS_STYLE_WIDTH_SHRINK_WRAP:
+                        // for 'min-width', '-moz-shrink-wrap' is like
+                        // '-moz-min-intrinsic'
+                        w = aCellFrame->GetMinWidth(aRenderingContext);
+                        handleW = PR_TRUE;
+                        break;
+                    case NS_STYLE_WIDTH_FILL:
+                        // act just like 'width: auto'
+                        break;
+                }
+            }
+            break;
         default:
             break;
+    }
+    if (handleW) {
+        if (w > minCoord)
+            minCoord = w;
+        if (w > prefCoord)
+            prefCoord = w;
     }
 
     // XXX Should col frame have border/padding considered?
diff --git a/layout/tables/FixedTableLayoutStrategy.cpp b/layout/tables/FixedTableLayoutStrategy.cpp
--- a/layout/tables/FixedTableLayoutStrategy.cpp
+++ b/layout/tables/FixedTableLayoutStrategy.cpp
@@ -98,12 +98,16 @@ FixedTableLayoutStrategy::GetMinWidth(ns
         }
         const nsStyleCoord *styleWidth =
             &colFrame->GetStylePosition()->mWidth;
-        if (styleWidth->GetUnit() == eStyleUnit_Coord) {
-            result += styleWidth->GetCoordValue();
+        if (styleWidth->GetUnit() == eStyleUnit_Coord ||
+            styleWidth->GetUnit() == eStyleUnit_Chars) {
+            result += nsLayoutUtils::ComputeWidthValue(aRenderingContext,
+                        colFrame, 0, 0, 0, styleWidth);
         } else if (styleWidth->GetUnit() == eStyleUnit_Percent) {
             // do nothing
         } else {
-            NS_ASSERTION(styleWidth->GetUnit() == eStyleUnit_Auto, "bad width");
+            NS_ASSERTION(styleWidth->GetUnit() == eStyleUnit_Auto ||
+                         styleWidth->GetUnit() == eStyleUnit_Enumerated,
+                         "bad width");
 
             // The 'table-layout: fixed' algorithm considers only cells
             // in the first row.
@@ -113,7 +117,10 @@ FixedTableLayoutStrategy::GetMinWidth(ns
                 cellMap->GetCellInfoAt(0, col, &originates, &colSpan);
             if (cellFrame) {
                 styleWidth = &cellFrame->GetStylePosition()->mWidth;
-                if (styleWidth->GetUnit() == eStyleUnit_Coord) {
+                if (styleWidth->GetUnit() == eStyleUnit_Coord ||
+                    styleWidth->GetUnit() == eStyleUnit_Chars ||
+                    (styleWidth->GetUnit() == eStyleUnit_Enumerated &&
+                     (styleWidth->GetIntValue() != NS_STYLE_WIDTH_FILL))) {
                     nscoord cellWidth = nsLayoutUtils::IntrinsicForContainer(
                         aRenderingContext, cellFrame, nsLayoutUtils::MIN_WIDTH);
                     if (colSpan > 1) {
@@ -133,6 +140,7 @@ FixedTableLayoutStrategy::GetMinWidth(ns
                         result -= spacing * (colSpan - 1);
                     }
                 }
+                // else, for 'auto' and '-moz-fill', do nothing
                 // XXXldb Bug 364989
             }
         }
@@ -209,15 +217,19 @@ FixedTableLayoutStrategy::ComputeColumnW
         const nsStyleCoord *styleWidth =
             &colFrame->GetStylePosition()->mWidth;
         nscoord colWidth;
-        if (styleWidth->GetUnit() == eStyleUnit_Coord) {
-            colWidth = styleWidth->GetCoordValue();
+        if (styleWidth->GetUnit() == eStyleUnit_Coord ||
+            styleWidth->GetUnit() == eStyleUnit_Chars) {
+            colWidth = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
+                         colFrame, 0, 0, 0, styleWidth);
         } else if (styleWidth->GetUnit() == eStyleUnit_Percent) {
             float pct = styleWidth->GetPercentValue();
             colWidth = NSToCoordFloor(pct * float(tableWidth));
             colFrame->AddPrefPercent(pct);
             pctTotal += pct;
         } else {
-            NS_ASSERTION(styleWidth->GetUnit() == eStyleUnit_Auto, "bad width");
+            NS_ASSERTION(styleWidth->GetUnit() == eStyleUnit_Auto ||
+                         styleWidth->GetUnit() == eStyleUnit_Enumerated,
+                         "bad width");
 
             // The 'table-layout: fixed' algorithm considers only cells
             // in the first row.
@@ -227,8 +239,12 @@ FixedTableLayoutStrategy::ComputeColumnW
                 cellMap->GetCellInfoAt(0, col, &originates, &colSpan);
             if (cellFrame) {
                 styleWidth = &cellFrame->GetStylePosition()->mWidth;
-                if (styleWidth->GetUnit() == eStyleUnit_Coord) {
-                    colWidth = styleWidth->GetCoordValue();
+                if (styleWidth->GetUnit() == eStyleUnit_Coord ||
+                    styleWidth->GetUnit() == eStyleUnit_Chars ||
+                    (styleWidth->GetUnit() == eStyleUnit_Enumerated &&
+                     (styleWidth->GetIntValue() != NS_STYLE_WIDTH_FILL))) {
+                    colWidth = nsLayoutUtils::IntrinsicForContainer(
+                        aRenderingContext, cellFrame, nsLayoutUtils::MIN_WIDTH);
                 } else if (styleWidth->GetUnit() == eStyleUnit_Percent) {
                     float pct = styleWidth->GetPercentValue();
                     colWidth = NSToCoordFloor(pct * float(tableWidth));
@@ -236,6 +252,7 @@ FixedTableLayoutStrategy::ComputeColumnW
                     colFrame->AddPrefPercent(pct);
                     pctTotal += pct;
                 } else {
+                    // 'auto' and '-moz-fill'
                     colWidth = unassignedMarker;
                 }
                 if (colWidth != unassignedMarker) {
diff --git a/layout/tables/nsTableFrame.cpp b/layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp
+++ b/layout/tables/nsTableFrame.cpp
@@ -3369,6 +3369,7 @@ nsTableFrame::IsAutoWidth(PRBool* aIsPct
     // seems silly.
     *aIsPctWidth = width.GetUnit() == eStyleUnit_Percent &&
                    width.GetPercentValue() > 0.0f;
+    // Should this handle -moz-fill and -moz-shrink-wrap?
   }
   return width.GetUnit() == eStyleUnit_Auto;
 }
@@ -3416,6 +3417,7 @@ nsTableFrame::IsAutoLayout()
 nsTableFrame::IsAutoLayout()
 {
   // a fixed-layout inline-table must have a width
+  // XXX Is everything ok with the new width values?
   return GetStyleTable()->mLayoutStrategy == NS_STYLE_TABLE_LAYOUT_AUTO ||
          (GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_INLINE_TABLE &&
           GetStylePosition()->mWidth.GetUnit() == eStyleUnit_Auto);
diff --git a/layout/xul/base/src/grid/nsGridRowLeafFrame.cpp b/layout/xul/base/src/grid/nsGridRowLeafFrame.cpp
--- a/layout/xul/base/src/grid/nsGridRowLeafFrame.cpp
+++ b/layout/xul/base/src/grid/nsGridRowLeafFrame.cpp
@@ -84,7 +84,7 @@ nsGridRowLeafFrame::GetBorderAndPadding(
 
   PRBool isHorizontal = IsHorizontal();
 
-  nsBoxLayoutState state((nsPresContext*) PresContext());
+  nsBoxLayoutState state(PresContext());
 
   PRInt32 firstIndex = 0;
   PRInt32 lastIndex = 0;
diff --git a/layout/xul/base/src/nsBox.cpp b/layout/xul/base/src/nsBox.cpp
--- a/layout/xul/base/src/nsBox.cpp
+++ b/layout/xul/base/src/nsBox.cpp
@@ -684,6 +684,7 @@ nsIBox::AddCSSPrefSize(nsBoxLayoutState&
         aSize.width = position->mWidth.GetCoordValue();
         widthSet = PR_TRUE;
     }
+    // XXX HANDLE ENUMERATED WIDTHS?
 
     if (position->mHeight.GetUnit() == eStyleUnit_Coord) {
         aSize.height = position->mHeight.GetCoordValue();     
@@ -770,6 +771,7 @@ nsIBox::AddCSSMinSize(nsBoxLayoutState& 
         aSize.width = 0;
         widthSet = PR_TRUE;
     }
+    // XXX HANDLE ENUMERATED WIDTHS?
 
     if (position->mMinHeight.GetUnit() == eStyleUnit_Coord) {
         nscoord min = position->mMinHeight.GetCoordValue();
@@ -836,6 +838,7 @@ nsIBox::AddCSSMaxSize(nsBoxLayoutState& 
         aSize.width = max;
         widthSet = PR_TRUE;
     }
+    // XXX HANDLE ENUMERATED WIDTHS?
 
     if (position->mMaxHeight.GetUnit() == eStyleUnit_Coord) {
         nscoord max = position->mMaxHeight.GetCoordValue();
