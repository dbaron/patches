From: L. David Baron <dbaron@dbaron.org>

Fix all ReflowChildren methods in table code to avoid unnecessary NS_METHOD and NS_IMETHOD, and one that takes an overflow area to handle it correctly.  (Bug 542595)

diff --git a/layout/tables/nsTableFrame.cpp b/layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp
+++ b/layout/tables/nsTableFrame.cpp
@@ -1883,17 +1883,17 @@ nsTableFrame::ReflowTable(nsHTMLReflowMe
   }
   // Constrain our reflow width to the computed table width (of the 1st in flow).
   // and our reflow height to our avail height minus border, padding, cellspacing
   aDesiredSize.width = aReflowState.ComputedWidth() +
                        aReflowState.mComputedBorderPadding.LeftRight();
   nsTableReflowState reflowState(*PresContext(), aReflowState, *this,
                                  aDesiredSize.width, aAvailHeight);
   ReflowChildren(reflowState, aStatus, aLastChildReflowed,
-                 aDesiredSize.mOverflowArea);
+                 aDesiredSize.mOverflowAreas);
 
   ReflowColGroups(aReflowState.rendContext);
   return rv;
 }
 
 nsIFrame*
 nsTableFrame::GetFirstBodyRowGroupFrame()
 {
@@ -2653,35 +2653,35 @@ nsTableFrame::PlaceRepeatedFooter(nsTabl
               aReflowState.x, aReflowState.y,
               NS_FRAME_INVALIDATE_ON_MOVE, footerStatus);
   PlaceChild(aReflowState, aTfoot, desiredSize, origTfootRect,
              origTfootVisualOverflow);
 }
                     
 // Reflow the children based on the avail size and reason in aReflowState
 // update aReflowMetrics a aStatus
-NS_METHOD
+nsresult
 nsTableFrame::ReflowChildren(nsTableReflowState& aReflowState,
                              nsReflowStatus&     aStatus,
                              nsIFrame*&          aLastChildReflowed,
-                             nsRect&             aOverflowArea)
+                             nsOverflowAreas&    aOverflowAreas)
 {
   aStatus = NS_FRAME_COMPLETE;
   aLastChildReflowed = nsnull;
 
   nsIFrame* prevKidFrame = nsnull;
   nsresult  rv = NS_OK;
   nscoord   cellSpacingY = GetCellSpacingY();
 
   nsPresContext* presContext = PresContext();
   // XXXldb Should we be checking constrained height instead?
   PRBool isPaginated = presContext->IsPaginated() &&
                        NS_UNCONSTRAINEDSIZE != aReflowState.availSize.height;
 
-  aOverflowArea = nsRect (0, 0, 0, 0);
+  aOverflowAreas.SetZero();
 
   PRBool reflowAllKids = aReflowState.reflowState.ShouldReflowAllKids() ||
                          mBits.mResizedColumns ||
                          IsGeometryDirty();
 
   RowGroupArray rowGroups;
   nsTableRowGroupFrame *thead, *tfoot;
   OrderRowGroups(rowGroups, &thead, &tfoot);
@@ -2894,17 +2894,17 @@ nsTableFrame::ReflowChildren(nsTableRefl
       }
       aReflowState.y += kidRect.height;
 
       // If our height is constrained then update the available height.
       if (NS_UNCONSTRAINEDSIZE != aReflowState.availSize.height) {
         aReflowState.availSize.height -= cellSpacingY + kidRect.height;
       }
     }
-    ConsiderChildOverflow(aOverflowArea, kidFrame);
+    ConsiderChildOverflow(aOverflowAreas, kidFrame);
   }
 
   // We've now propagated the column resizes and geometry changes to all
   // the children.
   mBits.mResizedColumns = PR_FALSE;
   ClearGeometryDirty();
 
   return rv;
diff --git a/layout/tables/nsTableFrame.h b/layout/tables/nsTableFrame.h
--- a/layout/tables/nsTableFrame.h
+++ b/layout/tables/nsTableFrame.h
@@ -544,20 +544,20 @@ protected:
     
   // A helper function to reflow a header or footer with unconstrained height
   // to see if it should be made repeatable and also to determine its desired
   // height.
   nsresult SetupHeaderFooterChild(const nsTableReflowState& aReflowState,
                                   nsTableRowGroupFrame* aFrame,
                                   nscoord* aDesiredHeight);
 
-  NS_METHOD ReflowChildren(nsTableReflowState&  aReflowState,
-                           nsReflowStatus&      aStatus,
-                           nsIFrame*&           aLastChildReflowed,
-                           nsRect&              aOverflowArea);
+  nsresult ReflowChildren(nsTableReflowState&  aReflowState,
+                          nsReflowStatus&      aStatus,
+                          nsIFrame*&           aLastChildReflowed,
+                          nsOverflowAreas&     aOverflowAreas);
 
   // This calls the col group and column reflow methods, which do two things:
   //  (1) set all the dimensions to 0
   //  (2) notify the table about colgroups or columns with hidden visibility
   void ReflowColGroups(nsIRenderingContext* aRenderingContext);
 
   /** return the width of the table taking into account visibility collapse
     * on columns and colgroups
diff --git a/layout/tables/nsTableRowFrame.cpp b/layout/tables/nsTableRowFrame.cpp
--- a/layout/tables/nsTableRowFrame.cpp
+++ b/layout/tables/nsTableRowFrame.cpp
@@ -785,17 +785,17 @@ nscoord CalcHeightFromUnpaginatedHeight(
     for (nsIFrame* prevInFlow = aRow.GetPrevInFlow(); prevInFlow;
          prevInFlow = prevInFlow->GetPrevInFlow()) {
       height -= prevInFlow->GetSize().height;
     }
   }
   return NS_MAX(height, 0);
 }
 
-NS_METHOD 
+nsresult
 nsTableRowFrame::ReflowChildren(nsPresContext*          aPresContext,
                                 nsHTMLReflowMetrics&     aDesiredSize,
                                 const nsHTMLReflowState& aReflowState,
                                 nsTableFrame&            aTableFrame,
                                 nsReflowStatus&          aStatus)
 {
   aStatus = NS_FRAME_COMPLETE;
 
diff --git a/layout/tables/nsTableRowFrame.h b/layout/tables/nsTableRowFrame.h
--- a/layout/tables/nsTableRowFrame.h
+++ b/layout/tables/nsTableRowFrame.h
@@ -274,21 +274,21 @@ protected:
 
   nscoord ComputeCellXOffset(const nsHTMLReflowState& aState,
                              nsIFrame*                aKidFrame,
                              const nsMargin&          aKidMargin) const;
   /**
    * Called for incremental/dirty and resize reflows. If aDirtyOnly is true then
    * only reflow dirty cells.
    */
-  NS_IMETHOD ReflowChildren(nsPresContext*          aPresContext,
-                            nsHTMLReflowMetrics&     aDesiredSize,
-                            const nsHTMLReflowState& aReflowState,
-                            nsTableFrame&            aTableFrame,
-                            nsReflowStatus&          aStatus);
+  nsresult ReflowChildren(nsPresContext*           aPresContext,
+                          nsHTMLReflowMetrics&     aDesiredSize,
+                          const nsHTMLReflowState& aReflowState,
+                          nsTableFrame&            aTableFrame,
+                          nsReflowStatus&          aStatus);
 
 private:
   struct RowBits {
     unsigned mRowIndex:29;
     unsigned mHasFixedHeight:1; // set if the dominating style height on the row or any cell is pixel based
     unsigned mHasPctHeight:1;   // set if the dominating style height on the row or any cell is pct based
     unsigned mFirstInserted:1;  // if true, then it was the top most newly inserted row 
   } mBits;
diff --git a/layout/tables/nsTableRowGroupFrame.cpp b/layout/tables/nsTableRowGroupFrame.cpp
--- a/layout/tables/nsTableRowGroupFrame.cpp
+++ b/layout/tables/nsTableRowGroupFrame.cpp
@@ -337,17 +337,17 @@ CacheRowHeightsForPrinting(nsPresContext
   for (nsTableRowFrame* row = aFirstRow; row; row = row->GetNextRow()) {
     if (!row->GetPrevInFlow()) {
       row->SetHasUnpaginatedHeight(PR_TRUE);
       row->SetUnpaginatedHeight(aPresContext, row->GetSize().height);
     }
   }
 }
 
-NS_METHOD 
+nsresult
 nsTableRowGroupFrame::ReflowChildren(nsPresContext*         aPresContext,
                                      nsHTMLReflowMetrics&   aDesiredSize,
                                      nsRowGroupReflowState& aReflowState,
                                      nsReflowStatus&        aStatus,
                                      PRBool*                aPageBreakBeforeEnd)
 {
   if (aPageBreakBeforeEnd) 
     *aPageBreakBeforeEnd = PR_FALSE;
diff --git a/layout/tables/nsTableRowGroupFrame.h b/layout/tables/nsTableRowGroupFrame.h
--- a/layout/tables/nsTableRowGroupFrame.h
+++ b/layout/tables/nsTableRowGroupFrame.h
@@ -385,21 +385,21 @@ protected:
   /**
    * Reflow the frames we've already created
    *
    * @param   aPresContext presentation context to use
    * @param   aReflowState current inline state
    * @return  true if we successfully reflowed all the mapped children and false
    *            otherwise, e.g. we pushed children to the next in flow
    */
-  NS_METHOD ReflowChildren(nsPresContext*         aPresContext,
-                           nsHTMLReflowMetrics&   aDesiredSize,
-                           nsRowGroupReflowState& aReflowState,
-                           nsReflowStatus&        aStatus,
-                           PRBool*                aPageBreakBeforeEnd = nsnull);
+  nsresult ReflowChildren(nsPresContext*         aPresContext,
+                          nsHTMLReflowMetrics&   aDesiredSize,
+                          nsRowGroupReflowState& aReflowState,
+                          nsReflowStatus&        aStatus,
+                          PRBool*                aPageBreakBeforeEnd = nsnull);
 
   nsresult SplitRowGroup(nsPresContext*           aPresContext,
                          nsHTMLReflowMetrics&     aDesiredSize,
                          const nsHTMLReflowState& aReflowState,
                          nsTableFrame*            aTableFrame,
                          nsReflowStatus&          aStatus);
 
   void SplitSpanningCells(nsPresContext&           aPresContext,
