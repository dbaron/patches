From: L. David Baron <dbaron@dbaron.org>

Pass the dirty rect through, transformed appropriately, in nsSVGForeignObjectFrame::PaintSVG.  (Bug 541188)

diff --git a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
--- a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
+++ b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
@@ -233,17 +233,35 @@ nsSVGForeignObjectFrame::PaintSVG(nsSVGR
 
     gfxRect clipRect =
       nsSVGUtils::GetClipRectForFrame(this, 0.0f, 0.0f, width, height);
     nsSVGUtils::SetClipRect(gfx, GetCanvasTM(), clipRect);
   }
 
   gfx->Multiply(matrix);
 
-  nsresult rv = nsLayoutUtils::PaintFrame(ctx, kid, nsRegion(kid->GetRect()),
+  // Transform aDirtyRect.  Since we can be dealing with an arbitrary
+  // transformation, we have to transform all four corners.
+  gfxMatrix invmatrix = matrix.Invert();
+  NS_ASSERTION(!invmatrix.IsSingular(),
+               "inverse of non-singular matrix should be non-singular");
+  // Need to do something like ToCanvasBounds.  Or do we need to do
+  // all the stuff GetFrameForPoint does?
+
+  gfxRect dirtyRect = gfxRect(aDirtyRect->x, aDirtyRect->y,
+                              aDirtyRect->width, aDirtyRect->height);
+  dirtyRect = invmatrix.TransformBounds(dirtyRect);
+
+  dirtyRect.Scale(nsPresContext::AppUnitsPerCSSPixel());
+  nsRect dirtyRectNS(dirtyRect.pos.x, dirtyRect.pos.y,
+                     dirtyRect.size.width, dirtyRect.size.height);
+
+  dirtyRectNS.IntersectRect(dirtyRectNS, kid->GetRect());
+
+  nsresult rv = nsLayoutUtils::PaintFrame(ctx, kid, nsRegion(dirtyRectNS),
                                           NS_RGBA(0,0,0,0),
                                           nsLayoutUtils::PAINT_IN_TRANSFORM);
 
   gfx->Restore();
 
   return rv;
 }
 
