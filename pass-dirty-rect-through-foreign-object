From: L. David Baron <dbaron@dbaron.org>

Pass the dirty rect through, transformed appropriately, in nsSVGForeignObjectFrame::PaintSVG.  (Bug 541188)

diff --git a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
--- a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
+++ b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
@@ -201,21 +201,22 @@ nsSVGForeignObjectFrame::PaintSVG(nsSVGR
 {
   if (IsDisabled())
     return NS_OK;
 
   nsIFrame* kid = GetFirstChild(nsnull);
   if (!kid)
     return NS_OK;
 
-  gfxMatrix matrix = GetCanvasTMForChildren();
+  gfxMatrix matrixForChildren = GetCanvasTMForChildren();
+  gfxMatrix matrix = GetCanvasTM();
 
   nsIRenderingContext *ctx = aContext->GetRenderingContext(this);
 
-  if (!ctx || matrix.IsSingular()) {
+  if (!ctx || matrixForChildren.IsSingular()) {
     NS_WARNING("Can't render foreignObject element!");
     return NS_ERROR_FAILURE;
   }
 
   /* Check if we need to draw anything. */
   if (aDirtyRect) {
     PRInt32 appUnitsPerDevPx = PresContext()->AppUnitsPerDevPixel();
     if (!mRect.ToOutsidePixels(appUnitsPerDevPx).Intersects(*aDirtyRect))
@@ -228,22 +229,40 @@ nsSVGForeignObjectFrame::PaintSVG(nsSVGR
 
   if (GetStyleDisplay()->IsScrollableOverflow()) {
     float x, y, width, height;
     static_cast<nsSVGElement*>(mContent)->
       GetAnimatedLengthValues(&x, &y, &width, &height, nsnull);
 
     gfxRect clipRect =
       nsSVGUtils::GetClipRectForFrame(this, 0.0f, 0.0f, width, height);
-    nsSVGUtils::SetClipRect(gfx, GetCanvasTM(), clipRect);
+    nsSVGUtils::SetClipRect(gfx, matrix, clipRect);
   }
 
-  gfx->Multiply(matrix);
+  gfx->Multiply(matrixForChildren);
 
-  nsresult rv = nsLayoutUtils::PaintFrame(ctx, kid, nsRegion(kid->GetRect()),
+  // Transform aDirtyRect.  Since we can be dealing with an arbitrary
+  // transformation, we have to transform all four corners.
+  gfxMatrix invmatrix = matrix.Invert();
+  NS_ASSERTION(!invmatrix.IsSingular(),
+               "inverse of non-singular matrix should be non-singular");
+  // Need to do something like ToCanvasBounds.  Or do we need to do
+  // all the stuff GetFrameForPoint does?
+
+  gfxRect dirtyRect = gfxRect(aDirtyRect->x, aDirtyRect->y,
+                              aDirtyRect->width, aDirtyRect->height);
+  dirtyRect = invmatrix.TransformBounds(dirtyRect);
+
+  dirtyRect.Scale(nsPresContext::AppUnitsPerCSSPixel());
+  nsRect dirtyRectNS(dirtyRect.pos.x, dirtyRect.pos.y,
+                     dirtyRect.size.width, dirtyRect.size.height);
+
+  dirtyRectNS.IntersectRect(dirtyRectNS, kid->GetRect());
+
+  nsresult rv = nsLayoutUtils::PaintFrame(ctx, kid, nsRegion(dirtyRectNS),
                                           NS_RGBA(0,0,0,0),
                                           nsLayoutUtils::PAINT_IN_TRANSFORM);
 
   gfx->Restore();
 
   return rv;
 }
 
