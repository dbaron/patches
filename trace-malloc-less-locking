Start reducing the scope of locking in trace-malloc, and convert the PRMonitor to a PRLock.  b=376874

diff --git a/tools/trace-malloc/lib/nsTraceMalloc.c b/tools/trace-malloc/lib/nsTraceMalloc.c
--- a/tools/trace-malloc/lib/nsTraceMalloc.c
+++ b/tools/trace-malloc/lib/nsTraceMalloc.c
@@ -60,6 +60,7 @@
 #include "plhash.h"
 #include "pratom.h"
 #include "prlog.h"
+#include "prlock.h"
 #include "prmon.h"
 #include "prprf.h"
 #include "prenv.h"
@@ -296,28 +297,36 @@ static logfile   *logfile_list = NULL;
 static logfile   *logfile_list = NULL;
 static logfile   **logfile_tail = &logfile_list;
 static logfile   *logfp = &default_logfile;
-static PRMonitor *tmmon = NULL;
+static PRLock    *tmlock = NULL;
 static char      *sdlogname = NULL; /* filename for shutdown leak log */
 
 /*
  * This enables/disables trace-malloc logging.
  *
  * It is separate from suppress_tracing so that we do not have to pay
- * the performance cost of repeated PR_EnterMonitor/PR_ExitMonitor and
- * PR_IntervalNow calls when trace-malloc is disabled.
+ * the performance cost of repeated PR_GetThreadPrivate calls when
+ * trace-malloc is disabled (which is not as bad as the locking we used
+ * to have).
  */
 static int tracing_enabled = 1;
 
-#define TM_ENTER_MONITOR()                                                    \
+/*
+ * This lock must be held while manipulating the calltree, the
+ * allocations table, the log, or the tmstats.
+ *
+ * Callers should not *enter* the lock without checking suppress_tracing
+ * first; otherwise they risk trying to re-enter on the same thread.
+ */
+#define TM_ENTER_LOCK()                                                       \
     PR_BEGIN_MACRO                                                            \
-        if (tmmon)                                                            \
-            PR_EnterMonitor(tmmon);                                           \
+        if (tmlock)                                                           \
+            PR_Lock(tmlock);                                                  \
     PR_END_MACRO
 
-#define TM_EXIT_MONITOR()                                                     \
+#define TM_EXIT_LOCK()                                                        \
     PR_BEGIN_MACRO                                                            \
-        if (tmmon)                                                            \
-            PR_ExitMonitor(tmmon);                                            \
+        if (tmlock)                                                           \
+            PR_Unlock(tmlock);                                                \
     PR_END_MACRO
 
 /*
@@ -357,7 +366,7 @@ get_tm_thread()
 {
     tm_thread *t;
 
-    if (!tmmon) {
+    if (!tmlock) {
         return &main_thread;
     }
 
@@ -623,7 +632,7 @@ struct callsite {
     callsite    *kids;
 };
 
-/* NB: these counters are incremented and decremented only within tmmon. */
+/* NB: these counters are incremented and decremented only within tmlock. */
 static uint32 library_serial_generator = 0;
 static uint32 method_serial_generator = 0;
 static uint32 callsite_serial_generator = 0;
@@ -820,6 +829,12 @@ static callsite *calltree(int skip)
             break;
     }
 
+    /*
+     * FIXME: We should exit the lock while making some of the below
+     * calls into the system.  This will be fixed in bug 374829.
+     */
+    TM_ENTER_LOCK();
+
     depth = framenum;
     maxstack = (depth > tmstats.calltree_maxstack);
     if (maxstack)
@@ -905,7 +920,7 @@ static callsite *calltree(int skip)
                                             &lfdset_hashallocops, NULL);
                 if (!libraries) {
                     tmstats.btmalloc_failures++;
-                    return NULL;
+                    goto fail;
                 }
             }
             hash = PL_HashString(library);
@@ -928,7 +943,7 @@ static callsite *calltree(int skip)
                 }
                 if (!he) {
                     tmstats.btmalloc_failures++;
-                    return NULL;
+                    goto fail;
                 }
                 le = (lfdset_entry *) he;
             }
@@ -952,7 +967,7 @@ static callsite *calltree(int skip)
                                             &lfdset_hashallocops, NULL);
                 if (!filenames) {
                     tmstats.btmalloc_failures++;
-                    return NULL;
+                    goto fail;
                 }
             }
             hash = PL_HashString(filename);
@@ -974,7 +989,7 @@ static callsite *calltree(int skip)
                 }
                 if (!he) {
                     tmstats.btmalloc_failures++;
-                    return NULL;
+                    goto fail;
                 }
                 le = (lfdset_entry *) he;
             }
@@ -1001,7 +1016,7 @@ static callsite *calltree(int skip)
             demangledname = (char *)malloc(MAX_UNMANGLED_NAME_LEN);
             if (!_SymUnDName(symbol,demangledname,MAX_UNMANGLED_NAME_LEN)) {
                 free(demangledname);
-                return 0;
+                goto fail;
             }
             method = demangledname;
             offset = (char*)pc - (char*)(symbol->Address);
@@ -1022,7 +1037,7 @@ static callsite *calltree(int skip)
                 if (method != noname) {
                     free((void*) method);
                 }
-                return NULL;
+                goto fail;
             }
         }
         hash = PL_HashString(method);
@@ -1048,7 +1063,7 @@ static callsite *calltree(int skip)
                 if (method != noname) {
                     free((void*) method);
                 }
-                return NULL;
+                goto fail;
             }
             le = (lfdset_entry *) he;
         }
@@ -1064,7 +1079,7 @@ static callsite *calltree(int skip)
             site = malloc(sizeof(callsite));
             if (!site) {
                 tmstats.btmalloc_failures++;
-                return NULL;
+                goto fail;
             }
 
             /* Update parent and max-kids-per-parent stats. */
@@ -1107,7 +1122,13 @@ static callsite *calltree(int skip)
         depth++;
     if (depth > tmstats.calltree_maxdepth)
         tmstats.calltree_maxdepth = depth;
+
+    TM_EXIT_LOCK();
     return site;
+
+  fail:
+    TM_EXIT_LOCK();
+    return NULL;
 }
 
 #else /*XP_UNIX*/
@@ -1130,6 +1151,13 @@ static callsite *calltree(void **bp)
     uint32 linenumber;
     const char* filename;
 
+    /*
+     * FIXME: We should really lock only the minimum amount that we need
+     * to in this function, because it makes some calls that could lock
+     * in the system's shared library loader.
+     */
+    TM_ENTER_LOCK();
+
     /* Reverse the stack frame list to avoid recursion. */
     bpup = NULL;
     for (depth = 0; ; depth++) {
@@ -1201,7 +1229,7 @@ static callsite *calltree(void **bp)
         /*
          * dladdr can acquire a lock inside the shared library loader.
          * Another thread might call malloc while holding that lock
-         * (when loading a shared library).  So we have to exit tmmon
+         * (when loading a shared library).  So we have to exit tmlock
          * around this call.  For details, see
          * https://bugzilla.mozilla.org/show_bug.cgi?id=363334#c3
          *
@@ -1210,12 +1238,12 @@ static callsite *calltree(void **bp)
          * and then filling in the descriptions for any that hadn't been
          * described already.  But this is easier for now.
          */
-        TM_EXIT_MONITOR();
+        TM_EXIT_LOCK();
         ok = my_dladdr((void*) pc, &info);
-        TM_ENTER_MONITOR();
+        TM_ENTER_LOCK();
         if (ok < 0) {
             tmstats.dladdr_failures++;
-            return NULL;
+            goto fail;
         }
 
         /*
@@ -1235,7 +1263,7 @@ static callsite *calltree(void **bp)
                                             &lfdset_hashallocops, NULL);
                 if (!libraries) {
                     tmstats.btmalloc_failures++;
-                    return NULL;
+                    goto fail;
                 }
             }
             hash = PL_HashString(library);
@@ -1257,7 +1285,7 @@ static callsite *calltree(void **bp)
                 }
                 if (!he) {
                     tmstats.btmalloc_failures++;
-                    return NULL;
+                    goto fail;
                 }
                 le = (lfdset_entry *) he;
             }
@@ -1281,7 +1309,7 @@ static callsite *calltree(void **bp)
                                             &lfdset_hashallocops, NULL);
                 if (!filenames) {
                     tmstats.btmalloc_failures++;
-                    return NULL;
+                    goto fail;
                 }
             }
             hash = PL_HashString(filename);
@@ -1302,7 +1330,7 @@ static callsite *calltree(void **bp)
                 }
                 if (!he) {
                     tmstats.btmalloc_failures++;
-                    return NULL;
+                    goto fail;
                 }
                 le = (lfdset_entry *) he;
             }
@@ -1332,7 +1360,7 @@ static callsite *calltree(void **bp)
         }
         if (!method) {
             tmstats.btmalloc_failures++;
-            return NULL;
+            goto fail;
         }
 
         /* Emit an 'N' (for New method, 'M' is for malloc!) event if needed. */
@@ -1344,7 +1372,7 @@ static callsite *calltree(void **bp)
             if (!methods) {
                 tmstats.btmalloc_failures++;
                 free((void*) method);
-                return NULL;
+                goto fail;
             }
         }
         hash = PL_HashString(method);
@@ -1366,7 +1394,7 @@ static callsite *calltree(void **bp)
             if (!he) {
                 tmstats.btmalloc_failures++;
                 free((void*) method);
-                return NULL;
+                goto fail;
             }
             le = (lfdset_entry *) he;
         }
@@ -1382,7 +1410,7 @@ static callsite *calltree(void **bp)
             site = __libc_malloc(sizeof(callsite));
             if (!site) {
                 tmstats.btmalloc_failures++;
-                return NULL;
+                goto fail;
             }
 
             /* Update parent and max-kids-per-parent stats. */
@@ -1427,10 +1455,20 @@ static callsite *calltree(void **bp)
         depth++;
     if (depth > tmstats.calltree_maxdepth)
         tmstats.calltree_maxdepth = depth;
+
+    TM_EXIT_LOCK();
+
     return site;
+  fail:
+    TM_EXIT_LOCK();
+    return NULL;
 }
 
 #endif
+
+/*
+ * The caller MUST NOT be holding tmlock when calling backtrace.
+ */
 
 #ifdef XP_WIN32
 
@@ -1439,14 +1477,17 @@ backtrace(int skip, tm_thread *t)
 {
     callsite *site;
 
+    t->suppress_tracing++;
+
+    site = calltree(skip);
+
+    TM_ENTER_LOCK();
     tmstats.backtrace_calls++;
-    t->suppress_tracing++;
-
-    site = calltree(skip);
     if (!site) {
         tmstats.backtrace_failures++;
         /* PR_ASSERT(tmstats.backtrace_failures < 100); */
     }
+    TM_EXIT_LOCK();
     t->suppress_tracing--;
     return site;
 }
@@ -1462,7 +1503,6 @@ backtrace(int skip, tm_thread *t)
     PLHashEntry **hep, *he;
     int i, n;
 
-    tmstats.backtrace_calls++;
     t->suppress_tracing++;
 
     /* Stack walking code adapted from Kipp's "leaky". */
@@ -1486,10 +1526,13 @@ backtrace(int skip, tm_thread *t)
     }
 
     site = calltree(bp);
+    TM_ENTER_LOCK();
+    tmstats.backtrace_calls++;
     if (!site) {
         tmstats.backtrace_failures++;
         PR_ASSERT(tmstats.backtrace_failures < 100);
     }
+    TM_EXIT_LOCK();
     t->suppress_tracing--;
     return site;
 }
@@ -1583,29 +1626,29 @@ malloc(size_t size)
     allocation *alloc;
     tm_thread *t;
 
-    if (!tracing_enabled || !PR_Initialized()) {
+    if (!tracing_enabled || !PR_Initialized() ||
+        (t = get_tm_thread())->suppress_tracing != 0) {
         return __libc_malloc(size);
     }
-
-    t = get_tm_thread();
 
     start = PR_IntervalNow();
     ptr = __libc_malloc(size);
     end = PR_IntervalNow();
-    TM_ENTER_MONITOR();
+
+    site = backtrace(1, t);
+
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
     tmstats.malloc_calls++;
     if (!ptr) {
         tmstats.malloc_failures++;
-    } else if (t->suppress_tracing == 0) {
-        site = backtrace(1, t);
+    } else {
         if (site)
             log_event5(logfp, TM_EVENT_MALLOC,
                        site->serial, start, end - start,
                        (uint32)NS_PTR_TO_INT32(ptr), size);
         if (get_allocations()) {
-            t->suppress_tracing++;
             he = PL_HashTableAdd(allocations, ptr, site);
-            t->suppress_tracing--;
             if (he) {
                 alloc = (allocation*) he;
                 alloc->size = size;
@@ -1613,7 +1656,9 @@ malloc(size_t size)
             }
         }
     }
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
+
     return ptr;
 }
 
@@ -1638,21 +1683,23 @@ calloc(size_t count, size_t size)
      *
      * Delaying NSPR calls until NSPR is initialized helps.
      */
-    if (!tracing_enabled || !PR_Initialized()) {
+    if (!tracing_enabled || !PR_Initialized() ||
+        (t = get_tm_thread())->suppress_tracing != 0) {
         return __libc_calloc(count, size);
     }
-
-    t = get_tm_thread();
 
     start = PR_IntervalNow();
     ptr = __libc_calloc(count, size);
     end = PR_IntervalNow();
-    TM_ENTER_MONITOR();
+
+    site = backtrace(1, t);
+
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
     tmstats.calloc_calls++;
     if (!ptr) {
         tmstats.calloc_failures++;
-    } else if (t->suppress_tracing == 0) {
-        site = backtrace(1, t);
+    } else {
         size *= count;
         if (site) {
             log_event5(logfp, TM_EVENT_CALLOC,
@@ -1660,9 +1707,7 @@ calloc(size_t count, size_t size)
                        (uint32)NS_PTR_TO_INT32(ptr), size);
         }
         if (get_allocations()) {
-            t->suppress_tracing++;
             he = PL_HashTableAdd(allocations, ptr, site);
-            t->suppress_tracing--;
             if (he) {
                 alloc = (allocation*) he;
                 alloc->size = size;
@@ -1670,7 +1715,8 @@ calloc(size_t count, size_t size)
             }
         }
     }
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
     return ptr;
 }
 
@@ -1687,15 +1733,15 @@ realloc(__ptr_t ptr, size_t size)
     FILE *trackfp = NULL;
     tm_thread *t;
 
-    if (!tracing_enabled || !PR_Initialized()) {
+    if (!tracing_enabled || !PR_Initialized() ||
+        (t = get_tm_thread())->suppress_tracing != 0) {
         return __libc_realloc(ptr, size);
     }
 
-    t = get_tm_thread();
-
-    TM_ENTER_MONITOR();
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
     tmstats.realloc_calls++;
-    if (t->suppress_tracing == 0) {
+    if (PR_TRUE) {
         oldptr = ptr;
         oldsite = NULL;
         oldsize = 0;
@@ -1719,21 +1765,24 @@ realloc(__ptr_t ptr, size_t size)
             }
         }
     }
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
 
     start = PR_IntervalNow();
     ptr = __libc_realloc(ptr, size);
     end = PR_IntervalNow();
 
-    TM_ENTER_MONITOR();
+    site = backtrace(1, t);
+
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
     if (!ptr && size) {
         /*
          * When realloc() fails, the original block is not freed or moved, so
          * we'll leave the allocation entry untouched.
          */
         tmstats.realloc_failures++;
-    } else if (t->suppress_tracing == 0) {
-        site = backtrace(1, t);
+    } else {
         if (site) {
             log_event8(logfp, TM_EVENT_REALLOC,
                        site->serial, start, end - start,
@@ -1742,7 +1791,6 @@ realloc(__ptr_t ptr, size_t size)
                        (uint32)NS_PTR_TO_INT32(oldptr), oldsize);
         }
         if (ptr && allocations) {
-            t->suppress_tracing++;
             if (ptr != oldptr) {
                 /*
                  * If we're reallocating (not merely allocating new space by
@@ -1762,7 +1810,6 @@ realloc(__ptr_t ptr, size_t size)
                 if (!he)
                     he = PL_HashTableAdd(allocations, ptr, site);
             }
-            t->suppress_tracing--;
             if (he) {
                 alloc = (allocation*) he;
                 alloc->size = size;
@@ -1770,7 +1817,8 @@ realloc(__ptr_t ptr, size_t size)
             }
         }
     }
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
     return ptr;
 }
 
@@ -1784,29 +1832,29 @@ valloc(size_t size)
     allocation *alloc;
     tm_thread *t;
 
-    if (!tracing_enabled || !PR_Initialized()) {
+    if (!tracing_enabled || !PR_Initialized() ||
+        (t = get_tm_thread())->suppress_tracing != 0) {
         return __libc_valloc(size);
     }
-
-    t = get_tm_thread();
 
     start = PR_IntervalNow();
     ptr = __libc_valloc(size);
     end = PR_IntervalNow();
-    TM_ENTER_MONITOR();
+
+    site = backtrace(1, t);
+
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
     tmstats.malloc_calls++; /* XXX valloc_calls ? */
     if (!ptr) {
         tmstats.malloc_failures++; /* XXX valloc_failures ? */
-    } else if (t->suppress_tracing == 0) {
-        site = backtrace(1, t);
+    } else {
         if (site)
             log_event5(logfp, TM_EVENT_MALLOC, /* XXX TM_EVENT_VALLOC? */
                        site->serial, start, end - start,
                        (uint32)NS_PTR_TO_INT32(ptr), size);
         if (get_allocations()) {
-            t->suppress_tracing++;
             he = PL_HashTableAdd(allocations, ptr, site);
-            t->suppress_tracing--;
             if (he) {
                 alloc = (allocation*) he;
                 alloc->size = size;
@@ -1814,7 +1862,8 @@ valloc(size_t size)
             }
         }
     }
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
     return ptr;
 }
 
@@ -1828,30 +1877,30 @@ memalign(size_t boundary, size_t size)
     allocation *alloc;
     tm_thread *t;
 
-    if (!tracing_enabled || !PR_Initialized()) {
+    if (!tracing_enabled || !PR_Initialized() ||
+        (t = get_tm_thread())->suppress_tracing != 0) {
         return __libc_memalign(boundary, size);
     }
-
-    t = get_tm_thread();
 
     start = PR_IntervalNow();
     ptr = __libc_memalign(boundary, size);
     end = PR_IntervalNow();
-    TM_ENTER_MONITOR();
+
+    site = backtrace(1, t);
+
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
     tmstats.malloc_calls++; /* XXX memalign_calls ? */
     if (!ptr) {
         tmstats.malloc_failures++; /* XXX memalign_failures ? */
-    } else if (t->suppress_tracing == 0) {
-        site = backtrace(1, t);
+    } else {
         if (site) {
             log_event5(logfp, TM_EVENT_MALLOC, /* XXX TM_EVENT_MEMALIGN? */
                        site->serial, start, end - start,
                        (uint32)NS_PTR_TO_INT32(ptr), size);
         }
         if (get_allocations()) {
-            t->suppress_tracing++;
             he = PL_HashTableAdd(allocations, ptr, site);
-            t->suppress_tracing--;
             if (he) {
                 alloc = (allocation*) he;
                 alloc->size = size;
@@ -1859,7 +1908,8 @@ memalign(size_t boundary, size_t size)
             }
         }
     }
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
     return ptr;
 }
 
@@ -1883,18 +1933,18 @@ free(__ptr_t ptr)
     PRUint32 start, end;
     tm_thread *t;
 
-    if (!tracing_enabled || !PR_Initialized()) {
+    if (!tracing_enabled || !PR_Initialized() ||
+        (t = get_tm_thread())->suppress_tracing != 0) {
         __libc_free(ptr);
         return;
     }
 
-    t = get_tm_thread();
-
-    TM_ENTER_MONITOR();
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
     tmstats.free_calls++;
     if (!ptr) {
         tmstats.null_free_calls++;
-    } else if (t->suppress_tracing == 0) {
+    } else {
         if (get_allocations()) {
             hep = PL_HashTableRawLookup(allocations, hash_pointer(ptr), ptr);
             he = *hep;
@@ -1914,18 +1964,21 @@ free(__ptr_t ptr)
             }
         }
     }
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
 
     start = PR_IntervalNow();
     __libc_free(ptr);
     end = PR_IntervalNow();
 
     if (size != 0) {
-        TM_ENTER_MONITOR();
+        t->suppress_tracing++;
+        TM_ENTER_LOCK();
         log_event5(logfp, TM_EVENT_FREE,
                    serial, start, end - start,
                    (uint32)NS_PTR_TO_INT32(ptr), size);
-        TM_EXIT_MONITOR();
+        TM_EXIT_LOCK();
+        t->suppress_tracing--;
     }
 }
 
@@ -1969,8 +2022,8 @@ PR_IMPLEMENT(void) NS_TraceMallocStartup
 
     /*
      * We only allow one thread until NS_TraceMallocStartup is called.
-     * When it is, we have to initialize tpIndex before allocating tmmon
-     * since get_tm_index uses NULL-tmmon to detect tpIndex being
+     * When it is, we have to initialize tpIndex before allocating tmlock
+     * since get_tm_index uses NULL-tmlock to detect tpIndex being
      * uninitialized.
      */
     main_thread.suppress_tracing++;
@@ -1978,7 +2031,7 @@ PR_IMPLEMENT(void) NS_TraceMallocStartup
     tlsmon = PR_NewMonitor();
     PR_NewThreadPrivateIndex(&tpIndex, free_tm_thread);
     PR_SetThreadPrivate(tpIndex, &main_thread);
-    tmmon = PR_NewMonitor();
+    tmlock = PR_NewLock();
     main_thread.suppress_tracing--;
 
 #ifdef XP_WIN32
@@ -2160,10 +2213,10 @@ PR_IMPLEMENT(void) NS_TraceMallocShutdow
             free((void*) fp);
         }
     }
-    if (tmmon) {
-        PRMonitor *mon = tmmon;
-        tmmon = NULL;
-        PR_DestroyMonitor(mon);
+    if (tmlock) {
+        PRLock *lock = tmlock;
+        tmlock = NULL;
+        PR_DestroyLock(lock);
     }
     if (tlsmon) {
         PR_DestroyMonitor(tlsmon);
@@ -2179,38 +2232,51 @@ PR_IMPLEMENT(void) NS_TraceMallocDisable
 PR_IMPLEMENT(void) NS_TraceMallocDisable()
 {
     logfile *fp;
-
-    TM_ENTER_MONITOR();
+    tm_thread *t = get_tm_thread();
+
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
     for (fp = logfile_list; fp; fp = fp->next)
         flush_logfile(fp);
     tracing_enabled = 0;
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
 }
 
 PR_IMPLEMENT(void) NS_TraceMallocEnable()
 {
-    TM_ENTER_MONITOR();
+    tm_thread *t = get_tm_thread();
+
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
     tracing_enabled = 1;
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
 }
 
 PR_IMPLEMENT(int) NS_TraceMallocChangeLogFD(int fd)
 {
     logfile *oldfp, *fp;
     struct stat sb;
-
-    TM_ENTER_MONITOR();
+    tm_thread *t = get_tm_thread();
+
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
     oldfp = logfp;
     if (oldfp->fd != fd) {
         flush_logfile(oldfp);
         fp = get_logfile(fd);
-        if (!fp)
+        if (!fp) {
+            TM_EXIT_LOCK();
+            t->suppress_tracing--;
             return -2;
+        }
         if (fd >= 0 && fstat(fd, &sb) == 0 && sb.st_size == 0)
             log_header(fd);
         logfp = fp;
     }
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
     return oldfp->fd;
 }
 
@@ -2238,8 +2304,10 @@ NS_TraceMallocCloseLogFD(int fd)
 NS_TraceMallocCloseLogFD(int fd)
 {
     logfile *fp;
-
-    TM_ENTER_MONITOR();
+    tm_thread *t = get_tm_thread();
+
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
 
     fp = get_logfile(fd);
     if (fp) {
@@ -2270,7 +2338,8 @@ NS_TraceMallocCloseLogFD(int fd)
         }
     }
 
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
     close(fd);
 }
 
@@ -2284,8 +2353,10 @@ NS_TraceMallocLogTimestamp(const char *c
 #ifdef XP_WIN32
     struct _timeb tb;
 #endif
-
-    TM_ENTER_MONITOR();
+    tm_thread *t = get_tm_thread();
+
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
 
     fp = logfp;
     log_byte(fp, TM_EVENT_TIMESTAMP);
@@ -2302,7 +2373,8 @@ NS_TraceMallocLogTimestamp(const char *c
 #endif
     log_string(fp, caption);
 
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
 }
 
 static PRIntn
@@ -2371,13 +2443,16 @@ NS_TraceMallocFlushLogfiles()
 NS_TraceMallocFlushLogfiles()
 {
     logfile *fp;
-
-    TM_ENTER_MONITOR();
+    tm_thread *t = get_tm_thread();
+
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
 
     for (fp = logfile_list; fp; fp = fp->next)
         flush_logfile(fp);
 
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
 }
 
 PR_IMPLEMENT(void)
@@ -2385,11 +2460,13 @@ NS_TrackAllocation(void* ptr, FILE *ofp)
 {
     PLHashEntry **hep;
     allocation *alloc;
+    tm_thread *t = get_tm_thread();
 
     fprintf(ofp, "Trying to track %p\n", (void*) ptr);
     setlinebuf(ofp);
 
-    TM_ENTER_MONITOR();
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
     if (get_allocations()) {
         hep = PL_HashTableRawLookup(allocations, hash_pointer(ptr), ptr);
         alloc = (allocation*) *hep;
@@ -2400,7 +2477,8 @@ NS_TrackAllocation(void* ptr, FILE *ofp)
             fprintf(ofp, "Not tracking %p\n", (void*) ptr);
         }
     }
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
 }
 
 #ifdef XP_WIN32
@@ -2413,32 +2491,31 @@ MallocCallback(void *ptr, size_t size, P
     allocation *alloc;
     tm_thread *t;
 
-    if (!tracing_enabled)
+    if (!tracing_enabled || (t = get_tm_thread())->suppress_tracing != 0)
         return;
 
-    t = get_tm_thread();
-
-    TM_ENTER_MONITOR();
+    site = backtrace(4, t);
+
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
     tmstats.malloc_calls++;
     if (!ptr) {
         tmstats.malloc_failures++;
-    } else if (t->suppress_tracing == 0) {
-        site = backtrace(4, t);
+    } else {
         if (site)
             log_event5(logfp, TM_EVENT_MALLOC,
                        site->serial, start, end - start,
                        (uint32)NS_PTR_TO_INT32(ptr), size);
         if (get_allocations()) {
-            t->suppress_tracing++;
             he = PL_HashTableAdd(allocations, ptr, site);
-            t->suppress_tracing--;
             if (he) {
                 alloc = (allocation*) he;
                 alloc->size = size;
             }
         }
     }
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
 }
 
 PR_IMPLEMENT(void)
@@ -2449,33 +2526,32 @@ CallocCallback(void *ptr, size_t count, 
     allocation *alloc;
     tm_thread *t;
 
-    if (!tracing_enabled)
+    if (!tracing_enabled || (t = get_tm_thread())->suppress_tracing != 0)
         return;
 
-    t = get_tm_thread();
-
-    TM_ENTER_MONITOR();
+    site = backtrace(1, t);
+
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
     tmstats.calloc_calls++;
     if (!ptr) {
         tmstats.calloc_failures++;
-    } else if (t->suppress_tracing == 0) {
-        site = backtrace(1, t);
+    } else {
         size *= count;
         if (site)
             log_event5(logfp, TM_EVENT_CALLOC,
                        site->serial, start, end - start,
                        (uint32)NS_PTR_TO_INT32(ptr), size);
         if (get_allocations()) {
-            t->suppress_tracing++;
             he = PL_HashTableAdd(allocations, ptr, site);
-            t->suppress_tracing--;
             if (he) {
                 alloc = (allocation*) he;
                 alloc->size = size;
             }
         }
     }
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
 }
 
 PR_IMPLEMENT(void)
@@ -2488,14 +2564,15 @@ ReallocCallback(void * oldptr, void *ptr
     allocation *alloc;
     tm_thread *t;
 
-    if (!tracing_enabled)
+    if (!tracing_enabled || (t = get_tm_thread())->suppress_tracing != 0)
         return;
 
-    t = get_tm_thread();
-
-    TM_ENTER_MONITOR();
+    site = backtrace(1, t);
+
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
     tmstats.realloc_calls++;
-    if (t->suppress_tracing == 0) {
+    if (PR_TRUE) {
         oldsite = NULL;
         oldsize = 0;
         he = NULL;
@@ -2517,8 +2594,7 @@ ReallocCallback(void * oldptr, void *ptr
          * When realloc() fails, the original block is not freed or moved, so
          * we'll leave the allocation entry untouched.
          */
-    } else if (t->suppress_tracing == 0) {
-        site = backtrace(1, t);
+    } else {
         if (site) {
             log_event8(logfp, TM_EVENT_REALLOC,
                        site->serial, start, end - start,
@@ -2527,7 +2603,6 @@ ReallocCallback(void * oldptr, void *ptr
                        (uint32)NS_PTR_TO_INT32(oldptr), oldsize);
         }
         if (ptr && allocations) {
-            t->suppress_tracing++;
             if (ptr != oldptr) {
                 /*
                  * If we're reallocating (not allocating new space by passing
@@ -2546,14 +2621,14 @@ ReallocCallback(void * oldptr, void *ptr
                 if (!he)
                     he = PL_HashTableAdd(allocations, ptr, site);
             }
-            t->suppress_tracing--;
             if (he) {
                 alloc = (allocation*) he;
                 alloc->size = size;
             }
         }
     }
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
 }
 
 PR_IMPLEMENT(void)
@@ -2564,16 +2639,15 @@ FreeCallback(void * ptr, PRUint32 start,
     allocation *alloc;
     tm_thread *t;
 
-    if (!tracing_enabled)
+    if (!tracing_enabled || (t = get_tm_thread())->suppress_tracing != 0)
         return;
 
-    t = get_tm_thread();
-
-    TM_ENTER_MONITOR();
+    t->suppress_tracing++;
+    TM_ENTER_LOCK();
     tmstats.free_calls++;
     if (!ptr) {
         tmstats.null_free_calls++;
-    } else if (t->suppress_tracing == 0) {
+    } else {
         if (get_allocations()) {
             hep = PL_HashTableRawLookup(allocations, hash_pointer(ptr), ptr);
             he = *hep;
@@ -2589,7 +2663,8 @@ FreeCallback(void * ptr, PRUint32 start,
             }
         }
     }
-    TM_EXIT_MONITOR();
+    TM_EXIT_LOCK();
+    t->suppress_tracing--;
 }
 
 #endif /*XP_WIN32*/
