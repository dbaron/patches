From: L. David Baron <dbaron@dbaron.org>

Add support for animation of color values to nsStyleAnimation.  (Bug 504652)

diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -455,18 +455,18 @@ CSS_PROP_BACKGROUND(
     background_color,
     BackgroundColor,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Color,
     mBackColor,
     eCSSType_Value,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleBackground, mBackgroundColor),
+    eStyleAnimType_Color)
 CSS_PROP_BACKGROUND(
     background-image,
     background_image,
     BackgroundImage,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Color,
@@ -560,16 +560,17 @@ CSS_PROP_BORDER(
     border_bottom_color,
     BorderBottomColor,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBorderColor.mBottom,
     eCSSType_Value,
     kBorderColorKTable,
+    // FIXME: should be animatable
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BORDER(
     -moz-border-bottom-colors,
     border_bottom_colors,
     MozBorderBottomColors,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
@@ -703,16 +704,17 @@ CSS_PROP_BORDER(
     border_left_color_value,
     X,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBorderColor.mLeft,
     eCSSType_Value,
     kBorderColorKTable,
+    // FIXME: should be animatable
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BORDER(
     border-left-color-ltr-source,
     border_left_color_ltr_source,
     X,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_DIRECTIONAL_SOURCE |
@@ -849,16 +851,17 @@ CSS_PROP_BORDER(
     border_right_color_value,
     X,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBorderColor.mRight,
     eCSSType_Value,
     kBorderColorKTable,
+    // FIXME: should be animatable
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BORDER(
     border-right-color-ltr-source,
     border_right_color_ltr_source,
     X,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_DIRECTIONAL_SOURCE |
@@ -1064,16 +1067,17 @@ CSS_PROP_BORDER(
     border_top_color,
     BorderTopColor,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBorderColor.mTop,
     eCSSType_Value,
     kBorderColorKTable,
+    // FIXME: should be animatable
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BORDER(
     -moz-border-top-colors,
     border_top_colors,
     MozBorderTopColors,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
@@ -1183,18 +1187,18 @@ CSS_PROP_COLOR(
     color,
     Color,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Color,
     mColor,
     eCSSType_Value,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleColor, mColor),
+    eStyleAnimType_Color)
 CSS_PROP_COLUMN(
     -moz-column-count,
     _moz_column_count,
     MozColumnCount,
     0,
     Column,
     mColumnCount,
     eCSSType_Value,
@@ -1232,18 +1236,18 @@ CSS_PROP_COLUMN(
     -moz-column-rule-color,
     _moz_column_rule_color,
     MozColumnRuleColor,
     CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Column,
     mColumnRuleColor,
     eCSSType_Value,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleColumn, mColumnRuleColor),
+    eStyleAnimType_Color)
 CSS_PROP_COLUMN(
     -moz-column-rule-style,
     _moz_column_rule_style,
     MozColumnRuleStyle,
     0,
     Column,
     mColumnRuleStyle,
     eCSSType_Value,
@@ -1831,16 +1835,17 @@ CSS_PROP_OUTLINE(
     outline-color,
     outline_color,
     OutlineColor,
     CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mOutlineColor,
     eCSSType_Value,
     kOutlineColorKTable,
+    // FIXME: should be animatable
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_OUTLINE(
     outline-style,
     outline_style,
     OutlineStyle,
     0,
     Margin,
@@ -2778,18 +2783,18 @@ CSS_PROP_SVGRESET(
     flood-color,
     flood_color,
     FloodColor,
     0,
     SVG,
     mFloodColor,
     eCSSType_Value,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleSVGReset, mFloodColor),
+    eStyleAnimType_Color)
 CSS_PROP_SVGRESET(
     flood-opacity,
     flood_opacity,
     FloodOpacity,
     0,
     SVG,
     mFloodOpacity,
     eCSSType_Value,
@@ -2811,18 +2816,18 @@ CSS_PROP_SVGRESET(
     lighting-color,
     lighting_color,
     LightingColor,
     0,
     SVG,
     mLightingColor,
     eCSSType_Value,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleSVGReset, mLightingColor),
+    eStyleAnimType_Color)
 CSS_PROP_SHORTHAND(
     marker,
     marker,
     Marker,
     0)
 CSS_PROP_SVG(
     marker-end,
     marker_end,
@@ -2893,18 +2898,18 @@ CSS_PROP_SVGRESET(
     stop-color,
     stop_color,
     StopColor,
     0,
     SVG,
     mStopColor,
     eCSSType_Value,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleSVGReset, mStopColor),
+    eStyleAnimType_Color)
 CSS_PROP_SVGRESET(
     stop-opacity,
     stop_opacity,
     StopOpacity,
     0,
     SVG,
     mStopOpacity,
     eCSSType_Value,
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -77,16 +77,19 @@ enum nsStyleAnimType {
   eStyleAnimType_Sides_Top,
   eStyleAnimType_Sides_Right,
   eStyleAnimType_Sides_Bottom,
   eStyleAnimType_Sides_Left,
 
   // nscoord values
   eStyleAnimType_nscoord,
 
+  // nscolor values
+  eStyleAnimType_Color,
+
   // property not animatable
   eStyleAnimType_None
 };
 
 class nsCSSProps {
 public:
   static void AddRefTable(void);
   static void ReleaseTable(void);
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -42,16 +42,17 @@
 #include "nsString.h"
 #include "nsStyleAnimation.h"
 #include "nsStyleCoord.h"
 #include "nsStyleContext.h"
 #include "nsStyleSet.h"
 #include "nsCSSDataBlock.h"
 #include "nsCSSDeclaration.h"
 #include "prlog.h"
+#include <math.h>
 
 /**
  * Helper Class: StyleRuleImpl
  * This class is a simple nsIStyleRule implementation, which simply wraps a
  * nsCSSDeclaration.
  */
 class StyleRuleImpl : public nsIStyleRule {
 public:
@@ -133,16 +134,25 @@ GetCommonUnit(nsStyleUnit aFirstUnit,
     return eStyleUnit_Null;
   }
   return aFirstUnit;
 }
 
 // CLASS METHODS
 // -------------
 
+inline PRUint8 ClampColor(PRUint32 aColor)
+{
+  if (aColor <= 0)
+    return 0;
+  if (aColor >= 255)
+    return 255;
+  return aColor;
+}
+
 PRBool
 nsStyleAnimation::Add(nsStyleCoord& aDest, const nsStyleCoord& aValueToAdd,
                       PRUint32 aCount)
 {
   NS_ABORT_IF_FALSE(aDest.GetUnit() != eStyleUnit_Null,
                     "Expecting values with non-null units");
   NS_ABORT_IF_FALSE(aValueToAdd.GetUnit() != eStyleUnit_Null,
                     "Expecting values with non-null units");
@@ -159,16 +169,38 @@ nsStyleAnimation::Add(nsStyleCoord& aDes
     }
     case eStyleUnit_Percent: {
       float destPct = aDest.GetPercentValue();
       float valueToAddPct = aValueToAdd.GetPercentValue();
       destPct += aCount * valueToAddPct;
       aDest.SetPercentValue(destPct);
       break;
     }
+    case eStyleUnit_Color: {
+      // Since nscolor doesn't allow out-of-sRGB values, by-animations
+      // of colors don't make much sense in our implementation.
+      // FIXME: Animation of colors should really use floating point
+      // colors.
+      // Also, given RGBA colors, it's not clear whether we want
+      // premultiplication.  Probably we don't, given that's hard to
+      // premultiply aValueToAdd since it's a difference rather than a
+      // value.
+      nscolor destColor = aDest.GetColorValue();
+      nscolor colorToAdd = aValueToAdd.GetColorValue();
+      PRUint8 resultR =
+        ClampColor(NS_GET_R(destColor) + aCount * NS_GET_R(colorToAdd));
+      PRUint8 resultG =
+        ClampColor(NS_GET_G(destColor) + aCount * NS_GET_G(colorToAdd));
+      PRUint8 resultB =
+        ClampColor(NS_GET_B(destColor) + aCount * NS_GET_B(colorToAdd));
+      PRUint8 resultA =
+        ClampColor(NS_GET_A(destColor) + aCount * NS_GET_A(colorToAdd));
+      aDest.SetColorValue(NS_RGBA(resultR, resultG, resultB, resultA));
+      break;
+    }
     case eStyleUnit_Null:
       NS_WARNING("Unable to find a common unit for given values");
       success = PR_FALSE;
       break;
     default:
       NS_NOTREACHED("Can't add nsStyleCoords using the given common unit");
       success = PR_FALSE;
       break;
@@ -202,16 +234,42 @@ nsStyleAnimation::ComputeDistance(const 
       break;
     }
     case eStyleUnit_Percent: {
       float startPct = aStartValue.GetPercentValue();
       float endPct = aEndValue.GetPercentValue();
       aDistance = fabs(double(endPct - startPct));
       break;
     }
+    case eStyleUnit_Color: {
+      // http://www.w3.org/TR/smil-animation/#animateColorElement says
+      // that we should use Euclidian RGB cube distance.  However, we
+      // have to extend that to RGBA.  For now, we'll just use the
+      // Euclidian distance in the (part of the) 4-cube of premultiplied
+      // colors.
+      // FIXME: The CSS transitions spec doesn't say whether colors are
+      // premultiplied, but things work better when they are.
+      nscolor startColor = aStartValue.GetColorValue();
+      nscolor endColor = aEndValue.GetColorValue();
+      double startA = NS_GET_A(startColor) / 255.0;
+      double startR = NS_GET_R(startColor) * startA / 255.0;
+      double startG = NS_GET_G(startColor) * startA / 255.0;
+      double startB = NS_GET_B(startColor) * startA / 255.0;
+      double endA = NS_GET_A(endColor) / 255.0;
+      double endR = NS_GET_R(endColor) * endA / 255.0;
+      double endG = NS_GET_G(endColor) * endA / 255.0;
+      double endB = NS_GET_B(endColor) * endA / 255.0;
+      double diffA = startA - endA;
+      double diffR = startR - endR;
+      double diffG = startG - endG;
+      double diffB = startB - endB;
+      aDistance = sqrt(diffA * diffA + diffR * diffR +
+                       diffG * diffG + diffB * diffB);
+      break;
+    }
     case eStyleUnit_Null:
       NS_WARNING("Unable to find a common unit for given values");
       success = PR_FALSE;
       break;
     default:
       NS_NOTREACHED("Can't compute distance using the given common unit");
       success = PR_FALSE;
       break;
@@ -249,16 +307,59 @@ nsStyleAnimation::Interpolate(const nsSt
     }
     case eStyleUnit_Percent: {
       float startPct = aStartValue.GetPercentValue();
       float endPct = aEndValue.GetPercentValue();
       float resultPct = startPct + aPortion * (endPct - startPct);
       aResultValue.SetPercentValue(resultPct);
       break;
     }
+    case eStyleUnit_Color: {
+      double inv = 1.0 - aPortion;
+      nscolor startColor = aStartValue.GetColorValue();
+      nscolor endColor = aEndValue.GetColorValue();
+      // FIXME: The CSS transitions spec doesn't say whether colors are
+      // premultiplied, but things work better when they are.
+#if 0
+      // Don't use premultiplication.
+      aResultValue.SetColorValue(
+        NS_RGBA(PRUint8(NS_GET_R(startColor) * inv +
+                        NS_GET_R(endColor) * aPortion),
+                PRUint8(NS_GET_G(startColor) * inv +
+                        NS_GET_G(endColor) * aPortion),
+                PRUint8(NS_GET_B(startColor) * inv +
+                        NS_GET_B(endColor) * aPortion),
+                PRUint8(NS_GET_A(startColor) * inv +
+                        NS_GET_A(endColor) * aPortion)));
+#else
+      // Use premultiplication.
+      double startA = NS_GET_A(startColor) / 255.0;
+      double startR = NS_GET_R(startColor) * startA;
+      double startG = NS_GET_G(startColor) * startA;
+      double startB = NS_GET_B(startColor) * startA;
+      double endA = NS_GET_A(endColor) / 255.0;
+      double endR = NS_GET_R(endColor) * endA;
+      double endG = NS_GET_G(endColor) * endA;
+      double endB = NS_GET_B(endColor) * endA;
+      double resAf = (startA * inv + endA * aPortion);
+      nscolor resultColor;
+      if (resAf == 0.0) {
+        resultColor = NS_RGBA(0, 0, 0, 0);
+      } else {
+        double factor = 1.0 / resAf;
+        PRUint8 resA = NSToIntRound(resAf * 255.0);
+        PRUint8 resR = NSToIntRound((startR * inv + endR * aPortion) * factor);
+        PRUint8 resG = NSToIntRound((startG * inv + endG * aPortion) * factor);
+        PRUint8 resB = NSToIntRound((startB * inv + endB * aPortion) * factor);
+        resultColor = NS_RGBA(resR, resG, resB, resA);
+      }
+      aResultValue.SetColorValue(resultColor);
+#endif
+      break;
+    }
     case eStyleUnit_Null:
       NS_WARNING("Unable to find a common unit for given values");
       success = PR_FALSE;
       break;
     default:
       NS_NOTREACHED("Can't interpolate using the given common unit");
       success = PR_FALSE;
       break;
@@ -331,16 +432,20 @@ nsStyleAnimation::ExtractComputedValue(n
       aComputedValue = static_cast<const nsStyleSides*>(
         StyleDataAtOffset(styleStruct, ssOffset))->
           Get(animType - eStyleAnimType_Sides_Top);
       return PR_TRUE;
     case eStyleAnimType_nscoord:
       aComputedValue.SetCoordValue(*static_cast<const nscoord*>(
         StyleDataAtOffset(styleStruct, ssOffset)));
       return PR_TRUE;
+    case eStyleAnimType_Color:
+      aComputedValue.SetColorValue(*static_cast<const nscolor*>(
+        StyleDataAtOffset(styleStruct, ssOffset)));
+      return PR_TRUE;
     case eStyleAnimType_None:
       NS_NOTREACHED("shouldn't use on non-animatable properties");
   }
   return PR_FALSE;
 }
 
 PRBool
 nsStyleAnimation::StoreComputedValue(nsCSSProperty aProperty,
@@ -389,13 +494,17 @@ nsStyleAnimation::StoreComputedValue(nsC
           nscoord minimumFontSize =
             aPresContext->GetCachedIntPref(kPresContext_MinimumFontSize);
           font->mFont.size = PR_MAX(font->mSize, minimumFontSize);
         } else {
           font->mFont.size = font->mSize;
         }
       }
       return PR_TRUE;
+    case eStyleAnimType_Color:
+      *static_cast<nscolor*>(StyleDataAtOffset(aStyleStruct, ssOffset)) =
+        aComputedValue.GetColorValue();
+      return PR_TRUE;
     case eStyleAnimType_None:
       NS_NOTREACHED("shouldn't use on non-animatable properties");
   }
   return PR_FALSE;
 }
