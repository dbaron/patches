From: L. David Baron <dbaron@dbaron.org>

Add support for animation of color values (conversion of nscolor values to nsStyleCoord and animation of eStyleUnit_Color nsStyleCoords) to nsStyleAnimation.  (Bug 504652)

diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -455,18 +455,18 @@ CSS_PROP_BACKGROUND(
     background_color,
     BackgroundColor,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Color,
     mBackColor,
     eCSSType_Value,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleBackground, mBackgroundColor),
+    eStyleAnimType_Color)
 CSS_PROP_BACKGROUND(
     background-image,
     background_image,
     BackgroundImage,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Color,
@@ -560,16 +560,18 @@ CSS_PROP_BORDER(
     border_bottom_color,
     BorderBottomColor,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBorderColor.mBottom,
     eCSSType_Value,
     kBorderColorKTable,
+    // FIXME: should be animatable (but currently involves complex split
+    // between color and an extra bit on the style, all private members)
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BORDER(
     -moz-border-bottom-colors,
     border_bottom_colors,
     MozBorderBottomColors,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
@@ -703,16 +705,18 @@ CSS_PROP_BORDER(
     border_left_color_value,
     X,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBorderColor.mLeft,
     eCSSType_Value,
     kBorderColorKTable,
+    // FIXME: should be animatable (but currently involves complex split
+    // between color and an extra bit on the style, all private members)
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BORDER(
     border-left-color-ltr-source,
     border_left_color_ltr_source,
     X,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_DIRECTIONAL_SOURCE |
@@ -849,16 +853,18 @@ CSS_PROP_BORDER(
     border_right_color_value,
     X,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBorderColor.mRight,
     eCSSType_Value,
     kBorderColorKTable,
+    // FIXME: should be animatable (but currently involves complex split
+    // between color and an extra bit on the style, all private members)
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BORDER(
     border-right-color-ltr-source,
     border_right_color_ltr_source,
     X,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_DIRECTIONAL_SOURCE |
@@ -1064,16 +1070,18 @@ CSS_PROP_BORDER(
     border_top_color,
     BorderTopColor,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBorderColor.mTop,
     eCSSType_Value,
     kBorderColorKTable,
+    // FIXME: should be animatable (but currently involves complex split
+    // between color and an extra bit on the style, all private members)
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BORDER(
     -moz-border-top-colors,
     border_top_colors,
     MozBorderTopColors,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
@@ -1183,18 +1191,18 @@ CSS_PROP_COLOR(
     color,
     Color,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Color,
     mColor,
     eCSSType_Value,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleColor, mColor),
+    eStyleAnimType_Color)
 CSS_PROP_COLUMN(
     -moz-column-count,
     _moz_column_count,
     MozColumnCount,
     0,
     Column,
     mColumnCount,
     eCSSType_Value,
@@ -1232,18 +1240,18 @@ CSS_PROP_COLUMN(
     -moz-column-rule-color,
     _moz_column_rule_color,
     MozColumnRuleColor,
     CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Column,
     mColumnRuleColor,
     eCSSType_Value,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleColumn, mColumnRuleColor),
+    eStyleAnimType_Color)
 CSS_PROP_COLUMN(
     -moz-column-rule-style,
     _moz_column_rule_style,
     MozColumnRuleStyle,
     0,
     Column,
     mColumnRuleStyle,
     eCSSType_Value,
@@ -1831,16 +1839,18 @@ CSS_PROP_OUTLINE(
     outline-color,
     outline_color,
     OutlineColor,
     CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mOutlineColor,
     eCSSType_Value,
     kOutlineColorKTable,
+    // FIXME: should be animatable (but currently involves complex split
+    // between color and an extra bit on the style, all private members)
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_OUTLINE(
     outline-style,
     outline_style,
     OutlineStyle,
     0,
     Margin,
@@ -2789,18 +2799,18 @@ CSS_PROP_SVGRESET(
     flood-color,
     flood_color,
     FloodColor,
     0,
     SVG,
     mFloodColor,
     eCSSType_Value,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleSVGReset, mFloodColor),
+    eStyleAnimType_Color)
 CSS_PROP_SVGRESET(
     flood-opacity,
     flood_opacity,
     FloodOpacity,
     0,
     SVG,
     mFloodOpacity,
     eCSSType_Value,
@@ -2822,18 +2832,18 @@ CSS_PROP_SVGRESET(
     lighting-color,
     lighting_color,
     LightingColor,
     0,
     SVG,
     mLightingColor,
     eCSSType_Value,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleSVGReset, mLightingColor),
+    eStyleAnimType_Color)
 CSS_PROP_SHORTHAND(
     marker,
     marker,
     Marker,
     0)
 CSS_PROP_SVG(
     marker-end,
     marker_end,
@@ -2893,18 +2903,18 @@ CSS_PROP_SVGRESET(
     stop-color,
     stop_color,
     StopColor,
     0,
     SVG,
     mStopColor,
     eCSSType_Value,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleSVGReset, mStopColor),
+    eStyleAnimType_Color)
 CSS_PROP_SVGRESET(
     stop-opacity,
     stop_opacity,
     StopOpacity,
     0,
     SVG,
     mStopOpacity,
     eCSSType_Value,
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -77,16 +77,19 @@ enum nsStyleAnimType {
   eStyleAnimType_Sides_Top,
   eStyleAnimType_Sides_Right,
   eStyleAnimType_Sides_Bottom,
   eStyleAnimType_Sides_Left,
 
   // nscoord values
   eStyleAnimType_nscoord,
 
+  // nscolor values
+  eStyleAnimType_Color,
+
   // property not animatable
   eStyleAnimType_None
 };
 
 class nsCSSProps {
 public:
   static void AddRefTable(void);
   static void ReleaseTable(void);
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -48,16 +48,17 @@
 #include "nsStyleContext.h"
 #include "nsStyleSet.h"
 #include "nsComputedDOMStyle.h"
 #include "nsICSSParser.h"
 #include "nsICSSLoader.h"
 #include "nsCSSDataBlock.h"
 #include "nsCSSDeclaration.h"
 #include "prlog.h"
+#include <math.h>
 
 // HELPER METHODS
 // --------------
 /*
  * Given two units, this method returns a common unit that they can both be
  * converted into, if possible.  This is intended to facilitate
  * interpolation, distance-computation, and addition between "similar" units.
  *
@@ -88,16 +89,25 @@ GetCommonUnit(nsStyleUnit aFirstUnit,
     return eStyleUnit_Null;
   }
   return aFirstUnit;
 }
 
 // CLASS METHODS
 // -------------
 
+#define MAX_PACKED_COLOR_COMPONENT 255
+
+inline PRUint8 ClampColor(PRUint32 aColor)
+{
+  if (aColor >= MAX_PACKED_COLOR_COMPONENT)
+    return MAX_PACKED_COLOR_COMPONENT;
+  return aColor;
+}
+
 PRBool
 nsStyleAnimation::Add(nsStyleCoord& aDest, const nsStyleCoord& aValueToAdd,
                       PRUint32 aCount)
 {
   nsStyleUnit commonUnit = GetCommonUnit(aDest.GetUnit(),
                                          aValueToAdd.GetUnit());
   PRBool success = PR_TRUE;
   switch (commonUnit) {
@@ -110,16 +120,45 @@ nsStyleAnimation::Add(nsStyleCoord& aDes
     }
     case eStyleUnit_Percent: {
       float destPct = aDest.GetPercentValue();
       float valueToAddPct = aValueToAdd.GetPercentValue();
       destPct += aCount * valueToAddPct;
       aDest.SetPercentValue(destPct);
       break;
     }
+    case eStyleUnit_Color: {
+      // Since nscolor doesn't allow out-of-sRGB values, by-animations
+      // of colors don't make much sense in our implementation.
+      // FIXME: Animation of colors should really use floating point
+      // colors (and when it does, ClampColor and the clamping of aCount
+      // should go away).
+      // Also, given RGBA colors, it's not clear whether we want
+      // premultiplication.  Probably we don't, given that's hard to
+      // premultiply aValueToAdd since it's a difference rather than a
+      // value.
+      nscolor destColor = aDest.GetColorValue();
+      nscolor colorToAdd = aValueToAdd.GetColorValue();
+      if (aCount > MAX_PACKED_COLOR_COMPONENT) {
+        // Given that we're using integers and clamping at 255, we can
+        // clamp aCount to 255 since that's enough to saturate if we're
+        // multiplying it by anything nonzero.
+        aCount = MAX_PACKED_COLOR_COMPONENT;
+      }
+      PRUint8 resultR =
+        ClampColor(NS_GET_R(destColor) + aCount * NS_GET_R(colorToAdd));
+      PRUint8 resultG =
+        ClampColor(NS_GET_G(destColor) + aCount * NS_GET_G(colorToAdd));
+      PRUint8 resultB =
+        ClampColor(NS_GET_B(destColor) + aCount * NS_GET_B(colorToAdd));
+      PRUint8 resultA =
+        ClampColor(NS_GET_A(destColor) + aCount * NS_GET_A(colorToAdd));
+      aDest.SetColorValue(NS_RGBA(resultR, resultG, resultB, resultA));
+      break;
+    }
     case eStyleUnit_Null:
       NS_WARNING("Unable to find a common unit for given values");
       success = PR_FALSE;
       break;
     default:
       NS_NOTREACHED("Can't add nsStyleCoords using the given common unit");
       success = PR_FALSE;
       break;
@@ -144,16 +183,53 @@ nsStyleAnimation::ComputeDistance(const 
       break;
     }
     case eStyleUnit_Percent: {
       float startPct = aStartValue.GetPercentValue();
       float endPct = aEndValue.GetPercentValue();
       aDistance = fabs(double(endPct - startPct));
       break;
     }
+    case eStyleUnit_Color: {
+      // http://www.w3.org/TR/smil-animation/#animateColorElement says
+      // that we should use Euclidean RGB cube distance.  However, we
+      // have to extend that to RGBA.  For now, we'll just use the
+      // Euclidean distance in the (part of the) 4-cube of premultiplied
+      // colors.
+      // FIXME (spec): The CSS transitions spec doesn't say whether
+      // colors are premultiplied, but things work better when they are,
+      // so use premultiplication.  Spec issue is still open per
+      // http://lists.w3.org/Archives/Public/www-style/2009Jul/0050.html
+      nscolor startColor = aStartValue.GetColorValue();
+      nscolor endColor = aEndValue.GetColorValue();
+
+      // Get a color component on a 0-1 scale, which is much easier to
+      // deal with when working with alpha.
+      #define GET_COMPONENT(component_, color_) \
+        (NS_GET_##component_(color_) * (1.0 / 255.0))
+
+      double startA = GET_COMPONENT(A, startColor);
+      double startR = GET_COMPONENT(R, startColor) * startA;
+      double startG = GET_COMPONENT(G, startColor) * startA;
+      double startB = GET_COMPONENT(B, startColor) * startA;
+      double endA = GET_COMPONENT(A, endColor);
+      double endR = GET_COMPONENT(R, endColor) * endA;
+      double endG = GET_COMPONENT(G, endColor) * endA;
+      double endB = GET_COMPONENT(B, endColor) * endA;
+
+      #undef GET_COMPONENT
+
+      double diffA = startA - endA;
+      double diffR = startR - endR;
+      double diffG = startG - endG;
+      double diffB = startB - endB;
+      aDistance = sqrt(diffA * diffA + diffR * diffR +
+                       diffG * diffG + diffB * diffB);
+      break;
+    }
     case eStyleUnit_Null:
       NS_WARNING("Unable to find a common unit for given values");
       success = PR_FALSE;
       break;
     default:
       NS_NOTREACHED("Can't compute distance using the given common unit");
       success = PR_FALSE;
       break;
@@ -188,16 +264,50 @@ nsStyleAnimation::Interpolate(const nsSt
     }
     case eStyleUnit_Percent: {
       float startPct = aStartValue.GetPercentValue();
       float endPct = aEndValue.GetPercentValue();
       float resultPct = startPct + aPortion * (endPct - startPct);
       aResultValue.SetPercentValue(resultPct);
       break;
     }
+    case eStyleUnit_Color: {
+      double inv = 1.0 - aPortion;
+      nscolor startColor = aStartValue.GetColorValue();
+      nscolor endColor = aEndValue.GetColorValue();
+      // FIXME (spec): The CSS transitions spec doesn't say whether
+      // colors are premultiplied, but things work better when they are,
+      // so use premultiplication.  Spec issue is still open per
+      // http://lists.w3.org/Archives/Public/www-style/2009Jul/0050.html
+
+      // To save some math, scale the alpha down to a 0-1 scale, but
+      // leave the color components on a 0-255 scale.
+      double startA = NS_GET_A(startColor) * (1.0 / 255.0);
+      double startR = NS_GET_R(startColor) * startA;
+      double startG = NS_GET_G(startColor) * startA;
+      double startB = NS_GET_B(startColor) * startA;
+      double endA = NS_GET_A(endColor) * (1.0 / 255.0);
+      double endR = NS_GET_R(endColor) * endA;
+      double endG = NS_GET_G(endColor) * endA;
+      double endB = NS_GET_B(endColor) * endA;
+      double resAf = (startA * inv + endA * aPortion);
+      nscolor resultColor;
+      if (resAf == 0.0) {
+        resultColor = NS_RGBA(0, 0, 0, 0);
+      } else {
+        double factor = 1.0 / resAf;
+        PRUint8 resA = NSToIntRound(resAf * 255.0);
+        PRUint8 resR = NSToIntRound((startR * inv + endR * aPortion) * factor);
+        PRUint8 resG = NSToIntRound((startG * inv + endG * aPortion) * factor);
+        PRUint8 resB = NSToIntRound((startB * inv + endB * aPortion) * factor);
+        resultColor = NS_RGBA(resR, resG, resB, resA);
+      }
+      aResultValue.SetColorValue(resultColor);
+      break;
+    }
     case eStyleUnit_Null:
       NS_WARNING("Unable to find a common unit for given values");
       success = PR_FALSE;
       break;
     default:
       NS_NOTREACHED("Can't interpolate using the given common unit");
       success = PR_FALSE;
       break;
@@ -339,16 +449,20 @@ nsStyleAnimation::ExtractComputedValue(n
       aComputedValue = static_cast<const nsStyleSides*>(
         StyleDataAtOffset(styleStruct, ssOffset))->
           Get(animType - eStyleAnimType_Sides_Top);
       return PR_TRUE;
     case eStyleAnimType_nscoord:
       aComputedValue.SetCoordValue(*static_cast<const nscoord*>(
         StyleDataAtOffset(styleStruct, ssOffset)));
       return PR_TRUE;
+    case eStyleAnimType_Color:
+      aComputedValue.SetColorValue(*static_cast<const nscolor*>(
+        StyleDataAtOffset(styleStruct, ssOffset)));
+      return PR_TRUE;
     case eStyleAnimType_None:
       NS_NOTREACHED("shouldn't use on non-animatable properties");
   }
   return PR_FALSE;
 }
 
 PRBool
 nsStyleAnimation::StoreComputedValue(nsCSSProperty aProperty,
@@ -398,13 +512,17 @@ nsStyleAnimation::StoreComputedValue(nsC
           nscoord minimumFontSize =
             aPresContext->GetCachedIntPref(kPresContext_MinimumFontSize);
           font->mFont.size = PR_MAX(font->mSize, minimumFontSize);
         } else {
           font->mFont.size = font->mSize;
         }
       }
       return PR_TRUE;
+    case eStyleAnimType_Color:
+      *static_cast<nscolor*>(StyleDataAtOffset(aStyleStruct, ssOffset)) =
+        aComputedValue.GetColorValue();
+      return PR_TRUE;
     case eStyleAnimType_None:
       NS_NOTREACHED("shouldn't use on non-animatable properties");
   }
   return PR_FALSE;
 }
