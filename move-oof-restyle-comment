From: L. David Baron <dbaron@dbaron.org>

Bug 898209 patch 16:  Move a comment that should have been moved in patch 15.  No review.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -2041,16 +2041,26 @@ ElementRestyler::ElementRestyler(const E
 #ifdef ACCESSIBILITY
   , mDesiredA11yNotifications(aParentRestyler.mKidsDesiredA11yNotifications)
   , mKidsDesiredA11yNotifications(mDesiredA11yNotifications)
   , mOurA11yNotification(eDontNotify)
   , mVisibleKidsOfHiddenElement(aParentRestyler.mVisibleKidsOfHiddenElement)
 #endif
 {
   if (aConstructorFlags & FOR_OUT_OF_FLOW_CHILD) {
+    // Note that the out-of-flow may not be a geometric descendant of
+    // the frame where we started the reresolve.  Therefore, even if
+    // mHintsHandled already includes nsChangeHint_AllReflowHints we
+    // don't want to pass that on to the out-of-flow reresolve, since
+    // that can lead to the out-of-flow not getting reflowed when it
+    // should be (eg a reresolve starting at <body> that involves
+    // reflowing the <body> would miss reflowing fixed-pos nodes that
+    // also need reflow).  In the cases when the out-of-flow _is_ a
+    // geometric descendant of a frame we already have a reflow hint
+    // for, reflow coalescing should keep us from doing the work twice.
     mHintsHandled = NS_SubtractHint(mHintsHandled, nsChangeHint_AllReflowHints);
   }
 }
 
 ElementRestyler::ElementRestyler(ParentContextFromChildFrame,
                                  const ElementRestyler& aParentRestyler,
                                  nsIFrame* aFrame)
   : mPresContext(aParentRestyler.mPresContext)
@@ -2661,27 +2671,16 @@ ElementRestyler::RestyleContentChildren(
         if (nsGkAtoms::placeholderFrame == child->GetType()) { // placeholder
           // get out of flow frame and recur there
           nsIFrame* outOfFlowFrame =
             nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
           NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
           NS_ASSERTION(outOfFlowFrame != mResolvedChild,
                        "out-of-flow frame not a true descendant");
 
-          // Note that the out-of-flow may not be a geometric descendant of
-          // the frame where we started the reresolve.  Therefore, even if
-          // mHintsHandled already includes nsChangeHint_AllReflowHints we don't
-          // want to pass that on to the out-of-flow reresolve, since that
-          // can lead to the out-of-flow not getting reflowed when it should
-          // be (eg a reresolve starting at <body> that involves reflowing
-          // the <body> would miss reflowing fixed-pos nodes that also need
-          // reflow).  In the cases when the out-of-flow _is_ a geometric
-          // descendant of a frame we already have a reflow hint for,
-          // reflow coalescing should keep us from doing the work twice.
-
           // |nsFrame::GetParentStyleContextFrame| checks being out
           // of flow so that this works correctly.
           do {
             if (GetPrevContinuationWithSameStyle(outOfFlowFrame)) {
               // Later continuations are likely restyled as a result of
               // the restyling of the previous continuation.
               // (Currently that's always true, but it's likely to
               // change if we implement overflow:fragments or similar.)
