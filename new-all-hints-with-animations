From: L. David Baron <dbaron@dbaron.org>

Replace one use of nsRestyleHint_ChangeAnimationPhase with nsRestyleHint_AllHintsWithAnimations so that we can remove the rest.

diff --git a/layout/base/nsChangeHint.h b/layout/base/nsChangeHint.h
--- a/layout/base/nsChangeHint.h
+++ b/layout/base/nsChangeHint.h
@@ -367,16 +367,22 @@ enum nsRestyleHint {
   eRestyle_Force = (1<<9),
 
   // Continue the restyling process to all of the current frame's
   // descendants, even if any frame's restyling resulted in no style
   // changes.  (Implies eRestyle_Force.)  Note that this is weaker than
   // eRestyle_Subtree, which makes us rerun selector matching on all
   // descendants rather than just continuing the restyling process.
   eRestyle_ForceDescendants = (1<<10),
+
+  // Useful unions:
+  eRestyle_AllHintsWithAnimations = eRestyle_CSSTransitions |
+                                    eRestyle_CSSAnimations |
+                                    eRestyle_SVGAttrAnimations |
+                                    eRestyle_StyleAttribute,
 };
 
 // The functions below need an integral type to cast to to avoid
 // infinite recursion.
 typedef decltype(nsRestyleHint(0) + nsRestyleHint(0)) nsRestyleHint_size_t;
 
 inline nsRestyleHint operator|(nsRestyleHint aLeft, nsRestyleHint aRight)
 {
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -564,17 +564,17 @@ nsAnimationManager::BuildAnimations(nsSt
                          toKeyframe.mKey, toContext);
         } else {
           if (toKeyframe.mKey != 0.0f) {
             // There's no data for this property at 0%, so use the
             // cascaded value above us.
             if (!styleWithoutAnimation) {
               styleWithoutAnimation = mPresContext->StyleSet()->
                 ResolveStyleWithoutAnimation(aTarget, aStyleContext,
-                                             eRestyle_ChangeAnimationPhase);
+                                             eRestyle_AllHintsWithAnimations);
             }
             interpolated = interpolated &&
               BuildSegment(propData.mSegments, prop, src,
                            0.0f, styleWithoutAnimation, nullptr,
                            toKeyframe.mKey, toContext);
           }
         }
 
@@ -583,17 +583,17 @@ nsAnimationManager::BuildAnimations(nsSt
       }
 
       if (fromKeyframe->mKey != 1.0f) {
         // There's no data for this property at 100%, so use the
         // cascaded value above us.
         if (!styleWithoutAnimation) {
           styleWithoutAnimation = mPresContext->StyleSet()->
             ResolveStyleWithoutAnimation(aTarget, aStyleContext,
-                                         eRestyle_ChangeAnimationPhase);
+                                         eRestyle_AllHintsWithAnimations);
         }
         interpolated = interpolated &&
           BuildSegment(propData.mSegments, prop, src,
                        fromKeyframe->mKey, fromContext,
                        fromKeyframe->mRule->Declaration(),
                        1.0f, styleWithoutAnimation);
       }
 
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1411,20 +1411,17 @@ nsStyleSet::RuleNodeWithReplacement(Elem
                     // way to print these.
                     nsPrintfCString("unexpected replacement bits 0x%lX",
                                     uint32_t(aReplacements)).get());
 
   // If we're changing animation phase, we have to reconsider what rules
   // are in these four levels.
   if (aReplacements & (eRestyle_ChangeAnimationPhase |
                        eRestyle_ChangeAnimationPhaseDescendants)) {
-    aReplacements |= eRestyle_CSSTransitions |
-                     eRestyle_CSSAnimations |
-                     eRestyle_SVGAttrAnimations |
-                     eRestyle_StyleAttribute;
+    aReplacements |= eRestyle_AllHintsWithAnimations;
   }
 
   // FIXME (perf): This should probably not rebuild the whole path, but
   // only the path from the last change in the rule tree, like
   // ReplaceAnimationRule in nsStyleSet.cpp does.  (That could then
   // perhaps share this code, too?)
   // But if we do that, we'll need to pass whether we are rebuilding the
   // rule tree from ElementRestyler::RestyleSelf to avoid taking that
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -137,17 +137,17 @@ class nsStyleSet
   ResolveStyleWithReplacement(mozilla::dom::Element* aElement,
                               mozilla::dom::Element* aPseudoElement,
                               nsStyleContext* aNewParentContext,
                               nsStyleContext* aOldStyleContext,
                               nsRestyleHint aReplacements);
 
   // Resolve style by returning a style context with the animation data
   // removed.  It is allowable to remove all animation data with
-  // eRestyle_ChangeAnimationPhase, or by using any othe hints that
+  // eRestyle_AllHintsWithAnimations, or by using any othe hints that
   // are allowed by ResolveStyleWithReplacement.
   already_AddRefed<nsStyleContext>
     ResolveStyleWithoutAnimation(mozilla::dom::Element* aElement,
                                  nsStyleContext* aStyleContext,
                                  nsRestyleHint aWhichToRemove);
 
   // Get a style context for a non-element (which no rules will match),
   // such as text nodes, placeholder frames, and the nsFirstLetterFrame
