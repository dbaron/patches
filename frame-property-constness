From: L. David Baron <dbaron@dbaron.org>

Give frame properties the const-ness semantics of member variables.

This makes it so that, given a |const nsIFrame*|, a caller can retrieve
properties but not set or remove them, but with an |nsIFrame*| all
operations are allowed.  I believe this is sensible since properties act
as extended member variables for things that are needed rarely, and
these are the const-ness semantics of member variables.

This also avoids the need for const_cast<nsIFrame*> to cast away const
in the following patch, which guards property access with a frame state
bit.

MozReview-Commit-ID: IJ9JnGzdH51

diff --git a/layout/base/FramePropertyTable.cpp b/layout/base/FramePropertyTable.cpp
--- a/layout/base/FramePropertyTable.cpp
+++ b/layout/base/FramePropertyTable.cpp
@@ -8,17 +8,17 @@
 #include "mozilla/MemoryReporting.h"
 #include "mozilla/ServoStyleSet.h"
 #include "nsThreadUtils.h"
 
 namespace mozilla {
 
 void
 FramePropertyTable::SetInternal(
-  const nsIFrame* aFrame, UntypedDescriptor aProperty, void* aValue)
+  nsIFrame* aFrame, UntypedDescriptor aProperty, void* aValue)
 {
   MOZ_ASSERT(NS_IsMainThread());
   NS_ASSERTION(aFrame, "Null frame?");
   NS_ASSERTION(aProperty, "Null property?");
 
   if (mLastFrame != aFrame || !mLastEntry) {
     mLastFrame = aFrame;
     mLastEntry = mEntries.PutEntry(aFrame);
@@ -106,17 +106,17 @@ FramePropertyTable::GetInternal(
     *aFoundResult = true;
   }
 
   return array->ElementAt(index).mValue;
 }
 
 void*
 FramePropertyTable::RemoveInternal(
-  const nsIFrame* aFrame, UntypedDescriptor aProperty, bool* aFoundResult)
+  nsIFrame* aFrame, UntypedDescriptor aProperty, bool* aFoundResult)
 {
   MOZ_ASSERT(NS_IsMainThread());
   NS_ASSERTION(aFrame, "Null frame?");
   NS_ASSERTION(aProperty, "Null property?");
 
   if (aFoundResult) {
     *aFoundResult = false;
   }
@@ -171,17 +171,17 @@ FramePropertyTable::RemoveInternal(
     entry->mProp = pv;
   }
   
   return result;
 }
 
 void
 FramePropertyTable::DeleteInternal(
-  const nsIFrame* aFrame, UntypedDescriptor aProperty)
+  nsIFrame* aFrame, UntypedDescriptor aProperty)
 {
   MOZ_ASSERT(NS_IsMainThread());
   NS_ASSERTION(aFrame, "Null frame?");
   NS_ASSERTION(aProperty, "Null property?");
 
   bool found;
   void* v = RemoveInternal(aFrame, aProperty, &found);
   if (found) {
@@ -201,17 +201,17 @@ FramePropertyTable::DeleteAllForEntry(En
   nsTArray<PropertyValue>* array = aEntry->mProp.ToArray();
   for (uint32_t i = 0; i < array->Length(); ++i) {
     array->ElementAt(i).DestroyValueFor(aEntry->GetKey());
   }
   array->~nsTArray<PropertyValue>();
 }
 
 void
-FramePropertyTable::DeleteAllFor(const nsIFrame* aFrame)
+FramePropertyTable::DeleteAllFor(nsIFrame* aFrame)
 {
   NS_ASSERTION(aFrame, "Null frame?");
 
   Entry* entry = mEntries.GetEntry(aFrame);
   if (!entry)
     return;
 
   if (mLastFrame == aFrame) {
diff --git a/layout/base/FramePropertyTable.h b/layout/base/FramePropertyTable.h
--- a/layout/base/FramePropertyTable.h
+++ b/layout/base/FramePropertyTable.h
@@ -160,17 +160,17 @@ public:
 
   /**
    * Set a property value on a frame. This requires one hashtable
    * lookup (using the frame as the key) and a linear search through
    * the properties of that frame. Any existing value for the property
    * is destroyed.
    */
   template<typename T>
-  void Set(const nsIFrame* aFrame, Descriptor<T> aProperty,
+  void Set(nsIFrame* aFrame, Descriptor<T> aProperty,
            PropertyType<T> aValue)
   {
     void* ptr = ReinterpretHelper<T>::ToPointer(aValue);
     SetInternal(aFrame, aProperty, ptr);
   }
 
   /**
    * @return true if @aProperty is set for @aFrame. This requires one hashtable
@@ -223,56 +223,56 @@ public:
    * returns zero-filled result, which means null for pointers and
    * zero for integers and floating point types.
    * @param aFoundResult if non-null, receives a value 'true' iff
    * the frame had a value for the property. This lets callers
    * disambiguate a null result, which can mean 'no such property' or
    * 'property value is null'.
    */
   template<typename T>
-  PropertyType<T> Remove(const nsIFrame* aFrame, Descriptor<T> aProperty,
+  PropertyType<T> Remove(nsIFrame* aFrame, Descriptor<T> aProperty,
                          bool* aFoundResult = nullptr)
   {
     void* ptr = RemoveInternal(aFrame, aProperty, aFoundResult);
     return ReinterpretHelper<T>::FromPointer(ptr);
   }
   /**
    * Remove and destroy a property value for a frame. This requires one
    * hashtable lookup (using the frame as the key) and a linear search
    * through the properties of that frame. If the frame has no such
    * property, nothing happens.
    */
   template<typename T>
-  void Delete(const nsIFrame* aFrame, Descriptor<T> aProperty)
+  void Delete(nsIFrame* aFrame, Descriptor<T> aProperty)
   {
     DeleteInternal(aFrame, aProperty);
   }
   /**
    * Remove and destroy all property values for a frame. This requires one
    * hashtable lookup (using the frame as the key).
    */
-  void DeleteAllFor(const nsIFrame* aFrame);
+  void DeleteAllFor(nsIFrame* aFrame);
   /**
    * Remove and destroy all property values for all frames.
    */
   void DeleteAll();
 
   size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;
 
 protected:
-  void SetInternal(const nsIFrame* aFrame, UntypedDescriptor aProperty,
+  void SetInternal(nsIFrame* aFrame, UntypedDescriptor aProperty,
                    void* aValue);
 
   void* GetInternal(const nsIFrame* aFrame, UntypedDescriptor aProperty,
                     bool* aFoundResult);
 
-  void* RemoveInternal(const nsIFrame* aFrame, UntypedDescriptor aProperty,
+  void* RemoveInternal(nsIFrame* aFrame, UntypedDescriptor aProperty,
                        bool* aFoundResult);
 
-  void DeleteInternal(const nsIFrame* aFrame, UntypedDescriptor aProperty);
+  void DeleteInternal(nsIFrame* aFrame, UntypedDescriptor aProperty);
 
   template<typename T>
   struct ReinterpretHelper
   {
     static_assert(sizeof(PropertyType<T>) <= sizeof(void*),
                   "size of the value must never be larger than a pointer");
 
     static void* ToPointer(PropertyType<T> aValue)
@@ -387,56 +387,69 @@ protected:
   // not triggering a resize of mEntries, e.g. use RawRemoveEntry() instead of
   // RemoveEntry() in some places.
   nsTHashtable<Entry> mEntries;
   const nsIFrame* mLastFrame;
   Entry* mLastEntry;
 };
 
 /**
- * This class encapsulates the properties of a frame.
+ * The FrameProperties class encapsulates the properties of a frame.
+ *
+ * However, since frame properties are like member variables, it is
+ * templatized over whether the frame is |const| or not, with the common
+ * methods being in a base class.
+ *
+ * CVnsIFrame is either |nsIFrame| or |const nsIFrame|.
  */
+template<class CVnsIFrame>
 class FrameProperties {
 public:
   template<typename T> using Descriptor = FramePropertyTable::Descriptor<T>;
   template<typename T> using PropertyType = FramePropertyTable::PropertyType<T>;
 
-  FrameProperties(FramePropertyTable* aTable, const nsIFrame* aFrame)
+  FrameProperties(FramePropertyTable* aTable, CVnsIFrame* aFrame)
     : mTable(aTable), mFrame(aFrame) {}
 
   template<typename T>
-  void Set(Descriptor<T> aProperty, PropertyType<T> aValue) const
-  {
-    mTable->Set(mFrame, aProperty, aValue);
-  }
-
-  template<typename T>
   bool Has(Descriptor<T> aProperty) const
   {
     return mTable->Has(mFrame, aProperty);
   }
 
   template<typename T>
   PropertyType<T> Get(Descriptor<T> aProperty,
                       bool* aFoundResult = nullptr) const
   {
     return mTable->Get(mFrame, aProperty, aFoundResult);
   }
+
+private:
+  FramePropertyTable* const mTable;
+  CVnsIFrame* const mFrame;
+};
+
+template<nsIFrame*>
+class FrameProperties {
+  template<typename T>
+  void Set(Descriptor<T> aProperty, PropertyType<T> aValue) const
+  {
+    mTable->Set(mFrame, aProperty, aValue);
+  }
+
   template<typename T>
   PropertyType<T> Remove(Descriptor<T> aProperty,
                          bool* aFoundResult = nullptr) const
   {
     return mTable->Remove(mFrame, aProperty, aFoundResult);
   }
+
   template<typename T>
-  void Delete(Descriptor<T> aProperty)
+  void Delete(Descriptor<T> aProperty) const
   {
     mTable->Delete(mFrame, aProperty);
   }
 
-private:
-  FramePropertyTable* mTable;
-  const nsIFrame* mFrame;
 };
 
 } // namespace mozilla
 
 #endif /* FRAMEPROPERTYTABLE_H_ */
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -577,17 +577,18 @@ public:
   using Nothing = mozilla::Nothing;
   using OnNonvisible = mozilla::OnNonvisible;
   template<typename T=void>
   using PropertyDescriptor = const mozilla::FramePropertyDescriptor<T>*;
   using ReflowInput = mozilla::ReflowInput;
   using ReflowOutput = mozilla::ReflowOutput;
   using Visibility = mozilla::Visibility;
 
-  typedef mozilla::FrameProperties FrameProperties;
+  typedef mozilla::FrameProperties<nsIFrame*> FrameProperties;
+  typedef mozilla::FrameProperties<const nsIFrame*> ConstFrameProperties;
   typedef mozilla::layers::Layer Layer;
   typedef mozilla::layout::FrameChildList ChildList;
   typedef mozilla::layout::FrameChildListID ChildListID;
   typedef mozilla::layout::FrameChildListIDs ChildListIDs;
   typedef mozilla::layout::FrameChildListIterator ChildListIterator;
   typedef mozilla::layout::FrameChildListArrayIterator ChildListArrayIterator;
   typedef mozilla::gfx::DrawTarget DrawTarget;
   typedef mozilla::gfx::Matrix Matrix;
@@ -3252,20 +3253,24 @@ public:
    *
    * @param aParentContent the content node corresponding to the parent frame
    * @return whether the frame is a pseudo frame
    */
   bool IsPseudoFrame(const nsIContent* aParentContent) {
     return mContent == aParentContent;
   }
 
-  FrameProperties Properties() const {
+  FrameProperties Properties() {
     return FrameProperties(PresContext()->PropertyTable(), this);
   }
 
+  ConstFrameProperties Properties() const {
+    return ConstFrameProperties(PresContext()->PropertyTable(), this);
+  }
+
   /**
    * Return true if and only if this frame obeys visibility:hidden.
    * if it does not, then nsContainerFrame will hide its view even though
    * this means children can't be made visible again.
    */
   virtual bool SupportsVisibilityHidden() { return true; }
 
   /**
