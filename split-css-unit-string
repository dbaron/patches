Split eCSSUnit_String into eCSSUnit_String (with quotes), eCSSUnit_Ident (without quotes), and eCSSUnit_Families (font family list, but not for @font-face descriptor where the single family is stored as eCSSUnit_String).  (Bug 478160)

diff --git a/content/html/content/src/nsGenericHTMLElement.cpp b/content/html/content/src/nsGenericHTMLElement.cpp
--- a/content/html/content/src/nsGenericHTMLElement.cpp
+++ b/content/html/content/src/nsGenericHTMLElement.cpp
@@ -1673,17 +1673,17 @@ nsGenericHTMLElement::MapCommonAttribute
         }
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Visibility)) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::lang);
     if (value && value->Type() == nsAttrValue::eString) {
       aData->mDisplayData->mLang.SetStringValue(value->GetStringValue(),
-                                                eCSSUnit_String);
+                                                eCSSUnit_Ident);
     }
   }
 }
 
 void
 nsGenericHTMLFormElement::UpdateEditableFormControlState()
 {
   ContentEditableTristate value = GetContentEditableValue();
diff --git a/content/html/content/src/nsHTMLFontElement.cpp b/content/html/content/src/nsHTMLFontElement.cpp
--- a/content/html/content/src/nsHTMLFontElement.cpp
+++ b/content/html/content/src/nsHTMLFontElement.cpp
@@ -175,17 +175,17 @@ MapAttributesIntoRule(const nsMappedAttr
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Font)) {
     nsRuleDataFont& font = *(aData->mFontData);
     
     // face: string list
     if (font.mFamily.GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::face);
       if (value && value->Type() == nsAttrValue::eString &&
           !value->IsEmptyString()) {
-        font.mFamily.SetStringValue(value->GetStringValue(), eCSSUnit_String);
+        font.mFamily.SetStringValue(value->GetStringValue(), eCSSUnit_Families);
         font.mFamilyFromHTML = PR_TRUE;
       }
     }
 
     // pointSize: int
     if (font.mSize.GetUnit() == eCSSUnit_Null) {
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::pointSize);
       if (value && value->Type() == nsAttrValue::eInteger)
diff --git a/content/html/content/src/nsHTMLPreElement.cpp b/content/html/content/src/nsHTMLPreElement.cpp
--- a/content/html/content/src/nsHTMLPreElement.cpp
+++ b/content/html/content/src/nsHTMLPreElement.cpp
@@ -134,17 +134,17 @@ nsHTMLPreElement::ParseAttribute(PRInt32
 static void
 MapAttributesIntoRule(const nsMappedAttributes* aAttributes,
                       nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Font)) {
     // variable
     if (aAttributes->GetAttr(nsGkAtoms::variable))
       aData->mFontData->mFamily.SetStringValue(NS_LITERAL_STRING("serif"),
-                                               eCSSUnit_String);
+                                               eCSSUnit_Families);
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)) {
     if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
       // width: int (html4 attribute == nav4 cols)
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
       if (!value || value->Type() != nsAttrValue::eInteger) {
         // cols: int (nav4 attribute)
         value = aAttributes->GetAttr(nsGkAtoms::cols);
diff --git a/content/mathml/content/src/nsMathMLElement.cpp b/content/mathml/content/src/nsMathMLElement.cpp
--- a/content/mathml/content/src/nsMathMLElement.cpp
+++ b/content/mathml/content/src/nsMathMLElement.cpp
@@ -361,17 +361,17 @@ nsMathMLElement::MapMathMLAttributesInto
         }
       }
     }
 
     value = aAttributes->GetAttr(nsGkAtoms::fontfamily_);
     if (value && value->Type() == nsAttrValue::eString &&
         aData->mFontData->mFamily.GetUnit() == eCSSUnit_Null) {
       aData->mFontData->mFamily.SetStringValue(value->GetStringValue(),
-                                               eCSSUnit_String);
+                                               eCSSUnit_Families);
       aData->mFontData->mFamilyFromHTML = PR_FALSE;
     }
   }
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)) {
     const nsAttrValue* value =
       aAttributes->GetAttr(nsGkAtoms::mathbackground_);
     if (!value) {
diff --git a/layout/style/nsCSSDataBlock.cpp b/layout/style/nsCSSDataBlock.cpp
--- a/layout/style/nsCSSDataBlock.cpp
+++ b/layout/style/nsCSSDataBlock.cpp
@@ -271,17 +271,17 @@ nsCSSCompressedDataBlock::MapRuleInfoInt
                             // in rgba notation.
                             nsCSSValue &colorVal = target->mXValue;
                             nsCSSUnit u = colorVal.GetUnit();
                             nsDependentString buf;
                             
                             if ((u == eCSSUnit_Color &&
                                  NS_GET_A(colorVal.GetColorValue())
                                  > 0) ||
-                                (u == eCSSUnit_String &&
+                                (u == eCSSUnit_Ident &&
                                  !nsGkAtoms::transparent->
                                  Equals(colorVal.GetStringValue(buf))) ||
                                 (u == eCSSUnit_EnumColor)) {
                                 colorVal.SetColorValue(aRuleData->
                                     mPresContext->
                                     DefaultBackgroundColor());
                             }
                             // We could consider using the fallback
diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -233,16 +233,18 @@ nsCSSDeclaration::AppendCSSValueToString
 
   if (eCSSUnit_Null == unit) {
     return PR_FALSE;
   }
 
   if (eCSSUnit_String <= unit && unit <= eCSSUnit_Attr) {
     if (unit == eCSSUnit_Attr) {
       aResult.AppendLiteral("attr(");
+    } else if (unit == eCSSUnit_String) {
+      aResult.Append(PRUnichar('"'));
     }
     nsAutoString  buffer;
     aValue.GetStringValue(buffer);
     aResult.Append(buffer);
   }
   else if (eCSSUnit_Array <= unit && unit <= eCSSUnit_Counters) {
     switch (unit) {
       case eCSSUnit_Counter:  aResult.AppendLiteral("counter(");  break;
@@ -417,17 +419,19 @@ nsCSSDeclaration::AppendCSSValueToString
     case eCSSUnit_Normal:       aResult.AppendLiteral("normal");   break;
     case eCSSUnit_System_Font:  aResult.AppendLiteral("-moz-use-system-font"); break;
     case eCSSUnit_Dummy:
     case eCSSUnit_DummyInherit:
     case eCSSUnit_RectIsAuto:
       NS_NOTREACHED("should never serialize");
       break;
 
-    case eCSSUnit_String:       break;
+    case eCSSUnit_String:       aResult.Append(PRUnichar('"'));    break;
+    case eCSSUnit_Ident:        break;
+    case eCSSUnit_Families:     break;
     case eCSSUnit_URL:          break;
     case eCSSUnit_Image:        break;
     case eCSSUnit_Array:        break;
     case eCSSUnit_Attr:
     case eCSSUnit_Counter:
     case eCSSUnit_Counters:     aResult.Append(PRUnichar(')'));    break;
     case eCSSUnit_Local_Font:   break;
     case eCSSUnit_Font_Format:  break;
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -85,17 +85,17 @@
 #include "nsAutoPtr.h"
 #include "nsTArray.h"
 #include "prlog.h"
 
 // Flags for ParseVariant method
 #define VARIANT_KEYWORD         0x000001  // K
 #define VARIANT_LENGTH          0x000002  // L
 #define VARIANT_PERCENT         0x000004  // P
-#define VARIANT_COLOR           0x000008  // C eCSSUnit_Color, eCSSUnit_String (e.g.  "red")
+#define VARIANT_COLOR           0x000008  // C eCSSUnit_Color, eCSSUnit_Ident (e.g.  "red")
 #define VARIANT_URL             0x000010  // U
 #define VARIANT_NUMBER          0x000020  // N
 #define VARIANT_INTEGER         0x000040  // I
 #define VARIANT_ANGLE           0x000080  // G
 #define VARIANT_FREQUENCY       0x000100  // F
 #define VARIANT_TIME            0x000200  // T
 #define VARIANT_STRING          0x000400  // S
 #define VARIANT_COUNTER         0x000800  //
@@ -1173,17 +1173,17 @@ CSSParserImpl::ParseColorString(const ns
   nsresult rv = mScanner.GetLowLevelError();
   OUTPUT_ERROR();
   ReleaseScanner();
 
   if (!colorParsed) {
     return NS_FAILED(rv) ? rv : NS_ERROR_FAILURE;
   }
 
-  if (value.GetUnit() == eCSSUnit_String) {
+  if (value.GetUnit() == eCSSUnit_Ident) {
     nscolor rgba;
     if (NS_ColorNameToRGB(nsDependentString(value.GetStringBufferValue()), &rgba)) {
       (*aColor) = rgba;
       rv = NS_OK;
     }
   } else if (value.GetUnit() == eCSSUnit_Color) {
     (*aColor) = value.GetColorValue();
     rv = NS_OK;
@@ -3539,17 +3539,17 @@ CSSParserImpl::ParseColor(nsCSSValue& aV
       if (NS_HexToRGB(tk->mIdent, &rgba)) {
         aValue.SetColorValue(rgba);
         return PR_TRUE;
       }
       break;
 
     case eCSSToken_Ident:
       if (NS_ColorNameToRGB(tk->mIdent, &rgba)) {
-        aValue.SetStringValue(tk->mIdent, eCSSUnit_String);
+        aValue.SetStringValue(tk->mIdent, eCSSUnit_Ident);
         return PR_TRUE;
       }
       else {
         nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(tk->mIdent);
         if (eCSSKeyword_UNKNOWN < keyword) { // known keyword
           PRInt32 value;
           if (nsCSSProps::FindKeyword(keyword, nsCSSProps::kColorKTable, value)) {
             aValue.SetIntValue(value, eCSSUnit_EnumColor);
@@ -4471,17 +4471,17 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
     buffer.Append(tk->mSymbol);
     buffer.Append(tk->mIdent);
     buffer.Append(tk->mSymbol);
     aValue.SetStringValue(buffer, eCSSUnit_String);
     return PR_TRUE;
   }
   if (((aVariantMask & VARIANT_IDENTIFIER) != 0) &&
       (eCSSToken_Ident == tk->mType)) {
-    aValue.SetStringValue(tk->mIdent, eCSSUnit_String);
+    aValue.SetStringValue(tk->mIdent, eCSSUnit_Ident);
     return PR_TRUE;
   }
   if (((aVariantMask & VARIANT_COUNTER) != 0) &&
       (eCSSToken_Function == tk->mType) &&
       (tk->mIdent.LowerCaseEqualsLiteral("counter") ||
        tk->mIdent.LowerCaseEqualsLiteral("counters"))) {
     return ParseCounter(aValue);
   }
@@ -4513,17 +4513,17 @@ CSSParserImpl::ParseCounter(nsCSSValue& 
 
   nsRefPtr<nsCSSValue::Array> val =
     nsCSSValue::Array::Create(unit == eCSSUnit_Counter ? 2 : 3);
   if (!val) {
     mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     return PR_FALSE;
   }
 
-  val->Item(0).SetStringValue(mToken.mIdent, eCSSUnit_String);
+  val->Item(0).SetStringValue(mToken.mIdent, eCSSUnit_Ident);
 
   if (eCSSUnit_Counters == unit) {
     // get mandatory separator string
     if (!ExpectSymbol(',', PR_TRUE) ||
         !(GetNonCloseParenToken(PR_TRUE) &&
           eCSSToken_String == mToken.mType)) {
       SkipUntil(')');
       return PR_FALSE;
@@ -5757,17 +5757,17 @@ PRBool
 CSSParserImpl::ParseFontDescriptorValue(nsCSSFontDesc aDescID,
                                         nsCSSValue& aValue)
 {
   switch (aDescID) {
     // These four are similar to the properties of the same name,
     // possibly with more restrictions on the values they can take.
   case eCSSFontDesc_Family: {
     if (!ParseFamily(aValue) ||
-        aValue.GetUnit() != eCSSUnit_String)
+        aValue.GetUnit() != eCSSUnit_Families)
       return PR_FALSE;
 
     // the style parameters to the nsFont constructor are ignored,
     // because it's only being used to call EnumerateFamilies
     nsAutoString valueStr;
     aValue.GetStringValue(valueStr);
     nsFont font(valueStr, 0, 0, 0, 0, 0, 0);
     ExtractFirstFamilyData dat;
@@ -6797,17 +6797,17 @@ CSSParserImpl::ParseCounterData(nsCSSVal
       break;
     }
     nsCSSValuePairList *data = *next = new nsCSSValuePairList();
     if (!data) {
       mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
       break;
     }
     next = &data->mNext;
-    data->mXValue.SetStringValue(mToken.mIdent, eCSSUnit_String);
+    data->mXValue.SetStringValue(mToken.mIdent, eCSSUnit_Ident);
     if (GetToken(PR_TRUE)) {
       if (eCSSToken_Number == mToken.mType && mToken.mIntegerValid) {
         data->mYValue.SetIntValue(mToken.mInteger, eCSSUnit_Integer);
       } else {
         UngetToken();
       }
     }
     if (ExpectEndProperty()) {
@@ -7159,17 +7159,17 @@ CSSParserImpl::ParseFunction(const nsStr
   nsRefPtr<nsCSSValue::Array> convertedArray =
     nsCSSValue::Array::Create(numElements);
   if (!convertedArray) {
     mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     return PR_FALSE;
   }
   
   /* Copy things over. */
-  convertedArray->Item(0).SetStringValue(functionName, eCSSUnit_String);
+  convertedArray->Item(0).SetStringValue(functionName, eCSSUnit_Ident);
   for (PRUint16 index = 0; index + 1 < numElements; ++index)
     convertedArray->Item(index + 1) = foundValues[static_cast<arrlen_t>(index)];
   
   /* Fill in the outparam value with the array. */
   aValue.SetArrayValue(convertedArray, eCSSUnit_Function);
   
   /* Return it! */
   return PR_TRUE;
@@ -7469,17 +7469,17 @@ CSSParserImpl::ParseFamily(nsCSSValue& a
       break;
 
     family.Append(PRUnichar(','));
   }
 
   if (family.IsEmpty()) {
     return PR_FALSE;
   }
-  aValue.SetStringValue(family, eCSSUnit_String);
+  aValue.SetStringValue(family, eCSSUnit_Families);
   return PR_TRUE;
 }
 
 // src: ( uri-src | local-src ) (',' ( uri-src | local-src ) )*
 // uri-src: uri [ 'format(' string ( ',' string )* ')' ]
 // local-src: 'local(' ( string | ident ) ')'
 
 PRBool
@@ -7948,17 +7948,17 @@ CSSParserImpl::ParseCSSShadowList(PRBool
         mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
         break;
       }
       PRBool haveColor = PR_FALSE;
       if (cur->mValue.IsLengthUnit()) {
         val->Item(IndexX) = cur->mValue;
       } else {
         // Must be a color (as string or color value)
-        NS_ASSERTION(unit == eCSSUnit_String || unit == eCSSUnit_Color ||
+        NS_ASSERTION(unit == eCSSUnit_Ident || unit == eCSSUnit_Color ||
                      unit == eCSSUnit_EnumColor,
                      "Must be a color value (named color, numeric color, "
                      "or system color)");
         haveColor = PR_TRUE;
         val->Item(IndexColor) = cur->mValue;
 
         // Parse the X coordinate
         if (!ParseVariant(val->Item(IndexX), VARIANT_LENGTH,
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -94,19 +94,21 @@ enum nsCSSUnit {
   eCSSUnit_Normal       = 5,      // (n/a) value is normal (algorithmic, different than auto)
   eCSSUnit_System_Font  = 6,      // (n/a) value is -moz-use-system-font
   eCSSUnit_Dummy        = 7,      // (n/a) a fake but specified value, used
                                   //       only in temporary values
   eCSSUnit_DummyInherit = 8,      // (n/a) a fake but specified value, used
                                   //       only in temporary values
   eCSSUnit_RectIsAuto   = 9,      // (n/a) 'auto' for an entire rect()
   eCSSUnit_String       = 10,     // (PRUnichar*) a string value
-  eCSSUnit_Attr         = 11,     // (PRUnichar*) a attr(string) value
-  eCSSUnit_Local_Font   = 12,     // (PRUnichar*) a local font name
-  eCSSUnit_Font_Format  = 13,     // (PRUnichar*) a font format name
+  eCSSUnit_Ident        = 11,     // (PRUnichar*) a string value
+  eCSSUnit_Families     = 12,     // (PRUnichar*) a string value
+  eCSSUnit_Attr         = 13,     // (PRUnichar*) a attr(string) value
+  eCSSUnit_Local_Font   = 14,     // (PRUnichar*) a local font name
+  eCSSUnit_Font_Format  = 15,     // (PRUnichar*) a font format name
   eCSSUnit_Array        = 20,     // (nsCSSValue::Array*) a list of values
   eCSSUnit_Counter      = 21,     // (nsCSSValue::Array*) a counter(string,[string]) value
   eCSSUnit_Counters     = 22,     // (nsCSSValue::Array*) a counters(string,string[,string]) value
   eCSSUnit_Function     = 23,     // (nsCSSValue::Array*) a function with parameters.  First elem of array is name,
                                   //  the rest of the values are arguments.
 
   eCSSUnit_URL          = 30,     // (nsCSSValue::URL*) value
   eCSSUnit_Image        = 31,     // (nsCSSValue::Image*) value
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -440,17 +440,17 @@ static PRBool SetColor(const nsCSSValue&
 {
   PRBool  result = PR_FALSE;
   nsCSSUnit unit = aValue.GetUnit();
 
   if (eCSSUnit_Color == unit) {
     aResult = aValue.GetColorValue();
     result = PR_TRUE;
   }
-  else if (eCSSUnit_String == unit) {
+  else if (eCSSUnit_Ident == unit) {
     nsAutoString  value;
     aValue.GetStringValue(value);
     nscolor rgba;
     if (NS_ColorNameToRGB(value, &rgba)) {
       aResult = rgba;
       result = PR_TRUE;
     }
   }
@@ -2561,17 +2561,17 @@ nsRuleNode::SetFont(nsPresContext* aPres
     // In case somebody explicitly used -moz-use-system-font.
     systemFont = *defaultVariableFont;
   }
 
 
   // font-family: string list, enum, inherit
   NS_ASSERTION(eCSSUnit_Enumerated != aFontData.mFamily.GetUnit(),
                "system fonts should not be in mFamily anymore");
-  if (eCSSUnit_String == aFontData.mFamily.GetUnit()) {
+  if (eCSSUnit_Families == aFontData.mFamily.GetUnit()) {
     // set the correct font if we are using DocumentFonts OR we are overriding for XUL
     // MJA: bug 31816
     if (aGenericFontID == kGenericFont_NONE) {
       // only bother appending fallback fonts if this isn't a fallback generic font itself
       if (!aFont->mFont.name.IsEmpty())
         aFont->mFont.name.Append((PRUnichar)',');
       // defaultVariableFont.name should always be "serif" or "sans-serif".
       aFont->mFont.name.Append(defaultVariableFont->name);
@@ -2900,17 +2900,17 @@ nsRuleNode::ComputeFontData(void* aStart
     useDocumentFonts = PR_TRUE;
     minimumFontSize = 0;
   }
 
   // Figure out if we are a generic font
   PRUint8 generic = kGenericFont_NONE;
   // XXXldb What if we would have had a string if we hadn't been doing
   // the optimization with a non-null aStartStruct?
-  if (eCSSUnit_String == fontData.mFamily.GetUnit()) {
+  if (eCSSUnit_Families == fontData.mFamily.GetUnit()) {
     fontData.mFamily.GetStringValue(font->mFont.name);
     // XXXldb Do we want to extract the generic for this if it's not only a
     // generic?
     nsFont::GetGenericID(font->mFont.name, &generic);
 
     // If we aren't allowed to use document fonts, then we are only entitled
     // to use the user's default variable-width font and fixed-width font
     if (!useDocumentFonts) {
@@ -3739,17 +3739,17 @@ nsRuleNode::ComputeVisibilityData(void* 
   // visibility: enum, inherit, initial
   SetDiscrete(displayData.mVisibility, visibility->mVisible,
               canStoreInRuleTree,
               SETDSC_ENUMERATED, parentVisibility->mVisible,
               NS_STYLE_VISIBILITY_VISIBLE, 0, 0, 0, 0);
 
   // lang: string, inherit
   // this is not a real CSS property, it is a html attribute mapped to CSS struture
-  if (eCSSUnit_String == displayData.mLang.GetUnit()) {
+  if (eCSSUnit_Ident == displayData.mLang.GetUnit()) {
     if (!gLangService) {
       CallGetService(NS_LANGUAGEATOMSERVICE_CONTRACTID, &gLangService);
     }
 
     if (gLangService) {
       nsAutoString lang;
       displayData.mLang.GetStringValue(lang);
       visibility->mLangGroup = gLangService->LookupLanguage(lang);
@@ -4889,17 +4889,17 @@ nsRuleNode::ComputeContentData(void* aSt
       if (NS_SUCCEEDED(content->AllocateCounterIncrements(count))) {
         while (0 < count--) {
           const nsStyleCounterData *data =
             parentContent->GetCounterIncrementAt(count);
           content->SetCounterIncrementAt(count, data->mCounter, data->mValue);
         }
       }
     }
-    else if (eCSSUnit_String == ourIncrement->mXValue.GetUnit()) {
+    else if (eCSSUnit_Ident == ourIncrement->mXValue.GetUnit()) {
       count = 0;
       while (ourIncrement) {
         count++;
         ourIncrement = ourIncrement->mNext;
       }
       if (NS_SUCCEEDED(content->AllocateCounterIncrements(count))) {
         count = 0;
         ourIncrement = contentData.mCounterIncrement;
@@ -4932,17 +4932,17 @@ nsRuleNode::ComputeContentData(void* aSt
       if (NS_SUCCEEDED(content->AllocateCounterResets(count))) {
         while (0 < count--) {
           const nsStyleCounterData *data =
             parentContent->GetCounterResetAt(count);
           content->SetCounterResetAt(count, data->mCounter, data->mValue);
         }
       }
     }
-    else if (eCSSUnit_String == ourReset->mXValue.GetUnit()) {
+    else if (eCSSUnit_Ident == ourReset->mXValue.GetUnit()) {
       count = 0;
       while (ourReset) {
         count++;
         ourReset = ourReset->mNext;
       }
       if (NS_SUCCEEDED(content->AllocateCounterResets(count))) {
         count = 0;
         ourReset = contentData.mCounterReset;
