From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Fix RestyleTracker to handle restyle hints exactly rather than pessimistically when restyling continuations with varying styles (e.g., spans inside ::first-line or ::first-letter).

This is necessary now because animation-only style flushes need to
update *only* the animation style data and no other style data.  Thus
using the RestyleTracker for animation-only style flushes requires that
we do this.

FIXME: WRITE

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1867,17 +1867,18 @@ GetPrevContinuationWithSameStyle(nsIFram
  * Since this is used when deciding to copy the new style context, it
  * takes as an argument the old style context to check if the style is
  * the same.  When it is used in other contexts (i.e., where the next
  * continuation would already have the new style context), the current
  * style context should be passed.
  */
 static nsIFrame*
 GetNextContinuationWithSameStyle(nsIFrame* aFrame,
-                                 nsStyleContext* aOldStyleContext)
+                                 nsStyleContext* aOldStyleContext,
+                                 bool* aHaveMoreContinuations = nullptr)
 {
   // See GetPrevContinuationWithSameStyle about {ib} splits.
 
   nsIFrame *nextContinuation = aFrame->GetNextContinuation();
   if (!nextContinuation &&
       (aFrame->GetStateBits() & NS_FRAME_PART_OF_IBSPLIT)) {
     // We're the last continuation, so we have to hop back to the first
     // before getting the frame property
@@ -1897,16 +1898,19 @@ GetNextContinuationWithSameStyle(nsIFram
                "unexpected content mismatch");
 
   nsStyleContext* nextStyle = nextContinuation->StyleContext();
   if (nextStyle != aOldStyleContext) {
     NS_ASSERTION(aOldStyleContext->GetPseudo() != nextStyle->GetPseudo() ||
                  aOldStyleContext->GetParent() != nextStyle->GetParent(),
                  "continuations should have the same style context");
     nextContinuation = nullptr;
+    if (aHaveMoreContinuations) {
+      *aHaveMoreContinuations = true;
+    }
   }
   return nextContinuation;
 }
 
 nsresult
 RestyleManager::ReparentStyleContext(nsIFrame* aFrame)
 {
   if (nsGkAtoms::placeholderFrame == aFrame->GetType()) {
@@ -2275,20 +2279,36 @@ ElementRestyler::Restyle(nsRestyleHint a
   nsRestyleHint childRestyleHint = nsRestyleHint(aRestyleHint & eRestyle_Subtree);
 
   {
     nsRefPtr<nsStyleContext> oldContext = mFrame->StyleContext();
 
     // TEMPORARY (until bug 918064):  Call RestyleSelf for each
     // continuation or block-in-inline sibling.
 
+    bool haveMoreContinuations = false;
     for (nsIFrame* f = mFrame; f;
-         f = GetNextContinuationWithSameStyle(f, oldContext)) {
+         f = GetNextContinuationWithSameStyle(f, oldContext,
+                                              &haveMoreContinuations)) {
       RestyleSelf(f, aRestyleHint);
     }
+
+    if (haveMoreContinuations) {
+      // If we have more continuations with different style (e.g., because
+      // we're inside a ::first-letter or ::first-line), put the restyle
+      // hint back.
+
+      // FIXME: WRITE ME
+      // FIXME: It seems like the above GetRestyleData call might be
+      // broken for calls in the second ProcessOneRestyle loop in
+      // RestyleTracker::DoProcessRestyles, because CollectRestyles will
+      // clear the restyle tracker.  It also seems like that means our
+      // ancestor-descendant coalescing is broken for everything other
+      // than eRestyle_Subtree.
+    }
   }
 
   RestyleChildren(childRestyleHint);
 }
 
 void
 ElementRestyler::RestyleSelf(nsIFrame* aSelf, nsRestyleHint aRestyleHint)
 {
@@ -2373,27 +2393,17 @@ ElementRestyler::RestyleSelf(nsIFrame* a
     // continuation.
     newContext = prevContinuationContext;
   }
   else if (pseudoTag == nsCSSAnonBoxes::mozNonElement) {
     NS_ASSERTION(aSelf->GetContent(),
                  "non pseudo-element frame without content node");
     newContext = styleSet->ResolveStyleForNonElement(parentContext);
   }
-  else if (!(aRestyleHint & (eRestyle_Self | eRestyle_Subtree)) &&
-           !prevContinuation) {
-    // Unfortunately, if prevContinuation is non-null then we may have
-    // already stolen the restyle tracker entry for this element while
-    // processing prevContinuation.  So we don't know whether aRestyleHint
-    // should really be 0 here or whether it should be eRestyle_Self.  Be
-    // pessimistic and force an actual reresolve in that situation.  The good
-    // news is that in the common case when prevContinuation is non-null we
-    // just used prevContinuationContext anyway and aren't reaching this code
-    // to start with.
-
+  else if (!(aRestyleHint & (eRestyle_Self | eRestyle_Subtree))) {
     Element* element = ElementForStyleContext(mParentContent, aSelf, pseudoType);
     if (aRestyleHint == nsRestyleHint(0)) {
       newContext =
         styleSet->ReparentStyleContext(oldContext, parentContext, element);
     } else {
       newContext =
         styleSet->ResolveStyleWithReplacement(element, parentContext, oldContext,
                                               aRestyleHint);
