From: L. David Baron <dbaron@dbaron.org>

Remove null-checks for infallible array allocations.  (Bug 520234)  r=bzbarsky  a=blocking2.0:beta7

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -1794,21 +1794,16 @@ CSSParserImpl::ParseMediaQueryExpression
     case nsMediaFeature::eFloat:
       rv = ParseNonNegativeVariant(expr->mValue, VARIANT_NUMBER, nsnull);
       break;
     case nsMediaFeature::eIntRatio:
       {
         // Two integers separated by '/', with optional whitespace on
         // either side of the '/'.
         nsRefPtr<nsCSSValue::Array> a = nsCSSValue::Array::Create(2);
-        if (!a) {
-          mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-          SkipUntil(')');
-          return PR_FALSE;
-        }
         expr->mValue.SetArrayValue(a, eCSSUnit_Array);
         // We don't bother with ParseNonNegativeVariant since we have to
         // check for != 0 as well; no need to worry about the UngetToken
         // since we're throwing out up to the next ')' anyway.
         rv = ParseVariant(a->Item(0), VARIANT_INTEGER, nsnull) &&
              a->Item(0).GetIntValue() > 0 &&
              ExpectSymbol('/', PR_TRUE) &&
              ParseVariant(a->Item(1), VARIANT_INTEGER, nsnull) &&
@@ -4515,20 +4510,16 @@ CSSParserImpl::ParseCounter(nsCSSValue& 
     }
     if (eCSSToken_Ident != mToken.mType) {
       UngetToken();
       break;
     }
 
     nsRefPtr<nsCSSValue::Array> val =
       nsCSSValue::Array::Create(unit == eCSSUnit_Counter ? 2 : 3);
-    if (!val) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      break;
-    }
 
     val->Item(0).SetStringValue(mToken.mIdent, eCSSUnit_Ident);
 
     if (eCSSUnit_Counters == unit) {
       // must have a comma and then a separator string
       if (!ExpectSymbol(',', PR_TRUE) || !GetToken(PR_TRUE)) {
         break;
       }
@@ -6643,20 +6634,16 @@ CSSParserImpl::ParseBorderImage()
   if (ParseVariant(val, VARIANT_INHERIT | VARIANT_NONE, nsnull)) {
     AppendValue(eCSSProperty_border_image, val);
     return PR_TRUE;
   }
 
   // <uri> [<number> | <percentage>]{1,4}
   //       [ / <border-width>{1,4} ]? [stretch | repeat | round]{0,2}
   nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(11);
-  if (!arr) {
-    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-    return PR_FALSE;
-  }
 
   nsCSSValue& url = arr->Item(0);
   nsCSSValue& splitTop = arr->Item(1);
   nsCSSValue& splitRight = arr->Item(2);
   nsCSSValue& splitBottom = arr->Item(3);
   nsCSSValue& splitLeft = arr->Item(4);
   nsCSSValue& borderWidthTop = arr->Item(5);
   nsCSSValue& borderWidthRight = arr->Item(6);
@@ -6930,20 +6917,16 @@ CSSParserImpl::ParseCalc(nsCSSValue &aVa
   // values cannot themselves be numbers.
   NS_ASSERTION(!(aVariantMask & VARIANT_NUMBER), "unexpected variant mask");
   NS_ABORT_IF_FALSE(aVariantMask != 0, "unexpected variant mask");
 
   // One-iteration loop so we can break to the error-handling case.
   do {
     // The toplevel of a calc() is always an nsCSSValue::Array of length 1.
     nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(1);
-    if (!arr) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      break;
-    }
 
     if (!ParseCalcAdditiveExpression(arr->Item(0), aVariantMask))
       break;
 
     if (!ExpectSymbol(')', PR_TRUE))
       break;
 
     aValue.SetArrayValue(arr, eCSSUnit_Calc);
@@ -6988,20 +6971,16 @@ CSSParserImpl::ParseCalcAdditiveExpressi
     } else {
       UngetToken();
       return PR_TRUE;
     }
     if (!RequireWhitespace())
       return PR_FALSE;
 
     nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(2);
-    if (!arr) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      return PR_FALSE;
-    }
     arr->Item(0) = aValue;
     storage = &arr->Item(1);
     aValue.SetArrayValue(arr, unit);
   }
 }
 
 struct ReduceNumberCalcOps : public mozilla::css::BasicFloatCalcOps,
                              public mozilla::css::CSSValueInputCalcOps
@@ -7093,20 +7072,16 @@ CSSParserImpl::ParseCalcMultiplicativeEx
       afterDivision = PR_TRUE;
     } else {
       UngetToken();
       *aHadFinalWS = hadWS;
       break;
     }
 
     nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(2);
-    if (!arr) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      return PR_FALSE;
-    }
     arr->Item(0) = aValue;
     storage = &arr->Item(1);
     aValue.SetArrayValue(arr, unit);
   }
 
   // Adjust aVariantMask (see comments above function) to reflect which
   // option we took.
   if (aVariantMask & VARIANT_NUMBER) {
@@ -7666,21 +7641,17 @@ CSSParserImpl::ParseFunction(const nsStr
    * We'll need N + 1 spots, one for the function name and the rest for the
    * arguments.  In case the user has given us more than 2^16 - 2 arguments,
    * we'll truncate them at 2^16 - 2 arguments.
    */
   PRUint16 numElements = (foundValues.Length() <= MAX_ALLOWED_ELEMS ?
                           foundValues.Length() + 1 : MAX_ALLOWED_ELEMS);
   nsRefPtr<nsCSSValue::Array> convertedArray =
     nsCSSValue::Array::Create(numElements);
-  if (!convertedArray) {
-    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-    return PR_FALSE;
-  }
-  
+
   /* Copy things over. */
   convertedArray->Item(0).SetStringValue(functionName, eCSSUnit_Ident);
   for (PRUint16 index = 0; index + 1 < numElements; ++index)
     convertedArray->Item(index + 1) = foundValues[static_cast<arrlen_t>(index)];
   
   /* Fill in the outparam value with the array. */
   aValue.SetArrayValue(convertedArray, eCSSUnit_Function);
   
@@ -8514,20 +8485,16 @@ PRBool
 CSSParserImpl::ParseTransitionTimingFunctionValues(nsCSSValue& aValue)
 {
   NS_ASSERTION(!mHavePushBack &&
                mToken.mType == eCSSToken_Function &&
                mToken.mIdent.LowerCaseEqualsLiteral("cubic-bezier"),
                "unexpected initial state");
 
   nsRefPtr<nsCSSValue::Array> val = nsCSSValue::Array::Create(4);
-  if (!val) {
-    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-    return PR_FALSE;
-  }
 
   float x1, x2, y1, y2;
   if (!ParseTransitionTimingFunctionValueComponent(x1, ',', PR_TRUE) ||
       !ParseTransitionTimingFunctionValueComponent(y1, ',', PR_FALSE) ||
       !ParseTransitionTimingFunctionValueComponent(x2, ',', PR_TRUE) ||
       !ParseTransitionTimingFunctionValueComponent(y2, ')', PR_FALSE)) {
     return PR_FALSE;
   }
diff --git a/layout/style/nsMediaFeatures.cpp b/layout/style/nsMediaFeatures.cpp
--- a/layout/style/nsMediaFeatures.cpp
+++ b/layout/style/nsMediaFeatures.cpp
@@ -157,17 +157,16 @@ GetOrientation(nsPresContext* aPresConte
     return NS_OK;
 }
 
 // Helper for two features below
 static nsresult
 MakeArray(const nsSize& aSize, nsCSSValue& aResult)
 {
     nsRefPtr<nsCSSValue::Array> a = nsCSSValue::Array::Create(2);
-    NS_ENSURE_TRUE(a, NS_ERROR_OUT_OF_MEMORY);
 
     a->Item(0).SetIntValue(aSize.width, eCSSUnit_Integer);
     a->Item(1).SetIntValue(aSize.height, eCSSUnit_Integer);
 
     aResult.SetArrayValue(a, eCSSUnit_Array);
     return NS_OK;
 }
 
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -224,35 +224,30 @@ ExtractCalcValue(const nsCSSValue& aValu
     result.mLength = 0.0f;
     result.mPercent = aValue.GetPercentValue();
     result.mHasPercent = PR_TRUE;
     return result;
   }
   return ExtractCalcValueInternal(aValue);
 }
 
-static bool
+static void
 SetCalcValue(const nsStyleCoord::Calc* aCalc, nsCSSValue& aValue)
 {
   nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(1);
-  if (!arr)
-    return false;
   if (!aCalc->mHasPercent) {
     nscoordToCSSValue(aCalc->mLength, arr->Item(0));
   } else {
     nsCSSValue::Array *arr2 = nsCSSValue::Array::Create(2);
-    if (!arr2)
-      return false;
     arr->Item(0).SetArrayValue(arr2, eCSSUnit_Calc_Plus);
     nscoordToCSSValue(aCalc->mLength, arr2->Item(0));
     arr2->Item(1).SetPercentValue(aCalc->mPercent);
   }
 
   aValue.SetArrayValue(arr, eCSSUnit_Calc);
-  return true;
 }
 
 // CLASS METHODS
 // -------------
 
 PRBool
 nsStyleAnimation::ComputeDistance(nsCSSProperty aProperty,
                                   const Value& aStartValue,
@@ -780,19 +775,16 @@ AddShadowItems(double aCoeff1, const nsC
   // X, Y, Radius, Spread, Color, Inset
   NS_ABORT_IF_FALSE(aValue1.GetUnit() == eCSSUnit_Array,
                     "wrong unit");
   NS_ABORT_IF_FALSE(aValue2.GetUnit() == eCSSUnit_Array,
                     "wrong unit");
   nsCSSValue::Array *array1 = aValue1.GetArrayValue();
   nsCSSValue::Array *array2 = aValue2.GetArrayValue();
   nsRefPtr<nsCSSValue::Array> resultArray = nsCSSValue::Array::Create(6);
-  if (!resultArray) {
-    return PR_FALSE;
-  }
 
   for (size_t i = 0; i < 4; ++i) {
     AddCSSValuePixel(aCoeff1, array1->Item(i), aCoeff2, array2->Item(i),
                      resultArray->Item(i));
   }
 
   const nsCSSValue& color1 = array1->Item(4);
   const nsCSSValue& color2 = array2->Item(4);
@@ -1458,25 +1450,19 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
       CalcValue v1 = ExtractCalcValue(aValue1);
       CalcValue v2 = ExtractCalcValue(aValue2);
       double len = aCoeff1 * v1.mLength + aCoeff2 * v2.mLength;
       double pct = aCoeff1 * v1.mPercent + aCoeff2 * v2.mPercent;
       PRBool hasPct = (aCoeff1 != 0.0 && v1.mHasPercent) ||
                       (aCoeff2 != 0.0 && v2.mHasPercent);
       nsCSSValue *val = new nsCSSValue();
       nsCSSValue::Array *arr = nsCSSValue::Array::Create(1);
-      if (!arr) {
-        return PR_FALSE;
-      }
       val->SetArrayValue(arr, eCSSUnit_Calc);
       if (hasPct) {
         nsCSSValue::Array *arr2 = nsCSSValue::Array::Create(2);
-        if (!arr2) {
-          return PR_FALSE;
-        }
         arr2->Item(0).SetFloatValue(len, eCSSUnit_Pixel);
         arr2->Item(1).SetPercentValue(pct);
         arr->Item(0).SetArrayValue(arr2, eCSSUnit_Calc_Plus);
       } else {
         arr->Item(0).SetFloatValue(len, eCSSUnit_Pixel);
       }
       aResultValue.SetAndAdoptCSSValueValue(val, eUnit_Calc);
       return PR_TRUE;
@@ -2092,18 +2078,17 @@ StyleCoordToValue(const nsStyleCoord& aC
                          nsStyleAnimation::eUnit_Enumerated);
       break;
     case eStyleUnit_Integer:
       aValue.SetIntValue(aCoord.GetIntValue(),
                          nsStyleAnimation::eUnit_Integer);
       break;
     case eStyleUnit_Calc: {
       nsAutoPtr<nsCSSValue> val(new nsCSSValue);
-      if (!SetCalcValue(aCoord.GetCalcValue(), *val))
-        return PR_FALSE;
+      SetCalcValue(aCoord.GetCalcValue(), *val);
       aValue.SetAndAdoptCSSValueValue(val.forget(),
                                       nsStyleAnimation::eUnit_Calc);
       break;
     }
     default:
       return PR_FALSE;
   }
   return PR_TRUE;
@@ -2115,18 +2100,17 @@ StyleCoordToCSSValue(const nsStyleCoord&
   switch (aCoord.GetUnit()) {
     case eStyleUnit_Coord:
       nscoordToCSSValue(aCoord.GetCoordValue(), aCSSValue);
       break;
     case eStyleUnit_Percent:
       aCSSValue.SetPercentValue(aCoord.GetPercentValue());
       break;
     case eStyleUnit_Calc:
-      if (!SetCalcValue(aCoord.GetCalcValue(), aCSSValue))
-        return PR_FALSE;
+      SetCalcValue(aCoord.GetCalcValue(), aCSSValue);
       break;
     default:
       NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
       return PR_FALSE;
   }
   return PR_TRUE;
 }
 
@@ -2431,30 +2415,28 @@ nsStyleAnimation::ExtractComputedValue(n
               item->mXValue.SetPercentValue(pos.mXPosition.mPercent);
             } else if (pos.mXPosition.mPercent == 0.0f) {
               nscoordToCSSValue(pos.mXPosition.mLength, item->mXValue);
             } else {
               nsStyleCoord::Calc calc;
               calc.mLength = pos.mXPosition.mLength;
               calc.mPercent = pos.mXPosition.mPercent;
               calc.mHasPercent = PR_TRUE;
-              if (!SetCalcValue(&calc, item->mXValue))
-                return PR_FALSE;
+              SetCalcValue(&calc, item->mXValue);
             }
             if (pos.mYPosition.mLength == 0) {
               item->mYValue.SetPercentValue(pos.mYPosition.mPercent);
             } else if (pos.mYPosition.mPercent == 0.0f) {
               nscoordToCSSValue(pos.mYPosition.mLength, item->mYValue);
             } else {
               nsStyleCoord::Calc calc;
               calc.mLength = pos.mYPosition.mLength;
               calc.mPercent = pos.mYPosition.mPercent;
               calc.mHasPercent = PR_TRUE;
-              if (!SetCalcValue(&calc, item->mYValue))
-                return PR_FALSE;
+              SetCalcValue(&calc, item->mYValue);
             }
           }
 
           aComputedValue.SetAndAdoptCSSValuePairListValue(result.forget());
           break;
         }
 
         case eCSSProperty_background_size: {
@@ -2483,18 +2465,17 @@ nsStyleAnimation::ExtractComputedValue(n
                   item->mXValue.SetPercentValue(size.mWidth.mPercent);
                 } else if (size.mWidth.mPercent == 0.0f) {
                   nscoordToCSSValue(size.mWidth.mLength, item->mXValue);
                 } else {
                   nsStyleCoord::Calc calc;
                   calc.mLength = size.mWidth.mLength;
                   calc.mPercent = size.mWidth.mPercent;
                   calc.mHasPercent = PR_TRUE;
-                  if (!SetCalcValue(&calc, item->mXValue))
-                    return PR_FALSE;
+                  SetCalcValue(&calc, item->mXValue);
                 }
                 break;
             }
 
             switch (size.mHeightType) {
               case nsStyleBackground::Size::eContain:
               case nsStyleBackground::Size::eCover:
                 // leave it null
@@ -2507,18 +2488,17 @@ nsStyleAnimation::ExtractComputedValue(n
                   item->mYValue.SetPercentValue(size.mHeight.mPercent);
                 } else if (size.mHeight.mPercent == 0.0f) {
                   nscoordToCSSValue(size.mHeight.mLength, item->mYValue);
                 } else {
                   nsStyleCoord::Calc calc;
                   calc.mLength = size.mHeight.mLength;
                   calc.mPercent = size.mHeight.mPercent;
                   calc.mHasPercent = PR_TRUE;
-                  if (!SetCalcValue(&calc, item->mYValue))
-                    return PR_FALSE;
+                  SetCalcValue(&calc, item->mYValue);
                 }
                 break;
             }
           }
 
           aComputedValue.SetAndAdoptCSSValuePairListValue(result.forget());
           break;
         }
