Don't keep hash tables around between cycle collections.  b=377606  Patch from peterv.

diff --git a/js/src/xpconnect/src/nsXPConnect.cpp b/js/src/xpconnect/src/nsXPConnect.cpp
--- a/js/src/xpconnect/src/nsXPConnect.cpp
+++ b/js/src/xpconnect/src/nsXPConnect.cpp
@@ -142,7 +142,7 @@ struct JSObjectRefcounts
 
     JSObjectRefcounts() : mMarkEnded(PR_FALSE)
     {
-        InitRefCounts();
+        mRefCounts.ops = nsnull;
 #ifndef XPCONNECT_STANDALONE
         mScopes.Init();
 #endif
@@ -150,22 +150,25 @@ struct JSObjectRefcounts
 
     ~JSObjectRefcounts()
     {
-        if(mRefCounts.ops)
-            PL_DHashTableFinish(&mRefCounts);
+        NS_ASSERTION(!mRefCounts.ops,
+                     "Didn't call PL_DHashTableFinish on mRefCounts?");
     }
 
     void InitRefCounts()
-    {
-        if(!PL_DHashTableInit(&mRefCounts, &RefCountOps, nsnull,
-                              sizeof(ObjRefCount), 65536))
-            mRefCounts.ops = nsnull;
-    }
-    void Clear()
     {
         if(!mRefCounts.ops || mRefCounts.entryCount > 0) {
             if(mRefCounts.ops)
                 PL_DHashTableFinish(&mRefCounts);
-            InitRefCounts();
+            if(!PL_DHashTableInit(&mRefCounts, &RefCountOps, nsnull,
+                                  sizeof(ObjRefCount), 65536))
+                mRefCounts.ops = nsnull;
+        }
+    }
+    void FinishRefCounts()
+    {
+        if(mRefCounts.ops) {
+            PL_DHashTableFinish(&mRefCounts);
+            mRefCounts.ops = nsnull;
         }
 #ifndef XPCONNECT_STANDALONE
         mScopes.Clear();
@@ -174,7 +177,7 @@ struct JSObjectRefcounts
 
     void MarkStart()
     {
-        Clear();
+        InitRefCounts();
         mMarkEnded = PR_FALSE;
     }
 
@@ -580,7 +583,7 @@ nsXPConnect::FinishCycleCollection()
 nsXPConnect::FinishCycleCollection()
 {
     if (mObjRefcounts)
-        mObjRefcounts->Clear();
+        mObjRefcounts->FinishRefCounts();
     return NS_OK;
 }
 
diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -333,7 +333,7 @@ static PLDHashTableOps GCTableOps = {
     PL_DHashClearEntryStub,
     PL_DHashFinalizeStub,
     InitPtrInfo
- };
+};
 
 struct GCTable
 {
@@ -341,26 +341,28 @@ struct GCTable
 
     GCTable()
     {
-        Init();
+        mTab.ops = nsnull;
     }
     ~GCTable()
     {
-        if (mTab.ops)
-            PL_DHashTableFinish(&mTab);
+        NS_ASSERTION(!mTab.ops, "Didn't call PL_DHashTableFinish on mTab?");
     }
 
     void Init()
-    {
-        if (!PL_DHashTableInit(&mTab, &GCTableOps, nsnull, sizeof(PtrInfo),
-                               32768))
-            mTab.ops = nsnull;
-    }
-    void Clear()
     {
         if (!mTab.ops || mTab.entryCount > 0) {
             if (mTab.ops)
                 PL_DHashTableFinish(&mTab);
-            Init();
+            if (!PL_DHashTableInit(&mTab, &GCTableOps, nsnull, sizeof(PtrInfo),
+                                   32768))
+                mTab.ops = nsnull;
+        }
+    }
+    void Finish()
+    {
+        if (mTab.ops) {
+            PL_DHashTableFinish(&mTab);
+            mTab.ops = nsnull;
         }
     }
 
@@ -1511,8 +1513,6 @@ nsCycleCollector::nsCycleCollector() :
 
 nsCycleCollector::~nsCycleCollector()
 {
-    mGraph.Clear();    
-
     for (PRUint32 i = 0; i < nsIProgrammingLanguage::MAX+1; ++i) {
         mRuntimes[i] = NULL;
     }
@@ -1804,7 +1804,7 @@ nsCycleCollector::Collect(PRUint32 aTryC
 
                 mScanInProgress = PR_TRUE;
 
-                mGraph.Clear();
+                mGraph.Init();
 
                 // The main Bacon & Rajan collection algorithm.
 
@@ -1848,8 +1848,6 @@ nsCycleCollector::Collect(PRUint32 aTryC
 
                 // Some additional book-keeping.
 
-                mGraph.Clear();
-
                 --aTryCollections;
             }
 
@@ -1869,6 +1867,8 @@ nsCycleCollector::Collect(PRUint32 aTryC
                 mRuntimes[i]->FinishCycleCollection();
         }
     }
+
+    mGraph.Finish();
 
 #ifdef COLLECT_TIME_DEBUG
     printf("cc: Collect() took %lldms\n",
@@ -1968,7 +1968,7 @@ nsCycleCollector::ExplainLiveExpectedGar
     mCollectionInProgress = PR_TRUE;
     mScanInProgress = PR_TRUE;
 
-    mGraph.Clear();
+    mGraph.Init();
     mBufs[0].Empty();
 
     // Instead of filling mBufs[0] from the purple buffer, we fill it
@@ -1986,7 +1986,7 @@ nsCycleCollector::ExplainLiveExpectedGar
         explainWalker(mGraph, mRuntimes).Walk(s); 
     }
 
-    mGraph.Clear();
+    mGraph.Finish();
 
     mCollectionInProgress = PR_FALSE;
 
