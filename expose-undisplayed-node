From: L. David Baron <dbaron@dbaron.org>

Bug 896138 patch 5:  Expose UndisplayedNode list from nsFrameManager.

diff --git a/layout/base/nsFrameManager.cpp b/layout/base/nsFrameManager.cpp
--- a/layout/base/nsFrameManager.cpp
+++ b/layout/base/nsFrameManager.cpp
@@ -121,45 +121,16 @@ static PLDHashTableOps PlaceholderMapOps
   NULL
 };
 
 //----------------------------------------------------------------------
 
 // XXXldb This seems too complicated for what I think it's doing, and it
 // should also be using pldhash rather than plhash to use less memory.
 
-class UndisplayedNode {
-public:
-  UndisplayedNode(nsIContent* aContent, nsStyleContext* aStyle)
-    : mContent(aContent),
-      mStyle(aStyle),
-      mNext(nullptr)
-  {
-    MOZ_COUNT_CTOR(UndisplayedNode);
-  }
-
-  NS_HIDDEN ~UndisplayedNode()
-  {
-    MOZ_COUNT_DTOR(UndisplayedNode);
-
-    // Delete mNext iteratively to avoid blowing up the stack (bug 460461).
-    UndisplayedNode *cur = mNext;
-    while (cur) {
-      UndisplayedNode *next = cur->mNext;
-      cur->mNext = nullptr;
-      delete cur;
-      cur = next;
-    }
-  }
-
-  nsCOMPtr<nsIContent>      mContent;
-  nsRefPtr<nsStyleContext>  mStyle;
-  UndisplayedNode*          mNext;
-};
-
 class nsFrameManagerBase::UndisplayedMap {
 public:
   UndisplayedMap(uint32_t aNumBuckets = 16) NS_HIDDEN;
   ~UndisplayedMap(void) NS_HIDDEN;
 
   NS_HIDDEN_(UndisplayedNode*) GetFirstNode(nsIContent* aParentContent);
 
   NS_HIDDEN_(nsresult) AddNodeFor(nsIContent* aParentContent,
@@ -306,17 +277,26 @@ nsFrameManager::GetUndisplayedContent(ns
   for (UndisplayedNode* node = mUndisplayedMap->GetFirstNode(parent);
          node; node = node->mNext) {
     if (node->mContent == aContent)
       return node->mStyle;
   }
 
   return nullptr;
 }
-  
+
+UndisplayedNode*
+nsFrameManager::GetAllUndisplayedContentIn(nsIContent* aParentContent)
+{
+  if (!mUndisplayedMap)
+    return nullptr;
+
+  return mUndisplayedMap->GetFirstNode(aParentContent);
+}
+
 void
 nsFrameManager::SetUndisplayedContent(nsIContent* aContent, 
                                       nsStyleContext* aStyleContext)
 {
   NS_PRECONDITION(!aStyleContext->GetPseudo(),
                   "Should only have actual elements here");
 
 #ifdef DEBUG_UNDISPLAYED_MAP
diff --git a/layout/base/nsFrameManager.h b/layout/base/nsFrameManager.h
--- a/layout/base/nsFrameManager.h
+++ b/layout/base/nsFrameManager.h
@@ -21,16 +21,49 @@
 
 #include "nsIFrame.h"
 #include "nsIStatefulFrame.h"
 #include "nsChangeHint.h"
 #include "nsFrameManagerBase.h"
 
 namespace mozilla {
 class RestyleTracker;
+
+/**
+ * Node in a linked list, containing the style for an element that
+ * does not have a frame but whose parent does have a frame.
+ */
+struct UndisplayedNode {
+  UndisplayedNode(nsIContent* aContent, nsStyleContext* aStyle)
+    : mContent(aContent),
+      mStyle(aStyle),
+      mNext(nullptr)
+  {
+    MOZ_COUNT_CTOR(mozilla::UndisplayedNode);
+  }
+
+  NS_HIDDEN ~UndisplayedNode()
+  {
+    MOZ_COUNT_DTOR(mozilla::UndisplayedNode);
+
+    // Delete mNext iteratively to avoid blowing up the stack (bug 460461).
+    UndisplayedNode *cur = mNext;
+    while (cur) {
+      UndisplayedNode *next = cur->mNext;
+      cur->mNext = nullptr;
+      delete cur;
+      cur = next;
+    }
+  }
+
+  nsCOMPtr<nsIContent>      mContent;
+  nsRefPtr<nsStyleContext>  mStyle;
+  UndisplayedNode*          mNext;
+};
+
 } // namespace mozilla
 
 struct TreeMatchContext;
 
 /**
  * Frame manager interface. The frame manager serves two purposes:
  * <li>provides a service for mapping from content to frame and from
  * out-of-flow frame to placeholder frame.
@@ -69,16 +102,18 @@ public:
 
   NS_HIDDEN_(void)
     UnregisterPlaceholderFrame(nsPlaceholderFrame* aPlaceholderFrame);
 
   NS_HIDDEN_(void)      ClearPlaceholderFrameMap();
 
   // Mapping undisplayed content
   NS_HIDDEN_(nsStyleContext*) GetUndisplayedContent(nsIContent* aContent);
+  NS_HIDDEN_(mozilla::UndisplayedNode*)
+    GetAllUndisplayedContentIn(nsIContent* aParentContent);
   NS_HIDDEN_(void) SetUndisplayedContent(nsIContent* aContent,
                                          nsStyleContext* aStyleContext);
   NS_HIDDEN_(void) ChangeUndisplayedContent(nsIContent* aContent,
                                             nsStyleContext* aStyleContext);
   NS_HIDDEN_(void) ClearUndisplayedContentIn(nsIContent* aContent,
                                              nsIContent* aParentContent);
   NS_HIDDEN_(void) ClearAllUndisplayedContentIn(nsIContent* aParentContent);
 
