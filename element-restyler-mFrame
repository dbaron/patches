From: L. David Baron <dbaron@dbaron.org>

Bug 898209 patch 3:  Create and use ElementRestyler::mFrame.  r=heycam

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1905,42 +1905,48 @@ RestyleManager::ReparentStyleContext(nsI
 #endif
       }
     }
   }
   return NS_OK;
 }
 
 ElementRestyler::ElementRestyler(nsPresContext* aPresContext,
+                                 nsIFrame* aFrame,
                                  nsChangeHint aHintsHandledByAncestors)
   : mPresContext(aPresContext)
+  , mFrame(aFrame)
   , mHintsHandled(NS_SubtractHint(aHintsHandledByAncestors,
                   NS_HintsNotHandledForDescendantsIn(aHintsHandledByAncestors)))
 {
 }
 
-ElementRestyler::ElementRestyler(const ElementRestyler& aParentRestyler)
+ElementRestyler::ElementRestyler(const ElementRestyler& aParentRestyler,
+                                 nsIFrame* aFrame)
   : mPresContext(aParentRestyler.mPresContext)
+  , mFrame(aFrame)
   , mHintsHandled(NS_SubtractHint(aParentRestyler.mHintsHandled,
                   NS_HintsNotHandledForDescendantsIn(aParentRestyler.mHintsHandled)))
 {
 }
 
 ElementRestyler::ElementRestyler(ParentContextFromChildFrame,
-                                 const ElementRestyler& aParentRestyler)
+                                 const ElementRestyler& aParentRestyler,
+                                 nsIFrame* aFrame)
   : mPresContext(aParentRestyler.mPresContext)
+  , mFrame(aFrame)
   , mHintsHandled(NS_SubtractHint(aParentRestyler.mHintsHandled,
                   NS_HintsNotHandledForDescendantsIn(aParentRestyler.mHintsHandled)))
 {
 }
 
 void
 ElementRestyler::CaptureChange(nsStyleContext* aOldContext,
                                nsStyleContext* aNewContext,
-                               nsIFrame* aFrame, nsIContent* aContent,
+                               nsIContent* aContent,
                                nsStyleChangeList* aChangeList,
                                /*in*/nsChangeHint aParentHintsNotHandledForDescendants,
                                /*out*/nsChangeHint &aHintsNotHandledForDescendants,
                                nsChangeHint aChangeToAssume)
 {
   nsChangeHint ourChange = aOldContext->CalcStyleDifference(aNewContext,
                              aParentHintsNotHandledForDescendants);
   NS_ASSERTION(!(ourChange & nsChangeHint_AllReflowHints) ||
@@ -1953,187 +1959,186 @@ ElementRestyler::CaptureChange(nsStyleCo
   if ((ourChange & nsChangeHint_UpdateEffects) &&
       aContent && !aContent->IsElement()) {
     ourChange = NS_SubtractHint(ourChange, nsChangeHint_UpdateEffects);
   }
 
   NS_UpdateHint(ourChange, aChangeToAssume);
   if (NS_UpdateHint(mHintsHandled, ourChange)) {
     if (!(ourChange & nsChangeHint_ReconstructFrame) || aContent) {
-      aChangeList->AppendChange(aFrame, aContent, ourChange);
+      aChangeList->AppendChange(mFrame, aContent, ourChange);
     }
   }
   aHintsNotHandledForDescendants = NS_HintsNotHandledForDescendantsIn(ourChange);
 }
 
 /**
- * Recompute style for aFrame and accumulate changes into aChangeList
+ * Recompute style for mFrame and accumulate changes into aChangeList
  * given that mHintsHandled is already accumulated for an ancestor.
  * aParentContent is the content node used to resolve the parent style
  * context.  This means that, for pseudo-elements, it is the content
  * that should be used for selector matching (rather than the fake
  * content node attached to the frame).
  *
  * For aParentFrameHintsNotHandledForDescendants, see
  * nsStyleContext::CalcStyleDifference.
  */
 void
 ElementRestyler::Restyle(nsPresContext     *aPresContext,
-                         nsIFrame          *aFrame,
                          nsIContent        *aParentContent,
                          nsStyleChangeList *aChangeList,
                          nsChangeHint       aParentFrameHintsNotHandledForDescendants,
                          nsRestyleHint      aRestyleHint,
                          RestyleTracker&    aRestyleTracker,
                          DesiredA11yNotifications aDesiredA11yNotifications,
                          nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
                          TreeMatchContext &aTreeMatchContext)
 {
   // It would be nice if we could make stronger assertions here; they
   // would let us simplify the ?: expressions below setting |content|
   // and |pseudoContent| in sensible ways as well as making what
   // |localContent|, |content|, and |pseudoContent| mean make more
   // sense.  However, we can't, because of frame trees like the one in
   // https://bugzilla.mozilla.org/show_bug.cgi?id=472353#c14 .  Once we
   // fix bug 242277 we should be able to make this make more sense.
-  NS_ASSERTION(aFrame->GetContent() || !aParentContent ||
+  NS_ASSERTION(mFrame->GetContent() || !aParentContent ||
                !aParentContent->GetParent(),
                "frame must have content (unless at the top of the tree)");
   // XXXldb get new context from prev-in-flow if possible, to avoid
   // duplication.  (Or should we just let |GetContext| handle that?)
   // Getting the hint would be nice too, but that's harder.
 
   // XXXbryner we may be able to avoid some of the refcounting goop here.
   // We do need a reference to oldContext for the lifetime of this function, and it's possible
   // that the frame has the last reference to it, so AddRef it here.
 
   nsChangeHint assumeDifferenceHint = NS_STYLE_HINT_NONE;
   // XXXbz oldContext should just be an nsRefPtr
-  nsStyleContext* oldContext = aFrame->StyleContext();
+  nsStyleContext* oldContext = mFrame->StyleContext();
   nsStyleSet* styleSet = aPresContext->StyleSet();
 
   // XXXbz the nsIFrame constructor takes an nsStyleContext, so how
   // could oldContext be null?
   if (oldContext) {
     oldContext->AddRef();
 
 #ifdef ACCESSIBILITY
     bool wasFrameVisible = nsIPresShell::IsAccessibilityActive() ?
       oldContext->StyleVisibility()->IsVisible() : false;
 #endif
 
     nsIAtom* const pseudoTag = oldContext->GetPseudo();
     const nsCSSPseudoElements::Type pseudoType = oldContext->GetPseudoType();
-    nsIContent* localContent = aFrame->GetContent();
+    nsIContent* localContent = mFrame->GetContent();
     // |content| is the node that we used for rule matching of
     // normal elements (not pseudo-elements) and for which we generate
     // framechange hints if we need them.
     // XXXldb Why does it make sense to use aParentContent?  (See
     // comment above assertion at start of function.)
     nsIContent* content = localContent ? localContent : aParentContent;
 
     if (content && content->IsElement()) {
       content->OwnerDoc()->FlushPendingLinkUpdates();
       RestyleTracker::RestyleData restyleData;
       if (aRestyleTracker.GetRestyleData(content->AsElement(), &restyleData)) {
         if (NS_UpdateHint(mHintsHandled, restyleData.mChangeHint)) {
-          aChangeList->AppendChange(aFrame, content, restyleData.mChangeHint);
+          aChangeList->AppendChange(mFrame, content, restyleData.mChangeHint);
         }
         aRestyleHint = nsRestyleHint(aRestyleHint | restyleData.mRestyleHint);
       }
     }
 
     nsRestyleHint childRestyleHint = aRestyleHint;
 
     if (childRestyleHint == eRestyle_Self) {
       childRestyleHint = nsRestyleHint(0);
     }
 
     nsStyleContext* parentContext;
     nsIFrame* resolvedChild = nullptr;
     // Get the frame providing the parent style context.  If it is a
     // child, then resolve the provider first.
-    nsIFrame* providerFrame = aFrame->GetParentStyleContextFrame();
-    bool isChild = providerFrame && providerFrame->GetParent() == aFrame;
+    nsIFrame* providerFrame = mFrame->GetParentStyleContextFrame();
+    bool isChild = providerFrame && providerFrame->GetParent() == mFrame;
     if (!isChild) {
       if (providerFrame)
         parentContext = providerFrame->StyleContext();
       else
         parentContext = nullptr;
     }
     else {
-      MOZ_ASSERT(providerFrame->GetContent() == aFrame->GetContent(),
+      MOZ_ASSERT(providerFrame->GetContent() == mFrame->GetContent(),
                  "Postcondition for GetParentStyleContextFrame() violated. "
                  "That means we need to add the current element to the "
                  "ancestor filter.");
 
-      // resolve the provider here (before aFrame below).
+      // resolve the provider here (before mFrame below).
 
       // assumeDifferenceHint forces the parent's change to be also
       // applied to this frame, no matter what
       // nsStyleContext::CalcStyleDifference says. CalcStyleDifference
       // can't be trusted because it assumes any changes to the parent
       // style context provider will be automatically propagated to
       // the frame(s) with child style contexts.
 
       ElementRestyler providerRestyler(PARENT_CONTEXT_FROM_CHILD_FRAME,
-                                       *this);
-      providerRestyler.Restyle(aPresContext, providerFrame,
+                                       *this, providerFrame);
+      providerRestyler.Restyle(aPresContext,
                                                    aParentContent, aChangeList,
                                                    nsChangeHint_Hints_NotHandledForDescendants,
                                                    aRestyleHint,
                                                    aRestyleTracker,
                                                    aDesiredA11yNotifications,
                                                    aVisibleKidsOfHiddenElement,
                                                    aTreeMatchContext);
       assumeDifferenceHint = providerRestyler.HintsHandledForFrame();
 
       // The provider's new context becomes the parent context of
-      // aFrame's context.
+      // mFrame's context.
       parentContext = providerFrame->StyleContext();
       // Set |resolvedChild| so we don't bother resolving the
       // provider again.
       resolvedChild = providerFrame;
     }
 
-    if (providerFrame != aFrame->GetParent()) {
+    if (providerFrame != mFrame->GetParent()) {
       // We don't actually know what the parent style context's
       // non-inherited hints were, so assume the worst.
       aParentFrameHintsNotHandledForDescendants =
         nsChangeHint_Hints_NotHandledForDescendants;
     }
 
 #ifdef DEBUG
     {
       // Check that our assumption that continuations of the same
       // pseudo-type and with the same style context parent have the
       // same style context is valid before the reresolution.  (We need
       // to check the pseudo-type and style context parent because of
       // :first-letter and :first-line, where we create styled and
       // unstyled letter/line frames distinguished by pseudo-type, and
       // then need to distinguish their descendants based on having
       // different parents.)
-      nsIFrame *nextContinuation = aFrame->GetNextContinuation();
+      nsIFrame *nextContinuation = mFrame->GetNextContinuation();
       if (nextContinuation) {
         nsStyleContext *nextContinuationContext =
           nextContinuation->StyleContext();
         NS_ASSERTION(oldContext == nextContinuationContext ||
                      oldContext->GetPseudo() !=
                        nextContinuationContext->GetPseudo() ||
                      oldContext->GetParent() !=
                        nextContinuationContext->GetParent(),
                      "continuations should have the same style context");
       }
       // And assert the same thing for {ib} splits.  See the comments in
       // GetPrevContinuationWithPossiblySameStyle for an explanation of
       // why we step two forward in the special sibling chain.
-      if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
-          !aFrame->GetPrevContinuation()) {
+      if ((mFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
+          !mFrame->GetPrevContinuation()) {
         nsIFrame *nextIBSibling = static_cast<nsIFrame*>(
-          aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+          mFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
         if (nextIBSibling) {
           nextIBSibling = static_cast<nsIFrame*>(
             nextIBSibling->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
         }
         if (nextIBSibling) {
           nsStyleContext *nextIBSiblingContext =
             nextIBSibling->StyleContext();
           NS_ASSERTION(oldContext == nextIBSiblingContext ||
@@ -2146,27 +2151,27 @@ ElementRestyler::Restyle(nsPresContext  
       }
     }
 #endif
 
     // do primary context
     nsRefPtr<nsStyleContext> newContext;
     nsChangeHint nonInheritedHints = nsChangeHint(0);
     nsIFrame *prevContinuation =
-      GetPrevContinuationWithPossiblySameStyle(aFrame);
+      GetPrevContinuationWithPossiblySameStyle(mFrame);
     nsStyleContext *prevContinuationContext;
     bool copyFromContinuation =
       prevContinuation &&
       (prevContinuationContext = prevContinuation->StyleContext())
         ->GetPseudo() == oldContext->GetPseudo() &&
        prevContinuationContext->GetParent() == parentContext;
     if (copyFromContinuation) {
       // Just use the style context from the frame's previous
-      // continuation (see assertion about aFrame->GetNextContinuation()
-      // above, which we would have previously hit for aFrame's previous
+      // continuation (see assertion about mFrame->GetNextContinuation()
+      // above, which we would have previously hit for mFrame's previous
       // continuation).
       newContext = prevContinuationContext;
     }
     else if (pseudoTag == nsCSSAnonBoxes::mozNonElement) {
       NS_ASSERTION(localContent,
                    "non pseudo-element frame without content node");
       newContext = styleSet->ResolveStyleForNonElement(parentContext);
     }
@@ -2177,38 +2182,38 @@ ElementRestyler::Restyle(nsPresContext  
       // should really be 0 here or whether it should be eRestyle_Self.  Be
       // pessimistic and force an actual reresolve in that situation.  The good
       // news is that in the common case when prevContinuation is non-null we
       // just used prevContinuationContext anyway and aren't reaching this code
       // to start with.
       newContext =
         styleSet->ReparentStyleContext(oldContext, parentContext,
                                        ElementForStyleContext(aParentContent,
-                                                              aFrame,
+                                                              mFrame,
                                                               pseudoType));
     } else if (pseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
       newContext = styleSet->ResolveAnonymousBoxStyle(pseudoTag,
                                                       parentContext);
     }
     else {
       Element* element = ElementForStyleContext(aParentContent,
-                                                aFrame,
+                                                mFrame,
                                                 pseudoType);
       if (pseudoTag) {
         if (pseudoTag == nsCSSPseudoElements::before ||
             pseudoTag == nsCSSPseudoElements::after) {
           // XXX what other pseudos do we need to treat like this?
           newContext = styleSet->ProbePseudoElementStyle(element,
                                                          pseudoType,
                                                          parentContext,
                                                          aTreeMatchContext);
           if (!newContext) {
             // This pseudo should no longer exist; gotta reframe
             NS_UpdateHint(mHintsHandled, nsChangeHint_ReconstructFrame);
-            aChangeList->AppendChange(aFrame, element,
+            aChangeList->AppendChange(mFrame, element,
                                       nsChangeHint_ReconstructFrame);
             // We're reframing anyway; just keep the same context
             newContext = oldContext;
           }
         } else {
           // Don't expect XUL tree stuff here, since it needs a comparator and
           // all.
           NS_ASSERTION(pseudoType <
@@ -2244,42 +2249,42 @@ ElementRestyler::Restyle(nsPresContext  
           // style contexts around.  However, we need to start from the
           // same root.
           newContext = oldContext;
         }
       }
 
       if (newContext != oldContext) {
         if (!copyFromContinuation) {
-          TryStartingTransition(aPresContext, aFrame->GetContent(),
+          TryStartingTransition(aPresContext, mFrame->GetContent(),
                                 oldContext, &newContext);
         }
 
-        CaptureChange(oldContext, newContext, aFrame, content, aChangeList,
+        CaptureChange(oldContext, newContext, content, aChangeList,
                       aParentFrameHintsNotHandledForDescendants,
                       nonInheritedHints, assumeDifferenceHint);
         if (!(mHintsHandled & nsChangeHint_ReconstructFrame)) {
           // if frame gets regenerated, let it keep old context
-          aFrame->SetStyleContext(newContext);
+          mFrame->SetStyleContext(newContext);
         }
       }
       oldContext->Release();
     }
     else {
       NS_ERROR("resolve style context failed");
       newContext = oldContext;  // new context failed, recover...
     }
 
     // do additional contexts
     // XXXbz might be able to avoid selector matching here in some
     // cases; won't worry about it for now.
     int32_t contextIndex = -1;
     while (1 == 1) {
       nsStyleContext* oldExtraContext = nullptr;
-      oldExtraContext = aFrame->GetAdditionalStyleContext(++contextIndex);
+      oldExtraContext = mFrame->GetAdditionalStyleContext(++contextIndex);
       if (oldExtraContext) {
         nsRefPtr<nsStyleContext> newExtraContext;
         nsIAtom* const extraPseudoTag = oldExtraContext->GetPseudo();
         const nsCSSPseudoElements::Type extraPseudoType =
           oldExtraContext->GetPseudoType();
         NS_ASSERTION(extraPseudoTag &&
                      extraPseudoTag != nsCSSAnonBoxes::mozNonElement,
                      "extra style context is not pseudo element");
@@ -2295,24 +2300,24 @@ ElementRestyler::Restyle(nsPresContext  
                        "Unexpected type");
           newExtraContext = styleSet->ResolvePseudoElementStyle(content->AsElement(),
                                                                 extraPseudoType,
                                                                 newContext);
         }
         if (newExtraContext) {
           if (oldExtraContext != newExtraContext) {
             nsChangeHint extraHintsNotHandledForDescendants = nsChangeHint(0);
-            CaptureChange(oldExtraContext, newExtraContext, aFrame, content,
+            CaptureChange(oldExtraContext, newExtraContext, content,
                           aChangeList,
                           aParentFrameHintsNotHandledForDescendants,
                           extraHintsNotHandledForDescendants,
                           assumeDifferenceHint);
             NS_UpdateHint(nonInheritedHints, extraHintsNotHandledForDescendants);
             if (!(mHintsHandled & nsChangeHint_ReconstructFrame)) {
-              aFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
+              mFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
             }
           }
         }
       }
       else {
         break;
       }
     }
@@ -2321,17 +2326,17 @@ ElementRestyler::Restyle(nsPresContext  
 
     // When the root element is display:none, we still construct *some*
     // frames that have the root element as their mContent, down to the
     // DocElementContainingBlock.
     bool checkUndisplayed;
     nsIContent* undisplayedParent;
     nsCSSFrameConstructor* frameConstructor = mPresContext->FrameConstructor();
     if (pseudoTag) {
-      checkUndisplayed = aFrame == frameConstructor->
+      checkUndisplayed = mFrame == frameConstructor->
                                      GetDocElementContainingBlock();
       undisplayedParent = nullptr;
     } else {
       checkUndisplayed = !!localContent;
       undisplayedParent = localContent;
     }
     if (checkUndisplayed) {
       UndisplayedNode* undisplayed =
@@ -2397,65 +2402,65 @@ ElementRestyler::Restyle(nsPresContext  
     // Check whether we might need to create a new ::before frame.
     // There's no need to do this if we're planning to reframe already
     // or if we're not forcing restyles on kids.
     if (!(mHintsHandled & nsChangeHint_ReconstructFrame) &&
         childRestyleHint) {
       // Make sure not to do this for pseudo-frames or frames that
       // can't have generated content.
       if (!pseudoTag &&
-          ((aFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
+          ((mFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
            // Our content insertion frame might have gotten flagged
-           (aFrame->GetContentInsertionFrame()->GetStateBits() &
+           (mFrame->GetContentInsertionFrame()->GetStateBits() &
             NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
         // Check for a new :before pseudo and an existing :before
         // frame, but only if the frame is the first continuation.
-        nsIFrame* prevContinuation = aFrame->GetPrevContinuation();
+        nsIFrame* prevContinuation = mFrame->GetPrevContinuation();
         if (!prevContinuation) {
           // Checking for a :before frame is cheaper than getting the
           // :before style context.
-          if (!nsLayoutUtils::GetBeforeFrame(aFrame) &&
+          if (!nsLayoutUtils::GetBeforeFrame(mFrame) &&
               nsLayoutUtils::HasPseudoStyle(localContent, newContext,
                                             nsCSSPseudoElements::ePseudo_before,
                                             aPresContext)) {
             // Have to create the new :before frame
             NS_UpdateHint(mHintsHandled, nsChangeHint_ReconstructFrame);
-            aChangeList->AppendChange(aFrame, content,
+            aChangeList->AppendChange(mFrame, content,
                                       nsChangeHint_ReconstructFrame);
           }
         }
       }
     }
 
     // Check whether we might need to create a new ::after frame.
     // There's no need to do this if we're planning to reframe already
     // or if we're not forcing restyles on kids.
     if (!(mHintsHandled & nsChangeHint_ReconstructFrame) &&
         childRestyleHint) {
       // Make sure not to do this for pseudo-frames or frames that
       // can't have generated content.
       if (!pseudoTag &&
-          ((aFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
+          ((mFrame->GetStateBits() & NS_FRAME_MAY_HAVE_GENERATED_CONTENT) ||
            // Our content insertion frame might have gotten flagged
-           (aFrame->GetContentInsertionFrame()->GetStateBits() &
+           (mFrame->GetContentInsertionFrame()->GetStateBits() &
             NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
         // Check for new :after content, but only if the frame is the
         // last continuation.
-        nsIFrame* nextContinuation = aFrame->GetNextContinuation();
+        nsIFrame* nextContinuation = mFrame->GetNextContinuation();
 
         if (!nextContinuation) {
           // Getting the :after frame is more expensive than getting the pseudo
           // context, so get the pseudo context first.
           if (nsLayoutUtils::HasPseudoStyle(localContent, newContext,
                                             nsCSSPseudoElements::ePseudo_after,
                                             aPresContext) &&
-              !nsLayoutUtils::GetAfterFrame(aFrame)) {
+              !nsLayoutUtils::GetAfterFrame(mFrame)) {
             // have to create the new :after frame
             NS_UpdateHint(mHintsHandled, nsChangeHint_ReconstructFrame);
-            aChangeList->AppendChange(aFrame, content,
+            aChangeList->AppendChange(mFrame, content,
                                       nsChangeHint_ReconstructFrame);
           }
         }
       }
     }
 
     // There is no need to waste time crawling into a frame's children
     // on a frame change.  The act of reconstructing frames will force
@@ -2467,18 +2472,18 @@ ElementRestyler::Restyle(nsPresContext  
       DesiredA11yNotifications kidsDesiredA11yNotification =
         aDesiredA11yNotifications;
 #ifdef ACCESSIBILITY
       A11yNotificationType ourA11yNotification = eDontNotify;
       // Notify a11y for primary frame only if it's a root frame of visibility
       // changes or its parent frame was hidden while it stays visible and
       // it is not inside a {ib} split or is the first frame of {ib} split.
       if (nsIPresShell::IsAccessibilityActive() &&
-          !aFrame->GetPrevContinuation() &&
-          !nsLayoutUtils::FrameIsNonFirstInIBSplit(aFrame)) {
+          !mFrame->GetPrevContinuation() &&
+          !nsLayoutUtils::FrameIsNonFirstInIBSplit(mFrame)) {
         if (aDesiredA11yNotifications == eSendAllNotifications) {
           bool isFrameVisible = newContext->StyleVisibility()->IsVisible();
           if (isFrameVisible != wasFrameVisible) {
             if (isFrameVisible) {
               // Notify a11y the element (perhaps with its children) was shown.
               // We don't fall into this case if this element gets or stays shown
               // while its parent becomes hidden.
               kidsDesiredA11yNotification = eSkipNotifications;
@@ -2492,24 +2497,24 @@ ElementRestyler::Restyle(nsPresContext  
               kidsDesiredA11yNotification = eNotifyIfShown;
               ourA11yNotification = eNotifyHidden;
             }
           }
         } else if (aDesiredA11yNotifications == eNotifyIfShown &&
                    newContext->StyleVisibility()->IsVisible()) {
           // Notify a11y that element stayed visible while its parent was
           // hidden.
-          aVisibleKidsOfHiddenElement.AppendElement(aFrame->GetContent());
+          aVisibleKidsOfHiddenElement.AppendElement(mFrame->GetContent());
           kidsDesiredA11yNotification = eSkipNotifications;
         }
       }
 #endif
 
       // now do children
-      nsIFrame::ChildListIterator lists(aFrame);
+      nsIFrame::ChildListIterator lists(mFrame);
       for (TreeMatchContext::AutoAncestorPusher
              pushAncestor(!lists.IsDone(),
                           aTreeMatchContext,
                           content && content->IsElement() ? content->AsElement()
                                                           : nullptr);
            !lists.IsDone(); lists.Next()) {
         nsFrameList::Enumerator childFrames(lists.CurrentList());
         for (; !childFrames.AtEnd(); childFrames.Next()) {
@@ -2545,46 +2550,46 @@ ElementRestyler::Restyle(nsPresContext  
               // the <body> would miss reflowing fixed-pos nodes that also need
               // reflow).  In the cases when the out-of-flow _is_ a geometric
               // descendant of a frame we already have a reflow hint for,
               // reflow coalescing should keep us from doing the work twice.
 
               // |nsFrame::GetParentStyleContextFrame| checks being out
               // of flow so that this works correctly.
               do {
-                ElementRestyler oofRestyler(*this);
+                ElementRestyler oofRestyler(*this, outOfFlowFrame);
                 oofRestyler.mHintsHandled =
                   NS_SubtractHint(oofRestyler.mHintsHandled,
                                   nsChangeHint_AllReflowHints);
-                oofRestyler.Restyle(aPresContext, outOfFlowFrame,
+                oofRestyler.Restyle(aPresContext,
                                       content, aChangeList,
                                       nonInheritedHints,
                                       childRestyleHint,
                                       aRestyleTracker,
                                       kidsDesiredA11yNotification,
                                       aVisibleKidsOfHiddenElement,
                                       aTreeMatchContext);
               } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
 
               // reresolve placeholder's context under the same parent
               // as the out-of-flow frame
-              ElementRestyler phRestyler(*this);
-              phRestyler.Restyle(aPresContext, child, content,
+              ElementRestyler phRestyler(*this, child);
+              phRestyler.Restyle(aPresContext, content,
                                     aChangeList,
                                     nonInheritedHints,
                                     childRestyleHint,
                                     aRestyleTracker,
                                     kidsDesiredA11yNotification,
                                     aVisibleKidsOfHiddenElement,
                                     aTreeMatchContext);
             }
             else {  // regular child frame
               if (child != resolvedChild) {
-                ElementRestyler childRestyler(*this);
-                childRestyler.Restyle(aPresContext, child, content,
+                ElementRestyler childRestyler(*this, child);
+                childRestyler.Restyle(aPresContext, content,
                                       aChangeList,
                                       nonInheritedHints,
                                       childRestyleHint,
                                       aRestyleTracker,
                                       kidsDesiredA11yNotification,
                                       aVisibleKidsOfHiddenElement,
                                       aTreeMatchContext);
               }
@@ -2594,28 +2599,28 @@ ElementRestyler::Restyle(nsPresContext  
       }
       // XXX need to do overflow frames???
 
 #ifdef ACCESSIBILITY
       // Send notifications about visibility changes.
       if (ourA11yNotification == eNotifyShown) {
         nsAccessibilityService* accService = nsIPresShell::AccService();
         if (accService) {
-          nsIPresShell* presShell = aFrame->PresContext()->GetPresShell();
-          nsIContent* content = aFrame->GetContent();
+          nsIPresShell* presShell = mFrame->PresContext()->GetPresShell();
+          nsIContent* content = mFrame->GetContent();
 
           accService->ContentRangeInserted(presShell, content->GetParent(),
                                            content,
                                            content->GetNextSibling());
         }
       } else if (ourA11yNotification == eNotifyHidden) {
         nsAccessibilityService* accService = nsIPresShell::AccService();
         if (accService) {
-          nsIPresShell* presShell = aFrame->PresContext()->GetPresShell();
-          nsIContent* content = aFrame->GetContent();
+          nsIPresShell* presShell = mFrame->PresContext()->GetPresShell();
+          nsIContent* content = mFrame->GetContent();
           accService->ContentRemoved(presShell, content->GetParent(), content);
 
           // Process children staying shown.
           uint32_t visibleContentCount = aVisibleKidsOfHiddenElement.Length();
           for (uint32_t idx = 0; idx < visibleContentCount; idx++) {
             nsIContent* content = aVisibleKidsOfHiddenElement[idx];
             accService->ContentRangeInserted(presShell, content->GetParent(),
                                              content, content->GetNextSibling());
@@ -2660,20 +2665,20 @@ RestyleManager::ComputeStyleChangeFor(ns
   Element *parentElement =
     parent && parent->IsElement() ? parent->AsElement() : nullptr;
   treeMatchContext.InitAncestors(parentElement);
   nsTArray<nsIContent*> visibleKidsOfHiddenElement;
   do {
     // Outer loop over special siblings
     do {
       // Inner loop over next-in-flows of the current frame
-      ElementRestyler restyler(mPresContext,
+      ElementRestyler restyler(mPresContext, frame,
                                aMinChange);
 
-      restyler.Restyle(mPresContext, frame, nullptr,
+      restyler.Restyle(mPresContext, nullptr,
                               aChangeList, nsChangeHint(0),
                               aRestyleDescendants ?
                                 eRestyle_Subtree : eRestyle_Self,
                               aRestyleTracker,
                               ElementRestyler::eSendAllNotifications,
                               visibleKidsOfHiddenElement,
                               treeMatchContext);
 
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -267,30 +267,33 @@ private:
  * recompute styles for.
  */
 class ElementRestyler MOZ_FINAL {
 public:
   typedef mozilla::dom::Element Element;
 
   // Construct for the root of the subtree that we're restyling.
   ElementRestyler(nsPresContext* aPresContext,
+                  nsIFrame* aFrame,
                   nsChangeHint aHintsHandledByAncestors);
 
   // Construct for an element whose parent is being restyled.
-  ElementRestyler(const ElementRestyler& aParentRestyler);
+  ElementRestyler(const ElementRestyler& aParentRestyler,
+                  nsIFrame* aFrame);
 
   // Construct for a frame whose parent is being restyled, but whose
   // style context is the parent style context for its parent frame.
   // (This is only used for table frames, whose style contexts are used
   // as the parent style context for their outer table frame (table
   // wrapper frame).  We should probably try to get rid of this
   // exception and have the inheritance go the other way.)
   enum ParentContextFromChildFrame { PARENT_CONTEXT_FROM_CHILD_FRAME };
   ElementRestyler(ParentContextFromChildFrame,
-                  const ElementRestyler& aParentFrameRestyler);
+                  const ElementRestyler& aParentFrameRestyler,
+                  nsIFrame* aFrame);
 
 public: // FIXME: private
   enum DesiredA11yNotifications {
     eSkipNotifications,
     eSendAllNotifications,
     eNotifyIfShown
   };
 
@@ -306,17 +309,16 @@ public:
    *
    * Use eRestyle_Self for the aRestyleHint argument to mean
    * "reresolve our style context but not kids", use eRestyle_Subtree
    * to mean "reresolve our style context and kids", and use
    * nsRestyleHint(0) to mean recompute a new style context for our
    * current parent and existing rulenode, and the same for kids.
    */
   void Restyle(nsPresContext     *aPresContext,
-               nsIFrame          *aFrame,
                nsIContent        *aParentContent,
                nsStyleChangeList *aChangeList,
                nsChangeHint       aParentFrameHintsNotHandledForDescendants,
                nsRestyleHint      aRestyleHint,
                RestyleTracker&    aRestyleTracker,
                DesiredA11yNotifications aDesiredA11yNotifications,
                nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
                TreeMatchContext &aTreeMatchContext);
@@ -328,24 +330,25 @@ public:
    * method is intended to be called after Restyle, to find out what
    * hints have been handled for this frame.
    */
   nsChangeHint HintsHandledForFrame() { return mHintsHandled; }
 
 private:
   void CaptureChange(nsStyleContext* aOldContext,
                      nsStyleContext* aNewContext,
-                     nsIFrame* aFrame, nsIContent* aContent,
+                     nsIContent* aContent,
                      nsStyleChangeList* aChangeList,
                      /*in*/nsChangeHint aParentHintsNotHandledForDescendants,
                      /*out*/nsChangeHint &aHintsNotHandledForDescendants,
                      nsChangeHint aChangeToAssume);
 
 private:
   nsPresContext* const mPresContext;
+  nsIFrame* const mFrame;
   // We have already generated change list entries for hints listed in
   // mHintsHandled (initially it's those handled by ancestors, but by
   // the end of Restyle it is those handled for this frame as well).  We
   // need to generate a new change list entry for the frame when its
   // style comparision returns a hint other than one of these hints.
   nsChangeHint mHintsHandled;
 };
 
