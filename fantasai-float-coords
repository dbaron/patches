From: fantasai <fantasai.cvs@inkedblade.net>

Change coordinate system in the float manager from content box (most of the time, but sometimes border box) to always border box.  (Bug 551425)  r=dbaron  a2.0=blocking+

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -3481,18 +3481,17 @@ nsBlockFrame::DoReflowInlineFrames(nsBlo
   // are impacted by floats.
   if (aFloatAvailableSpace.mHasFloats)
     aLine->SetLineIsImpactedByFloat(PR_TRUE);
 #ifdef REALLY_NOISY_REFLOW
   printf("nsBlockFrame::DoReflowInlineFrames %p impacted = %d\n",
          this, aFloatAvailableSpace.mHasFloats);
 #endif
 
-  const nsMargin& borderPadding = aState.BorderPadding();
-  nscoord x = aFloatAvailableSpace.mRect.x + borderPadding.left;
+  nscoord x = aFloatAvailableSpace.mRect.x;
   nscoord availWidth = aFloatAvailableSpace.mRect.width;
   nscoord availHeight;
   if (aState.GetFlag(BRS_UNCONSTRAINEDHEIGHT)) {
     availHeight = NS_UNCONSTRAINEDSIZE;
   }
   else {
     /* XXX get the height right! */
     availHeight = aFloatAvailableSpace.mRect.height;
@@ -5552,35 +5551,33 @@ nsBlockFrame::AdjustFloatAvailableSpace(
   else {
     // This quirk matches the one in nsBlockReflowState::FlowAndPlaceFloat
     // give tables only the available space
     // if they can shrink we may not be constrained to place
     // them in the next line
     availWidth = aFloatAvailableSpace.width;
   }
 
-  // aState.mY is relative to the border-top, make it relative to the content-top
-  nscoord contentYOffset = aState.mY - aState.BorderPadding().top;
   nscoord availHeight = NS_UNCONSTRAINEDSIZE == aState.mContentArea.height
                         ? NS_UNCONSTRAINEDSIZE
-                        : NS_MAX(0, aState.mContentArea.height - contentYOffset);
+                        : NS_MAX(0, aState.mContentArea.YMost() - aState.mY);
 
 #ifdef DISABLE_FLOAT_BREAKING_IN_COLUMNS
   if (availHeight != NS_UNCONSTRAINEDSIZE &&
       nsLayoutUtils::GetClosestFrameOfType(this, nsGkAtoms::columnSetFrame)) {
     // Tell the float it has unrestricted height, so it won't break.
     // If the float doesn't actually fit in the column it will fail to be
     // placed, and either move to the top of the next column or just
     // overflow.
     availHeight = NS_UNCONSTRAINEDSIZE;
   }
 #endif
 
-  return nsRect(aState.BorderPadding().left,
-                aState.BorderPadding().top,
+  return nsRect(aState.mContentArea.x,
+                aState.mContentArea.y,
                 availWidth, availHeight);
 }
 
 nscoord
 nsBlockFrame::ComputeFloatWidth(nsBlockReflowState& aState,
                                 const nsRect&       aFloatAvailableSpace,
                                 nsIFrame*           aFloat)
 {
@@ -6605,17 +6602,17 @@ nsBlockFrame::ReflowBullet(nsBlockReflow
                            nsHTMLReflowMetrics& aMetrics,
                            nscoord aLineTop)
 {
   const nsHTMLReflowState &rs = aState.mReflowState;
 
   // Reflow the bullet now
   nsSize availSize;
   // Make up a width since it doesn't really matter (XXX).
-  availSize.width = rs.ComputedWidth();
+  availSize.width = aState.mContentArea.width;
   availSize.height = NS_UNCONSTRAINEDSIZE;
 
   // Get the reason right.
   // XXXwaterson Should this look just like the logic in
   // nsBlockReflowContext::ReflowBlock and nsLineLayout::ReflowFrame?
   nsHTMLReflowState reflowState(aState.mPresContext, rs,
                                 mBullet, availSize);
   nsReflowStatus  status;
@@ -6639,36 +6636,32 @@ nsBlockFrame::ReflowBullet(nsBlockReflow
   // the bullet frame as separation).  However, if a line box would be
   // displaced by floats that are *outside* the associated block, we
   // want to displace it by the same amount.  That is, we act as though
   // the edge of the floats is the content-edge of the block, and place
   // the bullet at a position offset from there by the block's padding,
   // the block's border, and the bullet frame's margin.
   nscoord x;
   if (rs.mStyleVisibility->mDirection == NS_STYLE_DIRECTION_LTR) {
-    // Note: floatAvailSpace.x is relative to the content box and never
-    // less than zero.  Converting to frame coordinates and subtracting
-    // the padding and border cancel each other out, and the NS_MAX()
-    // with 0 (or with the left border+padding) is even implied in the
-    // right place.
-    x = floatAvailSpace.x - reflowState.mComputedMargin.right - aMetrics.width;
+    // The floatAvailSpace.x gives us the content/float edge. Then we
+    // subtract out the left border/padding and the bullet's width and
+    // margin to offset the position.
+    x = floatAvailSpace.x - rs.mComputedBorderPadding.left
+        - reflowState.mComputedMargin.right - aMetrics.width;
   } else {
-    // The XMost() of the available space and the computed width both
-    // give us offsets from the left content edge.  Then we add the left
-    // border/padding to get into frame coordinates, and the right
-    // border/padding and the bullet's margin to offset the position.
-    x = NS_MIN(rs.ComputedWidth(), floatAvailSpace.XMost())
-        + rs.mComputedBorderPadding.LeftRight()
+    // The XMost() of the available space give us offsets from the left
+    // border edge.  Then we add the right border/padding and the
+    // bullet's margin to offset the position.
+    x = floatAvailSpace.XMost() + rs.mComputedBorderPadding.right
         + reflowState.mComputedMargin.left;
   }
 
   // Approximate the bullets position; vertical alignment will provide
   // the final vertical location.
-  const nsMargin& bp = aState.BorderPadding();
-  nscoord y = bp.top;
+  nscoord y = aState.mContentArea.y;
   mBullet->SetRect(nsRect(x, y, aMetrics.width, aMetrics.height));
   mBullet->DidReflow(aState.mPresContext, &aState.mReflowState, NS_FRAME_REFLOW_FINISHED);
 }
 
 // This is used to scan frames for any float placeholders, add their
 // floats to the list represented by aList, and remove the
 // floats from whatever list they might be in. We don't search descendants
 // that are float containing blocks. The floats must be children of 'this'.
diff --git a/layout/generic/nsBlockReflowContext.cpp b/layout/generic/nsBlockReflowContext.cpp
--- a/layout/generic/nsBlockReflowContext.cpp
+++ b/layout/generic/nsBlockReflowContext.cpp
@@ -273,34 +273,21 @@ nsBlockReflowContext::ReflowBlock(const 
   // them. Floats are guaranteed to have their own float manager, so tx and ty
   // don't matter.  mX and mY don't matter becacuse they are only used in
   // PlaceBlock, which is not used for floats.
   if (aLine) {
     // Compute x/y coordinate where reflow will begin. Use the rules
     // from 10.3.3 to determine what to apply. At this point in the
     // reflow auto left/right margins will have a zero value.
 
-    nscoord x = mSpace.x + aFrameRS.mComputedMargin.left;
-    nscoord y = mSpace.y + mTopMargin.get() + aClearance;
+    mX = tx = mSpace.x + aFrameRS.mComputedMargin.left;
+    mY = ty = mSpace.y + mTopMargin.get() + aClearance;
 
     if ((mFrame->GetStateBits() & NS_BLOCK_FLOAT_MGR) == 0)
-      aFrameRS.mBlockDelta = mOuterReflowState.mBlockDelta + y - aLine->mBounds.y;
-
-    mX = x;
-    mY = y;
-
-    // Compute the translation to be used for adjusting the spacemanagager
-    // coordinate system for the frame.  The spacemanager coordinates are
-    // <b>inside</b> the callers border+padding, but the x/y coordinates
-    // are not (recall that frame coordinates are relative to the parents
-    // origin and that the parents border/padding is <b>inside</b> the
-    // parent frame. Therefore we have to subtract out the parents
-    // border+padding before translating.
-    tx = x - mOuterReflowState.mComputedBorderPadding.left;
-    ty = y - mOuterReflowState.mComputedBorderPadding.top;
+      aFrameRS.mBlockDelta = mOuterReflowState.mBlockDelta + ty - aLine->mBounds.y;
   }
 
   // Let frame know that we are reflowing it
   mFrame->WillReflow(mPresContext);
 
 #ifdef DEBUG
   mMetrics.width = nscoord(0xdeadbeef);
   mMetrics.height = nscoord(0xdeadbeef);
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -97,19 +97,17 @@ nsBlockReflowState::nsBlockReflowState(c
     SetFlag(BRS_FLOAT_MGR, PR_TRUE);
   }
   
   mFloatManager = aReflowState.mFloatManager;
 
   NS_ASSERTION(mFloatManager,
                "FloatManager should be set in nsBlockReflowState" );
   if (mFloatManager) {
-    // Translate into our content area and then save the 
-    // coordinate system origin for later.
-    mFloatManager->Translate(borderPadding.left, borderPadding.top);
+    // Save the coordinate system origin for later.
     mFloatManager->GetTranslation(mFloatManagerX, mFloatManagerY);
     mFloatManager->PushState(&mFloatManagerStateBefore); // never popped
   }
 
   mReflowStatus = NS_FRAME_COMPLETE;
 
   mPresContext = aPresContext;
   mNextInFlow = static_cast<nsBlockFrame*>(mBlock->GetNextInFlow());
@@ -134,35 +132,25 @@ nsBlockReflowState::nsBlockReflowState(c
     mContentArea.height = NS_MAX(0, mBottomEdge - borderPadding.top);
   }
   else {
     // When we are not in a paginated situation then we always use
     // an constrained height.
     SetFlag(BRS_UNCONSTRAINEDHEIGHT, PR_TRUE);
     mContentArea.height = mBottomEdge = NS_UNCONSTRAINEDSIZE;
   }
-
-  mY = borderPadding.top;
+  mContentArea.x = borderPadding.left;
+  mY = mContentArea.y = borderPadding.top;
 
   mPrevChild = nsnull;
   mCurrentLine = aFrame->end_lines();
 
   mMinLineHeight = aReflowState.CalcLineHeight();
 }
 
-nsBlockReflowState::~nsBlockReflowState()
-{
-  // Restore the coordinate system, unless the float manager is null,
-  // which means it was just destroyed.
-  if (mFloatManager) {
-    const nsMargin& borderPadding = BorderPadding();
-    mFloatManager->Translate(-borderPadding.left, -borderPadding.top);
-  }
-}
-
 nsLineBox*
 nsBlockReflowState::NewLineBox(nsIFrame* aFrame,
                                PRInt32 aCount,
                                PRBool aIsBlock)
 {
   return NS_NewLineBox(mPresContext->PresShell(), aFrame, aCount, aIsBlock);
 }
 
@@ -182,19 +170,19 @@ nsBlockReflowState::ComputeReplacedBlock
                                                          nsBlockFrame::
                                                       ReplacedElementWidthToClear
                                                                  *aReplacedWidth)
 {
   // The frame is clueless about the float manager and therefore we
   // only give it free space. An example is a table frame - the
   // tables do not flow around floats.
   // However, we can let its margins intersect floats.
-  NS_ASSERTION(aFloatAvailableSpace.x >= 0, "bad avail space rect x");
+  NS_ASSERTION(aFloatAvailableSpace.x >= mContentArea.x, "bad avail space rect x");
   NS_ASSERTION(aFloatAvailableSpace.width == 0 ||
-               aFloatAvailableSpace.XMost() <= mContentArea.width,
+               aFloatAvailableSpace.XMost() <= mContentArea.XMost(),
                "bad avail space rect width");
 
   nscoord leftOffset, rightOffset;
   if (aFloatAvailableSpace.width == mContentArea.width) {
     // We don't need to compute margins when there are no floats around.
     leftOffset = 0;
     rightOffset = 0;
   } else {
@@ -205,23 +193,23 @@ nsBlockReflowState::ComputeReplacedBlock
     // to place.
     nsCSSOffsetState os(aFrame, mReflowState.rendContext, mContentArea.width);
     NS_ASSERTION(!aReplacedWidth ||
                  aFrame->GetType() == nsGkAtoms::tableOuterFrame ||
                  (aReplacedWidth->marginLeft  == os.mComputedMargin.left &&
                   aReplacedWidth->marginRight == os.mComputedMargin.right),
                  "unexpected aReplacedWidth");
 
-    nscoord leftFloatXOffset = aFloatAvailableSpace.x;
+    nscoord leftFloatXOffset = aFloatAvailableSpace.x - mContentArea.x;
     leftOffset = NS_MAX(leftFloatXOffset, os.mComputedMargin.left) -
                  (aReplacedWidth ? aReplacedWidth->marginLeft
                                  : os.mComputedMargin.left);
     leftOffset = NS_MAX(leftOffset, 0); // in case of negative margin
     nscoord rightFloatXOffset =
-      mContentArea.width - aFloatAvailableSpace.XMost();
+      mContentArea.XMost() - aFloatAvailableSpace.XMost();
     rightOffset = NS_MAX(rightFloatXOffset, os.mComputedMargin.right) -
                   (aReplacedWidth ? aReplacedWidth->marginRight
                                   : os.mComputedMargin.right);
     rightOffset = NS_MAX(rightOffset, 0); // in case of negative margin
   }
   aLeftResult = leftOffset;
   aRightResult = rightOffset;
 }
@@ -243,18 +231,16 @@ nsBlockReflowState::ComputeBlockAvailSpa
   aResult.y = mY;
   aResult.height = GetFlag(BRS_UNCONSTRAINEDHEIGHT)
     ? NS_UNCONSTRAINEDSIZE
     : mReflowState.availableHeight - mY;
   // mY might be greater than mBottomEdge if the block's top margin pushes
   // it off the page/column. Negative available height can confuse other code
   // and is nonsense in principle.
 
-  const nsMargin& borderPadding = BorderPadding();
-
   // XXX Do we really want this condition to be this restrictive (i.e.,
   // more restrictive than it used to be)?  The |else| here is allowed
   // by the CSS spec, but only out of desperation given implementations,
   // and the behavior it leads to is quite undesirable (it can cause
   // things to become extremely narrow when they'd fit quite well a
   // little bit lower).  Should the else be a quirk or something that
   // applies to a specific set of frame classes and no new ones?
   // If we did that, then for those frames where the condition below is
@@ -270,34 +256,34 @@ nsBlockReflowState::ComputeBlockAvailSpa
       // Use the float-edge property to determine how the child block
       // will interact with the float.
       const nsStyleBorder* borderStyle = aFrame->GetStyleBorder();
       switch (borderStyle->mFloatEdge) {
         default:
         case NS_STYLE_FLOAT_EDGE_CONTENT:  // content and only content does runaround of floats
           // The child block will flow around the float. Therefore
           // give it all of the available space.
-          aResult.x = borderPadding.left;
+          aResult.x = mContentArea.x;
           aResult.width = mContentArea.width;
           break;
         case NS_STYLE_FLOAT_EDGE_MARGIN:
           {
             // The child block's margins should be placed adjacent to,
             // but not overlap the float.
-            aResult.x = aFloatAvailableSpace.mRect.x + borderPadding.left;
+            aResult.x = aFloatAvailableSpace.mRect.x;
             aResult.width = aFloatAvailableSpace.mRect.width;
           }
           break;
       }
     }
     else {
       // Since there are no floats present the float-edge property
       // doesn't matter therefore give the block element all of the
       // available space since it will flow around the float itself.
-      aResult.x = borderPadding.left;
+      aResult.x = mContentArea.x;
       aResult.width = mContentArea.width;
     }
   }
   else {
     nsBlockFrame::ReplacedElementWidthToClear replacedWidthStruct;
     nsBlockFrame::ReplacedElementWidthToClear *replacedWidth = nsnull;
     if (aFrame->GetType() == nsGkAtoms::tableOuterFrame) {
       replacedWidth = &replacedWidthStruct;
@@ -305,17 +291,17 @@ nsBlockReflowState::ComputeBlockAvailSpa
         nsBlockFrame::WidthToClearPastFloats(*this, aFloatAvailableSpace.mRect,
                                              aFrame);
     }
 
     nscoord leftOffset, rightOffset;
     ComputeReplacedBlockOffsetsForFloats(aFrame, aFloatAvailableSpace.mRect,
                                          leftOffset, rightOffset,
                                          replacedWidth);
-    aResult.x = borderPadding.left + leftOffset;
+    aResult.x = mContentArea.x + leftOffset;
     aResult.width = mContentArea.width - leftOffset - rightOffset;
   }
 
 #ifdef REALLY_NOISY_REFLOW
   printf("  CBAS: result %d %d %d %d\n", aResult.x, aResult.y, aResult.width, aResult.height);
 #endif
 }
 
@@ -327,22 +313,21 @@ nsBlockReflowState::GetFloatAvailableSpa
 #ifdef DEBUG
   // Verify that the caller setup the coordinate system properly
   nscoord wx, wy;
   mFloatManager->GetTranslation(wx, wy);
   NS_ASSERTION((wx == mFloatManagerX) && (wy == mFloatManagerY),
                "bad coord system");
 #endif
 
-  nscoord y = aY - BorderPadding().top;
   nscoord height = (mContentArea.height == nscoord_MAX)
-                     ? nscoord_MAX : NS_MAX(mContentArea.height - y, 0);
+                     ? nscoord_MAX : NS_MAX(mContentArea.YMost() - aY, 0);
   nsFlowAreaRect result =
-    mFloatManager->GetFlowArea(y, nsFloatManager::BAND_FROM_POINT,
-                               height, mContentArea.width, aState);
+    mFloatManager->GetFlowArea(aY, nsFloatManager::BAND_FROM_POINT,
+                               height, mContentArea, aState);
   // Keep the width >= 0 for compatibility with nsSpaceManager.
   if (result.mRect.width < 0)
     result.mRect.width = 0;
 
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
     printf("GetAvailableSpace: band=%d,%d,%d,%d hasfloats=%d\n",
@@ -362,19 +347,18 @@ nsBlockReflowState::GetFloatAvailableSpa
   // Verify that the caller setup the coordinate system properly
   nscoord wx, wy;
   mFloatManager->GetTranslation(wx, wy);
   NS_ASSERTION((wx == mFloatManagerX) && (wy == mFloatManagerY),
                "bad coord system");
 #endif
 
   nsFlowAreaRect result =
-    mFloatManager->GetFlowArea(aY - BorderPadding().top, 
-                               nsFloatManager::WIDTH_WITHIN_HEIGHT,
-                               aHeight, mContentArea.width, aState);
+    mFloatManager->GetFlowArea(aY, nsFloatManager::WIDTH_WITHIN_HEIGHT,
+                               aHeight, mContentArea, aState);
   // Keep the width >= 0 for compatibility with nsSpaceManager.
   if (result.mRect.width < 0)
     result.mRect.width = 0;
 
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
     printf("GetAvailableSpaceForHeight: space=%d,%d,%d,%d hasfloats=%d\n",
@@ -505,31 +489,23 @@ void
 nsBlockReflowState::RecoverStateFrom(nsLineList::iterator aLine,
                                      nscoord aDeltaY)
 {
   // Make the line being recovered the current line
   mCurrentLine = aLine;
 
   // Place floats for this line into the float manager
   if (aLine->HasFloats() || aLine->IsBlock()) {
-    // Undo border/padding translation since the nsFloatCache's
-    // coordinates are relative to the frame not relative to the
-    // border/padding.
-    const nsMargin& bp = BorderPadding();
-    mFloatManager->Translate(-bp.left, -bp.top);
-
     RecoverFloats(aLine, aDeltaY);
 
 #ifdef DEBUG
     if (nsBlockFrame::gNoisyReflow || nsBlockFrame::gNoisyFloatManager) {
       mFloatManager->List(stdout);
     }
 #endif
-    // And then put the translation back again
-    mFloatManager->Translate(bp.left, bp.top);
   }
 }
 
 // This is called by the line layout's AddFloat method when a
 // place-holder frame is reflowed in a line. If the float is a
 // left-most child (it's x coordinate is at the line's left margin)
 // then the float is place immediately, otherwise the float
 // placement is deferred until the line has been reflowed.
@@ -595,18 +571,17 @@ nsBlockReflowState::AddFloat(nsLineLayou
       (aLineLayout->LineIsEmpty() ||
        mBlock->ComputeFloatWidth(*this, floatAvailableSpace, aFloat)
        <= aAvailableWidth)) {
     // And then place it
     placed = FlowAndPlaceFloat(aFloat);
     if (placed) {
       // Pass on updated available space to the current inline reflow engine
       nsFlowAreaRect floatAvailSpace = GetFloatAvailableSpace(mY);
-      nsRect availSpace(nsPoint(floatAvailSpace.mRect.x + BorderPadding().left,
-                                mY),
+      nsRect availSpace(nsPoint(floatAvailSpace.mRect.x, mY),
                         floatAvailSpace.mRect.Size());
       aLineLayout->UpdateBand(availSpace, aFloat);
       // Record this float in the current-line list
       mCurrentLineFloats.Append(mFloatCacheFreeList.Alloc(aFloat));
     } else {
       (*aLineLayout->GetLine())->SetHadFloatPushed();
     }
   }
@@ -676,17 +651,17 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
   // Grab the float's display information
   const nsStyleDisplay* floatDisplay = aFloat->GetStyleDisplay();
 
   // The float's old region, so we can propagate damage.
   nsRect oldRegion = nsFloatManager::GetRegionFor(aFloat);
 
   // Enforce CSS2 9.5.1 rule [2], i.e., make sure that a float isn't
   // ``above'' another float that preceded it in the flow.
-  mY = NS_MAX(mFloatManager->GetLowestFloatTop() + BorderPadding().top, mY);
+  mY = NS_MAX(mFloatManager->GetLowestFloatTop(), mY);
 
   // See if the float should clear any preceding floats...
   // XXX We need to mark this float somehow so that it gets reflowed
   // when floats are inserted before it.
   if (NS_STYLE_CLEAR_NONE != floatDisplay->mBreakType) {
     // XXXldb Does this handle vertical margins correctly?
     mY = ClearFloats(mY, floatDisplay->mBreakType);
   }
@@ -786,45 +761,38 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
     }
   }
 
   // If the float is continued, it will get the same absolute x value as its prev-in-flow
 
   // We don't worry about the geometry of the prev in flow, let the continuation
   // place and size itself as required.
 
-  // Assign an x and y coordinate to the float. Note that the x,y
-  // coordinates are computed <b>relative to the translation in the
-  // spacemanager</b> which means that the impacted region will be
-  // <b>inside</b> the border/padding area.
+  // Assign an x and y coordinate to the float.
   nscoord floatX, floatY;
   if (NS_STYLE_FLOAT_LEFT == floatDisplay->mFloats) {
     floatX = floatAvailableSpace.mRect.x;
   }
   else {
     if (!keepFloatOnSameLine) {
       floatX = floatAvailableSpace.mRect.XMost() - floatMarginWidth;
     } 
     else {
       // this is the IE quirk (see few lines above)
       // the table is kept in the same line: don't let it overlap the
       // previous float 
       floatX = floatAvailableSpace.mRect.x;
     }
   }
-  const nsMargin& borderPadding = BorderPadding();
-  floatY = mY - borderPadding.top;
-  if (floatY < 0) {
-    // CSS2 spec, 9.5.1 rule [4]: "A floating box's outer top may not
-    // be higher than the top of its containing block."  (Since the
-    // containing block is the content edge of the block box, this
-    // means the margin edge of the float can't be higher than the
-    // content edge of the block that contains it.)
-    floatY = 0;
-  }
+  // CSS2 spec, 9.5.1 rule [4]: "A floating box's outer top may not
+  // be higher than the top of its containing block."  (Since the
+  // containing block is the content edge of the block box, this
+  // means the margin edge of the float can't be higher than the
+  // content edge of the block that contains it.)
+  floatY = NS_MAX(mY, mContentArea.y);
 
   // Reflow the float after computing its vertical position so it knows
   // where to break.
   nsMargin floatMargin; // computed margin
   PRBool pushedDown = mY != saveY;
   nsReflowStatus reflowStatus;
   mBlock->ReflowFloat(*this, adjustedAvailableSpace, aFloat,
                       floatMargin, pushedDown, reflowStatus);
@@ -840,29 +808,28 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
   // Likewise, if none of the float fit, and it needs to be pushed in
   // its entirety to the next page (NS_FRAME_IS_TRUNCATED), we need to
   // do the same.
   if ((mContentArea.height != NS_UNCONSTRAINEDSIZE &&
        adjustedAvailableSpace.height == NS_UNCONSTRAINEDSIZE &&
        (!mReflowState.mFlags.mIsTopOfPage || !IsAdjacentWithTop() ||
         pushedDown) &&
        aFloat->GetSize().height + floatMargin.TopBottom() >
-         mContentArea.height - floatY) ||
+         mContentArea.YMost() - floatY) ||
       NS_FRAME_IS_TRUNCATED(reflowStatus)) {
 
     PushFloatPastBreak(aFloat);
     return PR_FALSE;
   }
 
   // Calculate the actual origin of the float frame's border rect
-  // relative to the parent block; floatX/Y must be converted from space-manager
-  // coordinates to parent coordinates, and the margin must be added in
+  // relative to the parent block; the margin must be added in
   // to get the border rect
-  nsPoint origin(borderPadding.left + floatMargin.left + floatX,
-                 borderPadding.top + floatMargin.top + floatY);
+  nsPoint origin(floatMargin.left + floatX,
+                 floatMargin.top + floatY);
 
   // If float is relatively positioned, factor that in as well
   origin += aFloat->GetRelativeOffset(floatDisplay);
 
   // Position the float and make sure and views are properly
   // positioned. We need to explicitly position its child views as
   // well, since we're moving the float after flowing it.
   aFloat->SetPosition(origin);
@@ -879,33 +846,31 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
   // calculate region
   nsRect region = nsFloatManager::CalculateRegionFor(aFloat, floatMargin);
   // if the float split, then take up all of the vertical height
   if (NS_FRAME_IS_NOT_COMPLETE(reflowStatus) &&
       (NS_UNCONSTRAINEDSIZE != mContentArea.height)) {
     region.height = NS_MAX(region.height, mContentArea.height - floatY);
   }
   nsresult rv =
-  // spacemanager translation is inset by the border+padding.
-  mFloatManager->AddFloat(aFloat,
-                          region - nsPoint(borderPadding.left, borderPadding.top));
+  mFloatManager->AddFloat(aFloat, region);
   NS_ABORT_IF_FALSE(NS_SUCCEEDED(rv), "bad float placement");
   // store region
   rv = nsFloatManager::StoreRegionFor(aFloat, region);
   NS_ABORT_IF_FALSE(NS_SUCCEEDED(rv), "float region storage failed");
 
   // If the float's dimensions have changed, note the damage in the
   // float manager.
   if (region != oldRegion) {
     // XXXwaterson conservative: we could probably get away with noting
     // less damage; e.g., if only height has changed, then only note the
     // area into which the float has grown or from which the float has
     // shrunk.
-    nscoord top = NS_MIN(region.y, oldRegion.y) - borderPadding.top;
-    nscoord bottom = NS_MAX(region.YMost(), oldRegion.YMost()) - borderPadding.top;
+    nscoord top = NS_MIN(region.y, oldRegion.y);
+    nscoord bottom = NS_MAX(region.YMost(), oldRegion.YMost());
     mFloatManager->IncludeInDamage(top, bottom);
   }
 
   if (NS_FRAME_IS_NOT_COMPLETE(reflowStatus)) {
     mBlock->SplitFloat(*this, aFloat, reflowStatus);
   }
 
 #ifdef NOISY_FLOATMANAGER
@@ -988,49 +953,45 @@ nsBlockReflowState::PlaceBelowCurrentLin
 nscoord
 nsBlockReflowState::ClearFloats(nscoord aY, PRUint8 aBreakType,
                                 nsIFrame *aReplacedBlock,
                                 PRUint32 aFlags)
 {
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
-    printf("clear floats: in: aY=%d(%d)\n",
-           aY, aY - BorderPadding().top);
+    printf("clear floats: in: aY=%d\n", aY);
   }
 #endif
 
 #ifdef NOISY_FLOAT_CLEARING
   printf("nsBlockReflowState::ClearFloats: aY=%d breakType=%d\n",
          aY, aBreakType);
   mFloatManager->List(stdout);
 #endif
   
-  const nsMargin& bp = BorderPadding();
   nscoord newY = aY;
 
   if (aBreakType != NS_STYLE_CLEAR_NONE) {
-    newY = bp.top +
-           mFloatManager->ClearFloats(newY - bp.top, aBreakType, aFlags);
+    newY = mFloatManager->ClearFloats(newY, aBreakType, aFlags);
   }
 
   if (aReplacedBlock) {
     for (;;) {
       nsFlowAreaRect floatAvailableSpace = GetFloatAvailableSpace(newY);
       nsBlockFrame::ReplacedElementWidthToClear replacedWidth =
         nsBlockFrame::WidthToClearPastFloats(*this, floatAvailableSpace.mRect,
                                              aReplacedBlock);
       if (!floatAvailableSpace.mHasFloats ||
-          NS_MAX(floatAvailableSpace.mRect.x, replacedWidth.marginLeft) +
+          NS_MAX(floatAvailableSpace.mRect.x - mContentArea.x,
+                 replacedWidth.marginLeft) +
             replacedWidth.borderBoxWidth +
-            NS_MAX(mContentArea.width -
-                     NS_MIN(mContentArea.width,
-                            floatAvailableSpace.mRect.XMost()),
-                   replacedWidth.marginRight) <=
-          mContentArea.width) {
+            NS_MAX(mContentArea.XMost() - floatAvailableSpace.mRect.XMost(),
+                   replacedWidth.marginRight)
+          <= mContentArea.width) {
         break;
       }
       // See the analogous code for inlines in nsBlockFrame::DoReflowInlineFrames
       if (floatAvailableSpace.mRect.height > 0) {
         // See if there's room in the next band.
         newY += floatAvailableSpace.mRect.height;
       } else {
         if (mReflowState.availableHeight != NS_UNCONSTRAINEDSIZE) {
@@ -1042,15 +1003,15 @@ nsBlockReflowState::ClearFloats(nscoord 
         newY += 1;
       }
     }
   }
 
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
-    printf("clear floats: out: y=%d(%d)\n", newY, newY - bp.top);
+    printf("clear floats: out: y=%d\n", newY);
   }
 #endif
 
   return newY;
 }
 
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -70,18 +70,16 @@ class nsBlockReflowState {
 public:
   nsBlockReflowState(const nsHTMLReflowState& aReflowState,
                      nsPresContext* aPresContext,
                      nsBlockFrame* aFrame,
                      const nsHTMLReflowMetrics& aMetrics,
                      PRBool aTopMarginRoot, PRBool aBottomMarginRoot,
                      PRBool aBlockNeedsFloatManager);
 
-  ~nsBlockReflowState();
-
   /**
    * Get the available reflow space (the area not occupied by floats)
    * for the current y coordinate. The available space is relative to
    * our coordinate system, which is the content box, with (0, 0) in the
    * upper left.
    *
    * Returns whether there are floats present at the given vertical
    * coordinate and within the width of the content rect.
@@ -215,22 +213,25 @@ public:
   // The float manager state as it was before the contents of this
   // block.  This is needed for positioning bullets, since we only want
   // to move the bullet to flow around floats that were before this
   // block, not floats inside of it.
   nsFloatManager::SavedState mFloatManagerStateBefore;
 
   nscoord mBottomEdge;
 
-  // The content area to reflow child frames within. The x/y
-  // coordinates are known to be mBorderPadding.left and
-  // mBorderPadding.top. The width/height may be NS_UNCONSTRAINEDSIZE
-  // if the container reflowing this frame has given the frame an
-  // unconstrained area.
-  nsSize mContentArea;
+  // The content area to reflow child frames within.  This is within
+  // this frame's coordinate system, which means mContentArea.x ==
+  // BorderPadding().left and mContentArea.y == BorderPadding().top.
+  // The height may be NS_UNCONSTRAINEDSIZE, which indicates that there
+  // is no page/column boundary below (the common case).
+  // mContentArea.YMost() should only be called after checking that
+  // mContentArea.height is not NS_UNCONSTRAINEDSIZE; otherwise
+  // coordinate overflow may occur.
+  nsRect mContentArea;
 
   // Continuation out-of-flow float frames that need to move to our
   // next in flow are placed here during reflow.  It's a pointer to
   // a frame list stored in the block's property table.
   nsFrameList *mPushedFloats;
   // This method makes sure pushed floats are accessible to
   // StealFrame. Call it before adding any frames to mPushedFloats.
   void SetupPushedFloatList();
diff --git a/layout/generic/nsFloatManager.cpp b/layout/generic/nsFloatManager.cpp
--- a/layout/generic/nsFloatManager.cpp
+++ b/layout/generic/nsFloatManager.cpp
@@ -139,21 +139,21 @@ void nsFloatManager::Shutdown()
   }
 
   // Disable further caching.
   sCachedFloatManagerCount = -1;
 }
 
 nsFlowAreaRect
 nsFloatManager::GetFlowArea(nscoord aYOffset, BandInfoType aInfoType,
-                            nscoord aHeight, nscoord aContentAreaWidth,
+                            nscoord aHeight, nsRect aContentArea,
                             SavedState* aState) const
 {
   NS_ASSERTION(aHeight >= 0, "unexpected max height");
-  NS_ASSERTION(aContentAreaWidth >= 0, "unexpected content area width");
+  NS_ASSERTION(aContentArea.width >= 0, "unexpected content area width");
 
   nscoord top = aYOffset + mY;
   if (top < nscoord_MIN) {
     NS_WARNING("bad value");
     top = nscoord_MIN;
   }
 
   // Determine the last float that we should consider.
@@ -167,35 +167,36 @@ nsFloatManager::GetFlowArea(nscoord aYOf
     floatCount = mFloats.Length();
   }
 
   // If there are no floats at all, or we're below the last one, return
   // quickly.
   if (floatCount == 0 ||
       (mFloats[floatCount-1].mLeftYMost <= top &&
        mFloats[floatCount-1].mRightYMost <= top)) {
-    return nsFlowAreaRect(0, aYOffset, aContentAreaWidth, aHeight, PR_FALSE);
+    return nsFlowAreaRect(aContentArea.x, aYOffset, aContentArea.width,
+                          aHeight, PR_FALSE);
   }
 
   nscoord bottom;
   if (aHeight == nscoord_MAX) {
     // This warning (and the two below) are possible to hit on pages
     // with really large objects.
     NS_WARN_IF_FALSE(aInfoType == BAND_FROM_POINT,
                      "bad height");
     bottom = nscoord_MAX;
   } else {
     bottom = top + aHeight;
     if (bottom < top || bottom > nscoord_MAX) {
       NS_WARNING("bad value");
       bottom = nscoord_MAX;
     }
   }
-  nscoord left = mX;
-  nscoord right = aContentAreaWidth + mX;
+  nscoord left = mX + aContentArea.x;
+  nscoord right = mX + aContentArea.XMost();
   if (right < left) {
     NS_WARNING("bad value");
     right = left;
   }
 
   // Walk backwards through the floats until we either hit the front of
   // the list or we're above |top|.
   PRBool haveFloats = PR_FALSE;
diff --git a/layout/generic/nsFloatManager.h b/layout/generic/nsFloatManager.h
--- a/layout/generic/nsFloatManager.h
+++ b/layout/generic/nsFloatManager.h
@@ -151,34 +151,33 @@ public:
    *     boxes *throughout* that space.  (It is possible that more
    *     horizontal space could be used in part of the space if a float
    *     begins or ends in it.)  The width of the resulting rectangle
    *     can be negative.
    *
    * @param aY [in] vertical coordinate for top of available space
    *           desired
    * @param aHeight [in] see above
-   * @param aContentAreaWidth [in] the width of the content area (whose left
-   *                          edge must be zero in the current translation)
+   * @param aContentArea [in] an nsRect representing the content area
    * @param aState [in] If null, use the current state, otherwise, do
    *                    computation based only on floats present in the given
    *                    saved state.
    * @return An nsFlowAreaRect whose:
-   *           mRect is the resulting rectangle for line boxes.  It will not go
-   *             left of 0, nor right of aContentAreaWidth, but will be
+   *           mRect is the resulting rectangle for line boxes.  It will not
+   *             extend beyond aContentArea's horizontal bounds, but may be
    *             narrower when floats are present.
    *          mBandHasFloats is whether there are floats at the sides of the
    *            return value including those that do not reduce the line box
    *            width at all (because they are entirely in the margins)
    *
    * aY and aAvailSpace are positioned relative to the current translation
    */
   enum BandInfoType { BAND_FROM_POINT, WIDTH_WITHIN_HEIGHT };
   nsFlowAreaRect GetFlowArea(nscoord aY, BandInfoType aInfoType,
-                             nscoord aHeight, nscoord aContentAreaWidth,
+                             nscoord aHeight, nsRect aContentArea,
                              SavedState* aState) const;
 
   /**
    * Add a float that comes after all floats previously added.  Its top
    * must be even with or below the top of all previous floats.
    *
    * aMarginRect is relative to the current translation.  The caller
    * must ensure aMarginRect.height >= 0 and aMarginRect.width >= 0.
diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -808,35 +808,26 @@ nsLineLayout::ReflowFrame(nsIFrame* aFra
   
   // Apply start margins (as appropriate) to the frame computing the
   // new starting x,y coordinates for the frame.
   ApplyStartMargin(pfd, reflowState);
 
   // Let frame know that are reflowing it. Note that we don't bother
   // positioning the frame yet, because we're probably going to end up
   // moving it when we do the vertical alignment
-  nscoord x = pfd->mBounds.x;
-  nscoord y = pfd->mBounds.y;
-
   aFrame->WillReflow(mPresContext);
 
-  // Adjust spacemanager coordinate system for the frame. The
-  // spacemanager coordinates are <b>inside</b> the current spans
-  // border+padding, but the x/y coordinates are not (recall that
-  // frame coordinates are relative to the parents origin and that the
-  // parents border/padding is <b>inside</b> the parent
-  // frame. Therefore we have to subtract out the parents
-  // border+padding before translating.
+  // Adjust spacemanager coordinate system for the frame.
   nsHTMLReflowMetrics metrics;
 #ifdef DEBUG
   metrics.width = nscoord(0xdeadbeef);
   metrics.height = nscoord(0xdeadbeef);
 #endif
-  nscoord tx = x - psd->mReflowState->mComputedBorderPadding.left;
-  nscoord ty = y - psd->mReflowState->mComputedBorderPadding.top;
+  nscoord tx = pfd->mBounds.x;
+  nscoord ty = pfd->mBounds.y;
   mFloatManager->Translate(tx, ty);
 
   nsIAtom* frameType = aFrame->GetType();
   PRInt32 savedOptionalBreakOffset;
   gfxBreakPriority savedOptionalBreakPriority;
   nsIContent* savedOptionalBreakContent =
     GetLastOptionalBreakPosition(&savedOptionalBreakOffset,
                                  &savedOptionalBreakPriority);
