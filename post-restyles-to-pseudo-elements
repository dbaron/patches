From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Post all animation restyles directly to pseudo-elements.

diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -171,18 +171,18 @@ struct ElementAnimations MOZ_FINAL
              mElementProperty == nsGkAtoms::animationsOfBeforeProperty ?
                NS_LITERAL_STRING("::before") :
                NS_LITERAL_STRING("::after");
   }
 
   mozilla::dom::Element* ElementToRestyle() const;
 
   void PostRestyleForAnimation(nsPresContext *aPresContext) {
-    nsRestyleHint styleHint = IsForElement() ? eRestyle_Self : eRestyle_Subtree;
-    aPresContext->PresShell()->RestyleForAnimation(mElement, styleHint);
+    aPresContext->PresShell()->RestyleForAnimation(ElementToRestyle(),
+                                                   eRestyle_Self);
   }
 
   // If aFlags contains CanAnimate_AllowPartial, returns whether the
   // state of this element's animations at the current refresh driver
   // time contains animation data that can be done on the compositor
   // thread.  (This is useful for determining whether a layer should be
   // active, or whether to send data to the layer.)
   // If aFlags does not contain CanAnimate_AllowPartial, returns whether
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -668,21 +668,17 @@ nsTransitionManager::ConsiderStartingTra
   } else {
     if (!pts.AppendElement(pt)) {
       NS_WARNING("out of memory");
       return;
     }
   }
   aElementTransitions->UpdateAnimationGeneration(mPresContext);
 
-  nsRestyleHint hint =
-    aNewStyleContext->GetPseudoType() ==
-      nsCSSPseudoElements::ePseudo_NotPseudoElement ?
-    eRestyle_Self : eRestyle_Subtree;
-  presContext->PresShell()->RestyleForAnimation(aElement, hint);
+  aElementTransitions->PostRestyleForAnimation(presContext);
 
   *aStartedAny = true;
   aWhichStarted->AddProperty(aProperty);
 }
 
 ElementTransitions*
 nsTransitionManager::GetElementTransitions(dom::Element *aElement,
                                            nsCSSPseudoElements::Type aPseudoType,
@@ -752,20 +748,17 @@ nsTransitionManager::WalkTransitionRule(
       !aData->mPresContext->IsProcessingAnimationStyleChange()) {
     // If we're processing a normal style change rather than one from
     // animation, don't add the transition rule.  This allows us to
     // compute the new style value rather than having the transition
     // override it, so that we can start transitioning differently.
 
     // We need to immediately restyle with animation
     // after doing this.
-    nsRestyleHint hint =
-      aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ?
-      eRestyle_Self : eRestyle_Subtree;
-    mPresContext->PresShell()->RestyleForAnimation(aData->mElement, hint);
+    et->PostRestyleForAnimation(mPresContext);
     return;
   }
 
   et->EnsureStyleRuleFor(
     aData->mPresContext->RefreshDriver()->MostRecentRefresh());
 
   aData->mRuleWalker->Forward(et->mStyleRule);
 }
@@ -936,24 +929,18 @@ nsTransitionManager::FlushTransitions(Fl
           // transition proper.
           et->UpdateAnimationGeneration(mPresContext);
           transitionStartedOrEnded = true;
         }
       } while (i != 0);
 
       // We need to restyle even if the transition rule no longer
       // applies (in which case we just made it not apply).
-      NS_ASSERTION(et->mElementProperty == nsGkAtoms::transitionsProperty ||
-                   et->mElementProperty == nsGkAtoms::transitionsOfBeforeProperty ||
-                   et->mElementProperty == nsGkAtoms::transitionsOfAfterProperty,
-                   "Unexpected element property; might restyle too much");
       if (!canThrottleTick || transitionStartedOrEnded) {
-        nsRestyleHint hint = et->mElementProperty == nsGkAtoms::transitionsProperty ?
-          eRestyle_Self : eRestyle_Subtree;
-        mPresContext->PresShell()->RestyleForAnimation(et->mElement, hint);
+        et->PostRestyleForAnimation(mPresContext);
       } else {
         didThrottle = true;
       }
 
       if (et->mPropertyTransitions.IsEmpty()) {
         et->Destroy();
         // |et| is now a dangling pointer!
         et = nullptr;
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
--- a/layout/style/nsTransitionManager.h
+++ b/layout/style/nsTransitionManager.h
@@ -89,16 +89,21 @@ struct ElementTransitions MOZ_FINAL
                      mozilla::TimeStamp aNow);
 
   void EnsureStyleRuleFor(mozilla::TimeStamp aRefreshTime);
 
   virtual bool HasAnimationOfProperty(nsCSSProperty aProperty) const MOZ_OVERRIDE;
 
   mozilla::dom::Element* ElementToRestyle() const;
 
+  void PostRestyleForAnimation(nsPresContext *aPresContext) {
+    aPresContext->PresShell()->RestyleForAnimation(ElementToRestyle(),
+                                                   eRestyle_Self);
+  }
+
   // If aFlags contains CanAnimate_AllowPartial, returns whether the
   // state of this element's transitions at the current refresh driver
   // time contains transition data that can be done on the compositor
   // thread.  (This is useful for determining whether a layer should be
   // active, or whether to send data to the layer.)
   // If aFlags does not contain CanAnimate_AllowPartial, returns whether
   // the state of this element's transitions at the current refresh driver
   // time can be fully represented by data sent to the compositor.
