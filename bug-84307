Make default table and hr border colors be gray rather than special values that depend on the background color, and remove the special values that depend on the background.  b=84307  Patch by fantasai <fantasai.bugs@inkedblade.net>.  r=bzbarsky  sr=dbaron

diff -r c54186afb7ed content/html/content/src/nsHTMLHRElement.cpp
--- a/content/html/content/src/nsHTMLHRElement.cpp	Wed Jan 31 17:44:08 2007 -0800
+++ b/content/html/content/src/nsHTMLHRElement.cpp	Wed Jan 31 18:03:31 2007 -0800
@@ -255,25 +255,23 @@ MapAttributesIntoRule(const nsMappedAttr
       }
     }
 
-    // if a color is set, set the border-style to 'solid' so that the
-    // 'color' property takes effect, otherwise, use '-moz-bg-solid'.
-    // (we got the color attribute earlier)
-    PRInt32 style = colorIsSet ? NS_STYLE_BORDER_STYLE_SOLID :
-                                 NS_STYLE_BORDER_STYLE_BG_SOLID;
-
     nsCSSRect& borderStyle = aData->mMarginData->mBorderStyle;
     if (borderStyle.mTop.GetUnit() == eCSSUnit_Null) {
-      borderStyle.mTop.SetIntValue(style, eCSSUnit_Enumerated);
+      borderStyle.mTop.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
+                                   eCSSUnit_Enumerated);
     }
     if (allSides) {
       if (borderStyle.mRight.GetUnit() == eCSSUnit_Null) {
-        borderStyle.mRight.SetIntValue(style, eCSSUnit_Enumerated);
+        borderStyle.mRight.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
+                                       eCSSUnit_Enumerated);
       }
       if (borderStyle.mBottom.GetUnit() == eCSSUnit_Null) {
-        borderStyle.mBottom.SetIntValue(style, eCSSUnit_Enumerated);
+        borderStyle.mBottom.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
+                                        eCSSUnit_Enumerated);
       }
       if (borderStyle.mLeft.GetUnit() == eCSSUnit_Null) {
-        borderStyle.mLeft.SetIntValue(style, eCSSUnit_Enumerated);
+        borderStyle.mLeft.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
+                                      eCSSUnit_Enumerated);
       }
 
       // If it would be noticeable, set the border radius to
diff -r c54186afb7ed content/html/content/src/nsHTMLTableElement.cpp
--- a/content/html/content/src/nsHTMLTableElement.cpp	Wed Jan 31 17:44:08 2007 -0800
+++ b/content/html/content/src/nsHTMLTableElement.cpp	Wed Jan 31 18:03:31 2007 -0800
@@ -1294,10 +1294,7 @@ MapAttributesIntoRule(const nsMappedAttr
           if (aData->mMarginData->mBorderWidth.mBottom.GetUnit() == eCSSUnit_Null)
             aData->mMarginData->mBorderWidth.mBottom.SetFloatValue(1.0f, eCSSUnit_Pixel);
 
-          PRUint8 borderStyle = (eCompatibility_NavQuirks == mode) 
-                                ? NS_STYLE_BORDER_STYLE_BG_INSET : NS_STYLE_BORDER_STYLE_INSET;
-          // BG_INSET results in a border color based on background colors
-          // used for NavQuirks only...
+          PRUint8 borderStyle = NS_STYLE_BORDER_STYLE_INSET;
 
           if (aData->mMarginData->mBorderStyle.mLeft.GetUnit() == eCSSUnit_Null)
             aData->mMarginData->mBorderStyle.mLeft.SetIntValue(borderStyle, eCSSUnit_Enumerated);
@@ -1311,16 +1308,7 @@ MapAttributesIntoRule(const nsMappedAttr
       }
     }
     else {
-      // default border style is the Nav4.6 extension which uses the
-      // background color as the basis of the outset border. If the
-      // table has a transparent background then it finds the closest
-      // ancestor that has a non-transparent
-      // background. NS_STYLE_BORDER_OUTSET uses the border color of
-      // the table and if that is not set, then it uses the color.
-
-      PRUint8 borderStyle = (eCompatibility_NavQuirks == mode) 
-                            ? NS_STYLE_BORDER_STYLE_BG_OUTSET :
-                              NS_STYLE_BORDER_STYLE_OUTSET;
+      PRUint8 borderStyle = NS_STYLE_BORDER_STYLE_OUTSET;
       // bordercolor
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::bordercolor);
       nscolor color;
diff -r c54186afb7ed layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp	Wed Jan 31 17:44:08 2007 -0800
+++ b/layout/base/nsCSSRendering.cpp	Wed Jan 31 18:03:31 2007 -0800
@@ -302,8 +302,7 @@ void nsCSSRendering::FillPolygon (nsIRen
  */
 nscolor nsCSSRendering::MakeBevelColor(PRIntn whichSide, PRUint8 style,
                                        nscolor aBackgroundColor,
-                                       nscolor aBorderColor,
-                                       PRBool aSpecialCase)
+                                       nscolor aBorderColor)
 {
 
   nscolor colors[2];
@@ -311,15 +310,11 @@ nscolor nsCSSRendering::MakeBevelColor(P
 
   // Given a background color and a border color
   // calculate the color used for the shading
-  if(aSpecialCase)
-    NS_GetSpecial3DColors(colors, aBackgroundColor, aBorderColor);
-  else
-    NS_Get3DColors(colors, aBackgroundColor);
+  NS_GetSpecial3DColors(colors, aBackgroundColor, aBorderColor);
  
-  if ((style == NS_STYLE_BORDER_STYLE_BG_OUTSET) ||
-      (style == NS_STYLE_BORDER_STYLE_OUTSET) ||
+  if ((style == NS_STYLE_BORDER_STYLE_OUTSET) ||
       (style == NS_STYLE_BORDER_STYLE_RIDGE)) {
-    // Flip colors for these three border styles
+    // Flip colors for these two border styles
     switch (whichSide) {
     case NS_SIDE_BOTTOM: whichSide = NS_SIDE_TOP;    break;
     case NS_SIDE_RIGHT:  whichSide = NS_SIDE_LEFT;   break;
@@ -558,8 +553,7 @@ void nsCSSRendering::DrawSide(nsIRenderi
                                         ((theStyle == NS_STYLE_BORDER_STYLE_RIDGE) ?
                                          NS_STYLE_BORDER_STYLE_GROOVE :
                                          NS_STYLE_BORDER_STYLE_RIDGE), 
-                                         aBackgroundColor, theColor, 
-                                         PR_TRUE));
+                                         aBackgroundColor, theColor));
     if (2 == np) {
       //aContext.DrawLine (theSide[0].x, theSide[0].y, theSide[1].x, theSide[1].y);
       DrawLine (aContext, theSide[0].x, theSide[0].y, theSide[1].x, theSide[1].y, aGap);
@@ -570,7 +564,7 @@ void nsCSSRendering::DrawSide(nsIRenderi
     np = MakeSide (theSide, aContext, whichSide, borderOutside, borderInside,aSkipSides,
                    BORDER_OUTSIDE, 0.5f, twipsPerPixel);
     aContext.SetColor ( MakeBevelColor (whichSide, theStyle, aBackgroundColor, 
-                                        theColor, PR_TRUE));
+                                        theColor));
     if (2 == np) {
       //aContext.DrawLine (theSide[0].x, theSide[0].y, theSide[1].x, theSide[1].y);
       DrawLine (aContext, theSide[0].x, theSide[0].y, theSide[1].x, theSide[1].y, aGap);
@@ -590,19 +584,6 @@ void nsCSSRendering::DrawSide(nsIRenderi
       DrawLine (aContext, theSide[0].x, theSide[0].y, theSide[1].x, theSide[1].y, aGap);
     } else {
       //aContext.FillPolygon (theSide, np);
-      FillPolygon (aContext, theSide, np, aGap);
-    }
-    break;
-
-  case NS_STYLE_BORDER_STYLE_BG_SOLID:
-    np = MakeSide (theSide, aContext, whichSide, borderOutside, borderInside, aSkipSides,
-                   BORDER_FULL, 1.0f, twipsPerPixel);
-    nscolor colors[2]; 
-    NS_Get3DColors(colors, aBackgroundColor); 
-    aContext.SetColor (colors[0]);
-    if (2 == np) {
-      DrawLine (aContext, theSide[0].x, theSide[0].y, theSide[1].x, theSide[1].y, aGap);
-    } else {
       FillPolygon (aContext, theSide, np, aGap);
     }
     break;
@@ -629,26 +610,12 @@ void nsCSSRendering::DrawSide(nsIRenderi
     }
     break;
 
-  case NS_STYLE_BORDER_STYLE_BG_OUTSET:
-  case NS_STYLE_BORDER_STYLE_BG_INSET:
-    np = MakeSide (theSide, aContext, whichSide, borderOutside, borderInside,aSkipSides,
-                   BORDER_FULL, 1.0f, twipsPerPixel);
-    aContext.SetColor ( MakeBevelColor (whichSide, theStyle, aBackgroundColor,
-                                        theColor, PR_FALSE));
-    if (2 == np) {
-      //aContext.DrawLine (theSide[0].x, theSide[0].y, theSide[1].x, theSide[1].y);
-      DrawLine (aContext, theSide[0].x, theSide[0].y, theSide[1].x, theSide[1].y, aGap);
-    } else {
-      //aContext.FillPolygon (theSide, np);
-      FillPolygon (aContext, theSide, np, aGap);
-    }
-    break;
   case NS_STYLE_BORDER_STYLE_OUTSET:
   case NS_STYLE_BORDER_STYLE_INSET:
     np = MakeSide (theSide, aContext, whichSide, borderOutside, borderInside,aSkipSides,
                    BORDER_FULL, 1.0f, twipsPerPixel);
     aContext.SetColor ( MakeBevelColor (whichSide, theStyle, aBackgroundColor, 
-                                        theColor, PR_TRUE));
+                                        theColor));
     if (2 == np) {
       //aContext.DrawLine (theSide[0].x, theSide[0].y, theSide[1].x, theSide[1].y);
       DrawLine (aContext, theSide[0].x, theSide[0].y, theSide[1].x, theSide[1].y, aGap);
@@ -1561,64 +1528,6 @@ nscolor   newcolor;
   return newcolor;
 }
 
-// method GetBGColorForHTMLElement
-//
-// Now here's a *fun* hack: Nav4 uses the BODY element's background color for the 
-//                          background color on tables so we need to find that element's
-//                          color and use it... Actually, we can use the HTML element as well.
-//
-// Traverse from PresContext to PresShell to Document to RootContent. The RootContent is
-// then checked to ensure that it is the HTML or BODY element, and if it is, we get
-// it's primary frame and from that the style context and from that the color to use.
-//
-PRBool GetBGColorForHTMLElement( nsPresContext *aPresContext,
-                                   const nsStyleBackground *&aBGColor )
-{
-  NS_ASSERTION(aPresContext, "null params not allowed");
-  PRBool result = PR_FALSE; // assume we did not find the HTML element
-
-  nsIPresShell* shell = aPresContext->GetPresShell();
-  if (shell) {
-    nsIDocument *doc = shell->GetDocument();
-    if (doc) {
-      nsIContent *pContent;
-      if ((pContent = doc->GetRootContent())) {
-        // make sure that this is the HTML element
-        nsIAtom *tag = pContent->Tag();
-        NS_ASSERTION(tag, "Tag could not be retrieved from root content element");
-        if (tag == nsGkAtoms::html ||
-            tag == nsGkAtoms::body) {
-          // use this guy's color
-          nsIFrame *pFrame = shell->GetPrimaryFrameFor(pContent);
-          if (pFrame) {
-            nsStyleContext *pContext = pFrame->GetStyleContext();
-            if (pContext) {
-              const nsStyleBackground* color = pContext->GetStyleBackground();
-              if (0 == (color->mBackgroundFlags & NS_STYLE_BG_COLOR_TRANSPARENT)) {
-                aBGColor = color;
-                // set the reslt to TRUE to indicate we mapped the color
-                result = PR_TRUE;
-              }
-            }// if context
-          }// if frame
-        }// if tag == html or body
-#ifdef DEBUG
-        else {
-          printf( "Root Content is not HTML or BODY: cannot get bgColor of HTML or BODY\n");
-        }
-#endif
-      }// if content
-    }// if doc
-  } // if shell
-
-  return result;
-}
-
-// helper macro to determine if the borderstyle 'a' is a MOZ-BG-XXX style
-#define MOZ_BG_BORDER(a)\
-((a==NS_STYLE_BORDER_STYLE_BG_INSET) || (a==NS_STYLE_BORDER_STYLE_BG_OUTSET)\
-                                     || (a==NS_STYLE_BORDER_STYLE_BG_SOLID))
-
 static
 PRBool GetBorderColor(const nsStyleColor* aColor, const nsStyleBorder& aBorder, PRUint8 aSide, nscolor& aColorVal,
                       nsBorderColors** aCompositeColors = nsnull)
@@ -1678,29 +1587,6 @@ void nsCSSRendering::PaintBorder(nsPresC
     nsCSSRendering::FindNonTransparentBackground(aStyleContext, 
                                             compatMode == eCompatibility_NavQuirks ? PR_TRUE : PR_FALSE); 
 
-  // mozBGColor is used instead of bgColor when the display type is BG_INSET or BG_OUTSET
-  // or BG_SOLID, and, in quirk mode, it is set to the BODY element's background color
-  // instead of the nearest ancestor's background color.
-  const nsStyleBackground* mozBGColor = bgColor;
-
-  // now check if we are in Quirks mode and have a border style of BG_INSET or OUTSET
-  // or BG_SOLID - if so we use the bgColor from the HTML element instead of the
-  // nearest ancestor
-  if (compatMode == eCompatibility_NavQuirks) {
-    PRBool bNeedBodyBGColor = PR_FALSE;
-    if (aStyleContext) {
-      for (cnt=0; cnt<4;cnt++) {
-        bNeedBodyBGColor = MOZ_BG_BORDER(aBorderStyle.GetBorderStyle(cnt));
-        if (bNeedBodyBGColor) {
-          break;
-        }
-      }
-    }
-    if (bNeedBodyBGColor) {
-      GetBGColorForHTMLElement(aPresContext, mozBGColor);
-    } 
-  }
-
   if (aHardBorderSize > 0) {
     border.SizeTo(aHardBorderSize, aHardBorderSize, aHardBorderSize, aHardBorderSize);
   } else {
@@ -1858,9 +1744,7 @@ void nsCSSRendering::PaintBorder(nsPresC
           DrawSide(aRenderingContext, side,
                    forceSolid ? NS_STYLE_BORDER_STYLE_SOLID : aBorderStyle.GetBorderStyle(side),
                    sideColor,
-                   MOZ_BG_BORDER(aBorderStyle.GetBorderStyle(side)) ? 
-                    mozBGColor->mBackgroundColor :
-                    bgColor->mBackgroundColor,
+                   bgColor->mBackgroundColor,
                    outerRect,innerRect, aSkipSides,
                    twipsPerPixel, aGap);
       }
@@ -3706,19 +3590,10 @@ nsCSSRendering::RenderSide(nsFloatPoint 
     switch (border_Style){
       case NS_STYLE_BORDER_STYLE_OUTSET:
       case NS_STYLE_BORDER_STYLE_INSET:
-      case NS_STYLE_BORDER_STYLE_BG_OUTSET:
-      case NS_STYLE_BORDER_STYLE_BG_INSET:
-      case NS_STYLE_BORDER_STYLE_BG_SOLID:
         {
           const nsStyleBackground* bgColor = nsCSSRendering::FindNonTransparentBackground(aStyleContext);
-          if (border_Style == NS_STYLE_BORDER_STYLE_BG_SOLID) {
-            nscolor colors[2]; 
-            NS_Get3DColors(colors, bgColor->mBackgroundColor); 
-            aRenderingContext.SetColor(colors[0]);
-          } else {
-            aRenderingContext.SetColor(MakeBevelColor(aSide, border_Style, bgColor->mBackgroundColor, sideColor, 
-                                       !MOZ_BG_BORDER(border_Style)));
-          }
+          aRenderingContext.SetColor(MakeBevelColor(aSide, border_Style,
+                                       bgColor->mBackgroundColor, sideColor));
         }
       case NS_STYLE_BORDER_STYLE_DOTTED:
       case NS_STYLE_BORDER_STYLE_DASHED:
@@ -3766,7 +3641,8 @@ nsCSSRendering::RenderSide(nsFloatPoint 
       case NS_STYLE_BORDER_STYLE_GROOVE:
         {
         const nsStyleBackground* bgColor = nsCSSRendering::FindNonTransparentBackground(aStyleContext);
-        aRenderingContext.SetColor ( MakeBevelColor (aSide, border_Style, bgColor->mBackgroundColor,sideColor, PR_TRUE));
+        aRenderingContext.SetColor(MakeBevelColor(aSide, border_Style,
+                                     bgColor->mBackgroundColor,sideColor));
 
         polypath[0].x = NSToCoordRound(aPoints[0].x);
         polypath[0].y = NSToCoordRound(aPoints[0].y);
@@ -3789,7 +3665,7 @@ nsCSSRendering::RenderSide(nsFloatPoint 
                                                 ((border_Style == NS_STYLE_BORDER_STYLE_RIDGE) ?
                                                 NS_STYLE_BORDER_STYLE_GROOVE :
                                                 NS_STYLE_BORDER_STYLE_RIDGE), 
-                                                bgColor->mBackgroundColor,sideColor, PR_TRUE));
+                                                bgColor->mBackgroundColor,sideColor));
        
         polypath[0].x = NSToCoordRound((aPoints[0].x + aPoints[11].x)/2.0f);
         polypath[0].y = NSToCoordRound((aPoints[0].y + aPoints[11].y)/2.0f);
@@ -4386,7 +4262,7 @@ nsCSSRendering::DrawTableBorderSegment(n
                             ? RoundFloatToPixel(0.5f * (float)aEndBevelOffset, twipsPerPixel, PR_TRUE) : 0;
       PRUint8 ridgeGrooveSide = (horizontal) ? NS_SIDE_TOP : NS_SIDE_LEFT;
       aContext.SetColor ( 
-        MakeBevelColor (ridgeGrooveSide, ridgeGroove, aBGColor->mBackgroundColor, aBorderColor, PR_TRUE));
+        MakeBevelColor(ridgeGrooveSide, ridgeGroove, aBGColor->mBackgroundColor, aBorderColor));
       nsRect rect(aBorder);
       nscoord half;
       if (horizontal) { // top, bottom
@@ -4419,7 +4295,7 @@ nsCSSRendering::DrawTableBorderSegment(n
       rect = aBorder;
       ridgeGrooveSide = (NS_SIDE_TOP == ridgeGrooveSide) ? NS_SIDE_BOTTOM : NS_SIDE_RIGHT;
       aContext.SetColor ( 
-        MakeBevelColor (ridgeGrooveSide, ridgeGroove, aBGColor->mBackgroundColor, aBorderColor, PR_TRUE));
+        MakeBevelColor(ridgeGrooveSide, ridgeGroove, aBGColor->mBackgroundColor, aBorderColor));
       if (horizontal) {
         rect.y = rect.y + half;
         rect.height = aBorder.height - half;
@@ -4511,13 +4387,10 @@ nsCSSRendering::DrawTableBorderSegment(n
       break;
     }
     // else fall through to solid
-  case NS_STYLE_BORDER_STYLE_BG_SOLID:
   case NS_STYLE_BORDER_STYLE_SOLID:
     DrawSolidBorderSegment(aContext, aBorder, twipsPerPixel, aStartBevelSide, 
                            aStartBevelOffset, aEndBevelSide, aEndBevelOffset);
     break;
-  case NS_STYLE_BORDER_STYLE_BG_OUTSET:
-  case NS_STYLE_BORDER_STYLE_BG_INSET:
   case NS_STYLE_BORDER_STYLE_OUTSET:
   case NS_STYLE_BORDER_STYLE_INSET:
     NS_ASSERTION(PR_FALSE, "inset, outset should have been converted to groove, ridge");
diff -r c54186afb7ed layout/base/nsCSSRendering.h
--- a/layout/base/nsCSSRendering.h	Wed Jan 31 17:44:08 2007 -0800
+++ b/layout/base/nsCSSRendering.h	Wed Jan 31 18:03:31 2007 -0800
@@ -265,8 +265,7 @@ protected:
 
   static nscolor MakeBevelColor(PRIntn whichSide, PRUint8 style,
                                 nscolor aBackgroundColor,
-                                nscolor aBorderColor,
-                                PRBool aSpecialCase);
+                                nscolor aBorderColor);
 
   static PRIntn MakeSide(nsPoint aPoints[],
                          nsIRenderingContext& aContext,
diff -r c54186afb7ed layout/base/nsStyleConsts.h
--- a/layout/base/nsStyleConsts.h	Wed Jan 31 17:44:08 2007 -0800
+++ b/layout/base/nsStyleConsts.h	Wed Jan 31 18:03:31 2007 -0800
@@ -251,10 +251,7 @@
 #define NS_STYLE_BORDER_STYLE_INSET             7
 #define NS_STYLE_BORDER_STYLE_OUTSET            8
 #define NS_STYLE_BORDER_STYLE_HIDDEN            9
-#define NS_STYLE_BORDER_STYLE_BG_INSET          10
-#define NS_STYLE_BORDER_STYLE_BG_OUTSET         11
-#define NS_STYLE_BORDER_STYLE_BG_SOLID          12
-#define NS_STYLE_BORDER_STYLE_AUTO              13 // for outline-style only
+#define NS_STYLE_BORDER_STYLE_AUTO              10 // for outline-style only
 // a bit ORed onto the style for table border collapsing indicating that the style was 
 // derived from a table with its rules attribute set
 #define NS_STYLE_BORDER_STYLE_RULES_MARKER      0x10  
diff -r c54186afb7ed layout/style/html.css
--- a/layout/style/html.css	Wed Jan 31 17:44:08 2007 -0800
+++ b/layout/style/html.css	Wed Jan 31 18:03:31 2007 -0800
@@ -171,6 +171,10 @@ table {
   /* XXXldb do we want this if we're border-collapse:collapse ? */
   -moz-box-sizing: border-box;
   text-indent: 0;
+}
+
+table, td, th {
+  border-color: gray;
 }
 
 table[align="left"] {
@@ -386,14 +390,15 @@ hr {
 hr {
   display: block;
   height: 2px;
-  border: 1px -moz-bg-inset;
+  border: 1px inset;
   margin: 0.5em auto 0.5em auto;
+  color: gray;
   -moz-float-edge: margin-box;
   -moz-box-sizing: border-box;
 }
 
 hr[size="1"] {
-  border-style: -moz-bg-solid none none none;
+  border-style: solid none none none;
 }
 
 *|*:-moz-any-link img, img[usemap], object[usemap] {
diff -r c54186afb7ed layout/style/nsCSSKeywordList.h
--- a/layout/style/nsCSSKeywordList.h	Wed Jan 31 17:44:08 2007 -0800
+++ b/layout/style/nsCSSKeywordList.h	Wed Jan 31 18:03:31 2007 -0800
@@ -74,9 +74,6 @@ CSS_KEY(-moz-anchor-decoration, _moz_anc
 CSS_KEY(-moz-anchor-decoration, _moz_anchor_decoration)
 CSS_KEY(-moz-arabic-indic, _moz_arabic_indic)
 CSS_KEY(-moz-bengali, _moz_bengali)
-CSS_KEY(-moz-bg-inset, _moz_bg_inset)
-CSS_KEY(-moz-bg-outset, _moz_bg_outset)
-CSS_KEY(-moz-bg-solid, _moz_bg_solid)
 CSS_KEY(-moz-box, _moz_box)
 CSS_KEY(-moz-button, _moz_button)
 CSS_KEY(-moz-buttondefault, _moz_buttondefault)
diff -r c54186afb7ed layout/style/nsCSSProps.cpp
--- a/layout/style/nsCSSProps.cpp	Wed Jan 31 17:44:08 2007 -0800
+++ b/layout/style/nsCSSProps.cpp	Wed Jan 31 18:03:31 2007 -0800
@@ -350,9 +350,6 @@ const PRInt32 nsCSSProps::kBorderStyleKT
   eCSSKeyword_ridge,  NS_STYLE_BORDER_STYLE_RIDGE,
   eCSSKeyword_inset,  NS_STYLE_BORDER_STYLE_INSET,
   eCSSKeyword_outset, NS_STYLE_BORDER_STYLE_OUTSET,
-  eCSSKeyword__moz_bg_inset,  NS_STYLE_BORDER_STYLE_BG_INSET,
-  eCSSKeyword__moz_bg_outset, NS_STYLE_BORDER_STYLE_BG_OUTSET,
-  eCSSKeyword__moz_bg_solid,  NS_STYLE_BORDER_STYLE_BG_SOLID,
   eCSSKeyword_UNKNOWN,-1
 };
 
@@ -727,9 +724,6 @@ const PRInt32 nsCSSProps::kOutlineStyleK
   eCSSKeyword_ridge,  NS_STYLE_BORDER_STYLE_RIDGE,
   eCSSKeyword_inset,  NS_STYLE_BORDER_STYLE_INSET,
   eCSSKeyword_outset, NS_STYLE_BORDER_STYLE_OUTSET,
-  eCSSKeyword__moz_bg_inset,  NS_STYLE_BORDER_STYLE_BG_INSET,
-  eCSSKeyword__moz_bg_outset, NS_STYLE_BORDER_STYLE_BG_OUTSET,
-  eCSSKeyword__moz_bg_solid,  NS_STYLE_BORDER_STYLE_BG_SOLID,
   eCSSKeyword_UNKNOWN,-1
 };
 
diff -r c54186afb7ed layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp	Wed Jan 31 17:44:08 2007 -0800
+++ b/layout/tables/nsTableFrame.cpp	Wed Jan 31 18:03:31 2007 -0800
@@ -4245,18 +4245,15 @@ BCMapCellIterator::PeekBottom(BCMapCellI
 // Assign priorities to border styles. For example, styleToPriority(NS_STYLE_BORDER_STYLE_SOLID)
 // will return the priority of NS_STYLE_BORDER_STYLE_SOLID. 
 static PRUint8 styleToPriority[13] = { 0,  // NS_STYLE_BORDER_STYLE_NONE
-                                       3,  // NS_STYLE_BORDER_STYLE_GROOVE
-                                       6,  // NS_STYLE_BORDER_STYLE_RIDGE
-                                       7,  // NS_STYLE_BORDER_STYLE_DOTTED
-                                       8,  // NS_STYLE_BORDER_STYLE_DASHED
-                                       10, // NS_STYLE_BORDER_STYLE_SOLID
-                                       11, // NS_STYLE_BORDER_STYLE_DOUBLE
-                                       2,  // NS_STYLE_BORDER_STYLE_INSET
-                                       5,  // NS_STYLE_BORDER_STYLE_OUTSET
-                                       12, // NS_STYLE_BORDER_STYLE_HIDDEN
-                                       1,  // NS_STYLE_BORDER_STYLE_BG_INSET
-                                       4,  // NS_STYLE_BORDER_STYLE_BG_OUTSET
-                                       9 };// NS_STYLE_BORDER_STYLE_BG_SOLID
+                                       2,  // NS_STYLE_BORDER_STYLE_GROOVE
+                                       4,  // NS_STYLE_BORDER_STYLE_RIDGE
+                                       5,  // NS_STYLE_BORDER_STYLE_DOTTED
+                                       6,  // NS_STYLE_BORDER_STYLE_DASHED
+                                       7,  // NS_STYLE_BORDER_STYLE_SOLID
+                                       8,  // NS_STYLE_BORDER_STYLE_DOUBLE
+                                       1,  // NS_STYLE_BORDER_STYLE_INSET
+                                       3,  // NS_STYLE_BORDER_STYLE_OUTSET
+                                       9 };// NS_STYLE_BORDER_STYLE_HIDDEN
 // priority rules follow CSS 2.1 spec
 // 'hidden', 'double', 'solid', 'dashed', 'dotted', 'ridge', 'outset', 'groove',
 // and the lowest: 'inset'. none is even weaker
@@ -4336,12 +4333,10 @@ GetPaintStyleInfo(const nsIFrame*  aFram
                   PRBool           aIgnoreTableEdge)
 {
   GetColorAndStyle(aFrame, aSide, aStyle, aColor, aTableIsLTR, aIgnoreTableEdge);
-  if ((NS_STYLE_BORDER_STYLE_INSET    == aStyle) || 
-      (NS_STYLE_BORDER_STYLE_BG_INSET == aStyle)) {
+  if (NS_STYLE_BORDER_STYLE_INSET    == aStyle) {
     aStyle = NS_STYLE_BORDER_STYLE_RIDGE;
   }
-  else if ((NS_STYLE_BORDER_STYLE_OUTSET    == aStyle) || 
-           (NS_STYLE_BORDER_STYLE_BG_OUTSET == aStyle)) {
+  else if (NS_STYLE_BORDER_STYLE_OUTSET    == aStyle) {
     aStyle = NS_STYLE_BORDER_STYLE_GROOVE;
   }
 }
