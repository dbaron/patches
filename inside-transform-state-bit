From: L. David Baron <dbaron@dbaron.org>

Add the NS_FRAME_INSIDE_TRANSFORM for frames that are inside of a CSS transform.  (Bug 627842, patch 3.75)

diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -449,24 +449,25 @@ nsFrame::Init(nsIContent*      aContent,
                        NS_FRAME_IS_SPECIAL |
                        NS_FRAME_MAY_BE_TRANSFORMED);
   }
   if (mParent) {
     nsFrameState state = mParent->GetStateBits();
 
     // Make bits that are currently off (see constructor) the same:
     mState |= state & (NS_FRAME_INDEPENDENT_SELECTION |
-                       NS_FRAME_GENERATED_CONTENT);
+                       NS_FRAME_GENERATED_CONTENT |
+                       NS_FRAME_INSIDE_TRANSFORM);
   }
   if (GetStyleDisplay()->HasTransform()) {
     // The frame gets reconstructed if we toggle the -moz-transform
     // property, so we can set this bit here and then ignore it.
-    mState |= NS_FRAME_MAY_BE_TRANSFORMED;
-  }
-  
+    mState |= NS_FRAME_MAY_BE_TRANSFORMED | NS_FRAME_INSIDE_TRANSFORM;
+  }
+
   DidSetStyleContext(nsnull);
 
   if (IsBoxWrapped())
     InitBoxMetrics(false); // XXX propagate allocation failure?
 
   return NS_OK;
 }
 
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -292,16 +292,25 @@ typedef PRUint64 nsFrameState;
 
 // Frame is or is a descendant of something with a fixed height, and
 // has no closer ancestor that is overflow:auto or overflow:scroll.
 #define NS_FRAME_IN_CONSTRAINED_HEIGHT              NS_FRAME_STATE_BIT(39)
 
 // This is only set during painting
 #define NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO    NS_FRAME_STATE_BIT(40)
 
+// Is this frame transformed in such a way that font sizes aren't
+// meaningful in an absolute sense?  This currently means that it or one
+// of its ancestors has a CSS transform.
+// In the future it should also be set when the frame or one of its
+// ancestors is (b) an SVG frame with a viewBox or (c) an SVG frame with
+// a transform?  (Keeping those dynamically updated correctly is
+// harder.)
+#define NS_FRAME_INSIDE_TRANSFORM                   NS_FRAME_STATE_BIT(41)
+
 // Bits 0-19 and bits 32-59 of the frame state are reserved by this API.
 #define NS_FRAME_RESERVED                           ~NS_FRAME_IMPL_RESERVED
 
 // Box layout bits
 #define NS_STATE_IS_HORIZONTAL                      NS_FRAME_STATE_BIT(22)
 #define NS_STATE_IS_DIRECTION_NORMAL                NS_FRAME_STATE_BIT(31)
 
 // Helper macros
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -2210,16 +2210,19 @@ nsChangeHint nsStyleDisplay::CalcDiffere
   if (mOpacity != aOther.mOpacity) {
     NS_UpdateHint(hint, nsChangeHint_UpdateOpacityLayer);
   }
 
   /* If we've added or removed the transform property, we need to reconstruct the frame to add
    * or remove the view object, and also to handle abs-pos and fixed-pos containers.
    */
   if (HasTransform() != aOther.HasTransform()) {
+    // When we remove this code (for bug 691651), we need to make sure
+    // to replace it with something that updates the
+    // NS_FRAME_INSIDE_TRANSFORM state bit.
     NS_UpdateHint(hint, nsChangeHint_ReconstructFrame);
   }
   else if (HasTransform()) {
     /* Otherwise, if we've kept the property lying around and we already had a
      * transform, we need to see whether or not we've changed the transform.
      * If so, we need to do a reflow and a repaint. The reflow is to recompute
      * the overflow rect (which probably changed if the transform changed)
      * and to redraw within the bounds of that new overflow rect.
