Count U+000C and U+000B as whitespace characters for separating class attributes.  b=437915

diff --git a/content/base/public/nsContentUtils.h b/content/base/public/nsContentUtils.h
--- a/content/base/public/nsContentUtils.h
+++ b/content/base/public/nsContentUtils.h
@@ -363,16 +363,28 @@ public:
   static const nsDependentSubstring TrimWhitespace(const nsAString& aStr,
                                                    PRBool aTrimTrailing = PR_TRUE);
 
   /**
    * Returns true if aChar is of class Ps, Pi, Po, Pf, or Pe. (Does not
    * currently handle non-BMP characters.)
    */
   static PRBool IsPunctuationMark(PRUnichar aChar);
+
+  /*
+   * Is the character an HTML whitespace character?
+   *
+   * We define whitespace using the list in HTML 5:
+   * U+0009, U+000A, U+000B, U+000C, U+000D, U+0020
+   *
+   * css3-selectors gives this list, minus U+000B (vertical tab).
+   *
+   * HTML 4.01 gives the css3-selectors list plus U+200B (zero-width space).
+   */
+  static PRBool IsHTMLWhitespace(PRUnichar aChar);
 
   static void Shutdown();
 
   /**
    * Checks whether two nodes come from the same origin. aTrustedNode is
    * considered 'safe' in that a user can operate on it and that it isn't
    * a js-object that implements nsIDOMNode.
    * Never call this function with the first node provided by script, it
diff --git a/content/base/src/nsAttrValue.cpp b/content/base/src/nsAttrValue.cpp
--- a/content/base/src/nsAttrValue.cpp
+++ b/content/base/src/nsAttrValue.cpp
@@ -44,16 +44,17 @@
 #include "nsAttrValue.h"
 #include "nsIAtom.h"
 #include "nsUnicharUtils.h"
 #include "nsICSSStyleRule.h"
 #include "nsCSSDeclaration.h"
 #include "nsIHTMLDocument.h"
 #include "nsIDocument.h"
 #include "nsTPtrArray.h"
+#include "nsContentUtils.h"
 
 #ifdef MOZ_SVG
 #include "nsISVGValue.h"
 #endif
 
 nsTPtrArray<const nsAttrValue::EnumTable>* nsAttrValue::sEnumTableArray = nsnull;
 
 nsAttrValue::nsAttrValue()
@@ -728,40 +729,40 @@ void
 void
 nsAttrValue::ParseAtomArray(const nsAString& aValue)
 {
   nsAString::const_iterator iter, end;
   aValue.BeginReading(iter);
   aValue.EndReading(end);
 
   // skip initial whitespace
-  while (iter != end && nsCRT::IsAsciiSpace(*iter)) {
+  while (iter != end && nsContentUtils::IsHTMLWhitespace(*iter)) {
     ++iter;
   }
 
   if (iter == end) {
     ResetIfSet();
     return;
   }
 
   nsAString::const_iterator start(iter);
 
   // get first - and often only - atom
   do {
     ++iter;
-  } while (iter != end && !nsCRT::IsAsciiSpace(*iter));
+  } while (iter != end && !nsContentUtils::IsHTMLWhitespace(*iter));
 
   nsCOMPtr<nsIAtom> classAtom = do_GetAtom(Substring(start, iter));
   if (!classAtom) {
     Reset();
     return;
   }
 
   // skip whitespace
-  while (iter != end && nsCRT::IsAsciiSpace(*iter)) {
+  while (iter != end && nsContentUtils::IsHTMLWhitespace(*iter)) {
     ++iter;
   }
 
   if (iter == end) {
     // we only found one classname so don't bother storing a list
     ResetIfSet();
     nsIAtom* atom = nsnull;
     classAtom.swap(atom);
@@ -781,27 +782,27 @@ nsAttrValue::ParseAtomArray(const nsAStr
   }
 
   // parse the rest of the classnames
   do {
     start = iter;
 
     do {
       ++iter;
-    } while (iter != end && !nsCRT::IsAsciiSpace(*iter));
+    } while (iter != end && !nsContentUtils::IsHTMLWhitespace(*iter));
 
     classAtom = do_GetAtom(Substring(start, iter));
 
     if (!array->AppendObject(classAtom)) {
       Reset();
       return;
     }
 
     // skip whitespace
-    while (iter != end && nsCRT::IsAsciiSpace(*iter)) {
+    while (iter != end && nsContentUtils::IsHTMLWhitespace(*iter)) {
       ++iter;
     }
   } while (iter != end);
 
   return;
 }
 
 void
diff --git a/content/base/src/nsContentUtils.cpp b/content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp
+++ b/content/base/src/nsContentUtils.cpp
@@ -680,16 +680,29 @@ DEFINE_CCMAP(gPuncCharsCCMap, const);
 // static
 PRBool
 nsContentUtils::IsPunctuationMark(PRUnichar aChar)
 {
   return CCMAP_HAS_CHAR(gPuncCharsCCMap, aChar);
 }
 
 /* static */
+PRBool
+nsContentUtils::IsHTMLWhitespace(PRUnichar aChar)
+{
+  return aChar == PRUnichar(0x0009) ||
+         aChar == PRUnichar(0x000A) ||
+         aChar == PRUnichar(0x000B) ||
+         aChar == PRUnichar(0x000C) ||
+         aChar == PRUnichar(0x000D) ||
+         aChar == PRUnichar(0x0020);
+}
+
+
+/* static */
 void
 nsContentUtils::GetOfflineAppManifest(nsIDOMWindow *aWindow, nsIURI **aURI)
 {
   nsCOMPtr<nsIDOMWindow> top;
   aWindow->GetTop(getter_AddRefs(top));
   if (!top) {
     return;
   }
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -75,16 +75,17 @@
 #include "nsQuickSort.h"
 #include "nsAttrValue.h"
 #include "nsAttrName.h"
 #include "nsILookAndFeel.h"
 #include "nsWidgetsCID.h"
 #include "nsServiceManagerUtils.h"
 #include "nsTArray.h"
 #include "nsIMediaList.h"
+#include "nsContentUtils.h"
 
 static NS_DEFINE_CID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
 static nsTArray< nsCOMPtr<nsIAtom> >* sSystemMetrics = 0;
 
 struct RuleValue {
   /**
    * |RuleValue|s are constructed before they become part of the
    * |RuleHash|, to act as rule/selector pairs.  |Add| is called when
@@ -1015,23 +1016,23 @@ static PRBool ValueIncludes(const nsSubs
                             const nsSubstring& aValue,
                             const nsStringComparator& aComparator)
 {
   const PRUnichar *p = aValueList.BeginReading(),
               *p_end = aValueList.EndReading();
 
   while (p < p_end) {
     // skip leading space
-    while (p != p_end && nsCRT::IsAsciiSpace(*p))
+    while (p != p_end && nsContentUtils::IsHTMLWhitespace(*p))
       ++p;
 
     const PRUnichar *val_start = p;
 
     // look for space or end
-    while (p != p_end && !nsCRT::IsAsciiSpace(*p))
+    while (p != p_end && !nsContentUtils::IsHTMLWhitespace(*p))
       ++p;
 
     const PRUnichar *val_end = p;
 
     if (val_start < val_end &&
         aValue.Equals(Substring(val_start, val_end), aComparator))
       return PR_TRUE;
 
