Count U+000C as a whitespace character for separating class attributes.  b=437915  r=bzbarsky

diff --git a/content/base/public/nsContentUtils.h b/content/base/public/nsContentUtils.h
--- a/content/base/public/nsContentUtils.h
+++ b/content/base/public/nsContentUtils.h
@@ -363,16 +363,30 @@ public:
   static const nsDependentSubstring TrimWhitespace(const nsAString& aStr,
                                                    PRBool aTrimTrailing = PR_TRUE);
 
   /**
    * Returns true if aChar is of class Ps, Pi, Po, Pf, or Pe. (Does not
    * currently handle non-BMP characters.)
    */
   static PRBool IsPunctuationMark(PRUnichar aChar);
+
+  /*
+   * Is the character an HTML whitespace character?
+   *
+   * We define whitespace using the list in css3-selectors:
+   * U+0009, U+000A, U+000C, U+000D, U+0020
+   *
+   * HTML 4.01 lists the css3-selectors list plus U+200B (zero-width space).
+   *
+   * HTML 5 lists the css3-selectors list plus U+000B (vertical tab).
+   * 
+   * Once HTML 5 is stable we may want to add U+000B.
+   */
+  static PRBool IsHTMLWhitespace(PRUnichar aChar);
 
   static void Shutdown();
 
   /**
    * Checks whether two nodes come from the same origin. aTrustedNode is
    * considered 'safe' in that a user can operate on it and that it isn't
    * a js-object that implements nsIDOMNode.
    * Never call this function with the first node provided by script, it
diff --git a/content/base/src/nsAttrValue.cpp b/content/base/src/nsAttrValue.cpp
--- a/content/base/src/nsAttrValue.cpp
+++ b/content/base/src/nsAttrValue.cpp
@@ -44,16 +44,17 @@
 #include "nsAttrValue.h"
 #include "nsIAtom.h"
 #include "nsUnicharUtils.h"
 #include "nsICSSStyleRule.h"
 #include "nsCSSDeclaration.h"
 #include "nsIHTMLDocument.h"
 #include "nsIDocument.h"
 #include "nsTPtrArray.h"
+#include "nsContentUtils.h"
 
 #ifdef MOZ_SVG
 #include "nsISVGValue.h"
 #endif
 
 nsTPtrArray<const nsAttrValue::EnumTable>* nsAttrValue::sEnumTableArray = nsnull;
 
 nsAttrValue::nsAttrValue()
@@ -728,40 +729,40 @@ void
 void
 nsAttrValue::ParseAtomArray(const nsAString& aValue)
 {
   nsAString::const_iterator iter, end;
   aValue.BeginReading(iter);
   aValue.EndReading(end);
 
   // skip initial whitespace
-  while (iter != end && nsCRT::IsAsciiSpace(*iter)) {
+  while (iter != end && nsContentUtils::IsHTMLWhitespace(*iter)) {
     ++iter;
   }
 
   if (iter == end) {
     ResetIfSet();
     return;
   }
 
   nsAString::const_iterator start(iter);
 
   // get first - and often only - atom
   do {
     ++iter;
-  } while (iter != end && !nsCRT::IsAsciiSpace(*iter));
+  } while (iter != end && !nsContentUtils::IsHTMLWhitespace(*iter));
 
   nsCOMPtr<nsIAtom> classAtom = do_GetAtom(Substring(start, iter));
   if (!classAtom) {
     Reset();
     return;
   }
 
   // skip whitespace
-  while (iter != end && nsCRT::IsAsciiSpace(*iter)) {
+  while (iter != end && nsContentUtils::IsHTMLWhitespace(*iter)) {
     ++iter;
   }
 
   if (iter == end) {
     // we only found one classname so don't bother storing a list
     ResetIfSet();
     nsIAtom* atom = nsnull;
     classAtom.swap(atom);
@@ -781,27 +782,27 @@ nsAttrValue::ParseAtomArray(const nsAStr
   }
 
   // parse the rest of the classnames
   do {
     start = iter;
 
     do {
       ++iter;
-    } while (iter != end && !nsCRT::IsAsciiSpace(*iter));
+    } while (iter != end && !nsContentUtils::IsHTMLWhitespace(*iter));
 
     classAtom = do_GetAtom(Substring(start, iter));
 
     if (!array->AppendObject(classAtom)) {
       Reset();
       return;
     }
 
     // skip whitespace
-    while (iter != end && nsCRT::IsAsciiSpace(*iter)) {
+    while (iter != end && nsContentUtils::IsHTMLWhitespace(*iter)) {
       ++iter;
     }
   } while (iter != end);
 
   return;
 }
 
 void
diff --git a/content/base/src/nsContentUtils.cpp b/content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp
+++ b/content/base/src/nsContentUtils.cpp
@@ -680,16 +680,28 @@ DEFINE_CCMAP(gPuncCharsCCMap, const);
 // static
 PRBool
 nsContentUtils::IsPunctuationMark(PRUnichar aChar)
 {
   return CCMAP_HAS_CHAR(gPuncCharsCCMap, aChar);
 }
 
 /* static */
+PRBool
+nsContentUtils::IsHTMLWhitespace(PRUnichar aChar)
+{
+  return aChar == PRUnichar(0x0009) ||
+         aChar == PRUnichar(0x000A) ||
+         aChar == PRUnichar(0x000C) ||
+         aChar == PRUnichar(0x000D) ||
+         aChar == PRUnichar(0x0020);
+}
+
+
+/* static */
 void
 nsContentUtils::GetOfflineAppManifest(nsIDOMWindow *aWindow, nsIURI **aURI)
 {
   nsCOMPtr<nsIDOMWindow> top;
   aWindow->GetTop(getter_AddRefs(top));
   if (!top) {
     return;
   }
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -75,16 +75,17 @@
 #include "nsQuickSort.h"
 #include "nsAttrValue.h"
 #include "nsAttrName.h"
 #include "nsILookAndFeel.h"
 #include "nsWidgetsCID.h"
 #include "nsServiceManagerUtils.h"
 #include "nsTArray.h"
 #include "nsIMediaList.h"
+#include "nsContentUtils.h"
 
 static NS_DEFINE_CID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
 static nsTArray< nsCOMPtr<nsIAtom> >* sSystemMetrics = 0;
 
 struct RuleValue {
   /**
    * |RuleValue|s are constructed before they become part of the
    * |RuleHash|, to act as rule/selector pairs.  |Add| is called when
@@ -1015,23 +1016,23 @@ static PRBool ValueIncludes(const nsSubs
                             const nsSubstring& aValue,
                             const nsStringComparator& aComparator)
 {
   const PRUnichar *p = aValueList.BeginReading(),
               *p_end = aValueList.EndReading();
 
   while (p < p_end) {
     // skip leading space
-    while (p != p_end && nsCRT::IsAsciiSpace(*p))
+    while (p != p_end && nsContentUtils::IsHTMLWhitespace(*p))
       ++p;
 
     const PRUnichar *val_start = p;
 
     // look for space or end
-    while (p != p_end && !nsCRT::IsAsciiSpace(*p))
+    while (p != p_end && !nsContentUtils::IsHTMLWhitespace(*p))
       ++p;
 
     const PRUnichar *val_end = p;
 
     if (val_start < val_end &&
         aValue.Equals(Substring(val_start, val_end), aComparator))
       return PR_TRUE;
 
diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -89,16 +89,17 @@ _TEST_FILES =	test_acid3_test46.html \
 		test_bug387615.html \
 		test_bug389464.html \
 		test_bug391034.html \
 		test_bug391221.html \
 		test_bug397427.html \
 		test_bug401046.html \
 		test_bug405818.html \
 		test_bug412901.html \
+		test_bug437915.html \
 		test_compute_data_with_start_struct.html \
 		test_dont_use_document_colors.html \
 		test_for_expect_end_property.html \
 		test_inherit_storage.html \
 		test_inherit_computation.html \
 		test_initial_storage.html \
 		test_initial_computation.html \
 		test_media_queries.html \
diff --git a/layout/style/test/test_bug437915.html b/layout/style/test/test_bug437915.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_bug437915.html
@@ -0,0 +1,71 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=437915
+-->
+<head>
+  <title>Test for Bug 437915</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+  <style type="text/css">
+
+  div.classvalue { text-decoration: underline; }
+  div[title~="titlevalue"] { visibility: hidden; }
+
+  </style>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=437915">Mozilla Bug 437915</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 437915 **/
+
+var div = document.getElementById("content");
+var cs = document.defaultView.getComputedStyle(div, "");
+
+var chars = {
+  0x09: true, // tab
+  0x0a: true, // newline
+  0x0b: false, // vertical tab (MAY CHANGE IN FUTURE!)
+  0x0c: true, // form feed
+  0x0d: true, // carriage return
+  0x0e: false,
+  0x20: true, // space
+  0x2003: false,
+  0x200b: false,
+  0x2028: false,
+  0x2029: false,
+  0x3000: false
+};
+
+var wsmap = {
+  false: { str: " NOT", "text-decoration": "none", "visibility": "visible" },
+  true: { str: "", "text-decoration": "underline", "visibility": "hidden" }
+};
+
+for (var char in chars) {
+  var is_whitespace = chars[char];
+  var mapent = wsmap[is_whitespace];
+  div.setAttribute("class", "classvalue" + String.fromCharCode(char) + "b")
+  div.setAttribute("title", "a" + String.fromCharCode(char) + "titlevalue")
+  for each (var prop in ["text-decoration", "visibility"]) {
+    is(cs.getPropertyValue(prop), mapent[prop],
+       "Character " + char + " should" + mapent.str +
+       " be treated as whitespace ("
+       + prop + " should be " + mapent[prop] + ")");
+  }
+}
+
+
+
+</script>
+</pre>
+</body>
+</html>
+
