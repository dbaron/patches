From: L. David Baron <dbaron@dbaron.org>

Bug 896138 patch 7:  Remove unused aFrameManager parameters to some functions.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -65,30 +65,28 @@ RestyleManager::NotifyDestroyingFrame(ns
 #ifdef DEBUG
   // To ensure that the functions below are only called within
   // |ApplyRenderingChangeToTree|.
 static bool gInApplyRenderingChangeToTree = false;
 #endif
 
 static void
 DoApplyRenderingChangeToTree(nsIFrame* aFrame,
-                             nsFrameManager* aFrameManager,
                              nsChangeHint aChange);
 
 /**
  * Sync views on aFrame and all of aFrame's descendants (following placeholders),
  * if aChange has nsChangeHint_SyncFrameView.
  * Calls DoApplyRenderingChangeToTree on all aFrame's out-of-flow descendants
  * (following placeholders), if aChange has nsChangeHint_RepaintFrame.
  * aFrame should be some combination of nsChangeHint_SyncFrameView and
  * nsChangeHint_RepaintFrame and nsChangeHint_UpdateOpacityLayer, nothing else.
 */
 static void
 SyncViewsAndInvalidateDescendants(nsIFrame* aFrame,
-                                  nsFrameManager* aFrameManager,
                                   nsChangeHint aChange)
 {
   NS_PRECONDITION(gInApplyRenderingChangeToTree,
                   "should only be called within ApplyRenderingChangeToTree");
   NS_ASSERTION(aChange == (aChange & (nsChangeHint_RepaintFrame |
                                       nsChangeHint_SyncFrameView |
                                       nsChangeHint_UpdateOpacityLayer)),
                "Invalid change flag");
@@ -107,23 +105,21 @@ SyncViewsAndInvalidateDescendants(nsIFra
     for (; !childFrames.AtEnd(); childFrames.Next()) {
       nsIFrame* child = childFrames.get();
       if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
         // only do frames that don't have placeholders
         if (nsGkAtoms::placeholderFrame == child->GetType()) {
           // do the out-of-flow frame and its continuations
           nsIFrame* outOfFlowFrame =
             nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
-          DoApplyRenderingChangeToTree(outOfFlowFrame, aFrameManager,
-                                       aChange);
+          DoApplyRenderingChangeToTree(outOfFlowFrame, aChange);
         } else if (lists.CurrentID() == nsIFrame::kPopupList) {
-          DoApplyRenderingChangeToTree(child, aFrameManager,
-                                       aChange);
+          DoApplyRenderingChangeToTree(child, aChange);
         } else {  // regular frame
-          SyncViewsAndInvalidateDescendants(child, aFrameManager, aChange);
+          SyncViewsAndInvalidateDescendants(child, aChange);
         }
       }
     }
   }
 }
 
 /**
  * To handle nsChangeHint_ChildrenOnlyTransform we must iterate over the child
@@ -163,29 +159,28 @@ GetFrameForChildrenOnlyTransformHint(nsI
   NS_ABORT_IF_FALSE(aFrame->IsFrameOfType(nsIFrame::eSVG |
                                           nsIFrame::eSVGContainer),
                     "Children-only transforms only expected on SVG frames");
   return aFrame;
 }
 
 static void
 DoApplyRenderingChangeToTree(nsIFrame* aFrame,
-                             nsFrameManager* aFrameManager,
                              nsChangeHint aChange)
 {
   NS_PRECONDITION(gInApplyRenderingChangeToTree,
                   "should only be called within ApplyRenderingChangeToTree");
 
   for ( ; aFrame; aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame)) {
     // Invalidate and sync views on all descendant frames, following placeholders.
     // We don't need to update transforms in SyncViewsAndInvalidateDescendants, because
     // there can't be any out-of-flows or popups that need to be transformed;
     // all out-of-flow descendants of the transformed element must also be
     // descendants of the transformed frame.
-    SyncViewsAndInvalidateDescendants(aFrame, aFrameManager,
+    SyncViewsAndInvalidateDescendants(aFrame,
       nsChangeHint(aChange & (nsChangeHint_RepaintFrame |
                               nsChangeHint_SyncFrameView |
                               nsChangeHint_UpdateOpacityLayer)));
     // This must be set to true if the rendering change needs to
     // invalidate content.  If it's false, a composite-only paint
     // (empty transaction) will be scheduled.
     bool needInvalidatingPaint = false;
 
@@ -292,17 +287,17 @@ ApplyRenderingChangeToTree(nsPresContext
   // Trigger rendering updates by damaging this frame and any
   // continuations of this frame.
 
   // XXX this needs to detect the need for a view due to an opacity change and deal with it...
 
 #ifdef DEBUG
   gInApplyRenderingChangeToTree = true;
 #endif
-  DoApplyRenderingChangeToTree(aFrame, shell->FrameManager(), aChange);
+  DoApplyRenderingChangeToTree(aFrame, aChange);
 #ifdef DEBUG
   gInApplyRenderingChangeToTree = false;
 #endif
 }
 
 nsresult
 RestyleManager::StyleChangeReflow(nsIFrame* aFrame, nsChangeHint aHint)
 {
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -6248,17 +6248,17 @@ nsCSSFrameConstructor::MaybeConstructLaz
                    //XXX the child->GetPrimaryFrame()->GetContent() != child
                    // check is needed due to bug 135040. Remove it once that's
                    // fixed.
                    "setting NEEDS_FRAME on a node that already has a frame?");
       child->SetFlags(NODE_NEEDS_FRAME);
     }
   }
 
-  PostRestyleEventForLazyConstruction();
+  RestyleManager()->PostRestyleEventForLazyConstruction();
   return true;
 }
 
 void
 nsCSSFrameConstructor::CreateNeededFrames(nsIContent* aContent)
 {
   NS_ASSERTION(!aContent->HasFlag(NODE_NEEDS_FRAME),
     "shouldn't get here with a content node that has needs frame bit set");
@@ -8521,18 +8521,18 @@ nsCSSFrameConstructor::RecreateFramesFor
                           aContent->GetNextSibling(),
                         REMOVE_FOR_RECONSTRUCTION, &didReconstruct);
 
     if (NS_SUCCEEDED(rv) && !didReconstruct) {
       // Now, recreate the frames associated with this content object. If
       // ContentRemoved triggered reconstruction, then we don't need to do this
       // because the frames will already have been built.
       if (aAsyncInsert) {
-        PostRestyleEvent(aContent->AsElement(), nsRestyleHint(0),
-                         nsChangeHint_ReconstructFrame);
+        RestyleManager()->PostRestyleEvent(
+          aContent->AsElement(), nsRestyleHint(0), nsChangeHint_ReconstructFrame);
       } else {
         rv = ContentInserted(container, aContent, mTempFrameTreeState, false);
       }
     }
   }
 
   return rv;
 }
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -73,37 +73,29 @@ public:
                                   nsIAtom*       aTag,  // content object's tag
                                   nsXPIDLString& aAltText);
 
 private:
   nsCSSFrameConstructor(const nsCSSFrameConstructor& aCopy) MOZ_DELETE;
   nsCSSFrameConstructor& operator=(const nsCSSFrameConstructor& aCopy) MOZ_DELETE;
 
 public:
+  mozilla::RestyleManager* RestyleManager() const
+    { return mPresShell->GetPresContext()->RestyleManager(); }
+
   nsIFrame* ConstructRootFrame();
 
   nsresult ReconstructDocElementHierarchy();
 
   // Create frames for content nodes that are marked as needing frames. This
   // should be called before ProcessPendingRestyles.
   // Note: It's the caller's responsibility to make sure to wrap a
   // CreateNeededFrames call in a view update batch and a script blocker.
   void CreateNeededFrames();
 
-  mozilla::RestyleManager* RestyleManager() const
-    { return mPresShell->GetPresContext()->RestyleManager(); }
-
-  void PostRestyleEventForLazyConstruction()
-    { return RestyleManager()->PostRestyleEventForLazyConstruction(); }
-  void PostRestyleEvent(Element* aElement,
-                        nsRestyleHint aRestyleHint,
-                        nsChangeHint aMinChangeHint)
-    { return RestyleManager()->
-               PostRestyleEvent(aElement, aRestyleHint, aMinChangeHint); }
-
 private:
   void CreateNeededFrames(nsIContent* aContent);
 
   enum Operation {
     CONTENTAPPEND,
     CONTENTINSERT
   };
 
