Make the Windows widget code report 24-bit color depth when the display driver reports 32, since it's the same number of bits per pixel.  (Bug 466669)

diff --git a/gfx/src/thebes/nsThebesDeviceContext.cpp b/gfx/src/thebes/nsThebesDeviceContext.cpp
--- a/gfx/src/thebes/nsThebesDeviceContext.cpp
+++ b/gfx/src/thebes/nsThebesDeviceContext.cpp
@@ -235,17 +235,17 @@ nsThebesDeviceContext::SetDPI()
         if (dpi < 0) // something didn't work before, fall back to hardcoded DPI value
             dpi = 96;
 #elif defined(XP_MACOSX)
 
         // we probably want to actually get a real DPI here?
         dpi = 96;
 
 #elif defined(MOZ_WIDGET_QT)
-		// TODO: get real DPI here with Qt methods
+        // TODO: get real DPI here with Qt methods
         dpi = 96;
 #else
 #error undefined platform dpi
 #endif
 
         if (prefDPI > 0 && !mPrintingSurface)
             dpi = prefDPI;
     }
@@ -441,18 +441,18 @@ NS_IMETHODIMP
 nsThebesDeviceContext::CheckFontExistence(const nsString& aFaceName)
 {
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsThebesDeviceContext::GetDepth(PRUint32& aDepth)
 {
-    nsCOMPtr<nsIScreen> primaryScreen;
     if (mDepth == 0) {
+        nsCOMPtr<nsIScreen> primaryScreen;
         mScreenManager->GetPrimaryScreen(getter_AddRefs(primaryScreen));
         primaryScreen->GetColorDepth(reinterpret_cast<PRInt32 *>(&mDepth));
     }
 
     aDepth = mDepth;
     return NS_OK;
 }
 
diff --git a/layout/style/nsMediaFeatures.cpp b/layout/style/nsMediaFeatures.cpp
--- a/layout/style/nsMediaFeatures.cpp
+++ b/layout/style/nsMediaFeatures.cpp
@@ -188,21 +188,16 @@ GetColor(nsPresContext* aPresContext, ns
 {
     // FIXME:  This implementation is bogus.  nsThebesDeviceContext
     // doesn't provide reliable information (should be fixed in bug
     // 424386).
     // FIXME: On a monochrome device, return 0!
     nsIDeviceContext *dx = GetDeviceContextFor(aPresContext);
     PRUint32 depth;
     dx->GetDepth(depth);
-    // Some graphics backends may claim 32-bit depth when it's really 24
-    // (because they're counting the Alpha component).
-    if (depth == 32) {
-        depth = 24;
-    }
     // The spec says to use bits *per color component*, so divide by 3,
     // and round down, since the spec says to use the smallest when the
     // color components differ.
     depth /= 3;
     aResult.SetIntValue(PRInt32(depth), eCSSUnit_Integer);
     return NS_OK;
 }
 
diff --git a/widget/src/windows/nsScreenWin.cpp b/widget/src/windows/nsScreenWin.cpp
--- a/widget/src/windows/nsScreenWin.cpp
+++ b/widget/src/windows/nsScreenWin.cpp
@@ -142,17 +142,24 @@ nsScreenWin :: GetAvailRect(PRInt32 *out
 
 NS_IMETHODIMP 
 nsScreenWin :: GetPixelDepth(PRInt32 *aPixelDepth)
 {
   //XXX not sure how to get this info for multiple monitors, this might be ok...
   HDC hDCScreen = ::GetDC(nsnull);
   NS_ASSERTION(hDCScreen,"GetDC Failure");
 
-  *aPixelDepth = ::GetDeviceCaps(hDCScreen, BITSPIXEL);
+  PRInt32 depth = ::GetDeviceCaps(hDCScreen, BITSPIXEL);
+  if (depth == 32) {
+    // If a device uses 32 bits per pixel, it's still only using 8 bits
+    // per color component, which is what our callers want to know.
+    // (Some devices report 32 and some devices report 24.)
+    depth = 24;
+  }
+  *aPixelDepth = depth;
 
   ::ReleaseDC(nsnull, hDCScreen);
   return NS_OK;
 
 } // GetPixelDepth
 
 
 NS_IMETHODIMP 
