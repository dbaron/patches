Make the Windows widget code report 24-bit color depth when the display driver reports 32, since it's the same number of bits per pixel.  (Bug 466669)

diff --git a/layout/style/nsMediaFeatures.cpp b/layout/style/nsMediaFeatures.cpp
--- a/layout/style/nsMediaFeatures.cpp
+++ b/layout/style/nsMediaFeatures.cpp
@@ -188,21 +188,16 @@ GetColor(nsPresContext* aPresContext, ns
 {
     // FIXME:  This implementation is bogus.  nsThebesDeviceContext
     // doesn't provide reliable information (should be fixed in bug
     // 424386).
     // FIXME: On a monochrome device, return 0!
     nsIDeviceContext *dx = GetDeviceContextFor(aPresContext);
     PRUint32 depth;
     dx->GetDepth(depth);
-    // Some graphics backends may claim 32-bit depth when it's really 24
-    // (because they're counting the Alpha component).
-    if (depth == 32) {
-        depth = 24;
-    }
     // The spec says to use bits *per color component*, so divide by 3,
     // and round down, since the spec says to use the smallest when the
     // color components differ.
     depth /= 3;
     aResult.SetIntValue(PRInt32(depth), eCSSUnit_Integer);
     return NS_OK;
 }
 
diff --git a/widget/src/windows/nsScreenWin.cpp b/widget/src/windows/nsScreenWin.cpp
--- a/widget/src/windows/nsScreenWin.cpp
+++ b/widget/src/windows/nsScreenWin.cpp
@@ -142,17 +142,23 @@ nsScreenWin :: GetAvailRect(PRInt32 *out
 
 NS_IMETHODIMP 
 nsScreenWin :: GetPixelDepth(PRInt32 *aPixelDepth)
 {
   //XXX not sure how to get this info for multiple monitors, this might be ok...
   HDC hDCScreen = ::GetDC(nsnull);
   NS_ASSERTION(hDCScreen,"GetDC Failure");
 
-  *aPixelDepth = ::GetDeviceCaps(hDCScreen, BITSPIXEL);
+  PRInt32 depth = ::GetDeviceCaps(hDCScreen, BITSPIXEL);
+  if (depth == 32) {
+    // If a device uses 32 bits per pixel, it's still only using 8 bits
+    // per color component, which is what our callers want to know.
+    depth = 24;
+  }
+  *aPixelDepth = depth;
 
   ::ReleaseDC(nsnull, hDCScreen);
   return NS_OK;
 
 } // GetPixelDepth
 
 
 NS_IMETHODIMP 
