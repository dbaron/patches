From: L. David Baron <dbaron@dbaron.org>

Avoid showing black when the if-visited style is transparent and the unvisited style is a color.  (Bug 557584)  r=bzbarsky

diff --git a/layout/reftests/css-visited/white-to-transparent-1-ref.html b/layout/reftests/css-visited/white-to-transparent-1-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/css-visited/white-to-transparent-1-ref.html
@@ -0,0 +1,11 @@
+<!DOCTYPE HTML>
+<title>Test for privacy restrictions on :visited (Bug 147777)</title>
+<style type="text/css">
+
+body { background: white; color: black }
+
+span { background: #ccc; }
+
+</style>
+<span>unvisited</span>
+<span>visited</span>
diff --git a/layout/reftests/css-visited/white-to-transparent-1.html b/layout/reftests/css-visited/white-to-transparent-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/css-visited/white-to-transparent-1.html
@@ -0,0 +1,13 @@
+<!DOCTYPE HTML>
+<title>Test for privacy restrictions on :visited (Bug 147777)</title>
+<style type="text/css">
+
+body { background: white; color: black }
+
+a { text-decoration: none; color: black }
+:link { background: #ccc; }
+:visited { background: transparent }
+
+</style>
+<a href="unvisited-page.html">unvisited</a>
+<a href="visited-page.html">visited</a>
diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -748,16 +748,24 @@ nsStyleContext::GetVisitedDependentColor
 
   return nsStyleContext::CombineVisitedColors(colors,
                                               this->RelevantLinkVisited());
 }
 
 /* static */ nscolor
 nsStyleContext::CombineVisitedColors(nscolor *aColors, PRBool aLinkIsVisited)
 {
+  if (NS_GET_A(aColors[1]) == 0) {
+    // If the style-if-visited is transparent, then just use the
+    // unvisited style rather than using the (meaningless) color
+    // components of the visited style along with a potentially
+    // non-transparent alpha value.
+    aLinkIsVisited = PR_FALSE;
+  }
+
   // NOTE: We want this code to have as little timing dependence as
   // possible on whether this->RelevantLinkVisited() is true.
   const ColorIndexSet &set =
     gVisitedIndices[aLinkIsVisited ? 1 : 0];
 
   nscolor colorColor = aColors[set.colorIndex];
   nscolor alphaColor = aColors[set.alphaIndex];
   return NS_RGBA(NS_GET_R(colorColor), NS_GET_G(colorColor),
diff --git a/layout/style/test/test_visited_reftests.html b/layout/style/test/test_visited_reftests.html
--- a/layout/style/test/test_visited_reftests.html
+++ b/layout/style/test/test_visited_reftests.html
@@ -72,16 +72,17 @@ var gTests = [
   "== subject-of-selector-descendant-2.xhtml subject-of-selector-descendant-2-ref.xhtml",
   "== subject-of-selector-child-1.html subject-of-selector-1-ref.html",
   "== subject-of-selector-adj-sibling-1.html subject-of-selector-1-ref.html",
   "== subject-of-selector-any-sibling-1.html subject-of-selector-1-ref.html",
   "== inherit-keyword-1.xhtml inherit-keyword-1-ref.html",
   // FIXME: commented out because dynamic changes on the non-first-line
   // part of the test don't work right when the link becomes visited.
   //"== first-line-1.html first-line-1-ref.html",
+  "== white-to-transparent-1.html white-to-transparent-1-ref.html",
 ];
 
 // Maintain a reference count of how many things we're waiting for until
 // we can say the tests are done.
 var gDelayCount = 0;
 function AddFinishDependency()
   { ++gDelayCount; }
 function RemoveFinishDependency()
