From: L. David Baron <dbaron@dbaron.org>

Pass style rule to post-resolve callbacks.  (Maybe not the long term approach for CSS transitions, but easiest right now.)  (Bug 435441)  r=bzbarsky

diff --git a/layout/style/nsHTMLStyleSheet.cpp b/layout/style/nsHTMLStyleSheet.cpp
--- a/layout/style/nsHTMLStyleSheet.cpp
+++ b/layout/style/nsHTMLStyleSheet.cpp
@@ -187,106 +187,111 @@ ProcessTableRulesAttribute(void*       a
         borderData->SetBorderColor(aSide, borderColor);
       }
       // set the border width to be 1 pixel
       borderData->SetBorderWidth(aSide, nsPresContext::CSSPixelsToAppUnits(1));
     }
   }
 }
 
-static void TbodyPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData)
+static void TbodyPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData, nsIStyleRule* aStyleRule)
 {
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_TOP, PR_TRUE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_GROUPS, NS_STYLE_TABLE_RULES_ROWS);
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_BOTTOM, PR_TRUE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_GROUPS, NS_STYLE_TABLE_RULES_ROWS);
 }
 
 NS_IMETHODIMP
 nsHTMLStyleSheet::TableTbodyRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Border)) {
     aRuleData->mCanStoreInRuleTree = PR_FALSE;
-    aRuleData->mPostResolveCallbacks.AppendElement(&TbodyPostResolveCallback);
+    nsPostResolveCallback prc = { &TbodyPostResolveCallback, this };
+    aRuleData->mPostResolveCallbacks.AppendElement(prc);
   }
   return NS_OK;
 }
 // -----------------------------------------------------------
 
-static void RowPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData)
+static void RowPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData, nsIStyleRule* aStyleRule)
 {
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_TOP, PR_FALSE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_ROWS, NS_STYLE_TABLE_RULES_ROWS);
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_BOTTOM, PR_FALSE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_ROWS, NS_STYLE_TABLE_RULES_ROWS);
 }
 
 NS_IMETHODIMP
 nsHTMLStyleSheet::TableRowRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Border)) {
     aRuleData->mCanStoreInRuleTree = PR_FALSE;
-    aRuleData->mPostResolveCallbacks.AppendElement(&RowPostResolveCallback);
+    nsPostResolveCallback prc = { &RowPostResolveCallback, this };
+    aRuleData->mPostResolveCallbacks.AppendElement(prc);
   }
   return NS_OK;
 }
 
-static void ColgroupPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData)
+static void ColgroupPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData, nsIStyleRule* aStyleRule)
 {
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_LEFT, PR_TRUE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_GROUPS, NS_STYLE_TABLE_RULES_COLS);
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_RIGHT, PR_TRUE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_GROUPS, NS_STYLE_TABLE_RULES_COLS);
 }
 
 NS_IMETHODIMP
 nsHTMLStyleSheet::TableColgroupRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Border)) {
     aRuleData->mCanStoreInRuleTree = PR_FALSE;
-    aRuleData->mPostResolveCallbacks.AppendElement(&ColgroupPostResolveCallback);
+    nsPostResolveCallback prc = { &ColgroupPostResolveCallback, this };
+    aRuleData->mPostResolveCallbacks.AppendElement(prc);
   }
   return NS_OK;
 }
 
-static void ColPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData)
+static void ColPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData, nsIStyleRule* aStyleRule)
 {
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_LEFT, PR_FALSE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_COLS, NS_STYLE_TABLE_RULES_COLS);
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_RIGHT, PR_FALSE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_COLS, NS_STYLE_TABLE_RULES_COLS);
 }
 
 static void UngroupedColPostResolveCallback(void* aStyleStruct,
-                                            nsRuleData* aRuleData)
+                                            nsRuleData* aRuleData, nsIStyleRule* aStyleRule)
 {
   // Pass PR_TRUE for aGroup, so that we find the table's style
   // context correctly.
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_LEFT, PR_TRUE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_COLS, NS_STYLE_TABLE_RULES_COLS);
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_RIGHT, PR_TRUE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_COLS, NS_STYLE_TABLE_RULES_COLS);
 }
 
 NS_IMETHODIMP
 nsHTMLStyleSheet::TableColRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Border)) {
     aRuleData->mCanStoreInRuleTree = PR_FALSE;
-    aRuleData->mPostResolveCallbacks.AppendElement(&ColPostResolveCallback);
+    nsPostResolveCallback prc = { &ColPostResolveCallback, this };
+    aRuleData->mPostResolveCallbacks.AppendElement(prc);
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsHTMLStyleSheet::TableUngroupedColRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Border)) {
     aRuleData->mCanStoreInRuleTree = PR_FALSE;
-    aRuleData->mPostResolveCallbacks.AppendElement(&UngroupedColPostResolveCallback);
+    nsPostResolveCallback prc = { &UngroupedColPostResolveCallback, this };
+    aRuleData->mPostResolveCallbacks.AppendElement(prc);
   }
   return NS_OK;
 }
 // -----------------------------------------------------------
 
 struct MappedAttrTableEntry : public PLDHashEntryHdr {
   nsMappedAttributes *mAttributes;
 };
diff --git a/layout/style/nsRuleData.h b/layout/style/nsRuleData.h
--- a/layout/style/nsRuleData.h
+++ b/layout/style/nsRuleData.h
@@ -46,29 +46,35 @@
 
 #include "nsCSSStruct.h"
 #include "nsStyleStructFwd.h"
 #include "nsTArray.h"
 class nsPresContext;
 class nsStyleContext;
 
 struct nsRuleData;
-typedef void (*nsPostResolveFunc)(void* aStyleStruct, nsRuleData* aData);
+typedef void (*nsPostResolveFunc)(void* aStyleStruct, nsRuleData* aData,
+                                  nsIStyleRule* aRule);
+
+struct nsPostResolveCallback {
+  nsPostResolveFunc mFunc;
+  nsIStyleRule *mRule;
+};
 
 struct nsRuleData
 {
   PRUint32 mSIDs;
   PRPackedBool mCanStoreInRuleTree;
   PRPackedBool mIsImportantRule;
   PRUint8 mLevel; // an nsStyleSet::sheetType
   nsPresContext* mPresContext;
   nsStyleContext* mStyleContext;
   // MapRuleInfoInto should append to this array, so it is ordered from
   // most specific to least.
-  nsTArray<nsPostResolveFunc> mPostResolveCallbacks;
+  nsTArray<nsPostResolveCallback> mPostResolveCallbacks;
   nsRuleDataFont* mFontData; // Should always be stack-allocated! We don't own these structures!
   nsRuleDataDisplay* mDisplayData;
   nsRuleDataMargin* mMarginData;
   nsRuleDataList* mListData;
   nsRuleDataPosition* mPositionData;
   nsRuleDataTable* mTableData;
   nsRuleDataColor* mColorData;
   nsRuleDataContent* mContentData;
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -2008,17 +2008,18 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
 #include "nsStyleStructList.h"
 #undef STYLE_STRUCT
 #undef STYLE_STRUCT_TEST
 
   // If we have post-resolve callbacks, handle that now.
   if (NS_LIKELY(res != nsnull)) {
     // Enumerate from least to most specific rule.
     for (PRUint32 i = aRuleData->mPostResolveCallbacks.Length(); i-- != 0; ) {
-      (*aRuleData->mPostResolveCallbacks[i])(const_cast<void*>(res), aRuleData);
+      nsPostResolveCallback &prc = aRuleData->mPostResolveCallbacks[i];
+      (*prc.mFunc)(const_cast<void*>(res), aRuleData, prc.mRule);
     }
   }
 
   // Now return the result.
   return res;
 }
 
 const void*
@@ -3006,17 +3007,18 @@ nsRuleNode::SetGenericFont(nsPresContext
     nsRuleNode::SetFont(aPresContext, context, aMinFontSize,
                         aGenericFontID, fontData, &parentFont, aFont,
                         PR_FALSE, dummy);
 
     // XXX Not sure if we need to do this here
     // If we have post-resolve callbacks, handle that now.
     // Enumerate from least to most specific rule.
     for (PRUint32 j = ruleData.mPostResolveCallbacks.Length(); j-- != 0; ) {
-      (*ruleData.mPostResolveCallbacks[j])(aFont, &ruleData);
+      nsPostResolveCallback &prc = ruleData.mPostResolveCallbacks[j];
+      (*prc.mFunc)(aFont, &ruleData, prc.mRule);
     }
 
     parentFont = *aFont;
   }
 }
 
 static PRBool ExtractGeneric(const nsString& aFamily, PRBool aGeneric,
                              void *aData)
