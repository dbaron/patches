Make nsROCSSPrimitiveValue store ident values as nsCSSKeyword rather than nsIAtom*.  (Bug 474712)  r+sr=bzbarsky

diff --git a/layout/style/nsROCSSPrimitiveValue.cpp b/layout/style/nsROCSSPrimitiveValue.cpp
--- a/layout/style/nsROCSSPrimitiveValue.cpp
+++ b/layout/style/nsROCSSPrimitiveValue.cpp
@@ -125,19 +125,18 @@ nsROCSSPrimitiveValue::GetCssText(nsAStr
       {
         float val = nsPresContext::AppUnitsToFloatCSSPixels(mValue.mAppUnits);
         tmpStr.AppendFloat(val);
         tmpStr.AppendLiteral("px");
         break;
       }
     case CSS_IDENT :
       {
-        const char *atomValue;
-        mValue.mAtom->GetUTF8String(&atomValue);
-        AppendUTF8toUTF16(atomValue, tmpStr);
+        AppendUTF8toUTF16(nsCSSKeywords::GetStringValue(mValue.mKeyword),
+                          tmpStr);
         break;
       }
     case CSS_STRING :
     case CSS_COUNTER : /* FIXME: COUNTER should use an object */
       {
         tmpStr.Append(mValue.mString);
         break;
       }
@@ -412,17 +411,17 @@ nsROCSSPrimitiveValue::SetStringValue(PR
 }
 
 
 NS_IMETHODIMP
 nsROCSSPrimitiveValue::GetStringValue(nsAString& aReturn)
 {
   switch (mType) {
     case CSS_IDENT:
-      mValue.mAtom->ToString(aReturn);
+      CopyUTF8toUTF16(nsCSSKeywords::GetStringValue(mValue.mKeyword), aReturn);
       break;
     case CSS_STRING:
     case CSS_ATTR:
       aReturn.Assign(mValue.mString);
       break;
     case CSS_URI: {
       nsCAutoString spec;
       if (mValue.mURI)
diff --git a/layout/style/nsROCSSPrimitiveValue.h b/layout/style/nsROCSSPrimitiveValue.h
--- a/layout/style/nsROCSSPrimitiveValue.h
+++ b/layout/style/nsROCSSPrimitiveValue.h
@@ -105,40 +105,24 @@ public:
     mType = CSS_PX;
   }
 
   void SetAppUnits(float aValue)
   {
     SetAppUnits(NSToCoordRound(aValue));
   }
 
-  void SetIdent(nsIAtom* aAtom)
-  {
-    NS_PRECONDITION(aAtom, "Don't pass in a null atom");
-    Reset();
-    NS_ADDREF(mValue.mAtom = aAtom);
-    mType = CSS_IDENT;
-  }
-
-  // FIXME More callers should use this variant.
   void SetIdent(nsCSSKeyword aKeyword)
   {
-    SetIdent(nsCSSKeywords::GetStringValue(aKeyword));
-  }
-
-  void SetIdent(const nsACString& aString)
-  {
+    NS_PRECONDITION(aKeyword != eCSSKeyword_UNKNOWN &&
+                    0 <= aKeyword && aKeyword < eCSSKeyword_COUNT,
+                    "bad keyword");
     Reset();
-    mValue.mAtom = NS_NewAtom(aString);
-    if (mValue.mAtom) {
-      mType = CSS_IDENT;
-    } else {
-      // XXXcaa We should probably let the caller know we are out of memory
-      mType = CSS_UNKNOWN;
-    }
+    mValue.mKeyword = aKeyword;
+    mType = CSS_IDENT;
   }
 
   // FIXME: CSS_STRING should imply a string with "" and a need for escaping.
   void SetString(const nsACString& aString, PRUint16 aType = CSS_STRING)
   {
     Reset();
     mValue.mString = ToNewUnicode(aString);
     if (mValue.mString) {
@@ -197,18 +181,16 @@ public:
       mType = CSS_UNKNOWN;
     }
   }
 
   void Reset(void)
   {
     switch (mType) {
       case CSS_IDENT:
-        NS_ASSERTION(mValue.mAtom, "Null atom should never happen");
-        NS_RELEASE(mValue.mAtom);
         break;
       case CSS_STRING:
       case CSS_ATTR:
       case CSS_COUNTER: // FIXME: Counter should use an object
         NS_ASSERTION(mValue.mString, "Null string should never happen");
         nsMemory::Free(mValue.mString);
         mValue.mString = nsnull;
         break;
@@ -233,16 +215,16 @@ private:
 
   union {
     nscoord         mAppUnits;
     float           mFloat;
     nsDOMCSSRGBColor* mColor;
     nsIDOMRect*     mRect;
     PRUnichar*      mString;
     nsIURI*         mURI;
-    nsIAtom*        mAtom; // FIXME use nsCSSKeyword instead
+    nsCSSKeyword    mKeyword;
   } mValue;
   
   PRInt32 mAppUnitsPerInch;
 };
 
 #endif /* nsROCSSPrimitiveValue_h___ */
 
