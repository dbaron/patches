From: L. David Baron <dbaron@dbaron.org>

Bug 1308876 - Mark lines dirty when we abort their reflow due to page-break-inside:avoid.  r?dholbert

Both of the changes are needed to fix
layout/reftests/w3c-css/submitted/css21/pagination/moz-css21-float-page-break-inside-avoid-4.html
with the following patch.

These are now needed because dirtiness transfers from parent to child
only at the start of reflow, so frames that are pulled during reflow are
not marked dirty (and thus forced to reflow all of their lines).  This
means that the following patch introduces the possibility of non-dirty
reflows during printing, which is the only case where
page-break-inside:avoid currently works.  (CHECK THIS!!!)

FIXME: Add test!

MozReview-Commit-ID: JZ3qWTSO2lX

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -3753,16 +3753,19 @@ nsBlockFrame::ReflowBlockFrame(BlockRefl
 #endif
       } else {
         if ((aLine == mLines.front() && !GetPrevInFlow()) ||
             ShouldAvoidBreakInside(aState.mReflowInput)) {
           // If it's our very first line *or* we're not at the top of the page
           // and we have page-break-inside:avoid, then we need to be pushed to
           // our parent's next-in-flow.
           aState.mReflowStatus.SetInlineLineBreakBeforeAndReset();
+          // When we reflow in the new position, we need to reflow this
+          // line again.
+          aLine->MarkDirty();
         } else {
           // Push the line that didn't fit and any lines that follow it
           // to our next-in-flow.
           PushLines(aState, aLine.prev());
           aState.mReflowStatus.SetIncomplete();
         }
       }
     }
@@ -4640,16 +4643,18 @@ nsBlockFrame::PlaceLine(BlockReflowInput
                    ? -aState.mPrevBEndMargin.get() : 0;
     newBCoord = aState.mBCoord + dy;
   }
 
   if (!aState.mReflowStatus.IsFullyComplete() &&
       ShouldAvoidBreakInside(aState.mReflowInput)) {
     aLine->AppendFloats(aState.mCurrentLineFloats);
     aState.mReflowStatus.SetInlineLineBreakBeforeAndReset();
+    // Reflow the line again when we reflow at our new position.
+    aLine->MarkDirty();
     return true;
   }
 
   // See if the line fit (our first line always does).
   if (mLines.front() != aLine &&
       newBCoord > aState.mBEndEdge &&
       aState.mBEndEdge != NS_UNCONSTRAINEDSIZE) {
     NS_ASSERTION(aState.mCurrentLine == aLine, "oops");
