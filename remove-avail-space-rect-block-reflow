Switch away from nsBlockReflowState::mAvailSpaceRect for reflow of child blocks.  (Bug 25888)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -2946,25 +2946,27 @@ nsBlockFrame::ReflowBlockFrame(nsBlockRe
       } else {
         // Advance aState.mY to the top border-edge of the frame.
         aState.mY += topMargin;
       }
     }
     
     // Here aState.mY is the top border-edge of the block.
     // Compute the available space for the block
-    aState.GetAvailableSpace();
+    nsRect floatAvailableSpace;
+    PRBool isImpacted = aState.GetFloatAvailableSpace(floatAvailableSpace);
 #ifdef REALLY_NOISY_REFLOW
-    printf("setting line %p isImpacted to %s\n", aLine.get(), aState.IsImpactedByFloat()?"true":"false");
-#endif
-    PRBool isImpacted = aState.IsImpactedByFloat() ? PR_TRUE : PR_FALSE;
+    printf("setting line %p isImpacted to %s\n",
+           aLine.get(), isImpacted?"true":"false");
+#endif
     aLine->SetLineIsImpactedByFloat(isImpacted);
     nsRect availSpace;
-    aState.ComputeBlockAvailSpace(frame, display, replacedBlock != nsnull,
-                                  availSpace);
+    aState.ComputeBlockAvailSpace(frame, display,
+                                  isImpacted, floatAvailableSpace,
+                                  replacedBlock != nsnull, availSpace);
     
     // Now put the Y coordinate back to the top of the top-margin +
     // clearance, and flow the block.
     aState.mY -= topMargin;
     availSpace.y -= topMargin;
     if (NS_UNCONSTRAINEDSIZE != availSpace.height) {
       availSpace.height += topMargin;
     }
@@ -6841,16 +6843,17 @@ nsBlockFrame::BlockCanIntersectFloats(ns
 
 // Note that this width can vary based on the vertical position.
 // However, the cases where it varies are the cases where the width fits
 // in the available space given, which means that variation shouldn't
 // matter.
 /* static */
 nsBlockFrame::ReplacedElementWidthToClear
 nsBlockFrame::WidthToClearPastFloats(nsBlockReflowState& aState,
+                                     const nsRect& aFloatAvailableSpace,
                                      nsIFrame* aFrame)
 {
   nscoord leftOffset, rightOffset;
   nsCSSOffsetState offsetState(aFrame, aState.mReflowState.rendContext,
                                aState.mContentArea.width);
 
   ReplacedElementWidthToClear result;
   // A table outer frame is an exception in that it is a block child
@@ -6894,17 +6897,18 @@ nsBlockFrame::WidthToClearPastFloats(nsB
         result.marginLeft = captionMargin.left;
         result.marginRight = tableMargin.right;
       } else {
         result.marginLeft = tableMargin.left;
         result.marginRight = captionMargin.right;
       }
     }
 
-    aState.ComputeReplacedBlockOffsetsForFloats(aFrame, leftOffset, rightOffset,
+    aState.ComputeReplacedBlockOffsetsForFloats(aFrame, aFloatAvailableSpace,
+                                                leftOffset, rightOffset,
                                                 &result);
 
     // result.marginLeft has already been subtracted from leftOffset (etc.)
     nscoord availWidth = aState.mContentArea.width - leftOffset - rightOffset;
     // Force the outer frame to shrink-wrap (otherwise it just sizes to
     // the available width unconditionally).
     result.borderBoxWidth =
       aFrame->ComputeSize(aState.mReflowState.rendContext,
@@ -6918,17 +6922,18 @@ nsBlockFrame::WidthToClearPastFloats(nsB
                                  offsetState.mComputedBorderPadding.TopBottom() -
                                    offsetState.mComputedPadding.TopBottom()),
                           nsSize(offsetState.mComputedPadding.LeftRight(),
                                  offsetState.mComputedPadding.TopBottom()),
                           PR_TRUE).width +
       offsetState.mComputedBorderPadding.LeftRight() -
       (result.marginLeft + result.marginRight);
   } else {
-    aState.ComputeReplacedBlockOffsetsForFloats(aFrame, leftOffset, rightOffset);
+    aState.ComputeReplacedBlockOffsetsForFloats(aFrame, aFloatAvailableSpace,
+                                                leftOffset, rightOffset);
     nscoord availWidth = aState.mContentArea.width - leftOffset - rightOffset;
 
     // We actually don't want the min width here; see bug 427782; we only
     // want to displace if the width won't compute to a value small enough
     // to fit.
     // All we really need here is the result of ComputeSize, and we
     // could *almost* get that from an nsCSSOffsetState, except for the
     // last argument.
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -299,17 +299,19 @@ public:
    * care about (which need not be its current mY)
    */
   struct ReplacedElementWidthToClear {
     nscoord marginLeft, borderBoxWidth, marginRight;
     nscoord MarginBoxWidth() const
       { return marginLeft + borderBoxWidth + marginRight; }
   };
   static ReplacedElementWidthToClear
-    WidthToClearPastFloats(nsBlockReflowState& aState, nsIFrame* aFrame);
+    WidthToClearPastFloats(nsBlockReflowState& aState,
+                           const nsRect& aFloatAvailableSpace,
+                           nsIFrame* aFrame);
 
   /**
    * Walks up the frame tree, starting with aCandidate, and returns the first
    * block frame that it encounters.
    */
   static nsBlockFrame* GetNearestAncestorBlock(nsIFrame* aCandidate);
   
 protected:
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -184,75 +184,79 @@ nsBlockReflowState::FreeLineBox(nsLineBo
 {
   if (aLine) {
     aLine->Destroy(mPresContext->PresShell());
   }
 }
 
 void
 nsBlockReflowState::ComputeReplacedBlockOffsetsForFloats(nsIFrame* aFrame,
+                                                         const nsRect& aFloatAvailableSpace,
                                                          nscoord& aLeftResult,
                                                          nscoord& aRightResult,
                                                          nsBlockFrame::
                                                       ReplacedElementWidthToClear
                                                                  *aReplacedWidth)
 {
   // The frame is clueless about the float manager and therefore we
   // only give it free space. An example is a table frame - the
   // tables do not flow around floats.
   // However, we can let its margins intersect floats.
-  NS_ASSERTION(mAvailSpaceRect.x >= 0, "bad avail space rect x");
-  NS_ASSERTION(mAvailSpaceRect.width == 0 ||
-               mAvailSpaceRect.XMost() <= mContentArea.width,
+  NS_ASSERTION(aFloatAvailableSpace.x >= 0, "bad avail space rect x");
+  NS_ASSERTION(aFloatAvailableSpace.width == 0 ||
+               aFloatAvailableSpace.XMost() <= mContentArea.width,
                "bad avail space rect width");
 
   nscoord leftOffset, rightOffset;
-  if (mAvailSpaceRect.width == mContentArea.width) {
+  if (aFloatAvailableSpace.width == mContentArea.width) {
     // We don't need to compute margins when there are no floats around.
     leftOffset = 0;
     rightOffset = 0;
   } else {
     // We pass in aReplacedWidth to make handling outer table frames
     // work correctly.  For outer table frames, we need to subtract off
     // the margin that's going to be at the edge of them, since we're
     // dealing with margin that it's really the child's responsibility
     // to place.
     nsCSSOffsetState os(aFrame, mReflowState.rendContext, mContentArea.width);
     NS_ASSERTION(!aReplacedWidth ||
                  aFrame->GetType() == nsGkAtoms::tableOuterFrame ||
                  (aReplacedWidth->marginLeft  == os.mComputedMargin.left &&
                   aReplacedWidth->marginRight == os.mComputedMargin.right),
                  "unexpected aReplacedWidth");
 
-    nscoord leftFloatXOffset = mAvailSpaceRect.x;
+    nscoord leftFloatXOffset = aFloatAvailableSpace.x;
     leftOffset = PR_MAX(leftFloatXOffset, os.mComputedMargin.left) -
                  (aReplacedWidth ? aReplacedWidth->marginLeft
                                  : os.mComputedMargin.left);
     leftOffset = PR_MAX(leftOffset, 0); // in case of negative margin
-    nscoord rightFloatXOffset = mContentArea.width - mAvailSpaceRect.XMost();
+    nscoord rightFloatXOffset =
+      mContentArea.width - aFloatAvailableSpace.XMost();
     rightOffset = PR_MAX(rightFloatXOffset, os.mComputedMargin.right) -
                   (aReplacedWidth ? aReplacedWidth->marginRight
                                   : os.mComputedMargin.right);
     rightOffset = PR_MAX(rightOffset, 0); // in case of negative margin
   }
   aLeftResult = leftOffset;
   aRightResult = rightOffset;
 }
 
 // Compute the amount of available space for reflowing a block frame
 // at the current Y coordinate. This method assumes that
 // GetAvailableSpace has already been called.
 void
 nsBlockReflowState::ComputeBlockAvailSpace(nsIFrame* aFrame,
                                            const nsStyleDisplay* aDisplay,
+                                           PRBool aBandHasFloats,
+                                           const nsRect& aFloatAvailableSpace,
                                            PRBool aBlockAvoidsFloats,
                                            nsRect& aResult)
 {
 #ifdef REALLY_NOISY_REFLOW
-  printf("CBAS frame=%p has floats %d\n", aFrame, mBandHasFloats);
+  printf("CBAS frame=%p has floats %d\n", aFrame, aBandHasFloats);
 #endif
   aResult.y = mY;
   aResult.height = GetFlag(BRS_UNCONSTRAINEDHEIGHT)
     ? NS_UNCONSTRAINEDSIZE
     : PR_MAX(0, mReflowState.availableHeight - mY);
   // mY might be greater than mBottomEdge if the block's top margin pushes
   // it off the page/column. Negative available height can confuse other code
   // and is nonsense in principle.
@@ -270,34 +274,34 @@ nsBlockReflowState::ComputeBlockAvailSpa
   // true but nsBlockFrame::BlockCanIntersectFloats is false,
   // nsBlockFrame::WidthToClearPastFloats would need to use the
   // shrink-wrap formula, max(MIN_WIDTH, min(avail width, PREF_WIDTH))
   // rather than just using MIN_WIDTH.
   NS_ASSERTION(nsBlockFrame::BlockCanIntersectFloats(aFrame) == 
                  !aBlockAvoidsFloats,
                "unexpected replaced width");
   if (!aBlockAvoidsFloats) {
-    if (mBandHasFloats) {
+    if (aBandHasFloats) {
       // Use the float-edge property to determine how the child block
       // will interact with the float.
       const nsStyleBorder* borderStyle = aFrame->GetStyleBorder();
       switch (borderStyle->mFloatEdge) {
         default:
         case NS_STYLE_FLOAT_EDGE_CONTENT:  // content and only content does runaround of floats
           // The child block will flow around the float. Therefore
           // give it all of the available space.
           aResult.x = borderPadding.left;
           aResult.width = mContentArea.width;
           break;
         case NS_STYLE_FLOAT_EDGE_MARGIN:
           {
             // The child block's margins should be placed adjacent to,
             // but not overlap the float.
-            aResult.x = mAvailSpaceRect.x + borderPadding.left;
-            aResult.width = mAvailSpaceRect.width;
+            aResult.x = aFloatAvailableSpace.x + borderPadding.left;
+            aResult.width = aFloatAvailableSpace.width;
           }
           break;
       }
     }
     else {
       // Since there are no floats present the float-edge property
       // doesn't matter therefore give the block element all of the
       // available space since it will flow around the float itself.
@@ -305,21 +309,24 @@ nsBlockReflowState::ComputeBlockAvailSpa
       aResult.width = mContentArea.width;
     }
   }
   else {
     nsBlockFrame::ReplacedElementWidthToClear replacedWidthStruct;
     nsBlockFrame::ReplacedElementWidthToClear *replacedWidth = nsnull;
     if (aFrame->GetType() == nsGkAtoms::tableOuterFrame) {
       replacedWidth = &replacedWidthStruct;
-      replacedWidthStruct = nsBlockFrame::WidthToClearPastFloats(*this, aFrame);
+      replacedWidthStruct =
+        nsBlockFrame::WidthToClearPastFloats(*this, aFloatAvailableSpace,
+                                             aFrame);
     }
 
     nscoord leftOffset, rightOffset;
-    ComputeReplacedBlockOffsetsForFloats(aFrame, leftOffset, rightOffset,
+    ComputeReplacedBlockOffsetsForFloats(aFrame, aFloatAvailableSpace,
+                                         leftOffset, rightOffset,
                                          replacedWidth);
     aResult.x = borderPadding.left + leftOffset;
     aResult.width = mContentArea.width - leftOffset - rightOffset;
   }
 
 #ifdef REALLY_NOISY_REFLOW
   printf("  CBAS: result %d %d %d %d\n", aResult.x, aResult.y, aResult.width, aResult.height);
 #endif
@@ -1105,47 +1112,45 @@ nsBlockReflowState::ClearFloats(nscoord 
   nscoord newY = aY;
 
   if (aBreakType != NS_STYLE_CLEAR_NONE) {
     newY = bp.top + mFloatManager->ClearFloats(newY - bp.top, aBreakType);
   }
 
   if (aReplacedBlock) {
     for (;;) {
-      GetAvailableSpace(newY, PR_FALSE);
+      nsRect floatAvailableSpace;
+      PRBool bandHasFloats =
+        GetFloatAvailableSpace(newY, PR_FALSE, floatAvailableSpace);
       nsBlockFrame::ReplacedElementWidthToClear replacedWidth =
-        nsBlockFrame::WidthToClearPastFloats(*this, aReplacedBlock);
-      if (!mBandHasFloats ||
-          PR_MAX(mAvailSpaceRect.x, replacedWidth.marginLeft) +
+        nsBlockFrame::WidthToClearPastFloats(*this, floatAvailableSpace,
+                                             aReplacedBlock);
+      if (!bandHasFloats ||
+          PR_MAX(floatAvailableSpace.x, replacedWidth.marginLeft) +
             replacedWidth.borderBoxWidth +
             PR_MAX(mContentArea.width -
-                     PR_MIN(mContentArea.width, mAvailSpaceRect.XMost()),
+                     PR_MIN(mContentArea.width, floatAvailableSpace.XMost()),
                    replacedWidth.marginRight) <=
           mContentArea.width) {
         break;
       }
       // See the analogous code for inlines in nsBlockFrame::DoReflowInlineFrames
-      if (mAvailSpaceRect.height > 0) {
+      if (floatAvailableSpace.height > 0) {
         // See if there's room in the next band.
-        newY += mAvailSpaceRect.height;
+        newY += floatAvailableSpace.height;
       } else {
         if (mReflowState.availableHeight != NS_UNCONSTRAINEDSIZE) {
           // Stop trying to clear here; we'll just get pushed to the
           // next column or page and try again there.
           break;
         }
         NS_NOTREACHED("avail space rect with zero height!");
         newY += 1;
       }
     }
-    // Restore mBandHasFloats and mAvailSpaceRect to the way they were.
-    // This may well not be needed, and we should probably come up with
-    // well-defined rules about when these members are valid so that
-    // it's clearly not needed.
-    GetAvailableSpace();
   }
 
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
     printf("clear floats: out: y=%d(%d)\n", newY, newY - bp.top);
   }
 #endif
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -164,24 +164,27 @@ public:
 
   // Reconstruct the previous bottom margin that goes above |aLine|.
   void ReconstructMarginAbove(nsLineList::iterator aLine);
 
   // Caller must have called GetAvailableSpace for the correct position
   // (which need not be the current mY).  Callers need only pass
   // aReplacedWidth for outer table frames.
   void ComputeReplacedBlockOffsetsForFloats(nsIFrame* aFrame,
+                                            const nsRect& aFloatAvailableSpace,
                                             nscoord& aLeftResult,
                                             nscoord& aRightResult,
                                        nsBlockFrame::ReplacedElementWidthToClear
                                                       *aReplacedWidth = nsnull);
 
   // Caller must have called GetAvailableSpace for the current mY
   void ComputeBlockAvailSpace(nsIFrame* aFrame,
                               const nsStyleDisplay* aDisplay,
+                              PRBool aBandHasFloats,
+                              const nsRect& aFloatAvailableSpace,
                               PRBool aBlockAvoidsFloats,
                               nsRect& aResult);
 
 protected:
   void RecoverFloats(nsLineList::iterator aLine, nscoord aDeltaY);
 
 public:
   void RecoverStateFrom(nsLineList::iterator aLine, nscoord aDeltaY);
