From: L. David Baron <dbaron@dbaron.org>

Make nsIFrame::ComputeBorderRadii take an nsSize instead of two nscoords.  (Bug 459144, patch 2)  r=roc  a2.0=blocking:beta6+

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -623,19 +623,18 @@ nsCSSRendering::PaintBorderWithStyleBord
 
   border = aStyleBorder.GetComputedBorder();
   if ((0 == border.left) && (0 == border.right) &&
       (0 == border.top) && (0 == border.bottom)) {
     // Empty border area
     return;
   }
 
-  nsSize frameSize = aForFrame->GetSize();
-  nsIFrame::ComputeBorderRadii(aStyleBorder.mBorderRadius, frameSize.width,
-                               frameSize.height, twipsRadii);
+  nsIFrame::ComputeBorderRadii(aStyleBorder.mBorderRadius,
+                               aForFrame->GetSize(), twipsRadii);
 
   // Turn off rendering for all of the zero sized sides
   if (aSkipSides & SIDE_BIT_TOP) border.top = 0;
   if (aSkipSides & SIDE_BIT_RIGHT) border.right = 0;
   if (aSkipSides & SIDE_BIT_BOTTOM) border.bottom = 0;
   if (aSkipSides & SIDE_BIT_LEFT) border.left = 0;
 
   // get the inside and outside parts of the border
@@ -745,18 +744,18 @@ nsCSSRendering::PaintOutline(nsPresConte
 
   nsIFrame* bgFrame = nsCSSRendering::FindNonTransparentBackgroundFrame
     (aForFrame, PR_FALSE);
   nsStyleContext* bgContext = bgFrame->GetStyleContext();
   nscolor bgColor =
     bgContext->GetVisitedDependentColor(eCSSProperty_background_color);
 
   // get the radius for our outline
-  nsIFrame::ComputeBorderRadii(ourOutline->mOutlineRadius, aBorderArea.width,
-                               aBorderArea.height, twipsRadii);
+  nsIFrame::ComputeBorderRadii(ourOutline->mOutlineRadius, aBorderArea.Size(),
+                               twipsRadii);
 
   // When the outline property is set on :-moz-anonymous-block or
   // :-moz-anonyomus-positioned-block pseudo-elements, it inherited that
   // outline from the inline that was broken because it contained a
   // block.  In that case, we don't want a really wide outline if the
   // block inside the inline is narrow, so union the actual contents of
   // the anonymous blocks.
   nsIFrame *frameForArea = aForFrame;
@@ -1163,17 +1162,17 @@ nsCSSRendering::PaintBoxShadowOuter(nsPr
     hasBorderRadius = PR_FALSE;
     // For opaque (rectangular) theme widgets we can take the generic
     // border-box path with border-radius disabled.
     nativeTheme = transparency != nsITheme::eOpaque;
   } else {
     nativeTheme = PR_FALSE;
     nscoord twipsRadii[8];
     hasBorderRadius = nsIFrame::ComputeBorderRadii(styleBorder->mBorderRadius,
-                        aFrameArea.width, aFrameArea.height, twipsRadii);
+                        aFrameArea.Size(), twipsRadii);
     if (hasBorderRadius) {
       PRIntn sidesToSkip = aForFrame->GetSkipSides();
       ComputePixelRadii(twipsRadii, aFrameArea, sidesToSkip, twipsPerPixel,
                         &borderRadii);
     }
   }
 
   nsRect frameRect =
@@ -1343,18 +1342,18 @@ nsCSSRendering::PaintBoxShadowInner(nsPr
     // inner box-shadows for them. But we allow chrome to paint inner
     // box shadows since chrome can be aware of the platform theme.
     return;
   }
 
   // Get any border radius, since box-shadow must also have rounded corners if the frame does
   nscoord twipsRadii[8];
   PRBool hasBorderRadius = nsIFrame::ComputeBorderRadii(
-                             styleBorder->mBorderRadius, aFrameArea.width,
-                             aFrameArea.height, twipsRadii);
+                             styleBorder->mBorderRadius, aFrameArea.Size(),
+                             twipsRadii);
   nscoord twipsPerPixel = aPresContext->DevPixelsToAppUnits(1);
 
   nsRect paddingRect = aFrameArea;
   nsMargin border = aForFrame->GetUsedBorder();
   aForFrame->ApplySkipSides(border);
   paddingRect.Deflate(border);
 
   gfxCornerSizes innerRadii;
@@ -2235,19 +2234,18 @@ nsCSSRendering::PaintBackgroundWithSC(ns
   gfxContext *ctx = aRenderingContext.ThebesContext();
   nscoord appUnitsPerPixel = aPresContext->AppUnitsPerDevPixel();
 
   // Same coordinate space as aBorderArea & aBGClipRect
   gfxCornerSizes bgRadii;
   PRBool haveRoundedCorners;
   {
     nscoord radii[8];
-    nsSize frameSize = aForFrame->GetSize();
     haveRoundedCorners = nsIFrame::ComputeBorderRadii(aBorder.mBorderRadius,
-                           frameSize.width, frameSize.height, radii);
+                           aForFrame->GetSize(), radii);
     if (haveRoundedCorners)
       ComputePixelRadii(radii, aBorderArea, aForFrame->GetSkipSides(),
                         appUnitsPerPixel, &bgRadii);
   }
 
   // The 'bgClipArea' (used only by the image tiling logic, far below)
   // is the caller-provided aBGClipRect if any, or else the area
   // determined by the value of 'background-clip' in
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -1006,17 +1006,17 @@ nsDisplayBoxShadowOuter::ComputeVisibili
   if (!frameRect.Contains(visibleBounds))
     return PR_TRUE;
 
   // the visible region is entirely inside the border-rect, and box shadows
   // never render within the border-rect (unless there's a border radius).
   nscoord twipsRadii[8];
   PRBool hasBorderRadii = nsIFrame::ComputeBorderRadii(
                             mFrame->GetStyleBorder()->mBorderRadius,
-                            frameRect.width, frameRect.height, twipsRadii);
+                            frameRect.Size(), twipsRadii);
   if (!hasBorderRadii)
     return PR_FALSE;
 
   return !RoundedRectContainsRect(frameRect, twipsRadii, visibleBounds);
 }
 
 void
 nsDisplayBoxShadowInner::Paint(nsDisplayListBuilder* aBuilder,
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -733,26 +733,26 @@ nsIFrame::GetContentRect() const
   ApplySkipSides(bp);
   nsRect r(mRect);
   r.Deflate(bp);
   return r;
 }
 
 PRBool
 nsIFrame::ComputeBorderRadii(const nsStyleCorners& aBorderRadius,
-                             const nscoord aFrameWidth,
-                             const nscoord aFrameHeight,
+                             const nsSize& aFrameSize,
                              nscoord aRadii[8])
 {
   PRBool result = PR_FALSE;
 
   // Percentages are relative to whichever side they're on.
   NS_FOR_CSS_HALF_CORNERS(i) {
     const nsStyleCoord c = aBorderRadius.Get(i);
-    nscoord axis = NS_HALF_CORNER_IS_X(i) ? aFrameWidth : aFrameHeight;
+    nscoord axis =
+      NS_HALF_CORNER_IS_X(i) ? aFrameSize.width : aFrameSize.height;
 
     switch (c.GetUnit()) {
       case eStyleUnit_Percent:
         aRadii[i] = (nscoord)(c.GetPercentValue() * axis);
         break;
 
       case eStyleUnit_Coord:
         aRadii[i] = c.GetCoordValue();
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -919,18 +919,17 @@ public:
   nsRect GetContentRect() const;
 
   /**
    * Get the size, in app units, of the border radii. It returns FALSE iff all
    * returned radii == 0 (so no border radii), TRUE otherwise.
    * For the aRadii indexes, use the NS_CORNER_* constants in nsStyleConsts.h
    */
   static PRBool ComputeBorderRadii(const nsStyleCorners& aBorderRadius,
-                                   const nscoord aFrameWidth,
-                                   const nscoord aFrameHeight,
+                                   const nsSize& aFrameSize,
                                    nscoord aRadii[8]);
 
   /**
    * Get the position of the frame's baseline, relative to the top of
    * the frame (its top border edge).  Only valid when Reflow is not
    * needed and when the frame returned nsHTMLReflowMetrics::
    * ASK_FOR_BASELINE as ascent in its reflow metrics.
    */
