Make SVG foreignObject, rather than its child, be the reflow root, so that the child is not inappropriately reflowed with a constrained height.  b=366956

diff -r 7a281a348267 layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/base/nsCSSFrameConstructor.cpp	Tue Jan 23 17:10:29 2007 -0800
@@ -7337,12 +7337,12 @@ nsCSSFrameConstructor::ConstructSVGFrame
         ResolvePseudoStyleFor(aContent,
                               nsCSSAnonBoxes::mozSVGForeignContent, aStyleContext);
     
-      nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, innerPseudoStyle);
+      nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, innerPseudoStyle,
+                                              NS_BLOCK_SPACE_MGR |
+                                                NS_BLOCK_MARGIN_ROOT);
       if (NS_UNLIKELY(!blockFrame))
         return NS_ERROR_OUT_OF_MEMORY;
     
-      blockFrame->AddStateBits(NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT |
-                               NS_FRAME_REFLOW_ROOT);
       // Claim to be relatively positioned so that we end up being the
       // absolute containing block.
       nsFrameConstructorSaveState saveState;
diff -r 7a281a348267 layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/base/nsPresShell.cpp	Tue Jan 23 17:54:42 2007 -0800
@@ -6046,6 +6046,10 @@ PresShell::ProcessReflowCommands(PRBool 
         else
           size = target->GetSize();
 
+        // XXX This probably shouldn't pass a constrained height, since
+        // that implies pagination.  It should instead pass an
+        // unconstrained height and then fix the resulting computed
+        // height.
         nsHTMLReflowState reflowState(mPresContext, target, rcx, size);
 
         nsReflowStatus status;
@@ -6058,6 +6062,10 @@ PresShell::ProcessReflowCommands(PRBool 
                       desiredSize.height == size.height),
                      "non-root frame's desired size changed during an "
                      "incremental reflow");
+        NS_ASSERTION(desiredSize.mOverflowArea ==
+                       nsRect(nsPoint(0, 0),
+                              nsSize(desiredSize.width, desiredSize.height)),
+                     "reflow roots must not have visible overflow");
 
         target->SetSize(nsSize(desiredSize.width, desiredSize.height));
 
diff -r 7a281a348267 layout/generic/nsViewportFrame.cpp
--- a/layout/generic/nsViewportFrame.cpp	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/generic/nsViewportFrame.cpp	Tue Jan 23 17:52:01 2007 -0800
@@ -330,6 +330,10 @@ ViewportFrame::Reflow(nsPresContext*    
     Invalidate(damageRect, PR_FALSE);
   }
 
+  // XXX Should we do something to clip our children to this?
+  aDesiredSize.mOverflowArea =
+    nsRect(nsPoint(0, 0), nsSize(aDesiredSize.width, aDesiredSize.height));
+
   NS_FRAME_TRACE_REFLOW_OUT("ViewportFrame::Reflow", aStatus);
   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
   return rv; 
diff -r 7a281a348267 layout/svg/base/src/nsSVGForeignObjectFrame.cpp
--- a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp	Tue Jan 23 17:35:55 2007 -0800
@@ -82,6 +82,7 @@ nsSVGForeignObjectFrame::nsSVGForeignObj
   : nsSVGForeignObjectFrameBase(aContext),
     mPropagateTransform(PR_TRUE), mInReflow(PR_FALSE)
 {
+  AddStateBits(NS_FRAME_REFLOW_ROOT);
 }
 
 //----------------------------------------------------------------------
@@ -142,6 +143,33 @@ nsSVGForeignObjectFrame::DidSetStyleCont
   nsSVGUtils::StyleEffects(this);
   return NS_OK;
 }
+
+NS_IMETHODIMP
+nsSVGForeignObjectFrame::Reflow(nsPresContext*           aPresContext,
+                                nsHTMLReflowMetrics&     aDesiredSize,
+                                const nsHTMLReflowState& aReflowState,
+                                nsReflowStatus&          aStatus)
+{
+  NS_ASSERTION(!aReflowState.parentReflowState,
+               "should only get reflow from being reflow root");
+  NS_ASSERTION(aReflowState.availableWidth == GetSize().width &&
+               aReflowState.availableHeight == GetSize().height,
+               "reflow roots should be reflown at existing size");
+  NS_ASSERTION(aReflowState.mComputedWidth == GetSize().width &&
+               aReflowState.mComputedHeight == GetSize().height,
+               "svg.css should ensure we have no padding/border/margin");
+
+  DoReflow();
+
+  aDesiredSize.width = aReflowState.availableWidth;
+  aDesiredSize.height = aReflowState.availableHeight;
+  aDesiredSize.mOverflowArea =
+    nsRect(nsPoint(0, 0), nsSize(aDesiredSize.width, aDesiredSize.height));
+  aStatus = NS_FRAME_COMPLETE;
+
+  return NS_OK;
+}
+
 
 //----------------------------------------------------------------------
 // nsISVGValueObserver methods:
@@ -517,11 +545,19 @@ nsSVGForeignObjectFrame::DoReflow()
 
   mInReflow = PR_TRUE;
 
-  // create a new reflow state, setting our max size to (width,height):
   nsHTMLReflowState reflowState(presContext, kid,
-                                renderingContext, size);
+                                renderingContext,
+                                nsSize(size.width, NS_UNCONSTRAINEDSIZE));
   nsHTMLReflowMetrics desiredSize;
   nsReflowStatus status;
+
+  // We don't use size.height above because that tells the child to do
+  // page/column breaking at that height.
+  // The style system ensures that our :-moz-svg-foreign-content child
+  // has no padding, border, or margin.
+  NS_ASSERTION(reflowState.mComputedWidth == size.width,
+               "reflow state made child wrong size");
+  reflowState.mComputedHeight = size.width;
   
   ReflowChild(kid, presContext, desiredSize, reflowState, 0, 0,
               NS_FRAME_NO_MOVE_FRAME, status);
diff -r 7a281a348267 layout/svg/base/src/nsSVGForeignObjectFrame.h
--- a/layout/svg/base/src/nsSVGForeignObjectFrame.h	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/svg/base/src/nsSVGForeignObjectFrame.h	Tue Jan 23 17:12:25 2007 -0800
@@ -79,6 +79,11 @@ public:
 
   NS_IMETHOD DidSetStyleContext();
 
+  NS_IMETHOD Reflow(nsPresContext*           aPresContext,
+                    nsHTMLReflowMetrics&     aDesiredSize,
+                    const nsHTMLReflowState& aReflowState,
+                    nsReflowStatus&          aStatus);
+
   /**
    * Get the "type" of the frame
    *
diff -r 7a281a348267 layout/svg/base/src/nsSVGOuterSVGFrame.cpp
--- a/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	Tue Jan 23 17:18:39 2007 -0800
@@ -712,6 +712,7 @@ nsSVGOuterSVGFrame::CalculateAvailableSp
   // http://annevankesteren.nl/test/cdf/cdi/002.html
   *preferredRect = aPresContext->GetVisibleArea();
   
+  // XXXldb What about margin?
   if (aReflowState.availableWidth != NS_INTRINSICSIZE)
     maxRect->width = aReflowState.availableWidth;
   else if (aReflowState.parentReflowState &&
diff -r 7a281a348267 layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/xul/base/src/nsBoxFrame.cpp	Tue Jan 23 17:49:28 2007 -0800
@@ -806,6 +806,8 @@ nsBoxFrame::Reflow(nsPresContext*       
     nsRect* overflowArea = GetOverflowAreaProperty();
     NS_ASSERTION(overflowArea, "Failed to set overflow area property");
     aDesiredSize.mOverflowArea = *overflowArea;
+  } else {
+    aDesiredSize.mOverflowArea = nsRect(nsPoint(0, 0), GetSize());
   }
 
 #ifdef DO_NOISY_REFLOW
diff -r 7a281a348267 layout/xul/base/src/nsLeafBoxFrame.cpp
--- a/layout/xul/base/src/nsLeafBoxFrame.cpp	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/xul/base/src/nsLeafBoxFrame.cpp	Tue Jan 23 17:52:57 2007 -0800
@@ -358,6 +358,8 @@ nsLeafBoxFrame::Reflow(nsPresContext*   
     nsRect* overflowArea = GetOverflowAreaProperty();
     NS_ASSERTION(overflowArea, "Failed to set overflow area property");
     aDesiredSize.mOverflowArea = *overflowArea;
+  } else {
+    aDesiredSize.mOverflowArea = nsRect(nsPoint(0, 0), GetSize());
   }
 
 #ifdef DO_NOISY_REFLOW
