Reflow reflow roots and the child of SVG foreignObject with an unconstrained height to avoid triggering page/column breaking.  b=366956

diff -r 7a281a348267 layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/base/nsCSSFrameConstructor.cpp	Tue Jan 23 18:15:11 2007 -0800
@@ -7337,12 +7337,13 @@ nsCSSFrameConstructor::ConstructSVGFrame
         ResolvePseudoStyleFor(aContent,
                               nsCSSAnonBoxes::mozSVGForeignContent, aStyleContext);
     
-      nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, innerPseudoStyle);
+      nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, innerPseudoStyle,
+                                              NS_BLOCK_SPACE_MGR |
+                                                NS_BLOCK_MARGIN_ROOT |
+                                                NS_FRAME_REFLOW_ROOT);
       if (NS_UNLIKELY(!blockFrame))
         return NS_ERROR_OUT_OF_MEMORY;
     
-      blockFrame->AddStateBits(NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT |
-                               NS_FRAME_REFLOW_ROOT);
       // Claim to be relatively positioned so that we end up being the
       // absolute containing block.
       nsFrameConstructorSaveState saveState;
diff -r 7a281a348267 layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/base/nsPresShell.cpp	Tue Jan 23 18:31:55 2007 -0800
@@ -6046,7 +6046,27 @@ PresShell::ProcessReflowCommands(PRBool 
         else
           size = target->GetSize();
 
-        nsHTMLReflowState reflowState(mPresContext, target, rcx, size);
+        NS_ASSERTION(!target->GetNextInFlow() && !target->GetPrevInFlow(),
+                     "reflow roots should never split");
+
+        // Don't pass size directly to the reflow state, since a
+        // constrained height implies page/column breaking.
+        nsHTMLReflowState reflowState(mPresContext, target, rcx,
+                                      nsSize(size.width, NS_UNCONSTRAINEDSIZE));
+        
+        // fix the computed height
+        NS_ASSERTION(reflowState.mComputedMargin == nsMargin(0, 0, 0, 0),
+                     "reflow state should not set margin for reflow roots");
+        reflowState.mComputedHeight =
+          size.height - reflowState.mComputedBorderPadding.TopBottom();
+        NS_ASSERTION(reflowState.mComputedWidth ==
+                       size.width -
+                         reflowState.mComputedBorderPadding.LeftRight(),
+                     "reflow state computed incorrect width");
+
+        // except the viewport frame does want availableHeight set
+        if (target == root)
+          reflowState.availableHeight = size.height;
 
         nsReflowStatus status;
         target->Reflow(mPresContext, desiredSize, reflowState, status);
@@ -6058,6 +6078,12 @@ PresShell::ProcessReflowCommands(PRBool 
                       desiredSize.height == size.height),
                      "non-root frame's desired size changed during an "
                      "incremental reflow");
+        NS_ASSERTION(desiredSize.mOverflowArea ==
+                       nsRect(nsPoint(0, 0),
+                              nsSize(desiredSize.width, desiredSize.height)),
+                     "reflow roots must not have visible overflow");
+        NS_ASSERTION(status == NS_FRAME_COMPLETE,
+                     "reflow roots should never split");
 
         target->SetSize(nsSize(desiredSize.width, desiredSize.height));
 
diff -r 7a281a348267 layout/generic/nsViewportFrame.cpp
--- a/layout/generic/nsViewportFrame.cpp	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/generic/nsViewportFrame.cpp	Tue Jan 23 17:52:01 2007 -0800
@@ -330,6 +330,10 @@ ViewportFrame::Reflow(nsPresContext*    
     Invalidate(damageRect, PR_FALSE);
   }
 
+  // XXX Should we do something to clip our children to this?
+  aDesiredSize.mOverflowArea =
+    nsRect(nsPoint(0, 0), nsSize(aDesiredSize.width, aDesiredSize.height));
+
   NS_FRAME_TRACE_REFLOW_OUT("ViewportFrame::Reflow", aStatus);
   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
   return rv; 
diff -r 7a281a348267 layout/svg/base/src/nsSVGForeignObjectFrame.cpp
--- a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp	Tue Jan 23 18:30:43 2007 -0800
@@ -517,11 +517,21 @@ nsSVGForeignObjectFrame::DoReflow()
 
   mInReflow = PR_TRUE;
 
-  // create a new reflow state, setting our max size to (width,height):
   nsHTMLReflowState reflowState(presContext, kid,
-                                renderingContext, size);
+                                renderingContext,
+                                nsSize(size.width, NS_UNCONSTRAINEDSIZE));
   nsHTMLReflowMetrics desiredSize;
   nsReflowStatus status;
+
+  // We don't use size.height above because that tells the child to do
+  // page/column breaking at that height.
+  NS_ASSERTION(reflowState.mComputedBorderPadding == nsMargin(0, 0, 0, 0) &&
+               reflowState.mComputedMargin == nsMargin(0, 0, 0, 0),
+               "style system should ensure that :-moz-svg-foreign content "
+               "does not get styled");
+  NS_ASSERTION(reflowState.mComputedWidth == size.width,
+               "reflow state made child wrong size");
+  reflowState.mComputedHeight = size.width;
   
   ReflowChild(kid, presContext, desiredSize, reflowState, 0, 0,
               NS_FRAME_NO_MOVE_FRAME, status);
diff -r 7a281a348267 layout/svg/base/src/nsSVGOuterSVGFrame.cpp
--- a/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	Tue Jan 23 17:18:39 2007 -0800
@@ -712,6 +712,7 @@ nsSVGOuterSVGFrame::CalculateAvailableSp
   // http://annevankesteren.nl/test/cdf/cdi/002.html
   *preferredRect = aPresContext->GetVisibleArea();
   
+  // XXXldb What about margin?
   if (aReflowState.availableWidth != NS_INTRINSICSIZE)
     maxRect->width = aReflowState.availableWidth;
   else if (aReflowState.parentReflowState &&
diff -r 7a281a348267 layout/svg/base/src/svg.css
--- a/layout/svg/base/src/svg.css	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/svg/base/src/svg.css	Tue Jan 23 18:16:06 2007 -0800
@@ -72,4 +72,6 @@ foreignObject {
 *|*::-moz-svg-foreign-content {
   display: block !important;
   position: static !important;
+  /* so we don't report overflow that confuses the reflow root code */
+  overflow: -moz-hidden-unscrollable ! important;
 }
diff -r 7a281a348267 layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/xul/base/src/nsBoxFrame.cpp	Tue Jan 23 17:49:28 2007 -0800
@@ -806,6 +806,8 @@ nsBoxFrame::Reflow(nsPresContext*       
     nsRect* overflowArea = GetOverflowAreaProperty();
     NS_ASSERTION(overflowArea, "Failed to set overflow area property");
     aDesiredSize.mOverflowArea = *overflowArea;
+  } else {
+    aDesiredSize.mOverflowArea = nsRect(nsPoint(0, 0), GetSize());
   }
 
 #ifdef DO_NOISY_REFLOW
diff -r 7a281a348267 layout/xul/base/src/nsLeafBoxFrame.cpp
--- a/layout/xul/base/src/nsLeafBoxFrame.cpp	Tue Jan 23 15:03:56 2007 -0800
+++ b/layout/xul/base/src/nsLeafBoxFrame.cpp	Tue Jan 23 17:52:57 2007 -0800
@@ -358,6 +358,8 @@ nsLeafBoxFrame::Reflow(nsPresContext*   
     nsRect* overflowArea = GetOverflowAreaProperty();
     NS_ASSERTION(overflowArea, "Failed to set overflow area property");
     aDesiredSize.mOverflowArea = *overflowArea;
+  } else {
+    aDesiredSize.mOverflowArea = nsRect(nsPoint(0, 0), GetSize());
   }
 
 #ifdef DO_NOISY_REFLOW
