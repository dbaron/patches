From: L. David Baron <dbaron@dbaron.org>

Rename PushTruncatedPlaceholderLine since the remaining reasons for lines being truncated are related to being next to floats, not having truncated floats.  (Bug 563584)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -3419,24 +3419,20 @@ nsBlockFrame::ReflowInlineFrames(nsBlock
         allowPullUp = PR_FALSE;
       } while (LINE_REFLOW_REDO_NO_PULL == lineReflowStatus);
     } while (LINE_REFLOW_REDO_MORE_FLOATS == lineReflowStatus);
   } while (LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus);
 
   return rv;
 }
 
-// If at least one float on the line was complete, not at the top of
-// page, but was truncated, then restore the overflow floats to what
-// they were before and push the line.  The floats that will be removed
-// from the list aren't yet known by the block's next in flow.  
 void
-nsBlockFrame::PushTruncatedPlaceholderLine(nsBlockReflowState& aState,
-                                           line_iterator       aLine,
-                                           PRBool&             aKeepReflowGoing)
+nsBlockFrame::PushTruncatedLine(nsBlockReflowState& aState,
+                                line_iterator       aLine,
+                                PRBool&             aKeepReflowGoing)
 {
   line_iterator prevLine = aLine;
   --prevLine;
   PushLines(aState, prevLine);
   aKeepReflowGoing = PR_FALSE;
   NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
 }
 
@@ -3640,17 +3636,17 @@ nsBlockFrame::DoReflowInlineFrames(nsBlo
         aState.mFloatManager->AssertStateMatches(aFloatStateBeforeLine);
         aFloatAvailableSpace = aState.GetFloatAvailableSpace();
       } else {
         // There's nowhere to retry placing the line, so we want to push
         // it to the next page/column where its contents can fit not
         // next to a float.
         lineReflowStatus = LINE_REFLOW_TRUNCATED;
         // Push the line that didn't fit
-        PushTruncatedPlaceholderLine(aState, aLine, *aKeepReflowGoing);
+        PushTruncatedLine(aState, aLine, *aKeepReflowGoing);
       }
     }
 
     // XXX: a small optimization can be done here when paginating:
     // if the new Y coordinate is past the end of the block then
     // push the line and return now instead of later on after we are
     // past the float.
   }
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -619,21 +619,21 @@ protected:
    * @param aMadeNewFrame PR_TRUE if a new frame was created, PR_FALSE if not
    * @return NS_OK if a next-in-flow already exists or is successfully created
    */
   virtual nsresult CreateContinuationFor(nsBlockReflowState& aState,
                                          nsLineBox*          aLine,
                                          nsIFrame*           aFrame,
                                          PRBool&             aMadeNewFrame);
 
-  // Push aLine which contains a positioned element that was truncated. Clean up any 
-  // placeholders on the same line that were continued. Set aKeepReflowGoing to false. 
-  void PushTruncatedPlaceholderLine(nsBlockReflowState& aState,
-                                    line_iterator       aLine,
-                                    PRBool&             aKeepReflowGoing);
+  // Push aLine, which cannot be placed on this page/column but should
+  // fit on a future one.  Set aKeepReflowGoing to false.
+  void PushTruncatedLine(nsBlockReflowState& aState,
+                         line_iterator       aLine,
+                         PRBool&             aKeepReflowGoing);
 
   nsresult SplitLine(nsBlockReflowState& aState,
                      nsLineLayout& aLineLayout,
                      line_iterator aLine,
                      nsIFrame* aFrame,
                      LineReflowStatus* aLineReflowStatus);
 
   /**
