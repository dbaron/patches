From: L. David Baron <dbaron@dbaron.org>

DbgHelp thread-safety fixes.

diff --git a/xpcom/base/nsStackWalk.cpp b/xpcom/base/nsStackWalk.cpp
--- a/xpcom/base/nsStackWalk.cpp
+++ b/xpcom/base/nsStackWalk.cpp
@@ -255,16 +255,17 @@ void PrintError(const char *prefix)
     LocalFree(lpMsgBuf);
 }
 
 bool
 EnsureImageHlpInitialized()
 {
     static bool gInitialized = false;
 
+    // XXX Not threadsafe.
     if (gInitialized)
         return gInitialized;
 
     // Hope that our first call doesn't happen during static
     // initialization.  If it does, this CreateThread call won't
     // actually start the thread until after the static initialization
     // is done, which means we'll deadlock while waiting for it to
     // process a stack.
@@ -698,26 +699,29 @@ BOOL SymGetModuleInfoEspecial64(HANDLE a
 }
 
 bool
 EnsureSymInitialized()
 {
     static bool gInitialized = false;
     bool retStat;
 
+    // XXX Not threadsafe.
     if (gInitialized)
         return gInitialized;
 
     if (!EnsureImageHlpInitialized())
         return false;
 
+    EnterCriticalSection(&gDbgHelpCS);
     SymSetOptions(SYMOPT_LOAD_LINES | SYMOPT_UNDNAME);
     retStat = SymInitialize(GetCurrentProcess(), NULL, TRUE);
     if (!retStat)
         PrintError("SymInitialize");
+    LeaveCriticalSection(&gDbgHelpCS);
 
     gInitialized = retStat;
     /* XXX At some point we need to arrange to call SymCleanup */
 
     return retStat;
 }
 
 
