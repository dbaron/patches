From: L. David Baron <dbaron@dbaron.org>

DbgHelp thread-safety fixes.

diff --git a/xpcom/base/nsStackWalk.cpp b/xpcom/base/nsStackWalk.cpp
--- a/xpcom/base/nsStackWalk.cpp
+++ b/xpcom/base/nsStackWalk.cpp
@@ -299,16 +299,17 @@ void PrintError(char *prefix)
     LocalFree( lpMsgBuf );
 }
 
 bool
 EnsureImageHlpInitialized()
 {
     static bool gInitialized = false;
 
+    // XXX Not threadsafe.
     if (gInitialized)
         return gInitialized;
 
     // Hope that our first call doesn't happen during static
     // initialization.  If it does, this CreateThread call won't
     // actually start the thread until after the static initialization
     // is done, which means we'll deadlock while waiting for it to
     // process a stack.
@@ -940,28 +941,31 @@ GetCurrentPIDorHandle()
 }
 
 bool
 EnsureSymInitialized()
 {
     static bool gInitialized = false;
     bool retStat;
 
+    // XXX Not threadsafe.
     if (gInitialized)
         return gInitialized;
 
     NS_TIME_FUNCTION;
 
     if (!EnsureImageHlpInitialized())
         return PR_FALSE;
 
+    EnterCriticalSection(&gDbgHelpCS);
     _SymSetOptions(SYMOPT_LOAD_LINES | SYMOPT_UNDNAME);
     retStat = _SymInitialize(GetCurrentPIDorHandle(), NULL, TRUE);
     if (!retStat)
         PrintError("SymInitialize");
+    LeaveCriticalSection(&gDbgHelpCS);
 
     gInitialized = retStat;
     /* XXX At some point we need to arrange to call _SymCleanup */
 
     return retStat;
 }
 
 
