From: L. David Baron <dbaron@dbaron.org>

Bug 1125455 patch 1 - Add boolean for whether an animation of a property wins in the CSS cascade.

diff --git a/dom/animation/Animation.h b/dom/animation/Animation.h
--- a/dom/animation/Animation.h
+++ b/dom/animation/Animation.h
@@ -116,16 +116,30 @@ struct AnimationPropertySegment
   float mFromKey, mToKey;
   StyleAnimationValue mFromValue, mToValue;
   ComputedTimingFunction mTimingFunction;
 };
 
 struct AnimationProperty
 {
   nsCSSProperty mProperty;
+
+  // Does this property win in the CSS Cascade?
+  //
+  // For CSS transitions, this is true as long as a CSS animation on the
+  // same property and element is not running, in which case we set this
+  // to false so that the animation (lower in the cascade) can win.  We
+  // then use this to decide whether to apply the style both in the CSS
+  // cascade and for OMTA.
+  //
+  // FIXME (bug 847287): For CSS Animations, which are overridden by
+  // !important rules in the cascade, we actually determine this from
+  // the CSS cascade computations, and then use it for OMTA.
+  bool mWinsInCascade;
+
   InfallibleTArray<AnimationPropertySegment> mSegments;
 };
 
 struct ElementPropertyTransition;
 
 namespace dom {
 
 class AnimationEffect;
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -569,16 +569,17 @@ nsAnimationManager::BuildAnimations(nsSt
         } else {
           keyframesWithProperty.AppendElement(kfIdx);
         }
         lastKey = kf.mKey;
       }
 
       AnimationProperty &propData = *destAnim->Properties().AppendElement();
       propData.mProperty = prop;
+      propData.mWinsInCascade = true;
 
       KeyframeData *fromKeyframe = nullptr;
       nsRefPtr<nsStyleContext> fromContext;
       bool interpolated = true;
       for (uint32_t wpIdx = 0, wpEnd = keyframesWithProperty.Length();
            wpIdx != wpEnd; ++wpIdx) {
         uint32_t kfIdx = keyframesWithProperty[wpIdx];
         KeyframeData &toKeyframe = sortedKeyframes[kfIdx];
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -537,16 +537,17 @@ nsTransitionManager::ConsiderStartingTra
   nsRefPtr<ElementPropertyTransition> pt =
     new ElementPropertyTransition(aElement->OwnerDoc(), aElement,
                                   aNewStyleContext->GetPseudoType(), timing);
   pt->mStartForReversingTest = startForReversingTest;
   pt->mReversePortion = reversePortion;
 
   AnimationProperty& prop = *pt->Properties().AppendElement();
   prop.mProperty = aProperty;
+  prop.mWinsInCascade = true;
 
   AnimationPropertySegment& segment = *prop.mSegments.AppendElement();
   segment.mFromValue = startValue;
   segment.mToValue = endValue;
   segment.mFromKey = 0;
   segment.mToKey = 1;
   segment.mTimingFunction.Init(tf);
 
