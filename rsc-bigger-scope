From: L. David Baron <dbaron@dbaron.org>

Bug 1110277 patch 6 - Make the lifetime of the ReframingStyleContexts object longer.

This makes the ReframingStyleContexts live across the lifetime of the
processing of a full queue of posted restyles.

(It isn't really quite perfect in the case of RebuildAllStyleData,
though, as noted in the FIXME.)

This handles the form of lazy frame construction that is done in
nsCSSFrameConstructor::RecreateFramesForContent, which posts a restyle.
Patch 7 handles any use of the lazy frame construction mechanism.

This patch (with patches 4 and 5 under it, but without patches 1-3)
fixes the original testcase in bug 1110277, except for some flashing of
the final position as the transition starts.

Also fixes bug 1111451.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -923,16 +923,17 @@ RestyleManager::ProcessRestyledFrames(ns
 
 void
 RestyleManager::RestyleElement(Element*        aElement,
                                nsIFrame*       aPrimaryFrame,
                                nsChangeHint    aMinHint,
                                RestyleTracker& aRestyleTracker,
                                nsRestyleHint   aRestyleHint)
 {
+  MOZ_ASSERT(mReframingStyleContexts, "should have rsc");
   NS_ASSERTION(aPrimaryFrame == aElement->GetPrimaryFrame(),
                "frame/content mismatch");
   if (aPrimaryFrame && aPrimaryFrame->GetContent() != aElement) {
     // XXXbz this is due to image maps messing with the primary frame pointer
     // of <area>s.  See bug 135040.  We can remove this block once that's fixed.
     aPrimaryFrame = nullptr;
   }
   NS_ASSERTION(!aPrimaryFrame || aPrimaryFrame->GetContent() == aElement,
@@ -1520,17 +1521,28 @@ RestyleManager::RebuildAllStyleData(nsCh
   // animation restyles so that we restyle those elements again in the
   // animation phase.  Furthermore, we need to add
   // eRestyle_ChangeAnimationPhaseDescendants so that we actually honor
   // these booleans in all cases.
   mSkipAnimationRules = true;
   mPostAnimationRestyles = true;
   aRestyleHint |= eRestyle_ChangeAnimationPhaseDescendants;
 
-  DoRebuildAllStyleData(mPendingRestyles, aExtraHint, aRestyleHint);
+  {
+    // Create a ReframingStyleContexts struct on the stack and put it in
+    // our mReframingStyleContexts within this scope.
+    // FIXME: We should really use the same reframingStyleContexts
+    // object here and in the ProcessPendingRestyles below.  Without
+    // that, we'll have variants of bug 1110277 still present when a
+    // rebuild-all is triggered simultaneously with a change of the form
+    // that triggered that bug.
+    ReframingStyleContexts reframingStyleContexts(this);
+
+    DoRebuildAllStyleData(mPendingRestyles, aExtraHint, aRestyleHint);
+  }
 
   mPostAnimationRestyles = false;
   mSkipAnimationRules = false;
 #ifdef DEBUG
   mIsProcessingRestyles = false;
 #endif
 
   // Make sure that we process any pending animation restyles from the
@@ -3897,37 +3909,31 @@ ElementRestyler::SendAccessibilityNotifi
 }
 
 void
 RestyleManager::ComputeAndProcessStyleChange(nsIFrame*          aFrame,
                                              nsChangeHint       aMinChange,
                                              RestyleTracker&    aRestyleTracker,
                                              nsRestyleHint      aRestyleHint)
 {
-  // Create a ReframingStyleContexts struct on the stack and put it in
-  // our mReframingStyleContexts for the scope of this function.
-  ReframingStyleContexts reframingStyleContexts(this);
-
+  MOZ_ASSERT(mReframingStyleContexts, "should have rsc");
   nsStyleChangeList changeList;
   ElementRestyler::ComputeStyleChangeFor(aFrame, &changeList, aMinChange,
                                          aRestyleTracker, aRestyleHint);
   ProcessRestyledFrames(changeList);
 }
 
 void
 RestyleManager::ComputeAndProcessStyleChange(nsStyleContext*    aNewContext,
                                              Element*           aElement,
                                              nsChangeHint       aMinChange,
                                              RestyleTracker&    aRestyleTracker,
                                              nsRestyleHint      aRestyleHint)
 {
-  // Create a ReframingStyleContexts struct on the stack and put it in
-  // our mReframingStyleContexts for the scope of this function.
-  ReframingStyleContexts reframingStyleContexts(this);
-
+  MOZ_ASSERT(mReframingStyleContexts, "should have rsc");
   MOZ_ASSERT(aNewContext->StyleDisplay()->mDisplay == NS_STYLE_DISPLAY_CONTENTS);
   nsIFrame* frame = GetNearestAncestorFrame(aElement);
   MOZ_ASSERT(frame, "display:contents node in map although it's a "
                     "display:none descendant?");
   TreeMatchContext treeMatchContext(true,
                                     nsRuleWalker::eRelevantLinkUnvisited,
                                     frame->PresContext()->Document());
   nsIContent* parent = aElement->GetParent();
diff --git a/layout/base/RestyleTracker.cpp b/layout/base/RestyleTracker.cpp
--- a/layout/base/RestyleTracker.cpp
+++ b/layout/base/RestyleTracker.cpp
@@ -187,16 +187,21 @@ RestyleTracker::ProcessOneRestyle(Elemen
     changeList.AppendChange(primaryFrame, aElement, aChangeHint);
     mRestyleManager->ProcessRestyledFrames(changeList);
   }
 }
 
 void
 RestyleTracker::DoProcessRestyles()
 {
+  // Create a ReframingStyleContexts struct on the stack and put it in our
+  // mReframingStyleContexts for the remaining scope of this function.
+  RestyleManager::ReframingStyleContexts
+    reframingStyleContexts(mRestyleManager);
+
   PROFILER_LABEL("RestyleTracker", "ProcessRestyles",
     js::ProfileEntry::Category::CSS);
 
   mRestyleManager->BeginProcessingRestyles();
 
   LOG_RESTYLE("Processing %d pending %srestyles with %d restyle roots for %s",
               mPendingRestyles.Count(),
               mRestyleManager->IsProcessingAnimationStyleChange()
