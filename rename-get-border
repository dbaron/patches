From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::GetBorder to GetXULBorder.

This is a manual subset of changes written with sed, over .h and .cpp
files in layout/.

It also includes manual changes in accessible/.

MozReview-Commit-ID: D1nwxJmUzc9

diff --git a/accessible/html/HTMLTableAccessible.cpp b/accessible/html/HTMLTableAccessible.cpp
--- a/accessible/html/HTMLTableAccessible.cpp
+++ b/accessible/html/HTMLTableAccessible.cpp
@@ -1051,17 +1051,17 @@ HTMLTableAccessible::IsProbablyLayoutTab
   if (!tableFrame)
     RETURN_LAYOUT_ANSWER(false, "table with no frame!");
 
   nsIFrame* cellFrame = tableFrame->GetCellFrameAt(0, 0);
   if (!cellFrame)
     RETURN_LAYOUT_ANSWER(false, "table's first cell has no frame!");
 
   nsMargin border;
-  cellFrame->GetBorder(border);
+  cellFrame->GetXULBorder(border);
   if (border.top && border.bottom && border.left && border.right) {
     RETURN_LAYOUT_ANSWER(false, "Has nonzero border-width on table cell");
   }
 
   /**
    * Rules for non-bordered tables with 2-4 columns and 2+ rows from here on forward
    */
 
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -8985,17 +8985,17 @@ nsFrame::BoxReflow(nsBoxLayoutState&    
     // This may not do very much useful, but it's probably worth trying.
     if (parentSize.width != NS_INTRINSICSIZE)
       parentReflowState.SetComputedWidth(std::max(parentSize.width, 0));
     if (parentSize.height != NS_INTRINSICSIZE)
       parentReflowState.SetComputedHeight(std::max(parentSize.height, 0));
     parentReflowState.ComputedPhysicalMargin().SizeTo(0, 0, 0, 0);
     // XXX use box methods
     parentFrame->GetPadding(parentReflowState.ComputedPhysicalPadding());
-    parentFrame->GetBorder(parentReflowState.ComputedPhysicalBorderPadding());
+    parentFrame->GetXULBorder(parentReflowState.ComputedPhysicalBorderPadding());
     parentReflowState.ComputedPhysicalBorderPadding() +=
       parentReflowState.ComputedPhysicalPadding();
 
     // Construct the parent chain manually since constructing it normally
     // messes up dimensions.
     const nsHTMLReflowState *outerReflowState = aState.OuterReflowState();
     NS_ASSERTION(!outerReflowState || outerReflowState->frame != this,
                  "in and out of XUL on a single frame?");
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2907,17 +2907,17 @@ public:
   // box. You can pass true to aRemoveOverflowArea as a
   // convenience.
   virtual void SetXULBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
                             bool aRemoveOverflowAreas = false) = 0;
   nsresult XULLayout(nsBoxLayoutState& aBoxLayoutState);
   // Box methods.  Note that these do NOT just get the CSS border, padding,
   // etc.  They also talk to nsITheme.
   virtual nsresult GetXULBorderAndPadding(nsMargin& aBorderAndPadding);
-  virtual nsresult GetBorder(nsMargin& aBorder)=0;
+  virtual nsresult GetXULBorder(nsMargin& aBorder)=0;
   virtual nsresult GetPadding(nsMargin& aBorderAndPadding)=0;
   virtual nsresult GetMargin(nsMargin& aMargin)=0;
   virtual void SetLayoutManager(nsBoxLayout* aLayout) { }
   virtual nsBoxLayout* GetLayoutManager() { return nullptr; }
   nsresult GetClientRect(nsRect& aContentRect);
 
   // For nsSprocketLayout
   virtual Valignment GetVAlign() const = 0;
diff --git a/layout/xul/grid/nsGrid.cpp b/layout/xul/grid/nsGrid.cpp
--- a/layout/xul/grid/nsGrid.cpp
+++ b/layout/xul/grid/nsGrid.cpp
@@ -652,17 +652,17 @@ nsGrid::GetRowOffsets(int32_t aIndex, ns
   // borders padding into account
   if (box && !row->mIsBogus)
   {
     if (!box->IsXULCollapsed())
     {
        // get real border and padding. GetXULBorderAndPadding
        // is redefined on nsGridRowLeafFrame. If we called it here
        // we would be in finite recurson.
-       box->GetBorder(border);
+       box->GetXULBorder(border);
        box->GetPadding(padding);
 
        totalBorderPadding += border;
        totalBorderPadding += padding;
      }
 
      // if we are the first or last row
      // take into account <rows> tags around us
@@ -721,17 +721,17 @@ nsGrid::GetRowOffsets(int32_t aIndex, ns
         {
            // include the margin of the columns. To the row
            // at this point border/padding and margins all added
            // up to more needed space.
            margin = GetBoxTotalMargin(box, !aIsHorizontal);
            // get real border and padding. GetXULBorderAndPadding
            // is redefined on nsGridRowLeafFrame. If we called it here
            // we would be in finite recurson.
-           box->GetBorder(border);
+           box->GetXULBorder(border);
            box->GetPadding(padding);
            totalChildBorderPadding += border;
            totalChildBorderPadding += padding;
            totalChildBorderPadding += margin;
         }
 
         nscoord top;
         nscoord bottom;
diff --git a/layout/xul/grid/nsGridRowLeafLayout.cpp b/layout/xul/grid/nsGridRowLeafLayout.cpp
--- a/layout/xul/grid/nsGridRowLeafLayout.cpp
+++ b/layout/xul/grid/nsGridRowLeafLayout.cpp
@@ -154,17 +154,17 @@ nsGridRowLeafLayout::PopulateBoxSizes(ns
       nsGridRow* lastRow = nullptr;
       grid->GetFirstAndLastRow(firstIndex, lastIndex, firstRow, lastRow, !isHorizontal);
 
       if (i == firstIndex || i == lastIndex) {
         nsMargin offset = GetTotalMargin(aBox, isHorizontal);
 
         nsMargin border(0,0,0,0);
         // can't call GetBorderPadding we will get into recursion
-        aBox->GetBorder(border);
+        aBox->GetXULBorder(border);
         offset += border;
         aBox->GetPadding(border);
         offset += border;
 
         // subtract from out left and right
         if (i == firstIndex) 
         {
           if (isHorizontal)
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -282,32 +282,32 @@ nsBox::GetLayoutFlags(uint32_t& aFlags)
   aFlags = 0;
 }
 
 
 nsresult
 nsIFrame::GetXULBorderAndPadding(nsMargin& aBorderAndPadding)
 {
   aBorderAndPadding.SizeTo(0, 0, 0, 0);
-  nsresult rv = GetBorder(aBorderAndPadding);
+  nsresult rv = GetXULBorder(aBorderAndPadding);
   if (NS_FAILED(rv))
     return rv;
 
   nsMargin padding;
   rv = GetPadding(padding);
   if (NS_FAILED(rv))
     return rv;
 
   aBorderAndPadding += padding;
 
   return rv;
 }
 
 nsresult
-nsBox::GetBorder(nsMargin& aMargin)
+nsBox::GetXULBorder(nsMargin& aMargin)
 {
   aMargin.SizeTo(0,0,0,0);
     
   const nsStyleDisplay* disp = StyleDisplay();
   if (disp->mAppearance && gTheme) {
     // Go to the theme for the border.
     nsPresContext *context = PresContext();
     if (gTheme->ThemeSupportsWidget(context, this, disp->mAppearance)) {
diff --git a/layout/xul/nsBox.h b/layout/xul/nsBox.h
--- a/layout/xul/nsBox.h
+++ b/layout/xul/nsBox.h
@@ -27,17 +27,17 @@ public:
 
   virtual nsSize GetXULMinSizeForScrollArea(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual bool IsXULCollapsed() override;
 
   virtual void SetXULBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
                             bool aRemoveOverflowAreas = false) override;
 
-  virtual nsresult GetBorder(nsMargin& aBorderAndPadding) override;
+  virtual nsresult GetXULBorder(nsMargin& aBorderAndPadding) override;
   virtual nsresult GetPadding(nsMargin& aBorderAndPadding) override;
   virtual nsresult GetMargin(nsMargin& aMargin) override;
 
   virtual Valignment GetVAlign() const override { return vAlign_Top; }
   virtual Halignment GetHAlign() const override { return hAlign_Left; }
 
   virtual nsresult RelayoutChildAtOrdinal(nsIFrame* aChild) override;
 
diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -1395,17 +1395,17 @@ nsBoxFrame::BuildDisplayListForChildren(
 // This is done by nsDisplayXULDebug, which is in the Outlines()
 // layer so it goes on top. This means it is not clipped by OVERFLOW_CLIP,
 // whereas it did used to respect OVERFLOW_CLIP, but too bad.
 #ifdef DEBUG_LAYOUT
 void
 nsBoxFrame::PaintXULDebugBackground(DrawTarget* aDrawTarget, nsPoint aPt)
 {
   nsMargin border;
-  GetBorder(border);
+  GetXULBorder(border);
 
   nsMargin debugBorder;
   nsMargin debugMargin;
   nsMargin debugPadding;
 
   bool isHorizontal = IsHorizontal();
 
   GetDebugBorder(debugBorder);
@@ -1457,17 +1457,17 @@ nsBoxFrame::PaintXULDebugBackground(Draw
     aDrawTarget->StrokeRect(NSRectToRect(dirty, appUnitsPerDevPixel), green);
   }
 }
 
 void
 nsBoxFrame::PaintXULDebugOverlay(DrawTarget& aDrawTarget, nsPoint aPt)
 {
   nsMargin border;
-  GetBorder(border);
+  GetXULBorder(border);
 
   nsMargin debugMargin;
   GetDebugMargin(debugMargin);
   PixelMarginToTwips(debugMargin);
 
   nsRect inner(mRect);
   inner.MoveTo(aPt);
   inner.Deflate(debugMargin);
