From: L. David Baron <dbaron@dbaron.org>

Set NS_STYLE_RELEVANT_LINK_IS_VISITED when appropriate.  (Bug 147777)

diff --git a/layout/style/crashtests/147777-1.html b/layout/style/crashtests/147777-1.html
new file mode 100644
--- /dev/null
+++ b/layout/style/crashtests/147777-1.html
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<title>crashtest for NS_ABORT_IF_FALSE during development of 147777</title>
+<style type="text/css">
+:link::before { content: "link: " }
+</style>
+<a href="http://www.example.com/">example</a>
diff --git a/layout/style/crashtests/crashtests.list b/layout/style/crashtests/crashtests.list
--- a/layout/style/crashtests/crashtests.list
+++ b/layout/style/crashtests/crashtests.list
@@ -1,9 +1,10 @@
 load 105619-1.html
+load 147777-1.html
 load 187671-1.html
 load 192408-1.html
 load 286707-1.html
 load 285727-1.html
 load 317561-1.html
 load 330998-1.html
 load 368175-1.html
 load 379788-1.html
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -54,16 +54,17 @@
 #include "nsCSSAnonBoxes.h"
 #include "nsCSSPseudoElements.h"
 #include "nsCSSRuleProcessor.h"
 #include "nsIContent.h"
 #include "nsIFrame.h"
 #include "nsContentUtils.h"
 #include "nsRuleProcessorData.h"
 #include "nsTransitionManager.h"
+#include "nsIEventStateManager.h"
 
 NS_IMPL_ISUPPORTS1(nsEmptyStyleRule, nsIStyleRule)
 
 NS_IMETHODIMP
 nsEmptyStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   return NS_OK;
 }
@@ -430,16 +431,22 @@ already_AddRefed<nsStyleContext>
 nsStyleSet::GetContext(nsStyleContext* aParentContext,
                        nsRuleNode* aRuleNode,
                        // aVisitedRuleNode may be null; if it is null
                        // it means that we don't need to force creation
                        // of a StyleIfVisited.  (But if we make one
                        // because aParentContext has one, then aRuleNode
                        // should be used.)
                        nsRuleNode* aVisitedRuleNode,
+                       // NB: ReparentStyleContext and
+                       // ResolveStyleByAddingRules pass bogus values
+                       // that work based on what this function is known
+                       // to do with aIsLink and aIsVisitedLink
+                       PRBool aIsLink,
+                       PRBool aIsVisitedLink,
                        nsIAtom* aPseudoTag,
                        nsCSSPseudoElements::Type aPseudoType)
 {
   NS_PRECONDITION((!aPseudoTag &&
                    aPseudoType ==
                      nsCSSPseudoElements::ePseudo_NotPseudoElement) ||
                   (aPseudoTag &&
                    nsCSSPseudoElements::GetPseudoType(aPseudoTag) ==
@@ -467,17 +474,17 @@ nsStyleSet::GetContext(nsStyleContext* a
     // only the visitedness of the relevant link should influence style.
     parentIfVisited = aParentContext;
   }
 
   nsRefPtr<nsStyleContext> result;
   if (aParentContext)
     result = aParentContext->FindChildWithRules(aPseudoTag, aRuleNode,
                                                 aVisitedRuleNode,
-                                                PR_FALSE);
+                                                aIsVisitedLink);
 
 #ifdef NOISY_DEBUG
   if (result)
     fprintf(stdout, "--- SharedSC %d ---\n", ++gSharedCount);
   else
     fprintf(stdout, "+++ NewSC %d +++\n", ++gNewCount);
 #endif
 
@@ -489,16 +496,23 @@ nsStyleSet::GetContext(nsStyleContext* a
     if (aVisitedRuleNode) {
       nsRefPtr<nsStyleContext> resultIfVisited =
         NS_NewStyleContext(parentIfVisited, aPseudoTag, aPseudoType,
                            aVisitedRuleNode, PresContext());
       if (!resultIfVisited) {
         return nsnull;
       }
       result->SetStyleIfVisited(resultIfVisited.forget());
+
+      PRBool relevantLinkVisited =
+        aIsLink ? aIsVisitedLink
+                : (aParentContext && aParentContext->RelevantLinkVisited());
+      if (relevantLinkVisited) {
+        result->AddStyleBit(NS_STYLE_RELEVANT_LINK_VISITED);
+      }
     }
     if (!aParentContext)
       mRoots.AppendElement(result);
   }
   else {
     NS_ASSERTION(result->GetPseudoType() == aPseudoType, "Unexpected type");
     NS_ASSERTION(result->GetPseudo() == aPseudoTag, "Unexpected pseudo");
   }
@@ -793,16 +807,18 @@ nsStyleSet::ResolveStyleFor(nsIContent* 
   if (ruleWalker.HaveRelevantLink()) {
     ruleWalker.ResetForVisitedMatching();
     FileRules(EnumRulesMatching<ElementRuleProcessorData>, &data, aContent,
               &ruleWalker);
     visitedRuleNode = ruleWalker.CurrentNode();
   }
 
   return GetContext(aParentContext, ruleNode, visitedRuleNode,
+                    data.IsLink(),
+                    (data.ContentState() & NS_EVENT_STATE_VISITED) != 0,
                     nsnull, nsCSSPseudoElements::ePseudo_NotPseudoElement);
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForRules(nsStyleContext* aParentContext,
                                  const nsCOMArray<nsIStyleRule> &aRules)
 {
   NS_ENSURE_FALSE(mInShutdown, nsnull);
@@ -811,16 +827,17 @@ nsStyleSet::ResolveStyleForRules(nsStyle
   // FIXME: Perhaps this should be passed in, but it probably doesn't
   // matter.
   ruleWalker.SetLevel(eDocSheet, PR_FALSE, PR_FALSE);
   for (PRInt32 i = 0; i < aRules.Count(); i++) {
     ruleWalker.Forward(aRules.ObjectAt(i));
   }
 
   return GetContext(aParentContext, ruleWalker.CurrentNode(), nsnull,
+                    PR_FALSE, PR_FALSE,
                     nsnull, nsCSSPseudoElements::ePseudo_NotPseudoElement);
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleByAddingRules(nsStyleContext* aBaseContext,
                                       const nsCOMArray<nsIStyleRule> &aRules)
 {
   NS_ENSURE_FALSE(mInShutdown, nsnull);
@@ -841,24 +858,28 @@ nsStyleSet::ResolveStyleByAddingRules(ns
     ruleWalker.SetCurrentNode(aBaseContext->StyleIfVisited()->GetRuleNode());
     for (PRInt32 i = 0; i < aRules.Count(); i++) {
       ruleWalker.Forward(aRules.ObjectAt(i));
     }
     visitedRuleNode = ruleWalker.CurrentNode();
   }
 
   return GetContext(aBaseContext->GetParent(), ruleNode, visitedRuleNode,
+                    // bogus values for aIsLink and aIsVisitedLink that
+                    // we know will make GetContext do the right thing.
+                    PR_TRUE, aBaseContext->RelevantLinkVisited(),
                     aBaseContext->GetPseudo(),
                     aBaseContext->GetPseudoType());
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForNonElement(nsStyleContext* aParentContext)
 {
   return GetContext(aParentContext, mRuleTree, nsnull,
+                    PR_FALSE, PR_FALSE,
                     nsCSSAnonBoxes::mozNonElement,
                     nsCSSPseudoElements::ePseudo_AnonBox);
 }
 
 void
 nsStyleSet::WalkRestrictionRule(nsCSSPseudoElements::Type aPseudoType,
                                 nsRuleWalker* aRuleWalker)
 {
@@ -896,16 +917,19 @@ nsStyleSet::ResolvePseudoElementStyle(ns
   if (ruleWalker.HaveRelevantLink()) {
     ruleWalker.ResetForVisitedMatching();
     FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
               aParentContent, &ruleWalker);
     visitedRuleNode = ruleWalker.CurrentNode();
   }
 
   return GetContext(aParentContext, ruleNode, visitedRuleNode,
+                    // For pseudos, |data.IsLink()| being true means that
+                    // our parent node is a link.
+                    PR_FALSE, PR_FALSE,
                     nsCSSPseudoElements::GetPseudoAtom(aType), aType);
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ProbePseudoElementStyle(nsIContent* aParentContent,
                                     nsCSSPseudoElements::Type aType,
                                     nsStyleContext* aParentContext)
 {
@@ -938,16 +962,19 @@ nsStyleSet::ProbePseudoElementStyle(nsIC
     ruleWalker.ResetForVisitedMatching();
     FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
               aParentContent, &ruleWalker);
     visitedRuleNode = ruleWalker.CurrentNode();
   }
 
   nsRefPtr<nsStyleContext> result =
     GetContext(aParentContext, ruleNode, visitedRuleNode,
+               // For pseudos, |data.IsLink()| being true means that
+               // our parent node is a link.
+               PR_FALSE, PR_FALSE,
                pseudoTag, aType);
 
   // For :before and :after pseudo-elements, having display: none or no
   // 'content' property is equivalent to not having the pseudo-element
   // at all.
   if (result &&
       (pseudoTag == nsCSSPseudoElements::before ||
        pseudoTag == nsCSSPseudoElements::after)) {
@@ -979,16 +1006,17 @@ nsStyleSet::ResolveAnonymousBoxStyle(nsI
 #endif
 
   nsRuleWalker ruleWalker(mRuleTree);
   AnonBoxRuleProcessorData data(PresContext(), aPseudoTag, &ruleWalker);
   FileRules(EnumRulesMatching<AnonBoxRuleProcessorData>, &data, nsnull,
             &ruleWalker);
 
   return GetContext(aParentContext, ruleWalker.CurrentNode(), nsnull,
+                    PR_FALSE, PR_FALSE,
                     aPseudoTag, nsCSSPseudoElements::ePseudo_AnonBox);
 }
 
 #ifdef MOZ_XUL
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveXULTreePseudoStyle(nsIContent* aParentContent,
                                       nsIAtom* aPseudoTag,
                                       nsStyleContext* aParentContext,
@@ -1014,16 +1042,19 @@ nsStyleSet::ResolveXULTreePseudoStyle(ns
   if (ruleWalker.HaveRelevantLink()) {
     ruleWalker.ResetForVisitedMatching();
     FileRules(EnumRulesMatching<XULTreeRuleProcessorData>, &data,
               aParentContent, &ruleWalker);
     visitedRuleNode = ruleWalker.CurrentNode();
   }
 
   return GetContext(aParentContext, ruleNode, visitedRuleNode,
+                    // For pseudos, |data.IsLink()| being true means that
+                    // our parent node is a link.
+                    PR_FALSE, PR_FALSE,
                     aPseudoTag, nsCSSPseudoElements::ePseudo_XULTree);
 }
 #endif
 
 PRBool
 nsStyleSet::AppendFontFaceRules(nsPresContext* aPresContext,
                                 nsTArray<nsFontFaceRuleContainer>& aArray)
 {
@@ -1137,16 +1168,19 @@ nsStyleSet::ReparentStyleContext(nsStyle
   nsRuleNode* ruleNode = aStyleContext->GetRuleNode();
   nsRuleNode* visitedRuleNode = nsnull;
   nsStyleContext* visitedContext = aStyleContext->StyleIfVisited();
   if (visitedContext) {
      visitedRuleNode = visitedContext->GetRuleNode();
   }
 
   return GetContext(aNewParentContext, ruleNode, visitedRuleNode,
+                    // bogus values for aIsLink and aIsVisitedLink that
+                    // we know will make GetContext do the right thing.
+                    PR_TRUE, aStyleContext->RelevantLinkVisited(),
                     pseudoTag, pseudoType);
 }
 
 struct StatefulData : public StateRuleProcessorData {
   StatefulData(nsPresContext* aPresContext,
                nsIContent* aContent, PRInt32 aStateMask)
     : StateRuleProcessorData(aPresContext, aContent, aStateMask),
       mHint(nsRestyleHint(0))
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -335,16 +335,18 @@ class nsStyleSet
   void WalkRuleProcessors(nsIStyleRuleProcessor::EnumFunc aFunc,
                           RuleProcessorData* aData,
                           PRBool aWalkAllXBLStylesheets);
 
   already_AddRefed<nsStyleContext>
   GetContext(nsStyleContext* aParentContext,
              nsRuleNode* aRuleNode,
              nsRuleNode* aVisitedRuleNode,
+             PRBool aIsLink,
+             PRBool aIsVisitedLink,
              nsIAtom* aPseudoTag,
              nsCSSPseudoElements::Type aPseudoType);
 
   nsPresContext* PresContext() { return mRuleTree->GetPresContext(); }
 
   // The sheets in each array in mSheets are stored with the most significant
   // sheet last.
   nsCOMArray<nsIStyleSheet> mSheets[eSheetTypeCount];
