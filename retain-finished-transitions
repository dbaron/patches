From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch 13 - Retain finished transitions until the next style change or until removed from transition-property.

Note that this increases memory use for completed transitions since we
don't throw away the data when the transitions complete.  That said,
this matches what we do for CSS Animations, and it's needed (once we
switch to the new rules for starting transitions) to maintain the
invariant that unrelated style changes don't trigger transitions.

The storage issues could be optimized in the future if it turns out to
be a problem, but I think that's unlikely, given that we'll never store
more than one for any element+property combination.

diff --git a/dom/animation/Animation.h b/dom/animation/Animation.h
--- a/dom/animation/Animation.h
+++ b/dom/animation/Animation.h
@@ -231,20 +231,20 @@ public:
                                      = nullptr) const {
     return GetComputedTimingAt(GetLocalTime(), aTiming ? *aTiming : mTiming);
   }
 
   // Return the duration of the active interval for the given timing parameters.
   static StickyTimeDuration
   ActiveDuration(const AnimationTiming& aTiming);
 
-  // After transitions finish they need to be retained for one throttle-able
-  // cycle (for reasons see explanation in
-  // layout/style/nsTransitionManager.cpp).
-  // In the meantime, however, they should be ignored.
+  // After transitions finish they need to be retained in order to
+  // address the issue described in
+  // https://lists.w3.org/Archives/Public/www-style/2015Jan/0444.html .
+  // However, finished transitions are ignored for many purposes.
   bool IsFinishedTransition() const {
     return mIsFinishedTransition;
   }
 
   void SetIsFinishedTransition() {
     MOZ_ASSERT(AsTransition(),
                "Calling SetIsFinishedTransition but it's not a transition");
     mIsFinishedTransition = true;
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -265,20 +265,21 @@ nsTransitionManager::StyleContextChanged
         ConsiderStartingTransition(property, t, aElement, collection,
                                    aOldStyleContext, afterChangeStyle,
                                    &startedAny, &whichStarted);
       }
     }
   }
 
   // Stop any transitions for properties that are no longer in
-  // 'transition-property'.
-  // Also stop any transitions for properties that just changed (and are
-  // still in the set of properties to transition), but we didn't just
-  // start the transition because delay and duration are both zero.
+  // 'transition-property', including finished transitions.
+  // Also stop any transitions (and removed any finished transitions)
+  // for properties that just changed (and are still in the set of
+  // properties to transition), but we didn't just start the transition
+  // because delay and duration are both zero.
   if (collection) {
     bool checkProperties =
       disp->mTransitions[0].GetProperty() != eCSSPropertyExtra_all_properties;
     nsCSSPropertySet allTransitionProperties;
     if (checkProperties) {
       for (uint32_t i = disp->mTransitionPropertyCount; i-- != 0; ) {
         const StyleTransition& t = disp->mTransitions[i];
         // FIXME: Would be good to find a way to share code between this
@@ -323,19 +324,21 @@ nsTransitionManager::StyleContextChanged
       if ((checkProperties &&
            !allTransitionProperties.HasProperty(prop.mProperty)) ||
           // properties whose computed values changed but delay and
           // duration are both zero
           !ExtractComputedValueForTransition(prop.mProperty, afterChangeStyle,
                                              currentValue) ||
           currentValue != segment.mToValue) {
         // stop the transition
-        player->Cancel();
+        if (!player->GetSource()->IsFinishedTransition()) {
+          player->Cancel();
+          collection->UpdateAnimationGeneration(mPresContext);
+        }
         players.RemoveElementAt(i);
-        collection->UpdateAnimationGeneration(mPresContext);
       }
     } while (i != 0);
 
     if (players.IsEmpty()) {
       collection->Destroy();
       collection = nullptr;
     }
   }
@@ -435,26 +438,31 @@ nsTransitionManager::ConsiderStartingTra
   // of the currently running transition, we don't want to interrupt
   // its timing function.
   // This needs to be before the !shouldAnimate && haveCurrentTransition
   // case below because we might be close enough to the end of the
   // transition that the current value rounds to the final value.  In
   // this case, we'll end up with shouldAnimate as false (because
   // there's no value change), but we need to return early here rather
   // than cancel the running transition because shouldAnimate is false!
+  //
+  // Likewise, if we got a style change that changed the value to the
+  // endpoint of our finished transition, we also don't want to start
+  // a new transition for the reasons described in
+  // https://lists.w3.org/Archives/Public/www-style/2015Jan/0444.html .
   MOZ_ASSERT(!oldPT || oldPT->Properties()[0].mSegments.Length() == 1,
              "Should have one animation property segment for a transition");
   if (haveCurrentTransition && haveValues &&
       oldPT->Properties()[0].mSegments[0].mToValue == endValue) {
     // GetAnimationRule already called RestyleForAnimation.
     return;
   }
 
   if (!shouldAnimate) {
-    if (haveCurrentTransition) {
+    if (haveCurrentTransition && !oldPT->IsFinishedTransition()) {
       // We're in the middle of a transition, and just got a non-transition
       // style change to something that we can't animate.  This might happen
       // because we got a non-transition style change changing to the current
       // in-progress value (which is particularly easy to cause when we're
       // currently in the 'transition-delay').  It also might happen because we
       // just got a style change to a value that can't be interpolated.
       AnimationPlayerPtrArray& players = aElementTransitions->mPlayers;
       players[currentIndex]->Cancel();
@@ -681,26 +689,17 @@ nsTransitionManager::FlushTransitions(Fl
                         "destroyed the element transitions object");
 
       size_t i = collection->mPlayers.Length();
       NS_ABORT_IF_FALSE(i != 0, "empty transitions list?");
       bool transitionStartedOrEnded = false;
       do {
         --i;
         AnimationPlayer* player = collection->mPlayers[i];
-        if (player->GetSource()->IsFinishedTransition()) {
-          // Actually remove transitions one throttle-able cycle after their
-          // completion. We only clear on a throttle-able cycle because that
-          // means it is a regular restyle tick and thus it is safe to discard
-          // the transition. If the flush is not throttle-able, we might still
-          // have new transitions left to process. See comment below.
-          if (aFlags == Can_Throttle) {
-            collection->mPlayers.RemoveElementAt(i);
-          }
-        } else {
+        if (!player->GetSource()->IsFinishedTransition()) {
           MOZ_ASSERT(player->GetSource(),
                      "Transitions should have source content");
           ComputedTiming computedTiming =
             player->GetSource()->GetComputedTiming();
           if (computedTiming.mPhase == ComputedTiming::AnimationPhase_After) {
             MOZ_ASSERT(player->GetSource()->Properties().Length() == 1,
                        "Should have one animation property for a transition");
             nsCSSProperty prop = player->GetSource()->Properties()[0].mProperty;
