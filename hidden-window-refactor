From: L. David Baron <dbaron@dbaron.org>

Bug 1367830 - Refactor to share more code between private and non-private hidden window creation.

MozReview-Commit-ID: 8NZPbcJtvsE

diff --git a/xpfe/appshell/nsAppShellService.cpp b/xpfe/appshell/nsAppShellService.cpp
--- a/xpfe/appshell/nsAppShellService.cpp
+++ b/xpfe/appshell/nsAppShellService.cpp
@@ -126,39 +126,40 @@ nsAppShellService::CreateHiddenWindowHel
   static const char hiddenWindowURL[] = DEFAULT_HIDDENWINDOW_URL;
   uint32_t    chromeMask =  nsIWebBrowserChrome::CHROME_ALL;
 #endif
 
   nsCOMPtr<nsIURI> url;
   rv = NS_NewURI(getter_AddRefs(url), hiddenWindowURL);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  RefPtr<nsWebShellWindow> newWindow;
-  if (!aIsPrivate) {
-    rv = JustCreateTopWindow(nullptr, url,
-                             chromeMask, initialWidth, initialHeight,
-                             true, nullptr, nullptr, getter_AddRefs(newWindow));
-    NS_ENSURE_SUCCESS(rv, rv);
+  if (aIsPrivate) {
+    chromeMask |= nsIWebBrowserChrome::CHROME_PRIVATE_WINDOW;
+  }
 
-    mHiddenWindow.swap(newWindow);
-  } else {
-    // Create the hidden private window
-    chromeMask |= nsIWebBrowserChrome::CHROME_PRIVATE_WINDOW;
+  RefPtr<nsWebShellWindow> newWindow;
+  rv = JustCreateTopWindow(nullptr, url,
+                           chromeMask, initialWidth, initialHeight,
+                           true, nullptr, nullptr, getter_AddRefs(newWindow));
+  NS_ENSURE_SUCCESS(rv, rv);
 
-    rv = JustCreateTopWindow(nullptr, url,
-                             chromeMask, initialWidth, initialHeight,
-                             true, nullptr, nullptr, getter_AddRefs(newWindow));
-    NS_ENSURE_SUCCESS(rv, rv);
-
+  {
     nsCOMPtr<nsIDocShell> docShell;
     newWindow->GetDocShell(getter_AddRefs(docShell));
     if (docShell) {
-      docShell->SetAffectPrivateSessionLifetime(false);
+      if (aIsPrivate) {
+        docShell->SetAffectPrivateSessionLifetime(false);
+      }
     }
+  }
 
+  if (!aIsPrivate) {
+    mHiddenWindow.swap(newWindow);
+  } else {
+    // We created the hidden private window
     mHiddenPrivateWindow.swap(newWindow);
   }
 
   // RegisterTopLevelWindow(newWindow); -- Mac only
 
   return NS_OK;
 }
 
