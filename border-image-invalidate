Fix a bunch of issues relating to dynamic changes of border images.  (Bug 445810)

diff --git a/layout/base/nsFrameManager.cpp b/layout/base/nsFrameManager.cpp
--- a/layout/base/nsFrameManager.cpp
+++ b/layout/base/nsFrameManager.cpp
@@ -86,16 +86,17 @@
 #include "nsContentUtils.h"
 #include "nsReadableUtils.h"
 #include "nsUnicharUtils.h"
 #include "nsPrintfCString.h"
 #include "nsLayoutErrors.h"
 #include "nsLayoutUtils.h"
 #include "nsAutoPtr.h"
 #include "imgIRequest.h"
+#include "nsStyleStructInlines.h"
 
 #include "nsFrameManager.h"
 #ifdef ACCESSIBILITY
 #include "nsIAccessibilityService.h"
 #include "nsIAccessibleEvent.h"
 #endif
 
   #ifdef DEBUG
@@ -1210,18 +1211,45 @@ nsFrameManager::ReResolveStyleContext(ns
             oldColor->mBackgroundImage->GetURI(getter_AddRefs(oldURI));
             newColor->mBackgroundImage->GetURI(getter_AddRefs(newURI));
             PRBool equal;
             stopImages =
               NS_FAILED(oldURI->Equals(newURI, &equal)) || !equal;
           }
           if (stopImages) {
             // stop the image loading for the frame, the image has changed
-            aPresContext->StopImagesFor(aFrame);
+            aPresContext->StopBackgroundImageFor(aFrame);
           }
+        }
+
+        const nsStyleBorder* oldBorder = oldContext->GetStyleBorder();
+        const nsStyleBorder* newBorder = newContext->GetStyleBorder();
+        if (oldBorder->GetBorderImage()) {
+          PRBool stopImages = !newBorder->GetBorderImage();
+          if (!stopImages) {
+            nsCOMPtr<nsIURI> oldURI, newURI;
+            oldBorder->GetBorderImage()->GetURI(getter_AddRefs(oldURI));
+            newBorder->GetBorderImage()->GetURI(getter_AddRefs(newURI));
+            PRBool equal;
+            stopImages =
+              NS_FAILED(oldURI->Equals(newURI, &equal)) || !equal;
+          }
+          if (stopImages) {
+            // stop the image loading for the frame, the image has changed
+            aPresContext->StopBorderImageFor(aFrame);
+          }
+        }
+
+        // Since the CalcDifference call checked whether the new border
+        // image was loaded in order to determine whether to do a
+        // reflow, we need to call LoadBorderImage now so that the frame
+        // gets notified if the image loads.
+        imgIRequest *borderImage = newBorder->GetBorderImage();
+        if (borderImage) {
+          aPresContext->LoadBorderImage(borderImage, aFrame);
         }
       }
       oldContext->Release();
     }
     else {
       NS_ERROR("resolve style context failed");
       newContext = oldContext;  // new context failed, recover... (take ref)
       oldContext = nsnull;
diff --git a/layout/base/nsImageLoader.cpp b/layout/base/nsImageLoader.cpp
--- a/layout/base/nsImageLoader.cpp
+++ b/layout/base/nsImageLoader.cpp
@@ -209,21 +209,18 @@ NS_IMETHODIMP nsImageLoader::FrameChange
 
 void
 nsImageLoader::RedrawDirtyFrame(const nsRect* aDamageRect)
 {
   if (mReflowOnLoad) {
     nsIPresShell *shell = mPresContext->GetPresShell();
     nsresult rv = shell->FrameNeedsReflow(mFrame, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
     NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Could not reflow after loading border-image");
-    // Note that we're assuming that the resulting reflow will
-    // invalidate the entire frame.  Given that we only set
-    // mReflowOnLoad if the actual border width will change when we do
-    // this reflow, this invalidate should happen.
-    return;
+    // The reflow might not do all the invalidation we need, so continue
+    // on with the invalidation codepath.
   }
   // NOTE: It is not sufficient to invalidate only the size of the image:
   //       the image may be tiled! 
   //       The best option is to call into the frame, however lacking this
   //       we have to at least invalidate the frame's bounds, hence
   //       as long as we have a frame we'll use its size.
   //
 
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1210,34 +1210,45 @@ nsPresContext::LoadBorderImage(imgIReque
 {
   return DoLoadImage(mBorderImageLoaders, aImage, aTargetFrame,
                      aTargetFrame->GetStyleBorder()->ImageBorderDiffers());
 }
 
 void
 nsPresContext::StopImagesFor(nsIFrame* aTargetFrame)
 {
+  StopBackgroundImageFor(aTargetFrame);
+  StopBorderImageFor(aTargetFrame);
+}
+
+void
+nsPresContext::StopBackgroundImageFor(nsIFrame* aTargetFrame)
+{
   nsCOMPtr<nsImageLoader> loader;
   mImageLoaders.Get(aTargetFrame, getter_AddRefs(loader));
 
   if (loader) {
     loader->Destroy();
 
     mImageLoaders.Remove(aTargetFrame);
   }
+}
   
+void
+nsPresContext::StopBorderImageFor(nsIFrame* aTargetFrame)
+{
+  nsCOMPtr<nsImageLoader> loader;
   mBorderImageLoaders.Get(aTargetFrame, getter_AddRefs(loader));
   
   if (loader) {
     loader->Destroy();
 
     mBorderImageLoaders.Remove(aTargetFrame);
   }
 }
-
 
 void
 nsPresContext::SetContainer(nsISupports* aHandler)
 {
   mContainer = do_GetWeakReference(aHandler);
   if (mContainer) {
     GetDocumentColorPreferences();
   }
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -391,16 +391,18 @@ private:
   typedef nsInterfaceHashtable<nsVoidPtrHashKey, nsImageLoader> ImageLoaderTable;
 
   NS_HIDDEN_(imgIRequest*) DoLoadImage(ImageLoaderTable& aTable,
                                        imgIRequest* aImage,
                                        nsIFrame* aTargetFrame,
                                        PRBool aReflowOnLoad);
 public:
 
+  NS_HIDDEN_(void) StopBackgroundImageFor(nsIFrame* aTargetFrame);
+  NS_HIDDEN_(void) StopBorderImageFor(nsIFrame* aTargetFrame);
   /**
    * This method is called when a frame is being destroyed to
    * ensure that the image load gets disassociated from the prescontext
    */
   NS_HIDDEN_(void) StopImagesFor(nsIFrame* aTargetFrame);
 
   NS_HIDDEN_(void) SetContainer(nsISupports* aContainer);
 
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -430,33 +430,44 @@ nsStyleBorder::Destroy(nsPresContext* aC
 }
 
 
 nsChangeHint nsStyleBorder::CalcDifference(const nsStyleBorder& aOther) const
 {
   // Note that differences in mBorder don't affect rendering (which should only
   // use mComputedBorder), so don't need to be tested for here.
   if (mTwipsPerPixel == aOther.mTwipsPerPixel &&
-      mComputedBorder == aOther.mComputedBorder && 
+      GetActualBorder() == aOther.GetActualBorder() && 
       mFloatEdge == aOther.mFloatEdge) {
     // Note that mBorderStyle stores not only the border style but also
     // color-related flags.  Given that we've already done an mComputedBorder
     // comparison, border-style differences can only lead to a VISUAL hint.  So
     // it's OK to just compare the values directly -- if either the actual
     // style or the color flags differ we want to repaint.
     NS_FOR_CSS_SIDES(ix) {
       if (mBorderStyle[ix] != aOther.mBorderStyle[ix] || 
           mBorderColor[ix] != aOther.mBorderColor[ix]) {
         return NS_STYLE_HINT_VISUAL;
       }
     }
 
     if (mBorderRadius != aOther.mBorderRadius ||
         !mBorderColors != !aOther.mBorderColors) {
       return NS_STYLE_HINT_VISUAL;
+    }
+
+    if (IsBorderImageLoaded() || aOther.IsBorderImageLoaded()) {
+      if (mBorderImage != aOther.mBorderImage ||
+          mBorderImageHFill != aOther.mBorderImageHFill ||
+          mBorderImageVFill != aOther.mBorderImageVFill ||
+          mBorderImageSplit != aOther.mBorderImageSplit) {
+        return NS_STYLE_HINT_VISUAL;
+      }
+      // The call to GetActualBorder above already considered
+      // mBorderImageWidth and mHaveBorderImageWidth.
     }
 
     // Note that at this point if mBorderColors is non-null so is
     // aOther.mBorderColors
     if (mBorderColors) {
       NS_FOR_CSS_SIDES(ix) {
         if (!mBorderColors[ix] != !aOther.mBorderColors[ix]) {
           return NS_STYLE_HINT_VISUAL;
