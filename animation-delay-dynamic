From: L. David Baron <dbaron@dbaron.org>

Change record of animation start to be before delay so that dynamic changes to animation-delay are honored.

Note: per CSS WG, afternoon of 2012-10-29.

diff --git a/gfx/layers/Layers.h b/gfx/layers/Layers.h
--- a/gfx/layers/Layers.h
+++ b/gfx/layers/Layers.h
@@ -771,16 +771,17 @@ public:
    * A layer is "fixed position" when it draws content from a content
    * (not chrome) document, the topmost content document has a root scrollframe
    * with a displayport, but the layer does not move when that displayport scrolls.
    */
   void SetIsFixedPosition(bool aFixedPosition) { mIsFixedPosition = aFixedPosition; }
 
   // Call AddAnimation to add a new animation to this layer from layout code.
   // Caller must add segments to the returned animation.
+  // aStart represents the time at the *end* of the delay.
   Animation* AddAnimation(mozilla::TimeStamp aStart, mozilla::TimeDuration aDuration,
                           float aIterations, int aDirection,
                           nsCSSProperty aProperty, const AnimationData& aData);
   // ClearAnimations clears animations on this layer.
   void ClearAnimations();
   // This is only called when the layer tree is updated. Do not call this from
   // layout code.  To add an animation to this layer, use AddAnimation.
   void SetAnimations(const AnimationArray& aAnimations);
diff --git a/gfx/layers/ipc/CompositorParent.cpp b/gfx/layers/ipc/CompositorParent.cpp
--- a/gfx/layers/ipc/CompositorParent.cpp
+++ b/gfx/layers/ipc/CompositorParent.cpp
@@ -770,18 +770,17 @@ SampleAnimations(Layer* aLayer, TimeStam
 
   for (uint32_t i = animations.Length(); i-- !=0; ) {
     Animation& animation = animations[i];
     AnimData& animData = animationData[i];
 
     double numIterations = animation.numIterations() != -1 ?
       animation.numIterations() : NS_IEEEPositiveInfinity();
     double positionInIteration =
-      ElementAnimations::GetPositionInIteration(animation.startTime(),
-                                                aPoint,
+      ElementAnimations::GetPositionInIteration(animation.startTime() - aPoint,
                                                 animation.duration(),
                                                 numIterations,
                                                 animation.direction());
 
     NS_ABORT_IF_FALSE(0.0 <= positionInIteration &&
                       positionInIteration <= 1.0,
                       "position should be in [0-1]");
 
diff --git a/gfx/layers/ipc/PLayers.ipdl b/gfx/layers/ipc/PLayers.ipdl
--- a/gfx/layers/ipc/PLayers.ipdl
+++ b/gfx/layers/ipc/PLayers.ipdl
@@ -147,16 +147,19 @@ struct TransformData {
 };
 
 union AnimationData {
   null_t;
   TransformData;
 };
 
 struct Animation {
+  // Unlike in nsAnimationManager, this start time is at the end of the
+  // delay.  If the delay is changed dynamically, the layer's data will
+  // be updated.
   TimeStamp startTime;
   TimeDuration duration;
   // For each frame, the interpolation point is computed based on the
   // startTime, the direction, the duration, and the current time.
   // The segments must uniquely cover the portion from 0.0 to 1.0
   AnimationSegment[] segments;
   // How many times to repeat the animation.  < 0 means "forever".
   float numIterations;
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -296,17 +296,17 @@ AddAnimationsForProperty(nsIFrame* aFram
                          AnimationData& aData)
 {
   NS_ASSERTION(aLayer->AsContainerLayer(), "Should only animate ContainerLayer");
   nsStyleContext* styleContext = aFrame->GetStyleContext();
   nsPresContext* presContext = aFrame->PresContext();
   nsRect bounds = nsDisplayTransform::GetFrameBoundsForTransform(aFrame);
   float scale = presContext->AppUnitsPerDevPixel();
 
-  TimeStamp startTime = ea->mStartTime;
+  TimeStamp startTime = ea->mStartTime + ea->mDelay;
   TimeDuration duration = ea->mIterationDuration;
   float iterations = ea->mIterationCount != NS_IEEEPositiveInfinity()
                      ? ea->mIterationCount : -1;
   int direction = ea->mDirection;
 
   Animation* animation = aLayer->AddAnimation(startTime, duration,
                                               iterations, direction,
                                               aProperty, aData);
@@ -405,17 +405,20 @@ AddAnimationsAndTransitionsToLayer(Layer
       if (pt->mProperty != aProperty || !pt->IsRunningAt(currentTime)) {
         continue;
       }
 
       ElementAnimation anim;
       anim.mIterationCount = 1;
       anim.mDirection = NS_STYLE_ANIMATION_DIRECTION_NORMAL;
       anim.mFillMode = NS_STYLE_ANIMATION_FILL_MODE_NONE;
+      // Transition mStartTime is end-of-delay; animation mStartTime
+      // is start-of-delay, so set delay here to 0.
       anim.mStartTime = pt->mStartTime;
+      anim.mDelay = TimeDuration::FromMilliseconds(0);
       anim.mIterationDuration = pt->mDuration;
 
       AnimationProperty& prop = *anim.mProperties.AppendElement();
       prop.mProperty = pt->mProperty;
 
       AnimationPropertySegment& segment = *prop.mSegments.AppendElement();
       segment.mFromKey = 0;
       segment.mToKey = 1;
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -35,38 +35,37 @@ ElementAnimationsPropertyDtor(void      
 #ifdef DEBUG
   NS_ABORT_IF_FALSE(!ea->mCalledPropertyDtor, "can't call dtor twice");
   ea->mCalledPropertyDtor = true;
 #endif
   delete ea;
 }
 
 double
-ElementAnimations::GetPositionInIteration(TimeStamp aStartTime, TimeStamp aCurrentTime,
-                                          TimeDuration aDuration, double aIterationCount,
+ElementAnimations::GetPositionInIteration(TimeDuration aElapsedDuration,
+                                          TimeDuration aIterationDuration,
+                                          double aIterationCount,
                                           uint32_t aDirection, bool aIsForElement,
                                           ElementAnimation* aAnimation,
                                           ElementAnimations* aEa,
                                           EventArray* aEventsToDispatch)
 {
   // Set |currentIterationCount| to the (fractional) number of
   // iterations we've completed up to the current position.
-  TimeDuration currentTimeDuration = aCurrentTime - aStartTime;
-  double currentIterationCount =
-    currentTimeDuration / aDuration;
+  double currentIterationCount = aElapsedDuration / aIterationDuration;
   bool dispatchStartOrIteration = false;
   if (currentIterationCount >= aIterationCount) {
     if (aAnimation) {
       // Dispatch 'animationend' when needed.
       if (aIsForElement &&
           aAnimation->mLastNotification !=
             ElementAnimation::LAST_NOTIFICATION_END) {
         aAnimation->mLastNotification = ElementAnimation::LAST_NOTIFICATION_END;
         AnimationEventInfo ei(aEa->mElement, aAnimation->mName, NS_ANIMATION_END,
-                              currentTimeDuration);
+                              aElapsedDuration);
         aEventsToDispatch->AppendElement(ei);
       }
 
       if (!aAnimation->FillsForwards()) {
         // No animation data.
         return -1;
       }
     } else {
@@ -139,17 +138,17 @@ ElementAnimations::GetPositionInIteratio
     // immediately in many cases.  It's not clear to me if that's the
     // right thing to do.
     uint32_t message =
       aAnimation->mLastNotification == ElementAnimation::LAST_NOTIFICATION_NONE
         ? NS_ANIMATION_START : NS_ANIMATION_ITERATION;
 
     aAnimation->mLastNotification = whichIteration;
     AnimationEventInfo ei(aEa->mElement, aAnimation->mName, message,
-                          currentTimeDuration);
+                          aElapsedDuration);
     aEventsToDispatch->AppendElement(ei);
   }
 
   return positionInIteration;
 }
 
 void
 ElementAnimations::EnsureStyleRuleFor(TimeStamp aRefreshTime,
@@ -211,26 +210,20 @@ ElementAnimations::EnsureStyleRuleFor(Ti
       ElementAnimation &anim = mAnimations[animIdx];
 
       if (anim.mProperties.Length() == 0 ||
           anim.mIterationDuration.ToMilliseconds() <= 0.0) {
         // No animation data.
         continue;
       }
 
-      TimeStamp currentTime;
-      if (anim.IsPaused()) {
-        // FIXME: avoid recalculating every time
-        currentTime = anim.mPauseStart;
-      } else {
-        currentTime = aRefreshTime;
-      }
-
+      // The ElapsedDurationAt() call here handles pausing.  But:
+      // FIXME: avoid recalculating every time when paused.
       double positionInIteration =
-        GetPositionInIteration(anim.mStartTime, currentTime,
+        GetPositionInIteration(anim.ElapsedDurationAt(aRefreshTime),
                                anim.mIterationDuration, anim.mIterationCount,
                                anim.mDirection, IsForElement(),
                                &anim, this, &aEventsToDispatch);
 
       // The position is -1 when we don't have fill data for the current time,
       // so we shouldn't animate.
       if (positionInIteration == -1)
         continue;
@@ -298,18 +291,22 @@ ElementAnimations::EnsureStyleRuleFor(Ti
       }
     }
   }
 }
 
 bool
 ElementAnimation::IsRunningAt(TimeStamp aTime) const
 {
-  return !IsPaused() && aTime >= mStartTime &&
-    (aTime - mStartTime)  / mIterationDuration < mIterationCount;
+  if (IsPaused()) {
+    return false;
+  }
+
+  double iterationsElapsed = ElapsedDurationAt(aTime) / mIterationDuration;
+  return 0.0 <= iterationsElapsed && iterationsElapsed < mIterationCount;
 }
 
 
 bool
 ElementAnimation::HasAnimationOfProperty(nsCSSProperty aProperty) const
 {
   for (uint32_t propIdx = 0, propEnd = mProperties.Length();
        propIdx != propEnd; ++propIdx) {
@@ -721,17 +718,18 @@ nsAnimationManager::BuildAnimations(nsSt
     ElementAnimation& aDest = *aAnimations.AppendElement();
 
     aDest.mName = aSrc.GetName();
     aDest.mIterationCount = aSrc.GetIterationCount();
     aDest.mDirection = aSrc.GetDirection();
     aDest.mFillMode = aSrc.GetFillMode();
     aDest.mPlayState = aSrc.GetPlayState();
 
-    aDest.mStartTime = now + TimeDuration::FromMilliseconds(aSrc.GetDelay());
+    aDest.mDelay = TimeDuration::FromMilliseconds(aSrc.GetDelay());
+    aDest.mStartTime = now;
     if (aDest.IsPaused()) {
       aDest.mPauseStart = now;
     } else {
       aDest.mPauseStart = TimeStamp();
     }
 
     aDest.mIterationDuration = TimeDuration::FromMilliseconds(aSrc.GetDuration());
 
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -88,18 +88,27 @@ struct ElementAnimation
 
   bool IsPaused() const {
     return mPlayState == NS_STYLE_ANIMATION_PLAY_STATE_PAUSED;
   }
 
   virtual bool HasAnimationOfProperty(nsCSSProperty aProperty) const;
   bool IsRunningAt(mozilla::TimeStamp aTime) const;
 
-  mozilla::TimeStamp mStartTime; // with delay taken into account
+  // Return the duration, at aTime (or, if paused, mPauseStart), since
+  // the *end* of the delay period.  May be negative.
+  mozilla::TimeDuration ElapsedDurationAt(mozilla::TimeStamp aTime) const {
+    NS_ABORT_IF_FALSE(!IsPaused() || aTime >= mPauseStart,
+                      "if paused, aTime must be at least mPauseStart");
+    return (IsPaused() ? mPauseStart : aTime) - mStartTime - mDelay;
+  }
+
+  mozilla::TimeStamp mStartTime; // the beginning of the delay period
   mozilla::TimeStamp mPauseStart;
+  mozilla::TimeDuration mDelay;
   mozilla::TimeDuration mIterationDuration;
 
   enum {
     LAST_NOTIFICATION_NONE = uint32_t(-1),
     LAST_NOTIFICATION_END = uint32_t(-2)
   };
   // One of the above constants, or an integer for the iteration
   // whose start we last notified on.
@@ -127,19 +136,18 @@ struct ElementAnimations MOZ_FINAL
   // that if the animation has not started yet, has already ended, or is paused,
   // it should not be run from the compositor.  When this function is called 
   // from the main thread, we need the actual ElementAnimation* in order to 
   // get correct animation-fill behavior and to fire animation events.
   // This function returns -1 for the position if the animation should not be
   // run (because it is not currently active and has no fill behavior), but
   // only does so if aAnimation is non-null; with a null aAnimation it is an
   // error to give aCurrentTime < aStartTime, and fill-forwards is assumed.
-  static double GetPositionInIteration(TimeStamp aStartTime,
-                                       TimeStamp aCurrentTime,
-                                       TimeDuration aDuration,
+  static double GetPositionInIteration(TimeDuration aElapsedDuration,
+                                       TimeDuration aIterationDuration,
                                        double aIterationCount,
                                        uint32_t aDirection,
                                        bool aIsForElement = true,
                                        ElementAnimation* aAnimation = nullptr,
                                        ElementAnimations* aEa = nullptr,
                                        EventArray* aEventsToDispatch = nullptr);
 
   void EnsureStyleRuleFor(TimeStamp aRefreshTime,
diff --git a/layout/style/test/test_animations.html b/layout/style/test/test_animations.html
--- a/layout/style/test/test_animations.html
+++ b/layout/style/test/test_animations.html
@@ -1112,34 +1112,39 @@ advance_clock(400);
 is(cs.marginRight, "0px", "positive delay test at 400ms");
 advance_clock(100);
 is(cs.marginRight, "0px", "positive delay test at 500ms");
 advance_clock(100);
 is_approx(px_to_num(cs.marginRight), 100 * gTF.ease_out(0.1), 0.01,
           "positive delay test at 500ms");
 done_div();
 
-// test dynamic changes to delay (i.e., that we only check delay once,
-// at the very start of the animation)
-new_div("animation: anim2 1s 0.5s ease-out");
+// test dynamic changes to delay (i.e., that we preserve the start time
+// that's before the delay)
+new_div("animation: anim2 1s 0.5s ease-out both");
 is(cs.marginRight, "0px", "dynamic delay delay test at 0ms");
 advance_clock(400);
-is(cs.marginRight, "0px", "dynamic delay delay test at 400ms");
+is(cs.marginRight, "0px", "dynamic delay delay test at 400ms (1)");
 div.style.animationDelay = "0.2s";
+is_approx(px_to_num(cs.marginRight), 100 * gTF.ease_out(0.2), 0.01,
+          "dynamic delay delay test at 400ms (2)");
+div.style.animationDelay = "0.6s";
 advance_clock(0);
-advance_clock(100);
-is(cs.marginRight, "0px", "dynamic delay delay test at 500ms");
-advance_clock(100);
-is_approx(px_to_num(cs.marginRight), 100 * gTF.ease_out(0.1), 0.01,
-          "dynamic delay delay test at 500ms");
-div.style.animationDelay = "1s";
-advance_clock(0);
-advance_clock(100);
+advance_clock(200);
+is(cs.marginRight, "0px", "dynamic delay delay test at 600ms");
+advance_clock(200);
 is_approx(px_to_num(cs.marginRight), 100 * gTF.ease_out(0.2), 0.01,
-          "dynamic delay delay test at 500ms");
+          "dynamic delay delay test at 800ms");
+advance_clock(1000);
+is(cs.marginRight, "100px", "dynamic delay delay test at 1800ms (1)");
+div.style.animationDelay = "1.5s";
+is_approx(px_to_num(cs.marginRight), 100 * gTF.ease_out(0.3), 0.01,
+          "dynamic delay delay test at 1800ms (2)");
+div.style.animationDelay = "2s";
+is(cs.marginRight, "0px", "dynamic delay delay test at 1800ms (3)");
 done_div();
 
 // test delay and play-state interaction
 new_div("animation: anim2 1s 0.5s ease-out");
 is(cs.marginRight, "0px", "delay and play-state delay test at 0ms");
 advance_clock(400);
 is(cs.marginRight, "0px", "delay and play-state delay test at 400ms");
 div.style.animationPlayState = "paused";
