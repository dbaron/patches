From: L. David Baron <dbaron@dbaron.org>

Fix missing UngetToken() calls in ParseCounterData(), and avoid evil CheckEndProperty() calls while I'm there.

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -10748,38 +10748,43 @@ bool
 CSSParserImpl::ParseCounterData(nsCSSProperty aPropID)
 {
   static const nsCSSKeyword kCounterDataKTable[] = {
     eCSSKeyword_none,
     eCSSKeyword_UNKNOWN
   };
   nsCSSValue value;
   if (!ParseVariant(value, VARIANT_INHERIT | VARIANT_NONE, nullptr)) {
-    if (!GetToken(true) || mToken.mType != eCSSToken_Ident) {
+    if (!GetToken(true)) {
+      return false;
+    }
+    if (mToken.mType != eCSSToken_Ident) {
+      UngetToken();
       return false;
     }
 
     nsCSSValuePairList *cur = value.SetPairListValue();
     for (;;) {
       if (!ParseCustomIdent(cur->mXValue, mToken.mIdent, kCounterDataKTable)) {
         return false;
       }
       if (!GetToken(true)) {
         break;
       }
       if (mToken.mType == eCSSToken_Number && mToken.mIntegerValid) {
         cur->mYValue.SetIntValue(mToken.mInteger, eCSSUnit_Integer);
       } else {
         UngetToken();
       }
-      if (CheckEndProperty()) {
-        break;
-      }
-      if (!GetToken(true) || mToken.mType != eCSSToken_Ident) {
-        return false;
+      if (!GetToken(true)) {
+        break;
+      }
+      if (mToken.mType != eCSSToken_Ident) {
+        UngetToken();
+        break;
       }
       cur->mNext = new nsCSSValuePairList;
       cur = cur->mNext;
     }
   }
   AppendValue(aPropID, value);
   return true;
 }
diff --git a/layout/style/test/property_database.js b/layout/style/test/property_database.js
--- a/layout/style/test/property_database.js
+++ b/layout/style/test/property_database.js
@@ -26,19 +26,23 @@ const CSS_TYPE_SHORTHAND_AND_LONGHAND = 
 //	   another property, and this is a function used to get it
 //	 initial_values: Values whose computed value should be the same as the
 //	   computed value for the property's initial value.
 //	 other_values: Values whose computed value should be different from the
 //	   computed value for the property's initial value.
 //	 XXX Should have a third field for values whose computed value may or
 //	   may not be the same as for the property's initial value.
 //	 invalid_values: Things that are not values for the property and
-//	   should be rejected.
+//	   should be rejected, but which are balanced and should not absorb
+//	   what follows
 //	 quirks_values: Values that should be accepted in quirks mode only,
 //	   mapped to the values they are equivalent to.
+//	 unbalanced_values: Things that are not values for the property and
+//	   should be rejected, and which also contain unbalanced constructs
+//	   that should absorb what follows
 
 // Helper functions used to construct gCSSProperties.
 
 function initial_font_family_is_sans_serif()
 {
 	// The initial value of 'font-family' might be 'serif' or
 	// 'sans-serif'.
 	var div = document.createElement("div");
@@ -2360,17 +2364,18 @@ var gCSSProperties = {
 		invalid_values: [ 'counters(foo)', 'counter(foo, ".")', 'attr("title")', "attr('title')", "attr(2)", "attr(-2)", "counter(2)", "counters(-2, '.')", "-moz-alt-content 'foo'", "'foo' -moz-alt-content" ]
 	},
 	"counter-increment": {
 		domProp: "counterIncrement",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "none" ],
 		other_values: [ "foo 1", "bar", "foo 3 bar baz 2", "\\32  1", "-\\32  1", "-c 1", "\\32 1", "-\\32 1", "\\2  1", "-\\2  1", "-c 1", "\\2 1", "-\\2 1", "-\\7f \\9e 1" ],
-		invalid_values: [ "none foo", "none foo 3", "foo none", "foo 3 none" ]
+		invalid_values: [ "none foo", "none foo 3", "foo none", "foo 3 none" ],
+		unbalanced_values: [ "foo 1 (" ]
 	},
 	"counter-reset": {
 		domProp: "counterReset",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "none" ],
 		other_values: [ "foo 1", "bar", "foo 3 bar baz 2", "\\32  1", "-\\32  1", "-c 1", "\\32 1", "-\\32 1", "\\2  1", "-\\2  1", "-c 1", "\\2 1", "-\\2 1", "-\\7f \\9e 1" ],
 		invalid_values: [ "none foo", "none foo 3", "foo none", "foo 3 none" ]
diff --git a/layout/style/test/test_property_syntax_errors.html b/layout/style/test/test_property_syntax_errors.html
--- a/layout/style/test/test_property_syntax_errors.html
+++ b/layout/style/test/test_property_syntax_errors.html
@@ -36,35 +36,62 @@ function check_not_accepted(decl, proper
          "invalid value '" + badval + "' not accepted for '" + property +
          "' property when testing subproperty '" + subprop + "'");
     }
   }
 
   decl.removeProperty(property);
 }
 
+function check_value_balanced(decl, property, badval)
+{
+  var goodProp =
+    (property == "background-color") ? "color" : "background-color";
+  decl.cssText = goodProp + ": red; " + property + ": " + badval + "; " +
+                 goodProp + ": green";
+  is(decl.getPropertyValue(goodProp), "green",
+     "invalid value '" + property + ": " + badval +
+     "' is balanced and does not lead to parsing errors afterwards");
+  decl.cssText = "";
+}
+
+function check_value_unbalanced(decl, property, badval)
+{
+  var goodProp =
+    (property == "background-color") ? "color" : "background-color";
+  decl.cssText = goodProp + ": green; " + property + ": " + badval + "; " +
+                 goodProp + ": red";
+  is(decl.getPropertyValue(goodProp), "green",
+     "invalid value '" + property + ": " + badval +
+     "' is unbalanced and absorbs what follows it");
+  decl.cssText = "";
+}
+
 function run()
 {
   var gDeclaration = document.getElementById("testnode").style;
   var gQuirksDeclaration = document.getElementById("quirks").contentDocument
                              .getElementById("testnode").style;
 
   for (var property in gCSSProperties) {
     var info = gCSSProperties[property];
     for (var idx in info.invalid_values) {
       check_not_accepted(gDeclaration, property, info,
                          info.invalid_values[idx]);
       check_not_accepted(gQuirksDeclaration, property, info,
                          info.invalid_values[idx]);
+      check_value_balanced(gDeclaration, property,
+                           info.invalid_values[idx]);
     }
 
     if ("quirks_values" in info) {
       for (var quirkval in info.quirks_values) {
         var standardval = info.quirks_values[quirkval];
         check_not_accepted(gDeclaration, property, info, quirkval);
+        check_value_balanced(gDeclaration, property, quirkval);
 
         gQuirksDeclaration.setProperty(property, quirkval, "");
         gDeclaration.setProperty(property, standardval, "");
         var quirkret = gQuirksDeclaration.getPropertyValue(property);
         var standardret = gDeclaration.getPropertyValue(property);
         isnot(quirkret, "", property + ": " + quirkval +
                             " should be accepted in quirks mode");
         is(quirkret, standardret, property + ": " + quirkval + " result");
@@ -81,16 +108,25 @@ function run()
                                       " when testing subproperty " + subprop);
           }
         }
 
         gQuirksDeclaration.removeProperty(property);
         gDeclaration.removeProperty(property);
       }
     }
+
+    for (var idx in info.unbalanced_values) {
+      check_not_accepted(gDeclaration, property, info,
+                         info.invalid_values[idx]);
+      check_not_accepted(gQuirksDeclaration, property, info,
+                         info.invalid_values[idx]);
+      check_value_unbalanced(gDeclaration, property,
+                             info.unbalanced_values[idx]);
+    }
   }
 
   SimpleTest.finish();
 }
 
 </script>
 </pre>
 </body>
