From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch 12 - Instead of using the full style covered by the cover rule as the parent style for descendents when we've tried starting transitions, use the after-change style.  r=birtles

This switches to the new rules for how transitions start on descendants
when also starting on ancestors.

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -374,25 +374,30 @@ nsTransitionManager::StyleContextChanged
     }
   }
 
   if (collection) {
     // Set the style rule refresh time to null so that EnsureStyleRuleFor
     // creates a new style rule if we started *or* stopped transitions.
     collection->mStyleRuleRefreshTime = TimeStamp();
     collection->UpdateCheckGeneration(mPresContext);
+    collection->mNeedsRefreshes = true;
+    TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+    collection->EnsureStyleRuleFor(now, EnsureStyleRule_IsNotThrottled);
   }
 
-  // Replace the new style context by appending the cover rule.
-  nsCOMArray<nsIStyleRule> rules;
-  if (startedAny) {
-    rules.AppendObject(coverRule);
+  // We want to replace the new style context with the after-change style.
+  *aNewStyleContext = afterChangeStyle;
+  if (collection) {
+    // Since we have transition styles, we have to undo this replacement.
+    // The check of collection->mCheckGeneration against the restyle
+    // manager's GetAnimationGeneration() will ensure that we don't go
+    // through the rest of this function again when we do.
+    collection->PostRestyleForAnimation(mPresContext);
   }
-  *aNewStyleContext = mPresContext->StyleSet()->
-                        ResolveStyleByAddingRules(*aNewStyleContext, rules);
 }
 
 void
 nsTransitionManager::ConsiderStartingTransition(
   nsCSSProperty aProperty,
   const StyleTransition& aTransition,
   dom::Element* aElement,
   AnimationPlayerCollection*& aElementTransitions,
@@ -469,18 +474,16 @@ nsTransitionManager::ConsiderStartingTra
   MOZ_ASSERT(!oldPT || oldPT->Properties()[0].mSegments.Length() == 1,
              "Should have one animation property segment for a transition");
   if (haveCurrentTransition && haveValues &&
       oldPT->Properties()[0].mSegments[0].mToValue == endValue) {
     // GetAnimationRule already called RestyleForAnimation.
     return;
   }
 
-  nsPresContext *presContext = aNewStyleContext->PresContext();
-
   if (!shouldAnimate) {
     if (haveCurrentTransition) {
       // We're in the middle of a transition, and just got a non-transition
       // style change to something that we can't animate.  This might happen
       // because we got a non-transition style change changing to the current
       // in-progress value (which is particularly easy to cause when we're
       // currently in the 'transition-delay').  It also might happen because we
       // just got a style change to a value that can't be interpolated.
@@ -607,17 +610,16 @@ nsTransitionManager::ConsiderStartingTra
     players[currentIndex] = player;
   } else {
     if (!players.AppendElement(player)) {
       NS_WARNING("out of memory");
       return;
     }
   }
   aElementTransitions->UpdateAnimationGeneration(mPresContext);
-  aElementTransitions->PostRestyleForAnimation(presContext);
 
   *aStartedAny = true;
   aWhichStarted->AddProperty(aProperty);
 }
 
 /*
  * nsIStyleRuleProcessor implementation
  */
diff --git a/layout/style/test/test_transitions.html b/layout/style/test/test_transitions.html
--- a/layout/style/test/test_transitions.html
+++ b/layout/style/test/test_transitions.html
@@ -222,24 +222,23 @@ function make_reset_test(transition, des
     div.appendChild(p);
     is(getComputedStyle(p, "").marginLeft, "0px",
        "should be zero before changing value");
     return p;
 }
 var reset_test = make_reset_test("4s margin-left ease-out 4s", "transition-delay reset to starting point");
 var reset_test_reference = make_reset_test("4s margin-left linear -3s", "reference for previous test (reset test)");
 
-// Test that transitions on descendants do not trigger when the
+// Test that transitions on descendants start correctly when the
 // inherited value is itself transitioning.  In other words, when
 // ancestor and descendant both have a transition for the same property,
 // and the descendant inherits the property from the ancestor, the
-// descendant's transition is ignored (as part of the idea of not
-// starting transitions on changes that result from animation).
-// See http://lists.w3.org/Archives/Public/www-style/2009Jun/0121.html
-// and http://lists.w3.org/Archives/Public/www-style/2009Jul/0050.html
+// descendant's transition starts as specified, based on the concepts of
+// the before-change style, the after-change style, and the
+// after-transition style.
 var descendant_tests = [
     { parent_transition: "",
       child_transition: "4s text-indent" },
     { parent_transition: "4s text-indent",
       child_transition: "" },
     { parent_transition: "4s text-indent",
       child_transition: "16s text-indent" },
     { parent_transition: "4s text-indent",
@@ -637,16 +636,18 @@ add_future_call(6, check_descendant_test
 function check_descendant_tests() {
     // text-indent: transition from 50px to 150px
     // letter-spacing: transition from 10px to 5px
     var values = {};
     values["text-indent"] = [ 50, 150 ];
     values["letter-spacing"] = [ 10, 5 ];
     var tf = timingFunctions["ease"];
 
+    var time = px_to_num(earlyrefcs.textIndent) / 125;
+
     for (var i in descendant_tests) {
         var test = descendant_tests[i];
 
         /* ti=text-indent, ls=letter-spacing */
         var child_ti_duration = 0;
         var child_ls_duration = 0;
         var child_ti_delay = 0;
         var child_ls_delay = 0;
@@ -674,21 +675,23 @@ function check_descendant_tests() {
             var delay = (props.length > 2) ? parseInt(props[2]) : 0;
             var property = props[1];
             if (property != "text-indent" && property != "letter-spacing" &&
                 property != "all") {
                 ok(false, "fix this test (unexpected transition-property " +
                           property + " on child)");
             }
 
-            if (property != "letter-spacing" && child_ti_duration == 0) {
+            // Override the parent's transition with the child's as long
+            // as the child transition is still running.
+            if (property != "letter-spacing" && duration + delay > time) {
                 child_ti_duration = duration;
                 child_ti_delay = delay;
             }
-            if (property != "text-indent" && child_ls_duration == 0) {
+            if (property != "text-indent" && duration + delay > time) {
                 child_ls_duration = duration;
                 child_ls_delay = delay;
             }
         }
 
         var time_portions = {
           "text-indent":
             { duration: child_ti_duration, delay: child_ti_delay },
