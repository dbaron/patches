From: L. David Baron <dbaron@dbaron.org>

Bug 1089417 patch 6 - Save the previous media query cache key on the rule processor.

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -3029,16 +3029,20 @@ nsCSSRuleProcessor::AppendFontFeatureVal
   }
 
   return true;
 }
 
 nsresult
 nsCSSRuleProcessor::ClearRuleCascades()
 {
+  if (!mPreviousCacheKey) {
+    mPreviousCacheKey = Move(SaveMQCacheKey());
+  }
+
   // We rely on our caller (perhaps indirectly) to do something that
   // will rebuild style data and the user font set (either
   // nsIPresShell::ReconstructStyleData or
   // nsPresContext::RebuildAllStyleData).
   RuleCascadeData *data = mRuleCascades;
   mRuleCascades = nullptr;
   while (data) {
     RuleCascadeData *next = data->mNext;
@@ -3554,16 +3558,21 @@ nsCSSRuleProcessor::RefreshRuleCascade(n
       *cascadep = cascade->mNext;
       cascade->mNext = mRuleCascades;
       mRuleCascades = cascade;
 
       return;
     }
   }
 
+  // We're going to make a new rule cascade; this means that we should
+  // now stop using the previous cache key that we're holding on to from
+  // the last time we had rule cascades.
+  mPreviousCacheKey = nullptr;
+
   if (mSheets.Length() != 0) {
     nsAutoPtr<RuleCascadeData> newCascade(
       new RuleCascadeData(aPresContext->Medium(),
                           eCompatibility_NavQuirks == aPresContext->CompatibilityMode()));
     if (newCascade) {
       CascadeEnumData data(aPresContext, newCascade->mFontFaceRules,
                            newCascade->mKeyframesRules,
                            newCascade->mFontFeatureValuesRules,
diff --git a/layout/style/nsCSSRuleProcessor.h b/layout/style/nsCSSRuleProcessor.h
--- a/layout/style/nsCSSRuleProcessor.h
+++ b/layout/style/nsCSSRuleProcessor.h
@@ -199,16 +199,21 @@ private:
   void ClearSheets();
 
   // The sheet order here is the same as in nsStyleSet::mSheets
   sheet_array_type mSheets;
 
   // active first, then cached (most recent first)
   RuleCascadeData* mRuleCascades;
 
+  // If we cleared our mRuleCascades or replaced a previous rule
+  // processor, this is the media query result cache key that was used
+  // before we lost the old rule cascades.
+  mozilla::UniquePtr<nsMediaQueryResultCacheKey> mPreviousCacheKey;
+
   // The last pres context for which GetRuleCascades was called.
   nsPresContext *mLastPresContext;
 
   // The scope element for this rule processor's scoped style sheets.
   // Only used if mSheetType == nsStyleSet::eScopedDocSheet.
   nsRefPtr<mozilla::dom::Element> mScopeElement;
 
   // type of stylesheet using this processor
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -347,16 +347,17 @@ SortStyleSheetsByScope(nsTArray<CSSStyle
   for (uint32_t i = 0; i < n; i++) {
     aSheets[i] = sheets[i].mSheet;
   }
 }
 
 nsresult
 nsStyleSet::GatherRuleProcessors(sheetType aType)
 {
+  // FIXME
   mRuleProcessors[aType] = nullptr;
   if (aType == eScopedDocSheet) {
     for (uint32_t i = 0; i < mScopedDocSheetRuleProcessors.Length(); i++) {
       nsIStyleRuleProcessor* processor = mScopedDocSheetRuleProcessors[i].get();
       Element* scope =
         static_cast<nsCSSRuleProcessor*>(processor)->GetScopeElement();
       scope->ClearIsScopedStyleRoot();
     }
@@ -395,16 +396,17 @@ nsStyleSet::GatherRuleProcessors(sheetTy
       mRuleProcessors[aType] =
         PresContext()->Document()->GetSVGAttrAnimationRuleProcessor();
       return NS_OK;
     default:
       // keep going
       break;
   }
   if (aType == eScopedDocSheet) {
+    // FIXME
     // Create a rule processor for each scope.
     uint32_t count = mSheets[eScopedDocSheet].Count();
     if (count) {
       // Gather the scoped style sheets into an array as
       // CSSStyleSheets, and mark all of their scope elements
       // as scoped style roots.
       nsTArray<CSSStyleSheet*> sheets(count);
       for (uint32_t i = 0; i < count; i++) {
@@ -451,16 +453,17 @@ nsStyleSet::GatherRuleProcessors(sheetTy
         // levels containing CSS stylesheets (apart from eScopedDocSheet)
         nsCOMArray<nsIStyleSheet>& sheets = mSheets[aType];
         nsTArray<nsRefPtr<CSSStyleSheet>> cssSheets(sheets.Count());
         for (int32_t i = 0, i_end = sheets.Count(); i < i_end; ++i) {
           nsRefPtr<CSSStyleSheet> cssSheet = do_QueryObject(sheets[i]);
           NS_ASSERTION(cssSheet, "not a CSS sheet");
           cssSheets.AppendElement(cssSheet);
         }
+        // FIXME
         mRuleProcessors[aType] =
           new nsCSSRuleProcessor(cssSheets, uint8_t(aType), nullptr);
       } break;
 
       default:
         // levels containing non-CSS stylesheets
         NS_ASSERTION(mSheets[aType].Count() == 1, "only one sheet per level");
         mRuleProcessors[aType] = do_QueryInterface(mSheets[aType][0]);
