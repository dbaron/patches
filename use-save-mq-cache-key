From: L. David Baron <dbaron@dbaron.org>

Bug 1089417 patch 7 - Save the previous media query cache key on the rule processor.

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1087,16 +1087,17 @@ RuleCascadeData::AttributeListFor(nsIAto
 
 nsCSSRuleProcessor::nsCSSRuleProcessor(const sheet_array_type& aSheets,
                                        uint8_t aSheetType,
                                        Element* aScopeElement,
                                        nsCSSRuleProcessor*
                                          aPreviousCSSRuleProcessor)
   : mSheets(aSheets)
   , mRuleCascades(nullptr)
+  , mPreviousCacheKey(Move(aPreviousCSSRuleProcessor->SaveMQCacheKey()))
   , mLastPresContext(nullptr)
   , mScopeElement(aScopeElement)
   , mSheetType(aSheetType)
 {
   NS_ASSERTION(!!mScopeElement == (aSheetType == nsStyleSet::eScopedDocSheet),
                "aScopeElement must be specified iff aSheetType is "
                "eScopedDocSheet");
   for (sheet_array_type::size_type i = mSheets.Length(); i-- != 0; ) {
@@ -3031,16 +3032,20 @@ nsCSSRuleProcessor::AppendFontFeatureVal
   }
 
   return true;
 }
 
 nsresult
 nsCSSRuleProcessor::ClearRuleCascades()
 {
+  if (!mPreviousCacheKey) {
+    mPreviousCacheKey = Move(SaveMQCacheKey());
+  }
+
   // We rely on our caller (perhaps indirectly) to do something that
   // will rebuild style data and the user font set (either
   // nsIPresShell::ReconstructStyleData or
   // nsPresContext::RebuildAllStyleData).
   RuleCascadeData *data = mRuleCascades;
   mRuleCascades = nullptr;
   while (data) {
     RuleCascadeData *next = data->mNext;
@@ -3556,16 +3561,21 @@ nsCSSRuleProcessor::RefreshRuleCascade(n
       *cascadep = cascade->mNext;
       cascade->mNext = mRuleCascades;
       mRuleCascades = cascade;
 
       return;
     }
   }
 
+  // We're going to make a new rule cascade; this means that we should
+  // now stop using the previous cache key that we're holding on to from
+  // the last time we had rule cascades.
+  mPreviousCacheKey = nullptr;
+
   if (mSheets.Length() != 0) {
     nsAutoPtr<RuleCascadeData> newCascade(
       new RuleCascadeData(aPresContext->Medium(),
                           eCompatibility_NavQuirks == aPresContext->CompatibilityMode()));
     if (newCascade) {
       CascadeEnumData data(aPresContext, newCascade->mFontFaceRules,
                            newCascade->mKeyframesRules,
                            newCascade->mFontFeatureValuesRules,
diff --git a/layout/style/nsCSSRuleProcessor.h b/layout/style/nsCSSRuleProcessor.h
--- a/layout/style/nsCSSRuleProcessor.h
+++ b/layout/style/nsCSSRuleProcessor.h
@@ -202,16 +202,21 @@ private:
   void ClearSheets();
 
   // The sheet order here is the same as in nsStyleSet::mSheets
   sheet_array_type mSheets;
 
   // active first, then cached (most recent first)
   RuleCascadeData* mRuleCascades;
 
+  // If we cleared our mRuleCascades or replaced a previous rule
+  // processor, this is the media query result cache key that was used
+  // before we lost the old rule cascades.
+  mozilla::UniquePtr<nsMediaQueryResultCacheKey> mPreviousCacheKey;
+
   // The last pres context for which GetRuleCascades was called.
   nsPresContext *mLastPresContext;
 
   // The scope element for this rule processor's scoped style sheets.
   // Only used if mSheetType == nsStyleSet::eScopedDocSheet.
   nsRefPtr<mozilla::dom::Element> mScopeElement;
 
   // type of stylesheet using this processor
