From: Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, L. David Baron <dbaron@dbaron.org>

Implement CSS transitions: implement the parsing and computation of the transition properties.  (Bug 435441)

diff --git a/dom/interfaces/css/nsIDOMNSCSS2Properties.idl b/dom/interfaces/css/nsIDOMNSCSS2Properties.idl
--- a/dom/interfaces/css/nsIDOMNSCSS2Properties.idl
+++ b/dom/interfaces/css/nsIDOMNSCSS2Properties.idl
@@ -17,16 +17,17 @@
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 2000
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Vidur Apparao <vidur@netscape.com> (original author)
  *   Johnny Stenback <jst@netscape.com>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -34,17 +35,17 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsIDOMCSS2Properties.idl"
 
-[scriptable, uuid(e7245a21-3f46-4e67-82bf-a9b326fe74ee)]
+[scriptable, uuid(73902da2-9475-4e96-b0ed-85003721cf37)]
 interface nsIDOMNSCSS2Properties : nsIDOMCSS2Properties
 {
            /* Non-DOM 2 extensions */
 
            /* Mozilla extension CSS properties */
            attribute DOMString        MozAppearance;
                                         // raises(DOMException) on setting
 
@@ -251,10 +252,25 @@ interface nsIDOMNSCSS2Properties : nsIDO
            attribute DOMString        MozTransform;
                                         // raises(DOMException) on setting
 
            attribute DOMString        MozTransformOrigin;
                                         // raises(DOMException) on setting 
 
            attribute DOMString        MozWindowShadow;
                                         // raises(DOMException) on setting
-	
+
+           attribute DOMString        MozTransitionProperty;
+                                        // raises(DOMException) on setting
+
+           attribute DOMString        MozTransitionDuration;
+                                        // raises(DOMException) on setting
+
+           attribute DOMString        MozTransitionDelay;
+                                        // raises(DOMException) on setting
+
+           attribute DOMString        MozTransitionTimingFunction;
+                                        // raises(DOMException) on setting
+
+           attribute DOMString        MozTransition;
+                                        // raises(DOMException) on setting
+
 };
diff --git a/layout/base/nsStyleConsts.h b/layout/base/nsStyleConsts.h
--- a/layout/base/nsStyleConsts.h
+++ b/layout/base/nsStyleConsts.h
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -608,16 +609,23 @@
 #define NS_STYLE_TEXT_DECORATION_LINES_MASK     (NS_STYLE_TEXT_DECORATION_UNDERLINE | NS_STYLE_TEXT_DECORATION_OVERLINE | NS_STYLE_TEXT_DECORATION_LINE_THROUGH)
 
 // See nsStyleText
 #define NS_STYLE_TEXT_TRANSFORM_NONE            0
 #define NS_STYLE_TEXT_TRANSFORM_CAPITALIZE      1
 #define NS_STYLE_TEXT_TRANSFORM_LOWERCASE       2
 #define NS_STYLE_TEXT_TRANSFORM_UPPERCASE       3
 
+// See nsStyleDisplay
+#define NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE         0
+#define NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR       1
+#define NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN      2
+#define NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT     3
+#define NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT  4
+
 // See nsStyleText
 // Note: these values pickup after the text-align values because there
 // are a few html cases where an object can have both types of
 // alignment applied with a single attribute
 #define NS_STYLE_VERTICAL_ALIGN_BASELINE             11
 #define NS_STYLE_VERTICAL_ALIGN_SUB                  12
 #define NS_STYLE_VERTICAL_ALIGN_SUPER                13
 #define NS_STYLE_VERTICAL_ALIGN_TOP                  14
diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -17,16 +17,17 @@
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Daniel Glazman <glazman@netscape.com>
  *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -242,48 +243,53 @@ nsCSSDeclaration::AppendCSSValueToString
     nsAutoString  buffer;
     aValue.GetStringValue(buffer);
     if (unit == eCSSUnit_String) {
       nsStyleUtil::AppendEscapedCSSString(buffer, aResult);
     } else {
       aResult.Append(buffer);
     }
   }
-  else if (eCSSUnit_Array <= unit && unit <= eCSSUnit_Counters) {
+  else if (eCSSUnit_Array <= unit && unit <= eCSSUnit_Cubic_Bezier) {
     switch (unit) {
       case eCSSUnit_Counter:  aResult.AppendLiteral("counter(");  break;
       case eCSSUnit_Counters: aResult.AppendLiteral("counters("); break;
+      case eCSSUnit_Cubic_Bezier: aResult.AppendLiteral("cubic-bezier("); break;
       default: break;
     }
 
     nsCSSValue::Array *array = aValue.GetArrayValue();
     PRBool mark = PR_FALSE;
     for (PRUint16 i = 0, i_end = array->Count(); i < i_end; ++i) {
       if (aProperty == eCSSProperty_border_image && i >= 5) {
         if (array->Item(i).GetUnit() == eCSSUnit_Null) {
           continue;
         }
         if (i == 5) {
           aResult.AppendLiteral(" /");
         }
       }
       if (mark && array->Item(i).GetUnit() != eCSSUnit_Null) {
-        if (unit == eCSSUnit_Array)
+        if (unit == eCSSUnit_Array &&
+            eCSSProperty_transition_timing_function != aProperty)
           aResult.AppendLiteral(" ");
         else
           aResult.AppendLiteral(", ");
       }
       nsCSSProperty prop =
         ((eCSSUnit_Counter <= unit && unit <= eCSSUnit_Counters) &&
          i == array->Count() - 1)
         ? eCSSProperty_list_style_type : aProperty;
       if (AppendCSSValueToString(prop, array->Item(i), aResult)) {
         mark = PR_TRUE;
       }
     }
+    if (eCSSUnit_Array == unit && aProperty == eCSSProperty_transition_timing_function) {
+      aResult.AppendLiteral(")");
+    }
   }
   /* Although Function is backed by an Array, we'll handle it separately
    * because it's a bit quirky.
    */
   else if (eCSSUnit_Function == unit) {
     const nsCSSValue::Array* array = aValue.GetArrayValue();
     NS_ASSERTION(array->Count() >= 1, "Functions must have at least one element for the name.");
 
@@ -341,16 +347,19 @@ nsCSSDeclaration::AppendCSSValueToString
       }
       if ((NS_STYLE_PAGE_MARKS_REGISTER & intValue) != 0) {
         if ((NS_STYLE_PAGE_MARKS_CROP & intValue) != 0) {
           aResult.Append(PRUnichar(' '));
         }
         AppendASCIItoUTF16(nsCSSProps::LookupPropertyValue(aProperty, NS_STYLE_PAGE_MARKS_REGISTER), aResult);
       }
     }
+    else if (eCSSProperty_transition_property == aProperty) {
+      AppendASCIItoUTF16(nsCSSProps::GetStringValue((nsCSSProperty) aValue.GetIntValue()), aResult);
+    }
     else {
       const nsAFlatCString& name = nsCSSProps::LookupPropertyValue(aProperty, aValue.GetIntValue());
       AppendASCIItoUTF16(name, aResult);
     }
   }
   else if (eCSSUnit_EnumColor == unit) {
     // we can lookup the property in the ColorTable and then
     // get a string mapping the name
@@ -412,29 +421,31 @@ nsCSSDeclaration::AppendCSSValueToString
   switch (unit) {
     case eCSSUnit_Null:         break;
     case eCSSUnit_Auto:         aResult.AppendLiteral("auto");     break;
     case eCSSUnit_Inherit:      aResult.AppendLiteral("inherit");  break;
     case eCSSUnit_Initial:      aResult.AppendLiteral("-moz-initial"); break;
     case eCSSUnit_None:         aResult.AppendLiteral("none");     break;
     case eCSSUnit_Normal:       aResult.AppendLiteral("normal");   break;
     case eCSSUnit_System_Font:  aResult.AppendLiteral("-moz-use-system-font"); break;
+    case eCSSUnit_All:          aResult.AppendLiteral("all"); break;
     case eCSSUnit_Dummy:
     case eCSSUnit_DummyInherit:
     case eCSSUnit_RectIsAuto:
       NS_NOTREACHED("should never serialize");
       break;
 
     case eCSSUnit_String:       break;
     case eCSSUnit_Ident:        break;
     case eCSSUnit_Families:     break;
     case eCSSUnit_URL:          break;
     case eCSSUnit_Image:        break;
     case eCSSUnit_Array:        break;
     case eCSSUnit_Attr:
+    case eCSSUnit_Cubic_Bezier:
     case eCSSUnit_Counter:
     case eCSSUnit_Counters:     aResult.Append(PRUnichar(')'));    break;
     case eCSSUnit_Local_Font:   break;
     case eCSSUnit_Font_Format:  break;
     case eCSSUnit_Function:     break;
     case eCSSUnit_Integer:      break;
     case eCSSUnit_Enumerated:   break;
     case eCSSUnit_EnumColor:    break;
@@ -942,16 +953,52 @@ nsCSSDeclaration::GetValue(nsCSSProperty
     case eCSSProperty_pause: {
       if (AppendValueToString(eCSSProperty_pause_before, aValue)) {
         aValue.Append(PRUnichar(' '));
         if (!AppendValueToString(eCSSProperty_pause_after, aValue))
           aValue.Truncate();
       }
       break;
     }
+    case eCSSProperty_transition: {
+      const nsCSSProperty* subprops =
+        nsCSSProps::SubpropertyEntryFor(aProperty);
+      NS_ASSERTION(nsCSSProps::kTypeTable[subprops[0]] == eCSSType_ValueList &&
+                   nsCSSProps::kTypeTable[subprops[1]] == eCSSType_ValueList &&
+                   nsCSSProps::kTypeTable[subprops[2]] == eCSSType_ValueList &&
+                   nsCSSProps::kTypeTable[subprops[3]] == eCSSType_ValueList &&
+                   subprops[4] == eCSSProperty_UNKNOWN,
+                   "type mismatch");
+      const nsCSSValueList* val[4];
+      for (int i = 0; i < 4; ++i) {
+        val[i] = *data->ValueListStorageFor(subprops[i]);
+      }
+      // Merge the lists of the subproperties into a single list.
+      for (;;) {
+        for (int i = 0; i < 4; ++i) {
+          AppendCSSValueToString(subprops[i], val[i]->mValue, aValue);
+          aValue.Append(PRUnichar(' '));
+          val[i] = val[i]->mNext;
+        }
+        // Remove the last space.
+        aValue.Truncate(aValue.Length() - 1);
+
+        if (!val[0] || !val[1] || !val[2] || !val[3]) {
+          break;
+        }
+        aValue.AppendLiteral(", ");
+      }
+      if (val[0] || val[1] || val[2] || val[3]) {
+        // The sublists are different lengths, so this can't be
+        // represented as the shorthand.
+        aValue.Truncate();
+      }
+      break;
+    }
+
 #ifdef MOZ_SVG
     case eCSSProperty_marker: {
       const nsCSSValue &endValue =
         *data->ValueStorageFor(eCSSProperty_marker_end);
       const nsCSSValue &midValue =
         *data->ValueStorageFor(eCSSProperty_marker_mid);
       const nsCSSValue &startValue =
         *data->ValueStorageFor(eCSSProperty_marker_start);
diff --git a/layout/style/nsCSSKeywordList.h b/layout/style/nsCSSKeywordList.h
--- a/layout/style/nsCSSKeywordList.h
+++ b/layout/style/nsCSSKeywordList.h
@@ -257,16 +257,20 @@ CSS_KEY(deg, deg)
 CSS_KEY(dialog, dialog)
 CSS_KEY(digits, digits)
 CSS_KEY(disabled, disabled)
 CSS_KEY(disc, disc)
 CSS_KEY(dotted, dotted)
 CSS_KEY(double, double)
 CSS_KEY(e-resize, e_resize)
 CSS_KEY(each-box, each_box)
+CSS_KEY(ease, ease)
+CSS_KEY(ease-in, ease_in)
+CSS_KEY(ease-in-out, ease_in_out)
+CSS_KEY(ease-out, ease_out)
 CSS_KEY(element, element)
 CSS_KEY(elements, elements)
 CSS_KEY(em, em)
 CSS_KEY(embed, embed)
 CSS_KEY(enabled, enabled)
 CSS_KEY(end, end)
 CSS_KEY(ex, ex)
 CSS_KEY(expanded, expanded)
@@ -323,16 +327,17 @@ CSS_KEY(landscape, landscape)
 CSS_KEY(large, large)
 CSS_KEY(larger, larger)
 CSS_KEY(left, left)
 CSS_KEY(left-side, left_side)
 CSS_KEY(leftwards, leftwards)
 CSS_KEY(level, level)
 CSS_KEY(lighter, lighter)
 CSS_KEY(line-through, line_through)
+CSS_KEY(linear, linear)
 CSS_KEY(list-item, list_item)
 CSS_KEY(logical, logical)
 CSS_KEY(loud, loud)
 CSS_KEY(low, low)
 CSS_KEY(lower, lower)
 CSS_KEY(lower-alpha, lower_alpha)
 CSS_KEY(lower-greek, lower_greek)
 CSS_KEY(lower-latin, lower_latin)
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -21,16 +21,18 @@
  *
  * Contributor(s):
  *   emk <VYV03354@nifty.ne.jp>
  *   Daniel Glazman <glazman@netscape.com>
  *   L. David Baron <dbaron@dbaron.org>
  *   Boris Zbarsky <bzbarsky@mit.edu>
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   Christian Biesinger <cbiesinger@web.de>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
+ *   Siraj Razick <siraj.razick@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -101,16 +103,18 @@
 #define VARIANT_COUNTER         0x000800  //
 #define VARIANT_ATTR            0x001000  //
 #define VARIANT_IDENTIFIER      0x002000  // D
 #define VARIANT_AUTO            0x010000  // A
 #define VARIANT_INHERIT         0x020000  // H eCSSUnit_Initial, eCSSUnit_Inherit
 #define VARIANT_NONE            0x040000  // O
 #define VARIANT_NORMAL          0x080000  // M
 #define VARIANT_SYSFONT         0x100000  // eCSSUnit_System_Font
+#define VARIANT_CUBIC_BEZIER    0x200000  // CSS transition timing function
+#define VARIANT_ALL             0x400000  //
 
 // Common combinations of variants
 #define VARIANT_AL   (VARIANT_AUTO | VARIANT_LENGTH)
 #define VARIANT_LP   (VARIANT_LENGTH | VARIANT_PERCENT)
 #define VARIANT_AH   (VARIANT_AUTO | VARIANT_INHERIT)
 #define VARIANT_AHLP (VARIANT_AH | VARIANT_LP)
 #define VARIANT_AHI  (VARIANT_AH | VARIANT_INTEGER)
 #define VARIANT_AHK  (VARIANT_AH | VARIANT_KEYWORD)
@@ -136,16 +140,17 @@
 #define VARIANT_HCK  (VARIANT_HK | VARIANT_COLOR)
 #define VARIANT_HUO  (VARIANT_INHERIT | VARIANT_URL | VARIANT_NONE)
 #define VARIANT_AHUO (VARIANT_AUTO | VARIANT_HUO)
 #define VARIANT_HPN  (VARIANT_INHERIT | VARIANT_PERCENT | VARIANT_NUMBER)
 #define VARIANT_HOK  (VARIANT_HK | VARIANT_NONE)
 #define VARIANT_HN   (VARIANT_INHERIT | VARIANT_NUMBER)
 #define VARIANT_HON  (VARIANT_HN | VARIANT_NONE)
 #define VARIANT_HOS  (VARIANT_INHERIT | VARIANT_NONE | VARIANT_STRING)
+#define VARIANT_TIMING_FUNCTION (VARIANT_KEYWORD | VARIANT_CUBIC_BEZIER)
 
 //----------------------------------------------------------------------
 
 // Your basic top-down recursive descent style parser
 class CSSParserImpl : public nsICSSParser {
 public:
   CSSParserImpl();
   virtual ~CSSParserImpl();
@@ -460,16 +465,24 @@ protected:
   PRBool ParsePause();
   PRBool ParseQuotes();
   PRBool ParseSize();
   PRBool ParseTextDecoration(nsCSSValue& aValue);
 
   nsCSSValueList* ParseCSSShadowList(PRBool aIsBoxShadow);
   PRBool ParseTextShadow();
   PRBool ParseBoxShadow();
+  PRBool ParseTransitionTime(nsCSSProperty aPropID);
+  PRBool ParseTransitionProperty();
+  PRBool ParseTransition();
+  PRBool ParseTransitionTimingFunction();
+  PRBool ParseTransitionTimingFunctionValues(nsCSSValue& aValue);
+  PRBool ParseTransitionTimingFunctionValueComponent(float& aComponent, char aStop);
+  PRBool AppendValueToList(nsCSSValueList**& aListTail,
+                           const nsCSSValue& aValue);
 
 #ifdef MOZ_SVG
   PRBool ParsePaint(nsCSSValuePair* aResult,
                     nsCSSProperty aPropID);
   PRBool ParseDasharray();
   PRBool ParseMarker();
 #endif
 
@@ -4306,16 +4319,17 @@ CSSParserImpl::TranslateDimension(nsCSSV
   VARIANT_URL | \
   VARIANT_STRING | \
   VARIANT_COUNTER | \
   VARIANT_ATTR | \
   VARIANT_IDENTIFIER | \
   VARIANT_AUTO | \
   VARIANT_INHERIT | \
   VARIANT_NONE | \
+  VARIANT_ALL | \
   VARIANT_NORMAL | \
   VARIANT_SYSFONT
 
 PRBool
 CSSParserImpl::ParseNonNegativeVariant(nsCSSValue& aValue,
                                        PRInt32 aVariantMask,
                                        const PRInt32 aKeywordTable[])
 {
@@ -4384,17 +4398,17 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
   NS_ASSERTION(IsParsingCompoundProperty() ||
                ((~aVariantMask) & (VARIANT_LENGTH|VARIANT_COLOR)),
                "cannot distinguish lengths and colors in quirks mode");
 
   if (!GetToken(PR_TRUE)) {
     return PR_FALSE;
   }
   nsCSSToken* tk = &mToken;
-  if (((aVariantMask & (VARIANT_AHK | VARIANT_NORMAL | VARIANT_NONE)) != 0) &&
+  if (((aVariantMask & (VARIANT_AHK | VARIANT_NORMAL | VARIANT_NONE | VARIANT_ALL)) != 0) &&
       (eCSSToken_Ident == tk->mType)) {
     nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(tk->mIdent);
     if (eCSSKeyword_UNKNOWN < keyword) { // known keyword
       if ((aVariantMask & VARIANT_AUTO) != 0) {
         if (eCSSKeyword_auto == keyword) {
           aValue.SetAutoValue();
           return PR_TRUE;
         }
@@ -4413,16 +4427,22 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
         }
       }
       if ((aVariantMask & VARIANT_NONE) != 0) {
         if (eCSSKeyword_none == keyword) {
           aValue.SetNoneValue();
           return PR_TRUE;
         }
       }
+      if ((aVariantMask & VARIANT_ALL) != 0) {
+        if (eCSSKeyword_all == keyword) {
+          aValue.SetAllValue();
+          return PR_TRUE;
+        }
+      }
       if ((aVariantMask & VARIANT_NORMAL) != 0) {
         if (eCSSKeyword_normal == keyword) {
           aValue.SetNormalValue();
           return PR_TRUE;
         }
       }
       if ((aVariantMask & VARIANT_SYSFONT) != 0) {
         if (eCSSKeyword__moz_use_system_font == keyword &&
@@ -4531,16 +4551,23 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
        tk->mIdent.LowerCaseEqualsLiteral("counters"))) {
     return ParseCounter(aValue);
   }
   if (((aVariantMask & VARIANT_ATTR) != 0) &&
       (eCSSToken_Function == tk->mType) &&
       tk->mIdent.LowerCaseEqualsLiteral("attr")) {
     return ParseAttr(aValue);
   }
+  if (((aVariantMask & VARIANT_CUBIC_BEZIER) != 0) &&
+    (eCSSToken_Function == tk->mType)) {
+     if (tk->mIdent.LowerCaseEqualsLiteral("cubic-bezier")) {
+      UngetToken();
+      return ParseTransitionTimingFunctionValues(aValue);
+    }
+  }
 
   UngetToken();
   return PR_FALSE;
 }
 
 
 PRBool
 CSSParserImpl::ParseCounter(nsCSSValue& aValue)
@@ -5171,16 +5198,25 @@ CSSParserImpl::ParseProperty(nsCSSProper
   case eCSSProperty_size:
     return ParseSize();
   case eCSSProperty_text_shadow:
     return ParseTextShadow();
   case eCSSProperty__moz_transform:
     return ParseMozTransform();
   case eCSSProperty__moz_transform_origin:
     return ParseMozTransformOrigin();
+  case eCSSProperty_transition:
+      return ParseTransition();
+  case eCSSProperty_transition_property:
+    return ParseTransitionProperty();
+  case eCSSProperty_transition_timing_function:
+    return ParseTransitionTimingFunction();
+  case eCSSProperty_transition_duration:
+  case eCSSProperty_transition_delay:
+    return ParseTransitionTime(aPropID);
 
 #ifdef MOZ_SVG
   case eCSSProperty_fill:
     return ParsePaint(&mTempData.mSVG.mFill, eCSSProperty_fill);
   case eCSSProperty_stroke:
     return ParsePaint(&mTempData.mSVG.mStroke, eCSSProperty_stroke);
   case eCSSProperty_stroke_dasharray:
     return ParseDasharray();
@@ -5328,23 +5364,30 @@ CSSParserImpl::ParseSingleValueProperty(
   case eCSSProperty_padding_right:
   case eCSSProperty_padding_start:
   case eCSSProperty_pause:
   case eCSSProperty_quotes:
   case eCSSProperty_size:
   case eCSSProperty_text_shadow:
   case eCSSProperty__moz_transform:
   case eCSSProperty__moz_transform_origin:
+  case eCSSProperty_transition:
+  case eCSSProperty_transition_property:
+  case eCSSProperty_transition_timing_function:
+  case eCSSProperty_transition_duration:
+  case eCSSProperty_transition_delay:
   case eCSSProperty_COUNT:
 #ifdef MOZ_SVG
   case eCSSProperty_fill:
   case eCSSProperty_stroke:
   case eCSSProperty_stroke_dasharray:
   case eCSSProperty_marker:
 #endif
+  case eCSSPropertyExtra_no_properties:
+  case eCSSPropertyExtra_all_properties:
     NS_ERROR("not a single value property");
     return PR_FALSE;
 
   case eCSSProperty__x_system_font:
   case eCSSProperty_margin_left_ltr_source:
   case eCSSProperty_margin_left_rtl_source:
   case eCSSProperty_margin_right_ltr_source:
   case eCSSProperty_margin_right_rtl_source:
@@ -7943,16 +7986,390 @@ CSSParserImpl::ParseTextDecoration(nsCSS
       }
       aValue.SetIntValue(intValue, eCSSUnit_Enumerated);
     }
     return PR_TRUE;
   }
   return PR_FALSE;
 }
 
+
+PRBool
+CSSParserImpl::ParseTransitionTime(nsCSSProperty aPropID)
+{
+  NS_ABORT_IF_FALSE(aPropID == eCSSProperty_transition_duration ||
+                    aPropID == eCSSProperty_transition_delay,
+                    "Invalid property");
+  nsCSSValueList** storage =
+    aPropID == eCSSProperty_transition_duration
+      ? &mTempData.mDisplay.mTransitionDuration
+      : &mTempData.mDisplay.mTransitionDelay;
+                              
+  nsCSSValue timeval;
+  // first see if 'inherit' is specified.  If it is, it can be the only thing
+  // specified, so don't attempt to parse any additional properties
+  if (ParseVariant(timeval, VARIANT_INHERIT, nsnull)) {
+    nsCSSValueList* list = new nsCSSValueList();
+    if (!list) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      return PR_FALSE;
+    }
+    list->mValue = timeval;
+    mTempData.SetPropertyBit(aPropID);
+    *storage = list;
+    return PR_TRUE;
+  }
+
+  // now try to parse normal time values
+  nsCSSValueList *listHead = nsnull;
+  nsCSSValueList **next = &listHead;
+
+  for (;;) {
+    if (!ParseVariant(timeval, VARIANT_TIME, nsnull)) {
+      break;
+    }
+    nsCSSValueList *current;
+    *next = current = new nsCSSValueList();
+    if (!current) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    next = &current->mNext;
+    current->mValue = timeval;
+    if (ExpectEndProperty()) {
+      mTempData.SetPropertyBit(aPropID);
+      *storage = listHead;
+      return PR_TRUE;
+    }
+    if (!ExpectSymbol(',', PR_TRUE)) {
+      break;
+    }
+  }
+  delete listHead;
+  return PR_FALSE;
+}
+
+PRBool
+CSSParserImpl::ParseTransitionProperty()
+{
+  nsCSSValue value;
+  // first see if 'inherit' is specified.  If it is, it can be the only thing
+  // specified, so don't attempt to parse any additional properties
+  if (ParseVariant(value, VARIANT_INHERIT | VARIANT_NONE | VARIANT_ALL,
+                   nsnull)) {
+    nsCSSValueList* list = new nsCSSValueList();
+    if (!list) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      return PR_FALSE;
+    }
+    list->mValue = value;
+    mTempData.SetPropertyBit(eCSSProperty_transition_property);
+    mTempData.mDisplay.mTransitionProperty = list;
+    return PR_TRUE;
+  }
+
+  // Accept a list of arbitrary identifiers.  They should be CSS
+  // properties, but we want to accept any so that we accept properties
+  // that we don't know about yet, e.g.
+  // transition-property: invalid-property, left, opacity;
+  nsCSSValueList *listHead = nsnull;
+  nsCSSValueList **next = &listHead;
+
+  for (;;) {
+    if (!ParseVariant(value, VARIANT_IDENTIFIER, nsnull)) {
+      break;
+    }
+    // Exclude 'none' and 'all' and 'inherit' according to the same
+    // rules as for 'counter-reset'.
+    nsDependentString str(value.GetStringBufferValue());
+    if (str.EqualsLiteral("none") || str.EqualsLiteral("all") ||
+        str.EqualsLiteral("inherit") || str.EqualsLiteral("initial")) {
+      break;
+    }
+    
+    nsCSSValueList *current;
+    *next = current = new nsCSSValueList;
+    if (!current) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    current->mValue = value;
+    next = &current->mNext;
+    if (ExpectEndProperty()) {
+      mTempData.SetPropertyBit(eCSSProperty_transition_property);
+      mTempData.mDisplay.mTransitionProperty = listHead;
+      return PR_TRUE;
+    }
+    if (!ExpectSymbol(',', PR_TRUE)) {
+      break;
+    }
+  }
+  delete listHead;
+  return PR_FALSE;
+}
+
+PRBool
+CSSParserImpl::ParseTransitionTimingFunction()
+{
+  nsCSSValue timeFunction;
+  // first see if 'inherit' is specified.  If it is, it can be the only thing
+  // specified, so don't attempt to parse any additional properties
+  if (ParseVariant(timeFunction, VARIANT_INHERIT, nsnull)) {
+    nsCSSValueList* list = new nsCSSValueList();
+    if (!list) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      return PR_FALSE;
+    }
+    list->mValue = timeFunction;
+    mTempData.SetPropertyBit(eCSSProperty_transition_timing_function);
+    mTempData.mDisplay.mTransitionTimingFunction = list;
+    return PR_TRUE;
+  }
+
+  nsCSSValueList *listHead = nsnull;
+  nsCSSValueList **next = &listHead;
+
+  for (;;) {
+    if (!ParseVariant(timeFunction, VARIANT_TIMING_FUNCTION,
+                      nsCSSProps::kTransitionTimingFunctionKTable)) {
+      break;
+    }
+    nsCSSValueList *current;
+    *next = current = new nsCSSValueList();
+    if (!current) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    next = &current->mNext;
+    current->mValue = timeFunction;
+    if (ExpectEndProperty()) {
+      mTempData.SetPropertyBit(eCSSProperty_transition_timing_function);
+      mTempData.mDisplay.mTransitionTimingFunction = listHead;
+      return PR_TRUE;
+    }
+    if (!ExpectSymbol (',', PR_TRUE)) {
+      break;
+    }
+  }
+
+  delete listHead;
+  return PR_FALSE;
+}
+
+PRBool
+CSSParserImpl::ParseTransitionTimingFunctionValues(nsCSSValue& aValue)
+{
+  if (!GetToken(PR_TRUE)) {
+    REPORT_UNEXPECTED_EOF(PEColorEOF);
+    return PR_FALSE;
+  }
+
+  nsRefPtr<nsCSSValue::Array> val = nsCSSValue::Array::Create(4);
+  if (!val) {
+       mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+  }
+  float x1,x2,y1,y2;
+  nsCSSToken* tk = &mToken;
+
+  if (tk->mType == eCSSToken_Function){
+    if (ExpectSymbol('(',PR_FALSE)) {
+     ParseTransitionTimingFunctionValueComponent(x1,',');
+     ParseTransitionTimingFunctionValueComponent(y1,',');
+     ParseTransitionTimingFunctionValueComponent(x2,',');
+     ParseTransitionTimingFunctionValueComponent(y2,')');
+    }
+  }
+  
+  val->Item(0).SetFloatValue(x1, eCSSUnit_Number);
+  val->Item(1).SetFloatValue(y1, eCSSUnit_Number);
+  val->Item(2).SetFloatValue(x2, eCSSUnit_Number);
+  val->Item(3).SetFloatValue(y2, eCSSUnit_Number);
+
+  aValue.SetArrayValue(val, eCSSUnit_Cubic_Bezier);
+  
+  return PR_TRUE;
+}
+
+PRBool
+CSSParserImpl::ParseTransitionTimingFunctionValueComponent(float& aComponent,
+                                                           char aStop)
+{
+  if (!GetToken(PR_TRUE)) {
+    REPORT_UNEXPECTED_EOF(PEColorComponentEOF);
+    return PR_FALSE;
+  }
+  nsCSSToken* tk = &mToken;
+  if (tk->mType == eCSSToken_Number) {
+    aComponent = tk->mNumber;
+    if (ExpectSymbol(aStop,PR_TRUE)) {
+     return PR_TRUE;
+    }
+  }
+  return PR_FALSE;
+}
+
+PRBool
+CSSParserImpl::AppendValueToList(nsCSSValueList**& aListTail,
+                                 const nsCSSValue& aValue)
+{
+  NS_ABORT_IF_FALSE(!*aListTail, "should not have a next entry");
+  nsCSSValueList *entry = new nsCSSValueList();
+  if (!entry) {
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+    return PR_FALSE;
+  }
+  entry->mValue = aValue;
+  *aListTail = entry;
+  aListTail = &entry->mNext;
+  return PR_TRUE;
+}
+
+PRBool
+CSSParserImpl::ParseTransition()
+{
+  // FIXME: rewrite to use ParseChoice
+  // FIXME: figure out how to distinguish duration and delay (or just
+  // always make delay 0?)
+  // FIXME: Ensure that 'none' and 'all' are accepted only if there is
+  // one transition given.
+  static const nsCSSProperty kTransitionProperties[] = {
+    eCSSProperty_transition_duration,
+    eCSSProperty_transition_timing_function,
+    eCSSProperty_transition_delay,
+    // Always need to try property last since it accepts any keyword.
+    eCSSProperty_transition_property
+  };
+  static const PRSize numProps = NS_ARRAY_LENGTH(kTransitionProperties);
+  // this is a shorthand property that accepts -property, -delay,
+  // -duration, and -timing-function with some components missing.
+  // there can be multiple transitions, separated with commas
+
+  nsCSSValue tempValue;
+  // first see if 'inherit' is specified.  If it is, it can be the only thing
+  // specified, so don't attempt to parse any additional properties
+  if (ParseVariant(tempValue, VARIANT_INHERIT, nsnull)) {
+    for (PRSize i = 0; i < numProps; ++i) {
+      nsCSSValueList* list = new nsCSSValueList();
+      if (!list) {
+        mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+        return PR_FALSE;
+      }
+      list->mValue = tempValue;
+      nsCSSProperty prop = kTransitionProperties[i];
+      *static_cast<nsCSSValueList**>(mTempData.PropertyAt(prop)) = list;
+      mTempData.SetPropertyBit(prop);
+    }
+    return PR_TRUE;
+  }
+
+  nsAutoPtr<nsCSSValueList> values[numProps];
+  nsCSSValueList **tails[numProps] = { getter_Transfers(values[0]), 
+                                       getter_Transfers(values[1]), 
+                                       getter_Transfers(values[2]),
+                                       getter_Transfers(values[3]) };
+  // flags to determine whether a particular subproperty was specified for this
+  // transition
+  PRBool atEOP = PR_FALSE;
+  for (;;) { // loop over comma-separated transitions
+    PRBool parsedProperty[numProps] =
+      { PR_FALSE, PR_FALSE, PR_FALSE, PR_FALSE };
+    for (;;) { // loop over values within a transition
+      PRBool foundProperty = PR_FALSE;
+      // check to see if we're at the end of one full transition definition
+      // (either because we hit a comma or because we hit the end of the
+      // property definition)
+      if (ExpectSymbol(',', PR_TRUE))
+        break;
+      if (ExpectEndProperty()) {
+        atEOP = PR_TRUE;
+        break;
+      }
+
+      // else, try to parse the next transition sub-property
+      for (PRSize i = 0; !foundProperty && i < numProps; ++i) {
+        if (!parsedProperty[i]) {
+          // if we haven't found this property yet, try to parse it
+          PRInt32 variantMask;
+          const PRInt32* table = nsnull;
+          switch (kTransitionProperties[i]) {
+            case eCSSProperty_transition_property:
+              variantMask = VARIANT_IDENTIFIER | VARIANT_NONE | VARIANT_ALL;
+              break;
+            case eCSSProperty_transition_duration:
+            case eCSSProperty_transition_delay:
+              variantMask = VARIANT_TIME;
+              break;
+            case eCSSProperty_transition_timing_function:
+              variantMask = VARIANT_TIMING_FUNCTION;
+              table = nsCSSProps::kTransitionTimingFunctionKTable;
+              break;
+            default:
+              NS_ABORT_IF_FALSE(PR_FALSE, "Invalid transition property");
+          }
+          if (ParseVariant(tempValue, variantMask, table)) {
+            parsedProperty[i] = PR_TRUE;
+            if (!AppendValueToList(tails[i], tempValue)) {
+              return PR_FALSE;
+            }
+            foundProperty = PR_TRUE;
+            break;  // break out of inner loop, continue looking for next sub-property
+          }
+        }
+      }
+      if (!foundProperty) {
+        // we're not at a ',' or at the end of a the property but we couldn't
+        // parse any of the sub-properties, so the declaration is invalid
+        return PR_FALSE;
+      }
+    }
+
+    // we hit the end of the property or the end of one transition
+    // definition, add its components to the list
+    for (PRSize i = 0; i < numProps; ++i) {
+      // if the all of the subproperties were not explicitly specified, fill
+      // in the missing ones with initial values.
+      if (!parsedProperty[i]) {
+        switch (kTransitionProperties[i]) {
+          case eCSSProperty_transition_property:
+            tempValue.SetAllValue();
+            break;
+          case eCSSProperty_transition_duration:
+            tempValue.SetFloatValue(0.0, eCSSUnit_Seconds);
+            break;
+          case eCSSProperty_transition_timing_function:
+            tempValue.SetIntValue(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE,
+                                  eCSSUnit_Enumerated);
+            break;
+          case eCSSProperty_transition_delay:
+            tempValue.SetFloatValue(0.0, eCSSUnit_Seconds);
+            break;
+          default:
+            NS_ABORT_IF_FALSE(PR_FALSE, "Invalid transition property");
+        }
+        if (!AppendValueToList(tails[i], tempValue)) {
+          return PR_FALSE;
+        }
+      }
+    }
+
+    if (atEOP)
+      break;
+    // else we just hit a ',' so continue parsing the next compound transition
+  }
+
+  // Save all parsed transition sub-properties in mTempData
+  for (PRSize i = 0; i < numProps; ++i) {
+    nsCSSProperty prop = kTransitionProperties[i];
+    *static_cast<nsCSSValueList**>(mTempData.PropertyAt(prop)) =
+      values[i].forget();
+    mTempData.SetPropertyBit(prop);
+  }
+  return PR_TRUE;
+}
+
 nsCSSValueList*
 CSSParserImpl::ParseCSSShadowList(PRBool aIsBoxShadow)
 {
   nsAutoParseCompoundProperty compound(this);
 
   // Parses x, y, radius, color (in two possible orders)
   // This parses the input into a list. Either it contains just a "none" or
   // "inherit" value, or a list of arrays.
diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -514,16 +514,21 @@ CSS_PROP_TABLE(table-layout, table_layou
 CSS_PROP_TEXT(text-align, text_align, TextAlign, 0, Text, mTextAlign, eCSSType_Value, kTextAlignKTable)
 CSS_PROP_TEXTRESET(text-decoration, text_decoration, TextDecoration, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE, Text, mDecoration, eCSSType_Value, kTextDecorationKTable)
 CSS_PROP_TEXT(text-indent, text_indent, TextIndent, 0, Text, mTextIndent, eCSSType_Value, nsnull)
 CSS_PROP_TEXT(text-shadow, text_shadow, TextShadow, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE | CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Text, mTextShadow, eCSSType_ValueList, nsnull)
 CSS_PROP_TEXT(text-transform, text_transform, TextTransform, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE, Text, mTextTransform, eCSSType_Value, kTextTransformKTable)
 CSS_PROP_DISPLAY(-moz-transform, _moz_transform, MozTransform, 0, Display, mTransform, eCSSType_ValueList, kDisplayKTable)
 CSS_PROP_DISPLAY(-moz-transform-origin, _moz_transform_origin, MozTransformOrigin, 0, Display, mTransformOrigin, eCSSType_ValuePair, kBackgroundPositionKTable)
 CSS_PROP_POSITION(top, top, Top, 0, Position, mOffset.mTop, eCSSType_Value, nsnull)
+CSS_PROP_SHORTHAND(-moz-transition, transition, MozTransition, 0)
+CSS_PROP_DISPLAY(-moz-transition-delay, transition_delay, MozTransitionDelay, CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Display, mTransitionDelay, eCSSType_ValueList, nsnull)
+CSS_PROP_DISPLAY(-moz-transition-duration, transition_duration, MozTransitionDuration, CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Display, mTransitionDuration, eCSSType_ValueList, nsnull)
+CSS_PROP_DISPLAY(-moz-transition-property, transition_property, MozTransitionProperty, CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Display, mTransitionProperty, eCSSType_ValueList /* list of CSS properties that have transitions ? */, nsnull)
+CSS_PROP_DISPLAY(-moz-transition-timing-function, transition_timing_function, MozTransitionTimingFunction, CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Display, mTransitionTimingFunction, eCSSType_ValueList, kTransitionTimingFunctionKTable)
 CSS_PROP_TEXTRESET(unicode-bidi, unicode_bidi, UnicodeBidi, 0, Text, mUnicodeBidi, eCSSType_Value, kUnicodeBidiKTable)
 CSS_PROP_USERINTERFACE(-moz-user-focus, user_focus, MozUserFocus, 0, UserInterface, mUserFocus, eCSSType_Value, kUserFocusKTable) // XXX bug 3935
 CSS_PROP_USERINTERFACE(-moz-user-input, user_input, MozUserInput, 0, UserInterface, mUserInput, eCSSType_Value, kUserInputKTable) // XXX ??? // XXX bug 3935
 CSS_PROP_USERINTERFACE(-moz-user-modify, user_modify, MozUserModify, 0, UserInterface, mUserModify, eCSSType_Value, kUserModifyKTable) // XXX bug 3935
 CSS_PROP_UIRESET(-moz-user-select, user_select, MozUserSelect, 0, UserInterface, mUserSelect, eCSSType_Value, kUserSelectKTable) // XXX bug 3935
 // NOTE: vertical-align is only supposed to apply to :first-letter when
 // 'float' is 'none', but we don't worry about that since it has no
 // effect otherwise
diff --git a/layout/style/nsCSSProperty.h b/layout/style/nsCSSProperty.h
--- a/layout/style/nsCSSProperty.h
+++ b/layout/style/nsCSSProperty.h
@@ -59,16 +59,24 @@ enum nsCSSProperty {
   eCSSProperty_COUNT_DUMMY = eCSSProperty_COUNT_no_shorthands - 1,
 
   #define CSS_PROP_SHORTHAND(name_, id_, method_, flags_) eCSSProperty_##id_,
   #include "nsCSSPropList.h"
   #undef CSS_PROP_SHORTHAND
 
   eCSSProperty_COUNT,
 
+  // Some of the values below could probably overlap with each other and
+  // with eCSSProperty_COUNT if we had a need for them to do so.
+
+  // Extra values for use in the values of the 'transition-property'
+  // property.
+  eCSSPropertyExtra_no_properties,
+  eCSSPropertyExtra_all_properties,
+
   // Extra dummy values for nsCSSParser internal use.
   eCSSPropertyExtra_x_none_value
 };
 
 // The types of values that can be in the nsCSS*/nsRuleData* structs.
 // See nsCSSPropList.h for uses.
 enum nsCSSType {
   eCSSType_Value,
diff --git a/layout/style/nsCSSProps.cpp b/layout/style/nsCSSProps.cpp
--- a/layout/style/nsCSSProps.cpp
+++ b/layout/style/nsCSSProps.cpp
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1999
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -1097,16 +1098,25 @@ const PRInt32 nsCSSProps::kTextDecoratio
 
 const PRInt32 nsCSSProps::kTextTransformKTable[] = {
   eCSSKeyword_capitalize, NS_STYLE_TEXT_TRANSFORM_CAPITALIZE,
   eCSSKeyword_lowercase, NS_STYLE_TEXT_TRANSFORM_LOWERCASE,
   eCSSKeyword_uppercase, NS_STYLE_TEXT_TRANSFORM_UPPERCASE,
   eCSSKeyword_UNKNOWN,-1
 };
 
+const PRInt32 nsCSSProps::kTransitionTimingFunctionKTable[] = {
+  eCSSKeyword_ease, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE,
+  eCSSKeyword_linear, NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR,
+  eCSSKeyword_ease_in, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN,
+  eCSSKeyword_ease_out, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT, 
+  eCSSKeyword_ease_in_out, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT, 
+  eCSSKeyword_UNKNOWN,-1
+};
+
 const PRInt32 nsCSSProps::kUnicodeBidiKTable[] = {
   eCSSKeyword_embed, NS_STYLE_UNICODE_BIDI_EMBED,
   eCSSKeyword_bidi_override, NS_STYLE_UNICODE_BIDI_OVERRIDE,
   eCSSKeyword_UNKNOWN,-1
 };
 
 const PRInt32 nsCSSProps::kUserFocusKTable[] = {
   eCSSKeyword_ignore,         NS_STYLE_USER_FOCUS_IGNORE,
@@ -1901,16 +1911,24 @@ static const nsCSSProperty gMozPaddingEn
 };
 
 static const nsCSSProperty gPauseSubpropTable[] = {
   eCSSProperty_pause_after,
   eCSSProperty_pause_before,
   eCSSProperty_UNKNOWN
 };
 
+static const nsCSSProperty gMozTransitionSubpropTable[] = {
+  eCSSProperty_transition_property,
+  eCSSProperty_transition_duration,
+  eCSSProperty_transition_timing_function,
+  eCSSProperty_transition_delay,
+  eCSSProperty_UNKNOWN
+};
+
 #ifdef MOZ_SVG
 static const nsCSSProperty gMarkerSubpropTable[] = {
   eCSSProperty_marker_start,
   eCSSProperty_marker_mid,
   eCSSProperty_marker_end,
   eCSSProperty_UNKNOWN
 };
 #endif
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Joanthon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -227,16 +228,17 @@ public:
   static const PRInt32 kSpeakNumeralKTable[];
   static const PRInt32 kSpeakPunctuationKTable[];
   static const PRInt32 kSpeechRateKTable[];
   static const PRInt32 kStackSizingKTable[];
   static const PRInt32 kTableLayoutKTable[];
   static const PRInt32 kTextAlignKTable[];
   static const PRInt32 kTextDecorationKTable[];
   static const PRInt32 kTextTransformKTable[];
+  static const PRInt32 kTransitionTimingFunctionKTable[];
   static const PRInt32 kUnicodeBidiKTable[];
   static const PRInt32 kUserFocusKTable[];
   static const PRInt32 kUserInputKTable[];
   static const PRInt32 kUserModifyKTable[];
   static const PRInt32 kUserSelectKTable[];
   static const PRInt32 kVerticalAlignKTable[];
   static const PRInt32 kVisibilityKTable[];
   static const PRInt32 kVolumeKTable[];
diff --git a/layout/style/nsCSSStruct.cpp b/layout/style/nsCSSStruct.cpp
--- a/layout/style/nsCSSStruct.cpp
+++ b/layout/style/nsCSSStruct.cpp
@@ -264,16 +264,20 @@ nsCSSValueListRect::sides[4] = {
   &nsCSSValueListRect::mBottom,
   &nsCSSValueListRect::mLeft,
 };
 
 // --- nsCSSDisplay -----------------
 
 /* During allocation, null-out the transform list. */
 nsCSSDisplay::nsCSSDisplay(void) : mTransform(nsnull)
+  , mTransitionProperty(nsnull)
+  , mTransitionDuration(nsnull)
+  , mTransitionTimingFunction(nsnull)
+  , mTransitionDelay(nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSDisplay);
 }
 
 nsCSSDisplay::~nsCSSDisplay(void)
 {
   MOZ_COUNT_DTOR(nsCSSDisplay);
 }
diff --git a/layout/style/nsCSSStruct.h b/layout/style/nsCSSStruct.h
--- a/layout/style/nsCSSStruct.h
+++ b/layout/style/nsCSSStruct.h
@@ -369,16 +369,20 @@ struct nsCSSDisplay : public nsCSSStruct
   nsCSSValue mClear;
   nsCSSRect  mClip;
   nsCSSValue mOverflowX;
   nsCSSValue mOverflowY;
   nsCSSValue mVisibility;
   nsCSSValue mOpacity;
   nsCSSValueList *mTransform; // List of Arrays containing transform information
   nsCSSValuePair mTransformOrigin;
+  nsCSSValueList* mTransitionProperty;
+  nsCSSValueList* mTransitionDuration;
+  nsCSSValueList* mTransitionTimingFunction;
+  nsCSSValueList* mTransitionDelay;
 
   // temp fix for bug 24000 
   nsCSSValue mBreakBefore;
   nsCSSValue mBreakAfter;
   // end temp fix
 private:
   nsCSSDisplay(const nsCSSDisplay& aOther); // NOT IMPLEMENTED
 };
diff --git a/layout/style/nsCSSValue.cpp b/layout/style/nsCSSValue.cpp
--- a/layout/style/nsCSSValue.cpp
+++ b/layout/style/nsCSSValue.cpp
@@ -345,16 +345,22 @@ void nsCSSValue::SetInitialValue()
 }
 
 void nsCSSValue::SetNoneValue()
 {
   Reset();
   mUnit = eCSSUnit_None;
 }
 
+void nsCSSValue::SetAllValue()
+{
+  Reset();
+  mUnit = eCSSUnit_All;
+}
+
 void nsCSSValue::SetNormalValue()
 {
   Reset();
   mUnit = eCSSUnit_Normal;
 }
 
 void nsCSSValue::SetSystemFontValue()
 {
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -88,31 +88,33 @@ class nsIPrincipal;
 enum nsCSSUnit {
   eCSSUnit_Null         = 0,      // (n/a) null unit, value is not specified
   eCSSUnit_Auto         = 1,      // (n/a) value is algorithmic
   eCSSUnit_Inherit      = 2,      // (n/a) value is inherited
   eCSSUnit_Initial      = 3,      // (n/a) value is default UA value
   eCSSUnit_None         = 4,      // (n/a) value is none
   eCSSUnit_Normal       = 5,      // (n/a) value is normal (algorithmic, different than auto)
   eCSSUnit_System_Font  = 6,      // (n/a) value is -moz-use-system-font
-  eCSSUnit_Dummy        = 7,      // (n/a) a fake but specified value, used
+  eCSSUnit_All          = 7,      // (n/a) value is all
+  eCSSUnit_Dummy        = 8,      // (n/a) a fake but specified value, used
                                   //       only in temporary values
-  eCSSUnit_DummyInherit = 8,      // (n/a) a fake but specified value, used
+  eCSSUnit_DummyInherit = 9,      // (n/a) a fake but specified value, used
                                   //       only in temporary values
-  eCSSUnit_RectIsAuto   = 9,      // (n/a) 'auto' for an entire rect()
-  eCSSUnit_String       = 10,     // (PRUnichar*) a string value
-  eCSSUnit_Ident        = 11,     // (PRUnichar*) a string value
-  eCSSUnit_Families     = 12,     // (PRUnichar*) a string value
-  eCSSUnit_Attr         = 13,     // (PRUnichar*) a attr(string) value
-  eCSSUnit_Local_Font   = 14,     // (PRUnichar*) a local font name
-  eCSSUnit_Font_Format  = 15,     // (PRUnichar*) a font format name
+  eCSSUnit_RectIsAuto   = 10,     // (n/a) 'auto' for an entire rect()
+  eCSSUnit_String       = 11,     // (PRUnichar*) a string value
+  eCSSUnit_Ident        = 12,     // (PRUnichar*) a string value
+  eCSSUnit_Families     = 13,     // (PRUnichar*) a string value
+  eCSSUnit_Attr         = 14,     // (PRUnichar*) a attr(string) value
+  eCSSUnit_Local_Font   = 15,     // (PRUnichar*) a local font name
+  eCSSUnit_Font_Format  = 16,     // (PRUnichar*) a font format name
   eCSSUnit_Array        = 20,     // (nsCSSValue::Array*) a list of values
   eCSSUnit_Counter      = 21,     // (nsCSSValue::Array*) a counter(string,[string]) value
   eCSSUnit_Counters     = 22,     // (nsCSSValue::Array*) a counters(string,string[,string]) value
-  eCSSUnit_Function     = 23,     // (nsCSSValue::Array*) a function with parameters.  First elem of array is name,
+  eCSSUnit_Cubic_Bezier = 23,     // (nsCSSValue::Array*) a list of float values 
+  eCSSUnit_Function     = 24,     // (nsCSSValue::Array*) a function with parameters.  First elem of array is name,
                                   //  the rest of the values are arguments.
 
   eCSSUnit_URL          = 30,     // (nsCSSValue::URL*) value
   eCSSUnit_Image        = 31,     // (nsCSSValue::Image*) value
   eCSSUnit_Integer      = 50,     // (int) simple value
   eCSSUnit_Enumerated   = 51,     // (int) value has enumerated meaning
   eCSSUnit_EnumColor    = 80,     // (int) enumerated color (kColorKTable)
   eCSSUnit_Color        = 81,     // (nscolor) an RGBA value
@@ -161,17 +163,17 @@ public:
   friend struct Array;
 
   struct URL;
   friend struct URL;
 
   struct Image;
   friend struct Image;
   
-  // for valueless units only (null, auto, inherit, none, normal)
+  // for valueless units only (null, auto, inherit, none, all, normal)
   explicit nsCSSValue(nsCSSUnit aUnit = eCSSUnit_Null)
     : mUnit(aUnit)
   {
     NS_ASSERTION(aUnit <= eCSSUnit_RectIsAuto, "not a valueless unit");
   }
 
   nsCSSValue(PRInt32 aValue, nsCSSUnit aUnit) NS_HIDDEN;
   nsCSSValue(float aValue, nsCSSUnit aUnit) NS_HIDDEN;
@@ -304,16 +306,17 @@ public:
   NS_HIDDEN_(void)  SetColorValue(nscolor aValue);
   NS_HIDDEN_(void)  SetArrayValue(nsCSSValue::Array* aArray, nsCSSUnit aUnit);
   NS_HIDDEN_(void)  SetURLValue(nsCSSValue::URL* aURI);
   NS_HIDDEN_(void)  SetImageValue(nsCSSValue::Image* aImage);
   NS_HIDDEN_(void)  SetAutoValue();
   NS_HIDDEN_(void)  SetInheritValue();
   NS_HIDDEN_(void)  SetInitialValue();
   NS_HIDDEN_(void)  SetNoneValue();
+  NS_HIDDEN_(void)  SetAllValue();
   NS_HIDDEN_(void)  SetNormalValue();
   NS_HIDDEN_(void)  SetSystemFontValue();
   NS_HIDDEN_(void)  SetDummyValue();
   NS_HIDDEN_(void)  SetDummyInheritValue();
   NS_HIDDEN_(void)  SetRectIsAutoValue();
   NS_HIDDEN_(void)  StartImageLoad(nsIDocument* aDocument)
                                    const;  // Not really const, but pretending
 
diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -21,16 +21,17 @@
  *
  * Contributor(s):
  *   Daniel Glazman <glazman@netscape.com>
  *   Boris Zbarsky <bzbarsky@mit.edu>
  *   Christopher A. Aillon <christopher@aillon.com>
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   Christian Biesinger <cbiesinger@web.de>
  *   Michael Ventnor <m.ventnor@gmail.com>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -42,16 +43,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 /* DOM object returned from element.getComputedStyle() */
 
 #include "nsComputedDOMStyle.h"
 
 #include "nsDOMError.h"
 #include "nsDOMString.h"
+#include "nsPrintfCString.h"
 #include "nsIDOMNSCSS2Properties.h"
 #include "nsIDOMElement.h"
 #include "nsIDOMCSSPrimitiveValue.h"
 #include "nsStyleContext.h"
 #include "nsIScrollableFrame.h"
 #include "nsContentUtils.h"
 #include "prprf.h"
 
@@ -4029,16 +4031,134 @@ nsComputedDOMStyle::GetMask(nsIDOMCSSVal
   else
     val->SetIdent(eCSSKeyword_none);
 
   return CallQueryInterface(val, aValue);
 }
 
 #endif // MOZ_SVG
 
+nsresult
+nsComputedDOMStyle::GetTransitionDelay(nsIDOMCSSValue** aValue)
+{
+  const nsStyleDisplay* display = GetStyleDisplay();
+
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  NS_ABORT_IF_FALSE(display->mTransitionDelayCount > 0,
+                    "first item must be explicit");
+  PRUint32 i = 0;
+  do {
+    const nsTransition *transition = &display->mTransitions[i];
+    nsROCSSPrimitiveValue* delay = GetROCSSPrimitiveValue();
+    if (!delay || !valueList->AppendCSSValue(delay)) {
+      delete valueList;
+      delete delay;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+    delay->SetTime((float)transition->GetDelay() / (float)PR_MSEC_PER_SEC);
+  } while (++i < display->mTransitionDelayCount);
+
+  return CallQueryInterface(valueList, aValue);
+}
+
+nsresult
+nsComputedDOMStyle::GetTransitionDuration(nsIDOMCSSValue** aValue)
+{
+  const nsStyleDisplay* display = GetStyleDisplay();
+
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  NS_ABORT_IF_FALSE(display->mTransitionDurationCount > 0,
+                    "first item must be explicit");
+  PRUint32 i = 0;
+  do {
+    const nsTransition *transition = &display->mTransitions[i];
+    nsROCSSPrimitiveValue* duration = GetROCSSPrimitiveValue();
+    if (!duration || !valueList->AppendCSSValue(duration)) {
+      delete valueList;
+      delete duration;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    duration->SetTime((float)transition->GetDuration() / (float)PR_MSEC_PER_SEC);
+  } while (++i < display->mTransitionDurationCount);
+
+  return CallQueryInterface(valueList, aValue);
+}
+
+nsresult
+nsComputedDOMStyle::GetTransitionProperty(nsIDOMCSSValue** aValue)
+{
+  const nsStyleDisplay* display = GetStyleDisplay();
+
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  NS_ABORT_IF_FALSE(display->mTransitionPropertyCount > 0,
+                    "first item must be explicit");
+  PRUint32 i = 0;
+  do {
+    const nsTransition *transition = &display->mTransitions[i];
+    nsROCSSPrimitiveValue* property = GetROCSSPrimitiveValue();
+    if (!property || !valueList->AppendCSSValue(property)) {
+      delete valueList;
+      delete property;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+    nsCSSProperty cssprop = transition->GetProperty();
+    if (cssprop == eCSSPropertyExtra_all_properties)
+      property->SetIdent(eCSSKeyword_all);
+    else if (cssprop == eCSSPropertyExtra_no_properties)
+      property->SetIdent(eCSSKeyword_none);
+    else if (cssprop == eCSSProperty_UNKNOWN)
+    {
+      const char *str;
+      transition->GetUnknownProperty()->GetUTF8String(&str);
+      property->SetString(nsDependentCString(str)); // really want SetIdent
+    }
+    else
+      property->SetString(nsCSSProps::GetStringValue(cssprop));
+  } while (++i < display->mTransitionPropertyCount);
+
+  return CallQueryInterface(valueList, aValue);
+}
+
+nsresult
+nsComputedDOMStyle::GetTransitionTimingFunction(nsIDOMCSSValue** aValue)
+{
+  const nsStyleDisplay* display = GetStyleDisplay();
+
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  NS_ABORT_IF_FALSE(display->mTransitionTimingFunctionCount > 0,
+                    "first item must be explicit");
+  PRUint32 i = 0;
+  do {
+    const nsTransition *transition = &display->mTransitions[i];
+    nsROCSSPrimitiveValue* timingFunction = GetROCSSPrimitiveValue();
+    if (!timingFunction || !valueList->AppendCSSValue(timingFunction)) {
+      delete valueList;
+      delete timingFunction;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    // set the value from the cubic-bezier control points
+    // (We could try to regenerate the keywords if we want.)
+    const nsTimingFunction& tf = transition->GetTimingFunction();
+    timingFunction->SetString(
+      nsPrintfCString(64, "cubic-bezier(%f, %f, %f, %f)",
+                          tf.mX1, tf.mY1, tf.mX2, tf.mY2));
+  } while (++i < display->mTransitionTimingFunctionCount);
+
+  return CallQueryInterface(valueList, aValue);
+}
 
 #define COMPUTED_STYLE_MAP_ENTRY(_prop, _method)              \
   { eCSSProperty_##_prop, &nsComputedDOMStyle::Get##_method, PR_FALSE }
 #define COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_prop, _method)       \
   { eCSSProperty_##_prop, &nsComputedDOMStyle::Get##_method, PR_TRUE }
 
 const nsComputedDOMStyle::ComputedStyleMapEntry*
 nsComputedDOMStyle::GetQueryablePropertyMap(PRUint32* aLength)
@@ -4230,16 +4350,20 @@ nsComputedDOMStyle::GetQueryableProperty
     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_outline_radius_topRight,   OutlineRadiusTopRight),
     COMPUTED_STYLE_MAP_ENTRY(stack_sizing,                  StackSizing),
     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_transform,         MozTransform),
     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_transform_origin,  MozTransformOrigin),
     COMPUTED_STYLE_MAP_ENTRY(user_focus,                    UserFocus),
     COMPUTED_STYLE_MAP_ENTRY(user_input,                    UserInput),
     COMPUTED_STYLE_MAP_ENTRY(user_modify,                   UserModify),
     COMPUTED_STYLE_MAP_ENTRY(user_select,                   UserSelect),
+    COMPUTED_STYLE_MAP_ENTRY(transition_delay,              TransitionDelay),
+    COMPUTED_STYLE_MAP_ENTRY(transition_duration,           TransitionDuration),
+    COMPUTED_STYLE_MAP_ENTRY(transition_property,           TransitionProperty),
+    COMPUTED_STYLE_MAP_ENTRY(transition_timing_function,    TransitionTimingFunction),
     COMPUTED_STYLE_MAP_ENTRY(_moz_window_shadow,            WindowShadow),
     COMPUTED_STYLE_MAP_ENTRY(word_wrap,                     WordWrap)
 
 #ifdef MOZ_SVG
     ,
     COMPUTED_STYLE_MAP_ENTRY(clip_path,                     ClipPath),
     COMPUTED_STYLE_MAP_ENTRY(clip_rule,                     ClipRule),
     COMPUTED_STYLE_MAP_ENTRY(color_interpolation,           ColorInterpolation),
diff --git a/layout/style/nsComputedDOMStyle.h b/layout/style/nsComputedDOMStyle.h
--- a/layout/style/nsComputedDOMStyle.h
+++ b/layout/style/nsComputedDOMStyle.h
@@ -300,16 +300,22 @@ private:
   /* Column properties */
   nsresult GetColumnCount(nsIDOMCSSValue** aValue);
   nsresult GetColumnWidth(nsIDOMCSSValue** aValue);
   nsresult GetColumnGap(nsIDOMCSSValue** aValue);
   nsresult GetColumnRuleWidth(nsIDOMCSSValue** aValue);
   nsresult GetColumnRuleStyle(nsIDOMCSSValue** aValue);
   nsresult GetColumnRuleColor(nsIDOMCSSValue** aValue);
 
+  /* CSS Transitions */
+  nsresult GetTransitionProperty(nsIDOMCSSValue** aValue);
+  nsresult GetTransitionDuration(nsIDOMCSSValue** aValue);
+  nsresult GetTransitionDelay(nsIDOMCSSValue** aValue);
+  nsresult GetTransitionTimingFunction(nsIDOMCSSValue** aValue);
+
 #ifdef MOZ_SVG
   /* SVG properties */
   nsresult GetSVGPaintFor(PRBool aFill, nsIDOMCSSValue** aValue);
 
   nsresult GetFill(nsIDOMCSSValue** aValue);
   nsresult GetStroke(nsIDOMCSSValue** aValue);
   nsresult GetMarkerEnd(nsIDOMCSSValue** aValue);
   nsresult GetMarkerMid(nsIDOMCSSValue** aValue);
diff --git a/layout/style/nsROCSSPrimitiveValue.cpp b/layout/style/nsROCSSPrimitiveValue.cpp
--- a/layout/style/nsROCSSPrimitiveValue.cpp
+++ b/layout/style/nsROCSSPrimitiveValue.cpp
@@ -227,29 +227,34 @@ nsROCSSPrimitiveValue::GetCssText(nsAStr
             break;
           tmpStr.Append(comma + colorValue);
         }
 
         tmpStr.Append(NS_LITERAL_STRING(")"));
 
         break;
       }
+    case CSS_S :
+      {
+        tmpStr.AppendFloat(mValue.mFloat);
+        tmpStr.AppendLiteral("s");
+        break;
+      }
     case CSS_CM :
     case CSS_MM :
     case CSS_IN :
     case CSS_PT :
     case CSS_PC :
     case CSS_UNKNOWN :
     case CSS_EMS :
     case CSS_EXS :
     case CSS_DEG :
     case CSS_RAD :
     case CSS_GRAD :
     case CSS_MS :
-    case CSS_S :
     case CSS_HZ :
     case CSS_KHZ :
     case CSS_DIMENSION :
       NS_ERROR("We have a bogus value set.  This should not happen");
       return NS_ERROR_DOM_INVALID_ACCESS_ERR;
   }
 
   if (NS_SUCCEEDED(result)) {
diff --git a/layout/style/nsROCSSPrimitiveValue.h b/layout/style/nsROCSSPrimitiveValue.h
--- a/layout/style/nsROCSSPrimitiveValue.h
+++ b/layout/style/nsROCSSPrimitiveValue.h
@@ -177,16 +177,23 @@ public:
       NS_ADDREF(mValue.mRect);
       mType = CSS_RECT;
     }
     else {
       mType = CSS_UNKNOWN;
     }
   }
 
+  void SetTime(float aValue)
+  {
+    Reset();
+    mValue.mFloat = aValue;
+    mType = CSS_S;
+  }
+
   void Reset(void)
   {
     switch (mType) {
       case CSS_IDENT:
         break;
       case CSS_STRING:
       case CSS_ATTR:
       case CSS_COUNTER: // FIXME: Counter should use an object
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -23,16 +23,17 @@
  *   Original Author: David W. Hyatt (hyatt@netscape.com)
  *   Daniel Glazman <glazman@netscape.com>
  *   Roger B. Sidje <rbs@maths.uq.edu.au>
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   L. David Baron <dbaron@dbaron.org>
  *   Christian Biesinger <cbiesinger@web.de>
  *   Michael Ventnor <m.ventnor@gmail.com>
  *   Keith Rarick <kr@xph.us>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -3369,27 +3370,277 @@ static nsStyleTransformMatrix ReadTransf
     nsStyleTransformMatrix currMatrix;
     currMatrix.SetToTransformFunction(currElem.GetArrayValue(), aContext,
                                       aPresContext, aCanStoreInRuleTree);
     result *= currMatrix;
   }
   return result;
 }
 
+// A simple helper function to get the length of a nsCSSValueList
+inline static PRUint32 GetValueListLength(nsCSSValueList* aValueList)
+{
+  PRUint32 len = 0;
+  nsCSSValueList* val = aValueList;
+  while (val) {
+    len++;
+    val = val->mNext;
+  }
+  return len;
+}
+
 const void*
 nsRuleNode::ComputeDisplayData(void* aStartStruct,
                                const nsRuleDataStruct& aData, 
                                nsStyleContext* aContext, 
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Display, (), display, parentDisplay,
                       Display, displayData)
 
+
+  // CSS Transitions
+  nsCSSValueList* delayList = displayData.mTransitionDelay;
+  nsCSSValueList* durationList = displayData.mTransitionDuration;
+  nsCSSValueList* propertyList = displayData. mTransitionProperty;
+  nsCSSValueList* functionList = displayData.mTransitionTimingFunction;
+
+  // Transition properties are stored in nsCSSDisplay separately in jagged
+  // arrays.  The number of transitions is equal to the number of elements in
+  // the longest array.  Arrays with fewer elements will be filled in with
+  // default values
+
+  // Transitions are difficult to handle correctly because of this.  For example
+  // we need to handle scenarios such as:
+  //  * a more general rule specifies transition-property: a, b, c;
+  //  * a more specific rule overrides as transition-property: d;
+  //
+  //  If only the general rule applied, we would fill in the extra properties
+  //  (duration, delay, etc) with initial values to create 3 fully-specified
+  //  transitions.  But when the more specific rule applies, we should only
+  //  create a single transition.  In order to do this we need to remember which
+  //  properties were explicitly specified and which ones were just filled in
+  //  with initial values to get a fully-specified transition
+
+  // cache whether any of the properties are specified as 'inherit' so we can
+  // use it below
+  PRBool delayInherited = displayData.mTransitionDelay &&
+    displayData.mTransitionDelay->mValue.GetUnit() == eCSSUnit_Inherit;
+  PRBool durationInherited = displayData.mTransitionDuration &&
+    displayData.mTransitionDuration->mValue.GetUnit() == eCSSUnit_Inherit;
+  PRBool propertyInherited = displayData.mTransitionProperty &&
+    displayData.mTransitionProperty->mValue.GetUnit() == eCSSUnit_Inherit;
+  PRBool timingFunctionInherited = displayData.mTransitionTimingFunction &&
+    displayData.mTransitionTimingFunction->mValue.GetUnit() == eCSSUnit_Inherit;
+
+  // General algorithm to determine how many total transitions we need to build.
+  // For each property:
+  //  - if there is no value specified in for the property in displayData, use
+  //    the values from the start struct, but only if they were explicitly
+  //    specified
+  //  - if there is a value specified for the property in displayData:
+  //    - if the value is 'inherit', count the number of values for that
+  //      property are specified by the parent, but only those that were
+  //      explicitly specified
+  //    - otherwise, count the number of values specified in displayData
+
+  PRUint32 numTransitions = 0;
+  PRUint32 numDurations = 0;
+  PRUint32 numProperties = 0;
+  PRUint32 numDelays = 0;
+  PRUint32 numTimingFuncs = 0;
+
+  // FIXME: Convert this to a loop!
+
+  // calculate number of transition-duration elements
+  if (durationList) {
+    if (durationInherited) {
+      numDurations = parentDisplay->mTransitionDurationCount;
+    } else {
+      numDurations = GetValueListLength(durationList);
+    }
+  } else {
+    numDurations = display->mTransitionDurationCount;
+  }
+  if (numDurations > numTransitions)
+    numTransitions = numDurations;
+
+  // calculate number of transition-property elements
+  if (propertyList) {
+    if (propertyInherited) {
+      numProperties = parentDisplay->mTransitionPropertyCount;
+    } else {
+      numProperties = GetValueListLength(propertyList);
+    }
+  } else {
+    numProperties = display->mTransitionPropertyCount;
+  }
+  if (numProperties > numTransitions)
+    numTransitions = numProperties;
+
+  // calculate number of transition-delay elements
+  if (delayList) {
+    if (delayInherited) {
+      numDelays = parentDisplay->mTransitionDelayCount;
+    } else {
+      numDelays = GetValueListLength(delayList);
+    }
+  } else {
+    numDelays = display->mTransitionDelayCount;
+  }
+  if (numDelays > numTransitions)
+    numTransitions = numDelays;
+
+  // calculate number of transition-timing-function elements
+  if (functionList) {
+    if (timingFunctionInherited) {
+      numTimingFuncs = parentDisplay->mTransitionTimingFunctionCount;
+    } else {
+      numTimingFuncs = GetValueListLength(functionList);
+    }
+  } else {
+    numTimingFuncs = display->mTransitionTimingFunctionCount;
+  }
+  if (numTimingFuncs > numTransitions)
+    numTransitions = numTimingFuncs;
+
+  if (!display->mTransitions.SetLength(numTransitions)) {
+    NS_WARNING("failed to allocate transitions array");
+    display->mTransitions.SetLength(1);
+    NS_ABORT_IF_FALSE(display->mTransitions.Length() == 1,
+                      "could not allocate using auto array buffer");
+    numTransitions = 1;
+    numDurations = 1;
+    numProperties = 1;
+    numDelays = 1;
+    numTimingFuncs = 1;
+  }
+
+  display->mTransitionDurationCount = numDurations;
+  display->mTransitionPropertyCount = numProperties;
+  display->mTransitionDelayCount = numDelays;
+  display->mTransitionTimingFunctionCount = numTimingFuncs;
+
+  // Fill in the transitions we just allocated with the appropriate values.
+  PRUint32 parentNumTransitions = parentDisplay->mTransitions.Length();
+  NS_ABORT_IF_FALSE(parentNumTransitions > 0, "must be nonzero");
+  for (PRUint32 i = 0; i < numTransitions; ++i) {
+    const nsTransition *inheritedTransition =
+      &parentDisplay->mTransitions[i % parentNumTransitions];
+    nsTransition *transition = &display->mTransitions[i];
+
+    if (delayInherited) {
+      transition->SetDelay(inheritedTransition->GetDelay());
+    } else if (delayList) {
+      switch (delayList->mValue.GetUnit()) {
+        case eCSSUnit_Seconds:
+          transition->SetDelay(PR_MSEC_PER_SEC *
+                               delayList->mValue.GetFloatValue());
+          break;
+        case eCSSUnit_Milliseconds:
+          transition->SetDelay(delayList->mValue.GetFloatValue());
+          break;
+        case eCSSUnit_Initial:
+          transition->SetDelay(0.0);
+          break;
+        default:
+          NS_NOTREACHED("Invalid delay unit");
+      }
+      // if we're at the end of the list, start at the beginning and repeat
+      // until we're out of transitions to populate
+      delayList = delayList->mNext ? delayList->mNext :
+        displayData.mTransitionDelay;
+    }
+
+    if (durationInherited) {
+      transition->SetDuration(inheritedTransition->GetDuration());
+    } else if (durationList) {
+      switch (durationList->mValue.GetUnit()) {
+        case eCSSUnit_Seconds:
+          transition->SetDuration(PR_MSEC_PER_SEC *
+                                  durationList->mValue.GetFloatValue());
+          break;
+        case eCSSUnit_Milliseconds:
+          transition->SetDuration(durationList->mValue.GetFloatValue());
+          break;
+        case eCSSUnit_Initial:
+          transition->SetDuration(0.0);
+          break;
+        default:
+          NS_NOTREACHED("Invalid duration unit");
+      }
+      // repeat from the beginning if we reach the end
+      durationList = durationList->mNext ? durationList->mNext :
+        displayData.mTransitionDuration;
+    }
+
+    if (propertyInherited) {
+      transition->CopyPropertyFrom(inheritedTransition);
+    } else if (propertyList) {
+      switch (propertyList->mValue.GetUnit()) {
+        case eCSSUnit_Ident:
+          {
+            nsDependentString
+              propertyStr(propertyList->mValue.GetStringBufferValue());
+            nsCSSProperty property;
+            property = nsCSSProps::LookupProperty(propertyStr);
+            if (property == eCSSProperty_UNKNOWN) {
+              transition->SetUnknownProperty(propertyStr);
+            } else {
+              transition->SetProperty(property);
+            }
+          }
+          break;
+        case eCSSUnit_None:
+          transition->SetProperty(eCSSPropertyExtra_no_properties);
+          break;
+        default:
+          NS_NOTREACHED("Invalid transition property unit");
+        case eCSSUnit_All:
+        case eCSSUnit_Initial:
+          transition->SetProperty(eCSSPropertyExtra_all_properties);
+          break;
+      }
+      // repeat from the beginning if we reach the end
+      propertyList = propertyList->mNext ? propertyList->mNext :
+        displayData.mTransitionProperty;
+    }
+
+    if (timingFunctionInherited) {
+      transition->SetTimingFunction(inheritedTransition->GetTimingFunction());
+    } else if (functionList) {
+      switch (functionList->mValue.GetUnit()) {
+        case eCSSUnit_Enumerated:
+          transition->SetTimingFunction(nsTimingFunction(functionList->mValue.GetIntValue()));
+          functionList = functionList->mNext;
+          break;
+        case eCSSUnit_Cubic_Bezier:
+          {
+            nsCSSValue::Array* array = functionList->mValue.GetArrayValue();
+            NS_ASSERTION(array && array->Count() == 4, "Need 4 control points");
+            transition->SetTimingFunction(nsTimingFunction(array->Item(0).GetFloatValue(),
+                                                           array->Item(1).GetFloatValue(),
+                                                           array->Item(2).GetFloatValue(),
+                                                           array->Item(3).GetFloatValue()));
+            // repeat from the beginning if we reach the end
+            functionList = functionList->mNext ? functionList->mNext :
+              displayData.mTransitionTimingFunction;
+          }
+          break;
+        case eCSSUnit_Initial:
+          transition->SetTimingFunction(nsTimingFunction(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE));
+          break;
+        default:
+          NS_NOTREACHED("Invalid transition property unit");
+      }
+    }
+  }
+  
   // opacity: factor, inherit, initial
   SetFactor(displayData.mOpacity, display->mOpacity, canStoreInRuleTree,
             parentDisplay->mOpacity, 1.0f, SETFCT_OPACITY);
 
   // display: enum, none, inherit, initial
   SetDiscrete(displayData.mDisplay, display->mDisplay, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NONE, parentDisplay->mDisplay,
               NS_STYLE_DISPLAY_INLINE, 0,
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -18,16 +18,17 @@
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   David Hyatt (hyatt@netscape.com)
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   Michael Ventnor <m.ventnor@gmail.com>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -48,16 +49,17 @@
 #include "nsStyleConsts.h"
 #include "nsThemeConstants.h"
 #include "nsString.h"
 #include "nsPresContext.h"
 #include "nsIDeviceContext.h"
 #include "nsIWidget.h"
 #include "nsIStyleRule.h"
 #include "nsCRT.h"
+#include "nsCSSProps.h"
 
 #include "nsCOMPtr.h"
 #include "nsIPresShell.h"
 #include "nsIFrame.h"
 #include "nsHTMLReflowState.h"
 #include "prenv.h"
 
 #include "nsBidiUtils.h"
@@ -1330,16 +1332,64 @@ PRBool nsStyleBackground::Layer::operato
          mRepeat == aOther.mRepeat &&
          mPosition == aOther.mPosition &&
          EqualImages(mImage, aOther.mImage);
 }
 
 // --------------------
 // nsStyleDisplay
 //
+void nsTimingFunction::AssignFromKeyword(PRInt32 aTimingFunctionType)
+{
+  PR_STATIC_ASSERT(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE == 0);
+  PR_STATIC_ASSERT(NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR == 1);
+  PR_STATIC_ASSERT(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN == 2);
+  PR_STATIC_ASSERT(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT == 3);
+  PR_STATIC_ASSERT(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT == 4);
+
+  static const float timingFunctionValues[5][4] = {
+    { 0.25, 0.10, 0.25, 1.00 }, // ease
+    { 0.00, 0.00, 1.00, 1.00 }, // linear
+    { 0.42, 0.00, 1.00, 1.00 }, // ease-in
+    { 0.00, 0.00, 0.58, 1.00 }, // ease-out
+    { 0.42, 0.00, 0.58, 1.00 }  // ease-in-out
+  };
+
+  NS_ABORT_IF_FALSE(0 <= aTimingFunctionType && aTimingFunctionType < 5,
+                    "keyword out of range");
+  mX1 = timingFunctionValues[aTimingFunctionType][0];
+  mY1 = timingFunctionValues[aTimingFunctionType][1];
+  mX2 = timingFunctionValues[aTimingFunctionType][2];
+  mY2 = timingFunctionValues[aTimingFunctionType][3];
+}
+
+nsTransition::nsTransition(const nsTransition& aCopy)
+  : mTimingFunction(aCopy.mTimingFunction)
+  , mDuration(aCopy.mDuration)
+  , mDelay(aCopy.mDelay)
+  , mProperty(aCopy.mProperty)
+{
+}
+
+void nsTransition::SetInitialValues()
+{
+  mTimingFunction = nsTimingFunction(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE);
+  mDuration = 0.0;
+  mDelay = 0.0;
+  mProperty = eCSSPropertyExtra_all_properties;
+}
+
+void nsTransition::SetUnknownProperty(const nsAString& aUnknownProperty)
+{
+  NS_ASSERTION(nsCSSProps::LookupProperty(aUnknownProperty) ==
+                 eCSSProperty_UNKNOWN,
+               "should be unknown property");
+  mProperty = eCSSProperty_UNKNOWN;
+  mUnknownProperty = do_GetAtom(aUnknownProperty);
+}
 
 nsStyleDisplay::nsStyleDisplay()
 {
   mAppearance = NS_THEME_NONE;
   mDisplay = NS_STYLE_DISPLAY_INLINE;
   mOriginalDisplay = NS_STYLE_DISPLAY_NONE;
   mPosition = NS_STYLE_POSITION_STATIC;
   mFloats = NS_STYLE_FLOAT_NONE;
@@ -1349,19 +1399,32 @@ nsStyleDisplay::nsStyleDisplay()
   mOverflowX = NS_STYLE_OVERFLOW_VISIBLE;
   mOverflowY = NS_STYLE_OVERFLOW_VISIBLE;
   mClipFlags = NS_STYLE_CLIP_AUTO;
   mClip.SetRect(0,0,0,0);
   mOpacity = 1.0f;
   mTransformPresent = PR_FALSE; // No transform
   mTransformOrigin[0].SetPercentValue(0.5f); // Transform is centered on origin
   mTransformOrigin[1].SetPercentValue(0.5f); 
+  mTransitions.AppendElement();
+  NS_ABORT_IF_FALSE(mTransitions.Length() == 1,
+                    "appending within auto buffer should never fail");
+  mTransitions[0].SetInitialValues();
+  mTransitionTimingFunctionCount = 1;
+  mTransitionDurationCount = 1;
+  mTransitionDelayCount = 1;
+  mTransitionPropertyCount = 1;
 }
 
 nsStyleDisplay::nsStyleDisplay(const nsStyleDisplay& aSource)
+  : mTransitions(aSource.mTransitions)
+  , mTransitionTimingFunctionCount(aSource.mTransitionTimingFunctionCount)
+  , mTransitionDurationCount(aSource.mTransitionDurationCount)
+  , mTransitionDelayCount(aSource.mTransitionDelayCount)
+  , mTransitionPropertyCount(aSource.mTransitionPropertyCount)
 {
   mAppearance = aSource.mAppearance;
   mDisplay = aSource.mDisplay;
   mOriginalDisplay = aSource.mOriginalDisplay;
   mBinding = aSource.mBinding;
   mPosition = aSource.mPosition;
   mFloats = aSource.mFloats;
   mBreakType = aSource.mBreakType;
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -18,16 +18,17 @@
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   Masayuki Nakano <masayuki@d-toybox.com>
  *   Rob Arnold <robarnold@mozilla.com>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -905,16 +906,89 @@ struct nsStyleVisibility {
   }
 
   PRBool IsVisibleOrCollapsed() const {
     return ((mVisible == NS_STYLE_VISIBILITY_VISIBLE) ||
             (mVisible == NS_STYLE_VISIBILITY_COLLAPSE));
   }
 };
 
+struct nsTimingFunction {
+  explicit nsTimingFunction(PRInt32 aTimingFunctionType
+                              = NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE)
+  {
+    AssignFromKeyword(aTimingFunctionType);
+  }
+
+  nsTimingFunction(float x1, float y1, float x2, float y2)
+    : mX1(x1)
+    , mY1(y1)
+    , mX2(x2)
+    , mY2(y2)
+  {}
+
+  float mX1;
+  float mY1;
+  float mX2;
+  float mY2;
+
+  PRBool operator==(const nsTimingFunction& aOther) const
+  {
+    return !(*this != aOther);
+  }
+
+  PRBool operator!=(const nsTimingFunction& aOther) const
+  {
+    return ((mX1 != mX1) ||
+            (mY1 != mY1) ||
+            (mX2 != mX2) ||
+            (mY2 != mY2));
+  }
+private:
+  void AssignFromKeyword(PRInt32 aTimingFunctionType);
+};
+
+struct nsTransition {
+  nsTransition() { /* leaves uninitialized; see also SetInitialValues */ }
+  explicit nsTransition(const nsTransition& aCopy);
+
+  void SetInitialValues();
+
+  nsTimingFunction& GetTimingFunction() { return mTimingFunction; }
+  const nsTimingFunction& GetTimingFunction() const { return mTimingFunction; }
+  float GetDelay() const { return mDelay; }
+  float GetDuration() const { return mDuration; }
+  nsCSSProperty GetProperty() const { return mProperty; }
+  nsIAtom* GetUnknownProperty() const { return mUnknownProperty; }
+
+  void SetTimingFunction(const nsTimingFunction& aTimingFunction)
+    { mTimingFunction = aTimingFunction; }
+  void SetDelay(float aDelay) { mDelay = aDelay; }
+  void SetDuration(float aDuration) { mDuration = aDuration; }
+  void SetProperty(nsCSSProperty aProperty)
+    {
+      NS_ASSERTION(aProperty != eCSSProperty_UNKNOWN, "invalid property");
+      mProperty = aProperty;
+    }
+  void SetUnknownProperty(const nsAString& aUnknownProperty);
+  void CopyPropertyFrom(const nsTransition* aOther)
+    {
+      mProperty = aOther->mProperty;
+      mUnknownProperty = aOther->mUnknownProperty;
+    }
+
+private:
+  nsTimingFunction mTimingFunction;
+  float mDuration;
+  float mDelay;
+  nsCSSProperty mProperty;
+  nsCOMPtr<nsIAtom> mUnknownProperty; // used when mProperty is
+                                      // eCSSProperty_UNKNOWN
+};
+
 struct nsStyleDisplay {
   nsStyleDisplay();
   nsStyleDisplay(const nsStyleDisplay& aOther); 
   ~nsStyleDisplay() {}
 
   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
     return aContext->AllocateFromShell(sz);
   }
@@ -946,16 +1020,23 @@ struct nsStyleDisplay {
   PRUint8 mPosition;            // [reset] see nsStyleConsts.h
   PRUint8 mFloats;              // [reset] see nsStyleConsts.h NS_STYLE_FLOAT_*
   PRUint8 mBreakType;           // [reset] see nsStyleConsts.h NS_STYLE_CLEAR_*
   PRPackedBool mBreakBefore;    // [reset] 
   PRPackedBool mBreakAfter;     // [reset] 
   PRUint8 mOverflowX;           // [reset] see nsStyleConsts.h
   PRUint8 mOverflowY;           // [reset] see nsStyleConsts.h
   PRUint8   mClipFlags;         // [reset] see nsStyleConsts.h
+  nsAutoTArray<nsTransition, 1> mTransitions; // [reset]
+  // The number of elements in mTransitions that are not from repeating
+  // a list due to another property being longer.
+  PRUint32 mTransitionTimingFunctionCount,
+           mTransitionDurationCount,
+           mTransitionDelayCount,
+           mTransitionPropertyCount;
   PRPackedBool mTransformPresent;  // [reset] Whether there is a -moz-transform.
   nsStyleTransformMatrix mTransform; // [reset] The stored transform matrix
   nsStyleCoord mTransformOrigin[2]; // [reset] percent, coord.
 
   PRBool IsBlockInside() const {
     return NS_STYLE_DISPLAY_BLOCK == mDisplay ||
            NS_STYLE_DISPLAY_LIST_ITEM == mDisplay ||
            NS_STYLE_DISPLAY_INLINE_BLOCK == mDisplay;
diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -123,16 +123,17 @@ _TEST_FILES =	test_acid3_test46.html \
 		test_property_database.html \
 		test_priority_preservation.html \
 		test_property_syntax_errors.html \
 		test_selectors.html \
 		test_selectors_on_anonymous_content.html \
 		test_shorthand_property_getters.html \
 		test_style_struct_copy_constructors.html \
 		test_system_font_serialization.html \
+		test_transitions_computed_values.html \
 		test_units_angle.html \
 		test_units_frequency.html \
 		test_units_length.html \
 		test_units_time.html \
 		test_value_computation.html \
 		test_value_storage.html \
 		test_visited_pref.html \
 		css_properties.js \
diff --git a/layout/style/test/property_database.js b/layout/style/test/property_database.js
--- a/layout/style/test/property_database.js
+++ b/layout/style/test/property_database.js
@@ -1698,16 +1698,57 @@ var gCSSProperties = {
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		/* XXX requires position to be set */
 		/* XXX 0 may or may not be equal to auto */
 		initial_values: [ "auto" ],
 		other_values: [ "32px", "-3em", "12%" ],
 		invalid_values: []
 	},
+	"-moz-transition-delay": {
+		domProp: "MozTransitionDelay",
+		inherited: false,
+		type: CSS_TYPE_LONGHAND,
+		initial_values: [ "0", "0s", "0ms" ],
+		other_values: [ "1s", "250ms", "-100ms", "-1s", "1s, 250ms, 2.3s"],
+		invalid_values: []
+	},
+	"-moz-transition-duration": {
+		domProp: "MozTransitionDuration",
+		inherited: false,
+		type: CSS_TYPE_LONGHAND,
+		initial_values: [ "0", "0s", "0ms" ],
+		other_values: [ "1s", "250ms", "-1ms", "-2s", "1s, 250ms, 2.3s"],
+		invalid_values: []
+	},
+	"-moz-transition-property": {
+		domProp: "MozTransitionProperty",
+		inherited: false,
+		type: CSS_TYPE_LONGHAND,
+		initial_values: [ "all" ],
+		other_values: [ "none", "left", "top", "color", "width, height, opacity", "foobar", "auto" ],
+		invalid_values: [ "none, none", "all, all", "color, none", "none, color", "all, color", "color, all", "inherit, color", "color, inherit", "initial, color", "color, initial" ]
+	},
+	"-moz-transition-timing-function": {
+		domProp: "MozTransitionTimingFunction",
+		inherited: false,
+		type: CSS_TYPE_LONGHAND,
+		initial_values: [ "ease", "cubic-bezier(0.25, 0.1, 0.25, 1.0)" ],
+		other_values: [ "linear", "ease-in", "ease-out", "ease-in-out", "linear, ease-in, cubic-bezier(0.1, 0.2, 0.8, 0.9)" ],
+		invalid_values: [ "none", "auto" ]
+	},
+	"-moz-transition": {
+		domProp: "MozTransition",
+		inherited: false,
+		type: CSS_TYPE_TRUE_SHORTHAND,
+		subproperties: [ "-moz-transition-property", "-moz-transition-duration", "-moz-transition-timing-function", "-moz-transition-delay" ],
+		initial_values: [ "all 0s ease 0s" ],
+		other_values: [ "width 1s linear 2s", "height", "2s", "ease-in-out", "2s ease-in", "opacity linear", "ease-out 2s", "2s color, 1s width, 500ms height linear, 1s opacity 4s cubic-bezier(0.0, 0.1, 1.0, 1.0)" ],
+		invalid_values: [ "2s, 1s width", "1s width, 2s", "2s all, 1s width", "1s width, 2s all", "1s width, 2s none", "2s none, 1s width" ]
+	},
 	"unicode-bidi": {
 		domProp: "unicodeBidi",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "normal" ],
 		other_values: [ "embed", "bidi-override" ],
 		invalid_values: [ "auto", "none" ]
 	},
diff --git a/layout/style/test/test_garbage_at_end_of_declarations.html b/layout/style/test/test_garbage_at_end_of_declarations.html
--- a/layout/style/test/test_garbage_at_end_of_declarations.html
+++ b/layout/style/test/test_garbage_at_end_of_declarations.html
@@ -48,26 +48,37 @@ var gAllowsExtra = {
   "counter-increment": { "none": true },
   "counter-reset": { "none": true },
   "font-family": {},
   "font": { "caption": true, "icon": true, "menu": true, "message-box": true,
             "small-caption": true, "status-bar": true },
   "voice-family": {},
 };
 
+/* These are the reverse of the above list; they're the unusual values
+   that do allow extra keywords afterwards */
+var gAllowsExtraUnusual = {
+  "-moz-transition": { "2s": true, "ease-in-out": true, "2s ease-in": true,
+                       "ease-out 2s": true },
+};
+
 function test_property(property)
 {
   var info = gCSSProperties[property];
 
   function test_value(value) {
     if (property in gAllowsExtra &&
         value != "inherit" && value != "-moz-initial" &&
         !(value in gAllowsExtra[property])) {
       return;
     }
+    if (property in gAllowsExtraUnusual &&
+        value in gAllowsExtraUnusual[property]) {
+      return;
+    }
 
     gElement.setAttribute("style", property + ": " + value + " blah");
     if ("subproperties" in info) {
       for (idx in info.subproperties) {
         var subprop = info.subproperties[idx];
         is(gDeclaration.getPropertyValue(subprop), "",
            ["expected garbage ignored after '", property, ": ", value,
             "' when looking at subproperty '", subprop, "'"].join(""));
diff --git a/layout/style/test/test_shorthand_property_getters.html b/layout/style/test/test_shorthand_property_getters.html
--- a/layout/style/test/test_shorthand_property_getters.html
+++ b/layout/style/test/test_shorthand_property_getters.html
@@ -122,12 +122,28 @@ is(e.style.background, "", "should not h
 // -moz-background-clip:content not yet supported
 //e.setAttribute("style", "background: red; -moz-background-clip: content");
 //is(e.style.background, "", "should not have background shorthand (clip:content)");
 //e.setAttribute("style", "background: red; -moz-background-clip: content; -moz-background-origin: content;");
 //isnot(e.style.background, "", "should have background shorthand (clip:content;origin:content)");
 e.setAttribute("style", "background: red; -moz-background-inline-policy: each-box");
 isnot(e.style.background, "", "should have background shorthand (-moz-background-inline-policy not relevant)");
 
+// Check that we only serialize transition when the lists are the same length.
+// FIXME: We should check this for background as well.
+e.setAttribute("style", "-moz-transition-property: color, width; -moz-transition-duration: 1s, 200ms; -moz-transition-timing-function: ease-in, linear; -moz-transition-delay: 0, 1s");
+isnot(e.style.MozTransition, "", "should have -moz-transition shorthand (lists same length)");
+e.setAttribute("style", "-moz-transition-property: color, width, left; -moz-transition-duration: 1s, 200ms; -moz-transition-timing-function: ease-in, linear; -moz-transition-delay: 0, 1s");
+is(e.style.MozTransition, "", "should not have -moz-transition shorthand (lists different lengths)");
+e.setAttribute("style", "-moz-transition-property: all; -moz-transition-duration: 1s, 200ms; -moz-transition-timing-function: ease-in, linear; -moz-transition-delay: 0, 1s");
+is(e.style.MozTransition, "", "should not have -moz-transition shorthand (lists different lengths)");
+e.setAttribute("style", "-moz-transition-property: color, width; -moz-transition-duration: 1s, 200ms, 300ms; -moz-transition-timing-function: ease-in, linear; -moz-transition-delay: 0, 1s");
+is(e.style.MozTransition, "", "should not have -moz-transition shorthand (lists different lengths)");
+e.setAttribute("style", "-moz-transition-property: color, width; -moz-transition-duration: 1s, 200ms; -moz-transition-timing-function: ease-in, linear, ease-out; -moz-transition-delay: 0, 1s");
+is(e.style.MozTransition, "", "should not have -moz-transition shorthand (lists different lengths)");
+e.setAttribute("style", "-moz-transition-property: color, width; -moz-transition-duration: 1s, 200ms; -moz-transition-timing-function: ease-in, linear; -moz-transition-delay: 0, 1s, 0");
+is(e.style.MozTransition, "", "should not have -moz-transition shorthand (lists different lengths)");
+
+
 </script>
 </pre>
 </body>
 </html>
diff --git a/layout/style/test/test_transitions_computed_values.html b/layout/style/test/test_transitions_computed_values.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_transitions_computed_values.html
@@ -0,0 +1,78 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=435441
+-->
+<head>
+  <title>Test for Bug 435441</title>
+  <script type="application/javascript" src="/MochiKit/packed.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=435441">Mozilla Bug 435441</a>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 435441 **/
+
+
+/*
+ * test that when transition properties are inherited, the length of the
+ * computed value stays the same
+ */
+
+var p = document.getElementById("content");
+var c = document.createElement("div");
+p.appendChild(c);
+var cs = getComputedStyle(c, "");
+
+p.style.MozTransitionProperty = "margin-left, margin-right";
+c.style.MozTransitionProperty = "inherit";
+is(cs.MozTransitionProperty, "margin-left, margin-right",
+   "computed style match with no other properties");
+c.style.MozTransitionDuration = "5s";
+is(cs.MozTransitionProperty, "margin-left, margin-right",
+   "computed style match with shorter property");
+is(cs.MozTransitionDuration, "5s",
+   "shorter property not extended");
+c.style.MozTransitionDuration = "5s, 4s, 3s, 2000ms";
+is(cs.MozTransitionProperty, "margin-left, margin-right",
+   "computed style match with longer property");
+is(cs.MozTransitionDuration, "5s, 4s, 3s, 2s",
+   "longer property computed correctly");
+p.style.MozTransitionProperty = "";
+c.style.MozTransitionProperty = "";
+c.style.MozTransitionDuration = "";
+
+// and repeat the above set of tests with property and duration swapped
+p.style.MozTransitionDuration = "5s, 4s";
+c.style.MozTransitionDuration = "inherit";
+is(cs.MozTransitionDuration, "5s, 4s",
+   "computed style match with no other properties");
+c.style.MozTransitionProperty = "margin-left";
+is(cs.MozTransitionDuration, "5s, 4s",
+   "computed style match with shorter property");
+is(cs.MozTransitionProperty, "margin-left",
+   "shorter property not extended");
+c.style.MozTransitionProperty =
+  "margin-left, margin-right, margin-top, margin-bottom";
+is(cs.MozTransitionDuration, "5s, 4s",
+   "computed style match with longer property");
+is(cs.MozTransitionProperty,
+   "margin-left, margin-right, margin-top, margin-bottom",
+   "longer property computed correctly");
+p.style.MozTransitionDuration = "";
+c.style.MozTransitionDuration = "";
+c.style.MozTransitionProperty = "";
+
+// FIXME: Given the structure of the code, we really need to test all
+// four properties here.
+
+</script>
+</pre>
+</body>
+</html>
