From: Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, L. David Baron <dbaron@dbaron.org>

Implement CSS transitions: implement the parsing and computation of the transition properties.  (Bug 435441)

diff --git a/dom/interfaces/css/nsIDOMNSCSS2Properties.idl b/dom/interfaces/css/nsIDOMNSCSS2Properties.idl
--- a/dom/interfaces/css/nsIDOMNSCSS2Properties.idl
+++ b/dom/interfaces/css/nsIDOMNSCSS2Properties.idl
@@ -17,16 +17,17 @@
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 2000
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Vidur Apparao <vidur@netscape.com> (original author)
  *   Johnny Stenback <jst@netscape.com>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -34,17 +35,17 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsIDOMCSS2Properties.idl"
 
-[scriptable, uuid(643f64d3-6b95-4d9a-ac75-c01a6f4c88cb)]
+[scriptable, uuid(73902da2-9475-4e96-b0ed-85003721cf37)]
 interface nsIDOMNSCSS2Properties : nsIDOMCSS2Properties
 {
            /* Non-DOM 2 extensions */
 
            /* Mozilla extension CSS properties */
            attribute DOMString        MozAppearance;
                                         // raises(DOMException) on setting
 
@@ -254,10 +255,25 @@ interface nsIDOMNSCSS2Properties : nsIDO
            attribute DOMString        MozTransformOrigin;
                                         // raises(DOMException) on setting 
 
            attribute DOMString        MozWindowShadow;
                                         // raises(DOMException) on setting
 
            attribute DOMString        MozBackgroundSize;
                                         // raises(DOMException) on setting
-	
+
+           attribute DOMString        MozTransitionProperty;
+                                        // raises(DOMException) on setting
+
+           attribute DOMString        MozTransitionDuration;
+                                        // raises(DOMException) on setting
+
+           attribute DOMString        MozTransitionDelay;
+                                        // raises(DOMException) on setting
+
+           attribute DOMString        MozTransitionTimingFunction;
+                                        // raises(DOMException) on setting
+
+           attribute DOMString        MozTransition;
+                                        // raises(DOMException) on setting
+
 };
diff --git a/layout/base/nsStyleConsts.h b/layout/base/nsStyleConsts.h
--- a/layout/base/nsStyleConsts.h
+++ b/layout/base/nsStyleConsts.h
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -613,16 +614,23 @@
 #define NS_STYLE_TEXT_DECORATION_LINES_MASK     (NS_STYLE_TEXT_DECORATION_UNDERLINE | NS_STYLE_TEXT_DECORATION_OVERLINE | NS_STYLE_TEXT_DECORATION_LINE_THROUGH)
 
 // See nsStyleText
 #define NS_STYLE_TEXT_TRANSFORM_NONE            0
 #define NS_STYLE_TEXT_TRANSFORM_CAPITALIZE      1
 #define NS_STYLE_TEXT_TRANSFORM_LOWERCASE       2
 #define NS_STYLE_TEXT_TRANSFORM_UPPERCASE       3
 
+// See nsStyleDisplay
+#define NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE         0
+#define NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR       1
+#define NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN      2
+#define NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT     3
+#define NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT  4
+
 // See nsStyleText
 // Note: these values pickup after the text-align values because there
 // are a few html cases where an object can have both types of
 // alignment applied with a single attribute
 #define NS_STYLE_VERTICAL_ALIGN_BASELINE             11
 #define NS_STYLE_VERTICAL_ALIGN_SUB                  12
 #define NS_STYLE_VERTICAL_ALIGN_SUPER                13
 #define NS_STYLE_VERTICAL_ALIGN_TOP                  14
diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -17,16 +17,18 @@
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Daniel Glazman <glazman@netscape.com>
  *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -247,48 +249,53 @@ nsCSSDeclaration::AppendCSSValueToString
     nsAutoString  buffer;
     aValue.GetStringValue(buffer);
     if (unit == eCSSUnit_String) {
       nsStyleUtil::AppendEscapedCSSString(buffer, aResult);
     } else {
       aResult.Append(buffer);
     }
   }
-  else if (eCSSUnit_Array <= unit && unit <= eCSSUnit_Counters) {
+  else if (eCSSUnit_Array <= unit && unit <= eCSSUnit_Cubic_Bezier) {
     switch (unit) {
       case eCSSUnit_Counter:  aResult.AppendLiteral("counter(");  break;
       case eCSSUnit_Counters: aResult.AppendLiteral("counters("); break;
+      case eCSSUnit_Cubic_Bezier: aResult.AppendLiteral("cubic-bezier("); break;
       default: break;
     }
 
     nsCSSValue::Array *array = aValue.GetArrayValue();
     PRBool mark = PR_FALSE;
     for (PRUint16 i = 0, i_end = array->Count(); i < i_end; ++i) {
       if (aProperty == eCSSProperty_border_image && i >= 5) {
         if (array->Item(i).GetUnit() == eCSSUnit_Null) {
           continue;
         }
         if (i == 5) {
           aResult.AppendLiteral(" /");
         }
       }
       if (mark && array->Item(i).GetUnit() != eCSSUnit_Null) {
-        if (unit == eCSSUnit_Array)
+        if (unit == eCSSUnit_Array &&
+            eCSSProperty_transition_timing_function != aProperty)
           aResult.AppendLiteral(" ");
         else
           aResult.AppendLiteral(", ");
       }
       nsCSSProperty prop =
         ((eCSSUnit_Counter <= unit && unit <= eCSSUnit_Counters) &&
          i == array->Count() - 1)
         ? eCSSProperty_list_style_type : aProperty;
       if (AppendCSSValueToString(prop, array->Item(i), aResult)) {
         mark = PR_TRUE;
       }
     }
+    if (eCSSUnit_Array == unit && aProperty == eCSSProperty_transition_timing_function) {
+      aResult.AppendLiteral(")");
+    }
   }
   /* Although Function is backed by an Array, we'll handle it separately
    * because it's a bit quirky.
    */
   else if (eCSSUnit_Function == unit) {
     const nsCSSValue::Array* array = aValue.GetArrayValue();
     NS_ASSERTION(array->Count() >= 1, "Functions must have at least one element for the name.");
 
@@ -346,16 +353,19 @@ nsCSSDeclaration::AppendCSSValueToString
       }
       if ((NS_STYLE_PAGE_MARKS_REGISTER & intValue) != 0) {
         if ((NS_STYLE_PAGE_MARKS_CROP & intValue) != 0) {
           aResult.Append(PRUnichar(' '));
         }
         AppendASCIItoUTF16(nsCSSProps::LookupPropertyValue(aProperty, NS_STYLE_PAGE_MARKS_REGISTER), aResult);
       }
     }
+    else if (eCSSProperty_transition_property == aProperty) {
+      AppendASCIItoUTF16(nsCSSProps::GetStringValue((nsCSSProperty) aValue.GetIntValue()), aResult);
+    }
     else {
       const nsAFlatCString& name = nsCSSProps::LookupPropertyValue(aProperty, aValue.GetIntValue());
       AppendASCIItoUTF16(name, aResult);
     }
   }
   else if (eCSSUnit_EnumColor == unit) {
     // we can lookup the property in the ColorTable and then
     // get a string mapping the name
@@ -460,29 +470,31 @@ nsCSSDeclaration::AppendCSSValueToString
   switch (unit) {
     case eCSSUnit_Null:         break;
     case eCSSUnit_Auto:         aResult.AppendLiteral("auto");     break;
     case eCSSUnit_Inherit:      aResult.AppendLiteral("inherit");  break;
     case eCSSUnit_Initial:      aResult.AppendLiteral("-moz-initial"); break;
     case eCSSUnit_None:         aResult.AppendLiteral("none");     break;
     case eCSSUnit_Normal:       aResult.AppendLiteral("normal");   break;
     case eCSSUnit_System_Font:  aResult.AppendLiteral("-moz-use-system-font"); break;
+    case eCSSUnit_All:          aResult.AppendLiteral("all"); break;
     case eCSSUnit_Dummy:
     case eCSSUnit_DummyInherit:
     case eCSSUnit_RectIsAuto:
       NS_NOTREACHED("should never serialize");
       break;
 
     case eCSSUnit_String:       break;
     case eCSSUnit_Ident:        break;
     case eCSSUnit_Families:     break;
     case eCSSUnit_URL:          break;
     case eCSSUnit_Image:        break;
     case eCSSUnit_Array:        break;
     case eCSSUnit_Attr:
+    case eCSSUnit_Cubic_Bezier:
     case eCSSUnit_Counter:
     case eCSSUnit_Counters:     aResult.Append(PRUnichar(')'));    break;
     case eCSSUnit_Local_Font:   break;
     case eCSSUnit_Font_Format:  break;
     case eCSSUnit_Function:     break;
     case eCSSUnit_Integer:      break;
     case eCSSUnit_Enumerated:   break;
     case eCSSUnit_EnumColor:    break;
@@ -994,16 +1006,59 @@ nsCSSDeclaration::GetValue(nsCSSProperty
     case eCSSProperty_pause: {
       if (AppendValueToString(eCSSProperty_pause_before, aValue)) {
         aValue.Append(PRUnichar(' '));
         if (!AppendValueToString(eCSSProperty_pause_after, aValue))
           aValue.Truncate();
       }
       break;
     }
+    case eCSSProperty_transition: {
+#define NUM_TRANSITION_SUBPROPS 4
+      const nsCSSProperty* subprops =
+        nsCSSProps::SubpropertyEntryFor(aProperty);
+#ifdef DEBUG
+      for (int i = 0; i < NUM_TRANSITION_SUBPROPS; ++i) {
+        NS_ASSERTION(nsCSSProps::kTypeTable[subprops[i]] == eCSSType_ValueList,
+                     "type mismatch");
+      }
+      NS_ASSERTION(subprops[NUM_TRANSITION_SUBPROPS] == eCSSProperty_UNKNOWN,
+                   "length mismatch");
+#endif
+      const nsCSSValueList* val[NUM_TRANSITION_SUBPROPS];
+      for (int i = 0; i < NUM_TRANSITION_SUBPROPS; ++i) {
+        val[i] = *data->ValueListStorageFor(subprops[i]);
+      }
+      // Merge the lists of the subproperties into a single list.
+      for (;;) {
+        for (int i = 0; i < NUM_TRANSITION_SUBPROPS; ++i) {
+          AppendCSSValueToString(subprops[i], val[i]->mValue, aValue);
+          aValue.Append(PRUnichar(' '));
+          val[i] = val[i]->mNext;
+        }
+        // Remove the last space.
+        aValue.Truncate(aValue.Length() - 1);
+
+        PR_STATIC_ASSERT(NUM_TRANSITION_SUBPROPS == 4);
+        if (!val[0] || !val[1] || !val[2] || !val[3]) {
+          break;
+        }
+        aValue.AppendLiteral(", ");
+      }
+
+      PR_STATIC_ASSERT(NUM_TRANSITION_SUBPROPS == 4);
+      if (val[0] || val[1] || val[2] || val[3]) {
+        // The sublists are different lengths, so this can't be
+        // represented as the shorthand.
+        aValue.Truncate();
+      }
+#undef NUM_TRANSITION_SUBPROPS 4
+      break;
+    }
+
 #ifdef MOZ_SVG
     case eCSSProperty_marker: {
       const nsCSSValue &endValue =
         *data->ValueStorageFor(eCSSProperty_marker_end);
       const nsCSSValue &midValue =
         *data->ValueStorageFor(eCSSProperty_marker_mid);
       const nsCSSValue &startValue =
         *data->ValueStorageFor(eCSSProperty_marker_start);
diff --git a/layout/style/nsCSSKeywordList.h b/layout/style/nsCSSKeywordList.h
--- a/layout/style/nsCSSKeywordList.h
+++ b/layout/style/nsCSSKeywordList.h
@@ -260,16 +260,20 @@ CSS_KEY(deg, deg)
 CSS_KEY(dialog, dialog)
 CSS_KEY(digits, digits)
 CSS_KEY(disabled, disabled)
 CSS_KEY(disc, disc)
 CSS_KEY(dotted, dotted)
 CSS_KEY(double, double)
 CSS_KEY(e-resize, e_resize)
 CSS_KEY(each-box, each_box)
+CSS_KEY(ease, ease)
+CSS_KEY(ease-in, ease_in)
+CSS_KEY(ease-in-out, ease_in_out)
+CSS_KEY(ease-out, ease_out)
 CSS_KEY(element, element)
 CSS_KEY(elements, elements)
 CSS_KEY(em, em)
 CSS_KEY(embed, embed)
 CSS_KEY(enabled, enabled)
 CSS_KEY(end, end)
 CSS_KEY(ex, ex)
 CSS_KEY(expanded, expanded)
@@ -326,16 +330,17 @@ CSS_KEY(landscape, landscape)
 CSS_KEY(large, large)
 CSS_KEY(larger, larger)
 CSS_KEY(left, left)
 CSS_KEY(left-side, left_side)
 CSS_KEY(leftwards, leftwards)
 CSS_KEY(level, level)
 CSS_KEY(lighter, lighter)
 CSS_KEY(line-through, line_through)
+CSS_KEY(linear, linear)
 CSS_KEY(list-item, list_item)
 CSS_KEY(logical, logical)
 CSS_KEY(loud, loud)
 CSS_KEY(low, low)
 CSS_KEY(lower, lower)
 CSS_KEY(lower-alpha, lower_alpha)
 CSS_KEY(lower-greek, lower_greek)
 CSS_KEY(lower-latin, lower_latin)
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -22,16 +22,18 @@
  * Contributor(s):
  *   emk <VYV03354@nifty.ne.jp>
  *   Daniel Glazman <glazman@netscape.com>
  *   L. David Baron <dbaron@dbaron.org>
  *   Boris Zbarsky <bzbarsky@mit.edu>
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   Christian Biesinger <cbiesinger@web.de>
  *   Jeff Walden <jwalden+code@mit.edu>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
+ *   Siraj Razick <siraj.razick@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -102,16 +104,18 @@
 #define VARIANT_ATTR            0x001000  //
 #define VARIANT_IDENTIFIER      0x002000  // D
 #define VARIANT_AUTO            0x010000  // A
 #define VARIANT_INHERIT         0x020000  // H eCSSUnit_Initial, eCSSUnit_Inherit
 #define VARIANT_NONE            0x040000  // O
 #define VARIANT_NORMAL          0x080000  // M
 #define VARIANT_SYSFONT         0x100000  // eCSSUnit_System_Font
 #define VARIANT_GRADIENT        0x200000  // eCSSUnit_Gradient
+#define VARIANT_CUBIC_BEZIER    0x400000  // CSS transition timing function
+#define VARIANT_ALL             0x800000  //
 
 // Common combinations of variants
 #define VARIANT_AL   (VARIANT_AUTO | VARIANT_LENGTH)
 #define VARIANT_LP   (VARIANT_LENGTH | VARIANT_PERCENT)
 #define VARIANT_AH   (VARIANT_AUTO | VARIANT_INHERIT)
 #define VARIANT_AHLP (VARIANT_AH | VARIANT_LP)
 #define VARIANT_AHI  (VARIANT_AH | VARIANT_INTEGER)
 #define VARIANT_AHK  (VARIANT_AH | VARIANT_KEYWORD)
@@ -137,16 +141,17 @@
 #define VARIANT_HCK  (VARIANT_HK | VARIANT_COLOR)
 #define VARIANT_HUO  (VARIANT_INHERIT | VARIANT_URL | VARIANT_NONE)
 #define VARIANT_AHUO (VARIANT_AUTO | VARIANT_HUO)
 #define VARIANT_HPN  (VARIANT_INHERIT | VARIANT_PERCENT | VARIANT_NUMBER)
 #define VARIANT_HOK  (VARIANT_HK | VARIANT_NONE)
 #define VARIANT_HN   (VARIANT_INHERIT | VARIANT_NUMBER)
 #define VARIANT_HON  (VARIANT_HN | VARIANT_NONE)
 #define VARIANT_HOS  (VARIANT_INHERIT | VARIANT_NONE | VARIANT_STRING)
+#define VARIANT_TIMING_FUNCTION (VARIANT_KEYWORD | VARIANT_CUBIC_BEZIER)
 
 //----------------------------------------------------------------------
 
 // Your basic top-down recursive descent style parser
 class CSSParserImpl : public nsICSSParser {
 public:
   CSSParserImpl();
   virtual ~CSSParserImpl();
@@ -470,16 +475,24 @@ protected:
   PRBool ParsePause();
   PRBool ParseQuotes();
   PRBool ParseSize();
   PRBool ParseTextDecoration(nsCSSValue& aValue);
 
   nsCSSValueList* ParseCSSShadowList(PRBool aIsBoxShadow);
   PRBool ParseTextShadow();
   PRBool ParseBoxShadow();
+  PRBool ParseTransitionTime(nsCSSProperty aPropID);
+  PRBool ParseTransitionProperty();
+  PRBool ParseTransition();
+  PRBool ParseTransitionTimingFunction();
+  PRBool ParseTransitionTimingFunctionValues(nsCSSValue& aValue);
+  PRBool ParseTransitionTimingFunctionValueComponent(float& aComponent, char aStop);
+  PRBool AppendValueToList(nsCSSValueList**& aListTail,
+                           const nsCSSValue& aValue);
 
 #ifdef MOZ_SVG
   PRBool ParsePaint(nsCSSValuePair* aResult,
                     nsCSSProperty aPropID);
   PRBool ParseDasharray();
   PRBool ParseMarker();
 #endif
 
@@ -4331,17 +4344,20 @@ CSSParserImpl::TranslateDimension(nsCSSV
   VARIANT_STRING | \
   VARIANT_COUNTER | \
   VARIANT_ATTR | \
   VARIANT_IDENTIFIER | \
   VARIANT_AUTO | \
   VARIANT_INHERIT | \
   VARIANT_NONE | \
   VARIANT_NORMAL | \
-  VARIANT_SYSFONT
+  VARIANT_SYSFONT | \
+  VARIANT_GRADIENT | \
+  VARIANT_CUBIC_BEZIER | \
+  VARIANT_ALL
 
 PRBool
 CSSParserImpl::ParseNonNegativeVariant(nsCSSValue& aValue,
                                        PRInt32 aVariantMask,
                                        const PRInt32 aKeywordTable[])
 {
   // The variant mask must only contain non-numeric variants or the ones
   // that we specifically handle.
@@ -4408,17 +4424,17 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
   NS_ASSERTION(IsParsingCompoundProperty() ||
                ((~aVariantMask) & (VARIANT_LENGTH|VARIANT_COLOR)),
                "cannot distinguish lengths and colors in quirks mode");
 
   if (!GetToken(PR_TRUE)) {
     return PR_FALSE;
   }
   nsCSSToken* tk = &mToken;
-  if (((aVariantMask & (VARIANT_AHK | VARIANT_NORMAL | VARIANT_NONE)) != 0) &&
+  if (((aVariantMask & (VARIANT_AHK | VARIANT_NORMAL | VARIANT_NONE | VARIANT_ALL)) != 0) &&
       (eCSSToken_Ident == tk->mType)) {
     nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(tk->mIdent);
     if (eCSSKeyword_UNKNOWN < keyword) { // known keyword
       if ((aVariantMask & VARIANT_AUTO) != 0) {
         if (eCSSKeyword_auto == keyword) {
           aValue.SetAutoValue();
           return PR_TRUE;
         }
@@ -4437,16 +4453,22 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
         }
       }
       if ((aVariantMask & VARIANT_NONE) != 0) {
         if (eCSSKeyword_none == keyword) {
           aValue.SetNoneValue();
           return PR_TRUE;
         }
       }
+      if ((aVariantMask & VARIANT_ALL) != 0) {
+        if (eCSSKeyword_all == keyword) {
+          aValue.SetAllValue();
+          return PR_TRUE;
+        }
+      }
       if ((aVariantMask & VARIANT_NORMAL) != 0) {
         if (eCSSKeyword_normal == keyword) {
           aValue.SetNormalValue();
           return PR_TRUE;
         }
       }
       if ((aVariantMask & VARIANT_SYSFONT) != 0) {
         if (eCSSKeyword__moz_use_system_font == keyword &&
@@ -4564,16 +4586,22 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
        tk->mIdent.LowerCaseEqualsLiteral("counters"))) {
     return ParseCounter(aValue);
   }
   if (((aVariantMask & VARIANT_ATTR) != 0) &&
       (eCSSToken_Function == tk->mType) &&
       tk->mIdent.LowerCaseEqualsLiteral("attr")) {
     return ParseAttr(aValue);
   }
+  if (((aVariantMask & VARIANT_CUBIC_BEZIER) != 0) &&
+      (eCSSToken_Function == tk->mType)) {
+     if (tk->mIdent.LowerCaseEqualsLiteral("cubic-bezier")) {
+      return ParseTransitionTimingFunctionValues(aValue);
+    }
+  }
 
   UngetToken();
   return PR_FALSE;
 }
 
 
 PRBool
 CSSParserImpl::ParseCounter(nsCSSValue& aValue)
@@ -5381,16 +5409,25 @@ CSSParserImpl::ParseProperty(nsCSSProper
   case eCSSProperty_size:
     return ParseSize();
   case eCSSProperty_text_shadow:
     return ParseTextShadow();
   case eCSSProperty__moz_transform:
     return ParseMozTransform();
   case eCSSProperty__moz_transform_origin:
     return ParseMozTransformOrigin();
+  case eCSSProperty_transition:
+      return ParseTransition();
+  case eCSSProperty_transition_property:
+    return ParseTransitionProperty();
+  case eCSSProperty_transition_timing_function:
+    return ParseTransitionTimingFunction();
+  case eCSSProperty_transition_duration:
+  case eCSSProperty_transition_delay:
+    return ParseTransitionTime(aPropID);
 
 #ifdef MOZ_SVG
   case eCSSProperty_fill:
     return ParsePaint(&mTempData.mSVG.mFill, eCSSProperty_fill);
   case eCSSProperty_stroke:
     return ParsePaint(&mTempData.mSVG.mStroke, eCSSProperty_stroke);
   case eCSSProperty_stroke_dasharray:
     return ParseDasharray();
@@ -5539,23 +5576,30 @@ CSSParserImpl::ParseSingleValueProperty(
   case eCSSProperty_padding_right:
   case eCSSProperty_padding_start:
   case eCSSProperty_pause:
   case eCSSProperty_quotes:
   case eCSSProperty_size:
   case eCSSProperty_text_shadow:
   case eCSSProperty__moz_transform:
   case eCSSProperty__moz_transform_origin:
+  case eCSSProperty_transition:
+  case eCSSProperty_transition_property:
+  case eCSSProperty_transition_timing_function:
+  case eCSSProperty_transition_duration:
+  case eCSSProperty_transition_delay:
   case eCSSProperty_COUNT:
 #ifdef MOZ_SVG
   case eCSSProperty_fill:
   case eCSSProperty_stroke:
   case eCSSProperty_stroke_dasharray:
   case eCSSProperty_marker:
 #endif
+  case eCSSPropertyExtra_no_properties:
+  case eCSSPropertyExtra_all_properties:
     NS_ERROR("not a single value property");
     return PR_FALSE;
 
   case eCSSProperty__x_system_font:
   case eCSSProperty_margin_left_ltr_source:
   case eCSSProperty_margin_left_rtl_source:
   case eCSSProperty_margin_right_ltr_source:
   case eCSSProperty_margin_right_rtl_source:
@@ -8259,16 +8303,410 @@ CSSParserImpl::ParseTextDecoration(nsCSS
       }
       aValue.SetIntValue(intValue, eCSSUnit_Enumerated);
     }
     return PR_TRUE;
   }
   return PR_FALSE;
 }
 
+
+PRBool
+CSSParserImpl::ParseTransitionTime(nsCSSProperty aPropID)
+{
+  NS_ABORT_IF_FALSE(aPropID == eCSSProperty_transition_duration ||
+                    aPropID == eCSSProperty_transition_delay,
+                    "Invalid property");
+  nsCSSValueList** storage =
+    aPropID == eCSSProperty_transition_duration
+      ? &mTempData.mDisplay.mTransitionDuration
+      : &mTempData.mDisplay.mTransitionDelay;
+
+  nsCSSValue timeval;
+  // first see if 'inherit' or '-moz-initial' is specified.  If one is,
+  // it can be the only thing specified, so don't attempt to parse any
+  // additional properties
+  if (ParseVariant(timeval, VARIANT_INHERIT, nsnull)) {
+    nsCSSValueList* list = new nsCSSValueList();
+    if (!list) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      return PR_FALSE;
+    }
+    list->mValue = timeval;
+    mTempData.SetPropertyBit(aPropID);
+    *storage = list;
+    return PR_TRUE;
+  }
+
+  // now try to parse normal time values
+  nsCSSValueList *listHead = nsnull;
+  nsCSSValueList **next = &listHead;
+
+  for (;;) {
+    if (!ParseVariant(timeval, VARIANT_TIME, nsnull)) {
+      break;
+    }
+    if (!AppendValueToList(next, timeval)) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    if (CheckEndProperty()) {
+      mTempData.SetPropertyBit(aPropID);
+      *storage = listHead;
+      return PR_TRUE;
+    }
+    if (!ExpectSymbol(',', PR_TRUE)) {
+      break;
+    }
+  }
+  delete listHead;
+  return PR_FALSE;
+}
+
+PRBool
+CSSParserImpl::ParseTransitionProperty()
+{
+  nsCSSValue value;
+  // first see if 'inherit', '-moz-initial', 'none', or 'all' is
+  // specified.  If one is, it can be the only thing specified, so don't
+  // attempt to parse any additional properties
+  if (ParseVariant(value, VARIANT_INHERIT | VARIANT_NONE | VARIANT_ALL,
+                   nsnull)) {
+    nsCSSValueList* list = new nsCSSValueList();
+    if (!list) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      return PR_FALSE;
+    }
+    list->mValue = value;
+    mTempData.SetPropertyBit(eCSSProperty_transition_property);
+    mTempData.mDisplay.mTransitionProperty = list;
+    return PR_TRUE;
+  }
+
+  // Accept a list of arbitrary identifiers.  They should be CSS
+  // properties, but we want to accept any so that we accept properties
+  // that we don't know about yet, e.g.
+  // transition-property: invalid-property, left, opacity;
+  nsCSSValueList *listHead = nsnull;
+  nsCSSValueList **next = &listHead;
+
+  for (;;) {
+    if (!ParseVariant(value, VARIANT_IDENTIFIER, nsnull)) {
+      break;
+    }
+    // Exclude 'none' and 'all' and 'inherit' and 'initial' according to
+    // the same rules as for 'counter-reset' in CSS 2.1 (except
+    // 'counter-reset' doesn't exclude 'all' since it doesn't support
+    // 'all' as a special value).
+    nsDependentString str(value.GetStringBufferValue());
+    if (str.EqualsLiteral("none") || str.EqualsLiteral("all") ||
+        str.EqualsLiteral("inherit") || str.EqualsLiteral("initial")) {
+      break;
+    }
+
+    if (!AppendValueToList(next, value)) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    if (CheckEndProperty()) {
+      mTempData.SetPropertyBit(eCSSProperty_transition_property);
+      mTempData.mDisplay.mTransitionProperty = listHead;
+      return PR_TRUE;
+    }
+    if (!ExpectSymbol(',', PR_TRUE)) {
+      break;
+    }
+  }
+  delete listHead;
+  return PR_FALSE;
+}
+
+PRBool
+CSSParserImpl::ParseTransitionTimingFunction()
+{
+  nsCSSValue timeFunction;
+  // first see if 'inherit' or '-moz-initial' is specified.  If one is,
+  // it can be the only thing specified, so don't attempt to parse any
+  // additional properties
+  if (ParseVariant(timeFunction, VARIANT_INHERIT, nsnull)) {
+    nsCSSValueList* list = new nsCSSValueList();
+    if (!list) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      return PR_FALSE;
+    }
+    list->mValue = timeFunction;
+    mTempData.SetPropertyBit(eCSSProperty_transition_timing_function);
+    mTempData.mDisplay.mTransitionTimingFunction = list;
+    return PR_TRUE;
+  }
+
+  nsCSSValueList *listHead = nsnull;
+  nsCSSValueList **next = &listHead;
+
+  for (;;) {
+    if (!ParseVariant(timeFunction, VARIANT_TIMING_FUNCTION,
+                      nsCSSProps::kTransitionTimingFunctionKTable)) {
+      break;
+    }
+    if (!AppendValueToList(next, timeFunction)) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    if (CheckEndProperty()) {
+      mTempData.SetPropertyBit(eCSSProperty_transition_timing_function);
+      mTempData.mDisplay.mTransitionTimingFunction = listHead;
+      return PR_TRUE;
+    }
+    if (!ExpectSymbol (',', PR_TRUE)) {
+      break;
+    }
+  }
+
+  delete listHead;
+  return PR_FALSE;
+}
+
+PRBool
+CSSParserImpl::ParseTransitionTimingFunctionValues(nsCSSValue& aValue)
+{
+  NS_ASSERTION(!mHavePushBack &&
+               mToken.mType == eCSSToken_Function &&
+               mToken.mIdent.LowerCaseEqualsLiteral("cubic-bezier"),
+               "unexpected initial state");
+
+  nsRefPtr<nsCSSValue::Array> val = nsCSSValue::Array::Create(4);
+  if (!val) {
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+    return PR_FALSE;
+  }
+
+  float x1,x2,y1,y2;
+  if (!ExpectSymbol('(', PR_FALSE) ||
+      !ParseTransitionTimingFunctionValueComponent(x1, ',') ||
+      !ParseTransitionTimingFunctionValueComponent(y1, ',') ||
+      !ParseTransitionTimingFunctionValueComponent(x2, ',') ||
+      !ParseTransitionTimingFunctionValueComponent(y2, ')')) {
+    return PR_FALSE;
+  }
+
+  val->Item(0).SetFloatValue(x1, eCSSUnit_Number);
+  val->Item(1).SetFloatValue(y1, eCSSUnit_Number);
+  val->Item(2).SetFloatValue(x2, eCSSUnit_Number);
+  val->Item(3).SetFloatValue(y2, eCSSUnit_Number);
+
+  aValue.SetArrayValue(val, eCSSUnit_Cubic_Bezier);
+
+  return PR_TRUE;
+}
+
+PRBool
+CSSParserImpl::ParseTransitionTimingFunctionValueComponent(float& aComponent,
+                                                           char aStop)
+{
+  if (!GetToken(PR_TRUE)) {
+    return PR_FALSE;
+  }
+  nsCSSToken* tk = &mToken;
+  if (tk->mType == eCSSToken_Number) {
+    aComponent = tk->mNumber;
+    if (ExpectSymbol(aStop, PR_TRUE)) {
+      return PR_TRUE;
+    }
+  }
+  return PR_FALSE;
+}
+
+PRBool
+CSSParserImpl::AppendValueToList(nsCSSValueList**& aListTail,
+                                 const nsCSSValue& aValue)
+{
+  NS_ABORT_IF_FALSE(!*aListTail, "should not have a next entry");
+  nsCSSValueList *entry = new nsCSSValueList();
+  if (!entry) {
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+    return PR_FALSE;
+  }
+  entry->mValue = aValue;
+  *aListTail = entry;
+  aListTail = &entry->mNext;
+  return PR_TRUE;
+}
+
+PRBool
+CSSParserImpl::ParseTransition()
+{
+  static const nsCSSProperty kTransitionProperties[] = {
+    eCSSProperty_transition_duration,
+    eCSSProperty_transition_timing_function,
+    // Must check 'transition-delay' after 'transition-duration', since
+    // that's our assumption about what the spec means for the shorthand
+    // syntax (the first time given is the duration, and the second
+    // given is the delay).
+    eCSSProperty_transition_delay,
+    // Must check 'transition-property' after
+    // 'transition-timing-function' since 'transition-property' accepts
+    // any keyword.
+    eCSSProperty_transition_property
+  };
+  static const PRUint32 numProps = NS_ARRAY_LENGTH(kTransitionProperties);
+  // this is a shorthand property that accepts -property, -delay,
+  // -duration, and -timing-function with some components missing.
+  // there can be multiple transitions, separated with commas
+
+  nsCSSValue tempValue;
+  // first see if 'inherit' or '-moz-initial' is specified.  If one is,
+  // it can be the only thing specified, so don't attempt to parse any
+  // additional properties
+  if (ParseVariant(tempValue, VARIANT_INHERIT, nsnull)) {
+    for (PRUint32 i = 0; i < numProps; ++i) {
+      nsCSSValueList* list = new nsCSSValueList();
+      if (!list) {
+        mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+        return PR_FALSE;
+      }
+      list->mValue = tempValue;
+      nsCSSProperty prop = kTransitionProperties[i];
+      *static_cast<nsCSSValueList**>(mTempData.PropertyAt(prop)) = list;
+      mTempData.SetPropertyBit(prop);
+    }
+    return PR_TRUE;
+  }
+
+  nsAutoPtr<nsCSSValueList> values[numProps];
+  nsCSSValueList **tails[numProps] = { getter_Transfers(values[0]),
+                                       getter_Transfers(values[1]),
+                                       getter_Transfers(values[2]),
+                                       getter_Transfers(values[3]) };
+  PRBool atEOP = PR_FALSE; // at end of property?
+  for (;;) { // loop over comma-separated transitions
+    // whether a particular subproperty was specified for this transition
+    PRBool parsedProperty[numProps] =
+      { PR_FALSE, PR_FALSE, PR_FALSE, PR_FALSE };
+    for (;;) { // loop over values within a transition
+      PRBool foundProperty = PR_FALSE;
+      // check to see if we're at the end of one full transition definition
+      // (either because we hit a comma or because we hit the end of the
+      // property definition)
+      if (ExpectSymbol(',', PR_TRUE))
+        break;
+      if (CheckEndProperty()) {
+        atEOP = PR_TRUE;
+        break;
+      }
+
+      // else, try to parse the next transition sub-property
+      for (PRUint32 i = 0; !foundProperty && i < numProps; ++i) {
+        if (!parsedProperty[i]) {
+          // if we haven't found this property yet, try to parse it
+          PRInt32 variantMask;
+          const PRInt32* table = nsnull;
+          switch (kTransitionProperties[i]) {
+            case eCSSProperty_transition_property:
+              variantMask = VARIANT_IDENTIFIER | VARIANT_NONE | VARIANT_ALL;
+              break;
+            case eCSSProperty_transition_duration:
+            case eCSSProperty_transition_delay:
+              variantMask = VARIANT_TIME;
+              break;
+            case eCSSProperty_transition_timing_function:
+              variantMask = VARIANT_TIMING_FUNCTION;
+              table = nsCSSProps::kTransitionTimingFunctionKTable;
+              break;
+            default:
+              NS_ABORT_IF_FALSE(PR_FALSE, "Invalid transition property");
+          }
+          if (ParseVariant(tempValue, variantMask, table)) {
+            parsedProperty[i] = PR_TRUE;
+            if (!AppendValueToList(tails[i], tempValue)) {
+              return PR_FALSE;
+            }
+            foundProperty = PR_TRUE;
+            break; // out of inner loop; continue looking for next sub-property
+          }
+        }
+      }
+      if (!foundProperty) {
+        // We're not at a ',' or at the end of the property, but we couldn't
+        // parse any of the sub-properties, so the declaration is invalid.
+        return PR_FALSE;
+      }
+    }
+
+    // We hit the end of the property or the end of one transition
+    // definition, add its components to the list.
+    for (PRUint32 i = 0; i < numProps; ++i) {
+      // If all of the subproperties were not explicitly specified, fill
+      // in the missing ones with initial values.
+      if (!parsedProperty[i]) {
+        switch (kTransitionProperties[i]) {
+          case eCSSProperty_transition_property:
+            tempValue.SetAllValue();
+            break;
+          case eCSSProperty_transition_duration:
+          case eCSSProperty_transition_delay:
+            tempValue.SetFloatValue(0.0, eCSSUnit_Seconds);
+            break;
+          case eCSSProperty_transition_timing_function:
+            tempValue.SetIntValue(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE,
+                                  eCSSUnit_Enumerated);
+            break;
+          default:
+            NS_ABORT_IF_FALSE(PR_FALSE, "Invalid transition property");
+        }
+        if (!AppendValueToList(tails[i], tempValue)) {
+          return PR_FALSE;
+        }
+      }
+    }
+
+    if (atEOP)
+      break;
+    // else we just hit a ',' so continue parsing the next compound transition
+  }
+
+  // Make two checks on the list for 'transition-property':
+  //   + If there is more than one item, then none of the items can be
+  //     'none' or 'all'.
+  //   + None of the items can be 'inherit' or 'initial' (this is the case,
+  //     like with counter-reset &c., where CSS 2.1 specifies 'initial', so
+  //     we should check it without the -moz- prefix).
+  {
+    NS_ABORT_IF_FALSE(kTransitionProperties[3] ==
+                        eCSSProperty_transition_property,
+                      "array index mismatch");
+    nsCSSValueList *l = values[3];
+    PRBool multipleItems = !!l->mNext;
+    do {
+      const nsCSSValue& val = l->mValue;
+      if (val.GetUnit() != eCSSUnit_Ident) {
+        NS_ABORT_IF_FALSE(val.GetUnit() == eCSSUnit_None ||
+                          val.GetUnit() == eCSSUnit_All, "unexpected unit");
+        if (multipleItems) {
+          // This is a syntax error.
+          return PR_FALSE;
+        }
+        continue;
+      }
+      nsDependentString str(val.GetStringBufferValue());
+      if (str.EqualsLiteral("inherit") || str.EqualsLiteral("initial")) {
+        return PR_FALSE;
+      }
+    } while ((l = l->mNext));
+  }
+
+  // Save all parsed transition sub-properties in mTempData
+  for (PRUint32 i = 0; i < numProps; ++i) {
+    nsCSSProperty prop = kTransitionProperties[i];
+    *static_cast<nsCSSValueList**>(mTempData.PropertyAt(prop)) =
+      values[i].forget();
+    mTempData.SetPropertyBit(prop);
+  }
+  return PR_TRUE;
+}
+
 nsCSSValueList*
 CSSParserImpl::ParseCSSShadowList(PRBool aIsBoxShadow)
 {
   nsAutoParseCompoundProperty compound(this);
 
   // Parses x, y, radius, color (in two possible orders)
   // This parses the input into a list. Either it contains just a "none" or
   // "inherit" value, or a list of arrays.
diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -15,16 +15,17 @@
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1999
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
@@ -2025,16 +2026,57 @@ CSS_PROP_POSITION(
     top,
     top,
     Top,
     0,
     Position,
     mOffset.mTop,
     eCSSType_Value,
     nsnull)
+CSS_PROP_SHORTHAND(
+    -moz-transition,
+    transition,
+    MozTransition,
+    0)
+CSS_PROP_DISPLAY(
+    -moz-transition-delay,
+    transition_delay,
+    MozTransitionDelay,
+    CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
+    Display,
+    mTransitionDelay,
+    eCSSType_ValueList,
+    nsnull)
+CSS_PROP_DISPLAY(
+    -moz-transition-duration,
+    transition_duration,
+    MozTransitionDuration,
+    CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
+    Display,
+    mTransitionDuration,
+    eCSSType_ValueList,
+    nsnull)
+CSS_PROP_DISPLAY(
+    -moz-transition-property,
+    transition_property,
+    MozTransitionProperty,
+    CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
+    Display,
+    mTransitionProperty,
+    eCSSType_ValueList /* list of CSS properties that have transitions ? */,
+    nsnull)
+CSS_PROP_DISPLAY(
+    -moz-transition-timing-function,
+    transition_timing_function,
+    MozTransitionTimingFunction,
+    CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
+    Display,
+    mTransitionTimingFunction,
+    eCSSType_ValueList,
+    kTransitionTimingFunctionKTable)
 CSS_PROP_TEXTRESET(
     unicode-bidi,
     unicode_bidi,
     UnicodeBidi,
     0,
     Text,
     mUnicodeBidi,
     eCSSType_Value,
diff --git a/layout/style/nsCSSProperty.h b/layout/style/nsCSSProperty.h
--- a/layout/style/nsCSSProperty.h
+++ b/layout/style/nsCSSProperty.h
@@ -15,16 +15,17 @@
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -59,16 +60,24 @@ enum nsCSSProperty {
   eCSSProperty_COUNT_DUMMY = eCSSProperty_COUNT_no_shorthands - 1,
 
   #define CSS_PROP_SHORTHAND(name_, id_, method_, flags_) eCSSProperty_##id_,
   #include "nsCSSPropList.h"
   #undef CSS_PROP_SHORTHAND
 
   eCSSProperty_COUNT,
 
+  // Some of the values below could probably overlap with each other and
+  // with eCSSProperty_COUNT if we had a need for them to do so.
+
+  // Extra values for use in the values of the 'transition-property'
+  // property.
+  eCSSPropertyExtra_no_properties,
+  eCSSPropertyExtra_all_properties,
+
   // Extra dummy values for nsCSSParser internal use.
   eCSSPropertyExtra_x_none_value
 };
 
 // The types of values that can be in the nsCSS*/nsRuleData* structs.
 // See nsCSSPropList.h for uses.
 enum nsCSSType {
   eCSSType_Value,
diff --git a/layout/style/nsCSSProps.cpp b/layout/style/nsCSSProps.cpp
--- a/layout/style/nsCSSProps.cpp
+++ b/layout/style/nsCSSProps.cpp
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1999
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -1104,16 +1105,25 @@ const PRInt32 nsCSSProps::kTextDecoratio
 
 const PRInt32 nsCSSProps::kTextTransformKTable[] = {
   eCSSKeyword_capitalize, NS_STYLE_TEXT_TRANSFORM_CAPITALIZE,
   eCSSKeyword_lowercase, NS_STYLE_TEXT_TRANSFORM_LOWERCASE,
   eCSSKeyword_uppercase, NS_STYLE_TEXT_TRANSFORM_UPPERCASE,
   eCSSKeyword_UNKNOWN,-1
 };
 
+const PRInt32 nsCSSProps::kTransitionTimingFunctionKTable[] = {
+  eCSSKeyword_ease, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE,
+  eCSSKeyword_linear, NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR,
+  eCSSKeyword_ease_in, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN,
+  eCSSKeyword_ease_out, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT, 
+  eCSSKeyword_ease_in_out, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT, 
+  eCSSKeyword_UNKNOWN,-1
+};
+
 const PRInt32 nsCSSProps::kUnicodeBidiKTable[] = {
   eCSSKeyword_embed, NS_STYLE_UNICODE_BIDI_EMBED,
   eCSSKeyword_bidi_override, NS_STYLE_UNICODE_BIDI_OVERRIDE,
   eCSSKeyword_UNKNOWN,-1
 };
 
 const PRInt32 nsCSSProps::kUserFocusKTable[] = {
   eCSSKeyword_ignore,         NS_STYLE_USER_FOCUS_IGNORE,
@@ -1909,16 +1919,24 @@ static const nsCSSProperty gMozPaddingEn
 };
 
 static const nsCSSProperty gPauseSubpropTable[] = {
   eCSSProperty_pause_after,
   eCSSProperty_pause_before,
   eCSSProperty_UNKNOWN
 };
 
+static const nsCSSProperty gMozTransitionSubpropTable[] = {
+  eCSSProperty_transition_property,
+  eCSSProperty_transition_duration,
+  eCSSProperty_transition_timing_function,
+  eCSSProperty_transition_delay,
+  eCSSProperty_UNKNOWN
+};
+
 #ifdef MOZ_SVG
 static const nsCSSProperty gMarkerSubpropTable[] = {
   eCSSProperty_marker_start,
   eCSSProperty_marker_mid,
   eCSSProperty_marker_end,
   eCSSProperty_UNKNOWN
 };
 #endif
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -231,16 +232,17 @@ public:
   static const PRInt32 kSpeakNumeralKTable[];
   static const PRInt32 kSpeakPunctuationKTable[];
   static const PRInt32 kSpeechRateKTable[];
   static const PRInt32 kStackSizingKTable[];
   static const PRInt32 kTableLayoutKTable[];
   static const PRInt32 kTextAlignKTable[];
   static const PRInt32 kTextDecorationKTable[];
   static const PRInt32 kTextTransformKTable[];
+  static const PRInt32 kTransitionTimingFunctionKTable[];
   static const PRInt32 kUnicodeBidiKTable[];
   static const PRInt32 kUserFocusKTable[];
   static const PRInt32 kUserInputKTable[];
   static const PRInt32 kUserModifyKTable[];
   static const PRInt32 kUserSelectKTable[];
   static const PRInt32 kVerticalAlignKTable[];
   static const PRInt32 kVisibilityKTable[];
   static const PRInt32 kVolumeKTable[];
diff --git a/layout/style/nsCSSStruct.cpp b/layout/style/nsCSSStruct.cpp
--- a/layout/style/nsCSSStruct.cpp
+++ b/layout/style/nsCSSStruct.cpp
@@ -266,16 +266,20 @@ nsCSSValueListRect::sides[4] = {
   &nsCSSValueListRect::mBottom,
   &nsCSSValueListRect::mLeft,
 };
 
 // --- nsCSSDisplay -----------------
 
 /* During allocation, null-out the transform list. */
 nsCSSDisplay::nsCSSDisplay(void) : mTransform(nsnull)
+  , mTransitionProperty(nsnull)
+  , mTransitionDuration(nsnull)
+  , mTransitionTimingFunction(nsnull)
+  , mTransitionDelay(nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSDisplay);
 }
 
 nsCSSDisplay::~nsCSSDisplay(void)
 {
   MOZ_COUNT_DTOR(nsCSSDisplay);
 }
diff --git a/layout/style/nsCSSStruct.h b/layout/style/nsCSSStruct.h
--- a/layout/style/nsCSSStruct.h
+++ b/layout/style/nsCSSStruct.h
@@ -370,16 +370,20 @@ struct nsCSSDisplay : public nsCSSStruct
   nsCSSValue mClear;
   nsCSSRect  mClip;
   nsCSSValue mOverflowX;
   nsCSSValue mOverflowY;
   nsCSSValue mVisibility;
   nsCSSValue mOpacity;
   nsCSSValueList *mTransform; // List of Arrays containing transform information
   nsCSSValuePair mTransformOrigin;
+  nsCSSValueList* mTransitionProperty;
+  nsCSSValueList* mTransitionDuration;
+  nsCSSValueList* mTransitionTimingFunction;
+  nsCSSValueList* mTransitionDelay;
 
   // temp fix for bug 24000 
   nsCSSValue mBreakBefore;
   nsCSSValue mBreakAfter;
   // end temp fix
 private:
   nsCSSDisplay(const nsCSSDisplay& aOther); // NOT IMPLEMENTED
 };
diff --git a/layout/style/nsCSSValue.cpp b/layout/style/nsCSSValue.cpp
--- a/layout/style/nsCSSValue.cpp
+++ b/layout/style/nsCSSValue.cpp
@@ -369,16 +369,22 @@ void nsCSSValue::SetInitialValue()
 }
 
 void nsCSSValue::SetNoneValue()
 {
   Reset();
   mUnit = eCSSUnit_None;
 }
 
+void nsCSSValue::SetAllValue()
+{
+  Reset();
+  mUnit = eCSSUnit_All;
+}
+
 void nsCSSValue::SetNormalValue()
 {
   Reset();
   mUnit = eCSSUnit_Normal;
 }
 
 void nsCSSValue::SetSystemFontValue()
 {
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -89,31 +89,33 @@ class nsIPrincipal;
 enum nsCSSUnit {
   eCSSUnit_Null         = 0,      // (n/a) null unit, value is not specified
   eCSSUnit_Auto         = 1,      // (n/a) value is algorithmic
   eCSSUnit_Inherit      = 2,      // (n/a) value is inherited
   eCSSUnit_Initial      = 3,      // (n/a) value is default UA value
   eCSSUnit_None         = 4,      // (n/a) value is none
   eCSSUnit_Normal       = 5,      // (n/a) value is normal (algorithmic, different than auto)
   eCSSUnit_System_Font  = 6,      // (n/a) value is -moz-use-system-font
-  eCSSUnit_Dummy        = 7,      // (n/a) a fake but specified value, used
+  eCSSUnit_All          = 7,      // (n/a) value is all
+  eCSSUnit_Dummy        = 8,      // (n/a) a fake but specified value, used
                                   //       only in temporary values
-  eCSSUnit_DummyInherit = 8,      // (n/a) a fake but specified value, used
+  eCSSUnit_DummyInherit = 9,      // (n/a) a fake but specified value, used
                                   //       only in temporary values
-  eCSSUnit_RectIsAuto   = 9,      // (n/a) 'auto' for an entire rect()
-  eCSSUnit_String       = 10,     // (PRUnichar*) a string value
-  eCSSUnit_Ident        = 11,     // (PRUnichar*) a string value
-  eCSSUnit_Families     = 12,     // (PRUnichar*) a string value
-  eCSSUnit_Attr         = 13,     // (PRUnichar*) a attr(string) value
-  eCSSUnit_Local_Font   = 14,     // (PRUnichar*) a local font name
-  eCSSUnit_Font_Format  = 15,     // (PRUnichar*) a font format name
+  eCSSUnit_RectIsAuto   = 10,     // (n/a) 'auto' for an entire rect()
+  eCSSUnit_String       = 11,     // (PRUnichar*) a string value
+  eCSSUnit_Ident        = 12,     // (PRUnichar*) a string value
+  eCSSUnit_Families     = 13,     // (PRUnichar*) a string value
+  eCSSUnit_Attr         = 14,     // (PRUnichar*) a attr(string) value
+  eCSSUnit_Local_Font   = 15,     // (PRUnichar*) a local font name
+  eCSSUnit_Font_Format  = 16,     // (PRUnichar*) a font format name
   eCSSUnit_Array        = 20,     // (nsCSSValue::Array*) a list of values
   eCSSUnit_Counter      = 21,     // (nsCSSValue::Array*) a counter(string,[string]) value
   eCSSUnit_Counters     = 22,     // (nsCSSValue::Array*) a counters(string,string[,string]) value
-  eCSSUnit_Function     = 23,     // (nsCSSValue::Array*) a function with parameters.  First elem of array is name,
+  eCSSUnit_Cubic_Bezier = 23,     // (nsCSSValue::Array*) a list of float values 
+  eCSSUnit_Function     = 24,     // (nsCSSValue::Array*) a function with parameters.  First elem of array is name,
                                   //  the rest of the values are arguments.
 
   eCSSUnit_URL          = 30,     // (nsCSSValue::URL*) value
   eCSSUnit_Image        = 31,     // (nsCSSValue::Image*) value
   eCSSUnit_Gradient     = 32,     // (nsCSSValueGradient*) value
   eCSSUnit_Integer      = 50,     // (int) simple value
   eCSSUnit_Enumerated   = 51,     // (int) value has enumerated meaning
   eCSSUnit_EnumColor    = 80,     // (int) enumerated color (kColorKTable)
@@ -165,17 +167,17 @@ public:
   friend struct Array;
 
   struct URL;
   friend struct URL;
 
   struct Image;
   friend struct Image;
   
-  // for valueless units only (null, auto, inherit, none, normal)
+  // for valueless units only (null, auto, inherit, none, all, normal)
   explicit nsCSSValue(nsCSSUnit aUnit = eCSSUnit_Null)
     : mUnit(aUnit)
   {
     NS_ASSERTION(aUnit <= eCSSUnit_RectIsAuto, "not a valueless unit");
   }
 
   nsCSSValue(PRInt32 aValue, nsCSSUnit aUnit) NS_HIDDEN;
   nsCSSValue(float aValue, nsCSSUnit aUnit) NS_HIDDEN;
@@ -318,16 +320,17 @@ public:
   NS_HIDDEN_(void)  SetArrayValue(nsCSSValue::Array* aArray, nsCSSUnit aUnit);
   NS_HIDDEN_(void)  SetURLValue(nsCSSValue::URL* aURI);
   NS_HIDDEN_(void)  SetImageValue(nsCSSValue::Image* aImage);
   NS_HIDDEN_(void)  SetGradientValue(nsCSSValueGradient* aGradient);
   NS_HIDDEN_(void)  SetAutoValue();
   NS_HIDDEN_(void)  SetInheritValue();
   NS_HIDDEN_(void)  SetInitialValue();
   NS_HIDDEN_(void)  SetNoneValue();
+  NS_HIDDEN_(void)  SetAllValue();
   NS_HIDDEN_(void)  SetNormalValue();
   NS_HIDDEN_(void)  SetSystemFontValue();
   NS_HIDDEN_(void)  SetDummyValue();
   NS_HIDDEN_(void)  SetDummyInheritValue();
   NS_HIDDEN_(void)  SetRectIsAutoValue();
   NS_HIDDEN_(void)  StartImageLoad(nsIDocument* aDocument)
                                    const;  // Not really const, but pretending
 
diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -21,16 +21,18 @@
  *
  * Contributor(s):
  *   Daniel Glazman <glazman@netscape.com>
  *   Boris Zbarsky <bzbarsky@mit.edu>
  *   Christopher A. Aillon <christopher@aillon.com>
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   Christian Biesinger <cbiesinger@web.de>
  *   Michael Ventnor <m.ventnor@gmail.com>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -42,16 +44,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 /* DOM object returned from element.getComputedStyle() */
 
 #include "nsComputedDOMStyle.h"
 
 #include "nsDOMError.h"
 #include "nsDOMString.h"
+#include "nsPrintfCString.h"
 #include "nsIDOMNSCSS2Properties.h"
 #include "nsIDOMElement.h"
 #include "nsIDOMCSSPrimitiveValue.h"
 #include "nsStyleContext.h"
 #include "nsIScrollableFrame.h"
 #include "nsContentUtils.h"
 #include "prprf.h"
 
@@ -4230,16 +4233,134 @@ nsComputedDOMStyle::GetMask(nsIDOMCSSVal
   else
     val->SetIdent(eCSSKeyword_none);
 
   return CallQueryInterface(val, aValue);
 }
 
 #endif // MOZ_SVG
 
+nsresult
+nsComputedDOMStyle::GetTransitionDelay(nsIDOMCSSValue** aValue)
+{
+  const nsStyleDisplay* display = GetStyleDisplay();
+
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  NS_ABORT_IF_FALSE(display->mTransitionDelayCount > 0,
+                    "first item must be explicit");
+  PRUint32 i = 0;
+  do {
+    const nsTransition *transition = &display->mTransitions[i];
+    nsROCSSPrimitiveValue* delay = GetROCSSPrimitiveValue();
+    if (!delay || !valueList->AppendCSSValue(delay)) {
+      delete valueList;
+      delete delay;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+    delay->SetTime((float)transition->GetDelay() / (float)PR_MSEC_PER_SEC);
+  } while (++i < display->mTransitionDelayCount);
+
+  return CallQueryInterface(valueList, aValue);
+}
+
+nsresult
+nsComputedDOMStyle::GetTransitionDuration(nsIDOMCSSValue** aValue)
+{
+  const nsStyleDisplay* display = GetStyleDisplay();
+
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  NS_ABORT_IF_FALSE(display->mTransitionDurationCount > 0,
+                    "first item must be explicit");
+  PRUint32 i = 0;
+  do {
+    const nsTransition *transition = &display->mTransitions[i];
+    nsROCSSPrimitiveValue* duration = GetROCSSPrimitiveValue();
+    if (!duration || !valueList->AppendCSSValue(duration)) {
+      delete valueList;
+      delete duration;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    duration->SetTime((float)transition->GetDuration() / (float)PR_MSEC_PER_SEC);
+  } while (++i < display->mTransitionDurationCount);
+
+  return CallQueryInterface(valueList, aValue);
+}
+
+nsresult
+nsComputedDOMStyle::GetTransitionProperty(nsIDOMCSSValue** aValue)
+{
+  const nsStyleDisplay* display = GetStyleDisplay();
+
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  NS_ABORT_IF_FALSE(display->mTransitionPropertyCount > 0,
+                    "first item must be explicit");
+  PRUint32 i = 0;
+  do {
+    const nsTransition *transition = &display->mTransitions[i];
+    nsROCSSPrimitiveValue* property = GetROCSSPrimitiveValue();
+    if (!property || !valueList->AppendCSSValue(property)) {
+      delete valueList;
+      delete property;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+    nsCSSProperty cssprop = transition->GetProperty();
+    if (cssprop == eCSSPropertyExtra_all_properties)
+      property->SetIdent(eCSSKeyword_all);
+    else if (cssprop == eCSSPropertyExtra_no_properties)
+      property->SetIdent(eCSSKeyword_none);
+    else if (cssprop == eCSSProperty_UNKNOWN)
+    {
+      const char *str;
+      transition->GetUnknownProperty()->GetUTF8String(&str);
+      property->SetString(nsDependentCString(str)); // really want SetIdent
+    }
+    else
+      property->SetString(nsCSSProps::GetStringValue(cssprop));
+  } while (++i < display->mTransitionPropertyCount);
+
+  return CallQueryInterface(valueList, aValue);
+}
+
+nsresult
+nsComputedDOMStyle::GetTransitionTimingFunction(nsIDOMCSSValue** aValue)
+{
+  const nsStyleDisplay* display = GetStyleDisplay();
+
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  NS_ABORT_IF_FALSE(display->mTransitionTimingFunctionCount > 0,
+                    "first item must be explicit");
+  PRUint32 i = 0;
+  do {
+    const nsTransition *transition = &display->mTransitions[i];
+    nsROCSSPrimitiveValue* timingFunction = GetROCSSPrimitiveValue();
+    if (!timingFunction || !valueList->AppendCSSValue(timingFunction)) {
+      delete valueList;
+      delete timingFunction;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    // set the value from the cubic-bezier control points
+    // (We could try to regenerate the keywords if we want.)
+    const nsTimingFunction& tf = transition->GetTimingFunction();
+    timingFunction->SetString(
+      nsPrintfCString(64, "cubic-bezier(%f, %f, %f, %f)",
+                          tf.mX1, tf.mY1, tf.mX2, tf.mY2));
+  } while (++i < display->mTransitionTimingFunctionCount);
+
+  return CallQueryInterface(valueList, aValue);
+}
 
 #define COMPUTED_STYLE_MAP_ENTRY(_prop, _method)              \
   { eCSSProperty_##_prop, &nsComputedDOMStyle::Get##_method, PR_FALSE }
 #define COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_prop, _method)       \
   { eCSSProperty_##_prop, &nsComputedDOMStyle::Get##_method, PR_TRUE }
 
 const nsComputedDOMStyle::ComputedStyleMapEntry*
 nsComputedDOMStyle::GetQueryablePropertyMap(PRUint32* aLength)
@@ -4432,16 +4553,20 @@ nsComputedDOMStyle::GetQueryableProperty
     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_outline_radius_topRight,   OutlineRadiusTopRight),
     COMPUTED_STYLE_MAP_ENTRY(stack_sizing,                  StackSizing),
     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_transform,         MozTransform),
     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_transform_origin,  MozTransformOrigin),
     COMPUTED_STYLE_MAP_ENTRY(user_focus,                    UserFocus),
     COMPUTED_STYLE_MAP_ENTRY(user_input,                    UserInput),
     COMPUTED_STYLE_MAP_ENTRY(user_modify,                   UserModify),
     COMPUTED_STYLE_MAP_ENTRY(user_select,                   UserSelect),
+    COMPUTED_STYLE_MAP_ENTRY(transition_delay,              TransitionDelay),
+    COMPUTED_STYLE_MAP_ENTRY(transition_duration,           TransitionDuration),
+    COMPUTED_STYLE_MAP_ENTRY(transition_property,           TransitionProperty),
+    COMPUTED_STYLE_MAP_ENTRY(transition_timing_function,    TransitionTimingFunction),
     COMPUTED_STYLE_MAP_ENTRY(_moz_window_shadow,            WindowShadow),
     COMPUTED_STYLE_MAP_ENTRY(word_wrap,                     WordWrap)
 
 #ifdef MOZ_SVG
     ,
     COMPUTED_STYLE_MAP_ENTRY(clip_path,                     ClipPath),
     COMPUTED_STYLE_MAP_ENTRY(clip_rule,                     ClipRule),
     COMPUTED_STYLE_MAP_ENTRY(color_interpolation,           ColorInterpolation),
diff --git a/layout/style/nsComputedDOMStyle.h b/layout/style/nsComputedDOMStyle.h
--- a/layout/style/nsComputedDOMStyle.h
+++ b/layout/style/nsComputedDOMStyle.h
@@ -310,16 +310,22 @@ private:
   /* Column properties */
   nsresult GetColumnCount(nsIDOMCSSValue** aValue);
   nsresult GetColumnWidth(nsIDOMCSSValue** aValue);
   nsresult GetColumnGap(nsIDOMCSSValue** aValue);
   nsresult GetColumnRuleWidth(nsIDOMCSSValue** aValue);
   nsresult GetColumnRuleStyle(nsIDOMCSSValue** aValue);
   nsresult GetColumnRuleColor(nsIDOMCSSValue** aValue);
 
+  /* CSS Transitions */
+  nsresult GetTransitionProperty(nsIDOMCSSValue** aValue);
+  nsresult GetTransitionDuration(nsIDOMCSSValue** aValue);
+  nsresult GetTransitionDelay(nsIDOMCSSValue** aValue);
+  nsresult GetTransitionTimingFunction(nsIDOMCSSValue** aValue);
+
 #ifdef MOZ_SVG
   /* SVG properties */
   nsresult GetSVGPaintFor(PRBool aFill, nsIDOMCSSValue** aValue);
 
   nsresult GetFill(nsIDOMCSSValue** aValue);
   nsresult GetStroke(nsIDOMCSSValue** aValue);
   nsresult GetMarkerEnd(nsIDOMCSSValue** aValue);
   nsresult GetMarkerMid(nsIDOMCSSValue** aValue);
diff --git a/layout/style/nsROCSSPrimitiveValue.cpp b/layout/style/nsROCSSPrimitiveValue.cpp
--- a/layout/style/nsROCSSPrimitiveValue.cpp
+++ b/layout/style/nsROCSSPrimitiveValue.cpp
@@ -227,29 +227,34 @@ nsROCSSPrimitiveValue::GetCssText(nsAStr
             break;
           tmpStr.Append(comma + colorValue);
         }
 
         tmpStr.Append(NS_LITERAL_STRING(")"));
 
         break;
       }
+    case CSS_S :
+      {
+        tmpStr.AppendFloat(mValue.mFloat);
+        tmpStr.AppendLiteral("s");
+        break;
+      }
     case CSS_CM :
     case CSS_MM :
     case CSS_IN :
     case CSS_PT :
     case CSS_PC :
     case CSS_UNKNOWN :
     case CSS_EMS :
     case CSS_EXS :
     case CSS_DEG :
     case CSS_RAD :
     case CSS_GRAD :
     case CSS_MS :
-    case CSS_S :
     case CSS_HZ :
     case CSS_KHZ :
     case CSS_DIMENSION :
       NS_ERROR("We have a bogus value set.  This should not happen");
       return NS_ERROR_DOM_INVALID_ACCESS_ERR;
   }
 
   if (NS_SUCCEEDED(result)) {
diff --git a/layout/style/nsROCSSPrimitiveValue.h b/layout/style/nsROCSSPrimitiveValue.h
--- a/layout/style/nsROCSSPrimitiveValue.h
+++ b/layout/style/nsROCSSPrimitiveValue.h
@@ -177,16 +177,23 @@ public:
       NS_ADDREF(mValue.mRect);
       mType = CSS_RECT;
     }
     else {
       mType = CSS_UNKNOWN;
     }
   }
 
+  void SetTime(float aValue)
+  {
+    Reset();
+    mValue.mFloat = aValue;
+    mType = CSS_S;
+  }
+
   void Reset(void)
   {
     switch (mType) {
       case CSS_IDENT:
         break;
       case CSS_STRING:
       case CSS_ATTR:
       case CSS_COUNTER: // FIXME: Counter should use an object
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -23,16 +23,17 @@
  *   Original Author: David W. Hyatt (hyatt@netscape.com)
  *   Daniel Glazman <glazman@netscape.com>
  *   Roger B. Sidje <rbs@maths.uq.edu.au>
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   L. David Baron <dbaron@dbaron.org>
  *   Christian Biesinger <cbiesinger@web.de>
  *   Michael Ventnor <m.ventnor@gmail.com>
  *   Keith Rarick <kr@xph.us>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -3445,27 +3446,295 @@ static nsStyleTransformMatrix ReadTransf
     nsStyleTransformMatrix currMatrix;
     currMatrix.SetToTransformFunction(currElem.GetArrayValue(), aContext,
                                       aPresContext, aCanStoreInRuleTree);
     result *= currMatrix;
   }
   return result;
 }
 
+// A simple helper function to get the length of a nsCSSValueList
+inline static PRUint32 GetValueListLength(nsCSSValueList* aValueList)
+{
+  PRUint32 len = 0;
+  nsCSSValueList* val = aValueList;
+  while (val) {
+    len++;
+    val = val->mNext;
+  }
+  return len;
+}
+
+// Information about each transition property that is constant.
+struct TransitionPropInfo {
+  // Location of the property's specified value.
+  nsCSSValueList* nsRuleDataDisplay::* rdList;
+  // Location of the count of the property's computed value.
+  PRUint32 nsStyleDisplay::* sdCount;
+};
+
+// Each property's index in this array must match its index in the
+// mutable array |transitionPropData| below.
+static const TransitionPropInfo transitionPropInfo[4] = {
+  { &nsRuleDataDisplay::mTransitionDelay,
+    &nsStyleDisplay::mTransitionDelayCount },
+  { &nsRuleDataDisplay::mTransitionDuration,
+    &nsStyleDisplay::mTransitionDurationCount },
+  { &nsRuleDataDisplay::mTransitionProperty,
+    &nsStyleDisplay::mTransitionPropertyCount },
+  { &nsRuleDataDisplay::mTransitionTimingFunction,
+    &nsStyleDisplay::mTransitionTimingFunctionCount },
+};
+
+// Information about each transition property that changes during
+// ComputeDisplayData.
+struct TransitionPropData {
+  nsCSSValueList *list;
+  PRBool inherited;
+  PRUint32 num;
+};
+
 const void*
 nsRuleNode::ComputeDisplayData(void* aStartStruct,
                                const nsRuleDataStruct& aData, 
                                nsStyleContext* aContext, 
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Display, (), display, parentDisplay,
                       Display, displayData)
 
+  // Each property's index in this array must match its index in the
+  // const array |transitionPropInfo| above.
+  TransitionPropData transitionPropData[4];
+  TransitionPropData& delay = transitionPropData[0];
+  TransitionPropData& duration = transitionPropData[1];
+  TransitionPropData& property = transitionPropData[2];
+  TransitionPropData& timingFunction = transitionPropData[3];
+
+#define FOR_ALL_TRANSITION_PROPS(var_) \
+                                      for (PRUint32 var_ = 0; var_ < 4; ++var_)
+
+  // CSS Transitions
+
+  // The four transition properties are stored in nsCSSDisplay in a
+  // single array for all properties.  The number of transitions is
+  // equal to the number of items in the longest property's value.
+  // Properties that have fewer values than the longest are filled in by
+  // repeating the list.  However, this repetition does not extend the
+  // computed value of that particular property (for purposes of
+  // inheritance, or, in our code, for when other properties are
+  // overridden by a more specific rule).
+
+  // Transitions are difficult to handle correctly because of this.  For
+  // example, we need to handle scenarios such as:
+  //  * a more general rule specifies transition-property: a, b, c;
+  //  * a more specific rule overrides as transition-property: d;
+  //
+  // If only the general rule applied, we would fill in the extra
+  // properties (duration, delay, etc) with initial values to create 3
+  // fully-specified transitions.  But when the more specific rule
+  // applies, we should only create a single transition.  In order to do
+  // this we need to remember which properties were explicitly specified
+  // and which ones were just filled in with initial values to get a
+  // fully-specified transition, which we do by remembering the number
+  // of values for each property.
+
+  PRUint32 numTransitions = 0;
+  FOR_ALL_TRANSITION_PROPS(p) {
+    const TransitionPropInfo& i = transitionPropInfo[p];
+    TransitionPropData& d = transitionPropData[p];
+
+    d.list = displayData.*(i.rdList);
+
+    // cache whether any of the properties are specified as 'inherit' so
+    // we can use it below
+    d.inherited = d.list && d.list->mValue.GetUnit() == eCSSUnit_Inherit;
+    d.num = 0;
+
+    // General algorithm to determine how many total transitions we need
+    // to build.  For each property:
+    //  - if there is no value specified in for the property in
+    //    displayData, use the values from the start struct, but only if
+    //    they were explicitly specified
+    //  - if there is a value specified for the property in displayData:
+    //    - if the value is 'inherit', count the number of values for
+    //      that property are specified by the parent, but only those
+    //      that were explicitly specified
+    //    - otherwise, count the number of values specified in displayData
+
+
+    // calculate number of elements
+    if (d.list) {
+      if (d.inherited) {
+        d.num = parentDisplay->*(i.sdCount);
+        d.list = nsnull; // we don't need it
+      } else {
+        d.num = GetValueListLength(d.list);
+      }
+    } else {
+      d.num = display->*(i.sdCount);
+    }
+    if (d.num > numTransitions)
+      numTransitions = d.num;
+  }
+
+  if (!display->mTransitions.SetLength(numTransitions)) {
+    NS_WARNING("failed to allocate transitions array");
+    display->mTransitions.SetLength(1);
+    NS_ABORT_IF_FALSE(display->mTransitions.Length() == 1,
+                      "could not allocate using auto array buffer");
+    numTransitions = 1;
+    FOR_ALL_TRANSITION_PROPS(p) {
+      TransitionPropData& d = transitionPropData[p];
+
+      d.num = 1;
+    }
+  }
+
+  FOR_ALL_TRANSITION_PROPS(p) {
+    const TransitionPropInfo& i = transitionPropInfo[p];
+    TransitionPropData& d = transitionPropData[p];
+
+    display->*(i.sdCount) = d.num;
+  }
+
+  // Fill in the transitions we just allocated with the appropriate values.
+  for (PRUint32 i = 0; i < numTransitions; ++i) {
+    nsTransition *transition = &display->mTransitions[i];
+
+    if (i >= delay.num) {
+      transition->SetDelay(display->mTransitions[i % delay.num].GetDelay());
+    } else if (delay.inherited) {
+      // FIXME (for all transition properties): write a test that
+      // detects when this was wrong for i >= delay.num if parent had
+      // count for this property not equal to length
+      NS_ABORT_IF_FALSE(i < parentDisplay->mTransitionDelayCount,
+                        "delay.num computed incorrectly");
+      transition->SetDelay(parentDisplay->mTransitions[i].GetDelay());
+    } else {
+      switch (delay.list->mValue.GetUnit()) {
+        case eCSSUnit_Seconds:
+          transition->SetDelay(PR_MSEC_PER_SEC *
+                               delay.list->mValue.GetFloatValue());
+          break;
+        case eCSSUnit_Milliseconds:
+          transition->SetDelay(delay.list->mValue.GetFloatValue());
+          break;
+        case eCSSUnit_Initial:
+          transition->SetDelay(0.0);
+          break;
+        default:
+          NS_NOTREACHED("Invalid delay unit");
+      }
+    }
+
+    if (i >= duration.num) {
+      // FIXME: Write a test that detects that this was broken when it
+      // had GetDelay() instead.
+      transition->SetDuration(
+        display->mTransitions[i % duration.num].GetDuration());
+    } else if (duration.inherited) {
+      NS_ABORT_IF_FALSE(i < parentDisplay->mTransitionDurationCount,
+                        "duration.num computed incorrectly");
+      transition->SetDuration(parentDisplay->mTransitions[i].GetDuration());
+    } else if (duration.list) {
+      switch (duration.list->mValue.GetUnit()) {
+        case eCSSUnit_Seconds:
+          transition->SetDuration(PR_MSEC_PER_SEC *
+                                  duration.list->mValue.GetFloatValue());
+          break;
+        case eCSSUnit_Milliseconds:
+          transition->SetDuration(duration.list->mValue.GetFloatValue());
+          break;
+        case eCSSUnit_Initial:
+          transition->SetDuration(0.0);
+          break;
+        default:
+          NS_NOTREACHED("Invalid duration unit");
+      }
+    }
+
+    if (i >= property.num) {
+      // FIXME: Add test for this not copying mUnknownProperty.
+      transition->CopyPropertyFrom(display->mTransitions[i % property.num]);
+    } else if (property.inherited) {
+      NS_ABORT_IF_FALSE(i < parentDisplay->mTransitionPropertyCount,
+                        "property.num computed incorrectly");
+      transition->CopyPropertyFrom(parentDisplay->mTransitions[i]);
+    } else if (property.list) {
+      switch (property.list->mValue.GetUnit()) {
+        case eCSSUnit_Ident:
+          {
+            nsDependentString
+              propertyStr(property.list->mValue.GetStringBufferValue());
+            nsCSSProperty prop = nsCSSProps::LookupProperty(propertyStr);
+            if (prop == eCSSProperty_UNKNOWN) {
+              transition->SetUnknownProperty(propertyStr);
+            } else {
+              transition->SetProperty(prop);
+            }
+          }
+          break;
+        case eCSSUnit_None:
+          transition->SetProperty(eCSSPropertyExtra_no_properties);
+          break;
+        case eCSSUnit_All:
+        case eCSSUnit_Initial:
+          transition->SetProperty(eCSSPropertyExtra_all_properties);
+          break;
+        default:
+          NS_NOTREACHED("Invalid transition property unit");
+      }
+    }
+
+    if (i >= timingFunction.num) {
+      transition->SetTimingFunction(
+        display->mTransitions[i % timingFunction.num].GetTimingFunction());
+    } else if (timingFunction.inherited) {
+      NS_ABORT_IF_FALSE(i < parentDisplay->mTransitionTimingFunctionCount,
+                        "timingFunction.num computed incorrectly");
+      transition->SetTimingFunction(
+        parentDisplay->mTransitions[i].GetTimingFunction());
+    } else if (timingFunction.list) {
+      switch (timingFunction.list->mValue.GetUnit()) {
+        case eCSSUnit_Enumerated:
+          transition->SetTimingFunction(nsTimingFunction(timingFunction.list->mValue.GetIntValue()));
+          break;
+        case eCSSUnit_Cubic_Bezier:
+          {
+            nsCSSValue::Array* array = timingFunction.list->mValue.GetArrayValue();
+            NS_ASSERTION(array && array->Count() == 4, "Need 4 control points");
+            transition->SetTimingFunction(nsTimingFunction(array->Item(0).GetFloatValue(),
+                                                           array->Item(1).GetFloatValue(),
+                                                           array->Item(2).GetFloatValue(),
+                                                           array->Item(3).GetFloatValue()));
+          }
+          break;
+        case eCSSUnit_Initial:
+          transition->SetTimingFunction(nsTimingFunction(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE));
+          break;
+        default:
+          NS_NOTREACHED("Invalid transition property unit");
+      }
+    }
+
+    FOR_ALL_TRANSITION_PROPS(p) {
+      const TransitionPropInfo& info = transitionPropInfo[p];
+      TransitionPropData& d = transitionPropData[p];
+
+      // if we're at the end of the list, start at the beginning and repeat
+      // until we're out of transitions to populate
+      if (d.list) { // could also check && !d.inherited if desired
+        d.list = d.list->mNext ? d.list->mNext : displayData.*(info.rdList);
+      }
+    }
+  }
+  
   // opacity: factor, inherit, initial
   SetFactor(displayData.mOpacity, display->mOpacity, canStoreInRuleTree,
             parentDisplay->mOpacity, 1.0f, SETFCT_OPACITY);
 
   // display: enum, none, inherit, initial
   SetDiscrete(displayData.mDisplay, display->mDisplay, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NONE, parentDisplay->mDisplay,
               NS_STYLE_DISPLAY_INLINE, 0,
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -18,16 +18,18 @@
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   David Hyatt (hyatt@netscape.com)
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   Michael Ventnor <m.ventnor@gmail.com>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -48,16 +50,17 @@
 #include "nsStyleConsts.h"
 #include "nsThemeConstants.h"
 #include "nsString.h"
 #include "nsPresContext.h"
 #include "nsIDeviceContext.h"
 #include "nsIWidget.h"
 #include "nsIStyleRule.h"
 #include "nsCRT.h"
+#include "nsCSSProps.h"
 
 #include "nsCOMPtr.h"
 #include "nsIPresShell.h"
 #include "nsIFrame.h"
 #include "nsHTMLReflowState.h"
 #include "prenv.h"
 
 #include "nsBidiUtils.h"
@@ -1542,16 +1545,64 @@ PRBool nsStyleBackground::Image::operato
     return *mGradient == *aOther.mGradient;
 
   return PR_TRUE;
 }
 
 // --------------------
 // nsStyleDisplay
 //
+void nsTimingFunction::AssignFromKeyword(PRInt32 aTimingFunctionType)
+{
+  PR_STATIC_ASSERT(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE == 0);
+  PR_STATIC_ASSERT(NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR == 1);
+  PR_STATIC_ASSERT(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN == 2);
+  PR_STATIC_ASSERT(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT == 3);
+  PR_STATIC_ASSERT(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT == 4);
+
+  static const float timingFunctionValues[5][4] = {
+    { 0.25, 0.10, 0.25, 1.00 }, // ease
+    { 0.00, 0.00, 1.00, 1.00 }, // linear
+    { 0.42, 0.00, 1.00, 1.00 }, // ease-in
+    { 0.00, 0.00, 0.58, 1.00 }, // ease-out
+    { 0.42, 0.00, 0.58, 1.00 }  // ease-in-out
+  };
+
+  NS_ABORT_IF_FALSE(0 <= aTimingFunctionType && aTimingFunctionType < 5,
+                    "keyword out of range");
+  mX1 = timingFunctionValues[aTimingFunctionType][0];
+  mY1 = timingFunctionValues[aTimingFunctionType][1];
+  mX2 = timingFunctionValues[aTimingFunctionType][2];
+  mY2 = timingFunctionValues[aTimingFunctionType][3];
+}
+
+nsTransition::nsTransition(const nsTransition& aCopy)
+  : mTimingFunction(aCopy.mTimingFunction)
+  , mDuration(aCopy.mDuration)
+  , mDelay(aCopy.mDelay)
+  , mProperty(aCopy.mProperty)
+{
+}
+
+void nsTransition::SetInitialValues()
+{
+  mTimingFunction = nsTimingFunction(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE);
+  mDuration = 0.0;
+  mDelay = 0.0;
+  mProperty = eCSSPropertyExtra_all_properties;
+}
+
+void nsTransition::SetUnknownProperty(const nsAString& aUnknownProperty)
+{
+  NS_ASSERTION(nsCSSProps::LookupProperty(aUnknownProperty) ==
+                 eCSSProperty_UNKNOWN,
+               "should be unknown property");
+  mProperty = eCSSProperty_UNKNOWN;
+  mUnknownProperty = do_GetAtom(aUnknownProperty);
+}
 
 nsStyleDisplay::nsStyleDisplay()
 {
   mAppearance = NS_THEME_NONE;
   mDisplay = NS_STYLE_DISPLAY_INLINE;
   mOriginalDisplay = NS_STYLE_DISPLAY_NONE;
   mPosition = NS_STYLE_POSITION_STATIC;
   mFloats = NS_STYLE_FLOAT_NONE;
@@ -1561,19 +1612,32 @@ nsStyleDisplay::nsStyleDisplay()
   mOverflowX = NS_STYLE_OVERFLOW_VISIBLE;
   mOverflowY = NS_STYLE_OVERFLOW_VISIBLE;
   mClipFlags = NS_STYLE_CLIP_AUTO;
   mClip.SetRect(0,0,0,0);
   mOpacity = 1.0f;
   mTransformPresent = PR_FALSE; // No transform
   mTransformOrigin[0].SetPercentValue(0.5f); // Transform is centered on origin
   mTransformOrigin[1].SetPercentValue(0.5f); 
+  mTransitions.AppendElement();
+  NS_ABORT_IF_FALSE(mTransitions.Length() == 1,
+                    "appending within auto buffer should never fail");
+  mTransitions[0].SetInitialValues();
+  mTransitionTimingFunctionCount = 1;
+  mTransitionDurationCount = 1;
+  mTransitionDelayCount = 1;
+  mTransitionPropertyCount = 1;
 }
 
 nsStyleDisplay::nsStyleDisplay(const nsStyleDisplay& aSource)
+  : mTransitions(aSource.mTransitions)
+  , mTransitionTimingFunctionCount(aSource.mTransitionTimingFunctionCount)
+  , mTransitionDurationCount(aSource.mTransitionDurationCount)
+  , mTransitionDelayCount(aSource.mTransitionDelayCount)
+  , mTransitionPropertyCount(aSource.mTransitionPropertyCount)
 {
   mAppearance = aSource.mAppearance;
   mDisplay = aSource.mDisplay;
   mOriginalDisplay = aSource.mOriginalDisplay;
   mBinding = aSource.mBinding;
   mPosition = aSource.mPosition;
   mFloats = aSource.mFloats;
   mBreakType = aSource.mBreakType;
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -18,16 +18,18 @@
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   Masayuki Nakano <masayuki@d-toybox.com>
  *   Rob Arnold <robarnold@mozilla.com>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -1049,16 +1051,89 @@ struct nsStyleVisibility {
   }
 
   PRBool IsVisibleOrCollapsed() const {
     return ((mVisible == NS_STYLE_VISIBILITY_VISIBLE) ||
             (mVisible == NS_STYLE_VISIBILITY_COLLAPSE));
   }
 };
 
+struct nsTimingFunction {
+  explicit nsTimingFunction(PRInt32 aTimingFunctionType
+                              = NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE)
+  {
+    AssignFromKeyword(aTimingFunctionType);
+  }
+
+  nsTimingFunction(float x1, float y1, float x2, float y2)
+    : mX1(x1)
+    , mY1(y1)
+    , mX2(x2)
+    , mY2(y2)
+  {}
+
+  float mX1;
+  float mY1;
+  float mX2;
+  float mY2;
+
+  PRBool operator==(const nsTimingFunction& aOther) const
+  {
+    return !(*this != aOther);
+  }
+
+  PRBool operator!=(const nsTimingFunction& aOther) const
+  {
+    return mX1 != mX1 || mY1 != mY1 || mX2 != mX2 || mY2 != mY2;
+  }
+
+private:
+  void AssignFromKeyword(PRInt32 aTimingFunctionType);
+};
+
+struct nsTransition {
+  nsTransition() { /* leaves uninitialized; see also SetInitialValues */ }
+  explicit nsTransition(const nsTransition& aCopy);
+
+  void SetInitialValues();
+
+  // Delay and Duration are in milliseconds
+
+  nsTimingFunction& GetTimingFunction() { return mTimingFunction; }
+  const nsTimingFunction& GetTimingFunction() const { return mTimingFunction; }
+  float GetDelay() const { return mDelay; }
+  float GetDuration() const { return mDuration; }
+  nsCSSProperty GetProperty() const { return mProperty; }
+  nsIAtom* GetUnknownProperty() const { return mUnknownProperty; }
+
+  void SetTimingFunction(const nsTimingFunction& aTimingFunction)
+    { mTimingFunction = aTimingFunction; }
+  void SetDelay(float aDelay) { mDelay = aDelay; }
+  void SetDuration(float aDuration) { mDuration = aDuration; }
+  void SetProperty(nsCSSProperty aProperty)
+    {
+      NS_ASSERTION(aProperty != eCSSProperty_UNKNOWN, "invalid property");
+      mProperty = aProperty;
+    }
+  void SetUnknownProperty(const nsAString& aUnknownProperty);
+  void CopyPropertyFrom(const nsTransition& aOther)
+    {
+      mProperty = aOther.mProperty;
+      mUnknownProperty = aOther.mUnknownProperty;
+    }
+
+private:
+  nsTimingFunction mTimingFunction;
+  float mDuration;
+  float mDelay;
+  nsCSSProperty mProperty;
+  nsCOMPtr<nsIAtom> mUnknownProperty; // used when mProperty is
+                                      // eCSSProperty_UNKNOWN
+};
+
 struct nsStyleDisplay {
   nsStyleDisplay();
   nsStyleDisplay(const nsStyleDisplay& aOther); 
   ~nsStyleDisplay() {}
 
   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
     return aContext->AllocateFromShell(sz);
   }
@@ -1093,16 +1168,23 @@ struct nsStyleDisplay {
   PRPackedBool mBreakBefore;    // [reset] 
   PRPackedBool mBreakAfter;     // [reset] 
   PRUint8 mOverflowX;           // [reset] see nsStyleConsts.h
   PRUint8 mOverflowY;           // [reset] see nsStyleConsts.h
   PRUint8   mClipFlags;         // [reset] see nsStyleConsts.h
   PRPackedBool mTransformPresent;  // [reset] Whether there is a -moz-transform.
   nsStyleTransformMatrix mTransform; // [reset] The stored transform matrix
   nsStyleCoord mTransformOrigin[2]; // [reset] percent, coord.
+  nsAutoTArray<nsTransition, 1> mTransitions; // [reset]
+  // The number of elements in mTransitions that are not from repeating
+  // a list due to another property being longer.
+  PRUint32 mTransitionTimingFunctionCount,
+           mTransitionDurationCount,
+           mTransitionDelayCount,
+           mTransitionPropertyCount;
 
   PRBool IsBlockInside() const {
     return NS_STYLE_DISPLAY_BLOCK == mDisplay ||
            NS_STYLE_DISPLAY_LIST_ITEM == mDisplay ||
            NS_STYLE_DISPLAY_INLINE_BLOCK == mDisplay;
     // Should TABLE_CELL and TABLE_CAPTION go here?  They have
     // block frames nested inside of them.
     // (But please audit all callers before changing.)
diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -127,16 +127,17 @@ _TEST_FILES =	test_acid3_test46.html \
 		test_priority_preservation.html \
 		test_property_syntax_errors.html \
 		test_rem_unit.html \
 		test_selectors.html \
 		test_selectors_on_anonymous_content.html \
 		test_shorthand_property_getters.html \
 		test_style_struct_copy_constructors.html \
 		test_system_font_serialization.html \
+		test_transitions_computed_values.html \
 		test_units_angle.html \
 		test_units_frequency.html \
 		test_units_length.html \
 		test_units_time.html \
 		test_value_computation.html \
 		test_value_storage.html \
 		test_visited_pref.html \
 		css_properties.js \
diff --git a/layout/style/test/property_database.js b/layout/style/test/property_database.js
--- a/layout/style/test/property_database.js
+++ b/layout/style/test/property_database.js
@@ -1728,16 +1728,57 @@ var gCSSProperties = {
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		/* XXX requires position to be set */
 		/* XXX 0 may or may not be equal to auto */
 		initial_values: [ "auto" ],
 		other_values: [ "32px", "-3em", "12%" ],
 		invalid_values: []
 	},
+	"-moz-transition": {
+		domProp: "MozTransition",
+		inherited: false,
+		type: CSS_TYPE_TRUE_SHORTHAND,
+		subproperties: [ "-moz-transition-property", "-moz-transition-duration", "-moz-transition-timing-function", "-moz-transition-delay" ],
+		initial_values: [ "all 0s ease 0s" ],
+		other_values: [ "width 1s linear 2s", "width 1s 2s linear", "width linear 1s 2s", "linear width 1s 2s", "linear 1s width 2s", "linear 1s 2s width", "1s width linear 2s", "1s width 2s linear", "1s 2s width linear", "1s linear width 2s", "1s linear 2s width", "1s 2s linear width", "width linear 1s", "width 1s linear", "linear width 1s", "linear 1s width", "1s width linear", "1s linear width", "1s 2s width", "1s width 2s", "width 1s 2s", "1s 2s linear", "1s linear 2s", "linear 1s 2s", "width 1s", "1s width", "linear 1s", "1s linear", "1s 2s", "2s 1s", "width", "linear", "1s", "height", "2s", "ease-in-out", "2s ease-in", "opacity linear", "ease-out 2s", "2s color, 1s width, 500ms height linear, 1s opacity 4s cubic-bezier(0.0, 0.1, 1.0, 1.0)" ],
+		invalid_values: [ "2s, 1s width", "1s width, 2s", "2s all, 1s width", "1s width, 2s all", "1s width, 2s none", "2s none, 1s width", "2s inherit", "inherit 2s", "2s width, 1s inherit", "2s inherit, 1s width", "2s initial", "2s all, 1s width", "2s width, 1s all" ]
+	},
+	"-moz-transition-delay": {
+		domProp: "MozTransitionDelay",
+		inherited: false,
+		type: CSS_TYPE_LONGHAND,
+		initial_values: [ "0", "0s", "0ms" ],
+		other_values: [ "1s", "250ms", "-100ms", "-1s", "1s, 250ms, 2.3s"],
+		invalid_values: []
+	},
+	"-moz-transition-duration": {
+		domProp: "MozTransitionDuration",
+		inherited: false,
+		type: CSS_TYPE_LONGHAND,
+		initial_values: [ "0", "0s", "0ms" ],
+		other_values: [ "1s", "250ms", "-1ms", "-2s", "1s, 250ms, 2.3s"],
+		invalid_values: []
+	},
+	"-moz-transition-property": {
+		domProp: "MozTransitionProperty",
+		inherited: false,
+		type: CSS_TYPE_LONGHAND,
+		initial_values: [ "all" ],
+		other_values: [ "none", "left", "top", "color", "width, height, opacity", "foobar", "auto" ],
+		invalid_values: [ "none, none", "all, all", "color, none", "none, color", "all, color", "color, all", "inherit, color", "color, inherit", "initial, color", "color, initial", "none, color", "color, none", "all, color", "color, all" ]
+	},
+	"-moz-transition-timing-function": {
+		domProp: "MozTransitionTimingFunction",
+		inherited: false,
+		type: CSS_TYPE_LONGHAND,
+		initial_values: [ "ease", "cubic-bezier(0.25, 0.1, 0.25, 1.0)" ],
+		other_values: [ "linear", "ease-in", "ease-out", "ease-in-out", "linear, ease-in, cubic-bezier(0.1, 0.2, 0.8, 0.9)" ],
+		invalid_values: [ "none", "auto" ]
+	},
 	"unicode-bidi": {
 		domProp: "unicodeBidi",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "normal" ],
 		other_values: [ "embed", "bidi-override" ],
 		invalid_values: [ "auto", "none" ]
 	},
diff --git a/layout/style/test/test_garbage_at_end_of_declarations.html b/layout/style/test/test_garbage_at_end_of_declarations.html
--- a/layout/style/test/test_garbage_at_end_of_declarations.html
+++ b/layout/style/test/test_garbage_at_end_of_declarations.html
@@ -48,26 +48,41 @@ var gAllowsExtra = {
   "counter-increment": { "none": true },
   "counter-reset": { "none": true },
   "font-family": {},
   "font": { "caption": true, "icon": true, "menu": true, "message-box": true,
             "small-caption": true, "status-bar": true },
   "voice-family": {},
 };
 
+/* These are the reverse of the above list; they're the unusual values
+   that do allow extra keywords afterwards */
+var gAllowsExtraUnusual = {
+  "-moz-transition": { "1s 2s linear": true, "1s linear 2s": true,
+                       "linear 1s 2s": true, "linear 1s": true,
+                       "1s linear": true, "1s 2s": true, "2s 1s": true,
+                       "linear": true, "1s": true, "2s": true,
+                       "ease-in-out": true, "2s ease-in": true,
+                       "ease-out 2s": true },
+};
+
 function test_property(property)
 {
   var info = gCSSProperties[property];
 
   function test_value(value) {
     if (property in gAllowsExtra &&
         value != "inherit" && value != "-moz-initial" &&
         !(value in gAllowsExtra[property])) {
       return;
     }
+    if (property in gAllowsExtraUnusual &&
+        value in gAllowsExtraUnusual[property]) {
+      return;
+    }
 
     gElement.setAttribute("style", property + ": " + value + " blah");
     if ("subproperties" in info) {
       for (idx in info.subproperties) {
         var subprop = info.subproperties[idx];
         is(gDeclaration.getPropertyValue(subprop), "",
            ["expected garbage ignored after '", property, ": ", value,
             "' when looking at subproperty '", subprop, "'"].join(""));
diff --git a/layout/style/test/test_shorthand_property_getters.html b/layout/style/test/test_shorthand_property_getters.html
--- a/layout/style/test/test_shorthand_property_getters.html
+++ b/layout/style/test/test_shorthand_property_getters.html
@@ -122,12 +122,49 @@ is(e.style.background, "", "should not h
 // -moz-background-clip:content not yet supported
 //e.setAttribute("style", "background: red; -moz-background-clip: content");
 //is(e.style.background, "", "should not have background shorthand (clip:content)");
 //e.setAttribute("style", "background: red; -moz-background-clip: content; -moz-background-origin: content;");
 //isnot(e.style.background, "", "should have background shorthand (clip:content;origin:content)");
 e.setAttribute("style", "background: red; -moz-background-inline-policy: each-box");
 isnot(e.style.background, "", "should have background shorthand (-moz-background-inline-policy not relevant)");
 
+// Check that we only serialize background when the lists (of layers) for
+// the subproperties are the same length.
+// XXX Should change background-clip to border,padding,border and
+// background-origin to border,padding,padding once serialization does
+// clip/origin.
+e.setAttribute("style", "-moz-background-clip: border, border, border; -moz-background-origin: padding, padding, padding; -moz-background-size: cover, auto, contain; background-color: blue; background-image: url(404.png), none, url(404-2.png); background-attachment: fixed, scroll, scroll; background-position: top left, center, 30px 50px; background-repeat: repeat-x, repeat, no-repeat");
+isnot(e.style.background, "", "should have background shorthand (all lists length 3)");
+e.setAttribute("style", "-moz-background-clip: border, border, border, border; -moz-background-origin: padding, padding, padding; -moz-background-size: cover, auto, contain; background-color: blue; background-image: url(404.png), none, url(404-2.png); background-attachment: fixed, scroll, scroll; background-position: top left, center, 30px 50px; background-repeat: repeat-x, repeat, no-repeat");
+is(e.style.background, "", "should not have background shorthand (background-clip too long)");
+e.setAttribute("style", "-moz-background-clip: border, border, border; -moz-background-origin: border, padding; -moz-background-size: cover, auto, contain; background-color: blue; background-image: url(404.png), none, url(404-2.png); background-attachment: fixed, scroll, scroll; background-position: top left, center, 30px 50px; background-repeat: repeat-x, repeat, no-repeat");
+is(e.style.background, "", "should not have background shorthand (background-origin too short)");
+e.setAttribute("style", "-moz-background-clip: border, border, border; -moz-background-origin: padding, padding, padding; -moz-background-size: cover, auto, contain; background-color: blue; background-image: url(404.png), none, url(404-2.png), none; background-attachment: fixed, scroll, scroll; background-position: top left, center, 30px 50px; background-repeat: repeat-x, repeat, no-repeat");
+is(e.style.background, "", "should not have background shorthand (background-image too long)");
+e.setAttribute("style", "-moz-background-clip: border, border, border; -moz-background-origin: padding, padding, padding; -moz-background-size: cover, auto, contain; background-color: blue; background-image: url(404.png), none, url(404-2.png); background-attachment: fixed, scroll; background-position: top left, center, 30px 50px; background-repeat: repeat-x, repeat, no-repeat");
+is(e.style.background, "", "should not have background shorthand (background-attachment too short)");
+e.setAttribute("style", "-moz-background-clip: border, border, border; -moz-background-origin: padding, padding, padding; -moz-background-size: cover, auto, contain; background-color: blue; background-image: url(404.png), none, url(404-2.png); background-attachment: fixed, scroll, scroll; background-position: top left, center, 30px 50px, bottom; background-repeat: repeat-x, repeat, no-repeat");
+is(e.style.background, "", "should not have background shorthand (background-position too long)");
+e.setAttribute("style", "-moz-background-clip: border, border, border; -moz-background-origin: padding, padding, padding; -moz-background-size: cover, auto, contain; background-color: blue; background-image: url(404.png), none, url(404-2.png); background-attachment: fixed, scroll, scroll; background-position: top left, center, 30px 50px; background-repeat: repeat-x, repeat");
+is(e.style.background, "", "should not have background shorthand (background-repeat too short)");
+e.setAttribute("style", "-moz-background-clip: border, border, border; -moz-background-origin: padding, padding, padding; -moz-background-size: cover, auto, contain, cover; background-color: blue; background-image: url(404.png), none, url(404-2.png); background-attachment: fixed, scroll, scroll; background-position: top left, center, 30px 50px; background-repeat: repeat-x, repeat, no-repeat");
+is(e.style.background, "", "should not have background shorthand (-moz-background-size too long)");
+
+// Check that we only serialize transition when the lists are the same length.
+e.setAttribute("style", "-moz-transition-property: color, width; -moz-transition-duration: 1s, 200ms; -moz-transition-timing-function: ease-in, linear; -moz-transition-delay: 0, 1s");
+isnot(e.style.MozTransition, "", "should have -moz-transition shorthand (lists same length)");
+e.setAttribute("style", "-moz-transition-property: color, width, left; -moz-transition-duration: 1s, 200ms; -moz-transition-timing-function: ease-in, linear; -moz-transition-delay: 0, 1s");
+is(e.style.MozTransition, "", "should not have -moz-transition shorthand (lists different lengths)");
+e.setAttribute("style", "-moz-transition-property: all; -moz-transition-duration: 1s, 200ms; -moz-transition-timing-function: ease-in, linear; -moz-transition-delay: 0, 1s");
+is(e.style.MozTransition, "", "should not have -moz-transition shorthand (lists different lengths)");
+e.setAttribute("style", "-moz-transition-property: color, width; -moz-transition-duration: 1s, 200ms, 300ms; -moz-transition-timing-function: ease-in, linear; -moz-transition-delay: 0, 1s");
+is(e.style.MozTransition, "", "should not have -moz-transition shorthand (lists different lengths)");
+e.setAttribute("style", "-moz-transition-property: color, width; -moz-transition-duration: 1s, 200ms; -moz-transition-timing-function: ease-in, linear, ease-out; -moz-transition-delay: 0, 1s");
+is(e.style.MozTransition, "", "should not have -moz-transition shorthand (lists different lengths)");
+e.setAttribute("style", "-moz-transition-property: color, width; -moz-transition-duration: 1s, 200ms; -moz-transition-timing-function: ease-in, linear; -moz-transition-delay: 0, 1s, 0");
+is(e.style.MozTransition, "", "should not have -moz-transition shorthand (lists different lengths)");
+
+
 </script>
 </pre>
 </body>
 </html>
diff --git a/layout/style/test/test_transitions_computed_values.html b/layout/style/test/test_transitions_computed_values.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_transitions_computed_values.html
@@ -0,0 +1,75 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=435441
+-->
+<head>
+  <title>Test for Bug 435441</title>
+  <script type="application/javascript" src="/MochiKit/packed.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=435441">Mozilla Bug 435441</a>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 435441 **/
+
+
+/*
+ * test that when transition properties are inherited, the length of the
+ * computed value stays the same
+ */
+
+var p = document.getElementById("content");
+var c = document.createElement("div");
+p.appendChild(c);
+var cs = getComputedStyle(c, "");
+
+p.style.MozTransitionProperty = "margin-left, margin-right";
+c.style.MozTransitionProperty = "inherit";
+is(cs.MozTransitionProperty, "margin-left, margin-right",
+   "computed style match with no other properties");
+c.style.MozTransitionDuration = "5s";
+is(cs.MozTransitionProperty, "margin-left, margin-right",
+   "computed style match with shorter property");
+is(cs.MozTransitionDuration, "5s",
+   "shorter property not extended");
+c.style.MozTransitionDuration = "5s, 4s, 3s, 2000ms";
+is(cs.MozTransitionProperty, "margin-left, margin-right",
+   "computed style match with longer property");
+is(cs.MozTransitionDuration, "5s, 4s, 3s, 2s",
+   "longer property computed correctly");
+p.style.MozTransitionProperty = "";
+c.style.MozTransitionProperty = "";
+c.style.MozTransitionDuration = "";
+
+// and repeat the above set of tests with property and duration swapped
+p.style.MozTransitionDuration = "5s, 4s";
+c.style.MozTransitionDuration = "inherit";
+is(cs.MozTransitionDuration, "5s, 4s",
+   "computed style match with no other properties");
+c.style.MozTransitionProperty = "margin-left";
+is(cs.MozTransitionDuration, "5s, 4s",
+   "computed style match with shorter property");
+is(cs.MozTransitionProperty, "margin-left",
+   "shorter property not extended");
+c.style.MozTransitionProperty =
+  "margin-left, margin-right, margin-top, margin-bottom";
+is(cs.MozTransitionDuration, "5s, 4s",
+   "computed style match with longer property");
+is(cs.MozTransitionProperty,
+   "margin-left, margin-right, margin-top, margin-bottom",
+   "longer property computed correctly");
+p.style.MozTransitionDuration = "";
+c.style.MozTransitionDuration = "";
+c.style.MozTransitionProperty = "";
+
+</script>
+</pre>
+</body>
+</html>
