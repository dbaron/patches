From: Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, L. David Baron <dbaron@dbaron.org>

Implement CSS transitions: implement the parsing and computation of the transition properties.  (Bug 435441)

diff --git a/dom/interfaces/css/nsIDOMNSCSS2Properties.idl b/dom/interfaces/css/nsIDOMNSCSS2Properties.idl
--- a/dom/interfaces/css/nsIDOMNSCSS2Properties.idl
+++ b/dom/interfaces/css/nsIDOMNSCSS2Properties.idl
@@ -17,16 +17,17 @@
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 2000
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Vidur Apparao <vidur@netscape.com> (original author)
  *   Johnny Stenback <jst@netscape.com>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -34,17 +35,17 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsIDOMCSS2Properties.idl"
 
-[scriptable, uuid(e7245a21-3f46-4e67-82bf-a9b326fe74ee)]
+[scriptable, uuid(73902da2-9475-4e96-b0ed-85003721cf37)]
 interface nsIDOMNSCSS2Properties : nsIDOMCSS2Properties
 {
            /* Non-DOM 2 extensions */
 
            /* Mozilla extension CSS properties */
            attribute DOMString        MozAppearance;
                                         // raises(DOMException) on setting
 
@@ -251,10 +252,25 @@ interface nsIDOMNSCSS2Properties : nsIDO
            attribute DOMString        MozTransform;
                                         // raises(DOMException) on setting
 
            attribute DOMString        MozTransformOrigin;
                                         // raises(DOMException) on setting 
 
            attribute DOMString        MozWindowShadow;
                                         // raises(DOMException) on setting
-	
+
+           attribute DOMString        MozTransitionProperty;
+                                        // raises(DOMException) on setting
+
+           attribute DOMString        MozTransitionDuration;
+                                        // raises(DOMException) on setting
+
+           attribute DOMString        MozTransitionDelay;
+                                        // raises(DOMException) on setting
+
+           attribute DOMString        MozTransitionTimingFunction;
+                                        // raises(DOMException) on setting
+
+           attribute DOMString        MozTransition;
+                                        // raises(DOMException) on setting
+
 };
diff --git a/layout/base/nsStyleConsts.h b/layout/base/nsStyleConsts.h
--- a/layout/base/nsStyleConsts.h
+++ b/layout/base/nsStyleConsts.h
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -608,16 +609,23 @@
 #define NS_STYLE_TEXT_DECORATION_LINES_MASK     (NS_STYLE_TEXT_DECORATION_UNDERLINE | NS_STYLE_TEXT_DECORATION_OVERLINE | NS_STYLE_TEXT_DECORATION_LINE_THROUGH)
 
 // See nsStyleText
 #define NS_STYLE_TEXT_TRANSFORM_NONE            0
 #define NS_STYLE_TEXT_TRANSFORM_CAPITALIZE      1
 #define NS_STYLE_TEXT_TRANSFORM_LOWERCASE       2
 #define NS_STYLE_TEXT_TRANSFORM_UPPERCASE       3
 
+// See nsStyleDisplay
+#define NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE         0
+#define NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR       1
+#define NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN      2
+#define NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT     3
+#define NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT  4
+
 // See nsStyleText
 // Note: these values pickup after the text-align values because there
 // are a few html cases where an object can have both types of
 // alignment applied with a single attribute
 #define NS_STYLE_VERTICAL_ALIGN_BASELINE             11
 #define NS_STYLE_VERTICAL_ALIGN_SUB                  12
 #define NS_STYLE_VERTICAL_ALIGN_SUPER                13
 #define NS_STYLE_VERTICAL_ALIGN_TOP                  14
diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -17,16 +17,17 @@
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Daniel Glazman <glazman@netscape.com>
  *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -242,48 +243,53 @@ nsCSSDeclaration::AppendCSSValueToString
     nsAutoString  buffer;
     aValue.GetStringValue(buffer);
     if (unit == eCSSUnit_String) {
       nsStyleUtil::AppendEscapedCSSString(buffer, aResult);
     } else {
       aResult.Append(buffer);
     }
   }
-  else if (eCSSUnit_Array <= unit && unit <= eCSSUnit_Counters) {
+  else if (eCSSUnit_Array <= unit && unit <= eCSSUnit_Cubic_Bezier) {
     switch (unit) {
       case eCSSUnit_Counter:  aResult.AppendLiteral("counter(");  break;
       case eCSSUnit_Counters: aResult.AppendLiteral("counters("); break;
+      case eCSSUnit_Cubic_Bezier: aResult.AppendLiteral("cubic-bezier("); break;
       default: break;
     }
 
     nsCSSValue::Array *array = aValue.GetArrayValue();
     PRBool mark = PR_FALSE;
     for (PRUint16 i = 0, i_end = array->Count(); i < i_end; ++i) {
       if (aProperty == eCSSProperty_border_image && i >= 5) {
         if (array->Item(i).GetUnit() == eCSSUnit_Null) {
           continue;
         }
         if (i == 5) {
           aResult.AppendLiteral(" /");
         }
       }
       if (mark && array->Item(i).GetUnit() != eCSSUnit_Null) {
-        if (unit == eCSSUnit_Array)
+        if (unit == eCSSUnit_Array &&
+            eCSSProperty_transition_timing_function != aProperty)
           aResult.AppendLiteral(" ");
         else
           aResult.AppendLiteral(", ");
       }
       nsCSSProperty prop =
         ((eCSSUnit_Counter <= unit && unit <= eCSSUnit_Counters) &&
          i == array->Count() - 1)
         ? eCSSProperty_list_style_type : aProperty;
       if (AppendCSSValueToString(prop, array->Item(i), aResult)) {
         mark = PR_TRUE;
       }
     }
+    if (eCSSUnit_Array == unit && aProperty == eCSSProperty_transition_timing_function) {
+      aResult.AppendLiteral(")");
+    }
   }
   /* Although Function is backed by an Array, we'll handle it separately
    * because it's a bit quirky.
    */
   else if (eCSSUnit_Function == unit) {
     const nsCSSValue::Array* array = aValue.GetArrayValue();
     NS_ASSERTION(array->Count() >= 1, "Functions must have at least one element for the name.");
 
@@ -341,16 +347,19 @@ nsCSSDeclaration::AppendCSSValueToString
       }
       if ((NS_STYLE_PAGE_MARKS_REGISTER & intValue) != 0) {
         if ((NS_STYLE_PAGE_MARKS_CROP & intValue) != 0) {
           aResult.Append(PRUnichar(' '));
         }
         AppendASCIItoUTF16(nsCSSProps::LookupPropertyValue(aProperty, NS_STYLE_PAGE_MARKS_REGISTER), aResult);
       }
     }
+    else if (eCSSProperty_transition_property == aProperty) {
+      AppendASCIItoUTF16(nsCSSProps::GetStringValue((nsCSSProperty) aValue.GetIntValue()), aResult);
+    }
     else {
       const nsAFlatCString& name = nsCSSProps::LookupPropertyValue(aProperty, aValue.GetIntValue());
       AppendASCIItoUTF16(name, aResult);
     }
   }
   else if (eCSSUnit_EnumColor == unit) {
     // we can lookup the property in the ColorTable and then
     // get a string mapping the name
@@ -412,29 +421,31 @@ nsCSSDeclaration::AppendCSSValueToString
   switch (unit) {
     case eCSSUnit_Null:         break;
     case eCSSUnit_Auto:         aResult.AppendLiteral("auto");     break;
     case eCSSUnit_Inherit:      aResult.AppendLiteral("inherit");  break;
     case eCSSUnit_Initial:      aResult.AppendLiteral("-moz-initial"); break;
     case eCSSUnit_None:         aResult.AppendLiteral("none");     break;
     case eCSSUnit_Normal:       aResult.AppendLiteral("normal");   break;
     case eCSSUnit_System_Font:  aResult.AppendLiteral("-moz-use-system-font"); break;
+    case eCSSUnit_All:          aResult.AppendLiteral("all"); break;
     case eCSSUnit_Dummy:
     case eCSSUnit_DummyInherit:
     case eCSSUnit_RectIsAuto:
       NS_NOTREACHED("should never serialize");
       break;
 
     case eCSSUnit_String:       break;
     case eCSSUnit_Ident:        break;
     case eCSSUnit_Families:     break;
     case eCSSUnit_URL:          break;
     case eCSSUnit_Image:        break;
     case eCSSUnit_Array:        break;
     case eCSSUnit_Attr:
+    case eCSSUnit_Cubic_Bezier:
     case eCSSUnit_Counter:
     case eCSSUnit_Counters:     aResult.Append(PRUnichar(')'));    break;
     case eCSSUnit_Local_Font:   break;
     case eCSSUnit_Font_Format:  break;
     case eCSSUnit_Function:     break;
     case eCSSUnit_Integer:      break;
     case eCSSUnit_Enumerated:   break;
     case eCSSUnit_EnumColor:    break;
@@ -942,16 +953,64 @@ nsCSSDeclaration::GetValue(nsCSSProperty
     case eCSSProperty_pause: {
       if (AppendValueToString(eCSSProperty_pause_before, aValue)) {
         aValue.Append(PRUnichar(' '));
         if (!AppendValueToString(eCSSProperty_pause_after, aValue))
           aValue.Truncate();
       }
       break;
     }
+    case eCSSProperty_transition: {
+      // FIXME: Must only serialize when sublists are the same length
+      // (and need to add a test to test_shorthand_property_getters).
+      const nsCSSProperty* subprops =
+        nsCSSProps::SubpropertyEntryFor(aProperty);
+      NS_ASSERTION(nsCSSProps::kTypeTable[subprops[0]] == eCSSType_ValueList &&
+                   nsCSSProps::kTypeTable[subprops[1]] == eCSSType_ValueList &&
+                   nsCSSProps::kTypeTable[subprops[2]] == eCSSType_ValueList &&
+                   nsCSSProps::kTypeTable[subprops[3]] == eCSSType_ValueList,
+                   "type mismatch");
+      // this is ugly but I don't think there's much choice:  we need to print
+      // subprops[0][0] subprops[0][1] subprops[0][2] subprops[0][3],
+      // subprops[1][0] subprops[1][1] ... etc.
+      nsCSSCompressedDataBlock *data = GetValueIsImportant(aProperty)
+        ? mImportantData : mData;
+      const nsCSSValueList* val[4];
+      for (int i = 0; i < 4; ++i) {
+        const void *storage = data->StorageFor(subprops[i]);
+        val[i] = *static_cast<nsCSSValueList*const*>(storage);
+      }
+      PRBool firstTime = PR_TRUE;
+      while (val[0] || val[1] || val[2] || val[3]) {
+        if (!firstTime) {
+          // we've already added one transition, and we're still in the loop, so
+          // add a delimiter between them
+          aValue.AppendLiteral(", ");
+        }
+        else
+          firstTime = PR_FALSE;
+
+        PRBool subpropAppended = PR_FALSE;
+        for (int j = 0; j < 4; ++j) {
+          if (val[j]) {
+            if (subpropAppended) {
+              aValue.Append(PRUnichar(' '));
+              subpropAppended = PR_FALSE;
+            }
+            if (val[j]->mValue.GetUnit() != eCSSUnit_Initial)
+              if (AppendCSSValueToString(subprops[j], val[j]->mValue, aValue)) {
+                subpropAppended = PR_TRUE;
+              }
+            val[j] = val[j]->mNext;
+          }
+        }
+      }
+      break;
+    }
+
 #ifdef MOZ_SVG
     case eCSSProperty_marker: {
       const nsCSSValue &endValue =
         *data->ValueStorageFor(eCSSProperty_marker_end);
       const nsCSSValue &midValue =
         *data->ValueStorageFor(eCSSProperty_marker_mid);
       const nsCSSValue &startValue =
         *data->ValueStorageFor(eCSSProperty_marker_start);
diff --git a/layout/style/nsCSSKeywordList.h b/layout/style/nsCSSKeywordList.h
--- a/layout/style/nsCSSKeywordList.h
+++ b/layout/style/nsCSSKeywordList.h
@@ -257,16 +257,20 @@ CSS_KEY(deg, deg)
 CSS_KEY(dialog, dialog)
 CSS_KEY(digits, digits)
 CSS_KEY(disabled, disabled)
 CSS_KEY(disc, disc)
 CSS_KEY(dotted, dotted)
 CSS_KEY(double, double)
 CSS_KEY(e-resize, e_resize)
 CSS_KEY(each-box, each_box)
+CSS_KEY(ease, ease)
+CSS_KEY(ease-in, ease_in)
+CSS_KEY(ease-in-out, ease_in_out)
+CSS_KEY(ease-out, ease_out)
 CSS_KEY(element, element)
 CSS_KEY(elements, elements)
 CSS_KEY(em, em)
 CSS_KEY(embed, embed)
 CSS_KEY(enabled, enabled)
 CSS_KEY(end, end)
 CSS_KEY(ex, ex)
 CSS_KEY(expanded, expanded)
@@ -323,16 +327,17 @@ CSS_KEY(landscape, landscape)
 CSS_KEY(large, large)
 CSS_KEY(larger, larger)
 CSS_KEY(left, left)
 CSS_KEY(left-side, left_side)
 CSS_KEY(leftwards, leftwards)
 CSS_KEY(level, level)
 CSS_KEY(lighter, lighter)
 CSS_KEY(line-through, line_through)
+CSS_KEY(linear, linear)
 CSS_KEY(list-item, list_item)
 CSS_KEY(logical, logical)
 CSS_KEY(loud, loud)
 CSS_KEY(low, low)
 CSS_KEY(lower, lower)
 CSS_KEY(lower-alpha, lower_alpha)
 CSS_KEY(lower-greek, lower_greek)
 CSS_KEY(lower-latin, lower_latin)
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -21,16 +21,18 @@
  *
  * Contributor(s):
  *   emk <VYV03354@nifty.ne.jp>
  *   Daniel Glazman <glazman@netscape.com>
  *   L. David Baron <dbaron@dbaron.org>
  *   Boris Zbarsky <bzbarsky@mit.edu>
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   Christian Biesinger <cbiesinger@web.de>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
+ *   Siraj Razick <siraj.razick@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -101,16 +103,18 @@
 #define VARIANT_COUNTER         0x000800  //
 #define VARIANT_ATTR            0x001000  //
 #define VARIANT_IDENTIFIER      0x002000  // D
 #define VARIANT_AUTO            0x010000  // A
 #define VARIANT_INHERIT         0x020000  // H eCSSUnit_Initial, eCSSUnit_Inherit
 #define VARIANT_NONE            0x040000  // O
 #define VARIANT_NORMAL          0x080000  // M
 #define VARIANT_SYSFONT         0x100000  // eCSSUnit_System_Font
+#define VARIANT_CUBIC_BEZIER    0x200000  // CSS transition timing function
+#define VARIANT_TRANSITION_PROPERTY   0x400000  // CSS transition property name
 
 // Common combinations of variants
 #define VARIANT_AL   (VARIANT_AUTO | VARIANT_LENGTH)
 #define VARIANT_LP   (VARIANT_LENGTH | VARIANT_PERCENT)
 #define VARIANT_AH   (VARIANT_AUTO | VARIANT_INHERIT)
 #define VARIANT_AHLP (VARIANT_AH | VARIANT_LP)
 #define VARIANT_AHI  (VARIANT_AH | VARIANT_INTEGER)
 #define VARIANT_AHK  (VARIANT_AH | VARIANT_KEYWORD)
@@ -136,16 +140,17 @@
 #define VARIANT_HCK  (VARIANT_HK | VARIANT_COLOR)
 #define VARIANT_HUO  (VARIANT_INHERIT | VARIANT_URL | VARIANT_NONE)
 #define VARIANT_AHUO (VARIANT_AUTO | VARIANT_HUO)
 #define VARIANT_HPN  (VARIANT_INHERIT | VARIANT_PERCENT | VARIANT_NUMBER)
 #define VARIANT_HOK  (VARIANT_HK | VARIANT_NONE)
 #define VARIANT_HN   (VARIANT_INHERIT | VARIANT_NUMBER)
 #define VARIANT_HON  (VARIANT_HN | VARIANT_NONE)
 #define VARIANT_HOS  (VARIANT_INHERIT | VARIANT_NONE | VARIANT_STRING)
+#define VARIANT_TIMING_FUNCTION (VARIANT_KEYWORD | VARIANT_CUBIC_BEZIER)
 
 //----------------------------------------------------------------------
 
 // Your basic top-down recursive descent style parser
 class CSSParserImpl : public nsICSSParser {
 public:
   CSSParserImpl();
   virtual ~CSSParserImpl();
@@ -460,16 +465,23 @@ protected:
   PRBool ParsePause();
   PRBool ParseQuotes();
   PRBool ParseSize();
   PRBool ParseTextDecoration(nsCSSValue& aValue);
 
   nsCSSValueList* ParseCSSShadowList(PRBool aIsBoxShadow);
   PRBool ParseTextShadow();
   PRBool ParseBoxShadow();
+  PRBool ParseTransitionTime(nsCSSProperty aPropID);
+  PRBool ParseTransitionProperty();
+  PRBool ParseTransition();
+  PRBool ParseTransitionTimingFunction();
+  PRBool ParseTransitionTimingFunctionValues(nsCSSValue& aValue);
+  PRBool ParseTransitionTimingFunctionValueComponent(float& aComponent, char aStop);
+  PRBool AppendValueToList(nsCSSValueList*& list, nsCSSValue& value);
 
 #ifdef MOZ_SVG
   PRBool ParsePaint(nsCSSValuePair* aResult,
                     nsCSSProperty aPropID);
   PRBool ParseDasharray();
   PRBool ParseMarker();
 #endif
 
@@ -4531,16 +4543,39 @@ CSSParserImpl::ParseVariant(nsCSSValue& 
        tk->mIdent.LowerCaseEqualsLiteral("counters"))) {
     return ParseCounter(aValue);
   }
   if (((aVariantMask & VARIANT_ATTR) != 0) &&
       (eCSSToken_Function == tk->mType) &&
       tk->mIdent.LowerCaseEqualsLiteral("attr")) {
     return ParseAttr(aValue);
   }
+  if (((aVariantMask & VARIANT_TRANSITION_PROPERTY) != 0) && 
+      (eCSSToken_Ident == tk->mType)) {
+    if (tk->mIdent.LowerCaseEqualsLiteral("none")) {
+      aValue.SetNoneValue();
+      return PR_TRUE;
+    } else if (tk->mIdent.LowerCaseEqualsLiteral("all")) {
+      aValue.SetAllValue();
+      return PR_TRUE;
+    } else {
+      nsCSSProperty propID = nsCSSProps::LookupProperty(tk->mIdent);
+      if (propID != eCSSProperty_UNKNOWN) {
+        aValue.SetIntValue(propID, eCSSUnit_Enumerated);
+        return PR_TRUE;
+      }
+    }
+  }
+  if (((aVariantMask & VARIANT_CUBIC_BEZIER) != 0) &&
+    (eCSSToken_Function == tk->mType)) {
+     if (tk->mIdent.LowerCaseEqualsLiteral("cubic-bezier")) {
+      UngetToken();
+      return ParseTransitionTimingFunctionValues(aValue);
+    }
+  }
 
   UngetToken();
   return PR_FALSE;
 }
 
 
 PRBool
 CSSParserImpl::ParseCounter(nsCSSValue& aValue)
@@ -5171,16 +5206,25 @@ CSSParserImpl::ParseProperty(nsCSSProper
   case eCSSProperty_size:
     return ParseSize();
   case eCSSProperty_text_shadow:
     return ParseTextShadow();
   case eCSSProperty__moz_transform:
     return ParseMozTransform();
   case eCSSProperty__moz_transform_origin:
     return ParseMozTransformOrigin();
+  case eCSSProperty_transition:
+      return ParseTransition();
+  case eCSSProperty_transition_property:
+    return ParseTransitionProperty();
+  case eCSSProperty_transition_timing_function:
+    return ParseTransitionTimingFunction();
+  case eCSSProperty_transition_duration:
+  case eCSSProperty_transition_delay:
+    return ParseTransitionTime(aPropID);
 
 #ifdef MOZ_SVG
   case eCSSProperty_fill:
     return ParsePaint(&mTempData.mSVG.mFill, eCSSProperty_fill);
   case eCSSProperty_stroke:
     return ParsePaint(&mTempData.mSVG.mStroke, eCSSProperty_stroke);
   case eCSSProperty_stroke_dasharray:
     return ParseDasharray();
@@ -5328,16 +5372,21 @@ CSSParserImpl::ParseSingleValueProperty(
   case eCSSProperty_padding_right:
   case eCSSProperty_padding_start:
   case eCSSProperty_pause:
   case eCSSProperty_quotes:
   case eCSSProperty_size:
   case eCSSProperty_text_shadow:
   case eCSSProperty__moz_transform:
   case eCSSProperty__moz_transform_origin:
+  case eCSSProperty_transition:
+  case eCSSProperty_transition_property:
+  case eCSSProperty_transition_timing_function:
+  case eCSSProperty_transition_duration:
+  case eCSSProperty_transition_delay:
   case eCSSProperty_COUNT:
 #ifdef MOZ_SVG
   case eCSSProperty_fill:
   case eCSSProperty_stroke:
   case eCSSProperty_stroke_dasharray:
   case eCSSProperty_marker:
 #endif
     NS_ERROR("not a single value property");
@@ -7943,16 +7992,387 @@ CSSParserImpl::ParseTextDecoration(nsCSS
       }
       aValue.SetIntValue(intValue, eCSSUnit_Enumerated);
     }
     return PR_TRUE;
   }
   return PR_FALSE;
 }
 
+
+PRBool
+CSSParserImpl::ParseTransitionTime(nsCSSProperty aPropID)
+{
+  NS_ABORT_IF_FALSE(aPropID == eCSSProperty_transition_duration ||
+                    aPropID == eCSSProperty_transition_delay,
+                    "Invalid property");
+  nsCSSValueList** storage =
+    aPropID == eCSSProperty_transition_duration
+      ? &mTempData.mDisplay.mTransitionDuration
+      : &mTempData.mDisplay.mTransitionDelay;
+                              
+  nsCSSValue timeval;
+  // first see if 'inherit' is specified.  If it is, it can be the only thing
+  // specified, so don't attempt to parse any additional properties
+  if (ParseVariant(timeval, VARIANT_INHERIT, nsnull)) {
+    nsCSSValueList* list = new nsCSSValueList();
+    if (!list) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      return PR_FALSE;
+    }
+    list->mValue = timeval;
+    mTempData.SetPropertyBit(aPropID);
+    *storage = list;
+    return PR_TRUE;
+  }
+
+  // now try to parse normal time values
+  nsCSSValueList *listHead = nsnull;
+  nsCSSValueList **next = &listHead;
+
+  for (;;) {
+    if (!ParseVariant(timeval, VARIANT_TIME, nsnull)) {
+      break;
+    }
+    nsCSSValueList *current;
+    *next = current = new nsCSSValueList();
+    if (!current) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    next = &current->mNext;
+    current->mValue = timeval;
+    if (ExpectEndProperty()) {
+      mTempData.SetPropertyBit(aPropID);
+      *storage = listHead;
+      return PR_TRUE;
+    }
+    if (!ExpectSymbol(',', PR_TRUE)) {
+      break;
+    }
+  }
+  delete listHead;
+  return PR_FALSE;
+}
+
+PRBool
+CSSParserImpl::ParseTransitionProperty()
+{
+  nsCSSValue value;
+  // first see if 'inherit' is specified.  If it is, it can be the only thing
+  // specified, so don't attempt to parse any additional properties
+  // FIXME: We should check 'none' and 'all' here too!
+  if (ParseVariant(value, VARIANT_INHERIT, nsnull)) {
+    nsCSSValueList* list = new nsCSSValueList();
+    if (!list) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      return PR_FALSE;
+    }
+    list->mValue = value;
+    mTempData.SetPropertyBit(eCSSProperty_transition_property);
+    mTempData.mDisplay.mTransitionProperty = list;
+    return PR_TRUE;
+  }
+
+  // FIXME: what if there is an invalid value in the list -- should we go on and
+  // try the next one or just drop the entire declaration?
+  // e.g. transition-property: invalid-property, left, opacity;
+  nsCSSValueList *listHead = nsnull;
+  nsCSSValueList **next = &listHead;
+
+  for (;;) {
+    if (!ParseVariant(value, VARIANT_TRANSITION_PROPERTY, nsnull)) {
+      // FIXME: Can't ignore properties we don't know about.
+      break;
+    }
+    // FIXME: Should exclude 'none' and 'all' and 'inherit' according to the
+    // same rules as for 'counter-reset'.
+    nsCSSValueList *current;
+    *next = current = new nsCSSValueList;
+    if (!current) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    current->mValue = value;
+    next = &current->mNext;
+    if (ExpectEndProperty()) {
+      mTempData.SetPropertyBit(eCSSProperty_transition_property);
+      mTempData.mDisplay.mTransitionProperty = listHead;
+      return PR_TRUE;
+    }
+    if (!ExpectSymbol(',', PR_TRUE)) {
+      break;
+    }
+  }
+  delete listHead;
+  return PR_FALSE;
+}
+
+PRBool
+CSSParserImpl::ParseTransitionTimingFunction()
+{
+  nsCSSValue timeFunction;
+  // first see if 'inherit' is specified.  If it is, it can be the only thing
+  // specified, so don't attempt to parse any additional properties
+  if (ParseVariant(timeFunction, VARIANT_INHERIT, nsnull)) {
+    nsCSSValueList* list = new nsCSSValueList();
+    if (!list) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      return PR_FALSE;
+    }
+    list->mValue = timeFunction;
+    mTempData.SetPropertyBit(eCSSProperty_transition_timing_function);
+    mTempData.mDisplay.mTransitionTimingFunction = list;
+    return PR_TRUE;
+  }
+
+  nsCSSValueList *listHead = nsnull;
+  nsCSSValueList **next = &listHead;
+
+  for (;;) {
+    if (!ParseVariant(timeFunction, VARIANT_TIMING_FUNCTION,
+                      nsCSSProps::kTransitionTimingFunctionKTable)) {
+      break;
+    }
+    nsCSSValueList *current;
+    *next = current = new nsCSSValueList();
+    if (!current) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    next = &current->mNext;
+    current->mValue = timeFunction;
+    if (ExpectEndProperty()) {
+      mTempData.SetPropertyBit(eCSSProperty_transition_timing_function);
+      mTempData.mDisplay.mTransitionTimingFunction = listHead;
+      return PR_TRUE;
+    }
+    if (!ExpectSymbol (',', PR_TRUE)) {
+      break;
+    }
+  }
+
+  delete listHead;
+  return PR_FALSE;
+}
+
+PRBool
+CSSParserImpl::ParseTransitionTimingFunctionValues(nsCSSValue& aValue)
+{
+  if (!GetToken(PR_TRUE)) {
+    REPORT_UNEXPECTED_EOF(PEColorEOF);
+    return PR_FALSE;
+  }
+
+  nsRefPtr<nsCSSValue::Array> val = nsCSSValue::Array::Create(4);
+  if (!val) {
+       mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+  }
+  float x1,x2,y1,y2;
+  nsCSSToken* tk = &mToken;
+
+  if (tk->mType == eCSSToken_Function){
+    if (ExpectSymbol('(',PR_FALSE)) {
+     ParseTransitionTimingFunctionValueComponent(x1,',');
+     ParseTransitionTimingFunctionValueComponent(y1,',');
+     ParseTransitionTimingFunctionValueComponent(x2,',');
+     ParseTransitionTimingFunctionValueComponent(y2,')');
+    }
+  }
+  
+  val->Item(0).SetFloatValue(x1, eCSSUnit_Number);
+  val->Item(1).SetFloatValue(y1, eCSSUnit_Number);
+  val->Item(2).SetFloatValue(x2, eCSSUnit_Number);
+  val->Item(3).SetFloatValue(y2, eCSSUnit_Number);
+
+  aValue.SetArrayValue(val, eCSSUnit_Cubic_Bezier);
+  
+  return PR_TRUE;
+}
+
+PRBool
+CSSParserImpl::ParseTransitionTimingFunctionValueComponent(float& aComponent,
+                                                           char aStop)
+{
+  if (!GetToken(PR_TRUE)) {
+    REPORT_UNEXPECTED_EOF(PEColorComponentEOF);
+    return PR_FALSE;
+  }
+  nsCSSToken* tk = &mToken;
+  if (tk->mType == eCSSToken_Number) {
+    aComponent = tk->mNumber;
+    if (ExpectSymbol(aStop,PR_TRUE)) {
+     return PR_TRUE;
+    }
+  }
+  return PR_FALSE;
+}
+
+PRBool
+CSSParserImpl::AppendValueToList(nsCSSValueList*& list, nsCSSValue& value)
+{
+  nsCSSValueList **end = nsnull;
+  // if the list is empty, simply create a new head node
+  if (!list){
+    end = &list;
+  }
+  // otherwise advance to the last item in the list and create a new
+  // item at the end
+  else {
+    nsCSSValueList* tmp = list;
+    // advance to the last item in the list
+    while (tmp->mNext)
+      tmp = tmp->mNext;
+    end = &tmp->mNext;
+  }
+  NS_ASSERTION(end && (*end == nsnull),
+               "'end' should be pointing to a NULL pointer");
+  *end = new nsCSSValueList();
+  if (!(*end)) {
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+    return PR_FALSE;
+  }
+  (*end)->mValue = value;
+  return PR_TRUE;
+}
+
+PRBool
+CSSParserImpl::ParseTransition()
+{
+  // FIXME: rewrite to use ParseChoice
+  static const nsCSSProperty kTransitionProperties[] = {
+    eCSSProperty_transition_property,
+    eCSSProperty_transition_duration,
+    eCSSProperty_transition_timing_function,
+    eCSSProperty_transition_delay
+  };
+  static const PRSize numProps = NS_ARRAY_LENGTH(kTransitionProperties);
+  // this is a shorthand property that accepts -property, -delay,
+  // -duration, and -timing-function with some components missing.
+  // there can be multiple transitions, separated with commas
+
+  nsCSSValue tempValue;
+  // first see if 'inherit' is specified.  If it is, it can be the only thing
+  // specified, so don't attempt to parse any additional properties
+  if (ParseVariant(tempValue, VARIANT_INHERIT, nsnull)) {
+    for (int i = 0; i < numProps; ++i) {
+      nsCSSValueList* list = new nsCSSValueList();
+      if (!list) {
+        mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+        return PR_FALSE;
+      }
+      list->mValue = tempValue;
+      nsCSSProperty prop = kTransitionProperties[i];
+      *static_cast<nsCSSValueList**>(mTempData.PropertyAt(prop)) = list;
+      mTempData.SetPropertyBit(prop);
+    }
+    return PR_TRUE;
+  }
+
+  nsCSSValueList* values[numProps] = { nsnull };
+  // flags to determine whethe ra particular subproperty was specified for this
+  // transition
+  PRBool parsedProperty[numProps] = { PR_FALSE };
+  PRUint8 i;
+  PRBool atEOP = PR_FALSE;
+  for (;;) {
+    for (;;) {
+      PRBool foundProperty = PR_FALSE;
+      // check to see if we're at the end of one full transition definition
+      // (either because we hit a comma or because we hit the end of the
+      // property definition)
+      if (ExpectSymbol(',', PR_TRUE))
+        break;
+      if (ExpectEndProperty()) {
+        atEOP = PR_TRUE;
+        break;
+      }
+
+      // else, try to parse the next transition sub-property
+      for (i = 0; !foundProperty && i < numProps; ++i) {
+        if (!parsedProperty[i]) {
+          // if we haven't found this property yet, try to parse it
+          PRInt32 variantMask;
+          const PRInt32* table = nsnull;
+          switch (kTransitionProperties[i]) {
+            case eCSSProperty_transition_property:
+              variantMask = VARIANT_TRANSITION_PROPERTY;
+              break;
+            case eCSSProperty_transition_duration:
+            case eCSSProperty_transition_delay:
+              variantMask = VARIANT_TIME;
+              break;
+            case eCSSProperty_transition_timing_function:
+              variantMask = VARIANT_TIMING_FUNCTION;
+              table = nsCSSProps::kTransitionTimingFunctionKTable;
+              break;
+            default:
+              NS_NOTREACHED("Invalid transition property");
+          }
+          if (ParseVariant(tempValue, variantMask, table)) {
+            parsedProperty[i] = PR_TRUE;
+            AppendValueToList(values[i], tempValue);
+            foundProperty = PR_TRUE;
+            break;  // break out of inner loop, continue looking for next sub-property
+          }
+        }
+      }
+      if (!foundProperty) {
+        // we're not at a ',' or at the end of a the property but we couldn't
+        // parse any of the sub-properties, so the declaration is invalid
+        return PR_FALSE;
+      }
+    }
+
+    // we hit the end of the property or the end of one transition
+    // definition, add its components to the list
+    for (i = 0; i < numProps; ++i) {
+      // if the all of the subproperties were not explicitly specified, fill
+      // in the missing ones with initial values.
+      if (!parsedProperty[i]) {
+        switch (kTransitionProperties[i]) {
+          case eCSSProperty_transition_property:
+            tempValue.SetAllValue();
+            mTempData.mDisplay.mTransitionProperty = values[i];
+            break;
+          case eCSSProperty_transition_duration:
+            tempValue.SetFloatValue(0.0, eCSSUnit_Seconds);
+            mTempData.mDisplay.mTransitionDuration = values[i];
+            break;
+          case eCSSProperty_transition_timing_function:
+            tempValue.SetIntValue(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE, eCSSUnit_Enumerated);
+            mTempData.mDisplay.mTransitionTimingFunction = values[i];
+            break;
+          case eCSSProperty_transition_delay:
+            tempValue.SetFloatValue(0.0, eCSSUnit_Seconds);
+            mTempData.mDisplay.mTransitionDelay = values[i];
+            break;
+          default:
+            NS_NOTREACHED("Invalid transition property");
+        }
+        AppendValueToList(values[i], tempValue);
+      }
+      // reset flags for next transition
+      parsedProperty[i] = PR_FALSE;
+    }
+
+    if (atEOP)
+      break;
+    // else we just hit a ',' so continue parsing the next compound transition
+  }
+
+  // Save all parsed transition sub-properties in mTempData
+  for (i = 0; i < numProps; ++i) {
+    nsCSSProperty prop = kTransitionProperties[i];
+    *static_cast<nsCSSValueList**>(mTempData.PropertyAt(prop)) = values[i];
+    mTempData.SetPropertyBit(prop);
+  }
+  return PR_TRUE;
+}
+
 nsCSSValueList*
 CSSParserImpl::ParseCSSShadowList(PRBool aIsBoxShadow)
 {
   nsAutoParseCompoundProperty compound(this);
 
   // Parses x, y, radius, color (in two possible orders)
   // This parses the input into a list. Either it contains just a "none" or
   // "inherit" value, or a list of arrays.
diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -514,16 +514,21 @@ CSS_PROP_TABLE(table-layout, table_layou
 CSS_PROP_TEXT(text-align, text_align, TextAlign, 0, Text, mTextAlign, eCSSType_Value, kTextAlignKTable)
 CSS_PROP_TEXTRESET(text-decoration, text_decoration, TextDecoration, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE, Text, mDecoration, eCSSType_Value, kTextDecorationKTable)
 CSS_PROP_TEXT(text-indent, text_indent, TextIndent, 0, Text, mTextIndent, eCSSType_Value, nsnull)
 CSS_PROP_TEXT(text-shadow, text_shadow, TextShadow, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE | CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Text, mTextShadow, eCSSType_ValueList, nsnull)
 CSS_PROP_TEXT(text-transform, text_transform, TextTransform, CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE, Text, mTextTransform, eCSSType_Value, kTextTransformKTable)
 CSS_PROP_DISPLAY(-moz-transform, _moz_transform, MozTransform, 0, Display, mTransform, eCSSType_ValueList, kDisplayKTable)
 CSS_PROP_DISPLAY(-moz-transform-origin, _moz_transform_origin, MozTransformOrigin, 0, Display, mTransformOrigin, eCSSType_ValuePair, kBackgroundPositionKTable)
 CSS_PROP_POSITION(top, top, Top, 0, Position, mOffset.mTop, eCSSType_Value, nsnull)
+CSS_PROP_SHORTHAND(-moz-transition, transition, MozTransition, 0)
+CSS_PROP_DISPLAY(-moz-transition-delay, transition_delay, MozTransitionDelay, CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Display, mTransitionDelay, eCSSType_ValueList, nsnull)
+CSS_PROP_DISPLAY(-moz-transition-duration, transition_duration, MozTransitionDuration, CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Display, mTransitionDuration, eCSSType_ValueList, nsnull)
+CSS_PROP_DISPLAY(-moz-transition-property, transition_property, MozTransitionProperty, CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Display, mTransitionProperty, eCSSType_ValueList /* list of CSS properties that have transitions ? */, nsnull)
+CSS_PROP_DISPLAY(-moz-transition-timing-function, transition_timing_function, MozTransitionTimingFunction, CSS_PROPERTY_VALUE_LIST_USES_COMMAS, Display, mTransitionTimingFunction, eCSSType_ValueList, kTransitionTimingFunctionKTable)
 CSS_PROP_TEXTRESET(unicode-bidi, unicode_bidi, UnicodeBidi, 0, Text, mUnicodeBidi, eCSSType_Value, kUnicodeBidiKTable)
 CSS_PROP_USERINTERFACE(-moz-user-focus, user_focus, MozUserFocus, 0, UserInterface, mUserFocus, eCSSType_Value, kUserFocusKTable) // XXX bug 3935
 CSS_PROP_USERINTERFACE(-moz-user-input, user_input, MozUserInput, 0, UserInterface, mUserInput, eCSSType_Value, kUserInputKTable) // XXX ??? // XXX bug 3935
 CSS_PROP_USERINTERFACE(-moz-user-modify, user_modify, MozUserModify, 0, UserInterface, mUserModify, eCSSType_Value, kUserModifyKTable) // XXX bug 3935
 CSS_PROP_UIRESET(-moz-user-select, user_select, MozUserSelect, 0, UserInterface, mUserSelect, eCSSType_Value, kUserSelectKTable) // XXX bug 3935
 // NOTE: vertical-align is only supposed to apply to :first-letter when
 // 'float' is 'none', but we don't worry about that since it has no
 // effect otherwise
diff --git a/layout/style/nsCSSProps.cpp b/layout/style/nsCSSProps.cpp
--- a/layout/style/nsCSSProps.cpp
+++ b/layout/style/nsCSSProps.cpp
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1999
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -1097,16 +1098,25 @@ const PRInt32 nsCSSProps::kTextDecoratio
 
 const PRInt32 nsCSSProps::kTextTransformKTable[] = {
   eCSSKeyword_capitalize, NS_STYLE_TEXT_TRANSFORM_CAPITALIZE,
   eCSSKeyword_lowercase, NS_STYLE_TEXT_TRANSFORM_LOWERCASE,
   eCSSKeyword_uppercase, NS_STYLE_TEXT_TRANSFORM_UPPERCASE,
   eCSSKeyword_UNKNOWN,-1
 };
 
+const PRInt32 nsCSSProps::kTransitionTimingFunctionKTable[] = {
+  eCSSKeyword_ease, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE,
+  eCSSKeyword_linear, NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR,
+  eCSSKeyword_ease_in, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN,
+  eCSSKeyword_ease_out, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT, 
+  eCSSKeyword_ease_in_out, NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT, 
+  eCSSKeyword_UNKNOWN,-1
+};
+
 const PRInt32 nsCSSProps::kUnicodeBidiKTable[] = {
   eCSSKeyword_embed, NS_STYLE_UNICODE_BIDI_EMBED,
   eCSSKeyword_bidi_override, NS_STYLE_UNICODE_BIDI_OVERRIDE,
   eCSSKeyword_UNKNOWN,-1
 };
 
 const PRInt32 nsCSSProps::kUserFocusKTable[] = {
   eCSSKeyword_ignore,         NS_STYLE_USER_FOCUS_IGNORE,
@@ -1901,16 +1911,24 @@ static const nsCSSProperty gMozPaddingEn
 };
 
 static const nsCSSProperty gPauseSubpropTable[] = {
   eCSSProperty_pause_after,
   eCSSProperty_pause_before,
   eCSSProperty_UNKNOWN
 };
 
+static const nsCSSProperty gMozTransitionSubpropTable[] = {
+  eCSSProperty_transition_property,
+  eCSSProperty_transition_duration,
+  eCSSProperty_transition_timing_function,
+  eCSSProperty_transition_delay,
+  eCSSProperty_UNKNOWN
+};
+
 #ifdef MOZ_SVG
 static const nsCSSProperty gMarkerSubpropTable[] = {
   eCSSProperty_marker_start,
   eCSSProperty_marker_mid,
   eCSSProperty_marker_end,
   eCSSProperty_UNKNOWN
 };
 #endif
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Joanthon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -227,16 +228,17 @@ public:
   static const PRInt32 kSpeakNumeralKTable[];
   static const PRInt32 kSpeakPunctuationKTable[];
   static const PRInt32 kSpeechRateKTable[];
   static const PRInt32 kStackSizingKTable[];
   static const PRInt32 kTableLayoutKTable[];
   static const PRInt32 kTextAlignKTable[];
   static const PRInt32 kTextDecorationKTable[];
   static const PRInt32 kTextTransformKTable[];
+  static const PRInt32 kTransitionTimingFunctionKTable[];
   static const PRInt32 kUnicodeBidiKTable[];
   static const PRInt32 kUserFocusKTable[];
   static const PRInt32 kUserInputKTable[];
   static const PRInt32 kUserModifyKTable[];
   static const PRInt32 kUserSelectKTable[];
   static const PRInt32 kVerticalAlignKTable[];
   static const PRInt32 kVisibilityKTable[];
   static const PRInt32 kVolumeKTable[];
diff --git a/layout/style/nsCSSStruct.cpp b/layout/style/nsCSSStruct.cpp
--- a/layout/style/nsCSSStruct.cpp
+++ b/layout/style/nsCSSStruct.cpp
@@ -264,16 +264,20 @@ nsCSSValueListRect::sides[4] = {
   &nsCSSValueListRect::mBottom,
   &nsCSSValueListRect::mLeft,
 };
 
 // --- nsCSSDisplay -----------------
 
 /* During allocation, null-out the transform list. */
 nsCSSDisplay::nsCSSDisplay(void) : mTransform(nsnull)
+  , mTransitionProperty(nsnull)
+  , mTransitionDuration(nsnull)
+  , mTransitionTimingFunction(nsnull)
+  , mTransitionDelay(nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSDisplay);
 }
 
 nsCSSDisplay::~nsCSSDisplay(void)
 {
   MOZ_COUNT_DTOR(nsCSSDisplay);
 }
diff --git a/layout/style/nsCSSStruct.h b/layout/style/nsCSSStruct.h
--- a/layout/style/nsCSSStruct.h
+++ b/layout/style/nsCSSStruct.h
@@ -369,16 +369,20 @@ struct nsCSSDisplay : public nsCSSStruct
   nsCSSValue mClear;
   nsCSSRect  mClip;
   nsCSSValue mOverflowX;
   nsCSSValue mOverflowY;
   nsCSSValue mVisibility;
   nsCSSValue mOpacity;
   nsCSSValueList *mTransform; // List of Arrays containing transform information
   nsCSSValuePair mTransformOrigin;
+  nsCSSValueList* mTransitionProperty;
+  nsCSSValueList* mTransitionDuration;
+  nsCSSValueList* mTransitionTimingFunction;
+  nsCSSValueList* mTransitionDelay;
 
   // temp fix for bug 24000 
   nsCSSValue mBreakBefore;
   nsCSSValue mBreakAfter;
   // end temp fix
 private:
   nsCSSDisplay(const nsCSSDisplay& aOther); // NOT IMPLEMENTED
 };
diff --git a/layout/style/nsCSSValue.cpp b/layout/style/nsCSSValue.cpp
--- a/layout/style/nsCSSValue.cpp
+++ b/layout/style/nsCSSValue.cpp
@@ -345,16 +345,22 @@ void nsCSSValue::SetInitialValue()
 }
 
 void nsCSSValue::SetNoneValue()
 {
   Reset();
   mUnit = eCSSUnit_None;
 }
 
+void nsCSSValue::SetAllValue()
+{
+  Reset();
+  mUnit = eCSSUnit_All;
+}
+
 void nsCSSValue::SetNormalValue()
 {
   Reset();
   mUnit = eCSSUnit_Normal;
 }
 
 void nsCSSValue::SetSystemFontValue()
 {
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -88,31 +88,33 @@ class nsIPrincipal;
 enum nsCSSUnit {
   eCSSUnit_Null         = 0,      // (n/a) null unit, value is not specified
   eCSSUnit_Auto         = 1,      // (n/a) value is algorithmic
   eCSSUnit_Inherit      = 2,      // (n/a) value is inherited
   eCSSUnit_Initial      = 3,      // (n/a) value is default UA value
   eCSSUnit_None         = 4,      // (n/a) value is none
   eCSSUnit_Normal       = 5,      // (n/a) value is normal (algorithmic, different than auto)
   eCSSUnit_System_Font  = 6,      // (n/a) value is -moz-use-system-font
-  eCSSUnit_Dummy        = 7,      // (n/a) a fake but specified value, used
+  eCSSUnit_All          = 7,      // (n/a) value is all
+  eCSSUnit_Dummy        = 8,      // (n/a) a fake but specified value, used
                                   //       only in temporary values
-  eCSSUnit_DummyInherit = 8,      // (n/a) a fake but specified value, used
+  eCSSUnit_DummyInherit = 9,      // (n/a) a fake but specified value, used
                                   //       only in temporary values
-  eCSSUnit_RectIsAuto   = 9,      // (n/a) 'auto' for an entire rect()
-  eCSSUnit_String       = 10,     // (PRUnichar*) a string value
-  eCSSUnit_Ident        = 11,     // (PRUnichar*) a string value
-  eCSSUnit_Families     = 12,     // (PRUnichar*) a string value
-  eCSSUnit_Attr         = 13,     // (PRUnichar*) a attr(string) value
-  eCSSUnit_Local_Font   = 14,     // (PRUnichar*) a local font name
-  eCSSUnit_Font_Format  = 15,     // (PRUnichar*) a font format name
+  eCSSUnit_RectIsAuto   = 10,     // (n/a) 'auto' for an entire rect()
+  eCSSUnit_String       = 11,     // (PRUnichar*) a string value
+  eCSSUnit_Ident        = 12,     // (PRUnichar*) a string value
+  eCSSUnit_Families     = 13,     // (PRUnichar*) a string value
+  eCSSUnit_Attr         = 14,     // (PRUnichar*) a attr(string) value
+  eCSSUnit_Local_Font   = 15,     // (PRUnichar*) a local font name
+  eCSSUnit_Font_Format  = 16,     // (PRUnichar*) a font format name
   eCSSUnit_Array        = 20,     // (nsCSSValue::Array*) a list of values
   eCSSUnit_Counter      = 21,     // (nsCSSValue::Array*) a counter(string,[string]) value
   eCSSUnit_Counters     = 22,     // (nsCSSValue::Array*) a counters(string,string[,string]) value
-  eCSSUnit_Function     = 23,     // (nsCSSValue::Array*) a function with parameters.  First elem of array is name,
+  eCSSUnit_Cubic_Bezier = 23,     // (nsCSSValue::Array*) a list of float values 
+  eCSSUnit_Function     = 24,     // (nsCSSValue::Array*) a function with parameters.  First elem of array is name,
                                   //  the rest of the values are arguments.
 
   eCSSUnit_URL          = 30,     // (nsCSSValue::URL*) value
   eCSSUnit_Image        = 31,     // (nsCSSValue::Image*) value
   eCSSUnit_Integer      = 50,     // (int) simple value
   eCSSUnit_Enumerated   = 51,     // (int) value has enumerated meaning
   eCSSUnit_EnumColor    = 80,     // (int) enumerated color (kColorKTable)
   eCSSUnit_Color        = 81,     // (nscolor) an RGBA value
@@ -161,17 +163,17 @@ public:
   friend struct Array;
 
   struct URL;
   friend struct URL;
 
   struct Image;
   friend struct Image;
   
-  // for valueless units only (null, auto, inherit, none, normal)
+  // for valueless units only (null, auto, inherit, none, all, normal)
   explicit nsCSSValue(nsCSSUnit aUnit = eCSSUnit_Null)
     : mUnit(aUnit)
   {
     NS_ASSERTION(aUnit <= eCSSUnit_RectIsAuto, "not a valueless unit");
   }
 
   nsCSSValue(PRInt32 aValue, nsCSSUnit aUnit) NS_HIDDEN;
   nsCSSValue(float aValue, nsCSSUnit aUnit) NS_HIDDEN;
@@ -304,16 +306,17 @@ public:
   NS_HIDDEN_(void)  SetColorValue(nscolor aValue);
   NS_HIDDEN_(void)  SetArrayValue(nsCSSValue::Array* aArray, nsCSSUnit aUnit);
   NS_HIDDEN_(void)  SetURLValue(nsCSSValue::URL* aURI);
   NS_HIDDEN_(void)  SetImageValue(nsCSSValue::Image* aImage);
   NS_HIDDEN_(void)  SetAutoValue();
   NS_HIDDEN_(void)  SetInheritValue();
   NS_HIDDEN_(void)  SetInitialValue();
   NS_HIDDEN_(void)  SetNoneValue();
+  NS_HIDDEN_(void)  SetAllValue();
   NS_HIDDEN_(void)  SetNormalValue();
   NS_HIDDEN_(void)  SetSystemFontValue();
   NS_HIDDEN_(void)  SetDummyValue();
   NS_HIDDEN_(void)  SetDummyInheritValue();
   NS_HIDDEN_(void)  SetRectIsAutoValue();
   NS_HIDDEN_(void)  StartImageLoad(nsIDocument* aDocument)
                                    const;  // Not really const, but pretending
 
diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -21,16 +21,17 @@
  *
  * Contributor(s):
  *   Daniel Glazman <glazman@netscape.com>
  *   Boris Zbarsky <bzbarsky@mit.edu>
  *   Christopher A. Aillon <christopher@aillon.com>
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   Christian Biesinger <cbiesinger@web.de>
  *   Michael Ventnor <m.ventnor@gmail.com>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -42,16 +43,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 /* DOM object returned from element.getComputedStyle() */
 
 #include "nsComputedDOMStyle.h"
 
 #include "nsDOMError.h"
 #include "nsDOMString.h"
+#include "nsPrintfCString.h"
 #include "nsIDOMNSCSS2Properties.h"
 #include "nsIDOMElement.h"
 #include "nsIDOMCSSPrimitiveValue.h"
 #include "nsStyleContext.h"
 #include "nsIScrollableFrame.h"
 #include "nsContentUtils.h"
 #include "prprf.h"
 
@@ -4029,16 +4031,161 @@ nsComputedDOMStyle::GetMask(nsIDOMCSSVal
   else
     val->SetIdent(eCSSKeyword_none);
 
   return CallQueryInterface(val, aValue);
 }
 
 #endif // MOZ_SVG
 
+nsresult
+nsComputedDOMStyle::GetTransitionDelay(nsIDOMCSSValue** aValue)
+{
+  const nsStyleDisplay* display = GetStyleDisplay();
+
+  if (!display->mTransitions) {
+    nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
+    NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
+    val->SetTime(0.0f);
+    return CallQueryInterface(val, aValue);
+  }
+
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  nsTransition* transition = display->mTransitions;
+  NS_ASSERTION(transition->GetDelayExplicit(),
+               "first item must be explicit");
+  do {
+    nsROCSSPrimitiveValue* delay = GetROCSSPrimitiveValue();
+    if (!delay || !valueList->AppendCSSValue(delay)) {
+      delete valueList;
+      delete delay;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+    delay->SetTime((float)transition->GetDelay() / (float)PR_MSEC_PER_SEC);
+  } while ((transition = transition->mNext) &&
+           transition->GetDelayExplicit());
+
+  return CallQueryInterface(valueList, aValue);
+}
+
+nsresult
+nsComputedDOMStyle::GetTransitionDuration(nsIDOMCSSValue** aValue)
+{
+  const nsStyleDisplay* display = GetStyleDisplay();
+
+  if (!display->mTransitions) {
+    nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
+    NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
+    val->SetTime(0.0f);
+    return CallQueryInterface(val, aValue);
+  }
+
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  nsTransition* transition = display->mTransitions;
+  NS_ASSERTION(transition->GetDurationExplicit(),
+               "first item must be explicit");
+  do {
+    nsROCSSPrimitiveValue* duration = GetROCSSPrimitiveValue();
+    if (!duration || !valueList->AppendCSSValue(duration)) {
+      delete valueList;
+      delete duration;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    duration->SetTime((float)transition->GetDuration() / (float)PR_MSEC_PER_SEC);
+  } while ((transition = transition->mNext) &&
+           transition->GetDurationExplicit());
+
+  return CallQueryInterface(valueList, aValue);
+}
+
+nsresult
+nsComputedDOMStyle::GetTransitionProperty(nsIDOMCSSValue** aValue)
+{
+  const nsStyleDisplay* display = GetStyleDisplay();
+
+  if (!display->mTransitions) {
+    nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
+    NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
+    val->SetIdent(eCSSKeyword_all);
+    return CallQueryInterface(val, aValue);
+  }
+
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  nsTransition* transition = display->mTransitions;
+  NS_ASSERTION(transition->GetPropertyExplicit(),
+               "first item must be explicit");
+  do {
+    nsROCSSPrimitiveValue* property = GetROCSSPrimitiveValue();
+    if (!property || !valueList->AppendCSSValue(property)) {
+      delete valueList;
+      delete property;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+    if (transition->IsPropertyAll())
+      property->SetIdent(eCSSKeyword_all);
+    else if (transition->IsPropertyNone())
+      property->SetIdent(eCSSKeyword_none);
+    else
+      property->SetString(nsCSSProps::GetStringValue(transition->GetProperty()));
+  } while ((transition = transition->mNext) &&
+           transition->GetPropertyExplicit());
+
+  return CallQueryInterface(valueList, aValue);
+}
+
+nsresult
+nsComputedDOMStyle::GetTransitionTimingFunction(nsIDOMCSSValue** aValue)
+{
+  const nsStyleDisplay* display = GetStyleDisplay();
+
+  if (!display->mTransitions) {
+    nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
+    NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
+    val->SetIdent(eCSSKeyword_ease);
+    return CallQueryInterface(val, aValue);
+  }
+
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  nsTransition* transition = display->mTransitions;
+  NS_ASSERTION(transition->GetTimingFunctionExplicit(),
+               "first item must be explicit");
+  do {
+    nsROCSSPrimitiveValue* timingFunction = GetROCSSPrimitiveValue();
+    if (!timingFunction || !valueList->AppendCSSValue(timingFunction)) {
+      delete valueList;
+      delete timingFunction;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    // FIXME: should we use keywords here or control points?  
+    nsCSSKeyword keyword = nsCSSProps::ValueToKeywordEnum(transition->GetTimingFunction().mTimingFunctionType, nsCSSProps::kTransitionTimingFunctionKTable);
+    if (eCSSKeyword_UNKNOWN != keyword) {
+      timingFunction->SetIdent(keyword);
+    } else {
+      // set the value from the cubic-bezier control points
+      timingFunction->SetString(nsPrintfCString(64, "cubic-bezier(%g, %g, %g, %g)",
+                                                transition->GetTimingFunction().mX1,
+                                                transition->GetTimingFunction().mY1,
+                                                transition->GetTimingFunction().mX2,
+                                                transition->GetTimingFunction().mY2));
+    }
+  } while ((transition = transition->mNext) &&
+           transition->GetTimingFunctionExplicit());
+
+  return CallQueryInterface(valueList, aValue);
+}
 
 #define COMPUTED_STYLE_MAP_ENTRY(_prop, _method)              \
   { eCSSProperty_##_prop, &nsComputedDOMStyle::Get##_method, PR_FALSE }
 #define COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_prop, _method)       \
   { eCSSProperty_##_prop, &nsComputedDOMStyle::Get##_method, PR_TRUE }
 
 const nsComputedDOMStyle::ComputedStyleMapEntry*
 nsComputedDOMStyle::GetQueryablePropertyMap(PRUint32* aLength)
@@ -4230,16 +4377,20 @@ nsComputedDOMStyle::GetQueryableProperty
     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_outline_radius_topRight,   OutlineRadiusTopRight),
     COMPUTED_STYLE_MAP_ENTRY(stack_sizing,                  StackSizing),
     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_transform,         MozTransform),
     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_transform_origin,  MozTransformOrigin),
     COMPUTED_STYLE_MAP_ENTRY(user_focus,                    UserFocus),
     COMPUTED_STYLE_MAP_ENTRY(user_input,                    UserInput),
     COMPUTED_STYLE_MAP_ENTRY(user_modify,                   UserModify),
     COMPUTED_STYLE_MAP_ENTRY(user_select,                   UserSelect),
+    COMPUTED_STYLE_MAP_ENTRY(transition_delay,              TransitionDelay),
+    COMPUTED_STYLE_MAP_ENTRY(transition_duration,           TransitionDuration),
+    COMPUTED_STYLE_MAP_ENTRY(transition_property,           TransitionProperty),
+    COMPUTED_STYLE_MAP_ENTRY(transition_timing_function,    TransitionTimingFunction),
     COMPUTED_STYLE_MAP_ENTRY(_moz_window_shadow,            WindowShadow),
     COMPUTED_STYLE_MAP_ENTRY(word_wrap,                     WordWrap)
 
 #ifdef MOZ_SVG
     ,
     COMPUTED_STYLE_MAP_ENTRY(clip_path,                     ClipPath),
     COMPUTED_STYLE_MAP_ENTRY(clip_rule,                     ClipRule),
     COMPUTED_STYLE_MAP_ENTRY(color_interpolation,           ColorInterpolation),
diff --git a/layout/style/nsComputedDOMStyle.h b/layout/style/nsComputedDOMStyle.h
--- a/layout/style/nsComputedDOMStyle.h
+++ b/layout/style/nsComputedDOMStyle.h
@@ -300,16 +300,22 @@ private:
   /* Column properties */
   nsresult GetColumnCount(nsIDOMCSSValue** aValue);
   nsresult GetColumnWidth(nsIDOMCSSValue** aValue);
   nsresult GetColumnGap(nsIDOMCSSValue** aValue);
   nsresult GetColumnRuleWidth(nsIDOMCSSValue** aValue);
   nsresult GetColumnRuleStyle(nsIDOMCSSValue** aValue);
   nsresult GetColumnRuleColor(nsIDOMCSSValue** aValue);
 
+  /* CSS Transitions */
+  nsresult GetTransitionProperty(nsIDOMCSSValue** aValue);
+  nsresult GetTransitionDuration(nsIDOMCSSValue** aValue);
+  nsresult GetTransitionDelay(nsIDOMCSSValue** aValue);
+  nsresult GetTransitionTimingFunction(nsIDOMCSSValue** aValue);
+
 #ifdef MOZ_SVG
   /* SVG properties */
   nsresult GetSVGPaintFor(PRBool aFill, nsIDOMCSSValue** aValue);
 
   nsresult GetFill(nsIDOMCSSValue** aValue);
   nsresult GetStroke(nsIDOMCSSValue** aValue);
   nsresult GetMarkerEnd(nsIDOMCSSValue** aValue);
   nsresult GetMarkerMid(nsIDOMCSSValue** aValue);
diff --git a/layout/style/nsROCSSPrimitiveValue.cpp b/layout/style/nsROCSSPrimitiveValue.cpp
--- a/layout/style/nsROCSSPrimitiveValue.cpp
+++ b/layout/style/nsROCSSPrimitiveValue.cpp
@@ -227,29 +227,34 @@ nsROCSSPrimitiveValue::GetCssText(nsAStr
             break;
           tmpStr.Append(comma + colorValue);
         }
 
         tmpStr.Append(NS_LITERAL_STRING(")"));
 
         break;
       }
+    case CSS_S :
+      {
+        tmpStr.AppendFloat(mValue.mFloat);
+        tmpStr.AppendLiteral("s");
+        break;
+      }
     case CSS_CM :
     case CSS_MM :
     case CSS_IN :
     case CSS_PT :
     case CSS_PC :
     case CSS_UNKNOWN :
     case CSS_EMS :
     case CSS_EXS :
     case CSS_DEG :
     case CSS_RAD :
     case CSS_GRAD :
     case CSS_MS :
-    case CSS_S :
     case CSS_HZ :
     case CSS_KHZ :
     case CSS_DIMENSION :
       NS_ERROR("We have a bogus value set.  This should not happen");
       return NS_ERROR_DOM_INVALID_ACCESS_ERR;
   }
 
   if (NS_SUCCEEDED(result)) {
diff --git a/layout/style/nsROCSSPrimitiveValue.h b/layout/style/nsROCSSPrimitiveValue.h
--- a/layout/style/nsROCSSPrimitiveValue.h
+++ b/layout/style/nsROCSSPrimitiveValue.h
@@ -177,16 +177,23 @@ public:
       NS_ADDREF(mValue.mRect);
       mType = CSS_RECT;
     }
     else {
       mType = CSS_UNKNOWN;
     }
   }
 
+  void SetTime(float aValue)
+  {
+    Reset();
+    mValue.mFloat = aValue;
+    mType = CSS_S;
+  }
+
   void Reset(void)
   {
     switch (mType) {
       case CSS_IDENT:
         break;
       case CSS_STRING:
       case CSS_ATTR:
       case CSS_COUNTER: // FIXME: Counter should use an object
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -23,16 +23,17 @@
  *   Original Author: David W. Hyatt (hyatt@netscape.com)
  *   Daniel Glazman <glazman@netscape.com>
  *   Roger B. Sidje <rbs@maths.uq.edu.au>
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   L. David Baron <dbaron@dbaron.org>
  *   Christian Biesinger <cbiesinger@web.de>
  *   Michael Ventnor <m.ventnor@gmail.com>
  *   Keith Rarick <kr@xph.us>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -3369,27 +3370,337 @@ static nsStyleTransformMatrix ReadTransf
     nsStyleTransformMatrix currMatrix;
     currMatrix.SetToTransformFunction(currElem.GetArrayValue(), aContext,
                                       aPresContext, aCanStoreInRuleTree);
     result *= currMatrix;
   }
   return result;
 }
 
+// This function will count the number of transitions owned by the given
+// nsStyleDisplay that return true for the given test function.  If the test
+// function is null, counts all transitions
+typedef PRBool (nsTransition::*TransitionTestFunc)(void) const;
+inline static int GetNumTransitions(const nsStyleDisplay* aStyleDisplay,
+                                    TransitionTestFunc aTestFunc = nsnull)
+{
+  nsTransition* t = aStyleDisplay->mTransitions;
+  int len = 0;
+  while (t) {
+    if (aTestFunc && !(t->*aTestFunc)())
+      break;
+    len++;
+    t = t->mNext;
+  }
+  return len;
+}
+
+// A simple helper function to get the length of a nsCSSValueList
+inline static int GetValueListLength(nsCSSValueList* aValueList)
+{
+  int len = 0;
+  nsCSSValueList* val = aValueList;
+  while (val) {
+    len++;
+    val = val->mNext;
+  }
+  return len;
+}
+
 const void*
 nsRuleNode::ComputeDisplayData(void* aStartStruct,
                                const nsRuleDataStruct& aData, 
                                nsStyleContext* aContext, 
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Display, (), display, parentDisplay,
                       Display, displayData)
 
+
+  // CSS Transitions
+  nsCSSValueList* delayList = displayData.mTransitionDelay;
+  nsCSSValueList* durationList = displayData.mTransitionDuration;
+  nsCSSValueList* propertyList = displayData. mTransitionProperty;
+  nsCSSValueList* functionList = displayData.mTransitionTimingFunction;
+
+  // Transition properties are stored in nsCSSDisplay separately in jagged
+  // arrays.  The number of transitions is equal to the number of elements in
+  // the longest array.  Arrays with fewer elements will be filled in with
+  // default values
+
+  // Transitions are difficult to handle correctly because of this.  For example
+  // we need to handle scenarios such as:
+  //  * a more general rule specifies transition-property: a, b, c;
+  //  * a more specific rule overrides as transition-property: d;
+  //
+  //  If only the general rule applied, we would fill in the extra properties
+  //  (duration, delay, etc) with initial values to create 3 fully-specified
+  //  transitions.  But when the more specific rule applies, we should only
+  //  create a single transition.  In order to do this we need to remember which
+  //  properties were explicitly specified and which ones were just filled in
+  //  with initial values to get a fully-specified transition
+
+  // cache whether any of the properties are specified as 'inherit' so we can
+  // use it below
+  PRBool delayInherited = displayData.mTransitionDelay &&
+    displayData.mTransitionDelay->mValue.GetUnit() == eCSSUnit_Inherit;
+  PRBool durationInherited = displayData.mTransitionDuration &&
+    displayData.mTransitionDuration->mValue.GetUnit() == eCSSUnit_Inherit;
+  PRBool propertyInherited = displayData.mTransitionProperty &&
+    displayData.mTransitionProperty->mValue.GetUnit() == eCSSUnit_Inherit;
+  PRBool timingFunctionInherited = displayData.mTransitionTimingFunction &&
+    displayData.mTransitionTimingFunction->mValue.GetUnit() == eCSSUnit_Inherit;
+
+  // General algorithm to determine how many total transitions we need to build.
+  // For each property:
+  //  - if there is no value specified in for the property in displayData, use
+  //    the values from the start struct, but only if they were explicitly
+  //    specified
+  //  - if there is a value specified for the property in displayData:
+  //    - if the value is 'inherit', count the number of values for that
+  //      property are specified by the parent, but only those that were
+  //      explicitly specified
+  //    - otherwise, count the number of values specified in displayData
+
+  int numTransitions = 0;
+  int numDurations = 0;
+  int numProperties = 0;
+  int numDelays = 0;
+  int numTimingFuncs = 0;
+
+  // calculate number of transition-duration elements
+  if (durationList) {
+    if (durationInherited) {
+      numDurations = GetNumTransitions(parentDisplay, &nsTransition::GetDurationExplicit);
+    } else {
+      numDurations = GetValueListLength(durationList);
+    }
+  } else {
+    numDurations = GetNumTransitions(display, &nsTransition::GetDurationExplicit);
+  }
+  if (numDurations > numTransitions)
+    numTransitions = numDurations;
+
+  // calculate number of transition-property elements
+  if (propertyList) {
+    if (propertyInherited) {
+      numProperties = GetNumTransitions(parentDisplay, &nsTransition::GetPropertyExplicit);
+    } else {
+      numProperties = GetValueListLength(propertyList);
+    }
+  } else {
+    numProperties = GetNumTransitions(display, &nsTransition::GetPropertyExplicit);
+  }
+  if (numProperties > numTransitions)
+    numTransitions = numProperties;
+
+  // calculate number of transition-delay elements
+  if (delayList) {
+    if (delayInherited) {
+      numDelays = GetNumTransitions(parentDisplay, &nsTransition::GetDelayExplicit);
+    } else {
+      numDelays = GetValueListLength(delayList);
+    }
+  } else {
+    numDelays = GetNumTransitions(display, &nsTransition::GetDelayExplicit);
+  }
+  if (numDelays > numTransitions)
+    numTransitions = numDelays;
+
+  // calculate number of transition-timing-function elements
+  if (functionList) {
+    if (timingFunctionInherited) {
+      numTimingFuncs = GetNumTransitions(parentDisplay, &nsTransition::GetTimingFunctionExplicit);
+    } else {
+      numTimingFuncs = GetValueListLength(functionList);
+    }
+  } else {
+    numTimingFuncs = GetNumTransitions(display, &nsTransition::GetTimingFunctionExplicit);
+  }
+  if (numTimingFuncs > numTransitions)
+    numTransitions = numTimingFuncs;
+
+  // determine the total number of transition objects we had already from
+  // aStartStruct
+  int numExistingTransitions = GetNumTransitions(display);
+
+  // if the transitions we already had from the start struct exceed the number
+  // we calculated above, prune the extras.  This can happen for example if a
+  // less-specific rule contains 3 values for a particular property and a
+  // more-specific rule contains only a single value.
+  if (numExistingTransitions > numTransitions)
+  {
+    nsTransition* t = display->mTransitions;
+    nsTransition* prev;
+    for (int i = 0; i < numTransitions; ++i)
+    {
+      prev = t;
+      t = t->mNext;
+    }
+    // prev is now the last valid transition, so save it so we can clear the mNext
+    // pointer and delete the remaining transitions
+    prev->mNext = nsnull;
+    while (t) {
+      nsTransition *p = t;
+      t = t->mNext;
+      delete p;
+    }
+  } else if (numExistingTransitions < numTransitions)
+  {
+    // otherwise allocate new nsTransition objects to reach numTransitions
+    nsTransition** t = &display->mTransitions;
+    for (int i = 0; i < numTransitions; ++i)
+    {
+      if (!*t) {
+        *t = new nsTransition();
+        continue;
+      }
+      else if (!(*t)->mNext) {
+        (*t)->mNext = new nsTransition();
+      }
+      t = &(*t)->mNext;
+    }
+  }
+
+  // We've already allocated the proper number of transitions above, now we just
+  // need to fill them in with the appropriate values
+  nsTransition* transition = display->mTransitions;
+  nsTransition* inheritedTransition = parentDisplay->mTransitions;
+  PRBool inheritedExplicit = PR_TRUE;
+  for (int i = 0; i < numTransitions; ++i) {
+    if (delayInherited) {
+      if (inheritedTransition)
+        transition->SetDelay(inheritedTransition->GetDelay(),
+                             inheritedExplicit && 
+                             inheritedTransition->GetDelayExplicit());
+    } else if (delayList) {
+      switch (delayList->mValue.GetUnit()) {
+        case eCSSUnit_Seconds:
+          transition->SetDelay(PR_MSEC_PER_SEC *
+                               delayList->mValue.GetFloatValue(), (numDelays-- > 0));
+          break;
+        case eCSSUnit_Milliseconds:
+          transition->SetDelay(delayList->mValue.GetFloatValue(), (numDelays-- > 0));
+          break;
+        case eCSSUnit_Initial:
+          transition->SetDelay(0.0);
+          break;
+        default:
+          NS_NOTREACHED("Invalid delay unit");
+      }
+      // if we're at the end of the list, start at the beginning and repeat
+      // until we're out of transitions to populate
+      delayList = delayList->mNext ? delayList->mNext :
+        displayData.mTransitionDelay;
+    }
+
+    if (durationInherited) {
+      if (inheritedTransition)
+        transition->SetDuration(inheritedTransition->GetDuration(),
+                                inheritedExplicit && 
+                                inheritedTransition->GetDurationExplicit());
+    } else if (durationList) {
+      switch (durationList->mValue.GetUnit()) {
+        case eCSSUnit_Seconds:
+          transition->SetDuration(PR_MSEC_PER_SEC *
+                                  durationList->mValue.GetFloatValue(), (numDurations-- > 0));
+          break;
+        case eCSSUnit_Milliseconds:
+          transition->SetDuration(durationList->mValue.GetFloatValue(), (numDurations-- > 0));
+          break;
+        case eCSSUnit_Initial:
+          transition->SetDuration(0.0);
+          break;
+        default:
+          NS_NOTREACHED("Invalid duration unit");
+      }
+      // repeat from the beginning if we reach the end
+      durationList = durationList->mNext ? durationList->mNext :
+        displayData.mTransitionDuration;
+    }
+
+    if (propertyInherited) {
+      if (inheritedTransition) {
+        if (inheritedTransition->IsPropertyAll())
+          transition->SetPropertyAll(inheritedExplicit &&
+                                     inheritedTransition->GetPropertyExplicit());
+        if (inheritedTransition->IsPropertyNone())
+          transition->SetPropertyNone(inheritedExplicit &&
+                                      inheritedTransition->GetPropertyExplicit());
+        else
+          transition->SetProperty(inheritedTransition->GetProperty(),
+                                  inheritedExplicit &&
+                                  inheritedTransition->GetPropertyExplicit());
+      }
+    } else if (propertyList) {
+      switch (propertyList->mValue.GetUnit()) {
+        case eCSSUnit_Enumerated:
+          transition->SetProperty((nsCSSProperty)
+                                  propertyList->mValue.GetIntValue(),
+                                  (numProperties-- > 0));
+          break;
+        case eCSSUnit_All:
+        case eCSSUnit_Initial:
+          transition->SetPropertyAll((numProperties-- > 0));
+          break;
+        case eCSSUnit_None:
+          transition->SetPropertyNone((numProperties-- > 0));
+          break;
+        default:
+          NS_NOTREACHED("Invalid transition property unit");
+      }
+      // repeat from the beginning if we reach the end
+      propertyList = propertyList->mNext ? propertyList->mNext :
+        displayData.mTransitionProperty;
+    }
+
+    if (timingFunctionInherited) {
+      if (inheritedTransition)
+        transition->SetTimingFunction(inheritedTransition->GetTimingFunction(),
+                                      inheritedTransition->GetTimingFunctionExplicit());
+    } else if (functionList) {
+      switch (functionList->mValue.GetUnit()) {
+        case eCSSUnit_Enumerated:
+          transition->SetTimingFunction(nsTimingFunction(functionList->mValue.GetIntValue()));
+          functionList = functionList->mNext;
+          break;
+        case eCSSUnit_Cubic_Bezier:
+          {
+            nsCSSValue::Array* array = functionList->mValue.GetArrayValue();
+            NS_ASSERTION(array && array->Count() == 4, "Need 4 control points");
+            transition->SetTimingFunction(nsTimingFunction(array->Item(0).GetFloatValue(),
+                                                           array->Item(1).GetFloatValue(),
+                                                           array->Item(2).GetFloatValue(),
+                                                           array->Item(3).GetFloatValue()),
+                                          (numTimingFuncs-- > 0));
+            // repeat from the beginning if we reach the end
+            functionList = functionList->mNext ? functionList->mNext :
+              displayData.mTransitionTimingFunction;
+          }
+          break;
+        case eCSSUnit_Initial:
+          transition->SetTimingFunction(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE);
+          break;
+        default:
+          NS_NOTREACHED("Invalid transition property unit");
+      }
+    }
+    // advance to the next inherited transition or cycle back to the beginning
+    if (inheritedTransition) {
+      inheritedTransition = inheritedTransition->mNext;
+      if (!inheritedTransition) {
+        inheritedTransition = parentDisplay->mTransitions;
+        inheritedExplicit = PR_FALSE;
+      }
+    }
+    transition = transition->mNext;
+  }
+  
   // opacity: factor, inherit, initial
   SetFactor(displayData.mOpacity, display->mOpacity, canStoreInRuleTree,
             parentDisplay->mOpacity, 1.0f, SETFCT_OPACITY);
 
   // display: enum, none, inherit, initial
   SetDiscrete(displayData.mDisplay, display->mDisplay, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_NONE, parentDisplay->mDisplay,
               NS_STYLE_DISPLAY_INLINE, 0,
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -18,16 +18,17 @@
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   David Hyatt (hyatt@netscape.com)
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   Michael Ventnor <m.ventnor@gmail.com>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -1330,16 +1331,131 @@ PRBool nsStyleBackground::Layer::operato
          mRepeat == aOther.mRepeat &&
          mPosition == aOther.mPosition &&
          EqualImages(mImage, aOther.mImage);
 }
 
 // --------------------
 // nsStyleDisplay
 //
+void nsTimingFunction::AssignFromKeyword(PRInt32 aTimingFunctionType) {
+    mTimingFunctionType = aTimingFunctionType;
+    switch (aTimingFunctionType) {
+      case NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE:
+        mX1 = 0.25;
+        mY1 = 0.10;
+        mX2 = 0.25;
+        mY2 = 1.0;
+        break;
+      case NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN:
+        mX1 = 0.42;
+        mY1 = 0.0;
+        mX2 = 1.0;
+        mY2 = 1.0;
+        break;
+      case NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_OUT:
+        mX1 = 0.0;
+        mY1 = 0.0;
+        mX2 = 0.58;
+        mY2 = 1.0;
+        break;
+      case NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE_IN_OUT:
+        mX1 = 0.42;
+        mY1 = 0.0;
+        mX2 = 0.58;
+        mY2 = 1.0;
+        break;
+      case  NS_STYLE_TRANSITION_TIMING_FUNCTION_LINEAR:
+        mX1 = 0.0;
+        mY1 = 0.0;
+        mX2 = 1.0;
+        mY2 = 1.0;
+        break;
+      default:
+        NS_NOTREACHED("Invalid timing function type");
+        // just initialize to 'ease', which is the default
+        mX1 = 0.25;
+        mY1 = 0.1;
+        mX2 = 0.25;
+        mY2 = 1.0;
+        break;
+    }
+}
+
+nsTransition::nsTransition() :
+  mNext(nsnull)
+  , mTimingFunction(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE)
+  , mDuration(0.0)
+  , mDelay(0.0)
+  , mProperty(eCSSProperty_UNKNOWN)
+  , mPropertyNone(PR_FALSE)
+  , mPropertyAll(PR_TRUE)
+  , mPropertyExplicit(PR_FALSE)
+  , mDelayExplicit(PR_FALSE)
+  , mDurationExplicit(PR_FALSE)
+  , mTimingFunctionExplicit(PR_FALSE)
+{
+}
+
+nsTransition::nsTransition(nsTransition& aCopy) :
+  mNext(aCopy.mNext ? new nsTransition(*aCopy.mNext) : nsnull)
+  , mTimingFunction(aCopy.mTimingFunction)
+  , mDuration(aCopy.mDuration)
+  , mDelay(aCopy.mDelay)
+  , mProperty(aCopy.mProperty)
+  , mPropertyNone(aCopy.mPropertyNone)
+  , mPropertyAll(aCopy.mPropertyAll)
+  , mPropertyExplicit(aCopy.mPropertyExplicit)
+  , mDelayExplicit(aCopy.mDelayExplicit)
+  , mDurationExplicit(aCopy.mDurationExplicit)
+  , mTimingFunctionExplicit(aCopy.mTimingFunctionExplicit)
+{
+}
+
+void nsTransition::SetTimingFunction(nsTimingFunction aTimingFunction, PRBool aExplicit)
+{
+  mTimingFunction = aTimingFunction;
+  mTimingFunctionExplicit = aExplicit;
+}
+
+void nsTransition::SetDelay(float aDelay, PRBool aExplicit)
+{
+  mDelay = aDelay;
+  mDelayExplicit = aExplicit;
+}
+
+void nsTransition::SetDuration(float aDuration, PRBool aExplicit)
+{
+  mDuration = aDuration;
+  mDurationExplicit = aExplicit;
+}
+
+void nsTransition::SetProperty(nsCSSProperty aProperty, PRBool aExplicit)
+{
+  NS_ASSERTION(aProperty != eCSSProperty_UNKNOWN, "invalid property");
+  mProperty = aProperty;
+  mPropertyNone = PR_FALSE;
+  mPropertyAll = PR_FALSE;
+  mPropertyExplicit = aExplicit;
+}
+
+void nsTransition::SetPropertyNone(PRBool aExplicit) {
+  mPropertyNone = PR_TRUE;
+  mPropertyAll = PR_FALSE;
+  mProperty = eCSSProperty_UNKNOWN;
+  mPropertyExplicit = aExplicit;
+}
+
+void nsTransition::SetPropertyAll(PRBool aExplicit) {
+  mPropertyNone = PR_FALSE;
+  mPropertyAll = PR_TRUE;
+  mProperty = eCSSProperty_UNKNOWN;
+  mPropertyExplicit = aExplicit;
+}
+
 
 nsStyleDisplay::nsStyleDisplay()
 {
   mAppearance = NS_THEME_NONE;
   mDisplay = NS_STYLE_DISPLAY_INLINE;
   mOriginalDisplay = NS_STYLE_DISPLAY_NONE;
   mPosition = NS_STYLE_POSITION_STATIC;
   mFloats = NS_STYLE_FLOAT_NONE;
@@ -1349,16 +1465,17 @@ nsStyleDisplay::nsStyleDisplay()
   mOverflowX = NS_STYLE_OVERFLOW_VISIBLE;
   mOverflowY = NS_STYLE_OVERFLOW_VISIBLE;
   mClipFlags = NS_STYLE_CLIP_AUTO;
   mClip.SetRect(0,0,0,0);
   mOpacity = 1.0f;
   mTransformPresent = PR_FALSE; // No transform
   mTransformOrigin[0].SetPercentValue(0.5f); // Transform is centered on origin
   mTransformOrigin[1].SetPercentValue(0.5f); 
+  mTransitions = nsnull;
 }
 
 nsStyleDisplay::nsStyleDisplay(const nsStyleDisplay& aSource)
 {
   mAppearance = aSource.mAppearance;
   mDisplay = aSource.mDisplay;
   mOriginalDisplay = aSource.mOriginalDisplay;
   mBinding = aSource.mBinding;
@@ -1376,16 +1493,30 @@ nsStyleDisplay::nsStyleDisplay(const nsS
   /* Copy over the transformation information. */
   mTransformPresent = aSource.mTransformPresent;
   if (mTransformPresent)
     mTransform = aSource.mTransform;
   
   /* Copy over transform origin. */
   mTransformOrigin[0] = aSource.mTransformOrigin[0];
   mTransformOrigin[1] = aSource.mTransformOrigin[1];
+
+  mTransitions = nsnull;
+  // copy transition list
+  nsTransition* transition = aSource.mTransitions;
+  nsTransition** tail = &mTransitions;
+  while (transition) {
+    if (!*tail)
+      *tail = new nsTransition(*transition);
+    else {
+      (*tail)->mNext = new nsTransition(*transition);
+      *tail = (*tail)->mNext;
+    }
+    transition = transition->mNext;
+  }
 }
 
 nsChangeHint nsStyleDisplay::CalcDifference(const nsStyleDisplay& aOther) const
 {
   nsChangeHint hint = nsChangeHint(0);
 
   if (!EqualURIs(mBinding, aOther.mBinding)
       || mPosition != aOther.mPosition
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -18,16 +18,17 @@
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Mats Palmgren <mats.palmgren@bredband.net>
  *   Masayuki Nakano <masayuki@d-toybox.com>
  *   Rob Arnold <robarnold@mozilla.com>
+ *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -905,16 +906,98 @@ struct nsStyleVisibility {
   }
 
   PRBool IsVisibleOrCollapsed() const {
     return ((mVisible == NS_STYLE_VISIBILITY_VISIBLE) ||
             (mVisible == NS_STYLE_VISIBILITY_COLLAPSE));
   }
 };
 
+struct nsTimingFunction {
+  nsTimingFunction(PRInt32 aTimingFunctionType=NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE)
+  {
+    AssignFromKeyword(aTimingFunctionType);
+  }
+
+  nsTimingFunction(float x1, float y1, float x2, float y2) :
+    mX1(x1)
+    , mY1(y1)
+    , mX2(x2)
+    , mY2(y2)
+    , mTimingFunctionType(-1)
+  {}
+
+  float mX1;
+  float mY1;
+  float mX2;
+  float mY2;
+  PRInt32 mTimingFunctionType;
+
+  PRBool operator==(const nsTimingFunction& aOther) const
+  {
+    return !(*this != aOther);
+  }
+
+  PRBool operator!=(const nsTimingFunction& aOther) const
+  {
+    return ((mX1 != mX1) ||
+            (mY1 != mY1) ||
+            (mX2 != mX2) ||
+            (mY2 != mY2));
+  }
+private:
+  void AssignFromKeyword(PRInt32 aTimingFunctionType);
+};
+
+struct nsTransition {
+  nsTransition();
+  explicit nsTransition(nsTransition& aCopy);
+public:
+  nsTimingFunction& GetTimingFunction() { return mTimingFunction; }
+  const nsTimingFunction& GetTimingFunction() const { return mTimingFunction; }
+  float GetDelay() const { return mDelay; }
+  float GetDuration() const { return mDuration; }
+  nsCSSProperty GetProperty() const { return mProperty; }
+  PRBool IsPropertyNone() const { return mPropertyNone; }
+  PRBool IsPropertyAll() const { return mPropertyAll; }
+
+  void SetTimingFunction(nsTimingFunction aTimingFunction, PRBool aExplicit=PR_TRUE);
+  void SetDelay(float aDelay, PRBool aExplicit=PR_TRUE);
+  void SetDuration(float aDuration, PRBool aExplicit=PR_TRUE);
+  void SetProperty(nsCSSProperty aProperty, PRBool aExplicit=PR_TRUE);
+  void SetPropertyNone(PRBool aExplicit=PR_TRUE);
+  void SetPropertyAll(PRBool aExplicit=PR_TRUE);
+
+  // check whether the property was specified explicitly or filled in
+  // automatically
+  inline PRBool GetPropertyExplicit() const { return mPropertyExplicit; }
+  inline PRBool GetDelayExplicit() const { return mDelayExplicit; }
+  inline PRBool GetDurationExplicit() const { return mDurationExplicit; }
+  inline PRBool GetTimingFunctionExplicit() const { return mTimingFunctionExplicit; }
+
+  // linked list
+  nsTransition* mNext;
+
+private:
+  nsTimingFunction mTimingFunction;
+  float mDuration;
+  float mDelay;
+  nsCSSProperty mProperty;
+  PRBool mPropertyNone;
+  PRBool mPropertyAll;
+
+  // bits that specify whether the given transition sub-properties were
+  // explicitly specified or whether they were inherited or filled in from
+  // repetition
+  PRBool mPropertyExplicit;
+  PRBool mDelayExplicit;
+  PRBool mDurationExplicit;
+  PRBool mTimingFunctionExplicit;
+};
+
 struct nsStyleDisplay {
   nsStyleDisplay();
   nsStyleDisplay(const nsStyleDisplay& aOther); 
   ~nsStyleDisplay() {}
 
   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
     return aContext->AllocateFromShell(sz);
   }
@@ -946,16 +1029,17 @@ struct nsStyleDisplay {
   PRUint8 mPosition;            // [reset] see nsStyleConsts.h
   PRUint8 mFloats;              // [reset] see nsStyleConsts.h NS_STYLE_FLOAT_*
   PRUint8 mBreakType;           // [reset] see nsStyleConsts.h NS_STYLE_CLEAR_*
   PRPackedBool mBreakBefore;    // [reset] 
   PRPackedBool mBreakAfter;     // [reset] 
   PRUint8 mOverflowX;           // [reset] see nsStyleConsts.h
   PRUint8 mOverflowY;           // [reset] see nsStyleConsts.h
   PRUint8   mClipFlags;         // [reset] see nsStyleConsts.h
+  nsTransition* mTransitions;   // [reset]
   PRPackedBool mTransformPresent;  // [reset] Whether there is a -moz-transform.
   nsStyleTransformMatrix mTransform; // [reset] The stored transform matrix
   nsStyleCoord mTransformOrigin[2]; // [reset] percent, coord.
 
   PRBool IsBlockInside() const {
     return NS_STYLE_DISPLAY_BLOCK == mDisplay ||
            NS_STYLE_DISPLAY_LIST_ITEM == mDisplay ||
            NS_STYLE_DISPLAY_INLINE_BLOCK == mDisplay;
diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -123,16 +123,17 @@ _TEST_FILES =	test_acid3_test46.html \
 		test_property_database.html \
 		test_priority_preservation.html \
 		test_property_syntax_errors.html \
 		test_selectors.html \
 		test_selectors_on_anonymous_content.html \
 		test_shorthand_property_getters.html \
 		test_style_struct_copy_constructors.html \
 		test_system_font_serialization.html \
+		test_transitions_computed_values.html \
 		test_units_angle.html \
 		test_units_frequency.html \
 		test_units_length.html \
 		test_units_time.html \
 		test_value_computation.html \
 		test_value_storage.html \
 		test_visited_pref.html \
 		css_properties.js \
diff --git a/layout/style/test/property_database.js b/layout/style/test/property_database.js
--- a/layout/style/test/property_database.js
+++ b/layout/style/test/property_database.js
@@ -1698,16 +1698,57 @@ var gCSSProperties = {
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		/* XXX requires position to be set */
 		/* XXX 0 may or may not be equal to auto */
 		initial_values: [ "auto" ],
 		other_values: [ "32px", "-3em", "12%" ],
 		invalid_values: []
 	},
+	"-moz-transition-delay": {
+		domProp: "MozTransitionDelay",
+		inherited: false,
+		type: CSS_TYPE_LONGHAND,
+		initial_values: [ "0", "0s", "0ms" ],
+		other_values: [ "1s", "250ms", "-100ms", "-1s", "1s, 250ms, 2.3s"],
+		invalid_values: []
+	},
+	"-moz-transition-duration": {
+		domProp: "MozTransitionDuration",
+		inherited: false,
+		type: CSS_TYPE_LONGHAND,
+		initial_values: [ "0", "0s", "0ms" ],
+		other_values: [ "1s", "250ms", "-1ms", "-2s", "1s, 250ms, 2.3s"],
+		invalid_values: []
+	},
+	"-moz-transition-property": {
+		domProp: "MozTransitionProperty",
+		inherited: false,
+		type: CSS_TYPE_LONGHAND,
+		initial_values: [ "all" ],
+		other_values: [ "none", "left", "top", "color", "width, height, opacity" ],
+		invalid_values: [ "auto" ]
+	},
+	"-moz-transition-timing-function": {
+		domProp: "MozTransitionTimingFunction",
+		inherited: false,
+		type: CSS_TYPE_LONGHAND,
+		initial_values: [ "ease" ],
+		other_values: [ "linear", "ease-in", "ease-out", "ease-in-out", "cubic-bezier(0.25, 0.1, 0.25, 1.0)", "linear, ease-in, cubic-bezier(0.1, 0.2, 0.8, 0.9)" ],
+		invalid_values: [ "none", "auto" ]
+	},
+	"-moz-transition": {
+		domProp: "MozTransition",
+		inherited: false,
+		type: CSS_TYPE_TRUE_SHORTHAND,
+		subproperties: [ "-moz-transition-property", "-moz-transition-duration", "-moz-transition-timing-function", "-moz-transition-delay" ],
+		initial_values: [ "all 0s ease 0s" ],
+		other_values: [ "width 1s linear 2s", "height", "2s", "ease-in-out", "2s ease-in", "opacity linear", "ease-out 2s", "2s, 1s width, 500ms height linear, 1s opacity 4s cubic-bezier(0.0, 0.1, 1.0, 1.0)" ],
+		invalid_values: [ ]
+	},
 	"unicode-bidi": {
 		domProp: "unicodeBidi",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "normal" ],
 		other_values: [ "embed", "bidi-override" ],
 		invalid_values: [ "auto", "none" ]
 	},
diff --git a/layout/style/test/test_transitions_computed_values.html b/layout/style/test/test_transitions_computed_values.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_transitions_computed_values.html
@@ -0,0 +1,78 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=435441
+-->
+<head>
+  <title>Test for Bug 435441</title>
+  <script type="application/javascript" src="/MochiKit/packed.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=435441">Mozilla Bug 435441</a>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 435441 **/
+
+
+/*
+ * test that when transition properties are inherited, the length of the
+ * computed value stays the same
+ */
+
+var p = document.getElementById("content");
+var c = document.createElement("div");
+p.appendChild(c);
+var cs = getComputedStyle(c, "");
+
+p.style.MozTransitionProperty = "margin-left, margin-right";
+c.style.MozTransitionProperty = "inherit";
+is(cs.MozTransitionProperty, "margin-left, margin-right",
+   "computed style match with no other properties");
+c.style.MozTransitionDuration = "5s";
+is(cs.MozTransitionProperty, "margin-left, margin-right",
+   "computed style match with shorter property");
+is(cs.MozTransitionDuration, "5s",
+   "shorter property not extended");
+c.style.MozTransitionDuration = "5s, 4s, 3s, 2000ms";
+is(cs.MozTransitionProperty, "margin-left, margin-right",
+   "computed style match with longer property");
+is(cs.MozTransitionDuration, "5s, 4s, 3s, 2s",
+   "longer property computed correctly");
+p.style.MozTransitionProperty = "";
+c.style.MozTransitionProperty = "";
+c.style.MozTransitionDuration = "";
+
+// and repeat the above set of tests with property and duration swapped
+p.style.MozTransitionDuration = "5s, 4s";
+c.style.MozTransitionDuration = "inherit";
+is(cs.MozTransitionDuration, "5s, 4s",
+   "computed style match with no other properties");
+c.style.MozTransitionProperty = "margin-left";
+is(cs.MozTransitionDuration, "5s, 4s",
+   "computed style match with shorter property");
+is(cs.MozTransitionProperty, "margin-left",
+   "shorter property not extended");
+c.style.MozTransitionProperty =
+  "margin-left, margin-right, margin-top, margin-bottom";
+is(cs.MozTransitionDuration, "5s, 4s",
+   "computed style match with longer property");
+is(cs.MozTransitionProperty,
+   "margin-left, margin-right, margin-top, margin-bottom",
+   "longer property computed correctly");
+p.style.MozTransitionDuration = "";
+c.style.MozTransitionDuration = "";
+c.style.MozTransitionProperty = "";
+
+// FIXME: Given the structure of the code, we really need to test all
+// four properties here.
+
+</script>
+</pre>
+</body>
+</html>
