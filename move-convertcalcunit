From: L. David Baron <dbaron@dbaron.org>

Move ConvertCalcUnit to CSSCalc.h.  (Bug 363249)

diff --git a/layout/style/CSSCalc.h b/layout/style/CSSCalc.h
--- a/layout/style/CSSCalc.h
+++ b/layout/style/CSSCalc.h
@@ -249,13 +249,44 @@ struct NumbersAlreadyNormalizedOps : pub
 {
   float ComputeNumber(const nsCSSValue& aValue)
   {
     NS_ABORT_IF_FALSE(aValue.GetUnit() == eCSSUnit_Number, "unexpected unit");
     return aValue.GetFloatValue();
   }
 };
 
+#define CHECK_UNIT(u_)                                                        \
+  PR_STATIC_ASSERT(int(eCSSUnit_Calc_##u_) + 14 == int(eStyleUnit_Calc_##u_));\
+  PR_STATIC_ASSERT(eCSSUnit_Calc_##u_ >= eCSSUnit_Calc_Plus);                 \
+  PR_STATIC_ASSERT(eCSSUnit_Calc_##u_ <= eCSSUnit_Calc_Maximum);
+
+CHECK_UNIT(Plus)
+CHECK_UNIT(Minus)
+CHECK_UNIT(Times_L)
+CHECK_UNIT(Times_R)
+CHECK_UNIT(Divided)
+CHECK_UNIT(Minimum)
+CHECK_UNIT(Maximum)
+
+#undef CHECK_UNIT
+
+inline nsStyleUnit
+ConvertCalcUnit(nsCSSUnit aUnit)
+{
+  NS_ABORT_IF_FALSE(eCSSUnit_Calc_Plus <= aUnit &&
+                    aUnit <= eCSSUnit_Calc_Maximum, "out of range");
+  return nsStyleUnit(aUnit + 14);
+}
+
+inline nsCSSUnit
+ConvertCalcUnit(nsStyleUnit aUnit)
+{
+  NS_ABORT_IF_FALSE(eStyleUnit_Calc_Plus <= aUnit &&
+                    aUnit <= eStyleUnit_Calc_Maximum, "out of range");
+  return nsCSSUnit(aUnit - 14);
+}
+
 }
 
 }
 
 #endif /* !defined(CSSCalc_h_) */
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -78,16 +78,17 @@
 #include "nsCSSProps.h"
 #include "nsTArray.h"
 #include "nsContentUtils.h"
 #include "mozilla/dom/Element.h"
 #include "CSSCalc.h"
 #include "prlog.h" // for PR_STATIC_ASSERT
 
 using namespace mozilla::dom;
+namespace css = mozilla::css;
 
 #define NS_SET_IMAGE_REQUEST(method_, context_, request_)                   \
   if ((context_)->PresContext()->IsDynamic()) {                               \
     method_(request_);                                                      \
   } else {                                                                  \
     nsCOMPtr<imgIRequest> req = nsContentUtils::GetStaticRequest(request_); \
     method_(req);                                                           \
   }
@@ -175,18 +176,18 @@ static nscoord CalcLengthWith(const nsCS
                               nscoord aFontSize,
                               const nsStyleFont* aStyleFont,
                               nsStyleContext* aStyleContext,
                               nsPresContext* aPresContext,
                               PRBool aUseProvidedRootEmSize,
                               PRBool aUseUserFontSet,
                               PRBool& aCanStoreInRuleTree);
 
-struct CalcLengthCalcOps : public mozilla::css::BasicCoordCalcOps,
-                           public mozilla::css::NumbersAlreadyNormalizedOps
+struct CalcLengthCalcOps : public css::BasicCoordCalcOps,
+                           public css::NumbersAlreadyNormalizedOps
 {
   // All of the parameters to CalcLengthWith except aValue.
   const nscoord mFontSize;
   const nsStyleFont* const mStyleFont;
   nsStyleContext* const mStyleContext;
   nsPresContext* const mPresContext;
   const PRBool mUseProvidedRootEmSize;
   const PRBool mUseUserFontSet;
@@ -323,17 +324,17 @@ static nscoord CalcLengthWith(const nsCS
     case eCSSUnit_Calc_Times_L:
     case eCSSUnit_Calc_Times_R:
     case eCSSUnit_Calc_Divided:
     case eCSSUnit_Calc_Minimum:
     case eCSSUnit_Calc_Maximum: {
       CalcLengthCalcOps ops(aFontSize, aStyleFont, aStyleContext, aPresContext,
                             aUseProvidedRootEmSize, aUseUserFontSet,
                             aCanStoreInRuleTree);
-      return mozilla::css::ComputeCalc(aValue, ops);
+      return css::ComputeCalc(aValue, ops);
     }
     default:
       NS_NOTREACHED("unexpected unit");
       break;
   }
   return 0;
 }
 
@@ -364,48 +365,18 @@ nsRuleNode::CalcLengthWithInitialFont(ns
                                       const nsCSSValue& aValue)
 {
   nsStyleFont defaultFont(aPresContext);
   PRBool canStoreInRuleTree;
   return CalcLengthWith(aValue, -1, &defaultFont, nsnull, aPresContext,
                         PR_TRUE, PR_FALSE, canStoreInRuleTree);
 }
 
-#define CHECK_UNIT(u_)                                                        \
-  PR_STATIC_ASSERT(int(eCSSUnit_Calc_##u_) + 14 == int(eStyleUnit_Calc_##u_));\
-  PR_STATIC_ASSERT(eCSSUnit_Calc_##u_ >= eCSSUnit_Calc_Plus);                 \
-  PR_STATIC_ASSERT(eCSSUnit_Calc_##u_ <= eCSSUnit_Calc_Maximum);
-
-CHECK_UNIT(Plus)
-CHECK_UNIT(Minus)
-CHECK_UNIT(Times_L)
-CHECK_UNIT(Times_R)
-CHECK_UNIT(Divided)
-CHECK_UNIT(Minimum)
-CHECK_UNIT(Maximum)
-
-inline nsStyleUnit
-ConvertCalcUnit(nsCSSUnit aUnit)
-{
-  NS_ABORT_IF_FALSE(eCSSUnit_Calc_Plus <= aUnit &&
-                    aUnit <= eCSSUnit_Calc_Maximum, "out of range");
-  return nsStyleUnit(aUnit + 14);
-}
-
-inline nsCSSUnit
-ConvertCalcUnit(nsStyleUnit aUnit)
-{
-  NS_ABORT_IF_FALSE(eStyleUnit_Calc_Plus <= aUnit &&
-                    aUnit <= eStyleUnit_Calc_Maximum, "out of range");
-  return nsCSSUnit(aUnit - 14);
-}
-
 // FIXME: Need to clamp nscoords resulting from arithmetic ops.
-struct SpecifiedToComputedCalcOps :
-           public mozilla::css::NumbersAlreadyNormalizedOps
+struct SpecifiedToComputedCalcOps : public css::NumbersAlreadyNormalizedOps
 {
   // FIXME (perf): Is there too much copying as a result of returning
   // nsStyleCoord objects?
   typedef nsStyleCoord result_type;
 
   nsStyleContext* const mStyleContext;
   nsPresContext* const mPresContext;
   PRBool& mCanStoreInRuleTree;
@@ -432,91 +403,91 @@ struct SpecifiedToComputedCalcOps :
     NS_ABORT_IF_FALSE(unit2 == eStyleUnit_Coord ||
                       unit2 == eStyleUnit_Percent ||
                       aValue2.IsCalcUnit(),
                       "unexpected unit");
     nsStyleCoord result;
     if (unit1 == unit2 && !aValue1.IsCalcUnit()) {
       // Merge nodes that we don't need to keep separate.
       if (unit1 == eStyleUnit_Percent) {
-        mozilla::css::BasicFloatCalcOps ops;
+        css::BasicFloatCalcOps ops;
         result.SetPercentValue(ops.MergeAdditive(aCalcFunction,
                                                  aValue1.GetPercentValue(),
                                                  aValue2.GetPercentValue()));
       } else {
-        mozilla::css::BasicCoordCalcOps ops;
+        css::BasicCoordCalcOps ops;
         result.SetCoordValue(ops.MergeAdditive(aCalcFunction,
                                                aValue1.GetCoordValue(),
                                                aValue2.GetCoordValue()));
       }
     } else {
       nsStyleCoord::Array *array =
         nsStyleCoord::Array::Create(mStyleContext, 2);
       array->Item(0) = aValue1;
       array->Item(1) = aValue2;
-      result.SetArrayValue(array, ConvertCalcUnit(aCalcFunction));
+      result.SetArrayValue(array, css::ConvertCalcUnit(aCalcFunction));
     }
     return result;
   }
 
   result_type
   MergeMultiplicativeL(nsCSSUnit aCalcFunction,
                        float aValue1, result_type aValue2)
   {
     nsStyleCoord result;
     switch (aValue2.GetUnit()) {
       case eStyleUnit_Percent: {
-        mozilla::css::BasicFloatCalcOps ops;
+        css::BasicFloatCalcOps ops;
         result.SetPercentValue(ops.MergeMultiplicativeL(
           aCalcFunction, aValue1, aValue2.GetPercentValue()));
         break;
       }
       case eStyleUnit_Coord: {
-        mozilla::css::BasicCoordCalcOps ops;
+        css::BasicCoordCalcOps ops;
         result.SetCoordValue(ops.MergeMultiplicativeL(
           aCalcFunction, aValue1, aValue2.GetCoordValue()));
         break;
       }
       default:
         NS_ABORT_IF_FALSE(aValue2.IsCalcUnit(), "unexpected unit");
         nsStyleCoord::Array *array =
           nsStyleCoord::Array::Create(mStyleContext, 2);
         array->Item(0).SetFactorValue(aValue1);
         array->Item(1) = aValue2;
-        result.SetArrayValue(array, ConvertCalcUnit(aCalcFunction));
+        result.SetArrayValue(array, css::ConvertCalcUnit(aCalcFunction));
         break;
     }
     return result;
   }
 
   result_type
   MergeMultiplicativeR(nsCSSUnit aCalcFunction,
                        result_type aValue1, float aValue2)
   {
     nsStyleCoord result;
     switch (aValue1.GetUnit()) {
       case eStyleUnit_Percent: {
-        mozilla::css::BasicFloatCalcOps ops;
+        css::BasicFloatCalcOps ops;
         result.SetPercentValue(ops.MergeMultiplicativeR(
           aCalcFunction, aValue1.GetPercentValue(), aValue2));
         break;
       }
       case eStyleUnit_Coord: {
-        mozilla::css::BasicCoordCalcOps ops;
+        css::BasicCoordCalcOps ops;
         result.SetCoordValue(ops.MergeMultiplicativeR(
           aCalcFunction, aValue1.GetCoordValue(), aValue2));
         break;
       }
       default:
         NS_ABORT_IF_FALSE(aValue1.IsCalcUnit(), "unexpected unit");
         nsStyleCoord::Array *array =
           nsStyleCoord::Array::Create(mStyleContext, 2);
         array->Item(0) = aValue1;
         array->Item(1).SetFactorValue(aValue2);
-        result.SetArrayValue(array, ConvertCalcUnit(aCalcFunction));
+        result.SetArrayValue(array, css::ConvertCalcUnit(aCalcFunction));
         break;
     }
     return result;
   }
 
   result_type ComputeLeafValue(const nsCSSValue& aValue)
   {
     nsStyleCoord result;
@@ -537,24 +508,24 @@ SpecifiedCalcToComputedCalc(const nsCSSV
 {
   SpecifiedToComputedCalcOps ops(aStyleContext, aStyleContext->PresContext(),
                                  aCanStoreInRuleTree);
   aCoord = ComputeCalc(aValue, ops);
 }
 
 // FIXME: Need to clamp nscoords resulting from arithmetic ops.
 struct ComputeComputedCalcCalcOps :
-           public mozilla::css::BasicCoordCalcOps
+           public css::BasicCoordCalcOps
 {
   typedef nsStyleCoord input_type;
   typedef nsStyleCoord::Array input_array_type;
 
   static nsCSSUnit GetUnit(const nsStyleCoord& aValue)
   {
-    return ConvertCalcUnit(aValue.GetUnit());
+    return css::ConvertCalcUnit(aValue.GetUnit());
   }
 
   const nscoord mPercentageBasis;
 
   ComputeComputedCalcCalcOps(nscoord aPercentageBasis)
     : mPercentageBasis(aPercentageBasis)
   {
   }
@@ -581,17 +552,17 @@ struct ComputeComputedCalcCalcOps :
 
 // This is our public API for handling calc() expressions that involve
 // percentages.
 /* static */ nscoord
 nsRuleNode::ComputeComputedCalc(const nsStyleCoord& aValue,
                                 nscoord aPercentageBasis)
 {
   ComputeComputedCalcCalcOps ops(aPercentageBasis);
-  return mozilla::css::ComputeCalc(aValue, ops);
+  return css::ComputeCalc(aValue, ops);
 }
 
 /* static */ nscoord
 nsRuleNode::ComputeCoordPercentCalc(const nsStyleCoord& aCoord,
                                     nscoord aPercentageBasis)
 {
   switch (aCoord.GetUnit()) {
     case eStyleUnit_Coord:
@@ -2630,17 +2601,17 @@ nsRuleNode::SetDefaultOnRoot(const nsSty
  * input).
  */
 void
 nsRuleNode::AdjustLogicalBoxProp(nsStyleContext* aContext,
                                  const nsCSSValue& aLTRSource,
                                  const nsCSSValue& aRTLSource,
                                  const nsCSSValue& aLTRLogicalValue,
                                  const nsCSSValue& aRTLLogicalValue,
-                                 mozilla::css::Side aSide,
+                                 css::Side aSide,
                                  nsCSSRect& aValueRect,
                                  PRBool& aCanStoreInRuleTree)
 {
   PRBool LTRlogical = aLTRSource.GetUnit() == eCSSUnit_Enumerated &&
                       aLTRSource.GetIntValue() == NS_BOXPROP_SOURCE_LOGICAL;
   PRBool RTLlogical = aRTLSource.GetUnit() == eCSSUnit_Enumerated &&
                       aRTLSource.GetIntValue() == NS_BOXPROP_SOURCE_LOGICAL;
   if (LTRlogical || RTLlogical) {
@@ -2900,18 +2871,18 @@ ComputeScriptLevelSize(const nsStyleFont
     // scriptminsize can only make sizes larger than the unconstrained size
     NS_ASSERTION(*aUnconstrainedSize <= scriptLevelSize, "How can this ever happen?");
     // Apply constraint #2
     return NS_MIN(scriptLevelSize, NS_MAX(*aUnconstrainedSize, minScriptSize));
   }
 }
 #endif
 
-struct SetFontSizeCalcOps : public mozilla::css::BasicCoordCalcOps,
-                            public mozilla::css::NumbersAlreadyNormalizedOps
+struct SetFontSizeCalcOps : public css::BasicCoordCalcOps,
+                            public css::NumbersAlreadyNormalizedOps
 {
   // The parameters beyond aValue that we need for CalcLengthWith.
   const nscoord mParentSize;
   const nsStyleFont* const mParentFont;
   nsPresContext* const mPresContext;
   const PRBool mAtRoot;
   PRBool& mCanStoreInRuleTree;
 
@@ -3017,17 +2988,17 @@ nsRuleNode::SetFontSize(nsPresContext* a
       NS_NOTREACHED("unexpected value");
     }
   }
   else if (aFontData.mSize.IsLengthUnit() ||
            aFontData.mSize.GetUnit() == eCSSUnit_Percent ||
            aFontData.mSize.IsCalcUnit()) {
     SetFontSizeCalcOps ops(aParentSize, aParentFont, aPresContext, aAtRoot,
                            aCanStoreInRuleTree);
-    *aSize = mozilla::css::ComputeCalc(aFontData.mSize, ops);
+    *aSize = css::ComputeCalc(aFontData.mSize, ops);
     if (*aSize < 0) {
       NS_ABORT_IF_FALSE(aFontData.mSize.IsCalcUnit(),
                         "negative lengths and percents should be rejected "
                         "by parser");
       *aSize = 0;
     }
     // Zoom is handled inside the calc ops when needed.
     zoom = PR_FALSE;
