From: L. David Baron <dbaron@dbaron.org>

Ignore changes to offsets of static-positioned elements when they or their descendants have views.

We get slightly better optimization, and no loss of function, by putting
these checks in the opposite order.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -303,31 +303,31 @@ RestyleManager::RecomputePosition(nsIFra
 {
   // Don't process position changes on table frames, since we already handle
   // the dynamic position change on the outer table frame, and the reflow-based
   // fallback code path also ignores positions on inner table frames.
   if (aFrame->GetType() == nsGkAtoms::tableFrame) {
     return true;
   }
 
+  const nsStyleDisplay* display = aFrame->StyleDisplay();
+  // Changes to the offsets of a non-positioned element can safely be ignored.
+  if (display->mPosition == NS_STYLE_POSITION_STATIC) {
+    return true;
+  }
+
   // Don't process position changes on frames which have views or the ones which
   // have a view somewhere in their descendants, because the corresponding view
   // needs to be repositioned properly as well.
   if (aFrame->HasView() ||
       (aFrame->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW)) {
     StyleChangeReflow(aFrame, nsChangeHint_NeedReflow);
     return false;
   }
 
-  const nsStyleDisplay* display = aFrame->StyleDisplay();
-  // Changes to the offsets of a non-positioned element can safely be ignored.
-  if (display->mPosition == NS_STYLE_POSITION_STATIC) {
-    return true;
-  }
-
   aFrame->SchedulePaint();
 
   // For relative positioning, we can simply update the frame rect
   if (display->IsRelativelyPositionedStyle()) {
     if (display->IsInnerTableStyle()) {
       // We don't currently support relative positioning of inner table
       // elements (bug 35168).  If we apply offsets to things we haven't
       // previously offset, we'll get confused.  So bail.
