From: L. David Baron <dbaron@dbaron.org>

Bug ??? patch N - Make AddStyleUpdatesTo only add updates that need to be done, and make RuleNodeWithReplacement interact with the nsAnimationManager and nsTransitionManager in a more typical way.

FIXME: This needs reexamination of what happened when merging!
FIXME: ... and from another merge!
FIXME: Removed another hunk when merging!

NOTE: depends on patch consistent-animations-transitions

diff --git a/dom/animation/EffectCompositor.cpp b/dom/animation/EffectCompositor.cpp
--- a/dom/animation/EffectCompositor.cpp
+++ b/dom/animation/EffectCompositor.cpp
@@ -561,16 +561,18 @@ EffectCompositor::HasThrottledStyleUpdat
 
 void
 EffectCompositor::AddStyleUpdatesTo(RestyleTracker& aTracker)
 {
   if (!mPresContext) {
     return;
   }
 
+  // FIXME: Do we need to do something with events like FlushTransitions
+  // does?  (maybe transitions only?)
   for (size_t i = 0; i < kCascadeLevelCount; i++) {
     CascadeLevel cascadeLevel = CascadeLevel(i);
     auto& elementSet = mElementsToRestyle[cascadeLevel];
 
     // Copy the list of elements to restyle to a separate array that we can
     // iterate over. This is because we need to call MaybeUpdateCascadeResults
     // on each element, but doing that can mutate elementSet. In this case
     // it will only mutate the bool value associated with each element in the
@@ -593,20 +595,38 @@ EffectCompositor::AddStyleUpdatesTo(Rest
 
 #if 0
       // FIXME: REWRITE THIS!
       if (!collection->mStyleChanging) {
         continue;
       }
 #endif
 
+#if 0
+      RefPtr<css::AnimValuesStyleRule> oldStyleRule = collection->mStyleRule;
+#endif
+
       ComposeAnimationRule(pseudoElem.mElement,
                            pseudoElem.mPseudoType,
                            cascadeLevel);
 
+#if 0
+    // FIXME: It would be nice to check this; it would allow us to skip
+    // a good bit of duplication of work.  Unfortunately it's the norm
+    // that we have already updated the style rule, but not yet
+    // restyled.  (Is that because of the FlushAnimations/FlushTransitions
+    // calls in PresShell::FlushPendingNotifications, which post updates
+    // before the animation-only style flush in ProcessPendingRestyles
+    // but aren't processed until later in ProcessPendingRestyles?)
+    if (oldStyleRule == collection->mStyleRule) {
+      // No style to update.
+      continue;
+    }
+#endif
+
       dom::Element* elementToRestyle =
         GetElementToRestyle(pseudoElem.mElement, pseudoElem.mPseudoType);
       if (elementToRestyle) {
         nsRestyleHint rshint = cascadeLevel == CascadeLevel::Transitions ?
                                eRestyle_CSSTransitions :
                                eRestyle_CSSAnimations;
         aTracker.AddPendingRestyle(elementToRestyle, rshint, nsChangeHint(0));
       }
