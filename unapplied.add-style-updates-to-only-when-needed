From: L. David Baron <dbaron@dbaron.org>

Bug ??? patch N - Make AddStyleUpdatesTo only add updates that need to be done, and make RuleNodeWithReplacement interact with the nsAnimationManager and nsTransitionManager in a more typical way.

FIXME: This needs reexamination of what happened when merging!
FIXME: ... and from another merge!

NOTE: depends on patch consistent-animations-transitions

diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -286,29 +286,49 @@ CommonAnimationManager::SizeOfExcludingT
 CommonAnimationManager::SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
 {
   return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
 }
 
 void
 CommonAnimationManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
 {
+  // FIXME: Do we need to do something with events like FlushTransitions
+  // does?  (maybe transitions only?)
   TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
 
   PRCList* next = PR_LIST_HEAD(&mElementCollections);
   while (next != &mElementCollections) {
     AnimationCollection* collection = static_cast<AnimationCollection*>(next);
     next = PR_NEXT_LINK(next);
 
     if (!collection->mNeedsRefreshes) {
       continue;
     }
 
+#if 0
+    nsRefPtr<css::AnimValuesStyleRule> oldStyleRule = collection->mStyleRule;
+#endif
+
     collection->EnsureStyleRuleFor(now, EnsureStyleRule_IsNotThrottled);
 
+#if 0
+    // FIXME: It would be nice to check this; it would allow us to skip
+    // a good bit of duplication of work.  Unfortunately it's the norm
+    // that we have already updated the style rule, but not yet
+    // restyled.  (Is that because of the FlushAnimations/FlushTransitions
+    // calls in PresShell::FlushPendingNotifications, which post updates
+    // before the animation-only style flush in ProcessPendingRestyles
+    // but aren't processed until later in ProcessPendingRestyles?)
+    if (oldStyleRule == collection->mStyleRule) {
+      // No style to update.
+      continue;
+    }
+#endif
+
     dom::Element* elementToRestyle = collection->GetElementToRestyle();
     if (elementToRestyle) {
       nsRestyleHint rshint = collection->IsForTransitions()
         ? eRestyle_CSSTransitions : eRestyle_CSSAnimations;
       aTracker.AddPendingRestyle(elementToRestyle, rshint, nsChangeHint(0));
     }
   }
 }
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -973,16 +973,17 @@ nsTransitionManager::FlushTransitions(Fl
       MOZ_ASSERT(collection->mElementProperty ==
                    nsGkAtoms::transitionsProperty ||
                  collection->mElementProperty ==
                    nsGkAtoms::transitionsOfBeforeProperty ||
                  collection->mElementProperty ==
                    nsGkAtoms::transitionsOfAfterProperty,
                  "Unexpected element property; might restyle too much");
       if (!canThrottleTick || transitionStartedOrEnded) {
+        collection->EnsureStyleRuleFor(now);
         collection->PostRestyleForAnimation(mPresContext);
       } else {
         didThrottle = true;
       }
 
       if (collection->mAnimations.IsEmpty()) {
         collection->Destroy();
         // |collection| is now a dangling pointer!
