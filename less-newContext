From: L. David Baron <dbaron@dbaron.org>

Bug 898329 patch 4:  Avoid using newContext outside of what will be in RestyleManager::RestyleSelf.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -2397,21 +2397,22 @@ ElementRestyler::Restyle(nsRestyleHint a
                                            &undisplayedRestyleData)) {
           thisChildHint =
             nsRestyleHint(thisChildHint | undisplayedRestyleData.mRestyleHint);
         }
         nsRefPtr<nsStyleContext> undisplayedContext;
         if (thisChildHint) {
           undisplayedContext =
             styleSet->ResolveStyleFor(undisplayed->mContent->AsElement(),
-                                      newContext,
+                                      mFrame->StyleContext(),
                                       mTreeMatchContext);
         } else {
           undisplayedContext =
-            styleSet->ReparentStyleContext(undisplayed->mStyle, newContext,
+            styleSet->ReparentStyleContext(undisplayed->mStyle,
+                                           mFrame->StyleContext(),
                                            undisplayed->mContent->AsElement());
         }
         if (undisplayedContext) {
           const nsStyleDisplay* display = undisplayedContext->StyleDisplay();
           if (display->mDisplay != NS_STYLE_DISPLAY_NONE) {
             NS_ASSERTION(undisplayed->mContent,
                          "Must have undisplayed content");
             mChangeList->AppendChange(nullptr, undisplayed->mContent,
@@ -2440,17 +2441,18 @@ ElementRestyler::Restyle(nsRestyleHint a
             NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
         // Check for a new :before pseudo and an existing :before
         // frame, but only if the frame is the first continuation.
         nsIFrame* prevContinuation = mFrame->GetPrevContinuation();
         if (!prevContinuation) {
           // Checking for a :before frame is cheaper than getting the
           // :before style context.
           if (!nsLayoutUtils::GetBeforeFrame(mFrame) &&
-              nsLayoutUtils::HasPseudoStyle(mFrame->GetContent(), newContext,
+              nsLayoutUtils::HasPseudoStyle(mFrame->GetContent(),
+                                            mFrame->StyleContext(),
                                             nsCSSPseudoElements::ePseudo_before,
                                             mPresContext)) {
             // Have to create the new :before frame
             NS_UpdateHint(mMinChange, nsChangeHint_ReconstructFrame);
             mChangeList->AppendChange(mFrame, mContent,
                                       nsChangeHint_ReconstructFrame);
           }
         }
@@ -2471,17 +2473,18 @@ ElementRestyler::Restyle(nsRestyleHint a
             NS_FRAME_MAY_HAVE_GENERATED_CONTENT))) {
         // Check for new :after content, but only if the frame is the
         // last continuation.
         nsIFrame* nextContinuation = mFrame->GetNextContinuation();
 
         if (!nextContinuation) {
           // Getting the :after frame is more expensive than getting the pseudo
           // context, so get the pseudo context first.
-          if (nsLayoutUtils::HasPseudoStyle(mFrame->GetContent(), newContext,
+          if (nsLayoutUtils::HasPseudoStyle(mFrame->GetContent(),
+                                            mFrame->StyleContext(),
                                             nsCSSPseudoElements::ePseudo_after,
                                             mPresContext) &&
               !nsLayoutUtils::GetAfterFrame(mFrame)) {
             // have to create the new :after frame
             NS_UpdateHint(mMinChange, nsChangeHint_ReconstructFrame);
             mChangeList->AppendChange(mFrame, mContent,
                                       nsChangeHint_ReconstructFrame);
           }
@@ -2499,17 +2502,17 @@ ElementRestyler::Restyle(nsRestyleHint a
 #ifdef ACCESSIBILITY
       // Notify a11y for primary frame only if it's a root frame of visibility
       // changes or its parent frame was hidden while it stays visible and
       // it is not inside a {ib} split or is the first frame of {ib} split.
       if (nsIPresShell::IsAccessibilityActive() &&
           !mFrame->GetPrevContinuation() &&
           !nsLayoutUtils::FrameIsNonFirstInIBSplit(mFrame)) {
         if (mDesiredA11yNotifications == eSendAllNotifications) {
-          bool isFrameVisible = newContext->StyleVisibility()->IsVisible();
+          bool isFrameVisible = mFrame->StyleVisibility()->IsVisible();
           if (isFrameVisible != mWasFrameVisible) {
             if (isFrameVisible) {
               // Notify a11y the element (perhaps with its children) was shown.
               // We don't fall into this case if this element gets or stays shown
               // while its parent becomes hidden.
               mKidsDesiredA11yNotifications = eSkipNotifications;
               mOurA11yNotification = eNotifyShown;
             } else {
@@ -2518,17 +2521,17 @@ ElementRestyler::Restyle(nsRestyleHint a
               // visible children then we should notify a11y about that as if
               // they were inserted into tree. Notify a11y this element was
               // hidden.
               mKidsDesiredA11yNotifications = eNotifyIfShown;
               mOurA11yNotification = eNotifyHidden;
             }
           }
         } else if (mDesiredA11yNotifications == eNotifyIfShown &&
-                   newContext->StyleVisibility()->IsVisible()) {
+                   mFrame->StyleVisibility()->IsVisible()) {
           // Notify a11y that element stayed visible while its parent was
           // hidden.
           mVisibleKidsOfHiddenElement.AppendElement(mFrame->GetContent());
           mKidsDesiredA11yNotifications = eSkipNotifications;
         }
       }
 #endif
 
