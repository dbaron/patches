From: L. David Baron <dbaron@dbaron.org>

Bug 882573 patch 3:  Stop putting the presentational hint and style attribute style sheets in the style set's list of style sheets; put them only in the list of rule processors.

diff --git a/content/base/src/nsDocument.cpp b/content/base/src/nsDocument.cpp
--- a/content/base/src/nsDocument.cpp
+++ b/content/base/src/nsDocument.cpp
@@ -2228,37 +2228,37 @@ nsDocument::ResetStylesheetsToURI(nsIURI
     mAdditionalSheets[i].Clear();
 
   // NOTE:  We don't release the catalog sheets.  It doesn't really matter
   // now, but it could in the future -- in which case not releasing them
   // is probably the right thing to do.
 
   // Now reset our inline style and attribute sheets.
   if (mAttrStyleSheet) {
-    // Remove this sheet from all style sets
+    // Tell the style set that its rule processor list is dirty.  (Is
+    // this even needed?)
     nsCOMPtr<nsIPresShell> shell = GetShell();
     if (shell) {
-      shell->StyleSet()->RemoveStyleSheet(nsStyleSet::ePresHintSheet,
-                                          mAttrStyleSheet);
+      shell->StyleSet()->DirtyRuleProcessor(nsStyleSet::ePresHintSheet);
     }
     mAttrStyleSheet->Reset(aURI);
   } else {
     mAttrStyleSheet = new nsHTMLStyleSheet(aURI, this);
   }
 
   // Don't use AddStyleSheet, since it'll put the sheet into style
   // sets in the document level, which is not desirable here.
   mAttrStyleSheet->SetOwningDocument(this);
 
   if (mStyleAttrStyleSheet) {
-    // Remove this sheet from all style sets
+    // Tell the style set that its rule processor list is dirty.  (Is
+    // this even needed?)
     nsCOMPtr<nsIPresShell> shell = GetShell();
     if (shell) {
-      shell->StyleSet()->
-        RemoveStyleSheet(nsStyleSet::eStyleAttrSheet, mStyleAttrStyleSheet);
+      shell->StyleSet()->DirtyRuleProcessor(nsStyleSet::eStyleAttrSheet);
     }
     mStyleAttrStyleSheet->Reset(aURI);
   } else {
     mStyleAttrStyleSheet = new nsHTMLCSSStyleSheet(aURI, this);
   }
 
   // The loop over style sets below will handle putting this sheet
   // into style sets as needed.
@@ -2289,29 +2289,23 @@ AppendSheetsToStyleSet(nsStyleSet* aStyl
   }
 }
 
 
 void
 nsDocument::FillStyleSet(nsStyleSet* aStyleSet)
 {
   NS_PRECONDITION(aStyleSet, "Must have a style set");
-  NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::ePresHintSheet) == 0,
-                  "Style set already has a preshint sheet?");
   NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::eDocSheet) == 0,
                   "Style set already has document sheets?");
-  NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::eStyleAttrSheet) == 0,
-                  "Style set already has style attr sheets?");
-  NS_PRECONDITION(mStyleAttrStyleSheet, "No style attr stylesheet?");
-  NS_PRECONDITION(mAttrStyleSheet, "No attr stylesheet?");
-
-  aStyleSet->AppendStyleSheet(nsStyleSet::ePresHintSheet, mAttrStyleSheet);
-
-  aStyleSet->AppendStyleSheet(nsStyleSet::eStyleAttrSheet,
-                              mStyleAttrStyleSheet);
+
+  // We could consider moving this to nsStyleSet::Init, to match its
+  // handling of the eAnimationSheet and eTransitionSheet levels.
+  aStyleSet->DirtyRuleProcessor(nsStyleSet::ePresHintSheet);
+  aStyleSet->DirtyRuleProcessor(nsStyleSet::eStyleAttrSheet);
 
   int32_t i;
   for (i = mStyleSheets.Count() - 1; i >= 0; --i) {
     nsIStyleSheet* sheet = mStyleSheets[i];
     if (sheet->IsApplicable()) {
       aStyleSet->AddDocStyleSheet(sheet, this);
     }
   }
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -25,16 +25,18 @@
 #include "nsRuleData.h"
 #include "nsRuleProcessorData.h"
 #include "nsTransitionManager.h"
 #include "nsAnimationManager.h"
 #include "nsEventStates.h"
 #include "nsStyleSheetService.h"
 #include "mozilla/dom/Element.h"
 #include "GeckoProfiler.h"
+#include "nsHTMLCSSStyleSheet.h"
+#include "nsHTMLStyleSheet.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 NS_IMPL_ISUPPORTS1(nsEmptyStyleRule, nsIStyleRule)
 
 /* virtual */ void
 nsEmptyStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
@@ -313,29 +315,38 @@ nsStyleSet::GatherRuleProcessors(sheetTy
   if (mAuthorStyleDisabled && (aType == eDocSheet || 
                                aType == eScopedDocSheet ||
                                aType == eStyleAttrSheet)) {
     // Don't regather if this level is disabled.  Note that we gather
     // preshint sheets no matter what, but then skip them for some
     // elements later if mAuthorStyleDisabled.
     return NS_OK;
   }
-  if (aType == eAnimationSheet) {
-    // We have no sheet for the animations level; just a rule
-    // processor.  (XXX: We should probably do this for the other
-    // non-CSS levels too!)
-    mRuleProcessors[aType] = PresContext()->AnimationManager();
-    return NS_OK;
-  }
-  if (aType == eTransitionSheet) {
-    // We have no sheet for the transitions level; just a rule
-    // processor.  (XXX: We should probably do this for the other
-    // non-CSS levels too!)
-    mRuleProcessors[aType] = PresContext()->TransitionManager();
-    return NS_OK;
+  switch (aType) {
+    // handle the types for which have a rule processor that does not
+    // implement the style sheet interface.
+    case eAnimationSheet:
+      MOZ_ASSERT(mSheets[aType].Count() == 0);
+      mRuleProcessors[aType] = PresContext()->AnimationManager();
+      return NS_OK;
+    case eTransitionSheet:
+      MOZ_ASSERT(mSheets[aType].Count() == 0);
+      mRuleProcessors[aType] = PresContext()->TransitionManager();
+      return NS_OK;
+    case eStyleAttrSheet:
+      MOZ_ASSERT(mSheets[aType].Count() == 0);
+      mRuleProcessors[aType] = PresContext()->Document()->GetInlineStyleSheet();
+      return NS_OK;
+    case ePresHintSheet:
+      MOZ_ASSERT(mSheets[aType].Count() == 0);
+      mRuleProcessors[aType] = PresContext()->Document()->GetAttributeStyleSheet();
+      return NS_OK;
+    default:
+      // keep going
+      break;
   }
   if (aType == eScopedDocSheet) {
     // Create a rule processor for each scope.
     uint32_t count = mSheets[eScopedDocSheet].Count();
     if (count) {
       // Gather the scoped style sheets into an array as
       // nsCSSStyleSheets, and mark all of their scope elements
       // as scoped style roots.
@@ -418,90 +429,71 @@ nsStyleSet::AppendStyleSheet(sheetType a
 {
   NS_PRECONDITION(aSheet, "null arg");
   NS_ASSERTION(aSheet->IsApplicable(),
                "Inapplicable sheet being placed in style set");
   mSheets[aType].RemoveObject(aSheet);
   if (!mSheets[aType].AppendObject(aSheet))
     return NS_ERROR_OUT_OF_MEMORY;
 
-  if (!mBatching)
-    return GatherRuleProcessors(aType);
-
-  mDirty |= 1 << aType;
-  return NS_OK;
+  return DirtyRuleProcessor(aType);
 }
 
 nsresult
 nsStyleSet::PrependStyleSheet(sheetType aType, nsIStyleSheet *aSheet)
 {
   NS_PRECONDITION(aSheet, "null arg");
   NS_ASSERTION(aSheet->IsApplicable(),
                "Inapplicable sheet being placed in style set");
   mSheets[aType].RemoveObject(aSheet);
   if (!mSheets[aType].InsertObjectAt(aSheet, 0))
     return NS_ERROR_OUT_OF_MEMORY;
 
-  if (!mBatching)
-    return GatherRuleProcessors(aType);
-
-  mDirty |= 1 << aType;
-  return NS_OK;
+  return DirtyRuleProcessor(aType);
 }
 
 nsresult
 nsStyleSet::RemoveStyleSheet(sheetType aType, nsIStyleSheet *aSheet)
 {
   NS_PRECONDITION(aSheet, "null arg");
   NS_ASSERTION(aSheet->IsComplete(),
                "Incomplete sheet being removed from style set");
   mSheets[aType].RemoveObject(aSheet);
-  if (!mBatching)
-    return GatherRuleProcessors(aType);
 
-  mDirty |= 1 << aType;
-  return NS_OK;
+  return DirtyRuleProcessor(aType);
 }
 
 nsresult
 nsStyleSet::ReplaceSheets(sheetType aType,
                           const nsCOMArray<nsIStyleSheet> &aNewSheets)
 {
   mSheets[aType].Clear();
   if (!mSheets[aType].AppendObjects(aNewSheets))
     return NS_ERROR_OUT_OF_MEMORY;
 
-  if (!mBatching)
-    return GatherRuleProcessors(aType);
-
-  mDirty |= 1 << aType;
-  return NS_OK;
+  return DirtyRuleProcessor(aType);
 }
 
 nsresult
 nsStyleSet::InsertStyleSheetBefore(sheetType aType, nsIStyleSheet *aNewSheet,
                                    nsIStyleSheet *aReferenceSheet)
 {
   NS_PRECONDITION(aNewSheet && aReferenceSheet, "null arg");
   NS_ASSERTION(aNewSheet->IsApplicable(),
                "Inapplicable sheet being placed in style set");
 
   mSheets[aType].RemoveObject(aNewSheet);
   int32_t idx = mSheets[aType].IndexOf(aReferenceSheet);
   if (idx < 0)
     return NS_ERROR_INVALID_ARG;
-  
+
   if (!mSheets[aType].InsertObjectAt(aNewSheet, idx))
     return NS_ERROR_OUT_OF_MEMORY;
 
-  if (!mBatching)
-    return GatherRuleProcessors(aType);
-
-  mDirty |= 1 << aType;
-  return NS_OK;
+  return DirtyRuleProcessor(aType);
 }
 
 nsresult
 nsStyleSet::DirtyRuleProcessor(sheetType aType)
 {
   MOZ_ASSERT(aType == ePresHintSheet || aType == eStyleAttrSheet);
   if (!mBatching)
     return GatherRuleProcessors(aType);
@@ -565,21 +557,18 @@ nsStyleSet::AddDocStyleSheet(nsIStyleShe
     if (sheetDocIndex < 0 &&
         ((sheetService &&
         sheetService->AuthorStyleSheets()->IndexOf(sheet) >= 0) ||
         sheet == aDocument->FirstAdditionalAuthorSheet()))
         break;
   }
   if (!sheets.InsertObjectAt(aSheet, index))
     return NS_ERROR_OUT_OF_MEMORY;
-  if (!mBatching)
-    return GatherRuleProcessors(type);
 
-  mDirty |= 1 << type;
-  return NS_OK;
+  return DirtyRuleProcessor(type);
 }
 
 nsresult
 nsStyleSet::RemoveDocStyleSheet(nsIStyleSheet *aSheet)
 {
   nsRefPtr<nsCSSStyleSheet> cssSheet = do_QueryObject(aSheet);
   bool isScoped = cssSheet && cssSheet->GetScopeElement();
   return RemoveStyleSheet(isScoped ? eScopedDocSheet : eDocSheet, aSheet);
