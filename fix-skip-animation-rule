From: L. David Baron <dbaron@dbaron.org>

Bug 861489:  Fix SkipAnimationRule to do the right thing in the presence of new cascading rules.  r=bzbarsky

diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -830,22 +830,29 @@ nsStyleSet::GetContext(nsStyleContext* a
     NS_ABORT_IF_FALSE(result->RuleNode() == aRuleNode,
                       "unexpected rule node");
     NS_ABORT_IF_FALSE(!result->GetStyleIfVisited() == !aVisitedRuleNode,
                       "unexpected visited rule node");
     NS_ABORT_IF_FALSE(!aVisitedRuleNode ||
                       result->GetStyleIfVisited()->RuleNode() ==
                         aVisitedRuleNode,
                       "unexpected visited rule node");
+    NS_ABORT_IF_FALSE(!aVisitedRuleNode ||
+                      oldAnimRule == GetAnimationRule(aVisitedRuleNode),
+                      "animation rule mismatch between rule nodes");
     if (oldAnimRule != animRule) {
       nsRuleNode *ruleNode =
         ReplaceAnimationRule(aRuleNode, oldAnimRule, animRule);
       nsRuleNode *visitedRuleNode = aVisitedRuleNode
         ? ReplaceAnimationRule(aVisitedRuleNode, oldAnimRule, animRule)
         : nullptr;
+      NS_ABORT_IF_FALSE(!visitedRuleNode ||
+                        GetAnimationRule(ruleNode) ==
+                          GetAnimationRule(visitedRuleNode),
+                        "animation rule mismatch between rule nodes");
       result = GetContext(aParentContext, ruleNode, visitedRuleNode,
                           aPseudoTag, aPseudoType, nullptr,
                           aFlags & ~eDoAnimation);
     }
   }
 
   if (aElementForAnimation && aElementForAnimation->IsHTML(nsGkAtoms::body) &&
       aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement &&
@@ -1716,25 +1723,40 @@ nsStyleSet::GCRuleTrees()
       // It was deleted, as it should be.
       mOldRuleTrees.RemoveElementAt(i);
     } else {
       NS_NOTREACHED("old rule tree still referenced");
     }
   }
 }
 
+/**
+ * Return an equivalent to aRuleNode with both animation and transition
+ * rules removed, and post a restyle if needed.
+ */
 static inline nsRuleNode*
 SkipAnimationRules(nsRuleNode* aRuleNode, Element* aElement, bool isPseudo)
 {
   nsRuleNode* ruleNode = aRuleNode;
-  while (!ruleNode->IsRoot() &&
-         (ruleNode->GetLevel() == nsStyleSet::eTransitionSheet ||
-          ruleNode->GetLevel() == nsStyleSet::eAnimationSheet)) {
+  // The transition rule must be at the top of the cascade.
+  if (!ruleNode->IsRoot() &&
+      ruleNode->GetLevel() == nsStyleSet::eTransitionSheet) {
     ruleNode = ruleNode->GetParent();
   }
+  NS_ABORT_IF_FALSE(ruleNode->IsRoot() ||
+                    ruleNode->GetLevel() != nsStyleSet::eTransitionSheet,
+                    "can't have more than one transition rule");
+
+  // Use our existing ReplaceAnimationRule function to replace the
+  // animation rule, if present.
+  nsIStyleRule* animationRule = GetAnimationRule(ruleNode);
+  if (animationRule) {
+    ruleNode = ReplaceAnimationRule(ruleNode, animationRule, nullptr);
+  }
+
   if (ruleNode != aRuleNode) {
     NS_ASSERTION(aElement, "How can we have transition rules but no element?");
     // Need to do an animation restyle, just like
     // nsTransitionManager::WalkTransitionRule and
     // nsAnimationManager::GetAnimationRule would.
     nsRestyleHint hint = isPseudo ? eRestyle_Subtree : eRestyle_Self;
     aRuleNode->PresContext()->PresShell()->RestyleForAnimation(aElement, hint);
   }
