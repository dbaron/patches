From: L. David Baron <dbaron@dbaron.org>

Use extension alternatives for GLX 1.3 features when GLX 1.3 is not available but equivalent extensions are.

diff --git a/gfx/thebes/GLContextProviderGLX.cpp b/gfx/thebes/GLContextProviderGLX.cpp
--- a/gfx/thebes/GLContextProviderGLX.cpp
+++ b/gfx/thebes/GLContextProviderGLX.cpp
@@ -60,16 +60,39 @@
 
 namespace mozilla {
 namespace gl {
 
 static PRBool gIsATI = PR_FALSE;
 static PRBool gIsChromium = PR_FALSE;
 static int gGLXVersion = 0;
 
+static bool HasExtension(const char* aExtensions, const char* aRequiredExtension)
+{
+    // aExtensions is a space-separated list of extension names (which do
+    // not contain spaces
+    NS_ASSERTION(strchr(aRequiredExtension, ' ') == 0,
+                 "extension names must not have spaces");
+
+    const char *s = strstr(aExtensions, aRequiredExtension);
+    if (!s)
+        return false;
+
+    // Check delimiter at start
+    if (s != aExtensions && *(s-1) != ' ')
+        return false;
+
+    // Check delimiter at end
+    size_t len = strlen(aRequiredExtension);
+    if (s[len] != '\0' && s[len] != ' ')
+        return false;
+
+    return true;
+}
+
 PRBool
 GLXLibrary::EnsureInitialized()
 {
     if (mInitialized) {
         return PR_TRUE;
     }
 
     // Don't repeatedly try to initialize.
@@ -82,48 +105,76 @@ GLXLibrary::EnsureInitialized()
         mOGLLibrary = PR_LoadLibrary("libGL.so.1");
         if (!mOGLLibrary) {
 	    NS_WARNING("Couldn't load OpenGL shared library.");
 	    return PR_FALSE;
         }
     }
 
     LibrarySymbolLoader::SymLoadStruct symbols[] = {
+        /* functions that were in GLX 1.0 */
         { (PRFuncPtr*) &xDestroyContext, { "glXDestroyContext", NULL } },
         { (PRFuncPtr*) &xMakeCurrent, { "glXMakeCurrent", NULL } },
-        { (PRFuncPtr*) &xGetProcAddress, { "glXGetProcAddress", NULL } },
-        { (PRFuncPtr*) &xChooseFBConfig, { "glXChooseFBConfig", NULL } },
-        { (PRFuncPtr*) &xGetFBConfigs, { "glXGetFBConfigs", NULL } },
-        { (PRFuncPtr*) &xCreateNewContext, { "glXCreateNewContext", NULL } },
-        { (PRFuncPtr*) &xGetVisualFromFBConfig, { "glXGetVisualFromFBConfig", NULL } },
-        { (PRFuncPtr*) &xGetFBConfigAttrib, { "glXGetFBConfigAttrib", NULL } },
         { (PRFuncPtr*) &xSwapBuffers, { "glXSwapBuffers", NULL } },
+        { (PRFuncPtr*) &xGetCurrentContext, { "glXGetCurrentContext", NULL } },
+        /* functions introduced in GLX 1.1 */
         { (PRFuncPtr*) &xQueryExtensionsString, { "glXQueryExtensionsString", NULL } },
         { (PRFuncPtr*) &xQueryServerString, { "glXQueryServerString", NULL } },
+        { (PRFuncPtr*) &xGetClientString, { "glXGetClientString", NULL } },
+        { NULL, { NULL } }
+    };
+
+    LibrarySymbolLoader::SymLoadStruct symbols13[] = {
+        /* functions introduced in GLX 1.3 */
+        { (PRFuncPtr*) &xChooseFBConfig, { "glXChooseFBConfig", NULL } },
+        { (PRFuncPtr*) &xGetFBConfigAttrib, { "glXGetFBConfigAttrib", NULL } },
+        { (PRFuncPtr*) &xGetFBConfigs, { "glXGetFBConfigs", NULL } },
+        { (PRFuncPtr*) &xGetVisualFromFBConfig, { "glXGetVisualFromFBConfig", NULL } },
         { (PRFuncPtr*) &xCreatePixmap, { "glXCreatePixmap", NULL } },
         { (PRFuncPtr*) &xDestroyPixmap, { "glXDestroyPixmap", NULL } },
-        { (PRFuncPtr*) &xGetClientString, { "glXGetClientString", NULL } },
-        { (PRFuncPtr*) &xGetCurrentContext, { "glXGetCurrentContext", NULL } },
+        { (PRFuncPtr*) &xCreateNewContext, { "glXCreateNewContext", NULL } },
+        { NULL, { NULL } }
+    };
+
+    LibrarySymbolLoader::SymLoadStruct symbols13_ext[] = {
+        /* extension equivalents for functions introduced in GLX 1.3 */
+        // GLX_SGIX_fbconfig extension
+        { (PRFuncPtr*) &xChooseFBConfig, { "glXChooseFBConfigSGIX", NULL } },
+        { (PRFuncPtr*) &xGetFBConfigAttrib, { "glXGetFBConfigAttribSGIX", NULL } },
+        { (PRFuncPtr*) &xGetFBConfigs, { "glXGetFBConfigs", NULL } }, // no equivalent!
+        { (PRFuncPtr*) &xGetVisualFromFBConfig, { "glXGetVisualFromFBConfig", NULL } },
+        { (PRFuncPtr*) &xCreatePixmap, { "glXCreateGLXPixmapWithConfigSGIX", NULL } }, // missing last argument!
+        { (PRFuncPtr*) &xDestroyPixmap, { "glXDestroyGLXPixmap", NULL } }, // not from ext
+        { (PRFuncPtr*) &xCreateNewContext, { "glXCreateContextWithConfigSGIX", NULL } },
+        { NULL, { NULL } }
+    };
+
+    LibrarySymbolLoader::SymLoadStruct symbols14[] = {
+        /* functions introduced in GLX 1.4 */
+        { (PRFuncPtr*) &xGetProcAddress, { "glXGetProcAddress", NULL } },
+        { NULL, { NULL } }
+    };
+
+    LibrarySymbolLoader::SymLoadStruct symbols14_ext[] = {
+        /* extension equivalents for functions introduced in GLX 1.4 */
+        // GLX_ARB_get_proc_address extension
+        { (PRFuncPtr*) &xGetProcAddress, { "glXGetProcAddressARB", NULL } },
         { NULL, { NULL } }
     };
 
     if (!LibrarySymbolLoader::LoadSymbols(mOGLLibrary, &symbols[0])) {
         NS_WARNING("Couldn't find required entry point in OpenGL shared library");
         return PR_FALSE;
     }
 
-    const char *vendor = xQueryServerString(DefaultXDisplay(),
-                                            DefaultScreen(DefaultXDisplay()),
-                                            GLX_VENDOR);
-    const char *serverVersionStr = xQueryServerString(DefaultXDisplay(),
-                                                      DefaultScreen(DefaultXDisplay()),
-                                                      GLX_VERSION);
-    const char *clientVersionStr = xGetClientString(DefaultXDisplay(),
-                                                    GLX_VERSION);
-
+    Display *display = DefaultXDisplay();
+    int screen = DefaultScreen(display);
+    const char *vendor = xQueryServerString(display, screen, GLX_VENDOR);
+    const char *serverVersionStr = xQueryServerString(display, screen, GLX_VERSION);
+    const char *clientVersionStr = xGetClientString(display, GLX_VERSION);
 
     int serverVersion = 0, clientVersion = 0;
     // FIXME: What about "2" or "1.10"?
     if (serverVersionStr &&
         strlen(serverVersionStr) >= 3 &&
         serverVersionStr[1] == '.')
     {
         serverVersion = (serverVersionStr[0] - '0') << 8 | (serverVersionStr[2] - '0');
@@ -134,19 +185,54 @@ GLXLibrary::EnsureInitialized()
         strlen(clientVersionStr) >= 3 &&
         clientVersionStr[1] == '.')
     {
         clientVersion = (clientVersionStr[0] - '0') << 8 | (clientVersionStr[2] - '0');
     }
 
     gGLXVersion = PR_MIN(clientVersion, serverVersion);
 
-    if (gGLXVersion < 0x0103)
+    if (gGLXVersion < 0x0101)
+        // Not possible to query for extensions.
         return PR_FALSE;
 
+    const char *extensionsStr = xQueryExtensionsString(display, screen);
+
+    LibrarySymbolLoader::SymLoadStruct *sym13;
+    if (gGLXVersion < 0x0103) {
+        // Even if we don't have 1.3, we might have equivalent extensions
+        // (as on the Intel X server).
+        if (!HasExtension(extensionsStr, "GLX_SGIX_fbconfig")) {
+            return PR_FALSE;
+        }
+        sym13 = symbols13_ext;
+    } else {
+        sym13 = symbols13;
+    }
+    if (!LibrarySymbolLoader::LoadSymbols(mOGLLibrary, sym13)) {
+        NS_WARNING("Couldn't find required entry point in OpenGL shared library");
+        return PR_FALSE;
+    }
+
+    LibrarySymbolLoader::SymLoadStruct *sym14;
+    if (gGLXVersion < 0x0104) {
+        // Even if we don't have 1.4, we might have equivalent extensions
+        // (as on the Intel X server).
+        if (!HasExtension(extensionsStr, "GLX_ARB_get_proc_address")) {
+            return PR_FALSE;
+        }
+        sym14 = symbols14_ext;
+    } else {
+        sym14 = symbols14;
+    }
+    if (!LibrarySymbolLoader::LoadSymbols(mOGLLibrary, sym14)) {
+        NS_WARNING("Couldn't find required entry point in OpenGL shared library");
+        return PR_FALSE;
+    }
+
     gIsATI = vendor && DoesVendorStringMatch(vendor, "ATI");
     gIsChromium = (vendor && DoesVendorStringMatch(vendor, "Chromium")) ||
         (serverVersion && DoesVendorStringMatch(serverVersionStr, "Chromium"));
 
     mInitialized = PR_TRUE;
     return PR_TRUE;
 }
 
@@ -436,17 +522,19 @@ GLContextProviderGLX::CreateForWindow(ns
     // is a relatively safe intermediate step.
 
     Display *display = (Display*)aWidget->GetNativeData(NS_NATIVE_DISPLAY); 
     int xscreen = DefaultScreen(display);
     Window window = GET_NATIVE_WINDOW(aWidget);
 
     int numConfigs;
     ScopedXFree<GLXFBConfig> cfgs;
-    if (gIsATI) {
+    // FIXME
+    // if (gIsATI) {
+    if (true) {
         const int attribs[] = {
             GLX_DOUBLEBUFFER, False,
             0
         };
         cfgs = sGLXLibrary.xChooseFBConfig(display,
                                            xscreen,
                                            attribs,
                                            &numConfigs);
