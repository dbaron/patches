From: L. David Baron <dbaron@dbaron.org>

Use extension alternatives for GLX 1.3 features when GLX 1.3 is not available but equivalent extensions are.  (Bug 605992)

diff --git a/gfx/thebes/GLContextProviderGLX.cpp b/gfx/thebes/GLContextProviderGLX.cpp
--- a/gfx/thebes/GLContextProviderGLX.cpp
+++ b/gfx/thebes/GLContextProviderGLX.cpp
@@ -60,16 +60,39 @@
 
 namespace mozilla {
 namespace gl {
 
 static PRBool gIsATI = PR_FALSE;
 static PRBool gIsChromium = PR_FALSE;
 static int gGLXVersion = 0;
 
+static bool HasExtension(const char* aExtensions, const char* aRequiredExtension)
+{
+    // aExtensions is a space-separated list of extension names (which do
+    // not contain spaces
+    NS_ASSERTION(strchr(aRequiredExtension, ' ') == 0,
+                 "extension names must not have spaces");
+
+    const char *s = strstr(aExtensions, aRequiredExtension);
+    if (!s)
+        return false;
+
+    // Check delimiter at start
+    if (s != aExtensions && *(s-1) != ' ')
+        return false;
+
+    // Check delimiter at end
+    size_t len = strlen(aRequiredExtension);
+    if (s[len] != '\0' && s[len] != ' ')
+        return false;
+
+    return true;
+}
+
 PRBool
 GLXLibrary::EnsureInitialized()
 {
     if (mInitialized) {
         return PR_TRUE;
     }
 
     // Don't repeatedly try to initialize.
@@ -82,48 +105,79 @@ GLXLibrary::EnsureInitialized()
         mOGLLibrary = PR_LoadLibrary("libGL.so.1");
         if (!mOGLLibrary) {
 	    NS_WARNING("Couldn't load OpenGL shared library.");
 	    return PR_FALSE;
         }
     }
 
     LibrarySymbolLoader::SymLoadStruct symbols[] = {
+        /* functions that were in GLX 1.0 */
         { (PRFuncPtr*) &xDestroyContext, { "glXDestroyContext", NULL } },
         { (PRFuncPtr*) &xMakeCurrent, { "glXMakeCurrent", NULL } },
-        { (PRFuncPtr*) &xGetProcAddress, { "glXGetProcAddress", NULL } },
-        { (PRFuncPtr*) &xChooseFBConfig, { "glXChooseFBConfig", NULL } },
-        { (PRFuncPtr*) &xGetFBConfigs, { "glXGetFBConfigs", NULL } },
-        { (PRFuncPtr*) &xCreateNewContext, { "glXCreateNewContext", NULL } },
-        { (PRFuncPtr*) &xGetVisualFromFBConfig, { "glXGetVisualFromFBConfig", NULL } },
-        { (PRFuncPtr*) &xGetFBConfigAttrib, { "glXGetFBConfigAttrib", NULL } },
         { (PRFuncPtr*) &xSwapBuffers, { "glXSwapBuffers", NULL } },
+        { (PRFuncPtr*) &xGetCurrentContext, { "glXGetCurrentContext", NULL } },
+        /* functions introduced in GLX 1.1 */
         { (PRFuncPtr*) &xQueryExtensionsString, { "glXQueryExtensionsString", NULL } },
         { (PRFuncPtr*) &xQueryServerString, { "glXQueryServerString", NULL } },
+        { (PRFuncPtr*) &xGetClientString, { "glXGetClientString", NULL } },
+        { NULL, { NULL } }
+    };
+
+    LibrarySymbolLoader::SymLoadStruct symbols13[] = {
+        /* functions introduced in GLX 1.3 */
+        { (PRFuncPtr*) &xChooseFBConfig, { "glXChooseFBConfig", NULL } },
+        { (PRFuncPtr*) &xGetFBConfigAttrib, { "glXGetFBConfigAttrib", NULL } },
+        // WARNING: xGetFBConfigs not set in symbols13_ext
+        { (PRFuncPtr*) &xGetFBConfigs, { "glXGetFBConfigs", NULL } },
+        { (PRFuncPtr*) &xGetVisualFromFBConfig, { "glXGetVisualFromFBConfig", NULL } },
+        // WARNING: symbols13_ext sets xCreateGLXPixmapWithConfig instead
         { (PRFuncPtr*) &xCreatePixmap, { "glXCreatePixmap", NULL } },
         { (PRFuncPtr*) &xDestroyPixmap, { "glXDestroyPixmap", NULL } },
-        { (PRFuncPtr*) &xGetClientString, { "glXGetClientString", NULL } },
-        { (PRFuncPtr*) &xGetCurrentContext, { "glXGetCurrentContext", NULL } },
+        { (PRFuncPtr*) &xCreateNewContext, { "glXCreateNewContext", NULL } },
+        { NULL, { NULL } }
+    };
+
+    LibrarySymbolLoader::SymLoadStruct symbols13_ext[] = {
+        /* extension equivalents for functions introduced in GLX 1.3 */
+        // GLX_SGIX_fbconfig extension
+        { (PRFuncPtr*) &xChooseFBConfig, { "glXChooseFBConfigSGIX", NULL } },
+        { (PRFuncPtr*) &xGetFBConfigAttrib, { "glXGetFBConfigAttribSGIX", NULL } },
+        // WARNING: no xGetFBConfigs equivalent in extensions
+        { (PRFuncPtr*) &xGetVisualFromFBConfig, { "glXGetVisualFromFBConfig", NULL } },
+        // WARNING: different from symbols13:
+        { (PRFuncPtr*) &xCreateGLXPixmapWithConfig, { "glXCreateGLXPixmapWithConfigSGIX", NULL } },
+        { (PRFuncPtr*) &xDestroyPixmap, { "glXDestroyGLXPixmap", NULL } }, // not from ext
+        { (PRFuncPtr*) &xCreateNewContext, { "glXCreateContextWithConfigSGIX", NULL } },
+        { NULL, { NULL } }
+    };
+
+    LibrarySymbolLoader::SymLoadStruct symbols14[] = {
+        /* functions introduced in GLX 1.4 */
+        { (PRFuncPtr*) &xGetProcAddress, { "glXGetProcAddress", NULL } },
+        { NULL, { NULL } }
+    };
+
+    LibrarySymbolLoader::SymLoadStruct symbols14_ext[] = {
+        /* extension equivalents for functions introduced in GLX 1.4 */
+        // GLX_ARB_get_proc_address extension
+        { (PRFuncPtr*) &xGetProcAddress, { "glXGetProcAddressARB", NULL } },
         { NULL, { NULL } }
     };
 
     if (!LibrarySymbolLoader::LoadSymbols(mOGLLibrary, &symbols[0])) {
         NS_WARNING("Couldn't find required entry point in OpenGL shared library");
         return PR_FALSE;
     }
 
-    const char *vendor = xQueryServerString(DefaultXDisplay(),
-                                            DefaultScreen(DefaultXDisplay()),
-                                            GLX_VENDOR);
-    const char *serverVersionStr = xQueryServerString(DefaultXDisplay(),
-                                                      DefaultScreen(DefaultXDisplay()),
-                                                      GLX_VERSION);
-    const char *clientVersionStr = xGetClientString(DefaultXDisplay(),
-                                                    GLX_VERSION);
-
+    Display *display = DefaultXDisplay();
+    int screen = DefaultScreen(display);
+    const char *vendor = xQueryServerString(display, screen, GLX_VENDOR);
+    const char *serverVersionStr = xQueryServerString(display, screen, GLX_VERSION);
+    const char *clientVersionStr = xGetClientString(display, GLX_VERSION);
 
     int serverVersion = 0, clientVersion = 0;
     if (serverVersionStr &&
         strlen(serverVersionStr) >= 3 &&
         serverVersionStr[1] == '.')
     {
         serverVersion = (serverVersionStr[0] - '0') << 8 | (serverVersionStr[2] - '0');
     }
@@ -132,19 +186,54 @@ GLXLibrary::EnsureInitialized()
         strlen(clientVersionStr) >= 3 &&
         clientVersionStr[1] == '.')
     {
         clientVersion = (clientVersionStr[0] - '0') << 8 | (clientVersionStr[2] - '0');
     }
 
     gGLXVersion = PR_MIN(clientVersion, serverVersion);
 
-    if (gGLXVersion < 0x0103)
+    if (gGLXVersion < 0x0101)
+        // Not possible to query for extensions.
         return PR_FALSE;
 
+    const char *extensionsStr = xQueryExtensionsString(display, screen);
+
+    LibrarySymbolLoader::SymLoadStruct *sym13;
+    if (gGLXVersion < 0x0103) {
+        // Even if we don't have 1.3, we might have equivalent extensions
+        // (as on the Intel X server).
+        if (!HasExtension(extensionsStr, "GLX_SGIX_fbconfig")) {
+            return PR_FALSE;
+        }
+        sym13 = symbols13_ext;
+    } else {
+        sym13 = symbols13;
+    }
+    if (!LibrarySymbolLoader::LoadSymbols(mOGLLibrary, sym13)) {
+        NS_WARNING("Couldn't find required entry point in OpenGL shared library");
+        return PR_FALSE;
+    }
+
+    LibrarySymbolLoader::SymLoadStruct *sym14;
+    if (gGLXVersion < 0x0104) {
+        // Even if we don't have 1.4, we might have equivalent extensions
+        // (as on the Intel X server).
+        if (!HasExtension(extensionsStr, "GLX_ARB_get_proc_address")) {
+            return PR_FALSE;
+        }
+        sym14 = symbols14_ext;
+    } else {
+        sym14 = symbols14;
+    }
+    if (!LibrarySymbolLoader::LoadSymbols(mOGLLibrary, sym14)) {
+        NS_WARNING("Couldn't find required entry point in OpenGL shared library");
+        return PR_FALSE;
+    }
+
     gIsATI = vendor && DoesVendorStringMatch(vendor, "ATI");
     gIsChromium = (vendor && DoesVendorStringMatch(vendor, "Chromium")) ||
         (serverVersion && DoesVendorStringMatch(serverVersionStr, "Chromium"));
 
     mInitialized = PR_TRUE;
     return PR_TRUE;
 }
 
@@ -434,17 +523,17 @@ GLContextProviderGLX::CreateForWindow(ns
     // is a relatively safe intermediate step.
 
     Display *display = (Display*)aWidget->GetNativeData(NS_NATIVE_DISPLAY); 
     int xscreen = DefaultScreen(display);
     Window window = GET_NATIVE_WINDOW(aWidget);
 
     int numConfigs;
     ScopedXFree<GLXFBConfig> cfgs;
-    if (gIsATI) {
+    if (gIsATI || gGLXVersion < 0x0103) {
         const int attribs[] = {
             GLX_DOUBLEBUFFER, False,
             0
         };
         cfgs = sGLXLibrary.xChooseFBConfig(display,
                                            xscreen,
                                            attribs,
                                            &numConfigs);
@@ -593,21 +682,32 @@ CreateOffscreenPixmapContext(const gfxIn
 
     nsRefPtr<gfxXlibSurface> xsurface = gfxXlibSurface::Create(DefaultScreenOfDisplay(display),
                                                                vinfo->visual,
                                                                gfxIntSize(16, 16));
     if (xsurface->CairoStatus() != 0) {
         return nsnull;
     }
 
-   
-    GLXPixmap glxpixmap = sGLXLibrary.xCreatePixmap(display,
-                                                    cfgs[chosenIndex],
-                                                    xsurface->XDrawable(),
-                                                    NULL);
+
+    GLXPixmap glxpixmap;
+    // Handle slightly different signature between glXCreatePixmap and
+    // its pre-GLX-1.3 extension equivalent (though given the ABI, we
+    // might not need to).
+    if (gGLXVersion >= 0x0103) {
+        glxpixmap = sGLXLibrary.xCreatePixmap(display,
+                                              cfgs[chosenIndex],
+                                              xsurface->XDrawable(),
+                                              NULL);
+    } else {
+        glxpixmap = sGLXLibrary.xCreateGLXPixmapWithConfig(display,
+                                                           cfgs[chosenIndex],
+                                                           xsurface->
+                                                             XDrawable());
+    }
     if (glxpixmap == 0) {
         return nsnull;
     }
 
     GLContextGLX *shareContext = aShare ? GetGlobalContextGLX() : nsnull;
 
     nsRefPtr<GLContextGLX> glContext = GLContextGLX::CreateGLContext(aFormat,
                                                                      display,
diff --git a/gfx/thebes/GLXLibrary.h b/gfx/thebes/GLXLibrary.h
--- a/gfx/thebes/GLXLibrary.h
+++ b/gfx/thebes/GLXLibrary.h
@@ -94,16 +94,21 @@ public:
                                                                  int);
     PFNGLXQUERYSERVERSTRING xQueryServerString;
 
     typedef GLXPixmap (GLAPIENTRY * PFNGLXCREATEPIXMAP) (Display *,
                                                          GLXFBConfig,
                                                          Pixmap,
                                                          const int *);
     PFNGLXCREATEPIXMAP xCreatePixmap;
+    typedef GLXPixmap (GLAPIENTRY * PFNGLXCREATEGLXPIXMAPWITHCONFIG)
+                                                        (Display *,
+                                                         GLXFBConfig,
+                                                         Pixmap);
+    PFNGLXCREATEGLXPIXMAPWITHCONFIG xCreateGLXPixmapWithConfig;
     typedef void (GLAPIENTRY * PFNGLXDESTROYPIXMAP) (Display *,
                                                      GLXPixmap);
     PFNGLXDESTROYPIXMAP xDestroyPixmap;
     typedef const char * (GLAPIENTRY * PFNGLXGETCLIENTSTRING) (Display *,
                                                                int);
     PFNGLXGETCLIENTSTRING xGetClientString;
     typedef GLXContext (GLAPIENTRY * PFNGLXCREATECONTEXT) (Display *,
                                                            XVisualInfo *,
