From: L. David Baron <dbaron@dbaron.org>

Revert 9ef12a27ab14 and c87e6a6a41bb (patches 6 and 7 from bug 435441) which are no longer needed after bug 520396.

diff --git a/layout/style/nsHTMLStyleSheet.cpp b/layout/style/nsHTMLStyleSheet.cpp
--- a/layout/style/nsHTMLStyleSheet.cpp
+++ b/layout/style/nsHTMLStyleSheet.cpp
@@ -187,111 +187,106 @@ ProcessTableRulesAttribute(void*       a
         borderData->SetBorderColor(aSide, borderColor);
       }
       // set the border width to be 1 pixel
       borderData->SetBorderWidth(aSide, nsPresContext::CSSPixelsToAppUnits(1));
     }
   }
 }
 
-static void TbodyPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData, nsIStyleRule* aStyleRule)
+static void TbodyPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData)
 {
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_TOP, PR_TRUE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_GROUPS, NS_STYLE_TABLE_RULES_ROWS);
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_BOTTOM, PR_TRUE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_GROUPS, NS_STYLE_TABLE_RULES_ROWS);
 }
 
 NS_IMETHODIMP
 nsHTMLStyleSheet::TableTbodyRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Border)) {
     aRuleData->mCanStoreInRuleTree = PR_FALSE;
-    nsPostResolveCallback prc = { &TbodyPostResolveCallback, this };
-    aRuleData->mPostResolveCallbacks.AppendElement(prc);
+    aRuleData->mPostResolveCallback = &TbodyPostResolveCallback;
   }
   return NS_OK;
 }
 // -----------------------------------------------------------
 
-static void RowPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData, nsIStyleRule* aStyleRule)
+static void RowPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData)
 {
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_TOP, PR_FALSE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_ROWS, NS_STYLE_TABLE_RULES_ROWS);
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_BOTTOM, PR_FALSE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_ROWS, NS_STYLE_TABLE_RULES_ROWS);
 }
 
 NS_IMETHODIMP
 nsHTMLStyleSheet::TableRowRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Border)) {
     aRuleData->mCanStoreInRuleTree = PR_FALSE;
-    nsPostResolveCallback prc = { &RowPostResolveCallback, this };
-    aRuleData->mPostResolveCallbacks.AppendElement(prc);
+    aRuleData->mPostResolveCallback = &RowPostResolveCallback;
   }
   return NS_OK;
 }
 
-static void ColgroupPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData, nsIStyleRule* aStyleRule)
+static void ColgroupPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData)
 {
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_LEFT, PR_TRUE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_GROUPS, NS_STYLE_TABLE_RULES_COLS);
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_RIGHT, PR_TRUE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_GROUPS, NS_STYLE_TABLE_RULES_COLS);
 }
 
 NS_IMETHODIMP
 nsHTMLStyleSheet::TableColgroupRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Border)) {
     aRuleData->mCanStoreInRuleTree = PR_FALSE;
-    nsPostResolveCallback prc = { &ColgroupPostResolveCallback, this };
-    aRuleData->mPostResolveCallbacks.AppendElement(prc);
+    aRuleData->mPostResolveCallback = &ColgroupPostResolveCallback;
   }
   return NS_OK;
 }
 
-static void ColPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData, nsIStyleRule* aStyleRule)
+static void ColPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData)
 {
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_LEFT, PR_FALSE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_COLS, NS_STYLE_TABLE_RULES_COLS);
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_RIGHT, PR_FALSE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_COLS, NS_STYLE_TABLE_RULES_COLS);
 }
 
 static void UngroupedColPostResolveCallback(void* aStyleStruct,
-                                            nsRuleData* aRuleData, nsIStyleRule* aStyleRule)
+                                            nsRuleData* aRuleData)
 {
   // Pass PR_TRUE for aGroup, so that we find the table's style
   // context correctly.
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_LEFT, PR_TRUE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_COLS, NS_STYLE_TABLE_RULES_COLS);
   ::ProcessTableRulesAttribute(aStyleStruct, aRuleData, NS_SIDE_RIGHT, PR_TRUE, NS_STYLE_TABLE_RULES_ALL,
                                NS_STYLE_TABLE_RULES_COLS, NS_STYLE_TABLE_RULES_COLS);
 }
 
 NS_IMETHODIMP
 nsHTMLStyleSheet::TableColRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Border)) {
     aRuleData->mCanStoreInRuleTree = PR_FALSE;
-    nsPostResolveCallback prc = { &ColPostResolveCallback, this };
-    aRuleData->mPostResolveCallbacks.AppendElement(prc);
+    aRuleData->mPostResolveCallback = &ColPostResolveCallback;
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsHTMLStyleSheet::TableUngroupedColRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Border)) {
     aRuleData->mCanStoreInRuleTree = PR_FALSE;
-    nsPostResolveCallback prc = { &UngroupedColPostResolveCallback, this };
-    aRuleData->mPostResolveCallbacks.AppendElement(prc);
+    aRuleData->mPostResolveCallback = &UngroupedColPostResolveCallback;
   }
   return NS_OK;
 }
 // -----------------------------------------------------------
 
 struct MappedAttrTableEntry : public PLDHashEntryHdr {
   nsMappedAttributes *mAttributes;
 };
diff --git a/layout/style/nsRuleData.h b/layout/style/nsRuleData.h
--- a/layout/style/nsRuleData.h
+++ b/layout/style/nsRuleData.h
@@ -41,40 +41,31 @@
  * hold data from matched rules during style data computation 
  */
 
 #ifndef nsRuleData_h_
 #define nsRuleData_h_
 
 #include "nsCSSStruct.h"
 #include "nsStyleStructFwd.h"
-#include "nsTArray.h"
 class nsPresContext;
 class nsStyleContext;
 
 struct nsRuleData;
-typedef void (*nsPostResolveFunc)(void* aStyleStruct, nsRuleData* aData,
-                                  nsIStyleRule* aRule);
-
-struct nsPostResolveCallback {
-  nsPostResolveFunc mFunc;
-  nsIStyleRule *mRule;
-};
+typedef void (*nsPostResolveFunc)(void* aStyleStruct, nsRuleData* aData);
 
 struct nsRuleData
 {
   PRUint32 mSIDs;
   PRPackedBool mCanStoreInRuleTree;
   PRPackedBool mIsImportantRule;
   PRUint8 mLevel; // an nsStyleSet::sheetType
   nsPresContext* mPresContext;
   nsStyleContext* mStyleContext;
-  // MapRuleInfoInto should append to this array, so it is ordered from
-  // most specific to least.
-  nsTArray<nsPostResolveCallback> mPostResolveCallbacks;
+  nsPostResolveFunc mPostResolveCallback;
   nsRuleDataFont* mFontData; // Should always be stack-allocated! We don't own these structures!
   nsRuleDataDisplay* mDisplayData;
   nsRuleDataMargin* mMarginData;
   nsRuleDataList* mListData;
   nsRuleDataPosition* mPositionData;
   nsRuleDataTable* mTableData;
   nsRuleDataColor* mColorData;
   nsRuleDataContent* mContentData;
@@ -84,17 +75,17 @@ struct nsRuleData
 
 #ifdef MOZ_SVG
   nsRuleDataSVG* mSVGData;
 #endif
 
   nsRuleDataColumn* mColumnData;
 
   nsRuleData(PRUint32 aSIDs, nsPresContext* aContext, nsStyleContext* aStyleContext) 
-    :mSIDs(aSIDs), mPresContext(aContext), mStyleContext(aStyleContext),
+    :mSIDs(aSIDs), mPresContext(aContext), mStyleContext(aStyleContext), mPostResolveCallback(nsnull),
      mFontData(nsnull), mDisplayData(nsnull), mMarginData(nsnull), mListData(nsnull), 
      mPositionData(nsnull), mTableData(nsnull), mColorData(nsnull), mContentData(nsnull), mTextData(nsnull),
      mUserInterfaceData(nsnull), mColumnData(nsnull)
   {
     mCanStoreInRuleTree = PR_TRUE;
     mXULData = nsnull;
 #ifdef MOZ_SVG
     mSVGData = nsnull;
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -1947,27 +1947,26 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
   PRBool isReset = nsCachedStyleData::IsReset(aSID);
   if (!highestNode)
     highestNode = rootNode;
 
   if (!aRuleData->mCanStoreInRuleTree)
     detail = eRulePartialMixed; // Treat as though some data is specified to avoid
                                 // the optimizations and force data computation.
 
-  if (detail == eRuleNone && startStruct &&
-      aRuleData->mPostResolveCallbacks.IsEmpty()) {
+  if (detail == eRuleNone && startStruct && !aRuleData->mPostResolveCallback) {
     // We specified absolutely no rule information, but a parent rule in the tree
     // specified all the rule information.  We set a bit along the branch from our
     // node in the tree to the node that specified the data that tells nodes on that
     // branch that they never need to examine their rules for this particular struct type
     // ever again.
     PropagateDependentBit(bit, ruleNode);
     return startStruct;
   }
-  // FIXME Do we need to check for mPostResolveCallbacks?
+  // FIXME Do we need to check for mPostResolveCallback?
   if ((!startStruct && !isReset &&
        (detail == eRuleNone || detail == eRulePartialInherited)) ||
       detail == eRuleFullInherited) {
     // We specified no non-inherited information and neither did any of
     // our parent rules.
 
     // We set a bit along the branch from the highest node (ruleNode)
     // down to our node (this) indicating that no non-inherited data was
@@ -2012,24 +2011,19 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
 #define STYLE_STRUCT_TEST aSID
 #define STYLE_STRUCT(name, checkdata_cb, ctor_args)                           \
   res = Compute##name##Data(startStruct, *aSpecificData, aContext,            \
                       highestNode, detail, aRuleData->mCanStoreInRuleTree);
 #include "nsStyleStructList.h"
 #undef STYLE_STRUCT
 #undef STYLE_STRUCT_TEST
 
-  // If we have post-resolve callbacks, handle that now.
-  if (NS_LIKELY(res != nsnull)) {
-    // Enumerate from least to most specific rule.
-    for (PRUint32 i = aRuleData->mPostResolveCallbacks.Length(); i-- != 0; ) {
-      nsPostResolveCallback &prc = aRuleData->mPostResolveCallbacks[i];
-      (*prc.mFunc)(const_cast<void*>(res), aRuleData, prc.mRule);
-    }
-  }
+  // If we have a post-resolve callback, handle that now.
+  if (aRuleData->mPostResolveCallback && (NS_LIKELY(res != nsnull)))
+    (*aRuleData->mPostResolveCallback)(const_cast<void*>(res), aRuleData);
 
   // Now return the result.
   return res;
 }
 
 const void*
 nsRuleNode::SetDefaultOnRoot(const nsStyleStructID aSID, nsStyleContext* aContext)
 {
@@ -3012,22 +3006,19 @@ nsRuleNode::SetGenericFont(nsPresContext
     if (i != 0)
       fontData.mFamily.Reset();
 
     nsRuleNode::SetFont(aPresContext, context, aMinFontSize,
                         aGenericFontID, fontData, &parentFont, aFont,
                         PR_FALSE, dummy);
 
     // XXX Not sure if we need to do this here
-    // If we have post-resolve callbacks, handle that now.
-    // Enumerate from least to most specific rule.
-    for (PRUint32 j = ruleData.mPostResolveCallbacks.Length(); j-- != 0; ) {
-      nsPostResolveCallback &prc = ruleData.mPostResolveCallbacks[j];
-      (*prc.mFunc)(aFont, &ruleData, prc.mRule);
-    }
+    // If we have a post-resolve callback, handle that now.
+    if (ruleData.mPostResolveCallback)
+      (ruleData.mPostResolveCallback)(aFont, &ruleData);
 
     parentFont = *aFont;
   }
 }
 
 static PRBool ExtractGeneric(const nsString& aFamily, PRBool aGeneric,
                              void *aData)
 {
