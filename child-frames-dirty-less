From: L. David Baron <dbaron@dbaron.org>

Bug 1308876 - Experiment - Mark child frames as dirty before starting reflow of the parent, so that if we reflow a child twice, it's only dirty the first time.

MozReview-Commit-ID: GdOvPynqcFP

diff --git a/layout/generic/ReflowInput.cpp b/layout/generic/ReflowInput.cpp
--- a/layout/generic/ReflowInput.cpp
+++ b/layout/generic/ReflowInput.cpp
@@ -196,23 +196,16 @@ ReflowInput::ReflowInput(
   MOZ_ASSERT(aFrame, "no frame");
   MOZ_ASSERT(aPresContext == aFrame->PresContext(), "wrong pres context");
   NS_PRECONDITION(!mFlags.mSpecialBSizeReflow ||
                   !NS_SUBTREE_DIRTY(aFrame),
                   "frame should be clean when getting special bsize reflow");
 
   mParentReflowInput = &aParentReflowInput;
 
-  // If the parent is dirty, then the child is as well.
-  // XXX Are the other cases where the parent reflows a child a second
-  // time, as a resize?
-  if (!mFlags.mSpecialBSizeReflow)
-    mFrame->AddStateBits(mParentReflowInput->mFrame->GetStateBits() &
-                        NS_FRAME_IS_DIRTY);
-
   AvailableISize() = aAvailableSpace.ISize(mWritingMode);
   AvailableBSize() = aAvailableSpace.BSize(mWritingMode);
 
   if (mWritingMode.IsOrthogonalTo(aParentReflowInput.GetWritingMode())) {
     // If we're setting up for an orthogonal flow, and the parent reflow state
     // had a constrained ComputedBSize, we can use that as our AvailableISize
     // in preference to leaving it unconstrained.
     if (AvailableISize() == NS_UNCONSTRAINEDSIZE &&
@@ -355,16 +348,31 @@ ReflowInput::SetComputedHeight(nscoord a
 }
 
 void
 ReflowInput::Init(nsPresContext*     aPresContext,
                         const LogicalSize* aContainingBlockSize,
                         const nsMargin*    aBorder,
                         const nsMargin*    aPadding)
 {
+  if (mFrame->GetStateBits() & NS_FRAME_IS_DIRTY) {
+    // Mark all child frames as dirty.
+    // FIXME: It would be better for memory locality if we did this as
+    // we went.  However, we need to be careful not to do this twice for
+    // any particular child if we reflow it twice.  The easiest way to
+    // accomplish that is to do it at the start.
+    for (nsIFrame::ChildListIterator childLists(mFrame);
+         !childLists.IsDone(); childLists.Next()) {
+      for (nsFrameList::Enumerator childFrames(childLists.CurrentList());
+           !childFrames.AtEnd(); childFrames.Next()) {
+        childFrames.get()->AddStateBits(NS_FRAME_IS_DIRTY);
+      }
+    }
+  }
+
   if (AvailableISize() == NS_UNCONSTRAINEDSIZE) {
     // Look up the parent chain for an orthogonal inline limit,
     // and reset AvailableISize() if found.
     for (const ReflowInput *parent = mParentReflowInput;
          parent != nullptr; parent = parent->mParentReflowInput) {
       if (parent->GetWritingMode().IsOrthogonalTo(mWritingMode) &&
           parent->mOrthogonalLimit != NS_UNCONSTRAINEDSIZE) {
         AvailableISize() = parent->mOrthogonalLimit;
