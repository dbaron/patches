From: L. David Baron <dbaron@dbaron.org>

Bug 996796 patch 2 - Change the public API to updating main-thread-suppressed animation styles (miniflush) in preparation for refactoring how it works.

Later patches will combine the coalescing of restyling between the
miniflush performed for animations and for transitions into a single
RestyleTracker, which will coalesce the work better.  This patch changes
the API exposed for doing that so that the coalescing patch will contain
only the internals.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1432,18 +1432,17 @@ RestyleManager::ProcessPendingRestyles()
   // Before we process any restyles, we need to ensure that style
   // resulting from any throttled animations (animations that we're
   // running entirely on the compositor thread) is up-to-date, so that
   // if any style changes we cause trigger transitions, we have the
   // correct old style for starting the transition.
   if (nsLayoutUtils::AreAsyncAnimationsEnabled() &&
       mPendingRestyles.Count() > 0) {
     ++mAnimationGeneration;
-    mPresContext->TransitionManager()->UpdateAllThrottledStyles();
-    mPresContext->AnimationManager()->UpdateAllThrottledStyles();
+    UpdateOnlyAnimationStyles();
   }
 
   mPendingRestyles.ProcessRestyles();
 
 #ifdef DEBUG
   uint32_t oldPendingRestyleCount = mPendingRestyles.Count();
 #endif
 
@@ -1494,16 +1493,23 @@ RestyleManager::EndProcessingRestyles()
   mPresContext->FrameConstructor()->EndUpdate();
 
 #ifdef DEBUG
   mPresContext->PresShell()->VerifyStyleTree();
 #endif
 }
 
 void
+RestyleManager::UpdateOnlyAnimationStyles()
+{
+  mPresContext->TransitionManager()->UpdateAllThrottledStyles();
+  mPresContext->AnimationManager()->UpdateAllThrottledStyles();
+}
+
+void
 RestyleManager::PostRestyleEventCommon(Element* aElement,
                                        nsRestyleHint aRestyleHint,
                                        nsChangeHint aMinChangeHint,
                                        bool aForAnimation)
 {
   if (MOZ_UNLIKELY(mPresContext->PresShell()->IsDestroying())) {
     return;
   }
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -155,16 +155,22 @@ public:
   void ProcessPendingRestyles();
 
   // ProcessPendingRestyles calls into one of our RestyleTracker
   // objects.  It then calls back to these functions at the beginning
   // and end of its work.
   void BeginProcessingRestyles();
   void EndProcessingRestyles();
 
+  // Update styles for animations that are running on the compositor and
+  // whose updating is suppressed on the main thread (to save
+  // unnecessary work), while leaving all other aspects of style
+  // out-of-date.
+  void UpdateOnlyAnimationStyles();
+
   // Rebuilds all style data by throwing out the old rule tree and
   // building a new one, and additionally applying aExtraHint (which
   // must not contain nsChangeHint_ReconstructFrame) to the root frame.
   void RebuildAllStyleData(nsChangeHint aExtraHint);
 
   // Helper that does part of the work of RebuildAllStyleData, shared by
   // RestyleElement for 'rem' handling.
   void DoRebuildAllStyleData(RestyleTracker& aRestyleTracker,
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -6654,18 +6654,17 @@ nsIFrame* GetNearestFrameContainingPresS
 
 static bool
 FlushThrottledStyles(nsIDocument *aDocument, void *aData)
 {
   nsIPresShell* shell = aDocument->GetShell();
   if (shell && shell->IsVisible()) {
     nsPresContext* presContext = shell->GetPresContext();
     if (presContext) {
-      presContext->TransitionManager()->UpdateAllThrottledStyles();
-      presContext->AnimationManager()->UpdateAllThrottledStyles();
+      presContext->RestyleManager()->UpdateOnlyAnimationStyles();
     }
   }
 
   return true;
 }
 
 static nsresult
 DispatchPointerFromMouseOrTouch(PresShell* aShell,
