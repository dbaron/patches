From: L. David Baron <dbaron@dbaron.org>

Bug 898209 patch 1:  Add ElementRestyler class to begin refactoring ReResolveStyleContext.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1688,17 +1688,17 @@ ElementForStyleContext(nsIContent* aPare
                        nsCSSPseudoElements::Type aPseudoType)
 {
   // We don't expect XUL tree stuff here.
   NS_PRECONDITION(aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ||
                   aPseudoType == nsCSSPseudoElements::ePseudo_AnonBox ||
                   aPseudoType < nsCSSPseudoElements::ePseudo_PseudoElementCount,
                   "Unexpected pseudo");
   // XXX see the comments about the various element confusion in
-  // ReResolveStyleContext.
+  // ElementRestyler::Restyle.
   if (aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
     return aFrame->GetContent()->AsElement();
   }
 
   if (aPseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
     return nullptr;
   }
 
@@ -1931,24 +1931,41 @@ RestyleManager::ReparentStyleContext(nsI
         VerifyStyleTree(mPresContext, aFrame, newParentContext);
 #endif
       }
     }
   }
   return NS_OK;
 }
 
-static void
-CaptureChange(nsStyleContext* aOldContext, nsStyleContext* aNewContext,
-              nsIFrame* aFrame, nsIContent* aContent,
-              nsStyleChangeList* aChangeList,
-              /*inout*/nsChangeHint &aMinChange,
-              /*in*/nsChangeHint aParentHintsNotHandledForDescendants,
-              /*out*/nsChangeHint &aHintsNotHandledForDescendants,
-              nsChangeHint aChangeToAssume)
+ElementRestyler::ElementRestyler(nsPresContext* aPresContext)
+  : mPresContext(aPresContext)
+{
+}
+
+ElementRestyler::ElementRestyler(const ElementRestyler& aParentRestyler)
+  : mPresContext(aParentRestyler.mPresContext)
+{
+}
+
+ElementRestyler::ElementRestyler(ParentContextFromChildFrame,
+                                 const ElementRestyler& aParentRestyler)
+  : mPresContext(aParentRestyler.mPresContext)
+{
+}
+
+void
+ElementRestyler::CaptureChange(nsStyleContext* aOldContext,
+                               nsStyleContext* aNewContext,
+                               nsIFrame* aFrame, nsIContent* aContent,
+                               nsStyleChangeList* aChangeList,
+                               /*inout*/nsChangeHint &aMinChange,
+                               /*in*/nsChangeHint aParentHintsNotHandledForDescendants,
+                               /*out*/nsChangeHint &aHintsNotHandledForDescendants,
+                               nsChangeHint aChangeToAssume)
 {
   nsChangeHint ourChange = aOldContext->CalcStyleDifference(aNewContext,
                              aParentHintsNotHandledForDescendants);
   NS_ASSERTION(!(ourChange & nsChangeHint_AllReflowHints) ||
                (ourChange & nsChangeHint_NeedReflow),
                "Reflow hint bits set without actually asking for a reflow");
 
   // nsChangeHint_UpdateEffects is inherited, but it can be set due to changes
@@ -1975,27 +1992,27 @@ CaptureChange(nsStyleContext* aOldContex
  * context.  This means that, for pseudo-elements, it is the content
  * that should be used for selector matching (rather than the fake
  * content node attached to the frame).
  *
  * For aParentFrameHintsNotHandledForDescendants, see
  * nsStyleContext::CalcStyleDifference.
  */
 nsChangeHint
-RestyleManager::ReResolveStyleContext(nsPresContext     *aPresContext,
-                                      nsIFrame          *aFrame,
-                                      nsIContent        *aParentContent,
-                                      nsStyleChangeList *aChangeList,
-                                      nsChangeHint       aMinChange,
-                                      nsChangeHint       aParentFrameHintsNotHandledForDescendants,
-                                      nsRestyleHint      aRestyleHint,
-                                      RestyleTracker&    aRestyleTracker,
-                                      DesiredA11yNotifications aDesiredA11yNotifications,
-                                      nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
-                                      TreeMatchContext &aTreeMatchContext)
+ElementRestyler::Restyle(nsPresContext     *aPresContext,
+                         nsIFrame          *aFrame,
+                         nsIContent        *aParentContent,
+                         nsStyleChangeList *aChangeList,
+                         nsChangeHint       aMinChange,
+                         nsChangeHint       aParentFrameHintsNotHandledForDescendants,
+                         nsRestyleHint      aRestyleHint,
+                         RestyleTracker&    aRestyleTracker,
+                         DesiredA11yNotifications aDesiredA11yNotifications,
+                         nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
+                         TreeMatchContext &aTreeMatchContext)
 {
   // We need to generate a new change list entry for every frame whose style
   // comparision returns one of these hints. These hints don't automatically
   // update all their descendant frames.
   aMinChange = NS_SubtractHint(aMinChange, NS_HintsNotHandledForDescendantsIn(aMinChange));
 
   // It would be nice if we could make stronger assertions here; they
   // would let us simplify the ?: expressions below setting |content|
@@ -2079,17 +2096,19 @@ RestyleManager::ReResolveStyleContext(ns
 
       // assumeDifferenceHint forces the parent's change to be also
       // applied to this frame, no matter what
       // nsStyleContext::CalcStyleDifference says. CalcStyleDifference
       // can't be trusted because it assumes any changes to the parent
       // style context provider will be automatically propagated to
       // the frame(s) with child style contexts.
 
-      assumeDifferenceHint = ReResolveStyleContext(aPresContext, providerFrame,
+      ElementRestyler providerRestyler(PARENT_CONTEXT_FROM_CHILD_FRAME,
+                                       *this);
+      assumeDifferenceHint = providerRestyler.Restyle(aPresContext, providerFrame,
                                                    aParentContent, aChangeList,
                                                    aMinChange,
                                                    nsChangeHint_Hints_NotHandledForDescendants,
                                                    aRestyleHint,
                                                    aRestyleTracker,
                                                    aDesiredA11yNotifications,
                                                    aVisibleKidsOfHiddenElement,
                                                    aTreeMatchContext);
@@ -2327,17 +2346,17 @@ RestyleManager::ReResolveStyleContext(ns
 
     // now look for undisplayed child content and pseudos
 
     // When the root element is display:none, we still construct *some*
     // frames that have the root element as their mContent, down to the
     // DocElementContainingBlock.
     bool checkUndisplayed;
     nsIContent* undisplayedParent;
-    nsCSSFrameConstructor* frameConstructor = FrameConstructor();
+    nsCSSFrameConstructor* frameConstructor = mPresContext->FrameConstructor();
     if (pseudoTag) {
       checkUndisplayed = aFrame == frameConstructor->
                                      GetDocElementContainingBlock();
       undisplayedParent = nullptr;
     } else {
       checkUndisplayed = !!localContent;
       undisplayedParent = localContent;
     }
@@ -2553,42 +2572,45 @@ RestyleManager::ReResolveStyleContext(ns
               // the <body> would miss reflowing fixed-pos nodes that also need
               // reflow).  In the cases when the out-of-flow _is_ a geometric
               // descendant of a frame we already have a reflow hint for,
               // reflow coalescing should keep us from doing the work twice.
 
               // |nsFrame::GetParentStyleContextFrame| checks being out
               // of flow so that this works correctly.
               do {
-                ReResolveStyleContext(aPresContext, outOfFlowFrame,
+                ElementRestyler oofRestyler(*this);
+                oofRestyler.Restyle(aPresContext, outOfFlowFrame,
                                       content, aChangeList,
                                       NS_SubtractHint(aMinChange,
                                                       nsChangeHint_AllReflowHints),
                                       nonInheritedHints,
                                       childRestyleHint,
                                       aRestyleTracker,
                                       kidsDesiredA11yNotification,
                                       aVisibleKidsOfHiddenElement,
                                       aTreeMatchContext);
               } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
 
               // reresolve placeholder's context under the same parent
               // as the out-of-flow frame
-              ReResolveStyleContext(aPresContext, child, content,
+              ElementRestyler phRestyler(*this);
+              phRestyler.Restyle(aPresContext, child, content,
                                     aChangeList, aMinChange,
                                     nonInheritedHints,
                                     childRestyleHint,
                                     aRestyleTracker,
                                     kidsDesiredA11yNotification,
                                     aVisibleKidsOfHiddenElement,
                                     aTreeMatchContext);
             }
             else {  // regular child frame
               if (child != resolvedChild) {
-                ReResolveStyleContext(aPresContext, child, content,
+                ElementRestyler childRestyler(*this);
+                childRestyler.Restyle(aPresContext, child, content,
                                       aChangeList, aMinChange,
                                       nonInheritedHints,
                                       childRestyleHint,
                                       aRestyleTracker,
                                       kidsDesiredA11yNotification,
                                       aVisibleKidsOfHiddenElement,
                                       aTreeMatchContext);
               }
@@ -2666,23 +2688,25 @@ RestyleManager::ComputeStyleChangeFor(ns
   Element *parentElement =
     parent && parent->IsElement() ? parent->AsElement() : nullptr;
   treeMatchContext.InitAncestors(parentElement);
   nsTArray<nsIContent*> visibleKidsOfHiddenElement;
   do {
     // Outer loop over special siblings
     do {
       // Inner loop over next-in-flows of the current frame
+      ElementRestyler restyler(mPresContext);
+
       nsChangeHint frameChange =
-        ReResolveStyleContext(mPresContext, frame, nullptr,
+        restyler.Restyle(mPresContext, frame, nullptr,
                               aChangeList, aMinChange, nsChangeHint(0),
                               aRestyleDescendants ?
                                 eRestyle_Subtree : eRestyle_Self,
                               aRestyleTracker,
-                              eSendAllNotifications,
+                              ElementRestyler::eSendAllNotifications,
                               visibleKidsOfHiddenElement,
                               treeMatchContext);
 
       if (frameChange & nsChangeHint_ReconstructFrame) {
         // If it's going to cause a framechange, then don't bother
         // with the continuations or special siblings since they'll be
         // clobbered by the frame reconstruct anyway.
         NS_ASSERTION(!frame->GetPrevContinuation(),
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -21,17 +21,17 @@ class nsIFrame;
 struct TreeMatchContext;
 
 namespace mozilla {
 
 namespace dom {
   class Element;
 } // namespace dom
 
-class RestyleManager {
+class RestyleManager MOZ_FINAL {
 public:
   friend class ::nsRefreshDriver;
   friend class RestyleTracker;
 
   typedef mozilla::dom::Element Element;
 
   RestyleManager(nsPresContext* aPresContext);
 
@@ -186,46 +186,16 @@ public:
   }
 
   void FlushOverflowChangedTracker()
   {
     mOverflowChangedTracker.Flush();
   }
 
 private:
-  enum DesiredA11yNotifications {
-    eSkipNotifications,
-    eSendAllNotifications,
-    eNotifyIfShown
-  };
-
-  enum A11yNotificationType {
-    eDontNotify,
-    eNotifyShown,
-    eNotifyHidden
-  };
-
-  // Use eRestyle_Self for the aRestyleHint argument to mean
-  // "reresolve our style context but not kids", use eRestyle_Subtree
-  // to mean "reresolve our style context and kids", and use
-  // nsRestyleHint(0) to mean recompute a new style context for our
-  // current parent and existing rulenode, and the same for kids.
-  NS_HIDDEN_(nsChangeHint)
-    ReResolveStyleContext(nsPresContext* aPresContext,
-                          nsIFrame* aFrame,
-                          nsIContent* aParentContent,
-                          nsStyleChangeList* aChangeList,
-                          nsChangeHint aMinChange,
-                          nsChangeHint aParentFrameHintsNotHandledForDescendants,
-                          nsRestyleHint aRestyleHint,
-                          RestyleTracker& aRestyleTracker,
-                          DesiredA11yNotifications aDesiredA11yNotifications,
-                          nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
-                          TreeMatchContext& aTreeMatchContext);
-
   /**
    * Notify the frame constructor that an element needs to have its
    * style recomputed.
    * @param aElement: The element to be restyled.
    * @param aRestyleHint: Which nodes need to have selector matching run
    *                      on them.
    * @param aMinChangeHint: A minimum change hint for aContent and its
    *                        descendants.
@@ -293,11 +263,84 @@ private:
   // The total number of animation flushes by this frame constructor.
   // Used to keep the layer and animation manager in sync.
   uint64_t mAnimationGeneration;
 
   RestyleTracker mPendingRestyles;
   RestyleTracker mPendingAnimationRestyles;
 };
 
+/**
+ * An ElementRestyler is created for *each* element in a subtree that we
+ * recompute styles for.
+ */
+class ElementRestyler MOZ_FINAL {
+public:
+  typedef mozilla::dom::Element Element;
+
+  // Construct for the root of the subtree that we're restyling.
+  ElementRestyler(nsPresContext* aPresContext);
+
+  // Construct for an element whose parent is being restyled.
+  ElementRestyler(const ElementRestyler& aParentRestyler);
+
+  // Construct for an frame whose parent is being restyled, but which
+  // provides the parent style context for its parent frame.  (This is
+  // only used for table frames, which are the parent style context for
+  // the outer table frame (table wrapper frame).  We should probably
+  // try to get rid of this exception and have the inheritance go the
+  // other way.)
+  enum ParentContextFromChildFrame { PARENT_CONTEXT_FROM_CHILD_FRAME };
+  ElementRestyler(ParentContextFromChildFrame,
+                  const ElementRestyler& aParentFrameRestyler);
+
+public: // FIXME: private
+  enum DesiredA11yNotifications {
+    eSkipNotifications,
+    eSendAllNotifications,
+    eNotifyIfShown
+  };
+
+  enum A11yNotificationType {
+    eDontNotify,
+    eNotifyShown,
+    eNotifyHidden
+  };
+
+public:
+  /**
+   * Restyle our frame's element and its subtree.
+   *
+   * Use eRestyle_Self for the aRestyleHint argument to mean
+   * "reresolve our style context but not kids", use eRestyle_Subtree
+   * to mean "reresolve our style context and kids", and use
+   * nsRestyleHint(0) to mean recompute a new style context for our
+   * current parent and existing rulenode, and the same for kids.
+   */
+  nsChangeHint Restyle(nsPresContext     *aPresContext,
+               nsIFrame          *aFrame,
+               nsIContent        *aParentContent,
+               nsStyleChangeList *aChangeList,
+               nsChangeHint       aMinChange,
+               nsChangeHint       aParentFrameHintsNotHandledForDescendants,
+               nsRestyleHint      aRestyleHint,
+               RestyleTracker&    aRestyleTracker,
+               DesiredA11yNotifications aDesiredA11yNotifications,
+               nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
+               TreeMatchContext &aTreeMatchContext);
+
+private:
+  void CaptureChange(nsStyleContext* aOldContext,
+                     nsStyleContext* aNewContext,
+                     nsIFrame* aFrame, nsIContent* aContent,
+                     nsStyleChangeList* aChangeList,
+                     /*inout*/nsChangeHint &aMinChange,
+                     /*in*/nsChangeHint aParentHintsNotHandledForDescendants,
+                     /*out*/nsChangeHint &aHintsNotHandledForDescendants,
+                     nsChangeHint aChangeToAssume);
+
+private:
+  nsPresContext* const mPresContext;
+};
+
 } // namespace mozilla
 
 #endif /* mozilla_RestyleManager_h */
