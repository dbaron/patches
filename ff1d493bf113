
# HG changeset patch
# User Boris Zbarsky <bzbarsky@mit.edu>
# Date 1318368552 14400
# Node ID ff1d493bf11316977b54ee912b26ad4841d70e92
# Parent  c7b4452ef1d2d7ba6fa2673cbfc7621e4b9d7c4f
Bug 693219.  Don't use TimeDuration methods from static constructors.  r=roc

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -2150,18 +2150,19 @@ static PRUint32 sInterruptMaxCounter = 1
 // Used for the "counter" mode.  This counts up to sInterruptMaxCounter and is
 // then reset to 0.
 static PRUint32 sInterruptCounter;
 // Number of interrupt checks to skip before really trying to interrupt.
 // Controlled by the GECKO_REFLOW_INTERRUPT_CHECKS_TO_SKIP env var.
 static PRUint32 sInterruptChecksToSkip = 200;
 // Number of milliseconds that a reflow should be allowed to run for before we
 // actually allow interruption.  Controlled by the
-// GECKO_REFLOW_MIN_NOINTERRUPT_DURATION env var.
-static TimeDuration sInterruptTimeout = TimeDuration::FromMilliseconds(100);
+// GECKO_REFLOW_MIN_NOINTERRUPT_DURATION env var.  Can't be initialized here,
+// because TimeDuration/TimeStamp is not safe to use in static constructors..
+static TimeDuration sInterruptTimeout;
 
 static void GetInterruptEnv()
 {
   char *ev = PR_GetEnv("GECKO_REFLOW_INTERRUPT_MODE");
   if (ev) {
 #ifndef XP_WIN
     if (PL_strcasecmp(ev, "random") == 0) {
       ev = PR_GetEnv("GECKO_REFLOW_INTERRUPT_SEED");
@@ -2182,19 +2183,18 @@ static void GetInterruptEnv()
     }
   }
   ev = PR_GetEnv("GECKO_REFLOW_INTERRUPT_CHECKS_TO_SKIP");
   if (ev) {
     sInterruptChecksToSkip = atoi(ev);
   }
 
   ev = PR_GetEnv("GECKO_REFLOW_MIN_NOINTERRUPT_DURATION");
-  if (ev) {
-    sInterruptTimeout = TimeDuration::FromMilliseconds(atoi(ev));
-  }
+  int duration_ms = ev ? atoi(ev) : 100;
+  sInterruptTimeout = TimeDuration::FromMilliseconds(duration_ms);
 }
 
 bool
 nsPresContext::HavePendingInputEvent()
 {
   switch (sInterruptMode) {
 #ifndef XP_WIN
     case ModeRandom:

