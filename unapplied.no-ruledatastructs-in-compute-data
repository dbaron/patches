From: L. David Baron <dbaron@dbaron.org>

Stop using nsRuleData* structs in nsRuleNode::Compute*Data.  (Bug 636039)

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -2108,17 +2108,17 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
       // come from the pres context.
       return SetDefaultOnRoot(aSID, aContext);
   }
 
   // We need to compute the data from the information that the rules specified.
   const void* res;
 #define STYLE_STRUCT_TEST aSID
 #define STYLE_STRUCT(name, checkdata_cb, ctor_args)                           \
-  res = Compute##name##Data(startStruct, *aSpecificData, aContext,            \
+  res = Compute##name##Data(startStruct, aRuleData, aContext,                 \
                       highestNode, detail, aRuleData->mCanStoreInRuleTree);
 #include "nsStyleStructList.h"
 #undef STYLE_STRUCT
 #undef STYLE_STRUCT_TEST
 
   // If we have a post-resolve callback, handle that now.
   if (aRuleData->mPostResolveCallback && (NS_LIKELY(res != nsnull)))
     (*aRuleData->mPostResolveCallback)(const_cast<void*>(res), aRuleData);
@@ -2410,18 +2410,16 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
  * @param rdata_ Variable (declared here) holding the nsCSS* used here.
  */
 #define COMPUTE_START_INHERITED(type_, ctorargs_, data_, parentdata_, rdtype_, rdata_) \
   NS_ASSERTION(aRuleDetail != eRuleFullInherited,                             \
                "should not have bothered calling Compute*Data");              \
                                                                               \
   nsStyleContext* parentContext = aContext->GetParent();                      \
                                                                               \
-  const nsRuleData##rdtype_& rdata_ =                                         \
-    static_cast<const nsRuleData##rdtype_&>(aData);                           \
   nsStyle##type_* data_ = nsnull;                                             \
   const nsStyle##type_* parentdata_ = nsnull;                                 \
   PRBool canStoreInRuleTree = aCanStoreInRuleTree;                            \
                                                                               \
   /* If |canStoreInRuleTree| might be true by the time we're done, we */      \
   /* can't call parentContext->GetStyle##type_() since it could recur into */ \
   /* setting the same struct on the same rule node, causing a leak. */        \
   if (parentContext && aRuleDetail != eRuleFullReset &&                       \
@@ -2471,18 +2469,16 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
   nsStyleContext* parentContext = aContext->GetParent();                      \
   /* Reset structs don't inherit from first-line */                           \
   /* See similar code in WalkRuleTree */                                      \
   while (parentContext &&                                                     \
          parentContext->GetPseudo() == nsCSSPseudoElements::firstLine) {      \
     parentContext = parentContext->GetParent();                               \
   }                                                                           \
                                                                               \
-  const nsRuleData##rdtype_& rdata_ =                                         \
-    static_cast<const nsRuleData##rdtype_&>(aData);                           \
   nsStyle##type_* data_;                                                      \
   if (aStartStruct)                                                           \
     /* We only need to compute the delta between this computed data and */    \
     /* our computed data. */                                                  \
     data_ = new (mPresContext)                                                \
             nsStyle##type_(*static_cast<nsStyle##type_*>(aStartStruct));      \
   else                                                                        \
     data_ = new (mPresContext) nsStyle##type_ ctorargs_;                      \
@@ -2684,32 +2680,33 @@ struct SetFontSizeCalcOps : public css::
     }
 
     return size;
   }
 };
 
 /* static */ void
 nsRuleNode::SetFontSize(nsPresContext* aPresContext,
-                        const nsRuleDataFont& aFontData,
+                        const nsRuleData* aRuleData,
                         const nsStyleFont* aFont,
                         const nsStyleFont* aParentFont,
                         nscoord* aSize,
                         const nsFont& aSystemFont,
                         nscoord aParentSize,
                         nscoord aScriptLevelAdjustedParentSize,
                         PRBool aUsedStartStruct,
                         PRBool aAtRoot,
                         PRBool& aCanStoreInRuleTree)
 {
   PRBool zoom = PR_FALSE;
   PRInt32 baseSize = (PRInt32) aPresContext->
     GetDefaultFont(aFont->mGenericID)->size;
-  if (eCSSUnit_Enumerated == aFontData.mSize.GetUnit()) {
-    PRInt32 value = aFontData.mSize.GetIntValue();
+  const nsCSSValue* sizeValue = aRuleData->ValueForFontSize();
+  if (eCSSUnit_Enumerated == sizeValue->GetUnit()) {
+    PRInt32 value = sizeValue->GetIntValue();
     PRInt32 scaler = aPresContext->FontScaler();
     float scaleFactor = nsStyleUtil::GetScalingFactor(scaler);
 
     zoom = PR_TRUE;
     if ((NS_STYLE_FONT_SIZE_XXSMALL <= value) &&
         (value <= NS_STYLE_FONT_SIZE_XXLARGE)) {
       *aSize = nsStyleUtil::CalcFontPointSize(value, baseSize,
                        scaleFactor, aPresContext, eFontSize_CSS);
@@ -2743,51 +2740,51 @@ nsRuleNode::SetFontSize(nsPresContext* a
         NS_ASSERTION(*aSize < parentSize ||
                      parentSize <= nsPresContext::CSSPixelsToAppUnits(1),
                      "FindNextSmallerFontSize failed");
       }
     } else {
       NS_NOTREACHED("unexpected value");
     }
   }
-  else if (aFontData.mSize.IsLengthUnit() ||
-           aFontData.mSize.GetUnit() == eCSSUnit_Percent ||
-           aFontData.mSize.IsCalcUnit()) {
+  else if (sizeValue->IsLengthUnit() ||
+           sizeValue->GetUnit() == eCSSUnit_Percent ||
+           sizeValue->IsCalcUnit()) {
     SetFontSizeCalcOps ops(aParentSize, aParentFont, aPresContext, aAtRoot,
                            aCanStoreInRuleTree);
-    *aSize = css::ComputeCalc(aFontData.mSize, ops);
+    *aSize = css::ComputeCalc(*sizeValue, ops);
     if (*aSize < 0) {
-      NS_ABORT_IF_FALSE(aFontData.mSize.IsCalcUnit(),
+      NS_ABORT_IF_FALSE(sizeValue->IsCalcUnit(),
                         "negative lengths and percents should be rejected "
                         "by parser");
       *aSize = 0;
     }
     // Zoom is handled inside the calc ops when needed.
     zoom = PR_FALSE;
   }
-  else if (eCSSUnit_System_Font == aFontData.mSize.GetUnit()) {
+  else if (eCSSUnit_System_Font == sizeValue->GetUnit()) {
     // this becomes our cascading size
     *aSize = aSystemFont.size;
     zoom = PR_TRUE;
   }
-  else if (eCSSUnit_Inherit == aFontData.mSize.GetUnit()) {
+  else if (eCSSUnit_Inherit == sizeValue->GetUnit()) {
     aCanStoreInRuleTree = PR_FALSE;
     // We apply scriptlevel change for this case, because the default is
     // to inherit and we don't want explicit "inherit" to differ from the
     // default.
     *aSize = aScriptLevelAdjustedParentSize;
     zoom = PR_FALSE;
   }
-  else if (eCSSUnit_Initial == aFontData.mSize.GetUnit()) {
+  else if (eCSSUnit_Initial == sizeValue->GetUnit()) {
     // The initial value is 'medium', which has magical sizing based on
     // the generic font family, so do that here too.
     *aSize = baseSize;
     zoom = PR_TRUE;
   } else {
-    NS_ASSERTION(eCSSUnit_Null == aFontData.mSize.GetUnit(),
+    NS_ASSERTION(eCSSUnit_Null == sizeValue->GetUnit(),
                  "What kind of font-size value is this?");
 #ifdef MOZ_MATHML
     // if aUsedStartStruct is true, then every single property in the
     // font struct is being set all at once. This means scriptlevel is not
     // going to have any influence on the font size; there is no need to
     // do anything here.
     if (!aUsedStartStruct && aParentSize != aScriptLevelAdjustedParentSize) {
       // There was no rule affecting the size but the size has been
@@ -2812,30 +2809,31 @@ static PRInt8 ClampTo8Bit(PRInt32 aValue
   if (aValue > 127)
     return 127;
   return PRInt8(aValue);
 }
 
 /* static */ void
 nsRuleNode::SetFont(nsPresContext* aPresContext, nsStyleContext* aContext,
                     nscoord aMinFontSize,
-                    PRUint8 aGenericFontID, const nsRuleDataFont& aFontData,
+                    PRUint8 aGenericFontID, const nsRuleData* aRuleData,
                     const nsStyleFont* aParentFont,
                     nsStyleFont* aFont, PRBool aUsedStartStruct,
                     PRBool& aCanStoreInRuleTree)
 {
   const nsFont* defaultVariableFont =
     aPresContext->GetDefaultFont(kPresContext_DefaultVariableFont_ID);
   PRBool atRoot = !aContext->GetParent();
 
   // -moz-system-font: enum (never inherit!)
   nsFont systemFont;
-  if (eCSSUnit_Enumerated == aFontData.mSystemFont.GetUnit()) {
+  const nsCSSValue* systemFontValue = aRuleData->ValueForMozSystemFont();
+  if (eCSSUnit_Enumerated == systemFontValue->GetUnit()) {
     nsSystemFontID sysID;
-    switch (aFontData.mSystemFont.GetIntValue()) {
+    switch (systemFontValue->GetIntValue()) {
       case NS_STYLE_FONT_CAPTION:       sysID = eSystemFont_Caption;      break;    // css2
       case NS_STYLE_FONT_ICON:          sysID = eSystemFont_Icon;         break;
       case NS_STYLE_FONT_MENU:          sysID = eSystemFont_Menu;         break;
       case NS_STYLE_FONT_MESSAGE_BOX:   sysID = eSystemFont_MessageBox;   break;
       case NS_STYLE_FONT_SMALL_CAPTION: sysID = eSystemFont_SmallCaption; break;
       case NS_STYLE_FONT_STATUS_BAR:    sysID = eSystemFont_StatusBar;    break;
       case NS_STYLE_FONT_WINDOW:        sysID = eSystemFont_Window;       break;    // css3
       case NS_STYLE_FONT_DOCUMENT:      sysID = eSystemFont_Document;     break;
@@ -2887,77 +2885,81 @@ nsRuleNode::SetFont(nsPresContext* aPres
 #endif
   } else {
     // In case somebody explicitly used -moz-use-system-font.
     systemFont = *defaultVariableFont;
   }
 
 
   // font-family: string list, enum, inherit
-  NS_ASSERTION(eCSSUnit_Enumerated != aFontData.mFamily.GetUnit(),
+  const nsCSSValue* familyValue = aRuleData->ValueForFontFamily();
+  NS_ASSERTION(eCSSUnit_Enumerated != familyValue->GetUnit(),
                "system fonts should not be in mFamily anymore");
-  if (eCSSUnit_Families == aFontData.mFamily.GetUnit()) {
+  if (eCSSUnit_Families == familyValue->GetUnit()) {
     // set the correct font if we are using DocumentFonts OR we are overriding for XUL
     // MJA: bug 31816
     if (aGenericFontID == kGenericFont_NONE) {
       // only bother appending fallback fonts if this isn't a fallback generic font itself
       if (!aFont->mFont.name.IsEmpty())
         aFont->mFont.name.Append((PRUnichar)',');
       // defaultVariableFont.name should always be "serif" or "sans-serif".
       aFont->mFont.name.Append(defaultVariableFont->name);
     }
     aFont->mFont.systemFont = PR_FALSE;
     // Technically this is redundant with the code below, but it's good
     // to have since we'll still want it once we get rid of
     // SetGenericFont (bug 380915).
     aFont->mGenericID = aGenericFontID;
   }
-  else if (eCSSUnit_System_Font == aFontData.mFamily.GetUnit()) {
+  else if (eCSSUnit_System_Font == familyValue->GetUnit()) {
     aFont->mFont.name = systemFont.name;
     aFont->mFont.systemFont = PR_TRUE;
     aFont->mGenericID = kGenericFont_NONE;
   }
-  else if (eCSSUnit_Inherit == aFontData.mFamily.GetUnit()) {
+  else if (eCSSUnit_Inherit == familyValue->GetUnit()) {
     aCanStoreInRuleTree = PR_FALSE;
     aFont->mFont.name = aParentFont->mFont.name;
     aFont->mFont.systemFont = aParentFont->mFont.systemFont;
     aFont->mGenericID = aParentFont->mGenericID;
   }
-  else if (eCSSUnit_Initial == aFontData.mFamily.GetUnit()) {
+  else if (eCSSUnit_Initial == familyValue->GetUnit()) {
     aFont->mFont.name = defaultVariableFont->name;
     aFont->mFont.systemFont = defaultVariableFont->systemFont;
     aFont->mGenericID = kGenericFont_NONE;
   }
 
   // When we're in the loop in SetGenericFont, we must ensure that we
   // always keep aFont->mFlags set to the correct generic.  But we have
   // to be careful not to touch it when we're called directly from
   // ComputeFontData, because we could have a start struct.
   if (aGenericFontID != kGenericFont_NONE) {
     aFont->mGenericID = aGenericFontID;
   }
 
   // font-style: enum, inherit, initial, -moz-system-font
-  SetDiscrete(aFontData.mStyle, aFont->mFont.style, aCanStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForFontStyle(),
+              aFont->mFont.style, aCanStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_SYSTEM_FONT,
               aParentFont->mFont.style,
               defaultVariableFont->style,
               0, 0, 0, systemFont.style);
 
   // font-variant: enum, inherit, initial, -moz-system-font
-  SetDiscrete(aFontData.mVariant, aFont->mFont.variant, aCanStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForFontVariant(),
+              aFont->mFont.variant, aCanStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_SYSTEM_FONT,
               aParentFont->mFont.variant,
               defaultVariableFont->variant,
               0, 0, 0, systemFont.variant);
 
   // font-weight: int, enum, inherit, initial, -moz-system-font
   // special handling for enum
-  if (eCSSUnit_Enumerated == aFontData.mWeight.GetUnit()) {
-    PRInt32 value = aFontData.mWeight.GetIntValue();
+  const nsCSSValue* weightValue = aRuleData->ValueForFontWeight();
+  if (eCSSUnit_Enumerated == weightValue->GetUnit()) {
+    PRInt32 value = weightValue->GetIntValue();
     switch (value) {
       case NS_STYLE_FONT_WEIGHT_NORMAL:
       case NS_STYLE_FONT_WEIGHT_BOLD:
         aFont->mFont.weight = value;
         break;
       case NS_STYLE_FONT_WEIGHT_BOLDER: {
         aCanStoreInRuleTree = PR_FALSE;
         PRInt32 inheritedValue = aParentFont->mFont.weight;
@@ -2979,118 +2981,126 @@ nsRuleNode::SetFont(nsPresContext* aPres
           aFont->mFont.weight = 400;
         } else {
           aFont->mFont.weight = 700;
         }
         break;
       }
     }
   } else
-    SetDiscrete(aFontData.mWeight, aFont->mFont.weight, aCanStoreInRuleTree,
+    SetDiscrete(*weightValue, aFont->mFont.weight, aCanStoreInRuleTree,
                 SETDSC_INTEGER | SETDSC_SYSTEM_FONT,
                 aParentFont->mFont.weight,
                 defaultVariableFont->weight,
                 0, 0, 0, systemFont.weight);
 
   // font-stretch: enum, inherit, initial, -moz-system-font
-  SetDiscrete(aFontData.mStretch, aFont->mFont.stretch, aCanStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForFontStretch(),
+              aFont->mFont.stretch, aCanStoreInRuleTree,
               SETDSC_SYSTEM_FONT | SETDSC_ENUMERATED,
               aParentFont->mFont.stretch,
               defaultVariableFont->stretch,
               0, 0, 0, systemFont.stretch);
 
 #ifdef MOZ_MATHML
   // Compute scriptlevel, scriptminsize and scriptsizemultiplier now so
   // they're available for font-size computation.
 
   // -moz-script-min-size: length
-  if (aFontData.mScriptMinSize.IsLengthUnit()) {
+  const nsCSSValue* scriptMinSizeValue = aRuleData->ValueForScriptMinSize();
+  if (scriptMinSizeValue->IsLengthUnit()) {
     // scriptminsize in font units (em, ex) has to be interpreted relative
     // to the parent font, or the size definitions are circular and we
     //
     aFont->mScriptMinSize =
-      CalcLengthWith(aFontData.mScriptMinSize, aParentFont->mSize, aParentFont,
+      CalcLengthWith(*scriptMinSizeValue, aParentFont->mSize, aParentFont,
                      nsnull, aPresContext, atRoot, PR_TRUE,
                      aCanStoreInRuleTree);
   }
 
   // -moz-script-size-multiplier: factor, inherit, initial
-  SetFactor(aFontData.mScriptSizeMultiplier, aFont->mScriptSizeMultiplier,
+  SetFactor(*aRuleData->ValueForScriptSizeMultiplier(),
+            aFont->mScriptSizeMultiplier,
             aCanStoreInRuleTree, aParentFont->mScriptSizeMultiplier,
             NS_MATHML_DEFAULT_SCRIPT_SIZE_MULTIPLIER,
             SETFCT_POSITIVE);
 
   // -moz-script-level: integer, number, inherit
-  if (eCSSUnit_Integer == aFontData.mScriptLevel.GetUnit()) {
+  const nsCSSValue* scriptLevelValue = aRuleData->ValueForScriptLevel();
+  if (eCSSUnit_Integer == scriptLevelValue->GetUnit()) {
     // "relative"
-    aFont->mScriptLevel = ClampTo8Bit(aParentFont->mScriptLevel + aFontData.mScriptLevel.GetIntValue());
-  }
-  else if (eCSSUnit_Number == aFontData.mScriptLevel.GetUnit()) {
+    aFont->mScriptLevel = ClampTo8Bit(aParentFont->mScriptLevel + scriptLevelValue->GetIntValue());
+  }
+  else if (eCSSUnit_Number == scriptLevelValue->GetUnit()) {
     // "absolute"
-    aFont->mScriptLevel = ClampTo8Bit(PRInt32(aFontData.mScriptLevel.GetFloatValue()));
-  }
-  else if (eCSSUnit_Inherit == aFontData.mScriptLevel.GetUnit()) {
+    aFont->mScriptLevel = ClampTo8Bit(PRInt32(scriptLevelValue->GetFloatValue()));
+  }
+  else if (eCSSUnit_Inherit == scriptLevelValue->GetUnit()) {
     aCanStoreInRuleTree = PR_FALSE;
     aFont->mScriptLevel = aParentFont->mScriptLevel;
   }
-  else if (eCSSUnit_Initial == aFontData.mScriptLevel.GetUnit()) {
+  else if (eCSSUnit_Initial == scriptLevelValue->GetUnit()) {
     aFont->mScriptLevel = 0;
   }
 #endif
 
   // font-feature-settings
-  if (eCSSUnit_Inherit == aFontData.mFontFeatureSettings.GetUnit()) {
+  const nsCSSValue* featureSettingsValue =
+    aRuleData->ValueForMozFontFeatureSettings();
+  if (eCSSUnit_Inherit == featureSettingsValue->GetUnit()) {
     aCanStoreInRuleTree = PR_FALSE;
     aFont->mFont.featureSettings = aParentFont->mFont.featureSettings;
-  } else if (eCSSUnit_Normal == aFontData.mFontFeatureSettings.GetUnit() ||
-             eCSSUnit_Initial == aFontData.mFontFeatureSettings.GetUnit()) {
+  } else if (eCSSUnit_Normal == featureSettingsValue->GetUnit() ||
+             eCSSUnit_Initial == featureSettingsValue->GetUnit()) {
     aFont->mFont.featureSettings.Truncate();
-  } else if (eCSSUnit_System_Font == aFontData.mFontFeatureSettings.GetUnit()) {
+  } else if (eCSSUnit_System_Font == featureSettingsValue->GetUnit()) {
     aFont->mFont.featureSettings = systemFont.featureSettings;
-  } else if (eCSSUnit_String == aFontData.mFontFeatureSettings.GetUnit()) {
-    aFontData.mFontFeatureSettings.GetStringValue(aFont->mFont.featureSettings);
+  } else if (eCSSUnit_String == featureSettingsValue->GetUnit()) {
+    featureSettingsValue->GetStringValue(aFont->mFont.featureSettings);
   }
 
   // font-language-override
-  if (eCSSUnit_Inherit == aFontData.mFontLanguageOverride.GetUnit()) {
+  const nsCSSValue* languageOverrideValue =
+    aRuleData->ValueForMozFontLanguageOverride();
+  if (eCSSUnit_Inherit == languageOverrideValue->GetUnit()) {
     aCanStoreInRuleTree = PR_FALSE;
     aFont->mFont.languageOverride = aParentFont->mFont.languageOverride;
-  } else if (eCSSUnit_Normal == aFontData.mFontLanguageOverride.GetUnit() ||
-             eCSSUnit_Initial == aFontData.mFontLanguageOverride.GetUnit()) {
+  } else if (eCSSUnit_Normal == languageOverrideValue->GetUnit() ||
+             eCSSUnit_Initial == languageOverrideValue->GetUnit()) {
     aFont->mFont.languageOverride.Truncate();
-  } else if (eCSSUnit_System_Font == aFontData.mFontLanguageOverride.GetUnit()) {
+  } else if (eCSSUnit_System_Font == languageOverrideValue->GetUnit()) {
     aFont->mFont.languageOverride = systemFont.languageOverride;
-  } else if (eCSSUnit_String == aFontData.mFontLanguageOverride.GetUnit()) {
-    aFontData.mFontLanguageOverride.GetStringValue(aFont->mFont.languageOverride);
+  } else if (eCSSUnit_String == languageOverrideValue->GetUnit()) {
+    languageOverrideValue->GetStringValue(aFont->mFont.languageOverride);
   }
 
   // font-size: enum, length, percent, inherit
   nscoord scriptLevelAdjustedParentSize = aParentFont->mSize;
 #ifdef MOZ_MATHML
   nscoord scriptLevelAdjustedUnconstrainedParentSize;
   scriptLevelAdjustedParentSize =
     ComputeScriptLevelSize(aFont, aParentFont, aPresContext,
                            &scriptLevelAdjustedUnconstrainedParentSize);
   NS_ASSERTION(!aUsedStartStruct || aFont->mScriptUnconstrainedSize == aFont->mSize,
                "If we have a start struct, we should have reset everything coming in here");
 #endif
-  SetFontSize(aPresContext, aFontData, aFont, aParentFont, &aFont->mSize,
+  SetFontSize(aPresContext, aRuleData, aFont, aParentFont, &aFont->mSize,
               systemFont, aParentFont->mSize, scriptLevelAdjustedParentSize,
               aUsedStartStruct, atRoot, aCanStoreInRuleTree);
 #ifdef MOZ_MATHML
   if (aParentFont->mSize == aParentFont->mScriptUnconstrainedSize &&
       scriptLevelAdjustedParentSize == scriptLevelAdjustedUnconstrainedParentSize) {
     // Fast path: we have not been affected by scriptminsize so we don't
     // need to call SetFontSize again to compute the
     // scriptminsize-unconstrained size. This is OK even if we have a
     // start struct, because if we have a start struct then 'font-size'
     // was specified and so scriptminsize has no effect.
     aFont->mScriptUnconstrainedSize = aFont->mSize;
   } else {
-    SetFontSize(aPresContext, aFontData, aFont, aParentFont,
+    SetFontSize(aPresContext, aRuleData, aFont, aParentFont,
                 &aFont->mScriptUnconstrainedSize, systemFont,
                 aParentFont->mScriptUnconstrainedSize,
                 scriptLevelAdjustedUnconstrainedParentSize,
                 aUsedStartStruct, atRoot, aCanStoreInRuleTree);
   }
   NS_ASSERTION(aFont->mScriptUnconstrainedSize <= aFont->mSize,
                "scriptminsize should never be making things bigger");
 #endif
@@ -3098,20 +3108,21 @@ nsRuleNode::SetFont(nsPresContext* aPres
   // enforce the user' specified minimum font-size on the value that we expose
   // (but don't change font-size:0)
   if (0 < aFont->mSize && aFont->mSize < aMinFontSize)
     aFont->mFont.size = aMinFontSize;
   else
     aFont->mFont.size = aFont->mSize;
 
   // font-size-adjust: number, none, inherit, initial, -moz-system-font
-  if (eCSSUnit_System_Font == aFontData.mSizeAdjust.GetUnit()) {
+  const nsCSSValue* sizeAdjustValue = aRuleData->ValueForFontSizeAdjust();
+  if (eCSSUnit_System_Font == sizeAdjustValue->GetUnit()) {
     aFont->mFont.sizeAdjust = systemFont.sizeAdjust;
   } else
-    SetFactor(aFontData.mSizeAdjust, aFont->mFont.sizeAdjust,
+    SetFactor(*sizeAdjustValue, aFont->mFont.sizeAdjust,
               aCanStoreInRuleTree, aParentFont->mFont.sizeAdjust, 0.0f,
               SETFCT_NONE);
 }
 
 // SetGenericFont:
 //  - backtrack to an ancestor with the same generic font name (possibly
 //    up to the root where default values come from the presentation context)
 //  - re-apply cascading rules from there without caching intermediate values
@@ -3174,20 +3185,20 @@ nsRuleNode::SetGenericFont(nsPresContext
       }
     }
 
     // Compute the delta from the information that the rules specified
 
     // Avoid unnecessary operations in SetFont().  But we care if it's
     // the final value that we're computing.
     if (i != 0)
-      fontData.mFamily.Reset();
+      ruleData.ValueForFontFamily()->Reset();
 
     nsRuleNode::SetFont(aPresContext, context, aMinFontSize,
-                        aGenericFontID, fontData, &parentFont, aFont,
+                        aGenericFontID, &ruleData, &parentFont, aFont,
                         PR_FALSE, dummy);
 
     // XXX Not sure if we need to do this here
     // If we have a post-resolve callback, handle that now.
     if (ruleData.mPostResolveCallback)
       (ruleData.mPostResolveCallback)(aFont, &ruleData);
 
     parentFont = *aFont;
@@ -3203,17 +3214,17 @@ static PRBool ExtractGeneric(const nsStr
     *data = aFamily;
     return PR_FALSE; // stop enumeration
   }
   return PR_TRUE;
 }
 
 const void*
 nsRuleNode::ComputeFontData(void* aStartStruct,
-                            const nsRuleDataStruct& aData,
+                            const nsRuleData* aRuleData,
                             nsStyleContext* aContext,
                             nsRuleNode* aHighestNode,
                             const RuleDetail aRuleDetail,
                             const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Font, (mPresContext), font, parentFont,
                           Font, fontData)
 
@@ -3248,18 +3259,19 @@ nsRuleNode::ComputeFontData(void* aStart
     useDocumentFonts = PR_TRUE;
     minimumFontSize = 0;
   }
 
   // Figure out if we are a generic font
   PRUint8 generic = kGenericFont_NONE;
   // XXXldb What if we would have had a string if we hadn't been doing
   // the optimization with a non-null aStartStruct?
-  if (eCSSUnit_Families == fontData.mFamily.GetUnit()) {
-    fontData.mFamily.GetStringValue(font->mFont.name);
+  const nsCSSValue* familyValue = aRuleData->ValueForFontFamily();
+  if (eCSSUnit_Families == familyValue->GetUnit()) {
+    familyValue->GetStringValue(font->mFont.name);
     // XXXldb Do we want to extract the generic for this if it's not only a
     // generic?
     nsFont::GetGenericID(font->mFont.name, &generic);
 
     // If we aren't allowed to use document fonts, then we are only entitled
     // to use the user's default variable-width font and fixed-width font
     if (!useDocumentFonts) {
       // Extract the generic from the specified font family...
@@ -3282,17 +3294,17 @@ nsRuleNode::ComputeFontData(void* aStart
       }
     }
   }
 
   // Now compute our font struct
   if (generic == kGenericFont_NONE) {
     // continue the normal processing
     nsRuleNode::SetFont(mPresContext, aContext, minimumFontSize, generic,
-                        fontData, parentFont, font,
+                        aRuleData, parentFont, font,
                         aStartStruct != nsnull, canStoreInRuleTree);
   }
   else {
     // re-calculate the font as a generic font
     canStoreInRuleTree = PR_FALSE;
     nsRuleNode::SetGenericFont(mPresContext, aContext, generic,
                                minimumFontSize, font);
   }
@@ -3390,53 +3402,57 @@ nsRuleNode::GetShadowData(const nsCSSVal
   }
 
   NS_ADDREF(shadowList);
   return shadowList;
 }
 
 const void*
 nsRuleNode::ComputeTextData(void* aStartStruct,
-                            const nsRuleDataStruct& aData,
+                            const nsRuleData* aRuleData,
                             nsStyleContext* aContext,
                             nsRuleNode* aHighestNode,
                             const RuleDetail aRuleDetail,
                             const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Text, (), text, parentText, Text, textData)
 
   // tab-size: integer, inherit
-  SetDiscrete(textData.mTabSize, text->mTabSize, canStoreInRuleTree,
+  SetDiscrete(*aRuleData->ValueForMozTabSize(),
+              text->mTabSize, canStoreInRuleTree,
               SETDSC_INTEGER, parentText->mTabSize,
               NS_STYLE_TABSIZE_INITIAL, 0, 0, 0, 0);
 
   // letter-spacing: normal, length, inherit
-  SetCoord(textData.mLetterSpacing, text->mLetterSpacing, parentText->mLetterSpacing,
+  SetDiscrete(*aRuleData->ValueForLetterSpacing(),
+              text->mLetterSpacing, parentText->mLetterSpacing,
            SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL |
              SETCOORD_CALC_LENGTH_ONLY,
            aContext, mPresContext, canStoreInRuleTree);
 
   // text-shadow: none, list, inherit, initial
-  if (textData.mTextShadow.GetUnit() != eCSSUnit_Null) {
+  const nsCSSValue* textShadowValue = aRuleData->ValueForTextShadow();
+  if (textShadowValue->GetUnit() != eCSSUnit_Null) {
     text->mTextShadow = nsnull;
 
     // Don't need to handle none/initial explicitly: The above assignment
     // takes care of that
-    if (textData.mTextShadow.GetUnit() == eCSSUnit_Inherit) {
+    if (textShadowValue->GetUnit() == eCSSUnit_Inherit) {
       canStoreInRuleTree = PR_FALSE;
       text->mTextShadow = parentText->mTextShadow;
-    } else if (textData.mTextShadow.GetUnit() == eCSSUnit_List ||
-               textData.mTextShadow.GetUnit() == eCSSUnit_ListDep) {
+    } else if (textShadowValue->GetUnit() == eCSSUnit_List ||
+               textShadowValue->GetUnit() == eCSSUnit_ListDep) {
       // List of arrays
-      text->mTextShadow = GetShadowData(textData.mTextShadow.GetListValue(),
+      text->mTextShadow = GetShadowData(textShadowValue->GetListValue(),
                                         aContext, PR_FALSE, canStoreInRuleTree);
     }
   }
 
   // line-height: normal, number, length, percent, inherit
+  const nsCSSValue* lineHeightValue = aRuleData->ValueForLineHeight();
   if (eCSSUnit_Percent == textData.mLineHeight.GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     // Use |mFont.size| to pick up minimum font size.
     text->mLineHeight.SetCoordValue(
         nscoord(float(aContext->GetStyleFont()->mFont.size) *
                 textData.mLineHeight.GetPercentValue()));
   }
   else if (eCSSUnit_Initial == textData.mLineHeight.GetUnit() ||
@@ -3527,17 +3543,17 @@ nsRuleNode::ComputeTextData(void* aStart
               SETDSC_ENUMERATED, parentText->mWordWrap,
               NS_STYLE_WORDWRAP_NORMAL, 0, 0, 0, 0);
 
   COMPUTE_END_INHERITED(Text, text)
 }
 
 const void*
 nsRuleNode::ComputeTextResetData(void* aStartStruct,
-                                 const nsRuleDataStruct& aData,
+                                 const nsRuleData* aRuleData,
                                  nsStyleContext* aContext,
                                  nsRuleNode* aHighestNode,
                                  const RuleDetail aRuleDetail,
                                  const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(TextReset, (), text, parentText, Text, textData)
 
   // vertical-align: enum, length, percent, calc, inherit
@@ -3577,17 +3593,17 @@ nsRuleNode::ComputeTextResetData(void* a
               SETDSC_ENUMERATED, parentText->mUnicodeBidi,
               NS_STYLE_UNICODE_BIDI_NORMAL, 0, 0, 0, 0);
 
   COMPUTE_END_RESET(TextReset, text)
 }
 
 const void*
 nsRuleNode::ComputeUserInterfaceData(void* aStartStruct,
-                                     const nsRuleDataStruct& aData,
+                                     const nsRuleData* aRuleData,
                                      nsStyleContext* aContext,
                                      nsRuleNode* aHighestNode,
                                      const RuleDetail aRuleDetail,
                                      const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(UserInterface, (), ui, parentUI,
                           UserInterface, uiData)
 
@@ -3666,17 +3682,17 @@ nsRuleNode::ComputeUserInterfaceData(voi
               SETDSC_ENUMERATED, parentUI->mUserFocus,
               NS_STYLE_USER_FOCUS_NONE, 0, 0, 0, 0);
 
   COMPUTE_END_INHERITED(UserInterface, ui)
 }
 
 const void*
 nsRuleNode::ComputeUIResetData(void* aStartStruct,
-                               const nsRuleDataStruct& aData,
+                               const nsRuleData* aRuleData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(UIReset, (), ui, parentUI, UserInterface, uiData)
 
   // user-select: enum, inherit, initial
@@ -3752,17 +3768,17 @@ static const TransitionPropInfo animatio
 struct TransitionPropData {
   const nsCSSValueList *list;
   nsCSSUnit unit;
   PRUint32 num;
 };
 
 const void*
 nsRuleNode::ComputeDisplayData(void* aStartStruct,
-                               const nsRuleDataStruct& aData,
+                               const nsRuleData* aRuleData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Display, (), display, parentDisplay,
                       Display, displayData)
 
@@ -4293,17 +4309,17 @@ nsRuleNode::ComputeDisplayData(void* aSt
     NS_ASSERTION(result, "Malformed -moz-transform-origin parse!");
   }
 
   COMPUTE_END_RESET(Display, display)
 }
 
 const void*
 nsRuleNode::ComputeVisibilityData(void* aStartStruct,
-                                  const nsRuleDataStruct& aData,
+                                  const nsRuleData* aRuleData,
                                   nsStyleContext* aContext,
                                   nsRuleNode* aHighestNode,
                                   const RuleDetail aRuleDetail,
                                   const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Visibility, (mPresContext),
                           visibility, parentVisibility,
                           Display, displayData)
@@ -4351,17 +4367,17 @@ nsRuleNode::ComputeVisibilityData(void* 
     }
   }
 
   COMPUTE_END_INHERITED(Visibility, visibility)
 }
 
 const void*
 nsRuleNode::ComputeColorData(void* aStartStruct,
-                             const nsRuleDataStruct& aData,
+                             const nsRuleData* aRuleData,
                              nsStyleContext* aContext,
                              nsRuleNode* aHighestNode,
                              const RuleDetail aRuleDetail,
                              const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Color, (mPresContext), color, parentColor,
                           Color, colorData)
 
@@ -4742,17 +4758,17 @@ FillBackgroundList(nsAutoTArray< nsStyle
        ++sourceLayer, ++destLayer) {
     aLayers[destLayer].*aResultLocation =
       aLayers[sourceLayer].*aResultLocation;
   }
 }
 
 const void*
 nsRuleNode::ComputeBackgroundData(void* aStartStruct,
-                                  const nsRuleDataStruct& aData,
+                                  const nsRuleData* aRuleData,
                                   nsStyleContext* aContext,
                                   nsRuleNode* aHighestNode,
                                   const RuleDetail aRuleDetail,
                                   const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Background, (), bg, parentBG, Color, colorData)
 
   // background-color: color, string, inherit
@@ -4853,17 +4869,17 @@ nsRuleNode::ComputeBackgroundData(void* 
   for (PRUint32 i = 0; i < bg->mImageCount; ++i)
     bg->mLayers[i].TrackImages(aContext->PresContext());
 
   COMPUTE_END_RESET(Background, bg)
 }
 
 const void*
 nsRuleNode::ComputeMarginData(void* aStartStruct,
-                              const nsRuleDataStruct& aData,
+                              const nsRuleData* aRuleData,
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Margin, (), margin, parentMargin, Margin, marginData)
 
   // margin: length, percent, auto, inherit
@@ -4890,17 +4906,17 @@ nsRuleNode::ComputeMarginData(void* aSta
   }
 
   margin->RecalcData();
   COMPUTE_END_RESET(Margin, margin)
 }
 
 const void*
 nsRuleNode::ComputeBorderData(void* aStartStruct,
-                              const nsRuleDataStruct& aData,
+                              const nsRuleData* aRuleData,
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Border, (mPresContext), border, parentBorder,
                       Margin, marginData)
 
@@ -5229,17 +5245,17 @@ nsRuleNode::ComputeBorderData(void* aSta
   if (border->HasBorderImage())
     border->TrackImage(aContext->PresContext());
 
   COMPUTE_END_RESET(Border, border)
 }
 
 const void*
 nsRuleNode::ComputePaddingData(void* aStartStruct,
-                               const nsRuleDataStruct& aData,
+                               const nsRuleData* aRuleData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Padding, (), padding, parentPadding, Margin, marginData)
 
   // padding: length, percent, inherit
@@ -5266,17 +5282,17 @@ nsRuleNode::ComputePaddingData(void* aSt
   }
 
   padding->RecalcData();
   COMPUTE_END_RESET(Padding, padding)
 }
 
 const void*
 nsRuleNode::ComputeOutlineData(void* aStartStruct,
-                               const nsRuleDataStruct& aData,
+                               const nsRuleData* aRuleData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Outline, (mPresContext), outline, parentOutline,
                       Margin, marginData)
 
@@ -5374,17 +5390,17 @@ nsRuleNode::ComputeOutlineData(void* aSt
   }
 
   outline->RecalcData(mPresContext);
   COMPUTE_END_RESET(Outline, outline)
 }
 
 const void*
 nsRuleNode::ComputeListData(void* aStartStruct,
-                            const nsRuleDataStruct& aData,
+                            const nsRuleData* aRuleData,
                             nsStyleContext* aContext,
                             nsRuleNode* aHighestNode,
                             const RuleDetail aRuleDetail,
                             const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(List, (), list, parentList, List, listData)
 
   // list-style-type: enum, inherit, initial
@@ -5464,17 +5480,17 @@ nsRuleNode::ComputeListData(void* aStart
     NS_ABORT_IF_FALSE(false, "unrecognized image-region unit");
   }
 
   COMPUTE_END_INHERITED(List, list)
 }
 
 const void*
 nsRuleNode::ComputePositionData(void* aStartStruct,
-                                const nsRuleDataStruct& aData,
+                                const nsRuleData* aRuleData,
                                 nsStyleContext* aContext,
                                 nsRuleNode* aHighestNode,
                                 const RuleDetail aRuleDetail,
                                 const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Position, (), pos, parentPos, Position, posData)
 
   // box offsets: length, percent, calc, auto, inherit
@@ -5525,17 +5541,17 @@ nsRuleNode::ComputePositionData(void* aS
     }
   }
 
   COMPUTE_END_RESET(Position, pos)
 }
 
 const void*
 nsRuleNode::ComputeTableData(void* aStartStruct,
-                             const nsRuleDataStruct& aData,
+                             const nsRuleData* aRuleData,
                              nsStyleContext* aContext,
                              nsRuleNode* aHighestNode,
                              const RuleDetail aRuleDetail,
                              const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Table, (), table, parentTable, Table, tableData)
 
   // table-layout: enum, inherit, initial
@@ -5553,17 +5569,17 @@ nsRuleNode::ComputeTableData(void* aStar
       eCSSUnit_Integer == tableData.mSpan.GetUnit())
     table->mSpan = tableData.mSpan.GetIntValue();
 
   COMPUTE_END_RESET(Table, table)
 }
 
 const void*
 nsRuleNode::ComputeTableBorderData(void* aStartStruct,
-                                   const nsRuleDataStruct& aData,
+                                   const nsRuleData* aRuleData,
                                    nsStyleContext* aContext,
                                    nsRuleNode* aHighestNode,
                                    const RuleDetail aRuleDetail,
                                    const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(TableBorder, (mPresContext), table, parentTable,
                           Table, tableData)
 
@@ -5608,17 +5624,17 @@ nsRuleNode::ComputeTableBorderData(void*
               : NS_STYLE_TABLE_EMPTY_CELLS_SHOW,
               0, 0, 0, 0);
 
   COMPUTE_END_INHERITED(TableBorder, table)
 }
 
 const void*
 nsRuleNode::ComputeContentData(void* aStartStruct,
-                               const nsRuleDataStruct& aData,
+                               const nsRuleData* aRuleData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
   PRUint32 count;
   nsAutoString buffer;
 
@@ -5841,17 +5857,17 @@ nsRuleNode::ComputeContentData(void* aSt
     }
   }
 
   COMPUTE_END_RESET(Content, content)
 }
 
 const void*
 nsRuleNode::ComputeQuotesData(void* aStartStruct,
-                              const nsRuleDataStruct& aData,
+                              const nsRuleData* aRuleData,
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Quotes, (), quotes, parentQuotes,
                           Content, contentData)
 
@@ -5895,17 +5911,17 @@ nsRuleNode::ComputeQuotesData(void* aSta
     NS_ABORT_IF_FALSE(false, "unexpected value unit");
   }
 
   COMPUTE_END_INHERITED(Quotes, quotes)
 }
 
 const void*
 nsRuleNode::ComputeXULData(void* aStartStruct,
-                           const nsRuleDataStruct& aData,
+                           const nsRuleData* aRuleData,
                            nsStyleContext* aContext,
                            nsRuleNode* aHighestNode,
                            const RuleDetail aRuleDetail,
                            const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(XUL, (), xul, parentXUL, XUL, xulData)
 
   // box-align: enum, inherit, initial
@@ -5947,17 +5963,17 @@ nsRuleNode::ComputeXULData(void* aStartS
       NS_STYLE_STACK_SIZING_STRETCH_TO_FIT;
   }
 
   COMPUTE_END_RESET(XUL, xul)
 }
 
 const void*
 nsRuleNode::ComputeColumnData(void* aStartStruct,
-                              const nsRuleDataStruct& aData,
+                              const nsRuleData* aRuleData,
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Column, (mPresContext), column, parent, Column, columnData)
 
   // column-width: length, auto, inherit
@@ -6102,17 +6118,17 @@ SetSVGPaint(const nsCSSValue& aValue, co
   } else {
     NS_ABORT_IF_FALSE(aValue.GetUnit() == eCSSUnit_Null,
                       "malformed paint server value");
   }
 }
 
 const void*
 nsRuleNode::ComputeSVGData(void* aStartStruct,
-                           const nsRuleDataStruct& aData,
+                           const nsRuleData* aRuleData,
                            nsStyleContext* aContext,
                            nsRuleNode* aHighestNode,
                            const RuleDetail aRuleDetail,
                            const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(SVG, (), svg, parentSVG, SVG, SVGData)
 
   // clip-rule: enum, inherit, initial
@@ -6300,17 +6316,17 @@ nsRuleNode::ComputeSVGData(void* aStartS
               SETDSC_ENUMERATED, parentSVG->mTextRendering,
               NS_STYLE_TEXT_RENDERING_AUTO, 0, 0, 0, 0);
 
   COMPUTE_END_INHERITED(SVG, svg)
 }
 
 const void*
 nsRuleNode::ComputeSVGResetData(void* aStartStruct,
-                                const nsRuleDataStruct& aData,
+                                const nsRuleData* aRuleData,
                                 nsStyleContext* aContext,
                                 nsRuleNode* aHighestNode,
                                 const RuleDetail aRuleDetail,
                                 const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(SVGReset, (), svgReset, parentSVGReset, SVG, SVGData)
 
   // stop-color:
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -459,194 +459,194 @@ protected:
                                nsStyleContext* aContext);
 
   const void*
     WalkRuleTree(const nsStyleStructID aSID, nsStyleContext* aContext,
                  nsRuleData* aRuleData, nsRuleDataStruct* aSpecificData);
 
   const void*
     ComputeDisplayData(void* aStartStruct,
-                       const nsRuleDataStruct& aData,
+                       const nsRuleData* aRuleData,
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
                        RuleDetail aRuleDetail,
                        const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeVisibilityData(void* aStartStruct,
-                          const nsRuleDataStruct& aData,
+                          const nsRuleData* aRuleData,
                           nsStyleContext* aContext, nsRuleNode* aHighestNode,
                           RuleDetail aRuleDetail,
                           const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeFontData(void* aStartStruct,
-                    const nsRuleDataStruct& aData,
+                    const nsRuleData* aRuleData,
                     nsStyleContext* aContext, nsRuleNode* aHighestNode,
                     RuleDetail aRuleDetail,
                     const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeColorData(void* aStartStruct,
-                     const nsRuleDataStruct& aData,
+                     const nsRuleData* aRuleData,
                      nsStyleContext* aContext, nsRuleNode* aHighestNode,
                      RuleDetail aRuleDetail,
                      const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeBackgroundData(void* aStartStruct,
-                          const nsRuleDataStruct& aData,
+                          const nsRuleData* aRuleData,
                           nsStyleContext* aContext, nsRuleNode* aHighestNode,
                           RuleDetail aRuleDetail,
                           const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeMarginData(void* aStartStruct,
-                      const nsRuleDataStruct& aData,
+                      const nsRuleData* aRuleData,
                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
                       RuleDetail aRuleDetail,
                       const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeBorderData(void* aStartStruct,
-                      const nsRuleDataStruct& aData,
+                      const nsRuleData* aRuleData,
                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
                       RuleDetail aRuleDetail,
                       const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputePaddingData(void* aStartStruct,
-                       const nsRuleDataStruct& aData,
+                       const nsRuleData* aRuleData,
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
                        RuleDetail aRuleDetail,
                        const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeOutlineData(void* aStartStruct,
-                       const nsRuleDataStruct& aData,
+                       const nsRuleData* aRuleData,
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
                        RuleDetail aRuleDetail,
                        const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeListData(void* aStartStruct,
-                    const nsRuleDataStruct& aData,
+                    const nsRuleData* aRuleData,
                     nsStyleContext* aContext, nsRuleNode* aHighestNode,
                     RuleDetail aRuleDetail,
                     const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputePositionData(void* aStartStruct,
-                        const nsRuleDataStruct& aData,
+                        const nsRuleData* aRuleData,
                         nsStyleContext* aContext, nsRuleNode* aHighestNode,
                         RuleDetail aRuleDetail,
                         const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeTableData(void* aStartStruct,
-                     const nsRuleDataStruct& aData,
+                     const nsRuleData* aRuleData,
                      nsStyleContext* aContext, nsRuleNode* aHighestNode,
                      RuleDetail aRuleDetail,
                      const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeTableBorderData(void* aStartStruct,
-                           const nsRuleDataStruct& aData,
+                           const nsRuleData* aRuleData,
                            nsStyleContext* aContext, nsRuleNode* aHighestNode,
                            RuleDetail aRuleDetail,
                            const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeContentData(void* aStartStruct,
-                       const nsRuleDataStruct& aData,
+                       const nsRuleData* aRuleData,
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
                        RuleDetail aRuleDetail,
                        const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeQuotesData(void* aStartStruct,
-                      const nsRuleDataStruct& aData,
+                      const nsRuleData* aRuleData,
                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
                       RuleDetail aRuleDetail,
                       const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeTextData(void* aStartStruct,
-                    const nsRuleDataStruct& aData,
+                    const nsRuleData* aRuleData,
                     nsStyleContext* aContext, nsRuleNode* aHighestNode,
                     RuleDetail aRuleDetail,
                     const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeTextResetData(void* aStartStruct,
-                         const nsRuleDataStruct& aData,
+                         const nsRuleData* aRuleData,
                          nsStyleContext* aContext, nsRuleNode* aHighestNode,
                          RuleDetail aRuleDetail,
                          const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeUserInterfaceData(void* aStartStruct,
-                             const nsRuleDataStruct& aData,
+                             const nsRuleData* aRuleData,
                              nsStyleContext* aContext,
                              nsRuleNode* aHighestNode,
                              RuleDetail aRuleDetail,
                              const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeUIResetData(void* aStartStruct,
-                       const nsRuleDataStruct& aData,
+                       const nsRuleData* aRuleData,
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
                        RuleDetail aRuleDetail,
                        const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeXULData(void* aStartStruct,
-                   const nsRuleDataStruct& aData,
+                   const nsRuleData* aRuleData,
                    nsStyleContext* aContext, nsRuleNode* aHighestNode,
                    RuleDetail aRuleDetail,
                    const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeColumnData(void* aStartStruct,
-                      const nsRuleDataStruct& aData,
+                      const nsRuleData* aRuleData,
                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
                       RuleDetail aRuleDetail,
                       const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeSVGData(void* aStartStruct,
-                   const nsRuleDataStruct& aData,
+                   const nsRuleData* aRuleData,
                    nsStyleContext* aContext, nsRuleNode* aHighestNode,
                    RuleDetail aRuleDetail,
                    const PRBool aCanStoreInRuleTree);
 
   const void*
     ComputeSVGResetData(void* aStartStruct,
-                        const nsRuleDataStruct& aData,
+                        const nsRuleData* aRuleData,
                         nsStyleContext* aContext, nsRuleNode* aHighestNode,
                         RuleDetail aRuleDetail,
                         const PRBool aCanStoreInRuleTree);
 
   // helpers for |ComputeFontData| that need access to |mNoneBits|:
   static void SetFontSize(nsPresContext* aPresContext,
-                          const nsRuleDataFont& aFontData,
+                          const nsRuleData* aRuleData,
                           const nsStyleFont* aFont,
                           const nsStyleFont* aParentFont,
                           nscoord* aSize,
                           const nsFont& aSystemFont,
                           nscoord aParentSize,
                           nscoord aScriptLevelAdjustedParentSize,
                           PRBool aUsedStartStruct,
                           PRBool aAtRoot,
                           PRBool& aCanStoreInRuleTree);
 
   static void SetFont(nsPresContext* aPresContext,
                       nsStyleContext* aContext,
                       nscoord aMinFontSize,
                       PRUint8 aGenericFontID,
-                      const nsRuleDataFont& aFontData,
+                      const nsRuleData* aRuleData,
                       const nsStyleFont* aParentFont,
                       nsStyleFont* aFont,
                       PRBool aStartStruct,
                       PRBool& aCanStoreInRuleTree);
 
   static void SetGenericFont(nsPresContext* aPresContext,
                              nsStyleContext* aContext,
                              PRUint8 aGenericFontID,
