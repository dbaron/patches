Record results of cycle collection traversal so we only have to call the traversal APIs once per collection.  b=378514

diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -1,4 +1,5 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim: set cindent tabstop=4 expandtab shiftwidth=4: */
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
@@ -287,6 +288,112 @@ nsCycleCollector_shouldSuppress(nsISuppo
 // Base types
 ////////////////////////////////////////////////////////////////////////
 
+struct PtrInfo;
+
+class EdgeIterator
+{
+public:
+    EdgeIterator() : mPointer(nsnull) {}
+    EdgeIterator(void **aPointer) : mPointer(aPointer) {}
+    EdgeIterator(const EdgeIterator& aOther) : mPointer(aOther.mPointer) {}
+
+    EdgeIterator& operator++(int)
+    {
+        if (*mPointer == nsnull) {
+            // Null pointer is a sentinel for link to the next block.
+            mPointer = *(++mPointer);
+        }
+        return *this;
+    }
+
+    PtrInfo* operator*() const
+        { return NS_STATIC_CAST(PtrInfo*, *mPointer); }
+    PRBool operator==(const EdgeIterator& aOther) const
+        { return mPointer == aOther.mPointer; }
+    PRBool operator!=(const EdgeIterator& aOther) const
+        { return mPointer != aOther.mPointer; }
+
+private:
+    void **mPointer;
+};
+
+class EdgePool
+{
+    // EdgePool allocates arrays of void*, primarily to hold PtrInfo*.
+    // However, at the end of a block, the last two pointers are a null
+    // and then a void** pointing to the next block.  This allows
+    // EdgeIterators to be a single word but still capable of crossing
+    // block boundaries.
+
+    EdgePool()
+      : mBlocks(nsnull)
+    {
+    }
+
+    ~EdgePool()
+    {
+        Block *b = mBlocks;
+        while (b) {
+            Block *next = b->Next();
+            delete b;
+            b = next;
+        }
+    }
+
+    class Builder;
+    friend class Builder;
+    class Builder {
+    public:
+        Builder(EdgePool &aPool)
+          : mCurrent(nsnull)
+          , mBlockEnd(nsnull)
+          , mNextBlock(&aPool.mBlocks)
+        {
+        }
+
+        EdgeIterator Mark() { return EdgeIterator(mCurrent); }
+
+        void Add(PtrInfo* aEdge) {
+            if (mCurrent == mBlockEnd) {
+                Block *b = new Block();
+                if (!b) {
+                    // This means we just won't free things.
+                    NS_NOTREACHED("out of memory, ignoring edges");
+                    return;
+                }
+                *mNextBlockPtr = b;
+                mCurrent = b->Start();
+                mBlockEnd = b->End();
+                mNextBlockPtr = &b->Next();
+            }
+            *(mCurrent++) = aEdge;
+        }
+    private:
+        PtrInfo **mCurrent;
+        PtrInfo **mBlockEnd; // mBlockEnd points to space for null sentinel
+        Block **mNextBlockPtr;
+    };
+
+private:
+    Block *mBlocks;
+    enum { BlockSize = 65536 };
+
+    struct Block {
+        void* mPointers[BlockSize];
+        Block() {
+            mPointers[mBlockSize - 2] = nsnull; // sentinel
+            mPointers[mBlockSize - 1] = nsnull; // next block pointer
+        }
+        Block*& Next()
+            { return NS_STATIC_CAST(Block*&, mPointers[mBlockSize - 1]); }
+        PtrInfo** Start()
+            { return NS_STATIC_CAST(PtrInfo**, mPointers); }
+        PtrInfo** End()
+            { return NS_STATIC_CAST(PtrInfo**, mPointers + mBlockSize - 2); }
+    };
+};
+
+
 enum NodeColor { black, white, grey };
 
 // This structure should be kept as small as possible; we may expect
@@ -294,102 +401,136 @@ enum NodeColor { black, white, grey };
 // each cycle collection.
 
 struct PtrInfo
-    : public PLDHashEntryStub
-{
+{
+    void *mPointer;
     PRUint32 mColor : 2;
     PRUint32 mInternalRefs : 30;
     // FIXME: mLang expands back to a full word when bug 368774 lands.
     PRUint32 mLang : 2;
     PRUint32 mRefCount : 30;
+    EdgeIterator mFirstChild; // first
+    EdgeIterator mLastChild; // one after last
 
 #ifdef DEBUG_CC
     size_t mBytes;
     const char *mName;
 #endif
+
+    PtrInfo(void *aPointer)
+      : mPointer(aPointer)
+      , mColor(grey)
+      , mInternalRefs(0)
+      , mLang(nsIProgrammingLanguage::CPLUSPLUS)
+      , mRefCount(0)
+      , mFirstChild(nsnull)
+      , mLastChild(nsnull)
+#ifdef DEBUG_CC
+      , mBytes(0)
+      , mName(nsnull)
+#endif
+    {
+    }
 };
 
-PR_STATIC_CALLBACK(PRBool)
-InitPtrInfo(PLDHashTable *table, PLDHashEntryHdr *entry, const void *key)
-{
-    PtrInfo* pi = (PtrInfo*)entry;
-    pi->key = key;
-    pi->mColor = black;
-    pi->mInternalRefs = 0;
-    pi->mLang = nsIProgrammingLanguage::CPLUSPLUS;
-    pi->mRefCount = 0;
-#ifdef DEBUG_CC
-    pi->mBytes = 0;
-    pi->mName = nsnull;
-#endif
-    return PR_TRUE;
-}
-
-static PLDHashTableOps GCTableOps = {
-    PL_DHashAllocTable,
-    PL_DHashFreeTable,
-    PL_DHashVoidPtrKeyStub,
-    PL_DHashMatchEntryStub,
-    PL_DHashMoveEntryStub,
-    PL_DHashClearEntryStub,
-    PL_DHashFinalizeStub,
-    InitPtrInfo
- };
-
-struct GCTable
-{
-    PLDHashTable mTab;
-
-    GCTable()
-    {
-        Init();
-    }
-    ~GCTable()
-    {
-        if (mTab.ops)
-            PL_DHashTableFinish(&mTab);
-    }
-
-    void Init()
-    {
-        if (!PL_DHashTableInit(&mTab, &GCTableOps, nsnull, sizeof(PtrInfo),
-                               32768))
-            mTab.ops = nsnull;
-    }
-    void Clear()
-    {
-        if (!mTab.ops || mTab.entryCount > 0) {
-            if (mTab.ops)
-                PL_DHashTableFinish(&mTab);
-            Init();
-        }
-    }
-
-    PtrInfo *Lookup(void *key)
-    {
-        if (!mTab.ops)
-            return nsnull;
-
-        PLDHashEntryHdr *entry =
-            PL_DHashTableOperate(&mTab, key, PL_DHASH_LOOKUP);
-
-        return PL_DHASH_ENTRY_IS_BUSY(entry) ? (PtrInfo*)entry : nsnull;
-    }
-
-    PtrInfo *Add(void *key)
-    {
-        if (!mTab.ops)
-            return nsnull;
-
-        return (PtrInfo*)PL_DHashTableOperate(&mTab, key, PL_DHASH_ADD);
-    }
-    
-    void Enumerate(PLDHashEnumerator etor, void *arg)
-    {
-        if (mTab.ops)
-            PL_DHashTableEnumerate(&mTab, etor, arg);
-    }
+// A structure designed to be used like a linked list, but allocated
+// many items at a time.
+
+class NodePool
+{
+private:
+    enum { BlockSize = 32768 }; // could be int template parameter
+
+    struct Block {
+        Block* mNext;
+        PtrInfo mEntries[BlockSize];
+    };
+
+public:
+    NodePool()
+      : mBlocks(nsnull)
+      , mLast(nsnull)
+    {
+    }
+
+    ~NodePool()
+    {
+        Block *b = mBlocks;
+        while (b) {
+            Block *n = mBlocks->mNext;
+            delete b;
+            b = n;
+        }
+    }
+
+    class Builder;
+    friend class Builder;
+    class Builder {
+    public:
+        Builder(NodePool& aPool)
+          : mNextBlock(&aPool.mBlocks)
+          , mNext(aPool.mLast)
+          , mBlockEnd(nsnull)
+        {
+            NS_ASSERTION(aPool.mBlocks == nsnull && aPool.mLast == nsnull,
+                         "pool not empty");
+        }
+        PtrInfo *Add(void *aPointer)
+        {
+            if (mNext == mBlockEnd) {
+                Block *block;
+                if (!(*mNextBlock = block = new Block))
+                    return nsnull;
+                mCurrent = block->mEntries;
+                mBlockEnd = block->mEntries + BlockSize;
+                mNextBlock = &block->mNext;
+            }
+            return new (mNext++) PtrInfo(aPointer);
+        }
+    private:
+        Block **mNextBlock;
+        PtrInfo *&mNext;
+        PtrInfo *mBlockEnd;
+    };
+
+    class Enumerator;
+    friend class Enumerator;
+    class Enumerator {
+    public:
+        Enumerator(NodePool& aPool)
+          : mNextBlock(&aPool.mBlocks)
+          , mNext(nsnull)
+          , mBlockEnd(nsnull)
+          , mLast(aPool.mLast)
+        {
+        }
+
+        PRBool IsDone() const
+        {
+            return mNext == mLast;
+        }
+
+        PtrInfo& GetNext()
+        {
+            NS_ASSERTION(!IsDone(), "calling GetNext when done");
+            if (mNext == mBlockEnd) {
+                Block *nextBlock = *mNextBlock;
+                mNext = nextBlock->mEntries;
+                mBlockEnd = mNext + BlockSize;
+                mNextBlock = &nextBlock->mNext;
+            }
+            return *(mNext++);
+        }
+    private:
+        Block *mNextBlock;
+        // mNext is the next value we want to return, unless mNext == mBlockEnd
+        // NB: mLast is a reference to allow enumerating while building!
+        PtrInfo *mNext, *mBlockEnd, *&mLast;
+    };
+
+private:
+    Block *mBlocks;
+    PtrInfo *mLast;
 };
-
 
 // XXX Would be nice to have an nsHashSet<KeyType> API that has
 // Add/Remove/Has rather than PutEntry/RemoveEntry/GetEntry.
@@ -661,13 +802,17 @@ struct nsCycleCollectionXPCOMRuntime :
     }
 };
 
+struct GCGraph
+{
+    ListPool<PtrInfo> mNodes;
+    ListPool<PtrInfo*> mEdges;
+};
 
 struct nsCycleCollector
 {
     PRBool mCollectionInProgress;
     PRBool mScanInProgress;
 
-    GCTable mGraph;
     nsCycleCollectionLanguageRuntime *mRuntimes[nsIProgrammingLanguage::MAX+1];
     nsCycleCollectionXPCOMRuntime mXPCOMRuntime;
 
@@ -689,9 +834,9 @@ struct nsCycleCollector
     void ForgetRuntime(PRUint32 langID);
 
     void CollectPurple(); // XXXldb Should this be called SelectPurple?
-    void MarkRoots();
-    void ScanRoots();
-    void CollectWhite();
+    void MarkRoots(GCGraph &graph);
+    void ScanRoots(GCGraph &graph);
+    void CollectWhite(GCGraph &graph);
 
     nsCycleCollector();
     ~nsCycleCollector();
@@ -708,7 +853,7 @@ struct nsCycleCollector
 
     FILE *mPtrLog;
 
-    void MaybeDrawGraphs();
+    void MaybeDrawGraphs(GCGraph &graph);
     void ExplainLiveExpectedGarbage();
     void ShouldBeFreed(nsISupports *n);
     void WasFreed(nsISupports *n);
@@ -717,24 +862,14 @@ struct nsCycleCollector
 };
 
 
-class GraphWalker :
-    public nsCycleCollectionTraversalCallback
-{
-private:
-    nsDeque mQueue;
-    PtrInfo *mCurrPi;
-
+class GraphWalker
+{
 protected:
-    GCTable &mGraph;
-    nsCycleCollectionLanguageRuntime **mRuntimes;
+    GCGraph &mGraph;
 
 public:
-    GraphWalker(GCTable & tab,
-                nsCycleCollectionLanguageRuntime **runtimes) : 
-        mQueue(nsnull),
-        mCurrPi(nsnull),
-        mGraph(tab),
-        mRuntimes(runtimes)
+    GraphWalker(GCGraph &graph)
+      : mGraph(graph)
     {}
 
     virtual ~GraphWalker() 
@@ -742,19 +877,9 @@ public:
    
     void Walk(void *s0);
 
-    // nsCycleCollectionTraversalCallback methods.
-#ifdef DEBUG_CC
-    void DescribeNode(size_t refCount, size_t objSz, const char *objName);
-#else
-    void DescribeNode(size_t refCount);
-#endif
-    void NoteXPCOMChild(nsISupports *child);
-    void NoteScriptChild(PRUint32 langID, void *child);
-
     // Provided by concrete walker subtypes.
     virtual PRBool ShouldVisitNode(PtrInfo const *pi) = 0;
-    virtual void VisitNode(PtrInfo *pi, size_t refcount) = 0;
-    virtual void NoteChild(PtrInfo *childpi) = 0;
+    virtual void VisitNode(PtrInfo *pi) = 0;
 };
 
 
@@ -769,26 +894,6 @@ static nsCycleCollector *sCollector = ns
 ////////////////////////////////////////////////////////////////////////
 // Utility functions
 ////////////////////////////////////////////////////////////////////////
-
-#ifdef DEBUG_CC
-
-struct safetyCallback :     
-    public nsCycleCollectionTraversalCallback
-{
-    // This is just a dummy interface to feed to children when we're
-    // called, to force potential segfaults to happen early, so gdb
-    // can give us an informative stack trace. If we don't use it, the
-    // collector runs faster but segfaults happen after pointers have
-    // been queued and dequeued, at which point their owner is
-    // obscure.
-    void DescribeNode(size_t refCount, size_t objSz, const char *objName) {}
-    void NoteXPCOMChild(nsISupports *child) {}
-    void NoteScriptChild(PRUint32 langID, void *child) {}
-};
-
-static safetyCallback sSafetyCallback;
-
-#endif
 
 static void
 Fault(const char *msg, const void *ptr=nsnull)
@@ -825,29 +930,6 @@ Fault(const char *msg, const void *ptr=n
 }
 
 
-void 
-#ifdef DEBUG_CC
-GraphWalker::DescribeNode(size_t refCount, size_t objSz, const char *objName)
-#else
-GraphWalker::DescribeNode(size_t refCount)
-#endif
-{
-    if (refCount == 0)
-        Fault("zero refcount", mCurrPi->key);
-
-#ifdef DEBUG_CC
-    mCurrPi->mBytes = objSz;
-    mCurrPi->mName = objName;
-#endif
-
-    this->VisitNode(mCurrPi, refCount);
-#ifdef DEBUG_CC
-    sCollector->mStats.mVisitedNode++;
-    if (mCurrPi->mLang == nsIProgrammingLanguage::JAVASCRIPT)
-        sCollector->mStats.mVisitedJSNode++;
-#endif
-}
-
 
 static nsISupports *
 canonicalize(nsISupports *in)
@@ -859,8 +941,171 @@ canonicalize(nsISupports *in)
 }
 
 
+void
+GraphWalker::Walk(PtrInfo *s0)
+{
+    nsDeque queue;
+    queue.Push(s0);
+
+    do {
+        PtrInfo *pi = NS_STATIC_CAST(PtrInfo*, queue.PopFront());
+
+        if (this->ShouldVisitNode(pi)) {
+            this->VisitNode(pi);
+            for (EdgeIterator child = pi->mFirstChild,
+                          child_end = pi->mLastChild;
+                 child != child_end; ++child) {
+                queue.Push((*child)->mPointer);
+            }
+        }
+    } while (queue.GetSize() > 0);
+
+#ifdef DEBUG_CC
+    sCollector->mStats.mWalkedGraph++;
+#endif
+}
+
+
+////////////////////////////////////////////////////////////////////////
+// Bacon & Rajan's |MarkRoots| routine.
+////////////////////////////////////////////////////////////////////////
+
+struct PtrToNodeEntry : public PLDHashEntryHdr {
+    // The key is mNode->mPointer
+    PtrInfo *mNode;
+};
+
+PR_STATIC_CALLBACK(PRBool)
+PtrToNodeMatchEntry(PLDHashTable *table,
+                    const PLDHashEntryHdr *entry,
+                    const void *key)
+{
+    const PtrToNodeEntry *n = NS_STATIC_CAST(const PtrToNodeEntry*, entry);
+    return n->mNode->mPointer == key;
+}
+
+static PLDHashTableOps PtrNodeOps = {
+    PL_DHashAllocTable,
+    PL_DHashFreeTable,
+    PL_DHashVoidPtrKeyStub,
+    PtrToNodeMatchEntry,
+    PL_DHashMoveEntryStub,
+    PL_DHashClearEntryStub,
+    PL_DHashFinalizeStub,
+    NULL
+};
+
+class GCGraphBuilder : private nsCycleCollectionTraversalCallback
+{
+private:
+    NodePool::Builder mNodeBuilder;
+    EdgePool::Builder mEdgeBuilder;
+    PLDHashTable mPtrToNodeMap;
+    PtrInfo *mCurrPi;
+    nsCycleCollectionLanguageRuntime **mRuntimes; // weak, from nsCycleCollector
+
+public:
+    GCGraphBuilder(GCGraph &aGraph,
+                   nsCycleCollectionLanguageRuntime **aRuntimes)
+      : mNodeBuilder(aGraph.mNodePool)
+      , mEdgeBuilder(aGraph.mEdgePool)
+      , mRuntimes(aRuntimes)
+    {
+        if (!PL_DHashTableInit(&mPtrToNodeMap, &PtrNodeOps, nsnull,
+                               sizeof(PtrToNodeEntry), 32768))
+            mPtrToNodeMap.ops = nsnull;
+    }
+
+    ~GCGraphBuilder()
+    {
+        if (mPtrToNodeMap.ops)
+            PL_DHashTableFinish(&mPtrToNodeMap);
+    }
+
+    PtrInfo* AddNode(nsISupports *s);
+    {
+        s = canonicalize(s);
+
+        PtrToNodeEntry *e =
+            PL_DHashTableOperate(&mPtrToNodeMap, s, PL_DHASH_ADD);
+        if (!e->mNode) {
+            // New entry.
+            PtrInfo *result = mNodeBuilder.Add(aPointer);
+            if (!result) {
+                PL_DHashTableRawRemove(&mPtrToNodeMap, e);
+                return nsnull;
+            }
+            e->mNode = result;
+        } else {
+            result = e->mNode;
+        }
+        return result;
+    }
+
+    void Traverse(PtrInfo* aPtrInfo)
+    {
+        mCurrPI = aPtrInfo;
+        // XXX What if this is null and we add children!
+        // Need to allocate first pool, but only if we have nodes!
+        mCurrPI->mFirstChild = mEdgeBuilder.Mark();
+
+#ifdef DEBUG_CC
+        if (mCurrPi->mLang > nsIProgrammingLanguage::MAX ) {
+            Fault("unknown language during walk");
+            continue;
+        }
+
+        if (!mRuntimes[mCurrPi->mLang]) {
+            Fault("script pointer for unregistered language");
+            continue;
+        }
+#endif
+        
+        nsresult rv =
+            mRuntimes[aPtrInfo->mLang]->Traverse(aPtrInfo->mPointer, *this);
+        if (NS_FAILED(rv)) {
+            Fault("script pointer traversal failed", aPtrInfo->mPointer);
+        }
+
+        mCurrPI->mLastChild = mEdgeBuilder.Mark();
+    }
+
+private:
+    // nsCycleCollectionTraversalCallback methods.
+#ifdef DEBUG_CC
+    void DescribeNode(size_t refCount, size_t objSz, const char *objName);
+#else
+    void DescribeNode(size_t refCount);
+#endif
+    void NoteXPCOMChild(nsISupports *child);
+    void NoteScriptChild(PRUint32 langID, void *child);
+};
+
 void 
-GraphWalker::NoteXPCOMChild(nsISupports *child) 
+#ifdef DEBUG_CC
+GCGraphBuilder::DescribeNode(size_t refCount, size_t objSz, const char *objName)
+#else
+GCGraphBuilder::DescribeNode(size_t refCount)
+#endif
+{
+    if (refCount == 0)
+        Fault("zero refcount", mCurrPi->key);
+
+#ifdef DEBUG_CC
+    mCurrPi->mBytes = objSz;
+    mCurrPi->mName = objName;
+#endif
+
+    mCurrPi->mRefCount = refCount;
+#ifdef DEBUG_CC
+    sCollector->mStats.mVisitedNode++;
+    if (mCurrPi->mLang == nsIProgrammingLanguage::JAVASCRIPT)
+        sCollector->mStats.mVisitedJSNode++;
+#endif
+}
+
+void 
+GCGraphBuilder::NoteXPCOMChild(nsISupports *child) 
 {
     if (!child)
         return; 
@@ -872,20 +1117,16 @@ GraphWalker::NoteXPCOMChild(nsISupports 
     scanSafe &= !nsCycleCollector_shouldSuppress(child);
 #endif
     if (scanSafe) {
-        PtrInfo *childPi = mGraph.Add(child);
+        PtrInfo *childPi = AddNode(child);
         if (!childPi)
             return;
-        this->NoteChild(childPi);
-#ifdef DEBUG_CC
-        mRuntimes[nsIProgrammingLanguage::CPLUSPLUS]->Traverse(child, sSafetyCallback);
-#endif
-        mQueue.Push(child);
-    }
-}
-
+        mEdgeBuilder.Add(childPI);
+        ++childPi->mInternalRefs;
+    }
+}
 
 void
-GraphWalker::NoteScriptChild(PRUint32 langID, void *child) 
+GCGraphBuilder::NoteScriptChild(PRUint32 langID, void *child) 
 {
     if (!child)
         return;
@@ -895,91 +1136,14 @@ GraphWalker::NoteScriptChild(PRUint32 la
         return;
     }
 
-    PtrInfo *childPi = mGraph.Add(child);
+    PtrInfo *childPi = AddNode(child);
     if (!childPi)
         return;
+    mEdgeBuilder.Add(childPI);
+    ++childPi->mInternalRefs;
     childPi->mLang = langID;
-    this->NoteChild(childPi);
-#ifdef DEBUG_CC
-    mRuntimes[langID]->Traverse(child, sSafetyCallback);
-#endif
-    mQueue.Push(child);
-}
-
-
-void
-GraphWalker::Walk(void *s0)
-{
-    mQueue.Empty();
-    mQueue.Push(s0);
-
-    while (mQueue.GetSize() > 0) {
-
-        void *ptr = mQueue.Pop();
-        mCurrPi = mGraph.Lookup(ptr);
-
-        if (!mCurrPi) {
-            Fault("unknown pointer", ptr);
-            continue;
-        }
-
-#ifdef DEBUG_CC
-        if (mCurrPi->mLang > nsIProgrammingLanguage::MAX ) {
-            Fault("unknown language during walk");
-            continue;
-        }
-
-        if (!mRuntimes[mCurrPi->mLang]) {
-            Fault("script pointer for unregistered language");
-            continue;
-        }
-#endif
-        
-        if (this->ShouldVisitNode(mCurrPi)) {
-            nsresult rv = mRuntimes[mCurrPi->mLang]->Traverse(ptr, *this);
-            if (NS_FAILED(rv)) {
-                Fault("script pointer traversal failed", ptr);
-            }
-        }
-    }
-
-#ifdef DEBUG_CC
-    sCollector->mStats.mWalkedGraph++;
-#endif
-}
-
-
-////////////////////////////////////////////////////////////////////////
-// Bacon & Rajan's |MarkRoots| routine.
-////////////////////////////////////////////////////////////////////////
-
-
-struct MarkGreyWalker : public GraphWalker
-{
-    MarkGreyWalker(GCTable &tab,
-                   nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes) 
-    {}
-
-    PRBool ShouldVisitNode(PtrInfo const *pi)
-    { 
-        return pi->mColor != grey;
-    }
-
-    void VisitNode(PtrInfo *pi, size_t refcount)
-    { 
-        pi->mColor = grey;
-        pi->mRefCount = refcount;
-#ifdef DEBUG_CC
-        sCollector->mStats.mSetColorGrey++;
-#endif
-    }
-
-    void NoteChild(PtrInfo *childpi)
-    { 
-        childpi->mInternalRefs++;
-    }
-};
+}
+
 
 void 
 nsCycleCollector::CollectPurple()
@@ -988,14 +1152,22 @@ nsCycleCollector::CollectPurple()
 }
 
 void
-nsCycleCollector::MarkRoots()
-{
+nsCycleCollector::MarkRoots(GCGraph &graph)
+{
+    GCGraphBuilder builder(graph, mRuntimes);
+
     int i;
     for (i = 0; i < mBufs[0].GetSize(); ++i) {
         nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0].ObjectAt(i));
-        s = canonicalize(s);
-        mGraph.Add(s);
-        MarkGreyWalker(mGraph, mRuntimes).Walk(s);
+        PtrInfo *pi = builder.AddNode(s);
+    }
+
+    // read the PtrInfo out of the graph that we are building
+    NodePool::enumerator queue(graph.mNodePool);
+    while (queue.IsDone()) {
+        PtrInfo &pi = queue.GetNext();
+        builder.Traverse(&pi);
+        // XXX Call Traverse, fill in parent, create children, and add edges
     }
 }
 
@@ -1007,9 +1179,9 @@ nsCycleCollector::MarkRoots()
 
 struct ScanBlackWalker : public GraphWalker
 {
-    ScanBlackWalker(GCTable &tab,
-                   nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes) 
+    ScanBlackWalker(GCGraph &graph,
+                    nsCycleCollectionLanguageRuntime **runtimes)
+        : GraphWalker(graph, runtimes) 
     {}
 
     PRBool ShouldVisitNode(PtrInfo const *pi)
@@ -1017,23 +1189,21 @@ struct ScanBlackWalker : public GraphWal
         return pi->mColor != black;
     }
 
-    void VisitNode(PtrInfo *pi, size_t refcount)
+    void VisitNode(PtrInfo *pi)
     { 
         pi->mColor = black;
 #ifdef DEBUG_CC
         sCollector->mStats.mSetColorBlack++;
 #endif
     }
-
-    void NoteChild(PtrInfo *childpi) {}
 };
 
 
 struct scanWalker : public GraphWalker
 {
-    scanWalker(GCTable &tab,
+    scanWalker(GCGraph &graph,
                nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes) 
+        : GraphWalker(graph, runtimes) 
     {}
 
     PRBool ShouldVisitNode(PtrInfo const *pi)
@@ -1041,7 +1211,7 @@ struct scanWalker : public GraphWalker
         return pi->mColor == grey;
     }
 
-    void VisitNode(PtrInfo *pi, size_t refcount)
+    void VisitNode(PtrInfo *pi)
     {
         if (pi->mColor != grey)
             Fault("scanning non-grey node", pi->key);
@@ -1061,7 +1231,6 @@ struct scanWalker : public GraphWalker
                          "Why didn't ScanBlackWalker make pi black?");
         }
     }
-    void NoteChild(PtrInfo *childpi) {}
 };
 
 
@@ -1079,20 +1248,20 @@ NoGreyCallback(PLDHashTable *table, PLDH
 
 
 void
-nsCycleCollector::ScanRoots()
+nsCycleCollector::ScanRoots(GCGraph &graph)
 {
     int i;
 
     for (i = 0; i < mBufs[0].GetSize(); ++i) {
         nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0].ObjectAt(i));
         s = canonicalize(s);
-        scanWalker(mGraph, mRuntimes).Walk(s); 
+        scanWalker(graph, mRuntimes).Walk(s); 
     }
 
 #ifdef DEBUG_CC
     // Sanity check: scan should have colored all grey nodes black or
     // white. So we ensure we have no grey nodes at this point.
-    mGraph.Enumerate(NoGreyCallback, this);
+    graph.Enumerate(NoGreyCallback, this);
 #endif
 }
 
@@ -1137,7 +1306,7 @@ FindWhiteCallback(PLDHashTable *table, P
 
 
 void
-nsCycleCollector::CollectWhite()
+nsCycleCollector::CollectWhite(GCGraph &graph)
 {
     // Explanation of "somewhat modified": we have no way to collect the
     // set of whites "all at once", we have to ask each of them to drop
@@ -1164,7 +1333,7 @@ nsCycleCollector::CollectWhite()
     _CrtMemCheckpoint(&ms1);
 #endif
 
-    mGraph.Enumerate(FindWhiteCallback, this);
+    graph.Enumerate(FindWhiteCallback, this);
 
     for (i = 0; i < nsIProgrammingLanguage::MAX+1; ++i) {
         if (mRuntimes[i] &&
@@ -1225,9 +1394,9 @@ struct graphVizWalker : public GraphWalk
     const void *mParent;
     FILE *mStream;
 
-    graphVizWalker(GCTable &tab,
+    graphVizWalker(GCGraph &graph,
                    nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes), 
+        : GraphWalker(graph, runtimes), 
           mParent(nsnull), 
           mStream(nsnull)        
     {
@@ -1270,7 +1439,7 @@ struct graphVizWalker : public GraphWalk
         return ! mVisited.GetEntry(pi->key);
     }
 
-    void VisitNode(PtrInfo *pi, size_t refcount)
+    void VisitNode(PtrInfo *pi)
     {
         const void *p = pi->key;
         mVisited.PutEntry(p);
@@ -1284,11 +1453,10 @@ struct graphVizWalker : public GraphWalk
                 pi->mInternalRefs, pi->mRefCount,
                 (pi->mColor == black ? "black" : "white"),
                 (pi->mColor == black ? "white" : "black"));
-    }
-
-    void NoteChild(PtrInfo *childpi)
-    { 
-        fprintf(mStream, "n%p -> n%p\n", mParent, childpi->key);
+        for (EdgeIterator child = pi->mFirstChild, child_end = pi->mLastChild;
+             child != child_end; ++child) {
+            fprintf(mStream, "n%p -> n%p\n", mParent, (*child)->mPointer);
+        }
     }
 };
 
@@ -1511,8 +1679,6 @@ nsCycleCollector::nsCycleCollector() :
 
 nsCycleCollector::~nsCycleCollector()
 {
-    mGraph.Clear();    
-
     for (PRUint32 i = 0; i < nsIProgrammingLanguage::MAX+1; ++i) {
         mRuntimes[i] = NULL;
     }
@@ -1567,15 +1733,15 @@ FindAnyWhiteCallback(PLDHashTable *table
 
 
 void 
-nsCycleCollector::MaybeDrawGraphs()
+nsCycleCollector::MaybeDrawGraphs(GCGraph &graph)
 {
     if (mParams.mDrawGraphs) {
         // We draw graphs only if there were any white nodes.
         PRBool anyWhites = PR_FALSE;
-        mGraph.Enumerate(FindAnyWhiteCallback, &anyWhites);
+        graph.Enumerate(FindAnyWhiteCallback, &anyWhites);
 
         if (anyWhites) {
-            graphVizWalker gw(mGraph, mRuntimes);
+            graphVizWalker gw(graph, mRuntimes);
             while (mBufs[0].GetSize() > 0) {
                 nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0].Pop());
                 s = canonicalize(s);
@@ -1804,14 +1970,14 @@ nsCycleCollector::Collect(PRUint32 aTryC
 
                 mScanInProgress = PR_TRUE;
 
-                mGraph.Clear();
+                GCGraph graph;
 
                 // The main Bacon & Rajan collection algorithm.
 
 #ifdef COLLECT_TIME_DEBUG
                 now = PR_Now();
 #endif
-                MarkRoots();
+                MarkRoots(graph);
 
 #ifdef COLLECT_TIME_DEBUG
                 {
@@ -1822,7 +1988,7 @@ nsCycleCollector::Collect(PRUint32 aTryC
                 }
 #endif
 
-                ScanRoots();
+                ScanRoots(graph);
 
 #ifdef COLLECT_TIME_DEBUG
                 printf("cc: ScanRoots() took %lldms\n",
@@ -1830,7 +1996,7 @@ nsCycleCollector::Collect(PRUint32 aTryC
 #endif
 
 #ifdef DEBUG_CC
-                MaybeDrawGraphs();
+                MaybeDrawGraphs(graph);
 #endif
 
                 mScanInProgress = PR_FALSE;
@@ -1839,7 +2005,7 @@ nsCycleCollector::Collect(PRUint32 aTryC
 #ifdef COLLECT_TIME_DEBUG
                 now = PR_Now();
 #endif
-                CollectWhite();
+                CollectWhite(graph);
 
 #ifdef COLLECT_TIME_DEBUG
                 printf("cc: CollectWhite() took %lldms\n",
@@ -1847,8 +2013,6 @@ nsCycleCollector::Collect(PRUint32 aTryC
 #endif
 
                 // Some additional book-keeping.
-
-                mGraph.Clear();
 
                 --aTryCollections;
             }
@@ -1911,9 +2075,9 @@ AddExpectedGarbage(nsVoidPtrHashKey *p, 
 
 struct explainWalker : public GraphWalker
 {
-    explainWalker(GCTable &tab,
+    explainWalker(GCGraph &graph,
                   nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes) 
+        : GraphWalker(graph, runtimes) 
     {}
 
     PRBool ShouldVisitNode(PtrInfo const *pi)
@@ -1922,7 +2086,7 @@ struct explainWalker : public GraphWalke
         return pi->mColor != grey;
     }
 
-    void VisitNode(PtrInfo *pi, size_t refcount)
+    void VisitNode(PtrInfo *pi)
     {
         if (pi->mColor == grey)
             Fault("scanning grey node", pi->key);
@@ -1945,7 +2109,6 @@ struct explainWalker : public GraphWalke
 
         pi->mColor = grey;
     }
-    void NoteChild(PtrInfo *childpi) {}
 };
 
 void
@@ -1968,25 +2131,26 @@ nsCycleCollector::ExplainLiveExpectedGar
     mCollectionInProgress = PR_TRUE;
     mScanInProgress = PR_TRUE;
 
-    mGraph.Clear();
-    mBufs[0].Empty();
-
-    // Instead of filling mBufs[0] from the purple buffer, we fill it
-    // from the list of nodes we were expected to collect.
-    mExpectedGarbage.EnumerateEntries(&AddExpectedGarbage, this);
-
-    MarkRoots();
-    ScanRoots();
-
-    mScanInProgress = PR_FALSE;
-
-    for (int i = 0; i < mBufs[0].GetSize(); ++i) {
-        nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0].ObjectAt(i));
-        s = canonicalize(s);
-        explainWalker(mGraph, mRuntimes).Walk(s); 
-    }
-
-    mGraph.Clear();
+    {
+        GCGraph graph;
+        mBufs[0].Empty();
+
+        // Instead of filling mBufs[0] from the purple buffer, we fill it
+        // from the list of nodes we were expected to collect.
+        mExpectedGarbage.EnumerateEntries(&AddExpectedGarbage, this);
+
+        MarkRoots(graph);
+        ScanRoots(graph);
+
+        mScanInProgress = PR_FALSE;
+
+        for (int i = 0; i < mBufs[0].GetSize(); ++i) {
+            nsISupports *s =
+                NS_STATIC_CAST(nsISupports *, mBufs[0].ObjectAt(i));
+            s = canonicalize(s);
+            explainWalker(graph, mRuntimes).Walk(s); 
+        }
+    }
 
     mCollectionInProgress = PR_FALSE;
 
