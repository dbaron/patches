Record results of cycle collection traversal so we only have to call the traversal APIs once per collection.  b=378514

diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -1,4 +1,5 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim: set cindent tabstop=4 expandtab shiftwidth=4: */
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
@@ -287,6 +288,135 @@ nsCycleCollector_shouldSuppress(nsISuppo
 // Base types
 ////////////////////////////////////////////////////////////////////////
 
+struct PtrInfo;
+
+class EdgePool
+{
+public:
+    // EdgePool allocates arrays of void*, primarily to hold PtrInfo*.
+    // However, at the end of a block, the last two pointers are a null
+    // and then a void** pointing to the next block.  This allows
+    // EdgePool::Iterators to be a single word but still capable of crossing
+    // block boundaries.
+
+    EdgePool()
+    {
+        mSentinelAndBlocks[0].block = nsnull;
+        mSentinelAndBlocks[1].block = nsnull;
+    }
+
+    ~EdgePool()
+    {
+        Block *b = Blocks();
+        while (b) {
+            Block *next = b->Next();
+            delete b;
+            b = next;
+        }
+    }
+
+private:
+    struct Block;
+    union PtrInfoOrBlock {
+        // Use a union to avoid reinterpret_cast and the ensuing
+        // potential aliasing bugs.
+        PtrInfo *ptrInfo;
+        Block *block;
+    };
+    struct Block {
+        enum { BlockSize = 65536 };
+
+        PtrInfoOrBlock mPointers[BlockSize];
+        Block() {
+            mPointers[BlockSize - 2].block = nsnull; // sentinel
+            mPointers[BlockSize - 1].block = nsnull; // next block pointer
+        }
+        Block*& Next()
+            { return mPointers[BlockSize - 1].block; }
+        PtrInfoOrBlock* Start()
+            { return &mPointers[0]; }
+        PtrInfoOrBlock* End()
+            { return &mPointers[BlockSize - 2]; }
+    };
+
+    // Store the null sentinel so that we can have valid iterators
+    // before adding any edges and without adding any blocks.
+    PtrInfoOrBlock mSentinelAndBlocks[2];
+
+    Block*& Blocks() { return mSentinelAndBlocks[1].block; }
+
+public:
+    class Iterator
+    {
+    public:
+        Iterator() : mPointer(nsnull) {}
+        Iterator(PtrInfoOrBlock *aPointer) : mPointer(aPointer) {}
+        Iterator(const Iterator& aOther) : mPointer(aOther.mPointer) {}
+
+        Iterator& operator++()
+        {
+            if (mPointer->ptrInfo == nsnull) {
+                // Null pointer is a sentinel for link to the next block.
+                mPointer = (mPointer + 1)->block->mPointers;
+            }
+            ++mPointer;
+            return *this;
+        }
+
+        PtrInfo* operator*() const
+        {
+            if (mPointer->ptrInfo == nsnull) {
+                // Null pointer is a sentinel for link to the next block.
+                return (mPointer + 1)->block->mPointers->ptrInfo;
+            }
+            return mPointer->ptrInfo;
+        }
+        PRBool operator==(const Iterator& aOther) const
+            { return mPointer == aOther.mPointer; }
+        PRBool operator!=(const Iterator& aOther) const
+            { return mPointer != aOther.mPointer; }
+
+    private:
+        PtrInfoOrBlock *mPointer;
+    };
+
+    class Builder;
+    friend class Builder;
+    class Builder {
+    public:
+        Builder(EdgePool &aPool)
+          : mCurrent(&aPool.mSentinelAndBlocks[0])
+          , mBlockEnd(&aPool.mSentinelAndBlocks[0])
+          , mNextBlockPtr(&aPool.Blocks())
+        {
+        }
+
+        EdgePool::Iterator Mark() { return EdgePool::Iterator(mCurrent); }
+
+        void Add(PtrInfo* aEdge) {
+            if (mCurrent == mBlockEnd) {
+                EdgePool::Block *b = new EdgePool::Block();
+                if (!b) {
+                    // This means we just won't free things.
+                    NS_NOTREACHED("out of memory, ignoring edges");
+                    return;
+                }
+                *mNextBlockPtr = b;
+                mCurrent = b->Start();
+                mBlockEnd = b->End();
+                mNextBlockPtr = &b->Next();
+            }
+            (mCurrent++)->ptrInfo = aEdge;
+        }
+    private:
+        // mBlockEnd points to space for null sentinel
+        PtrInfoOrBlock *mCurrent, *mBlockEnd;
+        EdgePool::Block **mNextBlockPtr;
+    };
+
+};
+
+
 enum NodeColor { black, white, grey };
 
 // This structure should be kept as small as possible; we may expect
@@ -294,102 +424,142 @@ enum NodeColor { black, white, grey };
 // each cycle collection.
 
 struct PtrInfo
-    : public PLDHashEntryStub
-{
+{
+    void *mPointer;
     PRUint32 mColor : 2;
     PRUint32 mInternalRefs : 30;
     // FIXME: mLang expands back to a full word when bug 368774 lands.
     PRUint32 mLang : 2;
     PRUint32 mRefCount : 30;
+    EdgePool::Iterator mFirstChild; // first
+    EdgePool::Iterator mLastChild; // one after last
 
 #ifdef DEBUG_CC
     size_t mBytes;
     const char *mName;
 #endif
+
+    PtrInfo(void *aPointer)
+      : mPointer(aPointer)
+      , mColor(grey)
+      , mInternalRefs(0)
+      , mLang(nsIProgrammingLanguage::CPLUSPLUS)
+      , mRefCount(0)
+      , mFirstChild()
+      , mLastChild()
+#ifdef DEBUG_CC
+      , mBytes(0)
+      , mName(nsnull)
+#endif
+    {
+    }
+
+    // Allow uninitialized values in large arrays.
+    PtrInfo() {}
 };
 
-PR_STATIC_CALLBACK(PRBool)
-InitPtrInfo(PLDHashTable *table, PLDHashEntryHdr *entry, const void *key)
-{
-    PtrInfo* pi = (PtrInfo*)entry;
-    pi->key = key;
-    pi->mColor = black;
-    pi->mInternalRefs = 0;
-    pi->mLang = nsIProgrammingLanguage::CPLUSPLUS;
-    pi->mRefCount = 0;
-#ifdef DEBUG_CC
-    pi->mBytes = 0;
-    pi->mName = nsnull;
-#endif
-    return PR_TRUE;
-}
-
-static PLDHashTableOps GCTableOps = {
-    PL_DHashAllocTable,
-    PL_DHashFreeTable,
-    PL_DHashVoidPtrKeyStub,
-    PL_DHashMatchEntryStub,
-    PL_DHashMoveEntryStub,
-    PL_DHashClearEntryStub,
-    PL_DHashFinalizeStub,
-    InitPtrInfo
- };
-
-struct GCTable
-{
-    PLDHashTable mTab;
-
-    GCTable()
-    {
-        Init();
-    }
-    ~GCTable()
-    {
-        if (mTab.ops)
-            PL_DHashTableFinish(&mTab);
-    }
-
-    void Init()
-    {
-        if (!PL_DHashTableInit(&mTab, &GCTableOps, nsnull, sizeof(PtrInfo),
-                               32768))
-            mTab.ops = nsnull;
-    }
-    void Clear()
-    {
-        if (!mTab.ops || mTab.entryCount > 0) {
-            if (mTab.ops)
-                PL_DHashTableFinish(&mTab);
-            Init();
-        }
-    }
-
-    PtrInfo *Lookup(void *key)
-    {
-        if (!mTab.ops)
-            return nsnull;
-
-        PLDHashEntryHdr *entry =
-            PL_DHashTableOperate(&mTab, key, PL_DHASH_LOOKUP);
-
-        return PL_DHASH_ENTRY_IS_BUSY(entry) ? (PtrInfo*)entry : nsnull;
-    }
-
-    PtrInfo *Add(void *key)
-    {
-        if (!mTab.ops)
-            return nsnull;
-
-        return (PtrInfo*)PL_DHashTableOperate(&mTab, key, PL_DHASH_ADD);
-    }
-    
-    void Enumerate(PLDHashEnumerator etor, void *arg)
-    {
-        if (mTab.ops)
-            PL_DHashTableEnumerate(&mTab, etor, arg);
-    }
+// A structure designed to be used like a linked list, but allocated
+// many items at a time.
+
+class NodePool
+{
+private:
+    enum { BlockSize = 32768 }; // could be int template parameter
+
+    struct Block {
+        Block* mNext;
+        PtrInfo mEntries[BlockSize];
+
+        Block() : mNext(nsnull) {}
+    };
+
+public:
+    NodePool()
+      : mBlocks(nsnull)
+      , mLast(nsnull)
+    {
+    }
+
+    ~NodePool()
+    {
+        Block *b = mBlocks;
+        while (b) {
+            Block *n = mBlocks->mNext;
+            delete b;
+            b = n;
+        }
+    }
+
+    class Builder;
+    friend class Builder;
+    class Builder {
+    public:
+        Builder(NodePool& aPool)
+          : mNextBlock(&aPool.mBlocks)
+          , mNext(aPool.mLast)
+          , mBlockEnd(nsnull)
+        {
+            NS_ASSERTION(aPool.mBlocks == nsnull && aPool.mLast == nsnull,
+                         "pool not empty");
+        }
+        PtrInfo *Add(void *aPointer)
+        {
+            if (mNext == mBlockEnd) {
+                Block *block;
+                if (!(*mNextBlock = block = new Block()))
+                    return nsnull;
+                mNext = block->mEntries;
+                mBlockEnd = block->mEntries + BlockSize;
+                mNextBlock = &block->mNext;
+            }
+            return new (mNext++) PtrInfo(aPointer);
+        }
+    private:
+        Block **mNextBlock;
+        PtrInfo *&mNext;
+        PtrInfo *mBlockEnd;
+    };
+
+    class Enumerator;
+    friend class Enumerator;
+    class Enumerator {
+    public:
+        Enumerator(NodePool& aPool)
+          : mFirstBlock(aPool.mBlocks)
+          , mCurBlock(nsnull)
+          , mNext(nsnull)
+          , mBlockEnd(nsnull)
+          , mLast(aPool.mLast)
+        {
+        }
+
+        PRBool IsDone() const
+        {
+            return mNext == mLast;
+        }
+
+        PtrInfo* GetNext()
+        {
+            NS_ASSERTION(!IsDone(), "calling GetNext when done");
+            if (mNext == mBlockEnd) {
+                Block *nextBlock = mCurBlock ? mCurBlock->mNext : mFirstBlock;
+                mNext = nextBlock->mEntries;
+                mBlockEnd = mNext + BlockSize;
+                mCurBlock = nextBlock;
+            }
+            return mNext++;
+        }
+    private:
+        Block *mFirstBlock, *mCurBlock;
+        // mNext is the next value we want to return, unless mNext == mBlockEnd
+        // NB: mLast is a reference to allow enumerating while building!
+        PtrInfo *mNext, *mBlockEnd, *&mLast;
+    };
+
+private:
+    Block *mBlocks;
+    PtrInfo *mLast;
 };
-
 
 // XXX Would be nice to have an nsHashSet<KeyType> API that has
 // Add/Remove/Has rather than PutEntry/RemoveEntry/GetEntry.
@@ -661,13 +831,20 @@ struct nsCycleCollectionXPCOMRuntime :
     }
 };
 
+struct GCGraph
+{
+    NodePool mNodes;
+    EdgePool mEdges;
+    PRUint32 mRootCount;
+
+    GCGraph() : mRootCount(0) {}
+};
 
 struct nsCycleCollector
 {
     PRBool mCollectionInProgress;
     PRBool mScanInProgress;
 
-    GCTable mGraph;
     nsCycleCollectionLanguageRuntime *mRuntimes[nsIProgrammingLanguage::MAX+1];
     nsCycleCollectionXPCOMRuntime mXPCOMRuntime;
 
@@ -689,9 +866,9 @@ struct nsCycleCollector
     void ForgetRuntime(PRUint32 langID);
 
     void CollectPurple(); // XXXldb Should this be called SelectPurple?
-    void MarkRoots();
-    void ScanRoots();
-    void CollectWhite();
+    void MarkRoots(GCGraph &graph);
+    void ScanRoots(GCGraph &graph);
+    void CollectWhite(GCGraph &graph);
 
     nsCycleCollector();
     ~nsCycleCollector();
@@ -708,7 +885,7 @@ struct nsCycleCollector
 
     FILE *mPtrLog;
 
-    void MaybeDrawGraphs();
+    void MaybeDrawGraphs(GCGraph &graph);
     void ExplainLiveExpectedGarbage();
     void ShouldBeFreed(nsISupports *n);
     void WasFreed(nsISupports *n);
@@ -717,44 +894,26 @@ struct nsCycleCollector
 };
 
 
-class GraphWalker :
-    public nsCycleCollectionTraversalCallback
-{
-private:
-    nsDeque mQueue;
-    PtrInfo *mCurrPi;
-
+class GraphWalker
+{
 protected:
-    GCTable &mGraph;
-    nsCycleCollectionLanguageRuntime **mRuntimes;
+    GCGraph &mGraph;
+    void DoWalk(nsDeque &aQueue);
 
 public:
-    GraphWalker(GCTable & tab,
-                nsCycleCollectionLanguageRuntime **runtimes) : 
-        mQueue(nsnull),
-        mCurrPi(nsnull),
-        mGraph(tab),
-        mRuntimes(runtimes)
+    GraphWalker(GCGraph &graph)
+      : mGraph(graph)
     {}
 
     virtual ~GraphWalker() 
     {}
    
-    void Walk(void *s0);
-
-    // nsCycleCollectionTraversalCallback methods.
-#ifdef DEBUG_CC
-    void DescribeNode(size_t refCount, size_t objSz, const char *objName);
-#else
-    void DescribeNode(size_t refCount);
-#endif
-    void NoteXPCOMChild(nsISupports *child);
-    void NoteScriptChild(PRUint32 langID, void *child);
+    void Walk(PtrInfo *s0);
+    void WalkFromRoots();
 
     // Provided by concrete walker subtypes.
     virtual PRBool ShouldVisitNode(PtrInfo const *pi) = 0;
-    virtual void VisitNode(PtrInfo *pi, size_t refcount) = 0;
-    virtual void NoteChild(PtrInfo *childpi) = 0;
+    virtual void VisitNode(PtrInfo *pi) = 0;
 };
 
 
@@ -769,26 +928,6 @@ static nsCycleCollector *sCollector = ns
 ////////////////////////////////////////////////////////////////////////
 // Utility functions
 ////////////////////////////////////////////////////////////////////////
-
-#ifdef DEBUG_CC
-
-struct safetyCallback :     
-    public nsCycleCollectionTraversalCallback
-{
-    // This is just a dummy interface to feed to children when we're
-    // called, to force potential segfaults to happen early, so gdb
-    // can give us an informative stack trace. If we don't use it, the
-    // collector runs faster but segfaults happen after pointers have
-    // been queued and dequeued, at which point their owner is
-    // obscure.
-    void DescribeNode(size_t refCount, size_t objSz, const char *objName) {}
-    void NoteXPCOMChild(nsISupports *child) {}
-    void NoteScriptChild(PRUint32 langID, void *child) {}
-};
-
-static safetyCallback sSafetyCallback;
-
-#endif
 
 static void
 Fault(const char *msg, const void *ptr=nsnull)
@@ -825,29 +964,6 @@ Fault(const char *msg, const void *ptr=n
 }
 
 
-void 
-#ifdef DEBUG_CC
-GraphWalker::DescribeNode(size_t refCount, size_t objSz, const char *objName)
-#else
-GraphWalker::DescribeNode(size_t refCount)
-#endif
-{
-    if (refCount == 0)
-        Fault("zero refcount", mCurrPi->key);
-
-#ifdef DEBUG_CC
-    mCurrPi->mBytes = objSz;
-    mCurrPi->mName = objName;
-#endif
-
-    this->VisitNode(mCurrPi, refCount);
-#ifdef DEBUG_CC
-    sCollector->mStats.mVisitedNode++;
-    if (mCurrPi->mLang == nsIProgrammingLanguage::JAVASCRIPT)
-        sCollector->mStats.mVisitedJSNode++;
-#endif
-}
-
 
 static nsISupports *
 canonicalize(nsISupports *in)
@@ -859,8 +975,189 @@ canonicalize(nsISupports *in)
 }
 
 
+void
+GraphWalker::Walk(PtrInfo *s0)
+{
+    nsDeque queue;
+    queue.Push(s0);
+    DoWalk(queue);
+}
+
+void
+GraphWalker::WalkFromRoots()
+{
+    nsDeque queue;
+    NodePool::Enumerator etor(mGraph.mNodes);
+    for (PRUint32 i = 0; i < mGraph.mRootCount; ++i) {
+        queue.Push(etor.GetNext());
+    }
+    DoWalk(queue);
+}
+
+void
+GraphWalker::DoWalk(nsDeque &aQueue)
+{
+    // Use a aQueue to match the breadth-first traversal used when we
+    // built the graph, for hopefully-better locality.
+    while (aQueue.GetSize() > 0) {
+        PtrInfo *pi = NS_STATIC_CAST(PtrInfo*, aQueue.PopFront());
+
+        if (this->ShouldVisitNode(pi)) {
+            this->VisitNode(pi);
+            for (EdgePool::Iterator child = pi->mFirstChild,
+                                child_end = pi->mLastChild;
+                 child != child_end; ++child) {
+                aQueue.Push(*child);
+            }
+        }
+    };
+
+#ifdef DEBUG_CC
+    sCollector->mStats.mWalkedGraph++;
+#endif
+}
+
+
+////////////////////////////////////////////////////////////////////////
+// Bacon & Rajan's |MarkRoots| routine.
+////////////////////////////////////////////////////////////////////////
+
+struct PtrToNodeEntry : public PLDHashEntryHdr {
+    // The key is mNode->mPointer
+    PtrInfo *mNode;
+};
+
+PR_STATIC_CALLBACK(PRBool)
+PtrToNodeMatchEntry(PLDHashTable *table,
+                    const PLDHashEntryHdr *entry,
+                    const void *key)
+{
+    const PtrToNodeEntry *n = NS_STATIC_CAST(const PtrToNodeEntry*, entry);
+    return n->mNode->mPointer == key;
+}
+
+static PLDHashTableOps PtrNodeOps = {
+    PL_DHashAllocTable,
+    PL_DHashFreeTable,
+    PL_DHashVoidPtrKeyStub,
+    PtrToNodeMatchEntry,
+    PL_DHashMoveEntryStub,
+    PL_DHashClearEntryStub,
+    PL_DHashFinalizeStub,
+    NULL
+};
+
+class GCGraphBuilder : private nsCycleCollectionTraversalCallback
+{
+private:
+    NodePool::Builder mNodeBuilder;
+    EdgePool::Builder mEdgeBuilder;
+    PLDHashTable mPtrToNodeMap;
+    PtrInfo *mCurrPi;
+    nsCycleCollectionLanguageRuntime **mRuntimes; // weak, from nsCycleCollector
+
+public:
+    GCGraphBuilder(GCGraph &aGraph,
+                   nsCycleCollectionLanguageRuntime **aRuntimes)
+      : mNodeBuilder(aGraph.mNodes)
+      , mEdgeBuilder(aGraph.mEdges)
+      , mRuntimes(aRuntimes)
+    {
+        if (!PL_DHashTableInit(&mPtrToNodeMap, &PtrNodeOps, nsnull,
+                               sizeof(PtrToNodeEntry), 32768))
+            mPtrToNodeMap.ops = nsnull;
+    }
+
+    ~GCGraphBuilder()
+    {
+        if (mPtrToNodeMap.ops)
+            PL_DHashTableFinish(&mPtrToNodeMap);
+    }
+
+    PRUint32 Count() const { return mPtrToNodeMap.entryCount; }
+
+    PtrInfo* AddNode(void *s)
+    {
+        PtrToNodeEntry *e = NS_STATIC_CAST(PtrToNodeEntry*, 
+            PL_DHashTableOperate(&mPtrToNodeMap, s, PL_DHASH_ADD));
+        PtrInfo *result;
+        if (!e->mNode) {
+            // New entry.
+            result = mNodeBuilder.Add(s);
+            if (!result) {
+                PL_DHashTableRawRemove(&mPtrToNodeMap, e);
+                return nsnull;
+            }
+            e->mNode = result;
+        } else {
+            result = e->mNode;
+        }
+        return result;
+    }
+
+    void Traverse(PtrInfo* aPtrInfo)
+    {
+        mCurrPi = aPtrInfo;
+
+#ifdef DEBUG_CC
+        if (mCurrPi->mLang > nsIProgrammingLanguage::MAX ) {
+            Fault("unknown language during walk");
+            return;
+        }
+
+        if (!mRuntimes[mCurrPi->mLang]) {
+            Fault("script pointer for unregistered language");
+            return;
+        }
+#endif
+
+        mCurrPi->mFirstChild = mEdgeBuilder.Mark();
+        
+        nsresult rv =
+            mRuntimes[aPtrInfo->mLang]->Traverse(aPtrInfo->mPointer, *this);
+        if (NS_FAILED(rv)) {
+            Fault("script pointer traversal failed", aPtrInfo->mPointer);
+        }
+
+        mCurrPi->mLastChild = mEdgeBuilder.Mark();
+    }
+
+private:
+    // nsCycleCollectionTraversalCallback methods.
+#ifdef DEBUG_CC
+    void DescribeNode(size_t refCount, size_t objSz, const char *objName);
+#else
+    void DescribeNode(size_t refCount);
+#endif
+    void NoteXPCOMChild(nsISupports *child);
+    void NoteScriptChild(PRUint32 langID, void *child);
+};
+
 void 
-GraphWalker::NoteXPCOMChild(nsISupports *child) 
+#ifdef DEBUG_CC
+GCGraphBuilder::DescribeNode(size_t refCount, size_t objSz, const char *objName)
+#else
+GCGraphBuilder::DescribeNode(size_t refCount)
+#endif
+{
+    if (refCount == 0)
+        Fault("zero refcount", mCurrPi->mPointer);
+
+#ifdef DEBUG_CC
+    mCurrPi->mBytes = objSz;
+    mCurrPi->mName = objName;
+#endif
+
+    mCurrPi->mRefCount = refCount;
+#ifdef DEBUG_CC
+    sCollector->mStats.mVisitedNode++;
+    if (mCurrPi->mLang == nsIProgrammingLanguage::JAVASCRIPT)
+        sCollector->mStats.mVisitedJSNode++;
+#endif
+}
+
+void 
+GCGraphBuilder::NoteXPCOMChild(nsISupports *child) 
 {
     if (!child)
         return; 
@@ -872,20 +1169,16 @@ GraphWalker::NoteXPCOMChild(nsISupports 
     scanSafe &= !nsCycleCollector_shouldSuppress(child);
 #endif
     if (scanSafe) {
-        PtrInfo *childPi = mGraph.Add(child);
+        PtrInfo *childPi = AddNode(canonicalize(child));
         if (!childPi)
             return;
-        this->NoteChild(childPi);
-#ifdef DEBUG_CC
-        mRuntimes[nsIProgrammingLanguage::CPLUSPLUS]->Traverse(child, sSafetyCallback);
-#endif
-        mQueue.Push(child);
-    }
-}
-
+        mEdgeBuilder.Add(childPi);
+        ++childPi->mInternalRefs;
+    }
+}
 
 void
-GraphWalker::NoteScriptChild(PRUint32 langID, void *child) 
+GCGraphBuilder::NoteScriptChild(PRUint32 langID, void *child) 
 {
     if (!child)
         return;
@@ -895,91 +1188,14 @@ GraphWalker::NoteScriptChild(PRUint32 la
         return;
     }
 
-    PtrInfo *childPi = mGraph.Add(child);
+    PtrInfo *childPi = AddNode(child);
     if (!childPi)
         return;
+    mEdgeBuilder.Add(childPi);
+    ++childPi->mInternalRefs;
     childPi->mLang = langID;
-    this->NoteChild(childPi);
-#ifdef DEBUG_CC
-    mRuntimes[langID]->Traverse(child, sSafetyCallback);
-#endif
-    mQueue.Push(child);
-}
-
-
-void
-GraphWalker::Walk(void *s0)
-{
-    mQueue.Empty();
-    mQueue.Push(s0);
-
-    while (mQueue.GetSize() > 0) {
-
-        void *ptr = mQueue.Pop();
-        mCurrPi = mGraph.Lookup(ptr);
-
-        if (!mCurrPi) {
-            Fault("unknown pointer", ptr);
-            continue;
-        }
-
-#ifdef DEBUG_CC
-        if (mCurrPi->mLang > nsIProgrammingLanguage::MAX ) {
-            Fault("unknown language during walk");
-            continue;
-        }
-
-        if (!mRuntimes[mCurrPi->mLang]) {
-            Fault("script pointer for unregistered language");
-            continue;
-        }
-#endif
-        
-        if (this->ShouldVisitNode(mCurrPi)) {
-            nsresult rv = mRuntimes[mCurrPi->mLang]->Traverse(ptr, *this);
-            if (NS_FAILED(rv)) {
-                Fault("script pointer traversal failed", ptr);
-            }
-        }
-    }
-
-#ifdef DEBUG_CC
-    sCollector->mStats.mWalkedGraph++;
-#endif
-}
-
-
-////////////////////////////////////////////////////////////////////////
-// Bacon & Rajan's |MarkRoots| routine.
-////////////////////////////////////////////////////////////////////////
-
-
-struct MarkGreyWalker : public GraphWalker
-{
-    MarkGreyWalker(GCTable &tab,
-                   nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes) 
-    {}
-
-    PRBool ShouldVisitNode(PtrInfo const *pi)
-    { 
-        return pi->mColor != grey;
-    }
-
-    void VisitNode(PtrInfo *pi, size_t refcount)
-    { 
-        pi->mColor = grey;
-        pi->mRefCount = refcount;
-#ifdef DEBUG_CC
-        sCollector->mStats.mSetColorGrey++;
-#endif
-    }
-
-    void NoteChild(PtrInfo *childpi)
-    { 
-        childpi->mInternalRefs++;
-    }
-};
+}
+
 
 void 
 nsCycleCollector::CollectPurple()
@@ -988,14 +1204,26 @@ nsCycleCollector::CollectPurple()
 }
 
 void
-nsCycleCollector::MarkRoots()
-{
+nsCycleCollector::MarkRoots(GCGraph &graph)
+{
+    if (mBufs[0].GetSize() == 0)
+        return;
+
+    GCGraphBuilder builder(graph, mRuntimes);
+
     int i;
     for (i = 0; i < mBufs[0].GetSize(); ++i) {
         nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0].ObjectAt(i));
-        s = canonicalize(s);
-        mGraph.Add(s);
-        MarkGreyWalker(mGraph, mRuntimes).Walk(s);
+        PtrInfo *pi = builder.AddNode(canonicalize(s));
+    }
+
+    graph.mRootCount = builder.Count();
+
+    // read the PtrInfo out of the graph that we are building
+    NodePool::Enumerator queue(graph.mNodes);
+    while (!queue.IsDone()) {
+        PtrInfo *pi = queue.GetNext();
+        builder.Traverse(pi);
     }
 }
 
@@ -1007,9 +1235,8 @@ nsCycleCollector::MarkRoots()
 
 struct ScanBlackWalker : public GraphWalker
 {
-    ScanBlackWalker(GCTable &tab,
-                   nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes) 
+    ScanBlackWalker(GCGraph &graph)
+        : GraphWalker(graph) 
     {}
 
     PRBool ShouldVisitNode(PtrInfo const *pi)
@@ -1017,23 +1244,20 @@ struct ScanBlackWalker : public GraphWal
         return pi->mColor != black;
     }
 
-    void VisitNode(PtrInfo *pi, size_t refcount)
+    void VisitNode(PtrInfo *pi)
     { 
         pi->mColor = black;
 #ifdef DEBUG_CC
         sCollector->mStats.mSetColorBlack++;
 #endif
     }
-
-    void NoteChild(PtrInfo *childpi) {}
 };
 
 
 struct scanWalker : public GraphWalker
 {
-    scanWalker(GCTable &tab,
-               nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes) 
+    scanWalker(GCGraph &graph)
+        : GraphWalker(graph) 
     {}
 
     PRBool ShouldVisitNode(PtrInfo const *pi)
@@ -1041,58 +1265,46 @@ struct scanWalker : public GraphWalker
         return pi->mColor == grey;
     }
 
-    void VisitNode(PtrInfo *pi, size_t refcount)
+    void VisitNode(PtrInfo *pi)
     {
         if (pi->mColor != grey)
-            Fault("scanning non-grey node", pi->key);
-
-        if (pi->mInternalRefs > refcount)
-            Fault("traversed refs exceed refcount", pi->key);
-
-        if (pi->mInternalRefs == refcount) {
+            Fault("scanning non-grey node", pi->mPointer);
+
+        if (pi->mInternalRefs > pi->mRefCount)
+            Fault("traversed refs exceed refcount", pi->mPointer);
+
+        if (pi->mInternalRefs == pi->mRefCount) {
             pi->mColor = white;
 #ifdef DEBUG_CC
             sCollector->mStats.mSetColorWhite++;
 #endif
         } else {
-            ScanBlackWalker(mGraph, mRuntimes).Walk(NS_CONST_CAST(void*,
-                                                                  pi->key));
+            ScanBlackWalker(mGraph).Walk(pi);
             NS_ASSERTION(pi->mColor == black,
                          "Why didn't ScanBlackWalker make pi black?");
         }
     }
-    void NoteChild(PtrInfo *childpi) {}
 };
 
-
-#ifdef DEBUG_CC
-PR_STATIC_CALLBACK(PLDHashOperator)
-NoGreyCallback(PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number,
-               void *arg)
-{
-    PtrInfo *pinfo = (PtrInfo *) hdr;
-    if (pinfo->mColor == grey)
-        Fault("valid grey node after scanning", pinfo->key);
-    return PL_DHASH_NEXT;
-}
-#endif
-
-
 void
-nsCycleCollector::ScanRoots()
-{
-    int i;
-
-    for (i = 0; i < mBufs[0].GetSize(); ++i) {
-        nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0].ObjectAt(i));
-        s = canonicalize(s);
-        scanWalker(mGraph, mRuntimes).Walk(s); 
-    }
+nsCycleCollector::ScanRoots(GCGraph &graph)
+{
+    // On the assumption that most nodes will be black, it's
+    // probably faster to use a GraphWalker than a
+    // NodePool::Enumerator.
+    scanWalker(graph).WalkFromRoots(); 
 
 #ifdef DEBUG_CC
     // Sanity check: scan should have colored all grey nodes black or
     // white. So we ensure we have no grey nodes at this point.
-    mGraph.Enumerate(NoGreyCallback, this);
+    NodePool::Enumerator etor(graph.mNodes);
+    while (!etor.IsDone())
+    {
+        PtrInfo *pinfo = etor.GetNext();
+        if (pinfo->mColor == grey) {
+            Fault("valid grey node after scanning", pinfo->mPointer);
+        }
+    }
 #endif
 }
 
@@ -1101,43 +1313,8 @@ nsCycleCollector::ScanRoots()
 // Bacon & Rajan's |CollectWhite| routine, somewhat modified.
 ////////////////////////////////////////////////////////////////////////
 
-
-PR_STATIC_CALLBACK(PLDHashOperator)
-FindWhiteCallback(PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number,
-                  void *arg)
-{
-    nsCycleCollector *collector = NS_STATIC_CAST(nsCycleCollector*, arg);
-    PtrInfo *pinfo = (PtrInfo *) hdr;
-    void *p = NS_CONST_CAST(void*, pinfo->key);
-
-    NS_ASSERTION(pinfo->mLang == nsIProgrammingLanguage::CPLUSPLUS ||
-                 !collector->mPurpleBuf.Exists(p),
-                 "Need to remove non-CPLUSPLUS objects from purple buffer!");
-    if (pinfo->mColor == white) {
-        if (pinfo->mLang > nsIProgrammingLanguage::MAX)
-            Fault("White node has bad language ID", p);
-        else
-            collector->mBufs[pinfo->mLang].Push(p);
-
-        if (pinfo->mLang == nsIProgrammingLanguage::CPLUSPLUS) {
-            nsISupports* s = NS_STATIC_CAST(nsISupports*, p);
-            collector->Forget(s);
-        }
-    }
-    else if (pinfo->mLang == nsIProgrammingLanguage::CPLUSPLUS) {
-        nsISupports* s = NS_STATIC_CAST(nsISupports*, p);
-        nsCycleCollectionParticipant* cp;
-        CallQueryInterface(s, &cp);
-        if (cp)
-            cp->UnmarkPurple(s);
-        collector->Forget(s);
-    }
-    return PL_DHASH_NEXT;
-}
-
-
 void
-nsCycleCollector::CollectWhite()
+nsCycleCollector::CollectWhite(GCGraph &graph)
 {
     // Explanation of "somewhat modified": we have no way to collect the
     // set of whites "all at once", we have to ask each of them to drop
@@ -1164,7 +1341,35 @@ nsCycleCollector::CollectWhite()
     _CrtMemCheckpoint(&ms1);
 #endif
 
-    mGraph.Enumerate(FindWhiteCallback, this);
+    NodePool::Enumerator etor(graph.mNodes);
+    while (!etor.IsDone())
+    {
+        PtrInfo *pinfo = etor.GetNext();
+        void *p = pinfo->mPointer;
+
+        NS_ASSERTION(pinfo->mLang == nsIProgrammingLanguage::CPLUSPLUS ||
+                     !mPurpleBuf.Exists(p),
+                     "Need to remove non-CPLUSPLUS objects from purple buffer!");
+        if (pinfo->mColor == white) {
+            if (pinfo->mLang > nsIProgrammingLanguage::MAX)
+                Fault("White node has bad language ID", p);
+            else
+                mBufs[pinfo->mLang].Push(p);
+
+            if (pinfo->mLang == nsIProgrammingLanguage::CPLUSPLUS) {
+                nsISupports* s = NS_STATIC_CAST(nsISupports*, p);
+                Forget(s);
+            }
+        }
+        else if (pinfo->mLang == nsIProgrammingLanguage::CPLUSPLUS) {
+            nsISupports* s = NS_STATIC_CAST(nsISupports*, p);
+            nsCycleCollectionParticipant* cp;
+            CallQueryInterface(s, &cp);
+            if (cp)
+                cp->UnmarkPurple(s);
+            Forget(s);
+        }
+    }
 
     for (i = 0; i < nsIProgrammingLanguage::MAX+1; ++i) {
         if (mRuntimes[i] &&
@@ -1214,86 +1419,6 @@ nsCycleCollector::CollectWhite()
 
 #ifdef DEBUG_CC
 ////////////////////////////////////////////////////////////////////////
-// Extra book-keeping functions.
-////////////////////////////////////////////////////////////////////////
-
-struct graphVizWalker : public GraphWalker
-{
-    // We can't just use _popen here because graphviz-for-windows
-    // doesn't set up its stdin stream properly, sigh.
-    PointerSet mVisited;
-    const void *mParent;
-    FILE *mStream;
-
-    graphVizWalker(GCTable &tab,
-                   nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes), 
-          mParent(nsnull), 
-          mStream(nsnull)        
-    {
-#ifdef WIN32
-        mStream = fopen("c:\\cycle-graph.dot", "w+");
-#else
-        mStream = popen("dotty -", "w");
-#endif
-        mVisited.Init();
-        fprintf(mStream, 
-                "digraph collection {\n"
-                "rankdir=LR\n"
-                "node [fontname=fixed, fontsize=10, style=filled, shape=box]\n"
-                );
-    }
-
-    ~graphVizWalker()
-    {
-        fprintf(mStream, "\n}\n");
-#ifdef WIN32
-        fclose(mStream);
-        // Even dotty doesn't work terribly well on windows, since
-        // they execute lefty asynchronously. So we'll just run 
-        // lefty ourselves.
-        _spawnlp(_P_WAIT, 
-                 "lefty", 
-                 "lefty",
-                 "-e",
-                 "\"load('dotty.lefty');"
-                 "dotty.simple('c:\\cycle-graph.dot');\"",
-                 NULL);
-        unlink("c:\\cycle-graph.dot");
-#else
-        pclose(mStream);
-#endif
-    }
-
-    PRBool ShouldVisitNode(PtrInfo const *pi)
-    { 
-        return ! mVisited.GetEntry(pi->key);
-    }
-
-    void VisitNode(PtrInfo *pi, size_t refcount)
-    {
-        const void *p = pi->key;
-        mVisited.PutEntry(p);
-        mParent = p;
-        fprintf(mStream, 
-                "n%p [label=\"%s\\n%p\\n%u/%u refs found\", "
-                "fillcolor=%s, fontcolor=%s]\n", 
-                p,
-                pi->mName,
-                p,
-                pi->mInternalRefs, pi->mRefCount,
-                (pi->mColor == black ? "black" : "white"),
-                (pi->mColor == black ? "white" : "black"));
-    }
-
-    void NoteChild(PtrInfo *childpi)
-    { 
-        fprintf(mStream, "n%p -> n%p\n", mParent, childpi->key);
-    }
-};
-
-
-////////////////////////////////////////////////////////////////////////
 // Memory-hooking stuff
 // When debugging wild pointers, it sometimes helps to hook malloc and
 // free. This stuff is disabled unless you set an environment variable.
@@ -1511,8 +1636,6 @@ nsCycleCollector::nsCycleCollector() :
 
 nsCycleCollector::~nsCycleCollector()
 {
-    mGraph.Clear();    
-
     for (PRUint32 i = 0; i < nsIProgrammingLanguage::MAX+1; ++i) {
         mRuntimes[i] = NULL;
     }
@@ -1553,34 +1676,74 @@ nsCycleCollector::ForgetRuntime(PRUint32
 
 
 #ifdef DEBUG_CC
-static PR_CALLBACK PLDHashOperator
-FindAnyWhiteCallback(PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number,
-                     void *arg)
-{
-    PtrInfo *pinfo = (PtrInfo *) hdr;
-    if (pinfo->mColor == white) {
-        *NS_STATIC_CAST(PRBool*, arg) = PR_TRUE;
-        return PL_DHASH_STOP;
-    }
-    return PL_DHASH_NEXT;
-}
-
-
 void 
-nsCycleCollector::MaybeDrawGraphs()
+nsCycleCollector::MaybeDrawGraphs(GCGraph &graph)
 {
     if (mParams.mDrawGraphs) {
         // We draw graphs only if there were any white nodes.
         PRBool anyWhites = PR_FALSE;
-        mGraph.Enumerate(FindAnyWhiteCallback, &anyWhites);
+        NodePool::Enumerator fwetor(graph.mNodes);
+        while (!fwetor.IsDone())
+        {
+            PtrInfo *pinfo = fwetor.GetNext();
+            if (pinfo->mColor == white) {
+                anyWhites = PR_TRUE;
+                break;
+            }
+        }
 
         if (anyWhites) {
-            graphVizWalker gw(mGraph, mRuntimes);
-            while (mBufs[0].GetSize() > 0) {
-                nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0].Pop());
-                s = canonicalize(s);
-                gw.Walk(s);
+            // We can't just use _popen here because graphviz-for-windows
+            // doesn't set up its stdin stream properly, sigh.
+            FILE *stream;
+#ifdef WIN32
+            stream = fopen("c:\\cycle-graph.dot", "w+");
+#else
+            stream = popen("dotty -", "w");
+#endif
+            fprintf(stream, 
+                    "digraph collection {\n"
+                    "rankdir=LR\n"
+                    "node [fontname=fixed, fontsize=10, style=filled, shape=box]\n"
+                    );
+
+            NodePool::Enumerator etor(graph.mNodes);
+            while (!etor.IsDone()) {
+                PtrInfo *pi = etor.GetNext();
+                const void *p = pi->mPointer;
+                fprintf(stream, 
+                        "n%p [label=\"%s\\n%p\\n%u/%u refs found\", "
+                        "fillcolor=%s, fontcolor=%s]\n", 
+                        p,
+                        pi->mName,
+                        p,
+                        pi->mInternalRefs, pi->mRefCount,
+                        (pi->mColor == black ? "black" : "white"),
+                        (pi->mColor == black ? "white" : "black"));
+                for (EdgePool::Iterator child = pi->mFirstChild,
+                                    child_end = pi->mLastChild;
+                     child != child_end; ++child) {
+                    fprintf(stream, "n%p -> n%p\n", p, (*child)->mPointer);
+                }
             }
+
+            fprintf(stream, "\n}\n");
+#ifdef WIN32
+            fclose(stream);
+            // Even dotty doesn't work terribly well on windows, since
+            // they execute lefty asynchronously. So we'll just run 
+            // lefty ourselves.
+            _spawnlp(_P_WAIT, 
+                     "lefty", 
+                     "lefty",
+                     "-e",
+                     "\"load('dotty.lefty');"
+                     "dotty.simple('c:\\cycle-graph.dot');\"",
+                     NULL);
+            unlink("c:\\cycle-graph.dot");
+#else
+            pclose(stream);
+#endif
         }
     }
 }
@@ -1804,14 +1967,14 @@ nsCycleCollector::Collect(PRUint32 aTryC
 
                 mScanInProgress = PR_TRUE;
 
-                mGraph.Clear();
+                GCGraph graph;
 
                 // The main Bacon & Rajan collection algorithm.
 
 #ifdef COLLECT_TIME_DEBUG
                 now = PR_Now();
 #endif
-                MarkRoots();
+                MarkRoots(graph);
 
 #ifdef COLLECT_TIME_DEBUG
                 {
@@ -1822,7 +1985,7 @@ nsCycleCollector::Collect(PRUint32 aTryC
                 }
 #endif
 
-                ScanRoots();
+                ScanRoots(graph);
 
 #ifdef COLLECT_TIME_DEBUG
                 printf("cc: ScanRoots() took %lldms\n",
@@ -1830,7 +1993,7 @@ nsCycleCollector::Collect(PRUint32 aTryC
 #endif
 
 #ifdef DEBUG_CC
-                MaybeDrawGraphs();
+                MaybeDrawGraphs(graph);
 #endif
 
                 mScanInProgress = PR_FALSE;
@@ -1839,7 +2002,7 @@ nsCycleCollector::Collect(PRUint32 aTryC
 #ifdef COLLECT_TIME_DEBUG
                 now = PR_Now();
 #endif
-                CollectWhite();
+                CollectWhite(graph);
 
 #ifdef COLLECT_TIME_DEBUG
                 printf("cc: CollectWhite() took %lldms\n",
@@ -1847,8 +2010,6 @@ nsCycleCollector::Collect(PRUint32 aTryC
 #endif
 
                 // Some additional book-keeping.
-
-                mGraph.Clear();
 
                 --aTryCollections;
             }
@@ -1909,45 +2070,6 @@ AddExpectedGarbage(nsVoidPtrHashKey *p, 
     return PL_DHASH_NEXT;
 }
 
-struct explainWalker : public GraphWalker
-{
-    explainWalker(GCTable &tab,
-                  nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes) 
-    {}
-
-    PRBool ShouldVisitNode(PtrInfo const *pi)
-    { 
-        // We set them back to gray as we explain problems.
-        return pi->mColor != grey;
-    }
-
-    void VisitNode(PtrInfo *pi, size_t refcount)
-    {
-        if (pi->mColor == grey)
-            Fault("scanning grey node", pi->key);
-
-        if (pi->mColor == white) {
-            printf("nsCycleCollector: %s %p was not collected due to\n"
-                   "  missing call to suspect or failure to unlink\n",
-                   pi->mName, pi->key);
-        }
-
-        if (pi->mInternalRefs != refcount) {
-            // Note that the external references may have been external
-            // to a different node in the cycle collection that just
-            // happened, if that different node was purple and then
-            // black.
-            printf("nsCycleCollector: %s %p was not collected due to %d\n"
-                   "  external references\n",
-                   pi->mName, pi->key, refcount - pi->mInternalRefs);
-        }
-
-        pi->mColor = grey;
-    }
-    void NoteChild(PtrInfo *childpi) {}
-};
-
 void
 nsCycleCollector::ExplainLiveExpectedGarbage()
 {
@@ -1968,25 +2090,40 @@ nsCycleCollector::ExplainLiveExpectedGar
     mCollectionInProgress = PR_TRUE;
     mScanInProgress = PR_TRUE;
 
-    mGraph.Clear();
-    mBufs[0].Empty();
-
-    // Instead of filling mBufs[0] from the purple buffer, we fill it
-    // from the list of nodes we were expected to collect.
-    mExpectedGarbage.EnumerateEntries(&AddExpectedGarbage, this);
-
-    MarkRoots();
-    ScanRoots();
-
-    mScanInProgress = PR_FALSE;
-
-    for (int i = 0; i < mBufs[0].GetSize(); ++i) {
-        nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0].ObjectAt(i));
-        s = canonicalize(s);
-        explainWalker(mGraph, mRuntimes).Walk(s); 
-    }
-
-    mGraph.Clear();
+    {
+        GCGraph graph;
+        mBufs[0].Empty();
+
+        // Instead of filling mBufs[0] from the purple buffer, we fill it
+        // from the list of nodes we were expected to collect.
+        mExpectedGarbage.EnumerateEntries(&AddExpectedGarbage, this);
+
+        MarkRoots(graph);
+        ScanRoots(graph);
+
+        mScanInProgress = PR_FALSE;
+
+        NodePool::Enumerator queue(graph.mNodes);
+        while (!queue.IsDone()) {
+            PtrInfo *pi = queue.GetNext();
+            if (pi->mColor == white) {
+                printf("nsCycleCollector: %s %p was not collected due to\n"
+                       "  missing call to suspect or failure to unlink\n",
+                       pi->mName, pi->mPointer);
+            }
+
+            if (pi->mInternalRefs != pi->mRefCount) {
+                // Note that the external references may have been external
+                // to a different node in the cycle collection that just
+                // happened, if that different node was purple and then
+                // black.
+                printf("nsCycleCollector: %s %p was not collected due to %d\n"
+                       "  external references\n",
+                       pi->mName, pi->mPointer,
+                       pi->mRefCount - pi->mInternalRefs);
+            }
+        }
+    }
 
     mCollectionInProgress = PR_FALSE;
 
