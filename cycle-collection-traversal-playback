Record results of cycle collection traversal so we only have to call the traversal APIs once per collection.  b=378514

diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -1,4 +1,5 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim: set cindent tabstop=4 expandtab shiftwidth=4: */
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
@@ -287,6 +288,112 @@ nsCycleCollector_shouldSuppress(nsISuppo
 // Base types
 ////////////////////////////////////////////////////////////////////////
 
+struct PtrInfo;
+
+class EdgeIterator
+{
+public:
+    EdgeIterator() : mPointer(nsnull) {}
+    EdgeIterator(void **aPointer) : mPointer(aPointer) {}
+    EdgeIterator(const EdgeIterator& aOther) : mPointer(aOther.mPointer) {}
+
+    EdgeIterator& operator++(int)
+    {
+        if (*mPointer == nsnull) {
+            // Null pointer is a sentinel for link to the next block.
+            mPointer = *(++mPointer);
+        }
+        return *this;
+    }
+
+    PtrInfo* operator*() const
+        { return NS_STATIC_CAST(PtrInfo*, *mPointer); }
+    PRBool operator==(const EdgeIterator& aOther) const
+        { return mPointer == aOther.mPointer; }
+    PRBool operator!=(const EdgeIterator& aOther) const
+        { return mPointer != aOther.mPointer; }
+
+private:
+    void **mPointer;
+};
+
+class EdgePool
+{
+    // EdgePool allocates arrays of void*, primarily to hold PtrInfo*.
+    // However, at the end of a block, the last two pointers are a null
+    // and then a void** pointing to the next block.  This allows
+    // EdgeIterators to be a single word but still capable of crossing
+    // block boundaries.
+
+    EdgePool()
+      : mBlocks(nsnull)
+    {
+    }
+
+    ~EdgePool()
+    {
+        Block *b = mBlocks;
+        while (b) {
+            Block *next = b->Next();
+            delete b;
+            b = next;
+        }
+    }
+
+    class Builder;
+    friend class Builder;
+    class Builder {
+    public:
+        Builder(EdgePool &aPool)
+          : mCurrent(nsnull)
+          , mBlockEnd(nsnull)
+          , mNextBlock(&aPool.mBlocks)
+        {
+        }
+
+        EdgeIterator Mark() { return EdgeIterator(mCurrent); }
+
+        void Add(PtrInfo* aEdge) {
+            if (mCurrent == mBlockEnd) {
+                Block *b = new Block();
+                if (!b) {
+                    // This means we just won't free things.
+                    NS_NOTREACHED("out of memory, ignoring edges");
+                    return;
+                }
+                *mNextBlockPtr = b;
+                mCurrent = b->Start();
+                mBlockEnd = b->End();
+                mNextBlockPtr = &b->Next();
+            }
+            *(mCurrent++) = aEdge;
+        }
+    private:
+        PtrInfo **mCurrent;
+        PtrInfo **mBlockEnd; // mBlockEnd points to space for null sentinel
+        Block **mNextBlockPtr;
+    };
+
+private:
+    Block *mBlocks;
+    enum { BlockSize = 65536 };
+
+    struct Block {
+        void* mPointers[BlockSize];
+        Block() {
+            mPointers[mBlockSize - 2] = nsnull; // sentinel
+            mPointers[mBlockSize - 1] = nsnull; // next block pointer
+        }
+        Block*& Next()
+            { return NS_STATIC_CAST(Block*&, mPointers[mBlockSize - 1]); }
+        PtrInfo** Start()
+            { return NS_STATIC_CAST(PtrInfo**, mPointers); }
+        PtrInfo** End()
+            { return NS_STATIC_CAST(PtrInfo**, mPointers + mBlockSize - 2); }
+    };
+};
+
+
 enum NodeColor { black, white, grey };
 
 // This structure should be kept as small as possible; we may expect
@@ -294,102 +401,148 @@ enum NodeColor { black, white, grey };
 // each cycle collection.
 
 struct PtrInfo
-    : public PLDHashEntryStub
-{
+{
+    void *mPointer;
     PRUint32 mColor : 2;
     PRUint32 mInternalRefs : 30;
     // FIXME: mLang expands back to a full word when bug 368774 lands.
     PRUint32 mLang : 2;
     PRUint32 mRefCount : 30;
+    EdgeIterator mFirstChild; // first
+    EdgeIterator mLastChild; // one after last
 
 #ifdef DEBUG_CC
     size_t mBytes;
     const char *mName;
 #endif
+
+    PtrInfo(void *aPointer)
+      : mPointer(aPointer)
+      , mColor(grey)
+      , mInternalRefs(0)
+      , mLang(nsIProgrammingLanguage::CPLUSPLUS)
+      , mRefCount(0)
+      , mFirstChild(nsnull)
+      , mLastChild(nsnull)
+#ifdef DEBUG_CC
+      , mBytes(0)
+      , mName(nsnull)
+#endif
+    {
+    }
 };
 
-PR_STATIC_CALLBACK(PRBool)
-InitPtrInfo(PLDHashTable *table, PLDHashEntryHdr *entry, const void *key)
-{
-    PtrInfo* pi = (PtrInfo*)entry;
-    pi->key = key;
-    pi->mColor = black;
-    pi->mInternalRefs = 0;
-    pi->mLang = nsIProgrammingLanguage::CPLUSPLUS;
-    pi->mRefCount = 0;
-#ifdef DEBUG_CC
-    pi->mBytes = 0;
-    pi->mName = nsnull;
-#endif
-    return PR_TRUE;
-}
-
-static PLDHashTableOps GCTableOps = {
-    PL_DHashAllocTable,
-    PL_DHashFreeTable,
-    PL_DHashVoidPtrKeyStub,
-    PL_DHashMatchEntryStub,
-    PL_DHashMoveEntryStub,
-    PL_DHashClearEntryStub,
-    PL_DHashFinalizeStub,
-    InitPtrInfo
- };
-
-struct GCTable
-{
-    PLDHashTable mTab;
-
-    GCTable()
-    {
-        Init();
-    }
-    ~GCTable()
-    {
-        if (mTab.ops)
-            PL_DHashTableFinish(&mTab);
-    }
-
-    void Init()
-    {
-        if (!PL_DHashTableInit(&mTab, &GCTableOps, nsnull, sizeof(PtrInfo),
-                               32768))
-            mTab.ops = nsnull;
-    }
-    void Clear()
-    {
-        if (!mTab.ops || mTab.entryCount > 0) {
-            if (mTab.ops)
-                PL_DHashTableFinish(&mTab);
-            Init();
-        }
-    }
-
-    PtrInfo *Lookup(void *key)
-    {
-        if (!mTab.ops)
-            return nsnull;
-
-        PLDHashEntryHdr *entry =
-            PL_DHashTableOperate(&mTab, key, PL_DHASH_LOOKUP);
-
-        return PL_DHASH_ENTRY_IS_BUSY(entry) ? (PtrInfo*)entry : nsnull;
-    }
-
-    PtrInfo *Add(void *key)
-    {
-        if (!mTab.ops)
-            return nsnull;
-
-        return (PtrInfo*)PL_DHashTableOperate(&mTab, key, PL_DHASH_ADD);
-    }
-    
-    void Enumerate(PLDHashEnumerator etor, void *arg)
-    {
-        if (mTab.ops)
-            PL_DHashTableEnumerate(&mTab, etor, arg);
-    }
+// A structure designed to be used like a linked list, but allocated
+// many items at a time.
+
+class NodePool
+{
+private:
+    enum { BlockSize = 32768 }; // could be int template parameter
+    typedef PtrInfo EntryType;
+
+    struct Block {
+        Block* mNext;
+        EntryType mEntries[BlockSize];
+    };
+
+public:
+    NodePool()
+      : mBlocks(nsnull)
+      , mLast(nsnull)
+    {
+    }
+
+    ~NodePool()
+    {
+        Block *b = mBlocks;
+        while (b) {
+            Block *n = mBlocks->mNext;
+            delete b;
+            b = n;
+        }
+    }
+
+    class Builder;
+    friend class Builder;
+    class Builder {
+    public:
+        Builder(NodePool& aPool)
+          : mNextBlock(&aPool.mBlocks)
+          , mNext(aPool.mLast)
+          , mBlockEnd(nsnull)
+        {
+            NS_ASSERTION(aPool.mBlocks == nsnull && aPool.mLast == nsnull,
+                         "pool not empty");
+        }
+        EntryType *Add()
+        {
+            if (mNext == mBlockEnd) {
+                Block *block;
+                if (!(*mNextBlock = block = new Block))
+                    return nsnull;
+                mCurrent = block->mEntries;
+                mBlockEnd = block->mEntries + BlockSize;
+                mNextBlock = &block->mNext;
+            }
+            return mNext++;
+        }
+    private:
+        Block **mNextBlock;
+        EntryType *&mNext;
+        EntryType *mBlockEnd;
+    };
+
+    class Enumerator;
+    friend class Enumerator;
+    class Enumerator {
+    public:
+        Enumerator(NodePool& aPool)
+          : mNextBlock(&aPool.mBlocks)
+          , mNext(nsnull)
+          , mBlockEnd(nsnull)
+          , mLast(aPool.mLast)
+        {
+        }
+
+        PRBool IsDone() const
+        {
+            return mNext == mLast;
+        }
+
+        void Advance(PRUint32 aCount)
+        {
+            while (mNext + aCount >= mBlockEnd) {
+                aCount -= (mBlockEnd - mNext);
+                Block *nextBlock = *mNextBlock;
+                mNext = nextBlock->mEntries;
+                mBlockEnd = mNext + BlockSize;
+                mNextBlock = &nextBlock->mNext;
+            }
+            mNext += aCount;
+        }
+
+        EntryType& GetNext()
+        {
+            NS_ASSERTION(!IsDone(), "calling GetNext when done");
+            if (mNext == mBlockEnd) {
+                Block *nextBlock = *mNextBlock;
+                mNext = nextBlock->mEntries;
+                mBlockEnd = mNext + BlockSize;
+                mNextBlock = &nextBlock->mNext;
+            }
+            return *(mNext++);
+        }
+    private:
+        Block *mNextBlock;
+        // mNext is the next value we want to return, unless mNext == mBlockEnd
+        EntryType *mNext, *mBlockEnd, *&mLast;
+    };
+
+private:
+    Block *mBlocks;
+    EntryType *mLast;
 };
-
 
 // XXX Would be nice to have an nsHashSet<KeyType> API that has
 // Add/Remove/Has rather than PutEntry/RemoveEntry/GetEntry.
@@ -661,13 +814,17 @@ struct nsCycleCollectionXPCOMRuntime :
     }
 };
 
+struct GCGraph
+{
+    ListPool<PtrInfo> mNodes;
+    ListPool<PtrInfo*> mEdges;
+};
 
 struct nsCycleCollector
 {
     PRBool mCollectionInProgress;
     PRBool mScanInProgress;
 
-    GCTable mGraph;
     nsCycleCollectionLanguageRuntime *mRuntimes[nsIProgrammingLanguage::MAX+1];
     nsCycleCollectionXPCOMRuntime mXPCOMRuntime;
 
@@ -689,9 +846,9 @@ struct nsCycleCollector
     void ForgetRuntime(PRUint32 langID);
 
     void CollectPurple(); // XXXldb Should this be called SelectPurple?
-    void MarkRoots();
-    void ScanRoots();
-    void CollectWhite();
+    void MarkRoots(GCGraph &graph);
+    void ScanRoots(GCGraph &graph);
+    void CollectWhite(GCGraph &graph);
 
     nsCycleCollector();
     ~nsCycleCollector();
@@ -708,7 +865,7 @@ struct nsCycleCollector
 
     FILE *mPtrLog;
 
-    void MaybeDrawGraphs();
+    void MaybeDrawGraphs(GCGraph &graph);
     void ExplainLiveExpectedGarbage();
     void ShouldBeFreed(nsISupports *n);
     void WasFreed(nsISupports *n);
@@ -725,15 +882,15 @@ private:
     PtrInfo *mCurrPi;
 
 protected:
-    GCTable &mGraph;
+    GCGraph &mGraph;
     nsCycleCollectionLanguageRuntime **mRuntimes;
 
 public:
-    GraphWalker(GCTable & tab,
+    GraphWalker(GCGraph &graph,
                 nsCycleCollectionLanguageRuntime **runtimes) : 
         mQueue(nsnull),
         mCurrPi(nsnull),
-        mGraph(tab),
+        mGraph(graph),
         mRuntimes(runtimes)
     {}
 
@@ -916,6 +1073,7 @@ GraphWalker::Walk(void *s0)
     while (mQueue.GetSize() > 0) {
 
         void *ptr = mQueue.Pop();
+        // XXX MAKE QUEUE OF PtrInfo
         mCurrPi = mGraph.Lookup(ptr);
 
         if (!mCurrPi) {
@@ -953,12 +1111,16 @@ GraphWalker::Walk(void *s0)
 // Bacon & Rajan's |MarkRoots| routine.
 ////////////////////////////////////////////////////////////////////////
 
-
+struct GCGraphBuilder
+{
+};
+
+// SHOULD GO AWAY
 struct MarkGreyWalker : public GraphWalker
 {
-    MarkGreyWalker(GCTable &tab,
+    MarkGreyWalker(GCGraph &graph,
                    nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes) 
+        : GraphWalker(graph, runtimes) 
     {}
 
     PRBool ShouldVisitNode(PtrInfo const *pi)
@@ -988,14 +1150,14 @@ nsCycleCollector::CollectPurple()
 }
 
 void
-nsCycleCollector::MarkRoots()
+nsCycleCollector::MarkRoots(GCGraph &graph)
 {
     int i;
     for (i = 0; i < mBufs[0].GetSize(); ++i) {
         nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0].ObjectAt(i));
         s = canonicalize(s);
-        mGraph.Add(s);
-        MarkGreyWalker(mGraph, mRuntimes).Walk(s);
+        graph.Add(s);
+        MarkGreyWalker(graph, mRuntimes).Walk(s);
     }
 }
 
@@ -1007,9 +1169,9 @@ nsCycleCollector::MarkRoots()
 
 struct ScanBlackWalker : public GraphWalker
 {
-    ScanBlackWalker(GCTable &tab,
-                   nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes) 
+    ScanBlackWalker(GCGraph &graph,
+                    nsCycleCollectionLanguageRuntime **runtimes)
+        : GraphWalker(graph, runtimes) 
     {}
 
     PRBool ShouldVisitNode(PtrInfo const *pi)
@@ -1031,9 +1193,9 @@ struct ScanBlackWalker : public GraphWal
 
 struct scanWalker : public GraphWalker
 {
-    scanWalker(GCTable &tab,
+    scanWalker(GCGraph &graph,
                nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes) 
+        : GraphWalker(graph, runtimes) 
     {}
 
     PRBool ShouldVisitNode(PtrInfo const *pi)
@@ -1079,20 +1241,20 @@ NoGreyCallback(PLDHashTable *table, PLDH
 
 
 void
-nsCycleCollector::ScanRoots()
+nsCycleCollector::ScanRoots(GCGraph &graph)
 {
     int i;
 
     for (i = 0; i < mBufs[0].GetSize(); ++i) {
         nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0].ObjectAt(i));
         s = canonicalize(s);
-        scanWalker(mGraph, mRuntimes).Walk(s); 
+        scanWalker(graph, mRuntimes).Walk(s); 
     }
 
 #ifdef DEBUG_CC
     // Sanity check: scan should have colored all grey nodes black or
     // white. So we ensure we have no grey nodes at this point.
-    mGraph.Enumerate(NoGreyCallback, this);
+    graph.Enumerate(NoGreyCallback, this);
 #endif
 }
 
@@ -1137,7 +1299,7 @@ FindWhiteCallback(PLDHashTable *table, P
 
 
 void
-nsCycleCollector::CollectWhite()
+nsCycleCollector::CollectWhite(GCGraph &graph)
 {
     // Explanation of "somewhat modified": we have no way to collect the
     // set of whites "all at once", we have to ask each of them to drop
@@ -1164,7 +1326,7 @@ nsCycleCollector::CollectWhite()
     _CrtMemCheckpoint(&ms1);
 #endif
 
-    mGraph.Enumerate(FindWhiteCallback, this);
+    graph.Enumerate(FindWhiteCallback, this);
 
     for (i = 0; i < nsIProgrammingLanguage::MAX+1; ++i) {
         if (mRuntimes[i] &&
@@ -1225,9 +1387,9 @@ struct graphVizWalker : public GraphWalk
     const void *mParent;
     FILE *mStream;
 
-    graphVizWalker(GCTable &tab,
+    graphVizWalker(GCGraph &graph,
                    nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes), 
+        : GraphWalker(graph, runtimes), 
           mParent(nsnull), 
           mStream(nsnull)        
     {
@@ -1511,8 +1673,6 @@ nsCycleCollector::nsCycleCollector() :
 
 nsCycleCollector::~nsCycleCollector()
 {
-    mGraph.Clear();    
-
     for (PRUint32 i = 0; i < nsIProgrammingLanguage::MAX+1; ++i) {
         mRuntimes[i] = NULL;
     }
@@ -1567,15 +1727,15 @@ FindAnyWhiteCallback(PLDHashTable *table
 
 
 void 
-nsCycleCollector::MaybeDrawGraphs()
+nsCycleCollector::MaybeDrawGraphs(GCGraph &graph)
 {
     if (mParams.mDrawGraphs) {
         // We draw graphs only if there were any white nodes.
         PRBool anyWhites = PR_FALSE;
-        mGraph.Enumerate(FindAnyWhiteCallback, &anyWhites);
+        graph.Enumerate(FindAnyWhiteCallback, &anyWhites);
 
         if (anyWhites) {
-            graphVizWalker gw(mGraph, mRuntimes);
+            graphVizWalker gw(graph, mRuntimes);
             while (mBufs[0].GetSize() > 0) {
                 nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0].Pop());
                 s = canonicalize(s);
@@ -1804,14 +1964,14 @@ nsCycleCollector::Collect(PRUint32 aTryC
 
                 mScanInProgress = PR_TRUE;
 
-                mGraph.Clear();
+                GCGraph graph;
 
                 // The main Bacon & Rajan collection algorithm.
 
 #ifdef COLLECT_TIME_DEBUG
                 now = PR_Now();
 #endif
-                MarkRoots();
+                MarkRoots(graph);
 
 #ifdef COLLECT_TIME_DEBUG
                 {
@@ -1822,7 +1982,7 @@ nsCycleCollector::Collect(PRUint32 aTryC
                 }
 #endif
 
-                ScanRoots();
+                ScanRoots(graph);
 
 #ifdef COLLECT_TIME_DEBUG
                 printf("cc: ScanRoots() took %lldms\n",
@@ -1830,7 +1990,7 @@ nsCycleCollector::Collect(PRUint32 aTryC
 #endif
 
 #ifdef DEBUG_CC
-                MaybeDrawGraphs();
+                MaybeDrawGraphs(graph);
 #endif
 
                 mScanInProgress = PR_FALSE;
@@ -1839,7 +1999,7 @@ nsCycleCollector::Collect(PRUint32 aTryC
 #ifdef COLLECT_TIME_DEBUG
                 now = PR_Now();
 #endif
-                CollectWhite();
+                CollectWhite(graph);
 
 #ifdef COLLECT_TIME_DEBUG
                 printf("cc: CollectWhite() took %lldms\n",
@@ -1847,8 +2007,6 @@ nsCycleCollector::Collect(PRUint32 aTryC
 #endif
 
                 // Some additional book-keeping.
-
-                mGraph.Clear();
 
                 --aTryCollections;
             }
@@ -1911,9 +2069,9 @@ AddExpectedGarbage(nsVoidPtrHashKey *p, 
 
 struct explainWalker : public GraphWalker
 {
-    explainWalker(GCTable &tab,
+    explainWalker(GCGraph &graph,
                   nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes) 
+        : GraphWalker(graph, runtimes) 
     {}
 
     PRBool ShouldVisitNode(PtrInfo const *pi)
@@ -1968,25 +2126,26 @@ nsCycleCollector::ExplainLiveExpectedGar
     mCollectionInProgress = PR_TRUE;
     mScanInProgress = PR_TRUE;
 
-    mGraph.Clear();
-    mBufs[0].Empty();
-
-    // Instead of filling mBufs[0] from the purple buffer, we fill it
-    // from the list of nodes we were expected to collect.
-    mExpectedGarbage.EnumerateEntries(&AddExpectedGarbage, this);
-
-    MarkRoots();
-    ScanRoots();
-
-    mScanInProgress = PR_FALSE;
-
-    for (int i = 0; i < mBufs[0].GetSize(); ++i) {
-        nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0].ObjectAt(i));
-        s = canonicalize(s);
-        explainWalker(mGraph, mRuntimes).Walk(s); 
-    }
-
-    mGraph.Clear();
+    {
+        GCGraph graph;
+        mBufs[0].Empty();
+
+        // Instead of filling mBufs[0] from the purple buffer, we fill it
+        // from the list of nodes we were expected to collect.
+        mExpectedGarbage.EnumerateEntries(&AddExpectedGarbage, this);
+
+        MarkRoots(graph);
+        ScanRoots(graph);
+
+        mScanInProgress = PR_FALSE;
+
+        for (int i = 0; i < mBufs[0].GetSize(); ++i) {
+            nsISupports *s =
+                NS_STATIC_CAST(nsISupports *, mBufs[0].ObjectAt(i));
+            s = canonicalize(s);
+            explainWalker(graph, mRuntimes).Walk(s); 
+        }
+    }
 
     mCollectionInProgress = PR_FALSE;
 
