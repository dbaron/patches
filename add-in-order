From: L. David Baron <dbaron@dbaron.org>

Bug 847287 patch 13 - Add animations/transitions to layer in order that reflects overriding.

This independently would have fixed some of the problems fixed in this
bug, but not fully, since we always fill animations on layers forwards
in the expectation of another update (to avoid jumping and then jumping
back).

FIXME: This shouldn't be fixing tests.

diff --git a/gfx/layers/Layers.h b/gfx/layers/Layers.h
--- a/gfx/layers/Layers.h
+++ b/gfx/layers/Layers.h
@@ -1103,16 +1103,17 @@ public:
       MOZ_LAYERS_LOG_IF_SHADOWABLE(this, ("Layer::Mutated(%p) IsFixedPosition", this));
       mIsFixedPosition = aFixedPosition;
       Mutated();
     }
   }
 
   // Call AddAnimation to add a new animation to this layer from layout code.
   // Caller must fill in all the properties of the returned animation.
+  // A later animation overrides an earlier one.
   Animation* AddAnimation();
   // ClearAnimations clears animations on this layer.
   void ClearAnimations();
   // This is only called when the layer tree is updated. Do not call this from
   // layout code.  To add an animation to this layer, use AddAnimation.
   void SetAnimations(const AnimationArray& aAnimations);
   // Go through all animations in this layer and its children and, for
   // any animations with a null start time, update their start time such
diff --git a/gfx/layers/composite/AsyncCompositionManager.cpp b/gfx/layers/composite/AsyncCompositionManager.cpp
--- a/gfx/layers/composite/AsyncCompositionManager.cpp
+++ b/gfx/layers/composite/AsyncCompositionManager.cpp
@@ -435,17 +435,18 @@ SampleValue(float aPortion, Animation& a
 static bool
 SampleAnimations(Layer* aLayer, TimeStamp aPoint)
 {
   AnimationArray& animations = aLayer->GetAnimations();
   InfallibleTArray<AnimData>& animationData = aLayer->GetAnimationData();
 
   bool activeAnimations = false;
 
-  for (uint32_t i = animations.Length(); i-- !=0; ) {
+  // Process in reverse, since later animations override earlier ones.
+  for (size_t i = 0, iEnd = animations.Length(); i < iEnd; ++i) {
     Animation& animation = animations[i];
     AnimData& animData = animationData[i];
 
     activeAnimations = true;
 
     MOZ_ASSERT(!animation.startTime().IsNull(),
                "Failed to resolve start time of pending animations");
     TimeDuration elapsedDuration = aPoint - animation.startTime();
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -408,16 +408,17 @@ AddAnimationsForProperty(nsIFrame* aFram
                          AnimationPlayerPtrArray& aPlayers,
                          Layer* aLayer, AnimationData& aData,
                          bool aPending)
 {
   MOZ_ASSERT(nsCSSProps::PropHasFlags(aProperty,
                                       CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR),
              "inconsistent property flags");
 
+  // Add from first to last (since last overrides)
   for (size_t playerIdx = 0; playerIdx < aPlayers.Length(); playerIdx++) {
     AnimationPlayer* player = aPlayers[playerIdx];
     if (!player->IsRunning()) {
       continue;
     }
     dom::Animation* anim = player->GetSource();
     if (!anim) {
       continue;
@@ -557,16 +558,18 @@ nsDisplayListBuilder::AddAnimationsAndTr
 
     data = TransformData(origin, offsetToTransformOrigin,
                          offsetToPerspectiveOrigin, bounds, perspective,
                          aFrame->PresContext()->AppUnitsPerDevPixel());
   } else if (aProperty == eCSSProperty_opacity) {
     data = null_t();
   }
 
+  // When both are running, animations override transitions.  We want
+  // to add the ones that override last.
   if (transitions) {
     AddAnimationsForProperty(aFrame, aProperty, transitions->mPlayers,
                              aLayer, data, pending);
   }
 
   if (animations) {
     AddAnimationsForProperty(aFrame, aProperty, animations->mPlayers,
                              aLayer, data, pending);
diff --git a/layout/style/test/test_animations_omta.html b/layout/style/test/test_animations_omta.html
--- a/layout/style/test/test_animations_omta.html
+++ b/layout/style/test/test_animations_omta.html
@@ -2188,17 +2188,16 @@ addAsyncAnimTest(function *() {
   new_div("animation: anim2 1s linear, anim3 500ms linear reverse");
   yield waitForPaintsFlushed();
   omta_is("opacity", 1, RunningOn.Compositor,
           "anim3 overriding anim2 at start (0s)");
   advance_clock(400);
   omta_is("opacity", 0.2, RunningOn.Compositor,
           "anim3 overriding anim2 at 400ms");
   advance_clock(200);
-  // FIXME: This test fails in mochitest-plain but passes in mochitest-e10s.
   omta_is("opacity", 0.6, RunningOn.Compositor,
           "anim2 at 600ms");
   done_div();
 
   // One animation overriding another, and then not, but without a
   // restyle when the overriding one ends.
   new_div("animation: anim2 1s steps(8, end)");
   yield waitForPaintsFlushed();
@@ -2210,20 +2209,18 @@ addAsyncAnimTest(function *() {
   gDiv.style.animation = "anim2 1s steps(8, end), anim3 500ms steps(4, end)";
   yield waitForPaintsFlushed();
   omta_is("opacity", 0, RunningOn.Compositor,
           "anim3 overriding anim2 at 300ms");
   advance_clock(475);
   omta_is("opacity", 0.75, RunningOn.Compositor,
           "anim3 the same as anim2 at 775ms");
   advance_clock(50);
-  // FIXME: This test fails in mochitest-plain but passes in mochitest-e10s.
   omta_is("opacity", 0.75, RunningOn.Compositor,
           "anim2 at 825ms");
   advance_clock(75);
-  // FIXME: This test fails in mochitest-plain but passes in mochitest-e10s.
   omta_is("opacity", 0.875, RunningOn.Compositor,
           "anim2 at 900ms");
   done_div();
 });
 
 </script>
 </html>
