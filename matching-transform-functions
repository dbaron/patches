From: L. David Baron <dbaron@dbaron.org>

Bug 977311 - Treat matrix(), matrix3d(), perspective(), and interpolatematrix() as being matching transform functions for determining whether interpolation can be per-list-item.

diff --git a/layout/style/StyleAnimationValue.cpp b/layout/style/StyleAnimationValue.cpp
--- a/layout/style/StyleAnimationValue.cpp
+++ b/layout/style/StyleAnimationValue.cpp
@@ -1631,20 +1631,30 @@ AddDifferentTransformLists(double aCoeff
   }
 
   aList2->CloneInto(arr->Item(2).SetListValue());
   arr->Item(3).SetPercentValue(aCoeff2);
 
   return result.forget();
 }
 
+static inline bool
+InterpolatesAsMatrix(nsCSSKeyword aFunction)
+{
+  return aFunction == eCSSKeyword_matrix ||
+         aFunction == eCSSKeyword_matrix3d ||
+         aFunction == eCSSKeyword_interpolatematrix ||
+         aFunction == eCSSKeyword_perspective;
+}
+
 static bool
 TransformFunctionsMatch(nsCSSKeyword func1, nsCSSKeyword func2)
 {
-  return ToPrimitive(func1) == ToPrimitive(func2);
+  return ToPrimitive(func1) == ToPrimitive(func2) ||
+         (InterpolatesAsMatrix(func1) && InterpolatesAsMatrix(func2));
 }
 
 static bool
 AddFilterFunctionImpl(double aCoeff1, const nsCSSValueList* aList1,
                       double aCoeff2, const nsCSSValueList* aList2,
                       nsCSSValueList**& aResultTail)
 {
   // AddFilterFunction should be our only caller, and it should ensure that both
@@ -1850,27 +1860,29 @@ AddTransformLists(double aCoeff1, const 
         tfunc != eCSSKeyword_interpolatematrix &&
         tfunc != eCSSKeyword_rotate3d &&
         tfunc != eCSSKeyword_perspective) {
       arr = StyleAnimationValue::AppendTransformFunction(tfunc, resultTail);
     }
 
     switch (tfunc) {
       case eCSSKeyword_translate3d: {
+          MOZ_ASSERT(nsStyleTransformMatrix::TransformFunctionOf(a2) == tfunc);
           MOZ_ASSERT(a1->Count() == 4, "unexpected count");
           MOZ_ASSERT(a2->Count() == 4, "unexpected count");
           AddTransformTranslate(aCoeff1, a1->Item(1), aCoeff2, a2->Item(1),
                                 arr->Item(1));
           AddTransformTranslate(aCoeff1, a1->Item(2), aCoeff2, a2->Item(2),
                                 arr->Item(2));
           AddTransformTranslate(aCoeff1, a1->Item(3), aCoeff2, a2->Item(3),
                                 arr->Item(3));
           break;
       }
       case eCSSKeyword_scale3d: {
+          MOZ_ASSERT(nsStyleTransformMatrix::TransformFunctionOf(a2) == tfunc);
           MOZ_ASSERT(a1->Count() == 4, "unexpected count");
           MOZ_ASSERT(a2->Count() == 4, "unexpected count");
 
           AddTransformScale(aCoeff1, a1->Item(1), aCoeff2, a2->Item(1),
                             arr->Item(1));
           AddTransformScale(aCoeff1, a1->Item(2), aCoeff2, a2->Item(2),
                             arr->Item(2));
           AddTransformScale(aCoeff1, a1->Item(3), aCoeff2, a2->Item(3),
@@ -1879,16 +1891,17 @@ AddTransformLists(double aCoeff1, const 
           break;
       }
       // It would probably be nicer to animate skew in tangent space
       // rather than angle space.  However, it's easy to specify
       // skews with infinite tangents, and behavior changes pretty
       // drastically when crossing such skews (since the direction of
       // animation flips), so interop is probably more important here.
       case eCSSKeyword_skew: {
+        MOZ_ASSERT(nsStyleTransformMatrix::TransformFunctionOf(a2) == tfunc);
         MOZ_ASSERT(a1->Count() == 2 || a1->Count() == 3,
                    "unexpected count");
         MOZ_ASSERT(a2->Count() == 2 || a2->Count() == 3,
                    "unexpected count");
 
         nsCSSValue zero(0.0f, eCSSUnit_Radian);
         // Add Y component of skew.
         AddCSSValueAngle(aCoeff1,
@@ -1905,25 +1918,27 @@ AddTransformLists(double aCoeff1, const 
         break;
       }
       case eCSSKeyword_skewx:
       case eCSSKeyword_skewy:
       case eCSSKeyword_rotate:
       case eCSSKeyword_rotatex:
       case eCSSKeyword_rotatey:
       case eCSSKeyword_rotatez: {
+        MOZ_ASSERT(nsStyleTransformMatrix::TransformFunctionOf(a2) == tfunc);
         MOZ_ASSERT(a1->Count() == 2, "unexpected count");
         MOZ_ASSERT(a2->Count() == 2, "unexpected count");
 
         AddCSSValueAngle(aCoeff1, a1->Item(1), aCoeff2, a2->Item(1),
                          arr->Item(1));
 
         break;
       }
       case eCSSKeyword_rotate3d: {
+        MOZ_ASSERT(nsStyleTransformMatrix::TransformFunctionOf(a2) == tfunc);
         Point3D vector1(a1->Item(1).GetFloatValue(),
                         a1->Item(2).GetFloatValue(),
                         a1->Item(3).GetFloatValue());
         vector1.Normalize();
         Point3D vector2(a2->Item(1).GetFloatValue(),
                         a2->Item(2).GetFloatValue(),
                         a2->Item(3).GetFloatValue());
         vector2.Normalize();
@@ -1944,16 +1959,21 @@ AddTransformLists(double aCoeff1, const 
           break;
         }
         MOZ_FALLTHROUGH;
       }
       case eCSSKeyword_matrix:
       case eCSSKeyword_matrix3d:
       case eCSSKeyword_interpolatematrix:
       case eCSSKeyword_perspective: {
+        // NOTE:  In these cases,
+        // nsStyleTransformMatrix::TransformFunctionOf(a1) (i.e., tfunc)
+        // and nsStyleTransformMatrix::TransformFunctionOf(a2) might be
+        // different.  See TransformFunctionsMatch.
+
         // FIXME: If the matrix contains only numbers then we could decompose
         // here.
 
         // Construct temporary lists with only this item in them.
         nsCSSValueList tempList1, tempList2;
         tempList1.mValue = aList1->mValue;
         tempList2.mValue = aList2->mValue;
 
