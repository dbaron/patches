From: L. David Baron <dbaron@dbaron.org>

Bug 977311 - Treat matrix(), matrix3d(), perspective(), and interpolatematrix() as being matching transform functions for determining whether interpolation can be per-list-item.

diff --git a/layout/style/StyleAnimationValue.cpp b/layout/style/StyleAnimationValue.cpp
--- a/layout/style/StyleAnimationValue.cpp
+++ b/layout/style/StyleAnimationValue.cpp
@@ -146,27 +146,37 @@ HasAccumulateMatrix(const nsCSSValueList
       return true;
     }
     item = item->mNext;
   } while (item);
 
   return false;
 }
 
+static inline bool
+InterpolatesAsMatrix(nsCSSKeyword aFunction)
+{
+  return aFunction == eCSSKeyword_matrix ||
+         aFunction == eCSSKeyword_matrix3d ||
+         aFunction == eCSSKeyword_interpolatematrix ||
+         aFunction == eCSSKeyword_perspective;
+}
+
 static bool
 TransformFunctionsMatch(nsCSSKeyword func1, nsCSSKeyword func2)
 {
   // Handle eCSSKeyword_accumulatematrix as different function to be calculated
   // (decomposed and recomposed) them later.
   if (func1 == eCSSKeyword_accumulatematrix ||
       func2 == eCSSKeyword_accumulatematrix) {
     return false;
   }
 
-  return ToPrimitive(func1) == ToPrimitive(func2);
+  return ToPrimitive(func1) == ToPrimitive(func2) ||
+         (InterpolatesAsMatrix(func1) && InterpolatesAsMatrix(func2));
 }
 
 static bool
 TransformFunctionListsMatch(const nsCSSValueList *list1,
                             const nsCSSValueList *list2)
 {
   const nsCSSValueList *item1 = list1, *item2 = list2;
   do {
@@ -2589,27 +2599,29 @@ AddTransformLists(double aCoeff1, const 
         tfunc != eCSSKeyword_interpolatematrix &&
         tfunc != eCSSKeyword_rotate3d &&
         tfunc != eCSSKeyword_perspective) {
       arr = StyleAnimationValue::AppendTransformFunction(tfunc, resultTail);
     }
 
     switch (tfunc) {
       case eCSSKeyword_translate3d: {
+          MOZ_ASSERT(nsStyleTransformMatrix::TransformFunctionOf(a2) == tfunc);
           MOZ_ASSERT(a1->Count() == 4, "unexpected count");
           MOZ_ASSERT(a2->Count() == 4, "unexpected count");
           AddTransformTranslate(aCoeff1, a1->Item(1), aCoeff2, a2->Item(1),
                                 arr->Item(1));
           AddTransformTranslate(aCoeff1, a1->Item(2), aCoeff2, a2->Item(2),
                                 arr->Item(2));
           AddTransformTranslate(aCoeff1, a1->Item(3), aCoeff2, a2->Item(3),
                                 arr->Item(3));
           break;
       }
       case eCSSKeyword_scale3d: {
+          MOZ_ASSERT(nsStyleTransformMatrix::TransformFunctionOf(a2) == tfunc);
           MOZ_ASSERT(a1->Count() == 4, "unexpected count");
           MOZ_ASSERT(a2->Count() == 4, "unexpected count");
 
           AddTransformScale(aCoeff1, a1->Item(1), aCoeff2, a2->Item(1),
                             arr->Item(1));
           AddTransformScale(aCoeff1, a1->Item(2), aCoeff2, a2->Item(2),
                             arr->Item(2));
           AddTransformScale(aCoeff1, a1->Item(3), aCoeff2, a2->Item(3),
@@ -2618,16 +2630,17 @@ AddTransformLists(double aCoeff1, const 
           break;
       }
       // It would probably be nicer to animate skew in tangent space
       // rather than angle space.  However, it's easy to specify
       // skews with infinite tangents, and behavior changes pretty
       // drastically when crossing such skews (since the direction of
       // animation flips), so interop is probably more important here.
       case eCSSKeyword_skew: {
+        MOZ_ASSERT(nsStyleTransformMatrix::TransformFunctionOf(a2) == tfunc);
         MOZ_ASSERT(a1->Count() == 2 || a1->Count() == 3,
                    "unexpected count");
         MOZ_ASSERT(a2->Count() == 2 || a2->Count() == 3,
                    "unexpected count");
 
         nsCSSValue zero(0.0f, eCSSUnit_Radian);
         // Add Y component of skew.
         AddCSSValueAngle(aCoeff1,
@@ -2644,25 +2657,27 @@ AddTransformLists(double aCoeff1, const 
         break;
       }
       case eCSSKeyword_skewx:
       case eCSSKeyword_skewy:
       case eCSSKeyword_rotate:
       case eCSSKeyword_rotatex:
       case eCSSKeyword_rotatey:
       case eCSSKeyword_rotatez: {
+        MOZ_ASSERT(nsStyleTransformMatrix::TransformFunctionOf(a2) == tfunc);
         MOZ_ASSERT(a1->Count() == 2, "unexpected count");
         MOZ_ASSERT(a2->Count() == 2, "unexpected count");
 
         AddCSSValueAngle(aCoeff1, a1->Item(1), aCoeff2, a2->Item(1),
                          arr->Item(1));
 
         break;
       }
       case eCSSKeyword_rotate3d: {
+        MOZ_ASSERT(nsStyleTransformMatrix::TransformFunctionOf(a2) == tfunc);
         Point3D vector1(a1->Item(1).GetFloatValue(),
                         a1->Item(2).GetFloatValue(),
                         a1->Item(3).GetFloatValue());
         vector1.Normalize();
         Point3D vector2(a2->Item(1).GetFloatValue(),
                         a2->Item(2).GetFloatValue(),
                         a2->Item(3).GetFloatValue());
         vector2.Normalize();
@@ -2682,16 +2697,22 @@ AddTransformLists(double aCoeff1, const 
                            arr->Item(4));
           break;
         }
         MOZ_FALLTHROUGH;
       }
       case eCSSKeyword_matrix:
       case eCSSKeyword_matrix3d:
       case eCSSKeyword_perspective:
+        // NOTE:  In these cases,
+        // nsStyleTransformMatrix::TransformFunctionOf(a1) (i.e., tfunc)
+        // and nsStyleTransformMatrix::TransformFunctionOf(a2) might be
+        // different.  See TransformFunctionsMatch.
+        // (Does this also apply to interpolatematrix below?
+
         if (aCoeff1 == 0.0 && aCoeff2 == 0.0) {
           // Special case. If both coefficients are 0.0, we should apply an
           // identity transform function.
           arr = StyleAnimationValue::AppendTransformFunction(tfunc, resultTail);
 
           if (tfunc == eCSSKeyword_rotate3d) {
             arr->Item(1).SetFloatValue(0.0, eCSSUnit_Number);
             arr->Item(2).SetFloatValue(0.0, eCSSUnit_Number);
