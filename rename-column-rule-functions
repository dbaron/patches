From: L. David Baron <dbaron@dbaron.org>

Bug 1432341 - Rename functions that relate to column rules to have clearer names.  r?mattwoodrow

This is followup to bug 1361668, and is just cleanup in advance of the
patch to fix this bug.

MozReview-Commit-ID: 4HOKLA5WYNq

diff --git a/layout/generic/nsColumnSetFrame.cpp b/layout/generic/nsColumnSetFrame.cpp
--- a/layout/generic/nsColumnSetFrame.cpp
+++ b/layout/generic/nsColumnSetFrame.cpp
@@ -30,17 +30,18 @@ public:
 
   /**
    * Returns the frame's visual overflow rect instead of the frame's bounds.
    */
   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder,
                            bool* aSnap) const override
   {
     *aSnap = false;
-    return static_cast<nsColumnSetFrame*>(mFrame)->CalculateBounds(ToReferenceFrame());
+    return static_cast<nsColumnSetFrame*>(mFrame)->
+      CalculateColumnRuleBounds(ToReferenceFrame());
   }
 
   virtual LayerState GetLayerState(nsDisplayListBuilder* aBuilder,
                                    LayerManager* aManager,
                                    const ContainerLayerParameters& aParameters) override;
   virtual already_AddRefed<Layer> BuildLayer(nsDisplayListBuilder* aBuilder,
                                              LayerManager* aManager,
                                              const ContainerLayerParameters& aContainerParameters) override;
@@ -142,18 +143,18 @@ NS_IMPL_FRAMEARENA_HELPERS(nsColumnSetFr
 
 nsColumnSetFrame::nsColumnSetFrame(nsStyleContext* aContext)
   : nsContainerFrame(aContext, kClassID)
   , mLastBalanceBSize(NS_INTRINSICSIZE)
 {
 }
 
 void
-nsColumnSetFrame::ForEachColumn(const std::function<void(const nsRect& lineRect)>& aSetLineRect,
-                                const nsPoint& aPt)
+nsColumnSetFrame::ForEachColumnRule(const std::function<void(const nsRect& lineRect)>& aSetLineRect,
+                                    const nsPoint& aPt)
 {
   nsIFrame* child = mFrames.FirstChild();
   if (!child)
     return;  // no columns
 
   nsIFrame* nextSibling = child->GetNextSibling();
   if (!nextSibling)
     return;  // 1 column only - this means no gap to draw on
@@ -198,23 +199,23 @@ nsColumnSetFrame::ForEachColumn(const st
     aSetLineRect(nsRect(linePt, ruleSize));
 
     child = nextSibling;
     nextSibling = nextSibling->GetNextSibling();
   }
 }
 
 nsRect
-nsColumnSetFrame::CalculateBounds(const nsPoint& aOffset)
+nsColumnSetFrame::CalculateColumnRuleBounds(const nsPoint& aOffset)
 {
   nsRect combined;
-  ForEachColumn([&combined](const nsRect& aLineRect)
-                {
-                  combined = combined.Union(aLineRect);
-                }, aOffset);
+  ForEachColumnRule([&combined](const nsRect& aLineRect)
+                    {
+                      combined = combined.Union(aLineRect);
+                    }, aOffset);
   return combined;
 }
 
 void
 nsColumnSetFrame::CreateBorderRenderers(nsTArray<nsCSSBorderRenderer>& aBorderRenderers,
                                         gfxContext* aCtx,
                                         const nsRect& aDirtyRect,
                                         const nsPoint& aPt)
@@ -257,37 +258,37 @@ nsColumnSetFrame::CreateBorderRenderers(
   } else {
     border.SetBorderWidth(eSideLeft, ruleWidth);
     border.SetBorderStyle(eSideLeft, ruleStyle);
     border.mBorderLeftColor = StyleComplexColor::FromColor(ruleColor);
     skipSides |= mozilla::eSideBitsTopBottom;
     skipSides |= mozilla::eSideBitsRight;
   }
 
-  ForEachColumn([&]
-                (const nsRect& aLineRect)
-                {
-                  // Assert that we're not drawing a border-image here; if we were, we
-                  // couldn't ignore the ImgDrawResult that PaintBorderWithStyleBorder returns.
-                  MOZ_ASSERT(border.mBorderImageSource.GetType() == eStyleImageType_Null);
+  ForEachColumnRule([&]
+                    (const nsRect& aLineRect)
+                    {
+                      // Assert that we're not drawing a border-image here; if we were, we
+                      // couldn't ignore the ImgDrawResult that PaintBorderWithStyleBorder returns.
+                      MOZ_ASSERT(border.mBorderImageSource.GetType() == eStyleImageType_Null);
 
-                  gfx::DrawTarget* dt = aCtx ? aCtx->GetDrawTarget() : nullptr;
-                  bool borderIsEmpty = false;
-                  Maybe<nsCSSBorderRenderer> br =
-                    nsCSSRendering::CreateBorderRendererWithStyleBorder(presContext, dt,
-                                                                        this, aDirtyRect,
-                                                                        aLineRect, border,
-                                                                        StyleContext(),
-                                                                        &borderIsEmpty,
-                                                                        skipSides);
-                  if (br.isSome()) {
-                    MOZ_ASSERT(!borderIsEmpty);
-                    aBorderRenderers.AppendElement(br.value());
-                  }
-                }, aPt);
+                      gfx::DrawTarget* dt = aCtx ? aCtx->GetDrawTarget() : nullptr;
+                      bool borderIsEmpty = false;
+                      Maybe<nsCSSBorderRenderer> br =
+                        nsCSSRendering::CreateBorderRendererWithStyleBorder(presContext, dt,
+                                                                            this, aDirtyRect,
+                                                                            aLineRect, border,
+                                                                            StyleContext(),
+                                                                            &borderIsEmpty,
+                                                                            skipSides);
+                      if (br.isSome()) {
+                        MOZ_ASSERT(!borderIsEmpty);
+                        aBorderRenderers.AppendElement(br.value());
+                      }
+                    }, aPt);
 }
 
 static nscoord
 GetAvailableContentISize(const ReflowInput& aReflowInput)
 {
   if (aReflowInput.AvailableISize() == NS_INTRINSICSIZE) {
     return NS_INTRINSICSIZE;
   }
diff --git a/layout/generic/nsColumnSetFrame.h b/layout/generic/nsColumnSetFrame.h
--- a/layout/generic/nsColumnSetFrame.h
+++ b/layout/generic/nsColumnSetFrame.h
@@ -81,17 +81,17 @@ public:
   void AppendDirectlyOwnedAnonBoxes(nsTArray<OwnedAnonBox>& aResult) override;
 
 #ifdef DEBUG_FRAME_DUMP
   virtual nsresult GetFrameName(nsAString& aResult) const override {
     return MakeFrameName(NS_LITERAL_STRING("ColumnSet"), aResult);
   }
 #endif
 
-  nsRect CalculateBounds(const nsPoint& aOffset);
+  nsRect CalculateColumnRuleBounds(const nsPoint& aOffset);
   void CreateBorderRenderers(nsTArray<nsCSSBorderRenderer>& aBorderRenderers,
                              gfxContext* aCtx,
                              const nsRect& aDirtyRect,
                              const nsPoint& aPt);
 
 protected:
   nscoord        mLastBalanceBSize;
   nsReflowStatus mLastFrameStatus;
@@ -223,13 +223,13 @@ protected:
   bool ReflowChildren(ReflowOutput& aDesiredSize,
                         const ReflowInput& aReflowInput,
                         nsReflowStatus& aStatus,
                         const ReflowConfig& aConfig,
                         bool aLastColumnUnbounded,
                         nsCollapsingMargin* aCarriedOutBEndMargin,
                         ColumnBalanceData& aColData);
 
-  void ForEachColumn(const std::function<void(const nsRect& lineRect)>& aSetLineRect,
-                     const nsPoint& aPt);
+  void ForEachColumnRule(const std::function<void(const nsRect& lineRect)>& aSetLineRect,
+                         const nsPoint& aPt);
 };
 
 #endif // nsColumnSetFrame_h___
