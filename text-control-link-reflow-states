From: L. David Baron <dbaron@dbaron.org>

When reflowing a frame (such as text controls) that jumps from HTML layout into XUL layout and then jumps back to HTML on the child frame, link the parent reflow state chain correctly.  (Bug 627842, patch 3)  r?roc

diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -7526,18 +7526,31 @@ nsFrame::BoxReflow(nsBoxLayoutState&    
     // XXX Is it OK that this reflow state has no parent reflow state?
     // (It used to have a bogus parent, skipping all the boxes).
     nsSize availSize(aWidth, NS_INTRINSICSIZE);
     nsHTMLReflowState reflowState(aPresContext, this, aRenderingContext,
                                   availSize);
 
     // Construct the parent chain manually since constructing it normally
     // messes up dimensions.
-    reflowState.parentReflowState = &parentReflowState;
-    reflowState.mCBReflowState = &parentReflowState;
+    const nsHTMLReflowState *outerReflowState = aState.OuterReflowState();
+    NS_ASSERTION(!outerReflowState || outerReflowState->frame != this,
+                 "in and out of XUL on a single frame?");
+    if (outerReflowState && outerReflowState->frame == parentFrame) {
+      // We're a frame (such as a text control frame) that jumps into
+      // box reflow and then straight out of it on the child frame.
+      // This means we actually have a real parent reflow state.
+      // nsLayoutUtils::InflationMinFontSizeFor needs this to be linked
+      // up correctly for text control frames, so do so here).
+      reflowState.parentReflowState = outerReflowState;
+      reflowState.mCBReflowState = outerReflowState;
+    } else {
+      reflowState.parentReflowState = &parentReflowState;
+      reflowState.mCBReflowState = &parentReflowState;
+    }
     reflowState.mReflowDepth = aState.GetReflowDepth();
 
     // mComputedWidth and mComputedHeight are content-box, not
     // border-box
     if (aWidth != NS_INTRINSICSIZE) {
       nscoord computedWidth =
         aWidth - reflowState.mComputedBorderPadding.LeftRight();
       computedWidth = NS_MAX(computedWidth, 0);
diff --git a/layout/xul/base/src/nsBoxFrame.cpp b/layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp
+++ b/layout/xul/base/src/nsBoxFrame.cpp
@@ -672,17 +672,17 @@ nsBoxFrame::Reflow(nsPresContext*       
   printf(" *\n");
 
 #endif
 
   aStatus = NS_FRAME_COMPLETE;
 
   // create the layout state
   nsBoxLayoutState state(aPresContext, aReflowState.rendContext,
-                         aReflowState.mReflowDepth);
+                         &aReflowState, aReflowState.mReflowDepth);
 
   nsSize computedSize(aReflowState.ComputedWidth(),aReflowState.ComputedHeight());
 
   nsMargin m;
   m = aReflowState.mComputedBorderPadding;
   // GetBorderAndPadding(m);
 
   nsSize prefSize(0,0);
diff --git a/layout/xul/base/src/nsBoxLayoutState.cpp b/layout/xul/base/src/nsBoxLayoutState.cpp
--- a/layout/xul/base/src/nsBoxLayoutState.cpp
+++ b/layout/xul/base/src/nsBoxLayoutState.cpp
@@ -41,27 +41,30 @@
 //
 // See documentation in associated header file
 //
 
 #include "nsBoxLayoutState.h"
 
 nsBoxLayoutState::nsBoxLayoutState(nsPresContext* aPresContext,
                                    nsRenderingContext* aRenderingContext,
+                                   const nsHTMLReflowState* aOuterReflowState,
                                    PRUint16 aReflowDepth)
   : mPresContext(aPresContext)
   , mRenderingContext(aRenderingContext)
+  , mOuterReflowState(aOuterReflowState)
   , mLayoutFlags(0)
   , mReflowDepth(aReflowDepth)
   , mPaintingDisabled(false)
 {
   NS_ASSERTION(mPresContext, "PresContext must be non-null");
 }
 
 nsBoxLayoutState::nsBoxLayoutState(const nsBoxLayoutState& aState)
   : mPresContext(aState.mPresContext)
   , mRenderingContext(aState.mRenderingContext)
+  , mOuterReflowState(aState.mOuterReflowState)
   , mLayoutFlags(aState.mLayoutFlags)
   , mReflowDepth(aState.mReflowDepth + 1)
   , mPaintingDisabled(aState.mPaintingDisabled)
 {
   NS_ASSERTION(mPresContext, "PresContext must be non-null");
 }
diff --git a/layout/xul/base/src/nsBoxLayoutState.h b/layout/xul/base/src/nsBoxLayoutState.h
--- a/layout/xul/base/src/nsBoxLayoutState.h
+++ b/layout/xul/base/src/nsBoxLayoutState.h
@@ -54,17 +54,20 @@ class nsRenderingContext;
 class nsCalculatedBoxInfo;
 struct nsHTMLReflowMetrics;
 class nsString;
 class nsHTMLReflowCommand;
 
 class NS_STACK_CLASS nsBoxLayoutState
 {
 public:
-  nsBoxLayoutState(nsPresContext* aPresContext, nsRenderingContext* aRenderingContext = nsnull,
+  nsBoxLayoutState(nsPresContext* aPresContext,
+                   nsRenderingContext* aRenderingContext = nsnull,
+                   // see OuterReflowState() below
+                   const nsHTMLReflowState* aOuterReflowState = nsnull,
                    PRUint16 aReflowDepth = 0) NS_HIDDEN;
   nsBoxLayoutState(const nsBoxLayoutState& aState) NS_HIDDEN;
 
   nsPresContext* PresContext() const { return mPresContext; }
   nsIPresShell* PresShell() const { return mPresContext->PresShell(); }
 
   PRUint32 LayoutFlags() const { return mLayoutFlags; }
   void SetLayoutFlags(PRUint32 aFlags) { mLayoutFlags = aFlags; }
@@ -79,20 +82,25 @@ public:
   // doing box layout or intrinsic size calculation will cause bugs.
   nsRenderingContext* GetRenderingContext() const { return mRenderingContext; }
 
   void PushStackMemory() { PresShell()->PushStackMemory(); ++mReflowDepth; }
   void PopStackMemory()  { PresShell()->PopStackMemory(); --mReflowDepth; }
   void* AllocateStackMemory(size_t aSize)
   { return PresShell()->AllocateStackMemory(aSize); }
 
+  // The HTML reflow state that lives outside the box-block boundary.
+  // May not be set reliably yet.
+  const nsHTMLReflowState* OuterReflowState() { return mOuterReflowState; }
+
   PRUint16 GetReflowDepth() { return mReflowDepth; }
   
 private:
   nsRefPtr<nsPresContext> mPresContext;
   nsRenderingContext *mRenderingContext;
+  const nsHTMLReflowState *mOuterReflowState;
   PRUint32 mLayoutFlags;
   PRUint16 mReflowDepth; 
   bool mPaintingDisabled;
 };
 
 #endif
 
