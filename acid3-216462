From: Brian Birtles <birtles@gmail.com>, Tim Rowley <tor@acm.org>, Daniel Holbert <dholbert@mozilla.com>

WIP from attachment 350900 on bug 216462.

diff --git a/browser/installer/unix/packages-static b/browser/installer/unix/packages-static
--- a/browser/installer/unix/packages-static
+++ b/browser/installer/unix/packages-static
@@ -337,16 +337,19 @@ bin/res/charsetData.properties
 bin/res/charsetData.properties
 bin/res/langGroups.properties
 bin/res/language.properties
 bin/res/entityTables/*
 
 ; svg
 bin/res/svg.css
 bin/components/dom_svg.xpt
+#ifdef MOZ_SMIL
+bin/components/dom_smil.xpt
+#endif
 
 ; [Personal Security Manager]
 ;
 bin/libnssckbi.so
 bin/components/pipboot.xpt
 bin/components/pipnss.xpt
 bin/components/pippki.xpt
 bin/libnss3.so
diff --git a/browser/installer/windows/packages-static b/browser/installer/windows/packages-static
--- a/browser/installer/windows/packages-static
+++ b/browser/installer/windows/packages-static
@@ -333,16 +333,19 @@ bin\res\charsetData.properties
 bin\res\charsetData.properties
 bin\res\langGroups.properties
 bin\res\language.properties
 bin\res\entityTables\*
 
 ; svg
 bin\res\svg.css
 bin\components\dom_svg.xpt
+#ifdef MOZ_SMIL
+bin\components\dom_smil.xpt
+#endif
 
 ; [Personal Security Manager]
 ;
 bin\nssckbi.dll
 bin\components\pipboot.xpt
 bin\components\pipnss.xpt
 bin\components\pippki.xpt
 bin\nssutil3.dll
diff --git a/config/autoconf.mk.in b/config/autoconf.mk.in
--- a/config/autoconf.mk.in
+++ b/config/autoconf.mk.in
@@ -225,16 +225,17 @@ MOZ_MATHML = @MOZ_MATHML@
 MOZ_MATHML = @MOZ_MATHML@
 MOZ_PERMISSIONS = @MOZ_PERMISSIONS@
 MOZ_XTF = @MOZ_XTF@
 MOZ_NO_INSPECTOR_APIS = @MOZ_NO_INSPECTOR_APIS@
 MOZ_SVG = @MOZ_SVG@
 MOZ_LIBART_CFLAGS = @MOZ_LIBART_CFLAGS@
 MOZ_ENABLE_CANVAS = @MOZ_ENABLE_CANVAS@
 MOZ_CAIRO_CFLAGS = @MOZ_CAIRO_CFLAGS@
+MOZ_SMIL = @MOZ_SMIL@
 MOZ_XSLT_STANDALONE = @MOZ_XSLT_STANDALONE@
 
 MOZ_PREF_EXTENSIONS = @MOZ_PREF_EXTENSIONS@
 
 MOZ_CAIRO_LIBS = @MOZ_CAIRO_LIBS@
 
 MOZ_ENABLE_GNOMEUI = @MOZ_ENABLE_GNOMEUI@
 MOZ_GNOMEUI_CFLAGS = @MOZ_GNOMEUI_CFLAGS@
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -4352,16 +4352,17 @@ MOZ_PYTHON_LIBS=
 MOZ_PYTHON_LIBS=
 MOZ_PYTHON_PREFIX=
 MOZ_PYTHON_VER=
 MOZ_PYTHON_VER_DOTTED=
 MOZ_RDF=1
 MOZ_REFLOW_PERF=
 MOZ_SAFE_BROWSING=
 MOZ_HELP_VIEWER=
+MOZ_SMIL=1
 MOZ_SPELLCHECK=1
 MOZ_STATIC_MAIL_BUILD=
 MOZ_STORAGE=1
 MOZ_SVG=1
 MOZ_TIMELINE=
 MOZ_UI_LOCALE=en-US
 MOZ_UNIVERSALCHARDET=1
 MOZ_URL_CLASSIFIER=
@@ -5725,16 +5726,27 @@ MOZ_ARG_DISABLE_BOOL(svg,
 [  --disable-svg            Disable SVG support],
     MOZ_SVG=,
     MOZ_SVG=1 )
 if test -n "$MOZ_SVG"; then
   AC_DEFINE(MOZ_SVG)
 fi
 
 dnl ========================================================
+dnl SMIL
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(smil,
+[  --enable-smil            Enable SMIL animation support],
+    MOZ_SMIL=1,
+    MOZ_SMIL= )
+if test -n "$MOZ_SMIL"; then
+  AC_DEFINE(MOZ_SMIL)
+fi
+
+dnl ========================================================
 dnl Installer
 dnl ========================================================
 case "$target_os" in
     aix*|solaris*|linux*|msvc*|mks*|cygwin*|mingw*|os2*|wince*)
         MOZ_INSTALLER=1
         ;;
 esac
 
@@ -7793,16 +7805,17 @@ AC_SUBST(NS_MAEMO_LOCATION)
 AC_SUBST(NS_MAEMO_LOCATION)
 AC_SUBST(MOZ_AUTH_EXTENSION)
 AC_SUBST(MOZ_MATHML)
 AC_SUBST(MOZ_PERMISSIONS)
 AC_SUBST(MOZ_XTF)
 AC_SUBST(MOZ_NO_INSPECTOR_APIS)
 AC_SUBST(MOZ_PREF_EXTENSIONS)
 AC_SUBST(MOZ_SVG)
+AC_SUBST(MOZ_SMIL)
 AC_SUBST(MOZ_XSLT_STANDALONE)
 AC_SUBST(MOZ_JS_LIBS)
 AC_SUBST(MOZ_PSM)
 AC_SUBST(MOZ_DEBUG)
 AC_SUBST(MOZ_DEBUG_MODULES)
 AC_SUBST(MOZ_PROFILE_MODULES)
 AC_SUBST(MOZ_DEBUG_ENABLE_DEFS)
 AC_SUBST(MOZ_DEBUG_DISABLE_DEFS)
diff --git a/content/Makefile.in b/content/Makefile.in
--- a/content/Makefile.in
+++ b/content/Makefile.in
@@ -54,16 +54,20 @@ ifdef MOZ_SVG
 ifdef MOZ_SVG
 PARALLEL_DIRS	+= svg
 endif
 
 ifdef MOZ_XTF
 PARALLEL_DIRS   += xtf
 endif
 
+ifdef MOZ_SMIL
+PARALLEL_DIRS	+= smil
+endif
+
 ifdef MOZ_MATHML
 PARALLEL_DIRS   += mathml
 endif
 
 PARALLEL_DIRS   += events
 
 ifdef ENABLE_TESTS
 TOOL_DIRS += test
diff --git a/content/base/public/nsIContent.h b/content/base/public/nsIContent.h
--- a/content/base/public/nsIContent.h
+++ b/content/base/public/nsIContent.h
@@ -54,16 +54,19 @@ class nsIEventListenerManager;
 class nsIEventListenerManager;
 class nsIURI;
 class nsICSSStyleRule;
 class nsRuleWalker;
 class nsAttrValue;
 class nsAttrName;
 class nsTextFragment;
 class nsIDocShell;
+#ifdef MOZ_SMIL
+class nsISMILAttr;
+#endif // MOZ_SMIL
 
 // IID for the nsIContent interface
 #define NS_ICONTENT_IID       \
 { 0x2813b1d9, 0x7fe1, 0x496f, \
  { 0x85, 0x52, 0xa2, 0xc1, 0xc5, 0x6b, 0x15, 0x40 } }
 
 /**
  * A node of content in a document's content model. This interface
@@ -849,16 +852,28 @@ public:
    */
   virtual void DestroyContent() = 0;
 
   /**
    * Saves the form state of this node and its children.
    */
   virtual void SaveSubtreeState() = 0;
 
+#ifdef MOZ_SMIL
+  /*
+   * Returns a nsISMILAttr that allows the caller to animate the given
+   * attribute on this element. The 'aIsCSS' parameter indicates whether the
+   * requested attribute is a CSS property or just a standard XML attribute.
+   *
+   * XXXdholbert aIsCSS needs to be more generic
+   */
+  virtual nsISMILAttr* GetAnimatedAttr(const nsIAtom* aName,
+                                       PRBool aIsCSS) = 0;
+#endif // MOZ_SMIL
+
 private:
   /**
    * Hook for implementing GetClasses.  This is guaranteed to only be
    * called if the NODE_MAY_HAVE_CLASS flag is set.
    */
   virtual const nsAttrValue* DoGetClasses() const = 0;
 
 public:
diff --git a/content/base/public/nsIDocument.h b/content/base/public/nsIDocument.h
--- a/content/base/public/nsIDocument.h
+++ b/content/base/public/nsIDocument.h
@@ -49,16 +49,20 @@
 #include "nsCRT.h"
 #include "mozFlushType.h"
 #include "nsIAtom.h"
 #include "nsCompatibility.h"
 #include "nsTObserverArray.h"
 #include "nsNodeInfoManager.h"
 #include "nsIStreamListener.h"
 #include "nsIObserver.h"
+#ifdef MOZ_SMIL
+#include "nsHashKeys.h"
+class nsISMILAnimationSpec;
+#endif // MOZ_SMIL
 
 class nsIContent;
 class nsPresContext;
 class nsIPresShell;
 class nsIDocShell;
 class nsStyleSet;
 class nsIStyleSheet;
 class nsIStyleRule;
@@ -1092,17 +1096,28 @@ public:
 
   /**
    * Enumerate the external resource documents associated with this document.
    * The enumerator callback should return PR_TRUE to continue enumerating, or
    * PR_FALSE to stop.  This callback will never get passed a null aDocument.
    */
   virtual void EnumerateExternalResources(nsSubDocEnumFunc aCallback,
                                           void* aData) = 0;
-  
+
+#ifdef MOZ_SMIL
+  // Adds a new animation element to be tracked in this document.
+  virtual void AddToAnimationSpecSet(nsISMILAnimationSpec* aAnimationSpec) = 0;
+  virtual void RemoveFromAnimationSpecSet(nsISMILAnimationSpec* aAnimationSpec) = 0;
+
+  typedef PLDHashOperator(*PR_CALLBACK nsAnimationSpecEnumFunc)
+                         (nsVoidPtrHashKey* aKey, void* aData);
+  virtual PRUint32 EnumerateAnimationSpecs(nsAnimationSpecEnumFunc aFunc,
+                                           void *aData) = 0;
+#endif // MOZ_SMIL
+
 protected:
   ~nsIDocument()
   {
     // XXX The cleanup of mNodeInfoManager (calling DropDocumentReference and
     //     releasing it) happens in the nsDocument destructor. We'd prefer to
     //     do it here but nsNodeInfoManager is a concrete class that we don't
     //     want to expose to users of the nsIDocument API outside of Gecko.
   }
diff --git a/content/base/src/nsDocument.cpp b/content/base/src/nsDocument.cpp
--- a/content/base/src/nsDocument.cpp
+++ b/content/base/src/nsDocument.cpp
@@ -1587,16 +1587,22 @@ nsDocument::~nsDocument()
   }
 
   delete mHeaderData;
 
   if (mBoxObjectTable) {
     mBoxObjectTable->EnumerateRead(ClearAllBoxObjects, nsnull);
     delete mBoxObjectTable;
   }
+
+#ifdef MOZ_SMIL
+  NS_ASSERTION(mAnimationSpecSet.Count() == 0,
+               "nsDocument shouldn't be tracking any animation elements "
+               "when it dies...");
+#endif
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsDocument)
 
 NS_INTERFACE_TABLE_HEAD(nsDocument)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
   NS_DOCUMENT_INTERFACE_TABLE_BEGIN(nsDocument)
     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsINode)
@@ -1864,16 +1870,20 @@ nsDocument::Init()
   mNodeInfo = mNodeInfoManager->GetDocumentNodeInfo();
   NS_ENSURE_TRUE(mNodeInfo, NS_ERROR_OUT_OF_MEMORY);
 
   NS_ASSERTION(GetOwnerDoc() == this, "Our nodeinfo is busted!");
 
   mScriptLoader = new nsScriptLoader(this);
   NS_ENSURE_TRUE(mScriptLoader, NS_ERROR_OUT_OF_MEMORY);
 
+#ifdef MOZ_SMIL
+  mAnimationSpecSet.Init();
+#endif // MOZ_SMIL
+
   return NS_OK;
 }
 
 nsresult
 nsDocument::AddXMLEventsContent(nsIContent *aXMLEventsElement)
 {
   if (!mXMLEventsManager) {
     mXMLEventsManager = new nsXMLEventsManager();
@@ -5218,16 +5228,37 @@ nsDocument::RequestExternalResource(nsIU
                                               this, aPendingLoad);
 }
 
 void
 nsDocument::EnumerateExternalResources(nsSubDocEnumFunc aCallback, void* aData)
 {
   mExternalResourceMap.EnumerateResources(aCallback, aData);
 }
+
+#ifdef MOZ_SMIL
+void
+nsDocument::AddToAnimationSpecSet(nsISMILAnimationSpec* aAnimationSpec)
+{
+  mAnimationSpecSet.PutEntry(aAnimationSpec);
+}
+
+void
+nsDocument::RemoveFromAnimationSpecSet(nsISMILAnimationSpec* aAnimationSpec)
+{
+  mAnimationSpecSet.RemoveEntry(aAnimationSpec);
+}
+
+PRUint32
+nsDocument::EnumerateAnimationSpecs(nsAnimationSpecEnumFunc aFunc,
+                                    void *aData)
+{
+  return mAnimationSpecSet.EnumerateEntries(aFunc, aData);
+}
+#endif // MOZ_SMIL
 
 struct DirTable {
   const char* mName;
   PRUint8     mValue;
 };
 
 static const DirTable dirAttributes[] = {
   {"ltr", IBMBIDI_TEXTDIRECTION_LTR},
diff --git a/content/base/src/nsDocument.h b/content/base/src/nsDocument.h
--- a/content/base/src/nsDocument.h
+++ b/content/base/src/nsDocument.h
@@ -971,16 +971,25 @@ public:
   virtual NS_HIDDEN_(PRBool) FrameLoaderScheduledToBeFinalized(nsIDocShell* aShell);
   virtual NS_HIDDEN_(nsIDocument*)
     RequestExternalResource(nsIURI* aURI,
                             nsINode* aRequestingNode,
                             ExternalResourceLoad** aPendingLoad);
   virtual NS_HIDDEN_(void)
     EnumerateExternalResources(nsSubDocEnumFunc aCallback, void* aData);
 
+#ifdef MOZ_SMIL
+  // Used in SMIL to add a new animation element to be tracked by
+  // this document.
+  virtual NS_HIDDEN_(void) AddToAnimationSpecSet(nsISMILAnimationSpec* aAnimationSpec);
+  virtual NS_HIDDEN_(void) RemoveFromAnimationSpecSet(nsISMILAnimationSpec* aAnimationSpec);
+  virtual NS_HIDDEN_(PRUint32) EnumerateAnimationSpecs(nsAnimationSpecEnumFunc aFunc,
+                                                       void *aData);
+#endif // MOZ_SMIL
+
   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsDocument, nsIDocument)
 
   /**
    * Utility method for getElementsByClassName.  aRootNode is the node (either
    * document or element), which getElementsByClassName was called on.
    */
   static nsresult GetElementsByClassNameHelper(nsINode* aRootNode,
                                                const nsAString& aClasses,
@@ -1261,16 +1270,20 @@ private:
   nsString mLastStyleSheetSet;
 
   nsTArray<nsRefPtr<nsFrameLoader> > mInitializableFrameLoaders;
   nsTArray<nsRefPtr<nsFrameLoader> > mFinalizableFrameLoaders;
 
   nsRevocableEventPtr<nsRunnableMethod<nsDocument> > mPendingTitleChangeEvent;
 
   nsExternalResourceMap mExternalResourceMap;
+
+#ifdef MOZ_SMIL
+  nsTHashtable<nsVoidPtrHashKey> mAnimationSpecSet;
+#endif // MOZ_SMIL
 };
 
 #define NS_DOCUMENT_INTERFACE_TABLE_BEGIN(_class)                             \
   NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocument, nsDocument)      \
   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMNSDocument, nsDocument)    \
   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocumentEvent, nsDocument) \
   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocumentView, nsDocument)  \
diff --git a/content/base/src/nsGenericDOMDataNode.h b/content/base/src/nsGenericDOMDataNode.h
--- a/content/base/src/nsGenericDOMDataNode.h
+++ b/content/base/src/nsGenericDOMDataNode.h
@@ -48,16 +48,20 @@
 #include "nsIDOM3Text.h"
 #include "nsTextFragment.h"
 #include "nsVoidArray.h"
 #include "nsDOMError.h"
 #include "nsIEventListenerManager.h"
 #include "nsGenericElement.h"
 #include "nsCycleCollectionParticipant.h"
 #include "nsContentUtils.h"
+
+#ifdef MOZ_SMIL
+#include "nsISMILAttr.h"
+#endif // MOZ_SMIL
 
 class nsIDOMAttr;
 class nsIDOMEventListener;
 class nsIDOMNodeList;
 class nsIFrame;
 class nsIDOMText;
 class nsINodeInfo;
 class nsURI;
@@ -229,16 +233,24 @@ public:
     return SetText(aStr.BeginReading(), aStr.Length(), aNotify);
   }
   virtual nsresult AppendText(const PRUnichar* aBuffer, PRUint32 aLength,
                               PRBool aNotify);
   virtual PRBool TextIsOnlyWhitespace();
   virtual void AppendTextTo(nsAString& aResult);
   virtual void DestroyContent();
   virtual void SaveSubtreeState();
+
+#ifdef MOZ_SMIL
+  virtual nsISMILAttr* GetAnimatedAttr(const nsIAtom* aName, PRBool aIsCSS)
+  {
+    return nsnull;
+  }
+#endif // MOZ_SMIL
+
 #ifdef DEBUG
   virtual void List(FILE* out, PRInt32 aIndent) const;
   virtual void DumpContent(FILE* out, PRInt32 aIndent, PRBool aDumpAll) const;
 #endif
 
   virtual nsIContent *GetBindingParent() const;
   virtual PRBool IsNodeOfType(PRUint32 aFlags) const;
 
diff --git a/content/base/src/nsGenericElement.cpp b/content/base/src/nsGenericElement.cpp
--- a/content/base/src/nsGenericElement.cpp
+++ b/content/base/src/nsGenericElement.cpp
@@ -1848,16 +1848,23 @@ nsGenericElement::InternalIsSupported(ns
            NS_SVG_HaveFeature(aFeature)) {
     if (aVersion.IsEmpty() ||
         PL_strcmp(v, "1.0") == 0 ||
         PL_strcmp(v, "1.1") == 0) {
       *aReturn = PR_TRUE;
     }
   }
 #endif /* MOZ_SVG */
+#ifdef MOZ_SMIL
+  else if (PL_strcasecmp(f, "TimeControl") == 0) {
+    if (aVersion.IsEmpty() || PL_strcmp(v, "1.0") == 0) {
+      *aReturn = PR_TRUE;
+    }
+  }
+#endif /* MOZ_SMIL */
   else {
     nsCOMPtr<nsIDOMNSFeatureFactory> factory =
       GetDOMFeatureFactory(aFeature, aVersion);
 
     if (factory) {
       factory->HasFeature(aObject, aFeature, aVersion, aReturn);
     }
   }
diff --git a/content/base/src/nsGenericElement.h b/content/base/src/nsGenericElement.h
--- a/content/base/src/nsGenericElement.h
+++ b/content/base/src/nsGenericElement.h
@@ -59,16 +59,20 @@
 #include "nsNodeUtils.h"
 #include "nsAttrAndChildArray.h"
 #include "mozFlushType.h"
 #include "nsDOMAttributeMap.h"
 #include "nsIWeakReference.h"
 #include "nsCycleCollectionParticipant.h"
 #include "nsIDocument.h"
 #include "nsIDOMNodeSelector.h"
+
+#ifdef MOZ_SMIL
+#include "nsISMILAttr.h"
+#endif // MOZ_SMIL
 
 class nsIDOMAttr;
 class nsIDOMEventListener;
 class nsIFrame;
 class nsIDOMNamedNodeMap;
 class nsDOMCSSDeclaration;
 class nsIDOMCSSStyleDeclaration;
 class nsIURI;
@@ -421,16 +425,23 @@ public:
   virtual void SetMayHaveFrame(PRBool aMayHaveFrame);
   virtual PRBool MayHaveFrame() const;
 
   virtual PRUint32 GetScriptTypeID() const;
   virtual nsresult SetScriptTypeID(PRUint32 aLang);
 
   virtual void DestroyContent();
   virtual void SaveSubtreeState();
+
+#ifdef MOZ_SMIL
+  virtual nsISMILAttr* GetAnimatedAttr(const nsIAtom* aName, PRBool aIsCSS)
+  {
+    return nsnull;
+  }
+#endif // MOZ_SMIL
 
 #ifdef DEBUG
   virtual void List(FILE* out, PRInt32 aIndent) const
   {
     List(out, aIndent, EmptyCString());
   }
   virtual void DumpContent(FILE* out, PRInt32 aIndent, PRBool aDumpAll) const;
   void List(FILE* out, PRInt32 aIndent, const nsCString& aPrefix) const;
diff --git a/content/base/src/nsGkAtomList.h b/content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h
+++ b/content/base/src/nsGkAtomList.h
@@ -1251,16 +1251,38 @@ GK_ATOM(y, "y")
 GK_ATOM(y, "y")
 GK_ATOM(y1, "y1")
 GK_ATOM(y2, "y2")
 GK_ATOM(yChannelSelector, "yChannelSelector")
 GK_ATOM(z, "z")
 GK_ATOM(zoomAndPan, "zoomAndPan")
 #endif
 
+#ifdef MOZ_SMIL
+GK_ATOM(accumulate, "accumulate")
+GK_ATOM(additive, "additive")
+GK_ATOM(attributeName, "attributeName")
+GK_ATOM(attributeType, "attributeType")
+GK_ATOM(begin, "begin")
+GK_ATOM(by, "by")
+GK_ATOM(calcMode, "calcMode")
+GK_ATOM(dur, "dur")
+GK_ATOM(freeze, "freeze")
+GK_ATOM(keySplines, "keySplines")
+GK_ATOM(keyTimes, "keyTimes")
+GK_ATOM(paced, "paced")
+GK_ATOM(remove, "remove")
+GK_ATOM(repeatCount, "repeatCount")
+GK_ATOM(repeatDur, "repeatDur")
+GK_ATOM(restart, "restart")
+GK_ATOM(spline, "spline")
+GK_ATOM(to, "to")
+GK_ATOM(whennotactive, "whenNotActive")
+#endif
+
 #ifdef MOZ_MATHML
 GK_ATOM(MOZcolumnalign, "-moz-math-columnalign")
 GK_ATOM(MOZcolumnline, "-moz-math-columnline") // different from columnlines_
 GK_ATOM(MOZfontsize, "-moz-math-font-size") // different from fontsize_
 GK_ATOM(MOZfontstyle, "-moz-math-font-style") // different from fontstyle_
 GK_ATOM(MOZrowalign, "-moz-math-rowalign")
 GK_ATOM(MOZrowline, "-moz-math-rowline") // different from rowlines_
 GK_ATOM(abs_, "abs")
diff --git a/content/smil/Makefile.in b/content/smil/Makefile.in
new file mode 100644
--- /dev/null
+++ b/content/smil/Makefile.in
@@ -0,0 +1,48 @@
+# 
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla SMIL module.
+#
+# The Initial Developer of the Original Code is Brian Birtles.
+# Portions created by the Initial Developer are Copyright (C) 2005
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Brian Birtles <birtles@gmail.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+DIRS		= public src
+
+include $(topsrcdir)/config/rules.mk
+
diff --git a/content/smil/public/Makefile.in b/content/smil/public/Makefile.in
new file mode 100644
--- /dev/null
+++ b/content/smil/public/Makefile.in
@@ -0,0 +1,66 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla SMIL module.
+#
+# The Initial Developer of the Original Code is Brian Birtles.
+# Portions created by the Initial Developer are Copyright (C) 2005
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Brian Birtles <birtles@gmail.com>
+#   Daniel Holbert <dholbert@mozilla.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH           = ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= content
+
+EXPORTS		= \
+	  nsISMILAnimationSpec.h \
+	  nsISMILAttr.h \
+	  nsISMILTimeContainer.h \
+	  nsISMILTimedElement.h \
+	  nsISMILType.h \
+	  nsSMILAnimationController.h \
+	  nsSMILAnimationFunction.h \
+	  nsSMILAnimationRegistry.h \
+	  nsSMILEnum.h \
+	  nsSMILKeySpline.h \
+	  nsSMILTimeValue.h \
+	  nsSMILTimedDocumentRoot.h \
+	  nsSMILValue.h \
+	  nsSMILFloatType.h \
+	  nsSMILNullType.h \
+	  $(NULL)
+
+include $(topsrcdir)/config/rules.mk
diff --git a/content/smil/public/nsISMILAnimationSpec.h b/content/smil/public/nsISMILAnimationSpec.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsISMILAnimationSpec.h
@@ -0,0 +1,149 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is
+ * the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Daniel Holbert <dholbert@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILANIMATIONSPEC__
+#define __NS_ISMILANIMATIONSPEC__
+
+class nsISMILAttr;
+class nsIContent;
+class nsAString;
+class nsSMILAnimationFunction;
+
+//////////////////////////////////////////////////////////////////////////////
+// nsISMILAnimationSpec: This is an interface used to request specific
+// information about an animation of one attribute on one element.
+
+class nsISMILAnimationSpec
+{
+public:
+  /*
+   * Returns the SMIL animation function associated with this animation.
+   *
+   * @returns the SMIL animation function associated with this animation.
+   */
+  virtual nsSMILAnimationFunction* GetAnimationFunction() = 0;
+  
+  /*
+   * XXXdholbert: Make this return by reference, like GetTargetElement does.
+   *
+   * If this animation is controlled by a content node (e.g. <animate>), this
+   * method returns that node.  If not (e.g. if this is a CSS transition), this
+   * method simply returns null.
+   * 
+   * This helps nsSMILAnimationFunctions sort themselves by document-position,
+   * when necessary. (see notes in nsSMILAnimationFunction::CompareTo)
+   *
+   * @returns the content node that controls this animation (e.g. <animate>),
+   *          if applicable; otherwise, null.
+   */
+  virtual nsIContent* GetAnimationElement() = 0;
+
+  /*
+   * Returns the target (animated) element, by reference.
+   *
+   * @param aTarget  outparam -- will be set to an addrefed version of 
+   *                 the target element.
+   */
+  virtual void GetTargetElement(nsIContent** aTarget) = 0;
+
+  /*
+   * Returns the name of the target (animated) attribute or property.
+   * 
+   * @param aResult outparam -- will be set to the name of the target
+   *                attribute or property.
+   *
+   * @returns PR_TRUE on success, or PR_FALSE if the animation doesn't have a
+   *          specified target attribute/property.
+   */
+  virtual PRBool GetTargetAttributeNameStr(nsAString& aResult) const = 0;
+
+  /*
+   * Returns the type of the target (animated) attribute or property.
+   * In SVG Animation, the valid return values are "XML", "CSS", and "auto".
+   * 
+   * @param aResult outparam -- will be set to the type of the target
+   *                attribute or property.
+   *
+   * @returns PR_TRUE on success, or PR_FALSE if the animation doesn't specify
+   *          a type for its target attribute/property.
+   */
+  virtual PRBool GetTargetAttributeTypeStr(nsAString& aResult) const = 0;
+
+  /*
+   * Returns a string representation of the animation's "by" attribute.
+   *
+   * @param aResult outparam -- will be set to the animation's "by" attribute.
+   *
+   * @returns PR_TRUE on success, or PR_FALSE if the animation doesn't specify
+   *          a "by" attribute.
+   */
+  virtual PRBool GetByStr(nsAString& aResult) const = 0;
+
+  /*
+   * Returns a string representation of the animation's "from" attribute.
+   *
+   * @param aResult outparam -- will be set to the animation's "from" attribute.
+   *
+   * @returns PR_TRUE on success, or PR_FALSE if the animation doesn't specify
+   *          a "from" attribute.
+   */
+  virtual PRBool GetFromStr(nsAString& aResult) const = 0;
+
+  /*
+   * Returns a string representation of the animation's "to" attribute.
+   *
+   * @param aResult outparam -- will be set to the animation's "to" attribute.
+   *
+   * @returns PR_TRUE on success, or PR_FALSE if the animation doesn't specify
+   *          a "to" attribute.
+   */
+  virtual PRBool GetToStr(nsAString& aResult) const = 0;
+
+  /*
+   * Returns a string representation of the animation's "values" attribute.
+   *
+   * @param aResult outparam -- will be set to the animation's "values"
+   *                attribute.
+   *
+   * @returns PR_TRUE on success, or PR_FALSE if the animation doesn't specify
+   *          a "values" attribute.
+   */
+  virtual PRBool GetValuesStr(nsAString& aResult) const = 0;
+};
+
+#endif // __NS_ISMILANIMATIONSPEC__
diff --git a/content/smil/public/nsISMILAttr.h b/content/smil/public/nsISMILAttr.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsISMILAttr.h
@@ -0,0 +1,97 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILATTR_H__
+#define __NS_ISMILATTR_H__
+
+#include "nsStringFwd.h"
+
+struct nsSMILValue;
+class nsISMILType;
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILAttr: Interfaces for data types that can have a base and
+//              animated value.
+
+class nsISMILAttr
+{
+public:
+  /**
+   * Returns the type of the animated values used in this attribute.
+   *
+   * @param aData   Optional parameter for passing in additional data,
+   *                if needed.
+   * @return An object representing the type of animated value used for
+   * this attribute.
+   */
+  virtual nsISMILType* GetSMILType(const void* aData) = 0;
+
+  /**
+   * Parses the given string to create a new nsSMILValue for this attribute.
+   *
+   * @param aStr    A string defining the new value to be created.
+   * @param aData   Optional parameter for passing in additional data,
+   *                if needed.
+   * @param aValue  Outparam for storing the parsed value.
+   * @return NS_OK on success or an error code if creation failed.
+   */
+  virtual nsresult  ValueFromString(const nsAString& aStr, const void* aData,
+                                    nsSMILValue& aValue) = 0;
+
+  /**
+   * Gets the underlying value of this attribute.
+   *
+   * @param aValue  The value to fill.
+   * @return NS_OK on success or an error code if getting failed.
+   */
+  virtual nsresult  GetBaseValue(nsSMILValue& aValue) = 0;
+
+  /**
+   * Sets the presentation value of this attribute.
+   *
+   * @param aValue  The value to set.
+   * @return NS_OK on success or an error code if setting failed.
+   */
+  virtual nsresult  SetAnimValue(const nsSMILValue& aValue) = 0;
+
+  /**
+   * Virtual destructor, to make sure subclasses can clean themselves up.
+   */
+  virtual ~nsISMILAttr() {};
+};
+
+#endif // __NS_ISMILATTR_H__
diff --git a/content/smil/public/nsISMILTimeContainer.h b/content/smil/public/nsISMILTimeContainer.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsISMILTimeContainer.h
@@ -0,0 +1,129 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILTIMECONTAINER_H__
+#define __NS_ISMILTIMECONTAINER_H__
+
+#include "nsISupports.h"
+#include "nsISMILTimedElement.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILTimeContainer: Time container
+
+// {46b51a7b-d857-45f1-9c7d-4d0d12719238}
+#define NS_ISMILTIMECONTAINER_IID \
+{ 0x46b51a7b, 0xd857, 0x45f1, { 0x9c, 0x7d, 0x4d, 0x0d, 0x12, 0x71, 0x92, 0x38 } }
+
+/**
+ * A SMIL time container.
+ *
+ * When implementing SMIL 2.0 time containers, this interface will most likely
+ * inherit from nsISMILTimedElement, amongst other changes
+ */
+class nsISMILTimeContainer : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILTIMECONTAINER_IID)
+
+  /**
+   * Pause the time container. The time container is initially unpaused.
+   */
+  virtual nsresult  Pause()=0;
+
+  /**
+   * Resume the time container.
+   */
+  virtual nsresult  Resume()=0;
+
+  /**
+   * Returns the paused state of the time container independently of the paused
+   * state of the container's parent.
+   */
+  virtual PRBool    IsPaused()=0;
+
+  /**
+   * Used to inform the time container that its parent has been paused.
+   *
+   * Currently this is necessary so that the time container will accumulate
+   * pause offsets correctly as these are not maintained by the parent.
+   *
+   * Re-using Pause() and maintaining pause counts can lead to unwanted
+   * behaviour when calls to pause and resume are unbalanced.
+   */
+  virtual nsresult  HandleParentPaused()=0;
+
+  /**
+   * Used to inform the time container that its parent has been resumed.
+   */
+  virtual nsresult  HandleParentResumed()=0;
+
+  /**
+   * Reset the time container's internal state. This is particularly useful when
+   * a cached time container is to be re-used.
+   */
+  virtual nsresult  Reset()=0;
+
+  /**
+   * We may later change this to SampleAt and maintain separate host document
+   * and document fragment times. This would allow more advanced time
+   * manipulations for documents with several animated SVG document fragments.
+   */
+  virtual void      Sample()=0;
+
+  /**
+   * Add a timed element to this container. No attempt is made to check if the
+   * timed element is already a child of this container--in that case the timed
+   * element will be added twice and will be sampled twice.
+   *
+   * @param aElement  The element to add.
+   * @return  NS_OK if the element was successfully added or an error otherwise.
+   */
+  virtual nsresult  AddTimedElement(nsISMILTimedElement* aElement)=0;
+
+  /**
+   * Remove the specified timed element from this container.
+   *
+   * @param aElement  The element to remove.
+   * @return NS_OK if the element is found and successfully removed or an error
+   * otherwise.
+   */
+  virtual nsresult  RemoveTimedElement(nsISMILTimedElement* aElement)=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILTimeContainer, NS_ISMILTIMECONTAINER_IID)
+
+#endif // __NS_ISMILTIMECONTAINER_H__
diff --git a/content/smil/public/nsISMILTimedElement.h b/content/smil/public/nsISMILTimedElement.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsISMILTimedElement.h
@@ -0,0 +1,156 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILTIMEDELEMENT_H__
+#define __NS_ISMILTIMEDELEMENT_H__
+
+#include "nsISupports.h"
+
+class nsSMILAnimationFunction;
+class nsSMILTimeValue;
+class nsSMILInstanceTime;
+class nsSMILTimedDocumentRoot;
+class nsIAtom;
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILTimedElement
+
+// {c5f60446-5c1a-4f3b-8ce3-646199ac97f2}
+#define NS_ISMILTIMEDELEMENT_IID \
+{ 0xc5f60446, 0x5c1a, 0x4f3b, { 0x8c, 0xe3, 0x64, 0x61, 0x99, 0xac, 0x97, 0xf2 } }
+
+class nsISMILTimedElement : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILTIMEDELEMENT_IID)
+
+  /**
+   * Adds an instance time object this element's list of instance times.
+   * These instance times are used when creating intervals.
+   *
+   * This method is typically called by an nsSMILTimeValueSpec.
+   *
+   * @param aInstanceTime   The time to add.
+   *
+   * @param aIsBegin        True if the time to be added represents a begin time
+   *                        or false if it represents an end time.
+   */
+  virtual void      AddInstanceTime(const nsSMILInstanceTime &aInstanceTime,
+                                    PRBool aIsBegin)=0;
+
+  /**
+   * Associates a timed document root. This is required for resolving wallclock
+   * values and getting the document time in order to create new instance times.
+   * 
+   * @param aRoot The timed document root to associate.
+   */
+  virtual void      SetDocumentRoot(nsSMILTimedDocumentRoot* aRoot)=0;
+
+  /**
+   * Sets the object that will be called by this timed element each time it is
+   * sampled.
+   *
+   * In Schmitz's model it is possible to associate several time clients with
+   * a timed element but for now we only allow one.
+   *
+   * @param aClient   The time client to associate. Any previous time client
+   *                  will be disassociated and no longer sampled. Setting this
+   *                  to nsnull will simply disassociate the previous client, if
+   *                  any.
+   */
+  virtual void      SetTimeClient(nsSMILAnimationFunction* aClient)=0;
+
+  /**
+   * Samples the object at the given document time. Timing intervals are updated
+   * and if this element is active at the given time the associated time client
+   * will be sampled with the appropriate simple time.
+   *
+   * @param aDocumentTime The document time at which to sample.
+   */
+  virtual void      SampleAt(const PRInt64& aDocumentTime)=0;
+
+  /**
+   * Reset the element's internal state. This is useful for repeating time
+   * containers and so that the timing model can be cached.
+   *
+   * @param aHardReset  Perform a hard reset such that all instance times are
+   *                    cleared. For a soft reset only instance times created by
+   *                    DOM calls and events are cleared. A hard reset is needed
+   *                    in the case of a cached timing model whilst for
+   *                    repeating only a soft reset is required.
+   */
+  virtual void      Reset(PRBool aHardReset = PR_FALSE)=0;
+
+  /**
+   * Attempts to set an attribute on this timed element.
+   *
+   * @param aAttribute  The name of the attribute to set. The namespace of this
+   *                    attribute is not specified as it is checked by the host
+   *                    element. Only attributes in the namespace defined for
+   *                    SMIL attributes in the host language are passed to the
+   *                    timed element.
+   *
+   * @param aValue      The attribute value.
+   *
+   * @param[out] aResult
+   *                    The result of parsing the attribute. May be nsnull. Only
+   *                    used for unit testing.
+   *
+   * @return PR_TRUE if the given attribute is a timing attribute, PR_FALSE
+   * otherwise.
+   */
+  virtual PRBool    SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                            nsresult* aResult = nsnull)=0;
+
+  /**
+   * Attempts to unset an attribute on this timed element.
+   *
+   * @param aAttribute  The name of the attribute to set. As with SetAttr the
+   *                    namespace of the attribute is not specified (see
+   *                    SetAttr).
+   *
+   * @return PR_TRUE if the given attribute is a timing attribute, PR_FALSE
+   * otherwise.
+   */
+  virtual PRBool    UnsetAttr(nsIAtom* aAttribute)=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILTimedElement, NS_ISMILTIMEDELEMENT_IID)
+
+nsISMILTimedElement* NS_NewSMILTimedElement();
+
+#endif // __NS_ISMILTIMEDELEMENT_H__
diff --git a/content/smil/public/nsISMILType.h b/content/smil/public/nsISMILType.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsISMILType.h
@@ -0,0 +1,175 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILTYPE_H__
+#define __NS_ISMILTYPE_H__
+
+#include "nscore.h"
+
+struct nsSMILValue;
+
+class nsISMILType
+{
+public:
+  /**
+   * Sets the value to some identity value such that adding this value with
+   * another has no effect.
+   *
+   * @pre aValue.mType == this
+   */
+  virtual void SetValueIdentity(nsSMILValue& aValue) = 0;
+
+  /**
+   * Destroys any data associated with a value of this type.
+   *
+   * @pre aValue.mType == this
+   */
+  virtual void DestroyValue(nsSMILValue& aValue) = 0;
+
+  /**
+   * Assign this object the value of another. Think of this as the assignment
+   * operator.
+   *
+   * @param   aDest       The left-hand side of the assignment.
+   * @param   aSrc        The right-hand side of the assignment.
+   * @return  NS_OK on success, an error code on failure such as when the
+   *          underlying type of the specified object differs.
+   *
+   * @pre aDest.mType == aSrc.mType == this
+   * @pre aDest's data has been destroyed
+   */
+  virtual nsresult  AssignValue(nsSMILValue& aDest,
+                                const nsSMILValue& aSrc) = 0;
+
+  /**
+   * Adds two values. This method facilitates additive and cumulative animation.
+   *
+   * This method will fail if the underlying datatype is not additive or was not
+   * specified using an additive syntax.
+   *
+   * See SVG 1.1, section 19.2.5. In particular,
+   *
+   * "If a given attribute or property can take values of keywords (which are
+   * not additive) or numeric values (which are additive), then additive
+   * animations are possible if the subsequent animation uses a numeric value
+   * even if the base animation uses a keyword value; however, if the subsequent
+   * animation uses a keyword value, additive animation is not possible."
+   *
+   * Add and Interpolate should be defined in such a way that Add followed by
+   * Interpolate produces the same result as Interpolate followed by Add. If
+   * this is a problem for a particular datatype we will need to change the way
+   * 'by' animation is implemented.
+   *
+   * @param   aDest       The value that will be adjusted.
+   * @param   aSrc        The value to add.
+   * @return  NS_OK on success, an error code on failure.
+   *
+   * @pre aDest.mType == this
+   */
+  virtual nsresult  Add(nsSMILValue& aDest,
+                        const nsSMILValue& aSrc) = 0;
+
+  /**
+   * Calculates the 'distance' between two values. This is the distance used in
+   * paced interpolation.
+   *
+   * @param   aFrom     The start of the interval for which the distance should
+   *                    be calculated.
+   * @param   aTo       The end of the interval for which the distance should be
+   *                    calculated.
+   * @param   aDistance The result of the calculation.
+   * @return  NS_OK on success, or an appropriate error code if there is no
+   *          notion of distance for the underlying data type or the distance
+   *          could not be calculated.
+   *
+   * @pre aFrom.mType == aTo.mType == this
+   */
+  virtual nsresult ComputeDistance(const nsSMILValue& aFrom,
+                                   const nsSMILValue& aTo,
+                                   PRFloat64& aDistance) const = 0;
+
+  /**
+   * Calculates an interpolated value between two values using the specified
+   * proportion.
+   *
+   * @param   aStartVal     The value defining the start of the interval of
+   *                        interpolation.
+   * @param   aEndVal       The value defining the end of the interval of
+   *                        interpolation.
+   * @param   aUnitDistance A number between 0.0 and 1.0 (inclusive) defining
+   *                        the distance of the interpolated value in the
+   *                        interval.
+   * @param   aResult       The interpolated value.
+   * @result  NS_OK on success, NS_ERROR_FAILURE if this data type cannot be
+   *          interpolated or NS_ERROR_OUT_OF_MEMORY if insufficient memory was
+   *          available for storing the result.
+   *
+   * @pre aStartVal.mType == aEndVal.mType == this
+   * @pre Any data in aResult has been destroyed
+   */
+  virtual nsresult  Interpolate(const nsSMILValue& aStartVal,
+                                const nsSMILValue& aEndVal,
+                                float aUnitDistance,
+                                nsSMILValue& aResult) = 0;
+
+  /**
+   * Repeats this value or the specified value a number of times. This method
+   * will fail if the underlying data type is not additive.
+   *
+   * @param   aDest         The value to alter.
+   * @param   aCount        The number of times to repeat the value.
+   * @param   aRepeatValue  The value to repeat. If this parameter is null the
+   *                        destination value will be repeated.
+   * @return  NS_OK on success, an error code on failure.
+   *
+   * @pre aDest.mType == this
+   * @pre aRepeatValue == nsnull || aRepeatValue->mType == this
+   */
+  virtual nsresult  Repeat(nsSMILValue& aDest,
+                           PRUint32 aCount,
+                           const nsSMILValue* aRepeatValue = nsnull) = 0;
+
+
+  /*
+   * Virtual destructor: Nothing to do here, but subclasses
+   * may need it.
+   */
+  virtual ~nsISMILType() {};
+};
+
+#endif // __NS_ISMILTYPE_H__
diff --git a/content/smil/public/nsSMILAnimationController.h b/content/smil/public/nsSMILAnimationController.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsSMILAnimationController.h
@@ -0,0 +1,113 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Daniel Holbert <dholbert@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILANIMATIONCONTROLLER_H__
+#define __NS_SMILANIMATIONCONTROLLER_H__
+
+#include "nsWeakReference.h"
+#include "nsAutoPtr.h"
+#include "nsCOMArray.h"
+#include "nsITimer.h"
+#include "nsIDOMEventListener.h"
+#include "nsTHashtable.h"
+#include "nsHashKeys.h"
+
+class nsISMILTimeContainer;
+class nsIDocument;
+
+class nsSMILAnimationController : public nsIDOMEventListener
+{
+public:
+  nsSMILAnimationController();
+  ~nsSMILAnimationController();
+
+  NS_DECL_ISUPPORTS
+
+  // Methods to pause/resume all animations controlled by this controller.
+  nsresult  Pause();
+  nsresult  Resume();
+  
+  // XXXdholbert No other classes call this method right now -- should it
+  // really be public?
+  nsresult  Reset();
+
+  // Methods for adding/removing time containers
+  nsresult  AddTimeContainer(nsISMILTimeContainer* aContainer);
+  nsresult  RemoveTimeContainer(nsISMILTimeContainer* aContainer);
+
+  // Methods for forcing synchronous samples
+  nsresult  OnForceSample();
+  void      FireForceSampleEvent();
+
+  // nsIDOMEventListener
+  NS_IMETHOD        HandleEvent(nsIDOMEvent *event);
+
+protected:
+  friend nsSMILAnimationController*
+  NS_NewSMILAnimationController(nsIDocument* doc);
+
+  // nsISMILAnimationController
+  nsresult          Init(nsIDocument* doc);
+  nsresult          StartTimer();
+  nsresult          StopTimer();
+  void              SampleChildren();
+  static void       Notify(nsITimer* aTimer, void* aClosure);
+
+  static const PRUint32         kTimerInterval;
+  nsCOMPtr<nsITimer>            mTimer;
+
+  // XXXdholbert Why does this need weak references?
+  nsCOMArray<nsIWeakReference>  mTimeContainers;
+  PRUint16                      mPauseCount;
+  PRBool                        mHidden;
+  PRBool                        mIsForceSampleEventQueued;
+  
+  // Store raw ptr to mDocument.  It owns the controller, so controller
+  // shouldn't outlive it
+  nsIDocument                   *mDocument;
+
+  // Contains compositors used in our last sample.  We keep this around
+  // so we can detect when an element/attribute used to be animated,
+  // but isn't anymore for some reason. (e.g. if its <animate> element is 
+  // removed or retargeted)
+  nsAutoPtr<nsTHashtable<nsHashableHashKey> > mLastCompositorTable;
+};
+
+nsSMILAnimationController* NS_NewSMILAnimationController(nsIDocument *doc);
+
+#endif // __NS_SMILANIMATIONCONTROLLER_H__
diff --git a/content/smil/public/nsSMILAnimationFunction.h b/content/smil/public/nsSMILAnimationFunction.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsSMILAnimationFunction.h
@@ -0,0 +1,369 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Daniel Holbert <dholbert@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILANIMATIONFUNCTION_H__
+#define __NS_SMILANIMATIONFUNCTION_H__
+
+#include "nsISMILAttr.h"
+#include "nsGkAtoms.h"
+#include "nsIContent.h"
+#include "nsString.h"
+#include "nsSMILTimeValue.h"
+#include "nsSMILEnum.h"
+#include "nsSMILKeySpline.h"
+#include "nsSMILValue.h"
+#include "nsAutoPtr.h"
+#include "nsISMILAnimationSpec.h"
+
+//----------------------------------------------------------------------
+// nsSMILAnimationFunction
+
+class nsSMILAnimationFunction
+{
+public:
+  nsSMILAnimationFunction(nsISMILAnimationSpec* aAnimationSpec);
+
+  /*
+   * Re-parses the attributes "from", "to", "by", and "values", if needed.
+   * (These attributes are only parsed at sample-time, because they may be
+   * parsed differently depending on the target element & attribute, and
+   * the target is only resolved at sample time.)
+   *
+   * @param aSMILAttr This animation's target attribute.  Used here for
+   *                  doing attribute-specific parsing of from/to/by/values.
+   */
+  void             ReparseDirtyAttrs(nsISMILAttr& aSMILAttr);
+
+  /*
+   * Updates the generic data pointer that's passed to nsISMILAttr whenever
+   * we parse a SMIL value.
+   * (e.g. used for updating transform type for <animateTransform> elements)
+   *
+   * @param aData  The new value for the generic data pointer.
+   */
+  void             SetSMILAttrData(const void* aData);
+
+  /*
+   * Sets animation-specific attributes (or marks them dirty, in the case
+   * of from/to/by/values).
+   *
+   * @param aAttribute The attribute being set
+   * @param aValue     The updated value of the attribute.
+   * @param aResult    Outparam used for reporting parse errors. Will be set
+   *                   to NS_OK if everything succeeds.
+   * @returns PR_TRUE if aAttribute is a recognized animation-related
+   *          attribute; PR_FALSE otherwise.
+   */
+  PRBool           SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                           nsresult* aResult = nsnull);
+
+  /*
+   * Unsets the given attribute.
+   *
+   * @returns PR_TRUE if aAttribute is a recognized animation-related
+   *          attribute; PR_FALSE otherwise.
+   */
+  PRBool           UnsetAttr(nsIAtom* aAttribute);
+
+  /**
+   * Indicate a new sample has occurred.
+   *
+   * @param aSimpleTime The sample time for this timed element expressed in
+   *                    simple time.
+   * @param aSimpleDuration The simple duration for this timed element.
+   * @param aRepeatIteration  The repeat iteration for this sample. The first
+   *                          iteration has a value of 0.
+   */
+  void             SampleAt(const PRInt64& aSimpleTime,
+                            const nsSMILTimeValue& aSimpleDuration,
+                            const PRUint32& aRepeatIteration);
+
+  /**
+   * Indicate to sample using the last value defined for the animation function.
+   * This value is not normally sampled due to the end-point exclusive timing
+   * model but only occurs when the fill mode is "freeze" and the active
+   * duration is an even multiple of the simple duration.
+   *
+   * @param aRepeatIteration  The repeat iteration for this sample. The first
+   *                          iteration has a value of 0.
+   */
+  void             SampleLastValue(const PRUint32& aRepeatIteration);
+
+  /**
+   * Indicate that this animation is now active. This is used to instruct the
+   * animation function that it should now add its result to the animation
+   * sandwich. The begin time is also provided for proper prioritization of
+   * animation functions, and for this reason, this method must be called
+   * before either of the Sample methods.
+   *
+   * @param aBeginTime The begin time for the newly active interval.
+   */
+  void             Activate(const PRInt64& aBeginTime);
+
+  /**
+   * Indicate that this animation is no longer active. This is used to instruct
+   * the animation function that it should no longer add its result to the
+   * animation sandwich.
+   *
+   * @param aIsFrozen True if this animation should continue to contribute to
+   *                  the animation sandwich using the most recent sample
+   *                  parameters.
+   */
+  void             Inactivate(PRBool aIsFrozen);
+
+  /**
+   * Combines the result of this animation function for the last sample with the
+   * specified value.
+   *
+   * @param aResult The value to compose with.
+   */
+  void             ComposeResult(nsSMILValue &aResult);
+
+  /**
+   * Returns the relative priority of this animation to another. The priority is
+   * used for determining the position of the animation in the animation
+   * sandwich -- higher priority animations are applied on top of lower
+   * priority animations.
+   *
+   * @return  -1 if this animation has lower priority or 1 if this animation has
+   *          higher priority
+   *
+   * This method should never return any other value, including 0.
+   */
+  PRInt8           CompareTo(const nsSMILAnimationFunction *other) const;
+
+  /*
+   * The following methods are provided so that the compositor can optimize its
+   * operations by only composing those animation that will affect the final
+   * result.
+   */
+ 
+  /**
+   * Indicates if the animation is currently active. Inactive animations will
+   * not contribute to the composed result.
+   *
+   * @return  True if the animation active, false otherwise.
+   */
+  PRBool           IsActive() const;
+
+  /**
+   * Indicates if this animation will replace the passed in result rather than
+   * adding to it. Animations that replace the underlying value may be called
+   * without first calling lower priority animations.
+   *
+   * @return  True if the animation will replace, false if it will add or
+   *          otherwise build on the passed in value.
+   */
+  PRBool           WillReplace() const;
+
+  /**
+   * Indicates if the parameters for this animation have changed since the last
+   * time it was composited. This allows rendering to be performed only when
+   * necessary, particularly when no animations are active.
+   *
+   * @return  True if the animation parameters have changed, false otherwise.
+   */
+  PRBool           HasChanged() const;
+
+  // Comparator utility class, used for sorting nsSMILAnimationFunctions
+  class Comparator {
+    public:
+      PRBool Equals(const nsSMILAnimationFunction* aElem1,
+                    const nsSMILAnimationFunction* aElem2) const {
+        return (aElem1->CompareTo(aElem2) == 0);
+      }
+      PRBool LessThan(const nsSMILAnimationFunction* aElem1,
+                      const nsSMILAnimationFunction* aElem2) const {
+        return (aElem1->CompareTo(aElem2) < 0);
+      }
+  };
+
+protected:
+  // Implementation helpers
+  nsSMILAnimationFunction*     NS_NewSMILAnimationFunction();
+
+  // Used for sorting nsSMILAnimationFunctions
+  const PRInt64&  GetBeginTime() const;
+
+  // Property setters
+  nsresult  SetAccumulate(const nsAString& aAccumulate);
+  nsresult  SetAdditive(const nsAString& aAdditive);
+  nsresult  SetCalcMode(const nsAString& aCalcMode);
+  nsresult  SetKeyTimes(const nsAString& aKeyTimes);
+  nsresult  SetKeySplines(const nsAString& aKeySplines);
+
+  // Property un-setters
+  void      UnsetAdditive();
+  void      UnsetCalcMode();
+  void      UnsetAccumulate();
+  void      UnsetKeyTimes();
+  void      UnsetKeySplines();
+
+  // Property re-parser for by/from/to/values attributes
+  void ReparseSMILValue(nsISMILAttr& aSMILAttr, PRUint16 aBitfieldIndex);
+
+  // Property un-setter for by/from/to/values attributes
+  void UnsetSMILValue(PRUint16 aBitfieldIndex);
+
+  // Helpers
+  nsresult  InterpolateResult(nsSMILValue& aResult,
+                              nsSMILValue& aBaseValue);
+  nsresult  AccumulateResult(nsSMILValue& aResult);
+
+  nsresult  ComputePacedPosition(const double& aSimpleProgress,
+                                 double& aIntervalProgress,
+                                 nsSMILValue& aFrom, nsSMILValue& aTo);
+  nsresult  ComputePacedTotalDistance();
+
+  void      ScaleSimpleProgress(PRFloat64& aProgress);
+  void      ScaleIntervalProgress(PRFloat64& aProgress, PRUint32 aIntervalIndex,
+                                  PRUint32 aNumIntervals);
+  void      UpdateValuesArray();
+  PRBool    IsToAnimation() const;
+  PRBool    IsAdditive() const;
+  void      CheckKeyTimes();
+  void      CheckKeySplines();
+  void      UpdateSMILType(const nsISMILType* aType);
+  void      MarkSMILValuesDirty();
+
+
+  // Members
+  // -------
+
+  // The type of attribute that this nsSMILAnimationFunction animates.
+  const nsISMILType*            mSMILType;
+
+  // Animation function values.
+  nsSMILValue                   mFrom;
+  nsSMILValue                   mTo;
+  nsSMILValue                   mBy;
+  nsTArray<nsSMILValue>         mValues;
+
+  enum nsSMILCalcMode
+  {
+    calc_linear,
+    calc_discrete,
+    calc_paced,
+    calc_spline
+  };
+  static nsSMILEnumMapping      sCalcModeMap[];
+  nsSMILEnum                    mCalcMode;
+
+  static nsSMILEnumMapping      sAdditiveMap[];
+  nsSMILEnum                    mAdditive;
+
+  static nsSMILEnumMapping      sAccumulateMap[];
+  nsSMILEnum                    mAccumulate;
+
+  nsTArray<PRFloat64>           mKeyTimes;
+  nsTArray<nsSMILKeySpline>     mKeySplines;
+
+  PRPackedBool                  mIsActive;
+  PRPackedBool                  mIsFrozen;
+
+  // These are the parameters provided by the previous sample. Currently we
+  // perform lazy calculation. That is, we only calculate the result if and when
+  // instructed by the compositor. This allows us to apply the result directly
+  // to the animation value and allows the compositor to filter out functions
+  // that it determines will not contribute to the final result.
+  PRInt64                       mSimpleTime;
+  nsSMILTimeValue               mSimpleDuration;
+  PRUint32                      mRepeatIteration;
+  PRPackedBool                  mLastValue;
+  PRPackedBool                  mHasChanged;
+
+  PRInt64                       mBeginTime;
+  
+  // The SMILAnimationSpec for this object.  Used for updating
+  // mFrom / mBy / mTo / mValues, and for sorting nsSMILAnimationFunctions
+  // based on e.g. document position.
+  nsISMILAnimationSpec*      mAnimationSpec;
+
+  // Keep track of which attributes have been set. This is mostly necessary for
+  // correct error handling but it also used to distinguish between when the
+  // mValues array is filled from a 'values' spec or from the values of
+  // 'from', 'to' and 'by'. Currently it is not used for all attributes.
+  PRUint16                      mSetFlags;
+
+  // Keep track of which attributes (of 'from', 'to', 'by', and 'values') need
+  // to be re-parsed and updated.  This is necessary because these attributes
+  // could be changed at any time via the DOM, but we can't parse the new
+  // values until sample-time, when we create a temporary nsISMILAttr to do
+  // the (attribute-type-specific) parsing for us.
+  PRUint16                      mDirtyFlags;
+
+  // Which attributes have been set but have had errors. This is not used for
+  // all attributes but only those which have specified error behaviour
+  // associated with them.
+  PRUint16                      mErrorFlags;
+
+  // This is for the very specific case where we have a 'to' animation that is
+  // frozen part way through the simple duration and there are other active
+  // lower-priority animations targetting the same attribute. In this case
+  // SMILANIM 3.3.6 says:
+  //
+  //   The value for F(t) when a to-animation is frozen (at the end of the
+  //   simple duration) is just the to value. If a to-animation is frozen
+  //   anywhere within the simple duration (e.g., using a repeatCount of "2.5"),
+  //   the value for F(t) when the animation is frozen is the value computed for
+  //   the end of the active duration. Even if other, lower priority animations
+  //   are active while a to-animation is frozen, the value for F(t) does not
+  //   change.
+  //
+  // To implement this properly we'd need to force a resample of all the lower
+  // priority animations at the active end of this animation--something which
+  // would introduce unwanted coupling between the timing and animation model.
+  // Instead we just save the value calculated when this animation is frozen (in
+  // which case this animation will be sampled at the active end and the lower
+  // priority animations should be sampled at a time pretty close to this,
+  // provided we have a reasonable frame rate and we aren't seeking).
+  //
+  // @see
+  // http://www.w3.org/TR/2001/REC-smil-animation-20010904/#FromToByAndAdditive
+  nsSMILValue                   mFrozenValue;
+
+  // Total distance to be travelled over a simple duration for
+  // calcMode="paced" animation.  This is cached here, as an optimization.
+  PRFloat64                     mPacedTotalDistance;
+  
+  // Misc. data pointer used to pass extra information to nsISMILAttr, 
+  // e.g. when re-parsing a nsSMILValue
+  const void*                   mSMILAttrData;
+};
+
+#endif // __NS_SMILANIMATIONFUNCTION_H__
diff --git a/content/smil/public/nsSMILAnimationRegistry.h b/content/smil/public/nsSMILAnimationRegistry.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsSMILAnimationRegistry.h
@@ -0,0 +1,93 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILANIMATIONREGISTRY_H__
+#define __NS_SMILANIMATIONREGISTRY_H__
+
+#include "nsTArray.h"
+#include "nsAutoPtr.h"
+#include "nsSMILAnimationController.h"
+#include "nsSMILTimedDocumentRoot.h"
+
+class nsISMILAttr;
+class nsISMILTimedElement;
+class nsSMILAnimationFunction;
+
+// XXXdholbert Possibly remove this class, and have SVG elements
+// talk directly to the TimedDocumentRoot instead? (This is mostly
+// just a wrapper for TimedDocumentRoot, at this point)
+class nsSMILAnimationRegistry
+{
+public:
+  ~nsSMILAnimationRegistry();
+
+  // nsISMILAnimationRegistry
+  nsresult  SetController(nsSMILAnimationController* aController);
+  nsresult  Start();
+  void      Pause();
+  void      Unpause();
+  PRBool    IsPaused();
+  float     GetCurrentTime();
+  nsresult  SetCurrentTime(float aSeconds);
+  nsresult  RegisterTimedElement(nsISMILTimedElement *aElement);
+  nsresult  UnregisterTimedElement(nsISMILTimedElement *aElement);
+
+protected:
+  friend nsSMILAnimationRegistry* NS_NewSMILAnimationRegistry();
+  // Member data is allocated in Init() instead of in constructor
+  // so we can return an error code if we run out of memory
+  nsresult          Init();
+
+  nsRefPtr<nsSMILTimedDocumentRoot>     mTimedDocumentRoot;
+  nsSMILAnimationController             *mController; // owned by nsPresContext
+  PRBool                                mStarted;
+
+private:
+  // This class should only be created by the factory method
+  nsSMILAnimationRegistry() : mController(nsnull), mStarted(PR_FALSE) {}
+
+  // Pass by value and assignment should not be used
+  nsSMILAnimationRegistry(const nsSMILAnimationRegistry& other);
+  nsSMILAnimationRegistry& operator=(const nsSMILAnimationRegistry& right);
+};
+
+/**
+ * Creates a new animation registry object.
+ */
+nsSMILAnimationRegistry* NS_NewSMILAnimationRegistry();
+
+#endif // __NS_SMILANIMATIONREGISTRY_H__
diff --git a/content/smil/public/nsSMILEnum.h b/content/smil/public/nsSMILEnum.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsSMILEnum.h
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Tim Rowley <tor@cs.brown.edu> (original author)
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILENUM_H__
+#define __NS_SMILENUM_H__
+
+#include "nsIAtom.h"
+
+struct nsSMILEnumMapping 
+{
+    nsIAtom **key;
+    PRUint16 val;
+};
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILEnum class
+
+class nsSMILEnum
+{
+public:
+  nsSMILEnum(PRUint16 value, nsSMILEnumMapping *mapping);
+
+  PRUint16  GetIntegerValue() const { return mValue; }
+  void      SetIntegerValue(const PRUint16 &aValue) { mValue = aValue; }
+  nsresult  SetStringValue(const nsAString &aValue);
+
+protected:
+  PRUint16          mValue;
+  nsSMILEnumMapping *mMapping;
+};
+
+#endif //__NS_SMILENUM_H__
diff --git a/content/smil/public/nsSMILFloatType.h b/content/smil/public/nsSMILFloatType.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsSMILFloatType.h
@@ -0,0 +1,69 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILFLOATTYPE_H__
+#define __NS_SMILFLOATTYPE_H__
+
+#include "nsISMILType.h"
+
+class nsSMILFloatType : public nsISMILType
+{
+public:
+  virtual void        SetValueIdentity(nsSMILValue& aValue);
+  virtual void        DestroyValue(nsSMILValue&) {}
+  virtual nsresult    AssignValue(nsSMILValue& aDest,
+                                  const nsSMILValue& aSrc);
+  virtual nsresult    Add(nsSMILValue& aDest, const nsSMILValue& aSrc);
+  virtual nsresult    ComputeDistance(const nsSMILValue& aFrom,
+                                      const nsSMILValue& aTo,
+                                      PRFloat64& aDistance) const;
+  virtual nsresult    Interpolate(const nsSMILValue& aStartVal,
+                                  const nsSMILValue& aEndVal,
+                                         float aUnitDistance,
+                                         nsSMILValue& aResult);
+  virtual nsresult    Repeat(nsSMILValue& aDest,
+                             PRUint32 aCount,
+                             const nsSMILValue* aRepeatValue);
+
+  static nsSMILFloatType sSingleton;
+
+private:
+  nsSMILFloatType() {}
+};
+
+#endif // __NS_SMILFLOATTYPE_H__
diff --git a/content/smil/public/nsSMILKeySpline.h b/content/smil/public/nsSMILKeySpline.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsSMILKeySpline.h
@@ -0,0 +1,96 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILKEYSPLINE_H__
+#define __NS_SMILKEYSPLINE_H__
+
+#include "prtypes.h"
+
+/**
+ * Utility class to provide scaling defined in a keySplines element.
+ */
+class nsSMILKeySpline
+{
+public:
+  nsSMILKeySpline(const PRFloat64& aX1, const PRFloat64& aY1,
+                  const PRFloat64& aX2, const PRFloat64& aY2);
+
+  PRFloat64 GetSplineValue(const PRFloat64& x) const;
+
+private:
+  void
+  CalcSampleValues();
+
+  static PRFloat64
+  CalcBezier(const PRFloat64& t, const PRFloat64& a1, const PRFloat64& a2);
+
+  static PRFloat64
+  GetSlope(const PRFloat64& t, const PRFloat64& a1, const PRFloat64& a2);
+
+  PRFloat64
+  GetTForX(const PRFloat64& x) const;
+
+  static PRFloat64
+  A(const PRFloat64& a1, const PRFloat64& a2)
+  {
+    return 1.0 - 3.0 * a2 + 3.0 * a1;
+  }
+  
+  static PRFloat64
+  B(const PRFloat64& a1, const PRFloat64& a2)
+  {
+    return 3.0 * a2 - 6.0 * a1;
+  }
+
+  static PRFloat64
+  C(const PRFloat64& a1)
+  {
+    return 3.0 * a1;
+  }
+
+  const PRFloat64         mX1;
+  const PRFloat64         mY1;
+  const PRFloat64         mX2;
+  const PRFloat64         mY2;
+
+  enum { kSplineTableSize = 11 };
+  PRFloat64               mSampleValues[kSplineTableSize];
+
+  static const PRFloat64  kSampleStepSize;
+};
+
+#endif // __NS_SMILKEYSPLINE_H__
diff --git a/content/smil/public/nsSMILNullType.h b/content/smil/public/nsSMILNullType.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsSMILNullType.h
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILNULLTYPE_H__
+#define __NS_SMILNULLTYPE_H__
+
+#include "nsISMILType.h"
+
+class nsSMILNullType : public nsISMILType
+{
+public:
+  virtual void SetValueIdentity(nsSMILValue&) {}
+  virtual void DestroyValue(nsSMILValue&) {}
+  virtual nsresult AssignValue(nsSMILValue&, const nsSMILValue&);
+
+  // The remaining methods should never be called, so although they're very
+  // simple they don't need to be inline.
+  virtual nsresult Add(nsSMILValue&, const nsSMILValue&);
+  virtual nsresult ComputeDistance(const nsSMILValue&,
+                                   const nsSMILValue&,
+                                   PRFloat64& aDistance) const;
+  virtual nsresult Interpolate(const nsSMILValue&,
+                               const nsSMILValue&,
+                               float,
+                               nsSMILValue&);
+  virtual nsresult Repeat(nsSMILValue&,
+                          PRUint32,
+                          const nsSMILValue*);
+
+  static nsSMILNullType sSingleton;
+};
+
+#endif // __NS_SMILNULLTYPE_H__
diff --git a/content/smil/public/nsSMILTimeValue.h b/content/smil/public/nsSMILTimeValue.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsSMILTimeValue.h
@@ -0,0 +1,127 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILTIMEVALUE_H__
+#define __NS_SMILTIMEVALUE_H__
+
+#include "prtypes.h"
+#include "prlong.h"
+
+/**
+ * nsSMILTimeValue class
+ *
+ * Objects of this class may be in one of three orthogonal states:
+ *
+ * 1) The time is resolved and has a millisecond value
+ * 2) The time is indefinite
+ * 3) The time in unresolved
+ *
+ * There is considerable chance for confusion with regards to the indefinite
+ * state. Is it resolved? We adopt the convention that it is NOT resolved (but
+ * nor is it unresolved). This simplifies implementation as you can then write:
+ *
+ * if (time.IsResolved())
+ *    x = time.GetMillis()
+ *
+ * instead of:
+ *
+ * if (time.IsResolved() && !time.IsIndefinite())
+ *    x = time.GetMillis()
+ *
+ * Testing if a time is unresolved becomes more complicated but this is tested
+ * much less often.
+ *
+ * In summary:
+ *
+ * State         |  GetMillis         |  IsResolved        |  IsIndefinite
+ * --------------+--------------------+--------------------+-------------------
+ * Resolved      |  The millisecond   |  PR_TRUE           |  PR_FALSE
+ *               |  time              |                    |
+ * --------------+--------------------+--------------------+-------------------
+ * Indefinite    |  LL_MaxInt         |  PR_FALSE          |  PR_TRUE
+ * --------------+--------------------+--------------------+-------------------
+ * Unresolved    |  LL_MaxInt         |  PR_FALSE          |  PR_FALSE
+ *
+ */
+
+class nsSMILTimeValue
+{
+public:
+  // Creates an unresolved time value
+  nsSMILTimeValue();
+
+  PRBool            IsIndefinite() const;
+  void              SetIndefinite();
+
+  PRBool            IsResolved() const;
+  void              SetUnresolved();
+
+  const PRInt64&    GetMillis() const;
+  void              SetMillis(const PRInt64& aMillis);
+
+  PRInt8            CompareTo(const nsSMILTimeValue& aOther) const;
+
+private:
+  PRInt8            CmpLL(const PRInt64& a, const PRInt64& b) const;
+
+  static PRInt64    mUnresolvedSeconds;
+
+  PRInt64           mMilliseconds;
+  PRBool            mIndefinite;
+  PRBool            mResolved;
+};
+
+inline PRBool
+nsSMILTimeValue::IsIndefinite() const
+{
+  return mIndefinite;
+}
+
+inline PRBool
+nsSMILTimeValue::IsResolved() const
+{
+  return mResolved;
+}
+
+// A signed comparison of two signed 64-bit integers
+inline PRInt8
+nsSMILTimeValue::CmpLL(const PRInt64& a, const PRInt64& b) const
+{
+  return (LL_EQ(a, b)) ? 0 : (LL_CMP(a, >, b)) ? 1 : -1;
+}
+
+#endif // __NS_SMILTIMEVALUE_H__
diff --git a/content/smil/public/nsSMILTimedDocumentRoot.h b/content/smil/public/nsSMILTimedDocumentRoot.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsSMILTimedDocumentRoot.h
@@ -0,0 +1,94 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILTIMEDDOCUMENTROOT_H__
+#define __NS_SMILTIMEDDOCUMENTROOT_H__
+
+#include "nsISupports.h"
+#include "nsISMILTimeContainer.h"
+#include "nsSMILAnimationRegistry.h"
+#include "nsWeakReference.h"
+#include "nsCOMArray.h"
+
+class nsISMILTimeValueSpec;
+class nsISMILTimedElement;
+class nsSMILTimeValue;
+class nsSMILAnimationRegistry;
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILTimedDocumentRoot: Timed document root
+
+class nsSMILTimedDocumentRoot : public nsISMILTimeContainer,
+                                public nsSupportsWeakReference
+{
+public:
+  nsSMILTimedDocumentRoot(nsSMILAnimationRegistry* registry);
+
+  NS_DECL_ISUPPORTS
+
+  PRInt64           GetDocumentTime();
+  nsSMILTimeValue   WallclockToDocumentTime(nsISMILTimeValueSpec*
+                                              aWallclockSpec);
+  nsresult          SeekToTime(PRInt64 aSeekTo);
+
+  // nsISMILTimeContainer
+  virtual PRBool    IsPaused();
+  virtual nsresult  Pause();
+  virtual nsresult  Resume();
+  virtual nsresult  HandleParentPaused();
+  virtual nsresult  HandleParentResumed();
+  virtual nsresult  Reset();
+  virtual void      Sample();
+  virtual nsresult  AddTimedElement(nsISMILTimedElement* aElement);
+  virtual nsresult  RemoveTimedElement(nsISMILTimedElement* aElement);
+
+protected:
+  void              SampleChildren(PRInt64 aDocumentTime);
+  void              ResetChildren(PRBool aHardReset);
+
+  PRInt64                       mStartTime;
+  PRInt64                       mAccumulatedOffset;
+  nsCOMArray<nsIWeakReference>  mTimedElements;
+  nsSMILAnimationRegistry*      mAnimationRegistry;
+  PRBool                        mParentPaused;
+  PRBool                        mContainerPaused;
+  PRInt64                       mPauseStart;
+  // Should generally update whenever mPauseStart is updated
+  PRBool                        mNeedsSampleDuringPause;
+};
+
+#endif // __NS_SMILTIMEDDOCUMENTROOT_H__
diff --git a/content/smil/public/nsSMILValue.h b/content/smil/public/nsSMILValue.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsSMILValue.h
@@ -0,0 +1,116 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILVALUE_H__
+#define __NS_SMILVALUE_H__
+
+#include "nsISMILType.h"
+#include "nsSMILNullType.h"
+
+struct nsSMILValue
+{
+  nsSMILValue(nsISMILType* aType) : mType(aType)
+  {
+    mType->SetValueIdentity(*this);
+  }
+  nsSMILValue() : mType(&nsSMILNullType::sSingleton) {}
+
+  ~nsSMILValue()
+  {
+    mType->DestroyValue(*this);
+  }
+
+  nsSMILValue(const nsSMILValue& aVal) : mType( aVal.mType)
+  {
+    mType->AssignValue(*this, aVal);
+  }
+
+  // XXX Add a 'Swap' method to nsISMILType. In many cases whilst compositing
+  // we're using the assignment operator when a swap would do and would save the
+  // unnecessary allocations and deallocations that this requires for types that
+  // use dynamically allocated memory (mU.mPtr)
+  const nsSMILValue& operator=(const nsSMILValue& aVal)
+  {
+    if (&aVal == this)
+      return *this;
+
+    mType->DestroyValue(*this);
+    mType = aVal.mType;
+    mType->AssignValue(*this, aVal);
+    return *this;
+  }
+
+  PRBool IsNull() const
+  {
+    return (mType == &nsSMILNullType::sSingleton);
+  }
+
+  nsresult Add(const nsSMILValue& aSrc)
+  {
+    return mType->Add(*this, aSrc);
+  }
+  
+  nsresult ComputeDistance(const nsSMILValue& aTo,
+                           PRFloat64& aDistance)
+  {
+    return mType->ComputeDistance(*this, aTo, aDistance);
+  }
+
+  nsresult Interpolate(const nsSMILValue& aEndVal,
+                       float aUnitDistance,
+                       nsSMILValue& aResult)
+  {
+    aResult.mType->DestroyValue(aResult);
+    return mType->Interpolate(*this, aEndVal, aUnitDistance, aResult);
+  }
+
+  nsresult Repeat(PRUint32 aCount,
+                  const nsSMILValue* aRepeatValue = nsnull)
+  {
+    return mType->Repeat(*this, aCount, aRepeatValue);
+  }
+
+  union {
+    PRInt64 mInt;
+    double mDouble;
+    void* mPtr;
+  } mU;
+  nsISMILType* mType;
+};
+
+#endif  // __NS_SMILVALUE_H__
diff --git a/content/smil/src/Makefile.in b/content/smil/src/Makefile.in
new file mode 100644
--- /dev/null
+++ b/content/smil/src/Makefile.in
@@ -0,0 +1,89 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla SMIL module.
+#
+# The Initial Developer of the Original Code is Brian Birtles.
+# Portions created by the Initial Developer are Copyright (C) 2005
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Brian Birtles <birtles@gmail.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= content
+LIBRARY_NAME	= gkconsmil_s
+LIBXUL_LIBRARY	= 1
+
+REQUIRES	= xpcom \
+		  string \
+		  layout \
+		  content \
+		  unicharutil \
+		  widget \
+		  dom \
+		  js \
+		  pref \
+		  $(NULL)
+
+CPPSRCS		= \
+	nsSMILAnimationController.cpp \
+	nsSMILAnimationFunction.cpp \
+	nsSMILAnimationRegistry.cpp \
+	nsSMILCompositor.cpp \
+	nsSMILEnum.cpp \
+	nsSMILFloatType.cpp \
+	nsSMILInstanceTime.cpp \
+	nsSMILInterval.cpp \
+	nsSMILKeySpline.cpp \
+	nsSMILNullType.cpp \
+	nsSMILParserUtils.cpp \
+	nsSMILTimedDocumentRoot.cpp \
+	nsSMILTimedElement.cpp \
+	nsSMILTimeValue.cpp \
+	nsSMILTimeValueSpec.cpp \
+		$(NULL)
+
+include $(topsrcdir)/config/config.mk
+
+# we don't want the shared lib, but we want to force the creation of a static lib.
+FORCE_STATIC_LIB = 1
+
+ifdef ENABLE_TESTS
+TOOL_DIRS		+= test
+endif
+
+include $(topsrcdir)/config/rules.mk
+
+DEFINES += -D_IMPL_NS_LAYOUT
diff --git a/content/smil/src/nsSMILAnimationController.cpp b/content/smil/src/nsSMILAnimationController.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILAnimationController.cpp
@@ -0,0 +1,528 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Daniel Holbert <dholbert@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILAnimationController.h"
+#include "nsSMILCompositor.h"
+#include "nsComponentManagerUtils.h"
+#include "nsITimer.h"
+#include "nsISMILTimeContainer.h"
+#include "nsISimpleEnumerator.h"
+#include "nsArrayEnumerator.h"
+#include "nsIContent.h"
+#include "nsIDocument.h"
+#include "nsIDOMEventTarget.h"
+#include "nsIDOMSVGSVGElement.h"
+#include "nsIDOMSVGElement.h"
+#include "nsIScriptGlobalObject.h"
+#include "nsIDOMEventListener.h"
+#include "nsIDOMEvent.h"
+#include "nsThreadUtils.h" // for nsRunnable
+#include "nsGkAtoms.h"
+#include "nsTHashtable.h"
+#include "nsHashKeys.h"
+#include "nsISMILAnimationSpec.h"
+#include "nsIDOMSVGAnimationElement.h"
+
+#define CSS_TYPE_LABEL NS_LITERAL_STRING("CSS")
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILAnimationController implementation
+
+// In my testing the minimum needed for smooth animation is 36 frames per
+// second which seems like a lot (Flash traditionally uses 14fps).
+//
+// Redrawing is synchronous. This is deliberate so that later we can tune the
+// timer based on how long the callback takes. To achieve 36fps we'd need 28ms
+// between frames. For now we set the timer interval to be a little less than
+// this (to allow for the render itself) and then let performance decay as the
+// image gets more complicated and render times increase.
+//
+const PRUint32 nsSMILAnimationController::kTimerInterval = 22;
+
+//----------------------------------------------------------------------
+// ctors, dtors, factory methods
+
+nsSMILAnimationController::nsSMILAnimationController()
+  : mPauseCount(0),
+    mHidden(PR_FALSE),
+    mIsForceSampleEventQueued(PR_FALSE),
+    mDocument(nsnull)
+{
+}
+
+nsSMILAnimationController::~nsSMILAnimationController()
+{
+  if (mTimer) {
+    mTimer->Cancel();
+    mTimer = nsnull;
+  }
+}
+
+nsSMILAnimationController* NS_NewSMILAnimationController(nsIDocument* doc)
+{
+  nsSMILAnimationController* animationController = 
+    new nsSMILAnimationController();
+  NS_ENSURE_TRUE(animationController, nsnull);
+
+  nsresult rv = animationController->Init(doc);
+  if (NS_FAILED(rv)) {
+    delete animationController;
+    animationController = nsnull;
+  }
+
+  return animationController;
+}
+
+//----------------------------------------------------------------------
+// nsISupports methods:
+
+NS_IMPL_ISUPPORTS1(nsSMILAnimationController,
+                   nsIDOMEventListener)
+
+//----------------------------------------------------------------------
+// Timer callback
+
+// We use the function callback rather than implementing nsITimerCallback to
+// avoid circular ownership between the timer and this object.
+
+/*static*/ void
+nsSMILAnimationController::Notify(nsITimer* timer, void* aClosure)
+{
+  nsSMILAnimationController* controller = (nsSMILAnimationController*)aClosure;
+
+  NS_ASSERTION(controller->mTimer == timer,
+               "nsSMILAnimationController::Notify called with incorrect timer");
+
+  controller->SampleChildren();
+}
+
+//----------------------------------------------------------------------
+// nsSMILAnimationController methods:
+
+nsresult
+nsSMILAnimationController::Pause()
+{
+  if (++mPauseCount > 1)
+    return NS_OK;
+
+  nsresult rv = NS_OK;
+
+  rv = StopTimer();
+
+  // We must tell the children too so they can keep their accumulated offsets
+  // accurate
+  PRUint32 i = mTimeContainers.Count();
+  while (i > 0) {
+    --i;
+    nsCOMPtr<nsISMILTimeContainer> 
+      container( do_QueryReferent(mTimeContainers[i]) );
+
+    // This mess means that we continue processing all the children even if an
+    // error occurs but that we report the first error encountered
+    if (container) {
+      if (NS_SUCCEEDED(rv))
+        rv = container->HandleParentPaused();
+      else
+        container->HandleParentPaused();
+    } else {
+      mTimeContainers.RemoveObjectAt(i);
+    }
+  }
+
+  return rv;
+}
+
+nsresult
+nsSMILAnimationController::Resume()
+{
+  nsresult rv = NS_OK;
+
+  NS_ASSERTION(mPauseCount > 0, "Unbalanced calls to Pause() and Resume()");
+  if (mPauseCount == 0)
+    return NS_ERROR_FAILURE;
+
+  if (--mPauseCount > 0)
+    return NS_OK;
+
+  // We must tell the children so they can keep their accumulated offsets
+  // accurate
+  PRUint32 i = mTimeContainers.Count();
+  while (i > 0) {
+    --i;
+    nsCOMPtr<nsISMILTimeContainer> 
+      container( do_QueryReferent(mTimeContainers[i]) );
+
+    if (container) {
+      if (NS_SUCCEEDED(rv))
+        rv = container->HandleParentResumed();
+      else
+        container->HandleParentResumed();
+    } else {
+      mTimeContainers.RemoveObjectAt(i);
+    }
+  }
+
+  if (mTimeContainers.Count() > 0)
+    StartTimer();
+
+  return rv;
+}
+
+nsresult
+nsSMILAnimationController::Reset()
+{
+  nsresult rv = NS_OK;
+
+  PRUint32 i = mTimeContainers.Count();
+  while (i > 0) {
+    --i;
+    nsCOMPtr<nsISMILTimeContainer> 
+      container( do_QueryReferent(mTimeContainers[i]) );
+
+    if (container) {
+      if (NS_SUCCEEDED(rv))
+        rv = container->Reset();
+      else
+        container->Reset();
+    } else {
+      mTimeContainers.RemoveObjectAt(i);
+    }
+  }
+
+  return rv;
+}
+
+nsresult
+nsSMILAnimationController::AddTimeContainer(nsISMILTimeContainer* aContainer)
+{
+  NS_ENSURE_ARG_POINTER(aContainer);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aContainer, &rv)) );
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  rv = (mTimeContainers.AppendObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (mPauseCount > 0) {
+    aContainer->HandleParentPaused();
+  } else if (mTimeContainers.Count() == 1) {
+    rv = StartTimer();
+  }
+
+  return rv;
+}
+
+nsresult
+nsSMILAnimationController::RemoveTimeContainer(nsISMILTimeContainer* aContainer)
+{
+  NS_ENSURE_ARG_POINTER(aContainer);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aContainer, &rv)) );
+
+  if (NS_SUCCEEDED(rv))
+    rv = (mTimeContainers.RemoveObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+
+  if (NS_SUCCEEDED(rv) && mPauseCount == 0 && mTimeContainers.Count() == 0)
+    rv = StopTimer();
+
+  return rv;
+}
+
+nsresult
+nsSMILAnimationController::OnForceSample()
+{
+  // Make sure this was a queued call
+  NS_ENSURE_TRUE(mIsForceSampleEventQueued, NS_ERROR_FAILURE);
+
+  nsresult rv = NS_OK;
+  if (mPauseCount == 0) {
+    // Stop timer-controlled samples first, to avoid race conditions.
+    rv = StopTimer();
+    if (NS_SUCCEEDED(rv)) {
+      // StartTimer does a synchronous sample before it starts the timer.
+      // This is the sample that we're "forcing" here.
+      StartTimer();
+    }
+  }
+  mIsForceSampleEventQueued = PR_FALSE;
+  return rv;
+}
+
+// Force Sample Event
+// (Based on nsPrintCompletionEvent)
+class nsForceSampleEvent : public nsRunnable {
+public:
+  nsForceSampleEvent(nsSMILAnimationController *animationController)
+    : mAnimationController(animationController) {
+    NS_ASSERTION(mAnimationController, "mAnimationController is null.");
+  }
+
+  NS_IMETHOD Run() {
+    if (mAnimationController) {
+      return mAnimationController->OnForceSample();
+    }
+    return NS_OK;
+  }
+
+private:
+  nsRefPtr<nsSMILAnimationController> mAnimationController;
+};
+
+void
+nsSMILAnimationController::FireForceSampleEvent()
+{
+  if (!mIsForceSampleEventQueued) {
+    nsCOMPtr<nsIRunnable> event = new nsForceSampleEvent(this);
+    if (NS_FAILED(NS_DispatchToCurrentThread(event))) {
+      NS_WARNING("failed to dispatch force sample event");
+    } else {
+      mIsForceSampleEventQueued = PR_TRUE;
+    }
+  }
+}
+
+//----------------------------------------------------------------------
+// nsIDOMPageTransitionListener methods
+
+nsresult
+nsSMILAnimationController::HandleEvent(nsIDOMEvent *aEvent)
+{
+  nsAutoString eventType;
+  aEvent->GetType(eventType);
+
+  if (eventType.EqualsLiteral("pageshow")) {
+    if (!mHidden)
+      return NS_OK;
+
+    mHidden = PR_FALSE;
+
+    if (NS_SUCCEEDED(Reset())) {
+      Resume();
+    }
+  } else if (eventType.EqualsLiteral("pagehide")) {
+    mHidden = PR_TRUE;
+    Pause();
+  }
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers:
+
+nsresult
+nsSMILAnimationController::Init(nsIDocument *doc)
+{
+  NS_ENSURE_ARG_POINTER(doc);
+
+  mTimer = do_CreateInstance("@mozilla.org/timer;1");
+
+  // Keep track of document, so we can traverse its set of animation elements
+  mDocument = doc;
+
+  // Register as listener to support bfcache
+  nsCOMPtr<nsIScriptGlobalObject> global(doc->GetScriptGlobalObject());
+  if (global) {
+    nsCOMPtr<nsIDOMEventTarget> receiver( do_QueryInterface(global) );
+    if (receiver) {
+      receiver->AddEventListener(NS_LITERAL_STRING("pageshow"), this,
+                                 PR_FALSE);
+      receiver->AddEventListener(NS_LITERAL_STRING("pagehide"), this,
+                                 PR_FALSE);
+    }
+  }
+
+  return (mTimer) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+nsresult
+nsSMILAnimationController::StartTimer()
+{
+  NS_ENSURE_TRUE(mTimer, NS_ERROR_FAILURE);
+  NS_ASSERTION(mPauseCount == 0, "Starting timer but controller is paused.");
+
+  // Run the first sample manually
+  SampleChildren();
+
+  // 
+  // XXX Make this self-tuning. Sounds like control theory to me and not
+  // something I'm familiar with.
+  //
+  return mTimer->InitWithFuncCallback(nsSMILAnimationController::Notify,
+                                      this,
+                                      kTimerInterval,
+                                      nsITimer::TYPE_REPEATING_SLACK);
+}
+
+nsresult
+nsSMILAnimationController::StopTimer()
+{
+  NS_ENSURE_TRUE(mTimer, NS_ERROR_FAILURE);
+
+  return mTimer->Cancel();
+}
+
+// Callback method, to be called on each nsSMILAnimationSpec in the Document's
+// hash-set.  This sorts them by targeted element & attribute.
+PR_STATIC_CALLBACK(PLDHashOperator)
+AddAnimationToCompositorTable(nsVoidPtrHashKey *aKey, void *aData)
+{
+  // STEP 0: Cast args (key & data) to correct types.
+  // The animation spec (specifies a particular animation on an elem & attr)
+  nsISMILAnimationSpec *animSpec =
+    static_cast<nsISMILAnimationSpec*>(const_cast<void*>(aKey->GetKey()));
+  NS_ASSERTION(animSpec, "Null content pointer in animation spec set");
+
+  // a table that maps compositor --> list of animation functions.
+  nsTHashtable<nsHashableHashKey> *compositorTable =
+    static_cast<nsTHashtable<nsHashableHashKey>*>(aData);
+  NS_ASSERTION(compositorTable, "Null data pointer in animation element set.");
+
+  // STEP 1: Look up target (animated) element
+  nsCOMPtr<nsIContent> targetElem;
+  animSpec->GetTargetElement(getter_AddRefs(targetElem));
+
+  if (!targetElem) {
+    // Animation has no target. That's fine; it won't do anything.
+    return PL_DHASH_NEXT;
+  }
+
+  // STEP 2: Look up target (animated) attribute
+  nsAutoString attributeName;
+  nsAutoString attributeType;
+  // XXXdholbert As mentioned in SVG11 spec section 19.2.5, attributeName may
+  // have an XMLNS prefix to indicate the XML namespace.  Need to parse/remove
+  // that somewhere.
+  animSpec->GetTargetAttributeNameStr(attributeName);
+  animSpec->GetTargetAttributeTypeStr(attributeType);
+
+  // XXXdholbert The variable "PRBool isCSS" actually should be an enum, which
+  // could be {css, xml, auto} {more...?}
+  PRBool isCSS = PR_FALSE;
+  if (attributeType.Equals(CSS_TYPE_LABEL)) {
+    isCSS = PR_TRUE;
+  }
+
+  // STEP 3: Create compositor for elem & attrib, & insert it into table
+  // (if it's not already there)
+  nsSMILCompositor *probe = new nsSMILCompositor(targetElem, attributeName, isCSS);
+  nsHashableHashKey* result = compositorTable->PutEntry(probe);
+  nsSMILCompositor* entry = static_cast<nsSMILCompositor*>(result->GetKey());
+  if (entry != probe) {
+    // The key was already in the hashtable.
+    delete probe;
+  } // else, probe is now stored in the hashtable.
+    //  XXXdholbert make sure we delete it later on.
+
+  // STEP 4: Add this animationSpec's animation function to the
+  // compositor's list of animation functions
+  entry->AddAnimationFunction(animSpec->GetAnimationFunction());
+
+  return PL_DHASH_NEXT;
+}
+
+void
+nsSMILAnimationController::SampleChildren()
+{
+  if (mPauseCount > 0) {
+    // We're paused. Do nothing.
+    return;
+  }
+
+  // STEP 1: Set up the sample
+  // Note: this doesn't create/modify any nsSMILValues at all -- it just uses
+  // the current time to figure out which elements are active and what simple
+  // time they'll be sampled at.
+  nsCOMPtr<nsISimpleEnumerator> enumerator;
+  nsresult rv =
+    NS_NewArrayEnumerator(getter_AddRefs(enumerator), mTimeContainers);
+  NS_ENSURE_SUCCESS(rv,);
+
+  PRBool more = PR_FALSE;
+  while (NS_SUCCEEDED(enumerator->HasMoreElements(&more)) && more) {
+    nsCOMPtr<nsIWeakReference> weakRef;
+    if (NS_FAILED(enumerator->GetNext(getter_AddRefs(weakRef))) || !weakRef)
+      break;
+
+    nsCOMPtr<nsISMILTimeContainer> container(do_QueryReferent(weakRef));
+    if (container)
+      container->Sample();
+  }
+
+  // STEP 2: Create & populate a table of compositors for this sample, using
+  // the document's list of animation elements.
+  // Note: The compositor table needs to be allocated on the heap so we can
+  // easily store it until the next sample.  This lets us find out which
+  // elements were animated in sample 'n-1' but not in sample 'n' (& hence
+  // need to have their animation effects removed in sample 'n'.)
+  nsAutoPtr<nsTHashtable<nsHashableHashKey> > 
+    currentCompositorTable(new nsTHashtable<nsHashableHashKey>());
+  currentCompositorTable->Init(0);
+  rv = mDocument->EnumerateAnimationSpecs(AddAnimationToCompositorTable,
+                                          currentCompositorTable);
+  if (NS_FAILED(rv)) {
+    // XXXdholbert what types of errors might we encounter here, & what's the
+    // right fallback behavior?
+    NS_WARNING("EnumerateAnimationSpecs failed");
+  }
+
+  // STEP 3: Remove animation effects from any no-longer-animated elems/attrs
+  if (mLastCompositorTable) {
+    // XXX Remove animation effects from no-longer-animated elements
+    //  * For each compositor in current sample's hash table:
+    //    - Remove entry from *prev sample's* hash table
+    //  * For any entries still remaining in prev sample's hash table:
+    //    - Remove animation from that entry's attribute.
+    //      (For nsSVGLength2, set anim val = base val.  For CSS attribs,
+    //      just clear the relevant chunk of OverrideStyle)
+  }
+
+  // STEP 4: Do composition & animation on currently-animated elements/attrs.
+  rv = nsSMILCompositor::ComposeHashtableEntries(currentCompositorTable);
+  if (NS_FAILED(rv)) {
+    // XXXdholbert what types of errors might we encounter here, & what's the
+    // right fallback behavior?
+    NS_WARNING("ComposeHashtableEntries/EnumerateAnimationSpecs failed");
+  }
+
+  mLastCompositorTable = currentCompositorTable;
+}
diff --git a/content/smil/src/nsSMILAnimationFunction.cpp b/content/smil/src/nsSMILAnimationFunction.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILAnimationFunction.cpp
@@ -0,0 +1,1119 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *   Daniel Holbert <dholbert@cs.stanford.edu>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILAnimationFunction.h"
+#include "nsISMILAttr.h"
+#include "nsSMILParserUtils.h"
+#include "nsSMILNullType.h"
+#include "nsGkAtoms.h"
+#include "nsCOMPtr.h"
+#include "nsCOMArray.h"
+#include "nsIContent.h"
+#include "nsAutoPtr.h"
+#include "nsTArray.h"
+#include "nsContentUtils.h"
+#include "nsReadableUtils.h"
+#include "nsString.h"
+#include <math.h>
+
+#define ALLOW_BAD_KEYTIMES
+
+//----------------------------------------------------------------------
+// Static members
+
+nsSMILEnumMapping nsSMILAnimationFunction::sCalcModeMap[] = {
+      {&nsGkAtoms::linear, calc_linear},
+      {&nsGkAtoms::discrete, calc_discrete},
+      {&nsGkAtoms::paced, calc_paced},
+      {&nsGkAtoms::spline, calc_spline},
+      {nsnull, 0}
+};
+
+nsSMILEnumMapping nsSMILAnimationFunction::sAdditiveMap[] = {
+      {&nsGkAtoms::replace, PR_FALSE},
+      {&nsGkAtoms::sum, PR_TRUE},
+      {nsnull, 0}
+};
+
+nsSMILEnumMapping nsSMILAnimationFunction::sAccumulateMap[] = {
+      {&nsGkAtoms::none, PR_FALSE},
+      {&nsGkAtoms::sum, PR_TRUE},
+      {nsnull, 0}
+};
+
+// Bits for attributes that need special parsing depending on animated type
+#define BF_BY          0
+#define BF_FROM        1
+#define BF_TO          2
+#define BF_VALUES      3
+// Bits for attributes that are parsed the same regardless of animated type
+#define BF_ACCUMULATE  4
+#define BF_ADDITIVE    5
+#define BF_CALC_MODE   6
+#define BF_KEY_TIMES   7
+#define BF_KEY_SPLINES 8
+
+// Any negative number should be fine as a sentinel here,
+// because valid distances are non-negative.
+#define PACED_TOTAL_DISTANCE_NOT_SET (-1)
+
+// Based on GET/SET_BOOLBIT in nsHTMLInputElement.cpp
+#define GET_FLAG(bitfield, field) (((bitfield) & (0x01 << (field))) \
+                                     ? PR_TRUE : PR_FALSE)
+#define SET_FLAG(bitfield, field, b) ((b) \
+                                     ? ((bitfield) |=  (0x01 << (field))) \
+                                     : ((bitfield) &= ~(0x01 << (field))))
+
+// Used to screen out the flags in a bitfield that relate to the attributes
+// that need special parsing depending on the animated type.
+#define SPECIALLY_PARSED_ATTR_MASK (( 0x01 << BF_BY) |   \
+                                    ( 0x01 << BF_FROM) | \
+                                    ( 0x01 << BF_TO) |   \
+                                    ( 0x01 << BF_VALUES))
+//----------------------------------------------------------------------
+// Constructors etc.
+
+nsSMILAnimationFunction::nsSMILAnimationFunction(nsISMILAnimationSpec *aAnimationSpec)
+  : mSMILType(&nsSMILNullType::sSingleton),
+    mCalcMode(calc_linear, sCalcModeMap),
+    mAdditive(PR_FALSE, sAdditiveMap),
+    mAccumulate(PR_FALSE, sAccumulateMap),
+    mIsActive(PR_FALSE),
+    mIsFrozen(PR_FALSE),
+    mSimpleTime(-1),
+    mRepeatIteration(0),
+    mLastValue(PR_FALSE),
+    mHasChanged(PR_TRUE),
+    mBeginTime(LL_MinInt()),
+    mAnimationSpec(aAnimationSpec),
+    mSetFlags(0),
+    mDirtyFlags(0),
+    mErrorFlags(0),
+    mPacedTotalDistance(PACED_TOTAL_DISTANCE_NOT_SET),
+    mSMILAttrData(nsnull)
+{
+}
+
+void
+nsSMILAnimationFunction::SetSMILAttrData(const void* aData)
+{
+  if (mSMILAttrData != aData) {
+    mSMILAttrData = aData;
+    // This change presumably means we need to re-parse our nsSMILValues
+    MarkSMILValuesDirty();
+  }
+}
+
+void
+nsSMILAnimationFunction::ReparseDirtyAttrs(nsISMILAttr& aSMILAttr)
+{
+  const nsISMILType *newSMILType = aSMILAttr.GetSMILType(mSMILAttrData);
+
+  NS_ASSERTION(mDirtyFlags ==
+               (mDirtyFlags & SPECIALLY_PARSED_ATTR_MASK),
+               "mDirtyFlags should only have bits set for "
+               "specially-parsed attributes");
+  
+  UpdateSMILType(newSMILType);
+  // XXXdholbert this could probably be cleaner by iterating across
+  // the list of attrs in SPECIALLY_PARSED_ATTR_MASK
+  if (GET_FLAG(mDirtyFlags, BF_BY)) {
+    ReparseSMILValue(aSMILAttr, BF_BY);
+  }
+  if (GET_FLAG(mDirtyFlags, BF_FROM)) {
+    ReparseSMILValue(aSMILAttr, BF_FROM);
+  }
+  if (GET_FLAG(mDirtyFlags, BF_TO)) {
+    ReparseSMILValue(aSMILAttr, BF_TO);
+  }
+  if (GET_FLAG(mDirtyFlags, BF_VALUES)) {
+    ReparseSMILValue(aSMILAttr, BF_VALUES);
+  }
+
+  NS_ASSERTION(mDirtyFlags == 0,
+               "mDirtyFlags should be clear after "
+               "we've reparsed all the attrs that need reparsing");
+
+  // XXXdholbert Should only do these if we've actually changed, right?
+  mHasChanged = PR_TRUE;
+  UpdateValuesArray();
+}
+
+// Helper function to re-parse a particular SMIL value. (mBy/mFrom/mTo)
+void
+nsSMILAnimationFunction::ReparseSMILValue(nsISMILAttr& aSMILAttr,
+                                          PRUint16     aBitfieldIndex)
+{
+  PRBool gotParseError = PR_FALSE;
+  PRBool gotString = PR_FALSE;
+  nsAutoString resultStr;
+  nsSMILValue *valToSet;
+
+  // Request string for requested value
+  switch(aBitfieldIndex) {
+    case BF_BY:
+      gotString = mAnimationSpec->GetByStr(resultStr);
+      valToSet = &mBy;
+      break;
+    case BF_FROM:
+      gotString = mAnimationSpec->GetFromStr(resultStr);
+      valToSet = &mFrom;
+      break;
+    case BF_TO:
+      gotString = mAnimationSpec->GetToStr(resultStr);
+      valToSet = &mTo;
+      break;
+    case BF_VALUES:
+      gotString = mAnimationSpec->GetValuesStr(resultStr);
+      break;
+    default:
+      NS_NOTREACHED("ReparseSMILValue got an unrecognized bitfield index!");
+      break;
+  }
+
+  // Parse the string (if we got one)
+  if (gotString) {
+    nsresult rv;
+    switch(aBitfieldIndex) {
+      case BF_BY:
+      case BF_FROM:
+      case BF_TO:
+        rv = aSMILAttr.ValueFromString(resultStr, mSMILAttrData, *valToSet);
+        break;
+      case BF_VALUES:
+        rv = nsSMILParserUtils::GetValues(resultStr, mSMILAttrData,
+                                          aSMILAttr, mValues);
+        break;
+      default:
+        NS_NOTREACHED("ReparseSMILValue got an unrecognized bitfield index!");
+        break;
+    }
+    gotParseError = NS_FAILED(rv);
+  }
+  
+  // Update bitfields
+  SET_FLAG(mDirtyFlags, aBitfieldIndex, PR_FALSE);
+  SET_FLAG(mErrorFlags, aBitfieldIndex, gotParseError);
+  SET_FLAG(mSetFlags, aBitfieldIndex, gotString && !gotParseError);
+}
+
+                                       
+PRBool
+nsSMILAnimationFunction::SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                                 nsresult* aResult)
+{
+  PRBool foundMatch = PR_TRUE;
+
+  nsresult result = NS_OK;
+
+  // The attributes 'by', 'from', 'to', and 'values' may be parsed differently
+  // depending on the element & attribute we're animating.  So instead of
+  // parsing & setting them now, we'll flag them as needing an update at the
+  // next animation sample.
+  if (aAttribute == nsGkAtoms::by) {
+    SET_FLAG(mDirtyFlags, BF_BY, PR_TRUE);
+  } else if (aAttribute == nsGkAtoms::from) {
+    SET_FLAG(mDirtyFlags, BF_FROM, PR_TRUE);
+  } else if (aAttribute == nsGkAtoms::to) {
+    SET_FLAG(mDirtyFlags, BF_TO, PR_TRUE);
+  } else if (aAttribute == nsGkAtoms::values) {
+    SET_FLAG(mDirtyFlags, BF_VALUES, PR_TRUE);
+  } else if (aAttribute == nsGkAtoms::accumulate) {
+    result = SetAccumulate(aValue);
+  } else if (aAttribute == nsGkAtoms::additive) {
+    result = SetAdditive(aValue);
+  } else if (aAttribute == nsGkAtoms::calcMode) {
+    result = SetCalcMode(aValue);
+  } else if (aAttribute == nsGkAtoms::keyTimes) {
+    result = SetKeyTimes(aValue);
+  } else if (aAttribute == nsGkAtoms::keySplines) {
+    result = SetKeySplines(aValue);
+  } else {
+    foundMatch = PR_FALSE;
+  }
+
+  if (foundMatch && aResult)
+    *aResult = result;
+
+  return foundMatch;
+}
+
+PRBool
+nsSMILAnimationFunction::UnsetAttr(nsIAtom* aAttribute)
+{
+  PRBool foundMatch = PR_TRUE;
+
+  if (aAttribute == nsGkAtoms::by) {
+    UnsetSMILValue(BF_BY);
+  } else if (aAttribute == nsGkAtoms::from) {
+    UnsetSMILValue(BF_FROM);
+  } else if (aAttribute == nsGkAtoms::to) {
+    UnsetSMILValue(BF_TO);
+  } else if (aAttribute == nsGkAtoms::values) {
+    UnsetSMILValue(BF_VALUES);
+  } else if (aAttribute == nsGkAtoms::accumulate) {
+    UnsetAccumulate();
+  } else if (aAttribute == nsGkAtoms::additive) {
+    UnsetAdditive();
+  } else if (aAttribute == nsGkAtoms::calcMode) {
+    UnsetCalcMode();
+  } else if (aAttribute == nsGkAtoms::keyTimes) {
+    UnsetKeyTimes();
+  } else if (aAttribute == nsGkAtoms::keySplines) {
+    UnsetKeySplines();
+  } else {
+    foundMatch = PR_FALSE;
+  }
+
+  return foundMatch;
+}
+
+void
+nsSMILAnimationFunction::SampleAt(const PRInt64& aSimpleTime,
+                                  const nsSMILTimeValue& aSimpleDuration,
+                                  const PRUint32& aRepeatIteration)
+{
+  if (mHasChanged || mLastValue || LL_NE(mSimpleTime, aSimpleTime) || 
+      mSimpleDuration.CompareTo(aSimpleDuration) || 
+      mRepeatIteration != aRepeatIteration)
+    mHasChanged = PR_TRUE;
+
+  mSimpleTime       = aSimpleTime;
+  mSimpleDuration   = aSimpleDuration;
+  mRepeatIteration  = aRepeatIteration;
+  mLastValue        = PR_FALSE;
+}
+
+void
+nsSMILAnimationFunction::SampleLastValue(const PRUint32& aRepeatIteration)
+{
+ if (mHasChanged || !mLastValue || mRepeatIteration != aRepeatIteration)
+    mHasChanged = PR_TRUE;
+
+  mRepeatIteration  = aRepeatIteration;
+  mLastValue        = PR_TRUE;
+}
+
+void
+nsSMILAnimationFunction::Activate(const PRInt64& aBeginTime)
+{
+  mBeginTime = aBeginTime;
+  mIsActive = PR_TRUE;
+  mIsFrozen = PR_FALSE;
+  mFrozenValue = nsSMILValue();
+}
+
+void
+nsSMILAnimationFunction::Inactivate(PRBool aIsFrozen)
+{
+  mIsActive = PR_FALSE;
+  mIsFrozen = aIsFrozen;
+  mFrozenValue = nsSMILValue();
+  mHasChanged = PR_TRUE;
+}
+
+void
+nsSMILAnimationFunction::ComposeResult(nsSMILValue &aResult)
+{
+  mHasChanged = PR_FALSE;
+
+  // This checks if mValues is empty so we don't need to check it again later
+  if (!IsActive())
+    return;
+
+  NS_ASSERTION(mSMILType, "mSMILType should never be null; it should instead "
+               " be cleared to &nsSMILNullType::sSingleton.");
+  // XXXdholbert probably don't need to check for null mSMILType here -- it
+  // should never be null, as indicated in the assertion above.
+  if (!mSMILType || mSMILType == &nsSMILNullType::sSingleton)
+    return;
+
+  // If this interval is active, we must have a nonnegative
+  // mSimpleTime and a resolved or indefinite mSimpleDuration.
+  // (Otherwise, we're probably just frozen.)
+  if (mIsActive) {
+    NS_ENSURE_TRUE(mSimpleTime >= 0,);
+    NS_ENSURE_TRUE(mSimpleDuration.IsResolved() || 
+                   mSimpleDuration.IsIndefinite(),);
+  }
+
+  nsSMILValue result(aResult.mType);
+  
+  if (mSimpleDuration.IsIndefinite() ||
+      (GET_FLAG(mSetFlags, BF_VALUES) && mValues.Length() == 1)) {
+
+    // Indefinite duration or only one value set: Always set the first value
+    result = mValues[0];
+
+  } else if (mLastValue) {
+
+    // Sampling last value
+    nsSMILValue last(mValues[mValues.Length() - 1]);
+    if (mAccumulate.GetIntegerValue() && mRepeatIteration > 0) {
+      if (NS_FAILED(result.Repeat(mRepeatIteration, &last)))
+        result = last;
+    } else {
+      result = last;
+    }
+
+  } else if (!mFrozenValue.IsNull() && !mHasChanged) {
+
+    // Frozen to animation
+    result = mFrozenValue;
+
+  } else {
+
+    // Interpolation
+    NS_ENSURE_SUCCESS(InterpolateResult(result, aResult),);
+    NS_ENSURE_SUCCESS(AccumulateResult(result),);
+
+    if (IsToAnimation() && mIsFrozen) {
+      mFrozenValue = result;
+    }
+  }
+
+  // If additive animation isn't required or isn't supported, set the value.
+  if (!IsAdditive() || NS_FAILED(aResult.Add(result)))
+    aResult = result;
+}
+
+PRInt8
+nsSMILAnimationFunction::CompareTo(const nsSMILAnimationFunction* other) const
+{
+  // Inactive animations sort first
+  if (!IsActive() && other->IsActive())
+    return -1;
+
+  if (IsActive() && !other->IsActive())
+    return 1;
+
+  // Sort based on begin time
+  if (LL_NE(mBeginTime, other->GetBeginTime()))
+    return LL_CMP(mBeginTime, >, other->GetBeginTime()) ? 1 : -1;
+
+  // XXX When syncbase timing is implemented, we next need to sort based on
+  // dependencies
+
+  // XXXdholbert: We should replace this next chunk with a
+  // nsSMILAnimationSpec-specific comparison method.
+  // (e.g. For 2 SVG animations, we'd just compare their elements'
+  // document positions.  For 1 SVG animation and 1 CSS transition, we'd
+  // say SMIL always overrides the transition. For 2 CSS transitions, we'd
+  // complain because that shouldn't happen, right?)
+
+  // SVG animations that appear later in the document sort after those earlier
+  // in the document
+  // Note: need a const_cast here, because PositionIsBefore doesn't take const
+  // arguments.
+  // XXXdholbert clean up const usage here
+  nsIContent *myContent = mAnimationSpec->GetAnimationElement();
+  nsIContent *otherContent = const_cast<nsSMILAnimationFunction*>(other)->mAnimationSpec->GetAnimationElement();
+
+  NS_ASSERTION(myContent != nsnull || otherContent != nsnull,
+               "We shouldn't have two non-SVG animations affecting the same "
+               "element and attribute...");
+  NS_ASSERTION(myContent != otherContent,
+               "Two animations cannot have the same animation content element!");
+
+  if (myContent && otherContent) {
+    return (nsContentUtils::PositionIsBefore(myContent, otherContent))
+      ? -1 : 1;
+  } else {
+    // Either myContent or otheContent is null (a non-SVG animation).
+    // By convention, let's say non-SVG animations sort before SVG Animations.
+    // NOTE: If they both happen to be non-SVG (shouldn't happen, per assertion
+    // above), we'll have non-detministic behavior, but  at least we don't explode.
+    return otherContent ? -1 : 1;
+  }
+}
+
+const PRInt64&
+nsSMILAnimationFunction::GetBeginTime() const
+{
+  return mBeginTime;
+}
+
+PRBool
+nsSMILAnimationFunction::IsActive() const
+{
+  //
+  // Even if an animation should be active, if its attributes are set
+  // incorrectly, it will have no effect and should be considered by the
+  // compositor to be inactive.
+  //
+  // Frozen animations should be considered active for the purposes of
+  // compositing.
+  //
+  return ((mIsActive || mIsFrozen) && mValues.Length() > 0 && mErrorFlags == 0);
+}
+
+
+PRBool
+nsSMILAnimationFunction::WillReplace() const
+{
+  /*
+   * In IsAdditive() we don't consider to-animation to be additive as it is
+   * a special case that is dealt with differently in the compositing method but
+   * here we return false for to animation as it builds on the underlying value
+   * unless its a frozen to animation.
+   */
+  return !(IsAdditive() || IsToAnimation()) || 
+    (IsToAnimation() && mIsFrozen && !mHasChanged);
+}
+
+PRBool
+nsSMILAnimationFunction::HasChanged() const
+{
+  return mHasChanged;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+nsresult
+nsSMILAnimationFunction::InterpolateResult(nsSMILValue& aResult,
+                                           nsSMILValue& aBaseValue)
+{
+  nsresult        rv = NS_OK;
+  double          fTime;
+  double          fDur;
+  double          simpleProgress;   // normalized progress through simple dur
+  double          intervalProgress; // normalized progress between adjacent vals
+  nsSMILValue     from;
+  nsSMILValue     to;
+  const PRInt64&  dur  = mSimpleDuration.GetMillis();
+
+  // Sanity Checks
+  NS_ASSERTION(mSimpleTime >= 0.0f, "Simple time should not be negative...");
+  NS_ASSERTION(dur  >= 0.0f, "Simple duration should not be negative...");
+
+  if (LL_CMP(mSimpleTime, >=, dur) || !LL_GE_ZERO(mSimpleTime)) {
+    NS_ERROR("Animation sampled outside interval.");
+    return NS_ERROR_FAILURE;
+  }
+
+  if ((!IsToAnimation() && mValues.Length() < 2) || 
+      (IsToAnimation()  && mValues.Length() != 1)) {
+    NS_ERROR("Unexpected number of values.");
+    return NS_ERROR_FAILURE;
+  }
+  // End Sanity Checks
+
+  LL_L2D(fTime, mSimpleTime);
+  LL_L2D(fDur, dur);
+  simpleProgress = (fDur > 0.0) ? fTime / fDur : 0.0;
+
+#ifdef ALLOW_BAD_KEYTIMES
+  if (GET_FLAG(mSetFlags, BF_KEY_TIMES)) {
+    PRFloat64 first = mKeyTimes[0];
+    if (first > 0.0 && simpleProgress < first) {
+      if (!IsToAnimation())
+        aResult = mValues[0];
+      return rv;
+    }
+    PRFloat64 last = mKeyTimes[mKeyTimes.Length() - 1];
+    if (last < 1.0 && simpleProgress >= last) {
+      if (IsToAnimation())
+        aResult = mValues[0];
+      else
+        aResult = mValues[mValues.Length() - 1];
+      return rv;
+    }
+  }
+#endif
+
+  ScaleSimpleProgress(simpleProgress);
+
+  // Handle calc_discrete separately, because it's simple.
+  if (mCalcMode.GetIntegerValue() == calc_discrete) {
+    PRUint32 index = IsToAnimation() ? 0 :
+      (PRUint32) floor(simpleProgress * (mValues.Length()));
+    aResult = mValues[index];
+    return NS_OK;
+  } 
+
+  // XXXdholbert -- maybe from and to should be pointers or references,
+  // so we don't have to do memory copying during the "from = [nsSMILValue]"
+  // assignment? (esp. for complex types with storage in mU.mPtr)
+  if (IsToAnimation()) {
+    // Note: Don't need to do any special-casing for calc_paced here,
+    // because To-Animation doesn't use a values list, by definition.
+    from = aBaseValue;
+    to = mValues[0];
+    intervalProgress = simpleProgress;
+    ScaleIntervalProgress(intervalProgress, 0, 1);
+  } else {
+    if (mCalcMode.GetIntegerValue() == calc_paced) { 
+      ComputePacedPosition(simpleProgress, 
+                           intervalProgress, from, to);
+    } else { // mCalcMode == calc_linear or mCalcMode == calc_spline
+      PRUint32 index = (PRUint32) floor(simpleProgress * (mValues.Length() - 1));
+      from = mValues[index];
+      to = mValues[index + 1];
+      intervalProgress = simpleProgress * (mValues.Length() - 1) - index;
+      ScaleIntervalProgress(intervalProgress, index, mValues.Length() - 1);
+    }
+  }
+
+  return from.Interpolate(to, static_cast<float>(intervalProgress), aResult);
+}
+
+nsresult
+nsSMILAnimationFunction::AccumulateResult(nsSMILValue& aResult)
+{
+  if (!IsToAnimation() && mAccumulate.GetIntegerValue() && mRepeatIteration)
+  {
+    nsSMILValue repeatValue(aResult.mType);
+    nsSMILValue lastValue = mValues[mValues.Length() - 1];
+
+    // If the target attribute doesn't support addition, Repeat will fail and we
+    // leave aResult untouched.
+    if (NS_SUCCEEDED(repeatValue.Repeat(mRepeatIteration - 1,
+                                        &lastValue)))
+      aResult.Add(repeatValue);
+  }
+
+  return NS_OK;
+}
+
+/*
+ * Given the simple progress for a paced animation, this method:
+ *  - determines which two elements of mValues we're in between
+ *    (returned as aFrom and aTo)
+ *  - determines where we are between them
+ *    (returned as aIntervalProgress)
+ *
+ * Returns NS_OK, unless there's an error computing distances.
+ */
+nsresult
+nsSMILAnimationFunction::ComputePacedPosition(const double& aSimpleProgress,
+                                              double& aIntervalProgress,
+                                              nsSMILValue& aFrom,
+                                              nsSMILValue& aTo)
+{
+  NS_ASSERTION(0.0f <= aSimpleProgress && aSimpleProgress < 1.0f,
+               "aSimpleProgress is out of bounds.");
+  NS_ASSERTION(mCalcMode.GetIntegerValue() == calc_paced,
+               "Calling paced-specific function, but not in paced mode");
+
+  if (mPacedTotalDistance == PACED_TOTAL_DISTANCE_NOT_SET) {
+    nsresult rv = ComputePacedTotalDistance();
+    if (!NS_SUCCEEDED(rv)) 
+      return rv;
+  } 
+
+  // total distance we should have moved at this point in time.
+  // (called 'remainingDist' due to how it's used in loop below)
+  PRFloat64 remainingDist = aSimpleProgress * mPacedTotalDistance;
+
+  // Find where remainingDist puts us in the list of values
+  // Note: We could optimize this next loop by caching the
+  // interval-distances in an array, but maybe that's excessive.
+  for (PRUint32 i = 0; i < mValues.Length() - 1; i++) {
+    PRFloat64 curIntervalDist;
+    nsresult tmpRv = mValues[i].ComputeDistance(mValues[i+1], curIntervalDist);
+    NS_ASSERTION(NS_SUCCEEDED(tmpRv), "ComputeDistance failed...?");
+    if (remainingDist >= curIntervalDist) {
+      remainingDist -= curIntervalDist;
+    } else {
+      // We found the right spot -- an interpolated position between
+      // values i and i+1.
+      aFrom = mValues[i];
+      aTo = mValues[i+1];
+      aIntervalProgress = remainingDist / curIntervalDist;
+      return NS_OK;
+    }
+  }
+
+  NS_NOTREACHED("shouldn't complete loop & get here -- if we do, "
+                "then aSimpleProgress was probably out of bounds.");
+  return NS_ERROR_FAILURE;
+}
+
+/*
+ * Computes & caches the total distance to be travelled by a paced animation.
+ *
+ * Returns NS_OK, unless there's an error computing distance.
+ */
+nsresult
+nsSMILAnimationFunction::ComputePacedTotalDistance()
+{
+  NS_ASSERTION(mCalcMode.GetIntegerValue() == calc_paced,
+               "Calling paced-specific function, but not in paced mode");
+  NS_ASSERTION(mPacedTotalDistance == PACED_TOTAL_DISTANCE_NOT_SET,
+               "Recomputing mPacedTotalDistance when it's already set...");
+
+  mPacedTotalDistance = 0.0f;
+  for (PRUint32 i = 0; i < mValues.Length() - 1; i++) {
+    PRFloat64 tmpDist;
+    nsresult rv = mValues[i].ComputeDistance(mValues[i+1], tmpDist);
+    if (!NS_SUCCEEDED(rv)) {
+      NS_NOTREACHED("ComputeDistance failed...?");
+      return rv;
+    }
+    mPacedTotalDistance += tmpDist;
+  }
+  return NS_OK;
+}
+
+/*
+ * Scale the simple progress, taking into account any keyTimes.
+ */
+void
+nsSMILAnimationFunction::ScaleSimpleProgress(PRFloat64& aProgress)
+{
+  if (!GET_FLAG(mSetFlags, BF_KEY_TIMES))
+    return;
+
+  PRUint32 numTimes = mKeyTimes.Length();
+
+  if (numTimes < 2)
+    return;
+
+  PRUint32 i = 0;
+  for (; i < numTimes - 2 && aProgress >= mKeyTimes[i+1]; ++i);
+
+  PRFloat64& intervalStart = mKeyTimes[i];
+  PRFloat64& intervalEnd   = mKeyTimes[i+1];
+
+  PRFloat64 intervalLength = intervalEnd - intervalStart;
+  if (intervalLength <= 0.0) {
+    aProgress = intervalStart;
+    return;
+  }
+
+  aProgress = (i + (aProgress - intervalStart) / intervalLength) * 
+         1.0 / (PRFloat64)(numTimes - 1);
+}
+
+/*
+ * Scale the interval progress, taking into account any keySplines
+ * or discrete methods.
+ */
+void
+nsSMILAnimationFunction::ScaleIntervalProgress(PRFloat64& aProgress,
+                                               PRUint32   aIntervalIndex,
+                                               PRUint32   aNumIntervals)
+{
+  if (mCalcMode.GetIntegerValue() != calc_spline)
+    return;
+
+  if (!GET_FLAG(mSetFlags, BF_KEY_SPLINES))
+    return;
+
+  NS_ASSERTION(aIntervalIndex >= 0 && 
+               aIntervalIndex < (PRUint32)mKeySplines.Length(),
+               "Invalid interval index.");
+  NS_ASSERTION(aNumIntervals >= 1, "Invalid number of intervals.");
+
+  if (aIntervalIndex < 0 ||
+      aIntervalIndex >= (PRUint32)mKeySplines.Length() ||
+      aNumIntervals < 1)
+    return;
+
+  nsSMILKeySpline const &spline = mKeySplines[aIntervalIndex];
+  aProgress = spline.GetSplineValue(aProgress);
+}
+
+/*
+ * SMILANIM specifies the following rules for animation function values:
+ *
+ * (1) if values is set, it overrides everything
+ * (2) for from/to/by animation at least to or by must be specified, from on its
+ *     own (or nothing) is an error--which we will ignore
+ * (3) if both by and to are specified only to will be used, by will be ignored
+ * (4) if by is specified without from (by animation), forces additive behaviour
+ * (5) if to is specified without from (to animation), special care needs to be
+ *     taken when compositing animation as such animations are composited last.
+ *
+ * This helper method applies these rules to fill in the values list and to set
+ * some internal state.
+ */
+void
+nsSMILAnimationFunction::UpdateValuesArray()
+{
+  // Need to clear cached paced-total-distance whenever we modify values array
+  mPacedTotalDistance = PACED_TOTAL_DISTANCE_NOT_SET;
+
+  if (!GET_FLAG(mSetFlags, BF_VALUES)) {
+    mValues.Clear();
+    mValues.SetCapacity(2);
+
+    if (!mTo.IsNull()) {
+      if (!mFrom.IsNull()) {
+        mValues.AppendElement(mFrom);
+        mValues.AppendElement(mTo);
+      } else {
+        mValues.AppendElement(mTo);
+      }
+    } else if (!mBy.IsNull()) {
+      if (!mFrom.IsNull()) {
+        // Set values to 'from; from + by'
+        mValues.AppendElement(mFrom);
+        nsSMILValue to = mFrom;
+        if (!to.IsNull() && NS_SUCCEEDED(to.Add(mBy))) {
+          mValues.AppendElement(to);
+        } else {
+          mValues.Clear();
+        }
+      } else {
+        // Set values to '0; by'
+        nsSMILValue from(mBy.mType);
+        if (!from.IsNull()) {
+          mValues.AppendElement(from);
+          mValues.AppendElement(mBy);
+        } else {
+          mValues.Clear();
+        }
+      }
+    }
+    // else, do nothing, mValues has been cleared already.
+  }
+
+  // mValues has changed, do we still have the right number of keySplines and
+  // keyTimes?
+  CheckKeyTimes();
+  CheckKeySplines();
+}
+
+inline PRBool
+nsSMILAnimationFunction::IsToAnimation() const
+{
+  return (!GET_FLAG(mSetFlags, BF_VALUES) && !mTo.IsNull() && mFrom.IsNull());
+}
+
+inline PRBool
+nsSMILAnimationFunction::IsAdditive() const
+{
+  /*
+   * Animation is additive if:
+   *
+   * (1) additive = "sum" (mAdditive == true), or
+   * (2) it is 'by animation' (by is set, from and values are not)
+   *
+   * Although animation is not additive if it is 'to animation'
+   */
+  return (!IsToAnimation() && 
+      (mAdditive.GetIntegerValue() || 
+       (!GET_FLAG(mSetFlags, BF_VALUES) && !mBy.IsNull() && mFrom.IsNull())));
+}
+
+/**
+ * Performs checks for the keyTimes attribute required by the SMIL spec but
+ * which depend on other attributes and therefore needs to be updated as
+ * dependent attributes are set.
+ */
+void
+nsSMILAnimationFunction::CheckKeyTimes()
+{
+  if (!GET_FLAG(mSetFlags, BF_KEY_TIMES))
+    return;
+
+  // attribute is ignored for calcMode = paced
+  if (mCalcMode.GetIntegerValue() == calc_paced) {
+    SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_FALSE);
+    return;
+  }
+
+  if (mKeyTimes.Length() < 1) {
+    // keyTimes isn't set or failed preliminary checks
+    SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_TRUE);
+    return;
+  }
+
+  // no. keyTimes == no. values
+  if ((mKeyTimes.Length() != mValues.Length() && !IsToAnimation()) ||
+      (IsToAnimation() && mKeyTimes.Length() != 2)) {
+    SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_TRUE);
+    return;
+  }
+
+  // special handling if there is only one keyTime. The spec doesn't say what to
+  // do in this case so we allow the keyTime to be either 0 or 1.
+  if (mKeyTimes.Length() == 1) {
+    PRFloat64 time = mKeyTimes[0];
+    SET_FLAG(mErrorFlags, BF_KEY_TIMES, !(time == 0.0 || time == 1.0));
+    return;
+  }
+
+  // there is a contradiction in the spec here. We're told the last value must
+  // be 1 for linear or spline calcMode's but then an example is given later of
+  // a from-to animation with a spline calcMode and keyTimes "0.0; 0.7".
+
+#ifndef ALLOW_BAD_KEYTIMES
+  // first value must be 0
+  if (mKeyTimes[0] != 0.0) {
+    SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_TRUE);
+    return;
+  }
+
+  // last value must be 1 for linear or spline calcMode's
+  if (mCalcMode.GetIntegerValue() == calc_linear || 
+      mCalcMode.GetIntegerValue() == calc_spline) {
+    PRFloat64 lastValue = mKeyTimes[mKeyTimes.Length() - 1];
+    if (lastValue != 1.0) {
+      SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_TRUE);
+      return;
+    }
+  }
+#endif
+
+  SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_FALSE);
+}
+
+void
+nsSMILAnimationFunction::CheckKeySplines()
+{
+  // attribute is ignored if calc mode is not spline
+  if (mCalcMode.GetIntegerValue() != calc_spline) {
+    SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_FALSE);
+    return;
+  }
+
+  // calc mode is spline but the attribute is not set
+  if (!GET_FLAG(mSetFlags, BF_KEY_SPLINES)) {
+    SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_FALSE);
+    return;
+  }
+
+  if (mKeySplines.Length() < 1) {
+    // keyTimes isn't set or failed preliminary checks
+    SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_TRUE);
+    return;
+  }
+
+  // ignore splines if there's only one value
+  if (mValues.Length() == 1 && !IsToAnimation()) {
+    SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_FALSE);
+    return;
+  }
+
+  // no. keySpline specs == no. values - 1
+  PRUint32 splineSpecs = mKeySplines.Length();
+  if ((splineSpecs != mValues.Length() - 1 && !IsToAnimation()) ||
+      (IsToAnimation() && splineSpecs != 1)) {
+    SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_TRUE);
+    return;
+  }
+
+  SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_FALSE);
+}
+
+//----------------------------------------------------------------------
+// Property setters / un-setters:
+
+nsresult
+nsSMILAnimationFunction::SetAdditive(const nsAString& aAdditive)
+{
+  mHasChanged = PR_TRUE;
+  return mAdditive.SetStringValue(aAdditive);
+}
+
+void
+nsSMILAnimationFunction::UnsetAdditive()
+{
+  mAdditive.SetIntegerValue((PRUint16)PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetCalcMode(const nsAString& aCalcMode)
+{
+  mHasChanged = PR_TRUE;
+  nsresult rv = mCalcMode.SetStringValue(aCalcMode);
+  SET_FLAG(mErrorFlags, BF_CALC_MODE, NS_FAILED(rv));
+  CheckKeyTimes();
+  CheckKeySplines();
+
+  return rv;
+}
+
+void
+nsSMILAnimationFunction::UnsetCalcMode()
+{
+  mCalcMode.SetIntegerValue(calc_linear);
+  SET_FLAG(mErrorFlags, BF_CALC_MODE, PR_FALSE);
+  mHasChanged = PR_TRUE;
+  CheckKeyTimes();
+  CheckKeySplines();
+}
+
+nsresult
+nsSMILAnimationFunction::SetAccumulate(const nsAString& aAccumulate)
+{
+  mHasChanged = PR_TRUE;
+  return mAccumulate.SetStringValue(aAccumulate);
+}
+
+void
+nsSMILAnimationFunction::UnsetAccumulate()
+{
+  mAccumulate.SetIntegerValue((PRUint16)PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetKeySplines(const nsAString& aKeySplines)
+{
+  mKeySplines.Clear();
+
+  nsTArray<PRFloat64> keySplines;
+  nsresult rv = nsSMILParserUtils::GetKeySplines(aKeySplines, keySplines);
+
+  if (keySplines.Length() < 1 || keySplines.Length() % 4)
+    rv = NS_ERROR_FAILURE;
+
+  if (NS_SUCCEEDED(rv))
+  {
+    mKeySplines.SetCapacity(keySplines.Length() % 4);
+    for (PRUint32 i = 0; i < keySplines.Length() && NS_SUCCEEDED(rv); i += 4)
+    {
+      if (!mKeySplines.AppendElement(nsSMILKeySpline(keySplines[i],
+                                                     keySplines[i+1],
+                                                     keySplines[i+2],
+                                                     keySplines[i+3]))) {
+        rv = NS_ERROR_OUT_OF_MEMORY;
+      }
+    }
+  }
+
+  mHasChanged = PR_TRUE;
+  SET_FLAG(mSetFlags, BF_KEY_SPLINES, PR_TRUE);
+
+  CheckKeySplines();
+
+  return rv;
+}
+
+void
+nsSMILAnimationFunction::UnsetKeySplines()
+{
+  mKeySplines.Clear();
+  SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_FALSE);
+  SET_FLAG(mSetFlags, BF_KEY_SPLINES, PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetKeyTimes(const nsAString& aKeyTimes)
+{
+  mKeyTimes.Clear();
+  nsresult rv = nsSMILParserUtils::GetKeyTimes(aKeyTimes, mKeyTimes);
+
+  if (NS_SUCCEEDED(rv) && mKeyTimes.Length() < 1)
+    rv = NS_ERROR_FAILURE;
+
+  if (NS_FAILED(rv))
+    mKeyTimes.Clear();
+
+  mHasChanged = PR_TRUE;
+  SET_FLAG(mSetFlags, BF_KEY_TIMES, PR_TRUE);
+
+  CheckKeyTimes();
+
+  return NS_OK;
+}
+
+void
+nsSMILAnimationFunction::UnsetKeyTimes()
+{
+  mKeyTimes.Clear();
+  SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_FALSE);
+  SET_FLAG(mSetFlags, BF_KEY_TIMES, PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+// Un-setter for nsSMILValue member data.
+// (Note: Setting is done in ReparseSMILValue)
+void
+nsSMILAnimationFunction::UnsetSMILValue(PRUint16 aBitfieldIndex)
+{
+  SET_FLAG(mSetFlags,   aBitfieldIndex, PR_FALSE);
+  SET_FLAG(mErrorFlags, aBitfieldIndex, PR_FALSE);
+  switch(aBitfieldIndex) {
+  case BF_BY:
+    mBy = nsSMILValue();
+    break;
+  case BF_FROM:
+    mFrom = nsSMILValue();
+    break;
+  case BF_TO:
+    mTo = nsSMILValue();
+    break;
+  case BF_VALUES:
+    // Do nothing.
+    break;
+  default:
+    NS_NOTREACHED("UnsetSMILValue got an unrecognized bitfield index!");
+    break;
+  }
+  UpdateValuesArray();
+  mHasChanged = PR_TRUE;
+}
+
+void
+nsSMILAnimationFunction::UpdateSMILType(const nsISMILType* aType)
+{
+  NS_ASSERTION(aType, "The SMIL type should never be set to null -- it should "
+               "instead be cleared to &nsSMILNullType::sSingleton");
+  if (mSMILType != aType) {
+    mSMILType = aType;
+    MarkSMILValuesDirty();
+  }
+}
+
+// Utility function to clear out all nsSMILValue member variables & mark them
+// as needing to be re-parsed
+void
+nsSMILAnimationFunction::MarkSMILValuesDirty()
+{
+  // Indicate that we need to re-parse all SMIL Values
+  //  - set their 'dirty' bits... 
+  // (optimization: just for attrs that are set, or were attempted to be set &
+  // had errors)
+  mDirtyFlags |= SPECIALLY_PARSED_ATTR_MASK & (mSetFlags | mErrorFlags);
+
+  // - clear their 'set' and 'error' bits...
+  mSetFlags   &= (~SPECIALLY_PARSED_ATTR_MASK);
+  mErrorFlags &= (~SPECIALLY_PARSED_ATTR_MASK);
+
+  // - and clear the actual stored values, too.
+  mBy = mFrom = mTo = nsSMILValue();
+  UpdateValuesArray();
+}
diff --git a/content/smil/src/nsSMILAnimationRegistry.cpp b/content/smil/src/nsSMILAnimationRegistry.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILAnimationRegistry.cpp
@@ -0,0 +1,176 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILAnimationRegistry.h"
+#include "nsISMILAttr.h"
+#include "nsSMILAnimationFunction.h"
+#include "nsSMILTimedDocumentRoot.h"
+#include "nsMathUtils.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILAnimationRegistry implementation
+
+//----------------------------------------------------------------------
+// ctors, dtors, factory methods
+
+nsSMILAnimationRegistry::~nsSMILAnimationRegistry()
+{
+  if (mController && mTimedDocumentRoot)
+    mController->RemoveTimeContainer(mTimedDocumentRoot);
+}
+
+nsSMILAnimationRegistry*
+NS_NewSMILAnimationRegistry()
+{
+  nsSMILAnimationRegistry* animationRegistry = new nsSMILAnimationRegistry();
+
+  if (!animationRegistry)
+    return nsnull;
+
+  nsresult rv = animationRegistry->Init();
+  if (NS_FAILED(rv)) {
+    delete animationRegistry;
+    animationRegistry = nsnull;
+  }
+
+  return animationRegistry;
+}
+
+nsresult
+nsSMILAnimationRegistry::Init()
+{
+  mTimedDocumentRoot = new nsSMILTimedDocumentRoot(this);
+  NS_ENSURE_TRUE(mTimedDocumentRoot, NS_ERROR_OUT_OF_MEMORY);
+
+  mTimedDocumentRoot->Pause();
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// nsISMILAnimationRegistry methods:
+
+nsresult
+nsSMILAnimationRegistry::SetController(nsSMILAnimationController* aController)
+{
+  nsresult rv = NS_OK;
+
+  NS_ENSURE_TRUE(mTimedDocumentRoot, NS_ERROR_FAILURE);
+
+  if (mController) {
+    rv = mController->RemoveTimeContainer(mTimedDocumentRoot);
+    NS_ENSURE_SUCCESS(rv,rv);
+  }
+
+  mController = aController;
+
+  if (mController)
+    rv = mController->AddTimeContainer(mTimedDocumentRoot);
+
+  return rv;
+}
+
+nsresult
+nsSMILAnimationRegistry::Start()
+{
+  NS_ENSURE_TRUE(mTimedDocumentRoot,NS_ERROR_FAILURE);
+  if (!mStarted) {
+    mTimedDocumentRoot->Resume();
+    mStarted = PR_TRUE;
+  }
+  return NS_OK;
+}
+
+void
+nsSMILAnimationRegistry::Pause()
+{
+  NS_ENSURE_TRUE(mTimedDocumentRoot,);
+  NS_ENSURE_TRUE(mStarted,);
+  mTimedDocumentRoot->Pause();
+}
+
+void
+nsSMILAnimationRegistry::Unpause()
+{
+  NS_ENSURE_TRUE(mTimedDocumentRoot,);
+  NS_ENSURE_TRUE(mStarted,);
+  mTimedDocumentRoot->Resume();
+}
+
+PRBool
+nsSMILAnimationRegistry::IsPaused()
+{
+  if (!mStarted)
+    return PR_TRUE;
+
+  NS_ENSURE_TRUE(mTimedDocumentRoot,PR_FALSE);
+
+  return mTimedDocumentRoot->IsPaused();
+}
+
+float
+nsSMILAnimationRegistry::GetCurrentTime()
+{
+  PRInt64 lCurrentTimeMs = mTimedDocumentRoot->GetDocumentTime();
+  PRFloat64 fCurrentTimeMs;
+  LL_L2D(fCurrentTimeMs, lCurrentTimeMs);
+  return (float)(fCurrentTimeMs / PR_MSEC_PER_SEC);
+}
+
+nsresult
+nsSMILAnimationRegistry::SetCurrentTime(float aSeconds)
+{
+  PRFloat64 fMilliseconds = aSeconds * PR_MSEC_PER_SEC;
+  PRInt64 lMilliseconds;
+  // Round to nearest whole number before converting, to avoid precision errors
+  LL_D2L(lMilliseconds, NS_round(fMilliseconds));
+  return mTimedDocumentRoot->SeekToTime(lMilliseconds);
+}
+
+nsresult
+nsSMILAnimationRegistry::RegisterTimedElement(nsISMILTimedElement *aElement)
+{
+  return (mTimedDocumentRoot) ? mTimedDocumentRoot->AddTimedElement(aElement)
+                              : NS_ERROR_FAILURE;
+}
+
+nsresult
+nsSMILAnimationRegistry::UnregisterTimedElement(nsISMILTimedElement *aElement)
+{
+  return (mTimedDocumentRoot) ? mTimedDocumentRoot->RemoveTimedElement(aElement)
+                              : NS_ERROR_FAILURE;
+}
diff --git a/content/smil/src/nsSMILCompositor.cpp b/content/smil/src/nsSMILCompositor.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILCompositor.cpp
@@ -0,0 +1,174 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Daniel Holbert <dholbert@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILCompositor.h"
+#include "nsHashKeys.h"
+
+NS_IMPL_THREADSAFE_ISUPPORTS1(nsSMILCompositor,
+                              nsIHashable)
+
+
+// nsIHashable Methods
+NS_IMETHODIMP
+nsSMILCompositor::Equals(nsIHashable* aOther, PRBool *aResult)
+{
+  nsSMILCompositor* other = static_cast<nsSMILCompositor*>(aOther);
+  
+  *aResult = (other->mElement       == mElement &&
+              other->mAttributeName == mAttributeName &&
+              other->mIsCSS         == mIsCSS);
+
+   return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSMILCompositor::GetHashCode(PRUint32 *aResult)
+{
+  // Combine the 3 values into one numeric value, which will be hashed
+  *aResult = 
+    NS_PTR_TO_UINT32(mElement.get()) +
+    HashString(mAttributeName) +
+    (mIsCSS ? 1 : 0);
+
+  return NS_OK;
+}
+
+// Other methods
+void
+nsSMILCompositor::AddAnimationFunction(nsSMILAnimationFunction* aFunc)
+{
+  mAnimationFunctions.AppendElement(aFunc);
+}
+
+void
+nsSMILCompositor::ComposeSample()
+{
+  // FIRST: Sort the animationFunctions, to prepare for compositing.
+  nsSMILAnimationFunction::Comparator comparator;
+  mAnimationFunctions.Sort(comparator);
+  
+  // SECOND: Get the nsISMILAttr (to grab base value from, and to eventually
+  // give animated value to)
+  nsCOMPtr<nsIContent> animatedElem(do_QueryInterface(mElement));
+  NS_ASSERTION(animatedElem, "target elem failed QI to nsIContent");
+
+  nsCOMPtr<nsIAtom> attributeAtom(do_GetAtom(mAttributeName));
+
+  nsAutoPtr<nsISMILAttr> smilAttr;
+
+  smilAttr = animatedElem->GetAnimatedAttr(attributeAtom, mIsCSS);
+  if (!smilAttr) {
+    // This could probably happen if e.g. the attribute name (combined with
+    // isCSS) doesn't match to an actual attribute on the target element.
+    // e.g. Maybe we were animating "cx" on a circle, but now we've been
+    // retargeted at a rect, for which "cx" is meaningless.
+    return;
+  }
+
+  // THIRD: Step backwards through animation functions to find out
+  // which ones we actually care about.
+  PRUint32 length = mAnimationFunctions.Length();
+  PRUint32 i;
+  //  PRBool changed = PR_FALSE; // XXXdholbert removing until we have HasChangedTarget
+  for (i = length; i > 0; --i) {
+    nsSMILAnimationFunction* curAnimFunc = mAnimationFunctions[i-1];
+    NS_ASSERTION(curAnimFunc, "null nsSMILAnimationFunction in mAnimationFunctions!");
+    if (curAnimFunc) {
+      // XXXdholbert we need to add another function
+      // nsSMILAnimationFunction::HasChangedTarget(elem, smilAttr, isCSS) that
+      // we call here (in addition to HasChanged(), because even if function
+      // value hasn't changed, its target might have.
+      // For this to work, the nsSMILAnimationFunction needs to cache its last
+      // elem/smilAttr/isCSS values, and then check them against the new values
+      // here.
+      /*
+      if (!changed && curAnimFunc->HasChanged()) {
+        changed = PR_TRUE;
+      }
+      */
+      
+      // Re-parse any attributes that need it.
+      curAnimFunc->ReparseDirtyAttrs(*smilAttr);
+      if (curAnimFunc->WillReplace()) {
+        --i;
+        break;
+      }
+    }
+  }
+  // note: 'i' is now the index of the first animation function that we need
+  // to use in compositing.
+
+  // if (!changed) // XXXdholbert removing until we have HasChangedTarget
+  //  return;
+
+  // THIRD: Compose animation functions (starting with base value)
+  nsSMILValue resultValue;
+  smilAttr->GetBaseValue(resultValue);
+  for (; i < length; ++i) {
+    nsSMILAnimationFunction* curAnimFunc = mAnimationFunctions[i];
+    if (curAnimFunc) {
+      curAnimFunc->ComposeResult(resultValue);
+    }
+  }
+
+  // FOURTH: Set the animated value to the final composited result.
+  // XXXdholbert Check return value of SetAnimVal?  (what could go wrong?)
+  smilAttr->SetAnimValue(resultValue);
+}
+
+ // static
+nsresult
+nsSMILCompositor::ComposeHashtableEntries(nsTHashtable<nsHashableHashKey>*
+                                          compositorTable)
+{
+  return compositorTable->EnumerateEntries(ComposeHashtableEntry, nsnull);
+}
+
+// static
+PR_CALLBACK PLDHashOperator
+nsSMILCompositor::ComposeHashtableEntry(nsHashableHashKey *aKey, void* /*aData*/)
+{ 
+  nsSMILCompositor *compositor = static_cast<nsSMILCompositor*>(aKey->GetKey());
+
+  if (!compositor) {
+    NS_NOTREACHED("Null pointer in compositor table");
+  } else {
+    compositor->ComposeSample();
+  }
+  
+  return PL_DHASH_NEXT;
+}
diff --git a/content/smil/src/nsSMILCompositor.h b/content/smil/src/nsSMILCompositor.h
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILCompositor.h
@@ -0,0 +1,94 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Daniel Holbert <dholbert@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILCOMPOSITOR_H__
+#define __NS_SMILCOMPOSITOR_H__
+
+#include "nsIContent.h"
+#include "nsHashKeys.h"
+#include "nsIHashable.h"
+#include "nsTHashtable.h"
+#include "nsAutoPtr.h"
+#include "nsString.h"
+#include "nsSMILAnimationFunction.h"
+
+class nsSMILCompositor : public nsIHashable
+{
+ public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIHASHABLE
+
+  nsSMILCompositor(nsIContent *aElement, nsAString &aAttributeName, 
+                   PRBool aIsCSS)
+    : mElement(aElement), mAttributeName(aAttributeName), mIsCSS(aIsCSS)  {};
+
+
+  // Adds the given animation function to this Compositor's list of functions
+  void AddAnimationFunction(nsSMILAnimationFunction* aFunc);
+  
+  // Calls ComposeSample() on each nsSMILCompositor in the given hashset
+  static nsresult ComposeHashtableEntries(nsTHashtable<nsHashableHashKey>*
+                                          compositorTable);
+
+ private:
+  // Composes the current values the list of animation functions, and assigns
+  // the resulting value to the target element's target attribute.
+  void ComposeSample();
+
+  // Static callback methods
+  PR_STATIC_CALLBACK(int) SortAnimationFunctions(nsSMILAnimationFunction* aFunc1,
+                                                 nsSMILAnimationFunction* aFunc2,
+                                                 void* aData);
+  PR_STATIC_CALLBACK(PLDHashOperator) ComposeHashtableEntry(nsHashableHashKey *aKey,
+                                                            void* aData);
+  // Hash Key: Animated Element, Attribute Name & Type (CSS vs. XML)
+  // ---------------------------------------------------------------
+  // Note: Need a nsRefPtr to the element, because nsSMILCompositors are kept
+  // around for 1 sample after they're used, and they need to make sure their
+  // target isn't deleted.
+  nsRefPtr<nsIContent> mElement;
+  nsAutoString         mAttributeName;
+  PRBool               mIsCSS;  // XXXdholbert needs to be more generic
+                                // (CSS vs XML vs auto... maybe vs
+                                // namespaces specified in the attribute name?)
+
+  // Hash Value: List of animation functions that animate the specified attribute
+  // ----------------------------------------------------------------------------
+  nsTArray<nsSMILAnimationFunction*> mAnimationFunctions;
+};
+
+#endif // __NS_SMILCOMPOSITOR_H__
diff --git a/content/smil/src/nsSMILEnum.cpp b/content/smil/src/nsSMILEnum.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILEnum.cpp
@@ -0,0 +1,94 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Tim Rowley <tor@cs.brown.edu> (original author)
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILEnum.h"
+#include "nsGkAtoms.h"
+#include "nsString.h"
+#include "nsCRT.h"
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSMILEnum::nsSMILEnum(PRUint16 value,
+                       nsSMILEnumMapping *mapping)
+    : mValue(value), mMapping(mapping)
+{
+  nsGkAtoms::AddRefAtoms();
+}
+
+nsresult
+nsSMILEnum::SetStringValue(const nsAString& aValue)
+{
+  // 
+  // According to XML 1.0, section 3.3.3 we need to discard leading and trailing
+  // whitespace for this attribute. Currently nsSVGEnum doesn't do this
+  // otherwise we might try and re-use some of that functionality here
+  //
+  nsAString::const_iterator start;
+  nsAString::const_iterator end;
+
+  aValue.BeginReading(start);
+  aValue.EndReading(end);
+
+  while (*start && NS_IS_SPACE(*start))
+    ++start;
+
+  do --end; while (start != end && NS_IS_SPACE(*end));
+    ++end;
+
+  nsCOMPtr<nsIAtom> valAtom = do_GetAtom(Substring(start, end));
+
+  nsSMILEnumMapping *tmp = mMapping;
+
+  if (!tmp)
+    return NS_ERROR_FAILURE;
+
+  while (tmp->key) {
+    if (valAtom == *(tmp->key)) {
+      mValue = tmp->val;
+      return NS_OK;
+    }
+    tmp++;
+  }
+
+  // XXXbb Should be reporting a warning somehow?
+  // NS_WARNING("Unknown enumeration key");
+
+  return NS_ERROR_FAILURE;
+}
diff --git a/content/smil/src/nsSMILFloatType.cpp b/content/smil/src/nsSMILFloatType.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILFloatType.cpp
@@ -0,0 +1,122 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILFloatType.h"
+#include "nsSMILValue.h"
+#include "nsDebug.h"
+
+/*static*/ nsSMILFloatType nsSMILFloatType::sSingleton;
+
+void
+nsSMILFloatType::SetValueIdentity(nsSMILValue& aValue)
+{
+  aValue.mU.mDouble = 0.0;
+}
+
+nsresult
+nsSMILFloatType::AssignValue(nsSMILValue& aDest, const nsSMILValue& aSrc)
+{
+  NS_ASSERTION(aSrc.mType == &sSingleton, "Unexpected source type");
+  aDest.mType = &sSingleton;
+  aDest.mU.mDouble = aSrc.mU.mDouble;
+  return NS_OK;
+}
+
+nsresult
+nsSMILFloatType::Add(nsSMILValue& aDest, const nsSMILValue& aSrc)
+{
+  NS_ASSERTION(aSrc.mType == aDest.mType, "Trying to add invalid types");
+  NS_ASSERTION(aSrc.mType == &sSingleton, "Unexpected source type");
+  aDest.mU.mDouble += aSrc.mU.mDouble;
+  return NS_OK;
+}
+
+nsresult
+nsSMILFloatType::ComputeDistance(const nsSMILValue& aFrom,
+                                 const nsSMILValue& aTo,
+                                 PRFloat64& aDistance) const
+{
+  NS_ASSERTION(aFrom.mType == aTo.mType, "Trying to compare different types");
+  NS_ASSERTION(aFrom.mType == &sSingleton, "Unexpected source type");
+  
+  const double &from = aFrom.mU.mDouble;
+  const double &to   = aTo.mU.mDouble;
+
+  // XXX do we have an absolute-value utility function?
+  aDistance = to - from;
+  if (aDistance < 0) 
+    aDistance = -aDistance;
+
+  return NS_OK;
+}
+
+nsresult
+nsSMILFloatType::Interpolate(const nsSMILValue& aStartVal,
+                             const nsSMILValue& aEndVal,
+                             float aUnitDistance,
+                             nsSMILValue& aResult)
+{
+  NS_ASSERTION(aStartVal.mType == aEndVal.mType,
+      "Trying to interpolate different types");
+  NS_ASSERTION(aStartVal.mType == &sSingleton, "Unexpected type");
+
+  const double &startVal = aStartVal.mU.mDouble;
+  const double &endVal   = aEndVal.mU.mDouble;
+
+  aResult.mU.mDouble = (startVal + (endVal - startVal) * aUnitDistance);
+  aResult.mType      = &sSingleton;
+
+  return NS_OK;
+}
+
+nsresult
+nsSMILFloatType::Repeat(nsSMILValue& aDest,
+                        PRUint32 aCount,
+                        const nsSMILValue* aRepeatValue)
+{
+  NS_ASSERTION(aDest.mType == &sSingleton, "Trying to repeat invalid type");
+  NS_ASSERTION(!aRepeatValue || aRepeatValue->mType == &sSingleton,
+    "Invalid repeat type");
+
+  double const &value = (aRepeatValue)
+                      ? aRepeatValue->mU.mDouble
+                      : aDest.mU.mDouble;
+  aDest.mU.mDouble = value * (aCount + 1);
+
+  return NS_OK;
+}
diff --git a/content/smil/src/nsSMILInstanceTime.cpp b/content/smil/src/nsSMILInstanceTime.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILInstanceTime.cpp
@@ -0,0 +1,60 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILInstanceTime.h"
+#include "nsSMILTimeValueSpec.h"
+#include "nsSMILTimeValue.h"
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSMILInstanceTime::nsSMILInstanceTime(const nsSMILTimeValue &aTime,
+                                       nsSMILTimeValueSpec *aCreator,
+                                       PRBool aClearOnReset /*=false*/)
+  : mTime(aTime), // Copy the time
+    mClearOnReset(aClearOnReset)
+{
+  if (aCreator)
+    mCreator = do_GetWeakReference(aCreator);
+}
+
+nsSMILInstanceTime::~nsSMILInstanceTime()
+{
+  // XXXdholbert When we add support for syncbase timing, we'll
+  // need to remove this nsSMILInstanceTime from its timebase
+  // here.
+}
diff --git a/content/smil/src/nsSMILInstanceTime.h b/content/smil/src/nsSMILInstanceTime.h
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILInstanceTime.h
@@ -0,0 +1,104 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILINSTANCETIME_H__
+#define __NS_SMILINSTANCETIME_H__
+
+#include "nsISupports.h"
+#include "nsSMILTimeValue.h"
+#include "nsWeakReference.h"
+#include "nsAutoPtr.h"
+
+class nsSMILTimeValueSpec;
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILInstanceTime : An instant in document simple time that may be
+//                      used in creating a new interval
+
+class nsSMILInstanceTime
+{
+public:
+  nsSMILInstanceTime(const nsSMILTimeValue &aTime,
+                     nsSMILTimeValueSpec *aCreator,
+                     PRBool aClearOnReset = PR_FALSE);
+
+  ~nsSMILInstanceTime();
+
+  const nsSMILTimeValue&  Time() const { return mTime; }
+
+  PRBool                  ClearOnReset() const { return mClearOnReset; }
+
+  // void DependentUpdate(const nsSMILTimeValue& aNewTime); -- NOT YET IMPL.
+
+  // Used by nsTArray::Sort
+  class Comparator {
+    public:
+      PRBool Equals(const nsSMILInstanceTime& aElem1,
+                    const nsSMILInstanceTime& aElem2) const {
+        return (aElem1.Time().CompareTo(aElem2.Time()) == 0);
+      }
+      PRBool LessThan(const nsSMILInstanceTime& aElem1,
+                      const nsSMILInstanceTime& aElem2) const {
+        return (aElem1.Time().CompareTo(aElem2.Time()) < 0);
+      }
+  };
+
+protected:
+  nsSMILTimeValue     mTime;
+
+  /**
+   * The nsSMILTimeValueSpec that created this instance time if any. This will
+   * be NULL for instance times created via DOM calls etc.
+   */
+  nsWeakPtr           mCreator;
+
+  /**
+   * Indicates if this instance time should be removed when the owning timed
+   * element is reset. True for events and DOM calls.
+   */
+  PRBool              mClearOnReset;
+
+  /*
+   * This will only be used for for identifying the instance times associated
+   * with a deleting interval. We will never de-reference this pointer, but only
+   * use it for pointer comparisons. Therefore it's not necessary for instances
+   * of nsSMILInterval to be reference-counted.
+   */
+  // nsSMILInterval   *mTimebase -- NOT YET IMPLEMENTED
+};
+
+#endif // __NS_SMILINSTANCETIME_H__
diff --git a/content/smil/src/nsSMILInterval.cpp b/content/smil/src/nsSMILInterval.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILInterval.cpp
@@ -0,0 +1,74 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILInterval.h"
+#include "nsSMILInstanceTime.h"
+#include "nsCRT.h"
+
+// Creates a new interval with unresolved begin and end times
+nsSMILInterval::nsSMILInterval()
+: mBegin(),
+  mEnd()
+{
+}
+
+nsSMILInterval::nsSMILInterval(const nsSMILTimeValue& aBegin,
+                               const nsSMILTimeValue& aEnd)
+: mBegin(aBegin),
+  mEnd(aEnd)
+{
+}
+
+//----------------------------------------------------------------------
+// Implementation
+
+NS_IMPL_ISUPPORTS1(nsSMILInterval,
+                   nsSMILInterval)
+
+void
+nsSMILInterval::UpdateBegin(const nsSMILTimeValue &aNewTime)
+{
+  mBegin = aNewTime;
+  // XXX notify dependents
+}
+
+void
+nsSMILInterval::UpdateEnd(const nsSMILTimeValue &aNewTime)
+{
+  mEnd = aNewTime;
+  // XXX notify dependents
+}
diff --git a/content/smil/src/nsSMILInterval.h b/content/smil/src/nsSMILInterval.h
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILInterval.h
@@ -0,0 +1,83 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILINTERVAL_H__
+#define __NS_SMILINTERVAL_H__
+
+#include "nsISupports.h"
+#include "nsSMILTimeValue.h"
+
+class nsSMILInstanceTime;
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILInterval class
+
+// {443cdd3f-1d0c-4eb9-b043-5cde9e4ca35b}
+#define NS_SMILINTERVAL_IID \
+{ 0x443cdd3f, 0x1d0c, 0x4eb9, { 0xb0, 0x43, 0x5c, 0xde, 0x9e, 0x4c, 0xa3, 0x5b } }
+
+class nsSMILInterval : public nsISupports
+{
+public:
+  nsSMILInterval();
+  nsSMILInterval(const nsSMILTimeValue &aBegin,
+                 const nsSMILTimeValue &aEnd);
+
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_SMILINTERVAL_IID)
+  NS_DECL_ISUPPORTS
+
+  const nsSMILTimeValue& Begin() { return mBegin; }
+  const nsSMILTimeValue& End() { return mEnd; }
+
+  void UpdateBegin(const nsSMILTimeValue &aNewTime);
+  void UpdateEnd(const nsSMILTimeValue &aNewTime);
+
+  // We will need to track dependent instance times from here
+  //
+  // e.g.
+  // 
+  // void  AddDependent(nsSMILInstanceTime& aDependent, PRBool aForBegin);
+  // void  RemoveDependent(nsSMILInstanceTime& aDependent, PRBool aForBegin);
+
+protected:
+  nsSMILTimeValue   mBegin;
+  nsSMILTimeValue   mEnd;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsSMILInterval, NS_SMILINTERVAL_IID)
+
+#endif // __NS_SMILINTERVAL_H__
diff --git a/content/smil/src/nsSMILKeySpline.cpp b/content/smil/src/nsSMILKeySpline.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILKeySpline.cpp
@@ -0,0 +1,119 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILKeySpline.h"
+#include <math.h>
+
+#define NEWTON_ITERATIONS   4
+
+const PRFloat64 nsSMILKeySpline::kSampleStepSize = 
+                                        1.0 / (PRFloat64)(kSplineTableSize - 1);
+
+nsSMILKeySpline::nsSMILKeySpline(const PRFloat64& aX1,
+                                 const PRFloat64& aY1,
+                                 const PRFloat64& aX2,
+                                 const PRFloat64& aY2)
+: mX1(aX1),
+  mY1(aY1),
+  mX2(aX2),
+  mY2(aY2)
+{
+  if (mX1 != mY1 || mX2 != mY2)
+    CalcSampleValues();
+}
+
+PRFloat64
+nsSMILKeySpline::GetSplineValue(const PRFloat64& x) const
+{
+  if (mX1 == mY1 && mX2 == mY2)
+    return x;
+
+  return CalcBezier(GetTForX(x), mY1, mY2);
+}
+
+void
+nsSMILKeySpline::CalcSampleValues()
+{
+  for (int i = 0; i < kSplineTableSize; ++i)
+    mSampleValues[i] = CalcBezier((PRFloat64)i * kSampleStepSize, mX1, mX2);
+}
+
+/*static*/ PRFloat64
+nsSMILKeySpline::CalcBezier(const PRFloat64& t,
+                            const PRFloat64& a1,
+                            const PRFloat64& a2)
+{
+  return A(a1, a2) * pow(t,3) + B(a1, a2)*t*t + C(a1) * t;
+}
+
+/*static*/ PRFloat64
+nsSMILKeySpline::GetSlope(const PRFloat64& t,
+                             const PRFloat64& a1,
+                             const PRFloat64& a2)
+{
+  PRFloat64 denom = (3.0 * A(a1, a2)*t*t + 2.0 * B(a1, a2) * t + C(a1)); 
+  return (denom == 0.0) ? 0.0 : 1.0 / denom;
+}
+
+PRFloat64
+nsSMILKeySpline::GetTForX(const PRFloat64& x) const
+{
+  int i;
+
+  // Get an initial guess.
+  //
+  // Note: This is better than just taking x as our initial guess as cases such
+  // as where the control points are (1, 1), (0, 0) will take some 20 iterations
+  // to converge to a good accuracy. By taking an initial guess in this way we
+  // only need 3~4 iterations depending on the size of the table.
+  for (i = 0; i < kSplineTableSize - 2 && mSampleValues[i] < x; ++i);
+  PRFloat64 currentT = 
+    (PRFloat64)i * kSampleStepSize + (x - mSampleValues[i]) * kSampleStepSize;
+
+  // Refine with Newton-Raphson iteration
+  for (i = 0; i < NEWTON_ITERATIONS; ++i) {
+    PRFloat64 currentX = CalcBezier(currentT, mX1, mX2);
+    PRFloat64 currentSlope = GetSlope(currentT, mX1, mX2);
+
+    if (currentSlope == 0.0)
+      return currentT;
+
+    currentT -= (currentX - x) * currentSlope;
+  }
+
+  return currentT;
+}
diff --git a/content/smil/src/nsSMILNullType.cpp b/content/smil/src/nsSMILNullType.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILNullType.cpp
@@ -0,0 +1,87 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILNullType.h"
+#include "nsSMILValue.h"
+#include "nsDebug.h"
+
+/*static*/ nsSMILNullType nsSMILNullType::sSingleton;
+
+nsresult
+nsSMILNullType::AssignValue(nsSMILValue& aDest, const nsSMILValue& aSrc)
+{
+  NS_ASSERTION(aSrc.mType == &sSingleton, "Unexpected source type");
+  aDest.mType = &sSingleton;
+  return NS_OK;
+}
+
+nsresult
+nsSMILNullType::Add(nsSMILValue&, const nsSMILValue&)
+{
+  NS_NOTREACHED("Adding NULL type.");
+  return NS_ERROR_FAILURE;
+}
+
+nsresult
+nsSMILNullType::ComputeDistance(const nsSMILValue&,
+                                const nsSMILValue&,
+                                PRFloat64& aDistance) const
+{
+  NS_NOTREACHED("Computing distance for NULL type.");
+  aDistance = 0.0;
+  return NS_ERROR_FAILURE;
+}
+
+nsresult
+nsSMILNullType::Interpolate(const nsSMILValue&,
+                            const nsSMILValue&,
+                            float,
+                            nsSMILValue&)
+{
+  NS_NOTREACHED("Interpolating NULL type.");
+  return NS_ERROR_FAILURE;
+}
+
+nsresult
+nsSMILNullType::Repeat(nsSMILValue&,
+                       PRUint32,
+                       const nsSMILValue*)
+{
+  NS_NOTREACHED("Repeating NULL type.");
+  return NS_ERROR_FAILURE;
+}
diff --git a/content/smil/src/nsSMILParserUtils.cpp b/content/smil/src/nsSMILParserUtils.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILParserUtils.cpp
@@ -0,0 +1,617 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILParserUtils.h"
+#include "nsISMILAttr.h"
+#include "nsSMILValue.h"
+#include "nsSMILTimeValue.h"
+#include "nsString.h"
+#include "prdtoa.h"
+#include "nsCRT.h"
+#include "nsCOMPtr.h"
+#include "prlong.h"
+
+const PRUint32 nsSMILParserUtils::MSEC_PER_SEC   = 1000;
+const PRUint32 nsSMILParserUtils::MSEC_PER_MIN   = 1000 * 60;
+const PRUint32 nsSMILParserUtils::MSEC_PER_HOUR  = 1000 * 60 * 60;
+
+//------------------------------------------------------------------------------
+// Inlines
+
+// NS_IS_SPACE relies on isspace which may return true for \xB and \xC but
+// SMILANIM does not consider these characters to be whitespace.
+inline PRBool
+nsSMILParserUtils::IsSpace(const char c)
+{
+  return (c == 0x9 || c == 0xA || c == 0xD || c == 0x20);
+}
+
+inline PRBool
+nsSMILParserUtils::IsSpace(const PRUnichar c)
+{
+  return (c == 0x9 || c == 0xA || c == 0xD || c == 0x20);
+}
+
+inline void
+nsSMILParserUtils::SkipWsp(nsACString::const_iterator& aIter,
+                           const nsACString::const_iterator& aIterEnd)
+{
+  while (aIter != aIterEnd && IsSpace(*aIter))
+    ++aIter;
+}
+
+inline void
+nsSMILParserUtils::SkipWsp(nsAString::const_iterator& aIter,
+                           const nsAString::const_iterator& aIterEnd)
+{
+  while (aIter != aIterEnd && IsSpace(*aIter))
+    ++aIter;
+}
+
+inline PRFloat64
+nsSMILParserUtils::GetFloat(nsACString::const_iterator& aIter,
+                            const nsACString::const_iterator& aIterEnd,
+                            nsresult *aErrorCode)
+{
+  char *end;
+  const char *start = aIter.get();
+  PRFloat64 value = PR_strtod(start, &end);
+
+  nsresult rv = NS_OK;
+
+  if (end == start || end > aIterEnd.get())
+    rv = NS_ERROR_FAILURE;
+  else
+    aIter.advance(end - start);
+
+  if (aErrorCode)
+    *aErrorCode = rv;
+
+  return value;
+}
+
+inline PRBool
+nsSMILParserUtils::ConsumeSubstring(nsACString::const_iterator& aIter,
+                                    const nsACString::const_iterator& aIterEnd,
+                                    const char *aSubstring)
+{
+  size_t substrLen = PL_strlen(aSubstring);
+  typedef nsACString::const_iterator::difference_type diff_type;
+
+  if (aIterEnd.get() - aIter.get() < static_cast<diff_type>(substrLen))
+    return PR_FALSE;
+
+  PRBool result = PR_FALSE;
+
+  if (PL_strstr(aIter.get(), aSubstring) == aIter.get()) {
+    aIter.advance(substrLen);
+    result = PR_TRUE;
+  }
+
+  return result;
+}
+
+//------------------------------------------------------------------------------
+// Implementation
+
+nsresult
+nsSMILParserUtils::GetKeySplines(const nsAString& aSpec,
+                                 nsTArray<PRFloat64> &aSplineArray)
+{
+  nsresult rv = NS_OK;
+
+  nsCAutoString spec;
+  LossyCopyUTF16toASCII(aSpec, spec);
+
+  nsACString::const_iterator start, end;
+  spec.BeginReading(start);
+  spec.EndReading(end);
+
+  SkipWsp(start, end);
+
+  int i = 0;
+
+  while (start != end)
+  {
+    PRFloat64 value = GetFloat(start, end, &rv);
+    if (NS_FAILED(rv))
+      break;
+
+    if (value > 1.0 || value < 0.0) {
+      rv = NS_ERROR_FAILURE;
+      break;
+    }
+
+    if (!aSplineArray.AppendElement(value)) {
+      rv = NS_ERROR_OUT_OF_MEMORY;
+      break;
+    }
+
+    ++i;
+
+    SkipWsp(start, end);
+    if (start == end)
+      break;
+
+    if (i % 4) {
+      if (*start == ',')
+        ++start;
+    } else {
+      if (*start != ';') {
+        rv = NS_ERROR_FAILURE;
+        break;
+      }
+      ++start;
+    }
+
+    SkipWsp(start, end);
+  }
+
+  if (i % 4)
+    rv = NS_ERROR_FAILURE; // wrong number of points
+
+  return rv;
+}
+
+nsresult
+nsSMILParserUtils::GetKeyTimes(const nsAString& aSpec,
+                               nsTArray<PRFloat64> &aTimeArray)
+{
+  nsresult rv = NS_OK;
+
+  nsCAutoString spec;
+  LossyCopyUTF16toASCII(aSpec, spec);
+
+  nsACString::const_iterator start, end;
+  spec.BeginReading(start);
+  spec.EndReading(end);
+
+  SkipWsp(start, end);
+
+  PRFloat64 previousValue = -1.0;
+
+  while (start != end) {
+    PRFloat64 value = GetFloat(start, end, &rv);
+    if (NS_FAILED(rv))
+      break;
+
+    if (value > 1.0 || value < 0.0 || value < previousValue) {
+      rv = NS_ERROR_FAILURE;
+      break;
+    }
+
+    if (!aTimeArray.AppendElement(value)) {
+      rv = NS_ERROR_OUT_OF_MEMORY;
+      break;
+    }
+    previousValue = value;
+
+    SkipWsp(start, end);
+    if (start == end)
+      break;
+    
+    if (*start++ != ';') {
+      rv = NS_ERROR_FAILURE;
+      break;
+    }
+
+    SkipWsp(start, end);
+  }
+
+  return rv;
+}
+
+nsresult
+nsSMILParserUtils::GetValues(const nsAString& aSpec, const void* aData,
+                             nsISMILAttr& aAttribute, 
+                             nsTArray<nsSMILValue>& aValuesArray)
+{
+  nsresult rv = NS_ERROR_FAILURE;
+  nsAString::const_iterator start;
+  nsAString::const_iterator end;
+  nsAString::const_iterator substr_end;
+  nsAString::const_iterator next;
+
+  aSpec.BeginReading(start);
+  aSpec.EndReading(end);
+
+  while (start != end) {
+    rv = NS_ERROR_FAILURE;
+
+    SkipWsp(start, end);
+
+    if (start == end || *start == ';')
+      break;
+
+    substr_end = start;
+
+    while (substr_end != end && *substr_end != ';')
+      ++substr_end;
+
+    next = substr_end;
+    if (*substr_end == ';') {
+      ++next;
+      if (next == end)
+        break;
+    }
+
+    do --substr_end; while (start != substr_end && NS_IS_SPACE(*substr_end));
+      ++substr_end;
+
+    nsSMILValue newValue;
+    rv = aAttribute.ValueFromString(Substring(start, substr_end), 
+                                    aData, newValue);
+    if (NS_FAILED(rv))
+      break;
+
+    if (!aValuesArray.AppendElement(newValue)) {
+      rv = NS_ERROR_OUT_OF_MEMORY;
+      break;
+    }
+
+    rv = NS_OK;
+    start = next;
+  }
+
+  return rv;
+}
+
+nsresult
+nsSMILParserUtils::GetRepeatCount(const nsAString& aSpec,
+                                  nsSMILTimeValue& aResult)
+{
+  nsresult rv = NS_OK;
+
+  nsCAutoString spec;
+  LossyCopyUTF16toASCII(aSpec, spec);
+
+  nsACString::const_iterator start, end;
+  spec.BeginReading(start);
+  spec.EndReading(end);
+
+  SkipWsp(start, end);
+  
+  if (start != end)
+  {
+    if (ConsumeSubstring(start, end, "indefinite")) {
+      aResult.SetIndefinite();
+    } else {
+      PRFloat64 value = GetFloat(start, end, &rv);
+
+      if (NS_SUCCEEDED(rv))
+      {
+        PRInt64 count;
+        value *= 1000.0;
+
+        LL_D2L(count, value);
+
+        aResult.SetMillis(count);
+
+        if (!LL_GE_ZERO(count) || LL_IS_ZERO(count))
+          rv = NS_ERROR_FAILURE;
+      }
+    }
+
+    /* Check for trailing junk */
+    SkipWsp(start, end);
+    if (start != end)
+      rv = NS_ERROR_FAILURE;
+  } else {
+    /* Empty spec */
+    rv = NS_ERROR_FAILURE;
+  }
+
+  if (NS_FAILED(rv))
+    aResult.SetUnresolved();
+
+  return rv;
+}
+
+//
+// This method can actually parse more than a clock value as defined in the
+// SMIL Animation specification. It can also parse:
+//  - the + or - before an offset
+//  - the special value "indefinite"
+//  - the special value "media"
+//
+// Because the value "media" cannot be represented as part of an nsSMILTimeValue
+// and has different meanings depending on where it is used, it is passed out as
+// a separate parameter (which can be set to null if the media attribute is not
+// allowed).
+//
+// aResult may be NULL, e.g. to check if the string is a valid clock value
+//
+nsresult
+nsSMILParserUtils::GetClockValue(const nsAString& aSpec,
+                                 nsSMILTimeValue* aResult, 
+                                 PRBool aAllowSign,       // = false
+                                 PRBool aAllowIndefinite, // = false
+                                 PRBool aAllowMedia,      // = false
+                                 PRBool* aIsMedia)        // = nsnull
+{
+  PRInt64 offset = LL_Zero();
+  PRFloat64 component = 0.0;
+
+  PRInt8 sign = 0;
+  PRUint8 colonCount = 0;
+
+  PRBool started = PR_FALSE;
+  PRBool isValid = PR_TRUE;
+
+  PRInt32 metricMultiplicand = MSEC_PER_SEC;
+
+  PRBool numIsReal = PR_FALSE;
+  PRBool prevNumCouldBeMin = PR_FALSE;
+  PRBool numCouldBeMin = PR_FALSE;
+  PRBool numCouldBeSec = PR_FALSE;
+  PRBool isIndefinite = PR_FALSE;
+
+  if (aIsMedia)
+    *aIsMedia = PR_FALSE;
+
+  nsCAutoString spec;
+  LossyCopyUTF16toASCII(aSpec, spec);
+
+  nsACString::const_iterator start, end;
+  spec.BeginReading(start);
+  spec.EndReading(end);
+
+  while (start != end) {
+    if (IsSpace(*start)) {
+      if (started) {
+        ++start;
+        break;
+      }
+      // else, we haven't started yet, ignore initial whitespace
+      ++start;
+
+    } else if (aAllowSign && (*start == '+' || *start == '-')) {
+      if (sign != 0) {
+        // sign has already been set
+        isValid = PR_FALSE;
+        break;
+      }
+
+      if (started) {
+        // sign appears in the middle of the string
+        isValid = PR_FALSE;
+        break;
+      }
+
+      sign = (*start == '+') ? 1 : -1;
+      ++start;
+    // The NS_IS_DIGIT etc. macros are not locale-specific
+    } else if (NS_IS_DIGIT(*start)) {
+      prevNumCouldBeMin = numCouldBeMin;
+
+      if (!GetClockComponent(start, end, component, numIsReal, numCouldBeMin,
+                             numCouldBeSec)) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      started = PR_TRUE;
+    } else if (*start == ':') {
+      ++colonCount;
+
+      // Neither minutes nor hours can be reals
+      if (numIsReal) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      // Clock value can't start with a ':'
+      if (!started) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      // Can't have more than two colons
+      if (colonCount > 2) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      // Multiply the offset by 60 and add the last accumulated component
+      PRInt64 component64;
+      LL_D2L(component64, component);
+      LL_MUL(offset, offset, LL_INIT(0,60));
+      LL_ADD(offset, offset, component64);
+
+      component = 0.0l;
+      ++start;
+    } else if (NS_IS_ALPHA(*start)) {
+      if (colonCount > 0) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      if (aAllowIndefinite && ConsumeSubstring(start, end, "indefinite")) {
+        // We set a separate flag because we don't know what the state of the
+        // passed in time value is and we shouldn't change it in the case of a
+        // bad input string (so we can't initialise it to 0ms for example).
+        isIndefinite = PR_TRUE;
+        if (aResult)
+          aResult->SetIndefinite();
+      } else if (aAllowMedia && ConsumeSubstring(start, end, "media")) {
+        if (aIsMedia)
+          *aIsMedia = PR_TRUE;
+      } else if (!GetMetricMultiplicand(start, end, metricMultiplicand)) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      // Nothing must come after the string except whitespace
+      break;
+    } else {
+      isValid = PR_FALSE;
+      break;
+    }
+  }
+
+  if (!started) isValid = PR_FALSE;
+
+  // Process remainder of string (if any) to ensure it is only trailing
+  // whitespace (embedded whitespace is not allowed)
+  SkipWsp(start, end);
+  if (start != end)
+    isValid = PR_FALSE;
+
+  // No more processing required if the value was "indefinite" or "media".
+  if (isIndefinite || (aIsMedia && *aIsMedia))
+    return NS_OK;
+
+  // If there is more than one colon then the previous component must be a
+  // correctly formatted minute (i.e. two digits between 00 and 59) and the
+  // latest component must be a correctly formatted second (i.e. two digits
+  // before the .)
+  if (colonCount > 0 && (!prevNumCouldBeMin || !numCouldBeSec))
+    isValid = PR_FALSE;
+
+  if (isValid) {
+    // Tack on the last component
+    if (colonCount > 0) {
+      LL_MUL(offset, offset, LL_INIT(0,60));
+      LL_MUL(offset, offset, LL_INIT(0,1000));
+      component *= 1000;
+      // rounding
+      component = (component >= 0) ? component + 0.5l : component - 0.5l;
+      PRInt64 component64;
+      LL_D2L(component64, component);
+      LL_ADD(offset, offset, component64);
+    } else {
+      component *= metricMultiplicand;
+      // rounding
+      component = (component >= 0) ? component + 0.5l : component - 0.5l;
+      LL_D2L(offset, component);
+    }
+
+    if (aResult) {
+      PRInt64 millis = offset;
+
+      if (sign == -1)
+        LL_NEG(millis, offset);
+
+      aResult->SetMillis(millis);
+    }
+  }
+
+  return (isValid) ? NS_OK : NS_ERROR_FAILURE;
+}
+
+PRBool
+nsSMILParserUtils::GetClockComponent(nsACString::const_iterator& aSpec,
+                                     const nsACString::const_iterator& aEnd,
+                                     PRFloat64& aResult,
+                                     PRBool& aIsReal,
+                                     PRBool& aCouldBeMin,
+                                     PRBool& aCouldBeSec)
+{
+  nsresult rv;
+  char const *begin = aSpec.get();
+  PRFloat64 value = GetFloat(aSpec, aEnd, &rv);
+
+  // Check a number was found
+  if (NS_FAILED(rv))
+    return PR_FALSE;
+
+  // Check it's not expressed in exponential form
+  size_t len = aSpec.get() - begin;
+  PRBool isExp = (PL_strnpbrk(begin, "eE", len) != nsnull);
+  if (isExp)
+    return PR_FALSE;
+
+  // Don't allow real numbers of the form "23."
+  if (*(aSpec.get() - 1) == '.')
+    return PR_FALSE;
+
+  // Number looks good
+  aResult = value;
+
+  // Set some flags so we can check this number is valid once we know
+  // whether it's an hour, minute string etc.
+  aIsReal = (PL_strnchr(begin, '.', len) != nsnull);
+  aCouldBeMin = (value < 60.0l && (len == 2));
+  aCouldBeSec = (value < 60.0l ||
+      (value == 60.0l && begin[0] == '5')); // Take care of rounding error
+  aCouldBeSec &= (len >= 2 &&
+      (begin[2] == '\0' || begin[2] == '.' || IsSpace(begin[2])));
+
+  return PR_TRUE;
+}
+
+inline PRBool
+nsSMILParserUtils::GetMetricMultiplicand(nsACString::const_iterator& aSpec,
+                                         const nsACString::const_iterator& aEnd,
+                                         PRInt32& multiplicand)
+{
+  PRBool result = PR_FALSE;
+
+  size_t len = aEnd.get() - aSpec.get();
+  nsACString::const_iterator spec(aSpec);
+  
+  if (len) {
+    switch (*spec++)
+    {
+      case 'h':
+        multiplicand = MSEC_PER_HOUR;
+        result = PR_TRUE;
+        break;
+      case 'm':
+        if (len >= 2) {
+          if (*spec == 's') {
+            ++spec;
+            multiplicand = 1;
+            result = PR_TRUE;
+          } else if (len >=3 && *spec++ == 'i' && *spec++ == 'n') {
+            multiplicand = MSEC_PER_MIN;
+            result = PR_TRUE;
+          }
+        }
+        break;
+      case 's':
+        multiplicand = MSEC_PER_SEC;
+        result = PR_TRUE;
+        break;
+    }
+  }
+
+  if (result)
+    aSpec = spec;
+
+  return result;
+}
diff --git a/content/smil/src/nsSMILParserUtils.h b/content/smil/src/nsSMILParserUtils.h
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILParserUtils.h
@@ -0,0 +1,106 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILPARSERUTILS_H__
+#define __NS_SMILPARSERUTILS_H__
+
+#include "nscore.h"
+#include "nsTArray.h"
+#include "nsString.h"
+
+class nsISMILAttr;
+class nsSMILTimeValue;
+struct nsSMILValue;
+
+/**
+ * Common parsing utilities for the SMIL module. There is little re-use here; it
+ * simply serves to simplify other classes by moving parsing outside and to aid
+ * unit testing.
+ */
+class nsSMILParserUtils
+{
+public:
+  static nsresult   GetKeySplines(const nsAString& aSpec,
+                                  nsTArray<PRFloat64> &aSplineArray);
+
+  static nsresult   GetKeyTimes(const nsAString& aSpec,
+                                nsTArray<PRFloat64> &aTimesArray);
+
+  static nsresult   GetValues(const nsAString& aSpec, const void* aData,
+                              nsISMILAttr& aAttribute,
+                              nsTArray<nsSMILValue>& aValuesArray);
+
+  static nsresult   GetRepeatCount(const nsAString& aSpec,
+                                   nsSMILTimeValue& aResult);
+
+  static nsresult   GetClockValue(const nsAString& aSpec,
+                                  nsSMILTimeValue* aResult, 
+                                  PRBool aAllowSign = false,
+                                  PRBool aAllowIndefinite = false,
+                                  PRBool aAllowMedia = false,
+                                  PRBool* aIsMedia = nsnull);
+
+
+private:
+  static void   SkipWsp(nsACString::const_iterator& aIter,
+                        const nsACString::const_iterator& aIterEnd);
+  static void   SkipWsp(nsAString::const_iterator& aIter,
+                        const nsAString::const_iterator& aIterEnd);
+  static PRFloat64 GetFloat(nsACString::const_iterator& aIter,
+                            const nsACString::const_iterator& aIterEnd,
+                            nsresult *aErrorCode = nsnull);
+  static PRBool IsSpace(const char c);
+  static PRBool IsSpace(const PRUnichar c);
+  static PRBool ConsumeSubstring(nsACString::const_iterator& aIter,
+                                 const nsACString::const_iterator& aIterEnd,
+                                 const char *aSubstring);
+  static PRBool GetClockComponent(nsACString::const_iterator& aSpec,
+                                  const nsACString::const_iterator& aEnd,
+                                  PRFloat64& aResult,
+                                  PRBool& aIsReal,
+                                  PRBool& aCouldBeMin,
+                                  PRBool& aCouldBeSec);
+  static PRBool GetMetricMultiplicand(nsACString::const_iterator& aSpec,
+                                      const nsACString::const_iterator& aEnd,
+                                      PRInt32& multiplicand);
+
+  static const PRUint32 MSEC_PER_SEC;
+  static const PRUint32 MSEC_PER_MIN;
+  static const PRUint32 MSEC_PER_HOUR;
+};
+
+#endif // __NS_SMILPARSERUTILS_H__
diff --git a/content/smil/src/nsSMILTimeValue.cpp b/content/smil/src/nsSMILTimeValue.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILTimeValue.cpp
@@ -0,0 +1,113 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILTimeValue.h"
+#include "nsDebug.h"
+
+PRInt64 nsSMILTimeValue::mUnresolvedSeconds = LL_MaxInt();
+
+//----------------------------------------------------------------------
+// Implementation
+
+// Default constructor creates an unresolved time
+nsSMILTimeValue::nsSMILTimeValue()
+  : mMilliseconds(LL_MaxInt()),
+    mIndefinite(PR_FALSE),
+    mResolved(PR_FALSE)
+{
+}
+
+//----------------------------------------------------------------------
+// nsSMILTimeValue methods:
+
+void
+nsSMILTimeValue::SetIndefinite()
+{
+  mResolved = PR_FALSE;
+  mIndefinite = PR_TRUE;
+  mMilliseconds = LL_MaxInt();
+}
+
+void
+nsSMILTimeValue::SetUnresolved()
+{
+  mResolved = PR_FALSE;
+  mIndefinite = PR_FALSE;
+  mMilliseconds = LL_MaxInt();
+}
+
+const PRInt64&
+nsSMILTimeValue::GetMillis() const
+{
+  NS_ASSERTION(mResolved, "GetMillis() called for unresolved time.");
+
+  if (!mResolved)
+      return mUnresolvedSeconds;
+
+  return mMilliseconds;
+}
+
+void
+nsSMILTimeValue::SetMillis(const PRInt64& aMillis)
+{
+  mResolved = PR_TRUE;
+  mIndefinite = PR_FALSE;
+  mMilliseconds = aMillis;
+}
+
+PRInt8
+nsSMILTimeValue::CompareTo(const nsSMILTimeValue& aOther) const
+{
+  PRInt8 result;
+
+  if (mResolved) {
+    result = (aOther.mResolved)
+           ? CmpLL(mMilliseconds, aOther.mMilliseconds)
+           : -1;
+  } else if (mIndefinite) {
+    if (aOther.mResolved)
+      result = 1;
+    else if (aOther.mIndefinite)
+      result = 0;
+    else
+      result = -1;
+  } else {
+    result = (aOther.mResolved || aOther.mIndefinite) ? 1 : 0;
+  }
+
+  return result;
+}
diff --git a/content/smil/src/nsSMILTimeValueSpec.cpp b/content/smil/src/nsSMILTimeValueSpec.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILTimeValueSpec.cpp
@@ -0,0 +1,113 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILTimeValueSpec.h"
+#include "nsSMILTimeValue.h"
+#include "nsSMILInstanceTime.h"
+#include "nsSMILParserUtils.h"
+#include "nsString.h"
+#include "nsAutoPtr.h"
+
+//----------------------------------------------------------------------
+// Implementation
+
+already_AddRefed<nsSMILTimeValueSpec>
+NS_NewSMILTimeValueSpec(nsISMILTimedElement* aOwner,
+                        PRBool aIsBegin,
+                        const nsAString& aStringSpec)
+{
+  nsSMILTimeValueSpec* result = new nsSMILTimeValueSpec(aOwner, aIsBegin);
+  NS_ENSURE_TRUE(result, nsnull);
+
+  NS_ADDREF(result); // Need to addref as SetSpec calls getWeakReference
+  nsresult rv = result->SetSpec(aStringSpec);
+  if (NS_FAILED(rv)) {
+    NS_RELEASE(result);
+    return nsnull;
+  }
+  return result;
+}
+
+nsSMILTimeValueSpec::nsSMILTimeValueSpec(nsISMILTimedElement* aOwner,
+                                         PRBool aIsBegin)
+  : mIsBegin(aIsBegin),
+    mOffset() // initalises to zero
+{
+  if (aOwner)
+    mOwner = do_GetWeakReference(aOwner);
+}
+
+//----------------------------------------------------------------------
+// nsISupports
+
+NS_IMPL_ISUPPORTS2(nsSMILTimeValueSpec,
+                   nsSMILTimeValueSpec,
+                   nsISupportsWeakReference)
+
+//----------------------------------------------------------------------
+// nsSMILTimeValueSpec
+
+nsresult
+nsSMILTimeValueSpec::SetSpec(const nsAString& aStringSpec)
+{
+  // XXX Need to parse other specifiers, not just offset type
+  nsSMILTimeValue clockTime;
+  nsresult rv = 
+    nsSMILParserUtils::GetClockValue(aStringSpec,
+                                     &clockTime,
+                                     true,  // allow + or -
+                                     true); // allow 'indefinite'
+
+  if (NS_FAILED(rv) || (!clockTime.IsResolved() && !clockTime.IsIndefinite()))
+    return NS_ERROR_FAILURE;
+  
+  if (clockTime.IsResolved())
+    mOffset = clockTime.GetMillis();
+  
+  if (mOwner) {
+    nsSMILInstanceTime *instance = new nsSMILInstanceTime(clockTime, this);
+    NS_ENSURE_TRUE(instance, NS_ERROR_OUT_OF_MEMORY);
+
+    nsCOMPtr<nsISMILTimedElement> owner = do_QueryReferent(mOwner);
+    NS_ENSURE_TRUE(owner, NS_ERROR_FAILURE);
+
+    owner->AddInstanceTime(*instance, mIsBegin);
+    delete instance;
+  }
+
+  return rv;
+}
diff --git a/content/smil/src/nsSMILTimeValueSpec.h b/content/smil/src/nsSMILTimeValueSpec.h
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILTimeValueSpec.h
@@ -0,0 +1,86 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILTIMEVALUESPEC_H__
+#define __NS_SMILTIMEVALUESPEC_H__
+
+#include "nsISupports.h"
+#include "nsWeakReference.h"
+#include "nsISMILTimedElement.h"
+
+class nsAString;
+class nsSMILTimeValue;
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILTimeValueSpec class
+
+// {39d2f376-6bda-42c0-8510-a93b24828a80}
+#define NS_SMILTIMEVALUESPEC_IID \
+{ 0x39d2f376, 0x6bda, 0x42c0, { 0x85, 0x10, 0xa9, 0x3b, 0x24, 0x82, 0x8a, 0x80 } }
+
+class nsSMILTimeValueSpec : public nsSupportsWeakReference
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_SMILTIMEVALUESPEC_IID)
+  NS_DECL_ISUPPORTS
+
+protected:
+  nsSMILTimeValueSpec(nsISMILTimedElement* aOwner, PRBool aIsBegin);
+
+  friend already_AddRefed<nsSMILTimeValueSpec>
+  NS_NewSMILTimeValueSpec(nsISMILTimedElement* aOwner,
+                          PRBool aIsBegin,
+                          const nsAString& aStringSpec);
+
+  nsresult      SetSpec(const nsAString& aStringSpec);
+
+  nsWeakPtr mOwner;
+  PRBool    mIsBegin;
+  PRInt64   mOffset;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsSMILTimeValueSpec, NS_SMILTIMEVALUESPEC_IID)
+
+////////////////////////////////////////////////////////////////////////
+// Factory methods
+
+already_AddRefed<nsSMILTimeValueSpec>
+NS_NewSMILTimeValueSpec(nsISMILTimedElement* aOwner,
+                        PRBool aIsBegin,
+                        const nsAString& aStringSpec);
+
+#endif // __NS_SMILTIMEVALUESPEC_H__
diff --git a/content/smil/src/nsSMILTimedDocumentRoot.cpp b/content/smil/src/nsSMILTimedDocumentRoot.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILTimedDocumentRoot.cpp
@@ -0,0 +1,290 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILTimedDocumentRoot.h"
+#include "nsSMILTimeValue.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILTimedDocumentRoot implementation
+
+nsSMILTimedDocumentRoot::nsSMILTimedDocumentRoot(
+    nsSMILAnimationRegistry* registry)
+:
+  mStartTime(),
+  mAccumulatedOffset(),
+  mAnimationRegistry(registry),
+  mParentPaused(PR_FALSE),
+  mContainerPaused(PR_FALSE),
+  mNeedsSampleDuringPause(PR_FALSE)
+{
+}
+
+//----------------------------------------------------------------------
+// nsISupports methods:
+
+NS_IMPL_ISUPPORTS2(nsSMILTimedDocumentRoot,
+                   nsISMILTimeContainer,
+                   nsISupportsWeakReference)
+
+//----------------------------------------------------------------------
+// nsSMILTimedDocumentRoot methods
+
+PRInt64
+nsSMILTimedDocumentRoot::GetDocumentTime()
+{
+  if (LL_IS_ZERO(mStartTime))
+    return LL_Zero();
+
+  PRInt64 now;
+  LL_DIV(now, PR_Now(), PR_USEC_PER_MSEC);
+  
+  PRInt64 currentTime = (mParentPaused || mContainerPaused)
+                      ? mPauseStart
+                      : now;
+
+  PRInt64 timeSinceStart;
+  LL_SUB(timeSinceStart, currentTime, mStartTime);
+
+  PRInt64 adjustedTime;
+  LL_SUB(adjustedTime, timeSinceStart, mAccumulatedOffset);
+
+  return adjustedTime;
+}
+
+nsSMILTimeValue
+nsSMILTimedDocumentRoot::WallclockToDocumentTime(nsISMILTimeValueSpec*
+                                                   aWallclockSpec)
+{
+  // XXX
+  (void)aWallclockSpec;
+  NS_NOTYETIMPLEMENTED("nsSMILTimedDocumentRoot::WallclockToDocumentTime");
+  return nsSMILTimeValue();
+}
+
+nsresult
+nsSMILTimedDocumentRoot::SeekToTime(PRInt64 aSeekTo)
+{
+  PRInt64 now;
+  LL_DIV(now, PR_Now(), PR_USEC_PER_MSEC);
+  LL_SUB(mStartTime, now, aSeekTo);
+  mAccumulatedOffset = LL_Zero();
+  if (mParentPaused || mContainerPaused) {
+    // Update mPauseStart to be now (= mStartTime + aSeekTo)
+    // and request a sample
+    mPauseStart = now;
+    mNeedsSampleDuringPause = PR_TRUE;
+  }
+  
+  ResetChildren(PR_FALSE);
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// nsISMILTimeContainer methods
+
+nsresult
+nsSMILTimedDocumentRoot::Pause()
+{
+  if (!mContainerPaused && !mParentPaused) {
+    LL_DIV(mPauseStart, PR_Now(), PR_USEC_PER_MSEC);
+    mNeedsSampleDuringPause = PR_TRUE; // request one more sample after pause
+  }
+
+  mContainerPaused = PR_TRUE;
+  return NS_OK;
+}
+
+nsresult
+nsSMILTimedDocumentRoot::Resume()
+{
+  if (mContainerPaused && !mParentPaused) {
+    PRInt64 extraOffset;
+    PRInt64 now;
+    LL_DIV(now, PR_Now(), PR_USEC_PER_MSEC);
+    LL_SUB(extraOffset, now, mPauseStart);
+    LL_ADD(mAccumulatedOffset, extraOffset, mAccumulatedOffset);
+    mNeedsSampleDuringPause = PR_FALSE; // XXXdholbert probably unnecessary
+  }
+  mContainerPaused = PR_FALSE;
+  return NS_OK;
+}
+
+PRBool
+nsSMILTimedDocumentRoot::IsPaused()
+{
+  return mContainerPaused;
+}
+
+nsresult
+nsSMILTimedDocumentRoot::HandleParentPaused()
+{
+  if (!mContainerPaused && !mParentPaused) {
+    LL_DIV(mPauseStart, PR_Now(), PR_USEC_PER_MSEC);
+    mNeedsSampleDuringPause = PR_TRUE;
+  }
+  mParentPaused = PR_TRUE;
+  return NS_OK;
+}
+
+nsresult
+nsSMILTimedDocumentRoot::HandleParentResumed()
+{
+  if (!mContainerPaused && mParentPaused) {
+    PRInt64 extraOffset;
+    PRInt64 now;
+    LL_DIV(now, PR_Now(), PR_USEC_PER_MSEC);
+    LL_SUB(extraOffset, now, mPauseStart);
+    LL_ADD(mAccumulatedOffset, extraOffset, mAccumulatedOffset);
+  }
+  mParentPaused = PR_FALSE;
+  return NS_OK;
+}
+
+nsresult
+nsSMILTimedDocumentRoot::Reset()
+{
+  mStartTime = LL_Zero();
+  mAccumulatedOffset = LL_Zero();
+  mParentPaused = PR_FALSE;
+  mContainerPaused = PR_FALSE;
+  mNeedsSampleDuringPause = PR_FALSE;
+  ResetChildren(PR_TRUE);
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedDocumentRoot::Sample()
+{
+  PRInt64 now;
+  if (mParentPaused || mContainerPaused) {
+    if (mNeedsSampleDuringPause) {
+      // Perform requested sample, for pause-start-time
+      now = mPauseStart;
+      mNeedsSampleDuringPause = PR_FALSE;
+    } else {
+      // Paused, and don't need a sample.  Nothing to do.
+      return;
+    }
+  } else {
+    // Not paused -- need a sample at time = now.
+    LL_DIV(now, PR_Now(), PR_USEC_PER_MSEC);
+  }
+
+  // If this is the first time, record the document begin time
+  // and clear any accumulated offset.
+  if (LL_IS_ZERO(mStartTime)) {
+    mStartTime = now;
+    mAccumulatedOffset = LL_Zero();
+  }
+  
+  PRInt64 instant;
+  LL_SUB(instant, now, mStartTime);
+  LL_SUB(instant, instant, mAccumulatedOffset);
+
+  SampleChildren(instant);
+}
+
+nsresult
+nsSMILTimedDocumentRoot::AddTimedElement(nsISMILTimedElement* aElement)
+{
+  NS_ENSURE_ARG_POINTER(aElement);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aElement, &rv)) );
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  rv = (mTimedElements.AppendObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+
+  aElement->SetDocumentRoot(this);
+
+  return rv;
+}
+
+nsresult
+nsSMILTimedDocumentRoot::RemoveTimedElement(nsISMILTimedElement* aElement)
+{
+  NS_ENSURE_ARG_POINTER(aElement);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aElement, &rv)) );
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  rv = (mTimedElements.RemoveObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+
+  aElement->SetDocumentRoot(nsnull);
+
+  return rv;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers:
+
+void
+nsSMILTimedDocumentRoot::SampleChildren(PRInt64 aDocumentTime)
+{
+  PRUint32 i = mTimedElements.Count();
+  while (i > 0) {
+    --i;
+    nsCOMPtr<nsISMILTimedElement> 
+      element( do_QueryReferent(mTimedElements[i]) );
+
+    if (element)
+      element->SampleAt(aDocumentTime);
+    else
+      mTimedElements.RemoveObjectAt(i);
+  }
+}
+
+void
+nsSMILTimedDocumentRoot::ResetChildren(PRBool aHardReset)
+{
+  PRUint32 i = mTimedElements.Count();
+  while (i > 0) {
+    --i;
+    nsCOMPtr<nsISMILTimedElement> 
+      element( do_QueryReferent(mTimedElements[i]) );
+
+    if (element)
+      element->Reset(aHardReset);
+    else
+      mTimedElements.RemoveObjectAt(i);
+  }
+}
diff --git a/content/smil/src/nsSMILTimedElement.cpp b/content/smil/src/nsSMILTimedElement.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILTimedElement.cpp
@@ -0,0 +1,1275 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILAnimationFunction.h"
+#include "nsISMILTimedElement.h"
+#include "nsIDOMElementTimeControl.h"
+#include "nsWeakReference.h"
+#include "nsSMILTimeValue.h"
+#include "nsSMILTimeValueSpec.h"
+#include "nsSMILInstanceTime.h"
+#include "nsSMILInterval.h"
+#include "nsSMILEnum.h"
+#include "nsSMILParserUtils.h"
+#include "nsSMILTimedDocumentRoot.h"
+#include "nsGkAtoms.h"
+#include "nsCOMArray.h"
+#include "nsReadableUtils.h"
+#include "nsAutoPtr.h"
+#include "prdtoa.h"
+#include "plstr.h"
+#include "nsString.h"
+
+// handy typedefs
+typedef nsTArray<nsRefPtr<nsSMILInterval> >       SMILIntervalList;
+typedef nsTArray<nsRefPtr<nsSMILTimeValueSpec> >  SMILTimeValueSpecList;
+
+//----------------------------------------------------------------------
+// Class declaration
+
+class nsSMILTimedElement : public nsISMILTimedElement,
+                           public nsIDOMElementTimeControl,
+                           public nsSupportsWeakReference
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIDOMELEMENTTIMECONTROL
+
+  // nsISMILTimedElement
+  virtual void      AddInstanceTime(const nsSMILInstanceTime& aInstanceTime,
+                                    PRBool aIsBegin);
+  virtual void      SetDocumentRoot(nsSMILTimedDocumentRoot* aRoot);
+  virtual void      SetTimeClient(nsSMILAnimationFunction* aClient);
+  virtual void      SampleAt(const PRInt64& aDocumentTime);
+  virtual void      Reset(PRBool aHardReset = PR_FALSE);
+  virtual PRBool    SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                            nsresult* aResult);
+  virtual PRBool    UnsetAttr(nsIAtom* aAttribute);
+
+protected:
+  nsSMILTimedElement();
+  nsresult          Init();
+
+  friend nsISMILTimedElement* NS_NewSMILTimedElement();
+
+  //
+  // Implementation helpers
+  //
+
+  nsresult          SetBeginSpec(const nsAString& aBeginSpec);
+  nsresult          SetEndSpec(const nsAString& aEndSpec);
+  nsresult          SetSimpleDuration(const nsAString& aDurSpec);
+  nsresult          SetMin(const nsAString& aMinSpec);
+  nsresult          SetMax(const nsAString& aMaxSpec);
+  nsresult          SetRestart(const nsAString& aRestartSpec);
+  nsresult          SetRepeatCount(const nsAString& aRepeatCountSpec);
+  nsresult          SetRepeatDur(const nsAString& aRepeatDurSpec);
+  nsresult          SetFillMode(const nsAString& aFillModeSpec);
+
+  void              UnsetBeginSpec();
+  void              UnsetEndSpec();
+  void              UnsetSimpleDuration();
+  void              UnsetMin();
+  void              UnsetMax();
+  void              UnsetRestart();
+  void              UnsetRepeatCount();
+  void              UnsetRepeatDur();
+  void              UnsetFillMode();
+
+  nsresult          SetBeginOrEndSpec(const nsAString& aSpec, PRBool aIsBegin);
+
+  /**
+   * Calculates the first acceptable interval for this element.
+   *
+   * @see SMILANIM 3.6.8
+   */
+  nsresult          GetNextInterval(const nsSMILTimeValue& aBeginAfter,
+                                  PRBool aFirstInstance,
+                                  nsSMILInterval& aResult);
+
+  PRBool            GetNextGreater(const nsTArray<nsSMILInstanceTime>& aList,
+                                   const nsSMILTimeValue& aBase,
+                                   PRInt32& aPosition,
+                                   nsSMILTimeValue& aResult);
+  nsSMILTimeValue   CalcActiveEnd(const nsSMILTimeValue& aBegin,
+                                  const nsSMILTimeValue& aEnd);
+  nsSMILTimeValue   GetRepeatDuration();
+  nsSMILTimeValue   ApplyMinAndMax(const nsSMILTimeValue& aDuration);
+  PRInt64           ActiveTimeToSimpleTime(const PRInt64& aActiveTime,
+                                           PRUint32& aRepeatIteration);
+  void              CheckForEarlyEnd(const nsSMILTimeValue &aDocumentTime);
+  void              UpdateCurrentInterval();
+  void              SampleSimpleTime(PRInt64 aActiveTime);
+  void              SampleFillValue();
+  PRInt64           MinLL(const PRInt64& a, const PRInt64& b);
+
+  //
+  // Members
+  //
+  SMILTimeValueSpecList mBeginSpecs;
+  SMILTimeValueSpecList mEndSpecs;
+
+  //
+  // We need to distinguish between attempting to set the begin spec and failing
+  // (in which case the mBeginSpecs array will be empty) and not attempting to
+  // set the begin spec at all. In the first case, we should act as if the begin
+  // was indefinite, and in the second, we should act as if begin was 0s.
+  //
+  PRBool                          mBeginSpecSet;
+
+  nsSMILTimeValue                 mSimpleDur;
+
+  /**
+   * The number of iterations of the animation function. We use an
+   * nsSMILTimeValue type where:
+   *
+   * milliseconds = the number of iterations * 1000,
+   * indefinite   = repeating indefinitely, until the document ends, and
+   * unresolved   = the attribute is not set, therefore no repeating.
+   */
+  nsSMILTimeValue                 mRepeatCount;
+  nsSMILTimeValue                 mRepeatDur;
+
+  nsSMILTimeValue                 mMin;
+  nsSMILTimeValue                 mMax;
+
+  enum nsSMILFillMode
+  {
+    fill_remove,
+    fill_freeze
+  };
+  static nsSMILEnumMapping        sFillModeMap[];
+  nsSMILEnum                      mFillMode;
+
+  enum nsSMILRestartMode
+  {
+    restart_always,
+    restart_whennotactive,
+    restart_never
+  };
+  static nsSMILEnumMapping        sRestartModeMap[];
+  nsSMILEnum                      mRestartMode;
+
+  PRBool                          mEndHasEventConditions;
+
+  nsTArray<nsSMILInstanceTime>    mBeginInstances;
+  nsTArray<nsSMILInstanceTime>    mEndInstances;
+
+  nsSMILAnimationFunction         *mClient;
+  nsRefPtr<nsSMILInterval>        mCurrentInterval;
+  SMILIntervalList                mOldIntervals;
+  nsRefPtr<nsSMILTimedDocumentRoot> mDocumentRoot;
+
+  /**
+   * The state of the element in its life-cycle. These states are based on the
+   * element life-cycle described in SMILANIM 3.6.8
+   */
+  enum nsSMILElementState
+  {
+    state_startup,
+    state_waiting,
+    state_active,
+    state_postactive
+  };
+  nsSMILElementState              mElementState;
+};
+
+//----------------------------------------------------------------------
+// Static members
+
+nsSMILEnumMapping nsSMILTimedElement::sFillModeMap[] = {
+      {&nsGkAtoms::remove, fill_remove},
+      {&nsGkAtoms::freeze, fill_freeze},
+      {nsnull, 0}
+};
+
+nsSMILEnumMapping nsSMILTimedElement::sRestartModeMap[] = {
+      {&nsGkAtoms::always, restart_always},
+      {&nsGkAtoms::whennotactive, restart_whennotactive},
+      {&nsGkAtoms::never, restart_never},
+      {nsnull, 0}
+};
+
+//----------------------------------------------------------------------
+// Factory method
+
+nsISMILTimedElement* NS_NewSMILTimedElement()
+{
+  nsSMILTimedElement* element = new nsSMILTimedElement();
+
+  if (element && NS_FAILED(element->Init())) {
+      delete element;
+      return nsnull;
+  }
+
+  return element;
+}
+
+//----------------------------------------------------------------------
+// Ctor, dtor
+
+nsSMILTimedElement::nsSMILTimedElement()
+:
+  mBeginSpecs(),
+  mEndSpecs(),
+  mBeginSpecSet(PR_FALSE),
+  mFillMode(fill_remove, sFillModeMap),
+  mRestartMode(restart_always, sRestartModeMap),
+  mEndHasEventConditions(PR_FALSE),
+  mClient(nsnull),
+  mElementState(state_startup)
+{
+  mSimpleDur.SetIndefinite();
+  mMin.SetMillis(LL_Zero());
+  mMax.SetIndefinite();
+}
+
+nsresult
+nsSMILTimedElement::Init()
+{
+  mCurrentInterval = new nsSMILInterval();
+
+  return (mCurrentInterval) ? NS_OK : NS_ERROR_FAILURE;
+}
+
+//----------------------------------------------------------------------
+// nsISupports
+
+NS_IMPL_ISUPPORTS3(nsSMILTimedElement,
+                   nsISMILTimedElement,
+                   nsIDOMElementTimeControl,
+                   nsISupportsWeakReference)
+
+//----------------------------------------------------------------------
+// nsIDOMElementTimeControl methods
+//
+// The definition of the ElementTimeControl interface differs between SMIL
+// Animation and SVG 1.1. In SMIL Animation all methods have a void return
+// type and the new instance time is simply added to the list and restart
+// semantics are applied as with any other instance time. In the SVG definition
+// the methods return a bool depending on the restart mode. There are some
+// cases where this is problematic.
+//
+// For example, if a call is made to beginElementAt and the resolved time
+// after including the offset falls outside the current interval then using
+// the SMIL Animation definition an element with restart == whenNotActive
+// would restart with this new instance time. The SVG definition however seems
+// to imply that in this case the implementation should ignore the new
+// instance time if the restart mode == whenNotActive and the element is
+// currently active and return false.
+//
+// It is tempting to try and determine when a new instance time will actually
+// cause a restart but this is not possible as in the meantime a new event may
+// trump the new instance time. We take a compromise of returning true and
+// false according to the SVG definition but adding the instance time to the
+// list regardless. This may produce different results to an implementation that
+// follows strictly the behaviour implied by the SVG spec.
+//
+
+/* boolean beginElement (); */
+NS_IMETHODIMP
+nsSMILTimedElement::BeginElement(PRBool *_retval)
+{
+  return BeginElementAt(0.0, _retval);
+}
+
+// XXXdholbert share code with EndElementAt?
+/* boolean beginElementAt (in float offset); */
+NS_IMETHODIMP
+nsSMILTimedElement::BeginElementAt(float offset, PRBool *_retval)
+{
+  // If restart == never or restart == whenNotActive, check whether we're
+  // in a state that allows us to restart.
+  if ((mRestartMode.GetIntegerValue() == restart_never &&
+       (mElementState == state_active || mElementState == state_postactive)) ||
+      (mRestartMode.GetIntegerValue() == restart_whennotactive &&
+       mElementState == state_active)) {
+    *_retval = PR_FALSE;
+    return NS_OK;
+  }
+
+  if (!mDocumentRoot) {
+    *_retval = PR_FALSE;
+    NS_ERROR("Attempting to begin but there is no document root.");
+    return NS_ERROR_FAILURE;
+  }
+
+  PRInt64 offsetVal;
+  LL_D2L(offsetVal, offset);
+  PRInt64 timeWithOffset;
+  LL_ADD(timeWithOffset, mDocumentRoot->GetDocumentTime(), offsetVal);
+  nsSMILTimeValue timeVal;
+  timeVal.SetMillis(timeWithOffset);
+
+  nsSMILInstanceTime *instanceTime = 
+    new nsSMILInstanceTime(timeVal, nsnull, PR_TRUE);
+  NS_ENSURE_TRUE(instanceTime, NS_ERROR_OUT_OF_MEMORY);
+  AddInstanceTime(*instanceTime, PR_TRUE);
+  delete instanceTime;
+
+  *_retval = PR_TRUE;
+  return NS_OK;
+}
+
+/* boolean endElement (); */
+NS_IMETHODIMP
+nsSMILTimedElement::EndElement(PRBool *_retval)
+{
+  return EndElementAt(0.0, _retval);
+}
+
+/* boolean endElementAt (in float offset); */
+NS_IMETHODIMP
+nsSMILTimedElement::EndElementAt(float offset, PRBool *_retval)
+{
+  if (mElementState != state_active)
+    *_retval = PR_FALSE;
+
+  if (!mDocumentRoot) {
+    *_retval = PR_FALSE;
+    NS_ERROR("Attempting to end but there is no document root.");
+    return NS_ERROR_FAILURE;
+  }
+
+  PRInt64 offsetVal;
+  LL_D2L(offsetVal, offset);
+  PRInt64 timeWithOffset;
+  LL_ADD(timeWithOffset, mDocumentRoot->GetDocumentTime(), offsetVal);
+  nsSMILTimeValue timeVal;
+  timeVal.SetMillis(timeWithOffset);
+
+  nsSMILInstanceTime *instanceTime = 
+    new nsSMILInstanceTime(timeVal, nsnull, PR_TRUE);
+  NS_ENSURE_TRUE(instanceTime, NS_ERROR_OUT_OF_MEMORY);
+  AddInstanceTime(*instanceTime, PR_FALSE);
+  delete instanceTime;
+
+  *_retval = PR_TRUE;
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// nsISMILTimedElement
+
+void
+nsSMILTimedElement::AddInstanceTime(const nsSMILInstanceTime& aInstanceTime,
+                                    PRBool aIsBegin)
+{
+  if (aIsBegin)
+    mBeginInstances.AppendElement(aInstanceTime);
+  else
+    mEndInstances.AppendElement(aInstanceTime);
+
+  UpdateCurrentInterval();
+}
+
+void
+nsSMILTimedElement::SetDocumentRoot(nsSMILTimedDocumentRoot* aRoot)
+{
+  mDocumentRoot = aRoot;
+}
+
+void
+nsSMILTimedElement::SetTimeClient(nsSMILAnimationFunction* aClient)
+{
+  //
+  // No need to check for NULL. A NULL parameter simply means to remove the
+  // previous client which we do by setting to NULL anyway.
+  //
+
+  mClient = aClient;
+}
+
+void
+nsSMILTimedElement::SampleAt(const PRInt64& aDocumentTime)
+{
+  PRBool          stateChanged;
+  nsSMILTimeValue docTime;
+  docTime.SetMillis(aDocumentTime);
+
+  // XXX Cache previous sample time and if this time is less then perform
+  // backwards seeking behaviour (see SMILANIM 3.6.5 Hyperlinks and timing)
+
+  do {
+    stateChanged = false;
+
+    switch (mElementState)
+    {
+    case state_startup:
+      {
+        nsSMILTimeValue beginAfter;
+        beginAfter.SetMillis(LL_MININT);
+
+        mElementState = 
+          (NS_SUCCEEDED(GetNextInterval(beginAfter, true, *mCurrentInterval)))
+          ? state_waiting
+          : state_postactive;
+        stateChanged = true;
+      }
+      break;
+
+    case state_waiting:
+      {
+        if (mCurrentInterval->Begin().CompareTo(docTime) <= 0) {
+          mElementState = state_active;
+          if (mClient) {
+            mClient->Activate(mCurrentInterval->Begin().GetMillis());
+          }
+          stateChanged = true;
+        }
+      }
+      break;
+
+    case state_active:
+      {
+        CheckForEarlyEnd(docTime);
+        if (mCurrentInterval->End().CompareTo(docTime) <= 0) {
+          nsRefPtr<nsSMILInterval> newInterval(new nsSMILInterval());
+          mElementState = 
+            (NS_SUCCEEDED(GetNextInterval(mCurrentInterval->End(),
+                                          false,
+                                          *newInterval)))
+            ? state_waiting
+            : state_postactive;
+          if (mClient) {
+            mClient->Inactivate(mFillMode.GetIntegerValue() == fill_freeze);
+          }
+          SampleFillValue();
+          mOldIntervals.AppendElement(mCurrentInterval);
+          mCurrentInterval = newInterval;
+          Reset();
+          stateChanged = true;
+        } else {
+          PRInt64 beginTime = mCurrentInterval->Begin().GetMillis();
+
+          PRInt64 activeTime;
+          LL_SUB(activeTime, aDocumentTime, beginTime);
+
+          SampleSimpleTime(activeTime);
+        }
+      }
+      break;
+
+    case state_postactive:
+      break;
+    }
+  } while (stateChanged);
+}
+
+void
+nsSMILTimedElement::Reset(PRBool aHardReset /* = PR_FALSE */)
+{
+  PRInt32 count = mBeginInstances.Length();
+
+  for (PRInt32 i = 0; i < count; ++i) {
+    nsSMILInstanceTime &instance = mBeginInstances[0];
+    if (instance.ClearOnReset()) {
+      mBeginInstances.RemoveElementAt(0);
+    }
+  }
+
+  count = mEndInstances.Length();
+
+  for (PRInt32 j = 0; j < count; ++j) {
+    nsSMILInstanceTime &instance = mEndInstances[0];
+    if (instance.ClearOnReset()) {
+      mEndInstances.RemoveElementAt(0);
+    }
+  }
+
+  if (aHardReset) {
+    mCurrentInterval = new nsSMILInterval();
+    mElementState    = state_startup;
+    mOldIntervals.Clear();
+
+    // Remove any fill
+    if (mClient) {
+      mClient->Inactivate(PR_FALSE);
+    }
+  }
+}
+
+PRBool
+nsSMILTimedElement::SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                            nsresult* aResult)
+{
+  PRBool rv = PR_TRUE;
+  nsresult result = NS_OK;
+
+  if (aAttribute == nsGkAtoms::begin) {
+    result = SetBeginSpec(aValue);
+  } else if (aAttribute == nsGkAtoms::dur) {
+    result = SetSimpleDuration(aValue);
+  } else if (aAttribute == nsGkAtoms::end) {
+    result = SetEndSpec(aValue);
+  } else if (aAttribute == nsGkAtoms::fill) {
+    result = SetFillMode(aValue);
+  } else if (aAttribute == nsGkAtoms::max) {
+    result = SetMax(aValue);
+  } else if (aAttribute == nsGkAtoms::min) {
+    result = SetMin(aValue);
+  } else if (aAttribute == nsGkAtoms::repeatCount) {
+    result = SetRepeatCount(aValue);
+  } else if (aAttribute == nsGkAtoms::repeatDur) {
+    result = SetRepeatDur(aValue);
+  } else if (aAttribute == nsGkAtoms::restart) {
+    result = SetRestart(aValue);
+  } else {
+    rv = PR_FALSE;
+  }
+
+  if (rv && aResult) {
+    *aResult = result;
+  }
+
+  return rv;
+}
+
+PRBool
+nsSMILTimedElement::UnsetAttr(nsIAtom* aAttribute)
+{
+  PRBool rv = PR_TRUE;
+
+  if (aAttribute == nsGkAtoms::begin) {
+    UnsetBeginSpec();
+  } else if (aAttribute == nsGkAtoms::dur) {
+    UnsetSimpleDuration();
+  } else if (aAttribute == nsGkAtoms::end) {
+    UnsetEndSpec();
+  } else if (aAttribute == nsGkAtoms::fill) {
+    UnsetFillMode();
+  } else if (aAttribute == nsGkAtoms::max) {
+    UnsetMax();
+  } else if (aAttribute == nsGkAtoms::min) {
+    UnsetMin();
+  } else if (aAttribute == nsGkAtoms::repeatCount) {
+    UnsetRepeatCount();
+  } else if (aAttribute == nsGkAtoms::repeatDur) {
+    UnsetRepeatDur();
+  } else if (aAttribute == nsGkAtoms::restart) {
+    UnsetRestart();
+  } else {
+    rv = PR_FALSE;
+  }
+
+  return rv;
+}
+
+//----------------------------------------------------------------------
+// Setters and unsetters
+
+nsresult
+nsSMILTimedElement::SetBeginSpec(const nsAString& aBeginSpec)
+{
+  mBeginSpecSet = PR_TRUE;
+  return SetBeginOrEndSpec(aBeginSpec, PR_TRUE);
+}
+
+void
+nsSMILTimedElement::UnsetBeginSpec()
+{
+  mBeginSpecs.Clear();
+  mBeginInstances.Clear();
+  mBeginSpecSet = PR_FALSE;
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetEndSpec(const nsAString& aEndSpec)
+{
+  //
+  // When implementing events etc., don't forget to ensure
+  // mEndHasEventConditions is set if the specification contains conditions that
+  // describe event-values, repeat-values or accessKey-values.
+  //
+  return SetBeginOrEndSpec(aEndSpec, PR_FALSE);
+}
+
+void
+nsSMILTimedElement::UnsetEndSpec()
+{
+  mEndSpecs.Clear();
+  mEndInstances.Clear();
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetSimpleDuration(const nsAString& aDurSpec)
+{
+  nsSMILTimeValue duration;
+  PRBool isMedia;
+  nsresult rv;
+  
+  rv = nsSMILParserUtils::GetClockValue(aDurSpec,
+                                        &duration,
+                                        false, // don't allow + or -
+                                        true,  // allow indefinite
+                                        true,  // allow media
+                                        &isMedia);
+
+  if (NS_FAILED(rv) || (!duration.IsResolved() && !duration.IsIndefinite()))
+    return NS_ERROR_FAILURE;
+  
+  if (duration.IsResolved() && LL_IS_ZERO(duration.GetMillis()))
+    return NS_ERROR_FAILURE;
+
+  //
+  // SVG-specific: "For SVG's animation elements, if "media" is specified, the
+  // attribute will be ignored." (SVG 1.1, section 19.2.6)
+  //
+  if (isMedia)
+    duration.SetIndefinite();
+
+  mSimpleDur = duration;
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedElement::UnsetSimpleDuration()
+{
+  mSimpleDur.SetIndefinite();
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetMin(const nsAString& aMinSpec)
+{
+  nsSMILTimeValue duration;
+  PRBool isMedia;
+  nsresult rv;
+  
+  rv = nsSMILParserUtils::GetClockValue(aMinSpec,
+                                        &duration,
+                                        false, // don't allow + or -
+                                        false, // don't allow indefinite
+                                        true,  // allow media
+                                        &isMedia);
+
+  if (isMedia)
+    duration.SetMillis(LL_Zero());
+
+  if (NS_FAILED(rv) || !duration.IsResolved()) {
+    mMin.SetMillis(LL_Zero());
+    return NS_ERROR_FAILURE;
+  }
+  
+  if (!LL_GE_ZERO(duration.GetMillis())) {
+    mMin.SetMillis(LL_Zero());
+    return NS_ERROR_FAILURE;
+  }
+
+  mMin = duration;
+  UpdateCurrentInterval();
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedElement::UnsetMin()
+{
+  mMin.SetMillis(LL_Zero());
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetMax(const nsAString& aMaxSpec)
+{
+  nsSMILTimeValue duration;
+  PRBool isMedia;
+  nsresult rv;
+  
+  rv = nsSMILParserUtils::GetClockValue(aMaxSpec,
+                                        &duration,
+                                        false, // don't allow + or -
+                                        true,  // allow indefinite
+                                        true,  // allow media
+                                        &isMedia);
+
+  if (isMedia)
+    duration.SetIndefinite();
+
+  if (NS_FAILED(rv) || (!duration.IsResolved() && !duration.IsIndefinite())) {
+    mMax.SetIndefinite();
+    return NS_ERROR_FAILURE;
+  }
+  
+  if (duration.IsResolved() &&
+      (!LL_GE_ZERO(duration.GetMillis()) || LL_IS_ZERO(duration.GetMillis()))) {
+    mMax.SetIndefinite();
+    return NS_ERROR_FAILURE;
+  }
+
+  mMax = duration;
+  UpdateCurrentInterval();
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedElement::UnsetMax()
+{
+  mMax.SetIndefinite();
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetRestart(const nsAString& aRestartSpec)
+{
+  nsresult rv = mRestartMode.SetStringValue(aRestartSpec);
+  UpdateCurrentInterval();
+  return rv;
+}
+
+void
+nsSMILTimedElement::UnsetRestart()
+{
+  mRestartMode.SetIntegerValue(restart_always);
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetRepeatCount(const nsAString& aRepeatCountSpec)
+{
+  nsSMILTimeValue newRepeatCount;
+  nsresult rv = 
+    nsSMILParserUtils::GetRepeatCount(aRepeatCountSpec, newRepeatCount);
+
+  UpdateCurrentInterval();
+
+  if (NS_SUCCEEDED(rv)) {
+    mRepeatCount = newRepeatCount;
+  } else {
+    mRepeatCount.SetUnresolved();
+  }
+    
+  return rv;
+}
+
+void
+nsSMILTimedElement::UnsetRepeatCount()
+{
+  mRepeatCount.SetUnresolved();
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetRepeatDur(const nsAString& aRepeatDurSpec)
+{
+  nsresult        rv;
+  nsSMILTimeValue duration;
+
+  rv = nsSMILParserUtils::GetClockValue(aRepeatDurSpec,
+                                        &duration,
+                                        false,  // don't allow + or -
+                                        true);  // allow indefinite
+
+  if (NS_FAILED(rv) || (!duration.IsResolved() && !duration.IsIndefinite()))
+    return NS_ERROR_FAILURE;
+  
+  UpdateCurrentInterval();
+  
+  mRepeatDur = duration;
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedElement::UnsetRepeatDur()
+{
+  mRepeatDur.SetUnresolved();
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetFillMode(const nsAString& aFillModeSpec)
+{
+  PRUint16 previousFillMode = mFillMode.GetIntegerValue();
+  nsresult rv = mFillMode.SetStringValue(aFillModeSpec);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (previousFillMode == mFillMode.GetIntegerValue())
+    return NS_OK;
+
+  if ((mElementState == state_waiting || mElementState == state_postactive) &&
+      mClient)
+      mClient->Inactivate(mFillMode.GetIntegerValue() == fill_freeze);
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedElement::UnsetFillMode()
+{
+  PRUint16 previousFillMode = mFillMode.GetIntegerValue();
+  mFillMode.SetIntegerValue(fill_remove);
+  if ((mElementState == state_waiting || mElementState == state_postactive) &&
+      previousFillMode == fill_freeze &&
+      mClient)
+    mClient->Inactivate(PR_FALSE);
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+nsresult
+nsSMILTimedElement::SetBeginOrEndSpec(const nsAString& aSpec,
+                                      PRBool aIsBegin)
+{
+  nsRefPtr<nsSMILTimeValueSpec>    spec;
+  SMILTimeValueSpecList& timeSpecsList = (aIsBegin)
+                                       ? mBeginSpecs
+                                       : mEndSpecs;
+  nsTArray<nsSMILInstanceTime>&  instancesList = (aIsBegin)
+                                               ? mBeginInstances
+                                               : mEndInstances;
+
+  timeSpecsList.Clear();
+  instancesList.Clear();
+
+  PRInt32 start;
+  PRInt32 end = -1;
+  PRInt32 length;
+
+  do {
+    start        = end + 1;
+    end          = aSpec.FindChar(';', start);
+    length       = (end == -1) ? -1 : end - start;
+
+    spec = NS_NewSMILTimeValueSpec(this, aIsBegin,
+                                   Substring(aSpec, start, length));
+
+    if (spec)
+      timeSpecsList.AppendElement(spec);
+  } while (end != -1 && spec);
+
+  if (!spec) {
+    timeSpecsList.Clear();
+    instancesList.Clear();
+    Reset(PR_TRUE);
+    return NS_ERROR_FAILURE;
+  }
+
+  UpdateCurrentInterval();
+
+  return NS_OK;
+}
+
+//
+// This method is based on the pseudocode given in the SMILANIM spec.
+//
+// See:
+// http://www.w3.org/TR/2001/REC-smil-animation-20010904/#Timing-BeginEnd-LC-Start
+//
+nsresult
+nsSMILTimedElement::GetNextInterval(const nsSMILTimeValue& aBeginAfter,
+                                    PRBool aFirstInterval,
+                                    nsSMILInterval& aResult)
+{
+  static nsSMILTimeValue zeroTime;
+  zeroTime.SetMillis(LL_Zero());
+  
+  nsSMILTimeValue beginAfter = aBeginAfter;
+  nsSMILTimeValue tempBegin;
+  nsSMILTimeValue tempEnd;
+  PRInt32         beginPos = 0;
+  PRInt32         endPos = 0;
+
+  //
+  // This is to handle the special case when a we are calculating the first
+  // interval and we have a non-0-duration interval immediately after
+  // a 0-duration in which case but we have to be careful not to re-use an end
+  // that has already been used in another interval. See the pseudocode in
+  // SMILANIM 3.6.8 for getFirstInterval.
+  //
+  PRInt32         endMaxPos = 0;
+
+  if (mRestartMode.GetIntegerValue() == restart_never && !aFirstInterval)
+    return NS_ERROR_FAILURE;
+
+  nsSMILInstanceTime::Comparator comparator;
+  mBeginInstances.Sort(comparator);
+  mEndInstances.Sort(comparator);
+
+  while (true) {
+    if (!mBeginSpecSet && beginAfter.CompareTo(zeroTime) <= 0) {
+      tempBegin.SetMillis(0);
+    } else {
+      PRBool beginFound = GetNextGreater(mBeginInstances, beginAfter,
+                                         beginPos, tempBegin);
+      if (!beginFound)
+        return NS_ERROR_FAILURE;
+    }
+
+    if (mEndInstances.Length() == 0) {
+      nsSMILTimeValue indefiniteEnd;
+      indefiniteEnd.SetIndefinite();
+
+      tempEnd = CalcActiveEnd(tempBegin, indefiniteEnd);
+    } else {
+      // 
+      // Start searching from the beginning again.
+      //
+      endPos = 0;
+
+      PRBool endFound = GetNextGreater(mEndInstances, tempBegin,
+                                       endPos, tempEnd);
+
+      if ((!aFirstInterval && tempEnd.CompareTo(aBeginAfter) == 0) ||
+          (aFirstInterval && tempEnd.CompareTo(tempBegin) == 0 && 
+           endPos <= endMaxPos)) {
+        endFound = GetNextGreater(mEndInstances, tempBegin, endPos, tempEnd);
+      }
+
+      endMaxPos = endPos;
+
+      if (!endFound) {
+        if (mEndHasEventConditions || mEndInstances.Length() == 0) {
+          tempEnd.SetUnresolved();
+        } else {
+          // 
+          // This is a little counter-intuitive but according to SMILANIM, if
+          // all the end's are after the begin, we _don't_ just assume an
+          // infinite end, it's actually a bad interval. ASV however will just
+          // use an infinite end.
+          // 
+          return NS_ERROR_FAILURE;
+        }
+      }
+
+      tempEnd = CalcActiveEnd(tempBegin, tempEnd);
+    }
+
+    if (tempEnd.CompareTo(zeroTime) > 0) {
+      aResult.UpdateBegin(tempBegin);
+      aResult.UpdateEnd(tempEnd);
+      return NS_OK;
+    } else if (mRestartMode.GetIntegerValue() == restart_never) {
+      return NS_ERROR_FAILURE;
+    } else {
+      beginAfter = tempEnd;
+    }
+  }
+  NS_NOTREACHED("Hmm... we really shouldn't be here");
+
+  return NS_ERROR_FAILURE;
+}
+
+PRBool
+nsSMILTimedElement::GetNextGreater(const nsTArray<nsSMILInstanceTime>& aList,
+                                   const nsSMILTimeValue& aBase,
+                                   PRInt32 &aPosition,
+                                   nsSMILTimeValue& aResult)
+{
+    PRBool              found = PR_FALSE;
+    PRInt32             count = aList.Length();
+
+    for (; aPosition < count && !found; ++aPosition) {
+      const nsSMILInstanceTime &val = aList[aPosition];
+      if (val.Time().CompareTo(aBase) >= 0) {
+        aResult = val.Time();
+        found = PR_TRUE;
+      }
+    }
+
+    return found;
+}
+
+inline PRInt64
+nsSMILTimedElement::MinLL(const PRInt64& a, const PRInt64& b)
+{
+  return (LL_CMP(a, <, b)) ? a : b;
+}
+
+/**
+ * @see SMILANIM 3.3.4
+ */
+nsSMILTimeValue
+nsSMILTimedElement::CalcActiveEnd(const nsSMILTimeValue& aBegin,
+                                  const nsSMILTimeValue& aEnd)
+{
+  nsSMILTimeValue result;
+
+  if (!mSimpleDur.IsIndefinite() && !mSimpleDur.IsResolved()) {
+    NS_ERROR("Unresolved simple duration in CalcActiveEnd.");
+    result.SetIndefinite();
+    return result;
+  }
+
+  if (!aBegin.IsResolved() && !aBegin.IsIndefinite()) {
+    NS_ERROR("Unresolved begin time passed to CalcActiveEnd.");
+    result.SetIndefinite();
+    return result;
+  }
+
+  if (mRepeatDur.IsIndefinite() || aBegin.IsIndefinite()) {
+    result.SetIndefinite();
+  } else {
+    result = GetRepeatDuration();
+  }
+
+  if (aEnd.IsResolved() && aBegin.IsResolved()) {
+    PRInt64 activeDur;
+    LL_SUB(activeDur, aEnd.GetMillis(), aBegin.GetMillis());
+
+    if (result.IsResolved()) {
+      result.SetMillis(MinLL(result.GetMillis(), activeDur));
+    } else {
+      result.SetMillis(activeDur);
+    }
+  }
+
+  result = ApplyMinAndMax(result);
+
+  if (result.IsResolved()) {
+    PRInt64 activeEnd;
+    LL_ADD(activeEnd, result.GetMillis(), aBegin.GetMillis());
+    result.SetMillis(activeEnd);
+  }
+
+  return result;
+}
+
+nsSMILTimeValue
+nsSMILTimedElement::GetRepeatDuration()
+{
+  nsSMILTimeValue result;
+
+  if (mRepeatCount.IsResolved() && mRepeatDur.IsResolved()) {
+    if (mSimpleDur.IsResolved()) {
+      PRInt64 activeDur;
+      LL_MUL(activeDur, mRepeatCount.GetMillis(), mSimpleDur.GetMillis());
+      LL_DIV(activeDur, activeDur, 1000);
+      result.SetMillis(MinLL(activeDur, mRepeatDur.GetMillis()));
+    } else {
+      result = mRepeatDur;
+    }
+  } else if (mRepeatCount.IsResolved() && mSimpleDur.IsResolved()) {
+    PRInt64 activeDur;
+    LL_MUL(activeDur, mRepeatCount.GetMillis(), mSimpleDur.GetMillis());
+    LL_DIV(activeDur, activeDur, 1000);
+    result.SetMillis(activeDur);
+  } else if (mRepeatDur.IsResolved()) {
+    result = mRepeatDur;
+  } else if (mRepeatCount.IsIndefinite()) {
+    result.SetIndefinite();
+  } else {
+    result = mSimpleDur;
+  }
+
+  return result;
+}
+
+nsSMILTimeValue
+nsSMILTimedElement::ApplyMinAndMax(const nsSMILTimeValue& aDuration)
+{
+  if (!aDuration.IsResolved() && !aDuration.IsIndefinite()) {
+    return aDuration;
+  }
+
+  if (mMax.CompareTo(mMin) < 0) {
+    return aDuration;
+  }
+
+  nsSMILTimeValue result;
+
+  if (aDuration.CompareTo(mMax) > 0) {
+    result = mMax;
+  } else if (aDuration.CompareTo(mMin) < 0) {
+    nsSMILTimeValue repeatDur = GetRepeatDuration();
+    result = (mMin.CompareTo(repeatDur) > 0) ? repeatDur : mMin;
+  } else {
+    result = aDuration;
+  }
+
+  return result;
+}
+
+PRInt64
+nsSMILTimedElement::ActiveTimeToSimpleTime(const PRInt64& aActiveTime,
+                                           PRUint32& aRepeatIteration)
+{
+  PRInt64 result;
+
+  NS_ASSERTION(mSimpleDur.IsResolved() || mSimpleDur.IsIndefinite(),
+      "Trying to calculate active time with unresolved duration");
+
+  if (mSimpleDur.IsIndefinite() || LL_IS_ZERO(mSimpleDur.GetMillis())) {
+    aRepeatIteration = 0;
+    result = aActiveTime;
+  } else {    
+    PRInt64 repeatResult;
+    LL_MOD(result, aActiveTime, mSimpleDur.GetMillis());
+    LL_DIV(repeatResult, aActiveTime, mSimpleDur.GetMillis());
+
+    LL_L2UI(aRepeatIteration, repeatResult);
+  }
+
+  return result;
+}
+
+//
+// Although in many cases it would be possible to check for an early end and
+// adjust the current interval well in advance the SMIL Animation spec seems to
+// indicate that we should only apply an early end at the latest possible
+// moment. In particular, this paragraph from section 3.6.8:
+//
+// 'If restart  is set to "always", then the current interval will end early if
+// there is an instance time in the begin list that is before (i.e. earlier
+// than) the defined end for the current interval. Ending in this manner will
+// also send a changed time notice to all time dependents for the current
+// interval end.'
+//
+void
+nsSMILTimedElement::CheckForEarlyEnd(const nsSMILTimeValue& aDocumentTime)
+{
+  if (mRestartMode.GetIntegerValue() != restart_always)
+    return;
+
+  nsSMILTimeValue nextBegin;
+  PRInt32 position = 0;
+
+  // 
+  // Despite its name, GetNextGreater actually gets the next instance time that
+  // is greater than _or_equal_to_ the reference time so we have to loop to make
+  // sure we're getting an instance time that is actually _after_ the interval
+  // begin time
+  //
+  while (GetNextGreater(mBeginInstances, mCurrentInterval->Begin(),
+                        position, nextBegin) &&
+         nextBegin.CompareTo(mCurrentInterval->Begin()) == 0);
+        
+  if (nextBegin.IsResolved() && 
+      nextBegin.CompareTo(mCurrentInterval->Begin()) > 0 &&
+      nextBegin.CompareTo(mCurrentInterval->End()) < 0 &&
+      nextBegin.CompareTo(aDocumentTime) <= 0) {
+    mCurrentInterval->UpdateEnd(nextBegin);
+  }
+}
+
+void
+nsSMILTimedElement::UpdateCurrentInterval()
+{
+  if (mElementState == state_startup)
+    return;
+
+  nsRefPtr<nsSMILInterval> updatedInterval = new nsSMILInterval();
+  PRBool isFirstInterval = mOldIntervals.IsEmpty();
+
+  nsSMILTimeValue beginAfter;
+  if (!isFirstInterval) {
+    beginAfter = mOldIntervals[mOldIntervals.Length() - 1]->End();
+  } else {
+    beginAfter.SetMillis(LL_MININT);
+  }
+
+  nsresult rv = 
+    GetNextInterval(beginAfter, isFirstInterval, *updatedInterval);
+
+  if (NS_SUCCEEDED(rv)) {
+
+    if (mElementState != state_active &&
+        updatedInterval->Begin().CompareTo(mCurrentInterval->Begin())) {
+      mCurrentInterval->UpdateBegin(updatedInterval->Begin());
+    }
+
+    if (updatedInterval->End().CompareTo(mCurrentInterval->End())) {
+      mCurrentInterval->UpdateEnd(updatedInterval->End());
+    }
+
+    if (mElementState == state_postactive) {
+      // XXX notify dependents of new interval
+      mElementState = state_waiting;
+    }
+  } else {
+
+    nsSMILTimeValue unresolvedTime;
+    mCurrentInterval->UpdateEnd(unresolvedTime);
+    if (mElementState != state_active) {
+      mCurrentInterval->UpdateBegin(unresolvedTime);
+    }
+
+    if (mElementState == state_waiting) {
+      // XXX notify dependents the current interval has been deleted
+      mElementState = state_postactive;
+    }
+
+    if (mElementState == state_active) {
+      // XXX notify dependents the current interval has been deleted
+      mElementState = state_postactive;
+      if (mClient) {
+        mClient->Inactivate(PR_FALSE);
+      }
+    }
+  }
+}
+
+void
+nsSMILTimedElement::SampleSimpleTime(PRInt64 aActiveTime)
+{
+  if (mClient) {
+    PRUint32 repeatIteration;
+    PRInt64  simpleTime = 
+      ActiveTimeToSimpleTime(aActiveTime, repeatIteration);
+    mClient->SampleAt(simpleTime, mSimpleDur, repeatIteration);
+  }
+}
+
+void
+nsSMILTimedElement::SampleFillValue()
+{
+  if (mFillMode.GetIntegerValue() != fill_freeze)
+    return;
+
+  if (!mClient)
+    return;
+
+  PRUint32 repeatIteration;
+  PRInt64 activeTime;
+  LL_SUB(activeTime,
+         mCurrentInterval->End().GetMillis(),
+         mCurrentInterval->Begin().GetMillis());
+
+  PRInt64  simpleTime = 
+    ActiveTimeToSimpleTime(activeTime, repeatIteration);
+
+  if (LL_IS_ZERO(simpleTime)) {
+    mClient->SampleLastValue(--repeatIteration);
+  } else {
+    mClient->SampleAt(simpleTime, mSimpleDur, repeatIteration);
+  }
+}
diff --git a/content/smil/src/test/Makefile.in b/content/smil/src/test/Makefile.in
new file mode 100644
--- /dev/null
+++ b/content/smil/src/test/Makefile.in
@@ -0,0 +1,51 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla SMIL module.
+#
+# The Initial Developer of the Original Code is
+# Mozilla Corporation.
+# Portions created by the Initial Developer are Copyright (C) 2008
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Daniel Holbert <dholbert@mozilla.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+DEPTH		= ../../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+relativesrcdir  = content/smil/src/test
+
+include $(DEPTH)/config/autoconf.mk
+include $(topsrcdir)/config/rules.mk
+
+_TEST_FILES = 	test_smilRestart.xhtml \
+		$(NULL)
+
+libs:: $(_TEST_FILES)
+	$(INSTALL) $^ $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
diff --git a/content/smil/src/test/test_smilRestart.xhtml b/content/smil/src/test/test_smilRestart.xhtml
new file mode 100644
--- /dev/null
+++ b/content/smil/src/test/test_smilRestart.xhtml
@@ -0,0 +1,105 @@
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+  <title>Test for SMIL Restart Behavior </title>
+  <script type="text/javascript" src="/MochiKit/packed.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<p id="display"></p>
+<div id="content" style="display: none">
+<svg id="svg" xmlns="http://www.w3.org/2000/svg" width="120px" height="120px">
+  <!-- These 3 circles only differ in their animation's "restart" value -->
+  <circle cx="20" cy="20" r="15" fill="blue">
+    <animate attributeName="cx" from="20" to="100" begin="0s" dur="4s"
+             restart="always" id="always" attributeType="XML"/>
+  </circle>
+  <circle cx="20" cy="60" r="15" fill="blue">
+    <animate attributeName="cx" from="20" to="100" begin="0s" dur="4s"
+             restart="whenNotActive" id="whenNotActive" attributeType="XML"/>
+  </circle>
+  <circle cx="20" cy="100" r="15" fill="blue">
+    <animate attributeName="cx" from="20" to="100" begin="0s" dur="4s"
+             restart="never" id="never" attributeType="XML"/>
+  </circle>
+</svg>
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+<![CDATA[
+/** Test for SMIL Restart Behavior  **/
+
+/* Global Variables */
+var dur = 4.0; // this must match the "dur" attribute on animations above.
+var svg = document.getElementById("svg");
+
+SimpleTest.waitForExplicitFinish();
+
+// main: just triggers the first link in the chain of function-calls
+function main() {
+  checkInitialState();
+}
+
+// Attempt a "beginElement" call on the given element, and
+// complain if we don't get the expected return value.
+// 'time' is only provided for better diagnostic output.
+function tryRestartElem(id, time, expectedRetVal) {
+  var elem = document.getElementById(id); 
+  var retVal = elem.beginElement();
+  is(retVal, expectedRetVal,
+     "Error restarting animation '" + id + 
+     "' at time = " + time + ": " + 
+     "expected return value of " + expectedRetVal + 
+     ", but got " + retVal + ".");
+}
+
+function checkInitialState() {
+  svg.setCurrentTime(0.0);
+  setTimeout('doCheckInitialState(0.0)', 0);
+}
+function doCheckInitialState(time) {
+  tryRestartElem('always', time, true);
+  tryRestartElem('whenNotActive', time, false);
+  tryRestartElem('never', time, false);
+  checkHalfwayState();
+}
+
+function checkHalfwayState() {
+  svg.setCurrentTime(0.5 * dur);
+  setTimeout('doCheckHalfwayState(0.5 * dur)', 0);
+}
+function doCheckHalfwayState(time) {
+  tryRestartElem('always', time, true);
+  tryRestartElem('whenNotActive', time, false);
+  tryRestartElem('never', time, false);
+  checkEndingState();
+}
+
+function checkEndingState() {
+  svg.setCurrentTime(dur);
+  setTimeout('doCheckEndingState(dur)', 0);
+}
+function doCheckEndingState(time) {
+  tryRestartElem('always', time, true);
+  tryRestartElem('whenNotActive', time, true);
+  tryRestartElem('never', time, false);
+  checkAfterEndingState();
+}
+
+function checkAfterEndingState() {
+  svg.setCurrentTime(dur * 3);
+  setTimeout('doCheckAfterEndingState(dur * 3)', 0);
+}
+function doCheckAfterEndingState(time) {
+  tryRestartElem('always', time, true);
+  tryRestartElem('whenNotActive', time, true);
+  tryRestartElem('never', time, false);
+  SimpleTest.finish();
+}
+
+window.addEventListener("load", main, false);
+]]>
+</script>
+</pre>
+</body>
+</html>
diff --git a/content/svg/content/src/Makefile.in b/content/svg/content/src/Makefile.in
--- a/content/svg/content/src/Makefile.in
+++ b/content/svg/content/src/Makefile.in
@@ -16,16 +16,17 @@
 #
 # The Initial Developer of the Original Code is
 # Crocodile Clips Ltd.
 # Portions created by the Initial Developer are Copyright (C) 2001
 # the Initial Developer. All Rights Reserved.
 #
 # Contributor(s):
 #   Alex Fritze <alex.fritze@crocodile-clips.com>
+#   Chris Double  <chris.double@double.co.nz>
 #
 # Alternatively, the contents of this file may be used under the terms of
 # either of the GNU General Public License Version 2 or later (the "GPL"),
 # or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 # in which case the provisions of the GPL or the LGPL are applicable instead
 # of those above. If you wish to allow use of your version of this file only
 # under the terms of either the GPL or the LGPL, and not to allow others to
 # use your version of this file under the terms of the MPL, indicate your
@@ -134,16 +135,27 @@ CPPSRCS		= \
 		nsSVGTitleElement.cpp \
 		nsSVGTransform.cpp \
 		nsSVGTransformList.cpp \
 		nsSVGTransformListParser.cpp \
 		nsSVGUseElement.cpp \
 		nsSVGValue.cpp \
 		$(NULL)
 
+ifdef MOZ_SMIL
+CPPSRCS += nsSVGAnimateElement.cpp \
+           nsSVGAnimateTransformElement.cpp \
+           nsSVGAnimationElement.cpp \
+           nsSVGAnimationSpec.cpp \
+           nsSVGSetElement.cpp \
+           nsSVGTransformSMILType.cpp \
+           nsSVGTransformSMILAttr.cpp \
+           $(NULL)
+endif
+
 include $(topsrcdir)/config/config.mk
 
 # we don't want the shared lib, but we want to force the creation of a static lib.
 FORCE_STATIC_LIB = 1
 
 EXPORTS =  			\
 	nsIDOMSVGListener.h \
 	nsIDOMSVGZoomListener.h \
@@ -152,17 +164,16 @@ EXPORTS =  			\
 	nsISVGValueObserver.h      \
 	nsISVGValueUtils.h         \
 	nsSVGNumber.h              \
 	nsSVGRect.h                \
 	nsSVGPoint.h               \
 	nsSVGMatrix.h              \
 	$(NULL)
 
-
 include $(topsrcdir)/config/rules.mk
 
 INCLUDES += 	\
 		-I$(srcdir)/../../../shared/public \
 		-I$(srcdir)/../../../html/base/src \
 		-I$(srcdir)/../../../xml/content/src \
 		-I$(srcdir)/../../../../dom \
 		-I$(srcdir)/../../../base/src \
diff --git a/content/svg/content/src/nsSVGAnimateElement.cpp b/content/svg/content/src/nsSVGAnimateElement.cpp
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGAnimateElement.cpp
@@ -0,0 +1,101 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGAnimationElement.h"
+#include "nsIDOMSVGAnimateElement.h"
+
+typedef nsSVGAnimationElement nsSVGAnimateElementBase;
+
+class nsSVGAnimateElement : public nsSVGAnimateElementBase,
+                            public nsIDOMSVGAnimateElement
+{
+protected:
+  friend nsresult NS_NewSVGAnimateElement(nsIContent **aResult,
+                                          nsINodeInfo *aNodeInfo);
+  nsSVGAnimateElement(nsINodeInfo* aNodeInfo);
+  nsresult Init();
+
+public:
+  // interfaces:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIDOMSVGANIMATEELEMENT
+
+  NS_FORWARD_NSIDOMNODE(nsSVGAnimateElementBase::)
+  NS_FORWARD_NSIDOMELEMENT(nsSVGAnimateElementBase::)
+  NS_FORWARD_NSIDOMSVGELEMENT(nsSVGAnimateElementBase::)
+  NS_FORWARD_NSIDOMSVGANIMATIONELEMENT(nsSVGAnimateElementBase::)
+  
+  // nsIDOMNode
+  virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
+};
+
+NS_IMPL_NS_NEW_SVG_ELEMENT(Animate)
+
+
+//----------------------------------------------------------------------
+// nsISupports methods
+
+NS_IMPL_ADDREF_INHERITED(nsSVGAnimateElement,nsSVGAnimateElementBase)
+NS_IMPL_RELEASE_INHERITED(nsSVGAnimateElement,nsSVGAnimateElementBase)
+
+NS_INTERFACE_MAP_BEGIN(nsSVGAnimateElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimationElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimateElement)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGAnimateElement)
+NS_INTERFACE_MAP_END_INHERITING(nsSVGAnimateElementBase)
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSVGAnimateElement::nsSVGAnimateElement(nsINodeInfo *aNodeInfo)
+  : nsSVGAnimateElementBase(aNodeInfo)
+{
+}
+
+nsresult
+nsSVGAnimateElement::Init()
+{
+  return nsSVGAnimateElementBase::Init();
+}
+
+//----------------------------------------------------------------------
+// nsIDOMNode methods
+
+NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGAnimateElement)
diff --git a/content/svg/content/src/nsSVGAnimateTransformElement.cpp b/content/svg/content/src/nsSVGAnimateTransformElement.cpp
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGAnimateTransformElement.cpp
@@ -0,0 +1,135 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *   Daniel Holbert <dholbert@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGAnimationElement.h"
+#include "nsIDOMSVGAnimateTransformElement.h"
+#include "nsSVGEnum.h"
+#include "nsIDOMSVGTransform.h"
+#include "nsIDOMSVGTransformable.h"
+#include "nsSVGAnimatedTransformList.h"
+#include "nsSVGTransformSMILAttr.h"
+
+typedef nsSVGAnimationElement nsSVGAnimateTransformElementBase;
+
+class nsSVGAnimateTransformElement : public nsSVGAnimateTransformElementBase,
+                                     public nsIDOMSVGAnimateTransformElement
+{
+protected:
+  friend nsresult NS_NewSVGAnimateTransformElement(nsIContent **aResult,
+                                                   nsINodeInfo *aNodeInfo);
+  nsSVGAnimateTransformElement(nsINodeInfo* aNodeInfo);
+
+public:
+  // interfaces:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIDOMSVGANIMATETRANSFORMELEMENT
+
+  NS_FORWARD_NSIDOMNODE(nsSVGAnimateTransformElementBase::)
+  NS_FORWARD_NSIDOMELEMENT(nsSVGAnimateTransformElementBase::)
+  NS_FORWARD_NSIDOMSVGELEMENT(nsSVGAnimateTransformElementBase::)
+  NS_FORWARD_NSIDOMSVGANIMATIONELEMENT(nsSVGAnimateTransformElementBase::)
+
+  // nsIDOMNode specializations
+  virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
+
+  // nsGenericElement specializations
+  PRBool ParseAttribute(PRInt32 aNamespaceID,
+                        nsIAtom* aAttribute,
+                        const nsAString& aValue,
+                        nsAttrValue& aResult);
+};
+
+NS_IMPL_NS_NEW_SVG_ELEMENT(AnimateTransform)
+
+//----------------------------------------------------------------------
+// nsISupports methods
+
+NS_IMPL_ADDREF_INHERITED(nsSVGAnimateTransformElement,nsSVGAnimateTransformElementBase)
+NS_IMPL_RELEASE_INHERITED(nsSVGAnimateTransformElement,nsSVGAnimateTransformElementBase)
+
+NS_INTERFACE_MAP_BEGIN(nsSVGAnimateTransformElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimationElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimateTransformElement)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGAnimateElement)
+NS_INTERFACE_MAP_END_INHERITING(nsSVGAnimateTransformElementBase)
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSVGAnimateTransformElement::nsSVGAnimateTransformElement(nsINodeInfo *aNodeInfo)
+  : nsSVGAnimateTransformElementBase(aNodeInfo)
+{
+}
+
+PRBool
+nsSVGAnimateTransformElement::ParseAttribute(PRInt32 aNamespaceID,
+                                             nsIAtom* aAttribute,
+                                             const nsAString& aValue,
+                                             nsAttrValue& aResult)
+{
+  // Type is an <animateTransform>-specific attribute, and we'll handle it
+  // specially.
+  if (aNamespaceID == kNameSpaceID_None && aAttribute == nsGkAtoms::type) {
+    // Check the value, to make sure it's one of the recognized strings
+    nsCOMPtr<nsIAtom> attributeAtom(do_GetAtom(aValue));
+    if (attributeAtom == nsGkAtoms::translate ||
+        attributeAtom == nsGkAtoms::scale ||
+        attributeAtom == nsGkAtoms::rotate ||
+        attributeAtom == nsGkAtoms::skewX ||
+        attributeAtom == nsGkAtoms::skewY) {
+
+      // This raw nsIAtom* pointer will stay alive, because we know it points
+      // to one of the above-checked nsGkAtoms members.
+      mAnimationSpec->GetAnimationFunction()->SetSMILAttrData(attributeAtom.get());
+    }
+    // XXXdholbert need a return statement here...
+  } else {
+    return nsSVGAnimateTransformElementBase::ParseAttribute(aNamespaceID, 
+                                                            aAttribute, aValue,
+                                                            aResult);
+  }
+}
+
+//----------------------------------------------------------------------
+// nsIDOMNode methods
+
+NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGAnimateTransformElement)
diff --git a/content/svg/content/src/nsSVGAnimatedTransformList.cpp b/content/svg/content/src/nsSVGAnimatedTransformList.cpp
--- a/content/svg/content/src/nsSVGAnimatedTransformList.cpp
+++ b/content/svg/content/src/nsSVGAnimatedTransformList.cpp
@@ -33,67 +33,20 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsSVGAnimatedTransformList.h"
 #include "nsSVGTransformList.h"
-#include "nsSVGValue.h"
-#include "nsWeakReference.h"
 #include "nsContentUtils.h"
-
-////////////////////////////////////////////////////////////////////////
-// nsSVGAnimatedTransformList
-
-class nsSVGAnimatedTransformList : public nsIDOMSVGAnimatedTransformList,
-                                   public nsSVGValue,
-                                   public nsISVGValueObserver
-{  
-protected:
-  friend nsresult
-  NS_NewSVGAnimatedTransformList(nsIDOMSVGAnimatedTransformList** result,
-                                 nsIDOMSVGTransformList* baseVal);
-
-  nsSVGAnimatedTransformList();
-  ~nsSVGAnimatedTransformList();
-  void Init(nsIDOMSVGTransformList* baseVal);
-  
-public:
-  // nsISupports interface:
-  NS_DECL_ISUPPORTS
-
-  // nsIDOMSVGAnimatedTransformList interface:
-  NS_DECL_NSIDOMSVGANIMATEDTRANSFORMLIST
-
-  // remainder of nsISVGValue interface:
-  NS_IMETHOD SetValueString(const nsAString& aValue);
-  NS_IMETHOD GetValueString(nsAString& aValue);
-
-  // nsISVGValueObserver
-  NS_IMETHOD WillModifySVGObservable(nsISVGValue* observable,
-                                     modificationType aModType);
-  NS_IMETHOD DidModifySVGObservable (nsISVGValue* observable,
-                                     modificationType aModType);
-  
-  // nsISupportsWeakReference
-  // implementation inherited from nsSupportsWeakReference
-  
-protected:
-  nsCOMPtr<nsIDOMSVGTransformList> mBaseVal;
-};
-
 
 //----------------------------------------------------------------------
 // Implementation
-
-nsSVGAnimatedTransformList::nsSVGAnimatedTransformList()
-{
-}
 
 nsSVGAnimatedTransformList::~nsSVGAnimatedTransformList()
 {
   if (!mBaseVal) return;
     nsCOMPtr<nsISVGValue> val = do_QueryInterface(mBaseVal);
   if (!val) return;
   val->RemoveObserver(this);
 }
@@ -141,28 +94,28 @@ nsSVGAnimatedTransformList::GetValueStri
   return value->GetValueString(aValue);
 }
 
 //----------------------------------------------------------------------
 // nsIDOMSVGAnimatedTransformList methods:
 
 /* readonly attribute nsIDOMSVGTransformList baseVal; */
 NS_IMETHODIMP
-nsSVGAnimatedTransformList::GetBaseVal(nsIDOMSVGTransformList * *aBaseVal)
+nsSVGAnimatedTransformList::GetBaseVal(nsIDOMSVGTransformList** aBaseVal)
 {
   *aBaseVal = mBaseVal;
   NS_ADDREF(*aBaseVal);
   return NS_OK;
 }
 
 /* readonly attribute nsIDOMSVGTransformList animVal; */
 NS_IMETHODIMP
-nsSVGAnimatedTransformList::GetAnimVal(nsIDOMSVGTransformList * *aAnimVal)
+nsSVGAnimatedTransformList::GetAnimVal(nsIDOMSVGTransformList** aAnimVal)
 {
-  *aAnimVal = mBaseVal;
+  *aAnimVal = (mAnimVal) ? mAnimVal : mBaseVal;
   NS_ADDREF(*aAnimVal);
   return NS_OK;
 }
 
 //----------------------------------------------------------------------
 // nsISVGValueObserver methods
 
 NS_IMETHODIMP
@@ -176,23 +129,22 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsSVGAnimatedTransformList::DidModifySVGObservable (nsISVGValue* observable,
                                                     modificationType aModType)
 {
   DidModify(aModType);
   return NS_OK;
 }
 
-
 ////////////////////////////////////////////////////////////////////////
 // Exported creation functions:
 
 nsresult
 NS_NewSVGAnimatedTransformList(nsIDOMSVGAnimatedTransformList** result,
-                      nsIDOMSVGTransformList* baseVal)
+                               nsIDOMSVGTransformList* baseVal)
 {
   *result = nsnull;
   
   nsSVGAnimatedTransformList* animatedTransformList = new nsSVGAnimatedTransformList();
   if(!animatedTransformList) return NS_ERROR_OUT_OF_MEMORY;
   NS_ADDREF(animatedTransformList);
 
   animatedTransformList->Init(baseVal);
diff --git a/content/svg/content/src/nsSVGAnimatedTransformList.h b/content/svg/content/src/nsSVGAnimatedTransformList.h
--- a/content/svg/content/src/nsSVGAnimatedTransformList.h
+++ b/content/svg/content/src/nsSVGAnimatedTransformList.h
@@ -36,14 +36,65 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef __NS_SVGANIMATEDTRANSFORMLIST_H__
 #define __NS_SVGANIMATEDTRANSFORMLIST_H__
 
 #include "nsIDOMSVGAnimTransformList.h"
 #include "nsIDOMSVGTransformList.h"
+#include "nsSVGValue.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsSVGAnimatedTransformList
+
+class nsSVGTransformSMILAttr;
+
+class nsSVGAnimatedTransformList : public nsIDOMSVGAnimatedTransformList,
+                                   public nsSVGValue,
+                                   public nsISVGValueObserver
+{  
+protected:
+  friend nsresult
+  NS_NewSVGAnimatedTransformList(nsIDOMSVGAnimatedTransformList** result,
+                                 nsIDOMSVGTransformList* baseVal);
+
+  ~nsSVGAnimatedTransformList();
+  void Init(nsIDOMSVGTransformList* baseVal);
+
+public:
+  // nsISupports interface:
+  NS_DECL_ISUPPORTS
+
+  // nsIDOMSVGAnimatedTransformList interface:
+  NS_DECL_NSIDOMSVGANIMATEDTRANSFORMLIST
+
+  // remainder of nsISVGValue interface:
+  NS_IMETHOD SetValueString(const nsAString& aValue);
+  NS_IMETHOD GetValueString(nsAString& aValue);
+
+  // nsISVGValueObserver
+  NS_IMETHOD WillModifySVGObservable(nsISVGValue* observable,
+                                     modificationType aModType);
+  NS_IMETHOD DidModifySVGObservable (nsISVGValue* observable,
+                                     modificationType aModType);
+
+  // nsISupportsWeakReference
+  // implementation inherited from nsSupportsWeakReference
+
+protected:
+  nsresult
+  ParseValue(const nsAString &aSpec, nsIDOMSVGMatrix** matrix) const;
+
+  PRInt32
+  ParseParameterList(char *paramstr, float *vars, PRInt32 nvars) const;
+
+  friend class nsSVGTransformSMILAttr;
+
+  nsCOMPtr<nsIDOMSVGTransformList> mBaseVal;
+  nsCOMPtr<nsIDOMSVGTransformList> mAnimVal;
+};
 
 nsresult
 NS_NewSVGAnimatedTransformList(nsIDOMSVGAnimatedTransformList** result,
                                nsIDOMSVGTransformList* baseVal);
 
 #endif //__NS_SVGANIMATEDTRANSFORMLIST_H__
diff --git a/content/svg/content/src/nsSVGAnimationElement.cpp b/content/svg/content/src/nsSVGAnimationElement.cpp
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGAnimationElement.cpp
@@ -0,0 +1,328 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGAnimationElement.h"
+#include "nsSVGSVGElement.h"
+#include "nsSMILAnimationRegistry.h"
+#include "nsISMILAttr.h"
+#include "nsBindingManager.h"
+
+//----------------------------------------------------------------------
+// nsISupports methods
+
+NS_IMPL_ADDREF_INHERITED(nsSVGAnimationElement, nsSVGAnimationElementBase)
+NS_IMPL_RELEASE_INHERITED(nsSVGAnimationElement, nsSVGAnimationElementBase)
+
+NS_INTERFACE_MAP_BEGIN(nsSVGAnimationElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMElementTimeControl)
+NS_INTERFACE_MAP_END_INHERITING(nsSVGAnimationElementBase)
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSVGAnimationElement::nsSVGAnimationElement(nsINodeInfo *aNodeInfo)
+  : nsSVGAnimationElementBase(aNodeInfo)
+{
+}
+
+nsresult
+nsSVGAnimationElement::Init()
+{
+  nsresult rv = nsSVGAnimationElementBase::Init();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  mAnimationSpec = new nsSVGAnimationSpec(this);
+  NS_ENSURE_TRUE(mAnimationSpec, NS_ERROR_FAILURE);
+
+  mTimedElement = NS_NewSMILTimedElement();
+  NS_ENSURE_TRUE(mTimedElement, NS_ERROR_FAILURE);
+  
+  mTimedElement->SetTimeClient(mAnimationSpec->GetAnimationFunction());
+
+  mTimeControl = do_QueryInterface(mTimedElement);
+  NS_ENSURE_TRUE(mTimeControl, NS_ERROR_FAILURE);
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// nsIDOMSVGAnimationElement methods
+
+/* readonly attribute SVGElement targetElement; */
+NS_IMETHODIMP
+nsSVGAnimationElement::GetTargetElement(nsIDOMSVGElement** aTarget)
+{
+  // We'll just call the other GetTargetElement method, and QI to the right type
+  nsCOMPtr<nsIContent> targetContent;
+  GetTargetElement(getter_AddRefs(targetContent));
+
+  nsCOMPtr<nsIDOMSVGElement> targetSVG = do_QueryInterface(targetContent);
+  NS_IF_RELEASE(*aTarget);
+  NS_IF_ADDREF(*aTarget = targetSVG);
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGAnimationElement::GetTargetElement(nsIContent** aTarget)
+{
+  if (HasAttr(kNameSpaceID_XLink, nsGkAtoms::href)) {
+    // XXXdholbert: Use xlink:href attr to look up target element here.
+
+    // Note: Need to check for updated target element each sample, because
+    // the existing target's ID might've changed, or another element
+    // with the same ID might've been inserted earlier in the DOM tree.
+  } else {
+    // No "xlink:href" attribute --> target is my parent.
+    NS_IF_ADDREF(*aTarget = GetParentElement());
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSVGAnimationElement::GetStartTime(float* retval)
+{
+  // XXX
+  (void)retval;
+  NS_NOTYETIMPLEMENTED("nsSVGAnimationElement::GetStartTime");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsSVGAnimationElement::GetCurrentTime(float* retval)
+{
+  // XXX
+  (void)retval;
+  NS_NOTYETIMPLEMENTED("nsSVGAnimationElement::GetCurrentTime");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsSVGAnimationElement::GetSimpleDuration(float* retval)
+{
+  // XXX
+  (void)retval;
+  NS_NOTYETIMPLEMENTED("nsSVGAnimationElement::GetSimpleDuration");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+//----------------------------------------------------------------------
+// nsISVGContent methods
+
+nsresult
+nsSVGAnimationElement::BindToTree(nsIDocument* aDocument,
+                                  nsIContent* aParent,
+                                  nsIContent* aBindingParent,
+                                  PRBool aCompileEventHandlers)
+{
+  nsresult rv = nsSVGAnimationElementBase::BindToTree(aDocument, aParent,
+                                                      aBindingParent,
+                                                      aCompileEventHandlers);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  // XXXdholbert is ownerDOMSVG (as a check for SVG parent) still needed here?
+  nsCOMPtr<nsIDOMSVGSVGElement> ownerDOMSVG;
+  rv = GetOwnerSVGElement(getter_AddRefs(ownerDOMSVG));
+
+  if (NS_FAILED(rv) || !ownerDOMSVG)
+    // No use proceeding. We don't have an SVG parent (yet) so we won't be able
+    // to register ourselves etc. Maybe next time we'll have more luck.
+    // (This sort of situation will arise a lot when trees are being constructed
+    // piece by piece via script)
+    return NS_OK;
+
+
+  // XXXdholbert -- Don't need the registry anymore, but we *do* still
+  // need a handle on the timed-document root.  Hook that in here (& retain
+  // a pointer to it) instead of using the registry.
+  nsSMILAnimationRegistry* registry = GetAnimationRegistry();
+  if (!registry)
+    // Registry hasn't been created yet. This will be created when the SVG
+    // parent is bound.
+    return NS_OK;
+
+  rv = registry->RegisterTimedElement(mTimedElement);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  // Add myself to document's master set of animation elements.
+  aDocument->AddToAnimationSpecSet(mAnimationSpec);
+
+  return rv;
+}
+
+void
+nsSVGAnimationElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
+{
+  nsIDocument *doc = GetOwnerDoc();
+  if (doc) {
+    doc->RemoveFromAnimationSpecSet(mAnimationSpec);
+  }
+
+  // XXXdholbert -- this should be talking directly to document root,
+  // not to the registry. (We hopefully don't need registry at all anymore)
+  nsSMILAnimationRegistry* registry = GetAnimationRegistry();
+  if (registry)
+    registry->UnregisterTimedElement(mTimedElement);
+
+  nsSVGAnimationElementBase::UnbindFromTree(aDeep, aNullParent);
+}
+
+//----------------------------------------------------------------------
+// nsIContent methods
+
+PRBool
+nsSVGAnimationElement::ParseAttribute(PRInt32 aNamespaceID,
+                                      nsIAtom* aAttribute,
+                                      const nsAString& aValue,
+                                      nsAttrValue& aResult)
+{
+  if (aNamespaceID == kNameSpaceID_None) {
+    // First let the nsSMILAnimationFunction try to parse it...
+    PRBool foundMatch = 
+      mAnimationSpec->GetAnimationFunction()->SetAttr(aAttribute, aValue);
+
+    // ... and if that didn't recognize the attribute, let the timed element
+    // try to parse it...
+    if (!foundMatch)
+      foundMatch = mTimedElement->SetAttr(aAttribute, aValue);
+    
+    // ... and store the value, if either of those succeeded.
+    if (foundMatch) {
+      aResult.SetTo(aValue);
+      // XXXdholbert Now that we've already set aResult, do we need to keep
+      // going with the call to nsSVGAnimationElementBase::ParseAttribute,
+      // or can we just return here?
+    }
+  }
+
+  return nsSVGAnimationElementBase::ParseAttribute(aNamespaceID, aAttribute,
+                                                   aValue, aResult);
+}
+
+nsresult
+nsSVGAnimationElement::UnsetAttr(PRInt32 aNamespaceID,
+                                 nsIAtom* aAttribute, PRBool aNotify)
+{
+  nsresult rv = nsSVGAnimationElementBase::UnsetAttr(aNamespaceID, aAttribute,
+                                                     aNotify);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (aNamespaceID == kNameSpaceID_None)  {
+    if (!mAnimationSpec->GetAnimationFunction()->UnsetAttr(aAttribute)) {
+      mTimedElement->UnsetAttr(aAttribute);
+    }
+  }
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+nsSMILAnimationRegistry*
+nsSVGAnimationElement::GetAnimationRegistry()
+{
+  nsSMILAnimationRegistry*      result = nsnull;
+  nsCOMPtr<nsIDOMSVGSVGElement> ownerDOMSVG;
+
+  nsresult rv = GetOwnerSVGElement(getter_AddRefs(ownerDOMSVG));
+
+  if (NS_SUCCEEDED(rv) && ownerDOMSVG) {
+    nsSVGSVGElement *ownerSVG =
+      static_cast<nsSVGSVGElement*>(ownerDOMSVG.get());
+    result = ownerSVG->GetAnimationRegistry();
+  }
+
+  return result;
+}
+
+nsIContent*
+nsSVGAnimationElement::GetParentElement()
+{
+  nsCOMPtr<nsIContent> result;
+  nsBindingManager*   bindingManager = nsnull;
+  nsIDocument*        ownerDoc = GetOwnerDoc();
+
+  if (ownerDoc)
+    bindingManager = ownerDoc->BindingManager();
+
+  if (bindingManager)
+    // we have a binding manager -- do we have an anonymous parent?
+    result = bindingManager->GetInsertionParent(this);
+
+  if (!result)
+    // if we didn't find an anonymous parent, use the explicit one,
+    // whether it's null or not...
+    result = GetParent();
+
+  return result;
+}
+
+// nsIDOMElementTimeControl
+/* boolean beginElement (); */
+NS_IMETHODIMP
+nsSVGAnimationElement::BeginElement(PRBool *_retval)
+{
+  RequestSample();
+  return mTimeControl->BeginElement(_retval);
+}
+
+/* boolean beginElementAt (in float offset); */
+NS_IMETHODIMP
+nsSVGAnimationElement::BeginElementAt(float offset, PRBool *_retval)
+{
+  RequestSample();
+  return mTimeControl->BeginElementAt(offset, _retval);
+}
+
+/* boolean endElement (); */
+NS_IMETHODIMP
+nsSVGAnimationElement::EndElement(PRBool *_retval)
+{
+  RequestSample();
+  return mTimeControl->EndElement(_retval);
+}
+
+/* boolean endElementAt (in float offset); */
+NS_IMETHODIMP
+nsSVGAnimationElement::EndElementAt(float offset, PRBool *_retval)
+{
+  RequestSample();
+  return mTimeControl->EndElementAt(offset, _retval);
+}
diff --git a/content/svg/content/src/nsSVGAnimationElement.h b/content/svg/content/src/nsSVGAnimationElement.h
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGAnimationElement.h
@@ -0,0 +1,104 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SVGANIMATIONELEMENT_H__
+#define __NS_SVGANIMATIONELEMENT_H__
+
+#include "nsSVGElement.h"
+#include "nsSVGAnimationSpec.h"
+#include "nsIDOMSVGAnimationElement.h"
+#include "nsIDOMElementTimeControl.h"
+#include "nsISMILTimedElement.h"
+#include "nsSMILAnimationFunction.h"
+
+class nsSMILAnimationRegistry;
+
+typedef nsSVGElement nsSVGAnimationElementBase;
+
+class nsSVGAnimationElement : public nsSVGAnimationElementBase,
+                              public nsIDOMElementTimeControl
+{
+protected:
+  nsSVGAnimationElement(nsINodeInfo *aNodeInfo);
+  nsresult Init();
+
+public:
+  // interfaces:  
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIDOMSVGANIMATIONELEMENT
+  NS_DECL_NSIDOMELEMENTTIMECONTROL
+
+  // nsISVGContent specializations
+  virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
+                              nsIContent* aBindingParent,
+                              PRBool aCompileEventHandlers);
+  virtual void UnbindFromTree(PRBool aDeep = PR_TRUE,
+                              PRBool aNullParent = PR_TRUE);
+
+  // nsIContent specializations
+  virtual nsresult UnsetAttr(PRInt32 aNamespaceID, nsIAtom* aAttribute,
+                             PRBool aNotify);
+
+  // nsGenericElement specializations
+  virtual PRBool ParseAttribute(PRInt32 aNamespaceID,
+                                nsIAtom* aAttribute,
+                                const nsAString& aValue,
+                                nsAttrValue& aResult);
+
+  // Utility function, implementing GetTargetElement() for
+  // things that just care about nsIContent.
+  nsresult GetTargetElement(nsIContent** aTarget);
+
+protected:
+  // Implementation helpers
+  nsSMILAnimationRegistry*           GetAnimationRegistry();
+  nsIContent*                        GetParentElement();
+
+  nsAutoPtr<nsISMILAnimationSpec> mAnimationSpec;
+
+  // XXXdholbert should mTimedElement and mTimeControl be incorporated
+  // into the animationSpec object?  Non-SVG animations will need access
+  // to them or something like them, so they shouldn't live here.
+  nsCOMPtr<nsISMILTimedElement>      mTimedElement;
+
+  // XXXdholbert get rid of this, if possible:
+  nsCOMPtr<nsIDOMElementTimeControl> mTimeControl; // QI'ed version of the
+                                                   // nsSMILAnimationFunction 
+};
+
+#endif // __NS_SVGANIMATIONELEMENT_H__
diff --git a/content/svg/content/src/nsSVGAnimationSpec.cpp b/content/svg/content/src/nsSVGAnimationSpec.cpp
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGAnimationSpec.cpp
@@ -0,0 +1,101 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Daniel Holbert <dholbert@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGAnimationSpec.h"
+#include "nsSVGAnimationElement.h"
+
+nsSMILAnimationFunction*
+nsSVGAnimationSpec::GetAnimationFunction()
+{
+  return &mAnimationFunction;
+}
+
+nsIContent*
+nsSVGAnimationSpec::GetAnimationElement()
+{
+  return mAnimationElement;
+}
+
+void
+nsSVGAnimationSpec::GetTargetElement(nsIContent** aTarget)
+{
+  mAnimationElement->GetTargetElement(aTarget);
+}
+
+PRBool
+nsSVGAnimationSpec::GetTargetAttributeNameStr(nsAString& aResult) const
+{
+  return GetAttrHelper(nsGkAtoms::attributeName, aResult);
+}
+
+PRBool
+nsSVGAnimationSpec::GetTargetAttributeTypeStr(nsAString& aResult) const
+{
+  return GetAttrHelper(nsGkAtoms::attributeType, aResult);
+}
+
+
+PRBool
+nsSVGAnimationSpec::GetByStr(nsAString& aResult) const
+{
+  return GetAttrHelper(nsGkAtoms::by, aResult);
+}
+
+PRBool
+nsSVGAnimationSpec::GetFromStr(nsAString& aResult) const
+{
+  return GetAttrHelper(nsGkAtoms::from, aResult);
+}
+
+PRBool
+nsSVGAnimationSpec::GetToStr(nsAString& aResult) const
+{
+  return GetAttrHelper(nsGkAtoms::to, aResult);
+}
+
+PRBool
+nsSVGAnimationSpec::GetValuesStr(nsAString& aResult) const
+{
+  return GetAttrHelper(nsGkAtoms::values, aResult);
+}
+
+PRBool
+nsSVGAnimationSpec::GetAttrHelper(nsIAtom *aAttrName, nsAString &aResult) const
+{
+  NS_ASSERTION(mAnimationElement, "mAnimationElement should never be null.");
+  return mAnimationElement->GetAttr(kNameSpaceID_None, aAttrName, aResult);
+}
diff --git a/content/svg/content/src/nsSVGAnimationSpec.h b/content/svg/content/src/nsSVGAnimationSpec.h
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGAnimationSpec.h
@@ -0,0 +1,81 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Daniel Holbert <dholbert@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SVGANIMATIONSPEC_H__
+#define __NS_SVGANIMATIONSPEC_H__
+
+#include "nscore.h"
+#include "nsISMILAnimationSpec.h"
+#include "nsSMILAnimationFunction.h"
+
+class nsSVGAnimationElement;
+
+class nsSVGAnimationSpec : public nsISMILAnimationSpec
+{
+public:
+  nsSVGAnimationSpec(nsSVGAnimationElement* aAnimationElement)
+    : mAnimationElement(aAnimationElement),
+      mAnimationFunction(this)
+  {}
+ 
+  // nsISMILAnimationElement interface
+  virtual nsSMILAnimationFunction* GetAnimationFunction();
+  virtual nsIContent* GetAnimationElement();
+
+  virtual void   GetTargetElement(nsIContent** aTarget);
+  virtual PRBool GetTargetAttributeNameStr(nsAString& aResult) const;
+  virtual PRBool GetTargetAttributeTypeStr(nsAString& aResult) const;
+  virtual PRBool GetByStr(nsAString& aResult) const;
+  virtual PRBool GetFromStr(nsAString& aResult) const;
+  virtual PRBool GetToStr(nsAString& aResult) const;
+  virtual PRBool GetValuesStr(nsAString& aResult) const;
+
+private:
+  // Helper function that slightly simplifies calls to 
+  // mAnimationElement->GetAttr()
+  PRBool GetAttrHelper(nsIAtom *aAttrName, nsAString &aResult) const;
+
+  // The SVG animation element that owns this animation spec
+  nsSVGAnimationElement   *mAnimationElement;
+
+  // The animation function for this animation.
+  // Just including this as part of the animationSpec, because it's
+  // tied inextricably to it.
+  nsSMILAnimationFunction mAnimationFunction;
+};
+
+#endif // __NS_SVGANIMATIONSPEC_H__
diff --git a/content/svg/content/src/nsSVGElement.cpp b/content/svg/content/src/nsSVGElement.cpp
--- a/content/svg/content/src/nsSVGElement.cpp
+++ b/content/svg/content/src/nsSVGElement.cpp
@@ -82,18 +82,23 @@
 #include "nsIDOMSVGPointList.h"
 #include "nsIDOMSVGAnimatedPoints.h"
 #include "nsIDOMSVGPresAspectRatio.h"
 #include "nsIDOMSVGAnimPresAspRatio.h"
 #include "nsIDOMSVGTransformList.h"
 #include "nsIDOMSVGAnimTransformList.h"
 #include "nsIDOMSVGAnimatedRect.h"
 #include "nsSVGRect.h"
+#include "nsIFrame.h"
 #include "prdtoa.h"
 #include <stdarg.h>
+#ifdef MOZ_SMIL
+#include "nsIDOMSVGTransformable.h"
+#include "nsSVGTransformSMILAttr.h"
+#endif // MOZ_SMIL
 
 nsSVGEnumMapping nsSVGElement::sSVGUnitTypesMap[] = {
   {&nsGkAtoms::userSpaceOnUse, nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_USERSPACEONUSE},
   {&nsGkAtoms::objectBoundingBox, nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX},
   {nsnull, 0}
 };
 
 nsSVGElement::nsSVGElement(nsINodeInfo *aNodeInfo)
@@ -1184,16 +1189,29 @@ nsSVGElement::DidChangeLength(PRUint8 aA
   nsAutoString newStr;
   info.mLengths[aAttrEnum].GetBaseValueString(newStr);
 
   SetAttr(kNameSpaceID_None, *info.mLengthInfo[aAttrEnum].mName,
           newStr, PR_TRUE);
 }
 
 void
+nsSVGElement::DidAnimateLength(PRUint8 aAttrEnum)
+{
+  nsIFrame* frame = GetPrimaryFrame();
+
+  if (frame) {
+    LengthAttributesInfo info = GetLengthInfo();
+    frame->AttributeChanged(kNameSpaceID_None,
+                            *info.mLengthInfo[aAttrEnum].mName,
+                            nsIDOMMutationEvent::MODIFICATION);
+  }
+}
+
+void
 nsSVGElement::GetAnimatedLengthValues(float *aFirst, ...)
 {
   LengthAttributesInfo info = GetLengthInfo();
 
   NS_ASSERTION(info.mLengthCount > 0,
                "GetAnimatedLengthValues on element with no length attribs");
 
   nsSVGSVGElement *ctx = nsnull;
@@ -1568,8 +1586,88 @@ nsSVGElement::RecompileScriptEventListen
       continue;
     }
 
     nsAutoString value;
     GetAttr(kNameSpaceID_None, attr, value);
     AddScriptEventListener(GetEventNameForAttr(attr), value, PR_TRUE);
   }
 }
+
+#ifdef MOZ_SMIL
+nsSMILAnimationController*
+nsSVGElement::GetAnimationController(nsIDocument* aDocument,
+                                     PRBool aCreate /* = PR_FALSE */)
+{
+  NS_ENSURE_TRUE(aDocument, nsnull);
+
+  nsIPresShell* presShell = aDocument->GetPrimaryShell();
+  if (!presShell)
+    return nsnull;
+
+  nsPresContext* context = presShell->GetPresContext();
+  NS_ENSURE_TRUE(context, nsnull);
+
+  nsSMILAnimationController* controller = context->GetAnimationController();
+
+  if (!controller) {
+    // XXXdholbert Maybe the controller should be created within
+    // nsPresContext, since that's what owns it?
+    controller = NS_NewSMILAnimationController(aDocument);
+    context->SetAnimationController(controller);
+  }
+
+  return controller;
+}
+
+// XXXdholbert maybe this should live in the SVGSVGElement, so that the
+// SVGElement is cleaner. (e.g. then SVGElement wouldn't need
+// GetAnimationController)
+void
+nsSVGElement::RequestSample()
+{
+  nsIDocument* doc = GetCurrentDoc();
+  if (doc) {
+    nsSMILAnimationController *smilController =
+      GetAnimationController(doc, PR_FALSE);
+    if (smilController) {
+      smilController->FireForceSampleEvent();
+    }
+  }
+}
+
+nsISMILAttr*
+nsSVGElement::GetAnimatedAttr(const nsIAtom* aName, PRBool aIsCSS)
+{
+  // Non-CSS:
+  // ------- 
+  // Transforms:
+  // (Note: there is no CSS "transform" property for SVG, so this one
+  // is non-CSS-only.)
+  // NOTE: Copied from nsSVGAnimateTransformElement in old patch
+  if (aName == nsGkAtoms::transform) {
+    nsCOMPtr<nsIDOMSVGTransformable> transformable(
+            do_QueryInterface(static_cast<nsIContent*>(this)));
+    NS_ENSURE_TRUE(transformable, nsnull);
+    nsCOMPtr<nsIDOMSVGAnimatedTransformList> transformList;
+    nsresult rv = transformable->GetTransform(getter_AddRefs(transformList));
+    NS_ENSURE_SUCCESS(rv,nsnull);
+    nsSVGAnimatedTransformList* list =
+      (nsSVGAnimatedTransformList*)transformList.get();
+    NS_ENSURE_TRUE(list,nsnull);
+
+    // Get the SVG element
+    return new nsSVGTransformSMILAttr(list, this);
+  }
+
+  // Lengths:
+  // XXXdholbert Once we add CSS support, check aIsCSS here.
+  LengthAttributesInfo info = GetLengthInfo();
+  for (PRUint32 i = 0; i < info.mLengthCount; i++) {
+    if (aName == *info.mLengthInfo[i].mName) {
+      return info.mLengths[i].ToSMILAttr(this);
+    }
+  }
+
+  return nsnull;
+}
+
+#endif // MOZ_SMIL
diff --git a/content/svg/content/src/nsSVGElement.h b/content/svg/content/src/nsSVGElement.h
--- a/content/svg/content/src/nsSVGElement.h
+++ b/content/svg/content/src/nsSVGElement.h
@@ -48,16 +48,21 @@
 #include "nsCOMPtr.h"
 #include "nsIDOMSVGElement.h"
 #include "nsGenericElement.h"
 #include "nsStyledElement.h"
 #include "nsISVGValue.h"
 #include "nsISVGValueObserver.h"
 #include "nsWeakReference.h"
 #include "nsICSSStyleRule.h"
+
+#ifdef MOZ_SMIL
+#include "nsISMILAttr.h"
+#include "nsSMILAnimationController.h"
+#endif
 
 class nsSVGSVGElement;
 class nsSVGLength2;
 class nsSVGNumber2;
 class nsSVGInteger;
 class nsSVGAngle;
 class nsSVGBoolean;
 class nsSVGEnum;
@@ -135,19 +140,29 @@ public:
   virtual void DidChangeLength(PRUint8 aAttrEnum, PRBool aDoSetAttr);
   virtual void DidChangeNumber(PRUint8 aAttrEnum, PRBool aDoSetAttr);
   virtual void DidChangeInteger(PRUint8 aAttrEnum, PRBool aDoSetAttr);
   virtual void DidChangeAngle(PRUint8 aAttrEnum, PRBool aDoSetAttr);
   virtual void DidChangeBoolean(PRUint8 aAttrEnum, PRBool aDoSetAttr);
   virtual void DidChangeEnum(PRUint8 aAttrEnum, PRBool aDoSetAttr);
   virtual void DidChangeString(PRUint8 aAttrEnum, PRBool aDoSetAttr);
 
+  void DidAnimateLength(PRUint8 aAttrEnum);
+
   void GetAnimatedLengthValues(float *aFirst, ...);
   void GetAnimatedNumberValues(float *aFirst, ...);
   void GetAnimatedIntegerValues(PRInt32 *aFirst, ...);
+
+#ifdef MOZ_SMIL
+  void RequestSample();
+  nsSMILAnimationController*
+  GetAnimationController(nsIDocument* aDocument, PRBool aCreate = PR_FALSE);
+
+  virtual nsISMILAttr* GetAnimatedAttr(const nsIAtom* aName, PRBool aIsCSS);
+#endif
 
   virtual void RecompileScriptEventListeners();
 
 protected:
   virtual nsresult BeforeSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
                                  const nsAString* aValue, PRBool aNotify);
   virtual nsresult AfterSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
                                 const nsAString* aValue, PRBool aNotify);
diff --git a/content/svg/content/src/nsSVGElementFactory.cpp b/content/svg/content/src/nsSVGElementFactory.cpp
--- a/content/svg/content/src/nsSVGElementFactory.cpp
+++ b/content/svg/content/src/nsSVGElementFactory.cpp
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Crocodile Clips Ltd..
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Alex Fritze <alex.fritze@crocodile-clips.com> (original author)
+ *   Chris Double  <chris.double@double.co.nz>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -154,16 +155,25 @@ NS_NewSVGFEDiffuseLightingElement(nsICon
 NS_NewSVGFEDiffuseLightingElement(nsIContent **aResult, nsINodeInfo *aNodeInfo);
 nsresult
 NS_NewSVGFESpecularLightingElement(nsIContent **aResult, nsINodeInfo *aNodeInfo);
 nsresult
 NS_NewSVGFEImageElement(nsIContent **aResult, nsINodeInfo *aNodeInfo);
 nsresult
 NS_NewSVGFEDisplacementMapElement(nsIContent **aResult, nsINodeInfo *aNodeInfo);
 
+#ifdef MOZ_SMIL
+nsresult
+NS_NewSVGAnimateElement(nsIContent **aResult, nsINodeInfo *aNodeInfo);
+nsresult
+NS_NewSVGAnimateTransformElement(nsIContent **aResult, nsINodeInfo *aNodeInfo);
+nsresult
+NS_NewSVGSetElement(nsIContent **aResult, nsINodeInfo *aNodeInfo);
+#endif // MOZ_SMIL
+
 nsresult
 NS_NewSVGElement(nsIContent** aResult, nsINodeInfo *aNodeInfo)
 {
   NS_PRECONDITION(NS_SVGEnabled(),
                   "creating an SVG element while SVG disabled");
 
   static const char kSVGStyleSheetURI[] = "resource://gre/res/svg.css";
 
@@ -281,13 +291,21 @@ NS_NewSVGElement(nsIContent** aResult, n
   if (name == nsGkAtoms::feDisplacementMap)
     return NS_NewSVGFEDisplacementMapElement(aResult, aNodeInfo);
   if (name == nsGkAtoms::pattern)
     return NS_NewSVGPatternElement(aResult, aNodeInfo);
   if (name == nsGkAtoms::mask)
     return NS_NewSVGMaskElement(aResult, aNodeInfo);
   if (name == nsGkAtoms::svgSwitch)
     return NS_NewSVGSwitchElement(aResult, aNodeInfo);
+#ifdef MOZ_SMIL
+  if (name == nsGkAtoms::animate)
+    return NS_NewSVGAnimateElement(aResult, aNodeInfo);
+  if (name == nsGkAtoms::animateTransform)
+    return NS_NewSVGAnimateTransformElement(aResult, aNodeInfo);
+  if (name == nsGkAtoms::set)
+    return NS_NewSVGSetElement(aResult, aNodeInfo);
+#endif // MOZ_SMIL
 
   // if we don't know what to create, just create a standard xml element:
   return NS_NewXMLElement(aResult, aNodeInfo);
 }
 
diff --git a/content/svg/content/src/nsSVGLength2.cpp b/content/svg/content/src/nsSVGLength2.cpp
--- a/content/svg/content/src/nsSVGLength2.cpp
+++ b/content/svg/content/src/nsSVGLength2.cpp
@@ -37,16 +37,20 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsSVGLength2.h"
 #include "prdtoa.h"
 #include "nsTextFormatter.h"
 #include "nsSVGSVGElement.h"
 #include "nsIFrame.h"
 #include "nsSVGIntegrationUtils.h"
+#ifdef MOZ_SMIL
+#include "nsSMILValue.h"
+#include "nsSMILFloatType.h"
+#endif // MOZ_SMIL
 
 NS_IMPL_ADDREF(nsSVGLength2::DOMBaseVal)
 NS_IMPL_RELEASE(nsSVGLength2::DOMBaseVal)
 
 NS_IMPL_ADDREF(nsSVGLength2::DOMAnimVal)
 NS_IMPL_RELEASE(nsSVGLength2::DOMAnimVal)
 
 NS_IMPL_ADDREF(nsSVGLength2::DOMAnimatedLength)
@@ -397,19 +401,75 @@ nsSVGLength2::GetAnimValueString(nsAStri
 
 void
 nsSVGLength2::SetBaseValue(float aValue, nsSVGElement *aSVGElement)
 {
   mAnimVal = mBaseVal = aValue * GetUnitScaleFactor(aSVGElement);
   aSVGElement->DidChangeLength(mAttrEnum, PR_TRUE);
 }
 
+void
+nsSVGLength2::SetAnimValue(float aValue, nsSVGElement *aSVGElement)
+{
+  mAnimVal = aValue * GetUnitScaleFactor(aSVGElement);
+  aSVGElement->DidAnimateLength(mAttrEnum);
+}
+
 nsresult
 nsSVGLength2::ToDOMAnimatedLength(nsIDOMSVGAnimatedLength **aResult,
                                   nsSVGElement *aSVGElement)
 {
   *aResult = new DOMAnimatedLength(this, aSVGElement);
   if (!*aResult)
     return NS_ERROR_OUT_OF_MEMORY;
 
   NS_ADDREF(*aResult);
   return NS_OK;
 }
+
+#ifdef MOZ_SMIL
+nsISMILAttr*
+nsSVGLength2::ToSMILAttr(nsSVGElement *aSVGElement)
+{
+  return new SMILLength(this, aSVGElement);
+}
+
+nsISMILType*
+nsSVGLength2::SMILLength::GetSMILType(const void* aData)
+{
+  NS_ASSERTION(!aData, "Was expecting a null aData pointer");
+  return &nsSMILFloatType::sSingleton;
+}
+
+nsresult
+nsSVGLength2::SMILLength::ValueFromString(const nsAString& aStr,
+                                          const void* aData,
+                                          nsSMILValue& aValue)
+{
+  NS_ASSERTION(!aData, "aData pointer being ignored, but it's non-null");
+  nsSVGLength2 tmp;
+  tmp.SetBaseValueString(aStr, mSVGElement, PR_FALSE);
+
+  nsSMILValue val(&nsSMILFloatType::sSingleton);
+  val.mU.mDouble = tmp.GetBaseValue(mSVGElement);
+  aValue = val;
+  return NS_OK;
+}
+
+nsresult
+nsSVGLength2::SMILLength::GetBaseValue(nsSMILValue& aValue)
+{
+  nsSMILValue val(&nsSMILFloatType::sSingleton);
+  val.mU.mDouble = mVal->GetBaseValue(mSVGElement);
+  aValue = val;
+  return NS_OK;
+}
+
+nsresult
+nsSVGLength2::SMILLength::SetAnimValue(const nsSMILValue& aValue)
+{
+  NS_ASSERTION(aValue.mType == &nsSMILFloatType::sSingleton,
+    "Unexpected type to assign animated value");
+  if (aValue.mType == &nsSMILFloatType::sSingleton)
+    mVal->SetAnimValue((float)aValue.mU.mDouble, mSVGElement);
+  return NS_OK;
+}
+#endif // MOZ_SMIL
diff --git a/content/svg/content/src/nsSVGLength2.h b/content/svg/content/src/nsSVGLength2.h
--- a/content/svg/content/src/nsSVGLength2.h
+++ b/content/svg/content/src/nsSVGLength2.h
@@ -38,16 +38,22 @@
 #define __NS_SVGLENGTH2_H__
 
 #include "nsIDOMSVGLength.h"
 #include "nsIDOMSVGAnimatedLength.h"
 #include "nsSVGUtils.h"
 #include "nsSVGElement.h"
 #include "nsDOMError.h"
 
+#ifdef MOZ_SMIL
+#include "nsISMILAttr.h"
+struct nsSMILValue;
+class nsISMILType;
+#endif // MOZ_SMIL
+
 class nsIFrame;
 
 class nsSVGLength2
 {
 
 public:
   void Init(PRUint8 aCtxType = nsSVGUtils::XY,
             PRUint8 aAttrEnum = 0xff,
@@ -82,16 +88,19 @@ public:
 
   float GetBaseValue(nsSVGSVGElement* aCtx) const
     { return mBaseVal / GetUnitScaleFactor(aCtx); }
   float GetAnimValue(nsSVGSVGElement* aCtx) const
     { return mAnimVal / GetUnitScaleFactor(aCtx); }
   
   nsresult ToDOMAnimatedLength(nsIDOMSVGAnimatedLength **aResult,
                                nsSVGElement* aSVGElement);
+#ifdef MOZ_SMIL
+  nsISMILAttr* ToSMILAttr(nsSVGElement* aSVGElement);
+#endif // MOZ_SMIL
 
 private:
   
   float mAnimVal;
   float mBaseVal;
   PRUint8 mSpecifiedUnitType;
   PRUint8 mAttrEnum; // element specified tracking for attribute
   PRUint8 mCtxType; // X, Y or Unspecified
@@ -110,16 +119,17 @@ private:
   float GetEmLength(nsSVGElement *aSVGElement) const
     { return nsSVGUtils::GetFontSize(aSVGElement); }
   float GetExLength(nsSVGElement *aSVGElement) const
     { return nsSVGUtils::GetFontXHeight(aSVGElement); }
   float GetUnitScaleFactor(nsSVGElement *aSVGElement) const;
   float GetUnitScaleFactor(nsSVGSVGElement *aCtx) const;
   void SetBaseValue(float aValue, nsSVGElement *aSVGElement);
   void SetBaseValueInSpecifiedUnits(float aValue, nsSVGElement *aSVGElement);
+  void SetAnimValue(float aValue, nsSVGElement *aSVGElement);
   void NewValueSpecifiedUnits(PRUint16 aUnitType, float aValue,
                               nsSVGElement *aSVGElement);
   void ConvertToSpecifiedUnits(PRUint16 aUnitType, nsSVGElement *aSVGElement);
   nsresult ToDOMBaseVal(nsIDOMSVGLength **aResult, nsSVGElement* aSVGElement);
   nsresult ToDOMAnimVal(nsIDOMSVGLength **aResult, nsSVGElement* aSVGElement);
 
   struct DOMBaseVal : public nsIDOMSVGLength
   {
@@ -207,11 +217,34 @@ private:
     nsRefPtr<nsSVGElement> mSVGElement;
 
     NS_IMETHOD GetBaseVal(nsIDOMSVGLength **aBaseVal)
       { return mVal->ToDOMBaseVal(aBaseVal, mSVGElement); }
 
     NS_IMETHOD GetAnimVal(nsIDOMSVGLength **aAnimVal)
       { return mVal->ToDOMAnimVal(aAnimVal, mSVGElement); }
   };
+
+#ifdef MOZ_SMIL
+  struct SMILLength : public nsISMILAttr
+  {
+  public:
+    SMILLength(nsSVGLength2* aVal, nsSVGElement *aSVGElement)
+      : mVal(aVal), mSVGElement(aSVGElement) {}
+
+    // These will stay alive because a nsISMILAttr only lives as long
+    // as the Compositing step, and DOM elements don't get a chance to
+    // die during that.
+    nsSVGLength2* mVal;
+    nsSVGElement* mSVGElement;
+
+
+    // nsISMILAttr methods
+    virtual nsISMILType* GetSMILType(const void *aData);
+    virtual nsresult  ValueFromString(const nsAString& aStr, const void* aData,
+                                      nsSMILValue &aValue);
+    virtual nsresult  GetBaseValue(nsSMILValue& aValue);
+    virtual nsresult  SetAnimValue(const nsSMILValue& aValue);
+  };
+#endif // MOZ_SMIL
 };
 
-#endif
+#endif //  __NS_SVGLENGTH2_H__
diff --git a/content/svg/content/src/nsSVGSVGElement.cpp b/content/svg/content/src/nsSVGSVGElement.cpp
--- a/content/svg/content/src/nsSVGSVGElement.cpp
+++ b/content/svg/content/src/nsSVGSVGElement.cpp
@@ -17,16 +17,17 @@
  * The Initial Developer of the Original Code is
  * Crocodile Clips Ltd..
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Alex Fritze <alex.fritze@crocodile-clips.com> (original author)
  *   Jonathan Watt <jonathan.watt@strath.ac.uk>
+ *   Chris Double  <chris.double@double.co.nz>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -58,16 +59,26 @@
 #include "nsSVGRect.h"
 #include "nsSVGPreserveAspectRatio.h"
 #include "nsISVGValueUtils.h"
 #include "nsDOMError.h"
 #include "nsISVGChildFrame.h"
 #include "nsGUIEvent.h"
 #include "nsSVGUtils.h"
 #include "nsSVGSVGElement.h"
+
+#ifdef MOZ_SMIL
+#include "nsEventDispatcher.h"
+#include "nsSMILAnimationRegistry.h"
+#include "nsSMILAnimationController.h"
+#include "nsIContentIterator.h"
+
+nsresult NS_NewContentIterator(nsIContentIterator** aInstancePtrResult);
+#endif // MOZ_SMIL
+
 
 nsSVGElement::LengthInfo nsSVGSVGElement::sLengthInfo[4] =
 {
   { &nsGkAtoms::x, 0, nsIDOMSVGLength::SVG_LENGTHTYPE_NUMBER, nsSVGUtils::X },
   { &nsGkAtoms::y, 0, nsIDOMSVGLength::SVG_LENGTHTYPE_NUMBER, nsSVGUtils::Y },
   { &nsGkAtoms::width, 100, nsIDOMSVGLength::SVG_LENGTHTYPE_PERCENTAGE, nsSVGUtils::X },
   { &nsGkAtoms::height, 100, nsIDOMSVGLength::SVG_LENGTHTYPE_PERCENTAGE, nsSVGUtils::Y },
 };
@@ -443,51 +454,84 @@ nsSVGSVGElement::ForceRedraw()
 
   return NS_OK;
 }
 
 /* void pauseAnimations (); */
 NS_IMETHODIMP
 nsSVGSVGElement::PauseAnimations()
 {
+#ifdef MOZ_SMIL
+  NS_ENSURE_TRUE(mAnimationRegistry, NS_ERROR_FAILURE);
+  mAnimationRegistry->Pause();
+  return NS_OK;
+#else
   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::PauseAnimations");
   return NS_ERROR_NOT_IMPLEMENTED;
+#endif
 }
 
 /* void unpauseAnimations (); */
 NS_IMETHODIMP
 nsSVGSVGElement::UnpauseAnimations()
 {
+#ifdef MOZ_SMIL
+  NS_ENSURE_TRUE(mAnimationRegistry, NS_ERROR_FAILURE);
+  mAnimationRegistry->Unpause();
+  return NS_OK;
+#else
   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::UnpauseAnimations");
   return NS_ERROR_NOT_IMPLEMENTED;
+#endif
 }
 
 /* boolean animationsPaused (); */
 NS_IMETHODIMP
 nsSVGSVGElement::AnimationsPaused(PRBool *_retval)
 {
+#ifdef MOZ_SMIL
+  NS_ENSURE_TRUE(mAnimationRegistry, NS_ERROR_FAILURE);
+  *_retval = mAnimationRegistry->IsPaused();
+  return NS_OK;
+#else
   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::AnimationsPaused");
   return NS_ERROR_NOT_IMPLEMENTED;
+#endif
 }
 
 /* float getCurrentTime (); */
 NS_IMETHODIMP
 nsSVGSVGElement::GetCurrentTime(float *_retval)
 {
+#ifdef MOZ_SMIL
+  NS_ENSURE_TRUE(mAnimationRegistry, NS_ERROR_FAILURE);
+  *_retval = mAnimationRegistry->GetCurrentTime();
+  return NS_OK;
+#else
   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetCurrentTime");
   return NS_ERROR_NOT_IMPLEMENTED;
+#endif
 }
 
 /* void setCurrentTime (in float seconds); */
 NS_IMETHODIMP
 nsSVGSVGElement::SetCurrentTime(float seconds)
 {
+#ifdef MOZ_SMIL
+  NS_ENSURE_TRUE(mAnimationRegistry, NS_ERROR_FAILURE);
+  nsresult rv = mAnimationRegistry->SetCurrentTime(seconds);
+  if (NS_SUCCEEDED(rv)) {
+    RequestSample();
+  }
+  return rv;
+#else
   NS_ENSURE_FINITE(seconds, NS_ERROR_ILLEGAL_VALUE);
   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::SetCurrentTime");
   return NS_ERROR_NOT_IMPLEMENTED;
+#endif
 }
 
 /* nsIDOMNodeList getIntersectionList (in nsIDOMSVGRect rect, in nsIDOMSVGElement referenceElement); */
 NS_IMETHODIMP
 nsSVGSVGElement::GetIntersectionList(nsIDOMSVGRect *rect,
                                      nsIDOMSVGElement *referenceElement,
                                      nsIDOMNodeList **_retval)
 {
@@ -1069,16 +1113,41 @@ nsSVGSVGElement::GetPreviousTranslate_y(
 }
 
 NS_IMETHODIMP_(float)
 nsSVGSVGElement::GetPreviousScale()
 {
   return mPreviousScale;
 }
 
+#ifdef MOZ_SMIL
+nsSMILAnimationRegistry*
+nsSVGSVGElement::GetAnimationRegistry()
+{
+  nsSMILAnimationRegistry* result = nsnull;
+
+  if (mAnimationRegistry) {
+    result = mAnimationRegistry;
+  } else {
+    // We must not be the outermost SVG element, try to find it
+    nsCOMPtr<nsIDOMSVGSVGElement> outerSVGDOM;
+
+    nsresult rv = GetOwnerSVGElement(getter_AddRefs(outerSVGDOM));
+
+    if (NS_SUCCEEDED(rv) && outerSVGDOM) {
+      nsSVGSVGElement *outerSVG =
+        static_cast<nsSVGSVGElement*>(outerSVGDOM.get());
+      result = outerSVG->GetAnimationRegistry();
+    }
+  }
+
+  return result;
+}
+#endif // MOZ_SMIL
+
 //----------------------------------------------------------------------
 // nsIContent methods
 
 NS_IMETHODIMP_(PRBool)
 nsSVGSVGElement::IsAttributeMapped(const nsIAtom* name) const
 {
   static const MappedAttributeEntry* const map[] = {
     sColorMap,
@@ -1122,16 +1191,31 @@ nsSVGSVGElement::UnsetAttr(PRInt32 aName
   nsSVGSVGElementBase::UnsetAttr(aNamespaceID, aName, aNotify);
 
   if (aNamespaceID == kNameSpaceID_None && aName == nsGkAtoms::viewBox) {
     InvalidateTransformNotifyFrame();
   }
 
   return NS_OK;
 }
+
+//----------------------------------------------------------------------
+// nsIContent methods:
+
+#ifdef MOZ_SMIL
+nsresult
+nsSVGSVGElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
+{
+  if (aVisitor.mEvent->message == NS_SVG_LOAD) {
+    if (mAnimationRegistry)
+      mAnimationRegistry->Start();
+  }
+  return nsSVGSVGElementBase::PreHandleEvent(aVisitor);
+}
+#endif // MOZ_SMIL
 
 //----------------------------------------------------------------------
 // nsISVGValueObserver methods:
 
 NS_IMETHODIMP
 nsSVGSVGElement::WillModifySVGObservable(nsISVGValue* observable,
                                          nsISVGValue::modificationType aModType)
 {
@@ -1260,16 +1344,62 @@ nsSVGSVGElement::GetViewboxToViewportTra
     nsSVGUtils::GetViewBoxTransform(viewportWidth, viewportHeight,
                                     viewboxX, viewboxY,
                                     viewboxWidth, viewboxHeight,
                                     mPreserveAspectRatio);
   xform.swap(*_retval);
 
   return NS_OK;
 }
+
+#ifdef MOZ_SMIL
+nsresult
+nsSVGSVGElement::BindToTree(nsIDocument* aDocument,
+                            nsIContent* aParent,
+                            nsIContent* aBindingParent,
+                            PRBool aCompileEventHandlers)
+{
+  nsCOMPtr<nsIDOMSVGSVGElement> outerSVG;
+
+  GetOwnerSVGElement(getter_AddRefs(outerSVG));
+
+  PRBool outermost = (outerSVG == nsnull);
+
+  if (!mAnimationRegistry && outermost) {
+    // We are now the outermost SVG element
+    mAnimationRegistry = NS_NewSMILAnimationRegistry();
+    NS_ENSURE_TRUE(mAnimationRegistry, NS_ERROR_FAILURE);
+  } else if (mAnimationRegistry && !outermost) {
+    mAnimationRegistry = nsnull;
+  }
+
+  nsresult rv = nsSVGSVGElementBase::BindToTree(aDocument, aParent,
+                                                aBindingParent,
+                                                aCompileEventHandlers);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  nsSMILAnimationController *smilController = 
+    GetAnimationController(aDocument, PR_TRUE);
+
+  if (mAnimationRegistry && smilController)
+    rv = mAnimationRegistry->SetController(smilController);
+
+  return rv;
+}
+
+void
+nsSVGSVGElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
+{
+  if (mAnimationRegistry)
+    mAnimationRegistry->SetController(nsnull);
+
+  nsSVGSVGElementBase::UnbindFromTree(aDeep, aNullParent);
+}
+
+#endif // MOZ_SMIL
 
 //----------------------------------------------------------------------
 // implementation helpers
 
 // if an ancestor isn't specified, obtains offset from root frame
 void nsSVGSVGElement::GetOffsetToAncestor(nsIContent* ancestor,
                                           float &x, float &y)
 {
diff --git a/content/svg/content/src/nsSVGSVGElement.h b/content/svg/content/src/nsSVGSVGElement.h
--- a/content/svg/content/src/nsSVGSVGElement.h
+++ b/content/svg/content/src/nsSVGSVGElement.h
@@ -43,16 +43,20 @@
 #include "nsSVGStylableElement.h"
 #include "nsIDOMSVGSVGElement.h"
 #include "nsIDOMSVGFitToViewBox.h"
 #include "nsIDOMSVGLocatable.h"
 #include "nsIDOMSVGZoomAndPan.h"
 #include "nsIDOMSVGMatrix.h"
 #include "nsSVGLength2.h"
 #include "nsSVGEnum.h"
+
+#ifdef MOZ_SMIL
+class nsSMILAnimationRegistry;
+#endif // MOZ_SMIL
 
 #define QI_AND_CAST_TO_NSSVGSVGELEMENT(base)                                  \
   (nsCOMPtr<nsIDOMSVGSVGElement>(do_QueryInterface(base)) ?                   \
    static_cast<nsSVGSVGElement*>(base.get()) : nsnull)
 
 typedef nsSVGStylableElement nsSVGSVGElementBase;
 
 class svgFloatSize {
@@ -124,18 +128,25 @@ public:
   /**
    * Retrieve the value of currentScale, currentTranslate.x or
    * currentTranslate.y prior to the last change made to any one of them.
    */
   NS_IMETHOD_(float) GetPreviousTranslate_x();
   NS_IMETHOD_(float) GetPreviousTranslate_y();
   NS_IMETHOD_(float) GetPreviousScale();
 
+#ifdef MOZ_SMIL
+  NS_IMETHOD_(nsSMILAnimationRegistry*) GetAnimationRegistry();
+#endif // MOZ_SMIL
+
   // nsIContent interface
   NS_IMETHOD_(PRBool) IsAttributeMapped(const nsIAtom* aAttribute) const;
+#ifdef MOZ_SMIL
+  virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
+#endif // MOZ_SMIL
 
   virtual nsresult AfterSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
                                 const nsAString* aValue, PRBool aNotify);
   virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
                              PRBool aNotify);
 
   // nsISVGValueObserver
   NS_IMETHOD WillModifySVGObservable(nsISVGValue* observable,
@@ -165,18 +176,27 @@ public:
     mViewportWidth  = aSize.width;
     mViewportHeight = aSize.height;
   }
 
 protected:
   // nsSVGElement overrides
   PRBool IsEventName(nsIAtom* aName);
 
+#ifdef MOZ_SMIL
+  virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
+                              nsIContent* aBindingParent,
+                              PRBool aCompileEventHandlers);
+  virtual void UnbindFromTree(PRBool aDeep = PR_TRUE,
+                              PRBool aNullParent = PR_TRUE);
+#endif // MOZ_SMIL   
+
   // implementation helpers:
   void GetOffsetToAncestor(nsIContent* ancestor, float &x, float &y);
+
   PRBool IsRoot() {
     NS_ASSERTION((IsInDoc() && !GetParent()) ==
                  (GetOwnerDoc() && (GetOwnerDoc()->GetRootContent() == this)),
                  "Can't determine if we're root");
     return IsInDoc() && !GetParent();
   }
 
   // invalidate viewbox -> viewport xform & inform frames
@@ -216,11 +236,16 @@ protected:
   // members below - see the comment in RecordCurrentScaleTranslate
   nsCOMPtr<nsIDOMSVGPoint>          mCurrentTranslate;
   nsCOMPtr<nsIDOMSVGNumber>         mCurrentScale;
   float                             mPreviousTranslate_x;
   float                             mPreviousTranslate_y;
   float                             mPreviousScale;
   PRInt32                           mRedrawSuspendCount;
   PRPackedBool                      mDispatchEvent;
+
+#ifdef MOZ_SMIL
+  // animation
+  nsAutoPtr<nsSMILAnimationRegistry> mAnimationRegistry;
+#endif // MOZ_SMIL
 };
 
 #endif
diff --git a/content/svg/content/src/nsSVGSetElement.cpp b/content/svg/content/src/nsSVGSetElement.cpp
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGSetElement.cpp
@@ -0,0 +1,108 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGAnimationElement.h"
+#include "nsIDOMSVGSetElement.h"
+
+typedef nsSVGAnimationElement nsSVGSetElementBase;
+
+class nsSVGSetElement : public nsSVGSetElementBase,
+                        public nsIDOMSVGSetElement
+{
+protected:
+  friend nsresult NS_NewSVGSetElement(nsIContent **aResult,
+                                      nsINodeInfo *aNodeInfo);
+  nsSVGSetElement(nsINodeInfo* aNodeInfo);
+  nsresult Init();
+
+public:
+  // interfaces:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIDOMSVGSETELEMENT
+
+  NS_FORWARD_NSIDOMNODE(nsSVGSetElementBase::)
+  NS_FORWARD_NSIDOMELEMENT(nsSVGSetElementBase::)
+  NS_FORWARD_NSIDOMSVGELEMENT(nsSVGSetElementBase::)
+  NS_FORWARD_NSIDOMSVGANIMATIONELEMENT(nsSVGSetElementBase::)
+  
+  // nsIDOMNode specializations
+  virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
+};
+
+NS_IMPL_NS_NEW_SVG_ELEMENT(Set)
+
+
+//----------------------------------------------------------------------
+// nsISupports methods
+
+NS_IMPL_ADDREF_INHERITED(nsSVGSetElement,nsSVGSetElementBase)
+NS_IMPL_RELEASE_INHERITED(nsSVGSetElement,nsSVGSetElementBase)
+
+NS_INTERFACE_MAP_BEGIN(nsSVGSetElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimationElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGSetElement)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGAnimateElement)
+NS_INTERFACE_MAP_END_INHERITING(nsSVGSetElementBase)
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSVGSetElement::nsSVGSetElement(nsINodeInfo *aNodeInfo)
+  : nsSVGSetElementBase(aNodeInfo)
+{
+}
+
+nsresult
+nsSVGSetElement::Init()
+{
+  nsresult rv = nsSVGSetElementBase::Init();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  mAnimationSpec->GetAnimationFunction()->SetAttr(nsGkAtoms::calcMode,
+                                                  NS_LITERAL_STRING("discrete"),
+                                                  &rv);
+  return rv;
+}
+
+//----------------------------------------------------------------------
+// nsIDOMNode methods
+
+NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGSetElement)
diff --git a/content/svg/content/src/nsSVGTransformSMILAttr.cpp b/content/svg/content/src/nsSVGTransformSMILAttr.cpp
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGTransformSMILAttr.cpp
@@ -0,0 +1,317 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGTransformSMILAttr.h"
+#include "nsSVGTransformSMILType.h"
+#include "nsSVGAnimatedTransformList.h"
+#include "nsIDOMSVGTransform.h"
+#include "nsIDOMSVGMatrix.h"
+#include "nsSVGTransformList.h"
+#include "nsSVGMatrix.h"
+#include "nsSMILValue.h"
+#include "nsSMILNullType.h"
+#include "nsSVGElement.h"
+#include "nsISVGValue.h"
+#include "prdtoa.h"
+
+nsISMILType *
+nsSVGTransformSMILAttr::GetSMILType(const void *aData)
+{
+  NS_ENSURE_TRUE(aData, &nsSMILNullType::sSingleton);
+
+  const nsIAtom* transformType = static_cast<const nsIAtom*>(aData);
+   
+  if (transformType == nsGkAtoms::translate) {
+    return &nsSVGTransformSMILType::sTranslateTransformType;
+  } else if (transformType == nsGkAtoms::scale) {
+    return &nsSVGTransformSMILType::sScaleTransformType;
+  } else if (transformType == nsGkAtoms::rotate) {
+    return &nsSVGTransformSMILType::sRotateTransformType;
+  } else if (transformType == nsGkAtoms::skewX) {
+    return &nsSVGTransformSMILType::sSkewXTransformType;
+  } else if (transformType == nsGkAtoms::skewY) {
+    return &nsSVGTransformSMILType::sSkewYTransformType;
+  } else {
+    NS_NOTREACHED("Bad transform type");
+    return &nsSMILNullType::sSingleton;
+  }
+}
+
+nsresult
+nsSVGTransformSMILAttr::ValueFromString(const nsAString& aStr,
+                                        const void* aData,
+                                        nsSMILValue &aValue)
+{
+  NS_ENSURE_TRUE(aData, NS_ERROR_FAILURE);
+
+  const nsIAtom* transformType = static_cast<const nsIAtom*>(aData);
+
+  nsISMILType *type = GetSMILType(transformType);
+  NS_ENSURE_TRUE(type, NS_ERROR_FAILURE);
+
+  nsIDOMSVGMatrix *matrix = nsnull;
+  nsresult rv = ParseValue(aStr, transformType, &matrix);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  aValue.mU.mPtr = matrix; /* NS_NewSVGMatrix will addref */
+  aValue.mType   = type;
+
+  return NS_OK;
+}
+
+// Returns the base transform-matrix for the animation target.
+nsresult
+nsSVGTransformSMILAttr::GetBaseValue(nsSMILValue& aValue)
+{
+  nsCOMPtr<nsIDOMSVGTransform> transform;
+  nsresult rv = mVal->mBaseVal->Consolidate(getter_AddRefs(transform));
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  nsCOMPtr<nsIDOMSVGMatrix> matrix;
+  /* Consolidate sets transform to NULL if there are no matrices */
+  if (transform)
+    rv = transform->GetMatrix(getter_AddRefs(matrix));
+  else
+    rv = NS_NewSVGMatrix(getter_AddRefs(matrix));
+  NS_ENSURE_SUCCESS(rv,rv);
+  NS_ENSURE_TRUE(matrix,NS_ERROR_FAILURE);
+
+  nsSMILValue val;
+
+  /* 
+   * Assign the type first or if something goes wrong the matrix might never be
+   * released.
+   */
+  // XXXdholbert: I'm arbitrarily choosing to set the type to _translate_
+  // transform here, even though this base transform-matrix could really be
+  // anything.  It'd probably be cleaner to use some generic/'other' transform
+  // type here.  But in any case, this shouldn't affect behavior, because
+  // compositing doesn't depend on the transform-type of the base matrix.
+  val.mType = &nsSVGTransformSMILType::sTranslateTransformType;
+  NS_ENSURE_TRUE(val.mType, NS_ERROR_FAILURE);
+
+  nsIDOMSVGMatrix *raw_matrix = matrix;
+  val.mU.mPtr = raw_matrix;
+
+  // XXXdholbert Where does this get NS_RELEASE'd? 
+  // (Add a note here indicating where, for clarity)
+  NS_ADDREF(raw_matrix);
+
+  aValue = val;
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGTransformSMILAttr::SetAnimValue(const nsSMILValue& aValue)
+{
+  if (aValue.mType != &nsSVGTransformSMILType::sTranslateTransformType &&
+      aValue.mType != &nsSVGTransformSMILType::sScaleTransformType &&
+      aValue.mType != &nsSVGTransformSMILType::sRotateTransformType &&
+      aValue.mType != &nsSVGTransformSMILType::sSkewXTransformType &&
+      aValue.mType != &nsSVGTransformSMILType::sSkewYTransformType) {
+    NS_NOTREACHED("Unexpected SMIL Type");
+    return NS_ERROR_FAILURE;
+  }
+
+  nsIDOMSVGMatrix *value = (nsIDOMSVGMatrix *)aValue.mU.mPtr;
+  NS_ENSURE_TRUE(value,NS_ERROR_FAILURE);
+
+  mVal->WillModify(nsISVGValue::mod_other);
+
+  nsresult rv = NS_OK;
+
+  if (!mVal->mAnimVal)
+  {
+    rv = nsSVGTransformList::Create(getter_AddRefs(mVal->mAnimVal));
+    NS_ENSURE_SUCCESS(rv,NS_ERROR_FAILURE);
+  }
+
+  mVal->mAnimVal->Clear();
+
+  nsCOMPtr<nsIDOMSVGTransform> transform;
+  rv = mVal->mBaseVal->CreateSVGTransformFromMatrix(value,
+                                                    getter_AddRefs(transform));
+
+  nsCOMPtr<nsIDOMSVGTransform> result;
+  rv = mVal->mAnimVal->AppendItem(transform, getter_AddRefs(result));
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  mVal->DidModify(nsISVGValue::mod_other);
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+nsresult
+nsSVGTransformSMILAttr::ParseValue(const nsAString &aSpec,
+                                   const nsIAtom *aTransformType,
+                                   nsIDOMSVGMatrix** aMatrix) const
+{
+  nsresult rv = NS_OK;
+
+  if (aTransformType == nsGkAtoms::translate) {
+    // tx [ty=0]
+    float t[2] = { 0.f };
+    PRInt32 num_parsed = ParseParameterList(aSpec, t, 2);
+    if (num_parsed != 1 && num_parsed != 2) {
+      rv = NS_ERROR_FAILURE;
+    } else {      
+      rv = NS_NewSVGMatrix(aMatrix, 1.f, 0.f, 0.f, 1.f, t[0], t[1]);
+    }
+  } else if (aTransformType == nsGkAtoms::scale) {
+    // sx [sy=sx]
+    float s[2] = { 0.f };
+    PRInt32 num_parsed = ParseParameterList(aSpec, s, 2);
+    if (num_parsed != 1 && num_parsed != 2) {
+      rv = NS_ERROR_FAILURE; // parse error
+    } else {
+      if (num_parsed == 1)
+        s[1] = s[0];
+      rv = NS_NewSVGMatrix(aMatrix, s[0], 0.f, 0.f, s[1], 0.f, 0.f);
+    }
+  } else if (aTransformType == nsGkAtoms::rotate) {
+    // r [cx=0 cy=0]
+    // Per SVG1.1 sec 7.6, this operation represents the equivalent of doing
+    //  translate(<cx>, <cy>) rotate(<rotate-angle>) translate(-<cx>, -<cy>).
+    // XXXdholbert Animation of rotation transforms is currently broken. Need to:
+    //  - Honor / interpolate the "cx / cy" coordinates
+    //  - Store & interpolate between the *actual specified angles* (which may
+    //    be greater than 360) rather than between the reverse-engineered
+    //    angles extracted via acos()
+    float r[3] = { 0.f };
+    PRInt32 num_parsed = ParseParameterList(aSpec, r, 3);
+    if (num_parsed != 1 && num_parsed != 3) {
+      rv = NS_ERROR_FAILURE; // parse error
+    } else {
+      nsCOMPtr<nsIDOMSVGMatrix> temp;
+      rv = NS_NewSVGMatrix(getter_AddRefs(temp));
+      NS_ENSURE_SUCCESS(rv,rv);
+
+      nsCOMPtr<nsIDOMSVGMatrix> temp2;
+      rv = temp->Rotate(r[0], getter_AddRefs(temp2));
+      NS_ENSURE_SUCCESS(rv,rv);
+
+      rv = temp2->Translate(-r[1],-r[2], getter_AddRefs(temp));
+      NS_ENSURE_SUCCESS(rv,rv);
+
+      *aMatrix = temp;
+      NS_ADDREF(*aMatrix);
+    }
+  } else if (aTransformType == nsGkAtoms::skewX) {
+    // x-angle
+    float angle;
+    PRInt32 num_parsed = ParseParameterList(aSpec, &angle, 1);
+    if (num_parsed != 1) {
+      rv = NS_ERROR_FAILURE; // parse error
+    } else {
+      nsCOMPtr<nsIDOMSVGMatrix> temp_matrix;
+      rv = NS_NewSVGMatrix(getter_AddRefs(temp_matrix));
+      NS_ENSURE_SUCCESS(rv,rv);
+
+      rv = temp_matrix->SkewX(angle, aMatrix);
+    }
+  } else if (aTransformType == nsGkAtoms::skewY) {
+    // y-angle
+    float angle;
+    PRInt32 num_parsed = ParseParameterList(aSpec, &angle, 1);
+    if (num_parsed != 1) {
+      rv = NS_ERROR_FAILURE; // parse error
+    } else {
+      nsCOMPtr<nsIDOMSVGMatrix> temp_matrix;
+      rv = NS_NewSVGMatrix(getter_AddRefs(temp_matrix));
+      NS_ENSURE_SUCCESS(rv,rv);
+
+      rv = temp_matrix->SkewY(angle, aMatrix);
+    }
+  } else {
+    rv = NS_ERROR_FAILURE;
+  }
+
+  return rv;
+}
+
+inline PRBool
+nsSVGTransformSMILAttr::IsSpace(const char c) const
+{
+  return (c == 0x9 || c == 0xA || c == 0xD || c == 0x20);
+}
+
+inline void
+nsSVGTransformSMILAttr::SkipWsp(nsACString::const_iterator& aIter,
+                                const nsACString::const_iterator& aIterEnd) const
+{
+  while (aIter != aIterEnd && IsSpace(*aIter))
+    ++aIter;
+}
+
+PRInt32
+nsSVGTransformSMILAttr::ParseParameterList(const nsAString &aSpec,
+                                           float *aVars,
+                                           PRInt32 aNVars) const
+{
+  nsCAutoString spec;
+  LossyCopyUTF16toASCII(aSpec, spec);
+
+  nsACString::const_iterator start, end;
+  spec.BeginReading(start);
+  spec.EndReading(end);
+
+  SkipWsp(start, end);
+
+  int num_args_found = 0;
+
+  while (start != end) {
+    char const *arg = start.get();
+    char *argend;
+    float f = (float)PR_strtod(arg, &argend);
+    if (arg == argend || argend > end.get())
+      return -1;
+
+    if (num_args_found < aNVars) {
+      aVars[num_args_found] = f;
+    }
+
+    start.advance(argend - arg);
+    num_args_found++;
+
+    SkipWsp(start, end);
+  }
+
+  return num_args_found;
+}
diff --git a/content/svg/content/src/nsSVGTransformSMILAttr.h b/content/svg/content/src/nsSVGTransformSMILAttr.h
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGTransformSMILAttr.h
@@ -0,0 +1,83 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SVGTRANSFORMSMILATTR_H__
+#define __NS_SVGTRANSFORMSMILATTR_H__
+
+#include "nsISMILAttr.h"
+#include "nsIAtom.h"
+#include "nsAutoPtr.h"
+#include "nsString.h"
+
+class nsSVGElement;
+class nsSVGAnimatedTransformList;
+class nsISMILType;
+class nsIDOMSVGMatrix;
+
+class nsSVGTransformSMILAttr : public nsISMILAttr
+{
+public:
+  nsSVGTransformSMILAttr(nsSVGAnimatedTransformList* aTransform,
+                         nsSVGElement* aSVGElement)
+    : mVal(aTransform),
+      mSVGElement(aSVGElement) {}
+
+  // nsISMILAttr methods
+  virtual nsISMILType* GetSMILType(const void* aData);
+  virtual nsresult     ValueFromString(const nsAString& aStr, const void* aData,
+                                       nsSMILValue &aValue);
+  virtual nsresult     GetBaseValue(nsSMILValue& aValue);
+  virtual nsresult     SetAnimValue(const nsSMILValue& aValue);
+protected:
+  nsresult  ParseValue(const nsAString &aSpec,
+                       const nsIAtom* aTransformType,
+                       nsIDOMSVGMatrix** aMatrix) const;
+  PRInt32   ParseParameterList(const nsAString &aSpec, float *aVars,
+                               PRInt32 aNVars) const;
+  PRBool    IsSpace(const char c) const;
+  void      SkipWsp(nsACString::const_iterator& aIter,
+                    const nsACString::const_iterator& aIterEnd) const;
+
+private:
+  // Raw pointers are OK here because this nsSVGTransformSMILAttr is both
+  // created & destroyed during a SMIL sample-step, during which time the DOM
+  // isn't modified.
+  nsSVGAnimatedTransformList* mVal;
+  nsSVGElement* mSVGElement;
+};
+
+#endif // __NS_SVGTRANSFORMSMILATTR_H__
diff --git a/content/svg/content/src/nsSVGTransformSMILType.cpp b/content/svg/content/src/nsSVGTransformSMILType.cpp
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGTransformSMILType.cpp
@@ -0,0 +1,319 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGTransformSMILType.h"
+#include "nsSMILValue.h"
+#include "nsIDOMSVGTransform.h"
+#include "nsSVGMatrix.h"
+#include "nsCOMPtr.h"
+#include "nsCRT.h"
+#include <math.h>
+
+nsSVGTransformSMILType nsSVGTransformSMILType::sTranslateTransformType(
+    nsIDOMSVGTransform::SVG_TRANSFORM_TRANSLATE);
+nsSVGTransformSMILType nsSVGTransformSMILType::sScaleTransformType(
+    nsIDOMSVGTransform::SVG_TRANSFORM_SCALE);
+nsSVGTransformSMILType nsSVGTransformSMILType::sRotateTransformType(
+    nsIDOMSVGTransform::SVG_TRANSFORM_ROTATE);
+nsSVGTransformSMILType nsSVGTransformSMILType::sSkewXTransformType(
+    nsIDOMSVGTransform::SVG_TRANSFORM_SKEWX);
+nsSVGTransformSMILType nsSVGTransformSMILType::sSkewYTransformType(
+    nsIDOMSVGTransform::SVG_TRANSFORM_SKEWY);
+
+void
+nsSVGTransformSMILType::SetValueIdentity(nsSMILValue &value)
+{
+  NS_ASSERTION(value.mType == this, "Unexpected SMIL value type.");
+
+  nsIDOMSVGMatrix *matrix = nsnull;
+  if (NS_FAILED(NS_NewSVGMatrix(&matrix))) {
+    value.mType = &nsSMILNullType::sSingleton;
+    return;
+  }
+
+  value.mU.mPtr = matrix; /* NS_NewSVGMatrix will addref */
+}
+
+void
+nsSVGTransformSMILType::DestroyValue(nsSMILValue& value)
+{
+  NS_ASSERTION(value.mType == this, "Unexpected SMIL value type.");
+  nsIDOMSVGMatrix *matrix = (nsIDOMSVGMatrix *)value.mU.mPtr;
+  NS_IF_RELEASE(matrix);
+}
+
+nsresult
+nsSVGTransformSMILType::AssignValue(nsSMILValue& aDest, const nsSMILValue& aSrc)
+{
+  NS_ASSERTION(aDest.mType == aSrc.mType, "Incompatible SMIL types.");
+  NS_ASSERTION(aDest.mType == this, "Unexpected SMIL value.");
+
+  float a, b, c, d, e, f;
+  nsIDOMSVGMatrix *src_matrix = (nsIDOMSVGMatrix *)aSrc.mU.mPtr;
+
+  src_matrix->GetA(&a);
+  src_matrix->GetB(&b);
+  src_matrix->GetC(&c);
+  src_matrix->GetD(&d);
+  src_matrix->GetE(&e);
+  src_matrix->GetF(&f);
+
+  nsIDOMSVGMatrix *matrix = nsnull;
+  nsresult rv = NS_NewSVGMatrix(&matrix, a, b, c, d, e, f);
+  if (NS_FAILED(rv)) {
+    aDest.mType = &nsSMILNullType::sSingleton;
+    return rv;
+  }
+
+  aDest.mU.mPtr = matrix; /* NS_NewSVGMatrix will addref */
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGTransformSMILType::Add(nsSMILValue& aDest, const nsSMILValue& aSrc)
+{
+  NS_ASSERTION(aDest.mType == this, "Unexpected SMIL type.");
+
+  if (aSrc.mType != &nsSVGTransformSMILType::sTranslateTransformType &&
+      aSrc.mType != &nsSVGTransformSMILType::sScaleTransformType &&
+      aSrc.mType != &nsSVGTransformSMILType::sRotateTransformType &&
+      aSrc.mType != &nsSVGTransformSMILType::sSkewXTransformType &&
+      aSrc.mType != &nsSVGTransformSMILType::sSkewYTransformType) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsIDOMSVGMatrix *dest_matrix = (nsIDOMSVGMatrix *)aDest.mU.mPtr;
+  nsIDOMSVGMatrix *src_matrix  = (nsIDOMSVGMatrix *)aSrc.mU.mPtr;
+
+  if (!dest_matrix || !src_matrix)
+    return NS_ERROR_FAILURE;
+
+  nsIDOMSVGMatrix *temp;
+  nsresult rv = dest_matrix->Multiply(src_matrix, &temp);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  NS_ADDREF(temp);
+  NS_RELEASE(dest_matrix);
+  aDest.mU.mPtr = temp;
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGTransformSMILType::ComputeDistance(const nsSMILValue& aFrom,
+                                     const nsSMILValue& aTo,
+                                     PRFloat64& aDistance) const
+{
+  NS_ASSERTION(aFrom.mType == aTo.mType, 
+      "Can't compute difference between different SMIL types.");
+  NS_ASSERTION(aFrom.mType == this, "Unexpected SMIL type.");
+
+  (void)aFrom;
+  (void)aTo;
+
+  aDistance = 0.0;
+  NS_NOTYETIMPLEMENTED("nsSVGAnimatedTransformList::ComputeDistance");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult
+nsSVGTransformSMILType::Interpolate(const nsSMILValue& aStartVal,
+                                    const nsSMILValue& aEndVal,
+                                    float aUnitDistance,
+                                    nsSMILValue& aResult)
+{
+  NS_ASSERTION(aStartVal.mType == aEndVal.mType,
+      "Can't interpolate between different SMIL types.");
+  NS_ASSERTION(aStartVal.mType == this, "Unexpected SMIL type.");
+
+  /* 
+   * We cast away constness here because nsIDOMSVGMatrix getters aren't marked
+   * as const.
+   */
+  nsIDOMSVGMatrix* start = (nsIDOMSVGMatrix*)aStartVal.mU.mPtr;
+  nsIDOMSVGMatrix* end   = (nsIDOMSVGMatrix*)aEndVal.mU.mPtr;
+  NS_ENSURE_TRUE(start && end, NS_ERROR_FAILURE);
+
+  nsresult rv = NS_OK;
+
+  nsCOMPtr<nsIDOMSVGMatrix> result = nsnull;
+  rv = NS_NewSVGMatrix(getter_AddRefs(result));
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  switch (mTransformType)
+  {
+  case nsIDOMSVGTransform::SVG_TRANSFORM_TRANSLATE:
+    {
+      float txa,tya;
+      start->GetE(&txa);
+      start->GetF(&tya);
+
+      float txb,tyb;
+      end->GetE(&txb);
+      end->GetF(&tyb);
+
+      result->SetE(txa + (txb - txa) * aUnitDistance);
+      result->SetF(tya + (tyb - tya) * aUnitDistance);
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SCALE:
+    {
+      float sxa,sya;
+      start->GetA(&sxa);
+      start->GetD(&sya);
+
+      float sxb,syb;
+      end->GetA(&sxb);
+      end->GetD(&syb);
+
+      result->SetA(sxa + (sxb - sxa) * aUnitDistance);
+      result->SetD(sya + (syb - sya) * aUnitDistance);
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_ROTATE:
+    {
+      // XXXdholbert FIXME This doesn't correctly handle situations where
+      // the angles are outside the range of 0 - 180 degrees.
+      // (including situations with multiple full rotations)
+      // This also doesn't handle the 'cx' and 'cy' values at all.
+      // (in 'r [cx=0 cy=0]')
+      // See also notes in nsSVGTransformSMILAttr.cpp, below
+      // "else if (aTransformType == nsGkAtoms::rotate)"
+      float da;
+      start->GetA(&da);
+      float aa = acos(da);
+
+      float db;
+      end->GetA(&db);
+      float ab = acos(db);
+
+      float newa = (aa + (ab - aa) * aUnitDistance);
+      result->SetA(cos(newa));
+      result->SetB(sin(newa));
+      result->SetC(-sin(newa));
+      result->SetD(cos(newa));
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SKEWX:
+    {
+      float da;
+      start->GetC(&da);
+      float aa = atan(da);
+
+      float db;
+      end->GetC(&db);
+      float ab = atan(db);
+
+      float newa = (aa + (ab - aa) * aUnitDistance);
+      result->SetC(tan(newa));
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SKEWY:
+    {
+      float da;
+      start->GetB(&da);
+      float aa = atan(da);
+
+      float db;
+      end->GetB(&db);
+      float ab = atan(db);
+
+      float newa = (aa + (ab - aa) * aUnitDistance);
+      result->SetB(tan(newa));
+    }
+    break;
+
+  default:
+    return NS_ERROR_FAILURE;
+  }
+
+  nsIDOMSVGMatrix *raw_result = result.get();
+  aResult.mType   = this;
+  aResult.mU.mPtr = raw_result;
+  NS_ADDREF(raw_result);
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGTransformSMILType::Repeat(nsSMILValue& aDest,
+                               PRUint32 aCount,
+                               const nsSMILValue* aRepeatValue)
+{
+  NS_ASSERTION(aDest.mType == this, "Unexpected SMIL type.");
+  NS_ASSERTION(!aRepeatValue || aRepeatValue->mType == this,
+      "Unexpected SMIL type for repeat value.");
+
+  nsCOMPtr<nsIDOMSVGMatrix> target =
+    static_cast<nsIDOMSVGMatrix*>(aDest.mU.mPtr);
+  NS_ENSURE_TRUE(target, NS_ERROR_FAILURE);
+
+  nsCOMPtr<nsIDOMSVGMatrix> repeatValue(target);
+
+  if (aRepeatValue) {
+    /* 
+     * Casting away const-ness because nsIDOMSVGMatrix::Multiply is non-const
+     * (although it should be const).
+     */
+    repeatValue = (nsIDOMSVGMatrix *)(aRepeatValue->mU.mPtr);
+  }
+
+  // XXX Do matrix multiplication here. nsSVGMatrix::Multiply does an allocation
+  // every time it is called.
+  for (PRUint32 i = 0; i <= aCount; ++i)
+  {
+    nsCOMPtr<nsIDOMSVGMatrix> temp;
+    nsresult rv = target->Multiply(repeatValue, getter_AddRefs(temp));
+    NS_ENSURE_SUCCESS(rv,rv);
+    target = temp;
+  }
+
+  nsIDOMSVGMatrix *dest = static_cast<nsIDOMSVGMatrix*>(aDest.mU.mPtr);
+  NS_RELEASE(dest);
+  /* Even if aDest and target point to the same matrix target will keep it
+   * alive. */
+  nsIDOMSVGMatrix *raw_target = target.get();
+  aDest.mU.mPtr = raw_target;
+  NS_ADDREF(raw_target);
+
+  return NS_OK;
+}
diff --git a/content/svg/content/src/nsSVGTransformSMILType.h b/content/svg/content/src/nsSVGTransformSMILType.h
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGTransformSMILType.h
@@ -0,0 +1,77 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SVGTRANSFORMSMILTYPE_H__
+#define __NS_SVGTRANSFORMSMILTYPE_H__
+
+#include "nsISMILType.h"
+
+struct nsSMILValue;
+class nsIDOMSVGMatrix;
+
+class nsSVGTransformSMILType : public nsISMILType
+{
+public:
+  virtual void        SetValueIdentity(nsSMILValue& aValue);
+  virtual void        DestroyValue(nsSMILValue& aValue);
+  virtual nsresult    AssignValue(nsSMILValue& aDest,
+                                  const nsSMILValue& aSrc);
+  virtual nsresult    Add(nsSMILValue& aDest, const nsSMILValue& aSrc);
+  virtual nsresult    ComputeDistance(const nsSMILValue& aFrom,
+                                      const nsSMILValue& aTo,
+                                      PRFloat64& aDistance) const;
+  virtual nsresult    Interpolate(const nsSMILValue& aStartVal,
+                                         const nsSMILValue& aEndVal,
+                                         float aUnitDistance,
+                                         nsSMILValue& aResult);
+  virtual nsresult    Repeat(nsSMILValue& aDest,
+                             PRUint32 aCount,
+                             const nsSMILValue* aRepeatValue);
+
+  static nsSVGTransformSMILType sTranslateTransformType;
+  static nsSVGTransformSMILType sScaleTransformType;
+  static nsSVGTransformSMILType sRotateTransformType;
+  static nsSVGTransformSMILType sSkewXTransformType;
+  static nsSVGTransformSMILType sSkewYTransformType;
+
+private:
+  nsSVGTransformSMILType(PRUint16 aType) : mTransformType(aType) {}
+
+  PRUint16                    mTransformType;
+};
+
+#endif // __NS_SVGTRANSFORMSMILTYPE_H__
diff --git a/content/xml/document/src/nsXMLContentSink.cpp b/content/xml/document/src/nsXMLContentSink.cpp
--- a/content/xml/document/src/nsXMLContentSink.cpp
+++ b/content/xml/document/src/nsXMLContentSink.cpp
@@ -1174,17 +1174,21 @@ nsXMLContentSink::HandleEndElement(const
     }
     mNotifyLevel = stackLen - 1;
   }
   DidAddContent();
 
 #ifdef MOZ_SVG
   if (mDocument &&
       content->GetNameSpaceID() == kNameSpaceID_SVG &&
-      content->HasAttr(kNameSpaceID_None, nsGkAtoms::onload)) {
+      (
+#ifdef MOZ_SMIL
+       content->Tag() == nsGkAtoms::svg ||
+#endif
+       content->HasAttr(kNameSpaceID_None, nsGkAtoms::onload))) {
     FlushTags();
 
     nsEvent event(PR_TRUE, NS_SVG_LOAD);
     event.eventStructType = NS_SVG_EVENT;
     event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
 
     // Do we care about forcing presshell creation if it hasn't happened yet?
     // That is, should this code flush or something?  Does it really matter?
diff --git a/dom/public/idl/Makefile.in b/dom/public/idl/Makefile.in
--- a/dom/public/idl/Makefile.in
+++ b/dom/public/idl/Makefile.in
@@ -62,10 +62,14 @@ DIRS =						\
 	offline                                 \
 	geolocation                             \
 	threads
 
 ifdef MOZ_SVG
 DIRS += svg
 endif
 
+ifdef MOZ_SMIL
+DIRS += smil
+endif
+
 include $(topsrcdir)/config/rules.mk
 
diff --git a/dom/public/idl/smil/Makefile.in b/dom/public/idl/smil/Makefile.in
new file mode 100644
--- /dev/null
+++ b/dom/public/idl/smil/Makefile.in
@@ -0,0 +1,53 @@
+#!nmake
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla SMIL module.
+#
+# The Initial Developer of the Original Code is Brian Birtles.
+# Portions created by the Initial Developer are Copyright (C) 2005
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+# 	Brian Birtles <birtles@gmail.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= dom
+XPIDL_MODULE	= dom_smil
+
+XPIDLSRCS	= \
+		nsIDOMElementTimeControl.idl \
+		$(NULL)
+
+include $(topsrcdir)/config/rules.mk
diff --git a/dom/public/idl/smil/nsIDOMElementTimeControl.idl b/dom/public/idl/smil/nsIDOMElementTimeControl.idl
new file mode 100644
--- /dev/null
+++ b/dom/public/idl/smil/nsIDOMElementTimeControl.idl
@@ -0,0 +1,58 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMSVGElement.idl"
+
+/*
+ * The definitions of this interface in SMIL Animation and SVG 1.1 differ in the
+ * return type and semantics. Returning a boolean shouldn't present a problem
+ * for anyone expecting the method to have a void return type so we use the SVG
+ * definition of the interface here (boolean return types).
+ */
+
+[scriptable, uuid(276a6678-7844-4d5e-8dfe-938c46089b84)]
+interface nsIDOMElementTimeControl : nsISupports
+{ 
+  boolean beginElement ( );
+          // raises (nsIDOMDOMException)
+  boolean beginElementAt ( in float offset );
+          // raises (nsIDOMDOMException)
+  boolean endElement ( );
+          // raises (nsIDOMDOMException)
+  boolean endElementAt ( in float offset );
+          // raises (nsIDOMDOMException)
+};
diff --git a/dom/public/idl/svg/Makefile.in b/dom/public/idl/svg/Makefile.in
--- a/dom/public/idl/svg/Makefile.in
+++ b/dom/public/idl/svg/Makefile.in
@@ -16,16 +16,17 @@
 # The Original Code is Crocodile Clips Ltd code.
 #
 # The Initial Developer of the Original Code is
 # Crocodile Clips Ltd.
 # Portions created by the Initial Developer are Copyright (C) 2001
 # the Initial Developer. All Rights Reserved.
 #
 # Contributor(s):
+#   Chris Double  <chris.double@double.co.nz>
 #
 # Alternatively, the contents of this file may be used under the terms of
 # either of the GNU General Public License Version 2 or later (the "GPL"),
 # or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 # in which case the provisions of the GPL or the LGPL are applicable instead
 # of those above. If you wish to allow use of your version of this file only
 # under the terms of either the GPL or the LGPL, and not to allow others to
 # use your version of this file under the terms of the MPL, indicate your
@@ -122,9 +123,18 @@ XPIDLSRCS	= \
 		nsIDOMSVGURIReference.idl \
 		nsIDOMSVGUnitTypes.idl \
 		nsIDOMSVGUseElement.idl \
 		nsIDOMSVGViewSpec.idl \
 		nsIDOMSVGZoomAndPan.idl \
 		nsIDOMSVGZoomEvent.idl \
 		$(NULL)
 
+ifdef MOZ_SMIL
+XPIDLSRCS	+= \
+		nsIDOMSVGAnimateElement.idl \
+		nsIDOMSVGAnimateTransformElement.idl \
+		nsIDOMSVGAnimationElement.idl \
+		nsIDOMSVGSetElement.idl \
+		$(NULL)
+endif
+
 include $(topsrcdir)/config/rules.mk
diff --git a/dom/public/idl/svg/nsIDOMSVGAnimateElement.idl b/dom/public/idl/svg/nsIDOMSVGAnimateElement.idl
new file mode 100644
--- /dev/null
+++ b/dom/public/idl/svg/nsIDOMSVGAnimateElement.idl
@@ -0,0 +1,41 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMSVGAnimationElement.idl"
+
+[scriptable, uuid(0c4297e8-68d0-471d-a933-64132ccc5b97)]
+interface nsIDOMSVGAnimateElement : nsIDOMSVGAnimationElement {};
diff --git a/dom/public/idl/svg/nsIDOMSVGAnimateTransformElement.idl b/dom/public/idl/svg/nsIDOMSVGAnimateTransformElement.idl
new file mode 100644
--- /dev/null
+++ b/dom/public/idl/svg/nsIDOMSVGAnimateTransformElement.idl
@@ -0,0 +1,41 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMSVGAnimationElement.idl"
+
+[scriptable, uuid(735e0f75-c6aa-4aee-bcd2-46426d6ac90c)]
+interface nsIDOMSVGAnimateTransformElement : nsIDOMSVGAnimationElement {};
diff --git a/dom/public/idl/svg/nsIDOMSVGAnimationElement.idl b/dom/public/idl/svg/nsIDOMSVGAnimationElement.idl
new file mode 100644
--- /dev/null
+++ b/dom/public/idl/svg/nsIDOMSVGAnimationElement.idl
@@ -0,0 +1,62 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMSVGElement.idl"
+
+[scriptable, uuid(8f2ccf31-5544-4a9d-8927-ef35d242039e)]
+interface nsIDOMSVGAnimationElement
+  : nsIDOMSVGElement
+/*
+        The SVG DOM makes use of multiple interface inheritance.
+        Since XPCOM only supports single interface inheritance,
+        the best thing that we can do is to promise that whenever
+        an object implements _this_ interface it will also
+        implement the following interfaces. (We then have to QI to
+        hop between them.)
+        
+    nsIDOMSVGTests,
+    nsIDOMSVGExternalResourcesRequired,
+    smil::nsIDOMElementTimeControl,
+    events::nsIDOMEventTarget
+*/
+{ 
+  readonly attribute nsIDOMSVGElement targetElement;
+  float getStartTime ( );
+  float getCurrentTime ( );
+  float getSimpleDuration ( );
+          // raises (nsIDOMDOMException)
+};
diff --git a/dom/public/idl/svg/nsIDOMSVGSetElement.idl b/dom/public/idl/svg/nsIDOMSVGSetElement.idl
new file mode 100644
--- /dev/null
+++ b/dom/public/idl/svg/nsIDOMSVGSetElement.idl
@@ -0,0 +1,41 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Chris Double <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMSVGAnimationElement.idl"
+
+[scriptable, uuid(b6c27cdc-4d8b-4343-8ccb-3b68adb1052a)]
+interface nsIDOMSVGSetElement : nsIDOMSVGAnimationElement {};
diff --git a/dom/public/nsDOMClassInfoID.h b/dom/public/nsDOMClassInfoID.h
--- a/dom/public/nsDOMClassInfoID.h
+++ b/dom/public/nsDOMClassInfoID.h
@@ -238,16 +238,21 @@ enum nsDOMClassInfoID {
   eDOMClassInfo_BeforeUnloadEvent_id,
 
 #ifdef MOZ_SVG
   // The SVG document
   eDOMClassInfo_SVGDocument_id,
 
   // SVG element classes
   eDOMClassInfo_SVGAElement_id,
+#ifdef MOZ_SMIL
+  eDOMClassInfo_SVGAnimateElement_id,
+  eDOMClassInfo_SVGAnimateTransformElement_id,
+  eDOMClassInfo_SVGSetElement_id,
+#endif // MOZ_SMIL
   eDOMClassInfo_SVGCircleElement_id,
   eDOMClassInfo_SVGClipPathElement_id,
   eDOMClassInfo_SVGDefsElement_id,
   eDOMClassInfo_SVGDescElement_id,
   eDOMClassInfo_SVGEllipseElement_id,
   eDOMClassInfo_SVGFEBlendElement_id,
   eDOMClassInfo_SVGFEColorMatrixElement_id,
   eDOMClassInfo_SVGFEComponentTransferElement_id,
diff --git a/dom/src/base/nsDOMClassInfo.cpp b/dom/src/base/nsDOMClassInfo.cpp
--- a/dom/src/base/nsDOMClassInfo.cpp
+++ b/dom/src/base/nsDOMClassInfo.cpp
@@ -371,16 +371,23 @@
 #include "nsIDOMSVGAnimatedLengthList.h"
 #include "nsIDOMSVGAnimatedNumber.h"
 #include "nsIDOMSVGAnimatedNumberList.h"
 #include "nsIDOMSVGAnimatedPathData.h"
 #include "nsIDOMSVGAnimatedPoints.h"
 #include "nsIDOMSVGAnimPresAspRatio.h"
 #include "nsIDOMSVGAnimatedRect.h"
 #include "nsIDOMSVGAnimatedString.h"
+#ifdef MOZ_SMIL
+#include "nsIDOMSVGAnimateElement.h"
+#include "nsIDOMSVGAnimateTransformElement.h"
+#include "nsIDOMSVGSetElement.h"
+#include "nsIDOMSVGAnimationElement.h"
+#include "nsIDOMElementTimeControl.h"
+#endif // MOZ_SMIL
 #include "nsIDOMSVGAnimTransformList.h"
 #include "nsIDOMSVGCircleElement.h"
 #include "nsIDOMSVGClipPathElement.h"
 #include "nsIDOMSVGDefsElement.h"
 #include "nsIDOMSVGDescElement.h"
 #include "nsIDOMSVGDocument.h"
 #include "nsIDOMSVGElement.h"
 #include "nsIDOMSVGEllipseElement.h"
@@ -934,16 +941,24 @@ static nsDOMClassInfoData sClassInfoData
 #ifdef MOZ_SVG
   // SVG document
   NS_DEFINE_CLASSINFO_DATA(SVGDocument, nsDocumentSH,
                            DOCUMENT_SCRIPTABLE_FLAGS)
 
   // SVG element classes
   NS_DEFINE_CLASSINFO_DATA(SVGAElement, nsElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
+#ifdef MOZ_SMIL
+  NS_DEFINE_CLASSINFO_DATA(SVGAnimateElement, nsElementSH,
+                           ELEMENT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(SVGAnimateTransformElement, nsElementSH,
+                           ELEMENT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(SVGSetElement, nsElementSH,
+                           ELEMENT_SCRIPTABLE_FLAGS)
+#endif // MOZ_SMIL
   NS_DEFINE_CLASSINFO_DATA(SVGCircleElement, nsElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(SVGClipPathElement, nsElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(SVGDefsElement, nsElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(SVGDescElement, nsElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
@@ -2757,16 +2772,41 @@ nsDOMClassInfo::Init()
 
   // SVG element classes
 
   DOM_CLASSINFO_MAP_BEGIN(SVGAElement, nsIDOMSVGAElement)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGAElement)
     DOM_CLASSINFO_SVG_GRAPHIC_ELEMENT_MAP_ENTRIES
   DOM_CLASSINFO_MAP_END
 
+#ifdef MOZ_SMIL
+  DOM_CLASSINFO_MAP_BEGIN(SVGAnimateElement, nsIDOMSVGAnimateElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGAnimationElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGAnimateElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMElementTimeControl)
+    DOM_CLASSINFO_SVG_ELEMENT_MAP_ENTRIES
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(SVGAnimateTransformElement,
+                          nsIDOMSVGAnimateTransformElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGAnimationElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGAnimateTransformElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMElementTimeControl)
+    DOM_CLASSINFO_SVG_ELEMENT_MAP_ENTRIES
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(SVGSetElement,
+                          nsIDOMSVGSetElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGAnimationElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGSetElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMElementTimeControl)
+    DOM_CLASSINFO_SVG_ELEMENT_MAP_ENTRIES
+  DOM_CLASSINFO_MAP_END
+#endif // MOZ_SMIL
+
   DOM_CLASSINFO_MAP_BEGIN(SVGCircleElement, nsIDOMSVGCircleElement)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGCircleElement)
     DOM_CLASSINFO_SVG_GRAPHIC_ELEMENT_MAP_ENTRIES
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(SVGClipPathElement, nsIDOMSVGClipPathElement)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGClipPathElement)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGLocatable)
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -83,16 +83,20 @@
 #include "nsStyleChangeList.h"
 #include "nsRuleNode.h"
 #include "nsEventDispatcher.h"
 #include "gfxUserFontSet.h"
 #include "gfxPlatform.h"
 #include "nsCSSRules.h"
 #include "nsFontFaceLoader.h"
 #include "nsIEventListenerManager.h"
+
+#ifdef MOZ_SMIL
+#include "nsSMILAnimationController.h"
+#endif // MOZ_SMIL
 
 #ifdef IBMBIDI
 #include "nsBidiPresUtils.h"
 #endif // IBMBIDI
 
 #include "nsContentUtils.h"
 
 // Needed for Start/Stop of Image Animation
@@ -1086,16 +1090,34 @@ nsPresContext::SetImageAnimationModeInte
     if (doc) {
       nsIContent *rootContent = doc->GetRootContent();
       if (rootContent) {
         SetImgAnimations(rootContent, aMode);
       }
     }
   }
 
+  #ifdef MOZ_SMIL
+  if (mAnimationController) {
+    switch (aMode)
+    {
+      case imgIContainer::kNormalAnimMode:
+      case imgIContainer::kLoopOnceAnimMode:
+        if (mImageAnimationMode == imgIContainer::kDontAnimMode)
+          mAnimationController->Resume();
+        break;
+
+      case imgIContainer::kDontAnimMode:
+        if (mImageAnimationMode != imgIContainer::kDontAnimMode)
+          mAnimationController->Pause();
+        break;
+    }
+  }
+  #endif // MOZ_SMIL
+
   mImageAnimationMode = aMode;
 }
 
 void
 nsPresContext::SetImageAnimationModeExternal(PRUint16 aMode)
 {
   SetImageAnimationModeInternal(aMode);
 }
@@ -1532,16 +1554,33 @@ nsPresContext::EnsureVisible(PRBool aUns
         }
         return PR_TRUE;
       }
     }
   }
   return PR_FALSE;
 }
 
+#ifdef MOZ_SMIL
+void
+nsPresContext::SetAnimationController(nsSMILAnimationController* aController)
+{
+  // XXXdholbert is this ADDREF'ing / RELEASing nececessary?
+  // Probably not, if I make mController a nsRefPtr
+  NS_IF_ADDREF(aController);
+  nsSMILAnimationController* temp = mAnimationController;
+  mAnimationController = aController;
+  if (mAnimationController && 
+      mImageAnimationMode == imgIContainer::kDontAnimMode) {
+    mAnimationController->Pause();
+  }
+  NS_IF_RELEASE(temp);
+}
+#endif // MOZ_SMIL
+
 #ifdef MOZ_REFLOW_PERF
 void
 nsPresContext::CountReflows(const char * aName, nsIFrame * aFrame)
 {
   if (mShell) {
     mShell->CountReflows(aName, aFrame);
   }
 }
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -81,26 +81,31 @@ class nsIContent;
 class nsIContent;
 class nsIFontMetrics;
 class nsIFrame;
 class nsFrameManager;
 class nsIImage;
 class nsILinkHandler;
 class nsStyleContext;
 class nsIAtom;
+class nsIAnimationController;
 class nsIEventStateManager;
 class nsIURI;
 class nsILookAndFeel;
 class nsICSSPseudoComparator;
 class nsIAtom;
 struct nsStyleBackground;
 template <class T> class nsRunnableMethod;
 class nsIRunnable;
 class gfxUserFontSet;
 struct nsFontFaceRuleContainer;
+
+#ifdef MOZ_SMIL
+class nsSMILAnimationController;
+#endif // MOZ_SMIL
 
 #ifdef MOZ_REFLOW_PERF
 class nsIRenderingContext;
 #endif
 
 enum nsWidgetType {
   eWidgetType_Button  	= 1,
   eWidgetType_Checkbox	= 2,
@@ -743,16 +748,23 @@ public:
                               mType == eContext_PrintPreview); }
 
   // Is this presentation in a chrome docshell?
   PRBool IsChrome() const;
 
   // Public API for native theme code to get style internals.
   virtual PRBool HasAuthorSpecifiedRules(nsIFrame *aFrame, PRUint32 ruleTypeMask) const;
 
+  nsSMILAnimationController* GetAnimationController()
+  {
+    return mAnimationController;
+  }
+
+  void SetAnimationController(nsSMILAnimationController* aController);
+
   // Is it OK to let the page specify colors and backgrounds?
   PRBool UseDocumentColors() const {
     return GetCachedBoolPref(kPresContext_UseDocumentColors) || IsChrome();
   }
 
   PRBool           SupressingResizeReflow() const { return mSupressResizeReflow; }
   
   virtual NS_HIDDEN_(gfxUserFontSet*) GetUserFontSetExternal();
@@ -826,16 +838,22 @@ protected:
   float                 mFullZoom;      // Page zoom, defaults to 1.0
 
   PRInt32               mCurAppUnitsPerDevPixel;
   PRInt32               mAutoQualityMinFontSizePixelsPref;
 
 #ifdef IBMBIDI
   nsBidiPresUtils*      mBidiUtils;
 #endif
+
+#ifdef MOZ_SMIL
+  // XXXdholbert -- this can't be a nsAutoPtr, because it's an
+  // nsIDOMEventListener, and it gets addref'd / released as such.
+  nsSMILAnimationController *mAnimationController; // [STRONG]
+#endif // MOZ_SMIL
 
   nsCOMPtr<nsITheme> mTheme;
   nsCOMPtr<nsILanguageAtomService> mLangService;
   nsCOMPtr<nsIPrintSettings> mPrintSettings;
   nsCOMPtr<nsITimer>    mPrefChangedTimer;
 
   nsPropertyTable       mPropertyTable;
 
diff --git a/layout/build/Makefile.in b/layout/build/Makefile.in
--- a/layout/build/Makefile.in
+++ b/layout/build/Makefile.in
@@ -209,16 +209,22 @@ ifdef MOZ_SVG
 ifdef MOZ_SVG
 SHARED_LIBRARY_LIBS += \
 		../svg/base/src/$(LIB_PREFIX)gksvgbase_s.$(LIB_SUFFIX) \
 		$(DEPTH)/content/svg/document/src/$(LIB_PREFIX)gkconsvgdoc_s.$(LIB_SUFFIX) \
 		$(DEPTH)/content/svg/content/src/$(LIB_PREFIX)gkcontentsvg_s.$(LIB_SUFFIX) \
 		$(NULL)
 endif
 
+ifdef MOZ_SMIL
+SHARED_LIBRARY_LIBS += \
+		$(DEPTH)/content/smil/src/$(LIB_PREFIX)gkconsmil_s.$(LIB_SUFFIX) \
+		$(NULL)
+endif
+
 ifdef MOZ_PLAINTEXT_EDITOR_ONLY
 DEFINES += -DMOZILLA_PLAINTEXT_EDITOR_ONLY
 else
 SHARED_LIBRARY_LIBS += \
 	$(DEPTH)/editor/libeditor/html/$(LIB_PREFIX)htmleditor_s.$(LIB_SUFFIX) \
 	$(DEPTH)/editor/txtsvc/src/$(LIB_PREFIX)txtsvc_s.$(LIB_SUFFIX) \
 	$(NULL)
 endif
diff --git a/layout/reftests/svg/reftest.list b/layout/reftests/svg/reftest.list
--- a/layout/reftests/svg/reftest.list
+++ b/layout/reftests/svg/reftest.list
@@ -1,16 +1,19 @@
 
 # bugs/
 include bugs/reftest.list
 
 # sizing tests
 include sizing/reftest.list
 
 include filters/reftest.list
+
+# smil / animation tests
+include smil/reftest.list
 
 # Mozilla only tests (i.e. those containing XUL/XBL/etc.)
 include moz-only/reftest.list
 
 == clipPath-basic-01.svg pass.svg
 == clip-surface-clone-01.svg clip-surface-clone-01-ref.svg
 == conditions-01.svg pass.svg
 == currentColor-01.svg pass.svg
diff --git a/layout/reftests/svg/smil/anim-discrete-replace-sum-1.svg b/layout/reftests/svg/smil/anim-discrete-replace-sum-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-discrete-replace-sum-1.svg
@@ -0,0 +1,12 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="20" fill="blue">
+    <animate attributeName="height" calcMode="discrete" 
+             additive="replace" accumulate="sum"
+             from="20" to="100" repeatCount="2" 
+             begin="0s" dur="1s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-discrete-sum-none-1.svg b/layout/reftests/svg/smil/anim-discrete-sum-none-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-discrete-sum-none-1.svg
@@ -0,0 +1,12 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="20" fill="blue">
+    <animate attributeName="height" calcMode="discrete"
+             additive="sum" accumulate="none" 
+             from="20" to="180"
+             begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-discrete-sum-sum-1.svg b/layout/reftests/svg/smil/anim-discrete-sum-sum-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-discrete-sum-sum-1.svg
@@ -0,0 +1,12 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="20" fill="blue">
+    <animate attributeName="height" calcMode="discrete"
+             additive="sum" accumulate="sum"
+             from="20" to="90" repeatCount="2" 
+             begin="0s" dur="1s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-discrete-values-1.svg b/layout/reftests/svg/smil/anim-discrete-values-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-discrete-values-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height" calcMode="discrete" 
+             values="100; 200; 50" begin="0s" dur="5s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-fillcolor-1.svg b/layout/reftests/svg/smil/anim-fillcolor-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-fillcolor-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="200" fill="rgb(255,0,0)">
+    <animateColor attributeName="fill" from="rgb(255,0,0)" to="rgb(0,0,255)"
+                  begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-fillopacity-1.svg b/layout/reftests/svg/smil/anim-fillopacity-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-fillopacity-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="200" fill="blue" fill-opacity="0">
+    <animate attributeName="fill-opacity"
+             from="0" to="1" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-done-1a.svg b/layout/reftests/svg/smil/anim-height-done-1a.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-done-1a.svg
@@ -0,0 +1,11 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="50" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
+
diff --git a/layout/reftests/svg/smil/anim-height-done-1b.svg b/layout/reftests/svg/smil/anim-height-done-1b.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-done-1b.svg
@@ -0,0 +1,11 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="50" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
+
diff --git a/layout/reftests/svg/smil/anim-height-interp-1-ref.svg b/layout/reftests/svg/smil/anim-height-interp-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-1-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="15" width="200" height="115" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-1.svg b/layout/reftests/svg/smil/anim-height-interp-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(0.3, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-2-ref.svg b/layout/reftests/svg/smil/anim-height-interp-2-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-2-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="15" width="200" height="125" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-2.svg b/layout/reftests/svg/smil/anim-height-interp-2.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-2.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(0.5, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-3-ref.svg b/layout/reftests/svg/smil/anim-height-interp-3-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-3-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="15" width="200" height="160" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-3.svg b/layout/reftests/svg/smil/anim-height-interp-3.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-3.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.2, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-4-ref.svg b/layout/reftests/svg/smil/anim-height-interp-4-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-4-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="15" width="200" height="170" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-4.svg b/layout/reftests/svg/smil/anim-height-interp-4.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-4.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.4, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-5-ref.svg b/layout/reftests/svg/smil/anim-height-interp-5-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-5-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="15" width="200" height="190" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-5.svg b/layout/reftests/svg/smil/anim-height-interp-5.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-5.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.8, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-6-ref.svg b/layout/reftests/svg/smil/anim-height-interp-6-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-6-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="15" width="200" height="195" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-6.svg b/layout/reftests/svg/smil/anim-height-interp-6.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-6.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.9, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-ref-text.svg b/layout/reftests/svg/smil/anim-ref-text.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-ref-text.svg
@@ -0,0 +1,5 @@
+<svg xmlns="http://www.w3.org/2000/svg" onload="var svg=document.documentElement;svg.pauseAnimations();svg.setCurrentTime(2.5)">
+
+<text x="20" y="100" font-size="25" fill="lime">Some Long Text Here</text>
+
+</svg>
diff --git a/layout/reftests/svg/smil/anim-standard-ref.svg b/layout/reftests/svg/smil/anim-standard-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-standard-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="15" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-strokecolor-1.svg b/layout/reftests/svg/smil/anim-strokecolor-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-strokecolor-1.svg
@@ -0,0 +1,12 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="20" y="20" width="190" height="190" 
+        fill="rgb(0,0,255)" stroke="rgb(255,0,0)" stroke-width="10">
+    <animateColor attributeName="stroke" 
+                  from="rgb(255,0,0)" to="rgb(0,0,255)"
+                  begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-strokewidth-1.svg b/layout/reftests/svg/smil/anim-strokewidth-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-strokewidth-1.svg
@@ -0,0 +1,11 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="200" 
+        fill="blue" stroke="red" stroke-width="10">
+    <animate attributeName="stroke-width"
+             from="10" to="0" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-targethref-1.svg b/layout/reftests/svg/smil/anim-targethref-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-targethref-1.svg
@@ -0,0 +1,9 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect id="theRect" x="15" y="15" width="200" height="50" fill="blue" />
+  <animate xlink:href="#theRect" attributeName="height" 
+           from="50" to="200" begin="0s" dur="2s" fill="freeze"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-width-done-1a.svg b/layout/reftests/svg/smil/anim-width-done-1a.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-width-done-1a.svg
@@ -0,0 +1,11 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="50" height="200" fill="blue">
+    <animate attributeName="width" 
+             from="50" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
+
diff --git a/layout/reftests/svg/smil/anim-width-done-1b.svg b/layout/reftests/svg/smil/anim-width-done-1b.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-width-done-1b.svg
@@ -0,0 +1,11 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="50" height="200" fill="blue">
+    <animate attributeName="width"
+             from="50" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
+
diff --git a/layout/reftests/svg/smil/anim-x-done-1a.svg b/layout/reftests/svg/smil/anim-x-done-1a.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-done-1a.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x"
+             from="200" to="15" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-done-1b.svg b/layout/reftests/svg/smil/anim-x-done-1b.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-done-1b.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x" 
+             from="200" to="15" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-1-ref.svg b/layout/reftests/svg/smil/anim-x-interp-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-1-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="115" y="15" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-1.svg b/layout/reftests/svg/smil/anim-x-interp-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(0.3, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-2-ref.svg b/layout/reftests/svg/smil/anim-x-interp-2-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-2-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="125" y="15" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-2.svg b/layout/reftests/svg/smil/anim-x-interp-2.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-2.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(0.5, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-3-ref.svg b/layout/reftests/svg/smil/anim-x-interp-3-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-3-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="160" y="15" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-3.svg b/layout/reftests/svg/smil/anim-x-interp-3.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-3.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.2, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-4-ref.svg b/layout/reftests/svg/smil/anim-x-interp-4-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-4-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="170" y="15" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-4.svg b/layout/reftests/svg/smil/anim-x-interp-4.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-4.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.4, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-5-ref.svg b/layout/reftests/svg/smil/anim-x-interp-5-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-5-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="190" y="15" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-5.svg b/layout/reftests/svg/smil/anim-x-interp-5.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-5.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.8, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-6-ref.svg b/layout/reftests/svg/smil/anim-x-interp-6-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-6-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="195" y="15" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-6.svg b/layout/reftests/svg/smil/anim-x-interp-6.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-6.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.9, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-done-1a.svg b/layout/reftests/svg/smil/anim-y-done-1a.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-done-1a.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="200" to="15" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-done-1b.svg b/layout/reftests/svg/smil/anim-y-done-1b.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-done-1b.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="200" to="15" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-1-ref.svg b/layout/reftests/svg/smil/anim-y-interp-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-1-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="115" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-1.svg b/layout/reftests/svg/smil/anim-y-interp-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(0.3, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-2-ref.svg b/layout/reftests/svg/smil/anim-y-interp-2-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-2-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="125" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-2.svg b/layout/reftests/svg/smil/anim-y-interp-2.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-2.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(0.5, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-3-ref.svg b/layout/reftests/svg/smil/anim-y-interp-3-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-3-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="160" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-3.svg b/layout/reftests/svg/smil/anim-y-interp-3.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-3.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.2, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-4-ref.svg b/layout/reftests/svg/smil/anim-y-interp-4-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-4-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="170" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-4.svg b/layout/reftests/svg/smil/anim-y-interp-4.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-4.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.4, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-5-ref.svg b/layout/reftests/svg/smil/anim-y-interp-5-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-5-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="190" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-5.svg b/layout/reftests/svg/smil/anim-y-interp-5.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-5.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.8, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-6-ref.svg b/layout/reftests/svg/smil/anim-y-interp-6-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-6-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="195" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-6.svg b/layout/reftests/svg/smil/anim-y-interp-6.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-6.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.9, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/api-sanity-1-ref.svg b/layout/reftests/svg/smil/api-sanity-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/api-sanity-1-ref.svg
@@ -0,0 +1,6 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect id="rect" width="100px" height="100px"
+        fill="lime"/>
+</svg>
diff --git a/layout/reftests/svg/smil/api-sanity-1.svg b/layout/reftests/svg/smil/api-sanity-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/api-sanity-1.svg
@@ -0,0 +1,34 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="go()"
+     class="reftest-wait"
+>
+  <script type="application/javascript">
+    function go(evt) {
+      // Try calling the animation-related methods in nsSVGSVGElement.cpp
+      // If any aren't implemented, we'll throw an exception and
+      // the rect will stay red.
+
+      // Note: I'm catching the exception because (I think) we need to
+      // make sure to remove the "reftest-wait" document-class
+      try {
+        document.documentElement.animationsPaused();
+        document.documentElement.pauseAnimations();
+        document.documentElement.unpauseAnimations();
+        document.documentElement.getCurrentTime();
+        document.documentElement.setCurrentTime(0);
+      } catch (e) {
+        document.documentElement.removeAttribute("class");
+        throw e;
+      }
+
+      // If we get here, we're successful!
+      // Change the rect color.
+      var rect = document.getElementById("rect");
+      rect.setAttributeNS(null, "fill", "lime");
+      document.documentElement.removeAttribute("class");
+    }
+  </script>
+  <rect id="rect" width="100px" height="100px"
+        fill="red"/>
+</svg>
diff --git a/layout/reftests/svg/smil/reftest.list b/layout/reftests/svg/smil/reftest.list
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/reftest.list
@@ -0,0 +1,64 @@
+# Tests related to SVG Animation (using SMIL)
+# XXXdholbert Partial list of features that still need reftests:
+#   - calcMode=discrete, paced, spline
+#   - Stacking of additive=[sum|replace] animations
+#   - Stacking of additive animations, w/ "hybrid case of to-animation"
+#   - Repeating animations, w/ & w/out accumulate=sum
+#   - <animateTransform>
+#   - <set>
+#   - DOM interfaces (Section 6.2 of http://www.w3.org/TR/smil-animation/ )
+
+# animation sort-order tests
+include sort/reftest.list
+
+# style tests
+include style/reftest.list
+
+# time-dependent tests
+# XXXdholbert Disabling this class of tests for now, because most of them
+# can & should be converted so they don't depend on specific timeout values.
+# (to prevent sporadic failures due to nondeterminism)
+# include timed/reftest.list
+
+# General tests
+== anim-discrete-values-1.svg      anim-standard-ref.svg
+== anim-discrete-replace-sum-1.svg anim-standard-ref.svg
+== anim-discrete-sum-none-1.svg    anim-standard-ref.svg
+== anim-discrete-sum-sum-1.svg     anim-standard-ref.svg
+
+fails == anim-fillcolor-1.svg      anim-standard-ref.svg # color support
+fails == anim-fillopacity-1.svg anim-standard-ref.svg    # non-length-numeric values support
+
+== anim-height-done-1a.svg anim-standard-ref.svg
+== anim-height-done-1b.svg anim-standard-ref.svg
+== anim-height-interp-1.svg anim-height-interp-1-ref.svg
+== anim-height-interp-2.svg anim-height-interp-2-ref.svg
+== anim-height-interp-3.svg anim-height-interp-3-ref.svg
+== anim-height-interp-4.svg anim-height-interp-4-ref.svg
+== anim-height-interp-5.svg anim-height-interp-5-ref.svg
+== anim-height-interp-6.svg anim-height-interp-6-ref.svg
+
+fails == anim-strokecolor-1.svg anim-standard-ref.svg # color support
+fails == anim-strokewidth-1.svg anim-standard-ref.svg # color support
+fails == anim-targethref-1.svg anim-standard-ref.svg  # href support
+
+== anim-width-done-1a.svg anim-standard-ref.svg
+== anim-width-done-1b.svg anim-standard-ref.svg
+
+== anim-x-done-1a.svg anim-standard-ref.svg
+== anim-x-done-1b.svg anim-standard-ref.svg
+== anim-x-interp-1.svg anim-x-interp-1-ref.svg
+== anim-x-interp-2.svg anim-x-interp-2-ref.svg
+== anim-x-interp-3.svg anim-x-interp-3-ref.svg
+== anim-x-interp-4.svg anim-x-interp-4-ref.svg
+== anim-x-interp-5.svg anim-x-interp-5-ref.svg
+== anim-x-interp-6.svg anim-x-interp-6-ref.svg
+
+== anim-y-done-1a.svg anim-standard-ref.svg
+== anim-y-done-1b.svg anim-standard-ref.svg
+== anim-y-interp-1.svg anim-y-interp-1-ref.svg
+== anim-y-interp-2.svg anim-y-interp-2-ref.svg
+== anim-y-interp-3.svg anim-y-interp-3-ref.svg
+== anim-y-interp-4.svg anim-y-interp-4-ref.svg
+== anim-y-interp-5.svg anim-y-interp-5-ref.svg
+== anim-y-interp-6.svg anim-y-interp-6-ref.svg
diff --git a/layout/reftests/svg/smil/smil-util.js b/layout/reftests/svg/smil/smil-util.js
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/smil-util.js
@@ -0,0 +1,11 @@
+// Seeks to the given time and then removes the SVG document's class to trigger
+// a reftest snapshot. If pauseFlag is true, animations will be paused.
+function setTimeAndSnapshot(timeInSeconds, pauseFlag) {
+  var svg = document.documentElement;
+  if (pauseFlag) {
+    svg.pauseAnimations();
+  }
+  svg.setCurrentTime(timeInSeconds);
+  // Use setTimeout to allow SMIL to update the animation before snapshot
+  setTimeout('document.documentElement.removeAttribute("class")', 0);
+}
diff --git a/layout/reftests/svg/smil/sort/reftest.list b/layout/reftests/svg/smil/sort/reftest.list
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/reftest.list
@@ -0,0 +1,9 @@
+# Tests related to SVG Animation (using SMIL), focusing on animation-sorting
+# to see which animation takes precedence (out of multiple animations on the
+# same attribute
+
+== sort-startAfter-1.svg sort-startAfter-1-ref.svg
+== sort-startAfter-2.svg sort-startAfter-2-ref.svg
+== sort-startAfter-3.svg sort-startAfter-3-ref.svg
+== sort-startSame-1.svg  sort-startSame-1-ref.svg
+== sort-startSame-2.svg  sort-startSame-2-ref.svg
diff --git a/layout/reftests/svg/smil/sort/sort-startAfter-1-ref.svg b/layout/reftests/svg/smil/sort/sort-startAfter-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startAfter-1-ref.svg
@@ -0,0 +1,4 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="125" y="0"   width="100" height="100" fill="blue"/>
+  <rect x="125" y="200" width="100" height="100" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startAfter-1.svg b/layout/reftests/svg/smil/sort/sort-startAfter-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startAfter-1.svg
@@ -0,0 +1,16 @@
+<!-- If two conflicting animations start at diffent times, the one starting 
+     later should win. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.0, true)">
+  <script xlink:href="../smil-util.js" type="text/javascript"/>
+  <rect x="0" y="0" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="100" to="200" begin="0.5s" dur="2s"/>
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="2s"/>
+  </rect>
+  <rect x="0" y="200" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="2s"/>
+    <animate attributeName="x" from="100" to="200" begin="0.5s" dur="2s"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startAfter-2-ref.svg b/layout/reftests/svg/smil/sort/sort-startAfter-2-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startAfter-2-ref.svg
@@ -0,0 +1,4 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="150" y="0"   width="100" height="100" fill="blue"/>
+  <rect x="150" y="200" width="100" height="100" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startAfter-2.svg b/layout/reftests/svg/smil/sort/sort-startAfter-2.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startAfter-2.svg
@@ -0,0 +1,18 @@
+<!-- If two conflicting animations start at diffent times, the one starting 
+     later should win. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.5, true)">
+  <script xlink:href="../smil-util.js" type="text/javascript"/>
+  <rect x="0" y="0" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="100" to="200" begin="0.5s" dur="2s"/>
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="1s"
+             fill="freeze"/>
+  </rect>
+  <rect x="0" y="200" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="1s"
+             fill="freeze"/>
+    <animate attributeName="x" from="100" to="200" begin="0.5s" dur="2s"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startAfter-3-ref.svg b/layout/reftests/svg/smil/sort/sort-startAfter-3-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startAfter-3-ref.svg
@@ -0,0 +1,4 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="200" y="0"   width="100" height="100" fill="blue"/>
+  <rect x="200" y="200" width="100" height="100" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startAfter-3.svg b/layout/reftests/svg/smil/sort/sort-startAfter-3.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startAfter-3.svg
@@ -0,0 +1,18 @@
+<!-- If two conflicting animations start at diffent times, the one starting 
+     later (including its lasting "freeze" effect) should win. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.5, true)">
+  <script xlink:href="../smil-util.js" type="text/javascript"/>
+  <rect x="0" y="0" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="100" to="200" begin="0.25s" dur="1s"
+             fill="freeze"/>
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="2s"/>
+  </rect>
+  <rect x="0" y="200" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="2s"/>
+    <animate attributeName="x" from="100" to="200" begin="0.25s" dur="1s"
+             fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startSame-1-ref.svg b/layout/reftests/svg/smil/sort/sort-startSame-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startSame-1-ref.svg
@@ -0,0 +1,4 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="350" y="0"   width="100" height="100" fill="blue"/>
+  <rect x="150" y="200" width="100" height="100" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startSame-1.svg b/layout/reftests/svg/smil/sort/sort-startSame-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startSame-1.svg
@@ -0,0 +1,16 @@
+<!-- If two conflicting animations start at same time, the one appearing
+     later in the document should win. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.0, true)">
+  <script xlink:href="../smil-util.js" type="text/javascript"/>
+  <rect x="0" y="0" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="100" to="200" begin="0s" dur="2s"/>
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="2s"/>
+  </rect>
+  <rect x="0" y="200" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="2s"/>
+    <animate attributeName="x" from="100" to="200" begin="0s" dur="2s"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startSame-2-ref.svg b/layout/reftests/svg/smil/sort/sort-startSame-2-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startSame-2-ref.svg
@@ -0,0 +1,4 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="400" y="0"   width="100" height="100" fill="blue"/>
+  <rect x="175" y="200" width="100" height="100" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startSame-2.svg b/layout/reftests/svg/smil/sort/sort-startSame-2.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startSame-2.svg
@@ -0,0 +1,18 @@
+<!-- If two conflicting animations start at same time, the one appearing
+     later in the document should win (including its freeze effects). -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.5, true)">
+  <script xlink:href="../smil-util.js" type="text/javascript"/>
+  <rect x="0" y="0" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="100" to="200" begin="0s" dur="2s"/>
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="1s" 
+             fill="freeze"/>
+  </rect>
+  <rect x="0" y="200" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="1s" 
+             fill="freeze"/>
+    <animate attributeName="x" from="100" to="200" begin="0s" dur="2s"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/style/anim-css-fontsize-pt-1-ref.svg b/layout/reftests/svg/smil/style/anim-css-fontsize-pt-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/anim-css-fontsize-pt-1-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <text x="20" y="100" font-size="20pt" fill="blue">Some Long Text Here</text>
+</svg>
diff --git a/layout/reftests/svg/smil/style/anim-css-fontsize-pt-1.svg b/layout/reftests/svg/smil/style/anim-css-fontsize-pt-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/anim-css-fontsize-pt-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="../smil-util.js" type="text/javascript"/>
+  <text x="20" y="100" font-size="50pt" fill="blue">Some Long Text Here
+    <animate attributeName="font-size" attributeType="CSS"
+             from="50pt" to="20pt" begin="0s" dur="2s" fill="freeze"/>
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/style/anim-css-fontsize-px-1-ref.svg b/layout/reftests/svg/smil/style/anim-css-fontsize-px-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/anim-css-fontsize-px-1-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <text x="20" y="100" font-size="25" fill="blue">Some Long Text Here</text>
+</svg>
diff --git a/layout/reftests/svg/smil/style/anim-css-fontsize-px-1a.svg b/layout/reftests/svg/smil/style/anim-css-fontsize-px-1a.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/anim-css-fontsize-px-1a.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="../smil-util.js" type="text/javascript"/>
+  <text x="20" y="100" font-size="50" fill="blue">Some Long Text Here
+    <animate attributeName="font-size" attributeType="CSS"
+             from="50" to="25" begin="0s" dur="2s" fill="freeze"/>
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/style/anim-css-fontsize-px-1b.svg b/layout/reftests/svg/smil/style/anim-css-fontsize-px-1b.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/anim-css-fontsize-px-1b.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="../smil-util.js" type="text/javascript"/>
+  <text x="20" y="100" font-size="50px" fill="blue">Some Long Text Here
+    <animate attributeName="font-size" attributeType="CSS"
+             from="50px" to="25px" begin="0s" dur="2s" fill="freeze"/>
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/style/anim-css-fontsize-px-1c.svg b/layout/reftests/svg/smil/style/anim-css-fontsize-px-1c.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/anim-css-fontsize-px-1c.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="../smil-util.js" type="text/javascript"/>
+  <text x="20" y="100" font-size="50" fill="blue">Some Long Text Here
+    <animate attributeName="font-size" attributeType="CSS"
+             from="50" to="25px" begin="0s" dur="2s" fill="freeze"/>
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/style/fill-1-ref.svg b/layout/reftests/svg/smil/style/fill-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/fill-1-ref.svg
@@ -0,0 +1,8 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <!-- Test interaction of specified CSS style and animated values -->
+  <text y="40" style="fill: green">
+    This text should be green.
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/style/fill-1.svg b/layout/reftests/svg/smil/style/fill-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/fill-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <!-- Test interaction of specified CSS style and animated values -->
+  <text y="40" style="fill: red">
+    This text should be green.
+	<set attributeType="CSS" attributeName="fill" 
+             begin="0s" dur="1s" to="green" fill="freeze"/>
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/style/font-size-1-ref.svg b/layout/reftests/svg/smil/style/font-size-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/font-size-1-ref.svg
@@ -0,0 +1,8 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <!-- Test interaction of specified CSS style and animated values -->
+  <text y="40" style="font-size: 30pt">
+    This text should be large.
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/style/font-size-1.svg b/layout/reftests/svg/smil/style/font-size-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/font-size-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <!-- Test interaction of specified CSS style and animated values -->
+  <text y="40" style="font-size: 8pt">
+    This text should be large.
+	<set attributeType="CSS" attributeName="font-size" 
+             begin="0s" dur="1s" to="30pt" fill="freeze"/>
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/style/reftest.list b/layout/reftests/svg/smil/style/reftest.list
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/reftest.list
@@ -0,0 +1,14 @@
+# Tests related to SVG Animation (using SMIL) of CSS properties
+
+# NOTE: All tests here are currently marked 'fails'.  They'll be enabled
+# as part of a smil-for-CSS-properties patch.
+
+# Tests that are expected to pass with current smil_css draft patch:
+fails == font-size-1.svg  font-size-1-ref.svg  # Note: Opera v9.27 fails this
+fails == anim-css-fontsize-px-1a.svg anim-css-fontsize-px-1-ref.svg
+fails == anim-css-fontsize-px-1b.svg anim-css-fontsize-px-1-ref.svg
+fails == anim-css-fontsize-px-1c.svg anim-css-fontsize-px-1-ref.svg
+fails == anim-css-fontsize-pt-1.svg  anim-css-fontsize-pt-1-ref.svg
+
+# Tests that don't yet pass:
+fails == fill-1.svg       fill-1-ref.svg
diff --git a/layout/reftests/svg/smil/timed/appendChild-1a-ref.svg b/layout/reftests/svg/smil/timed/appendChild-1a-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-1a-ref.svg
@@ -0,0 +1,8 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+  </rect>
+  <rect id="rect2" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/appendChild-1a.svg b/layout/reftests/svg/smil/timed/appendChild-1a.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-1a.svg
@@ -0,0 +1,27 @@
+<!-- This test's animation sets x=100 from 1sec to 1.5sec.  We'll
+     remove the animate element at time 1.1sec to capture this, and
+     then wait a little, and make sure the animation is frozen there. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1100);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      var rect1 = document.getElementById("rect1");
+      var rect2 = document.getElementById("rect2");
+      var anim = document.getElementById("anim");
+      rect2.appendChild(anim);
+
+      // Wait >= 1s before taking screenshot, to give animation time to finish
+      setTimeout('document.documentElement.removeAttribute("class")', 1100);
+    }
+  </script>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+    <animate id="anim" attributeName="x" 
+             dur="2s" values="0; 50; 100; 150"
+             calcMode="discrete" />
+  </rect>
+  <rect id="rect2" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/appendChild-1b-ref.svg b/layout/reftests/svg/smil/timed/appendChild-1b-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-1b-ref.svg
@@ -0,0 +1,6 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect id="rect2" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/appendChild-1b.svg b/layout/reftests/svg/smil/timed/appendChild-1b.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-1b.svg
@@ -0,0 +1,26 @@
+<!-- This test makes the first rect white (invisible), so that we can
+     focus just on the second rect. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1100);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      var rect1 = document.getElementById("rect1");
+      var rect2 = document.getElementById("rect2");
+      var anim = document.getElementById("anim");
+      rect2.appendChild(anim);
+
+      // Wait >= 1s before taking screenshot, to give animation time to finish
+      setTimeout('document.documentElement.removeAttribute("class")', 1100);
+    }
+  </script>
+  <rect id="rect1" y="40" width="10" height="10" fill="white">
+    <animate id="anim" attributeName="x" 
+             dur="2s" values="0; 50; 100; 150"
+             calcMode="discrete" />
+  </rect>
+  <rect id="rect2" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/appendChild-2a-ref.svg b/layout/reftests/svg/smil/timed/appendChild-2a-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-2a-ref.svg
@@ -0,0 +1,8 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+  </rect>
+  <rect id="rect2" x="150" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/appendChild-2a.svg b/layout/reftests/svg/smil/timed/appendChild-2a.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-2a.svg
@@ -0,0 +1,27 @@
+<!-- This test's animation sets x=100 from 1sec to 1.5sec.  We'll
+     remove the animate element at time 1.1sec to capture this, and
+     then wait a little, and make sure the animation is frozen there. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1100);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      var rect1 = document.getElementById("rect1");
+      var rect2 = document.getElementById("rect2");
+      var anim = document.getElementById("anim");
+      rect2.appendChild(anim);
+
+      // Wait >= 1s before taking screenshot, to give animation time to finish
+      setTimeout('document.documentElement.removeAttribute("class")', 1100);
+    }
+  </script>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+    <animate id="anim" attributeName="x" 
+             dur="2s" values="0; 50; 100; 150"
+             calcMode="discrete" fill="freeze"/>
+  </rect>
+  <rect id="rect2" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/appendChild-2b-ref.svg b/layout/reftests/svg/smil/timed/appendChild-2b-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-2b-ref.svg
@@ -0,0 +1,6 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect id="rect2" x="150" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/appendChild-2b.svg b/layout/reftests/svg/smil/timed/appendChild-2b.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-2b.svg
@@ -0,0 +1,26 @@
+<!-- This test makes the first rect white (invisible), so that we can
+     focus just on the second rect. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1100);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      var rect1 = document.getElementById("rect1");
+      var rect2 = document.getElementById("rect2");
+      var anim = document.getElementById("anim");
+      rect2.appendChild(anim);
+
+      // Wait >= 1s before taking screenshot, to give animation time to finish
+      setTimeout('document.documentElement.removeAttribute("class")', 1100);
+    }
+  </script>
+  <rect id="rect1" y="40" width="10" height="10" fill="white">
+    <animate id="anim" attributeName="x" 
+             dur="2s" values="0; 50; 100; 150"
+             calcMode="discrete" fill="freeze"/>
+  </rect>
+  <rect id="rect2" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/paced-1-ref.svg b/layout/reftests/svg/smil/timed/paced-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/paced-1-ref.svg
@@ -0,0 +1,5 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect height="90" width="90" fill="green"></rect>   
+</svg>
diff --git a/layout/reftests/svg/smil/timed/paced-1.svg b/layout/reftests/svg/smil/timed/paced-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/paced-1.svg
@@ -0,0 +1,19 @@
+<!-- In paced calcmode, this animation should jump to -990 really fast,
+     despite the many small-jump values before it, leaving the canvas blank. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1000);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      document.documentElement.removeAttribute("class");
+    }
+  </script>
+  <rect height="90" width="90" fill="green"></rect>
+  <rect x="40" y="40" width="10" height="10" fill="red">
+    <animate attributeName="x" 
+             dur="5s" values="40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; -950"
+             calcMode="paced" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/pause-1-ref.svg b/layout/reftests/svg/smil/timed/pause-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/pause-1-ref.svg
@@ -0,0 +1,6 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+   <rect x="100" y="40" width="10" height="10" fill="blue">
+   </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/pause-1.svg b/layout/reftests/svg/smil/timed/pause-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/pause-1.svg
@@ -0,0 +1,35 @@
+<!-- This test's animation sets x=100 from 1sec to 1.5sec.  We'll
+     pause the animation at time 1.1sec to capture this, and then wait
+     a little, and make sure the animation is frozen there.       -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1100);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      // Use try/catch, so that we make sure to remove the reftest-wait 
+      // attribute  even on older browser versions that don't support
+      // pauseAnimations.
+      try {
+        document.documentElement.pauseAnimations();
+      } catch (e) {
+        // pauseAnimations not implemented. Change rect to red, 
+	    // and clear class to fail/end immediately.
+        document.documentElement.removeAttribute("class");
+        var rect = document.getElementById("rect");
+        rect.setAttributeNS(null, "fill", "red");
+        throw e;
+      }
+
+      // Wait > 0.5s before taking screenshot, to give animation time to
+      // jump to next value if the freeze didn't work.
+      setTimeout('document.documentElement.removeAttribute("class")', 600);
+    }
+  </script>
+  <rect y="40" width="10" height="10" fill="blue">
+    <animate id="rect" attributeName="x" 
+             dur="3s" values="0; 50; 100; 150; 200; 250"
+             calcMode="discrete" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/reftest.list b/layout/reftests/svg/smil/timed/reftest.list
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/reftest.list
@@ -0,0 +1,14 @@
+# Tests related to SVG Animation that use timeouts to interrupt, modify, 
+# and examine animations.
+#
+# NOTE: Most of these tests require a few seconds to run.
+# (That's longer than most other reftests)
+
+== paced-1.svg paced-1-ref.svg
+== pause-1.svg pause-1-ref.svg
+fails == removeChild-1.svg removeChild-1-ref.svg # rect needs to reset
+fails == removeChild-2.svg removeChild-2-ref.svg # rect needs to reset
+fails == appendChild-1a.svg appendChild-1a-ref.svg # first rect needs to reset
+== appendChild-1b.svg appendChild-1b-ref.svg
+fails == appendChild-2a.svg appendChild-2a-ref.svg # first rect needs to reset
+== appendChild-2b.svg appendChild-2b-ref.svg
diff --git a/layout/reftests/svg/smil/timed/removeChild-1-ref.svg b/layout/reftests/svg/smil/timed/removeChild-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/removeChild-1-ref.svg
@@ -0,0 +1,6 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/removeChild-1.svg b/layout/reftests/svg/smil/timed/removeChild-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/removeChild-1.svg
@@ -0,0 +1,25 @@
+<!-- This test's animation sets x=100 from 1sec to 1.5sec.  We'll
+     remove the animate element at time 1.1sec, give it a little more 
+     time, and see what happens. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1100);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      var rect1 = document.getElementById("rect1");
+      var anim = document.getElementById("anim");
+      rect1.removeChild(anim);
+
+      // Wait > 0.5s before taking screenshot, to give animation time to
+      // finish, if it's still going
+      setTimeout('document.documentElement.removeAttribute("class")', 700);
+    }
+  </script>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+    <animate id="anim" attributeName="x" 
+             dur="2s" values="0; 50; 100; 150"
+             calcMode="discrete" />
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/removeChild-2-ref.svg b/layout/reftests/svg/smil/timed/removeChild-2-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/removeChild-2-ref.svg
@@ -0,0 +1,6 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/removeChild-2.svg b/layout/reftests/svg/smil/timed/removeChild-2.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/removeChild-2.svg
@@ -0,0 +1,25 @@
+<!-- This test's animation sets x=100 from 1sec to 1.5sec.  We'll
+     remove the animate element at time 1.1sec, give it a little more 
+     time, and see what happens. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1100);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      var rect1 = document.getElementById("rect1");
+      var anim = document.getElementById("anim");
+      rect1.removeChild(anim);
+
+      // Wait > 0.5s before taking screenshot, to give animation time to
+      // finish, if it's still going
+      setTimeout('document.documentElement.removeAttribute("class")', 700);
+    }
+  </script>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+    <animate id="anim" attributeName="x" 
+             dur="2s" values="0; 50; 100; 150"
+             calcMode="discrete" fill="freeze" />
+  </rect>
+</svg>
diff --git a/toolkit/toolkit-makefiles.sh b/toolkit/toolkit-makefiles.sh
--- a/toolkit/toolkit-makefiles.sh
+++ b/toolkit/toolkit-makefiles.sh
@@ -1000,16 +1000,25 @@ if [ "$MOZ_SVG" ]; then
     content/svg/document/src/Makefile
     content/svg/content/Makefile
     content/svg/content/src/Makefile
     dom/public/idl/svg/Makefile
     layout/svg/base/src/Makefile
   "
 fi
 
+# smil
+if [ "$MOZ_SMIL" ]; then
+    MAKEFILES_content="$MAKEFILES_content
+	content/smil/Makefile
+	content/smil/public/Makefile
+	content/smil/src/Makefile
+"
+fi
+
 if [ "$MOZ_XTF" ]; then
   add_makefiles "
     content/xtf/Makefile
     content/xtf/public/Makefile
     content/xtf/src/Makefile
   "
 fi
 
