From: Brian Birtles <birtles@gmail.com>, Tim Rowley <tor@acm.org>, Daniel Holbert <dholbert@mozilla.com>

WIP from attachment 339235 on bug 216462.

diff --git a/browser/installer/unix/packages-static b/browser/installer/unix/packages-static
--- a/browser/installer/unix/packages-static
+++ b/browser/installer/unix/packages-static
@@ -333,16 +333,19 @@ bin/res/charsetData.properties
 bin/res/charsetData.properties
 bin/res/langGroups.properties
 bin/res/language.properties
 bin/res/entityTables/*
 
 ; svg
 bin/res/svg.css
 bin/components/dom_svg.xpt
+#ifdef MOZ_SMIL
+bin/components/dom_smil.xpt
+#endif
 
 ; [Personal Security Manager]
 ;
 bin/libnssckbi.so
 bin/components/pipboot.xpt
 bin/components/pipnss.xpt
 bin/components/pippki.xpt
 bin/libnss3.so
diff --git a/browser/installer/windows/packages-static b/browser/installer/windows/packages-static
--- a/browser/installer/windows/packages-static
+++ b/browser/installer/windows/packages-static
@@ -329,16 +329,19 @@ bin\res\charsetData.properties
 bin\res\charsetData.properties
 bin\res\langGroups.properties
 bin\res\language.properties
 bin\res\entityTables\*
 
 ; svg
 bin\res\svg.css
 bin\components\dom_svg.xpt
+#ifdef MOZ_SMIL
+bin\components\dom_smil.xpt
+#endif
 
 ; [Personal Security Manager]
 ;
 bin\nssckbi.dll
 bin\components\pipboot.xpt
 bin\components\pipnss.xpt
 bin\components\pippki.xpt
 bin\nssutil3.dll
diff --git a/config/autoconf.mk.in b/config/autoconf.mk.in
--- a/config/autoconf.mk.in
+++ b/config/autoconf.mk.in
@@ -225,16 +225,17 @@ MOZ_MATHML = @MOZ_MATHML@
 MOZ_MATHML = @MOZ_MATHML@
 MOZ_PERMISSIONS = @MOZ_PERMISSIONS@
 MOZ_XTF = @MOZ_XTF@
 MOZ_NO_INSPECTOR_APIS = @MOZ_NO_INSPECTOR_APIS@
 MOZ_SVG = @MOZ_SVG@
 MOZ_LIBART_CFLAGS = @MOZ_LIBART_CFLAGS@
 MOZ_ENABLE_CANVAS = @MOZ_ENABLE_CANVAS@
 MOZ_CAIRO_CFLAGS = @MOZ_CAIRO_CFLAGS@
+MOZ_SMIL = @MOZ_SMIL@
 MOZ_XSLT_STANDALONE = @MOZ_XSLT_STANDALONE@
 
 MOZ_PREF_EXTENSIONS = @MOZ_PREF_EXTENSIONS@
 
 MOZ_CAIRO_LIBS = @MOZ_CAIRO_LIBS@
 
 MOZ_ENABLE_GNOMEUI = @MOZ_ENABLE_GNOMEUI@
 MOZ_GNOMEUI_CFLAGS = @MOZ_GNOMEUI_CFLAGS@
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -4324,16 +4324,17 @@ MOZ_PYTHON_LIBS=
 MOZ_PYTHON_LIBS=
 MOZ_PYTHON_PREFIX=
 MOZ_PYTHON_VER=
 MOZ_PYTHON_VER_DOTTED=
 MOZ_RDF=1
 MOZ_REFLOW_PERF=
 MOZ_SAFE_BROWSING=
 MOZ_HELP_VIEWER=
+MOZ_SMIL=1
 MOZ_SPELLCHECK=1
 MOZ_STATIC_MAIL_BUILD=
 MOZ_STORAGE=1
 MOZ_SVG=1
 MOZ_TIMELINE=
 MOZ_UI_LOCALE=en-US
 MOZ_UNIVERSALCHARDET=1
 MOZ_URL_CLASSIFIER=
@@ -5658,16 +5659,27 @@ MOZ_ARG_DISABLE_BOOL(svg,
 [  --disable-svg            Disable SVG support],
     MOZ_SVG=,
     MOZ_SVG=1 )
 if test -n "$MOZ_SVG"; then
   AC_DEFINE(MOZ_SVG)
 fi
 
 dnl ========================================================
+dnl SMIL
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(smil,
+[  --enable-smil            Enable SMIL animation support],
+    MOZ_SMIL=1,
+    MOZ_SMIL= )
+if test -n "$MOZ_SMIL"; then
+  AC_DEFINE(MOZ_SMIL)
+fi
+
+dnl ========================================================
 dnl Installer
 dnl ========================================================
 case "$target_os" in
     aix*|solaris*|linux*|msvc*|mks*|cygwin*|mingw*|os2*|wince*)
         MOZ_INSTALLER=1
         ;;
 esac
 
@@ -7746,16 +7758,17 @@ AC_SUBST(NS_MAEMO_LOCATION)
 AC_SUBST(NS_MAEMO_LOCATION)
 AC_SUBST(MOZ_AUTH_EXTENSION)
 AC_SUBST(MOZ_MATHML)
 AC_SUBST(MOZ_PERMISSIONS)
 AC_SUBST(MOZ_XTF)
 AC_SUBST(MOZ_NO_INSPECTOR_APIS)
 AC_SUBST(MOZ_PREF_EXTENSIONS)
 AC_SUBST(MOZ_SVG)
+AC_SUBST(MOZ_SMIL)
 AC_SUBST(MOZ_XSLT_STANDALONE)
 AC_SUBST(MOZ_JS_LIBS)
 AC_SUBST(MOZ_PSM)
 AC_SUBST(MOZ_DEBUG)
 AC_SUBST(MOZ_DEBUG_MODULES)
 AC_SUBST(MOZ_PROFILE_MODULES)
 AC_SUBST(MOZ_DEBUG_ENABLE_DEFS)
 AC_SUBST(MOZ_DEBUG_DISABLE_DEFS)
diff --git a/content/Makefile.in b/content/Makefile.in
--- a/content/Makefile.in
+++ b/content/Makefile.in
@@ -54,16 +54,20 @@ ifdef MOZ_SVG
 ifdef MOZ_SVG
 DIRS		+= svg
 endif
 
 ifdef MOZ_XTF
 DIRS            += xtf
 endif
 
+ifdef MOZ_SMIL
+DIRS		+= smil
+endif
+
 ifdef MOZ_MATHML
 DIRS            += mathml
 endif
 
 DIRS           += events
 
 ifdef ENABLE_TESTS
 TOOL_DIRS += test
diff --git a/content/base/src/nsGenericElement.cpp b/content/base/src/nsGenericElement.cpp
--- a/content/base/src/nsGenericElement.cpp
+++ b/content/base/src/nsGenericElement.cpp
@@ -1843,16 +1843,23 @@ nsGenericElement::InternalIsSupported(ns
            NS_SVG_HaveFeature(aFeature)) {
     if (aVersion.IsEmpty() ||
         PL_strcmp(v, "1.0") == 0 ||
         PL_strcmp(v, "1.1") == 0) {
       *aReturn = PR_TRUE;
     }
   }
 #endif /* MOZ_SVG */
+#ifdef MOZ_SMIL
+  else if (PL_strcasecmp(f, "TimeControl") == 0) {
+    if (aVersion.IsEmpty() || PL_strcmp(v, "1.0") == 0) {
+      *aReturn = PR_TRUE;
+    }
+  }
+#endif /* MOZ_SMIL */
   else {
     nsCOMPtr<nsIDOMNSFeatureFactory> factory =
       GetDOMFeatureFactory(aFeature, aVersion);
 
     if (factory) {
       factory->HasFeature(aObject, aFeature, aVersion, aReturn);
     }
   }
diff --git a/content/base/src/nsGkAtomList.h b/content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h
+++ b/content/base/src/nsGkAtomList.h
@@ -1250,16 +1250,38 @@ GK_ATOM(y, "y")
 GK_ATOM(y, "y")
 GK_ATOM(y1, "y1")
 GK_ATOM(y2, "y2")
 GK_ATOM(yChannelSelector, "yChannelSelector")
 GK_ATOM(z, "z")
 GK_ATOM(zoomAndPan, "zoomAndPan")
 #endif
 
+#ifdef MOZ_SMIL
+GK_ATOM(accumulate, "accumulate")
+GK_ATOM(additive, "additive")
+GK_ATOM(attributeName, "attributeName")
+GK_ATOM(attributeType, "attributeType")
+GK_ATOM(begin, "begin")
+GK_ATOM(by, "by")
+GK_ATOM(calcMode, "calcMode")
+GK_ATOM(dur, "dur")
+GK_ATOM(freeze, "freeze")
+GK_ATOM(keySplines, "keySplines")
+GK_ATOM(keyTimes, "keyTimes")
+GK_ATOM(paced, "paced")
+GK_ATOM(remove, "remove")
+GK_ATOM(repeatCount, "repeatCount")
+GK_ATOM(repeatDur, "repeatDur")
+GK_ATOM(restart, "restart")
+GK_ATOM(spline, "spline")
+GK_ATOM(to, "to")
+GK_ATOM(whennotactive, "whenNotActive")
+#endif
+
 #ifdef MOZ_MATHML
 GK_ATOM(MOZcolumnalign, "-moz-math-columnalign")
 GK_ATOM(MOZcolumnline, "-moz-math-columnline") // different from columnlines_
 GK_ATOM(MOZfontsize, "-moz-math-font-size") // different from fontsize_
 GK_ATOM(MOZfontstyle, "-moz-math-font-style") // different from fontstyle_
 GK_ATOM(MOZrowalign, "-moz-math-rowalign")
 GK_ATOM(MOZrowline, "-moz-math-rowline") // different from rowlines_
 GK_ATOM(abs_, "abs")
diff --git a/content/smil/Makefile.in b/content/smil/Makefile.in
new file mode 100644
--- /dev/null
+++ b/content/smil/Makefile.in
@@ -0,0 +1,48 @@
+# 
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla SMIL module.
+#
+# The Initial Developer of the Original Code is Brian Birtles.
+# Portions created by the Initial Developer are Copyright (C) 2005
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Brian Birtles <birtles@gmail.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+DIRS		= public src
+
+include $(topsrcdir)/config/rules.mk
+
diff --git a/content/smil/public/Makefile.in b/content/smil/public/Makefile.in
new file mode 100644
--- /dev/null
+++ b/content/smil/public/Makefile.in
@@ -0,0 +1,63 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla SMIL module.
+#
+# The Initial Developer of the Original Code is Brian Birtles.
+# Portions created by the Initial Developer are Copyright (C) 2005
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Brian Birtles <birtles@gmail.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH           = ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= content
+
+EXPORTS		= \
+	  nsISMILAttr.h \
+	  nsISMILAnimationController.h \
+	  nsISMILAnimationFunction.h \
+	  nsISMILAnimationObserver.h \
+	  nsISMILAnimationRegistry.h \
+	  nsISMILComposable.h \
+	  nsISMILTimeClient.h \
+	  nsISMILTimeContainer.h \
+	  nsISMILTimedElement.h \
+	  nsISMILType.h \
+	  nsSMILValue.h \
+	  nsSMILFloatType.h \
+	  nsSMILNullType.h \
+	  $(NULL)
+
+include $(topsrcdir)/config/rules.mk
diff --git a/content/smil/public/nsISMILAnimationController.h b/content/smil/public/nsISMILAnimationController.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsISMILAnimationController.h
@@ -0,0 +1,85 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILANIMATIONCONTROLLER_H__
+#define __NS_ISMILANIMATIONCONTROLLER_H__
+
+#include "nsIAnimationController.h"
+
+#define NS_ISMILANIMATIONCONTROLLER_IID \
+{ 0xd2c81398, 0x1f30, 0x4303, { 0xbe, 0xbe, 0xc5, 0x0c, 0x01, 0xfd, 0xd8, 0x85 } }
+
+class nsISMILTimeContainer;
+class nsIDocument;
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILAnimationController: Animation controller
+
+class nsISMILAnimationController : public nsIAnimationController
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILANIMATIONCONTROLLER_IID)
+
+  // nsIAnimationController methods
+  virtual nsresult  Pause()=0;
+  virtual nsresult  Resume()=0;
+  virtual nsresult  Reset()=0;
+  
+  // Force the animation to perform a sample, synchronously.
+  // XXXdholbert This should probably be a protected method,
+  // accessible only to the nsRunnable
+  virtual nsresult  OnForceSample()=0;
+  
+  // Queue an event that will force a sample
+  virtual void      FireForceSampleEvent()=0;
+
+  // 
+  // Eventually, this will probably be all nsISMILTimedElements so that it is
+  // possible to have hierarchies of containers (which will implement
+  // nsISMILTimedElement), and then these methods will be replaced with
+  // SetRootElement.
+  //
+  virtual nsresult  AddTimeContainer(nsISMILTimeContainer* aContainer)=0;
+  virtual nsresult  RemoveTimeContainer(nsISMILTimeContainer* aContainer)=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILAnimationController,
+                              NS_ISMILANIMATIONCONTROLLER_IID)
+
+nsISMILAnimationController* NS_NewSMILAnimationController(nsIDocument *doc);
+
+#endif // __NS_ISMILANIMATIONCONTROLLER_H__
diff --git a/content/smil/public/nsISMILAnimationFunction.h b/content/smil/public/nsISMILAnimationFunction.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsISMILAnimationFunction.h
@@ -0,0 +1,108 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILANIMATIONFUNCTION_H__
+#define __NS_ISMILANIMATIONFUNCTION_H__
+
+#include "nsISupports.h"
+#include "nsIContent.h"
+
+class nsISMILAttr;
+class nsIAtom;
+
+// {14eb1aab-e4ba-4c77-be89-195ef975c90d}
+#define NS_ISMILANIMATIONFUNCTION_IID \
+{ 0x14eb1aab, 0xe4ba, 0x4c77, { 0xbe, 0x89, 0x19, 0x5e, 0xf9, 0x75, 0xc9, 0x0d } }
+
+/**
+ * Provides the animation function for an interpolating animation element. This
+ * includes the animation-related attributes. It is intended to be used by
+ * elements such as <animate>, <animateColor> and so on.
+ *
+ * It will likely be split into nsISMILInterpolatingAnimFunc and
+ * nsISMILSimpleAnimFunc when <set> is introduced. Extra parameters or perhaps
+ * a subclass will probably be needed to support <animateTransform>,
+ * <animateMotion> and the like.
+ */
+class nsISMILAnimationFunction : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILANIMATIONFUNCTION_IID)
+
+  virtual nsresult         SetTargetAttribute(nsISMILAttr* aAttribute)=0;
+  virtual nsISMILAttr*     GetTargetAttribute()=0;
+
+  /**
+   * Attempts to set an attribute on this animation function.
+   *
+   * @param aAttribute  The name of the attribute to set. The namespace of this
+   *                    attribute is not specified as it is checked by the host
+   *                    element. Only attributes in the namespace defined for
+   *                    SMIL attributes in the host language are passed to the
+   *                    animation function.
+   *
+   * @param aValue      The attribute value.
+   *
+   * @param[out] aResult
+   *                    The result of parsing the attribute. May be nsnull. Only
+   *                    used for unit testing.
+   *
+   * @return PR_TRUE if the given attribute is an animation attribute, PR_FALSE
+   * otherwise.
+   */
+  virtual PRBool           SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                                   nsresult* aResult = nsnull)=0;
+
+  /**
+   * Attempts to unset an attribute on this animation function.
+   *
+   * @param aAttribute  The name of the attribute to set. As with SetAttr the
+   *                    namespace of the attribute is not specified (see
+   *                    SetAttr).
+   *
+   * @return PR_TRUE if the given attribute is an animation attribute, PR_FALSE
+   * otherwise.
+   */
+  virtual PRBool           UnsetAttr(nsIAtom* aAttribute)=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILAnimationFunction,
+                              NS_ISMILANIMATIONFUNCTION_IID)
+
+nsISMILAnimationFunction* NS_NewSMILAnimationFunction(nsIContent* aAnimationContent);
+
+#endif //__NS_ISMILANIMATIONFUNCTION_H__
diff --git a/content/smil/public/nsISMILAnimationObserver.h b/content/smil/public/nsISMILAnimationObserver.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsISMILAnimationObserver.h
@@ -0,0 +1,65 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILANIMATIONOBSERVER_H__
+#define __NS_ISMILANIMATIONOBSERVER_H__
+
+#include "nsISupports.h"
+#include "nsWeakReference.h"
+
+#define NS_ISMILANIMATIONOBSERVER_IID \
+{ 0x8f96dd0c, 0x9c70, 0x4b3a, { 0xa0, 0x72, 0xce, 0x71, 0x0f, 0x47, 0xa0, 0x06 } }
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILAnimationObserver: Interfaces for clients that want to be informed of
+//                           stages in the animation's life cycle
+
+class nsISMILAnimationObserver : public nsSupportsWeakReference
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILANIMATIONOBSERVER_IID)
+
+  virtual void      StartSample()=0;
+  virtual void      StartCompositing()=0;
+  virtual void      EndCompositing()=0;
+  virtual void      EndSample()=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILAnimationObserver,
+                              NS_ISMILANIMATIONOBSERVER_IID)
+
+#endif // __NS_ISMILANIMATIONOBSERVER_H__
diff --git a/content/smil/public/nsISMILAnimationRegistry.h b/content/smil/public/nsISMILAnimationRegistry.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsISMILAnimationRegistry.h
@@ -0,0 +1,157 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILANIMATIONREGISTRY_H__
+#define __NS_ISMILANIMATIONREGISTRY_H__
+
+#include "nsISupports.h"
+
+class nsISMILAnimationController;
+class nsISMILAnimationObserver;
+class nsISMILComposable;
+class nsISMILAttr;
+class nsISMILTimedElement;
+
+#define NS_ISMILANIMATIONREGISTRY_IID \
+{ 0xdd3c7124, 0xcc1f, 0x447b, { 0xa1, 0x35, 0x4a, 0xd8, 0xfc, 0xd4, 0x9f, 0x31 } }
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILAnimationRegistry: Entry point for SMIL animated documents
+
+class nsISMILAnimationRegistry : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILANIMATIONREGISTRY_IID)
+
+  /**
+   * Sets the animation controller which is needed for registering the time
+   * container managed by this registry.
+   *
+   * @param aController The animation controller. May be nsnull to disassociate
+   *                    this registry from any controller.
+   */
+  virtual nsresult  SetController(nsISMILAnimationController* aController)=0;
+
+  /**
+   * Sets the object which will be notified each time a sample begins and ends
+   * and when compositing takes place. Currently only one observer can be set at
+   * a time.
+   *
+   * @param aObserver The observer to receive notifications. May be nsnull to
+   *                  remove the currently set observer if any.
+   */
+  virtual void      SetObserver(nsISMILAnimationObserver* aObserver)=0;
+
+  /*
+   * The next six methods correspond to methods in the nsIDOMSVGSVGElement
+   * interface.
+   */
+
+  /**
+   * Starts animation. After creating the registry this method needs to be
+   * called before animation starts. This allows more precise control over when
+   * the animation starts allowing the registry to be created and set up but
+   * only started when the conditions are right.
+   */
+  virtual nsresult  Start()=0;
+
+  /**
+   * Pauses animation.
+   */
+  virtual void      Pause()=0;
+
+  /**
+   * Unpauses animation.
+   */
+  virtual void      Unpause()=0;
+
+  /**
+   * @return true if the animation is in a paused state.
+   */
+  virtual PRBool    IsPaused()=0;
+
+  /**
+   * Returns the current time in seconds relative to the start time of the
+   * animation.
+   */
+  virtual float     GetCurrentTime()=0;
+
+  /**
+   * Adjusts the clock for the animation to the specified time.
+   *
+   * @param aSeconds  The new current time in seconds relative to the start time
+   *                  for this animation.
+   */
+  virtual nsresult  SetCurrentTime(float aSeconds)=0;
+
+  /**
+   * Registers a composable object with the compositor for the specified target
+   * attribute. The composable object may be registered with several target
+   * attributes and each target attribute may have several composable objects
+   * associated with it.
+   */
+  virtual nsresult  RegisterComposable(nsISMILAttr* aTargetAttr,
+                                       nsISMILComposable* aComposable)=0;
+
+  /**
+   * Removes the specified composable object from all compositors with which is
+   * it registered.
+   */
+  virtual nsresult  UnregisterComposable(nsISMILComposable* aComposable)=0;
+
+  /**
+   * Registers the timed element with the time container managed by this
+   * registry.
+   */
+  virtual nsresult  RegisterTimedElement(nsISMILTimedElement* aElement)=0;
+
+  /**
+   * Unregisters the timed element from the time container managed by this
+   * registry.
+   */
+  virtual nsresult  UnregisterTimedElement(nsISMILTimedElement* aElement)=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILAnimationRegistry,
+                              NS_ISMILANIMATIONREGISTRY_IID)
+
+/**
+ * Creates a new animation registry object.
+ */
+nsISMILAnimationRegistry* NS_NewSMILAnimationRegistry();
+
+#endif // __NS_ISMILANIMATIONREGISTRY_H__
diff --git a/content/smil/public/nsISMILAttr.h b/content/smil/public/nsISMILAttr.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsISMILAttr.h
@@ -0,0 +1,110 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILATTR_H__
+#define __NS_ISMILATTR_H__
+
+#include "nsISupports.h"
+#include "nsStringFwd.h"
+
+struct nsSMILValue;
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILAttr: Interfaces for data types that can have a base and
+//              animated value.
+
+// {aad2eaa3-dec5-4c8c-9b9c-8371cfeea930}
+#define NS_ISMILATTR_IID \
+{ 0xaad2eaa3, 0xdec5, 0x4c8c, { 0x9b, 0x9c, 0x83, 0x71, 0xcf, 0xee, 0xa9, 0x30 } }
+
+class nsISMILAttr: public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILATTR_IID)
+  /**
+   * Gets the underlying value of this attribute.
+   *
+   * @param aValue  The value to fill.
+   * @return NS_OK on success or an error code if getting failed.
+   */
+  virtual nsresult  GetBaseValue(nsSMILValue& aValue) = 0;
+
+  /**
+   * Sets the presentation value of this attribute.
+   *
+   * @param aValue  The value to set.
+   * @return NS_OK on success or an error code if setting failed.
+   */
+  virtual nsresult  SetAnimValue(const nsSMILValue& aValue) = 0;
+
+  /**
+   * Creates a new nsSMILValue from the given specification.
+   *
+   * @param aStr    A string defining the new value to be created.
+   * @param aValue  The value to assign to.
+   * @return NS_OK on success or an error code if creation failed.
+   */
+  virtual nsresult  ValueFromString(const nsAString& aStr,
+                                    nsSMILValue& aValue) = 0;
+
+  /**
+   * Returns true if this animation attribute refers to the same content
+   * attribute as aOther.
+   * 
+   * This is necessary because sometimes independent nsISMILAttr's are created
+   * that refer to the same attribute as it is too costly to cache previously
+   * created attributes. Caching these attributes might require an extra pointer
+   * member on each animatable data type or on each nsIContent object that can
+   * be animated.
+   *
+   * @return PR_TRUE if the attributes refer to the same target. PR_FALSE
+   * otherwise.
+   */
+  virtual PRBool EqualsTarget(const nsISMILAttr &aOther) const = 0;
+
+  /**
+   * DIY RTTI
+   */
+  void* mType;
+
+protected:
+  nsISMILAttr(void* aType) : mType(aType) {}
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILAttr, NS_ISMILATTR_IID)
+
+#endif // __NS_ISMILATTR_H__
diff --git a/content/smil/public/nsISMILComposable.h b/content/smil/public/nsISMILComposable.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsISMILComposable.h
@@ -0,0 +1,140 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILCOMPOSABLE_H__
+#define __NS_ISMILCOMPOSABLE_H__
+
+#include "nsISupports.h"
+#include "nsWeakReference.h"
+#include "nsIContent.h"
+
+struct nsSMILValue;
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILComposable : Interface for animations that can be composited
+//                     by the compositor
+
+// {4b05aa22-712e-4a9e-8452-f7c4b2e507e7}
+#define NS_ISMILCOMPOSABLE_IID \
+{ 0x4b05aa22, 0x712e, 0x4a9e, { 0x84, 0x52, 0xf7, 0xc4, 0xb2, 0xe5, 0x07, 0xe7 } }
+
+class nsISMILComposable : public nsSupportsWeakReference
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILCOMPOSABLE_IID)
+
+  /**
+   * Combines the result of this animation function for the last sample with the
+   * specified value.
+   *
+   * @param aResult The value to compose with.
+   */
+  virtual void      ComposeResult(nsSMILValue &aResult)=0;
+
+  /**
+   * Returns the relative priority of this animation to another. The priority is
+   * used for determining the position of the animation in the animation
+   * sandwich.
+   *
+   * @return  -1 if this animation has lower priority or 1 if this animation has
+   *          higher priority
+   *
+   * This method should never return any other value including 0.
+   */
+  virtual PRInt8    CompareTo(nsISMILComposable& composable)=0;
+
+  /*
+   * The following methods are used in sorting.
+   */
+
+  /**
+   * Returns the begin time of this animation for the interval it is currently
+   * animating. For inactive animations this will be LL_MinInt but such
+   * animations should be filtered from compositing anyway.
+   *
+   * The time returned is in document time. This is used for sorting as
+   * animations that start later have a higher priority (SMILANIM 3.3.6). 
+   *
+   * @return  A 64-bit integer representing the begin time of this animation.
+   */
+  virtual const PRInt64&  GetBeginTime() const=0;
+
+  /**
+   * Returns the content node associated with this composable. 
+   * (The <animate> / <set> / <animateTransform> / etc. element)
+   *
+   * @return  The animation content noode associated with this composable.
+   */
+  virtual nsIContent*  GetAnimationElement()=0;
+
+  /*
+   * The following methods are provided so that the compositor can optimise its
+   * operations by only composing those animation that will affect the final
+   * result.
+   */
+
+  /**
+   * Indicates if the animation is currently active. Inactive animations will
+   * not contribute to the composed result.
+   *
+   * @return  True if the animation active, false otherwise.
+   */
+  virtual PRBool    IsActive() const=0; 
+
+  /**
+   * Indicates if this animation will replace the passed in result rather than
+   * adding to it. Animations that replace the underlying value may be called
+   * without first calling lower priority animations.
+   *
+   * @return  True if the animation will replace, false if it will add or
+   *          otherwise build on the passed in value.
+   */
+  virtual PRBool    WillReplace() const=0;
+
+  /**
+   * Indicates if the parameters for this animation have changed since the last
+   * time it was composited. This allows rendering to be performed only when
+   * necessary, particularly when no animations are active.
+   *
+   * @return  True if the animation parameters have changed, false otherwise.
+   */
+  virtual PRBool    HasChanged() const=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILComposable, NS_ISMILCOMPOSABLE_IID)
+
+#endif // __NS_ISMILCOMPOSABLE_H__
diff --git a/content/smil/public/nsISMILTimeClient.h b/content/smil/public/nsISMILTimeClient.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsISMILTimeClient.h
@@ -0,0 +1,107 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILTIMECLIENT_H__
+#define __NS_ISMILTIMECLIENT_H__
+
+#include "nsISupports.h"
+
+class nsSMILTimeValue;
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILTimeClient
+
+// {196f66f4-e6f6-420b-a337-da42a2efccde}
+#define NS_ISMILTIMECLIENT_IID \
+{ 0x196f66f4, 0xe6f6, 0x420b, { 0xa3, 0x37, 0xda, 0x42, 0xa2, 0xef, 0xcc, 0xde } }
+
+class nsISMILTimeClient : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILTIMECLIENT_IID)
+
+  /**
+   * Indicate a new sample has occurred.
+   *
+   * @param aSimpleTime The sample time for this timed element expressed in
+   *                    simple time.
+   * @param aSimpleDuration The simple duration for this timed element.
+   * @param aRepeatIteration  The repeat iteration for this sample. The first
+   *                          iteration has a value of 0.
+   */
+  virtual void      SampleAt(const PRInt64& aSimpleTime,
+                             const nsSMILTimeValue& aSimpleDuration,
+                             const PRUint32& aRepeatIteration)=0;
+
+  /**
+   * Indicate to sample using the last value defined for the animation function.
+   * This value is not normally sampled due to the end-point exclusive timing
+   * model but only occurs when the fill mode is "freeze" and the active
+   * duration is an even multiple of the simple duration.
+   *
+   * @param aRepeatIteration  The repeat iteration for this sample. The first
+   *                          iteration has a value of 0.
+   */
+  virtual void      SampleLastValue(const PRUint32& aRepeatIteration)=0;
+
+  /**
+   * Indicate that the timed element is now active. This is used, for example,
+   * to instruct the animation function that it should now add its result to the
+   * animation sandwich. The begin time is also provided for proper
+   * prioritisation of animation functions and for this reason this method must
+   * be called before either of the Sample methods.
+   *
+   * @param aBeginTime The begin time for the newly active interval.
+   */
+  virtual void      Activate(const PRInt64& aBeginTime)=0;
+
+  /**
+   * Indicate that the timed element is no longer active. This is used, for
+   * example, to instruct the animation function that it should no longer add
+   * its result to the animation sandwich.
+   *
+   * @param aIsFrozen True if this animation should continue to contribute to
+   *                  the animation sandwich using the most recent sample
+   *                  parameters even though these parameters are unlikely to
+   *                  change between samples.
+   */
+  virtual void      Inactivate(PRBool aIsFrozen)=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILTimeClient, NS_ISMILTIMECLIENT_IID)
+
+#endif // __NS_ISMILTIMECLIENT_H__
diff --git a/content/smil/public/nsISMILTimeContainer.h b/content/smil/public/nsISMILTimeContainer.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsISMILTimeContainer.h
@@ -0,0 +1,129 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILTIMECONTAINER_H__
+#define __NS_ISMILTIMECONTAINER_H__
+
+#include "nsISupports.h"
+#include "nsISMILTimedElement.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILTimeContainer: Time container
+
+// {46b51a7b-d857-45f1-9c7d-4d0d12719238}
+#define NS_ISMILTIMECONTAINER_IID \
+{ 0x46b51a7b, 0xd857, 0x45f1, { 0x9c, 0x7d, 0x4d, 0x0d, 0x12, 0x71, 0x92, 0x38 } }
+
+/**
+ * A SMIL time container.
+ *
+ * When implementing SMIL 2.0 time containers, this interface will most likely
+ * inherit from nsISMILTimedElement, amongst other changes
+ */
+class nsISMILTimeContainer : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILTIMECONTAINER_IID)
+
+  /**
+   * Pause the time container. The time container is initially unpaused.
+   */
+  virtual nsresult  Pause()=0;
+
+  /**
+   * Resume the time container.
+   */
+  virtual nsresult  Resume()=0;
+
+  /**
+   * Returns the paused state of the time container independently of the paused
+   * state of the container's parent.
+   */
+  virtual PRBool    IsPaused()=0;
+
+  /**
+   * Used to inform the time container that its parent has been paused.
+   *
+   * Currently this is necessary so that the time container will accumulate
+   * pause offsets correctly as these are not maintained by the parent.
+   *
+   * Re-using Pause() and maintaining pause counts can lead to unwanted
+   * behaviour when calls to pause and resume are unbalanced.
+   */
+  virtual nsresult  HandleParentPaused()=0;
+
+  /**
+   * Used to inform the time container that its parent has been resumed.
+   */
+  virtual nsresult  HandleParentResumed()=0;
+
+  /**
+   * Reset the time container's internal state. This is particularly useful when
+   * a cached time container is to be re-used.
+   */
+  virtual nsresult  Reset()=0;
+
+  /**
+   * We may later change this to SampleAt and maintain separate host document
+   * and document fragment times. This would allow more advanced time
+   * manipulations for documents with several animated SVG document fragments.
+   */
+  virtual void      Sample()=0;
+
+  /**
+   * Add a timed element to this container. No attempt is made to check if the
+   * timed element is already a child of this container--in that case the timed
+   * element will be added twice and will be sampled twice.
+   *
+   * @param aElement  The element to add.
+   * @return  NS_OK if the element was successfully added or an error otherwise.
+   */
+  virtual nsresult  AddTimedElement(nsISMILTimedElement* aElement)=0;
+
+  /**
+   * Remove the specified timed element from this container.
+   *
+   * @param aElement  The element to remove.
+   * @return NS_OK if the element is found and successfully removed or an error
+   * otherwise.
+   */
+  virtual nsresult  RemoveTimedElement(nsISMILTimedElement* aElement)=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILTimeContainer, NS_ISMILTIMECONTAINER_IID)
+
+#endif // __NS_ISMILTIMECONTAINER_H__
diff --git a/content/smil/public/nsISMILTimedElement.h b/content/smil/public/nsISMILTimedElement.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsISMILTimedElement.h
@@ -0,0 +1,156 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILTIMEDELEMENT_H__
+#define __NS_ISMILTIMEDELEMENT_H__
+
+#include "nsISupports.h"
+
+class nsISMILTimeClient;
+class nsSMILTimeValue;
+class nsSMILInstanceTime;
+class nsSMILTimedDocumentRoot;
+class nsIAtom;
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILTimedElement
+
+// {c5f60446-5c1a-4f3b-8ce3-646199ac97f2}
+#define NS_ISMILTIMEDELEMENT_IID \
+{ 0xc5f60446, 0x5c1a, 0x4f3b, { 0x8c, 0xe3, 0x64, 0x61, 0x99, 0xac, 0x97, 0xf2 } }
+
+class nsISMILTimedElement : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILTIMEDELEMENT_IID)
+
+  /**
+   * Adds an instance time object this element's list of instance times.
+   * These instance times are used when creating intervals.
+   *
+   * This method is typically called by an nsSMILTimeValueSpec.
+   *
+   * @param aInstanceTime   The time to add.
+   *
+   * @param aIsBegin        True if the time to be added represents a begin time
+   *                        or false if it represents an end time.
+   */
+  virtual void      AddInstanceTime(const nsSMILInstanceTime &aInstanceTime,
+                                    PRBool aIsBegin)=0;
+
+  /**
+   * Associates a timed document root. This is required for resolving wallclock
+   * values and getting the document time in order to create new instance times.
+   * 
+   * @param aRoot The timed document root to associate.
+   */
+  virtual void      SetDocumentRoot(nsSMILTimedDocumentRoot* aRoot)=0;
+
+  /**
+   * Sets the object that will be called by this timed element each time it is
+   * sampled.
+   *
+   * In Schmitz's model it is possible to associate several time clients with
+   * a timed element but for now we only allow one.
+   *
+   * @param aClient   The time client to associate. Any previous time client
+   *                  will be disassociated and no longer sampled. Setting this
+   *                  to nsnull will simply disassociate the previous client, if
+   *                  any.
+   */
+  virtual void      SetTimeClient(nsISMILTimeClient* aClient)=0;
+
+  /**
+   * Samples the object at the given document time. Timing intervals are updated
+   * and if this element is active at the given time the associated time client
+   * will be sampled with the appropriate simple time.
+   *
+   * @param aDocumentTime The document time at which to sample.
+   */
+  virtual void      SampleAt(const PRInt64& aDocumentTime)=0;
+
+  /**
+   * Reset the element's internal state. This is useful for repeating time
+   * containers and so that the timing model can be cached.
+   *
+   * @param aHardReset  Perform a hard reset such that all instance times are
+   *                    cleared. For a soft reset only instance times created by
+   *                    DOM calls and events are cleared. A hard reset is needed
+   *                    in the case of a cached timing model whilst for
+   *                    repeating only a soft reset is required.
+   */
+  virtual void      Reset(PRBool aHardReset = PR_FALSE)=0;
+
+  /**
+   * Attempts to set an attribute on this timed element.
+   *
+   * @param aAttribute  The name of the attribute to set. The namespace of this
+   *                    attribute is not specified as it is checked by the host
+   *                    element. Only attributes in the namespace defined for
+   *                    SMIL attributes in the host language are passed to the
+   *                    timed element.
+   *
+   * @param aValue      The attribute value.
+   *
+   * @param[out] aResult
+   *                    The result of parsing the attribute. May be nsnull. Only
+   *                    used for unit testing.
+   *
+   * @return PR_TRUE if the given attribute is a timing attribute, PR_FALSE
+   * otherwise.
+   */
+  virtual PRBool    SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                            nsresult* aResult = nsnull)=0;
+
+  /**
+   * Attempts to unset an attribute on this timed element.
+   *
+   * @param aAttribute  The name of the attribute to set. As with SetAttr the
+   *                    namespace of the attribute is not specified (see
+   *                    SetAttr).
+   *
+   * @return PR_TRUE if the given attribute is a timing attribute, PR_FALSE
+   * otherwise.
+   */
+  virtual PRBool    UnsetAttr(nsIAtom* aAttribute)=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILTimedElement, NS_ISMILTIMEDELEMENT_IID)
+
+nsISMILTimedElement* NS_NewSMILTimedElement();
+
+#endif // __NS_ISMILTIMEDELEMENT_H__
diff --git a/content/smil/public/nsISMILType.h b/content/smil/public/nsISMILType.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsISMILType.h
@@ -0,0 +1,168 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILTYPE_H__
+#define __NS_ISMILTYPE_H__
+
+#include "nscore.h"
+
+struct nsSMILValue;
+
+class nsISMILType
+{
+public:
+  /**
+   * Sets the value to some identity value such that adding this value with
+   * another has no effect.
+   *
+   * @pre aValue.mType == this
+   */
+  virtual void SetValueIdentity(nsSMILValue& aValue) = 0;
+
+  /**
+   * Destroys any data associated with a value of this type.
+   *
+   * @pre aValue.mType == this
+   */
+  virtual void DestroyValue(nsSMILValue& aValue) = 0;
+
+  /**
+   * Assign this object the value of another. Think of this as the assignment
+   * operator.
+   *
+   * @param   aDest       The left-hand side of the assignment.
+   * @param   aSrc        The right-hand side of the assignment.
+   * @return  NS_OK on success, an error code on failure such as when the
+   *          underlying type of the specified object differs.
+   *
+   * @pre aDest.mType == aSrc.mType == this
+   * @pre aDest's data has been destroyed
+   */
+  virtual nsresult  AssignValue(nsSMILValue& aDest,
+                                const nsSMILValue& aSrc) = 0;
+
+  /**
+   * Adds two values. This method facilitates additive and cumulative animation.
+   *
+   * This method will fail if the underlying datatype is not additive or was not
+   * specified using an additive syntax.
+   *
+   * See SVG 1.1, section 19.2.5. In particular,
+   *
+   * "If a given attribute or property can take values of keywords (which are
+   * not additive) or numeric values (which are additive), then additive
+   * animations are possible if the subsequent animation uses a numeric value
+   * even if the base animation uses a keyword value; however, if the subsequent
+   * animation uses a keyword value, additive animation is not possible."
+   *
+   * Add and Interpolate should be defined in such a way that Add followed by
+   * Interpolate produces the same result as Interpolate followed by Add. If
+   * this is a problem for a particular datatype we will need to change the way
+   * 'by' animation is implemented.
+   *
+   * @param   aDest       The value that will be adjusted.
+   * @param   aSrc        The value to add.
+   * @return  NS_OK on success, an error code on failure.
+   *
+   * @pre aDest.mType == this
+   */
+  virtual nsresult  Add(nsSMILValue& aDest,
+                        const nsSMILValue& aSrc) = 0;
+
+  /**
+   * Calculates the 'distance' between two values. This is the distance used in
+   * paced interpolation.
+   *
+   * @param   aFrom     The start of the interval for which the distance should
+   *                    be calculated.
+   * @param   aTo       The end of the interval for which the distance should be
+   *                    calculated.
+   * @param   aDistance The result of the calculation.
+   * @return  NS_OK on success, or an appropriate error code if there is no
+   *          notion of distance for the underlying data type or the distance
+   *          could not be calculated.
+   *
+   * @pre aFrom.mType == aTo.mType == this
+   */
+  virtual nsresult ComputeDistance(const nsSMILValue& aFrom,
+                                   const nsSMILValue& aTo,
+                                   PRFloat64& aDistance) const = 0;
+
+  /**
+   * Calculates an interpolated value between two values using the specified
+   * proportion.
+   *
+   * @param   aStartVal     The value defining the start of the interval of
+   *                        interpolation.
+   * @param   aEndVal       The value defining the end of the interval of
+   *                        interpolation.
+   * @param   aUnitDistance A number between 0.0 and 1.0 (inclusive) defining
+   *                        the distance of the interpolated value in the
+   *                        interval.
+   * @param   aResult       The interpolated value.
+   * @result  NS_OK on success, NS_ERROR_FAILURE if this data type cannot be
+   *          interpolated or NS_ERROR_OUT_OF_MEMORY if insufficient memory was
+   *          available for storing the result.
+   *
+   * @pre aStartVal.mType == aEndVal.mType == this
+   * @pre Any data in aResult has been destroyed
+   */
+  virtual nsresult  Interpolate(const nsSMILValue& aStartVal,
+                                const nsSMILValue& aEndVal,
+                                float aUnitDistance,
+                                nsSMILValue& aResult) = 0;
+
+  /**
+   * Repeats this value or the specified value a number of times. This method
+   * will fail if the underlying data type is not additive.
+   *
+   * @param   aDest         The value to alter.
+   * @param   aCount        The number of times to repeat the value.
+   * @param   aRepeatValue  The value to repeat. If this parameter is null the
+   *                        destination value will be repeated.
+   * @return  NS_OK on success, an error code on failure.
+   *
+   * @pre aDest.mType == this
+   * @pre aRepeatValue == nsnull || aRepeatValue->mType == this
+   */
+  virtual nsresult  Repeat(nsSMILValue& aDest,
+                           PRUint32 aCount,
+                           const nsSMILValue* aRepeatValue = nsnull) = 0;
+};
+
+#endif // __NS_ISMILTYPE_H__
diff --git a/content/smil/public/nsSMILFloatType.h b/content/smil/public/nsSMILFloatType.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsSMILFloatType.h
@@ -0,0 +1,69 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILFLOATTYPE_H__
+#define __NS_SMILFLOATTYPE_H__
+
+#include "nsISMILType.h"
+
+class nsSMILFloatType : public nsISMILType
+{
+public:
+  virtual void        SetValueIdentity(nsSMILValue& aValue);
+  virtual void        DestroyValue(nsSMILValue&) {}
+  virtual nsresult    AssignValue(nsSMILValue& aDest,
+                                  const nsSMILValue& aSrc);
+  virtual nsresult    Add(nsSMILValue& aDest, const nsSMILValue& aSrc);
+  virtual nsresult    ComputeDistance(const nsSMILValue& aFrom,
+                                      const nsSMILValue& aTo,
+                                      PRFloat64& aDistance) const;
+  virtual nsresult    Interpolate(const nsSMILValue& aStartVal,
+                                  const nsSMILValue& aEndVal,
+                                         float aUnitDistance,
+                                         nsSMILValue& aResult);
+  virtual nsresult    Repeat(nsSMILValue& aDest,
+                             PRUint32 aCount,
+                             const nsSMILValue* aRepeatValue);
+
+  static nsSMILFloatType sSingleton;
+
+private:
+  nsSMILFloatType() {}
+};
+
+#endif // __NS_SMILFLOATTYPE_H__
diff --git a/content/smil/public/nsSMILNullType.h b/content/smil/public/nsSMILNullType.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsSMILNullType.h
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILNULLTYPE_H__
+#define __NS_SMILNULLTYPE_H__
+
+#include "nsISMILType.h"
+
+class nsSMILNullType : public nsISMILType
+{
+public:
+  virtual void SetValueIdentity(nsSMILValue&) {}
+  virtual void DestroyValue(nsSMILValue&) {}
+  virtual nsresult AssignValue(nsSMILValue&, const nsSMILValue&);
+
+  // The remaining methods should never be called, so although they're very
+  // simple they don't need to be inline.
+  virtual nsresult Add(nsSMILValue&, const nsSMILValue&);
+  virtual nsresult ComputeDistance(const nsSMILValue&,
+                                   const nsSMILValue&,
+                                   PRFloat64& aDistance) const;
+  virtual nsresult Interpolate(const nsSMILValue&,
+                               const nsSMILValue&,
+                               float,
+                               nsSMILValue&);
+  virtual nsresult Repeat(nsSMILValue&,
+                          PRUint32,
+                          const nsSMILValue*);
+
+  static nsSMILNullType sSingleton;
+};
+
+#endif // __NS_SMILNULLTYPE_H__
diff --git a/content/smil/public/nsSMILValue.h b/content/smil/public/nsSMILValue.h
new file mode 100644
--- /dev/null
+++ b/content/smil/public/nsSMILValue.h
@@ -0,0 +1,116 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILVALUE_H__
+#define __NS_SMILVALUE_H__
+
+#include "nsISMILType.h"
+#include "nsSMILNullType.h"
+
+struct nsSMILValue
+{
+  nsSMILValue(nsISMILType* aType) : mType(aType)
+  {
+    mType->SetValueIdentity(*this);
+  }
+  nsSMILValue() : mType(&nsSMILNullType::sSingleton) {}
+
+  ~nsSMILValue()
+  {
+    mType->DestroyValue(*this);
+  }
+
+  nsSMILValue(const nsSMILValue& aVal) : mType( aVal.mType)
+  {
+    mType->AssignValue(*this, aVal);
+  }
+
+  // XXX Add a 'Swap' method to nsISMILType. In many cases whilst compositing
+  // we're using the assignment operator when a swap would do and would save the
+  // unnecessary allocations and deallocations that this requires for types that
+  // use dynamically allocated memory (mU.mPtr)
+  const nsSMILValue& operator=(const nsSMILValue& aVal)
+  {
+    if (&aVal == this)
+      return *this;
+
+    mType->DestroyValue(*this);
+    mType = aVal.mType;
+    mType->AssignValue(*this, aVal);
+    return *this;
+  }
+
+  bool IsNull() const
+  {
+    return (mType == &nsSMILNullType::sSingleton);
+  }
+
+  nsresult Add(const nsSMILValue& aSrc)
+  {
+    return mType->Add(*this, aSrc);
+  }
+  
+  nsresult ComputeDistance(const nsSMILValue& aTo,
+                           PRFloat64& aDistance)
+  {
+    return mType->ComputeDistance(*this, aTo, aDistance);
+  }
+
+  nsresult Interpolate(const nsSMILValue& aEndVal,
+                       float aUnitDistance,
+                       nsSMILValue& aResult)
+  {
+    aResult.mType->DestroyValue(aResult);
+    return mType->Interpolate(*this, aEndVal, aUnitDistance, aResult);
+  }
+
+  nsresult Repeat(PRUint32 aCount,
+                  const nsSMILValue* aRepeatValue = nsnull)
+  {
+    return mType->Repeat(*this, aCount, aRepeatValue);
+  }
+
+  union {
+    PRInt64 mInt;
+    double mDouble;
+    void* mPtr;
+  } mU;
+  nsISMILType* mType;
+};
+
+#endif  // __NS_SMILVALUE_H__
diff --git a/content/smil/src/Makefile.in b/content/smil/src/Makefile.in
new file mode 100644
--- /dev/null
+++ b/content/smil/src/Makefile.in
@@ -0,0 +1,89 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla SMIL module.
+#
+# The Initial Developer of the Original Code is Brian Birtles.
+# Portions created by the Initial Developer are Copyright (C) 2005
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Brian Birtles <birtles@gmail.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= content
+LIBRARY_NAME	= gkconsmil_s
+LIBXUL_LIBRARY	= 1
+
+REQUIRES	= xpcom \
+		  string \
+		  layout \
+		  content \
+		  unicharutil \
+		  widget \
+		  dom \
+		  js \
+		  pref \
+		  $(NULL)
+
+CPPSRCS		= \
+	nsSMILAnimationController.cpp \
+	nsSMILAnimationFunction.cpp \
+	nsSMILAnimationRegistry.cpp \
+	nsSMILCompositor.cpp \
+	nsSMILEnum.cpp \
+	nsSMILFloatType.cpp \
+	nsSMILInstanceTime.cpp \
+	nsSMILInterval.cpp \
+	nsSMILKeySpline.cpp \
+	nsSMILNullType.cpp \
+	nsSMILParserUtils.cpp \
+	nsSMILTimedDocumentRoot.cpp \
+	nsSMILTimedElement.cpp \
+	nsSMILTimeValue.cpp \
+	nsSMILTimeValueSpec.cpp \
+		$(NULL)
+
+include $(topsrcdir)/config/config.mk
+
+# we don't want the shared lib, but we want to force the creation of a static lib.
+FORCE_STATIC_LIB = 1
+
+ifdef ENABLE_TESTS
+TOOL_DIRS		+= test
+endif
+
+include $(topsrcdir)/config/rules.mk
+
+DEFINES += -D_IMPL_NS_LAYOUT
diff --git a/content/smil/src/nsSMILAnimationController.cpp b/content/smil/src/nsSMILAnimationController.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILAnimationController.cpp
@@ -0,0 +1,465 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISMILAnimationController.h"
+#include "nsComponentManagerUtils.h"
+#include "nsWeakReference.h"
+#include "nsAutoPtr.h"
+#include "nsITimer.h"
+#include "nsISMILTimeContainer.h"
+#include "nsCOMArray.h"
+#include "nsISimpleEnumerator.h"
+#include "nsArrayEnumerator.h"
+#include "nsIDocument.h"
+#include "nsIDOMEventTarget.h"
+#include "nsIScriptGlobalObject.h"
+#include "nsIDOMEventListener.h"
+#include "nsIDOMEvent.h"
+#include "nsThreadUtils.h" // for nsRunnable
+
+class nsSMILAnimationController : public nsISMILAnimationController,
+                                  public nsIDOMEventListener,
+                                  public nsSupportsWeakReference
+{
+public:
+  nsSMILAnimationController();
+  ~nsSMILAnimationController();
+
+  NS_DECL_ISUPPORTS
+
+  // nsISMILAnimationController
+  virtual nsresult  Pause();
+  virtual nsresult  Resume();
+  virtual nsresult  Reset();
+  virtual nsresult  AddTimeContainer(nsISMILTimeContainer* aContainer);
+  virtual nsresult  RemoveTimeContainer(nsISMILTimeContainer* aContainer);
+
+  // Force Samples
+  virtual nsresult  OnForceSample();
+  virtual void  FireForceSampleEvent();
+
+  // nsIDOMEventListener
+  NS_IMETHOD        HandleEvent(nsIDOMEvent *event);
+
+protected:
+  friend nsISMILAnimationController*
+  NS_NewSMILAnimationController(nsIDocument* doc);
+
+  // nsISMILAnimationController
+  nsresult          Init(nsIDocument* doc);
+  nsresult          StartTimer();
+  nsresult          StopTimer();
+  void              SampleChildren();
+  static void       Notify(nsITimer* aTimer, void* aClosure);
+
+  static const PRUint32         kTimerInterval;
+  nsCOMPtr<nsITimer>            mTimer;
+  nsCOMArray<nsIWeakReference>  mTimeContainers;
+  PRUint16                      mPauseCount;
+  PRBool                        mHidden;
+  PRBool                        mIsForceSampleEventQueued;
+};
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILAnimationController implementation
+
+// In my testing the minimum needed for smooth animation is 36 frames per
+// second which seems like a lot (Flash traditionally uses 14fps).
+//
+// Redrawing is synchronous. This is deliberate so that later we can tune the
+// timer based on how long the callback takes. To achieve 36fps we'd need 28ms
+// between frames. For now we set the timer interval to be a little less than
+// this (to allow for the render itself) and then let performance decay as the
+// image gets more complicated and render times increase.
+//
+const PRUint32 nsSMILAnimationController::kTimerInterval = 22;
+
+//----------------------------------------------------------------------
+// ctors, dtors, factory methods
+
+nsSMILAnimationController::nsSMILAnimationController()
+  : mPauseCount(0),
+    mHidden(PR_FALSE),
+    mIsForceSampleEventQueued(PR_FALSE)
+{
+}
+
+nsSMILAnimationController::~nsSMILAnimationController()
+{
+  if (mTimer) {
+    mTimer->Cancel();
+    mTimer = nsnull;
+  }
+}
+
+nsISMILAnimationController* NS_NewSMILAnimationController(nsIDocument* doc)
+{
+  nsSMILAnimationController* animationController = 
+    new nsSMILAnimationController();
+  NS_ENSURE_TRUE(animationController, nsnull);
+
+  nsresult rv = animationController->Init(doc);
+  if (NS_FAILED(rv)) {
+    delete animationController;
+    animationController = nsnull;
+  }
+
+  return animationController;
+}
+
+//----------------------------------------------------------------------
+// nsISupports methods:
+
+NS_IMPL_ISUPPORTS4(nsSMILAnimationController,
+                   nsISMILAnimationController,
+                   nsIAnimationController,
+                   nsIDOMEventListener,
+                   nsISupportsWeakReference)
+
+//----------------------------------------------------------------------
+// Timer callback
+
+// We use the function callback rather than implementing nsITimerCallback to
+// avoid circular ownership between the timer and this object.
+
+/*static*/ void
+nsSMILAnimationController::Notify(nsITimer* timer, void* aClosure)
+{
+  nsSMILAnimationController* controller = (nsSMILAnimationController*)aClosure;
+
+  NS_ASSERTION(controller->mTimer == timer,
+               "nsSMILAnimationController::Notify called with incorrect timer");
+
+  controller->SampleChildren();
+}
+
+//----------------------------------------------------------------------
+// nsISMILAnimationController methods:
+
+nsresult
+nsSMILAnimationController::Pause()
+{
+  if (++mPauseCount > 1)
+    return NS_OK;
+
+  nsresult rv = NS_OK;
+
+  rv = StopTimer();
+
+  // We must tell the children too so they can keep their accumulated offsets
+  // accurate
+  PRUint32 i = mTimeContainers.Count();
+  while (i > 0) {
+    --i;
+    nsCOMPtr<nsISMILTimeContainer> 
+      container( do_QueryReferent(mTimeContainers[i]) );
+
+    // This mess means that we continue processing all the children even if an
+    // error occurs but that we report the first error encountered
+    if (container) {
+      if (NS_SUCCEEDED(rv))
+        rv = container->HandleParentPaused();
+      else
+        container->HandleParentPaused();
+    } else {
+      mTimeContainers.RemoveObjectAt(i);
+    }
+  }
+
+  return rv;
+}
+
+nsresult
+nsSMILAnimationController::Resume()
+{
+  nsresult rv = NS_OK;
+
+  NS_ASSERTION(mPauseCount > 0, "Unbalanced calls to Pause() and Resume()");
+  if (mPauseCount == 0)
+    return NS_ERROR_FAILURE;
+
+  if (--mPauseCount > 0)
+    return NS_OK;
+
+  // We must tell the children so they can keep their accumulated offsets
+  // accurate
+  PRUint32 i = mTimeContainers.Count();
+  while (i > 0) {
+    --i;
+    nsCOMPtr<nsISMILTimeContainer> 
+      container( do_QueryReferent(mTimeContainers[i]) );
+
+    if (container) {
+      if (NS_SUCCEEDED(rv))
+        rv = container->HandleParentResumed();
+      else
+        container->HandleParentResumed();
+    } else {
+      mTimeContainers.RemoveObjectAt(i);
+    }
+  }
+
+  if (mTimeContainers.Count() > 0)
+    StartTimer();
+
+  return rv;
+}
+
+nsresult
+nsSMILAnimationController::Reset()
+{
+  nsresult rv = NS_OK;
+
+  PRUint32 i = mTimeContainers.Count();
+  while (i > 0) {
+    --i;
+    nsCOMPtr<nsISMILTimeContainer> 
+      container( do_QueryReferent(mTimeContainers[i]) );
+
+    if (container) {
+      if (NS_SUCCEEDED(rv))
+        rv = container->Reset();
+      else
+        container->Reset();
+    } else {
+      mTimeContainers.RemoveObjectAt(i);
+    }
+  }
+
+  return rv;
+}
+
+nsresult
+nsSMILAnimationController::AddTimeContainer(nsISMILTimeContainer* aContainer)
+{
+  NS_ENSURE_ARG_POINTER(aContainer);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aContainer, &rv)) );
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  rv = (mTimeContainers.AppendObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (mPauseCount > 0) {
+    aContainer->HandleParentPaused();
+  } else if (mTimeContainers.Count() == 1) {
+    rv = StartTimer();
+  }
+
+  return rv;
+}
+
+nsresult
+nsSMILAnimationController::RemoveTimeContainer(nsISMILTimeContainer* aContainer)
+{
+  NS_ENSURE_ARG_POINTER(aContainer);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aContainer, &rv)) );
+
+  if (NS_SUCCEEDED(rv))
+    rv = (mTimeContainers.RemoveObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+
+  if (NS_SUCCEEDED(rv) && mPauseCount == 0 && mTimeContainers.Count() == 0)
+    rv = StopTimer();
+
+  return rv;
+}
+
+nsresult
+nsSMILAnimationController::OnForceSample()
+{
+  // Make sure this was a queued call
+  NS_ENSURE_TRUE(mIsForceSampleEventQueued, NS_ERROR_FAILURE);
+
+  nsresult rv = NS_OK;
+  if (mPauseCount == 0) {
+    // Stop timer-controlled samples first, to avoid race conditions.
+    rv = StopTimer();
+    if (NS_SUCCEEDED(rv)) {
+      // StartTimer does a synchronous sample before it starts the timer.
+      // This is the sample that we're "forcing" here.
+      StartTimer();
+    }
+  }
+  mIsForceSampleEventQueued = PR_FALSE;
+  return rv;
+}
+
+// Force Sample Event
+// (Based on nsPrintCompletionEvent)
+class nsForceSampleEvent : public nsRunnable {
+public:
+  nsForceSampleEvent(nsISMILAnimationController *animationController)
+    : mAnimationController(animationController) {
+    NS_ASSERTION(mAnimationController, "mAnimationController is null.");
+  }
+
+  NS_IMETHOD Run() {
+    if (mAnimationController) {
+      return mAnimationController->OnForceSample();
+    }
+    return NS_OK;
+  }
+
+private:
+  nsRefPtr<nsISMILAnimationController> mAnimationController;
+};
+
+void
+nsSMILAnimationController::FireForceSampleEvent()
+{
+  if (!mIsForceSampleEventQueued) {
+    nsCOMPtr<nsIRunnable> event = new nsForceSampleEvent(this);
+    if (NS_FAILED(NS_DispatchToCurrentThread(event))) {
+      NS_WARNING("failed to dispatch force sample event");
+    } else {
+      mIsForceSampleEventQueued = PR_TRUE;
+    }
+  }
+}
+
+//----------------------------------------------------------------------
+// nsIDOMPageTransitionListener methods
+
+nsresult
+nsSMILAnimationController::HandleEvent(nsIDOMEvent *aEvent)
+{
+  nsAutoString eventType;
+  aEvent->GetType(eventType);
+
+  if (eventType.EqualsLiteral("pageshow")) {
+    if (!mHidden)
+      return NS_OK;
+
+    mHidden = PR_FALSE;
+
+    if (NS_SUCCEEDED(Reset())) {
+      Resume();
+    }
+  } else if (eventType.EqualsLiteral("pagehide")) {
+    mHidden = PR_TRUE;
+    Pause();
+  }
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers:
+
+nsresult
+nsSMILAnimationController::Init(nsIDocument *doc)
+{
+  mTimer = do_CreateInstance("@mozilla.org/timer;1");
+
+  // SMIL should be able to be used from a wide variety of contexts so in the
+  // following we fail silently. It is only necessary to support the bfcache.
+  if (doc) {
+    nsCOMPtr<nsIScriptGlobalObject> global(doc->GetScriptGlobalObject());
+    if (global) {
+      nsCOMPtr<nsIDOMEventTarget> receiver( do_QueryInterface(global) );
+      if (receiver) {
+        receiver->AddEventListener(NS_LITERAL_STRING("pageshow"), this,
+                                   PR_FALSE);
+        receiver->AddEventListener(NS_LITERAL_STRING("pagehide"), this,
+                                   PR_FALSE);
+      }
+    }
+  }
+
+  return (mTimer) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+nsresult
+nsSMILAnimationController::StartTimer()
+{
+  NS_ENSURE_TRUE(mTimer, NS_ERROR_FAILURE);
+  NS_ASSERTION(mPauseCount == 0, "Starting timer but controller is paused.");
+
+  // Run the first sample manually
+  SampleChildren();
+
+  // 
+  // XXX Make this self-tuning. Sounds like control theory to me and not
+  // something I'm familiar with.
+  //
+  return mTimer->InitWithFuncCallback(nsSMILAnimationController::Notify,
+                                      this,
+                                      kTimerInterval,
+                                      nsITimer::TYPE_REPEATING_SLACK);
+}
+
+nsresult
+nsSMILAnimationController::StopTimer()
+{
+  NS_ENSURE_TRUE(mTimer, NS_ERROR_FAILURE);
+
+  return mTimer->Cancel();
+}
+
+void
+nsSMILAnimationController::SampleChildren()
+{
+  // Creating a new enumerator each sample provides thread-safety but I'm not
+  // sure what the cost is
+
+  if (mPauseCount > 0)
+    return;
+
+  nsCOMPtr<nsISimpleEnumerator> enumerator;
+  nsresult rv = 
+    NS_NewArrayEnumerator(getter_AddRefs(enumerator), mTimeContainers);
+  NS_ENSURE_SUCCESS(rv,);
+
+  PRBool more = PR_FALSE;
+  nsCOMPtr<nsISMILTimeContainer> container;
+  nsCOMPtr<nsIWeakReference> weakRef;
+
+  while (NS_SUCCEEDED(enumerator->HasMoreElements(&more)) && more) {
+    if (NS_FAILED(enumerator->GetNext(getter_AddRefs(weakRef))) || !weakRef)
+      break;
+
+    container = do_QueryReferent(weakRef);
+
+    if (container)
+      container->Sample();
+  }
+}
diff --git a/content/smil/src/nsSMILAnimationFunction.cpp b/content/smil/src/nsSMILAnimationFunction.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILAnimationFunction.cpp
@@ -0,0 +1,1262 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *   Daniel Holbert <dholbert@cs.stanford.edu>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISMILAnimationFunction.h"
+#include "nsISMILComposable.h"
+#include "nsISMILTimeClient.h"
+#include "nsISMILAttr.h"
+#include "nsSMILTimeValue.h"
+#include "nsSMILValue.h"
+#include "nsSMILEnum.h"
+#include "nsSMILKeySpline.h"
+#include "nsSMILParserUtils.h"
+#include "nsGkAtoms.h"
+#include "nsCOMPtr.h"
+#include "nsCOMArray.h"
+#include "nsIContent.h"
+#include "nsAutoPtr.h"
+#include "nsTArray.h"
+#include "nsContentUtils.h"
+#include "nsReadableUtils.h"
+#include "nsString.h"
+#include <math.h>
+
+#define ALLOW_BAD_KEYTIMES
+
+//----------------------------------------------------------------------
+// nsSMILAnimationFunction
+
+class nsSMILAnimationFunction : public nsISMILAnimationFunction,
+                                public nsISMILComposable,
+                                public nsISMILTimeClient
+{
+public:
+  nsSMILAnimationFunction(nsIContent* aAnimationElement);
+
+  NS_DECL_ISUPPORTS
+
+  // nsISMILAnimationFunction
+  virtual nsresult         SetTargetAttribute(nsISMILAttr* aAttribute);
+  virtual nsISMILAttr*     GetTargetAttribute();
+  virtual PRBool           SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                                   nsresult* aResult);
+  virtual PRBool           UnsetAttr(nsIAtom* aAttribute);
+
+  // nsISMILTimeClient methods
+  virtual void             SampleAt(const PRInt64& aSimpleTime,
+                                    const nsSMILTimeValue& aSimpleDuration,
+                                    const PRUint32& aRepeatIteration);
+  virtual void             SampleLastValue(const PRUint32& aRepeatIteration);
+  virtual void             Activate(const PRInt64& aBeginTime);
+  virtual void             Inactivate(PRBool aIsFrozen);
+
+  // nsISMILComposable methods
+  virtual void             ComposeResult(nsSMILValue &aResult);
+  virtual PRInt8           CompareTo(nsISMILComposable& composable);
+  virtual const PRInt64&   GetBeginTime() const;
+  virtual nsIContent*      GetAnimationElement();
+  virtual PRBool           IsActive() const; 
+  virtual PRBool           WillReplace() const;
+  virtual PRBool           HasChanged() const;
+
+protected:
+  // Implementation helpers
+  nsISMILAnimationFunction*     NS_NewSMILAnimationFunction();
+
+  // Property setters
+  nsresult  SetAccumulate(const nsAString& aAccumulate);
+  nsresult  SetAdditive(const nsAString& aAdditive);
+  nsresult  SetBy(const nsAString& aBy);
+  nsresult  SetCalcMode(const nsAString& aCalcMode);
+  nsresult  SetFrom(const nsAString& aFrom);
+  nsresult  SetKeyTimes(const nsAString& aKeyTimes);
+  nsresult  SetKeySplines(const nsAString& aKeySplines);
+  nsresult  SetTo(const nsAString& aTo);
+  nsresult  SetValues(const nsAString& aValues);
+
+  // Property un-setters
+  void      UnsetAdditive();
+  void      UnsetBy();
+  void      UnsetCalcMode();
+  void      UnsetAccumulate();
+  void      UnsetFrom();
+  void      UnsetKeyTimes();
+  void      UnsetKeySplines();
+  void      UnsetTo();
+  void      UnsetValues();
+
+  nsresult  InterpolateResult(nsSMILValue& aResult,
+                              nsSMILValue& aBaseValue);
+  nsresult  AccumulateResult(nsSMILValue& aResult);
+
+  nsresult  ComputePacedPosition(const double& aSimpleProgress,
+                                 double& aIntervalProgress,
+                                 nsSMILValue& aFrom, nsSMILValue& aTo);
+  nsresult  ComputePacedTotalDistance();
+
+  void      ScaleSimpleProgress(PRFloat64& aProgress);
+  void      ScaleIntervalProgress(PRFloat64& aProgress, PRUint32 aIntervalIndex,
+                                  PRUint32 aNumIntervals);
+  void      FillValuesArray();
+  PRBool    IsToAnimation() const;
+  PRBool    IsAdditive() const;
+  void      CheckKeyTimes();
+  void      CheckKeySplines();
+
+  // Members
+  
+  /**
+   * The attribute being targeted. This is needed for parsing animation function
+   * values and creating temporary objects.
+   */
+  nsRefPtr<nsISMILAttr>         mAttribute;
+
+  // Animation function values.
+  nsSMILValue                   mFrom;
+  nsSMILValue                   mTo;
+  nsSMILValue                   mBy;
+  nsTArray<nsSMILValue>         mValues;
+
+  enum nsSMILCalcMode
+  {
+    calc_linear,
+    calc_discrete,
+    calc_paced,
+    calc_spline
+  };
+  static nsSMILEnumMapping      sCalcModeMap[];
+  nsSMILEnum                    mCalcMode;
+
+  static nsSMILEnumMapping      sAdditiveMap[];
+  nsSMILEnum                    mAdditive;
+
+  static nsSMILEnumMapping      sAccumulateMap[];
+  nsSMILEnum                    mAccumulate;
+
+  nsTArray<PRFloat64>           mKeyTimes;
+  nsTArray<nsSMILKeySpline>     mKeySplines;
+
+  PRPackedBool                  mIsActive;
+  PRPackedBool                  mIsFrozen;
+
+  // These are the parameters provided by the previous sample. Currently we
+  // perform lazy calculation. That is, we only calculate the result if and when
+  // instructed by the compositor. This allows us to apply the result directly
+  // to the animation value and allows the compositor to filter out functions
+  // that it determines will not contribute to the final result.
+  PRInt64                       mSimpleTime;
+  nsSMILTimeValue               mSimpleDuration;
+  PRUint32                      mRepeatIteration;
+  PRPackedBool                  mLastValue;
+  PRPackedBool                  mHasChanged;
+
+  PRInt64                       mBeginTime;
+  
+  // For sorting animation functions based on SVGAnimationElement 
+  // document position.  Raw pointer is OK here, because this
+  // nsSMILAnimationFunction can't outlive its animation element.
+  nsIContent*                   mAnimationElement;
+
+  // Keep track of which attributes have been set. This is mostly necessary for
+  // correct error handling but it also used to distinguish between when the
+  // mValues array is filled from a 'values' spec or from the values of
+  // 'from', 'to' and 'by'.
+  //
+  // Currently it is not used for all attributes.
+  PRUint16                      mSetFlags;
+
+  // Which attributes have been set but have had errors. This is not used for
+  // all attributes but only those which have specified error behaviour
+  // associated with them.
+  PRUint16                      mErrorFlags;
+
+  // This is for the very specific case where we have a 'to' animation that is
+  // frozen part way through the simple duration and there are other active
+  // lower-priority animations targetting the same attribute. In this case
+  // SMILANIM 3.3.6 says:
+  //
+  //   The value for F(t) when a to-animation is frozen (at the end of the
+  //   simple duration) is just the to value. If a to-animation is frozen
+  //   anywhere within the simple duration (e.g., using a repeatCount of "2.5"),
+  //   the value for F(t) when the animation is frozen is the value computed for
+  //   the end of the active duration. Even if other, lower priority animations
+  //   are active while a to-animation is frozen, the value for F(t) does not
+  //   change.
+  //
+  // To implement this properly we'd need to force a resample of all the lower
+  // priority animations at the active end of this animation--something which
+  // would introduce unwanted coupling between the timing and animation model.
+  // Instead we just save the value calculated when this animation is frozen (in
+  // which case this animation will be sampled at the active end and the lower
+  // priority animations should be sampled at a time pretty close to this,
+  // provided we have a reasonable frame rate and we aren't seeking).
+  //
+  // @see
+  // http://www.w3.org/TR/2001/REC-smil-animation-20010904/#FromToByAndAdditive
+  nsSMILValue                   mFrozenValue;
+
+  // Total distance to be travelled over a simple duration for
+  // calcMode="paced" animation.  This is cached here, as an optimization.
+  PRFloat64                     mPacedTotalDistance;
+};
+
+//----------------------------------------------------------------------
+// Static members
+
+nsSMILEnumMapping nsSMILAnimationFunction::sCalcModeMap[] = {
+      {&nsGkAtoms::linear, calc_linear},
+      {&nsGkAtoms::discrete, calc_discrete},
+      {&nsGkAtoms::paced, calc_paced},
+      {&nsGkAtoms::spline, calc_spline},
+      {nsnull, 0}
+};
+
+nsSMILEnumMapping nsSMILAnimationFunction::sAdditiveMap[] = {
+      {&nsGkAtoms::replace, PR_FALSE},
+      {&nsGkAtoms::sum, PR_TRUE},
+      {nsnull, 0}
+};
+
+nsSMILEnumMapping nsSMILAnimationFunction::sAccumulateMap[] = {
+      {&nsGkAtoms::none, PR_FALSE},
+      {&nsGkAtoms::sum, PR_TRUE},
+      {nsnull, 0}
+};
+
+#define BF_ACCUMULATE  0
+#define BF_ADDITIVE    1
+#define BF_BY          2
+#define BF_CALC_MODE   3
+#define BF_FROM        4
+#define BF_KEY_TIMES   5
+#define BF_KEY_SPLINES 6
+#define BF_TO          7
+#define BF_VALUES      8
+
+// Any negative number should be fine as a sentinel here,
+// because valid distances are non-negative.
+#define PACED_TOTAL_DISTANCE_NOT_SET (-1)
+
+// Based on GET/SET_BOOLBIT in nsHTMLInputElement.cpp
+#define GET_FLAG(bitfield, field) (((bitfield) & (0x01 << (field))) \
+                                     ? PR_TRUE : PR_FALSE)
+#define SET_FLAG(bitfield, field, b) ((b) \
+                                     ? ((bitfield) |=  (0x01 << (field))) \
+                                     : ((bitfield) &= ~(0x01 << (field))))
+
+//----------------------------------------------------------------------
+// Constructors etc.
+
+nsSMILAnimationFunction::nsSMILAnimationFunction(nsIContent *aAnimationElement)
+  : mCalcMode(calc_linear, sCalcModeMap),
+    mAdditive(PR_FALSE, sAdditiveMap),
+    mAccumulate(PR_FALSE, sAccumulateMap),
+    mIsActive(PR_FALSE),
+    mIsFrozen(PR_FALSE),
+    mSimpleTime(-1),
+    mRepeatIteration(0),
+    mLastValue(PR_FALSE),
+    mHasChanged(PR_TRUE),
+    mBeginTime(LL_MinInt()),
+    mAnimationElement(aAnimationElement),
+    mSetFlags(0),
+    mErrorFlags(0),
+    mPacedTotalDistance(PACED_TOTAL_DISTANCE_NOT_SET)
+{
+}
+
+nsISMILAnimationFunction*
+NS_NewSMILAnimationFunction(nsIContent *aAnimationElement)
+{
+  nsSMILAnimationFunction *func = 
+    new nsSMILAnimationFunction(aAnimationElement);
+  NS_ENSURE_TRUE(func, nsnull);
+
+  return func;
+}
+
+//----------------------------------------------------------------------
+// nsISupports methods:
+
+NS_IMPL_ISUPPORTS4(nsSMILAnimationFunction,
+                   nsISMILAnimationFunction,
+                   nsISMILComposable,
+                   nsISMILTimeClient,
+                   nsISupportsWeakReference)
+
+//----------------------------------------------------------------------
+// nsISMILAnimationFunction methods:
+
+nsresult
+nsSMILAnimationFunction::SetTargetAttribute(nsISMILAttr* aAttribute)
+{
+  mAttribute = aAttribute;
+  mValues.Clear();
+  SET_FLAG(mSetFlags, BF_VALUES, PR_FALSE);
+  mFrom = nsSMILValue();
+  mTo = nsSMILValue();
+  mBy = nsSMILValue();
+  mHasChanged = PR_TRUE;
+
+  return NS_OK;
+}
+
+nsISMILAttr*
+nsSMILAnimationFunction::GetTargetAttribute()
+{
+  return mAttribute;
+}
+
+PRBool
+nsSMILAnimationFunction::SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                                 nsresult* aResult)
+{
+  PRBool rv = PR_TRUE;
+
+  nsresult result = NS_OK;
+
+  if (aAttribute == nsGkAtoms::by)
+    result = SetBy(aValue);
+  else if (aAttribute == nsGkAtoms::from)
+    result = SetFrom(aValue);
+  else if (aAttribute == nsGkAtoms::to)
+    result = SetTo(aValue);
+  else if (aAttribute == nsGkAtoms::values)
+    result = SetValues(aValue);
+  else if (aAttribute == nsGkAtoms::accumulate)
+    result = SetAccumulate(aValue);
+  else if (aAttribute == nsGkAtoms::additive)
+    result = SetAdditive(aValue);
+  else if (aAttribute == nsGkAtoms::calcMode)
+    result = SetCalcMode(aValue);
+  else if (aAttribute == nsGkAtoms::keyTimes)
+    result = SetKeyTimes(aValue);
+  else if (aAttribute == nsGkAtoms::keySplines)
+    result = SetKeySplines(aValue);
+  else
+    rv = PR_FALSE;
+
+  if (rv && aResult)
+    *aResult = result;
+
+  return rv;
+}
+
+PRBool
+nsSMILAnimationFunction::UnsetAttr(nsIAtom* aAttribute)
+{
+  PRBool rv = PR_TRUE;
+
+  if (aAttribute == nsGkAtoms::by)
+    UnsetBy();
+  else if (aAttribute == nsGkAtoms::from)
+    UnsetFrom();
+  else if (aAttribute == nsGkAtoms::to)
+    UnsetTo();
+  else if (aAttribute == nsGkAtoms::values)
+    UnsetValues();
+  else if (aAttribute == nsGkAtoms::accumulate)
+    UnsetAccumulate();
+  else if (aAttribute == nsGkAtoms::additive)
+    UnsetAdditive();
+  else if (aAttribute == nsGkAtoms::calcMode)
+    UnsetCalcMode();
+  else if (aAttribute == nsGkAtoms::keyTimes)
+    UnsetKeyTimes();
+  else if (aAttribute == nsGkAtoms::keySplines)
+    UnsetKeySplines();
+  else
+    rv = PR_FALSE;
+
+  return rv;
+}
+
+//----------------------------------------------------------------------
+// nsISMILTimeClient methods
+
+void
+nsSMILAnimationFunction::SampleAt(const PRInt64& aSimpleTime,
+                                  const nsSMILTimeValue& aSimpleDuration,
+                                  const PRUint32& aRepeatIteration)
+{
+  if (mHasChanged || mLastValue || LL_NE(mSimpleTime, aSimpleTime) || 
+      mSimpleDuration.CompareTo(aSimpleDuration) || 
+      mRepeatIteration != aRepeatIteration)
+    mHasChanged = PR_TRUE;
+
+  mSimpleTime       = aSimpleTime;
+  mSimpleDuration   = aSimpleDuration;
+  mRepeatIteration  = aRepeatIteration;
+  mLastValue        = PR_FALSE;
+}
+
+void
+nsSMILAnimationFunction::SampleLastValue(const PRUint32& aRepeatIteration)
+{
+ if (mHasChanged || !mLastValue || mRepeatIteration != aRepeatIteration)
+    mHasChanged = PR_TRUE;
+
+  mRepeatIteration  = aRepeatIteration;
+  mLastValue        = PR_TRUE;
+}
+
+void
+nsSMILAnimationFunction::Activate(const PRInt64& aBeginTime)
+{
+  mBeginTime = aBeginTime;
+  mIsActive = PR_TRUE;
+  mIsFrozen = PR_FALSE;
+  mFrozenValue = nsSMILValue();
+}
+
+void
+nsSMILAnimationFunction::Inactivate(PRBool aIsFrozen)
+{
+  mIsActive = PR_FALSE;
+  mIsFrozen = aIsFrozen;
+  mFrozenValue = nsSMILValue();
+  mHasChanged = PR_TRUE;
+}
+
+//----------------------------------------------------------------------
+// nsISMILComposable methods
+
+void
+nsSMILAnimationFunction::ComposeResult(nsSMILValue &aResult)
+{
+  mHasChanged = PR_FALSE;
+
+  // This checks if mValues is empty so we don't need to check it again later
+  if (!IsActive())
+    return;
+
+  if (!mAttribute)
+    return;
+
+  // If this interval is active, we must have a nonnegative
+  // mSimpleTime and a resolved or indefinite mSimpleDuration.
+  // (Otherwise, we're probably just frozen.)
+  if (mIsActive) {
+    NS_ENSURE_TRUE(mSimpleTime >= 0,);
+    NS_ENSURE_TRUE(mSimpleDuration.IsResolved() || 
+                   mSimpleDuration.IsIndefinite(),);
+  }
+
+  nsSMILValue result(aResult.mType);
+  
+  if (mSimpleDuration.IsIndefinite() ||
+      (GET_FLAG(mSetFlags, BF_VALUES) && mValues.Length() == 1)) {
+
+    // Indefinite duration or only one value set: Always set the first value
+    result = mValues[0];
+
+  } else if (mLastValue) {
+
+    // Sampling last value
+    nsSMILValue last(mValues[mValues.Length() - 1]);
+    if (mAccumulate.GetIntegerValue() && mRepeatIteration > 0) {
+      if (NS_FAILED(result.Repeat(mRepeatIteration, &last)))
+        result = last;
+    } else {
+      result = last;
+    }
+
+  } else if (!mFrozenValue.IsNull() && !mHasChanged) {
+
+    // Frozen to animation
+    result = mFrozenValue;
+
+  } else {
+
+    // Interpolation
+    NS_ENSURE_SUCCESS(InterpolateResult(result, aResult),);
+    NS_ENSURE_SUCCESS(AccumulateResult(result),);
+
+    if (IsToAnimation() && mIsFrozen) {
+      mFrozenValue = result;
+    }
+  }
+
+  // If additive animation isn't required or isn't supported, set the value.
+  if (!IsAdditive() || NS_FAILED(aResult.Add(result)))
+    aResult = result;
+}
+
+PRInt8
+nsSMILAnimationFunction::CompareTo(nsISMILComposable& composable)
+{
+  // Inactive animations sort first
+  if (!IsActive() && composable.IsActive())
+    return -1;
+
+  if (IsActive() && !composable.IsActive())
+    return 1;
+
+  // Sort based on begin time
+  if (LL_NE(mBeginTime, composable.GetBeginTime()))
+    return LL_CMP(mBeginTime, >, composable.GetBeginTime()) ? 1 : -1;
+
+  // XXX When syncbase timing is implemented, we next need to sort based on
+  // dependencies
+
+  // Animations that appear later in the document sort after those earlier in
+  // the document
+  nsIContent *otherElement = composable.GetAnimationElement();
+
+  NS_ASSERTION(mAnimationElement != otherElement,
+             "Two animations cannot have the same animation content element!");
+
+  return (nsContentUtils::PositionIsBefore(otherElement, mAnimationElement))
+          ? 1
+          : (mAnimationElement == otherElement) ? 0 : -1;
+}
+
+const PRInt64&
+nsSMILAnimationFunction::GetBeginTime() const
+{
+  return mBeginTime;
+}
+
+nsIContent*
+nsSMILAnimationFunction::GetAnimationElement()
+{
+  return mAnimationElement;
+}
+
+PRBool
+nsSMILAnimationFunction::IsActive() const
+{
+  //
+  // Even if an animation should be active, if its attributes are set
+  // incorrectly, it will have no effect and should be considered by the
+  // compositor to be inactive.
+  //
+  // Frozen animations should be considered active for the purposes of
+  // compositing.
+  //
+  return ((mIsActive || mIsFrozen) && mValues.Length() > 0 && mErrorFlags == 0);
+}
+
+
+PRBool
+nsSMILAnimationFunction::WillReplace() const
+{
+  /*
+   * In IsAdditive() we don't consider to-animation to be additive as it is
+   * a special case that is dealt with differently in the compositing method but
+   * here we return false for to animation as it builds on the underlying value
+   * unless its a frozen to animation.
+   */
+  return !(IsAdditive() || IsToAnimation()) || 
+    (IsToAnimation() && mIsFrozen && !mHasChanged);
+}
+
+PRBool
+nsSMILAnimationFunction::HasChanged() const
+{
+  return mHasChanged;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+nsresult
+nsSMILAnimationFunction::InterpolateResult(nsSMILValue& aResult,
+                                           nsSMILValue& aBaseValue)
+{
+  nsresult        rv = NS_OK;
+  double          fTime;
+  double          fDur;
+  double          simpleProgress;   // normalized progress through simple dur
+  double          intervalProgress; // normalized progress between adjacent vals
+  nsSMILValue     from;
+  nsSMILValue     to;
+  const PRInt64&  dur  = mSimpleDuration.GetMillis();
+
+  // Sanity Checks
+  NS_ASSERTION(mSimpleTime >= 0.0f, "Simple time should not be negative...");
+  NS_ASSERTION(dur  >= 0.0f, "Simple duration should not be negative...");
+
+  if (LL_CMP(mSimpleTime, >=, dur) || !LL_GE_ZERO(mSimpleTime)) {
+    NS_ERROR("Animation sampled outside interval.");
+    return NS_ERROR_FAILURE;
+  }
+
+  if ((!IsToAnimation() && mValues.Length() < 2) || 
+      (IsToAnimation()  && mValues.Length() != 1)) {
+    NS_ERROR("Unexpected number of values.");
+    return NS_ERROR_FAILURE;
+  }
+  // End Sanity Checks
+
+  LL_L2D(fTime, mSimpleTime);
+  LL_L2D(fDur, dur);
+  simpleProgress = (fDur > 0.0) ? fTime / fDur : 0.0;
+
+#ifdef ALLOW_BAD_KEYTIMES
+  if (GET_FLAG(mSetFlags, BF_KEY_TIMES)) {
+    PRFloat64 first = mKeyTimes[0];
+    if (first > 0.0 && simpleProgress < first) {
+      if (!IsToAnimation())
+        aResult = mValues[0];
+      return rv;
+    }
+    PRFloat64 last = mKeyTimes[mKeyTimes.Length() - 1];
+    if (last < 1.0 && simpleProgress >= last) {
+      if (IsToAnimation())
+        aResult = mValues[0];
+      else
+        aResult = mValues[mValues.Length() - 1];
+      return rv;
+    }
+  }
+#endif
+
+  ScaleSimpleProgress(simpleProgress);
+
+  // Handle calc_discrete separately, because it's simple.
+  if (mCalcMode.GetIntegerValue() == calc_discrete) {
+    PRUint32 index = IsToAnimation() ? 0 :
+      (PRUint32) floor(simpleProgress * (mValues.Length()));
+    aResult = mValues[index];
+    return NS_OK;
+  } 
+
+  // XXXdholbert -- maybe from and to should be pointers or references,
+  // so we don't have to do memory copying during the "from = [nsSMILValue]"
+  // assignment? (esp. for complex types with storage in mU.mPtr)
+  if (IsToAnimation()) {
+    // Note: Don't need to do any special-casing for calc_paced here,
+    // because To-Animation doesn't use a values list, by definition.
+    from = aBaseValue;
+    to = mValues[0];
+    intervalProgress = simpleProgress;
+    ScaleIntervalProgress(intervalProgress, 0, 1);
+  } else {
+    if (mCalcMode.GetIntegerValue() == calc_paced) { 
+      ComputePacedPosition(simpleProgress, 
+                           intervalProgress, from, to);
+    } else { // mCalcMode == calc_linear or mCalcMode == calc_spline
+      PRUint32 index = (PRUint32) floor(simpleProgress * (mValues.Length() - 1));
+      from = mValues[index];
+      to = mValues[index + 1];
+      intervalProgress = simpleProgress * (mValues.Length() - 1) - index;
+      ScaleIntervalProgress(intervalProgress, index, mValues.Length() - 1);
+    }
+  }
+
+  return from.Interpolate(to, static_cast<float>(intervalProgress), aResult);
+}
+
+nsresult
+nsSMILAnimationFunction::AccumulateResult(nsSMILValue& aResult)
+{
+  if (!IsToAnimation() && mAccumulate.GetIntegerValue() && mRepeatIteration)
+  {
+    nsSMILValue repeatValue(aResult.mType);
+    nsSMILValue lastValue = mValues[mValues.Length() - 1];
+
+    // If the target attribute doesn't support addition, Repeat will fail and we
+    // leave aResult untouched.
+    if (NS_SUCCEEDED(repeatValue.Repeat(mRepeatIteration - 1,
+                                        &lastValue)))
+      aResult.Add(repeatValue);
+  }
+
+  return NS_OK;
+}
+
+/*
+ * Given the simple progress for a paced animation, this method:
+ *  - determines which two elements of mValues we're in between
+ *    (returned as aFrom and aTo)
+ *  - determines where we are between them
+ *    (returned as aIntervalProgress)
+ *
+ * Returns NS_OK, unless there's an error computing distances.
+ */
+nsresult
+nsSMILAnimationFunction::ComputePacedPosition(const double& aSimpleProgress,
+                                              double& aIntervalProgress,
+                                              nsSMILValue& aFrom,
+                                              nsSMILValue& aTo)
+{
+  NS_ASSERTION(0.0f <= aSimpleProgress && aSimpleProgress < 1.0f,
+               "aSimpleProgress is out of bounds.");
+  NS_ASSERTION(mCalcMode.GetIntegerValue() == calc_paced,
+               "Calling paced-specific function, but not in paced mode");
+
+  if (mPacedTotalDistance == PACED_TOTAL_DISTANCE_NOT_SET) {
+    nsresult rv = ComputePacedTotalDistance();
+    if (!NS_SUCCEEDED(rv)) 
+      return rv;
+  } 
+
+  // total distance we should have moved at this point in time.
+  // (called 'remainingDist' due to how it's used in loop below)
+  PRFloat64 remainingDist = aSimpleProgress * mPacedTotalDistance;
+
+  // Find where remainingDist puts us in the list of values
+  // Note: We could optimize this next loop by caching the
+  // interval-distances in an array, but maybe that's excessive.
+  for (PRUint32 i = 0; i < mValues.Length() - 1; i++) {
+    PRFloat64 curIntervalDist;
+    nsresult tmpRv = mValues[i].ComputeDistance(mValues[i+1], curIntervalDist);
+    NS_ASSERTION(NS_SUCCEEDED(tmpRv), "ComputeDistance failed...?");
+    if (remainingDist >= curIntervalDist) {
+      remainingDist -= curIntervalDist;
+    } else {
+      // We found the right spot -- an interpolated position between
+      // values i and i+1.
+      aFrom = mValues[i];
+      aTo = mValues[i+1];
+      aIntervalProgress = remainingDist / curIntervalDist;
+      return NS_OK;
+    }
+  }
+
+  NS_NOTREACHED("shouldn't complete loop & get here -- if we do, "
+                "then aSimpleProgress was probably out of bounds.");
+  return NS_ERROR_FAILURE;
+}
+
+/*
+ * Computes & caches the total distance to be travelled by a paced animation.
+ *
+ * Returns NS_OK, unless there's an error computing distance.
+ */
+nsresult
+nsSMILAnimationFunction::ComputePacedTotalDistance()
+{
+  NS_ASSERTION(mCalcMode.GetIntegerValue() == calc_paced,
+               "Calling paced-specific function, but not in paced mode");
+  NS_ASSERTION(mPacedTotalDistance == PACED_TOTAL_DISTANCE_NOT_SET,
+               "Recomputing mPacedTotalDistance when it's already set...");
+
+  mPacedTotalDistance = 0.0f;
+  for (PRUint32 i = 0; i < mValues.Length() - 1; i++) {
+    PRFloat64 tmpDist;
+    nsresult rv = mValues[i].ComputeDistance(mValues[i+1], tmpDist);
+    if (!NS_SUCCEEDED(rv)) {
+      NS_NOTREACHED("ComputeDistance failed...?");
+      return rv;
+    }
+    mPacedTotalDistance += tmpDist;
+  }
+  return NS_OK;
+}
+
+/*
+ * Scale the simple progress, taking into account any keyTimes.
+ */
+void
+nsSMILAnimationFunction::ScaleSimpleProgress(PRFloat64& aProgress)
+{
+  if (!GET_FLAG(mSetFlags, BF_KEY_TIMES))
+    return;
+
+  PRUint32 numTimes = mKeyTimes.Length();
+
+  if (numTimes < 2)
+    return;
+
+  PRUint32 i = 0;
+  for (; i < numTimes - 2 && aProgress >= mKeyTimes[i+1]; ++i);
+
+  PRFloat64& intervalStart = mKeyTimes[i];
+  PRFloat64& intervalEnd   = mKeyTimes[i+1];
+
+  PRFloat64 intervalLength = intervalEnd - intervalStart;
+  if (intervalLength <= 0.0) {
+    aProgress = intervalStart;
+    return;
+  }
+
+  aProgress = (i + (aProgress - intervalStart) / intervalLength) * 
+         1.0 / (PRFloat64)(numTimes - 1);
+}
+
+/*
+ * Scale the interval progress, taking into account any keySplines
+ * or discrete methods.
+ */
+void
+nsSMILAnimationFunction::ScaleIntervalProgress(PRFloat64& aProgress,
+                                               PRUint32   aIntervalIndex,
+                                               PRUint32   aNumIntervals)
+{
+  if (mCalcMode.GetIntegerValue() != calc_spline)
+    return;
+
+  if (!GET_FLAG(mSetFlags, BF_KEY_SPLINES))
+    return;
+
+  NS_ASSERTION(aIntervalIndex >= 0 && 
+               aIntervalIndex < (PRUint32)mKeySplines.Length(),
+               "Invalid interval index.");
+  NS_ASSERTION(aNumIntervals >= 1, "Invalid number of intervals.");
+
+  if (aIntervalIndex < 0 ||
+      aIntervalIndex >= (PRUint32)mKeySplines.Length() ||
+      aNumIntervals < 1)
+    return;
+
+  nsSMILKeySpline const &spline = mKeySplines[aIntervalIndex];
+  aProgress = spline.GetSplineValue(aProgress);
+}
+
+/*
+ * SMILANIM specifies the following rules for animation function values:
+ *
+ * (1) if values is set, it overrides everything
+ * (2) for from/to/by animation at least to or by must be specified, from on its
+ *     own (or nothing) is an error--which we will ignore
+ * (3) if both by and to are specified only to will be used, by will be ignored
+ * (4) if by is specified without from (by animation), forces additive behaviour
+ * (5) if to is specified without from (to animation), special care needs to be
+ *     taken when compositing animation as such animations are composited last.
+ *
+ * This helper method applies these rules to fill in the values list and to set
+ * some internal state.
+ */
+void
+nsSMILAnimationFunction::FillValuesArray()
+{
+  // Need to clear cached paced-total-distance whenever we modify values array
+  mPacedTotalDistance = PACED_TOTAL_DISTANCE_NOT_SET;
+
+  if (!GET_FLAG(mSetFlags, BF_VALUES)) {
+    mValues.Clear();
+    mValues.SetCapacity(2);
+
+    if (!mTo.IsNull()) {
+      if (!mFrom.IsNull()) {
+        mValues.AppendElement(mFrom);
+        mValues.AppendElement(mTo);
+      } else {
+        mValues.AppendElement(mTo);
+      }
+    } else if (!mBy.IsNull()) {
+      if (!mFrom.IsNull()) {
+        // Set values to 'from; from + by'
+        mValues.AppendElement(mFrom);
+        nsSMILValue to = mFrom;
+        if (!to.IsNull() && NS_SUCCEEDED(to.Add(mBy))) {
+          mValues.AppendElement(to);
+        } else {
+          mValues.Clear();
+        }
+      } else {
+        // Set values to '0; by'
+        nsSMILValue from(mBy.mType);
+        if (!from.IsNull()) {
+          mValues.AppendElement(from);
+          mValues.AppendElement(mBy);
+        } else {
+          mValues.Clear();
+        }
+      }
+    }
+    // else, do nothing, mValues has been cleared already.
+  }
+
+  // mValues has changed, do we still have the right number of keySplines and
+  // keyTimes?
+  CheckKeyTimes();
+  CheckKeySplines();
+}
+
+inline PRBool
+nsSMILAnimationFunction::IsToAnimation() const
+{
+  return (!GET_FLAG(mSetFlags, BF_VALUES) && !mTo.IsNull() && mFrom.IsNull());
+}
+
+inline PRBool
+nsSMILAnimationFunction::IsAdditive() const
+{
+  /*
+   * Animation is additive if:
+   *
+   * (1) additive = "sum" (mAdditive == true), or
+   * (2) it is 'by animation' (by is set, from and values are not)
+   *
+   * Although animation is not additive if it is 'to animation'
+   */
+  return (!IsToAnimation() && 
+      (mAdditive.GetIntegerValue() || 
+       (!GET_FLAG(mSetFlags, BF_VALUES) && !mBy.IsNull() && mFrom.IsNull())));
+}
+
+/**
+ * Performs checks for the keyTimes attribute required by the SMIL spec but
+ * which depend on other attributes and therefore needs to be updated as
+ * dependent attributes are set.
+ */
+void
+nsSMILAnimationFunction::CheckKeyTimes()
+{
+  if (!GET_FLAG(mSetFlags, BF_KEY_TIMES))
+    return;
+
+  // attribute is ignored for calcMode = paced
+  if (mCalcMode.GetIntegerValue() == calc_paced) {
+    SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_FALSE);
+    return;
+  }
+
+  if (mKeyTimes.Length() < 1) {
+    // keyTimes isn't set or failed preliminary checks
+    SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_TRUE);
+    return;
+  }
+
+  // no. keyTimes == no. values
+  if ((mKeyTimes.Length() != mValues.Length() && !IsToAnimation()) ||
+      (IsToAnimation() && mKeyTimes.Length() != 2)) {
+    SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_TRUE);
+    return;
+  }
+
+  // special handling if there is only one keyTime. The spec doesn't say what to
+  // do in this case so we allow the keyTime to be either 0 or 1.
+  if (mKeyTimes.Length() == 1) {
+    PRFloat64 time = mKeyTimes[0];
+    SET_FLAG(mErrorFlags, BF_KEY_TIMES, !(time == 0.0 || time == 1.0));
+    return;
+  }
+
+  // there is a contradiction in the spec here. We're told the last value must
+  // be 1 for linear or spline calcMode's but then an example is given later of
+  // a from-to animation with a spline calcMode and keyTimes "0.0; 0.7".
+
+#ifndef ALLOW_BAD_KEYTIMES
+  // first value must be 0
+  if (mKeyTimes[0] != 0.0) {
+    SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_TRUE);
+    return;
+  }
+
+  // last value must be 1 for linear or spline calcMode's
+  if (mCalcMode.GetIntegerValue() == calc_linear || 
+      mCalcMode.GetIntegerValue() == calc_spline) {
+    PRFloat64 lastValue = mKeyTimes[mKeyTimes.Length() - 1];
+    if (lastValue != 1.0) {
+      SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_TRUE);
+      return;
+    }
+  }
+#endif
+
+  SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_FALSE);
+}
+
+void
+nsSMILAnimationFunction::CheckKeySplines()
+{
+  // attribute is ignored if calc mode is not spline
+  if (mCalcMode.GetIntegerValue() != calc_spline) {
+    SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_FALSE);
+    return;
+  }
+
+  // calc mode is spline but the attribute is not set
+  if (!GET_FLAG(mSetFlags, BF_KEY_SPLINES)) {
+    SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_FALSE);
+    return;
+  }
+
+  if (mKeySplines.Length() < 1) {
+    // keyTimes isn't set or failed preliminary checks
+    SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_TRUE);
+    return;
+  }
+
+  // ignore splines if there's only one value
+  if (mValues.Length() == 1 && !IsToAnimation()) {
+    SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_FALSE);
+    return;
+  }
+
+  // no. keySpline specs == no. values - 1
+  PRUint32 splineSpecs = mKeySplines.Length();
+  if ((splineSpecs != mValues.Length() - 1 && !IsToAnimation()) ||
+      (IsToAnimation() && splineSpecs != 1)) {
+    SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_TRUE);
+    return;
+  }
+
+  SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_FALSE);
+}
+
+//----------------------------------------------------------------------
+// Property setters / un-setters:
+
+nsresult
+nsSMILAnimationFunction::SetAdditive(const nsAString& aAdditive)
+{
+  mHasChanged = PR_TRUE;
+  return mAdditive.SetStringValue(aAdditive);
+}
+
+void
+nsSMILAnimationFunction::UnsetAdditive()
+{
+  mAdditive.SetIntegerValue((PRUint16)PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetBy(const nsAString& aBy)
+{
+  if (!mAttribute)
+    return NS_ERROR_FAILURE;
+
+  nsresult rv = mAttribute->ValueFromString(aBy, mBy);
+  SET_FLAG(mErrorFlags, BF_BY, NS_FAILED(rv));
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+
+  FillValuesArray();
+  mHasChanged = PR_TRUE;
+
+  return NS_OK;
+}
+
+void
+nsSMILAnimationFunction::UnsetBy()
+{
+  mBy = nsSMILValue();
+  FillValuesArray();
+  SET_FLAG(mErrorFlags, BF_BY, PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetCalcMode(const nsAString& aCalcMode)
+{
+  mHasChanged = PR_TRUE;
+  nsresult rv = mCalcMode.SetStringValue(aCalcMode);
+  SET_FLAG(mErrorFlags, BF_CALC_MODE, NS_FAILED(rv));
+  CheckKeyTimes();
+  CheckKeySplines();
+
+  return rv;
+}
+
+void
+nsSMILAnimationFunction::UnsetCalcMode()
+{
+  mCalcMode.SetIntegerValue(calc_linear);
+  SET_FLAG(mErrorFlags, BF_CALC_MODE, PR_FALSE);
+  mHasChanged = PR_TRUE;
+  CheckKeyTimes();
+  CheckKeySplines();
+}
+
+nsresult
+nsSMILAnimationFunction::SetAccumulate(const nsAString& aAccumulate)
+{
+  mHasChanged = PR_TRUE;
+  return mAccumulate.SetStringValue(aAccumulate);
+}
+
+void
+nsSMILAnimationFunction::UnsetAccumulate()
+{
+  mAccumulate.SetIntegerValue((PRUint16)PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+
+nsresult
+nsSMILAnimationFunction::SetFrom(const nsAString& aFrom)
+{
+  if (!mAttribute)
+    return NS_ERROR_FAILURE;
+
+  nsresult rv = mAttribute->ValueFromString(aFrom, mFrom);
+  SET_FLAG(mErrorFlags, BF_FROM, NS_FAILED(rv));
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+
+  FillValuesArray();
+  mHasChanged = PR_TRUE;
+
+  return NS_OK;
+}
+
+void
+nsSMILAnimationFunction::UnsetFrom()
+{
+  mFrom = nsSMILValue();
+  FillValuesArray();
+  SET_FLAG(mErrorFlags, BF_FROM, PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetKeySplines(const nsAString& aKeySplines)
+{
+  mKeySplines.Clear();
+
+  nsTArray<PRFloat64> keySplines;
+  nsresult rv = nsSMILParserUtils::GetKeySplines(aKeySplines, keySplines);
+
+  if (keySplines.Length() < 1 || keySplines.Length() % 4)
+    rv = NS_ERROR_FAILURE;
+
+  if (NS_SUCCEEDED(rv))
+  {
+    mKeySplines.SetCapacity(keySplines.Length() % 4);
+    for (PRUint32 i = 0; i < keySplines.Length() && NS_SUCCEEDED(rv); i += 4)
+    {
+      if (!mKeySplines.AppendElement(nsSMILKeySpline(keySplines[i],
+                                                     keySplines[i+1],
+                                                     keySplines[i+2],
+                                                     keySplines[i+3]))) {
+        rv = NS_ERROR_OUT_OF_MEMORY;
+      }
+    }
+  }
+
+  mHasChanged = PR_TRUE;
+  SET_FLAG(mSetFlags, BF_KEY_SPLINES, PR_TRUE);
+
+  CheckKeySplines();
+
+  return rv;
+}
+
+void
+nsSMILAnimationFunction::UnsetKeySplines()
+{
+  mKeySplines.Clear();
+  SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_FALSE);
+  SET_FLAG(mSetFlags, BF_KEY_SPLINES, PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetKeyTimes(const nsAString& aKeyTimes)
+{
+  mKeyTimes.Clear();
+  nsresult rv = nsSMILParserUtils::GetKeyTimes(aKeyTimes, mKeyTimes);
+
+  if (NS_SUCCEEDED(rv) && mKeyTimes.Length() < 1)
+    rv = NS_ERROR_FAILURE;
+
+  if (NS_FAILED(rv))
+    mKeyTimes.Clear();
+
+  mHasChanged = PR_TRUE;
+  SET_FLAG(mSetFlags, BF_KEY_TIMES, PR_TRUE);
+
+  CheckKeyTimes();
+
+  return NS_OK;
+}
+
+void
+nsSMILAnimationFunction::UnsetKeyTimes()
+{
+  mKeyTimes.Clear();
+  SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_FALSE);
+  SET_FLAG(mSetFlags, BF_KEY_TIMES, PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetTo(const nsAString& aTo)
+{
+  if (!mAttribute)
+    return NS_ERROR_FAILURE;
+
+  nsresult rv = mAttribute->ValueFromString(aTo, mTo);
+  SET_FLAG(mErrorFlags, BF_TO, NS_FAILED(rv));
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+
+  FillValuesArray();
+  mHasChanged = PR_TRUE;
+
+  return NS_OK;
+}
+
+void
+nsSMILAnimationFunction::UnsetTo()
+{
+  mTo = nsSMILValue();
+  FillValuesArray();
+  SET_FLAG(mErrorFlags, BF_TO, PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetValues(const nsAString& aValues)
+{
+  if (!mAttribute)
+    return NS_ERROR_FAILURE;
+
+  mValues.Clear();
+  SET_FLAG(mSetFlags, BF_VALUES, PR_FALSE);
+
+  nsresult rv = nsSMILParserUtils::GetValues(aValues, mValues, *mAttribute);
+
+  if (NS_SUCCEEDED(rv))
+    SET_FLAG(mSetFlags, BF_VALUES, PR_TRUE);
+  else
+    mValues.Clear();
+
+  mHasChanged = PR_TRUE;
+  SET_FLAG(mErrorFlags, BF_VALUES, NS_FAILED(rv));
+  CheckKeyTimes();
+  CheckKeySplines();
+
+  return rv;
+}
+
+void
+nsSMILAnimationFunction::UnsetValues()
+{
+  SET_FLAG(mSetFlags, BF_VALUES, PR_FALSE);
+  FillValuesArray();
+  SET_FLAG(mErrorFlags, BF_VALUES, PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
diff --git a/content/smil/src/nsSMILAnimationRegistry.cpp b/content/smil/src/nsSMILAnimationRegistry.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILAnimationRegistry.cpp
@@ -0,0 +1,296 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILAnimationRegistry.h"
+#include "nsISMILAnimationObserver.h"
+#include "nsISMILAttr.h"
+#include "nsISMILComposable.h"
+#include "nsSMILTimedDocumentRoot.h"
+#include "nsMathUtils.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILAnimationRegistry implementation
+
+//----------------------------------------------------------------------
+// ctors, dtors, factory methods
+
+nsSMILAnimationRegistry::~nsSMILAnimationRegistry()
+{
+  if (mController && mTimedDocumentRoot)
+    mController->RemoveTimeContainer(mTimedDocumentRoot);
+}
+
+nsISMILAnimationRegistry*
+NS_NewSMILAnimationRegistry()
+{
+  nsSMILAnimationRegistry* animationRegistry = new nsSMILAnimationRegistry();
+
+  if (!animationRegistry)
+    return nsnull;
+
+  nsresult rv = animationRegistry->Init();
+  if (NS_FAILED(rv)) {
+    delete animationRegistry;
+    animationRegistry = nsnull;
+  }
+
+  return animationRegistry;
+}
+
+nsresult
+nsSMILAnimationRegistry::Init()
+{
+  mTimedDocumentRoot = new nsSMILTimedDocumentRoot(this);
+  NS_ENSURE_TRUE(mTimedDocumentRoot, NS_ERROR_OUT_OF_MEMORY);
+
+  mTimedDocumentRoot->Pause();
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// nsISupports methods:
+
+NS_IMPL_ISUPPORTS1(nsSMILAnimationRegistry,
+                   nsISMILAnimationRegistry)
+
+//----------------------------------------------------------------------
+// nsISMILAnimationRegistry methods:
+
+nsresult
+nsSMILAnimationRegistry::SetController(nsISMILAnimationController* aController)
+{
+  nsresult rv = NS_OK;
+
+  NS_ENSURE_TRUE(mTimedDocumentRoot, NS_ERROR_FAILURE);
+
+  if (mController) {
+    rv = mController->RemoveTimeContainer(mTimedDocumentRoot);
+    NS_ENSURE_SUCCESS(rv,rv);
+  }
+
+  mController = aController;
+
+  if (mController)
+    rv = mController->AddTimeContainer(mTimedDocumentRoot);
+
+  return rv;
+}
+
+void
+nsSMILAnimationRegistry::SetObserver(nsISMILAnimationObserver* aObserver)
+{
+  if (aObserver) {
+    mObserver = do_GetWeakReference(aObserver);
+  } else {
+    mObserver = nsnull;
+  }
+}
+
+nsresult
+nsSMILAnimationRegistry::Start()
+{
+  NS_ENSURE_TRUE(mTimedDocumentRoot,NS_ERROR_FAILURE);
+  if (!mStarted) {
+    mTimedDocumentRoot->Resume();
+    mStarted = PR_TRUE;
+  }
+  return NS_OK;
+}
+
+void
+nsSMILAnimationRegistry::Pause()
+{
+  NS_ENSURE_TRUE(mTimedDocumentRoot,);
+  NS_ENSURE_TRUE(mStarted,);
+  mTimedDocumentRoot->Pause();
+}
+
+void
+nsSMILAnimationRegistry::Unpause()
+{
+  NS_ENSURE_TRUE(mTimedDocumentRoot,);
+  NS_ENSURE_TRUE(mStarted,);
+  mTimedDocumentRoot->Resume();
+}
+
+PRBool
+nsSMILAnimationRegistry::IsPaused()
+{
+  if (!mStarted)
+    return PR_TRUE;
+
+  NS_ENSURE_TRUE(mTimedDocumentRoot,PR_FALSE);
+
+  return mTimedDocumentRoot->IsPaused();
+}
+
+float
+nsSMILAnimationRegistry::GetCurrentTime()
+{
+  PRInt64 lCurrentTimeMs = mTimedDocumentRoot->GetDocumentTime();
+  PRFloat64 fCurrentTimeMs;
+  LL_L2D(fCurrentTimeMs, lCurrentTimeMs);
+  return (float)(fCurrentTimeMs / PR_MSEC_PER_SEC);
+}
+
+nsresult
+nsSMILAnimationRegistry::SetCurrentTime(float aSeconds)
+{
+  PRFloat64 fMilliseconds = aSeconds * PR_MSEC_PER_SEC;
+  PRInt64 lMilliseconds;
+  // Round to nearest whole number before converting, to avoid precision errors
+  LL_D2L(lMilliseconds, NS_round(fMilliseconds));
+  return mTimedDocumentRoot->SeekToTime(lMilliseconds);
+}
+
+nsresult
+nsSMILAnimationRegistry::RegisterComposable(nsISMILAttr* aTargetAttr,
+                                            nsISMILComposable* aComposable)
+{
+  NS_ENSURE_ARG_POINTER(aTargetAttr);
+  NS_ENSURE_ARG_POINTER(aComposable);
+
+  nsSMILCompositor*   compositor = nsnull;
+
+  //
+  // Iterate in reverse as if a compositor already exists for this attribute it
+  // is most likely to be the most recently added entry.
+  //
+  for (PRUint32 i = mCompositors.Length(); i > 0 && !compositor;) {
+    CompositorEntry &entry = mCompositors[--i];
+    if (entry.mKey->EqualsTarget(*aTargetAttr))
+      compositor = &entry.mCompositor;
+  }
+
+  if (!compositor) {
+    CompositorEntry *new_entry = mCompositors.AppendElement();
+    NS_ENSURE_TRUE(new_entry,NS_ERROR_OUT_OF_MEMORY);
+
+    nsresult rv = new_entry->mCompositor.Init(aTargetAttr);
+    if (NS_FAILED(rv)) {
+      mCompositors.RemoveElementAt(mCompositors.Length() - 1);
+      return rv;
+    }
+    NS_ENSURE_SUCCESS(rv,rv);
+
+    new_entry->mKey = aTargetAttr;
+
+    compositor = &new_entry->mCompositor;
+  }
+
+  return compositor->AddComposable(aComposable);
+}
+
+nsresult
+nsSMILAnimationRegistry::UnregisterComposable(nsISMILComposable* aComposable)
+{
+  NS_ENSURE_ARG_POINTER(aComposable);
+
+  PRBool              found = PR_FALSE;
+  nsresult            result = NS_OK;
+  nsresult            rv = NS_ERROR_FAILURE;
+  PRUint32            count = mCompositors.Length();
+
+  for (PRUint32 i = 0; i < count; ++i) {
+    CompositorEntry &entry = mCompositors[i];
+    rv = entry.mCompositor.RemoveComposable(aComposable);
+
+    // This rather complicated error handling just ensures that we report the
+    // first error that occurs, or a generic error if the item wasn't found.
+    if (NS_SUCCEEDED(result))
+      result = rv;
+    found = PR_TRUE;
+
+    // Even if the entry now no longer has any compositors we don't bother
+    // deleting it as it may be re-used again later.
+  }
+
+  return (found) ? rv : NS_ERROR_FAILURE;
+}
+
+nsresult
+nsSMILAnimationRegistry::RegisterTimedElement(nsISMILTimedElement *aElement)
+{
+  return (mTimedDocumentRoot) ? mTimedDocumentRoot->AddTimedElement(aElement)
+                              : NS_ERROR_FAILURE;
+}
+
+nsresult
+nsSMILAnimationRegistry::UnregisterTimedElement(nsISMILTimedElement *aElement)
+{
+  return (mTimedDocumentRoot) ? mTimedDocumentRoot->RemoveTimedElement(aElement)
+                              : NS_ERROR_FAILURE;
+}
+
+void
+nsSMILAnimationRegistry::StartSample()
+{
+  if (mObserver) {
+    nsCOMPtr<nsISMILAnimationObserver> observer = do_QueryReferent(mObserver);
+    if (observer)
+      observer->StartSample();
+  }
+
+  // Do any pre-animation actions here, e.g. acquiring locks, blocking scripts
+  // etc.
+}
+
+void
+nsSMILAnimationRegistry::EndSample()
+{
+  nsCOMPtr<nsISMILAnimationObserver> observer;
+  
+  if (mObserver)
+    observer = do_QueryReferent(mObserver);
+
+  if (observer)
+    observer->StartCompositing();
+
+  PRUint32 count = mCompositors.Length();
+  for (PRUint32 i = 0; i < count; ++i) {
+    mCompositors[i].mCompositor.ComposeSample();
+  }
+
+  if (observer)
+    observer->EndCompositing();
+
+  // Release any locks etc.
+
+  if (observer)
+    observer->EndSample();
+}
diff --git a/content/smil/src/nsSMILAnimationRegistry.h b/content/smil/src/nsSMILAnimationRegistry.h
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILAnimationRegistry.h
@@ -0,0 +1,102 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILANIMATIONREGISTRY_H__
+#define __NS_SMILANIMATIONREGISTRY_H__
+
+#include "nsISMILAnimationRegistry.h"
+#include "nsISMILAnimationController.h"
+#include "nsSMILCompositor.h"
+#include "nsTArray.h"
+#include "nsAutoPtr.h"
+#include "nsWeakPtr.h"
+
+class nsSMILTimedDocumentRoot;
+class nsISMILAttr;
+
+class nsSMILAnimationRegistry : public nsISMILAnimationRegistry
+{
+public:
+  ~nsSMILAnimationRegistry();
+
+  NS_DECL_ISUPPORTS
+
+  virtual void      StartSample();
+  virtual void      EndSample();
+
+  // nsISMILAnimationRegistry
+  virtual nsresult  SetController(nsISMILAnimationController* aController);
+  virtual void      SetObserver(nsISMILAnimationObserver* aObserver);
+  virtual nsresult  Start();
+  virtual void      Pause();
+  virtual void      Unpause();
+  virtual PRBool    IsPaused();
+  virtual float     GetCurrentTime();
+  virtual nsresult  SetCurrentTime(float aSeconds);
+  virtual nsresult  RegisterComposable(nsISMILAttr *aTargetAttr,
+                                       nsISMILComposable *aComposable);
+  virtual nsresult  UnregisterComposable(nsISMILComposable *aComposable);
+  virtual nsresult  RegisterTimedElement(nsISMILTimedElement *aElement);
+  virtual nsresult  UnregisterTimedElement(nsISMILTimedElement *aElement);
+
+protected:
+  friend nsISMILAnimationRegistry* NS_NewSMILAnimationRegistry();
+
+  nsresult          Init();
+
+  struct CompositorEntry
+  {
+    nsISMILAttr*      mKey;
+    nsSMILCompositor  mCompositor;
+  };
+
+  nsTArray<CompositorEntry>             mCompositors;
+  nsRefPtr<nsSMILTimedDocumentRoot>     mTimedDocumentRoot;
+  nsCOMPtr<nsISMILAnimationController>  mController;
+  nsWeakPtr                             mObserver;
+  PRBool                                mStarted;
+
+private:
+  // This class should only be created by the factory method
+  nsSMILAnimationRegistry() : mStarted(PR_FALSE) {}
+
+  // Pass by value and assignment should not be used
+  nsSMILAnimationRegistry(const nsSMILAnimationRegistry& other);
+  nsSMILAnimationRegistry& operator=(const nsSMILAnimationRegistry& right);
+};
+
+#endif // __NS_SMILANIMATIONREGISTRY_H__
diff --git a/content/smil/src/nsSMILCompositor.cpp b/content/smil/src/nsSMILCompositor.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILCompositor.cpp
@@ -0,0 +1,143 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILCompositor.h"
+#include "nsISMILComposable.h"
+#include "nsISimpleEnumerator.h"
+#include "nsArrayEnumerator.h"
+#include "nsISMILAttr.h"
+#include "nsSMILValue.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILCompositor implementation
+
+nsresult
+nsSMILCompositor::Init(nsISMILAttr* aTargetAttribute)
+{
+  NS_ENSURE_ARG_POINTER(aTargetAttribute);
+
+  mTargetAttribute = aTargetAttribute;
+
+  return aTargetAttribute->GetBaseValue(mResult);
+}
+
+nsresult
+nsSMILCompositor::AddComposable(nsISMILComposable* aComposable)
+{
+  NS_ENSURE_ARG_POINTER(aComposable);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aComposable, &rv)) );
+
+  if (NS_SUCCEEDED(rv))
+    rv = (mChildren.AppendObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+
+  return rv;
+}
+
+nsresult
+nsSMILCompositor::RemoveComposable(nsISMILComposable* aComposable)
+{
+  NS_ENSURE_ARG_POINTER(aComposable);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aComposable, &rv)) );
+  
+  if (NS_SUCCEEDED(rv))
+    rv = (mChildren.RemoveObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+
+  return rv;
+}
+
+void
+nsSMILCompositor::ComposeSample()
+{
+  NS_ENSURE_TRUE(mTargetAttribute,);
+  nsresult rv;
+
+  rv = mTargetAttribute->GetBaseValue(mResult);
+  NS_ENSURE_SUCCESS(rv,);
+
+  mChildren.Sort(SortCompositors, nsnull);
+
+  PRBool changed = PR_FALSE;
+  nsCOMPtr<nsISMILComposable> composable;
+  PRUint32 length = mChildren.Count();
+  PRUint32 i;
+  
+  for (i = length; i > 0; --i) {
+    composable = do_QueryReferent(mChildren[i-1]);
+    if (composable) {
+      changed |= composable->HasChanged();
+      if (composable->WillReplace()) {
+        --i;
+        break;
+     }
+    }
+  }
+
+  if (!changed)
+    return;
+
+  for (; i < length; ++i)
+  {
+    composable = do_QueryReferent(mChildren[i]);
+    if (composable)
+      composable->ComposeResult(mResult);
+  }
+
+  // We can't just call Set on the animated value itself, because the observers
+  // of the animated object as a whole need to be updated too.
+  rv = mTargetAttribute->SetAnimValue(mResult);
+  NS_ENSURE_SUCCESS(rv,);
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+PR_CALLBACK int
+nsSMILCompositor::SortCompositors(nsIWeakReference* aRef1,
+                                  nsIWeakReference* aRef2,
+                                  void* /*aData*/)      
+{
+  nsCOMPtr<nsISMILComposable> a = do_QueryReferent(aRef1);
+  nsCOMPtr<nsISMILComposable> b = do_QueryReferent(aRef2);
+
+  return (a && b) ? a->CompareTo(*b) : (a) ? 1 : (b) ? -1 : 0;
+}
diff --git a/content/smil/src/nsSMILCompositor.h b/content/smil/src/nsSMILCompositor.h
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILCompositor.h
@@ -0,0 +1,78 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILCOMPOSITOR_H__
+#define __NS_SMILCOMPOSITOR_H__
+
+#include "nsCOMArray.h"
+#include "nsWeakReference.h"
+#include "nsSMILValue.h"
+#include "nsISMILAttr.h"
+#include "nsAutoPtr.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILCompositor: Collection of nsISMILComposable animations
+
+class nsISMILComposable;
+
+class nsSMILCompositor
+{
+public:
+  nsSMILCompositor() {}
+
+  nsresult  Init(nsISMILAttr* aTargetAttribute);
+
+  nsresult  AddComposable(nsISMILComposable* aComposable);
+  nsresult  RemoveComposable(nsISMILComposable* aComposable);
+  void      ComposeSample();
+
+protected:
+  PR_STATIC_CALLBACK(int) SortCompositors(nsIWeakReference* aRef1,
+                                          nsIWeakReference* aRef2,
+                                          void* aData);
+
+  nsCOMArray<nsIWeakReference>   mChildren;
+  nsSMILValue                    mResult;
+  nsRefPtr<nsISMILAttr>          mTargetAttribute;
+
+private:
+  // Pass by value and assignment should not be used
+  nsSMILCompositor(const nsSMILCompositor& other);
+  nsSMILCompositor& operator=(const nsSMILCompositor& right);
+};
+
+#endif // __NS_SMILCOMPOSITOR_H__
diff --git a/content/smil/src/nsSMILEnum.cpp b/content/smil/src/nsSMILEnum.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILEnum.cpp
@@ -0,0 +1,94 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Tim Rowley <tor@cs.brown.edu> (original author)
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILEnum.h"
+#include "nsGkAtoms.h"
+#include "nsString.h"
+#include "nsCRT.h"
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSMILEnum::nsSMILEnum(PRUint16 value,
+                       nsSMILEnumMapping *mapping)
+    : mValue(value), mMapping(mapping)
+{
+  nsGkAtoms::AddRefAtoms();
+}
+
+nsresult
+nsSMILEnum::SetStringValue(const nsAString& aValue)
+{
+  // 
+  // According to XML 1.0, section 3.3.3 we need to discard leading and trailing
+  // whitespace for this attribute. Currently nsSVGEnum doesn't do this
+  // otherwise we might try and re-use some of that functionality here
+  //
+  nsAString::const_iterator start;
+  nsAString::const_iterator end;
+
+  aValue.BeginReading(start);
+  aValue.EndReading(end);
+
+  while (*start && NS_IS_SPACE(*start))
+    ++start;
+
+  do --end; while (start != end && NS_IS_SPACE(*end));
+    ++end;
+
+  nsCOMPtr<nsIAtom> valAtom = do_GetAtom(Substring(start, end));
+
+  nsSMILEnumMapping *tmp = mMapping;
+
+  if (!tmp)
+    return NS_ERROR_FAILURE;
+
+  while (tmp->key) {
+    if (valAtom == *(tmp->key)) {
+      mValue = tmp->val;
+      return NS_OK;
+    }
+    tmp++;
+  }
+
+  // XXXbb Should be reporting a warning somehow?
+  // NS_WARNING("Unknown enumeration key");
+
+  return NS_ERROR_FAILURE;
+}
diff --git a/content/smil/src/nsSMILEnum.h b/content/smil/src/nsSMILEnum.h
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILEnum.h
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Tim Rowley <tor@cs.brown.edu> (original author)
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILENUM_H__
+#define __NS_SMILENUM_H__
+
+#include "nsIAtom.h"
+
+struct nsSMILEnumMapping 
+{
+    nsIAtom **key;
+    PRUint16 val;
+};
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILEnum class
+
+class nsSMILEnum
+{
+public:
+  nsSMILEnum(PRUint16 value, nsSMILEnumMapping *mapping);
+
+  PRUint16  GetIntegerValue() const { return mValue; }
+  void      SetIntegerValue(const PRUint16 &aValue) { mValue = aValue; }
+  nsresult  SetStringValue(const nsAString &aValue);
+
+protected:
+  PRUint16          mValue;
+  nsSMILEnumMapping *mMapping;
+};
+
+#endif //__NS_SMILENUM_H__
diff --git a/content/smil/src/nsSMILFloatType.cpp b/content/smil/src/nsSMILFloatType.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILFloatType.cpp
@@ -0,0 +1,122 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILFloatType.h"
+#include "nsSMILValue.h"
+#include "nsDebug.h"
+
+/*static*/ nsSMILFloatType nsSMILFloatType::sSingleton;
+
+void
+nsSMILFloatType::SetValueIdentity(nsSMILValue& aValue)
+{
+  aValue.mU.mDouble = 0.0;
+}
+
+nsresult
+nsSMILFloatType::AssignValue(nsSMILValue& aDest, const nsSMILValue& aSrc)
+{
+  NS_ASSERTION(aSrc.mType == &sSingleton, "Unexpected source type");
+  aDest.mType = &sSingleton;
+  aDest.mU.mDouble = aSrc.mU.mDouble;
+  return NS_OK;
+}
+
+nsresult
+nsSMILFloatType::Add(nsSMILValue& aDest, const nsSMILValue& aSrc)
+{
+  NS_ASSERTION(aSrc.mType == aDest.mType, "Trying to add invalid types");
+  NS_ASSERTION(aSrc.mType == &sSingleton, "Unexpected source type");
+  aDest.mU.mDouble += aSrc.mU.mDouble;
+  return NS_OK;
+}
+
+nsresult
+nsSMILFloatType::ComputeDistance(const nsSMILValue& aFrom,
+                                 const nsSMILValue& aTo,
+                                 PRFloat64& aDistance) const
+{
+  NS_ASSERTION(aFrom.mType == aTo.mType, "Trying to compare different types");
+  NS_ASSERTION(aFrom.mType == &sSingleton, "Unexpected source type");
+  
+  const double &from = aFrom.mU.mDouble;
+  const double &to   = aTo.mU.mDouble;
+
+  // XXX do we have an absolute-value utility function?
+  aDistance = to - from;
+  if (aDistance < 0) 
+    aDistance = -aDistance;
+
+  return NS_OK;
+}
+
+nsresult
+nsSMILFloatType::Interpolate(const nsSMILValue& aStartVal,
+                             const nsSMILValue& aEndVal,
+                             float aUnitDistance,
+                             nsSMILValue& aResult)
+{
+  NS_ASSERTION(aStartVal.mType == aEndVal.mType,
+      "Trying to interpolate different types");
+  NS_ASSERTION(aStartVal.mType == &sSingleton, "Unexpected type");
+
+  const double &startVal = aStartVal.mU.mDouble;
+  const double &endVal   = aEndVal.mU.mDouble;
+
+  aResult.mU.mDouble = (startVal + (endVal - startVal) * aUnitDistance);
+  aResult.mType      = &sSingleton;
+
+  return NS_OK;
+}
+
+nsresult
+nsSMILFloatType::Repeat(nsSMILValue& aDest,
+                        PRUint32 aCount,
+                        const nsSMILValue* aRepeatValue)
+{
+  NS_ASSERTION(aDest.mType == &sSingleton, "Trying to repeat invalid type");
+  NS_ASSERTION(!aRepeatValue || aRepeatValue->mType == &sSingleton,
+    "Invalid repeat type");
+
+  double const &value = (aRepeatValue)
+                      ? aRepeatValue->mU.mDouble
+                      : aDest.mU.mDouble;
+  aDest.mU.mDouble = value * (aCount + 1);
+
+  return NS_OK;
+}
diff --git a/content/smil/src/nsSMILInstanceTime.cpp b/content/smil/src/nsSMILInstanceTime.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILInstanceTime.cpp
@@ -0,0 +1,60 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILInstanceTime.h"
+#include "nsSMILTimeValueSpec.h"
+#include "nsSMILTimeValue.h"
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSMILInstanceTime::nsSMILInstanceTime(const nsSMILTimeValue &aTime,
+                                       nsSMILTimeValueSpec *aCreator,
+                                       PRBool aClearOnReset /*=false*/)
+  : mTime(aTime), // Copy the time
+    mClearOnReset(aClearOnReset)
+{
+  if (aCreator)
+    mCreator = do_GetWeakReference(aCreator);
+}
+
+nsSMILInstanceTime::~nsSMILInstanceTime()
+{
+  // XXXdholbert When we add support for syncbase timing, we'll
+  // need to remove this nsSMILInstanceTime from its timebase
+  // here.
+}
diff --git a/content/smil/src/nsSMILInstanceTime.h b/content/smil/src/nsSMILInstanceTime.h
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILInstanceTime.h
@@ -0,0 +1,104 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILINSTANCETIME_H__
+#define __NS_SMILINSTANCETIME_H__
+
+#include "nsISupports.h"
+#include "nsSMILTimeValue.h"
+#include "nsWeakReference.h"
+#include "nsAutoPtr.h"
+
+class nsSMILTimeValueSpec;
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILInstanceTime : An instant in document simple time that may be
+//                      used in creating a new interval
+
+class nsSMILInstanceTime
+{
+public:
+  nsSMILInstanceTime(const nsSMILTimeValue &aTime,
+                     nsSMILTimeValueSpec *aCreator,
+                     PRBool aClearOnReset = PR_FALSE);
+
+  ~nsSMILInstanceTime();
+
+  const nsSMILTimeValue&  Time() const { return mTime; }
+
+  PRBool                  ClearOnReset() const { return mClearOnReset; }
+
+  // void DependentUpdate(const nsSMILTimeValue& aNewTime); -- NOT YET IMPL.
+
+  // Used by nsTArray::Sort
+  class Comparator {
+    public:
+      PRBool Equals(const nsSMILInstanceTime& aElem1,
+                    const nsSMILInstanceTime& aElem2) const {
+        return (aElem1.Time().CompareTo(aElem2.Time()) == 0);
+      }
+      PRBool LessThan(const nsSMILInstanceTime& aElem1,
+                      const nsSMILInstanceTime& aElem2) const {
+        return (aElem1.Time().CompareTo(aElem2.Time()) < 0);
+      }
+  };
+
+protected:
+  nsSMILTimeValue     mTime;
+
+  /**
+   * The nsSMILTimeValueSpec that created this instance time if any. This will
+   * be NULL for instance times created via DOM calls etc.
+   */
+  nsWeakPtr           mCreator;
+
+  /**
+   * Indicates if this instance time should be removed when the owning timed
+   * element is reset. True for events and DOM calls.
+   */
+  PRBool              mClearOnReset;
+
+  /*
+   * This will only be used for for identifying the instance times associated
+   * with a deleting interval. We will never de-reference this pointer, but only
+   * use it for pointer comparisons. Therefore it's not necessary for instances
+   * of nsSMILInterval to be reference-counted.
+   */
+  // nsSMILInterval   *mTimebase -- NOT YET IMPLEMENTED
+};
+
+#endif // __NS_SMILINSTANCETIME_H__
diff --git a/content/smil/src/nsSMILInterval.cpp b/content/smil/src/nsSMILInterval.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILInterval.cpp
@@ -0,0 +1,74 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILInterval.h"
+#include "nsSMILInstanceTime.h"
+#include "nsCRT.h"
+
+// Creates a new interval with unresolved begin and end times
+nsSMILInterval::nsSMILInterval()
+: mBegin(),
+  mEnd()
+{
+}
+
+nsSMILInterval::nsSMILInterval(const nsSMILTimeValue& aBegin,
+                               const nsSMILTimeValue& aEnd)
+: mBegin(aBegin),
+  mEnd(aEnd)
+{
+}
+
+//----------------------------------------------------------------------
+// Implementation
+
+NS_IMPL_ISUPPORTS1(nsSMILInterval,
+                   nsSMILInterval)
+
+void
+nsSMILInterval::UpdateBegin(const nsSMILTimeValue &aNewTime)
+{
+  mBegin = aNewTime;
+  // XXX notify dependents
+}
+
+void
+nsSMILInterval::UpdateEnd(const nsSMILTimeValue &aNewTime)
+{
+  mEnd = aNewTime;
+  // XXX notify dependents
+}
diff --git a/content/smil/src/nsSMILInterval.h b/content/smil/src/nsSMILInterval.h
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILInterval.h
@@ -0,0 +1,83 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILINTERVAL_H__
+#define __NS_SMILINTERVAL_H__
+
+#include "nsISupports.h"
+#include "nsSMILTimeValue.h"
+
+class nsSMILInstanceTime;
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILInterval class
+
+// {443cdd3f-1d0c-4eb9-b043-5cde9e4ca35b}
+#define NS_SMILINTERVAL_IID \
+{ 0x443cdd3f, 0x1d0c, 0x4eb9, { 0xb0, 0x43, 0x5c, 0xde, 0x9e, 0x4c, 0xa3, 0x5b } }
+
+class nsSMILInterval : public nsISupports
+{
+public:
+  nsSMILInterval();
+  nsSMILInterval(const nsSMILTimeValue &aBegin,
+                 const nsSMILTimeValue &aEnd);
+
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_SMILINTERVAL_IID)
+  NS_DECL_ISUPPORTS
+
+  const nsSMILTimeValue& Begin() { return mBegin; }
+  const nsSMILTimeValue& End() { return mEnd; }
+
+  void UpdateBegin(const nsSMILTimeValue &aNewTime);
+  void UpdateEnd(const nsSMILTimeValue &aNewTime);
+
+  // We will need to track dependent instance times from here
+  //
+  // e.g.
+  // 
+  // void  AddDependent(nsSMILInstanceTime& aDependent, PRBool aForBegin);
+  // void  RemoveDependent(nsSMILInstanceTime& aDependent, PRBool aForBegin);
+
+protected:
+  nsSMILTimeValue   mBegin;
+  nsSMILTimeValue   mEnd;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsSMILInterval, NS_SMILINTERVAL_IID)
+
+#endif // __NS_SMILINTERVAL_H__
diff --git a/content/smil/src/nsSMILKeySpline.cpp b/content/smil/src/nsSMILKeySpline.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILKeySpline.cpp
@@ -0,0 +1,119 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILKeySpline.h"
+#include <math.h>
+
+#define NEWTON_ITERATIONS   4
+
+const PRFloat64 nsSMILKeySpline::kSampleStepSize = 
+                                        1.0 / (PRFloat64)(kSplineTableSize - 1);
+
+nsSMILKeySpline::nsSMILKeySpline(const PRFloat64& aX1,
+                                 const PRFloat64& aY1,
+                                 const PRFloat64& aX2,
+                                 const PRFloat64& aY2)
+: mX1(aX1),
+  mY1(aY1),
+  mX2(aX2),
+  mY2(aY2)
+{
+  if (mX1 != mY1 || mX2 != mY2)
+    CalcSampleValues();
+}
+
+PRFloat64
+nsSMILKeySpline::GetSplineValue(const PRFloat64& x) const
+{
+  if (mX1 == mY1 && mX2 == mY2)
+    return x;
+
+  return CalcBezier(GetTForX(x), mY1, mY2);
+}
+
+void
+nsSMILKeySpline::CalcSampleValues()
+{
+  for (int i = 0; i < kSplineTableSize; ++i)
+    mSampleValues[i] = CalcBezier((PRFloat64)i * kSampleStepSize, mX1, mX2);
+}
+
+/*static*/ PRFloat64
+nsSMILKeySpline::CalcBezier(const PRFloat64& t,
+                            const PRFloat64& a1,
+                            const PRFloat64& a2)
+{
+  return A(a1, a2) * pow(t,3) + B(a1, a2)*t*t + C(a1) * t;
+}
+
+/*static*/ PRFloat64
+nsSMILKeySpline::GetSlope(const PRFloat64& t,
+                             const PRFloat64& a1,
+                             const PRFloat64& a2)
+{
+  PRFloat64 denom = (3.0 * A(a1, a2)*t*t + 2.0 * B(a1, a2) * t + C(a1)); 
+  return (denom == 0.0) ? 0.0 : 1.0 / denom;
+}
+
+PRFloat64
+nsSMILKeySpline::GetTForX(const PRFloat64& x) const
+{
+  int i;
+
+  // Get an initial guess.
+  //
+  // Note: This is better than just taking x as our initial guess as cases such
+  // as where the control points are (1, 1), (0, 0) will take some 20 iterations
+  // to converge to a good accuracy. By taking an initial guess in this way we
+  // only need 3~4 iterations depending on the size of the table.
+  for (i = 0; i < kSplineTableSize - 2 && mSampleValues[i] < x; ++i);
+  PRFloat64 currentT = 
+    (PRFloat64)i * kSampleStepSize + (x - mSampleValues[i]) * kSampleStepSize;
+
+  // Refine with Newton-Raphson iteration
+  for (i = 0; i < NEWTON_ITERATIONS; ++i) {
+    PRFloat64 currentX = CalcBezier(currentT, mX1, mX2);
+    PRFloat64 currentSlope = GetSlope(currentT, mX1, mX2);
+
+    if (currentSlope == 0.0)
+      return currentT;
+
+    currentT -= (currentX - x) * currentSlope;
+  }
+
+  return currentT;
+}
diff --git a/content/smil/src/nsSMILKeySpline.h b/content/smil/src/nsSMILKeySpline.h
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILKeySpline.h
@@ -0,0 +1,96 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILKEYSPLINE_H__
+#define __NS_SMILKEYSPLINE_H__
+
+#include "prtypes.h"
+
+/**
+ * Utility class to provide scaling defined in a keySplines element.
+ */
+class nsSMILKeySpline
+{
+public:
+  nsSMILKeySpline(const PRFloat64& aX1, const PRFloat64& aY1,
+                  const PRFloat64& aX2, const PRFloat64& aY2);
+
+  PRFloat64 GetSplineValue(const PRFloat64& x) const;
+
+private:
+  void
+  CalcSampleValues();
+
+  static PRFloat64
+  CalcBezier(const PRFloat64& t, const PRFloat64& a1, const PRFloat64& a2);
+
+  static PRFloat64
+  GetSlope(const PRFloat64& t, const PRFloat64& a1, const PRFloat64& a2);
+
+  PRFloat64
+  GetTForX(const PRFloat64& x) const;
+
+  static PRFloat64
+  A(const PRFloat64& a1, const PRFloat64& a2)
+  {
+    return 1.0 - 3.0 * a2 + 3.0 * a1;
+  }
+  
+  static PRFloat64
+  B(const PRFloat64& a1, const PRFloat64& a2)
+  {
+    return 3.0 * a2 - 6.0 * a1;
+  }
+
+  static PRFloat64
+  C(const PRFloat64& a1)
+  {
+    return 3.0 * a1;
+  }
+
+  const PRFloat64         mX1;
+  const PRFloat64         mY1;
+  const PRFloat64         mX2;
+  const PRFloat64         mY2;
+
+  enum { kSplineTableSize = 11 };
+  PRFloat64               mSampleValues[kSplineTableSize];
+
+  static const PRFloat64  kSampleStepSize;
+};
+
+#endif // __NS_SMILKEYSPLINE_H__
diff --git a/content/smil/src/nsSMILNullType.cpp b/content/smil/src/nsSMILNullType.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILNullType.cpp
@@ -0,0 +1,87 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILNullType.h"
+#include "nsSMILValue.h"
+#include "nsDebug.h"
+
+/*static*/ nsSMILNullType nsSMILNullType::sSingleton;
+
+nsresult
+nsSMILNullType::AssignValue(nsSMILValue& aDest, const nsSMILValue& aSrc)
+{
+  NS_ASSERTION(aSrc.mType == &sSingleton, "Unexpected source type");
+  aDest.mType = &sSingleton;
+  return NS_OK;
+}
+
+nsresult
+nsSMILNullType::Add(nsSMILValue&, const nsSMILValue&)
+{
+  NS_NOTREACHED("Adding NULL type.");
+  return NS_ERROR_FAILURE;
+}
+
+nsresult
+nsSMILNullType::ComputeDistance(const nsSMILValue&,
+                                const nsSMILValue&,
+                                PRFloat64& aDistance) const
+{
+  NS_NOTREACHED("Computing distance for NULL type.");
+  aDistance = 0.0;
+  return NS_ERROR_FAILURE;
+}
+
+nsresult
+nsSMILNullType::Interpolate(const nsSMILValue&,
+                            const nsSMILValue&,
+                            float,
+                            nsSMILValue&)
+{
+  NS_NOTREACHED("Interpolating NULL type.");
+  return NS_ERROR_FAILURE;
+}
+
+nsresult
+nsSMILNullType::Repeat(nsSMILValue&,
+                       PRUint32,
+                       const nsSMILValue*)
+{
+  NS_NOTREACHED("Repeating NULL type.");
+  return NS_ERROR_FAILURE;
+}
diff --git a/content/smil/src/nsSMILParserUtils.cpp b/content/smil/src/nsSMILParserUtils.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILParserUtils.cpp
@@ -0,0 +1,616 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILParserUtils.h"
+#include "nsISMILAttr.h"
+#include "nsSMILValue.h"
+#include "nsSMILTimeValue.h"
+#include "nsString.h"
+#include "prdtoa.h"
+#include "nsCRT.h"
+#include "nsCOMPtr.h"
+#include "prlong.h"
+
+const PRUint32 nsSMILParserUtils::MSEC_PER_SEC   = 1000;
+const PRUint32 nsSMILParserUtils::MSEC_PER_MIN   = 1000 * 60;
+const PRUint32 nsSMILParserUtils::MSEC_PER_HOUR  = 1000 * 60 * 60;
+
+//------------------------------------------------------------------------------
+// Inlines
+
+// NS_IS_SPACE relies on isspace which may return true for \xB and \xC but
+// SMILANIM does not consider these characters to be whitespace.
+inline PRBool
+nsSMILParserUtils::IsSpace(const char c)
+{
+  return (c == 0x9 || c == 0xA || c == 0xD || c == 0x20);
+}
+
+inline PRBool
+nsSMILParserUtils::IsSpace(const PRUnichar c)
+{
+  return (c == 0x9 || c == 0xA || c == 0xD || c == 0x20);
+}
+
+inline void
+nsSMILParserUtils::SkipWsp(nsACString::const_iterator& aIter,
+                           const nsACString::const_iterator& aIterEnd)
+{
+  while (aIter != aIterEnd && IsSpace(*aIter))
+    ++aIter;
+}
+
+inline void
+nsSMILParserUtils::SkipWsp(nsAString::const_iterator& aIter,
+                           const nsAString::const_iterator& aIterEnd)
+{
+  while (aIter != aIterEnd && IsSpace(*aIter))
+    ++aIter;
+}
+
+inline PRFloat64
+nsSMILParserUtils::GetFloat(nsACString::const_iterator& aIter,
+                            const nsACString::const_iterator& aIterEnd,
+                            nsresult *aErrorCode)
+{
+  char *end;
+  const char *start = aIter.get();
+  PRFloat64 value = PR_strtod(start, &end);
+
+  nsresult rv = NS_OK;
+
+  if (end == start || end > aIterEnd.get())
+    rv = NS_ERROR_FAILURE;
+  else
+    aIter.advance(end - start);
+
+  if (aErrorCode)
+    *aErrorCode = rv;
+
+  return value;
+}
+
+inline PRBool
+nsSMILParserUtils::ConsumeSubstring(nsACString::const_iterator& aIter,
+                                    const nsACString::const_iterator& aIterEnd,
+                                    const char *aSubstring)
+{
+  size_t substrLen = PL_strlen(aSubstring);
+  typedef nsACString::const_iterator::difference_type diff_type;
+
+  if (aIterEnd.get() - aIter.get() < static_cast<diff_type>(substrLen))
+    return PR_FALSE;
+
+  PRBool result = PR_FALSE;
+
+  if (PL_strstr(aIter.get(), aSubstring) == aIter.get()) {
+    aIter.advance(substrLen);
+    result = PR_TRUE;
+  }
+
+  return result;
+}
+
+//------------------------------------------------------------------------------
+// Implementation
+
+nsresult
+nsSMILParserUtils::GetKeySplines(const nsAString& aSpec,
+                                 nsTArray<PRFloat64> &aSplineArray)
+{
+  nsresult rv = NS_OK;
+
+  nsCAutoString spec;
+  LossyCopyUTF16toASCII(aSpec, spec);
+
+  nsACString::const_iterator start, end;
+  spec.BeginReading(start);
+  spec.EndReading(end);
+
+  SkipWsp(start, end);
+
+  int i = 0;
+
+  while (start != end)
+  {
+    PRFloat64 value = GetFloat(start, end, &rv);
+    if (NS_FAILED(rv))
+      break;
+
+    if (value > 1.0 || value < 0.0) {
+      rv = NS_ERROR_FAILURE;
+      break;
+    }
+
+    if (!aSplineArray.AppendElement(value)) {
+      rv = NS_ERROR_OUT_OF_MEMORY;
+      break;
+    }
+
+    ++i;
+
+    SkipWsp(start, end);
+    if (start == end)
+      break;
+
+    if (i % 4) {
+      if (*start == ',')
+        ++start;
+    } else {
+      if (*start != ';') {
+        rv = NS_ERROR_FAILURE;
+        break;
+      }
+      ++start;
+    }
+
+    SkipWsp(start, end);
+  }
+
+  if (i % 4)
+    rv = NS_ERROR_FAILURE; // wrong number of points
+
+  return rv;
+}
+
+nsresult
+nsSMILParserUtils::GetKeyTimes(const nsAString& aSpec,
+                               nsTArray<PRFloat64> &aTimeArray)
+{
+  nsresult rv = NS_OK;
+
+  nsCAutoString spec;
+  LossyCopyUTF16toASCII(aSpec, spec);
+
+  nsACString::const_iterator start, end;
+  spec.BeginReading(start);
+  spec.EndReading(end);
+
+  SkipWsp(start, end);
+
+  PRFloat64 previousValue = -1.0;
+
+  while (start != end) {
+    PRFloat64 value = GetFloat(start, end, &rv);
+    if (NS_FAILED(rv))
+      break;
+
+    if (value > 1.0 || value < 0.0 || value < previousValue) {
+      rv = NS_ERROR_FAILURE;
+      break;
+    }
+
+    if (!aTimeArray.AppendElement(value)) {
+      rv = NS_ERROR_OUT_OF_MEMORY;
+      break;
+    }
+    previousValue = value;
+
+    SkipWsp(start, end);
+    if (start == end)
+      break;
+    
+    if (*start++ != ';') {
+      rv = NS_ERROR_FAILURE;
+      break;
+    }
+
+    SkipWsp(start, end);
+  }
+
+  return rv;
+}
+
+nsresult
+nsSMILParserUtils::GetValues(const nsAString& aSpec,
+                             nsTArray<nsSMILValue>& aValuesArray,
+                             nsISMILAttr& aAttribute)
+{
+  nsresult rv = NS_ERROR_FAILURE;
+  nsAString::const_iterator start;
+  nsAString::const_iterator end;
+  nsAString::const_iterator substr_end;
+  nsAString::const_iterator next;
+
+  aSpec.BeginReading(start);
+  aSpec.EndReading(end);
+
+  while (start != end) {
+    rv = NS_ERROR_FAILURE;
+
+    SkipWsp(start, end);
+
+    if (start == end || *start == ';')
+      break;
+
+    substr_end = start;
+
+    while (substr_end != end && *substr_end != ';')
+      ++substr_end;
+
+    next = substr_end;
+    if (*substr_end == ';') {
+      ++next;
+      if (next == end)
+        break;
+    }
+
+    do --substr_end; while (start != substr_end && NS_IS_SPACE(*substr_end));
+      ++substr_end;
+
+    nsSMILValue newValue;
+    rv = aAttribute.ValueFromString(Substring(start, substr_end), newValue);
+    if (NS_FAILED(rv))
+      break;
+
+    if (!aValuesArray.AppendElement(newValue)) {
+      rv = NS_ERROR_OUT_OF_MEMORY;
+      break;
+    }
+
+    rv = NS_OK;
+    start = next;
+  }
+
+  return rv;
+}
+
+nsresult
+nsSMILParserUtils::GetRepeatCount(const nsAString& aSpec,
+                                  nsSMILTimeValue& aResult)
+{
+  nsresult rv = NS_OK;
+
+  nsCAutoString spec;
+  LossyCopyUTF16toASCII(aSpec, spec);
+
+  nsACString::const_iterator start, end;
+  spec.BeginReading(start);
+  spec.EndReading(end);
+
+  SkipWsp(start, end);
+  
+  if (start != end)
+  {
+    if (ConsumeSubstring(start, end, "indefinite")) {
+      aResult.SetIndefinite();
+    } else {
+      PRFloat64 value = GetFloat(start, end, &rv);
+
+      if (NS_SUCCEEDED(rv))
+      {
+        PRInt64 count;
+        value *= 1000.0;
+
+        LL_D2L(count, value);
+
+        aResult.SetMillis(count);
+
+        if (!LL_GE_ZERO(count) || LL_IS_ZERO(count))
+          rv = NS_ERROR_FAILURE;
+      }
+    }
+
+    /* Check for trailing junk */
+    SkipWsp(start, end);
+    if (start != end)
+      rv = NS_ERROR_FAILURE;
+  } else {
+    /* Empty spec */
+    rv = NS_ERROR_FAILURE;
+  }
+
+  if (NS_FAILED(rv))
+    aResult.SetUnresolved();
+
+  return rv;
+}
+
+//
+// This method can actually parse more than a clock value as defined in the
+// SMIL Animation specification. It can also parse:
+//  - the + or - before an offset
+//  - the special value "indefinite"
+//  - the special value "media"
+//
+// Because the value "media" cannot be represented as part of an nsSMILTimeValue
+// and has different meanings depending on where it is used, it is passed out as
+// a separate parameter (which can be set to null if the media attribute is not
+// allowed).
+//
+// aResult may be NULL, e.g. to check if the string is a valid clock value
+//
+nsresult
+nsSMILParserUtils::GetClockValue(const nsAString& aSpec,
+                                 nsSMILTimeValue* aResult, 
+                                 PRBool aAllowSign,       // = false
+                                 PRBool aAllowIndefinite, // = false
+                                 PRBool aAllowMedia,      // = false
+                                 PRBool* aIsMedia)        // = nsnull
+{
+  PRInt64 offset = LL_Zero();
+  PRFloat64 component = 0.0;
+
+  PRInt8 sign = 0;
+  PRUint8 colonCount = 0;
+
+  PRBool started = PR_FALSE;
+  PRBool isValid = PR_TRUE;
+
+  PRInt32 metricMultiplicand = MSEC_PER_SEC;
+
+  PRBool numIsReal = PR_FALSE;
+  PRBool prevNumCouldBeMin = PR_FALSE;
+  PRBool numCouldBeMin = PR_FALSE;
+  PRBool numCouldBeSec = PR_FALSE;
+  PRBool isIndefinite = PR_FALSE;
+
+  if (aIsMedia)
+    *aIsMedia = PR_FALSE;
+
+  nsCAutoString spec;
+  LossyCopyUTF16toASCII(aSpec, spec);
+
+  nsACString::const_iterator start, end;
+  spec.BeginReading(start);
+  spec.EndReading(end);
+
+  while (start != end) {
+    if (IsSpace(*start)) {
+      if (started) {
+        ++start;
+        break;
+      }
+      // else, we haven't started yet, ignore initial whitespace
+      ++start;
+
+    } else if (aAllowSign && (*start == '+' || *start == '-')) {
+      if (sign != 0) {
+        // sign has already been set
+        isValid = PR_FALSE;
+        break;
+      }
+
+      if (started) {
+        // sign appears in the middle of the string
+        isValid = PR_FALSE;
+        break;
+      }
+
+      sign = (*start == '+') ? 1 : -1;
+      ++start;
+    // The NS_IS_DIGIT etc. macros are not locale-specific
+    } else if (NS_IS_DIGIT(*start)) {
+      prevNumCouldBeMin = numCouldBeMin;
+
+      if (!GetClockComponent(start, end, component, numIsReal, numCouldBeMin,
+                             numCouldBeSec)) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      started = PR_TRUE;
+    } else if (*start == ':') {
+      ++colonCount;
+
+      // Neither minutes nor hours can be reals
+      if (numIsReal) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      // Clock value can't start with a ':'
+      if (!started) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      // Can't have more than two colons
+      if (colonCount > 2) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      // Multiply the offset by 60 and add the last accumulated component
+      PRInt64 component64;
+      LL_D2L(component64, component);
+      LL_MUL(offset, offset, LL_INIT(0,60));
+      LL_ADD(offset, offset, component64);
+
+      component = 0.0l;
+      ++start;
+    } else if (NS_IS_ALPHA(*start)) {
+      if (colonCount > 0) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      if (aAllowIndefinite && ConsumeSubstring(start, end, "indefinite")) {
+        // We set a separate flag because we don't know what the state of the
+        // passed in time value is and we shouldn't change it in the case of a
+        // bad input string (so we can't initialise it to 0ms for example).
+        isIndefinite = PR_TRUE;
+        if (aResult)
+          aResult->SetIndefinite();
+      } else if (aAllowMedia && ConsumeSubstring(start, end, "media")) {
+        if (aIsMedia)
+          *aIsMedia = PR_TRUE;
+      } else if (!GetMetricMultiplicand(start, end, metricMultiplicand)) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      // Nothing must come after the string except whitespace
+      break;
+    } else {
+      isValid = PR_FALSE;
+      break;
+    }
+  }
+
+  if (!started) isValid = PR_FALSE;
+
+  // Process remainder of string (if any) to ensure it is only trailing
+  // whitespace (embedded whitespace is not allowed)
+  SkipWsp(start, end);
+  if (start != end)
+    isValid = PR_FALSE;
+
+  // No more processing required if the value was "indefinite" or "media".
+  if (isIndefinite || (aIsMedia && *aIsMedia))
+    return NS_OK;
+
+  // If there is more than one colon then the previous component must be a
+  // correctly formatted minute (i.e. two digits between 00 and 59) and the
+  // latest component must be a correctly formatted second (i.e. two digits
+  // before the .)
+  if (colonCount > 0 && (!prevNumCouldBeMin || !numCouldBeSec))
+    isValid = PR_FALSE;
+
+  if (isValid) {
+    // Tack on the last component
+    if (colonCount > 0) {
+      LL_MUL(offset, offset, LL_INIT(0,60));
+      LL_MUL(offset, offset, LL_INIT(0,1000));
+      component *= 1000;
+      // rounding
+      component = (component >= 0) ? component + 0.5l : component - 0.5l;
+      PRInt64 component64;
+      LL_D2L(component64, component);
+      LL_ADD(offset, offset, component64);
+    } else {
+      component *= metricMultiplicand;
+      // rounding
+      component = (component >= 0) ? component + 0.5l : component - 0.5l;
+      LL_D2L(offset, component);
+    }
+
+    if (aResult) {
+      PRInt64 millis = offset;
+
+      if (sign == -1)
+        LL_NEG(millis, offset);
+
+      aResult->SetMillis(millis);
+    }
+  }
+
+  return (isValid) ? NS_OK : NS_ERROR_FAILURE;
+}
+
+PRBool
+nsSMILParserUtils::GetClockComponent(nsACString::const_iterator& aSpec,
+                                     const nsACString::const_iterator& aEnd,
+                                     PRFloat64& aResult,
+                                     PRBool& aIsReal,
+                                     PRBool& aCouldBeMin,
+                                     PRBool& aCouldBeSec)
+{
+  nsresult rv;
+  char const *begin = aSpec.get();
+  PRFloat64 value = GetFloat(aSpec, aEnd, &rv);
+
+  // Check a number was found
+  if (NS_FAILED(rv))
+    return PR_FALSE;
+
+  // Check it's not expressed in exponential form
+  size_t len = aSpec.get() - begin;
+  PRBool isExp = (PL_strnpbrk(begin, "eE", len) != nsnull);
+  if (isExp)
+    return PR_FALSE;
+
+  // Don't allow real numbers of the form "23."
+  if (*(aSpec.get() - 1) == '.')
+    return PR_FALSE;
+
+  // Number looks good
+  aResult = value;
+
+  // Set some flags so we can check this number is valid once we know
+  // whether it's an hour, minute string etc.
+  aIsReal = (PL_strnchr(begin, '.', len) != nsnull);
+  aCouldBeMin = (value < 60.0l && (len == 2));
+  aCouldBeSec = (value < 60.0l ||
+      (value == 60.0l && begin[0] == '5')); // Take care of rounding error
+  aCouldBeSec &= (len >= 2 &&
+      (begin[2] == '\0' || begin[2] == '.' || IsSpace(begin[2])));
+
+  return PR_TRUE;
+}
+
+inline PRBool
+nsSMILParserUtils::GetMetricMultiplicand(nsACString::const_iterator& aSpec,
+                                         const nsACString::const_iterator& aEnd,
+                                         PRInt32& multiplicand)
+{
+  PRBool result = PR_FALSE;
+
+  size_t len = aEnd.get() - aSpec.get();
+  nsACString::const_iterator spec(aSpec);
+  
+  if (len) {
+    switch (*spec++)
+    {
+      case 'h':
+        multiplicand = MSEC_PER_HOUR;
+        result = PR_TRUE;
+        break;
+      case 'm':
+        if (len >= 2) {
+          if (*spec == 's') {
+            ++spec;
+            multiplicand = 1;
+            result = PR_TRUE;
+          } else if (len >=3 && *spec++ == 'i' && *spec++ == 'n') {
+            multiplicand = MSEC_PER_MIN;
+            result = PR_TRUE;
+          }
+        }
+        break;
+      case 's':
+        multiplicand = MSEC_PER_SEC;
+        result = PR_TRUE;
+        break;
+    }
+  }
+
+  if (result)
+    aSpec = spec;
+
+  return result;
+}
diff --git a/content/smil/src/nsSMILParserUtils.h b/content/smil/src/nsSMILParserUtils.h
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILParserUtils.h
@@ -0,0 +1,106 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILPARSERUTILS_H__
+#define __NS_SMILPARSERUTILS_H__
+
+#include "nscore.h"
+#include "nsTArray.h"
+#include "nsString.h"
+
+class nsISMILAttr;
+class nsSMILTimeValue;
+struct nsSMILValue;
+
+/**
+ * Common parsing utilities for the SMIL module. There is little re-use here, it
+ * simply serves to simplify other classes by moving parsing outside and aid
+ * unit testing.
+ */
+class nsSMILParserUtils
+{
+public:
+  static nsresult   GetKeySplines(const nsAString& aSpec,
+                                  nsTArray<PRFloat64> &aSplineArray);
+
+  static nsresult   GetKeyTimes(const nsAString& aSpec,
+                                nsTArray<PRFloat64> &aTimesArray);
+
+  static nsresult   GetValues(const nsAString& aSpec,
+                              nsTArray<nsSMILValue>& aValuesArray,
+                              nsISMILAttr& aAttribute);
+
+  static nsresult   GetRepeatCount(const nsAString& aSpec,
+                                   nsSMILTimeValue& aResult);
+
+  static nsresult   GetClockValue(const nsAString& aSpec,
+                                  nsSMILTimeValue* aResult, 
+                                  PRBool aAllowSign = false,
+                                  PRBool aAllowIndefinite = false,
+                                  PRBool aAllowMedia = false,
+                                  PRBool* aIsMedia = nsnull);
+
+
+private:
+  static void   SkipWsp(nsACString::const_iterator& aIter,
+                        const nsACString::const_iterator& aIterEnd);
+  static void   SkipWsp(nsAString::const_iterator& aIter,
+                        const nsAString::const_iterator& aIterEnd);
+  static PRFloat64 GetFloat(nsACString::const_iterator& aIter,
+                            const nsACString::const_iterator& aIterEnd,
+                            nsresult *aErrorCode = nsnull);
+  static PRBool IsSpace(const char c);
+  static PRBool IsSpace(const PRUnichar c);
+  static PRBool ConsumeSubstring(nsACString::const_iterator& aIter,
+                                 const nsACString::const_iterator& aIterEnd,
+                                 const char *aSubstring);
+  static PRBool GetClockComponent(nsACString::const_iterator& aSpec,
+                                  const nsACString::const_iterator& aEnd,
+                                  PRFloat64& aResult,
+                                  PRBool& aIsReal,
+                                  PRBool& aCouldBeMin,
+                                  PRBool& aCouldBeSec);
+  static PRBool GetMetricMultiplicand(nsACString::const_iterator& aSpec,
+                                      const nsACString::const_iterator& aEnd,
+                                      PRInt32& multiplicand);
+
+  static const PRUint32 MSEC_PER_SEC;
+  static const PRUint32 MSEC_PER_MIN;
+  static const PRUint32 MSEC_PER_HOUR;
+};
+
+#endif // __NS_SMILPARSERUTILS_H__
diff --git a/content/smil/src/nsSMILTimeValue.cpp b/content/smil/src/nsSMILTimeValue.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILTimeValue.cpp
@@ -0,0 +1,113 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILTimeValue.h"
+#include "nsDebug.h"
+
+PRInt64 nsSMILTimeValue::mUnresolvedSeconds = LL_MaxInt();
+
+//----------------------------------------------------------------------
+// Implementation
+
+// Default constructor creates an unresolved time
+nsSMILTimeValue::nsSMILTimeValue()
+  : mMilliseconds(LL_MaxInt()),
+    mIndefinite(PR_FALSE),
+    mResolved(PR_FALSE)
+{
+}
+
+//----------------------------------------------------------------------
+// nsSMILTimeValue methods:
+
+void
+nsSMILTimeValue::SetIndefinite()
+{
+  mResolved = PR_FALSE;
+  mIndefinite = PR_TRUE;
+  mMilliseconds = LL_MaxInt();
+}
+
+void
+nsSMILTimeValue::SetUnresolved()
+{
+  mResolved = PR_FALSE;
+  mIndefinite = PR_FALSE;
+  mMilliseconds = LL_MaxInt();
+}
+
+const PRInt64&
+nsSMILTimeValue::GetMillis() const
+{
+  NS_ASSERTION(mResolved, "GetMillis() called for unresolved time.");
+
+  if (!mResolved)
+      return mUnresolvedSeconds;
+
+  return mMilliseconds;
+}
+
+void
+nsSMILTimeValue::SetMillis(const PRInt64& aMillis)
+{
+  mResolved = PR_TRUE;
+  mIndefinite = PR_FALSE;
+  mMilliseconds = aMillis;
+}
+
+PRInt8
+nsSMILTimeValue::CompareTo(const nsSMILTimeValue& aOther) const
+{
+  PRInt8 result;
+
+  if (mResolved) {
+    result = (aOther.mResolved)
+           ? CmpLL(mMilliseconds, aOther.mMilliseconds)
+           : -1;
+  } else if (mIndefinite) {
+    if (aOther.mResolved)
+      result = 1;
+    else if (aOther.mIndefinite)
+      result = 0;
+    else
+      result = -1;
+  } else {
+    result = (aOther.mResolved || aOther.mIndefinite) ? 1 : 0;
+  }
+
+  return result;
+}
diff --git a/content/smil/src/nsSMILTimeValue.h b/content/smil/src/nsSMILTimeValue.h
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILTimeValue.h
@@ -0,0 +1,127 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILTIMEVALUE_H__
+#define __NS_SMILTIMEVALUE_H__
+
+#include "prtypes.h"
+#include "prlong.h"
+
+/**
+ * nsSMILTimeValue class
+ *
+ * Objects of this class may be in one of three orthogonal states:
+ *
+ * 1) The time is resolved and has a millisecond value
+ * 2) The time is indefinite
+ * 3) The time in unresolved
+ *
+ * There is considerable chance for confusion with regards to the indefinite
+ * state. Is it resolved? We adopt the convention that it is NOT resolved (but
+ * nor is it unresolved). This simplifies implementation as you can then write:
+ *
+ * if (time.IsResolved())
+ *    x = time.GetMillis()
+ *
+ * instead of:
+ *
+ * if (time.IsResolved() && !time.IsIndefinite())
+ *    x = time.GetMillis()
+ *
+ * Testing if a time is unresolved becomes more complicated but this is tested
+ * much less often.
+ *
+ * In summary:
+ *
+ * State         |  GetMillis         |  IsResolved        |  IsIndefinite
+ * --------------+--------------------+--------------------+-------------------
+ * Resolved      |  The millisecond   |  PR_TRUE           |  PR_FALSE
+ *               |  time              |                    |
+ * --------------+--------------------+--------------------+-------------------
+ * Indefinite    |  LL_MaxInt         |  PR_FALSE          |  PR_TRUE
+ * --------------+--------------------+--------------------+-------------------
+ * Unresolved    |  LL_MaxInt         |  PR_FALSE          |  PR_FALSE
+ *
+ */
+
+class nsSMILTimeValue
+{
+public:
+  // Creates an unresolved time value
+  nsSMILTimeValue();
+
+  PRBool            IsIndefinite() const;
+  void              SetIndefinite();
+
+  PRBool            IsResolved() const;
+  void              SetUnresolved();
+
+  const PRInt64&    GetMillis() const;
+  void              SetMillis(const PRInt64& aMillis);
+
+  PRInt8            CompareTo(const nsSMILTimeValue& aOther) const;
+
+private:
+  PRInt8            CmpLL(const PRInt64& a, const PRInt64& b) const;
+
+  static PRInt64    mUnresolvedSeconds;
+
+  PRInt64           mMilliseconds;
+  PRBool            mIndefinite;
+  PRBool            mResolved;
+};
+
+inline PRBool
+nsSMILTimeValue::IsIndefinite() const
+{
+  return mIndefinite;
+}
+
+inline PRBool
+nsSMILTimeValue::IsResolved() const
+{
+  return mResolved;
+}
+
+// A signed comparison of two signed 64-bit integers
+inline PRInt8
+nsSMILTimeValue::CmpLL(const PRInt64& a, const PRInt64& b) const
+{
+  return (LL_EQ(a, b)) ? 0 : (LL_CMP(a, >, b)) ? 1 : -1;
+}
+
+#endif // __NS_SMILTIMEVALUE_H__
diff --git a/content/smil/src/nsSMILTimeValueSpec.cpp b/content/smil/src/nsSMILTimeValueSpec.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILTimeValueSpec.cpp
@@ -0,0 +1,113 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILTimeValueSpec.h"
+#include "nsSMILTimeValue.h"
+#include "nsSMILInstanceTime.h"
+#include "nsSMILParserUtils.h"
+#include "nsString.h"
+#include "nsAutoPtr.h"
+
+//----------------------------------------------------------------------
+// Implementation
+
+already_AddRefed<nsSMILTimeValueSpec>
+NS_NewSMILTimeValueSpec(nsISMILTimedElement* aOwner,
+                        PRBool aIsBegin,
+                        const nsAString& aStringSpec)
+{
+  nsSMILTimeValueSpec* result = new nsSMILTimeValueSpec(aOwner, aIsBegin);
+  NS_ENSURE_TRUE(result, nsnull);
+
+  NS_ADDREF(result); // Need to addref as SetSpec calls getWeakReference
+  nsresult rv = result->SetSpec(aStringSpec);
+  if (NS_FAILED(rv)) {
+    NS_RELEASE(result);
+    return nsnull;
+  }
+  return result;
+}
+
+nsSMILTimeValueSpec::nsSMILTimeValueSpec(nsISMILTimedElement* aOwner,
+                                         PRBool aIsBegin)
+  : mIsBegin(aIsBegin),
+    mOffset() // initalises to zero
+{
+  if (aOwner)
+    mOwner = do_GetWeakReference(aOwner);
+}
+
+//----------------------------------------------------------------------
+// nsISupports
+
+NS_IMPL_ISUPPORTS2(nsSMILTimeValueSpec,
+                   nsSMILTimeValueSpec,
+                   nsISupportsWeakReference)
+
+//----------------------------------------------------------------------
+// nsSMILTimeValueSpec
+
+nsresult
+nsSMILTimeValueSpec::SetSpec(const nsAString& aStringSpec)
+{
+  // XXX Need to parse other specifiers, not just offset type
+  nsSMILTimeValue clockTime;
+  nsresult rv = 
+    nsSMILParserUtils::GetClockValue(aStringSpec,
+                                     &clockTime,
+                                     true,  // allow + or -
+                                     true); // allow 'indefinite'
+
+  if (NS_FAILED(rv) || (!clockTime.IsResolved() && !clockTime.IsIndefinite()))
+    return NS_ERROR_FAILURE;
+  
+  if (clockTime.IsResolved())
+    mOffset = clockTime.GetMillis();
+  
+  if (mOwner) {
+    nsSMILInstanceTime *instance = new nsSMILInstanceTime(clockTime, this);
+    NS_ENSURE_TRUE(instance, NS_ERROR_OUT_OF_MEMORY);
+
+    nsCOMPtr<nsISMILTimedElement> owner = do_QueryReferent(mOwner);
+    NS_ENSURE_TRUE(owner, NS_ERROR_FAILURE);
+
+    owner->AddInstanceTime(*instance, mIsBegin);
+    delete instance;
+  }
+
+  return rv;
+}
diff --git a/content/smil/src/nsSMILTimeValueSpec.h b/content/smil/src/nsSMILTimeValueSpec.h
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILTimeValueSpec.h
@@ -0,0 +1,86 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILTIMEVALUESPEC_H__
+#define __NS_SMILTIMEVALUESPEC_H__
+
+#include "nsISupports.h"
+#include "nsWeakReference.h"
+#include "nsISMILTimedElement.h"
+
+class nsAString;
+class nsSMILTimeValue;
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILTimeValueSpec class
+
+// {39d2f376-6bda-42c0-8510-a93b24828a80}
+#define NS_SMILTIMEVALUESPEC_IID \
+{ 0x39d2f376, 0x6bda, 0x42c0, { 0x85, 0x10, 0xa9, 0x3b, 0x24, 0x82, 0x8a, 0x80 } }
+
+class nsSMILTimeValueSpec : public nsSupportsWeakReference
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_SMILTIMEVALUESPEC_IID)
+  NS_DECL_ISUPPORTS
+
+protected:
+  nsSMILTimeValueSpec(nsISMILTimedElement* aOwner, PRBool aIsBegin);
+
+  friend already_AddRefed<nsSMILTimeValueSpec>
+  NS_NewSMILTimeValueSpec(nsISMILTimedElement* aOwner,
+                          PRBool aIsBegin,
+                          const nsAString& aStringSpec);
+
+  nsresult      SetSpec(const nsAString& aStringSpec);
+
+  nsWeakPtr mOwner;
+  PRBool    mIsBegin;
+  PRInt64   mOffset;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsSMILTimeValueSpec, NS_SMILTIMEVALUESPEC_IID)
+
+////////////////////////////////////////////////////////////////////////
+// Factory methods
+
+already_AddRefed<nsSMILTimeValueSpec>
+NS_NewSMILTimeValueSpec(nsISMILTimedElement* aOwner,
+                        PRBool aIsBegin,
+                        const nsAString& aStringSpec);
+
+#endif // __NS_SMILTIMEVALUESPEC_H__
diff --git a/content/smil/src/nsSMILTimedDocumentRoot.cpp b/content/smil/src/nsSMILTimedDocumentRoot.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILTimedDocumentRoot.cpp
@@ -0,0 +1,296 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILTimedDocumentRoot.h"
+#include "nsSMILTimeValue.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILTimedDocumentRoot implementation
+
+nsSMILTimedDocumentRoot::nsSMILTimedDocumentRoot(
+    nsSMILAnimationRegistry* registry)
+:
+  mStartTime(),
+  mAccumulatedOffset(),
+  mAnimationRegistry(registry),
+  mParentPaused(PR_FALSE),
+  mContainerPaused(PR_FALSE),
+  mNeedsSampleDuringPause(PR_FALSE)
+{
+}
+
+//----------------------------------------------------------------------
+// nsISupports methods:
+
+NS_IMPL_ISUPPORTS2(nsSMILTimedDocumentRoot,
+                   nsISMILTimeContainer,
+                   nsISupportsWeakReference)
+
+//----------------------------------------------------------------------
+// nsSMILTimedDocumentRoot methods
+
+PRInt64
+nsSMILTimedDocumentRoot::GetDocumentTime()
+{
+  if (LL_IS_ZERO(mStartTime))
+    return LL_Zero();
+
+  PRInt64 now;
+  LL_DIV(now, PR_Now(), PR_USEC_PER_MSEC);
+  
+  PRInt64 currentTime = (mParentPaused || mContainerPaused)
+                      ? mPauseStart
+                      : now;
+
+  PRInt64 timeSinceStart;
+  LL_SUB(timeSinceStart, currentTime, mStartTime);
+
+  PRInt64 adjustedTime;
+  LL_SUB(adjustedTime, timeSinceStart, mAccumulatedOffset);
+
+  return adjustedTime;
+}
+
+nsSMILTimeValue
+nsSMILTimedDocumentRoot::WallclockToDocumentTime(nsISMILTimeValueSpec*
+                                                   aWallclockSpec)
+{
+  // XXX
+  (void)aWallclockSpec;
+  NS_NOTYETIMPLEMENTED("nsSMILTimedDocumentRoot::WallclockToDocumentTime");
+  return nsSMILTimeValue();
+}
+
+nsresult
+nsSMILTimedDocumentRoot::SeekToTime(PRInt64 aSeekTo)
+{
+  PRInt64 now;
+  LL_DIV(now, PR_Now(), PR_USEC_PER_MSEC);
+  LL_SUB(mStartTime, now, aSeekTo);
+  mAccumulatedOffset = LL_Zero();
+  if (mParentPaused || mContainerPaused) {
+    // Update mPauseStart to be now (= mStartTime + aSeekTo)
+    // and request a sample
+    mPauseStart = now;
+    mNeedsSampleDuringPause = PR_TRUE;
+  }
+  
+  ResetChildren(PR_FALSE);
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// nsISMILTimeContainer methods
+
+nsresult
+nsSMILTimedDocumentRoot::Pause()
+{
+  if (!mContainerPaused && !mParentPaused) {
+    LL_DIV(mPauseStart, PR_Now(), PR_USEC_PER_MSEC);
+    mNeedsSampleDuringPause = PR_TRUE; // request one more sample after pause
+  }
+
+  mContainerPaused = PR_TRUE;
+  return NS_OK;
+}
+
+nsresult
+nsSMILTimedDocumentRoot::Resume()
+{
+  if (mContainerPaused && !mParentPaused) {
+    PRInt64 extraOffset;
+    PRInt64 now;
+    LL_DIV(now, PR_Now(), PR_USEC_PER_MSEC);
+    LL_SUB(extraOffset, now, mPauseStart);
+    LL_ADD(mAccumulatedOffset, extraOffset, mAccumulatedOffset);
+    mNeedsSampleDuringPause = PR_FALSE; // XXXdholbert probably unnecessary
+  }
+  mContainerPaused = PR_FALSE;
+  return NS_OK;
+}
+
+PRBool
+nsSMILTimedDocumentRoot::IsPaused()
+{
+  return mContainerPaused;
+}
+
+nsresult
+nsSMILTimedDocumentRoot::HandleParentPaused()
+{
+  if (!mContainerPaused && !mParentPaused) {
+    LL_DIV(mPauseStart, PR_Now(), PR_USEC_PER_MSEC);
+    mNeedsSampleDuringPause = PR_TRUE;
+  }
+  mParentPaused = PR_TRUE;
+  return NS_OK;
+}
+
+nsresult
+nsSMILTimedDocumentRoot::HandleParentResumed()
+{
+  if (!mContainerPaused && mParentPaused) {
+    PRInt64 extraOffset;
+    PRInt64 now;
+    LL_DIV(now, PR_Now(), PR_USEC_PER_MSEC);
+    LL_SUB(extraOffset, now, mPauseStart);
+    LL_ADD(mAccumulatedOffset, extraOffset, mAccumulatedOffset);
+  }
+  mParentPaused = PR_FALSE;
+  return NS_OK;
+}
+
+nsresult
+nsSMILTimedDocumentRoot::Reset()
+{
+  mStartTime = LL_Zero();
+  mAccumulatedOffset = LL_Zero();
+  mParentPaused = PR_FALSE;
+  mContainerPaused = PR_FALSE;
+  mNeedsSampleDuringPause = PR_FALSE;
+  ResetChildren(PR_TRUE);
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedDocumentRoot::Sample()
+{
+  PRInt64 now;
+  if (mParentPaused || mContainerPaused) {
+    if (mNeedsSampleDuringPause) {
+      // Perform requested sample, for pause-start-time
+      now = mPauseStart;
+      mNeedsSampleDuringPause = PR_FALSE;
+    } else {
+      // Paused, and don't need a sample.  Nothing to do.
+      return;
+    }
+  } else {
+    // Not paused -- need a sample at time = now.
+    LL_DIV(now, PR_Now(), PR_USEC_PER_MSEC);
+  }
+
+  // If this is the first time, record the document begin time
+  // and clear any accumulated offset.
+  if (LL_IS_ZERO(mStartTime)) {
+    mStartTime = now;
+    mAccumulatedOffset = LL_Zero();
+  }
+  
+  PRInt64 instant;
+  LL_SUB(instant, now, mStartTime);
+  LL_SUB(instant, instant, mAccumulatedOffset);
+
+  if (mAnimationRegistry)
+    mAnimationRegistry->StartSample();
+
+  SampleChildren(instant);
+
+  if (mAnimationRegistry)
+    mAnimationRegistry->EndSample();
+}
+
+nsresult
+nsSMILTimedDocumentRoot::AddTimedElement(nsISMILTimedElement* aElement)
+{
+  NS_ENSURE_ARG_POINTER(aElement);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aElement, &rv)) );
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  rv = (mTimedElements.AppendObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+
+  aElement->SetDocumentRoot(this);
+
+  return rv;
+}
+
+nsresult
+nsSMILTimedDocumentRoot::RemoveTimedElement(nsISMILTimedElement* aElement)
+{
+  NS_ENSURE_ARG_POINTER(aElement);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aElement, &rv)) );
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  rv = (mTimedElements.RemoveObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+
+  aElement->SetDocumentRoot(nsnull);
+
+  return rv;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers:
+
+void
+nsSMILTimedDocumentRoot::SampleChildren(PRInt64 aDocumentTime)
+{
+  PRUint32 i = mTimedElements.Count();
+  while (i > 0) {
+    --i;
+    nsCOMPtr<nsISMILTimedElement> 
+      element( do_QueryReferent(mTimedElements[i]) );
+
+    if (element)
+      element->SampleAt(aDocumentTime);
+    else
+      mTimedElements.RemoveObjectAt(i);
+  }
+}
+
+void
+nsSMILTimedDocumentRoot::ResetChildren(PRBool aHardReset)
+{
+  PRUint32 i = mTimedElements.Count();
+  while (i > 0) {
+    --i;
+    nsCOMPtr<nsISMILTimedElement> 
+      element( do_QueryReferent(mTimedElements[i]) );
+
+    if (element)
+      element->Reset(aHardReset);
+    else
+      mTimedElements.RemoveObjectAt(i);
+  }
+}
diff --git a/content/smil/src/nsSMILTimedDocumentRoot.h b/content/smil/src/nsSMILTimedDocumentRoot.h
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILTimedDocumentRoot.h
@@ -0,0 +1,93 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILTIMEDDOCUMENTROOT_H__
+#define __NS_SMILTIMEDDOCUMENTROOT_H__
+
+#include "nsISupports.h"
+#include "nsISMILTimeContainer.h"
+#include "nsSMILAnimationRegistry.h"
+#include "nsWeakReference.h"
+#include "nsCOMArray.h"
+
+class nsISMILTimeValueSpec;
+class nsISMILTimedElement;
+class nsSMILTimeValue;
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILTimedDocumentRoot: Timed document root
+
+class nsSMILTimedDocumentRoot : public nsISMILTimeContainer,
+                                public nsSupportsWeakReference
+{
+public:
+  nsSMILTimedDocumentRoot(nsSMILAnimationRegistry* registry);
+
+  NS_DECL_ISUPPORTS
+
+  PRInt64           GetDocumentTime();
+  nsSMILTimeValue   WallclockToDocumentTime(nsISMILTimeValueSpec*
+                                              aWallclockSpec);
+  nsresult          SeekToTime(PRInt64 aSeekTo);
+
+  // nsISMILTimeContainer
+  virtual PRBool    IsPaused();
+  virtual nsresult  Pause();
+  virtual nsresult  Resume();
+  virtual nsresult  HandleParentPaused();
+  virtual nsresult  HandleParentResumed();
+  virtual nsresult  Reset();
+  virtual void      Sample();
+  virtual nsresult  AddTimedElement(nsISMILTimedElement* aElement);
+  virtual nsresult  RemoveTimedElement(nsISMILTimedElement* aElement);
+
+protected:
+  void              SampleChildren(PRInt64 aDocumentTime);
+  void              ResetChildren(PRBool aHardReset);
+
+  PRInt64                       mStartTime;
+  PRInt64                       mAccumulatedOffset;
+  nsCOMArray<nsIWeakReference>  mTimedElements;
+  nsSMILAnimationRegistry*      mAnimationRegistry;
+  PRBool                        mParentPaused;
+  PRBool                        mContainerPaused;
+  PRInt64                       mPauseStart;
+  // Should generally update whenever mPauseStart is updated
+  PRBool                        mNeedsSampleDuringPause;
+};
+
+#endif // __NS_SMILTIMEDDOCUMENTROOT_H__
diff --git a/content/smil/src/nsSMILTimedElement.cpp b/content/smil/src/nsSMILTimedElement.cpp
new file mode 100644
--- /dev/null
+++ b/content/smil/src/nsSMILTimedElement.cpp
@@ -0,0 +1,1274 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISMILTimedElement.h"
+#include "nsIDOMElementTimeControl.h"
+#include "nsWeakReference.h"
+#include "nsSMILTimeValue.h"
+#include "nsSMILTimeValueSpec.h"
+#include "nsSMILInstanceTime.h"
+#include "nsSMILInterval.h"
+#include "nsISMILTimeClient.h"
+#include "nsSMILEnum.h"
+#include "nsSMILParserUtils.h"
+#include "nsSMILTimedDocumentRoot.h"
+#include "nsGkAtoms.h"
+#include "nsCOMArray.h"
+#include "nsReadableUtils.h"
+#include "nsAutoPtr.h"
+#include "prdtoa.h"
+#include "plstr.h"
+#include "nsString.h"
+
+// handy typedefs
+typedef nsTArray<nsRefPtr<nsSMILInterval> >       SMILIntervalList;
+typedef nsTArray<nsRefPtr<nsSMILTimeValueSpec> >  SMILTimeValueSpecList;
+
+//----------------------------------------------------------------------
+// Class declaration
+
+class nsSMILTimedElement : public nsISMILTimedElement,
+                           public nsIDOMElementTimeControl,
+                           public nsSupportsWeakReference
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIDOMELEMENTTIMECONTROL
+
+  // nsISMILTimedElement
+  virtual void      AddInstanceTime(const nsSMILInstanceTime& aInstanceTime,
+                                    PRBool aIsBegin);
+  virtual void      SetDocumentRoot(nsSMILTimedDocumentRoot* aRoot);
+  virtual void      SetTimeClient(nsISMILTimeClient* aClient);
+  virtual void      SampleAt(const PRInt64& aDocumentTime);
+  virtual void      Reset(PRBool aHardReset = PR_FALSE);
+  virtual PRBool    SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                            nsresult* aResult);
+  virtual PRBool    UnsetAttr(nsIAtom* aAttribute);
+
+protected:
+  nsSMILTimedElement();
+  nsresult          Init();
+
+  friend nsISMILTimedElement* NS_NewSMILTimedElement();
+
+  //
+  // Implementation helpers
+  //
+
+  nsresult          SetBeginSpec(const nsAString& aBeginSpec);
+  nsresult          SetEndSpec(const nsAString& aEndSpec);
+  nsresult          SetSimpleDuration(const nsAString& aDurSpec);
+  nsresult          SetMin(const nsAString& aMinSpec);
+  nsresult          SetMax(const nsAString& aMaxSpec);
+  nsresult          SetRestart(const nsAString& aRestartSpec);
+  nsresult          SetRepeatCount(const nsAString& aRepeatCountSpec);
+  nsresult          SetRepeatDur(const nsAString& aRepeatDurSpec);
+  nsresult          SetFillMode(const nsAString& aFillModeSpec);
+
+  void              UnsetBeginSpec();
+  void              UnsetEndSpec();
+  void              UnsetSimpleDuration();
+  void              UnsetMin();
+  void              UnsetMax();
+  void              UnsetRestart();
+  void              UnsetRepeatCount();
+  void              UnsetRepeatDur();
+  void              UnsetFillMode();
+
+  nsresult          SetBeginOrEndSpec(const nsAString& aSpec, PRBool aIsBegin);
+
+  /**
+   * Calculates the first acceptable interval for this element.
+   *
+   * @see SMILANIM 3.6.8
+   */
+  nsresult          GetNextInterval(const nsSMILTimeValue& aBeginAfter,
+                                  PRBool aFirstInstance,
+                                  nsSMILInterval& aResult);
+
+  PRBool            GetNextGreater(const nsTArray<nsSMILInstanceTime>& aList,
+                                   const nsSMILTimeValue& aBase,
+                                   PRInt32& aPosition,
+                                   nsSMILTimeValue& aResult);
+  nsSMILTimeValue   CalcActiveEnd(const nsSMILTimeValue& aBegin,
+                                  const nsSMILTimeValue& aEnd);
+  nsSMILTimeValue   GetRepeatDuration();
+  nsSMILTimeValue   ApplyMinAndMax(const nsSMILTimeValue& aDuration);
+  PRInt64           ActiveTimeToSimpleTime(const PRInt64& aActiveTime,
+                                           PRUint32& aRepeatIteration);
+  void              CheckForEarlyEnd(const nsSMILTimeValue &aDocumentTime);
+  void              UpdateCurrentInterval();
+  void              SampleSimpleTime(PRInt64 aActiveTime);
+  void              SampleFillValue();
+  PRInt64           MinLL(const PRInt64& a, const PRInt64& b);
+
+  //
+  // Members
+  //
+  SMILTimeValueSpecList mBeginSpecs;
+  SMILTimeValueSpecList mEndSpecs;
+
+  //
+  // We need to distinguish between attempting to set the begin spec and failing
+  // (in which case the mBeginSpecs array will be empty) and not attempting to
+  // set the begin spec at all. In the first case, we should act as if the begin
+  // was indefinite, and in the second, we should act as if begin was 0s.
+  //
+  PRBool                          mBeginSpecSet;
+
+  nsSMILTimeValue                 mSimpleDur;
+
+  /**
+   * The number of iterations of the animation function. We use an
+   * nsSMILTimeValue type where:
+   *
+   * milliseconds = the number of iterations * 1000,
+   * indefinite   = repeating indefinitely, until the document ends, and
+   * unresolved   = the attribute is not set, therefore no repeating.
+   */
+  nsSMILTimeValue                 mRepeatCount;
+  nsSMILTimeValue                 mRepeatDur;
+
+  nsSMILTimeValue                 mMin;
+  nsSMILTimeValue                 mMax;
+
+  enum nsSMILFillMode
+  {
+    fill_remove,
+    fill_freeze
+  };
+  static nsSMILEnumMapping        sFillModeMap[];
+  nsSMILEnum                      mFillMode;
+
+  enum nsSMILRestartMode
+  {
+    restart_always,
+    restart_whennotactive,
+    restart_never
+  };
+  static nsSMILEnumMapping        sRestartModeMap[];
+  nsSMILEnum                      mRestartMode;
+
+  PRBool                          mEndHasEventConditions;
+
+  nsTArray<nsSMILInstanceTime>    mBeginInstances;
+  nsTArray<nsSMILInstanceTime>    mEndInstances;
+
+  nsCOMPtr<nsISMILTimeClient>     mClient;
+  nsRefPtr<nsSMILInterval>        mCurrentInterval;
+  SMILIntervalList                mOldIntervals;
+  nsRefPtr<nsSMILTimedDocumentRoot> mDocumentRoot;
+
+  /**
+   * The state of the element in its life-cycle. These states are based on the
+   * element life-cycle described in SMILANIM 3.6.8
+   */
+  enum nsSMILElementState
+  {
+    state_startup,
+    state_waiting,
+    state_active,
+    state_postactive
+  };
+  nsSMILElementState              mElementState;
+};
+
+//----------------------------------------------------------------------
+// Static members
+
+nsSMILEnumMapping nsSMILTimedElement::sFillModeMap[] = {
+      {&nsGkAtoms::remove, fill_remove},
+      {&nsGkAtoms::freeze, fill_freeze},
+      {nsnull, 0}
+};
+
+nsSMILEnumMapping nsSMILTimedElement::sRestartModeMap[] = {
+      {&nsGkAtoms::always, restart_always},
+      {&nsGkAtoms::whennotactive, restart_whennotactive},
+      {&nsGkAtoms::never, restart_never},
+      {nsnull, 0}
+};
+
+//----------------------------------------------------------------------
+// Factory method
+
+nsISMILTimedElement* NS_NewSMILTimedElement()
+{
+  nsSMILTimedElement* element = new nsSMILTimedElement();
+
+  if (element && NS_FAILED(element->Init())) {
+      delete element;
+      return nsnull;
+  }
+
+  return element;
+}
+
+//----------------------------------------------------------------------
+// Ctor, dtor
+
+nsSMILTimedElement::nsSMILTimedElement()
+:
+  mBeginSpecs(),
+  mEndSpecs(),
+  mBeginSpecSet(PR_FALSE),
+  mFillMode(fill_remove, sFillModeMap),
+  mRestartMode(restart_always, sRestartModeMap),
+  mEndHasEventConditions(PR_FALSE),
+  mElementState(state_startup)
+{
+  mSimpleDur.SetIndefinite();
+  mMin.SetMillis(LL_Zero());
+  mMax.SetIndefinite();
+}
+
+nsresult
+nsSMILTimedElement::Init()
+{
+  mCurrentInterval = new nsSMILInterval();
+
+  return (mCurrentInterval) ? NS_OK : NS_ERROR_FAILURE;
+}
+
+//----------------------------------------------------------------------
+// nsISupports
+
+NS_IMPL_ISUPPORTS3(nsSMILTimedElement,
+                   nsISMILTimedElement,
+                   nsIDOMElementTimeControl,
+                   nsISupportsWeakReference)
+
+//----------------------------------------------------------------------
+// nsIDOMElementTimeControl methods
+//
+// The definition of the ElementTimeControl interface differs between SMIL
+// Animation and SVG 1.1. In SMIL Animation all methods have a void return
+// type and the new instance time is simply added to the list and restart
+// semantics are applied as with any other instance time. In the SVG definition
+// the methods return a bool depending on the restart mode. There are some
+// cases where this is problematic.
+//
+// For example, if a call is made to beginElementAt and the resolved time
+// after including the offset falls outside the current interval then using
+// the SMIL Animation definition an element with restart == whenNotActive
+// would restart with this new instance time. The SVG definition however seems
+// to imply that in this case the implementation should ignore the new
+// instance time if the restart mode == whenNotActive and the element is
+// currently active and return false.
+//
+// It is tempting to try and determine when a new instance time will actually
+// cause a restart but this is not possible as in the meantime a new event may
+// trump the new instance time. We take a compromise of returning true and
+// false according to the SVG definition but adding the instance time to the
+// list regardless. This may produce different results to an implementation that
+// follows strictly the behaviour implied by the SVG spec.
+//
+
+/* boolean beginElement (); */
+NS_IMETHODIMP
+nsSMILTimedElement::BeginElement(PRBool *_retval)
+{
+  return BeginElementAt(0.0, _retval);
+}
+
+// XXXdholbert share code with EndElementAt?
+/* boolean beginElementAt (in float offset); */
+NS_IMETHODIMP
+nsSMILTimedElement::BeginElementAt(float offset, PRBool *_retval)
+{
+  // If restart == never or restart == whenNotActive, check whether we're
+  // in a state that allows us to restart.
+  if ((mRestartMode.GetIntegerValue() == restart_never &&
+       (mElementState == state_active || mElementState == state_postactive)) ||
+      (mRestartMode.GetIntegerValue() == restart_whennotactive &&
+       mElementState == state_active)) {
+    *_retval = PR_FALSE;
+    return NS_OK;
+  }
+
+  if (!mDocumentRoot) {
+    *_retval = PR_FALSE;
+    NS_ERROR("Attempting to begin but there is no document root.");
+    return NS_ERROR_FAILURE;
+  }
+
+  PRInt64 offsetVal;
+  LL_D2L(offsetVal, offset);
+  PRInt64 timeWithOffset;
+  LL_ADD(timeWithOffset, mDocumentRoot->GetDocumentTime(), offsetVal);
+  nsSMILTimeValue timeVal;
+  timeVal.SetMillis(timeWithOffset);
+
+  nsSMILInstanceTime *instanceTime = 
+    new nsSMILInstanceTime(timeVal, nsnull, PR_TRUE);
+  NS_ENSURE_TRUE(instanceTime, NS_ERROR_OUT_OF_MEMORY);
+  AddInstanceTime(*instanceTime, PR_TRUE);
+  delete instanceTime;
+
+  *_retval = PR_TRUE;
+  return NS_OK;
+}
+
+/* boolean endElement (); */
+NS_IMETHODIMP
+nsSMILTimedElement::EndElement(PRBool *_retval)
+{
+  return EndElementAt(0.0, _retval);
+}
+
+/* boolean endElementAt (in float offset); */
+NS_IMETHODIMP
+nsSMILTimedElement::EndElementAt(float offset, PRBool *_retval)
+{
+  if (mElementState != state_active)
+    *_retval = PR_FALSE;
+
+  if (!mDocumentRoot) {
+    *_retval = PR_FALSE;
+    NS_ERROR("Attempting to end but there is no document root.");
+    return NS_ERROR_FAILURE;
+  }
+
+  PRInt64 offsetVal;
+  LL_D2L(offsetVal, offset);
+  PRInt64 timeWithOffset;
+  LL_ADD(timeWithOffset, mDocumentRoot->GetDocumentTime(), offsetVal);
+  nsSMILTimeValue timeVal;
+  timeVal.SetMillis(timeWithOffset);
+
+  nsSMILInstanceTime *instanceTime = 
+    new nsSMILInstanceTime(timeVal, nsnull, PR_TRUE);
+  NS_ENSURE_TRUE(instanceTime, NS_ERROR_OUT_OF_MEMORY);
+  AddInstanceTime(*instanceTime, PR_FALSE);
+  delete instanceTime;
+
+  *_retval = PR_TRUE;
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// nsISMILTimedElement
+
+void
+nsSMILTimedElement::AddInstanceTime(const nsSMILInstanceTime& aInstanceTime,
+                                    PRBool aIsBegin)
+{
+  if (aIsBegin)
+    mBeginInstances.AppendElement(aInstanceTime);
+  else
+    mEndInstances.AppendElement(aInstanceTime);
+
+  UpdateCurrentInterval();
+}
+
+void
+nsSMILTimedElement::SetDocumentRoot(nsSMILTimedDocumentRoot* aRoot)
+{
+  mDocumentRoot = aRoot;
+}
+
+void
+nsSMILTimedElement::SetTimeClient(nsISMILTimeClient* aClient)
+{
+  //
+  // No need to check for NULL. A NULL parameter simply means to remove the
+  // previous client which we do by setting to NULL anyway.
+  //
+
+  mClient = aClient;
+}
+
+void
+nsSMILTimedElement::SampleAt(const PRInt64& aDocumentTime)
+{
+  PRBool          stateChanged;
+  nsSMILTimeValue docTime;
+  docTime.SetMillis(aDocumentTime);
+
+  // XXX Cache previous sample time and if this time is less then perform
+  // backwards seeking behaviour (see SMILANIM 3.6.5 Hyperlinks and timing)
+
+  do {
+    stateChanged = false;
+
+    switch (mElementState)
+    {
+    case state_startup:
+      {
+        nsSMILTimeValue beginAfter;
+        beginAfter.SetMillis(LL_MININT);
+
+        mElementState = 
+          (NS_SUCCEEDED(GetNextInterval(beginAfter, true, *mCurrentInterval)))
+          ? state_waiting
+          : state_postactive;
+        stateChanged = true;
+      }
+      break;
+
+    case state_waiting:
+      {
+        if (mCurrentInterval->Begin().CompareTo(docTime) <= 0) {
+          mElementState = state_active;
+          if (mClient) {
+            mClient->Activate(mCurrentInterval->Begin().GetMillis());
+          }
+          stateChanged = true;
+        }
+      }
+      break;
+
+    case state_active:
+      {
+        CheckForEarlyEnd(docTime);
+        if (mCurrentInterval->End().CompareTo(docTime) <= 0) {
+          nsRefPtr<nsSMILInterval> newInterval(new nsSMILInterval());
+          mElementState = 
+            (NS_SUCCEEDED(GetNextInterval(mCurrentInterval->End(),
+                                          false,
+                                          *newInterval)))
+            ? state_waiting
+            : state_postactive;
+          if (mClient) {
+            mClient->Inactivate(mFillMode.GetIntegerValue() == fill_freeze);
+          }
+          SampleFillValue();
+          mOldIntervals.AppendElement(mCurrentInterval);
+          mCurrentInterval = newInterval;
+          Reset();
+          stateChanged = true;
+        } else {
+          PRInt64 beginTime = mCurrentInterval->Begin().GetMillis();
+
+          PRInt64 activeTime;
+          LL_SUB(activeTime, aDocumentTime, beginTime);
+
+          SampleSimpleTime(activeTime);
+        }
+      }
+      break;
+
+    case state_postactive:
+      break;
+    }
+  } while (stateChanged);
+}
+
+void
+nsSMILTimedElement::Reset(PRBool aHardReset /* = PR_FALSE */)
+{
+  PRInt32 count = mBeginInstances.Length();
+
+  for (PRInt32 i = 0; i < count; ++i) {
+    nsSMILInstanceTime &instance = mBeginInstances[0];
+    if (instance.ClearOnReset()) {
+      mBeginInstances.RemoveElementAt(0);
+    }
+  }
+
+  count = mEndInstances.Length();
+
+  for (PRInt32 j = 0; j < count; ++j) {
+    nsSMILInstanceTime &instance = mEndInstances[0];
+    if (instance.ClearOnReset()) {
+      mEndInstances.RemoveElementAt(0);
+    }
+  }
+
+  if (aHardReset) {
+    mCurrentInterval = new nsSMILInterval();
+    mElementState    = state_startup;
+    mOldIntervals.Clear();
+
+    // Remove any fill
+    if (mClient) {
+      mClient->Inactivate(PR_FALSE);
+    }
+  }
+}
+
+PRBool
+nsSMILTimedElement::SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                            nsresult* aResult)
+{
+  PRBool rv = PR_TRUE;
+  nsresult result = NS_OK;
+
+  if (aAttribute == nsGkAtoms::begin) {
+    result = SetBeginSpec(aValue);
+  } else if (aAttribute == nsGkAtoms::dur) {
+    result = SetSimpleDuration(aValue);
+  } else if (aAttribute == nsGkAtoms::end) {
+    result = SetEndSpec(aValue);
+  } else if (aAttribute == nsGkAtoms::fill) {
+    result = SetFillMode(aValue);
+  } else if (aAttribute == nsGkAtoms::max) {
+    result = SetMax(aValue);
+  } else if (aAttribute == nsGkAtoms::min) {
+    result = SetMin(aValue);
+  } else if (aAttribute == nsGkAtoms::repeatCount) {
+    result = SetRepeatCount(aValue);
+  } else if (aAttribute == nsGkAtoms::repeatDur) {
+    result = SetRepeatDur(aValue);
+  } else if (aAttribute == nsGkAtoms::restart) {
+    result = SetRestart(aValue);
+  } else {
+    rv = PR_FALSE;
+  }
+
+  if (rv && aResult) {
+    *aResult = result;
+  }
+
+  return rv;
+}
+
+PRBool
+nsSMILTimedElement::UnsetAttr(nsIAtom* aAttribute)
+{
+  PRBool rv = PR_TRUE;
+
+  if (aAttribute == nsGkAtoms::begin) {
+    UnsetBeginSpec();
+  } else if (aAttribute == nsGkAtoms::dur) {
+    UnsetSimpleDuration();
+  } else if (aAttribute == nsGkAtoms::end) {
+    UnsetEndSpec();
+  } else if (aAttribute == nsGkAtoms::fill) {
+    UnsetFillMode();
+  } else if (aAttribute == nsGkAtoms::max) {
+    UnsetMax();
+  } else if (aAttribute == nsGkAtoms::min) {
+    UnsetMin();
+  } else if (aAttribute == nsGkAtoms::repeatCount) {
+    UnsetRepeatCount();
+  } else if (aAttribute == nsGkAtoms::repeatDur) {
+    UnsetRepeatDur();
+  } else if (aAttribute == nsGkAtoms::restart) {
+    UnsetRestart();
+  } else {
+    rv = PR_FALSE;
+  }
+
+  return rv;
+}
+
+//----------------------------------------------------------------------
+// Setters and unsetters
+
+nsresult
+nsSMILTimedElement::SetBeginSpec(const nsAString& aBeginSpec)
+{
+  mBeginSpecSet = PR_TRUE;
+  return SetBeginOrEndSpec(aBeginSpec, PR_TRUE);
+}
+
+void
+nsSMILTimedElement::UnsetBeginSpec()
+{
+  mBeginSpecs.Clear();
+  mBeginInstances.Clear();
+  mBeginSpecSet = PR_FALSE;
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetEndSpec(const nsAString& aEndSpec)
+{
+  //
+  // When implementing events etc., don't forget to ensure
+  // mEndHasEventConditions is set if the specification contains conditions that
+  // describe event-values, repeat-values or accessKey-values.
+  //
+  return SetBeginOrEndSpec(aEndSpec, PR_FALSE);
+}
+
+void
+nsSMILTimedElement::UnsetEndSpec()
+{
+  mEndSpecs.Clear();
+  mEndInstances.Clear();
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetSimpleDuration(const nsAString& aDurSpec)
+{
+  nsSMILTimeValue duration;
+  PRBool isMedia;
+  nsresult rv;
+  
+  rv = nsSMILParserUtils::GetClockValue(aDurSpec,
+                                        &duration,
+                                        false, // don't allow + or -
+                                        true,  // allow indefinite
+                                        true,  // allow media
+                                        &isMedia);
+
+  if (NS_FAILED(rv) || (!duration.IsResolved() && !duration.IsIndefinite()))
+    return NS_ERROR_FAILURE;
+  
+  if (duration.IsResolved() && LL_IS_ZERO(duration.GetMillis()))
+    return NS_ERROR_FAILURE;
+
+  //
+  // SVG-specific: "For SVG's animation elements, if "media" is specified, the
+  // attribute will be ignored." (SVG 1.1, section 19.2.6)
+  //
+  if (isMedia)
+    duration.SetIndefinite();
+
+  mSimpleDur = duration;
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedElement::UnsetSimpleDuration()
+{
+  mSimpleDur.SetIndefinite();
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetMin(const nsAString& aMinSpec)
+{
+  nsSMILTimeValue duration;
+  PRBool isMedia;
+  nsresult rv;
+  
+  rv = nsSMILParserUtils::GetClockValue(aMinSpec,
+                                        &duration,
+                                        false, // don't allow + or -
+                                        false, // don't allow indefinite
+                                        true,  // allow media
+                                        &isMedia);
+
+  if (isMedia)
+    duration.SetMillis(LL_Zero());
+
+  if (NS_FAILED(rv) || !duration.IsResolved()) {
+    mMin.SetMillis(LL_Zero());
+    return NS_ERROR_FAILURE;
+  }
+  
+  if (!LL_GE_ZERO(duration.GetMillis())) {
+    mMin.SetMillis(LL_Zero());
+    return NS_ERROR_FAILURE;
+  }
+
+  mMin = duration;
+  UpdateCurrentInterval();
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedElement::UnsetMin()
+{
+  mMin.SetMillis(LL_Zero());
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetMax(const nsAString& aMaxSpec)
+{
+  nsSMILTimeValue duration;
+  PRBool isMedia;
+  nsresult rv;
+  
+  rv = nsSMILParserUtils::GetClockValue(aMaxSpec,
+                                        &duration,
+                                        false, // don't allow + or -
+                                        true,  // allow indefinite
+                                        true,  // allow media
+                                        &isMedia);
+
+  if (isMedia)
+    duration.SetIndefinite();
+
+  if (NS_FAILED(rv) || (!duration.IsResolved() && !duration.IsIndefinite())) {
+    mMax.SetIndefinite();
+    return NS_ERROR_FAILURE;
+  }
+  
+  if (duration.IsResolved() &&
+      (!LL_GE_ZERO(duration.GetMillis()) || LL_IS_ZERO(duration.GetMillis()))) {
+    mMax.SetIndefinite();
+    return NS_ERROR_FAILURE;
+  }
+
+  mMax = duration;
+  UpdateCurrentInterval();
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedElement::UnsetMax()
+{
+  mMax.SetIndefinite();
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetRestart(const nsAString& aRestartSpec)
+{
+  nsresult rv = mRestartMode.SetStringValue(aRestartSpec);
+  UpdateCurrentInterval();
+  return rv;
+}
+
+void
+nsSMILTimedElement::UnsetRestart()
+{
+  mRestartMode.SetIntegerValue(restart_always);
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetRepeatCount(const nsAString& aRepeatCountSpec)
+{
+  nsSMILTimeValue newRepeatCount;
+  nsresult rv = 
+    nsSMILParserUtils::GetRepeatCount(aRepeatCountSpec, newRepeatCount);
+
+  UpdateCurrentInterval();
+
+  if (NS_SUCCEEDED(rv)) {
+    mRepeatCount = newRepeatCount;
+  } else {
+    mRepeatCount.SetUnresolved();
+  }
+    
+  return rv;
+}
+
+void
+nsSMILTimedElement::UnsetRepeatCount()
+{
+  mRepeatCount.SetUnresolved();
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetRepeatDur(const nsAString& aRepeatDurSpec)
+{
+  nsresult        rv;
+  nsSMILTimeValue duration;
+
+  rv = nsSMILParserUtils::GetClockValue(aRepeatDurSpec,
+                                        &duration,
+                                        false,  // don't allow + or -
+                                        true);  // allow indefinite
+
+  if (NS_FAILED(rv) || (!duration.IsResolved() && !duration.IsIndefinite()))
+    return NS_ERROR_FAILURE;
+  
+  UpdateCurrentInterval();
+  
+  mRepeatDur = duration;
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedElement::UnsetRepeatDur()
+{
+  mRepeatDur.SetUnresolved();
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetFillMode(const nsAString& aFillModeSpec)
+{
+  PRUint16 previousFillMode = mFillMode.GetIntegerValue();
+  nsresult rv = mFillMode.SetStringValue(aFillModeSpec);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (previousFillMode == mFillMode.GetIntegerValue())
+    return NS_OK;
+
+  if ((mElementState == state_waiting || mElementState == state_postactive) &&
+      mClient)
+      mClient->Inactivate(mFillMode.GetIntegerValue() == fill_freeze);
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedElement::UnsetFillMode()
+{
+  PRUint16 previousFillMode = mFillMode.GetIntegerValue();
+  mFillMode.SetIntegerValue(fill_remove);
+  if ((mElementState == state_waiting || mElementState == state_postactive) &&
+      previousFillMode == fill_freeze &&
+      mClient)
+    mClient->Inactivate(PR_FALSE);
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+nsresult
+nsSMILTimedElement::SetBeginOrEndSpec(const nsAString& aSpec,
+                                      PRBool aIsBegin)
+{
+  nsRefPtr<nsSMILTimeValueSpec>    spec;
+  SMILTimeValueSpecList& timeSpecsList = (aIsBegin)
+                                       ? mBeginSpecs
+                                       : mEndSpecs;
+  nsTArray<nsSMILInstanceTime>&  instancesList = (aIsBegin)
+                                               ? mBeginInstances
+                                               : mEndInstances;
+
+  timeSpecsList.Clear();
+  instancesList.Clear();
+
+  PRInt32 start;
+  PRInt32 end = -1;
+  PRInt32 length;
+
+  do {
+    start        = end + 1;
+    end          = aSpec.FindChar(';', start);
+    length       = (end == -1) ? -1 : end - start;
+
+    spec = NS_NewSMILTimeValueSpec(this, aIsBegin,
+                                   Substring(aSpec, start, length));
+
+    if (spec)
+      timeSpecsList.AppendElement(spec);
+  } while (end != -1 && spec);
+
+  if (!spec) {
+    timeSpecsList.Clear();
+    instancesList.Clear();
+    Reset(PR_TRUE);
+    return NS_ERROR_FAILURE;
+  }
+
+  UpdateCurrentInterval();
+
+  return NS_OK;
+}
+
+//
+// This method is based on the pseudocode given in the SMILANIM spec.
+//
+// See:
+// http://www.w3.org/TR/2001/REC-smil-animation-20010904/#Timing-BeginEnd-LC-Start
+//
+nsresult
+nsSMILTimedElement::GetNextInterval(const nsSMILTimeValue& aBeginAfter,
+                                    PRBool aFirstInterval,
+                                    nsSMILInterval& aResult)
+{
+  static nsSMILTimeValue zeroTime;
+  zeroTime.SetMillis(LL_Zero());
+  
+  nsSMILTimeValue beginAfter = aBeginAfter;
+  nsSMILTimeValue tempBegin;
+  nsSMILTimeValue tempEnd;
+  PRInt32         beginPos = 0;
+  PRInt32         endPos = 0;
+
+  //
+  // This is to handle the special case when a we are calculating the first
+  // interval and we have a non-0-duration interval immediately after
+  // a 0-duration in which case but we have to be careful not to re-use an end
+  // that has already been used in another interval. See the pseudocode in
+  // SMILANIM 3.6.8 for getFirstInterval.
+  //
+  PRInt32         endMaxPos = 0;
+
+  if (mRestartMode.GetIntegerValue() == restart_never && !aFirstInterval)
+    return NS_ERROR_FAILURE;
+
+  nsSMILInstanceTime::Comparator comparator;
+  mBeginInstances.Sort(comparator);
+  mEndInstances.Sort(comparator);
+
+  while (true) {
+    if (!mBeginSpecSet && beginAfter.CompareTo(zeroTime) <= 0) {
+      tempBegin.SetMillis(0);
+    } else {
+      PRBool beginFound = GetNextGreater(mBeginInstances, beginAfter,
+                                         beginPos, tempBegin);
+      if (!beginFound)
+        return NS_ERROR_FAILURE;
+    }
+
+    if (mEndInstances.Length() == 0) {
+      nsSMILTimeValue indefiniteEnd;
+      indefiniteEnd.SetIndefinite();
+
+      tempEnd = CalcActiveEnd(tempBegin, indefiniteEnd);
+    } else {
+      // 
+      // Start searching from the beginning again.
+      //
+      endPos = 0;
+
+      PRBool endFound = GetNextGreater(mEndInstances, tempBegin,
+                                       endPos, tempEnd);
+
+      if ((!aFirstInterval && tempEnd.CompareTo(aBeginAfter) == 0) ||
+          (aFirstInterval && tempEnd.CompareTo(tempBegin) == 0 && 
+           endPos <= endMaxPos)) {
+        endFound = GetNextGreater(mEndInstances, tempBegin, endPos, tempEnd);
+      }
+
+      endMaxPos = endPos;
+
+      if (!endFound) {
+        if (mEndHasEventConditions || mEndInstances.Length() == 0) {
+          tempEnd.SetUnresolved();
+        } else {
+          // 
+          // This is a little counter-intuitive but according to SMILANIM, if
+          // all the end's are after the begin, we _don't_ just assume an
+          // infinite end, it's actually a bad interval. ASV however will just
+          // use an infinite end.
+          // 
+          return NS_ERROR_FAILURE;
+        }
+      }
+
+      tempEnd = CalcActiveEnd(tempBegin, tempEnd);
+    }
+
+    if (tempEnd.CompareTo(zeroTime) > 0) {
+      aResult.UpdateBegin(tempBegin);
+      aResult.UpdateEnd(tempEnd);
+      return NS_OK;
+    } else if (mRestartMode.GetIntegerValue() == restart_never) {
+      return NS_ERROR_FAILURE;
+    } else {
+      beginAfter = tempEnd;
+    }
+  }
+  NS_NOTREACHED("Hmm... we really shouldn't be here");
+
+  return NS_ERROR_FAILURE;
+}
+
+PRBool
+nsSMILTimedElement::GetNextGreater(const nsTArray<nsSMILInstanceTime>& aList,
+                                   const nsSMILTimeValue& aBase,
+                                   PRInt32 &aPosition,
+                                   nsSMILTimeValue& aResult)
+{
+    PRBool              found = PR_FALSE;
+    PRInt32             count = aList.Length();
+
+    for (; aPosition < count && !found; ++aPosition) {
+      const nsSMILInstanceTime &val = aList[aPosition];
+      if (val.Time().CompareTo(aBase) >= 0) {
+        aResult = val.Time();
+        found = PR_TRUE;
+      }
+    }
+
+    return found;
+}
+
+inline PRInt64
+nsSMILTimedElement::MinLL(const PRInt64& a, const PRInt64& b)
+{
+  return (LL_CMP(a, <, b)) ? a : b;
+}
+
+/**
+ * @see SMILANIM 3.3.4
+ */
+nsSMILTimeValue
+nsSMILTimedElement::CalcActiveEnd(const nsSMILTimeValue& aBegin,
+                                  const nsSMILTimeValue& aEnd)
+{
+  nsSMILTimeValue result;
+
+  if (!mSimpleDur.IsIndefinite() && !mSimpleDur.IsResolved()) {
+    NS_ERROR("Unresolved simple duration in CalcActiveEnd.");
+    result.SetIndefinite();
+    return result;
+  }
+
+  if (!aBegin.IsResolved() && !aBegin.IsIndefinite()) {
+    NS_ERROR("Unresolved begin time passed to CalcActiveEnd.");
+    result.SetIndefinite();
+    return result;
+  }
+
+  if (mRepeatDur.IsIndefinite() || aBegin.IsIndefinite()) {
+    result.SetIndefinite();
+  } else {
+    result = GetRepeatDuration();
+  }
+
+  if (aEnd.IsResolved() && aBegin.IsResolved()) {
+    PRInt64 activeDur;
+    LL_SUB(activeDur, aEnd.GetMillis(), aBegin.GetMillis());
+
+    if (result.IsResolved()) {
+      result.SetMillis(MinLL(result.GetMillis(), activeDur));
+    } else {
+      result.SetMillis(activeDur);
+    }
+  }
+
+  result = ApplyMinAndMax(result);
+
+  if (result.IsResolved()) {
+    PRInt64 activeEnd;
+    LL_ADD(activeEnd, result.GetMillis(), aBegin.GetMillis());
+    result.SetMillis(activeEnd);
+  }
+
+  return result;
+}
+
+nsSMILTimeValue
+nsSMILTimedElement::GetRepeatDuration()
+{
+  nsSMILTimeValue result;
+
+  if (mRepeatCount.IsResolved() && mRepeatDur.IsResolved()) {
+    if (mSimpleDur.IsResolved()) {
+      PRInt64 activeDur;
+      LL_MUL(activeDur, mRepeatCount.GetMillis(), mSimpleDur.GetMillis());
+      LL_DIV(activeDur, activeDur, 1000);
+      result.SetMillis(MinLL(activeDur, mRepeatDur.GetMillis()));
+    } else {
+      result = mRepeatDur;
+    }
+  } else if (mRepeatCount.IsResolved() && mSimpleDur.IsResolved()) {
+    PRInt64 activeDur;
+    LL_MUL(activeDur, mRepeatCount.GetMillis(), mSimpleDur.GetMillis());
+    LL_DIV(activeDur, activeDur, 1000);
+    result.SetMillis(activeDur);
+  } else if (mRepeatDur.IsResolved()) {
+    result = mRepeatDur;
+  } else if (mRepeatCount.IsIndefinite()) {
+    result.SetIndefinite();
+  } else {
+    result = mSimpleDur;
+  }
+
+  return result;
+}
+
+nsSMILTimeValue
+nsSMILTimedElement::ApplyMinAndMax(const nsSMILTimeValue& aDuration)
+{
+  if (!aDuration.IsResolved() && !aDuration.IsIndefinite()) {
+    return aDuration;
+  }
+
+  if (mMax.CompareTo(mMin) < 0) {
+    return aDuration;
+  }
+
+  nsSMILTimeValue result;
+
+  if (aDuration.CompareTo(mMax) > 0) {
+    result = mMax;
+  } else if (aDuration.CompareTo(mMin) < 0) {
+    nsSMILTimeValue repeatDur = GetRepeatDuration();
+    result = (mMin.CompareTo(repeatDur) > 0) ? repeatDur : mMin;
+  } else {
+    result = aDuration;
+  }
+
+  return result;
+}
+
+PRInt64
+nsSMILTimedElement::ActiveTimeToSimpleTime(const PRInt64& aActiveTime,
+                                           PRUint32& aRepeatIteration)
+{
+  PRInt64 result;
+
+  NS_ASSERTION(mSimpleDur.IsResolved() || mSimpleDur.IsIndefinite(),
+      "Trying to calculate active time with unresolved duration");
+
+  if (mSimpleDur.IsIndefinite() || LL_IS_ZERO(mSimpleDur.GetMillis())) {
+    aRepeatIteration = 0;
+    result = aActiveTime;
+  } else {    
+    PRInt64 repeatResult;
+    LL_MOD(result, aActiveTime, mSimpleDur.GetMillis());
+    LL_DIV(repeatResult, aActiveTime, mSimpleDur.GetMillis());
+
+    LL_L2UI(aRepeatIteration, repeatResult);
+  }
+
+  return result;
+}
+
+//
+// Although in many cases it would be possible to check for an early end and
+// adjust the current interval well in advance the SMIL Animation spec seems to
+// indicate that we should only apply an early end at the latest possible
+// moment. In particular, this paragraph from section 3.6.8:
+//
+// 'If restart  is set to "always", then the current interval will end early if
+// there is an instance time in the begin list that is before (i.e. earlier
+// than) the defined end for the current interval. Ending in this manner will
+// also send a changed time notice to all time dependents for the current
+// interval end.'
+//
+void
+nsSMILTimedElement::CheckForEarlyEnd(const nsSMILTimeValue& aDocumentTime)
+{
+  if (mRestartMode.GetIntegerValue() != restart_always)
+    return;
+
+  nsSMILTimeValue nextBegin;
+  PRInt32 position = 0;
+
+  // 
+  // Despite its name, GetNextGreater actually gets the next instance time that
+  // is greater than _or_equal_to_ the reference time so we have to loop to make
+  // sure we're getting an instance time that is actually _after_ the interval
+  // begin time
+  //
+  while (GetNextGreater(mBeginInstances, mCurrentInterval->Begin(),
+                        position, nextBegin) &&
+         nextBegin.CompareTo(mCurrentInterval->Begin()) == 0);
+        
+  if (nextBegin.IsResolved() && 
+      nextBegin.CompareTo(mCurrentInterval->Begin()) > 0 &&
+      nextBegin.CompareTo(mCurrentInterval->End()) < 0 &&
+      nextBegin.CompareTo(aDocumentTime) <= 0) {
+    mCurrentInterval->UpdateEnd(nextBegin);
+  }
+}
+
+void
+nsSMILTimedElement::UpdateCurrentInterval()
+{
+  if (mElementState == state_startup)
+    return;
+
+  nsRefPtr<nsSMILInterval> updatedInterval = new nsSMILInterval();
+  PRBool isFirstInterval = mOldIntervals.IsEmpty();
+
+  nsSMILTimeValue beginAfter;
+  if (!isFirstInterval) {
+    beginAfter = mOldIntervals[mOldIntervals.Length() - 1]->End();
+  } else {
+    beginAfter.SetMillis(LL_MININT);
+  }
+
+  nsresult rv = 
+    GetNextInterval(beginAfter, isFirstInterval, *updatedInterval);
+
+  if (NS_SUCCEEDED(rv)) {
+
+    if (mElementState != state_active &&
+        updatedInterval->Begin().CompareTo(mCurrentInterval->Begin())) {
+      mCurrentInterval->UpdateBegin(updatedInterval->Begin());
+    }
+
+    if (updatedInterval->End().CompareTo(mCurrentInterval->End())) {
+      mCurrentInterval->UpdateEnd(updatedInterval->End());
+    }
+
+    if (mElementState == state_postactive) {
+      // XXX notify dependents of new interval
+      mElementState = state_waiting;
+    }
+  } else {
+
+    nsSMILTimeValue unresolvedTime;
+    mCurrentInterval->UpdateEnd(unresolvedTime);
+    if (mElementState != state_active) {
+      mCurrentInterval->UpdateBegin(unresolvedTime);
+    }
+
+    if (mElementState == state_waiting) {
+      // XXX notify dependents the current interval has been deleted
+      mElementState = state_postactive;
+    }
+
+    if (mElementState == state_active) {
+      // XXX notify dependents the current interval has been deleted
+      mElementState = state_postactive;
+      if (mClient) {
+        mClient->Inactivate(PR_FALSE);
+      }
+    }
+  }
+}
+
+void
+nsSMILTimedElement::SampleSimpleTime(PRInt64 aActiveTime)
+{
+  if (mClient) {
+    PRUint32 repeatIteration;
+    PRInt64  simpleTime = 
+      ActiveTimeToSimpleTime(aActiveTime, repeatIteration);
+    mClient->SampleAt(simpleTime, mSimpleDur, repeatIteration);
+  }
+}
+
+void
+nsSMILTimedElement::SampleFillValue()
+{
+  if (mFillMode.GetIntegerValue() != fill_freeze)
+    return;
+
+  if (!mClient)
+    return;
+
+  PRUint32 repeatIteration;
+  PRInt64 activeTime;
+  LL_SUB(activeTime,
+         mCurrentInterval->End().GetMillis(),
+         mCurrentInterval->Begin().GetMillis());
+
+  PRInt64  simpleTime = 
+    ActiveTimeToSimpleTime(activeTime, repeatIteration);
+
+  if (LL_IS_ZERO(simpleTime)) {
+    mClient->SampleLastValue(--repeatIteration);
+  } else {
+    mClient->SampleAt(simpleTime, mSimpleDur, repeatIteration);
+  }
+}
diff --git a/content/smil/src/test/Makefile.in b/content/smil/src/test/Makefile.in
new file mode 100644
--- /dev/null
+++ b/content/smil/src/test/Makefile.in
@@ -0,0 +1,51 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla SMIL module.
+#
+# The Initial Developer of the Original Code is
+# Mozilla Corporation.
+# Portions created by the Initial Developer are Copyright (C) 2008
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Daniel Holbert <dholbert@mozilla.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+DEPTH		= ../../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+relativesrcdir  = content/smil/src/test
+
+include $(DEPTH)/config/autoconf.mk
+include $(topsrcdir)/config/rules.mk
+
+_TEST_FILES = 	test_smilRestart.xhtml \
+		$(NULL)
+
+libs:: $(_TEST_FILES)
+	$(INSTALL) $^ $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
diff --git a/content/smil/src/test/test_smilRestart.xhtml b/content/smil/src/test/test_smilRestart.xhtml
new file mode 100644
--- /dev/null
+++ b/content/smil/src/test/test_smilRestart.xhtml
@@ -0,0 +1,105 @@
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+  <title>Test for SMIL Restart Behavior </title>
+  <script type="text/javascript" src="/MochiKit/packed.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<p id="display"></p>
+<div id="content" style="display: none">
+<svg id="svg" xmlns="http://www.w3.org/2000/svg" width="120px" height="120px">
+  <!-- These 3 circles only differ in their animation's "restart" value -->
+  <circle cx="20" cy="20" r="15" fill="blue">
+    <animate attributeName="cx" from="20" to="100" begin="0s" dur="4s"
+             restart="always" id="always" attributeType="XML"/>
+  </circle>
+  <circle cx="20" cy="60" r="15" fill="blue">
+    <animate attributeName="cx" from="20" to="100" begin="0s" dur="4s"
+             restart="whenNotActive" id="whenNotActive" attributeType="XML"/>
+  </circle>
+  <circle cx="20" cy="100" r="15" fill="blue">
+    <animate attributeName="cx" from="20" to="100" begin="0s" dur="4s"
+             restart="never" id="never" attributeType="XML"/>
+  </circle>
+</svg>
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+<![CDATA[
+/** Test for SMIL Restart Behavior  **/
+
+/* Global Variables */
+var dur = 4.0; // this must match the "dur" attribute on animations above.
+var svg = document.getElementById("svg");
+
+SimpleTest.waitForExplicitFinish();
+
+// main: just triggers the first link in the chain of function-calls
+function main() {
+  checkInitialState();
+}
+
+// Attempt a "beginElement" call on the given element, and
+// complain if we don't get the expected return value.
+// 'time' is only provided for better diagnostic output.
+function tryRestartElem(id, time, expectedRetVal) {
+  var elem = document.getElementById(id); 
+  var retVal = elem.beginElement();
+  is(retVal, expectedRetVal,
+     "Error restarting animation '" + id + 
+     "' at time = " + time + ": " + 
+     "expected return value of " + expectedRetVal + 
+     ", but got " + retVal + ".");
+}
+
+function checkInitialState() {
+  svg.setCurrentTime(0.0);
+  setTimeout('doCheckInitialState(0.0)', 0);
+}
+function doCheckInitialState(time) {
+  tryRestartElem('always', time, true);
+  tryRestartElem('whenNotActive', time, false);
+  tryRestartElem('never', time, false);
+  checkHalfwayState();
+}
+
+function checkHalfwayState() {
+  svg.setCurrentTime(0.5 * dur);
+  setTimeout('doCheckHalfwayState(0.5 * dur)', 0);
+}
+function doCheckHalfwayState(time) {
+  tryRestartElem('always', time, true);
+  tryRestartElem('whenNotActive', time, false);
+  tryRestartElem('never', time, false);
+  checkEndingState();
+}
+
+function checkEndingState() {
+  svg.setCurrentTime(dur);
+  setTimeout('doCheckEndingState(dur)', 0);
+}
+function doCheckEndingState(time) {
+  tryRestartElem('always', time, true);
+  tryRestartElem('whenNotActive', time, true);
+  tryRestartElem('never', time, false);
+  checkAfterEndingState();
+}
+
+function checkAfterEndingState() {
+  svg.setCurrentTime(dur * 3);
+  setTimeout('doCheckAfterEndingState(dur * 3)', 0);
+}
+function doCheckAfterEndingState(time) {
+  tryRestartElem('always', time, true);
+  tryRestartElem('whenNotActive', time, true);
+  tryRestartElem('never', time, false);
+  SimpleTest.finish();
+}
+
+window.addEventListener("load", main, false);
+]]>
+</script>
+</pre>
+</body>
+</html>
diff --git a/content/svg/content/src/Makefile.in b/content/svg/content/src/Makefile.in
--- a/content/svg/content/src/Makefile.in
+++ b/content/svg/content/src/Makefile.in
@@ -16,16 +16,17 @@
 #
 # The Initial Developer of the Original Code is
 # Crocodile Clips Ltd.
 # Portions created by the Initial Developer are Copyright (C) 2001
 # the Initial Developer. All Rights Reserved.
 #
 # Contributor(s):
 #   Alex Fritze <alex.fritze@crocodile-clips.com>
+#   Chris Double  <chris.double@double.co.nz>
 #
 # Alternatively, the contents of this file may be used under the terms of
 # either of the GNU General Public License Version 2 or later (the "GPL"),
 # or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 # in which case the provisions of the GPL or the LGPL are applicable instead
 # of those above. If you wish to allow use of your version of this file only
 # under the terms of either the GPL or the LGPL, and not to allow others to
 # use your version of this file under the terms of the MPL, indicate your
@@ -134,16 +135,26 @@ CPPSRCS		= \
 		nsSVGTitleElement.cpp \
 		nsSVGTransform.cpp \
 		nsSVGTransformList.cpp \
 		nsSVGTransformListParser.cpp \
 		nsSVGUseElement.cpp \
 		nsSVGValue.cpp \
 		$(NULL)
 
+ifdef MOZ_SMIL
+CPPSRCS += nsSVGAnimateElement.cpp \
+           nsSVGAnimateTransformElement.cpp \
+           nsSVGAnimationElement.cpp \
+           nsSVGSetElement.cpp \
+           nsSVGTransformSMILType.cpp \
+           nsSVGTransformSMILAttr.cpp \
+           $(NULL)
+endif
+
 include $(topsrcdir)/config/config.mk
 
 # we don't want the shared lib, but we want to force the creation of a static lib.
 FORCE_STATIC_LIB = 1
 
 EXPORTS =  			\
 	nsIDOMSVGListener.h \
 	nsIDOMSVGZoomListener.h \
diff --git a/content/svg/content/src/nsISVGAnimationElement.h b/content/svg/content/src/nsISVGAnimationElement.h
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsISVGAnimationElement.h
@@ -0,0 +1,59 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISVGANIMATIONELEMENT__
+#define __NS_ISVGANIMATIONELEMENT__
+
+#include "nsISupports.h"
+
+//////////////////////////////////////////////////////////////////////////////
+// nsISVGAnimationElement: private interface implemented by animation elements
+
+#define NS_ISVGANIMATIONELEMENT_IID \
+{ 0x70ac6eed, 0x0dba, 0x4c11, { 0xa6, 0xc5, 0x15, 0x73, 0xbc, 0x2f, 0x1a, 0xd8 } }
+
+class nsISVGAnimationElement : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISVGANIMATIONELEMENT_IID)
+
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISVGAnimationElement,
+                              NS_ISVGANIMATIONELEMENT_IID)
+
+#endif // __NS_ISVGANIMATIONELEMENT__
diff --git a/content/svg/content/src/nsSVGAnimateElement.cpp b/content/svg/content/src/nsSVGAnimateElement.cpp
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGAnimateElement.cpp
@@ -0,0 +1,187 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGAnimationElement.h"
+#include "nsIDOMSVGAnimateElement.h"
+
+typedef nsSVGAnimationElement nsSVGAnimateElementBase;
+
+class nsSVGAnimateElement : public nsSVGAnimateElementBase,
+                            public nsIDOMSVGAnimateElement
+                              // : nsIDOMSVGAnimationElement
+{
+protected:
+  friend nsresult NS_NewSVGAnimateElement(nsIContent **aResult,
+                                          nsINodeInfo *aNodeInfo);
+  nsSVGAnimateElement(nsINodeInfo* aNodeInfo);
+  nsresult Init();
+
+public:
+  // interfaces:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIDOMSVGANIMATEELEMENT
+
+  NS_FORWARD_NSIDOMNODE(nsSVGAnimateElementBase::)
+  NS_FORWARD_NSIDOMELEMENT(nsSVGAnimateElementBase::)
+  NS_FORWARD_NSIDOMSVGELEMENT(nsSVGAnimateElementBase::)
+  NS_FORWARD_NSIDOMSVGANIMATIONELEMENT(nsSVGAnimateElementBase::)
+  
+  // nsIContent specializations
+  virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
+                           nsIAtom* aPrefix, const nsAString& aValue,
+                           PRBool aNotify);
+  virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
+                             PRBool aNotify);
+
+  virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
+
+protected:
+  // Implementation helpers
+  virtual already_AddRefed<nsISMILAttr> GetTargetAttribute();
+  virtual nsIAtom** GetAnimationProperties();
+};
+
+NS_IMPL_NS_NEW_SVG_ELEMENT(Animate)
+
+
+//----------------------------------------------------------------------
+// nsISupports methods
+
+NS_IMPL_ADDREF_INHERITED(nsSVGAnimateElement,nsSVGAnimateElementBase)
+NS_IMPL_RELEASE_INHERITED(nsSVGAnimateElement,nsSVGAnimateElementBase)
+
+NS_INTERFACE_MAP_BEGIN(nsSVGAnimateElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimationElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimateElement)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGAnimateElement)
+NS_INTERFACE_MAP_END_INHERITING(nsSVGAnimateElementBase)
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSVGAnimateElement::nsSVGAnimateElement(nsINodeInfo *aNodeInfo)
+  : nsSVGAnimateElementBase(aNodeInfo)
+{
+}
+
+nsresult
+nsSVGAnimateElement::Init()
+{
+  return nsSVGAnimateElementBase::Init();
+}
+
+//----------------------------------------------------------------------
+// nsIDOMNode methods
+
+NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGAnimateElement)
+
+//----------------------------------------------------------------------
+// nsIContent methods
+
+nsresult
+nsSVGAnimateElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
+                             nsIAtom* aPrefix, const nsAString& aValue,
+                             PRBool aNotify)
+{
+  nsresult rv = nsSVGAnimateElementBase::SetAttr(aNameSpaceID, aName, aPrefix,
+                                                 aValue, aNotify);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (aNameSpaceID != kNameSpaceID_None)
+    return NS_OK;
+  
+  if (aName == nsGkAtoms::attributeName)
+    UpdateTargetAttribute();
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGAnimateElement::UnsetAttr(PRInt32 aNameSpaceID,
+                               nsIAtom* aAttribute, PRBool aNotify)
+{
+  nsresult rv = nsSVGAnimateElementBase::UnsetAttr(aNameSpaceID, aAttribute,
+                                                   aNotify);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (aNameSpaceID != kNameSpaceID_None)
+    return NS_OK;
+
+  if (aAttribute == nsGkAtoms::attributeName)
+    UpdateTargetAttribute();
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+already_AddRefed<nsISMILAttr>
+nsSVGAnimateElement::GetTargetAttribute()
+{
+  nsISMILAttr* result = nsnull;
+
+  if (mTargetElement) {
+    nsAutoString attributeName;
+
+    GetAttr(kNameSpaceID_None, nsGkAtoms::attributeName, attributeName);
+
+    nsCOMPtr<nsIAtom> attributeAtom( do_GetAtom(attributeName) );
+    nsCOMPtr<nsIContent> targetElement(do_QueryReferent(mTargetElement));
+
+    if (targetElement && attributeAtom) {
+      result =
+        static_cast<nsSVGElement*>(targetElement.get())->GetAnimAttribute(kNameSpaceID_None,
+                                                                          attributeAtom).get();
+    }
+  }
+
+  return result;
+}
+
+nsIAtom**
+nsSVGAnimateElement::GetAnimationProperties()
+{
+  static nsIAtom *atoms[] = { nsGkAtoms::by, nsGkAtoms::from,
+                              nsGkAtoms::to, nsGkAtoms::values,
+                              nsnull };
+
+  return atoms;
+}
diff --git a/content/svg/content/src/nsSVGAnimateTransformElement.cpp b/content/svg/content/src/nsSVGAnimateTransformElement.cpp
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGAnimateTransformElement.cpp
@@ -0,0 +1,230 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGAnimationElement.h"
+#include "nsIDOMSVGAnimateTransformElement.h"
+#include "nsSVGEnum.h"
+#include "nsIDOMSVGTransform.h"
+#include "nsIDOMSVGTransformable.h"
+#include "nsSVGAnimatedTransformList.h"
+#include "nsSVGTransformSMILAttr.h"
+
+typedef nsSVGAnimationElement nsSVGAnimateTransformElementBase;
+
+class nsSVGAnimateTransformElement : public nsSVGAnimateTransformElementBase,
+                                     public nsIDOMSVGAnimateTransformElement
+                                       // : nsIDOMSVGAnimationElement
+{
+protected:
+  friend nsresult NS_NewSVGAnimateTransformElement(nsIContent **aResult,
+                                                   nsINodeInfo *aNodeInfo);
+  nsSVGAnimateTransformElement(nsINodeInfo* aNodeInfo);
+
+public:
+  // interfaces:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIDOMSVGANIMATETRANSFORMELEMENT
+
+  NS_FORWARD_NSIDOMNODE(nsSVGAnimateTransformElementBase::)
+  NS_FORWARD_NSIDOMELEMENT(nsSVGAnimateTransformElementBase::)
+  NS_FORWARD_NSIDOMSVGELEMENT(nsSVGAnimateTransformElementBase::)
+  NS_FORWARD_NSIDOMSVGANIMATIONELEMENT(nsSVGAnimateTransformElementBase::)
+
+  // nsIContent specializations
+  virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
+                           nsIAtom* aPrefix, const nsAString& aValue,
+                           PRBool aNotify);
+  virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
+                             PRBool aNotify);
+
+  virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
+
+protected:
+  virtual nsIAtom** GetAnimationProperties();
+  virtual already_AddRefed<nsISMILAttr> GetTargetAttribute();
+  virtual EnumAttributesInfo GetEnumInfo();
+
+  enum { TYPE };
+  nsSVGEnum mEnumAttributes[1];
+  static nsSVGEnumMapping sTransformTypeMap[];
+  static EnumInfo sEnumInfo[1];
+};
+
+nsSVGEnumMapping nsSVGAnimateTransformElement::sTransformTypeMap[] = {
+  {&nsGkAtoms::translate, nsIDOMSVGTransform::SVG_TRANSFORM_TRANSLATE},
+  {&nsGkAtoms::scale, nsIDOMSVGTransform::SVG_TRANSFORM_SCALE},
+  {&nsGkAtoms::rotate, nsIDOMSVGTransform::SVG_TRANSFORM_ROTATE},
+  {&nsGkAtoms::skewX, nsIDOMSVGTransform::SVG_TRANSFORM_SKEWX},
+  {&nsGkAtoms::skewY, nsIDOMSVGTransform::SVG_TRANSFORM_SKEWY},
+  {nsnull, 0}
+};
+
+nsSVGElement::EnumInfo nsSVGAnimateTransformElement::sEnumInfo[1] =
+{
+  { &nsGkAtoms::type,
+    sTransformTypeMap,
+    nsIDOMSVGTransform::SVG_TRANSFORM_TRANSLATE
+  }
+};
+
+NS_IMPL_NS_NEW_SVG_ELEMENT(AnimateTransform)
+
+
+//----------------------------------------------------------------------
+// nsISupports methods
+
+NS_IMPL_ADDREF_INHERITED(nsSVGAnimateTransformElement,nsSVGAnimateTransformElementBase)
+NS_IMPL_RELEASE_INHERITED(nsSVGAnimateTransformElement,nsSVGAnimateTransformElementBase)
+
+NS_INTERFACE_MAP_BEGIN(nsSVGAnimateTransformElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimationElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimateTransformElement)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGAnimateElement)
+NS_INTERFACE_MAP_END_INHERITING(nsSVGAnimateTransformElementBase)
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSVGAnimateTransformElement::nsSVGAnimateTransformElement(nsINodeInfo *aNodeInfo)
+  : nsSVGAnimateTransformElementBase(aNodeInfo)
+{
+}
+
+nsSVGElement::EnumAttributesInfo
+nsSVGAnimateTransformElement::GetEnumInfo()
+{
+  return EnumAttributesInfo(mEnumAttributes, sEnumInfo,
+                            NS_ARRAY_LENGTH(sEnumInfo));
+}
+
+//----------------------------------------------------------------------
+// nsIDOMNode methods
+
+NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGAnimateTransformElement)
+
+//----------------------------------------------------------------------
+// nsIContent methods
+
+nsresult
+nsSVGAnimateTransformElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
+                                      nsIAtom* aPrefix, const nsAString& aValue,
+                                      PRBool aNotify)
+{
+  nsresult rv = nsSVGAnimateTransformElementBase::SetAttr(aNameSpaceID, aName,
+                                                          aPrefix, aValue,
+                                                          aNotify);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (aNameSpaceID != kNameSpaceID_None)
+    return NS_OK;
+  
+  if (aName == nsGkAtoms::type)
+    UpdateTargetAttribute();
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGAnimateTransformElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
+                                        PRBool aNotify)
+{
+  nsresult rv = nsSVGAnimateTransformElementBase::UnsetAttr(aNameSpaceID,
+                                                            aAttribute,
+                                                            aNotify);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (aNameSpaceID != kNameSpaceID_None)
+    return NS_OK;
+
+  if (aAttribute == nsGkAtoms::type)
+    UpdateTargetAttribute();
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+already_AddRefed<nsISMILAttr>
+nsSVGAnimateTransformElement::GetTargetAttribute()
+{
+  nsISMILAttr* result = nsnull;
+
+  if (!HasAttr(kNameSpaceID_None, nsGkAtoms::type))
+    return nsnull;
+
+  if (mTargetElement) {
+    /* Get the list */
+    nsCOMPtr<nsIDOMSVGTransformable> transformable( 
+        do_QueryReferent(mTargetElement) );
+    NS_ENSURE_TRUE(transformable, nsnull);
+    nsCOMPtr<nsIDOMSVGAnimatedTransformList> transformList;
+    nsresult rv = transformable->GetTransform(getter_AddRefs(transformList));
+    NS_ENSURE_SUCCESS(rv,nsnull);
+    nsSVGAnimatedTransformList* list =
+      (nsSVGAnimatedTransformList*)transformList.get();
+    NS_ENSURE_TRUE(list,nsnull);
+
+    /* Get the SVG element */
+    nsCOMPtr<nsIDOMSVGElement> svgElement(do_QueryReferent(mTargetElement));
+    NS_ENSURE_TRUE(svgElement, nsnull);
+    nsSVGElement *target = (nsSVGElement*)svgElement.get();
+
+    /* Get the type */
+    PRUint16 transformType = mEnumAttributes[TYPE].GetAnimValue();
+
+    result = new nsSVGTransformSMILAttr(list, target, transformType);
+    NS_ENSURE_SUCCESS(rv,nsnull);
+    NS_ADDREF(result);
+  }
+
+  return result;
+}
+
+nsIAtom**
+nsSVGAnimateTransformElement::GetAnimationProperties()
+{
+  static nsIAtom *atoms[] = { nsGkAtoms::by, nsGkAtoms::from,
+                              nsGkAtoms::to, nsGkAtoms::values,
+                              nsnull };
+
+  return atoms;
+}
diff --git a/content/svg/content/src/nsSVGAnimatedTransformList.cpp b/content/svg/content/src/nsSVGAnimatedTransformList.cpp
--- a/content/svg/content/src/nsSVGAnimatedTransformList.cpp
+++ b/content/svg/content/src/nsSVGAnimatedTransformList.cpp
@@ -33,67 +33,20 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsSVGAnimatedTransformList.h"
 #include "nsSVGTransformList.h"
-#include "nsSVGValue.h"
-#include "nsWeakReference.h"
 #include "nsContentUtils.h"
-
-////////////////////////////////////////////////////////////////////////
-// nsSVGAnimatedTransformList
-
-class nsSVGAnimatedTransformList : public nsIDOMSVGAnimatedTransformList,
-                                   public nsSVGValue,
-                                   public nsISVGValueObserver
-{  
-protected:
-  friend nsresult
-  NS_NewSVGAnimatedTransformList(nsIDOMSVGAnimatedTransformList** result,
-                                 nsIDOMSVGTransformList* baseVal);
-
-  nsSVGAnimatedTransformList();
-  ~nsSVGAnimatedTransformList();
-  void Init(nsIDOMSVGTransformList* baseVal);
-  
-public:
-  // nsISupports interface:
-  NS_DECL_ISUPPORTS
-
-  // nsIDOMSVGAnimatedTransformList interface:
-  NS_DECL_NSIDOMSVGANIMATEDTRANSFORMLIST
-
-  // remainder of nsISVGValue interface:
-  NS_IMETHOD SetValueString(const nsAString& aValue);
-  NS_IMETHOD GetValueString(nsAString& aValue);
-
-  // nsISVGValueObserver
-  NS_IMETHOD WillModifySVGObservable(nsISVGValue* observable,
-                                     modificationType aModType);
-  NS_IMETHOD DidModifySVGObservable (nsISVGValue* observable,
-                                     modificationType aModType);
-  
-  // nsISupportsWeakReference
-  // implementation inherited from nsSupportsWeakReference
-  
-protected:
-  nsCOMPtr<nsIDOMSVGTransformList> mBaseVal;
-};
-
 
 //----------------------------------------------------------------------
 // Implementation
-
-nsSVGAnimatedTransformList::nsSVGAnimatedTransformList()
-{
-}
 
 nsSVGAnimatedTransformList::~nsSVGAnimatedTransformList()
 {
   if (!mBaseVal) return;
     nsCOMPtr<nsISVGValue> val = do_QueryInterface(mBaseVal);
   if (!val) return;
   val->RemoveObserver(this);
 }
@@ -141,28 +94,28 @@ nsSVGAnimatedTransformList::GetValueStri
   return value->GetValueString(aValue);
 }
 
 //----------------------------------------------------------------------
 // nsIDOMSVGAnimatedTransformList methods:
 
 /* readonly attribute nsIDOMSVGTransformList baseVal; */
 NS_IMETHODIMP
-nsSVGAnimatedTransformList::GetBaseVal(nsIDOMSVGTransformList * *aBaseVal)
+nsSVGAnimatedTransformList::GetBaseVal(nsIDOMSVGTransformList** aBaseVal)
 {
   *aBaseVal = mBaseVal;
   NS_ADDREF(*aBaseVal);
   return NS_OK;
 }
 
 /* readonly attribute nsIDOMSVGTransformList animVal; */
 NS_IMETHODIMP
-nsSVGAnimatedTransformList::GetAnimVal(nsIDOMSVGTransformList * *aAnimVal)
+nsSVGAnimatedTransformList::GetAnimVal(nsIDOMSVGTransformList** aAnimVal)
 {
-  *aAnimVal = mBaseVal;
+  *aAnimVal = (mAnimVal) ? mAnimVal : mBaseVal;
   NS_ADDREF(*aAnimVal);
   return NS_OK;
 }
 
 //----------------------------------------------------------------------
 // nsISVGValueObserver methods
 
 NS_IMETHODIMP
@@ -176,23 +129,22 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsSVGAnimatedTransformList::DidModifySVGObservable (nsISVGValue* observable,
                                                     modificationType aModType)
 {
   DidModify(aModType);
   return NS_OK;
 }
 
-
 ////////////////////////////////////////////////////////////////////////
 // Exported creation functions:
 
 nsresult
 NS_NewSVGAnimatedTransformList(nsIDOMSVGAnimatedTransformList** result,
-                      nsIDOMSVGTransformList* baseVal)
+                               nsIDOMSVGTransformList* baseVal)
 {
   *result = nsnull;
   
   nsSVGAnimatedTransformList* animatedTransformList = new nsSVGAnimatedTransformList();
   if(!animatedTransformList) return NS_ERROR_OUT_OF_MEMORY;
   NS_ADDREF(animatedTransformList);
 
   animatedTransformList->Init(baseVal);
diff --git a/content/svg/content/src/nsSVGAnimatedTransformList.h b/content/svg/content/src/nsSVGAnimatedTransformList.h
--- a/content/svg/content/src/nsSVGAnimatedTransformList.h
+++ b/content/svg/content/src/nsSVGAnimatedTransformList.h
@@ -36,14 +36,65 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef __NS_SVGANIMATEDTRANSFORMLIST_H__
 #define __NS_SVGANIMATEDTRANSFORMLIST_H__
 
 #include "nsIDOMSVGAnimTransformList.h"
 #include "nsIDOMSVGTransformList.h"
+#include "nsSVGValue.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsSVGAnimatedTransformList
+
+class nsSVGTransformSMILAttr;
+
+class nsSVGAnimatedTransformList : public nsIDOMSVGAnimatedTransformList,
+                                   public nsSVGValue,
+                                   public nsISVGValueObserver
+{  
+protected:
+  friend nsresult
+  NS_NewSVGAnimatedTransformList(nsIDOMSVGAnimatedTransformList** result,
+                                 nsIDOMSVGTransformList* baseVal);
+
+  ~nsSVGAnimatedTransformList();
+  void Init(nsIDOMSVGTransformList* baseVal);
+
+public:
+  // nsISupports interface:
+  NS_DECL_ISUPPORTS
+
+  // nsIDOMSVGAnimatedTransformList interface:
+  NS_DECL_NSIDOMSVGANIMATEDTRANSFORMLIST
+
+  // remainder of nsISVGValue interface:
+  NS_IMETHOD SetValueString(const nsAString& aValue);
+  NS_IMETHOD GetValueString(nsAString& aValue);
+
+  // nsISVGValueObserver
+  NS_IMETHOD WillModifySVGObservable(nsISVGValue* observable,
+                                     modificationType aModType);
+  NS_IMETHOD DidModifySVGObservable (nsISVGValue* observable,
+                                     modificationType aModType);
+
+  // nsISupportsWeakReference
+  // implementation inherited from nsSupportsWeakReference
+
+protected:
+  nsresult
+  ParseValue(const nsAString &aSpec, nsIDOMSVGMatrix** matrix) const;
+
+  PRInt32
+  ParseParameterList(char *paramstr, float *vars, PRInt32 nvars) const;
+
+  friend class nsSVGTransformSMILAttr;
+
+  nsCOMPtr<nsIDOMSVGTransformList> mBaseVal;
+  nsCOMPtr<nsIDOMSVGTransformList> mAnimVal;
+};
 
 nsresult
 NS_NewSVGAnimatedTransformList(nsIDOMSVGAnimatedTransformList** result,
                                nsIDOMSVGTransformList* baseVal);
 
 #endif //__NS_SVGANIMATEDTRANSFORMLIST_H__
diff --git a/content/svg/content/src/nsSVGAnimationElement.cpp b/content/svg/content/src/nsSVGAnimationElement.cpp
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGAnimationElement.cpp
@@ -0,0 +1,373 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGAnimationElement.h"
+#include "nsSVGSVGElement.h"
+#include "nsISMILAnimationRegistry.h"
+#include "nsISMILAttr.h"
+#include "nsISMILComposable.h"
+#include "nsISMILTimeClient.h"
+#include "nsBindingManager.h"
+
+//----------------------------------------------------------------------
+// nsISupports methods
+
+NS_IMPL_ADDREF_INHERITED(nsSVGAnimationElement, nsSVGAnimationElementBase)
+NS_IMPL_RELEASE_INHERITED(nsSVGAnimationElement, nsSVGAnimationElementBase)
+
+NS_INTERFACE_MAP_BEGIN(nsSVGAnimationElement)
+  NS_INTERFACE_MAP_ENTRY(nsISVGAnimationElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMElementTimeControl)
+NS_INTERFACE_MAP_END_INHERITING(nsSVGAnimationElementBase)
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSVGAnimationElement::nsSVGAnimationElement(nsINodeInfo *aNodeInfo)
+  : nsSVGAnimationElementBase(aNodeInfo)
+{
+}
+
+nsresult
+nsSVGAnimationElement::Init()
+{
+  nsresult rv = nsSVGAnimationElementBase::Init();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  mAnimation = NS_NewSMILAnimationFunction(this);
+  NS_ENSURE_TRUE(mAnimation, NS_ERROR_FAILURE);
+
+  mTimedElement = NS_NewSMILTimedElement();
+  NS_ENSURE_TRUE(mTimedElement, NS_ERROR_FAILURE);
+
+  mTimeControl = do_QueryInterface(mTimedElement);
+  NS_ENSURE_TRUE(mTimeControl, NS_ERROR_FAILURE);
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// nsIDOMSVGAnimationElement methods
+
+/* readonly attribute SVGElement targetElement; */
+NS_IMETHODIMP
+nsSVGAnimationElement::GetTargetElement(nsIDOMSVGElement** aTarget)
+{
+  if (mTargetElement) {
+    nsCOMPtr<nsIDOMSVGElement> target = do_QueryReferent(mTargetElement);
+    NS_IF_RELEASE(*aTarget);
+    NS_IF_ADDREF(*aTarget = target);
+  } else {
+    *aTarget = nsnull;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSVGAnimationElement::GetStartTime(float* retval)
+{
+  // XXX
+  (void)retval;
+  NS_NOTYETIMPLEMENTED("nsSVGAnimationElement::GetStartTime");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsSVGAnimationElement::GetCurrentTime(float* retval)
+{
+  // XXX
+  (void)retval;
+  NS_NOTYETIMPLEMENTED("nsSVGAnimationElement::GetCurrentTime");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsSVGAnimationElement::GetSimpleDuration(float* retval)
+{
+  // XXX
+  (void)retval;
+  NS_NOTYETIMPLEMENTED("nsSVGAnimationElement::GetSimpleDuration");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+//----------------------------------------------------------------------
+// nsISVGContent methods
+
+nsresult
+nsSVGAnimationElement::BindToTree(nsIDocument* aDocument,
+                                  nsIContent* aParent,
+                                  nsIContent* aBindingParent,
+                                  PRBool aCompileEventHandlers)
+{
+  nsresult rv = nsSVGAnimationElementBase::BindToTree(aDocument, aParent,
+                                                      aBindingParent,
+                                                      aCompileEventHandlers);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  // XXXdholbert is ownerDOMSVG (as a check for SVG parent) still needed here?
+  nsCOMPtr<nsIDOMSVGSVGElement> ownerDOMSVG;
+  rv = GetOwnerSVGElement(getter_AddRefs(ownerDOMSVG));
+
+  if (NS_FAILED(rv) || !ownerDOMSVG)
+    // No use proceeding. We don't have an SVG parent (yet) so we won't be able
+    // to register ourselves etc. Maybe next time we'll have more luck.
+    // (This sort of situation will arise a lot when trees are being constructed
+    // piece by piece via script)
+    return NS_OK;
+
+  nsCOMPtr<nsISMILAnimationRegistry> registry = GetAnimationRegistry();
+  if (!registry)
+    // Registry hasn't been created yet. This will be created when the SVG
+    // parent is bound.
+    return NS_OK;
+
+  UpdateTargetElement();
+
+  rv = registry->RegisterTimedElement(mTimedElement);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  return rv;
+}
+
+void
+nsSVGAnimationElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
+{
+  nsCOMPtr<nsISMILAnimationRegistry> registry = GetAnimationRegistry();
+
+  if (mAnimation->GetTargetAttribute()) {
+      if (registry) {
+        nsCOMPtr<nsISMILComposable> composable(do_QueryInterface(mAnimation));
+        registry->UnregisterComposable(composable);
+      }
+      mAnimation->SetTargetAttribute(nsnull);
+  }
+
+  if (registry)
+    registry->UnregisterTimedElement(mTimedElement);
+
+  nsSVGAnimationElementBase::UnbindFromTree(aDeep, aNullParent);
+}
+
+//----------------------------------------------------------------------
+// nsIContent methods
+
+PRBool
+nsSVGAnimationElement::ParseAttribute(PRInt32 aNamespaceID,
+                                      nsIAtom* aAttribute,
+                                      const nsAString& aValue,
+                                      nsAttrValue& aResult)
+{
+  PRBool result = PR_FALSE;
+
+  if (aNamespaceID == kNameSpaceID_None)
+  {
+    result = mAnimation->SetAttr(aAttribute, aValue); 
+
+    if (!result)
+      mTimedElement->SetAttr(aAttribute, aValue);
+
+    if (result)
+      aResult.SetTo(aValue);
+  }
+
+  return nsSVGAnimationElementBase::ParseAttribute(aNamespaceID, aAttribute,
+                                                   aValue, aResult);
+}
+
+nsresult
+nsSVGAnimationElement::UnsetAttr(PRInt32 aNamespaceID,
+                                 nsIAtom* aAttribute, PRBool aNotify)
+{
+  nsresult rv = nsSVGAnimationElementBase::UnsetAttr(aNamespaceID, aAttribute,
+                                                     aNotify);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (aNamespaceID == kNameSpaceID_None)
+  {
+    if (!mAnimation->UnsetAttr(aAttribute))
+      mTimedElement->UnsetAttr(aAttribute);
+  }
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+nsISMILAnimationRegistry*
+nsSVGAnimationElement::GetAnimationRegistry()
+{
+  nsISMILAnimationRegistry*     result = nsnull;
+  nsCOMPtr<nsIDOMSVGSVGElement> ownerDOMSVG;
+
+  nsresult rv = GetOwnerSVGElement(getter_AddRefs(ownerDOMSVG));
+
+  if (NS_SUCCEEDED(rv) && ownerDOMSVG) {
+    nsSVGSVGElement *ownerSVG =
+      static_cast<nsSVGSVGElement*>(ownerDOMSVG.get());
+    result = ownerSVG->GetAnimationRegistry();
+  }
+
+  return result;
+}
+
+nsIContent*
+nsSVGAnimationElement::GetParentElement()
+{
+  nsCOMPtr<nsIContent> result;
+  nsBindingManager*   bindingManager = nsnull;
+  nsIDocument*        ownerDoc = GetOwnerDoc();
+
+  if (ownerDoc)
+    bindingManager = ownerDoc->BindingManager();
+
+  if (bindingManager)
+    // we have a binding manager -- do we have an anonymous parent?
+    result = bindingManager->GetInsertionParent(this);
+
+  if (!result)
+    // if we didn't find an anonymous parent, use the explicit one,
+    // whether it's null or not...
+    result = GetParent();
+
+  return result;
+}
+
+void
+nsSVGAnimationElement::UpdateTargetElement()
+{
+  // XXX Follow xlink:href attributes when provided
+  
+  nsCOMPtr<nsIContent> target = GetParentElement();
+  if (!target)
+    return;
+
+  nsWeakPtr targetElement = do_GetWeakReference(target);
+  if (mTargetElement != targetElement || !mAnimation->GetTargetAttribute()) {
+    // XXXdholbert If targetElement has changed, remove my animation effects
+    // from mTargetElement here before we lose a handle on it.
+    mTargetElement = targetElement;
+    UpdateTargetAttribute();
+  }
+}
+
+void
+nsSVGAnimationElement::UpdateTargetAttribute()
+{
+  nsresult rv;
+  
+  if (mTargetElement) {
+    nsRefPtr<nsISMILAttr> prevAttribute = mAnimation->GetTargetAttribute();
+    nsRefPtr<nsISMILAttr> targetAttribute = GetTargetAttribute();
+
+    rv = mAnimation->SetTargetAttribute(targetAttribute);
+    NS_ENSURE_SUCCESS(rv,);
+
+    SetAnimationProperties();
+
+    nsCOMPtr<nsISMILTimeClient> timeClient( do_QueryInterface(mAnimation) );
+    NS_ENSURE_TRUE(timeClient,);
+    mTimedElement->SetTimeClient(timeClient);
+
+    if (targetAttribute != prevAttribute) {
+      nsCOMPtr<nsISMILAnimationRegistry> registry = GetAnimationRegistry();
+      NS_ENSURE_TRUE(registry,);
+
+      nsCOMPtr<nsISMILComposable> composable( do_QueryInterface(mAnimation) );
+      NS_ENSURE_TRUE(composable,);
+
+      if (prevAttribute)
+        registry->UnregisterComposable(composable);
+
+      if (targetAttribute)
+        registry->RegisterComposable(targetAttribute, composable);
+    }
+  }
+}
+
+void
+nsSVGAnimationElement::SetAnimationProperties()
+{
+  NS_ENSURE_TRUE(mAnimation,);
+  if (!mAnimation->GetTargetAttribute())
+    return;
+
+  nsIAtom** property = GetAnimationProperties();
+  nsAutoString attrValue;
+  while (*property) {
+    nsIAtom* atom = *property++;
+    if (HasAttr(kNameSpaceID_None, atom)) {
+      if (NS_SUCCEEDED(GetAttr(kNameSpaceID_None, atom, attrValue)))
+        mAnimation->SetAttr(atom, attrValue);
+    }
+  }
+}
+
+// nsIDOMElementTimeControl
+/* boolean beginElement (); */
+NS_IMETHODIMP
+nsSVGAnimationElement::BeginElement(PRBool *_retval)
+{
+  RequestSample();
+  return mTimeControl->BeginElement(_retval);
+}
+
+/* boolean beginElementAt (in float offset); */
+NS_IMETHODIMP
+nsSVGAnimationElement::BeginElementAt(float offset, PRBool *_retval)
+{
+  RequestSample();
+  return mTimeControl->BeginElementAt(offset, _retval);
+}
+
+/* boolean endElement (); */
+NS_IMETHODIMP
+nsSVGAnimationElement::EndElement(PRBool *_retval)
+{
+  RequestSample();
+  return mTimeControl->EndElement(_retval);
+}
+
+/* boolean endElementAt (in float offset); */
+NS_IMETHODIMP
+nsSVGAnimationElement::EndElementAt(float offset, PRBool *_retval)
+{
+  RequestSample();
+  return mTimeControl->EndElementAt(offset, _retval);
+}
diff --git a/content/svg/content/src/nsSVGAnimationElement.h b/content/svg/content/src/nsSVGAnimationElement.h
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGAnimationElement.h
@@ -0,0 +1,101 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SVGANIMATIONELEMENT_H__
+#define __NS_SVGANIMATIONELEMENT_H__
+
+#include "nsSVGElement.h"
+#include "nsIDOMSVGAnimationElement.h"
+#include "nsIDOMElementTimeControl.h"
+#include "nsISVGAnimationElement.h"
+#include "nsISMILAnimationFunction.h"
+#include "nsISMILTimedElement.h"
+
+class nsISMILAnimationRegistry;
+
+typedef nsSVGElement nsSVGAnimationElementBase;
+
+class nsSVGAnimationElement : public nsSVGAnimationElementBase,
+                              public nsISVGAnimationElement,
+                              public nsIDOMElementTimeControl
+{
+protected:
+  nsSVGAnimationElement(nsINodeInfo *aNodeInfo);
+  nsresult Init();
+
+public:
+  // interfaces:  
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIDOMSVGANIMATIONELEMENT
+  NS_DECL_NSIDOMELEMENTTIMECONTROL
+
+  // nsISVGContent specializations
+  virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
+                              nsIContent* aBindingParent,
+                              PRBool aCompileEventHandlers);
+  virtual void UnbindFromTree(PRBool aDeep = PR_TRUE,
+                              PRBool aNullParent = PR_TRUE);
+
+  // nsIContent specializations
+  virtual nsresult UnsetAttr(PRInt32 aNamespaceID, nsIAtom* aAttribute,
+                             PRBool aNotify);
+
+  // nsGenericElement specializations
+  virtual PRBool ParseAttribute(PRInt32 aNamespaceID,
+                                nsIAtom* aAttribute,
+                                const nsAString& aValue,
+                                nsAttrValue& aResult);
+
+protected:
+  // Implementation helpers
+  nsISMILAnimationRegistry*          GetAnimationRegistry();
+  nsIContent*                        GetParentElement();
+  void                               UpdateTargetElement();
+  void                               UpdateTargetAttribute();
+  void                               SetAnimationProperties();
+
+  virtual already_AddRefed<nsISMILAttr> GetTargetAttribute() = 0;
+  virtual nsIAtom** GetAnimationProperties() = 0;
+
+  nsWeakPtr                          mTargetElement;
+  nsRefPtr<nsISMILAnimationFunction> mAnimation;
+  nsCOMPtr<nsISMILTimedElement>      mTimedElement;
+  nsCOMPtr<nsIDOMElementTimeControl> mTimeControl; // QI'ed version of the above
+};
+
+#endif // __NS_SVGANIMATIONELEMENT_H__
diff --git a/content/svg/content/src/nsSVGElement.cpp b/content/svg/content/src/nsSVGElement.cpp
--- a/content/svg/content/src/nsSVGElement.cpp
+++ b/content/svg/content/src/nsSVGElement.cpp
@@ -82,16 +82,17 @@
 #include "nsIDOMSVGPointList.h"
 #include "nsIDOMSVGAnimatedPoints.h"
 #include "nsIDOMSVGPresAspectRatio.h"
 #include "nsIDOMSVGAnimPresAspRatio.h"
 #include "nsIDOMSVGTransformList.h"
 #include "nsIDOMSVGAnimTransformList.h"
 #include "nsIDOMSVGAnimatedRect.h"
 #include "nsSVGRect.h"
+#include "nsIFrame.h"
 #include "prdtoa.h"
 #include <stdarg.h>
 
 nsSVGEnumMapping nsSVGElement::sSVGUnitTypesMap[] = {
   {&nsGkAtoms::userSpaceOnUse, nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_USERSPACEONUSE},
   {&nsGkAtoms::objectBoundingBox, nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX},
   {nsnull, 0}
 };
@@ -1184,16 +1185,29 @@ nsSVGElement::DidChangeLength(PRUint8 aA
   nsAutoString newStr;
   info.mLengths[aAttrEnum].GetBaseValueString(newStr);
 
   SetAttr(kNameSpaceID_None, *info.mLengthInfo[aAttrEnum].mName,
           newStr, PR_TRUE);
 }
 
 void
+nsSVGElement::DidAnimateLength(PRUint8 aAttrEnum)
+{
+  nsIFrame* frame = GetPrimaryFrame();
+
+  if (frame) {
+    LengthAttributesInfo info = GetLengthInfo();
+    frame->AttributeChanged(kNameSpaceID_None,
+                            *info.mLengthInfo[aAttrEnum].mName,
+                            nsIDOMMutationEvent::MODIFICATION);
+  }
+}
+
+void
 nsSVGElement::GetAnimatedLengthValues(float *aFirst, ...)
 {
   LengthAttributesInfo info = GetLengthInfo();
 
   NS_ASSERTION(info.mLengthCount > 0,
                "GetAnimatedLengthValues on element with no length attribs");
 
   nsSVGSVGElement *ctx = nsnull;
@@ -1568,8 +1582,76 @@ nsSVGElement::RecompileScriptEventListen
       continue;
     }
 
     nsAutoString value;
     GetAttr(kNameSpaceID_None, attr, value);
     AddScriptEventListener(GetEventNameForAttr(attr), value, PR_TRUE);
   }
 }
+
+#ifdef MOZ_SMIL
+nsISMILAnimationController*
+nsSVGElement::GetAnimationController(nsIDocument* aDocument,
+                                        PRBool aCreate /* = PR_FALSE */)
+{
+  nsISMILAnimationController* result = nsnull;
+
+  NS_ENSURE_TRUE(aDocument, nsnull);
+
+  nsIPresShell* presShell = aDocument->GetPrimaryShell();
+  if (!presShell)
+    return nsnull;
+
+  nsPresContext* context = presShell->GetPresContext();
+  NS_ENSURE_TRUE(context, nsnull);
+  NS_ENSURE_TRUE(context->SMILEnabled(), nsnull);
+
+  nsIAnimationController* controller = context->GetAnimationController();
+
+  if (controller) {
+    nsresult rv = CallQueryInterface(controller, &result);
+    NS_ENSURE_SUCCESS(rv, nsnull);
+  } else if (aCreate) {
+    result = NS_NewSMILAnimationController(aDocument);
+    context->SetAnimationController(result);
+  }
+
+  return result;
+}
+
+// This should be overridden as necessary, e.g. to ensure some attributes are
+// not animatable
+already_AddRefed<nsISMILAttr>
+nsSVGElement::GetAnimAttribute(PRInt32 aNamespaceID, const nsIAtom* aAttribute)
+{
+  NS_ENSURE_TRUE(aAttribute, nsnull);
+
+  nsISMILAttr* result = nsnull;
+
+  // XXX Only lengths are supported at present
+
+  if (aNamespaceID == kNameSpaceID_None) {
+    LengthAttributesInfo info = GetLengthInfo();
+    for (PRUint32 i = 0; i < info.mLengthCount && !result; i++) {
+      if (aAttribute == *info.mLengthInfo[i].mName) {
+        if (NS_FAILED(info.mLengths[i].ToSMILAttr(&result, this)))
+          result = nsnull;
+      }
+    }
+  }
+
+  return result;
+}
+
+void nsSVGElement::RequestSample()
+{
+  nsIDocument* doc = GetCurrentDoc();
+  if (doc) {
+    nsCOMPtr<nsISMILAnimationController> smilController = 
+      GetAnimationController(doc, PR_FALSE);
+    if (smilController) {
+      smilController->FireForceSampleEvent();
+    }
+  }
+}
+
+#endif // MOZ_SMIL
diff --git a/content/svg/content/src/nsSVGElement.h b/content/svg/content/src/nsSVGElement.h
--- a/content/svg/content/src/nsSVGElement.h
+++ b/content/svg/content/src/nsSVGElement.h
@@ -48,16 +48,21 @@
 #include "nsCOMPtr.h"
 #include "nsIDOMSVGElement.h"
 #include "nsGenericElement.h"
 #include "nsStyledElement.h"
 #include "nsISVGValue.h"
 #include "nsISVGValueObserver.h"
 #include "nsWeakReference.h"
 #include "nsICSSStyleRule.h"
+
+#ifdef MOZ_SMIL
+#include "nsISMILAnimationController.h"
+#include "nsISMILAttr.h"
+#endif
 
 class nsSVGSVGElement;
 class nsSVGLength2;
 class nsSVGNumber2;
 class nsSVGInteger;
 class nsSVGAngle;
 class nsSVGBoolean;
 class nsSVGEnum;
@@ -135,19 +140,29 @@ public:
   virtual void DidChangeLength(PRUint8 aAttrEnum, PRBool aDoSetAttr);
   virtual void DidChangeNumber(PRUint8 aAttrEnum, PRBool aDoSetAttr);
   virtual void DidChangeInteger(PRUint8 aAttrEnum, PRBool aDoSetAttr);
   virtual void DidChangeAngle(PRUint8 aAttrEnum, PRBool aDoSetAttr);
   virtual void DidChangeBoolean(PRUint8 aAttrEnum, PRBool aDoSetAttr);
   virtual void DidChangeEnum(PRUint8 aAttrEnum, PRBool aDoSetAttr);
   virtual void DidChangeString(PRUint8 aAttrEnum, PRBool aDoSetAttr);
 
+  void DidAnimateLength(PRUint8 aAttrEnum);
+
   void GetAnimatedLengthValues(float *aFirst, ...);
   void GetAnimatedNumberValues(float *aFirst, ...);
   void GetAnimatedIntegerValues(PRInt32 *aFirst, ...);
+
+#ifdef MOZ_SMIL
+  void RequestSample();
+  nsISMILAnimationController*
+  GetAnimationController(nsIDocument* aDocument, PRBool aCreate = PR_FALSE);
+  virtual already_AddRefed<nsISMILAttr>
+  GetAnimAttribute(PRInt32 aNamespaceID, const nsIAtom* aAttribute);
+#endif
 
   virtual void RecompileScriptEventListeners();
 
 protected:
   virtual nsresult BeforeSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
                                  const nsAString* aValue, PRBool aNotify);
   virtual nsresult AfterSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
                                 const nsAString* aValue, PRBool aNotify);
diff --git a/content/svg/content/src/nsSVGElementFactory.cpp b/content/svg/content/src/nsSVGElementFactory.cpp
--- a/content/svg/content/src/nsSVGElementFactory.cpp
+++ b/content/svg/content/src/nsSVGElementFactory.cpp
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Crocodile Clips Ltd..
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Alex Fritze <alex.fritze@crocodile-clips.com> (original author)
+ *   Chris Double  <chris.double@double.co.nz>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -154,16 +155,25 @@ NS_NewSVGFEDiffuseLightingElement(nsICon
 NS_NewSVGFEDiffuseLightingElement(nsIContent **aResult, nsINodeInfo *aNodeInfo);
 nsresult
 NS_NewSVGFESpecularLightingElement(nsIContent **aResult, nsINodeInfo *aNodeInfo);
 nsresult
 NS_NewSVGFEImageElement(nsIContent **aResult, nsINodeInfo *aNodeInfo);
 nsresult
 NS_NewSVGFEDisplacementMapElement(nsIContent **aResult, nsINodeInfo *aNodeInfo);
 
+#ifdef MOZ_SMIL
+nsresult
+NS_NewSVGAnimateElement(nsIContent **aResult, nsINodeInfo *aNodeInfo);
+nsresult
+NS_NewSVGAnimateTransformElement(nsIContent **aResult, nsINodeInfo *aNodeInfo);
+nsresult
+NS_NewSVGSetElement(nsIContent **aResult, nsINodeInfo *aNodeInfo);
+#endif // MOZ_SMIL
+
 nsresult
 NS_NewSVGElement(nsIContent** aResult, nsINodeInfo *aNodeInfo)
 {
   NS_PRECONDITION(NS_SVGEnabled(),
                   "creating an SVG element while SVG disabled");
 
   static const char kSVGStyleSheetURI[] = "resource://gre/res/svg.css";
 
@@ -281,13 +291,21 @@ NS_NewSVGElement(nsIContent** aResult, n
   if (name == nsGkAtoms::feDisplacementMap)
     return NS_NewSVGFEDisplacementMapElement(aResult, aNodeInfo);
   if (name == nsGkAtoms::pattern)
     return NS_NewSVGPatternElement(aResult, aNodeInfo);
   if (name == nsGkAtoms::mask)
     return NS_NewSVGMaskElement(aResult, aNodeInfo);
   if (name == nsGkAtoms::svgSwitch)
     return NS_NewSVGSwitchElement(aResult, aNodeInfo);
+#ifdef MOZ_SMIL
+  if (name == nsGkAtoms::animate)
+    return NS_NewSVGAnimateElement(aResult, aNodeInfo);
+  if (name == nsGkAtoms::animateTransform)
+    return NS_NewSVGAnimateTransformElement(aResult, aNodeInfo);
+  if (name == nsGkAtoms::set)
+    return NS_NewSVGSetElement(aResult, aNodeInfo);
+#endif // MOZ_SMIL
 
   // if we don't know what to create, just create a standard xml element:
   return NS_NewXMLElement(aResult, aNodeInfo);
 }
 
diff --git a/content/svg/content/src/nsSVGLength2.cpp b/content/svg/content/src/nsSVGLength2.cpp
--- a/content/svg/content/src/nsSVGLength2.cpp
+++ b/content/svg/content/src/nsSVGLength2.cpp
@@ -37,25 +37,34 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsSVGLength2.h"
 #include "prdtoa.h"
 #include "nsTextFormatter.h"
 #include "nsSVGSVGElement.h"
 #include "nsIFrame.h"
 #include "nsSVGIntegrationUtils.h"
+#ifdef MOZ_SMIL
+#include "nsSMILValue.h"
+#include "nsSMILFloatType.h"
+#endif // MOZ_SMIL
 
 NS_IMPL_ADDREF(nsSVGLength2::DOMBaseVal)
 NS_IMPL_RELEASE(nsSVGLength2::DOMBaseVal)
 
 NS_IMPL_ADDREF(nsSVGLength2::DOMAnimVal)
 NS_IMPL_RELEASE(nsSVGLength2::DOMAnimVal)
 
 NS_IMPL_ADDREF(nsSVGLength2::DOMAnimatedLength)
 NS_IMPL_RELEASE(nsSVGLength2::DOMAnimatedLength)
+
+#ifdef MOZ_SMIL
+NS_IMPL_ADDREF(nsSVGLength2::SMILLength)
+NS_IMPL_RELEASE(nsSVGLength2::SMILLength)
+#endif // MOZ_SMIL
 
 NS_INTERFACE_MAP_BEGIN(nsSVGLength2::DOMBaseVal)
   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGLength)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGLength)
 NS_INTERFACE_MAP_END
 
 NS_INTERFACE_MAP_BEGIN(nsSVGLength2::DOMAnimVal)
@@ -64,16 +73,23 @@ NS_INTERFACE_MAP_BEGIN(nsSVGLength2::DOM
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGLength)
 NS_INTERFACE_MAP_END
 
 NS_INTERFACE_MAP_BEGIN(nsSVGLength2::DOMAnimatedLength)
   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimatedLength)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGAnimatedLength)
 NS_INTERFACE_MAP_END
+
+#ifdef MOZ_SMIL
+NS_INTERFACE_MAP_BEGIN(nsSVGLength2::SMILLength)
+   NS_INTERFACE_MAP_ENTRY(nsISMILAttr)
+   NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_MAP_END
+#endif // MOZ_SMIL
 
 static nsIAtom** const unitMap[] =
 {
   nsnull, /* SVG_LENGTHTYPE_UNKNOWN */
   nsnull, /* SVG_LENGTHTYPE_NUMBER */
   &nsGkAtoms::percentage,
   &nsGkAtoms::em,
   &nsGkAtoms::ex,
@@ -397,19 +413,86 @@ nsSVGLength2::GetAnimValueString(nsAStri
 
 void
 nsSVGLength2::SetBaseValue(float aValue, nsSVGElement *aSVGElement)
 {
   mAnimVal = mBaseVal = aValue * GetUnitScaleFactor(aSVGElement);
   aSVGElement->DidChangeLength(mAttrEnum, PR_TRUE);
 }
 
+void
+nsSVGLength2::SetAnimValue(float aValue, nsSVGElement *aSVGElement)
+{
+  mAnimVal = aValue * GetUnitScaleFactor(aSVGElement);
+  aSVGElement->DidAnimateLength(mAttrEnum);
+}
+
 nsresult
 nsSVGLength2::ToDOMAnimatedLength(nsIDOMSVGAnimatedLength **aResult,
                                   nsSVGElement *aSVGElement)
 {
   *aResult = new DOMAnimatedLength(this, aSVGElement);
   if (!*aResult)
     return NS_ERROR_OUT_OF_MEMORY;
 
   NS_ADDREF(*aResult);
   return NS_OK;
 }
+
+#ifdef MOZ_SMIL
+
+nsresult
+nsSVGLength2::ToSMILAttr(nsISMILAttr **aAttr, nsSVGElement *aSVGElement)
+{
+  *aAttr = new SMILLength(this, aSVGElement);
+  if (!*aAttr)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  NS_ADDREF(*aAttr);
+  return NS_OK;
+}
+
+/*static*/
+nsSVGLength2::SMILLength nsSVGLength2::SMILLength::sSingleton(nsnull, nsnull);
+
+nsresult
+nsSVGLength2::SMILLength::GetBaseValue(nsSMILValue& aValue)
+{
+  nsSMILValue val(&nsSMILFloatType::sSingleton);
+  val.mU.mDouble = mVal->GetBaseValue(mSVGElement);
+  aValue = val;
+  return NS_OK;
+}
+
+nsresult
+nsSVGLength2::SMILLength::SetAnimValue(const nsSMILValue& aValue)
+{
+  NS_ASSERTION(aValue.mType == &nsSMILFloatType::sSingleton,
+    "Unexpected type to assign animated value");
+  if (aValue.mType == &nsSMILFloatType::sSingleton)
+    mVal->SetAnimValue((float)aValue.mU.mDouble, mSVGElement);
+  return NS_OK;
+}
+
+nsresult
+nsSVGLength2::SMILLength::ValueFromString(const nsAString& aStr,
+                                          nsSMILValue& aValue)
+{
+  nsSVGLength2 tmp;
+  tmp.SetBaseValueString(aStr, mSVGElement, PR_FALSE);
+
+  nsSMILValue val(&nsSMILFloatType::sSingleton);
+  val.mU.mDouble = tmp.GetBaseValue(mSVGElement);
+  aValue = val;
+  return NS_OK;
+}
+
+PRBool
+nsSVGLength2::SMILLength::EqualsTarget(const nsISMILAttr &aOther) const
+{
+  if (aOther.mType != &sSingleton)
+    return PR_FALSE;
+
+  SMILLength const *other = static_cast<SMILLength const *>(&aOther);
+  return (mVal == other->mVal);
+}
+
+#endif // MOZ_SMIL
diff --git a/content/svg/content/src/nsSVGLength2.h b/content/svg/content/src/nsSVGLength2.h
--- a/content/svg/content/src/nsSVGLength2.h
+++ b/content/svg/content/src/nsSVGLength2.h
@@ -38,16 +38,21 @@
 #define __NS_SVGLENGTH2_H__
 
 #include "nsIDOMSVGLength.h"
 #include "nsIDOMSVGAnimatedLength.h"
 #include "nsSVGUtils.h"
 #include "nsSVGElement.h"
 #include "nsDOMError.h"
 
+#ifdef MOZ_SMIL
+#include "nsISMILAttr.h"
+struct nsSMILValue;
+#endif // MOZ_SMIL
+
 class nsIFrame;
 
 class nsSVGLength2
 {
 
 public:
   void Init(PRUint8 aCtxType = nsSVGUtils::XY,
             PRUint8 aAttrEnum = 0xff,
@@ -82,16 +87,19 @@ public:
 
   float GetBaseValue(nsSVGSVGElement* aCtx) const
     { return mBaseVal / GetUnitScaleFactor(aCtx); }
   float GetAnimValue(nsSVGSVGElement* aCtx) const
     { return mAnimVal / GetUnitScaleFactor(aCtx); }
   
   nsresult ToDOMAnimatedLength(nsIDOMSVGAnimatedLength **aResult,
                                nsSVGElement* aSVGElement);
+#ifdef MOZ_SMIL
+  nsresult ToSMILAttr(nsISMILAttr **aAttr, nsSVGElement* aSVGElement);
+#endif // MOZ_SMIL
 
 private:
   
   float mAnimVal;
   float mBaseVal;
   PRUint8 mSpecifiedUnitType;
   PRUint8 mAttrEnum; // element specified tracking for attribute
   PRUint8 mCtxType; // X, Y or Unspecified
@@ -110,16 +118,17 @@ private:
   float GetEmLength(nsSVGElement *aSVGElement) const
     { return nsSVGUtils::GetFontSize(aSVGElement); }
   float GetExLength(nsSVGElement *aSVGElement) const
     { return nsSVGUtils::GetFontXHeight(aSVGElement); }
   float GetUnitScaleFactor(nsSVGElement *aSVGElement) const;
   float GetUnitScaleFactor(nsSVGSVGElement *aCtx) const;
   void SetBaseValue(float aValue, nsSVGElement *aSVGElement);
   void SetBaseValueInSpecifiedUnits(float aValue, nsSVGElement *aSVGElement);
+  void SetAnimValue(float aValue, nsSVGElement *aSVGElement);
   void NewValueSpecifiedUnits(PRUint16 aUnitType, float aValue,
                               nsSVGElement *aSVGElement);
   void ConvertToSpecifiedUnits(PRUint16 aUnitType, nsSVGElement *aSVGElement);
   nsresult ToDOMBaseVal(nsIDOMSVGLength **aResult, nsSVGElement* aSVGElement);
   nsresult ToDOMAnimVal(nsIDOMSVGLength **aResult, nsSVGElement* aSVGElement);
 
   struct DOMBaseVal : public nsIDOMSVGLength
   {
@@ -207,11 +216,33 @@ private:
     nsRefPtr<nsSVGElement> mSVGElement;
 
     NS_IMETHOD GetBaseVal(nsIDOMSVGLength **aBaseVal)
       { return mVal->ToDOMBaseVal(aBaseVal, mSVGElement); }
 
     NS_IMETHOD GetAnimVal(nsIDOMSVGLength **aAnimVal)
       { return mVal->ToDOMAnimVal(aAnimVal, mSVGElement); }
   };
+
+#ifdef MOZ_SMIL
+  struct SMILLength : public nsISMILAttr
+  {
+  public:
+    NS_DECL_ISUPPORTS
+
+    SMILLength(nsSVGLength2* aVal, nsSVGElement *aSVGElement)
+      : nsISMILAttr(&sSingleton), mVal(aVal), mSVGElement(aSVGElement) {}
+
+    nsSVGLength2* mVal; // kept alive because it belongs to content
+    nsRefPtr<nsSVGElement> mSVGElement;
+
+    virtual nsresult  GetBaseValue(nsSMILValue& aValue);
+    virtual nsresult  SetAnimValue(const nsSMILValue& aValue);
+    virtual nsresult  ValueFromString(const nsAString& aStr,
+                                      nsSMILValue &aValue);
+    virtual PRBool    EqualsTarget(const nsISMILAttr &aOther) const;
+  private:
+    static SMILLength sSingleton; // Type checking only
+  };
+#endif // MOZ_SMIL
 };
 
 #endif
diff --git a/content/svg/content/src/nsSVGSVGElement.cpp b/content/svg/content/src/nsSVGSVGElement.cpp
--- a/content/svg/content/src/nsSVGSVGElement.cpp
+++ b/content/svg/content/src/nsSVGSVGElement.cpp
@@ -17,16 +17,17 @@
  * The Initial Developer of the Original Code is
  * Crocodile Clips Ltd..
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Alex Fritze <alex.fritze@crocodile-clips.com> (original author)
  *   Jonathan Watt <jonathan.watt@strath.ac.uk>
+ *   Chris Double  <chris.double@double.co.nz>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -59,16 +60,27 @@
 #include "nsSVGPreserveAspectRatio.h"
 #include "nsISVGValueUtils.h"
 #include "nsDOMError.h"
 #include "nsISVGChildFrame.h"
 #include "nsGUIEvent.h"
 #include "nsSVGUtils.h"
 #include "nsSVGSVGElement.h"
 
+#ifdef MOZ_SMIL
+#include "nsEventDispatcher.h"
+#include "nsISMILAnimationController.h"
+#include "nsISMILAnimationRegistry.h"
+#include "nsISVGAnimationElement.h"
+#include "nsIContentIterator.h"
+
+nsresult NS_NewContentIterator(nsIContentIterator** aInstancePtrResult);
+#endif // MOZ_SMIL
+
+
 nsSVGElement::LengthInfo nsSVGSVGElement::sLengthInfo[4] =
 {
   { &nsGkAtoms::x, 0, nsIDOMSVGLength::SVG_LENGTHTYPE_NUMBER, nsSVGUtils::X },
   { &nsGkAtoms::y, 0, nsIDOMSVGLength::SVG_LENGTHTYPE_NUMBER, nsSVGUtils::Y },
   { &nsGkAtoms::width, 100, nsIDOMSVGLength::SVG_LENGTHTYPE_PERCENTAGE, nsSVGUtils::X },
   { &nsGkAtoms::height, 100, nsIDOMSVGLength::SVG_LENGTHTYPE_PERCENTAGE, nsSVGUtils::Y },
 };
 
@@ -97,16 +109,19 @@ NS_INTERFACE_MAP_BEGIN(nsSVGSVGElement)
 NS_INTERFACE_MAP_BEGIN(nsSVGSVGElement)
   NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
   NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGSVGElement)
   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFitToViewBox)
   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGLocatable)
   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGZoomAndPan)
+#ifdef MOZ_SMIL
+  NS_INTERFACE_MAP_ENTRY(nsISMILAnimationObserver)
+#endif // MOZ_SMIL
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGSVGElement)
 NS_INTERFACE_MAP_END_INHERITING(nsSVGSVGElementBase)
 
 //----------------------------------------------------------------------
 // Implementation
 
 nsSVGSVGElement::nsSVGSVGElement(nsINodeInfo* aNodeInfo)
   : nsSVGSVGElementBase(aNodeInfo),
@@ -446,51 +461,84 @@ nsSVGSVGElement::ForceRedraw()
 
   return NS_OK;
 }
 
 /* void pauseAnimations (); */
 NS_IMETHODIMP
 nsSVGSVGElement::PauseAnimations()
 {
+#ifdef MOZ_SMIL
+  NS_ENSURE_TRUE(mAnimationRegistry, NS_ERROR_FAILURE);
+  mAnimationRegistry->Pause();
+  return NS_OK;
+#else
   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::PauseAnimations");
   return NS_ERROR_NOT_IMPLEMENTED;
+#endif
 }
 
 /* void unpauseAnimations (); */
 NS_IMETHODIMP
 nsSVGSVGElement::UnpauseAnimations()
 {
+#ifdef MOZ_SMIL
+  NS_ENSURE_TRUE(mAnimationRegistry, NS_ERROR_FAILURE);
+  mAnimationRegistry->Unpause();
+  return NS_OK;
+#else
   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::UnpauseAnimations");
   return NS_ERROR_NOT_IMPLEMENTED;
+#endif
 }
 
 /* boolean animationsPaused (); */
 NS_IMETHODIMP
 nsSVGSVGElement::AnimationsPaused(PRBool *_retval)
 {
+#ifdef MOZ_SMIL
+  NS_ENSURE_TRUE(mAnimationRegistry, NS_ERROR_FAILURE);
+  *_retval = mAnimationRegistry->IsPaused();
+  return NS_OK;
+#else
   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::AnimationsPaused");
   return NS_ERROR_NOT_IMPLEMENTED;
+#endif
 }
 
 /* float getCurrentTime (); */
 NS_IMETHODIMP
 nsSVGSVGElement::GetCurrentTime(float *_retval)
 {
+#ifdef MOZ_SMIL
+  NS_ENSURE_TRUE(mAnimationRegistry, NS_ERROR_FAILURE);
+  *_retval = mAnimationRegistry->GetCurrentTime();
+  return NS_OK;
+#else
   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetCurrentTime");
   return NS_ERROR_NOT_IMPLEMENTED;
+#endif
 }
 
 /* void setCurrentTime (in float seconds); */
 NS_IMETHODIMP
 nsSVGSVGElement::SetCurrentTime(float seconds)
 {
+#ifdef MOZ_SMIL
+  NS_ENSURE_TRUE(mAnimationRegistry, NS_ERROR_FAILURE);
+  nsresult rv = mAnimationRegistry->SetCurrentTime(seconds);
+  if (NS_SUCCEEDED(rv)) {
+    RequestSample();
+  }
+  return rv;
+#else
   NS_ENSURE_FINITE(seconds, NS_ERROR_ILLEGAL_VALUE);
   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::SetCurrentTime");
   return NS_ERROR_NOT_IMPLEMENTED;
+#endif
 }
 
 /* nsIDOMNodeList getIntersectionList (in nsIDOMSVGRect rect, in nsIDOMSVGElement referenceElement); */
 NS_IMETHODIMP
 nsSVGSVGElement::GetIntersectionList(nsIDOMSVGRect *rect,
                                      nsIDOMSVGElement *referenceElement,
                                      nsIDOMNodeList **_retval)
 {
@@ -1072,16 +1120,41 @@ nsSVGSVGElement::GetPreviousTranslate_y(
 }
 
 NS_IMETHODIMP_(float)
 nsSVGSVGElement::GetPreviousScale()
 {
   return mPreviousScale;
 }
 
+#ifdef MOZ_SMIL
+nsISMILAnimationRegistry*
+nsSVGSVGElement::GetAnimationRegistry()
+{
+  nsISMILAnimationRegistry* result = nsnull;
+
+  if (mAnimationRegistry) {
+    result = mAnimationRegistry;
+  } else {
+    // We must not be the outermost SVG element, try to find it
+    nsCOMPtr<nsIDOMSVGSVGElement> outerSVGDOM;
+
+    nsresult rv = GetOwnerSVGElement(getter_AddRefs(outerSVGDOM));
+
+    if (NS_SUCCEEDED(rv) && outerSVGDOM) {
+      nsSVGSVGElement *outerSVG =
+        static_cast<nsSVGSVGElement*>(outerSVGDOM.get());
+      result = outerSVG->GetAnimationRegistry();
+    }
+  }
+
+  return result;
+}
+#endif // MOZ_SMIL
+
 //----------------------------------------------------------------------
 // nsIContent methods
 
 NS_IMETHODIMP_(PRBool)
 nsSVGSVGElement::IsAttributeMapped(const nsIAtom* name) const
 {
   static const MappedAttributeEntry* const map[] = {
     sColorMap,
@@ -1125,16 +1198,31 @@ nsSVGSVGElement::UnsetAttr(PRInt32 aName
   nsSVGSVGElementBase::UnsetAttr(aNamespaceID, aName, aNotify);
 
   if (aNamespaceID == kNameSpaceID_None && aName == nsGkAtoms::viewBox) {
     InvalidateTransformNotifyFrame();
   }
 
   return NS_OK;
 }
+
+//----------------------------------------------------------------------
+// nsIContent methods:
+
+#ifdef MOZ_SMIL
+nsresult
+nsSVGSVGElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
+{
+  if (aVisitor.mEvent->message == NS_SVG_LOAD) {
+    if (mAnimationRegistry)
+      mAnimationRegistry->Start();
+  }
+  return nsSVGSVGElementBase::PreHandleEvent(aVisitor);
+}
+#endif // MOZ_SMIL
 
 //----------------------------------------------------------------------
 // nsISVGValueObserver methods:
 
 NS_IMETHODIMP
 nsSVGSVGElement::WillModifySVGObservable(nsISVGValue* observable,
                                          nsISVGValue::modificationType aModType)
 {
@@ -1263,16 +1351,99 @@ nsSVGSVGElement::GetViewboxToViewportTra
     nsSVGUtils::GetViewBoxTransform(viewportWidth, viewportHeight,
                                     viewboxX, viewboxY,
                                     viewboxWidth, viewboxHeight,
                                     mPreserveAspectRatio);
   xform.swap(*_retval);
 
   return NS_OK;
 }
+
+#ifdef MOZ_SMIL
+PRBool nsSVGSVGElement::SMILEnabledForDoc(nsIDocument *aDocument)
+{
+  if (aDocument) {
+    nsIPresShell *presShell = aDocument->GetPrimaryShell();
+    if (presShell) {
+      nsPresContext *context = presShell->GetPresContext();
+      if (context && context->SMILEnabled()) {
+        return PR_TRUE;
+      }
+    }
+  }
+  return PR_FALSE;
+}
+
+nsresult
+nsSVGSVGElement::BindToTree(nsIDocument* aDocument,
+                            nsIContent* aParent,
+                            nsIContent* aBindingParent,
+                            PRBool aCompileEventHandlers)
+{
+  PRBool smilEnabled = SMILEnabledForDoc(aDocument);
+
+  if (smilEnabled) {
+    nsCOMPtr<nsIDOMSVGSVGElement> outerSVG;
+
+    GetOwnerSVGElement(getter_AddRefs(outerSVG));
+
+    PRBool outermost = (outerSVG == nsnull);
+
+    if (!mAnimationRegistry && outermost) {
+      // We are now the outermost SVG element
+      mAnimationRegistry = NS_NewSMILAnimationRegistry();
+      NS_ENSURE_TRUE(mAnimationRegistry, NS_ERROR_FAILURE);
+      mAnimationRegistry->SetObserver(this);
+    } else if (mAnimationRegistry && !outermost) {
+      mAnimationRegistry = nsnull;
+    }
+  }
+  nsresult rv = nsSVGSVGElementBase::BindToTree(aDocument, aParent,
+                                                aBindingParent,
+                                                aCompileEventHandlers);
+  NS_ENSURE_SUCCESS(rv,rv);
+  if (smilEnabled) {
+    nsCOMPtr<nsISMILAnimationController> smilController = 
+      GetAnimationController(aDocument, PR_TRUE);
+
+    if (mAnimationRegistry && smilController)
+      rv = mAnimationRegistry->SetController(smilController);
+  }
+  return rv;
+}
+
+void
+nsSVGSVGElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
+{
+  if (mAnimationRegistry)
+    mAnimationRegistry->SetController(nsnull);
+
+  nsSVGSVGElementBase::UnbindFromTree(aDeep, aNullParent);
+}
+
+//----------------------------------------------------------------------
+// nsISMILAnimationObserver
+
+void
+nsSVGSVGElement::StartCompositing()
+{
+  PRUint32 retval;
+  if (GetPrimaryFrame()) {
+    SuspendRedraw(0, &retval);
+  }
+}
+
+void
+nsSVGSVGElement::EndCompositing()
+{
+  if (GetPrimaryFrame())
+    UnsuspendRedraw(0);
+}
+
+#endif // MOZ_SMIL
 
 //----------------------------------------------------------------------
 // implementation helpers
 
 // if an ancestor isn't specified, obtains offset from root frame
 void nsSVGSVGElement::GetOffsetToAncestor(nsIContent* ancestor,
                                           float &x, float &y)
 {
diff --git a/content/svg/content/src/nsSVGSVGElement.h b/content/svg/content/src/nsSVGSVGElement.h
--- a/content/svg/content/src/nsSVGSVGElement.h
+++ b/content/svg/content/src/nsSVGSVGElement.h
@@ -44,16 +44,23 @@
 #include "nsIDOMSVGSVGElement.h"
 #include "nsIDOMSVGFitToViewBox.h"
 #include "nsIDOMSVGLocatable.h"
 #include "nsIDOMSVGZoomAndPan.h"
 #include "nsIDOMSVGMatrix.h"
 #include "nsSVGLength2.h"
 #include "nsSVGEnum.h"
 
+#ifdef MOZ_SMIL
+#include "nsISMILAnimationObserver.h"
+
+class nsISMILAnimationController;
+class nsISMILAnimationRegistry;
+#endif // MOZ_SMIL
+
 #define QI_AND_CAST_TO_NSSVGSVGELEMENT(base)                                  \
   (nsCOMPtr<nsIDOMSVGSVGElement>(do_QueryInterface(base)) ?                   \
    static_cast<nsSVGSVGElement*>(base.get()) : nsnull)
 
 typedef nsSVGStylableElement nsSVGSVGElementBase;
 
 class svgFloatSize {
 public:
@@ -68,16 +75,19 @@ public:
   float height;
 };
 
 class nsSVGSVGElement : public nsSVGSVGElementBase,
                         public nsIDOMSVGSVGElement,
                         public nsIDOMSVGFitToViewBox,
                         public nsIDOMSVGLocatable,
                         public nsIDOMSVGZoomAndPan
+#ifdef MOZ_SMIL
+                        , public nsISMILAnimationObserver
+#endif // MOZ_SMIL
 {
   friend class nsSVGOuterSVGFrame;
   friend class nsSVGInnerSVGFrame;
 
 protected:
   friend nsresult NS_NewSVGSVGElement(nsIContent **aResult,
                                       nsINodeInfo *aNodeInfo);
   nsSVGSVGElement(nsINodeInfo* aNodeInfo);
@@ -124,18 +134,25 @@ public:
   /**
    * Retrieve the value of currentScale, currentTranslate.x or
    * currentTranslate.y prior to the last change made to any one of them.
    */
   NS_IMETHOD_(float) GetPreviousTranslate_x();
   NS_IMETHOD_(float) GetPreviousTranslate_y();
   NS_IMETHOD_(float) GetPreviousScale();
 
+#ifdef MOZ_SMIL
+  NS_IMETHOD_(nsISMILAnimationRegistry*) GetAnimationRegistry();
+#endif // MOZ_SMIL
+
   // nsIContent interface
   NS_IMETHOD_(PRBool) IsAttributeMapped(const nsIAtom* aAttribute) const;
+#ifdef MOZ_SMIL
+  virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
+#endif // MOZ_SMIL
 
   virtual nsresult AfterSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
                                 const nsAString* aValue, PRBool aNotify);
   virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
                              PRBool aNotify);
 
   // nsISVGValueObserver
   NS_IMETHOD WillModifySVGObservable(nsISVGValue* observable,
@@ -152,31 +169,49 @@ public:
   float GetMMPerPx(PRUint8 mCtxType = 0);
   already_AddRefed<nsIDOMSVGRect> GetCtxRect();
 
   // public helpers:
   nsresult GetViewboxToViewportTransform(nsIDOMSVGMatrix **_retval);
 
   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
 
+#ifdef MOZ_SMIL
+  // nsISMILAnimationObserver interface
+  virtual void StartSample() {}
+  virtual void StartCompositing();
+  virtual void EndCompositing();
+  virtual void EndSample() {}
+#endif // MOZ_SMIL
+
   svgFloatSize GetViewportSize() {
     return svgFloatSize(mViewportWidth, mViewportHeight);
   }
 
   void SetViewportSize(svgFloatSize& aSize) {
     mViewportWidth  = aSize.width;
     mViewportHeight = aSize.height;
   }
 
 protected:
   // nsSVGElement overrides
   PRBool IsEventName(nsIAtom* aName);
 
+#ifdef MOZ_SMIL
+  PRBool SMILEnabledForDoc(nsIDocument *aDocument);
+  virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
+                              nsIContent* aBindingParent,
+                              PRBool aCompileEventHandlers);
+  virtual void UnbindFromTree(PRBool aDeep = PR_TRUE,
+                              PRBool aNullParent = PR_TRUE);
+#endif // MOZ_SMIL   
+
   // implementation helpers:
   void GetOffsetToAncestor(nsIContent* ancestor, float &x, float &y);
+
   PRBool IsRoot() {
     NS_ASSERTION((IsInDoc() && !GetParent()) ==
                  (GetOwnerDoc() && (GetOwnerDoc()->GetRootContent() == this)),
                  "Can't determine if we're root");
     return IsInDoc() && !GetParent();
   }
 
   // invalidate viewbox -> viewport xform & inform frames
@@ -216,11 +251,16 @@ protected:
   // members below - see the comment in RecordCurrentScaleTranslate
   nsCOMPtr<nsIDOMSVGPoint>          mCurrentTranslate;
   nsCOMPtr<nsIDOMSVGNumber>         mCurrentScale;
   float                             mPreviousTranslate_x;
   float                             mPreviousTranslate_y;
   float                             mPreviousScale;
   PRInt32                           mRedrawSuspendCount;
   PRPackedBool                      mDispatchEvent;
+
+#ifdef MOZ_SMIL
+  // animation
+  nsCOMPtr<nsISMILAnimationRegistry> mAnimationRegistry;
+#endif // MOZ_SMIL
 };
 
 #endif
diff --git a/content/svg/content/src/nsSVGSetElement.cpp b/content/svg/content/src/nsSVGSetElement.cpp
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGSetElement.cpp
@@ -0,0 +1,189 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGAnimationElement.h"
+#include "nsIDOMSVGSetElement.h"
+
+typedef nsSVGAnimationElement nsSVGSetElementBase;
+
+class nsSVGSetElement : public nsSVGSetElementBase,
+                        public nsIDOMSVGSetElement
+{
+protected:
+  friend nsresult NS_NewSVGSetElement(nsIContent **aResult,
+                                      nsINodeInfo *aNodeInfo);
+  nsSVGSetElement(nsINodeInfo* aNodeInfo);
+  nsresult Init();
+
+public:
+  // interfaces:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIDOMSVGSETELEMENT
+
+  NS_FORWARD_NSIDOMNODE(nsSVGSetElementBase::)
+  NS_FORWARD_NSIDOMELEMENT(nsSVGSetElementBase::)
+  NS_FORWARD_NSIDOMSVGELEMENT(nsSVGSetElementBase::)
+  NS_FORWARD_NSIDOMSVGANIMATIONELEMENT(nsSVGSetElementBase::)
+  
+  // nsIContent specializations
+  virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
+                           nsIAtom* aPrefix, const nsAString& aValue,
+                           PRBool aNotify);
+  virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
+                             PRBool aNotify);
+
+  virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
+
+protected:
+  // Implementation helpers
+  virtual already_AddRefed<nsISMILAttr> GetTargetAttribute();
+  virtual nsIAtom** GetAnimationProperties();
+};
+
+NS_IMPL_NS_NEW_SVG_ELEMENT(Set)
+
+
+//----------------------------------------------------------------------
+// nsISupports methods
+
+NS_IMPL_ADDREF_INHERITED(nsSVGSetElement,nsSVGSetElementBase)
+NS_IMPL_RELEASE_INHERITED(nsSVGSetElement,nsSVGSetElementBase)
+
+NS_INTERFACE_MAP_BEGIN(nsSVGSetElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimationElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGSetElement)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGAnimateElement)
+NS_INTERFACE_MAP_END_INHERITING(nsSVGSetElementBase)
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSVGSetElement::nsSVGSetElement(nsINodeInfo *aNodeInfo)
+  : nsSVGSetElementBase(aNodeInfo)
+{
+}
+
+nsresult
+nsSVGSetElement::Init()
+{
+  nsresult rv = nsSVGSetElementBase::Init();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  mAnimation->SetAttr(nsGkAtoms::calcMode, NS_LITERAL_STRING("discrete"), &rv);
+  return rv;
+}
+
+//----------------------------------------------------------------------
+// nsIDOMNode methods
+
+NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGSetElement)
+
+//----------------------------------------------------------------------
+// nsIContent methods
+
+nsresult
+nsSVGSetElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
+                         nsIAtom* aPrefix, const nsAString& aValue,
+                         PRBool aNotify)
+{
+  nsresult rv = nsSVGSetElementBase::SetAttr(aNameSpaceID, aName, aPrefix,
+                                                 aValue, aNotify);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (aNameSpaceID != kNameSpaceID_None)
+    return NS_OK;
+  
+  if (aName == nsGkAtoms::attributeName)
+    UpdateTargetAttribute();
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGSetElement::UnsetAttr(PRInt32 aNameSpaceID,
+                           nsIAtom* aAttribute, PRBool aNotify)
+{
+  nsresult rv = nsSVGSetElementBase::UnsetAttr(aNameSpaceID, aAttribute,
+                                               aNotify);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (aNameSpaceID != kNameSpaceID_None)
+    return NS_OK;
+
+  if (aAttribute == nsGkAtoms::attributeName)
+    UpdateTargetAttribute();
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+already_AddRefed<nsISMILAttr>
+nsSVGSetElement::GetTargetAttribute()
+{
+  nsISMILAttr* result = nsnull;
+
+  if (mTargetElement) {
+    nsAutoString attributeName;
+
+    GetAttr(kNameSpaceID_None, nsGkAtoms::attributeName, attributeName);
+
+    nsCOMPtr<nsIAtom> attributeAtom( do_GetAtom(attributeName) );
+    nsCOMPtr<nsIContent> targetElement(do_QueryReferent(mTargetElement));
+
+    if (targetElement && attributeAtom) {
+      result =
+        static_cast<nsSVGElement*>(targetElement.get())->GetAnimAttribute(kNameSpaceID_None,
+                                                                          attributeAtom).get();
+    }
+  }
+
+  return result;
+}
+
+nsIAtom**
+nsSVGSetElement::GetAnimationProperties()
+{
+  static nsIAtom *atoms[] = { nsGkAtoms::to, nsnull };
+
+  return atoms;
+}
diff --git a/content/svg/content/src/nsSVGTransformSMILAttr.cpp b/content/svg/content/src/nsSVGTransformSMILAttr.cpp
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGTransformSMILAttr.cpp
@@ -0,0 +1,343 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGTransformSMILAttr.h"
+#include "nsSVGTransformSMILType.h"
+#include "nsSVGAnimatedTransformList.h"
+#include "nsIDOMSVGTransform.h"
+#include "nsIDOMSVGMatrix.h"
+#include "nsSVGTransformList.h"
+#include "nsSVGMatrix.h"
+#include "nsSMILValue.h"
+#include "nsSVGElement.h"
+#include "nsISVGValue.h"
+#include "prdtoa.h"
+
+int nsSVGTransformSMILAttr::sType = 1;
+
+NS_IMPL_ISUPPORTS1(nsSVGTransformSMILAttr, nsISMILAttr)
+
+nsresult
+nsSVGTransformSMILAttr::GetBaseValue(nsSMILValue& aValue)
+{
+  nsCOMPtr<nsIDOMSVGTransform> transform;
+  nsresult rv = mVal->mBaseVal->Consolidate(getter_AddRefs(transform));
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  nsCOMPtr<nsIDOMSVGMatrix> matrix;
+  /* Consolidate sets transform to NULL if there are no matrices */
+  if (transform)
+    rv = transform->GetMatrix(getter_AddRefs(matrix));
+  else
+    rv = NS_NewSVGMatrix(getter_AddRefs(matrix));
+  NS_ENSURE_SUCCESS(rv,rv);
+  NS_ENSURE_TRUE(matrix,NS_ERROR_FAILURE);
+
+  nsSMILValue val;
+
+  /* 
+   * Assign the type first or if something goes wrong the matrix might never be
+   * released.
+   */
+  val.mType = GetSMILType();
+  NS_ENSURE_TRUE(val.mType, NS_ERROR_FAILURE);
+
+  nsIDOMSVGMatrix *raw_matrix = matrix;
+  val.mU.mPtr = raw_matrix;
+  NS_ADDREF(raw_matrix);
+
+  aValue = val;
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGTransformSMILAttr::SetAnimValue(const nsSMILValue& aValue)
+{
+  if (aValue.mType != &nsSVGTransformSMILType::sTranslateTransformType &&
+      aValue.mType != &nsSVGTransformSMILType::sScaleTransformType &&
+      aValue.mType != &nsSVGTransformSMILType::sRotateTransformType &&
+      aValue.mType != &nsSVGTransformSMILType::sSkewXTransformType &&
+      aValue.mType != &nsSVGTransformSMILType::sSkewYTransformType) {
+    NS_NOTREACHED("Unexpected SMIL Type");
+    return NS_ERROR_FAILURE;
+  }
+
+  nsIDOMSVGMatrix *value = (nsIDOMSVGMatrix *)aValue.mU.mPtr;
+  NS_ENSURE_TRUE(value,NS_ERROR_FAILURE);
+
+  mVal->WillModify(nsISVGValue::mod_other);
+
+  nsresult rv = NS_OK;
+
+  if (!mVal->mAnimVal)
+  {
+    rv = nsSVGTransformList::Create(getter_AddRefs(mVal->mAnimVal));
+    NS_ENSURE_SUCCESS(rv,NS_ERROR_FAILURE);
+  }
+
+  mVal->mAnimVal->Clear();
+
+  nsCOMPtr<nsIDOMSVGTransform> transform;
+  rv = mVal->mBaseVal->CreateSVGTransformFromMatrix(value,
+                                                    getter_AddRefs(transform));
+
+  nsCOMPtr<nsIDOMSVGTransform> result;
+  rv = mVal->mAnimVal->AppendItem(transform, getter_AddRefs(result));
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  mVal->DidModify(nsISVGValue::mod_other);
+  return NS_OK;
+}
+
+nsresult
+nsSVGTransformSMILAttr::ValueFromString(const nsAString& aStr,
+                                        nsSMILValue &aValue)
+{
+  nsISMILType *type = GetSMILType();
+  NS_ENSURE_TRUE(type, NS_ERROR_FAILURE);
+
+  nsIDOMSVGMatrix *matrix = nsnull;
+  nsresult rv = ParseValue(aStr, mTransformType, &matrix);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  aValue.mU.mPtr = matrix; /* NS_NewSVGMatrix will addref */
+  aValue.mType   = type;
+
+  return NS_OK;
+}
+
+PRBool
+nsSVGTransformSMILAttr::EqualsTarget(const nsISMILAttr &aOther) const
+{
+  if (aOther.mType != &sType)
+    return PR_FALSE;
+
+  nsSVGTransformSMILAttr const *other =
+    static_cast<const nsSVGTransformSMILAttr*>(&aOther);
+  return (mVal == other->mVal);
+}
+
+nsISMILType *
+nsSVGTransformSMILAttr::GetSMILType() const
+{
+  switch (mTransformType)
+  {
+  case nsIDOMSVGTransform::SVG_TRANSFORM_TRANSLATE:
+    return &nsSVGTransformSMILType::sTranslateTransformType;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SCALE:
+    return &nsSVGTransformSMILType::sScaleTransformType;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_ROTATE:
+    return &nsSVGTransformSMILType::sRotateTransformType;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SKEWX:
+    return &nsSVGTransformSMILType::sSkewXTransformType;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SKEWY:
+    return &nsSVGTransformSMILType::sSkewYTransformType;
+    break;
+
+  default:
+    NS_NOTREACHED("Bad transform type");
+    return nsnull;
+  }
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+nsresult
+nsSVGTransformSMILAttr::ParseValue(const nsAString &aSpec,
+                                   PRUint16 aTransformType,
+                                   nsIDOMSVGMatrix** aMatrix) const
+{
+  nsresult rv = NS_OK;
+
+  switch (aTransformType)
+  {
+  case nsIDOMSVGTransform::SVG_TRANSFORM_TRANSLATE:
+    {
+      // tx [ty=0]
+      float t[2] = { 0.f };
+      PRInt32 num_parsed = ParseParameterList(aSpec, t, 2);
+      if (num_parsed != 1 && num_parsed != 2) {
+        rv = NS_ERROR_FAILURE;
+        break; // parse error
+      }
+
+      rv = NS_NewSVGMatrix(aMatrix, 1.f, 0.f, 0.f, 1.f, t[0], t[1]);
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SCALE:
+    {
+      // sx [sy=sx]
+      float s[2] = { 0.f };
+      PRInt32 num_parsed = ParseParameterList(aSpec, s, 2);
+      if (num_parsed != 1 && num_parsed != 2) {
+        rv = NS_ERROR_FAILURE;
+        break; // parse error
+      }
+
+      if (num_parsed == 1)
+        s[1] = s[0];
+
+      rv = NS_NewSVGMatrix(aMatrix, s[0], 0.f, 0.f, s[1], 0.f, 0.f);
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_ROTATE:
+    {
+      // r [x0=0 y0=0]
+      float r[3] = { 0.f };
+      PRInt32 num_parsed = ParseParameterList(aSpec, r, 3);
+      if (num_parsed != 1 && num_parsed != 3) {
+        rv = NS_ERROR_FAILURE;
+        break; // parse error
+      }
+
+      nsCOMPtr<nsIDOMSVGMatrix> temp;
+      rv = NS_NewSVGMatrix(getter_AddRefs(temp));
+      NS_ENSURE_SUCCESS(rv,rv);
+
+      nsCOMPtr<nsIDOMSVGMatrix> temp2;
+      rv = temp->Rotate(r[0], getter_AddRefs(temp2));
+      NS_ENSURE_SUCCESS(rv,rv);
+
+      rv = temp2->Translate(-r[1],-r[2], getter_AddRefs(temp));
+      NS_ENSURE_SUCCESS(rv,rv);
+
+      *aMatrix = temp;
+      NS_ADDREF(*aMatrix);
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SKEWX:
+    {
+      // x-angle
+      float angle;
+      PRInt32 num_parsed = ParseParameterList(aSpec, &angle, 1);
+      if (num_parsed != 1) {
+        rv = NS_ERROR_FAILURE;
+        break; // parse error
+      }
+
+      nsCOMPtr<nsIDOMSVGMatrix> temp_matrix;
+      rv = NS_NewSVGMatrix(getter_AddRefs(temp_matrix));
+      NS_ENSURE_SUCCESS(rv,rv);
+
+      rv = temp_matrix->SkewX(angle, aMatrix);
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SKEWY:
+    {
+      // y-angle
+      float angle;
+      PRInt32 num_parsed = ParseParameterList(aSpec, &angle, 1);
+      if (num_parsed != 1) {
+        rv = NS_ERROR_FAILURE;
+        break; // parse error
+      }
+
+      nsCOMPtr<nsIDOMSVGMatrix> temp_matrix;
+      rv = NS_NewSVGMatrix(getter_AddRefs(temp_matrix));
+      NS_ENSURE_SUCCESS(rv,rv);
+
+      rv = temp_matrix->SkewY(angle, aMatrix);
+    }
+    break;
+
+  default:
+    rv = NS_ERROR_FAILURE;
+    break;
+  }
+
+  return rv;
+}
+
+inline PRBool
+nsSVGTransformSMILAttr::IsSpace(const char c) const
+{
+  return (c == 0x9 || c == 0xA || c == 0xD || c == 0x20);
+}
+
+inline void
+nsSVGTransformSMILAttr::SkipWsp(nsACString::const_iterator& aIter,
+                                const nsACString::const_iterator& aIterEnd) const
+{
+  while (aIter != aIterEnd && IsSpace(*aIter))
+    ++aIter;
+}
+
+PRInt32
+nsSVGTransformSMILAttr::ParseParameterList(const nsAString &aSpec,
+                                           float *aVars,
+                                           PRInt32 aNVars) const
+{
+  nsCAutoString spec;
+  LossyCopyUTF16toASCII(aSpec, spec);
+
+  nsACString::const_iterator start, end;
+  spec.BeginReading(start);
+  spec.EndReading(end);
+
+  SkipWsp(start, end);
+
+  int num_args_found = 0;
+
+  while (start != end) {
+    char const *arg = start.get();
+    char *argend;
+    float f = (float)PR_strtod(arg, &argend);
+    if (arg == argend || argend > end.get())
+      return -1;
+
+    if (num_args_found < aNVars) {
+      aVars[num_args_found] = f;
+    }
+
+    start.advance(argend - arg);
+    num_args_found++;
+
+    SkipWsp(start, end);
+  }
+
+  return num_args_found;
+}
diff --git a/content/svg/content/src/nsSVGTransformSMILAttr.h b/content/svg/content/src/nsSVGTransformSMILAttr.h
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGTransformSMILAttr.h
@@ -0,0 +1,86 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISMILAttr.h"
+#include "nsAutoPtr.h"
+#include "nsString.h"
+
+class nsSVGElement;
+class nsSVGAnimatedTransformList;
+class nsISMILType;
+class nsIDOMSVGMatrix;
+
+class nsSVGTransformSMILAttr : public nsISMILAttr
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  nsSVGTransformSMILAttr(nsSVGAnimatedTransformList* aTransform,
+                         nsSVGElement* aSVGElement,
+                         PRUint16 aTransformType)
+    : nsISMILAttr(&sType),
+      mVal(aTransform),
+      mSVGElement(aSVGElement), 
+      mTransformType(aTransformType) {}
+
+  virtual nsresult  GetBaseValue(nsSMILValue& aValue);
+  virtual nsresult  SetAnimValue(const nsSMILValue& aValue);
+  virtual nsresult  ValueFromString(const nsAString& aStr,
+                                    nsSMILValue &aValue);
+  virtual PRBool    EqualsTarget(const nsISMILAttr &aOther) const;
+
+protected:
+  nsresult  ParseValue(const nsAString &aSpec,
+                       PRUint16 aTransformType,
+                       nsIDOMSVGMatrix** aMatrix) const;
+  PRInt32   ParseParameterList(const nsAString &aSpec, float *aVars,
+                               PRInt32 aNVars) const;
+  PRBool    IsSpace(const char c) const;
+  void      SkipWsp(nsACString::const_iterator& aIter,
+                    const nsACString::const_iterator& aIterEnd) const;
+
+private:
+  static int sType; // Type checking only
+
+  nsISMILType *
+  GetSMILType() const;
+
+  nsSVGAnimatedTransformList* mVal; // kept alive because it belongs to content
+  nsRefPtr<nsSVGElement> mSVGElement;
+  PRUint16 mTransformType;
+
+};
diff --git a/content/svg/content/src/nsSVGTransformSMILType.cpp b/content/svg/content/src/nsSVGTransformSMILType.cpp
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGTransformSMILType.cpp
@@ -0,0 +1,312 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGTransformSMILType.h"
+#include "nsSMILValue.h"
+#include "nsIDOMSVGTransform.h"
+#include "nsSVGMatrix.h"
+#include "nsCOMPtr.h"
+#include "nsCRT.h"
+#include <math.h>
+
+nsSVGTransformSMILType nsSVGTransformSMILType::sTranslateTransformType(
+    nsIDOMSVGTransform::SVG_TRANSFORM_TRANSLATE);
+nsSVGTransformSMILType nsSVGTransformSMILType::sScaleTransformType(
+    nsIDOMSVGTransform::SVG_TRANSFORM_SCALE);
+nsSVGTransformSMILType nsSVGTransformSMILType::sRotateTransformType(
+    nsIDOMSVGTransform::SVG_TRANSFORM_ROTATE);
+nsSVGTransformSMILType nsSVGTransformSMILType::sSkewXTransformType(
+    nsIDOMSVGTransform::SVG_TRANSFORM_SKEWX);
+nsSVGTransformSMILType nsSVGTransformSMILType::sSkewYTransformType(
+    nsIDOMSVGTransform::SVG_TRANSFORM_SKEWY);
+
+void
+nsSVGTransformSMILType::SetValueIdentity(nsSMILValue &value)
+{
+  NS_ASSERTION(value.mType == this, "Unexpected SMIL value type.");
+
+  nsIDOMSVGMatrix *matrix = nsnull;
+  if (NS_FAILED(NS_NewSVGMatrix(&matrix))) {
+    value.mType = &nsSMILNullType::sSingleton;
+    return;
+  }
+
+  value.mU.mPtr = matrix; /* NS_NewSVGMatrix will addref */
+}
+
+void
+nsSVGTransformSMILType::DestroyValue(nsSMILValue& value)
+{
+  NS_ASSERTION(value.mType == this, "Unexpected SMIL value type.");
+  nsIDOMSVGMatrix *matrix = (nsIDOMSVGMatrix *)value.mU.mPtr;
+  NS_IF_RELEASE(matrix);
+}
+
+nsresult
+nsSVGTransformSMILType::AssignValue(nsSMILValue& aDest, const nsSMILValue& aSrc)
+{
+  NS_ASSERTION(aDest.mType == aSrc.mType, "Incompatible SMIL types.");
+  NS_ASSERTION(aDest.mType == this, "Unexpected SMIL value.");
+
+  float a, b, c, d, e, f;
+  nsIDOMSVGMatrix *src_matrix = (nsIDOMSVGMatrix *)aSrc.mU.mPtr;
+
+  src_matrix->GetA(&a);
+  src_matrix->GetB(&b);
+  src_matrix->GetC(&c);
+  src_matrix->GetD(&d);
+  src_matrix->GetE(&e);
+  src_matrix->GetF(&f);
+
+  nsIDOMSVGMatrix *matrix = nsnull;
+  nsresult rv = NS_NewSVGMatrix(&matrix, a, b, c, d, e, f);
+  if (NS_FAILED(rv)) {
+    aDest.mType = &nsSMILNullType::sSingleton;
+    return rv;
+  }
+
+  aDest.mU.mPtr = matrix; /* NS_NewSVGMatrix will addref */
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGTransformSMILType::Add(nsSMILValue& aDest, const nsSMILValue& aSrc)
+{
+  NS_ASSERTION(aDest.mType == this, "Unexpected SMIL type.");
+
+  if (aSrc.mType != &nsSVGTransformSMILType::sTranslateTransformType &&
+      aSrc.mType != &nsSVGTransformSMILType::sScaleTransformType &&
+      aSrc.mType != &nsSVGTransformSMILType::sRotateTransformType &&
+      aSrc.mType != &nsSVGTransformSMILType::sSkewXTransformType &&
+      aSrc.mType != &nsSVGTransformSMILType::sSkewYTransformType) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsIDOMSVGMatrix *dest_matrix = (nsIDOMSVGMatrix *)aDest.mU.mPtr;
+  nsIDOMSVGMatrix *src_matrix  = (nsIDOMSVGMatrix *)aSrc.mU.mPtr;
+
+  if (!dest_matrix || !src_matrix)
+    return NS_ERROR_FAILURE;
+
+  nsIDOMSVGMatrix *temp;
+  nsresult rv = dest_matrix->Multiply(src_matrix, &temp);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  NS_ADDREF(temp);
+  NS_RELEASE(dest_matrix);
+  aDest.mU.mPtr = temp;
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGTransformSMILType::ComputeDistance(const nsSMILValue& aFrom,
+                                     const nsSMILValue& aTo,
+                                     PRFloat64& aDistance) const
+{
+  NS_ASSERTION(aFrom.mType == aTo.mType, 
+      "Can't compute difference between different SMIL types.");
+  NS_ASSERTION(aFrom.mType == this, "Unexpected SMIL type.");
+
+  (void)aFrom;
+  (void)aTo;
+
+  aDistance = 0.0;
+  NS_NOTYETIMPLEMENTED("nsSVGAnimatedTransformList::ComputeDistance");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult
+nsSVGTransformSMILType::Interpolate(const nsSMILValue& aStartVal,
+                                    const nsSMILValue& aEndVal,
+                                    float aUnitDistance,
+                                    nsSMILValue& aResult)
+{
+  NS_ASSERTION(aStartVal.mType == aEndVal.mType,
+      "Can't interpolate between different SMIL types.");
+  NS_ASSERTION(aStartVal.mType == this, "Unexpected SMIL type.");
+
+  /* 
+   * We cast away constness here because nsIDOMSVGMatrix getters aren't marked
+   * as const.
+   */
+  nsIDOMSVGMatrix* start = (nsIDOMSVGMatrix*)aStartVal.mU.mPtr;
+  nsIDOMSVGMatrix* end   = (nsIDOMSVGMatrix*)aEndVal.mU.mPtr;
+  NS_ENSURE_TRUE(start && end, NS_ERROR_FAILURE);
+
+  nsresult rv = NS_OK;
+
+  nsCOMPtr<nsIDOMSVGMatrix> result = nsnull;
+  rv = NS_NewSVGMatrix(getter_AddRefs(result));
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  switch (mTransformType)
+  {
+  case nsIDOMSVGTransform::SVG_TRANSFORM_TRANSLATE:
+    {
+      float txa,tya;
+      start->GetE(&txa);
+      start->GetF(&tya);
+
+      float txb,tyb;
+      end->GetE(&txb);
+      end->GetF(&tyb);
+
+      result->SetE(txa + (txb - txa) * aUnitDistance);
+      result->SetF(tya + (tyb - tya) * aUnitDistance);
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SCALE:
+    {
+      float sxa,sya;
+      start->GetA(&sxa);
+      start->GetD(&sya);
+
+      float sxb,syb;
+      end->GetA(&sxb);
+      end->GetD(&syb);
+
+      result->SetA(sxa + (sxb - sxa) * aUnitDistance);
+      result->SetD(sya + (syb - sya) * aUnitDistance);
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_ROTATE:
+    {
+      float da;
+      start->GetA(&da);
+      float aa = acos(da);
+
+      float db;
+      end->GetA(&db);
+      float ab = acos(db);
+
+      float newa = (aa + (ab - aa) * aUnitDistance);
+      result->SetA(cos(newa));
+      result->SetB(sin(newa));
+      result->SetC(-sin(newa));
+      result->SetD(cos(newa));
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SKEWX:
+    {
+      float da;
+      start->GetC(&da);
+      float aa = atan(da);
+
+      float db;
+      end->GetC(&db);
+      float ab = atan(db);
+
+      float newa = (aa + (ab - aa) * aUnitDistance);
+      result->SetC(tan(newa));
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SKEWY:
+    {
+      float da;
+      start->GetB(&da);
+      float aa = atan(da);
+
+      float db;
+      end->GetB(&db);
+      float ab = atan(db);
+
+      float newa = (aa + (ab - aa) * aUnitDistance);
+      result->SetB(tan(newa));
+    }
+    break;
+
+  default:
+    return NS_ERROR_FAILURE;
+  }
+
+  nsIDOMSVGMatrix *raw_result = result.get();
+  aResult.mType   = this;
+  aResult.mU.mPtr = raw_result;
+  NS_ADDREF(raw_result);
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGTransformSMILType::Repeat(nsSMILValue& aDest,
+                               PRUint32 aCount,
+                               const nsSMILValue* aRepeatValue)
+{
+  NS_ASSERTION(aDest.mType == this, "Unexpected SMIL type.");
+  NS_ASSERTION(!aRepeatValue || aRepeatValue->mType == this,
+      "Unexpected SMIL type for repeat value.");
+
+  nsCOMPtr<nsIDOMSVGMatrix> target =
+    static_cast<nsIDOMSVGMatrix*>(aDest.mU.mPtr);
+  NS_ENSURE_TRUE(target, NS_ERROR_FAILURE);
+
+  nsCOMPtr<nsIDOMSVGMatrix> repeatValue(target);
+
+  if (aRepeatValue) {
+    /* 
+     * Casting away const-ness because nsIDOMSVGMatrix::Multiply is non-const
+     * (although it should be const).
+     */
+    repeatValue = (nsIDOMSVGMatrix *)(aRepeatValue->mU.mPtr);
+  }
+
+  // XXX Do matrix multiplication here. nsSVGMatrix::Multiply does an allocation
+  // every time it is called.
+  for (PRUint32 i = 0; i <= aCount; ++i)
+  {
+    nsCOMPtr<nsIDOMSVGMatrix> temp;
+    nsresult rv = target->Multiply(repeatValue, getter_AddRefs(temp));
+    NS_ENSURE_SUCCESS(rv,rv);
+    target = temp;
+  }
+
+  nsIDOMSVGMatrix *dest = static_cast<nsIDOMSVGMatrix*>(aDest.mU.mPtr);
+  NS_RELEASE(dest);
+  /* Even if aDest and target point to the same matrix target will keep it
+   * alive. */
+  nsIDOMSVGMatrix *raw_target = target.get();
+  aDest.mU.mPtr = raw_target;
+  NS_ADDREF(raw_target);
+
+  return NS_OK;
+}
diff --git a/content/svg/content/src/nsSVGTransformSMILType.h b/content/svg/content/src/nsSVGTransformSMILType.h
new file mode 100644
--- /dev/null
+++ b/content/svg/content/src/nsSVGTransformSMILType.h
@@ -0,0 +1,72 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISMILType.h"
+
+struct nsSMILValue;
+class nsIDOMSVGMatrix;
+
+class nsSVGTransformSMILType : public nsISMILType
+{
+public:
+  virtual void        SetValueIdentity(nsSMILValue& aValue);
+  virtual void        DestroyValue(nsSMILValue& aValue);
+  virtual nsresult    AssignValue(nsSMILValue& aDest,
+                                  const nsSMILValue& aSrc);
+  virtual nsresult    Add(nsSMILValue& aDest, const nsSMILValue& aSrc);
+  virtual nsresult    ComputeDistance(const nsSMILValue& aFrom,
+                                      const nsSMILValue& aTo,
+                                      PRFloat64& aDistance) const;
+  virtual nsresult    Interpolate(const nsSMILValue& aStartVal,
+                                         const nsSMILValue& aEndVal,
+                                         float aUnitDistance,
+                                         nsSMILValue& aResult);
+  virtual nsresult    Repeat(nsSMILValue& aDest,
+                             PRUint32 aCount,
+                             const nsSMILValue* aRepeatValue);
+
+  static nsSVGTransformSMILType sTranslateTransformType;
+  static nsSVGTransformSMILType sScaleTransformType;
+  static nsSVGTransformSMILType sRotateTransformType;
+  static nsSVGTransformSMILType sSkewXTransformType;
+  static nsSVGTransformSMILType sSkewYTransformType;
+
+private:
+  nsSVGTransformSMILType(PRUint16 aType) : mTransformType(aType) {}
+
+  PRUint16                    mTransformType;
+};
diff --git a/content/xml/document/src/nsXMLContentSink.cpp b/content/xml/document/src/nsXMLContentSink.cpp
--- a/content/xml/document/src/nsXMLContentSink.cpp
+++ b/content/xml/document/src/nsXMLContentSink.cpp
@@ -1162,17 +1162,21 @@ nsXMLContentSink::HandleEndElement(const
     }
     mNotifyLevel = stackLen - 1;
   }
   DidAddContent();
 
 #ifdef MOZ_SVG
   if (mDocument &&
       content->GetNameSpaceID() == kNameSpaceID_SVG &&
-      content->HasAttr(kNameSpaceID_None, nsGkAtoms::onload)) {
+      (
+#ifdef MOZ_SMIL
+       content->Tag() == nsGkAtoms::svg ||
+#endif
+       content->HasAttr(kNameSpaceID_None, nsGkAtoms::onload))) {
     FlushTags();
 
     nsEvent event(PR_TRUE, NS_SVG_LOAD);
     event.eventStructType = NS_SVG_EVENT;
     event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
 
     // Do we care about forcing presshell creation if it hasn't happened yet?
     // That is, should this code flush or something?  Does it really matter?
diff --git a/dom/public/idl/Makefile.in b/dom/public/idl/Makefile.in
--- a/dom/public/idl/Makefile.in
+++ b/dom/public/idl/Makefile.in
@@ -62,10 +62,14 @@ DIRS =						\
 	offline                                 \
 	geolocation                             \
 	threads
 
 ifdef MOZ_SVG
 DIRS += svg
 endif
 
+ifdef MOZ_SMIL
+DIRS += smil
+endif
+
 include $(topsrcdir)/config/rules.mk
 
diff --git a/dom/public/idl/smil/Makefile.in b/dom/public/idl/smil/Makefile.in
new file mode 100644
--- /dev/null
+++ b/dom/public/idl/smil/Makefile.in
@@ -0,0 +1,53 @@
+#!nmake
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla SMIL module.
+#
+# The Initial Developer of the Original Code is Brian Birtles.
+# Portions created by the Initial Developer are Copyright (C) 2005
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+# 	Brian Birtles <birtles@gmail.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= dom
+XPIDL_MODULE	= dom_smil
+
+XPIDLSRCS	= \
+		nsIDOMElementTimeControl.idl \
+		$(NULL)
+
+include $(topsrcdir)/config/rules.mk
diff --git a/dom/public/idl/smil/nsIDOMElementTimeControl.idl b/dom/public/idl/smil/nsIDOMElementTimeControl.idl
new file mode 100644
--- /dev/null
+++ b/dom/public/idl/smil/nsIDOMElementTimeControl.idl
@@ -0,0 +1,58 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMSVGElement.idl"
+
+/*
+ * The definitions of this interface in SMIL Animation and SVG 1.1 differ in the
+ * return type and semantics. Returning a boolean shouldn't present a problem
+ * for anyone expecting the method to have a void return type so we use the SVG
+ * definition of the interface here (boolean return types).
+ */
+
+[scriptable, uuid(276a6678-7844-4d5e-8dfe-938c46089b84)]
+interface nsIDOMElementTimeControl : nsISupports
+{ 
+  boolean beginElement ( );
+          // raises (nsIDOMDOMException)
+  boolean beginElementAt ( in float offset );
+          // raises (nsIDOMDOMException)
+  boolean endElement ( );
+          // raises (nsIDOMDOMException)
+  boolean endElementAt ( in float offset );
+          // raises (nsIDOMDOMException)
+};
diff --git a/dom/public/idl/svg/Makefile.in b/dom/public/idl/svg/Makefile.in
--- a/dom/public/idl/svg/Makefile.in
+++ b/dom/public/idl/svg/Makefile.in
@@ -16,16 +16,17 @@
 # The Original Code is Crocodile Clips Ltd code.
 #
 # The Initial Developer of the Original Code is
 # Crocodile Clips Ltd.
 # Portions created by the Initial Developer are Copyright (C) 2001
 # the Initial Developer. All Rights Reserved.
 #
 # Contributor(s):
+#   Chris Double  <chris.double@double.co.nz>
 #
 # Alternatively, the contents of this file may be used under the terms of
 # either of the GNU General Public License Version 2 or later (the "GPL"),
 # or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 # in which case the provisions of the GPL or the LGPL are applicable instead
 # of those above. If you wish to allow use of your version of this file only
 # under the terms of either the GPL or the LGPL, and not to allow others to
 # use your version of this file under the terms of the MPL, indicate your
@@ -122,9 +123,18 @@ XPIDLSRCS	= \
 		nsIDOMSVGURIReference.idl \
 		nsIDOMSVGUnitTypes.idl \
 		nsIDOMSVGUseElement.idl \
 		nsIDOMSVGViewSpec.idl \
 		nsIDOMSVGZoomAndPan.idl \
 		nsIDOMSVGZoomEvent.idl \
 		$(NULL)
 
+ifdef MOZ_SMIL
+XPIDLSRCS	+= \
+		nsIDOMSVGAnimateElement.idl \
+		nsIDOMSVGAnimateTransformElement.idl \
+		nsIDOMSVGAnimationElement.idl \
+		nsIDOMSVGSetElement.idl \
+		$(NULL)
+endif
+
 include $(topsrcdir)/config/rules.mk
diff --git a/dom/public/idl/svg/nsIDOMSVGAnimateElement.idl b/dom/public/idl/svg/nsIDOMSVGAnimateElement.idl
new file mode 100644
--- /dev/null
+++ b/dom/public/idl/svg/nsIDOMSVGAnimateElement.idl
@@ -0,0 +1,41 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMSVGAnimationElement.idl"
+
+[scriptable, uuid(0c4297e8-68d0-471d-a933-64132ccc5b97)]
+interface nsIDOMSVGAnimateElement : nsIDOMSVGAnimationElement {};
diff --git a/dom/public/idl/svg/nsIDOMSVGAnimateTransformElement.idl b/dom/public/idl/svg/nsIDOMSVGAnimateTransformElement.idl
new file mode 100644
--- /dev/null
+++ b/dom/public/idl/svg/nsIDOMSVGAnimateTransformElement.idl
@@ -0,0 +1,41 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMSVGAnimationElement.idl"
+
+[scriptable, uuid(735e0f75-c6aa-4aee-bcd2-46426d6ac90c)]
+interface nsIDOMSVGAnimateTransformElement : nsIDOMSVGAnimationElement {};
diff --git a/dom/public/idl/svg/nsIDOMSVGAnimationElement.idl b/dom/public/idl/svg/nsIDOMSVGAnimationElement.idl
new file mode 100644
--- /dev/null
+++ b/dom/public/idl/svg/nsIDOMSVGAnimationElement.idl
@@ -0,0 +1,62 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMSVGElement.idl"
+
+[scriptable, uuid(8f2ccf31-5544-4a9d-8927-ef35d242039e)]
+interface nsIDOMSVGAnimationElement
+  : nsIDOMSVGElement
+/*
+        The SVG DOM makes use of multiple interface inheritance.
+        Since XPCOM only supports single interface inheritance,
+        the best thing that we can do is to promise that whenever
+        an object implements _this_ interface it will also
+        implement the following interfaces. (We then have to QI to
+        hop between them.)
+        
+    nsIDOMSVGTests,
+    nsIDOMSVGExternalResourcesRequired,
+    smil::nsIDOMElementTimeControl,
+    events::nsIDOMEventTarget
+*/
+{ 
+  readonly attribute nsIDOMSVGElement targetElement;
+  float getStartTime ( );
+  float getCurrentTime ( );
+  float getSimpleDuration ( );
+          // raises (nsIDOMDOMException)
+};
diff --git a/dom/public/idl/svg/nsIDOMSVGSetElement.idl b/dom/public/idl/svg/nsIDOMSVGSetElement.idl
new file mode 100644
--- /dev/null
+++ b/dom/public/idl/svg/nsIDOMSVGSetElement.idl
@@ -0,0 +1,41 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Chris Double <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMSVGAnimationElement.idl"
+
+[scriptable, uuid(b6c27cdc-4d8b-4343-8ccb-3b68adb1052a)]
+interface nsIDOMSVGSetElement : nsIDOMSVGAnimationElement {};
diff --git a/dom/public/nsDOMClassInfoID.h b/dom/public/nsDOMClassInfoID.h
--- a/dom/public/nsDOMClassInfoID.h
+++ b/dom/public/nsDOMClassInfoID.h
@@ -238,16 +238,21 @@ enum nsDOMClassInfoID {
   eDOMClassInfo_BeforeUnloadEvent_id,
 
 #ifdef MOZ_SVG
   // The SVG document
   eDOMClassInfo_SVGDocument_id,
 
   // SVG element classes
   eDOMClassInfo_SVGAElement_id,
+#ifdef MOZ_SMIL
+  eDOMClassInfo_SVGAnimateElement_id,
+  eDOMClassInfo_SVGAnimateTransformElement_id,
+  eDOMClassInfo_SVGSetElement_id,
+#endif // MOZ_SMIL
   eDOMClassInfo_SVGCircleElement_id,
   eDOMClassInfo_SVGClipPathElement_id,
   eDOMClassInfo_SVGDefsElement_id,
   eDOMClassInfo_SVGDescElement_id,
   eDOMClassInfo_SVGEllipseElement_id,
   eDOMClassInfo_SVGFEBlendElement_id,
   eDOMClassInfo_SVGFEColorMatrixElement_id,
   eDOMClassInfo_SVGFEComponentTransferElement_id,
diff --git a/dom/src/base/nsDOMClassInfo.cpp b/dom/src/base/nsDOMClassInfo.cpp
--- a/dom/src/base/nsDOMClassInfo.cpp
+++ b/dom/src/base/nsDOMClassInfo.cpp
@@ -372,16 +372,23 @@
 #include "nsIDOMSVGAnimatedLengthList.h"
 #include "nsIDOMSVGAnimatedNumber.h"
 #include "nsIDOMSVGAnimatedNumberList.h"
 #include "nsIDOMSVGAnimatedPathData.h"
 #include "nsIDOMSVGAnimatedPoints.h"
 #include "nsIDOMSVGAnimPresAspRatio.h"
 #include "nsIDOMSVGAnimatedRect.h"
 #include "nsIDOMSVGAnimatedString.h"
+#ifdef MOZ_SMIL
+#include "nsIDOMSVGAnimateElement.h"
+#include "nsIDOMSVGAnimateTransformElement.h"
+#include "nsIDOMSVGSetElement.h"
+#include "nsIDOMSVGAnimationElement.h"
+#include "nsIDOMElementTimeControl.h"
+#endif // MOZ_SMIL
 #include "nsIDOMSVGAnimTransformList.h"
 #include "nsIDOMSVGCircleElement.h"
 #include "nsIDOMSVGClipPathElement.h"
 #include "nsIDOMSVGDefsElement.h"
 #include "nsIDOMSVGDescElement.h"
 #include "nsIDOMSVGDocument.h"
 #include "nsIDOMSVGElement.h"
 #include "nsIDOMSVGEllipseElement.h"
@@ -929,16 +936,24 @@ static nsDOMClassInfoData sClassInfoData
 #ifdef MOZ_SVG
   // SVG document
   NS_DEFINE_CLASSINFO_DATA(SVGDocument, nsDocumentSH,
                            DOCUMENT_SCRIPTABLE_FLAGS)
 
   // SVG element classes
   NS_DEFINE_CLASSINFO_DATA(SVGAElement, nsElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
+#ifdef MOZ_SMIL
+  NS_DEFINE_CLASSINFO_DATA(SVGAnimateElement, nsElementSH,
+                           ELEMENT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(SVGAnimateTransformElement, nsElementSH,
+                           ELEMENT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(SVGSetElement, nsElementSH,
+                           ELEMENT_SCRIPTABLE_FLAGS)
+#endif // MOZ_SMIL
   NS_DEFINE_CLASSINFO_DATA(SVGCircleElement, nsElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(SVGClipPathElement, nsElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(SVGDefsElement, nsElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(SVGDescElement, nsElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
@@ -2732,16 +2747,41 @@ nsDOMClassInfo::Init()
 
   // SVG element classes
 
   DOM_CLASSINFO_MAP_BEGIN(SVGAElement, nsIDOMSVGAElement)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGAElement)
     DOM_CLASSINFO_SVG_GRAPHIC_ELEMENT_MAP_ENTRIES
   DOM_CLASSINFO_MAP_END
 
+#ifdef MOZ_SMIL
+  DOM_CLASSINFO_MAP_BEGIN(SVGAnimateElement, nsIDOMSVGAnimateElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGAnimationElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGAnimateElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMElementTimeControl)
+    DOM_CLASSINFO_SVG_ELEMENT_MAP_ENTRIES
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(SVGAnimateTransformElement,
+                          nsIDOMSVGAnimateTransformElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGAnimationElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGAnimateTransformElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMElementTimeControl)
+    DOM_CLASSINFO_SVG_ELEMENT_MAP_ENTRIES
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(SVGSetElement,
+                          nsIDOMSVGSetElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGAnimationElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGSetElement)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMElementTimeControl)
+    DOM_CLASSINFO_SVG_ELEMENT_MAP_ENTRIES
+  DOM_CLASSINFO_MAP_END
+#endif // MOZ_SMIL
+
   DOM_CLASSINFO_MAP_BEGIN(SVGCircleElement, nsIDOMSVGCircleElement)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGCircleElement)
     DOM_CLASSINFO_SVG_GRAPHIC_ELEMENT_MAP_ENTRIES
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(SVGClipPathElement, nsIDOMSVGClipPathElement)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGClipPathElement)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGLocatable)
diff --git a/layout/base/Makefile.in b/layout/base/Makefile.in
--- a/layout/base/Makefile.in
+++ b/layout/base/Makefile.in
@@ -149,16 +149,22 @@ EXPORTS    += \
 EXPORTS    += \
 		nsPIBoxObject.h \
 		$(NULL)
 CPPSRCS    += \
 		nsBoxObject.cpp \
 		$(NULL)
 endif
 
+ifdef MOZ_SMIL
+EXPORTS    += \
+		nsIAnimationController.h \
+		$(NULL)
+endif
+
 ifdef IBMBIDI
 CPPSRCS		+= \
 		nsBidiPresUtils.cpp \
 		nsBidi.cpp \
 		$(NULL)
 endif                
 
 FORCE_STATIC_LIB = 1
diff --git a/layout/base/nsIAnimationController.h b/layout/base/nsIAnimationController.h
new file mode 100644
--- /dev/null
+++ b/layout/base/nsIAnimationController.h
@@ -0,0 +1,63 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_IANIMATIONCONTROLLER_H__
+#define __NS_IANIMATIONCONTROLLER_H__
+
+#include "nsISupports.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsIAnimationController: Animation controller
+
+// {7aa203ea-e6e1-4cca-84af-a29f0eaedef5}
+#define NS_IANIMATIONCONTROLLER_IID \
+{ 0x7aa203ea, 0xe6e1, 0x4cca, { 0x84, 0xaf, 0xa2, 0x9f, 0x0e, 0xae, 0xde, 0xf5 } }
+
+class nsIAnimationController : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IANIMATIONCONTROLLER_IID)
+
+  virtual nsresult  Pause()=0;
+  virtual nsresult  Resume()=0;
+  virtual nsresult  Reset()=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsIAnimationController,
+                              NS_IANIMATIONCONTROLLER_IID)
+
+#endif // __NS_IANIMATIONCONTROLLER_H__
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -69,16 +69,17 @@
 #include "nsXPIDLString.h"
 #include "nsIWeakReferenceUtils.h"
 #include "nsCSSRendering.h"
 #include "prprf.h"
 #include "nsContentPolicyUtils.h"
 #include "nsIDOMDocument.h"
 #include "nsAutoPtr.h"
 #include "nsEventStateManager.h"
+#include "nsIAnimationController.h"
 #include "nsThreadUtils.h"
 #include "nsFrameManager.h"
 #include "nsLayoutUtils.h"
 #include "nsIViewManager.h"
 #include "nsCSSFrameConstructor.h"
 #include "nsCSSRuleProcessor.h"
 #include "nsStyleChangeList.h"
 #include "nsRuleNode.h"
@@ -163,16 +164,17 @@ static NS_DEFINE_CID(kLookAndFeelCID,  N
   // NOTE! nsPresContext::operator new() zeroes out all members, so don't
   // bother initializing members to 0.
 
 nsPresContext::nsPresContext(nsIDocument* aDocument, nsPresContextType aType)
   : mType(aType), mDocument(aDocument), mTextZoom(1.0), mFullZoom(1.0),
     mPageSize(-1, -1), mPPScale(1.0f),
     mViewportStyleOverflow(NS_STYLE_OVERFLOW_AUTO, NS_STYLE_OVERFLOW_AUTO),
     mImageAnimationModePref(imgIContainer::kNormalAnimMode),
+    mSMILEnabled(PR_FALSE),
     // Font sizes default to zero; they will be set in GetFontPreferences
     mDefaultVariableFont("serif", NS_FONT_STYLE_NORMAL, NS_FONT_VARIANT_NORMAL,
                          NS_FONT_WEIGHT_NORMAL, 0, 0),
     mDefaultFixedFont("monospace", NS_FONT_STYLE_NORMAL,
                       NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL, 0, 0),
     mDefaultSerifFont("serif", NS_FONT_STYLE_NORMAL, NS_FONT_VARIANT_NORMAL,
                       NS_FONT_WEIGHT_NORMAL, 0, 0),
     mDefaultSansSerifFont("sans-serif", NS_FONT_STYLE_NORMAL,
@@ -281,16 +283,17 @@ nsPresContext::~nsPresContext()
 #endif // IBMBIDI
   nsContentUtils::UnregisterPrefCallback("layout.css.dpi",
                                          nsPresContext::PrefChangedCallback,
                                          this);
 
   NS_IF_RELEASE(mDeviceContext);
   NS_IF_RELEASE(mLookAndFeel);
   NS_IF_RELEASE(mLangGroup);
+  NS_IF_RELEASE(mAnimationController);
   
   SetUserFontSet(nsnull);
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsPresContext)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsPresContext)
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIObserver)
@@ -681,16 +684,18 @@ nsPresContext::GetUserPreferences()
   if (animatePref.Equals("normal"))
     mImageAnimationModePref = imgIContainer::kNormalAnimMode;
   else if (animatePref.Equals("none"))
     mImageAnimationModePref = imgIContainer::kDontAnimMode;
   else if (animatePref.Equals("once"))
     mImageAnimationModePref = imgIContainer::kLoopOnceAnimMode;
   else // dynamic change to invalid value should act like it does initially
     mImageAnimationModePref = imgIContainer::kNormalAnimMode;
+
+  mSMILEnabled = IsDynamic() && nsContentUtils::GetBoolPref("svg.smil.enabled");
 
   PRUint32 bidiOptions = GetBidi();
 
   PRInt32 prefInt =
     nsContentUtils::GetIntPref(IBMBIDI_TEXTDIRECTION_STR,
                                GET_BIDI_OPTION_DIRECTION(bidiOptions));
   SET_BIDI_OPTION_DIRECTION(bidiOptions, prefInt);
   mPrefBidiDirection = prefInt;
@@ -1080,16 +1085,30 @@ nsPresContext::SetImageAnimationModeInte
   // on all the images.
   if (mShell != nsnull) {
     nsIDocument *doc = mShell->GetDocument();
     if (doc) {
       nsIContent *rootContent = doc->GetRootContent();
       if (rootContent) {
         SetImgAnimations(rootContent, aMode);
       }
+    }
+  }
+
+  if (mAnimationController) {
+    switch (aMode)
+    {
+      case imgIContainer::kDontAnimMode:
+        if (mImageAnimationMode != imgIContainer::kDontAnimMode)
+          mAnimationController->Pause();
+        break;
+      default:
+        if (mImageAnimationMode == imgIContainer::kDontAnimMode)
+          mAnimationController->Resume();
+        break;
     }
   }
 
   mImageAnimationMode = aMode;
 }
 
 void
 nsPresContext::SetImageAnimationModeExternal(PRUint16 aMode)
@@ -1526,16 +1545,37 @@ nsPresContext::EnsureVisible(PRBool aUns
         }
         return PR_TRUE;
       }
     }
   }
   return PR_FALSE;
 }
 
+void
+nsPresContext::SetAnimationController(nsIAnimationController* aController)
+{
+  if (!SMILEnabled()) {
+    NS_NOTREACHED("Shouldn't be making/setting an animation controller "
+                  "if SMIL is disabled...");
+    return;
+  }
+
+  NS_IF_ADDREF(aController);
+  nsIAnimationController* temp = mAnimationController;
+  mAnimationController = aController;
+  NS_IF_RELEASE(temp);
+}
+
+PRBool
+nsPresContext::SMILEnabled() const
+{
+  return mSMILEnabled && (mImageAnimationMode != imgIContainer::kDontAnimMode);
+}
+
 #ifdef MOZ_REFLOW_PERF
 void
 nsPresContext::CountReflows(const char * aName, nsIFrame * aFrame)
 {
   if (mShell) {
     mShell->CountReflows(aName, aFrame);
   }
 }
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -84,16 +84,17 @@ class nsILinkHandler;
 class nsILinkHandler;
 class nsStyleContext;
 class nsIAtom;
 class nsIEventStateManager;
 class nsIURI;
 class nsILookAndFeel;
 class nsICSSPseudoComparator;
 class nsIAtom;
+class nsIAnimationController;
 struct nsStyleBackground;
 template <class T> class nsRunnableMethod;
 class nsIRunnable;
 class gfxUserFontSet;
 
 #ifdef MOZ_REFLOW_PERF
 class nsIRenderingContext;
 #endif
@@ -730,16 +731,26 @@ public:
                               mType == eContext_PrintPreview); }
 
   // Is this presentation in a chrome docshell?
   PRBool IsChrome() const;
 
   // Public API for native theme code to get style internals.
   virtual PRBool HasAuthorSpecifiedRules(nsIFrame *aFrame, PRUint32 ruleTypeMask) const;
 
+  nsIAnimationController* GetAnimationController()
+  {
+    return mAnimationController;
+  }
+
+  void SetAnimationController(nsIAnimationController* aController);
+
+  /* Returns true if SMIL animation is enabled for this context. */
+  PRBool SMILEnabled() const;
+
   // Is it OK to let the page specify colors and backgrounds?
   PRBool UseDocumentColors() const {
     return GetCachedBoolPref(kPresContext_UseDocumentColors) || IsChrome();
   }
 
   PRBool           SupressingResizeReflow() const { return mSupressResizeReflow; }
   
   gfxUserFontSet* GetUserFontSet();
@@ -795,16 +806,19 @@ protected:
   float                 mFullZoom;      // Page zoom, defaults to 1.0
 
   PRInt32               mCurAppUnitsPerDevPixel;
   PRInt32               mAutoQualityMinFontSizePixelsPref;
 
 #ifdef IBMBIDI
   nsBidiPresUtils*      mBidiUtils;
 #endif
+
+  nsIAnimationController* mAnimationController; // [STRONG]
+  PRBool                mSMILEnabled;
 
   nsCOMPtr<nsITheme> mTheme;
   nsCOMPtr<nsILanguageAtomService> mLangService;
   nsCOMPtr<nsIPrintSettings> mPrintSettings;
   nsCOMPtr<nsITimer>    mPrefChangedTimer;
 
   nsPropertyTable       mPropertyTable;
 
diff --git a/layout/build/Makefile.in b/layout/build/Makefile.in
--- a/layout/build/Makefile.in
+++ b/layout/build/Makefile.in
@@ -206,16 +206,22 @@ ifdef MOZ_SVG
 ifdef MOZ_SVG
 SHARED_LIBRARY_LIBS += \
 		../svg/base/src/$(LIB_PREFIX)gksvgbase_s.$(LIB_SUFFIX) \
 		$(DEPTH)/content/svg/document/src/$(LIB_PREFIX)gkconsvgdoc_s.$(LIB_SUFFIX) \
 		$(DEPTH)/content/svg/content/src/$(LIB_PREFIX)gkcontentsvg_s.$(LIB_SUFFIX) \
 		$(NULL)
 endif
 
+ifdef MOZ_SMIL
+SHARED_LIBRARY_LIBS += \
+		$(DEPTH)/content/smil/src/$(LIB_PREFIX)gkconsmil_s.$(LIB_SUFFIX) \
+		$(NULL)
+endif
+
 ifdef MOZ_PLAINTEXT_EDITOR_ONLY
 DEFINES += -DMOZILLA_PLAINTEXT_EDITOR_ONLY
 else
 SHARED_LIBRARY_LIBS += \
 	$(DEPTH)/editor/libeditor/html/$(LIB_PREFIX)htmleditor_s.$(LIB_SUFFIX) \
 	$(DEPTH)/editor/txtsvc/src/$(LIB_PREFIX)txtsvc_s.$(LIB_SUFFIX) \
 	$(NULL)
 endif
diff --git a/layout/reftests/svg/reftest.list b/layout/reftests/svg/reftest.list
--- a/layout/reftests/svg/reftest.list
+++ b/layout/reftests/svg/reftest.list
@@ -1,16 +1,19 @@
 
 # bugs/
 include bugs/reftest.list
 
 # sizing tests
 include sizing/reftest.list
 
 include filters/reftest.list
+
+# smil / animation tests
+include smil/reftest.list
 
 # Mozilla only tests (i.e. those containing XUL/XBL/etc.)
 include moz-only/reftest.list
 
 == clipPath-basic-01.svg pass.svg
 == clip-surface-clone-01.svg clip-surface-clone-01-ref.svg
 == conditions-01.svg pass.svg
 == currentColor-01.svg pass.svg
diff --git a/layout/reftests/svg/smil/anim-css-fontsize-pt-1-ref.svg b/layout/reftests/svg/smil/anim-css-fontsize-pt-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-css-fontsize-pt-1-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <text x="20" y="100" font-size="20pt" fill="blue">Some Long Text Here</text>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-css-fontsize-pt-1.svg b/layout/reftests/svg/smil/anim-css-fontsize-pt-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-css-fontsize-pt-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <text x="20" y="100" font-size="50pt" fill="blue">Some Long Text Here
+    <animate attributeName="font-size" attributeType="CSS"
+             from="50pt" to="20pt" begin="0s" dur="2s" fill="freeze"/>
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-css-fontsize-px-1-ref.svg b/layout/reftests/svg/smil/anim-css-fontsize-px-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-css-fontsize-px-1-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <text x="20" y="100" font-size="25" fill="blue">Some Long Text Here</text>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-css-fontsize-px-1a.svg b/layout/reftests/svg/smil/anim-css-fontsize-px-1a.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-css-fontsize-px-1a.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <text x="20" y="100" font-size="50" fill="blue">Some Long Text Here
+    <animate attributeName="font-size" attributeType="CSS"
+             from="50" to="25" begin="0s" dur="2s" fill="freeze"/>
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-css-fontsize-px-1b.svg b/layout/reftests/svg/smil/anim-css-fontsize-px-1b.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-css-fontsize-px-1b.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <text x="20" y="100" font-size="50px" fill="blue">Some Long Text Here
+    <animate attributeName="font-size" attributeType="CSS"
+             from="50px" to="25px" begin="0s" dur="2s" fill="freeze"/>
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-css-fontsize-px-1c.svg b/layout/reftests/svg/smil/anim-css-fontsize-px-1c.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-css-fontsize-px-1c.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <text x="20" y="100" font-size="50" fill="blue">Some Long Text Here
+    <animate attributeName="font-size" attributeType="CSS"
+             from="50" to="25px" begin="0s" dur="2s" fill="freeze"/>
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-discrete-replace-sum-1.svg b/layout/reftests/svg/smil/anim-discrete-replace-sum-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-discrete-replace-sum-1.svg
@@ -0,0 +1,12 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="20" fill="blue">
+    <animate attributeName="height" calcMode="discrete" 
+             additive="replace" accumulate="sum"
+             from="20" to="100" repeatCount="2" 
+             begin="0s" dur="1s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-discrete-sum-none-1.svg b/layout/reftests/svg/smil/anim-discrete-sum-none-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-discrete-sum-none-1.svg
@@ -0,0 +1,12 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="20" fill="blue">
+    <animate attributeName="height" calcMode="discrete"
+             additive="sum" accumulate="none" 
+             from="20" to="180"
+             begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-discrete-sum-sum-1.svg b/layout/reftests/svg/smil/anim-discrete-sum-sum-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-discrete-sum-sum-1.svg
@@ -0,0 +1,12 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="20" fill="blue">
+    <animate attributeName="height" calcMode="discrete"
+             additive="sum" accumulate="sum"
+             from="20" to="90" repeatCount="2" 
+             begin="0s" dur="1s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-discrete-values-1.svg b/layout/reftests/svg/smil/anim-discrete-values-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-discrete-values-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height" calcMode="discrete" 
+             values="100; 200; 50" begin="0s" dur="5s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-fillcolor-1.svg b/layout/reftests/svg/smil/anim-fillcolor-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-fillcolor-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="200" fill="rgb(255,0,0)">
+    <animateColor attributeName="fill" from="rgb(255,0,0)" to="rgb(0,0,255)"
+                  begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-fillopacity-1.svg b/layout/reftests/svg/smil/anim-fillopacity-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-fillopacity-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="200" fill="blue" fill-opacity="0">
+    <animate attributeName="fill-opacity" attributeType="CSS"
+             from="0" to="1" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-done-1a.svg b/layout/reftests/svg/smil/anim-height-done-1a.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-done-1a.svg
@@ -0,0 +1,11 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="50" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
+
diff --git a/layout/reftests/svg/smil/anim-height-done-1b.svg b/layout/reftests/svg/smil/anim-height-done-1b.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-done-1b.svg
@@ -0,0 +1,11 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="50" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
+
diff --git a/layout/reftests/svg/smil/anim-height-interp-1-ref.svg b/layout/reftests/svg/smil/anim-height-interp-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-1-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="15" width="200" height="115" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-1.svg b/layout/reftests/svg/smil/anim-height-interp-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(0.3, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-2-ref.svg b/layout/reftests/svg/smil/anim-height-interp-2-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-2-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="15" width="200" height="125" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-2.svg b/layout/reftests/svg/smil/anim-height-interp-2.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-2.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(0.5, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-3-ref.svg b/layout/reftests/svg/smil/anim-height-interp-3-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-3-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="15" width="200" height="160" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-3.svg b/layout/reftests/svg/smil/anim-height-interp-3.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-3.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.2, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-4-ref.svg b/layout/reftests/svg/smil/anim-height-interp-4-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-4-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="15" width="200" height="170" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-4.svg b/layout/reftests/svg/smil/anim-height-interp-4.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-4.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.4, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-5-ref.svg b/layout/reftests/svg/smil/anim-height-interp-5-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-5-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="15" width="200" height="190" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-5.svg b/layout/reftests/svg/smil/anim-height-interp-5.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-5.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.8, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-6-ref.svg b/layout/reftests/svg/smil/anim-height-interp-6-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-6-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="15" width="200" height="195" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-height-interp-6.svg b/layout/reftests/svg/smil/anim-height-interp-6.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-height-interp-6.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.9, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="50" fill="blue">
+    <animate attributeName="height"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-ref-text.svg b/layout/reftests/svg/smil/anim-ref-text.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-ref-text.svg
@@ -0,0 +1,5 @@
+<svg xmlns="http://www.w3.org/2000/svg" onload="var svg=document.documentElement;svg.pauseAnimations();svg.setCurrentTime(2.5)">
+
+<text x="20" y="100" font-size="25" fill="lime">Some Long Text Here</text>
+
+</svg>
diff --git a/layout/reftests/svg/smil/anim-standard-ref.svg b/layout/reftests/svg/smil/anim-standard-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-standard-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="15" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-strokecolor-1.svg b/layout/reftests/svg/smil/anim-strokecolor-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-strokecolor-1.svg
@@ -0,0 +1,12 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="20" y="20" width="190" height="190" 
+        fill="rgb(0,0,255)" stroke="rgb(255,0,0)" stroke-width="10">
+    <animateColor attributeName="stroke" 
+                  from="rgb(255,0,0)" to="rgb(0,0,255)"
+                  begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-strokewidth-1.svg b/layout/reftests/svg/smil/anim-strokewidth-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-strokewidth-1.svg
@@ -0,0 +1,11 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="200" height="200" 
+        fill="blue" stroke="red" stroke-width="10">
+    <animate attributeName="stroke-width" attributeType="CSS"
+             from="10" to="0" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-targethref-1.svg b/layout/reftests/svg/smil/anim-targethref-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-targethref-1.svg
@@ -0,0 +1,9 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect id="theRect" x="15" y="15" width="200" height="50" fill="blue" />
+  <animate xlink:href="#theRect" attributeName="height" 
+           from="50" to="200" begin="0s" dur="2s" fill="freeze"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-width-done-1a.svg b/layout/reftests/svg/smil/anim-width-done-1a.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-width-done-1a.svg
@@ -0,0 +1,11 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="50" height="200" fill="blue">
+    <animate attributeName="width" 
+             from="50" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
+
diff --git a/layout/reftests/svg/smil/anim-width-done-1b.svg b/layout/reftests/svg/smil/anim-width-done-1b.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-width-done-1b.svg
@@ -0,0 +1,11 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="15" width="50" height="200" fill="blue">
+    <animate attributeName="width"
+             from="50" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
+
diff --git a/layout/reftests/svg/smil/anim-x-done-1a.svg b/layout/reftests/svg/smil/anim-x-done-1a.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-done-1a.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x"
+             from="200" to="15" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-done-1b.svg b/layout/reftests/svg/smil/anim-x-done-1b.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-done-1b.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x" 
+             from="200" to="15" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-1-ref.svg b/layout/reftests/svg/smil/anim-x-interp-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-1-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="115" y="15" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-1.svg b/layout/reftests/svg/smil/anim-x-interp-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(0.3, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-2-ref.svg b/layout/reftests/svg/smil/anim-x-interp-2-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-2-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="125" y="15" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-2.svg b/layout/reftests/svg/smil/anim-x-interp-2.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-2.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(0.5, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-3-ref.svg b/layout/reftests/svg/smil/anim-x-interp-3-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-3-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="160" y="15" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-3.svg b/layout/reftests/svg/smil/anim-x-interp-3.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-3.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.2, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-4-ref.svg b/layout/reftests/svg/smil/anim-x-interp-4-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-4-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="170" y="15" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-4.svg b/layout/reftests/svg/smil/anim-x-interp-4.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-4.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.4, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-5-ref.svg b/layout/reftests/svg/smil/anim-x-interp-5-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-5-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="190" y="15" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-5.svg b/layout/reftests/svg/smil/anim-x-interp-5.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-5.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.8, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-6-ref.svg b/layout/reftests/svg/smil/anim-x-interp-6-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-6-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="195" y="15" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-x-interp-6.svg b/layout/reftests/svg/smil/anim-x-interp-6.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-x-interp-6.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.9, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="200" y="15" width="200" height="200" fill="blue">
+    <animate attributeName="x"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-done-1a.svg b/layout/reftests/svg/smil/anim-y-done-1a.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-done-1a.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="200" to="15" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-done-1b.svg b/layout/reftests/svg/smil/anim-y-done-1b.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-done-1b.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(2.5, false)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="200" to="15" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-1-ref.svg b/layout/reftests/svg/smil/anim-y-interp-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-1-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="115" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-1.svg b/layout/reftests/svg/smil/anim-y-interp-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(0.3, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-2-ref.svg b/layout/reftests/svg/smil/anim-y-interp-2-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-2-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="125" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-2.svg b/layout/reftests/svg/smil/anim-y-interp-2.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-2.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(0.5, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-3-ref.svg b/layout/reftests/svg/smil/anim-y-interp-3-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-3-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="160" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-3.svg b/layout/reftests/svg/smil/anim-y-interp-3.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-3.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.2, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-4-ref.svg b/layout/reftests/svg/smil/anim-y-interp-4-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-4-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="170" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-4.svg b/layout/reftests/svg/smil/anim-y-interp-4.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-4.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.4, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-5-ref.svg b/layout/reftests/svg/smil/anim-y-interp-5-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-5-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="190" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-5.svg b/layout/reftests/svg/smil/anim-y-interp-5.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-5.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.8, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-6-ref.svg b/layout/reftests/svg/smil/anim-y-interp-6-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-6-ref.svg
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="15" y="195" width="200" height="200" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/anim-y-interp-6.svg b/layout/reftests/svg/smil/anim-y-interp-6.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/anim-y-interp-6.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.9, true)">
+  <script xlink:href="smil-util.js" type="text/javascript"/>
+  <rect x="15" y="200" width="200" height="200" fill="blue">
+    <animate attributeName="y"
+             from="100" to="200" begin="0s" dur="2s" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/api-sanity-1-ref.svg b/layout/reftests/svg/smil/api-sanity-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/api-sanity-1-ref.svg
@@ -0,0 +1,6 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect id="rect" width="100px" height="100px"
+        fill="lime"/>
+</svg>
diff --git a/layout/reftests/svg/smil/api-sanity-1.svg b/layout/reftests/svg/smil/api-sanity-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/api-sanity-1.svg
@@ -0,0 +1,34 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="go()"
+     class="reftest-wait"
+>
+  <script type="application/javascript">
+    function go(evt) {
+      // Try calling the animation-related methods in nsSVGSVGElement.cpp
+      // If any aren't implemented, we'll throw an exception and
+      // the rect will stay red.
+
+      // Note: I'm catching the exception because (I think) we need to
+      // make sure to remove the "reftest-wait" document-class
+      try {
+        document.documentElement.animationsPaused();
+        document.documentElement.pauseAnimations();
+        document.documentElement.unpauseAnimations();
+        document.documentElement.getCurrentTime();
+        document.documentElement.setCurrentTime(0);
+      } catch (e) {
+        document.documentElement.removeAttribute("class");
+        throw e;
+      }
+
+      // If we get here, we're successful!
+      // Change the rect color.
+      var rect = document.getElementById("rect");
+      rect.setAttributeNS(null, "fill", "lime");
+      document.documentElement.removeAttribute("class");
+    }
+  </script>
+  <rect id="rect" width="100px" height="100px"
+        fill="red"/>
+</svg>
diff --git a/layout/reftests/svg/smil/reftest.list b/layout/reftests/svg/smil/reftest.list
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/reftest.list
@@ -0,0 +1,69 @@
+# Tests related to SVG Animation (using SMIL)
+# XXXdholbert Partial list of features that still need reftests:
+#   - calcMode=discrete, paced, spline
+#   - Stacking of additive=[sum|replace] animations
+#   - Stacking of additive animations, w/ "hybrid case of to-animation"
+#   - Repeating animations, w/ & w/out accumulate=sum
+#   - <animateTransform>
+#   - <set>
+#   - DOM interfaces (Section 6.2 of http://www.w3.org/TR/smil-animation/ )
+
+# animation sort-order tests
+include sort/reftest.list
+
+# style tests
+include style/reftest.list
+
+# time-dependent tests
+# XXXdholbert Disabling this class of tests for now, because most of them
+# can & should be converted so they don't depend on specific timeout values.
+# (to prevent sporadic failures due to nondeterminism)
+# include timed/reftest.list
+
+# General tests
+fails == anim-css-fontsize-px-1a.svg anim-css-fontsize-px-1-ref.svg
+fails == anim-css-fontsize-px-1b.svg anim-css-fontsize-px-1-ref.svg
+fails == anim-css-fontsize-px-1c.svg anim-css-fontsize-px-1-ref.svg
+fails == anim-css-fontsize-pt-1.svg  anim-css-fontsize-pt-1-ref.svg
+
+== anim-discrete-values-1.svg      anim-standard-ref.svg
+== anim-discrete-replace-sum-1.svg anim-standard-ref.svg
+== anim-discrete-sum-none-1.svg    anim-standard-ref.svg
+== anim-discrete-sum-sum-1.svg     anim-standard-ref.svg
+
+fails == anim-fillcolor-1.svg      anim-standard-ref.svg # CSS/color support
+fails == anim-fillopacity-1.svg anim-standard-ref.svg # CSS/color support
+
+== anim-height-done-1a.svg anim-standard-ref.svg
+== anim-height-done-1b.svg anim-standard-ref.svg
+== anim-height-interp-1.svg anim-height-interp-1-ref.svg
+== anim-height-interp-2.svg anim-height-interp-2-ref.svg
+== anim-height-interp-3.svg anim-height-interp-3-ref.svg
+== anim-height-interp-4.svg anim-height-interp-4-ref.svg
+== anim-height-interp-5.svg anim-height-interp-5-ref.svg
+== anim-height-interp-6.svg anim-height-interp-6-ref.svg
+
+fails == anim-strokecolor-1.svg anim-standard-ref.svg # CSS/color support
+fails == anim-strokewidth-1.svg anim-standard-ref.svg # color support
+fails == anim-targethref-1.svg anim-standard-ref.svg  # href support
+
+== anim-width-done-1a.svg anim-standard-ref.svg
+== anim-width-done-1b.svg anim-standard-ref.svg
+
+== anim-x-done-1a.svg anim-standard-ref.svg
+== anim-x-done-1b.svg anim-standard-ref.svg
+== anim-x-interp-1.svg anim-x-interp-1-ref.svg
+== anim-x-interp-2.svg anim-x-interp-2-ref.svg
+== anim-x-interp-3.svg anim-x-interp-3-ref.svg
+== anim-x-interp-4.svg anim-x-interp-4-ref.svg
+== anim-x-interp-5.svg anim-x-interp-5-ref.svg
+== anim-x-interp-6.svg anim-x-interp-6-ref.svg
+
+== anim-y-done-1a.svg anim-standard-ref.svg
+== anim-y-done-1b.svg anim-standard-ref.svg
+== anim-y-interp-1.svg anim-y-interp-1-ref.svg
+== anim-y-interp-2.svg anim-y-interp-2-ref.svg
+== anim-y-interp-3.svg anim-y-interp-3-ref.svg
+== anim-y-interp-4.svg anim-y-interp-4-ref.svg
+== anim-y-interp-5.svg anim-y-interp-5-ref.svg
+== anim-y-interp-6.svg anim-y-interp-6-ref.svg
diff --git a/layout/reftests/svg/smil/smil-util.js b/layout/reftests/svg/smil/smil-util.js
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/smil-util.js
@@ -0,0 +1,11 @@
+// Seeks to the given time and then removes the SVG document's class to trigger
+// a reftest snapshot. If pauseFlag is true, animations will be paused.
+function setTimeAndSnapshot(timeInSeconds, pauseFlag) {
+  var svg = document.documentElement;
+  if (pauseFlag) {
+    svg.pauseAnimations();
+  }
+  svg.setCurrentTime(timeInSeconds);
+  // Use setTimeout to allow SMIL to update the animation before snapshot
+  setTimeout('document.documentElement.removeAttribute("class")', 0);
+}
diff --git a/layout/reftests/svg/smil/sort/reftest.list b/layout/reftests/svg/smil/sort/reftest.list
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/reftest.list
@@ -0,0 +1,9 @@
+# Tests related to SVG Animation (using SMIL), focusing on animation-sorting
+# to see which animation takes precedence (out of multiple animations on the
+# same attribute
+
+== sort-startAfter-1.svg sort-startAfter-1-ref.svg
+== sort-startAfter-2.svg sort-startAfter-2-ref.svg
+== sort-startAfter-3.svg sort-startAfter-3-ref.svg
+== sort-startSame-1.svg  sort-startSame-1-ref.svg
+== sort-startSame-2.svg  sort-startSame-2-ref.svg
diff --git a/layout/reftests/svg/smil/sort/sort-startAfter-1-ref.svg b/layout/reftests/svg/smil/sort/sort-startAfter-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startAfter-1-ref.svg
@@ -0,0 +1,4 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="125" y="0"   width="100" height="100" fill="blue"/>
+  <rect x="125" y="200" width="100" height="100" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startAfter-1.svg b/layout/reftests/svg/smil/sort/sort-startAfter-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startAfter-1.svg
@@ -0,0 +1,16 @@
+<!-- If two conflicting animations start at diffent times, the one starting 
+     later should win. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.0, true)">
+  <script xlink:href="../smil-util.js" type="text/javascript"/>
+  <rect x="0" y="0" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="100" to="200" begin="0.5s" dur="2s"/>
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="2s"/>
+  </rect>
+  <rect x="0" y="200" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="2s"/>
+    <animate attributeName="x" from="100" to="200" begin="0.5s" dur="2s"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startAfter-2-ref.svg b/layout/reftests/svg/smil/sort/sort-startAfter-2-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startAfter-2-ref.svg
@@ -0,0 +1,4 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="150" y="0"   width="100" height="100" fill="blue"/>
+  <rect x="150" y="200" width="100" height="100" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startAfter-2.svg b/layout/reftests/svg/smil/sort/sort-startAfter-2.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startAfter-2.svg
@@ -0,0 +1,18 @@
+<!-- If two conflicting animations start at diffent times, the one starting 
+     later should win. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.5, true)">
+  <script xlink:href="../smil-util.js" type="text/javascript"/>
+  <rect x="0" y="0" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="100" to="200" begin="0.5s" dur="2s"/>
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="1s"
+             fill="freeze"/>
+  </rect>
+  <rect x="0" y="200" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="1s"
+             fill="freeze"/>
+    <animate attributeName="x" from="100" to="200" begin="0.5s" dur="2s"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startAfter-3-ref.svg b/layout/reftests/svg/smil/sort/sort-startAfter-3-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startAfter-3-ref.svg
@@ -0,0 +1,4 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="200" y="0"   width="100" height="100" fill="blue"/>
+  <rect x="200" y="200" width="100" height="100" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startAfter-3.svg b/layout/reftests/svg/smil/sort/sort-startAfter-3.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startAfter-3.svg
@@ -0,0 +1,18 @@
+<!-- If two conflicting animations start at diffent times, the one starting 
+     later (including its lasting "freeze" effect) should win. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.5, true)">
+  <script xlink:href="../smil-util.js" type="text/javascript"/>
+  <rect x="0" y="0" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="100" to="200" begin="0.25s" dur="1s"
+             fill="freeze"/>
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="2s"/>
+  </rect>
+  <rect x="0" y="200" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="2s"/>
+    <animate attributeName="x" from="100" to="200" begin="0.25s" dur="1s"
+             fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startSame-1-ref.svg b/layout/reftests/svg/smil/sort/sort-startSame-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startSame-1-ref.svg
@@ -0,0 +1,4 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="350" y="0"   width="100" height="100" fill="blue"/>
+  <rect x="150" y="200" width="100" height="100" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startSame-1.svg b/layout/reftests/svg/smil/sort/sort-startSame-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startSame-1.svg
@@ -0,0 +1,16 @@
+<!-- If two conflicting animations start at same time, the one appearing
+     later in the document should win. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.0, true)">
+  <script xlink:href="../smil-util.js" type="text/javascript"/>
+  <rect x="0" y="0" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="100" to="200" begin="0s" dur="2s"/>
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="2s"/>
+  </rect>
+  <rect x="0" y="200" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="2s"/>
+    <animate attributeName="x" from="100" to="200" begin="0s" dur="2s"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startSame-2-ref.svg b/layout/reftests/svg/smil/sort/sort-startSame-2-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startSame-2-ref.svg
@@ -0,0 +1,4 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect x="400" y="0"   width="100" height="100" fill="blue"/>
+  <rect x="175" y="200" width="100" height="100" fill="blue"/>
+</svg>
diff --git a/layout/reftests/svg/smil/sort/sort-startSame-2.svg b/layout/reftests/svg/smil/sort/sort-startSame-2.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/sort/sort-startSame-2.svg
@@ -0,0 +1,18 @@
+<!-- If two conflicting animations start at same time, the one appearing
+     later in the document should win (including its freeze effects). -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     class="reftest-wait"
+     onload="setTimeAndSnapshot(1.5, true)">
+  <script xlink:href="../smil-util.js" type="text/javascript"/>
+  <rect x="0" y="0" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="100" to="200" begin="0s" dur="2s"/>
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="1s" 
+             fill="freeze"/>
+  </rect>
+  <rect x="0" y="200" width="100" height="100" fill="blue">
+    <animate attributeName="x" from="300" to="400" begin="0s" dur="1s" 
+             fill="freeze"/>
+    <animate attributeName="x" from="100" to="200" begin="0s" dur="2s"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/style/fill-1-ref.svg b/layout/reftests/svg/smil/style/fill-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/fill-1-ref.svg
@@ -0,0 +1,8 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <!-- Test interaction of specified CSS style and animated values -->
+  <text y="40" style="fill: green">
+    This text should be green.
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/style/fill-1.svg b/layout/reftests/svg/smil/style/fill-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/fill-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <!-- Test interaction of specified CSS style and animated values -->
+  <text y="40" style="fill: red">
+    This text should be green.
+	<set attributeType="CSS" attributeName="fill" 
+             begin="0s" dur="1s" to="green" fill="freeze"/>
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/style/font-size-1-ref.svg b/layout/reftests/svg/smil/style/font-size-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/font-size-1-ref.svg
@@ -0,0 +1,8 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <!-- Test interaction of specified CSS style and animated values -->
+  <text y="40" style="font-size: 30pt">
+    This text should be large.
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/style/font-size-1.svg b/layout/reftests/svg/smil/style/font-size-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/font-size-1.svg
@@ -0,0 +1,10 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <!-- Test interaction of specified CSS style and animated values -->
+  <text y="40" style="font-size: 8pt">
+    This text should be large.
+	<set attributeType="CSS" attributeName="font-size" 
+             begin="0s" dur="1s" to="30pt" fill="freeze"/>
+  </text>
+</svg>
diff --git a/layout/reftests/svg/smil/style/reftest.list b/layout/reftests/svg/smil/style/reftest.list
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/style/reftest.list
@@ -0,0 +1,10 @@
+# Tests related to SVG Animation (using SMIL) of CSS properties
+
+# NOTE: All tests here are currently marked 'fails'.  They'll be enabled
+# as part of a smil-for-CSS-properties patch.
+
+# Tests that are expected to pass with current smil_css draft patch:
+fails == font-size-1.svg  font-size-1-ref.svg  # Note: Opera v9.27 fails this
+
+# Tests that don't yet pass:
+fails == fill-1.svg       fill-1-ref.svg
diff --git a/layout/reftests/svg/smil/timed/appendChild-1a-ref.svg b/layout/reftests/svg/smil/timed/appendChild-1a-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-1a-ref.svg
@@ -0,0 +1,8 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+  </rect>
+  <rect id="rect2" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/appendChild-1a.svg b/layout/reftests/svg/smil/timed/appendChild-1a.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-1a.svg
@@ -0,0 +1,27 @@
+<!-- This test's animation sets x=100 from 1sec to 1.5sec.  We'll
+     remove the animate element at time 1.1sec to capture this, and
+     then wait a little, and make sure the animation is frozen there. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1100);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      var rect1 = document.getElementById("rect1");
+      var rect2 = document.getElementById("rect2");
+      var anim = document.getElementById("anim");
+      rect2.appendChild(anim);
+
+      // Wait >= 1s before taking screenshot, to give animation time to finish
+      setTimeout('document.documentElement.removeAttribute("class")', 1100);
+    }
+  </script>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+    <animate id="anim" attributeName="x" 
+             dur="2s" values="0; 50; 100; 150"
+             calcMode="discrete" />
+  </rect>
+  <rect id="rect2" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/appendChild-1b-ref.svg b/layout/reftests/svg/smil/timed/appendChild-1b-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-1b-ref.svg
@@ -0,0 +1,6 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect id="rect2" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/appendChild-1b.svg b/layout/reftests/svg/smil/timed/appendChild-1b.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-1b.svg
@@ -0,0 +1,26 @@
+<!-- This test makes the first rect white (invisible), so that we can
+     focus just on the second rect. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1100);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      var rect1 = document.getElementById("rect1");
+      var rect2 = document.getElementById("rect2");
+      var anim = document.getElementById("anim");
+      rect2.appendChild(anim);
+
+      // Wait >= 1s before taking screenshot, to give animation time to finish
+      setTimeout('document.documentElement.removeAttribute("class")', 1100);
+    }
+  </script>
+  <rect id="rect1" y="40" width="10" height="10" fill="white">
+    <animate id="anim" attributeName="x" 
+             dur="2s" values="0; 50; 100; 150"
+             calcMode="discrete" />
+  </rect>
+  <rect id="rect2" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/appendChild-2a-ref.svg b/layout/reftests/svg/smil/timed/appendChild-2a-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-2a-ref.svg
@@ -0,0 +1,8 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+  </rect>
+  <rect id="rect2" x="150" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/appendChild-2a.svg b/layout/reftests/svg/smil/timed/appendChild-2a.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-2a.svg
@@ -0,0 +1,27 @@
+<!-- This test's animation sets x=100 from 1sec to 1.5sec.  We'll
+     remove the animate element at time 1.1sec to capture this, and
+     then wait a little, and make sure the animation is frozen there. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1100);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      var rect1 = document.getElementById("rect1");
+      var rect2 = document.getElementById("rect2");
+      var anim = document.getElementById("anim");
+      rect2.appendChild(anim);
+
+      // Wait >= 1s before taking screenshot, to give animation time to finish
+      setTimeout('document.documentElement.removeAttribute("class")', 1100);
+    }
+  </script>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+    <animate id="anim" attributeName="x" 
+             dur="2s" values="0; 50; 100; 150"
+             calcMode="discrete" fill="freeze"/>
+  </rect>
+  <rect id="rect2" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/appendChild-2b-ref.svg b/layout/reftests/svg/smil/timed/appendChild-2b-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-2b-ref.svg
@@ -0,0 +1,6 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect id="rect2" x="150" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/appendChild-2b.svg b/layout/reftests/svg/smil/timed/appendChild-2b.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/appendChild-2b.svg
@@ -0,0 +1,26 @@
+<!-- This test makes the first rect white (invisible), so that we can
+     focus just on the second rect. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1100);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      var rect1 = document.getElementById("rect1");
+      var rect2 = document.getElementById("rect2");
+      var anim = document.getElementById("anim");
+      rect2.appendChild(anim);
+
+      // Wait >= 1s before taking screenshot, to give animation time to finish
+      setTimeout('document.documentElement.removeAttribute("class")', 1100);
+    }
+  </script>
+  <rect id="rect1" y="40" width="10" height="10" fill="white">
+    <animate id="anim" attributeName="x" 
+             dur="2s" values="0; 50; 100; 150"
+             calcMode="discrete" fill="freeze"/>
+  </rect>
+  <rect id="rect2" y="80" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/paced-1-ref.svg b/layout/reftests/svg/smil/timed/paced-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/paced-1-ref.svg
@@ -0,0 +1,5 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect height="90" width="90" fill="green"></rect>   
+</svg>
diff --git a/layout/reftests/svg/smil/timed/paced-1.svg b/layout/reftests/svg/smil/timed/paced-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/paced-1.svg
@@ -0,0 +1,19 @@
+<!-- In paced calcmode, this animation should jump to -990 really fast,
+     despite the many small-jump values before it, leaving the canvas blank. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1000);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      document.documentElement.removeAttribute("class");
+    }
+  </script>
+  <rect height="90" width="90" fill="green"></rect>
+  <rect x="40" y="40" width="10" height="10" fill="red">
+    <animate attributeName="x" 
+             dur="5s" values="40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; -950"
+             calcMode="paced" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/pause-1-ref.svg b/layout/reftests/svg/smil/timed/pause-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/pause-1-ref.svg
@@ -0,0 +1,6 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+   <rect x="100" y="40" width="10" height="10" fill="blue">
+   </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/pause-1.svg b/layout/reftests/svg/smil/timed/pause-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/pause-1.svg
@@ -0,0 +1,35 @@
+<!-- This test's animation sets x=100 from 1sec to 1.5sec.  We'll
+     pause the animation at time 1.1sec to capture this, and then wait
+     a little, and make sure the animation is frozen there.       -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1100);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      // Use try/catch, so that we make sure to remove the reftest-wait 
+      // attribute  even on older browser versions that don't support
+      // pauseAnimations.
+      try {
+        document.documentElement.pauseAnimations();
+      } catch (e) {
+        // pauseAnimations not implemented. Change rect to red, 
+	    // and clear class to fail/end immediately.
+        document.documentElement.removeAttribute("class");
+        var rect = document.getElementById("rect");
+        rect.setAttributeNS(null, "fill", "red");
+        throw e;
+      }
+
+      // Wait > 0.5s before taking screenshot, to give animation time to
+      // jump to next value if the freeze didn't work.
+      setTimeout('document.documentElement.removeAttribute("class")', 600);
+    }
+  </script>
+  <rect y="40" width="10" height="10" fill="blue">
+    <animate id="rect" attributeName="x" 
+             dur="3s" values="0; 50; 100; 150; 200; 250"
+             calcMode="discrete" fill="freeze"/>
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/reftest.list b/layout/reftests/svg/smil/timed/reftest.list
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/reftest.list
@@ -0,0 +1,14 @@
+# Tests related to SVG Animation that use timeouts to interrupt, modify, 
+# and examine animations.
+#
+# NOTE: Most of these tests require a few seconds to run.
+# (That's longer than most other reftests)
+
+== paced-1.svg paced-1-ref.svg
+== pause-1.svg pause-1-ref.svg
+fails == removeChild-1.svg removeChild-1-ref.svg # rect needs to reset
+fails == removeChild-2.svg removeChild-2-ref.svg # rect needs to reset
+fails == appendChild-1a.svg appendChild-1a-ref.svg # first rect needs to reset
+== appendChild-1b.svg appendChild-1b-ref.svg
+fails == appendChild-2a.svg appendChild-2a-ref.svg # first rect needs to reset
+== appendChild-2b.svg appendChild-2b-ref.svg
diff --git a/layout/reftests/svg/smil/timed/removeChild-1-ref.svg b/layout/reftests/svg/smil/timed/removeChild-1-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/removeChild-1-ref.svg
@@ -0,0 +1,6 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/removeChild-1.svg b/layout/reftests/svg/smil/timed/removeChild-1.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/removeChild-1.svg
@@ -0,0 +1,25 @@
+<!-- This test's animation sets x=100 from 1sec to 1.5sec.  We'll
+     remove the animate element at time 1.1sec, give it a little more 
+     time, and see what happens. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1100);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      var rect1 = document.getElementById("rect1");
+      var anim = document.getElementById("anim");
+      rect1.removeChild(anim);
+
+      // Wait > 0.5s before taking screenshot, to give animation time to
+      // finish, if it's still going
+      setTimeout('document.documentElement.removeAttribute("class")', 700);
+    }
+  </script>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+    <animate id="anim" attributeName="x" 
+             dur="2s" values="0; 50; 100; 150"
+             calcMode="discrete" />
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/removeChild-2-ref.svg b/layout/reftests/svg/smil/timed/removeChild-2-ref.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/removeChild-2-ref.svg
@@ -0,0 +1,6 @@
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+  </rect>
+</svg>
diff --git a/layout/reftests/svg/smil/timed/removeChild-2.svg b/layout/reftests/svg/smil/timed/removeChild-2.svg
new file mode 100644
--- /dev/null
+++ b/layout/reftests/svg/smil/timed/removeChild-2.svg
@@ -0,0 +1,25 @@
+<!-- This test's animation sets x=100 from 1sec to 1.5sec.  We'll
+     remove the animate element at time 1.1sec, give it a little more 
+     time, and see what happens. -->
+<svg xmlns="http://www.w3.org/2000/svg"
+     xmlns:xlink="http://www.w3.org/1999/xlink"
+     onload="setTimeout('go()', 1100);"
+     class="reftest-wait"
+>
+  <script>
+    function go() {
+      var rect1 = document.getElementById("rect1");
+      var anim = document.getElementById("anim");
+      rect1.removeChild(anim);
+
+      // Wait > 0.5s before taking screenshot, to give animation time to
+      // finish, if it's still going
+      setTimeout('document.documentElement.removeAttribute("class")', 700);
+    }
+  </script>
+  <rect id="rect1" y="40" width="10" height="10" fill="blue">
+    <animate id="anim" attributeName="x" 
+             dur="2s" values="0; 50; 100; 150"
+             calcMode="discrete" fill="freeze" />
+  </rect>
+</svg>
diff --git a/modules/libpref/src/init/all.js b/modules/libpref/src/init/all.js
--- a/modules/libpref/src/init/all.js
+++ b/modules/libpref/src/init/all.js
@@ -1109,16 +1109,20 @@ pref("config.use_system_prefs.accessibil
 
 pref("editor.resizing.preserve_ratio",       true);
 pref("editor.positioning.offset",            0);
 
 pref("dom.max_chrome_script_run_time", 20);
 pref("dom.max_script_run_time", 10);
 
 pref("svg.enabled", true);
+
+//XXXdholbert This should initially be disabled in release builds
+// pref("svg.smil.enabled", false);
+pref("svg.smil.enabled", true);
 
 pref("font.minimum-size.ar", 0);
 pref("font.minimum-size.x-armn", 0);
 pref("font.minimum-size.x-beng", 0);
 pref("font.minimum-size.x-baltic", 0);
 pref("font.minimum-size.x-central-euro", 0);
 pref("font.minimum-size.zh-CN", 0);
 pref("font.minimum-size.zh-HK", 0);
diff --git a/toolkit/toolkit-makefiles.sh b/toolkit/toolkit-makefiles.sh
--- a/toolkit/toolkit-makefiles.sh
+++ b/toolkit/toolkit-makefiles.sh
@@ -1045,16 +1045,25 @@ if [ "$MOZ_SVG" ]; then
     content/svg/content/src/Makefile
     dom/public/idl/svg/Makefile
     layout/svg/Makefile
     layout/svg/base/Makefile
     layout/svg/base/src/Makefile
   "
 fi
 
+# smil
+if [ "$MOZ_SMIL" ]; then
+    MAKEFILES_content="$MAKEFILES_content
+	content/smil/Makefile
+	content/smil/public/Makefile
+	content/smil/src/Makefile
+"
+fi
+
 if [ "$MOZ_XTF" ]; then
   add_makefiles "
     content/xtf/Makefile
     content/xtf/public/Makefile
     content/xtf/src/Makefile
   "
 fi
 
