DeCOMtaminate nsIPresShell::GetDidInitialReflow.  (Bug 468645)

diff --git a/content/base/src/nsContentSink.cpp b/content/base/src/nsContentSink.cpp
--- a/content/base/src/nsContentSink.cpp
+++ b/content/base/src/nsContentSink.cpp
@@ -1261,19 +1261,17 @@ nsContentSink::StartLayout(PRBool aIgnor
   nsCOMPtr<nsIPresShell> shell;
   while ((shell = iter.GetNextShell())) {
     // Make sure we don't call InitialReflow() for a shell that has
     // already called it. This can happen when the layout frame for
     // an iframe is constructed *between* the Embed() call for the
     // docshell in the iframe, and the content sink's call to OpenBody().
     // (Bug 153815)
 
-    PRBool didInitialReflow = PR_FALSE;
-    shell->GetDidInitialReflow(&didInitialReflow);
-    if (didInitialReflow) {
+    if (shell->DidInitialReflow()) {
       // XXX: The assumption here is that if something already
       // called InitialReflow() on this shell, it also did some of
       // the setup below, so we do nothing and just move on to the
       // next shell in the list.
 
       continue;
     }
 
diff --git a/content/html/document/src/nsMediaDocument.cpp b/content/html/document/src/nsMediaDocument.cpp
--- a/content/html/document/src/nsMediaDocument.cpp
+++ b/content/html/document/src/nsMediaDocument.cpp
@@ -274,19 +274,17 @@ nsMediaDocument::CreateSyntheticDocument
 
 nsresult
 nsMediaDocument::StartLayout()
 {
   mMayStartLayout = PR_TRUE;
   nsPresShellIterator iter(this);
   nsCOMPtr<nsIPresShell> shell;
   while ((shell = iter.GetNextShell())) {
-    PRBool didInitialReflow = PR_FALSE;
-    shell->GetDidInitialReflow(&didInitialReflow);
-    if (didInitialReflow) {
+    if (shell->DidInitialReflow()) {
       // Don't mess with this presshell: someone has already handled
       // its initial reflow.
       continue;
     }
     
     nsRect visibleArea = shell->GetPresContext()->GetVisibleArea();
     nsresult rv = shell->InitialReflow(visibleArea.width, visibleArea.height);
     NS_ENSURE_SUCCESS(rv, rv);
diff --git a/content/xul/document/src/nsXULDocument.cpp b/content/xul/document/src/nsXULDocument.cpp
--- a/content/xul/document/src/nsXULDocument.cpp
+++ b/content/xul/document/src/nsXULDocument.cpp
@@ -3886,17 +3886,17 @@ nsXULDocument::OverlayForwardReference::
     // Resolve a forward reference from an overlay element; attempt to
     // hook it up into the main document.
     nsresult rv;
     nsCOMPtr<nsIContent> target;
 
     PRBool notify = PR_FALSE;
     nsIPresShell *shell = mDocument->GetPrimaryShell();
     if (shell)
-        shell->GetDidInitialReflow(&notify);
+        notify = shell->DidInitialReflow();
 
     nsAutoString id;
     mOverlay->GetAttr(kNameSpaceID_None, nsGkAtoms::id, id);
     if (id.IsEmpty()) {
         // mOverlay is a direct child of <overlay> and has no id.
         // Insert it under the root element in the base document.
         nsIContent* root = mDocument->GetRootContent();
         if (!root) {
diff --git a/layout/base/nsIPresShell.h b/layout/base/nsIPresShell.h
--- a/layout/base/nsIPresShell.h
+++ b/layout/base/nsIPresShell.h
@@ -270,16 +270,17 @@ public:
   NS_IMETHOD EndObservingDocument() = 0;
 
   /**
    * Determine if InitialReflow() was previously called.
    * @param aDidInitialReflow PR_TRUE if InitalReflow() was previously called,
    * PR_FALSE otherwise.
    */
   NS_IMETHOD GetDidInitialReflow(PRBool *aDidInitialReflow) = 0;
+  PRBool DidInitialReflow() const { return mDidInitialReflow; }
 
   /**
    * Perform the initial reflow. Constructs the frame for the root content
    * object and then reflows the frame model into the specified width and
    * height.
    *
    * The coordinates for aWidth and aHeight must be in standard nscoords.
    *
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -799,17 +799,16 @@ public:
 
   NS_IMETHOD SetDisplaySelection(PRInt16 aToggle);
   NS_IMETHOD GetDisplaySelection(PRInt16 *aToggle);
   NS_IMETHOD ScrollSelectionIntoView(SelectionType aType, SelectionRegion aRegion, PRBool aIsSynchronous);
   NS_IMETHOD RepaintSelection(SelectionType aType);
 
   NS_IMETHOD BeginObservingDocument();
   NS_IMETHOD EndObservingDocument();
-  NS_IMETHOD GetDidInitialReflow(PRBool *aDidInitialReflow);
   NS_IMETHOD InitialReflow(nscoord aWidth, nscoord aHeight);
   NS_IMETHOD ResizeReflow(nscoord aWidth, nscoord aHeight);
   NS_IMETHOD StyleChangeReflow();
   NS_IMETHOD GetPageSequenceFrame(nsIPageSequenceFrame** aResult) const;
   virtual NS_HIDDEN_(nsIFrame*) GetPrimaryFrameFor(nsIContent* aContent) const;
   virtual NS_HIDDEN_(nsIFrame*) GetRealPrimaryFrameFor(nsIContent* aContent) const;
 
   NS_IMETHOD GetPlaceholderFrameFor(nsIFrame*  aFrame,
@@ -2312,27 +2311,16 @@ static void CheckForFocus(nsPIDOMWindow*
     aOurWindow->Focus();
 
   // We need to ensure that the focus controller is updated, since it may be
   // suppressed when this function is called.
   aFocusController->SetFocusedWindow(aOurWindow);
 }
 
 NS_IMETHODIMP
-PresShell::GetDidInitialReflow(PRBool *aDidInitialReflow)
-{
-  if (!aDidInitialReflow)
-    return NS_ERROR_FAILURE;
-
-  *aDidInitialReflow = mDidInitialReflow;
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
 PresShell::InitialReflow(nscoord aWidth, nscoord aHeight)
 {
   if (mIsDestroying) {
     return NS_OK;
   }
 
   NS_ASSERTION(!mDidInitialReflow, "Why are we being called?");
 
