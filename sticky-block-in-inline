From: L. David Baron <dbaron@dbaron.org>

Bug 828312 patch 9a:  Make sticky positioning handle block-in-inline splits correctly.

This assumes that the specification for how position:sticky behaves for
block-in-inline splits matches the specification for position:relative,
in other words, matches
http://www.w3.org/TR/CSS21/visuren.html#anonymous-block-level .

diff --git a/layout/generic/StickyScrollContainer.cpp b/layout/generic/StickyScrollContainer.cpp
--- a/layout/generic/StickyScrollContainer.cpp
+++ b/layout/generic/StickyScrollContainer.cpp
@@ -124,17 +124,18 @@ StickyScrollContainer::ComputeStickyOffs
               new nsMargin(computedOffsets));
   }
 }
 
 void
 StickyScrollContainer::ComputeStickyLimits(nsIFrame* aFrame, nsRect* aStick,
                                            nsRect* aContain) const
 {
-  NS_ASSERTION(!aFrame->GetPrevContinuation(),
+  NS_ASSERTION(nsLayoutUtils::GetFirstContinuationOrSpecialSibling(aFrame) ==
+               aFrame,
                "Can't sticky position individual continuations");
 
   aStick->SetRect(nscoord_MIN/2, nscoord_MIN/2, nscoord_MAX, nscoord_MAX);
   aContain->SetRect(nscoord_MIN/2, nscoord_MIN/2, nscoord_MAX, nscoord_MAX);
 
   const nsMargin* computedOffsets = static_cast<nsMargin*>(
     aFrame->Properties().Get(nsIFrame::ComputedOffsetProperty()));
   if (!computedOffsets) {
@@ -259,25 +260,24 @@ StickyScrollContainer::GetScrollRanges(n
     aInner->SetRightEdge(normalPosition.x - stick.x);
     aOuter->SetRightEdge(contain.XMost() - stick.x);
   }
 }
 
 void
 StickyScrollContainer::PositionContinuations(nsIFrame* aFrame)
 {
-  NS_ASSERTION(!aFrame->GetPrevContinuation(),
+  NS_ASSERTION(nsLayoutUtils::GetFirstContinuationOrSpecialSibling(aFrame) ==
+               aFrame,
                "Should be starting from the first continuation");
-  nsPoint newPosition = ComputePosition(aFrame);
-  nsPoint translation = newPosition - aFrame->GetPosition();
-  aFrame->SetPosition(newPosition);
+  nsPoint translation = ComputePosition(aFrame) - aFrame->GetPosition();
 
   // Move all continuation frames by the same amount.
-  for (nsIFrame* cont = aFrame->GetNextContinuation(); cont;
-       cont = cont->GetNextContinuation()) {
+  for (nsIFrame* cont = aFrame; cont;
+       cont = nsLayoutUtils::GetNextContinuationOrSpecialSibling(cont)) {
     cont->SetPosition(cont->GetPosition() + translation);
   }
 }
 
 void
 StickyScrollContainer::UpdatePositions(nsPoint aScrollPosition,
                                        nsIFrame* aSubtreeRoot)
 {
@@ -298,17 +298,18 @@ StickyScrollContainer::UpdatePositions(n
     if (aSubtreeRoot) {
       // Reflowing the scroll frame, so recompute offsets.
       ComputeStickyOffsets(f);
     }
     // mFrames will only contain first continuations, because we filter in
     // nsIFrame::Init.
     PositionContinuations(f);
 
-    for (nsIFrame* cont = f; cont; cont = cont->GetNextContinuation()) {
+    for (nsIFrame* cont = f; cont;
+         cont = nsLayoutUtils::GetNextContinuationOrSpecialSibling(cont)) {
       oct.AddFrame(cont);
     }
   }
   oct.Flush();
 }
 
 void
 StickyScrollContainer::ScrollPositionWillChange(nscoord aX, nscoord aY)
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -867,17 +867,19 @@ nsHTMLReflowState::ApplyRelativePosition
   } else {
     props.Set(nsIFrame::NormalPositionProperty(), new nsPoint(*aPosition));
   }
 
   const nsStyleDisplay* display = aFrame->StyleDisplay();
   if (NS_STYLE_POSITION_RELATIVE == display->mPosition) {
     *aPosition += nsPoint(aComputedOffsets.left, aComputedOffsets.top);
   } else if (NS_STYLE_POSITION_STICKY == display->mPosition &&
-             !aFrame->GetNextContinuation() && !aFrame->GetPrevContinuation()) {
+             !aFrame->GetNextContinuation() &&
+             !aFrame->GetPrevContinuation() &&
+             !(aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
     // Sticky positioning for elements with multiple frames needs to be
     // computed all at once. We can't safely do that here because we might be
     // partway through (re)positioning the frames, so leave it until the scroll
     // container reflows and calls StickyScrollContainer::UpdatePositions.
     // For single-frame sticky positioned elements, though, go ahead and apply
     // it now to avoid unnecessary overflow updates later.
     StickyScrollContainer* ssc =
       StickyScrollContainer::GetStickyScrollContainerForFrame(aFrame);
diff --git a/layout/reftests/position-sticky/block-in-inline-1.html b/layout/reftests/position-sticky/block-in-inline-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/position-sticky/block-in-inline-1.html
@@ -0,0 +1,42 @@
+<!DOCTYPE html>
+<!-- Any copyright is dedicated to the Public Domain.
+   - http://creativecommons.org/publicdomain/zero/1.0/ -->
+<html>
+  <head>
+    <title>CSS Test: Sticky Positioning - block inside inline, normal position</title>
+    <link rel="author" title="L. David Baron" href="mailto:dbaron@mozilla.com">
+    <link rel="match" href="block-in-inline-1-ref.html">
+    <meta name="assert" content="Inline elements split because they contain blocks should always have all parts moved the same offset from their normal position">
+    <style>
+      #scroll {
+        height: 100px;
+        overflow: hidden;
+        font-size: 16px;
+        line-height: 1.0;
+      }
+      #contain {
+        height: 100px;
+      }
+      #sticky {
+        display: inline;
+        position: sticky;
+        top: 10px;
+      }
+    </style>
+  </head>
+  <body>
+    <div id="scroll">
+      <div style="height: 20px"></div>
+      <div id="contain">
+        before inline
+        <div id="sticky">
+          before block
+          <div>in block</div>
+          after block
+        </div>
+        after inline
+      </div>
+      <div style="height: 100px"></div>
+    </div>
+  </body>
+</html>
diff --git a/layout/reftests/position-sticky/block-in-inline-2.html b/layout/reftests/position-sticky/block-in-inline-2.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/position-sticky/block-in-inline-2.html
@@ -0,0 +1,45 @@
+<!DOCTYPE html>
+<!-- Any copyright is dedicated to the Public Domain.
+   - http://creativecommons.org/publicdomain/zero/1.0/ -->
+<html>
+  <head>
+    <title>CSS Test: Sticky Positioning - block inside inline, stuck position</title>
+    <link rel="author" title="L. David Baron" href="mailto:dbaron@mozilla.com">
+    <link rel="match" href="block-in-inline-2-ref.html">
+    <meta name="assert" content="Inline elements split because they contain blocks should always have all parts moved the same offset from their normal position">
+    <style>
+      #scroll {
+        height: 100px;
+        overflow: hidden;
+        font-size: 16px;
+        line-height: 1.0;
+      }
+      #contain {
+        height: 100px;
+      }
+      #sticky {
+        display: inline;
+        position: sticky;
+        top: 10px;
+      }
+    </style>
+  </head>
+  <body>
+    <div id="scroll">
+      <div style="height: 20px"></div>
+      <div id="contain">
+        before inline
+        <div id="sticky">
+          before block
+          <div>in block</div>
+          after block
+        </div>
+        after inline
+      </div>
+      <div style="height: 100px"></div>
+    </div>
+    <script type="application/javascript">
+      document.getElementById("scroll").scrollTop = 30;
+    </script>
+  </body>
+</html>
diff --git a/layout/reftests/position-sticky/block-in-inline-3.html b/layout/reftests/position-sticky/block-in-inline-3.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/position-sticky/block-in-inline-3.html
@@ -0,0 +1,46 @@
+<!DOCTYPE html>
+<!-- Any copyright is dedicated to the Public Domain.
+   - http://creativecommons.org/publicdomain/zero/1.0/ -->
+<html>
+  <head>
+    <title>CSS Test: Sticky Positioning - block inside inline, contained position</title>
+    <link rel="author" title="L. David Baron" href="mailto:dbaron@mozilla.com">
+    <link rel="match" href="block-in-inline-3-ref.html">
+    <meta name="assert" content="Inline elements split because they contain blocks should always have all parts moved the same offset from their normal position">
+    <style>
+      #scroll {
+        height: 100px;
+        overflow: hidden;
+        font-size: 16px;
+        line-height: 1.0;
+      }
+      #contain {
+        height: 100px;
+      }
+      #sticky {
+        display: inline;
+        position: sticky;
+        top: 10px;
+      }
+    </style>
+  </head>
+  <body>
+    <div id="scroll">
+      <div style="height: 20px"></div>
+      <div id="contain">
+        before inline
+        <div id="sticky">
+          before block
+          <div>in block</div>
+          after block
+        </div>
+        after inline
+      </div>
+      <div style="height: 100px"></div>
+    </div>
+    <script type="application/javascript">
+      // should start moving after 72px
+      document.getElementById("scroll").scrollTop = 92;
+    </script>
+  </body>
+</html>
diff --git a/layout/reftests/position-sticky/reftest.list b/layout/reftests/position-sticky/reftest.list
--- a/layout/reftests/position-sticky/reftest.list
+++ b/layout/reftests/position-sticky/reftest.list
@@ -41,8 +41,11 @@ fuzzy-if(Android,4,1) == containing-bloc
 == overconstrained-1.html overconstrained-1-ref.html
 == overconstrained-2.html overconstrained-2-ref.html
 == overconstrained-3.html overconstrained-3-ref.html
 == inline-1.html inline-1-ref.html
 == inline-2.html inline-2-ref.html
 fails == inline-3.html inline-3-ref.html # bug 916302
 fails == column-contain-1a.html column-contain-1-ref.html
 == column-contain-1b.html column-contain-1-ref.html
+== block-in-inline-1.html block-in-inline-1-ref.html
+== block-in-inline-2.html block-in-inline-2-ref.html
+== block-in-inline-3.html block-in-inline-3-ref.html
diff --git a/layout/style/ua.css b/layout/style/ua.css
--- a/layout/style/ua.css
+++ b/layout/style/ua.css
@@ -204,18 +204,18 @@
 }
 
 *|*::-moz-pagebreak {
   display: block !important;
 }
 
 *|*::-moz-anonymous-positioned-block {
   display: block !important;
-  position: relative;
-  top: inherit; 
+  position: inherit; /* relative or sticky */
+  top: inherit;
   left: inherit;
   bottom: inherit;
   right: inherit;
   z-index: inherit;
   clip: inherit;
   opacity: inherit;
   unicode-bidi: inherit;
   text-overflow: inherit;
