From: L. David Baron <dbaron@dbaron.org>

Bug 828312 patch 9a:  Make sticky positioning handle block-in-inline splits correctly.

This assumes that the specification for how position:sticky behaves for
block-in-inline splits matches the specification for position:relative,
in other words, matches
http://www.w3.org/TR/CSS21/visuren.html#anonymous-block-level .

It's also necessary for patch 9b since the new rule for handling of
style change hints is that a style change hint applies to all
continuations and all block-in-inline siblings ("special siblings").

The change in StickyScrollContainer::GetScrollRanges is really the fix
for bug 918994, but adjusted for the change here to use block-in-inline
siblings ("special siblings") in addition to continuations.

diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -2541,16 +2541,30 @@ nsLayoutUtils::GetFirstContinuationOrSpe
       result = f;
     }
   }
 
   return result;
 }
 
 bool
+nsLayoutUtils::IsFirstContinuationOrSpecialSibling(nsIFrame *aFrame)
+{
+  if (aFrame->GetPrevContinuation()) {
+    return false;
+  }
+  if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
+      aFrame->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling())) {
+    return false;
+  }
+
+  return true;
+}
+
+bool
 nsLayoutUtils::IsViewportScrollbarFrame(nsIFrame* aFrame)
 {
   if (!aFrame)
     return false;
 
   nsIFrame* rootScrollFrame =
     aFrame->PresContext()->PresShell()->GetRootScrollFrame();
   if (!rootScrollFrame)
diff --git a/layout/base/nsLayoutUtils.h b/layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h
+++ b/layout/base/nsLayoutUtils.h
@@ -940,16 +940,23 @@ public:
   /**
    * Get the first frame in the continuation-plus-special-sibling chain
    * containing aFrame.
    */
   static nsIFrame*
   GetFirstContinuationOrSpecialSibling(nsIFrame *aFrame);
 
   /**
+   * Is GetFirstContinuationOrSpecialSibling(aFrame) going to return
+   * aFrame?
+   */
+  static bool
+  IsFirstContinuationOrSpecialSibling(nsIFrame *aFrame);
+
+  /**
    * Check whether aFrame is a part of the scrollbar or scrollcorner of
    * the root content.
    * @param aFrame the checking frame
    * @return if TRUE, the frame is a part of the scrollbar or scrollcorner of
    *         the root content.
    */
   static bool IsViewportScrollbarFrame(nsIFrame* aFrame);
 
diff --git a/layout/generic/StickyScrollContainer.cpp b/layout/generic/StickyScrollContainer.cpp
--- a/layout/generic/StickyScrollContainer.cpp
+++ b/layout/generic/StickyScrollContainer.cpp
@@ -124,43 +124,52 @@ StickyScrollContainer::ComputeStickyOffs
               new nsMargin(computedOffsets));
   }
 }
 
 void
 StickyScrollContainer::ComputeStickyLimits(nsIFrame* aFrame, nsRect* aStick,
                                            nsRect* aContain) const
 {
-  NS_ASSERTION(!aFrame->GetPrevContinuation(),
+  NS_ASSERTION(nsLayoutUtils::IsFirstContinuationOrSpecialSibling(aFrame),
                "Can't sticky position individual continuations");
 
   aStick->SetRect(nscoord_MIN/2, nscoord_MIN/2, nscoord_MAX, nscoord_MAX);
   aContain->SetRect(nscoord_MIN/2, nscoord_MIN/2, nscoord_MAX, nscoord_MAX);
 
   const nsMargin* computedOffsets = static_cast<nsMargin*>(
     aFrame->Properties().Get(nsIFrame::ComputedOffsetProperty()));
   if (!computedOffsets) {
     // We haven't reflowed the scroll frame yet, so offsets haven't been
     // computed. Bail.
     return;
   }
 
   nsIFrame* scrolledFrame = mScrollFrame->GetScrolledFrame();
+  // FIXME:  cbFrame isn't quite right if we're dealing with a
+  // block-in-inline split whose first part is a block.  We probably
+  // want the first in flow of the containing block of the first inline
+  // part.  (Or maybe those block-in-inline split pieces are never a
+  // containing block, and we're ok?)
   nsIFrame* cbFrame = aFrame->GetContainingBlock();
   NS_ASSERTION(cbFrame == scrolledFrame ||
     nsLayoutUtils::IsProperAncestorFrame(scrolledFrame, cbFrame),
     "Scroll frame should be an ancestor of the containing block");
 
   nsRect rect =
     nsLayoutUtils::GetAllInFlowRectsUnion(aFrame, aFrame->GetParent());
 
   // Containing block limits
   if (cbFrame != scrolledFrame) {
     *aContain = nsLayoutUtils::GetAllInFlowRectsUnion(cbFrame, cbFrame);
     aContain->MoveBy(-aFrame->GetParent()->GetOffsetTo(cbFrame));
+    // FIXME: GetUsedBorderAndPadding / GetUsedMargin consider skip-sides,
+    // which doesn't quite mesh with the use of GetAllInFlowRectsUnion here.
+    // This probably needs to do that computation *inside* the
+    // accumuation function over the in-flows.
     aContain->Deflate(cbFrame->GetUsedBorderAndPadding());
     aContain->Deflate(aFrame->GetUsedMargin());
     aContain->Deflate(nsMargin(0, rect.width, rect.height, 0));
   }
 
   nsMargin sfPadding = scrolledFrame->GetUsedPadding();
   nsPoint sfOffset = aFrame->GetParent()->GetOffsetTo(scrolledFrame);
 
@@ -224,19 +233,25 @@ StickyScrollContainer::ComputePosition(n
 
   return position;
 }
 
 void
 StickyScrollContainer::GetScrollRanges(nsIFrame* aFrame, nsRect* aOuter,
                                        nsRect* aInner) const
 {
+  // We need to use the first in flow; ComputeStickyLimits requires
+  // this, at the very least because its call to
+  // nsLayoutUtils::GetAllInFlowRectsUnion requires it.
+  nsIFrame *firstCont =
+    nsLayoutUtils::GetFirstContinuationOrSpecialSibling(aFrame);
+
   nsRect stick;
   nsRect contain;
-  ComputeStickyLimits(aFrame, &stick, &contain);
+  ComputeStickyLimits(firstCont, &stick, &contain);
 
   aOuter->SetRect(nscoord_MIN/2, nscoord_MIN/2, nscoord_MAX, nscoord_MAX);
   aInner->SetRect(nscoord_MIN/2, nscoord_MIN/2, nscoord_MAX, nscoord_MAX);
 
   const nsPoint normalPosition = aFrame->GetNormalPosition();
 
   // Bottom and top
   if (stick.YMost() != nscoord_MAX/2) {
@@ -259,25 +274,23 @@ StickyScrollContainer::GetScrollRanges(n
     aInner->SetRightEdge(normalPosition.x - stick.x);
     aOuter->SetRightEdge(contain.XMost() - stick.x);
   }
 }
 
 void
 StickyScrollContainer::PositionContinuations(nsIFrame* aFrame)
 {
-  NS_ASSERTION(!aFrame->GetPrevContinuation(),
+  NS_ASSERTION(nsLayoutUtils::IsFirstContinuationOrSpecialSibling(aFrame),
                "Should be starting from the first continuation");
-  nsPoint newPosition = ComputePosition(aFrame);
-  nsPoint translation = newPosition - aFrame->GetPosition();
-  aFrame->SetPosition(newPosition);
+  nsPoint translation = ComputePosition(aFrame) - aFrame->GetPosition();
 
   // Move all continuation frames by the same amount.
-  for (nsIFrame* cont = aFrame->GetNextContinuation(); cont;
-       cont = cont->GetNextContinuation()) {
+  for (nsIFrame* cont = aFrame; cont;
+       cont = nsLayoutUtils::GetNextContinuationOrSpecialSibling(cont)) {
     cont->SetPosition(cont->GetPosition() + translation);
   }
 }
 
 void
 StickyScrollContainer::UpdatePositions(nsPoint aScrollPosition,
                                        nsIFrame* aSubtreeRoot)
 {
@@ -289,26 +302,34 @@ StickyScrollContainer::UpdatePositions(n
   }
 #endif
   mScrollPosition = aScrollPosition;
 
   OverflowChangedTracker oct;
   oct.SetSubtreeRoot(aSubtreeRoot);
   for (nsTArray<nsIFrame*>::size_type i = 0; i < mFrames.Length(); i++) {
     nsIFrame* f = mFrames[i];
+    if (!nsLayoutUtils::IsFirstContinuationOrSpecialSibling(f)) {
+      // This frame was added in nsFrame::Init before we knew it wasn't
+      // the first special-sibling.
+      mFrames.RemoveElementAt(i);
+      --i;
+      continue;
+    }
 
     if (aSubtreeRoot) {
       // Reflowing the scroll frame, so recompute offsets.
       ComputeStickyOffsets(f);
     }
     // mFrames will only contain first continuations, because we filter in
     // nsIFrame::Init.
     PositionContinuations(f);
 
-    for (nsIFrame* cont = f; cont; cont = cont->GetNextContinuation()) {
+    for (nsIFrame* cont = f; cont;
+         cont = nsLayoutUtils::GetNextContinuationOrSpecialSibling(cont)) {
       oct.AddFrame(cont);
     }
   }
   oct.Flush();
 }
 
 void
 StickyScrollContainer::ScrollPositionWillChange(nscoord aX, nscoord aY)
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -509,16 +509,21 @@ nsFrame::Init(nsIContent*      aContent,
   if (disp->HasTransform(this)) {
     // The frame gets reconstructed if we toggle the -moz-transform
     // property, so we can set this bit here and then ignore it.
     mState |= NS_FRAME_MAY_BE_TRANSFORMED;
   }
   if (disp->mPosition == NS_STYLE_POSITION_STICKY &&
       !aPrevInFlow &&
       !(mState & NS_FRAME_IS_NONDISPLAY)) {
+    // Note that we only add first continuations, but we really only
+    // want to add first continuation-or-special-siblings.  But since we
+    // don't yet know if we're a later part of a block-in-inline split,
+    // we'll just add later members of a block-in-inline split here, and
+    // then StickyScrollContainer will remove them later.
     StickyScrollContainer* ssc =
       StickyScrollContainer::GetStickyScrollContainerForFrame(this);
     if (ssc) {
       ssc->AddFrame(this);
     }
   }
 
   if (nsLayoutUtils::FontSizeInflationEnabled(PresContext()) || !GetParent()
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -867,17 +867,19 @@ nsHTMLReflowState::ApplyRelativePosition
   } else {
     props.Set(nsIFrame::NormalPositionProperty(), new nsPoint(*aPosition));
   }
 
   const nsStyleDisplay* display = aFrame->StyleDisplay();
   if (NS_STYLE_POSITION_RELATIVE == display->mPosition) {
     *aPosition += nsPoint(aComputedOffsets.left, aComputedOffsets.top);
   } else if (NS_STYLE_POSITION_STICKY == display->mPosition &&
-             !aFrame->GetNextContinuation() && !aFrame->GetPrevContinuation()) {
+             !aFrame->GetNextContinuation() &&
+             !aFrame->GetPrevContinuation() &&
+             !(aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
     // Sticky positioning for elements with multiple frames needs to be
     // computed all at once. We can't safely do that here because we might be
     // partway through (re)positioning the frames, so leave it until the scroll
     // container reflows and calls StickyScrollContainer::UpdatePositions.
     // For single-frame sticky positioned elements, though, go ahead and apply
     // it now to avoid unnecessary overflow updates later.
     StickyScrollContainer* ssc =
       StickyScrollContainer::GetStickyScrollContainerForFrame(aFrame);
diff --git a/layout/reftests/position-sticky/block-in-inline-1.html b/layout/reftests/position-sticky/block-in-inline-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/position-sticky/block-in-inline-1.html
@@ -0,0 +1,42 @@
+<!DOCTYPE html>
+<!-- Any copyright is dedicated to the Public Domain.
+   - http://creativecommons.org/publicdomain/zero/1.0/ -->
+<html>
+  <head>
+    <title>CSS Test: Sticky Positioning - block inside inline, normal position</title>
+    <link rel="author" title="L. David Baron" href="mailto:dbaron@mozilla.com">
+    <link rel="match" href="block-in-inline-1-ref.html">
+    <meta name="assert" content="Inline elements split because they contain blocks should always have all parts moved the same offset from their normal position">
+    <style>
+      #scroll {
+        height: 100px;
+        overflow: hidden;
+        font-size: 16px;
+        line-height: 1.0;
+      }
+      #contain {
+        height: 100px;
+      }
+      #sticky {
+        display: inline;
+        position: sticky;
+        top: 10px;
+      }
+    </style>
+  </head>
+  <body>
+    <div id="scroll">
+      <div style="height: 20px"></div>
+      <div id="contain">
+        before inline
+        <div id="sticky">
+          before block
+          <div>in block</div>
+          after block
+        </div>
+        after inline
+      </div>
+      <div style="height: 100px"></div>
+    </div>
+  </body>
+</html>
diff --git a/layout/reftests/position-sticky/block-in-inline-2.html b/layout/reftests/position-sticky/block-in-inline-2.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/position-sticky/block-in-inline-2.html
@@ -0,0 +1,45 @@
+<!DOCTYPE html>
+<!-- Any copyright is dedicated to the Public Domain.
+   - http://creativecommons.org/publicdomain/zero/1.0/ -->
+<html>
+  <head>
+    <title>CSS Test: Sticky Positioning - block inside inline, stuck position</title>
+    <link rel="author" title="L. David Baron" href="mailto:dbaron@mozilla.com">
+    <link rel="match" href="block-in-inline-2-ref.html">
+    <meta name="assert" content="Inline elements split because they contain blocks should always have all parts moved the same offset from their normal position">
+    <style>
+      #scroll {
+        height: 100px;
+        overflow: hidden;
+        font-size: 16px;
+        line-height: 1.0;
+      }
+      #contain {
+        height: 100px;
+      }
+      #sticky {
+        display: inline;
+        position: sticky;
+        top: 10px;
+      }
+    </style>
+  </head>
+  <body>
+    <div id="scroll">
+      <div style="height: 20px"></div>
+      <div id="contain">
+        before inline
+        <div id="sticky">
+          before block
+          <div>in block</div>
+          after block
+        </div>
+        after inline
+      </div>
+      <div style="height: 100px"></div>
+    </div>
+    <script type="application/javascript">
+      document.getElementById("scroll").scrollTop = 30;
+    </script>
+  </body>
+</html>
diff --git a/layout/reftests/position-sticky/block-in-inline-3.html b/layout/reftests/position-sticky/block-in-inline-3.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/position-sticky/block-in-inline-3.html
@@ -0,0 +1,47 @@
+<!DOCTYPE html>
+<!-- Any copyright is dedicated to the Public Domain.
+   - http://creativecommons.org/publicdomain/zero/1.0/ -->
+<html>
+  <head>
+    <title>CSS Test: Sticky Positioning - block inside inline, contained position</title>
+    <link rel="author" title="L. David Baron" href="mailto:dbaron@mozilla.com">
+    <link rel="match" href="block-in-inline-3-ref.html">
+    <meta name="assert" content="Inline elements split because they contain blocks should always have all parts moved the same offset from their normal position">
+    <style>
+      #scroll {
+        height: 100px;
+        overflow: hidden;
+        font-size: 16px;
+        line-height: 1.0;
+      }
+      #contain {
+        height: 100px;
+      }
+      #sticky {
+        display: inline;
+        position: sticky;
+        top: 10px;
+      }
+    </style>
+  </head>
+  <body>
+    <div id="scroll">
+      <div style="height: 20px"></div>
+      <div id="contain">
+        before inline
+        <div id="sticky">
+          before block
+          <div>in block</div>
+          after block
+        </div>
+        after inline
+      </div>
+      <div style="height: 100px"></div>
+    </div>
+    <script type="application/javascript">
+      // should start moving after 62px
+      // FIXME: actually starts moving after 59px
+      document.getElementById("scroll").scrollTop = 92;
+    </script>
+  </body>
+</html>
diff --git a/layout/reftests/position-sticky/reftest.list b/layout/reftests/position-sticky/reftest.list
--- a/layout/reftests/position-sticky/reftest.list
+++ b/layout/reftests/position-sticky/reftest.list
@@ -41,8 +41,11 @@ fuzzy-if(Android,4,1) == containing-bloc
 == overconstrained-1.html overconstrained-1-ref.html
 == overconstrained-2.html overconstrained-2-ref.html
 == overconstrained-3.html overconstrained-3-ref.html
 == inline-1.html inline-1-ref.html
 == inline-2.html inline-2-ref.html
 fails == inline-3.html inline-3-ref.html # bug 916302
 fails == column-contain-1a.html column-contain-1-ref.html
 == column-contain-1b.html column-contain-1-ref.html
+== block-in-inline-1.html block-in-inline-1-ref.html
+== block-in-inline-2.html block-in-inline-2-ref.html
+== block-in-inline-3.html block-in-inline-3-ref.html
diff --git a/layout/style/ua.css b/layout/style/ua.css
--- a/layout/style/ua.css
+++ b/layout/style/ua.css
@@ -204,18 +204,18 @@
 }
 
 *|*::-moz-pagebreak {
   display: block !important;
 }
 
 *|*::-moz-anonymous-positioned-block {
   display: block !important;
-  position: relative;
-  top: inherit; 
+  position: inherit; /* relative or sticky */
+  top: inherit;
   left: inherit;
   bottom: inherit;
   right: inherit;
   z-index: inherit;
   clip: inherit;
   opacity: inherit;
   unicode-bidi: inherit;
   text-overflow: inherit;
