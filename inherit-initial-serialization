Handle serialization of inherit and -moz-initial for shorthand properties correctly, and refuse to serialize most unspecifiable cases of shorthands.  (Bug 160403)

diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -172,24 +172,16 @@ nsCSSDeclaration::GetValueOrImportantVal
 
   nsCSSCompressedDataBlock *data = GetValueIsImportant(aProperty)
                                      ? mImportantData : mData;
   const void *storage = data->StorageFor(aProperty);
   if (!storage)
     return NS_OK;
   aValue = *static_cast<const nsCSSValue*>(storage);
   return NS_OK;
-}
-
-nsresult
-nsCSSDeclaration::GetValue(const nsAString& aProperty,
-                           nsAString& aValue) const
-{
-  nsCSSProperty propID = nsCSSProps::LookupProperty(aProperty);
-  return GetValue(propID, aValue);
 }
 
 PRBool nsCSSDeclaration::AppendValueToString(nsCSSProperty aProperty, nsAString& aResult) const
 {
   nsCSSCompressedDataBlock *data = GetValueIsImportant(aProperty)
                                       ? mImportantData : mData;
   const void *storage = data->StorageFor(aProperty);
   if (storage) {
@@ -532,23 +524,114 @@ nsCSSDeclaration::GetValue(nsCSSProperty
   aValue.Truncate(0);
 
   // simple properties are easy.
   if (!nsCSSProps::IsShorthand(aProperty)) {
     AppendValueToString(aProperty, aValue);
     return NS_OK;
   }
 
-  // shorthands
+  // DOM Level 2 Style says (when describing CSS2Properties, although
+  // not CSSStyleDeclaration.getPropertyValue):
+  //   However, if there is no shorthand declaration that could be added
+  //   to the ruleset without changing in any way the rules already
+  //   declared in the ruleset (i.e., by adding longhand rules that were
+  //   previously not declared in the ruleset), then the empty string
+  //   should be returned for the shorthand property.
+  // This means we need to check a number of cases:
+  //   (1) Since a shorthand sets all sub-properties, if some of its
+  //       subproperties were not specified, we must return the empty
+  //       string.
+  //   (2) Since 'inherit' and 'initial' can only be specified as the
+  //       values for entire properties, we need to return the empty
+  //       string if some but not all of the subproperties have one of
+  //       those values.
+  //   (3) Since a single value only makes sense with or without
+  //       !important, we return the empty string if some values are
+  //       !important and some are not.
+  // Since we're doing this check for 'inherit' and 'initial' up front,
+  // we can also simplify the property serialization code by serializing
+  // those values up front as well.
+  PRUint32 totalCount = 0, importantCount = 0,
+           initialCount = 0, inheritCount = 0;
   CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(p, aProperty) {
-    if (!mData->StorageFor(*p) &&
-        (!mImportantData || !mImportantData->StorageFor(*p)))
-      // We don't have all the properties in the shorthand.
-      if (*p != eCSSProperty__x_system_font)
-        return NS_OK;
+    if (*p == eCSSProperty__x_system_font) {
+      // The system_font subproperty doesn't count.
+      continue;
+    }
+    ++totalCount;
+    const void *storage = mData->StorageFor(*p);
+    NS_ASSERTION(!storage || !mImportantData || !mImportantData->StorageFor(*p),
+                 "can't be in both blocks");
+    if (!storage) {
+      ++importantCount;
+      storage = mImportantData->StorageFor(*p);
+    }
+    if (!storage) {
+      // Case (1) above: some subproperties not specified.
+      return NS_OK;
+    }
+    nsCSSUnit unit;
+    switch (nsCSSProps::kTypeTable[*p]) {
+      case eCSSType_Value: {
+        const nsCSSValue *val = static_cast<const nsCSSValue*>(storage);
+        unit = val->GetUnit();
+      } break;
+      case eCSSType_Rect: {
+        const nsCSSRect *rect = static_cast<const nsCSSRect*>(storage);
+        unit = val->mTop.GetUnit();
+      } break;
+      case eCSSType_ValuePair: {
+        const nsCSSValuePair *pair = static_cast<const nsCSSValuePair*>(storage);
+        unit = val->mXValue.GetUnit();
+      } break;
+      case eCSSType_ValueList: {
+        const nsCSSValueList* item =
+            *static_cast<nsCSSValueList*const*>(storage);
+        if (item) {
+          unit = item->mValue.GetUnit();
+        } else {
+          unit = eCSSUnit_Null;
+        }
+      } break;
+      case eCSSType_ValuePairList: {
+        const nsCSSValuePairList* item =
+            *static_cast<nsCSSValuePairList*const*>(storage);
+        if (item) {
+          unit = item->mXValue.GetUnit();
+        } else {
+          unit = eCSSUnit_Null;
+        }
+      } break;
+    }
+    if (unit == eCSSUnit_Inherit) {
+      ++inheritCount;
+    } else if (unit == eCSSUnit_Initial) {
+      ++initialCount;
+    }
+  }
+  if (importantCount != 0 && importantCount != totalCount) {
+    // Case (3), no consistent importance.
+    return NS_OK;
+  }
+  if (initialCount == totalCount) {
+    // Simplify serialization below by serializing initial up-front.
+    AppendCSSValueToString(eCSSProperty_UNKNOWN, nsCSSValue(eCSSUnit_Initial),
+                           aValue);
+    return NS_OK;
+  }
+  if (inheritCount == totalCount) {
+    // Simplify serialization below by serializing inherit up-front.
+    AppendCSSValueToString(eCSSProperty_UNKNOWN, nsCSSValue(eCSSUnit_Inherit),
+                           aValue);
+    return NS_OK;
+  }
+  if (initialCount != 0 || inheritCount != 0) {
+    // Case (2): partially initial or inherit.
+    return NS_OK;
   }
 
 
   // XXX What about checking the consistency of '!important'?
   // XXX What about checking that we don't serialize inherit,
   // -moz-initial, or other illegal values?
   // XXXldb Can we share shorthand logic with ToString?
   switch (aProperty) {
@@ -750,17 +833,32 @@ nsCSSDeclaration::GetValueIsImportant(co
 }
 
 PRBool
 nsCSSDeclaration::GetValueIsImportant(nsCSSProperty aProperty) const
 {
   if (!mImportantData)
     return PR_FALSE;
 
-  // Inefficient, but we can assume '!important' is rare.
+  // Calling StorageFor is inefficient, but we can assume '!important'
+  // is rare.
+
+  if (nsCSSProps::IsShorthand(aProperty)) {
+    CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(p, aProperty) {
+      if (*p == eCSSProperty__x_system_font) {
+        // The system_font subproperty doesn't count.
+        continue;
+      }
+      if (!mImportantData->StorageFor(*p)) {
+        return PR_FALSE;
+      }
+    }
+    return PR_TRUE;
+  }
+
   return mImportantData->StorageFor(aProperty) != nsnull;
 }
 
 // XXXldb Bug 376075 All callers of AllPropertiesSameImportance also
 // need to check for 'inherit' and 'initial' values, since you can't
 // output a mix of either mixed with other values in the same shorthand!
 PRBool
 nsCSSDeclaration::AllPropertiesSameImportance(PRInt32 aFirst, PRInt32 aSecond,
diff --git a/layout/style/nsCSSDeclaration.h b/layout/style/nsCSSDeclaration.h
--- a/layout/style/nsCSSDeclaration.h
+++ b/layout/style/nsCSSDeclaration.h
@@ -72,17 +72,16 @@ public:
    * for this declaration.
    */
   nsresult ValueAppended(nsCSSProperty aProperty);
 
   nsresult AppendComment(const nsAString& aComment);
   nsresult RemoveProperty(nsCSSProperty aProperty);
 
   nsresult GetValue(nsCSSProperty aProperty, nsAString& aValue) const;
-  nsresult GetValue(const nsAString& aProperty, nsAString& aValue) const;
 
   PRBool HasImportantData() const { return mImportantData != nsnull; }
   PRBool GetValueIsImportant(nsCSSProperty aProperty) const;
   PRBool GetValueIsImportant(const nsAString& aProperty) const;
 
   PRUint32 Count() const {
     return mOrder.Length(); 
   }
diff --git a/layout/style/test/test_inherit_storage.html b/layout/style/test/test_inherit_storage.html
--- a/layout/style/test/test_inherit_storage.html
+++ b/layout/style/test/test_inherit_storage.html
@@ -19,41 +19,16 @@ https://bugzilla.mozilla.org/show_bug.cg
   
 </div>
 <pre id="test">
 <script class="testbody" type="text/javascript">
 
 /** Test for parsing, storage, and serialization of CSS 'inherit' **/
 
 var gDeclaration = document.getElementById("testnode").style;
-
-var gKnownFails = {
-  /* bug 377519: */
-  "-moz-border-end": true,
-  "-moz-border-radius": true,
-  "-moz-border-start": true,
-  "-moz-column-rule": true,
-  "-moz-outline-radius": true,
-  "background": true,
-  "border": true,
-  "border-bottom": true,
-  "border-color": true,
-  "border-left": true,
-  "border-right": true,
-  "border-style": true,
-  "border-top": true,
-  "border-width": true,
-  "cue": true,
-  "font": true,
-  "list-style": true,
-  "margin": true,
-  "outline": true,
-  "padding": true,
-  "pause": true
-};
 
 var gKnownFails2 = {
   "-moz-border-end": true,
   "-moz-border-radius": true,
   "-moz-border-start": true,
   "-moz-column-rule": true,
   "-moz-outline-radius": true,
   "background": true,
@@ -87,21 +62,18 @@ function test_property(property)
     for (var idx in info.subproperties)
       check_initial(info.subproperties[idx]);
 
   gDeclaration.setProperty(property, "inherit", "");
 
   function check_set(sproperty) {
     var sinfo = gCSSProperties[sproperty];
     val = gDeclaration.getPropertyValue(sproperty);
-    var func = is;
-    if (sproperty == property && property in gKnownFails)
-      func = todo_is;
-    func(val, "inherit",
-         "inherit reported back for property '" + sproperty + "'");
+    is(val, "inherit",
+       "inherit reported back for property '" + sproperty + "'");
     if (sinfo.domProp) {
       is(val, gDeclaration[sinfo.domProp],
          "consistency between decl.getPropertyValue('" + sproperty +
          "') and decl." + sinfo.domProp);
     }
   }
   check_set(property);
   if ("subproperties" in info)
diff --git a/layout/style/test/test_initial_storage.html b/layout/style/test/test_initial_storage.html
--- a/layout/style/test/test_initial_storage.html
+++ b/layout/style/test/test_initial_storage.html
@@ -19,41 +19,16 @@ https://bugzilla.mozilla.org/show_bug.cg
   
 </div>
 <pre id="test">
 <script class="testbody" type="text/javascript">
 
 /** Test for parsing, storage, and serialization of CSS '-moz-initial' **/
 
 var gDeclaration = document.getElementById("testnode").style;
-
-var gKnownFails = {
-  /* bug 377519: */
-  "-moz-border-end": true,
-  "-moz-border-radius": true,
-  "-moz-border-start": true,
-  "-moz-column-rule": true,
-  "-moz-outline-radius": true,
-  "background": true,
-  "border": true,
-  "border-bottom": true,
-  "border-color": true,
-  "border-left": true,
-  "border-right": true,
-  "border-style": true,
-  "border-top": true,
-  "border-width": true,
-  "cue": true,
-  "font": true,
-  "list-style": true,
-  "margin": true,
-  "outline": true,
-  "padding": true,
-  "pause": true
-};
 
 var gKnownFails2 = {
   "-moz-border-end": true,
   "-moz-border-radius": true,
   "-moz-border-start": true,
   "-moz-column-rule": true,
   "-moz-outline-radius": true,
   "background": true,
@@ -87,21 +62,18 @@ function test_property(property)
     for (var idx in info.subproperties)
       check_initial(info.subproperties[idx]);
 
   gDeclaration.setProperty(property, "-moz-initial", "");
 
   function check_set(sproperty) {
     var sinfo = gCSSProperties[sproperty];
     val = gDeclaration.getPropertyValue(sproperty);
-    var func = is;
-    if (sproperty == property && property in gKnownFails)
-      func = todo_is;
-    func(val, "-moz-initial",
-         "-moz-initial reported back for property '" + sproperty + "'");
+    is(val, "-moz-initial",
+       "-moz-initial reported back for property '" + sproperty + "'");
     if (sinfo.domProp) {
       is(val, gDeclaration[sinfo.domProp],
          "consistency between decl.getPropertyValue('" + sproperty +
          "') and decl." + sinfo.domProp);
     }
   }
   check_set(property);
   if ("subproperties" in info)
