Handle serialization of inherit and -moz-initial for shorthand properties correctly, and refuse to serialize most unspecifiable cases of shorthands.  (Bug 160403)

diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -172,24 +172,16 @@ nsCSSDeclaration::GetValueOrImportantVal
 
   nsCSSCompressedDataBlock *data = GetValueIsImportant(aProperty)
                                      ? mImportantData : mData;
   const void *storage = data->StorageFor(aProperty);
   if (!storage)
     return NS_OK;
   aValue = *static_cast<const nsCSSValue*>(storage);
   return NS_OK;
-}
-
-nsresult
-nsCSSDeclaration::GetValue(const nsAString& aProperty,
-                           nsAString& aValue) const
-{
-  nsCSSProperty propID = nsCSSProps::LookupProperty(aProperty);
-  return GetValue(propID, aValue);
 }
 
 PRBool nsCSSDeclaration::AppendValueToString(nsCSSProperty aProperty, nsAString& aResult) const
 {
   nsCSSCompressedDataBlock *data = GetValueIsImportant(aProperty)
                                       ? mImportantData : mData;
   const void *storage = data->StorageFor(aProperty);
   if (storage) {
@@ -532,23 +524,114 @@ nsCSSDeclaration::GetValue(nsCSSProperty
   aValue.Truncate(0);
 
   // simple properties are easy.
   if (!nsCSSProps::IsShorthand(aProperty)) {
     AppendValueToString(aProperty, aValue);
     return NS_OK;
   }
 
-  // shorthands
+  // DOM Level 2 Style says (when describing CSS2Properties, although
+  // not CSSStyleDeclaration.getPropertyValue):
+  //   However, if there is no shorthand declaration that could be added
+  //   to the ruleset without changing in any way the rules already
+  //   declared in the ruleset (i.e., by adding longhand rules that were
+  //   previously not declared in the ruleset), then the empty string
+  //   should be returned for the shorthand property.
+  // This means we need to check a number of cases:
+  //   (1) Since a shorthand sets all sub-properties, if some of its
+  //       subproperties were not specified, we must return the empty
+  //       string.
+  //   (2) Since 'inherit' and 'initial' can only be specified as the
+  //       values for entire properties, we need to return the empty
+  //       string if some but not all of the subproperties have one of
+  //       those values.
+  //   (3) Since a single value only makes sense with or without
+  //       !important, we return the empty string if some values are
+  //       !important and some are not.
+  // Since we're doing this check for 'inherit' and 'initial' up front,
+  // we can also simplify the property serialization code by serializing
+  // those values up front as well.
+  PRUint32 totalCount = 0, importantCount = 0,
+           initialCount = 0, inheritCount = 0;
   CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(p, aProperty) {
-    if (!mData->StorageFor(*p) &&
-        (!mImportantData || !mImportantData->StorageFor(*p)))
-      // We don't have all the properties in the shorthand.
-      if (*p != eCSSProperty__x_system_font)
-        return NS_OK;
+    if (*p == eCSSProperty__x_system_font) {
+      // The system_font subproperty doesn't count.
+      continue;
+    }
+    ++totalCount;
+    const void *storage = mData->StorageFor(*p);
+    NS_ASSERTION(!storage || !mImportantData || !mImportantData->StorageFor(*p),
+                 "can't be in both blocks");
+    if (!storage) {
+      ++importantCount;
+      storage = mImportantData->StorageFor(*p);
+    }
+    if (!storage) {
+      // Case (1) above: some subproperties not specified.
+      return NS_OK;
+    }
+    nsCSSUnit unit;
+    switch (nsCSSProps::kTypeTable[*p]) {
+      case eCSSType_Value: {
+        const nsCSSValue *val = static_cast<const nsCSSValue*>(storage);
+        unit = val->GetUnit();
+      } break;
+      case eCSSType_Rect: {
+        const nsCSSRect *rect = static_cast<const nsCSSRect*>(storage);
+        unit = val->mTop.GetUnit();
+      } break;
+      case eCSSType_ValuePair: {
+        const nsCSSValuePair *pair = static_cast<const nsCSSValuePair*>(storage);
+        unit = val->mXValue.GetUnit();
+      } break;
+      case eCSSType_ValueList: {
+        const nsCSSValueList* item =
+            *static_cast<nsCSSValueList*const*>(storage);
+        if (item) {
+          unit = item->mValue.GetUnit();
+        } else {
+          unit = eCSSUnit_Null;
+        }
+      } break;
+      case eCSSType_ValuePairList: {
+        const nsCSSValuePairList* item =
+            *static_cast<nsCSSValuePairList*const*>(storage);
+        if (item) {
+          unit = item->mXValue.GetUnit();
+        } else {
+          unit = eCSSUnit_Null;
+        }
+      } break;
+    }
+    if (unit == eCSSUnit_Inherit) {
+      ++inheritCount;
+    } else if (unit == eCSSUnit_Initial) {
+      ++initialCount;
+    }
+  }
+  if (importantCount != 0 && importantCount != totalCount) {
+    // Case (3), no consistent importance.
+    return NS_OK;
+  }
+  if (initialCount == totalCount) {
+    // Simplify serialization below by serializing initial up-front.
+    AppendCSSValueToString(eCSSProperty_UNKNOWN, nsCSSValue(eCSSUnit_Initial),
+                           aValue);
+    return NS_OK;
+  }
+  if (inheritCount == totalCount) {
+    // Simplify serialization below by serializing inherit up-front.
+    AppendCSSValueToString(eCSSProperty_UNKNOWN, nsCSSValue(eCSSUnit_Inherit),
+                           aValue);
+    return NS_OK;
+  }
+  if (initialCount != 0 || inheritCount != 0) {
+    // Case (2): partially initial or inherit.
+    return NS_OK;
   }
 
 
   // XXX What about checking the consistency of '!important'?
   // XXX What about checking that we don't serialize inherit,
   // -moz-initial, or other illegal values?
   // XXXldb Can we share shorthand logic with ToString?
   switch (aProperty) {
@@ -750,17 +833,32 @@ nsCSSDeclaration::GetValueIsImportant(co
 }
 
 PRBool
 nsCSSDeclaration::GetValueIsImportant(nsCSSProperty aProperty) const
 {
   if (!mImportantData)
     return PR_FALSE;
 
-  // Inefficient, but we can assume '!important' is rare.
+  // Calling StorageFor is inefficient, but we can assume '!important'
+  // is rare.
+
+  if (nsCSSProps::IsShorthand(aProperty)) {
+    CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(p, aProperty) {
+      if (*p == eCSSProperty__x_system_font) {
+        // The system_font subproperty doesn't count.
+        continue;
+      }
+      if (!mImportantData->StorageFor(*p)) {
+        return PR_FALSE;
+      }
+    }
+    return PR_TRUE;
+  }
+
   return mImportantData->StorageFor(aProperty) != nsnull;
 }
 
 // XXXldb Bug 376075 All callers of AllPropertiesSameImportance also
 // need to check for 'inherit' and 'initial' values, since you can't
 // output a mix of either mixed with other values in the same shorthand!
 PRBool
 nsCSSDeclaration::AllPropertiesSameImportance(PRInt32 aFirst, PRInt32 aSecond,
diff --git a/layout/style/nsCSSDeclaration.h b/layout/style/nsCSSDeclaration.h
--- a/layout/style/nsCSSDeclaration.h
+++ b/layout/style/nsCSSDeclaration.h
@@ -72,17 +72,16 @@ public:
    * for this declaration.
    */
   nsresult ValueAppended(nsCSSProperty aProperty);
 
   nsresult AppendComment(const nsAString& aComment);
   nsresult RemoveProperty(nsCSSProperty aProperty);
 
   nsresult GetValue(nsCSSProperty aProperty, nsAString& aValue) const;
-  nsresult GetValue(const nsAString& aProperty, nsAString& aValue) const;
 
   PRBool HasImportantData() const { return mImportantData != nsnull; }
   PRBool GetValueIsImportant(nsCSSProperty aProperty) const;
   PRBool GetValueIsImportant(const nsAString& aProperty) const;
 
   PRUint32 Count() const {
     return mOrder.Length(); 
   }
