From: L. David Baron <dbaron@dbaron.org>

Check for UniversalXPConnect in trace-malloc hooks.  (Bug 600064)  r=jst

diff --git a/dom/base/nsJSEnvironment.cpp b/dom/base/nsJSEnvironment.cpp
--- a/dom/base/nsJSEnvironment.cpp
+++ b/dom/base/nsJSEnvironment.cpp
@@ -3064,38 +3064,59 @@ static JSClass OptionsClass = {
 #include <unistd.h>
 #endif
 #ifdef XP_WIN32
 #include <io.h>
 #endif
 #include "nsTraceMalloc.h"
 
 static JSBool
+CheckUniversalXPConnectForTraceMalloc(JSContext *cx)
+{
+    PRBool hasCap = PR_FALSE;
+    nsresult rv = nsContentUtils::GetSecurityManager()->
+                    IsCapabilityEnabled("UniversalXPConnect", &hasCap);
+    if (NS_SUCCEEDED(rv) && hasCap)
+        return JS_TRUE;
+    JS_ReportError(cx, "trace-malloc functions require UniversalXPConnect");
+    return JS_FALSE;
+}
+
+static JSBool
 TraceMallocDisable(JSContext *cx, uintN argc, jsval *vp)
 {
+    if (!CheckUniversalXPConnectForTraceMalloc(cx))
+        return JS_FALSE;
+
     NS_TraceMallocDisable();
     JS_SET_RVAL(cx, vp, JSVAL_VOID);
     return JS_TRUE;
 }
 
 static JSBool
 TraceMallocEnable(JSContext *cx, uintN argc, jsval *vp)
 {
+    if (!CheckUniversalXPConnectForTraceMalloc(cx))
+        return JS_FALSE;
+
     NS_TraceMallocEnable();
     JS_SET_RVAL(cx, vp, JSVAL_VOID);
     return JS_TRUE;
 }
 
 static JSBool
 TraceMallocOpenLogFile(JSContext *cx, uintN argc, jsval *vp)
 {
     int fd;
     JSString *str;
     char *filename;
 
+    if (!CheckUniversalXPConnectForTraceMalloc(cx))
+        return JS_FALSE;
+
     if (argc == 0) {
         fd = -1;
     } else {
         str = JS_ValueToString(cx, JS_ARGV(cx, vp)[0]);
         if (!str)
             return JS_FALSE;
         filename = JS_GetStringBytes(str);
         fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0644);
@@ -3108,16 +3129,19 @@ TraceMallocOpenLogFile(JSContext *cx, ui
     return JS_TRUE;
 }
 
 static JSBool
 TraceMallocChangeLogFD(JSContext *cx, uintN argc, jsval *vp)
 {
     int32 fd, oldfd;
 
+    if (!CheckUniversalXPConnectForTraceMalloc(cx))
+        return JS_FALSE;
+
     if (argc == 0) {
         oldfd = -1;
     } else {
         if (!JS_ValueToECMAInt32(cx, JS_ARGV(cx, vp)[0], &fd))
             return JS_FALSE;
         oldfd = NS_TraceMallocChangeLogFD(fd);
         if (oldfd == -2) {
             JS_ReportOutOfMemory(cx);
@@ -3128,46 +3152,55 @@ TraceMallocChangeLogFD(JSContext *cx, ui
     return JS_TRUE;
 }
 
 static JSBool
 TraceMallocCloseLogFD(JSContext *cx, uintN argc, jsval *vp)
 {
     int32 fd;
 
+    if (!CheckUniversalXPConnectForTraceMalloc(cx))
+        return JS_FALSE;
+
     JS_SET_RVAL(cx, vp, JSVAL_VOID);
     if (argc == 0)
         return JS_TRUE;
     if (!JS_ValueToECMAInt32(cx, JS_ARGV(cx, vp)[0], &fd))
         return JS_FALSE;
     NS_TraceMallocCloseLogFD((int) fd);
     return JS_TRUE;
 }
 
 static JSBool
 TraceMallocLogTimestamp(JSContext *cx, uintN argc, jsval *vp)
 {
     JSString *str;
     const char *caption;
 
+    if (!CheckUniversalXPConnectForTraceMalloc(cx))
+        return JS_FALSE;
+
     str = JS_ValueToString(cx, argc ? JS_ARGV(cx, vp)[0] : JSVAL_VOID);
     if (!str)
         return JS_FALSE;
     caption = JS_GetStringBytes(str);
     NS_TraceMallocLogTimestamp(caption);
     JS_SET_RVAL(cx, vp, JSVAL_VOID);
     return JS_TRUE;
 }
 
 static JSBool
 TraceMallocDumpAllocations(JSContext *cx, uintN argc, jsval *vp)
 {
     JSString *str;
     const char *pathname;
 
+    if (!CheckUniversalXPConnectForTraceMalloc(cx))
+        return JS_FALSE;
+
     str = JS_ValueToString(cx, argc ? JS_ARGV(cx, vp)[0] : JSVAL_VOID);
     if (!str)
         return JS_FALSE;
     pathname = JS_GetStringBytes(str);
     if (NS_TraceMallocDumpAllocations(pathname) < 0) {
         JS_ReportError(cx, "can't dump to %s: %s", pathname, strerror(errno));
         return JS_FALSE;
     }
