From: L. David Baron <dbaron@dbaron.org>

Bug 1153539 - Revert bug 972310 and restore behavior of rasterizing at the maximum scale of off-main-thread transform animations.

This reverts the changes in changeset 940b00462eb7 (bug 972310),
although it isn't a straight backout because the code was significantly
refactored in ab404d8e7d88 (and I also fixed the coment formatting in
FrameLayerBuilder.cpp and improved the comment wording in
nsLayoutUtils.h).

Prior to bug 972310, ChooseScaleAndSetTransform in FrameLayerBuilder.cpp
would call GetMaximumAnimatedScale, which led to rasterizing (for the
entire duration of the off-main-thread animation) at the largest scale
present over the course of that animation, which avoids pixelation.
This is roughly equivalent to the quality we get without off-main-thread
animation, where we round up the scale to the nearest power of 2 and
rerasterize as the animation progresses.

Bug 972310 made us instead choose the scale within the range of the
animation that is closest to 1.0.  This means that animations that
involve only scales smaller than 1.0 rasterize at the best quality,
whereas animations involving only scales larger than 1.0 rasterize at
the worst quality.  This doesn't make sense as an API; the quality of
the animation shouldn't be a function of what numbers are being used for
the transform (especially considering how those numbers interact with
other transforms).

This change was made to optimize a particular animation in Firefox OS,
where unlocking the lockscreen zooms in (to 2x) and fades out at the
same time.  This animation will need to be optimized some other way.

diff --git a/layout/base/FrameLayerBuilder.cpp b/layout/base/FrameLayerBuilder.cpp
--- a/layout/base/FrameLayerBuilder.cpp
+++ b/layout/base/FrameLayerBuilder.cpp
@@ -4562,22 +4562,22 @@ ChooseScaleAndSetTransform(FrameLayerBui
   if (transform.IsSingular()) {
     return false;
   }
 
   bool canDraw2D = transform.CanDraw2D(&transform2d);
   gfxSize scale;
   // XXX Should we do something for 3D transforms?
   if (canDraw2D) {
-    // If the container's transform is animated off main thread, fix a suitable scale size
-    // for animation
+    // If the container's transform is animated off main thread, then use the
+    // maximum scale.
     if (aContainerFrame->GetContent() &&
         nsLayoutUtils::HasAnimationsForCompositor(
           aContainerFrame->GetContent(), eCSSProperty_transform)) {
-      scale = nsLayoutUtils::ComputeSuitableScaleForAnimation(aContainerFrame->GetContent());
+      scale = nsLayoutUtils::GetMaximumAnimatedScale(aContainerFrame->GetContent());
     } else {
       // Scale factors are normalized to a power of 2 to reduce the number of resolution changes
       scale = RoundToFloatPrecision(ThebesMatrix(transform2d).ScaleFactors(true));
       // For frames with a changing transform that's not just a translation,
       // round scale factors up to nearest power-of-2 boundary so that we don't
       // keep having to redraw the content as it scales up and down. Rounding up to nearest
       // power-of-2 boundary ensures we never scale up, only down --- avoiding
       // jaggies. It also ensures we never scale down by more than a factor of 2,
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -474,97 +474,72 @@ GetScaleForValue(const StyleAnimationVal
   bool canDraw2D = transform.CanDraw2D(&transform2d);
   if (!canDraw2D) {
     return gfxSize();
   }
 
   return transform2d.ScaleFactors(true);
 }
 
-static float
-GetSuitableScale(float aMaxScale, float aMinScale)
-{
-  // If the minimum scale >= 1.0f, use it; if the maximum <= 1.0f, use it;
-  // otherwise use 1.0f.
-  if (aMinScale >= 1.0f) {
-    return aMinScale;
-  }
-  else if (aMaxScale <= 1.0f) {
-    return aMaxScale;
-  }
-
-  return 1.0f;
-}
-
 static void
-GetMinAndMaxScaleForAnimationProperty(nsIContent* aContent,
-                                      AnimationCollection* aAnimations,
-                                      gfxSize& aMaxScale,
-                                      gfxSize& aMinScale)
+GetMaxScaleForAnimationProperty(nsIContent* aContent,
+                                AnimationCollection* aAnimations,
+                                gfxSize& aMaxScale)
 {
   for (size_t animIdx = aAnimations->mAnimations.Length(); animIdx-- != 0; ) {
     dom::Animation* anim = aAnimations->mAnimations[animIdx];
     if (!anim->GetEffect() || anim->GetEffect()->IsFinishedTransition()) {
       continue;
     }
     dom::KeyframeEffectReadonly* effect = anim->GetEffect();
     for (size_t propIdx = effect->Properties().Length(); propIdx-- != 0; ) {
       AnimationProperty& prop = effect->Properties()[propIdx];
       if (prop.mProperty == eCSSProperty_transform) {
         for (uint32_t segIdx = prop.mSegments.Length(); segIdx-- != 0; ) {
           AnimationPropertySegment& segment = prop.mSegments[segIdx];
           gfxSize from = GetScaleForValue(segment.mFromValue,
                                           aContent->GetPrimaryFrame());
           aMaxScale.width = std::max<float>(aMaxScale.width, from.width);
           aMaxScale.height = std::max<float>(aMaxScale.height, from.height);
-          aMinScale.width = std::min<float>(aMinScale.width, from.width);
-          aMinScale.height = std::min<float>(aMinScale.height, from.height);
           gfxSize to = GetScaleForValue(segment.mToValue,
                                         aContent->GetPrimaryFrame());
           aMaxScale.width = std::max<float>(aMaxScale.width, to.width);
           aMaxScale.height = std::max<float>(aMaxScale.height, to.height);
-          aMinScale.width = std::min<float>(aMinScale.width, to.width);
-          aMinScale.height = std::min<float>(aMinScale.height, to.height);
         }
       }
     }
   }
 }
 
 gfxSize
-nsLayoutUtils::ComputeSuitableScaleForAnimation(nsIContent* aContent)
+nsLayoutUtils::GetMaximumAnimatedScale(nsIContent* aContent)
 {
   gfxSize maxScale(std::numeric_limits<gfxFloat>::min(),
                    std::numeric_limits<gfxFloat>::min());
-  gfxSize minScale(std::numeric_limits<gfxFloat>::max(),
-                   std::numeric_limits<gfxFloat>::max());
 
   AnimationCollection* animations =
     nsAnimationManager::GetAnimationsForCompositor(aContent,
                                                    eCSSProperty_transform);
   if (animations) {
-    GetMinAndMaxScaleForAnimationProperty(aContent, animations,
-                                          maxScale, minScale);
+    GetMaxScaleForAnimationProperty(aContent, animations, maxScale);
   }
 
   animations =
     nsTransitionManager::GetAnimationsForCompositor(aContent,
                                                     eCSSProperty_transform);
   if (animations) {
-    GetMinAndMaxScaleForAnimationProperty(aContent, animations,
-                                          maxScale, minScale);
+    GetMaxScaleForAnimationProperty(aContent, animations, maxScale);
   }
 
   if (maxScale.width == std::numeric_limits<gfxFloat>::min()) {
     // We didn't encounter a transform
-    maxScale = minScale = gfxSize(1.0, 1.0);
-  }
-
-  return gfxSize(GetSuitableScale(maxScale.width, minScale.width),
-                 GetSuitableScale(maxScale.height, minScale.height));
+    maxScale = gfxSize(1.0, 1.0);
+  }
+
+  return maxScale;
 }
 
 bool
 nsLayoutUtils::AreAsyncAnimationsEnabled()
 {
   static bool sAreAsyncAnimationsEnabled;
   static bool sAsyncPrefCached = false;
 
diff --git a/layout/base/nsLayoutUtils.h b/layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h
+++ b/layout/base/nsLayoutUtils.h
@@ -2141,24 +2141,22 @@ public:
   static bool AreAsyncAnimationsEnabled();
 
   /**
    * Checks if we should warn about animations that can't be async
    */
   static bool IsAnimationLoggingEnabled();
 
   /**
-   * Find a suitable scale for an element (aContent) over the course of any
-   * animations and transitions on the element.
-   * It will check the maximum and minimum scale during the animations and
-   * transitions and return a suitable value for performance and quality.
-   * Will return scale(1,1) if there is no animated scaling.
-   * Always return positive value.
+   * Find the maximum scale for an element (aContent) over the course of any
+   * animations and transitions of the CSS transform property on the
+   * element that are running on the compositor thread.  Will return 1,1
+   * if there are no such animations.
    */
-  static gfxSize ComputeSuitableScaleForAnimation(nsIContent* aContent);
+  static gfxSize GetMaximumAnimatedScale(nsIContent* aContent);
 
   /**
    * Checks if we should forcibly use nearest pixel filtering for the
    * background.
    */
   static bool UseBackgroundNearestFiltering();
 
   /**
