From: L. David Baron <dbaron@dbaron.org>

Additional restyling is needed for :empty + E and :empty ~ E selectors.  (Bug 534804)

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -11386,16 +11386,34 @@ nsCSSFrameConstructor::ReframeContaining
     }
   }
 
   // If we get here, we're screwed!
   return RecreateFramesForContent(mPresShell->GetDocument()->GetRootContent(), PR_TRUE);
 }
 
 void
+nsCSSFrameConstructor::RestyleForEmptyChange(nsIContent* aContainer)
+{
+  nsIContent* toRestyle = aContainer;
+  // In some cases (:empty + E, :empty ~ E), a change if the content of
+  // an element requires restyling its grandparent, because it changes
+  // its parent's :empty state.
+  // REVIEW: Is it really ok to checkonly
+  // NODE_HAS_SLOW_SELECTOR_NOAPPEND and not NODE_HAS_SLOW_SELECTOR?  We
+  // should at least document the difference where those are defined.
+  nsIContent* grandparent = aContainer->GetParent();
+  if (grandparent &&
+      (grandparent->GetFlags() & NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
+    toRestyle = grandparent;
+  }
+  PostRestyleEvent(toRestyle, eReStyle_Self, NS_STYLE_HINT_NONE);
+}
+
+void
 nsCSSFrameConstructor::RestyleForAppend(nsIContent* aContainer,
                                         PRInt32 aNewIndexInContainer)
 {
   NS_ASSERTION(aContainer, "must have container for append");
 #ifdef DEBUG
   {
     for (PRInt32 index = aNewIndexInContainer;; ++index) {
       nsIContent *content = aContainer->GetChildAt(index);
@@ -11430,18 +11448,17 @@ nsCSSFrameConstructor::RestyleForAppend(
       // likely to restyle).
       if (nsStyleUtil::IsSignificantChild(aContainer->GetChildAt(index),
                                           PR_TRUE, PR_FALSE)) {
         wasEmpty = PR_FALSE;
         break;
       }
     }
     if (wasEmpty) {
-      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
-      // Restyling the container is the most we can do here, so we're done.
+      RestyleForEmptyChange(aContainer);
       return;
     }
   }
   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
     // restyle the last element child before this node
     for (PRInt32 index = aNewIndexInContainer - 1; index >= 0; --index) {
       nsIContent *content = aContainer->GetChildAt(index);
       if (content->IsNodeOfType(nsINode::eELEMENT)) {
@@ -11490,18 +11507,17 @@ nsCSSFrameConstructor::RestyleForInsertO
       // IsSignificantChild less likely to be true, and thus make us more
       // likely to restyle).
       if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
         wasEmpty = PR_FALSE;
         break;
       }
     }
     if (wasEmpty) {
-      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
-      // Restyling the container is the most we can do here, so we're done.
+      RestyleForEmptyChange(aContainer);
       return;
     }
   }
 
   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
     // restyle the previously-first element child if it is after this node
     PRBool passedChild = PR_FALSE;
     for (PRInt32 index = 0; ; ++index) {
@@ -11569,18 +11585,17 @@ nsCSSFrameConstructor::RestyleForRemove(
       // IsSignificantChild less likely to be true, and thus make us more
       // likely to restyle).
       if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
         isEmpty = PR_FALSE;
         break;
       }
     }
     if (isEmpty) {
-      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
-      // Restyling the container is the most we can do here, so we're done.
+      RestyleForEmptyChange(aContainer);
       return;
     }
   }
 
   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
     // restyle the previously-first element child if it is after aOldChild
     for (PRInt32 index = 0; ; ++index) {
       nsIContent *content = aContainer->GetChildAt(index);
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -189,16 +189,18 @@ private:
   // If the caller wants that to happen synchronously, it needs to handle that
   // itself.
   void ProcessOneRestyle(nsIContent* aContent, nsReStyleHint aRestyleHint,
                          nsChangeHint aChangeHint);
 
   void ProcessPendingRestyleTable(
            nsDataHashtable<nsISupportsHashKey, RestyleData>& aRestyles);
 
+  void RestyleForEmptyChange(nsIContent* aContainer);
+
 public:
   // Restyling for a ContentInserted (notification after insertion) or
   // for a CharacterDataChanged.  |aContainer| must be non-null; when
   // the container is null, no work is needed.
   void RestyleForInsertOrChange(nsIContent* aContainer,
                                 nsIContent* aChild);
   // This would be the same as RestyleForInsertOrChange if we got the
   // notification before the removal.  However, we get it after, so we
