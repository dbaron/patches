From: L. David Baron <dbaron@dbaron.org>

Additional restyling is needed for :empty + E and :empty ~ E selectors.  (Bug 534804)

diff --git a/content/base/public/nsINode.h b/content/base/public/nsINode.h
--- a/content/base/public/nsINode.h
+++ b/content/base/public/nsINode.h
@@ -129,17 +129,20 @@ enum {
   NODE_HAS_SLOW_SELECTOR =       0x00008000U,
 
   // A child of the node has a :first-child, :-moz-first-node,
   // :only-child, :last-child or :-moz-last-node selector.
   NODE_HAS_EDGE_CHILD_SELECTOR = 0x00010000U,
 
   // A child of the node has a selector such that any insertion or
   // removal of children requires restyling the parent (but append is
-  // OK).
+  // OK).  Additionally (in this manner it is stronger than
+  // NODE_HAS_SLOW_SELECTOR), if a child's style changes in any way
+  // (e.g., the child changes to or from matching :empty due to a
+  // grandchild changes), the node must also be restyled.
   NODE_HAS_SLOW_SELECTOR_NOAPPEND
                                = 0x00020000U,
 
   NODE_ALL_SELECTOR_FLAGS =      NODE_HAS_EMPTY_SELECTOR |
                                  NODE_HAS_SLOW_SELECTOR |
                                  NODE_HAS_EDGE_CHILD_SELECTOR |
                                  NODE_HAS_SLOW_SELECTOR_NOAPPEND,
 
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -11386,16 +11386,31 @@ nsCSSFrameConstructor::ReframeContaining
     }
   }
 
   // If we get here, we're screwed!
   return RecreateFramesForContent(mPresShell->GetDocument()->GetRootContent(), PR_TRUE);
 }
 
 void
+nsCSSFrameConstructor::RestyleForEmptyChange(nsIContent* aContainer)
+{
+  nsIContent* toRestyle = aContainer;
+  // In some cases (:empty + E, :empty ~ E), a change if the content of
+  // an element requires restyling its grandparent, because it changes
+  // its parent's :empty state.
+  nsIContent* grandparent = aContainer->GetParent();
+  if (grandparent &&
+      (grandparent->GetFlags() & NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
+    toRestyle = grandparent;
+  }
+  PostRestyleEvent(toRestyle, eReStyle_Self, NS_STYLE_HINT_NONE);
+}
+
+void
 nsCSSFrameConstructor::RestyleForAppend(nsIContent* aContainer,
                                         PRInt32 aNewIndexInContainer)
 {
   NS_ASSERTION(aContainer, "must have container for append");
 #ifdef DEBUG
   {
     for (PRInt32 index = aNewIndexInContainer;; ++index) {
       nsIContent *content = aContainer->GetChildAt(index);
@@ -11409,42 +11424,42 @@ nsCSSFrameConstructor::RestyleForAppend(
   }
 #endif
   PRUint32 selectorFlags =
     aContainer->GetFlags() & (NODE_ALL_SELECTOR_FLAGS &
                               ~NODE_HAS_SLOW_SELECTOR_NOAPPEND);
   if (selectorFlags == 0)
     return;
 
-  if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
-    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
-    // Restyling the container is the most we can do here, so we're done.
-    return;
-  }
-
   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
     // see whether we need to restyle the container
     PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
     for (PRInt32 index = 0; index < aNewIndexInContainer; ++index) {
       // We don't know whether we're testing :empty or :-moz-only-whitespace,
       // so be conservative and assume :-moz-only-whitespace (i.e., make
       // IsSignificantChild less likely to be true, and thus make us more
       // likely to restyle).
       if (nsStyleUtil::IsSignificantChild(aContainer->GetChildAt(index),
                                           PR_TRUE, PR_FALSE)) {
         wasEmpty = PR_FALSE;
         break;
       }
     }
     if (wasEmpty) {
-      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
-      // Restyling the container is the most we can do here, so we're done.
+      RestyleForEmptyChange(aContainer);
       return;
     }
   }
+
+  if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
+    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+    // Restyling the container is the most we can do here, so we're done.
+    return;
+  }
+
   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
     // restyle the last element child before this node
     for (PRInt32 index = aNewIndexInContainer - 1; index >= 0; --index) {
       nsIContent *content = aContainer->GetChildAt(index);
       if (content->IsNodeOfType(nsINode::eELEMENT)) {
         PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
         break;
       }
@@ -11464,23 +11479,16 @@ nsCSSFrameConstructor::RestyleForInsertO
 {
   NS_ASSERTION(!aChild->IsRootOfAnonymousSubtree(),
                "anonymous nodes should not be in child lists");
   PRUint32 selectorFlags =
     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
   if (selectorFlags == 0)
     return;
 
-  if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
-                       NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
-    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
-    // Restyling the container is the most we can do here, so we're done.
-    return;
-  }
-
   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
     // see whether we need to restyle the container
     PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
     for (PRInt32 index = 0; ; ++index) {
       nsIContent *child = aContainer->GetChildAt(index);
       if (!child) // last child
         break;
       if (child == aChild)
@@ -11490,22 +11498,28 @@ nsCSSFrameConstructor::RestyleForInsertO
       // IsSignificantChild less likely to be true, and thus make us more
       // likely to restyle).
       if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
         wasEmpty = PR_FALSE;
         break;
       }
     }
     if (wasEmpty) {
-      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
-      // Restyling the container is the most we can do here, so we're done.
+      RestyleForEmptyChange(aContainer);
       return;
     }
   }
 
+  if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
+                       NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
+    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+    // Restyling the container is the most we can do here, so we're done.
+    return;
+  }
+
   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
     // restyle the previously-first element child if it is after this node
     PRBool passedChild = PR_FALSE;
     for (PRInt32 index = 0; ; ++index) {
       nsIContent *content = aContainer->GetChildAt(index);
       if (!content)
         break; // went through all children
       if (content == aChild) {
@@ -11545,23 +11559,16 @@ nsCSSFrameConstructor::RestyleForRemove(
 {
   NS_ASSERTION(!aOldChild->IsRootOfAnonymousSubtree(),
                "anonymous nodes should not be in child lists");
   PRUint32 selectorFlags =
     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
   if (selectorFlags == 0)
     return;
 
-  if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
-                       NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
-    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
-    // Restyling the container is the most we can do here, so we're done.
-    return;
-  }
-
   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
     // see whether we need to restyle the container
     PRBool isEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
     for (PRInt32 index = 0; ; ++index) {
       nsIContent *child = aContainer->GetChildAt(index);
       if (!child) // last child
         break;
       // We don't know whether we're testing :empty or :-moz-only-whitespace,
@@ -11569,22 +11576,28 @@ nsCSSFrameConstructor::RestyleForRemove(
       // IsSignificantChild less likely to be true, and thus make us more
       // likely to restyle).
       if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
         isEmpty = PR_FALSE;
         break;
       }
     }
     if (isEmpty) {
-      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
-      // Restyling the container is the most we can do here, so we're done.
+      RestyleForEmptyChange(aContainer);
       return;
     }
   }
 
+  if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
+                       NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
+    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+    // Restyling the container is the most we can do here, so we're done.
+    return;
+  }
+
   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
     // restyle the previously-first element child if it is after aOldChild
     for (PRInt32 index = 0; ; ++index) {
       nsIContent *content = aContainer->GetChildAt(index);
       if (!content)
         break; // went through all children
       if (content->IsNodeOfType(nsINode::eELEMENT)) {
         if (index >= aIndexInContainer) {
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -189,16 +189,18 @@ private:
   // If the caller wants that to happen synchronously, it needs to handle that
   // itself.
   void ProcessOneRestyle(nsIContent* aContent, nsReStyleHint aRestyleHint,
                          nsChangeHint aChangeHint);
 
   void ProcessPendingRestyleTable(
            nsDataHashtable<nsISupportsHashKey, RestyleData>& aRestyles);
 
+  void RestyleForEmptyChange(nsIContent* aContainer);
+
 public:
   // Restyling for a ContentInserted (notification after insertion) or
   // for a CharacterDataChanged.  |aContainer| must be non-null; when
   // the container is null, no work is needed.
   void RestyleForInsertOrChange(nsIContent* aContainer,
                                 nsIContent* aChild);
   // This would be the same as RestyleForInsertOrChange if we got the
   // notification before the removal.  However, we get it after, so we
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1513,16 +1513,21 @@ mozEmptyExceptChildrenWithLocalnameMatch
                     nsCSSPseudoClasses::mozEmptyExceptChildrenWithLocalname,
                   "Unexpected atom");
   NS_ASSERTION(pseudoClass->u.mString, "Must have string!");
   nsIContent *child = nsnull;
   nsIContent *element = data.mContent;
   PRInt32 index = -1;
 
   if (setNodeFlags)
+    // FIXME:  This isn't sufficient to handle:
+    //   :-moz-empty-except-children-with-localname() + E
+    //   :-moz-empty-except-children-with-localname() ~ E
+    // because we don't know to restyle the grandparent of the
+    // inserted/removed element (as in bug 534804 for :empty).
     element->SetFlags(NODE_HAS_SLOW_SELECTOR);
 
   do {
     child = element->GetChildAt(++index);
   } while (child &&
            (!IsSignificantChild(child, PR_TRUE, PR_FALSE) ||
             (child->GetNameSpaceID() == element->GetNameSpaceID() &&
              child->Tag()->Equals(nsDependentString(pseudoClass->u.mString)))));
