From: L. David Baron <dbaron@dbaron.org>

Additional restyling is needed for :empty + E and :empty ~ E selectors.  (Bug 534804)

diff --git a/content/base/public/nsINode.h b/content/base/public/nsINode.h
--- a/content/base/public/nsINode.h
+++ b/content/base/public/nsINode.h
@@ -125,17 +125,20 @@ enum {
   NODE_HAS_SLOW_SELECTOR =       0x00004000U,
 
   // A child of the node has a :first-child, :-moz-first-node,
   // :only-child, :last-child or :-moz-last-node selector.
   NODE_HAS_EDGE_CHILD_SELECTOR = 0x00008000U,
 
   // A child of the node has a selector such that any insertion or
   // removal of children requires restyling the parent (but append is
-  // OK).
+  // OK).  Additionally (in this manner it is stronger than
+  // NODE_HAS_SLOW_SELECTOR), if a child's style changes in any way
+  // (e.g., the child changes to or from matching :empty due to a
+  // grandchild changes), the node must also be restyled.
   NODE_HAS_SLOW_SELECTOR_NOAPPEND
                                = 0x00010000U,
 
   NODE_ALL_SELECTOR_FLAGS =      NODE_HAS_EMPTY_SELECTOR |
                                  NODE_HAS_SLOW_SELECTOR |
                                  NODE_HAS_EDGE_CHILD_SELECTOR |
                                  NODE_HAS_SLOW_SELECTOR_NOAPPEND,
 
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -10753,16 +10753,31 @@ nsCSSFrameConstructor::ReframeContaining
     }
   }
 
   // If we get here, we're screwed!
   return RecreateFramesForContent(mPresShell->GetDocument()->GetRootContent(), PR_TRUE);
 }
 
 void
+nsCSSFrameConstructor::RestyleForEmptyChange(nsIContent* aContainer)
+{
+  nsIContent* toRestyle = aContainer;
+  // In some cases (:empty + E, :empty ~ E), a change if the content of
+  // an element requires restyling its grandparent, because it changes
+  // its parent's :empty state.
+  nsIContent* grandparent = aContainer->GetParent();
+  if (grandparent &&
+      (grandparent->GetFlags() & NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
+    toRestyle = grandparent;
+  }
+  PostRestyleEvent(toRestyle, eReStyle_Self, NS_STYLE_HINT_NONE);
+}
+
+void
 nsCSSFrameConstructor::RestyleForAppend(nsIContent* aContainer,
                                         PRInt32 aNewIndexInContainer)
 {
   NS_ASSERTION(aContainer, "must have container for append");
 #ifdef DEBUG
   {
     for (PRInt32 index = aNewIndexInContainer;; ++index) {
       nsIContent *content = aContainer->GetChildAt(index);
@@ -10776,42 +10791,42 @@ nsCSSFrameConstructor::RestyleForAppend(
   }
 #endif
   PRUint32 selectorFlags =
     aContainer->GetFlags() & (NODE_ALL_SELECTOR_FLAGS &
                               ~NODE_HAS_SLOW_SELECTOR_NOAPPEND);
   if (selectorFlags == 0)
     return;
 
-  if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
-    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
-    // Restyling the container is the most we can do here, so we're done.
-    return;
-  }
-
   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
     // see whether we need to restyle the container
     PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
     for (PRInt32 index = 0; index < aNewIndexInContainer; ++index) {
       // We don't know whether we're testing :empty or :-moz-only-whitespace,
       // so be conservative and assume :-moz-only-whitespace (i.e., make
       // IsSignificantChild less likely to be true, and thus make us more
       // likely to restyle).
       if (nsStyleUtil::IsSignificantChild(aContainer->GetChildAt(index),
                                           PR_TRUE, PR_FALSE)) {
         wasEmpty = PR_FALSE;
         break;
       }
     }
     if (wasEmpty) {
-      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
-      // Restyling the container is the most we can do here, so we're done.
+      RestyleForEmptyChange(aContainer);
       return;
     }
   }
+
+  if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
+    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+    // Restyling the container is the most we can do here, so we're done.
+    return;
+  }
+
   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
     // restyle the last element child before this node
     for (PRInt32 index = aNewIndexInContainer - 1; index >= 0; --index) {
       nsIContent *content = aContainer->GetChildAt(index);
       if (content->IsNodeOfType(nsINode::eELEMENT)) {
         PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
         break;
       }
@@ -10831,23 +10846,16 @@ nsCSSFrameConstructor::RestyleForInsertO
 {
   NS_ASSERTION(!aChild->IsRootOfAnonymousSubtree(),
                "anonymous nodes should not be in child lists");
   PRUint32 selectorFlags =
     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
   if (selectorFlags == 0)
     return;
 
-  if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
-                       NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
-    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
-    // Restyling the container is the most we can do here, so we're done.
-    return;
-  }
-
   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
     // see whether we need to restyle the container
     PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
     for (PRInt32 index = 0; ; ++index) {
       nsIContent *child = aContainer->GetChildAt(index);
       if (!child) // last child
         break;
       if (child == aChild)
@@ -10857,22 +10865,28 @@ nsCSSFrameConstructor::RestyleForInsertO
       // IsSignificantChild less likely to be true, and thus make us more
       // likely to restyle).
       if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
         wasEmpty = PR_FALSE;
         break;
       }
     }
     if (wasEmpty) {
-      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
-      // Restyling the container is the most we can do here, so we're done.
+      RestyleForEmptyChange(aContainer);
       return;
     }
   }
 
+  if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
+                       NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
+    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+    // Restyling the container is the most we can do here, so we're done.
+    return;
+  }
+
   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
     // restyle the previously-first element child if it is after this node
     PRBool passedChild = PR_FALSE;
     for (PRInt32 index = 0; ; ++index) {
       nsIContent *content = aContainer->GetChildAt(index);
       if (!content)
         break; // went through all children
       if (content == aChild) {
@@ -10912,23 +10926,16 @@ nsCSSFrameConstructor::RestyleForRemove(
 {
   NS_ASSERTION(!aOldChild->IsRootOfAnonymousSubtree(),
                "anonymous nodes should not be in child lists");
   PRUint32 selectorFlags =
     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
   if (selectorFlags == 0)
     return;
 
-  if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
-                       NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
-    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
-    // Restyling the container is the most we can do here, so we're done.
-    return;
-  }
-
   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
     // see whether we need to restyle the container
     PRBool isEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
     for (PRInt32 index = 0; ; ++index) {
       nsIContent *child = aContainer->GetChildAt(index);
       if (!child) // last child
         break;
       // We don't know whether we're testing :empty or :-moz-only-whitespace,
@@ -10936,22 +10943,28 @@ nsCSSFrameConstructor::RestyleForRemove(
       // IsSignificantChild less likely to be true, and thus make us more
       // likely to restyle).
       if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
         isEmpty = PR_FALSE;
         break;
       }
     }
     if (isEmpty) {
-      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
-      // Restyling the container is the most we can do here, so we're done.
+      RestyleForEmptyChange(aContainer);
       return;
     }
   }
 
+  if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
+                       NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
+    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+    // Restyling the container is the most we can do here, so we're done.
+    return;
+  }
+
   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
     // restyle the previously-first element child if it is after aOldChild
     for (PRInt32 index = 0; ; ++index) {
       nsIContent *content = aContainer->GetChildAt(index);
       if (!content)
         break; // went through all children
       if (content->IsNodeOfType(nsINode::eELEMENT)) {
         if (index >= aIndexInContainer) {
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -184,16 +184,18 @@ private:
   // If the caller wants that to happen synchronously, it needs to handle that
   // itself.
   void ProcessOneRestyle(nsIContent* aContent, nsReStyleHint aRestyleHint,
                          nsChangeHint aChangeHint);
 
   void ProcessPendingRestyleTable(
            nsDataHashtable<nsISupportsHashKey, RestyleData>& aRestyles);
 
+  void RestyleForEmptyChange(nsIContent* aContainer);
+
 public:
   // Restyling for a ContentInserted (notification after insertion) or
   // for a CharacterDataChanged.  |aContainer| must be non-null; when
   // the container is null, no work is needed.
   void RestyleForInsertOrChange(nsIContent* aContainer,
                                 nsIContent* aChild);
   // This would be the same as RestyleForInsertOrChange if we got the
   // notification before the removal.  However, we get it after, so we
diff --git a/layout/reftests/bugs/534804-1-ref.html b/layout/reftests/bugs/534804-1-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/534804-1-ref.html
@@ -0,0 +1,21 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+  <meta charset='utf-8'>
+  <title>dynamic sibling selector testcase</title>
+  <style>
+  #adjacent, #general {
+    background: #cfc;
+  }
+  </style>
+</head>
+<body>
+  <div>
+    <div id="adjacent">PASS: You should see this</div>
+  </div>
+
+  <div>
+    <div id="general">PASS: You should also see this</div>
+  </div>
+</body>
+</html>
diff --git a/layout/reftests/bugs/534804-1.html b/layout/reftests/bugs/534804-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/534804-1.html
@@ -0,0 +1,45 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+  <meta charset='utf-8'>
+  <title>dynamic sibling selector testcase</title>
+  <script>
+    window.onload = function() {
+      document.getElementById("adjacent").appendChild(document.createTextNode("PASS: You should see this"));
+      document.getElementById("general").appendChild(document.createTextNode("PASS: You should also see this"));
+    };
+  </script>
+  <style>
+  .test {
+    background: #fcc;
+  }
+  #adjacent:not(:empty), #general:not(:empty) {
+    background: #cfc;
+  }
+  #adjacent:not(:empty) + .test {
+    display: none;
+  }
+  #general:not(:empty) ~ .test {
+    display: none;
+  }
+  </style>
+</head>
+<body>
+  <div>
+    <div id="adjacent"></div>
+    <div class="test">
+      FAIL: You should NOT see me.
+    </div>
+  </div>
+
+  <div>
+    <div id="general"></div>
+    <div class="test">
+      FAIL: You should NOT see me either.
+    </div>
+    <div class="test">
+      FAIL: You should NOT even see me.
+    </div>
+  </div>
+</body>
+</html>
diff --git a/layout/reftests/bugs/reftest.list b/layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list
+++ b/layout/reftests/bugs/reftest.list
@@ -1364,9 +1364,10 @@ fails HTTP(..) == 518172-2b.html 518172-
 == 528038-1c.html 528038-1-ref.html
 == 528038-1d.html 528038-1-ref.html
 == 528038-1e.html 528038-1-ref.html
 == 528038-1f.html 528038-1-ref.html
 == 528038-2.html 528038-2-ref.html
 == 530686-1.html 530686-1-ref.html
 == 531098-1.html 531098-1-ref.html
 == 531371-1.html 531371-1-ref.html
+== 534804-1.html 534804-1-ref.html
 == 534919-1.html 534919-1-ref.html
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1513,16 +1513,21 @@ mozEmptyExceptChildrenWithLocalnameMatch
                     nsCSSPseudoClasses::mozEmptyExceptChildrenWithLocalname,
                   "Unexpected atom");
   NS_ASSERTION(pseudoClass->u.mString, "Must have string!");
   nsIContent *child = nsnull;
   nsIContent *element = data.mContent;
   PRInt32 index = -1;
 
   if (setNodeFlags)
+    // FIXME:  This isn't sufficient to handle:
+    //   :-moz-empty-except-children-with-localname() + E
+    //   :-moz-empty-except-children-with-localname() ~ E
+    // because we don't know to restyle the grandparent of the
+    // inserted/removed element (as in bug 534804 for :empty).
     element->SetFlags(NODE_HAS_SLOW_SELECTOR);
 
   do {
     child = element->GetChildAt(++index);
   } while (child &&
            (!IsSignificantChild(child, PR_TRUE, PR_FALSE) ||
             (child->GetNameSpaceID() == element->GetNameSpaceID() &&
              child->Tag()->Equals(nsDependentString(pseudoClass->u.mString)))));
diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -100,16 +100,17 @@ _TEST_FILES =	test_acid3_test46.html \
 		test_bug437915.html \
 		test_bug450191.html \
 		test_bug453896_deck.html \
 		test_bug470769.html \
 		test_bug499655.html \
 		test_bug499655.xhtml \
 		test_bug517224.html \
 		test_bug524175.html \
+		test_bug534804.html \
 		test_cascade.html \
 		test_compute_data_with_start_struct.html \
 		test_computed_style_no_pseudo.html \
 		test_css_cross_domain.html \
 		test_css_eof_handling.html \
 		test_descriptor_storage.html \
 		test_descriptor_syntax_errors.html \
 		test_dont_use_document_colors.html \
diff --git a/layout/style/test/test_bug534804.html b/layout/style/test/test_bug534804.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_bug534804.html
@@ -0,0 +1,90 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=534804
+-->
+<head>
+  <title>Test for Bug 534804</title>
+  <script type="application/javascript" src="/MochiKit/packed.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+  <style type="text/css" id="styleone">  </style>
+  <style type="text/css" id="styletwo">  </style>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=534804">Mozilla Bug 534804</a>
+<p id="display"></p>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 534804 **/
+
+var styleone = document.getElementById("styleone");
+var styletwo = document.getElementById("styletwo");
+var display = document.getElementById("display");
+
+run1();
+styletwo.firstChild.data = "#e > span:nth-child(2n+1) { color: green }";
+run1();
+styletwo.firstChild.data = "#e > span:first-child { color: green }";
+run1();
+styletwo.firstChild.data = "#e > span:nth-last-child(2n+1) { color: green }";
+run1();
+styletwo.firstChild.data = "#e > span:last-child { color: green }";
+run1();
+
+function run1()
+{
+  function identity(bool)      { return bool; }
+  function inverse(bool)       { return !bool; }
+  function always_false(bool)  { return false; }
+  run2("#e:empty + span", identity, always_false);
+  run2("#e:empty ~ span", identity, identity);
+  run2("#e:not(:empty) + span", inverse, always_false);
+  run2("#e:not(:empty) ~ span", inverse, inverse);
+}
+
+function run2(sel, next_sibling_rule, later_sibling_rule)
+{
+  styleone.firstChild.data = sel + " { text-decoration: underline }";
+
+  // Rebuild the subtree every time.
+  var span1 = document.createElement("span");
+  span1.id = "e";
+  var span2 = document.createElement("span");
+  var span3 = document.createElement("span");
+  display.appendChild(span1);
+  display.appendChild(span2);
+  display.appendChild(span3);
+
+  function td(e) { return getComputedStyle(e, "").textDecoration; }
+
+  function check(desc, isempty) {
+    is(td(span2), next_sibling_rule(isempty) ? "underline" : "none",
+       "match of next sibling in state " + desc);
+    is(td(span3), later_sibling_rule(isempty) ? "underline" : "none",
+       "match of next sibling in state " + desc);
+  }
+
+  check("initially empty", true);
+  var kid = document.createElement("span");
+  span1.appendChild(kid);
+  check("after append", false);
+  span1.removeChild(kid);
+  check("after remove", true);
+  span1.appendChild(document.createTextNode(""));
+  span1.appendChild(document.createComment("a comment"));
+  span1.appendChild(document.createTextNode(""));
+  check("after append of insignificant children", true);
+  span1.insertBefore(kid, span1.childNodes[1]);
+  check("after insert", false);
+
+  display.removeChild(span1);
+  display.removeChild(span2);
+  display.removeChild(span3);
+}
+
+</script>
+</pre>
+</body>
+</html>
