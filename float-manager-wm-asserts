From: L. David Baron <dbaron@dbaron.org>

Bug 1114329 patch 2 - Assert that a float manager doesn't switch between horizontal and vertical.

diff --git a/layout/generic/nsFloatManager.cpp b/layout/generic/nsFloatManager.cpp
--- a/layout/generic/nsFloatManager.cpp
+++ b/layout/generic/nsFloatManager.cpp
@@ -408,16 +408,18 @@ nsFloatManager::PushState(SavedState* aS
   aState->mSplitRightFloatAcrossBreak = mSplitRightFloatAcrossBreak;
   aState->mFloatInfoCount = mFloats.Length();
 }
 
 void
 nsFloatManager::PopState(SavedState* aState)
 {
   NS_PRECONDITION(aState, "No state to restore?");
+  MOZ_ASSERT(mWritingMode.IsVertical() == aState->mWritingMode.IsVertical(),
+             "a float manager is either vertical or horizontal");
 
   mWritingMode = aState->mWritingMode;
   mOffset = aState->mOffset;
   mPushedLeftFloatPastBreak = aState->mPushedLeftFloatPastBreak;
   mPushedRightFloatPastBreak = aState->mPushedRightFloatPastBreak;
   mSplitLeftFloatAcrossBreak = aState->mSplitLeftFloatAcrossBreak;
   mSplitRightFloatAcrossBreak = aState->mSplitRightFloatAcrossBreak;
 
@@ -470,16 +472,18 @@ nsFloatManager::List(FILE* out) const
 }
 #endif
 
 nscoord
 nsFloatManager::ClearFloats(WritingMode aWM, nscoord aBCoord,
                             uint8_t aBreakType, nscoord aContainerWidth,
                             uint32_t aFlags) const
 {
+  MOZ_ASSERT(mWritingMode.IsVertical() == aWM.IsVertical(),
+             "a float manager is either vertical or horizontal");
   if (!(aFlags & DONT_CLEAR_PUSHED_FLOATS) && ClearContinues(aBreakType)) {
     return nscoord_MAX;
   }
   if (!HasAnyFloats()) {
     return aBCoord;
   }
 
   LogicalPoint offset = mOffset.ConvertTo(aWM, mWritingMode, 0);
diff --git a/layout/generic/nsFloatManager.h b/layout/generic/nsFloatManager.h
--- a/layout/generic/nsFloatManager.h
+++ b/layout/generic/nsFloatManager.h
@@ -106,37 +106,43 @@ public:
    * Translate the current offset by the specified (dICoord, dBCoord). This
    * creates a new local coordinate space relative to the current
    * coordinate space.
    * @returns previous writing mode
    */
   mozilla::WritingMode Translate(mozilla::WritingMode aWM,
                                  mozilla::LogicalPoint aDOffset)
   {
+    MOZ_ASSERT(aWM.IsVertical() == mWritingMode.IsVertical(),
+               "a float manager is either vertical or horizontal");
     mozilla::WritingMode oldWM = mWritingMode;
     mOffset = mOffset.ConvertTo(aWM, oldWM, 0);
     mWritingMode = aWM;
     mOffset += aDOffset;
     return oldWM;
   }
 
   /*
    * Set the translation offset to a specified value instead of
    * translating by a delta.
    */
   void SetTranslation(mozilla::WritingMode aWM,
                       mozilla::LogicalPoint aOffset)
   {
+    MOZ_ASSERT(aWM.IsVertical() == mWritingMode.IsVertical(),
+               "a float manager is either vertical or horizontal");
     mWritingMode = aWM;
     mOffset = aOffset;
   }
 
   void Untranslate(mozilla::WritingMode aWM,
                    mozilla::LogicalPoint aDOffset)
   {
+    MOZ_ASSERT(aWM.IsVertical() == mWritingMode.IsVertical(),
+               "a float manager is either vertical or horizontal");
     mOffset -= aDOffset;
     mOffset = mOffset.ConvertTo(aWM, mWritingMode, 0);
     mWritingMode = aWM;
   }
 
   /**
    * Returns the current translation from local coordinate space to
    * world coordinate space. This represents the accumulated calls to
