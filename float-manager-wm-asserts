From: L. David Baron <dbaron@dbaron.org>

Bug 1114329 patch 2 - Assert that a float manager doesn't switch between horizontal and vertical.

diff --git a/layout/generic/nsFloatManager.cpp b/layout/generic/nsFloatManager.cpp
--- a/layout/generic/nsFloatManager.cpp
+++ b/layout/generic/nsFloatManager.cpp
@@ -112,16 +112,18 @@ void nsFloatManager::Shutdown()
 }
 
 nsFlowAreaRect
 nsFloatManager::GetFlowArea(WritingMode aWM, nscoord aBOffset,
                             BandInfoType aInfoType, nscoord aBSize,
                             LogicalRect aContentArea, SavedState* aState,
                             nscoord aContainerWidth) const
 {
+  MOZ_ASSERT(mWritingMode.IsVertical() == aWM.IsVertical(),
+             "a float manager is either vertical or horizontal");
   NS_ASSERTION(aBSize >= 0, "unexpected max block size");
   NS_ASSERTION(aContentArea.ISize(aWM) >= 0,
                "unexpected content area inline size");
 
   LogicalPoint offset = mOffset.ConvertTo(aWM, mWritingMode, 0);
   nscoord blockStart = aBOffset + offset.B(aWM);
   if (blockStart < nscoord_MIN) {
     NS_WARNING("bad value");
@@ -241,16 +243,18 @@ nsFloatManager::GetFlowArea(WritingMode 
                         inlineStart - offset.I(aWM), blockStart - offset.B(aWM),
                         inlineEnd - inlineStart, blockSize, haveFloats);
 }
 
 nsresult
 nsFloatManager::AddFloat(nsIFrame* aFloatFrame, const LogicalRect& aMarginRect,
                          WritingMode aWM, nscoord aContainerWidth)
 {
+  MOZ_ASSERT(mWritingMode.IsVertical() == aWM.IsVertical(),
+             "a float manager is either vertical or horizontal");
   NS_ASSERTION(aMarginRect.ISize(aWM) >= 0, "negative inline size!");
   NS_ASSERTION(aMarginRect.BSize(aWM) >= 0, "negative block size!");
 
   FloatInfo info(aFloatFrame, aWM, aMarginRect + mOffset);
 
   // Set mLeftBEnd and mRightBEnd.
   if (HasAnyFloats()) {
     FloatInfo &tail = mFloats[mFloats.Length() - 1];
@@ -408,16 +412,18 @@ nsFloatManager::PushState(SavedState* aS
   aState->mSplitRightFloatAcrossBreak = mSplitRightFloatAcrossBreak;
   aState->mFloatInfoCount = mFloats.Length();
 }
 
 void
 nsFloatManager::PopState(SavedState* aState)
 {
   NS_PRECONDITION(aState, "No state to restore?");
+  MOZ_ASSERT(mWritingMode.IsVertical() == aState->mWritingMode.IsVertical(),
+             "a float manager is either vertical or horizontal");
 
   mWritingMode = aState->mWritingMode;
   mOffset = aState->mOffset;
   mPushedLeftFloatPastBreak = aState->mPushedLeftFloatPastBreak;
   mPushedRightFloatPastBreak = aState->mPushedRightFloatPastBreak;
   mSplitLeftFloatAcrossBreak = aState->mSplitLeftFloatAcrossBreak;
   mSplitRightFloatAcrossBreak = aState->mSplitRightFloatAcrossBreak;
 
@@ -425,16 +431,18 @@ nsFloatManager::PopState(SavedState* aSt
                "somebody misused PushState/PopState");
   mFloats.TruncateLength(aState->mFloatInfoCount);
 }
 
 nscoord
 nsFloatManager::GetLowestFloatTop(WritingMode aWM,
                                   nscoord aContainerWidth) const
 {
+  MOZ_ASSERT(mWritingMode.IsVertical() == aWM.IsVertical(),
+             "a float manager is either vertical or horizontal");
   if (mPushedLeftFloatPastBreak || mPushedRightFloatPastBreak) {
     return nscoord_MAX;
   }
   if (!HasAnyFloats()) {
     return nscoord_MIN;
   }
   FloatInfo fi = mFloats[mFloats.Length() - 1];
   LogicalRect rect = fi.mRect.ConvertTo(aWM, fi.mWritingMode, aContainerWidth);
@@ -470,16 +478,18 @@ nsFloatManager::List(FILE* out) const
 }
 #endif
 
 nscoord
 nsFloatManager::ClearFloats(WritingMode aWM, nscoord aBCoord,
                             uint8_t aBreakType, nscoord aContainerWidth,
                             uint32_t aFlags) const
 {
+  MOZ_ASSERT(mWritingMode.IsVertical() == aWM.IsVertical(),
+             "a float manager is either vertical or horizontal");
   if (!(aFlags & DONT_CLEAR_PUSHED_FLOATS) && ClearContinues(aBreakType)) {
     return nscoord_MAX;
   }
   if (!HasAnyFloats()) {
     return aBCoord;
   }
 
   LogicalPoint offset = mOffset.ConvertTo(aWM, mWritingMode, 0);
diff --git a/layout/generic/nsFloatManager.h b/layout/generic/nsFloatManager.h
--- a/layout/generic/nsFloatManager.h
+++ b/layout/generic/nsFloatManager.h
@@ -106,37 +106,43 @@ public:
    * Translate the current offset by the specified (dICoord, dBCoord). This
    * creates a new local coordinate space relative to the current
    * coordinate space.
    * @returns previous writing mode
    */
   mozilla::WritingMode Translate(mozilla::WritingMode aWM,
                                  mozilla::LogicalPoint aDOffset)
   {
+    MOZ_ASSERT(aWM.IsVertical() == mWritingMode.IsVertical(),
+               "a float manager is either vertical or horizontal");
     mozilla::WritingMode oldWM = mWritingMode;
     mOffset = mOffset.ConvertTo(aWM, oldWM, 0);
     mWritingMode = aWM;
     mOffset += aDOffset;
     return oldWM;
   }
 
   /*
    * Set the translation offset to a specified value instead of
    * translating by a delta.
    */
   void SetTranslation(mozilla::WritingMode aWM,
                       mozilla::LogicalPoint aOffset)
   {
+    MOZ_ASSERT(aWM.IsVertical() == mWritingMode.IsVertical(),
+               "a float manager is either vertical or horizontal");
     mWritingMode = aWM;
     mOffset = aOffset;
   }
 
   void Untranslate(mozilla::WritingMode aWM,
                    mozilla::LogicalPoint aDOffset)
   {
+    MOZ_ASSERT(aWM.IsVertical() == mWritingMode.IsVertical(),
+               "a float manager is either vertical or horizontal");
     mOffset -= aDOffset;
     mOffset = mOffset.ConvertTo(aWM, mWritingMode, 0);
     mWritingMode = aWM;
   }
 
   /**
    * Returns the current translation from local coordinate space to
    * world coordinate space. This represents the accumulated calls to
