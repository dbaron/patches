From: L. David Baron <dbaron@dbaron.org>

Bug 1114329 patch 2 - Assert that a float manager doesn't switch between horizontal and vertical.

diff --git a/layout/generic/nsFloatManager.cpp b/layout/generic/nsFloatManager.cpp
--- a/layout/generic/nsFloatManager.cpp
+++ b/layout/generic/nsFloatManager.cpp
@@ -112,16 +112,18 @@ void nsFloatManager::Shutdown()
 }
 
 nsFlowAreaRect
 nsFloatManager::GetFlowArea(WritingMode aWM, nscoord aBOffset,
                             BandInfoType aInfoType, nscoord aBSize,
                             LogicalRect aContentArea, SavedState* aState,
                             nscoord aContainerWidth) const
 {
+  MOZ_ASSERT(mWritingMode.IsVertical() == aWM.IsVertical(),
+             "a float manager is either vertical or horizontal");
   NS_ASSERTION(aBSize >= 0, "unexpected max block size");
   NS_ASSERTION(aContentArea.ISize(aWM) >= 0,
                "unexpected content area inline size");
 
   nscoord blockStart = aBOffset + mBlockStart;
   if (blockStart < nscoord_MIN) {
     NS_WARNING("bad value");
     blockStart = nscoord_MIN;
@@ -241,16 +243,18 @@ nsFloatManager::GetFlowArea(WritingMode 
   return nsFlowAreaRect(aWM, inlineStart, blockStart - mBlockStart,
                         lineRight - lineLeft, blockSize, haveFloats);
 }
 
 nsresult
 nsFloatManager::AddFloat(nsIFrame* aFloatFrame, const LogicalRect& aMarginRect,
                          WritingMode aWM, nscoord aContainerWidth)
 {
+  MOZ_ASSERT(mWritingMode.IsVertical() == aWM.IsVertical(),
+             "a float manager is either vertical or horizontal");
   NS_ASSERTION(aMarginRect.ISize(aWM) >= 0, "negative inline size!");
   NS_ASSERTION(aMarginRect.BSize(aWM) >= 0, "negative block size!");
 
   FloatInfo info(aFloatFrame,
                  aMarginRect.LineLeft(aWM, aContainerWidth) + mLineLeft,
                  aMarginRect.BStart(aWM) + mBlockStart,
                  aMarginRect.ISize(aWM),
                  aMarginRect.BSize(aWM));
@@ -414,16 +418,18 @@ nsFloatManager::PushState(SavedState* aS
   aState->mSplitRightFloatAcrossBreak = mSplitRightFloatAcrossBreak;
   aState->mFloatInfoCount = mFloats.Length();
 }
 
 void
 nsFloatManager::PopState(SavedState* aState)
 {
   NS_PRECONDITION(aState, "No state to restore?");
+  MOZ_ASSERT(mWritingMode.IsVertical() == aState->mWritingMode.IsVertical(),
+             "a float manager is either vertical or horizontal");
 
   mWritingMode = aState->mWritingMode;
   mLineLeft = aState->mLineLeft;
   mBlockStart = aState->mBlockStart;
   mPushedLeftFloatPastBreak = aState->mPushedLeftFloatPastBreak;
   mPushedRightFloatPastBreak = aState->mPushedRightFloatPastBreak;
   mSplitLeftFloatAcrossBreak = aState->mSplitLeftFloatAcrossBreak;
   mSplitRightFloatAcrossBreak = aState->mSplitRightFloatAcrossBreak;
