From: L. David Baron <dbaron@dbaron.org>

Implement cycle collector's purple buffer using a linked list rather than a hash table.  (Bug 490695)

diff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h
--- a/js/src/xpconnect/src/xpcprivate.h
+++ b/js/src/xpconnect/src/xpcprivate.h
@@ -2143,19 +2143,20 @@ public:
     class NS_CYCLE_COLLECTION_INNERCLASS
      : public nsXPCOMCycleCollectionParticipant
     {
       NS_DECL_CYCLE_COLLECTION_CLASS_BODY_NO_UNLINK(XPCWrappedNative,
                                                     XPCWrappedNative)
       NS_IMETHOD RootAndUnlinkJSObjects(void *p);
       NS_IMETHOD Unlink(void *p) { return NS_OK; }
       NS_IMETHOD Unroot(void *p) { return NS_OK; }
+      NS_IMETHOD_(nsCycleCollectingAutoRefCnt*) AutoRefCnt(nsISupports *p)
+        { return nsnull; }
     };
     NS_CYCLE_COLLECTION_PARTICIPANT_INSTANCE
-    NS_DECL_CYCLE_COLLECTION_UNMARK_PURPLE_STUB(XPCWrappedNative)
 
 #ifndef XPCONNECT_STANDALONE
     virtual nsIPrincipal* GetObjectPrincipal() const;
 #endif
 
     JSBool
     IsValid() const {return nsnull != mFlatJSObject;}
 
@@ -2611,19 +2612,20 @@ public:
     NS_DECL_NSISUPPORTSWEAKREFERENCE
     NS_DECL_NSIPROPERTYBAG
 
     class NS_CYCLE_COLLECTION_INNERCLASS
      : public nsXPCOMCycleCollectionParticipant
     {
       NS_IMETHOD RootAndUnlinkJSObjects(void *p);
       NS_DECL_CYCLE_COLLECTION_CLASS_BODY(nsXPCWrappedJS, nsIXPConnectWrappedJS)
+      NS_IMETHOD_(nsCycleCollectingAutoRefCnt*) AutoRefCnt(nsISupports *p)
+        { return nsnull; }
     };
     NS_CYCLE_COLLECTION_PARTICIPANT_INSTANCE
-    NS_DECL_CYCLE_COLLECTION_UNMARK_PURPLE_STUB(nsXPCWrappedJS)
 
     NS_IMETHOD CallMethod(PRUint16 methodIndex,
                           const XPTMethodDescriptor *info,
                           nsXPTCMiniVariant* params);
 
     /*
     * This is rarely called directly. Instead one usually calls
     * XPCConvert::JSObject2NativeInterface which will handles cases where the
diff --git a/xpcom/base/nsAgg.h b/xpcom/base/nsAgg.h
--- a/xpcom/base/nsAgg.h
+++ b/xpcom/base/nsAgg.h
@@ -102,19 +102,19 @@ public:                                 
 #define NS_DECL_AGGREGATED_CYCLE_COLLECTION_CLASS(_class)                   \
 class NS_CYCLE_COLLECTION_INNERCLASS                                        \
  : public nsXPCOMCycleCollectionParticipant                                 \
 {                                                                           \
 public:                                                                     \
   NS_IMETHOD Unlink(void *p);                                               \
   NS_IMETHOD Traverse(void *p,                                              \
                       nsCycleCollectionTraversalCallback &cb);              \
-  NS_IMETHOD_(void) UnmarkPurple(nsISupports *p)                            \
+  NS_IMETHOD_(nsCycleCollectingAutoRefCnt*) AutoRefCnt(nsISupports *p)      \
   {                                                                         \
-    Downcast(p)->UnmarkPurple();                                            \
+    return Downcast(p)->AutoRefCnt();                                       \
   }                                                                         \
   static _class* Downcast(nsISupports* s)                                   \
   {                                                                         \
     return (_class*)((char*)(s) - offsetof(_class, fAggregated));           \
   }                                                                         \
   static nsISupports* Upcast(_class *p)                                     \
   {                                                                         \
     return p->InnerObject();                                                \
diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -234,17 +234,16 @@ struct nsCycleCollectorStats
     PRUint32 mSetColorWhite;
 
     PRUint32 mFailedUnlink;
     PRUint32 mCollectedNode;
     PRUint32 mBumpGeneration;
     PRUint32 mZeroGeneration;
 
     PRUint32 mSuspectNode;
-    PRUint32 mSpills;    
     PRUint32 mForgetNode;
     PRUint32 mFreedWhilePurple;
   
     PRUint32 mCollection;
 
     nsCycleCollectorStats()
     {
         memset(this, 0, sizeof(nsCycleCollectorStats));
@@ -268,17 +267,16 @@ struct nsCycleCollectorStats
         DUMP(mSetColorWhite);
     
         DUMP(mFailedUnlink);
         DUMP(mCollectedNode);
         DUMP(mBumpGeneration);
         DUMP(mZeroGeneration);
     
         DUMP(mSuspectNode);
-        DUMP(mSpills);
         DUMP(mForgetNode);
         DUMP(mFreedWhilePurple);
     
         DUMP(mCollection);
 #undef DUMP
     }
 };
 #endif
@@ -656,84 +654,54 @@ struct GCGraph
     }
     ~GCGraph() { 
     }
 };
 
 // XXX Would be nice to have an nsHashSet<KeyType> API that has
 // Add/Remove/Has rather than PutEntry/RemoveEntry/GetEntry.
 typedef nsTHashtable<nsVoidPtrHashKey> PointerSet;
-typedef nsBaseHashtable<nsVoidPtrHashKey, PRUint32, PRUint32>
-    PointerSetWithGeneration;
 
 #ifdef DEBUG_CC
 static void
 WriteGraph(FILE *stream, GCGraph &graph, const void *redPtr);
 #endif
 
 struct nsPurpleBuffer
 {
-
-#define ASSOCIATIVITY 2
-#define INDEX_LOW_BIT 6
-#define N_INDEX_BITS 13
-
-#define N_ENTRIES (1 << N_INDEX_BITS)
-#define N_POINTERS (N_ENTRIES * ASSOCIATIVITY)
-#define TOTAL_BYTES (N_POINTERS * PR_BYTES_PER_WORD)
-#define INDEX_MASK PR_BITMASK(N_INDEX_BITS)
-#define POINTER_INDEX(P) ((((PRUword)P) >> INDEX_LOW_BIT) & (INDEX_MASK))
-
-#if (INDEX_LOW_BIT + N_INDEX_BITS > (8 * PR_BYTES_PER_WORD))
-#error "index bit overflow"
-#endif
-
     // This class serves as a generational wrapper around a pldhash
     // table: a subset of generation zero lives in mCache, the
     // remainder spill into the mBackingStore hashtable. The idea is
     // to get a higher hit rate and greater locality of reference for
     // generation zero, in which the vast majority of suspect/forget
     // calls annihilate one another.
 
     nsCycleCollectorParams &mParams;
 #ifdef DEBUG_CC
     nsCycleCollectorStats &mStats;
 #endif
-    void* mCache[N_POINTERS];
-    PRUint32 mCurrGen;    
-    PointerSetWithGeneration mBackingStore;
     
 #ifdef DEBUG_CC
     nsPurpleBuffer(nsCycleCollectorParams &params,
                    nsCycleCollectorStats &stats) 
         : mParams(params),
-          mStats(stats),
-          mCurrGen(0)
+          mStats(stats)
     {
         Init();
     }
 #else
     nsPurpleBuffer(nsCycleCollectorParams &params) 
-        : mParams(params),
-          mCurrGen(0)
+        : mParams(params)
     {
         Init();
     }
 #endif
 
-    ~nsPurpleBuffer()
-    {
-        memset(mCache, 0, sizeof(mCache));
-        mBackingStore.Clear();
-    }
-
     void Init()
     {
-        memset(mCache, 0, sizeof(mCache));
-        mBackingStore.Init();
     }
 
     void BumpGeneration();
     void SelectAgedPointers(GCGraphBuilder &builder);
 
 #ifdef DEBUG_CC
     void NoteAll(GCGraphBuilder &builder);
 #endif
@@ -753,19 +721,16 @@ struct nsPurpleBuffer
     {
         PRUint32 idx = POINTER_INDEX(p);
         for (PRUint32 i = 0; i < ASSOCIATIVITY; ++i) {
             if (!mCache[idx+i]) {
                 mCache[idx+i] = p;
                 return;
             }
         }
-#ifdef DEBUG_CC
-        mStats.mSpills++;
-#endif
         SpillOne(p);
     }
 
     void Remove(void *p)     
     {
         PRUint32 idx = POINTER_INDEX(p);
         for (PRUint32 i = 0; i < ASSOCIATIVITY; ++i) {
             if (mCache[idx+i] == p) {
@@ -927,18 +892,18 @@ struct nsCycleCollector
     void MarkRoots(GCGraphBuilder &builder);
     void ScanRoots();
     void RootWhite();
     PRBool CollectWhite(); // returns whether anything was collected
 
     nsCycleCollector();
     ~nsCycleCollector();
 
-    PRBool Suspect(nsISupports *n);
-    PRBool Forget(nsISupports *n);
+    nsPurpleBufferEntry* Suspect(nsISupports *n);
+    PRBool Forget(nsPurpleBufferEntry *e);
     PRUint32 Collect(PRUint32 aTryCollections = 1);
     PRBool BeginCollection();
     PRBool FinishCollection();
     PRUint32 SuspectedCount();
     void Shutdown();
 
     void ClearGraph()
     {
@@ -1495,17 +1460,17 @@ AddPurpleRoot(GCGraphBuilder &builder, n
     ToParticipant(root, &cp);
 
     PtrInfo *pinfo = builder.AddNode(root, cp,
                                      nsIProgrammingLanguage::CPLUSPLUS);
     if (!pinfo) {
         return PR_FALSE;
     }
 
-    cp->UnmarkPurple(root);
+    cp->AutoRefCnt(root)->unmarkPurple();
 
     return PR_TRUE;
 }
 
 #ifdef DEBUG_CC
 static PLDHashOperator
 noteAllCallback(const void* ptr, PRUint32& generation, void* userArg)
 {
@@ -2129,87 +2094,86 @@ nsCycleCollector_isScanSafe(nsISupports 
 
     nsXPCOMCycleCollectionParticipant *cp;
     ToParticipant(s, &cp);
 
     return cp != nsnull;
 }
 #endif
 
-PRBool
+nsPurpleBufferEntry*
 nsCycleCollector::Suspect(nsISupports *n)
 {
     // Re-entering ::Suspect during collection used to be a fault, but
     // we are canonicalizing nsISupports pointers using QI, so we will
     // see some spurious refcount traffic here. 
 
     if (mScanInProgress)
-        return PR_FALSE;
+        return nsnull;
 
     NS_ASSERTION(nsCycleCollector_isScanSafe(n),
                  "suspected a non-scansafe pointer");
     NS_ASSERTION(NS_IsMainThread(), "trying to suspect from non-main thread");
 
     if (mParams.mDoNothing)
-        return PR_FALSE;
+        return nsnull;
 
 #ifdef DEBUG_CC
     mStats.mSuspectNode++;
 
     if (nsCycleCollector_shouldSuppress(n))
-        return PR_FALSE;
+        return nsnull;
 
 #ifndef __MINGW32__
     if (mParams.mHookMalloc)
         InitMemHook();
 #endif
 
     if (mParams.mLogPointers) {
         if (!mPtrLog)
             mPtrLog = fopen("pointer_log", "w");
         fprintf(mPtrLog, "S %p\n", static_cast<void*>(n));
     }
 #endif
 
     mPurpleBuf.Put(n);
 
+    // XXX WRITE ME!
     return PR_TRUE;
 }
 
 
 PRBool
-nsCycleCollector::Forget(nsISupports *n)
+nsCycleCollector::Forget(nsPurpleBufferEntry *e)
 {
     // Re-entering ::Forget during collection used to be a fault, but
     // we are canonicalizing nsISupports pointers using QI, so we will
     // see some spurious refcount traffic here. 
 
     if (mScanInProgress)
         return PR_FALSE;
 
     NS_ASSERTION(NS_IsMainThread(), "trying to forget from non-main thread");
     
-    if (mParams.mDoNothing)
-        return PR_TRUE; // it's as good as forgotten
-
 #ifdef DEBUG_CC
     mStats.mForgetNode++;
 
 #ifndef __MINGW32__
     if (mParams.mHookMalloc)
         InitMemHook();
 #endif
 
     if (mParams.mLogPointers) {
         if (!mPtrLog)
             mPtrLog = fopen("pointer_log", "w");
         fprintf(mPtrLog, "F %p\n", static_cast<void*>(n));
     }
 #endif
 
+    // XXX WRITE ME!
     mPurpleBuf.Remove(n);
     return PR_TRUE;
 }
 
 #ifdef DEBUG_CC
 void 
 nsCycleCollector::Allocated(void *n, size_t sz)
 {
@@ -2921,29 +2885,28 @@ nsCycleCollector_registerRuntime(PRUint3
 void 
 nsCycleCollector_forgetRuntime(PRUint32 langID)
 {
     if (sCollector)
         sCollector->ForgetRuntime(langID);
 }
 
 
-PRBool
+nsPurpleBufferEntry*
 NS_CycleCollectorSuspect(nsISupports *n)
 {
     if (sCollector)
         return sCollector->Suspect(n);
-    return PR_FALSE;
+    return nsnull;
 }
 
-
 PRBool
-NS_CycleCollectorForget(nsISupports *n)
+NS_CycleCollectorForget(nsPurpleBufferEntry *e)
 {
-    return sCollector ? sCollector->Forget(n) : PR_TRUE;
+    return sCollector ? sCollector->Forget(e) : PR_TRUE;
 }
 
 
 PRUint32
 nsCycleCollector_collect()
 {
     fprintf(stderr, "Starting nsCycleCollector_collect\n");
     PRIntervalTime start = PR_IntervalNow();
diff --git a/xpcom/build/nsXPCOM.h b/xpcom/build/nsXPCOM.h
--- a/xpcom/build/nsXPCOM.h
+++ b/xpcom/build/nsXPCOM.h
@@ -455,21 +455,23 @@ NS_LogCOMPtrAddRef(void *aCOMPtr, nsISup
 XPCOM_API(void)
 NS_LogCOMPtrRelease(void *aCOMPtr, nsISupports *aObject);
 
 /**
  * The XPCOM cycle collector analyzes and breaks reference cycles between
  * participating XPCOM objects. All objects in the cycle must implement
  * nsCycleCollectionParticipant to break cycles correctly.
  */
-XPCOM_API(PRBool)
+struct nsPurpleBufferEntry;
+
+XPCOM_API(nsPurpleBufferEntry*)
 NS_CycleCollectorSuspect(nsISupports *n);
 
 XPCOM_API(PRBool)
-NS_CycleCollectorForget(nsISupports *n);
+NS_CycleCollectorForget(nsPurpleBufferEntry *e);
 
 /**
  * Categories (in the category manager service) used by XPCOM:
  */
 
 /**
  * A category which is read after component registration but before
  * the "xpcom-startup" notifications. Each category entry is treated
diff --git a/xpcom/glue/nsCycleCollectionParticipant.cpp b/xpcom/glue/nsCycleCollectionParticipant.cpp
--- a/xpcom/glue/nsCycleCollectionParticipant.cpp
+++ b/xpcom/glue/nsCycleCollectionParticipant.cpp
@@ -77,21 +77,16 @@ nsXPCOMCycleCollectionParticipant::Unroo
 
 nsresult
 nsXPCOMCycleCollectionParticipant::Traverse
     (void *p, nsCycleCollectionTraversalCallback &cb)
 {
   return NS_OK;
 }
 
-void
-nsXPCOMCycleCollectionParticipant::UnmarkPurple(nsISupports *n)
-{
-}
-
 NS_IMETHODIMP_(void)
 nsXPCOMCycleCollectionParticipant::Trace(void *p, TraceCallback cb,
                                          void *closure)
 {
 }
 
 PRBool
 nsXPCOMCycleCollectionParticipant::CheckForRightISupports(nsISupports *s)
diff --git a/xpcom/glue/nsCycleCollectionParticipant.h b/xpcom/glue/nsCycleCollectionParticipant.h
--- a/xpcom/glue/nsCycleCollectionParticipant.h
+++ b/xpcom/glue/nsCycleCollectionParticipant.h
@@ -156,17 +156,18 @@ public:
     NS_IMETHOD Traverse(void *p, nsCycleCollectionTraversalCallback &cb);
 
     NS_IMETHOD RootAndUnlinkJSObjects(void *p);
     NS_IMETHOD Unlink(void *p);
     NS_IMETHOD Unroot(void *p);
 
     NS_IMETHOD_(void) Trace(void *p, TraceCallback cb, void *closure);
 
-    NS_IMETHOD_(void) UnmarkPurple(nsISupports *p);
+    // Must return non-null for any object that could be in the purple buffer.
+    NS_IMETHOD_(nsCycleCollectingAutoRefCnt*) AutoRefCnt(nsISupports *p) = 0;
 
     PRBool CheckForRightISupports(nsISupports *s);
 };
 
 #undef IMETHOD_VISIBILITY
 #define IMETHOD_VISIBILITY NS_VISIBILITY_HIDDEN
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -484,19 +485,19 @@ public:
 
 #define NS_CYCLE_COLLECTION_PARTICIPANT_INSTANCE                               \
   static NS_CYCLE_COLLECTION_INNERCLASS NS_CYCLE_COLLECTION_INNERNAME;
 
 #define NS_DECL_CYCLE_COLLECTION_CLASS_BODY_NO_UNLINK(_class, _base)           \
 public:                                                                        \
   NS_IMETHOD Traverse(void *p,                                                 \
                       nsCycleCollectionTraversalCallback &cb);                 \
-  NS_IMETHOD_(void) UnmarkPurple(nsISupports *s)                               \
+  NS_IMETHOD_(nsCycleCollectingAutoRefCnt*) AutoRefCnt(nsISupports *s);        \
   {                                                                            \
-    Downcast(s)->UnmarkPurple();                                               \
+    return Downcast(s)->AutoRefCnt();                                          \
   }                                                                            \
   static _class* Downcast(nsISupports* s)                                      \
   {                                                                            \
     return static_cast<_class*>(static_cast<_base*>(s));                       \
   }                                                                            \
   static nsISupports* Upcast(_class *p)                                        \
   {                                                                            \
     return NS_ISUPPORTS_CAST(_base*, p);                                       \
@@ -580,27 +581,16 @@ public:                                 
   static _class* Downcast(nsISupports* s)                                      \
   {                                                                            \
     return static_cast<_class*>(static_cast<_base_class*>(                     \
       NS_CYCLE_COLLECTION_CLASSNAME(_base_class)::Downcast(s)));               \
   }                                                                            \
 };                                                                             \
 NS_CYCLE_COLLECTION_PARTICIPANT_INSTANCE
 
-/**
- * This implements a stub UnmarkPurple function for classes that want to be
- * traversed but whose AddRef/Release functions don't add/remove them to/from
- * the purple buffer. If you're just using NS_DECL_CYCLE_COLLECTING_ISUPPORTS
- * then you don't need this.
- */
-#define NS_DECL_CYCLE_COLLECTION_UNMARK_PURPLE_STUB(_class)                    \
-  NS_IMETHODIMP_(void) UnmarkPurple()                                          \
-  {                                                                            \
-  }                                                                            \
-
 #define NS_IMPL_CYCLE_COLLECTION_CLASS(_class)                                 \
   NS_CYCLE_COLLECTION_CLASSNAME(_class) NS_CYCLE_COLLECTION_NAME(_class);
 
 #define NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS_BODY                             \
   public:                                                                      \
     NS_IMETHOD RootAndUnlinkJSObjects(void *n);                                \
     NS_IMETHOD Unlink(void *n);                                                \
     NS_IMETHOD Unroot(void *n);                                                \
diff --git a/xpcom/glue/nsISupportsImpl.h b/xpcom/glue/nsISupportsImpl.h
--- a/xpcom/glue/nsISupportsImpl.h
+++ b/xpcom/glue/nsISupportsImpl.h
@@ -80,120 +80,156 @@ private:
 
 #else // !NS_DEBUG
 
 #define NS_DECL_OWNINGTHREAD            /* nothing */
 #define NS_ASSERT_OWNINGTHREAD(_class)  ((void)0)
 
 #endif // NS_DEBUG
 
-#define NS_PURPLE_BIT ((PRUint32)(1 << 31))
-
-#define NS_PURPLE_MASK (~NS_PURPLE_BIT)
-#define NS_PURPLE_BIT_SET(x) ((x) & (NS_PURPLE_BIT))
-#define NS_CLEAR_PURPLE_BIT(x) ((x) &= (NS_PURPLE_MASK))
-#define NS_VALUE_WITHOUT_PURPLE_BIT(x) ((x) & (NS_PURPLE_MASK))
-
+#define NS_CCAR_REFCNT_BIT 1
+#define NS_CCAR_REFCNT_TO_TAGGED(rc_) \
+  NS_INT32_TO_PTR((rc << 1) | NS_CCAR_REFCNT_BIT)
+#define NS_CCAR_PURPLE_ENTRY_TO_TAGGED(pe_) \
+  static_cast<void*>(pe_)
+#define NS_CCAR_TAGGED_TO_REFCNT(tagged_) \
+  nsrefcnt(NS_PTR_TO_INT32(tagged_) >> 1)
+#define NS_CCAR_TAGGED_TO_PURPLE_ENTRY(tagged_) \
+  static_cast<PurpleBufferEntry*>(tagged_)
+#define NS_CCAR_TAGGED_STABILIZED_REFCNT NS_PURPLE_ENTRY_TO_TAGGED(0)
 
 // Support for ISupports classes which interact with cycle collector.
 
+struct nsPurpleBufferEntry {
+  nsPurpleBufferEntry *mPrev, *mNext;
+  nsISupports *mObject;
+  // When an object is in the purple buffer, it replaces its reference
+  // count with a (tagged) pointer to this entry, so we store the
+  // reference count for it.
+  nsrefcnt mRefCnt;
+};
+
 class nsCycleCollectingAutoRefCnt {
 
 public:
   nsCycleCollectingAutoRefCnt()
-    : mValue(0)
+    : mTagged(NS_CCAR_REFCNT_TO_TAGGED(0))
   {}
 
   nsCycleCollectingAutoRefCnt(nsrefcnt aValue)
-    : mValue(aValue)
+    : mTagged(NS_CCAR_REFCNT_TO_TAGGED(aValue))
   {
-    NS_CLEAR_PURPLE_BIT(mValue);
   }
 
   nsrefcnt incr(nsISupports *owner)
   {
-    if (NS_UNLIKELY(mValue == NS_PURPLE_BIT)) {
+    if (NS_UNLIKELY(mTagged == NS_CCAR_TAGGED_STABILIZED_REFCNT)) {
       // The sentinel value "purple bit alone, refcount 0" means
       // that we're stabilized, during finalization. In this
       // state we lie about our actual refcount if anyone asks
       // and say it's 2, which is basically true: the caller who
       // is incrementing has a reference, as does the decr() frame
       // that stabilized-and-is-deleting us.
       return 2;
     }
 
-    nsrefcnt tmp = get();
-    PRBool purple = static_cast<PRBool>(NS_PURPLE_BIT_SET(mValue));
+    nsrefcnt refcount;
+    if (IsPurple()) {
+      nsPurpleBufferEntry *e = NS_CCAR_TAGGED_TO_ENTRY(mTagged);
+      refcount = e->mRefCnt;
+      NS_ASSERTION(tmp != 0, "purple ISupports pointer with zero refcnt");
 
-    if (NS_UNLIKELY(purple)) {
-      NS_ASSERTION(tmp != 0, "purple ISupports pointer with zero refcnt");
-      if (!NS_CycleCollectorForget(owner))
-        tmp |= NS_PURPLE_BIT;
+      if (NS_LIKELY(NS_CycleCollectorForget(e))) {
+        // |e| is now invalid
+        ++refcount;
+        mTagged = NS_CCAR_REFCNT_TO_TAGGED(refcount);
+      } else {
+        ++refcount;
+        e->mRefCnt = refcount;
+      }
+    } else {
+      refcount = NS_CCAR_TAGGED_TO_REFCNT(mTagged);
+      ++refcount;
+      mTagged = NS_CCAR_REFCNT_TO_TAGGED(refcount);
     }
 
-    mValue = tmp + 1;
-    return mValue;
+    return refcount;
   }
 
   void stabilizeForDeletion(nsISupports *owner)
   {
-    mValue = NS_PURPLE_BIT;
+    mValue = NS_CCAR_TAGGED_STABILIZED_REFCNT;
   }
 
   nsrefcnt decr(nsISupports *owner)
   {
-    if (NS_UNLIKELY(mValue == NS_PURPLE_BIT))
+    if (NS_UNLIKELY(mTagged == NS_CCAR_TAGGED_STABILIZED_REFCNT))
       return 1;
 
-    nsrefcnt tmp = get();
-    NS_ASSERTION(tmp >= 1, "decr() called with zero refcnt");
+    nsrefcnt refcount;
+    if (IsPurple()) {
+      nsPurpleBufferEntry *e = NS_CCAR_TAGGED_TO_ENTRY(mTagged);
+      refcount = e->mRefCnt;
+      --refcount;
+      
+      if (NS_UNLIKELY(refcount == 0)) {
+        if (NS_UNLIKELY(!NS_CycleCollectorForget(e))) {
+          NS_NOTREACHED("forget should not fail when reference count hits 0");
+        }
+        mTagged = NS_CCAR_REFCNT_TO_TAGGED(refcount);
+      } else {
+        e->mRefCnt = refcount;
+      }
+    } else {
+      refcount = NS_CCAR_TAGGED_TO_REFCNT(mTagged);
+      --refcount;
 
-    PRBool purple = static_cast<PRBool>(NS_PURPLE_BIT_SET(mValue));
-    PRBool shouldBePurple = tmp > 1;
-
-    if (NS_UNLIKELY(shouldBePurple && !purple)) {
-      if (!NS_CycleCollectorSuspect(owner))
-        shouldBePurple = PR_FALSE;
-    } else if (NS_UNLIKELY(tmp == 1 && purple)) {
-      if (!NS_CycleCollectorForget(owner)) {
-        NS_NOTREACHED("forget should not fail when reference count hits 0");
+      nsPurpleBufferEntry *e;
+      if (NS_LIKELY(refcount > 0) &&
+          ((e = NS_CycleCollectorSuspect(owner)))) {
+        e->mRefCnt = refcount;
+        mTagged = NS_CCAR_ENTRY_TO_TAGGED(e);
+      } else {
+        mTagged = NS_CCAR_REFCNT_TO_TAGGED(refcount);
       }
     }
 
-    --tmp;
-
-    if (shouldBePurple)
-      mValue = tmp | NS_PURPLE_BIT;
-    else
-      mValue = tmp;
-
-    return tmp;
+    return refcount;
   }
 
   void unmarkPurple()
   {
     if (NS_LIKELY(mValue != NS_PURPLE_BIT))
       NS_CLEAR_PURPLE_BIT(mValue);
   }
 
+  PRBool IsPurple() const
+  {
+    NS_ASSERTION(mTagged != NS_CCAR_TAGGED_STABILIZED_REFCNT,
+                 "should have checked for stabilization first");
+    return !(mTagged & NS_CCAR_REFCNT_BIT);
+  }
+
   nsrefcnt get() const
   {
-    if (NS_UNLIKELY(mValue == NS_PURPLE_BIT))
+    if (NS_UNLIKELY(mTagged == NS_TAGGED_STABILIZED_REFCNT))
       return 1;
 
-    return NS_VALUE_WITHOUT_PURPLE_BIT(mValue);
+    return NS_UNLIKELY(IsPurple())
+             ? NS_CCAR_TAGGED_TO_PURPLE_ENTRY(mTagged)->mRefCnt
+             : NS_CCAR_TAGGED_TO_REFCNT(mTagged);
   }
 
   operator nsrefcnt() const
   {
     return get();
   }
 
  private:
-  nsrefcnt mValue;
+  void *mTagged;
 };
 
 class nsAutoRefCnt {
 
  public:
     nsAutoRefCnt() : mValue(0) {}
     nsAutoRefCnt(nsrefcnt aValue) : mValue(aValue) {}
 
@@ -230,19 +266,19 @@ protected:                              
 public:
 
 #define NS_DECL_CYCLE_COLLECTING_ISUPPORTS                                    \
 public:                                                                       \
   NS_IMETHOD QueryInterface(REFNSIID aIID,                                    \
                             void** aInstancePtr);                             \
   NS_IMETHOD_(nsrefcnt) AddRef(void);                                         \
   NS_IMETHOD_(nsrefcnt) Release(void);                                        \
-  void UnmarkPurple()                                                         \
+  nsCycleCollectingAutoRefCnt* AutoRefCnt()                                   \
   {                                                                           \
-    mRefCnt.unmarkPurple();                                                   \
+    return &mRefCnt;                                                          \
   }                                                                           \
 protected:                                                                    \
   nsCycleCollectingAutoRefCnt mRefCnt;                                        \
   NS_DECL_OWNINGTHREAD                                                        \
 public:
 
 
 ///////////////////////////////////////////////////////////////////////////////
