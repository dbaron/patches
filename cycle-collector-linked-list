From: L. David Baron <dbaron@dbaron.org>

Implement cycle collector's purple buffer using a linked list rather than a hash table.  (Bug 490695)

diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -230,21 +230,18 @@ struct nsCycleCollectorStats
     PRUint32 mFreedBytes;
 
     PRUint32 mSetColorGrey;
     PRUint32 mSetColorBlack;
     PRUint32 mSetColorWhite;
 
     PRUint32 mFailedUnlink;
     PRUint32 mCollectedNode;
-    PRUint32 mBumpGeneration;
-    PRUint32 mZeroGeneration;
 
     PRUint32 mSuspectNode;
-    PRUint32 mSpills;    
     PRUint32 mForgetNode;
     PRUint32 mFreedWhilePurple;
   
     PRUint32 mCollection;
 
     nsCycleCollectorStats()
     {
         memset(this, 0, sizeof(nsCycleCollectorStats));
@@ -264,21 +261,18 @@ struct nsCycleCollectorStats
         DUMP(mFreedBytes);
     
         DUMP(mSetColorGrey);
         DUMP(mSetColorBlack);
         DUMP(mSetColorWhite);
     
         DUMP(mFailedUnlink);
         DUMP(mCollectedNode);
-        DUMP(mBumpGeneration);
-        DUMP(mZeroGeneration);
     
         DUMP(mSuspectNode);
-        DUMP(mSpills);
         DUMP(mForgetNode);
         DUMP(mFreedWhilePurple);
     
         DUMP(mCollection);
 #undef DUMP
     }
 };
 #endif
@@ -656,230 +650,224 @@ struct GCGraph
     }
     ~GCGraph() { 
     }
 };
 
 // XXX Would be nice to have an nsHashSet<KeyType> API that has
 // Add/Remove/Has rather than PutEntry/RemoveEntry/GetEntry.
 typedef nsTHashtable<nsVoidPtrHashKey> PointerSet;
-typedef nsBaseHashtable<nsVoidPtrHashKey, PRUint32, PRUint32>
-    PointerSetWithGeneration;
 
 #ifdef DEBUG_CC
 static void
 WriteGraph(FILE *stream, GCGraph &graph, const void *redPtr);
 #endif
 
 struct nsPurpleBuffer
 {
+private:
+    struct Block {
+        Block *mNext;
+        nsPurpleBufferEntry mEntries[512];
 
-#define ASSOCIATIVITY 2
-#define INDEX_LOW_BIT 6
-#define N_INDEX_BITS 13
-
-#define N_ENTRIES (1 << N_INDEX_BITS)
-#define N_POINTERS (N_ENTRIES * ASSOCIATIVITY)
-#define TOTAL_BYTES (N_POINTERS * PR_BYTES_PER_WORD)
-#define INDEX_MASK PR_BITMASK(N_INDEX_BITS)
-#define POINTER_INDEX(P) ((((PRUword)P) >> INDEX_LOW_BIT) & (INDEX_MASK))
-
-#if (INDEX_LOW_BIT + N_INDEX_BITS > (8 * PR_BYTES_PER_WORD))
-#error "index bit overflow"
-#endif
-
-    // This class serves as a generational wrapper around a pldhash
-    // table: a subset of generation zero lives in mCache, the
-    // remainder spill into the mBackingStore hashtable. The idea is
-    // to get a higher hit rate and greater locality of reference for
-    // generation zero, in which the vast majority of suspect/forget
-    // calls annihilate one another.
+        Block() : mNext(nsnull) {}
+    };
+public:
+    // This class wraps a linked list of the elements in the purple
+    // buffer.
 
     nsCycleCollectorParams &mParams;
+    nsPurpleBufferEntry mListHead;
+    PRUint32 mCount;
+    Block mFirstBlock;
+    // mFreeList is singly-linked via mNext.
+    nsPurpleBufferEntry *mFreeList;
+    // The remainder of the current block.
+    nsPurpleBufferEntry *mUnallocatedEntry, *mUnallocatedEnd;
+
+    // For objects compiled against Gecko 1.9 and 1.9.1.
+    PointerSet mCompatObjects;
 #ifdef DEBUG_CC
     nsCycleCollectorStats &mStats;
 #endif
-    void* mCache[N_POINTERS];
-    PRUint32 mCurrGen;    
-    PointerSetWithGeneration mBackingStore;
     
 #ifdef DEBUG_CC
     nsPurpleBuffer(nsCycleCollectorParams &params,
                    nsCycleCollectorStats &stats) 
         : mParams(params),
-          mStats(stats),
-          mCurrGen(0)
+          mStats(stats)
     {
         Init();
     }
 #else
     nsPurpleBuffer(nsCycleCollectorParams &params) 
-        : mParams(params),
-          mCurrGen(0)
+        : mParams(params)
     {
         Init();
     }
 #endif
 
     ~nsPurpleBuffer()
     {
-        memset(mCache, 0, sizeof(mCache));
-        mBackingStore.Clear();
+        Block *b = mFirstBlock.mNext; 
+        while (b) {
+            Block *next = b->mNext;
+            delete b;
+            b = next;
+        }
     }
 
     void Init()
     {
-        memset(mCache, 0, sizeof(mCache));
-        mBackingStore.Init();
+        mCount = 0;
+        mListHead.mPrev = &mListHead;
+        mListHead.mNext = &mListHead;
+        mFreeList = nsnull;
+        StartBlock(&mFirstBlock);
+        mCompatObjects.Init();
     }
 
-    void BumpGeneration();
-    void SelectAgedPointers(GCGraphBuilder &builder);
+    void StartBlock(Block *aBlock)
+    {
+        mUnallocatedEntry = aBlock->mEntries;
+        mUnallocatedEnd = aBlock->mEntries + NS_ARRAY_LENGTH(aBlock->mEntries);
+    }
+
+    void SelectPointers(GCGraphBuilder &builder);
 
 #ifdef DEBUG_CC
     void NoteAll(GCGraphBuilder &builder);
 #endif
 
-    PRBool Exists(void *p)
+    nsPurpleBufferEntry* NewEntry()
     {
-        PRUint32 idx = POINTER_INDEX(p);
-        for (PRUint32 i = 0; i < ASSOCIATIVITY; ++i) {
-            if (mCache[idx+i] == p)
-                return PR_TRUE;
+        if (mFreeList) {
+            nsPurpleBufferEntry *e = mFreeList;
+            mFreeList = mFreeList->mNext;
+            return e;
         }
-        PRUint32 gen;
-        return mBackingStore.Get(p, &gen);
+
+        if (mUnallocatedEntry == mUnallocatedEnd) {
+            Block *b = new Block;
+            if (!b) {
+                return nsnull;
+            }
+            StartBlock(b);
+        }
+
+        nsPurpleBufferEntry *e = mUnallocatedEntry;
+        ++mUnallocatedEntry;
+        return e;
     }
 
-    void Put(void *p)
+    nsPurpleBufferEntry* Put(nsISupports *p)
     {
-        PRUint32 idx = POINTER_INDEX(p);
-        for (PRUint32 i = 0; i < ASSOCIATIVITY; ++i) {
-            if (!mCache[idx+i]) {
-                mCache[idx+i] = p;
-                return;
-            }
+        nsPurpleBufferEntry *e = NewEntry();
+        if (!e) {
+            return nsnull;
         }
-#ifdef DEBUG_CC
-        mStats.mSpills++;
-#endif
-        SpillOne(p);
+
+        ++mCount;
+
+        e->mObject = p;
+
+        e->mNext = mListHead.mNext;
+        e->mPrev = &mListHead;
+        mListHead.mNext->mPrev = e;
+        mListHead.mNext = e;
+
+        // Caller is responsible for filling in result's mRefCnt.
+        return e;
     }
 
-    void Remove(void *p)     
+    void Remove(nsPurpleBufferEntry *e)
     {
-        PRUint32 idx = POINTER_INDEX(p);
-        for (PRUint32 i = 0; i < ASSOCIATIVITY; ++i) {
-            if (mCache[idx+i] == p) {
-                mCache[idx+i] = (void*)0;
-                return;
-            }
-        }
-        mBackingStore.Remove(p);
+        NS_ASSERTION(mCount != 0, "must have entries");
+
+        e->mNext->mPrev = e->mPrev;
+        e->mPrev->mNext = e->mNext;
+
+        e->mNext = mFreeList;
+        mFreeList = e;
+
+        --mCount;
     }
 
-    void SpillOne(void* &p)
+    PRBool PutCompatObject(nsISupports *p)
     {
-        mBackingStore.Put(p, mCurrGen);
-        p = (void*)0;
+        ++mCount;
+        return !!mCompatObjects.PutEntry(p);
     }
 
-    void SpillAll()
+    void RemoveCompatObject(nsISupports *p)
     {
-        for (PRUint32 i = 0; i < N_POINTERS; ++i) {
-            if (mCache[i]) {
-                SpillOne(mCache[i]);
-            }
-        }
+        --mCount;
+        mCompatObjects.RemoveEntry(p);
     }
 
-    PRUint32 Count()
+    PRUint32 Count() const
     {
-        PRUint32 count = mBackingStore.Count();
-        for (PRUint32 i = 0; i < N_POINTERS; ++i) {
-            if (mCache[i]) {
-                ++count;
-            }
-        }
-        return count;
+        return mCount;
     }
 };
 
-static PLDHashOperator
-zeroGenerationCallback(const void*  ptr,
-                       PRUint32&    generation,
-                       void*        userArg)
-{
-#ifdef DEBUG_CC
-    nsPurpleBuffer *purp = static_cast<nsPurpleBuffer*>(userArg);
-    purp->mStats.mZeroGeneration++;
-#endif
-    generation = 0;
-    return PL_DHASH_NEXT;
-}
-
-void nsPurpleBuffer::BumpGeneration()
-{
-    SpillAll();
-    if (mCurrGen == 0xffffffff) {
-        mBackingStore.Enumerate(zeroGenerationCallback, this);
-        mCurrGen = 0;
-    } else {
-        ++mCurrGen;
-    }
-#ifdef DEBUG_CC
-    mStats.mBumpGeneration++;
-#endif
-}
-
-static inline PRBool
-SufficientlyAged(PRUint32 generation, nsPurpleBuffer *p)
-{
-    return generation + p->mParams.mScanDelay < p->mCurrGen;
-}
-
 struct CallbackClosure
 {
     CallbackClosure(nsPurpleBuffer *aPurpleBuffer, GCGraphBuilder &aBuilder)
         : mPurpleBuffer(aPurpleBuffer),
           mBuilder(aBuilder)
     {
     }
     nsPurpleBuffer *mPurpleBuffer;
     GCGraphBuilder &mBuilder;
 };
 
 static PRBool
 AddPurpleRoot(GCGraphBuilder &builder, nsISupports *root);
 
 static PLDHashOperator
-ageSelectionCallback(const void*  ptr,
-                     PRUint32&    generation,
-                     void*        userArg)
+selectionCallback(nsVoidPtrHashKey* key, void* userArg)
 {
     CallbackClosure *closure = static_cast<CallbackClosure*>(userArg);
-    if (SufficientlyAged(generation, closure->mPurpleBuffer) &&
-        AddPurpleRoot(closure->mBuilder,
-                      static_cast<nsISupports *>(const_cast<void*>(ptr))))
+    if (AddPurpleRoot(closure->mBuilder,
+                      static_cast<nsISupports *>(
+                        const_cast<void*>(key->GetKey()))))
         return PL_DHASH_REMOVE;
 
     return PL_DHASH_NEXT;
 }
 
 void
-nsPurpleBuffer::SelectAgedPointers(GCGraphBuilder &aBuilder)
+nsPurpleBuffer::SelectPointers(GCGraphBuilder &aBuilder)
 {
-    // Rely on our caller having done a BumpGeneration first, which in
-    // turn calls SpillAll.
     CallbackClosure closure(this, aBuilder);
-    mBackingStore.Enumerate(ageSelectionCallback, &closure);
+    mCompatObjects.EnumerateEntries(selectionCallback, &closure);
+
+    NS_ASSERTION((mListHead.mNext == &mListHead) == (mCount == 0),
+                 "count inconsistent with list");
+    if (mListHead.mNext == &mListHead) {
+        // The emptying code below is not tolerant of this case.
+        return;
+    }
+
+    for (nsPurpleBufferEntry *e = mListHead.mNext; e != &mListHead;
+         e = e->mNext) {
+         AddPurpleRoot(aBuilder, e->mObject);
+    }
+
+    // Put all the purple buffer entries (doubly linked) on the free
+    // list (singly linked).
+    mListHead.mPrev->mNext = mFreeList;
+    mFreeList = mListHead.mNext;
+    mListHead.mNext = &mListHead;
+    mListHead.mPrev = &mListHead;
+    mCount = 0;
+    // Should we free our blocks?
 }
 
-
-
 ////////////////////////////////////////////////////////////////////////
 // Implement the LanguageRuntime interface for C++/XPCOM 
 ////////////////////////////////////////////////////////////////////////
 
 
 struct nsCycleCollectionXPCOMRuntime : 
     public nsCycleCollectionLanguageRuntime 
 {
@@ -927,18 +915,23 @@ struct nsCycleCollector
     void MarkRoots(GCGraphBuilder &builder);
     void ScanRoots();
     void RootWhite();
     PRBool CollectWhite(); // returns whether anything was collected
 
     nsCycleCollector();
     ~nsCycleCollector();
 
+    // The first pair of Suspect and Forget functions are only used by
+    // old XPCOM binary components.
     PRBool Suspect(nsISupports *n);
     PRBool Forget(nsISupports *n);
+    nsPurpleBufferEntry* Suspect2(nsISupports *n);
+    PRBool Forget2(nsPurpleBufferEntry *e);
+
     PRUint32 Collect(PRUint32 aTryCollections = 1);
     PRBool BeginCollection();
     PRBool FinishCollection();
     PRUint32 SuspectedCount();
     void Shutdown();
 
     void ClearGraph()
     {
@@ -1499,37 +1492,30 @@ AddPurpleRoot(GCGraphBuilder &builder, n
     }
 
     cp->UnmarkPurple(root);
 
     return PR_TRUE;
 }
 
 #ifdef DEBUG_CC
-static PLDHashOperator
-noteAllCallback(const void* ptr, PRUint32& generation, void* userArg)
-{
-    GCGraphBuilder *builder = static_cast<GCGraphBuilder*>(userArg);
-    builder->NoteXPCOMRoot(static_cast<nsISupports *>(const_cast<void*>(ptr)));
-    return PL_DHASH_NEXT;
-}
-
 void
 nsPurpleBuffer::NoteAll(GCGraphBuilder &builder)
 {
-    SpillAll();
-    mBackingStore.Enumerate(noteAllCallback, &builder);
+    for (nsPurpleBufferEntry *e = mListHead.mNext; e != &mListHead;
+         e = e->mNext) {
+        builder->NoteXPCOMRoot(e->mObject);
+    }
 }
 #endif
 
 void 
 nsCycleCollector::SelectPurple(GCGraphBuilder &builder)
 {
-    mPurpleBuf.BumpGeneration();
-    mPurpleBuf.SelectAgedPointers(builder);
+    mPurpleBuf.SelectPointers(builder);
 }
 
 void
 nsCycleCollector::MarkRoots(GCGraphBuilder &builder)
 {
     mGraph.mRootCount = builder.Count();
 
     // read the PtrInfo out of the graph that we are building
@@ -1967,19 +1953,18 @@ nsCycleCollector::Suspect(nsISupports *n
 
     if (mParams.mLogPointers) {
         if (!mPtrLog)
             mPtrLog = fopen("pointer_log", "w");
         fprintf(mPtrLog, "S %p\n", static_cast<void*>(n));
     }
 #endif
 
-    mPurpleBuf.Put(n);
-
-    return PR_TRUE;
+    // Caller is responsible for filling in result's mRefCnt.
+    return mPurpleBuf.PutCompatObject(n);
 }
 
 
 PRBool
 nsCycleCollector::Forget(nsISupports *n)
 {
     // Re-entering ::Forget during collection used to be a fault, but
     // we are canonicalizing nsISupports pointers using QI, so we will
@@ -2003,20 +1988,103 @@ nsCycleCollector::Forget(nsISupports *n)
 
     if (mParams.mLogPointers) {
         if (!mPtrLog)
             mPtrLog = fopen("pointer_log", "w");
         fprintf(mPtrLog, "F %p\n", static_cast<void*>(n));
     }
 #endif
 
-    mPurpleBuf.Remove(n);
+    mPurpleBuf.RemoveCompatObject(n);
     return PR_TRUE;
 }
 
+nsPurpleBufferEntry*
+nsCycleCollector::Suspect2(nsISupports *n)
+{
+    // Re-entering ::Suspect during collection used to be a fault, but
+    // we are canonicalizing nsISupports pointers using QI, so we will
+    // see some spurious refcount traffic here. 
+
+    if (mScanInProgress)
+        return nsnull;
+
+    NS_ASSERTION(nsCycleCollector_isScanSafe(n),
+                 "suspected a non-scansafe pointer");
+    NS_ASSERTION(NS_IsMainThread(), "trying to suspect from non-main thread");
+
+    if (mParams.mDoNothing)
+        return nsnull;
+
+#ifdef DEBUG_CC
+    mStats.mSuspectNode++;
+
+    if (nsCycleCollector_shouldSuppress(n))
+        return nsnull;
+
+#ifndef __MINGW32__
+    if (mParams.mHookMalloc)
+        InitMemHook();
+#endif
+
+    if (mParams.mLogPointers) {
+        if (!mPtrLog)
+            mPtrLog = fopen("pointer_log", "w");
+        fprintf(mPtrLog, "S %p\n", static_cast<void*>(n));
+    }
+#endif
+
+    // Caller is responsible for filling in result's mRefCnt.
+    return mPurpleBuf.Put(n);
+}
+
+
+PRBool
+nsCycleCollector::Forget2(nsPurpleBufferEntry *e)
+{
+    // Re-entering ::Forget during collection used to be a fault, but
+    // we are canonicalizing nsISupports pointers using QI, so we will
+    // see some spurious refcount traffic here. 
+
+    if (mScanInProgress)
+        return PR_FALSE;
+
+    NS_ASSERTION(NS_IsMainThread(), "trying to forget from non-main thread");
+    
+#ifdef DEBUG_CC
+    mStats.mForgetNode++;
+
+#ifndef __MINGW32__
+    if (mParams.mHookMalloc)
+        InitMemHook();
+#endif
+
+    if (mParams.mLogPointers) {
+        if (!mPtrLog)
+            mPtrLog = fopen("pointer_log", "w");
+        fprintf(mPtrLog, "F %p\n", static_cast<void*>(n));
+    }
+#endif
+
+    mPurpleBuf.Remove(e);
+    return PR_TRUE;
+}
+
+#ifdef DEBUG_CC
+static PRBool
+IsInPurpleBuf(PtrInfo *aPtrInfo)
+{
+    if (aPtrInfo->mLangID != nsIProgrammingLanguage::CPLUSPLUS)
+        return PR_FALSE;
+
+    // XXX WRITE ME!  Lying for now!
+    return PR_FALSE;
+}
+#endif
+
 PRUint32
 nsCycleCollector::Collect(PRUint32 aTryCollections)
 {
 #if defined(DEBUG_CC) && !defined(__MINGW32__)
     if (!mParams.mDoNothing && mParams.mHookMalloc)
         InitMemHook();
 #endif
 
@@ -2056,18 +2124,17 @@ nsCycleCollector::Collect(PRUint32 aTryC
 #ifdef DEBUG_CC
         // We wait until after FinishCollection to check the white nodes because
         // some objects may outlive CollectWhite but then be freed by
         // FinishCycleCollection (like XPConnect's deferred release of native
         // objects).
         PRUint32 i, count = mWhiteNodes->Length();
         for (i = 0; i < count; ++i) {
             PtrInfo *pinfo = mWhiteNodes->ElementAt(i);
-            if (pinfo->mLangID == nsIProgrammingLanguage::CPLUSPLUS &&
-                mPurpleBuf.Exists(pinfo->mPointer)) {
+            if (IsInPurpleBuf(pinfo)) {
                 printf("nsCycleCollector: %s object @%p is still alive after\n"
                        "  calling RootAndUnlinkJSObjects, Unlink, and Unroot on"
                        " it!  This probably\n"
                        "  means the Unlink implementation was insufficient.\n",
                        pinfo->mName, pinfo->mPointer);
             }
         }
 #endif
@@ -2566,17 +2633,17 @@ nsCycleCollector::ExplainLiveExpectedGar
                     }
                 }
 
                 {
                     NodePool::Enumerator queue(mGraph.mNodes);
                     while (!queue.IsDone()) {
                         PtrInfo *pi = queue.GetNext();
                         if (pi->mColor == white) {
-                            if (mPurpleBuf.Exists(pi->mPointer)) {
+                            if (IsInPurpleBuf(pi)) {
                                 printf(
 "nsCycleCollector: %s %p in component %d\n"
 "  which was reference counted during the root/unlink/unroot phase of the\n"
 "  last collection was not collected due to failure to unlink (see other\n"
 "  warnings) or deficiency in traverse that causes cycles referenced only\n"
 "  from other cycles to require multiple rounds of cycle collection in which\n"
 "  this object was likely the reachable object\n",
                                        pi->mName, pi->mPointer, pi->mSCCIndex);
@@ -2701,23 +2768,36 @@ nsCycleCollector_forgetRuntime(PRUint32 
 PRBool
 NS_CycleCollectorSuspect(nsISupports *n)
 {
     if (sCollector)
         return sCollector->Suspect(n);
     return PR_FALSE;
 }
 
-
 PRBool
 NS_CycleCollectorForget(nsISupports *n)
 {
     return sCollector ? sCollector->Forget(n) : PR_TRUE;
 }
 
+nsPurpleBufferEntry*
+NS_CycleCollectorSuspect2(nsISupports *n)
+{
+    if (sCollector)
+        return sCollector->Suspect2(n);
+    return nsnull;
+}
+
+PRBool
+NS_CycleCollectorForget2(nsPurpleBufferEntry *e)
+{
+    return sCollector ? sCollector->Forget2(e) : PR_TRUE;
+}
+
 
 PRUint32
 nsCycleCollector_collect()
 {
     fprintf(stderr, "Starting nsCycleCollector_collect\n");
     PRIntervalTime start = PR_IntervalNow();
     PRUint32 result = sCollector ? sCollector->Collect() : 0;
     PRIntervalTime end = PR_IntervalNow();
diff --git a/xpcom/build/dlldeps.cpp b/xpcom/build/dlldeps.cpp
--- a/xpcom/build/dlldeps.cpp
+++ b/xpcom/build/dlldeps.cpp
@@ -278,17 +278,16 @@ void XXXNeverCalled()
       nsStringBuffer::Alloc(0);
       nsStringBuffer::Realloc(nsnull, 0);
       nsStringBuffer::FromString(x);
       nsStringBuffer::FromString(y);
       b.ToString(0, x);
       b.ToString(0, y);
     }
 
-    nsXPCOMCycleCollectionParticipant();
     nsCycleCollector_collect();
 
 #if !defined(XP_OS2)
     NS_NewWindowsRegKey(nsnull);
 #endif
 
     NS_NewThread(nsnull, nsnull);
     NS_GetCurrentThread(nsnull);
diff --git a/xpcom/build/nsXPCOM.h b/xpcom/build/nsXPCOM.h
--- a/xpcom/build/nsXPCOM.h
+++ b/xpcom/build/nsXPCOM.h
@@ -61,41 +61,46 @@
 # define NS_LogAddRef                NS_LogAddRef_P
 # define NS_LogRelease               NS_LogRelease_P
 # define NS_LogCtor                  NS_LogCtor_P
 # define NS_LogDtor                  NS_LogDtor_P
 # define NS_LogCOMPtrAddRef          NS_LogCOMPtrAddRef_P
 # define NS_LogCOMPtrRelease         NS_LogCOMPtrRelease_P
 # define NS_CycleCollectorSuspect    NS_CycleCollectorSuspect_P
 # define NS_CycleCollectorForget     NS_CycleCollectorForget_P
+# define NS_CycleCollectorSuspect2   NS_CycleCollectorSuspect2_P
+# define NS_CycleCollectorForget2    NS_CycleCollectorForget2_P
 #endif
 
 #include "nscore.h"
 #include "nsXPCOMCID.h"
 
 #ifdef __cplusplus
 #define DECL_CLASS(c) class c
+#define DECL_STRUCT(c) struct c
 #else
 #define DECL_CLASS(c) typedef struct c c
+#define DECL_STRUCT(c) typedef struct c c
 #endif
 
 DECL_CLASS(nsAString);
 DECL_CLASS(nsACString);
 
 DECL_CLASS(nsISupports);
 DECL_CLASS(nsIModule);
 DECL_CLASS(nsIComponentManager);
 DECL_CLASS(nsIComponentRegistrar);
 DECL_CLASS(nsIServiceManager);
 DECL_CLASS(nsIFile);
 DECL_CLASS(nsILocalFile);
 DECL_CLASS(nsIDirectoryServiceProvider);
 DECL_CLASS(nsIMemory);
 DECL_CLASS(nsIDebug);
 DECL_CLASS(nsITraceRefcnt);
+DECL_STRUCT(nsPurpleBufferEntry);
 
 /**
  * Every XPCOM component implements this function signature, which is the
  * only entrypoint XPCOM uses to the function.
  *
  * @status FROZEN
  */
 typedef nsresult (*nsGetModuleProc)(nsIComponentManager *aCompMgr,
@@ -454,23 +459,32 @@ NS_LogCOMPtrAddRef(void *aCOMPtr, nsISup
 
 XPCOM_API(void)
 NS_LogCOMPtrRelease(void *aCOMPtr, nsISupports *aObject);
 
 /**
  * The XPCOM cycle collector analyzes and breaks reference cycles between
  * participating XPCOM objects. All objects in the cycle must implement
  * nsCycleCollectionParticipant to break cycles correctly.
+ *
+ * The first two functions below exist only to support binary components
+ * that were compiled for older XPCOM versions.
  */
 XPCOM_API(PRBool)
 NS_CycleCollectorSuspect(nsISupports *n);
 
 XPCOM_API(PRBool)
 NS_CycleCollectorForget(nsISupports *n);
 
+XPCOM_API(nsPurpleBufferEntry*)
+NS_CycleCollectorSuspect2(nsISupports *n);
+
+XPCOM_API(PRBool)
+NS_CycleCollectorForget2(nsPurpleBufferEntry *e);
+
 /**
  * Categories (in the category manager service) used by XPCOM:
  */
 
 /**
  * A category which is read after component registration but before
  * the "xpcom-startup" notifications. Each category entry is treated
  * as the contract ID of a service which implements
diff --git a/xpcom/build/nsXPCOMPrivate.h b/xpcom/build/nsXPCOMPrivate.h
--- a/xpcom/build/nsXPCOMPrivate.h
+++ b/xpcom/build/nsXPCOMPrivate.h
@@ -114,16 +114,19 @@ typedef void       (* LogAddRefFunc)(voi
 typedef void       (* LogReleaseFunc)(void*, nsrefcnt, const char*);
 typedef void       (* LogCtorFunc)(void*, const char*, PRUint32);
 typedef void       (* LogCOMPtrFunc)(void*, nsISupports*);
 
 typedef nsresult   (* GetXPTCallStubFunc)(REFNSIID, nsIXPTCProxy*, nsISomeInterface**);
 typedef void       (* DestroyXPTCallStubFunc)(nsISomeInterface*);
 typedef nsresult   (* InvokeByIndexFunc)(nsISupports*, PRUint32, PRUint32, nsXPTCVariant*);
 typedef PRBool     (* CycleCollectorFunc)(nsISupports*);
+typedef nsPurpleBufferEntry*
+                   (* CycleCollectorSuspect2Func)(nsISupports*);
+typedef PRBool     (* CycleCollectorForget2Func)(nsPurpleBufferEntry*);
 
 // PRIVATE AND DEPRECATED
 typedef NS_CALLBACK(XPCOMExitRoutine)(void);
 
 typedef nsresult   (* RegisterXPCOMExitRoutineFunc)(XPCOMExitRoutine exitRoutine, PRUint32 priority);
 typedef nsresult   (* UnregisterXPCOMExitRoutineFunc)(XPCOMExitRoutine exitRoutine);
 
 typedef struct XPCOMFunctions{
@@ -189,16 +192,20 @@ typedef struct XPCOMFunctions{
     InvokeByIndexFunc invokeByIndexFunc;
     CycleCollectorFunc cycleSuspectFunc;
     CycleCollectorFunc cycleForgetFunc;
     StringSetIsVoidFunc stringSetIsVoid;
     StringGetIsVoidFunc stringGetIsVoid;
     CStringSetIsVoidFunc cstringSetIsVoid;
     CStringGetIsVoidFunc cstringGetIsVoid;
 
+    // Added for Mozilla 1.9.2
+    CycleCollectorSuspect2Func cycleSuspect2Func;
+    CycleCollectorForget2Func cycleForget2Func;
+
 } XPCOMFunctions;
 
 typedef nsresult (*GetFrozenFunctionsFunc)(XPCOMFunctions *entryPoints, const char* libraryPath);
 XPCOM_API(nsresult)
 NS_GetFrozenFunctions(XPCOMFunctions *entryPoints, const char* libraryPath);
 
 // think hard before changing this
 #define XPCOM_GLUE_VERSION 1
diff --git a/xpcom/glue/nsISupportsImpl.h b/xpcom/glue/nsISupportsImpl.h
--- a/xpcom/glue/nsISupportsImpl.h
+++ b/xpcom/glue/nsISupportsImpl.h
@@ -80,120 +80,157 @@ private:
 
 #else // !NS_DEBUG
 
 #define NS_DECL_OWNINGTHREAD            /* nothing */
 #define NS_ASSERT_OWNINGTHREAD(_class)  ((void)0)
 
 #endif // NS_DEBUG
 
-#define NS_PURPLE_BIT ((PRUint32)(1 << 31))
-
-#define NS_PURPLE_MASK (~NS_PURPLE_BIT)
-#define NS_PURPLE_BIT_SET(x) ((x) & (NS_PURPLE_BIT))
-#define NS_CLEAR_PURPLE_BIT(x) ((x) &= (NS_PURPLE_MASK))
-#define NS_VALUE_WITHOUT_PURPLE_BIT(x) ((x) & (NS_PURPLE_MASK))
-
+#define NS_CCAR_REFCNT_BIT 1
+#define NS_CCAR_REFCNT_TO_TAGGED(rc_) \
+  NS_INT32_TO_PTR((rc_ << 1) | NS_CCAR_REFCNT_BIT)
+#define NS_CCAR_PURPLE_ENTRY_TO_TAGGED(pe_) \
+  static_cast<void*>(pe_)
+#define NS_CCAR_TAGGED_TO_REFCNT(tagged_) \
+  nsrefcnt(NS_PTR_TO_INT32(tagged_) >> 1)
+#define NS_CCAR_TAGGED_TO_PURPLE_ENTRY(tagged_) \
+  static_cast<nsPurpleBufferEntry*>(tagged_)
+#define NS_CCAR_TAGGED_STABILIZED_REFCNT NS_CCAR_PURPLE_ENTRY_TO_TAGGED(0)
 
 // Support for ISupports classes which interact with cycle collector.
 
+struct nsPurpleBufferEntry {
+  nsPurpleBufferEntry *mPrev, *mNext;
+  nsISupports *mObject;
+  // When an object is in the purple buffer, it replaces its reference
+  // count with a (tagged) pointer to this entry, so we store the
+  // reference count for it.
+  nsrefcnt mRefCnt;
+};
+
 class nsCycleCollectingAutoRefCnt {
 
 public:
   nsCycleCollectingAutoRefCnt()
-    : mValue(0)
+    : mTagged(NS_CCAR_REFCNT_TO_TAGGED(0))
   {}
 
   nsCycleCollectingAutoRefCnt(nsrefcnt aValue)
-    : mValue(aValue)
+    : mTagged(NS_CCAR_REFCNT_TO_TAGGED(aValue))
   {
-    NS_CLEAR_PURPLE_BIT(mValue);
   }
 
   nsrefcnt incr(nsISupports *owner)
   {
-    if (NS_UNLIKELY(mValue == NS_PURPLE_BIT)) {
+    if (NS_UNLIKELY(mTagged == NS_CCAR_TAGGED_STABILIZED_REFCNT)) {
       // The sentinel value "purple bit alone, refcount 0" means
       // that we're stabilized, during finalization. In this
       // state we lie about our actual refcount if anyone asks
       // and say it's 2, which is basically true: the caller who
       // is incrementing has a reference, as does the decr() frame
       // that stabilized-and-is-deleting us.
       return 2;
     }
 
-    nsrefcnt tmp = get();
-    PRBool purple = static_cast<PRBool>(NS_PURPLE_BIT_SET(mValue));
+    nsrefcnt refcount;
+    if (IsPurple()) {
+      nsPurpleBufferEntry *e = NS_CCAR_TAGGED_TO_PURPLE_ENTRY(mTagged);
+      refcount = e->mRefCnt;
+      NS_ASSERTION(refcount != 0, "purple ISupports pointer with zero refcnt");
 
-    if (NS_UNLIKELY(purple)) {
-      NS_ASSERTION(tmp != 0, "purple ISupports pointer with zero refcnt");
-      if (!NS_CycleCollectorForget(owner))
-        tmp |= NS_PURPLE_BIT;
+      if (NS_LIKELY(NS_CycleCollectorForget2(e))) {
+        // |e| is now invalid
+        ++refcount;
+        mTagged = NS_CCAR_REFCNT_TO_TAGGED(refcount);
+      } else {
+        ++refcount;
+        e->mRefCnt = refcount;
+      }
+    } else {
+      refcount = NS_CCAR_TAGGED_TO_REFCNT(mTagged);
+      ++refcount;
+      mTagged = NS_CCAR_REFCNT_TO_TAGGED(refcount);
     }
 
-    mValue = tmp + 1;
-    return mValue;
+    return refcount;
   }
 
   void stabilizeForDeletion(nsISupports *owner)
   {
-    mValue = NS_PURPLE_BIT;
+    mTagged = NS_CCAR_TAGGED_STABILIZED_REFCNT;
   }
 
   nsrefcnt decr(nsISupports *owner)
   {
-    if (NS_UNLIKELY(mValue == NS_PURPLE_BIT))
+    if (NS_UNLIKELY(mTagged == NS_CCAR_TAGGED_STABILIZED_REFCNT))
       return 1;
 
-    nsrefcnt tmp = get();
-    NS_ASSERTION(tmp >= 1, "decr() called with zero refcnt");
+    nsrefcnt refcount;
+    if (IsPurple()) {
+      nsPurpleBufferEntry *e = NS_CCAR_TAGGED_TO_PURPLE_ENTRY(mTagged);
+      refcount = e->mRefCnt;
+      --refcount;
+      
+      if (NS_UNLIKELY(refcount == 0)) {
+        if (NS_UNLIKELY(!NS_CycleCollectorForget2(e))) {
+          NS_NOTREACHED("forget should not fail when reference count hits 0");
+        }
+        mTagged = NS_CCAR_REFCNT_TO_TAGGED(refcount);
+      } else {
+        e->mRefCnt = refcount;
+      }
+    } else {
+      refcount = NS_CCAR_TAGGED_TO_REFCNT(mTagged);
+      --refcount;
 
-    PRBool purple = static_cast<PRBool>(NS_PURPLE_BIT_SET(mValue));
-    PRBool shouldBePurple = tmp > 1;
-
-    if (NS_UNLIKELY(shouldBePurple && !purple)) {
-      if (!NS_CycleCollectorSuspect(owner))
-        shouldBePurple = PR_FALSE;
-    } else if (NS_UNLIKELY(tmp == 1 && purple)) {
-      if (!NS_CycleCollectorForget(owner)) {
-        NS_NOTREACHED("forget should not fail when reference count hits 0");
+      nsPurpleBufferEntry *e;
+      if (NS_LIKELY(refcount > 0) &&
+          ((e = NS_CycleCollectorSuspect2(owner)))) {
+        e->mRefCnt = refcount;
+        mTagged = NS_CCAR_PURPLE_ENTRY_TO_TAGGED(e);
+      } else {
+        mTagged = NS_CCAR_REFCNT_TO_TAGGED(refcount);
       }
     }
 
-    --tmp;
-
-    if (shouldBePurple)
-      mValue = tmp | NS_PURPLE_BIT;
-    else
-      mValue = tmp;
-
-    return tmp;
+    return refcount;
   }
 
   void unmarkPurple()
   {
-    if (NS_LIKELY(mValue != NS_PURPLE_BIT))
-      NS_CLEAR_PURPLE_BIT(mValue);
+    NS_ASSERTION(IsPurple(), "must be purple");
+    nsrefcnt refcount = NS_CCAR_TAGGED_TO_PURPLE_ENTRY(mTagged)->mRefCnt;
+    mTagged = NS_CCAR_REFCNT_TO_TAGGED(refcount);
+  }
+
+  PRBool IsPurple() const
+  {
+    NS_ASSERTION(mTagged != NS_CCAR_TAGGED_STABILIZED_REFCNT,
+                 "should have checked for stabilization first");
+    return !(NS_PTR_TO_INT32(mTagged) & NS_CCAR_REFCNT_BIT);
   }
 
   nsrefcnt get() const
   {
-    if (NS_UNLIKELY(mValue == NS_PURPLE_BIT))
+    if (NS_UNLIKELY(mTagged == NS_CCAR_TAGGED_STABILIZED_REFCNT))
       return 1;
 
-    return NS_VALUE_WITHOUT_PURPLE_BIT(mValue);
+    return NS_UNLIKELY(IsPurple())
+             ? NS_CCAR_TAGGED_TO_PURPLE_ENTRY(mTagged)->mRefCnt
+             : NS_CCAR_TAGGED_TO_REFCNT(mTagged);
   }
 
   operator nsrefcnt() const
   {
     return get();
   }
 
  private:
-  nsrefcnt mValue;
+  void *mTagged;
 };
 
 class nsAutoRefCnt {
 
  public:
     nsAutoRefCnt() : mValue(0) {}
     nsAutoRefCnt(nsrefcnt aValue) : mValue(aValue) {}
 
diff --git a/xpcom/glue/standalone/nsXPCOMGlue.cpp b/xpcom/glue/standalone/nsXPCOMGlue.cpp
--- a/xpcom/glue/standalone/nsXPCOMGlue.cpp
+++ b/xpcom/glue/standalone/nsXPCOMGlue.cpp
@@ -544,24 +544,42 @@ NS_InvokeByIndex(nsISupports* that, PRUi
     if (!xpcomFunctions.invokeByIndexFunc)
         return NS_ERROR_NOT_INITIALIZED;
 
     return xpcomFunctions.invokeByIndexFunc(that, methodIndex,
                                             paramCount, params);
 }
 
 XPCOM_API(PRBool)
-NS_CycleCollectorSuspect(nsISupports* obj)
+NS_CycleCollectorSuspect(nsISupports *obj)
 {
     if (!xpcomFunctions.cycleSuspectFunc)
         return PR_FALSE;
 
     return xpcomFunctions.cycleSuspectFunc(obj);
 }
 
 XPCOM_API(PRBool)
-NS_CycleCollectorForget(nsISupports* obj)
+NS_CycleCollectorForget(nsISupports *obj)
 {
     if (!xpcomFunctions.cycleForgetFunc)
         return PR_FALSE;
 
     return xpcomFunctions.cycleForgetFunc(obj);
 }
+
+XPCOM_API(nsPurpleBufferEntry*)
+NS_CycleCollectorSuspect2(nsISupports *obj)
+{
+    if (!xpcomFunctions.cycleSuspect2Func)
+        return nsnull;
+
+    return xpcomFunctions.cycleSuspect2Func(obj);
+}
+
+XPCOM_API(PRBool)
+NS_CycleCollectorForget2(nsPurpleBufferEntry *e)
+{
+    if (!xpcomFunctions.cycleForget2Func)
+        return PR_FALSE;
+
+    return xpcomFunctions.cycleForget2Func(e);
+}
diff --git a/xpcom/stub/nsXPComStub.cpp b/xpcom/stub/nsXPComStub.cpp
--- a/xpcom/stub/nsXPComStub.cpp
+++ b/xpcom/stub/nsXPComStub.cpp
@@ -115,17 +115,21 @@ static const XPCOMFunctions kFrozenFunct
     &NS_GetXPTCallStub_P,
     &NS_DestroyXPTCallStub_P,
     &NS_InvokeByIndex_P,
     &NS_CycleCollectorSuspect_P,
     &NS_CycleCollectorForget_P,
     &NS_StringSetIsVoid_P,
     &NS_StringGetIsVoid_P,
     &NS_CStringSetIsVoid_P,
-    &NS_CStringGetIsVoid_P
+    &NS_CStringGetIsVoid_P,
+
+    // these functions were added post 1.9.1
+    &NS_CycleCollectorSuspect2_P,
+    &NS_CycleCollectorForget2_P
 };
 
 EXPORT_XPCOM_API(nsresult)
 NS_GetFrozenFunctions(XPCOMFunctions *functions, const char* /* libraryPath */)
 {
     if (!functions)
         return NS_ERROR_OUT_OF_MEMORY;
 
@@ -548,8 +552,22 @@ NS_CycleCollectorSuspect(nsISupports* ob
 }
 
 #undef NS_CycleCollectorForget
 EXPORT_XPCOM_API(PRBool)
 NS_CycleCollectorForget(nsISupports* obj)
 {
   return NS_CycleCollectorForget_P(obj);
 }
+
+#undef NS_CycleCollectorSuspect2
+EXPORT_XPCOM_API(nsPurpleBufferEntry*)
+NS_CycleCollectorSuspect2(nsISupports* obj)
+{
+  return NS_CycleCollectorSuspect2_P(obj);
+}
+
+#undef NS_CycleCollectorForget2
+EXPORT_XPCOM_API(PRBool)
+NS_CycleCollectorForget2(nsPurpleBufferEntry* e)
+{
+  return NS_CycleCollectorForget2_P(e);
+}
