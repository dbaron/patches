From: L. David Baron <dbaron@dbaron.org>

Implement cycle collector's purple buffer using a linked list rather than a hash table.  (Bug 490695)

diff --git a/xpcom/build/nsXPCOM.h b/xpcom/build/nsXPCOM.h
--- a/xpcom/build/nsXPCOM.h
+++ b/xpcom/build/nsXPCOM.h
@@ -455,21 +455,23 @@ NS_LogCOMPtrAddRef(void *aCOMPtr, nsISup
 XPCOM_API(void)
 NS_LogCOMPtrRelease(void *aCOMPtr, nsISupports *aObject);
 
 /**
  * The XPCOM cycle collector analyzes and breaks reference cycles between
  * participating XPCOM objects. All objects in the cycle must implement
  * nsCycleCollectionParticipant to break cycles correctly.
  */
-XPCOM_API(PRBool)
+struct nsPurpleBufferEntry;
+
+XPCOM_API(nsPurpleBufferEntry*)
 NS_CycleCollectorSuspect(nsISupports *n);
 
 XPCOM_API(PRBool)
-NS_CycleCollectorForget(nsISupports *n);
+NS_CycleCollectorForget(nsPurpleBufferEntry *e);
 
 /**
  * Categories (in the category manager service) used by XPCOM:
  */
 
 /**
  * A category which is read after component registration but before
  * the "xpcom-startup" notifications. Each category entry is treated
diff --git a/xpcom/glue/nsISupportsImpl.h b/xpcom/glue/nsISupportsImpl.h
--- a/xpcom/glue/nsISupportsImpl.h
+++ b/xpcom/glue/nsISupportsImpl.h
@@ -80,120 +80,156 @@ private:
 
 #else // !NS_DEBUG
 
 #define NS_DECL_OWNINGTHREAD            /* nothing */
 #define NS_ASSERT_OWNINGTHREAD(_class)  ((void)0)
 
 #endif // NS_DEBUG
 
-#define NS_PURPLE_BIT ((PRUint32)(1 << 31))
-
-#define NS_PURPLE_MASK (~NS_PURPLE_BIT)
-#define NS_PURPLE_BIT_SET(x) ((x) & (NS_PURPLE_BIT))
-#define NS_CLEAR_PURPLE_BIT(x) ((x) &= (NS_PURPLE_MASK))
-#define NS_VALUE_WITHOUT_PURPLE_BIT(x) ((x) & (NS_PURPLE_MASK))
-
+#define NS_CCAR_REFCNT_BIT 1
+#define NS_CCAR_REFCNT_TO_TAGGED(rc_) \
+  NS_INT32_TO_PTR((rc << 1) | NS_CCAR_REFCNT_BIT)
+#define NS_CCAR_PURPLE_ENTRY_TO_TAGGED(pe_) \
+  static_cast<void*>(pe_)
+#define NS_CCAR_TAGGED_TO_REFCNT(tagged_) \
+  nsrefcnt(NS_PTR_TO_INT32(tagged_) >> 1)
+#define NS_CCAR_TAGGED_TO_PURPLE_ENTRY(tagged_) \
+  static_cast<PurpleBufferEntry*>(tagged_)
+#define NS_CCAR_TAGGED_STABILIZED_REFCNT NS_PURPLE_ENTRY_TO_TAGGED(0)
 
 // Support for ISupports classes which interact with cycle collector.
 
+struct nsPurpleBufferEntry {
+  nsPurpleBufferEntry *mPrev, *mNext;
+  nsISupports *mObject;
+  // When an object is in the purple buffer, it replaces its reference
+  // count with a (tagged) pointer to this entry, so we store the
+  // reference count for it.
+  nsrefcnt mRefCnt;
+};
+
 class nsCycleCollectingAutoRefCnt {
 
 public:
   nsCycleCollectingAutoRefCnt()
-    : mValue(0)
+    : mTagged(NS_CCAR_REFCNT_TO_TAGGED(0))
   {}
 
   nsCycleCollectingAutoRefCnt(nsrefcnt aValue)
-    : mValue(aValue)
+    : mTagged(NS_CCAR_REFCNT_TO_TAGGED(aValue))
   {
-    NS_CLEAR_PURPLE_BIT(mValue);
   }
 
   nsrefcnt incr(nsISupports *owner)
   {
-    if (NS_UNLIKELY(mValue == NS_PURPLE_BIT)) {
+    if (NS_UNLIKELY(mTagged == NS_CCAR_TAGGED_STABILIZED_REFCNT)) {
       // The sentinel value "purple bit alone, refcount 0" means
       // that we're stabilized, during finalization. In this
       // state we lie about our actual refcount if anyone asks
       // and say it's 2, which is basically true: the caller who
       // is incrementing has a reference, as does the decr() frame
       // that stabilized-and-is-deleting us.
       return 2;
     }
 
-    nsrefcnt tmp = get();
-    PRBool purple = static_cast<PRBool>(NS_PURPLE_BIT_SET(mValue));
+    nsrefcnt refcount;
+    if (IsPurple()) {
+      nsPurpleBufferEntry *e = NS_CCAR_TAGGED_TO_ENTRY(mTagged);
+      refcount = e->mRefCnt;
+      NS_ASSERTION(tmp != 0, "purple ISupports pointer with zero refcnt");
 
-    if (NS_UNLIKELY(purple)) {
-      NS_ASSERTION(tmp != 0, "purple ISupports pointer with zero refcnt");
-      if (!NS_CycleCollectorForget(owner))
-        tmp |= NS_PURPLE_BIT;
+      if (NS_LIKELY(NS_CycleCollectorForget(e))) {
+        // |e| is now invalid
+        ++refcount;
+        mTagged = NS_CCAR_REFCNT_TO_TAGGED(refcount);
+      } else {
+        ++refcount;
+        e->mRefCnt = refcount;
+      }
+    } else {
+      refcount = NS_CCAR_TAGGED_TO_REFCNT(mTagged);
+      ++refcount;
+      mTagged = NS_CCAR_REFCNT_TO_TAGGED(refcount);
     }
 
-    mValue = tmp + 1;
-    return mValue;
+    return refcount;
   }
 
   void stabilizeForDeletion(nsISupports *owner)
   {
-    mValue = NS_PURPLE_BIT;
+    mValue = NS_CCAR_TAGGED_STABILIZED_REFCNT;
   }
 
   nsrefcnt decr(nsISupports *owner)
   {
-    if (NS_UNLIKELY(mValue == NS_PURPLE_BIT))
+    if (NS_UNLIKELY(mTagged == NS_CCAR_TAGGED_STABILIZED_REFCNT))
       return 1;
 
-    nsrefcnt tmp = get();
-    NS_ASSERTION(tmp >= 1, "decr() called with zero refcnt");
+    nsrefcnt refcount;
+    if (IsPurple()) {
+      nsPurpleBufferEntry *e = NS_CCAR_TAGGED_TO_ENTRY(mTagged);
+      refcount = e->mRefCnt;
+      --refcount;
+      
+      if (NS_UNLIKELY(refcount == 0)) {
+        if (NS_UNLIKELY(!NS_CycleCollectorForget(e))) {
+          NS_NOTREACHED("forget should not fail when reference count hits 0");
+        }
+        mTagged = NS_CCAR_REFCNT_TO_TAGGED(refcount);
+      } else {
+        e->mRefCnt = refcount;
+      }
+    } else {
+      refcount = NS_CCAR_TAGGED_TO_REFCNT(mTagged);
+      --refcount;
 
-    PRBool purple = static_cast<PRBool>(NS_PURPLE_BIT_SET(mValue));
-    PRBool shouldBePurple = tmp > 1;
-
-    if (NS_UNLIKELY(shouldBePurple && !purple)) {
-      if (!NS_CycleCollectorSuspect(owner))
-        shouldBePurple = PR_FALSE;
-    } else if (NS_UNLIKELY(tmp == 1 && purple)) {
-      if (!NS_CycleCollectorForget(owner)) {
-        NS_NOTREACHED("forget should not fail when reference count hits 0");
+      nsPurpleBufferEntry *e;
+      if (NS_LIKELY(refcount > 0) &&
+          ((e = NS_CycleCollectorSuspect(owner)))) {
+        e->mRefCnt = refcount;
+        mTagged = NS_CCAR_ENTRY_TO_TAGGED(e);
+      } else {
+        mTagged = NS_CCAR_REFCNT_TO_TAGGED(refcount);
       }
     }
 
-    --tmp;
-
-    if (shouldBePurple)
-      mValue = tmp | NS_PURPLE_BIT;
-    else
-      mValue = tmp;
-
-    return tmp;
+    return refcount;
   }
 
   void unmarkPurple()
   {
     if (NS_LIKELY(mValue != NS_PURPLE_BIT))
       NS_CLEAR_PURPLE_BIT(mValue);
   }
 
+  PRBool IsPurple() const
+  {
+    NS_ASSERTION(mTagged != NS_CCAR_TAGGED_STABILIZED_REFCNT,
+                 "should have checked for stabilization first");
+    return !(mTagged & NS_CCAR_REFCNT_BIT);
+  }
+
   nsrefcnt get() const
   {
-    if (NS_UNLIKELY(mValue == NS_PURPLE_BIT))
+    if (NS_UNLIKELY(mTagged == NS_TAGGED_STABILIZED_REFCNT))
       return 1;
 
-    return NS_VALUE_WITHOUT_PURPLE_BIT(mValue);
+    return NS_UNLIKELY(IsPurple())
+             ? NS_CCAR_TAGGED_TO_PURPLE_ENTRY(mTagged)->mRefCnt
+             : NS_CCAR_TAGGED_TO_REFCNT(mTagged);
   }
 
   operator nsrefcnt() const
   {
     return get();
   }
 
  private:
-  nsrefcnt mValue;
+  void *mTagged;
 };
 
 class nsAutoRefCnt {
 
  public:
     nsAutoRefCnt() : mValue(0) {}
     nsAutoRefCnt(nsrefcnt aValue) : mValue(aValue) {}
 
