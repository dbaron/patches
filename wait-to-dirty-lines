From: L. David Baron <dbaron@dbaron.org>

Bug 828312 patch 3:  Wait to mark lines dirty until we're in reflow, to avoid O(N^2) behavior as a result of looking for lines.  r=bzbarsky

TODO: This causes various layout problems on facebook, flickr, etc.
(It's fine without the changes to nsBlockFrame::ChildIsDirty.)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1061,18 +1061,34 @@ nsBlockFrame::Reflow(nsPresContext*     
   nsOverflowAreas fcBounds;
   nsReflowStatus fcStatus = NS_FRAME_COMPLETE;
   rv = ReflowPushedFloats(state, fcBounds, fcStatus);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // If we're not dirty (which means we'll mark everything dirty later)
   // and our width has changed, mark the lines dirty that we need to
   // mark dirty for a resize reflow.
-  if (reflowState->mFlags.mHResize)
-    PrepareResizeReflow(state);
+  bool allLinesDirty = GetStateBits() & NS_FRAME_IS_DIRTY;
+  if (!allLinesDirty && reflowState->mFlags.mHResize)
+    allLinesDirty = PrepareResizeReflow(state);
+
+  if (!allLinesDirty && (GetStateBits() & NS_BLOCK_LOOK_FOR_DIRTY_FRAMES)) {
+    for (line_iterator line = begin_lines(), line_end = end_lines();
+         line != line_end; ++line) {
+      int32_t n = line->GetChildCount();
+      for (nsIFrame* lineFrame = line->mFirstChild;
+           n > 0; lineFrame = lineFrame->GetNextSibling(), --n) {
+        if (NS_SUBTREE_DIRTY(lineFrame)) {
+          MarkLineDirty(line, &mLines);
+          break;
+        }
+      }
+    }
+  }
+  RemoveStateBits(NS_BLOCK_LOOK_FOR_DIRTY_FRAMES);
 
   mState &= ~NS_FRAME_FIRST_REFLOW;
 
   // Now reflow...
   rv = ReflowDirtyLines(state);
 
   // If we have a next-in-flow, and that next-in-flow has pushed floats from
   // this frame from a previous iteration of reflow, then we should not return
@@ -6531,24 +6547,23 @@ nsBlockFrame::ChildIsDirty(nsIFrame* aCh
     }
     
     if (bulletLine != end_lines()) {
       MarkLineDirty(bulletLine, &mLines);
     }
     // otherwise we have an empty line list, and ReflowDirtyLines
     // will handle reflowing the bullet.
   } else {
-    // Mark the line containing the child frame dirty. We would rather do this
-    // in MarkIntrinsicWidthsDirty but that currently won't tell us which
-    // child is being dirtied.
-    bool isValid;
-    nsBlockInFlowLineIterator iter(this, aChild, &isValid);
-    if (isValid) {
-      iter.GetContainer()->MarkLineDirty(iter.GetLine(), iter.GetLineList());
-    }
+    // Note that we should go through our children to mark lines dirty
+    // before the next reflow.  Doing it now could make things O(N^2)
+    // since finding the right line is O(N).
+    // We don't need to worry about marking lines on the overflow list
+    // as dirty; we're guaranteed to reflow them if we take them off the
+    // overflow list.
+    AddStateBits(NS_BLOCK_LOOK_FOR_DIRTY_FRAMES);
   }
 
   nsBlockFrameSuper::ChildIsDirty(aChild);
 }
 
 void
 nsBlockFrame::Init(nsIContent*      aContent,
                    nsIFrame*        aParent,
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -85,16 +85,21 @@ class nsIntervalSet;
 #define NS_BLOCK_HAS_OVERFLOW_LINES         NS_FRAME_STATE_BIT(25)
 #define NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS  NS_FRAME_STATE_BIT(26)
 
 // Set on any block that has descendant frames in the normal
 // flow with 'clear' set to something other than 'none'
 // (including <BR CLEAR="..."> frames)
 #define NS_BLOCK_HAS_CLEAR_CHILDREN         NS_FRAME_STATE_BIT(27)
 
+// This block has had a child marked dirty, so before we reflow we need
+// to look through the lines to find any such children and mark
+// appropriate lines dirty.
+#define NS_BLOCK_LOOK_FOR_DIRTY_FRAMES      NS_FRAME_STATE_BIT(61)
+
 // Are our cached intrinsic widths intrinsic widths for font size
 // inflation?  i.e., what was the current state of
 // GetPresContext()->mInflationDisabledForShrinkWrap at the time they
 // were computed?
 // nsBlockFrame is the only thing that caches intrinsic widths that
 // needs to track this because it's the only thing that caches intrinsic
 // widths that lives inside of things (form controls) that do intrinsic
 // sizing with font inflation enabled.
