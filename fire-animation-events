From: L. David Baron <dbaron@dbaron.org>

Fire animation events at the correct times.  (Bug 435442, patch 13)

diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -39,16 +39,18 @@
 #include "nsAnimationManager.h"
 #include "nsPresContext.h"
 #include "nsRuleProcessorData.h"
 #include "nsStyleSet.h"
 #include "nsCSSRules.h"
 #include "mozilla/TimeStamp.h"
 #include "nsStyleAnimation.h"
 #include "nsSMILKeySpline.h"
+#include "nsGUIEvent.h"
+#include "nsEventDispatcher.h"
 
 using namespace mozilla;
 
 struct AnimationSegmentProperty
 {
   nsCSSProperty mProperty;
   nsStyleAnimation::Value mFromValue, mToValue;
 };
@@ -61,16 +63,21 @@ struct AnimationSegment
 };
 
 /**
  * Data about one animation (i.e., one of the values of
  * 'animation-name') animation running on an element.
  */
 struct ElementAnimation
 {
+  ElementAnimation()
+    : mLastNotification(LAST_NOTIFICATION_NONE)
+  {
+  }
+
   nsString mName; // empty string for 'none'
   float mIterationCount; // NS_IEEEPositiveInfinity() means infinite
   PRUint8 mDirection;
   PRUint8 mFillMode;
   PRUint8 mPlayState;
 
   bool FillsForwards() const {
     return mFillMode == NS_STYLE_ANIMATION_FILL_MODE_BOTH ||
@@ -84,38 +91,72 @@ struct ElementAnimation
   bool IsPaused() const {
     return mPlayState == NS_STYLE_ANIMATION_PLAY_STATE_PAUSED;
   }
 
   TimeStamp mStartTime; // with delay taken into account
   TimeStamp mPauseStart;
   TimeDuration mIterationDuration;
 
+  enum {
+    LAST_NOTIFICATION_NONE = PRUint32(-1),
+    LAST_NOTIFICATION_END = PRUint32(-2)
+  };
+  // One of the above constants, or an integer for the iteration
+  // whose start we last notified on.
+  PRUint32 mLastNotification;
+
   InfallibleTArray<AnimationSegment> mSegments;
 };
 
+struct AnimationEventInfo {
+  nsCOMPtr<dom::Element> mElement;
+  nsAnimationEvent mEvent;
+
+  AnimationEventInfo(dom::Element *aElement, const nsString& aAnimationName,
+                     PRUint32 aMessage, TimeDuration aElapsedTime)
+    : mElement(aElement),
+      mEvent(PR_TRUE, aMessage, aAnimationName, aElapsedTime.ToSeconds())
+  {
+  }
+
+  // nsAnimationEvent doesn't support copy-construction, so we need
+  // to ourselves in order to work with nsTArray
+  AnimationEventInfo(const AnimationEventInfo &aOther)
+    : mElement(aOther.mElement),
+      mEvent(PR_TRUE, aOther.mEvent.message,
+             aOther.mEvent.animationName, aOther.mEvent.elapsedTime)
+  {
+  }
+};
+
+typedef nsAnimationManager::EventArray EventArray;
+
 /**
  * Data about all of the animations running on an element.
  */
 struct ElementAnimations : public mozilla::css::CommonElementAnimationData
 {
   ElementAnimations(dom::Element *aElement, nsIAtom *aElementProperty,
                      nsAnimationManager *aAnimationManager)
     : CommonElementAnimationData(aElement, aElementProperty,
                                  aAnimationManager),
       mNeedsRefreshes(true)
   {
   }
 
-  void EnsureStyleRuleFor(TimeStamp aRefreshTime);
+  void EnsureStyleRuleFor(TimeStamp aRefreshTime,
+                          EventArray &aEventsToDispatch);
+
+  bool IsForElement() const { // rather than for a pseudo-element
+    return mElementProperty == nsGkAtoms::animationsProperty;
+  }
 
   void PostRestyleForAnimation(nsPresContext *aPresContext) {
-    nsRestyleHint hint =
-      (mElementProperty == nsGkAtoms::animationsProperty)
-        ? eRestyle_Self : eRestyle_Subtree;
+    nsRestyleHint hint = IsForElement() ? eRestyle_Self : eRestyle_Subtree;
     aPresContext->PresShell()->RestyleForAnimation(mElement, hint);
   }
 
   // This style rule contains the style data for currently animating
   // values.  It only matches when styling with animation.  When we
   // style without animation, we need to not use it so that we can
   // detect any new changes; if necessary we restyle immediately
   // afterwards with animation.
@@ -139,17 +180,18 @@ ElementAnimationsPropertyDtor(void      
                               void           *aPropertyValue,
                               void           *aData)
 {
   ElementAnimations *ea = static_cast<ElementAnimations*>(aPropertyValue);
   delete ea;
 }
 
 void
-ElementAnimations::EnsureStyleRuleFor(TimeStamp aRefreshTime)
+ElementAnimations::EnsureStyleRuleFor(TimeStamp aRefreshTime,
+                                      EventArray& aEventsToDispatch)
 {
   if (!mNeedsRefreshes) {
     // All of our animations are paused or completed.
     mStyleRuleRefreshTime = aRefreshTime;
     return;
   }
 
   mNeedsRefreshes = false;
@@ -162,17 +204,17 @@ ElementAnimations::EnsureStyleRuleFor(Ti
 
     // FIXME(spec): assume that properties in higher animations override
     // those in lower ones (and that our |HasProperty| check in
     // |BuildSegment| matches the definition of when they should do so.
     // Therefore, we iterate from last animation to first.
     nsCSSPropertySet properties;
 
     for (PRUint32 i = mAnimations.Length(); i-- != 0; ) {
-      const ElementAnimation &anim = mAnimations[i];
+      ElementAnimation &anim = mAnimations[i];
 
       if (anim.mSegments.Length() == 0 ||
           anim.mIterationDuration.ToMilliseconds() <= 0.0) {
         // No animation data.
         continue;
       }
 
       TimeDuration currentTimeDuration;
@@ -182,32 +224,45 @@ ElementAnimations::EnsureStyleRuleFor(Ti
       } else {
         currentTimeDuration = aRefreshTime - anim.mStartTime;
       }
 
       // Set |currentIterationCount| to the (fractional) number of
       // iterations we've completed up to the current position.
       double currentIterationCount =
         currentTimeDuration / anim.mIterationDuration;
+      bool dispatchStartOrIteration = false;
       if (currentIterationCount > double(anim.mIterationCount)) {
+        // Dispatch 'animationend' when needed.
+        if (IsForElement() && 
+            anim.mLastNotification !=
+              ElementAnimation::LAST_NOTIFICATION_END) {
+          anim.mLastNotification = ElementAnimation::LAST_NOTIFICATION_END;
+          AnimationEventInfo ei(mElement, anim.mName, NS_ANIMATION_END,
+                                currentTimeDuration);
+          aEventsToDispatch.AppendElement(ei);
+        }
+
         if (!anim.FillsForwards()) {
           // No animation data.
           continue;
         }
         currentIterationCount = double(anim.mIterationCount);
       } else {
         if (!anim.IsPaused()) {
           mNeedsRefreshes = true;
         }
         if (currentIterationCount < 0.0) {
           if (!anim.FillsBackwards()) {
             // No animation data.
             continue;
           }
           currentIterationCount = 0.0;
+        } else {
+          dispatchStartOrIteration = !anim.IsPaused();
         }
       }
 
       // Set |positionInIteration| to the position from 0% to 100% along
       // the keyframes.
       NS_ABORT_IF_FALSE(currentIterationCount >= 0.0, "must be positive");
       PRUint32 whichIteration = int(currentIterationCount);
       if (whichIteration == anim.mIterationCount) {
@@ -218,16 +273,34 @@ ElementAnimations::EnsureStyleRuleFor(Ti
       }
       double positionInIteration =
         currentIterationCount - double(whichIteration);
       if (anim.mDirection == NS_STYLE_ANIMATION_DIRECTION_ALTERNATE &&
           (whichIteration & 1) == 1) {
         positionInIteration = 1.0 - positionInIteration;
       }
 
+      // Dispatch 'animationstart' or 'animationiteration' when needed.
+      if (IsForElement() && dispatchStartOrIteration &&
+          whichIteration != anim.mLastNotification) {
+        // Notify 'animationstart' even if a negative delay puts us
+        // past the first iteration.
+        // Note that when somebody changes the animation-duration
+        // dynamically, this will fire an extra iteration event
+        // immediately in many cases.  It's not clear to me if that's the
+        // right thing to do.
+        PRUint32 message =
+          anim.mLastNotification == ElementAnimation::LAST_NOTIFICATION_NONE
+            ? NS_ANIMATION_START : NS_ANIMATION_ITERATION;
+        anim.mLastNotification = whichIteration;
+        AnimationEventInfo ei(mElement, anim.mName, message,
+                              currentTimeDuration);
+        aEventsToDispatch.AppendElement(ei);
+      }
+
       NS_ABORT_IF_FALSE(0.0 <= positionInIteration &&
                           positionInIteration <= 1.0,
                         "position should be in [0-1]");
 
       NS_ABORT_IF_FALSE(anim.mSegments[0].mFromKey == 0.0,
                         "incorrect first from key");
       NS_ABORT_IF_FALSE(anim.mSegments[anim.mSegments.Length() - 1].mToKey
                           == 1.0,
@@ -445,16 +518,17 @@ nsAnimationManager::CheckAnimationRule(n
               break;
             }
           }
           if (!oldAnim) {
             continue;
           }
 
           newAnim->mStartTime = oldAnim->mStartTime;
+          newAnim->mLastNotification = oldAnim->mLastNotification;
 
           if (oldAnim->IsPaused()) {
             if (newAnim->IsPaused()) {
               // Copy pause start just like start time.
               newAnim->mPauseStart = oldAnim->mPauseStart;
             } else {
               // Handle change in pause state by adjusting start
               // time to unpause.
@@ -465,17 +539,19 @@ nsAnimationManager::CheckAnimationRule(n
       }
     } else {
       ea = GetElementAnimations(aElement, aStyleContext->GetPseudoType(),
                                 PR_TRUE);
     }
     ea->mAnimations.SwapElements(newAnimations);
     ea->mNeedsRefreshes = true;
 
-    ea->EnsureStyleRuleFor(refreshTime);
+    EventArray eventsToDispatch;
+    ea->EnsureStyleRuleFor(refreshTime, eventsToDispatch);
+    // FIXME: Dispatch!  (WHEN?)
   }
 
   return GetAnimationRule(aElement, aStyleContext->GetPseudoType());
 }
 
 class PercentageHashKey : public PLDHashEntryHdr
 {
 public:
@@ -775,25 +851,42 @@ nsAnimationManager::WillRefresh(mozilla:
     // triggering refreshes.
     RemoveAllElementData();
     return;
   }
 
   // FIXME: check that there's at least one style rule that's not
   // in its "done" state, and if there isn't, remove ourselves from
   // the refresh driver (but leave the animations!).
+  EventArray eventsToDispatch;
   for (PRCList *l = PR_LIST_HEAD(&mElementData); l != &mElementData;
        l = PR_NEXT_LINK(l)) {
     ElementAnimations *ea = static_cast<ElementAnimations*>(l);
     nsRefPtr<css::AnimValuesStyleRule> oldStyleRule = ea->mStyleRule;
-    ea->EnsureStyleRuleFor(mPresContext->RefreshDriver()->MostRecentRefresh());
+    ea->EnsureStyleRuleFor(mPresContext->RefreshDriver()->MostRecentRefresh(),
+                           eventsToDispatch);
     if (oldStyleRule != ea->mStyleRule) {
       ea->PostRestyleForAnimation(mPresContext);
     }
   }
+
+  DispatchEvents(eventsToDispatch);
+}
+
+void
+nsAnimationManager::DispatchEvents(EventArray& aEvents)
+{
+  for (PRUint32 i = 0, i_end = aEvents.Length(); i < i_end; ++i) {
+    AnimationEventInfo &info = aEvents[i];
+    nsEventDispatcher::Dispatch(info.mElement, mPresContext, &info.mEvent);
+
+    if (!mPresContext) {
+      break;
+    }
+  }
 }
 
 nsCSSKeyframesRule*
 nsAnimationManager::KeyframesRuleFor(const nsSubstring& aName)
 {
   if (mKeyframesListIsDirty) {
     mKeyframesListIsDirty = false;
 
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -42,16 +42,17 @@
 #include "nsCSSPseudoElements.h"
 #include "nsStyleContext.h"
 #include "nsTHashtable.h"
 
 class nsCSSKeyframesRule;
 struct AnimationSegment;
 struct ElementAnimation;
 struct ElementAnimations;
+struct AnimationEventInfo;
 
 namespace mozilla {
 namespace css {
 class Declaration;
 }
 }
 
 class nsAnimationManager : public mozilla::css::CommonAnimationManager
@@ -88,31 +89,34 @@ public:
    */
   nsIStyleRule* CheckAnimationRule(nsStyleContext* aStyleContext,
                                    mozilla::dom::Element* aElement);
 
   void KeyframesListIsDirty() {
     mKeyframesListIsDirty = PR_TRUE;
   }
 
+  typedef InfallibleTArray<AnimationEventInfo> EventArray;
+
 private:
   ElementAnimations* GetElementAnimations(mozilla::dom::Element *aElement,
                                           nsCSSPseudoElements::Type aPseudoType,
                                           PRBool aCreateIfNeeded);
   void BuildAnimations(nsStyleContext* aStyleContext,
                        InfallibleTArray<ElementAnimation>& aAnimations);
   void BuildSegment(nsTArray<AnimationSegment,
                              nsTArrayInfallibleAllocator>& aSegments,
                     const nsAnimation& aAnimation,
                     float aFromKey, nsStyleContext* aFromContext,
                     mozilla::css::Declaration* aFromDeclaration,
                     float aToKey, nsStyleContext* aToContext,
                     mozilla::css::Declaration* aToDeclaration);
   nsIStyleRule* GetAnimationRule(mozilla::dom::Element* aElement,
                                  nsCSSPseudoElements::Type aPseudoType);
+  void DispatchEvents(EventArray& aEvents);
 
   nsCSSKeyframesRule* KeyframesRuleFor(const nsSubstring& aName);
 
   bool mKeyframesListIsDirty;
   nsDataHashtable<nsStringHashKey, nsCSSKeyframesRule*> mKeyframesRules;
 };
 
 #endif /* !defined(nsAnimationManager_h_) */
