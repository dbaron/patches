From: L. David Baron <dbaron@dbaron.org>

Start drags for GTK toolbars that are unified with the titlebar based on the dragstart event rather than the mousedown event.  (Bug 635397)

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -10087,17 +10087,18 @@ nsGlobalChromeWindow::BeginWindowMove(ns
   if (!widget) {
     return NS_OK;
   }
 
   nsCOMPtr<nsIPrivateDOMEvent> privEvent = do_QueryInterface(aMouseDownEvent);
   NS_ENSURE_TRUE(privEvent, NS_ERROR_FAILURE);
   nsEvent *internalEvent = privEvent->GetInternalNSEvent();
   NS_ENSURE_TRUE(internalEvent &&
-                 internalEvent->eventStructType == NS_MOUSE_EVENT,
+                 (internalEvent->eventStructType == NS_MOUSE_EVENT ||
+                  internalEvent->eventStructType == NS_DRAG_EVENT),
                  NS_ERROR_FAILURE);
   nsMouseEvent *mouseEvent = static_cast<nsMouseEvent*>(internalEvent);
 
   return widget->BeginMoveDrag(mouseEvent);
 }
 
 //Note: This call will lock the cursor, it will not change as it moves.
 //To unlock, the cursor must be set back to CURSOR_AUTO.
diff --git a/dom/interfaces/base/nsIDOMChromeWindow.idl b/dom/interfaces/base/nsIDOMChromeWindow.idl
--- a/dom/interfaces/base/nsIDOMChromeWindow.idl
+++ b/dom/interfaces/base/nsIDOMChromeWindow.idl
@@ -79,13 +79,17 @@ interface nsIDOMChromeWindow : nsISuppor
   readonly attribute nsIChromeFrameMessageManager messageManager;
 
   /**
    * On some operating systems, we must allow the window manager to
    * handle window dragging. This function tells the window manager to
    * start dragging the window. This function will fail unless called
    * while the left mouse button is held down, callers must check this.
    *
+   * The |mouseDownEvent| should be a mousedown or (preferably)
+   * dragstart or draggesture event whose coordinates represent the
+   * beginning of the drag motion.
+   *
    * Returns NS_ERROR_NOT_IMPLEMENTED (and thus throws in JS) if the OS
    * doesn't support this.
    */
   void beginWindowMove(in nsIDOMEvent mouseDownEvent);
 };
diff --git a/toolkit/content/WindowDraggingUtils.jsm b/toolkit/content/WindowDraggingUtils.jsm
--- a/toolkit/content/WindowDraggingUtils.jsm
+++ b/toolkit/content/WindowDraggingUtils.jsm
@@ -37,18 +37,22 @@
 let EXPORTED_SYMBOLS = [ "WindowDraggingElement" ];
 
 function WindowDraggingElement(elem, window) {
   this._elem = elem;
   this._window = window;
 #ifdef XP_WIN
   this._elem.addEventListener("MozMouseHittest", this, false);
 #else
+#ifdef MOZ_WIDGET_GTK2
+  this._elem.addEventListener("draggesture", this, false);
+#else
   this._elem.addEventListener("mousedown", this, false);
 #endif
+#endif
 }
 
 WindowDraggingElement.prototype = {
   mouseDownCheck: function(e) { return true; },
   dragTags: ["box", "hbox", "vbox", "spacer", "label", "statusbarpanel", "stack",
              "toolbaritem", "toolbarseparator", "toolbarspring", "toolbarspacer",
              "radiogroup", "deck", "scrollbox", "arrowscrollbox", "tabs"],
   shouldDrag: function(aEvent) {
@@ -79,40 +83,41 @@ WindowDraggingElement.prototype = {
     }
     return true;
   },
   handleEvent: function(aEvent) {
 #ifdef XP_WIN
     if (this.shouldDrag(aEvent))
       aEvent.preventDefault();
 #else
+#ifdef MOZ_WIDGET_GTK2
+    // On GTK, there is a toolkit-level function which handles
+    // window dragging, which must be used.
+    if (this.shouldDrag(aEvent))
+      this._window.beginWindowMove(aEvent);
+#else
     switch (aEvent.type) {
       case "mousedown":
         if (!this.shouldDrag(aEvent))
           return;
 
-#ifdef MOZ_WIDGET_GTK2
-        // On GTK, there is a toolkit-level function which handles
-        // window dragging, which must be used.
-        this._window.beginWindowMove(aEvent);
-#else
         this._deltaX = aEvent.screenX - this._window.screenX;
         this._deltaY = aEvent.screenY - this._window.screenY;
         this._draggingWindow = true;
         this._window.addEventListener("mousemove", this, false);
         this._window.addEventListener("mouseup", this, false);
-#endif
         break;
       case "mousemove":
         if (this._draggingWindow)
           this._window.moveTo(aEvent.screenX - this._deltaX, aEvent.screenY - this._deltaY);
         break;
       case "mouseup":
         if (this._draggingWindow) {
           this._draggingWindow = false;
           this._window.removeEventListener("mousemove", this, false);
           this._window.removeEventListener("mouseup", this, false);
         }
         break;
     }
 #endif
+#endif
   }
 }
diff --git a/widget/src/gtk2/nsWindow.cpp b/widget/src/gtk2/nsWindow.cpp
--- a/widget/src/gtk2/nsWindow.cpp
+++ b/widget/src/gtk2/nsWindow.cpp
@@ -6583,17 +6583,18 @@ nsWindow::GetDragInfo(nsMouseEvent* aMou
 
     return PR_TRUE;
 }
 
 NS_IMETHODIMP
 nsWindow::BeginMoveDrag(nsMouseEvent* aEvent)
 {
     NS_ABORT_IF_FALSE(aEvent, "must have event");
-    NS_ABORT_IF_FALSE(aEvent->eventStructType == NS_MOUSE_EVENT,
+    NS_ABORT_IF_FALSE(aEvent->eventStructType == NS_MOUSE_EVENT ||
+                      aEvent->eventStructType == NS_DRAG_EVENT,
                       "event must have correct struct type");
 
     GdkWindow *gdk_window;
     gint button, screenX, screenY;
     if (!GetDragInfo(aEvent, &gdk_window, &button, &screenX, &screenY)) {
         return NS_ERROR_FAILURE;
     }
 
