From: L. David Baron <dbaron@dbaron.org>

Allow use of GLX 1.2 when setting up GL for WebGL.

diff --git a/gfx/thebes/GLContextProviderGLX.cpp b/gfx/thebes/GLContextProviderGLX.cpp
--- a/gfx/thebes/GLContextProviderGLX.cpp
+++ b/gfx/thebes/GLContextProviderGLX.cpp
@@ -82,36 +82,38 @@ GLXLibrary::EnsureInitialized()
 
     LibrarySymbolLoader::SymLoadStruct symbols[] = {
         { (PRFuncPtr*) &xDeleteContext, { "glXDestroyContext", NULL } },
         { (PRFuncPtr*) &xMakeCurrent, { "glXMakeCurrent", NULL } },
         { (PRFuncPtr*) &xGetProcAddress, { "glXGetProcAddress", NULL } },
         { (PRFuncPtr*) &xChooseVisual, { "glXChooseVisual", NULL } },
         { (PRFuncPtr*) &xChooseFBConfig, { "glXChooseFBConfig", NULL } },
         { (PRFuncPtr*) &xGetFBConfigs, { "glXGetFBConfigs", NULL } },
+        { (PRFuncPtr*) &xCreateNewContext, { "glXCreateNewContext", NULL } },
+        { (PRFuncPtr*) &xSwapBuffers, { "glXSwapBuffers", NULL } },
+        { (PRFuncPtr*) &xQueryServerString, { "glXQueryServerString", NULL } },
+        { (PRFuncPtr*) &xGetClientString, { "glXGetClientString", NULL } },
+        { (PRFuncPtr*) &xCreateContext, { "glXCreateContext", NULL } },
+        { (PRFuncPtr*) &xGetCurrentContext, { "glXGetCurrentContext", NULL } },
+        { (PRFuncPtr*) &xCreateGLXPixmap, { "glXCreateGLXPixmap", NULL } },
+        { (PRFuncPtr*) &xDestroyGLXPixmap, { "glXDestroyGLXPixmap", NULL } },
+        { NULL, { NULL } }
+    };
+
+    // Symbols for functions that are new in GLX 1.3.
+    LibrarySymbolLoader::SymLoadStruct symbols13[] = {
         { (PRFuncPtr*) &xCreatePbuffer, { "glXCreatePbuffer", NULL } },
-        { (PRFuncPtr*) &xCreateNewContext, { "glXCreateNewContext", NULL } },
         { (PRFuncPtr*) &xDestroyPbuffer, { "glXDestroyPbuffer", NULL } },
         { (PRFuncPtr*) &xGetVisualFromFBConfig, { "glXGetVisualFromFBConfig", NULL } },
         { (PRFuncPtr*) &xGetFBConfigAttrib, { "glXGetFBConfigAttrib", NULL } },
-        { (PRFuncPtr*) &xSwapBuffers, { "glXSwapBuffers", NULL } },
-        { (PRFuncPtr*) &xQueryServerString, { "glXQueryServerString", NULL } },
         { (PRFuncPtr*) &xCreatePixmap, { "glXCreatePixmap", NULL } },
         { (PRFuncPtr*) &xDestroyPixmap, { "glXDestroyPixmap", NULL } },
-        { (PRFuncPtr*) &xGetClientString, { "glXGetClientString", NULL } },
-        { (PRFuncPtr*) &xCreateContext, { "glXCreateContext", NULL } },
-        { (PRFuncPtr*) &xGetCurrentContext, { "glXGetCurrentContext", NULL } },
         { NULL, { NULL } }
     };
 
-    if (!LibrarySymbolLoader::LoadSymbols(mOGLLibrary, &symbols[0])) {
-        NS_WARNING("Couldn't find required entry point in OpenGL shared library");
-        return PR_FALSE;
-    }
-
     const char *vendor = xQueryServerString(DefaultXDisplay(),
                                             DefaultScreen(DefaultXDisplay()),
                                             GLX_VENDOR);
     const char *serverVersionStr = xQueryServerString(DefaultXDisplay(),
                                                       DefaultScreen(DefaultXDisplay()),
                                                       GLX_VERSION);
     const char *clientVersionStr = xGetClientString(DefaultXDisplay(),
                                                     GLX_VERSION);
@@ -131,18 +133,22 @@ GLXLibrary::EnsureInitialized()
         strlen(clientVersionStr) >= 3 &&
         clientVersionStr[1] == '.')
     {
         clientVersion = (clientVersionStr[0] - '0') << 8 | (clientVersionStr[2] - '0');
     }
 
     gGLXVersion = PR_MIN(clientVersion, serverVersion);
 
-    if (gGLXVersion < 0x0103)
+    if (!LibrarySymbolLoader::LoadSymbols(mOGLLibrary, &symbols[0]) ||
+        (gGLXVersion >= 0x0103 &&
+         !LibrarySymbolLoader::LoadSymbols(mOGLLibrary, &symbols[0]))) {
+        NS_WARNING("Couldn't find required entry point in OpenGL shared library");
         return PR_FALSE;
+    }
 
     gIsATI = vendor && DoesVendorStringMatch(vendor, "ATI");
     gIsChromium = (vendor && DoesVendorStringMatch(vendor, "Chromium")) ||
         (serverVersion && DoesVendorStringMatch(serverVersionStr, "Chromium"));
 
     mInitialized = PR_TRUE;
     return PR_TRUE;
 }
@@ -427,16 +433,21 @@ AreCompatibleVisuals(XVisualInfo *one, X
 
 already_AddRefed<GLContext>
 GLContextProviderGLX::CreateForWindow(nsIWidget *aWidget)
 {
     if (!sGLXLibrary.EnsureInitialized()) {
         return nsnull;
     }
 
+    if (gGLXVersion < 0x0103) {
+        // This might be implementable, but it isn't now.
+        return nsnull;
+    }
+
     // Currently, we take whatever Visual the window already has, and
     // try to create an fbconfig for that visual.  This isn't
     // necessarily what we want in the long run; an fbconfig may not
     // be available for the existing visual, or if it is, the GL
     // performance might be suboptimal.  But using the existing visual
     // is a relatively safe intermediate step.
 
     Display *display = (Display*)aWidget->GetNativeData(NS_NATIVE_DISPLAY); 
@@ -534,16 +545,21 @@ static already_AddRefed<GLContextGLX>
 CreateOffscreenPixmapContext(const gfxIntSize& aSize,
                              const ContextFormat& aFormat,
                              PRBool aShare)
 {
     if (!sGLXLibrary.EnsureInitialized()) {
         return nsnull;
     }
 
+    if (gGLXVersion < 0x0103) {
+        // FIXME: WRITE ME!
+        return nsnull;
+    }
+
     Display *display = DefaultXDisplay();
     int xscreen = DefaultScreen(display);
 
     int attribs[] = {
         GLX_DOUBLEBUFFER, False,
         GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT,
         GLX_X_RENDERABLE, True,
         GLX_RED_SIZE, 1,
@@ -656,16 +672,21 @@ GLContextProviderGLX::CreateOffscreen(co
 
 already_AddRefed<GLContext>
 GLContextProviderGLX::CreateForNativePixmapSurface(gfxASurface *aSurface)
 {
     if (!sGLXLibrary.EnsureInitialized()) {
         return nsnull;
     }
 
+    if (gGLXVersion < 0x0103) {
+        // This might be implementable, but it isn't now.
+        return nsnull;
+    }
+
     if (aSurface->GetType() != gfxASurface::SurfaceTypeXlib) {
         NS_WARNING("GLContextProviderGLX::CreateForNativePixmapSurface called with non-Xlib surface");
         return nsnull;
     }
 
     nsAutoTArray<int, 20> attribs;
 
 #define A1_(_x)  do { attribs.AppendElement(_x); } while(0)
diff --git a/gfx/thebes/GLXLibrary.h b/gfx/thebes/GLXLibrary.h
--- a/gfx/thebes/GLXLibrary.h
+++ b/gfx/thebes/GLXLibrary.h
@@ -122,16 +122,19 @@ public:
                                                 XVisualInfo *,
                                                 int,
                                                 int *);
     PFNGLXGETCONFIG xGetConfig;
     typedef GLXPixmap (GLAPIENTRY * PFNGLXCREATEGLXPIXMAP) (Display *,
                                                             XVisualInfo *,
                                                             Pixmap);
     PFNGLXCREATEGLXPIXMAP xCreateGLXPixmap;
+    typedef void (GLAPIENTRY * PFNGLXDESTROYGLXPIXMAP) (Display *,
+                                                        GLXPixmap);
+    PFNGLXDESTROYGLXPIXMAP xDestroyGLXPixmap;
 
     PRBool EnsureInitialized();
 
 private:
     PRBool mInitialized;
     PRLibrary *mOGLLibrary;
 };
 
