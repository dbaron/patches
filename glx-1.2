From: L. David Baron <dbaron@dbaron.org>

Allow use of GLX 1.2 when setting up GL for WebGL.

diff --git a/gfx/thebes/GLContextProviderGLX.cpp b/gfx/thebes/GLContextProviderGLX.cpp
--- a/gfx/thebes/GLContextProviderGLX.cpp
+++ b/gfx/thebes/GLContextProviderGLX.cpp
@@ -82,36 +82,39 @@ GLXLibrary::EnsureInitialized()
 
     LibrarySymbolLoader::SymLoadStruct symbols[] = {
         { (PRFuncPtr*) &xDeleteContext, { "glXDestroyContext", NULL } },
         { (PRFuncPtr*) &xMakeCurrent, { "glXMakeCurrent", NULL } },
         { (PRFuncPtr*) &xGetProcAddress, { "glXGetProcAddress", NULL } },
         { (PRFuncPtr*) &xChooseVisual, { "glXChooseVisual", NULL } },
         { (PRFuncPtr*) &xChooseFBConfig, { "glXChooseFBConfig", NULL } },
         { (PRFuncPtr*) &xGetFBConfigs, { "glXGetFBConfigs", NULL } },
+        { (PRFuncPtr*) &xCreateNewContext, { "glXCreateNewContext", NULL } },
+        { (PRFuncPtr*) &xSwapBuffers, { "glXSwapBuffers", NULL } },
+        { (PRFuncPtr*) &xQueryServerString, { "glXQueryServerString", NULL } },
+        { (PRFuncPtr*) &xGetClientString, { "glXGetClientString", NULL } },
+        { (PRFuncPtr*) &xCreateContext, { "glXCreateContext", NULL } },
+        { (PRFuncPtr*) &xGetCurrentContext, { "glXGetCurrentContext", NULL } },
+        { (PRFuncPtr*) &xGetConfig, { "glXGetConfig", NULL } },
+        { (PRFuncPtr*) &xCreateGLXPixmap, { "glXCreateGLXPixmap", NULL } },
+        { (PRFuncPtr*) &xDestroyGLXPixmap, { "glXDestroyGLXPixmap", NULL } },
+        { NULL, { NULL } }
+    };
+
+    // Symbols for functions that are new in GLX 1.3.
+    LibrarySymbolLoader::SymLoadStruct symbols13[] = {
         { (PRFuncPtr*) &xCreatePbuffer, { "glXCreatePbuffer", NULL } },
-        { (PRFuncPtr*) &xCreateNewContext, { "glXCreateNewContext", NULL } },
         { (PRFuncPtr*) &xDestroyPbuffer, { "glXDestroyPbuffer", NULL } },
         { (PRFuncPtr*) &xGetVisualFromFBConfig, { "glXGetVisualFromFBConfig", NULL } },
         { (PRFuncPtr*) &xGetFBConfigAttrib, { "glXGetFBConfigAttrib", NULL } },
-        { (PRFuncPtr*) &xSwapBuffers, { "glXSwapBuffers", NULL } },
-        { (PRFuncPtr*) &xQueryServerString, { "glXQueryServerString", NULL } },
         { (PRFuncPtr*) &xCreatePixmap, { "glXCreatePixmap", NULL } },
         { (PRFuncPtr*) &xDestroyPixmap, { "glXDestroyPixmap", NULL } },
-        { (PRFuncPtr*) &xGetClientString, { "glXGetClientString", NULL } },
-        { (PRFuncPtr*) &xCreateContext, { "glXCreateContext", NULL } },
-        { (PRFuncPtr*) &xGetCurrentContext, { "glXGetCurrentContext", NULL } },
         { NULL, { NULL } }
     };
 
-    if (!LibrarySymbolLoader::LoadSymbols(mOGLLibrary, &symbols[0])) {
-        NS_WARNING("Couldn't find required entry point in OpenGL shared library");
-        return PR_FALSE;
-    }
-
     const char *vendor = xQueryServerString(DefaultXDisplay(),
                                             DefaultScreen(DefaultXDisplay()),
                                             GLX_VENDOR);
     const char *serverVersionStr = xQueryServerString(DefaultXDisplay(),
                                                       DefaultScreen(DefaultXDisplay()),
                                                       GLX_VERSION);
     const char *clientVersionStr = xGetClientString(DefaultXDisplay(),
                                                     GLX_VERSION);
@@ -131,18 +134,22 @@ GLXLibrary::EnsureInitialized()
         strlen(clientVersionStr) >= 3 &&
         clientVersionStr[1] == '.')
     {
         clientVersion = (clientVersionStr[0] - '0') << 8 | (clientVersionStr[2] - '0');
     }
 
     gGLXVersion = PR_MIN(clientVersion, serverVersion);
 
-    if (gGLXVersion < 0x0103)
+    if (!LibrarySymbolLoader::LoadSymbols(mOGLLibrary, &symbols[0]) ||
+        (gGLXVersion >= 0x0103 &&
+         !LibrarySymbolLoader::LoadSymbols(mOGLLibrary, &symbols[0]))) {
+        NS_WARNING("Couldn't find required entry point in OpenGL shared library");
         return PR_FALSE;
+    }
 
     gIsATI = vendor && DoesVendorStringMatch(vendor, "ATI");
     gIsChromium = (vendor && DoesVendorStringMatch(vendor, "Chromium")) ||
         (serverVersion && DoesVendorStringMatch(serverVersionStr, "Chromium"));
 
     mInitialized = PR_TRUE;
     return PR_TRUE;
 }
@@ -166,18 +173,22 @@ public:
                     GLXDrawable drawable,
                     GLXFBConfig cfg,
                     XVisualInfo *vinfo,
                     GLContextGLX *shareContext,
                     PRBool deleteDrawable,
                     gfxXlibSurface *pixmap = nsnull)
     {
         int db = 0, err;
-        err = sGLXLibrary.xGetFBConfigAttrib(display, cfg,
-                                             GLX_DOUBLEBUFFER, &db);
+        if (gGLXVersion >= 0x0103) {
+            err = sGLXLibrary.xGetFBConfigAttrib(display, cfg,
+                                                 GLX_DOUBLEBUFFER, &db);
+        } else {
+            err = sGLXLibrary.xGetConfig(display, vinfo, GLX_DOUBLEBUFFER, &db);
+        }
         if (GLX_BAD_ATTRIBUTE != err) {
 #ifdef DEBUG
             printf("[GLX] FBConfig is %sdouble-buffered\n", db ? "" : "not ");
 #endif
         }
 
         ctxErrorOccurred = false;
         int (*oldHandler)(Display *, XErrorEvent *);
@@ -427,16 +438,21 @@ AreCompatibleVisuals(XVisualInfo *one, X
 
 already_AddRefed<GLContext>
 GLContextProviderGLX::CreateForWindow(nsIWidget *aWidget)
 {
     if (!sGLXLibrary.EnsureInitialized()) {
         return nsnull;
     }
 
+    if (gGLXVersion < 0x0103) {
+        // This might be implementable, but it isn't now.
+        return nsnull;
+    }
+
     // Currently, we take whatever Visual the window already has, and
     // try to create an fbconfig for that visual.  This isn't
     // necessarily what we want in the long run; an fbconfig may not
     // be available for the existing visual, or if it is, the GL
     // performance might be suboptimal.  But using the existing visual
     // is a relatively safe intermediate step.
 
     Display *display = (Display*)aWidget->GetNativeData(NS_NATIVE_DISPLAY); 
@@ -548,82 +564,98 @@ CreateOffscreenPixmapContext(const gfxIn
         GLX_X_RENDERABLE, True,
         GLX_RED_SIZE, 1,
         GLX_GREEN_SIZE, 1,
         GLX_BLUE_SIZE, 1,
         GLX_ALPHA_SIZE, 0,
         GLX_DEPTH_SIZE, 0,
         0
     };
-    int numConfigs = 0;
+
+    ScopedXFree<XVisualInfo> vinfo;
 
     ScopedXFree<GLXFBConfig> cfgs;
-    cfgs = sGLXLibrary.xChooseFBConfig(display,
-                                       xscreen,
-                                       attribs,
-                                       &numConfigs);
-    if (!cfgs) {
-        return nsnull;
-    }
+    GLXFBConfig chosenConfig;
+    if (gGLXVersion >= 0x0103) {
+        int numConfigs = 0;
 
-    NS_ASSERTION(numConfigs > 0,
-                 "glXChooseFBConfig() failed to match our requested format and violated its spec (!)");
-
-    ScopedXFree<XVisualInfo> vinfo;
-    int chosenIndex;
-
-    for (int i = 0; i < numConfigs; ++i) {
-        int dtype, visid;
-
-        if (sGLXLibrary.xGetFBConfigAttrib(display, cfgs[i], GLX_DRAWABLE_TYPE, &dtype) != Success
-            || !(dtype & GLX_PIXMAP_BIT))
-        {
-            continue;
-        }
-        if (sGLXLibrary.xGetFBConfigAttrib(display, cfgs[i], GLX_VISUAL_ID, &visid) != Success
-            || visid == 0)
-        {
-            continue;
+        cfgs = sGLXLibrary.xChooseFBConfig(display,
+                                           xscreen,
+                                           attribs,
+                                           &numConfigs);
+        if (!cfgs) {
+            return nsnull;
         }
 
-        vinfo = sGLXLibrary.xGetVisualFromFBConfig(display, cfgs[i]);
+        NS_ASSERTION(numConfigs > 0,
+                     "glXChooseFBConfig() failed to match our requested format and violated its spec (!)");
 
-        if (vinfo) {
-            chosenIndex = i;
-            break;
+        for (int i = 0; i < numConfigs; ++i) {
+            int dtype, visid;
+
+            if (sGLXLibrary.xGetFBConfigAttrib(display, cfgs[i], GLX_DRAWABLE_TYPE, &dtype) != Success
+                || !(dtype & GLX_PIXMAP_BIT))
+            {
+                continue;
+            }
+            if (sGLXLibrary.xGetFBConfigAttrib(display, cfgs[i], GLX_VISUAL_ID, &visid) != Success
+                || visid == 0)
+            {
+                continue;
+            }
+
+            vinfo = sGLXLibrary.xGetVisualFromFBConfig(display, cfgs[i]);
+
+            if (vinfo) {
+                chosenConfig = cfgs[i];
+                break;
+            }
         }
+    } else {
+        vinfo = sGLXLibrary.xChooseVisual(display, xscreen, attribs);
+
+        // Leave chosenConfig uninitialized;
+        // GLContextGLX::CreateGLContext will also check gGLXVersion and
+        // thus won't use it.
     }
 
     if (!vinfo) {
-        NS_WARNING("glXChooseFBConfig() didn't give us any configs with visuals!");
+        NS_WARNING("glXChooseFBConfig()/glXChooseVisual() didn't give us any configs with visuals!");
         return nsnull;
     }
 
     nsRefPtr<gfxXlibSurface> xsurface = gfxXlibSurface::Create(DefaultScreenOfDisplay(display),
                                                                vinfo->visual,
                                                                gfxIntSize(16, 16));
     if (xsurface->CairoStatus() != 0) {
         return nsnull;
     }
 
-   
-    GLXPixmap glxpixmap = sGLXLibrary.xCreatePixmap(display,
-                                                    cfgs[chosenIndex],
-                                                    xsurface->XDrawable(),
-                                                    NULL);
+    GLXPixmap glxpixmap;
+    if (gGLXVersion >= 0x0103) {
+        glxpixmap = sGLXLibrary.xCreatePixmap(display,
+                                              chosenConfig,
+                                              xsurface->XDrawable(),
+                                              NULL);
+    } else {
+        // FIXME: We're assuming xsurface's drawable is a Pixmap!
+        glxpixmap = sGLXLibrary.xCreateGLXPixmap(display,
+                                                 vinfo,
+                                                 static_cast<Pixmap>(xsurface->XDrawable()));
+    }
     if (glxpixmap == 0) {
         return nsnull;
     }
 
     GLContextGLX *shareContext = aShare ? GetGlobalContextGLX() : nsnull;
 
     nsRefPtr<GLContextGLX> glContext = GLContextGLX::CreateGLContext(aFormat,
                                                                      display,
                                                                      glxpixmap,
-                                                                     cfgs[chosenIndex],
+                                                                     chosenConfig,
                                                                      vinfo,
                                                                      shareContext,
                                                                      PR_TRUE,
                                                                      xsurface);
 
     return glContext.forget();
 }
 
@@ -656,16 +688,21 @@ GLContextProviderGLX::CreateOffscreen(co
 
 already_AddRefed<GLContext>
 GLContextProviderGLX::CreateForNativePixmapSurface(gfxASurface *aSurface)
 {
     if (!sGLXLibrary.EnsureInitialized()) {
         return nsnull;
     }
 
+    if (gGLXVersion < 0x0103) {
+        // This might be implementable, but it isn't now.
+        return nsnull;
+    }
+
     if (aSurface->GetType() != gfxASurface::SurfaceTypeXlib) {
         NS_WARNING("GLContextProviderGLX::CreateForNativePixmapSurface called with non-Xlib surface");
         return nsnull;
     }
 
     nsAutoTArray<int, 20> attribs;
 
 #define A1_(_x)  do { attribs.AppendElement(_x); } while(0)
diff --git a/gfx/thebes/GLXLibrary.h b/gfx/thebes/GLXLibrary.h
--- a/gfx/thebes/GLXLibrary.h
+++ b/gfx/thebes/GLXLibrary.h
@@ -122,16 +122,19 @@ public:
                                                 XVisualInfo *,
                                                 int,
                                                 int *);
     PFNGLXGETCONFIG xGetConfig;
     typedef GLXPixmap (GLAPIENTRY * PFNGLXCREATEGLXPIXMAP) (Display *,
                                                             XVisualInfo *,
                                                             Pixmap);
     PFNGLXCREATEGLXPIXMAP xCreateGLXPixmap;
+    typedef void (GLAPIENTRY * PFNGLXDESTROYGLXPIXMAP) (Display *,
+                                                        GLXPixmap);
+    PFNGLXDESTROYGLXPIXMAP xDestroyGLXPixmap;
 
     PRBool EnsureInitialized();
 
 private:
     PRBool mInitialized;
     PRLibrary *mOGLLibrary;
 };
 
