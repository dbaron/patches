From: L. David Baron <dbaron@dbaron.org>

Bug 810586 - Check for originating cells in the FLEX_ALL_LARGE case.

TODO: Figure out if we want this.  I tend to think we don't.  See tests
at http://dbaron.org/css/test/2013/flex-all-large-to-nonoriginating/ and
spec issue at http://dbaron.org/css/intrinsic/20130102#distributetocols .

diff --git a/layout/tables/BasicTableLayoutStrategy.cpp b/layout/tables/BasicTableLayoutStrategy.cpp
--- a/layout/tables/BasicTableLayoutStrategy.cpp
+++ b/layout/tables/BasicTableLayoutStrategy.cpp
@@ -716,40 +716,44 @@ BasicTableLayoutStrategy::DistributeWidt
      *   [numNonSpecZeroWidthCols]
      *
      *   c. otherwise, if any columns without percent width have nonzero
      *   pref width, in proportion to pref width [total_fixed_pref]
      *
      *   d. otherwise, if any columns have nonzero percentage widths, in
      *   proportion to the percentage widths [total_pct]
      *
-     *   e. otherwise, equally.
+     *   e. otherwise, equally among all columns with originating cells.
      */
 
     // Loop #1 over the columns, to figure out the four values above so
     // we know which case we're dealing with.
 
     nscoord guess_min = 0,
             guess_min_pct = 0,
             guess_min_spec = 0,
             guess_pref = 0,
             total_flex_pref = 0,
             total_fixed_pref = 0;
     float total_pct = 0.0f; // 0.0f to 1.0f
     int32_t numInfiniteWidthCols = 0;
     int32_t numNonSpecZeroWidthCols = 0;
+    int32_t numOriginatingCols = 0;
 
     int32_t col;
     nsTableCellMap *cellMap = mTableFrame->GetCellMap();
     for (col = aFirstCol; col < aFirstCol + aColCount; ++col) {
         nsTableColFrame *colFrame = mTableFrame->GetColFrame(col);
         if (!colFrame) {
             NS_ERROR("column frames out of sync with cell map");
             continue;
         }
+        bool hasOriginating = cellMap->GetNumCellsOriginatingInCol(col) > 0;
+        if (hasOriginating)
+            ++numOriginatingCols;
         nscoord min_width = colFrame->GetMinCoord();
         guess_min += min_width;
         if (colFrame->GetPrefPercent() != 0.0f) {
             float pct = colFrame->GetPrefPercent();
             total_pct += pct;
             nscoord val = nscoord(float(aWidth) * pct);
             if (val < min_width)
                 val = min_width;
@@ -766,17 +770,17 @@ BasicTableLayoutStrategy::DistributeWidt
                 // we'll add on the rest of guess_min_spec outside the
                 // loop
                 nscoord delta = NSCoordSaturatingSubtract(pref_width, 
                                                           min_width, 0);
                 guess_min_spec = NSCoordSaturatingAdd(guess_min_spec, delta);
                 total_fixed_pref = NSCoordSaturatingAdd(total_fixed_pref, 
                                                         pref_width);
             } else if (pref_width == 0) {
-                if (cellMap->GetNumCellsOriginatingInCol(col) > 0) {
+                if (hasOriginating) {
                     ++numNonSpecZeroWidthCols;
                 }
             } else {
                 total_flex_pref = NSCoordSaturatingAdd(total_flex_pref,
                                                        pref_width);
             }
         }
     }
@@ -837,17 +841,17 @@ BasicTableLayoutStrategy::DistributeWidt
         } else if (total_fixed_pref > 0) {
             l2t = FLEX_FIXED_LARGE;
             basis.c = total_fixed_pref;
         } else if (total_pct > 0.0f) {
             l2t = FLEX_PCT_LARGE;
             basis.f = total_pct;
         } else {
             l2t = FLEX_ALL_LARGE;
-            basis.c = aColCount;
+            basis.c = numOriginatingCols;
         }
     }
 
 #ifdef DEBUG_dbaron_off
     printf("ComputeColumnWidths: %d columns in width %d,\n"
            "  guesses=[%d,%d,%d,%d], totals=[%d,%d,%f],\n"
            "  l2t=%d, space=%d, basis.c=%d\n",
            aColCount, aWidth,
@@ -995,19 +999,21 @@ BasicTableLayoutStrategy::DistributeWidt
                 if (pct != 0.0f) {
                     float c = float(space) / basis.f;
                     col_width += NSToCoordRound(pct * c);
                     basis.f -= pct;
                 }
                 break;
             case FLEX_ALL_LARGE:
                 {
-                    float c = float(space) / float(basis.c);
-                    col_width += NSToCoordRound(c);
-                    --basis.c;
+                    if (cellMap->GetNumCellsOriginatingInCol(col) > 0) {
+                        float c = float(space) / float(basis.c);
+                        col_width += NSToCoordRound(c);
+                        --basis.c;
+                    }
                 }
                 break;
         }
 
         // Only subtract from space if it's a real number.
         if (space != nscoord_MAX) {
             NS_ASSERTION(col_width != nscoord_MAX,
                  "How is col_width nscoord_MAX if space isn't?");
