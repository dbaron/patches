Hook g_object_ref and g_object_unref into NS_LogAddRef and NS_LogRelease.

diff --git a/toolkit/xre/nsAppRunner.cpp b/toolkit/xre/nsAppRunner.cpp
--- a/toolkit/xre/nsAppRunner.cpp
+++ b/toolkit/xre/nsAppRunner.cpp
@@ -2420,16 +2420,80 @@ static void MOZ_gdk_display_close(GdkDis
       gdk_display_close(display);
 #if GTK_CHECK_VERSION(2,8,0) && \
   (defined(DEBUG) || defined(NS_BUILD_REFCNT_LOGGING) || defined(NS_TRACE_MALLOC))
     cairo_debug_reset_static_data();
     FcFini();
 #endif
   }
 }
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+
+#define _GNU_SOURCE 1
+#include <dlfcn.h>
+
+typedef gpointer (*ns_g_object_ref_type)  (gpointer);
+typedef void (*ns_g_object_unref_type)(gpointer);
+typedef GTypeInstance* (*ns_g_type_create_instance_type)(GType);
+
+static ns_g_object_ref_type real_g_object_ref = 
+  (ns_g_object_ref_type) dlsym(RTLD_NEXT, "g_object_ref");
+static ns_g_object_unref_type real_g_object_unref = 
+  (ns_g_object_unref_type) dlsym(RTLD_NEXT, "g_object_unref");
+static ns_g_type_create_instance_type real_g_type_create_instance = 
+  (ns_g_type_create_instance_type) dlsym(RTLD_NEXT, "g_type_create_instance");
+
+gpointer
+g_object_ref (gpointer _object)
+{
+  gpointer result = real_g_object_ref(_object);
+
+  GObject *object = G_OBJECT(_object);
+  GTypeQuery q;
+  q.instance_size = 0;
+  g_type_query(G_TYPE_FROM_INSTANCE(object), &q);
+  NS_LogAddRef(object, object->ref_count, G_OBJECT_TYPE_NAME(object),
+               q.instance_size);
+
+  return result;
+}
+
+void
+g_object_unref (gpointer _object)
+{
+  GObject *object = G_OBJECT(_object);
+  NS_LogRelease(object, object->ref_count - 1, G_OBJECT_TYPE_NAME(object));
+
+  real_g_object_unref(_object);
+}
+
+GTypeInstance*
+g_type_create_instance(GType type)
+{
+  // GObjects are initialized with a reference count of one.  We want to
+  // hook into their construction path as early as possible to log that
+  // reference count.  (We want to log it before any other reference
+  // counting happens.)  Since G_OBJECT_TYPE_NAME() will return the
+  // correct result after g_type_create_instance finishes, so we can
+  // hook that (rather than g_object_constructor).
+  GTypeInstance *result = real_g_type_create_instance(type);
+
+  GObject *object = G_OBJECT(result);
+  GTypeQuery q;
+  q.instance_size = 0;
+  g_type_query(G_TYPE_FROM_INSTANCE(object), &q);
+  NS_LogAddRef(object, 1, G_OBJECT_TYPE_NAME(object),
+               q.instance_size);
+
+  return result;
+}
+
+#endif // defined(NS_BUILD_REFCNT_LOGGING)
+
 #endif // MOZ_WIDGET_GTK2
 
 /** 
  * NSPR will search for the "nspr_use_zone_allocator" symbol throughout
  * the process and use it to determine whether the application defines its own
  * memory allocator or not.
  *
  * Since most applications (e.g. Firefox and Thunderbird) don't use any special
