From: L. David Baron <dbaron@dbaron.org>

Add assertions that the rule walker is at the root.  (Bug 507457)

diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -699,16 +699,17 @@ nsStyleSet::ResolveStyleFor(nsIContent* 
   nsStyleContext*  result = nsnull;
   nsPresContext* presContext = PresContext();
 
   NS_ASSERTION(aContent, "must have content");
   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eELEMENT),
                "content must be element");
 
   if (aContent && presContext) {
+    NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
     ElementRuleProcessorData data(presContext, aContent, mRuleWalker);
     FileRules(EnumRulesMatching, &data);
     result = GetContext(presContext, aParentContext, nsnull).get();
 
     // Now reset the walker back to the root of the tree.
     mRuleWalker->Reset();
   }
 
@@ -721,16 +722,17 @@ nsStyleSet::ResolveStyleForRules(nsStyle
                                  nsRuleNode *aRuleNode,
                                  const nsCOMArray<nsIStyleRule> &aRules)
 {
   NS_ENSURE_FALSE(mInShutdown, nsnull);
   nsStyleContext* result = nsnull;
   nsPresContext *presContext = PresContext();
 
   if (presContext) {
+    NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
     if (aRuleNode)
       mRuleWalker->SetCurrentNode(aRuleNode);
     // FIXME: Perhaps this should be passed in, but it probably doesn't
     // matter.
     mRuleWalker->SetLevel(eDocSheet, PR_FALSE);
     for (PRInt32 i = 0; i < aRules.Count(); i++) {
       mRuleWalker->Forward(aRules.ObjectAt(i));
     }
@@ -744,16 +746,17 @@ nsStyleSet::ResolveStyleForRules(nsStyle
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForNonElement(nsStyleContext* aParentContext)
 {
   nsStyleContext* result = nsnull;
   nsPresContext *presContext = PresContext();
 
   if (presContext) {
+    NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
     result = GetContext(presContext, aParentContext,
                         nsCSSAnonBoxes::mozNonElement).get();
     NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
   }
 
   return result;
 }
 
@@ -797,16 +800,17 @@ nsStyleSet::ResolvePseudoStyleFor(nsICon
   NS_ASSERTION(aParentContent ||
                nsCSSAnonBoxes::IsAnonBox(aPseudoTag),
                "null content must correspond to anonymous box");
   NS_ASSERTION(nsCSSAnonBoxes::IsAnonBox(aPseudoTag) ||
                nsCSSPseudoElements::IsPseudoElement(aPseudoTag),
                "aPseudoTag must be pseudo-element or anonymous box");
 
   if (aPseudoTag && presContext) {
+    NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
     PseudoRuleProcessorData data(presContext, aParentContent, aPseudoTag,
                                  aComparator, mRuleWalker);
     WalkRestrictionRule(aPseudoTag);
     FileRules(EnumPseudoRulesMatching, &data);
 
     result = GetContext(presContext, aParentContext, aPseudoTag).get();
 
     // Now reset the walker back to the root of the tree.
@@ -835,16 +839,17 @@ nsStyleSet::ProbePseudoStyleFor(nsIConte
   NS_ASSERTION(aParentContent ||
                nsCSSAnonBoxes::IsAnonBox(aPseudoTag),
                "null content must correspond to anonymous box");
   NS_ASSERTION(nsCSSAnonBoxes::IsAnonBox(aPseudoTag) ||
                nsCSSPseudoElements::IsPseudoElement(aPseudoTag),
                "aPseudoTag must be pseudo-element or anonymous box");
 
   if (aPseudoTag && presContext) {
+    NS_ASSERTION(mRuleWalker->AtRoot(), "rule walker must be at root");
     PseudoRuleProcessorData data(presContext, aParentContent, aPseudoTag,
                                  nsnull, mRuleWalker);
     WalkRestrictionRule(aPseudoTag);
     // not the root if there was a restriction rule
     nsRuleNode *adjustedRoot = mRuleWalker->GetCurrentNode();
     FileRules(EnumPseudoRulesMatching, &data);
 
     if (mRuleWalker->GetCurrentNode() != adjustedRoot)
