From: L. David Baron <dbaron@dbaron.org>

Correct covering for continued transitions.  (Bug 625289)

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -352,16 +352,24 @@ TransExtractComputedValue(nsCSSProperty 
                         nsStyleAnimation::eUnit_Enumerated,
                       "unexpected unit");
     aComputedValue.SetIntValue(aComputedValue.GetIntValue(),
                                nsStyleAnimation::eUnit_Visibility);
   }
   return result;
 }
 
+struct StartTransitionState {
+  bool mNeedCover;
+  nsCSSPropertySet mWhichStarted;
+  nsCSSPropertySet mWhichContinued;
+
+  StartTransitionState() : mNeedCover(false) {}
+};
+
 already_AddRefed<nsIStyleRule>
 nsTransitionManager::StyleContextChanged(dom::Element *aElement,
                                          nsStyleContext *aOldStyleContext,
                                          nsStyleContext *aNewStyleContext)
 {
   NS_PRECONDITION(aOldStyleContext->GetPseudo() ==
                       aNewStyleContext->GetPseudo(),
                   "pseudo type mismatch");
@@ -372,18 +380,18 @@ nsTransitionManager::StyleContextChanged
   NS_PRECONDITION(aOldStyleContext->HasPseudoElementData() ==
                       aNewStyleContext->HasPseudoElementData(),
                   "pseudo type mismatch");
 
   // NOTE: Things in this function (and ConsiderStartingTransition)
   // should never call PeekStyleData because we don't preserve gotten
   // structs across reframes.
 
-  // Return sooner (before the startedAny check below) for the most
-  // common case: no transitions specified or running.
+  // Return sooner (before the state.mNeedCover check below) for the
+  // most common case: no transitions specified or running.
   const nsStyleDisplay *disp = aNewStyleContext->GetStyleDisplay();
   nsCSSPseudoElements::Type pseudoType = aNewStyleContext->GetPseudoType();
   if (pseudoType != nsCSSPseudoElements::ePseudo_NotPseudoElement) {
     if (pseudoType != nsCSSPseudoElements::ePseudo_before &&
         pseudoType != nsCSSPseudoElements::ePseudo_after) {
       return nsnull;
     }
 
@@ -419,18 +427,17 @@ nsTransitionManager::StyleContextChanged
     // FIXME (Bug 522599): Add tests for this.
     return nsnull;
   }
 
   // Per http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html
   // I'll consider only the transitions from the number of items in
   // 'transition-property' on down, and later ones will override earlier
   // ones (tracked using |whichStarted|).
-  PRBool startedAny = PR_FALSE;
-  nsCSSPropertySet whichStarted;
+  StartTransitionState state;
   for (PRUint32 i = disp->mTransitionPropertyCount; i-- != 0; ) {
     const nsTransition& t = disp->mTransitions[i];
     // Check delay and duration first, since they default to zero, and
     // when they're both zero, we can ignore the transition.
     if (t.GetDelay() != 0.0f || t.GetDuration() != 0.0f) {
       // We might have something to transition.  See if any of the
       // properties in question changed and are animatable.
       // FIXME: Would be good to find a way to share code between this
@@ -440,28 +447,28 @@ nsTransitionManager::StyleContextChanged
           property == eCSSProperty_UNKNOWN) {
         // Nothing to do, but need to exclude this from cases below.
       } else if (property == eCSSPropertyExtra_all_properties) {
         for (nsCSSProperty p = nsCSSProperty(0); 
              p < eCSSProperty_COUNT_no_shorthands;
              p = nsCSSProperty(p + 1)) {
           ConsiderStartingTransition(p, t, aElement, et,
                                      aOldStyleContext, aNewStyleContext,
-                                     &startedAny, &whichStarted);
+                                     state);
         }
       } else if (nsCSSProps::IsShorthand(property)) {
         CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(subprop, property) {
           ConsiderStartingTransition(*subprop, t, aElement, et,
                                      aOldStyleContext, aNewStyleContext,
-                                     &startedAny, &whichStarted);
+                                     state);
         }
       } else {
         ConsiderStartingTransition(property, t, aElement, et,
                                    aOldStyleContext, aNewStyleContext,
-                                   &startedAny, &whichStarted);
+                                   state);
       }
     }
   }
 
   // Stop any transitions for properties that are no longer in
   // 'transition-property'.
   // Also stop any transitions for properties that just changed (and are
   // still in the set of properties to transition), but we didn't just
@@ -516,17 +523,17 @@ nsTransitionManager::StyleContextChanged
     } while (i != 0);
 
     if (pts.IsEmpty()) {
       et->Destroy();
       et = nsnull;
     }
   }
 
-  if (!startedAny) {
+  if (!state.mNeedCover) {
     return nsnull;
   }
 
   NS_ABORT_IF_FALSE(et, "must have element transitions if we started "
                         "any transitions");
 
   // In the CSS working group discussion (2009 Jul 15 telecon,
   // http://www.w3.org/mid/4A5E1470.4030904@inkedblade.net ) of
@@ -547,39 +554,50 @@ nsTransitionManager::StyleContextChanged
   if (!coverRule) {
     NS_WARNING("out of memory");
     return nsnull;
   }
   
   nsTArray<ElementPropertyTransition> &pts = et->mPropertyTransitions;
   for (PRUint32 i = 0, i_end = pts.Length(); i < i_end; ++i) {
     ElementPropertyTransition &pt = pts[i];
-    if (whichStarted.HasProperty(pt.mProperty)) {
+    if (state.mWhichStarted.HasProperty(pt.mProperty)) {
+      NS_ABORT_IF_FALSE(!state.mWhichContinued.HasProperty(pt.mProperty),
+                        "can't have started and continued");
       coverRule->AddValue(pt.mProperty, pt.mStartValue);
+    } else if (state.mWhichContinued.HasProperty(pt.mProperty)) {
+      // Extract the value again; we know ConsiderStartingTransition
+      // extracted it successfully.
+      nsStyleAnimation::Value currentValue;
+#ifdef DEBUG
+      PRBool ok =
+#endif
+        TransExtractComputedValue(pt.mProperty, aOldStyleContext, currentValue);
+      NS_ABORT_IF_FALSE(ok, "should still be able to extract value");
+      coverRule->AddValue(pt.mProperty, currentValue);
     }
   }
 
   return coverRule.forget();
 }
 
 void
 nsTransitionManager::ConsiderStartingTransition(nsCSSProperty aProperty,
                        const nsTransition& aTransition,
                        dom::Element *aElement,
                        ElementTransitions *&aElementTransitions,
                        nsStyleContext *aOldStyleContext,
                        nsStyleContext *aNewStyleContext,
-                       PRBool *aStartedAny,
-                       nsCSSPropertySet *aWhichStarted)
+                       StartTransitionState &aState)
 {
   // IsShorthand itself will assert if aProperty is not a property.
   NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(aProperty),
                     "property out of range");
 
-  if (aWhichStarted->HasProperty(aProperty)) {
+  if (aState.mWhichStarted.HasProperty(aProperty)) {
     // A later item in transition-property already started a
     // transition for this property, so we ignore this one.
     // See comment above and
     // http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html .
     return;
   }
 
   if (nsCSSProps::kAnimTypeTable[aProperty] == eStyleAnimType_None) {
@@ -658,16 +676,18 @@ nsTransitionManager::ConsiderStartingTra
     const ElementPropertyTransition &oldPT =
       aElementTransitions->mPropertyTransitions[currentIndex];
 
     if (oldPT.mEndValue == pt.mEndValue) {
       // If we got a style change that changed the value to the endpoint
       // of the currently running transition, we don't want to interrupt
       // its timing function.
       // WalkTransitionRule already called RestyleForAnimation.
+      aState.mWhichContinued.AddProperty(aProperty);
+      aState.mNeedCover = true;
       return;
     }
 
     // If the new transition reverses the old one, we'll need to handle
     // the timing differently.
     if (!oldPT.IsRemovedSentinel() &&
         oldPT.mStartForReversingTest == pt.mEndValue) {
       // Compute the appropriate negative transition-delay such that right
@@ -735,18 +755,18 @@ nsTransitionManager::ConsiderStartingTra
   }
 
   nsRestyleHint hint =
     aNewStyleContext->GetPseudoType() ==
       nsCSSPseudoElements::ePseudo_NotPseudoElement ?
     eRestyle_Self : eRestyle_Subtree;
   presContext->PresShell()->RestyleForAnimation(aElement, hint);
 
-  *aStartedAny = PR_TRUE;
-  aWhichStarted->AddProperty(aProperty);
+  aState.mNeedCover = true;
+  aState.mWhichStarted.AddProperty(aProperty);
 }
 
 ElementTransitions*
 nsTransitionManager::GetElementTransitions(dom::Element *aElement,
                                            nsCSSPseudoElements::Type aPseudoType,
                                            PRBool aCreateIfNeeded)
 {
   if (!aCreateIfNeeded && PR_CLIST_IS_EMPTY(&mElementTransitions)) {
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
--- a/layout/style/nsTransitionManager.h
+++ b/layout/style/nsTransitionManager.h
@@ -43,19 +43,19 @@
 #include "prclist.h"
 #include "nsCSSProperty.h"
 #include "nsIStyleRuleProcessor.h"
 #include "nsRefreshDriver.h"
 #include "nsCSSPseudoElements.h"
 
 class nsStyleContext;
 class nsPresContext;
-class nsCSSPropertySet;
 struct nsTransition;
 struct ElementTransitions;
+struct StartTransitionState;
 
 class nsTransitionManager : public nsIStyleRuleProcessor,
                             public nsARefreshObserver {
 public:
   nsTransitionManager(nsPresContext *aPresContext);
   ~nsTransitionManager();
 
   /**
@@ -107,18 +107,17 @@ private:
   friend class ElementTransitions; // for TransitionsRemoved
 
   void ConsiderStartingTransition(nsCSSProperty aProperty,
                                   const nsTransition& aTransition,
                                   mozilla::dom::Element *aElement,
                                   ElementTransitions *&aElementTransitions,
                                   nsStyleContext *aOldStyleContext,
                                   nsStyleContext *aNewStyleContext,
-                                  PRBool *aStartedAny,
-                                  nsCSSPropertySet *aWhichStarted);
+                                  StartTransitionState &aState);
   ElementTransitions* GetElementTransitions(mozilla::dom::Element *aElement,
                                             nsCSSPseudoElements::Type aPseudoType,
                                             PRBool aCreateIfNeeded);
   void AddElementTransitions(ElementTransitions* aElementTransitions);
   void TransitionsRemoved();
   void WalkTransitionRule(RuleProcessorData* aData,
                           nsCSSPseudoElements::Type aPseudoType);
 
