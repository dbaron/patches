From: L. David Baron <dbaron@dbaron.org>

Remove the mechanism of backend-only CSS properties.

diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -56,23 +56,22 @@
   that can be set by this logical property.  The name must be one
   from nsCSSPropLogicalGroupList.h.  For example, this would be
   'BorderColor' for 'border-block-start-color'.
 
   -. 'stylestruct_' [used only for CSS_PROP and CSS_PROP_LOGICAL, not
   CSS_PROP_*] gives the name of the style struct.  Can be used to make
   nsStyle##stylestruct_ and eStyleStruct_##stylestruct_
 
-  -. 'stylestructoffset_' [not used for CSS_PROP_BACKENDONLY] gives the
-  result of offsetof(nsStyle*, member).  Ignored (and generally
-  CSS_PROP_NO_OFFSET, or -1) for properties whose animtype_ is
-  eStyleAnimType_None.
+  -. 'stylestructoffset_' gives the result of offsetof(nsStyle*,
+  member).  Ignored (and generally CSS_PROP_NO_OFFSET, or -1) for
+  properties whose animtype_ is eStyleAnimType_None.
 
-  -. 'animtype_' [not used for CSS_PROP_BACKENDONLY] gives the
-  animation type (see nsStyleAnimType) of this property.
+  -. 'animtype_' gives the animation type (see nsStyleAnimType) of this
+  property.
 
   CSS_PROP_SHORTHAND only takes 1-5.
 
   CSS_PROP_LOGICAL should be used instead of CSS_PROP_struct when
   defining logical properties (which also must be defined with the
   CSS_PROPERTY_LOGICAL flag).  Logical shorthand properties should still
   be defined with CSS_PROP_SHORTHAND.
 
@@ -154,24 +153,16 @@
 #define CSS_PROP_BORDER(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, stylestructoffset_, animtype_) CSS_PROP(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, Border, stylestructoffset_, animtype_)
 #define CSS_PROP_OUTLINE(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, stylestructoffset_, animtype_) CSS_PROP(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, Outline, stylestructoffset_, animtype_)
 #define CSS_PROP_XUL(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, stylestructoffset_, animtype_) CSS_PROP(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, XUL, stylestructoffset_, animtype_)
 #define CSS_PROP_COLUMN(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, stylestructoffset_, animtype_) CSS_PROP(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, Column, stylestructoffset_, animtype_)
 #define CSS_PROP_SVG(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, stylestructoffset_, animtype_) CSS_PROP(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, SVG, stylestructoffset_, animtype_)
 #define CSS_PROP_SVGRESET(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, stylestructoffset_, animtype_) CSS_PROP(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, SVGReset, stylestructoffset_, animtype_)
 #define CSS_PROP_VARIABLES(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, stylestructoffset_, animtype_) CSS_PROP(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, Variables, stylestructoffset_, animtype_)
 
-// For properties that are stored in the CSS backend but are not
-// computed.  An includer may define this in addition to CSS_PROP, but
-// otherwise we treat it as the same.
-#ifndef CSS_PROP_BACKENDONLY
-#define CSS_PROP_BACKENDONLY(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_) CSS_PROP(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, BackendOnly, CSS_PROP_NO_OFFSET, eStyleAnimType_None)
-#define DEFINED_CSS_PROP_BACKENDONLY
-#endif
-
 // And similarly for logical properties.  An includer can define
 // CSS_PROP_LOGICAL to capture all logical properties, but otherwise they
 // are included in CSS_PROP (as long as CSS_PROP_LIST_INCLUDE_LOGICAL is
 // defined).
 #if defined(CSS_PROP_LOGICAL) && defined(CSS_PROP_LIST_EXCLUDE_LOGICAL) || defined(CSS_PROP_LOGICAL) && defined(CSS_PROP_LIST_INCLUDE_LOGICAL) || defined(CSS_PROP_LIST_EXCLUDE_LOGICAL) && defined(CSS_PROP_LIST_INCLUDE_LOGICAL)
 #error Do not define more than one of CSS_PROP_LOGICAL, CSS_PROP_LIST_EXCLUDE_LOGICAL and CSS_PROP_LIST_INCLUDE_LOGICAL when capturing properties using CSS_PROP.
 #endif
 
@@ -289,20 +280,16 @@
 #define CSS_PROP_SVGRESET(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, stylestructoffset_, animtype_) /* nothing */
 #define DEFINED_CSS_PROP_SVGRESET
 #endif
 #ifndef CSS_PROP_VARIABLES
 #define CSS_PROP_VARIABLES(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, stylestructoffset_, animtype_) /* nothing */
 #define DEFINED_CSS_PROP_VARIABLES
 #endif
 
-#ifndef CSS_PROP_BACKENDONLY
-#define CSS_PROP_BACKENDONLY(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_) /* nothing */
-#define DEFINED_CSS_PROP_BACKENDONLY
-#endif
 #ifndef CSS_PROP_LOGICAL
 #define CSS_PROP_LOGICAL(name_, id_, method_, flags_, pref_, parsevariant_, kwtable_, group_, struct_, stylestructoffset_, animtype_) /* nothing */
 #define DEFINED_CSS_PROP_LOGICAL
 #endif
 
 #endif /* !defined(CSS_PROP) */
 
 /*************************************************************************/
@@ -4248,20 +4235,16 @@ CSS_PROP_FONT(
 #undef CSS_PROP_PADDING
 #undef CSS_PROP_BORDER
 #undef CSS_PROP_OUTLINE
 #undef CSS_PROP_XUL
 #undef CSS_PROP_COLUMN
 #undef CSS_PROP_SVG
 #undef CSS_PROP_SVGRESET
 #undef CSS_PROP_VARIABLES
-#ifdef DEFINED_CSS_PROP_BACKENDONLY
-#undef CSS_PROP_BACKENDONLY
-#undef DEFINED_CSS_PROP_BACKENDONLY
-#endif
 
 #else /* !defined(USED_CSS_PROP) */
 
 #ifdef DEFINED_CSS_PROP_FONT
 #undef CSS_PROP_FONT
 #undef DEFINED_CSS_PROP_FONT
 #endif
 #ifdef DEFINED_CSS_PROP_COLOR
@@ -4351,20 +4334,16 @@ CSS_PROP_FONT(
 #ifdef DEFINED_CSS_PROP_SVGRESET
 #undef CSS_PROP_SVGRESET
 #undef DEFINED_CSS_PROP_SVGRESET
 #endif
 #ifdef DEFINED_CSS_PROP_VARIABLES
 #undef CSS_PROP_VARIABLES
 #undef DEFINED_CSS_PROP_VARIABLES
 #endif
-#ifdef DEFINED_CSS_PROP_BACKENDONLY
-#undef CSS_PROP_BACKENDONLY
-#undef DEFINED_CSS_PROP_BACKENDONLY
-#endif
 
 #endif /* !defined(USED_CSS_PROP) */
 
 #ifdef DEFINED_CSS_PROP_SHORTHAND
 #undef CSS_PROP_SHORTHAND
 #undef DEFINED_CSS_PROP_SHORTHAND
 #endif
 #ifdef DEFINED_CSS_PROP_LOGICAL
diff --git a/layout/style/nsCSSProps.cpp b/layout/style/nsCSSProps.cpp
--- a/layout/style/nsCSSProps.cpp
+++ b/layout/style/nsCSSProps.cpp
@@ -2274,19 +2274,16 @@ bool nsCSSProps::GetColorName(int32_t aP
     aStr = nsCSSKeywords::GetStringValue(keyword);
     nsCSSKeywords::ReleaseTable();
     rv = true;
   }
   return rv;
 }
 
 const nsStyleStructID nsCSSProps::kSIDTable[eCSSProperty_COUNT_no_shorthands] = {
-    // Note that this uses the special BackendOnly style struct ID
-    // (which does need to be valid for storing in the
-    // nsCSSCompressedDataBlock::mStyleBits bitfield).
     #define CSS_PROP(name_, id_, method_, flags_, pref_, parsevariant_,     \
                      kwtable_, stylestruct_, stylestructoffset_, animtype_) \
         eStyleStruct_##stylestruct_,
     #define CSS_PROP_LIST_INCLUDE_LOGICAL
 
     #include "nsCSSPropList.h"
 
     #undef CSS_PROP_LIST_INCLUDE_LOGICAL
@@ -2967,30 +2964,26 @@ nsCSSProps::gPropertyCountInStruct[nsSty
     ePropertyCount_for_##name,
   #include "nsStyleStructList.h"
   #undef STYLE_STRUCT
 };
 
 /* static */ const size_t
 nsCSSProps::gPropertyIndexInStruct[eCSSProperty_COUNT_no_shorthands] = {
 
-  #define CSS_PROP_BACKENDONLY(name_, id_, method_, flags_, pref_, \
-                               parsevariant_, kwtable_)            \
-      size_t(-1),
   #define CSS_PROP_LOGICAL(name_, id_, method_, flags_, pref_, parsevariant_, \
                            kwtable_, group_, stylestruct_,                    \
                            stylestructoffset_, animtype_)                     \
       size_t(-1),
   #define CSS_PROP(name_, id_, method_, flags_, pref_, parsevariant_,     \
                    kwtable_, stylestruct_, stylestructoffset_, animtype_) \
     ePropertyIndex_for_##id_,
   #include "nsCSSPropList.h"
   #undef CSS_PROP
   #undef CSS_PROP_LOGICAL
-  #undef CSS_PROP_BACKENDONLY
 
 };
 
 /* static */ bool
 nsCSSProps::gPropertyEnabled[eCSSProperty_COUNT_with_aliases] = {
   // If the property has any "ENABLED_IN" flag set, it is disabled by
   // default. Note that, if a property has pref, whatever its default
   // value is, it will later be changed in nsCSSProps::AddRefTable().
diff --git a/layout/style/nsRuleData.h b/layout/style/nsRuleData.h
--- a/layout/style/nsRuleData.h
+++ b/layout/style/nsRuleData.h
@@ -71,18 +71,18 @@ struct nsRuleData
 
     nsStyleStructID sid = nsCSSProps::kSIDTable[aProperty];
     size_t indexInStruct = nsCSSProps::PropertyIndexInStruct(aProperty);
 
     // This should really be nsCachedStyleData::GetBitForSID, but we can't
     // include that here since it includes us.
     MOZ_ASSERT(mSIDs & (1 << sid),
                "calling nsRuleData::ValueFor on property not in mSIDs");
-    MOZ_ASSERT(sid != eStyleStruct_BackendOnly && indexInStruct != size_t(-1),
-               "backend-only or logical property");
+    MOZ_ASSERT(indexInStruct != size_t(-1),
+               "logical property");
 
     return mValueStorage + mValueOffsets[sid] + indexInStruct;
   }
 
   const nsCSSValue* ValueFor(nsCSSProperty aProperty) const {
     return const_cast<nsRuleData*>(this)->ValueFor(aProperty);
   }
 
@@ -100,32 +100,27 @@ struct nsRuleData
                    kwtable_, stylestruct_, stylestructoffset_, animtype_)    \
     nsCSSValue* ValueFor##method_() {                                        \
       MOZ_ASSERT(mSIDs & NS_STYLE_INHERIT_BIT(stylestruct_),                 \
                  "Calling nsRuleData::ValueFor" #method_ " without "         \
                  "NS_STYLE_INHERIT_BIT(" #stylestruct_ " in mSIDs.");        \
       nsStyleStructID sid = eStyleStruct_##stylestruct_;                     \
       size_t indexInStruct =                                                 \
         nsCSSProps::PropertyIndexInStruct(eCSSProperty_##id_);               \
-      MOZ_ASSERT(sid != eStyleStruct_BackendOnly &&                          \
-                 indexInStruct != size_t(-1),                                \
-                 "backend-only property");                                   \
+      MOZ_ASSERT(indexInStruct != size_t(-1),                                \
+                 "logical property");                                        \
       return mValueStorage + mValueOffsets[sid] + indexInStruct;             \
     }                                                                        \
     const nsCSSValue* ValueFor##method_() const {                            \
       return const_cast<nsRuleData*>(this)->ValueFor##method_();             \
     }
-  #define CSS_PROP_BACKENDONLY(name_, id_, method_, flags_, pref_,           \
-                             parsevariant_, kwtable_)                        \
-    /* empty; backend-only structs are not in nsRuleData  */
   #define CSS_PROP_LIST_EXCLUDE_LOGICAL
   #include "nsCSSPropList.h"
   #undef CSS_PROP_LIST_EXCLUDE_LOGICAL
   #undef CSS_PROP
   #undef CSS_PROP_PUBLIC_OR_PRIVATE
-  #undef CSS_PROP_BACKENDONLY
 
 private:
   inline size_t GetPoisonOffset();
 
 };
 
 #endif
diff --git a/layout/style/nsStyleStructFwd.h b/layout/style/nsStyleStructFwd.h
--- a/layout/style/nsStyleStructFwd.h
+++ b/layout/style/nsStyleStructFwd.h
@@ -49,22 +49,16 @@ nsStyleStructID_DUMMY2 = nsStyleStructID
 // one past the end; length of 0-based list
 nsStyleStructID_Length,
 
 nsStyleStructID_Inherited_Count =
   nsStyleStructID_Reset_Start - nsStyleStructID_Inherited_Start,
 nsStyleStructID_Reset_Count =
   nsStyleStructID_Length - nsStyleStructID_Reset_Start,
 
-// An ID used for properties that are not in style structs.  This is
-// used only in some users of nsStyleStructID, such as
-// nsCSSProps::kSIDTable, including some that store SIDs in a bitfield,
-// such as nsCSSCompressedDataBlock::mStyleBits.
-eStyleStruct_BackendOnly = nsStyleStructID_Length
-
 };
 
 // A bit corresponding to each struct ID
 #define NS_STYLE_INHERIT_BIT(sid_)        (1 << uint64_t(eStyleStruct_##sid_))
 
 typedef decltype(nsStyleStructID(0) + nsStyleStructID(0)) nsStyleStructID_size_t;
 
 #endif /* nsStyleStructFwd_h_ */
diff --git a/layout/style/test/test_bug1112014.html b/layout/style/test/test_bug1112014.html
--- a/layout/style/test/test_bug1112014.html
+++ b/layout/style/test/test_bug1112014.html
@@ -87,20 +87,16 @@ https://bugzilla.mozilla.org/show_bug.cg
 	reps.push(tc);
       }
     }
   }
   is(reps.join(","), "", "all types have representative test value");
 
   for (let propertyName in gCSSProperties) {
     let prop = gCSSProperties[propertyName];
-    if (prop.backend_only) {
-      // These aren't interesting to us.
-      continue;
-    }
 
     for (let iter in testValues) {
       let testValue = testValues[iter];
       if (propertyName in overrideValues &&
 	  iter in overrideValues[propertyName]) {
 	testValue = overrideValues[propertyName][iter];
       }
 
diff --git a/layout/style/test/test_ch_ex_no_infloops.html b/layout/style/test/test_ch_ex_no_infloops.html
--- a/layout/style/test/test_ch_ex_no_infloops.html
+++ b/layout/style/test/test_ch_ex_no_infloops.html
@@ -23,19 +23,16 @@ https://bugzilla.mozilla.org/show_bug.cg
  * sure they don't cause an infinite loop.
  */
 
 var content = document.getElementById("content");
 var cs = getComputedStyle(content, "");
 
 for (var prop in gCSSProperties) {
   var info = gCSSProperties[prop];
-  if (info.backend_only) {
-    continue;
-  }
   function test_val(v) {
     content.style.setProperty(prop, v, "");
     isnot(get_computed_value(cs, prop), "",
       "Setting '" + prop + "' to '" + v + "' should not cause infinite loop");
   }
   test_val('3ex');
   test_val('2ch');
   function test_replaced_values(value_list) {
diff --git a/layout/style/test/test_compute_data_with_start_struct.html b/layout/style/test/test_compute_data_with_start_struct.html
--- a/layout/style/test/test_compute_data_with_start_struct.html
+++ b/layout/style/test/test_compute_data_with_start_struct.html
@@ -61,25 +61,25 @@ var gRule2 = gStyleSheet.cssRules[gStyle
 
 var gBase = getComputedStyle(document.getElementById("base"), "");
 var gTest = getComputedStyle(document.getElementById("test"), "");
 
 function round(lower_set, higher_set, roundnum) {
 
   for (var prop in gCSSProperties) {
     var info = gCSSProperties[prop];
-    if (info.backend_only || info.subproperties || info.get_computed)
+    if (info.subproperties || info.get_computed)
       continue;
     gRule1.style.setProperty(prop, info[lower_set][0], "");
     gRule2.style.setProperty(prop, info[higher_set][0], "");
   }
 
   for (var prop in gCSSProperties) {
     var info = gCSSProperties[prop];
-    if (info.backend_only || info.subproperties || info.get_computed)
+    if (info.subproperties || info.get_computed)
       continue;
 
     if ("prerequisites" in info) {
       for (var prereq in info.prerequisites) {
         gRule2.style.setProperty(prereq, info.prerequisites[prereq], "");
       }
     }
 
diff --git a/layout/style/test/test_inherit_computation.html b/layout/style/test/test_inherit_computation.html
--- a/layout/style/test/test_inherit_computation.html
+++ b/layout/style/test/test_inherit_computation.html
@@ -42,18 +42,16 @@ function get_computed_value_node(node, p
 {
   var cs = getComputedStyle(node, "");
   return get_computed_value(cs, property);
 }
 
 function test_property(property)
 {
   var info = gCSSProperties[property];
-  if (info.backend_only)
-    return;
 
   var keywords = ["inherit"];
   if (info.inherited && gTestUnset)
     keywords.push("unset");
 
   keywords.forEach(function(keyword) {
     if ("prerequisites" in info) {
       var prereqs = info.prerequisites;
diff --git a/layout/style/test/test_initial_computation.html b/layout/style/test/test_initial_computation.html
--- a/layout/style/test/test_initial_computation.html
+++ b/layout/style/test/test_initial_computation.html
@@ -68,18 +68,16 @@ function setup_initial_values(id, ivalpr
   sheet.insertRule(":root { height: 200px; width: 500px }", sheet.cssRules.length);
 
   window[prereqprop] = sheet.cssRules[sheet.insertRule(":root > * {}", sheet.cssRules.length)];
 }
 
 function test_property(property)
 {
   var info = gCSSProperties[property];
-  if (info.backend_only)
-    return;
 
   var keywords = ["initial"];
   if (!info.inherited && gTestUnset)
     keywords.push("unset");
 
   keywords.forEach(function(keyword) {
     if ("prerequisites" in info) {
       var prereqs = info.prerequisites;
diff --git a/layout/style/test/test_value_cloning.html b/layout/style/test/test_value_cloning.html
--- a/layout/style/test/test_value_cloning.html
+++ b/layout/style/test/test_value_cloning.html
@@ -123,26 +123,21 @@ function iframe_loaded(event)
     var cur_ser = ifdoc.styleSheets[0].cssRules[3*idx+2].style.getPropertyValue(current_item.prop);
     if (cur_ser == "") {
       isnot(cur_ser, "",
 	    "serialization should be nonempty for " +
 	    current_item.prop + ": " + current_item.value);
     }
     start_ser.push(cur_ser);
 
-    var cur_compute;
-    if (!("backend_only" in info)) {
-      cur_compute = get_computed_value(cur_cs, current_item.prop);
-      if (cur_compute == "") {
-	isnot(cur_compute, "",
-	      "computed value should be nonempty for " +
-	      current_item.prop + ": " + current_item.value);
-      }
-    } else {
-      cur_compute = undefined;
+    var cur_compute = get_computed_value(cur_cs, current_item.prop);
+    if (cur_compute == "") {
+      isnot(cur_compute, "",
+            "computed value should be nonempty for " +
+            current_item.prop + ": " + current_item.value);
     }
     start_compute.push(cur_compute);
   }
 
   // In case the above access didn't force a clone already (though it
   // currently does), clone the second style sheet's inner and then
   // remove the first.
   ifdoc.styleSheets[1].insertRule("#nonexistent { color: red }", 0);
@@ -159,29 +154,27 @@ function iframe_loaded(event)
     var info = gCSSProperties[current_item.prop];
 
     var end_ser =
       ifdoc.styleSheets[0].cssRules[3*idx+3].style.getPropertyValue(current_item.prop);
     is(end_ser, start_ser[idx],
        "serialization should match when cloning " +
        current_item.prop + ": " + current_item.value);
 
-    if (!("backend_only" in info)) {
-      var end_compute = get_computed_value(test_cs[idx], current_item.prop);
-      // Output computed values only when the test failed.
-      // Computed values may be very long.
-      if (end_compute == start_compute[idx]) {
-        ok(true,
-           "computed values should match when cloning " +
-           current_item.prop + ": " + current_item.value);
-      } else {
-        is(end_compute, start_compute[idx],
-           "computed values should match when cloning " +
-           current_item.prop + ": " + current_item.value);
-      }
+    var end_compute = get_computed_value(test_cs[idx], current_item.prop);
+    // Output computed values only when the test failed.
+    // Computed values may be very long.
+    if (end_compute == start_compute[idx]) {
+      ok(true,
+         "computed values should match when cloning " +
+         current_item.prop + ": " + current_item.value);
+    } else {
+      is(end_compute, start_compute[idx],
+         "computed values should match when cloning " +
+         current_item.prop + ": " + current_item.value);
     }
   }
 
   SimpleTest.finish();
 }
 
 </script>
 </pre>
diff --git a/layout/style/test/test_value_computation.html b/layout/style/test/test_value_computation.html
--- a/layout/style/test/test_value_computation.html
+++ b/layout/style/test/test_value_computation.html
@@ -143,18 +143,16 @@ function setup_initial_values(id, ivalpr
   sheet.insertRule(":root { height: 200px; width: 500px }", sheet.cssRules.length);
 
   window[prereqprop] = sheet.cssRules[sheet.insertRule(":root > * {}", sheet.cssRules.length)];
 }
 
 function test_value(property, val, is_initial)
 {
   var info = gCSSProperties[property];
-  if (info.backend_only)
-    return;
 
   if ("prerequisites" in info) {
     var prereqs = info.prerequisites;
     for (var prereq in prereqs) {
       gRule1.style.setProperty(prereq, prereqs[prereq], "");
       gInitialPrereqsRuleN.style.setProperty(prereq, prereqs[prereq], "");
       gInitialPrereqsRuleF.style.setProperty(prereq, prereqs[prereq], "");
     }
diff --git a/layout/style/test/test_value_storage.html b/layout/style/test/test_value_storage.html
--- a/layout/style/test/test_value_storage.html
+++ b/layout/style/test/test_value_storage.html
@@ -106,18 +106,16 @@ function are_properties_aliased(propA, p
 
   return propA == propB;
 }
 
 function test_property(property)
 {
   var info = gCSSProperties[property];
 
-  var test_computed = !("backend_only" in info);
-
   // can all properties be removed from the style?
   function test_remove_all_properties(property, value) {
     var i, p = [];
     for (i = 0; i < gDeclaration.length; i++) p.push(gDeclaration[i]);
     for (i = 0; i < p.length; i++) gDeclaration.removeProperty(p[i]);
     var errstr = "when setting property " + property + " to " + value;
     is(gDeclaration.length, 0, "unremovable properties " + errstr);
     is(gDeclaration.cssText, "", "non-empty serialization after removing all properties " + errstr);
@@ -146,19 +144,19 @@ function test_property(property)
     var step1val = gDeclaration.getPropertyValue(property);
     var step1vals = [];
     var step1ser = gDeclaration.cssText;
     if ("subproperties" in info)
       for (idx in info.subproperties)
         step1vals.push(gDeclaration.getPropertyValue(info.subproperties[idx]));
     var step1comp;
     var step1comps = [];
-    if (test_computed && info.type != CSS_TYPE_TRUE_SHORTHAND)
+    if (info.type != CSS_TYPE_TRUE_SHORTHAND)
       step1comp = gComputedStyle.getPropertyValue(property);
-    if (test_computed && "subproperties" in info)
+    if ("subproperties" in info)
       for (idx in info.subproperties)
         step1comps.push(gComputedStyle.getPropertyValue(info.subproperties[idx]));
 
     isnot(step1val, "", "setting '" + value + "' on '" + property + "'");
     if ("subproperties" in info)
       for (idx in info.subproperties) {
         var subprop = info.subproperties[idx];
         if (value_has_variable_reference &&
@@ -186,17 +184,17 @@ function test_property(property)
        "serialization should match property value");
 
     gDeclaration.removeProperty(property);
     gDeclaration.setProperty(property, step1val, "");
 
     is(gDeclaration.getPropertyValue(property), step1val,
        "parse+serialize should be idempotent for '" +
          property + ": " + value + "'");
-    if (test_computed && info.type != CSS_TYPE_TRUE_SHORTHAND) {
+    if (info.type != CSS_TYPE_TRUE_SHORTHAND) {
       is(gComputedStyle.getPropertyValue(property), step1comp,
          "serialize+parse should be identity transform for '" +
          property + ": " + value + "'");
     }
 
     if ("subproperties" in info &&
         // Using setProperty over subproperties is not sufficient for
         // system fonts, since the shorthand does more than its parts.
@@ -210,51 +208,45 @@ function test_property(property)
         gDeclaration.setProperty(subprop, step1vals[idx], "");
       }
 
       // Now that all the subprops are set, check their values.  Note that we
       // need this in a separate loop, in case parts of the shorthand affect
       // the computed values of other parts.
       for (idx in info.subproperties) {
         var subprop = info.subproperties[idx];
-        if (test_computed && !("backend_only" in gCSSProperties[subprop])) {
-          is(gComputedStyle.getPropertyValue(subprop), step1comps[idx],
-             "serialize(" + subprop + ")+parse should be the identity " +
-             "transform for '" + property + ": " + value + "'");
-        }
+        is(gComputedStyle.getPropertyValue(subprop), step1comps[idx],
+           "serialize(" + subprop + ")+parse should be the identity " +
+           "transform for '" + property + ": " + value + "'");
       }
       is(gDeclaration.getPropertyValue(property), step1val,
          "parse+split+serialize should be idempotent for '" +
          property + ": " + value + "'");
     }
 
-    if (test_computed && info.type != CSS_TYPE_TRUE_SHORTHAND) {
+    if (info.type != CSS_TYPE_TRUE_SHORTHAND) {
       gDeclaration.removeProperty(property);
       gDeclaration.setProperty(property, step1comp, "");
       var func = xfail_compute(property, value) ? todo_is : is;
       func(gComputedStyle.getPropertyValue(property), step1comp,
            "parse+compute+serialize should be idempotent for '" +
            property + ": " + value + "'");
     }
-    if (test_computed && "subproperties" in info) {
+    if ("subproperties" in info) {
       gDeclaration.removeProperty(property);
       for (idx in info.subproperties) {
         var subprop = info.subproperties[idx];
-        if ("backend_only" in gCSSProperties[subprop])
-          continue;
         gDeclaration.setProperty(subprop, step1comps[idx], "");
       }
 
       // Now that all the subprops are set, check their values.  Note that we
       // need this in a separate loop, in case parts of the shorthand affect
       // the computed values of other parts.
       for (idx in info.subproperties) {
         var subprop = info.subproperties[idx];
-        if ("backend_only" in gCSSProperties[subprop])
-          continue;
         is(gComputedStyle.getPropertyValue(subprop), step1comps[idx],
            "parse+compute+serialize(" + subprop + ") should be idempotent for '" +
            property + ": " + value + "'");
       }
     }
 
     // sanity check shorthands to make sure disabled props aren't exposed
     if (info.type != CSS_TYPE_LONGHAND) {
