From: L. David Baron <dbaron@dbaron.org>

Add a (wrapping) display item that clips its contents to the curvature of a border-radius.  (Bug 485501)  (FIXME: WRITE THE REST)

diff --git a/layout/base/nsDisplayItemTypes.h b/layout/base/nsDisplayItemTypes.h
--- a/layout/base/nsDisplayItemTypes.h
+++ b/layout/base/nsDisplayItemTypes.h
@@ -57,16 +57,17 @@ enum Type {
   TYPE_CANVAS,
   TYPE_CANVAS_BACKGROUND,
   TYPE_CANVAS_FOCUS,
   TYPE_CARET,
   TYPE_CHANGE_COLOR_CORRECTION,
   TYPE_CHECKED_CHECKBOX,
   TYPE_CHECKED_RADIOBUTTON,
   TYPE_CLIP,
+  TYPE_CLIP_BORDER_RADIUS,
   TYPE_COLUMN_RULE,
   TYPE_COMBOBOX_FOCUS,
   TYPE_EVENT_RECEIVER,
   TYPE_FIELDSET_BORDER_BACKGROUND,
   TYPE_FRAMESET_BORDER,
   TYPE_FRAMESET_BLANK,
   TYPE_HEADER_FOOTER,
   TYPE_IMAGE,
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -1327,28 +1327,124 @@ PRBool nsDisplayClip::ComputeVisibility(
   return anyVisible;
 }
 
 PRBool nsDisplayClip::TryMerge(nsDisplayListBuilder* aBuilder,
                                nsDisplayItem* aItem) {
   if (aItem->GetType() != TYPE_CLIP)
     return PR_FALSE;
   nsDisplayClip* other = static_cast<nsDisplayClip*>(aItem);
+  // FIXME: Why don't we need to compare mFrame?
   if (other->mClip != mClip || other->mClippingFrame != mClippingFrame)
     return PR_FALSE;
   mList.AppendToBottom(&other->mList);
   return PR_TRUE;
 }
 
 nsDisplayWrapList* nsDisplayClip::WrapWithClone(nsDisplayListBuilder* aBuilder,
                                                 nsDisplayItem* aItem) {
   return new (aBuilder)
     nsDisplayClip(aBuilder, aItem->GetUnderlyingFrame(), mClippingFrame, aItem, mClip);
 }
 
+nsDisplayClipBorderRadius::nsDisplayClipBorderRadius(
+                             nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                             nsDisplayList* aList, ClipType aClipType)
+    : nsDisplayWrapList(aBuilder, aFrame, aList)
+{
+  MOZ_COUNT_CTOR(nsDisplayClipBorderRadius);
+
+  nsRect box;
+  nsMargin offsets;
+  if (aClipType == PADDING_BOX) {
+    box = aFrame->GetPaddingRect();
+    offsets = aFrame->GetUsedBorder();
+  } else {
+    NS_ABORT_IF_FALSE(aClipType == CONTENT_BOX, "unknown value");
+    box = aFrame->GetContentRect();
+    offsets = aFrame->GetUsedBorderAndPadding();
+  }
+
+  mBounds = box - aFrame->GetPosition() + ToReferenceFrame();
+  aFrame->GetBorderRadii(mRadii);
+  nsIFrame::MoveBorderRadiiIn(mRadii, offsets);
+}
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+nsDisplayClipBorderRadius::~nsDisplayClipBorderRadius()
+{
+  MOZ_COUNT_DTOR(nsDisplayClipBorderRadius);
+}
+#endif
+
+PRBool nsDisplayClipBorderRadius::IsOpaque(nsDisplayListBuilder* aBuilder)
+{
+  return PR_FALSE;
+}
+
+void
+nsDisplayClipBorderRadius::HitTest(nsDisplayListBuilder* aBuilder,
+                                   const nsRect& aRect, HitTestState* aState,
+                                   nsTArray<nsIFrame*> *aOutFrames)
+{
+  // FIXME: Consider border-radius.
+  mList.HitTest(aBuilder, aRect, aState, aOutFrames);
+}
+
+void
+nsDisplayClipBorderRadius::Paint(nsDisplayListBuilder* aBuilder,
+                                 nsIRenderingContext* aCtx)
+{
+  PRInt32 appUnitsPerPixel = mFrame->PresContext()->AppUnitsPerDevPixel();
+
+  gfxCornerSizes pixelRadii;
+  nsCSSRendering::ComputePixelRadii(mRadii, appUnitsPerPixel, &pixelRadii);
+
+  gfxRect contentArea(nsLayoutUtils::RectToGfxRect(mBounds, appUnitsPerPixel));
+  contentArea.Round();
+  contentArea.Condition();
+
+  if (contentArea.IsEmpty()) {
+    return;
+  }
+
+  gfxContext *ctx = aCtx->ThebesContext();
+  gfxContextAutoSaveRestore autoSR(ctx);
+  ctx->NewPath();
+  ctx->RoundedRectangle(contentArea, pixelRadii);
+  ctx->Clip();
+
+  mList.PaintForFrame(aBuilder, aCtx, mFrame,
+                      nsDisplayList::PAINT_DEFAULT);
+}
+
+PRBool nsDisplayClipBorderRadius::ComputeVisibility(
+                                    nsDisplayListBuilder* aBuilder,
+                                    nsRegion* aVisibleRegion)
+{
+  nsRegion clipped;
+  clipped.And(*aVisibleRegion, mBounds);
+
+  return nsDisplayWrapList::ComputeVisibility(aBuilder, &clipped);
+  // FIXME: Remove a *conservative* opaque region from aVisibleRegion
+  // (like in nsDisplayClip::ComputeVisibility).
+}
+
+PRBool nsDisplayClipBorderRadius::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
+{
+  if (aItem->GetType() != TYPE_CLIP_BORDER_RADIUS)
+    return PR_FALSE;
+  nsDisplayClipBorderRadius* other =
+    static_cast<nsDisplayClipBorderRadius*>(aItem);
+  if (mBounds != other->mBounds || mRadii != other->mRadii)
+    return PR_FALSE;
+  mList.AppendToBottom(&other->mList);
+  return PR_TRUE;
+}
+
 nsDisplayZoom::nsDisplayZoom(nsDisplayListBuilder* aBuilder,
                              nsIFrame* aFrame, nsDisplayList* aList,
                              PRInt32 aAPD, PRInt32 aParentAPD)
     : nsDisplayOwnLayer(aBuilder, aFrame, aList), mAPD(aAPD),
       mParentAPD(aParentAPD) {
   MOZ_COUNT_CTOR(nsDisplayZoom);
 }
 
diff --git a/layout/base/nsDisplayList.h b/layout/base/nsDisplayList.h
--- a/layout/base/nsDisplayList.h
+++ b/layout/base/nsDisplayList.h
@@ -1297,16 +1297,17 @@ public:
   virtual ~nsDisplayBackground() {
     MOZ_COUNT_DTOR(nsDisplayBackground);
   }
 #endif
 
   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames)
   {
+    // FIXME: Consider border-radius.
     aOutFrames->AppendElement(mFrame);
   }
   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
                                    nsRegion* aVisibleRegion);
   virtual PRBool IsOpaque(nsDisplayListBuilder* aBuilder);
   virtual PRBool IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
                                                 nsIFrame* aFrame);
   virtual PRBool IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor);
@@ -1404,16 +1405,17 @@ public:
   virtual ~nsDisplayEventReceiver() {
     MOZ_COUNT_DTOR(nsDisplayEventReceiver);
   }
 #endif
 
   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames)
   {
+    // FIXME: Consider border-radius.
     aOutFrames->AppendElement(mFrame);
   }
   NS_DISPLAY_DECL_NAME("EventReceiver", TYPE_EVENT_RECEIVER)
 };
 
 /**
  * A class that lets you wrap a display list as a display item.
  * 
@@ -1605,16 +1607,47 @@ private:
   // from mFrame because mFrame represents the content that is being
   // clipped, and for example may be used to obtain the z-index of the
   // content.
   nsIFrame* mClippingFrame;
   nsRect    mClip;
 };
 
 /**
+ * A display item to clip a list of items to the border-radius of a
+ * frame.
+ */
+class nsDisplayClipBorderRadius : public nsDisplayWrapList {
+public:
+  enum ClipType { PADDING_BOX, CONTENT_BOX };
+  // FIXME: Need two frame inputs, like nsDisplayClip
+  nsDisplayClipBorderRadius(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                            nsDisplayList* aList, ClipType aClipType);
+#ifdef NS_BUILD_REFCNT_LOGGING
+  virtual ~nsDisplayClipBorderRadius();
+#endif
+
+  virtual PRBool IsOpaque(nsDisplayListBuilder* aBuilder);
+  virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
+                       HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames);
+  virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
+    return mBounds;
+  }
+  virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx);
+  virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
+                                   nsRegion* aVisibleRegion);
+  virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
+  NS_DISPLAY_DECL_NAME("ClipBorderRadius", TYPE_CLIP_BORDER_RADIUS)
+
+private:
+  nsRect mBounds;
+  nscoord mRadii[8];
+};
+
+/**
  * nsDisplayZoom is used for subdocuments that have a different full zoom than
  * their parent documents. This item creates a container layer.
  */
 class nsDisplayZoom : public nsDisplayOwnLayer {
 public:
   /**
    * @param aFrame is the root frame of the subdocument.
    * @param aList contains the display items for the subdocument.
