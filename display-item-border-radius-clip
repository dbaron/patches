From: L. David Baron <dbaron@dbaron.org>

Add a (wrapping) display item that clips its contents to the curvature of a border-radius.  (Bug 485501)  (FIXME: WRITE THE REST)

diff --git a/layout/base/nsDisplayItemTypes.h b/layout/base/nsDisplayItemTypes.h
--- a/layout/base/nsDisplayItemTypes.h
+++ b/layout/base/nsDisplayItemTypes.h
@@ -57,16 +57,17 @@ enum Type {
   TYPE_CANVAS,
   TYPE_CANVAS_BACKGROUND,
   TYPE_CANVAS_FOCUS,
   TYPE_CARET,
   TYPE_CHANGE_COLOR_CORRECTION,
   TYPE_CHECKED_CHECKBOX,
   TYPE_CHECKED_RADIOBUTTON,
   TYPE_CLIP,
+  TYPE_CLIP_BORDER_RADIUS,
   TYPE_COLUMN_RULE,
   TYPE_COMBOBOX_FOCUS,
   TYPE_EVENT_RECEIVER,
   TYPE_FIELDSET_BORDER_BACKGROUND,
   TYPE_FRAMESET_BORDER,
   TYPE_FRAMESET_BLANK,
   TYPE_HEADER_FOOTER,
   TYPE_IMAGE,
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -1339,16 +1339,108 @@ PRBool nsDisplayClip::TryMerge(nsDisplay
 }
 
 nsDisplayWrapList* nsDisplayClip::WrapWithClone(nsDisplayListBuilder* aBuilder,
                                                 nsDisplayItem* aItem) {
   return new (aBuilder)
     nsDisplayClip(aBuilder, aItem->GetUnderlyingFrame(), aItem, mClip);
 }
 
+nsDisplayClipBorderRadius::nsDisplayClipBorderRadius(
+                             nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                             nsDisplayItem* aItem,
+                             const nsRect& aRect, nscoord aRadii[8])
+    : nsDisplayWrapList(aBuilder, aFrame, aItem), 
+      mBounds(aRect), mRadii(aRadii)
+{
+  MOZ_COUNT_CTOR(nsDisplayClipBorderRadius);
+}
+
+nsDisplayClipBorderRadius::nsDisplayClipBorderRadius(
+                             nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                             nsDisplayList* aList,
+                             const nsRect& aRect, nscoord aRadii[8])
+    : nsDisplayWrapList(aBuilder, aFrame, aList), 
+      mBounds(aRect), mRadii(aRadii)
+{
+  MOZ_COUNT_CTOR(nsDisplayClipBorderRadius);
+}
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+nsDisplayClipBorderRadius::~nsDisplayClipBorderRadius()
+{
+  MOZ_COUNT_DTOR(nsDisplayClipBorderRadius);
+}
+#endif
+
+PRBool nsDisplayClipBorderRadius::IsOpaque(nsDisplayListBuilder* aBuilder)
+{
+  return PR_FALSE;
+}
+
+void
+nsDisplayClipBorderRadius::HitTest(nsDisplayListBuilder* aBuilder,
+                                   const nsRect& aRect, HitTestState* aState,
+                                   nsTArray<nsIFrame*> *aOutFrames)
+{
+  // FIXME: Consider border-radius.
+  mList.HitTest(aBuilder, aRect, aState, aOutFrames);
+}
+
+void
+nsDisplayClipBorderRadius::Paint(nsDisplayListBuilder* aBuilder,
+                                 nsIRenderingContext* aCtx)
+{
+  PRInt32 appUnitsPerPixel = mFrame->PresContext()->AppUnitsPerDevPixel();
+
+  gfxCornerSizes pixelRadii;
+  nsCSSRendering::ComputePixelRadii(mRadii, appUnitsPerPixel, &pixelRadii);
+
+  gfxRect contentArea(nsLayoutUtils::RectToGfxRect(mBounds, appUnitsPerPixel));
+  contentArea.Round();
+  contentArea.Condition();
+
+  if (contentArea.IsEmpty()) {
+    return;
+  }
+
+  gfxContext *ctx = aCtx->ThebesContext();
+  gfxContextAutoSaveRestore autoSR(ctx);
+  ctx->NewPath();
+  ctx->RoundedRectangle(contentArea, pixelRadii);
+  ctx->Clip();
+
+  mList.PaintForFrame(aBuilder, aCtx, mFrame,
+                      nsDisplayList::PAINT_DEFAULT);
+}
+
+PRBool nsDisplayClipBorderRadius::ComputeVisibility(
+                                    nsDisplayListBuilder* aBuilder,
+                                    nsRegion* aVisibleRegion)
+{
+  nsRegion clipped;
+  clipped.And(*aVisibleRegion, mBounds);
+
+  return nsDisplayWrapList::ComputeVisibility(aBuilder, &clipped);
+  // FIXME: Remove a *conservative* opaque region from aVisibleRegion
+  // (like in nsDisplayClip::ComputeVisibility).
+}
+
+PRBool nsDisplayClipBorderRadius::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
+{
+  if (aItem->GetType() != TYPE_CLIP_BORDER_RADIUS)
+    return PR_FALSE;
+  nsDisplayClipBorderRadius* other =
+    static_cast<nsDisplayClipBorderRadius*>(aItem);
+  if (mBounds != other->mBounds || mRadii != other->mRadii)
+    return PR_FALSE;
+  mList.AppendToBottom(&other->mList);
+  return PR_TRUE;
+}
+
 nsDisplayZoom::nsDisplayZoom(nsDisplayListBuilder* aBuilder,
                              nsIFrame* aFrame, nsDisplayList* aList,
                              PRInt32 aAPD, PRInt32 aParentAPD)
     : nsDisplayOwnLayer(aBuilder, aFrame, aList), mAPD(aAPD),
       mParentAPD(aParentAPD) {
   MOZ_COUNT_CTOR(nsDisplayZoom);
 }
 
diff --git a/layout/base/nsDisplayList.h b/layout/base/nsDisplayList.h
--- a/layout/base/nsDisplayList.h
+++ b/layout/base/nsDisplayList.h
@@ -1297,16 +1297,17 @@ public:
   virtual ~nsDisplayBackground() {
     MOZ_COUNT_DTOR(nsDisplayBackground);
   }
 #endif
 
   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames)
   {
+    // FIXME: Consider border-radius.
     aOutFrames->AppendElement(mFrame);
   }
   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
                                    nsRegion* aVisibleRegion);
   virtual PRBool IsOpaque(nsDisplayListBuilder* aBuilder);
   virtual PRBool IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
                                                 nsIFrame* aFrame);
   virtual PRBool IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor);
@@ -1404,16 +1405,17 @@ public:
   virtual ~nsDisplayEventReceiver() {
     MOZ_COUNT_DTOR(nsDisplayEventReceiver);
   }
 #endif
 
   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames)
   {
+    // FIXME: Consider border-radius.
     aOutFrames->AppendElement(mFrame);
   }
   NS_DISPLAY_DECL_NAME("EventReceiver", TYPE_EVENT_RECEIVER)
 };
 
 /**
  * A class that lets you wrap a display list as a display item.
  * 
@@ -1597,16 +1599,54 @@ public:
   virtual nsDisplayWrapList* WrapWithClone(nsDisplayListBuilder* aBuilder,
                                            nsDisplayItem* aItem);
 
 private:
   nsRect    mClip;
 };
 
 /**
+ * A display item to clip a list of items to the border-radius of a
+ * frame.
+ */
+class nsDisplayClipBorderRadius : public nsDisplayWrapList {
+public:
+  /**
+   * @param aFrame the frame that should be considered the underlying
+   * frame for this content, e.g. the frame whose z-index we have.  This
+   * is *not* the frame that is inducing the clipping.
+   */
+  nsDisplayClipBorderRadius(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                            nsDisplayItem* aItem,
+                            const nsRect& aRect, nscoord aRadii[8])
+  nsDisplayClipBorderRadius(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                            nsDisplayList* aList,
+                            const nsRect& aRect, nscoord aRadii[8])
+#ifdef NS_BUILD_REFCNT_LOGGING
+  virtual ~nsDisplayClipBorderRadius();
+#endif
+
+  virtual PRBool IsOpaque(nsDisplayListBuilder* aBuilder);
+  virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
+                       HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames);
+  virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
+    return mBounds;
+  }
+  virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx);
+  virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
+                                   nsRegion* aVisibleRegion);
+  virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
+  NS_DISPLAY_DECL_NAME("ClipBorderRadius", TYPE_CLIP_BORDER_RADIUS)
+
+private:
+  nsRect mBounds;
+  nscoord mRadii[8];
+};
+
+/**
  * nsDisplayZoom is used for subdocuments that have a different full zoom than
  * their parent documents. This item creates a container layer.
  */
 class nsDisplayZoom : public nsDisplayOwnLayer {
 public:
   /**
    * @param aFrame is the root frame of the subdocument.
    * @param aList contains the display items for the subdocument.
