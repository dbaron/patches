From: L. David Baron <dbaron@dbaron.org>

Add a (wrapping) display item that clips its contents to the curvature of a border-radius.  (Bug 459144)  (FIXME: WRITE THE REST)

diff --git a/layout/base/nsDisplayItemTypes.h b/layout/base/nsDisplayItemTypes.h
--- a/layout/base/nsDisplayItemTypes.h
+++ b/layout/base/nsDisplayItemTypes.h
@@ -57,16 +57,17 @@ enum Type {
   TYPE_CANVAS,
   TYPE_CANVAS_BACKGROUND,
   TYPE_CANVAS_FOCUS,
   TYPE_CARET,
   TYPE_CHANGE_COLOR_CORRECTION,
   TYPE_CHECKED_CHECKBOX,
   TYPE_CHECKED_RADIOBUTTON,
   TYPE_CLIP,
+  TYPE_CLIP_ROUNDED_RECT,
   TYPE_COLUMN_RULE,
   TYPE_COMBOBOX_FOCUS,
   TYPE_EVENT_RECEIVER,
   TYPE_FIELDSET_BORDER_BACKGROUND,
   TYPE_FRAMESET_BORDER,
   TYPE_FRAMESET_BLANK,
   TYPE_HEADER_FOOTER,
   TYPE_IMAGE,
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -1347,16 +1347,121 @@ PRBool nsDisplayClip::TryMerge(nsDisplay
 }
 
 nsDisplayWrapList* nsDisplayClip::WrapWithClone(nsDisplayListBuilder* aBuilder,
                                                 nsDisplayItem* aItem) {
   return new (aBuilder)
     nsDisplayClip(aBuilder, aItem->GetUnderlyingFrame(), aItem, mClip);
 }
 
+nsDisplayClipRoundedRect::nsDisplayClipRoundedRect(
+                             nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                             nsDisplayItem* aItem, nsIFrame* aClippingFrame,
+                             const nsRect& aRect, nscoord aRadii[8])
+    : nsDisplayWrapList(aBuilder, aFrame, aItem), 
+      mClippingFrame(aClippingFrame),
+      mBounds(aRect)
+{
+  MOZ_COUNT_CTOR(nsDisplayClipRoundedRect);
+  memcpy(mRadii, aRadii, sizeof(mRadii));
+}
+
+nsDisplayClipRoundedRect::nsDisplayClipRoundedRect(
+                             nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                             nsDisplayList* aList, nsIFrame* aClippingFrame,
+                             const nsRect& aRect, nscoord aRadii[8])
+    : nsDisplayWrapList(aBuilder, aFrame, aList), 
+      mClippingFrame(aClippingFrame),
+      mBounds(aRect)
+{
+  MOZ_COUNT_CTOR(nsDisplayClipRoundedRect);
+  memcpy(mRadii, aRadii, sizeof(mRadii));
+}
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+nsDisplayClipRoundedRect::~nsDisplayClipRoundedRect()
+{
+  MOZ_COUNT_DTOR(nsDisplayClipRoundedRect);
+}
+#endif
+
+PRBool nsDisplayClipRoundedRect::IsOpaque(nsDisplayListBuilder* aBuilder)
+{
+  return PR_FALSE;
+}
+
+void
+nsDisplayClipRoundedRect::HitTest(nsDisplayListBuilder* aBuilder,
+                                  const nsRect& aRect, HitTestState* aState,
+                                  nsTArray<nsIFrame*> *aOutFrames)
+{
+  // FIXME: Consider border-radius.
+  mList.HitTest(aBuilder, aRect, aState, aOutFrames);
+}
+
+nsDisplayWrapList*
+nsDisplayClipRoundedRect::WrapWithClone(nsDisplayListBuilder* aBuilder,
+                                        nsDisplayItem* aItem) {
+  return new (aBuilder)
+    nsDisplayClipRoundedRect(aBuilder, aItem->GetUnderlyingFrame(), aItem,
+                             mClippingFrame, mBounds, mRadii);
+}
+
+void
+nsDisplayClipRoundedRect::Paint(nsDisplayListBuilder* aBuilder,
+                                nsIRenderingContext* aCtx)
+{
+  PRInt32 A2D = mClippingFrame->PresContext()->AppUnitsPerDevPixel();
+
+  gfxCornerSizes pixelRadii;
+  nsCSSRendering::ComputePixelRadii(mRadii, A2D, &pixelRadii);
+
+  gfxRect contentArea(nsLayoutUtils::RectToGfxRect(mBounds, A2D));
+  contentArea.Round();
+  contentArea.Condition();
+
+  if (contentArea.IsEmpty()) {
+    return;
+  }
+
+  gfxContext *ctx = aCtx->ThebesContext();
+  gfxContextAutoSaveRestore autoSR(ctx);
+  ctx->NewPath();
+  ctx->RoundedRectangle(contentArea, pixelRadii);
+  ctx->Clip();
+
+  mList.PaintForFrame(aBuilder, aCtx, mClippingFrame,
+                      nsDisplayList::PAINT_DEFAULT);
+}
+
+PRBool nsDisplayClipRoundedRect::ComputeVisibility(
+                                    nsDisplayListBuilder* aBuilder,
+                                    nsRegion* aVisibleRegion)
+{
+  nsRegion clipped;
+  clipped.And(*aVisibleRegion, mBounds);
+
+  return nsDisplayWrapList::ComputeVisibility(aBuilder, &clipped);
+  // FIXME: Remove a *conservative* opaque region from aVisibleRegion
+  // (like in nsDisplayClip::ComputeVisibility).
+}
+
+PRBool nsDisplayClipRoundedRect::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
+{
+  if (aItem->GetType() != TYPE_CLIP_ROUNDED_RECT)
+    return PR_FALSE;
+  nsDisplayClipRoundedRect* other =
+    static_cast<nsDisplayClipRoundedRect*>(aItem);
+  if (mClippingFrame != other->mClippingFrame ||
+      mBounds != other->mBounds || mRadii != other->mRadii)
+    return PR_FALSE;
+  mList.AppendToBottom(&other->mList);
+  return PR_TRUE;
+}
+
 nsDisplayZoom::nsDisplayZoom(nsDisplayListBuilder* aBuilder,
                              nsIFrame* aFrame, nsDisplayList* aList,
                              PRInt32 aAPD, PRInt32 aParentAPD)
     : nsDisplayOwnLayer(aBuilder, aFrame, aList), mAPD(aAPD),
       mParentAPD(aParentAPD) {
   MOZ_COUNT_CTOR(nsDisplayZoom);
 }
 
diff --git a/layout/base/nsDisplayList.h b/layout/base/nsDisplayList.h
--- a/layout/base/nsDisplayList.h
+++ b/layout/base/nsDisplayList.h
@@ -474,17 +474,17 @@ public:
   virtual Type GetType() = 0;
   /**
    * If this returns a non-zero value, then pairing this with the
    * GetUnderlyingFrame() pointer gives a key that uniquely identifies
    * this display item in the display item tree.
    * This will only return a zero value for items which wrap display lists
    * and do not create a CSS stacking context, therefore requiring
    * display items to be individually wrapped --- currently nsDisplayClip
-   * only.
+   * and nsDisplayClipRoundedRect only.
    */
   virtual PRUint32 GetPerFrameKey() { return PRUint32(GetType()); }
   /**
    * This is called after we've constructed a display list for event handling.
    * When this is called, we've already ensured that aRect intersects the
    * item's bounds.
    * 
    * @param aState must point to a HitTestState. If you don't have one,
@@ -1303,16 +1303,17 @@ public:
   virtual ~nsDisplayBackground() {
     MOZ_COUNT_DTOR(nsDisplayBackground);
   }
 #endif
 
   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames)
   {
+    // FIXME: Consider border-radius.
     aOutFrames->AppendElement(mFrame);
   }
   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
                                    nsRegion* aVisibleRegion);
   virtual PRBool IsOpaque(nsDisplayListBuilder* aBuilder);
   virtual PRBool IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
                                                 nsIFrame* aFrame);
   virtual PRBool IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor);
@@ -1410,16 +1411,17 @@ public:
   virtual ~nsDisplayEventReceiver() {
     MOZ_COUNT_DTOR(nsDisplayEventReceiver);
   }
 #endif
 
   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames)
   {
+    // FIXME: Consider border-radius.
     aOutFrames->AppendElement(mFrame);
   }
   NS_DISPLAY_DECL_NAME("EventReceiver", TYPE_EVENT_RECEIVER)
 };
 
 /**
  * A class that lets you wrap a display list as a display item.
  * 
@@ -1603,16 +1605,59 @@ public:
   virtual nsDisplayWrapList* WrapWithClone(nsDisplayListBuilder* aBuilder,
                                            nsDisplayItem* aItem);
 
 private:
   nsRect    mClip;
 };
 
 /**
+ * A display item to clip a list of items to the border-radius of a
+ * frame.
+ */
+class nsDisplayClipRoundedRect : public nsDisplayWrapList {
+public:
+  /**
+   * @param aFrame the frame that should be considered the underlying
+   * frame for this content, e.g. the frame whose z-index we have.  This
+   * is *not* the frame that is inducing the clipping.
+   */
+  nsDisplayClipRoundedRect(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                           nsDisplayItem* aItem, nsIFrame* aClippingFrame,
+                           const nsRect& aRect, nscoord aRadii[8]);
+  nsDisplayClipRoundedRect(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                           nsDisplayList* aList, nsIFrame* aClippingFrame,
+                           const nsRect& aRect, nscoord aRadii[8]);
+#ifdef NS_BUILD_REFCNT_LOGGING
+  virtual ~nsDisplayClipRoundedRect();
+#endif
+
+  virtual PRBool IsOpaque(nsDisplayListBuilder* aBuilder);
+  virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
+                       HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames);
+  virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
+    return mBounds;
+  }
+  virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx);
+  virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
+                                   nsRegion* aVisibleRegion);
+  virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
+  NS_DISPLAY_DECL_NAME("ClipRoundedRect", TYPE_CLIP_ROUNDED_RECT)
+  virtual PRUint32 GetPerFrameKey() { return 0; }
+
+  virtual nsDisplayWrapList* WrapWithClone(nsDisplayListBuilder* aBuilder,
+                                           nsDisplayItem* aItem);
+
+private:
+  nsIFrame* mClippingFrame;
+  nsRect mBounds;
+  nscoord mRadii[8];
+};
+
+/**
  * nsDisplayZoom is used for subdocuments that have a different full zoom than
  * their parent documents. This item creates a container layer.
  */
 class nsDisplayZoom : public nsDisplayOwnLayer {
 public:
   /**
    * @param aFrame is the root frame of the subdocument.
    * @param aList contains the display items for the subdocument.
