From: L. David Baron <dbaron@dbaron.org>

Add a (wrapping) display item that clips its contents to the curvature of a border-radius.  (Bug 459144)

diff --git a/layout/base/FrameLayerBuilder.cpp b/layout/base/FrameLayerBuilder.cpp
--- a/layout/base/FrameLayerBuilder.cpp
+++ b/layout/base/FrameLayerBuilder.cpp
@@ -38,16 +38,17 @@
 #include "FrameLayerBuilder.h"
 
 #include "nsDisplayList.h"
 #include "nsPresContext.h"
 #include "nsLayoutUtils.h"
 #include "Layers.h"
 #include "BasicLayers.h"
 #include "nsSubDocumentFrame.h"
+#include "nsCSSRendering.h"
 
 #ifdef DEBUG
 #include <stdio.h>
 #endif
 
 using namespace mozilla::layers;
 
 namespace mozilla {
@@ -131,17 +132,17 @@ public:
   }
   /**
    * This is the method that actually walks a display list and builds
    * the child layers. We invoke it recursively to process clipped sublists.
    * @param aClipRect the clip rect to apply to the list items, or null
    * if no clipping is required
    */
   void ProcessDisplayItems(const nsDisplayList& aList,
-                           const nsRect* aClipRect);
+                           const FrameLayerBuilder::Clip& aClip);
   /**
    * This finalizes all the open ThebesLayers by popping every element off
    * mThebesLayerDataStack, then sets the children of the container layer
    * to be all the layers in mNewChildLayers in that order and removes any
    * layers as children of the container that aren't in mNewChildLayers.
    */
   void Finish();
 
@@ -1029,53 +1030,53 @@ BuildTempManagerForInactiveLayer(nsDispl
  * Iterate through the non-clip items in aList and its descendants.
  * For each item we compute the effective clip rect. Each item is assigned
  * to a layer. We invalidate the areas in ThebesLayers where an item
  * has moved from one ThebesLayer to another. Also,
  * aState->mInvalidThebesContent is invalidated in every ThebesLayer.
  * We set the clip rect for items that generated their own layer.
  * (ThebesLayers don't need a clip rect on the layer, we clip the items
  * individually when we draw them.)
+ * If we have to clip to a rounded rect, we treat any active layer as
+ * though it's inactive so that we draw it ourselves into the thebes layer.
  * We set the visible rect for all layers, although the actual setting
  * of visible rects for some ThebesLayers is deferred until the calling
  * of ContainerState::Finish.
  */
 void
 ContainerState::ProcessDisplayItems(const nsDisplayList& aList,
-                                    const nsRect* aClipRect)
+                                    const FrameLayerBuilder::Clip& aClip)
 {
   PRInt32 appUnitsPerDevPixel =
     mContainerFrame->PresContext()->AppUnitsPerDevPixel();
 
   for (nsDisplayItem* item = aList.GetBottom(); item; item = item->GetAbove()) {
-    if (item->GetType() == nsDisplayItem::TYPE_CLIP) {
-      nsDisplayClip* clipItem = static_cast<nsDisplayClip*>(item);
-      nsRect clip = clipItem->GetClipRect();
-      if (aClipRect) {
-        clip.IntersectRect(clip, *aClipRect);
-      }
-      ProcessDisplayItems(*clipItem->GetList(), &clip);
+    nsDisplayItem::Type type = item->GetType();
+    if (type == nsDisplayItem::TYPE_CLIP ||
+        type == nsDisplayItem::TYPE_CLIP_ROUNDED_RECT) {
+      FrameLayerBuilder::Clip childClip(aClip, item);
+      ProcessDisplayItems(*item->GetList(), childClip);
       continue;
     }
 
     NS_ASSERTION(appUnitsPerDevPixel == AppUnitsPerDevPixel(item),
       "items in a container layer should all have the same app units per dev pixel");
 
     nsIntRect itemVisibleRect =
       item->GetVisibleRect().ToNearestPixels(appUnitsPerDevPixel);
     nsRect itemContent = item->GetBounds(mBuilder);
-    if (aClipRect) {
-      itemContent.IntersectRect(*aClipRect, itemContent);
+    if (aClip.mHaveClipRect) {
+      itemContent.IntersectRect(aClip.mClipRect, itemContent);
     }
     nsIntRect itemDrawRect = itemContent.ToNearestPixels(appUnitsPerDevPixel);
     nsDisplayItem::LayerState layerState =
       item->GetLayerState(mBuilder, mManager);
 
     // Assign the item to a layer
-    if (layerState == LAYER_ACTIVE) {
+    if (layerState == LAYER_ACTIVE && aClip.mRoundedClipRects.IsEmpty()) {
       // If the item would have its own layer but is invisible, just hide it.
       // Note that items without their own layers can't be skipped this
       // way, since their ThebesLayer may decide it wants to draw them
       // into its buffer even if they're currently covered.
       if (itemVisibleRect.IsEmpty()) {
         InvalidateForLayerChange(item, nsnull);
         continue;
       }
@@ -1087,19 +1088,19 @@ ContainerState::ProcessDisplayItems(cons
         continue;
       }
 
       // Update that layer's clip and visible rects.
       NS_ASSERTION(ownLayer->Manager() == mManager, "Wrong manager");
       NS_ASSERTION(!ownLayer->HasUserData(&gLayerManagerUserData),
                    "We shouldn't have a FrameLayerBuilder-managed layer here!");
       // It has its own layer. Update that layer's clip and visible rects.
-      if (aClipRect) {
+      if (aClip.mHaveClipRect) {
         ownLayer->IntersectClipRect(
-            aClipRect->ToNearestPixels(appUnitsPerDevPixel));
+            aClip.mClipRect.ToNearestPixels(appUnitsPerDevPixel));
       }
       ThebesLayerData* data = GetTopThebesLayerData();
       if (data) {
         data->mVisibleAboveRegion.Or(data->mVisibleAboveRegion, itemVisibleRect);
         // Add the entire bounds rect to the mDrawAboveRegion.
         // The visible region may be excluding opaque content above the
         // item, and we need to ensure that that content is not placed
         // in a ThebesLayer below the item!
@@ -1114,17 +1115,17 @@ ContainerState::ProcessDisplayItems(cons
                    "Layer already in list???");
 
       InvalidateForLayerChange(item, ownLayer);
 
       mNewChildLayers.AppendElement(ownLayer);
       mBuilder->LayerBuilder()->AddLayerDisplayItem(ownLayer, item);
     } else {
       nsRefPtr<BasicLayerManager> tempLayerManager;
-      if (layerState == LAYER_INACTIVE) {
+      if (layerState != LAYER_NONE) {
         tempLayerManager = BuildTempManagerForInactiveLayer(mBuilder, item);
         if (!tempLayerManager)
           continue;
       }
 
       nsIFrame* f = item->GetUnderlyingFrame();
       nsIFrame* activeScrolledRoot =
         nsLayoutUtils::GetActiveScrolledRootFor(f, mBuilder->ReferenceFrame());
@@ -1142,17 +1143,17 @@ ContainerState::ProcessDisplayItems(cons
 
       nsRefPtr<ThebesLayer> thebesLayer =
         FindThebesLayerFor(item, itemVisibleRect, itemDrawRect,
                            activeScrolledRoot);
 
       InvalidateForLayerChange(item, thebesLayer);
 
       mBuilder->LayerBuilder()->
-        AddThebesDisplayItem(thebesLayer, item, aClipRect, mContainerFrame,
+        AddThebesDisplayItem(thebesLayer, item, aClip, mContainerFrame,
                              layerState, tempLayerManager);
     }
   }
 }
 
 void
 ContainerState::InvalidateForLayerChange(nsDisplayItem* aItem, Layer* aNewLayer)
 {
@@ -1194,29 +1195,29 @@ ContainerState::InvalidateForLayerChange
         nsIFrame::INVALIDATE_NO_THEBES_LAYERS |
         nsIFrame::INVALIDATE_EXCLUDE_CURRENT_PAINT);
   }
 }
 
 void
 FrameLayerBuilder::AddThebesDisplayItem(ThebesLayer* aLayer,
                                         nsDisplayItem* aItem,
-                                        const nsRect* aClipRect,
+                                        const Clip& aClip,
                                         nsIFrame* aContainerLayerFrame,
                                         LayerState aLayerState,
                                         LayerManager* aTempManager)
 {
   AddLayerDisplayItem(aLayer, aItem);
 
   ThebesLayerItemsEntry* entry = mThebesLayerItems.PutEntry(aLayer);
   if (entry) {
     entry->mContainerLayerFrame = aContainerLayerFrame;
     NS_ASSERTION(aItem->GetUnderlyingFrame(), "Must have frame");
     ClippedDisplayItem* cdi =
-      entry->mItems.AppendElement(ClippedDisplayItem(aItem, aClipRect));
+      entry->mItems.AppendElement(ClippedDisplayItem(aItem, aClip));
     cdi->mTempLayerManager = aTempManager;
   }
 }
 
 void
 FrameLayerBuilder::AddLayerDisplayItem(Layer* aLayer,
                                        nsDisplayItem* aItem)
 {
@@ -1388,17 +1389,18 @@ FrameLayerBuilder::BuildContainerLayerFo
     } else {
       // The region was deleted to indicate that everything should be
       // invalidated.
       state.SetInvalidateAllThebesContent();
     }
     SetHasContainerLayer(aContainerFrame);
   }
 
-  state.ProcessDisplayItems(aChildren, nsnull);
+  Clip clip;
+  state.ProcessDisplayItems(aChildren, clip);
   state.Finish();
 
   PRUint32 flags = aChildren.IsOpaque() ? Layer::CONTENT_OPAQUE : 0;
   containerLayer->SetContentFlags(flags);
   return containerLayer.forget();
 }
 
 Layer*
@@ -1590,69 +1592,96 @@ FrameLayerBuilder::DrawThebesLayer(Thebe
                  NSIntPixelsToAppUnits(offset.y, appUnitsPerDevPixel));
 
   for (i = items.Length(); i > 0; --i) {
     ClippedDisplayItem* cdi = &items[i - 1];
 
     NS_ASSERTION(AppUnitsPerDevPixel(cdi->mItem) == appUnitsPerDevPixel,
                  "a thebes layer should contain items only at the same zoom");
 
-    if (!cdi->mHasClipRect || cdi->mClipRect.Contains(visible.GetBounds())) {
+    NS_ABORT_IF_FALSE(cdi->mClip.mHaveClipRect ||
+                      cdi->mClip.mRoundedClipRects.IsEmpty(),
+                      "If we have rounded rects, we must have a clip rect");
+
+    if (!cdi->mClip.mHaveClipRect ||
+        (cdi->mClip.mRoundedClipRects.IsEmpty() &&
+         cdi->mClip.mClipRect.Contains(visible.GetBounds()))) {
       cdi->mItem->RecomputeVisibility(builder, &visible);
       continue;
     }
 
     // Do a little dance to account for the fact that we're clipping
     // to cdi->mClipRect
     nsRegion clipped;
-    clipped.And(visible, cdi->mClipRect);
+    clipped.And(visible, cdi->mClip.mClipRect);
     nsRegion finalClipped = clipped;
     cdi->mItem->RecomputeVisibility(builder, &finalClipped);
-    nsRegion removed;
-    removed.Sub(clipped, finalClipped);
-    nsRegion newVisible;
-    newVisible.Sub(visible, removed);
-    // Don't let the visible region get too complex.
-    if (newVisible.GetNumRects() <= 15) {
-      visible = newVisible;
+    // If we have rounded clip rects, don't subtract from the visible
+    // region since we aren't displaying everything inside the rect.
+    if (cdi->mClip.mRoundedClipRects.IsEmpty()) {
+      nsRegion removed;
+      removed.Sub(clipped, finalClipped);
+      nsRegion newVisible;
+      newVisible.Sub(visible, removed);
+      // Don't let the visible region get too complex.
+      if (newVisible.GetNumRects() <= 15) {
+        visible = newVisible;
+      }
     }
   }
 
   nsRefPtr<nsIRenderingContext> rc;
   nsresult rv =
     presContext->DeviceContext()->CreateRenderingContextInstance(*getter_AddRefs(rc));
   if (NS_FAILED(rv))
     return;
   rc->Init(presContext->DeviceContext(), aContext);
 
-  nsRect currentClip;
+  Clip currentClip;
   PRBool setClipRect = PR_FALSE;
 
   for (i = 0; i < items.Length(); ++i) {
     ClippedDisplayItem* cdi = &items[i];
 
     if (cdi->mItem->GetVisibleRect().IsEmpty())
       continue;
 
     // If the new desired clip state is different from the current state,
     // update the clip.
-    if (setClipRect != cdi->mHasClipRect ||
-        (cdi->mHasClipRect && cdi->mClipRect != currentClip)) {
+    if (setClipRect != cdi->mClip.mHaveClipRect ||
+        (cdi->mClip.mHaveClipRect && cdi->mClip != currentClip)) {
       if (setClipRect) {
         aContext->Restore();
       }
-      setClipRect = cdi->mHasClipRect;
+      setClipRect = cdi->mClip.mHaveClipRect;
       if (setClipRect) {
-        currentClip = cdi->mClipRect;
+        currentClip = cdi->mClip;
         aContext->Save();
         aContext->NewPath();
-        gfxRect clip(currentClip.x, currentClip.y, currentClip.width, currentClip.height);
-        clip.ScaleInverse(presContext->AppUnitsPerDevPixel());
+        PRInt32 A2D = presContext->AppUnitsPerDevPixel();
+        gfxRect clip = nsLayoutUtils::RectToGfxRect(currentClip.mClipRect, A2D);
         aContext->Rectangle(clip, PR_TRUE);
         aContext->Clip();
+
+        for (PRUint32 j = 0, jEnd = currentClip.mRoundedClipRects.Length();
+             j < jEnd; ++j) {
+          const Clip::RoundedRect &rr = currentClip.mRoundedClipRects[j];
+
+          gfxCornerSizes pixelRadii;
+          nsCSSRendering::ComputePixelRadii(rr.mRadii, A2D, &pixelRadii);
+
+          clip = nsLayoutUtils::RectToGfxRect(rr.mRect, A2D);
+          clip.Round();
+          clip.Condition();
+          // REVIEW: This might make contentArea empty.  Is that OK?
+
+          aContext->NewPath();
+          aContext->RoundedRectangle(clip, pixelRadii);
+          aContext->Clip();
+        }
       }
     }
 
     if (cdi->mTempLayerManager) {
       // This item has an inactive layer. Render it to the ThebesLayer
       // using the temporary BasicLayerManager.
       cdi->mTempLayerManager->BeginTransactionWithTarget(aContext);
       cdi->mTempLayerManager->EndTransaction(DrawThebesLayer, builder);
@@ -1671,9 +1700,37 @@ void
 FrameLayerBuilder::DumpRetainedLayerTree()
 {
   if (mRetainingManager) {
     mRetainingManager->Dump(stderr);
   }
 }
 #endif
 
+FrameLayerBuilder::Clip::Clip(const Clip& aOther, nsDisplayItem* aClipItem)
+  : mHaveClipRect(PR_TRUE),
+    mRoundedClipRects(aOther.mRoundedClipRects)
+{
+  nsDisplayItem::Type type = aClipItem->GetType();
+  NS_ABORT_IF_FALSE(type == nsDisplayItem::TYPE_CLIP ||
+                    type == nsDisplayItem::TYPE_CLIP_ROUNDED_RECT,
+                    "unexpected display item type");
+  nsDisplayClip* item = static_cast<nsDisplayClip*>(aClipItem);
+  // Always intersect with mClipRect, even if we're going to add a
+  // rounded rect.
+  if (aOther.mHaveClipRect) {
+    mClipRect.IntersectRect(aOther.mClipRect, item->GetClipRect());
+  } else {
+    mClipRect = item->GetClipRect();
+  }
+
+  if (type == nsDisplayItem::TYPE_CLIP_ROUNDED_RECT) {
+    RoundedRect *rr = mRoundedClipRects.AppendElement();
+    if (rr) {
+      rr->mRect = item->GetClipRect();
+      static_cast<nsDisplayClipRoundedRect*>(item)->GetRadii(rr->mRadii);
+    }
+  }
+
+  // FIXME: Optimize away excess rounded rectangles due to the new addition.
+}
+
 } // namespace mozilla
diff --git a/layout/base/FrameLayerBuilder.h b/layout/base/FrameLayerBuilder.h
--- a/layout/base/FrameLayerBuilder.h
+++ b/layout/base/FrameLayerBuilder.h
@@ -222,19 +222,20 @@ public:
   void AddLayerDisplayItem(Layer* aLayer, nsDisplayItem* aItem);
 
   /**
    * Record aItem as a display item that is rendered by the ThebesLayer
    * aLayer, with aClipRect, where aContainerLayerFrame is the frame
    * for the container layer this ThebesItem belongs to.
    * aItem must have an underlying frame.
    */
+  struct Clip;
   void AddThebesDisplayItem(ThebesLayer* aLayer,
                             nsDisplayItem* aItem,
-                            const nsRect* aClipRect,
+                            const Clip& aClip,
                             nsIFrame* aContainerLayerFrame,
                             LayerState aLayerState,
                             LayerManager* aTempManager);
 
   /**
    * Given a frame and a display item key that uniquely identifies a
    * display item for the frame, find the layer that was last used to
    * render that display item. Returns null if there is no such layer.
@@ -258,16 +259,61 @@ public:
   /**
    * Try to determine whether the ThebesLayer aLayer paints an opaque
    * single color everywhere it's visible in aRect.
    * If successful, return that color, otherwise return NS_RGBA(0,0,0,0).
    */
   nscolor FindOpaqueColorCovering(nsDisplayListBuilder* aBuilder,
                                   ThebesLayer* aLayer, const nsRect& aRect);
 
+  /**
+   * Clip represents the intersection of an optional rectangle with a
+   * list of rounded rectangles.
+   */
+  struct Clip {
+    struct RoundedRect {
+      nsRect mRect;
+      // Indices into mRadii are the NS_CORNER_* constants in nsStyleConsts.h
+      nscoord mRadii[8];
+
+      bool operator==(const RoundedRect& aOther) const {
+        if (mRect != aOther.mRect) {
+          return false;
+        }
+
+        NS_FOR_CSS_HALF_CORNERS(corner) {
+          if (mRadii[corner] != aOther.mRadii[corner]) {
+            return false;
+          }
+        }
+        return true;
+      }
+      bool operator!=(const RoundedRect& aOther) const {
+        return !(*this == aOther);
+      }
+    };
+    PRBool mHaveClipRect;
+    nsRect mClipRect;
+    nsTArray<RoundedRect> mRoundedClipRects;
+
+    Clip() : mHaveClipRect(PR_FALSE) {}
+
+    // Construct as the intersection of aOther and aClipItem.
+    Clip(const Clip& aOther, nsDisplayItem* aClipItem);
+
+    bool operator==(const Clip& aOther) const {
+      return mHaveClipRect == aOther.mHaveClipRect &&
+             (!mHaveClipRect || mClipRect == aOther.mClipRect) &&
+             mRoundedClipRects == aOther.mRoundedClipRects;
+    }
+    bool operator!=(const Clip& aOther) const {
+      return !(*this == aOther);
+    }
+  };
+
 protected:
   /**
    * We store an array of these for each frame that is associated with
    * one or more retained layers. Each DisplayItemData records the layer
    * used to render one of the frame's display items.
    */
   class DisplayItemData {
   public:
@@ -318,28 +364,24 @@ protected:
    * of ClippedDisplayItems. (ThebesLayerItemsEntry is the hash entry
    * for that hashtable.)
    * These are only stored during the paint process, so that the
    * DrawThebesLayer callback can figure out which items to draw for the
    * ThebesLayer.
    * mItem always has an underlying frame.
    */
   struct ClippedDisplayItem {
-    ClippedDisplayItem(nsDisplayItem* aItem, const nsRect* aClipRect)
-      : mItem(aItem), mHasClipRect(aClipRect != nsnull)
+    ClippedDisplayItem(nsDisplayItem* aItem, const Clip& aClip)
+      : mItem(aItem), mClip(aClip)
     {
-      if (mHasClipRect) {
-        mClipRect = *aClipRect;
-      }
     }
 
     nsDisplayItem* mItem;
     nsRefPtr<LayerManager> mTempLayerManager;
-    nsRect         mClipRect;
-    PRPackedBool   mHasClipRect;
+    Clip mClip;
   };
 
   /**
    * We accumulate ClippedDisplayItem elements in a hashtable during
    * the paint process. This is the hashentry for that hashtable.
    */
   class ThebesLayerItemsEntry : public nsPtrHashKey<ThebesLayer> {
   public:
diff --git a/layout/base/crashtests/485501-1.html b/layout/base/crashtests/485501-1.html
new file mode 100644
--- /dev/null
+++ b/layout/base/crashtests/485501-1.html
@@ -0,0 +1,4 @@
+<!DOCTYPE HTML>
+<div style="overflow: hidden; -moz-border-radius: 50px; height: 200px; width: 200px; background:yellow">
+  This is some text that should get clipped at the corners by the border radius.
+</div>
diff --git a/layout/base/crashtests/crashtests.list b/layout/base/crashtests/crashtests.list
--- a/layout/base/crashtests/crashtests.list
+++ b/layout/base/crashtests/crashtests.list
@@ -252,16 +252,17 @@ load 468645-3.xhtml
 load 469861-1.xhtml
 load 469861-2.xhtml
 load 471594-1.xhtml
 load 479114-1.html
 load 477333-1.xhtml
 load 477731-1.html
 load 481806-1.html
 load 483604-1.xhtml
+load 485501-1.html
 load 487544-1.html
 load 488390-1.xhtml
 load 489691.html
 load 490376-1.xhtml
 load 490559-1.html
 load 490747.html
 load 491547-1.xul
 load 491547-2.xul
diff --git a/layout/base/nsDisplayItemTypes.h b/layout/base/nsDisplayItemTypes.h
--- a/layout/base/nsDisplayItemTypes.h
+++ b/layout/base/nsDisplayItemTypes.h
@@ -56,16 +56,17 @@ enum Type {
   TYPE_BUTTON_FOREGROUND,
   TYPE_CANVAS,
   TYPE_CANVAS_BACKGROUND,
   TYPE_CANVAS_FOCUS,
   TYPE_CARET,
   TYPE_CHECKED_CHECKBOX,
   TYPE_CHECKED_RADIOBUTTON,
   TYPE_CLIP,
+  TYPE_CLIP_ROUNDED_RECT,
   TYPE_COLUMN_RULE,
   TYPE_COMBOBOX_FOCUS,
   TYPE_EVENT_RECEIVER,
   TYPE_FIELDSET_BORDER_BACKGROUND,
   TYPE_FRAMESET_BORDER,
   TYPE_FRAMESET_BLANK,
   TYPE_HEADER_FOOTER,
   TYPE_IMAGE,
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -1347,16 +1347,89 @@ PRBool nsDisplayClip::TryMerge(nsDisplay
 }
 
 nsDisplayWrapList* nsDisplayClip::WrapWithClone(nsDisplayListBuilder* aBuilder,
                                                 nsDisplayItem* aItem) {
   return new (aBuilder)
     nsDisplayClip(aBuilder, aItem->GetUnderlyingFrame(), aItem, mClip);
 }
 
+nsDisplayClipRoundedRect::nsDisplayClipRoundedRect(
+                             nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                             nsDisplayItem* aItem,
+                             const nsRect& aRect, nscoord aRadii[8])
+    : nsDisplayClip(aBuilder, aFrame, aItem, aRect)
+{
+  MOZ_COUNT_CTOR(nsDisplayClipRoundedRect);
+  memcpy(mRadii, aRadii, sizeof(mRadii));
+}
+
+nsDisplayClipRoundedRect::nsDisplayClipRoundedRect(
+                             nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                             nsDisplayList* aList,
+                             const nsRect& aRect, nscoord aRadii[8])
+    : nsDisplayClip(aBuilder, aFrame, aList, aRect)
+{
+  MOZ_COUNT_CTOR(nsDisplayClipRoundedRect);
+  memcpy(mRadii, aRadii, sizeof(mRadii));
+}
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+nsDisplayClipRoundedRect::~nsDisplayClipRoundedRect()
+{
+  MOZ_COUNT_DTOR(nsDisplayClipRoundedRect);
+}
+#endif
+
+PRBool nsDisplayClipRoundedRect::IsOpaque(nsDisplayListBuilder* aBuilder)
+{
+  return PR_FALSE;
+}
+
+void
+nsDisplayClipRoundedRect::HitTest(nsDisplayListBuilder* aBuilder,
+                                  const nsRect& aRect, HitTestState* aState,
+                                  nsTArray<nsIFrame*> *aOutFrames)
+{
+  // FIXME: Consider border-radius.
+  mList.HitTest(aBuilder, aRect, aState, aOutFrames);
+}
+
+nsDisplayWrapList*
+nsDisplayClipRoundedRect::WrapWithClone(nsDisplayListBuilder* aBuilder,
+                                        nsDisplayItem* aItem) {
+  return new (aBuilder)
+    nsDisplayClipRoundedRect(aBuilder, aItem->GetUnderlyingFrame(), aItem,
+                             mClip, mRadii);
+}
+
+PRBool nsDisplayClipRoundedRect::ComputeVisibility(
+                                    nsDisplayListBuilder* aBuilder,
+                                    nsRegion* aVisibleRegion)
+{
+  nsRegion clipped;
+  clipped.And(*aVisibleRegion, mClip);
+
+  return nsDisplayWrapList::ComputeVisibility(aBuilder, &clipped);
+  // FIXME: Remove a *conservative* opaque region from aVisibleRegion
+  // (like in nsDisplayClip::ComputeVisibility).
+}
+
+PRBool nsDisplayClipRoundedRect::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
+{
+  if (aItem->GetType() != TYPE_CLIP_ROUNDED_RECT)
+    return PR_FALSE;
+  nsDisplayClipRoundedRect* other =
+    static_cast<nsDisplayClipRoundedRect*>(aItem);
+  if (mClip != other->mClip || mRadii != other->mRadii)
+    return PR_FALSE;
+  mList.AppendToBottom(&other->mList);
+  return PR_TRUE;
+}
+
 nsDisplayZoom::nsDisplayZoom(nsDisplayListBuilder* aBuilder,
                              nsIFrame* aFrame, nsDisplayList* aList,
                              PRInt32 aAPD, PRInt32 aParentAPD)
     : nsDisplayOwnLayer(aBuilder, aFrame, aList), mAPD(aAPD),
       mParentAPD(aParentAPD) {
   MOZ_COUNT_CTOR(nsDisplayZoom);
 }
 
diff --git a/layout/base/nsDisplayList.h b/layout/base/nsDisplayList.h
--- a/layout/base/nsDisplayList.h
+++ b/layout/base/nsDisplayList.h
@@ -474,17 +474,17 @@ public:
   virtual Type GetType() = 0;
   /**
    * If this returns a non-zero value, then pairing this with the
    * GetUnderlyingFrame() pointer gives a key that uniquely identifies
    * this display item in the display item tree.
    * This will only return a zero value for items which wrap display lists
    * and do not create a CSS stacking context, therefore requiring
    * display items to be individually wrapped --- currently nsDisplayClip
-   * only.
+   * and nsDisplayClipRoundedRect only.
    */
   virtual PRUint32 GetPerFrameKey() { return PRUint32(GetType()); }
   /**
    * This is called after we've constructed a display list for event handling.
    * When this is called, we've already ensured that aRect intersects the
    * item's bounds.
    * 
    * @param aState must point to a HitTestState. If you don't have one,
@@ -1302,16 +1302,17 @@ public:
   virtual ~nsDisplayBackground() {
     MOZ_COUNT_DTOR(nsDisplayBackground);
   }
 #endif
 
   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames)
   {
+    // FIXME: Consider border-radius.
     aOutFrames->AppendElement(mFrame);
   }
   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
                                    nsRegion* aVisibleRegion);
   virtual PRBool IsOpaque(nsDisplayListBuilder* aBuilder);
   virtual PRBool IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
                                                 nsIFrame* aFrame);
   virtual PRBool IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor);
@@ -1409,16 +1410,17 @@ public:
   virtual ~nsDisplayEventReceiver() {
     MOZ_COUNT_DTOR(nsDisplayEventReceiver);
   }
 #endif
 
   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames)
   {
+    // FIXME: Consider border-radius.
     aOutFrames->AppendElement(mFrame);
   }
   NS_DISPLAY_DECL_NAME("EventReceiver", TYPE_EVENT_RECEIVER)
 };
 
 /**
  * A class that lets you wrap a display list as a display item.
  * 
@@ -1597,18 +1599,58 @@ public:
   virtual PRUint32 GetPerFrameKey() { return 0; }
   
   const nsRect& GetClipRect() { return mClip; }
   void SetClipRect(const nsRect& aRect) { mClip = aRect; }
 
   virtual nsDisplayWrapList* WrapWithClone(nsDisplayListBuilder* aBuilder,
                                            nsDisplayItem* aItem);
 
+protected:
+  nsRect    mClip;
+};
+
+/**
+ * A display item to clip a list of items to the border-radius of a
+ * frame.
+ */
+class nsDisplayClipRoundedRect : public nsDisplayClip {
+public:
+  /**
+   * @param aFrame the frame that should be considered the underlying
+   * frame for this content, e.g. the frame whose z-index we have.  This
+   * is *not* the frame that is inducing the clipping.
+   */
+  nsDisplayClipRoundedRect(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                           nsDisplayItem* aItem,
+                           const nsRect& aRect, nscoord aRadii[8]);
+  nsDisplayClipRoundedRect(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                           nsDisplayList* aList,
+                           const nsRect& aRect, nscoord aRadii[8]);
+#ifdef NS_BUILD_REFCNT_LOGGING
+  virtual ~nsDisplayClipRoundedRect();
+#endif
+
+  virtual PRBool IsOpaque(nsDisplayListBuilder* aBuilder);
+  virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
+                       HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames);
+  virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
+                                   nsRegion* aVisibleRegion);
+  virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
+  NS_DISPLAY_DECL_NAME("ClipRoundedRect", TYPE_CLIP_ROUNDED_RECT)
+
+  virtual nsDisplayWrapList* WrapWithClone(nsDisplayListBuilder* aBuilder,
+                                           nsDisplayItem* aItem);
+
+  void GetRadii(nscoord aRadii[8]) {
+    memcpy(aRadii, mRadii, sizeof(mRadii));
+  }
+
 private:
-  nsRect    mClip;
+  nscoord mRadii[8];
 };
 
 /**
  * nsDisplayZoom is used for subdocuments that have a different full zoom than
  * their parent documents. This item creates a container layer.
  */
 class nsDisplayZoom : public nsDisplayOwnLayer {
 public:
diff --git a/layout/base/nsLayoutDebugger.cpp b/layout/base/nsLayoutDebugger.cpp
--- a/layout/base/nsLayoutDebugger.cpp
+++ b/layout/base/nsLayoutDebugger.cpp
@@ -161,17 +161,18 @@ PrintDisplayListTo(nsDisplayListBuilder*
     }
     nsIFrame* f = i->GetUnderlyingFrame();
     nsAutoString fName;
     if (f) {
       f->GetFrameName(fName);
     }
     nsRect rect = i->GetBounds(aBuilder);
     switch (i->GetType()) {
-      case nsDisplayItem::TYPE_CLIP: {
+      case nsDisplayItem::TYPE_CLIP:
+      case nsDisplayItem::TYPE_CLIP_ROUNDED_RECT: {
         nsDisplayClip* c = static_cast<nsDisplayClip*>(i);
         rect = c->GetClipRect();
         break;
       }
       default:
         break;
     }
     nscolor color;
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -1139,17 +1139,19 @@ PruneDisplayListForExtraPage(nsDisplayLi
 
   while (PR_TRUE) {
     nsDisplayItem* i = aList->RemoveBottom();
     if (!i)
       break;
     nsDisplayList* subList = i->GetList();
     if (subList) {
       PruneDisplayListForExtraPage(aBuilder, aExtraPage, aY, subList);
-      if (i->GetType() == nsDisplayItem::TYPE_CLIP) {
+      nsDisplayItem::Type type = i->GetType();
+      if (type == nsDisplayItem::TYPE_CLIP ||
+          type == nsDisplayItem::TYPE_CLIP_ROUNDED_RECT) {
         // This might clip an element which should appear on the first
         // page, and that element might be visible if this uses a 'clip'
         // property with a negative top.
         // The clip area needs to be moved because the frame geometry doesn't
         // put page content frames for adjacent pages vertically adjacent,
         // there are page margins and dead space between them in print
         // preview, and in printing all pages are at (0,0)...
         // XXX we have no way to test this right now that I know of;
