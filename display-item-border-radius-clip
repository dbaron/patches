From: L. David Baron <dbaron@dbaron.org>

Add a (wrapping) display item that clips its contents to the curvature of a border-radius.  (Bug 485501)  (FIXME: WRITE THE REST)

diff --git a/layout/base/nsDisplayItemTypes.h b/layout/base/nsDisplayItemTypes.h
--- a/layout/base/nsDisplayItemTypes.h
+++ b/layout/base/nsDisplayItemTypes.h
@@ -57,16 +57,17 @@ enum Type {
   TYPE_CANVAS,
   TYPE_CANVAS_BACKGROUND,
   TYPE_CANVAS_FOCUS,
   TYPE_CARET,
   TYPE_CHANGE_COLOR_CORRECTION,
   TYPE_CHECKED_CHECKBOX,
   TYPE_CHECKED_RADIOBUTTON,
   TYPE_CLIP,
+  TYPE_CLIP_BORDER_RADIUS,
   TYPE_COLUMN_RULE,
   TYPE_COMBOBOX_FOCUS,
   TYPE_EVENT_RECEIVER,
   TYPE_FIELDSET_BORDER_BACKGROUND,
   TYPE_FRAMESET_BORDER,
   TYPE_FRAMESET_BLANK,
   TYPE_HEADER_FOOTER,
   TYPE_IMAGE,
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -1339,16 +1339,72 @@ PRBool nsDisplayClip::TryMerge(nsDisplay
 }
 
 nsDisplayWrapList* nsDisplayClip::WrapWithClone(nsDisplayListBuilder* aBuilder,
                                                 nsDisplayItem* aItem) {
   return new (aBuilder)
     nsDisplayClip(aBuilder, aItem->GetUnderlyingFrame(), mClippingFrame, aItem, mClip);
 }
 
+nsDisplayClipBorderRadius::nsDisplayClipBorderRadius(
+                             nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                             nsDisplayList* aList)
+    : nsDisplayWrapList(aBuilder, aFrame, aList), mRadiusFrame(aFrame),
+{
+  MOZ_COUNT_CTOR(nsDisplayClipBorderRadius);
+}
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+nsDisplayClipBorderRadius::~nsDisplayClipBorderRadius()
+{
+  MOZ_COUNT_DTOR(nsDisplayClipBorderRadius);
+}
+#endif
+
+PRBool nsDisplayClipBorderRadius::IsOpaque(nsDisplayListBuilder* aBuilder)
+{
+  return PR_FALSE;
+}
+
+void
+nsDisplayClipBorderRadius::HitTest(nsDisplayListBuilder* aBuilder,
+                                   const nsRect& aRect, HitTestState* aState,
+                                   nsTArray<nsIFrame*> *aOutFrames)
+{
+  if (PR_TRUE) { // FIXME: WRITE ME
+    mList.HitTest(aBuilder, aRect, aState, aOutFrames);
+  }
+}
+
+void nsDisplayClipBorderRadius::Paint(nsDisplayListBuilder* aBuilder,
+                                nsIRenderingContext* aCtx)
+{
+  // FIXME: Copy bits of nsSVGIntegrationUtils::PaintFramesWithEffects
+  // (see also nsDisplaySVGEffects::Paint)
+}
+
+PRBool nsDisplayClipBorderRadius::ComputeVisibility(
+                                    nsDisplayListBuilder* aBuilder,
+                                    nsRegion* aVisibleRegion)
+{
+  // FIXME: Copy nsDisplayClip::ComputeVisibility
+}
+
+PRBool nsDisplayClipBorderRadius::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
+{
+  if (aItem->GetType() != TYPE_CLIP_BORDER_RADIUS)
+    return PR_FALSE;
+  nsDisplayClipBorderRadius* other =
+    static_cast<nsDisplayClipBorderRadius*>(aItem);
+  if (mRadiusFrame != other->mRadiusFrame || mClipType != other->mClipType)
+    return PR_FALSE;
+  mList.AppendToBottom(&other->mList);
+  return PR_TRUE;
+}
+
 nsDisplayZoom::nsDisplayZoom(nsDisplayListBuilder* aBuilder,
                              nsIFrame* aFrame, nsDisplayList* aList,
                              PRInt32 aAPD, PRInt32 aParentAPD)
     : nsDisplayOwnLayer(aBuilder, aFrame, aList), mAPD(aAPD),
       mParentAPD(aParentAPD) {
   MOZ_COUNT_CTOR(nsDisplayZoom);
 }
 
diff --git a/layout/base/nsDisplayList.h b/layout/base/nsDisplayList.h
--- a/layout/base/nsDisplayList.h
+++ b/layout/base/nsDisplayList.h
@@ -1605,16 +1605,49 @@ private:
   // from mFrame because mFrame represents the content that is being
   // clipped, and for example may be used to obtain the z-index of the
   // content.
   nsIFrame* mClippingFrame;
   nsRect    mClip;
 };
 
 /**
+ * A display item to clip a list of items to the border-radius of a
+ * frame.
+ */
+class nsDisplayClipBorderRadius : public nsDisplayWrapList {
+public:
+  enum ClipType { PADDING_BOX, CONTENT_BOX };
+  nsDisplayClipBorderRadius(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                            nsDisplayList* aList, ClipType aClipType);
+#ifdef NS_BUILD_REFCNT_LOGGING
+  virtual ~nsDisplayClipBorderRadius();
+#endif
+
+  virtual PRBool IsOpaque(nsDisplayListBuilder* aBuilder);
+  virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
+                       HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames);
+  virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
+    return (mClipType == PADDING_BOX ? mRadiusFrame->GetPaddingRect() :
+                                       mRadiusFrame->GetContentRect())
+           - mRadiusFrame->GetPosition()
+           + aBuilder->ToReferenceFrame(mRadiusFrame);
+  }
+  virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx);
+  virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
+                                   nsRegion* aVisibleRegion);
+  virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
+  NS_DISPLAY_DECL_NAME("ClipBorderRadius", TYPE_CLIP_BORDER_RADIUS)
+
+private:
+  nsIFrame* mRadiusFrame;
+  ClipType mClipType;
+};
+
+/**
  * nsDisplayZoom is used for subdocuments that have a different full zoom than
  * their parent documents. This item creates a container layer.
  */
 class nsDisplayZoom : public nsDisplayOwnLayer {
 public:
   /**
    * @param aFrame is the root frame of the subdocument.
    * @param aList contains the display items for the subdocument.
