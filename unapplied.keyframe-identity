From: L. David Baron <dbaron@dbaron.org>

Bug 978833 patch 2 - Give a keyframe rule a new identity when it changes, so that it gets a new path in the rule tree when the animation manager builds a path in the rule tree with it.

FIXME: This breaks the identity of an object that's exposed to the DOM.
See comments in the bug for how to fix.

diff --git a/layout/style/Rule.h b/layout/style/Rule.h
--- a/layout/style/Rule.h
+++ b/layout/style/Rule.h
@@ -89,16 +89,19 @@ public:
     return sheet ? sheet->GetDocument() : nullptr;
   }
 
   virtual void SetStyleSheet(CSSStyleSheet* aSheet);
   // This does not need to be virtual, because GroupRule and MediaRule are not
   // used for inline style.
   void SetHTMLCSSStyleSheet(nsHTMLCSSStyleSheet* aSheet);
 
+  GroupRule* GetParentRule() {
+    return mParentRule;
+  }
   void SetParentRule(GroupRule* aRule) {
     // We don't reference count this up reference. The group rule
     // will tell us when it's going away or when we're detached from
     // it.
     mParentRule = aRule;
   }
 
   uint32_t GetLineNumber() const { return mLineNumber; }
diff --git a/layout/style/nsCSSRules.cpp b/layout/style/nsCSSRules.cpp
--- a/layout/style/nsCSSRules.cpp
+++ b/layout/style/nsCSSRules.cpp
@@ -32,16 +32,17 @@
 #include "mozilla/css/Declaration.h"
 #include "nsCSSParser.h"
 #include "nsDOMClassInfoID.h"
 #include "mozilla/dom/CSSStyleDeclarationBinding.h"
 #include "StyleRule.h"
 #include "nsFont.h"
 #include "nsIURI.h"
 #include "mozAutoDocUpdate.h"
+#include "mozilla/Move.h"
 
 using namespace mozilla;
 
 #define IMPL_STYLE_RULE_INHERIT_GET_DOM_RULE_WEAK(class_, super_) \
   /* virtual */ nsIDOMCSSRule* class_::GetDOMRule()               \
   { return this; }                                                \
   /* virtual */ nsIDOMCSSRule* class_::GetExistingDOMRule()       \
   { return this; }
@@ -2197,17 +2198,39 @@ nsCSSKeyframeStyleDeclaration::GetParent
   NS_IF_ADDREF(*aParent = mRule);
   return NS_OK;
 }
 
 nsresult
 nsCSSKeyframeStyleDeclaration::SetCSSDeclaration(css::Declaration* aDecl)
 {
   NS_ABORT_IF_FALSE(aDecl, "must be non-null");
-  mRule->ChangeDeclaration(aDecl);
+
+  // Our caller already did a BeginUpdate/EndUpdate, but with
+  // UPDATE_CONTENT, and we need UPDATE_STYLE to trigger work in
+  // PresShell::EndUpdate.
+  nsIDocument* doc = mRule->GetDocument();
+  MOZ_AUTO_DOC_UPDATE(doc, UPDATE_STYLE, true);
+
+  css::GroupRule* parentRule = mRule->GetParentRule();
+  nsRefPtr<nsCSSKeyframeRule> oldRule = mRule;
+
+  mRule = new nsCSSKeyframeRule(Move(*oldRule), aDecl);
+  if (parentRule) {
+    parentRule->ReplaceStyleRule(oldRule, mRule);
+  }
+
+  CSSStyleSheet* sheet = mRule->GetStyleSheet();
+  if (sheet) {
+    sheet->SetModifiedByChildRule();
+
+    if (doc) {
+      doc->StyleRuleChanged(sheet, mRule, mRule);
+    }
+  }
   return NS_OK;
 }
 
 nsIDocument*
 nsCSSKeyframeStyleDeclaration::DocToUpdate()
 {
   return nullptr;
 }
@@ -2225,16 +2248,34 @@ nsCSSKeyframeStyleDeclaration::GetParent
 nsCSSKeyframeRule::nsCSSKeyframeRule(const nsCSSKeyframeRule& aCopy)
   // copy everything except our reference count and mDOMDeclaration
   : Rule(aCopy)
   , mKeys(aCopy.mKeys)
   , mDeclaration(new css::Declaration(*aCopy.mDeclaration))
 {
 }
 
+// Used only by the dom declaration
+nsCSSKeyframeRule::nsCSSKeyframeRule(nsCSSKeyframeRule&& aMove,
+                                     mozilla::css::Declaration* aNewDeclaration)
+  : Rule(Move(aMove))
+{
+  mKeys.SwapElements(aMove.mKeys);
+  if (aNewDeclaration == aMove.mDeclaration) {
+    // If we haven't yet marked the declaration immutable, the new
+    // declaration might be the same as the old one.
+    aMove.mDeclaration.forget();
+  } else {
+    mDeclaration = aNewDeclaration;
+  }
+  mDOMDeclaration.swap(aMove.mDOMDeclaration);
+  MOZ_ASSERT(mDOMDeclaration,
+             "should only happen with non-null mDOMDeclaration");
+}
+
 nsCSSKeyframeRule::~nsCSSKeyframeRule()
 {
   if (mDOMDeclaration) {
     mDOMDeclaration->DropReference();
   }
 }
 
 /* virtual */ already_AddRefed<css::Rule>
@@ -2409,41 +2450,16 @@ nsCSSKeyframeRule::GetStyle(nsIDOMCSSSty
 {
   if (!mDOMDeclaration) {
     mDOMDeclaration = new nsCSSKeyframeStyleDeclaration(this);
   }
   NS_ADDREF(*aStyle = mDOMDeclaration);
   return NS_OK;
 }
 
-void
-nsCSSKeyframeRule::ChangeDeclaration(css::Declaration* aDeclaration)
-{
-  // Our caller already did a BeginUpdate/EndUpdate, but with
-  // UPDATE_CONTENT, and we need UPDATE_STYLE to trigger work in
-  // PresShell::EndUpdate.
-  nsIDocument* doc = GetDocument();
-  MOZ_AUTO_DOC_UPDATE(doc, UPDATE_STYLE, true);
-
-  // Be careful to not assign to an nsAutoPtr if we would be assigning
-  // the thing it already holds.
-  if (aDeclaration != mDeclaration) {
-    mDeclaration = aDeclaration;
-  }
-
-  CSSStyleSheet* sheet = GetStyleSheet();
-  if (sheet) {
-    sheet->SetModifiedByChildRule();
-
-    if (doc) {
-      doc->StyleRuleChanged(sheet, this, this);
-    }
-  }
-}
-
 /* virtual */ size_t
 nsCSSKeyframeRule::SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const
 {
   return aMallocSizeOf(this);
 
   // Measurement of the following members may be added later if DMD finds it is
   // worthwhile:
   // - mKeys
diff --git a/layout/style/nsCSSRules.h b/layout/style/nsCSSRules.h
--- a/layout/style/nsCSSRules.h
+++ b/layout/style/nsCSSRules.h
@@ -425,16 +425,19 @@ public:
   nsCSSKeyframeRule(InfallibleTArray<float>& aKeys,
                     nsAutoPtr<mozilla::css::Declaration>&& aDeclaration,
                     uint32_t aLineNumber, uint32_t aColumnNumber)
     : mozilla::css::Rule(aLineNumber, aColumnNumber)
     , mDeclaration(mozilla::Move(aDeclaration))
   {
     mKeys.SwapElements(aKeys);
   }
+
+  nsCSSKeyframeRule(nsCSSKeyframeRule&& aMove,
+                    mozilla::css::Declaration* aNewDeclaration);
 private:
   nsCSSKeyframeRule(const nsCSSKeyframeRule& aCopy);
   ~nsCSSKeyframeRule();
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsCSSKeyframeRule, nsIStyleRule)
 
   // nsIStyleRule methods
@@ -448,25 +451,27 @@ public:
   virtual already_AddRefed<mozilla::css::Rule> Clone() const;
 
   // nsIDOMCSSRule interface
   NS_DECL_NSIDOMCSSRULE
 
   // nsIDOMMozCSSKeyframeRule interface
   NS_DECL_NSIDOMMOZCSSKEYFRAMERULE
 
+#ifdef HAVE_CPP_AMBIGUITY_RESOLVING_USING
+  using Rule::GetParentRule;
+#endif
+
   const nsTArray<float>& GetKeys() const     { return mKeys; }
   mozilla::css::Declaration* Declaration()   { return mDeclaration; }
 
   void RuleMatched() {
     mDeclaration->SetImmutable();
   }
 
-  void ChangeDeclaration(mozilla::css::Declaration* aDeclaration);
-
   virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const MOZ_OVERRIDE;
 
   void DoGetKeyText(nsAString &aKeyText) const;
 
 private:
   nsTArray<float>                            mKeys;
   nsAutoPtr<mozilla::css::Declaration>       mDeclaration;
   // lazily created when needed:
diff --git a/layout/style/test/test_animations.html b/layout/style/test/test_animations.html
--- a/layout/style/test/test_animations.html
+++ b/layout/style/test/test_animations.html
@@ -1536,18 +1536,17 @@ is(cs.marginLeft, "0px", "dynamic rule c
 advance_clock(250);
 is(cs.marginLeft, "25px", "dynamic rule change test, 250ms");
 dyn2.name = "dyn1";
 is(cs.marginLeft, "125px", "dynamic rule change test, change in @keyframes name applies");
 dyn2.appendRule("50% { margin-left: 0px }");
 is(cs.marginLeft, "50px", "dynamic rule change test, @keyframes appendRule");
 var dyn2_kf1 = dyn2.cssRules[0]; // currently 0% { margin-left: 100px }
 dyn2_kf1.style.marginLeft = "-100px";
-// FIXME: Bug 978833 (keyframe rules used as nsIStyleRule but doesn't follow immutability contract)
-todo_is(cs.marginLeft, "-50px", "dynamic rule change test, keyframe style set");
+is(cs.marginLeft, "-50px", "dynamic rule change test, keyframe style set");
 dyn2.name = "dyn2";
 is(cs.marginLeft, "25px", "dynamic rule change test, change in @keyframes name applies (second time)");
 var dyn1_kf2 = dyn1.cssRules[1]; // currently 50% { margin-left: 50px }
 dyn1_kf2.keyText = "25%";
 is(cs.marginLeft, "50px", "dynamic rule change test, change in keyframe keyText");
 dyn1.deleteRule("25%");
 is(cs.marginLeft, "25px", "dynamic rule change test, @keyframes deleteRule");
 done_div();
