From: L. David Baron <dbaron@dbaron.org>

Bug 1055865 patch 1 - Use separate nsHTMLReflowMetrics for reflowing the child of the nsFirstLetterFrame.

This changes this code to do things in the normal way, which is to use a
separate nsHTMLReflowMetrics for each Reflow, rather than (as this code
was) reusing the one for the nsFirstLetterFrame for its text frame
child.

diff --git a/layout/generic/nsFirstLetterFrame.cpp b/layout/generic/nsFirstLetterFrame.cpp
--- a/layout/generic/nsFirstLetterFrame.cpp
+++ b/layout/generic/nsFirstLetterFrame.cpp
@@ -174,16 +174,19 @@ nsFirstLetterFrame::Reflow(nsPresContext
   const LogicalMargin& bp = aReflowState.ComputedLogicalBorderPadding();
   NS_ASSERTION(availSize.ISize(wm) != NS_UNCONSTRAINEDSIZE,
                "should no longer use unconstrained inline size");
   availSize.ISize(wm) -= bp.IStartEnd(wm);
   if (NS_UNCONSTRAINEDSIZE != availSize.BSize(wm)) {
     availSize.BSize(wm) -= bp.BStartEnd(wm);
   }
 
+  WritingMode lineWM = aMetrics.GetWritingMode();
+  nsHTMLReflowMetrics kidMetrics(lineWM);
+
   // Reflow the child
   if (!aReflowState.mLineLayout) {
     // When there is no lineLayout provided, we provide our own. The
     // only time that the first-letter-frame is not reflowing in a
     // line context is when its floating.
     WritingMode kidWritingMode = GetWritingMode(kid);
     LogicalSize kidAvailSize = availSize.ConvertTo(kidWritingMode, wm);
     nsHTMLReflowState rs(aPresContext, aReflowState, kid, kidAvailSize);
@@ -193,51 +196,50 @@ nsFirstLetterFrame::Reflow(nsPresContext
                        availSize.ISize(wm), NS_UNCONSTRAINEDSIZE,
                        false, true, kidWritingMode,
                        aReflowState.AvailableWidth());
     rs.mLineLayout = &ll;
     ll.SetInFirstLetter(true);
     ll.SetFirstLetterStyleOK(true);
 
     kid->WillReflow(aPresContext);
-    kid->Reflow(aPresContext, aMetrics, rs, aReflowStatus);
+    kid->Reflow(aPresContext, kidMetrics, rs, aReflowStatus);
 
     ll.EndLineReflow();
     ll.SetInFirstLetter(false);
 
     // In the floating first-letter case, we need to set this ourselves;
     // nsLineLayout::BeginSpan will set it in the other case
-    mBaseline = aMetrics.BlockStartAscent();
+    mBaseline = kidMetrics.BlockStartAscent();
   }
   else {
     // Pretend we are a span and reflow the child frame
     nsLineLayout* ll = aReflowState.mLineLayout;
     bool          pushedFrame;
 
     ll->SetInFirstLetter(
       mStyleContext->GetPseudo() == nsCSSPseudoElements::firstLetter);
     ll->BeginSpan(this, &aReflowState, bp.IStart(wm),
                   availSize.ISize(wm), &mBaseline);
-    ll->ReflowFrame(kid, aReflowStatus, &aMetrics, pushedFrame);
+    ll->ReflowFrame(kid, aReflowStatus, &kidMetrics, pushedFrame);
     ll->EndSpan(this);
     ll->SetInFirstLetter(false);
   }
 
   // Place and size the child and update the output metrics
-  WritingMode lineWM = aMetrics.GetWritingMode();
-  LogicalSize convertedSize = aMetrics.Size(lineWM).ConvertTo(wm, lineWM);
+  LogicalSize convertedSize = kidMetrics.Size(lineWM).ConvertTo(wm, lineWM);
   kid->SetRect(nsRect(bp.IStart(wm), bp.BStart(wm),
                       convertedSize.ISize(wm), convertedSize.BSize(wm)));
-  kid->FinishAndStoreOverflow(&aMetrics);
+  kid->FinishAndStoreOverflow(&kidMetrics);
   kid->DidReflow(aPresContext, nullptr, nsDidReflowStatus::FINISHED);
 
   convertedSize.ISize(wm) += bp.IStartEnd(wm);
   convertedSize.BSize(wm) += bp.BStartEnd(wm);
   aMetrics.SetSize(wm, convertedSize);
-  aMetrics.SetBlockStartAscent(aMetrics.BlockStartAscent() +
+  aMetrics.SetBlockStartAscent(kidMetrics.BlockStartAscent() +
                                bp.BStart(wm));
 
   // Ensure that the overflow rect contains the child textframe's overflow rect.
   // Note that if this is floating, the overline/underline drawable area is in
   // the overflow rect of the child textframe.
   aMetrics.UnionOverflowAreasWithDesiredBounds();
   ConsiderChildOverflow(aMetrics.mOverflowAreas, kid);
 
