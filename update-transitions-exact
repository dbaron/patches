From: L. David Baron <dbaron@dbaron.org>

Bug 847287 patch 8 - Make updating of transition manager's cascade results when an animation starts or stops filling be exact.

FIXME: Scary recursion?!

diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -796,24 +796,16 @@ AnimationPlayerCollection::EnsureStyleRu
 
     for (size_t playerIdx = mPlayers.Length(); playerIdx-- != 0; ) {
       mPlayers[playerIdx]->ComposeStyle(mStyleRule, properties,
                                         mNeedsRefreshes);
     }
   }
 
   mManager->CheckNeedsRefresh();
-
-  // If one of our animations just started or stopped filling, we need
-  // to notify the transition manager.  This does the notification a bit
-  // more than necessary, but it's easier than doing it exactly.
-  if (mManager->IsAnimationManager()) {
-    mManager->mPresContext->TransitionManager()->
-      UpdateCascadeResultsWithAnimations(this);
-  }
 }
 
 bool
 AnimationPlayerCollection::CanThrottleTransformChanges(TimeStamp aTime)
 {
   if (!nsLayoutUtils::AreAsyncAnimationsEnabled()) {
     return false;
   }
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -229,16 +229,21 @@ nsAnimationManager::MaybeUpdateCascadeRe
     CSSAnimationPlayer* player =
       aCollection->mPlayers[playerIdx]->AsCSSAnimationPlayer();
     const Animation* anim = player->GetSource();
 
     bool filling = anim &&
                    anim->GetComputedTiming().mTimeFraction !=
                      ComputedTiming::kNullTimeFraction;
     if (filling != player->mFillingForCascadeResults) {
+      // Notify the transition manager.
+      mPresContext->TransitionManager()->
+        UpdateCascadeResultsWithAnimations(aCollection);
+
+      // Update our own cascade results.
       mozilla::dom::Element* element = aCollection->GetElementToRestyle();
       if (!element) {
         return;
       }
       nsIFrame* frame = element->GetPrimaryFrame();
       if (!frame) {
         return;
       }
