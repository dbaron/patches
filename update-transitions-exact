From: L. David Baron <dbaron@dbaron.org>

Bug 847287 patch 8 - Only update transition manager's cascade results when an animation starts or stops being in effect.  r=birtles

This avoids some extra work that was added in bug 1125455 now that we
have a mechanism for detecting when animations start and stop being in
effect (introduced in patch 7).

This is also needed to prevent infinite recursion in patch 9.

diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -823,24 +823,16 @@ AnimationPlayerCollection::EnsureStyleRu
 
     for (size_t playerIdx = mPlayers.Length(); playerIdx-- != 0; ) {
       mPlayers[playerIdx]->ComposeStyle(mStyleRule, properties,
                                         mNeedsRefreshes);
     }
   }
 
   mManager->CheckNeedsRefresh();
-
-  // If one of our animations just started or stopped filling, we need
-  // to notify the transition manager.  This does the notification a bit
-  // more than necessary, but it's easier than doing it exactly.
-  if (mManager->IsAnimationManager()) {
-    mManager->mPresContext->TransitionManager()->
-      UpdateCascadeResultsWithAnimations(this);
-  }
 }
 
 bool
 AnimationPlayerCollection::CanThrottleTransformChanges(TimeStamp aTime)
 {
   if (!nsLayoutUtils::AreAsyncAnimationsEnabled()) {
     return false;
   }
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -225,23 +225,29 @@ nsAnimationManager::QueueEvents(Animatio
 void
 nsAnimationManager::MaybeUpdateCascadeResults(AnimationPlayerCollection* aCollection)
 {
   for (size_t playerIdx = aCollection->mPlayers.Length(); playerIdx-- != 0; ) {
     CSSAnimationPlayer* player =
       aCollection->mPlayers[playerIdx]->AsCSSAnimationPlayer();
 
     if (player->HasInEffectSource() != player->mInEffectForCascadeResults) {
+      // Update our own cascade results.
       mozilla::dom::Element* element = aCollection->GetElementToRestyle();
       if (element) {
         nsIFrame* frame = element->GetPrimaryFrame();
         if (frame) {
           UpdateCascadeResults(frame->StyleContext(), aCollection);
         }
       }
+
+      // Notify the transition manager, whose results might depend on ours.
+      mPresContext->TransitionManager()->
+        UpdateCascadeResultsWithAnimations(aCollection);
+
       return;
     }
   }
 }
 
 /* virtual */ size_t
 nsAnimationManager::SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const
 {
