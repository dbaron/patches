From: L. David Baron <dbaron@dbaron.org>

Bug 847287 patch 8 - Only update transition manager's cascade results when an animation starts or stops filling.

This is needed to prevent infinite recursion in the following patch.

diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -808,24 +808,16 @@ AnimationPlayerCollection::EnsureStyleRu
 
     for (size_t playerIdx = mPlayers.Length(); playerIdx-- != 0; ) {
       mPlayers[playerIdx]->ComposeStyle(mStyleRule, properties,
                                         mNeedsRefreshes);
     }
   }
 
   mManager->CheckNeedsRefresh();
-
-  // If one of our animations just started or stopped filling, we need
-  // to notify the transition manager.  This does the notification a bit
-  // more than necessary, but it's easier than doing it exactly.
-  if (mManager->IsAnimationManager()) {
-    mManager->mPresContext->TransitionManager()->
-      UpdateCascadeResultsWithAnimations(this);
-  }
 }
 
 bool
 AnimationPlayerCollection::CanThrottleTransformChanges(TimeStamp aTime)
 {
   if (!nsLayoutUtils::AreAsyncAnimationsEnabled()) {
     return false;
   }
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -229,23 +229,29 @@ nsAnimationManager::MaybeUpdateCascadeRe
     CSSAnimationPlayer* player =
       aCollection->mPlayers[playerIdx]->AsCSSAnimationPlayer();
     const Animation* anim = player->GetSource();
 
     bool filling = anim &&
                    anim->GetComputedTiming().mTimeFraction !=
                      ComputedTiming::kNullTimeFraction;
     if (filling != player->mFillingForCascadeResults) {
+      // Update our own cascade results.
       mozilla::dom::Element* element = aCollection->GetElementToRestyle();
       if (element) {
         nsIFrame* frame = element->GetPrimaryFrame();
         if (frame) {
           UpdateCascadeResults(frame->StyleContext(), aCollection);
         }
       }
+
+      // Notify the transition manager, whose results might depend on ours.
+      mPresContext->TransitionManager()->
+        UpdateCascadeResultsWithAnimations(aCollection);
+
       return;
     }
   }
 }
 
 /* virtual */ size_t
 nsAnimationManager::SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const
 {
