From: L. David Baron <dbaron@dbaron.org>

Don't use ComputeDistance in nsTransitionManager when shortening reversals of partially running transitions, and shorten only transitions that are actually back to the current start point.

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -71,28 +71,64 @@ struct ElementPropertyTransition
   // UncomputeValue on it in MapRuleInfoInto).
   nsStyleAnimation::Value mStartValue, mEndValue, mCurrentValue;
   TimeStamp mStartTime; // actual start plus transition delay
 
   // data from the relevant nsTransition
   TimeDuration mDuration;
   nsSMILKeySpline mTimingFunction;
 
+  // This is the start value to be used for a check for whether a
+  // transition is being reversed.  Normally the same as mStartValue,
+  // except when this transition started as the reversal of another
+  // in-progress transition.  Needed so we can handle two reverses in a
+  // row.
+  nsStyleAnimation::Value mStartForReversingTest;
+  // Likewise, the portion of the "full" reversed transition that we're
+  // actually covering.
+  double mReversePortion;
+
+  double ValuePortionFor(TimeStamp aRefreshTime) const;
+
   PRBool IsRemovedSentinel() const
   {
     return mStartTime.IsNull();
   }
 
   void SetRemovedSentinel()
   {
     // assign the null time stamp
     mStartTime = TimeStamp();
   }
 };
 
+double
+ElementPropertyTransition::ValuePortionFor(TimeStamp aRefreshTime) const
+{
+  double duration = mDuration.ToSeconds();
+  NS_ABORT_IF_FALSE(duration >= 0.0, "negative duration forbidden");
+  double timePortion;
+  if (duration == 0.0) {
+    if (aRefreshTime >= mStartTime) {
+      timePortion = 0.0;
+    } else {
+      timePortion = 1.0;
+    }
+  } else {
+    timePortion = (aRefreshTime - mStartTime).ToSeconds() /
+                  mDuration.ToSeconds();
+    if (timePortion < 0.0)
+      timePortion = 0.0; // use start value during transition-delay
+    if (timePortion > 1.0)
+      timePortion = 1.0; // we might be behind on flushing
+  }
+
+  return mTimingFunction.GetSplineValue(timePortion);
+}
+
 /**
  * An ElementTransitionsStyleRule overrides style data with the
  * currently-transitioning value for an element that is executing a
  * transition.  It only matches when styling with animation.  When we
  * style without animation, we need to not use it so that we can detect
  * any new changes; if necessary we restyle immediately afterwards with
  * animation.
  */
@@ -232,36 +268,17 @@ ElementTransitionsStyleRule::MapRuleInfo
     ElementPropertyTransition &pt = et->mPropertyTransitions[i];
     if (pt.IsRemovedSentinel()) {
       continue;
     }
 
     if (aRuleData->mSIDs & nsCachedStyleData::GetBitForSID(
                              nsCSSProps::kSIDTable[pt.mProperty]))
     {
-      double duration = pt.mDuration.ToSeconds();
-      NS_ABORT_IF_FALSE(duration >= 0.0, "negative duration forbidden");
-      double timePortion;
-      if (duration == 0.0) {
-        if (RefreshTime() >= pt.mStartTime) {
-          timePortion = 0.0;
-        } else {
-          timePortion = 1.0;
-        }
-      } else {
-        timePortion = (RefreshTime() - pt.mStartTime).ToSeconds() /
-                      pt.mDuration.ToSeconds();
-        if (timePortion < 0.0)
-          timePortion = 0.0; // use start value during transition-delay
-        if (timePortion > 1.0)
-          timePortion = 1.0; // we might be behind on flushing
-      }
-
-      double valuePortion =
-        pt.mTimingFunction.GetSplineValue(timePortion);
+      double valuePortion = pt.ValuePortionFor(RefreshTime());
 #ifdef DEBUG
       PRBool ok =
 #endif
         nsStyleAnimation::Interpolate(pt.mProperty,
                                       pt.mStartValue, pt.mEndValue,
                                       valuePortion, pt.mCurrentValue);
       NS_ABORT_IF_FALSE(ok, "could not interpolate values");
 
@@ -654,80 +671,68 @@ nsTransitionManager::ConsiderStartingTra
         // |aElementTransitions| is now a dangling pointer!
         aElementTransitions = nsnull;
       }
       // WalkTransitionRule already called RestyleForAnimation.
     }
     return;
   }
 
-  // When we interrupt a running transition, we want to reduce the
-  // duration of the new transition *if* the new transition would have
-  // been longer had it started from the endpoint of the currently
-  // running transition.
-  double durationFraction = 1.0;
+  TimeStamp mostRecentRefresh =
+    presContext->RefreshDriver()->MostRecentRefresh();
+
+  const nsTimingFunction &tf = aTransition.GetTimingFunction();
+  float delay = aTransition.GetDelay();
+  float duration = aTransition.GetDuration();
+  if (duration < 0.0) {
+    // The spec says a negative duration is treated as zero.
+    duration = 0.0;
+  }
+  pt.mStartForReversingTest = pt.mStartValue;
+  pt.mReversePortion = 1.0;
 
   // We need to check two things if we have a currently running
-  // transition for this property:  see durationFraction comment above
-  // and the endpoint check below.
+  // transition for this property.
   if (currentIndex != nsTArray<ElementPropertyTransition>::NoIndex) {
     const ElementPropertyTransition &oldPT =
       aElementTransitions->mPropertyTransitions[currentIndex];
 
     if (oldPT.mEndValue == pt.mEndValue) {
       // If we got a style change that changed the value to the endpoint
       // of the currently running transition, we don't want to interrupt
       // its timing function.
       // WalkTransitionRule already called RestyleForAnimation.
       return;
     }
 
-    double fullDistance, remainingDistance;
-#ifdef DEBUG
-    PRBool ok =
-#endif
-      nsStyleAnimation::ComputeDistance(aProperty, pt.mStartValue,
-                                        pt.mEndValue, fullDistance);
-    NS_ABORT_IF_FALSE(ok, "could not compute distance");
-    NS_ABORT_IF_FALSE(fullDistance >= 0.0, "distance must be positive");
+    // If the new transition reverses the old one, we'll need to handle
+    // the timing differently.
+    if (!oldPT.IsRemovedSentinel() &&
+        oldPT.mStartForReversingTest == pt.mEndValue) {
+      // Compute the appropriate negative transition-delay such that right
+      // now we'd end up at the current position.
+      double valuePortion =
+        oldPT.ValuePortionFor(mostRecentRefresh) * oldPT.mReversePortion +
+        (1.0 - oldPT.mReversePortion); 
 
-    if (!oldPT.IsRemovedSentinel() &&
-        nsStyleAnimation::ComputeDistance(aProperty, oldPT.mEndValue,
-                                          pt.mEndValue, remainingDistance)) {
-      NS_ABORT_IF_FALSE(remainingDistance >= 0.0, "distance must be positive");
-      durationFraction = fullDistance / remainingDistance;
-      if (durationFraction > 1.0) {
-        durationFraction = 1.0;
-      }
+      // Negative delays are essentially part of the transition
+      // function, so reduce them along with the duration, but don't
+      // reduce positive delays.
+      if (delay < 0.0f)
+        delay *= valuePortion;
+      duration *= valuePortion;
+
+      pt.mStartForReversingTest = oldPT.mEndValue;
+      pt.mReversePortion = valuePortion;
     }
   }
 
-
-  nsRefreshDriver *rd = presContext->RefreshDriver();
-
   pt.mProperty = aProperty;
-  float delay = aTransition.GetDelay();
-  float duration = aTransition.GetDuration();
-  if (duration < 0.0) {
-    // The spec says a negative duration is treated as zero.
-    duration = 0.0;
-  }
-  if (durationFraction != 1.0) {
-    // Negative delays are essentially part of the transition
-    // function, so reduce them along with the duration, but don't
-    // reduce positive delays.  (See comment above about
-    // durationFraction.)
-    if (delay < 0.0f)
-        delay *= durationFraction;
-    duration *= durationFraction;
-  }
-  pt.mStartTime = rd->MostRecentRefresh() +
-                  TimeDuration::FromMilliseconds(delay);
+  pt.mStartTime = mostRecentRefresh + TimeDuration::FromMilliseconds(delay);
   pt.mDuration = TimeDuration::FromMilliseconds(duration);
-  const nsTimingFunction &tf = aTransition.GetTimingFunction();
   pt.mTimingFunction.Init(tf.mX1, tf.mY1, tf.mX2, tf.mY2);
 
   if (!aElementTransitions) {
     aElementTransitions =
       GetElementTransitions(aElement, aNewStyleContext->GetPseudoType(),
                             PR_TRUE);
     if (!aElementTransitions) {
       NS_WARNING("allocating ElementTransitions failed");
