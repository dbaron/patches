From: L. David Baron <dbaron@dbaron.org>

Remove nsStyleBorder::GetActualBorder, since it now does the same thing as nsStyleBorder::GetComputedBorder.  (Bug 713643, patch 3)

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -1397,17 +1397,17 @@ nsCSSRendering::PaintBackground(nsPresCo
                         aDirtyRect, aBorderArea, sc,
                         *aForFrame->GetStyleBorder(), aFlags,
                         aBGClipRect);
 }
 
 static bool
 IsOpaqueBorderEdge(const nsStyleBorder& aBorder, mozilla::css::Side aSide)
 {
-  if (aBorder.GetActualBorder().Side(aSide) == 0)
+  if (aBorder.GetComputedBorder().Side(aSide) == 0)
     return true;
   switch (aBorder.GetBorderStyle(aSide)) {
   case NS_STYLE_BORDER_STYLE_SOLID:
   case NS_STYLE_BORDER_STYLE_GROOVE:
   case NS_STYLE_BORDER_STYLE_RIDGE:
   case NS_STYLE_BORDER_STYLE_INSET:
   case NS_STYLE_BORDER_STYLE_OUTSET:
     break;
@@ -2639,17 +2639,17 @@ DrawBorderImage(nsPresContext*       aPr
         break;
     }
     if (value < 0)
       value = 0;
     if (value > imgDimension)
       value = imgDimension;
     slice.Side(s) = NS_lround(value);
 
-    nsMargin borderWidths(aStyleBorder.GetActualBorder());
+    nsMargin borderWidths(aStyleBorder.GetComputedBorder());
     coord = aStyleBorder.mBorderImageWidth.Get(s);
     switch (coord.GetUnit()) {
       case eStyleUnit_Coord: // absolute dimension
         value = coord.GetCoordValue();
         break;
       case eStyleUnit_Percent:
         value = coord.GetPercentValue() * borderDimension;
         break;
diff --git a/layout/forms/nsButtonFrameRenderer.cpp b/layout/forms/nsButtonFrameRenderer.cpp
--- a/layout/forms/nsButtonFrameRenderer.cpp
+++ b/layout/forms/nsButtonFrameRenderer.cpp
@@ -303,17 +303,17 @@ nsMargin
 nsButtonFrameRenderer::GetButtonOuterFocusBorderAndPadding()
 {
   nsMargin result(0,0,0,0);
 
   if (mOuterFocusStyle) {
     if (!mOuterFocusStyle->GetStylePadding()->GetPadding(result)) {
       NS_NOTYETIMPLEMENTED("percentage padding");
     }
-    result += mOuterFocusStyle->GetStyleBorder()->GetActualBorder();
+    result += mOuterFocusStyle->GetStyleBorder()->GetComputedBorder();
   }
 
   return result;
 }
 
 nsMargin
 nsButtonFrameRenderer::GetButtonBorderAndPadding()
 {
@@ -342,17 +342,17 @@ nsMargin
 nsButtonFrameRenderer::GetButtonInnerFocusBorderAndPadding()
 {
   nsMargin result(0,0,0,0);
 
   if (mInnerFocusStyle) {
     if (!mInnerFocusStyle->GetStylePadding()->GetPadding(result)) {
       NS_NOTYETIMPLEMENTED("percentage padding");
     }
-    result += mInnerFocusStyle->GetStyleBorder()->GetActualBorder();
+    result += mInnerFocusStyle->GetStyleBorder()->GetComputedBorder();
   }
 
   return result;
 }
 
 // gets all the focus borders and padding that will be added to the regular border
 nsMargin
 nsButtonFrameRenderer::GetAddedButtonBorderAndPadding()
diff --git a/layout/forms/nsHTMLButtonControlFrame.cpp b/layout/forms/nsHTMLButtonControlFrame.cpp
--- a/layout/forms/nsHTMLButtonControlFrame.cpp
+++ b/layout/forms/nsHTMLButtonControlFrame.cpp
@@ -172,17 +172,17 @@ nsHTMLButtonControlFrame::BuildDisplayLi
   }
   
   // Put the foreground outline and focus rects on top of the children
   set.Content()->AppendToTop(&onTop);
 
   // clips to our padding box for <input>s but not <button>s, unless
   // they have non-visible overflow..
   if (IsInput() || GetStyleDisplay()->mOverflowX != NS_STYLE_OVERFLOW_VISIBLE) {
-    nsMargin border = GetStyleBorder()->GetActualBorder();
+    nsMargin border = GetStyleBorder()->GetComputedBorder();
     nsRect rect(aBuilder->ToReferenceFrame(this), GetSize());
     rect.Deflate(border);
     nscoord radii[8];
     GetPaddingBoxBorderRadii(radii);
 
     nsresult rv = OverflowClip(aBuilder, set, aLists, rect, radii);
     NS_ENSURE_SUCCESS(rv, rv);
   } else {
diff --git a/layout/generic/nsAbsoluteContainingBlock.cpp b/layout/generic/nsAbsoluteContainingBlock.cpp
--- a/layout/generic/nsAbsoluteContainingBlock.cpp
+++ b/layout/generic/nsAbsoluteContainingBlock.cpp
@@ -399,17 +399,17 @@ nsAbsoluteContainingBlock::ReflowAbsolut
   // Store position and overflow rect so taht we can invalidate the correct
   // area if the position changes
   nsRect oldOverflowRect(aKidFrame->GetVisualOverflowRect() +
                          aKidFrame->GetPosition());
   nsRect oldRect = aKidFrame->GetRect();
 
   nsresult  rv;
   // Get the border values
-  const nsMargin& border = aReflowState.mStyleBorder->GetActualBorder();
+  const nsMargin& border = aReflowState.mStyleBorder->GetComputedBorder();
 
   nscoord availWidth = aContainingBlockWidth;
   if (availWidth == -1) {
     NS_ASSERTION(aReflowState.ComputedWidth() != NS_UNCONSTRAINEDSIZE,
                  "Must have a useful width _somewhere_");
     availWidth =
       aReflowState.ComputedWidth() + aReflowState.mComputedPadding.LeftRight();
   }
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -763,31 +763,32 @@ nsFrame::DidSetStyleContext(nsStyleConte
       if ((!GetStylePadding()->GetPadding(newValue) || oldValue != newValue) &&
           !props.Get(UsedPaddingProperty())) {
         props.Set(UsedPaddingProperty(), new nsMargin(oldValue));
       }
     }
 
     const nsStyleBorder* oldBorder = aOldStyleContext->PeekStyleBorder();
     if (oldBorder) {
-      oldValue = oldBorder->GetActualBorder();
-      newValue = GetStyleBorder()->GetActualBorder();
+      oldValue = oldBorder->GetComputedBorder();
+      newValue = GetStyleBorder()->GetComputedBorder();
       if (oldValue != newValue &&
           !props.Get(UsedBorderProperty())) {
         props.Set(UsedBorderProperty(), new nsMargin(oldValue));
       }
     }
   }
 
   imgIRequest *oldBorderImage = aOldStyleContext
     ? aOldStyleContext->GetStyleBorder()->GetBorderImage()
     : nsnull;
+  // FIXME: The following is no longer true.
   // For border-images, we can't be as conservative (we need to set the
   // new loaders if there has been any change) since the CalcDifference
-  // call depended on the result of GetActualBorder() and that result
+  // call depended on the result of GetComputedBorder() and that result
   // depends on whether the image has loaded, start the image load now
   // so that we'll get notified when it completes loading and can do a
   // restyle.  Otherwise, the image might finish loading from the
   // network before we start listening to its notifications, and then
   // we'll never know that it's finished loading.  Likewise, we want to
   // do this for freshly-created frames to prevent a similar race if the
   // image loads between reflow (which can depend on whether the image
   // is loaded) and paint.  We also don't really care about any callers
@@ -876,17 +877,17 @@ nsIFrame::GetUsedBorder() const
     return border;
   }
 
   nsMargin *b = static_cast<nsMargin*>
                            (Properties().Get(UsedBorderProperty()));
   if (b) {
     border = *b;
   } else {
-    border = GetStyleBorder()->GetActualBorder();
+    border = GetStyleBorder()->GetComputedBorder();
   }
   return border;
 }
 
 /* virtual */ nsMargin
 nsIFrame::GetUsedPadding() const
 {
   nsMargin padding(0, 0, 0, 0);
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -841,17 +841,17 @@ GetIntrinsicSizeFor(nsIFrame* aFrame, ns
  * aOutsideBoxSizing returns the rest.
  */
 void
 nsHTMLReflowState::CalculateHorizBorderPaddingMargin(
                        nscoord aContainingBlockWidth,
                        nscoord* aInsideBoxSizing,
                        nscoord* aOutsideBoxSizing)
 {
-  const nsMargin& border = mStyleBorder->GetActualBorder();
+  const nsMargin& border = mStyleBorder->GetComputedBorder();
   nsMargin padding, margin;
 
   // See if the style system can provide us the padding directly
   if (!mStylePadding->GetPadding(padding)) {
     // We have to compute the left and right values
     padding.left = nsLayoutUtils::
       ComputeWidthDependentValue(aContainingBlockWidth,
                                  mStylePadding->mPadding.GetLeft());
@@ -2040,17 +2040,17 @@ nsCSSOffsetState::InitOffsets(nscoord aC
       presContext->DevPixelsToAppUnits(widget.bottom);
     mComputedBorderPadding.left =
       presContext->DevPixelsToAppUnits(widget.left);
   }
   else if (aBorder) {  // border is an input arg
     mComputedBorderPadding = *aBorder;
   }
   else {
-    mComputedBorderPadding = frame->GetStyleBorder()->GetActualBorder();
+    mComputedBorderPadding = frame->GetStyleBorder()->GetComputedBorder();
   }
   mComputedBorderPadding += mComputedPadding;
 
   if (aFrameType == nsGkAtoms::tableFrame) {
     nsTableFrame *tableFrame = static_cast<nsTableFrame*>(frame);
 
     if (tableFrame->IsBorderCollapse()) {
       // border-collapsed tables don't use any of their padding, and
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -547,19 +547,19 @@ nsStyleBorder::Destroy(nsPresContext* aC
 nsChangeHint nsStyleBorder::CalcDifference(const nsStyleBorder& aOther) const
 {
   nsChangeHint shadowDifference =
     CalcShadowDifference(mBoxShadow, aOther.mBoxShadow);
 
   // Note that differences in mBorder don't affect rendering (which should only
   // use mComputedBorder), so don't need to be tested for here.
   // XXXbz we should be able to return a more specific change hint for
-  // at least GetActualBorder() differences...
+  // at least GetComputedBorder() differences...
   if (mTwipsPerPixel != aOther.mTwipsPerPixel ||
-      GetActualBorder() != aOther.GetActualBorder() ||
+      GetComputedBorder() != aOther.GetComputedBorder() ||
       mFloatEdge != aOther.mFloatEdge ||
       mBorderImageOutset != aOther.mBorderImageOutset ||
       (shadowDifference & nsChangeHint_ReflowFrame))
     return NS_STYLE_HINT_REFLOW;
 
   // Note that mBorderStyle stores not only the border style but also
   // color-related flags.  Given that we've already done an mComputedBorder
   // comparison, border-style differences can only lead to a VISUAL hint.  So
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -809,22 +809,16 @@ struct nsStyleBorder {
   {
     nscoord roundedWidth =
       NS_ROUND_BORDER_TO_PIXELS(aBorderWidth, mTwipsPerPixel);
     mBorder.Side(aSide) = roundedWidth;
     if (HasVisibleStyle(aSide))
       mComputedBorder.Side(aSide) = roundedWidth;
   }
 
-  // Returns the computed border.
-  inline const nsMargin& GetActualBorder() const
-  {
-    return mComputedBorder;
-  }
-
   // Get the computed border (plus rounding).  This does consider the
   // effects of 'border-style: none', but does not consider
   // 'border-image'.
   const nsMargin& GetComputedBorder() const
   {
     return mComputedBorder;
   }
 
@@ -834,17 +828,17 @@ struct nsStyleBorder {
   }
 
   // Get the actual border width for a particular side, in appunits.  Note that
   // this is zero if and only if there is no border to be painted for this
   // side.  That is, this value takes into account the border style and the
   // value is rounded to the nearest device pixel by NS_ROUND_BORDER_TO_PIXELS.
   nscoord GetActualBorderWidth(mozilla::css::Side aSide) const
   {
-    return GetActualBorder().Side(aSide);
+    return GetComputedBorder().Side(aSide);
   }
 
   PRUint8 GetBorderStyle(mozilla::css::Side aSide) const
   {
     NS_ASSERTION(aSide <= NS_SIDE_LEFT, "bad side");
     return (mBorderStyle[aSide] & BORDER_STYLE_MASK);
   }
 
diff --git a/layout/tables/nsTableCellFrame.cpp b/layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp
+++ b/layout/tables/nsTableCellFrame.cpp
@@ -1036,17 +1036,17 @@ NS_NewTableCellFrame(nsIPresShell*   aPr
     return new (aPresShell) nsTableCellFrame(aContext);
 }
 
 NS_IMPL_FRAMEARENA_HELPERS(nsBCTableCellFrame)
 
 nsMargin*
 nsTableCellFrame::GetBorderWidth(nsMargin&  aBorder) const
 {
-  aBorder = GetStyleBorder()->GetActualBorder();
+  aBorder = GetStyleBorder()->GetComputedBorder();
   return &aBorder;
 }
 
 nsIAtom*
 nsTableCellFrame::GetType() const
 {
   return nsGkAtoms::tableCellFrame;
 }
diff --git a/layout/tables/nsTableFrame.cpp b/layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp
+++ b/layout/tables/nsTableFrame.cpp
@@ -2440,17 +2440,17 @@ static
 void GetSeparateModelBorderPadding(const nsHTMLReflowState* aReflowState,
                                    nsStyleContext&          aStyleContext,
                                    nsMargin&                aBorderPadding)
 {
   // XXXbz Either we _do_ have a reflow state and then we can use its
   // mComputedBorderPadding or we don't and then we get the padding
   // wrong!
   const nsStyleBorder* border = aStyleContext.GetStyleBorder();
-  aBorderPadding = border->GetActualBorder();
+  aBorderPadding = border->GetComputedBorder();
   if (aReflowState) {
     aBorderPadding += aReflowState->mComputedPadding;
   }
 }
 
 nsMargin
 nsTableFrame::GetChildAreaOffset(const nsHTMLReflowState* aReflowState) const
 {
diff --git a/layout/xul/base/src/nsBox.cpp b/layout/xul/base/src/nsBox.cpp
--- a/layout/xul/base/src/nsBox.cpp
+++ b/layout/xul/base/src/nsBox.cpp
@@ -353,17 +353,17 @@ nsBox::GetBorder(nsMargin& aMargin)
       aMargin.top = context->DevPixelsToAppUnits(margin.top);
       aMargin.right = context->DevPixelsToAppUnits(margin.right);
       aMargin.bottom = context->DevPixelsToAppUnits(margin.bottom);
       aMargin.left = context->DevPixelsToAppUnits(margin.left);
       return NS_OK;
     }
   }
 
-  aMargin = GetStyleBorder()->GetActualBorder();
+  aMargin = GetStyleBorder()->GetComputedBorder();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsBox::GetPadding(nsMargin& aMargin)
 {
   const nsStyleDisplay *disp = GetStyleDisplay();
diff --git a/layout/xul/base/src/nsGroupBoxFrame.cpp b/layout/xul/base/src/nsGroupBoxFrame.cpp
--- a/layout/xul/base/src/nsGroupBoxFrame.cpp
+++ b/layout/xul/base/src/nsGroupBoxFrame.cpp
@@ -155,17 +155,17 @@ nsGroupBoxFrame::BuildDisplayList(nsDisp
   // REVIEW: Debug borders now painted by nsFrame::BuildDisplayListForChild
 }
 
 void
 nsGroupBoxFrame::PaintBorderBackground(nsRenderingContext& aRenderingContext,
     nsPoint aPt, const nsRect& aDirtyRect) {
   PRIntn skipSides = 0;
   const nsStyleBorder* borderStyleData = GetStyleBorder();
-  const nsMargin& border = borderStyleData->GetActualBorder();
+  const nsMargin& border = borderStyleData->GetComputedBorder();
   nscoord yoff = 0;
   nsPresContext* presContext = PresContext();
 
   nsRect groupRect;
   nsIBox* groupBox = GetCaptionBox(presContext, groupRect);
 
   if (groupBox) {        
     // if the border is smaller than the legend. Move the border down
diff --git a/layout/xul/base/src/nsListBoxBodyFrame.cpp b/layout/xul/base/src/nsListBoxBodyFrame.cpp
--- a/layout/xul/base/src/nsListBoxBodyFrame.cpp
+++ b/layout/xul/base/src/nsListBoxBodyFrame.cpp
@@ -700,17 +700,17 @@ nsListBoxBodyFrame::ComputeIntrinsicWidt
     styleContext = presContext->StyleSet()->
       ResolveStyleFor(firstRowContent->AsElement(), nsnull);
 
     nscoord width = 0;
     nsMargin margin(0,0,0,0);
 
     if (styleContext->GetStylePadding()->GetPadding(margin))
       width += margin.LeftRight();
-    width += styleContext->GetStyleBorder()->GetActualBorder().LeftRight();
+    width += styleContext->GetStyleBorder()->GetComputedBorder().LeftRight();
     if (styleContext->GetStyleMargin()->GetMargin(margin))
       width += margin.LeftRight();
 
 
     ChildIterator iter, last;
     PRUint32 i = 0;
     for (ChildIterator::Init(mContent, &iter, &last);
          iter != last && i < 100;
diff --git a/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp b/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp
--- a/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp
+++ b/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp
@@ -182,17 +182,17 @@ nsTreeBodyFrame::~nsTreeBodyFrame()
 
 static void
 GetBorderPadding(nsStyleContext* aContext, nsMargin& aMargin)
 {
   aMargin.SizeTo(0, 0, 0, 0);
   if (!aContext->GetStylePadding()->GetPadding(aMargin)) {
     NS_NOTYETIMPLEMENTED("percentage padding");
   }
-  aMargin += aContext->GetStyleBorder()->GetActualBorder();
+  aMargin += aContext->GetStyleBorder()->GetComputedBorder();
 }
 
 static void
 AdjustForBorderPadding(nsStyleContext* aContext, nsRect& aRect)
 {
   nsMargin borderPadding(0, 0, 0, 0);
   GetBorderPadding(aContext, borderPadding);
   aRect.Deflate(borderPadding);
