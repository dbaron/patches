From: L. David Baron <dbaron@dbaron.org>

Add test for bug 403443.  r=roc

diff --git a/layout/base/tests/scrolling_helper.html b/layout/base/tests/scrolling_helper.html
--- a/layout/base/tests/scrolling_helper.html
+++ b/layout/base/tests/scrolling_helper.html
@@ -123,16 +123,42 @@ iframe {
 
 <div id="testTableNoBackground" class="testcase">
   <table style="position:fixed; width:200px; height:200px;">
     <tr><td></td></tr>
   </table>
   <div style="height:300px; background:-moz-linear-gradient(top, red, black);"></div>
 </div>
 
+<iframe class="testcase" id="testNoBlitInSVG" height="200" width="200"
+        src="data:text/html,<body class='testcase' style='margin:0; height:300px; background:-moz-linear-gradient(top, red, black);'>">
+</iframe>
+<script>
+// We're not in XHTML, so we have to make our SVG elements with script.
+var SVG_NS = "http://www.w3.org/2000/svg";
+var svg = document.createElementNS(SVG_NS, "svg");
+svg.setAttribute("style", "width: 300px; height: 300px");
+var g = document.createElementNS(SVG_NS, "g");
+g.setAttribute("transform", "translate(100,0) rotate(30)");
+var fo = document.createElementNS(SVG_NS, "foreignObject");
+fo.setAttribute("x", "0");
+fo.setAttribute("y", "0");
+fo.setAttribute("width", "200");
+fo.setAttribute("height", "200");
+var iframe = document.getElementById("testNoBlitInSVG");
+iframe.parentNode.replaceChild(svg, iframe);
+fo.appendChild(iframe);
+g.appendChild(fo);
+svg.appendChild(g);
+</script>
+
+<iframe class="testcase" id="testNoBlitInTransform" height="200" width="200" style="-moz-transform-origin: 0 0; -moz-transform: translateX(100px) rotate(30deg)"
+        src="data:text/html,<body class='testcase' style='margin:0; height:300px; background:-moz-linear-gradient(top, red, black);'>">
+</iframe>
+
 <script>
 var testcases = document.querySelectorAll("div.testcase");
 var tests = [];
 var iframes = document.querySelectorAll("iframe.testcase");
 
 var currentTest = -1;
 
 function ok(a, msg) {
@@ -304,21 +330,51 @@ function testHiddenTable(blitRegion, pai
 
 function testTableNoBackground(blitRegion, paintRegion) {
   ok(blitRegion.equalsRegion(new Region([[0,0,200,180]])),
      "Should blit everything that was already visible: " + blitRegion.toString());
   ok(paintRegion.equalsRegion(new Region([[0,180,200,200]])),
      "Should repaint area that was scrolled into view: " + paintRegion.toString());
 }
 
+function testNoBlitInSVG(blitRegion, paintRegion) {
+  ok(blitRegion.isEmpty(), "should not blit when in transformed SVG");
+  // We're looking at regions in the coordinates of the inner iframe.
+  // (Not the most useful test, but it does test the particular bug that we
+  // should be repainting rather than blitting.)
+  ok(paintRegion.equalsRegion(new Region([[0,0,200,200]])),
+     "repaint rect must contain area completely inside scrolled region");
+}
+
+function testNoBlitInTransform(blitRegion, paintRegion) {
+  ok(blitRegion.isEmpty(), "should not blit when in CSS Transform");
+  // We're looking at regions in the coordinates of the inner iframe.
+  // (Not the most useful test, but it does test the particular bug that we
+  // should be repainting rather than blitting.)
+  ok(paintRegion.equalsRegion(new Region([[0,0,200,200]])),
+     "repaint rect must contain area completely inside scrolled region");
+}
+
 function clientRectToRect(cr)
 {
   return [cr.left, cr.top, cr.right, cr.bottom];
 }
 
+// Return the ancestor-or-self of |container| that is a child of body.
+function bodyChild(container)
+{
+  var prev;
+  var next = container;
+  do {
+    prev = next;
+    next = prev.parentNode;
+  } while (next != document.body);
+  return prev;
+}
+
 function regionForReason(requests, reason)
 {
   var rects = [];
   for (var i = 0; i < requests.length; ++i) {
     var r = requests[i];
     if (r.reason == reason) {
       rects.push(clientRectToRect(r.clientRect));
     }
@@ -342,30 +398,30 @@ function afterPaint(event) {
     return;
 
   var testFunc = window[tests[currentTest].container.id];
   if (!testFunc) {
     ok(false, "Cannot find test function for " + tests[currentTest].container.id);
   } else {
     testFunc(blitRegion, paintRegion);
   }
-  tests[currentTest].container.style.display = 'none';
+  bodyChild(tests[currentTest].container).style.display = 'none';
 
   nextTest();
 }
 
 function nextTest() {
   ++currentTest;
   if (currentTest >= tests.length) {
     finish();
     return;
   }
 
   var t = tests[currentTest];
-  t.container.style.display = "";
+  bodyChild(t.container).style.display = "";
   setTimeout(function() {
     if (t.scrollable.getAttribute("class").match(/horizontal/)) {
       t.scrollable.scrollLeft = 20;
     } else {
       t.scrollable.scrollTop = 20;
     }
   }, 0);
 }
@@ -375,17 +431,17 @@ function runTests() {
     tests.push({ scrollable:testcases[i], container:testcases[i] });
   }
   for (var i = 0; i < iframes.length; ++i) {
     tests.push({ scrollable:iframes[i].contentDocument.body, container:iframes[i] });
   }
 
   for (var i = 0; i < tests.length; ++i) {
     var t = tests[i];
-    t.container.style.display = "none";
+    bodyChild(t.container).style.display = "none";
     // Make sure we don't remember a scroll position from history
     t.scrollable.scrollTop = 0;
     t.scrollable.scrollLeft = 0;
   }
 
   window.addEventListener("MozAfterPaint", afterPaint, false);
   for (var i = 0; i < iframes.length; ++i) {
     iframes[i].contentWindow.addEventListener("MozAfterPaint", afterPaint, false);
