From: L. David Baron <dbaron@dbaron.org>

Introduce MatchContext for additional output from SelectorMatchesTree.  (Bug 147777)

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1199,16 +1199,42 @@ RuleProcessorData::GetNthIndex(PRBool aI
 #ifdef DEBUG
   NS_ASSERTION(!debugMutationGuard.Mutated(0), "Unexpected mutations happened");
 #endif  
 
   slot = result;
   return result;
 }
 
+/**
+ * A |MatchContext| has data about matching a selector (containing
+ * combinators) against a node and the tree that that node is in.  It
+ * contains both input to and output from the matching.
+ *
+ * (In contrast, a RuleProcessorData has information needed to match a
+ * selector (without combinators) against a single node; it only
+ * has input to the matching.)
+ */
+struct MatchContext {
+  // Is this matching operation for the creation of a style context?
+  // (If it is, we need to set slow selector bits on nodes indicating
+  // that certain restyling needs to happen.)
+  const PRBool mForStyling;
+
+  // Did this matching operation find a relevant link?  (If so, we'll
+  // need to construct a StyleIfVisited().)
+  PRBool mHaveRelevantLink;
+
+  MatchContext(PRBool aForStyling)
+    : mForStyling(aForStyling)
+    , mHaveRelevantLink(PR_FALSE)
+  {
+  }
+};
+
 static PRBool ValueIncludes(const nsSubstring& aValueList,
                             const nsSubstring& aValue,
                             const nsStringComparator& aComparator)
 {
   const PRUnichar *p = aValueList.BeginReading(),
               *p_end = aValueList.EndReading();
 
   while (p < p_end) {
@@ -1298,135 +1324,135 @@ static PRBool AttrMatchesValue(const nsA
       NS_NOTREACHED("Shouldn't be ending up here");
       return PR_FALSE;
   }
 }
 
 static PRBool SelectorMatches(RuleProcessorData &data,
                               nsCSSSelector* aSelector,
                               PRInt32 aStateMask,
-                              PRBool aForStyling,
+                              MatchContext* aMatchContext,
                               PRBool* const aDependence = nsnull);
 
 static PRBool NS_FASTCALL
-anyMatches(RuleProcessorData& data, PRBool setNodeFlags,
+anyMatches(RuleProcessorData& data, MatchContext* aMatchContext,
            PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::any,
                   "Unexpected atom");
   for (nsCSSSelectorList *l = pseudoClass->u.mSelectors; l; l = l->mNext) {
     nsCSSSelector *s = l->mSelectors;
     NS_ABORT_IF_FALSE(!s->mNext && !s->IsPseudoElement(), "parser failed");
-    if (SelectorMatches(data, s, aStateMask, setNodeFlags)) {
+    if (SelectorMatches(data, s, aStateMask, aMatchContext)) {
       return PR_TRUE;
     }
   }
   return PR_FALSE;
 }
 
 static PRBool NS_FASTCALL
-firstNodeMatches(RuleProcessorData& data, PRBool setNodeFlags,
+firstNodeMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                  PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::firstNode,
                   "Unexpected atom");
   nsIContent *firstNode = nsnull;
   nsIContent *parent = data.mParentContent;
   if (parent) {
-    if (setNodeFlags)
+    if (aMatchContext->mForStyling)
       parent->SetFlags(NODE_HAS_EDGE_CHILD_SELECTOR);
 
     PRInt32 index = -1;
     do {
       firstNode = parent->GetChildAt(++index);
       // stop at first non-comment and non-whitespace node
     } while (firstNode &&
              !IsSignificantChild(firstNode, PR_TRUE, PR_FALSE));
   }
   return (data.mContent == firstNode);
 }
 
 static PRBool NS_FASTCALL
-lastNodeMatches(RuleProcessorData& data, PRBool setNodeFlags,
+lastNodeMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                 PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::lastNode,
                   "Unexpected atom");
   nsIContent *lastNode = nsnull;
   nsIContent *parent = data.mParentContent;
   if (parent) {
-    if (setNodeFlags)
+    if (aMatchContext->mForStyling)
       parent->SetFlags(NODE_HAS_EDGE_CHILD_SELECTOR);
 
     PRUint32 index = parent->GetChildCount();
     do {
       lastNode = parent->GetChildAt(--index);
       // stop at first non-comment and non-whitespace node
     } while (lastNode &&
              !IsSignificantChild(lastNode, PR_TRUE, PR_FALSE));
   }
   return (data.mContent == lastNode);
 }
 
 static inline PRBool
-edgeChildMatches(RuleProcessorData& data, PRBool setNodeFlags,
+edgeChildMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                  PRBool checkFirst, PRBool checkLast)
 {
   nsIContent *parent = data.mParentContent;
   if (!parent) {
     return PR_FALSE;
   }
 
-  if (setNodeFlags)
+  if (aMatchContext->mForStyling)
     parent->SetFlags(NODE_HAS_EDGE_CHILD_SELECTOR);
 
   return (!checkFirst ||
           data.GetNthIndex(PR_FALSE, PR_FALSE, PR_TRUE) == 1) &&
          (!checkLast ||
           data.GetNthIndex(PR_FALSE, PR_TRUE, PR_TRUE) == 1);
 }
 
 static PRBool NS_FASTCALL
-firstChildMatches(RuleProcessorData& data, PRBool setNodeFlags,
+firstChildMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                   PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::firstChild,
                   "Unexpected atom");
-  return edgeChildMatches(data, setNodeFlags, PR_TRUE, PR_FALSE);
+  return edgeChildMatches(data, aMatchContext, PR_TRUE, PR_FALSE);
 }
 
 static PRBool NS_FASTCALL
-lastChildMatches(RuleProcessorData& data, PRBool setNodeFlags,
+lastChildMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                  PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::lastChild,
                   "Unexpected atom");
-  return edgeChildMatches(data, setNodeFlags, PR_FALSE, PR_TRUE);
+  return edgeChildMatches(data, aMatchContext, PR_FALSE, PR_TRUE);
 }
 
 static PRBool NS_FASTCALL
-onlyChildMatches(RuleProcessorData& data, PRBool setNodeFlags,
+onlyChildMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                  PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::onlyChild,
                   "Unexpected atom");
-  return edgeChildMatches(data, setNodeFlags, PR_TRUE, PR_TRUE);
+  return edgeChildMatches(data, aMatchContext, PR_TRUE, PR_TRUE);
 }
 
 static inline PRBool
-nthChildGenericMatches(RuleProcessorData& data, PRBool setNodeFlags,
+nthChildGenericMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                        nsPseudoClassList* pseudoClass,
                        PRBool isOfType, PRBool isFromEnd)
 {
   nsIContent *parent = data.mParentContent;
   if (!parent) {
     return PR_FALSE;
   }
 
-  if (setNodeFlags) {
+  if (aMatchContext->mForStyling) {
     if (isFromEnd)
       parent->SetFlags(NODE_HAS_SLOW_SELECTOR);
     else
       parent->SetFlags(NODE_HAS_SLOW_SELECTOR_NOAPPEND);
   }
 
   const PRInt32 index = data.GetNthIndex(isOfType, isFromEnd, PR_FALSE);
   if (index <= 0) {
@@ -1445,156 +1471,156 @@ nthChildGenericMatches(RuleProcessorData
   // Integer division in C does truncation (towards 0).  So
   // check that the result is nonnegative, and that there was no
   // truncation.
   const PRInt32 n = (index - b) / a;
   return n >= 0 && (a * n == index - b);
 }
 
 static PRBool NS_FASTCALL
-nthChildMatches(RuleProcessorData& data, PRBool setNodeFlags,
+nthChildMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                 PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::nthChild,
                   "Unexpected atom");
-  return nthChildGenericMatches(data, setNodeFlags, pseudoClass,
+  return nthChildGenericMatches(data, aMatchContext, pseudoClass,
                                 PR_FALSE, PR_FALSE);
 }
 
 static PRBool NS_FASTCALL
-nthLastChildMatches(RuleProcessorData& data, PRBool setNodeFlags,
+nthLastChildMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                     PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::nthLastChild,
                   "Unexpected atom");
-  return nthChildGenericMatches(data, setNodeFlags, pseudoClass,
+  return nthChildGenericMatches(data, aMatchContext, pseudoClass,
                                 PR_FALSE, PR_TRUE);
 }
 
 static PRBool NS_FASTCALL
-nthOfTypeMatches(RuleProcessorData& data, PRBool setNodeFlags,
+nthOfTypeMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                  PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::nthOfType,
                   "Unexpected atom");
-  return nthChildGenericMatches(data, setNodeFlags, pseudoClass,
+  return nthChildGenericMatches(data, aMatchContext, pseudoClass,
                                 PR_TRUE, PR_FALSE);
 }
 
 static PRBool NS_FASTCALL
-nthLastOfTypeMatches(RuleProcessorData& data, PRBool setNodeFlags,
+nthLastOfTypeMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                      PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::nthLastOfType,
                   "Unexpected atom");
-  return nthChildGenericMatches(data, setNodeFlags, pseudoClass,
+  return nthChildGenericMatches(data, aMatchContext, pseudoClass,
                                 PR_TRUE, PR_TRUE);
 }
 
 static inline PRBool
-edgeOfTypeMatches(RuleProcessorData& data, PRBool setNodeFlags,
+edgeOfTypeMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                   PRBool checkFirst, PRBool checkLast)
 {
   nsIContent *parent = data.mParentContent;
   if (!parent) {
     return PR_FALSE;
   }
 
-  if (setNodeFlags) {
+  if (aMatchContext->mForStyling) {
     if (checkLast)
       parent->SetFlags(NODE_HAS_SLOW_SELECTOR);
     else
       parent->SetFlags(NODE_HAS_SLOW_SELECTOR_NOAPPEND);
   }
 
   return (!checkFirst ||
           data.GetNthIndex(PR_TRUE, PR_FALSE, PR_TRUE) == 1) &&
          (!checkLast ||
           data.GetNthIndex(PR_TRUE, PR_TRUE, PR_TRUE) == 1);
 }
 
 static PRBool NS_FASTCALL
-firstOfTypeMatches(RuleProcessorData& data, PRBool setNodeFlags,
+firstOfTypeMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                    PRBool aStateMask, nsPseudoClassList* pseudoClass)
 { 
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::firstOfType,
                   "Unexpected atom");
-  return edgeOfTypeMatches(data, setNodeFlags, PR_TRUE, PR_FALSE);
+  return edgeOfTypeMatches(data, aMatchContext, PR_TRUE, PR_FALSE);
 }
 
 static PRBool NS_FASTCALL
-lastOfTypeMatches(RuleProcessorData& data, PRBool setNodeFlags,
+lastOfTypeMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                   PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::lastOfType,
                   "Unexpected atom");
-  return edgeOfTypeMatches(data, setNodeFlags, PR_FALSE, PR_TRUE);
+  return edgeOfTypeMatches(data, aMatchContext, PR_FALSE, PR_TRUE);
 }
 
 static PRBool NS_FASTCALL
-onlyOfTypeMatches(RuleProcessorData& data, PRBool setNodeFlags,
+onlyOfTypeMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                   PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::onlyOfType,
                   "Unexpected atom");
-  return edgeOfTypeMatches(data, setNodeFlags, PR_TRUE, PR_TRUE);
+  return edgeOfTypeMatches(data, aMatchContext, PR_TRUE, PR_TRUE);
 }
 
 static inline PRBool
-checkGenericEmptyMatches(RuleProcessorData& data, PRBool setNodeFlags,
+checkGenericEmptyMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                          PRBool isWhitespaceSignificant)
 {
   nsIContent *child = nsnull;
   nsIContent *element = data.mContent;
   PRInt32 index = -1;
 
-  if (setNodeFlags)
+  if (aMatchContext->mForStyling)
     element->SetFlags(NODE_HAS_EMPTY_SELECTOR);
 
   do {
     child = element->GetChildAt(++index);
     // stop at first non-comment (and non-whitespace for
     // :-moz-only-whitespace) node        
   } while (child && !IsSignificantChild(child, PR_TRUE, isWhitespaceSignificant));
   return (child == nsnull);
 }
 
 static PRBool NS_FASTCALL
-emptyMatches(RuleProcessorData& data, PRBool setNodeFlags,
+emptyMatches(RuleProcessorData& data, MatchContext* aMatchContext,
              PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::empty,
                   "Unexpected atom");
-  return checkGenericEmptyMatches(data, setNodeFlags, PR_TRUE);
+  return checkGenericEmptyMatches(data, aMatchContext, PR_TRUE);
 }
 
 static PRBool NS_FASTCALL
-mozOnlyWhitespaceMatches(RuleProcessorData& data, PRBool setNodeFlags,
+mozOnlyWhitespaceMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                          PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::mozOnlyWhitespace,
                   "Unexpected atom");
-  return checkGenericEmptyMatches(data, setNodeFlags, PR_FALSE);
+  return checkGenericEmptyMatches(data, aMatchContext, PR_FALSE);
 }
 
 static PRBool NS_FASTCALL
 mozEmptyExceptChildrenWithLocalnameMatches(RuleProcessorData& data,
-                                           PRBool setNodeFlags,
+                                           MatchContext* aMatchContext,
                                            PRBool aStateMask,
                                            nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom ==
                     nsCSSPseudoClasses::mozEmptyExceptChildrenWithLocalname,
                   "Unexpected atom");
   NS_ASSERTION(pseudoClass->u.mString, "Must have string!");
   nsIContent *child = nsnull;
   nsIContent *element = data.mContent;
   PRInt32 index = -1;
 
-  if (setNodeFlags)
+  if (aMatchContext->mForStyling)
     // FIXME:  This isn't sufficient to handle:
     //   :-moz-empty-except-children-with-localname() + E
     //   :-moz-empty-except-children-with-localname() ~ E
     // because we don't know to restyle the grandparent of the
     // inserted/removed element (as in bug 534804 for :empty).
     element->SetFlags(NODE_HAS_SLOW_SELECTOR);
 
   do {
@@ -1602,28 +1628,28 @@ mozEmptyExceptChildrenWithLocalnameMatch
   } while (child &&
            (!IsSignificantChild(child, PR_TRUE, PR_FALSE) ||
             (child->GetNameSpaceID() == element->GetNameSpaceID() &&
              child->Tag()->Equals(nsDependentString(pseudoClass->u.mString)))));
   return (child == nsnull);
 }
 
 static PRBool NS_FASTCALL
-mozSystemMetricMatches(RuleProcessorData& data, PRBool setNodeFlags,
+mozSystemMetricMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                        PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::mozSystemMetric,
                   "Unexpected atom");
   NS_ASSERTION(pseudoClass->u.mString, "Must have string!");
   nsCOMPtr<nsIAtom> metric = do_GetAtom(pseudoClass->u.mString);
   return nsCSSRuleProcessor::HasSystemMetric(metric);
 }
 
 static PRBool NS_FASTCALL
-mozHasHandlerRefMatches(RuleProcessorData& data, PRBool setNodeFlags,
+mozHasHandlerRefMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                         PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::mozHasHandlerRef,
                   "Unexpected atom");
   nsIContent *child = nsnull;
   nsIContent *element = data.mContent;
   PRInt32 index = -1;
 
@@ -1635,39 +1661,39 @@ mozHasHandlerRefMatches(RuleProcessorDat
                            NS_LITERAL_STRING("pluginurl"), eIgnoreCase)) {
       return PR_TRUE;
     }
   } while (child);
   return PR_FALSE;
 }
 
 static PRBool NS_FASTCALL
-rootMatches(RuleProcessorData& data, PRBool setNodeFlags,
+rootMatches(RuleProcessorData& data, MatchContext* aMatchContext,
             PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::root,
                   "Unexpected atom");
   return (data.mParentContent == nsnull &&
           data.mContent == data.mContent->GetOwnerDoc()->GetRootContent());
 }
 
 static PRBool NS_FASTCALL
-mozBoundElementMatches(RuleProcessorData& data, PRBool setNodeFlags,
+mozBoundElementMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                        PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::mozBoundElement,
                   "Unexpected atom");
   // XXXldb How do we know where the selector came from?  And what
   // if there are multiple bindings, and we should be matching the
   // outer one?
   return (data.mScopedRoot == data.mContent);
 }
 
 static PRBool NS_FASTCALL
-langMatches(RuleProcessorData& data, PRBool setNodeFlags,
+langMatches(RuleProcessorData& data, MatchContext* aMatchContext,
             PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::lang,
                   "Unexpected atom");
   NS_ASSERTION(nsnull != pseudoClass->u.mString, "null lang parameter");
   if (!pseudoClass->u.mString || !*pseudoClass->u.mString) {
     return PR_FALSE;
   }
@@ -1710,26 +1736,26 @@ langMatches(RuleProcessorData& data, PRB
       begin = end + 1;
     }
   }
 
   return PR_FALSE;
 }
 
 static PRBool NS_FASTCALL
-mozIsHTMLMatches(RuleProcessorData& data, PRBool setNodeFlags,
+mozIsHTMLMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                  PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::mozIsHTML,
                   "Unexpected atom");
   return data.mIsHTML;
 }
 
 static PRBool NS_FASTCALL
-mozLocaleDirMatches(RuleProcessorData& data, PRBool setNodeFlags,
+mozLocaleDirMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                     PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::mozLocaleDir,
                   "Unexpected atom");
   nsIDocument* doc = data.mContent->GetDocument();
 
   if (!doc) {
     return PR_FALSE;
@@ -1740,57 +1766,58 @@ mozLocaleDirMatches(RuleProcessorData& d
   nsDependentString dirString(pseudoClass->u.mString);
   NS_ASSERTION(dirString.EqualsLiteral("ltr") || dirString.EqualsLiteral("rtl"),
                "invalid value for -moz-locale-dir");
 
   return dirString.EqualsLiteral("rtl") == docIsRTL;
 }
 
 static PRBool NS_FASTCALL
-mozLWThemeMatches(RuleProcessorData& data, PRBool setNodeFlags,
+mozLWThemeMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                   PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::mozLWTheme,
                   "Unexpected atom");
   nsIDocument* doc = data.mContent->GetOwnerDoc();
   return doc && doc->GetDocumentLWTheme() > nsIDocument::Doc_Theme_None;
 }
 
 static PRBool NS_FASTCALL
-mozLWThemeBrightTextMatches(RuleProcessorData& data, PRBool setNodeFlags,
+mozLWThemeBrightTextMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                             PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom ==
                     nsCSSPseudoClasses::mozLWThemeBrightText,
                   "Unexpected atom");
   nsIDocument* doc = data.mContent->GetOwnerDoc();
   return doc && doc->GetDocumentLWTheme() == nsIDocument::Doc_Theme_Bright;
 }
 
 static PRBool NS_FASTCALL
-mozLWThemeDarkTextMatches(RuleProcessorData& data, PRBool setNodeFlags,
+mozLWThemeDarkTextMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                           PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom ==
                     nsCSSPseudoClasses::mozLWThemeDarkText,
                   "Unexpected atom");
   nsIDocument* doc = data.mContent->GetOwnerDoc();
   return doc && doc->GetDocumentLWTheme() == nsIDocument::Doc_Theme_Dark;
 }
 
 static PRBool NS_FASTCALL
-notPseudoMatches(RuleProcessorData& data, PRBool setNodeFlags,
+notPseudoMatches(RuleProcessorData& data, MatchContext* aMatchContext,
                  PRBool aStateMask, nsPseudoClassList* pseudoClass)
 {
   NS_NOTREACHED("Why did this get called?");
   return PR_FALSE;
 }
 
 typedef PRBool
-  (NS_FASTCALL * PseudoClassMatcher)(RuleProcessorData&, PRBool setNodeFlags,
+  (NS_FASTCALL * PseudoClassMatcher)(RuleProcessorData&,
+                                     MatchContext* aMatchContext,
                                      PRBool aStateMask,
                                      nsPseudoClassList* pseudoClass);
 // Only one of mFunc or mBits will be set; the other will be null or 0
 // respectively.  We could use a union, but then we'd still need to
 // differentiate somehow, eiher with another member in the struct or
 // with a boolean coming from _sowewhere_.
 struct PseudoClassInfo {
   PseudoClassMatcher mFunc;
@@ -1815,27 +1842,25 @@ PR_STATIC_ASSERT(NS_ARRAY_LENGTH(sPseudo
 
 // NOTE: For |aStateMask| to work correctly, it's important that any change
 // that changes multiple state bits include all those state bits in the
 // notification.  Otherwise, if multiple states change but we do separate
 // notifications then we might determine the style is not state-dependent when
 // it really is (e.g., determining that a :hover:active rule no longer matches
 // when both states are unset).
 
-// If |aForStyling| is false, we shouldn't mark slow-selector bits on nodes.
-
 // |aDependence| has two functions:
 //  * when non-null, it indicates that we're processing a negation,
 //    which is done only when SelectorMatches calls itself recursively
 //  * what it points to should be set to true whenever a test is skipped
 //    because of aStateMask
 static PRBool SelectorMatches(RuleProcessorData &data,
                               nsCSSSelector* aSelector,
                               PRInt32 aStateMask, // states NOT to test
-                              PRBool aForStyling,
+                              MatchContext* aMatchContext,
                               PRBool* const aDependence /* = nsnull */)
 
 {
   NS_PRECONDITION(!aSelector->IsPseudoElement(),
                   "Pseudo-element snuck into SelectorMatches?");
   // namespace/tag match
   // optimization : bail out early if we can
   if ((kNameSpaceID_Unknown != aSelector->mNameSpace &&
@@ -1905,27 +1930,26 @@ static PRBool SelectorMatches(RuleProces
   }
 
   const PRBool isNegated = (aDependence != nsnull);
   // The selectors for which we set node bits are, unfortunately, early
   // in this function (because they're pseudo-classes, which are
   // generally quick to test, and thus earlier).  If they were later,
   // we'd probably avoid setting those bits in more cases where setting
   // them is unnecessary.
-  NS_ASSERTION(aStateMask == 0 || !aForStyling,
-               "aForStyling must be false if we're just testing for "
+  NS_ASSERTION(aStateMask == 0 || !aMatchContext->mForStyling,
+               "mForStyling must be false if we're just testing for "
                "state-dependence");
-  const PRBool setNodeFlags = aForStyling;
 
   // test for pseudo class match
   for (nsPseudoClassList* pseudoClass = aSelector->mPseudoClassList;
        pseudoClass; pseudoClass = pseudoClass->mNext) {
     const PseudoClassInfo& info = sPseudoClassInfo[pseudoClass->mType];
     if (info.mFunc) {
-      if (!(*info.mFunc)(data, setNodeFlags, aStateMask, pseudoClass)) {
+      if (!(*info.mFunc)(data, aMatchContext, aStateMask, pseudoClass)) {
         return PR_FALSE;
       }
     } else {
       PRInt32 statesToCheck = info.mBits;
       NS_ABORT_IF_FALSE(statesToCheck != 0, "How did that happen?");
       if ((statesToCheck & (NS_EVENT_STATE_HOVER | NS_EVENT_STATE_ACTIVE)) &&
           data.mCompatMode == eCompatibility_NavQuirks &&
           // global selector (but don't check .class):
@@ -2034,17 +2058,17 @@ static PRBool SelectorMatches(RuleProces
   }
 
   // apply SelectorMatches to the negated selectors in the chain
   if (!isNegated) {
     for (nsCSSSelector *negation = aSelector->mNegations;
          result && negation; negation = negation->mNegations) {
       PRBool dependence = PR_FALSE;
       result = !SelectorMatches(data, negation, aStateMask,
-                                aForStyling, &dependence);
+                                aMatchContext, &dependence);
       // If the selector does match due to the dependence on aStateMask,
       // then we want to keep result true so that the final result of
       // SelectorMatches is true.  Doing so tells StateEnumFunc that
       // there is a dependence on the state.
       result = result || dependence;
     }
   }
   return result;
@@ -2055,17 +2079,17 @@ static PRBool SelectorMatches(RuleProces
 // Right now, there are four operators:
 //   PRUnichar(0), the descendant combinator, is greedy
 //   '~', the indirect adjacent sibling combinator, is greedy
 //   '+' and '>', the direct adjacent sibling and child combinators, are not
 #define NS_IS_GREEDY_OPERATOR(ch) (ch == PRUnichar(0) || ch == PRUnichar('~'))
 
 static PRBool SelectorMatchesTree(RuleProcessorData& aPrevData,
                                   nsCSSSelector* aSelector,
-                                  PRBool aForStyling) 
+                                  MatchContext* aMatchContext)
 {
   nsCSSSelector* selector = aSelector;
   RuleProcessorData* prevdata = &aPrevData;
   while (selector) { // check compound selectors
     // If we don't already have a RuleProcessorData for the next
     // appropriate content (whether parent or previous sibling), create
     // one.
 
@@ -2074,17 +2098,17 @@ static PRBool SelectorMatchesTree(RulePr
     RuleProcessorData* data;
     if (PRUnichar('+') == selector->mOperator ||
         PRUnichar('~') == selector->mOperator) {
       data = prevdata->mPreviousSiblingData;
       if (!data) {
         nsIContent* content = prevdata->mContent;
         nsIContent* parent = prevdata->mParentContent;
         if (parent) {
-          if (aForStyling)
+          if (aMatchContext->mForStyling)
             parent->SetFlags(NODE_HAS_SLOW_SELECTOR_NOAPPEND);
 
           PRInt32 index = parent->IndexOf(content);
           while (0 <= --index) {
             content = parent->GetChildAt(index);
             if (content->IsNodeOfType(nsINode::eELEMENT)) {
               data = RuleProcessorData::Create(prevdata->mPresContext, content,
                                                prevdata->mRuleWalker,
@@ -2110,17 +2134,17 @@ static PRBool SelectorMatchesTree(RulePr
                                            prevdata->mCompatMode);
           prevdata->mParentData = data;
         }
       }
     }
     if (! data) {
       return PR_FALSE;
     }
-    if (SelectorMatches(*data, selector, 0, aForStyling)) {
+    if (SelectorMatches(*data, selector, 0, aMatchContext)) {
       // to avoid greedy matching, we need to recur if this is a
       // descendant or general sibling combinator and the next
       // combinator is different, but we can make an exception for
       // sibling, then parent, since a sibling's parent is always the
       // same.
       if (NS_IS_GREEDY_OPERATOR(selector->mOperator) &&
           selector->mNext &&
           selector->mNext->mOperator != selector->mOperator &&
@@ -2130,17 +2154,17 @@ static PRBool SelectorMatchesTree(RulePr
 
         // pretend the selector didn't match, and step through content
         // while testing the same selector
 
         // This approach is slightly strange in that when it recurs
         // it tests from the top of the content tree, down.  This
         // doesn't matter much for performance since most selectors
         // don't match.  (If most did, it might be faster...)
-        if (SelectorMatchesTree(*data, selector, aForStyling)) {
+        if (SelectorMatchesTree(*data, selector, aMatchContext)) {
           return PR_TRUE;
         }
       }
       selector = selector->mNext;
     }
     else {
       // for adjacent sibling and child combinators, if we didn't find
       // a match, we're done
@@ -2153,19 +2177,20 @@ static PRBool SelectorMatchesTree(RulePr
   return PR_TRUE; // all the selectors matched.
 }
 
 static void ContentEnumFunc(nsICSSStyleRule* aRule, nsCSSSelector* aSelector,
                             void* aData)
 {
   RuleProcessorData* data = (RuleProcessorData*)aData;
 
-  if (SelectorMatches(*data, aSelector, 0, PR_TRUE)) {
+  MatchContext context(PR_TRUE);
+  if (SelectorMatches(*data, aSelector, 0, &context)) {
     nsCSSSelector *next = aSelector->mNext;
-    if (!next || SelectorMatchesTree(*data, next, PR_TRUE)) {
+    if (!next || SelectorMatchesTree(*data, next, &context)) {
       // for performance, require that every implementation of
       // nsICSSStyleRule return the same pointer for nsIStyleRule (why
       // would anything multiply inherit nsIStyleRule anyway?)
 #ifdef DEBUG
       nsCOMPtr<nsIStyleRule> iRule = do_QueryInterface(aRule);
       NS_ASSERTION(static_cast<nsIStyleRule*>(aRule) == iRule.get(),
                    "Please fix QI so this performance optimization is valid");
 #endif
@@ -2303,19 +2328,20 @@ nsCSSRuleProcessor::HasStateDependentSty
       nsCSSSelector* selector = *iter;
 
       nsReStyleHint possibleChange = IsSiblingOperator(selector->mOperator) ?
         eReStyle_LaterSiblings : eReStyle_Self;
 
       // If hint already includes all the bits of possibleChange,
       // don't bother calling SelectorMatches, since even if it returns false
       // hint won't change.
+      MatchContext context(PR_FALSE);
       if ((possibleChange & ~hint) &&
-          SelectorMatches(*aData, selector, aData->mStateMask, PR_FALSE) &&
-          SelectorMatchesTree(*aData, selector->mNext, PR_FALSE)) {
+          SelectorMatches(*aData, selector, aData->mStateMask, &context) &&
+          SelectorMatchesTree(*aData, selector->mNext, &context)) {
         hint = nsReStyleHint(hint | possibleChange);
       }
     }
   }
   return hint;
 }
 
 struct AttributeEnumData {
@@ -2333,19 +2359,20 @@ AttributeEnumFunc(nsCSSSelector* aSelect
   AttributeRuleProcessorData *data = aData->data;
 
   nsReStyleHint possibleChange = IsSiblingOperator(aSelector->mOperator) ?
     eReStyle_LaterSiblings : eReStyle_Self;
 
   // If enumData->change already includes all the bits of possibleChange, don't
   // bother calling SelectorMatches, since even if it returns false
   // enumData->change won't change.
+  MatchContext context(PR_FALSE);
   if ((possibleChange & ~(aData->change)) &&
-      SelectorMatches(*data, aSelector, 0, PR_FALSE) &&
-      SelectorMatchesTree(*data, aSelector->mNext, PR_FALSE)) {
+      SelectorMatches(*data, aSelector, 0, &context) &&
+      SelectorMatchesTree(*data, aSelector->mNext, &context)) {
     aData->change = nsReStyleHint(aData->change | possibleChange);
   }
 }
 
 nsReStyleHint
 nsCSSRuleProcessor::HasAttributeDependentStyle(AttributeRuleProcessorData* aData)
 {
   NS_PRECONDITION(aData->mContent->IsNodeOfType(nsINode::eELEMENT),
@@ -2860,19 +2887,20 @@ nsCSSRuleProcessor::RefreshRuleCascade(n
 /* static */ PRBool
 nsCSSRuleProcessor::SelectorListMatches(RuleProcessorData& aData,
                                         nsCSSSelectorList* aSelectorList)
 {
   while (aSelectorList) {
     nsCSSSelector* sel = aSelectorList->mSelectors;
     NS_ASSERTION(sel, "Should have *some* selectors");
     NS_ASSERTION(!sel->IsPseudoElement(), "Shouldn't have been called");
-    if (SelectorMatches(aData, sel, 0, PR_FALSE)) {
+    MatchContext context(PR_FALSE);
+    if (SelectorMatches(aData, sel, 0, &context)) {
       nsCSSSelector* next = sel->mNext;
-      if (!next || SelectorMatchesTree(aData, next, PR_FALSE)) {
+      if (!next || SelectorMatchesTree(aData, next, &context)) {
         return PR_TRUE;
       }
     }
 
     aSelectorList = aSelectorList->mNext;
   }
 
   return PR_FALSE;
