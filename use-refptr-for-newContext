From: L. David Baron <dbaron@dbaron.org>

Use nsRefPtr for new context in ReResolveStyleContext.  (Bug 435441)

diff --git a/layout/base/nsFrameManager.cpp b/layout/base/nsFrameManager.cpp
--- a/layout/base/nsFrameManager.cpp
+++ b/layout/base/nsFrameManager.cpp
@@ -1154,120 +1154,114 @@ nsFrameManager::ReResolveStyleContext(ns
       // aFrame's context.
       parentContext = providerFrame->GetStyleContext();
       // Set |resolvedChild| so we don't bother resolving the
       // provider again.
       resolvedChild = providerFrame;
     }
     
     // do primary context
-    // XXXbz newContext should just be an nsRefPtr
-    nsStyleContext* newContext = nsnull;
+    nsRefPtr<nsStyleContext> newContext;
     if (pseudoTag == nsCSSAnonBoxes::mozNonElement) {
       NS_ASSERTION(localContent,
                    "non pseudo-element frame without content node");
-      newContext = styleSet->ResolveStyleForNonElement(parentContext).get();
+      newContext = styleSet->ResolveStyleForNonElement(parentContext);
     }
     else if (pseudoTag) {
       // XXXldb This choice of pseudoContent seems incorrect for anon
       // boxes and perhaps other cases.
       // See also the comment above the assertion at the start of this
       // function.
       nsIContent* pseudoContent =
           aParentContent ? aParentContent : localContent;
       if (pseudoTag == nsCSSPseudoElements::before ||
           pseudoTag == nsCSSPseudoElements::after) {
         // XXX what other pseudos do we need to treat like this?
         newContext = styleSet->ProbePseudoStyleFor(pseudoContent,
                                                    pseudoTag,
-                                                   parentContext).get();
+                                                   parentContext);
         if (!newContext) {
           // This pseudo should no longer exist; gotta reframe
           NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
           aChangeList->AppendChange(aFrame, pseudoContent,
                                     nsChangeHint_ReconstructFrame);
           // We're reframing anyway; just keep the same context
           newContext = oldContext;
-          newContext->AddRef();
         }
       } else {
         if (pseudoTag == nsCSSPseudoElements::firstLetter) {
           NS_ASSERTION(aFrame->GetType() == nsGkAtoms::letterFrame, 
                        "firstLetter pseudoTag without a nsFirstLetterFrame");
           nsBlockFrame* block = nsBlockFrame::GetNearestAncestorBlock(aFrame);
           pseudoContent = block->GetContent();
         } else if (pseudoTag == nsCSSAnonBoxes::pageBreak) {
           pseudoContent = nsnull;
         }
         newContext = styleSet->ResolvePseudoStyleFor(pseudoContent,
                                                      pseudoTag,
-                                                     parentContext).get();
+                                                     parentContext);
       }
     }
     else {
       NS_ASSERTION(localContent,
                    "non pseudo-element frame without content node");
-      newContext = styleSet->ResolveStyleFor(content, parentContext).get();
+      newContext = styleSet->ResolveStyleFor(content, parentContext);
     }
     NS_ASSERTION(newContext, "failed to get new style context");
     if (newContext) {
       if (!parentContext) {
         if (oldContext->GetRuleNode() == newContext->GetRuleNode()) {
           // We're the root of the style context tree and the new style
           // context returned has the same rule node.  This means that
           // we can use FindChildWithRules to keep a lot of the old
           // style contexts around.  However, we need to start from the
           // same root.
-          newContext->Release();
           newContext = oldContext;
-          newContext->AddRef();
         }
       }
 
       if (newContext != oldContext) {
         aMinChange = CaptureChange(oldContext, newContext, aFrame,
                                    content, aChangeList, aMinChange,
                                    assumeDifferenceHint);
         if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
           // if frame gets regenerated, let it keep old context
           aFrame->SetStyleContext(newContext);
         }
       }
       oldContext->Release();
     }
     else {
       NS_ERROR("resolve style context failed");
-      newContext = oldContext;  // new context failed, recover... (take ref)
-      oldContext = nsnull;
+      newContext = oldContext;  // new context failed, recover...
     }
 
     // do additional contexts 
     PRInt32 contextIndex = -1;
     while (1 == 1) {
       nsStyleContext* oldExtraContext = nsnull;
       oldExtraContext = aFrame->GetAdditionalStyleContext(++contextIndex);
       if (oldExtraContext) {
-        nsStyleContext* newExtraContext = nsnull;
+        nsRefPtr<nsStyleContext> newExtraContext;
         nsIAtom* const extraPseudoTag = oldExtraContext->GetPseudoType();
         NS_ASSERTION(extraPseudoTag &&
                      extraPseudoTag != nsCSSAnonBoxes::mozNonElement,
                      "extra style context is not pseudo element");
         newExtraContext = styleSet->ResolvePseudoStyleFor(content,
                                                           extraPseudoTag,
-                                                          newContext).get();
+                                                          newContext);
         if (newExtraContext) {
           if (oldExtraContext != newExtraContext) {
             aMinChange = CaptureChange(oldExtraContext, newExtraContext,
                                        aFrame, content, aChangeList,
                                        aMinChange, assumeDifferenceHint);
             if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
               aFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
             }
           }
-          newExtraContext->Release();
         }
       }
       else {
         break;
       }
     }
 
     // now look for undisplayed child content and pseudos
