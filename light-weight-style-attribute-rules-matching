From: L. David Baron <dbaron@dbaron.org>

Bug 997991 patch 1 - Expose variants of RulesMatching on nsHTMLCSSStyleSheet that are less work to call.

diff --git a/layout/style/nsHTMLCSSStyleSheet.cpp b/layout/style/nsHTMLCSSStyleSheet.cpp
--- a/layout/style/nsHTMLCSSStyleSheet.cpp
+++ b/layout/style/nsHTMLCSSStyleSheet.cpp
@@ -49,56 +49,73 @@ nsHTMLCSSStyleSheet::~nsHTMLCSSStyleShee
   mCachedStyleAttrs.Enumerate(ClearAttrCache, nullptr);
 }
 
 NS_IMPL_ISUPPORTS(nsHTMLCSSStyleSheet, nsIStyleRuleProcessor)
 
 /* virtual */ void
 nsHTMLCSSStyleSheet::RulesMatching(ElementRuleProcessorData* aData)
 {
-  Element* element = aData->mElement;
+  ElementRulesMatching(aData->mPresContext, aData->mElement,
+                       aData->mRuleWalker);
+}
 
+void
+nsHTMLCSSStyleSheet::ElementRulesMatching(nsPresContext* aPresContext,
+                                          Element* aElement,
+                                          nsRuleWalker* aRuleWalker)
+{
   // just get the one and only style rule from the content's STYLE attribute
-  css::StyleRule* rule = element->GetInlineStyleRule();
+  css::StyleRule* rule = aElement->GetInlineStyleRule();
   if (rule) {
     rule->RuleMatched();
-    aData->mRuleWalker->Forward(rule);
+    aRuleWalker->Forward(rule);
   }
 
-  rule = element->GetSMILOverrideStyleRule();
+  rule = aElement->GetSMILOverrideStyleRule();
   if (rule) {
-    if (aData->mPresContext->IsProcessingRestyles() &&
-        !aData->mPresContext->IsProcessingAnimationStyleChange()) {
+    if (aPresContext->IsProcessingRestyles() &&
+        !aPresContext->IsProcessingAnimationStyleChange()) {
       // Non-animation restyle -- don't process SMIL override style, because we
       // don't want SMIL animation to trigger new CSS transitions. Instead,
       // request an Animation restyle, so we still get noticed.
-      aData->mPresContext->PresShell()->RestyleForAnimation(element,
-                                                            eRestyle_Self);
+      aPresContext->PresShell()->RestyleForAnimation(aElement,
+                                                     eRestyle_Self);
     } else {
       // Animation restyle (or non-restyle traversal of rules)
       // Now we can walk SMIL overrride style, without triggering transitions.
       rule->RuleMatched();
-      aData->mRuleWalker->Forward(rule);
+      aRuleWalker->Forward(rule);
     }
   }
 }
 
 /* virtual */ void
 nsHTMLCSSStyleSheet::RulesMatching(PseudoElementRuleProcessorData* aData)
 {
-  if (nsCSSPseudoElements::PseudoElementSupportsStyleAttribute(aData->mPseudoType)) {
-    MOZ_ASSERT(aData->mPseudoElement,
+  PseudoElementRulesMatching(aData->mPseudoElement, aData->mPseudoType,
+                             aData->mRuleWalker);
+}
+
+void
+nsHTMLCSSStyleSheet::PseudoElementRulesMatching(Element* aPseudoElement,
+                                                nsCSSPseudoElements::Type
+                                                  aPseudoType,
+                                                nsRuleWalker* aRuleWalker)
+{
+  if (nsCSSPseudoElements::PseudoElementSupportsStyleAttribute(aPseudoType)) {
+    MOZ_ASSERT(aPseudoElement,
         "If pseudo element is supposed to support style attribute, it must "
         "have a pseudo element set");
 
     // just get the one and only style rule from the content's STYLE attribute
-    css::StyleRule* rule = aData->mPseudoElement->GetInlineStyleRule();
+    css::StyleRule* rule = aPseudoElement->GetInlineStyleRule();
     if (rule) {
       rule->RuleMatched();
-      aData->mRuleWalker->Forward(rule);
+      aRuleWalker->Forward(rule);
     }
   }
 }
 
 /* virtual */ void
 nsHTMLCSSStyleSheet::RulesMatching(AnonBoxRuleProcessorData* aData)
 {
 }
diff --git a/layout/style/nsHTMLCSSStyleSheet.h b/layout/style/nsHTMLCSSStyleSheet.h
--- a/layout/style/nsHTMLCSSStyleSheet.h
+++ b/layout/style/nsHTMLCSSStyleSheet.h
@@ -38,16 +38,27 @@ public:
   virtual nsRestyleHint
     HasAttributeDependentStyle(AttributeRuleProcessorData* aData) MOZ_OVERRIDE;
   virtual bool MediumFeaturesChanged(nsPresContext* aPresContext) MOZ_OVERRIDE;
   virtual size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf)
     const MOZ_MUST_OVERRIDE MOZ_OVERRIDE;
   virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf)
     const MOZ_MUST_OVERRIDE MOZ_OVERRIDE;
 
+  // Variants of RulesMatching methods above that are specific to this
+  // rule processor.
+  void ElementRulesMatching(nsPresContext* aPresContext,
+                            mozilla::dom::Element* aElement,
+                            nsRuleWalker* aRuleWalker);
+  void PseudoElementRulesMatching(// NOTE: The pseudo-element content, not
+                                  // the real element!
+                                  mozilla::dom::Element* aPseudoElement,
+                                  nsCSSPseudoElements::Type aPseudoType,
+                                  nsRuleWalker* aRuleWalker);
+
   void CacheStyleAttr(const nsAString& aSerialized, MiscContainer* aValue);
   void EvictStyleAttr(const nsAString& aSerialized, MiscContainer* aValue);
   MiscContainer* LookupStyleAttr(const nsAString& aSerialized);
 
 private: 
   ~nsHTMLCSSStyleSheet();
 
   nsHTMLCSSStyleSheet(const nsHTMLCSSStyleSheet& aCopy) MOZ_DELETE;
