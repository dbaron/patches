From: L. David Baron <dbaron@dbaron.org>

Fix css3-animations handling of properties that are not present in all keyframes to match WebKit and generally be more sensible.  (Bug 649400)

This inverts the relationship between segments and properties in the
animation data structures:  now each property has a set of segments,
since the segments differ between properties.

Furthermore, we now handle inability to interpolate between values by
dropping the entire property rather than dropping a single segment.

diff --git a/layout/style/Declaration.h b/layout/style/Declaration.h
--- a/layout/style/Declaration.h
+++ b/layout/style/Declaration.h
@@ -246,20 +246,22 @@ private:
   static void AppendImportanceToString(PRBool aIsImportant, nsAString& aString);
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
   PRBool AppendValueToString(nsCSSProperty aProperty, nsAString& aResult) const;
   // Helper for ToString with strange semantics regarding aValue.
   void AppendPropertyAndValueToString(nsCSSProperty aProperty,
                                       nsAutoString& aValue,
                                       nsAString& aResult) const;
 
+public:
   nsCSSProperty OrderValueAt(PRUint32 aValue) const {
     return nsCSSProperty(mOrder.ElementAt(aValue));
   }
 
+private:
   nsAutoTArray<PRUint8, 8> mOrder;
 
   // never null, except while expanded, or before the first call to
   // InitializeEmpty or CompressFrom.
   nsAutoPtr<nsCSSCompressedDataBlock> mData;
 
   // may be null
   nsAutoPtr<nsCSSCompressedDataBlock> mImportantData;
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -42,27 +42,27 @@
 #include "nsStyleSet.h"
 #include "nsCSSRules.h"
 #include "nsStyleAnimation.h"
 #include "nsSMILKeySpline.h"
 #include "nsEventDispatcher.h"
 
 using namespace mozilla;
 
-struct AnimationSegmentProperty
+struct AnimationPropertySegment
+{
+  float mFromKey, mToKey;
+  nsStyleAnimation::Value mFromValue, mToValue;
+  css::ComputedTimingFunction mTimingFunction;
+};
+
+struct AnimationProperty
 {
   nsCSSProperty mProperty;
-  nsStyleAnimation::Value mFromValue, mToValue;
-};
-
-struct AnimationSegment
-{
-  float mFromKey, mToKey;
-  css::ComputedTimingFunction mTimingFunction;
-  InfallibleTArray<AnimationSegmentProperty> mProperties;
+  InfallibleTArray<AnimationPropertySegment> mSegments;
 };
 
 /**
  * Data about one animation (i.e., one of the values of
  * 'animation-name') running on an element.
  */
 struct ElementAnimation
 {
@@ -97,17 +97,17 @@ struct ElementAnimation
   enum {
     LAST_NOTIFICATION_NONE = PRUint32(-1),
     LAST_NOTIFICATION_END = PRUint32(-2)
   };
   // One of the above constants, or an integer for the iteration
   // whose start we last notified on.
   PRUint32 mLastNotification;
 
-  InfallibleTArray<AnimationSegment> mSegments;
+  InfallibleTArray<AnimationProperty> mProperties;
 };
 
 typedef nsAnimationManager::EventArray EventArray;
 typedef nsAnimationManager::AnimationEventInfo AnimationEventInfo;
 
 /**
  * Data about all of the animations running on an element.
  */
@@ -176,25 +176,24 @@ ElementAnimations::EnsureStyleRuleFor(Ti
 
   // mStyleRule may be null and valid, if we have no style to apply.
   if (mStyleRuleRefreshTime.IsNull() ||
       mStyleRuleRefreshTime != aRefreshTime) {
     mStyleRuleRefreshTime = aRefreshTime;
     mStyleRule = nsnull;
 
     // FIXME(spec): assume that properties in higher animations override
-    // those in lower ones (and that our |HasProperty| check in
-    // |BuildSegment| matches the definition of when they should do so.
+    // those in lower ones.
     // Therefore, we iterate from last animation to first.
     nsCSSPropertySet properties;
 
     for (PRUint32 animIdx = mAnimations.Length(); animIdx-- != 0; ) {
       ElementAnimation &anim = mAnimations[animIdx];
 
-      if (anim.mSegments.Length() == 0 ||
+      if (anim.mProperties.Length() == 0 ||
           anim.mIterationDuration.ToMilliseconds() <= 0.0) {
         // No animation data.
         continue;
       }
 
       TimeDuration currentTimeDuration;
       if (anim.IsPaused()) {
         // FIXME: avoid recalculating every time
@@ -273,69 +272,70 @@ ElementAnimations::EnsureStyleRuleFor(Ti
                               currentTimeDuration);
         aEventsToDispatch.AppendElement(ei);
       }
 
       NS_ABORT_IF_FALSE(0.0 <= positionInIteration &&
                           positionInIteration <= 1.0,
                         "position should be in [0-1]");
 
-      NS_ABORT_IF_FALSE(anim.mSegments[0].mFromKey == 0.0,
-                        "incorrect first from key");
-      NS_ABORT_IF_FALSE(anim.mSegments[anim.mSegments.Length() - 1].mToKey
-                          == 1.0,
-                        "incorrect last to key");
+      for (PRUint32 propIdx = 0, propEnd = anim.mProperties.Length();
+           propIdx != propEnd; ++propIdx)
+      {
+        const AnimationProperty &prop = anim.mProperties[propIdx];
 
-      // FIXME: Maybe cache the current segment?
-      const AnimationSegment *segment = anim.mSegments.Elements();
-      while (segment->mToKey < positionInIteration) {
-        NS_ABORT_IF_FALSE(segment->mFromKey < segment->mToKey,
-                          "incorrect keys");
-        ++segment;
-        NS_ABORT_IF_FALSE(segment->mFromKey == (segment-1)->mToKey,
-                          "incorrect keys");
-      }
-      NS_ABORT_IF_FALSE(segment->mFromKey < segment->mToKey,
-                        "incorrect keys");
-      NS_ABORT_IF_FALSE(segment - anim.mSegments.Elements() <
-                          anim.mSegments.Length(),
-                        "ran off end");
+        NS_ABORT_IF_FALSE(prop.mSegments[0].mFromKey == 0.0,
+                          "incorrect first from key");
+        NS_ABORT_IF_FALSE(prop.mSegments[prop.mSegments.Length() - 1].mToKey
+                            == 1.0,
+                          "incorrect last to key");
 
-      if (segment->mProperties.IsEmpty()) {
-        // No animation data.
-        continue;
-      }
-
-      if (!mStyleRule) {
-        // Allocate the style rule now that we know we have animation data.
-        mStyleRule = new css::AnimValuesStyleRule();
-      }
-
-      double positionInSegment = (positionInIteration - segment->mFromKey) /
-                                 (segment->mToKey - segment->mFromKey);
-      double valuePosition =
-        segment->mTimingFunction.GetValue(positionInSegment);
-
-      for (PRUint32 propIdx = 0, propEnd = segment->mProperties.Length();
-           propIdx != propEnd; ++propIdx) {
-        const AnimationSegmentProperty &prop = segment->mProperties[propIdx];
         if (properties.HasProperty(prop.mProperty)) {
           // A later animation already set this property.
           continue;
         }
         properties.AddProperty(prop.mProperty);
 
+        NS_ABORT_IF_FALSE(prop.mSegments.Length() > 0,
+                          "property should not be in animations if it "
+                          "has no segments");
+
+        // FIXME: Maybe cache the current segment?
+        const AnimationPropertySegment *segment = prop.mSegments.Elements();
+        while (segment->mToKey < positionInIteration) {
+          NS_ABORT_IF_FALSE(segment->mFromKey < segment->mToKey,
+                            "incorrect keys");
+          ++segment;
+          NS_ABORT_IF_FALSE(segment->mFromKey == (segment-1)->mToKey,
+                            "incorrect keys");
+        }
+        NS_ABORT_IF_FALSE(segment->mFromKey < segment->mToKey,
+                          "incorrect keys");
+        NS_ABORT_IF_FALSE(segment - prop.mSegments.Elements() <
+                            prop.mSegments.Length(),
+                          "ran off end");
+
+        if (!mStyleRule) {
+          // Allocate the style rule now that we know we have animation data.
+          mStyleRule = new css::AnimValuesStyleRule();
+        }
+
+        double positionInSegment = (positionInIteration - segment->mFromKey) /
+                                   (segment->mToKey - segment->mFromKey);
+        double valuePosition =
+          segment->mTimingFunction.GetValue(positionInSegment);
+
         nsStyleAnimation::Value *val =
           mStyleRule->AddEmptyValue(prop.mProperty);
 
 #ifdef DEBUG
         PRBool result =
 #endif
           nsStyleAnimation::Interpolate(prop.mProperty,
-                                        prop.mFromValue, prop.mToValue,
+                                        segment->mFromValue, segment->mToValue,
                                         valuePosition, *val);
         NS_ABORT_IF_FALSE(result, "interpolate must succeed now");
       }
     }
   }
 }
 
 ElementAnimations*
@@ -605,17 +605,17 @@ ResolvedStyleCache::Get(nsPresContext *a
 {
   // FIXME (spec):  The css3-animations spec isn't very clear about how
   // properties are resolved when they have values that depend on other
   // properties (e.g., values in 'em').  I presume that they're resolved
   // relative to the other styles of the element.  The question is
   // whether they are resolved relative to other animations:  I assume
   // that they're not, since that would prevent us from caching a lot of
   // data that we'd really like to cache (in particular, the
-  // nsStyleAnimation::Value values in AnimationSegmentProperty).
+  // nsStyleAnimation::Value values in AnimationPropertySegment).
   nsStyleContext *result = mCache.GetWeak(aKeyframe);
   if (!result) {
     nsCOMArray<nsIStyleRule> rules;
     rules.AppendObject(aKeyframe);
     nsRefPtr<nsStyleContext> resultStrong = aPresContext->StyleSet()->
       ResolveStyleByAddingRules(aParentStyleContext, rules);
     mCache.Put(aKeyframe, resultStrong);
     result = resultStrong;
@@ -690,103 +690,133 @@ nsAnimationManager::BuildAnimations(nsSt
     keyframes.EnumerateRead(AppendKeyframeData, &sortedKeyframes);
     sortedKeyframes.Sort(KeyframeDataComparator());
 
     if (sortedKeyframes.Length() == 0) {
       // no segments
       continue;
     }
 
-    KeyframeData fromKeyframe = sortedKeyframes[0];
-    nsRefPtr<nsStyleContext> fromContext =
-      resolvedStyles.Get(mPresContext, aStyleContext,
-                         fromKeyframe.mRule);
+    // Record the properties that are present in any keyframe rules we
+    // are using.
+    nsCSSPropertySet properties;
 
-    // If there's no rule for 0%, there's implicitly an empty rule.
-    if (fromKeyframe.mKey != 0.0f) {
-      BuildSegment(aDest.mSegments, aSrc,
-                   0.0f, aStyleContext, nsnull,
-                   fromKeyframe.mKey, fromContext,
-                     fromKeyframe.mRule->Declaration());
+    for (PRUint32 kfIdx = 0, kfEnd = sortedKeyframes.Length();
+         kfIdx != kfEnd; ++kfIdx) {
+      css::Declaration *decl = sortedKeyframes[kfIdx].mRule->Declaration();
+      for (PRUint32 propIdx = 0, propEnd = decl->Count();
+           propIdx != propEnd; ++propIdx) {
+        properties.AddProperty(decl->OrderValueAt(propIdx));
+      }
     }
 
-    for (PRUint32 kfIdx = 1, kfEnd = sortedKeyframes.Length();
-         kfIdx != kfEnd; ++kfIdx) {
-      KeyframeData toKeyframe = sortedKeyframes[kfIdx];
-      nsRefPtr<nsStyleContext> toContext =
-        resolvedStyles.Get(mPresContext, aStyleContext, toKeyframe.mRule);
+    for (nsCSSProperty prop = nsCSSProperty(0);
+         prop < eCSSProperty_COUNT_no_shorthands;
+         prop = nsCSSProperty(prop + 1)) {
+      if (!properties.HasProperty(prop) ||
+          nsCSSProps::kAnimTypeTable[prop] == eStyleAnimType_None) {
+        continue;
+      }
 
-      BuildSegment(aDest.mSegments, aSrc,
-                   fromKeyframe.mKey, fromContext,
-                   fromKeyframe.mRule->Declaration(),
-                   toKeyframe.mKey, toContext,
-                   toKeyframe.mRule->Declaration());
+      AnimationProperty &propData = *aDest.mProperties.AppendElement();
+      propData.mProperty = prop;
 
-      fromContext = toContext;
-      fromKeyframe = toKeyframe;
-    }
+      KeyframeData *fromKeyframe = nsnull;
+      nsRefPtr<nsStyleContext> fromContext;
+      bool interpolated = true;
+      for (PRUint32 kfIdx = 0, kfEnd = sortedKeyframes.Length();
+           kfIdx != kfEnd; ++kfIdx) {
+        KeyframeData &toKeyframe = sortedKeyframes[kfIdx];
+        if (!toKeyframe.mRule->Declaration()->HasProperty(prop)) {
+          continue;
+        }
 
-    // If there's no rule for 100%, there's implicitly an empty rule.
-    if (fromKeyframe.mKey != 1.0f) {
-      BuildSegment(aDest.mSegments, aSrc,
-                   fromKeyframe.mKey, fromContext,
-                   fromKeyframe.mRule->Declaration(),
-                   1.0f, aStyleContext, nsnull);
+        nsRefPtr<nsStyleContext> toContext =
+          resolvedStyles.Get(mPresContext, aStyleContext, toKeyframe.mRule);
+
+        if (fromKeyframe) {
+          interpolated = interpolated &&
+            BuildSegment(propData.mSegments, prop, aSrc,
+                         fromKeyframe->mKey, fromContext,
+                         fromKeyframe->mRule->Declaration(),
+                         toKeyframe.mKey, toContext);
+        } else {
+          if (toKeyframe.mKey != 0.0f) {
+            // There's no data for this property at 0%, so use the
+            // cascaded value above us.
+            interpolated = interpolated &&
+              BuildSegment(propData.mSegments, prop, aSrc,
+                           0.0f, aStyleContext, nsnull,
+                           toKeyframe.mKey, toContext);
+          }
+        }
+
+        fromContext = toContext;
+        fromKeyframe = &toKeyframe;
+      }
+
+      if (fromKeyframe->mKey != 1.0f) {
+        // There's no data for this property at 100%, so use the
+        // cascaded value above us.
+        interpolated = interpolated &&
+          BuildSegment(propData.mSegments, prop, aSrc,
+                       fromKeyframe->mKey, fromContext,
+                       fromKeyframe->mRule->Declaration(),
+                       1.0f, aStyleContext);
+      }
+
+      // If we failed to build any segments due to inability to
+      // interpolate, remove the property from the animation.  (It's not
+      // clear if this is the right thing to do -- we could run some of
+      // the segments, but it's really not clear whether we should skip
+      // values (which?) or skip segments, so best to skip the whole
+      // thing for now.)
+      if (!interpolated) {
+        aDest.mProperties.RemoveElementAt(aDest.mProperties.Length() - 1);
+      }
     }
   }
 }
 
-void
-nsAnimationManager::BuildSegment(InfallibleTArray<AnimationSegment>& aSegments,
+bool
+nsAnimationManager::BuildSegment(InfallibleTArray<AnimationPropertySegment>&
+                                   aSegments,
+                                 nsCSSProperty aProperty,
                                  const nsAnimation& aAnimation,
                                  float aFromKey, nsStyleContext* aFromContext,
                                  mozilla::css::Declaration* aFromDeclaration,
-                                 float aToKey, nsStyleContext* aToContext,
-                                 mozilla::css::Declaration* aToDeclaration)
+                                 float aToKey, nsStyleContext* aToContext)
 {
-  AnimationSegment &segment = *aSegments.AppendElement();
+  nsStyleAnimation::Value fromValue, toValue, dummyValue;
+  if (!ExtractComputedValueForTransition(aProperty, aFromContext, fromValue) ||
+      !ExtractComputedValueForTransition(aProperty, aToContext, toValue) ||
+      // Check that we can interpolate between these values
+      // (If this is ever a performance problem, we could add a
+      // CanInterpolate method, but it seems fine for now.)
+      !nsStyleAnimation::Interpolate(aProperty, fromValue, toValue,
+                                    0.5, dummyValue)) {
+    return false;
+  }
 
+  AnimationPropertySegment &segment = *aSegments.AppendElement();
+
+  segment.mFromValue = fromValue;
+  segment.mToValue = toValue;
   segment.mFromKey = aFromKey;
   segment.mToKey = aToKey;
   const nsTimingFunction *tf;
   if (aFromDeclaration &&
       aFromDeclaration->HasProperty(eCSSProperty_animation_timing_function)) {
     tf = &aFromContext->GetStyleDisplay()->mAnimations[0].GetTimingFunction();
   } else {
     tf = &aAnimation.GetTimingFunction();
   }
   segment.mTimingFunction.Init(*tf);
 
-  for (nsCSSProperty prop = nsCSSProperty(0);
-       prop < eCSSProperty_COUNT_no_shorthands;
-       prop = nsCSSProperty(prop + 1)) {
-    if (nsCSSProps::kAnimTypeTable[prop] == eStyleAnimType_None) {
-      continue;
-    }
-
-    if (!(aFromDeclaration && aFromDeclaration->HasProperty(prop)) &&
-        !(aToDeclaration && aToDeclaration->HasProperty(prop))) {
-      // Don't store an animation if neither declaration has the property.
-      continue;
-    }
-
-    nsStyleAnimation::Value fromValue, toValue, dummyValue;
-    if (ExtractComputedValueForTransition(prop, aFromContext, fromValue) &&
-        ExtractComputedValueForTransition(prop, aToContext, toValue) &&
-        // Check that we can interpolate between these values
-        // (If this is ever a performance problem, we could add a
-        // CanInterpolate method, but it seems fine for now.)
-        nsStyleAnimation::Interpolate(prop, fromValue, toValue,
-                                      0.5, dummyValue)) {
-      AnimationSegmentProperty &p = *segment.mProperties.AppendElement();
-      p.mProperty = prop;
-      p.mFromValue = fromValue;
-      p.mToValue = toValue;
-    }
-  }
+  return true;
 }
 
 nsIStyleRule*
 nsAnimationManager::GetAnimationRule(mozilla::dom::Element* aElement,
                                      nsCSSPseudoElements::Type aPseudoType)
 {
   NS_ABORT_IF_FALSE(
     aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ||
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -42,17 +42,17 @@
 #include "nsCSSPseudoElements.h"
 #include "nsStyleContext.h"
 #include "nsTHashtable.h"
 #include "nsGUIEvent.h"
 #include "mozilla/TimeStamp.h"
 #include "nsThreadUtils.h"
 
 class nsCSSKeyframesRule;
-struct AnimationSegment;
+struct AnimationPropertySegment;
 struct ElementAnimation;
 struct ElementAnimations;
 
 namespace mozilla {
 namespace css {
 class Declaration;
 }
 }
@@ -130,22 +130,21 @@ public:
   void DispatchEvents();
 
 private:
   ElementAnimations* GetElementAnimations(mozilla::dom::Element *aElement,
                                           nsCSSPseudoElements::Type aPseudoType,
                                           PRBool aCreateIfNeeded);
   void BuildAnimations(nsStyleContext* aStyleContext,
                        InfallibleTArray<ElementAnimation>& aAnimations);
-  void BuildSegment(InfallibleTArray<AnimationSegment>& aSegments,
-                    const nsAnimation& aAnimation,
+  bool BuildSegment(InfallibleTArray<AnimationPropertySegment>& aSegments,
+                    nsCSSProperty aProperty, const nsAnimation& aAnimation,
                     float aFromKey, nsStyleContext* aFromContext,
                     mozilla::css::Declaration* aFromDeclaration,
-                    float aToKey, nsStyleContext* aToContext,
-                    mozilla::css::Declaration* aToDeclaration);
+                    float aToKey, nsStyleContext* aToContext);
   nsIStyleRule* GetAnimationRule(mozilla::dom::Element* aElement,
                                  nsCSSPseudoElements::Type aPseudoType);
 
   nsCSSKeyframesRule* KeyframesRuleFor(const nsSubstring& aName);
 
   bool mKeyframesListIsDirty;
   nsDataHashtable<nsStringHashKey, nsCSSKeyframesRule*> mKeyframesRules;
 
diff --git a/layout/style/test/test_animations.html b/layout/style/test/test_animations.html
--- a/layout/style/test/test_animations.html
+++ b/layout/style/test/test_animations.html
@@ -60,16 +60,34 @@ https://bugzilla.mozilla.org/show_bug.cg
     75%  { padding-bottom: 120px; -moz-animation-timing-function: linear }
     100% { padding-bottom: 20px; -moz-animation-timing-function: ease-out }
   }
 
   #withbefore::before, #withafter::after {
     content: "";
     -moz-animation: anim2 1s linear alternate infinite;
   }
+
+  @-moz-keyframes multiprop {
+    0% {
+      padding-top: 10px; padding-left: 30px;
+      -moz-animation-timing-function: ease;
+    }
+    25% {
+      padding-left: 50px;
+      -moz-animation-timing-function: ease-out;
+    }
+    50% {
+      padding-top: 40px;
+    }
+    75% {
+      padding-top: 80px; padding-left: 60px;
+      -moz-animation-timing-function: ease-in;
+    }
+  }
   </style>
 </head>
 <body>
 <a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=435442">Mozilla Bug 435442</a>
 <div id="display"></div>
 <pre id="test">
 <script type="application/javascript">
 "use strict";
@@ -1108,14 +1126,63 @@ is(cs_after.marginRight, "80px", ":after
 is(cs.marginRight, "0px", ":after animation should not affect element");
 advance_clock(800);
 is(cs_after.marginRight, "0px", ":after test at 2000ms");
 advance_clock(300);
 is(cs_after.marginRight, "30px", ":after test at 2300ms");
 check_events([], "no events should be fired for animations on :after");
 done_div();
 
+/**
+ * Test handling of properties that are present in only some of the
+ * keyframes.
+ */
+new_div("-moz-animation: multiprop 1s ease-in-out alternate infinite");
+is(cs.paddingTop, "10px", "multiprop top at 0ms");
+is(cs.paddingLeft, "30px", "multiprop top at 0ms");
+advance_clock(100);
+is_approx(px_to_num(cs.paddingTop), 10 + 30 * gTF.ease(0.2), 0.01,
+          "multiprop top at 100ms");
+is_approx(px_to_num(cs.paddingLeft), 30 + 20 * gTF.ease(0.4), 0.01,
+          "multiprop left at 100ms");
+advance_clock(200);
+is_approx(px_to_num(cs.paddingTop), 10 + 30 * gTF.ease(0.6), 0.01,
+          "multiprop top at 300ms");
+is_approx(px_to_num(cs.paddingLeft), 50 + 10 * gTF.ease_out(0.1), 0.01,
+          "multiprop left at 300ms");
+advance_clock(300);
+is_approx(px_to_num(cs.paddingTop), 40 + 40 * gTF.ease_in_out(0.4), 0.01,
+          "multiprop top at 600ms");
+is_approx(px_to_num(cs.paddingLeft), 50 + 10 * gTF.ease_out(0.7), 0.01,
+          "multiprop left at 600ms");
+advance_clock(200);
+is_approx(px_to_num(cs.paddingTop), 80 - 80 * gTF.ease_in(0.2), 0.01,
+          "multiprop top at 800ms");
+is_approx(px_to_num(cs.paddingLeft), 60 - 60 * gTF.ease_in(0.2), 0.01,
+          "multiprop left at 800ms");
+advance_clock(400);
+is_approx(px_to_num(cs.paddingTop), 80 - 80 * gTF.ease_in(0.2), 0.01,
+          "multiprop top at 1200ms");
+is_approx(px_to_num(cs.paddingLeft), 60 - 60 * gTF.ease_in(0.2), 0.01,
+          "multiprop left at 1200ms");
+advance_clock(200);
+is_approx(px_to_num(cs.paddingTop), 40 + 40 * gTF.ease_in_out(0.4), 0.01,
+          "multiprop top at 1400ms");
+is_approx(px_to_num(cs.paddingLeft), 50 + 10 * gTF.ease_out(0.7), 0.01,
+          "multiprop left at 1400ms");
+advance_clock(300);
+is_approx(px_to_num(cs.paddingTop), 10 + 30 * gTF.ease(0.6), 0.01,
+          "multiprop top at 1700ms");
+is_approx(px_to_num(cs.paddingLeft), 50 + 10 * gTF.ease_out(0.1), 0.01,
+          "multiprop left at 1700ms");
+advance_clock(200);
+is_approx(px_to_num(cs.paddingTop), 10 + 30 * gTF.ease(0.2), 0.01,
+          "multiprop top at 1900ms");
+is_approx(px_to_num(cs.paddingLeft), 30 + 20 * gTF.ease(0.4), 0.01,
+          "multiprop left at 1900ms");
+done_div();
+
 SpecialPowers.DOMWindowUtils.restoreNormalRefresh();
 
 </script>
 </pre>
 </body>
 </html>
