From: L. David Baron <dbaron@dbaron.org>

Fix css3-animations handling of properties that are not present in all keyframes to match WebKit and generally be more sensible.  (This inverts the relationship between segments and properties in the animation data structures.)  (Bug 649400)

diff --git a/layout/style/Declaration.h b/layout/style/Declaration.h
--- a/layout/style/Declaration.h
+++ b/layout/style/Declaration.h
@@ -246,20 +246,22 @@ private:
   static void AppendImportanceToString(PRBool aIsImportant, nsAString& aString);
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
   PRBool AppendValueToString(nsCSSProperty aProperty, nsAString& aResult) const;
   // Helper for ToString with strange semantics regarding aValue.
   void AppendPropertyAndValueToString(nsCSSProperty aProperty,
                                       nsAutoString& aValue,
                                       nsAString& aResult) const;
 
+public:
   nsCSSProperty OrderValueAt(PRUint32 aValue) const {
     return nsCSSProperty(mOrder.ElementAt(aValue));
   }
 
+private:
   nsAutoTArray<PRUint8, 8> mOrder;
 
   // never null, except while expanded, or before the first call to
   // InitializeEmpty or CompressFrom.
   nsAutoPtr<nsCSSCompressedDataBlock> mData;
 
   // may be null
   nsAutoPtr<nsCSSCompressedDataBlock> mImportantData;
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -42,27 +42,27 @@
 #include "nsStyleSet.h"
 #include "nsCSSRules.h"
 #include "nsStyleAnimation.h"
 #include "nsSMILKeySpline.h"
 #include "nsEventDispatcher.h"
 
 using namespace mozilla;
 
-struct AnimationSegmentProperty
+struct AnimationPropertySegment
+{
+  float mFromKey, mToKey;
+  nsStyleAnimation::Value mFromValue, mToValue;
+  css::ComputedTimingFunction mTimingFunction;
+};
+
+struct AnimationProperty
 {
   nsCSSProperty mProperty;
-  nsStyleAnimation::Value mFromValue, mToValue;
-};
-
-struct AnimationSegment
-{
-  float mFromKey, mToKey;
-  css::ComputedTimingFunction mTimingFunction;
-  InfallibleTArray<AnimationSegmentProperty> mProperties;
+  InfallibleTArray<AnimationPropertySegment> mSegments;
 };
 
 /**
  * Data about one animation (i.e., one of the values of
  * 'animation-name') running on an element.
  */
 struct ElementAnimation
 {
@@ -97,17 +97,17 @@ struct ElementAnimation
   enum {
     LAST_NOTIFICATION_NONE = PRUint32(-1),
     LAST_NOTIFICATION_END = PRUint32(-2)
   };
   // One of the above constants, or an integer for the iteration
   // whose start we last notified on.
   PRUint32 mLastNotification;
 
-  InfallibleTArray<AnimationSegment> mSegments;
+  InfallibleTArray<AnimationProperty> mProperties;
 };
 
 typedef nsAnimationManager::EventArray EventArray;
 typedef nsAnimationManager::AnimationEventInfo AnimationEventInfo;
 
 /**
  * Data about all of the animations running on an element.
  */
@@ -176,25 +176,24 @@ ElementAnimations::EnsureStyleRuleFor(Ti
 
   // mStyleRule may be null and valid, if we have no style to apply.
   if (mStyleRuleRefreshTime.IsNull() ||
       mStyleRuleRefreshTime != aRefreshTime) {
     mStyleRuleRefreshTime = aRefreshTime;
     mStyleRule = nsnull;
 
     // FIXME(spec): assume that properties in higher animations override
-    // those in lower ones (and that our |HasProperty| check in
-    // |BuildSegment| matches the definition of when they should do so.
+    // those in lower ones.
     // Therefore, we iterate from last animation to first.
     nsCSSPropertySet properties;
 
     for (PRUint32 animIdx = mAnimations.Length(); animIdx-- != 0; ) {
       ElementAnimation &anim = mAnimations[animIdx];
 
-      if (anim.mSegments.Length() == 0 ||
+      if (anim.mProperties.Length() == 0 ||
           anim.mIterationDuration.ToMilliseconds() <= 0.0) {
         // No animation data.
         continue;
       }
 
       TimeDuration currentTimeDuration;
       if (anim.IsPaused()) {
         // FIXME: avoid recalculating every time
@@ -273,69 +272,70 @@ ElementAnimations::EnsureStyleRuleFor(Ti
                               currentTimeDuration);
         aEventsToDispatch.AppendElement(ei);
       }
 
       NS_ABORT_IF_FALSE(0.0 <= positionInIteration &&
                           positionInIteration <= 1.0,
                         "position should be in [0-1]");
 
-      NS_ABORT_IF_FALSE(anim.mSegments[0].mFromKey == 0.0,
-                        "incorrect first from key");
-      NS_ABORT_IF_FALSE(anim.mSegments[anim.mSegments.Length() - 1].mToKey
-                          == 1.0,
-                        "incorrect last to key");
+      for (PRUint32 propIdx = 0, propEnd = anim.mProperties.Length();
+           propIdx != propEnd; ++propIdx)
+      {
+        const AnimationProperty &prop = anim.mProperties[propIdx];
 
-      // FIXME: Maybe cache the current segment?
-      const AnimationSegment *segment = anim.mSegments.Elements();
-      while (segment->mToKey < positionInIteration) {
-        NS_ABORT_IF_FALSE(segment->mFromKey < segment->mToKey,
-                          "incorrect keys");
-        ++segment;
-        NS_ABORT_IF_FALSE(segment->mFromKey == (segment-1)->mToKey,
-                          "incorrect keys");
-      }
-      NS_ABORT_IF_FALSE(segment->mFromKey < segment->mToKey,
-                        "incorrect keys");
-      NS_ABORT_IF_FALSE(segment - anim.mSegments.Elements() <
-                          anim.mSegments.Length(),
-                        "ran off end");
+        NS_ABORT_IF_FALSE(prop.mSegments[0].mFromKey == 0.0,
+                          "incorrect first from key");
+        NS_ABORT_IF_FALSE(prop.mSegments[prop.mSegments.Length() - 1].mToKey
+                            == 1.0,
+                          "incorrect last to key");
 
-      if (segment->mProperties.IsEmpty()) {
-        // No animation data.
-        continue;
-      }
-
-      if (!mStyleRule) {
-        // Allocate the style rule now that we know we have animation data.
-        mStyleRule = new css::AnimValuesStyleRule();
-      }
-
-      double positionInSegment = (positionInIteration - segment->mFromKey) /
-                                 (segment->mToKey - segment->mFromKey);
-      double valuePosition =
-        segment->mTimingFunction.GetValue(positionInSegment);
-
-      for (PRUint32 propIdx = 0, propEnd = segment->mProperties.Length();
-           propIdx != propEnd; ++propIdx) {
-        const AnimationSegmentProperty &prop = segment->mProperties[propIdx];
         if (properties.HasProperty(prop.mProperty)) {
           // A later animation already set this property.
           continue;
         }
         properties.AddProperty(prop.mProperty);
 
+        NS_ABORT_IF_FALSE(prop.mSegments.Length() > 0,
+                          "property should not be in animations if it "
+                          "has no segments");
+
+        // FIXME: Maybe cache the current segment?
+        const AnimationPropertySegment *segment = prop.mSegments.Elements();
+        while (segment->mToKey < positionInIteration) {
+          NS_ABORT_IF_FALSE(segment->mFromKey < segment->mToKey,
+                            "incorrect keys");
+          ++segment;
+          NS_ABORT_IF_FALSE(segment->mFromKey == (segment-1)->mToKey,
+                            "incorrect keys");
+        }
+        NS_ABORT_IF_FALSE(segment->mFromKey < segment->mToKey,
+                          "incorrect keys");
+        NS_ABORT_IF_FALSE(segment - prop.mSegments.Elements() <
+                            prop.mSegments.Length(),
+                          "ran off end");
+
+        if (!mStyleRule) {
+          // Allocate the style rule now that we know we have animation data.
+          mStyleRule = new css::AnimValuesStyleRule();
+        }
+
+        double positionInSegment = (positionInIteration - segment->mFromKey) /
+                                   (segment->mToKey - segment->mFromKey);
+        double valuePosition =
+          segment->mTimingFunction.GetValue(positionInSegment);
+
         nsStyleAnimation::Value *val =
           mStyleRule->AddEmptyValue(prop.mProperty);
 
 #ifdef DEBUG
         PRBool result =
 #endif
           nsStyleAnimation::Interpolate(prop.mProperty,
-                                        prop.mFromValue, prop.mToValue,
+                                        segment->mFromValue, segment->mToValue,
                                         valuePosition, *val);
         NS_ABORT_IF_FALSE(result, "interpolate must succeed now");
       }
     }
   }
 }
 
 ElementAnimations*
@@ -605,17 +605,17 @@ ResolvedStyleCache::Get(nsPresContext *a
 {
   // FIXME (spec):  The css3-animations spec isn't very clear about how
   // properties are resolved when they have values that depend on other
   // properties (e.g., values in 'em').  I presume that they're resolved
   // relative to the other styles of the element.  The question is
   // whether they are resolved relative to other animations:  I assume
   // that they're not, since that would prevent us from caching a lot of
   // data that we'd really like to cache (in particular, the
-  // nsStyleAnimation::Value values in AnimationSegmentProperty).
+  // nsStyleAnimation::Value values in AnimationPropertySegment).
   nsStyleContext *result = mCache.GetWeak(aKeyframe);
   if (!result) {
     nsCOMArray<nsIStyleRule> rules;
     rules.AppendObject(aKeyframe);
     nsRefPtr<nsStyleContext> resultStrong = aPresContext->StyleSet()->
       ResolveStyleByAddingRules(aParentStyleContext, rules);
     mCache.Put(aKeyframe, resultStrong);
     result = resultStrong;
@@ -690,102 +690,114 @@ nsAnimationManager::BuildAnimations(nsSt
     keyframes.EnumerateRead(AppendKeyframeData, &sortedKeyframes);
     sortedKeyframes.Sort(KeyframeDataComparator());
 
     if (sortedKeyframes.Length() == 0) {
       // no segments
       continue;
     }
 
-    KeyframeData fromKeyframe = sortedKeyframes[0];
-    nsRefPtr<nsStyleContext> fromContext =
-      resolvedStyles.Get(mPresContext, aStyleContext,
-                         fromKeyframe.mRule);
+    // In the first loop through the keyframes rules, record the
+    // properties that are present in any of them.
+    nsCSSPropertySet properties;
 
-    // If there's no rule for 0%, there's implicitly an empty rule.
-    if (fromKeyframe.mKey != 0.0f) {
-      BuildSegment(aDest.mSegments, aSrc,
-                   0.0f, aStyleContext, nsnull,
-                   fromKeyframe.mKey, fromContext,
-                     fromKeyframe.mRule->Declaration());
+    for (PRUint32 kfIdx = 0, kfEnd = sortedKeyframes.Length();
+         kfIdx != kfEnd; ++kfIdx) {
+      css::Declaration *decl = sortedKeyframes[kfIdx].mRule->Declaration();
+      for (PRUint32 propIdx = 0, propEnd = decl->Count();
+           propIdx != propEnd; ++propIdx) {
+        properties.AddProperty(decl->OrderValueAt(propIdx));
+      }
     }
 
-    for (PRUint32 kfIdx = 1, kfEnd = sortedKeyframes.Length();
-         kfIdx != kfEnd; ++kfIdx) {
-      KeyframeData toKeyframe = sortedKeyframes[kfIdx];
-      nsRefPtr<nsStyleContext> toContext =
-        resolvedStyles.Get(mPresContext, aStyleContext, toKeyframe.mRule);
+    for (nsCSSProperty prop = nsCSSProperty(0);
+         prop < eCSSProperty_COUNT_no_shorthands;
+         prop = nsCSSProperty(prop + 1)) {
+      if (!properties.HasProperty(prop) ||
+          nsCSSProps::kAnimTypeTable[prop] == eStyleAnimType_None) {
+        continue;
+      }
 
-      BuildSegment(aDest.mSegments, aSrc,
-                   fromKeyframe.mKey, fromContext,
-                   fromKeyframe.mRule->Declaration(),
-                   toKeyframe.mKey, toContext,
-                   toKeyframe.mRule->Declaration());
+      AnimationProperty &propData = *aDest.mProperties.AppendElement();
+      propData.mProperty = prop;
 
-      fromContext = toContext;
-      fromKeyframe = toKeyframe;
-    }
+      KeyframeData *fromKeyframe = nsnull;
+      nsRefPtr<nsStyleContext> fromContext;
+      for (PRUint32 kfIdx = 0, kfEnd = sortedKeyframes.Length();
+           kfIdx != kfEnd; ++kfIdx) {
+        KeyframeData &toKeyframe = sortedKeyframes[kfIdx];
+        if (!toKeyframe.mRule->Declaration()->HasProperty(prop)) {
+          continue;
+        }
 
-    // If there's no rule for 100%, there's implicitly an empty rule.
-    if (fromKeyframe.mKey != 1.0f) {
-      BuildSegment(aDest.mSegments, aSrc,
-                   fromKeyframe.mKey, fromContext,
-                   fromKeyframe.mRule->Declaration(),
-                   1.0f, aStyleContext, nsnull);
+        nsRefPtr<nsStyleContext> toContext =
+          resolvedStyles.Get(mPresContext, aStyleContext, toKeyframe.mRule);
+
+        if (fromKeyframe) {
+          BuildSegment(propData.mSegments, prop, aSrc,
+                       fromKeyframe->mKey, fromContext,
+                       fromKeyframe->mRule->Declaration(),
+                       toKeyframe.mKey, toContext);
+        } else {
+          if (toKeyframe.mKey != 0.0f) {
+            // There's no data for this property at 0%, so use the
+            // cascaded value above us.
+            BuildSegment(propData.mSegments, prop, aSrc,
+                         0.0f, aStyleContext, nsnull,
+                         toKeyframe.mKey, toContext);
+          }
+        }
+
+        fromContext = toContext;
+        fromKeyframe = &toKeyframe;
+      }
+
+      if (fromKeyframe->mKey != 1.0f) {
+        // There's no data for this property at 100%, so use the
+        // cascaded value above us.
+        BuildSegment(propData.mSegments, prop, aSrc,
+                     fromKeyframe->mKey, fromContext,
+                     fromKeyframe->mRule->Declaration(),
+                     1.0f, aStyleContext);
+      }
     }
   }
 }
 
 void
-nsAnimationManager::BuildSegment(InfallibleTArray<AnimationSegment>& aSegments,
+nsAnimationManager::BuildSegment(InfallibleTArray<AnimationPropertySegment>&
+                                   aSegments,
+                                 nsCSSProperty aProperty,
                                  const nsAnimation& aAnimation,
                                  float aFromKey, nsStyleContext* aFromContext,
                                  mozilla::css::Declaration* aFromDeclaration,
-                                 float aToKey, nsStyleContext* aToContext,
-                                 mozilla::css::Declaration* aToDeclaration)
+                                 float aToKey, nsStyleContext* aToContext)
 {
-  AnimationSegment &segment = *aSegments.AppendElement();
+  nsStyleAnimation::Value fromValue, toValue, dummyValue;
+  if (ExtractComputedValueForTransition(aProperty, aFromContext, fromValue) &&
+      ExtractComputedValueForTransition(aProperty, aToContext, toValue) &&
+      // Check that we can interpolate between these values
+      // (If this is ever a performance problem, we could add a
+      // CanInterpolate method, but it seems fine for now.)
+      nsStyleAnimation::Interpolate(aProperty, fromValue, toValue,
+                                    0.5, dummyValue)) {
+    AnimationPropertySegment &segment = *aSegments.AppendElement();
 
-  segment.mFromKey = aFromKey;
-  segment.mToKey = aToKey;
-  const nsTimingFunction *tf;
-  if (aFromDeclaration &&
-      aFromDeclaration->HasProperty(eCSSProperty_animation_timing_function)) {
-    tf = &aFromContext->GetStyleDisplay()->mAnimations[0].GetTimingFunction();
-  } else {
-    tf = &aAnimation.GetTimingFunction();
-  }
-  segment.mTimingFunction.Init(*tf);
-
-  for (nsCSSProperty prop = nsCSSProperty(0);
-       prop < eCSSProperty_COUNT_no_shorthands;
-       prop = nsCSSProperty(prop + 1)) {
-    if (nsCSSProps::kAnimTypeTable[prop] == eStyleAnimType_None) {
-      continue;
+    segment.mFromValue = fromValue;
+    segment.mToValue = toValue;
+    segment.mFromKey = aFromKey;
+    segment.mToKey = aToKey;
+    const nsTimingFunction *tf;
+    if (aFromDeclaration &&
+        aFromDeclaration->HasProperty(eCSSProperty_animation_timing_function)) {
+      tf = &aFromContext->GetStyleDisplay()->mAnimations[0].GetTimingFunction();
+    } else {
+      tf = &aAnimation.GetTimingFunction();
     }
-
-    if (!(aFromDeclaration && aFromDeclaration->HasProperty(prop)) &&
-        !(aToDeclaration && aToDeclaration->HasProperty(prop))) {
-      // Don't store an animation if neither declaration has the property.
-      continue;
-    }
-
-    nsStyleAnimation::Value fromValue, toValue, dummyValue;
-    if (ExtractComputedValueForTransition(prop, aFromContext, fromValue) &&
-        ExtractComputedValueForTransition(prop, aToContext, toValue) &&
-        // Check that we can interpolate between these values
-        // (If this is ever a performance problem, we could add a
-        // CanInterpolate method, but it seems fine for now.)
-        nsStyleAnimation::Interpolate(prop, fromValue, toValue,
-                                      0.5, dummyValue)) {
-      AnimationSegmentProperty &p = *segment.mProperties.AppendElement();
-      p.mProperty = prop;
-      p.mFromValue = fromValue;
-      p.mToValue = toValue;
-    }
+    segment.mTimingFunction.Init(*tf);
   }
 }
 
 nsIStyleRule*
 nsAnimationManager::GetAnimationRule(mozilla::dom::Element* aElement,
                                      nsCSSPseudoElements::Type aPseudoType)
 {
   NS_ABORT_IF_FALSE(
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -42,17 +42,17 @@
 #include "nsCSSPseudoElements.h"
 #include "nsStyleContext.h"
 #include "nsTHashtable.h"
 #include "nsGUIEvent.h"
 #include "mozilla/TimeStamp.h"
 #include "nsThreadUtils.h"
 
 class nsCSSKeyframesRule;
-struct AnimationSegment;
+struct AnimationPropertySegment;
 struct ElementAnimation;
 struct ElementAnimations;
 
 namespace mozilla {
 namespace css {
 class Declaration;
 }
 }
@@ -130,22 +130,21 @@ public:
   void DispatchEvents();
 
 private:
   ElementAnimations* GetElementAnimations(mozilla::dom::Element *aElement,
                                           nsCSSPseudoElements::Type aPseudoType,
                                           PRBool aCreateIfNeeded);
   void BuildAnimations(nsStyleContext* aStyleContext,
                        InfallibleTArray<ElementAnimation>& aAnimations);
-  void BuildSegment(InfallibleTArray<AnimationSegment>& aSegments,
-                    const nsAnimation& aAnimation,
+  void BuildSegment(InfallibleTArray<AnimationPropertySegment>& aSegments,
+                    nsCSSProperty aProperty, const nsAnimation& aAnimation,
                     float aFromKey, nsStyleContext* aFromContext,
                     mozilla::css::Declaration* aFromDeclaration,
-                    float aToKey, nsStyleContext* aToContext,
-                    mozilla::css::Declaration* aToDeclaration);
+                    float aToKey, nsStyleContext* aToContext);
   nsIStyleRule* GetAnimationRule(mozilla::dom::Element* aElement,
                                  nsCSSPseudoElements::Type aPseudoType);
 
   nsCSSKeyframesRule* KeyframesRuleFor(const nsSubstring& aName);
 
   bool mKeyframesListIsDirty;
   nsDataHashtable<nsStringHashKey, nsCSSKeyframesRule*> mKeyframesRules;
 
