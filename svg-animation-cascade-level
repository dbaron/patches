From: L. David Baron <dbaron@dbaron.org>

Bug 1057231 patch 3 - Add new cascade level for rules from SMIL Animation of SVG attributes to the style set.

I will fix the indentation of gCascadeLevels in bug 977991 patch 2,
which adds a member to each element of the array.

Note that this bumps the maximum sheetType from 8 to 9 (and number of
them from 9 to 10), which does not require updating
NS_RULE_NODE_LEVEL_MASK, since NS_RULE_NODE_LEVEL_MASK currently has 4
bits and allows a maximum of 15.

diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -28,16 +28,17 @@
 #include "nsRuleProcessorData.h"
 #include "nsTransitionManager.h"
 #include "nsAnimationManager.h"
 #include "nsStyleSheetService.h"
 #include "mozilla/dom/Element.h"
 #include "GeckoProfiler.h"
 #include "nsHTMLCSSStyleSheet.h"
 #include "nsHTMLStyleSheet.h"
+#include "SVGAttrAnimationRuleProcessor.h"
 #include "nsCSSRules.h"
 #include "nsPrintfCString.h"
 #include "nsIFrame.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 NS_IMPL_ISUPPORTS(nsEmptyStyleRule, nsIStyleRule)
@@ -182,18 +183,24 @@ nsStyleSet::Init(nsPresContext *aPresCon
 {
   mFirstLineRule = new nsEmptyStyleRule;
   mFirstLetterRule = new nsEmptyStyleRule;
   mPlaceholderRule = new nsEmptyStyleRule;
   mDisableTextZoomStyleRule = new nsDisableTextZoomStyleRule;
 
   mRuleTree = nsRuleNode::CreateRootNode(aPresContext);
 
+  // Make an explicit GatherRuleProcessors call for the levels that
+  // don't have style sheets.  The other levels will have their calls
+  // triggered by DirtyRuleProcessors).  (We should probably convert the
+  // ePresHintSheet and eStyleAttrSheet levels to work like this as
+  // well, and not implement nsIStyleSheet.)
   GatherRuleProcessors(eAnimationSheet);
   GatherRuleProcessors(eTransitionSheet);
+  GatherRuleProcessors(eSVGAttrAnimationSheet);
 }
 
 nsresult
 nsStyleSet::BeginReconstruct()
 {
   NS_ASSERTION(!mInReconstruct, "Unmatched begin/end?");
   NS_ASSERTION(mRuleTree, "Reconstructing before first construction?");
 
@@ -368,18 +375,23 @@ nsStyleSet::GatherRuleProcessors(sheetTy
       mRuleProcessors[aType] = PresContext()->TransitionManager();
       return NS_OK;
     case eStyleAttrSheet:
       MOZ_ASSERT(mSheets[aType].Count() == 0);
       mRuleProcessors[aType] = PresContext()->Document()->GetInlineStyleSheet();
       return NS_OK;
     case ePresHintSheet:
       MOZ_ASSERT(mSheets[aType].Count() == 0);
-      mRuleProcessors[aType] = PresContext()->Document()->GetAttributeStyleSheet();
+      mRuleProcessors[aType] =
+        PresContext()->Document()->GetAttributeStyleSheet();
       return NS_OK;
+    case eSVGAttrAnimationSheet:
+      MOZ_ASSERT(mSheets[aType].Count() == 0);
+      mRuleProcessors[aType] =
+        PresContext()->Document()->GetSVGAttrAnimationRuleProcessor();
     default:
       // keep going
       break;
   }
   if (aType == eScopedDocSheet) {
     // Create a rule processor for each scope.
     uint32_t count = mSheets[eScopedDocSheet].Count();
     if (count) {
@@ -955,16 +967,17 @@ nsStyleSet::FileRules(nsIStyleRuleProces
   PROFILER_LABEL("nsStyleSet", "FileRules",
     js::ProfileEntry::Category::CSS);
 
   // Cascading order:
   // [least important]
   //  - UA normal rules                    = Agent        normal
   //  - User normal rules                  = User         normal
   //  - Presentation hints                 = PresHint     normal
+  //  - SVG Animation (highest pres hint)  = SVGAttrAnimation normal
   //  - Author normal rules                = Document     normal
   //  - Override normal rules              = Override     normal
   //  - animation rules                    = Animation    normal
   //  - Author !important rules            = Document     !important
   //  - Override !important rules          = Override     !important
   //  - User !important rules              = User         !important
   //  - UA !important rules                = Agent        !important
   //  - transition rules                   = Transition   normal
@@ -986,18 +999,22 @@ nsStyleSet::FileRules(nsIStyleRuleProces
   if (!skipUserStyles && mRuleProcessors[eUserSheet]) // NOTE: different
     (*aCollectorFunc)(mRuleProcessors[eUserSheet], aData);
   nsRuleNode* lastUserRN = aRuleWalker->CurrentNode();
   bool haveImportantUserRules = !aRuleWalker->GetCheckForImportantRules();
 
   aRuleWalker->SetLevel(ePresHintSheet, false, false);
   if (mRuleProcessors[ePresHintSheet])
     (*aCollectorFunc)(mRuleProcessors[ePresHintSheet], aData);
-  nsRuleNode* lastPresHintRN = aRuleWalker->CurrentNode();
-  
+
+  aRuleWalker->SetLevel(eSVGAttrAnimationSheet, false, false);
+  if (mRuleProcessors[eSVGAttrAnimationSheet])
+    (*aCollectorFunc)(mRuleProcessors[eSVGAttrAnimationSheet], aData);
+  nsRuleNode* lastSVGAttrAnimationRN = aRuleWalker->CurrentNode();
+
   aRuleWalker->SetLevel(eDocSheet, false, true);
   bool cutOffInheritance = false;
   if (mBindingManager && aElement) {
     // We can supply additional document-level sheets that should be walked.
     mBindingManager->WalkRules(aCollectorFunc,
                                static_cast<ElementDependentRuleProcessorData*>(aData),
                                &cutOffInheritance);
   }
@@ -1060,21 +1077,21 @@ nsStyleSet::FileRules(nsIStyleRuleProces
 #ifdef DEBUG
   else {
     AssertNoImportantRules(lastScopedRN, lastDocRN);
   }
 #endif
 
   if (haveImportantDocRules) {
     aRuleWalker->SetLevel(eDocSheet, true, false);
-    AddImportantRules(lastDocRN, lastPresHintRN, aRuleWalker);  // doc
+    AddImportantRules(lastDocRN, lastSVGAttrAnimationRN, aRuleWalker);  // doc
   }
 #ifdef DEBUG
   else {
-    AssertNoImportantRules(lastDocRN, lastPresHintRN);
+    AssertNoImportantRules(lastDocRN, lastSVGAttrAnimationRN);
   }
 #endif
 
   if (haveImportantStyleAttrRules) {
     aRuleWalker->SetLevel(eStyleAttrSheet, true, false);
     AddImportantRules(lastStyleAttrRN, lastScopedRN, aRuleWalker);  // style attr
   }
 #ifdef DEBUG
@@ -1089,17 +1106,17 @@ nsStyleSet::FileRules(nsIStyleRuleProces
   }
 #ifdef DEBUG
   else {
     AssertNoImportantRules(lastOvrRN, lastStyleAttrRN);
   }
 #endif
 
 #ifdef DEBUG
-  AssertNoCSSRules(lastPresHintRN, lastUserRN);
+  AssertNoCSSRules(lastSVGAttrAnimationRN, lastUserRN);
 #endif
 
   if (haveImportantUserRules) {
     aRuleWalker->SetLevel(eUserSheet, true, false);
     AddImportantRules(lastUserRN, lastAgentRN, aRuleWalker); //user
   }
 #ifdef DEBUG
   else {
@@ -1144,16 +1161,19 @@ nsStyleSet::WalkRuleProcessors(nsIStyleR
 
   bool skipUserStyles = aData->mElement->IsInNativeAnonymousSubtree();
   if (!skipUserStyles && mRuleProcessors[eUserSheet]) // NOTE: different
     (*aFunc)(mRuleProcessors[eUserSheet], aData);
 
   if (mRuleProcessors[ePresHintSheet])
     (*aFunc)(mRuleProcessors[ePresHintSheet], aData);
 
+  if (mRuleProcessors[eSVGAttrAnimationSheet])
+    (*aFunc)(mRuleProcessors[eSVGAttrAnimationSheet], aData);
+
   bool cutOffInheritance = false;
   if (mBindingManager) {
     // We can supply additional document-level sheets that should be walked.
     if (aWalkAllXBLStylesheets) {
       mBindingManager->WalkAllRules(aFunc, aData);
     } else {
       mBindingManager->WalkRules(aFunc, aData, &cutOffInheritance);
     }
@@ -1309,16 +1329,17 @@ struct CascadeLevel {
   bool mIsImportant;
   nsRestyleHint mLevelReplacementHint;
 };
 
 static const CascadeLevel gCascadeLevels[] = {
   { nsStyleSet::eAgentSheet,      false, nsRestyleHint(0) },
   { nsStyleSet::eUserSheet,       false, nsRestyleHint(0) },
   { nsStyleSet::ePresHintSheet,   false, nsRestyleHint(0) },
+  { nsStyleSet::eSVGAttrAnimationSheet, false, nsRestyleHint(0) },
   { nsStyleSet::eDocSheet,        false, nsRestyleHint(0) },
   { nsStyleSet::eScopedDocSheet,  false, nsRestyleHint(0) },
   { nsStyleSet::eStyleAttrSheet,  false, nsRestyleHint(0) },
   { nsStyleSet::eOverrideSheet,   false, nsRestyleHint(0) },
   { nsStyleSet::eAnimationSheet,  false, eRestyle_CSSAnimations },
   { nsStyleSet::eScopedDocSheet,  true,  nsRestyleHint(0) },
   { nsStyleSet::eDocSheet,        true,  nsRestyleHint(0) },
   { nsStyleSet::eStyleAttrSheet,  true,  nsRestyleHint(0) },
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -270,16 +270,17 @@ class nsStyleSet
   }
 
   // The "origins" of the CSS cascade, from lowest precedence to
   // highest (for non-!important rules).
   enum sheetType {
     eAgentSheet, // CSS
     eUserSheet, // CSS
     ePresHintSheet,
+    eSVGAttrAnimationSheet,
     eDocSheet, // CSS
     eScopedDocSheet,
     eStyleAttrSheet,
     eOverrideSheet, // CSS
     eAnimationSheet,
     eTransitionSheet,
     eSheetTypeCount
     // be sure to keep the number of bits in |mDirty| below and in
@@ -467,17 +468,17 @@ class nsStyleSet
                          // contexts use to look up properties.
 
   uint16_t mBatching;
 
   unsigned mInShutdown : 1;
   unsigned mAuthorStyleDisabled: 1;
   unsigned mInReconstruct : 1;
   unsigned mInitFontFeatureValuesLookup : 1;
-  unsigned mDirty : 9;  // one dirty bit is used per sheet type
+  unsigned mDirty : 10;  // one dirty bit is used per sheet type
 
   uint32_t mUnusedRuleNodeCount; // used to batch rule node GC
   nsTArray<nsStyleContext*> mRoots; // style contexts with no parent
 
   // Empty style rules to force things that restrict which properties
   // apply into different branches of the rule tree.
   nsRefPtr<nsEmptyStyleRule> mFirstLineRule, mFirstLetterRule, mPlaceholderRule;
 
