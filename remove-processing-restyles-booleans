From: L. David Baron <dbaron@dbaron.org>

Bug 1075137 patch 7 - Remove old IsProcessingRestyles and IsProcessingAnimationStyleChange booleans.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1447,17 +1447,16 @@ RestyleManager::RebuildAllStyleData(nsCh
 
   nsAutoScriptBlocker scriptBlocker;
 
   NS_ABORT_IF_FALSE(!mIsProcessingRestyles,
                     "Nesting calls to processing restyles");
 #ifdef DEBUG
   mIsProcessingRestyles = true;
 #endif
-  mPresContext->SetProcessingRestyles(true);
 
   // Until we get rid of these phases in bug 960465, we need to skip
   // animation restyles during the non-animation phase, and post
   // animation restyles so that we restyle those elements again in the
   // animation phase.
   mSkipAnimationRules = true;
   mPostAnimationRestyles = true;
 
@@ -1471,17 +1470,16 @@ RestyleManager::RebuildAllStyleData(nsCh
                         nsRestyleHint(eRestyle_Subtree |
                                       eRestyle_ForceDescendants));
 
   mPostAnimationRestyles = false;
   mSkipAnimationRules = false;
 #ifdef DEBUG
   mIsProcessingRestyles = false;
 #endif
-  mPresContext->SetProcessingRestyles(false);
 
   // Make sure that we process any pending animation restyles from the
   // above style change.  Note that we can *almost* implement the above
   // by just posting a style change -- except we really need to restyle
   // the root frame rather than the root element's primary frame.
   ProcessPendingRestyles();
 }
 
@@ -1546,17 +1544,16 @@ RestyleManager::ProcessPendingRestyles()
   mPresContext->FrameConstructor()->CreateNeededFrames();
 
   // Process non-animation restyles...
   NS_ABORT_IF_FALSE(!mIsProcessingRestyles,
                     "Nesting calls to ProcessPendingRestyles?");
 #ifdef DEBUG
   mIsProcessingRestyles = true;
 #endif
-  mPresContext->SetProcessingRestyles(true);
 
   // Before we process any restyles, we need to ensure that style
   // resulting from any throttled animations (animations that we're
   // running entirely on the compositor thread) is up-to-date, so that
   // if any style changes we cause trigger transitions, we have the
   // correct old style for starting the transition.
   if (nsLayoutUtils::AreAsyncAnimationsEnabled() &&
       mPendingRestyles.Count() > 0) {
@@ -1583,23 +1580,20 @@ RestyleManager::ProcessPendingRestyles()
   // ...and then process animation restyles.  This needs to happen
   // second because we need to start animations that resulted from the
   // first set of restyles (e.g., CSS transitions with negative
   // transition-delay), and because we need to immediately
   // restyle-with-animation any just-restyled elements that are
   // mid-transition (since processing the non-animation restyle ignores
   // the running transition so it can check for a new change on the same
   // property, and then posts an immediate animation style change).
-  mPresContext->SetProcessingAnimationStyleChange(true);
   mIsProcessingAnimationStyleChange = true;
   mPendingAnimationRestyles.ProcessRestyles();
   mIsProcessingAnimationStyleChange = false;
-  mPresContext->SetProcessingAnimationStyleChange(false);
-
-  mPresContext->SetProcessingRestyles(false);
+
 #ifdef DEBUG
   mIsProcessingRestyles = false;
 #endif
   NS_POSTCONDITION(mPendingRestyles.Count() == oldPendingRestyleCount,
                    "We should not have posted new non-animation restyles while "
                    "processing animation restyles");
 
   if (mRebuildAllStyleData) {
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -895,36 +895,16 @@ public:
   static void ClearNotifySubDocInvalidationData(mozilla::layers::ContainerLayer* aContainer);
   bool IsDOMPaintEventPending();
   void ClearMozAfterPaintEvents() {
     mInvalidateRequestsSinceLastPaint.mRequests.Clear();
     mUndeliveredInvalidateRequestsBeforeLastPaint.mRequests.Clear();
     mAllInvalidated = false;
   }
 
-  bool IsProcessingRestyles() const {
-    return mProcessingRestyles;
-  }
-
-  void SetProcessingRestyles(bool aProcessing) {
-    NS_ASSERTION(aProcessing != bool(mProcessingRestyles),
-                 "should never nest");
-    mProcessingRestyles = aProcessing;
-  }
-
-  bool IsProcessingAnimationStyleChange() const {
-    return mProcessingAnimationStyleChange;
-  }
-
-  void SetProcessingAnimationStyleChange(bool aProcessing) {
-    NS_ASSERTION(aProcessing != bool(mProcessingAnimationStyleChange),
-                 "should never nest");
-    mProcessingAnimationStyleChange = aProcessing;
-  }
-
   /**
    * Notify the prescontext that the presshell is about to reflow a reflow root.
    * The single argument indicates whether this reflow should be interruptible.
    * If aInterruptible is false then CheckForInterrupt and HasPendingInterrupt
    * will always return false. If aInterruptible is true then CheckForInterrupt
    * will return true when a pending event is detected.  This is for use by the
    * presshell only.  Reflow code wanting to prevent interrupts should use
    * InterruptPreventer.
@@ -1350,19 +1330,16 @@ protected:
   unsigned              mPostedFlushCounterStyles: 1;
 
   // resize reflow is suppressed when the only change has been to zoom
   // the document rather than to change the document's dimensions
   unsigned              mSupressResizeReflow : 1;
 
   unsigned              mIsVisual : 1;
 
-  unsigned              mProcessingRestyles : 1;
-  unsigned              mProcessingAnimationStyleChange : 1;
-
   unsigned              mBelowSomethingDirty : 1;
 
   unsigned              mFireAfterPaintEvents : 1;
 
   unsigned              mIsChrome : 1;
   unsigned              mIsChromeOriginImage : 1;
 
   // Should we paint flash in this context? Do not use this variable directly.
