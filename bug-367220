Fix error tracking size of circularly linked list of counters, causing mis-sorting.  b=367220

diff -r f710a23c91b5 layout/base/nsGenConList.cpp
--- a/layout/base/nsGenConList.cpp	Tue Jan 16 21:18:22 2007 -0800
+++ b/layout/base/nsGenConList.cpp	Wed Jan 17 00:33:11 2007 -0800
@@ -68,6 +68,7 @@ nsGenConList::DestroyNodesFor(nsIFrame* 
   PRBool destroyed = PR_FALSE;
   while (mFirstNode->mPseudoFrame == aFrame) {
     destroyed = PR_TRUE;
+    --mSize;
     node = Next(mFirstNode);
     if (node == mFirstNode) { // Last link
       mFirstNode = nsnull;
@@ -84,6 +85,7 @@ nsGenConList::DestroyNodesFor(nsIFrame* 
   while (node != mFirstNode) {
     if (node->mPseudoFrame == aFrame) {
       destroyed = PR_TRUE;
+      --mSize;
       nsGenConNode *nextNode = Next(node);
       Remove(node);
       delete node;
@@ -134,6 +136,7 @@ nsGenConList::NodeAfter(const nsGenConNo
       return pseudoType1 == 1;
     }
   }
+  // XXX Switch to the frame version of DoCompareTreePosition?
   PRInt32 cmp = nsLayoutUtils::DoCompareTreePosition(content1, content2,
                                                      pseudoType1, -pseudoType2);
   NS_ASSERTION(cmp != 0, "same content, different frames");
@@ -152,6 +155,7 @@ nsGenConList::Insert(nsGenConNode* aNode
       // Binary search.
 
       // the range of indices at which |aNode| could end up.
+      // (We already know it can't be at index mSize.)
       PRUint32 first = 0, last = mSize - 1;
 
       // A cursor to avoid walking more than the length of the list.
@@ -189,4 +193,9 @@ nsGenConList::Insert(nsGenConNode* aNode
     mFirstNode = aNode;
   }
   ++mSize;
-}
+
+  NS_ASSERTION(aNode == mFirstNode || NodeAfter(aNode, Prev(aNode)),
+               "sorting error");
+  NS_ASSERTION(IsLast(aNode) || NodeAfter(Next(aNode), aNode),
+               "sorting error");
+}
