Fix error tracking size of circularly linked list of counters, causing mis-sorting.  b=367220

diff -r f710a23c91b5 layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp	Tue Jan 16 21:18:22 2007 -0800
+++ b/layout/base/nsCSSFrameConstructor.cpp	Tue Jan 16 23:19:14 2007 -0800
@@ -10176,6 +10176,9 @@ nsCSSFrameConstructor::EndUpdate()
     if (mCountersDirty) {
       mCountersDirty = PR_FALSE;
       mCounterManager.RecalcAll();
+#if defined(DEBUG_dbaron)
+      mCounterManager.Dump();
+#endif
     }
 
     NS_ASSERTION(!mQuotesDirty, "Quotes updates will be lost");
@@ -10189,7 +10192,7 @@ void
 void
 nsCSSFrameConstructor::WillDestroyFrameTree()
 {
-#if defined(DEBUG_dbaron_off)
+#if defined(DEBUG_dbaron)
   mCounterManager.Dump();
 #endif
 
diff -r f710a23c91b5 layout/base/nsGenConList.cpp
--- a/layout/base/nsGenConList.cpp	Tue Jan 16 21:18:22 2007 -0800
+++ b/layout/base/nsGenConList.cpp	Wed Jan 17 00:26:50 2007 -0800
@@ -68,6 +68,7 @@ nsGenConList::DestroyNodesFor(nsIFrame* 
   PRBool destroyed = PR_FALSE;
   while (mFirstNode->mPseudoFrame == aFrame) {
     destroyed = PR_TRUE;
+    --mSize;
     node = Next(mFirstNode);
     if (node == mFirstNode) { // Last link
       mFirstNode = nsnull;
@@ -84,6 +85,7 @@ nsGenConList::DestroyNodesFor(nsIFrame* 
   while (node != mFirstNode) {
     if (node->mPseudoFrame == aFrame) {
       destroyed = PR_TRUE;
+      --mSize;
       nsGenConNode *nextNode = Next(node);
       Remove(node);
       delete node;
@@ -109,10 +111,12 @@ inline PRBool PseudoCompareType(nsIFrame
 /* static */ PRBool
 nsGenConList::NodeAfter(const nsGenConNode* aNode1, const nsGenConNode* aNode2)
 {
+printf("NodeAfter(%p,%p):\n", aNode1, aNode2);
   nsIFrame *frame1 = aNode1->mPseudoFrame;
   nsIFrame *frame2 = aNode2->mPseudoFrame;
   if (frame1 == frame2) {
     NS_ASSERTION(aNode2->mContentIndex != aNode1->mContentIndex, "identical");
+printf("  returning %d at line %d\n", aNode1->mContentIndex > aNode2->mContentIndex, __LINE__);
     return aNode1->mContentIndex > aNode2->mContentIndex;
   }
   PRInt32 pseudoType1 = PseudoCompareType(frame1);
@@ -122,6 +126,7 @@ nsGenConList::NodeAfter(const nsGenConNo
   if (pseudoType1 == 0 || pseudoType2 == 0) {
     if (content1 == content2) {
       NS_ASSERTION(pseudoType1 != pseudoType2, "identical");
+printf("  returning %d at line %d\n", pseudoType2 == 0, __LINE__);
       return pseudoType2 == 0;
     }
     // We want to treat an element as coming before its :before (preorder
@@ -131,12 +136,15 @@ nsGenConList::NodeAfter(const nsGenConNo
   } else {
     if (content1 == content2) {
       NS_ASSERTION(pseudoType1 != pseudoType2, "identical");
+printf("  returning %d at line %d\n", pseudoType1 == 1, __LINE__);
       return pseudoType1 == 1;
     }
   }
+  // XXX Switch to the frame version of DoCompareTreePosition?
   PRInt32 cmp = nsLayoutUtils::DoCompareTreePosition(content1, content2,
                                                      pseudoType1, -pseudoType2);
   NS_ASSERTION(cmp != 0, "same content, different frames");
+printf("  returning %d at line %d\n", cmp > 0, __LINE__);
   return cmp > 0;
 }
 
@@ -152,6 +160,7 @@ nsGenConList::Insert(nsGenConNode* aNode
       // Binary search.
 
       // the range of indices at which |aNode| could end up.
+      // (We already know it can't be at index mSize.)
       PRUint32 first = 0, last = mSize - 1;
 
       // A cursor to avoid walking more than the length of the list.
@@ -160,12 +169,17 @@ nsGenConList::Insert(nsGenConNode* aNode
 
       while (first != last) {
         PRUint32 test = (first + last) / 2;
+printf("  first=%d last=%d test=%d\n", first, last, test);
         if (last == curIndex) {
-          for ( ; curIndex != test; --curIndex)
+          for ( ; curIndex != test; --curIndex) {
+printf("    stepping back\n");
             curNode = Prev(curNode);
+          }
         } else {
-          for ( ; curIndex != test; ++curIndex)
+          for ( ; curIndex != test; ++curIndex) {
             curNode = Next(curNode);
+printf("    stepping forward\n");
+          }
         }
 
         if (NodeAfter(aNode, curNode)) {
@@ -189,4 +203,7 @@ nsGenConList::Insert(nsGenConNode* aNode
     mFirstNode = aNode;
   }
   ++mSize;
-}
+
+  NS_ASSERTION(aNode == mFirstNode || NodeAfter(aNode, Prev(aNode)), "sorting error");
+  NS_ASSERTION(IsLast(aNode) || NodeAfter(Next(aNode), aNode), "sorting error");
+}
