Fix error tracking size of circularly linked list of counters, causing mis-sorting.  b=367220

diff -r f710a23c91b5 layout/base/nsGenConList.cpp
--- a/layout/base/nsGenConList.cpp	Tue Jan 16 21:18:22 2007 -0800
+++ b/layout/base/nsGenConList.cpp	Wed Jan 17 00:43:13 2007 -0800
@@ -69,14 +69,13 @@ nsGenConList::DestroyNodesFor(nsIFrame* 
   while (mFirstNode->mPseudoFrame == aFrame) {
     destroyed = PR_TRUE;
     node = Next(mFirstNode);
-    if (node == mFirstNode) { // Last link
+    Remove(mFirstNode);
+    delete mFirstNode;
+    if (node == mFirstNode) { // Last link (comparing dangling pointers!)
       mFirstNode = nsnull;
-      delete node;
       return PR_TRUE;
     }
     else {
-      Remove(mFirstNode);
-      delete mFirstNode;
       mFirstNode = node;
     }
   }
@@ -134,6 +133,7 @@ nsGenConList::NodeAfter(const nsGenConNo
       return pseudoType1 == 1;
     }
   }
+  // XXX Switch to the frame version of DoCompareTreePosition?
   PRInt32 cmp = nsLayoutUtils::DoCompareTreePosition(content1, content2,
                                                      pseudoType1, -pseudoType2);
   NS_ASSERTION(cmp != 0, "same content, different frames");
@@ -152,6 +152,7 @@ nsGenConList::Insert(nsGenConNode* aNode
       // Binary search.
 
       // the range of indices at which |aNode| could end up.
+      // (We already know it can't be at index mSize.)
       PRUint32 first = 0, last = mSize - 1;
 
       // A cursor to avoid walking more than the length of the list.
@@ -189,4 +190,9 @@ nsGenConList::Insert(nsGenConNode* aNode
     mFirstNode = aNode;
   }
   ++mSize;
+
+  NS_ASSERTION(aNode == mFirstNode || NodeAfter(aNode, Prev(aNode)),
+               "sorting error");
+  NS_ASSERTION(IsLast(aNode) || NodeAfter(Next(aNode), aNode),
+               "sorting error");
 }
