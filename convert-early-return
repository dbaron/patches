From: L. David Baron <dbaron@dbaron.org>

Bug 567283 patch 1 - Convert if enclosing most of function into early return.

MozReview-Commit-ID: A5unK4grJ47

diff --git a/gfx/src/nsColor.cpp b/gfx/src/nsColor.cpp
--- a/gfx/src/nsColor.cpp
+++ b/gfx/src/nsColor.cpp
@@ -75,52 +75,52 @@ static int ComponentValue(const char16_t
   return component;
 }
 
 bool NS_HexToRGB(const nsAString& aColorSpec, nscolor* aResult)
 {
   const char16_t* buffer = aColorSpec.BeginReading();
 
   int nameLen = aColorSpec.Length();
-  if ((nameLen == 3) || (nameLen == 6)) {
-    // Make sure the digits are legal
-    for (int i = 0; i < nameLen; i++) {
-      char16_t ch = buffer[i];
-      if (((ch >= '0') && (ch <= '9')) ||
-          ((ch >= 'a') && (ch <= 'f')) ||
-          ((ch >= 'A') && (ch <= 'F'))) {
-        // Legal character
-        continue;
-      }
-      // Whoops. Illegal character.
-      return false;
-    }
-
-    // Convert the ascii to binary
-    int dpc = ((3 == nameLen) ? 1 : 2);
-    // Translate components from hex to binary
-    int r = ComponentValue(buffer, nameLen, 0, dpc);
-    int g = ComponentValue(buffer, nameLen, 1, dpc);
-    int b = ComponentValue(buffer, nameLen, 2, dpc);
-    if (dpc == 1) {
-      // Scale single digit component to an 8 bit value. Replicate the
-      // single digit to compute the new value.
-      r = (r << 4) | r;
-      g = (g << 4) | g;
-      b = (b << 4) | b;
-    }
-    NS_ASSERTION((r >= 0) && (r <= 255), "bad r");
-    NS_ASSERTION((g >= 0) && (g <= 255), "bad g");
-    NS_ASSERTION((b >= 0) && (b <= 255), "bad b");
-    *aResult = NS_RGB(r, g, b);
-    return true;
+  if (nameLen != 3 && nameLen != 6) {
+    // Improperly formatted color value
+    return false;
   }
 
-  // Improperly formatted color value
-  return false;
+  // Make sure the digits are legal
+  for (int i = 0; i < nameLen; i++) {
+    char16_t ch = buffer[i];
+    if (((ch >= '0') && (ch <= '9')) ||
+        ((ch >= 'a') && (ch <= 'f')) ||
+        ((ch >= 'A') && (ch <= 'F'))) {
+      // Legal character
+      continue;
+    }
+    // Whoops. Illegal character.
+    return false;
+  }
+
+  // Convert the ascii to binary
+  int dpc = ((3 == nameLen) ? 1 : 2);
+  // Translate components from hex to binary
+  int r = ComponentValue(buffer, nameLen, 0, dpc);
+  int g = ComponentValue(buffer, nameLen, 1, dpc);
+  int b = ComponentValue(buffer, nameLen, 2, dpc);
+  if (dpc == 1) {
+    // Scale single digit component to an 8 bit value. Replicate the
+    // single digit to compute the new value.
+    r = (r << 4) | r;
+    g = (g << 4) | g;
+    b = (b << 4) | b;
+  }
+  NS_ASSERTION((r >= 0) && (r <= 255), "bad r");
+  NS_ASSERTION((g >= 0) && (g <= 255), "bad g");
+  NS_ASSERTION((b >= 0) && (b <= 255), "bad b");
+  *aResult = NS_RGB(r, g, b);
+  return true;
 }
 
 // This implements part of the algorithm for legacy behavior described in
 // http://www.whatwg.org/specs/web-apps/current-work/complete/common-microsyntaxes.html#rules-for-parsing-a-legacy-color-value
 bool NS_LooseHexToRGB(const nsString& aColorSpec, nscolor* aResult)
 {
   if (aColorSpec.EqualsLiteral("transparent")) {
     return false;
