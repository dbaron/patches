Fix race saving/restoring malloc hooks.  b=392009

diff --git a/tools/trace-malloc/lib/nsTraceMalloc.c b/tools/trace-malloc/lib/nsTraceMalloc.c
--- a/tools/trace-malloc/lib/nsTraceMalloc.c
+++ b/tools/trace-malloc/lib/nsTraceMalloc.c
@@ -157,17 +157,34 @@ static uint32 tracing_enabled = 1;
  * Callers should not *enter* the lock without checking suppress_tracing
  * first; otherwise they risk trying to re-enter on the same thread.
  */
-#define TM_ENTER_LOCK()                                                       \
+#define TM_ENTER_LOCK(t)                                                      \
     PR_BEGIN_MACRO                                                            \
+        PR_ASSERT(t->suppress_tracing != 0);                                  \
         if (tmlock)                                                           \
             PR_Lock(tmlock);                                                  \
+        t->holding_tmlock = 1;                                                \
     PR_END_MACRO
 
-#define TM_EXIT_LOCK()                                                        \
+#define TM_EXIT_LOCK(t)                                                       \
     PR_BEGIN_MACRO                                                            \
+        PR_ASSERT(t->suppress_tracing != 0);                                  \
+        t->holding_tmlock = 0;                                                \
         if (tmlock)                                                           \
             PR_Unlock(tmlock);                                                \
     PR_END_MACRO
+
+#define TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t)                                 \
+    PR_BEGIN_MACRO                                                            \
+        t->suppress_tracing++;                                                \
+        TM_ENTER_LOCK(t);                                                     \
+    PR_END_MACRO
+
+#define TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t)                                \
+    PR_BEGIN_MACRO                                                            \
+        TM_EXIT_LOCK(t);                                                      \
+        t->suppress_tracing--;                                                \
+    PR_END_MACRO
+
 
 /*
  * Thread-local storage.
@@ -246,6 +263,7 @@ tm_get_thread(void)
          * malloc below
          */
         stack_tm_thread.suppress_tracing = 1;
+        stack_tm_thread.holding_tmlock = 0;
         stack_tm_thread.backtrace_buf.buffer = NULL;
         stack_tm_thread.backtrace_buf.size = 0;
         stack_tm_thread.backtrace_buf.entries = 0;
@@ -253,6 +271,7 @@ tm_get_thread(void)
 
         t = (tm_thread*) __libc_malloc(sizeof(tm_thread));
         t->suppress_tracing = 0;
+        t->holding_tmlock = 0;
         t->backtrace_buf = stack_tm_thread.backtrace_buf;
         TM_SET_TLS_DATA(tls_index, t);
 
@@ -577,7 +596,7 @@ static PLHashTable *methods = NULL;
 static PLHashTable *methods = NULL;
 
 static callsite *
-calltree(void **stack, size_t num_stack_entries)
+calltree(void **stack, size_t num_stack_entries, tm_thread *t)
 {
     logfile *fp = logfp;
     void *pc;
@@ -599,7 +618,7 @@ calltree(void **stack, size_t num_stack_
      * that we need to in this function, because it makes some calls
      * that could lock in the system's shared library loader.
      */
-    TM_ENTER_LOCK();
+    TM_ENTER_LOCK(t);
 
     maxstack = (num_stack_entries > tmstats.calltree_maxstack);
     if (maxstack) {
@@ -673,9 +692,9 @@ calltree(void **stack, size_t num_stack_
          * and then filling in the descriptions for any that hadn't been
          * described already.  But this is easier for now.
          */
-        TM_EXIT_LOCK();
+        TM_EXIT_LOCK(t);
         rv = NS_DescribeCodeAddress(pc, &details);
-        TM_ENTER_LOCK();
+        TM_ENTER_LOCK(t);
         if (NS_FAILED(rv)) {
             tmstats.dladdr_failures++;
             goto fail;
@@ -863,11 +882,11 @@ calltree(void **stack, size_t num_stack_
     if (maxstack)
         calltree_maxstack_top = site;
 
-    TM_EXIT_LOCK();
+    TM_EXIT_LOCK(t);
     return site;
 
   fail:
-    TM_EXIT_LOCK();
+    TM_EXIT_LOCK(t);
     return NULL;
 }
 
@@ -942,15 +961,15 @@ backtrace(tm_thread *t, int skip)
         return NULL;
     }
 
-    site = calltree(info->buffer, info->entries);
-
-    TM_ENTER_LOCK();
+    site = calltree(info->buffer, info->entries, t);
+
+    TM_ENTER_LOCK(t);
     tmstats.backtrace_calls++;
     if (!site) {
         tmstats.backtrace_failures++;
         PR_ASSERT(tmstats.backtrace_failures < 100);
     }
-    TM_EXIT_LOCK();
+    TM_EXIT_LOCK(t);
 
     t->suppress_tracing--;
     return site;
@@ -1088,22 +1107,24 @@ static __ptr_t (*old_memalign_hook)(size
 static __ptr_t (*old_memalign_hook)(size_t boundary, size_t size, __const __malloc_ptr_t caller);
 static void (*old_free_hook)(__ptr_t ptr, __const __malloc_ptr_t caller);
 
+static int32 enter_hook(tm_thread *t);
+static void exit_hook(tm_thread *t, int32 do_unlock);
+
 static __ptr_t
 my_malloc_hook(size_t size, __const __malloc_ptr_t caller)
 {
     tm_thread *t;
     PRUint32 start, end;
     __ptr_t ptr;
+    int32 do_unlock;
 
     PR_ASSERT(tracing_enabled);
     t = tm_get_thread();
-    t->suppress_tracing++;
-    __malloc_hook = old_malloc_hook;
+    do_unlock = enter_hook(t);
     start = PR_IntervalNow();
     ptr = __libc_malloc(size);
     end = PR_IntervalNow();
-    __malloc_hook = my_malloc_hook;
-    t->suppress_tracing--;
+    exit_hook(t, do_unlock);
     MallocCallback(ptr, size, start, end, t);
     return ptr;
 }
@@ -1114,11 +1135,11 @@ my_realloc_hook(__ptr_t oldptr, size_t s
     tm_thread *t;
     PRUint32 start, end;
     __ptr_t ptr;
+    int32 do_unlock;
 
     PR_ASSERT(tracing_enabled);
     t = tm_get_thread();
-    t->suppress_tracing++;
-    __realloc_hook = old_realloc_hook;
+    do_unlock = enter_hook(t);
     start = PR_IntervalNow();
 
     /*
@@ -1127,8 +1148,7 @@ my_realloc_hook(__ptr_t oldptr, size_t s
      */
     ptr = __libc_realloc(oldptr, size);
     end = PR_IntervalNow();
-    __realloc_hook = my_realloc_hook;
-    t->suppress_tracing--;
+    exit_hook(t, do_unlock);
     ReallocCallback(oldptr, ptr, size, start, end, t);
     return ptr;
 }
@@ -1139,16 +1159,15 @@ my_memalign_hook(size_t boundary, size_t
     tm_thread *t;
     PRUint32 start, end;
     __ptr_t ptr;
+    int32 do_unlock;
 
     PR_ASSERT(tracing_enabled);
     t = tm_get_thread();
-    t->suppress_tracing++;
-    __memalign_hook = old_memalign_hook;
+    do_unlock = enter_hook(t);
     start = PR_IntervalNow();
     ptr = __libc_memalign(boundary, size);
     end = PR_IntervalNow();
-    __memalign_hook = my_memalign_hook;
-    t->suppress_tracing--;
+    exit_hook(t, do_unlock);
     MallocCallback(ptr, size, start, end, t);
     return ptr;
 }
@@ -1158,17 +1177,67 @@ my_free_hook(__ptr_t ptr, __const __mall
 {
     tm_thread *t;
     PRUint32 start, end;
+    int32 do_unlock;
 
     PR_ASSERT(tracing_enabled);
     t = tm_get_thread();
-    t->suppress_tracing++;
-    __free_hook = old_free_hook;
+    do_unlock = enter_hook(t);
     start = PR_IntervalNow();
     __libc_free(ptr);
     end = PR_IntervalNow();
+    exit_hook(t, do_unlock);
+    FreeCallback(ptr, start, end, t);
+}
+
+static void
+restore_old_hooks(void)
+{
+    __malloc_hook = old_malloc_hook;
+    __realloc_hook = old_realloc_hook;
+    __memalign_hook = old_memalign_hook;
+    __free_hook = old_free_hook;
+}
+
+static void
+set_my_hooks(void)
+{
+    __malloc_hook = my_malloc_hook;
+    __realloc_hook = my_realloc_hook;
+    __memalign_hook = my_memalign_hook;
     __free_hook = my_free_hook;
+}
+
+/* static */ int32
+enter_hook(tm_thread *t)
+{
+    int32 do_lock;
+
+    t->suppress_tracing++;
+
+    do_lock = !t->holding_tmlock;
+    if (do_lock)
+        TM_ENTER_LOCK(t);
+
+    /*
+     * We need to unset the hooks while holding the lock so that other
+     * threads don't race with this one (causing us to miss
+     * allocations/frees). 
+     */
+    restore_old_hooks();
+
+    return do_lock;
+}
+
+/* static */ void
+exit_hook(tm_thread *t, int32 do_unlock)
+{
+    /* while holding lock; see above */
+    set_my_hooks();
+
+    if (do_unlock)
+        TM_EXIT_LOCK(t);
+
     t->suppress_tracing--;
-    FreeCallback(ptr, start, end, t);
 }
 
 static void
@@ -1181,10 +1250,7 @@ StartupHooker(void)
     old_memalign_hook = __memalign_hook;
     old_free_hook = __free_hook;
 
-    __malloc_hook = my_malloc_hook;
-    __realloc_hook = my_realloc_hook;
-    __memalign_hook = my_memalign_hook;
-    __free_hook = my_free_hook;
+    set_my_hooks();
 }
 
 static void
@@ -1192,10 +1258,7 @@ ShutdownHooker(void)
 {
     PR_ASSERT(__malloc_hook == my_malloc_hook);
 
-    __malloc_hook = old_malloc_hook;
-    __realloc_hook = old_realloc_hook;
-    __memalign_hook = old_memalign_hook;
-    __free_hook = old_free_hook;
+    restore_old_hooks();
 }
 
 #elif defined(XP_WIN32)
@@ -1447,13 +1510,11 @@ NS_TraceMallocDisable(void)
     if (tracing_enabled == 0)
         return;
 
-    t->suppress_tracing++;
-    TM_ENTER_LOCK();
+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);
     for (fp = logfile_list; fp; fp = fp->next)
         flush_logfile(fp);
     sample = --tracing_enabled;
-    TM_EXIT_LOCK();
-    t->suppress_tracing--;
+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);
     if (sample == 0)
         ShutdownHooker();
 }
@@ -1464,11 +1525,9 @@ NS_TraceMallocEnable(void)
     tm_thread *t = tm_get_thread();
     uint32 sample;
 
-    t->suppress_tracing++;
-    TM_ENTER_LOCK();
+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);
     sample = ++tracing_enabled;
-    TM_EXIT_LOCK();
-    t->suppress_tracing--;
+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);
     if (sample == 1)
         StartupHooker();
 }
@@ -1480,23 +1539,20 @@ NS_TraceMallocChangeLogFD(int fd)
     struct stat sb;
     tm_thread *t = tm_get_thread();
 
-    t->suppress_tracing++;
-    TM_ENTER_LOCK();
+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);
     oldfp = logfp;
     if (oldfp->fd != fd) {
         flush_logfile(oldfp);
         fp = get_logfile(fd);
         if (!fp) {
-            TM_EXIT_LOCK();
-            t->suppress_tracing--;
+            TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);
             return -2;
         }
         if (fd >= 0 && fstat(fd, &sb) == 0 && sb.st_size == 0)
             log_header(fd);
         logfp = fp;
     }
-    TM_EXIT_LOCK();
-    t->suppress_tracing--;
+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);
     return oldfp->fd;
 }
 
@@ -1526,8 +1582,7 @@ NS_TraceMallocCloseLogFD(int fd)
     logfile *fp;
     tm_thread *t = tm_get_thread();
 
-    t->suppress_tracing++;
-    TM_ENTER_LOCK();
+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);
 
     fp = get_logfile(fd);
     if (fp) {
@@ -1558,8 +1613,7 @@ NS_TraceMallocCloseLogFD(int fd)
         }
     }
 
-    TM_EXIT_LOCK();
-    t->suppress_tracing--;
+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);
     close(fd);
 }
 
@@ -1575,8 +1629,7 @@ NS_TraceMallocLogTimestamp(const char *c
 #endif
     tm_thread *t = tm_get_thread();
 
-    t->suppress_tracing++;
-    TM_ENTER_LOCK();
+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);
 
     fp = logfp;
     log_byte(fp, TM_EVENT_TIMESTAMP);
@@ -1593,8 +1646,7 @@ NS_TraceMallocLogTimestamp(const char *c
 #endif
     log_string(fp, caption);
 
-    TM_EXIT_LOCK();
-    t->suppress_tracing--;
+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);
 }
 
 static PRIntn
@@ -1653,8 +1705,7 @@ NS_TraceMallocDumpAllocations(const char
 
     tm_thread *t = tm_get_thread();
 
-    t->suppress_tracing++;
-    TM_ENTER_LOCK();
+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);
 
     ofp = fopen(pathname, WRITE_FLAGS);
     if (ofp) {
@@ -1668,8 +1719,7 @@ NS_TraceMallocDumpAllocations(const char
         rv = -1;
     }
 
-    TM_EXIT_LOCK();
-    t->suppress_tracing--;
+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);
 
     return rv;
 }
@@ -1680,14 +1730,12 @@ NS_TraceMallocFlushLogfiles(void)
     logfile *fp;
     tm_thread *t = tm_get_thread();
 
-    t->suppress_tracing++;
-    TM_ENTER_LOCK();
+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);
 
     for (fp = logfile_list; fp; fp = fp->next)
         flush_logfile(fp);
 
-    TM_EXIT_LOCK();
-    t->suppress_tracing--;
+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);
 }
 
 PR_IMPLEMENT(void)
@@ -1699,8 +1747,7 @@ NS_TrackAllocation(void* ptr, FILE *ofp)
     fprintf(ofp, "Trying to track %p\n", (void*) ptr);
     setlinebuf(ofp);
 
-    t->suppress_tracing++;
-    TM_ENTER_LOCK();
+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);
     if (get_allocations()) {
         alloc = (allocation*)
                 *PL_HashTableRawLookup(allocations, hash_pointer(ptr), ptr);
@@ -1711,8 +1758,7 @@ NS_TrackAllocation(void* ptr, FILE *ofp)
             fprintf(ofp, "Not tracking %p\n", (void*) ptr);
         }
     }
-    TM_EXIT_LOCK();
-    t->suppress_tracing--;
+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);
 }
 
 PR_IMPLEMENT(void)
@@ -1727,8 +1773,7 @@ MallocCallback(void *ptr, size_t size, P
 
     site = backtrace(t, 2);
 
-    t->suppress_tracing++;
-    TM_ENTER_LOCK();
+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);
     tmstats.malloc_calls++;
     if (!ptr) {
         tmstats.malloc_failures++;
@@ -1747,8 +1792,7 @@ MallocCallback(void *ptr, size_t size, P
             }
         }
     }
-    TM_EXIT_LOCK();
-    t->suppress_tracing--;
+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);
 }
 
 PR_IMPLEMENT(void)
@@ -1763,8 +1807,7 @@ CallocCallback(void *ptr, size_t count, 
 
     site = backtrace(t, 2);
 
-    t->suppress_tracing++;
-    TM_ENTER_LOCK();
+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);
     tmstats.calloc_calls++;
     if (!ptr) {
         tmstats.calloc_failures++;
@@ -1784,8 +1827,7 @@ CallocCallback(void *ptr, size_t count, 
             }
         }
     }
-    TM_EXIT_LOCK();
-    t->suppress_tracing--;
+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);
 }
 
 PR_IMPLEMENT(void)
@@ -1804,8 +1846,7 @@ ReallocCallback(void * oldptr, void *ptr
 
     site = backtrace(t, 2);
 
-    t->suppress_tracing++;
-    TM_ENTER_LOCK();
+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);
     tmstats.realloc_calls++;
     oldsite = NULL;
     oldsize = 0;
@@ -1869,8 +1910,7 @@ ReallocCallback(void * oldptr, void *ptr
             }
         }
     }
-    TM_EXIT_LOCK();
-    t->suppress_tracing--;
+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);
 }
 
 PR_IMPLEMENT(void)
@@ -1883,8 +1923,7 @@ FreeCallback(void * ptr, PRUint32 start,
     if (!tracing_enabled || t->suppress_tracing != 0)
         return;
 
-    t->suppress_tracing++;
-    TM_ENTER_LOCK();
+    TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);
     tmstats.free_calls++;
     if (!ptr) {
         tmstats.null_free_calls++;
@@ -1909,8 +1948,7 @@ FreeCallback(void * ptr, PRUint32 start,
             }
         }
     }
-    TM_EXIT_LOCK();
-    t->suppress_tracing--;
+    TM_EXIT_LOCK_AND_UNSUPPRESS_TRACING(t);
 }
 
 #endif /* NS_TRACE_MALLOC */
diff --git a/tools/trace-malloc/lib/nsTraceMallocCallbacks.h b/tools/trace-malloc/lib/nsTraceMallocCallbacks.h
--- a/tools/trace-malloc/lib/nsTraceMallocCallbacks.h
+++ b/tools/trace-malloc/lib/nsTraceMallocCallbacks.h
@@ -62,6 +62,9 @@ struct tm_thread {
      */
     uint32 suppress_tracing;
 
+    /* Whether this thread holds tmlock. */
+    int32 holding_tmlock;
+
     /* buffer for backtrace, below */
     stack_buffer_info backtrace_buf;
 };
