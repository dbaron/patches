Replace mechanism for restricting the properties that apply to :first-line and :first-letter.

diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -49,18 +49,20 @@
 #include "nsCSSProperty.h"
 #include "nsStyleStruct.h"
 #include "nsCSSKeywords.h"
 
 // Flags for the kFlagsTable bitfield (flags_ in nsCSSPropList.h)
 
 // A property that is a *-ltr-source or *-rtl-source property for one of
 // the directional pseudo-shorthand properties.
-#define CSS_PROPERTY_DIRECTIONAL_SOURCE (1<<0)
-#define CSS_PROPERTY_VALUE_LIST_USES_COMMAS (1<<1) /* otherwise spaces */
+#define CSS_PROPERTY_DIRECTIONAL_SOURCE           (1<<0)
+#define CSS_PROPERTY_VALUE_LIST_USES_COMMAS       (1<<1) /* otherwise spaces */
+#define CSS_PROPERTY_APPLIES_TO_FIRST_LETTER      (1<<2)
+#define CSS_PROPERTY_APPLIES_TO_FIRST_LINE        (1<<3)
 
 class nsCSSProps {
 public:
   static void AddRefTable(void);
   static void ReleaseTable(void);
 
   // Given a property string, return the enum value
   static nsCSSProperty LookupProperty(const nsAString& aProperty);
diff --git a/layout/style/nsHTMLCSSStyleSheet.cpp b/layout/style/nsHTMLCSSStyleSheet.cpp
--- a/layout/style/nsHTMLCSSStyleSheet.cpp
+++ b/layout/style/nsHTMLCSSStyleSheet.cpp
@@ -33,311 +33,32 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /*
  * style sheet and style rule processor representing style attributes
- * and some additional overrides
  */
 
 #include "nsIHTMLCSSStyleSheet.h"
 #include "nsCRT.h"
 #include "nsIAtom.h"
 #include "nsIURL.h"
 #include "nsCSSPseudoElements.h"
 #include "nsIStyleRule.h"
 #include "nsIFrame.h"
 #include "nsICSSStyleRule.h"
 #include "nsIStyleRuleProcessor.h"
 #include "nsPresContext.h"
 #include "nsIDocument.h"
 #include "nsCOMPtr.h"
 #include "nsRuleWalker.h"
 #include "nsRuleData.h"
-
-/*
- * The CSSFirstLetterRule and CSSFirstLineRule exist so that we can fix
- * up the style data so that we don't have non-default values for the
- * properties that don't apply to :first-letter and :first-line.
- *
- * CSSDisablePropsRule is a common base class for both the
- * CSSFirstLetterRule and CSSFirstLineRule.
- */
-
-class CSSDisablePropsRule : public nsIStyleRule {
-public:
-  CSSDisablePropsRule();
-  virtual ~CSSDisablePropsRule();
-
-  NS_DECL_ISUPPORTS
-
-  // Call this something else so that this class still has pure virtual
-  // functions.
-  void CommonMapRuleInfoInto(nsRuleData* aRuleData);
-
-#ifdef DEBUG
-  NS_IMETHOD List(FILE* out = stdout, PRInt32 aIndent = 0) const;
-#endif
-protected:
-  nsCSSValueList mInheritList;
-  nsCSSValueList mNoneList;
-  nsCSSValuePairList mInheritQuotes;
-  nsCSSValuePairList mNoneCounter;
-};
-
-CSSDisablePropsRule::CSSDisablePropsRule()
-{
-  nsCSSValue none(eCSSUnit_None);
-  mNoneCounter.mXValue = none;
-  mNoneList.mValue = none;
-  nsCSSValue inherit(eCSSUnit_Inherit);
-  mInheritList.mValue = inherit;
-  mInheritQuotes.mXValue = inherit;
-}
-
-class CSSFirstLineRule : public CSSDisablePropsRule {
-public:
-  CSSFirstLineRule() {}
-
-  NS_IMETHOD MapRuleInfoInto(nsRuleData* aRuleData);
-};
-
-class CSSFirstLetterRule : public CSSDisablePropsRule {
-public:
-  CSSFirstLetterRule() {}
-
-  NS_IMETHOD MapRuleInfoInto(nsRuleData* aRuleData);
-};
-
-CSSDisablePropsRule::~CSSDisablePropsRule()
-{
-}
-
-NS_IMPL_ISUPPORTS1(CSSDisablePropsRule, nsIStyleRule)
-
-#ifdef DEBUG
-NS_IMETHODIMP
-CSSDisablePropsRule::List(FILE* out, PRInt32 aIndent) const
-{
-  return NS_OK;
-}
-#endif
-
-// -----------------------------------------------------------
-
-/*
- * Note:  These rule mapping functions, unlike practically all others,
- * will overwrite the properties even if they're not |eCSSUnit_Null|.
- * XXX This is only a partial fix for the fact that they should be
- * higher in the cascade (at the very top).  It doesn't work in the case
- * where something higher in the cascade fully specifies the struct.
- *
- * XXX This should be cleaned up once we implement eCSSUnit_Initial
- * throughout.
- */
-
-void
-CSSDisablePropsRule::CommonMapRuleInfoInto(nsRuleData* aData)
-{
-  /*
-   * Common code for disabling the properties that apply neither to
-   * :first-letter nor to :first-line.
-   */
-
-  // Disable 'unicode-bidi'.
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
-    nsCSSValue normal(eCSSUnit_Normal);
-    aData->mTextData->mUnicodeBidi = normal;
-  }
-
-  // NOTE: 'text-align', 'text-indent', and 'white-space' should not be
-  // handled by the frames so we don't need to bother.
-
-  // Disable everything in the nsRuleDataDisplay struct except 'float'.
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Visibility)) {
-    nsCSSValue inherit(eCSSUnit_Inherit);
-    aData->mDisplayData->mVisibility = inherit;
-    aData->mDisplayData->mDirection = inherit;
-  }
-
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) {
-    nsCSSValue none(eCSSUnit_None);
-    aData->mDisplayData->mAppearance = none;
-
-    nsCSSValue autovalue(eCSSUnit_Auto);
-    aData->mDisplayData->mClip.mTop = autovalue;
-    aData->mDisplayData->mClip.mRight = autovalue;
-    aData->mDisplayData->mClip.mBottom = autovalue;
-    aData->mDisplayData->mClip.mLeft = autovalue;
-
-    nsCSSValue one(1.0f, eCSSUnit_Number);
-    aData->mDisplayData->mOpacity = one;
-
-    nsCSSValue inlinevalue(NS_STYLE_DISPLAY_INLINE, eCSSUnit_Enumerated);
-    aData->mDisplayData->mDisplay = inlinevalue;
-
-    aData->mDisplayData->mBinding = none;
-
-    nsCSSValue staticposition(NS_STYLE_POSITION_STATIC, eCSSUnit_Enumerated);
-    aData->mDisplayData->mPosition = staticposition;
-
-    nsCSSValue visible(NS_STYLE_OVERFLOW_VISIBLE, eCSSUnit_Enumerated);
-    aData->mDisplayData->mOverflowX = visible;
-    aData->mDisplayData->mOverflowY = visible;
-
-    aData->mDisplayData->mClear = none;
-
-    aData->mDisplayData->mTransform = &mNoneList;
-
-    nsCSSValue fiftyPercent(0.5f, eCSSUnit_Percent);
-    aData->mDisplayData->mTransformOrigin.mXValue = fiftyPercent;
-    aData->mDisplayData->mTransformOrigin.mYValue = fiftyPercent;
-
-    // Nobody will care about 'break-before' or 'break-after', since
-    // they only apply to blocks (assuming we implement them correctly).
-  }
-
-  // NOTE:  We'll never do anything with what's in nsCSSList,
-  // nsCSSTable, nsCSSBreaks, nsCSSPage, nsCSSAural, nsCSSXUL, or
-  // nsCSSSVG, so don't bother.
-
-  // Disable everything in the position struct.
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)) {
-    nsCSSValue autovalue(eCSSUnit_Auto);
-    nsCSSValue none(eCSSUnit_None);
-    nsCSSValue zero(0.0f, eCSSUnit_Point);
-    aData->mPositionData->mOffset.mTop = autovalue;
-    aData->mPositionData->mOffset.mRight = autovalue;
-    aData->mPositionData->mOffset.mBottom = autovalue;
-    aData->mPositionData->mOffset.mLeft = autovalue;
-    aData->mPositionData->mWidth = autovalue;
-    aData->mPositionData->mMinWidth = zero;
-    aData->mPositionData->mMaxWidth = none;
-    aData->mPositionData->mHeight = autovalue;
-    aData->mPositionData->mMinHeight = zero;
-    aData->mPositionData->mMaxHeight = none;
-    nsCSSValue content(NS_STYLE_BOX_SIZING_CONTENT, eCSSUnit_Enumerated);
-    aData->mPositionData->mBoxSizing = content;
-    aData->mPositionData->mZIndex = autovalue;
-  }
-
-  // Disable everything in the Content struct.
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Content)) {
-    // Don't bother resetting 'content'.
-
-    aData->mContentData->mCounterIncrement = &mNoneCounter;
-    aData->mContentData->mCounterReset = &mNoneCounter;
-
-    nsCSSValue autovalue(eCSSUnit_Auto);
-    aData->mContentData->mMarkerOffset = autovalue;
-  }
-
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Quotes)) {
-    aData->mContentData->mQuotes = &mInheritQuotes;
-  }
-
-  // Disable everything in the UserInterface struct.
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(UserInterface)) {
-    nsCSSValue inherit(eCSSUnit_Inherit);
-    aData->mUserInterfaceData->mUserInput = inherit;
-    aData->mUserInterfaceData->mUserModify = inherit;
-    aData->mUserInterfaceData->mUserFocus = inherit;
-    aData->mUserInterfaceData->mCursor = &mInheritList;
-  }
-
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(UIReset)) {
-    nsCSSValue autovalue(eCSSUnit_Auto);
-    nsCSSValue none(eCSSUnit_None);
-    // Don't bother with '-moz-force-broken-image-icon' since it's only
-    // half a property.
-    // Don't bother with '-moz-user-select' because there's no way to
-    // specify the initial value.
-  }
-
-  // Disable all outline properties.
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Outline)) {
-    nsCSSValue none(NS_STYLE_BORDER_STYLE_NONE, eCSSUnit_Enumerated);
-    aData->mMarginData->mOutlineStyle = none;
-  }
-
-}
-
-NS_IMETHODIMP
-CSSFirstLineRule::MapRuleInfoInto(nsRuleData* aData)
-{
-  /*
-   * See CSS2.1 section 5.12.1, which says that the properties that apply
-   * to :first-line are: font properties, color properties, background
-   * properties, 'word-spacing', 'letter-spacing', 'text-decoration',
-   * 'vertical-align', 'text-transform', and 'line-height'.
-   *
-   * We also allow 'text-shadow', which was listed in CSS2 (where the
-   * property existed).
-   */
-
-  CommonMapRuleInfoInto(aData);
-
-  // Disable 'float'.
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) {
-    nsCSSValue none(eCSSUnit_None);
-    aData->mDisplayData->mFloat = none;
-  }
-
-  // Disable border properties, margin properties, and padding
-  // properties.
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Border)) {
-    nsCSSValue none(NS_STYLE_BORDER_STYLE_NONE, eCSSUnit_Enumerated);
-    aData->mMarginData->mBorderStyle.mTop = none;
-    aData->mMarginData->mBorderStyle.mRight = none;
-    aData->mMarginData->mBorderStyle.mBottom = none;
-    aData->mMarginData->mBorderStyle.mLeft = none;
-  }
-
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Margin)) {
-    nsCSSValue zero(0.0f, eCSSUnit_Point);
-    aData->mMarginData->mMargin.mTop = zero;
-    aData->mMarginData->mMargin.mRight = zero;
-    aData->mMarginData->mMargin.mBottom = zero;
-    aData->mMarginData->mMargin.mLeft = zero;
-  }
-
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Padding)) {
-    nsCSSValue zero(0.0f, eCSSUnit_Point);
-    aData->mMarginData->mPadding.mTop = zero;
-    aData->mMarginData->mPadding.mRight = zero;
-    aData->mMarginData->mPadding.mBottom = zero;
-    aData->mMarginData->mPadding.mLeft = zero;
-  }
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-CSSFirstLetterRule::MapRuleInfoInto(nsRuleData* aData)
-{
-  /*
-   * See CSS2.1 section 5.12.2, which says that the properties that
-   * apply to :first-letter are: font properties, 'text-decoration',
-   * 'text-transform', 'letter-spacing', 'word-spacing' (when
-   * appropriate), 'line-height', 'float', 'vertical-align' (only if
-   * 'float' is 'none'), margin properties, padding properties, border
-   * properties, 'color', and background properties.
-   */
-
-  CommonMapRuleInfoInto(aData);
-
-  // NOTE:  'vertical-align' is only supposed to be relevant if 'float'
-  // is 'none', but we don't do anything with it if 'float' is not none,
-  // so we don't need to disable it.
-
-  return NS_OK;
-}
 
 // -----------------------------------------------------------
 
 class HTMLCSSStyleSheetImpl : public nsIHTMLCSSStyleSheet,
                               public nsIStyleRuleProcessor {
 public:
   HTMLCSSStyleSheetImpl();
 
@@ -387,38 +108,30 @@ private:
   HTMLCSSStyleSheetImpl& operator=(const HTMLCSSStyleSheetImpl& aCopy); 
 
 protected:
   virtual ~HTMLCSSStyleSheetImpl();
 
 protected:
   nsIURI*         mURL;
   nsIDocument*    mDocument;
-
-  CSSFirstLineRule* mFirstLineRule;
-  CSSFirstLetterRule* mFirstLetterRule;
 };
 
 
 HTMLCSSStyleSheetImpl::HTMLCSSStyleSheetImpl()
   : nsIHTMLCSSStyleSheet(),
     mRefCnt(0),
     mURL(nsnull),
-    mDocument(nsnull),
-    mFirstLineRule(nsnull),
-    mFirstLetterRule(nsnull)
+    mDocument(nsnull)
 {
 }
 
 HTMLCSSStyleSheetImpl::~HTMLCSSStyleSheetImpl()
 {
   NS_RELEASE(mURL);
-
-  NS_IF_RELEASE(mFirstLineRule);
-  NS_IF_RELEASE(mFirstLetterRule);
 }
 
 NS_IMPL_ISUPPORTS3(HTMLCSSStyleSheetImpl,
                    nsIHTMLCSSStyleSheet,
                    nsIStyleSheet,
                    nsIStyleRuleProcessor)
 
 NS_IMETHODIMP
@@ -434,42 +147,16 @@ HTMLCSSStyleSheetImpl::RulesMatching(Ele
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLCSSStyleSheetImpl::RulesMatching(PseudoRuleProcessorData* aData)
 {
-  // We only want to add these rules if there are real :first-letter or
-  // :first-line rules that cause a pseudo-element frame to be created.
-  // Otherwise the use of ProbePseudoStyleContextFor will prevent frame
-  // creation, and adding rules here would cause it.
-  if (aData->mRuleWalker->AtRoot())
-    return NS_OK;
-
-  nsIAtom* pseudoTag = aData->mPseudoTag;
-  if (pseudoTag == nsCSSPseudoElements::firstLine) {
-    if (!mFirstLineRule) {
-      mFirstLineRule = new CSSFirstLineRule();
-      if (!mFirstLineRule)
-        return NS_ERROR_OUT_OF_MEMORY;
-      NS_ADDREF(mFirstLineRule);
-    }
-    aData->mRuleWalker->Forward(mFirstLineRule);
-  }
-  else if (pseudoTag == nsCSSPseudoElements::firstLetter) {
-    if (!mFirstLetterRule) {
-      mFirstLetterRule = new CSSFirstLetterRule();
-      if (!mFirstLetterRule)
-        return NS_ERROR_OUT_OF_MEMORY;
-      NS_ADDREF(mFirstLetterRule);
-    }
-    aData->mRuleWalker->Forward(mFirstLetterRule);
-  } 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLCSSStyleSheetImpl::Init(nsIURI* aURL, nsIDocument* aDocument)
 {
   NS_PRECONDITION(aURL && aDocument, "null ptr");
   if (! aURL || ! aDocument)
@@ -513,18 +200,16 @@ HTMLCSSStyleSheetImpl::MediumFeaturesCha
 
 NS_IMETHODIMP 
 HTMLCSSStyleSheetImpl::Reset(nsIURI* aURL)
 {
   NS_IF_RELEASE(mURL);
   mURL = aURL;
   NS_ADDREF(mURL);
 
-  NS_IF_RELEASE(mFirstLineRule);
-  NS_IF_RELEASE(mFirstLetterRule);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLCSSStyleSheetImpl::GetSheetURI(nsIURI** aSheetURL) const
 {
   NS_IF_ADDREF(mURL);
   *aSheetURL = mURL;
@@ -551,18 +236,18 @@ HTMLCSSStyleSheetImpl::GetType(nsString&
 {
   aType.AssignLiteral("text/html");
   return NS_OK;
 }
 
 NS_IMETHODIMP_(PRBool)
 HTMLCSSStyleSheetImpl::HasRules() const
 {
-  return PR_TRUE;  // We always have rules, since mFirstLineRule and
-                   // mFirstLetterRule are created on request.
+  // Say we always have rules, since we don't know.
+  return PR_TRUE;
 }
 
 NS_IMETHODIMP
 HTMLCSSStyleSheetImpl::GetApplicable(PRBool& aApplicable) const
 {
   aApplicable = PR_TRUE;
   return NS_OK;
 }
diff --git a/layout/style/nsIHTMLCSSStyleSheet.h b/layout/style/nsIHTMLCSSStyleSheet.h
--- a/layout/style/nsIHTMLCSSStyleSheet.h
+++ b/layout/style/nsIHTMLCSSStyleSheet.h
@@ -32,17 +32,16 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /*
  * style sheet and style rule processor representing style attributes
- * and some additional overrides
  */
 
 #ifndef nsIHTMLCSSStyleSheet_h___
 #define nsIHTMLCSSStyleSheet_h___
 
 #include "nsIStyleSheet.h"
 
 // IID for the nsIHTMLCSSStyleSheet interface {b5cc4ac0-eab6-11d1-8031-006008159b5a}
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -797,17 +797,17 @@ nsRuleNode::PropagateDependentBit(PRUint
  * sharing can be used for the data on this rule node.  MORE HERE...
  */
 
 /* the information for a property (or in some cases, a rect group of
    properties) */
 
 struct PropertyCheckData {
   size_t offset;
-  nsCSSType type;
+  nsCSSProperty id;
 };
 
 /*
  * a callback function that that can revise the result of
  * CheckSpecifiedProperties before finishing; aResult is the current
  * result, and it returns the revised one.
  */
 typedef nsRuleNode::RuleDetail
@@ -924,180 +924,161 @@ CheckColorCallback(const nsRuleDataStruc
   return aResult;
 }
 
 
 // for nsCSSPropList.h, so we get information on things in the style
 // structs but not nsCSS*
 #define CSS_PROP_INCLUDE_NOT_CSS
 
+#define CHECK_DATA_FOR_PROPERTY(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
+  { offsetof(nsRuleData##datastruct_, member_), eCSSProperty_##id_ },
+
 static const PropertyCheckData FontCheckProperties[] = {
-#define CSS_PROP_FONT(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_FONT CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_FONT
 };
 
 static const PropertyCheckData DisplayCheckProperties[] = {
-#define CSS_PROP_DISPLAY(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_DISPLAY CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_DISPLAY
 };
 
 static const PropertyCheckData VisibilityCheckProperties[] = {
-#define CSS_PROP_VISIBILITY(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_VISIBILITY CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_VISIBILITY
 };
 
 static const PropertyCheckData MarginCheckProperties[] = {
-#define CSS_PROP_MARGIN(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_MARGIN CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_MARGIN
 };
 
 static const PropertyCheckData BorderCheckProperties[] = {
-#define CSS_PROP_BORDER(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_BORDER CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_BORDER
 };
 
 static const PropertyCheckData PaddingCheckProperties[] = {
-#define CSS_PROP_PADDING(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_PADDING CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_PADDING
 };
 
 static const PropertyCheckData OutlineCheckProperties[] = {
-#define CSS_PROP_OUTLINE(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_OUTLINE CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_OUTLINE
 };
 
 static const PropertyCheckData ListCheckProperties[] = {
-#define CSS_PROP_LIST(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_LIST CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_LIST
 };
 
 static const PropertyCheckData ColorCheckProperties[] = {
-#define CSS_PROP_COLOR(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_COLOR CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_COLOR
 };
 
 static const PropertyCheckData BackgroundCheckProperties[] = {
-#define CSS_PROP_BACKGROUND(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_BACKGROUND CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_BACKGROUND
 };
 
 static const PropertyCheckData PositionCheckProperties[] = {
-#define CSS_PROP_POSITION(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_POSITION CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_POSITION
 };
 
 static const PropertyCheckData TableCheckProperties[] = {
-#define CSS_PROP_TABLE(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_TABLE CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_TABLE
 };
 
 static const PropertyCheckData TableBorderCheckProperties[] = {
-#define CSS_PROP_TABLEBORDER(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_TABLEBORDER CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_TABLEBORDER
 };
 
 static const PropertyCheckData ContentCheckProperties[] = {
-#define CSS_PROP_CONTENT(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_CONTENT CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_CONTENT
 };
 
 static const PropertyCheckData QuotesCheckProperties[] = {
-#define CSS_PROP_QUOTES(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_QUOTES CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_QUOTES
 };
 
 static const PropertyCheckData TextCheckProperties[] = {
-#define CSS_PROP_TEXT(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_TEXT CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_TEXT
 };
 
 static const PropertyCheckData TextResetCheckProperties[] = {
-#define CSS_PROP_TEXTRESET(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_TEXTRESET CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_TEXTRESET
 };
 
 static const PropertyCheckData UserInterfaceCheckProperties[] = {
-#define CSS_PROP_USERINTERFACE(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_USERINTERFACE CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_USERINTERFACE
 };
 
 static const PropertyCheckData UIResetCheckProperties[] = {
-#define CSS_PROP_UIRESET(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_UIRESET CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_UIRESET
 };
 
 static const PropertyCheckData XULCheckProperties[] = {
-#define CSS_PROP_XUL(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_XUL CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_XUL
 };
 
 #ifdef MOZ_SVG
 static const PropertyCheckData SVGCheckProperties[] = {
-#define CSS_PROP_SVG(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_SVG CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_SVG
 };
 
 static const PropertyCheckData SVGResetCheckProperties[] = {
-#define CSS_PROP_SVGRESET(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_SVGRESET CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_SVGRESET
 };  
 #endif
 
 static const PropertyCheckData ColumnCheckProperties[] = {
-#define CSS_PROP_COLUMN(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
-  { offsetof(nsRuleData##datastruct_, member_), type_ },
+#define CSS_PROP_COLUMN CHECK_DATA_FOR_PROPERTY
 #include "nsCSSPropList.h"
 #undef CSS_PROP_COLUMN
 };
 
 #undef CSS_PROP_INCLUDE_NOT_CSS
+#undef CHECK_DATA_FOR_PROPERTY
   
 static const StructCheckData gCheckProperties[] = {
 
 #define STYLE_STRUCT(name, checkdata_cb, ctor_args) \
   {name##CheckProperties, \
    sizeof(name##CheckProperties)/sizeof(PropertyCheckData), \
    checkdata_cb},
 #include "nsStyleStructList.h"
@@ -1105,49 +1086,77 @@ static const StructCheckData gCheckPrope
   {nsnull, 0, nsnull}
 
 };
 
 
 
 // XXXldb Taking the address of a reference is evil.
 
+inline nsCSSValue&
+ValueAtOffset(nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
+{
+  return * reinterpret_cast<nsCSSValue*>
+                           (reinterpret_cast<char*>(&aRuleDataStruct) + aOffset);
+}
+
 inline const nsCSSValue&
 ValueAtOffset(const nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
 {
   return * reinterpret_cast<const nsCSSValue*>
                            (reinterpret_cast<const char*>(&aRuleDataStruct) + aOffset);
 }
 
+inline nsCSSRect*
+RectAtOffset(nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
+{
+  return reinterpret_cast<nsCSSRect*>
+                         (reinterpret_cast<char*>(&aRuleDataStruct) + aOffset);
+}
+
 inline const nsCSSRect*
 RectAtOffset(const nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
 {
   return reinterpret_cast<const nsCSSRect*>
                          (reinterpret_cast<const char*>(&aRuleDataStruct) + aOffset);
 }
 
+inline nsCSSValuePair*
+ValuePairAtOffset(nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
+{
+  return reinterpret_cast<nsCSSValuePair*>
+                         (reinterpret_cast<char*>(&aRuleDataStruct) + aOffset);
+}
+
 inline const nsCSSValuePair*
 ValuePairAtOffset(const nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
 {
   return reinterpret_cast<const nsCSSValuePair*>
                          (reinterpret_cast<const char*>(&aRuleDataStruct) + aOffset);
 }
 
+inline nsCSSValueList*&
+ValueListAtOffset(nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
+{
+  return * reinterpret_cast<nsCSSValueList**>
+                           (reinterpret_cast<char*>(&aRuleDataStruct) + aOffset);
+}
+
 inline const nsCSSValueList*
 ValueListAtOffset(const nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
 {
   return * reinterpret_cast<const nsCSSValueList*const*>
                            (reinterpret_cast<const char*>(&aRuleDataStruct) + aOffset);
 }
 
-inline const nsCSSValueList**
-ValueListArrayAtOffset(const nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
-{
-  return * reinterpret_cast<const nsCSSValueList**const*>
-                           (reinterpret_cast<const char*>(&aRuleDataStruct) + aOffset);
+inline nsCSSValuePairList*&
+ValuePairListAtOffset(nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
+{
+  return * reinterpret_cast<nsCSSValuePairList**>
+                           (reinterpret_cast<char*>(&aRuleDataStruct) + aOffset);
 }
 
 inline const nsCSSValuePairList*
 ValuePairListAtOffset(const nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
 {
   return * reinterpret_cast<const nsCSSValuePairList*const*>
                            (reinterpret_cast<const char*>(&aRuleDataStruct) + aOffset);
 }
@@ -1173,17 +1182,17 @@ nsRuleNode::CheckSpecifiedProperties(con
            specified = 0,  // number that were specified for this node
            inherited = 0;  // number that were 'inherit' (and not
                            //   eCSSUnit_Inherit) for this node
 
   for (const PropertyCheckData *prop = structData->props,
                            *prop_end = prop + structData->nprops;
        prop != prop_end;
        ++prop)
-    switch (prop->type) {
+    switch (nsCSSProps::kTypeTable[prop->id]) {
 
       case eCSSType_Value:
         ++total;
         ExamineCSSValue(ValueAtOffset(aRuleDataStruct, prop->offset),
                         specified, inherited);
         break;
 
       case eCSSType_Rect:
@@ -1210,21 +1219,21 @@ nsRuleNode::CheckSpecifiedProperties(con
             }
           }
         }
         break;
 
       case eCSSType_ValuePairList:
         {
           ++total;
-          const nsCSSValuePairList* quotes =
+          const nsCSSValuePairList* valuePairList =
               ValuePairListAtOffset(aRuleDataStruct, prop->offset);
-          if (quotes) {
+          if (valuePairList) {
             ++specified;
-            if (eCSSUnit_Inherit == quotes->mXValue.GetUnit()) {
+            if (eCSSUnit_Inherit == valuePairList->mXValue.GetUnit()) {
               ++inherited;
             }
           }
         }
         break;
 
       default:
         NS_NOTREACHED("unknown type");
@@ -1544,16 +1553,73 @@ nsRuleNode::GetSVGResetData(nsStyleConte
   nsRuleDataSVG svgData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(SVGReset), mPresContext, aContext);
   ruleData.mSVGData = &svgData;
 
   return WalkRuleTree(eStyleStruct_SVGReset, aContext, &ruleData, &svgData);
 }
 #endif
 
+// If we need to restrict which properties apply to the style context,
+// return the bit to check in nsCSSProp's flags table.  Otherwise,
+// return 0.
+inline PRUint32
+GetPseudoRestriction(nsStyleContext *aContext)
+{
+  PRUint32 pseudoRestriction = 0;
+  nsIAtom *pseudoType = aContext->GetPseudoType();
+  if (pseudoType) {
+    if (pseudoType == nsCSSPseudoElements::firstLetter) {
+      pseudoRestriction = CSS_PROPERTY_APPLIES_TO_FIRST_LETTER;
+    } else if (pseudoType == nsCSSPseudoElements::firstLine) {
+      pseudoRestriction = CSS_PROPERTY_APPLIES_TO_FIRST_LINE;
+    }
+  }
+  return pseudoRestriction;
+}
+
+static void
+UnsetPropertiesWithoutFlags(const nsStyleStructID aSID,
+                            nsRuleDataStruct& aRuleDataStruct,
+                            PRUint32 aFlags)
+{
+  NS_ASSERTION(aFlag != 0, "aFlags must be nonzero");
+  const StructCheckData *structData = gCheckProperties + aSID;
+
+  for (const PropertyCheckData *prop = structData->props,
+                           *prop_end = prop + structData->nprops;
+       prop != prop_end;
+       ++prop) {
+    if (nsCSSProps::PropHasFlags(prop->id, aFlags))
+      // Don't unset the property.
+      continue;
+
+    switch (nsCSSProps::kTypeTable[prop->id]) {
+      case eCSSType_Value:
+        ValueAtOffset(aRuleDataStruct, prop->offset).Reset();
+        break;
+      case eCSSType_Rect:
+        RectAtOffset(aRuleDataStruct, prop->offset).Reset();
+        break;
+      case eCSSType_ValuePair:
+        ValuePairAtOffset(aRuleDataStruct, prop->offset).Reset();
+        break;
+      case eCSSType_ValueList:
+        ValueListAtOffset(aRuleDataStruct, prop->offset) = nsnull;
+        break;
+      case eCSSType_ValuePairList:
+        ValuePairListAtOffset(aRuleDataStruct, prop->offset) = nsnull;
+        break;
+      default:
+        NS_NOTREACHED("unknown type");
+        break;
+    }
+  }
+}
+
 const void*
 nsRuleNode::WalkRuleTree(const nsStyleStructID aSID,
                          nsStyleContext* aContext, 
                          nsRuleData* aRuleData,
                          nsRuleDataStruct* aSpecificData)
 {
   // We start at the most specific rule in the tree.  
   void* startStruct = nsnull;
@@ -1619,16 +1685,26 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
         detail == eRuleFullMixed ||
         detail == eRuleFullInherited)
       break; // We don't need to examine any more rules.  All properties
              // have been fully specified.
 
     // Climb up to the next rule in the tree (a less specific rule).
     rootNode = ruleNode;
     ruleNode = ruleNode->mParent;
+  }
+
+  // A bit in nsCSSProps's flags that has to be present for this
+  // property to apply.
+  PRUint32 pseudoRestriction = GetPseudoRestriction(aContext);
+  if (pseudoRestriction) {
+    UnsetPropertiesWithoutFlags(aSID, *aSpecificData, pseudoRestriction);
+
+    // Recompute |detail| based on the restrictions we just applied.
+    detail = CheckSpecifiedProperties(aSID, *aSpecificData);
   }
 
   NS_ASSERTION(!startStruct || (detail != eRuleFullReset &&
                                 detail != eRuleFullMixed &&
                                 detail != eRuleFullInherited),
                "can't have start struct and be fully specified");
 
   PRBool isReset = nsCachedStyleData::IsReset(aSID);
