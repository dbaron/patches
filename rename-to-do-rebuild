From: L. David Baron <dbaron@dbaron.org>

Bug 1115812 patch 6 - Rename mRebuildAllStyleData to mDoRebuildAllStyleData.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -59,17 +59,17 @@ FrameTagToString(const nsIFrame* aFrame)
   nsCString result;
   aFrame->ListTag(result);
   return result;
 }
 #endif
 
 RestyleManager::RestyleManager(nsPresContext* aPresContext)
   : mPresContext(aPresContext)
-  , mRebuildAllStyleData(false)
+  , mDoRebuildAllStyleData(false)
   , mObservingRefreshDriver(false)
   , mInStyleRefresh(false)
   , mSkipAnimationRules(false)
   , mPostAnimationRestyles(false)
   , mIsProcessingAnimationStyleChange(false)
   , mHoverGeneration(0)
   , mLastUpdateForThrottledAnimations(aPresContext->RefreshDriver()->
                                         MostRecentRefresh())
@@ -1473,17 +1473,17 @@ RestyleManager::RestyleForRemove(Element
 void
 RestyleManager::RebuildAllStyleData(nsChangeHint aExtraHint,
                                     nsRestyleHint aRestyleHint)
 {
   NS_ASSERTION(!(aExtraHint & nsChangeHint_ReconstructFrame),
                "Should not reconstruct the root of the frame tree.  "
                "Use ReconstructDocElementHierarchy instead.");
 
-  mRebuildAllStyleData = false;
+  mDoRebuildAllStyleData = false;
 
   nsIPresShell* presShell = mPresContext->GetPresShell();
   if (!presShell || !presShell->GetRootFrame())
     return;
 
   // Make sure that the viewmanager will outlive the presshell
   nsRefPtr<nsViewManager> vm = presShell->GetViewManager();
 
@@ -1498,30 +1498,30 @@ RestyleManager::RebuildAllStyleData(nsCh
   nsAutoScriptBlocker scriptBlocker;
 
   // Until we get rid of these phases in bug 960465, we need to add
   // eRestyle_ChangeAnimationPhaseDescendants so that we actually honor
   // animation phase booleans in all cases.
   aRestyleHint |= eRestyle_ChangeAnimationPhaseDescendants;
 
   mPendingRestyles.AddPendingRestyleToRoot(aRestyleHint, aExtraHint);
-  mRebuildAllStyleData = true;
+  mDoRebuildAllStyleData = true;
 
   ProcessPendingRestyles();
 }
 
 void
 RestyleManager::ProcessPendingRestyles()
 {
   NS_PRECONDITION(mPresContext->Document(), "No document?  Pshaw!");
   NS_PRECONDITION(!nsContentUtils::IsSafeToRunScript(),
                   "Missing a script blocker!");
 
-  bool rebuildAllStyleData = mRebuildAllStyleData;
-  mRebuildAllStyleData = false;
+  bool rebuildAllStyleData = mDoRebuildAllStyleData;
+  mDoRebuildAllStyleData = false;
 
   // First do any queued-up frame creation.  (We should really
   // merge this into the rest of the process, though; see bug 827239.)
   mPresContext->FrameConstructor()->CreateNeededFrames();
 
   // Process non-animation restyles...
   NS_ABORT_IF_FALSE(!mIsProcessingRestyles,
                     "Nesting calls to ProcessPendingRestyles?");
@@ -1603,17 +1603,17 @@ RestyleManager::ProcessPendingRestyles()
 
 #ifdef DEBUG
   mIsProcessingRestyles = false;
 #endif
   NS_POSTCONDITION(mPendingRestyles.Count() == oldPendingRestyleCount,
                    "We should not have posted new non-animation restyles while "
                    "processing animation restyles");
 
-  if (mRebuildAllStyleData) {
+  if (mDoRebuildAllStyleData) {
     // We probably wasted a lot of work up above, but this seems safest
     // and it should be rarely used.
     // This might add us as a refresh observer again; that's ok.
     RebuildAllStyleData(nsChangeHint(0), nsRestyleHint(0));
   }
 }
 
 void
@@ -1716,17 +1716,17 @@ RestyleManager::PostRestyleEventInternal
 void
 RestyleManager::PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint,
                                              nsRestyleHint aRestyleHint)
 {
   NS_ASSERTION(!(aExtraHint & nsChangeHint_ReconstructFrame),
                "Should not reconstruct the root of the frame tree.  "
                "Use ReconstructDocElementHierarchy instead.");
 
-  mRebuildAllStyleData = true;
+  mDoRebuildAllStyleData = true;
 
   if (aExtraHint || aRestyleHint) {
     mPendingRestyles.AddPendingRestyleToRoot(aRestyleHint, aExtraHint);
   }
 
   // Get a restyle event posted if necessary
   PostRestyleEventInternal(false);
 }
@@ -2565,17 +2565,17 @@ ElementRestyler::Restyle(nsRestyleHint a
   // restyle.  Before we return from this function, we call
   // RestyleTracker::AddRestyleRootsIfAwaitingRestyle to ensure they get
   // restyled in RestyleTracker::DoProcessRestyles.
   nsTArray<nsRefPtr<Element>> descendants;
 
   nsRestyleHint hintToRestore = nsRestyleHint(0);
   if (mContent && mContent->IsElement() &&
       // If we're we're resolving from the root of the frame tree (which
-      // we do when mRebuildAllStyleData), we need to avoid getting the
+      // we do when mDoRebuildAllStyleData), we need to avoid getting the
       // root's restyle data until we get to its primary frame, since
       // it's the primary frame that has the styles for the root element
       // (rather than the ancestors of the primary frame whose mContent
       // is the root node but which have different styles).  If we use
       // up the hint for one of the ancestors that we hit first, then
       // we'll fail to do the restyling we need to do.
       (mContent->GetParent() || mContent->GetPrimaryFrame() == mFrame)) {
     mContent->OwnerDoc()->FlushPendingLinkUpdates();
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -457,17 +457,17 @@ private:
   // Returns true if this function managed to successfully move a frame, and
   // false if it could not process the position change, and a reflow should
   // be performed instead.
   bool RecomputePosition(nsIFrame* aFrame);
 
 private:
   nsPresContext* mPresContext; // weak, disconnected in Disconnect
 
-  bool mRebuildAllStyleData : 1;
+  bool mDoRebuildAllStyleData : 1;
   // True if we're already waiting for a refresh notification
   bool mObservingRefreshDriver : 1;
   // True if we're in the middle of a nsRefreshDriver refresh
   bool mInStyleRefresh : 1;
   // Whether rule matching should skip styles associated with animation
   bool mSkipAnimationRules : 1;
   // Whether rule matching should post animation restyles when it skips
   // styles associated with animation.  Only true when
