From: L. David Baron <dbaron@dbaron.org>

Bug 1115812 patch 6 - Rename mRebuildAllStyleData to mDoRebuildAllStyleData.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -59,17 +59,17 @@ FrameTagToString(const nsIFrame* aFrame)
   nsCString result;
   aFrame->ListTag(result);
   return result;
 }
 #endif
 
 RestyleManager::RestyleManager(nsPresContext* aPresContext)
   : mPresContext(aPresContext)
-  , mRebuildAllStyleData(false)
+  , mDoRebuildAllStyleData(false)
   , mObservingRefreshDriver(false)
   , mInStyleRefresh(false)
   , mSkipAnimationRules(false)
   , mPostAnimationRestyles(false)
   , mIsProcessingAnimationStyleChange(false)
   , mHoverGeneration(0)
   , mLastUpdateForThrottledAnimations(aPresContext->RefreshDriver()->
                                         MostRecentRefresh())
@@ -1471,17 +1471,17 @@ RestyleManager::RestyleForRemove(Element
 void
 RestyleManager::RebuildAllStyleData(nsChangeHint aExtraHint,
                                     nsRestyleHint aRestyleHint)
 {
   NS_ASSERTION(!(aExtraHint & nsChangeHint_ReconstructFrame),
                "Should not reconstruct the root of the frame tree.  "
                "Use ReconstructDocElementHierarchy instead.");
 
-  mRebuildAllStyleData = false;
+  mDoRebuildAllStyleData = false;
 
   nsIPresShell* presShell = mPresContext->GetPresShell();
   if (!presShell || !presShell->GetRootFrame())
     return;
 
   // Make sure that the viewmanager will outlive the presshell
   nsRefPtr<nsViewManager> vm = presShell->GetViewManager();
 
@@ -1558,17 +1558,17 @@ RestyleManager::DoRebuildAllStyleData(Re
 
 void
 RestyleManager::ProcessPendingRestyles()
 {
   NS_PRECONDITION(mPresContext->Document(), "No document?  Pshaw!");
   NS_PRECONDITION(!nsContentUtils::IsSafeToRunScript(),
                   "Missing a script blocker!");
 
-  if (mRebuildAllStyleData) {
+  if (mDoRebuildAllStyleData) {
     RebuildAllStyleData(nsChangeHint(0), nsRestyleHint(0));
     MOZ_ASSERT(mPendingRestyles.Count() == 0);
     return;
   }
 
   // First do any queued-up frame creation.  (We should really
   // merge this into the rest of the process, though; see bug 827239.)
   mPresContext->FrameConstructor()->CreateNeededFrames();
@@ -1623,17 +1623,17 @@ RestyleManager::ProcessPendingRestyles()
 
 #ifdef DEBUG
   mIsProcessingRestyles = false;
 #endif
   NS_POSTCONDITION(mPendingRestyles.Count() == oldPendingRestyleCount,
                    "We should not have posted new non-animation restyles while "
                    "processing animation restyles");
 
-  if (mRebuildAllStyleData) {
+  if (mDoRebuildAllStyleData) {
     // We probably wasted a lot of work up above, but this seems safest
     // and it should be rarely used.
     // This might add us as a refresh observer again; that's ok.
     RebuildAllStyleData(nsChangeHint(0), nsRestyleHint(0));
   }
 }
 
 void
@@ -1736,17 +1736,17 @@ RestyleManager::PostRestyleEventInternal
 void
 RestyleManager::PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint,
                                              nsRestyleHint aRestyleHint)
 {
   NS_ASSERTION(!(aExtraHint & nsChangeHint_ReconstructFrame),
                "Should not reconstruct the root of the frame tree.  "
                "Use ReconstructDocElementHierarchy instead.");
 
-  mRebuildAllStyleData = true;
+  mDoRebuildAllStyleData = true;
 
   if (aExtraHint || aRestyleHint) {
     mPendingRestyles.AddPendingRestyleToRoot(aRestyleHint, aExtraHint);
   }
 
   // Get a restyle event posted if necessary
   PostRestyleEventInternal(false);
 }
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -461,17 +461,17 @@ private:
   // Returns true if this function managed to successfully move a frame, and
   // false if it could not process the position change, and a reflow should
   // be performed instead.
   bool RecomputePosition(nsIFrame* aFrame);
 
 private:
   nsPresContext* mPresContext; // weak, disconnected in Disconnect
 
-  bool mRebuildAllStyleData : 1;
+  bool mDoRebuildAllStyleData : 1;
   // True if we're already waiting for a refresh notification
   bool mObservingRefreshDriver : 1;
   // True if we're in the middle of a nsRefreshDriver refresh
   bool mInStyleRefresh : 1;
   // Whether rule matching should skip styles associated with animation
   bool mSkipAnimationRules : 1;
   // Whether rule matching should post animation restyles when it skips
   // styles associated with animation.  Only true when
