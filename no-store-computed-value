From: L. David Baron <dbaron@dbaron.org>

Eliminate nsStyleAnimation::StoreComputedValue.  (Bug 520396)

diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -131,24 +131,32 @@ nsCSSDeclaration::AppendComment(const ns
   return /* NS_ERROR_NOT_IMPLEMENTED, or not any longer that is */ NS_OK;
 }
 
 PRBool nsCSSDeclaration::AppendValueToString(nsCSSProperty aProperty, nsAString& aResult) const
 {
   nsCSSCompressedDataBlock *data = GetValueIsImportant(aProperty)
                                       ? mImportantData : mData;
   const void *storage = data->StorageFor(aProperty);
-  if (storage) {
+  return nsCSSDeclaration::AppendStorageToString(aProperty, storage, aResult);
+}
+
+/* static */ PRBool
+nsCSSDeclaration::AppendStorageToString(nsCSSProperty aProperty,
+                                        const void* aStorage,
+                                        nsAString& aResult)
+{
+  if (aStorage) {
     switch (nsCSSProps::kTypeTable[aProperty]) {
       case eCSSType_Value: {
-        const nsCSSValue *val = static_cast<const nsCSSValue*>(storage);
+        const nsCSSValue *val = static_cast<const nsCSSValue*>(aStorage);
         AppendCSSValueToString(aProperty, *val, aResult);
       } break;
       case eCSSType_Rect: {
-        const nsCSSRect *rect = static_cast<const nsCSSRect*>(storage);
+        const nsCSSRect *rect = static_cast<const nsCSSRect*>(aStorage);
         const nsCSSUnit topUnit = rect->mTop.GetUnit();
         if (topUnit == eCSSUnit_Inherit ||
             topUnit == eCSSUnit_Initial ||
             topUnit == eCSSUnit_RectIsAuto) {
           NS_ASSERTION(rect->mRight.GetUnit() == topUnit &&
                        rect->mBottom.GetUnit() == topUnit &&
                        rect->mLeft.GetUnit() == topUnit,
                        "parser should make all sides have the same unit");
@@ -165,17 +173,17 @@ PRBool nsCSSDeclaration::AppendValueToSt
           aResult.Append(comma);
           AppendCSSValueToString(aProperty, rect->mBottom, aResult);
           aResult.Append(comma);
           AppendCSSValueToString(aProperty, rect->mLeft, aResult);
           aResult.Append(PRUnichar(')'));
         }
       } break;
       case eCSSType_ValuePair: {
-        const nsCSSValuePair *pair = static_cast<const nsCSSValuePair*>(storage);
+        const nsCSSValuePair *pair = static_cast<const nsCSSValuePair*>(aStorage);
         AppendCSSValueToString(aProperty, pair->mXValue, aResult);
         if (pair->mYValue != pair->mXValue ||
             ((aProperty == eCSSProperty_background_position ||
               aProperty == eCSSProperty__moz_transform_origin) &&
              pair->mXValue.GetUnit() != eCSSUnit_Inherit &&
              pair->mXValue.GetUnit() != eCSSUnit_Initial) ||
             (aProperty == eCSSProperty__moz_background_size &&
              pair->mXValue.GetUnit() != eCSSUnit_Inherit &&
@@ -187,31 +195,31 @@ PRBool nsCSSDeclaration::AppendValueToSt
           // than 'initial' or 'inherit', or if it's a -moz-background-size
           // value other than 'initial' or 'inherit' or 'contain' or 'cover'.
           aResult.Append(PRUnichar(' '));
           AppendCSSValueToString(aProperty, pair->mYValue, aResult);
         }
       } break;
       case eCSSType_ValueList: {
         const nsCSSValueList* val =
-            *static_cast<nsCSSValueList*const*>(storage);
+            *static_cast<nsCSSValueList*const*>(aStorage);
         do {
           AppendCSSValueToString(aProperty, val->mValue, aResult);
           val = val->mNext;
           if (val) {
             if (nsCSSProps::PropHasFlags(aProperty,
                                          CSS_PROPERTY_VALUE_LIST_USES_COMMAS))
               aResult.Append(PRUnichar(','));
             aResult.Append(PRUnichar(' '));
           }
         } while (val);
       } break;
       case eCSSType_ValuePairList: {
         const nsCSSValuePairList* item =
-            *static_cast<nsCSSValuePairList*const*>(storage);
+            *static_cast<nsCSSValuePairList*const*>(aStorage);
         do {
           NS_ASSERTION(item->mXValue.GetUnit() != eCSSUnit_Null,
                        "unexpected null unit");
           AppendCSSValueToString(aProperty, item->mXValue, aResult);
           if (item->mXValue.GetUnit() != eCSSUnit_Inherit &&
               item->mXValue.GetUnit() != eCSSUnit_Initial &&
               item->mYValue.GetUnit() != eCSSUnit_Null) {
             aResult.Append(PRUnichar(' '));
@@ -223,17 +231,17 @@ PRBool nsCSSDeclaration::AppendValueToSt
                                          CSS_PROPERTY_VALUE_LIST_USES_COMMAS))
               aResult.Append(PRUnichar(','));
             aResult.Append(PRUnichar(' '));
           }
         } while (item);
       } break;
     }
   }
-  return storage != nsnull;
+  return aStorage != nsnull;
 }
 
 /* static */ PRBool
 nsCSSDeclaration::AppendCSSValueToString(nsCSSProperty aProperty,
                                          const nsCSSValue& aValue,
                                          nsAString& aResult)
 {
   nsCSSUnit unit = aValue.GetUnit();
diff --git a/layout/style/nsCSSDeclaration.h b/layout/style/nsCSSDeclaration.h
--- a/layout/style/nsCSSDeclaration.h
+++ b/layout/style/nsCSSDeclaration.h
@@ -170,16 +170,21 @@ public:
   void List(FILE* out = stdout, PRInt32 aIndent = 0) const;
 #endif
   
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
   static PRBool AppendCSSValueToString(nsCSSProperty aProperty,
                                        const nsCSSValue& aValue,
                                        nsAString& aResult);
 
+  // return whether there was a value in |aStorage| (i.e., it was non-null)
+  static PRBool AppendStorageToString(nsCSSProperty aProperty,
+                                      const void* aStorage,
+                                      nsAString& aResult);
+
 private:
   // Not implemented, and not supported.
   nsCSSDeclaration& operator=(const nsCSSDeclaration& aCopy);
   PRBool operator==(const nsCSSDeclaration& aCopy) const;
 
   static void AppendImportanceToString(PRBool aIsImportant, nsAString& aString);
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
   PRBool   AppendValueToString(nsCSSProperty aProperty, nsAString& aResult) const;
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -396,43 +396,104 @@ nsStyleAnimation::ComputeValue(nsCSSProp
   // Extract computed value of our property from the temporary style rule
   return ExtractComputedValue(aProperty, tmpStyleContext, aComputedValue);
 }
 
 PRBool
 nsStyleAnimation::UncomputeValue(nsCSSProperty aProperty,
                                  nsPresContext* aPresContext,
                                  const nsStyleCoord& aComputedValue,
+                                 void* aSpecifiedValue)
+{
+  NS_ABORT_IF_FALSE(aPresContext, "null pres context");
+
+  switch (aComputedValue.GetUnit()) {
+    case eStyleUnit_None:
+      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
+                          eCSSType_ValuePair, "type mismatch");
+      static_cast<nsCSSValuePair*>(aSpecifiedValue)->
+        SetBothValuesTo(nsCSSValue(eCSSUnit_None));
+      break;
+    case eStyleUnit_Coord: {
+      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
+                        "type mismatch");
+      float pxVal = aPresContext->AppUnitsToFloatCSSPixels(
+                                    aComputedValue.GetCoordValue());
+      static_cast<nsCSSValue*>(aSpecifiedValue)->
+        SetFloatValue(pxVal, eCSSUnit_Pixel);
+      break;
+    }
+    case eStyleUnit_Percent:
+      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
+                        "type mismatch");
+      static_cast<nsCSSValue*>(aSpecifiedValue)->
+        SetPercentValue(aComputedValue.GetPercentValue());
+      break;
+    case eStyleUnit_Color:
+      // colors can be alone, or part of a paint server
+      if (nsCSSProps::kAnimTypeTable[aProperty] == eStyleAnimType_PaintServer) {
+        NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
+                            eCSSType_ValuePair, "type mismatch");
+        nsCSSValue val;
+        val.SetColorValue(aComputedValue.GetColorValue());
+        static_cast<nsCSSValuePair*>(aSpecifiedValue)->
+          SetBothValuesTo(val);
+      } else {
+        NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
+                          "type mismatch");
+        static_cast<nsCSSValue*>(aSpecifiedValue)->
+          SetColorValue(aComputedValue.GetColorValue());
+      }
+      break;
+    default:
+      return PR_FALSE;
+  }
+  return PR_TRUE;
+}
+
+PRBool
+nsStyleAnimation::UncomputeValue(nsCSSProperty aProperty,
+                                 nsPresContext* aPresContext,
+                                 const nsStyleCoord& aComputedValue,
                                  nsAString& aSpecifiedValue)
 {
   NS_ABORT_IF_FALSE(aPresContext, "null pres context");
   aSpecifiedValue.Truncate(); // Clear outparam, if it's not already empty
 
-  nsCSSValue value;
-  switch (aComputedValue.GetUnit()) {
-    case eStyleUnit_None:
-      value.SetNoneValue();
+  nsCSSValuePair vp;
+  nsCSSRect rect;
+  void *ptr = nsnull;
+  void *storage;
+  switch (nsCSSProps::kTypeTable[aProperty]) {
+    case eCSSType_Value:
+      storage = &vp.mXValue;
       break;
-    case eStyleUnit_Coord: {
-      float pxVal = aPresContext->AppUnitsToFloatCSSPixels(
-                                    aComputedValue.GetCoordValue());
-      value.SetFloatValue(pxVal, eCSSUnit_Pixel);
+    case eCSSType_Rect:
+      storage = &rect;
       break;
-    }
-    case eStyleUnit_Percent:
-      value.SetPercentValue(aComputedValue.GetPercentValue());
+    case eCSSType_ValuePair: 
+      storage = &vp;
       break;
-    case eStyleUnit_Color:
-      value.SetColorValue(aComputedValue.GetColorValue());
+    case eCSSType_ValueList:
+    case eCSSType_ValuePairList:
+      storage = &ptr;
       break;
     default:
-      return PR_FALSE;
+      NS_ABORT_IF_FALSE(PR_FALSE, "unexpected case");
+      storage = nsnull;
+      break;
   }
-  return nsCSSDeclaration::AppendCSSValueToString(aProperty, value,
-                                                  aSpecifiedValue);
+
+  nsCSSValue value;
+  if (!nsStyleAnimation::UncomputeValue(aProperty, aPresContext,
+                                        aComputedValue, storage)) {
+    return PR_FALSE;
+  }
+  return nsCSSDeclaration::AppendStorageToString(aProperty, storage,
+                                                 aSpecifiedValue);
 }
 
 inline const void*
 StyleDataAtOffset(const void* aStyleStruct, ptrdiff_t aOffset)
 {
   return reinterpret_cast<const char*>(aStyleStruct) + aOffset;
 }
 
@@ -497,84 +558,8 @@ nsStyleAnimation::ExtractComputedValue(n
       }
       return PR_FALSE;
     }
     case eStyleAnimType_None:
       NS_NOTREACHED("shouldn't use on non-animatable properties");
   }
   return PR_FALSE;
 }
-
-PRBool
-nsStyleAnimation::StoreComputedValue(nsCSSProperty aProperty,
-                                     nsPresContext* aPresContext,
-                                     void* aStyleStruct,
-                                     const nsStyleCoord& aComputedValue)
-{
-  NS_ABORT_IF_FALSE(0 <= aProperty &&
-                    aProperty < eCSSProperty_COUNT_no_shorthands,
-                    "bad property");
-  ptrdiff_t ssOffset = nsCSSProps::kStyleStructOffsetTable[aProperty];
-  NS_ABORT_IF_FALSE(0 <= ssOffset, "must be dealing with animatable property");
-  nsStyleAnimType animType = nsCSSProps::kAnimTypeTable[aProperty];
-  switch (animType) {
-    case eStyleAnimType_Coord:
-      *static_cast<nsStyleCoord*>(StyleDataAtOffset(aStyleStruct, ssOffset)) =
-        aComputedValue;
-      return PR_TRUE;
-    case eStyleAnimType_Sides_Top:
-    case eStyleAnimType_Sides_Right:
-    case eStyleAnimType_Sides_Bottom:
-    case eStyleAnimType_Sides_Left: {
-      PR_STATIC_ASSERT(0 == NS_SIDE_TOP);
-      PR_STATIC_ASSERT(eStyleAnimType_Sides_Right - eStyleAnimType_Sides_Top
-                         == NS_SIDE_RIGHT);
-      PR_STATIC_ASSERT(eStyleAnimType_Sides_Bottom - eStyleAnimType_Sides_Top
-                         == NS_SIDE_BOTTOM);
-      PR_STATIC_ASSERT(eStyleAnimType_Sides_Left - eStyleAnimType_Sides_Top
-                         == NS_SIDE_LEFT);
-      static_cast<nsStyleSides*>(StyleDataAtOffset(aStyleStruct, ssOffset))->
-          Set(animType - eStyleAnimType_Sides_Top, aComputedValue);
-
-       nsStyleStructID sid = nsCSSProps::kSIDTable[aProperty];
-       if (sid == eStyleStruct_Margin) {
-         static_cast<nsStyleMargin*>(aStyleStruct)->RecalcData();
-       } else if (sid == eStyleStruct_Padding) {
-         static_cast<nsStylePadding*>(aStyleStruct)->RecalcData();
-       }
-      return PR_TRUE;
-    }
-    case eStyleAnimType_nscoord:
-      *static_cast<nscoord*>(StyleDataAtOffset(aStyleStruct, ssOffset)) =
-        aComputedValue.GetCoordValue();
-      if (aProperty == eCSSProperty_font) {
-        nsStyleFont *font = static_cast<nsStyleFont*>(aStyleStruct);
-        if (!aPresContext->IsChrome()) {
-          nscoord minimumFontSize =
-            aPresContext->GetCachedIntPref(kPresContext_MinimumFontSize);
-          font->mFont.size = NS_MAX(font->mSize, minimumFontSize);
-        } else {
-          font->mFont.size = font->mSize;
-        }
-      }
-      return PR_TRUE;
-    case eStyleAnimType_Color:
-      *static_cast<nscolor*>(StyleDataAtOffset(aStyleStruct, ssOffset)) =
-        aComputedValue.GetColorValue();
-      return PR_TRUE;
-    case eStyleAnimType_PaintServer: {
-      nsStyleSVGPaint &paint = *static_cast<nsStyleSVGPaint*>(
-        StyleDataAtOffset(aStyleStruct, ssOffset));
-      if (aComputedValue.GetUnit() == eStyleUnit_Color) {
-        paint.SetType(eStyleSVGPaintType_Color);
-        paint.mPaint.mColor = aComputedValue.GetColorValue();
-      } else {
-        NS_ASSERTION(aComputedValue.GetUnit() == eStyleUnit_None,
-                     "unexpected unit");
-        paint.SetType(eStyleSVGPaintType_None);
-      }
-      return PR_TRUE;
-    }
-    case eStyleAnimType_None:
-      NS_NOTREACHED("shouldn't use on non-animatable properties");
-  }
-  return PR_FALSE;
-}
diff --git a/layout/style/nsStyleAnimation.h b/layout/style/nsStyleAnimation.h
--- a/layout/style/nsStyleAnimation.h
+++ b/layout/style/nsStyleAnimation.h
@@ -136,53 +136,48 @@ public:
    * @return PR_TRUE on success, PR_FALSE on failure.
    */
   static PRBool ComputeValue(nsCSSProperty aProperty,
                              nsIContent* aElement,
                              const nsAString& aSpecifiedValue,
                              nsStyleCoord& aComputedValue);
 
   /**
-   * Creates a specified value (nsAString) for the given computed value
+   * Creates a specified value for the given computed value
    * (nsStyleCoord).
    *
+   * The first form fills in one of the nsCSSType types into the void*;
+   * for some types this means that the void* is pointing to memory
+   * owned by the nsStyleCoord.  (For all complex types, the
+   * nsStyleCoord owns the necessary objects so that the caller does not
+   * need to do anything to free them.)
+   *
    * @param aProperty      The property whose value we're uncomputing.
    * @param aPresContext   The presentation context for the document in
    *                       which we're working.
    * @param aComputedValue The computed value to be converted.
    * @param [out] aSpecifiedValue The resulting specified value.
    * @return PR_TRUE on success, PR_FALSE on failure.
    */
   static PRBool UncomputeValue(nsCSSProperty aProperty,
                                nsPresContext* aPresContext,
                                const nsStyleCoord& aComputedValue,
+                               void* aSpecifiedValue);
+  static PRBool UncomputeValue(nsCSSProperty aProperty,
+                               nsPresContext* aPresContext,
+                               const nsStyleCoord& aComputedValue,
                                nsAString& aSpecifiedValue);
 
   /**
    * Gets the computed value for the given property from the given style
    * context.
    *
    * @param aProperty     The property whose value we're looking up.
    * @param aStyleContext The style context to check for the computed value.
    * @param [out] aComputedValue The resulting computed value.
    * @return PR_TRUE on success, PR_FALSE on failure.
    */
   static PRBool ExtractComputedValue(nsCSSProperty aProperty,
                                      nsStyleContext* aStyleContext,
                                      nsStyleCoord& aComputedValue);
-
-  /**
-   * Sets the computed value for the given property in the given style
-   * struct.
-   *
-   * @param aProperty      The property whose value we're setting.
-   * @param aPresContext   The pres context associated with aStyleStruct.
-   * @param aStyleStruct   The style struct in which to set the value.
-   * @param aComputedValue The computed value.
-   * @return  PR_TRUE on success, PR_FALSE on failure.
-   */
-  static PRBool StoreComputedValue(nsCSSProperty aProperty,
-                                   nsPresContext* aPresContext,
-                                   void* aStyleStruct,
-                                   const nsStyleCoord& aComputedValue);
 };
 
 #endif
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -47,16 +47,17 @@
 #include "nsIStyleRule.h"
 #include "nsRuleWalker.h"
 #include "nsRuleData.h"
 #include "nsSMILKeySpline.h"
 #include "gfxColor.h"
 #include "nsCSSPseudoElements.h"
 #include "nsCSSPropertySet.h"
 #include "nsStyleAnimation.h"
+#include "nsCSSDataBlock.h"
 
 using mozilla::TimeStamp;
 using mozilla::TimeDuration;
 
 /*****************************************************************************
  * Per-Element data                                                          *
  *****************************************************************************/
 
@@ -129,19 +130,16 @@ public:
 
   NS_HIDDEN_(void) CoverValue(nsCSSProperty aProperty,
                               nsStyleCoord &aStartValue)
   {
     CoveredValue v = { aProperty, aStartValue };
     mCoveredValues.AppendElement(v);
   }
 
-  NS_HIDDEN_(void)
-    FillStyleStruct(void* aStyleStruct, nsRuleData* aRuleData) const;
-
   struct CoveredValue {
     nsCSSProperty mProperty;
     nsStyleCoord mCoveredValue;
   };
 
 private:
   nsTArray<CoveredValue> mCoveredValues;
 };
@@ -196,58 +194,16 @@ ElementTransitionsPropertyDtor(void     
                                void           *aData)
 {
   ElementTransitions *et = static_cast<ElementTransitions*>(aPropertyValue);
   delete et;
 }
 
 NS_IMPL_ISUPPORTS1(ElementTransitionsStyleRule, nsIStyleRule)
 
-static void
-ElementTransitionsPostResolveCallback(void* aStyleStruct, nsRuleData* aRuleData,
-                                      nsIStyleRule* aRule)
-{
-  ElementTransitionsStyleRule *rule =
-    static_cast<ElementTransitionsStyleRule*>(aRule);
-  ElementTransitions *et = rule->ElementData();
-  for (PRUint32 i = 0, i_end = et->mPropertyTransitions.Length();
-       i < i_end; ++i)
-  {
-    const ElementPropertyTransition &pt = et->mPropertyTransitions[i];
-    if (aRuleData->mSIDs & nsCachedStyleData::GetBitForSID(
-                             nsCSSProps::kSIDTable[pt.mProperty]))
-    {
-      double timePortion =
-        (rule->RefreshTime() - pt.mStartTime).ToSeconds() /
-        pt.mDuration.ToSeconds();
-      if (timePortion < 0.0)
-        timePortion = 0.0; // use start value during transition-delay
-      if (timePortion > 1.0)
-        timePortion = 1.0; // we might be behind on flushing
-
-      double valuePortion =
-        pt.mTimingFunction.GetSplineValue(timePortion);
-      nsStyleCoord value;
-#ifdef DEBUG
-      PRBool ok =
-#endif
-        nsStyleAnimation::Interpolate(pt.mStartValue, pt.mEndValue,
-                                      valuePortion, value);
-      NS_ABORT_IF_FALSE(ok, "could not interpolate values");
-#ifdef DEBUG
-      ok =
-#endif
-        nsStyleAnimation::StoreComputedValue(pt.mProperty,
-                                             aRuleData->mPresContext,
-                                             aStyleStruct, value);
-      NS_ABORT_IF_FALSE(ok, "could not store computed value");
-    }
-  }
-}
-
 NS_IMETHODIMP
 ElementTransitionsStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   nsStyleContext *contextParent = aRuleData->mStyleContext->GetParent();
   if (contextParent && contextParent->HasPseudoElementData()) {
     // Don't apply transitions to things inside of pseudo-elements.
     // FIXME: Add tests for this.
     return NS_OK;
@@ -257,25 +213,41 @@ ElementTransitionsStyleRule::MapRuleInfo
   NS_ENSURE_TRUE(et, NS_OK); // FIXME: Why can this be null?
   for (PRUint32 i = 0, i_end = et->mPropertyTransitions.Length();
        i < i_end; ++i)
   {
     ElementPropertyTransition &pt = et->mPropertyTransitions[i];
     if (aRuleData->mSIDs & nsCachedStyleData::GetBitForSID(
                              nsCSSProps::kSIDTable[pt.mProperty]))
     {
-      nsPostResolveCallback prc =
-        { &ElementTransitionsPostResolveCallback, this };
-      aRuleData->mPostResolveCallbacks.AppendElement(prc);
-      // This really doesn't matter much, since this ought to be
-      // the only node with the rule, but it's good practice for
-      // post-resolve callbacks.
-      aRuleData->mCanStoreInRuleTree = PR_FALSE;
+      double timePortion =
+        (RefreshTime() - pt.mStartTime).ToSeconds() / pt.mDuration.ToSeconds();
+      if (timePortion < 0.0)
+        timePortion = 0.0; // use start value during transition-delay
+      if (timePortion > 1.0)
+        timePortion = 1.0; // we might be behind on flushing
 
-      return NS_OK;
+      double valuePortion =
+        pt.mTimingFunction.GetSplineValue(timePortion);
+      nsStyleCoord value;
+#ifdef DEBUG
+      PRBool ok =
+#endif
+        nsStyleAnimation::Interpolate(pt.mStartValue, pt.mEndValue,
+                                      valuePortion, value);
+      NS_ABORT_IF_FALSE(ok, "could not interpolate values");
+
+      void *prop =
+        nsCSSExpandedDataBlock::RuleDataPropertyAt(aRuleData, pt.mProperty);
+#ifdef DEBUG
+      ok =
+#endif
+        nsStyleAnimation::UncomputeValue(pt.mProperty, aRuleData->mPresContext,
+                                         value, prop);
+      NS_ABORT_IF_FALSE(ok, "could not store computed value");
     }
   }
 
   return NS_OK;
 }
 
 #ifdef DEBUG
 NS_IMETHODIMP
@@ -311,78 +283,47 @@ ElementTransitions::EnsureStyleRuleFor(T
     mStyleRule = newRule;
   }
 
   return PR_TRUE;
 }
 
 NS_IMPL_ISUPPORTS1(CoverTransitionStartStyleRule, nsIStyleRule)
 
-static void
-CoverTransitionStartPostResolveCallback(void* aStyleStruct,
-                                        nsRuleData* aRuleData,
-                                        nsIStyleRule* aRule)
-{
-  CoverTransitionStartStyleRule* coverRule =
-    static_cast<CoverTransitionStartStyleRule*>(aRule);
-  coverRule->FillStyleStruct(aStyleStruct, aRuleData);
-}
-
 NS_IMETHODIMP
 CoverTransitionStartStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   for (PRUint32 i = 0, i_end = mCoveredValues.Length(); i < i_end; ++i) {
     CoveredValue &cv = mCoveredValues[i];
     if (aRuleData->mSIDs & nsCachedStyleData::GetBitForSID(
                              nsCSSProps::kSIDTable[cv.mProperty]))
     {
-      nsPostResolveCallback prc =
-        { &CoverTransitionStartPostResolveCallback, this };
-      aRuleData->mPostResolveCallbacks.AppendElement(prc);
-      // This really doesn't matter much, since this ought to be
-      // the only node with the rule, but it's good practice for
-      // post-resolve callbacks.
-      aRuleData->mCanStoreInRuleTree = PR_FALSE;
-
-      return NS_OK;
+      void *prop =
+        nsCSSExpandedDataBlock::RuleDataPropertyAt(aRuleData, cv.mProperty);
+#ifdef DEBUG
+      PRBool ok =
+#endif
+        nsStyleAnimation::UncomputeValue(cv.mProperty, aRuleData->mPresContext,
+                                         cv.mCoveredValue, prop);
+      NS_ABORT_IF_FALSE(ok, "could not store computed value");
     }
   }
 
   return NS_OK;
 }
 
 #ifdef DEBUG
 NS_IMETHODIMP
 CoverTransitionStartStyleRule::List(FILE* out, PRInt32 aIndent) const
 {
   // WRITE ME?
   return NS_OK;
 }
 #endif
 
-void
-CoverTransitionStartStyleRule::FillStyleStruct(void* aStyleStruct,
-                                               nsRuleData* aRuleData) const
-{
-  for (PRUint32 i = 0, i_end = mCoveredValues.Length(); i < i_end; ++i) {
-    const CoveredValue &cv = mCoveredValues[i];
-    if (aRuleData->mSIDs & nsCachedStyleData::GetBitForSID(
-                             nsCSSProps::kSIDTable[cv.mProperty]))
-    {
-#ifdef DEBUG
-      PRBool ok =
-#endif
-        nsStyleAnimation::StoreComputedValue(cv.mProperty,
-                                             aRuleData->mPresContext,
-                                             aStyleStruct, cv.mCoveredValue);
-      NS_ABORT_IF_FALSE(ok, "could not store computed value");
-    }
-  }
-}
-
 /*****************************************************************************
  * nsTransitionManager                                                       *
  *****************************************************************************/
 
 nsTransitionManager::nsTransitionManager(nsPresContext *aPresContext)
   : mPresContext(aPresContext)
 {
   PR_INIT_CLIST(&mElementTransitions);
