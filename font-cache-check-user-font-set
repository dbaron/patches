Check that the user font set matches before returning an entry from the font cache.  (Bug 457821)  r=jdaggett  sr=roc  a=blocking1.9.1+

diff --git a/gfx/src/nsDeviceContext.cpp b/gfx/src/nsDeviceContext.cpp
--- a/gfx/src/nsDeviceContext.cpp
+++ b/gfx/src/nsDeviceContext.cpp
@@ -46,16 +46,17 @@
 #include "nsIFontMetrics.h"
 #include "nsHashtable.h"
 #include "nsILanguageAtomService.h"
 #include "nsIServiceManager.h"
 #include "nsUnicharUtils.h"
 #include "nsCRT.h"
 #include "nsIRenderingContext.h"
 #include "gfxUserFontSet.h"
+#include "nsIThebesFontMetrics.h"
 
 NS_IMPL_ISUPPORTS3(DeviceContextImpl, nsIDeviceContext, nsIObserver, nsISupportsWeakReference)
 
 DeviceContextImpl::DeviceContextImpl()
 {
   mAppUnitsPerDevPixel = -1;
   mAppUnitsPerInch = -1;
   mAppUnitsPerDevNotScaledPixel = -1;
@@ -477,24 +478,26 @@ nsFontCache::GetMetricsFor(const nsFont&
 {
   // First check our cache
   // start from the end, which is where we put the most-recent-used element
 
   nsIFontMetrics* fm;
   PRInt32 n = mFontMetrics.Count() - 1;
   for (PRInt32 i = n; i >= 0; --i) {
     fm = static_cast<nsIFontMetrics*>(mFontMetrics[i]);
-    if (fm->Font().Equals(aFont)) {
+    nsIThebesFontMetrics* tfm = static_cast<nsIThebesFontMetrics*>(fm);
+    if (fm->Font().Equals(aFont) && tfm->GetUserFontSet() == aUserFontSet) {
       nsCOMPtr<nsIAtom> langGroup;
       fm->GetLangGroup(getter_AddRefs(langGroup));
       if (aLangGroup == langGroup.get()) {
         if (i != n) {
           // promote it to the end of the cache
           mFontMetrics.MoveElement(i, n);
         }
+        tfm->GetThebesFontGroup()->UpdateFontList();
         NS_ADDREF(aMetrics = fm);
         return NS_OK;
       }
     }
   }
 
   // It's not in the cache. Get font metrics and then cache them.
 
diff --git a/gfx/src/thebes/nsIThebesFontMetrics.h b/gfx/src/thebes/nsIThebesFontMetrics.h
--- a/gfx/src/thebes/nsIThebesFontMetrics.h
+++ b/gfx/src/thebes/nsIThebesFontMetrics.h
@@ -111,11 +111,15 @@ public:
     // Set the direction of the text rendering
     virtual nsresult SetRightToLeftText(PRBool aIsRTL) = 0;
     virtual PRBool GetRightToLeftText() = 0;
     virtual void SetTextRunRTL(PRBool aIsRTL) = 0;
 
     virtual PRInt32 GetMaxStringLength() = 0;
 
     virtual gfxFontGroup* GetThebesFontGroup() = 0;
+
+    // Needs to be virtual and at this level so that its caller in gkgfx can
+    // avoid linking against thebes.
+    virtual gfxUserFontSet* GetUserFontSet() = 0;
 };
 
 #endif /* __nsIThebesFontMetrics_h */
diff --git a/gfx/src/thebes/nsThebesFontMetrics.cpp b/gfx/src/thebes/nsThebesFontMetrics.cpp
--- a/gfx/src/thebes/nsThebesFontMetrics.cpp
+++ b/gfx/src/thebes/nsThebesFontMetrics.cpp
@@ -489,8 +489,14 @@ nsThebesFontMetrics::SetRightToLeftText(
 }
 
 // Set the direction of the text rendering
 PRBool
 nsThebesFontMetrics::GetRightToLeftText()
 {
     return mIsRightToLeft;
 }
+
+/* virtual */ gfxUserFontSet*
+nsThebesFontMetrics::GetUserFontSet()
+{
+    return mFontGroup->GetUserFontSet();
+}
diff --git a/gfx/src/thebes/nsThebesFontMetrics.h b/gfx/src/thebes/nsThebesFontMetrics.h
--- a/gfx/src/thebes/nsThebesFontMetrics.h
+++ b/gfx/src/thebes/nsThebesFontMetrics.h
@@ -136,16 +136,18 @@ public:
 #endif /* MOZ_MATHML */
 
     // Set the direction of the text rendering
     virtual nsresult SetRightToLeftText(PRBool aIsRTL);
     virtual PRBool GetRightToLeftText();
     virtual void SetTextRunRTL(PRBool aIsRTL) { mTextRunRTL = aIsRTL; }
 
     virtual gfxFontGroup* GetThebesFontGroup() { return mFontGroup; }
+
+    virtual gfxUserFontSet* GetUserFontSet();
     
     PRBool GetRightToLeftTextRunMode() {
         return mTextRunRTL;
     }
 
 protected:
 
     const gfxFont::Metrics& GetMetrics() const;
diff --git a/gfx/thebes/public/gfxAtsuiFonts.h b/gfx/thebes/public/gfxAtsuiFonts.h
--- a/gfx/thebes/public/gfxAtsuiFonts.h
+++ b/gfx/thebes/public/gfxAtsuiFonts.h
@@ -128,16 +128,24 @@ public:
     // direction for all characters, the last character is PDF, and the
     // second to last character is a non-whitespace character --- to ensure
     // that there is no "trailing whitespace" in the string, see
     // http://weblogs.mozillazine.org/roc/archives/2007/02/superlaser_targ.html#comments
     void MakeTextRunInternal(const PRUnichar *aString, PRUint32 aLength,
                              PRBool aWrapped, gfxTextRun *aTextRun);
 
     gfxAtsuiFont* GetFontAt(PRInt32 aFontIndex) {
+        // If it turns out to be hard for all clients that cache font
+        // groups to call UpdateFontList at appropriate times, we could
+        // instead consider just calling UpdateFontList from someplace
+        // more central (such as here).
+        NS_ASSERTION(!mUserFontSet || mCurrGeneration == GetGeneration(),
+                     "Whoever was caching this font group should have "
+                     "called UpdateFontList on it");
+
         return static_cast<gfxAtsuiFont*>(static_cast<gfxFont*>(mFonts[aFontIndex]));
     }
 
     PRBool HasFont(ATSUFontID fid);
 
     inline gfxAtsuiFont* WhichFontSupportsChar(nsTArray< nsRefPtr<gfxFont> >& aFontList, 
                                                PRUint32 aCh)
     {
diff --git a/gfx/thebes/public/gfxFT2Fonts.h b/gfx/thebes/public/gfxFT2Fonts.h
--- a/gfx/thebes/public/gfxFT2Fonts.h
+++ b/gfx/thebes/public/gfxFT2Fonts.h
@@ -127,16 +127,24 @@ private:
 
 class THEBES_API gfxFT2FontGroup : public gfxFontGroup {
 public: // new functions
     gfxFT2FontGroup (const nsAString& families,
                     const gfxFontStyle *aStyle);
     virtual ~gfxFT2FontGroup ();
 
     inline gfxFT2Font *GetFontAt (PRInt32 i) {
+        // If it turns out to be hard for all clients that cache font
+        // groups to call UpdateFontList at appropriate times, we could
+        // instead consider just calling UpdateFontList from someplace
+        // more central (such as here).
+        NS_ASSERTION(!mUserFontSet || mCurrGeneration == GetGeneration(),
+                     "Whoever was caching this font group should have "
+                     "called UpdateFontList on it");
+
         return static_cast <gfxFT2Font *>(static_cast <gfxFont *>(mFonts[i]));
     }
 
 protected: // from gfxFontGroup
     virtual gfxTextRun *MakeTextRun(const PRUnichar *aString, 
                                     PRUint32 aLength,
                                     const Parameters *aParams, 
                                     PRUint32 aFlags);
diff --git a/gfx/thebes/public/gfxFont.h b/gfx/thebes/public/gfxFont.h
--- a/gfx/thebes/public/gfxFont.h
+++ b/gfx/thebes/public/gfxFont.h
@@ -1518,16 +1518,24 @@ class THEBES_API gfxFontGroup : public g
 class THEBES_API gfxFontGroup : public gfxTextRunFactory {
 protected:
     gfxFontGroup(const nsAString& aFamilies, const gfxFontStyle *aStyle, gfxUserFontSet *aUserFontSet = nsnull);
 
 public:
     virtual ~gfxFontGroup();
 
     virtual gfxFont *GetFontAt(PRInt32 i) {
+        // If it turns out to be hard for all clients that cache font
+        // groups to call UpdateFontList at appropriate times, we could
+        // instead consider just calling UpdateFontList from someplace
+        // more central (such as here).
+        NS_ASSERTION(!mUserFontSet || mCurrGeneration == GetGeneration(),
+                     "Whoever was caching this font group should have "
+                     "called UpdateFontList on it");
+
         return static_cast<gfxFont*>(mFonts[i]);
     }
     virtual PRUint32 FontListLength() const {
         return mFonts.Length();
     }
 
     PRBool Equals(const gfxFontGroup& other) const {
         return mFamilies.Equals(other.mFamilies) &&
diff --git a/gfx/thebes/public/gfxOS2Fonts.h b/gfx/thebes/public/gfxOS2Fonts.h
--- a/gfx/thebes/public/gfxOS2Fonts.h
+++ b/gfx/thebes/public/gfxOS2Fonts.h
@@ -102,16 +102,24 @@ public:
 
     // create and initialize the textRun using FreeType font
     virtual gfxTextRun *MakeTextRun(const PRUnichar* aString, PRUint32 aLength,
                                     const Parameters* aParams, PRUint32 aFlags);
     virtual gfxTextRun *MakeTextRun(const PRUint8* aString, PRUint32 aLength,
                                     const Parameters* aParams, PRUint32 aFlags);
 
     gfxOS2Font *GetFontAt(PRInt32 i) {
+        // If it turns out to be hard for all clients that cache font
+        // groups to call UpdateFontList at appropriate times, we could
+        // instead consider just calling UpdateFontList from someplace
+        // more central (such as here).
+        NS_ASSERTION(!mUserFontSet || mCurrGeneration == GetGeneration(),
+                     "Whoever was caching this font group should have "
+                     "called UpdateFontList on it");
+
 #ifdef DEBUG_thebes_2
         printf("gfxOS2FontGroup[%#x]::GetFontAt(%d), %#x, %#x\n",
                (unsigned)this, i, (unsigned)&mFonts, (unsigned)&mFonts[i]);
 #endif
         return static_cast<gfxOS2Font*>(static_cast<gfxFont*>(mFonts[i]));
     }
 
 protected:
diff --git a/gfx/thebes/src/gfxPangoFonts.cpp b/gfx/thebes/src/gfxPangoFonts.cpp
--- a/gfx/thebes/src/gfxPangoFonts.cpp
+++ b/gfx/thebes/src/gfxPangoFonts.cpp
@@ -1396,16 +1396,24 @@ PangoFont *
 PangoFont *
 gfxPangoFontGroup::GetBasePangoFont()
 {
     return GetBaseFontSet()->GetFontAt(0);
 }
 
 gfxFont *
 gfxPangoFontGroup::GetFontAt(PRInt32 i) {
+    // If it turns out to be hard for all clients that cache font
+    // groups to call UpdateFontList at appropriate times, we could
+    // instead consider just calling UpdateFontList from someplace
+    // more central (such as here).
+    NS_ASSERTION(!mUserFontSet || mCurrGeneration == GetGeneration(),
+                 "Whoever was caching this font group should have "
+                 "called UpdateFontList on it");
+
     NS_PRECONDITION(i == 0, "Only have one font");
 
     if (!mFonts[0]) {
         PangoFont *pangoFont = GetBasePangoFont();
         mFonts[0] = gfxPangoFcFont::GfxFont(GFX_PANGO_FC_FONT(pangoFont));
     }
 
     return mFonts[0];
diff --git a/gfx/thebes/src/gfxWindowsFonts.cpp b/gfx/thebes/src/gfxWindowsFonts.cpp
--- a/gfx/thebes/src/gfxWindowsFonts.cpp
+++ b/gfx/thebes/src/gfxWindowsFonts.cpp
@@ -884,16 +884,24 @@ gfxWindowsFontGroup::gfxWindowsFontGroup
 
 gfxWindowsFontGroup::~gfxWindowsFontGroup()
 {
 }
 
 gfxWindowsFont *
 gfxWindowsFontGroup::GetFontAt(PRInt32 i)
 {
+    // If it turns out to be hard for all clients that cache font
+    // groups to call UpdateFontList at appropriate times, we could
+    // instead consider just calling UpdateFontList from someplace
+    // more central (such as here).
+    NS_ASSERTION(!mUserFontSet || mCurrGeneration == GetGeneration(),
+                 "Whoever was caching this font group should have "
+                 "called UpdateFontList on it");
+
     if (!mFonts[i]) {
         nsRefPtr<gfxWindowsFont> font =
             gfxWindowsFont::GetOrMakeFont(mFontEntries[i], &mStyle);
         mFonts[i] = font;
     }
 
     return static_cast<gfxWindowsFont*>(mFonts[i].get());
 }
diff --git a/layout/reftests/font-face/reftest.list b/layout/reftests/font-face/reftest.list
--- a/layout/reftests/font-face/reftest.list
+++ b/layout/reftests/font-face/reftest.list
@@ -7,26 +7,26 @@ HTTP(..) != download-2.html about:blank
 HTTP(..) != download-2.html about:blank
 HTTP(..) == fallback-to-system-1.html fallback-to-system-1-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == name-override-simple-1.html name-override-simple-1-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) != name-override-simple-1.html download-1-notref.html
 fails HTTP(..) == name-override-1.html name-override-1-ref.html
 HTTP(..) == multiple-descriptor-1.html multiple-descriptor-1-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) != multiple-descriptor-1.html multiple-descriptor-1-notref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == src-list-1.html src-list-1-ref.html
-fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") random-if(MOZ_WIDGET_TOOLKIT=="cocoa") random-if(MOZ_WIDGET_TOOLKIT=="windows") HTTP(..) == src-list-2.html src-list-2-ref.html # random probably fixed by the font cache patch on bug 457821
+fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == src-list-2.html src-list-2-ref.html
 fails HTTP(..) == src-list-format-1.html src-list-format-1-ref.html
 fails HTTP(..) == src-list-format-2.html src-list-format-2-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == src-list-format-3.html src-list-format-3-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == src-list-format-4.html src-list-format-1-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == src-list-format-5.html src-list-format-2-ref.html
 fails HTTP(..) == src-list-format-6.html src-list-format-3-ref.html
 # FIXME: The behavior here is neither mandated nor specified by the spec, but
 # it really ought to be.
 HTTP(..) == order-1.html order-1-ref.html
 fails HTTP(..) == order-2.html order-2-ref.html
 fails HTTP(..) == order-3.html order-3-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") random-if(MOZ_WIDGET_TOOLKIT=="windows") HTTP(..) == multiple-in-family-1.html multiple-in-family-1-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") random-if(MOZ_WIDGET_TOOLKIT=="windows") HTTP(..) != multiple-in-family-1.html multiple-in-family-1-notref.html
-random-if(MOZ_WIDGET_TOOLKIT=="windows") random-if(MOZ_WIDGET_TOOLKIT=="cocoa") HTTP(..) == prop-order-over-rule-order-1a.html prop-order-over-rule-order-2a.html # randomness on cocoa should be fixed by the font cache patch on bug 457821
+random-if(MOZ_WIDGET_TOOLKIT=="windows") HTTP(..) == prop-order-over-rule-order-1a.html prop-order-over-rule-order-2a.html
 random-if(MOZ_WIDGET_TOOLKIT=="windows") HTTP(..) == prop-order-over-rule-order-1b.html prop-order-over-rule-order-2b.html
 random-if(MOZ_WIDGET_TOOLKIT=="windows") fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) != prop-order-over-rule-order-1a.html prop-order-over-rule-order-1b.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == cross-iframe-1.html cross-iframe-1-ref.html
