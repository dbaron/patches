Check that the user font set matches before returning an entry from the font cache.  (Bug 457821)

diff --git a/gfx/src/nsDeviceContext.cpp b/gfx/src/nsDeviceContext.cpp
--- a/gfx/src/nsDeviceContext.cpp
+++ b/gfx/src/nsDeviceContext.cpp
@@ -46,16 +46,17 @@
 #include "nsIFontMetrics.h"
 #include "nsHashtable.h"
 #include "nsILanguageAtomService.h"
 #include "nsIServiceManager.h"
 #include "nsUnicharUtils.h"
 #include "nsCRT.h"
 #include "nsIRenderingContext.h"
 #include "gfxUserFontSet.h"
+#include "nsIThebesFontMetrics.h"
 
 NS_IMPL_ISUPPORTS3(DeviceContextImpl, nsIDeviceContext, nsIObserver, nsISupportsWeakReference)
 
 DeviceContextImpl::DeviceContextImpl()
 {
   mAppUnitsPerDevPixel = -1;
   mAppUnitsPerInch = -1;
   mAppUnitsPerDevNotScaledPixel = -1;
@@ -477,24 +478,26 @@ nsFontCache::GetMetricsFor(const nsFont&
 {
   // First check our cache
   // start from the end, which is where we put the most-recent-used element
 
   nsIFontMetrics* fm;
   PRInt32 n = mFontMetrics.Count() - 1;
   for (PRInt32 i = n; i >= 0; --i) {
     fm = static_cast<nsIFontMetrics*>(mFontMetrics[i]);
-    if (fm->Font().Equals(aFont)) {
+    nsIThebesFontMetrics* tfm = static_cast<nsIThebesFontMetrics*>(fm);
+    if (fm->Font().Equals(aFont) && tfm->GetUserFontSet() == aUserFontSet) {
       nsCOMPtr<nsIAtom> langGroup;
       fm->GetLangGroup(getter_AddRefs(langGroup));
       if (aLangGroup == langGroup.get()) {
         if (i != n) {
           // promote it to the end of the cache
           mFontMetrics.MoveElement(i, n);
         }
+        tfm->GetThebesFontGroup()->UpdateFontList();
         NS_ADDREF(aMetrics = fm);
         return NS_OK;
       }
     }
   }
 
   // It's not in the cache. Get font metrics and then cache them.
 
diff --git a/gfx/src/thebes/nsIThebesFontMetrics.h b/gfx/src/thebes/nsIThebesFontMetrics.h
--- a/gfx/src/thebes/nsIThebesFontMetrics.h
+++ b/gfx/src/thebes/nsIThebesFontMetrics.h
@@ -111,11 +111,15 @@ public:
     // Set the direction of the text rendering
     virtual nsresult SetRightToLeftText(PRBool aIsRTL) = 0;
     virtual PRBool GetRightToLeftText() = 0;
     virtual void SetTextRunRTL(PRBool aIsRTL) = 0;
 
     virtual PRInt32 GetMaxStringLength() = 0;
 
     virtual gfxFontGroup* GetThebesFontGroup() = 0;
+
+    // Needs to be virtual and at this level so that its caller in gkgfx can
+    // avoid linking against thebes.
+    virtual gfxUserFontSet* GetUserFontSet() = 0;
 };
 
 #endif /* __nsIThebesFontMetrics_h */
diff --git a/gfx/src/thebes/nsThebesFontMetrics.cpp b/gfx/src/thebes/nsThebesFontMetrics.cpp
--- a/gfx/src/thebes/nsThebesFontMetrics.cpp
+++ b/gfx/src/thebes/nsThebesFontMetrics.cpp
@@ -492,8 +492,14 @@ nsThebesFontMetrics::SetRightToLeftText(
 }
 
 // Set the direction of the text rendering
 PRBool
 nsThebesFontMetrics::GetRightToLeftText()
 {
     return mIsRightToLeft;
 }
+
+/* virtual */ gfxUserFontSet*
+nsThebesFontMetrics::GetUserFontSet()
+{
+    return mFontGroup->GetUserFontSet();
+}
diff --git a/gfx/src/thebes/nsThebesFontMetrics.h b/gfx/src/thebes/nsThebesFontMetrics.h
--- a/gfx/src/thebes/nsThebesFontMetrics.h
+++ b/gfx/src/thebes/nsThebesFontMetrics.h
@@ -136,16 +136,18 @@ public:
 #endif /* MOZ_MATHML */
 
     // Set the direction of the text rendering
     virtual nsresult SetRightToLeftText(PRBool aIsRTL);
     virtual PRBool GetRightToLeftText();
     virtual void SetTextRunRTL(PRBool aIsRTL) { mTextRunRTL = aIsRTL; }
 
     virtual gfxFontGroup* GetThebesFontGroup() { return mFontGroup; }
+
+    virtual gfxUserFontSet* GetUserFontSet();
     
     PRBool GetRightToLeftTextRunMode() {
         return mTextRunRTL;
     }
 
 protected:
 
     const gfxFont::Metrics& GetMetrics() const;
diff --git a/gfx/thebes/public/gfxFont.h b/gfx/thebes/public/gfxFont.h
--- a/gfx/thebes/public/gfxFont.h
+++ b/gfx/thebes/public/gfxFont.h
@@ -1530,16 +1530,24 @@ class THEBES_API gfxFontGroup : public g
 class THEBES_API gfxFontGroup : public gfxTextRunFactory {
 protected:
     gfxFontGroup(const nsAString& aFamilies, const gfxFontStyle *aStyle, gfxUserFontSet *aUserFontSet = nsnull);
 
 public:
     virtual ~gfxFontGroup();
 
     virtual gfxFont *GetFontAt(PRInt32 i) {
+        // If it turns out to be hard for all clients that cache font
+        // groups to call UpdateFontList at appropriate times, we could
+        // instead consider just calling UpdateFontList from someplace
+        // more central (such as here).
+        NS_ASSERTION(!mUserFontSet || mCurrGeneration == GetGeneration(),
+                     "Whoever was caching this font group should have "
+                     "called UpdateFontList on it");
+
         return static_cast<gfxFont*>(mFonts[i]);
     }
     virtual PRUint32 FontListLength() const {
         return mFonts.Length();
     }
 
     PRBool Equals(const gfxFontGroup& other) const {
         return mFamilies.Equals(other.mFamilies) &&
diff --git a/layout/reftests/font-face/reftest.list b/layout/reftests/font-face/reftest.list
--- a/layout/reftests/font-face/reftest.list
+++ b/layout/reftests/font-face/reftest.list
@@ -7,23 +7,23 @@ HTTP(..) != download-2.html about:blank
 HTTP(..) != download-2.html about:blank
 HTTP(..) == fallback-to-system-1.html fallback-to-system-1-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == name-override-simple-1.html name-override-simple-1-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) != name-override-simple-1.html download-1-notref.html
 fails HTTP(..) == name-override-1.html name-override-1-ref.html
 HTTP(..) == multiple-descriptor-1.html multiple-descriptor-1-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) != multiple-descriptor-1.html multiple-descriptor-1-notref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == src-list-1.html src-list-1-ref.html
-fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") random-if(MOZ_WIDGET_TOOLKIT=="cocoa") random-if(MOZ_WIDGET_TOOLKIT=="windows") HTTP(..) == src-list-2.html src-list-2-ref.html # random probably fixed by the font cache patch on bug 457821
+fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == src-list-2.html src-list-2-ref.html
 fails HTTP(..) == src-list-format-1.html src-list-format-1-ref.html
 fails HTTP(..) == src-list-format-2.html src-list-format-2-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == src-list-format-3.html src-list-format-3-ref.html
 # FIXME: The behavior here is neither mandated nor specified by the spec, but
 # it really ought to be.
 HTTP(..) == order-1.html order-1-ref.html
 fails HTTP(..) == order-2.html order-2-ref.html
 fails HTTP(..) == order-3.html order-3-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") random-if(MOZ_WIDGET_TOOLKIT=="windows") HTTP(..) == multiple-in-family-1.html multiple-in-family-1-ref.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") fails-if(MOZ_WIDGET_TOOLKIT=="cocoa") random-if(MOZ_WIDGET_TOOLKIT=="windows") HTTP(..) != multiple-in-family-1.html multiple-in-family-1-notref.html
-random-if(MOZ_WIDGET_TOOLKIT=="windows") random-if(MOZ_WIDGET_TOOLKIT=="cocoa") HTTP(..) == prop-order-over-rule-order-1a.html prop-order-over-rule-order-2a.html # randomness on cocoa should be fixed by the font cache patch on bug 457821
+random-if(MOZ_WIDGET_TOOLKIT=="windows") HTTP(..) == prop-order-over-rule-order-1a.html prop-order-over-rule-order-2a.html
 random-if(MOZ_WIDGET_TOOLKIT=="windows") HTTP(..) == prop-order-over-rule-order-1b.html prop-order-over-rule-order-2b.html
 random-if(MOZ_WIDGET_TOOLKIT=="windows") fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) != prop-order-over-rule-order-1a.html prop-order-over-rule-order-1b.html
 fails-if(MOZ_WIDGET_TOOLKIT=="gtk2") HTTP(..) == cross-iframe-1.html cross-iframe-1-ref.html
