From: L. David Baron <dbaron@dbaron.org>

Replace AutoMaybeNullInflationContainer with AutoMaybeDisableInflationForShrinkWrap since the concept of the pres context's current inflation container will be going away.  (Bug 707195, patch 2)

diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -2334,17 +2334,17 @@ GetIntrinsicCoord(const nsStyleCoord& aS
   }
 
   NS_ASSERTION(val == NS_STYLE_WIDTH_MAX_CONTENT ||
                val == NS_STYLE_WIDTH_MIN_CONTENT,
                "should have reduced everything remaining to one of these");
 
   // If aFrame is a container for font size inflation, then shrink
   // wrapping inside of it should not apply font size inflation.
-  AutoMaybeNullInflationContainer an(aFrame);
+  AutoMaybeDisableFontInflation an(aFrame);
 
   if (val == NS_STYLE_WIDTH_MAX_CONTENT)
     aResult = aFrame->GetPrefWidth(aRenderingContext);
   else
     aResult = aFrame->GetMinWidth(aRenderingContext);
   return true;
 }
 
@@ -2366,17 +2366,17 @@ nsLayoutUtils::IntrinsicForContainer(nsR
   nsFrame::IndentBy(stdout, gNoiseIndent);
   static_cast<nsFrame*>(aFrame)->ListTag(stdout);
   printf(" %s intrinsic width for container:\n",
          aType == MIN_WIDTH ? "min" : "pref");
 #endif
 
   // If aFrame is a container for font size inflation, then shrink
   // wrapping inside of it should not apply font size inflation.
-  AutoMaybeNullInflationContainer an(aFrame);
+  AutoMaybeDisableFontInflation an(aFrame);
 
   nsIFrame::IntrinsicWidthOffsetData offsets =
     aFrame->IntrinsicWidthOffsets(aRenderingContext);
 
   const nsStylePosition *stylePos = aFrame->GetStylePosition();
   PRUint8 boxSizing = stylePos->mBoxSizing;
   const nsStyleCoord &styleWidth = stylePos->mWidth;
   const nsStyleCoord &styleMinWidth = stylePos->mMinWidth;
@@ -2625,17 +2625,17 @@ nsLayoutUtils::ComputeWidthValue(
     result = nsRuleNode::ComputeCoordPercentCalc(aCoord, aContainingBlockWidth);
     // The result of a calc() expression might be less than 0; we
     // should clamp at runtime (below).  (Percentages and coords that
     // are less than 0 have already been dropped by the parser.)
     result -= aContentEdgeToBoxSizing;
   } else if (eStyleUnit_Enumerated == aCoord.GetUnit()) {
     // If aFrame is a container for font size inflation, then shrink
     // wrapping inside of it should not apply font size inflation.
-    AutoMaybeNullInflationContainer an(aFrame);
+    AutoMaybeDisableFontInflation an(aFrame);
 
     PRInt32 val = aCoord.GetIntValue();
     switch (val) {
       case NS_STYLE_WIDTH_MAX_CONTENT:
         result = aFrame->GetPrefWidth(aRenderingContext);
         NS_ASSERTION(result >= 0, "width less than zero");
         break;
       case NS_STYLE_WIDTH_MIN_CONTENT:
@@ -4786,22 +4786,23 @@ nsLayoutUtils::InflationMinFontSizeFor(c
       }
     }
     // It's ok if frames are dirty, or even if they've never been
     // reflowed, since they will be eventually and then we'll get the
     // right size.
   }
 #endif
 
-  if (!FontSizeInflationEnabled(aFrame->PresContext())) {
+  nsPresContext *presContext = aFrame->PresContext();
+  if (!FontSizeInflationEnabled(presContext) ||
+      presContext->mInflationDisabledForShrinkWrap) {
     return 0;
   }
 
   if (aWidthDetermination == eInReflow) {
-    nsPresContext *presContext = aFrame->PresContext();
     nsIFrame *container = presContext->mCurrentInflationContainer;
     if (!container || !ShouldInflateFontsForContainer(container)) {
       return 0;
     }
     return MinimumFontSizeFor(presContext,
                               presContext->mCurrentInflationContainerWidth);
   }
 
diff --git a/layout/base/nsLayoutUtils.h b/layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h
+++ b/layout/base/nsLayoutUtils.h
@@ -1656,39 +1656,43 @@ namespace mozilla {
   namespace layout {
 
     /**
      * An RAII class which will, for the duration of its lifetime,
      * **if** the frame given is a container for font size inflation,
      * set the current inflation container on the pres context to null
      * (and then, in its destructor, restore the old value).
      */
-    class AutoMaybeNullInflationContainer {
+    class AutoMaybeDisableFontInflation {
     public:
-      AutoMaybeNullInflationContainer(nsIFrame *aFrame)
+      AutoMaybeDisableFontInflation(nsIFrame *aFrame)
       {
+        // FIXME: Now that inflation calculations are based on the flow
+        // root's NCA's (nearest common ancestor of its inflatable
+        // descendants) width, we could probably disable inflation in
+        // fewer cases than we currently do.
         if (nsLayoutUtils::IsContainerForFontSizeInflation(aFrame)) {
           mPresContext = aFrame->PresContext();
-          mOldValue = mPresContext->mCurrentInflationContainer;
-          mPresContext->mCurrentInflationContainer = nsnull;
+          mOldValue = mPresContext->mInflationDisabledForShrinkWrap;
+          mPresContext->mInflationDisabledForShrinkWrap = true;
         } else {
           // indicate we have nothing to restore
           mPresContext = nsnull;
         }
       }
 
-      ~AutoMaybeNullInflationContainer()
+      ~AutoMaybeDisableFontInflation()
       {
         if (mPresContext) {
-          mPresContext->mCurrentInflationContainer = mOldValue;
+          mPresContext->mInflationDisabledForShrinkWrap = mOldValue;
         }
       }
     private:
       nsPresContext *mPresContext;
-      nsIFrame *mOldValue;
+      bool mOldValue;
     };
 
   }
 }
 
 class nsSetAttrRunnable : public nsRunnable
 {
 public:
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -1134,16 +1134,20 @@ public:
   // frame is null, then font inflation should not be performed.
   nsIFrame*             mCurrentInflationContainer; // [WEAK]
 
   // The content-rect width of mCurrentInflationContainer.  If
   // mCurrentInflationContainer is currently in reflow, this is its new
   // width, which is not yet set on its rect.
   nscoord               mCurrentInflationContainerWidth;
 
+  // Should we disable font size inflation because we're inside of
+  // shrink-wrapping calculations on an inflation container?
+  bool                  mInflationDisabledForShrinkWrap;
+
 protected:
 
   nsRefPtrHashtable<nsPtrHashKey<nsIFrame>, nsImageLoader>
                         mImageLoaders[IMAGE_LOAD_TYPE_COUNT];
 
   nsWeakPtr             mContainer;
 
   PRCList               mDOMMediaQueryLists;
diff --git a/layout/forms/nsFieldSetFrame.cpp b/layout/forms/nsFieldSetFrame.cpp
--- a/layout/forms/nsFieldSetFrame.cpp
+++ b/layout/forms/nsFieldSetFrame.cpp
@@ -406,17 +406,17 @@ nsFieldSetFrame::ComputeSize(nsRendering
   nsSize result =
     nsContainerFrame::ComputeSize(aRenderingContext, aCBSize, aAvailableWidth,
                                   aMargin, aBorder, aPadding, aFlags);
 
   // Fieldsets never shrink below their min width.
 
   // If we're a container for font size inflation, then shrink
   // wrapping inside of us should not apply font size inflation.
-  AutoMaybeNullInflationContainer an(this);
+  AutoMaybeDisableFontInflation an(this);
 
   nscoord minWidth = GetMinWidth(aRenderingContext);
   if (minWidth > result.width)
     result.width = minWidth;
 
   return result;
 }
 
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -583,17 +583,17 @@ nsBlockReflowState::CanPlaceFloat(nscoor
 }
 
 static nscoord
 FloatMarginWidth(const nsHTMLReflowState& aCBReflowState,
                  nscoord aFloatAvailableWidth,
                  nsIFrame *aFloat,
                  const nsCSSOffsetState& aFloatOffsetState)
 {
-  AutoMaybeNullInflationContainer an(aFloat);
+  AutoMaybeDisableFontInflation an(aFloat);
   return aFloat->ComputeSize(
     aCBReflowState.rendContext,
     nsSize(aCBReflowState.ComputedWidth(),
            aCBReflowState.ComputedHeight()),
     aFloatAvailableWidth,
     nsSize(aFloatOffsetState.mComputedMargin.LeftRight(),
            aFloatOffsetState.mComputedMargin.TopBottom()),
     nsSize(aFloatOffsetState.mComputedBorderPadding.LeftRight() -
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -3956,17 +3956,17 @@ nsFrame::ComputeAutoSize(nsRenderingCont
 }
 
 nscoord
 nsFrame::ShrinkWidthToFit(nsRenderingContext *aRenderingContext,
                           nscoord aWidthInCB)
 {
   // If we're a container for font size inflation, then shrink
   // wrapping inside of us should not apply font size inflation.
-  AutoMaybeNullInflationContainer an(this);
+  AutoMaybeDisableFontInflation an(this);
 
   nscoord result;
   nscoord minWidth = GetMinWidth(aRenderingContext);
   if (minWidth > aWidthInCB) {
     result = minWidth;
   } else {
     nscoord prefWidth = GetPrefWidth(aRenderingContext);
     if (prefWidth > aWidthInCB) {
@@ -7409,17 +7409,17 @@ nsFrame::RefreshSizeCache(nsBoxLayoutSta
     nsRect rect(oldRect);
 
     nsMargin bp(0,0,0,0);
     GetBorderAndPadding(bp);
 
     {
       // If we're a container for font size inflation, then shrink
       // wrapping inside of us should not apply font size inflation.
-      AutoMaybeNullInflationContainer an(this);
+      AutoMaybeDisableFontInflation an(this);
 
       metrics->mBlockPrefSize.width =
         GetPrefWidth(rendContext) + bp.LeftRight();
       metrics->mBlockMinSize.width =
         GetMinWidth(rendContext) + bp.LeftRight();
     }
 
     // do the nasty.
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -1249,17 +1249,17 @@ nsHTMLReflowState::InitAbsoluteConstrain
   bool heightIsAuto = eStyleUnit_Auto == mStylePosition->mHeight.GetUnit();
 
   PRUint32 computeSizeFlags = 0;
   if (leftIsAuto || rightIsAuto) {
     computeSizeFlags |= nsIFrame::eShrinkWrap;
   }
 
   {
-    AutoMaybeNullInflationContainer an(frame);
+    AutoMaybeDisableFontInflation an(frame);
 
     nsSize size =
       frame->ComputeSize(rendContext,
                          nsSize(containingBlockWidth,
                                 containingBlockHeight),
                          containingBlockWidth, // XXX or availableWidth?
                          nsSize(mComputedMargin.LeftRight() +
                                   mComputedOffsets.LeftRight(),
@@ -1871,17 +1871,17 @@ nsHTMLReflowState::InitConstraints(nsPre
       mComputedMinWidth = mComputedMinHeight = 0;
       mComputedMaxWidth = mComputedMaxHeight = NS_UNCONSTRAINEDSIZE;
 
     } else if (NS_FRAME_GET_TYPE(mFrameType) == NS_CSS_FRAME_TYPE_ABSOLUTE) {
       // XXX not sure if this belongs here or somewhere else - cwk
       InitAbsoluteConstraints(aPresContext, cbrs, aContainingBlockWidth,
                               aContainingBlockHeight, aFrameType);
     } else {
-      AutoMaybeNullInflationContainer an(frame);
+      AutoMaybeDisableFontInflation an(frame);
 
       bool isBlock = NS_CSS_FRAME_TYPE_BLOCK == NS_FRAME_GET_TYPE(mFrameType);
       PRUint32 computeSizeFlags = isBlock ? 0 : nsIFrame::eShrinkWrap;
 
       // Make sure legend frames with display:block and width:auto still
       // shrink-wrap.
       if (isBlock &&
           ((aFrameType == nsGkAtoms::legendFrame &&
diff --git a/layout/tables/BasicTableLayoutStrategy.cpp b/layout/tables/BasicTableLayoutStrategy.cpp
--- a/layout/tables/BasicTableLayoutStrategy.cpp
+++ b/layout/tables/BasicTableLayoutStrategy.cpp
@@ -110,17 +110,17 @@ struct CellWidthInfo {
 static CellWidthInfo
 GetWidthInfo(nsRenderingContext *aRenderingContext,
              nsIFrame *aFrame, bool aIsCell)
 {
     nscoord minCoord, prefCoord;
     if (aIsCell) {
         // If aFrame is a container for font size inflation, then shrink
         // wrapping inside of it should not apply font size inflation.
-        AutoMaybeNullInflationContainer an(aFrame);
+        AutoMaybeDisableFontInflation an(aFrame);
 
         minCoord = aFrame->GetMinWidth(aRenderingContext);
         prefCoord = aFrame->GetPrefWidth(aRenderingContext);
     } else {
         minCoord = 0;
         prefCoord = 0;
     }
     float prefPercent = 0.0f;
diff --git a/layout/tables/nsTableFrame.cpp b/layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp
+++ b/layout/tables/nsTableFrame.cpp
@@ -1514,33 +1514,33 @@ nsTableFrame::ComputeSize(nsRenderingCon
                           PRUint32 aFlags)
 {
   nsSize result =
     nsContainerFrame::ComputeSize(aRenderingContext, aCBSize, aAvailableWidth,
                                   aMargin, aBorder, aPadding, aFlags);
 
   // If we're a container for font size inflation, then shrink
   // wrapping inside of us should not apply font size inflation.
-  AutoMaybeNullInflationContainer an(this);
+  AutoMaybeDisableFontInflation an(this);
 
   // Tables never shrink below their min width.
   nscoord minWidth = GetMinWidth(aRenderingContext);
   if (minWidth > result.width)
     result.width = minWidth;
 
   return result;
 }
 
 nscoord
 nsTableFrame::TableShrinkWidthToFit(nsRenderingContext *aRenderingContext,
                                     nscoord aWidthInCB)
 {
   // If we're a container for font size inflation, then shrink
   // wrapping inside of us should not apply font size inflation.
-  AutoMaybeNullInflationContainer an(this);
+  AutoMaybeDisableFontInflation an(this);
 
   nscoord result;
   nscoord minWidth = GetMinWidth(aRenderingContext);
   if (minWidth > aWidthInCB) {
     result = minWidth;
   } else {
     // Tables shrink width to fit with a slightly different algorithm
     // from the one they use for their intrinsic widths (the difference
diff --git a/layout/tables/nsTableOuterFrame.cpp b/layout/tables/nsTableOuterFrame.cpp
--- a/layout/tables/nsTableOuterFrame.cpp
+++ b/layout/tables/nsTableOuterFrame.cpp
@@ -98,17 +98,17 @@ nsTableCaptionFrame::ComputeAutoSize(nsR
                                      nsSize aMargin, nsSize aBorder,
                                      nsSize aPadding, bool aShrinkWrap)
 {
   nsSize result = nsBlockFrame::ComputeAutoSize(aRenderingContext, aCBSize,
                     aAvailableWidth, aMargin, aBorder, aPadding, aShrinkWrap);
 
   // If we're a container for font size inflation, then shrink
   // wrapping inside of us should not apply font size inflation.
-  AutoMaybeNullInflationContainer an(this);
+  AutoMaybeDisableFontInflation an(this);
 
   PRUint8 captionSide = GetStyleTableBorder()->mCaptionSide;
   if (captionSide == NS_STYLE_CAPTION_SIDE_LEFT ||
       captionSide == NS_STYLE_CAPTION_SIDE_RIGHT) {
     result.width = GetMinWidth(aRenderingContext);
   } else if (captionSide == NS_STYLE_CAPTION_SIDE_TOP ||
              captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM) {
     // The outer frame constrains our available width to the width of
@@ -528,17 +528,17 @@ nsTableOuterFrame::GetPrefWidth(nsRender
 // aMarginResult is non-null, fill it with the part of the margin-width
 // that was contributed by the margin.
 static nscoord
 ChildShrinkWrapWidth(nsRenderingContext *aRenderingContext,
                      nsIFrame *aChildFrame,
                      nsSize aCBSize, nscoord aAvailableWidth,
                      nscoord *aMarginResult = nsnull)
 {
-  AutoMaybeNullInflationContainer an(aChildFrame);
+  AutoMaybeDisableFontInflation an(aChildFrame);
 
   nsCSSOffsetState offsets(aChildFrame, aRenderingContext, aCBSize.width);
   nsSize size = aChildFrame->ComputeSize(aRenderingContext, aCBSize,
                   aAvailableWidth,
                   nsSize(offsets.mComputedMargin.LeftRight(),
                          offsets.mComputedMargin.TopBottom()),
                   nsSize(offsets.mComputedBorderPadding.LeftRight() -
                            offsets.mComputedPadding.LeftRight(),
