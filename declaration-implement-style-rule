From: L. David Baron <dbaron@dbaron.org>

Bug 978833 patch 3 - Make css::Declaration implement nsIStyleRule.

We switch to using this implementation instead of the one in
css::StyleRule in patch 10.

(Yes, implementing QueryInterface for a CID is ugly, but it's the same
thing StyleRule does.  Unfortunately now we'll need to have it in both
places.)

diff --git a/layout/style/Declaration.cpp b/layout/style/Declaration.cpp
--- a/layout/style/Declaration.cpp
+++ b/layout/style/Declaration.cpp
@@ -39,16 +39,40 @@ Declaration::Declaration(const Declarati
     mImmutable(false)
 {
 }
 
 Declaration::~Declaration()
 {
 }
 
+NS_INTERFACE_MAP_BEGIN(Declaration)
+  if (aIID.Equals(NS_GET_IID(mozilla::css::Declaration))) {
+    *aInstancePtr = this;
+    NS_ADDREF_THIS();
+    return NS_OK;
+  }
+  else
+  NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStyleRule)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(Declaration)
+NS_IMPL_RELEASE(Declaration)
+
+/* virtual */ void
+Declaration::MapRuleInfoInto(nsRuleData *aRuleData)
+{
+  MOZ_ASSERT(mData, "called while expanded");
+  mData->MapRuleInfoInto(aRuleData);
+  if (mVariables) {
+    mVariables->MapRuleInfoInto(aRuleData);
+  }
+}
+
 void
 Declaration::ValueAppended(nsCSSProperty aProperty)
 {
   MOZ_ASSERT(!mData && !mImportantData,
              "should only be called while expanded");
   MOZ_ASSERT(!nsCSSProps::IsShorthand(aProperty),
              "shorthands forbidden");
   // order IS important for CSS, so remove and add to the end
@@ -1331,17 +1355,17 @@ Declaration::ToString(nsAString& aString
   if (! aString.IsEmpty()) {
     // if the string is not empty, we have trailing whitespace we
     // should remove
     aString.Truncate(aString.Length() - 1);
   }
 }
 
 #ifdef DEBUG
-void
+/* virtual */ void
 Declaration::List(FILE* out, int32_t aIndent) const
 {
   nsAutoCString str;
   for (int32_t index = aIndent; --index >= 0; ) {
     str.AppendLiteral("  ");
   }
 
   str.AppendLiteral("{ ");
diff --git a/layout/style/Declaration.h b/layout/style/Declaration.h
--- a/layout/style/Declaration.h
+++ b/layout/style/Declaration.h
@@ -12,54 +12,69 @@
 #define mozilla_css_Declaration_h
 
 // This header is in EXPORTS because it's used in several places in content/,
 // but it's not really a public interface.
 #ifndef MOZILLA_INTERNAL_API
 #error "This file should only be included within libxul"
 #endif
 
+#include "nsIStyleRule.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/MemoryReporting.h"
 #include "CSSVariableDeclarations.h"
 #include "nsCSSDataBlock.h"
 #include "nsCSSProperty.h"
 #include "nsCSSProps.h"
 #include "nsStringFwd.h"
 #include "nsTArray.h"
 #include <stdio.h>
 
+// feec07b8-3fe6-491e-90d5-cc93f853e048
+#define NS_CSS_DECLARATION_IMPL_CID \
+{ 0xfeec07b8, 0x3fe6, 0x491e, \
+  { 0x90, 0xd5, 0xcc, 0x93, 0xf8, 0x53, 0xe0, 0x48 } }
+
 namespace mozilla {
 namespace css {
 
 // Declaration objects have unusual lifetime rules.  Every declaration
 // begins life in an invalid state which ends when InitializeEmpty or
 // CompressFrom is called upon it.  After that, it can be attached to
 // exactly one style rule, and will be destroyed when that style rule
 // is destroyed.  A declaration becomes immutable when its style rule's
 // |RuleMatched| method is called; after that, it must be copied before
 // it can be modified, which is taken care of by |EnsureMutable|.
 
-class Declaration {
+class Declaration final : public nsIStyleRule {
 public:
   /**
    * Construct an |Declaration| that is in an invalid state (null
    * |mData|) and cannot be used until its |CompressFrom| method or
    * |InitializeEmpty| method is called.
    */
   Declaration();
 
   Declaration(const Declaration& aCopy);
 
-  NS_INLINE_DECL_REFCOUNTING(Declaration)
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_CSS_DECLARATION_IMPL_CID)
+
+  NS_DECL_ISUPPORTS
 
 private:
   ~Declaration();
 
 public:
+
+  // nsIStyleRule implementation
+  virtual void MapRuleInfoInto(nsRuleData *aRuleData) override;
+#ifdef DEBUG
+  virtual void List(FILE* out = stdout, int32_t aIndent = 0) const override;
+#endif
+
   /**
    * |ValueAppended| must be called to maintain this declaration's
    * |mOrder| whenever a property is parsed into an expanded data block
    * for this declaration.  aProperty must not be a shorthand.
    */
   void ValueAppended(nsCSSProperty aProperty);
 
   void RemoveProperty(nsCSSProperty aProperty);
@@ -165,27 +180,16 @@ public:
   void ExpandTo(nsCSSExpandedDataBlock *aExpandedData) {
     AssertMutable();
     aExpandedData->AssertInitialState();
 
     MOZ_ASSERT(mData, "oops");
     aExpandedData->Expand(mData.forget(), mImportantData.forget());
   }
 
-  /**
-   * Do what |nsIStyleRule::MapRuleInfoInto| needs to do for a style
-   * rule using this declaration for storage.
-   */
-  void MapNormalRuleInfoInto(nsRuleData *aRuleData) const {
-    MOZ_ASSERT(mData, "called while expanded");
-    mData->MapRuleInfoInto(aRuleData);
-    if (mVariables) {
-      mVariables->MapRuleInfoInto(aRuleData);
-    }
-  }
   void MapImportantRuleInfoInto(nsRuleData *aRuleData) const {
     MOZ_ASSERT(mData, "called while expanded");
     MOZ_ASSERT(mImportantData || mImportantVariables,
                "must have important data or variables");
     if (mImportantData) {
       mImportantData->MapRuleInfoInto(aRuleData);
     }
     if (mImportantVariables) {
@@ -271,20 +275,16 @@ public:
     mData = nullptr;
     mImportantData = nullptr;
     mVariables = nullptr;
     mImportantVariables = nullptr;
     mOrder.Clear();
     mVariableOrder.Clear();
   }
 
-#ifdef DEBUG
-  void List(FILE* out = stdout, int32_t aIndent = 0) const;
-#endif
-
 private:
   Declaration& operator=(const Declaration& aCopy) = delete;
   bool operator==(const Declaration& aCopy) const = delete;
 
   void GetValue(nsCSSProperty aProperty, nsAString& aValue,
                 nsCSSValue::Serialization aValueSerialization) const;
 
   static void AppendImportanceToString(bool aIsImportant, nsAString& aString);
@@ -355,12 +355,14 @@ private:
   // may be null
   nsAutoPtr<CSSVariableDeclarations> mImportantVariables;
 
   // set by style rules when |RuleMatched| is called;
   // also by ToString (hence the 'mutable').
   mutable bool mImmutable;
 };
 
+NS_DEFINE_STATIC_IID_ACCESSOR(Declaration, NS_CSS_DECLARATION_IMPL_CID)
+
 } // namespace css
 } // namespace mozilla
 
 #endif /* mozilla_css_Declaration_h */
diff --git a/layout/style/StyleRule.cpp b/layout/style/StyleRule.cpp
--- a/layout/style/StyleRule.cpp
+++ b/layout/style/StyleRule.cpp
@@ -1548,17 +1548,17 @@ StyleRule::DeclarationChanged(Declaratio
   return clone.forget();
 }
 
 /* virtual */ void
 StyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
   MOZ_ASSERT(mWasMatched,
              "somebody forgot to call css::StyleRule::RuleMatched");
-  mDeclaration->MapNormalRuleInfoInto(aRuleData);
+  mDeclaration->MapRuleInfoInto(aRuleData);
 }
 
 #ifdef DEBUG
 /* virtual */ void
 StyleRule::List(FILE* out, int32_t aIndent) const
 {
   nsAutoCString str;
   // Indent
diff --git a/layout/style/nsCSSRules.cpp b/layout/style/nsCSSRules.cpp
--- a/layout/style/nsCSSRules.cpp
+++ b/layout/style/nsCSSRules.cpp
@@ -2076,17 +2076,17 @@ nsCSSKeyframeRule::MapRuleInfoInto(nsRul
   // We need to implement MapRuleInfoInto because the animation manager
   // constructs a rule node pointing to us in order to compute the
   // styles it needs to animate.
 
   // The spec says that !important declarations should just be ignored
   NS_ASSERTION(!mDeclaration->HasImportantData(),
                "Keyframe rules has !important data");
 
-  mDeclaration->MapNormalRuleInfoInto(aRuleData);
+  mDeclaration->MapRuleInfoInto(aRuleData);
 }
 
 #ifdef DEBUG
 void
 nsCSSKeyframeRule::List(FILE* out, int32_t aIndent) const
 {
   nsAutoCString str;
   for (int32_t index = aIndent; --index >= 0; ) {
@@ -2705,17 +2705,17 @@ nsCSSPageRule::GetImportantRule()
     mImportantRule = new css::ImportantRule(mDeclaration);
   }
   return mImportantRule;
 }
 
 /* virtual */ void
 nsCSSPageRule::MapRuleInfoInto(nsRuleData* aRuleData)
 {
-  mDeclaration->MapNormalRuleInfoInto(aRuleData);
+  mDeclaration->MapRuleInfoInto(aRuleData);
 }
 
 NS_IMETHODIMP
 nsCSSPageRule::GetStyle(nsIDOMCSSStyleDeclaration** aStyle)
 {
   if (!mDOMDeclaration) {
     mDOMDeclaration = new nsCSSPageStyleDeclaration(this);
   }
