From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::Layout to XULLayout, and related methods with the same name.

This is a manual subset of changes written with sed, over .h and .cpp
files in layout/.

MozReview-Commit-ID: 9NNnNw6ClGq

diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -9055,17 +9055,17 @@ nsFrame::BoxReflow(nsBoxLayoutState&    
                       reflowState.ComputedLogicalMargin().Size(wm),
                       reflowState.ComputedLogicalBorderPadding().Size(wm) -
                         reflowState.ComputedLogicalPadding().Size(wm),
                       reflowState.ComputedLogicalPadding().Size(wm),
                       ComputeSizeFlags::eDefault).Height(wm));
       }
     }
 
-    // Box layout calls SetRect before Layout, whereas non-box layout
+    // Box layout calls SetRect before XULLayout, whereas non-box layout
     // calls SetRect after Reflow.
     // XXX Perhaps we should be doing this by twiddling the rect back to
     // mLastSize before calling Reflow and then switching it back, but
     // However, mLastSize can also be the size passed to BoxReflow by
     // RefreshSizeCache, so that doesn't really make sense.
     if (metrics->mLastSize.width != aWidth) {
       reflowState.SetHResize(true);
 
@@ -10269,17 +10269,17 @@ void* nsFrame::DisplayLayoutEnter(nsIFra
   if (!DR_state->mInited) DR_state->Init();
   if (!DR_state->mActive) return nullptr;
 
   NS_ASSERTION(aFrame, "invalid call");
 
   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, nullptr);
   if (treeNode && treeNode->mDisplay) {
     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
-    printf("Layout\n");
+    printf("XULLayout\n");
   }
   return treeNode;
 }
 
 void* nsFrame::DisplayIntrinsicISizeEnter(nsIFrame* aFrame,
                                           const char* aType)
 {
   if (!DR_state->mInited) DR_state->Init();
@@ -10381,17 +10381,17 @@ void nsFrame::DisplayLayoutExit(nsIFrame
 
   NS_ASSERTION(aFrame, "non-null frame required");
   if (!aFrameTreeNode) return;
 
   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aFrameTreeNode;
   if (treeNode->mDisplay) {
     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
     nsRect rect = aFrame->GetRect();
-    printf("Layout=%d,%d,%d,%d\n", rect.x, rect.y, rect.width, rect.height);
+    printf("XULLayout=%d,%d,%d,%d\n", rect.x, rect.y, rect.width, rect.height);
   }
   DR_state->DeleteTreeNode(*treeNode);
 }
 
 void nsFrame::DisplayIntrinsicISizeExit(nsIFrame*            aFrame,
                                         const char*          aType,
                                         nscoord              aResult,
                                         void*                aFrameTreeNode)
diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -1485,17 +1485,17 @@ nsXULScrollFrame::GetFrameName(nsAString
   return MakeFrameName(NS_LITERAL_STRING("XULScroll"), aResult);
 }
 #endif
 
 NS_IMETHODIMP
 nsXULScrollFrame::DoLayout(nsBoxLayoutState& aState)
 {
   uint32_t flags = aState.LayoutFlags();
-  nsresult rv = Layout(aState);
+  nsresult rv = XULLayout(aState);
   aState.SetLayoutFlags(flags);
 
   nsBox::DoLayout(aState);
   return rv;
 }
 
 NS_QUERYFRAME_HEAD(nsXULScrollFrame)
   NS_QUERYFRAME_ENTRY(nsIAnonymousContentCreator)
@@ -4663,17 +4663,17 @@ nsXULScrollFrame::LayoutScrollArea(nsBox
   if (minSize.height > childRect.height)
     childRect.height = minSize.height;
 
   if (minSize.width > childRect.width)
     childRect.width = minSize.width;
 
   aState.SetLayoutFlags(flags);
   ClampAndSetBounds(aState, childRect, aScrollPosition);
-  mHelper.mScrolledFrame->Layout(aState);
+  mHelper.mScrolledFrame->XULLayout(aState);
 
   childRect = mHelper.mScrolledFrame->GetRect();
 
   if (childRect.width < mHelper.mScrollPort.width ||
       childRect.height < mHelper.mScrollPort.height)
   {
     childRect.width = std::max(childRect.width, mHelper.mScrollPort.width);
     childRect.height = std::max(childRect.height, mHelper.mScrollPort.height);
@@ -4798,17 +4798,17 @@ ScrollFrameHelper::IsScrollingActive(nsD
         mWillBuildScrollableLayer;
 }
 
 /**
  * Reflow the scroll area if it needs it and return its size. Also determine if the reflow will
  * cause any of the scrollbars to need to be reflowed.
  */
 nsresult
-nsXULScrollFrame::Layout(nsBoxLayoutState& aState)
+nsXULScrollFrame::XULLayout(nsBoxLayoutState& aState)
 {
   bool scrollbarRight = IsScrollbarOnRight();
   bool scrollbarBottom = true;
 
   // get the content rect
   nsRect clientRect(0,0,0,0);
   GetClientRect(clientRect);
 
diff --git a/layout/generic/nsGfxScrollFrame.h b/layout/generic/nsGfxScrollFrame.h
--- a/layout/generic/nsGfxScrollFrame.h
+++ b/layout/generic/nsGfxScrollFrame.h
@@ -1132,17 +1132,17 @@ public:
   NS_IMETHOD DoLayout(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsresult GetPadding(nsMargin& aPadding) override;
 
   virtual bool GetBorderRadii(const nsSize& aFrameSize, const nsSize& aBorderArea,
                               Sides aSkipSides, nscoord aRadii[8]) const override {
     return mHelper.GetBorderRadii(aFrameSize, aBorderArea, aSkipSides, aRadii);
   }
 
-  nsresult Layout(nsBoxLayoutState& aState);
+  nsresult XULLayout(nsBoxLayoutState& aState);
   void LayoutScrollArea(nsBoxLayoutState& aState, const nsPoint& aScrollPosition);
 
   static bool AddRemoveScrollbar(bool& aHasScrollbar, 
                                    nscoord& aXY, 
                                    nscoord& aSize, 
                                    nscoord aSbSize, 
                                    bool aOnRightOrBottom, 
                                    bool aAdd);
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2898,22 +2898,22 @@ public:
   // Implemented in nsBox, used in nsBoxFrame
   uint32_t GetXULOrdinal();
 
   virtual nscoord GetXULFlex() = 0;
   virtual nscoord GetXULBoxAscent(nsBoxLayoutState& aBoxLayoutState) = 0;
   virtual bool IsXULCollapsed() = 0;
   // This does not alter the overflow area. If the caller is changing
   // the box size, the caller is responsible for updating the overflow
-  // area. It's enough to just call Layout or SyncLayout on the
+  // area. It's enough to just call XULLayout or SyncLayout on the
   // box. You can pass true to aRemoveOverflowArea as a
   // convenience.
   virtual void SetXULBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
                             bool aRemoveOverflowAreas = false) = 0;
-  nsresult Layout(nsBoxLayoutState& aBoxLayoutState);
+  nsresult XULLayout(nsBoxLayoutState& aBoxLayoutState);
   // Box methods.  Note that these do NOT just get the CSS border, padding,
   // etc.  They also talk to nsITheme.
   virtual nsresult GetBorderAndPadding(nsMargin& aBorderAndPadding);
   virtual nsresult GetBorder(nsMargin& aBorder)=0;
   virtual nsresult GetPadding(nsMargin& aBorderAndPadding)=0;
   virtual nsresult GetMargin(nsMargin& aMargin)=0;
   virtual void SetLayoutManager(nsBoxLayout* aLayout) { }
   virtual nsBoxLayout* GetLayoutManager() { return nullptr; }
diff --git a/layout/xul/grid/nsGridLayout2.cpp b/layout/xul/grid/nsGridLayout2.cpp
--- a/layout/xul/grid/nsGridLayout2.cpp
+++ b/layout/xul/grid/nsGridLayout2.cpp
@@ -42,23 +42,23 @@ nsGridLayout2::AddOffset(nsIFrame* aChil
 {
   nsMargin offset;
   GetOffset(aChild, offset);
   aSize.width += offset.left;
   aSize.height += offset.top;
 }
 
 NS_IMETHODIMP
-nsGridLayout2::Layout(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
+nsGridLayout2::XULLayout(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
 {
   // XXX This should be set a better way!
   mGrid.SetBox(aBox);
   NS_ASSERTION(aBox->GetLayoutManager() == this, "setting incorrect box");
 
-  nsresult rv = nsStackLayout::Layout(aBox, aBoxLayoutState);
+  nsresult rv = nsStackLayout::XULLayout(aBox, aBoxLayoutState);
 #ifdef DEBUG_grid
   mGrid.PrintCellMap();
 #endif
   return rv;
 }
 
 void
 nsGridLayout2::IntrinsicISizesDirty(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
diff --git a/layout/xul/grid/nsGridLayout2.h b/layout/xul/grid/nsGridLayout2.h
--- a/layout/xul/grid/nsGridLayout2.h
+++ b/layout/xul/grid/nsGridLayout2.h
@@ -25,17 +25,17 @@ class nsGridLayout2 final : public nsSta
                             public nsIGridPart
 {
 public:
 
   friend nsresult NS_NewGridLayout2(nsIPresShell* aPresShell, nsBoxLayout** aNewLayout);
 
   NS_DECL_ISUPPORTS_INHERITED
 
-  NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
+  NS_IMETHOD XULLayout(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual void IntrinsicISizesDirty(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual nsGridRowGroupLayout* CastToRowGroupLayout() override { return nullptr; }
   virtual nsGridLayout2* CastToGridLayout() override { return this; }
   virtual nsGrid* GetGrid(nsIFrame* aBox, int32_t* aIndex, nsGridRowLayout* aRequestor=nullptr) override;
   virtual nsIGridPart* GetParentGridPart(nsIFrame* aBox, nsIFrame** aParentBox) override {
     NS_NOTREACHED("Should not be called"); return nullptr;
   }
diff --git a/layout/xul/grid/nsGridRowLeafLayout.cpp b/layout/xul/grid/nsGridRowLeafLayout.cpp
--- a/layout/xul/grid/nsGridRowLeafLayout.cpp
+++ b/layout/xul/grid/nsGridRowLeafLayout.cpp
@@ -272,19 +272,19 @@ nsGridRowLeafLayout::ComputeChildSizes(n
     }
   }
       
   nsSprocketLayout::ComputeChildSizes(aBox, aState, aGivenSize, aBoxSizes, aComputedBoxSizes);
 
 }
 
 NS_IMETHODIMP
-nsGridRowLeafLayout::Layout(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
+nsGridRowLeafLayout::XULLayout(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
 {
-  return nsGridRowLayout::Layout(aBox, aBoxLayoutState);
+  return nsGridRowLayout::XULLayout(aBox, aBoxLayoutState);
 }
 
 void
 nsGridRowLeafLayout::DirtyRows(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   if (aBox) {
     // mark us dirty
     // XXXldb We probably don't want to walk up the ancestor chain
diff --git a/layout/xul/grid/nsGridRowLeafLayout.h b/layout/xul/grid/nsGridRowLeafLayout.h
--- a/layout/xul/grid/nsGridRowLeafLayout.h
+++ b/layout/xul/grid/nsGridRowLeafLayout.h
@@ -27,17 +27,17 @@ class nsGridRowLeafLayout final : public
 public:
 
   friend already_AddRefed<nsBoxLayout> NS_NewGridRowLeafLayout();
 
   virtual nsSize GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual void ChildAddedOrRemoved(nsIFrame* aBox, nsBoxLayoutState& aState) override;
-  NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
+  NS_IMETHOD XULLayout(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual void CountRowsColumns(nsIFrame* aBox, int32_t& aRowCount, int32_t& aComputedColumnCount) override;
   virtual void DirtyRows(nsIFrame* aBox, nsBoxLayoutState& aState) override;
   virtual int32_t BuildRows(nsIFrame* aBox, nsGridRow* aRows) override;
   virtual Type GetType() override { return eRowLeaf; }
 
 protected:
 
   virtual void PopulateBoxSizes(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState,
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -117,17 +117,17 @@ nsBox::GetBoxName(nsAutoString& aName)
 #endif
 
 nsresult
 nsBox::BeginLayout(nsBoxLayoutState& aState)
 {
 #ifdef DEBUG_LAYOUT 
 
   nsBoxAddIndents();
-  printf("Layout: ");
+  printf("XULLayout: ");
   DumpBox(stdout);
   printf("\n");
   gIndent++;
 #endif
 
   // mark ourselves as dirty so no child under us
   // can post an incremental layout.
   // XXXldb Is this still needed?
@@ -492,17 +492,17 @@ nsBox::GetXULBoxAscent(nsBoxLayoutState&
 
 bool
 nsBox::IsXULCollapsed()
 {
   return StyleVisibility()->mVisible == NS_STYLE_VISIBILITY_COLLAPSE;
 }
 
 nsresult
-nsIFrame::Layout(nsBoxLayoutState& aState)
+nsIFrame::XULLayout(nsBoxLayoutState& aState)
 {
   NS_ASSERTION(aState.GetRenderingContext(), "must have rendering context");
 
   nsBox *box = static_cast<nsBox*>(this);
   DISPLAY_LAYOUT(box);
 
   box->BeginLayout(aState);
 
diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -701,17 +701,17 @@ nsBoxFrame::Reflow(nsPresContext*       
   }
 
   nsSize physicalSize = computedSize.GetPhysicalSize(wm);
   nsRect r(mRect.x, mRect.y, physicalSize.width, physicalSize.height);
 
   SetXULBounds(state, r);
  
   // layout our children
-  Layout(state);
+  XULLayout(state);
   
   // ok our child could have gotten bigger. So lets get its bounds
   
   // get the ascent
   LogicalSize boxSize = GetLogicalSize(wm);
   nscoord ascent = boxSize.BSize(wm);
 
   // getting the ascent could be a lot of work. Don't get it if
@@ -905,17 +905,17 @@ NS_IMETHODIMP
 nsBoxFrame::DoLayout(nsBoxLayoutState& aState)
 {
   uint32_t oldFlags = aState.LayoutFlags();
   aState.SetLayoutFlags(0);
 
   nsresult rv = NS_OK;
   if (mLayoutManager) {
     CoordNeedsRecalc(mAscent);
-    rv = mLayoutManager->Layout(this, aState);
+    rv = mLayoutManager->XULLayout(this, aState);
   }
 
   aState.SetLayoutFlags(oldFlags);
 
   if (HasAbsolutelyPositionedChildren()) {
     // Set up a |reflowState| to pass into ReflowAbsoluteFrames
     WritingMode wm = GetWritingMode();
     nsHTMLReflowState reflowState(aState.PresContext(), this,
@@ -1924,17 +1924,17 @@ nsBoxFrame::LayoutChildAt(nsBoxLayoutSta
 {
   // get the current rect
   nsRect oldRect(aBox->GetRect());
   aBox->SetXULBounds(aState, aRect);
 
   bool layout = NS_SUBTREE_DIRTY(aBox);
   
   if (layout || (oldRect.width != aRect.width || oldRect.height != aRect.height))  {
-    return aBox->Layout(aState);
+    return aBox->XULLayout(aState);
   }
 
   return NS_OK;
 }
 
 nsresult
 nsBoxFrame::RelayoutChildAtOrdinal(nsIFrame* aChild)
 {
diff --git a/layout/xul/nsBoxLayout.cpp b/layout/xul/nsBoxLayout.cpp
--- a/layout/xul/nsBoxLayout.cpp
+++ b/layout/xul/nsBoxLayout.cpp
@@ -61,17 +61,17 @@ nsBoxLayout::GetXULMaxSize(nsIFrame* aBo
 
 nscoord
 nsBoxLayout::GetAscent(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
 {
   return 0;
 }
 
 NS_IMETHODIMP
-nsBoxLayout::Layout(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
+nsBoxLayout::XULLayout(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
 {
   return NS_OK;
 }
 
 void
 nsBoxLayout::AddLargestSize(nsSize& aSize, const nsSize& aSize2)
 {
   if (aSize2.width > aSize.width)
diff --git a/layout/xul/nsBoxLayout.h b/layout/xul/nsBoxLayout.h
--- a/layout/xul/nsBoxLayout.h
+++ b/layout/xul/nsBoxLayout.h
@@ -29,17 +29,17 @@ protected:
 public:
 
   nsBoxLayout() {}
 
   NS_DECL_ISUPPORTS
 
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_BOX_LAYOUT_IID)
 
-  NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aState);
+  NS_IMETHOD XULLayout(nsIFrame* aBox, nsBoxLayoutState& aState);
 
   virtual nsSize GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState);
   virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState);
   virtual nsSize GetXULMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState);
   virtual nscoord GetAscent(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState);
   virtual void ChildrenInserted(nsIFrame* aBox, nsBoxLayoutState& aState,
                                 nsIFrame* aPrevBox,
                                 const nsFrameList::Slice& aNewChildren) {}
diff --git a/layout/xul/nsLeafBoxFrame.cpp b/layout/xul/nsLeafBoxFrame.cpp
--- a/layout/xul/nsLeafBoxFrame.cpp
+++ b/layout/xul/nsLeafBoxFrame.cpp
@@ -296,17 +296,17 @@ nsLeafBoxFrame::Reflow(nsPresContext*   
                                       aReflowState.ComputedMaxHeight());
   computedSize.height += m.TopBottom();
 
   nsRect r(mRect.x, mRect.y, computedSize.width, computedSize.height);
 
   SetXULBounds(state, r);
  
   // layout our children
-  Layout(state);
+  XULLayout(state);
   
   // ok our child could have gotten bigger. So lets get its bounds
   aDesiredSize.Width() = mRect.width;
   aDesiredSize.Height() = mRect.height;
   aDesiredSize.SetBlockStartAscent(GetXULBoxAscent(state));
 
   // the overflow rect is set in SetXULBounds() above
   aDesiredSize.mOverflowAreas = GetOverflowAreas();
diff --git a/layout/xul/nsListBoxLayout.cpp b/layout/xul/nsListBoxLayout.cpp
--- a/layout/xul/nsListBoxLayout.cpp
+++ b/layout/xul/nsListBoxLayout.cpp
@@ -88,17 +88,17 @@ nsListBoxLayout::GetXULMaxSize(nsIFrame*
       nscoord remainder = m == 0 ? 0 : rowheight - m;
       maxSize.height += remainder;
     }
   }
   return maxSize;
 }
 
 NS_IMETHODIMP
-nsListBoxLayout::Layout(nsIFrame* aBox, nsBoxLayoutState& aState)
+nsListBoxLayout::XULLayout(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   return LayoutInternal(aBox, aState);
 }
 
 
 /////////// nsListBoxLayout /////////////////////////
 
 /**
@@ -157,17 +157,17 @@ nsListBoxLayout::LayoutInternal(nsIFrame
       
       nsSize size = box->GetXULPrefSize(aState);
       body->SetRowHeight(size.height);
       
       childRect.height = rowHeight;
 
       childRect.Deflate(margin);
       box->SetXULBounds(aState, childRect);
-      box->Layout(aState);
+      box->XULLayout(aState);
     } else {
       // if the child did not need to be relayed out. Then its easy.
       // Place the child by just grabbing its rect and adjusting the y.
       int32_t newPos = yOffset+margin.top;
 
       // are we pushing down or pulling up any rows?
       // Then we may have to redraw everything below the moved 
       // rows.
diff --git a/layout/xul/nsListBoxLayout.h b/layout/xul/nsListBoxLayout.h
--- a/layout/xul/nsListBoxLayout.h
+++ b/layout/xul/nsListBoxLayout.h
@@ -14,17 +14,17 @@ typedef class nsIFrame nsIFrame;
 class nsBoxLayoutState;
 
 class nsListBoxLayout : public nsGridRowGroupLayout
 {
 public:
   nsListBoxLayout();
 
   // nsBoxLayout
-  NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aState) override;
+  NS_IMETHOD XULLayout(nsIFrame* aBox, nsBoxLayoutState& aState) override;
   virtual nsSize GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
 
 protected:
   NS_IMETHOD LayoutInternal(nsIFrame* aBox, nsBoxLayoutState& aState);
 };
 
diff --git a/layout/xul/nsMenuPopupFrame.cpp b/layout/xul/nsMenuPopupFrame.cpp
--- a/layout/xul/nsMenuPopupFrame.cpp
+++ b/layout/xul/nsMenuPopupFrame.cpp
@@ -476,17 +476,17 @@ nsMenuPopupFrame::LayoutPopup(nsBoxLayou
   bool needCallback = false;
 
   if (shouldPosition) {
     SetPopupPosition(aAnchor, false, aSizedToPopup);
     needCallback = true;
   }
 
   nsRect bounds(GetRect());
-  Layout(aState);
+  XULLayout(aState);
 
   // if the width or height changed, readjust the popup position. This is a
   // special case for tooltips where the preferred height doesn't include the
   // real height for its inline element, but does once it is laid out.
   // This is bug 228673 which doesn't have a simple fix.
   if (!aParentMenu) {
     nsSize newsize = GetSize();
     if (newsize.width > bounds.width || newsize.height > bounds.height) {
diff --git a/layout/xul/nsSprocketLayout.cpp b/layout/xul/nsSprocketLayout.cpp
--- a/layout/xul/nsSprocketLayout.cpp
+++ b/layout/xul/nsSprocketLayout.cpp
@@ -163,17 +163,17 @@ HandleBoxPack(nsIFrame* aBox, const nsFr
         else
           aY -= (aOriginalRect.height - aClientRect.height);
         break;
     }
   }
 }
 
 NS_IMETHODIMP
-nsSprocketLayout::Layout(nsIFrame* aBox, nsBoxLayoutState& aState)
+nsSprocketLayout::XULLayout(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   // See if we are collapsed. If we are, then simply iterate over all our
   // children and give them a rect of 0 width and height.
   if (aBox->IsXULCollapsed()) {
     nsIFrame* child = nsBox::GetChildBox(aBox);
     while(child) 
     {
       nsBoxFrame::LayoutChildAt(aState, child, nsRect(0,0,0,0));  
@@ -425,17 +425,17 @@ nsSprocketLayout::Layout(nsIFrame* aBox,
       child->GetMargin(margin);
       childRect.Deflate(margin);
       if (childRect.width < 0)
         childRect.width = 0;
       if (childRect.height < 0)
         childRect.height = 0;
 
       // Now we're trying to figure out if we have to lay out this child, i.e., to call
-      // the child's Layout method.
+      // the child's XULLayout method.
       if (passes > 0) {
         layout = false;
       } else {
         // Always perform layout if we are dirty or have dirty children
         if (!NS_SUBTREE_DIRTY(child))
           layout = false;
       }
 
@@ -476,17 +476,17 @@ nsSprocketLayout::Layout(nsIFrame* aBox,
         // set it again
         child->SetXULBounds(aState, childRect);
       }
 
       // If we already determined that layout was required or if our size has changed, then
       // we make sure to call layout on the child, since its children may need to be shifted
       // around as a result of the size change.
       if (layout || sizeChanged)
-        child->Layout(aState);
+        child->XULLayout(aState);
       
       // If the child was a block or inline (e.g., HTML) it may have changed its rect *during* layout. 
       // We have to check for this.
       nsRect newChildRect(child->GetRect());
 
       if (!newChildRect.IsEqualInterior(childRect)) {
 #ifdef DEBUG_GROW
         child->DumpBox(stdout);
@@ -1131,17 +1131,17 @@ nsSprocketLayout::ChildResized(nsIFrame*
         // the bounds.
         nsMargin margin(0,0,0,0);
         aChild->GetMargin(margin);
         nsRect rect(aChildActualRect);
         if (rect.width >= margin.left + margin.right && rect.height >= margin.top + margin.bottom) 
           rect.Deflate(margin);
 
         aChild->SetXULBounds(aState, rect);
-        aChild->Layout(aState);
+        aChild->XULLayout(aState);
       }
 
 }
 
 void
 nsSprocketLayout::InvalidateComputedSizes(nsComputedBoxSize* aComputedBoxSizes)
 {
   while(aComputedBoxSizes) {
diff --git a/layout/xul/nsSprocketLayout.h b/layout/xul/nsSprocketLayout.h
--- a/layout/xul/nsSprocketLayout.h
+++ b/layout/xul/nsSprocketLayout.h
@@ -63,17 +63,17 @@ nsresult NS_NewSprocketLayout(nsCOMPtr<n
 
 class nsSprocketLayout : public nsBoxLayout {
 
 public:
 
   friend nsresult NS_NewSprocketLayout(nsCOMPtr<nsBoxLayout>& aNewLayout);
   static void Shutdown();
 
-  NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aState) override;
+  NS_IMETHOD XULLayout(nsIFrame* aBox, nsBoxLayoutState& aState) override;
 
   virtual nsSize GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetAscent(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
 
   nsSprocketLayout();
 
diff --git a/layout/xul/nsStackLayout.cpp b/layout/xul/nsStackLayout.cpp
--- a/layout/xul/nsStackLayout.cpp
+++ b/layout/xul/nsStackLayout.cpp
@@ -247,17 +247,17 @@ nsStackLayout::GetOffset(nsIFrame* aChil
     aChild->AddStateBits(NS_STATE_STACK_NOT_POSITIONED);
   }
 
   return offsetSpecified;
 }
 
 
 NS_IMETHODIMP
-nsStackLayout::Layout(nsIFrame* aBox, nsBoxLayoutState& aState)
+nsStackLayout::XULLayout(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   nsRect clientRect;
   aBox->GetClientRect(clientRect);
 
   bool grow;
 
   do {
     nsIFrame* child = nsBox::GetChildBox(aBox);
@@ -334,17 +334,17 @@ nsStackLayout::Layout(nsIFrame* aBox, ns
               childRect.y = clientRect.YMost() - offset.bottom - margin.bottom - childRect.height;
             }
           }
 
           // Now place the child.
           child->SetXULBounds(aState, childRect);
 
           // Flow the child.
-          child->Layout(aState);
+          child->XULLayout(aState);
 
           // Get the child's new rect.
           childRect = child->GetRect();
           childRect.Inflate(margin);
 
           if (child->StyleXUL()->mStretchStack) {
             // Did the child push back on us and get bigger?
             if (offset.LeftRight() + childRect.width > clientRect.width) {
diff --git a/layout/xul/nsStackLayout.h b/layout/xul/nsStackLayout.h
--- a/layout/xul/nsStackLayout.h
+++ b/layout/xul/nsStackLayout.h
@@ -27,17 +27,17 @@ class nsStackLayout : public nsBoxLayout
 {
 public:
 
   friend nsresult NS_NewStackLayout(nsCOMPtr<nsBoxLayout>& aNewLayout);
   static void Shutdown();
 
   nsStackLayout();
 
-  NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aState) override;
+  NS_IMETHOD XULLayout(nsIFrame* aBox, nsBoxLayoutState& aState) override;
 
   virtual nsSize GetXULPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetAscent(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
 
   // get the child offsets for aChild and set them in aMargin. Returns a
   // bitfield mask of the SPECIFIED_LEFT, SPECIFIED_RIGHT, SPECIFIED_TOP and
