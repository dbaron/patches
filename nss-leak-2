From: Nelson Bolyard <nelson@bolyard.com>

Fix leak of slots when destroying tokens.  b=391903

diff --git a/security/nss/lib/dev/devtoken.c b/security/nss/lib/dev/devtoken.c
--- a/security/nss/lib/dev/devtoken.c
+++ b/security/nss/lib/dev/devtoken.c
@@ -65,16 +65,20 @@ nssToken_Destroy (
 nssToken_Destroy (
   NSSToken *tok
 )
 {
     if (tok) {
 	if (PR_AtomicDecrement(&tok->base.refCount) == 0) {
 	    PZ_DestroyLock(tok->base.lock);
 	    nssTokenObjectCache_Destroy(tok->cache);
+	    /* The token holds the first/last reference to the slot.
+	     * When the token is actually destroyed, that ref must go too.
+	     */
+	    (void)nssSlot_Destroy(tok->slot);
 	    return nssArena_Destroy(tok->base.arena);
 	}
     }
     return PR_SUCCESS;
 }
 
 NSS_IMPLEMENT void
 nssToken_Remove (
diff --git a/security/nss/lib/pki/trustdomain.c b/security/nss/lib/pki/trustdomain.c
--- a/security/nss/lib/pki/trustdomain.c
+++ b/security/nss/lib/pki/trustdomain.c
@@ -96,18 +96,20 @@ loser:
     nssArena_Destroy(arena);
     return (NSSTrustDomain *)NULL;
 }
 
 static void
 token_destructor(void *t)
 {
     NSSToken *tok = (NSSToken *)t;
-    /* in 3.4, also destroy the slot (managed separately) */
-    (void)nssSlot_Destroy(tok->slot);
+    /* The token holds the first/last reference to the slot.
+     * When the token is actually destroyed (ref count == 0), 
+     * the slot will also be destroyed.
+     */
     nssToken_Destroy(tok);
 }
 
 NSS_IMPLEMENT PRStatus
 NSSTrustDomain_Destroy (
   NSSTrustDomain *td
 )
 {
