From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Track whether there are any pending non-animation restyles.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -54,16 +54,17 @@ RestyleManager::RestyleManager(nsPresCon
   , mRebuildAllExtraHint(nsChangeHint(0))
   , mLastUpdateForThrottledAnimations(aPresContext->RefreshDriver()->
                                         MostRecentRefresh())
   , mAnimationGeneration(0)
   , mPendingRestyles(ELEMENT_HAS_PENDING_RESTYLE |
                      ELEMENT_IS_POTENTIAL_RESTYLE_ROOT)
   , mPendingAnimationRestyles(ELEMENT_HAS_PENDING_ANIMATION_RESTYLE |
                               ELEMENT_IS_POTENTIAL_ANIMATION_RESTYLE_ROOT)
+  , mHavePendingNonAnimationRestyles(false)
 {
   mPendingRestyles.Init(this);
   mPendingAnimationRestyles.Init(this);
 }
 
 void
 RestyleManager::NotifyDestroyingFrame(nsIFrame* aFrame)
 {
@@ -1460,16 +1461,18 @@ RestyleManager::ProcessPendingRestyles()
   mPendingAnimationRestyles.ProcessRestyles();
   mPresContext->SetProcessingAnimationStyleChange(false);
 
   mPresContext->SetProcessingRestyles(false);
   NS_POSTCONDITION(mPendingRestyles.Count() == oldPendingRestyleCount,
                    "We should not have posted new non-animation restyles while "
                    "processing animation restyles");
 
+  mHavePendingNonAnimationRestyles = false;
+
   if (mRebuildAllStyleData) {
     // We probably wasted a lot of work up above, but this seems safest
     // and it should be rarely used.
     // This might add us as a refresh observer again; that's ok.
     RebuildAllStyleData(nsChangeHint(0));
   }
 }
 
@@ -1543,16 +1546,20 @@ RestyleManager::PostRestyleEventCommon(E
     // Nothing to do here
     return;
   }
 
   RestyleTracker& tracker =
     aForAnimation ? mPendingAnimationRestyles : mPendingRestyles;
   tracker.AddPendingRestyle(aElement, aRestyleHint, aMinChangeHint);
 
+  if (aRestyleHint & ~(eRestyle_CSSTransitions | eRestyle_CSSAnimations)) {
+    mHavePendingNonAnimationRestyles = true;
+  }
+
   PostRestyleEventInternal(false);
 }
 
 void
 RestyleManager::PostRestyleEventInternal(bool aForLazyConstruction)
 {
   // Make sure we're not in a style refresh; if we are, we still have
   // a call to ProcessPendingRestyles coming and there's no need to
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -297,16 +297,17 @@ private:
   OverflowChangedTracker mOverflowChangedTracker;
 
   // The total number of animation flushes by this frame constructor.
   // Used to keep the layer and animation manager in sync.
   uint64_t mAnimationGeneration;
 
   RestyleTracker mPendingRestyles;
   RestyleTracker mPendingAnimationRestyles;
+  bool mHavePendingNonAnimationRestyles;
 };
 
 /**
  * An ElementRestyler is created for *each* element in a subtree that we
  * recompute styles for.
  */
 class ElementRestyler MOZ_FINAL {
 public:
