From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Use a RestyleTracker for the coalescing in the miniflush (animation-only style flush).

This changes the coalescing behavior during the animation-only style
flush by doing tree-based coalescing between the style updates required
by animations and those required by transitions, rather than doing
animations and transitions separately.

Note that both the old and the new code update all
animating/transitioning styles rather than only the throttled styles,
though we should fix that (but only for the existing caller, and not
for the new one).

FIXME:  The RestyleTracker's code is pessimistic in some cases, which is
bad for this case, where we actually need to not be pessimistic.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1470,18 +1470,28 @@ void
 RestyleManager::UpdateOnlyAnimationStyles()
 {
   TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
   if (mLastUpdateForThrottledAnimations == now) {
     return;
   }
   mLastUpdateForThrottledAnimations = now;
 
-  mPresContext->TransitionManager()->UpdateAllThrottledStyles();
-  mPresContext->AnimationManager()->UpdateAllThrottledStyles();
+  RestyleTracker tracker(ELEMENT_HAS_PENDING_ANIMATION_ONLY_RESTYLE |
+                         ELEMENT_IS_POTENTIAL_ANIMATION_ONLY_RESTYLE_ROOT);
+  tracker.Init(this);
+
+  // FIXME:  We should have the transition manager and animation manager
+  // add only the elements for which animations are currently throttled
+  // (i.e., animating on the compositor with main-thread style updates
+  // suppressed).
+  mPresContext->TransitionManager()->AddStyleUpdatesTo(tracker);
+  mPresContext->AnimationManager()->AddStyleUpdatesTo(tracker);
+
+  tracker.ProcessRestyles();
 }
 
 void
 RestyleManager::PostRestyleEventCommon(Element* aElement,
                                        nsRestyleHint aRestyleHint,
                                        nsChangeHint aMinChangeHint,
                                        bool aForAnimation)
 {
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -1187,8 +1187,28 @@ nsAnimationManager::UpdateAllThrottledSt
   if (PR_CLIST_IS_EMPTY(&mElementData)) {
     // no throttled animations, leave early
     return;
   }
 
   UpdateAllThrottledStylesInternal();
 }
 
+void
+nsAnimationManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
+{
+  PRCList *next = PR_LIST_HEAD(&mElementData);
+  while (next != &mElementData) {
+    ElementAnimations *ea = static_cast<ElementAnimations*>(next);
+    next = PR_NEXT_LINK(next);
+
+    if (ea->mElementProperty != nsGkAtoms::animationsProperty) {
+      // We don't support compositor-driven animation of :before/:after
+      // transitions, so at least skip those.
+      // FIXME: We'll need to handle this before using this for the
+      // transitions redesign.
+      continue;
+    }
+
+    aTracker.AddPendingRestyle(ea->mElement, eRestyle_CSSAnimations,
+                               nsChangeHint(0));
+  }
+}
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -11,16 +11,17 @@
 #include "nsCSSPseudoElements.h"
 #include "mozilla/MemoryReporting.h"
 #include "mozilla/TimeStamp.h"
 
 class nsCSSKeyframesRule;
 class nsStyleContext;
 
 namespace mozilla {
+class RestyleTracker;
 namespace css {
 class Declaration;
 }
 }
 
 struct AnimationEventInfo {
   nsRefPtr<mozilla::dom::Element> mElement;
   mozilla::InternalAnimationEvent mEvent;
@@ -286,16 +287,21 @@ public:
       DoDispatchEvents();
     }
   }
 
   ElementAnimations* GetElementAnimations(mozilla::dom::Element *aElement,
                                           nsCSSPseudoElements::Type aPseudoType,
                                           bool aCreateIfNeeded);
 
+  // Tell the restyle tracker about all the styles that we're currently
+  // animating, so that it can update the animation rule for these
+  // elements.
+  void AddStyleUpdatesTo(mozilla::RestyleTracker& aTracker);
+
   // Updates styles on throttled animations. See note on nsTransitionManager
   void UpdateAllThrottledStyles();
 
 protected:
   virtual void ElementDataRemoved() MOZ_OVERRIDE
   {
     CheckNeedsRefresh();
   }
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -256,16 +256,37 @@ nsTransitionManager::UpdateAllThrottledS
     // no throttled transitions, leave early
     return;
   }
 
   UpdateAllThrottledStylesInternal();
 }
 
 void
+nsTransitionManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
+{
+  PRCList *next = PR_LIST_HEAD(&mElementData);
+  while (next != &mElementData) {
+    ElementTransitions *et = static_cast<ElementTransitions*>(next);
+    next = PR_NEXT_LINK(next);
+
+    if (et->mElementProperty != nsGkAtoms::transitionsProperty) {
+      // We don't support compositor-driven animation of :before/:after
+      // transitions, so at least skip those.
+      // FIXME: We'll need to handle this before using this for the
+      // transitions redesign.
+      continue;
+    }
+
+    aTracker.AddPendingRestyle(et->mElement, eRestyle_CSSTransitions,
+                               nsChangeHint(0));
+  }
+}
+
+void
 nsTransitionManager::ElementDataRemoved()
 {
   // If we have no transitions or animations left, remove ourselves from
   // the refresh driver.
   if (PR_CLIST_IS_EMPTY(&mElementData)) {
     mPresContext->RefreshDriver()->RemoveRefreshObserver(this, Flush_Style);
   }
 }
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
--- a/layout/style/nsTransitionManager.h
+++ b/layout/style/nsTransitionManager.h
@@ -14,16 +14,20 @@
 #include "nsCSSPseudoElements.h"
 
 class nsStyleContext;
 class nsPresContext;
 class nsCSSPropertySet;
 struct nsTransition;
 struct ElementDependentRuleProcessorData;
 
+namespace mozilla {
+class RestyleTracker;
+}
+
 /*****************************************************************************
  * Per-Element data                                                          *
  *****************************************************************************/
 
 struct ElementPropertyTransition
 {
   ElementPropertyTransition() 
     : mIsRunningOnCompositor(false)
@@ -186,16 +190,21 @@ public:
   virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
     MOZ_MUST_OVERRIDE MOZ_OVERRIDE;
 
   // nsARefreshObserver
   virtual void WillRefresh(mozilla::TimeStamp aTime) MOZ_OVERRIDE;
 
   void FlushTransitions(FlushFlags aFlags);
 
+  // Tell the restyle tracker about all the styles that we're currently
+  // transitioning, so that it can update the animation rule for these
+  // elements.
+  void AddStyleUpdatesTo(mozilla::RestyleTracker& aTracker);
+
   // Performs a 'mini-flush' to make styles from throttled transitions
   // up-to-date prior to processing an unrelated style change, so that
   // any transitions triggered by that style change produce correct
   // results.
   //
   // In more detail:  when we're able to run animations on the
   // compositor, we sometimes "throttle" these animations by skipping
   // updating style data on the main thread.  However, whenever we
