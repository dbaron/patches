From: L. David Baron <dbaron@dbaron.org>

Bug 996796 patch 19 - Use a RestyleTracker for the coalescing in the animation-only style flush (miniflush).

This changes the coalescing behavior during the animation-only style
flush by doing tree-based coalescing between the style updates required
by animations and those required by transitions, rather than doing
animations and transitions separately.

Note that both the old and the new code update all
animating/transitioning styles rather than only the throttled styles,
though we should fix that eventually as noted in the FIXME comment in
the code (but only for the existing caller, and not for the new one to
be introduced in bug 960465).

Note that this depends for its correctness on the previous patches to
make the restyling process exact.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1551,18 +1551,28 @@ RestyleManager::UpdateOnlyAnimationStyle
   }
   mLastUpdateForThrottledAnimations = now;
 
   nsTransitionManager* transitionManager = mPresContext->TransitionManager();
   nsAnimationManager* animationManager = mPresContext->AnimationManager();
 
   transitionManager->SetInAnimationOnlyStyleUpdate(true);
 
-  transitionManager->UpdateAllThrottledStyles();
-  animationManager->UpdateAllThrottledStyles();
+  RestyleTracker tracker(ELEMENT_HAS_PENDING_ANIMATION_ONLY_RESTYLE |
+                         ELEMENT_IS_POTENTIAL_ANIMATION_ONLY_RESTYLE_ROOT);
+  tracker.Init(this);
+
+  // FIXME:  We should have the transition manager and animation manager
+  // add only the elements for which animations are currently throttled
+  // (i.e., animating on the compositor with main-thread style updates
+  // suppressed).
+  transitionManager->AddStyleUpdatesTo(tracker);
+  animationManager->AddStyleUpdatesTo(tracker);
+
+  tracker.ProcessRestyles();
 
   transitionManager->SetInAnimationOnlyStyleUpdate(false);
 }
 
 void
 RestyleManager::PostRestyleEventCommon(Element* aElement,
                                        nsRestyleHint aRestyleHint,
                                        nsChangeHint aMinChangeHint,
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -1123,8 +1123,28 @@ nsAnimationManager::UpdateAllThrottledSt
   if (PR_CLIST_IS_EMPTY(&mElementData)) {
     // no throttled animations, leave early
     return;
   }
 
   UpdateAllThrottledStylesInternal();
 }
 
+void
+nsAnimationManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
+{
+  PRCList *next = PR_LIST_HEAD(&mElementData);
+  while (next != &mElementData) {
+    ElementAnimations *ea = static_cast<ElementAnimations*>(next);
+    next = PR_NEXT_LINK(next);
+
+    if (ea->mElementProperty != nsGkAtoms::animationsProperty) {
+      // We don't support compositor-driven animation of :before/:after
+      // transitions, so at least skip those.
+      // FIXME: We'll need to handle this before using this for the
+      // transitions redesign.
+      continue;
+    }
+
+    aTracker.AddPendingRestyle(ea->mElement, eRestyle_CSSAnimations,
+                               nsChangeHint(0));
+  }
+}
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -11,16 +11,17 @@
 #include "nsCSSPseudoElements.h"
 #include "mozilla/MemoryReporting.h"
 #include "mozilla/TimeStamp.h"
 
 class nsCSSKeyframesRule;
 class nsStyleContext;
 
 namespace mozilla {
+class RestyleTracker;
 namespace css {
 class Declaration;
 }
 }
 
 struct AnimationEventInfo {
   nsRefPtr<mozilla::dom::Element> mElement;
   mozilla::InternalAnimationEvent mEvent;
@@ -190,16 +191,21 @@ public:
       DoDispatchEvents();
     }
   }
 
   ElementAnimations* GetElementAnimations(mozilla::dom::Element *aElement,
                                           nsCSSPseudoElements::Type aPseudoType,
                                           bool aCreateIfNeeded);
 
+  // Tell the restyle tracker about all the styles that we're currently
+  // animating, so that it can update the animation rule for these
+  // elements.
+  void AddStyleUpdatesTo(mozilla::RestyleTracker& aTracker);
+
   // Updates styles on throttled animations. See note on nsTransitionManager
   void UpdateAllThrottledStyles();
 
 protected:
   virtual void ElementDataRemoved() MOZ_OVERRIDE
   {
     CheckNeedsRefresh();
   }
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -267,16 +267,37 @@ nsTransitionManager::UpdateAllThrottledS
     // no throttled transitions, leave early
     return;
   }
 
   UpdateAllThrottledStylesInternal();
 }
 
 void
+nsTransitionManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
+{
+  PRCList *next = PR_LIST_HEAD(&mElementData);
+  while (next != &mElementData) {
+    ElementTransitions *et = static_cast<ElementTransitions*>(next);
+    next = PR_NEXT_LINK(next);
+
+    if (et->mElementProperty != nsGkAtoms::transitionsProperty) {
+      // We don't support compositor-driven animation of :before/:after
+      // transitions, so at least skip those.
+      // FIXME: We'll need to handle this before using this for the
+      // transitions redesign.
+      continue;
+    }
+
+    aTracker.AddPendingRestyle(et->mElement, eRestyle_CSSTransitions,
+                               nsChangeHint(0));
+  }
+}
+
+void
 nsTransitionManager::ElementDataRemoved()
 {
   // If we have no transitions or animations left, remove ourselves from
   // the refresh driver.
   if (PR_CLIST_IS_EMPTY(&mElementData)) {
     mPresContext->RefreshDriver()->RemoveRefreshObserver(this, Flush_Style);
   }
 }
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
--- a/layout/style/nsTransitionManager.h
+++ b/layout/style/nsTransitionManager.h
@@ -14,16 +14,20 @@
 #include "nsCSSPseudoElements.h"
 
 class nsStyleContext;
 class nsPresContext;
 class nsCSSPropertySet;
 struct nsTransition;
 struct ElementDependentRuleProcessorData;
 
+namespace mozilla {
+class RestyleTracker;
+}
+
 /*****************************************************************************
  * Per-Element data                                                          *
  *****************************************************************************/
 
 struct ElementPropertyTransition : public mozilla::ElementAnimation
 {
   virtual ElementPropertyTransition* AsTransition() { return this; }
   virtual const ElementPropertyTransition* AsTransition() const { return this; }
@@ -175,16 +179,21 @@ public:
   virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
     MOZ_MUST_OVERRIDE MOZ_OVERRIDE;
 
   // nsARefreshObserver
   virtual void WillRefresh(mozilla::TimeStamp aTime) MOZ_OVERRIDE;
 
   void FlushTransitions(FlushFlags aFlags);
 
+  // Tell the restyle tracker about all the styles that we're currently
+  // transitioning, so that it can update the animation rule for these
+  // elements.
+  void AddStyleUpdatesTo(mozilla::RestyleTracker& aTracker);
+
   // Performs a 'mini-flush' to make styles from throttled transitions
   // up-to-date prior to processing an unrelated style change, so that
   // any transitions triggered by that style change produce correct
   // results.
   //
   // In more detail:  when we're able to run animations on the
   // compositor, we sometimes "throttle" these animations by skipping
   // updating style data on the main thread.  However, whenever we
