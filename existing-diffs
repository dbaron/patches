diff --git a/accessible/src/atk/nsAccessibleWrap.cpp b/accessible/src/atk/nsAccessibleWrap.cpp
--- a/accessible/src/atk/nsAccessibleWrap.cpp
+++ b/accessible/src/atk/nsAccessibleWrap.cpp
@@ -266,7 +266,7 @@ mai_atk_object_get_type(void)
  * Must keep sychronization with enumerate AtkProperty in 
  * accessible/src/base/nsAccessibleEventData.h
  */
-static char * sAtkPropertyNameArray[PROP_LAST] = {
+static const char * sAtkPropertyNameArray[PROP_LAST] = {
     0,
     "accessible-name",
     "accessible-description",
diff --git a/browser/components/preferences/permissions.xul b/browser/components/preferences/permissions.xul
--- a/browser/components/preferences/permissions.xul
+++ b/browser/components/preferences/permissions.xul
@@ -87,6 +87,7 @@
           onselect="gPermissionManager.onPermissionSelected();">
       <treecols>
         <treecol id="siteCol" label="&treehead.sitename.label;" flex="3"
+                 style="text-align: right"
                 onclick="gPermissionManager.onPermissionSort('rawHost');" persist="width"/>
         <splitter class="tree-splitter"/>
         <treecol id="statusCol" label="&treehead.status.label;" flex="1"
diff --git a/browser/components/preferences/permissionsutils.js b/browser/components/preferences/permissionsutils.js
--- a/browser/components/preferences/permissionsutils.js
+++ b/browser/components/preferences/permissionsutils.js
@@ -87,7 +87,18 @@ var gTreeUtils = {
                   aLastSortColumn, aLastSortAscending) 
   {
     var ascending = (aColumn == aLastSortColumn) ? !aLastSortAscending : true;
-    aDataSet.sort(function (a, b) { return a[aColumn].toLowerCase().localeCompare(b[aColumn].toLowerCase()); });
+    var compareFunc;
+    if (aColumn == "rawHost") {
+      // sort by components of domain name, from last to first
+      compareFunc = function(a, b) {
+        return a[aColumn].toLowerCase().split(".").reverse().join(".").
+          localeCompare(
+            b[aColumn].toLowerCase().split(".").reverse().join("."));
+      };
+    } else {
+      compareFunc = function (a, b) { return a[aColumn].toLowerCase().localeCompare(b[aColumn].toLowerCase()); };
+    }
+    aDataSet.sort(compareFunc);
     if (!ascending)
       aDataSet.reverse();
     
diff --git a/caps/src/nsScriptSecurityManager.cpp b/caps/src/nsScriptSecurityManager.cpp
--- a/caps/src/nsScriptSecurityManager.cpp
+++ b/caps/src/nsScriptSecurityManager.cpp
@@ -3212,7 +3212,9 @@ nsScriptSecurityManager::Observe(nsISupp
                                  const PRUnichar* aMessage)
 {
     nsresult rv = NS_OK;
-    NS_ConvertUTF16toUTF8 messageStr(aMessage);
+    nsCAutoString messageStr;
+    if (aMessage)
+        AppendUTF16toUTF8(aMessage, messageStr);
     const char *message = messageStr.get();
 
     static const char jsPrefix[] = "javascript.";
diff --git a/config/Makefile.in b/config/Makefile.in
--- a/config/Makefile.in
+++ b/config/Makefile.in
@@ -48,11 +48,9 @@ include $(DEPTH)/config/autoconf.mk
 # headers, so that we can use it to set up the wrapped system headers.
 VISIBILITY_FLAGS =
 
-ifneq (,$(CROSS_COMPILE)$(filter-out WINNT OS2,$(OS_ARCH)))
-ifneq ($(OS_ARCH), WINCE)
+ifneq (,$(CROSS_COMPILE)$(filter-out WINCE WINNT OS2,$(OS_ARCH)))
 HOST_PROGRAM	= nsinstall$(HOST_BIN_SUFFIX)
 HOST_CSRCS	= nsinstall.c pathsub.c
-endif
 endif
 
 PLSRCS		= nfspwd.pl revdepth.pl
diff --git a/content/base/src/nsAttrAndChildArray.cpp b/content/base/src/nsAttrAndChildArray.cpp
--- a/content/base/src/nsAttrAndChildArray.cpp
+++ b/content/base/src/nsAttrAndChildArray.cpp
@@ -691,6 +691,9 @@ nsAttrAndChildArray::MakeMappedUnique(ns
   if (!aAttributes->GetStyleSheet()) {
     // This doesn't currently happen, but it could if we do loading right
 
+    // XXXldb We shouldn't try to handle this gracefully, since it
+    // should never happen.  But it seems to.
+    //NS_NOTREACHED("no style sheet");
     nsRefPtr<nsMappedAttributes> mapped(aAttributes);
     mapped.swap(mImpl->mMappedAttrs);
 
diff --git a/content/base/src/nsDocument.cpp b/content/base/src/nsDocument.cpp
--- a/content/base/src/nsDocument.cpp
+++ b/content/base/src/nsDocument.cpp
@@ -5475,6 +5475,7 @@ nsDocument::CanSavePresentation(nsIReque
 nsDocument::CanSavePresentation(nsIRequest *aNewRequest)
 {
   // Check our event listener manager for unload/beforeunload listeners.
+  // XXX What about listeners on the document rather than the window?
   nsCOMPtr<nsPIDOMEventTarget> piTarget = do_QueryInterface(mScriptGlobalObject);
   if (piTarget) {
     nsCOMPtr<nsIEventListenerManager> manager;
diff --git a/content/base/src/nsFrameLoader.cpp b/content/base/src/nsFrameLoader.cpp
--- a/content/base/src/nsFrameLoader.cpp
+++ b/content/base/src/nsFrameLoader.cpp
@@ -373,6 +373,9 @@ nsFrameLoader::EnsureDocShell()
 
       PRBool is_primary = value.LowerCaseEqualsLiteral("content-primary");
 
+        // Old comment, is it still valid?
+        // XXXldb This is inconsistent with the conditions under which
+        // nsFrame
       if (parentTreeOwner) {
         PRBool is_targetable = is_primary ||
           value.LowerCaseEqualsLiteral("content-targetable");
diff --git a/content/html/content/src/nsHTMLSelectElement.cpp b/content/html/content/src/nsHTMLSelectElement.cpp
--- a/content/html/content/src/nsHTMLSelectElement.cpp
+++ b/content/html/content/src/nsHTMLSelectElement.cpp
@@ -1806,8 +1806,10 @@ void
 void
 nsHTMLSelectElement::VerifyOptionsArray()
 {
+#ifndef DEBUG_dbaron // This is really really slow on long selects!
   PRInt32 aIndex = 0;
   VerifyOptionsRecurse(this, aIndex, mOptions);
+#endif
 }
 
 
diff --git a/content/xbl/src/nsBindingManager.cpp b/content/xbl/src/nsBindingManager.cpp
--- a/content/xbl/src/nsBindingManager.cpp
+++ b/content/xbl/src/nsBindingManager.cpp
@@ -1289,6 +1289,9 @@ nsBindingManager::WalkRules(nsStyleSet* 
                              
       break; // The anonymous content case is often deliberately hacked to
              // return itself to cut off style inheritance here.  Do that.
+             // XXXldb Could we use nsIContent::IsNativeAnonymous instead of
+             // this hack?  bz says we can't because IsNativeAnonymous is
+             // broken for XUL.
     }
 
     content = parent;
diff --git a/content/xul/document/src/nsXULPrototypeCache.h b/content/xul/document/src/nsXULPrototypeCache.h
--- a/content/xul/document/src/nsXULPrototypeCache.h
+++ b/content/xul/document/src/nsXULPrototypeCache.h
@@ -71,7 +71,7 @@ struct CacheScriptEntry
  *  2. The on-disk fastload file.
  */
 class nsXULPrototypeCache : public nsIXULPrototypeCache,
-                                   nsIObserver
+                            public nsIObserver
 {
 public:
     // nsISupports
diff --git a/content/xul/document/src/nsXULPrototypeDocument.cpp b/content/xul/document/src/nsXULPrototypeDocument.cpp
--- a/content/xul/document/src/nsXULPrototypeDocument.cpp
+++ b/content/xul/document/src/nsXULPrototypeDocument.cpp
@@ -234,7 +234,8 @@ NS_NewXULPrototypeDocument(nsXULPrototyp
 
 // Helper method that shares a system global among all prototype documents
 // that have the system principal as their security principal.   Called by
-// nsXULPrototypeDocument::Read and nsXULPDGlobalObject::GetGlobalObject.
+// nsXULPrototypeDocument::Read and
+// nsXULPrototypeDocument::GetScriptGlobalObject.
 // This method greatly reduces the number of nsXULPDGlobalObjects and their
 // nsIScriptContexts in apps that load many XUL documents via chrome: URLs.
 
diff --git a/db/mork/src/morkFactory.cpp b/db/mork/src/morkFactory.cpp
--- a/db/mork/src/morkFactory.cpp
+++ b/db/mork/src/morkFactory.cpp
@@ -106,6 +106,7 @@ morkFactory::morkFactory() // uses orkin
 morkFactory::morkFactory() // uses orkinHeap
 : morkObject(morkUsage::kGlobal, (nsIMdbHeap*) 0, morkColor_kNone)
 , mFactory_Env(morkUsage::kMember, (nsIMdbHeap*) 0, this,
+  // XXXldb Nothing ever frees this new orkinHeap
   new orkinHeap())
 , mFactory_Heap()
 {
@@ -147,6 +148,7 @@ NS_IMPL_ISUPPORTS_INHERITED1(morkFactory
 
 extern "C" nsIMdbFactory* MakeMdbFactory() 
 {
+  // XXXldb Nothing ever frees this new orkinHeap
   return new morkFactory(new orkinHeap());
 }
 
@@ -270,6 +272,7 @@ morkFactory::MakeEnv(nsIMdbHeap* ioHeap,
   nsIMdbEnv* outEnv = 0;
   mork_bool ownsHeap = (ioHeap == 0);
   if ( !ioHeap )
+    // XXXldb Nothing ever frees this new orkinHeap
     ioHeap = new orkinHeap();
 
   if ( acqEnv && ioHeap )
@@ -310,6 +313,7 @@ morkFactory::MakeHeap(nsIMdbEnv* mev, ns
   morkEnv* ev = morkEnv::FromMdbEnv(mev);
   if ( ev )
   {
+    // XXXldb Nothing ever frees this new orkinHeap
     outHeap = new orkinHeap();
     if ( !outHeap )
       ev->OutOfMemoryError();
diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -694,6 +694,14 @@ nsDocShell::LoadURI(nsIURI * aURI,
 
     NS_ENSURE_ARG(aURI);
 
+#ifdef DEBUG
+    {
+        nsCAutoString spec;
+        aURI->GetSpec(spec);
+        printf("nsDocShell(%p)::LoadURI(%s)\n", this, spec.get());
+    }
+#endif
+
     // Extract the info from the DocShellLoadInfo struct...
     if (aLoadInfo) {
         aLoadInfo->GetReferrer(getter_AddRefs(referrer));
@@ -3706,6 +3714,11 @@ nsDocShell::SetPositionAndSize(PRInt32 x
 nsDocShell::SetPositionAndSize(PRInt32 x, PRInt32 y, PRInt32 cx,
                                PRInt32 cy, PRBool fRepaint)
 {
+#if 0
+printf("\n\nnsDocShell[%p]::SetPositionAndSize(x=%d, y=%d, width=%d, height=%d)\n\n\n",
+       this, x, y, cx, cy);
+#endif
+
     mBounds.x = x;
     mBounds.y = y;
     mBounds.width = cx;
@@ -5222,13 +5235,21 @@ nsDocShell::CreateAboutBlankContentViewe
   return rv;
 }
 
+#ifdef DEBUG_dbaron
+#define CSP_DEBUG_PRINTF(string_) printf("nsDocShell::CanSavePresentation: " string_ "\n")
+#else
+#define CSP_DEBUG_PRINTF(string_) PR_BEGIN_MACRO PR_END_MACRO
+#endif
+
 PRBool
 nsDocShell::CanSavePresentation(PRUint32 aLoadType,
                                 nsIRequest *aNewRequest,
                                 nsIDocument *aNewDocument)
 {
-    if (!mOSHE)
+    if (!mOSHE) {
+        CSP_DEBUG_PRINTF(" returning false, since no OSHE");
         return PR_FALSE; // no entry to save into
+    }
 
     // Only save presentation for "normal" loads and link loads.  Anything else
     // probably wants to refetch the page, so caching the old presentation
@@ -5239,27 +5260,36 @@ nsDocShell::CanSavePresentation(PRUint32
         aLoadType != LOAD_STOP_CONTENT &&
         aLoadType != LOAD_STOP_CONTENT_AND_REPLACE &&
         aLoadType != LOAD_ERROR_PAGE)
-        return PR_FALSE;
+    {
+        CSP_DEBUG_PRINTF(" returning false, due to load type");
+        return PR_FALSE;
+    }
 
     // If the session history entry has the saveLayoutState flag set to false,
     // then we should not cache the presentation.
     PRBool canSaveState;
     mOSHE->GetSaveLayoutStateFlag(&canSaveState);
-    if (canSaveState == PR_FALSE)
-        return PR_FALSE;
+    if (canSaveState == PR_FALSE) {
+        CSP_DEBUG_PRINTF(" returning false, due to session history entry flag");
+        return PR_FALSE;
+    }
 
     // If the document is not done loading, don't cache it.
     nsCOMPtr<nsPIDOMWindow> pWin = do_QueryInterface(mScriptGlobal);
-    if (!pWin || pWin->IsLoading())
-        return PR_FALSE;
+    if (!pWin || pWin->IsLoading()) {
+        CSP_DEBUG_PRINTF(" returning false, due to window still loading");
+        return PR_FALSE;
+    }
 
     if (pWin->WouldReuseInnerWindow(aNewDocument))
         return PR_FALSE;
 
     // Avoid doing the work of saving the presentation state in the case where
     // the content viewer cache is disabled.
-    if (nsSHistory::GetMaxTotalViewers() == 0)
-        return PR_FALSE;
+    if (nsSHistory::GetMaxTotalViewers() == 0) {
+        CSP_DEBUG_PRINTF(" returning false, GetMaxTotalViewers 0");
+        return PR_FALSE;
+    }
 
     // Don't cache the content viewer if we're in a subframe and the subframe
     // pref is disabled.
@@ -5276,9 +5306,12 @@ nsDocShell::CanSavePresentation(PRUint32
 
     // If the document does not want its presentation cached, then don't.
     nsCOMPtr<nsIDocument> doc = do_QueryInterface(pWin->GetExtantDocument());
-    if (!doc || !doc->CanSavePresentation(aNewRequest))
-        return PR_FALSE;
-
+    if (!doc || !doc->CanSavePresentation(aNewRequest)) {
+        CSP_DEBUG_PRINTF(" returning false, since document says so");
+        return PR_FALSE;
+    }
+
+    CSP_DEBUG_PRINTF(" returning TRUE");
     return PR_TRUE;
 }
 
diff --git a/docshell/base/nsWebShell.cpp b/docshell/base/nsWebShell.cpp
--- a/docshell/base/nsWebShell.cpp
+++ b/docshell/base/nsWebShell.cpp
@@ -547,9 +547,7 @@ nsWebShell::nsWebShell() : nsDocShell()
 #ifdef DEBUG
   // We're counting the number of |nsWebShells| to help find leaks
   ++gNumberOfWebShells;
-#endif
-#ifdef DEBUG
-    printf("++WEBSHELL %p == %ld\n", (void*) this, gNumberOfWebShells);
+  printf("++WEBSHELL %p == %ld\n", (void*) this, gNumberOfWebShells);
 #endif
 
   InitFrameData();
@@ -572,8 +570,6 @@ nsWebShell::~nsWebShell()
 #ifdef DEBUG
   // We're counting the number of |nsWebShells| to help find leaks
   --gNumberOfWebShells;
-#endif
-#ifdef DEBUG
   printf("--WEBSHELL %p == %ld\n", (void*) this, gNumberOfWebShells);
 #endif
 }
diff --git a/dom/src/base/nsGlobalWindow.cpp b/dom/src/base/nsGlobalWindow.cpp
--- a/dom/src/base/nsGlobalWindow.cpp
+++ b/dom/src/base/nsGlobalWindow.cpp
@@ -1735,6 +1735,7 @@ nsGlobalWindow::SetNewDocument(nsIDocume
 
         // Don't clear scope on our current inner window if it's going to be
         // held in the bfcache.
+        // XXXldb Move this out of currentInner->mJSObject check!
         if (!currentInner->IsFrozen()) {
           // Skip the ClearScope if we set a termination function to do
           // it ourselves, later.
diff --git a/dom/src/base/nsJSEnvironment.cpp b/dom/src/base/nsJSEnvironment.cpp
--- a/dom/src/base/nsJSEnvironment.cpp
+++ b/dom/src/base/nsJSEnvironment.cpp
@@ -3017,6 +3017,83 @@ static JSFunctionSpec TraceMallocFunctio
 
 #endif /* NS_TRACE_MALLOC */
 
+#ifdef LINUX
+
+#include <malloc.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+
+static void
+dump_mallinfo(FILE *ofp)
+{
+    struct mallinfo mi = mallinfo();
+    fprintf(ofp,
+            "%8d non-mmapped space allocated from system (bytes)\n"
+            "%8d free chunks (count)\n"
+            "%8d fastbin blocks (count)\n"
+            "%8d mmapped regions (count)\n"
+            "%8d space in mmapped regions (bytes)\n"
+            "%8d maximum total allocated space (bytes)\n"
+            "%8d space available in freed fastbin blocks (bytes)\n"
+            "%8d total allocated space (bytes)\n"
+            "%8d total free space (bytes)\n"
+            "%8d top-most, releasable (via malloc_trim) space (bytes)\n",
+            mi.arena, mi.ordblks, mi.smblks, mi.hblks, mi.hblkhd,
+            mi.usmblks, mi.fsmblks, mi.uordblks, mi.fordblks, mi.keepcost);
+}
+
+static void
+dump_pid_proc_file(FILE *ofp, const char* procfile)
+{
+    char filename[40];
+    snprintf(filename, sizeof(filename),
+             "/proc/%d/%s", getpid(), procfile);
+    FILE *in = fopen(filename, "r");
+    if (!in)
+        return;
+
+    char buf[8192];
+    while (!feof(in)) {
+        size_t s = fread(buf, 1, sizeof(buf), in);
+        fwrite(buf, 1, s, ofp);
+    }
+
+    fclose(in);
+}
+
+static JSBool
+DumpHeapInfo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSString *str = JS_ValueToString(cx, argv[0]);
+    if (!str)
+        return JS_FALSE;
+    const char *pathname = JS_GetStringBytes(str);
+    FILE *ofp = fopen(pathname, "w");
+    if (!ofp) {
+        JS_ReportError(cx, "can't dump to %s: %s", pathname, strerror(errno));
+        return JS_FALSE;
+    }
+
+    dump_mallinfo(ofp);
+    fprintf(ofp, "-----\n");
+    dump_pid_proc_file(ofp, "maps");
+    fprintf(ofp, "-----\n");
+    dump_pid_proc_file(ofp, "status");
+    fprintf(ofp, "-----\n");
+
+    fclose(ofp);
+
+    return JS_TRUE;
+}
+
+static JSFunctionSpec DumpHeapFunctions[] = {
+    {"DumpHeapInfo",               DumpHeapInfo,               1, 0, 0},
+    {nsnull,                       nsnull,                     0, 0, 0}
+};
+#endif
+
 #ifdef MOZ_JPROF
 
 #include <signal.h>
@@ -3118,6 +3195,10 @@ nsJSContext::InitClasses(void *aGlobalOb
 #ifdef NS_TRACE_MALLOC
   // Attempt to initialize TraceMalloc functions
   ::JS_DefineFunctions(mContext, globalObj, TraceMallocFunctions);
+#endif
+
+#ifdef LINUX
+  ::JS_DefineFunctions(mContext, globalObj, DumpHeapFunctions);
 #endif
 
 #ifdef MOZ_JPROF
diff --git a/extensions/layout-debug/src/nsDebugFactory.cpp b/extensions/layout-debug/src/nsDebugFactory.cpp
--- a/extensions/layout-debug/src/nsDebugFactory.cpp
+++ b/extensions/layout-debug/src/nsDebugFactory.cpp
@@ -52,7 +52,7 @@ NS_GENERIC_FACTORY_CONSTRUCTOR(nsLayoutD
 
 #ifdef MOZ_XUL_APP
 
-static NS_IMETHODIMP
+static NS_METHOD
 RegisterCommandLineHandlers(nsIComponentManager* compMgr, nsIFile* path,
                             const char *location, const char *type,
                             const nsModuleComponentInfo *info)
@@ -70,7 +70,7 @@ RegisterCommandLineHandlers(nsIComponent
   return NS_OK;
 }
 
-static NS_IMETHODIMP
+static NS_METHOD
 UnregisterCommandLineHandlers(nsIComponentManager* compMgr, nsIFile *path,
                               const char *location,
                               const nsModuleComponentInfo *info)
diff --git a/extensions/layout-debug/src/nsLayoutDebuggingTools.cpp b/extensions/layout-debug/src/nsLayoutDebuggingTools.cpp
--- a/extensions/layout-debug/src/nsLayoutDebuggingTools.cpp
+++ b/extensions/layout-debug/src/nsLayoutDebuggingTools.cpp
@@ -148,14 +148,15 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::Init(nsIDOMWindow *aWin)
 {
+    mPrefs = do_GetService(NS_PREF_CONTRACTID);
+
     {
         nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aWin);
         if (!window)
             return NS_ERROR_UNEXPECTED;
         mDocShell = window->GetDocShell();
     }
-
-    mPrefs = do_GetService(NS_PREF_CONTRACTID);
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_UNEXPECTED);
 
     GetBoolPref("nglayout.debug.paint_flashing", &mPaintFlashing);
     GetBoolPref("nglayout.debug.paint_dumping", &mPaintDumping);
@@ -179,6 +180,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::NewURILoaded()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
     // Reset all the state that should be reset between pages.
 
     // XXX Some of these should instead be transferred between pages!
@@ -324,6 +326,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::SetReflowCounts(PRBool aShow)
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
     nsCOMPtr<nsIPresShell> shell(pres_shell(mDocShell)); 
     if (shell) {
 #ifdef MOZ_REFLOW_PERF
@@ -373,6 +376,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::DumpWebShells()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
     nsCOMPtr<nsIDocShellTreeItem> shellAsItem(do_QueryInterface(mDocShell));
     DumpAWebShell(shellAsItem, stdout, 0);
     return NS_OK;
@@ -414,6 +418,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::DumpContent()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
     DumpContentRecur(mDocShell, stdout);
     return NS_OK;
 }
@@ -421,33 +426,31 @@ static void
 static void
 DumpFramesRecur(nsIDocShell* aDocShell, FILE* out)
 {
-    if (nsnull != aDocShell) {
-        fprintf(out, "webshell=%p \n", static_cast<void*>(aDocShell));
-        nsCOMPtr<nsIPresShell> shell(pres_shell(aDocShell));
-        if (shell) {
-            nsIFrame* root = shell->GetRootFrame();
-            if (root) {
-                nsIFrameDebug* fdbg;
-                if (NS_SUCCEEDED(CallQueryInterface(root, &fdbg))) {
-                    fdbg->List(out, 0);
-                }
+    fprintf(out, "webshell=%p \n", static_cast<void*>(aDocShell));
+    nsCOMPtr<nsIPresShell> shell(pres_shell(aDocShell));
+    if (shell) {
+        nsIFrame* root = shell->GetRootFrame();
+        if (root) {
+            nsIFrameDebug* fdbg;
+            if (NS_SUCCEEDED(CallQueryInterface(root, &fdbg))) {
+                fdbg->List(out, 0);
             }
         }
-        else {
-            fputs("null pres shell\n", out);
-        }
+    }
+    else {
+        fputs("null pres shell\n", out);
+    }
 
-        // dump the frames of the sub documents
-        PRInt32 i, n;
-        nsCOMPtr<nsIDocShellTreeNode> docShellAsNode(do_QueryInterface(aDocShell));
-        docShellAsNode->GetChildCount(&n);
-        for (i = 0; i < n; ++i) {
-            nsCOMPtr<nsIDocShellTreeItem> child;
-            docShellAsNode->GetChildAt(i, getter_AddRefs(child));
-            nsCOMPtr<nsIDocShell> childAsShell(do_QueryInterface(child));
-            if (childAsShell) {
-                DumpFramesRecur(childAsShell, out);
-            }
+    // dump the frames of the sub documents
+    PRInt32 i, n;
+    nsCOMPtr<nsIDocShellTreeNode> docShellAsNode(do_QueryInterface(aDocShell));
+    docShellAsNode->GetChildCount(&n);
+    for (i = 0; i < n; ++i) {
+        nsCOMPtr<nsIDocShellTreeItem> child;
+        docShellAsNode->GetChildAt(i, getter_AddRefs(child));
+        nsCOMPtr<nsIDocShell> childAsShell(do_QueryInterface(child));
+        if (childAsShell) {
+            DumpFramesRecur(childAsShell, out);
         }
     }
 }
@@ -455,6 +458,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::DumpFrames()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
     DumpFramesRecur(mDocShell, stdout);
     return NS_OK;
 }
@@ -464,31 +468,29 @@ DumpViewsRecur(nsIDocShell* aDocShell, F
 DumpViewsRecur(nsIDocShell* aDocShell, FILE* out)
 {
 #ifdef DEBUG
-    if (aDocShell) {
-        fprintf(out, "docshell=%p \n", static_cast<void*>(aDocShell));
-        nsCOMPtr<nsIViewManager> vm(view_manager(aDocShell));
-        if (vm) {
-            nsIView* root;
-            vm->GetRootView(root);
-            if (nsnull != root) {
-                root->List(out);
-            }
+    fprintf(out, "docshell=%p \n", static_cast<void*>(aDocShell));
+    nsCOMPtr<nsIViewManager> vm(view_manager(aDocShell));
+    if (vm) {
+        nsIView* root;
+        vm->GetRootView(root);
+        if (nsnull != root) {
+            root->List(out);
         }
-        else {
-            fputs("null view manager\n", out);
-        }
+    }
+    else {
+        fputs("null view manager\n", out);
+    }
 
-        // dump the views of the sub documents
-        PRInt32 i, n;
-        nsCOMPtr<nsIDocShellTreeNode> docShellAsNode(do_QueryInterface(aDocShell));
-        docShellAsNode->GetChildCount(&n);
-        for (i = 0; i < n; i++) {
-            nsCOMPtr<nsIDocShellTreeItem> child;
-            docShellAsNode->GetChildAt(i, getter_AddRefs(child));
-            nsCOMPtr<nsIDocShell> childAsShell(do_QueryInterface(child));
-            if (childAsShell) {
-                DumpViewsRecur(childAsShell, out);
-            }
+    // dump the views of the sub documents
+    PRInt32 i, n;
+    nsCOMPtr<nsIDocShellTreeNode> docShellAsNode(do_QueryInterface(aDocShell));
+    docShellAsNode->GetChildCount(&n);
+    for (i = 0; i < n; i++) {
+        nsCOMPtr<nsIDocShellTreeItem> child;
+        docShellAsNode->GetChildAt(i, getter_AddRefs(child));
+        nsCOMPtr<nsIDocShell> childAsShell(do_QueryInterface(child));
+        if (childAsShell) {
+            DumpViewsRecur(childAsShell, out);
         }
     }
 #endif // DEBUG
@@ -497,6 +499,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::DumpViews()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
     DumpViewsRecur(mDocShell, stdout);
     return NS_OK;
 }
@@ -504,6 +507,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::DumpStyleSheets()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
 #ifdef DEBUG
     FILE *out = stdout;
     nsCOMPtr<nsIPresShell> shell(pres_shell(mDocShell)); 
@@ -518,6 +522,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::DumpStyleContexts()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
 #ifdef DEBUG
     FILE *out = stdout;
     nsCOMPtr<nsIPresShell> shell(pres_shell(mDocShell)); 
@@ -538,6 +543,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::DumpReflowStats()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
 #ifdef DEBUG
     nsCOMPtr<nsIPresShell> shell(pres_shell(mDocShell)); 
     if (shell) {
@@ -569,6 +575,7 @@ nsLayoutDebuggingTools::SetBoolPrefAndRe
 nsLayoutDebuggingTools::SetBoolPrefAndRefresh(const char * aPrefName,
                                               PRBool aNewVal)
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
     NS_ENSURE_TRUE(mPrefs && aPrefName, NS_OK);
 
     mPrefs->SetBoolPref(aPrefName, aNewVal);
diff --git a/extensions/layout-debug/src/nsRegressionTester.cpp b/extensions/layout-debug/src/nsRegressionTester.cpp
--- a/extensions/layout-debug/src/nsRegressionTester.cpp
+++ b/extensions/layout-debug/src/nsRegressionTester.cpp
@@ -142,6 +142,29 @@ nsRegressionTester::DumpFrameModel(nsIDO
   return NS_OK;
 }
 
+#if 0
+NS_IMETHODIMP
+nsRegressionTester::DumpPrintFrameModel(nsIDOMWindow *aWindowToDump, nsILocalFile *aDestFile)
+{
+  nsCOMPtr<nsIDocShell> docShell;
+  rv = GetDocShellFromWindow(aWindowToDump, getter_AddRefs(docShell));
+
+  nsCOMPtr<nsIContentViewer> cv;
+  docShell->GetContentViewer(getter_AddRefs(cv));
+  nsCOMPtr<nsIContentViewerFile> cvf = do_QueryInterface(cv);
+
+  FILE* fp = stdout;
+  if (aDestFile)
+  {
+    rv = aDestFile->OpenANSIFileDesc("w", &fp);
+    if (NS_FAILED(rv)) return rv;
+  }
+
+  cvf->Print(PR_TRUE, fp, nsnull);
+  return NS_OK;
+}
+#endif
+
 NS_IMETHODIMP
 nsRegressionTester::CompareFrameModels(nsILocalFile *aBaseFile, nsILocalFile *aVerFile, PRUint32 aFlags, PRInt32 *aResult) 
 {
diff --git a/extensions/pref/system-pref/src/gconf/nsSystemPrefService.cpp b/extensions/pref/system-pref/src/gconf/nsSystemPrefService.cpp
--- a/extensions/pref/system-pref/src/gconf/nsSystemPrefService.cpp
+++ b/extensions/pref/system-pref/src/gconf/nsSystemPrefService.cpp
@@ -592,6 +592,8 @@ gconfDeleteObserver(void *aElement, void
     return PR_TRUE;
 }
 
+MOZ_DECL_CTOR_COUNTER(GConfProxy)
+
 GConfProxy::GConfProxy(nsSystemPrefService *aSysPrefService):
     mGConfClient(nsnull),
     mGConfLib(nsnull),
@@ -599,10 +601,13 @@ GConfProxy::GConfProxy(nsSystemPrefServi
     mSysPrefService(aSysPrefService),
     mObservers(nsnull)
 {
+    MOZ_COUNT_CTOR(GConfProxy);
 }
 
 GConfProxy::~GConfProxy()
 {
+    MOZ_COUNT_DTOR(GConfProxy);
+
     if (mGConfClient)
         g_object_unref(G_OBJECT(mGConfClient));
 
diff --git a/extensions/webservices/security/src/nsWebScriptsAccess.cpp b/extensions/webservices/security/src/nsWebScriptsAccess.cpp
--- a/extensions/webservices/security/src/nsWebScriptsAccess.cpp
+++ b/extensions/webservices/security/src/nsWebScriptsAccess.cpp
@@ -116,6 +116,7 @@ nsWebScriptsAccess::CanAccess(nsIURI* aT
   if (NS_FAILED(rv) || *aAccessGranted)
     return rv;
   
+  // XXXldb This really shouldn't be a member variable.
   mServiceURI = aTransportURI;
 
   nsXPIDLCString path;
@@ -123,6 +124,8 @@ nsWebScriptsAccess::CanAccess(nsIURI* aT
   path += '/';
 
   AccessInfoEntry* entry = 0;
+  // XXXldb Shouldn't we check same origin before checking for a cached
+  // entry in case we've had a previous non-same-origin access?
   rv = GetAccessInfoEntry(path, &entry);
   if (!entry) {
     rv = mSecurityManager->CheckSameOrigin(0, aTransportURI);
@@ -311,6 +314,7 @@ nsWebScriptsAccess::CreateEntry(nsIDOMDo
 
   if (!aIsDelegated) {
     nsCOMPtr<nsIDOMNodeList> delegateList; 
+    // XXXldb Shouldn't this only look at the children of the root?
     rv = aDocument->GetElementsByTagNameNS(kNamespace2002, kDelegateTag, 
                                            getter_AddRefs(delegateList));
     NS_ENSURE_TRUE(delegateList, rv);
@@ -321,6 +325,7 @@ nsWebScriptsAccess::CreateEntry(nsIDOMDo
   }
 
   nsCOMPtr<nsIDOMNodeList> allowList;
+  // XXXldb Shouldn't this only look at the children of the root?
   rv = aDocument->GetElementsByTagNameNS(kNamespace2002, kAllowTag, 
                                          getter_AddRefs(allowList));
   NS_ENSURE_TRUE(allowList, rv);
@@ -580,6 +585,7 @@ nsWebScriptsAccess::ValidateDocument(nsI
  
       if (!ns.Equals(kNamespace2002))
         continue; // ignore elements with different ns.
+      // XXXldb But they could have children in this ns!
 
       PRBool hasChildNodes = PR_FALSE;
       if (name.Equals(kDelegateTag)) {
diff --git a/gfx/thebes/src/gfxPangoFonts.cpp b/gfx/thebes/src/gfxPangoFonts.cpp
--- a/gfx/thebes/src/gfxPangoFonts.cpp
+++ b/gfx/thebes/src/gfxPangoFonts.cpp
@@ -76,6 +76,10 @@
 #include <gdk/gdkpango.h>
 
 #include <math.h>
+
+#ifdef DEBUG_dbaron_off
+#define DEBUG_print_glyphs
+#endif
 
 #define FLOAT_PANGO_SCALE ((gfxFloat)PANGO_SCALE)
 
@@ -310,7 +314,7 @@ gfxPangoFont::RealizeFont(PRBool force)
 
     pango_font_description_set_family(mPangoFontDesc, NS_ConvertUTF16toUTF8(mName).get());
     gfxFloat size = mAdjustedSize ? mAdjustedSize : GetStyle()->size;
-    pango_font_description_set_absolute_size(mPangoFontDesc, size * PANGO_SCALE);
+    pango_font_description_set_absolute_size(mPangoFontDesc, (size + 0.000001) * PANGO_SCALE);
     pango_font_description_set_style(mPangoFontDesc, ThebesStyleToPangoStyle(GetStyle()));
     pango_font_description_set_weight(mPangoFontDesc, ThebesStyleToPangoWeight(GetStyle()));
 
@@ -1515,3 +1519,9 @@ gfxPangoFontCache::Get(const PangoFontDe
     g_object_ref(font);
     return font;
 }
+
+    // XXXldb It seems that we're rasterizing the font twice, since if
+    // you change the font size in this code, XFT_DEBUG=1023 still shows
+    // the other rasterization (being done from text measurement), but
+    // not this one (which means the second rasterization isn't even
+    // done using Xft, I think).
diff --git a/gfx/thebes/src/nsUnicodeRange.cpp b/gfx/thebes/src/nsUnicodeRange.cpp
--- a/gfx/thebes/src/nsUnicodeRange.cpp
+++ b/gfx/thebes/src/nsUnicodeRange.cpp
@@ -36,6 +36,8 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsUnicodeRange.h"
+
+// XXXldb Replace this with something generated from the Unicode database.
 
 // This table depends on unicode range definitions. 
 // Each item's index must correspond unicode range value
diff --git a/intl/uconv/native/nsNativeUConvService.cpp b/intl/uconv/native/nsNativeUConvService.cpp
--- a/intl/uconv/native/nsNativeUConvService.cpp
+++ b/intl/uconv/native/nsNativeUConvService.cpp
@@ -317,12 +317,12 @@ IConvAdaptor::ConvertInternal(void * aSr
                 if (mReplaceOnError) {
                     if (aDestCharSize == 1) {
                         (*(char*)aDest) = (char)mReplaceChar;
-                        aDest = (char*)aDest + sizeof(char);
+                        aDest = (char*)aDest + 1;
                     }
                     else
                     {
                         (*(PRUnichar*)aDest) = (PRUnichar)mReplaceChar;
-                        aDest = (PRUnichar*)aDest + sizeof(PRUnichar);
+                        aDest = (PRUnichar*)aDest + 1;
                     
                     }
                     inLeft -= aSrcCharSize;
diff --git a/intl/uconv/src/nsCharsetConverterManager.cpp b/intl/uconv/src/nsCharsetConverterManager.cpp
--- a/intl/uconv/src/nsCharsetConverterManager.cpp
+++ b/intl/uconv/src/nsCharsetConverterManager.cpp
@@ -64,13 +64,53 @@
 #endif
 
 // Pattern of cached, commonly used, single byte decoder
-#define NS_1BYTE_CODER_PATTERN "ISO-8859"
-#define NS_1BYTE_CODER_PATTERN_LEN 8
+static const char k1ByteCoderPattern[] = "ISO-8859";
+
+inline PRBool IsDecoderStateless(const char *aEncoding)
+{
+  return !strncmp(aEncoding, k1ByteCoderPattern,
+                  sizeof(k1ByteCoderPattern) - 1);
+}
+
+/* static */ void PR_CALLBACK
+nsCharsetConverterManager::ClearEntry(PLDHashTable *table,
+                                      PLDHashEntryHdr *entry)
+{
+  EncoderDecoderEntry *e = static_cast<EncoderDecoderEntry*>(entry);
+  if (e->mCharset) {
+    NS_RELEASE(e->mFactoryOrService);
+    nsCRT::free(e->mCharset);
+  }
+  memset(entry, 0, table->entrySize);
+}
+
+/* static */ PRBool PR_CALLBACK
+nsCharsetConverterManager::MatchEntry(PLDHashTable *table,
+                                      const PLDHashEntryHdr *entry,
+                                      const void* key)
+{
+  const EncoderDecoderEntry *e =
+    static_cast<const EncoderDecoderEntry*>(entry);
+  const char *s = static_cast<const char*>(key);
+
+  return !strcmp(s, e->mCharset);
+}
+
+/* static */ PLDHashTableOps nsCharsetConverterManager::EncoderDecoderOps = {
+  PL_DHashAllocTable,
+  PL_DHashFreeTable,
+  PL_DHashStringKey,
+  MatchEntry,
+  PL_DHashMoveEntryStub,
+  ClearEntry,
+  PL_DHashFinalizeStub,
+  NULL
+};
 
 // Class nsCharsetConverterManager [implementation]
 
-NS_IMPL_THREADSAFE_ISUPPORTS1(nsCharsetConverterManager,
-                              nsICharsetConverterManager)
+NS_IMPL_ISUPPORTS1(nsCharsetConverterManager,
+                   nsICharsetConverterManager)
 
 nsCharsetConverterManager::nsCharsetConverterManager() 
   :mDataBundle(NULL), mTitleBundle(NULL)
@@ -78,10 +118,36 @@ nsCharsetConverterManager::nsCharsetConv
 #ifdef MOZ_USE_NATIVE_UCONV
   mNativeUC = do_GetService(NS_NATIVE_UCONV_SERVICE_CONTRACT_ID);
 #endif
+  mEncoderTable.ops = nsnull;
+  mDecoderTable.ops = nsnull;
+}
+
+nsresult nsCharsetConverterManager::Init()
+{
+  if (!PL_DHashTableInit(&mEncoderTable, &EncoderDecoderOps, nsnull,
+                         sizeof(EncoderDecoderEntry), 16)) {
+    mEncoderTable.ops = nsnull;
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+  if (!PL_DHashTableInit(&mDecoderTable, &EncoderDecoderOps, nsnull,
+                         sizeof(EncoderDecoderEntry), 16)) {
+    mDecoderTable.ops = nsnull;
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  // It's OK if this fails -- we just won't resolve aliases.
+  mCSAlias = do_GetService(NS_CHARSETALIAS_CONTRACTID);
+
+  return NS_OK;
 }
 
 nsCharsetConverterManager::~nsCharsetConverterManager() 
 {
+  if (mEncoderTable.ops)
+    PL_DHashTableFinish(&mEncoderTable);
+  if (mDecoderTable.ops)
+    PL_DHashTableFinish(&mDecoderTable);
+
   NS_IF_RELEASE(mDataBundle);
   NS_IF_RELEASE(mTitleBundle);
 }
@@ -156,6 +222,15 @@ nsresult nsCharsetConverterManager::GetB
   return NS_OK;
 }
 
+#ifdef DEBUG
+PRBool nsCharsetConverterManager::IsCanonical(const char* aCharset)
+{
+  nsCAutoString charset;
+  nsCharsetConverterManager::GetCharsetAlias(aCharset, charset);
+  return !strcmp(aCharset, charset.get());
+}
+#endif
+
 
 //----------------------------------------------------------------------------//----------------------------------------------------------------------------
 // Interface nsICharsetConverterManager [implementation]
@@ -164,121 +239,129 @@ nsCharsetConverterManager::GetUnicodeEnc
 nsCharsetConverterManager::GetUnicodeEncoder(const char * aDest, 
                                              nsIUnicodeEncoder ** aResult)
 {
-  // resolve the charset first
-  nsCAutoString charset;
-  
-  // fully qualify to possibly avoid vtable call
-  nsCharsetConverterManager::GetCharsetAlias(aDest, charset);
+#ifdef MOZ_USE_NATIVE_UCONV
+  if (mNativeUC) {
+    nsCAutoString charset;
+    // fully qualify to possibly avoid vtable call
+    nsCharsetConverterManager::GetCharsetAlias(aDest, charset);
 
-  return nsCharsetConverterManager::GetUnicodeEncoderRaw(charset.get(),
-                                                         aResult);
+    nsCOMPtr<nsISupports> supports;
+    mNativeUC->GetNativeConverter("UCS-2", 
+                                  charset.get(),
+                                  getter_AddRefs(supports));
+
+    if (supports && NS_SUCCEEDED(CallQueryInterface(supports, aResult))) {
+      return NS_OK;
+    }
+  }
+#endif  
+
+  *aResult = nsnull;
+
+  EncoderDecoderEntry *entry = GetEncoderEntry(aDest, PL_DHASH_ADD);
+  NS_ENSURE_TRUE(entry, NS_ERROR_OUT_OF_MEMORY);
+  if (!entry->mCharset) {
+    nsCAutoString charset;
+    // fully qualify to possibly avoid vtable call
+    nsCharsetConverterManager::GetCharsetAlias(aDest, charset);
+
+    nsCAutoString
+      contractid(NS_LITERAL_CSTRING(NS_UNICODEENCODER_CONTRACTID_BASE) +
+                 charset);
+
+    nsCOMPtr<nsIComponentManager> cm;
+    NS_GetComponentManager(getter_AddRefs(cm));
+    nsresult rv =
+      cm->GetClassObjectByContractID(contractid.get(), NS_GET_IID(nsIFactory),
+                                     (void**) &entry->mFactory);
+    if (NS_FAILED(rv)) {
+      PL_DHashTableRawRemove(&mEncoderTable, entry);
+      return rv;
+    }
+
+    entry->mCharset = nsCRT::strdup(aDest);
+  }
+
+  // Always create an instance since encoders hold state.
+  return entry->mFactory->CreateInstance(nsnull, NS_GET_IID(nsIUnicodeEncoder),
+                                         (void**)aResult);
 }
-
 
 NS_IMETHODIMP
 nsCharsetConverterManager::GetUnicodeEncoderRaw(const char * aDest, 
                                                 nsIUnicodeEncoder ** aResult)
 {
-  *aResult= nsnull;
-  nsCOMPtr<nsIUnicodeEncoder> encoder;
-
-#ifdef MOZ_USE_NATIVE_UCONV
-  if (mNativeUC) {
-    nsCOMPtr<nsISupports> supports;
-    mNativeUC->GetNativeConverter("UCS-2", 
-                                  aDest,
-                                  getter_AddRefs(supports));
-
-    encoder = do_QueryInterface(supports);
-
-    if (encoder) {
-      NS_ADDREF(*aResult = encoder);
-      return NS_OK;
-    }
-  }
-#endif  
-  nsresult rv = NS_OK;
-
-  nsCAutoString
-    contractid(NS_LITERAL_CSTRING(NS_UNICODEENCODER_CONTRACTID_BASE) +
-               nsDependentCString(aDest));
-
-  // Always create an instance since encoders hold state.
-  encoder = do_CreateInstance(contractid.get(), &rv);
-
-  if (NS_FAILED(rv))
-    rv = NS_ERROR_UCONV_NOCONV;
-  else
-  {
-    *aResult = encoder.get();
-    NS_ADDREF(*aResult);
-  }
-  return rv;
+  NS_ASSERTION(IsCanonical(aDest), "not canonical form");
+  return nsCharsetConverterManager::GetUnicodeEncoder(aDest, aResult);
 }
 
 NS_IMETHODIMP
 nsCharsetConverterManager::GetUnicodeDecoder(const char * aSrc, 
                                              nsIUnicodeDecoder ** aResult)
 {
-  // resolve the charset first
-  nsCAutoString charset;
-  
-  // fully qualify to possibly avoid vtable call
-  nsCharsetConverterManager::GetCharsetAlias(aSrc, charset);
+#ifdef MOZ_USE_NATIVE_UCONV
+  if (mNativeUC) {
+    nsCAutoString charset;
+    // fully qualify to possibly avoid vtable call
+    nsCharsetConverterManager::GetCharsetAlias(aSrc, charset);
 
-  return nsCharsetConverterManager::GetUnicodeDecoderRaw(charset.get(),
-                                                         aResult);
+    nsCOMPtr<nsISupports> supports;
+    mNativeUC->GetNativeConverter(charset.get(),
+                                  "UCS-2", 
+                                  getter_AddRefs(supports));
+    
+    if (supports && NS_SUCCEEDED(CallQueryInterface(supports, aResult))) {
+      return NS_OK;
+    }
+  }
+#endif
+
+  *aResult = nsnull;
+
+  PRBool stateless = IsDecoderStateless(aSrc);
+  EncoderDecoderEntry *entry = GetDecoderEntry(aSrc, PL_DHASH_ADD);
+  NS_ENSURE_TRUE(entry, NS_ERROR_OUT_OF_MEMORY);
+  if (!entry->mCharset) {
+    nsCAutoString charset;
+    // fully qualify to possibly avoid vtable call
+    nsCharsetConverterManager::GetCharsetAlias(aSrc, charset);
+
+    NS_NAMED_LITERAL_CSTRING(kUnicodeDecoderContractIDBase,
+                             NS_UNICODEDECODER_CONTRACTID_BASE);
+    nsCAutoString contractid(kUnicodeDecoderContractIDBase + charset);
+
+    nsresult rv;
+    if (stateless) {
+      rv = CallGetService(contractid.get(), &entry->mService);
+    } else {
+      nsCOMPtr<nsIComponentManager> cm;
+      NS_GetComponentManager(getter_AddRefs(cm));
+      rv = cm->GetClassObjectByContractID(contractid.get(),
+                                          NS_GET_IID(nsIFactory),
+                                          (void**) &entry->mFactory);
+    }
+    if (NS_FAILED(rv)) {
+      PL_DHashTableRawRemove(&mEncoderTable, entry);
+      return rv;
+    }
+    entry->mCharset = nsCRT::strdup(aSrc);
+  }
+
+  if (stateless) {
+    *aResult = entry->mService;
+    NS_ADDREF(*aResult);
+    return NS_OK;
+  }
+  return entry->mFactory->CreateInstance(nsnull, NS_GET_IID(nsIUnicodeDecoder),
+                                         (void**)aResult);
 }
 
 NS_IMETHODIMP
 nsCharsetConverterManager::GetUnicodeDecoderRaw(const char * aSrc, 
                                                 nsIUnicodeDecoder ** aResult)
 {
-  *aResult= nsnull;
-  nsCOMPtr<nsIUnicodeDecoder> decoder;
-
-#ifdef MOZ_USE_NATIVE_UCONV
-  if (mNativeUC) {
-    nsCOMPtr<nsISupports> supports;
-    mNativeUC->GetNativeConverter(aSrc,
-                                  "UCS-2", 
-                                  getter_AddRefs(supports));
-    
-    decoder = do_QueryInterface(supports);
-
-    if (decoder) {
-      NS_ADDREF(*aResult = decoder);
-      return NS_OK;
-    }
-  }
-#endif
-  nsresult rv = NS_OK;
-
-  NS_NAMED_LITERAL_CSTRING(kUnicodeDecoderContractIDBase,
-                           NS_UNICODEDECODER_CONTRACTID_BASE);
-
-  nsCAutoString contractid(kUnicodeDecoderContractIDBase +
-                           nsDependentCString(aSrc));
-
-  if (!strncmp(aSrc,
-               NS_1BYTE_CODER_PATTERN,
-               NS_1BYTE_CODER_PATTERN_LEN))
-  {
-    // Single byte decoders dont hold state. Optimize by using a service.
-    decoder = do_GetService(contractid.get(), &rv);
-  }
-  else
-  {
-    decoder = do_CreateInstance(contractid.get(), &rv);
-  }
-  if(NS_FAILED(rv))
-    rv = NS_ERROR_UCONV_NOCONV;
-  else
-  {
-    *aResult = decoder.get();
-    NS_ADDREF(*aResult);
-  }
-  return rv;
+  NS_ASSERTION(IsCanonical(aSrc), "not canonical form");
+  return nsCharsetConverterManager::GetUnicodeDecoder(aSrc, aResult);
 }
 
 nsresult 
@@ -369,11 +452,9 @@ nsCharsetConverterManager::GetCharsetAli
   // We try to obtain the preferred name for this charset from the charset 
   // aliases. If we don't get it from there, we just use the original string
   nsDependentCString charset(aCharset);
-  nsCOMPtr<nsICharsetAlias> csAlias(do_GetService(NS_CHARSETALIAS_CONTRACTID));
-  NS_ASSERTION(csAlias, "failed to get the CharsetAlias service");
-  if (csAlias) {
+  if (mCSAlias) {
     nsAutoString pref;
-    nsresult rv = csAlias->GetPreferred(charset, aResult);
+    nsresult rv = mCSAlias->GetPreferred(charset, aResult);
     if (NS_SUCCEEDED(rv)) {
       return (!aResult.IsEmpty()) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
     }
diff --git a/intl/uconv/src/nsCharsetConverterManager.h b/intl/uconv/src/nsCharsetConverterManager.h
--- a/intl/uconv/src/nsCharsetConverterManager.h
+++ b/intl/uconv/src/nsCharsetConverterManager.h
@@ -40,6 +40,7 @@
 #include "nsISupports.h"
 #include "nsICharsetConverterManager.h"
 #include "nsIStringBundle.h"
+#include "pldhash.h"
 
 #ifdef MOZ_USE_NATIVE_UCONV
 #include "nsINativeUConvService.h"
@@ -55,10 +56,54 @@ public:
   nsCharsetConverterManager();
   virtual ~nsCharsetConverterManager();
 
+  nsresult Init();
+
 private:
 
   nsIStringBundle * mDataBundle;
   nsIStringBundle * mTitleBundle;
+
+  PLDHashTable mEncoderTable;
+  PLDHashTable mDecoderTable;
+
+  nsCOMPtr<nsICharsetAlias> mCSAlias;
+
+  struct EncoderDecoderEntry : public PLDHashEntryHdr {
+    char *mCharset; // owns
+    union { // owns a reference
+      // In |mEncoderTable|, we always have a factory.  In
+      // |mDecoderTable|, we have a decoder service if
+      // |IsDecoderStateless(mCharset)|, and otherwise we have a factory.
+
+      nsIFactory *mFactory;
+      nsIUnicodeDecoder *mService;
+      nsISupports *mFactoryOrService;
+    };
+  };
+
+  PR_STATIC_CALLBACK(void)   ClearEntry(PLDHashTable *table,
+                                        PLDHashEntryHdr *entry);
+  PR_STATIC_CALLBACK(PRBool) MatchEntry(PLDHashTable *table,
+                                        const PLDHashEntryHdr *entry,
+                                        const void* key);
+
+  static PLDHashTableOps EncoderDecoderOps;
+
+  inline EncoderDecoderEntry*
+  GetEncoderEntry(const char* aCharset, PLDHashOperator aOperator) {
+    return static_cast<EncoderDecoderEntry*>
+      (PL_DHashTableOperate(&mEncoderTable, aCharset, aOperator));
+  }
+
+  inline EncoderDecoderEntry*
+  GetDecoderEntry(const char* aCharset, PLDHashOperator aOperator) {
+    return static_cast<EncoderDecoderEntry*>
+      (PL_DHashTableOperate(&mDecoderTable, aCharset, aOperator));
+  }
+
+#ifdef DEBUG
+  PRBool IsCanonical(const char* aCharset);
+#endif
 
 #ifdef MOZ_USE_NATIVE_UCONV
   nsCOMPtr<nsINativeUConvService> mNativeUC;
diff --git a/intl/uconv/src/nsUConvModule.cpp b/intl/uconv/src/nsUConvModule.cpp
--- a/intl/uconv/src/nsUConvModule.cpp
+++ b/intl/uconv/src/nsUConvModule.cpp
@@ -706,7 +706,7 @@ nsConverterManagerDataRegister(nsICompon
   return nsCharsetConverterManager::RegisterConverterManagerData();
 }
 
-NS_GENERIC_FACTORY_CONSTRUCTOR(nsCharsetConverterManager)
+NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsCharsetConverterManager, Init)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsTextToSubURI)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsUTF8ConverterService)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsCharsetAlias2)
diff --git a/intl/unicharutil/tools/gentransliterate.pl b/intl/unicharutil/tools/gentransliterate.pl
--- a/intl/unicharutil/tools/gentransliterate.pl
+++ b/intl/unicharutil/tools/gentransliterate.pl
@@ -77,6 +77,9 @@
 # THIS FILE IS GENERATED BY mozilla/intl/unicharutil/tools/gentransliterate.pl
 # PLEASE DO NOT MODIFY THIS FILE BY HAND
 #
+END_OF_HEADER
+
+$handcoded = <<END_OF_HANDCODED;
 entity.list.name=transliterate
 entity.169=(c)
 #
diff --git a/ipc/ipcd/daemon/src/ipcModuleReg.cpp b/ipc/ipcd/daemon/src/ipcModuleReg.cpp
--- a/ipc/ipcd/daemon/src/ipcModuleReg.cpp
+++ b/ipc/ipcd/daemon/src/ipcModuleReg.cpp
@@ -158,7 +158,7 @@ IPC_InitModuleReg(const char *exePath)
     //
     // register plug-in modules
     //
-    char *p = PL_strrchr(exePath, IPC_PATH_SEP_CHAR);
+    const char *p = PL_strrchr(exePath, IPC_PATH_SEP_CHAR);
     if (p == NULL) {
         LOG(("unexpected exe path\n"));
         return;
@@ -185,7 +185,7 @@ IPC_InitModuleReg(const char *exePath)
             // locate extension, and check if dynamic library
             //
 
-            const char *p = strrchr(ent->name, '.');
+            p = strrchr(ent->name, '.');
             if (p && PL_strcasecmp(p, MOZ_DLL_SUFFIX) == 0)
                 InitModuleFromLib(modulesDir, ent->name);
         }
diff --git a/js/src/xpconnect/src/XPCDispInterface.cpp b/js/src/xpconnect/src/XPCDispInterface.cpp
--- a/js/src/xpconnect/src/XPCDispInterface.cpp
+++ b/js/src/xpconnect/src/XPCDispInterface.cpp
@@ -365,6 +365,8 @@ JSBool XPCDispInterface::Member::GetValu
         if(!funobj)
             return JS_FALSE;
 
+        // XXXldb root funobj?
+
         // Store ourselves and our native interface within the JSObject
         if(!JS_SetReservedSlot(ccx, funobj, 0, PRIVATE_TO_JSVAL(this)))
             return JS_FALSE;
diff --git a/js/src/xpconnect/src/xpcwrappednativescope.cpp b/js/src/xpconnect/src/xpcwrappednativescope.cpp
--- a/js/src/xpconnect/src/xpcwrappednativescope.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativescope.cpp
@@ -686,11 +686,7 @@ void DEBUG_CheckForComponentsInScope(XPC
     "callback code."
     "\n";
 
-#ifdef I_FOOLISHLY_WANT_TO_IGNORE_THIS_LIKE_THE_OTHER_CRAP_WE_PRINTF
-    NS_WARNING(msg);
-#else
     NS_ERROR(msg);
-#endif
 }
 #else
 #define DEBUG_CheckForComponentsInScope(ccx, obj, OKIfNotInitialized) ((void)0)
diff --git a/layout/base/nsBidi.cpp b/layout/base/nsBidi.cpp
--- a/layout/base/nsBidi.cpp
+++ b/layout/base/nsBidi.cpp
@@ -1,4 +1,4 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
  *
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
diff --git a/layout/base/nsBidi.h b/layout/base/nsBidi.h
--- a/layout/base/nsBidi.h
+++ b/layout/base/nsBidi.h
@@ -267,7 +267,7 @@ typedef PRUint8 DirProp;
 #define GET_UTF_32(first, second) (((first)<<10UL)+(second)-SURROGATE_OFFSET)
 
 
-#define UTF_ERROR_VALUE 0xffff
+#define UTF_ERROR_VALUE 0xfffd
 /* definitions with forward iteration --------------------------------------- */
 
 /*
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -8339,6 +8339,9 @@ nsCSSFrameConstructor::FindNextAnonymous
 // and col groups, (3) row groups and captions, (4) legends and content inside fieldsets, (5) popups and other kids of the menu
 // are siblings from a content perspective, they are not considered siblings in the 
 // frame tree.
+// XXXldb 307394 [Stir DOM] The way this is used seems completely bogus.
+// We should construct or grovel through pseudo-frames if this is false,
+// not skip content.
 PRBool
 nsCSSFrameConstructor::IsValidSibling(nsIFrame*              aSibling,
                                       nsIContent*            aContent,
@@ -8476,6 +8479,8 @@ nsCSSFrameConstructor::FindPreviousSibli
   ChildIterator first, iter;
   nsresult rv = ChildIterator::Init(aContainer, &first, &iter);
   NS_ENSURE_SUCCESS(rv, nsnull);
+  // XXXldb 307394 [Stir DOM on XUL] if |iter| has mNodes, then this is
+  // meaningless.  Should we even use ChildIterator at all?
   iter.seek(aIndexInContainer);
 
   PRUint8 childDisplay = UNSET_DISPLAY;
@@ -8512,6 +8517,8 @@ nsCSSFrameConstructor::FindNextSibling(n
   ChildIterator iter, last;
   nsresult rv = ChildIterator::Init(aContainer, &iter, &last);
   NS_ENSURE_SUCCESS(rv, nsnull);
+  // XXXldb 307394 [Stir DOM on XUL] if |iter| has mNodes, then this is
+  // meaningless.  Should we even use ChildIterator at all?
   iter.seek(aIndexInContainer);
 
   // Catch the case where someone tries to append
@@ -9080,7 +9087,7 @@ nsCSSFrameConstructor::ContentInserted(n
   // the preceding frame.
   nsIContent* container = parentFrame->GetContent();
 
-  // XXX if the insertionPoint was different from the original
+  // XXX 307394 if the insertionPoint was different from the original
   // parentFrame, then aIndexInContainer is most likely completely
   // wrong. What we need to do here is remember the original index,
   // then as we insert, search the child list where we're about to put
@@ -11397,6 +11404,9 @@ nsCSSFrameConstructor::GetFirstLineStyle
 
 // Predicate to see if a given content (block element) has
 // first-letter style applied to it.
+// XXXldb Bug 362901 This isn't necessarily going to work if changes are
+// batched, since removing the style rule at the same time as messing
+// with content that relies on this could break things pretty badly.
 PRBool
 nsCSSFrameConstructor::ShouldHaveFirstLetterStyle(nsIContent* aContent,
                                                   nsStyleContext* aStyleContext)
@@ -12684,6 +12694,7 @@ nsCSSFrameConstructor::ConstructInline(n
   nsIAtom* blockStyle;
   nsRefPtr<nsStyleContext> blockSC;
   nsIFrame* blockFrame;
+  // XXXldb Remove :-moz-anonymous-positioned-block -- not supported by spec.
   if (aIsPositioned) {
     blockStyle = nsCSSAnonBoxes::mozAnonymousPositionedBlock;
     
diff --git a/layout/base/tests/Makefile.in b/layout/base/tests/Makefile.in
--- a/layout/base/tests/Makefile.in
+++ b/layout/base/tests/Makefile.in
@@ -61,7 +61,7 @@ LOCAL_INCLUDES	= \
 		-I$(srcdir)/../src \
 		$(NULL)
 
-EXTRA_DSO_LIBS	= gkbase_s gkgfx
+EXTRA_DSO_LIBS	= gkbase_s gkgfx gkconbase_s gkconshared_s gkconhtmlstyle_s
 
 LIBS		+= \
 		$(LIBS_DIR) \
diff --git a/layout/forms/nsComboboxControlFrame.cpp b/layout/forms/nsComboboxControlFrame.cpp
--- a/layout/forms/nsComboboxControlFrame.cpp
+++ b/layout/forms/nsComboboxControlFrame.cpp
@@ -1229,7 +1229,7 @@ nsComboboxControlFrame::Destroy()
   if (mDroppedDown) {
     // Get parent view
     nsIFrame * listFrame;
-    if (NS_OK == mListControlFrame->QueryInterface(NS_GET_IID(nsIFrame), (void **)&listFrame)) {
+    if (NS_SUCCEEDED(CallQueryInterface(mListControlFrame, &listFrame))) {
       nsIView* view = listFrame->GetView();
       NS_ASSERTION(view, "nsComboboxControlFrame view is null");
       if (view) {
diff --git a/layout/forms/nsListControlFrame.h b/layout/forms/nsListControlFrame.h
--- a/layout/forms/nsListControlFrame.h
+++ b/layout/forms/nsListControlFrame.h
@@ -455,8 +455,8 @@ protected:
 #endif
 
 private:
-  NS_IMETHOD_(nsrefcnt) AddRef() { return NS_OK; }
-  NS_IMETHOD_(nsrefcnt) Release() { return NS_OK; }
+  NS_IMETHOD_(nsrefcnt) AddRef() { /*NS_NOTREACHED("not supported on frames");*/ return NS_OK; }
+  NS_IMETHOD_(nsrefcnt) Release() { /*NS_NOTREACHED("not supported on frames");*/ return NS_OK; }
 
   // for incremental typing navigation
   static nsAString& GetIncrementalString ();
diff --git a/layout/generic/nsBRFrame.cpp b/layout/generic/nsBRFrame.cpp
--- a/layout/generic/nsBRFrame.cpp
+++ b/layout/generic/nsBRFrame.cpp
@@ -144,7 +144,7 @@ BRFrame::Reflow(nsPresContext* aPresCont
 
       // We also do this in strict mode because BR should act like a
       // normal inline frame.  That line-height is used is important
-      // here for cases where the line-height is less that 1.
+      // here for cases where the line-height is less than 1.
       nsLayoutUtils::SetFontFromStyle(aReflowState.rendContext, mStyleContext);
       nsCOMPtr<nsIFontMetrics> fm;
       aReflowState.rendContext->GetFontMetrics(*getter_AddRefs(fm));
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -945,7 +945,7 @@ nsBlockFrame::Reflow(nsPresContext*     
                                     state.mReflowStatus);
   }
 
-  // If the block is complete, put continuted floats in the closest ancestor 
+  // If the block is complete, put continued floats in the closest ancestor 
   // block that uses the same space manager and leave the block complete; this 
   // allows subsequent lines on the page to be impacted by floats. If the 
   // block is incomplete or there is no ancestor using the same space manager, 
@@ -5689,9 +5689,7 @@ nsBlockFrame::ReflowFloat(nsBlockReflowS
       aReflowStatus = NS_FRAME_COMPLETE;
   }
 
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
+  NS_ENSURE_SUCCESS(rv, rv);
 
   // Capture the margin information for the caller
   const nsMargin& m = floatRS.mComputedMargin;
@@ -6321,9 +6319,7 @@ nsBlockFrame::SetInitialChildList(nsIAto
 #endif
     
     rv = AddFrames(aChildList, nsnull);
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
+    NS_ENSURE_SUCCESS(rv, rv);
 
     // Create list bullet if this is a list-item. Note that this is done
     // here so that RenumberLists will work (it needs the bullets to
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -428,7 +428,7 @@ nsFrame::Init(nsIContent*      aContent,
   DidSetStyleContext();
 
   if (IsBoxWrapped())
-    InitBoxMetrics(PR_FALSE);
+    InitBoxMetrics(PR_FALSE); // XXX propagate allocation failure?
 
   return NS_OK;
 }
@@ -5803,6 +5803,7 @@ nsFrame::RefreshSizeCache(nsBoxLayoutSta
       do {
          lines->GetLine(count, &firstFrame, &framesOnLine, lineBounds, &lineFlags);
 
+         // XXX This should sum across forced breaks!
          if (lineBounds.height > metrics->mBlockMinSize.height)
            metrics->mBlockMinSize.height = lineBounds.height;
 
diff --git a/layout/generic/nsFrame.h b/layout/generic/nsFrame.h
--- a/layout/generic/nsFrame.h
+++ b/layout/generic/nsFrame.h
@@ -613,7 +613,7 @@ private:
 
   NS_IMETHODIMP RefreshSizeCache(nsBoxLayoutState& aState);
 
-protected:
+protected: // XXXldb Private!
   NS_IMETHOD_(nsrefcnt) AddRef(void);
   NS_IMETHOD_(nsrefcnt) Release(void);
 };
diff --git a/layout/generic/nsFrameFrame.cpp b/layout/generic/nsFrameFrame.cpp
--- a/layout/generic/nsFrameFrame.cpp
+++ b/layout/generic/nsFrameFrame.cpp
@@ -681,6 +681,9 @@ nsSubDocumentFrame::AttributeChanged(PRI
         PRBool is_targetable = is_primary ||
           value.LowerCaseEqualsLiteral("content-targetable");
 
+        // Old comment, maybe still valid?
+        // XXXldb The conditions under which this call is made are
+        // different from the conditions under which nsFrameLoader does.
         parentTreeOwner->ContentShellAdded(docShellAsItem, is_primary,
                                            is_targetable, value);
       }
diff --git a/layout/html/tests/block/rtest.sh b/layout/html/tests/block/rtest.sh
--- a/layout/html/tests/block/rtest.sh
+++ b/layout/html/tests/block/rtest.sh
@@ -28,6 +28,7 @@ dirs="  base \
         ../formctls/bugs \
         ../style/bugs \
         ../xbl \
+        net \
         "
 
 # This doesn't appear to work on Linux right now; needs support for a
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -198,8 +198,16 @@ protected:
                             nsMediaList* aMediaList);
 
   PRBool GetToken(nsresult& aErrorCode, PRBool aSkipWS);
-  PRBool GetURLToken(nsresult& aErrorCode);
   void UngetToken();
+
+  // get the part in paretheses of the url() function, which is really a
+  // part of a token in the CSS grammar, but we're using a combination
+  // of the parser and the scanner to do it to hnadle the backtracking
+  // required by the error handling of the tokenization (since if we
+  // fail to scan the full token, we should fall back to tokenizing as
+  // FUNCTION ... ')').
+  // Note that this function WILL WRITE TO aURL IN SOME FAILURE CASES.
+  PRBool GetURLInParens(nsresult& aErrorCode, nsString& aURL);
 
   PRBool ExpectSymbol(nsresult& aErrorCode, PRUnichar aSymbol, PRBool aSkipWS);
   PRBool ExpectEndProperty(nsresult& aErrorCode);
@@ -1165,21 +1173,36 @@ PRBool CSSParserImpl::GetToken(nsresult&
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::GetURLToken(nsresult& aErrorCode)
-{
-  for (;;) {
-    // XXXldb This pushback code doesn't make sense.
-    if (! mHavePushBack) {
-      if (! mScanner.NextURL(aErrorCode, mToken)) {
-        break;
-      }
-    }
-    mHavePushBack = PR_FALSE;
-    if (eCSSToken_WhiteSpace != mToken.mType) {
-      return PR_TRUE;
-    }
-  }
-  return PR_FALSE;
+PRBool CSSParserImpl::GetURLInParens(nsresult& aErrorCode,
+                                     nsString& aURL)
+{
+  if (!ExpectSymbol(aErrorCode, '(', PR_FALSE))
+    return PR_FALSE;
+
+  NS_ASSERTION(!mHavePushBack,
+               "ExpectSymbol returning success shouldn't leave pushback");
+  do {
+    if (! mScanner.NextURL(aErrorCode, mToken)) {
+      return PR_FALSE;
+    }
+  } while (eCSSToken_WhiteSpace == mToken.mType);
+
+  if (eCSSToken_String != mToken.mType && eCSSToken_URL != mToken.mType)
+    return PR_FALSE;
+
+  aURL = mToken.mIdent;
+
+  if (!ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
+    // in the failure case, we have to match parentheses, as if this
+    // weren't treated as a URL token by the tokenization
+
+    // XXX We really need to push aURL back into the buffer before this
+    // SkipUntil!
+    SkipUntil(aErrorCode, ')');
+    return PR_FALSE;
+  }
+
+  return PR_TRUE;
 }
 
 void CSSParserImpl::UngetToken()
@@ -1356,14 +1379,8 @@ PRBool CSSParserImpl::GatherURL(nsresult
   }
   else if (eCSSToken_Function == mToken.mType && 
            mToken.mIdent.LowerCaseEqualsLiteral("url") &&
-           ExpectSymbol(aErrorCode, '(', PR_FALSE) &&
-           GetURLToken(aErrorCode) &&
-           (eCSSToken_String == mToken.mType ||
-            eCSSToken_URL == mToken.mType)) {
-    aURL = mToken.mIdent;
-    if (ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
-      return PR_TRUE;
-    }
+           GetURLInParens(aErrorCode, aURL)) {
+    return PR_TRUE;
   }
   return PR_FALSE;
 }
@@ -1573,15 +1590,9 @@ PRBool CSSParserImpl::ParseMozDocumentRu
       cur->func = nsCSSDocumentRule::eDomain;
     }
 
-    if (!ExpectSymbol(aErrorCode, '(', PR_FALSE) ||
-        !GetURLToken(aErrorCode) ||
-        (eCSSToken_String != mToken.mType &&
-         eCSSToken_URL != mToken.mType)) {
+    nsAutoString url;
+    if (!GetURLInParens(aErrorCode, url)) {
       REPORT_UNEXPECTED_TOKEN(PEMozDocRuleNotURI);
-      delete urls;
-      return PR_FALSE;
-    }
-    if (!ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
       delete urls;
       return PR_FALSE;
     }
@@ -1589,7 +1600,7 @@ PRBool CSSParserImpl::ParseMozDocumentRu
     // We could try to make the URL (as long as it's not domain())
     // canonical and absolute with NS_NewURI and GetSpec, but I'm
     // inclined to think we shouldn't.
-    CopyUTF16toUTF8(mToken.mIdent, cur->url);
+    CopyUTF16toUTF8(url, cur->url);
   } while (ExpectSymbol(aErrorCode, ',', PR_TRUE));
 
   nsRefPtr<nsCSSDocumentRule> rule(new nsCSSDocumentRule());
@@ -1634,18 +1645,10 @@ PRBool CSSParserImpl::ParseNameSpaceRule
   }
   else if ((eCSSToken_Function == mToken.mType) && 
            (mToken.mIdent.LowerCaseEqualsLiteral("url"))) {
-    if (ExpectSymbol(aErrorCode, '(', PR_FALSE)) {
-      if (GetURLToken(aErrorCode)) {
-        if ((eCSSToken_String == mToken.mType) || (eCSSToken_URL == mToken.mType)) {
-          url = mToken.mIdent;
-          if (ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
-            if (ExpectSymbol(aErrorCode, ';', PR_TRUE)) {
-              ProcessNameSpace(aErrorCode, prefix, url, aAppendFunc, aData);
-              return PR_TRUE;
-            }
-          }
-        }
-      }
+    if (GetURLInParens(aErrorCode, url) &&
+        ExpectSymbol(aErrorCode, ';', PR_TRUE)) {
+      ProcessNameSpace(aErrorCode, prefix, url, aAppendFunc, aData);
+      return PR_TRUE;
     }
   }
   REPORT_UNEXPECTED_TOKEN(PEAtNSUnexpected);
@@ -4101,39 +4104,32 @@ PRBool CSSParserImpl::ParseURL(nsresult&
                   "origin principal");
     return PR_FALSE;
   }
-  
-  if (ExpectSymbol(aErrorCode, '(', PR_FALSE)) {
-    if (! GetURLToken(aErrorCode)) {
-      return PR_FALSE;
-    }
-    nsCSSToken* tk = &mToken;
-    if ((eCSSToken_String == tk->mType) || (eCSSToken_URL == tk->mType)) {
-      // Translate url into an absolute url if the url is relative to
-      // the style sheet.
-      nsCOMPtr<nsIURI> uri;
-      NS_NewURI(getter_AddRefs(uri), tk->mIdent, nsnull, mBaseURL);
-      if (ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
-        // Set a null value on failure.  Most failure cases should be
-        // NS_ERROR_MALFORMED_URI.
-        nsStringBuffer* buffer = nsCSSValue::BufferFromString(tk->mIdent);
-        if (NS_UNLIKELY(!buffer)) {
-          aErrorCode = NS_ERROR_OUT_OF_MEMORY;
-          return PR_FALSE;
-        }
-
-        nsCSSValue::URL *url =
-          new nsCSSValue::URL(uri, buffer, mSheetURL, mSheetPrincipal);
-        buffer->Release();
-        if (NS_UNLIKELY(!url)) {
-          aErrorCode = NS_ERROR_OUT_OF_MEMORY;
-          return PR_FALSE;
-        }
-        aValue.SetURLValue(url);
-        return PR_TRUE;
-      }
-    }
-  }
-  return PR_FALSE;
+
+  nsAutoString str;
+  if (! GetURLInParens(aErrorCode, str)) {
+    return PR_FALSE;
+  }
+  // Translate str into an absolute url if the url is relative to
+  // the style sheet.
+  nsCOMPtr<nsIURI> uri;
+  NS_NewURI(getter_AddRefs(uri), str, nsnull, mBaseURL);
+  // Set a null value on failure.  Most failure cases should be
+  // NS_ERROR_MALFORMED_URI.
+  nsStringBuffer* buffer = nsCSSValue::BufferFromString(str);
+  if (NS_UNLIKELY(!buffer)) {
+    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    return PR_FALSE;
+  }
+
+  nsCSSValue::URL *url =
+    new nsCSSValue::URL(uri, buffer, mSheetURL, mSheetPrincipal);
+  buffer->Release();
+  if (NS_UNLIKELY(!url)) {
+    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    return PR_FALSE;
+  }
+  aValue.SetURLValue(url);
+  return PR_TRUE;
 }
 
 PRInt32 CSSParserImpl::ParseChoice(nsresult& aErrorCode, nsCSSValue aValues[],
diff --git a/layout/style/nsCSSScanner.cpp b/layout/style/nsCSSScanner.cpp
--- a/layout/style/nsCSSScanner.cpp
+++ b/layout/style/nsCSSScanner.cpp
@@ -743,23 +743,6 @@ PRBool nsCSSScanner::NextURL(nsresult& a
     (void) EatWhiteSpace(aErrorCode);
     return PR_TRUE;
   }
-  if (ch == '/') {
-    PRInt32 nextChar = Peek(aErrorCode);
-    if (nextChar == '*') {
-      (void) Read(aErrorCode);
-#if 0
-      // If we change our storage data structures such that comments are
-      // stored (for Editor), we should reenable this code, condition it
-      // on being in editor mode, and apply glazou's patch from bug
-      // 60290.
-      aToken.mIdent.SetCapacity(2);
-      aToken.mIdent.Assign(PRUnichar(ch));
-      aToken.mIdent.Append(PRUnichar(nextChar));
-      return ParseCComment(aErrorCode, aToken);
-#endif
-      return SkipCComment(aErrorCode) && Next(aErrorCode, aToken);
-    }
-  }
 
   // Process a url lexical token. A CSS1 url token can contain
   // characters beyond identifier characters (e.g. '/', ':', etc.)
@@ -767,55 +750,55 @@ PRBool nsCSSScanner::NextURL(nsresult& a
   // apply very well. To simplify the parser and relax some of the
   // requirements on the scanner we parse url's here. If we find a
   // malformed URL then we emit a token of type "InvalidURL" so that
-  // the CSS1 parser can ignore the invalid input. We attempt to eat
-  // the right amount of input data when an invalid URL is presented.
+  // the CSS1 parser can ignore the invalid input.  The parser must
+  // treat an InvalidURL token like a Function token, and process
+  // tokens until a matching parenthesis.
 
   aToken.mType = eCSSToken_InvalidURL;
   nsString& ident = aToken.mIdent;
   ident.SetLength(0);
 
-  if (ch == ')') {
-    Pushback(ch);
-    // empty url spec; just get out of here
+  Pushback(ch);
+
+  // start of a non-quoted url (which may be empty)
+  PRBool ok = PR_TRUE;
+  for (;;) {
+    ch = Read(aErrorCode);
+    if (ch < 0) break;
+    if (ch == CSS_ESCAPE) {
+      ParseAndAppendEscape(aErrorCode, ident);
+    } else if ((ch == '"') || (ch == '\'') || (ch == '(')) {
+      // This is an invalid URL spec
+      ok = PR_FALSE;
+      Pushback(ch); // push it back so the parser can match tokens and
+                    // then closing parenthesis
+      break;
+    } else if (IsWhitespace(ch)) {
+      // Whitespace is allowed at the end of the URL
+      (void) EatWhiteSpace(aErrorCode);
+      if (LookAhead(aErrorCode, ')')) {
+        Pushback(')');  // leave the closing symbol
+        // done!
+        break;
+      }
+      // Whitespace is followed by something other than a
+      // ")". This is an invalid url spec.
+      ok = PR_FALSE;
+      break;
+    } else if (ch == ')') {
+      Pushback(ch);
+      // All done
+      break;
+    } else {
+      // A regular url character.
+      ident.Append(PRUnichar(ch));
+    }
+  }
+
+  // If the result of the above scanning is ok then change the token
+  // type to a useful one.
+  if (ok) {
     aToken.mType = eCSSToken_URL;
-  } else {
-    // start of a non-quoted url
-    Pushback(ch);
-    PRBool ok = PR_TRUE;
-    for (;;) {
-      ch = Read(aErrorCode);
-      if (ch < 0) break;
-      if (ch == CSS_ESCAPE) {
-        ParseAndAppendEscape(aErrorCode, ident);
-      } else if ((ch == '"') || (ch == '\'') || (ch == '(')) {
-        // This is an invalid URL spec
-        ok = PR_FALSE;
-      } else if (IsWhitespace(ch)) {
-        // Whitespace is allowed at the end of the URL
-        (void) EatWhiteSpace(aErrorCode);
-        if (LookAhead(aErrorCode, ')')) {
-          Pushback(')');  // leave the closing symbol
-          // done!
-          break;
-        }
-        // Whitespace is followed by something other than a
-        // ")". This is an invalid url spec.
-        ok = PR_FALSE;
-      } else if (ch == ')') {
-        Pushback(ch);
-        // All done
-        break;
-      } else {
-        // A regular url character.
-        ident.Append(PRUnichar(ch));
-      }
-    }
-
-    // If the result of the above scanning is ok then change the token
-    // type to a useful one.
-    if (ok) {
-      aToken.mType = eCSSToken_URL;
-    }
   }
   return PR_TRUE;
 }
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -520,7 +520,7 @@ struct nsStyleOutline: public nsStyleStr
   // Note that these are specified values.  You can get the actual values with
   // GetOutlineWidth and GetOutlineOffset.  You cannot get the computed values
   // directly.
-  nsStyleCoord  mOutlineOffset;   // [reset] length
+  nsStyleCoord  mOutlineOffset;   // [reset] length XXX Why nsStyleCoord?
   nsStyleCoord  mOutlineWidth;    // [reset] length, enum (see nsStyleConsts.h)
 
   PRBool GetOutlineOffset(nscoord& aOffset) const
@@ -638,7 +638,7 @@ struct nsStylePosition : public nsStyleS
   static nsChangeHint MaxDifference();
 #endif
   
-  nsStyleSides  mOffset;                // [reset]
+  nsStyleSides  mOffset;                // [reset] XXX WHICH TYPES?
   nsStyleCoord  mWidth;                 // [reset] coord, percent, auto, enum
   nsStyleCoord  mMinWidth;              // [reset] coord, percent, enum
   nsStyleCoord  mMaxWidth;              // [reset] coord, percent, null, enum
@@ -646,7 +646,7 @@ struct nsStylePosition : public nsStyleS
   nsStyleCoord  mMinHeight;             // [reset] coord, percent
   nsStyleCoord  mMaxHeight;             // [reset] coord, percent, null
   PRUint8       mBoxSizing;             // [reset] see nsStyleConsts.h
-  nsStyleCoord  mZIndex;                // [reset] 
+  nsStyleCoord  mZIndex;                // [reset] XXX WHICH TYPES?
 };
 
 struct nsStyleTextReset : public nsStyleStruct {
@@ -670,7 +670,7 @@ struct nsStyleTextReset : public nsStyle
   PRUint8 mTextDecoration;              // [reset] see nsStyleConsts.h
   PRUint8 mUnicodeBidi;                 // [reset] see nsStyleConsts.h
 
-  nsStyleCoord  mVerticalAlign;         // [reset] see nsStyleConsts.h for enums
+  nsStyleCoord  mVerticalAlign;         // [reset] see nsStyleConsts.h for enums XXX WHICH TYPES?
 };
 
 struct nsStyleText : public nsStyleStruct {
@@ -695,10 +695,10 @@ struct nsStyleText : public nsStyleStruc
   PRUint8 mTextTransform;               // [inherited] see nsStyleConsts.h
   PRUint8 mWhiteSpace;                  // [inherited] see nsStyleConsts.h
 
-  nsStyleCoord  mLetterSpacing;         // [inherited] 
-  nsStyleCoord  mLineHeight;            // [inherited] 
-  nsStyleCoord  mTextIndent;            // [inherited] 
-  nsStyleCoord  mWordSpacing;           // [inherited] 
+  nsStyleCoord  mLetterSpacing;         // [inherited] XXX WHICH TYPES?
+  nsStyleCoord  mLineHeight;            // [inherited] XXX WHICH TYPES?
+  nsStyleCoord  mTextIndent;            // [inherited] XXX WHICH TYPES?
+  nsStyleCoord  mWordSpacing;           // [inherited] XXX WHICH TYPES?
   
   PRBool WhiteSpaceIsSignificant() const {
     return mWhiteSpace == NS_STYLE_WHITESPACE_PRE ||
@@ -878,8 +878,8 @@ struct nsStyleTableBorder: public nsStyl
   static nsChangeHint MaxDifference();
 #endif
   
-  nsStyleCoord  mBorderSpacingX;// [inherited]
-  nsStyleCoord  mBorderSpacingY;// [inherited]
+  nsStyleCoord  mBorderSpacingX;// [inherited] XXX WHICH TYPES?
+  nsStyleCoord  mBorderSpacingY;// [inherited] XXX WHICH TYPES?
   PRUint8       mBorderCollapse;// [inherited]
   PRUint8       mCaptionSide;   // [inherited]
   PRUint8       mEmptyCells;    // [inherited]
@@ -1088,7 +1088,7 @@ struct nsStyleContent: public nsStyleStr
     return NS_ERROR_ILLEGAL_VALUE;
   }
 
-  nsStyleCoord  mMarkerOffset;  // [reset]
+  nsStyleCoord  mMarkerOffset;  // [reset] XXX WHICH TYPES?
 
 protected:
   PRUint32            mContentCount;
@@ -1212,7 +1212,7 @@ struct nsStyleColumn : public nsStyleStr
 #endif
 
   PRUint32     mColumnCount; // [reset] see nsStyleConsts.h
-  nsStyleCoord mColumnWidth; // [reset]
+  nsStyleCoord mColumnWidth; // [reset] XXX WHICH TYPES?
   nsStyleCoord mColumnGap;   // [reset] coord
 };
 
@@ -1266,10 +1266,10 @@ struct nsStyleSVG : public nsStyleStruct
   nsCOMPtr<nsIURI> mMarkerEnd;        // [inherited]
   nsCOMPtr<nsIURI> mMarkerMid;        // [inherited]
   nsCOMPtr<nsIURI> mMarkerStart;      // [inherited]
-  nsStyleCoord    *mStrokeDasharray;  // [inherited]
+  nsStyleCoord    *mStrokeDasharray;  // [inherited] XXX WHICH TYPES?
 
-  nsStyleCoord     mStrokeDashoffset; // [inherited]
-  nsStyleCoord     mStrokeWidth;      // [inherited]
+  nsStyleCoord     mStrokeDashoffset; // [inherited] XXX WHICH TYPES?
+  nsStyleCoord     mStrokeWidth;      // [inherited] XXX WHICH TYPES?
 
   float            mFillOpacity;      // [inherited]
   float            mStrokeMiterlimit; // [inherited]
diff --git a/layout/style/ua.css b/layout/style/ua.css
--- a/layout/style/ua.css
+++ b/layout/style/ua.css
@@ -128,6 +128,7 @@
 *|*::-moz-anonymous-block, *|*::-moz-cell-content {
   display: block !important;
   position: static !important;
+  /* XXX shouldn't unicode-bidi inherit? */
 }
 
 *|*::-moz-xul-anonymous-block {
diff --git a/layout/tables/FixedTableLayoutStrategy.cpp b/layout/tables/FixedTableLayoutStrategy.cpp
--- a/layout/tables/FixedTableLayoutStrategy.cpp
+++ b/layout/tables/FixedTableLayoutStrategy.cpp
@@ -129,6 +129,8 @@ FixedTableLayoutStrategy::GetMinWidth(ns
                         // row, split up the space evenly.  (XXX This
                         // isn't quite right if some of the columns it's
                         // in have specified widths.  Should we care?)
+                        // XXXldb This doesn't consider columns with no
+                        // cells originating.
                         cellWidth = ((cellWidth + spacing) / colSpan) - spacing;
                     }
                     result += cellWidth;
@@ -141,6 +143,7 @@ FixedTableLayoutStrategy::GetMinWidth(ns
                 }
                 // else, for 'auto', '-moz-available', and '-moz-fit-content'
                 // do nothing
+                // XXXldb Bug 364989
             }
         }
     }
diff --git a/layout/tables/nsTableCellFrame.cpp b/layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp
+++ b/layout/tables/nsTableCellFrame.cpp
@@ -467,6 +467,7 @@ nsTableCellFrame::BuildDisplayList(nsDis
   if (quirkyClip) {
     clip = nsRect(nsPoint(0, 0), GetSize());
   }
+  // XXXldb Should this really OverflowClip?  (Used to be: Should this really SetClipRect?)
   return OverflowClip(aBuilder, set, aLists, clip + aBuilder->ToReferenceFrame(this));
 }
 
diff --git a/layout/tables/nsTableFrame.cpp b/layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp
+++ b/layout/tables/nsTableFrame.cpp
@@ -360,6 +360,7 @@ nsTableFrame::SetInitialChildList(nsIAto
     }
     else
     { // unknown frames go on the main list for now
+      NS_NOTREACHED("yikes, unknown frame type");
       if (mFrames.IsEmpty())
         mFrames.SetFrames(childFrame);
       else
diff --git a/layout/tables/nsTableOuterFrame.cpp b/layout/tables/nsTableOuterFrame.cpp
--- a/layout/tables/nsTableOuterFrame.cpp
+++ b/layout/tables/nsTableOuterFrame.cpp
@@ -660,6 +660,7 @@ nsTableOuterFrame::GetPrefWidth(nsIRende
     case NS_SIDE_BOTTOM:
     default:  // no caption 
       {
+        // XXXldb Use min width?
         nscoord capPref =
           nsLayoutUtils::IntrinsicForContainer(aRenderingContext, mCaptionFrame,
                                                nsLayoutUtils::PREF_WIDTH);
diff --git a/layout/tables/nsTableRowFrame.cpp b/layout/tables/nsTableRowFrame.cpp
--- a/layout/tables/nsTableRowFrame.cpp
+++ b/layout/tables/nsTableRowFrame.cpp
@@ -194,6 +194,8 @@ nsTableRowFrame::AppendFrames(nsIAtom*  
     if (IS_TABLE_CELL(childFrame->GetType())) {
       // Add the cell to the cell map
       tableFrame->AppendCell((nsTableCellFrame&)*childFrame, GetRowIndex());
+    } else {
+      NS_NOTREACHED("unexpected child of table row");
     }
   }
 
@@ -225,6 +227,8 @@ nsTableRowFrame::InsertFrames(nsIAtom*  
        childFrame = childFrame->GetNextSibling()) {
     if (IS_TABLE_CELL(childFrame->GetType())) {
       cellChildren.AppendElement(childFrame);
+    } else {
+      NS_NOTREACHED("unexpected child of table row");
     }
   }
   // insert the cells into the cell map
diff --git a/layout/xul/base/src/nsBoxFrame.cpp b/layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp
+++ b/layout/xul/base/src/nsBoxFrame.cpp
@@ -549,6 +549,7 @@ nsBoxFrame::GetInitialDirection(PRBool& 
   
   // Now see if we have an attribute.  The attribute overrides
   // the style system value.
+  // XXXldb This makes two reverses go back to normal!
   static nsIContent::AttrValuesArray strings[] =
     {&nsGkAtoms::reverse, &nsGkAtoms::ltr, &nsGkAtoms::rtl, nsnull};
   PRInt32 index = GetContent()->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::dir,
@@ -1849,10 +1850,11 @@ nsBoxFrame::CreateViewForFrame(nsPresCon
         if (scrollingView) {
           scrollingView->SetScrolledView(view);
         } else {
-          viewManager->SetViewZIndex(view, autoZIndex, zIndex);
           // XXX put view last in document order until we can do better
           viewManager->InsertChild(parentView, view, nsnull, PR_TRUE);
         }
+        nsContainerFrame::SyncFrameViewProperties(aPresContext, aFrame,
+                                                  nsnull, view);
       }
 
       // Remember our view
diff --git a/layout/xul/base/src/nsDeckFrame.cpp b/layout/xul/base/src/nsDeckFrame.cpp
--- a/layout/xul/base/src/nsDeckFrame.cpp
+++ b/layout/xul/base/src/nsDeckFrame.cpp
@@ -123,6 +123,9 @@ nsDeckFrame::HideBox(nsPresContext* aPre
   if (view) {
     nsIViewManager* viewManager = view->GetViewManager();
     viewManager->SetViewVisibility(view, nsViewVisibility_kHide);
+    // XXX This can go away when our notion of view visibility applies
+    // better to descendant views. (i.e., more callers use IsVisible
+    // rather than GetVisibility).
     viewManager->ResizeView(view, nsRect(0, 0, 0, 0));
   }
 }
@@ -135,6 +138,9 @@ nsDeckFrame::ShowBox(nsPresContext* aPre
   if (view) {
     nsIViewManager* viewManager = view->GetViewManager();
     rect.x = rect.y = 0;
+    // XXX This can go away when our notion of view visibility applies
+    // better to descendant views. (i.e., more callers use IsVisible
+    // rather than GetVisibility).
     viewManager->ResizeView(view, rect);
     viewManager->SetViewVisibility(view, nsViewVisibility_kShow);
   }
diff --git a/layout/xul/base/src/nsScrollBoxFrame.cpp b/layout/xul/base/src/nsScrollBoxFrame.cpp
--- a/layout/xul/base/src/nsScrollBoxFrame.cpp
+++ b/layout/xul/base/src/nsScrollBoxFrame.cpp
@@ -46,6 +46,7 @@
 #include "nsITimer.h"
 #include "nsRepeatService.h"
 
+// XXXldb This should not implement nsITimerCallback!
 class nsAutoRepeatBoxFrame : public nsButtonBoxFrame, 
                              public nsITimerCallback
 {
diff --git a/layout/xul/base/src/nsSprocketLayout.cpp b/layout/xul/base/src/nsSprocketLayout.cpp
--- a/layout/xul/base/src/nsSprocketLayout.cpp
+++ b/layout/xul/base/src/nsSprocketLayout.cpp
@@ -251,9 +251,7 @@ nsSprocketLayout::Layout(nsIBox* aBox, n
   // The |size| variable will hold the total size of children along the axis of
   // the box.  Continuing with the example begun in the comment above, size would
   // be 150 pixels.
-  nscoord size = clientRect.width;
-  if (!IsHorizontal(aBox))
-    size = clientRect.height;
+  nscoord size = IsHorizontal(aBox) ? clientRect.width : clientRect.height;
   ComputeChildSizes(aBox, aState, size, boxSizes, computedBoxSizes);
 
   // After the call to ComputeChildSizes, the |size| variable contains the
diff --git a/mailnews/addrbook/src/nsAddrDatabase.cpp b/mailnews/addrbook/src/nsAddrDatabase.cpp
--- a/mailnews/addrbook/src/nsAddrDatabase.cpp
+++ b/mailnews/addrbook/src/nsAddrDatabase.cpp
@@ -1060,7 +1060,7 @@ nsresult nsAddrDatabase::CheckAndUpdateR
 
   nsresult err = NS_OK;
   nsIMdbTableRowCursor* rowCursor = nsnull;
-  nsIMdbRow* findRow = nsnull;
+  nsCOMPtr<nsIMdbRow> findRow;
   mdb_pos    rowPos = 0;
 
   mdb_err merror = m_mdbPabTable->GetTableRowCursor(m_mdbEnv, -1, &rowCursor);
@@ -1075,7 +1075,7 @@ nsresult nsAddrDatabase::CheckAndUpdateR
 
   do
   {  //add key to each card and mailing list row
-    merror = rowCursor->NextRow(m_mdbEnv, &findRow, &rowPos);
+    merror = rowCursor->NextRow(m_mdbEnv, getter_AddRefs(findRow), &rowPos);
     if (merror == NS_OK && findRow)
     {
       mdbOid rowOid;
diff --git a/modules/oji/src/nsJVMManager.cpp b/modules/oji/src/nsJVMManager.cpp
--- a/modules/oji/src/nsJVMManager.cpp
+++ b/modules/oji/src/nsJVMManager.cpp
@@ -120,7 +120,6 @@ static NS_DEFINE_IID(kIJVMManagerIID, NS
 static NS_DEFINE_IID(kIJVMManagerIID, NS_IJVMMANAGER_IID);
 static NS_DEFINE_IID(kIJVMThreadManagerIID, NS_IJVMTHREADMANAGER_IID);
 static NS_DEFINE_IID(kILiveConnectManagerIID, NS_ILIVECONNECTMANAGER_IID);
-static NS_DEFINE_IID(kIJVMPluginIID, NS_IJVMPLUGIN_IID);
 
 #define PLUGIN_REGIONAL_URL "chrome://global-region/locale/region.properties"
 
@@ -384,7 +383,7 @@ nsJVMManager::PostEvent(PRThread* prthre
 }
 
 nsJVMManager::nsJVMManager(nsISupports* outer)
-    : fJVM(NULL), fStatus(nsJVMStatus_Enabled),
+    : fStatus(nsJVMStatus_Enabled),
       fDebugManager(NULL), fJSJavaVM(NULL),
       fClassPathAdditions(new nsVoidArray()), fClassPathAdditionsString(NULL),
       fStartupMessagePosted(PR_FALSE)
@@ -411,10 +410,7 @@ nsJVMManager::~nsJVMManager()
     delete fClassPathAdditions;
     if (fClassPathAdditionsString)
         PR_Free(fClassPathAdditionsString);
-    if (fJVM) {
-        /*nsrefcnt c =*/ fJVM->Release();   // Release for QueryInterface in GetJVM
-        // XXX unload plugin if c == 1 ? (should this be done inside Release?)
-    }
+    // XXX unload plugin if fJVM's refcount is 1?
 }
 
 nsresult
@@ -662,7 +658,7 @@ nsJVMManager::StartupJVM(void)
     EnterMonitor(&uStatus);
 #endif // MOZ_OJI_REQUIRE_THREAD_SAFE_ON_STARTUP    
 
-    PR_ASSERT(fJVM == NULL);
+    PR_ASSERT(fJVM == nsnull);
     /*
     **TODO: amusil. Load the plugin by getting into Service manager.
     **              Right now there is no API to do this stuff. We need to
@@ -697,18 +693,18 @@ nsJVMManager::StartupJVM(void)
         return fStatus;
     }
 
-    nsIPlugin* pluginFactory = NULL;
+    nsCOMPtr<nsIPlugin> pluginFactory;
      // this code is the correct way to obtain pluggable JVM
     nsCOMPtr<nsIPlugin> f = 
              do_GetService(NS_INLINE_PLUGIN_CONTRACTID_PREFIX NS_JVM_MIME_TYPE, &err);
     if (NS_FAILED(err) || !f) {
-        err = pluginHost->GetPluginFactory(NS_JVM_MIME_TYPE, &pluginFactory);
+        err = pluginHost->GetPluginFactory(NS_JVM_MIME_TYPE, getter_AddRefs(pluginFactory));
     } 
     else {
         pluginFactory  = f;
     }
     
-    if (pluginFactory == NULL) {
+    if (!pluginFactory) {
         fStatus = nsJVMStatus_Failed;
 
 #ifdef MOZ_OJI_REQUIRE_THREAD_SAFE_ON_STARTUP    
@@ -718,9 +714,10 @@ nsJVMManager::StartupJVM(void)
         return fStatus;
     }
 
-    nsresult rslt = pluginFactory->QueryInterface(kIJVMPluginIID, (void**)&fJVM);
+    nsresult rslt;
+    fJVM = do_QueryInterface(pluginFactory, &rslt);
     if (rslt != NS_OK) {
-        PR_ASSERT(fJVM == NULL);
+        PR_ASSERT(fJVM == nsnull);
         fStatus = nsJVMStatus_Failed;
 
 #ifdef MOZ_OJI_REQUIRE_THREAD_SAFE_ON_STARTUP    
@@ -738,8 +735,6 @@ nsJVMManager::StartupJVM(void)
     JSContext* crippledContext = LM_GetCrippledContext();
     MaybeStartupLiveConnect(crippledContext, JS_GetGlobalObject(crippledContext));
 #endif
-
-    fJVM->Release();
 
 #ifdef DEBUG
     PRIntervalTime end = PR_IntervalNow();
@@ -766,7 +761,7 @@ nsJVMManager::ShutdownJVM(PRBool fullShu
 nsJVMManager::ShutdownJVM(PRBool fullShutdown)
 {
     if (fStatus == nsJVMStatus_Running) {
-        PR_ASSERT(fJVM != NULL);
+        PR_ASSERT(fJVM != nsnull);
         // XXX need to shutdown JVM via ServiceManager
 //        nsresult err = fJVM->ShutdownJVM(fullShutdown);
 //        if (err == NS_OK)
@@ -775,9 +770,9 @@ nsJVMManager::ShutdownJVM(PRBool fullShu
 //            ReportJVMError(err);
 //            fStatus = nsJVMStatus_Disabled;
 //        }
-        fJVM = NULL;
+        fJVM = nsnull;
     }
-    PR_ASSERT(fJVM == NULL);
+    PR_ASSERT(fJVM == nsnull);
     return fStatus;
 }
 
diff --git a/modules/oji/src/nsJVMManager.h b/modules/oji/src/nsJVMManager.h
--- a/modules/oji/src/nsJVMManager.h
+++ b/modules/oji/src/nsJVMManager.h
@@ -221,7 +221,7 @@ protected:
     nsresult    GetChrome(nsIWebBrowserChrome **theChrome);
     const char* GetJavaErrorString(JRIEnv* env);
 
-    nsIJVMPlugin*       fJVM;
+    nsCOMPtr<nsIJVMPlugin> fJVM;
     nsJVMStatus         fStatus;
     nsISupports*        fDebugManager;
     JSJavaVM *          fJSJavaVM;  
diff --git a/modules/plugin/base/public/nsIPluginInstanceInternal.h b/modules/plugin/base/public/nsIPluginInstanceInternal.h
--- a/modules/plugin/base/public/nsIPluginInstanceInternal.h
+++ b/modules/plugin/base/public/nsIPluginInstanceInternal.h
@@ -53,6 +53,8 @@ public:
 public: 
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IPLUGININSTANCEINTERNAL_IID)
 
+  // The caller needs to root this object before making most JS API
+  // calls.
   virtual JSObject *GetJSObject(JSContext *cx) = 0;
 
   virtual nsresult GetFormValue(nsAString& aValue) = 0;
diff --git a/modules/plugin/base/src/ns4xPlugin.cpp b/modules/plugin/base/src/ns4xPlugin.cpp
--- a/modules/plugin/base/src/ns4xPlugin.cpp
+++ b/modules/plugin/base/src/ns4xPlugin.cpp
@@ -2091,6 +2091,8 @@ _setvalue(NPP npp, NPPVariable variable,
             rv = NS_ERROR_FAILURE;
 
             nsCOMPtr<nsIPluginInstancePeer> peer;
+            // XXXldb Shouldn't this return failure if peer is null
+            // (i.e., just skip the null-check)?
             if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
               nsCOMPtr<nsIPluginInstancePeer2> peer2 =
                 do_QueryInterface(peer);
@@ -2100,10 +2102,13 @@ _setvalue(NPP npp, NPPVariable variable,
                 rv = peer2->GetJSContext(&cx);
 
                 if (NS_SUCCEEDED(rv))
+                  // XXXldb Should assert that every push a plugin does
+                  // is matched by a pop.
                   rv = contextStack->Push(cx);
               }
             }
           } else {
+            // XXXldb Should assert that it's the right context!
             rv = contextStack->Pop(nsnull);
           }
         }
diff --git a/netwerk/base/src/nsProtocolProxyService.h b/netwerk/base/src/nsProtocolProxyService.h
--- a/netwerk/base/src/nsProtocolProxyService.h
+++ b/netwerk/base/src/nsProtocolProxyService.h
@@ -319,6 +319,8 @@ protected:
     };
 
     // simplified array of filters defined by this struct
+    struct HostInfo;
+    friend struct HostInfo;
     struct HostInfo {
         PRBool  is_ipaddr;
         PRInt32 port;
diff --git a/netwerk/base/src/nsStandardURL.cpp b/netwerk/base/src/nsStandardURL.cpp
--- a/netwerk/base/src/nsStandardURL.cpp
+++ b/netwerk/base/src/nsStandardURL.cpp
@@ -55,6 +55,7 @@
 #include "prlog.h"
 #include "nsAutoPtr.h"
 #include "nsIProgrammingLanguage.h"
+#include "nsVoidArray.h"
 
 static NS_DEFINE_CID(kThisImplCID, NS_THIS_STANDARDURL_IMPL_CID);
 static NS_DEFINE_CID(kStandardURLCID, NS_STANDARDURL_CID);
@@ -268,6 +269,10 @@ nsSegmentEncoder::InitUnicodeEncoder()
 // nsStandardURL <public>
 //----------------------------------------------------------------------------
 
+#ifdef DEBUG_DUMP_URLS_AT_SHUTDOWN
+static PRCList gAllURLs;
+#endif
+
 nsStandardURL::nsStandardURL(PRBool aSupportsFileURL)
     : mDefaultPort(-1)
     , mPort(-1)
@@ -292,6 +297,10 @@ nsStandardURL::nsStandardURL(PRBool aSup
 
     // default parser in case nsIStandardURL::Init is never called
     mParser = net_GetStdURLParser();
+
+#ifdef DEBUG_DUMP_URLS_AT_SHUTDOWN
+    PR_APPEND_LINK(&mDebugCList, &gAllURLs);
+#endif
 }
 
 nsStandardURL::~nsStandardURL()
@@ -299,7 +308,23 @@ nsStandardURL::~nsStandardURL()
     LOG(("Destroying nsStandardURL @%p\n", this));
 
     CRTFREEIF(mHostA);
+#ifdef DEBUG_DUMP_URLS_AT_SHUTDOWN
+    PR_REMOVE_LINK(&mDebugCList);
+#endif
 }
+
+#ifdef DEBUG_DUMP_URLS_AT_SHUTDOWN
+static void DumpLeakedURLs()
+{
+    if (!PR_CLIST_IS_EMPTY(&gAllURLs)) {
+        printf("Leaked URLs:\n");
+        for (PRCList *l = PR_LIST_HEAD(&gAllURLs); l != &gAllURLs; l = PR_NEXT_LINK(l)) {
+            nsStandardURL *url = reinterpret_cast<nsStandardURL*>(reinterpret_cast<char*>(l) - offsetof(nsStandardURL, mDebugCList));
+            url->PrintSpec();
+        }
+    }
+}
+#endif
 
 void
 nsStandardURL::InitGlobalObjects()
@@ -314,6 +339,11 @@ nsStandardURL::InitGlobalObjects()
 
         PrefsChanged(prefBranch, nsnull);
     }
+
+#ifdef DEBUG_DUMP_URLS_AT_SHUTDOWN
+    PR_INIT_CLIST(&gAllURLs);
+    atexit(DumpLeakedURLs);
+#endif
 }
 
 void
diff --git a/netwerk/base/src/nsStandardURL.h b/netwerk/base/src/nsStandardURL.h
--- a/netwerk/base/src/nsStandardURL.h
+++ b/netwerk/base/src/nsStandardURL.h
@@ -53,6 +53,11 @@
 #include "nsCOMPtr.h"
 #include "nsURLHelper.h"
 #include "nsIClassInfo.h"
+#include "prclist.h"
+
+#ifdef DEBUG_dbaron
+#define DEBUG_DUMP_URLS_AT_SHUTDOWN
+#endif
 
 class nsIBinaryInputStream;
 class nsIBinaryOutputStream;
@@ -271,6 +276,12 @@ private:
     static PRBool                       gEscapeUTF8;
     static PRBool                       gAlwaysEncodeInUTF8;
     static PRBool                       gEncodeQueryInUTF8;
+
+public:
+#ifdef DEBUG_DUMP_URLS_AT_SHUTDOWN
+    PRCList mDebugCList;
+    void PrintSpec() const { printf("  %s\n", mSpec.get()); }
+#endif
 };
 
 #define NS_THIS_STANDARDURL_IMPL_CID                 \
diff --git a/netwerk/cache/src/nsCacheService.cpp b/netwerk/cache/src/nsCacheService.cpp
--- a/netwerk/cache/src/nsCacheService.cpp
+++ b/netwerk/cache/src/nsCacheService.cpp
@@ -65,6 +65,7 @@
 #include "nsThreadUtils.h"
 #include "nsProxyRelease.h"
 #include "nsVoidArray.h"
+#include "nsReadableUtils.h"
 #include "nsDeleteDir.h"
 #include <math.h>  // for log()
 
@@ -170,7 +171,7 @@ nsCacheProfilePrefObserver::Install()
     nsCOMPtr<nsIPrefBranch2> branch = do_GetService(NS_PREFSERVICE_CONTRACTID);
     if (!branch) return NS_ERROR_FAILURE;
 
-    char * prefList[] = { 
+    static const char prefList[][39] = { 
         DISK_CACHE_ENABLE_PREF,
         DISK_CACHE_CAPACITY_PREF,
         DISK_CACHE_DIR_PREF,
@@ -180,9 +181,8 @@ nsCacheProfilePrefObserver::Install()
         MEMORY_CACHE_ENABLE_PREF,
         MEMORY_CACHE_CAPACITY_PREF
     };
-    int listCount = NS_ARRAY_LENGTH(prefList);
       
-    for (int i=0; i<listCount; i++) {
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(prefList); ++i) {
         rv = branch->AddObserver(prefList[i], this, PR_FALSE);
         if (NS_FAILED(rv))  rv2 = rv;
     }
@@ -246,7 +246,9 @@ nsCacheProfilePrefObserver::Observe(nsIS
                                     const PRUnichar * data_unicode)
 {
     nsresult rv;
-    NS_ConvertUTF16toUTF8 data(data_unicode);
+    nsCAutoString data;
+    if (data_unicode)
+        AppendUTF16toUTF8(data_unicode, data);
     CACHE_LOG_ALWAYS(("Observe [topic=%s data=%s]\n", topic, data.get()));
 
     if (!strcmp(NS_XPCOM_SHUTDOWN_OBSERVER_ID, topic)) {
diff --git a/netwerk/dns/src/nsDNSService2.cpp b/netwerk/dns/src/nsDNSService2.cpp
--- a/netwerk/dns/src/nsDNSService2.cpp
+++ b/netwerk/dns/src/nsDNSService2.cpp
@@ -211,7 +211,10 @@ public:
         , mHost(host)
         , mListener(listener)
         , mFlags(flags)
-        , mAF(af) {}
+        , mAF(af)
+    {
+        //printf("Looking up \"%s\".\n", PromiseFlatCString(host).get());
+    }
     ~nsDNSAsyncRequest() {}
 
     void OnLookupComplete(nsHostResolver *, nsHostRecord *, nsresult);
diff --git a/netwerk/dns/src/nsIDNService.cpp b/netwerk/dns/src/nsIDNService.cpp
--- a/netwerk/dns/src/nsIDNService.cpp
+++ b/netwerk/dns/src/nsIDNService.cpp
@@ -118,7 +118,7 @@ void nsIDNService::prefsChanged(nsIPrefB
     nsXPIDLCString prefix;
     nsresult rv = prefBranch->GetCharPref(NS_NET_PREF_IDNPREFIX, getter_Copies(prefix));
     if (NS_SUCCEEDED(rv) && prefix.Length() <= kACEPrefixLen)
-      PL_strncpyz(nsIDNService::mACEPrefix, prefix.get(), kACEPrefixLen + 1);
+      PL_strncpyz(mACEPrefix, prefix.get(), sizeof(mACEPrefix));
   }
   if (!pref || NS_LITERAL_STRING(NS_NET_PREF_IDNBLACKLIST).Equals(pref)) {
     nsCOMPtr<nsISupportsString> blacklist;
@@ -144,6 +144,7 @@ nsIDNService::nsIDNService()
   // initialize to the official prefix (RFC 3490 "5. ACE prefix")
   const char kIDNSPrefix[] = "xn--";
   strcpy(mACEPrefix, kIDNSPrefix);
+  NS_ASSERTION(sizeof(mACEPrefix) >= sizeof(kIDNSPrefix), "bad strcpy");
 
   mMultilingualTestBed = PR_FALSE;
 
@@ -492,9 +493,9 @@ nsresult nsIDNService::stringPrep(const 
     return NS_ERROR_FAILURE;
 
   // normalize
-  nsAutoString normlizedStr;
-  rv = mNormalizer->NormalizeUnicodeNFKC(namePrepStr, normlizedStr);
-  if (normlizedStr.Length() >= kMaxDNSNodeLen)
+  nsAutoString normalizedStr;
+  rv = mNormalizer->NormalizeUnicodeNFKC(namePrepStr, normalizedStr);
+  if (normalizedStr.Length() >= kMaxDNSNodeLen)
     return NS_ERROR_FAILURE;
 
   // prohibit
@@ -511,7 +512,7 @@ nsresult nsIDNService::stringPrep(const 
     return NS_ERROR_FAILURE;
 
   // set the result string
-  out.Assign(normlizedStr);
+  out.Assign(normalizedStr);
 
   return rv;
 }
diff --git a/themes/classic/global/mac/textbox.css b/themes/classic/global/mac/textbox.css
--- a/themes/classic/global/mac/textbox.css
+++ b/themes/classic/global/mac/textbox.css
@@ -71,6 +71,7 @@ html|*.textbox-textarea {
   background-color: inherit;
   color: inherit;
   font: inherit;
+  line-height: normal;
 }
 
 /* ..... focused state ..... */
diff --git a/themes/classic/global/win/textbox.css b/themes/classic/global/win/textbox.css
--- a/themes/classic/global/win/textbox.css
+++ b/themes/classic/global/win/textbox.css
@@ -70,6 +70,7 @@ html|*.textbox-textarea {
   background-color: inherit;
   color: inherit;
   font: inherit;
+  line-height: normal;
 }
 
 /* ..... readonly state ..... */
diff --git a/toolkit/themes/pinstripe/mozapps/shared/richview.css b/toolkit/themes/pinstripe/mozapps/shared/richview.css
--- a/toolkit/themes/pinstripe/mozapps/shared/richview.css
+++ b/toolkit/themes/pinstripe/mozapps/shared/richview.css
@@ -4,6 +4,7 @@ view {
   margin: 10px 10px 5px 10px;
   -moz-appearance: listbox;
   -moz-user-focus: normal;
+  background-color: Window;
 }
 
 .richviewInner2 {
diff --git a/tools/jprof/stub/libmalloc.cpp b/tools/jprof/stub/libmalloc.cpp
--- a/tools/jprof/stub/libmalloc.cpp
+++ b/tools/jprof/stub/libmalloc.cpp
@@ -86,7 +86,68 @@ static int enableRTCSignals(bool enable)
 
 //----------------------------------------------------------------------
 
-#if defined(i386) || defined(_i386) || defined(__x86_64__)
+//#if __GNUC__ >= 3
+#if 0
+
+#include <unwind.h>
+
+struct CrawlStackClosure {
+  malloc_log_entry *me;
+  void *stack_top;
+  void *top_instr_ptr;
+};
+
+extern "C" {
+static _Unwind_Reason_Code CrawlStackCallback(struct _Unwind_Context *cx, void *c);
+}
+
+/* static */ _Unwind_Reason_Code
+CrawlStackCallback(struct _Unwind_Context *cx, void *c)
+{
+  CrawlStackClosure *closure = (CrawlStackClosure*)c;
+  malloc_log_entry *me = closure->me;
+  if (me->numpcs >= MAX_STACK_CRAWL) {
+    printf("too many frames\n");
+    return _URC_END_OF_STACK;
+  }
+
+  void *sp = (void*)_Unwind_GetCFA(cx);
+  if (sp < closure->stack_top) {
+    printf("still in signal handling %p %p\n", sp, closure->stack_top);
+    // Still in the signal handling code.
+#if 0
+    // The unwind code doesn't know how to cross the signal handler, so
+    // we'll try to help it.
+    _Unwind_SetGR(cx, __builtin_dwarf_sp_column(),
+                  (_Unwind_Word) closure->stack_top);
+    _Unwind_SetIP(cx, (_Unwind_Ptr) closure->top_instr_ptr);
+#endif
+    return _URC_NO_REASON;
+  }
+
+  void *ip = (void*)_Unwind_GetIP(cx);
+  me->pcs[me->numpcs++] = (char*) ip;
+  printf("recording frame\n");
+
+  return _URC_NO_REASON;
+}
+
+static void CrawlStack(malloc_log_entry* me,
+                       void* stack_top, void* top_instr_ptr)
+{
+  CrawlStackClosure closure;
+  closure.me = me;
+  closure.stack_top = stack_top;
+  closure.top_instr_ptr = top_instr_ptr;
+  me->numpcs = 0;
+
+  me->pcs[me->numpcs++] = (char*) top_instr_ptr;
+
+  _Unwind_Backtrace(CrawlStackCallback, &closure);
+}
+
+#elif defined(i386) || defined(_i386) || defined(__x86_64__)
+
 static void CrawlStack(malloc_log_entry* me,
                        void* stack_top, void* top_instr_ptr)
 {
diff --git a/widget/src/gtk2/nsLookAndFeel.cpp b/widget/src/gtk2/nsLookAndFeel.cpp
--- a/widget/src/gtk2/nsLookAndFeel.cpp
+++ b/widget/src/gtk2/nsLookAndFeel.cpp
@@ -77,8 +77,7 @@ nsLookAndFeel::nsLookAndFeel() : nsXPLoo
 
 nsLookAndFeel::~nsLookAndFeel()
 {
-    //  gtk_widget_destroy(mWidget);
-    gtk_widget_unref(mWidget);
+    g_object_unref(mStyle);
 }
 
 nsresult nsLookAndFeel::NativeGetColor(const nsColorID aID, nscolor& aColor)
@@ -685,8 +684,7 @@ nsLookAndFeel::LookAndFeelChanged()
 {
     nsXPLookAndFeel::LookAndFeelChanged();
 
-    if (mWidget)
-        gtk_widget_unref(mWidget);
+    g_object_unref(mStyle);
  
     InitWidget();
     InitLookAndFeel();
diff --git a/widget/src/gtk2/nsLookAndFeel.h b/widget/src/gtk2/nsLookAndFeel.h
--- a/widget/src/gtk2/nsLookAndFeel.h
+++ b/widget/src/gtk2/nsLookAndFeel.h
@@ -56,7 +56,6 @@ public:
 
 protected:
     GtkStyle *mStyle;
-    GtkWidget *mWidget;
 
     // Cached colors, we have to create a dummy widget to actually
     // get the style
@@ -75,11 +74,12 @@ protected:
 
     static void InitLookAndFeel();
     void InitWidget() {
-        mWidget = gtk_invisible_new();
-        gtk_object_ref(GTK_OBJECT(mWidget));
-        gtk_object_sink(GTK_OBJECT(mWidget));
-        gtk_widget_ensure_style(mWidget);
-        mStyle = gtk_widget_get_style(mWidget);
+        GtkWidget *widget = gtk_invisible_new();
+        gtk_object_ref(GTK_OBJECT(widget));
+        gtk_object_sink(GTK_OBJECT(widget));
+        gtk_widget_ensure_style(widget);
+        mStyle = gtk_style_copy(gtk_widget_get_style(widget));
+        gtk_widget_unref(widget);
     }
 };
 
diff --git a/widget/src/gtk2/nsWindow.cpp b/widget/src/gtk2/nsWindow.cpp
--- a/widget/src/gtk2/nsWindow.cpp
+++ b/widget/src/gtk2/nsWindow.cpp
@@ -1212,6 +1212,7 @@ nsWindow::Update()
         return NS_OK;
 
     gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
+    // XSync(GDK_DISPLAY(), False);
     return NS_OK;
 }
 
@@ -3464,6 +3465,10 @@ nsWindow::EnsureGrabs(void)
         GrabKeyboard();
 }
 
+// Once people are reliably running compositing window managers, we
+// could get 8-bit alpha by using gdk_screen_get_rgba_visual.
+// See http://mail.gnome.org/archives/gtk-app-devel-list/2005-September/msg00124.html
+
 NS_IMETHODIMP
 nsWindow::SetWindowTranslucency(PRBool aTranslucent)
 {
@@ -5584,6 +5589,7 @@ void
 void
 nsWindow::IMECreateContext(void)
 {
+    NS_ASSERTION(!mIMEData, "already have IME data");
     mIMEData = new nsIMEData(this);
     if (!mIMEData)
         return;
@@ -5601,6 +5607,7 @@ nsWindow::IMECreateContext(void)
     gtk_im_context_set_client_window(mIMEData->mDummyContext,
                                      GTK_WIDGET(mContainer)->window);
 
+    // XXX Should we remove these signals before releasing the context?
     g_signal_connect(G_OBJECT(mIMEData->mContext), "preedit_changed",
                      G_CALLBACK(IM_preedit_changed_cb), this);
     g_signal_connect(G_OBJECT(mIMEData->mContext), "commit",
diff --git a/widget/src/gtk2/nsWindow.h b/widget/src/gtk2/nsWindow.h
--- a/widget/src/gtk2/nsWindow.h
+++ b/widget/src/gtk2/nsWindow.h
@@ -296,6 +296,7 @@ public:
      *  The children refers to its owning window's object.
      */
     struct nsIMEData {
+        // XXX Should this be refcounted?  I've seen it be a dangling pointer.
         // Actual context. This is used for handling the user's input.
         GtkIMContext       *mContext;
         // mDummyContext is a dummy context and will be used in IMESetFocus()
diff --git a/widget/src/xremoteclient/XRemoteClient.cpp b/widget/src/xremoteclient/XRemoteClient.cpp
--- a/widget/src/xremoteclient/XRemoteClient.cpp
+++ b/widget/src/xremoteclient/XRemoteClient.cpp
@@ -724,6 +724,7 @@ XRemoteClient::DoSendCommandLine(Window 
     argvlen += len;
   }
 
+  // XXXldb Would be nice to free |buffer|!
   PRInt32* buffer = (PRInt32*) malloc(argvlen + argc + 1 +
                                       sizeof(PRInt32) * (argc + 1));
   if (!buffer)
diff --git a/xpcom/base/nsIWeakReference.idl b/xpcom/base/nsIWeakReference.idl
--- a/xpcom/base/nsIWeakReference.idl
+++ b/xpcom/base/nsIWeakReference.idl
@@ -49,6 +49,15 @@
  * (hopefully short-lived) owning reference on demand, through which clients
  * can get useful access to the referent, while it still exists.
  *
+ * Thus this interface provides the following contract:  The result of
+ * calling QueryReferent on a given implementation of this interface
+ * with a given IID may change over time, but not more than twice:  it
+ * may change once from null to non-null (to account for aggregation)
+ * and it may change once from non-null to null.  This means that if
+ * a QueryReferent for an IID that once returned non-null (or was
+ * guaranteed by GetWeakReference to return non-null) at some time
+ * returns null, it will never again return non-null.
+ *
  * @status FROZEN
  * @version 1.0
  * @see nsISupportsWeakReference
@@ -86,6 +95,12 @@ interface nsISupportsWeakReference : nsI
      * As with all good XPCOM `getters', you own the resulting interface and should
      * manage it with an |nsCOMPtr|.
      *
+     * If this call is successful, the weak reference returned is (while
+     * the nsISupportsWeakReference object is held) guaranteed to return
+     * non-null for a QueryReferent to any interface that the
+     * nsISupportsWeakReference implementation is known to
+     * QueryInterface to.
+     *
      * @see nsIWeakReference
      * @see nsWeakPtr
      * @see nsCOMPtr
diff --git a/xpcom/components/nsComponentManager.cpp b/xpcom/components/nsComponentManager.cpp
--- a/xpcom/components/nsComponentManager.cpp
+++ b/xpcom/components/nsComponentManager.cpp
@@ -2468,7 +2468,9 @@ nsComponentManagerImpl::RegisterFactory(
         return NS_ERROR_OUT_OF_MEMORY;
 
 
+    // XXX This is guaranteed to be true.
     if (PL_DHASH_ENTRY_IS_BUSY(factoryTableEntry)) {
+        // XXX I don't think entry is guaranteed to be null.
         entry = factoryTableEntry->mFactoryEntry;
     }
 
@@ -3381,6 +3383,9 @@ nsComponentManagerImpl::RegisterFactory(
                                         const char *aContractID,
                                         nsIFactory *aFactory)
 {
+    // XXX We really don't want to create a new factory entry for each
+    // CID/ContractID pair, since the same CID could be repeated and that's
+    // OK.  And it's really bad when they're services.
     return RegisterFactory(aClass,
                            aClassName,
                            aContractID,
diff --git a/xpcom/io/nsEscape.cpp b/xpcom/io/nsEscape.cpp
--- a/xpcom/io/nsEscape.cpp
+++ b/xpcom/io/nsEscape.cpp
@@ -434,6 +434,7 @@ NS_COM PRBool NS_EscapeURL(const char *p
 
       if (tempBufferPos >= sizeof(tempBuffer) - 4)
       {
+        // XXXldb Why is this guaranteed not to fire?
         NS_ASSERTION(writing, "should be writing");
         tempBuffer[tempBufferPos] = '\0';
         result += tempBuffer;
diff --git a/xpcom/io/nsLocalFileWin.cpp b/xpcom/io/nsLocalFileWin.cpp
--- a/xpcom/io/nsLocalFileWin.cpp
+++ b/xpcom/io/nsLocalFileWin.cpp
@@ -2276,7 +2276,7 @@ nsLocalFile::IsExecutable(PRBool *_retva
 
     // kill trailing dots and spaces.
     PRInt32 filePathLen = path.Length() - 1;
-    while(filePathLen > 0 && (path[filePathLen] == L' ' || path[filePathLen] == L'.'))
+    while(filePathLen >= 0 && (path[filePathLen] == L' ' || path[filePathLen] == L'.'))
     {
         path.Truncate(filePathLen--);
     } 
diff --git a/xpcom/tests/TestCallTemplates.cpp b/xpcom/tests/TestCallTemplates.cpp
--- a/xpcom/tests/TestCallTemplates.cpp
+++ b/xpcom/tests/TestCallTemplates.cpp
@@ -78,8 +78,37 @@ NS_IMPL_ISUPPORTS2(nsTestService, nsITes
     {0xae, 0xd2, 0x1a, 0xb6, 0xdd, 0xba, 0xfe, 0x53}}
 static NS_DEFINE_CID(kTestServiceCID, NS_TEST_SERVICE_CID);
 
+#include "nsString.h"
+
 int main()
 {
+    nsCAutoString str;
+    str.AppendFloat(1.0/3.0);
+    str.Append(" ");
+    str.AppendFloat(2.0/3.0);
+    str.Append(" ");
+    str.AppendFloat(1.0/7.0);
+    str.Append(" ");
+    str.AppendFloat(-0.0);
+    str.Append(" ");
+    str.AppendFloat(-1073741824.0);
+    str.Append(" ");
+    str.AppendFloat(1073741824.0);
+    str.Append(" ");
+    str.AppendFloat(1024.0);
+    str.Append(" ");
+    str.AppendFloat(-1024.0);
+    printf("%s\n", str.get());
+
+#if 0
+    nsAutoString foo;
+    foo.AssignWithConversion("aosneuthasoenuhctsa oceuhsa oceush aoeu");
+    for (int i = 0; i < 10000000; ++i) {
+        NS_ConvertUCS2toUTF8 bar(foo.get());
+    }
+#endif
+
+#if 0
     /*
      * NOTE:  This does NOT demonstrate how these functions are
      * intended to be used.  They are intended for filling in out
@@ -124,6 +153,7 @@ int main()
     nsIInterfaceRequestor *myInterfaceRequestor =
         static_cast<nsIInterfaceRequestor*>(mySupportsPtr);
     CallGetInterface(myInterfaceRequestor, &myITestService);
+#endif
 
     return 0;
 }
diff --git a/xpfe/browser/src/nsBrowserStatusFilter.cpp b/xpfe/browser/src/nsBrowserStatusFilter.cpp
--- a/xpfe/browser/src/nsBrowserStatusFilter.cpp
+++ b/xpfe/browser/src/nsBrowserStatusFilter.cpp
@@ -95,6 +95,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsBrowserStatusFilter::RemoveProgressListener(nsIWebProgressListener *aListener)
 {
+    NS_ASSERTION(aListener == mListener, "listener mismatch");
     if (aListener == mListener)
         mListener = nsnull;
     return NS_OK;
