diff -r 31cfff909cc3 accessible/src/atk/nsDocAccessibleWrap.cpp
--- a/accessible/src/atk/nsDocAccessibleWrap.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/accessible/src/atk/nsDocAccessibleWrap.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -56,7 +56,7 @@
  * Must keep sychronization with enumerate AtkProperty in 
  * accessible/src/base/nsAccessibleEventData.h
  */
-static char * sAtkPropertyNameArray[PROP_LAST] = {
+static const char * sAtkPropertyNameArray[PROP_LAST] = {
     0,
     "accessible_name",
     "accessible_description",
diff -r 31cfff909cc3 browser/base/content/browser.js
--- a/browser/base/content/browser.js	Wed Jan 17 15:49:54 2007 -0800
+++ b/browser/base/content/browser.js	Wed Jan 17 15:50:38 2007 -0800
@@ -1770,6 +1770,7 @@ function addBookmarkForBrowser(aDocShell
   var title, charSet = null;
   var description;
   try {
+    // XXX Even with jst's patch this is insecure.
     title = aDocShell.document.title || url;
     charSet = aDocShell.document.characterSet;
     description = BookmarksUtils.getDescriptionFromDocument(aDocShell.document);
diff -r 31cfff909cc3 browser/components/bookmarks/src/nsBookmarksFeedHandler.cpp
--- a/browser/components/bookmarks/src/nsBookmarksFeedHandler.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/browser/components/bookmarks/src/nsBookmarksFeedHandler.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -376,10 +376,28 @@ nsFeedLoadListener::SetResourceTTL (PRIn
  * the RDF parser to do our work for us.
  */
 
+struct nsTryParseAsRDFNotifier {
+    nsTryParseAsRDFNotifier(nsFeedLoadListener* aListener)
+      : mListener(aListener)
+    {
+        mStartTime = PR_Now();
+        printf("nsFeedLoadListener[%p]::TryParseAsRDF\n", mListener, PR_Now());
+    }
+
+    ~nsTryParseAsRDFNotifier()
+    {
+        printf("nsFeedLoadListener[%p]::TryParseAsRDF:  took %lld us\n", mListener, PR_Now() - mStartTime);
+    }
+
+    nsFeedLoadListener *mListener;
+    PRTime mStartTime;
+};
+
 nsresult
 nsFeedLoadListener::TryParseAsRDF ()
 {
     nsresult rv;
+nsTryParseAsRDFNotifier notifier(this);
 
     nsCOMPtr<nsIRDFXMLParser> rdfparser(do_CreateInstance("@mozilla.org/rdf/xml-parser;1", &rv));
     if (NS_FAILED(rv)) return rv;
@@ -471,6 +489,7 @@ nsFeedLoadListener::TryParseAsRDF ()
     /* Go through each resource and pull out its link/title, if present. */
     PRBool more;
     while (NS_SUCCEEDED(rv = itemsEnumerator->HasMoreElements(&more)) && more) {
+printf("    Handling an RDF item\n");
         nsCOMPtr<nsISupports> iSupports;
         rv = itemsEnumerator->GetNext(getter_AddRefs(iSupports));
         if (NS_FAILED(rv)) break;
@@ -598,6 +617,8 @@ nsFeedLoadListener::HandleRDFItem (nsIRD
     rv = linkLiteral->GetValueConst(&linkStr);
     rv |= titleLiteral->GetValueConst(&titleStr);
     if (NS_FAILED(rv)) return rv;
+
+printf("    RDF item is \"%s\":\"%s\"\n", NS_ConvertUTF16toUTF8(titleStr).get(), NS_ConvertUTF16toUTF8(linkStr).get());
 
     if (!IsLinkValid(linkStr))
         return NS_OK;
diff -r 31cfff909cc3 browser/components/preferences/permissions.xul
--- a/browser/components/preferences/permissions.xul	Wed Jan 17 15:49:54 2007 -0800
+++ b/browser/components/preferences/permissions.xul	Wed Jan 17 15:50:38 2007 -0800
@@ -87,6 +87,7 @@
           onselect="gPermissionManager.onPermissionSelected();">
       <treecols>
         <treecol id="siteCol" label="&treehead.sitename.label;" flex="3"
+                 style="text-align: right"
                 onclick="gPermissionManager.onPermissionSort('rawHost');" persist="width"/>
         <splitter class="tree-splitter"/>
         <treecol id="statusCol" label="&treehead.status.label;" flex="1"
diff -r 31cfff909cc3 browser/components/preferences/permissionsutils.js
--- a/browser/components/preferences/permissionsutils.js	Wed Jan 17 15:49:54 2007 -0800
+++ b/browser/components/preferences/permissionsutils.js	Wed Jan 17 15:50:38 2007 -0800
@@ -87,7 +87,18 @@ var gTreeUtils = {
                   aLastSortColumn, aLastSortAscending) 
   {
     var ascending = (aColumn == aLastSortColumn) ? !aLastSortAscending : true;
-    aDataSet.sort(function (a, b) { return a[aColumn].toLowerCase().localeCompare(b[aColumn].toLowerCase()); });
+    var compareFunc;
+    if (aColumn == "rawHost") {
+      // sort by components of domain name, from last to first
+      compareFunc = function(a, b) {
+        return a[aColumn].toLowerCase().split(".").reverse().join(".").
+          localeCompare(
+            b[aColumn].toLowerCase().split(".").reverse().join("."));
+      };
+    } else {
+      compareFunc = function (a, b) { return a[aColumn].toLowerCase().localeCompare(b[aColumn].toLowerCase()); };
+    }
+    aDataSet.sort(compareFunc);
     if (!ascending)
       aDataSet.reverse();
     
diff -r 31cfff909cc3 caps/src/nsScriptSecurityManager.cpp
--- a/caps/src/nsScriptSecurityManager.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/caps/src/nsScriptSecurityManager.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -3002,7 +3002,9 @@ nsScriptSecurityManager::Observe(nsISupp
                                  const PRUnichar* aMessage)
 {
     nsresult rv = NS_OK;
-    NS_ConvertUTF16toUTF8 messageStr(aMessage);
+    nsCAutoString messageStr;
+    if (aMessage)
+        AppendUTF16toUTF8(aMessage, messageStr);
     const char *message = messageStr.get();
 
     static const char jsPrefix[] = "javascript.";
diff -r 31cfff909cc3 config/Makefile.in
--- a/config/Makefile.in	Wed Jan 17 15:49:54 2007 -0800
+++ b/config/Makefile.in	Wed Jan 17 15:50:38 2007 -0800
@@ -48,11 +48,9 @@ include $(DEPTH)/config/autoconf.mk
 # headers, so that we can use it to set up the wrapped system headers.
 VISIBILITY_FLAGS =
 
-ifneq (,$(CROSS_COMPILE)$(filter-out WINNT OS2,$(OS_ARCH)))
-ifneq ($(OS_ARCH), WINCE)
+ifneq (,$(CROSS_COMPILE)$(filter-out WINCE WINNT OS2,$(OS_ARCH)))
 HOST_PROGRAM	= nsinstall$(HOST_BIN_SUFFIX)
 HOST_CSRCS	= nsinstall.c pathsub.c
-endif
 endif
 
 PLSRCS		= nfspwd.pl revdepth.pl
diff -r 31cfff909cc3 content/base/src/nsAttrAndChildArray.cpp
--- a/content/base/src/nsAttrAndChildArray.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/content/base/src/nsAttrAndChildArray.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -716,6 +716,9 @@ nsAttrAndChildArray::MakeMappedUnique(ns
   if (!aAttributes->GetStyleSheet()) {
     // This doesn't currently happen, but it could if we do loading right
 
+    // XXXldb We shouldn't try to handle this gracefully, since it
+    // should never happen.  But it seems to.
+    //NS_NOTREACHED("no style sheet");
     nsRefPtr<nsMappedAttributes> mapped(aAttributes);
     mapped.swap(mImpl->mMappedAttrs);
 
diff -r 31cfff909cc3 content/base/src/nsDocument.cpp
--- a/content/base/src/nsDocument.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/content/base/src/nsDocument.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -5226,6 +5226,7 @@ nsDocument::CanSavePresentation(nsIReque
 nsDocument::CanSavePresentation(nsIRequest *aNewRequest)
 {
   // Check our event listener manager for unload/beforeunload listeners.
+  // XXX What about listeners on the document rather than the window?
   nsCOMPtr<nsIDOMEventReceiver> er = do_QueryInterface(mScriptGlobalObject);
   if (er) {
     nsCOMPtr<nsIEventListenerManager> manager;
diff -r 31cfff909cc3 content/base/src/nsFrameLoader.cpp
--- a/content/base/src/nsFrameLoader.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/content/base/src/nsFrameLoader.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -384,6 +384,9 @@ nsFrameLoader::EnsureDocShell()
 
       PRBool is_primary = value.LowerCaseEqualsLiteral("content-primary");
 
+        // Old comment, is it still valid?
+        // XXXldb This is inconsistent with the conditions under which
+        // nsFrame
       if (owner2) {
         PRBool is_targetable = is_primary ||
           value.LowerCaseEqualsLiteral("content-targetable");
diff -r 31cfff909cc3 content/html/content/src/nsHTMLSelectElement.cpp
--- a/content/html/content/src/nsHTMLSelectElement.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/content/html/content/src/nsHTMLSelectElement.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -2167,8 +2167,10 @@ void
 void
 nsHTMLSelectElement::VerifyOptionsArray()
 {
+#ifndef DEBUG_dbaron // This is really really slow on long selects!
   PRInt32 aIndex = 0;
   VerifyOptionsRecurse(this, aIndex, mOptions);
+#endif
 }
 
 
diff -r 31cfff909cc3 content/xbl/src/nsBindingManager.cpp
--- a/content/xbl/src/nsBindingManager.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/content/xbl/src/nsBindingManager.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -1168,6 +1168,8 @@ nsBindingManager::WalkRules(nsStyleSet* 
              // (see GetBindingParent in nsXULElement.cpp).  Actually, all
              // native anonymous content is thus hacked.  Cut off inheritance
              // here.
+             // XXXldb Could we use nsIContent::IsNativeAnonymous instead of
+             // this hack?
 
     content = parent;
   } while (content);
diff -r 31cfff909cc3 content/xul/document/src/nsXULPrototypeCache.h
--- a/content/xul/document/src/nsXULPrototypeCache.h	Wed Jan 17 15:49:54 2007 -0800
+++ b/content/xul/document/src/nsXULPrototypeCache.h	Wed Jan 17 15:50:38 2007 -0800
@@ -59,7 +59,7 @@ struct CacheScriptEntry
 };
 
 class nsXULPrototypeCache : public nsIXULPrototypeCache,
-                                   nsIObserver
+                            public nsIObserver
 {
 public:
     // nsISupports
diff -r 31cfff909cc3 content/xul/document/src/nsXULPrototypeDocument.cpp
--- a/content/xul/document/src/nsXULPrototypeDocument.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/content/xul/document/src/nsXULPrototypeDocument.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -215,7 +215,8 @@ NS_NewXULPrototypeDocument(nsXULPrototyp
 
 // Helper method that shares a system global among all prototype documents
 // that have the system principal as their security principal.   Called by
-// nsXULPrototypeDocument::Read and nsXULPDGlobalObject::GetGlobalObject.
+// nsXULPrototypeDocument::Read and
+// nsXULPrototypeDocument::GetScriptGlobalObject.
 // This method greatly reduces the number of nsXULPDGlobalObjects and their
 // nsIScriptContexts in apps that load many XUL documents via chrome: URLs.
 
diff -r 31cfff909cc3 db/mork/build/nsMorkFactory.cpp
--- a/db/mork/build/nsMorkFactory.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/db/mork/build/nsMorkFactory.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -69,30 +69,10 @@ NS_IMPL_NSGETMODULE(nsMorkModule, compon
 NS_IMPL_NSGETMODULE(nsMorkModule, components)
 
 
-
-
+// XXXldb This should really be a strong reference!
 static nsIMdbFactory *gMDBFactory = nsnull;
 
-NS_IMPL_ADDREF(nsMorkFactoryFactory)
-NS_IMPL_RELEASE(nsMorkFactoryFactory)
-
-NS_IMETHODIMP
-nsMorkFactoryFactory::QueryInterface(REFNSIID iid, void** result)
-{
-  if (! result)
-    return NS_ERROR_NULL_POINTER;
-  
-  *result = nsnull;
-  if(iid.Equals(NS_GET_IID(nsIMdbFactoryFactory)) ||
-    iid.Equals(NS_GET_IID(nsISupports))) {
-    *result = NS_STATIC_CAST(nsIMdbFactoryFactory*, this);
-    AddRef();
-    return NS_OK;
-  }
-  return NS_NOINTERFACE;
-}
-
-
+NS_IMPL_ISUPPORTS1(nsMorkFactoryFactory, nsIMdbFactoryFactory)
 
 nsMorkFactoryFactory::nsMorkFactoryFactory()
 {
diff -r 31cfff909cc3 db/mork/src/morkFactory.cpp
--- a/db/mork/src/morkFactory.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/db/mork/src/morkFactory.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -106,6 +106,7 @@ morkFactory::morkFactory() // uses orkin
 morkFactory::morkFactory() // uses orkinHeap
 : morkObject(morkUsage::kGlobal, (nsIMdbHeap*) 0, morkColor_kNone)
 , mFactory_Env(morkUsage::kMember, (nsIMdbHeap*) 0, this,
+  // XXXldb Nothing ever frees this new orkinHeap
   new orkinHeap())
 , mFactory_Heap()
 {
@@ -147,6 +148,7 @@ NS_IMPL_ISUPPORTS_INHERITED1(morkFactory
 
 extern "C" nsIMdbFactory* MakeMdbFactory() 
 {
+  // XXXldb Nothing ever frees this new orkinHeap
   return new morkFactory(new orkinHeap());
 }
 
@@ -270,6 +272,7 @@ morkFactory::MakeEnv(nsIMdbHeap* ioHeap,
   nsIMdbEnv* outEnv = 0;
   mork_bool ownsHeap = (ioHeap == 0);
   if ( !ioHeap )
+    // XXXldb Nothing ever frees this new orkinHeap
     ioHeap = new orkinHeap();
 
   if ( acqEnv && ioHeap )
@@ -310,6 +313,7 @@ morkFactory::MakeHeap(nsIMdbEnv* mev, ns
   morkEnv* ev = morkEnv::FromMdbEnv(mev);
   if ( ev )
   {
+    // XXXldb Nothing ever frees this new orkinHeap
     outHeap = new orkinHeap();
     if ( !outHeap )
       ev->OutOfMemoryError();
diff -r 31cfff909cc3 docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/docshell/base/nsDocShell.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -676,6 +676,14 @@ nsDocShell::LoadURI(nsIURI * aURI,
     PRUint32 loadType = MAKE_LOAD_TYPE(LOAD_NORMAL, aLoadFlags);    
 
     NS_ENSURE_ARG(aURI);
+
+#ifdef DEBUG
+    {
+        nsCAutoString spec;
+        aURI->GetSpec(spec);
+        printf("nsDocShell(%p)::LoadURI(%s)\n", this, spec.get());
+    }
+#endif
 
     // Extract the info from the DocShellLoadInfo struct...
     if (aLoadInfo) {
@@ -3536,6 +3544,11 @@ nsDocShell::SetPositionAndSize(PRInt32 x
 nsDocShell::SetPositionAndSize(PRInt32 x, PRInt32 y, PRInt32 cx,
                                PRInt32 cy, PRBool fRepaint)
 {
+#if 0
+printf("\n\nnsDocShell[%p]::SetPositionAndSize(x=%d, y=%d, width=%d, height=%d)\n\n\n",
+       this, x, y, cx, cy);
+#endif
+
     mBounds.x = x;
     mBounds.y = y;
     mBounds.width = cx;
@@ -4934,13 +4947,21 @@ nsDocShell::CreateAboutBlankContentViewe
   return rv;
 }
 
+#ifdef DEBUG_dbaron
+#define CSP_DEBUG_PRINTF(string_) printf("nsDocShell::CanSavePresentation: " string_ "\n")
+#else
+#define CSP_DEBUG_PRINTF(string_) PR_BEGIN_MACRO PR_END_MACRO
+#endif
+
 PRBool
 nsDocShell::CanSavePresentation(PRUint32 aLoadType,
                                 nsIRequest *aNewRequest,
                                 nsIDocument *aNewDocument)
 {
-    if (!mOSHE)
+    if (!mOSHE) {
+        CSP_DEBUG_PRINTF(" returning false, since no OSHE");
         return PR_FALSE; // no entry to save into
+    }
 
     // Only save presentation for "normal" loads and link loads.  Anything else
     // probably wants to refetch the page, so caching the old presentation
@@ -4951,27 +4972,36 @@ nsDocShell::CanSavePresentation(PRUint32
         aLoadType != LOAD_STOP_CONTENT &&
         aLoadType != LOAD_STOP_CONTENT_AND_REPLACE &&
         aLoadType != LOAD_ERROR_PAGE)
+    {
+        CSP_DEBUG_PRINTF(" returning false, due to load type");
         return PR_FALSE;
+    }
 
     // If the session history entry has the saveLayoutState flag set to false,
     // then we should not cache the presentation.
     PRBool canSaveState;
     mOSHE->GetSaveLayoutStateFlag(&canSaveState);
-    if (canSaveState == PR_FALSE)
+    if (canSaveState == PR_FALSE) {
+        CSP_DEBUG_PRINTF(" returning false, due to session history entry flag");
         return PR_FALSE;
+    }
 
     // If the document is not done loading, don't cache it.
     nsCOMPtr<nsPIDOMWindow> pWin = do_QueryInterface(mScriptGlobal);
-    if (!pWin || pWin->IsLoading())
+    if (!pWin || pWin->IsLoading()) {
+        CSP_DEBUG_PRINTF(" returning false, due to window still loading");
         return PR_FALSE;
+    }
 
     if (pWin->WouldReuseInnerWindow(aNewDocument))
         return PR_FALSE;
 
     // Avoid doing the work of saving the presentation state in the case where
     // the content viewer cache is disabled.
-    if (nsSHistory::GetMaxTotalViewers() == 0)
+    if (nsSHistory::GetMaxTotalViewers() == 0) {
+        CSP_DEBUG_PRINTF(" returning false, GetMaxTotalViewers 0");
         return PR_FALSE;
+    }
 
     // Don't cache the content viewer if we're in a subframe and the subframe
     // pref is disabled.
@@ -4988,9 +5018,12 @@ nsDocShell::CanSavePresentation(PRUint32
 
     // If the document does not want its presentation cached, then don't.
     nsCOMPtr<nsIDocument> doc = do_QueryInterface(pWin->GetExtantDocument());
-    if (!doc || !doc->CanSavePresentation(aNewRequest))
+    if (!doc || !doc->CanSavePresentation(aNewRequest)) {
+        CSP_DEBUG_PRINTF(" returning false, since document says so");
         return PR_FALSE;
-
+    }
+
+    CSP_DEBUG_PRINTF(" returning TRUE");
     return PR_TRUE;
 }
 
diff -r 31cfff909cc3 docshell/base/nsWebShell.cpp
--- a/docshell/base/nsWebShell.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/docshell/base/nsWebShell.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -549,9 +549,7 @@ nsWebShell::nsWebShell() : nsDocShell()
 #ifdef DEBUG
   // We're counting the number of |nsWebShells| to help find leaks
   ++gNumberOfWebShells;
-#endif
-#ifdef DEBUG
-    printf("++WEBSHELL %p == %ld\n", (void*) this, gNumberOfWebShells);
+  printf("++WEBSHELL %p == %ld\n", (void*) this, gNumberOfWebShells);
 #endif
 
   InitFrameData();
@@ -574,8 +572,6 @@ nsWebShell::~nsWebShell()
 #ifdef DEBUG
   // We're counting the number of |nsWebShells| to help find leaks
   --gNumberOfWebShells;
-#endif
-#ifdef DEBUG
   printf("--WEBSHELL %p == %ld\n", (void*) this, gNumberOfWebShells);
 #endif
 }
diff -r 31cfff909cc3 dom/src/base/nsGlobalWindow.cpp
--- a/dom/src/base/nsGlobalWindow.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/dom/src/base/nsGlobalWindow.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -1493,6 +1493,7 @@ nsGlobalWindow::SetNewDocument(nsIDocume
 
         // Don't clear scope on our current inner window if it's going to be
         // held in the bfcache.
+        // XXXldb Move this out of currentInner->mJSObject check!
         if (!currentInner->IsFrozen()) {
           // Skip the ClearScope if we set a termination function to do
           // it ourselves, later.
diff -r 31cfff909cc3 dom/src/base/nsJSEnvironment.cpp
--- a/dom/src/base/nsJSEnvironment.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/dom/src/base/nsJSEnvironment.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -2848,6 +2848,83 @@ static JSFunctionSpec TraceMallocFunctio
 
 #endif /* NS_TRACE_MALLOC */
 
+#ifdef LINUX
+
+#include <malloc.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+
+static void
+dump_mallinfo(FILE *ofp)
+{
+    struct mallinfo mi = mallinfo();
+    fprintf(ofp,
+            "%8d non-mmapped space allocated from system (bytes)\n"
+            "%8d free chunks (count)\n"
+            "%8d fastbin blocks (count)\n"
+            "%8d mmapped regions (count)\n"
+            "%8d space in mmapped regions (bytes)\n"
+            "%8d maximum total allocated space (bytes)\n"
+            "%8d space available in freed fastbin blocks (bytes)\n"
+            "%8d total allocated space (bytes)\n"
+            "%8d total free space (bytes)\n"
+            "%8d top-most, releasable (via malloc_trim) space (bytes)\n",
+            mi.arena, mi.ordblks, mi.smblks, mi.hblks, mi.hblkhd,
+            mi.usmblks, mi.fsmblks, mi.uordblks, mi.fordblks, mi.keepcost);
+}
+
+static void
+dump_pid_proc_file(FILE *ofp, const char* procfile)
+{
+    char filename[40];
+    snprintf(filename, sizeof(filename),
+             "/proc/%d/%s", getpid(), procfile);
+    FILE *in = fopen(filename, "r");
+    if (!in)
+        return;
+
+    char buf[8192];
+    while (!feof(in)) {
+        size_t s = fread(buf, 1, sizeof(buf), in);
+        fwrite(buf, 1, s, ofp);
+    }
+
+    fclose(in);
+}
+
+static JSBool
+DumpHeapInfo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSString *str = JS_ValueToString(cx, argv[0]);
+    if (!str)
+        return JS_FALSE;
+    const char *pathname = JS_GetStringBytes(str);
+    FILE *ofp = fopen(pathname, "w");
+    if (!ofp) {
+        JS_ReportError(cx, "can't dump to %s: %s", pathname, strerror(errno));
+        return JS_FALSE;
+    }
+
+    dump_mallinfo(ofp);
+    fprintf(ofp, "-----\n");
+    dump_pid_proc_file(ofp, "maps");
+    fprintf(ofp, "-----\n");
+    dump_pid_proc_file(ofp, "status");
+    fprintf(ofp, "-----\n");
+
+    fclose(ofp);
+
+    return JS_TRUE;
+}
+
+static JSFunctionSpec DumpHeapFunctions[] = {
+    {"DumpHeapInfo",               DumpHeapInfo,               1, 0, 0},
+    {nsnull,                       nsnull,                     0, 0, 0}
+};
+#endif
+
 #ifdef MOZ_JPROF
 
 #include <signal.h>
@@ -2952,6 +3029,10 @@ nsJSContext::InitClasses(void *aGlobalOb
 #ifdef NS_TRACE_MALLOC
   // Attempt to initialize TraceMalloc functions
   ::JS_DefineFunctions(mContext, globalObj, TraceMallocFunctions);
+#endif
+
+#ifdef LINUX
+  ::JS_DefineFunctions(mContext, globalObj, DumpHeapFunctions);
 #endif
 
 #ifdef MOZ_JPROF
diff -r 31cfff909cc3 editor/composer/src/nsEditingSession.cpp
--- a/editor/composer/src/nsEditingSession.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/editor/composer/src/nsEditingSession.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -752,7 +752,7 @@ nsEditingSession::OnStateChange(nsIWebPr
         }
 
         mCanCreateEditor = PR_TRUE;
-        StartDocumentLoad(aWebProgress, progressIsForTargetDocument);
+        StartDocumentLoad(progressIsForTargetDocument);
       }
     }
   }
@@ -955,24 +955,12 @@ nsEditingSession::GetEditorStatus(PRUint
   Called on start of load in a single frame
 ----------------------------------------------------------------------------*/
 nsresult
-nsEditingSession::StartDocumentLoad(nsIWebProgress *aWebProgress, 
-                                    PRBool aIsToBeMadeEditable)
+nsEditingSession::StartDocumentLoad(PRBool aIsToBeMadeEditable)
 {
 #ifdef NOISY_DOC_LOADING
   printf("======= StartDocumentLoad ========\n");
 #endif
 
-  NS_ENSURE_ARG_POINTER(aWebProgress);
-  
-  // If we have an editor here, then we got a reload after making the editor.
-  // We need to blow it away and make a new one at the end of the load.
-  nsCOMPtr<nsIDOMWindow> domWindow;
-  aWebProgress->GetDOMWindow(getter_AddRefs(domWindow));
-  if (domWindow)
-  {
-    TearDownEditorOnWindow(domWindow);
-  }
-    
   if (aIsToBeMadeEditable)
     mEditorStatus = eEditorCreationInProgress;
 
diff -r 31cfff909cc3 editor/composer/src/nsEditingSession.h
--- a/editor/composer/src/nsEditingSession.h	Wed Jan 17 15:49:54 2007 -0800
+++ b/editor/composer/src/nsEditingSession.h	Wed Jan 17 15:50:38 2007 -0800
@@ -108,8 +108,7 @@ protected:
   nsCOMPtr<nsITimer>  mLoadBlankDocTimer;
   
   // progress load stuff
-  nsresult        StartDocumentLoad(nsIWebProgress *aWebProgress,
-                                    PRBool isToBeMadeEditable);
+  nsresult        StartDocumentLoad(PRBool isToBeMadeEditable);
   nsresult        EndDocumentLoad(nsIWebProgress *aWebProgress, 
                                   nsIChannel* aChannel, nsresult aStatus,
                                   PRBool isToBeMadeEditable);
diff -r 31cfff909cc3 embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp
--- a/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -3734,6 +3734,7 @@ nsWebBrowserPersist::MakeAndStoreLocalFi
     return NS_OK;
 }
 
+// XXX Should be a typedef rather than a struct
 struct SpecialXHTMLTags {
     PRUnichar name[sizeof(PRUnichar)*11]; // strlen("blockquote")==10
 };
diff -r 31cfff909cc3 extensions/layout-debug/src/nsDebugFactory.cpp
--- a/extensions/layout-debug/src/nsDebugFactory.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/extensions/layout-debug/src/nsDebugFactory.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -52,7 +52,7 @@ NS_GENERIC_FACTORY_CONSTRUCTOR(nsLayoutD
 
 #ifdef MOZ_XUL_APP
 
-static NS_IMETHODIMP
+static NS_METHOD
 RegisterCommandLineHandlers(nsIComponentManager* compMgr, nsIFile* path,
                             const char *location, const char *type,
                             const nsModuleComponentInfo *info)
@@ -70,7 +70,7 @@ RegisterCommandLineHandlers(nsIComponent
   return NS_OK;
 }
 
-static NS_IMETHODIMP
+static NS_METHOD
 UnregisterCommandLineHandlers(nsIComponentManager* compMgr, nsIFile *path,
                               const char *location,
                               const nsModuleComponentInfo *info)
diff -r 31cfff909cc3 extensions/layout-debug/src/nsLayoutDebuggingTools.cpp
--- a/extensions/layout-debug/src/nsLayoutDebuggingTools.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/extensions/layout-debug/src/nsLayoutDebuggingTools.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -148,14 +148,15 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::Init(nsIDOMWindow *aWin)
 {
+    mPrefs = do_GetService(NS_PREF_CONTRACTID);
+
     {
         nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aWin);
         if (!window)
             return NS_ERROR_UNEXPECTED;
         mDocShell = window->GetDocShell();
     }
-
-    mPrefs = do_GetService(NS_PREF_CONTRACTID);
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_UNEXPECTED);
 
     GetBoolPref("nglayout.debug.paint_flashing", &mPaintFlashing);
     GetBoolPref("nglayout.debug.paint_dumping", &mPaintDumping);
@@ -179,6 +180,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::NewURILoaded()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
     // Reset all the state that should be reset between pages.
 
     // XXX Some of these should instead be transferred between pages!
@@ -324,6 +326,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::SetReflowCounts(PRBool aShow)
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
     nsCOMPtr<nsIPresShell> shell(pres_shell(mDocShell)); 
     if (shell) {
 #ifdef MOZ_REFLOW_PERF
@@ -373,6 +376,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::DumpWebShells()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
     nsCOMPtr<nsIDocShellTreeItem> shellAsItem(do_QueryInterface(mDocShell));
     DumpAWebShell(shellAsItem, stdout, 0);
     return NS_OK;
@@ -414,6 +418,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::DumpContent()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
     DumpContentRecur(mDocShell, stdout);
     return NS_OK;
 }
@@ -421,33 +426,31 @@ static void
 static void
 DumpFramesRecur(nsIDocShell* aDocShell, FILE* out)
 {
-    if (nsnull != aDocShell) {
-        fprintf(out, "webshell=%p \n", NS_STATIC_CAST(void*, aDocShell));
-        nsCOMPtr<nsIPresShell> shell(pres_shell(aDocShell));
-        if (shell) {
-            nsIFrame* root = shell->GetRootFrame();
-            if (root) {
-                nsIFrameDebug* fdbg;
-                if (NS_SUCCEEDED(CallQueryInterface(root, &fdbg))) {
-                    fdbg->List(out, 0);
-                }
+    fprintf(out, "webshell=%p \n", NS_STATIC_CAST(void*, aDocShell));
+    nsCOMPtr<nsIPresShell> shell(pres_shell(aDocShell));
+    if (shell) {
+        nsIFrame* root = shell->GetRootFrame();
+        if (root) {
+            nsIFrameDebug* fdbg;
+            if (NS_SUCCEEDED(CallQueryInterface(root, &fdbg))) {
+                fdbg->List(out, 0);
             }
         }
-        else {
-            fputs("null pres shell\n", out);
-        }
-
-        // dump the frames of the sub documents
-        PRInt32 i, n;
-        nsCOMPtr<nsIDocShellTreeNode> docShellAsNode(do_QueryInterface(aDocShell));
-        docShellAsNode->GetChildCount(&n);
-        for (i = 0; i < n; ++i) {
-            nsCOMPtr<nsIDocShellTreeItem> child;
-            docShellAsNode->GetChildAt(i, getter_AddRefs(child));
-            nsCOMPtr<nsIDocShell> childAsShell(do_QueryInterface(child));
-            if (childAsShell) {
-                DumpFramesRecur(childAsShell, out);
-            }
+    }
+    else {
+        fputs("null pres shell\n", out);
+    }
+
+    // dump the frames of the sub documents
+    PRInt32 i, n;
+    nsCOMPtr<nsIDocShellTreeNode> docShellAsNode(do_QueryInterface(aDocShell));
+    docShellAsNode->GetChildCount(&n);
+    for (i = 0; i < n; ++i) {
+        nsCOMPtr<nsIDocShellTreeItem> child;
+        docShellAsNode->GetChildAt(i, getter_AddRefs(child));
+        nsCOMPtr<nsIDocShell> childAsShell(do_QueryInterface(child));
+        if (childAsShell) {
+            DumpFramesRecur(childAsShell, out);
         }
     }
 }
@@ -455,6 +458,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::DumpFrames()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
     DumpFramesRecur(mDocShell, stdout);
     return NS_OK;
 }
@@ -464,31 +468,29 @@ DumpViewsRecur(nsIDocShell* aDocShell, F
 DumpViewsRecur(nsIDocShell* aDocShell, FILE* out)
 {
 #ifdef DEBUG
-    if (aDocShell) {
-        fprintf(out, "docshell=%p \n", NS_STATIC_CAST(void*, aDocShell));
-        nsCOMPtr<nsIViewManager> vm(view_manager(aDocShell));
-        if (vm) {
-            nsIView* root;
-            vm->GetRootView(root);
-            if (nsnull != root) {
-                root->List(out);
-            }
-        }
-        else {
-            fputs("null view manager\n", out);
-        }
-
-        // dump the views of the sub documents
-        PRInt32 i, n;
-        nsCOMPtr<nsIDocShellTreeNode> docShellAsNode(do_QueryInterface(aDocShell));
-        docShellAsNode->GetChildCount(&n);
-        for (i = 0; i < n; i++) {
-            nsCOMPtr<nsIDocShellTreeItem> child;
-            docShellAsNode->GetChildAt(i, getter_AddRefs(child));
-            nsCOMPtr<nsIDocShell> childAsShell(do_QueryInterface(child));
-            if (childAsShell) {
-                DumpViewsRecur(childAsShell, out);
-            }
+    fprintf(out, "docshell=%p \n", NS_STATIC_CAST(void*, aDocShell));
+    nsCOMPtr<nsIViewManager> vm(view_manager(aDocShell));
+    if (vm) {
+        nsIView* root;
+        vm->GetRootView(root);
+        if (nsnull != root) {
+            root->List(out);
+        }
+    }
+    else {
+        fputs("null view manager\n", out);
+    }
+
+    // dump the views of the sub documents
+    PRInt32 i, n;
+    nsCOMPtr<nsIDocShellTreeNode> docShellAsNode(do_QueryInterface(aDocShell));
+    docShellAsNode->GetChildCount(&n);
+    for (i = 0; i < n; i++) {
+        nsCOMPtr<nsIDocShellTreeItem> child;
+        docShellAsNode->GetChildAt(i, getter_AddRefs(child));
+        nsCOMPtr<nsIDocShell> childAsShell(do_QueryInterface(child));
+        if (childAsShell) {
+            DumpViewsRecur(childAsShell, out);
         }
     }
 #endif // DEBUG
@@ -497,6 +499,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::DumpViews()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
     DumpViewsRecur(mDocShell, stdout);
     return NS_OK;
 }
@@ -504,6 +507,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::DumpStyleSheets()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
 #ifdef DEBUG
     FILE *out = stdout;
     nsCOMPtr<nsIPresShell> shell(pres_shell(mDocShell)); 
@@ -518,6 +522,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::DumpStyleContexts()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
 #ifdef DEBUG
     FILE *out = stdout;
     nsCOMPtr<nsIPresShell> shell(pres_shell(mDocShell)); 
@@ -538,6 +543,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsLayoutDebuggingTools::DumpReflowStats()
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
 #ifdef DEBUG
     nsCOMPtr<nsIPresShell> shell(pres_shell(mDocShell)); 
     if (shell) {
@@ -569,6 +575,7 @@ nsLayoutDebuggingTools::SetBoolPrefAndRe
 nsLayoutDebuggingTools::SetBoolPrefAndRefresh(const char * aPrefName,
                                               PRBool aNewVal)
 {
+    NS_ENSURE_TRUE(mDocShell, NS_ERROR_NOT_INITIALIZED);
     NS_ENSURE_TRUE(mPrefs && aPrefName, NS_OK);
 
     mPrefs->SetBoolPref(aPrefName, aNewVal);
diff -r 31cfff909cc3 extensions/layout-debug/src/nsRegressionTester.cpp
--- a/extensions/layout-debug/src/nsRegressionTester.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/extensions/layout-debug/src/nsRegressionTester.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -142,6 +142,29 @@ nsRegressionTester::DumpFrameModel(nsIDO
   return NS_OK;
 }
 
+#if 0
+NS_IMETHODIMP
+nsRegressionTester::DumpPrintFrameModel(nsIDOMWindow *aWindowToDump, nsILocalFile *aDestFile)
+{
+  nsCOMPtr<nsIDocShell> docShell;
+  rv = GetDocShellFromWindow(aWindowToDump, getter_AddRefs(docShell));
+
+  nsCOMPtr<nsIContentViewer> cv;
+  docShell->GetContentViewer(getter_AddRefs(cv));
+  nsCOMPtr<nsIContentViewerFile> cvf = do_QueryInterface(cv);
+
+  FILE* fp = stdout;
+  if (aDestFile)
+  {
+    rv = aDestFile->OpenANSIFileDesc("w", &fp);
+    if (NS_FAILED(rv)) return rv;
+  }
+
+  cvf->Print(PR_TRUE, fp, nsnull);
+  return NS_OK;
+}
+#endif
+
 NS_IMETHODIMP
 nsRegressionTester::CompareFrameModels(nsILocalFile *aBaseFile, nsILocalFile *aVerFile, PRUint32 aFlags, PRInt32 *aResult) 
 {
diff -r 31cfff909cc3 extensions/pref/system-pref/src/gconf/nsSystemPrefService.cpp
--- a/extensions/pref/system-pref/src/gconf/nsSystemPrefService.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/extensions/pref/system-pref/src/gconf/nsSystemPrefService.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -592,6 +592,8 @@ gconfDeleteObserver(void *aElement, void
     return PR_TRUE;
 }
 
+MOZ_DECL_CTOR_COUNTER(GConfProxy)
+
 GConfProxy::GConfProxy(nsSystemPrefService *aSysPrefService):
     mGConfClient(nsnull),
     mGConfLib(nsnull),
@@ -599,10 +601,13 @@ GConfProxy::GConfProxy(nsSystemPrefServi
     mSysPrefService(aSysPrefService),
     mObservers(nsnull)
 {
+    MOZ_COUNT_CTOR(GConfProxy);
 }
 
 GConfProxy::~GConfProxy()
 {
+    MOZ_COUNT_DTOR(GConfProxy);
+
     if (mGConfClient)
         g_object_unref(G_OBJECT(mGConfClient));
 
diff -r 31cfff909cc3 extensions/webservices/security/src/nsWebScriptsAccess.cpp
--- a/extensions/webservices/security/src/nsWebScriptsAccess.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/extensions/webservices/security/src/nsWebScriptsAccess.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -116,6 +116,7 @@ nsWebScriptsAccess::CanAccess(nsIURI* aT
   if (NS_FAILED(rv) || *aAccessGranted)
     return rv;
   
+  // XXXldb This really shouldn't be a member variable.
   mServiceURI = aTransportURI;
 
   nsXPIDLCString path;
@@ -123,6 +124,8 @@ nsWebScriptsAccess::CanAccess(nsIURI* aT
   path += '/';
 
   AccessInfoEntry* entry = 0;
+  // XXXldb Shouldn't we check same origin before checking for a cached
+  // entry in case we've had a previous non-same-origin access?
   rv = GetAccessInfoEntry(path, &entry);
   if (!entry) {
     rv = mSecurityManager->CheckSameOrigin(0, aTransportURI);
@@ -311,6 +314,7 @@ nsWebScriptsAccess::CreateEntry(nsIDOMDo
 
   if (!aIsDelegated) {
     nsCOMPtr<nsIDOMNodeList> delegateList; 
+    // XXXldb Shouldn't this only look at the children of the root?
     rv = aDocument->GetElementsByTagNameNS(kNamespace2002, kDelegateTag, 
                                            getter_AddRefs(delegateList));
     NS_ENSURE_TRUE(delegateList, rv);
@@ -321,6 +325,7 @@ nsWebScriptsAccess::CreateEntry(nsIDOMDo
   }
 
   nsCOMPtr<nsIDOMNodeList> allowList;
+  // XXXldb Shouldn't this only look at the children of the root?
   rv = aDocument->GetElementsByTagNameNS(kNamespace2002, kAllowTag, 
                                          getter_AddRefs(allowList));
   NS_ENSURE_TRUE(allowList, rv);
@@ -580,6 +585,7 @@ nsWebScriptsAccess::ValidateDocument(nsI
  
       if (!ns.Equals(kNamespace2002))
         continue; // ignore elements with different ns.
+      // XXXldb But they could have children in this ns!
 
       PRBool hasChildNodes = PR_FALSE;
       if (name.Equals(kDelegateTag)) {
diff -r 31cfff909cc3 gfx/src/gtk/nsDeviceContextGTK.h
--- a/gfx/src/gtk/nsDeviceContextGTK.h	Wed Jan 17 15:49:54 2007 -0800
+++ b/gfx/src/gtk/nsDeviceContextGTK.h	Wed Jan 17 15:50:38 2007 -0800
@@ -98,10 +98,6 @@ private:
   PRUint32      mNumCells;
   static nscoord mDpi;
 
-  float         mWidthFloat;
-  float         mHeightFloat;
-  PRInt32       mWidth;
-  PRInt32       mHeight;
   GdkWindow    *mDeviceWindow;
 
   nsCOMPtr<nsIScreenManager> mScreenManager;
diff -r 31cfff909cc3 gfx/src/gtk/nsFontMetricsXft.cpp
--- a/gfx/src/gtk/nsFontMetricsXft.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/gfx/src/gtk/nsFontMetricsXft.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -940,6 +940,8 @@ nsFontXft *
 nsFontXft *
 nsFontMetricsXft::FindFont(PRUint32 aChar)
 {
+    if (aChar == 0xFFFD)
+        return nsnull; // because I don't like the U+FFFD in Nimbus Sans L
 
     // If mPattern is null, set up the base bits of it so we can
     // match.  If we need to match later we don't have to set it up
@@ -992,7 +994,7 @@ nsFontMetricsXft::FindFont(PRUint32 aCha
 
     // Now check the remaining fonts
     for (; i < mLoadedFonts.Count(); ++i) {
-        nsFontXft *font = (nsFontXft *)mLoadedFonts.ElementAt(i);
+        font = (nsFontXft *)mLoadedFonts.ElementAt(i);
         if (font->HasChar(aChar)) {
             if (font->GetXftFont())
                 return font;
@@ -1549,6 +1551,21 @@ nsFontMetricsXft::DrawStringCallback(con
 {
     DrawStringData *data = (DrawStringData *)aData;
 
+#ifdef DEBUG_dbaron_off
+    {
+        nsAutoString text;
+        for (PRUint32 i = 0; i < aLen; ++i)
+            AppendUCS4ToUTF16(aString[i], text);
+        nsCAutoString fontName;
+        if (aFont)
+            fontName = (const char*) FcNameUnparse(aFont->mFontName);
+        else
+            fontName.AssignLiteral("no font found");
+        printf("Drawing string \"%s\" with font \"%s\".\n",
+               NS_ConvertUTF16toUTF8(text).get(), fontName.get());
+    }
+#endif
+
     // If there was no font found for this character, just draw the
     // unknown glyph character
     if (!aFont) {
@@ -2032,7 +2049,9 @@ nsFontXft::DrawStringSpec(FcChar32 *aStr
         */                                                  
 
         FT_UInt glyph = CharToGlyphIndex(*pstr);
-        data->drawBuffer->Draw(x, y, mXftFont, glyph);
+        // Hack to make Ahem work right.
+        if (*pstr != 0x20)
+            data->drawBuffer->Draw(x, y, mXftFont, glyph);
 
         if (data->spacing) {
             data->xOffset += *data->spacing;
@@ -2514,7 +2533,7 @@ GetEncoding(const char *aFontName, char 
             // it's put in fontEncoding.properties file and is parsed here.
           
             nsAutoString ftCharMap; 
-            nsresult rv = gFontEncodingProperties->GetStringProperty(
+            rv = gFontEncodingProperties->GetStringProperty(
                           Substring(name, 0, name.Length() - 4) + 
                           NS_LITERAL_CSTRING(".ftcmap"), ftCharMap);
           
diff -r 31cfff909cc3 gfx/src/gtk/nsImageGTK.cpp
--- a/gfx/src/gtk/nsImageGTK.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/gfx/src/gtk/nsImageGTK.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -680,6 +680,12 @@ nsImageGTK::Draw(nsIRenderingContext &aC
   if (mDecodedX2 < mDecodedX1 || mDecodedY2 < mDecodedY1)
     return NS_OK;
 
+#ifdef DEBUG_dbaron_off
+  if (aSHeight != aDHeight) {
+    NS_NOTREACHED("yikes");
+  }
+#endif
+
 #ifdef TRACE_IMAGE_ALLOCATION
   fprintf(stderr, "nsImageGTK::Draw(%p) s=(%4d %4d %4d %4d) d=(%4d %4d %4d %4d)\n",
          this,
@@ -767,6 +773,7 @@ nsImageGTK::Draw(nsIRenderingContext &aC
   }
 
   if ((srcWidth != dstWidth) || (srcHeight != dstHeight)) {
+    // XXXldb This entire section ignores aSX and aSY!
     GdkPixmap *pixmap = 0;
     GdkGC *gc = 0;
     nsRegionGTK clipRgn;
@@ -1691,7 +1698,7 @@ nsImageGTK::Draw(nsIRenderingContext &aC
 
   return Draw(aContext, aSurface,
               0, 0, mWidth, mHeight,
-              aX, aY, mWidth, mHeight);
+              aX, aY, aWidth, aHeight);
 }
 
 /* inline */
diff -r 31cfff909cc3 gfx/src/gtk/nsRenderingContextGTK.cpp
--- a/gfx/src/gtk/nsRenderingContextGTK.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/gfx/src/gtk/nsRenderingContextGTK.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -53,6 +53,7 @@
 #include "nsIFontMetricsGTK.h"
 #include "nsDeviceContextGTK.h"
 #include "nsFontMetricsUtils.h"
+#include "nsAutoBuffer.h"
 
 #ifdef MOZ_WIDGET_GTK2
 #include <gdk/gdkwindow.h>
@@ -537,25 +538,28 @@ void nsRenderingContextGTK::SetClipRectI
          nsClipCombine_to_string(aCombine));
 #endif // TRACE_SET_CLIP
 
+  nsRect rect(aRect);
+  ConditionRect(rect.x, rect.y, rect.width, rect.height);
+
   switch(aCombine)
   {
     case nsClipCombine_kIntersect:
-      mClipRegion->Intersect(aRect.x,aRect.y,aRect.width,aRect.height);
+      mClipRegion->Intersect(rect.x, rect.y, rect.width, rect.height);
       break;
     case nsClipCombine_kUnion:
-      mClipRegion->Union(aRect.x,aRect.y,aRect.width,aRect.height);
+      mClipRegion->Union(rect.x, rect.y, rect.width, rect.height);
       break;
     case nsClipCombine_kSubtract:
-      mClipRegion->Subtract(aRect.x,aRect.y,aRect.width,aRect.height);
+      mClipRegion->Subtract(rect.x, rect.y, rect.width, rect.height);
       break;
     case nsClipCombine_kReplace:
-      mClipRegion->SetTo(aRect.x,aRect.y,aRect.width,aRect.height);
+      mClipRegion->SetTo(rect.x, rect.y, rect.width, rect.height);
       break;
   }
 #if 0
   nscolor color = mCurrentColor;
   SetColor(NS_RGB(255,   0,   0));
-  FillRect(aRect);
+  FillRect(rect);
   SetColor(color);
 #endif
 }
@@ -843,6 +847,176 @@ NS_IMETHODIMP nsRenderingContextGTK::Des
   return NS_OK;
 }
 
+PRBool
+nsRenderingContextGTK::TransformAndConditionPolygon(const nsPoint aPoints[],
+                                                    PRInt32 aNumPoints,
+                                                    nsAutoBuffer<GdkPoint,8> &aResult,
+                                                    PRInt32 *aResultCount)
+{
+  // Use *two* temporary buffers of nsPoint objects (so we can copy from
+  // one to the other).  Each one contains a clipped state of the input
+  // polygon, which can never have more than double the number of points
+  // as the original, since XXX WRITE ME.
+
+  // malloc only when we have more than 8 input points (unusual)
+  nsAutoBuffer<nsPoint, 32> buffer;
+
+  if (!buffer.EnsureElemCapacity(aNumPoints * 4))
+    return PR_FALSE;
+
+  // Divide buffer in half, into our two temporary buffers.
+  nsPoint *pts1 = buffer.get();
+  nsPoint *pts2 = pts1 + (aNumPoints * 2);
+
+  // Use the transformation matrix to transform aPoints into pts1.
+  PRInt32 i;
+  for (i = 0; i < aNumPoints; ++i) {
+    nsPoint &p = pts1[i];
+    p = aPoints[i];
+    mTranMatrix->TransformCoord(&p.x, &p.y);
+  }
+
+  PRInt32 numPts = aNumPoints;
+  nsPoint *curOut;
+  nsPoint prevIn;
+
+  // Trim the left edge of pts1, putting the result in pts2.
+  curOut = pts2;
+  prevIn = pts1[numPts - 1];
+  for (i = 0; i < numPts; ++i) {
+    nsPoint &p = pts1[i];
+    if (p.x <= 32766) {
+      // current point in range
+      if (prevIn.x > 32766) {
+        // previous point out of range
+        double slope = double(prevIn.y - p.y) / double(prevIn.x - p.x);
+        curOut->x = 32766;
+        curOut->y = prevIn.y - nscoord(slope * (prevIn.x - 32766));
+        ++curOut;
+      }
+      curOut->x = p.x;
+      curOut->y = p.y;
+      ++curOut;
+    } else {
+      // current point out of range
+      if (prevIn.x <= 32766) {
+        // previous point in range
+        double slope = double(p.y - prevIn.y) / double(p.x - prevIn.x);
+        curOut->x = 32766;
+        curOut->y = p.y - nscoord(slope * (p.x - 32766));
+        ++curOut;
+      }
+    }
+    prevIn = p;
+  }
+  numPts = curOut - pts2;
+
+  // Trim the bottom edge of pts2, putting the result in pts1.
+  curOut = pts1;
+  prevIn = pts2[numPts - 1];
+  for (i = 0; i < numPts; ++i) {
+    nsPoint &p = pts2[i];
+    if (p.y <= 32766) {
+      // current point in range
+      if (prevIn.y > 32766) {
+        // previous point out of range
+        double islope = double(prevIn.x - p.x) / double(prevIn.y - p.y);
+        curOut->y = 32766;
+        curOut->x = prevIn.x - nscoord(islope * (prevIn.y - 32766));
+        ++curOut;
+      }
+      curOut->y = p.y;
+      curOut->x = p.x;
+      ++curOut;
+    } else {
+      // current point out of range
+      if (prevIn.y <= 32766) {
+        // previous point in range
+        double islope = double(p.x - prevIn.x) / double(p.y - prevIn.y);
+        curOut->y = 32766;
+        curOut->x = p.x - nscoord(islope * (p.y - 32766));
+        ++curOut;
+      }
+    }
+    prevIn = p;
+  }
+  numPts = curOut - pts1;
+
+  // Trim the right edge of pts1, putting the result in pts2.
+  curOut = pts2;
+  prevIn = pts1[numPts - 1];
+  for (i = 0; i < numPts; ++i) {
+    nsPoint &p = pts1[i];
+    if (p.x >= -32767) {
+      // current point in range
+      if (prevIn.x < -32767) {
+        // previous point out of range
+        double slope = double(prevIn.y - p.y) / double(prevIn.x - p.x);
+        curOut->x = -32767;
+        curOut->y = prevIn.y - nscoord(slope * (prevIn.x - -32767));
+        ++curOut;
+      }
+      curOut->x = p.x;
+      curOut->y = p.y;
+      ++curOut;
+    } else {
+      // current point out of range
+      if (prevIn.x >= -32767) {
+        // previous point in range
+        double slope = double(p.y - prevIn.y) / double(p.x - prevIn.x);
+        curOut->x = -32767;
+        curOut->y = p.y - nscoord(slope * (p.x - -32767));
+        ++curOut;
+      }
+    }
+    prevIn = p;
+  }
+  numPts = curOut - pts2;
+
+  // Trim the top edge of pts2, putting the result in pts1.
+  curOut = pts1;
+  prevIn = pts2[numPts - 1];
+  for (i = 0; i < numPts; ++i) {
+    nsPoint &p = pts2[i];
+    if (p.y >= -32767) {
+      // current point in range
+      if (prevIn.y < -32767) {
+        // previous point out of range
+        double islope = double(prevIn.x - p.x) / double(prevIn.y - p.y);
+        curOut->y = -32767;
+        curOut->x = prevIn.x - nscoord(islope * (prevIn.y - -32767));
+        ++curOut;
+      }
+      curOut->y = p.y;
+      curOut->x = p.x;
+      ++curOut;
+    } else {
+      // current point out of range
+      if (prevIn.y >= -32767) {
+        // previous point in range
+        double islope = double(p.x - prevIn.x) / double(p.y - prevIn.y);
+        curOut->y = -32767;
+        curOut->x = p.x - nscoord(islope * (p.y - -32767));
+        ++curOut;
+      }
+    }
+    prevIn = p;
+  }
+  numPts = curOut - pts1;
+
+  if (!aResult.EnsureElemCapacity(numPts))
+    return PR_FALSE;
+
+  GdkPoint *gdk_pts = aResult.get();
+  for (i = 0; i < numPts; ++i) {
+    gdk_pts[i].x = pts1[i].x;
+    gdk_pts[i].y = pts1[i].y;
+  }
+  *aResultCount = numPts;
+
+  return PR_TRUE;
+}
+
 NS_IMETHODIMP nsRenderingContextGTK::DrawLine(nscoord aX0, nscoord aY0, nscoord aX1, nscoord aY1)
 {
   nscoord diffX,diffY;
@@ -874,27 +1048,17 @@ NS_IMETHODIMP nsRenderingContextGTK::Dra
 
 NS_IMETHODIMP nsRenderingContextGTK::DrawPolyline(const nsPoint aPoints[], PRInt32 aNumPoints)
 {
-  PRInt32 i;
-
   g_return_val_if_fail(mTranMatrix != NULL, NS_ERROR_FAILURE);
   g_return_val_if_fail(mSurface != NULL, NS_ERROR_FAILURE);
 
-  GdkPoint *pts = new GdkPoint[aNumPoints];
-  for (i = 0; i < aNumPoints; i++)
-  {
-    nsPoint p = aPoints[i];
-    mTranMatrix->TransformCoord(&p.x,&p.y);
-    pts[i].x = p.x;
-    pts[i].y = p.y;
-  }
+  nsAutoBuffer<GdkPoint,8> pts;
+  PRInt32 num_pts;
+  if (!TransformAndConditionPolygon(aPoints, aNumPoints, pts, &num_pts))
+    return NS_ERROR_OUT_OF_MEMORY;
 
   UpdateGC();
 
-  ::gdk_draw_lines(mSurface->GetDrawable(),
-                   mGC,
-                   pts, aNumPoints);
-
-  delete[] pts;
+  ::gdk_draw_lines(mSurface->GetDrawable(), mGC, pts.get(), num_pts);
 
   return NS_OK;
 }
@@ -1029,20 +1193,14 @@ NS_IMETHODIMP nsRenderingContextGTK::Dra
   g_return_val_if_fail(mTranMatrix != NULL, NS_ERROR_FAILURE);
   g_return_val_if_fail(mSurface != NULL, NS_ERROR_FAILURE);
 
-  GdkPoint *pts = new GdkPoint[aNumPoints];
-  for (PRInt32 i = 0; i < aNumPoints; i++)
-  {
-    nsPoint p = aPoints[i];
-    mTranMatrix->TransformCoord(&p.x,&p.y);
-    pts[i].x = p.x;
-    pts[i].y = p.y;
-  }
+  nsAutoBuffer<GdkPoint,8> pts;
+  PRInt32 num_pts;
+  if (!TransformAndConditionPolygon(aPoints, aNumPoints, pts, &num_pts))
+    return NS_ERROR_OUT_OF_MEMORY;
 
   UpdateGC();
 
-  ::gdk_draw_polygon(mSurface->GetDrawable(), mGC, FALSE, pts, aNumPoints);
-
-  delete[] pts;
+  ::gdk_draw_polygon(mSurface->GetDrawable(), mGC, FALSE, pts.get(), num_pts);
 
   return NS_OK;
 }
@@ -1052,20 +1210,14 @@ NS_IMETHODIMP nsRenderingContextGTK::Fil
   g_return_val_if_fail(mTranMatrix != NULL, NS_ERROR_FAILURE);
   g_return_val_if_fail(mSurface != NULL, NS_ERROR_FAILURE);
 
-  GdkPoint *pts = new GdkPoint[aNumPoints];
-  for (PRInt32 i = 0; i < aNumPoints; i++)
-  {
-    nsPoint p = aPoints[i];
-    mTranMatrix->TransformCoord(&p.x,&p.y);
-    pts[i].x = p.x;
-    pts[i].y = p.y;
-  }
+  nsAutoBuffer<GdkPoint,8> pts;
+  PRInt32 num_pts;
+  if (!TransformAndConditionPolygon(aPoints, aNumPoints, pts, &num_pts))
+    return NS_ERROR_OUT_OF_MEMORY;
 
   UpdateGC();
 
-  ::gdk_draw_polygon(mSurface->GetDrawable(), mGC, TRUE, pts, aNumPoints);
-
-  delete[] pts;
+  ::gdk_draw_polygon(mSurface->GetDrawable(), mGC, TRUE, pts.get(), num_pts);
 
   return NS_OK;
 }
diff -r 31cfff909cc3 gfx/src/gtk/nsRenderingContextGTK.h
--- a/gfx/src/gtk/nsRenderingContextGTK.h	Wed Jan 17 15:49:54 2007 -0800
+++ b/gfx/src/gtk/nsRenderingContextGTK.h	Wed Jan 17 15:50:38 2007 -0800
@@ -53,6 +53,7 @@
 #include "nsDrawingSurfaceGTK.h"
 #include "nsRegionGTK.h"
 #include "nsIFontMetricsGTK.h"
+#include "nsAutoBuffer.h"
 
 #include <gtk/gtk.h>
 
@@ -292,6 +293,7 @@ private:
   // rectangles after they are transformed to screen coordinates
   void ConditionRect(nscoord &x, nscoord &y, nscoord &w, nscoord &h) {
     if ( y < -32766 ) {
+      h += (y + 32766);
       y = -32766;
     }
 
@@ -300,6 +302,7 @@ private:
     }
 
     if ( x < -32766 ) {
+      w += (x + 32766);
       x = -32766;
     }
 
@@ -307,6 +310,15 @@ private:
       w  = 32766 - x;
     }
   }
+
+  // Transform a polygon and simultaneously ensure that the transformed
+  // polygon won't trigger coordinate overflow problems.
+  // Returns false on allocation failure.
+  PRBool TransformAndConditionPolygon(const nsPoint aPoints[],
+                                      PRInt32 aNumPoints,
+                                      nsAutoBuffer<GdkPoint,8> &aResult,
+                                      PRInt32 *aResultCount);
+
 };
 
 #endif /* nsRenderingContextGTK_h___ */
diff -r 31cfff909cc3 gfx/src/thebes/nsThebesFontMetrics.cpp
--- a/gfx/src/thebes/nsThebesFontMetrics.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/gfx/src/thebes/nsThebesFontMetrics.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -461,6 +461,15 @@ nsThebesFontMetrics::GetBoundingMetrics(
                                         nsBoundingMetrics &aBoundingMetrics,
                                         PRInt32 *aFontID)
 {
+#if 0
+    const nsDependentCSubstring& theString = nsDependentCSubstring(aString, aString+aLength);
+    nsRefPtr<gfxTextRun> textrun = mFontGroup->MakeTextRun(theString);
+
+    textrun->SetRightToLeft(mIsRTL);
+
+    aWidth = ROUND_TO_TWIPS(textrun->MeasureString(aContext->Thebes()));
+#endif
+
     return NS_ERROR_NOT_IMPLEMENTED;
 }
 
diff -r 31cfff909cc3 gfx/thebes/src/gfxPangoFonts.cpp
--- a/gfx/thebes/src/gfxPangoFonts.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/gfx/thebes/src/gfxPangoFonts.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -94,6 +94,10 @@
 
 #include <math.h>
 
+#ifdef DEBUG_dbaron_off
+#define DEBUG_print_glyphs
+#endif
+
 #define FLOAT_PANGO_SCALE ((gfxFloat)PANGO_SCALE)
 #define NSToCoordRound(x) (floor((x) + 0.5))
 
@@ -302,6 +306,9 @@ ThebesStyleToPangoWeight (const gfxFontS
      * weight -- the number of steps to move to adjust
      * the weight in the list of supported font weights,
      * this value can be negative or positive.
+     *
+     * XXX Implementing |offset| correctly really requires enumerating
+     * what weights are available.
      */
     PRInt32 baseWeight = (w + 50) / 100;
     PRInt32 offset = w - baseWeight * 100;
@@ -314,7 +321,8 @@ ThebesStyleToPangoWeight (const gfxFontS
 
     /* Map from weight value to fcWeights index */
     static int fcWeightLookup[10] = {
-        0, 0, 0, 0, 1, 1, 2, 3, 3, 4,
+     /* 0  1  2  3  4  5  6  7  8  9 (hundreds) */
+        0, 0, 0, 0, 1, 1, 2, 2, 3, 3,
     };
 
     PRInt32 fcWeight = fcWeightLookup[baseWeight];
@@ -331,12 +339,12 @@ ThebesStyleToPangoWeight (const gfxFontS
         fcWeight = 4;
 
     /* Map to final PANGO_WEIGHT value */
-    static int fcWeights[5] = {
-        349,
-        499,
-        649,
-        749,
-        999
+    /* Values available are 200, 300, 400, 600, 700, 800, and 900. */
+    static int fcWeights[4] = {
+        200,
+        400,
+        700,
+        900
     };
 
     return (PangoWeight)fcWeights[fcWeight];
@@ -358,7 +366,7 @@ gfxPangoFont::RealizeFont(PRBool force)
 
     pango_font_description_set_family(mPangoFontDesc, NS_ConvertUTF16toUTF8(mName).get());
     gfxFloat size = mAdjustedSize ? mAdjustedSize : mStyle->size;
-    MOZ_pango_font_description_set_absolute_size(mPangoFontDesc, size * PANGO_SCALE);
+    MOZ_pango_font_description_set_absolute_size(mPangoFontDesc, (size + 0.000001) * PANGO_SCALE);
     pango_font_description_set_style(mPangoFontDesc, ThebesStyleToPangoStyle(mStyle));
     pango_font_description_set_weight(mPangoFontDesc, ThebesStyleToPangoWeight(mStyle));
 
@@ -475,10 +483,10 @@ gfxPangoFont::GetMetrics()
     if (!face)
         return mMetrics;        // XXX error
 
-    int size;
-    if (FcPatternGetInteger(fcfont->font_pattern, FC_PIXEL_SIZE, 0, &size) != FcResultMatch)
-        size = 12;
-    mMetrics.emHeight = PR_MAX(1, size);
+    double size;
+    if (FcPatternGetDouble(fcfont->font_pattern, FC_PIXEL_SIZE, 0, &size) != FcResultMatch)
+        size = 12.0;
+    mMetrics.emHeight = PR_MAX(1.0, size);
 
     mMetrics.maxAscent = xftFont->ascent;
     mMetrics.maxDescent = xftFont->descent;
@@ -618,8 +626,16 @@ PangoFont*
 PangoFont*
 gfxPangoFont::GetPangoFont()
 {
+    //PRTime start = PR_Now();
     RealizeFont();
-    return pango_context_load_font(mPangoCtx, mPangoFontDesc);
+    PangoFont *res = pango_context_load_font(mPangoCtx, mPangoFontDesc);
+#if 0
+    FcChar8 *family;
+    FcPatternGetString(PANGO_FC_FONT(res)->font_pattern,
+                       FC_FAMILY, 0, &family);
+printf("gfxPangoFont[%p]::GetPangoFont for \"%s\" took %lld\n", this, family, PR_Now() - start);
+#endif
+    return res;
 }
 
 static const char *sCJKLangGroup[] = {
@@ -693,6 +709,18 @@ gfxXftTextRun::Draw(gfxContext *aContext
     
     size_t len = mIsWide ? mWString.Length() : mCString.Length();
     
+#ifdef DEBUG_print_glyphs
+    nsCString family;
+    pf->GetActualFontFamily(family);
+    printf("Drawing (Xft) using font %s size %f:\n",
+           family.get(), size);
+    for (size_t i = 0; i < len; i++) {
+        FT_UInt glyph = mIsWide ?
+            XftCharIndex(GDK_DISPLAY(), xfont, mWString[i]) :
+            XftCharIndex(GDK_DISPLAY(), xfont, mCString[i]);
+        printf("  glyph 0x%X\n", (int)glyph);
+    }
+#endif
    
     gfxFloat offset = 0;
     cairo_glyph_t autoGlyphs[AUTO_GLYPHBUF_SIZE];
@@ -808,6 +836,11 @@ DrawCairoGlyphs(gfxContext* ctx,
                 const gfxPoint& pt,
                 PangoGlyphString* aGlyphs)
 {
+    // XXXldb It seems that we're rasterizing the font twice, since if
+    // you change the font size in this code, XFT_DEBUG=1023 still shows
+    // the other rasterization (being done from text measurement), but
+    // not this one (which means the second rasterization isn't even
+    // done using Xft, I think).
     PangoFcFont* fcfont = PANGO_FC_FONT(aFont);
     cairo_font_face_t* font = cairo_ft_font_face_create_for_pattern(fcfont->font_pattern);
     cairo_set_font_face(ctx->GetCairo(), font);
@@ -815,6 +848,16 @@ DrawCairoGlyphs(gfxContext* ctx,
     double size;
     if (FcPatternGetDouble(fcfont->font_pattern, FC_PIXEL_SIZE, 0, &size) != FcResultMatch)
         size = 12.0;
+
+#ifdef DEBUG_print_glyphs
+    printf("Drawing using font %s size %f:\n",
+           pango_font_description_to_string(pango_font_describe(aFont)),
+           size);
+    for (gint i = 0; i < aGlyphs->num_glyphs; ++i) {
+        PangoGlyphInfo* info = &aGlyphs->glyphs[i];
+        printf("  glyph 0x%X\n", (int)info->glyph);
+    }
+#endif
 
     cairo_set_font_size(ctx->GetCairo(), size);
 
@@ -831,6 +874,7 @@ DrawCairoGlyphs(gfxContext* ctx,
         // PANGO_GLYPH_UNKNOWN_FLAG (0x10000000) bit set.
         if ((info->glyph & 0x10000000) || info->glyph == 0x0FFFFFFF) {
             // XXX we should to render a slug for the invalid glyph instead of just skipping it
+            // XXXldb Use the code we have in the Xft code to draw the hex digits!  (Did the measuring account for it?)
             num_invalid_glyphs++;
         } else {
             glyphs[i-num_invalid_glyphs].index = info->glyph;
diff -r 31cfff909cc3 gfx/thebes/src/nsUnicodeRange.cpp
--- a/gfx/thebes/src/nsUnicodeRange.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/gfx/thebes/src/nsUnicodeRange.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -36,6 +36,8 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsUnicodeRange.h"
+
+// XXXldb Replace this with something generated from the Unicode database.
 
 // This table depends on unicode range definitions. 
 // Each item's index must correspond unicode range value
diff -r 31cfff909cc3 intl/lwbrk/tools/anzx4501.html
--- a/intl/lwbrk/tools/anzx4501.html	Wed Jan 17 15:49:54 2007 -0800
+++ b/intl/lwbrk/tools/anzx4501.html	Wed Jan 17 15:50:38 2007 -0800
@@ -54,9 +54,9 @@ Analysis of JIS X 4051 to Unicode Genera
 <TD></TD>
 <TD></TD>
 <TD>17</TD>
-<TD></TD>
-<TD></TD>
-<TD BGCOLOR=white>17</TD>
+<TD>1</TD>
+<TD></TD>
+<TD BGCOLOR=white>18</TD>
 <TD></TD>
 <TD></TD>
 <TD></TD>
@@ -81,7 +81,7 @@ Analysis of JIS X 4051 to Unicode Genera
 <TD>13</TD>
 <TD></TD>
 <TD></TD>
-<TD></TD>
+<TD>1</TD>
 <TD></TD>
 <TD></TD>
 <TD></TD>
@@ -92,10 +92,10 @@ Analysis of JIS X 4051 to Unicode Genera
 <TD>27</TD>
 <TD>2</TD>
 <TD></TD>
-<TD>29</TD>
-<TD>3</TD>
-<TD></TD>
-<TD BGCOLOR=white>61</TD>
+<TD>32</TD>
+<TD>4</TD>
+<TD></TD>
+<TD BGCOLOR=white>65</TD>
 <TD></TD>
 <TD></TD>
 <TD></TD>
@@ -116,11 +116,11 @@ Analysis of JIS X 4051 to Unicode Genera
 <TD>14</TD>
 <TD>2</TD>
 <TD></TD>
-<TD>9</TD>
-<TD>2</TD>
-<TD></TD>
-<TD>2</TD>
-<TD>1</TD>
+<TD>12</TD>
+<TD>2</TD>
+<TD></TD>
+<TD>2</TD>
+<TD>2</TD>
 <TD></TD>
 <TD></TD>
 <TD></TD>
@@ -131,31 +131,31 @@ Analysis of JIS X 4051 to Unicode Genera
 <TD></TD>
 <TD></TD>
 <TD></TD>
-<TD>4</TD>
-<TD></TD>
-<TD></TD>
-<TD BGCOLOR=white>4</TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD>1</TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD>3</TD>
+<TD>1</TD>
+<TD></TD>
+<TD></TD>
+<TD BGCOLOR=white>1</TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD>1</TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
 <TD></TD>
 <TD></TD>
 <TD></TD>
@@ -170,31 +170,31 @@ Analysis of JIS X 4051 to Unicode Genera
 <TD></TD>
 <TD></TD>
 <TD></TD>
-<TD></TD>
-<TD>4</TD>
-<TD></TD>
-<TD BGCOLOR=white>4</TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
+<TD>1</TD>
+<TD>4</TD>
+<TD></TD>
+<TD BGCOLOR=white>5</TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD>1</TD>
 <TD></TD>
 <TD>3</TD>
 <TD></TD>
@@ -249,9 +249,9 @@ Analysis of JIS X 4051 to Unicode Genera
 <TD></TD>
 <TD>53</TD>
 <TD>3</TD>
-<TD>316</TD>
-<TD>2</TD>
-<TD BGCOLOR=white>560</TD>
+<TD>314</TD>
+<TD>14</TD>
+<TD BGCOLOR=white>570</TD>
 <TD>32</TD>
 <TD></TD>
 <TD></TD>
@@ -276,11 +276,11 @@ Analysis of JIS X 4051 to Unicode Genera
 <TD></TD>
 <TD></TD>
 <TD></TD>
-<TD>7</TD>
+<TD>5</TD>
 <TD>309</TD>
 <TD></TD>
 <TD></TD>
-<TD>2</TD>
+<TD>14</TD>
 </TR>
 <TR><TH>06_15<TH>
 <TD></TD>
@@ -361,23 +361,23 @@ Analysis of JIS X 4051 to Unicode Genera
 <TD></TD>
 </TR>
 <TR><TH>08_18<TH>
-<TD>9</TD>
-<TD>661</TD>
+<TD>10</TD>
+<TD>659</TD>
 <TD>4</TD>
 <TD>130</TD>
-<TD>51</TD>
-<TD>929</TD>
-<TD>14</TD>
-<TD BGCOLOR=white>1798</TD>
-<TD></TD>
-<TD>9</TD>
-<TD></TD>
-<TD></TD>
-<TD>370</TD>
-<TD>1</TD>
-<TD>5</TD>
-<TD></TD>
-<TD>285</TD>
+<TD>47</TD>
+<TD>933</TD>
+<TD>2</TD>
+<TD BGCOLOR=white>1785</TD>
+<TD></TD>
+<TD>10</TD>
+<TD></TD>
+<TD></TD>
+<TD>368</TD>
+<TD>1</TD>
+<TD>4</TD>
+<TD></TD>
+<TD>286</TD>
 <TD></TD>
 <TD></TD>
 <TD>4</TD>
@@ -385,19 +385,19 @@ Analysis of JIS X 4051 to Unicode Genera
 <TD>3</TD>
 <TD>127</TD>
 <TD>3</TD>
-<TD>6</TD>
+<TD>5</TD>
 <TD>3</TD>
 <TD>2</TD>
 <TD>2</TD>
-<TD>32</TD>
+<TD>29</TD>
 <TD>3</TD>
 <TD>12</TD>
-<TD>8</TD>
-<TD>258</TD>
-<TD>651</TD>
-<TD>1</TD>
-<TD>1</TD>
-<TD>12</TD>
+<TD>10</TD>
+<TD>269</TD>
+<TD>642</TD>
+<TD>1</TD>
+<TD>1</TD>
+<TD></TD>
 </TR>
 <TR><TH>09_nbsp<TH>
 <TD></TD>
@@ -493,80 +493,80 @@ Analysis of JIS X 4051 to Unicode Genera
 <TD BGCOLOR=red>X</TD>
 </TR>
 <TR><TH>00<TH>
+<TD>4</TD>
+<TD>10</TD>
+<TD></TD>
+<TD>4</TD>
 <TD>3</TD>
+<TD>43</TD>
+<TD>10</TD>
+<TD></TD>
+<TD>148</TD>
+<TD></TD>
+<TD></TD>
+</TR>
+<TR><TH>01<TH>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD>128</TD>
+<TD></TD>
+<TD></TD>
+</TR>
+<TR><TH>02<TH>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD>89</TD>
+<TD></TD>
+<TD></TD>
+</TR>
+<TR><TH>03<TH>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD>76</TD>
+<TD></TD>
+<TD></TD>
+</TR>
+<TR><TH>04<TH>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD></TD>
+<TD>226</TD>
+<TD></TD>
+<TD></TD>
+</TR>
+<TR><TH>20<TH>
+<TD>4</TD>
 <TD>9</TD>
-<TD></TD>
-<TD>3</TD>
-<TD>3</TD>
-<TD>45</TD>
-<TD>10</TD>
-<TD></TD>
-<TD>149</TD>
-<TD></TD>
-<TD></TD>
-</TR>
-<TR><TH>01<TH>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD>128</TD>
-<TD></TD>
-<TD></TD>
-</TR>
-<TR><TH>02<TH>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD>89</TD>
-<TD></TD>
-<TD></TD>
-</TR>
-<TR><TH>03<TH>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD>76</TD>
-<TD></TD>
-<TD></TD>
-</TR>
-<TR><TH>04<TH>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD></TD>
-<TD>226</TD>
-<TD></TD>
-<TD></TD>
-</TR>
-<TR><TH>20<TH>
-<TD>4</TD>
-<TD>6</TD>
-<TD>4</TD>
-<TD></TD>
-<TD>4</TD>
-<TD>1</TD>
-<TD></TD>
-<TD></TD>
-<TD>90</TD>
+<TD>1</TD>
+<TD></TD>
+<TD>4</TD>
+<TD>13</TD>
+<TD></TD>
+<TD></TD>
+<TD>78</TD>
 <TD></TD>
 <TD></TD>
 </TR>
diff -r 31cfff909cc3 intl/uconv/native/nsNativeUConvService.cpp
--- a/intl/uconv/native/nsNativeUConvService.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/intl/uconv/native/nsNativeUConvService.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -313,12 +313,12 @@ IConvAdaptor::ConvertInternal(void * aSr
                 if (mReplaceOnError) {
                     if (aDestCharSize == 1) {
                         (*(char*)aDest) = (char)mReplaceChar;
-                        aDest = (char*)aDest + sizeof(char);
+                        aDest = (char*)aDest + 1;
                     }
                     else
                     {
                         (*(PRUnichar*)aDest) = (PRUnichar)mReplaceChar;
-                        aDest = (PRUnichar*)aDest + sizeof(PRUnichar);
+                        aDest = (PRUnichar*)aDest + 1;
                     
                     }
                     inLeft -= aSrcCharSize;
diff -r 31cfff909cc3 intl/uconv/src/nsCharsetConverterManager.cpp
--- a/intl/uconv/src/nsCharsetConverterManager.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/intl/uconv/src/nsCharsetConverterManager.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -67,13 +67,54 @@ static NS_DEFINE_CID(kCharsetAliasCID, N
 static NS_DEFINE_CID(kCharsetAliasCID, NS_CHARSETALIAS_CID);
 
 // Pattern of cached, commonly used, single byte decoder
-#define NS_1BYTE_CODER_PATTERN "ISO-8859"
-#define NS_1BYTE_CODER_PATTERN_LEN 8
+static const char k1ByteCoderPattern[] = "ISO-8859";
+
+inline PRBool IsDecoderStateless(const char *aEncoding)
+{
+  return !strncmp(aEncoding, k1ByteCoderPattern,
+                  sizeof(k1ByteCoderPattern) - 1);
+}
+
+/* static */ void PR_CALLBACK
+nsCharsetConverterManager::ClearEntry(PLDHashTable *table,
+                                      PLDHashEntryHdr *entry)
+{
+  EncoderDecoderEntry *e = NS_STATIC_CAST(EncoderDecoderEntry*, entry);
+  if (e->mCharset) {
+    NS_RELEASE(e->mFactoryOrService);
+    nsCRT::free(e->mCharset);
+  }
+  memset(entry, 0, table->entrySize);
+}
+
+/* static */ PRBool PR_CALLBACK
+nsCharsetConverterManager::MatchEntry(PLDHashTable *table,
+                                      const PLDHashEntryHdr *entry,
+                                      const void* key)
+{
+  const EncoderDecoderEntry *e =
+    NS_STATIC_CAST(const EncoderDecoderEntry*, entry);
+  const char *s = NS_STATIC_CAST(const char*, key);
+
+  return !strcmp(s, e->mCharset);
+}
+
+/* static */ PLDHashTableOps nsCharsetConverterManager::EncoderDecoderOps = {
+  PL_DHashAllocTable,
+  PL_DHashFreeTable,
+  PL_DHashGetKeyStub,
+  PL_DHashStringKey,
+  MatchEntry,
+  PL_DHashMoveEntryStub,
+  ClearEntry,
+  PL_DHashFinalizeStub,
+  NULL
+};
 
 // Class nsCharsetConverterManager [implementation]
 
-NS_IMPL_THREADSAFE_ISUPPORTS1(nsCharsetConverterManager,
-                              nsICharsetConverterManager)
+NS_IMPL_ISUPPORTS1(nsCharsetConverterManager,
+                   nsICharsetConverterManager)
 
 nsCharsetConverterManager::nsCharsetConverterManager() 
   :mDataBundle(NULL), mTitleBundle(NULL)
@@ -81,10 +122,36 @@ nsCharsetConverterManager::nsCharsetConv
 #ifdef MOZ_USE_NATIVE_UCONV
   mNativeUC = do_GetService(NS_NATIVE_UCONV_SERVICE_CONTRACT_ID);
 #endif
+  mEncoderTable.ops = nsnull;
+  mDecoderTable.ops = nsnull;
+}
+
+nsresult nsCharsetConverterManager::Init()
+{
+  if (!PL_DHashTableInit(&mEncoderTable, &EncoderDecoderOps, nsnull,
+                         sizeof(EncoderDecoderEntry), 16)) {
+    mEncoderTable.ops = nsnull;
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+  if (!PL_DHashTableInit(&mDecoderTable, &EncoderDecoderOps, nsnull,
+                         sizeof(EncoderDecoderEntry), 16)) {
+    mDecoderTable.ops = nsnull;
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  // It's OK if this fails -- we just won't resolve aliases.
+  mCSAlias = do_GetService(kCharsetAliasCID);
+
+  return NS_OK;
 }
 
 nsCharsetConverterManager::~nsCharsetConverterManager() 
 {
+  if (mEncoderTable.ops)
+    PL_DHashTableFinish(&mEncoderTable);
+  if (mDecoderTable.ops)
+    PL_DHashTableFinish(&mDecoderTable);
+
   NS_IF_RELEASE(mDataBundle);
   NS_IF_RELEASE(mTitleBundle);
 }
@@ -159,6 +226,15 @@ nsresult nsCharsetConverterManager::GetB
   return NS_OK;
 }
 
+#ifdef DEBUG
+PRBool nsCharsetConverterManager::IsCanonical(const char* aCharset)
+{
+  nsCAutoString charset;
+  nsCharsetConverterManager::GetCharsetAlias(aCharset, charset);
+  return !strcmp(aCharset, charset.get());
+}
+#endif
+
 
 //----------------------------------------------------------------------------//----------------------------------------------------------------------------
 // Interface nsICharsetConverterManager [implementation]
@@ -167,121 +243,129 @@ nsCharsetConverterManager::GetUnicodeEnc
 nsCharsetConverterManager::GetUnicodeEncoder(const char * aDest, 
                                              nsIUnicodeEncoder ** aResult)
 {
-  // resolve the charset first
-  nsCAutoString charset;
-  
-  // fully qualify to possibly avoid vtable call
-  nsCharsetConverterManager::GetCharsetAlias(aDest, charset);
-
-  return nsCharsetConverterManager::GetUnicodeEncoderRaw(charset.get(),
-                                                         aResult);
-}
-
+#ifdef MOZ_USE_NATIVE_UCONV
+  if (mNativeUC) {
+    nsCAutoString charset;
+    // fully qualify to possibly avoid vtable call
+    nsCharsetConverterManager::GetCharsetAlias(aDest, charset);
+
+    nsCOMPtr<nsISupports> supports;
+    mNativeUC->GetNativeConverter("UCS-2", 
+                                  charset.get(),
+                                  getter_AddRefs(supports));
+
+    if (supports && NS_SUCCEEDED(CallQueryInterface(supports, aResult))) {
+      return NS_OK;
+    }
+  }
+#endif  
+
+  *aResult = nsnull;
+
+  EncoderDecoderEntry *entry = GetEncoderEntry(aDest, PL_DHASH_ADD);
+  NS_ENSURE_TRUE(entry, NS_ERROR_OUT_OF_MEMORY);
+  if (!entry->mCharset) {
+    nsCAutoString charset;
+    // fully qualify to possibly avoid vtable call
+    nsCharsetConverterManager::GetCharsetAlias(aDest, charset);
+
+    nsCAutoString
+      contractid(NS_LITERAL_CSTRING(NS_UNICODEENCODER_CONTRACTID_BASE) +
+                 charset);
+
+    nsCOMPtr<nsIComponentManager> cm;
+    NS_GetComponentManager(getter_AddRefs(cm));
+    nsresult rv =
+      cm->GetClassObjectByContractID(contractid.get(), NS_GET_IID(nsIFactory),
+                                     (void**) &entry->mFactory);
+    if (NS_FAILED(rv)) {
+      PL_DHashTableRawRemove(&mEncoderTable, entry);
+      return rv;
+    }
+
+    entry->mCharset = nsCRT::strdup(aDest);
+  }
+
+  // Always create an instance since encoders hold state.
+  return entry->mFactory->CreateInstance(nsnull, NS_GET_IID(nsIUnicodeEncoder),
+                                         (void**)aResult);
+}
 
 NS_IMETHODIMP
 nsCharsetConverterManager::GetUnicodeEncoderRaw(const char * aDest, 
                                                 nsIUnicodeEncoder ** aResult)
 {
-  *aResult= nsnull;
-  nsCOMPtr<nsIUnicodeEncoder> encoder;
-
+  NS_ASSERTION(IsCanonical(aDest), "not canonical form");
+  return nsCharsetConverterManager::GetUnicodeEncoder(aDest, aResult);
+}
+
+NS_IMETHODIMP
+nsCharsetConverterManager::GetUnicodeDecoder(const char * aSrc, 
+                                             nsIUnicodeDecoder ** aResult)
+{
 #ifdef MOZ_USE_NATIVE_UCONV
   if (mNativeUC) {
+    nsCAutoString charset;
+    // fully qualify to possibly avoid vtable call
+    nsCharsetConverterManager::GetCharsetAlias(aSrc, charset);
+
     nsCOMPtr<nsISupports> supports;
-    mNativeUC->GetNativeConverter("UCS-2", 
-                                  aDest,
-                                  getter_AddRefs(supports));
-
-    encoder = do_QueryInterface(supports);
-
-    if (encoder) {
-      NS_ADDREF(*aResult = encoder);
-      return NS_OK;
-    }
-  }
-#endif  
-  nsresult rv = NS_OK;
-
-  nsCAutoString
-    contractid(NS_LITERAL_CSTRING(NS_UNICODEENCODER_CONTRACTID_BASE) +
-               nsDependentCString(aDest));
-
-  // Always create an instance since encoders hold state.
-  encoder = do_CreateInstance(contractid.get(), &rv);
-
-  if (NS_FAILED(rv))
-    rv = NS_ERROR_UCONV_NOCONV;
-  else
-  {
-    *aResult = encoder.get();
-    NS_ADDREF(*aResult);
-  }
-  return rv;
-}
-
-NS_IMETHODIMP
-nsCharsetConverterManager::GetUnicodeDecoder(const char * aSrc, 
-                                             nsIUnicodeDecoder ** aResult)
-{
-  // resolve the charset first
-  nsCAutoString charset;
-  
-  // fully qualify to possibly avoid vtable call
-  nsCharsetConverterManager::GetCharsetAlias(aSrc, charset);
-
-  return nsCharsetConverterManager::GetUnicodeDecoderRaw(charset.get(),
-                                                         aResult);
-}
-
-NS_IMETHODIMP
-nsCharsetConverterManager::GetUnicodeDecoderRaw(const char * aSrc, 
-                                                nsIUnicodeDecoder ** aResult)
-{
-  *aResult= nsnull;
-  nsCOMPtr<nsIUnicodeDecoder> decoder;
-
-#ifdef MOZ_USE_NATIVE_UCONV
-  if (mNativeUC) {
-    nsCOMPtr<nsISupports> supports;
-    mNativeUC->GetNativeConverter(aSrc,
+    mNativeUC->GetNativeConverter(charset.get(),
                                   "UCS-2", 
                                   getter_AddRefs(supports));
     
-    decoder = do_QueryInterface(supports);
-
-    if (decoder) {
-      NS_ADDREF(*aResult = decoder);
+    if (supports && NS_SUCCEEDED(CallQueryInterface(supports, aResult))) {
       return NS_OK;
     }
   }
 #endif
-  nsresult rv = NS_OK;
-
-  NS_NAMED_LITERAL_CSTRING(kUnicodeDecoderContractIDBase,
-                           NS_UNICODEDECODER_CONTRACTID_BASE);
-
-  nsCAutoString contractid(kUnicodeDecoderContractIDBase +
-                           nsDependentCString(aSrc));
-
-  if (!strncmp(aSrc,
-               NS_1BYTE_CODER_PATTERN,
-               NS_1BYTE_CODER_PATTERN_LEN))
-  {
-    // Single byte decoders dont hold state. Optimize by using a service.
-    decoder = do_GetService(contractid.get(), &rv);
-  }
-  else
-  {
-    decoder = do_CreateInstance(contractid.get(), &rv);
-  }
-  if(NS_FAILED(rv))
-    rv = NS_ERROR_UCONV_NOCONV;
-  else
-  {
-    *aResult = decoder.get();
+
+  *aResult = nsnull;
+
+  PRBool stateless = IsDecoderStateless(aSrc);
+  EncoderDecoderEntry *entry = GetDecoderEntry(aSrc, PL_DHASH_ADD);
+  NS_ENSURE_TRUE(entry, NS_ERROR_OUT_OF_MEMORY);
+  if (!entry->mCharset) {
+    nsCAutoString charset;
+    // fully qualify to possibly avoid vtable call
+    nsCharsetConverterManager::GetCharsetAlias(aSrc, charset);
+
+    NS_NAMED_LITERAL_CSTRING(kUnicodeDecoderContractIDBase,
+                             NS_UNICODEDECODER_CONTRACTID_BASE);
+    nsCAutoString contractid(kUnicodeDecoderContractIDBase + charset);
+
+    nsresult rv;
+    if (stateless) {
+      rv = CallGetService(contractid.get(), &entry->mService);
+    } else {
+      nsCOMPtr<nsIComponentManager> cm;
+      NS_GetComponentManager(getter_AddRefs(cm));
+      rv = cm->GetClassObjectByContractID(contractid.get(),
+                                          NS_GET_IID(nsIFactory),
+                                          (void**) &entry->mFactory);
+    }
+    if (NS_FAILED(rv)) {
+      PL_DHashTableRawRemove(&mEncoderTable, entry);
+      return rv;
+    }
+    entry->mCharset = nsCRT::strdup(aSrc);
+  }
+
+  if (stateless) {
+    *aResult = entry->mService;
     NS_ADDREF(*aResult);
-  }
-  return rv;
+    return NS_OK;
+  }
+  return entry->mFactory->CreateInstance(nsnull, NS_GET_IID(nsIUnicodeDecoder),
+                                         (void**)aResult);
+}
+
+NS_IMETHODIMP
+nsCharsetConverterManager::GetUnicodeDecoderRaw(const char * aSrc, 
+                                                nsIUnicodeDecoder ** aResult)
+{
+  NS_ASSERTION(IsCanonical(aSrc), "not canonical form");
+  return nsCharsetConverterManager::GetUnicodeDecoder(aSrc, aResult);
 }
 
 nsresult 
@@ -372,11 +456,9 @@ nsCharsetConverterManager::GetCharsetAli
   // We try to obtain the preferred name for this charset from the charset 
   // aliases. If we don't get it from there, we just use the original string
   nsDependentCString charset(aCharset);
-  nsCOMPtr<nsICharsetAlias> csAlias( do_GetService(kCharsetAliasCID) );
-  NS_ASSERTION(csAlias, "failed to get the CharsetAlias service");
-  if (csAlias) {
+  if (mCSAlias) {
     nsAutoString pref;
-    nsresult rv = csAlias->GetPreferred(charset, aResult);
+    nsresult rv = mCSAlias->GetPreferred(charset, aResult);
     if (NS_SUCCEEDED(rv)) {
       return (!aResult.IsEmpty()) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
     }
diff -r 31cfff909cc3 intl/uconv/src/nsCharsetConverterManager.h
--- a/intl/uconv/src/nsCharsetConverterManager.h	Wed Jan 17 15:49:54 2007 -0800
+++ b/intl/uconv/src/nsCharsetConverterManager.h	Wed Jan 17 15:50:38 2007 -0800
@@ -41,6 +41,7 @@
 #include "nsICharsetConverterManager.h"
 #include "nsIStringBundle.h"
 #include "nsISupportsArray.h"
+#include "pldhash.h"
 
 #ifdef MOZ_USE_NATIVE_UCONV
 #include "nsINativeUConvService.h"
@@ -56,10 +57,54 @@ public:
   nsCharsetConverterManager();
   virtual ~nsCharsetConverterManager();
 
+  nsresult Init();
+
 private:
 
   nsIStringBundle * mDataBundle;
   nsIStringBundle * mTitleBundle;
+
+  PLDHashTable mEncoderTable;
+  PLDHashTable mDecoderTable;
+
+  nsCOMPtr<nsICharsetAlias> mCSAlias;
+
+  struct EncoderDecoderEntry : public PLDHashEntryHdr {
+    char *mCharset; // owns
+    union { // owns a reference
+      // In |mEncoderTable|, we always have a factory.  In
+      // |mDecoderTable|, we have a decoder service if
+      // |IsDecoderStateless(mCharset)|, and otherwise we have a factory.
+
+      nsIFactory *mFactory;
+      nsIUnicodeDecoder *mService;
+      nsISupports *mFactoryOrService;
+    };
+  };
+
+  PR_STATIC_CALLBACK(void)   ClearEntry(PLDHashTable *table,
+                                        PLDHashEntryHdr *entry);
+  PR_STATIC_CALLBACK(PRBool) MatchEntry(PLDHashTable *table,
+                                        const PLDHashEntryHdr *entry,
+                                        const void* key);
+
+  static PLDHashTableOps EncoderDecoderOps;
+
+  inline EncoderDecoderEntry*
+  GetEncoderEntry(const char* aCharset, PLDHashOperator aOperator) {
+    return NS_STATIC_CAST(EncoderDecoderEntry*,
+      PL_DHashTableOperate(&mEncoderTable, aCharset, aOperator));
+  }
+
+  inline EncoderDecoderEntry*
+  GetDecoderEntry(const char* aCharset, PLDHashOperator aOperator) {
+    return NS_STATIC_CAST(EncoderDecoderEntry*,
+      PL_DHashTableOperate(&mDecoderTable, aCharset, aOperator));
+  }
+
+#ifdef DEBUG
+  PRBool IsCanonical(const char* aCharset);
+#endif
 
 #ifdef MOZ_USE_NATIVE_UCONV
   nsCOMPtr<nsINativeUConvService> mNativeUC;
diff -r 31cfff909cc3 intl/uconv/src/nsUConvModule.cpp
--- a/intl/uconv/src/nsUConvModule.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/intl/uconv/src/nsUConvModule.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -700,7 +700,7 @@ nsConverterManagerDataRegister(nsICompon
   return nsCharsetConverterManager::RegisterConverterManagerData();
 }
 
-NS_GENERIC_FACTORY_CONSTRUCTOR(nsCharsetConverterManager)
+NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsCharsetConverterManager, Init)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsTextToSubURI)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsUTF8ConverterService)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsCharsetAlias2)
diff -r 31cfff909cc3 intl/unicharutil/tools/gentransliterate.pl
--- a/intl/unicharutil/tools/gentransliterate.pl	Wed Jan 17 15:49:54 2007 -0800
+++ b/intl/unicharutil/tools/gentransliterate.pl	Wed Jan 17 15:50:38 2007 -0800
@@ -77,6 +77,9 @@
 # THIS FILE IS GENERATED BY mozilla/intl/unicharutil/tools/gentransliterate.pl
 # PLEASE DO NOT MODIFY THIS FILE BY HAND
 #
+END_OF_HEADER
+
+$handcoded = <<END_OF_HANDCODED;
 entity.list.name=transliterate
 entity.169=(c)
 #
diff -r 31cfff909cc3 ipc/ipcd/daemon/src/ipcModuleReg.cpp
--- a/ipc/ipcd/daemon/src/ipcModuleReg.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/ipc/ipcd/daemon/src/ipcModuleReg.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -158,7 +158,7 @@ IPC_InitModuleReg(const char *exePath)
     //
     // register plug-in modules
     //
-    char *p = PL_strrchr(exePath, IPC_PATH_SEP_CHAR);
+    const char *p = PL_strrchr(exePath, IPC_PATH_SEP_CHAR);
     if (p == NULL) {
         LOG(("unexpected exe path\n"));
         return;
@@ -185,7 +185,7 @@ IPC_InitModuleReg(const char *exePath)
             // locate extension, and check if dynamic library
             //
 
-            const char *p = strrchr(ent->name, '.');
+            p = strrchr(ent->name, '.');
             if (p && PL_strcasecmp(p, MOZ_DLL_SUFFIX) == 0)
                 InitModuleFromLib(modulesDir, ent->name);
         }
diff -r 31cfff909cc3 js/src/jsdhash.c
--- a/js/src/jsdhash.c	Wed Jan 17 15:49:54 2007 -0800
+++ b/js/src/jsdhash.c	Wed Jan 17 15:50:38 2007 -0800
@@ -71,14 +71,18 @@
                                             table_->entrySize))
 
 #define ENTRY_STORE_EXTRA                   sizeof(uint32)
-#define INCREMENT_RECURSION_LEVEL(table_)   (++RECURSION_LEVEL(table_))
-#define DECREMENT_RECURSION_LEVEL(table_)   (--RECURSION_LEVEL(table_))
+#define INCREMENT_RECURSION_LEVEL(table_)   JS_BEGIN_MACRO \
+                                              ++RECURSION_LEVEL(table_); \
+                                            JS_END_MACRO
+#define DECREMENT_RECURSION_LEVEL(table_)   JS_BEGIN_MACRO \
+                                              --RECURSION_LEVEL(table_); \
+                                            JS_END_MACRO
 
 #else
 
-#define ENTRY_STORE_EXTRA 0
-#define INCREMENT_RECURSION_LEVEL(table_)   ((void)1)
-#define DECREMENT_RECURSION_LEVEL(table_)   ((void)0)
+#define ENTRY_STORE_EXTRA                   0
+#define INCREMENT_RECURSION_LEVEL(table_)   JS_BEGIN_MACRO JS_END_MACRO
+#define DECREMENT_RECURSION_LEVEL(table_)   JS_BEGIN_MACRO JS_END_MACRO
 
 #endif /* defined(DEBUG) */
 
diff -r 31cfff909cc3 js/src/xpconnect/src/XPCDispInterface.cpp
--- a/js/src/xpconnect/src/XPCDispInterface.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/js/src/xpconnect/src/XPCDispInterface.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -365,6 +365,8 @@ JSBool XPCDispInterface::Member::GetValu
         if(!funobj)
             return JS_FALSE;
 
+        // XXXldb root funobj?
+
         // Store ourselves and our native interface within the JSObject
         if(!JS_SetReservedSlot(ccx, funobj, 0, PRIVATE_TO_JSVAL(this)))
             return JS_FALSE;
diff -r 31cfff909cc3 js/src/xpconnect/src/xpcwrappednativescope.cpp
--- a/js/src/xpconnect/src/xpcwrappednativescope.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/js/src/xpconnect/src/xpcwrappednativescope.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -591,11 +591,7 @@ void DEBUG_CheckForComponentsInScope(XPC
     "callback code."
     "\n";
 
-#ifdef I_FOOLISHLY_WANT_TO_IGNORE_THIS_LIKE_THE_OTHER_CRAP_WE_PRINTF
-    NS_WARNING(msg);
-#else
     NS_ERROR(msg);
-#endif
 }
 #else
 #define DEBUG_CheckForComponentsInScope(ccx, obj, OKIfNotInitialized) ((void)0)
diff -r 31cfff909cc3 layout/base/nsBidi.cpp
--- a/layout/base/nsBidi.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/base/nsBidi.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -1,4 +1,4 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
  *
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
diff -r 31cfff909cc3 layout/base/nsBidi.h
--- a/layout/base/nsBidi.h	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/base/nsBidi.h	Wed Jan 17 15:50:38 2007 -0800
@@ -339,7 +339,7 @@ typedef PRUint8 DirProp;
 #define GET_UTF_32(first, second) (((first)<<10UL)+(second)-SURROGATE_OFFSET)
 
 
-#define UTF_ERROR_VALUE 0xffff
+#define UTF_ERROR_VALUE 0xfffd
 /* definitions with forward iteration --------------------------------------- */
 
 /*
diff -r 31cfff909cc3 layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/base/nsCSSFrameConstructor.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -8016,6 +8016,9 @@ FindNextAnonymousSibling(nsIPresShell* a
 // and col groups, (3) row groups and captions (4) legends and content inside fieldsets
 // are siblings from a content perspective, they are not considered siblings in the 
 // frame tree.
+// XXXldb 307394 [Stir DOM] The way this is used seems completely bogus.
+// We should construct or grovel through pseudo-frames if this is false,
+// not skip content.
 PRBool
 nsCSSFrameConstructor::IsValidSibling(nsIFrame*              aParentFrame,
                                       const nsIFrame&        aSibling,
@@ -8079,6 +8082,8 @@ nsCSSFrameConstructor::FindPreviousSibli
   ChildIterator first, iter;
   nsresult rv = ChildIterator::Init(aContainer, &first, &iter);
   NS_ENSURE_SUCCESS(rv, nsnull);
+  // XXXldb 307394 [Stir DOM on XUL] if |iter| has mNodes, then this is
+  // meaningless.  Should we even use ChildIterator at all?
   iter.seek(aIndexInContainer);
 
   PRUint8 childDisplay = UNSET_DISPLAY;
@@ -8142,6 +8147,8 @@ nsCSSFrameConstructor::FindNextSibling(n
   ChildIterator iter, last;
   nsresult rv = ChildIterator::Init(aContainer, &iter, &last);
   NS_ENSURE_SUCCESS(rv, nsnull);
+  // XXXldb 307394 [Stir DOM on XUL] if |iter| has mNodes, then this is
+  // meaningless.  Should we even use ChildIterator at all?
   iter.seek(aIndexInContainer);
 
   // Catch the case where someone tries to append
@@ -8901,7 +8908,7 @@ nsCSSFrameConstructor::ContentInserted(n
   // the preceding frame.
   nsIContent* container = parentFrame->GetContent();
 
-  // XXX if the insertionPoint was different from the original
+  // XXX 307394 if the insertionPoint was different from the original
   // parentFrame, then aIndexInContainer is most likely completely
   // wrong. What we need to do here is remember the original index,
   // then as we insert, search the child list where we're about to put
@@ -11179,6 +11186,9 @@ nsCSSFrameConstructor::GetFirstLineStyle
 
 // Predicate to see if a given content (block element) has
 // first-letter style applied to it.
+// XXXldb Bug 362901 This isn't necessarily going to work if changes are
+// batched, since removing the style rule at the same time as messing
+// with content that relies on this could break things pretty badly.
 PRBool
 nsCSSFrameConstructor::HaveFirstLetterStyle(nsIContent* aContent,
                                             nsStyleContext* aStyleContext)
@@ -12426,6 +12436,7 @@ nsCSSFrameConstructor::ConstructInline(n
   nsIAtom* blockStyle;
   nsRefPtr<nsStyleContext> blockSC;
   nsIFrame* blockFrame;
+  // XXXldb Remove :-moz-anonymous-positioned-block -- not supported by spec.
   if (aIsPositioned) {
     blockStyle = nsCSSAnonBoxes::mozAnonymousPositionedBlock;
     
diff -r 31cfff909cc3 layout/base/tests/Makefile.in
--- a/layout/base/tests/Makefile.in	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/base/tests/Makefile.in	Wed Jan 17 15:50:38 2007 -0800
@@ -58,7 +58,7 @@ LOCAL_INCLUDES	= \
 		-I$(srcdir)/../src \
 		$(NULL)
 
-EXTRA_DSO_LIBS	= gkbase_s gkgfx
+EXTRA_DSO_LIBS	= gkbase_s gkgfx gkconbase_s gkconshared_s gkconhtmlstyle_s
 
 LIBS		+= \
 		$(LIBS_DIR) \
diff -r 31cfff909cc3 layout/forms/nsComboboxControlFrame.cpp
--- a/layout/forms/nsComboboxControlFrame.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/forms/nsComboboxControlFrame.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -425,7 +425,7 @@ nsComboboxControlFrame::ShowList(nsPresC
 
   // Get parent view
   nsIFrame * listFrame;
-  if (NS_OK == mListControlFrame->QueryInterface(NS_GET_IID(nsIFrame), (void **)&listFrame)) {
+  if (NS_SUCCEEDED(CallQueryInterface(mListControlFrame, &listFrame))) {
     nsIView* view = listFrame->GetView();
     NS_ASSERTION(view, "nsComboboxControlFrame view is null");
     if (view) {
@@ -1230,7 +1230,7 @@ nsComboboxControlFrame::Destroy()
   if (mDroppedDown) {
     // Get parent view
     nsIFrame * listFrame;
-    if (NS_OK == mListControlFrame->QueryInterface(NS_GET_IID(nsIFrame), (void **)&listFrame)) {
+    if (NS_SUCCEEDED(CallQueryInterface(mListControlFrame, &listFrame))) {
       nsIView* view = listFrame->GetView();
       NS_ASSERTION(view, "nsComboboxControlFrame view is null");
       if (view) {
diff -r 31cfff909cc3 layout/forms/nsListControlFrame.h
--- a/layout/forms/nsListControlFrame.h	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/forms/nsListControlFrame.h	Wed Jan 17 15:50:38 2007 -0800
@@ -344,8 +344,8 @@ protected:
 #endif
 
 private:
-  NS_IMETHOD_(nsrefcnt) AddRef() { return NS_OK; }
-  NS_IMETHOD_(nsrefcnt) Release() { return NS_OK; }
+  NS_IMETHOD_(nsrefcnt) AddRef() { /*NS_NOTREACHED("not supported on frames");*/ return NS_OK; }
+  NS_IMETHOD_(nsrefcnt) Release() { /*NS_NOTREACHED("not supported on frames");*/ return NS_OK; }
 
   // for incremental typing navigation
   static nsAString& GetIncrementalString ();
diff -r 31cfff909cc3 layout/generic/nsBRFrame.cpp
--- a/layout/generic/nsBRFrame.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/generic/nsBRFrame.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -140,7 +140,7 @@ BRFrame::Reflow(nsPresContext* aPresCont
 
       // We also do this in strict mode because BR should act like a
       // normal inline frame.  That line-height is used is important
-      // here for cases where the line-height is less that 1.
+      // here for cases where the line-height is less than 1.
       SetFontFromStyle(aReflowState.rendContext, mStyleContext);
       nsCOMPtr<nsIFontMetrics> fm;
       aReflowState.rendContext->GetFontMetrics(*getter_AddRefs(fm));
diff -r 31cfff909cc3 layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/generic/nsBlockFrame.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -885,7 +885,7 @@ nsBlockFrame::Reflow(nsPresContext*     
   NS_ASSERTION(NS_SUCCEEDED(rv), "reflow dirty lines failed");
   if (NS_FAILED(rv)) return rv;
 
-  // If the block is complete, put continuted floats in the closest ancestor 
+  // If the block is complete, put continued floats in the closest ancestor 
   // block that uses the same space manager and leave the block complete; this 
   // allows subsequent lines on the page to be impacted by floats. If the 
   // block is incomplete or there is no ancestor using the same space manager, 
@@ -5350,9 +5350,7 @@ nsBlockFrame::ReflowFloat(nsBlockReflowS
       aReflowStatus = NS_FRAME_COMPLETE;
   }
 
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
+  NS_ENSURE_SUCCESS(rv, rv);
 
   // Capture the margin information for the caller
   const nsMargin& m = brc.GetMargin();
@@ -5984,9 +5982,7 @@ nsBlockFrame::SetInitialChildList(nsIAto
     }
 
     rv = AddFrames(aChildList, nsnull);
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
+    NS_ENSURE_SUCCESS(rv, rv);
 
     // Create list bullet if this is a list-item. Note that this is done
     // here so that RenumberLists will work (it needs the bullets to
diff -r 31cfff909cc3 layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/generic/nsFrame.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -584,7 +584,7 @@ nsFrame::Init(nsIContent*      aContent,
   DidSetStyleContext();
 
   if (IsBoxWrapped())
-    InitBoxMetrics(PR_FALSE);
+    InitBoxMetrics(PR_FALSE); // XXX propagate allocation failure?
 
   return NS_OK;
 }
@@ -5793,6 +5793,7 @@ nsFrame::RefreshSizeCache(nsBoxLayoutSta
       do {
          lines->GetLine(count, &firstFrame, &framesOnLine, lineBounds, &lineFlags);
 
+         // XXX This should sum across forced breaks!
          if (lineBounds.height > metrics->mBlockMinSize.height)
            metrics->mBlockMinSize.height = lineBounds.height;
 
diff -r 31cfff909cc3 layout/generic/nsFrame.h
--- a/layout/generic/nsFrame.h	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/generic/nsFrame.h	Wed Jan 17 15:50:38 2007 -0800
@@ -600,7 +600,7 @@ private:
 
   NS_IMETHODIMP RefreshSizeCache(nsBoxLayoutState& aState);
 
-protected:
+protected: // XXXldb Private!
   NS_IMETHOD_(nsrefcnt) AddRef(void);
   NS_IMETHOD_(nsrefcnt) Release(void);
 };
diff -r 31cfff909cc3 layout/generic/nsFrameFrame.cpp
--- a/layout/generic/nsFrameFrame.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/generic/nsFrameFrame.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -552,6 +552,9 @@ nsSubDocumentFrame::AttributeChanged(PRI
       if (!owner2) {
         // XXXbz this adds stuff even if it's not of type content-*, but not
         // much we can do about that....
+        // Old comment, maybe still valid?
+        // XXXldb The conditions under which this call is made are
+        // different from the conditions under which nsFrameLoader does.
         parentTreeOwner->ContentShellAdded(docShellAsItem, is_primary,
                                            value.get());
       } else {
diff -r 31cfff909cc3 layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/generic/nsLineLayout.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -484,7 +484,8 @@ nsLineLayout::EndSpan(nsIFrame* aFrame, 
       if (NS_UNCONSTRAINEDSIZE != psd->mRightEdge ||  // it's not an unconstrained reflow
           pfd->mNext ||                               // or it's not the last frame in the span
           !pfd->GetFlag(PFD_ISTEXTFRAME) ||           // or it's not a text frame
-          pfd->GetFlag(PFD_ISNONWHITESPACETEXTFRAME)  // or it contains something other than whitespace
+          pfd->GetFlag(PFD_ISNONWHITESPACETEXTFRAME) ||// or it contains something other than whitespace
+          pfd->mFrame->GetStyleText()->WhiteSpaceIsSignificant()      // or it's 'pre' or 'pre-wrap'
          ) {
         if (pfd->mBounds.height > maxHeight) maxHeight = pfd->mBounds.height;
 
@@ -715,12 +716,6 @@ nsLineLayout::ReflowFrame(nsIFrame* aFra
   }
   else {
     availSize.width = psd->mRightEdge - psd->mX;
-    if (psd->mNoWrap) {
-      // Make up a width to use for reflowing into.  XXX what value to
-      // use? for tables, we want to limit it; for other elements
-      // (e.g. text) it can be unlimited...
-      availSize.width = psd->mReflowState->availableWidth;
-    }
   }
   // For now, set the available height to unconstrained always.
   // XXX inline blocks and tables won't be able to break across pages/
@@ -1105,10 +1100,6 @@ nsLineLayout::CanPlaceFrame(PerFrameData
   }
 
   PerSpanData* psd = mCurrentSpan;
-  if (psd->mNoWrap) {
-    // When wrapping is off, everything fits.
-    return PR_TRUE;
-  }
 
   PRBool ltr = NS_STYLE_DIRECTION_LTR == aReflowState.mStyleVisibility->mDirection;
   nscoord endMargin = ltr ? pfd->mMargin.right : pfd->mMargin.left;
@@ -1197,9 +1188,9 @@ nsLineLayout::CanPlaceFrame(PerFrameData
     // set on them and contain a float and are placed where they
     // don't naturally fit.
     return PR_TRUE;
- }
-
-  if (aFrameCanContinueTextRun) {
+  }
+
+  if (aFrameCanContinueTextRun || psd->mNoWrap) {
     // Let it fit, but we reserve the right to roll back
     // to before the text run! Note that we usually won't get here because
     // a text frame will break itself to avoid exceeding the available width.
@@ -1254,7 +1245,8 @@ nsLineLayout::PlaceFrame(PerFrameData* p
   // Advance to next X coordinate
   psd->mX = pfd->mBounds.XMost() + (ltr ? pfd->mMargin.right : pfd->mMargin.left);
 
-  // If the frame is a not aware of white-space and it takes up some
+  // If the frame is not aware of white-space (nor has descendants
+  // within the line that are aware of whitespace) and it takes up some
   // width, disable leading white-space compression for the next frame
   // to be reflowed.
   if ((!GetFlag(LL_UNDERSTANDSNWHITESPACE)) && pfd->mBounds.width) {
@@ -1613,9 +1605,6 @@ nsLineLayout::VerticalAlignFrames(PerSpa
   nsCOMPtr<nsIFontMetrics> fm;
   rc->GetFontMetrics(*getter_AddRefs(fm));
 
-  PRBool preMode = (mStyleText->mWhiteSpace == NS_STYLE_WHITESPACE_PRE) ||
-    (mStyleText->mWhiteSpace == NS_STYLE_WHITESPACE_MOZ_PRE_WRAP);
-
   // See if the span is an empty continuation. It's an empty continuation iff:
   // - it has a prev-in-flow
   // - it has no next in flow
@@ -1628,8 +1617,7 @@ nsLineLayout::VerticalAlignFrames(PerSpa
 #ifdef NOISY_VERTICAL_ALIGN
   printf("[%sSpan]", (psd == mRootSpan)?"Root":"");
   nsFrame::ListTag(stdout, spanFrame);
-  printf(": preMode=%s strictMode=%s w/h=%d,%d emptyContinuation=%s",
-         preMode ? "yes" : "no",
+  printf(": strictMode=%s w/h=%d,%d emptyContinuation=%s",
          InStrictMode() ? "yes" : "no",
          spanFramePFD->mBounds.width, spanFramePFD->mBounds.height,
          emptyContinuation ? "yes" : "no");
@@ -1667,9 +1655,10 @@ nsLineLayout::VerticalAlignFrames(PerSpa
   // document author is intending css2 behavior then we act as if strict
   // mode is set.
   //
-  // This code works correctly for preMode, because a blank line
-  // in PRE mode is encoded as a text node with a LF in it, since
-  // text nodes with only whitespace are considered in preMode.
+  // This code works correctly when preserving whitespace, because a
+  // blank line in PRE mode is encoded as a text node with a LF in it,
+  // since text nodes with only whitespace are considered for those
+  // values of 'white-space'.
   //
   // Much of this logic is shared with the various implementations of
   // nsIFrame::IsEmpty since they need to duplicate the way it makes
@@ -1709,7 +1698,8 @@ nsLineLayout::VerticalAlignFrames(PerSpa
     zeroEffectiveSpanBox = PR_TRUE;
     for (PerFrameData* pfd = psd->mFirstFrame; pfd; pfd = pfd->mNext) {
       if (pfd->GetFlag(PFD_ISTEXTFRAME) &&
-          (pfd->GetFlag(PFD_ISNONWHITESPACETEXTFRAME) || preMode ||
+          (pfd->GetFlag(PFD_ISNONWHITESPACETEXTFRAME) ||
+           pfd->mFrame->GetStyleText()->WhiteSpaceIsSignificant() ||
            pfd->mBounds.width != 0)) {
         zeroEffectiveSpanBox = PR_FALSE;
         break;
@@ -2056,7 +2046,7 @@ nsLineLayout::VerticalAlignFrames(PerSpa
           yTop = pfd->mBounds.y - pfd->mMargin.top;
           yBottom = yTop + logicalHeight;
         }
-        if (!preMode &&
+        if (!frame->GetStyleText()->WhiteSpaceIsSignificant() &&
             GetCompatMode() != eCompatibility_FullStandards &&
             !logicalHeight) {
           // Check if it's a BR frame that is not alone on its line (it
@@ -2130,6 +2120,8 @@ nsLineLayout::VerticalAlignFrames(PerSpa
       }
     }
     if (applyMinLH) {
+      PRBool preMode = mStyleText->WhiteSpaceIsSignificant();
+      // XXXldb Why do we need this test?
       if ((psd->mX != psd->mLeftEdge) || preMode || foundLI) {
 #ifdef NOISY_VERTICAL_ALIGN
         printf("  [span]==> adjusting min/maxY: currentValues: %d,%d", minY, maxY);
@@ -2153,7 +2145,7 @@ nsLineLayout::VerticalAlignFrames(PerSpa
         // XXX issues:
         // [1] BR's on empty lines stop working
         // [2] May not honor css2's notion of handling empty elements
-        // [3] blank lines in a pre-section ("\n") (handled with preMode)
+        // [3] blank lines in a pre-section ("\n")
 
         // XXX Are there other problems with this?
 #ifdef NOISY_VERTICAL_ALIGN
diff -r 31cfff909cc3 layout/generic/nsTextFrame.cpp
--- a/layout/generic/nsTextFrame.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/generic/nsTextFrame.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -929,8 +929,7 @@ nsTextStyle::nsTextStyle(nsPresContext* 
   mNumJustifiableCharacterToMeasure = 0;
   mNumJustifiableCharacterReceivingExtraJot = 0;
   mExtraSpacePerJustifiableCharacter = 0;
-  mPreformatted = (NS_STYLE_WHITESPACE_PRE == mText->mWhiteSpace) ||
-    (NS_STYLE_WHITESPACE_MOZ_PRE_WRAP == mText->mWhiteSpace);
+  mPreformatted = mText->WhiteSpaceIsSignificant();
   
   mJustifying = (NS_STYLE_TEXT_ALIGN_JUSTIFY == mText->mTextAlign) &&
     !mPreformatted;
@@ -5570,8 +5569,10 @@ nsTextFrame::MeasureText(nsPresContext* 
   lineLayout.SetUnderstandsWhiteSpace(PR_TRUE);
   if (0 != aTextData.mX) {
     lineLayout.SetTrailingTextFrame(this, aTextData.mWrapping);
-    lineLayout.SetEndsInWhiteSpace(endsInWhitespace);
-    lineLayout.SetInWord(!endsInWhitespace);
+    // XXX This should be called SetEndsInCollapsableWhiteSpace
+    lineLayout.SetEndsInWhiteSpace(endsInWhitespace &&
+                                   !aTs.mPreformatted);
+    lineLayout.SetInWord(!endsInWhitespace || !aTs.mText->WhiteSpaceCanWrap());
   } else {
     // Don't allow subsequent text frame to break-before. All our text is
     // being skipped (usually whitespace, could be discarded Unicode control
diff -r 31cfff909cc3 layout/html/tests/block/rtest.sh
--- a/layout/html/tests/block/rtest.sh	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/html/tests/block/rtest.sh	Wed Jan 17 15:50:38 2007 -0800
@@ -28,6 +28,7 @@ dirs="  base \
         ../formctls/bugs \
         ../style/bugs \
         ../xbl \
+        net \
         "
 
 # This doesn't appear to work on Linux right now; needs support for a
diff -r 31cfff909cc3 layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/style/nsCSSParser.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -188,8 +188,16 @@ protected:
                             nsMediaList* aMediaList);
 
   PRBool GetToken(nsresult& aErrorCode, PRBool aSkipWS);
-  PRBool GetURLToken(nsresult& aErrorCode, PRBool aSkipWS);
   void UngetToken();
+
+  // get the part in paretheses of the url() function, which is really a
+  // part of a token in the CSS grammar, but we're using a combination
+  // of the parser and the scanner to do it to hnadle the backtracking
+  // required by the error handling of the tokenization (since if we
+  // fail to scan the full token, we should fall back to tokenizing as
+  // FUNCTION ... ')').
+  // Note that this function WILL WRITE TO aURL IN SOME FAILURE CASES.
+  PRBool GetURLInParens(nsresult& aErrorCode, nsString& aURL, PRBool aSkipWS);
 
   PRBool ExpectSymbol(nsresult& aErrorCode, PRUnichar aSymbol, PRBool aSkipWS);
   PRBool ExpectEndProperty(nsresult& aErrorCode, PRBool aSkipWS);
@@ -1115,22 +1123,37 @@ PRBool CSSParserImpl::GetToken(nsresult&
   return PR_FALSE;
 }
 
-PRBool CSSParserImpl::GetURLToken(nsresult& aErrorCode, PRBool aSkipWS)
-{
-  for (;;) {
-    // XXXldb This pushback code doesn't make sense.
-    if (! mHavePushBack) {
-      if (! mScanner.NextURL(aErrorCode, mToken)) {
-        break;
-      }
-    }
-    mHavePushBack = PR_FALSE;
-    if (aSkipWS && (eCSSToken_WhiteSpace == mToken.mType)) {
-      continue;
-    }
-    return PR_TRUE;
-  }
-  return PR_FALSE;
+PRBool CSSParserImpl::GetURLInParens(nsresult& aErrorCode,
+                                     nsString& aURL,
+                                     PRBool aSkipWS)
+{
+  if (!ExpectSymbol(aErrorCode, '(', PR_FALSE))
+    return PR_FALSE;
+
+  NS_ASSERTION(!mHavePushBack,
+               "ExpectSymbol returning success shouldn't leave pushback");
+  do {
+    if (! mScanner.NextURL(aErrorCode, mToken)) {
+      return PR_FALSE;
+    }
+  } while (aSkipWS && (eCSSToken_WhiteSpace == mToken.mType));
+
+  if (eCSSToken_String != mToken.mType && eCSSToken_URL != mToken.mType)
+    return PR_FALSE;
+
+  aURL = mToken.mIdent;
+
+  if (!ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
+    // in the failure case, we have to match parentheses, as if this
+    // weren't treated as a URL token by the tokenization
+
+    // XXX We really need to push aURL back into the buffer before this
+    // SkipUntil!
+    SkipUntil(aErrorCode, ')');
+    return PR_FALSE;
+  }
+
+  return PR_TRUE;
 }
 
 void CSSParserImpl::UngetToken()
@@ -1304,14 +1327,8 @@ PRBool CSSParserImpl::GatherURL(nsresult
   }
   else if (eCSSToken_Function == mToken.mType && 
            mToken.mIdent.LowerCaseEqualsLiteral("url") &&
-           ExpectSymbol(aErrorCode, '(', PR_FALSE) &&
-           GetURLToken(aErrorCode, PR_TRUE) &&
-           (eCSSToken_String == mToken.mType ||
-            eCSSToken_URL == mToken.mType)) {
-    aURL = mToken.mIdent;
-    if (ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
-      return PR_TRUE;
-    }
+           GetURLInParens(aErrorCode, aURL, PR_TRUE)) {
+    return PR_TRUE;
   }
   return PR_FALSE;
 }
@@ -1521,23 +1538,17 @@ PRBool CSSParserImpl::ParseMozDocumentRu
       cur->func = nsCSSDocumentRule::eDomain;
     }
 
-    if (!ExpectSymbol(aErrorCode, '(', PR_FALSE) ||
-        !GetURLToken(aErrorCode, PR_TRUE) ||
-        (eCSSToken_String != mToken.mType &&
-         eCSSToken_URL != mToken.mType)) {
+    nsAutoString url;
+    if (!GetURLInParens(aErrorCode, url, PR_TRUE)) {
       REPORT_UNEXPECTED_TOKEN(PEMozDocRuleNotURI);
       delete urls;
       return PR_FALSE;
     }
-    if (!ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
-      delete urls;
-      return PR_FALSE;
-    }
 
     // We could try to make the URL (as long as it's not domain())
     // canonical and absolute with NS_NewURI and GetSpec, but I'm
     // inclined to think we shouldn't.
-    CopyUTF16toUTF8(mToken.mIdent, cur->url);
+    CopyUTF16toUTF8(url, cur->url);
   } while (ExpectSymbol(aErrorCode, ',', PR_TRUE));
 
   nsRefPtr<nsCSSDocumentRule> rule(new nsCSSDocumentRule());
@@ -1582,18 +1593,10 @@ PRBool CSSParserImpl::ParseNameSpaceRule
   }
   else if ((eCSSToken_Function == mToken.mType) && 
            (mToken.mIdent.LowerCaseEqualsLiteral("url"))) {
-    if (ExpectSymbol(aErrorCode, '(', PR_FALSE)) {
-      if (GetURLToken(aErrorCode, PR_TRUE)) {
-        if ((eCSSToken_String == mToken.mType) || (eCSSToken_URL == mToken.mType)) {
-          url = mToken.mIdent;
-          if (ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
-            if (ExpectSymbol(aErrorCode, ';', PR_TRUE)) {
-              ProcessNameSpace(aErrorCode, prefix, url, aAppendFunc, aData);
-              return PR_TRUE;
-            }
-          }
-        }
-      }
+    if (GetURLInParens(aErrorCode, url, PR_TRUE) &&
+        ExpectSymbol(aErrorCode, ';', PR_TRUE)) {
+      ProcessNameSpace(aErrorCode, prefix, url, aAppendFunc, aData);
+      return PR_TRUE;
     }
   }
   REPORT_UNEXPECTED_TOKEN(PEAtNSUnexpected);
@@ -3997,37 +4000,30 @@ PRBool CSSParserImpl::ParseAttr(nsresult
 
 PRBool CSSParserImpl::ParseURL(nsresult& aErrorCode, nsCSSValue& aValue)
 {
-  if (ExpectSymbol(aErrorCode, '(', PR_FALSE)) {
-    if (! GetURLToken(aErrorCode, PR_TRUE)) {
-      return PR_FALSE;
-    }
-    nsCSSToken* tk = &mToken;
-    if ((eCSSToken_String == tk->mType) || (eCSSToken_URL == tk->mType)) {
-      // Translate url into an absolute url if the url is relative to
-      // the style sheet.
-      nsCOMPtr<nsIURI> uri;
-      NS_NewURI(getter_AddRefs(uri), tk->mIdent, nsnull, mBaseURL);
-      if (ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
-        // Set a null value on failure.  Most failure cases should be
-        // NS_ERROR_MALFORMED_URI.
-        nsStringBuffer* buffer = nsCSSValue::BufferFromString(tk->mIdent);
-        if (NS_UNLIKELY(!buffer)) {
-          aErrorCode = NS_ERROR_OUT_OF_MEMORY;
-          return PR_FALSE;
-        }
-
-        nsCSSValue::URL *url = new nsCSSValue::URL(uri, buffer, mSheetURL);
-        buffer->Release();
-        if (NS_UNLIKELY(!url)) {
-          aErrorCode = NS_ERROR_OUT_OF_MEMORY;
-          return PR_FALSE;
-        }
-        aValue.SetURLValue(url);
-        return PR_TRUE;
-      }
-    }
-  }
-  return PR_FALSE;
+  nsAutoString str;
+  if (! GetURLInParens(aErrorCode, str, PR_TRUE)) {
+    return PR_FALSE;
+  }
+  // Translate str into an absolute url if the url is relative to
+  // the style sheet.
+  nsCOMPtr<nsIURI> uri;
+  NS_NewURI(getter_AddRefs(uri), str, nsnull, mBaseURL);
+  // Set a null value on failure.  Most failure cases should be
+  // NS_ERROR_MALFORMED_URI.
+  nsStringBuffer* buffer = nsCSSValue::BufferFromString(str);
+  if (NS_UNLIKELY(!buffer)) {
+    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    return PR_FALSE;
+  }
+
+  nsCSSValue::URL *url = new nsCSSValue::URL(uri, buffer, mSheetURL);
+  buffer->Release();
+  if (NS_UNLIKELY(!url)) {
+    aErrorCode = NS_ERROR_OUT_OF_MEMORY;
+    return PR_FALSE;
+  }
+  aValue.SetURLValue(url);
+  return PR_TRUE;
 }
 
 PRInt32 CSSParserImpl::ParseChoice(nsresult& aErrorCode, nsCSSValue aValues[],
diff -r 31cfff909cc3 layout/style/nsCSSScanner.cpp
--- a/layout/style/nsCSSScanner.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/style/nsCSSScanner.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -762,23 +762,6 @@ PRBool nsCSSScanner::NextURL(nsresult& a
       (void) EatWhiteSpace(aErrorCode);
       return PR_TRUE;
     }
-    if (ch == '/') {
-      PRInt32 nextChar = Peek(aErrorCode);
-      if (nextChar == '*') {
-        (void) Read(aErrorCode);
-#if 0
-        // If we change our storage data structures such that comments are
-        // stored (for Editor), we should reenable this code, condition it
-        // on being in editor mode, and apply glazou's patch from bug
-        // 60290.
-        aToken.mIdent.SetCapacity(2);
-        aToken.mIdent.Assign(PRUnichar(ch));
-        aToken.mIdent.Append(PRUnichar(nextChar));
-        return ParseCComment(aErrorCode, aToken);
-#endif
-        return SkipCComment(aErrorCode) && Next(aErrorCode, aToken);
-      }
-    }
 
     // Process a url lexical token. A CSS1 url token can contain
     // characters beyond identifier characters (e.g. '/', ':', etc.)
@@ -786,55 +769,55 @@ PRBool nsCSSScanner::NextURL(nsresult& a
     // apply very well. To simplify the parser and relax some of the
     // requirements on the scanner we parse url's here. If we find a
     // malformed URL then we emit a token of type "InvalidURL" so that
-    // the CSS1 parser can ignore the invalid input. We attempt to eat
-    // the right amount of input data when an invalid URL is presented.
+    // the CSS1 parser can ignore the invalid input.  The parser must
+    // treat an InvalidURL token like a Function token, and process
+    // tokens until a matching parenthesis.
 
     aToken.mType = eCSSToken_InvalidURL;
     nsString& ident = aToken.mIdent;
     ident.SetLength(0);
 
-    if (ch == ')') {
-      Pushback(ch);
-      // empty url spec; just get out of here
+    Pushback(ch);
+
+    // start of a non-quoted url (which may be empty)
+    PRBool ok = PR_TRUE;
+    for (;;) {
+      ch = Read(aErrorCode);
+      if (ch < 0) break;
+      if (ch == CSS_ESCAPE) {
+        ParseAndAppendEscape(aErrorCode, ident);
+      } else if ((ch == '"') || (ch == '\'') || (ch == '(')) {
+        // This is an invalid URL spec
+        ok = PR_FALSE;
+        Pushback(ch); // push it back so the parser can match tokens and
+                      // then closing parenthesis
+        break;
+      } else if ((256 > ch) && ((gLexTable[ch] & IS_WHITESPACE) != 0)) {
+        // Whitespace is allowed at the end of the URL
+        (void) EatWhiteSpace(aErrorCode);
+        if (LookAhead(aErrorCode, ')')) {
+          Pushback(')');  // leave the closing symbol
+          // done!
+          break;
+        }
+        // Whitespace is followed by something other than a
+        // ")". This is an invalid url spec.
+        ok = PR_FALSE;
+        break;
+      } else if (ch == ')') {
+        Unread();
+        // All done
+        break;
+      } else {
+        // A regular url character.
+        ident.Append(PRUnichar(ch));
+      }
+    }
+
+    // If the result of the above scanning is ok then change the token
+    // type to a useful one.
+    if (ok) {
       aToken.mType = eCSSToken_URL;
-    } else {
-      // start of a non-quoted url
-      Pushback(ch);
-      PRBool ok = PR_TRUE;
-      for (;;) {
-        ch = Read(aErrorCode);
-        if (ch < 0) break;
-        if (ch == CSS_ESCAPE) {
-          ParseAndAppendEscape(aErrorCode, ident);
-        } else if ((ch == '"') || (ch == '\'') || (ch == '(')) {
-          // This is an invalid URL spec
-          ok = PR_FALSE;
-        } else if ((256 > ch) && ((gLexTable[ch] & IS_WHITESPACE) != 0)) {
-          // Whitespace is allowed at the end of the URL
-          (void) EatWhiteSpace(aErrorCode);
-          if (LookAhead(aErrorCode, ')')) {
-            Pushback(')');  // leave the closing symbol
-            // done!
-            break;
-          }
-          // Whitespace is followed by something other than a
-          // ")". This is an invalid url spec.
-          ok = PR_FALSE;
-        } else if (ch == ')') {
-          Unread();
-          // All done
-          break;
-        } else {
-          // A regular url character.
-          ident.Append(PRUnichar(ch));
-        }
-      }
-
-      // If the result of the above scanning is ok then change the token
-      // type to a useful one.
-      if (ok) {
-        aToken.mType = eCSSToken_URL;
-      }
     }
   }
   return PR_TRUE;
diff -r 31cfff909cc3 layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/style/nsComputedDOMStyle.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -2769,6 +2769,7 @@ nsComputedDOMStyle::GetRelativeOffset(PR
       }
       break;
     default:
+      // XXXldb This fires for 'auto'!
       NS_ERROR("Unexpected left/right/top/bottom unit");
       val->SetTwips(0);
       break;
diff -r 31cfff909cc3 layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/style/nsStyleStruct.h	Wed Jan 17 15:50:38 2007 -0800
@@ -522,7 +522,7 @@ struct nsStyleOutline: public nsStyleStr
   // Note that these are specified values.  You can get the actual values with
   // GetOutlineWidth and GetOutlineOffset.  You cannot get the computed values
   // directly.
-  nsStyleCoord  mOutlineOffset;   // [reset] length
+  nsStyleCoord  mOutlineOffset;   // [reset] length XXX Why nsStyleCoord?
   nsStyleCoord  mOutlineWidth;    // [reset] length, enum (see nsStyleConsts.h)
 
   PRBool GetOutlineOffset(nscoord& aOffset) const
@@ -640,7 +640,7 @@ struct nsStylePosition : public nsStyleS
   static nsChangeHint MaxDifference();
 #endif
   
-  nsStyleSides  mOffset;                // [reset]
+  nsStyleSides  mOffset;                // [reset] XXX WHICH TYPES?
   nsStyleCoord  mWidth;                 // [reset] coord, percent, auto
   nsStyleCoord  mMinWidth;              // [reset] coord, percent
   nsStyleCoord  mMaxWidth;              // [reset] coord, percent, null
@@ -648,7 +648,7 @@ struct nsStylePosition : public nsStyleS
   nsStyleCoord  mMinHeight;             // [reset] coord, percent
   nsStyleCoord  mMaxHeight;             // [reset] coord, percent, null
   PRUint8       mBoxSizing;             // [reset] see nsStyleConsts.h
-  nsStyleCoord  mZIndex;                // [reset] 
+  nsStyleCoord  mZIndex;                // [reset] XXX WHICH TYPES?
 };
 
 struct nsStyleTextReset : public nsStyleStruct {
@@ -672,7 +672,7 @@ struct nsStyleTextReset : public nsStyle
   PRUint8 mTextDecoration;              // [reset] see nsStyleConsts.h
   PRUint8 mUnicodeBidi;                 // [reset] see nsStyleConsts.h
 
-  nsStyleCoord  mVerticalAlign;         // [reset] see nsStyleConsts.h for enums
+  nsStyleCoord  mVerticalAlign;         // [reset] see nsStyleConsts.h for enums XXX WHICH TYPES?
 };
 
 struct nsStyleText : public nsStyleStruct {
@@ -697,10 +697,10 @@ struct nsStyleText : public nsStyleStruc
   PRUint8 mTextTransform;               // [inherited] see nsStyleConsts.h
   PRUint8 mWhiteSpace;                  // [inherited] see nsStyleConsts.h
 
-  nsStyleCoord  mLetterSpacing;         // [inherited] 
-  nsStyleCoord  mLineHeight;            // [inherited] 
-  nsStyleCoord  mTextIndent;            // [inherited] 
-  nsStyleCoord  mWordSpacing;           // [inherited] 
+  nsStyleCoord  mLetterSpacing;         // [inherited] XXX WHICH TYPES?
+  nsStyleCoord  mLineHeight;            // [inherited] XXX WHICH TYPES?
+  nsStyleCoord  mTextIndent;            // [inherited] XXX WHICH TYPES?
+  nsStyleCoord  mWordSpacing;           // [inherited] XXX WHICH TYPES?
   
   PRBool WhiteSpaceIsSignificant() const {
     return mWhiteSpace == NS_STYLE_WHITESPACE_PRE ||
@@ -785,9 +785,37 @@ struct nsStyleDisplay : public nsStyleSt
   PRUint8 mOverflowY;           // [reset] see nsStyleConsts.h
   PRUint8   mClipFlags;         // [reset] see nsStyleConsts.h
   
-  PRBool IsBlockLevel() const {return (NS_STYLE_DISPLAY_BLOCK == mDisplay) ||
-                                      (NS_STYLE_DISPLAY_LIST_ITEM == mDisplay) ||
-                                      (NS_STYLE_DISPLAY_TABLE == mDisplay);}
+  // XXX Deprecated.  Prefer |IsBlockOutside|.
+  PRBool IsBlockLevel() const {
+    return IsBlockOutside();
+  }
+
+  PRBool IsBlockInside() const {
+    return NS_STYLE_DISPLAY_BLOCK == mDisplay ||
+           NS_STYLE_DISPLAY_LIST_ITEM == mDisplay ||
+           NS_STYLE_DISPLAY_INLINE_BLOCK == mDisplay;
+    // Should TABLE_CELL and TABLE_CAPTION go here?  They have
+    // block frames nested inside of them.
+  }
+
+  PRBool IsBlockOutside() const {
+    return NS_STYLE_DISPLAY_BLOCK == mDisplay ||
+           NS_STYLE_DISPLAY_LIST_ITEM == mDisplay ||
+           NS_STYLE_DISPLAY_TABLE == mDisplay;
+  }
+
+  PRBool IsInlineOutside() const {
+    return NS_STYLE_DISPLAY_INLINE == mDisplay ||
+           NS_STYLE_DISPLAY_INLINE_BLOCK == mDisplay ||
+           NS_STYLE_DISPLAY_INLINE_TABLE == mDisplay ||
+           NS_STYLE_DISPLAY_INLINE_BOX == mDisplay ||
+           NS_STYLE_DISPLAY_INLINE_GRID == mDisplay ||
+           NS_STYLE_DISPLAY_INLINE_STACK == mDisplay ||
+           // Are these really inlines? :
+           NS_STYLE_DISPLAY_DECK == mDisplay ||
+           NS_STYLE_DISPLAY_POPUP == mDisplay ||
+           NS_STYLE_DISPLAY_GROUPBOX == mDisplay;
+  }
 
   PRBool IsFloating() const {
     return NS_STYLE_FLOAT_NONE != mFloats;
@@ -858,8 +886,8 @@ struct nsStyleTableBorder: public nsStyl
   static nsChangeHint MaxDifference();
 #endif
   
-  nsStyleCoord  mBorderSpacingX;// [inherited]
-  nsStyleCoord  mBorderSpacingY;// [inherited]
+  nsStyleCoord  mBorderSpacingX;// [inherited] XXX WHICH TYPES?
+  nsStyleCoord  mBorderSpacingY;// [inherited] XXX WHICH TYPES?
   PRUint8       mBorderCollapse;// [inherited]
   PRUint8       mCaptionSide;   // [inherited]
   PRUint8       mEmptyCells;    // [inherited]
@@ -1068,7 +1096,7 @@ struct nsStyleContent: public nsStyleStr
     return NS_ERROR_ILLEGAL_VALUE;
   }
 
-  nsStyleCoord  mMarkerOffset;  // [reset]
+  nsStyleCoord  mMarkerOffset;  // [reset] XXX WHICH TYPES?
 
 protected:
   PRUint32            mContentCount;
@@ -1191,8 +1219,8 @@ struct nsStyleColumn : public nsStyleStr
 #endif
 
   PRUint32     mColumnCount; // [reset] see nsStyleConsts.h
-  nsStyleCoord mColumnWidth; // [reset]
-  nsStyleCoord mColumnGap;   // [reset]
+  nsStyleCoord mColumnWidth; // [reset] XXX WHICH TYPES?
+  nsStyleCoord mColumnGap;   // [reset] XXX WHICH TYPES?
 };
 
 #ifdef MOZ_SVG
@@ -1245,10 +1273,10 @@ struct nsStyleSVG : public nsStyleStruct
   nsCOMPtr<nsIURI> mMarkerEnd;        // [inherited]
   nsCOMPtr<nsIURI> mMarkerMid;        // [inherited]
   nsCOMPtr<nsIURI> mMarkerStart;      // [inherited]
-  nsStyleCoord    *mStrokeDasharray;  // [inherited]
-
-  nsStyleCoord     mStrokeDashoffset; // [inherited]
-  nsStyleCoord     mStrokeWidth;      // [inherited]
+  nsStyleCoord    *mStrokeDasharray;  // [inherited] XXX WHICH TYPES?
+
+  nsStyleCoord     mStrokeDashoffset; // [inherited] XXX WHICH TYPES?
+  nsStyleCoord     mStrokeWidth;      // [inherited] XXX WHICH TYPES?
 
   float            mFillOpacity;      // [inherited]
   float            mStrokeMiterlimit; // [inherited]
diff -r 31cfff909cc3 layout/style/ua.css
--- a/layout/style/ua.css	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/style/ua.css	Wed Jan 17 15:50:38 2007 -0800
@@ -120,6 +120,7 @@
 *|*::-moz-anonymous-block, *|*::-moz-cell-content {
   display: block !important;
   position: static !important;
+  /* XXX shouldn't unicode-bidi inherit? */
 }
 
 *|*::-moz-scrolled-content, *|*::-moz-scrolled-canvas,
diff -r 31cfff909cc3 layout/svg/base/src/nsSVGOuterSVGFrame.cpp
--- a/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -710,6 +710,9 @@ nsSVGOuterSVGFrame::CalculateAvailableSp
                                             nsPresContext* aPresContext,
                                             const nsHTMLReflowState& aReflowState)
 {
+  // XXXldb This really doesn't make sense for svg within HTML+CSS, etc.
+  // http://annevankesteren.nl/test/cdf/cdi/001.xml
+  // http://annevankesteren.nl/test/cdf/cdi/002.html
   *preferredRect = aPresContext->GetVisibleArea();
   
   if (aReflowState.availableWidth != NS_INTRINSICSIZE)
diff -r 31cfff909cc3 layout/tables/FixedTableLayoutStrategy.cpp
--- a/layout/tables/FixedTableLayoutStrategy.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/tables/FixedTableLayoutStrategy.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -121,6 +121,8 @@ FixedTableLayoutStrategy::GetMinWidth(ns
                         // row, split up the space evenly.  (XXX This
                         // isn't quite right if some of the columns it's
                         // in have specified widths.  Should we care?)
+                        // XXXldb This doesn't consider columns with no
+                        // cells originating.
                         cellWidth = ((cellWidth + spacing) / colSpan) - spacing;
                     }
                     result += cellWidth;
@@ -131,6 +133,7 @@ FixedTableLayoutStrategy::GetMinWidth(ns
                         result -= spacing * (colSpan - 1);
                     }
                 }
+                // XXXldb Bug 364989
             }
         }
     }
diff -r 31cfff909cc3 layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/tables/nsTableCellFrame.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -450,6 +450,7 @@ nsTableCellFrame::BuildDisplayList(nsDis
   if (quirkyClip) {
     clip = nsRect(nsPoint(0, 0), GetSize());
   }
+  // XXXldb Should this really OverflowClip?  (Used to be: Should this really SetClipRect?)
   return OverflowClip(aBuilder, set, aLists, clip + aBuilder->ToReferenceFrame(this));
 }
 
diff -r 31cfff909cc3 layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/tables/nsTableFrame.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -384,6 +384,7 @@ nsTableFrame::SetInitialChildList(nsIAto
     }
     else
     { // unknown frames go on the main list for now
+      NS_NOTREACHED("yikes, unknown frame type");
       if (mFrames.IsEmpty())
         mFrames.SetFrames(childFrame);
       else
diff -r 31cfff909cc3 layout/tables/nsTableOuterFrame.cpp
--- a/layout/tables/nsTableOuterFrame.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/tables/nsTableOuterFrame.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -604,6 +604,7 @@ nsTableOuterFrame::GetPrefWidth(nsIRende
     case NS_SIDE_BOTTOM:
     default:  // no caption 
       {
+        // XXXldb Use min width?
         nscoord capPref =
           nsLayoutUtils::IntrinsicForContainer(aRenderingContext, mCaptionFrame,
                                                nsLayoutUtils::PREF_WIDTH);
diff -r 31cfff909cc3 layout/tables/nsTableRowFrame.cpp
--- a/layout/tables/nsTableRowFrame.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/tables/nsTableRowFrame.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -193,6 +193,8 @@ nsTableRowFrame::AppendFrames(nsIAtom*  
     if (IS_TABLE_CELL(childFrame->GetType())) {
       // Add the cell to the cell map
       tableFrame->AppendCell((nsTableCellFrame&)*childFrame, GetRowIndex());
+    } else {
+      NS_NOTREACHED("unexpected child of table row");
     }
   }
 
@@ -225,6 +227,8 @@ nsTableRowFrame::InsertFrames(nsIAtom*  
        childFrame = childFrame->GetNextSibling()) {
     if (IS_TABLE_CELL(childFrame->GetType())) {
       cellChildren.AppendElement(childFrame);
+    } else {
+      NS_NOTREACHED("unexpected child of table row");
     }
   }
   // insert the cells into the cell map
diff -r 31cfff909cc3 layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/xul/base/src/nsBoxFrame.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -580,6 +580,7 @@ nsBoxFrame::GetInitialDirection(PRBool& 
   
   // Now see if we have an attribute.  The attribute overrides
   // the style system value.
+  // XXXldb This makes two reverses go back to normal!
   static nsIContent::AttrValuesArray strings[] =
     {&nsGkAtoms::reverse, &nsGkAtoms::ltr, &nsGkAtoms::rtl, nsnull};
   PRInt32 index = content->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::dir,
@@ -2011,12 +2012,16 @@ nsBoxFrame::CreateViewForFrame(nsPresCon
         if (scrollingView) {
           scrollingView->SetScrolledView(view);
         } else {
-          viewManager->SetViewZIndex(view, autoZIndex, zIndex);
           // XXX put view last in document order until we can do better
           viewManager->InsertChild(parentView, view, nsnull, PR_TRUE);
         }
 
+        nsContainerFrame::SyncFrameViewProperties(aPresContext, aFrame,
+                                                  nsnull, view);
+
+
         // See if the view should be hidden
+        // XXX Does SyncFrameViewProperties do the right thing here?
         PRBool  viewIsVisible = PR_TRUE;
         PRBool  viewHasTransparentContent =
             !isCanvas &&
@@ -2063,11 +2068,9 @@ nsBoxFrame::CreateViewForFrame(nsPresCon
           viewManager->SetViewVisibility(view, nsViewVisibility_kHide);
         }
 
-        viewManager->SetViewOpacity(view, disp->mOpacity);
+        // Remember our view
+        aFrame->SetView(view);
       }
-
-      // Remember our view
-      aFrame->SetView(view);
 
       NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
         ("nsBoxFrame::CreateViewForFrame: frame=%p view=%p",
diff -r 31cfff909cc3 layout/xul/base/src/nsDeckFrame.cpp
--- a/layout/xul/base/src/nsDeckFrame.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/xul/base/src/nsDeckFrame.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -127,6 +127,9 @@ nsDeckFrame::HideBox(nsPresContext* aPre
   if (view) {
     nsIViewManager* viewManager = view->GetViewManager();
     viewManager->SetViewVisibility(view, nsViewVisibility_kHide);
+    // XXX This can go away when our notion of view visibility applies
+    // better to descendant views. (i.e., more callers use IsVisible
+    // rather than GetVisibility).
     viewManager->ResizeView(view, nsRect(0, 0, 0, 0));
   }
 }
@@ -139,6 +142,9 @@ nsDeckFrame::ShowBox(nsPresContext* aPre
   if (view) {
     nsIViewManager* viewManager = view->GetViewManager();
     rect.x = rect.y = 0;
+    // XXX This can go away when our notion of view visibility applies
+    // better to descendant views. (i.e., more callers use IsVisible
+    // rather than GetVisibility).
     viewManager->ResizeView(view, rect);
     viewManager->SetViewVisibility(view, nsViewVisibility_kShow);
   }
diff -r 31cfff909cc3 layout/xul/base/src/nsMenuPopupFrame.cpp
--- a/layout/xul/base/src/nsMenuPopupFrame.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/xul/base/src/nsMenuPopupFrame.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -179,7 +179,7 @@ nsMenuPopupFrame::Init(nsIContent*      
   // Remove the view from its old position.
   viewManager->RemoveChild(ourView);
 
-  // Reinsert ourselves as the root view with a maximum z-index.
+  // Reinsert ourselves under the root view with a maximum z-index.
   nsIView* rootView;
   viewManager->GetRootView(rootView);
   viewManager->SetViewZIndex(ourView, PR_FALSE, kMaxZ);
@@ -2094,20 +2094,6 @@ NS_IMPL_ISUPPORTS1(nsMenuPopupTimerMedia
 NS_IMPL_ISUPPORTS1(nsMenuPopupTimerMediator, nsITimerCallback)
 
 /**
- * Constructs a wrapper around an nsMenuFrame.
- * @param aFrame nsMenuFrame to create a wrapper around.
- */
-nsMenuPopupTimerMediator::nsMenuPopupTimerMediator(nsMenuPopupFrame *aFrame) :
-  mFrame(aFrame)
-{
-  NS_ASSERTION(mFrame, "Must have frame");
-}
-
-nsMenuPopupTimerMediator::~nsMenuPopupTimerMediator()
-{
-}
-
-/**
  * Delegates the notification to the contained frame if it has not been destroyed.
  * @param aTimer Timer which initiated the callback.
  * @return NS_ERROR_FAILURE if the frame has been destroyed.
diff -r 31cfff909cc3 layout/xul/base/src/nsMenuPopupFrame.h
--- a/layout/xul/base/src/nsMenuPopupFrame.h	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/xul/base/src/nsMenuPopupFrame.h	Wed Jan 17 15:50:38 2007 -0800
@@ -84,9 +84,22 @@ class nsMenuPopupTimerMediator : public 
 class nsMenuPopupTimerMediator : public nsITimerCallback
 {
 public:
-  nsMenuPopupTimerMediator(nsMenuPopupFrame* aFrame);
-  ~nsMenuPopupTimerMediator();
-
+  /**
+   * Constructs a wrapper around an nsMenuFrame.
+   * @param aFrame nsMenuFrame to create a wrapper around.
+   */
+  nsMenuPopupTimerMediator(nsMenuPopupFrame *aFrame)
+    : mFrame(aFrame)
+  {
+    NS_ASSERTION(mFrame, "Must have frame");
+  }
+
+private:
+  ~nsMenuPopupTimerMediator()
+  {
+  }
+
+public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSITIMERCALLBACK
 
diff -r 31cfff909cc3 layout/xul/base/src/nsScrollBoxFrame.cpp
--- a/layout/xul/base/src/nsScrollBoxFrame.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/xul/base/src/nsScrollBoxFrame.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -46,6 +46,7 @@
 #include "nsITimer.h"
 #include "nsRepeatService.h"
 
+// XXXldb This should not implement nsITimerCallback!
 class nsAutoRepeatBoxFrame : public nsButtonBoxFrame, 
                              public nsITimerCallback
 {
diff -r 31cfff909cc3 layout/xul/base/src/nsSprocketLayout.cpp
--- a/layout/xul/base/src/nsSprocketLayout.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/layout/xul/base/src/nsSprocketLayout.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -262,9 +262,7 @@ nsSprocketLayout::Layout(nsIBox* aBox, n
   // The |size| variable will hold the total size of children along the axis of
   // the box.  Continuing with the example begun in the comment above, size would
   // be 150 pixels.
-  nscoord size = clientRect.width;
-  if (!IsHorizontal(aBox))
-    size = clientRect.height;
+  nscoord size = IsHorizontal(aBox) ? clientRect.width : clientRect.height;
   ComputeChildSizes(aBox, aState, size, boxSizes, computedBoxSizes);
 
   // After the call to ComputeChildSizes, the |size| variable contains the
diff -r 31cfff909cc3 mailnews/addrbook/src/nsAddrDatabase.cpp
--- a/mailnews/addrbook/src/nsAddrDatabase.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/mailnews/addrbook/src/nsAddrDatabase.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -1070,7 +1070,7 @@ nsresult nsAddrDatabase::CheckAndUpdateR
 
   nsresult err = NS_OK;
   nsIMdbTableRowCursor* rowCursor = nsnull;
-  nsIMdbRow* findRow = nsnull;
+  nsCOMPtr<nsIMdbRow> findRow;
   mdb_pos    rowPos = 0;
 
   mdb_err merror = m_mdbPabTable->GetTableRowCursor(m_mdbEnv, -1, &rowCursor);
@@ -1085,7 +1085,7 @@ nsresult nsAddrDatabase::CheckAndUpdateR
 
   do
   {  //add key to each card and mailing list row
-    merror = rowCursor->NextRow(m_mdbEnv, &findRow, &rowPos);
+    merror = rowCursor->NextRow(m_mdbEnv, getter_AddRefs(findRow), &rowPos);
     if (merror == NS_OK && findRow)
     {
       mdbOid rowOid;
diff -r 31cfff909cc3 modules/libpr0n/decoders/bmp/nsBMPDecoder.cpp
--- a/modules/libpr0n/decoders/bmp/nsBMPDecoder.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/modules/libpr0n/decoders/bmp/nsBMPDecoder.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -167,6 +167,7 @@ nsresult nsBMPDecoder::WriteRLERows(PRUi
             byte |= *pos++ & bit;
         mAlpha[cnt] = byte;
 #ifdef MOZ_CAIRO_GFX
+        // XXXldb This makes no sense!
 #ifdef IS_LITTLE_ENDIAN
         mDecoded[(cnt << 2) + 3] = byte ? 0 : 255;
 #else
@@ -183,6 +184,7 @@ nsresult nsBMPDecoder::WriteRLERows(PRUi
 #endif
         rv = mFrame->SetImageData(mDecoded, mBpr, line * mBpr);
         NS_ENSURE_SUCCESS(rv, rv);
+        // XXXldb eh?
         if (cnt == 0) {
             memset(mAlpha, 0, mBIH.width);
             memset(mDecoded, 0, mBpr);
diff -r 31cfff909cc3 modules/oji/src/nsJVMManager.cpp
--- a/modules/oji/src/nsJVMManager.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/modules/oji/src/nsJVMManager.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -120,7 +120,6 @@ static NS_DEFINE_IID(kIJVMManagerIID, NS
 static NS_DEFINE_IID(kIJVMManagerIID, NS_IJVMMANAGER_IID);
 static NS_DEFINE_IID(kIJVMThreadManagerIID, NS_IJVMTHREADMANAGER_IID);
 static NS_DEFINE_IID(kILiveConnectManagerIID, NS_ILIVECONNECTMANAGER_IID);
-static NS_DEFINE_IID(kIJVMPluginIID, NS_IJVMPLUGIN_IID);
 
 #define PLUGIN_REGIONAL_URL "chrome://global-region/locale/region.properties"
 
@@ -384,7 +383,7 @@ nsJVMManager::PostEvent(PRThread* prthre
 }
 
 nsJVMManager::nsJVMManager(nsISupports* outer)
-    : fJVM(NULL), fStatus(nsJVMStatus_Enabled),
+    : fStatus(nsJVMStatus_Enabled),
       fDebugManager(NULL), fJSJavaVM(NULL),
       fClassPathAdditions(new nsVoidArray()), fClassPathAdditionsString(NULL),
       fStartupMessagePosted(PR_FALSE)
@@ -411,10 +410,7 @@ nsJVMManager::~nsJVMManager()
     delete fClassPathAdditions;
     if (fClassPathAdditionsString)
         PR_Free(fClassPathAdditionsString);
-    if (fJVM) {
-        /*nsrefcnt c =*/ fJVM->Release();   // Release for QueryInterface in GetJVM
-        // XXX unload plugin if c == 1 ? (should this be done inside Release?)
-    }
+    // XXX unload plugin if fJVM's refcount is 1?
 }
 
 nsresult
@@ -662,7 +658,7 @@ nsJVMManager::StartupJVM(void)
     EnterMonitor(&uStatus);
 #endif // MOZ_OJI_REQUIRE_THREAD_SAFE_ON_STARTUP    
 
-    PR_ASSERT(fJVM == NULL);
+    PR_ASSERT(fJVM == nsnull);
     /*
     **TODO: amusil. Load the plugin by getting into Service manager.
     **              Right now there is no API to do this stuff. We need to
@@ -697,18 +693,18 @@ nsJVMManager::StartupJVM(void)
         return fStatus;
     }
 
-    nsIPlugin* pluginFactory = NULL;
+    nsCOMPtr<nsIPlugin> pluginFactory;
      // this code is the correct way to obtain pluggable JVM
     nsCOMPtr<nsIPlugin> f = 
              do_GetService(NS_INLINE_PLUGIN_CONTRACTID_PREFIX NS_JVM_MIME_TYPE, &err);
     if (NS_FAILED(err) || !f) {
-        err = pluginHost->GetPluginFactory(NS_JVM_MIME_TYPE, &pluginFactory);
+        err = pluginHost->GetPluginFactory(NS_JVM_MIME_TYPE, getter_AddRefs(pluginFactory));
     } 
     else {
         pluginFactory  = f;
     }
     
-    if (pluginFactory == NULL) {
+    if (!pluginFactory) {
         fStatus = nsJVMStatus_Failed;
 
 #ifdef MOZ_OJI_REQUIRE_THREAD_SAFE_ON_STARTUP    
@@ -718,9 +714,10 @@ nsJVMManager::StartupJVM(void)
         return fStatus;
     }
 
-    nsresult rslt = pluginFactory->QueryInterface(kIJVMPluginIID, (void**)&fJVM);
+    nsresult rslt;
+    fJVM = do_QueryInterface(pluginFactory, &rslt);
     if (rslt != NS_OK) {
-        PR_ASSERT(fJVM == NULL);
+        PR_ASSERT(fJVM == nsnull);
         fStatus = nsJVMStatus_Failed;
 
 #ifdef MOZ_OJI_REQUIRE_THREAD_SAFE_ON_STARTUP    
@@ -738,8 +735,6 @@ nsJVMManager::StartupJVM(void)
     JSContext* crippledContext = LM_GetCrippledContext();
     MaybeStartupLiveConnect(crippledContext, JS_GetGlobalObject(crippledContext));
 #endif
-
-    fJVM->Release();
 
 #ifdef DEBUG
     PRIntervalTime end = PR_IntervalNow();
@@ -766,7 +761,7 @@ nsJVMManager::ShutdownJVM(PRBool fullShu
 nsJVMManager::ShutdownJVM(PRBool fullShutdown)
 {
     if (fStatus == nsJVMStatus_Running) {
-        PR_ASSERT(fJVM != NULL);
+        PR_ASSERT(fJVM != nsnull);
         // XXX need to shutdown JVM via ServiceManager
 //        nsresult err = fJVM->ShutdownJVM(fullShutdown);
 //        if (err == NS_OK)
@@ -775,9 +770,9 @@ nsJVMManager::ShutdownJVM(PRBool fullShu
 //            ReportJVMError(err);
 //            fStatus = nsJVMStatus_Disabled;
 //        }
-        fJVM = NULL;
-    }
-    PR_ASSERT(fJVM == NULL);
+        fJVM = nsnull;
+    }
+    PR_ASSERT(fJVM == nsnull);
     return fStatus;
 }
 
diff -r 31cfff909cc3 modules/oji/src/nsJVMManager.h
--- a/modules/oji/src/nsJVMManager.h	Wed Jan 17 15:49:54 2007 -0800
+++ b/modules/oji/src/nsJVMManager.h	Wed Jan 17 15:50:38 2007 -0800
@@ -221,7 +221,7 @@ protected:
     nsresult    GetChrome(nsIWebBrowserChrome **theChrome);
     const char* GetJavaErrorString(JRIEnv* env);
 
-    nsIJVMPlugin*       fJVM;
+    nsCOMPtr<nsIJVMPlugin> fJVM;
     nsJVMStatus         fStatus;
     nsISupports*        fDebugManager;
     JSJavaVM *          fJSJavaVM;  
diff -r 31cfff909cc3 modules/plugin/base/public/nsIPluginInstanceInternal.h
--- a/modules/plugin/base/public/nsIPluginInstanceInternal.h	Wed Jan 17 15:49:54 2007 -0800
+++ b/modules/plugin/base/public/nsIPluginInstanceInternal.h	Wed Jan 17 15:50:38 2007 -0800
@@ -51,6 +51,8 @@ public:
 public: 
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IPLUGININSTANCEINTERNAL_IID)
 
+  // The caller needs to root this object before making most JS API
+  // calls.
   virtual JSObject *GetJSObject(JSContext *cx) = 0;
 
   virtual nsresult GetFormValue(nsAString& aValue) = 0;
diff -r 31cfff909cc3 modules/plugin/base/src/ns4xPlugin.cpp
--- a/modules/plugin/base/src/ns4xPlugin.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/modules/plugin/base/src/ns4xPlugin.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -2009,6 +2009,8 @@ _setvalue(NPP npp, NPPVariable variable,
             rv = NS_ERROR_FAILURE;
 
             nsCOMPtr<nsIPluginInstancePeer> peer;
+            // XXXldb Shouldn't this return failure if peer is null
+            // (i.e., just skip the null-check)?
             if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
               nsCOMPtr<nsIPluginInstancePeer2> peer2 =
                 do_QueryInterface(peer);
@@ -2018,10 +2020,13 @@ _setvalue(NPP npp, NPPVariable variable,
                 rv = peer2->GetJSContext(&cx);
 
                 if (NS_SUCCEEDED(rv))
+                  // XXXldb Should assert that every push a plugin does
+                  // is matched by a pop.
                   rv = contextStack->Push(cx);
               }
             }
           } else {
+            // XXXldb Should assert that it's the right context!
             rv = contextStack->Pop(nsnull);
           }
         }
diff -r 31cfff909cc3 netwerk/base/src/nsProtocolProxyService.h
--- a/netwerk/base/src/nsProtocolProxyService.h	Wed Jan 17 15:49:54 2007 -0800
+++ b/netwerk/base/src/nsProtocolProxyService.h	Wed Jan 17 15:50:38 2007 -0800
@@ -319,6 +319,8 @@ protected:
     };
 
     // simplified array of filters defined by this struct
+    struct HostInfo;
+    friend struct HostInfo;
     struct HostInfo {
         PRBool  is_ipaddr;
         PRInt32 port;
diff -r 31cfff909cc3 netwerk/base/src/nsStandardURL.cpp
--- a/netwerk/base/src/nsStandardURL.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/netwerk/base/src/nsStandardURL.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -55,6 +55,7 @@
 #include "prlog.h"
 #include "nsAutoPtr.h"
 #include "nsIProgrammingLanguage.h"
+#include "nsVoidArray.h"
 
 static NS_DEFINE_CID(kThisImplCID, NS_THIS_STANDARDURL_IMPL_CID);
 static NS_DEFINE_CID(kStandardURLCID, NS_STANDARDURL_CID);
@@ -272,6 +273,10 @@ nsSegmentEncoder::InitUnicodeEncoder()
 // nsStandardURL <public>
 //----------------------------------------------------------------------------
 
+#ifdef NS_BUILD_REFCNT_LOGGING
+static nsVoidArray *gAllURLs;
+#endif
+
 nsStandardURL::nsStandardURL(PRBool aSupportsFileURL)
     : mDefaultPort(-1)
     , mPort(-1)
@@ -296,6 +301,10 @@ nsStandardURL::nsStandardURL(PRBool aSup
 
     // default parser in case nsIStandardURL::Init is never called
     mParser = net_GetStdURLParser();
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+    gAllURLs->AppendElement(this);
+#endif
 }
 
 nsStandardURL::~nsStandardURL()
@@ -303,7 +312,26 @@ nsStandardURL::~nsStandardURL()
     LOG(("Destroying nsStandardURL @%p\n", this));
 
     CRTFREEIF(mHostA);
-}
+#ifdef NS_BUILD_REFCNT_LOGGING
+    gAllURLs->RemoveElement(this);
+#endif
+}
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+static void DumpLeakedURLs()
+{
+    PRUint32 count = gAllURLs->Count();
+    if (count) {
+        printf("Leaked URLs:\n");
+        nsCAutoString spec;
+        for (PRUint32 i = 0; i < count; ++i) {
+            nsStandardURL *url = NS_STATIC_CAST(nsStandardURL*, gAllURLs->ElementAt(i));
+            url->GetSpec(spec);
+            printf("  %s\n", spec.get());
+        }
+    }
+}
+#endif
 
 void
 nsStandardURL::InitGlobalObjects()
@@ -327,6 +355,11 @@ nsStandardURL::InitGlobalObjects()
                NS_ADDREF(gIDNWhitelistPrefBranch = branch);
         }
     }
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+    gAllURLs = new nsVoidArray;
+    atexit(DumpLeakedURLs);
+#endif
 }
 
 void
diff -r 31cfff909cc3 netwerk/cache/src/nsCacheService.cpp
--- a/netwerk/cache/src/nsCacheService.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/netwerk/cache/src/nsCacheService.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -65,6 +65,7 @@
 #include "nsThreadUtils.h"
 #include "nsProxyRelease.h"
 #include "nsVoidArray.h"
+#include "nsReadableUtils.h"
 #include "nsDeleteDir.h"
 #include <math.h>  // for log()
 
@@ -155,16 +156,14 @@ nsCacheProfilePrefObserver::Install()
     nsCOMPtr<nsIPrefBranch2> branch = do_GetService(NS_PREFSERVICE_CONTRACTID);
     if (!branch) return NS_ERROR_FAILURE;
 
-    char * prefList[] = { 
+    static const char prefList[][36] = { 
         DISK_CACHE_ENABLE_PREF,
         DISK_CACHE_CAPACITY_PREF,
         DISK_CACHE_DIR_PREF,
         MEMORY_CACHE_ENABLE_PREF,
         MEMORY_CACHE_CAPACITY_PREF
     };
-    int listCount = NS_ARRAY_LENGTH(prefList);
-      
-    for (int i=0; i<listCount; i++) {
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(prefList); ++i) {
         rv = branch->AddObserver(prefList[i], this, PR_FALSE);
         if (NS_FAILED(rv))  rv2 = rv;
     }
@@ -223,7 +222,9 @@ nsCacheProfilePrefObserver::Observe(nsIS
                                     const PRUnichar * data_unicode)
 {
     nsresult rv;
-    NS_ConvertUTF16toUTF8 data(data_unicode);
+    nsCAutoString data;
+    if (data_unicode)
+        AppendUTF16toUTF8(data_unicode, data);
     CACHE_LOG_ALWAYS(("Observe [topic=%s data=%s]\n", topic, data.get()));
 
     if (!strcmp(NS_XPCOM_SHUTDOWN_OBSERVER_ID, topic)) {
diff -r 31cfff909cc3 netwerk/dns/src/nsDNSService2.cpp
--- a/netwerk/dns/src/nsDNSService2.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/netwerk/dns/src/nsDNSService2.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -194,7 +194,10 @@ public:
         , mHost(host)
         , mListener(listener)
         , mFlags(flags)
-        , mAF(af) {}
+        , mAF(af)
+    {
+        //printf("Looking up \"%s\".\n", PromiseFlatCString(host).get());
+    }
     ~nsDNSAsyncRequest() {}
 
     void OnLookupComplete(nsHostResolver *, nsHostRecord *, nsresult);
diff -r 31cfff909cc3 netwerk/dns/src/nsIDNService.cpp
--- a/netwerk/dns/src/nsIDNService.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/netwerk/dns/src/nsIDNService.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -110,7 +110,7 @@ void nsIDNService::prefsChanged(nsIPrefB
     nsXPIDLCString prefix;
     nsresult rv = prefBranch->GetCharPref(NS_NET_PREF_IDNPREFIX, getter_Copies(prefix));
     if (NS_SUCCEEDED(rv) && prefix.Length() <= kACEPrefixLen)
-      PL_strncpyz(nsIDNService::mACEPrefix, prefix.get(), kACEPrefixLen + 1);
+      PL_strncpyz(mACEPrefix, prefix.get(), sizeof(mACEPrefix));
   }
   if (!pref || NS_LITERAL_STRING(NS_NET_PREF_IDNBLACKLIST).Equals(pref)) {
     nsCOMPtr<nsISupportsString> blacklist;
@@ -131,6 +131,7 @@ nsIDNService::nsIDNService()
   // initialize to the official prefix (RFC 3490 "5. ACE prefix")
   const char kIDNSPrefix[] = "xn--";
   strcpy(mACEPrefix, kIDNSPrefix);
+  NS_ASSERTION(sizeof(mACEPrefix) >= sizeof(kIDNSPrefix), "bad strcpy");
 
   mMultilingualTestBed = PR_FALSE;
 
@@ -431,9 +432,9 @@ nsresult nsIDNService::stringPrep(const 
     return NS_ERROR_FAILURE;
 
   // normalize
-  nsAutoString normlizedStr;
-  rv = mNormalizer->NormalizeUnicodeNFKC(namePrepStr, normlizedStr);
-  if (normlizedStr.Length() >= kMaxDNSNodeLen)
+  nsAutoString normalizedStr;
+  rv = mNormalizer->NormalizeUnicodeNFKC(namePrepStr, normalizedStr);
+  if (normalizedStr.Length() >= kMaxDNSNodeLen)
     return NS_ERROR_FAILURE;
 
   // prohibit
@@ -450,7 +451,7 @@ nsresult nsIDNService::stringPrep(const 
     return NS_ERROR_FAILURE;
 
   // set the result string
-  out.Assign(normlizedStr);
+  out.Assign(normalizedStr);
 
   return rv;
 }
diff -r 31cfff909cc3 parser/htmlparser/src/nsViewSourceHTML.cpp
--- a/parser/htmlparser/src/nsViewSourceHTML.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/parser/htmlparser/src/nsViewSourceHTML.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -145,6 +145,7 @@ public:
   }
 
   static CSharedVSContext& GetSharedContext() {
+    // XXXldb Static constructor!
     static CSharedVSContext gSharedVSContext;
     return gSharedVSContext;
   }
diff -r 31cfff909cc3 themes/classic/global/mac/textbox.css
--- a/themes/classic/global/mac/textbox.css	Wed Jan 17 15:49:54 2007 -0800
+++ b/themes/classic/global/mac/textbox.css	Wed Jan 17 15:50:38 2007 -0800
@@ -71,6 +71,7 @@ html|*.textbox-textarea {
   background-color: inherit;
   color: inherit;
   font: inherit;
+  line-height: normal;
 }
 
 /* ..... focused state ..... */
diff -r 31cfff909cc3 themes/classic/global/win/textbox.css
--- a/themes/classic/global/win/textbox.css	Wed Jan 17 15:49:54 2007 -0800
+++ b/themes/classic/global/win/textbox.css	Wed Jan 17 15:50:38 2007 -0800
@@ -70,6 +70,7 @@ html|*.textbox-textarea {
   background-color: inherit;
   color: inherit;
   font: inherit;
+  line-height: normal;
 }
 
 /* ..... readonly state ..... */
diff -r 31cfff909cc3 themes/classic/messenger/mailWindow1.css
--- a/themes/classic/messenger/mailWindow1.css	Wed Jan 17 15:49:54 2007 -0800
+++ b/themes/classic/messenger/mailWindow1.css	Wed Jan 17 15:50:38 2007 -0800
@@ -99,6 +99,7 @@
 #searchBoxHolder > #searchBox {
   border-top: 1px solid ThreeDHighlight;
   border-bottom: 1px solid ThreeDShadow;
+  min-width: 1px; /* allow other things in the window to shrink */
 }
 
 /* XXX bug 313731 buttons are taller than menulists */
diff -r 31cfff909cc3 themes/modern/global/textbox.css
--- a/themes/modern/global/textbox.css	Wed Jan 17 15:49:54 2007 -0800
+++ b/themes/modern/global/textbox.css	Wed Jan 17 15:50:38 2007 -0800
@@ -72,6 +72,7 @@ html|*.textbox-textarea {
   background-color: inherit;
   color: inherit;
   font: inherit;
+  line-height: normal;
 }
 
 /* ..... focused state ..... */
diff -r 31cfff909cc3 toolkit/components/build/nsToolkitCompsModule.cpp
--- a/toolkit/components/build/nsToolkitCompsModule.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/toolkit/components/build/nsToolkitCompsModule.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -117,7 +117,7 @@ static const nsModuleComponentInfo compo
 #endif
 #ifndef MOZ_SUITE
 // XXX Suite isn't ready to include this just yet
-#ifdef MOZ_XPINSTALL
+#ifdef MOZ_XPINSTALL // XXXldb Why?
 #ifdef MOZ_RDF
   { "Download Manager",
     NS_DOWNLOADMANAGER_CID,
diff -r 31cfff909cc3 toolkit/components/passwordmgr/base/nsPasswordManager.cpp
--- a/toolkit/components/passwordmgr/base/nsPasswordManager.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/toolkit/components/passwordmgr/base/nsPasswordManager.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -222,6 +222,8 @@ nsPasswordManager::nsPasswordManager()
 
 nsPasswordManager::~nsPasswordManager()
 {
+  NS_ASSERTION(mAutoCompleteInputs.Count() == 0,
+               "content nodes leaked until password manager shutdown");
 }
 
 
diff -r 31cfff909cc3 toolkit/components/remote/nsGTKRemoteService.cpp
--- a/toolkit/components/remote/nsGTKRemoteService.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/toolkit/components/remote/nsGTKRemoteService.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -107,6 +107,7 @@ NS_IMETHODIMP_(nsrefcnt)
 NS_IMETHODIMP_(nsrefcnt)
 nsGTKRemoteService::Release()
 {
+  // XXXldb This object leaks!
   return 1;
 }
 
@@ -221,8 +222,6 @@ nsGTKRemoteService::Observe(nsISupports*
   Shutdown();
   return NS_OK;
 }
-
-#define ARRAY_LENGTH(array_) (sizeof(array_)/sizeof(array_[0]))
 
 // Minimize the roundtrips to the X server by getting all the atoms at once
 static char *XAtomNames[] = {
@@ -235,7 +234,7 @@ static char *XAtomNames[] = {
   MOZILLA_PROGRAM_PROP,
   MOZILLA_COMMANDLINE_PROP
 };
-static Atom XAtoms[ARRAY_LENGTH(XAtomNames)];
+static Atom XAtoms[NS_ARRAY_LENGTH(XAtomNames)];
 
 void
 nsGTKRemoteService::EnsureAtoms(void)
@@ -243,7 +242,7 @@ nsGTKRemoteService::EnsureAtoms(void)
   if (sMozVersionAtom)
     return;
 
-  XInternAtoms(GDK_DISPLAY(), XAtomNames, ARRAY_LENGTH(XAtomNames),
+  XInternAtoms(GDK_DISPLAY(), XAtomNames, NS_ARRAY_LENGTH(XAtomNames),
                False, XAtoms);
   int i = 0;
   sMozVersionAtom     = XAtoms[i++];
diff -r 31cfff909cc3 toolkit/components/satchel/src/nsFormFillController.cpp
--- a/toolkit/components/satchel/src/nsFormFillController.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/toolkit/components/satchel/src/nsFormFillController.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -103,7 +103,8 @@ nsFormFillController::nsFormFillControll
   mCompleteDefaultIndex(PR_FALSE),
   mCompleteSelectedIndex(PR_FALSE),
   mForceComplete(PR_FALSE),
-  mSuppressOnInput(PR_FALSE)
+  mSuppressOnInput(PR_FALSE),
+  mIgnoreClick(PR_FALSE)
 {
   mController = do_GetService("@mozilla.org/autocomplete/controller;1");
 
diff -r 31cfff909cc3 toolkit/themes/pinstripe/mozapps/shared/richview.css
--- a/toolkit/themes/pinstripe/mozapps/shared/richview.css	Wed Jan 17 15:49:54 2007 -0800
+++ b/toolkit/themes/pinstripe/mozapps/shared/richview.css	Wed Jan 17 15:50:38 2007 -0800
@@ -4,6 +4,7 @@ view {
   margin: 10px 10px 5px 10px;
   -moz-appearance: listbox;
   -moz-user-focus: normal;
+  background-color: Window;
 }
 
 .richviewInner2 {
diff -r 31cfff909cc3 toolkit/themes/winstripe/global/browser.css
--- a/toolkit/themes/winstripe/global/browser.css	Wed Jan 17 15:49:54 2007 -0800
+++ b/toolkit/themes/winstripe/global/browser.css	Wed Jan 17 15:50:38 2007 -0800
@@ -1,123 +1,29 @@
 
 @namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
 
-/**
- * Tabbrowser Tabs
- */
+.tabbrowser-strip {
+
+}
+
+tabpanels {
+  -moz-appearance: none;
+}
 
 .tabbrowser-tabs {
-  -moz-binding: url("chrome://global/skin/globalBindings.xml#tabbrowser-tabs") !important;
-  padding-top: 0px;
-  background: -moz-dialog url("chrome://global/skin/icons/tabbrowser-tabs-bkgnd.png") !important;
-  -moz-padding-start: 0px;
+  padding-top: 1px;
+  background: transparent url("chrome://global/skin/icons/tabstrip-bottom.png") repeat-x bottom center !important;
+  -moz-padding-start: 2px;
+  border-bottom: 2px solid;
+  -moz-border-bottom-colors: threedshadow threedlightshadow;
 }
 
-.tabbrowser-tabs[overflow="true"] {
-  -moz-padding-start: 0px;
+.tabs-left,
+.tabs-right {
+  width: 3px;
+  border-bottom-width: 0px;
 }
 
-/**
- * Tab
- */
-
-.tabbrowser-tab {
-  -moz-appearance: none !important;
-  -moz-binding: url("chrome://global/skin/globalBindings.xml#tabbrowser-tab") !important;
-  background: transparent !important;
-  margin: 0px  !important;
-  padding: 0px !important;
-  border: none !important;
-  height: 22px !important;
-  margin-bottom: 1px;
-}
-
-.tabbrowser-tab > .tab-image-middle {
-  padding-top: 1px;
-  -moz-padding-start: 1px;
-}
-
-.tabbrowser-tab[busy] > .tab-image-middle > .tab-icon > .tab-icon-image {
-  list-style-image: url("chrome://global/skin/throbber/Throbber-small.gif") !important;
-  opacity: 0.6;
-}
-
-.tabbrowser-tab[selected="true"] {
-  font-weight: bold;
-}
-
-.tabbrowser-tab[selected="true"] > .tab-image-middle > .tab-text {
-  opacity: 1.0 !important;
-}
-
-.tabbrowser-tab > .tab-image-left {
-  width: 8px;
-  height: 24px;
-  background: url("chrome://global/skin/icons/tab-left.png") no-repeat;
-  background-color: -moz-dialog;
-  -moz-border-radius-topleft: 4px;
-}
-
-.tabbrowser-tab[chromedir="rtl"] > .tab-image-left {
-  background: url("chrome://global/skin/icons/tab-right.png") no-repeat;
-  background-color: -moz-dialog;
-  -moz-border-radius-topleft: 0px;
-  -moz-border-radius-topright: 4px;
-}
-
-.tabbrowser-tab:not([selected="true"]):not(:hover) > .tab-image-left {
-  background: url("chrome://global/skin/icons/tab-left-bkgnd.png") no-repeat;
-  background-color: -moz-dialog;
-}
-
-.tabbrowser-tab[chromedir="rtl"]:not([selected="true"]):not(:hover) > .tab-image-left {
-  background: url("chrome://global/skin/icons/tab-right-bkgnd.png") no-repeat;
-  background-color: -moz-dialog;
-}
-
-.tabbrowser-tab > .tab-image-middle {
-  height: 24px;
-  background: url("chrome://global/skin/icons/tab-middle.png") repeat-x;
-  background-color: -moz-dialog;
-}
-
-.tabbrowser-tab:not([selected="true"]):not(:hover) > .tab-image-middle {
-  background: url("chrome://global/skin/icons/tab-middle-bkgnd.png") repeat-x;
-  background-color: -moz-dialog;
-}
-
-.tabbrowser-tab > .tab-image-right {
-  width: 8px;
-  height: 24px;
-  background: url("chrome://global/skin/icons/tab-right.png") no-repeat;
-  background-color: -moz-dialog;
-  -moz-border-radius-topright: 4px;
-}
-
-.tabbrowser-tab[chromedir="rtl"] > .tab-image-right {
-  background: url("chrome://global/skin/icons/tab-left.png") no-repeat;
-  background-color: -moz-dialog;
-  -moz-border-radius-topleft: 4px;
-  -moz-border-radius-topright: 0px;
-}
-
-.tabbrowser-tab:not([selected="true"]):not(:hover) > .tab-image-right {
-  background: url("chrome://global/skin/icons/tab-right-bkgnd.png") no-repeat;
-  background-color: -moz-dialog;
-}
-
-.tabbrowser-tab[chromedir="rtl"]:not([selected="true"]):not(:hover) > .tab-image-right {
-  background: url("chrome://global/skin/icons/tab-left-bkgnd.png") no-repeat;
-  background-color: -moz-dialog;
-}
-
-.tabbrowser-tab:not([selected="true"]) > .tab-image-left,
-.tabbrowser-tab:not([selected="true"]) > .tab-image-middle,
-.tabbrowser-tab:not([selected="true"]) > .tab-image-right {
-  height: 23px;
-  margin-bottom: 1px;
-}
-
-.tab-icon-image {
+.tab-icon {
   margin-top: 1px;
   -moz-margin-end: 3px;
   width: 16px;
@@ -126,36 +32,20 @@
   -moz-image-region: rect(0px, 16px, 16px, 0px);
 }
 
-.tabs-bottom {
-  height: 4px !important;
-  margin: 0px !important;
-  background: -moz-dialog url("chrome://global/skin/icons/tabstrip-bottom.png") repeat !important;
-  border-top: 1px solid threedshadow; 
-  border-bottom: 1px solid threedshadow;
+tab[busy] > .tab-middle > .tab-icon {
+  list-style-image: url("chrome://global/skin/throbber/Throbber-small.gif");
+  opacity: 0.5;
 }
 
-tabpanels {
-  -moz-appearance: none;
+tab[selected="true"] {
+  font-weight: bold;
+  margin-bottom: 0px;
+  -moz-padding-start: 3px;
 }
 
-.tabs-left,
-.tabs-right {
-  width: 3px;
-  border-bottom-width: 0px;
+tab {
+  margin-bottom: 1px;
 }
-
-/* tabbrowser-tab focus ring */
-.tabbrowser-tab >  .tab-image-middle > .tab-text {
-  border: 1px dotted transparent;
-}
-
-.tabbrowser-tab:focus > .tab-image-middle > .tab-text {
-  border: 1px dotted -moz-DialogText;
-}
-
-/**
- * Tab Drag and Drop
- */
 
 .tab-drop-indicator-bar {
     display:none;
@@ -181,26 +71,17 @@ tabpanels {
  */
 .tab-close-button > .toolbarbutton-icon {
   -moz-margin-end: 0px !important;
-  margin-top: 1px;
 }
 
 .tab-close-button {
+  list-style-image: url("chrome://global/skin/icons/close.png");
   -moz-appearance: none;
   -moz-image-region: rect(0px, 64px, 16px, 48px);
-  height: 24px;
+  -moz-margin-start: 2px;
+  margin-top: 2px;
   border: none !important;
   padding: 0px;
-  cursor: default;
-  list-style-image: url("chrome://global/skin/icons/close.png");
-}
-
-.tabbrowser-tab:not([selected="true"]) > .tab-close-button {
-  height: 23px;
-  margin-bottom: 1px;
-}
-
-.tabbrowser-tab:not([selected="true"]) > .tab-close-button > .toolbarbutton-icon {
-  margin-top: 2px;
+  opacity: 0.7;
 }
 
 .tab-close-button:hover,
@@ -215,19 +96,12 @@ tabpanels {
   opacity: 1.0;
 }
 
-.tabbrowser-tab > .tab-close-button {
-  background-image: url("chrome://global/skin/icons/tab-middle-bkgnd.png");
-  background-color: -moz-dialog;
-}
-
-.tabbrowser-tab:hover > .tab-close-button {
-  background-image: url("chrome://global/skin/icons/tab-middle.png");
-}
-
 .tabbrowser-tab[selected="true"] > .tab-close-button {
-  background-image: url("chrome://global/skin/icons/tab-middle.png");
+  -moz-margin-start: 2px;
+  margin-top: 0px;
+  opacity: 1.0;
   -moz-image-region: rect(0px, 16px, 16px, 0px);
-  /* Make this button focusable so clicking on it will not focus the tab while
+  /* Make this button focusable so clicking on it will not focus the tab while 
      it's getting closed */
   -moz-user-focus: normal;
 }
@@ -237,139 +111,23 @@ tabpanels {
 }
 
 /**
- * Tab Scrollbox Arrow Buttons
+ * Tabbrowser Tabs
  */
-
-.tabbrowser-tabs[overflow="true"] .tabs-left {
-  display: none;
+.tabbrowser-tab[selected="true"] {
+  -moz-padding-end: 4px; 
+  padding-top: 4px;
+  padding-bottom: 1px;
 }
 
-.tabbrowser-arrowscrollbox > .scrollbutton-up {
-  -moz-appearance: none !important;
-  border: none !important;
-  margin-top: 2px;
-  margin-bottom: 4px !important;
-  padding: 0px;
-  width: 18px;
-  height: 23px;
-  -moz-margin-start: 0px;
-  -moz-margin-end: 0px;
-  list-style-image: url("chrome://global/skin/icons/tab-arrow-start.png");
-  -moz-image-region: rect(0, 11px, 14px, 0);
-  background-repeat: no-repeat;
-  background-image: url("chrome://global/skin/icons/tab-arrow-start-bkgnd-enabled.png");
-  background-color: -moz-dialog;
-  -moz-border-radius-topright: 4px;
+.tabbrowser-tab > .tab-middle {
+  padding-top: 1px;
 }
 
-.tabbrowser-arrowscrollbox[chromedir="rtl"] > .scrollbutton-up {
-  list-style-image: url("chrome://global/skin/icons/tab-arrow-end.png");
-  background-image: url("chrome://global/skin/icons/tab-arrow-end-bkgnd-enabled.png");
-  -moz-border-radius-topleft: 4px;
-  -moz-border-radius-topright: 0px;
-}
-
-.tabbrowser-arrowscrollbox > .scrollbutton-up[disabled="true"] {
-  -moz-image-region: rect(0, 33px, 14px, 22px);
-  background-image: url("chrome://global/skin/icons/tab-arrow-start-bkgnd-disabled.png");
-}
-
-.tabbrowser-arrowscrollbox[chromedir="rtl"] > .scrollbutton-up[disabled="true"] {
-  background-image: url("chrome://global/skin/icons/tab-arrow-end-bkgnd-disabled.png");
-}
-
-.tabbrowser-arrowscrollbox > .scrollbutton-up:not([disabled="true"]):hover {
-  background-image: url("chrome://global/skin/icons/tab-arrow-start-bkgnd-hover.png");
-  -moz-image-region: rect(0, 22px, 14px, 11px);
-}
-
-.tabbrowser-arrowscrollbox[chromedir="rtl"] > .scrollbutton-up:not([disabled="true"]):hover {
-  background-image: url("chrome://global/skin/icons/tab-arrow-end-bkgnd-hover.png");
-}
-
-.tabbrowser-arrowscrollbox > .scrollbutton-up:not([disabled="true"]):hover:active {
-  -moz-image-region: rect(0, 44px, 14px, 33px);
-}
-
-.tabbrowser-arrowscrollbox > .scrollbutton-up > .toolbarbutton-icon {    
-  margin: 6px 0px 0px 0px;
-}                                                                            
-
-.tabbrowser-arrowscrollbox > .scrollbutton-down-stack {
-  margin-top: 2px;
-  margin-bottom: 4px;
-  height: 23px;
-}
-
-.scrollbutton-rel-box > .scrollbutton-down-box {
-  -moz-appearance: none !important;
-  border: none !important;
-  width: 18px;
-  background-image: url("chrome://global/skin/icons/tab-arrow-end-bkgnd-enabled.png");
-  background-repeat: no-repeat;	
-  background-color: -moz-dialog;
-  -moz-border-radius-topleft: 4px;
-}
-
-.tabbrowser-arrowscrollbox[chromedir="rtl"] > stack > .scrollbutton-rel-box > .scrollbutton-down-box {
-  background-image: url("chrome://global/skin/icons/tab-arrow-start-bkgnd-enabled.png");
-  -moz-border-radius-topleft: 0px;
-  -moz-border-radius-topright: 4px;
-}
-
-.scrollbutton-rel-box > .scrollbutton-down-box[disabled="true"] {
-  background-image: url("chrome://global/skin/icons/tab-arrow-end-bkgnd-disabled.png");
-}
-
-.tabbrowser-arrowscrollbox[chromedir="rtl"] > stack > .scrollbutton-rel-box > .scrollbutton-down-box[disabled="true"] {
-  background-image: url("chrome://global/skin/icons/tab-arrow-start-bkgnd-disabled.png");
-}
-
-.scrollbutton-rel-box > .scrollbutton-down-box-animate {
-  background-image: url("chrome://global/skin/icons/tab-arrow-end-bkgnd-animate.png");
-  background-repeat: no-repeat;
-  opacity: 0.0;
-}
-
-.tabbrowser-arrowscrollbox[chromedir="rtl"] > stack > .scrollbutton-rel-box > .scrollbutton-down-box-animate {
-  background-image: url("chrome://global/skin/icons/tab-arrow-start-bkgnd-animate.png");
-}
-
-.scrollbutton-rel-box > .scrollbutton-down {
-  -moz-appearance: none !important;
-  border: none !important;
-  width: 18px;
-  list-style-image: url("chrome://global/skin/icons/tab-arrow-end.png");
-  -moz-image-region: rect(0, 11px, 14px, 0);
-  margin: 0px;
-  padding: 0px;
-}
-
-.tabbrowser-arrowscrollbox[chromedir="rtl"] > stack > .scrollbutton-rel-box > .scrollbutton-down {
-  list-style-image: url("chrome://global/skin/icons/tab-arrow-start.png");
-}
-
-.scrollbutton-rel-box > .scrollbutton-down[disabled="true"] {
-  -moz-image-region: rect(0, 33px, 14px, 22px);
-}
-
-.scrollbutton-rel-box > .scrollbutton-down:not([disabled="true"]):hover {
-  -moz-image-region: rect(0, 22px, 14px, 11px);
-  background-image: url("chrome://global/skin/icons/tab-arrow-end-bkgnd-hover.png");
-  background-repeat: no-repeat;
-  background-position: top left;
-}
-
-.tabbrowser-arrowscrollbox[chromedir="rtl"] > stack > .scrollbutton-rel-box > .scrollbutton-down:not([disabled="true"]):hover {
-  background-image: url("chrome://global/skin/icons/tab-arrow-start-bkgnd-hover.png");
-}
-
-.scrollbutton-rel-box > .scrollbutton-down:not([disabled="true"]):hover:active {
-  -moz-image-region: rect(0, 44px, 14px, 33px);
-}
-
-.scrollbutton-rel-box > .scrollbutton-down > .toolbarbutton-icon {
-  margin: 6px 0px 0px 1px;
+.tabbrowser-tab[selected="true"] > .tab-middle {
+  padding-bottom: 1px;
+  padding-top: 0;
+  -moz-padding-start: 1px;
+  margin-bottom: 1px;
 }
 
 /**
@@ -377,86 +135,17 @@ tabpanels {
  */
 
 .tabs-alltabs-box {
-  margin-top: 2px;
-  margin-bottom: 4px;
-  width: 18px !important;
-  height: 23px !important;
-  background-image: url("chrome://global/skin/icons/tab-arrow-end-bkgnd-enabled.png");
-  background-repeat: no-repeat;
-  background-color: -moz-dialog; 
-  -moz-border-radius-topleft: 4px;
-}
-
-stack[chromedir="rtl"] > hbox > .tabs-alltabs-box {
-  background-image: url("chrome://global/skin/icons/tab-arrow-start-bkgnd-enabled.png");
-  -moz-border-radius-topleft: 0px;
-  -moz-border-radius-topright: 4px;
-}
-
-.tabbrowser-tabs[overflow="true"] .tabs-alltabs-box {
-  background-image: url("chrome://global/skin/icons/alltabs-box-overflow-end-bkgnd.png");
-  -moz-border-radius-topleft: 0px;
-  -moz-border-radius-topright: 0px;
-}
-
-.tabbrowser-tabs[overflow="true"] stack[chromedir="rtl"] > hbox > .tabs-alltabs-box {
-  background-image: url("chrome://global/skin/icons/alltabs-box-overflow-start-bkgnd.png");
+  background-color: orange;
+  opacity: 0.0;
 }
 
 .tabs-alltabs-button {
-  -moz-appearance: none !important;
-  border: 0px !important;
-  margin-top: 2px;
-  margin-bottom: 4px;
-  width: 18px !important;
-  height: 23px !important;
-  border: 0px !important;
-  -moz-padding-start: 4px !important;
-  -moz-padding-end: 4px !important;
-  padding: 0px;
-}
-
-.tabs-alltabs-button > .toolbarbutton-text {
-  display: none;
-}
-
-.tabs-alltabs-button > .toolbarbutton-icon {
-  -moz-margin-end: 2px;
-}
-
-.tabs-alltabs-button > .toolbarbutton-menu-dropmarker {
-  margin-top: 3px !important;
+  list-style-image: url("chrome://global/skin/icons/alltabs.png");
+  -moz-image-region: rect(0px, 16px, 16px, 0px); 
 }
 
 .tabs-alltabs-button:hover {
-  background-image: url("chrome://global/skin/icons/tab-arrow-end-bkgnd-hover.png");
-  background-repeat: no-repeat;
-}
-
-stack[chromedir="rtl"] > hbox > .tabs-alltabs-button:hover {
-  background-image: url("chrome://global/skin/icons/tab-arrow-start-bkgnd-hover.png");
-}
-
-.tabbrowser-tabs[overflow="true"] .tabs-alltabs-button:hover {
-  background-image: url("chrome://global/skin/icons/alltabs-box-overflow-end-bkgnd-hover.png");
-}
-
-.tabbrowser-tabs[overflow="true"] stack[chromedir="rtl"] > hbox > .tabs-alltabs-button:hover {
-  background-image: url("chrome://global/skin/icons/alltabs-box-overflow-start-bkgnd-hover.png");
-}
-
-.tabs-alltabs-box-animate {
-  margin-top: 2px;
-  margin-bottom: 4px;
-  width: 18px !important;
-  height: 23px !important;
-  background-image: url("chrome://global/skin/icons/alltabs-box-overflow-end-bkgnd-animate.png");
-  background-repeat: no-repeat;
-  opacity: 0.0;
-}
-
-stack[chromedir="rtl"] > hbox > .tabs-alltabs-box-animate {
-  background-image: url("chrome://global/skin/icons/alltabs-box-overflow-start-bkgnd-animate.png");
+  -moz-image-region: rect(0px, 48px, 16px, 32px);
 }
 
 /**
@@ -476,5 +165,5 @@ stack[chromedir="rtl"] > hbox > .tabs-al
 
 .alltabs-item[busy] > .menu-iconic-left > .menu-iconic-icon {
   list-style-image: url("chrome://global/skin/throbber/Throbber-small.gif");
-  opacity: 0.6;
+  opacity: 0.5;
 }
diff -r 31cfff909cc3 tools/jprof/stub/libmalloc.cpp
--- a/tools/jprof/stub/libmalloc.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/tools/jprof/stub/libmalloc.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -86,7 +86,68 @@ static int enableRTCSignals(bool enable)
 
 //----------------------------------------------------------------------
 
-#if defined(i386) || defined(_i386) || defined(__x86_64__)
+//#if __GNUC__ >= 3
+#if 0
+
+#include <unwind.h>
+
+struct CrawlStackClosure {
+  malloc_log_entry *me;
+  void *stack_top;
+  void *top_instr_ptr;
+};
+
+extern "C" {
+static _Unwind_Reason_Code CrawlStackCallback(struct _Unwind_Context *cx, void *c);
+}
+
+/* static */ _Unwind_Reason_Code
+CrawlStackCallback(struct _Unwind_Context *cx, void *c)
+{
+  CrawlStackClosure *closure = (CrawlStackClosure*)c;
+  malloc_log_entry *me = closure->me;
+  if (me->numpcs >= MAX_STACK_CRAWL) {
+    printf("too many frames\n");
+    return _URC_END_OF_STACK;
+  }
+
+  void *sp = (void*)_Unwind_GetCFA(cx);
+  if (sp < closure->stack_top) {
+    printf("still in signal handling %p %p\n", sp, closure->stack_top);
+    // Still in the signal handling code.
+#if 0
+    // The unwind code doesn't know how to cross the signal handler, so
+    // we'll try to help it.
+    _Unwind_SetGR(cx, __builtin_dwarf_sp_column(),
+                  (_Unwind_Word) closure->stack_top);
+    _Unwind_SetIP(cx, (_Unwind_Ptr) closure->top_instr_ptr);
+#endif
+    return _URC_NO_REASON;
+  }
+
+  void *ip = (void*)_Unwind_GetIP(cx);
+  me->pcs[me->numpcs++] = (char*) ip;
+  printf("recording frame\n");
+
+  return _URC_NO_REASON;
+}
+
+static void CrawlStack(malloc_log_entry* me,
+                       void* stack_top, void* top_instr_ptr)
+{
+  CrawlStackClosure closure;
+  closure.me = me;
+  closure.stack_top = stack_top;
+  closure.top_instr_ptr = top_instr_ptr;
+  me->numpcs = 0;
+
+  me->pcs[me->numpcs++] = (char*) top_instr_ptr;
+
+  _Unwind_Backtrace(CrawlStackCallback, &closure);
+}
+
+#elif defined(i386) || defined(_i386) || defined(__x86_64__)
+
 static void CrawlStack(malloc_log_entry* me,
                        void* stack_top, void* top_instr_ptr)
 {
diff -r 31cfff909cc3 tools/rb/fix-linux-stack.pl
--- a/tools/rb/fix-linux-stack.pl	Wed Jan 17 15:49:54 2007 -0800
+++ b/tools/rb/fix-linux-stack.pl	Wed Jan 17 15:50:38 2007 -0800
@@ -96,6 +96,8 @@ sub address_adjustment($) {
 # for Fedora Core 5's *-debuginfo packages (glibc-debuginfo, etc.).
 # See http://sources.redhat.com/gdb/current/onlinedocs/gdb_16.html#SEC152
 # for how it ought to work.
+# ... or http://bugs.kde.org/show_bug.cgi?id=82872
+# parse output of objdump -s --section=.gnu_debuglink $file
 sub debuginfo_file_for($) {
     my ($file) = @_;
     return '/usr/lib/debug/' . $file . '.debug';
diff -r 31cfff909cc3 widget/src/gtk/nsWindow.cpp
--- a/widget/src/gtk/nsWindow.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/widget/src/gtk/nsWindow.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -1061,6 +1061,21 @@ NS_IMETHODIMP nsWindow::Invalidate(PRBoo
   if (!mSuperWin)
     return NS_OK;
   
+#ifdef DEBUG
+  // Check the pref _before_ checking caps lock, because checking
+  // caps lock requires a server round-trip.
+  if (debug_GetCachedBoolPref("nglayout.debug.invalidate_dumping") &&
+      CAPS_LOCK_IS_ON)
+  {
+    debug_DumpInvalidate(stdout,
+                         this,
+                         nsnull,
+                         aIsSynchronous,
+                         debug_GetName(GTK_OBJECT(mSuperWin)),
+                         debug_GetRenderXID(GTK_OBJECT(mSuperWin)));
+  }
+#endif // DEBUG
+
   mUpdateArea->SetTo(0, 0, mBounds.width, mBounds.height);
   
   if (aIsSynchronous)
@@ -1077,6 +1092,21 @@ NS_IMETHODIMP nsWindow::Invalidate(const
   if (!mSuperWin)
     return NS_OK;
 
+#ifdef DEBUG
+  // Check the pref _before_ checking caps lock, because checking
+  // caps lock requires a server round-trip.
+  if (debug_GetCachedBoolPref("nglayout.debug.invalidate_dumping") &&
+      CAPS_LOCK_IS_ON)
+  {
+    debug_DumpInvalidate(stdout,
+                         this,
+                         &aRect,
+                         aIsSynchronous,
+                         debug_GetName(GTK_OBJECT(mSuperWin)),
+                         debug_GetRenderXID(GTK_OBJECT(mSuperWin)));
+  }
+#endif // DEBUG
+
   mUpdateArea->Union(aRect.x, aRect.y, aRect.width, aRect.height);
 
   if (aIsSynchronous)
@@ -1093,6 +1123,27 @@ NS_IMETHODIMP nsWindow::InvalidateRegion
   if (!mSuperWin)
     return NS_OK;
   
+#ifdef DEBUG
+  // Check the pref _before_ checking caps lock, because checking
+  // caps lock requires a server round-trip.
+  if (debug_GetCachedBoolPref("nglayout.debug.invalidate_dumping") &&
+      CAPS_LOCK_IS_ON)
+  {
+    nsRegionRectSet *regionRectSet = nsnull;
+    NS_CONST_CAST(nsIRegion*, aRegion)->GetRects(&regionRectSet);
+    for (nsRegionRect *r = regionRectSet->mRects,
+                  *r_end = r + regionRectSet->mNumRects; r < r_end; ++r) {
+      nsRect rect(r->x, r->y, r->width, r->height);
+      debug_DumpInvalidate(stdout,
+                           this,
+                           &rect,
+                           aIsSynchronous,
+                           debug_GetName(GTK_OBJECT(mSuperWin)),
+                           debug_GetRenderXID(GTK_OBJECT(mSuperWin)));
+    }
+  }
+#endif // DEBUG
+
   mUpdateArea->Union(*aRegion);
 
   if (aIsSynchronous)
diff -r 31cfff909cc3 widget/src/gtk2/gtk2drawing.c
--- a/widget/src/gtk2/gtk2drawing.c	Wed Jan 17 15:49:54 2007 -0800
+++ b/widget/src/gtk2/gtk2drawing.c	Wed Jan 17 15:50:38 2007 -0800
@@ -1297,14 +1297,20 @@ moz_gtk_progress_chunk_paint(GdkDrawable
                              GdkRectangle* cliprect)
 {
     GtkStyle* style;
+    gint x, y, w, h;
 
     ensure_progress_widget();
     style = gProgressWidget->style;
 
+    /* do our own clipping, since at least some themes ignore cliprect */
+    x = MAX(rect->x, cliprect->x);
+    y = MAX(rect->y, cliprect->y);
+    w = MIN(rect->x + rect->width, cliprect->x + cliprect->width) - x;
+    h = MIN(rect->y + rect->height, cliprect->y + cliprect->height) - y;
+
     TSOffsetStyleGCs(style, rect->x, rect->y);
     gtk_paint_box(style, drawable, GTK_STATE_PRELIGHT, GTK_SHADOW_OUT,
-                  cliprect, gProgressWidget, "bar", rect->x, rect->y,
-                  rect->width, rect->height);
+                  NULL, gProgressWidget, "bar", x, y, w, h);
 
     return MOZ_GTK_SUCCESS;
 }
diff -r 31cfff909cc3 widget/src/gtk2/nsLookAndFeel.cpp
--- a/widget/src/gtk2/nsLookAndFeel.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/widget/src/gtk2/nsLookAndFeel.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -77,8 +77,7 @@ nsLookAndFeel::nsLookAndFeel() : nsXPLoo
 
 nsLookAndFeel::~nsLookAndFeel()
 {
-    //  gtk_widget_destroy(mWidget);
-    gtk_widget_unref(mWidget);
+    g_object_unref(mStyle);
 }
 
 nsresult nsLookAndFeel::NativeGetColor(const nsColorID aID, nscolor& aColor)
@@ -677,8 +676,7 @@ nsLookAndFeel::LookAndFeelChanged()
 {
     nsXPLookAndFeel::LookAndFeelChanged();
 
-    if (mWidget)
-        gtk_widget_unref(mWidget);
+    g_object_unref(mStyle);
  
     InitWidget();
     InitLookAndFeel();
diff -r 31cfff909cc3 widget/src/gtk2/nsLookAndFeel.h
--- a/widget/src/gtk2/nsLookAndFeel.h	Wed Jan 17 15:49:54 2007 -0800
+++ b/widget/src/gtk2/nsLookAndFeel.h	Wed Jan 17 15:50:38 2007 -0800
@@ -56,7 +56,6 @@ public:
 
 protected:
     GtkStyle *mStyle;
-    GtkWidget *mWidget;
 
     // Cached colors, we have to create a dummy widget to actually
     // get the style
@@ -75,11 +74,12 @@ protected:
 
     static void InitLookAndFeel();
     void InitWidget() {
-        mWidget = gtk_invisible_new();
-        gtk_object_ref(GTK_OBJECT(mWidget));
-        gtk_object_sink(GTK_OBJECT(mWidget));
-        gtk_widget_ensure_style(mWidget);
-        mStyle = gtk_widget_get_style(mWidget);
+        GtkWidget *widget = gtk_invisible_new();
+        gtk_object_ref(GTK_OBJECT(widget));
+        gtk_object_sink(GTK_OBJECT(widget));
+        gtk_widget_ensure_style(widget);
+        mStyle = gtk_style_copy(gtk_widget_get_style(widget));
+        gtk_widget_unref(widget);
     }
 };
 
diff -r 31cfff909cc3 widget/src/gtk2/nsWindow.cpp
--- a/widget/src/gtk2/nsWindow.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/widget/src/gtk2/nsWindow.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -1128,6 +1128,7 @@ nsWindow::Update()
         return NS_OK;
 
     gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
+    // XSync(GDK_DISPLAY(), False);
     return NS_OK;
 }
 
@@ -5158,6 +5159,7 @@ void
 void
 nsWindow::IMECreateContext(void)
 {
+    NS_ASSERTION(!mIMEData, "already have IME data");
     mIMEData = new nsIMEData(this);
     if (!mIMEData)
         return;
@@ -5175,6 +5177,7 @@ nsWindow::IMECreateContext(void)
     gtk_im_context_set_client_window(mIMEData->mDummyContext,
                                      GTK_WIDGET(mContainer)->window);
 
+    // XXX Should we remove these signals before releasing the context?
     g_signal_connect(G_OBJECT(mIMEData->mContext), "preedit_changed",
                      G_CALLBACK(IM_preedit_changed_cb), this);
     g_signal_connect(G_OBJECT(mIMEData->mContext), "commit",
diff -r 31cfff909cc3 widget/src/gtk2/nsWindow.h
--- a/widget/src/gtk2/nsWindow.h	Wed Jan 17 15:49:54 2007 -0800
+++ b/widget/src/gtk2/nsWindow.h	Wed Jan 17 15:50:38 2007 -0800
@@ -295,6 +295,7 @@ public:
      *  The children refers to its owning window's object.
      */
     struct nsIMEData {
+        // XXX Should this be refcounted?  I've seen it be a dangling pointer.
         // Actual context. This is used for handling the user's input.
         GtkIMContext       *mContext;
         // mDummyContext is a dummy context and will be used in IMESetFocus()
diff -r 31cfff909cc3 widget/src/xremoteclient/XRemoteClient.cpp
--- a/widget/src/xremoteclient/XRemoteClient.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/widget/src/xremoteclient/XRemoteClient.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -694,6 +694,7 @@ XRemoteClient::DoSendCommandLine(Window 
   for (i = 0; i < argc; ++i)
     argvlen += strlen(argv[i]);
 
+  // XXXldb Would be nice to free |buffer|!
   PRInt32* buffer = (PRInt32*) malloc(argvlen + argc + 1 +
                                       sizeof(PRInt32) * (argc + 1));
   if (!buffer)
diff -r 31cfff909cc3 xpcom/base/nsIWeakReference.idl
--- a/xpcom/base/nsIWeakReference.idl	Wed Jan 17 15:49:54 2007 -0800
+++ b/xpcom/base/nsIWeakReference.idl	Wed Jan 17 15:50:38 2007 -0800
@@ -49,6 +49,15 @@
  * (hopefully short-lived) owning reference on demand, through which clients
  * can get useful access to the referent, while it still exists.
  *
+ * Thus this interface provides the following contract:  The result of
+ * calling QueryReferent on a given implementation of this interface
+ * with a given IID may change over time, but not more than twice:  it
+ * may change once from null to non-null (to account for aggregation)
+ * and it may change once from non-null to null.  This means that if
+ * a QueryReferent for an IID that once returned non-null (or was
+ * guaranteed by GetWeakReference to return non-null) at some time
+ * returns null, it will never again return non-null.
+ *
  * @status FROZEN
  * @version 1.0
  * @see nsISupportsWeakReference
@@ -86,6 +95,12 @@ interface nsISupportsWeakReference : nsI
      * As with all good XPCOM `getters', you own the resulting interface and should
      * manage it with an |nsCOMPtr|.
      *
+     * If this call is successful, the weak reference returned is (while
+     * the nsISupportsWeakReference object is held) guaranteed to return
+     * non-null for a QueryReferent to any interface that the
+     * nsISupportsWeakReference implementation is known to
+     * QueryInterface to.
+     *
      * @see nsIWeakReference
      * @see nsWeakPtr
      * @see nsCOMPtr
diff -r 31cfff909cc3 xpcom/base/nsStackFrameUnix.cpp
--- a/xpcom/base/nsStackFrameUnix.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/xpcom/base/nsStackFrameUnix.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -84,6 +84,9 @@ void DemangleSymbol(const char * aSymbol
 
 
 #if defined(linux) && defined(__GNUC__) && (defined(__i386) || defined(PPC) || defined(__x86_64__)) // i386 or PPC Linux stackwalking code
+
+// XXXldb This should basically work for Mac OS X, 10.3 and up.
+// See http://developer.apple.com/documentation/DeveloperTools/Reference/MachOReference/Reference/reference.html#//apple_ref/doc/uid/TP40001398-CH1g-315644
 
 
 void DumpStackToFile(FILE* aStream)
diff -r 31cfff909cc3 xpcom/components/nsComponentManager.cpp
--- a/xpcom/components/nsComponentManager.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/xpcom/components/nsComponentManager.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -2478,7 +2478,9 @@ nsComponentManagerImpl::RegisterFactory(
         return NS_ERROR_OUT_OF_MEMORY;
 
 
+    // XXX This is guaranteed to be true.
     if (PL_DHASH_ENTRY_IS_BUSY(factoryTableEntry)) {
+        // XXX I don't think entry is guaranteed to be null.
         entry = factoryTableEntry->mFactoryEntry;
     }
 
@@ -3391,6 +3393,9 @@ nsComponentManagerImpl::RegisterFactory(
                                         const char *aContractID,
                                         nsIFactory *aFactory)
 {
+    // XXX We really don't want to create a new factory entry for each
+    // CID/ContractID pair, since the same CID could be repeated and that's
+    // OK.  And it's really bad when they're services.
     return RegisterFactory(aClass,
                            aClassName,
                            aContractID,
diff -r 31cfff909cc3 xpcom/io/nsEscape.cpp
--- a/xpcom/io/nsEscape.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/xpcom/io/nsEscape.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -431,6 +431,7 @@ NS_COM PRBool NS_EscapeURL(const char *p
 
       if (tempBufferPos >= sizeof(tempBuffer) - 4)
       {
+        // XXXldb Why is this guaranteed not to fire?
         NS_ASSERTION(writing, "should be writing");
         tempBuffer[tempBufferPos] = '\0';
         result += tempBuffer;
diff -r 31cfff909cc3 xpcom/io/nsLocalFileWin.cpp
--- a/xpcom/io/nsLocalFileWin.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/xpcom/io/nsLocalFileWin.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -2303,7 +2303,7 @@ nsLocalFile::IsExecutable(PRBool *_retva
 
     // kill trailing dots and spaces.
     PRInt32 filePathLen = path.Length() - 1;
-    while(filePathLen > 0 && (path[filePathLen] == L' ' || path[filePathLen] == L'.'))
+    while(filePathLen >= 0 && (path[filePathLen] == L' ' || path[filePathLen] == L'.'))
     {
         path.Truncate(filePathLen--);
     } 
diff -r 31cfff909cc3 xpcom/tests/TestCallTemplates.cpp
--- a/xpcom/tests/TestCallTemplates.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/xpcom/tests/TestCallTemplates.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -78,8 +78,37 @@ NS_IMPL_ISUPPORTS2(nsTestService, nsITes
     {0xae, 0xd2, 0x1a, 0xb6, 0xdd, 0xba, 0xfe, 0x53}}
 static NS_DEFINE_CID(kTestServiceCID, NS_TEST_SERVICE_CID);
 
+#include "nsString.h"
+
 int main()
 {
+    nsCAutoString str;
+    str.AppendFloat(1.0/3.0);
+    str.Append(" ");
+    str.AppendFloat(2.0/3.0);
+    str.Append(" ");
+    str.AppendFloat(1.0/7.0);
+    str.Append(" ");
+    str.AppendFloat(-0.0);
+    str.Append(" ");
+    str.AppendFloat(-1073741824.0);
+    str.Append(" ");
+    str.AppendFloat(1073741824.0);
+    str.Append(" ");
+    str.AppendFloat(1024.0);
+    str.Append(" ");
+    str.AppendFloat(-1024.0);
+    printf("%s\n", str.get());
+
+#if 0
+    nsAutoString foo;
+    foo.AssignWithConversion("aosneuthasoenuhctsa oceuhsa oceush aoeu");
+    for (int i = 0; i < 10000000; ++i) {
+        NS_ConvertUCS2toUTF8 bar(foo.get());
+    }
+#endif
+
+#if 0
     /*
      * NOTE:  This does NOT demonstrate how these functions are
      * intended to be used.  They are intended for filling in out
@@ -124,6 +153,7 @@ int main()
     nsIInterfaceRequestor *myInterfaceRequestor =
         NS_STATIC_CAST(nsIInterfaceRequestor*, mySupportsPtr);
     CallGetInterface(myInterfaceRequestor, &myITestService);
+#endif
 
     return 0;
 }
diff -r 31cfff909cc3 xpfe/browser/src/nsBrowserStatusFilter.cpp
--- a/xpfe/browser/src/nsBrowserStatusFilter.cpp	Wed Jan 17 15:49:54 2007 -0800
+++ b/xpfe/browser/src/nsBrowserStatusFilter.cpp	Wed Jan 17 15:50:38 2007 -0800
@@ -89,6 +89,7 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsBrowserStatusFilter::RemoveProgressListener(nsIWebProgressListener *aListener)
 {
+    NS_ASSERTION(aListener == mListener, "listener mismatch");
     if (aListener == mListener)
         mListener = nsnull;
     return NS_OK;
