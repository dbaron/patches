diff --git a/accessible/src/atk/nsAccessibleWrap.cpp b/accessible/src/atk/nsAccessibleWrap.cpp
--- a/accessible/src/atk/nsAccessibleWrap.cpp
+++ b/accessible/src/atk/nsAccessibleWrap.cpp
@@ -261,17 +261,17 @@ mai_atk_object_get_type(void)
     }
     return type;
 }
 
 /*
  * Must keep sychronization with enumerate AtkProperty in 
  * accessible/src/base/nsAccessibleEventData.h
  */
-static char * sAtkPropertyNameArray[PROP_LAST] = {
+static const char * sAtkPropertyNameArray[PROP_LAST] = {
     0,
     "accessible-name",
     "accessible-description",
     "accessible-parent",
     "accessible-role",
     "accessible-layer",
     "accessible-mdi-zorder",
     "accessible-table-caption",
diff --git a/config/Makefile.in b/config/Makefile.in
--- a/config/Makefile.in
+++ b/config/Makefile.in
@@ -43,22 +43,20 @@ srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 # For sanity's sake, we compile nsinstall without the wrapped system
 # headers, so that we can use it to set up the wrapped system headers.
 VISIBILITY_FLAGS =
 
-ifneq (,$(CROSS_COMPILE)$(filter-out WINNT OS2,$(OS_ARCH)))
-ifneq ($(OS_ARCH), WINCE)
+ifneq (,$(CROSS_COMPILE)$(filter-out WINCE WINNT OS2,$(OS_ARCH)))
 HOST_PROGRAM	= nsinstall$(HOST_BIN_SUFFIX)
 HOST_CSRCS	= nsinstall.c pathsub.c
 endif
-endif
 
 PLSRCS		= nfspwd.pl
 
 TARGETS		= $(HOST_PROGRAM) $(PLSRCS:.pl=) $(SIMPLE_PROGRAMS)
 
 ifndef CROSS_COMPILE
 ifdef USE_ELF_DYNSTR_GC
 TARGETS		+= elf-dynstr-gc
diff --git a/content/base/src/nsAttrAndChildArray.cpp b/content/base/src/nsAttrAndChildArray.cpp
--- a/content/base/src/nsAttrAndChildArray.cpp
+++ b/content/base/src/nsAttrAndChildArray.cpp
@@ -724,16 +724,19 @@ nsAttrAndChildArray::MakeMappedUnique(ns
 
   if (!mImpl && !GrowBy(1)) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   if (!aAttributes->GetStyleSheet()) {
     // This doesn't currently happen, but it could if we do loading right
 
+    // XXXldb We shouldn't try to handle this gracefully, since it
+    // should never happen.  But it seems to.
+    //NS_NOTREACHED("no style sheet");
     nsRefPtr<nsMappedAttributes> mapped(aAttributes);
     mapped.swap(mImpl->mMappedAttrs);
 
     return NS_OK;
   }
 
   nsRefPtr<nsMappedAttributes> mapped =
     aAttributes->GetStyleSheet()->UniqueMappedAttributes(aAttributes);
diff --git a/content/base/src/nsDocument.cpp b/content/base/src/nsDocument.cpp
--- a/content/base/src/nsDocument.cpp
+++ b/content/base/src/nsDocument.cpp
@@ -6816,16 +6816,17 @@ nsDocument::CanSavePresentation(nsIReque
   }
 
   nsPIDOMWindow* win = GetInnerWindow();
   if (win && win->TimeoutSuspendCount()) {
     return PR_FALSE;
   }
 
   // Check our event listener manager for unload/beforeunload listeners.
+  // XXX What about listeners on the document rather than the window?
   nsCOMPtr<nsPIDOMEventTarget> piTarget = do_QueryInterface(mScriptGlobalObject);
   if (piTarget) {
     nsCOMPtr<nsIEventListenerManager> manager;
     piTarget->GetListenerManager(PR_FALSE, getter_AddRefs(manager));
     if (manager && manager->HasUnloadListeners()) {
       return PR_FALSE;
     }
   }
diff --git a/content/base/src/nsFrameLoader.cpp b/content/base/src/nsFrameLoader.cpp
--- a/content/base/src/nsFrameLoader.cpp
+++ b/content/base/src/nsFrameLoader.cpp
@@ -417,16 +417,19 @@ AddTreeItemToTreeOwner(nsIDocShellTreeIt
   if (aParentNode) {
     aParentNode->AddChild(aItem);
   }
 
   PRBool retval = PR_FALSE;
   if (aParentType == nsIDocShellTreeItem::typeChrome && isContent) {
     retval = PR_TRUE;
 
+    // Old comment, is it still valid?
+    // XXXldb This is inconsistent with the conditions under which
+    // nsFrame
     PRBool is_primary = value.LowerCaseEqualsLiteral("content-primary");
 
     if (aOwner) {
       PRBool is_targetable = is_primary ||
         value.LowerCaseEqualsLiteral("content-targetable");
       aOwner->ContentShellAdded(aItem, is_primary, is_targetable, value);
     }
   }
diff --git a/content/html/content/src/nsHTMLSelectElement.cpp b/content/html/content/src/nsHTMLSelectElement.cpp
--- a/content/html/content/src/nsHTMLSelectElement.cpp
+++ b/content/html/content/src/nsHTMLSelectElement.cpp
@@ -1740,18 +1740,20 @@ VerifyOptionsRecurse(nsIContent* aRoot, 
       VerifyOptionsRecurse(child, aIndex, aArray);
     }
   }
 }
 
 void
 nsHTMLSelectElement::VerifyOptionsArray()
 {
+#ifndef DEBUG_dbaron // This is really really slow on long selects!
   PRInt32 aIndex = 0;
   VerifyOptionsRecurse(this, aIndex, mOptions);
+#endif
 }
 
 
 #endif
 
 //----------------------------------------------------------------------
 //
 // nsHTMLOptionCollection implementation
diff --git a/content/xul/document/src/nsXULPrototypeCache.h b/content/xul/document/src/nsXULPrototypeCache.h
--- a/content/xul/document/src/nsXULPrototypeCache.h
+++ b/content/xul/document/src/nsXULPrototypeCache.h
@@ -66,17 +66,17 @@ struct CacheScriptEntry
  * The XUL prototype cache can be used to store and retrieve shared data for
  * XUL documents, style sheets, XBL, and scripts.
  *
  * The cache has two levels:
  *  1. In-memory hashtables
  *  2. The on-disk fastload file.
  */
 class nsXULPrototypeCache : public nsIXULPrototypeCache,
-                                   nsIObserver
+                            public nsIObserver
 {
 public:
     // nsISupports
     NS_DECL_ISUPPORTS
     NS_DECL_NSIOBSERVER
 
     // nsIXULPrototypeCache
     virtual PRBool IsCached(nsIURI* aURI) {
diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -730,16 +730,24 @@ nsDocShell::LoadURI(nsIURI * aURI,
     PRBool ownerIsExplicit = PR_FALSE;
     PRBool sendReferrer = PR_TRUE;
     nsCOMPtr<nsISHEntry> shEntry;
     nsXPIDLString target;
     PRUint32 loadType = MAKE_LOAD_TYPE(LOAD_NORMAL, aLoadFlags);    
 
     NS_ENSURE_ARG(aURI);
 
+#ifdef DEBUG
+    {
+        nsCAutoString spec;
+        aURI->GetSpec(spec);
+        printf("nsDocShell(%p)::LoadURI(%s)\n", this, spec.get());
+    }
+#endif
+
     // Extract the info from the DocShellLoadInfo struct...
     if (aLoadInfo) {
         aLoadInfo->GetReferrer(getter_AddRefs(referrer));
 
         nsDocShellInfoLoadType lt = nsIDocShellLoadInfo::loadNormal;
         aLoadInfo->GetLoadType(&lt);
         // Get the appropriate loadType from nsIDocShellLoadInfo type
         loadType = ConvertDocShellLoadInfoToLoadType(lt);
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -1838,16 +1838,17 @@ nsGlobalWindow::SetNewDocument(nsIDocume
           }
 
           // Re-push our context.
           cxPusher.Push(cx);
         }
 
         // Don't clear scope on our current inner window if it's going to be
         // held in the bfcache.
+        // XXXldb Move this out of currentInner->mJSObject check!
         if (!currentInner->IsFrozen()) {
           // Skip the ClearScope if we set a termination function to do
           // it ourselves, later.
           currentInner->FreeInnerObjects(!termFuncSet);
         }
       }
 
       mInnerWindow = newInnerWindow;
diff --git a/extensions/pref/system-pref/src/gconf/nsSystemPrefService.cpp b/extensions/pref/system-pref/src/gconf/nsSystemPrefService.cpp
--- a/extensions/pref/system-pref/src/gconf/nsSystemPrefService.cpp
+++ b/extensions/pref/system-pref/src/gconf/nsSystemPrefService.cpp
@@ -595,20 +595,23 @@ gconfDeleteObserver(void *aElement, void
 
 GConfProxy::GConfProxy(nsSystemPrefService *aSysPrefService):
     mGConfClient(nsnull),
     mGConfLib(nsnull),
     mInitialized(PR_FALSE),
     mSysPrefService(aSysPrefService),
     mObservers(nsnull)
 {
+    MOZ_COUNT_CTOR(GConfProxy);
 }
 
 GConfProxy::~GConfProxy()
 {
+    MOZ_COUNT_DTOR(GConfProxy);
+
     if (mGConfClient)
         g_object_unref(G_OBJECT(mGConfClient));
 
     if (mObservers) {
         (void)mObservers->EnumerateForwards(gconfDeleteObserver, nsnull);
         delete mObservers;
     }
 
diff --git a/gfx/thebes/src/nsUnicodeRange.cpp b/gfx/thebes/src/nsUnicodeRange.cpp
--- a/gfx/thebes/src/nsUnicodeRange.cpp
+++ b/gfx/thebes/src/nsUnicodeRange.cpp
@@ -32,16 +32,18 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsUnicodeRange.h"
 
+// XXXldb Replace this with something generated from the Unicode database.
+
 // This table depends on unicode range definitions. 
 // Each item's index must correspond unicode range value
 // eg. x-cyrillic = LangGroupTable[kRangeCyrillic]
 static const char *gUnicodeRangeToLangGroupTable[] = 
 {
   "x-cyrillic",
   "el",
   "tr",
diff --git a/intl/uconv/native/nsNativeUConvService.cpp b/intl/uconv/native/nsNativeUConvService.cpp
--- a/intl/uconv/native/nsNativeUConvService.cpp
+++ b/intl/uconv/native/nsNativeUConvService.cpp
@@ -328,22 +328,22 @@ IConvAdaptor::ConvertInternal(void * aSr
                 break;
             }
             
             if (errno == EILSEQ) {
 
                 if (mReplaceOnError) {
                     if (aDestCharSize == 1) {
                         (*(char*)aDest) = (char)mReplaceChar;
-                        aDest = (char*)aDest + sizeof(char);
+                        aDest = (char*)aDest + 1;
                     }
                     else
                     {
                         (*(PRUnichar*)aDest) = (PRUnichar)mReplaceChar;
-                        aDest = (PRUnichar*)aDest + sizeof(PRUnichar);
+                        aDest = (PRUnichar*)aDest + 1;
                     
                     }
                     inLeft -= aSrcCharSize;
                     outLeft -= aDestCharSize;
 
 #ifdef DEBUG
                     printf(" * IConvAdaptor - replacing char in output  ( %s -> %s )\n", 
                            mFrom.get(), mTo.get());
diff --git a/intl/unicharutil/tools/gentransliterate.pl b/intl/unicharutil/tools/gentransliterate.pl
--- a/intl/unicharutil/tools/gentransliterate.pl
+++ b/intl/unicharutil/tools/gentransliterate.pl
@@ -72,16 +72,19 @@
 # the terms of any one of the MPL, the GPL or the LGPL.
 #
 # ***** END LICENSE BLOCK *****
 
 # 
 # THIS FILE IS GENERATED BY mozilla/intl/unicharutil/tools/gentransliterate.pl
 # PLEASE DO NOT MODIFY THIS FILE BY HAND
 #
+END_OF_HEADER
+
+$handcoded = <<END_OF_HANDCODED;
 entity.list.name=transliterate
 entity.169=(c)
 #
 #
 # Here are the windows-1252 characters from the range 0x80 - 0x9F
 #
 END_OF_HEADER
 
diff --git a/js/src/config/Makefile.in b/js/src/config/Makefile.in
--- a/js/src/config/Makefile.in
+++ b/js/src/config/Makefile.in
@@ -43,22 +43,20 @@ srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 # For sanity's sake, we compile nsinstall without the wrapped system
 # headers, so that we can use it to set up the wrapped system headers.
 VISIBILITY_FLAGS =
 
-ifneq (,$(CROSS_COMPILE)$(filter-out WINNT OS2,$(OS_ARCH)))
-ifneq ($(OS_ARCH), WINCE)
+ifneq (,$(CROSS_COMPILE)$(filter-out WINCE WINNT OS2,$(OS_ARCH)))
 HOST_PROGRAM	= nsinstall$(HOST_BIN_SUFFIX)
 HOST_CSRCS	= nsinstall.c pathsub.c
 endif
-endif
 
 PLSRCS		= nfspwd.pl
 
 TARGETS		= $(HOST_PROGRAM) $(PLSRCS:.pl=) $(SIMPLE_PROGRAMS)
 
 # IMPORTANT: Disable NSBUILDROOT for this directory only, otherwise we have
 # a recursive rule for finding nsinstall and the Perl scripts.
 ifdef NSBUILDROOT
diff --git a/js/src/xpconnect/src/XPCDispInterface.cpp b/js/src/xpconnect/src/XPCDispInterface.cpp
--- a/js/src/xpconnect/src/XPCDispInterface.cpp
+++ b/js/src/xpconnect/src/XPCDispInterface.cpp
@@ -360,16 +360,18 @@ JSBool XPCDispInterface::Member::GetValu
                                          JS_GetStringBytes(JSVAL_TO_STRING(mName)));
         if(!fun)
             return JS_FALSE;
 
         JSObject* funobj = JS_GetFunctionObject(fun);
         if(!funobj)
             return JS_FALSE;
 
+        // XXXldb root funobj?
+
         // Store ourselves and our native interface within the JSObject
         if(!JS_SetReservedSlot(ccx, funobj, 0, PRIVATE_TO_JSVAL(this)))
             return JS_FALSE;
 
         if(!JS_SetReservedSlot(ccx, funobj, 1, PRIVATE_TO_JSVAL(iface)))
             return JS_FALSE;
 
         {   // scoped lock
diff --git a/js/src/xpconnect/src/xpcwrappednativescope.cpp b/js/src/xpconnect/src/xpcwrappednativescope.cpp
--- a/js/src/xpconnect/src/xpcwrappednativescope.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativescope.cpp
@@ -753,21 +753,17 @@ void DEBUG_CheckForComponentsInScope(JSC
         return;
 
     // This is pretty much always bad. It usually means that native code is
     // making a callback to an interface implemented in JavaScript, but the
     // document where the JS object was created has already been cleared and the
     // global properties of that document's window are *gone*. Generally this
     // indicates a problem that should be addressed in the design and use of the
     // callback code.
-#ifdef I_FOOLISHLY_WANT_TO_IGNORE_THIS_LIKE_THE_OTHER_CRAP_WE_PRINTF
-    NS_WARNING("XPConnect is being called on a scope without a 'Components' property!");
-#else
     NS_ERROR("XPConnect is being called on a scope without a 'Components' property!");
-#endif
 }
 #else
 #define DEBUG_CheckForComponentsInScope(ccx, obj, OKIfNotInitialized, runtime) \
     ((void)0)
 #endif
 
 // static
 XPCWrappedNativeScope*
diff --git a/layout/base/nsBidi.cpp b/layout/base/nsBidi.cpp
--- a/layout/base/nsBidi.cpp
+++ b/layout/base/nsBidi.cpp
@@ -1,9 +1,9 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
  *
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
diff --git a/layout/base/nsBidi.h b/layout/base/nsBidi.h
--- a/layout/base/nsBidi.h
+++ b/layout/base/nsBidi.h
@@ -262,17 +262,17 @@ typedef PRUint8 DirProp;
 #define IS_FIRST_SURROGATE(uchar) (((uchar)&0xfc00)==0xd800)
 #define IS_SECOND_SURROGATE(uchar) (((uchar)&0xfc00)==0xdc00)
 
 /* get the UTF-32 value directly from the surrogate pseudo-characters */
 #define SURROGATE_OFFSET ((0xd800<<10UL)+0xdc00-0x10000)
 #define GET_UTF_32(first, second) (((first)<<10UL)+(second)-SURROGATE_OFFSET)
 
 
-#define UTF_ERROR_VALUE 0xffff
+#define UTF_ERROR_VALUE 0xfffd
 /* definitions with forward iteration --------------------------------------- */
 
 /*
  * all the macros that go forward assume that
  * the initial offset is 0<=i<length;
  * they update the offset
  */
 
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -5837,16 +5837,19 @@ nsCSSFrameConstructor::AppendFrames(nsFr
 
 #define UNSET_DISPLAY 255
 
 // This gets called to see if the frames corresponding to aSiblingDisplay and aDisplay
 // should be siblings in the frame tree. Although (1) rows and cols, (2) row groups 
 // and col groups, (3) row groups and captions, (4) legends and content inside fieldsets, (5) popups and other kids of the menu
 // are siblings from a content perspective, they are not considered siblings in the 
 // frame tree.
+// XXXldb 307394 [Stir DOM] The way this is used seems completely bogus.
+// We should construct or grovel through pseudo-frames if this is false,
+// not skip content.
 PRBool
 nsCSSFrameConstructor::IsValidSibling(nsIFrame*              aSibling,
                                       nsIContent*            aContent,
                                       PRUint8&               aDisplay)
 {
   nsIFrame* parentFrame = aSibling->GetParent();
   nsIAtom* parentType = nsnull;
   nsIAtom* grandparentType = nsnull;
@@ -9002,16 +9005,19 @@ nsCSSFrameConstructor::GetFirstLineStyle
       ResolvePseudoStyleFor(aContent,
                             nsCSSPseudoElements::firstLine, aStyleContext);
   }
   return nsnull;
 }
 
 // Predicate to see if a given content (block element) has
 // first-letter style applied to it.
+// XXXldb Bug 362901 This isn't necessarily going to work if changes are
+// batched, since removing the style rule at the same time as messing
+// with content that relies on this could break things pretty badly.
 PRBool
 nsCSSFrameConstructor::ShouldHaveFirstLetterStyle(nsIContent* aContent,
                                                   nsStyleContext* aStyleContext)
 {
   return nsLayoutUtils::HasPseudoStyle(aContent, aStyleContext,
                                        nsCSSPseudoElements::firstLetter,
                                        mPresShell->GetPresContext());
 }
@@ -10657,16 +10663,17 @@ nsCSSFrameConstructor::ConstructInline(n
   newFrame->SetInitialChildList(nsnull, list1);
                                              
   // list2's frames belong to an anonymous block that we create right
   // now. The anonymous block will be the parent of the block children
   // of the inline.
   nsIAtom* blockStyle;
   nsRefPtr<nsStyleContext> blockSC;
   nsIFrame* blockFrame;
+  // XXXldb Remove :-moz-anonymous-positioned-block -- not supported by spec.
   if (positioned) {
     blockStyle = nsCSSAnonBoxes::mozAnonymousPositionedBlock;
     
     blockSC = mPresShell->StyleSet()->
       ResolvePseudoStyleFor(content, blockStyle, styleContext);
   }
   else {
     blockStyle = nsCSSAnonBoxes::mozAnonymousBlock;
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -5797,19 +5797,17 @@ nsBlockFrame::ReflowFloat(nsBlockReflowS
   if (floatFrame->GetType() == nsGkAtoms::letterFrame) {
     // We never split floating first letters; an incomplete state for
     // such frames simply means that there is more content to be
     // reflowed on the line.
     if (NS_FRAME_IS_NOT_COMPLETE(aReflowStatus)) 
       aReflowStatus = NS_FRAME_COMPLETE;
   }
 
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
+  NS_ENSURE_SUCCESS(rv, rv);
 
   // Capture the margin information for the caller
   const nsMargin& m = floatRS.mComputedMargin;
   aFloatMargin.top = brc.GetTopMargin();
   aFloatMargin.right = m.right;
   // Only last in flows get a bottom margin
   if (NS_FRAME_IS_COMPLETE(aReflowStatus)) {
     brc.GetCarriedOutBottomMargin().Include(m.bottom);
@@ -6424,19 +6422,17 @@ nsBlockFrame::SetInitialChildList(nsIAto
       !IsFrameOfType(eMathML) &&
       nsRefPtr<nsStyleContext>(GetFirstLetterStyle(presContext)) != nsnull;
     NS_ASSERTION(haveFirstLetterStyle ==
                  ((mState & NS_BLOCK_HAS_FIRST_LETTER_STYLE) != 0),
                  "NS_BLOCK_HAS_FIRST_LETTER_STYLE state out of sync");
 #endif
     
     rv = AddFrames(aChildList, nsnull);
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
+    NS_ENSURE_SUCCESS(rv, rv);
 
     // Create list bullet if this is a list-item. Note that this is done
     // here so that RenumberLists will work (it needs the bullets to
     // store the bullet numbers).
     const nsStyleDisplay* styleDisplay = GetStyleDisplay();
     if ((nsnull == GetPrevInFlow()) &&
         (NS_STYLE_DISPLAY_LIST_ITEM == styleDisplay->mDisplay) &&
         (nsnull == mBullet)) {
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -412,17 +412,17 @@ nsFrame::Init(nsIContent*      aContent,
     // The frame gets reconstructed if we toggle the -moz-transform
     // property, so we can set this bit here and then ignore it.
     mState |= NS_FRAME_MAY_BE_TRANSFORMED_OR_HAVE_RENDERING_OBSERVERS;
   }
   
   DidSetStyleContext(nsnull);
 
   if (IsBoxWrapped())
-    InitBoxMetrics(PR_FALSE);
+    InitBoxMetrics(PR_FALSE); // XXX propagate allocation failure?
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsFrame::SetInitialChildList(nsIAtom*        aListName,
                                            nsIFrame*       aChildList)
 {
   // XXX This shouldn't be getting called at all, but currently is for backwards
@@ -6278,16 +6278,17 @@ nsFrame::RefreshSizeCache(nsBoxLayoutSta
       nsIFrame* firstFrame = nsnull;
       PRInt32 framesOnLine;
       nsRect lineBounds;
       PRUint32 lineFlags;
 
       do {
          lines->GetLine(count, &firstFrame, &framesOnLine, lineBounds, &lineFlags);
 
+         // XXX This should sum across forced breaks!
          if (lineBounds.height > metrics->mBlockMinSize.height)
            metrics->mBlockMinSize.height = lineBounds.height;
 
          count++;
       } while(firstFrame);
     } else {
       metrics->mBlockMinSize.height = desiredSize.height;
     }
diff --git a/layout/generic/nsFrameFrame.cpp b/layout/generic/nsFrameFrame.cpp
--- a/layout/generic/nsFrameFrame.cpp
+++ b/layout/generic/nsFrameFrame.cpp
@@ -698,16 +698,19 @@ nsSubDocumentFrame::AttributeChanged(PRI
       parentTreeOwner->ContentShellRemoved(docShellAsItem);
 
       if (value.LowerCaseEqualsLiteral("content") ||
           StringBeginsWith(value, NS_LITERAL_STRING("content-"),
                            nsCaseInsensitiveStringComparator())) {
         PRBool is_targetable = is_primary ||
           value.LowerCaseEqualsLiteral("content-targetable");
 
+        // Old comment, maybe still valid?
+        // XXXldb The conditions under which this call is made are
+        // different from the conditions under which nsFrameLoader does.
         parentTreeOwner->ContentShellAdded(docShellAsItem, is_primary,
                                            is_targetable, value);
       }
     }
   }
 
   return NS_OK;
 }
diff --git a/layout/html/tests/block/rtest.sh b/layout/html/tests/block/rtest.sh
--- a/layout/html/tests/block/rtest.sh
+++ b/layout/html/tests/block/rtest.sh
@@ -23,16 +23,17 @@ dirs="  base \
         ../table/marvin \
         ../table/other \
         ../table/dom \
         ../table/printing \
         ../formctls/base \
         ../formctls/bugs \
         ../style/bugs \
         ../xbl \
+        net \
         "
 
 # This doesn't appear to work on Linux right now; needs support for a
 # null driver, perhaps?
 #extra_dirs="../table/printing"
 
 #extra_dirs="net/HTML_Chars net/W3C net/baron net/boxAcidTest net/glazman net/mozilla"
 
diff --git a/layout/style/ua.css b/layout/style/ua.css
--- a/layout/style/ua.css
+++ b/layout/style/ua.css
@@ -116,16 +116,17 @@
   outline: 1px dotted;
 }
 
 /* Miscellaneous */
 
 *|*::-moz-anonymous-block, *|*::-moz-cell-content {
   display: block !important;
   position: static !important;
+  /* XXX shouldn't unicode-bidi inherit? */
 }
 
 *|*::-moz-anonymous-block, *|*::-moz-anonymous-positioned-block {
   /* we currently inherit from the inline that is split */
   outline: inherit;
   outline-offset: inherit;
   clip-path: inherit;
   filter: inherit;
diff --git a/layout/tables/FixedTableLayoutStrategy.cpp b/layout/tables/FixedTableLayoutStrategy.cpp
--- a/layout/tables/FixedTableLayoutStrategy.cpp
+++ b/layout/tables/FixedTableLayoutStrategy.cpp
@@ -122,28 +122,31 @@ FixedTableLayoutStrategy::GetMinWidth(ns
                       styleWidth->GetIntValue() == NS_STYLE_WIDTH_MIN_CONTENT))) {
                     nscoord cellWidth = nsLayoutUtils::IntrinsicForContainer(
                         aRenderingContext, cellFrame, nsLayoutUtils::MIN_WIDTH);
                     if (colSpan > 1) {
                         // If a column-spanning cell is in the first
                         // row, split up the space evenly.  (XXX This
                         // isn't quite right if some of the columns it's
                         // in have specified widths.  Should we care?)
+                        // XXXldb This doesn't consider columns with no
+                        // cells originating.
                         cellWidth = ((cellWidth + spacing) / colSpan) - spacing;
                     }
                     result += cellWidth;
                 } else if (styleWidth->GetUnit() == eStyleUnit_Percent) {
                     if (colSpan > 1) {
                         // XXX Can this force columns to negative
                         // widths?
                         result -= spacing * (colSpan - 1);
                     }
                 }
                 // else, for 'auto', '-moz-available', and '-moz-fit-content'
                 // do nothing
+                // XXXldb Bug 364989
             }
         }
     }
 
     return (mMinWidth = result);
 }
 
 /* virtual */ nscoord
diff --git a/layout/tables/nsTableFrame.cpp b/layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp
+++ b/layout/tables/nsTableFrame.cpp
@@ -343,16 +343,17 @@ nsTableFrame::SetInitialChildList(nsIAto
       if (mColGroups.IsEmpty())
         mColGroups.SetFrames(childFrame);
       else
         prevColGroupChild->SetNextSibling(childFrame);
       prevColGroupChild = childFrame;
     }
     else
     { // unknown frames go on the main list for now
+      NS_NOTREACHED("yikes, unknown frame type");
       if (mFrames.IsEmpty())
         mFrames.SetFrames(childFrame);
       else
         prevMainChild->SetNextSibling(childFrame);
       prevMainChild = childFrame;
     }
     nsIFrame *prevChild = childFrame;
     childFrame = childFrame->GetNextSibling();
diff --git a/layout/xul/base/src/nsBoxFrame.cpp b/layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp
+++ b/layout/xul/base/src/nsBoxFrame.cpp
@@ -540,16 +540,17 @@ nsBoxFrame::GetInitialDirection(PRBool& 
 
   // Now check the style system to see if we should invert aIsNormal.
   const nsStyleXUL* boxInfo = GetStyleXUL();
   if (boxInfo->mBoxDirection == NS_STYLE_BOX_DIRECTION_REVERSE)
     aIsNormal = !aIsNormal; // Invert our direction.
   
   // Now see if we have an attribute.  The attribute overrides
   // the style system value.
+  // XXXldb This makes two reverses go back to normal!
   static nsIContent::AttrValuesArray strings[] =
     {&nsGkAtoms::reverse, &nsGkAtoms::ltr, &nsGkAtoms::rtl, nsnull};
   PRInt32 index = GetContent()->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::dir,
       strings, eCaseMatters);
   if (index >= 0) {
     PRPackedBool values[] = {!aIsNormal, PR_TRUE, PR_FALSE};
     aIsNormal = values[index];
   }
@@ -1844,20 +1845,21 @@ nsBoxFrame::CreateViewForFrame(nsPresCon
       nsIView *view = viewManager->CreateView(aFrame->GetRect(), parentView, visibility);
       if (view) {
         // Insert the view into the view hierarchy. If the parent view is a
         // scrolling view we need to do this differently
         nsIScrollableView*  scrollingView = parentView->ToScrollableView();
         if (scrollingView) {
           scrollingView->SetScrolledView(view);
         } else {
-          viewManager->SetViewZIndex(view, autoZIndex, zIndex);
           // XXX put view last in document order until we can do better
           viewManager->InsertChild(parentView, view, nsnull, PR_TRUE);
         }
+        nsContainerFrame::SyncFrameViewProperties(aPresContext, aFrame,
+                                                  nsnull, view);
       }
 
       // Remember our view
       aFrame->SetView(view);
 
       NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
         ("nsBoxFrame::CreateViewForFrame: frame=%p view=%p",
          aFrame));
diff --git a/layout/xul/base/src/nsDeckFrame.cpp b/layout/xul/base/src/nsDeckFrame.cpp
--- a/layout/xul/base/src/nsDeckFrame.cpp
+++ b/layout/xul/base/src/nsDeckFrame.cpp
@@ -110,28 +110,34 @@ nsDeckFrame::Init(nsIContent*     aConte
 void
 nsDeckFrame::HideBox(nsPresContext* aPresContext, nsIBox* aBox)
 {
   nsIView* view = aBox->GetView();
 
   if (view) {
     nsIViewManager* viewManager = view->GetViewManager();
     viewManager->SetViewVisibility(view, nsViewVisibility_kHide);
+    // XXX This can go away when our notion of view visibility applies
+    // better to descendant views. (i.e., more callers use IsVisible
+    // rather than GetVisibility).
     viewManager->ResizeView(view, nsRect(0, 0, 0, 0));
   }
 }
 
 void
 nsDeckFrame::ShowBox(nsPresContext* aPresContext, nsIBox* aBox)
 {
   nsRect rect = aBox->GetRect();
   nsIView* view = aBox->GetView();
   if (view) {
     nsIViewManager* viewManager = view->GetViewManager();
     rect.x = rect.y = 0;
+    // XXX This can go away when our notion of view visibility applies
+    // better to descendant views. (i.e., more callers use IsVisible
+    // rather than GetVisibility).
     viewManager->ResizeView(view, rect);
     viewManager->SetViewVisibility(view, nsViewVisibility_kShow);
   }
 }
 
 void
 nsDeckFrame::IndexChanged(nsPresContext* aPresContext)
 {
diff --git a/layout/xul/base/src/nsSprocketLayout.cpp b/layout/xul/base/src/nsSprocketLayout.cpp
--- a/layout/xul/base/src/nsSprocketLayout.cpp
+++ b/layout/xul/base/src/nsSprocketLayout.cpp
@@ -246,19 +246,17 @@ nsSprocketLayout::Layout(nsIBox* aBox, n
   nscoord min = 0;
   nscoord max = 0;
   PRInt32 flexes = 0;
   PopulateBoxSizes(aBox, aState, boxSizes, computedBoxSizes, min, max, flexes);
   
   // The |size| variable will hold the total size of children along the axis of
   // the box.  Continuing with the example begun in the comment above, size would
   // be 150 pixels.
-  nscoord size = clientRect.width;
-  if (!IsHorizontal(aBox))
-    size = clientRect.height;
+  nscoord size = IsHorizontal(aBox) ? clientRect.width : clientRect.height;
   ComputeChildSizes(aBox, aState, size, boxSizes, computedBoxSizes);
 
   // After the call to ComputeChildSizes, the |size| variable contains the
   // total required size of all the children.  We adjust our clientRect in the
   // appropriate dimension to match this size.  In our example, we now assign
   // 150 pixels into the clientRect.width.
   //
   // The variables |min| and |max| hold the minimum required size box must be 
diff --git a/modules/plugin/base/public/nsIPluginInstanceInternal.h b/modules/plugin/base/public/nsIPluginInstanceInternal.h
--- a/modules/plugin/base/public/nsIPluginInstanceInternal.h
+++ b/modules/plugin/base/public/nsIPluginInstanceInternal.h
@@ -48,16 +48,18 @@ struct JSContext;
   {0x1a9c2ae8, 0xab75, 0x4296, \
     { 0xaf, 0xcb, 0x39, 0x54, 0x39, 0x96, 0x06, 0xa9 }}
 
 class NS_NO_VTABLE nsIPluginInstanceInternal : public nsISupports
 {
 public: 
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IPLUGININSTANCEINTERNAL_IID)
 
+  // The caller needs to root this object before making most JS API
+  // calls.
   virtual JSObject *GetJSObject(JSContext *cx) = 0;
 
   virtual nsresult GetFormValue(nsAString& aValue) = 0;
 
   virtual void PushPopupsEnabledState(PRBool aEnabled) = 0;
   virtual void PopPopupsEnabledState() = 0;
 
   virtual PRUint16 GetPluginAPIVersion() = 0;
diff --git a/modules/plugin/base/src/nsNPAPIPlugin.cpp b/modules/plugin/base/src/nsNPAPIPlugin.cpp
--- a/modules/plugin/base/src/nsNPAPIPlugin.cpp
+++ b/modules/plugin/base/src/nsNPAPIPlugin.cpp
@@ -2140,29 +2140,34 @@ _setvalue(NPP npp, NPPVariable variable,
           do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
         if (NS_SUCCEEDED(rv)) {
           NPBool bPushCaller = (result != nsnull);
 
           if (bPushCaller) {
             rv = NS_ERROR_FAILURE;
 
             nsCOMPtr<nsIPluginInstancePeer> peer;
+            // XXXldb Shouldn't this return failure if peer is null
+            // (i.e., just skip the null-check)?
             if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
               nsCOMPtr<nsIPluginInstancePeer2> peer2 =
                 do_QueryInterface(peer);
 
               if (peer2) {
                 JSContext *cx;
                 rv = peer2->GetJSContext(&cx);
 
                 if (NS_SUCCEEDED(rv))
+                  // XXXldb Should assert that every push a plugin does
+                  // is matched by a pop.
                   rv = contextStack->Push(cx);
               }
             }
           } else {
+            // XXXldb Should assert that it's the right context!
             rv = contextStack->Pop(nsnull);
           }
         }
         return NS_SUCCEEDED(rv) ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
       }
 
     case NPPVpluginKeepLibraryInMemory: {
       NPBool bCached = (result != nsnull);
diff --git a/netwerk/base/src/nsProtocolProxyService.h b/netwerk/base/src/nsProtocolProxyService.h
--- a/netwerk/base/src/nsProtocolProxyService.h
+++ b/netwerk/base/src/nsProtocolProxyService.h
@@ -314,16 +314,18 @@ protected:
         eProxyConfig_PAC,
         eProxyConfig_Direct4x,
         eProxyConfig_WPAD,
         eProxyConfig_System, // use system proxy settings if available, otherwise DIRECT
         eProxyConfig_Last
     };
 
     // simplified array of filters defined by this struct
+    struct HostInfo;
+    friend struct HostInfo;
     struct HostInfo {
         PRBool  is_ipaddr;
         PRInt32 port;
         union {
             HostInfoIP   ip;
             HostInfoName name;
         };
 
diff --git a/netwerk/dns/src/nsDNSService2.cpp b/netwerk/dns/src/nsDNSService2.cpp
--- a/netwerk/dns/src/nsDNSService2.cpp
+++ b/netwerk/dns/src/nsDNSService2.cpp
@@ -213,17 +213,20 @@ public:
                       const nsACString &host,
                       nsIDNSListener   *listener,
                       PRUint16          flags,
                       PRUint16          af)
         : mResolver(res)
         , mHost(host)
         , mListener(listener)
         , mFlags(flags)
-        , mAF(af) {}
+        , mAF(af)
+    {
+        //printf("Looking up \"%s\".\n", PromiseFlatCString(host).get());
+    }
     ~nsDNSAsyncRequest() {}
 
     void OnLookupComplete(nsHostResolver *, nsHostRecord *, nsresult);
 
     nsRefPtr<nsHostResolver> mResolver;
     nsCString                mHost; // hostname we're resolving
     nsCOMPtr<nsIDNSListener> mListener;
     PRUint16                 mFlags;
diff --git a/netwerk/dns/src/nsIDNService.cpp b/netwerk/dns/src/nsIDNService.cpp
--- a/netwerk/dns/src/nsIDNService.cpp
+++ b/netwerk/dns/src/nsIDNService.cpp
@@ -113,17 +113,17 @@ void nsIDNService::prefsChanged(nsIPrefB
     PRBool val;
     if (NS_SUCCEEDED(prefBranch->GetBoolPref(NS_NET_PREF_IDNTESTBED, &val)))
       mMultilingualTestBed = val;
   }
   if (!pref || NS_LITERAL_STRING(NS_NET_PREF_IDNPREFIX).Equals(pref)) {
     nsXPIDLCString prefix;
     nsresult rv = prefBranch->GetCharPref(NS_NET_PREF_IDNPREFIX, getter_Copies(prefix));
     if (NS_SUCCEEDED(rv) && prefix.Length() <= kACEPrefixLen)
-      PL_strncpyz(nsIDNService::mACEPrefix, prefix.get(), kACEPrefixLen + 1);
+      PL_strncpyz(mACEPrefix, prefix.get(), sizeof(mACEPrefix));
   }
   if (!pref || NS_LITERAL_STRING(NS_NET_PREF_IDNBLACKLIST).Equals(pref)) {
     nsCOMPtr<nsISupportsString> blacklist;
     nsresult rv = prefBranch->GetComplexValue(NS_NET_PREF_IDNBLACKLIST,
                                               NS_GET_IID(nsISupportsString),
                                               getter_AddRefs(blacklist));
     if (NS_SUCCEEDED(rv))
       blacklist->ToString(getter_Copies(mIDNBlacklist));
@@ -137,16 +137,17 @@ void nsIDNService::prefsChanged(nsIPrefB
   }
 }
 
 nsIDNService::nsIDNService()
 {
   // initialize to the official prefix (RFC 3490 "5. ACE prefix")
   const char kIDNSPrefix[] = "xn--";
   strcpy(mACEPrefix, kIDNSPrefix);
+  NS_ASSERTION(sizeof(mACEPrefix) >= sizeof(kIDNSPrefix), "bad strcpy");
 
   mMultilingualTestBed = PR_FALSE;
 
   if (idn_success != idn_nameprep_create(NULL, &mNamePrepHandle))
     mNamePrepHandle = nsnull;
 
   mNormalizer = do_GetService(NS_UNICODE_NORMALIZER_CONTRACTID);
   /* member initializers and constructor code */
@@ -527,19 +528,19 @@ nsresult nsIDNService::stringPrep(const 
   NS_ENSURE_TRUE(idn_err == idn_success, NS_ERROR_FAILURE);
 
   nsAutoString namePrepStr;
   ucs4toUtf16(namePrepBuf, namePrepStr);
   if (namePrepStr.Length() >= kMaxDNSNodeLen)
     return NS_ERROR_FAILURE;
 
   // normalize
-  nsAutoString normlizedStr;
-  rv = mNormalizer->NormalizeUnicodeNFKC(namePrepStr, normlizedStr);
-  if (normlizedStr.Length() >= kMaxDNSNodeLen)
+  nsAutoString normalizedStr;
+  rv = mNormalizer->NormalizeUnicodeNFKC(namePrepStr, normalizedStr);
+  if (normalizedStr.Length() >= kMaxDNSNodeLen)
     return NS_ERROR_FAILURE;
 
   // prohibit
   const PRUint32 *found = nsnull;
   idn_err = idn_nameprep_isprohibited(mNamePrepHandle, 
                                       (const PRUint32 *) ucs4Buf, &found);
   if (idn_err != idn_success || found)
     return NS_ERROR_FAILURE;
@@ -554,17 +555,17 @@ nsresult nsIDNService::stringPrep(const 
     // check unassigned code points
     idn_err = idn_nameprep_isunassigned(mNamePrepHandle,
                                         (const PRUint32 *) ucs4Buf, &found);
     if (idn_err != idn_success || found)
       return NS_ERROR_FAILURE;
   }
 
   // set the result string
-  out.Assign(normlizedStr);
+  out.Assign(normalizedStr);
 
   return rv;
 }
 
 nsresult nsIDNService::encodeToACE(const nsAString& in, nsACString& out)
 {
   // RACE encode is supported for existing testing environment
   if (!strcmp("bq--", mACEPrefix))
diff --git a/tools/jprof/stub/libmalloc.cpp b/tools/jprof/stub/libmalloc.cpp
--- a/tools/jprof/stub/libmalloc.cpp
+++ b/tools/jprof/stub/libmalloc.cpp
@@ -81,17 +81,78 @@ static int gLogFD = -1;
 static pthread_t main_thread;
 
 static void startSignalCounter(unsigned long millisec);
 static int enableRTCSignals(bool enable);
 
 
 //----------------------------------------------------------------------
 
-#if defined(i386) || defined(_i386) || defined(__x86_64__)
+//#if __GNUC__ >= 3
+#if 0
+
+#include <unwind.h>
+
+struct CrawlStackClosure {
+  malloc_log_entry *me;
+  void *stack_top;
+  void *top_instr_ptr;
+};
+
+extern "C" {
+static _Unwind_Reason_Code CrawlStackCallback(struct _Unwind_Context *cx, void *c);
+}
+
+/* static */ _Unwind_Reason_Code
+CrawlStackCallback(struct _Unwind_Context *cx, void *c)
+{
+  CrawlStackClosure *closure = (CrawlStackClosure*)c;
+  malloc_log_entry *me = closure->me;
+  if (me->numpcs >= MAX_STACK_CRAWL) {
+    printf("too many frames\n");
+    return _URC_END_OF_STACK;
+  }
+
+  void *sp = (void*)_Unwind_GetCFA(cx);
+  if (sp < closure->stack_top) {
+    printf("still in signal handling %p %p\n", sp, closure->stack_top);
+    // Still in the signal handling code.
+#if 0
+    // The unwind code doesn't know how to cross the signal handler, so
+    // we'll try to help it.
+    _Unwind_SetGR(cx, __builtin_dwarf_sp_column(),
+                  (_Unwind_Word) closure->stack_top);
+    _Unwind_SetIP(cx, (_Unwind_Ptr) closure->top_instr_ptr);
+#endif
+    return _URC_NO_REASON;
+  }
+
+  void *ip = (void*)_Unwind_GetIP(cx);
+  me->pcs[me->numpcs++] = (char*) ip;
+  printf("recording frame\n");
+
+  return _URC_NO_REASON;
+}
+
+static void CrawlStack(malloc_log_entry* me,
+                       void* stack_top, void* top_instr_ptr)
+{
+  CrawlStackClosure closure;
+  closure.me = me;
+  closure.stack_top = stack_top;
+  closure.top_instr_ptr = top_instr_ptr;
+  me->numpcs = 0;
+
+  me->pcs[me->numpcs++] = (char*) top_instr_ptr;
+
+  _Unwind_Backtrace(CrawlStackCallback, &closure);
+}
+
+#elif defined(i386) || defined(_i386) || defined(__x86_64__)
+
 static void CrawlStack(malloc_log_entry* me,
                        void* stack_top, void* top_instr_ptr)
 {
   void **bp;
 #if defined(__i386)
   __asm__( "movl %%ebp, %0" : "=g"(bp));
 #elif defined(__x86_64__)
   __asm__( "movq %%rbp, %0" : "=g"(bp));
diff --git a/widget/src/gtk2/nsWindow.cpp b/widget/src/gtk2/nsWindow.cpp
--- a/widget/src/gtk2/nsWindow.cpp
+++ b/widget/src/gtk2/nsWindow.cpp
@@ -1636,16 +1636,17 @@ nsWindow::Invalidate(const nsIntRect &aR
 
 NS_IMETHODIMP
 nsWindow::Update()
 {
     if (!mDrawingarea)
         return NS_OK;
 
     gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
+    // XSync(GDK_DISPLAY(), False);
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::Scroll(PRInt32     aDx,
                  PRInt32     aDy,
                  nsIntRect  *aClipRect)
 {
@@ -4215,16 +4216,20 @@ void
 nsWindow::EnsureGrabs(void)
 {
     if (mRetryPointerGrab)
         GrabPointer();
     if (mRetryKeyboardGrab)
         GrabKeyboard();
 }
 
+// Once people are reliably running compositing window managers, we
+// could get 8-bit alpha by using gdk_screen_get_rgba_visual.
+// See http://mail.gnome.org/archives/gtk-app-devel-list/2005-September/msg00124.html
+
 void
 nsWindow::SetTransparencyMode(nsTransparencyMode aMode)
 {
     if (!mShell) {
         // Pass the request to the toplevel window
         GtkWidget *topWidget = nsnull;
         GetToplevelWidget(&topWidget);
         if (!topWidget)
@@ -6352,16 +6357,17 @@ nsWindow*
 nsWindow::IMEComposingWindow(void)
 {
     return mIMEData ? mIMEData->mComposingWindow : nsnull;
 }
 
 void
 nsWindow::IMECreateContext(void)
 {
+    NS_ASSERTION(!mIMEData, "already have IME data");
     mIMEData = new nsIMEData(this);
     if (!mIMEData)
         return;
 
     mIMEData->mContext = gtk_im_multicontext_new();
     mIMEData->mSimpleContext = gtk_im_context_simple_new();
     mIMEData->mDummyContext = gtk_im_multicontext_new();
     if (!mIMEData->mContext || !mIMEData->mSimpleContext ||
@@ -6373,16 +6379,17 @@ nsWindow::IMECreateContext(void)
 
     gtk_im_context_set_client_window(mIMEData->mContext,
                                      GTK_WIDGET(mContainer)->window);
     gtk_im_context_set_client_window(mIMEData->mSimpleContext,
                                      GTK_WIDGET(mContainer)->window);
     gtk_im_context_set_client_window(mIMEData->mDummyContext,
                                      GTK_WIDGET(mContainer)->window);
 
+    // XXX Should we remove these signals before releasing the context?
     g_signal_connect(G_OBJECT(mIMEData->mContext), "preedit_changed",
                      G_CALLBACK(IM_preedit_changed_cb), this);
     g_signal_connect(G_OBJECT(mIMEData->mContext), "commit",
                      G_CALLBACK(IM_commit_cb), this);
     g_signal_connect(G_OBJECT(mIMEData->mSimpleContext), "preedit_changed",
                      G_CALLBACK(IM_preedit_changed_cb), this);
     g_signal_connect(G_OBJECT(mIMEData->mSimpleContext), "commit",
                      G_CALLBACK(IM_commit_cb), this);
diff --git a/widget/src/gtk2/nsWindow.h b/widget/src/gtk2/nsWindow.h
--- a/widget/src/gtk2/nsWindow.h
+++ b/widget/src/gtk2/nsWindow.h
@@ -352,16 +352,17 @@ public:
     /*
      *  |mIMEData| has all IME data for the window and its children widgets.
      *  Only stand-alone windows and child windows embedded in non-Mozilla GTK
      *  containers own IME contexts.
      *  But this is referred from all children after the widget gets focus.
      *  The children refers to its owning window's object.
      */
     struct nsIMEData {
+        // XXX Should this be refcounted?  I've seen it be a dangling pointer.
         // Actual context. This is used for handling the user's input.
         GtkIMContext       *mContext;
         // mSimpleContext is used for the password field and
         // the |ime-mode: disabled;| editors. These editors disable IME.
         // But dead keys should work. Fortunately, the simple IM context of
         // GTK2 support only them.
         GtkIMContext       *mSimpleContext;
         // mDummyContext is a dummy context and will be used in IMESetFocus()
diff --git a/xpcom/base/nsIWeakReference.idl b/xpcom/base/nsIWeakReference.idl
--- a/xpcom/base/nsIWeakReference.idl
+++ b/xpcom/base/nsIWeakReference.idl
@@ -44,16 +44,25 @@
  * An instance of |nsIWeakReference| is a proxy object that cooperates with
  * its referent to give clients a non-owning, non-dangling reference.  Clients
  * own the proxy, and should generally manage it with an |nsCOMPtr| (see the
  * type |nsWeakPtr| for a |typedef| name that stands out) as they would any
  * other XPCOM object.  The |QueryReferent| member function provides a
  * (hopefully short-lived) owning reference on demand, through which clients
  * can get useful access to the referent, while it still exists.
  *
+ * Thus this interface provides the following contract:  The result of
+ * calling QueryReferent on a given implementation of this interface
+ * with a given IID may change over time, but not more than twice:  it
+ * may change once from null to non-null (to account for aggregation)
+ * and it may change once from non-null to null.  This means that if
+ * a QueryReferent for an IID that once returned non-null (or was
+ * guaranteed by GetWeakReference to return non-null) at some time
+ * returns null, it will never again return non-null.
+ *
  * @status FROZEN
  * @version 1.0
  * @see nsISupportsWeakReference
  * @see nsWeakReference
  * @see nsWeakPtr
  */
 [scriptable, uuid(9188bc85-f92e-11d2-81ef-0060083a0bcf)]
 interface nsIWeakReference : nsISupports
@@ -81,16 +90,22 @@ interface nsIWeakReference : nsISupports
 [scriptable, uuid(9188bc86-f92e-11d2-81ef-0060083a0bcf)]
 interface nsISupportsWeakReference : nsISupports
   {
     /**
      * |GetWeakReference| produces an appropriate instance of |nsIWeakReference|.
      * As with all good XPCOM `getters', you own the resulting interface and should
      * manage it with an |nsCOMPtr|.
      *
+     * If this call is successful, the weak reference returned is (while
+     * the nsISupportsWeakReference object is held) guaranteed to return
+     * non-null for a QueryReferent to any interface that the
+     * nsISupportsWeakReference implementation is known to
+     * QueryInterface to.
+     *
      * @see nsIWeakReference
      * @see nsWeakPtr
      * @see nsCOMPtr
      */
     nsIWeakReference GetWeakReference();
   };
 
 
diff --git a/xpcom/components/nsComponentManager.cpp b/xpcom/components/nsComponentManager.cpp
--- a/xpcom/components/nsComponentManager.cpp
+++ b/xpcom/components/nsComponentManager.cpp
@@ -2472,17 +2472,19 @@ nsComponentManagerImpl::RegisterFactory(
                                                         (PL_DHashTableOperate(&mFactories,
                                                                                  &aClass,
                                                                                  PL_DHASH_ADD));
 
     if (!factoryTableEntry)
         return NS_ERROR_OUT_OF_MEMORY;
 
 
+    // XXX This is guaranteed to be true.
     if (PL_DHASH_ENTRY_IS_BUSY(factoryTableEntry)) {
+        // XXX I don't think entry is guaranteed to be null.
         entry = factoryTableEntry->mFactoryEntry;
     }
 
     if (entry && !aReplace)
     {
         // Already registered
         PR_LOG(nsComponentManagerLog, PR_LOG_ERROR,
                ("\t\tFactory already registered."));
@@ -3397,16 +3399,19 @@ nsComponentManagerImpl::AutoUnregister(n
 }
 
 NS_IMETHODIMP
 nsComponentManagerImpl::RegisterFactory(const nsCID & aClass,
                                         const char *aClassName,
                                         const char *aContractID,
                                         nsIFactory *aFactory)
 {
+    // XXX We really don't want to create a new factory entry for each
+    // CID/ContractID pair, since the same CID could be repeated and that's
+    // OK.  And it's really bad when they're services.
     return RegisterFactory(aClass,
                            aClassName,
                            aContractID,
                            aFactory,
                            PR_TRUE);
 }
 
 NS_IMETHODIMP
diff --git a/xpcom/io/nsEscape.cpp b/xpcom/io/nsEscape.cpp
--- a/xpcom/io/nsEscape.cpp
+++ b/xpcom/io/nsEscape.cpp
@@ -455,16 +455,17 @@ NS_COM PRBool NS_EscapeURL(const char *p
         }
         tempBuffer[tempBufferPos++] = HEX_ESCAPE;
         tempBuffer[tempBufferPos++] = hexChars[c >> 4];	/* high nibble */
         tempBuffer[tempBufferPos++] = hexChars[c & 0x0f]; /* low nibble */
       }
 
       if (tempBufferPos >= sizeof(tempBuffer) - 4)
       {
+        // XXXldb Why is this guaranteed not to fire?
         NS_ASSERTION(writing, "should be writing");
         tempBuffer[tempBufferPos] = '\0';
         result += tempBuffer;
         tempBufferPos = 0;
       }
 
       previousIsNonASCII = (c > 0x7f);
     }
diff --git a/xpcom/io/nsLocalFileWin.cpp b/xpcom/io/nsLocalFileWin.cpp
--- a/xpcom/io/nsLocalFileWin.cpp
+++ b/xpcom/io/nsLocalFileWin.cpp
@@ -2320,17 +2320,17 @@ nsLocalFile::IsExecutable(PRBool *_retva
     nsAutoString path;
     if (symLink)
         GetTarget(path);
     else
         GetPath(path);
 
     // kill trailing dots and spaces.
     PRInt32 filePathLen = path.Length() - 1;
-    while(filePathLen > 0 && (path[filePathLen] == L' ' || path[filePathLen] == L'.'))
+    while(filePathLen >= 0 && (path[filePathLen] == L' ' || path[filePathLen] == L'.'))
     {
         path.Truncate(filePathLen--);
     } 
 
     // Get extension.
     PRInt32 dotIdx = path.RFindChar(PRUnichar('.'));
     if ( dotIdx != kNotFound ) {
         // Convert extension to lower case.
diff --git a/xpcom/tests/TestCallTemplates.cpp b/xpcom/tests/TestCallTemplates.cpp
--- a/xpcom/tests/TestCallTemplates.cpp
+++ b/xpcom/tests/TestCallTemplates.cpp
@@ -73,18 +73,47 @@ class nsTestService : public nsITestServ
 NS_IMPL_ISUPPORTS2(nsTestService, nsITestService, nsISupportsWeakReference)
 
 #define NS_TEST_SERVICE_CONTRACTID "@mozilla.org/test/testservice;1"
 #define NS_TEST_SERVICE_CID \
   {0xa00c1406, 0x283a, 0x45c9, \
     {0xae, 0xd2, 0x1a, 0xb6, 0xdd, 0xba, 0xfe, 0x53}}
 static NS_DEFINE_CID(kTestServiceCID, NS_TEST_SERVICE_CID);
 
+#include "nsString.h"
+
 int main()
 {
+    nsCAutoString str;
+    str.AppendFloat(1.0/3.0);
+    str.Append(" ");
+    str.AppendFloat(2.0/3.0);
+    str.Append(" ");
+    str.AppendFloat(1.0/7.0);
+    str.Append(" ");
+    str.AppendFloat(-0.0);
+    str.Append(" ");
+    str.AppendFloat(-1073741824.0);
+    str.Append(" ");
+    str.AppendFloat(1073741824.0);
+    str.Append(" ");
+    str.AppendFloat(1024.0);
+    str.Append(" ");
+    str.AppendFloat(-1024.0);
+    printf("%s\n", str.get());
+
+#if 0
+    nsAutoString foo;
+    foo.AssignWithConversion("aosneuthasoenuhctsa oceuhsa oceush aoeu");
+    for (int i = 0; i < 10000000; ++i) {
+        NS_ConvertUCS2toUTF8 bar(foo.get());
+    }
+#endif
+
+#if 0
     /*
      * NOTE:  This does NOT demonstrate how these functions are
      * intended to be used.  They are intended for filling in out
      * parameters that need to be |AddRef|ed.  I'm just too lazy
      * to write lots of little getter functions for a test program
      * when I don't need to.
      */
 
@@ -119,11 +148,12 @@ int main()
     /* Test CallGetService */
     CallGetService(kTestServiceCID, &myITestService);
     CallGetService(NS_TEST_SERVICE_CONTRACTID, &myITestService);
 
     /* Test CallGetInterface */
     nsIInterfaceRequestor *myInterfaceRequestor =
         static_cast<nsIInterfaceRequestor*>(mySupportsPtr);
     CallGetInterface(myInterfaceRequestor, &myITestService);
+#endif
 
     return 0;
 }
diff --git a/xpfe/browser/src/nsBrowserStatusFilter.cpp b/xpfe/browser/src/nsBrowserStatusFilter.cpp
--- a/xpfe/browser/src/nsBrowserStatusFilter.cpp
+++ b/xpfe/browser/src/nsBrowserStatusFilter.cpp
@@ -90,16 +90,17 @@ nsBrowserStatusFilter::AddProgressListen
 {
     mListener = aListener;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsBrowserStatusFilter::RemoveProgressListener(nsIWebProgressListener *aListener)
 {
+    NS_ASSERTION(aListener == mListener, "listener mismatch");
     if (aListener == mListener)
         mListener = nsnull;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsBrowserStatusFilter::GetDOMWindow(nsIDOMWindow **aResult)
 {
