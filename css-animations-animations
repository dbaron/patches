From: L. David Baron <dbaron@dbaron.org>

Implement animation of css3-animations.  (Bug 435442, patch 11)

diff --git a/content/base/src/nsGenericElement.cpp b/content/base/src/nsGenericElement.cpp
--- a/content/base/src/nsGenericElement.cpp
+++ b/content/base/src/nsGenericElement.cpp
@@ -3063,16 +3063,19 @@ nsGenericElement::UnbindFromTree(PRBool 
   // Ensure that CSS transitions don't continue on an element at a
   // different place in the tree (even if reinserted before next
   // animation refresh).
   // FIXME (Bug 522599): Need a test for this.
   if (HasFlag(NODE_HAS_PROPERTIES)) {
     DeleteProperty(nsGkAtoms::transitionsOfBeforeProperty);
     DeleteProperty(nsGkAtoms::transitionsOfAfterProperty);
     DeleteProperty(nsGkAtoms::transitionsProperty);
+    DeleteProperty(nsGkAtoms::animationsOfBeforeProperty);
+    DeleteProperty(nsGkAtoms::animationsOfAfterProperty);
+    DeleteProperty(nsGkAtoms::animationsProperty);
   }
 
   // Unset this since that's what the old code effectively did.
   UnsetFlags(NODE_FORCE_XBL_BINDINGS);
   
 #ifdef MOZ_XUL
   nsXULElement* xulElem = nsXULElement::FromContent(this);
   if (xulElem) {
diff --git a/content/base/src/nsGkAtomList.h b/content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h
+++ b/content/base/src/nsGkAtomList.h
@@ -1825,16 +1825,19 @@ GK_ATOM(ended, "ended")
 GK_ATOM(canplay, "canplay")
 GK_ATOM(canplaythrough, "canplaythrough")
 GK_ATOM(ratechange, "ratechange")
 GK_ATOM(durationchange, "durationchange")
 GK_ATOM(volumechange, "volumechange")
 #endif
 
 // Content property names
+GK_ATOM(animationsProperty, "AnimationsProperty")        // FrameAnimations*
+GK_ATOM(animationsOfBeforeProperty, "AnimationsOfBeforeProperty") // FrameAnimations*
+GK_ATOM(animationsOfAfterProperty, "AnimationsOfAfterProperty") // FrameAnimations*
 GK_ATOM(transitionsProperty, "TransitionsProperty")        // FrameTransitions*
 GK_ATOM(transitionsOfBeforeProperty, "TransitionsOfBeforeProperty") // FrameTransitions*
 GK_ATOM(transitionsOfAfterProperty, "TransitionsOfAfterProperty") // FrameTransitions*
 GK_ATOM(genConInitializerProperty, "QuoteNodeProperty")
 GK_ATOM(labelMouseDownPtProperty, "LabelMouseDownPtProperty")
 
 // Languages for lang-specific transforms
 GK_ATOM(Japanese, "ja")
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -90,16 +90,17 @@
 #include "nsIEventListenerManager.h"
 #include "nsStyleStructInlines.h"
 #include "nsIAppShell.h"
 #include "prenv.h"
 #include "nsIPrivateDOMEvent.h"
 #include "nsIDOMEventTarget.h"
 #include "nsObjectFrame.h"
 #include "nsTransitionManager.h"
+#include "nsAnimationManager.h"
 #include "mozilla/dom/Element.h"
 #include "nsIFrameMessageManager.h"
 
 #ifdef MOZ_SMIL
 #include "nsSMILAnimationController.h"
 #endif // MOZ_SMIL
 
 #ifdef IBMBIDI
@@ -892,16 +893,20 @@ nsPresContext::Init(nsIDeviceContext* aD
     return NS_ERROR_OUT_OF_MEMORY;
 
   NS_ADDREF(mEventManager);
 
   mTransitionManager = new nsTransitionManager(this);
   if (!mTransitionManager)
     return NS_ERROR_OUT_OF_MEMORY;
 
+  mAnimationManager = new nsAnimationManager(this);
+  if (!mAnimationManager)
+    return NS_ERROR_OUT_OF_MEMORY;
+
   if (mDocument->GetDisplayDocument()) {
     NS_ASSERTION(mDocument->GetDisplayDocument()->GetShell() &&
                  mDocument->GetDisplayDocument()->GetShell()->GetPresContext(),
                  "Why are we being initialized?");
     mRefreshDriver = mDocument->GetDisplayDocument()->GetShell()->
       GetPresContext()->RefreshDriver();
   } else {
     nsIDocument* parent = mDocument->GetParentDocument();
@@ -1054,16 +1059,20 @@ nsPresContext::SetShell(nsIPresShell* aS
       mImageLoaders[i].Enumerate(destroy_loads, nsnull);
       mImageLoaders[i].Clear();
     }
 
     if (mTransitionManager) {
       mTransitionManager->Disconnect();
       mTransitionManager = nsnull;
     }
+    if (mAnimationManager) {
+      mAnimationManager->Disconnect();
+      mAnimationManager = nsnull;
+    }
   }
 }
 
 void
 nsPresContext::UpdateCharSet(const nsAFlatCString& aCharSet)
 {
   if (mLangService) {
     NS_IF_RELEASE(mLanguage);
@@ -1613,16 +1622,17 @@ void
 nsPresContext::RebuildAllStyleData(nsChangeHint aExtraHint)
 {
   if (!mShell) {
     // We must have been torn down. Nothing to do here.
     return;
   }
 
   RebuildUserFontSet();
+  AnimationManager()->KeyframesListIsDirty();
 
   mShell->FrameConstructor()->RebuildAllStyleData(aExtraHint);
 }
 
 void
 nsPresContext::PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint)
 {
   if (!mShell) {
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -97,16 +97,17 @@ class nsIAtom;
 struct nsStyleBackground;
 struct nsStyleBorder;
 class nsIRunnable;
 class gfxUserFontSet;
 class nsUserFontSet;
 struct nsFontFaceRuleContainer;
 class nsObjectFrame;
 class nsTransitionManager;
+class nsAnimationManager;
 class nsRefreshDriver;
 class imgIContainer;
 
 #ifdef MOZ_REFLOW_PERF
 class nsIRenderingContext;
 #endif
 
 enum nsWidgetType {
@@ -233,16 +234,17 @@ public:
 
 #ifdef _IMPL_NS_LAYOUT
   nsStyleSet* StyleSet() { return GetPresShell()->StyleSet(); }
 
   nsFrameManager* FrameManager()
     { return GetPresShell()->FrameManager(); } 
 
   nsTransitionManager* TransitionManager() { return mTransitionManager; }
+  nsAnimationManager* AnimationManager() { return mAnimationManager; }
 
   nsRefreshDriver* RefreshDriver() { return mRefreshDriver; }
 #endif
 
   /**
    * Rebuilds all style data by throwing out the old rule tree and
    * building a new one, and additionally applying aExtraHint (which
    * must not contain nsChangeHint_ReconstructFrame) to the root frame.
@@ -1058,16 +1060,17 @@ protected:
                                         // better safe than sorry.
                                         // Cannot reintroduce cycles
                                         // since there is no dependency
                                         // from gfx back to layout.
   nsIEventStateManager* mEventManager;  // [STRONG]
   nsILookAndFeel*       mLookAndFeel;   // [STRONG]
   nsRefPtr<nsRefreshDriver> mRefreshDriver;
   nsRefPtr<nsTransitionManager> mTransitionManager;
+  nsRefPtr<nsAnimationManager> mAnimationManager;
   nsIAtom*              mMedium;        // initialized by subclass ctors;
                                         // weak pointer to static atom
 
   nsILinkHandler*       mLinkHandler;   // [WEAK]
 
   // Formerly mLangGroup; moving from charset-oriented langGroup to
   // maintaining actual language settings everywhere (see bug 524107).
   // This may in fact hold a langGroup such as x-western rather than
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -61,16 +61,17 @@
 #include "nsIContent.h"
 #include "mozilla/dom/Element.h"
 #include "nsIDocument.h"
 #include "nsIDOMXULDocument.h"
 #include "nsStubDocumentObserver.h"
 #include "nsStyleSet.h"
 #include "nsCSSStyleSheet.h" // XXX for UA sheet loading hack, can this go away please?
 #include "nsIDOMCSSStyleSheet.h"  // for Pref-related rule management (bugs 22963,20760,31816)
+#include "nsAnimationManager.h"
 #include "nsINameSpaceManager.h"  // for Pref-related rule management (bugs 22963,20760,31816)
 #include "nsIServiceManager.h"
 #include "nsFrame.h"
 #include "nsIViewManager.h"
 #include "nsCRT.h"
 #include "nsCRTGlue.h"
 #include "prlog.h"
 #include "prmem.h"
@@ -5098,16 +5099,17 @@ nsIPresShell::ReconstructStyleDataIntern
 
   if (mIsDestroying) {
     // We don't want to mess with restyles at this point
     return;
   }
 
   if (mPresContext) {
     mPresContext->RebuildUserFontSet();
+    mPresContext->AnimationManager()->KeyframesListIsDirty();
   }
 
   Element* root = mDocument->GetRootElement();
   if (!mDidInitialReflow) {
     // Nothing to do here, since we have no frames yet
     return;
   }
 
diff --git a/layout/style/Makefile.in b/layout/style/Makefile.in
--- a/layout/style/Makefile.in
+++ b/layout/style/Makefile.in
@@ -107,16 +107,17 @@ EXPORTS_mozilla/css = \
 
 CPPSRCS		= \
 		AnimationCommon.cpp \
 		nsCSSAnonBoxes.cpp \
 		nsCSSDataBlock.cpp \
 		Declaration.cpp \
 		nsCSSKeywords.cpp \
 		Loader.cpp \
+		nsAnimationManager.cpp \
 		nsCSSParser.cpp \
 		nsCSSProps.cpp \
 		nsCSSPseudoClasses.cpp \
 		nsCSSPseudoElements.cpp \
 		nsCSSRuleProcessor.cpp \
 		nsCSSRules.cpp \
 		nsCSSScanner.cpp \
 		nsCSSStyleSheet.cpp \
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
new file mode 100644
--- /dev/null
+++ b/layout/style/nsAnimationManager.cpp
@@ -0,0 +1,798 @@
+/* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsAnimationManager, an implementation of part
+ * of css3-animations.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsAnimationManager.h"
+#include "nsPresContext.h"
+#include "nsRuleProcessorData.h"
+#include "nsStyleSet.h"
+#include "nsCSSRules.h"
+#include "mozilla/TimeStamp.h"
+#include "nsStyleAnimation.h"
+#include "nsSMILKeySpline.h"
+
+using namespace mozilla;
+
+struct AnimationSegmentProperty
+{
+  nsCSSProperty mProperty;
+  nsStyleAnimation::Value mFromValue, mToValue;
+};
+
+struct AnimationSegment
+{
+  float mFromKey, mToKey;
+  css::ComputedTimingFunction mTimingFunction;
+  InfallibleTArray<AnimationSegmentProperty> mProperties;
+};
+
+/**
+ * Data about one animation (i.e., one of the values of
+ * 'animation-name') animation running on an element.
+ */
+struct ElementAnimation
+{
+  nsString mName; // empty string for 'none'
+  float mIterationCount; // NS_IEEEPositiveInfinity() means infinite
+  PRUint8 mDirection;
+  PRUint8 mFillMode;
+  PRUint8 mPlayState;
+
+  bool FillsForwards() const {
+    return mFillMode == NS_STYLE_ANIMATION_FILL_MODE_BOTH ||
+           mFillMode == NS_STYLE_ANIMATION_FILL_MODE_FORWARDS;
+  }
+  bool FillsBackwards() const {
+    return mFillMode == NS_STYLE_ANIMATION_FILL_MODE_BOTH ||
+           mFillMode == NS_STYLE_ANIMATION_FILL_MODE_BACKWARDS;
+  }
+
+  bool IsPaused() const {
+    return mPlayState == NS_STYLE_ANIMATION_PLAY_STATE_PAUSED;
+  }
+
+  TimeStamp mStartTime; // with delay taken into account
+  TimeStamp mPauseStart;
+  TimeDuration mIterationDuration;
+
+  InfallibleTArray<AnimationSegment> mSegments;
+};
+
+/**
+ * Data about all of the animations running on an element.
+ */
+struct ElementAnimations : public mozilla::css::CommonElementAnimationData
+{
+  ElementAnimations(dom::Element *aElement, nsIAtom *aElementProperty,
+                     nsAnimationManager *aAnimationManager)
+    : CommonElementAnimationData(aElement, aElementProperty,
+                                 aAnimationManager),
+      mNeedsRefreshes(true)
+  {
+  }
+
+  void EnsureStyleRuleFor(TimeStamp aRefreshTime);
+
+  void PostRestyleForAnimation(nsPresContext *aPresContext) {
+    nsRestyleHint hint =
+      (mElementProperty == nsGkAtoms::animationsProperty)
+        ? eRestyle_Self : eRestyle_Subtree;
+    aPresContext->PresShell()->RestyleForAnimation(mElement, hint);
+  }
+
+  // This style rule contains the style data for currently animating
+  // values.  It only matches when styling with animation.  When we
+  // style without animation, we need to not use it so that we can
+  // detect any new changes; if necessary we restyle immediately
+  // afterwards with animation.
+  // NOTE: If we don't need to apply any styles, mStyleRule will be
+  // null, but mStyleRuleRefreshTime will still be valid.
+  nsRefPtr<css::AnimValuesStyleRule> mStyleRule;
+  // The refresh time associated with mStyleRule.
+  TimeStamp mStyleRuleRefreshTime;
+
+  // False when we know that our current style rule is valid
+  // indefinitely into the future (because all of our animations are
+  // either completed or paused).  May be invalidated by a style change.
+  bool mNeedsRefreshes;
+
+  InfallibleTArray<ElementAnimation> mAnimations;
+};
+
+static void
+ElementAnimationsPropertyDtor(void           *aObject,
+                              nsIAtom        *aPropertyName,
+                              void           *aPropertyValue,
+                              void           *aData)
+{
+  ElementAnimations *ea = static_cast<ElementAnimations*>(aPropertyValue);
+  delete ea;
+}
+
+void
+ElementAnimations::EnsureStyleRuleFor(TimeStamp aRefreshTime)
+{
+  if (!mNeedsRefreshes) {
+    // All of our animations are paused or completed.
+    mStyleRuleRefreshTime = aRefreshTime;
+    return;
+  }
+
+  mNeedsRefreshes = false;
+
+  // mStyleRule may be null and valid, if we have no style to apply.
+  if (mStyleRuleRefreshTime.IsNull() ||
+      mStyleRuleRefreshTime != aRefreshTime) {
+    mStyleRuleRefreshTime = aRefreshTime;
+    mStyleRule = nsnull;
+
+    // FIXME(spec): assume that properties in higher animations override
+    // those in lower ones (and that our |HasProperty| check in
+    // |BuildSegment| matches the definition of when they should do so.
+    // Therefore, we iterate from last animation to first.
+    nsCSSPropertySet properties;
+
+    for (PRUint32 i = mAnimations.Length(); i-- != 0; ) {
+      const ElementAnimation &anim = mAnimations[i];
+
+      if (anim.mSegments.Length() == 0 ||
+          anim.mIterationDuration.ToMilliseconds() <= 0.0) {
+        // No animation data.
+        continue;
+      }
+
+      TimeDuration currentTimeDuration;
+      if (anim.IsPaused()) {
+        // FIXME: avoid recalculating every time
+        currentTimeDuration = anim.mPauseStart - anim.mStartTime;
+      } else {
+        currentTimeDuration = aRefreshTime - anim.mStartTime;
+      }
+
+      // Set |currentIterationCount| to the (fractional) number of
+      // iterations we've completed up to the current position.
+      double currentIterationCount =
+        currentTimeDuration / anim.mIterationDuration;
+      if (currentIterationCount > double(anim.mIterationCount)) {
+        if (!anim.FillsForwards()) {
+          // No animation data.
+          continue;
+        }
+        currentIterationCount = double(anim.mIterationCount);
+      } else {
+        if (!anim.IsPaused()) {
+          mNeedsRefreshes = true;
+        }
+        if (currentIterationCount < 0.0) {
+          if (!anim.FillsBackwards()) {
+            // No animation data.
+            continue;
+          }
+          currentIterationCount = 0.0;
+        }
+      }
+
+      // Set |positionInIteration| to the position from 0% to 100% along
+      // the keyframes.
+      NS_ABORT_IF_FALSE(currentIterationCount >= 0.0, "must be positive");
+      PRUint32 whichIteration = int(currentIterationCount);
+      if (whichIteration == anim.mIterationCount) {
+        // When the animation's iteration count is an integer (as it
+        // normally is), we need to end at 100% of its last iteration
+        // rather than 0% of the next one.
+        --whichIteration;
+      }
+      double positionInIteration =
+        currentIterationCount - double(whichIteration);
+      if (anim.mDirection == NS_STYLE_ANIMATION_DIRECTION_ALTERNATE &&
+          (whichIteration & 1) == 1) {
+        positionInIteration = 1.0 - positionInIteration;
+      }
+
+      NS_ABORT_IF_FALSE(0.0 <= positionInIteration &&
+                          positionInIteration <= 1.0,
+                        "position should be in [0-1]");
+
+      NS_ABORT_IF_FALSE(anim.mSegments[0].mFromKey == 0.0,
+                        "incorrect first from key");
+      NS_ABORT_IF_FALSE(anim.mSegments[anim.mSegments.Length() - 1].mToKey
+                          == 1.0,
+                        "incorrect last to key");
+
+      // FIXME: Maybe cache the current segment?
+      const AnimationSegment *segment = anim.mSegments.Elements();
+      while (segment->mToKey < positionInIteration) {
+        NS_ABORT_IF_FALSE(segment->mFromKey < segment->mToKey,
+                          "incorrect keys");
+        ++segment;
+        NS_ABORT_IF_FALSE(segment->mFromKey == (segment-1)->mToKey,
+                          "incorrect keys");
+      }
+      NS_ABORT_IF_FALSE(segment->mFromKey < segment->mToKey,
+                        "incorrect keys");
+      NS_ABORT_IF_FALSE(segment - anim.mSegments.Elements() <
+                          anim.mSegments.Length(),
+                        "ran off end");
+
+      if (segment->mProperties.IsEmpty()) {
+        // No animation data.
+        continue;
+      }
+
+      if (!mStyleRule) {
+        // Allocate the style rule now that we know we have animation data.
+        mStyleRule = new css::AnimValuesStyleRule();
+      }
+
+      double positionInSegment = (positionInIteration - segment->mFromKey) /
+                                 (segment->mToKey - segment->mFromKey);
+      double valuePosition =
+        segment->mTimingFunction.GetValue(positionInSegment);
+
+      for (PRUint32 j = 0, j_end = segment->mProperties.Length();
+           j != j_end; ++j) {
+        const AnimationSegmentProperty &prop = segment->mProperties[j];
+        if (properties.HasProperty(prop.mProperty)) {
+          // A later animation already set this property.
+          continue;
+        }
+        properties.AddProperty(prop.mProperty);
+
+        nsStyleAnimation::Value *val =
+          mStyleRule->AddEmptyValue(prop.mProperty);
+
+#ifdef DEBUG
+        PRBool result =
+#endif
+          nsStyleAnimation::Interpolate(prop.mProperty,
+                                        prop.mFromValue, prop.mToValue,
+                                        valuePosition, *val);
+        NS_ABORT_IF_FALSE(result, "interpolate must succeed now");
+      }
+    }
+  }
+}
+
+ElementAnimations*
+nsAnimationManager::GetElementAnimations(dom::Element *aElement,
+                                         nsCSSPseudoElements::Type aPseudoType,
+                                         PRBool aCreateIfNeeded)
+{
+  if (!aCreateIfNeeded && PR_CLIST_IS_EMPTY(&mElementData)) {
+    // Early return for the most common case.
+    return nsnull;
+  }
+
+  nsIAtom *propName;
+  if (aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
+    propName = nsGkAtoms::animationsProperty;
+  } else if (aPseudoType == nsCSSPseudoElements::ePseudo_before) {
+    propName = nsGkAtoms::animationsOfBeforeProperty;
+  } else if (aPseudoType == nsCSSPseudoElements::ePseudo_after) {
+    propName = nsGkAtoms::animationsOfAfterProperty;
+  } else {
+    NS_ASSERTION(!aCreateIfNeeded,
+                 "should never try to create transitions for pseudo "
+                 "other than :before or :after");
+    return nsnull;
+  }
+  ElementAnimations *ea = static_cast<ElementAnimations*>(
+                             aElement->GetProperty(propName));
+  if (!ea && aCreateIfNeeded) {
+    // FIXME: Consider arena-allocating?
+    ea = new ElementAnimations(aElement, propName, this);
+    if (!ea) {
+      NS_WARNING("out of memory");
+      return nsnull;
+    }
+    nsresult rv = aElement->SetProperty(propName, ea,
+                                        ElementAnimationsPropertyDtor, nsnull);
+    if (NS_FAILED(rv)) {
+      NS_WARNING("SetProperty failed");
+      delete ea;
+      return nsnull;
+    }
+
+    AddElementData(ea);
+  }
+
+  return ea;
+}
+
+/* virtual */ void
+nsAnimationManager::RulesMatching(ElementRuleProcessorData* aData)
+{
+  NS_ABORT_IF_FALSE(aData->mPresContext == mPresContext,
+                    "pres context mismatch");
+  nsIStyleRule *rule =
+    GetAnimationRule(aData->mElement,
+                     nsCSSPseudoElements::ePseudo_NotPseudoElement);
+  if (rule) {
+    aData->mRuleWalker->Forward(rule);
+  }
+}
+
+/* virtual */ void
+nsAnimationManager::RulesMatching(PseudoElementRuleProcessorData* aData)
+{
+  NS_ABORT_IF_FALSE(aData->mPresContext == mPresContext,
+                    "pres context mismatch");
+  if (aData->mPseudoType != nsCSSPseudoElements::ePseudo_before &&
+      aData->mPseudoType != nsCSSPseudoElements::ePseudo_after) {
+    return;
+  }
+
+  // FIXME: Do we really want to be the only thing keeping a
+  // pseudo-element alive?  I *think* the non-animation restyle should
+  // handle that, but should add a test.
+  nsIStyleRule *rule = GetAnimationRule(aData->mElement, aData->mPseudoType);
+  if (rule) {
+    aData->mRuleWalker->Forward(rule);
+  }
+}
+
+/* virtual */ void
+nsAnimationManager::RulesMatching(AnonBoxRuleProcessorData* aData)
+{
+}
+
+#ifdef MOZ_XUL
+/* virtual */ void
+nsAnimationManager::RulesMatching(XULTreeRuleProcessorData* aData)
+{
+}
+#endif
+
+nsIStyleRule*
+nsAnimationManager::CheckAnimationRule(nsStyleContext* aStyleContext,
+                                       mozilla::dom::Element* aElement)
+{
+  if (!mPresContext->IsProcessingAnimationStyleChange()) {
+    // Everything that causes our animation data to change triggers a
+    // style change, which in turn triggers a non-animation restyle.
+    // Likewise, when we initially construct frames, we're not in a
+    // style change, but also not in an animation restyle.
+
+    const nsStyleDisplay *disp = aStyleContext->GetStyleDisplay();
+    ElementAnimations *ea =
+      GetElementAnimations(aElement, aStyleContext->GetPseudoType(), PR_FALSE);
+    if (!ea &&
+        disp->mAnimations.Length() == 1 &&
+        disp->mAnimations[0].GetName().IsEmpty()) {
+      return nsnull;
+    }
+
+    // build the animations list
+    InfallibleTArray<ElementAnimation> newAnimations;
+    BuildAnimations(aStyleContext, newAnimations);
+
+    if (newAnimations.IsEmpty()) {
+      if (ea) {
+        ea->Destroy();
+      }
+      return nsnull;
+    }
+
+    TimeStamp refreshTime = mPresContext->RefreshDriver()->MostRecentRefresh();
+
+    if (ea) {
+      // The cached style rule is invalid.
+      ea->mStyleRule = nsnull;
+      ea->mStyleRuleRefreshTime = TimeStamp();
+
+      // If the full list of names matches, copy over the start times and
+      // (if still paused) pause starts.
+      // FIXME (spec): the spec is very unclear about when to preserve
+      // animation data under changes.  Should test and improve spec and
+      // code.
+      if (newAnimations.Length() == ea->mAnimations.Length()) {
+        bool namesMatch = true;
+        for (PRUint32 i = 0, i_end = newAnimations.Length(); i != i_end; ++i) {
+          if (newAnimations[i].mName != ea->mAnimations[i].mName) {
+            namesMatch = false;
+            break;
+          }
+        }
+        if (namesMatch) {
+          for (PRUint32 i = 0, i_end = newAnimations.Length();
+               i != i_end; ++i) {
+            const ElementAnimation &oldAnim = ea->mAnimations[i];
+            ElementAnimation &newAnim = newAnimations[i];
+
+            newAnim.mStartTime = oldAnim.mStartTime;
+
+            if (oldAnim.IsPaused()) {
+              if (newAnim.IsPaused()) {
+                // Copy pause start just like start time.
+                newAnim.mPauseStart = oldAnim.mPauseStart;
+              } else {
+                // Handle change in pause state by adjusting start
+                // time to unpause.
+                newAnim.mStartTime += refreshTime - oldAnim.mPauseStart;
+              }
+            }
+          }
+        }
+      }
+    } else {
+      ea = GetElementAnimations(aElement, aStyleContext->GetPseudoType(),
+                                PR_TRUE);
+    }
+    ea->mAnimations.SwapElements(newAnimations);
+    ea->mNeedsRefreshes = true;
+
+    ea->EnsureStyleRuleFor(refreshTime);
+  }
+
+  return GetAnimationRule(aElement, aStyleContext->GetPseudoType());
+}
+
+class PercentageHashKey : public PLDHashEntryHdr
+{
+public:
+  typedef const float& KeyType;
+  typedef const float* KeyTypePointer;
+
+  PercentageHashKey(KeyTypePointer aKey) : mValue(*aKey) { }
+  PercentageHashKey(const PercentageHashKey& toCopy) : mValue(toCopy.mValue) { }
+  ~PercentageHashKey() { }
+
+  KeyType GetKey() const { return mValue; }
+  PRBool KeyEquals(KeyTypePointer aKey) const { return *aKey == mValue; }
+
+  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
+  static PLDHashNumber HashKey(KeyTypePointer aKey) {
+    PR_STATIC_ASSERT(sizeof(PLDHashNumber) == sizeof(PRUint32));
+    PR_STATIC_ASSERT(PLDHashNumber(-1) > PLDHashNumber(0));
+    float key = *aKey;
+    NS_ABORT_IF_FALSE(0.0f <= key && key <= 1.0f, "out of range");
+    return PLDHashNumber(key * PR_UINT32_MAX);
+  }
+  enum { ALLOW_MEMMOVE = PR_TRUE };
+
+private:
+  const float mValue;
+};
+
+struct KeyframeData {
+  float mKey;
+  nsCSSKeyframeRule *mRule;
+};
+
+typedef InfallibleTArray<KeyframeData> KeyframeDataArray;
+
+static PLDHashOperator
+AppendKeyframeData(const float &aKey, nsCSSKeyframeRule *aRule, void *aData)
+{
+  KeyframeDataArray *array = static_cast<KeyframeDataArray*>(aData);
+  KeyframeData *data = array->AppendElement();
+  data->mKey = aKey;
+  data->mRule = aRule;
+  return PL_DHASH_NEXT;
+}
+
+struct KeyframeDataComparator {
+  PRBool Equals(const KeyframeData& A, const KeyframeData& B) const {
+    return A.mKey == B.mKey;
+  }
+  PRBool LessThan(const KeyframeData& A, const KeyframeData& B) const {
+    return A.mKey < B.mKey;
+  }
+};
+
+class ResolvedStyleCache {
+public:
+  ResolvedStyleCache() {
+    mCache.Init(16); // FIXME: make infallible!
+  }
+  nsStyleContext* Get(nsPresContext *aPresContext,
+                      nsStyleContext *aParentStyleContext,
+                      nsCSSKeyframeRule *aKeyframe);
+
+private:
+  nsRefPtrHashtable<nsPtrHashKey<nsCSSKeyframeRule>, nsStyleContext> mCache;
+};
+
+nsStyleContext*
+ResolvedStyleCache::Get(nsPresContext *aPresContext,
+                        nsStyleContext *aParentStyleContext,
+                        nsCSSKeyframeRule *aKeyframe)
+{
+  // FIXME (spec):  The css3-animations spec isn't very clear about how
+  // properties are resolved when they have values that depend on other
+  // properties (e.g., values in 'em').  I presume that they're resolved
+  // relative to the other styles of the element.  The question is
+  // whether they are resolved relative to other animations:  I assume
+  // that they're not, since that would prevent us from caching a lot of
+  // data that we'd really like to cache (in particular, the
+  // nsStyleAnimation::Value values in AnimationSegmentProperty).
+  nsStyleContext *result = mCache.GetWeak(aKeyframe);
+  if (!result) {
+    nsCOMArray<nsIStyleRule> rules;
+    rules.AppendObject(aKeyframe);
+    nsRefPtr<nsStyleContext> resultStrong = aPresContext->StyleSet()->
+      ResolveStyleByAddingRules(aParentStyleContext, rules);
+    mCache.Put(aKeyframe, resultStrong);
+    result = resultStrong;
+  }
+  return result;
+}
+
+void
+nsAnimationManager::BuildAnimations(nsStyleContext* aStyleContext,
+                                    InfallibleTArray<ElementAnimation>& aAnimations)
+{
+  NS_ABORT_IF_FALSE(aAnimations.IsEmpty(), "expect empty array");
+
+  ResolvedStyleCache resolvedStyles;
+
+  const nsStyleDisplay *disp = aStyleContext->GetStyleDisplay();
+  TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+  for (PRUint32 i = 0, i_end = disp->mAnimations.Length(); i != i_end; ++i) {
+    const nsAnimation& aSrc = disp->mAnimations[i];
+    ElementAnimation& aDest = *aAnimations.AppendElement();
+
+    aDest.mName = aSrc.GetName();
+    aDest.mIterationCount = aSrc.GetIterationCount();
+    aDest.mDirection = aSrc.GetDirection();
+    aDest.mFillMode = aSrc.GetFillMode();
+    aDest.mPlayState = aSrc.GetPlayState();
+
+    aDest.mStartTime = now + TimeDuration::FromMilliseconds(aSrc.GetDelay());
+    if (aDest.IsPaused()) {
+      aDest.mPauseStart = now;
+    } else {
+      aDest.mPauseStart = TimeStamp();
+    }
+
+    aDest.mIterationDuration = TimeDuration::FromMilliseconds(aSrc.GetDuration());
+
+    nsCSSKeyframesRule *rule = KeyframesRuleFor(aDest.mName);
+    if (!rule) {
+      // no segments
+      continue;
+    }
+
+    // Build the set of unique keyframes in the @keyframes rule.  Per
+    // css3-animations, later keyframes with the same key replace
+    // earlier ones (no cascading).
+    nsDataHashtable<PercentageHashKey, nsCSSKeyframeRule*> keyframes;
+    keyframes.Init(16); // FIXME: make infallible!
+    for (PRUint32 j = 0, j_end = rule->StyleRuleCount(); j != j_end; ++j) {
+      nsCOMPtr<nsICSSRule> cssRule;
+      rule->GetStyleRuleAt(j, *getter_AddRefs(cssRule));
+      NS_ABORT_IF_FALSE(cssRule, "must have rule");
+      NS_ABORT_IF_FALSE(cssRule->GetType() == nsICSSRule::KEYFRAME_RULE,
+                        "must be keyframe rule");
+      nsCSSKeyframeRule *kfRule =
+        static_cast<nsCSSKeyframeRule*>(cssRule.get());
+
+      const nsTArray<float> &keys = kfRule->GetKeys();
+      for (PRUint32 k = 0, k_end = keys.Length(); k != k_end; ++k) {
+        float key = keys[k];
+        // FIXME (spec):  The spec doesn't say what to do with
+        // out-of-range keyframes.  We'll ignore them.
+        // (And PercentageHashKey currently assumes we either ignore or
+        // clamp them.)
+        if (0.0f <= key && key <= 1.0f) {
+          keyframes.Put(key, kfRule);
+        }
+      }
+    }
+
+    KeyframeDataArray sortedKeyframes;
+    keyframes.EnumerateRead(AppendKeyframeData, &sortedKeyframes);
+    sortedKeyframes.Sort(KeyframeDataComparator());
+
+    if (sortedKeyframes.Length() == 0) {
+      // no segments
+      continue;
+    }
+
+    KeyframeData fromKeyframe = sortedKeyframes[0];
+    nsRefPtr<nsStyleContext> fromContext =
+      resolvedStyles.Get(mPresContext, aStyleContext,
+                         fromKeyframe.mRule);
+
+    // If there's no rule for 0%, there's implicitly an empty rule.
+    if (fromKeyframe.mKey != 0.0f) {
+      BuildSegment(aDest.mSegments, aSrc,
+                   0.0f, aStyleContext, nsnull,
+                   fromKeyframe.mKey, fromContext,
+                     fromKeyframe.mRule->Declaration());
+    }
+
+    for (PRUint32 j = 1, j_end = sortedKeyframes.Length(); j != j_end; ++j) {
+      KeyframeData toKeyframe = sortedKeyframes[j];
+      nsRefPtr<nsStyleContext> toContext =
+        resolvedStyles.Get(mPresContext, aStyleContext, toKeyframe.mRule);
+
+      BuildSegment(aDest.mSegments, aSrc,
+                   fromKeyframe.mKey, fromContext,
+                   fromKeyframe.mRule->Declaration(),
+                   toKeyframe.mKey, toContext,
+                   toKeyframe.mRule->Declaration());
+
+      fromContext = toContext;
+      fromKeyframe = toKeyframe;
+    }
+
+    // If there's no rule for 100%, there's implicitly an empty rule.
+    if (fromKeyframe.mKey != 1.0f) {
+      BuildSegment(aDest.mSegments, aSrc,
+                   fromKeyframe.mKey, fromContext,
+                   fromKeyframe.mRule->Declaration(),
+                   1.0f, aStyleContext, nsnull);
+    }
+  }
+}
+
+void
+nsAnimationManager::BuildSegment(nsTArray<AnimationSegment,
+                                   nsTArrayInfallibleAllocator>& aSegments,
+                                 const nsAnimation& aAnimation,
+                                 float aFromKey, nsStyleContext* aFromContext,
+                                 mozilla::css::Declaration* aFromDeclaration,
+                                 float aToKey, nsStyleContext* aToContext,
+                                 mozilla::css::Declaration* aToDeclaration)
+{
+  AnimationSegment &segment = *aSegments.AppendElement();
+
+  segment.mFromKey = aFromKey;
+  segment.mToKey = aToKey;
+  const nsTimingFunction *tf;
+  if (aFromDeclaration &&
+      aFromDeclaration->HasProperty(eCSSProperty_animation_timing_function)) {
+    tf = &aFromContext->GetStyleDisplay()->mAnimations[0].GetTimingFunction();
+  } else {
+    tf = &aAnimation.GetTimingFunction();
+  }
+  segment.mTimingFunction.Init(*tf);
+
+  for (nsCSSProperty prop = nsCSSProperty(0);
+       prop < eCSSProperty_COUNT_no_shorthands;
+       prop = nsCSSProperty(prop + 1)) {
+    if (nsCSSProps::kAnimTypeTable[prop] == eStyleAnimType_None) {
+      continue;
+    }
+
+    if (!(aFromDeclaration && aFromDeclaration->HasProperty(prop)) &&
+        !(aToDeclaration && aToDeclaration->HasProperty(prop))) {
+      // Don't store an animation if neither declaration has the property.
+      continue;
+    }
+
+    nsStyleAnimation::Value fromValue, toValue, dummyValue;
+    if (ExtractComputedValueForTransition(prop, aFromContext, fromValue) &&
+        ExtractComputedValueForTransition(prop, aToContext, toValue) &&
+        // Check that we can interpolate between these values
+        // (If this is ever a performance problem, we could add a
+        // CanInterpolate method, but it seems fine for now.)
+        nsStyleAnimation::Interpolate(prop, fromValue, toValue,
+                                      0.5, dummyValue)) {
+      AnimationSegmentProperty &p = *segment.mProperties.AppendElement();
+      p.mProperty = prop;
+      p.mFromValue = fromValue;
+      p.mToValue = toValue;
+    }
+  }
+}
+
+nsIStyleRule*
+nsAnimationManager::GetAnimationRule(mozilla::dom::Element* aElement,
+                                     nsCSSPseudoElements::Type aPseudoType)
+{
+  NS_ABORT_IF_FALSE(
+    aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ||
+    aPseudoType == nsCSSPseudoElements::ePseudo_before ||
+    aPseudoType == nsCSSPseudoElements::ePseudo_after,
+    "forbidden pseudo type");
+
+  ElementAnimations *ea =
+    GetElementAnimations(aElement, aPseudoType, PR_FALSE);
+  if (!ea) {
+    return nsnull;
+  }
+
+  NS_ABORT_IF_FALSE(ea->mStyleRuleRefreshTime ==
+                      mPresContext->RefreshDriver()->MostRecentRefresh(),
+                    "should already have refreshed style rule");
+
+  if (mPresContext->IsProcessingRestyles() &&
+      !mPresContext->IsProcessingAnimationStyleChange()) {
+    // During the non-animation part of processing restyles, we don't
+    // add the animation rule.
+
+    if (ea->mStyleRule) {
+      ea->PostRestyleForAnimation(mPresContext);
+    }
+
+    return nsnull;
+  }
+
+  return ea->mStyleRule;
+}
+
+/* virtual */ void
+nsAnimationManager::WillRefresh(mozilla::TimeStamp aTime)
+{
+  NS_ABORT_IF_FALSE(mPresContext,
+                    "refresh driver should not notify additional observers "
+                    "after pres context has been destroyed");
+  if (!mPresContext->GetPresShell()) {
+    // Someone might be keeping mPresContext alive past the point
+    // where it has been torn down; don't bother doing anything in
+    // this case.  But do get rid of all our transitions so we stop
+    // triggering refreshes.
+    RemoveAllElementData();
+    return;
+  }
+
+  // FIXME: check that there's at least one style rule that's not
+  // in its "done" state, and if there isn't, remove ourselves from
+  // the refresh driver (but leave the animations!).
+  for (PRCList *l = PR_LIST_HEAD(&mElementData); l != &mElementData;
+       l = PR_NEXT_LINK(l)) {
+    ElementAnimations *ea = static_cast<ElementAnimations*>(l);
+    nsRefPtr<css::AnimValuesStyleRule> oldStyleRule = ea->mStyleRule;
+    ea->EnsureStyleRuleFor(mPresContext->RefreshDriver()->MostRecentRefresh());
+    if (oldStyleRule != ea->mStyleRule) {
+      ea->PostRestyleForAnimation(mPresContext);
+    }
+  }
+}
+
+nsCSSKeyframesRule*
+nsAnimationManager::KeyframesRuleFor(const nsSubstring& aName)
+{
+  if (mKeyframesListIsDirty) {
+    mKeyframesListIsDirty = false;
+
+    nsTArray<nsCSSKeyframesRule*> rules;
+    mPresContext->StyleSet()->AppendKeyframesRules(mPresContext, rules);
+
+    // Per css3-animations, the last @keyframes rule specified wins.
+    mKeyframesRules.Clear();
+    for (PRUint32 i = 0, i_end = rules.Length(); i != i_end; ++i) {
+      nsCSSKeyframesRule *rule = rules[i];
+      mKeyframesRules.Put(rule->GetName(), rule);
+    }
+  }
+
+  return mKeyframesRules.Get(aName);
+}
+
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
new file mode 100644
--- /dev/null
+++ b/layout/style/nsAnimationManager.h
@@ -0,0 +1,118 @@
+/* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is nsAnimationManager, an implementation of part
+ * of css3-animations.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsAnimationManager_h_
+#define nsAnimationManager_h_
+
+#include "AnimationCommon.h"
+#include "nsCSSPseudoElements.h"
+#include "nsStyleContext.h"
+#include "nsTHashtable.h"
+
+class nsCSSKeyframesRule;
+struct AnimationSegment;
+struct ElementAnimation;
+struct ElementAnimations;
+
+namespace mozilla {
+namespace css {
+class Declaration;
+}
+}
+
+class nsAnimationManager : public mozilla::css::CommonAnimationManager
+{
+public:
+  nsAnimationManager(nsPresContext *aPresContext)
+    : mozilla::css::CommonAnimationManager(aPresContext),
+      mKeyframesListIsDirty(true)
+  {
+    mKeyframesRules.Init(16); // FIXME: make infallible!
+  }
+
+  // nsIStyleRuleProcessor (parts)
+  virtual void RulesMatching(ElementRuleProcessorData* aData);
+  virtual void RulesMatching(PseudoElementRuleProcessorData* aData);
+  virtual void RulesMatching(AnonBoxRuleProcessorData* aData);
+#ifdef MOZ_XUL
+  virtual void RulesMatching(XULTreeRuleProcessorData* aData);
+#endif
+
+  // nsARefreshObserver
+  virtual void WillRefresh(mozilla::TimeStamp aTime);
+
+  /**
+   * Return the style rule that RulesMatching should add for
+   * aStyleContext.  This might be different from what RulesMatching
+   * actually added during aStyleContext's construction because the
+   * element's animation-name may have changed.  (However, this does
+   * return null during the non-animation restyling phase, as
+   * RulesMatching does.)
+   *
+   * aStyleContext may be a style context for aElement or for its
+   * :before or :after pseudo-element.
+   */
+  nsIStyleRule* CheckAnimationRule(nsStyleContext* aStyleContext,
+                                   mozilla::dom::Element* aElement);
+
+  void KeyframesListIsDirty() {
+    mKeyframesListIsDirty = PR_TRUE;
+  }
+
+private:
+  ElementAnimations* GetElementAnimations(mozilla::dom::Element *aElement,
+                                          nsCSSPseudoElements::Type aPseudoType,
+                                          PRBool aCreateIfNeeded);
+  void BuildAnimations(nsStyleContext* aStyleContext,
+                       InfallibleTArray<ElementAnimation>& aAnimations);
+  void BuildSegment(nsTArray<AnimationSegment,
+                             nsTArrayInfallibleAllocator>& aSegments,
+                    const nsAnimation& aAnimation,
+                    float aFromKey, nsStyleContext* aFromContext,
+                    mozilla::css::Declaration* aFromDeclaration,
+                    float aToKey, nsStyleContext* aToContext,
+                    mozilla::css::Declaration* aToDeclaration);
+  nsIStyleRule* GetAnimationRule(mozilla::dom::Element* aElement,
+                                 nsCSSPseudoElements::Type aPseudoType);
+
+  nsCSSKeyframesRule* KeyframesRuleFor(const nsSubstring& aName);
+
+  bool mKeyframesListIsDirty;
+  nsDataHashtable<nsStringHashKey, nsCSSKeyframesRule*> mKeyframesRules;
+};
+
+#endif /* !defined(nsAnimationManager_h_) */
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -54,16 +54,17 @@
 #include "nsCSSAnonBoxes.h"
 #include "nsCSSPseudoElements.h"
 #include "nsCSSRuleProcessor.h"
 #include "nsIContent.h"
 #include "nsIFrame.h"
 #include "nsContentUtils.h"
 #include "nsRuleProcessorData.h"
 #include "nsTransitionManager.h"
+#include "nsAnimationManager.h"
 #include "nsIEventStateManager.h"
 #include "mozilla/dom/Element.h"
 
 using namespace mozilla::dom;
 
 NS_IMPL_ISUPPORTS1(nsEmptyStyleRule, nsIStyleRule)
 
 /* virtual */ void
@@ -111,16 +112,17 @@ nsStyleSet::Init(nsPresContext *aPresCon
   }
 
   mRuleTree = nsRuleNode::CreateRootNode(aPresContext);
   if (!mRuleTree) {
     mDefaultStyleData.Destroy(0, aPresContext);
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
+  GatherRuleProcessors(eAnimationSheet);
   GatherRuleProcessors(eTransitionSheet);
 
   return NS_OK;
 }
 
 nsresult
 nsStyleSet::BeginReconstruct()
 {
@@ -191,16 +193,23 @@ nsStyleSet::GatherRuleProcessors(sheetTy
 {
   mRuleProcessors[aType] = nsnull;
   if (mAuthorStyleDisabled && (aType == eDocSheet || 
                                aType == ePresHintSheet ||
                                aType == eStyleAttrSheet)) {
     //don't regather if this level is disabled
     return NS_OK;
   }
+  if (aType == eAnimationSheet) {
+    // We have no sheet for the animations level; just a rule
+    // processor.  (XXX: We should probably do this for the other
+    // non-CSS levels too!)
+    mRuleProcessors[aType] = PresContext()->AnimationManager();
+    return NS_OK;
+  }
   if (aType == eTransitionSheet) {
     // We have no sheet for the transitions level; just a rule
     // processor.  (XXX: We should probably do this for the other
     // non-CSS levels too!)
     mRuleProcessors[aType] = PresContext()->TransitionManager();
     return NS_OK;
   }
   if (mSheets[aType].Count()) {
@@ -420,17 +429,19 @@ nsStyleSet::GetContext(nsStyleContext* a
                        // it means that we don't need to force creation
                        // of a StyleIfVisited.  (But if we make one
                        // because aParentContext has one, then aRuleNode
                        // should be used.)
                        nsRuleNode* aVisitedRuleNode,
                        PRBool aIsLink,
                        PRBool aIsVisitedLink,
                        nsIAtom* aPseudoTag,
-                       nsCSSPseudoElements::Type aPseudoType)
+                       nsCSSPseudoElements::Type aPseudoType,
+                       PRBool aDoAnimations,
+                       Element* aElementForAnimation)
 {
   NS_PRECONDITION((!aPseudoTag &&
                    aPseudoType ==
                      nsCSSPseudoElements::ePseudo_NotPseudoElement) ||
                   (aPseudoTag &&
                    nsCSSPseudoElements::GetPseudoType(aPseudoTag) ==
                      aPseudoType),
                   "Pseudo mismatch");
@@ -503,16 +514,61 @@ nsStyleSet::GetContext(nsStyleContext* a
     if (!aParentContext)
       mRoots.AppendElement(result);
   }
   else {
     NS_ASSERTION(result->GetPseudoType() == aPseudoType, "Unexpected type");
     NS_ASSERTION(result->GetPseudo() == aPseudoTag, "Unexpected pseudo");
   }
 
+  if (aDoAnimations) {
+    // Normally the animation manager has already added the correct
+    // style rule.  However, if the animation-name just changed, it
+    // might have been wrong.  So ask it to double-check based on the
+    // resulting style context.
+    nsIStyleRule *animRule = PresContext()->AnimationManager()->
+      CheckAnimationRule(result, aElementForAnimation);
+    bool rerun;
+    NS_ABORT_IF_FALSE(result->GetRuleNode() == aRuleNode,
+                      "unexpected rule node");
+    NS_ABORT_IF_FALSE(!result->GetStyleIfVisited() == !aVisitedRuleNode,
+                      "unexpected visited rule node");
+    NS_ABORT_IF_FALSE(!aVisitedRuleNode ||
+                      result->GetStyleIfVisited()->GetRuleNode() ==
+                        aVisitedRuleNode,
+                      "unexpected visited rule node");
+    if (animRule) {
+      rerun = aRuleNode->GetRule() != animRule;
+    } else {
+      rerun = !aRuleNode->IsRoot() && aRuleNode->GetLevel() == eAnimationSheet;
+    }
+    if (rerun) {
+      nsRuleNode *ruleNode = (aRuleNode->GetLevel() == eAnimationSheet)
+                               ? aRuleNode->GetParent() : aRuleNode;
+      if (animRule) {
+        ruleNode = ruleNode->Transition(animRule, eAnimationSheet, PR_FALSE);
+      }
+
+      nsRuleNode *visitedRuleNode;
+      if (aVisitedRuleNode) {
+        visitedRuleNode = (aVisitedRuleNode->GetLevel() == eAnimationSheet)
+                            ? aVisitedRuleNode->GetParent() : aVisitedRuleNode;
+        if (animRule) {
+          ruleNode = visitedRuleNode->Transition(animRule, eAnimationSheet,
+                                                 PR_FALSE);
+        }
+      } else {
+        visitedRuleNode = nsnull;
+      }
+      result = GetContext(aParentContext, ruleNode, visitedRuleNode,
+                          aIsLink, aIsVisitedLink,
+                          aPseudoTag, aPseudoType, PR_FALSE, nsnull);
+    }
+  }
+
   return result.forget();
 }
 
 void
 nsStyleSet::AddImportantRules(nsRuleNode* aCurrLevelNode,
                               nsRuleNode* aLastPrevLevelNode,
                               nsRuleWalker* aRuleWalker)
 {
@@ -677,16 +733,19 @@ nsStyleSet::FileRules(nsIStyleRuleProces
   }
 #endif
 
 #ifdef DEBUG
   nsRuleNode *lastImportantRN = aRuleWalker->CurrentNode();
 #endif
   aRuleWalker->SetLevel(eTransitionSheet, PR_FALSE, PR_FALSE);
   (*aCollectorFunc)(mRuleProcessors[eTransitionSheet], aData);
+  // GetContext() depends on the animation rules being *last*
+  aRuleWalker->SetLevel(eAnimationSheet, PR_FALSE, PR_FALSE);
+  (*aCollectorFunc)(mRuleProcessors[eAnimationSheet], aData);
 #ifdef DEBUG
   AssertNoCSSRules(aRuleWalker->CurrentNode(), lastImportantRN);
   AssertNoImportantRules(aRuleWalker->CurrentNode(), lastImportantRN);
 #endif
 
 }
 
 // Enumerate all the rules in a way that doesn't care about the order
@@ -718,16 +777,18 @@ nsStyleSet::WalkRuleProcessors(nsIStyleR
   if (!skipUserStyles && !cutOffInheritance &&
       mRuleProcessors[eDocSheet]) // NOTE: different
     (*aFunc)(mRuleProcessors[eDocSheet], aData);
   if (mRuleProcessors[eStyleAttrSheet])
     (*aFunc)(mRuleProcessors[eStyleAttrSheet], aData);
   if (mRuleProcessors[eOverrideSheet])
     (*aFunc)(mRuleProcessors[eOverrideSheet], aData);
   (*aFunc)(mRuleProcessors[eTransitionSheet], aData);
+  // GetContext depends on the animation rule being *last*
+  (*aFunc)(mRuleProcessors[eAnimationSheet], aData);
 }
 
 PRBool nsStyleSet::BuildDefaultStyleData(nsPresContext* aPresContext)
 {
   NS_ASSERTION(!mDefaultStyleData.mResetData &&
                !mDefaultStyleData.mInheritedData,
                "leaking default style data");
   mDefaultStyleData.mResetData = new (aPresContext) nsResetStyleData;
@@ -792,17 +853,18 @@ nsStyleSet::ResolveStyleFor(Element* aEl
               &ruleWalker);
     visitedRuleNode = ruleWalker.CurrentNode();
   }
 
   return GetContext(aParentContext, ruleNode, visitedRuleNode,
                     nsCSSRuleProcessor::IsLink(aElement),
                     nsCSSRuleProcessor::GetContentState(aElement).
                       HasState(NS_EVENT_STATE_VISITED),
-                    nsnull, nsCSSPseudoElements::ePseudo_NotPseudoElement);
+                    nsnull, nsCSSPseudoElements::ePseudo_NotPseudoElement,
+                    PR_TRUE, aElement);
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForRules(nsStyleContext* aParentContext,
                                  const nsCOMArray<nsIStyleRule> &aRules)
 {
   NS_ENSURE_FALSE(mInShutdown, nsnull);
 
@@ -811,17 +873,18 @@ nsStyleSet::ResolveStyleForRules(nsStyle
   // matter.
   ruleWalker.SetLevel(eDocSheet, PR_FALSE, PR_FALSE);
   for (PRInt32 i = 0; i < aRules.Count(); i++) {
     ruleWalker.Forward(aRules.ObjectAt(i));
   }
 
   return GetContext(aParentContext, ruleWalker.CurrentNode(), nsnull,
                     PR_FALSE, PR_FALSE,
-                    nsnull, nsCSSPseudoElements::ePseudo_NotPseudoElement);
+                    nsnull, nsCSSPseudoElements::ePseudo_NotPseudoElement,
+                    PR_FALSE, nsnull);
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleByAddingRules(nsStyleContext* aBaseContext,
                                       const nsCOMArray<nsIStyleRule> &aRules)
 {
   NS_ENSURE_FALSE(mInShutdown, nsnull);
 
@@ -844,26 +907,27 @@ nsStyleSet::ResolveStyleByAddingRules(ns
     }
     visitedRuleNode = ruleWalker.CurrentNode();
   }
 
   return GetContext(aBaseContext->GetParent(), ruleNode, visitedRuleNode,
                     aBaseContext->IsLinkContext(),
                     aBaseContext->RelevantLinkVisited(),
                     aBaseContext->GetPseudo(),
-                    aBaseContext->GetPseudoType());
+                    aBaseContext->GetPseudoType(),
+                    PR_FALSE, nsnull);
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForNonElement(nsStyleContext* aParentContext)
 {
   return GetContext(aParentContext, mRuleTree, nsnull,
                     PR_FALSE, PR_FALSE,
                     nsCSSAnonBoxes::mozNonElement,
-                    nsCSSPseudoElements::ePseudo_AnonBox);
+                    nsCSSPseudoElements::ePseudo_AnonBox, PR_FALSE, nsnull);
 }
 
 void
 nsStyleSet::WalkRestrictionRule(nsCSSPseudoElements::Type aPseudoType,
                                 nsRuleWalker* aRuleWalker)
 {
   // This needs to match GetPseudoRestriction in nsRuleNode.cpp.
   aRuleWalker->SetLevel(eAgentSheet, PR_FALSE, PR_FALSE);
@@ -903,17 +967,20 @@ nsStyleSet::ResolvePseudoElementStyle(El
               aParentElement, &ruleWalker);
     visitedRuleNode = ruleWalker.CurrentNode();
   }
 
   return GetContext(aParentContext, ruleNode, visitedRuleNode,
                     // For pseudos, |data.IsLink()| being true means that
                     // our parent node is a link.
                     PR_FALSE, PR_FALSE,
-                    nsCSSPseudoElements::GetPseudoAtom(aType), aType);
+                    nsCSSPseudoElements::GetPseudoAtom(aType), aType,
+                    aType == nsCSSPseudoElements::ePseudo_before ||
+                    aType == nsCSSPseudoElements::ePseudo_after,
+                    aParentElement);
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ProbePseudoElementStyle(Element* aParentElement,
                                     nsCSSPseudoElements::Type aType,
                                     nsStyleContext* aParentContext)
 {
   TreeMatchContext treeContext(PR_TRUE, nsRuleWalker::eRelevantLinkUnvisited,
@@ -960,17 +1027,20 @@ nsStyleSet::ProbePseudoElementStyle(Elem
     visitedRuleNode = ruleWalker.CurrentNode();
   }
 
   nsRefPtr<nsStyleContext> result =
     GetContext(aParentContext, ruleNode, visitedRuleNode,
                // For pseudos, |data.IsLink()| being true means that
                // our parent node is a link.
                PR_FALSE, PR_FALSE,
-               pseudoTag, aType);
+               pseudoTag, aType,
+               aType == nsCSSPseudoElements::ePseudo_before ||
+               aType == nsCSSPseudoElements::ePseudo_after,
+               aParentElement);
 
   // For :before and :after pseudo-elements, having display: none or no
   // 'content' property is equivalent to not having the pseudo-element
   // at all.
   if (result &&
       (pseudoTag == nsCSSPseudoElements::before ||
        pseudoTag == nsCSSPseudoElements::after)) {
     const nsStyleDisplay *display = result->GetStyleDisplay();
@@ -1002,17 +1072,18 @@ nsStyleSet::ResolveAnonymousBoxStyle(nsI
 
   nsRuleWalker ruleWalker(mRuleTree);
   AnonBoxRuleProcessorData data(PresContext(), aPseudoTag, &ruleWalker);
   FileRules(EnumRulesMatching<AnonBoxRuleProcessorData>, &data, nsnull,
             &ruleWalker);
 
   return GetContext(aParentContext, ruleWalker.CurrentNode(), nsnull,
                     PR_FALSE, PR_FALSE,
-                    aPseudoTag, nsCSSPseudoElements::ePseudo_AnonBox);
+                    aPseudoTag, nsCSSPseudoElements::ePseudo_AnonBox,
+                    PR_FALSE, nsnull);
 }
 
 #ifdef MOZ_XUL
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveXULTreePseudoStyle(Element* aParentElement,
                                       nsIAtom* aPseudoTag,
                                       nsStyleContext* aParentContext,
                                       nsICSSPseudoComparator* aComparator)
@@ -1041,17 +1112,18 @@ nsStyleSet::ResolveXULTreePseudoStyle(El
               aParentElement, &ruleWalker);
     visitedRuleNode = ruleWalker.CurrentNode();
   }
 
   return GetContext(aParentContext, ruleNode, visitedRuleNode,
                     // For pseudos, |data.IsLink()| being true means that
                     // our parent node is a link.
                     PR_FALSE, PR_FALSE,
-                    aPseudoTag, nsCSSPseudoElements::ePseudo_XULTree);
+                    aPseudoTag, nsCSSPseudoElements::ePseudo_XULTree,
+                    PR_FALSE, nsnull);
 }
 #endif
 
 PRBool
 nsStyleSet::AppendFontFaceRules(nsPresContext* aPresContext,
                                 nsTArray<nsFontFaceRuleContainer>& aArray)
 {
   NS_ENSURE_FALSE(mInShutdown, PR_FALSE);
@@ -1200,16 +1272,17 @@ nsStyleSet::ReparentStyleContext(nsStyle
   nsCSSPseudoElements::Type pseudoType = aStyleContext->GetPseudoType();
   nsRuleNode* ruleNode = aStyleContext->GetRuleNode();
 
   // Skip transition rules as needed just like
   // nsTransitionManager::WalkTransitionRule would.
   PRBool skipTransitionRules = PresContext()->IsProcessingRestyles() &&
     !PresContext()->IsProcessingAnimationStyleChange();
   if (skipTransitionRules) {
+    // FIXME do something here for animations?
     // Make sure that we're not using transition rules for our new style
     // context.  If we need them, an animation restyle will provide.
     ruleNode =
       SkipTransitionRules(ruleNode, aElement,
                           pseudoType !=
                             nsCSSPseudoElements::ePseudo_NotPseudoElement);
   }
 
@@ -1218,27 +1291,32 @@ nsStyleSet::ReparentStyleContext(nsStyle
   // Reparenting a style context just changes where we inherit from,
   // not what rules we match or what our DOM looks like.  In
   // particular, it doesn't change whether this is a style context for
   // a link.
   if (visitedContext) {
      visitedRuleNode = visitedContext->GetRuleNode();
      // Again, skip transition rules as needed
      if (skipTransitionRules) {
+      // FIXME do something here for animations?
        visitedRuleNode =
          SkipTransitionRules(visitedRuleNode, aElement,
                              pseudoType !=
                                nsCSSPseudoElements::ePseudo_NotPseudoElement);
      }
   }
 
   return GetContext(aNewParentContext, ruleNode, visitedRuleNode,
                     aStyleContext->IsLinkContext(),
                     aStyleContext->RelevantLinkVisited(),
-                    pseudoTag, pseudoType);
+                    pseudoTag, pseudoType,
+                    pseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ||
+                    pseudoType == nsCSSPseudoElements::ePseudo_before ||
+                    pseudoType == nsCSSPseudoElements::ePseudo_after,
+                    aElement);
 }
 
 struct StatefulData : public StateRuleProcessorData {
   StatefulData(nsPresContext* aPresContext, Element* aElement,
                nsEventStates aStateMask, TreeMatchContext& aTreeMatchContext)
     : StateRuleProcessorData(aPresContext, aElement, aStateMask,
                              aTreeMatchContext),
       mHint(nsRestyleHint(0))
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -235,16 +235,17 @@ class nsStyleSet
   enum sheetType {
     eAgentSheet, // CSS
     eUserSheet, // CSS
     ePresHintSheet,
     eDocSheet, // CSS
     eStyleAttrSheet,
     eOverrideSheet, // CSS
     eTransitionSheet,
+    eAnimationSheet,
     eSheetTypeCount
     // be sure to keep the number of bits in |mDirty| below and in
     // NS_RULE_NODE_LEVEL_MASK updated when changing the number of sheet
     // types
   };
 
   // APIs to manipulate the style sheet lists.  The sheets in each
   // list are stored with the most significant sheet last.
@@ -359,17 +360,19 @@ class nsStyleSet
 
   already_AddRefed<nsStyleContext>
   GetContext(nsStyleContext* aParentContext,
              nsRuleNode* aRuleNode,
              nsRuleNode* aVisitedRuleNode,
              PRBool aIsLink,
              PRBool aIsVisitedLink,
              nsIAtom* aPseudoTag,
-             nsCSSPseudoElements::Type aPseudoType);
+             nsCSSPseudoElements::Type aPseudoType,
+             PRBool aDoAnimation,
+             mozilla::dom::Element* aElementForAnimation);
 
   nsPresContext* PresContext() { return mRuleTree->GetPresContext(); }
 
   // The sheets in each array in mSheets are stored with the most significant
   // sheet last.
   nsCOMArray<nsIStyleSheet> mSheets[eSheetTypeCount];
 
   nsCOMPtr<nsIStyleRuleProcessor> mRuleProcessors[eSheetTypeCount];
diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -90,16 +90,17 @@ css_properties.js: host_ListCSSPropertie
 	$(RM) $@
 	./host_ListCSSProperties$(HOST_BIN_SUFFIX) > $@
 	cat $(srcdir)/css_properties_like_longhand.js >> $@
 
 GARBAGE += css_properties.js
 
 
 _TEST_FILES =	test_acid3_test46.html \
+		test_animations.html \
 		test_any_dynamic.html \
 		test_at_rule_parse_serialize.html \
 		test_bug73586.html \
 		test_bug74880.html \
 		test_bug98997.html \
 		test_bug160403.html \
 		test_bug221428.html \
 		test_bug229915.html \
diff --git a/layout/style/test/animation_utils.js b/layout/style/test/animation_utils.js
--- a/layout/style/test/animation_utils.js
+++ b/layout/style/test/animation_utils.js
@@ -27,8 +27,31 @@ function bezier(x1, y1, x2, y2) {
         return (mint + maxt) / 2;
     }
     return function bezier_closure(x) {
         if (x == 0) return 0;
         if (x == 1) return 1;
         return y_for_t(t_for_x(x));
     }
 }
+
+function step_end(nsteps) {
+    return function step_end_closure(x) {
+        return Math.floor(x * nsteps) / nsteps;
+    }
+}
+
+function step_start(nsteps) {
+    var stepend = step_end(nsteps);
+    return function step_start_closure(x) {
+        return 1.0 - stepend(1.0 - x);
+    }
+}
+
+var gNamedTimingFunctions = {
+  "ease": bezier(0.25, 0.1, 0.25, 1),
+  "linear": function(x) { return x; },
+  "ease_in": bezier(0.42, 0, 1, 1),
+  "ease_out": bezier(0, 0, 0.58, 1),
+  "ease_in_out": bezier(0.42, 0, 0.58, 1),
+  "step_start": step_start(1),
+  "step_end": step_end(1),
+};
diff --git a/layout/style/test/test_animations.html b/layout/style/test/test_animations.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_animations.html
@@ -0,0 +1,104 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=435442
+-->
+<head>
+  <title>Test for css3-animations (Bug 435442)</title>
+  <script type="application/javascript" src="/MochiKit/packed.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+  <style type="text/css">
+  @-moz-keyframes anim1 {
+     0% { margin-left: 0px }
+     50% { margin-left: 80px }
+     100% { margin-left: 100px }
+  }
+  </style>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=435442">Mozilla Bug 435442</a>
+<div id="display"></div>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for css3-animations (Bug 435442) **/
+
+function advance_clock(milliseconds) {
+  SpecialPowers.DOMWindowUtils.advanceTimeAndRefresh(milliseconds);
+}
+
+var display = document.getElementById("display");
+var div = null;
+var cs = null;
+function new_div(style) {
+  if (div != null || cs != null) {
+    ok(false, "test author forgot to call done_div");
+  }
+  div = document.createElement("div");
+  div.setAttribute("style", style);
+  display.appendChild(div);
+  cs = getComputedStyle(div, "");
+}
+function done_div() {
+  display.removeChild(div);
+  div = null;
+  cs = null;
+}
+
+// take over the refresh driver right from the start.
+advance_clock(0);
+
+// Test that animations don't affect the computed value before the
+// start of the animation or after its end.  Test without
+// animation-fill-mode, but then repeat the test with all the values of
+// animation-fill-mode.
+function test_fill_mode(fill_mode, fills_backwards, fills_forwards)
+{
+  var style = "margin-left: 30px; -moz-animation: 10s 3s anim1 linear";
+  if (fill_mode.length > 0) {
+    style += " " + fill_mode;
+  }
+  new_div(style);
+  if (fills_backwards)
+    is(cs.marginLeft, "0px", "does affect value during delay");
+  else
+    is(cs.marginLeft, "30px", "doesn't affect value during delay");
+  advance_clock(2000);
+  if (fills_backwards)
+    is(cs.marginLeft, "0px", "does affect value during delay");
+  else
+    is(cs.marginLeft, "30px", "doesn't affect value during delay");
+  advance_clock(1000);
+  if (fills_backwards)
+    is(cs.marginLeft, "0px", "affects value at start of animation");
+  advance_clock(125);
+  is(cs.marginLeft, "2px", "affects value during animation");
+  advance_clock(2375);
+  is(cs.marginLeft, "40px", "affects value during animation");
+  advance_clock(2500);
+  is(cs.marginLeft, "80px", "affects value during animation");
+  advance_clock(2500);
+  is(cs.marginLeft, "90px", "affects value during animation");
+  advance_clock(2375);
+  is(cs.marginLeft, "99.5px", "affects value during animation");
+  advance_clock(125);
+  if (fills_forwards)
+    is(cs.marginLeft, "100px", "affects value at end of animation");
+  advance_clock(10);
+  if (fills_forwards)
+    is(cs.marginLeft, "100px", "does affect value after animation");
+  else
+    is(cs.marginLeft, "30px", "does not affect value after animation");
+  done_div();
+}
+test_fill_mode("", false, false);
+test_fill_mode("none", false, false);
+test_fill_mode("forwards", false, true);
+test_fill_mode("backwards", true, false);
+test_fill_mode("both", true, true);
+
+</script>
+</pre>
+</body>
+</html>
