Do reinitialization of screen info at the screen manager level, so we get it for the xinerama codepath too.  b=403706

diff --git a/widget/src/gtk2/nsScreenGtk.cpp b/widget/src/gtk2/nsScreenGtk.cpp
--- a/widget/src/gtk2/nsScreenGtk.cpp
+++ b/widget/src/gtk2/nsScreenGtk.cpp
@@ -42,36 +42,8 @@
 #include <gtk/gtk.h>
 #include <X11/Xatom.h>
 
-static GdkFilterReturn
-root_window_event_filter(GdkXEvent *aGdkXEvent, GdkEvent *aGdkEvent,
-                         gpointer aClosure)
-{
-  XEvent *xevent = static_cast<XEvent*>(aGdkXEvent);
-  nsScreenGtk *ourScreen = static_cast<nsScreenGtk*>(aClosure);
-
-  // See comments in nsScreenGtk::Init below.
-  switch (xevent->type) {
-    case ConfigureNotify:
-      ourScreen->ReInit();
-      break;
-    case PropertyNotify:
-      {
-        XPropertyEvent *propertyEvent = &xevent->xproperty;
-        if (propertyEvent->atom == ourScreen->NetWorkareaAtom()) {
-          ourScreen->ReInit();
-        }
-      }
-      break;
-    default:
-      break;
-  }
-
-  return GDK_FILTER_CONTINUE;
-}
-
 nsScreenGtk :: nsScreenGtk (  )
-  : mRootWindow(nsnull),
-    mScreenNum(0),
+  : mScreenNum(0),
     mRect(0, 0, 0, 0),
     mAvailRect(0, 0, 0, 0)
 {
@@ -80,11 +52,6 @@ nsScreenGtk :: nsScreenGtk (  )
 
 nsScreenGtk :: ~nsScreenGtk()
 {
-  if (mRootWindow) {
-    gdk_window_remove_filter(mRootWindow, root_window_event_filter, this);
-    g_object_unref(mRootWindow);
-    mRootWindow = nsnull;
-  }
 }
 
 
@@ -138,7 +105,7 @@ nsScreenGtk :: GetColorDepth(PRInt32 *aC
 
 
 void
-nsScreenGtk :: Init (PRBool aReInit)
+nsScreenGtk :: Init (GdkWindow *aRootWindow)
 {
   // We listen for configure events on the root window to pick up
   // changes to this rect.  We could listen for "size_changed" signals
@@ -154,25 +121,6 @@ nsScreenGtk :: Init (PRBool aReInit)
   // could have a non-rectangular shape), but should
   // lead to greater accuracy.
 
-  if (!aReInit) {
-#if GTK_CHECK_VERSION(2,2,0)
-    mRootWindow = gdk_get_default_root_window();
-#else
-    mRootWindow = GDK_ROOT_PARENT();
-#endif // GTK_CHECK_VERSION(2,2,0)
-    g_object_ref(mRootWindow);
-
-    // GDK_STRUCTURE_MASK ==> StructureNotifyMask, for ConfigureNotify
-    // GDK_PROPERTY_CHANGE_MASK ==> PropertyChangeMask, for PropertyNotify
-    gdk_window_set_events(mRootWindow,
-                          GdkEventMask(gdk_window_get_events(mRootWindow) |
-                                       GDK_STRUCTURE_MASK |
-                                       GDK_PROPERTY_CHANGE_MASK));
-    gdk_window_add_filter(mRootWindow, root_window_event_filter, this);
-    mNetWorkareaAtom =
-      XInternAtom(GDK_WINDOW_XDISPLAY(mRootWindow), "_NET_WORKAREA", False);
-  }
-
   long *workareas;
   GdkAtom type_returned;
   int format_returned;
@@ -187,7 +135,7 @@ nsScreenGtk :: Init (PRBool aReInit)
   gdk_error_trap_push();
 
   // gdk_property_get uses (length + 3) / 4, hence G_MAXLONG - 3 here.
-  if (!gdk_property_get(mRootWindow,
+  if (!gdk_property_get(aRootWindow,
                         gdk_atom_intern ("_NET_WORKAREA", FALSE),
                         cardinal_atom,
                         0, G_MAXLONG - 3, FALSE,
diff --git a/widget/src/gtk2/nsScreenGtk.h b/widget/src/gtk2/nsScreenGtk.h
--- a/widget/src/gtk2/nsScreenGtk.h
+++ b/widget/src/gtk2/nsScreenGtk.h
@@ -63,16 +63,13 @@ public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSISCREEN
 
-  void Init(PRBool aReInit = PR_FALSE);
-  void ReInit() { Init(PR_TRUE); }
+  void Init(GdkWindow *aRootWindow);
   void Init(XineramaScreenInfo *aScreenInfo);
 
   Atom NetWorkareaAtom() { return mNetWorkareaAtom; }
 
 private:
-  GdkWindow *mRootWindow;
   PRUint32 mScreenNum;
-  Atom mNetWorkareaAtom;
   nsRect mRect; // in pixels, not twips
   nsRect mAvailRect; // in pixels, not twips
 };
diff --git a/widget/src/gtk2/nsScreenManagerGtk.cpp b/widget/src/gtk2/nsScreenManagerGtk.cpp
--- a/widget/src/gtk2/nsScreenManagerGtk.cpp
+++ b/widget/src/gtk2/nsScreenManagerGtk.cpp
@@ -51,7 +51,35 @@ typedef Bool (*_XnrmIsActive_fn)(Display
 typedef Bool (*_XnrmIsActive_fn)(Display *dpy);
 typedef XineramaScreenInfo* (*_XnrmQueryScreens_fn)(Display *dpy, int *number);
 
+static GdkFilterReturn
+root_window_event_filter(GdkXEvent *aGdkXEvent, GdkEvent *aGdkEvent,
+                         gpointer aClosure)
+{
+  XEvent *xevent = static_cast<XEvent*>(aGdkXEvent);
+  nsScreenGtk *ourScreen = static_cast<nsScreenGtk*>(aClosure);
+
+  // See comments in nsScreenGtk::Init below.
+  switch (xevent->type) {
+    case ConfigureNotify:
+      ourScreen->ReInit();
+      break;
+    case PropertyNotify:
+      {
+        XPropertyEvent *propertyEvent = &xevent->xproperty;
+        if (propertyEvent->atom == ourScreen->NetWorkareaAtom()) {
+          ourScreen->ReInit();
+        }
+      }
+      break;
+    default:
+      break;
+  }
+
+  return GDK_FILTER_CONTINUE;
+}
+
 nsScreenManagerGtk :: nsScreenManagerGtk ( )
+  : mRootWindow(nsnull)
 {
   // nothing else to do. I guess we could cache a bunch of information
   // here, but we want to ask the device at runtime in case anything
@@ -62,6 +90,12 @@ nsScreenManagerGtk :: nsScreenManagerGtk
 
 nsScreenManagerGtk :: ~nsScreenManagerGtk()
 {
+  if (mRootWindow) {
+    gdk_window_remove_filter(mRootWindow, root_window_event_filter, this);
+    g_object_unref(mRootWindow);
+    mRootWindow = nsnull;
+  }
+
   if (mXineramalib && mXineramalib != SCREEN_MANAGER_LIBRARY_LOAD_FAILED) {
     PR_UnloadLibrary(mXineramalib);
   }
@@ -74,9 +108,34 @@ NS_IMPL_ISUPPORTS1(nsScreenManagerGtk, n
 
 // this function will make sure that everything has been initialized.
 nsresult
-nsScreenManagerGtk :: EnsureInit(void)
+nsScreenManagerGtk :: EnsureInit()
 {
-  if (mNumScreens == 0) {
+  if (mNumScreens > 0)
+    return NS_OK;
+
+#if GTK_CHECK_VERSION(2,2,0)
+  mRootWindow = gdk_get_default_root_window();
+#else
+  mRootWindow = GDK_ROOT_PARENT();
+#endif // GTK_CHECK_VERSION(2,2,0)
+  g_object_ref(mRootWindow);
+
+  // GDK_STRUCTURE_MASK ==> StructureNotifyMask, for ConfigureNotify
+  // GDK_PROPERTY_CHANGE_MASK ==> PropertyChangeMask, for PropertyNotify
+  gdk_window_set_events(mRootWindow,
+                        GdkEventMask(gdk_window_get_events(mRootWindow) |
+                                     GDK_STRUCTURE_MASK |
+                                     GDK_PROPERTY_CHANGE_MASK));
+  gdk_window_add_filter(mRootWindow, root_window_event_filter, this);
+  mNetWorkareaAtom =
+    XInternAtom(GDK_WINDOW_XDISPLAY(mRootWindow), "_NET_WORKAREA", False);
+
+  return Init();
+}
+
+nsresult
+nsScreenManagerGtk :: Init()
+{
     XineramaScreenInfo *screenInfo = NULL;
 
     if (!mXineramalib) {
@@ -109,7 +168,7 @@ nsScreenManagerGtk :: EnsureInit(void)
         return NS_ERROR_OUT_OF_MEMORY;
       }
 
-      screen->Init();
+      screen->Init(mRootWindow);
     }
     // If Xinerama is enabled and there's more than one screen, fill
     // in the info for all of the screens.  If that's not the case
diff --git a/widget/src/gtk2/nsScreenManagerGtk.h b/widget/src/gtk2/nsScreenManagerGtk.h
--- a/widget/src/gtk2/nsScreenManagerGtk.h
+++ b/widget/src/gtk2/nsScreenManagerGtk.h
@@ -44,6 +44,8 @@
 #include "nsCOMPtr.h"
 #include "nsCOMArray.h"
 #include "prlink.h"
+#include "gdk/gdk.h"
+#include <X11/Xlib.h>
 
 //------------------------------------------------------------------------
 
@@ -70,6 +72,9 @@ private:
   int mNumScreens;
 
   PRLibrary *mXineramalib;
+
+  GdkWindow *mRootWindow;
+  Atom mNetWorkareaAtom;
 };
 
 #endif  // nsScreenManagerGtk_h___ 
