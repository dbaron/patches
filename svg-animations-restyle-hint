From: L. David Baron <dbaron@dbaron.org>

Bug 1058346 patch 2 - Add eRestyle_SVGAttrAnimations and support it in nsStyleSet::RuleNodeWithReplacement.  r=birtles

This allows posting a restyle that says that only the rule(s) from the
SVGAttrAnimationSheet cascade level will be replaced, which avoids running
selector matching.

This is needed to land bug 977991 prior to landing bug 960465, since
that requires replacing all levels that contain animations.

(I'll rename this to match the name determined in bug 1057231.)

diff --git a/layout/base/nsChangeHint.h b/layout/base/nsChangeHint.h
--- a/layout/base/nsChangeHint.h
+++ b/layout/base/nsChangeHint.h
@@ -300,20 +300,27 @@ enum nsRestyleHint {
 
   // Replace the style data coming from CSS animations without updating
   // any other style data.  If a new style context results, update style
   // contexts on the descendants.  (Irrelevant if eRestyle_Self or
   // eRestyle_Subtree is also set, since those imply a superset of the
   // work.)
   eRestyle_CSSAnimations = (1<<4),
 
+  // Replace the style data coming from SVG animations (SMIL Animations)
+  // without updating any other style data.  If a new style context
+  // results, update style contexts on the descendants.  (Irrelevant if
+  // eRestyle_Self or eRestyle_Subtree is also set, since those imply a
+  // superset of the work.)
+  eRestyle_SVGAttrAnimations = (1<<5),
+
   // Continue the restyling process to the current frame's children even
   // if this frame's restyling resulted in no style changes.
-  eRestyle_Force = (1<<5),
+  eRestyle_Force = (1<<8),
 
   // Continue the restyling process to all of the current frame's
   // descendants, even if any frame's restyling resulted in no style
   // changes.  (Implies eRestyle_Force.)
-  eRestyle_ForceDescendants = (1<<6),
+  eRestyle_ForceDescendants = (1<<9),
 };
 
 
 #endif /* nsChangeHint_h___ */
diff --git a/layout/style/SVGAttrAnimationRuleProcessor.cpp b/layout/style/SVGAttrAnimationRuleProcessor.cpp
--- a/layout/style/SVGAttrAnimationRuleProcessor.cpp
+++ b/layout/style/SVGAttrAnimationRuleProcessor.cpp
@@ -71,27 +71,36 @@ SVGAttrAnimationRuleProcessor::HasAttrib
 SVGAttrAnimationRuleProcessor::MediumFeaturesChanged(nsPresContext* aPresContext)
 {
   return false;
 }
 
 /* virtual */ void
 SVGAttrAnimationRuleProcessor::RulesMatching(PseudoElementRuleProcessorData* aData)
 {
+  // If SMIL Animation of SVG attributes can ever target
+  // pseudo-elements, we need to adjust either
+  // nsStyleSet::RuleNodeWithReplacement or the test in
+  // ElementRestyler::RestyleSelf (added in bug 977991 patch 4) to
+  // handle such styles.
 }
 
 /* virtual */ void
 SVGAttrAnimationRuleProcessor::RulesMatching(AnonBoxRuleProcessorData* aData)
 {
+  // If SMIL Animation of SVG attributes can ever target anonymous boxes,
+  // see comment in RulesMatching(PseudoElementRuleProcessorData*).
 }
 
 #ifdef MOZ_XUL
 /* virtual */ void
 SVGAttrAnimationRuleProcessor::RulesMatching(XULTreeRuleProcessorData* aData)
 {
+  // If SMIL Animation of SVG attributes can ever target XUL tree pseudos,
+  // see comment in RulesMatching(PseudoElementRuleProcessorData*).
 }
 #endif
 
 /* virtual */ size_t
 SVGAttrAnimationRuleProcessor::SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const
 {
   return 0; // SVGAttrAnimationRuleProcessors are charged to the DOM, not layout
 }
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1330,17 +1330,17 @@ struct CascadeLevel {
   bool mIsImportant;
   nsRestyleHint mLevelReplacementHint;
 };
 
 static const CascadeLevel gCascadeLevels[] = {
   { nsStyleSet::eAgentSheet,      false, nsRestyleHint(0) },
   { nsStyleSet::eUserSheet,       false, nsRestyleHint(0) },
   { nsStyleSet::ePresHintSheet,   false, nsRestyleHint(0) },
-  { nsStyleSet::eSVGAttrAnimationSheet, false, nsRestyleHint(0) },
+  { nsStyleSet::eSVGAttrAnimationSheet, false, eRestyle_SVGAttrAnimations },
   { nsStyleSet::eDocSheet,        false, nsRestyleHint(0) },
   { nsStyleSet::eScopedDocSheet,  false, nsRestyleHint(0) },
   { nsStyleSet::eStyleAttrSheet,  false, nsRestyleHint(0) },
   { nsStyleSet::eOverrideSheet,   false, nsRestyleHint(0) },
   { nsStyleSet::eAnimationSheet,  false, eRestyle_CSSAnimations },
   { nsStyleSet::eScopedDocSheet,  true,  nsRestyleHint(0) },
   { nsStyleSet::eDocSheet,        true,  nsRestyleHint(0) },
   { nsStyleSet::eStyleAttrSheet,  true,  nsRestyleHint(0) },
@@ -1353,16 +1353,17 @@ static const CascadeLevel gCascadeLevels
 nsRuleNode*
 nsStyleSet::RuleNodeWithReplacement(Element* aElement,
                                     nsRuleNode* aOldRuleNode,
                                     nsCSSPseudoElements::Type aPseudoType,
                                     nsRestyleHint aReplacements)
 {
   NS_ABORT_IF_FALSE(!(aReplacements & ~(eRestyle_CSSTransitions |
                                         eRestyle_CSSAnimations |
+                                        eRestyle_SVGAttrAnimations |
                                         eRestyle_Force |
                                         eRestyle_ForceDescendants)),
                     // FIXME: Once bug 979133 lands we'll have a better
                     // way to print these.
                     nsPrintfCString("unexpected replacement bits 0x%lX",
                                     uint32_t(aReplacements)).get());
 
   // FIXME (perf): This should probably not rebuild the whole path, but
@@ -1426,16 +1427,26 @@ nsStyleSet::RuleNodeWithReplacement(Elem
               presContext->RefreshDriver()->MostRecentRefresh(),
               EnsureStyleRule_IsNotThrottled);
             if (collection->mStyleRule) {
               ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
             }
           }
           break;
         }
+        case eRestyle_SVGAttrAnimations: {
+          SVGAttrAnimationRuleProcessor* ruleProcessor =
+            static_cast<SVGAttrAnimationRuleProcessor*>(
+              mRuleProcessors[eSVGAttrAnimationSheet].get());
+          if (ruleProcessor &&
+              aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
+            ruleProcessor->ElementRulesMatching(aElement, &ruleWalker);
+          }
+          break;
+        }
         default:
           break;
       }
     }
 
     while (rulesIndex != 0) {
       --rulesIndex;
       const RuleNodeInfo& ruleInfo = rules[rulesIndex];
