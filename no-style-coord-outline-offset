Convert outline offset storage from nsStyleCoord to nscoord.  (Bug 443057)  r+sr=bzbarsky

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -706,18 +706,17 @@ nsCSSRendering::PaintOutline(nsPresConte
       // the border.
       nsRect r(GetOutlineInnerRect(frameForArea) +
                frameForArea->GetOffsetTo(aForFrame));
       innerRect.UnionRect(innerRect, r);
     }
   }
 
   innerRect += aBorderArea.TopLeft();
-  nscoord offset;
-  aOutlineStyle.GetOutlineOffset(offset);
+  nscoord offset = aOutlineStyle.mOutlineOffset;
   innerRect.Inflate(offset, offset);
   // If the dirty rect is completely inside the border area (e.g., only the
   // content is being painted), then we can skip out now
   // XXX this isn't exactly true for rounded borders, where the inside curves may
   // encroach into the content area.  A safer calculation would be to
   // shorten insideRect by the radius one each side before performing this test.
   if (innerRect.Contains(aDirtyRect))
     return;
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -588,19 +588,17 @@ nsDisplayOutline::OptimizeVisibility(nsD
                                      nsRegion* aVisibleRegion) {
   if (!nsDisplayItem::OptimizeVisibility(aBuilder, aVisibleRegion))
     return PR_FALSE;
 
   const nsStyleOutline* outline = mFrame->GetStyleOutline();
   nsPoint origin = aBuilder->ToReferenceFrame(mFrame);
   if (nsRect(origin, mFrame->GetSize()).Contains(aVisibleRegion->GetBounds()) &&
       !nsLayoutUtils::HasNonZeroSide(outline->mOutlineRadius)) {
-    nscoord outlineOffset;
-    outline->GetOutlineOffset(outlineOffset);
-    if (outlineOffset >= 0) {
+    if (outline->mOutlineOffset >= 0) {
       // the visible region is entirely inside the border-rect, and the outline
       // isn't rendered inside the border-rect, so the outline is not visible
       return PR_FALSE;
     }
   }
 
   return PR_TRUE;
 }
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -3704,18 +3704,17 @@ ComputeOutlineAndEffectsRect(nsIFrame* a
 #endif
       outline->GetOutlineWidth(width);
     NS_ASSERTION(result, "GetOutlineWidth had no cached outline width");
     if (width > 0) {
       if (aStoreRectProperties) {
         SetRectProperty(aFrame, nsGkAtoms::outlineInnerRectProperty, r);
       }
 
-      nscoord offset;
-      outline->GetOutlineOffset(offset);
+      nscoord offset = outline->mOutlineOffset;
       nscoord inflateBy = PR_MAX(width + offset, 0);
       r.Inflate(inflateBy, inflateBy);
       *aAnyOutlineOrEffects = PR_TRUE;
     }
   }
   
   // Note that we don't remove the outlineInnerRect if a frame loses outline
   // style. That would require an extra property lookup for every frame,
diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -1542,17 +1542,17 @@ nsComputedDOMStyle::GetOutlineStyle(nsID
 }
 
 nsresult
 nsComputedDOMStyle::GetOutlineOffset(nsIDOMCSSValue** aValue)
 {
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 
-  SetValueToCoord(val, GetStyleOutline()->mOutlineOffset);
+  val->SetAppUnits(GetStyleOutline()->mOutlineOffset);
 
   return CallQueryInterface(val, aValue);
 }
 
 nsresult
 nsComputedDOMStyle::GetOutlineRadiusBottomLeft(nsIDOMCSSValue** aValue)
 {
   return GetOutlineRadiusFor(NS_SIDE_LEFT, aValue);
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -3904,20 +3904,26 @@ nsRuleNode::ComputeOutlineData(void* aSt
   }
   else {
     SetCoord(marginData.mOutlineWidth, outline->mOutlineWidth,
              parentOutline->mOutlineWidth, SETCOORD_LEH, aContext,
              mPresContext, inherited);
   }
 
   // outline-offset: length, inherit
-  SetCoord(marginData.mOutlineOffset, outline->mOutlineOffset, parentOutline->mOutlineOffset,
-           SETCOORD_LH | SETCOORD_INITIAL_ZERO, aContext, mPresContext,
-           inherited);
-  
+  nsStyleCoord tempCoord;
+  if (SetCoord(marginData.mOutlineOffset, tempCoord,
+               parentOutline->mOutlineOffset,
+               SETCOORD_LH | SETCOORD_INITIAL_ZERO, aContext, mPresContext,
+               inherited)) {
+    outline->mOutlineOffset = tempCoord.GetCoordValue();
+  } else {
+    NS_ASSERTION(marginData.mOutlineOffset.GetUnit() == eCSSUnit_Null,
+                 "unexpected unit");
+  }
 
   // outline-color: color, string, enum, inherit
   nscolor outlineColor;
   nscolor unused = NS_RGB(0,0,0);
   if (eCSSUnit_Inherit == marginData.mOutlineColor.GetUnit()) {
     if (parentContext) {
       inherited = PR_TRUE;
       if (parentOutline->GetOutlineColor(outlineColor))
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -511,17 +511,17 @@ nsStyleOutline::nsStyleOutline(nsPresCon
 nsStyleOutline::nsStyleOutline(nsPresContext* aPresContext)
 {
   // spacing values not inherited
   nsStyleCoord zero(0);
   NS_FOR_CSS_SIDES(side) {
     mOutlineRadius.Set(side, zero);
   }
 
-  mOutlineOffset.SetCoordValue(0);
+  mOutlineOffset = 0;
 
   mOutlineWidth = nsStyleCoord(NS_STYLE_BORDER_WIDTH_MEDIUM, eStyleUnit_Enumerated);
   mOutlineStyle = NS_STYLE_BORDER_STYLE_NONE;
   mOutlineColor = NS_RGB(0, 0, 0);
 
   mHasCachedOutline = PR_FALSE;
   mTwipsPerPixel = aPresContext->DevPixelsToAppUnits(1);
 }
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -612,34 +612,20 @@ struct nsStyleOutline {
   nsChangeHint CalcDifference(const nsStyleOutline& aOther) const;
 #ifdef DEBUG
   static nsChangeHint MaxDifference();
 #endif
  
   nsStyleSides  mOutlineRadius;    // [reset] length, percent
                                    // (top=topLeft, right=topRight, bottom=bottomRight, left=bottomLeft)
 
-  // Note that these are specified values.  You can get the actual values with
-  // GetOutlineWidth and GetOutlineOffset.  You cannot get the computed values
-  // directly.
-  nsStyleCoord  mOutlineOffset;   // [reset] length XXX Why nsStyleCoord?
+  // Note that this is a specified value.  You can get the actual values
+  // with GetOutlineWidth.  You cannot get the computed value directly.
   nsStyleCoord  mOutlineWidth;    // [reset] length, enum (see nsStyleConsts.h)
-
-  PRBool GetOutlineOffset(nscoord& aOffset) const
-  {
-    if (mOutlineOffset.GetUnit() == eStyleUnit_Coord) {
-      nscoord offset = mOutlineOffset.GetCoordValue();
-      aOffset = NS_ROUND_OFFSET_TO_PIXELS(offset, mTwipsPerPixel);
-      return PR_TRUE;
-    } else {
-      NS_ERROR("GetOutlineOffset: bad unit type");
-      aOffset = 0;
-      return PR_FALSE;
-    }
-  }
+  nscoord       mOutlineOffset;   // [reset]
 
   PRBool GetOutlineWidth(nscoord& aWidth) const
   {
     if (mHasCachedOutline) {
       aWidth = mCachedOutlineWidth;
       return PR_TRUE;
     }
     return PR_FALSE;
