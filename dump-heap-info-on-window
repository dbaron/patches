From: L. David Baron <dbaron@dbaron.org>

Add a DumpHeapInfo method on the window object to dump the output of mallinfo(), /proc/pid/maps, and /proc/pid/status.

diff --git a/dom/base/nsJSEnvironment.cpp b/dom/base/nsJSEnvironment.cpp
--- a/dom/base/nsJSEnvironment.cpp
+++ b/dom/base/nsJSEnvironment.cpp
@@ -3201,16 +3201,93 @@ static JSFunctionSpec TraceMallocFunctio
     {"TraceMallocCloseLogFD",      TraceMallocCloseLogFD,      1, 0},
     {"TraceMallocLogTimestamp",    TraceMallocLogTimestamp,    1, 0},
     {"TraceMallocDumpAllocations", TraceMallocDumpAllocations, 1, 0},
     {nsnull,                       nsnull,                     0, 0}
 };
 
 #endif /* NS_TRACE_MALLOC */
 
+#ifdef LINUX
+
+#include <malloc.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+
+static void
+dump_mallinfo(FILE *ofp)
+{
+    struct mallinfo mi = mallinfo();
+    fprintf(ofp,
+            "%8d non-mmapped space allocated from system (bytes)\n"
+            "%8d free chunks (count)\n"
+            "%8d fastbin blocks (count)\n"
+            "%8d mmapped regions (count)\n"
+            "%8d space in mmapped regions (bytes)\n"
+            "%8d maximum total allocated space (bytes)\n"
+            "%8d space available in freed fastbin blocks (bytes)\n"
+            "%8d total allocated space (bytes)\n"
+            "%8d total free space (bytes)\n"
+            "%8d top-most, releasable (via malloc_trim) space (bytes)\n",
+            mi.arena, mi.ordblks, mi.smblks, mi.hblks, mi.hblkhd,
+            mi.usmblks, mi.fsmblks, mi.uordblks, mi.fordblks, mi.keepcost);
+}
+
+static void
+dump_pid_proc_file(FILE *ofp, const char* procfile)
+{
+    char filename[40];
+    snprintf(filename, sizeof(filename),
+             "/proc/%d/%s", getpid(), procfile);
+    FILE *in = fopen(filename, "r");
+    if (!in)
+        return;
+
+    char buf[8192];
+    while (!feof(in)) {
+        size_t s = fread(buf, 1, sizeof(buf), in);
+        fwrite(buf, 1, s, ofp);
+    }
+
+    fclose(in);
+}
+
+static JSBool
+DumpHeapInfo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSString *str = JS_ValueToString(cx, argv[0]);
+    if (!str)
+        return JS_FALSE;
+    const char *pathname = JS_GetStringBytes(str);
+    FILE *ofp = fopen(pathname, "w");
+    if (!ofp) {
+        JS_ReportError(cx, "can't dump to %s: %s", pathname, strerror(errno));
+        return JS_FALSE;
+    }
+
+    dump_mallinfo(ofp);
+    fprintf(ofp, "-----\n");
+    dump_pid_proc_file(ofp, "maps");
+    fprintf(ofp, "-----\n");
+    dump_pid_proc_file(ofp, "status");
+    fprintf(ofp, "-----\n");
+
+    fclose(ofp);
+
+    return JS_TRUE;
+}
+
+static JSFunctionSpec DumpHeapFunctions[] = {
+    {"DumpHeapInfo",               DumpHeapInfo,               1, 0},
+    {nsnull,                       nsnull,                     0, 0}
+};
+#endif
+
 #ifdef MOZ_JPROF
 
 #include <signal.h>
 
 inline PRBool
 IsJProfAction(struct sigaction *action)
 {
     return (action->sa_sigaction &&
@@ -3341,16 +3418,20 @@ nsJSContext::InitClasses(void *aGlobalOb
     rv = NS_ERROR_FAILURE;
   }
 
 #ifdef NS_TRACE_MALLOC
   // Attempt to initialize TraceMalloc functions
   ::JS_DefineFunctions(mContext, globalObj, TraceMallocFunctions);
 #endif
 
+#ifdef LINUX
+  ::JS_DefineFunctions(mContext, globalObj, DumpHeapFunctions);
+#endif
+
 #ifdef MOZ_JPROF
   // Attempt to initialize JProf functions
   ::JS_DefineFunctions(mContext, globalObj, JProfFunctions);
 #endif
 
 #ifdef MOZ_SHARK
   // Attempt to initialize Shark functions
   ::JS_DefineFunctions(mContext, globalObj, SharkFunctions);
