From: L. David Baron <dbaron@dbaron.org>

Add a DumpHeapInfo method on the window object to dump the output of mallinfo(), /proc/pid/maps, and /proc/pid/status.

diff --git a/dom/base/nsJSEnvironment.cpp b/dom/base/nsJSEnvironment.cpp
--- a/dom/base/nsJSEnvironment.cpp
+++ b/dom/base/nsJSEnvironment.cpp
@@ -1528,16 +1528,94 @@ ReportAndDump(JSContext *cx, unsigned ar
 
 static const JSFunctionSpec DMDFunctions[] = {
     JS_FS("DMDReportAndDump", dmd::ReportAndDump, 1, 0),
     JS_FS_END
 };
 
 #endif  // defined(MOZ_DMD)
 
+#ifdef LINUX
+
+#include <malloc.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+
+static void
+dump_mallinfo(FILE *ofp)
+{
+    struct mallinfo mi = mallinfo();
+    fprintf(ofp,
+            "%8d non-mmapped space allocated from system (bytes)\n"
+            "%8d free chunks (count)\n"
+            "%8d fastbin blocks (count)\n"
+            "%8d mmapped regions (count)\n"
+            "%8d space in mmapped regions (bytes)\n"
+            "%8d maximum total allocated space (bytes)\n"
+            "%8d space available in freed fastbin blocks (bytes)\n"
+            "%8d total allocated space (bytes)\n"
+            "%8d total free space (bytes)\n"
+            "%8d top-most, releasable (via malloc_trim) space (bytes)\n",
+            mi.arena, mi.ordblks, mi.smblks, mi.hblks, mi.hblkhd,
+            mi.usmblks, mi.fsmblks, mi.uordblks, mi.fordblks, mi.keepcost);
+}
+
+static void
+dump_pid_proc_file(FILE *ofp, const char* procfile)
+{
+    char filename[40];
+    snprintf(filename, sizeof(filename),
+             "/proc/%d/%s", getpid(), procfile);
+    FILE *in = fopen(filename, "r");
+    if (!in)
+        return;
+
+    char buf[8192];
+    while (!feof(in)) {
+        size_t s = fread(buf, 1, sizeof(buf), in);
+        fwrite(buf, 1, s, ofp);
+    }
+
+    fclose(in);
+}
+
+static bool
+DumpHeapInfo(JSContext *cx, unsigned argc, jsval *vp)
+{
+    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
+    JSString *str = JS::ToString(cx, args.get(0));
+    if (!str)
+        return false;
+    JSAutoByteString pathname(cx, str);
+    FILE *ofp = fopen(pathname.ptr(), "w");
+    if (!ofp) {
+        JS_ReportError(cx, "can't dump to %s: %s", pathname.ptr(), strerror(errno));
+        return false;
+    }
+
+    dump_mallinfo(ofp);
+    fprintf(ofp, "-----\n");
+    dump_pid_proc_file(ofp, "maps");
+    fprintf(ofp, "-----\n");
+    dump_pid_proc_file(ofp, "status");
+    fprintf(ofp, "-----\n");
+
+    fclose(ofp);
+
+    return true;
+}
+
+static JSFunctionSpec DumpHeapFunctions[] = {
+    JS_FS("DumpHeapInfo", DumpHeapInfo, 1, 0),
+    JS_FS_END
+};
+#endif
+
 #ifdef MOZ_JPROF
 
 #include <signal.h>
 
 inline bool
 IsJProfAction(struct sigaction *action)
 {
     return (action->sa_sigaction &&
@@ -1658,16 +1736,20 @@ nsJSContext::InitClasses(JS::Handle<JSOb
 
 #ifdef MOZ_DMD
   if (nsContentUtils::IsCallerChrome()) {
     // Attempt to initialize DMD functions
     ::JS_DefineFunctions(cx, aGlobalObj, DMDFunctions);
   }
 #endif
 
+#ifdef LINUX
+  ::JS_DefineFunctions(cx, aGlobalObj, DumpHeapFunctions);
+#endif
+
 #ifdef MOZ_JPROF
   // Attempt to initialize JProf functions
   ::JS_DefineFunctions(cx, aGlobalObj, JProfFunctions);
 #endif
 
   return rv;
 }
 
