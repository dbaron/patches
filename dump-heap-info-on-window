From: L. David Baron <dbaron@dbaron.org>

Add a DumpHeapInfo method on the window object to dump the output of mallinfo(), /proc/pid/maps, and /proc/pid/status.

diff --git a/dom/base/nsJSEnvironment.cpp b/dom/base/nsJSEnvironment.cpp
--- a/dom/base/nsJSEnvironment.cpp
+++ b/dom/base/nsJSEnvironment.cpp
@@ -1001,16 +1001,94 @@ nsJSContext::AddSupportsPrimitiveTojsval
       NS_WARNING("Unknown primitive type used");
       aArgv->setNull();
       break;
     }
   }
   return NS_OK;
 }
 
+#ifdef LINUX
+
+#include <malloc.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+
+static void
+dump_mallinfo(FILE *ofp)
+{
+    struct mallinfo mi = mallinfo();
+    fprintf(ofp,
+            "%8d non-mmapped space allocated from system (bytes)\n"
+            "%8d free chunks (count)\n"
+            "%8d fastbin blocks (count)\n"
+            "%8d mmapped regions (count)\n"
+            "%8d space in mmapped regions (bytes)\n"
+            "%8d maximum total allocated space (bytes)\n"
+            "%8d space available in freed fastbin blocks (bytes)\n"
+            "%8d total allocated space (bytes)\n"
+            "%8d total free space (bytes)\n"
+            "%8d top-most, releasable (via malloc_trim) space (bytes)\n",
+            mi.arena, mi.ordblks, mi.smblks, mi.hblks, mi.hblkhd,
+            mi.usmblks, mi.fsmblks, mi.uordblks, mi.fordblks, mi.keepcost);
+}
+
+static void
+dump_pid_proc_file(FILE *ofp, const char* procfile)
+{
+    char filename[40];
+    snprintf(filename, sizeof(filename),
+             "/proc/%d/%s", getpid(), procfile);
+    FILE *in = fopen(filename, "r");
+    if (!in)
+        return;
+
+    char buf[8192];
+    while (!feof(in)) {
+        size_t s = fread(buf, 1, sizeof(buf), in);
+        fwrite(buf, 1, s, ofp);
+    }
+
+    fclose(in);
+}
+
+static bool
+DumpHeapInfo(JSContext *cx, unsigned argc, JS::Value *vp)
+{
+    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
+    JSString *str = JS::ToString(cx, args.get(0));
+    if (!str)
+        return false;
+    JSAutoByteString pathname(cx, str);
+    FILE *ofp = fopen(pathname.ptr(), "w");
+    if (!ofp) {
+        JS_ReportErrorLatin1(cx, "can't dump to %s: %s", pathname.ptr(), strerror(errno));
+        return false;
+    }
+
+    dump_mallinfo(ofp);
+    fprintf(ofp, "-----\n");
+    dump_pid_proc_file(ofp, "maps");
+    fprintf(ofp, "-----\n");
+    dump_pid_proc_file(ofp, "status");
+    fprintf(ofp, "-----\n");
+
+    fclose(ofp);
+
+    return true;
+}
+
+static JSFunctionSpec DumpHeapFunctions[] = {
+    JS_FS("DumpHeapInfo", DumpHeapInfo, 1, 0),
+    JS_FS_END
+};
+#endif
+
 #ifdef MOZ_JPROF
 
 #include <signal.h>
 
 inline bool
 IsJProfAction(struct sigaction *action)
 {
     return (action->sa_sigaction &&
@@ -1116,16 +1194,20 @@ nsJSContext::InitClasses(JS::Handle<JSOb
   AutoJSAPI jsapi;
   jsapi.Init();
   JSContext* cx = jsapi.cx();
   JSAutoCompartment ac(cx, aGlobalObj);
 
   // Attempt to initialize profiling functions
   ::JS_DefineProfilingFunctions(cx, aGlobalObj);
 
+#ifdef LINUX
+  ::JS_DefineFunctions(cx, aGlobalObj, DumpHeapFunctions);
+#endif
+
 #ifdef MOZ_JPROF
   // Attempt to initialize JProf functions
   ::JS_DefineFunctions(cx, aGlobalObj, JProfFunctions);
 #endif
 
   return NS_OK;
 }
 
