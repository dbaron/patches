From: L. David Baron <dbaron@dbaron.org>

Build font data structure by walking the necessary text.  (Bug 706193, bug 707195)

diff --git a/layout/generic/nsFontInflationData.cpp b/layout/generic/nsFontInflationData.cpp
--- a/layout/generic/nsFontInflationData.cpp
+++ b/layout/generic/nsFontInflationData.cpp
@@ -34,37 +34,167 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* Per-block-formatting-context manager of font size inflation for pan and zoom UI. */
 
 #include "nsFontInflationData.h"
 #include "FramePropertyTable.h"
+#include "nsTextFragment.h"
 
 using namespace mozilla;
 
 static void
 DestroyFontInflationData(void *aPropertyValue)
 {
   delete static_cast<nsFontInflationData*>(aPropertyValue);
 }
 
 NS_DECLARE_FRAME_PROPERTY(FontInflationDataProperty, DestroyFontInflationData);
 
 /* static */ nsFontInflationData*
 nsFontInflationData::FontInflationDataFor(nsIFrame *aFrame)
 {
   // We have one set of font inflation data per block formatting context.
-  FrameProperties bfcProps = BlockFormattingContextFor(aFrame)->Properties();
+  nsIFrame *bfc = BlockFormattingContextFor(aFrame);
+  FrameProperties bfcProps = bfc->Properties();
 
   // If we already have a data object, return it.
   nsFontInflationData *data = static_cast<nsFontInflationData*>(
                                 bfcProps.Get(FontInflationDataProperty()));
   if (data) {
     return data;
   }
 
   // Otherwise, make a new data object.
-  data = new nsFontInflationData();
+  data = new nsFontInflationData(bfc);
   bfcProps.Set(FontInflationDataProperty(), data);
   return data;
 }
+
+nsFontInflationData::nsFontInflationData(nsIFrame *aFrame)
+{
+  NS_ASSERTION(IsBlockFormattingContext(aFrame),
+               "must be block formatting context");
+
+  memset(mTextAmounts, 0, sizeof(mTextAmounts));
+  memset(mMaxContainerWidths, 0, sizeof(mMaxContainerWidths));
+
+  ScanText(aFrame);
+}
+
+void
+nsFontInflationData::ScanText(nsIFrame *aFrame)
+{
+  // FIXME: Should probably only scan the text that's actually going to
+  // be inflated!
+
+  // FIXME: Need to record the widths!
+
+  nsIFrame::ChildListIterator lists(aFrame);
+  for (; !lists.IsDone(); lists.Next()) {
+    nsFrameList::Enumerator kids(lists.CurrentList());
+    for (; !kids.AtEnd(); kids.Next()) {
+      nsIFrame *kid = kids.get();
+      if (kid->GetType() == nsGkAtoms::textFrame) {
+        nsIContent *content = kid->GetContent();
+        if (content && kid == content->GetPrimaryFrame()) {
+          const nsTextFragment *frag = content->GetText();
+          const nsStyleText *styleText = kid->GetStyleText();
+
+          // This is an approximation so we don't really need anything
+          // too fancy here.
+          PRUint32 len;
+          if (styleText->WhiteSpaceIsSignificant()) {
+            len = frag->GetLength();
+          } else {
+            bool is2b = frag->Is2b();
+            union {
+              const char *s1b;
+              const PRUnichar *s2b;
+            } u;
+            if (is2b) {
+              u.s2b = frag->Get2b();
+            } else {
+              u.s1b = frag->Get1b();
+            }
+            bool prevWS = true; // more important to ignore blocks with
+                                // only whitespace than get inline boundaries
+                                // exactly right
+            len = 0;
+            for (PRUint32 i = 0, i_end = frag->GetLength(); i < i_end; ++i) {
+              PRUnichar c = is2b ? u.s2b[i] : u.s1b[i];
+              if (c == ' ' || c == '\n' || c == '\t' || c == '\r') {
+                if (!prevWS) {
+                  ++len;
+                }
+                prevWS = true;
+              } else {
+                ++len;
+                prevWS = false;
+              }
+            }
+          }
+          // FIXME: Pass a real container width
+          // FIXME: I HAVE NO IDEA HOW TO DO THIS!
+          if (len != 0) {
+            RecordText(kid->GetStyleFont()->mFont.size, len, 0);
+          }
+        }
+      } else if (!IsBlockFormattingContext(kid)) {
+        // recursive step
+        ScanText(aFrame);
+      }
+    }
+  }
+}
+
+/* static */ size_t
+nsFontInflationData::BucketForFontSize(nscoord aFontSize)
+{
+  NS_ABORT_IF_FALSE(aFontSize > 0, "RecordText should have returned early");
+  PRInt32 pixels = nsPresContext::AppUnitsToIntCSSPixels(aFontSize);
+
+  if (pixels < 16) {
+    if (pixels < 7) {
+      // 0px - 6px in bucket 0
+      return 0;
+    } else {
+      // 7px - 15px in 1 pixel increments in buckets 1-9
+      return pixels - 6;
+    }
+  } else if (pixels < 30) {
+    // 16px - 29px in 2 pixel increments in buckets 10-16
+    return pixels / 2 + 2;
+  } else if (pixels < 60) {
+    // 30px - 59px in 5 pixel increments in buckets 17-22
+    return pixels / 5 + 11;
+  } else {
+    // 60px and up in bucket 23
+    // (We don't care much about distinctions here because such text is
+    // unlikely to need inflation.)
+    return 23;
+  }
+}
+
+void
+nsFontInflationData::RecordText(nscoord aFontSize, PRUint32 aTextLength,
+                                nscoord aContainerWidth)
+{
+  if (aFontSize <= 0) {
+    // Hidden text.
+    return;
+  }
+
+  size_t bucket = BucketForFontSize(aFontSize);
+
+  PRUint32 newLength = PRUint32(mTextAmounts[bucket]) + aTextLength;
+  if (aTextLength >= PR_UINT8_MAX || newLength >= PR_UINT8_MAX) {
+    mTextAmounts[bucket] = PR_UINT8_MAX;
+  } else {
+    mTextAmounts[bucket] = newLength;
+  }
+
+  if (aContainerWidth > mMaxContainerWidths[bucket]) {
+    mMaxContainerWidths[bucket] = aContainerWidth;
+  }
+}
diff --git a/layout/generic/nsFontInflationData.h b/layout/generic/nsFontInflationData.h
--- a/layout/generic/nsFontInflationData.h
+++ b/layout/generic/nsFontInflationData.h
@@ -45,29 +45,54 @@
 #include "nsBlockFrame.h"
 
 class nsFontInflationData
 {
 public:
 
   static nsFontInflationData* FontInflationDataFor(nsIFrame *aFrame);
 
+  nsFontInflationData(nsIFrame *aFrame);
+
 private:
 
+  nsFontInflationData(const nsFontInflationData&) MOZ_DELETE;
+  void operator=(const nsFontInflationData&) MOZ_DELETE;
+
+  // Scan text in the subtree rooted at aFrame
+  void ScanText(nsIFrame* aFrame);
+
+  // We gather data about text (amount of text and width of container)
+  // categorized by font size.  This function defines how we bucket the
+  // font sizes.  (We don't want too many buckets, and it's useful to
+  // avoid having a more complex data structure.)
+  enum { eNumBuckets = 24 };
+  static size_t BucketForFontSize(nscoord aFontSize);
+
+  // Record that the scan encountered aTextLength characters of size
+  // aFontSize in a container of width aContainerWidth.
+  void RecordText(nscoord aFontSize, PRUint32 aTextLength,
+                  nscoord aContainerWidth);
+
   static nsIFrame* BlockFormattingContextFor(nsIFrame *aFrame)
   {
     while (!IsBlockFormattingContext(aFrame)) {
       aFrame = aFrame->GetParent();
     }
     return aFrame;
   }
 
   static bool IsBlockFormattingContext(nsIFrame *aFrame)
   {
     return nsLayoutUtils::IsContainerForFontSizeInflation(aFrame) &&
            ((aFrame->IsFrameOfType(nsIFrame::eBlockFrame) &&
             (aFrame->GetStateBits() & NS_BLOCK_FLOAT_MGR)) ||
             aFrame->IsFrameOfType(nsIFrame::eXULBox) ||
             !aFrame->GetParent());
   }
+
+  // The amount of text in each of the groups of font sizes.
+  PRUint8 mTextAmounts[eNumBuckets];
+  // The largest container width in each of the groups of font sizes.
+  nscoord mMaxContainerWidths[eNumBuckets];
 };
 
 #endif /* !defined(nsFontInflationData_h_) */
