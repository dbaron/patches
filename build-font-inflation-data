From: L. David Baron <dbaron@dbaron.org>

Build font data structure by walking the necessary text.  (Bug 706193)

diff --git a/layout/generic/nsFontInflationData.cpp b/layout/generic/nsFontInflationData.cpp
--- a/layout/generic/nsFontInflationData.cpp
+++ b/layout/generic/nsFontInflationData.cpp
@@ -34,28 +34,265 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* Per-block-formatting-context manager of font size inflation for pan and zoom UI. */
 
 #include "nsFontInflationData.h"
 #include "FramePropertyTable.h"
+#include "nsTextFragment.h"
+#include "nsIFormControlFrame.h"
+#include "nsHTMLReflowState.h"
 
 using namespace mozilla;
 
 static void
 DestroyFontInflationData(void *aPropertyValue)
 {
   delete static_cast<nsFontInflationData*>(aPropertyValue);
 }
 
 NS_DECLARE_FRAME_PROPERTY(FontInflationDataProperty, DestroyFontInflationData);
 
 /* static */ nsFontInflationData*
 nsFontInflationData::FindFontInflationDataFor(const nsIFrame *aFrame)
 {
   // We have one set of font inflation data per block formatting context.
   const nsIFrame *bfc = FlowRootFor(aFrame);
+  NS_ASSERTION(bfc->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT,
+               "should have found a flow root");
 
   return static_cast<nsFontInflationData*>(
              bfc->Properties().Get(FontInflationDataProperty()));
 }
+
+/* static */ nsFontInflationData*
+nsFontInflationData::CreateFontInflationDataFor(const nsHTMLReflowState& aReflowState)
+{
+  nsIFrame *bfc = aReflowState.frame;
+  NS_ASSERTION(bfc->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT,
+               "should have been given a flow root");
+
+  nsFontInflationData *data = new nsFontInflationData(aReflowState);
+  bfc->Properties().Set(FontInflationDataProperty(), data);
+  return data;
+}
+
+/* static */ void
+nsFontInflationData::MarkFontInflationDataDirty(nsIFrame *aBFCFrame)
+{
+  NS_ASSERTION(aBFCFrame->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT,
+               "should have been given a flow root");
+
+  aBFCFrame->Properties().Delete(FontInflationDataProperty());
+}
+
+
+/**
+ * Find the closest common ancestor between aFrame1 and aFrame2, except
+ * treating the parent of a frame as the first-in-flow of its parent (so
+ * the result doesn't change when breaking changes).
+ *
+ * aKnownCommonAncestor is a known common ancestor of both.
+ */
+static nsIFrame*
+NearestCommonAncestorFirstInFlow(nsIFrame *aFrame1, nsIFrame *aFrame2,
+                                 nsIFrame *aKnownCommonAncestor)
+{
+  aFrame1 = aFrame1->GetFirstInFlow();
+  aFrame2 = aFrame2->GetFirstInFlow();
+  aKnownCommonAncestor = aKnownCommonAncestor->GetFirstInFlow();
+
+  PRInt32 diff = 0;
+  for (nsIFrame *f = aFrame1; f != aKnownCommonAncestor;
+       (f = f->GetParent()) && (f = f->GetFirstInFlow())) {
+    ++diff;
+  }
+  for (nsIFrame *f = aFrame2; f != aKnownCommonAncestor;
+       (f = f->GetParent()) && (f = f->GetFirstInFlow())) {
+    --diff;
+  }
+
+  if (diff > 0) {
+    while (diff-- != 0) {
+      aFrame1 = aFrame1->GetParent()->GetFirstInFlow();
+    }
+  } else {
+    while (diff++ != 0) {
+      aFrame2 = aFrame2->GetParent()->GetFirstInFlow();
+    }
+  }
+
+  while (aFrame1 != aFrame2) {
+    aFrame1 = aFrame1->GetParent()->GetFirstInFlow();
+    aFrame2 = aFrame2->GetParent()->GetFirstInFlow();
+  }
+
+  return aFrame1;
+}
+
+static nscoord
+ComputeDescendantWidth(const nsHTMLReflowState& aAncestorReflowState,
+                       nsIFrame *aDescendantFrame)
+{
+  nsIFrame *ancestorFrame = aAncestorReflowState.frame;
+  if (aDescendantFrame == ancestorFrame) {
+    return aAncestorReflowState.ComputedWidth();
+  }
+
+  AutoInfallibleTArray<nsIFrame*, 16> frames;
+  for (nsIFrame *f = aDescendantFrame; f != ancestorFrame;
+       f = f->GetParent()) {
+    frames.AppendElement(f);
+  }
+
+  PRUint32 len = frames.Length();
+  nsHTMLReflowState *reflowStates =
+    static_cast<nsHTMLReflowState*>(malloc(sizeof(nsHTMLReflowState) * len));
+  nsPresContext *presContext = aDescendantFrame->PresContext();
+  for (PRUint32 i = 0; i < len; ++i) {
+    const nsHTMLReflowState &parentReflowState =
+      (i == 0) ? aAncestorReflowState : reflowStates[i - 1];
+    nsSize availSize(parentReflowState.ComputedWidth(), NS_UNCONSTRAINEDSIZE);
+    nsIFrame *frame = frames[len - i - 1];
+    NS_ABORT_IF_FALSE(frame->GetParent() == parentReflowState.frame,
+                      "bad logic in this function");
+    new (reflowStates + i) nsHTMLReflowState(presContext, parentReflowState,
+                                             frame, availSize);
+  }
+
+  NS_ABORT_IF_FALSE(reflowStates[len - 1].frame == aDescendantFrame,
+                    "bad logic in this function");
+  nscoord result = reflowStates[len - 1].ComputedWidth();
+
+  for (PRUint32 i = len; i-- != 0; ) {
+    reflowStates[i].~nsHTMLReflowState();
+  }
+  free (reflowStates);
+
+  return result;
+}
+
+nsFontInflationData::nsFontInflationData(const nsHTMLReflowState &aReflowState)
+{
+  nsIFrame *bfc = aReflowState.frame;
+  NS_ASSERTION(bfc->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT,
+               "must be block formatting context");
+
+  nsIFrame *firstInflatableDescendant = nsnull,
+           *lastInflatableDescendant = nsnull;
+  nscoord textEmSize =
+    ScanText(bfc, &firstInflatableDescendant, &lastInflatableDescendant);
+
+  NS_ABORT_IF_FALSE(!firstInflatableDescendant == !lastInflatableDescendant,
+                    "null-ness should match; NearestCommonAncestorFirstInFlow"
+                    " will crash when passed null");
+  if (!firstInflatableDescendant) {
+    mInflationEnabled = false;
+    return;
+  }
+
+  nsIFrame *nca = NearestCommonAncestorFirstInFlow(firstInflatableDescendant,
+                                                   lastInflatableDescendant,
+                                                   bfc);
+  while (!nsLayoutUtils::IsContainerForFontSizeInflation(nca)) {
+    nca = nca->GetParent();
+  }
+
+  nscoord ncaWidth = ComputeDescendantWidth(aReflowState, nca);
+
+  // FIXME: We could perhaps make this a pref for what multiple of
+  // ncaWidth to check.  We're currently hardcoding it to 1, which means
+  // that we're making the threshhold somewhere between 1 and 2 lines of
+  // text.
+  mInflationEnabled = textEmSize > ncaWidth;
+}
+
+nscoord
+nsFontInflationData::ScanText(nsIFrame *aFrame,
+                              nsIFrame **aFirstInflatableDescendant,
+                              nsIFrame **aLastInflatableDescendant)
+{
+  // FIXME: Should probably only scan the text that's actually going to
+  // be inflated!
+
+  nsIFormControlFrame* fcf = do_QueryFrame(aFrame);
+  if (fcf && !*aFirstInflatableDescendant) {
+    *aFirstInflatableDescendant = aFrame;
+  }
+
+  nscoord result = 0;
+  nsIFrame::ChildListIterator lists(aFrame);
+  for (; !lists.IsDone(); lists.Next()) {
+    nsFrameList::Enumerator kids(lists.CurrentList());
+    for (; !kids.AtEnd(); kids.Next()) {
+      nsIFrame *kid = kids.get();
+      if (kid->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT) {
+        // Goes in a different set of inflation data.
+        continue;
+      }
+
+      if (kid->GetType() == nsGkAtoms::textFrame) {
+        nsIContent *content = kid->GetContent();
+        if (content && kid == content->GetPrimaryFrame()) {
+          const nsTextFragment *frag = content->GetText();
+          const nsStyleText *styleText = kid->GetStyleText();
+
+          // This is an approximation so we don't really need anything
+          // too fancy here.
+          PRUint32 len;
+          if (styleText->WhiteSpaceIsSignificant()) {
+            len = frag->GetLength();
+          } else {
+            bool is2b = frag->Is2b();
+            union {
+              const char *s1b;
+              const PRUnichar *s2b;
+            } u;
+            if (is2b) {
+              u.s2b = frag->Get2b();
+            } else {
+              u.s1b = frag->Get1b();
+            }
+            bool prevWS = true; // more important to ignore blocks with
+                                // only whitespace than get inline boundaries
+                                // exactly right
+            len = 0;
+            for (PRUint32 i = 0, i_end = frag->GetLength(); i < i_end; ++i) {
+              PRUnichar c = is2b ? u.s2b[i] : u.s1b[i];
+              if (c == ' ' || c == '\n' || c == '\t' || c == '\r') {
+                if (!prevWS) {
+                  ++len;
+                }
+                prevWS = true;
+              } else {
+                ++len;
+                prevWS = false;
+              }
+            }
+          }
+          if (len != 0) {
+            if (!*aFirstInflatableDescendant) {
+              *aFirstInflatableDescendant = kid;
+            }
+            *aLastInflatableDescendant = kid;
+
+            nscoord fontSize = kid->GetStyleFont()->mFont.size;
+            if (fontSize > 0) {
+              result += fontSize * len;
+            }
+          }
+        }
+      } else {
+        // recursive step
+        result +=
+          ScanText(kid, aFirstInflatableDescendant, aLastInflatableDescendant);
+      }
+    }
+  }
+
+  if (fcf) {
+    *aLastInflatableDescendant = aFrame;
+  }
+
+  return result;
+}
diff --git a/layout/generic/nsFontInflationData.h b/layout/generic/nsFontInflationData.h
--- a/layout/generic/nsFontInflationData.h
+++ b/layout/generic/nsFontInflationData.h
@@ -39,27 +39,48 @@
 
 #ifndef nsFontInflationData_h_
 #define nsFontInflationData_h_
 
 #include "nsIFrame.h"
 #include "nsLayoutUtils.h"
 #include "nsBlockFrame.h"
 
+struct nsHTMLReflowState;
+
 class nsFontInflationData
 {
 public:
 
   static nsFontInflationData* FindFontInflationDataFor(const nsIFrame *aFrame);
 
+  static nsFontInflationData*
+    CreateFontInflationDataFor(const nsHTMLReflowState& aReflowState);
+
+  static void MarkFontInflationDataDirty(nsIFrame *aFrame);
+
 private:
 
+  nsFontInflationData(const nsHTMLReflowState& aReflowState);
+
+  nsFontInflationData(const nsFontInflationData&) MOZ_DELETE;
+  void operator=(const nsFontInflationData&) MOZ_DELETE;
+
+  // Scan text in the subtree rooted at aFrame.  Returns the result of
+  // multiplying the number of characters found by the font size
+  // (yielding the width that would be occupied by the characters if
+  // they were all em squares).
+  nscoord ScanText(nsIFrame *aFrame,
+                   nsIFrame **aFirstInflatableDescendant,
+                   nsIFrame **aLastInflatableDescendant);
+
   static const nsIFrame* FlowRootFor(const nsIFrame *aFrame)
   {
     while (!aFrame->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT) {
       aFrame = aFrame->GetParent();
     }
     return aFrame;
   }
 
+  bool mInflationEnabled; // for this BFC
 };
 
 #endif /* !defined(nsFontInflationData_h_) */
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -121,16 +121,17 @@
 #include "nsSVGEffects.h"
 #include "nsChangeHint.h"
 #include "nsDeckFrame.h"
 
 #include "gfxContext.h"
 #include "nsRenderingContext.h"
 #include "CSSCalc.h"
 #include "nsAbsoluteContainingBlock.h"
+#include "nsFontInflationData.h"
 
 #include "mozilla/Preferences.h"
 #include "mozilla/LookAndFeel.h"
 
 using namespace mozilla;
 using namespace mozilla::layers;
 using namespace mozilla::layout;
 
@@ -3557,16 +3558,20 @@ nsFrame::MarkIntrinsicWidthsDirty()
     SizeNeedsRecalc(metrics->mPrefSize);
     SizeNeedsRecalc(metrics->mMinSize);
     SizeNeedsRecalc(metrics->mMaxSize);
     SizeNeedsRecalc(metrics->mBlockPrefSize);
     SizeNeedsRecalc(metrics->mBlockMinSize);
     CoordNeedsRecalc(metrics->mFlex);
     CoordNeedsRecalc(metrics->mAscent);
   }
+
+  if (GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT) {
+    nsFontInflationData::MarkFontInflationDataDirty(this);
+  }
 }
 
 /* virtual */ nscoord
 nsFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
 {
   nscoord result = 0;
   DISPLAY_MIN_WIDTH(this, result);
   return result;
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -51,19 +51,18 @@
 #include "nsLineBox.h"
 #include "nsImageFrame.h"
 #include "nsTableFrame.h"
 #include "nsTableCellFrame.h"
 #include "nsIServiceManager.h"
 #include "nsIPercentHeightObserver.h"
 #include "nsLayoutUtils.h"
 #include "mozilla/Preferences.h"
-#ifdef IBMBIDI
 #include "nsBidiUtils.h"
-#endif
+#include "nsFontInflationData.h"
 
 #ifdef NS_DEBUG
 #undef NOISY_VERTICAL_ALIGN
 #else
 #undef NOISY_VERTICAL_ALIGN
 #endif
 
 using namespace mozilla;
@@ -311,16 +310,21 @@ nsHTMLReflowState::Init(nsPresContext* a
 
   NS_WARN_IF_FALSE((mFrameType == NS_CSS_FRAME_TYPE_INLINE &&
                     !frame->IsFrameOfType(nsIFrame::eReplaced)) ||
                    type == nsGkAtoms::textFrame ||
                    mComputedWidth != NS_UNCONSTRAINEDSIZE,
                    "have unconstrained width; this should only result from "
                    "very large sizes, not attempts at intrinsic width "
                    "calculation");
+
+  if (frame->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT) {
+    // Destroy and re-create our font inflation data.
+    nsFontInflationData::CreateFontInflationDataFor(*this);
+  }
 }
 
 void nsHTMLReflowState::InitCBReflowState()
 {
   if (!parentReflowState) {
     mCBReflowState = nsnull;
     return;
   }
