From: L. David Baron <dbaron@dbaron.org>

Fix serialization of tree pseudo-elements with arguments.

diff --git a/layout/style/nsCSSAnonBoxes.cpp b/layout/style/nsCSSAnonBoxes.cpp
--- a/layout/style/nsCSSAnonBoxes.cpp
+++ b/layout/style/nsCSSAnonBoxes.cpp
@@ -37,16 +37,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 /* atom list for CSS anonymous boxes */
 
 #include "nsCSSAnonBoxes.h"
 #include "nsAtomListUtils.h"
 #include "nsStaticAtom.h"
 #include "nsMemory.h"
+#include "nsCRT.h"
 
 // define storage for all atoms
 #define CSS_ANON_BOX(_name, _value) \
   nsICSSAnonBoxPseudo* nsCSSAnonBoxes::_name;
 #include "nsCSSAnonBoxList.h"
 #undef CSS_ANON_BOX
 
 static const nsStaticAtom CSSAnonBoxes_info[] = {
@@ -63,8 +64,18 @@ void nsCSSAnonBoxes::AddRefAtoms()
 }
 
 PRBool nsCSSAnonBoxes::IsAnonBox(nsIAtom *aAtom)
 {
   return nsAtomListUtils::IsMember(aAtom, CSSAnonBoxes_info,
                                    NS_ARRAY_LENGTH(CSSAnonBoxes_info));
 }
 
+#ifdef MOZ_XUL
+/* static */ PRBool
+nsCSSAnonBoxes::IsTreePseudoElement(nsIAtom* aPseudo)
+{
+  const char* str;
+  aPseudo->GetUTF8String(&str);
+  static const char moz_tree[] = ":-moz-tree-";
+  return nsCRT::strncmp(str, moz_tree, PRInt32(sizeof(moz_tree)-1)) == 0;
+}
+#endif
diff --git a/layout/style/nsCSSAnonBoxes.h b/layout/style/nsCSSAnonBoxes.h
--- a/layout/style/nsCSSAnonBoxes.h
+++ b/layout/style/nsCSSAnonBoxes.h
@@ -48,15 +48,18 @@
 class nsICSSAnonBoxPseudo : public nsIAtom {};
 
 class nsCSSAnonBoxes {
 public:
 
   static void AddRefAtoms();
 
   static PRBool IsAnonBox(nsIAtom *aAtom);
+#ifdef MOZ_XUL
+  static PRBool IsTreePseudoElement(nsIAtom* aPseudo);
+#endif
 
 #define CSS_ANON_BOX(_name, _value) static nsICSSAnonBoxPseudo* _name;
 #include "nsCSSAnonBoxList.h"
 #undef CSS_ANON_BOX
 };
 
 #endif /* nsCSSAnonBoxes_h___ */
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -2475,26 +2475,16 @@ static PRBool IsUniversalSelector(const 
                 (aSelector.mLowercaseTag == nsnull) &&
                 (aSelector.mIDList == nsnull) &&
                 (aSelector.mClassList == nsnull) &&
                 (aSelector.mAttrList == nsnull) &&
                 (aSelector.mNegations == nsnull) &&
                 (aSelector.mPseudoClassList == nsnull));
 }
 
-#ifdef MOZ_XUL
-static PRBool IsTreePseudoElement(nsIAtom* aPseudo)
-{
-  const char* str;
-  aPseudo->GetUTF8String(&str);
-  static const char moz_tree[] = ":-moz-tree-";
-  return nsCRT::strncmp(str, moz_tree, PRInt32(sizeof(moz_tree)-1)) == 0;
-}
-#endif
-
 PRBool
 CSSParserImpl::ParseSelectorGroup(nsCSSSelectorList*& aList)
 {
   nsAutoPtr<nsCSSSelectorList> list;
   PRUnichar     combinator = PRUnichar(0);
   PRInt32       weight = 0;
   PRBool        havePseudoElement = PR_FALSE;
   PRBool        done = PR_FALSE;
@@ -3037,17 +3027,17 @@ CSSParserImpl::ParsePseudoSelector(PRInt
   if (!pseudo) {
     mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     return eSelectorParsingStatus_Error;
   }
 
   // stash away some info about this pseudo so we only have to get it once.
   PRBool isTreePseudo = PR_FALSE;
 #ifdef MOZ_XUL
-  isTreePseudo = IsTreePseudoElement(pseudo);
+  isTreePseudo = nsCSSAnonBoxes::IsTreePseudoElement(pseudo);
   // If a tree pseudo-element is using the function syntax, it will
   // get isTree set here and will pass the check below that only
   // allows functions if they are in our list of things allowed to be
   // functions.  If it is _not_ using the function syntax, isTree will
   // be false, and it will still pass that check.  So the tree
   // pseudo-elements are allowed to be either functions or not, as
   // desired.
   PRBool isTree = (eCSSToken_Function == mToken.mType) && isTreePseudo;
diff --git a/layout/style/nsCSSStyleRule.cpp b/layout/style/nsCSSStyleRule.cpp
--- a/layout/style/nsCSSStyleRule.cpp
+++ b/layout/style/nsCSSStyleRule.cpp
@@ -70,16 +70,17 @@
 #include "nsXMLNameSpaceMap.h"
 #include "nsILookAndFeel.h"
 #include "nsRuleNode.h"
 #include "nsUnicharUtils.h"
 #include "nsCSSPseudoElements.h"
 #include "nsIPrincipal.h"
 #include "nsComponentManagerUtils.h"
 #include "nsCSSPseudoClasses.h"
+#include "nsCSSAnonBoxes.h"
 #include "nsTArray.h"
 
 #include "nsContentUtils.h"
 #include "nsContentErrors.h"
 #include "mozAutoDocUpdate.h"
 
 #define NS_IF_CLONE(member_)                                                  \
   PR_BEGIN_MACRO                                                              \
@@ -688,19 +689,37 @@ nsCSSSelector::AppendToStringWithoutComb
 
       aString.Append(PRUnichar(']'));
       
       list = list->mNext;
     }
   }
 
   // Append each pseudo-class in the linked list
-  if (mPseudoClassList) {
-    nsPseudoClassList* list = mPseudoClassList;
-    while (list != nsnull) {
+  if (isPseudoElement) {
+#ifdef MOZ_XUL
+    if (mPseudoClassList) {
+      NS_ABORT_IF_FALSE(nsCSSAnonBoxes::IsTreePseudoElement(mLowercaseTag),
+                        "must be tree pseudo-element");
+      aString.Append(PRUnichar('('));
+      for (nsPseudoClassList* list = mPseudoClassList; list;
+           list = list->mNext) {
+        list->mAtom->ToString(temp);
+        aString.Append(temp);
+        NS_ABORT_IF_FALSE(!list->u.mMemory, "data not expected");
+        aString.Append(PRUnichar(','));
+      }
+      // replace the final comma with a close-paren
+      aString.Replace(aString.Length() - 1, 1, PRUnichar(')'));
+    }
+#else
+    NS_ABORT_IF_FALSE(!mPseudoClassList, "unexpected pseudo-class list");
+#endif
+  } else {
+    for (nsPseudoClassList* list = mPseudoClassList; list; list = list->mNext) {
       list->mAtom->ToString(temp);
       aString.Append(temp);
       if (list->u.mMemory) {
         aString.Append(PRUnichar('('));
         if (nsCSSPseudoClasses::HasStringArg(list->mAtom)) {
           aString.Append(list->u.mString);
         } else {
           NS_ASSERTION(nsCSSPseudoClasses::HasNthPairArg(list->mAtom),
@@ -720,17 +739,16 @@ nsCSSSelector::AppendToStringWithoutComb
             if (b >= 0 && a != 0) // check a != 0 for whether we printed above
               temp.Append(PRUnichar('+'));
             temp.AppendInt(b);
           }
           aString.Append(temp);
         }
         aString.Append(PRUnichar(')'));
       }
-      list = list->mNext;
     }
   }
 }
 
 PRBool
 nsCSSSelector::CanBeNamespaced(PRBool aIsNegated) const
 {
   return !aIsNegated ||
