From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Make the cover rule produce the correct after-change style.

This switches to the new rules for how transitions start on descendants
when also starting on ancestors.

FIXME: We still fail the fourth test in descendant_tests in
layout/style/testtest_transitions.html (which has a 4s text-indent
transition on the parent and a 1s text-indent transition on the child),
because we start new transitions on the child after its first one
finishes, in response to the progress of the transition on the parent.
(I think this would be fixed by removing transitions from the
before-change style.)

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -221,28 +221,27 @@ nsTransitionManager::StyleContextChanged
     nsStyleSet* styleSet = mPresContext->StyleSet();
     afterChangeStyle =
       styleSet->ResolveStyleWithoutAnimation(aElement, newStyleContext,
                                              eRestyle_CSSTransitions);
   } else {
     afterChangeStyle = newStyleContext;
   }
 
-  // In the CSS working group discussion (2009 Jul 15 telecon,
-  // http://www.w3.org/mid/4A5E1470.4030904@inkedblade.net ) of
-  // http://lists.w3.org/Archives/Public/www-style/2009Jun/0121.html ,
-  // the working group decided that a transition property on an
-  // element should not cause any transitions if the property change
-  // is itself inheriting a value that is transitioning on an
-  // ancestor.  So, to get the correct behavior, we continue the
-  // restyle that caused this transition using a "covering" rule that
-  // covers up any changes on which we started transitions, so that
-  // descendants don't start their own transitions.  (In the case of
-  // negative transition delay, this covering rule produces different
-  // results than applying the transition rule immediately would).
+  // Here we need to produce a style rule (called the cover rule) that,
+  // when added to the after-change style defined in
+  // http://dev.w3.org/csswg/css-transitions/#starting (actually, the
+  // after-change style but with already-running transitions included),
+  // we produce the after-transition style.  This is needed to get
+  // correct behavior for both starting and stopping transitions on
+  // descendants.
+  //
+  // This requires that we cover any styles that started or stopped
+  // during this style change with the styles from afterChangeStyle.
+  //
   // Our caller is responsible for restyling again using this covering
   // rule.
 
   nsRefPtr<css::AnimValuesStyleRule> coverRule = new css::AnimValuesStyleRule;
 
   // Per http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html
   // I'll consider only the transitions from the number of items in
   // 'transition-property' on down, and later ones will override earlier
@@ -361,25 +360,29 @@ nsTransitionManager::StyleContextChanged
                     "must have element transitions if we started "
                     "any transitions");
 
   if (collection) {
     // Set the style rule refresh time to null so that EnsureStyleRuleFor
     // creates a new style rule if we started *or* stopped transitions.
     collection->mStyleRuleRefreshTime = TimeStamp();
     collection->UpdateCheckGeneration(mPresContext);
+    collection->mNeedsRefreshes = true;
+    TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+    collection->EnsureStyleRuleFor(now, EnsureStyleRule_IsNotThrottled);
   }
 
-  // Replace the new style context by appending the cover rule.
-  nsCOMArray<nsIStyleRule> rules;
-  if (startedAny) {
-    rules.AppendObject(coverRule);
+  // We want to replace the new style context with the after-change style.
+  *aNewStyleContext = afterChangeStyle;
+  if (collection) {
+    // Since we have transition styles, we have to undo this replacement.
+    // The check of mAnimationGeneration above will ensure that we don't
+    // go through the rest of this function again when we do.
+    collection->PostRestyleForAnimation(mPresContext);
   }
-  *aNewStyleContext = mPresContext->StyleSet()->
-                        ResolveStyleByAddingRules(*aNewStyleContext, rules);
 }
 
 void
 nsTransitionManager::ConsiderStartingTransition(
   nsCSSProperty aProperty,
   const StyleTransition& aTransition,
   dom::Element* aElement,
   AnimationPlayerCollection*& aElementTransitions,
@@ -457,18 +460,16 @@ nsTransitionManager::ConsiderStartingTra
   MOZ_ASSERT(!oldPT || oldPT->Properties()[0].mSegments.Length() == 1,
              "Should have one animation property segment for a transition");
   if (haveCurrentTransition && haveValues &&
       oldPT->Properties()[0].mSegments[0].mToValue == endValue) {
     // GetAnimationRule already called RestyleForAnimation.
     return;
   }
 
-  nsPresContext *presContext = aNewStyleContext->PresContext();
-
   if (!shouldAnimate) {
     if (haveCurrentTransition) {
       // We're in the middle of a transition, and just got a non-transition
       // style change to something that we can't animate.  This might happen
       // because we got a non-transition style change changing to the current
       // in-progress value (which is particularly easy to cause when we're
       // currently in the 'transition-delay').  It also might happen because we
       // just got a style change to a value that can't be interpolated.
@@ -595,17 +596,16 @@ nsTransitionManager::ConsiderStartingTra
     players[currentIndex] = player;
   } else {
     if (!players.AppendElement(player)) {
       NS_WARNING("out of memory");
       return;
     }
   }
   aElementTransitions->UpdateAnimationGeneration(mPresContext);
-  aElementTransitions->PostRestyleForAnimation(presContext);
 
   aCoverRule->AddValue(aProperty, startValue);
 
   *aStartedAny = true;
   aWhichStarted->AddProperty(aProperty);
 }
 
 /*
diff --git a/layout/style/test/test_transitions.html b/layout/style/test/test_transitions.html
--- a/layout/style/test/test_transitions.html
+++ b/layout/style/test/test_transitions.html
@@ -222,24 +222,23 @@ function make_reset_test(transition, des
     div.appendChild(p);
     is(getComputedStyle(p, "").marginLeft, "0px",
        "should be zero before changing value");
     return p;
 }
 var reset_test = make_reset_test("4s margin-left ease-out 4s", "transition-delay reset to starting point");
 var reset_test_reference = make_reset_test("4s margin-left linear -3s", "reference for previous test (reset test)");
 
-// Test that transitions on descendants do not trigger when the
+// Test that transitions on descendants start correctly when the
 // inherited value is itself transitioning.  In other words, when
 // ancestor and descendant both have a transition for the same property,
 // and the descendant inherits the property from the ancestor, the
-// descendant's transition is ignored (as part of the idea of not
-// starting transitions on changes that result from animation).
-// See http://lists.w3.org/Archives/Public/www-style/2009Jun/0121.html
-// and http://lists.w3.org/Archives/Public/www-style/2009Jul/0050.html
+// descendant's transition starts as specified, based on the concepts of
+// the before-change style, the after-change style, and the
+// after-transition style.
 var descendant_tests = [
     { parent_transition: "",
       child_transition: "4s text-indent" },
     { parent_transition: "4s text-indent",
       child_transition: "" },
     { parent_transition: "4s text-indent",
       child_transition: "16s text-indent" },
     { parent_transition: "4s text-indent",
@@ -625,21 +624,21 @@ is(getComputedStyle(reset_test_reference
 reset_reset_test();
 check_reset_test(0);
 for (var i = 1; i <= 8; ++i) {
     (function(j) {
         add_future_call(j, function() { check_reset_test(j); });
     })(i);
 }
 
-check_descendant_tests();
-add_future_call(2, check_descendant_tests);
-add_future_call(6, check_descendant_tests);
+check_descendant_tests(0);
+add_future_call(2, function() { check_descendant_tests(2) });
+add_future_call(6, function() { check_descendant_tests(6) });
 
-function check_descendant_tests() {
+function check_descendant_tests(time) {
     // text-indent: transition from 50px to 150px
     // letter-spacing: transition from 10px to 5px
     var values = {};
     values["text-indent"] = [ 50, 150 ];
     values["letter-spacing"] = [ 10, 5 ];
     var tf = timingFunctions["ease"];
 
     for (var i in descendant_tests) {
@@ -674,21 +673,23 @@ function check_descendant_tests() {
             var delay = (props.length > 2) ? parseInt(props[2]) : 0;
             var property = props[1];
             if (property != "text-indent" && property != "letter-spacing" &&
                 property != "all") {
                 ok(false, "fix this test (unexpected transition-property " +
                           property + " on child)");
             }
 
-            if (property != "letter-spacing" && child_ti_duration == 0) {
+            // Override the parent's transition with the child's as long
+            // as the child transition is still running.
+            if (property != "letter-spacing" && duration + delay > time) {
                 child_ti_duration = duration;
                 child_ti_delay = delay;
             }
-            if (property != "text-indent" && child_ls_duration == 0) {
+            if (property != "text-indent" && duration + delay > time) {
                 child_ls_duration = duration;
                 child_ls_delay = delay;
             }
         }
 
         var time_portions = {
           "text-indent":
             { duration: child_ti_duration, delay: child_ti_delay },
