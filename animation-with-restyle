From: L. David Baron <dbaron@dbaron.org>

Make CSS animations use the correct base values for unspecified 0% and 100% keyframes for restyles that don't cause reframes, though it's still broken for restyles that do cause reframes.  (Bug 686656)

diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -636,21 +636,32 @@ nsStyleSet::GetContext(nsStyleContext* a
     if (!aParentContext)
       mRoots.AppendElement(result);
   }
   else {
     NS_ASSERTION(result->GetPseudoType() == aPseudoType, "Unexpected type");
     NS_ASSERTION(result->GetPseudo() == aPseudoTag, "Unexpected pseudo");
   }
 
-  if (aDoAnimations) {
+  if (aDoAnimations && !mPresContext->IsProcessingRestyles()) {
     // Normally the animation manager has already added the correct
     // style rule.  However, if the animation-name just changed, it
     // might have been wrong.  So ask it to double-check based on the
     // resulting style context.
+    // We don't need to do this when we're processing restyles because
+    // the paired WRITE ME...
+    // FIXME: This causes us to call nsAnimationManager::BuildAnimations
+    // while there are animation rules applied, which means that we'll
+    // use incorrect base values.  (This only happens for the frame
+    // reconstruction case, since for the initial frame construction
+    // case we'll never have the animation rules applied.)  We probably
+    // need to make the frame construction case behave more like the
+    // restyle processing case with its initial non-animation pass
+    // followed by a restyle for animation.  (But what if the animation
+    // causes frame reconstruction?!)
     nsIStyleRule *oldAnimRule = GetAnimationRule(aRuleNode);
     nsIStyleRule *animRule = PresContext()->AnimationManager()->
       CheckAnimationRule(result, aElementForAnimation);
     NS_ABORT_IF_FALSE(result->GetRuleNode() == aRuleNode,
                       "unexpected rule node");
     NS_ABORT_IF_FALSE(!result->GetStyleIfVisited() == !aVisitedRuleNode,
                       "unexpected visited rule node");
     NS_ABORT_IF_FALSE(!aVisitedRuleNode ||
