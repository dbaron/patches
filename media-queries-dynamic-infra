Implement Media Queries, part 2: infrastructure for dynamic change handling.  b=156716

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -79,6 +79,7 @@
 #include "nsWidgetsCID.h"
 #include "nsServiceManagerUtils.h"
 #include "nsTArray.h"
+#include "nsIMediaList.h"
 
 static NS_DEFINE_CID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
 static nsTArray< nsCOMPtr<nsIAtom> >* sSystemMetrics = 0;
@@ -682,7 +683,7 @@ struct RuleCascadeData {
   RuleCascadeData(nsIAtom *aMedium, PRBool aQuirksMode)
     : mRuleHash(aQuirksMode),
       mStateSelectors(),
-      mMedium(aMedium),
+      mCacheKey(aMedium),
       mNext(nsnull)
   {
     PL_DHashTableInit(&mAttributeSelectors, &AttributeSelectorOps, nsnull,
@@ -703,7 +704,7 @@ struct RuleCascadeData {
   // Returns null only on allocation failure.
   nsVoidArray* AttributeListFor(nsIAtom* aAttribute);
 
-  nsCOMPtr<nsIAtom> mMedium;
+  nsMediaQueryResultCacheKey mCacheKey;
   RuleCascadeData*  mNext; // for a different medium
 };
 
@@ -2176,8 +2177,11 @@ static PLDHashTableOps gRulesByWeightOps
 };
 
 struct CascadeEnumData {
-  CascadeEnumData(nsPresContext* aPresContext, PLArenaPool& aArena)
+  CascadeEnumData(nsPresContext* aPresContext,
+                  nsMediaQueryResultCacheKey& aKey,
+                  PLArenaPool& aArena)
     : mPresContext(aPresContext),
+      mCacheKey(aKey),
       mArena(aArena)
   {
     if (!PL_DHashTableInit(&mRulesByWeight, &gRulesByWeightOps, nsnull,
@@ -2192,6 +2196,7 @@ struct CascadeEnumData {
   }
 
   nsPresContext* mPresContext;
+  nsMediaQueryResultCacheKey& mCacheKey;
   // Hooray, a manual PLDHashTable since nsClassHashtable doesn't
   // provide a getter that gives me a *reference* to the value.
   PLDHashTable mRulesByWeight; // of RuleValue* linked lists (?)
@@ -2227,7 +2232,7 @@ InsertRuleByWeight(nsICSSRule* aRule, vo
   else if (nsICSSRule::MEDIA_RULE == type ||
            nsICSSRule::DOCUMENT_RULE == type) {
     nsICSSGroupRule* groupRule = (nsICSSGroupRule*)aRule;
-    if (groupRule->UseForPresentation(data->mPresContext))
+    if (groupRule->UseForPresentation(data->mPresContext, data->mCacheKey))
       if (!groupRule->EnumerateRulesForwards(InsertRuleByWeight, aData))
         return PR_FALSE;
   }
@@ -2243,7 +2248,8 @@ CascadeSheetRulesInto(nsICSSStyleSheet* 
   PRBool bSheetApplicable = PR_TRUE;
   sheet->GetApplicable(bSheetApplicable);
 
-  if (bSheetApplicable && sheet->UseForMedium(data->mPresContext)) {
+  if (bSheetApplicable &&
+      sheet->UseForPresentation(data->mPresContext, data->mCacheKey)) {
     nsCSSStyleSheet* child = sheet->mFirstChild;
     while (child) {
       CascadeSheetRulesInto(child, data);
@@ -2299,23 +2305,21 @@ nsCSSRuleProcessor::GetRuleCascade(nsPre
   // (@-moz-document).)  Things will get a little more complicated if
   // we implement media queries, though.
 
-  // FIXME: per-medium caching is now invalid; fix using boundary
-  // conditions per feature
   RuleCascadeData **cascadep = &mRuleCascades;
   RuleCascadeData *cascade;
-  nsIAtom *medium = aPresContext->Medium();
   while ((cascade = *cascadep)) {
-    if (cascade->mMedium == medium)
+    if (cascade->mCacheKey.Matches(aPresContext))
       return cascade;
     cascadep = &cascade->mNext;
   }
 
   if (mSheets.Count() != 0) {
     nsAutoPtr<RuleCascadeData> newCascade(
-      new RuleCascadeData(medium,
+      new RuleCascadeData(aPresContext->Medium(),
                           eCompatibility_NavQuirks == aPresContext->CompatibilityMode()));
     if (newCascade) {
-      CascadeEnumData data(aPresContext, newCascade->mRuleHash.Arena());
+      CascadeEnumData data(aPresContext, newCascade->mCacheKey,
+                           newCascade->mRuleHash.Arena());
       if (!data.mRulesByWeight.ops)
         return nsnull;
       if (!mSheets.EnumerateForwards(CascadeSheetRulesInto, &data))
diff --git a/layout/style/nsCSSRules.cpp b/layout/style/nsCSSRules.cpp
--- a/layout/style/nsCSSRules.cpp
+++ b/layout/style/nsCSSRules.cpp
@@ -1036,10 +1036,11 @@ nsCSSMediaRule::DeleteRule(PRUint32 aInd
 
 // nsICSSGroupRule interface
 NS_IMETHODIMP_(PRBool)
-nsCSSMediaRule::UseForPresentation(nsPresContext* aPresContext)
+nsCSSMediaRule::UseForPresentation(nsPresContext* aPresContext,
+                                   nsMediaQueryResultCacheKey& aKey)
 {
   if (mMedia) {
-    return mMedia->Matches(aPresContext);
+    return mMedia->Matches(aPresContext, aKey);
   }
   return PR_TRUE;
 }
@@ -1196,7 +1197,8 @@ nsCSSDocumentRule::DeleteRule(PRUint32 a
 
 // nsICSSGroupRule interface
 NS_IMETHODIMP_(PRBool)
-nsCSSDocumentRule::UseForPresentation(nsPresContext* aPresContext)
+nsCSSDocumentRule::UseForPresentation(nsPresContext* aPresContext,
+                                      nsMediaQueryResultCacheKey& aKey)
 {
   nsIURI *docURI = aPresContext->Document()->GetDocumentURI();
   nsCAutoString docURISpec;
diff --git a/layout/style/nsCSSRules.h b/layout/style/nsCSSRules.h
--- a/layout/style/nsCSSRules.h
+++ b/layout/style/nsCSSRules.h
@@ -135,7 +135,8 @@ public:
   NS_DECL_NSIDOMCSSMEDIARULE
 
   // rest of nsICSSGroupRule interface
-  NS_IMETHOD_(PRBool) UseForPresentation(nsPresContext* aPresContext);
+  NS_IMETHOD_(PRBool) UseForPresentation(nsPresContext* aPresContext,
+                                         nsMediaQueryResultCacheKey& aKey);
 
   // @media rule methods
   nsresult SetMedia(nsMediaList* aMedia);
@@ -170,7 +171,8 @@ public:
   NS_DECL_NSIDOMCSSMOZDOCUMENTRULE
 
   // rest of nsICSSGroupRule interface
-  NS_IMETHOD_(PRBool) UseForPresentation(nsPresContext* aPresContext);
+  NS_IMETHOD_(PRBool) UseForPresentation(nsPresContext* aPresContext,
+                                         nsMediaQueryResultCacheKey& aKey);
 
   enum Function {
     eURL,
diff --git a/layout/style/nsCSSStyleSheet.cpp b/layout/style/nsCSSStyleSheet.cpp
--- a/layout/style/nsCSSStyleSheet.cpp
+++ b/layout/style/nsCSSStyleSheet.cpp
@@ -165,6 +165,175 @@ CSSRuleListImpl::Item(PRUint32 aIndex, n
   return result;
 }
 
+
+template <class Numeric>
+PRInt32 DoCompare(Numeric a, Numeric b)
+{
+  if (a == b)
+    return 0;
+  if (a < b)
+    return -1;
+  return 1;
+}
+
+PRBool
+nsMediaExpression::Matches(nsPresContext *aPresContext,
+                           const nsCSSValue& aActualValue) const
+{
+  const nsCSSValue& actual = aActualValue;
+  const nsCSSValue& required = mValue;
+
+  // If we don't have the feature, the match fails.
+  if (actual.GetUnit() == eCSSUnit_Null) {
+    return PR_FALSE;
+  }
+
+  // If the expression had no value to match, the match succeeds,
+  // unless the value is an integer 0.
+  if (required.GetUnit() == eCSSUnit_Null) {
+    return actual.GetUnit() != eCSSUnit_Integer ||
+           actual.GetIntValue() != 0;
+  }
+
+  NS_ASSERTION(mFeature->mRangeType == nsMediaFeature::eMinMaxAllowed ||
+               mRange == nsMediaExpression::eEqual, "yikes");
+  PRInt32 cmp; // -1 (actual < required)
+               //  0 (actual == required)
+               //  1 (actual > required)
+  switch (mFeature->mValueType) {
+    case nsMediaFeature::eLength:
+      {
+        NS_ASSERTION(actual.IsLengthUnit(), "bad actual value");
+        NS_ASSERTION(required.IsLengthUnit(), "bad required value");
+        nscoord actualCoord = nsRuleNode::CalcLengthWithInitialFont(
+                                aPresContext, actual);
+        nscoord requiredCoord = nsRuleNode::CalcLengthWithInitialFont(
+                                  aPresContext, required);
+        cmp = DoCompare(actualCoord, requiredCoord);
+      }
+      break;
+    case nsMediaFeature::eInteger:
+      {
+        NS_ASSERTION(actual.GetUnit() == eCSSUnit_Integer,
+                     "bad actual value");
+        NS_ASSERTION(required.GetUnit() == eCSSUnit_Integer,
+                     "bad required value");
+        cmp = DoCompare(actual.GetIntValue(), required.GetIntValue());
+      }
+      break;
+    case nsMediaFeature::eIntRatio:
+      {
+        NS_ASSERTION(actual.GetUnit() == eCSSUnit_Array &&
+                     actual.GetArrayValue()->Item(0).GetUnit() ==
+                       eCSSUnit_Integer &&
+                     actual.GetArrayValue()->Item(1).GetUnit() ==
+                       eCSSUnit_Integer,
+                     "bad actual value");
+        NS_ASSERTION(required.GetUnit() == eCSSUnit_Array &&
+                     required.GetArrayValue()->Item(0).GetUnit() ==
+                       eCSSUnit_Integer &&
+                     required.GetArrayValue()->Item(1).GetUnit() ==
+                       eCSSUnit_Integer,
+                     "bad required value");
+        // Convert to PRInt64 so we can multiply without worry
+        PRInt64 actualNum = actual.GetArrayValue()->Item(0).GetIntValue(),
+                actualDen = actual.GetArrayValue()->Item(1).GetIntValue(),
+                requiredNum = required.GetArrayValue()->Item(0).GetIntValue(),
+                requiredDen = required.GetArrayValue()->Item(1).GetIntValue();
+        cmp = DoCompare(actualNum * requiredDen, requiredNum * actualDen);
+      }
+      break;
+    case nsMediaFeature::eResolution:
+      {
+        NS_ASSERTION(actual.GetUnit() == eCSSUnit_Inch ||
+                     actual.GetUnit() == eCSSUnit_Centimeter,
+                     "bad actual value");
+        NS_ASSERTION(required.GetUnit() == eCSSUnit_Inch ||
+                     required.GetUnit() == eCSSUnit_Centimeter,
+                     "bad required value");
+        float actualDPI = actual.GetFloatValue();
+        if (actual.GetUnit() == eCSSUnit_Centimeter)
+          actualDPI = actualDPI / 2.54f;
+        float requiredDPI = required.GetFloatValue();
+        if (required.GetUnit() == eCSSUnit_Centimeter)
+          requiredDPI = requiredDPI / 2.54f;
+        cmp = DoCompare(actualDPI, requiredDPI);
+      }
+      break;
+    case nsMediaFeature::eEnumerated:
+      {
+        NS_ASSERTION(actual.GetUnit() == eCSSUnit_Enumerated,
+                     "bad actual value");
+        NS_ASSERTION(required.GetUnit() == eCSSUnit_Enumerated,
+                     "bad required value");
+        NS_ASSERTION(mFeature->mRangeType == nsMediaFeature::eMinMaxNotAllowed,
+                     "bad range"); // we asserted above about mRange
+        // We don't really need DoCompare, but it doesn't hurt (and
+        // maybe the compiler will condense this case with eInteger).
+        cmp = DoCompare(actual.GetIntValue(), required.GetIntValue());
+      }
+      break;
+  }
+  PRBool match;
+  switch (mRange) {
+    case nsMediaExpression::eMin:
+      match = cmp != -1;
+      break;
+    case nsMediaExpression::eMax:
+      match = cmp != 1;
+      break;
+    case nsMediaExpression::eEqual:
+      match = cmp == 0;
+      break;
+  }
+  return match;
+}
+
+void
+nsMediaQueryResultCacheKey::AddExpression(const nsMediaExpression* aExpression)
+{
+  const nsMediaFeature *feature = aExpression->mFeature;
+  FeatureEntry *entry;
+  for (PRUint32 i = 0; i < mFeatureCache.Length(); ++i) {
+    if (mFeatureCache[i].mFeature == feature) {
+      entry = &mFeatureCache[i];
+      break;
+    }
+  }
+  if (!entry) {
+    entry = mFeatureCache.AppendElement();
+    if (!entry) {
+      return; /* out of memory */
+    }
+    entry->mFeature = feature;
+  }
+
+  entry->mExpressions.AppendElement(aExpression);
+}
+
+PRBool
+nsMediaQueryResultCacheKey::Matches(nsPresContext* aPresContext) const
+{
+  if (aPresContext->Medium() != mMedium) {
+    return PR_FALSE;
+  }
+
+  for (PRUint32 i = 0; i < mFeatureCache.Length(); ++i) {
+    const FeatureEntry *entry = &mFeatureCache[i];
+    nsCSSValue actual;
+    nsresult rv = (entry->mFeature->mGetter)(aPresContext, actual);
+    NS_ENSURE_SUCCESS(rv, PR_FALSE); // any better ideas?
+
+    for (PRUint32 j = 0; j < entry->mExpressions.Length(); ++j) {
+      if (!entry->mExpressions[j]->Matches(aPresContext, actual)) {
+        return PR_FALSE;
+      }
+    }
+  }
+
+  return PR_TRUE;
+}
+
 void
 nsMediaQuery::AppendToString(nsAString& aString) const
 {
@@ -274,18 +443,9 @@ nsMediaQuery::Clone() const
   return result.forget();
 }
 
-template <class Numeric>
-PRInt32 DoCompare(Numeric a, Numeric b)
-{
-  if (a == b)
-    return 0;
-  if (a < b)
-    return -1;
-  return 1;
-}
-
 PRBool
-nsMediaQuery::Matches(nsPresContext* aPresContext) const
+nsMediaQuery::Matches(nsPresContext* aPresContext,
+                      nsMediaQueryResultCacheKey& aKey) const
 {
   if (mHadUnknownExpression)
     return mNegated;
@@ -296,115 +456,12 @@ nsMediaQuery::Matches(nsPresContext* aPr
   // CHANGES!
   for (PRUint32 i = 0, i_end = mExpressions.Length(); match && i < i_end; ++i) {
     const nsMediaExpression &expr = mExpressions[i];
-    const nsMediaFeature *feature = expr.mFeature;
+    aKey.AddExpression(&expr);
     nsCSSValue actual;
-    nsresult rv = (feature->mGetter)(aPresContext, actual);
+    nsresult rv = (expr.mFeature->mGetter)(aPresContext, actual);
     NS_ENSURE_SUCCESS(rv, PR_FALSE); // any better ideas?
-    // If we don't have the feature, the match fails.
-    if (actual.GetUnit() == eCSSUnit_Null) {
-      match = PR_FALSE;
-      continue;
-    }
 
-    // If the expression had no value to match, the match succeeds,
-    // unless the value is an integer 0.
-    const nsCSSValue required = expr.mValue;
-    if (required.GetUnit() == eCSSUnit_Null) {
-      match = actual.GetUnit() != eCSSUnit_Integer ||
-              actual.GetIntValue() != 0;
-      continue;
-    }
-
-    NS_ASSERTION(feature->mRangeType == nsMediaFeature::eMinMaxAllowed ||
-                 expr.mRange == nsMediaExpression::eEqual, "yikes");
-    PRInt32 cmp; // -1 (actual < required)
-                 //  0 (actual == required)
-                 //  1 (actual > required)
-    switch (feature->mValueType) {
-      case nsMediaFeature::eLength:
-        {
-          NS_ASSERTION(actual.IsLengthUnit(), "bad actual value");
-          NS_ASSERTION(required.IsLengthUnit(), "bad required value");
-          nscoord actualCoord = nsRuleNode::CalcLengthWithInitialFont(
-                                  aPresContext, actual);
-          nscoord requiredCoord = nsRuleNode::CalcLengthWithInitialFont(
-                                    aPresContext, required);
-          cmp = DoCompare(actualCoord, requiredCoord);
-        }
-        break;
-      case nsMediaFeature::eInteger:
-        {
-          NS_ASSERTION(actual.GetUnit() == eCSSUnit_Integer,
-                       "bad actual value");
-          NS_ASSERTION(required.GetUnit() == eCSSUnit_Integer,
-                       "bad required value");
-          cmp = DoCompare(actual.GetIntValue(), required.GetIntValue());
-        }
-        break;
-      case nsMediaFeature::eIntRatio:
-        {
-          NS_ASSERTION(actual.GetUnit() == eCSSUnit_Array &&
-                       actual.GetArrayValue()->Item(0).GetUnit() ==
-                         eCSSUnit_Integer &&
-                       actual.GetArrayValue()->Item(1).GetUnit() ==
-                         eCSSUnit_Integer,
-                       "bad actual value");
-          NS_ASSERTION(required.GetUnit() == eCSSUnit_Array &&
-                       required.GetArrayValue()->Item(0).GetUnit() ==
-                         eCSSUnit_Integer &&
-                       required.GetArrayValue()->Item(1).GetUnit() ==
-                         eCSSUnit_Integer,
-                       "bad required value");
-          // Convert to PRInt64 so we can multiply without worry
-          PRInt64 actualNum = actual.GetArrayValue()->Item(0).GetIntValue(),
-                  actualDen = actual.GetArrayValue()->Item(1).GetIntValue(),
-                  requiredNum = required.GetArrayValue()->Item(0).GetIntValue(),
-                  requiredDen = required.GetArrayValue()->Item(1).GetIntValue();
-          cmp = DoCompare(actualNum * requiredDen, requiredNum * actualDen);
-        }
-        break;
-      case nsMediaFeature::eResolution:
-        {
-          NS_ASSERTION(actual.GetUnit() == eCSSUnit_Inch ||
-                       actual.GetUnit() == eCSSUnit_Centimeter,
-                       "bad actual value");
-          NS_ASSERTION(required.GetUnit() == eCSSUnit_Inch ||
-                       required.GetUnit() == eCSSUnit_Centimeter,
-                       "bad required value");
-          float actualDPI = actual.GetFloatValue();
-          if (actual.GetUnit() == eCSSUnit_Centimeter)
-            actualDPI = actualDPI / 2.54f;
-          float requiredDPI = required.GetFloatValue();
-          if (required.GetUnit() == eCSSUnit_Centimeter)
-            requiredDPI = requiredDPI / 2.54f;
-          cmp = DoCompare(actualDPI, requiredDPI);
-        }
-        break;
-      case nsMediaFeature::eEnumerated:
-        {
-          NS_ASSERTION(actual.GetUnit() == eCSSUnit_Enumerated,
-                       "bad actual value");
-          NS_ASSERTION(required.GetUnit() == eCSSUnit_Enumerated,
-                       "bad required value");
-          NS_ASSERTION(feature->mRangeType == nsMediaFeature::eMinMaxNotAllowed,
-                       "bad range"); // we asserted above about expr.mRange
-          // We don't really need DoCompare, but it doesn't hurt (and
-          // maybe the compiler will condense this case with eInteger).
-          cmp = DoCompare(actual.GetIntValue(), required.GetIntValue());
-        }
-        break;
-    }
-    switch (expr.mRange) {
-      case nsMediaExpression::eMin:
-        match = cmp != -1;
-        break;
-      case nsMediaExpression::eMax:
-        match = cmp != 1;
-        break;
-      case nsMediaExpression::eEqual:
-        match = cmp == 0;
-        break;
-    }
+    match = expr.Matches(aPresContext, actual);
   }
 
   return match == !mNegated;
@@ -472,10 +529,11 @@ nsMediaList::SetText(const nsAString& aM
 }
 
 PRBool
-nsMediaList::Matches(nsPresContext* aPresContext)
+nsMediaList::Matches(nsPresContext* aPresContext,
+                     nsMediaQueryResultCacheKey& aKey)
 {
   for (PRInt32 i = 0, i_end = mArray.Length(); i < i_end; ++i) {
-    if (mArray[i]->Matches(aPresContext)) {
+    if (mArray[i]->Matches(aPresContext, aKey)) {
       return PR_TRUE;
     }
   }
@@ -1102,11 +1160,12 @@ nsCSSStyleSheet::GetType(nsString& aType
   return NS_OK;
 }
 
-NS_IMETHODIMP_(PRBool)
-nsCSSStyleSheet::UseForMedium(nsPresContext* aPresContext) const
+PRBool
+nsCSSStyleSheet::UseForPresentation(nsPresContext* aPresContext,
+                                    nsMediaQueryResultCacheKey& aKey) const
 {
   if (mMedia) {
-    return mMedia->Matches(aPresContext);
+    return mMedia->Matches(aPresContext, aKey);
   }
   return PR_TRUE;
 }
diff --git a/layout/style/nsCSSStyleSheet.h b/layout/style/nsCSSStyleSheet.h
--- a/layout/style/nsCSSStyleSheet.h
+++ b/layout/style/nsCSSStyleSheet.h
@@ -55,6 +55,7 @@
 
 class nsIURI;
 class nsMediaList;
+class nsMediaQueryResultCacheKey;
 
 // -------------------------------
 // CSS Style Sheet Inner Data Container
@@ -109,7 +110,6 @@ public:
   NS_IMETHOD GetBaseURI(nsIURI** aBaseURI) const;
   NS_IMETHOD GetTitle(nsString& aTitle) const;
   NS_IMETHOD GetType(nsString& aType) const;
-  NS_IMETHOD_(PRBool) UseForMedium(nsPresContext* aPresContext) const;
   NS_IMETHOD_(PRBool) HasRules() const;
   NS_IMETHOD GetApplicable(PRBool& aApplicable) const;
   NS_IMETHOD SetEnabled(PRBool aEnabled);
@@ -164,6 +164,9 @@ public:
                               nsresult aStatus);
   
   nsresult EnsureUniqueInner();
+
+  PRBool UseForPresentation(nsPresContext* aPresContext,
+                            nsMediaQueryResultCacheKey& aKey) const;
 
   // nsIDOMStyleSheet interface
   NS_DECL_NSIDOMSTYLESHEET
diff --git a/layout/style/nsHTMLCSSStyleSheet.cpp b/layout/style/nsHTMLCSSStyleSheet.cpp
--- a/layout/style/nsHTMLCSSStyleSheet.cpp
+++ b/layout/style/nsHTMLCSSStyleSheet.cpp
@@ -342,7 +342,6 @@ public:
   NS_IMETHOD GetBaseURI(nsIURI** aBaseURL) const;
   NS_IMETHOD GetTitle(nsString& aTitle) const;
   NS_IMETHOD GetType(nsString& aType) const;
-  NS_IMETHOD_(PRBool) UseForMedium(nsPresContext* aPresContext) const;
   NS_IMETHOD_(PRBool) HasRules() const;
 
   NS_IMETHOD GetApplicable(PRBool& aApplicable) const;
@@ -535,12 +534,6 @@ HTMLCSSStyleSheetImpl::GetType(nsString&
 {
   aType.AssignLiteral("text/html");
   return NS_OK;
-}
-
-NS_IMETHODIMP_(PRBool)
-HTMLCSSStyleSheetImpl::UseForMedium(nsPresContext* aPresContext) const
-{
-  return PR_TRUE; // works for all media
 }
 
 NS_IMETHODIMP_(PRBool)
diff --git a/layout/style/nsHTMLStyleSheet.cpp b/layout/style/nsHTMLStyleSheet.cpp
--- a/layout/style/nsHTMLStyleSheet.cpp
+++ b/layout/style/nsHTMLStyleSheet.cpp
@@ -609,12 +609,6 @@ nsHTMLStyleSheet::GetType(nsString& aTyp
 }
 
 NS_IMETHODIMP_(PRBool)
-nsHTMLStyleSheet::UseForMedium(nsPresContext* aPresContext) const
-{
-  return PR_TRUE; // works for all media
-}
-
-NS_IMETHODIMP_(PRBool)
 nsHTMLStyleSheet::HasRules() const
 {
   return PR_TRUE; // We have rules at all reasonable times
diff --git a/layout/style/nsHTMLStyleSheet.h b/layout/style/nsHTMLStyleSheet.h
--- a/layout/style/nsHTMLStyleSheet.h
+++ b/layout/style/nsHTMLStyleSheet.h
@@ -64,7 +64,6 @@ public:
   NS_IMETHOD GetBaseURI(nsIURI** aBaseURL) const;
   NS_IMETHOD GetTitle(nsString& aTitle) const;
   NS_IMETHOD GetType(nsString& aType) const;
-  NS_IMETHOD_(PRBool) UseForMedium(nsPresContext* aPresContext) const;
   NS_IMETHOD_(PRBool) HasRules() const;
   NS_IMETHOD GetApplicable(PRBool& aApplicable) const;
   NS_IMETHOD SetEnabled(PRBool aEnabled);
diff --git a/layout/style/nsICSSGroupRule.h b/layout/style/nsICSSGroupRule.h
--- a/layout/style/nsICSSGroupRule.h
+++ b/layout/style/nsICSSGroupRule.h
@@ -48,6 +48,7 @@
 
 class nsIAtom;
 class nsPresContext;
+class nsMediaQueryResultCacheKey;
 
 // IID for the nsICSSGroupRule interface {67b8492e-6d8d-43a5-8037-71eb269f24fe}
 #define NS_ICSS_GROUP_RULE_IID     \
@@ -75,7 +76,8 @@ public:
                                  nsCOMArray<nsICSSRule>& aRules) = 0;
   NS_IMETHOD  ReplaceStyleRule(nsICSSRule* aOld, nsICSSRule* aNew) = 0;
 
-  NS_IMETHOD_(PRBool) UseForPresentation(nsPresContext* aPresContext) = 0;
+  NS_IMETHOD_(PRBool) UseForPresentation(nsPresContext* aPresContext,
+                                         nsMediaQueryResultCacheKey& aKey) = 0;
    
 };
 
diff --git a/layout/style/nsIMediaList.h b/layout/style/nsIMediaList.h
--- a/layout/style/nsIMediaList.h
+++ b/layout/style/nsIMediaList.h
@@ -48,6 +48,7 @@
 #include "nsIDOMMediaList.h"
 #include "nsAString.h"
 #include "nsTArray.h"
+#include "nsTPtrArray.h"
 #include "nsIAtom.h"
 #include "nsMediaFeatures.h"
 #include "nsCSSValue.h"
@@ -62,6 +63,46 @@ struct nsMediaExpression {
   const nsMediaFeature *mFeature;
   Range mRange;
   nsCSSValue mValue;
+
+  // aActualValue must be obtained from mFeature->mGetter
+  PRBool Matches(nsPresContext* aPresContext,
+                 const nsCSSValue& aActualValue) const;
+};
+
+/**
+ * An nsMediaQueryResultCacheKey records what feature/value combinations
+ * a set of media query results are valid for.  This allows the caller
+ * to quickly learn whether a prior result of media query evaluation is
+ * still valid (e.g., due to a window size change) without rerunning all
+ * of the evaluation and rebuilding the list of rules.
+ *
+ * This object may not be used after any any media rules in any of the
+ * sheets it was given to have been modified.  However, this is
+ * generally not a problem since ClearRuleCascades is called on the
+ * sheet whenever this happens, and these objects are stored inside the
+ * rule cascades.
+ *
+ * The implementation could be further optimized in the future to store
+ * ranges (combinations of less-than, less-than-or-equal, greater-than,
+ * greater-than-or-equal, equal, not-equal, present, not-present) for
+ * each feature rather than simply storing the list of expressions.
+ * However, this requires combining any such ranges.
+ */
+class nsMediaQueryResultCacheKey {
+public:
+  nsMediaQueryResultCacheKey(nsIAtom* aMedium)
+    : mMedium(aMedium)
+  {}
+
+  void AddExpression(const nsMediaExpression* aExpression);
+  PRBool Matches(nsPresContext* aPresContext) const;
+private:
+  struct FeatureEntry {
+    const nsMediaFeature *mFeature;
+    nsTPtrArray<const nsMediaExpression> mExpressions;
+  };
+  nsCOMPtr<nsIAtom> mMedium;
+  nsTArray<FeatureEntry> mFeatureCache;
 };
 
 class nsMediaQuery {
@@ -106,7 +147,8 @@ public:
   nsMediaQuery* Clone() const;
 
   // Does this query apply to the presentation?
-  PRBool Matches(nsPresContext* aPresContext) const;
+  PRBool Matches(nsPresContext* aPresContext,
+                 nsMediaQueryResultCacheKey& aKey) const;
 
 private:
   PRPackedBool mNegated;
@@ -127,7 +169,8 @@ public:
 
   nsresult GetText(nsAString& aMediaText);
   nsresult SetText(const nsAString& aMediaText);
-  PRBool Matches(nsPresContext* aPresContext);
+  PRBool Matches(nsPresContext* aPresContext,
+                 nsMediaQueryResultCacheKey& aKey);
   nsresult SetStyleSheet(nsICSSStyleSheet* aSheet);
   nsresult AppendQuery(nsMediaQuery *aQuery) {
     // Takes ownership of aQuery
diff --git a/layout/style/nsIStyleSheet.h b/layout/style/nsIStyleSheet.h
--- a/layout/style/nsIStyleSheet.h
+++ b/layout/style/nsIStyleSheet.h
@@ -78,7 +78,6 @@ public:
   NS_IMETHOD GetBaseURI(nsIURI** aBaseURI) const = 0;
   NS_IMETHOD GetTitle(nsString& aTitle) const = 0;
   NS_IMETHOD GetType(nsString& aType) const = 0;
-  NS_IMETHOD_(PRBool) UseForMedium(nsPresContext* aPresContext) const = 0;
   NS_IMETHOD_(PRBool) HasRules() const = 0;
 
   /**
