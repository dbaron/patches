Fix greediness of A ~ B C selector matching.  b=420814

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1620,10 +1620,15 @@ static PRBool SelectorMatchesTree(RulePr
     }
     if (SelectorMatches(*data, selector, 0, nsnull)) {
       // to avoid greedy matching, we need to recur if this is a
-      // descendant combinator and the next combinator is not
+      // descendant or general sibling combinator and the next
+      // combinator is different, but we can make an exception for
+      // sibling, then parent, since a sibling's parent is always the
+      // same.
       if ((NS_IS_GREEDY_OPERATOR(selector->mOperator)) &&
           (selector->mNext) &&
-          (!NS_IS_GREEDY_OPERATOR(selector->mNext->mOperator))) {
+          (selector->mNext->mOperator != selector->mOperator) &&
+          !(selector->mOperator == '~' &&
+            selector->mNext->mOperator == PRUnichar(0))) {
 
         // pretend the selector didn't match, and step through content
         // while testing the same selector
diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -103,6 +103,7 @@ _TEST_FILES =	test_bug73586.html \
 		test_parse_rule.html \
 		test_property_database.html \
 		test_property_syntax_errors.html \
+		test_selectors.html \
 		test_style_struct_copy_constructors.html \
 		test_value_storage.html \
 		test_value_computation.html \
@@ -112,6 +113,7 @@ _TEST_FILES =	test_bug73586.html \
 		unstyled.css \
 		unstyled-frame.xml \
 		unstyled-frame.css \
+		empty.html \
 		redirect-1.css \
 		post-redirect-1.css \
 		redirect-1.css^headers^ \
diff --git a/layout/style/test/empty.html b/layout/style/test/empty.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/empty.html
@@ -0,0 +1,1 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title></title></head><body></body></html>
diff --git a/layout/style/test/test_selectors.html b/layout/style/test/test_selectors.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_selectors.html
@@ -0,0 +1,71 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Test for CSS Selectors</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<p id="display"><iframe id="iframe" src="empty.html"></iframe></p>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+var iframe = document.getElementById("iframe");
+var ifwin = iframe.contentWindow;
+var ifdoc = iframe.contentDocument;
+
+function setup_style() {
+    var style_elem = ifdoc.createElement("style");
+    style_elem.setAttribute("type", "text/css");
+    ifdoc.getElementsByTagName("head")[0].appendChild(style_elem);
+    var style_text = ifdoc.createTextNode("");
+    style_elem.appendChild(style_text);
+    return style_text;
+}
+
+var style_text = setup_style();
+
+var gCounter = 0;
+
+/*
+ * selector: the selector to test
+ * body_contents: what to set the body's innerHTML to
+ * match_fn: a function that, given the document object into which
+ *   body_contents has been inserted, produces an array of nodes that
+ *   should match selector
+ * notmatch_fn: likewise, but for nodes that should not match
+ */
+function test_selector_in_html(selector, body_contents, match_fn, notmatch_fn)
+{
+    var zi = ++gCounter;
+    ifdoc.body.innerHTML = body_contents;
+    style_text.data = selector + "{ z-index: " + zi + " }";
+    var should_match = match_fn(ifdoc);
+    var should_not_match = notmatch_fn(ifdoc);
+    if (should_match.length + should_not_match.length == 0) {
+        ok(false, "nothing to check");
+    }
+    for (var i = 0; i < should_match.length; ++i) {
+        var e = should_match[i];
+        is(ifwin.getComputedStyle(e, "").zIndex, zi,
+           "element in " + body_contents + " matched " + selector);
+    }
+    for (var i = 0; i < should_not_match.length; ++i) {
+        var e = should_not_match[i];
+        is(ifwin.getComputedStyle(e, "").zIndex, "auto",
+           "element in " + body_contents + " did not match " + selector);
+    }
+}
+
+// Bug 420814
+test_selector_in_html("div ~ div p",
+                      "<div></div><div><div><p>match</p></div></div>",
+                      function(doc) { return doc.getElementsByTagName("p"); },
+                      function(doc) { return []; });
+
+</script>
+</pre>
+</body>
+</html>
+
