From: L. David Baron <dbaron@dbaron.org>

Stop transitions when -moz-transition-property changes to a value that no longer includes the transitioning property.  (Bug 525530)

diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -1917,25 +1917,26 @@ nsChangeHint nsStyleDisplay::CalcDiffere
     
     for (PRUint8 index = 0; index < 2; ++index)
       if (mTransformOrigin[index] != aOther.mTransformOrigin[index]) {
         NS_UpdateHint(hint, NS_CombineHint(nsChangeHint_ReflowFrame,
                                            nsChangeHint_RepaintFrame));
         break;
       }
   }
-  
-  // Note:  Our current behavior for handling changes to transition
+
+  // Note:  Our current behavior for handling changes to the
+  // transition-duration, transition-delay, and transition-timing-function
   // properties is to do nothing.  In other words, the transition
   // property that matters is what it is when the transition begins, and
   // we don't stop a transition later because the transition property
   // changed.
-  // FIXME (Bug 522599):  Need to test for this and write it in the
-  // spec, if it's compatible with other browsers.  Test for behavior at
-  // http://dbaron.org/css/test/2009/transitions/dynamic-transition-change
+  // We do handle changes to transition-property, but we don't need to
+  // bother with anything here, since the transition manager is notified
+  // of any style context change anyway.
   
   return hint;
 }
 
 #ifdef DEBUG
 /* static */
 nsChangeHint nsStyleDisplay::MaxDifference()
 {
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -367,19 +367,23 @@ nsTransitionManager::StyleContextChanged
   // it's worth thinking about some more.
   NS_PRECONDITION(aOldStyleContext->HasPseudoElementData() ==
                       aNewStyleContext->HasPseudoElementData(),
                   "pseudo type mismatch");
 
   // Return sooner (before the startedAny check below) for the most
   // common case: no transitions specified.
   const nsStyleDisplay *disp = aNewStyleContext->GetStyleDisplay();
+  const nsStyleDisplay *oldDisp = aOldStyleContext->GetStyleDisplay();
   if (disp->mTransitionPropertyCount == 1 &&
+      oldDisp->mTransitionPropertyCount == 1 &&
       disp->mTransitions[0].GetDelay() == 0.0f &&
-      disp->mTransitions[0].GetDuration() == 0.0f) {
+      disp->mTransitions[0].GetDuration() == 0.0f &&
+      oldDisp->mTransitions[0].GetProperty() ==
+        disp->mTransitions[0].GetProperty()) {
     return nsnull;
   }      
 
 
   if (aNewStyleContext->PresContext()->IsProcessingAnimationStyleChange()) {
     return nsnull;
   }
   
@@ -397,28 +401,27 @@ nsTransitionManager::StyleContextChanged
   }
 
   // Per http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html
   // I'll consider only the transitions from the number of items in
   // 'transition-property' on down, and later ones will override earlier
   // ones (tracked using |whichStarted|).
   PRBool startedAny = PR_FALSE;
   nsCSSPropertySet whichStarted;
-  ElementTransitions *et = nsnull;
+  ElementTransitions *et =
+      GetElementTransitions(aElement, aNewStyleContext->GetPseudo(), PR_FALSE);
   for (PRUint32 i = disp->mTransitionPropertyCount; i-- != 0; ) {
     const nsTransition& t = disp->mTransitions[i];
     // Check delay and duration first, since they default to zero, and
     // when they're both zero, we can ignore the transition.
     if (t.GetDelay() != 0.0f || t.GetDuration() != 0.0f) {
-      et = GetElementTransitions(aElement,
-                                 aNewStyleContext->GetPseudo(),
-                                 PR_FALSE);
-
       // We might have something to transition.  See if any of the
       // properties in question changed and are animatable.
+      // FIXME: Would be good to find a way to share code between this
+      // interpretation of transition-property and the one below.
       nsCSSProperty property = t.GetProperty();
       if (property == eCSSPropertyExtra_no_properties ||
           property == eCSSProperty_UNKNOWN) {
         // Nothing to do, but need to exclude this from cases below.
       } else if (property == eCSSPropertyExtra_all_properties) {
         for (nsCSSProperty p = nsCSSProperty(0); 
              p < eCSSProperty_COUNT_no_shorthands;
              p = nsCSSProperty(p + 1)) {
@@ -435,16 +438,63 @@ nsTransitionManager::StyleContextChanged
       } else {
         ConsiderStartingTransition(property, t, aElement, et,
                                    aOldStyleContext, aNewStyleContext,
                                    &startedAny, &whichStarted);
       }
     }
   }
 
+  // Stop any transitions for properties that are no longer in
+  // 'transition-property'.
+  PRBool didStop = PR_FALSE;
+  if (et && disp->mTransitions[0].GetProperty() !=
+            eCSSPropertyExtra_all_properties) {
+    nsCSSPropertySet allTransitionProperties;
+    for (PRUint32 i = disp->mTransitionPropertyCount; i-- != 0; ) {
+      const nsTransition& t = disp->mTransitions[i];
+      // FIXME: Would be good to find a way to share code between this
+      // interpretation of transition-property and the one above.
+      nsCSSProperty property = t.GetProperty();
+      if (property == eCSSPropertyExtra_no_properties ||
+          property == eCSSProperty_UNKNOWN) {
+        // Nothing to do, but need to exclude this from cases below.
+      } else if (property == eCSSPropertyExtra_all_properties) {
+        for (nsCSSProperty p = nsCSSProperty(0); 
+             p < eCSSProperty_COUNT_no_shorthands;
+             p = nsCSSProperty(p + 1)) {
+          allTransitionProperties.AddProperty(p);
+        }
+      } else if (nsCSSProps::IsShorthand(property)) {
+        CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(subprop, property) {
+          allTransitionProperties.AddProperty(*subprop);
+        }
+      } else {
+        allTransitionProperties.AddProperty(property);
+      }
+    }
+
+    nsTArray<ElementPropertyTransition> &pts = et->mPropertyTransitions;
+    PRUint32 i = pts.Length();
+    NS_ABORT_IF_FALSE(i != 0, "empty transitions list?");
+    do {
+      --i;
+      ElementPropertyTransition &pt = pts[i];
+      if (!allTransitionProperties.HasProperty(pt.mProperty)) {
+        pts.RemoveElementAt(i);
+        didStop = PR_TRUE;
+      }
+    } while (i != 0);
+
+    if (pts.IsEmpty()) {
+      et->Destroy();
+      et = nsnull;
+    }
+  }
+
   if (!startedAny) {
     return nsnull;
   }
 
   NS_ABORT_IF_FALSE(et, "must have element transitions if we started "
                         "any transitions");
 
   // In the CSS working group discussion (2009 Jul 15 telecon,
@@ -549,17 +599,17 @@ nsTransitionManager::ConsiderStartingTra
       nsTArray<ElementPropertyTransition> &pts =
         aElementTransitions->mPropertyTransitions;
       pts.RemoveElementAt(currentIndex);
       if (pts.IsEmpty()) {
         aElementTransitions->Destroy();
         // |aElementTransitions| is now a dangling pointer!
         aElementTransitions = nsnull;
       }
-      presContext->PresShell()->RestyleForAnimation(aElement);
+      // WalkTransitionRule already called RestyleForAnimation.
     }
     return;
   }
 
   // When we interrupt a running transition, we want to reduce the
   // duration of the new transition *if* the new transition would have
   // been longer had it started from the endpoint of the currently
   // running transition.
@@ -571,19 +621,17 @@ nsTransitionManager::ConsiderStartingTra
   if (currentIndex != nsTArray<ElementPropertyTransition>::NoIndex) {
     const nsStyleAnimation::Value &endVal =
       aElementTransitions->mPropertyTransitions[currentIndex].mEndValue;
 
     if (endVal == pt.mEndValue) {
       // If we got a style change that changed the value to the endpoint
       // of the currently running transition, we don't want to interrupt
       // its timing function.
-      // But don't forget to restyle with animation so we show the
-      // current transition.
-      presContext->PresShell()->RestyleForAnimation(aElement);
+      // WalkTransitionRule already called RestyleForAnimation.
       return;
     }
 
     double fullDistance, remainingDistance;
 #ifdef DEBUG
     PRBool ok =
 #endif
       nsStyleAnimation::ComputeDistance(pt.mStartValue, pt.mEndValue,
@@ -728,19 +776,19 @@ nsTransitionManager::WalkTransitionRule(
                                         nsIAtom *aPseudo)
 {
   if (!aData->mPresContext->IsProcessingAnimationStyleChange()) {
     // If we're processing a normal style change rather than one from
     // animation, don't add the transition rule.  This allows us to
     // compute the new style value rather than having the transition
     // override it, so that we can start transitioning differently.
 
-    // In most cases, we need to immediately restyle with animation
-    // after doing this.  However, ConsiderStartingTransition takes care
-    // of that for us.
+    // We need to immediately restyle with animation
+    // after doing this.
+    mPresContext->PresShell()->RestyleForAnimation(aData->mContent);
     return NS_OK;
   }
 
   ElementTransitions *et =
     GetElementTransitions(aData->mContent, aPseudo, PR_FALSE);
   if (!et) {
     return NS_OK;
   }
diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -133,16 +133,17 @@ _TEST_FILES =	test_acid3_test46.html \
 		test_selectors_on_anonymous_content.html \
 		test_shorthand_property_getters.html \
 		test_style_struct_copy_constructors.html \
 		test_system_font_serialization.html \
 		test_transitions_computed_values.html \
 		test_transitions_computed_value_combinations.html \
 		test_transitions.html \
 		test_transitions_per_property.html \
+		test_transitions_dynamic_changes.html \
 		test_units_angle.html \
 		test_units_frequency.html \
 		test_units_length.html \
 		test_units_time.html \
 		test_value_cloning.html \
 		test_value_computation.html \
 		test_value_storage.html \
 		test_visited_pref.html \
diff --git a/layout/style/test/test_transitions_dynamic_changes.html b/layout/style/test/test_transitions_dynamic_changes.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_transitions_dynamic_changes.html
@@ -0,0 +1,46 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=525530
+-->
+<head>
+  <title>Test for Bug 525530</title>
+  <script type="application/javascript" src="/MochiKit/packed.js"></script>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=525530">Mozilla Bug 525530</a>
+<p id="display" style="text-indent: 100px"></p>
+<pre id="test">
+<script type="application/javascript">
+
+/** Test for Bug 525530 **/
+
+var p = document.getElementById("display");
+var cs = getComputedStyle(p, "");
+
+p.style.MozTransitionProperty = "all";
+p.style.MozTransitionDuration = "4s";
+p.style.MozTransitionDelay = "-2s";
+p.style.MozTransitionTimingFunction = "linear";
+
+is(cs.textIndent, "100px", "initial value");
+
+p.style.textIndent = "0";
+is(cs.textIndent, "50px", "transition is halfway");
+p.style.MozTransitionDuration = "0";
+is(cs.textIndent, "50px", "changing duration doesn't change transitioning");
+p.style.MozTransitionDelay = "0";
+is(cs.textIndent, "50px", "changing delay doesn't change transitioning");
+p.style.MozTransitionProperty = "text-indent";
+is(cs.textIndent, "50px",
+   "irrelevant change to transition property doesn't change transitioning");
+p.style.MozTransitionProperty = "font";
+is(cs.textIndent, "0px",
+   "relevant change to transition property doesn't change transitioning");
+
+</script>
+</pre>
+</body>
+</html>
