From: L. David Baron <dbaron@dbaron.org>

When a wrapper is expired, do deferred release of mIdentity to fix bug 629610, and also lock the wrapped native map appropriately to fix bug 645442.  Accomplish both of these by sharing more code between FlatJSObjectFinalized and ~XPCWrappedNative.

NOTE: passed try (all platforms, all unit tests)

diff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h
--- a/js/src/xpconnect/src/xpcprivate.h
+++ b/js/src/xpconnect/src/xpcprivate.h
@@ -2788,16 +2788,17 @@ protected:
                      XPCWrappedNativeProto* aProto);
 
     // This ctor is used if this object will NOT have a proto.
     XPCWrappedNative(already_AddRefed<nsISupports> aIdentity,
                      XPCWrappedNativeScope* aScope,
                      XPCNativeSet* aSet);
 
     virtual ~XPCWrappedNative();
+    void Destroy();
 
 private:
     enum {
         NEEDS_SOW = JS_BIT(0),
         NEEDS_COW = JS_BIT(1),
 
         LAST_FLAG = NEEDS_COW,
 
diff --git a/js/src/xpconnect/src/xpcwrappednative.cpp b/js/src/xpconnect/src/xpcwrappednative.cpp
--- a/js/src/xpconnect/src/xpcwrappednative.cpp
+++ b/js/src/xpconnect/src/xpcwrappednative.cpp
@@ -924,23 +924,30 @@ XPCWrappedNative::XPCWrappedNative(alrea
 
     DEBUG_TrackNewWrapper(this);
 }
 
 XPCWrappedNative::~XPCWrappedNative()
 {
     DEBUG_TrackDeleteWrapper(this);
 
+    Destroy();
+}
+
+void
+XPCWrappedNative::Destroy()
+{
     XPCWrappedNativeProto* proto = GetProto();
 
     if(mScriptableInfo &&
        (!HasProto() ||
         (proto && proto->GetScriptableInfo() != mScriptableInfo)))
     {
         delete mScriptableInfo;
+        mScriptableInfo = nsnull;
     }
 
     XPCWrappedNativeScope *scope = GetScope();
     if(scope)
     {
         Native2WrappedNativeMap* map = scope->GetWrappedNativeMap();
 
         // scoped lock
@@ -951,28 +958,34 @@ XPCWrappedNative::~XPCWrappedNative()
         map->Remove(this);
     }
 
     if(mIdentity)
     {
         XPCJSRuntime* rt = GetRuntime();
         if(rt && rt->GetDoingFinalization())
         {
-            if(!rt->DeferredRelease(mIdentity))
+            if(rt->DeferredRelease(mIdentity))
+            {
+                mIdentity = nsnull;
+            }
+            else
             {
                 NS_WARNING("Failed to append object for deferred release.");
                 // XXX do we really want to do this???
                 NS_RELEASE(mIdentity);
             }
         }
         else
         {
             NS_RELEASE(mIdentity);
         }
     }
+
+    mMaybeScope = nsnull;
 }
 
 // This is factored out so that it can be called publicly 
 // static
 void 
 XPCWrappedNative::GatherProtoScriptableCreateInfo(
                         nsIClassInfo* classInfo,
                         XPCNativeScriptableCreateInfo& sciProto)
@@ -1269,17 +1282,18 @@ NS_IMPL_THREADSAFE_RELEASE(XPCWrappedNat
  *    the native caller that caused the wrapper creation).
  *  - During the JS GC Mark phase we mark any wrapper with a refcount > 1.
  *  - The *only* thing that can make the wrapper get destroyed is the
  *    finalization of mFlatJSObject. And *that* should only happen if the only
  *    reference is the single extra (internal) reference we hold.
  *
  *  - The wrapper has a pointer to the nsISupports 'view' of the wrapped native
  *    object i.e... mIdentity. This is held until the wrapper's refcount goes
- *    to zero and the wrapper is released.
+ *    to zero and the wrapper is released, or until an expired wrapper (i.e.,
+ *    one unlinked by the cycle collector) has had its JS object finalized.
  *
  *  - The wrapper also has 'tearoffs'. It has one tearoff for each interface
  *    that is actually used on the native object. 'Used' means we have either
  *    needed to QueryInterface to verify the availability of that interface
  *    of that we've had to QueryInterface in order to actually make a call
  *    into the wrapped object via the pointer for the given interface.
  *
  *  - Each tearoff's 'mNative' member (if non-null) indicates one reference
@@ -1364,48 +1378,36 @@ XPCWrappedNative::FlatJSObjectFinalized(
                 }
                 to->SetNative(nsnull);
             }
 
             to->SetInterface(nsnull);
         }
     }
 
-    if(IsWrapperExpired())
-    {
-        GetScope()->GetWrappedNativeMap()->Remove(this);
-
-        XPCWrappedNativeProto* proto = GetProto();
-
-        if(mScriptableInfo &&
-           (!HasProto() ||
-            (proto && proto->GetScriptableInfo() != mScriptableInfo)))
-        {
-            delete mScriptableInfo;
-            mScriptableInfo = nsnull;
-        }
-
-        mMaybeScope = nsnull;
-    }
-
     nsWrapperCache *cache = nsnull;
     CallQueryInterface(mIdentity, &cache);
     if(cache)
         cache->ClearWrapper();
 
     // This makes IsValid return false from now on...
     mFlatJSObject = nsnull;
 
     NS_ASSERTION(mIdentity, "bad pointer!");
 #ifdef XP_WIN
     // Try to detect free'd pointer
     NS_ASSERTION(*(int*)mIdentity != 0xdddddddd, "bad pointer!");
     NS_ASSERTION(*(int*)mIdentity != 0,          "bad pointer!");
 #endif
 
+    if(IsWrapperExpired())
+    {
+        Destroy();
+    }
+
     // Note that it's not safe to touch mNativeWrapper here since it's
     // likely that it has already been finalized.
 
     Release();
 }
 
 void
 XPCWrappedNative::SystemIsBeingShutDown(JSContext* cx)
