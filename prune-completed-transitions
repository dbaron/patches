From: L. David Baron <dbaron@dbaron.org>

Bug 1144410 - Remove completed transitions when a frame transitions away from being display:none.

This really fixes only part of the set of problems described in bug
1158431, which also affect running transitions.  However, it's the part
of that set that was a regression from bug 960465, which introduced the
concept of completed transitions, and which makes these issues
substantially easier to hit.

I'd like to fix this part quickly because it's a regression and we
should backport the fix.

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -83,16 +83,17 @@
 #include "nsBlockFrame.h"
 #include "nsCanvasFrame.h"
 #include "nsFirstLetterFrame.h"
 #include "nsGfxScrollFrame.h"
 #include "nsPageFrame.h"
 #include "nsSimplePageSequenceFrame.h"
 #include "nsTableOuterFrame.h"
 #include "nsIScrollableFrame.h"
+#include "nsTransitionManager.h"
 
 #ifdef MOZ_XUL
 #include "nsIRootBox.h"
 #endif
 #ifdef ACCESSIBILITY
 #include "nsAccessibilityService.h"
 #endif
 
@@ -1798,16 +1799,20 @@ nsCSSFrameConstructor::CreateGeneratedCo
     RestyleManager()->GetReframingStyleContexts();
   if (rsc) {
     nsStyleContext* oldStyleContext = rsc->Get(container, aPseudoElement);
     if (oldStyleContext) {
       RestyleManager::TryStartingTransition(aState.mPresContext,
                                             container,
                                             oldStyleContext,
                                             &pseudoStyleContext);
+    } else {
+      aState.mPresContext->TransitionManager()->
+        PruneCompletedTransitions(container, aPseudoElement,
+                                  pseudoStyleContext);
     }
   }
 
   uint32_t contentCount = pseudoStyleContext->StyleContent()->ContentCount();
   for (uint32_t contentIndex = 0; contentIndex < contentCount; contentIndex++) {
     nsCOMPtr<nsIContent> content =
       CreateGeneratedContent(aState, aParentContent, pseudoStyleContext,
                              contentIndex);
@@ -4842,20 +4847,24 @@ nsCSSFrameConstructor::ResolveStyleConte
     result = styleSet->ResolveStyleForNonElement(aParentStyleContext);
   }
 
   RestyleManager::ReframingStyleContexts* rsc =
     RestyleManager()->GetReframingStyleContexts();
   if (rsc) {
     nsStyleContext* oldStyleContext =
       rsc->Get(aContent, nsCSSPseudoElements::ePseudo_NotPseudoElement);
+    nsPresContext* presContext = mPresShell->GetPresContext();
     if (oldStyleContext) {
-      RestyleManager::TryStartingTransition(mPresShell->GetPresContext(),
-                                            aContent,
+      RestyleManager::TryStartingTransition(presContext, aContent,
                                             oldStyleContext, &result);
+    } else {
+      presContext->TransitionManager()->
+        PruneCompletedTransitions(aContent->AsElement(),
+          nsCSSPseudoElements::ePseudo_NotPseudoElement, result);
     }
   }
 
   return result.forget();
 }
 
 // MathML Mod - RBS
 void
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -276,16 +276,18 @@ nsTransitionManager::StyleContextChanged
 
   // Stop any transitions for properties that are no longer in
   // 'transition-property', including finished transitions.
   // Also stop any transitions (and remove any finished transitions)
   // for properties that just changed (and are still in the set of
   // properties to transition), but for which we didn't just start the
   // transition.  This can happen delay and duration are both zero, or
   // because the new value is not interpolable.
+  // Note that we also do the latter set of work in
+  // nsTransitionManager::PruneCompletedTransitions.
   if (collection) {
     bool checkProperties =
       disp->mTransitions[0].GetProperty() != eCSSPropertyExtra_all_properties;
     nsCSSPropertySet allTransitionProperties;
     if (checkProperties) {
       for (uint32_t i = disp->mTransitionPropertyCount; i-- != 0; ) {
         const StyleTransition& t = disp->mTransitions[i];
         // FIXME: Would be good to find a way to share code between this
@@ -604,16 +606,63 @@ nsTransitionManager::ConsiderStartingTra
   }
   aElementTransitions->UpdateAnimationGeneration(mPresContext);
 
   *aStartedAny = true;
   aWhichStarted->AddProperty(aProperty);
 }
 
 void
+nsTransitionManager::PruneCompletedTransitions(mozilla::dom::Element *aElement,
+                                               nsCSSPseudoElements::Type
+                                                 aPseudoType,
+                                               nsStyleContext *aNewStyleContext)
+{
+  AnimationCollection* collection = GetAnimations(aElement, aPseudoType, false);
+  if (!collection) {
+    return;
+  }
+
+  // Remove any finished transitions whose style doesn't match the new
+  // style.
+  // This is similar to some of the work that happens near the end of
+  // nsTransitionManager::StyleContextChanged.
+  // FIXME (bug 1158431): Really, we should also cancel running
+  // transitions whose destination doesn't match as well.
+  AnimationPtrArray& animations = collection->mAnimations;
+  size_t i = animations.Length();
+  MOZ_ASSERT(i != 0, "empty transitions list?");
+  do {
+    --i;
+    Animation* anim = animations[i];
+    dom::KeyframeEffectReadonly* effect = anim->GetEffect();
+
+    if (!effect->IsFinishedTransition()) {
+      continue;
+    }
+
+    MOZ_ASSERT(effect && effect->Properties().Length() == 1,
+               "Should have one animation property for a transition");
+    MOZ_ASSERT(effect && effect->Properties()[0].mSegments.Length() == 1,
+               "Animation property should have one segment for a transition");
+    const AnimationProperty& prop = effect->Properties()[0];
+    const AnimationPropertySegment& segment = prop.mSegments[0];
+
+    // Since effect is a finished transition, we know it didn't
+    // influence style.
+    StyleAnimationValue currentValue;
+    if (!ExtractComputedValueForTransition(prop.mProperty, aNewStyleContext,
+                                           currentValue) ||
+        currentValue != segment.mToValue) {
+      animations.RemoveElementAt(i);
+    }
+  } while (i != 0);
+}
+
+void
 nsTransitionManager::UpdateCascadeResultsWithTransitions(
                        AnimationCollection* aTransitions)
 {
   AnimationCollection* animations = mPresContext->AnimationManager()->
       GetAnimations(aTransitions->mElement,
                     aTransitions->PseudoElementType(), false);
   UpdateCascadeResults(aTransitions, animations);
 }
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
--- a/layout/style/nsTransitionManager.h
+++ b/layout/style/nsTransitionManager.h
@@ -131,16 +131,28 @@ public:
    * *aNewStyleContext) to cover up some of the changes for the duration
    * of the restyling of descendants.  If it does, this function will
    * take care of causing the necessary restyle afterwards.
    */
   void StyleContextChanged(mozilla::dom::Element *aElement,
                            nsStyleContext *aOldStyleContext,
                            nsRefPtr<nsStyleContext>* aNewStyleContext /* inout */);
 
+  /**
+   * When we're resolving style for an element that previously didn't have
+   * style, we might have some old completed transitions for it, if,
+   * say, it was display:none for a bit, but previously displayed.
+   *
+   * This method removes any completed transitions that don't match the
+   * new style.
+   */
+  void PruneCompletedTransitions(mozilla::dom::Element *aElement,
+                                 nsCSSPseudoElements::Type aPseudoType,
+                                 nsStyleContext *aNewStyleContext);
+
   void UpdateCascadeResultsWithTransitions(AnimationCollection* aTransitions);
   void UpdateCascadeResultsWithAnimations(AnimationCollection* aAnimations);
   void UpdateCascadeResultsWithAnimationsToBeDestroyed(
          const AnimationCollection* aAnimations);
   void UpdateCascadeResults(AnimationCollection* aTransitions,
                             AnimationCollection* aAnimations);
 
   void SetInAnimationOnlyStyleUpdate(bool aInAnimationOnlyUpdate) {
