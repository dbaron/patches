From: L. David Baron <dbaron@dbaron.org>

Bug 1209603 patch 7 - Record in mBits when we have gotten a reset style struct that is cached on the rule node.

I'm a little worried about the performance of the change to
nsRuleNode::GetStyle*, which sets a bit on the style context every time
a struct getter goes through it.  It's not obvious how that compares to
the performance benefit from patch 8.

FIXME: Doesn't compile yet due to incomplete type nsStyleContext in
nsRuleNode.h

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -2374,16 +2374,21 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
 
   if (detail == eRuleNone && startStruct) {
     // We specified absolutely no rule information, but a parent rule in the tree
     // specified all the rule information.  We set a bit along the branch from our
     // node in the tree to the node that specified the data that tells nodes on that
     // branch that they never need to examine their rules for this particular struct type
     // ever again.
     PropagateDependentBit(aSID, ruleNode, startStruct);
+    if (!isReset) {
+      // Record that we have asked for this struct on this context, but
+      // it is not cached on the context.
+      aContext->AddStyleBit(nsCachedStyleData::GetBitForSID(aSID));
+    }
     return startStruct;
   }
   if ((!startStruct && !isReset &&
        (detail == eRuleNone || detail == eRulePartialInherited)) ||
       detail == eRuleFullInherited) {
     // We specified no non-inherited information and neither did any of
     // our parent rules.
 
@@ -2743,18 +2748,17 @@ nsRuleNode::SetDefaultOnRoot(const nsSty
     NS_ASSERTION(!aHighestNode->mStyleData.mInheritedData->                   \
                    mStyleStructs[eStyleStruct_##type_],                       \
                  "Going to leak style data");                                 \
     aHighestNode->mStyleData.mInheritedData->                                 \
       mStyleStructs[eStyleStruct_##type_] = data_;                            \
     /* Propagate the bit down. */                                             \
     PropagateDependentBit(eStyleStruct_##type_, aHighestNode, data_);         \
     /* Tell the style context that it doesn't own the data */                 \
-    aContext->                                                                \
-      AddStyleBit(nsCachedStyleData::GetBitForSID(eStyleStruct_##type_));     \
+    aContext->AddStyleBit(NS_STYLE_INHERIT_BIT(type_));                       \
   }                                                                           \
   /* Always cache inherited data on the style context */                      \
   aContext->SetStyle##type_(data_);                                           \
                                                                               \
   return data_;
 
 /**
  * End an nsRuleNode::Compute*Data function for a reset struct.
@@ -2779,25 +2783,27 @@ nsRuleNode::SetDefaultOnRoot(const nsSty
     }                                                                         \
     NS_ASSERTION(!aHighestNode->mStyleData.mResetData->                       \
                    GetStyleData(eStyleStruct_##type_),                        \
                  "Going to leak style data");                                 \
     aHighestNode->mStyleData.mResetData->                                     \
       SetStyleData(eStyleStruct_##type_, data_);                              \
     /* Propagate the bit down. */                                             \
     PropagateDependentBit(eStyleStruct_##type_, aHighestNode, data_);         \
+    /* Tell the context that we've gotten the data (separate meaning */       \
+    /* of mBits when the cached data pointer is null) */                      \
+    aContext->AddStyleBit(NS_STYLE_INHERIT_BIT(type_));                       \
   } else if (conditions.Cacheable()) {                                        \
     if (!mStyleData.mResetData) {                                             \
       mStyleData.mResetData = new (mPresContext) nsConditionalResetStyleData; \
     }                                                                         \
     mStyleData.mResetData->                                                   \
       SetStyleData(eStyleStruct_##type_, mPresContext, data_, conditions);    \
     /* Tell the style context that it doesn't own the data */                 \
-    aContext->                                                                \
-      AddStyleBit(nsCachedStyleData::GetBitForSID(eStyleStruct_##type_));     \
+    aContext->AddStyleBit(NS_STYLE_INHERIT_BIT(type_));                       \
     aContext->SetStyle(eStyleStruct_##type_, data_);                          \
   } else {                                                                    \
     /* We can't be cached in the rule node.  We have to be put right */       \
     /* on the style context. */                                               \
     aContext->SetStyle(eStyleStruct_##type_, data_);                          \
     if (aContext->GetParent()) {                                              \
       /* This is pessimistic; we could be uncacheable because we had a */     \
       /* relative font-weight, for example, which does not need to defeat */  \
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -924,18 +924,20 @@ public:
                "style context should not have cached data for struct");       \
                                                                               \
     const nsStyle##name_ *data;                                               \
                                                                               \
     /* Never use cached data for animated style inside a pseudo-element; */   \
     /* see comment on cacheability in AnimValuesStyleRule::MapRuleInfoInto */ \
     if (!(HasAnimationData() && ParentHasPseudoElementData(aContext))) {      \
       data = mStyleData.GetStyle##name_(aContext);                            \
-      if (MOZ_LIKELY(data != nullptr))                                        \
+      if (MOZ_LIKELY(data != nullptr)) {                                      \
+        aContext->AddStyleBit(NS_STYLE_INHERIT_BIT(name_));                   \
         return data;                                                          \
+      }                                                                       \
     }                                                                         \
                                                                               \
     if (!aComputeData)                                                        \
       return nullptr;                                                         \
                                                                               \
     data = static_cast<const nsStyle##name_ *>                                \
              (WalkRuleTree(eStyleStruct_##name_, aContext));                  \
                                                                               \
@@ -1052,11 +1054,19 @@ public:
    *         aPresContext and aStyleContext are non-null
    */
   static bool ComputeColor(const nsCSSValue& aValue,
                            nsPresContext* aPresContext,
                            nsStyleContext* aStyleContext,
                            nscolor& aResult);
 
   static bool ParentHasPseudoElementData(nsStyleContext* aContext);
+
+private:
+#ifdef DEBUG
+  // non-inline helper function to allow assertions without incomplete
+  // type errors
+  bool ContextHasCachedData(nsStyleContext* aContext, nsStyleStructID aSID);
+#endif
+
 };
 
 #endif
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -597,16 +597,21 @@ private:
   nsResetStyleData*       mCachedResetData; // Cached reset style data.
   nsInheritedStyleData    mCachedInheritedData; // Cached inherited style data
 
   // mBits stores a number of things:
   //  - For all structs (those with inherited properties), when they are
   //    non-null in the style context's storage, it records (using the
   //    style struct bits) which structs are inherited from the parent
   //    context or owned by mRuleNode.
+  //  - For reset (non-inherited) style structs, when they are null in
+  //    the style context's storage, it records that we have had
+  //    GetStyleData() called for that struct.  (We don't need this for
+  //    inherited structs since we always cache them in
+  //    mCachedInheritedData.)
   //  - It also stores the additional bits listed at the top of
   //    nsStyleStruct.h.
   uint64_t                mBits;
 
   uint32_t                mRefCnt;
 
 #ifdef DEBUG
   uint32_t                mFrameRefCnt; // number of frames that use this
