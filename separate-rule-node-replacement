From: L. David Baron <dbaron@dbaron.org>

Bug 996796 patch 11 - Separate the rule node replacement code from the style context handling so that we can make visited handling correct.

diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1317,28 +1317,28 @@ static const CascadeLevel gCascadeLevels
   { nsStyleSet::eDocSheet,        true,  nsRestyleHint(0) },
   { nsStyleSet::eStyleAttrSheet,  true,  nsRestyleHint(0) },
   { nsStyleSet::eOverrideSheet,   true,  nsRestyleHint(0) },
   { nsStyleSet::eUserSheet,       true,  nsRestyleHint(0) },
   { nsStyleSet::eAgentSheet,      true,  nsRestyleHint(0) },
   { nsStyleSet::eTransitionSheet, false, eRestyle_CSSTransitions },
 };
 
-already_AddRefed<nsStyleContext>
-nsStyleSet::ResolveStyleWithReplacement(Element* aElement,
-                                        nsStyleContext* aParentStyleContext,
-                                        nsStyleContext* aOldStyleContext,
-                                        nsRestyleHint aReplacements)
+nsRuleNode*
+nsStyleSet::RuleNodeWithReplacement(Element* aElement,
+                                    nsRuleNode* aOldRuleNode,
+                                    nsCSSPseudoElements::Type aPseudoType,
+                                    nsRestyleHint aReplacements)
 {
   MOZ_ASSERT(!(aReplacements & ~(eRestyle_CSSTransitions |
                                  eRestyle_CSSAnimations)),
              "unexpected replacement bits");
 
   nsTArray<RuleNodeInfo> rules;
-  for (nsRuleNode* ruleNode = aOldStyleContext->RuleNode(); !ruleNode->IsRoot();
+  for (nsRuleNode* ruleNode = aOldRuleNode; !ruleNode->IsRoot();
        ruleNode = ruleNode->GetParent()) {
     RuleNodeInfo* curRule = rules.AppendElement();
     curRule->mRule = ruleNode->GetRule();
     curRule->mLevel = ruleNode->GetLevel();
     curRule->mIsImportant = ruleNode->IsImportantRule();
   }
 
   nsRuleWalker ruleWalker(mRuleTree, mAuthorStyleDisabled);
@@ -1352,32 +1352,30 @@ nsStyleSet::ResolveStyleWithReplacement(
     bool doReplace = level->mLevelReplacementHint & aReplacements;
     if (doReplace) {
       switch (level->mLevelReplacementHint) {
       case eRestyle_CSSAnimations:
         {
           nsAnimationManager* animationManager =
             PresContext()->AnimationManager();
           ElementAnimations* ea = animationManager->GetElementAnimations(
-            aElement, aOldStyleContext->GetPseudoType(), false);
+            aElement, aPseudoType, false);
           NS_ASSERTION(ea,
             "Rule has level eAnimationSheet without animation on manager");
 
           animationManager->EnsureStyleRuleFor(ea);
           ruleWalker.ForwardOnPossiblyCSSRule(ea->mStyleRule);
         }
         break;
       case eRestyle_CSSTransitions:
         {
           nsPresContext* presContext = PresContext();
           ElementTransitions *et =
             presContext->TransitionManager()->GetElementTransitions(
-              aElement,
-              aOldStyleContext->GetPseudoType(),
-              false);
+              aElement, aPseudoType, false);
           NS_ASSERTION(et,
             "Rule has level eTransitionSheet without transition on manager");
 
           et->EnsureStyleRuleFor(presContext->RefreshDriver()->MostRecentRefresh());
           ruleWalker.ForwardOnPossiblyCSSRule(et->mStyleRule);
         }
         break;
       default:
@@ -1396,27 +1394,40 @@ nsStyleSet::ResolveStyleWithReplacement(
       }
 
       if (!doReplace) {
         ruleWalker.ForwardOnPossiblyCSSRule(ruleInfo.mRule);
       }
     }
   }
 
+  return ruleWalker.CurrentNode();
+}
+
+already_AddRefed<nsStyleContext>
+nsStyleSet::ResolveStyleWithReplacement(Element* aElement,
+                                        nsStyleContext* aParentStyleContext,
+                                        nsStyleContext* aOldStyleContext,
+                                        nsRestyleHint aReplacements)
+{
+  nsRuleNode* ruleNode =
+    RuleNodeWithReplacement(aElement, aOldStyleContext->RuleNode(),
+                            aOldStyleContext->GetPseudoType(), aReplacements);
+
   // FIXME: Does this handle visited contexts correctly???
 
   uint32_t flags = eNoFlags;
   if (aOldStyleContext->IsLinkContext()) {
     flags |= eIsLink;
   }
   if (aOldStyleContext->RelevantLinkVisited()) {
     flags |= eIsVisitedLink;
   }
 
-  return GetContext(aParentStyleContext, ruleWalker.CurrentNode(), nullptr,
+  return GetContext(aParentStyleContext, ruleNode, nullptr,
                     nullptr, nsCSSPseudoElements::ePseudo_NotPseudoElement,
                     nullptr, flags);
 }
 
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForNonElement(nsStyleContext* aParentContext)
 {
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -382,16 +382,22 @@ class nsStyleSet
                  nsRuleWalker* aRuleWalker);
 
   // Enumerate all the rules in a way that doesn't care about the order
   // of the rules and break out if the enumeration is halted.
   void WalkRuleProcessors(nsIStyleRuleProcessor::EnumFunc aFunc,
                           ElementDependentRuleProcessorData* aData,
                           bool aWalkAllXBLStylesheets);
 
+  // Helper for ResolveStyleWithReplacement
+  nsRuleNode* RuleNodeWithReplacement(mozilla::dom::Element* aElement,
+                                      nsRuleNode* aOldRuleNode,
+                                      nsCSSPseudoElements::Type aPseudoType,
+                                      nsRestyleHint aReplacements);
+
   /**
    * Bit-flags that can be passed to GetContext() in its parameter 'aFlags'.
    */
   enum {
     eNoFlags =          0,
     eIsLink =           1 << 0,
     eIsVisitedLink =    1 << 1,
     eDoAnimation =      1 << 2,
