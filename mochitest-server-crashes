Don't rely on NS_TraceMallocStartupArgs to initialize TLS index.  (Bug 442192)

diff --git a/tools/trace-malloc/lib/nsTraceMalloc.c b/tools/trace-malloc/lib/nsTraceMalloc.c
--- a/tools/trace-malloc/lib/nsTraceMalloc.c
+++ b/tools/trace-malloc/lib/nsTraceMalloc.c
@@ -231,17 +231,17 @@ static uint32 tracing_enabled = 0;
 #define TM_CREATE_TLS_INDEX(i_)         pthread_key_create(&(i_), NULL)
 #define TM_DESTROY_TLS_INDEX(i_)        pthread_key_delete((i_))
 #define TM_GET_TLS_DATA(i_)             pthread_getspecific((i_))
 #define TM_SET_TLS_DATA(i_, v_)         pthread_setspecific((i_), (v_))
 
 #endif
 
 static TM_TLS_INDEX_TYPE tls_index;
-static tm_thread main_thread; /* 0-initialization is correct */
+static PRBool tls_index_initialized = PR_FALSE;
 
 /* FIXME (maybe): This is currently unused; we leak the thread-local data. */
 #if 0
 static void
 free_tm_thread(void *priv)
 {
     tm_thread *t = (tm_thread*) priv;
 
@@ -258,18 +258,26 @@ free_tm_thread(void *priv)
 #endif
 
 tm_thread *
 tm_get_thread(void)
 {
     tm_thread *t;
     tm_thread stack_tm_thread;
 
-    if (!tmlock) {
-        return &main_thread;
+    if (!tls_index_initialized) {
+        /**
+         * Assume that the first call to |malloc| will occur before
+         * there are multiple threads.  (If that's not the case, we
+         * probably need to do the necessary synchronization without
+         * using NSPR primitives.  See discussion in
+         * https://bugzilla.mozilla.org/show_bug.cgi?id=442192
+         */
+        TM_CREATE_TLS_INDEX(tls_index);
+        tls_index_initialized = PR_TRUE;
     }
 
     t = TM_GET_TLS_DATA(tls_index);
 
     if (!t) {
         /*
          * First, store a tm_thread on the stack to suppress for the
          * malloc below
@@ -734,17 +742,17 @@ calltree(void **stack, size_t num_stack_
                     /* We already logged an event on fp for this library. */
                     le = NULL;
                 }
             } else {
                 library = strdup(details.library);
                 if (library) {
                     library_serial = ++library_serial_generator;
                     he = PL_HashTableRawAdd(libraries, hep, hash, library,
-                                            (void*) library_serial);
+                                            NS_INT32_TO_PTR(library_serial));
                 }
                 if (!he) {
                     tmstats.btmalloc_failures++;
                     goto fail;
                 }
                 le = (lfdset_entry *) he;
             }
             if (le) {
@@ -781,17 +789,17 @@ calltree(void **stack, size_t num_stack_
                 /* We already logged an event on fp for this filename. */
                 le = NULL;
             }
         } else {
             filename = strdup(filename);
             if (filename) {
                 filename_serial = ++filename_serial_generator;
                 he = PL_HashTableRawAdd(filenames, hep, hash, filename,
-                                        (void*) filename_serial);
+                                        NS_INT32_TO_PTR(filename_serial));
             }
             if (!he) {
                 tmstats.btmalloc_failures++;
                 return NULL;
             }
             le = (lfdset_entry *) he;
         }
         if (le) {
@@ -828,17 +836,17 @@ calltree(void **stack, size_t num_stack_
                 /* We already logged an event on fp for this method. */
                 le = NULL;
             }
         } else {
             method = strdup(details.function);
             if (method) {
                 method_serial = ++method_serial_generator;
                 he = PL_HashTableRawAdd(methods, hep, hash, method,
-                                        (void*) method_serial);
+                                        NS_INT32_TO_PTR(method_serial));
             }
             if (!he) {
                 tmstats.btmalloc_failures++;
                 return NULL;
             }
             le = (lfdset_entry *) he;
         }
         if (le) {
@@ -1340,27 +1348,18 @@ NS_TraceMallocStartup(int logfd)
         logfile_list = &default_logfile;
         logfp->prevp = &logfile_list;
         logfile_tail = &logfp->next;
         log_header(logfd);
     }
 
     atexit(NS_TraceMallocShutdown);
 
-    /*
-     * We only allow one thread until NS_TraceMallocStartup is called.
-     * When it is, we have to initialize tls_index before allocating tmlock
-     * since get_tm_index uses NULL-tmlock to detect tls_index being
-     * uninitialized.
-     */
-    main_thread.suppress_tracing++;
-    TM_CREATE_TLS_INDEX(tls_index);
-    TM_SET_TLS_DATA(tls_index, &main_thread);
     tmlock = PR_NewLock();
-    main_thread.suppress_tracing--;
+    (void) tm_get_thread(); /* ensure index initialization while it's easy */
 
     if (tracing_enabled)
         StartupHooker();
 
 #ifdef linux
     SetupDumpAllocationsHook();
 #endif
 }
@@ -1990,20 +1989,22 @@ FreeCallback(void * ptr, PRUint32 start,
 {
     PLHashEntry **hep, *he;
     callsite *site;
     allocation *alloc;
 
     if (!tracing_enabled || t->suppress_tracing != 0)
         return;
 
-    // XXX Perhaps we should call backtrace() so we can check for
-    // immediate_abort. However, the only current contexts where
-    // immediate_abort will be true do not call free(), so for now,
-    // let's avoid the cost of backtrace().
+    /*
+     * XXX Perhaps we should call backtrace() so we can check for
+     * immediate_abort. However, the only current contexts where
+     * immediate_abort will be true do not call free(), so for now,
+     * let's avoid the cost of backtrace().
+     */
     TM_SUPPRESS_TRACING_AND_ENTER_LOCK(t);
     tmstats.free_calls++;
     if (!ptr) {
         tmstats.null_free_calls++;
     } else {
         if (get_allocations()) {
             hep = PL_HashTableRawLookup(allocations, hash_pointer(ptr), ptr);
             he = *hep;
@@ -2029,16 +2030,18 @@ FreeCallback(void * ptr, PRUint32 start,
 
 PR_IMPLEMENT(nsTMStackTraceID)
 NS_TraceMallocGetStackTrace(void)
 {
     callsite *site;
     int dummy;
     tm_thread *t = tm_get_thread();
 
+    PR_ASSERT(t->suppress_tracing == 0);
+
     site = backtrace(t, 2, &dummy);
     return (nsTMStackTraceID) site;
 }
 
 PR_IMPLEMENT(void)
 NS_TraceMallocPrintStackTrace(FILE *ofp, nsTMStackTraceID id)
 {
     print_stack(ofp, (callsite *)id);
