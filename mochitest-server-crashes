Don't rely on NS_TraceMallocStartupArgs to initialize TLS index.  (Bug 442192)

diff --git a/tools/trace-malloc/lib/nsTraceMalloc.c b/tools/trace-malloc/lib/nsTraceMalloc.c
--- a/tools/trace-malloc/lib/nsTraceMalloc.c
+++ b/tools/trace-malloc/lib/nsTraceMalloc.c
@@ -231,17 +231,18 @@ static uint32 tracing_enabled = 0;
 #define TM_CREATE_TLS_INDEX(i_)         pthread_key_create(&(i_), NULL)
 #define TM_DESTROY_TLS_INDEX(i_)        pthread_key_delete((i_))
 #define TM_GET_TLS_DATA(i_)             pthread_getspecific((i_))
 #define TM_SET_TLS_DATA(i_, v_)         pthread_setspecific((i_), (v_))
 
 #endif
 
 static TM_TLS_INDEX_TYPE tls_index;
-static tm_thread main_thread; /* 0-initialization is correct */
+static volatile PRBool tls_index_initialized = PR_FALSE;
+static PRInt32 tls_index_initializing = 0;
 
 /* FIXME (maybe): This is currently unused; we leak the thread-local data. */
 #if 0
 static void
 free_tm_thread(void *priv)
 {
     tm_thread *t = (tm_thread*) priv;
 
@@ -258,18 +259,24 @@ free_tm_thread(void *priv)
 #endif
 
 tm_thread *
 tm_get_thread(void)
 {
     tm_thread *t;
     tm_thread stack_tm_thread;
 
-    if (!tmlock) {
-        return &main_thread;
+    if (!tls_index_initialized) {
+        if (PR_AtomicIncrement(&tls_index_initializing) == 1) {
+            TM_CREATE_TLS_INDEX(tls_index);
+            tls_index_initialized = PR_TRUE;
+        } else {
+            while (!tls_index_initialized)
+                ;
+        }
     }
 
     t = TM_GET_TLS_DATA(tls_index);
 
     if (!t) {
         /*
          * First, store a tm_thread on the stack to suppress for the
          * malloc below
@@ -1340,27 +1347,18 @@ NS_TraceMallocStartup(int logfd)
         logfile_list = &default_logfile;
         logfp->prevp = &logfile_list;
         logfile_tail = &logfp->next;
         log_header(logfd);
     }
 
     atexit(NS_TraceMallocShutdown);
 
-    /*
-     * We only allow one thread until NS_TraceMallocStartup is called.
-     * When it is, we have to initialize tls_index before allocating tmlock
-     * since get_tm_index uses NULL-tmlock to detect tls_index being
-     * uninitialized.
-     */
-    main_thread.suppress_tracing++;
-    TM_CREATE_TLS_INDEX(tls_index);
-    TM_SET_TLS_DATA(tls_index, &main_thread);
     tmlock = PR_NewLock();
-    main_thread.suppress_tracing--;
+    (void) tm_get_thread(); /* ensure index initialization while it's easy */
 
     if (tracing_enabled)
         StartupHooker();
 
 #ifdef linux
     SetupDumpAllocationsHook();
 #endif
 }
@@ -2029,16 +2027,18 @@ FreeCallback(void * ptr, PRUint32 start,
 
 PR_IMPLEMENT(nsTMStackTraceID)
 NS_TraceMallocGetStackTrace(void)
 {
     callsite *site;
     int dummy;
     tm_thread *t = tm_get_thread();
 
+    PR_ASSERT(t->suppress_tracing == 0);
+
     site = backtrace(t, 2, &dummy);
     return (nsTMStackTraceID) site;
 }
 
 PR_IMPLEMENT(void)
 NS_TraceMallocPrintStackTrace(FILE *ofp, nsTMStackTraceID id)
 {
     print_stack(ofp, (callsite *)id);
