From: L. David Baron <dbaron@dbaron.org>

Bug 815408:  Ignore CSS transitions and animations in print and print preview.

Note that this patch has a little bit of a belt-and-braces aspect to it.
In each file, either one of the changes should be sufficient, but one of
them prevents us from doing unneeded work and the other one ensures that
we never apply style resulting from transitions and animations even if
somehow we do that work.

Also note that the tests don't actually test anything usefully, since
the reftest harness doesn't currently make the pres context non-dynamic.
(Thus they're marked as failing.)  I'm not sure what I should do about
that, though I'm considering just deleting the tests entirely.

diff --git a/layout/reftests/css-animations/print-no-animations-notref.html b/layout/reftests/css-animations/print-no-animations-notref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/css-animations/print-no-animations-notref.html
@@ -0,0 +1,11 @@
+<!DOCTYPE HTML>
+<html class="reftest-print">
+<title>Static CSS animation</title>
+<style>
+
+p {
+  color: blue;
+}
+
+</style>
+<p>blue with animation support; olive without</p>
diff --git a/layout/reftests/css-animations/print-no-animations-ref.html b/layout/reftests/css-animations/print-no-animations-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/css-animations/print-no-animations-ref.html
@@ -0,0 +1,11 @@
+<!DOCTYPE HTML>
+<html class="reftest-print">
+<title>Static CSS animation</title>
+<style>
+
+p {
+  color: olive;
+}
+
+</style>
+<p>blue with animation support; olive without</p>
diff --git a/layout/reftests/css-animations/print-no-animations.html b/layout/reftests/css-animations/print-no-animations.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/css-animations/print-no-animations.html
@@ -0,0 +1,16 @@
+<!DOCTYPE HTML>
+<html class="reftest-print">
+<title>Static CSS animation</title>
+<style>
+
+@keyframes a {
+  from, to { color: blue }
+}
+
+p {
+  color: olive;
+  animation: a 1s infinite;
+}
+
+</style>
+<p>blue with animation support; olive without</p>
diff --git a/layout/reftests/css-animations/reftest.list b/layout/reftests/css-animations/reftest.list
new file mode 100644
--- /dev/null
+++ b/layout/reftests/css-animations/reftest.list
@@ -0,0 +1,4 @@
+== screen-animations.html screen-animations-ref.html
+!= screen-animations.html screen-animations-notref.html
+fails == print-no-animations.html print-no-animations-ref.html # reftest harness doesn't actually make pres context non-dynamic for reftest-print tests
+fails != print-no-animations.html print-no-animations-notref.html # reftest harness doesn't actually make pres context non-dynamic for reftest-print tests
diff --git a/layout/reftests/css-animations/screen-animations-notref.html b/layout/reftests/css-animations/screen-animations-notref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/css-animations/screen-animations-notref.html
@@ -0,0 +1,11 @@
+<!DOCTYPE HTML>
+<html>
+<title>Static CSS animation</title>
+<style>
+
+p {
+  color: olive;
+}
+
+</style>
+<p>blue with animation support; olive without</p>
diff --git a/layout/reftests/css-animations/screen-animations-ref.html b/layout/reftests/css-animations/screen-animations-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/css-animations/screen-animations-ref.html
@@ -0,0 +1,11 @@
+<!DOCTYPE HTML>
+<html>
+<title>Static CSS animation</title>
+<style>
+
+p {
+  color: blue;
+}
+
+</style>
+<p>blue with animation support; olive without</p>
diff --git a/layout/reftests/css-animations/screen-animations.html b/layout/reftests/css-animations/screen-animations.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/css-animations/screen-animations.html
@@ -0,0 +1,16 @@
+<!DOCTYPE HTML>
+<html>
+<title>Static CSS animation</title>
+<style>
+
+@keyframes a {
+  from, to { color: blue }
+}
+
+p {
+  color: olive;
+  animation: a 1s infinite;
+}
+
+</style>
+<p>blue with animation support; olive without</p>
diff --git a/layout/reftests/reftest.list b/layout/reftests/reftest.list
--- a/layout/reftests/reftest.list
+++ b/layout/reftests/reftest.list
@@ -43,16 +43,19 @@ skip-if(B2G) include box-properties/reft
 skip-if(Android||B2G) include box-shadow/reftest.list
 
 # bugs/
 include bugs/reftest.list
 
 # canvas 2D
 include canvas/reftest.list
 
+# css animations
+include css-animations/reftest.list
+
 # css calc() tests
 include css-calc/reftest.list
 
 # css character encoding tests
 skip-if(B2G) include css-charset/reftest.list
 
 # css default pseudo class tests
 skip-if(B2G) include css-default/reftest.list
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -534,16 +534,21 @@ nsAnimationManager::SizeOfIncludingThis(
   return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
 }
 
 nsIStyleRule*
 nsAnimationManager::CheckAnimationRule(nsStyleContext* aStyleContext,
                                        mozilla::dom::Element* aElement)
 {
   if (!mPresContext->IsProcessingAnimationStyleChange()) {
+    if (!mPresContext->IsDynamic()) {
+      // For print or print preview, ignore animations.
+      return nullptr;
+    }
+
     // Everything that causes our animation data to change triggers a
     // style change, which in turn triggers a non-animation restyle.
     // Likewise, when we initially construct frames, we're not in a
     // style change, but also not in an animation restyle.
 
     const nsStyleDisplay *disp = aStyleContext->StyleDisplay();
     ElementAnimations *ea =
       GetElementAnimations(aElement, aStyleContext->GetPseudoType(), false);
@@ -945,16 +950,21 @@ nsAnimationManager::GetAnimationRule(moz
                                      nsCSSPseudoElements::Type aPseudoType)
 {
   NS_ABORT_IF_FALSE(
     aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ||
     aPseudoType == nsCSSPseudoElements::ePseudo_before ||
     aPseudoType == nsCSSPseudoElements::ePseudo_after,
     "forbidden pseudo type");
 
+  if (!mPresContext->IsDynamic()) {
+    // For print or print preview, ignore animations.
+    return nullptr;
+  }
+
   ElementAnimations *ea =
     GetElementAnimations(aElement, aPseudoType, false);
   if (!ea) {
     return nullptr;
   }
 
   if (mPresContext->IsProcessingRestyles() &&
       !mPresContext->IsProcessingAnimationStyleChange()) {
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -446,16 +446,21 @@ nsTransitionManager::StyleContextChanged
   // If we were called from ReparentStyleContext, this assertion would
   // actually fire.  If we need to be called from there, we can probably
   // just remove it; the condition probably isn't critical, although
   // it's worth thinking about some more.
   NS_PRECONDITION(aOldStyleContext->HasPseudoElementData() ==
                       aNewStyleContext->HasPseudoElementData(),
                   "pseudo type mismatch");
 
+  if (!mPresContext->IsDynamic()) {
+    // For print or print preview, ignore transitions.
+    return nullptr;
+  }
+
   // NOTE: Things in this function (and ConsiderStartingTransition)
   // should never call PeekStyleData because we don't preserve gotten
   // structs across reframes.
 
   // Return sooner (before the startedAny check below) for the most
   // common case: no transitions specified or running.
   const nsStyleDisplay *disp = aNewStyleContext->StyleDisplay();
   nsCSSPseudoElements::Type pseudoType = aNewStyleContext->GetPseudoType();
@@ -888,16 +893,21 @@ nsTransitionManager::WalkTransitionRule(
                                         nsCSSPseudoElements::Type aPseudoType)
 {
   ElementTransitions *et =
     GetElementTransitions(aData->mElement, aPseudoType, false);
   if (!et) {
     return;
   }
 
+  if (!mPresContext->IsDynamic()) {
+    // For print or print preview, ignore animations.
+    return;
+  }
+
   if (aData->mPresContext->IsProcessingRestyles() &&
       !aData->mPresContext->IsProcessingAnimationStyleChange()) {
     // If we're processing a normal style change rather than one from
     // animation, don't add the transition rule.  This allows us to
     // compute the new style value rather than having the transition
     // override it, so that we can start transitioning differently.
 
     // We need to immediately restyle with animation
