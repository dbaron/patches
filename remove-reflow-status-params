From: L. David Baron <dbaron@dbaron.org>

Remove aReflowStatus parameters made unnecessary by previous patch.  (Bug 563584)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -5670,18 +5670,17 @@ nsBlockFrame::ReflowFloatContinuations(n
        f && (f->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION);
        f = f->GetNextSibling()) {
     if (NS_SUBTREE_DIRTY(f) || aState.mReflowState.ShouldReflowAllKids()) {
       // Cache old bounds
       nsRect oldRect = f->GetRect();
       nsRect oldOverflow = f->GetOverflowRect();
 
       // Reflow
-      nsReflowStatus fStatus = NS_FRAME_COMPLETE;
-      aState.AddFloat(nsnull, f, aState.mContentArea.width, fStatus);
+      aState.AddFloat(nsnull, f, aState.mContentArea.width);
 
       // Invalidate if there was a position or size change
       nsRect rect = f->GetRect();
       if (rect != oldRect) {
         nsRect dirtyRect = oldOverflow;
         dirtyRect.MoveBy(oldRect.x, oldRect.y);
         Invalidate(dirtyRect);
 
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -541,18 +541,17 @@ nsBlockReflowState::RecoverStateFrom(nsL
 
 // XXXldb This behavior doesn't quite fit with CSS1 and CSS2 --
 // technically we're supposed let the current line flow around the
 // float as well unless it won't fit next to what we already have.
 // But nobody else implements it that way...
 PRBool
 nsBlockReflowState::AddFloat(nsLineLayout*       aLineLayout,
                              nsIFrame*           aFloat,
-                             nscoord             aAvailableWidth,
-                             nsReflowStatus&     aReflowStatus)
+                             nscoord             aAvailableWidth)
 {
   NS_PRECONDITION(!aLineLayout || mBlock->end_lines() != mCurrentLine, "null ptr");
   NS_PRECONDITION(aFloat->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
                   "aFloat must be an out-of-flow frame");
 
   NS_ABORT_IF_FALSE(aFloat->GetParent(), "float must have parent");
   NS_ABORT_IF_FALSE(aFloat->GetParent()->IsFrameOfType(nsIFrame::eBlockFrame),
                     "float's parent must be block");
@@ -571,19 +570,16 @@ nsBlockReflowState::AddFloat(nsLineLayou
     floatParent->StealFrame(mPresContext, aFloat);
 
     // Appending is fine, since if a float was pushed to the next
     // page/column, all later floats were also pushed.
     // FIXME: check that we do this
     mBlock->mFloats.AppendFrame(mBlock, aFloat);
   }
 
-  // FIXME: Remove aReflowStatus parameter!
-  aReflowStatus = NS_FRAME_COMPLETE;
-
   // Because we are in the middle of reflowing a placeholder frame
   // within a line (and possibly nested in an inline frame or two
   // that's a child of our block) we need to restore the space
   // manager's translation to the space that the block resides in
   // before placing the float.
   nscoord ox, oy;
   mFloatManager->GetTranslation(ox, oy);
   nscoord dx = ox - mFloatManagerX;
@@ -599,17 +595,17 @@ nsBlockReflowState::AddFloat(nsLineLayou
   // float ordering.
   nsRect floatAvailableSpace = GetFloatAvailableSpace().mRect;
   if (!aLineLayout ||
       (mBelowCurrentLineFloats.IsEmpty() &&
        (aLineLayout->LineIsEmpty() ||
         mBlock->ComputeFloatWidth(*this, floatAvailableSpace, aFloat)
         <= aAvailableWidth))) {
     // And then place it
-    placed = FlowAndPlaceFloat(aFloat, aReflowStatus);
+    placed = FlowAndPlaceFloat(aFloat);
     if (placed) {
       // Pass on updated available space to the current inline reflow engine
       nsFlowAreaRect floatAvailSpace = GetFloatAvailableSpace(mY);
       nsRect availSpace(nsPoint(floatAvailSpace.mRect.x + BorderPadding().left,
                                 mY),
                         floatAvailSpace.mRect.Size());
       if (aLineLayout) {
         aLineLayout->UpdateBand(availSpace, aFloat);
@@ -661,21 +657,18 @@ FloatMarginWidth(const nsHTMLReflowState
     nsSize(aFloatOffsetState.mComputedPadding.LeftRight(),
            aFloatOffsetState.mComputedPadding.TopBottom()),
     PR_TRUE).width +
   aFloatOffsetState.mComputedMargin.LeftRight() +
   aFloatOffsetState.mComputedBorderPadding.LeftRight();
 }
 
 PRBool
-nsBlockReflowState::FlowAndPlaceFloat(nsIFrame*       aFloat,
-                                      // FIXME: remove aReflowStatus
-                                      nsReflowStatus& aReflowStatus)
+nsBlockReflowState::FlowAndPlaceFloat(nsIFrame* aFloat)
 {
-  aReflowStatus = NS_FRAME_COMPLETE;
   // Save away the Y coordinate before placing the float. We will
   // restore mY at the end after placing the float. This is
   // necessary because any adjustments to mY during the float
   // placement are for the float only, not for any non-floating
   // content.
   AutoRestore<nscoord> restoreY(mY);
   // FIXME: Should give AutoRestore a getter for the value to avoid this.
   const nscoord saveY = mY;
@@ -961,18 +954,17 @@ nsBlockReflowState::PlaceBelowCurrentLin
     if (nsBlockFrame::gNoisyReflow) {
       nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
       printf("placing bcl float: ");
       nsFrame::ListTag(stdout, fc->mFloat);
       printf("\n");
     }
 #endif
     // Place the float
-    nsReflowStatus reflowStatus;
-    PRBool placed = FlowAndPlaceFloat(fc->mFloat, reflowStatus);
+    PRBool placed = FlowAndPlaceFloat(fc->mFloat);
     nsFloatCache *next = fc->Next();
     if (!placed) {
       aList.Remove(fc);
     }
     fc = next;
   }
 }
 
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -101,23 +101,21 @@ public:
    * The following functions all return PR_TRUE if they were able to
    * place the float, PR_FALSE if the float did not fit in available
    * space.
    * aLineLayout is null when we are reflowing float continuations (because
    * they are not associated with a line box).
    */
   PRBool AddFloat(nsLineLayout*       aLineLayout,
                   nsIFrame*           aFloat,
-                  nscoord             aAvailableWidth,
-                  nsReflowStatus&     aReflowStatus);
+                  nscoord             aAvailableWidth);
 private:
   PRBool CanPlaceFloat(nscoord aFloatWidth,
                        const nsFlowAreaRect& aFloatAvailableSpace);
-  PRBool FlowAndPlaceFloat(nsIFrame*       aFloat,
-                           nsReflowStatus& aReflowStatus);
+  PRBool FlowAndPlaceFloat(nsIFrame* aFloat);
   void PushFloatPastBreak(nsIFrame* aFloat);
 public:
   void PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aFloats);
 
   // Returns the first coordinate >= aY that clears the
   // floats indicated by aBreakType and has enough width between floats
   // (or no floats remaining) to accomodate aReplacedBlock.
   nscoord ClearFloats(nscoord aY, PRUint8 aBreakType,
diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -884,17 +884,17 @@ nsLineLayout::ReflowFrame(nsIFrame* aFra
           // so we can't know whether the float plus that content will fit
           // on the line. So for now, don't place floats after inline
           // content where there's no break opportunity. This is incorrect
           // but hopefully rare. Fixing it will require significant
           // restructuring of line layout.
           // We might as well allow zero-width floats to be placed, though.
           availableWidth = 0;
         }
-        placedFloat = AddFloat(outOfFlowFrame, availableWidth, aReflowStatus);
+        placedFloat = AddFloat(outOfFlowFrame, availableWidth);
         NS_ASSERTION(!(outOfFlowFrame->GetType() == nsGkAtoms::letterFrame &&
                        GetFirstLetterStyleOK()),
                     "FirstLetterStyle set on line with floating first letter");
       }
     }
     else if (nsGkAtoms::textFrame == frameType) {
       // Note non-empty text-frames for inline frame compatibility hackery
       pfd->SetFlag(PFD_ISTEXTFRAME, PR_TRUE);
diff --git a/layout/generic/nsLineLayout.h b/layout/generic/nsLineLayout.h
--- a/layout/generic/nsLineLayout.h
+++ b/layout/generic/nsLineLayout.h
@@ -216,21 +216,19 @@ public:
   void SetLineEndsInBR(PRBool aOn) 
   { 
     SetFlag(LL_LINEENDSINBR, aOn); 
   }
 
   //----------------------------------------
   // Inform the line-layout about the presence of a floating frame
   // XXX get rid of this: use get-frame-type?
-  PRBool AddFloat(nsIFrame*       aFloat,
-                  nscoord         aAvailableWidth,
-                  nsReflowStatus& aReflowStatus)
+  PRBool AddFloat(nsIFrame* aFloat, nscoord aAvailableWidth)
   {
-    return mBlockRS->AddFloat(this, aFloat, aAvailableWidth, aReflowStatus);
+    return mBlockRS->AddFloat(this, aFloat, aAvailableWidth);
   }
 
   void SetTrimmableWidth(nscoord aTrimmableWidth) {
     mTrimmableWidth = aTrimmableWidth;
   }
 
   //----------------------------------------
 
