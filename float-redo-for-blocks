Fix bug 25888 for blocks:  redo block reflow when the height of a block that does not intersect floats pushes it into the way of other floats.  (Bug 25888)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1669,16 +1669,17 @@ nsBlockFrame::PropagateFloatDamage(nsBlo
       // decide what it needs to reflow.
       aLine->MarkDirty();
     } else {
       PRBool wasImpactedByFloat = aLine->IsImpactedByFloat();
       nsRect floatAvailableSpace;
       PRBool isImpactedByFloat =
         aState.GetFloatAvailableSpaceForHeight(aLine->mBounds.y + aDeltaY,
                                                aLine->mBounds.height,
+                                               nsnull,
                                                floatAvailableSpace);
 
 #ifdef REALLY_NOISY_REFLOW
     printf("nsBlockFrame::PropagateFloatDamage %p was = %d, is=%d\n", 
        this, wasImpactedByFloat, isImpactedByFloat);
 #endif
 
       // Mark the line dirty if it was or is affected by a float
@@ -2958,58 +2959,123 @@ nsBlockFrame::ReflowBlockFrame(nsBlockRe
         
         // Note that aState.mY should stay where it is: at the top
         // border-edge of the frame
       } else {
         // Advance aState.mY to the top border-edge of the frame.
         aState.mY += topMargin;
       }
     }
-    
+
+    aLine->SetLineIsImpactedByFloat(PR_FALSE);
+
     // Here aState.mY is the top border-edge of the block.
     // Compute the available space for the block
     nsRect floatAvailableSpace;
     PRBool isImpacted = aState.GetFloatAvailableSpace(floatAvailableSpace);
-#ifdef REALLY_NOISY_REFLOW
-    printf("setting line %p isImpacted to %s\n",
-           aLine.get(), isImpacted?"true":"false");
-#endif
-    aLine->SetLineIsImpactedByFloat(isImpacted);
     nsRect availSpace;
     aState.ComputeBlockAvailSpace(frame, display,
                                   isImpacted, floatAvailableSpace,
                                   replacedBlock != nsnull, availSpace);
-    
+
     // Now put the Y coordinate back to the top of the top-margin +
-    // clearance, and flow the block.
+    // clearance.
     aState.mY -= topMargin;
     availSpace.y -= topMargin;
     if (NS_UNCONSTRAINEDSIZE != availSpace.height) {
       availSpace.height += topMargin;
     }
     
-    // Reflow the block into the available space
     // construct the html reflow state for the block. ReflowBlock 
     // will initialize it
     nsHTMLReflowState blockHtmlRS(aState.mPresContext, aState.mReflowState, frame, 
                                   nsSize(availSpace.width, availSpace.height));
     blockHtmlRS.mFlags.mHasClearance = aLine->HasClearance();
     
     nsFloatManager::SavedState floatManagerState;
-    if (mayNeedRetry) {
-      blockHtmlRS.mDiscoveredClearance = &clearanceFrame;
-      aState.mFloatManager->PushState(&floatManagerState);
-    } else if (!applyTopMargin) {
-      blockHtmlRS.mDiscoveredClearance = aState.mReflowState.mDiscoveredClearance;
-    }
-    
-    nsReflowStatus frameReflowStatus = NS_FRAME_COMPLETE;
-    rv = brc.ReflowBlock(availSpace, applyTopMargin, aState.mPrevBottomMargin,
-                         clearance, aState.IsAdjacentWithTop(),
-                         aLine.get(), blockHtmlRS, frameReflowStatus, aState);
+    nsReflowStatus frameReflowStatus;
+    do {
+      if (isImpacted) {
+        // Set if isImpacted is true for any iteration of the loop.
+        aLine->SetLineIsImpactedByFloat(PR_TRUE);
+      }
+      
+      // Reflow the block into the available space
+      if (mayNeedRetry || replacedBlock) {
+        aState.mFloatManager->PushState(&floatManagerState);
+      }
+
+      if (mayNeedRetry) {
+        blockHtmlRS.mDiscoveredClearance = &clearanceFrame;
+      } else if (!applyTopMargin) {
+        blockHtmlRS.mDiscoveredClearance =
+          aState.mReflowState.mDiscoveredClearance;
+      }
+
+      frameReflowStatus = NS_FRAME_COMPLETE;
+      rv = brc.ReflowBlock(availSpace, applyTopMargin, aState.mPrevBottomMargin,
+                           clearance, aState.IsAdjacentWithTop(),
+                           aLine.get(), blockHtmlRS, frameReflowStatus, aState);
+
+      // Now the block has a height.  Using that height, get the
+      // available space again and call ComputeBlockAvailSpace again.
+      // If ComputeBlockAvailSpace gives a different result, we need to
+      // reflow again.
+      if (!replacedBlock) {
+        break;
+      }
+
+      nsRect oldFloatAvailableSpace(floatAvailableSpace);
+      isImpacted = aState.GetFloatAvailableSpaceForHeight(
+                            aState.mY + topMargin, brc.GetMetrics().height,
+                            &floatManagerState,
+                            floatAvailableSpace);
+      NS_ASSERTION(floatAvailableSpace.y == oldFloatAvailableSpace.y, "yikes");
+      // Restore the height to the position of the next band.
+      floatAvailableSpace.height = oldFloatAvailableSpace.height;
+      if (!AvailableSpaceShrunk(oldFloatAvailableSpace, floatAvailableSpace)) {
+        break;
+      }
+
+      PRBool advanced = PR_FALSE;
+      if (!aState.ReplacedBlockFitsInAvailSpace(replacedBlock,
+                                                floatAvailableSpace,
+                                                isImpacted)) {
+        // Advance to the next band.
+        // XXX SHOULD THIS BE TREATED AS CLEARANCE?
+        nscoord newY = aState.mY;
+        if (aState.AdvanceToNextBand(floatAvailableSpace, &newY))
+          advanced = PR_TRUE;
+        // ClearFloats might be able to advance us further once we're there.
+        aState.mY =
+          aState.ClearFloats(newY, NS_STYLE_CLEAR_NONE, replacedBlock);
+        // Start over with a new available space rect at the new height.
+        isImpacted =
+          aState.GetFloatAvailableSpaceWithState(aState.mY, PR_FALSE,
+                                                 &floatManagerState,
+                                                 floatAvailableSpace);
+      }
+
+      nsRect oldAvailSpace(availSpace);
+      // XXX NEED TO ADJUST mY AROUND OR ALLOW PASSING OF topMargin
+      aState.ComputeBlockAvailSpace(frame, display,
+                                    isImpacted, floatAvailableSpace,
+                                    replacedBlock != nsnull, availSpace);
+      if (!advanced && availSpace.IsExactEqual(oldAvailSpace)) {
+        break;
+      }
+
+      // We need another reflow.
+      aState.mFloatManager->PopState(&floatManagerState);
+
+      blockHtmlRS.~nsHTMLReflowState();
+      new (&blockHtmlRS) nsHTMLReflowState(aState.mPresContext,
+                           aState.mReflowState, frame, 
+                           nsSize(availSpace.width, availSpace.height));
+    } while (PR_TRUE);
 
     // If this was a second-pass reflow and the block's vertical position
     // changed, invalidates from the first pass might have happened in the
     // wrong places.  Invalidate the entire overflow rect at the new position.
     if (!mayNeedRetry && clearanceFrame &&
         frame->GetRect().y != passOriginalY) {
       Invalidate(frame->GetOverflowRect() + frame->GetPosition());
     }
@@ -3969,18 +4035,22 @@ nsBlockFrame::PlaceLine(nsBlockReflowSta
     nsHTMLReflowMetrics metrics;
     ReflowBullet(aState, metrics, aState.mY);
     aLineLayout.AddBulletFrame(mBullet, metrics);
     addedBullet = PR_TRUE;
   }
   aLineLayout.VerticalAlignLine();
 
   nsRect oldFloatAvailableSpace(aFloatAvailableSpace);
+  // Note that we really do want to pass a null state here; floats
+  // inside the line can reduce the width available to it (even if they
+  // don't hit the top of it).
   aState.GetFloatAvailableSpaceForHeight(aLine->mBounds.y,
                                          aLine->mBounds.height,
+                                         nsnull,
                                          aFloatAvailableSpace);
   NS_ASSERTION(aFloatAvailableSpace.y == oldFloatAvailableSpace.y, "yikes");
   // Restore the height to the position of the next band.
   aFloatAvailableSpace.height = oldFloatAvailableSpace.height;
   // If the available space between the floats is smaller now that we
   // know the height, return false (and cause another pass with
   // LINE_REFLOW_REDO_MORE_FLOATS).
   if (AvailableSpaceShrunk(oldFloatAvailableSpace, aFloatAvailableSpace)) {
@@ -6869,17 +6939,17 @@ nsBlockFrame::BlockCanIntersectFloats(ns
 }
 
 // Note that this width can vary based on the vertical position.
 // However, the cases where it varies are the cases where the width fits
 // in the available space given, which means that variation shouldn't
 // matter.
 /* static */
 nsBlockFrame::ReplacedElementWidthToClear
-nsBlockFrame::WidthToClearPastFloats(nsBlockReflowState& aState,
+nsBlockFrame::WidthToClearPastFloats(const nsBlockReflowState& aState,
                                      const nsRect& aFloatAvailableSpace,
                                      nsIFrame* aFrame)
 {
   nscoord leftOffset, rightOffset;
   nsCSSOffsetState offsetState(aFrame, aState.mReflowState.rendContext,
                                aState.mContentArea.width);
 
   ReplacedElementWidthToClear result;
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -303,17 +303,17 @@ public:
    * care about (which need not be its current mY)
    */
   struct ReplacedElementWidthToClear {
     nscoord marginLeft, borderBoxWidth, marginRight;
     nscoord MarginBoxWidth() const
       { return marginLeft + borderBoxWidth + marginRight; }
   };
   static ReplacedElementWidthToClear
-    WidthToClearPastFloats(nsBlockReflowState& aState,
+    WidthToClearPastFloats(const nsBlockReflowState& aState,
                            const nsRect& aFloatAvailableSpace,
                            nsIFrame* aFrame);
 
   /**
    * Walks up the frame tree, starting with aCandidate, and returns the first
    * block frame that it encounters.
    */
   static nsBlockFrame* GetNearestAncestorBlock(nsIFrame* aCandidate);
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -189,17 +189,17 @@ nsBlockReflowState::FreeLineBox(nsLineBo
 
 void
 nsBlockReflowState::ComputeReplacedBlockOffsetsForFloats(nsIFrame* aFrame,
                                                          const nsRect& aFloatAvailableSpace,
                                                          nscoord& aLeftResult,
                                                          nscoord& aRightResult,
                                                          nsBlockFrame::
                                                       ReplacedElementWidthToClear
-                                                                 *aReplacedWidth)
+                                                                 *aReplacedWidth) const
 {
   // The frame is clueless about the float manager and therefore we
   // only give it free space. An example is a table frame - the
   // tables do not flow around floats.
   // However, we can let its margins intersect floats.
   NS_ASSERTION(aFloatAvailableSpace.x >= 0, "bad avail space rect x");
   NS_ASSERTION(aFloatAvailableSpace.width == 0 ||
                aFloatAvailableSpace.XMost() <= mContentArea.width,
@@ -364,31 +364,33 @@ nsBlockReflowState::GetFloatAvailableSpa
            aResult.x, aResult.y, aResult.width, aResult.height, hasFloats);
   }
 #endif
   return hasFloats;
 }
 
 PRBool
 nsBlockReflowState::GetFloatAvailableSpaceForHeight(nscoord aY, nscoord aHeight,
+                                                    nsFloatManager::SavedState
+                                                      *aState,
                                                     nsRect& aResult) const
 {
 #ifdef DEBUG
   // Verify that the caller setup the coordinate system properly
   nscoord wx, wy;
   mFloatManager->GetTranslation(wx, wy);
   NS_ASSERTION((wx == mFloatManagerX) && (wy == mFloatManagerY),
                "bad coord system");
 #endif
 
   PRBool hasFloats;
   aResult = 
     mFloatManager->GetFlowArea(aY - BorderPadding().top, 
                                nsFloatManager::WIDTH_WITHIN_HEIGHT,
-                               aHeight, mContentArea.width, nsnull,
+                               aHeight, mContentArea.width, aState,
                                &hasFloats);
   // Keep the width >= 0 for compatibility with nsSpaceManager.
   if (aResult.width < 0)
     aResult.width = 0;
 
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
@@ -1137,40 +1139,25 @@ nsBlockReflowState::ClearFloats(nscoord 
     newY = bp.top + mFloatManager->ClearFloats(newY - bp.top, aBreakType);
   }
 
   if (aReplacedBlock) {
     for (;;) {
       nsRect floatAvailableSpace;
       PRBool bandHasFloats =
         GetFloatAvailableSpace(newY, PR_FALSE, floatAvailableSpace);
-      nsBlockFrame::ReplacedElementWidthToClear replacedWidth =
-        nsBlockFrame::WidthToClearPastFloats(*this, floatAvailableSpace,
-                                             aReplacedBlock);
-      if (!bandHasFloats ||
-          PR_MAX(floatAvailableSpace.x, replacedWidth.marginLeft) +
-            replacedWidth.borderBoxWidth +
-            PR_MAX(mContentArea.width -
-                     PR_MIN(mContentArea.width, floatAvailableSpace.XMost()),
-                   replacedWidth.marginRight) <=
-          mContentArea.width) {
+      if (ReplacedBlockFitsInAvailSpace(aReplacedBlock, floatAvailableSpace,
+                                        bandHasFloats)) {
         break;
       }
       // See the analogous code for inlines in nsBlockFrame::DoReflowInlineFrames
-      if (floatAvailableSpace.height > 0) {
-        // See if there's room in the next band.
-        newY += floatAvailableSpace.height;
-      } else {
-        if (mReflowState.availableHeight != NS_UNCONSTRAINEDSIZE) {
-          // Stop trying to clear here; we'll just get pushed to the
-          // next column or page and try again there.
-          break;
-        }
-        NS_NOTREACHED("avail space rect with zero height!");
-        newY += 1;
+      if (!AdvanceToNextBand(floatAvailableSpace, &newY)) {
+        // Stop trying to clear here; we'll just get pushed to the
+        // next column or page and try again there.
+        break;
       }
     }
   }
 
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
     printf("clear floats: out: y=%d(%d)\n", newY, newY - bp.top);
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -97,16 +97,17 @@ public:
                                 nsRect& aResult) const
     { return GetFloatAvailableSpaceWithState(aY, aRelaxHeightConstraint,
                                              nsnull, aResult); }
   PRBool GetFloatAvailableSpaceWithState(nscoord aY,
                                          PRBool aRelaxHeightConstraint,
                                          nsFloatManager::SavedState *aState,
                                          nsRect& aResult) const;
   PRBool GetFloatAvailableSpaceForHeight(nscoord aY, nscoord aHeight,
+                                         nsFloatManager::SavedState *aState,
                                          nsRect& aResult) const;
 
   /*
    * The following functions all return PR_TRUE if they were able to
    * place the float, PR_FALSE if the float did not fit in available
    * space.
    */
   PRBool InitFloat(nsLineLayout&       aLineLayout,
@@ -128,16 +129,48 @@ public:
   PRBool PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aFloats, PRBool aForceFit);
 
   // Returns the first coordinate >= aY that clears the
   // floats indicated by aBreakType and has enough width between floats
   // (or no floats remaining) to accomodate aReplacedBlock.
   nscoord ClearFloats(nscoord aY, PRUint8 aBreakType,
                       nsIFrame *aReplacedBlock = nsnull);
 
+  PRBool AdvanceToNextBand(const nsRect& aFloatAvailableSpace,
+                           nscoord *aY) const {
+    if (aFloatAvailableSpace.height > 0) {
+      // See if there's room in the next band.
+      *aY += aFloatAvailableSpace.height;
+    } else {
+      if (mReflowState.availableHeight != NS_UNCONSTRAINEDSIZE) {
+        // Stop trying to clear here; we'll just get pushed to the
+        // next column or page and try again there.
+        return PR_FALSE;
+      }
+      NS_NOTREACHED("avail space rect with zero height!");
+      *aY += 1;
+    }
+    return PR_TRUE;
+  }
+
+  PRBool ReplacedBlockFitsInAvailSpace(nsIFrame* aReplacedBlock,
+                                       const nsRect& aFloatAvailableSpace,
+                                       PRBool aBandHasFloats) const {
+    nsBlockFrame::ReplacedElementWidthToClear replacedWidth =
+      nsBlockFrame::WidthToClearPastFloats(*this, aFloatAvailableSpace,
+                                           aReplacedBlock);
+    return !aBandHasFloats ||
+           PR_MAX(aFloatAvailableSpace.x, replacedWidth.marginLeft) +
+             replacedWidth.borderBoxWidth +
+             PR_MAX(mContentArea.width -
+                      PR_MIN(mContentArea.width, aFloatAvailableSpace.XMost()),
+                    replacedWidth.marginRight) <=
+           mContentArea.width;
+  }
+
   PRBool IsAdjacentWithTop() const {
     return mY ==
       ((mFlags & BRS_ISFIRSTINFLOW) ? mReflowState.mComputedBorderPadding.top : 0);
   }
 
   /**
    * Adjusts the border/padding to return 0 for the top if
    * we are not the first in flow.
@@ -164,17 +197,17 @@ public:
   // Caller must have called GetAvailableSpace for the correct position
   // (which need not be the current mY).  Callers need only pass
   // aReplacedWidth for outer table frames.
   void ComputeReplacedBlockOffsetsForFloats(nsIFrame* aFrame,
                                             const nsRect& aFloatAvailableSpace,
                                             nscoord& aLeftResult,
                                             nscoord& aRightResult,
                                        nsBlockFrame::ReplacedElementWidthToClear
-                                                      *aReplacedWidth = nsnull);
+                                                *aReplacedWidth = nsnull) const;
 
   // Caller must have called GetAvailableSpace for the current mY
   void ComputeBlockAvailSpace(nsIFrame* aFrame,
                               const nsStyleDisplay* aDisplay,
                               PRBool aBandHasFloats,
                               const nsRect& aFloatAvailableSpace,
                               PRBool aBlockAvoidsFloats,
                               nsRect& aResult);
diff --git a/layout/reftests/bugs/25888-1l.html b/layout/reftests/bugs/25888-1l-block.html
copy from layout/reftests/bugs/25888-1l.html
copy to layout/reftests/bugs/25888-1l-block.html
--- a/layout/reftests/bugs/25888-1l.html
+++ b/layout/reftests/bugs/25888-1l-block.html
@@ -1,17 +1,17 @@
 <!DOCTYPE HTML>
 <html>
 <head>
 <title>Testcase, bug 25888</title>
 <style type="text/css">
 
-body { width: 400px; border: medium solid; text-align: left; }
+body { width: 400px; border: medium solid; }
 div { float: left; clear: left; }
-span { display: inline-block; vertical-align: top; width: 200px; height: 50px; background: aqua; }
+span { display: block; overflow: hidden; width: 200px; height: 50px; background: aqua; margin-right: auto; }
 
 </style>
 </head>
 <body>
 
 <div style="width: 50px; height: 75px;"></div>
 <div style="width: 100px; height: 75px;"></div>
 <span></span>
diff --git a/layout/reftests/bugs/25888-1r.html b/layout/reftests/bugs/25888-1r-block.html
copy from layout/reftests/bugs/25888-1r.html
copy to layout/reftests/bugs/25888-1r-block.html
--- a/layout/reftests/bugs/25888-1r.html
+++ b/layout/reftests/bugs/25888-1r-block.html
@@ -1,17 +1,17 @@
 <!DOCTYPE HTML>
 <html>
 <head>
 <title>Testcase, bug 25888</title>
 <style type="text/css">
 
-body { width: 400px; border: medium solid; text-align: right; }
+body { width: 400px; border: medium solid; }
 div { float: right; clear: right; }
-span { display: inline-block; vertical-align: top; width: 200px; height: 50px; background: aqua; }
+span { display: block; overflow: hidden; width: 200px; height: 50px; background: aqua; margin-left: auto; }
 
 </style>
 </head>
 <body>
 
 <div style="width: 50px; height: 75px;"></div>
 <div style="width: 100px; height: 75px;"></div>
 <span></span>
diff --git a/layout/reftests/bugs/25888-2l.html b/layout/reftests/bugs/25888-2l-block.html
copy from layout/reftests/bugs/25888-2l.html
copy to layout/reftests/bugs/25888-2l-block.html
--- a/layout/reftests/bugs/25888-2l.html
+++ b/layout/reftests/bugs/25888-2l-block.html
@@ -1,16 +1,16 @@
 <!DOCTYPE HTML>
 <html>
 <head>
 <title>Testcase, bug 25888</title>
 <style type="text/css">
 
 body { width: 400px; border: medium solid; }
-span { display: inline-block; vertical-align: top; width: 200px; height: 50px; background: aqua; }
+span { display: block; overflow: hidden; width: 200px; height: 50px; background: aqua; }
 
 </style>
 </head>
 <body>
 
 <div style="float: left; width: 150px; height: 75px;"></div>
 <div style="float: right; width: 300px; height: 75px;"></div>
 <span></span>
diff --git a/layout/reftests/bugs/25888-2r.html b/layout/reftests/bugs/25888-2r-block.html
copy from layout/reftests/bugs/25888-2r.html
copy to layout/reftests/bugs/25888-2r-block.html
--- a/layout/reftests/bugs/25888-2r.html
+++ b/layout/reftests/bugs/25888-2r-block.html
@@ -1,16 +1,16 @@
 <!DOCTYPE HTML>
 <html>
 <head>
 <title>Testcase, bug 25888</title>
 <style type="text/css">
 
 body { width: 400px; border: medium solid; }
-span { display: inline-block; vertical-align: top; width: 200px; height: 50px; background: aqua; }
+span { display: block; overflow: hidden; width: 200px; height: 50px; background: aqua; }
 
 </style>
 </head>
 <body>
 
 <div style="float: right; width: 150px; height: 75px;"></div>
 <div style="float: left; width: 300px; height: 75px;"></div>
 <span></span>
diff --git a/layout/reftests/bugs/25888-3l.html b/layout/reftests/bugs/25888-3l-block.html
copy from layout/reftests/bugs/25888-3l.html
copy to layout/reftests/bugs/25888-3l-block.html
--- a/layout/reftests/bugs/25888-3l.html
+++ b/layout/reftests/bugs/25888-3l-block.html
@@ -1,16 +1,16 @@
 <!DOCTYPE HTML>
 <html>
 <head>
 <title>Testcase, bug 25888</title>
 <style type="text/css">
 
 body { width: 400px; border: medium solid; }
-span { display: inline-block; vertical-align: top; width: 100px; height: 50px; background: aqua; }
+span { display: block; overflow: hidden; width: 100px; height: 50px; background: aqua; }
 
 </style>
 </head>
 <body>
 
 <div style="float: left; width: 250px; height: 75px;"></div>
 <div style="float: right; width: 250px; height: 75px;"></div>
 <span></span>
diff --git a/layout/reftests/bugs/25888-3r.html b/layout/reftests/bugs/25888-3r-block.html
copy from layout/reftests/bugs/25888-3r.html
copy to layout/reftests/bugs/25888-3r-block.html
--- a/layout/reftests/bugs/25888-3r.html
+++ b/layout/reftests/bugs/25888-3r-block.html
@@ -1,16 +1,16 @@
 <!DOCTYPE HTML>
 <html>
 <head>
 <title>Testcase, bug 25888</title>
 <style type="text/css">
 
 body { width: 400px; border: medium solid; }
-span { display: inline-block; vertical-align: top; width: 100px; height: 50px; background: aqua; }
+span { display: block; overflow: hidden; width: 100px; height: 50px; background: aqua; }
 
 </style>
 </head>
 <body>
 
 <div style="float: right; width: 250px; height: 75px;"></div>
 <div style="float: left; width: 250px; height: 75px;"></div>
 <span></span>
diff --git a/layout/reftests/bugs/reftest.list b/layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list
+++ b/layout/reftests/bugs/reftest.list
@@ -39,16 +39,24 @@
 == 25888-1l.html 25888-1l-ref.html
 != 25888-1l.html 25888-1l-notref.html
 == 25888-1r.html 25888-1r-ref.html
 != 25888-1r.html 25888-1r-notref.html
 == 25888-2l.html 25888-2l-ref.html
 == 25888-2r.html 25888-2r-ref.html
 == 25888-3l.html 25888-3l-ref.html
 == 25888-3r.html 25888-3r-ref.html
+== 25888-1l-block.html 25888-1l-ref.html
+!= 25888-1l-block.html 25888-1l-notref.html
+== 25888-1r-block.html 25888-1r-ref.html
+!= 25888-1r-block.html 25888-1r-notref.html
+== 25888-2l-block.html 25888-2l-ref.html
+== 25888-2r-block.html 25888-2r-ref.html
+== 25888-3l-block.html 25888-3l-ref.html
+== 25888-3r-block.html 25888-3r-ref.html
 == 28811-1a.html 28811-1-ref.html
 == 28811-1b.html 28811-1-ref.html
 == 28811-2a.html 28811-2-ref.html
 == 28811-2b.html 28811-2-ref.html
 == 40596-1a.html 40596-1-ref.html
 != 40596-1b.html 40596-1-ref.html
 == 40596-1c.html 40596-1-ref.html
 != 40596-1d.html 40596-1-ref.html
