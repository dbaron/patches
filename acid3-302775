From: Olli Pettay <Olli.Pettay@gmail.com>

WIP from attachment 332418 on bug 302775

diff --git a/content/base/public/nsIContentIterator.h b/content/base/public/nsIContentIterator.h
--- a/content/base/public/nsIContentIterator.h
+++ b/content/base/public/nsIContentIterator.h
@@ -35,31 +35,31 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef __nsIContentIterator_h___
 #define __nsIContentIterator_h___
 
 #include "nsISupports.h"
 
-class nsIContent;
+class nsINode;
 class nsIDOMRange;
 
 #define NS_ICONTENTITERTOR_IID \
-{0xa6cf90e4, 0x15b3, 0x11d2,   \
-{0x93, 0x2e, 0x00, 0x80, 0x5f, 0x8a, 0xdd, 0x32} }
+{ 0x716a396c, 0xdc4e, 0x4d10, \
+  { 0xbd, 0x07, 0x27, 0xee, 0xae, 0x85, 0xe3, 0x86 } }
 
 class nsIContentIterator : public nsISupports
 {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICONTENTITERTOR_IID)
 
   /* Initializes an iterator for the subtree rooted by the node aRoot
    */
-  virtual nsresult Init(nsIContent* aRoot) = 0;
+  virtual nsresult Init(nsINode* aRoot) = 0;
 
   /* Initializes an iterator for the subtree defined by the range aRange
    */
   virtual nsresult Init(nsIDOMRange* aRange) = 0;
 
   /** First will reset the list.
    */
   virtual void First() = 0;
@@ -74,25 +74,25 @@ public:
 
   /** Prev will decrement the list.
    */
   virtual void Prev() = 0;
 
   /** CurrentItem will return the current item, or null if the list is empty
    *  @return the current node
    */
-  virtual nsIContent *GetCurrentNode() = 0;
+  virtual nsINode *GetCurrentNode() = 0;
 
   /** return if the collection is at the end. that is the beginning following a call to Prev
    *  and it is the end of the list following a call to next
    *  @return if the iterator is done.
    */
   virtual PRBool IsDone() = 0;
 
   /** PositionAt will position the iterator to the supplied node
    */
-  virtual nsresult PositionAt(nsIContent* aCurNode) = 0;
+  virtual nsresult PositionAt(nsINode* aCurNode) = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIContentIterator, NS_ICONTENTITERTOR_IID)
 
 #endif // __nsIContentIterator_h___
 
diff --git a/content/base/src/nsContentIterator.cpp b/content/base/src/nsContentIterator.cpp
--- a/content/base/src/nsContentIterator.cpp
+++ b/content/base/src/nsContentIterator.cpp
@@ -60,57 +60,57 @@ static NS_DEFINE_IID(kISupportsIID, NS_I
 //
 static inline PRBool
 NodeHasChildren(nsINode *aNode)
 {
   return aNode->GetChildCount() > 0;
 }
 
 ///////////////////////////////////////////////////////////////////////////
-// ContentToParentOffset: returns the content node's parent and offset.
+// NodeToParentOffset: returns the node's parent and offset.
 //
 
-static nsIContent*
-ContentToParentOffset(nsIContent *aContent, PRInt32 *aOffset)
+static nsINode*
+NodeToParentOffset(nsINode *aNode, PRInt32 *aOffset)
 {
   *aOffset  = 0;
 
-  nsIContent* parent = aContent->GetParent();
+  nsINode* parent = aNode->GetNodeParent();
 
   if (parent) {
-    *aOffset = parent->IndexOf(aContent);
+    *aOffset = parent->IndexOf(aNode);
   }
   
   return parent;
 }
 
 ///////////////////////////////////////////////////////////////////////////
-// ContentIsInTraversalRange: returns true if content is visited during
+// NodeIsInTraversalRange: returns true if content is visited during
 // the traversal of the range in the specified mode.
 //
 static PRBool
-ContentIsInTraversalRange(nsIContent *aContent, PRBool aIsPreMode,
-                          nsINode *aStartNode, PRInt32 aStartOffset,
-                          nsINode *aEndNode, PRInt32 aEndOffset)
+NodeIsInTraversalRange(nsINode *aNode, PRBool aIsPreMode,
+                       nsINode *aStartNode, PRInt32 aStartOffset,
+                       nsINode *aEndNode, PRInt32 aEndOffset)
 {
-  if (!aStartNode || !aEndNode || !aContent)
+  if (!aStartNode || !aEndNode || !aNode)
     return PR_FALSE;
 
   // If a chardata node contains an end point of the traversal range,
   // it is always in the traversal range.
-  if (aContent->IsNodeOfType(nsINode::eDATA_NODE) &&
-      (aContent == aStartNode || aContent == aEndNode)) {
+  if (aNode->IsNodeOfType(nsINode::eDATA_NODE) &&
+      (aNode == aStartNode || aNode == aEndNode)) {
     return PR_TRUE;
   }
 
-  nsIContent* parent = aContent->GetParent();
+  nsINode* parent = aNode->GetNodeParent();
   if (!parent)
     return PR_FALSE;
 
-  PRInt32 indx = parent->IndexOf(aContent);
+  PRInt32 indx = parent->IndexOf(aNode);
 
   if (!aIsPreMode)
     ++indx;
 
   return (nsContentUtils::ComparePoints(aStartNode, aStartOffset,
                                         parent, indx) <= 0) &&
          (nsContentUtils::ComparePoints(aEndNode, aEndOffset,
                                         parent, indx) >= 0);
@@ -126,62 +126,62 @@ public:
 public:
   NS_DECL_ISUPPORTS
 
   nsContentIterator();
   virtual ~nsContentIterator();
 
   // nsIContentIterator interface methods ------------------------------
 
-  virtual nsresult Init(nsIContent* aRoot);
+  virtual nsresult Init(nsINode* aRoot);
 
   virtual nsresult Init(nsIDOMRange* aRange);
 
   virtual void First();
 
   virtual void Last();
   
   virtual void Next();
 
   virtual void Prev();
 
-  virtual nsIContent *GetCurrentNode();
+  virtual nsINode *GetCurrentNode();
 
   virtual PRBool IsDone();
 
-  virtual nsresult PositionAt(nsIContent* aCurNode);
+  virtual nsresult PositionAt(nsINode* aCurNode);
 
   // nsIEnumertor interface methods ------------------------------
   
   //NS_IMETHOD CurrentItem(nsISupports **aItem);
 
 protected:
 
-  nsIContent *GetDeepFirstChild(nsIContent *aRoot, nsVoidArray *aIndexes);
-  nsIContent *GetDeepLastChild(nsIContent *aRoot, nsVoidArray *aIndexes);
+  nsINode* GetDeepFirstChild(nsINode *aRoot, nsVoidArray *aIndexes);
+  nsINode* GetDeepLastChild(nsINode *aRoot, nsVoidArray *aIndexes);
 
   // Get the next sibling of aNode.  Note that this will generally return null
   // if aNode happens not to be a content node.  That's OK.
-  nsIContent *GetNextSibling(nsINode *aNode, nsVoidArray *aIndexes);
+  nsINode* GetNextSibling(nsINode *aNode, nsVoidArray *aIndexes);
 
   // Get the prev sibling of aNode.  Note that this will generally return null
   // if aNode happens not to be a content node.  That's OK.
-  nsIContent *GetPrevSibling(nsINode *aNode, nsVoidArray *aIndexes);
+  nsINode* GetPrevSibling(nsINode *aNode, nsVoidArray *aIndexes);
 
-  nsIContent *NextNode(nsIContent *aNode, nsVoidArray *aIndexes);
-  nsIContent *PrevNode(nsIContent *aNode, nsVoidArray *aIndexes);
+  nsINode* NextNode(nsINode *aNode, nsVoidArray *aIndexes);
+  nsINode* PrevNode(nsINode *aNode, nsVoidArray *aIndexes);
 
   // WARNING: This function is expensive
   nsresult RebuildIndexStack();
 
   void MakeEmpty();
   
-  nsCOMPtr<nsIContent> mCurNode;
-  nsCOMPtr<nsIContent> mFirst;
-  nsCOMPtr<nsIContent> mLast;
+  nsCOMPtr<nsINode> mCurNode;
+  nsCOMPtr<nsINode> mFirst;
+  nsCOMPtr<nsINode> mLast;
   nsCOMPtr<nsINode> mCommonParent;
 
   // used by nsContentIterator to cache indices
   nsAutoVoidArray mIndexes;
 
   // used by nsSubtreeIterator to cache indices.  Why put them in the base class?
   // Because otherwise I have to duplicate the routines GetNextSibling etc across both classes,
   // with slight variations for caching.  Or alternately, create a base class for the cache
@@ -277,20 +277,21 @@ nsContentIterator::~nsContentIterator()
 
 
 /******************************************************
  * Init routines
  ******************************************************/
 
 
 nsresult
-nsContentIterator::Init(nsIContent* aRoot)
+nsContentIterator::Init(nsINode* aRoot)
 {
   if (!aRoot) 
     return NS_ERROR_NULL_POINTER; 
+
   mIsDone = PR_FALSE;
   mIndexes.Clear();
   
   if (mPre)
   {
     mFirst = aRoot;
     mLast  = GetDeepLastChild(aRoot, nsnull);
   }
@@ -383,18 +384,18 @@ nsContentIterator::Init(nsIDOMRange* aRa
       {
         mFirst = GetNextSibling(startNode, nsnull);
 
         // Does mFirst node really intersect the range?
         // The range could be 'degenerate', ie not collapsed 
         // but still contain no content.
   
         if (mFirst &&
-            !ContentIsInTraversalRange(mFirst, mPre, startNode, startIndx,
-                                       endNode, endIndx)) {
+            !NodeIsInTraversalRange(mFirst, mPre, startNode, startIndx,
+                                    endNode, endIndx)) {
           mFirst = nsnull;
         }
       }
       else {
         NS_ASSERTION(startNode->IsNodeOfType(nsINode::eCONTENT),
                    "Data node that's not content?");
 
         mFirst = static_cast<nsIContent*>(startNode);
@@ -418,18 +419,18 @@ nsContentIterator::Init(nsIDOMRange* aRa
     {
       mFirst = GetDeepFirstChild(cChild, nsnull);
 
       // Does mFirst node really intersect the range?
       // The range could be 'degenerate', ie not collapsed 
       // but still contain no content.
   
       if (mFirst &&
-          !ContentIsInTraversalRange(mFirst, mPre, startNode, startIndx,
-                                     endNode, endIndx))
+          !NodeIsInTraversalRange(mFirst, mPre, startNode, startIndx,
+                                  endNode, endIndx))
         mFirst = nsnull;
     }
   }
 
 
   // Find last node in range.
 
   PRBool endIsData = endNode->IsNodeOfType(nsINode::eDATA_NODE);
@@ -449,18 +450,18 @@ nsContentIterator::Init(nsIDOMRange* aRa
       // XXX: In the future, if end offset is before the first
       //      character in the cdata node, should we set mLast to
       //      the prev sibling?
 
       if (!endIsData)
       {
         mLast = GetPrevSibling(endNode, nsnull);
 
-        if (!ContentIsInTraversalRange(mLast, mPre, startNode, startIndx,
-                                       endNode, endIndx))
+        if (!NodeIsInTraversalRange(mLast, mPre, startNode, startIndx,
+                                    endNode, endIndx))
           mLast = nsnull;
       }
       else {
         NS_ASSERTION(endNode->IsNodeOfType(nsINode::eCONTENT),
                      "Data node that's not content?");
 
         mLast = static_cast<nsIContent*>(endNode);
       }
@@ -477,18 +478,18 @@ nsContentIterator::Init(nsIDOMRange* aRa
       NS_NOTREACHED("nsContentIterator::nsContentIterator");
       return NS_ERROR_FAILURE; 
     }
 
     if (mPre)
     {
       mLast  = GetDeepLastChild(cChild, nsnull);
 
-      if (!ContentIsInTraversalRange(mLast, mPre, startNode, startIndx,
-                                     endNode, endIndx)) {
+      if (!NodeIsInTraversalRange(mLast, mPre, startNode, startIndx,
+                                  endNode, endIndx)) {
         mLast = nsnull;
       }
     }
     else { // post-order 
       mLast = cChild;
     }
   }
 
@@ -517,28 +518,28 @@ nsContentIterator::Init(nsIDOMRange* aRa
  * Helper routines
  ******************************************************/
 // WARNING: This function is expensive
 nsresult nsContentIterator::RebuildIndexStack()
 {
   // Make sure we start at the right indexes on the stack!  Build array up
   // to common parent of start and end.  Perhaps it's too many entries, but
   // that's far better than too few.
-  nsIContent* parent;
-  nsIContent* current;
+  nsINode* parent;
+  nsINode* current;
 
   mIndexes.Clear();
   current = mCurNode;
   if (!current) {
     return NS_OK;
   }
 
   while (current != mCommonParent)
   {
-    parent = current->GetParent();
+    parent = current->GetNodeParent();
     
     if (!parent)
       return NS_ERROR_FAILURE;
   
     mIndexes.InsertElementAt(NS_INT32_TO_PTR(parent->IndexOf(current)), 0);
 
     current = parent;
   }
@@ -551,72 +552,72 @@ nsContentIterator::MakeEmpty()
   mCurNode      = nsnull;
   mFirst        = nsnull;
   mLast         = nsnull;
   mCommonParent = nsnull;
   mIsDone       = PR_TRUE;
   mIndexes.Clear();
 }
 
-nsIContent *
-nsContentIterator::GetDeepFirstChild(nsIContent *aRoot, nsVoidArray *aIndexes)
+nsINode*
+nsContentIterator::GetDeepFirstChild(nsINode *aRoot, nsVoidArray *aIndexes)
 {
   if (!aRoot) {
     return nsnull;
   }
 
-  nsIContent *cN = aRoot;
-  nsIContent *cChild = cN->GetChildAt(0);
+  nsINode *n = aRoot;
+  nsINode *nChild = n->GetChildAt(0);
 
-  while (cChild)
+  while (nChild)
   {
     if (aIndexes)
     {
       // Add this node to the stack of indexes
       aIndexes->AppendElement(NS_INT32_TO_PTR(0));
     }
-    cN = cChild;
-    cChild = cN->GetChildAt(0);
+    n = nChild;
+    nChild = n->GetChildAt(0);
   }
 
-  return cN;
+  return n;
 }
 
-nsIContent *
-nsContentIterator::GetDeepLastChild(nsIContent *aRoot, nsVoidArray *aIndexes)
+nsINode*
+nsContentIterator::GetDeepLastChild(nsINode *aRoot, nsVoidArray *aIndexes)
 {
   if (!aRoot) {
     return nsnull;
   }
 
-  nsIContent *deepLastChild = aRoot;
+  nsINode *deepLastChild = aRoot;
 
-  nsIContent *cN = aRoot;
-  PRInt32 numChildren = cN->GetChildCount();
+  nsINode *n = aRoot;
+  PRInt32 numChildren = n->GetChildCount();
 
   while (numChildren)
   {
-    nsIContent *cChild = cN->GetChildAt(--numChildren);
+    nsINode *nChild = n->GetChildAt(--numChildren);
 
     if (aIndexes)
     {
       // Add this node to the stack of indexes
       aIndexes->AppendElement(NS_INT32_TO_PTR(numChildren));
     }
-    numChildren = cChild->GetChildCount();
-    cN = cChild;
+    numChildren = nChild->GetChildCount();
+    n = nChild;
 
-    deepLastChild = cN;
+    deepLastChild = n;
   }
 
   return deepLastChild;
 }
 
 // Get the next sibling, or parents next sibling, or grandpa's next sibling...
-nsIContent *
+nsINode *
 nsContentIterator::GetNextSibling(nsINode *aNode, 
                                   nsVoidArray *aIndexes)
 {
   if (!aNode) 
     return nsnull;
 
   nsINode *parent = aNode->GetNodeParent();
   if (!parent)
@@ -631,17 +632,17 @@ nsContentIterator::GetNextSibling(nsINod
     indx = NS_PTR_TO_INT32((*aIndexes)[aIndexes->Count()-1]);
   }
   else
     indx = mCachedIndex;
 
   // reverify that the index of the current node hasn't changed.
   // not super cheap, but a lot cheaper than IndexOf(), and still O(1).
   // ignore result this time - the index may now be out of range.
-  nsIContent *sib = parent->GetChildAt(indx);
+  nsINode* sib = parent->GetChildAt(indx);
   if (sib != aNode)
   {
     // someone changed our index - find the new index the painful way
     indx = parent->IndexOf(aNode);
   }
 
   // indx is now canonically correct
   if ((sib = parent->GetChildAt(++indx)))
@@ -670,17 +671,17 @@ nsContentIterator::GetNextSibling(nsINod
     // ok to leave cache out of date here if parent == mCommonParent?
     sib = GetNextSibling(parent, aIndexes);
   }
   
   return sib;
 }
 
 // Get the prev sibling, or parents prev sibling, or grandpa's prev sibling...
-nsIContent *
+nsINode*
 nsContentIterator::GetPrevSibling(nsINode *aNode, 
                                   nsVoidArray *aIndexes)
 {
   if (!aNode)
     return nsnull;
 
   nsINode *parent = aNode->GetNodeParent();
   if (!parent)
@@ -694,17 +695,17 @@ nsContentIterator::GetPrevSibling(nsINod
     // use the last entry on the Indexes array for the current index
     indx = NS_PTR_TO_INT32((*aIndexes)[aIndexes->Count()-1]);
   }
   else
     indx = mCachedIndex;
 
   // reverify that the index of the current node hasn't changed
   // ignore result this time - the index may now be out of range.
-  nsIContent *sib = parent->GetChildAt(indx);
+  nsINode *sib = parent->GetChildAt(indx);
   if (sib != aNode)
   {
     // someone changed our index - find the new index the painful way
     indx = parent->IndexOf(aNode);
   }
 
   // indx is now canonically correct
   if (indx > 0 && (sib = parent->GetChildAt(--indx)))
@@ -724,83 +725,83 @@ nsContentIterator::GetPrevSibling(nsINod
       aIndexes->RemoveElementAt(aIndexes->Count()-1);
     }
     return GetPrevSibling(parent, aIndexes);
   }
 
   return sib;
 }
 
-nsIContent *
-nsContentIterator::NextNode(nsIContent *aNode, nsVoidArray *aIndexes)
+nsINode*
+nsContentIterator::NextNode(nsINode *aNode, nsVoidArray *aIndexes)
 {
-  nsIContent *cN = aNode;
-  nsIContent *nextNode = nsnull;
+  nsINode *n = aNode;
+  nsINode *nextNode = nsnull;
 
   if (mPre)  // if we are a Pre-order iterator, use pre-order
   {
     // if it has children then next node is first child
-    if (NodeHasChildren(cN))
+    if (NodeHasChildren(n))
     {
-      nsIContent *cFirstChild = cN->GetChildAt(0);
+      nsINode *nFirstChild = n->GetChildAt(0);
 
       // update cache
       if (aIndexes)
       {
         // push an entry on the index stack
         aIndexes->AppendElement(NS_INT32_TO_PTR(0));
       }
       else mCachedIndex = 0;
       
-      return cFirstChild;
+      return nFirstChild;
     }
 
     // else next sibling is next
-    nextNode = GetNextSibling(cN, aIndexes);
+    nextNode = GetNextSibling(n, aIndexes);
   }
   else  // post-order
   {
-    nsIContent *parent = cN->GetParent();
-    nsIContent *cSibling = nsnull;
+    nsINode *parent = n->GetNodeParent();
+    nsINode *nSibling = nsnull;
     PRInt32 indx;
 
     // get the cached index
     if (aIndexes)
     {
       NS_ASSERTION(aIndexes->Count() > 0, "ContentIterator stack underflow");
       // use the last entry on the Indexes array for the current index
       indx = NS_PTR_TO_INT32((*aIndexes)[aIndexes->Count()-1]);
     }
     else indx = mCachedIndex;
 
     // reverify that the index of the current node hasn't changed.
     // not super cheap, but a lot cheaper than IndexOf(), and still O(1).
     // ignore result this time - the index may now be out of range.
     if (indx >= 0)
-      cSibling = parent->GetChildAt(indx);
-    if (cSibling != cN)
+      nSibling = parent->GetChildAt(indx);
+    if (nSibling != n)
     {
       // someone changed our index - find the new index the painful way
-      indx = parent->IndexOf(cN);
+      indx = parent->IndexOf(n);
     }
 
     // indx is now canonically correct
-    cSibling = parent->GetChildAt(++indx);
-    if (cSibling)
+    nSibling = parent->GetChildAt(++indx);
+    if (nSibling)
     {
       // update cache
       if (aIndexes)
       {
         // replace an entry on the index stack
         aIndexes->ReplaceElementAt(NS_INT32_TO_PTR(indx),aIndexes->Count()-1);
       }
       else mCachedIndex = indx;
       
       // next node is siblings "deep left" child
-      return GetDeepFirstChild(cSibling, aIndexes); 
+      return GetDeepFirstChild(nSibling, aIndexes); 
     }
   
     // else it's the parent
     // update cache
     if (aIndexes)
     {
       // pop an entry off the index stack
       // Don't leave the index empty, especially if we're
@@ -810,96 +811,96 @@ nsContentIterator::NextNode(nsIContent *
     }
     else mCachedIndex = 0;   // this might be wrong, but we are better off guessing
     nextNode = parent;
   }
 
   return nextNode;
 }
 
-nsIContent *
-nsContentIterator::PrevNode(nsIContent *aNode, nsVoidArray *aIndexes)
+nsINode*
+nsContentIterator::PrevNode(nsINode *aNode, nsVoidArray *aIndexes)
 {
-  nsIContent *prevNode = nsnull;
-  nsIContent *cN = aNode;
+  nsINode *prevNode = nsnull;
+  nsINode *n = aNode;
    
   if (mPre)  // if we are a Pre-order iterator, use pre-order
   {
-    nsIContent *parent = cN->GetParent();
-    nsIContent *cSibling = nsnull;
+    nsINode *parent = n->GetNodeParent();
+    nsINode *nSibling = nsnull;
     PRInt32 indx;
 
     // get the cached index
     if (aIndexes)
     {
       NS_ASSERTION(aIndexes->Count() > 0, "ContentIterator stack underflow");
       // use the last entry on the Indexes array for the current index
       indx = NS_PTR_TO_INT32((*aIndexes)[aIndexes->Count()-1]);
     }
     else indx = mCachedIndex;
 
     // reverify that the index of the current node hasn't changed.
     // not super cheap, but a lot cheaper than IndexOf(), and still O(1).
     // ignore result this time - the index may now be out of range.
     if (indx >= 0)
-      cSibling = parent->GetChildAt(indx);
+      nSibling = parent->GetChildAt(indx);
 
-    if (cSibling != cN)
+    if (nSibling != n)
     {
       // someone changed our index - find the new index the painful way
-      indx = parent->IndexOf(cN);
+      indx = parent->IndexOf(n);
     }
 
     // indx is now canonically correct
-    if (indx && (cSibling = parent->GetChildAt(--indx)))
+    if (indx && (nSibling = parent->GetChildAt(--indx)))
     {
       // update cache
       if (aIndexes)
       {
         // replace an entry on the index stack
         aIndexes->ReplaceElementAt(NS_INT32_TO_PTR(indx),aIndexes->Count()-1);
       }
       else mCachedIndex = indx;
       
       // prev node is siblings "deep right" child
-      return GetDeepLastChild(cSibling, aIndexes); 
+      return GetDeepLastChild(nSibling, aIndexes); 
     }
   
     // else it's the parent
     // update cache
     if (aIndexes)
     {
       // pop an entry off the index stack
       aIndexes->RemoveElementAt(aIndexes->Count()-1);
     }
     else mCachedIndex = 0;   // this might be wrong, but we are better off guessing
     prevNode = parent;
   }
   else  // post-order
   {
-    PRInt32 numChildren = cN->GetChildCount();
+    PRInt32 numChildren = n->GetChildCount();
   
     // if it has children then prev node is last child
     if (numChildren)
     {
-      nsIContent *cLastChild = cN->GetChildAt(--numChildren);
+      nsINode *nLastChild = n->GetChildAt(--numChildren);
 
       // update cache
       if (aIndexes)
       {
         // push an entry on the index stack
         aIndexes->AppendElement(NS_INT32_TO_PTR(numChildren));
       }
       else mCachedIndex = numChildren;
       
-      return cLastChild;
+      return nLastChild;
     }
 
     // else prev sibling is previous
-    prevNode = GetPrevSibling(cN, aIndexes);
+    prevNode = GetPrevSibling(n, aIndexes);
   }
 
   return prevNode;
 }
 
 /******************************************************
  * ContentIterator routines
  ******************************************************/
@@ -977,69 +978,69 @@ nsContentIterator::IsDone()
 {
   return mIsDone;
 }
 
 
 // Keeping arrays of indexes for the stack of nodes makes PositionAt
 // interesting...
 nsresult
-nsContentIterator::PositionAt(nsIContent* aCurNode)
+nsContentIterator::PositionAt(nsINode* aCurNode)
 {
   if (!aCurNode)
     return NS_ERROR_NULL_POINTER;
 
-  nsIContent *newCurNode = aCurNode;
-  nsIContent *tempNode = mCurNode;
+  nsINode *newCurNode = aCurNode;
+  nsINode *tempNode = mCurNode;
 
   mCurNode = aCurNode;
   // take an early out if this doesn't actually change the position
   if (mCurNode == tempNode)
   {
     mIsDone = PR_FALSE;  // paranoia
     return NS_OK;
   }
 
   // Check to see if the node falls within the traversal range.
 
-  nsIContent* firstNode = mFirst;
-  nsIContent* lastNode = mLast;
+  nsINode* firstNode = mFirst;
+  nsINode* lastNode = mLast;
   PRInt32 firstOffset=0, lastOffset=0;
 
   if (firstNode && lastNode)
   {
     if (mPre)
     {
-      firstNode = ContentToParentOffset(mFirst, &firstOffset);
+      firstNode = NodeToParentOffset(mFirst, &firstOffset);
 
       if (lastNode->GetChildCount())
         lastOffset = 0;
       else
       {
-        lastNode = ContentToParentOffset(mLast, &lastOffset);
+        lastNode = NodeToParentOffset(mLast, &lastOffset);
         ++lastOffset;
       }
     }
     else
     {
       PRUint32 numChildren = firstNode->GetChildCount();
 
       if (numChildren)
         firstOffset = numChildren;
       else
-        firstNode = ContentToParentOffset(mFirst, &firstOffset);
+        firstNode = NodeToParentOffset(mFirst, &firstOffset);
 
-      lastNode = ContentToParentOffset(mLast, &lastOffset);
+      lastNode = NodeToParentOffset(mLast, &lastOffset);
       ++lastOffset;
     }
   }
 
   if (!firstNode || !lastNode ||
-      !ContentIsInTraversalRange(mCurNode, mPre, firstNode, firstOffset,
-                                 lastNode, lastOffset))
+      !NodeIsInTraversalRange(mCurNode, mPre, firstNode, firstOffset,
+                              lastNode, lastOffset))
   {
     mIsDone = PR_TRUE;
     return NS_ERROR_FAILURE;
   }
 
   // We can be at ANY node in the sequence.
   // Need to regenerate the array of indexes back to the root or common parent!
   nsAutoVoidArray      oldParentStack;
@@ -1061,17 +1062,17 @@ nsContentIterator::PositionAt(nsIContent
   // sure we include mCommonParent in the oldParentStack, for use in the next
   // for loop, and mIndexes only has entries for nodes from tempNode up through
   // an ancestor of tempNode that's a child of mCommonParent.
   for (PRInt32 i = mIndexes.Count()+1; i > 0 && tempNode; i--)
   {
     // Insert at head since we're walking up
     oldParentStack.InsertElementAt(tempNode,0);
 
-    nsIContent *parent = tempNode->GetParent();
+    nsINode *parent = tempNode->GetNodeParent();
 
     if (!parent)  // this node has no parent, and thus no index
       break;
 
     if (parent == mCurNode)
     {
       // The position was moved to a parent of the current position. 
       // All we need to do is drop some indexes.  Shortcut here.
@@ -1081,17 +1082,17 @@ nsContentIterator::PositionAt(nsIContent
       return NS_OK;
     }
     tempNode = parent;
   }
 
   // Ok.  We have the array of old parents.  Look for a match.
   while (newCurNode)
   {
-    nsIContent *parent = newCurNode->GetParent();
+    nsINode *parent = newCurNode->GetNodeParent();
 
     if (!parent)  // this node has no parent, and thus no index
       break;
 
     PRInt32 indx = parent->IndexOf(newCurNode);
 
     // insert at the head!
     newIndexes.InsertElementAt(NS_INT32_TO_PTR(indx),0);
@@ -1116,18 +1117,17 @@ nsContentIterator::PositionAt(nsIContent
   }
 
   // phew!
 
   mIsDone = PR_FALSE;
   return NS_OK;
 }
 
-
-nsIContent *
+nsINode*
 nsContentIterator::GetCurrentNode()
 {
   if (mIsDone) {
     return nsnull;
   }
 
   NS_ASSERTION(mCurNode, "Null current node in an iterator that's not done!");
 
@@ -1157,36 +1157,36 @@ class nsContentSubtreeIterator : public 
 class nsContentSubtreeIterator : public nsContentIterator 
 {
 public:
   nsContentSubtreeIterator() {}
   virtual ~nsContentSubtreeIterator() {}
 
   // nsContentIterator overrides ------------------------------
 
-  virtual nsresult Init(nsIContent* aRoot);
+  virtual nsresult Init(nsINode* aRoot);
 
   virtual nsresult Init(nsIDOMRange* aRange);
 
   virtual void Next();
 
   virtual void Prev();
 
-  virtual nsresult PositionAt(nsIContent* aCurNode);
+  virtual nsresult PositionAt(nsINode* aCurNode);
 
   // Must override these because we don't do PositionAt
   virtual void First();
 
   // Must override these because we don't do PositionAt
   virtual void Last();
 
 protected:
 
-  nsresult GetTopAncestorInRange(nsIContent *aNode,
-                                 nsCOMPtr<nsIContent> *outAnestor);
+  nsresult GetTopAncestorInRange(nsINode *aNode,
+                                 nsCOMPtr<nsINode> *outAnestor);
 
   // no copy's or assigns  FIX ME
   nsContentSubtreeIterator(const nsContentSubtreeIterator&);
   nsContentSubtreeIterator& operator=(const nsContentSubtreeIterator&);
 
   nsCOMPtr<nsIDOMRange> mRange;
   // these arrays all typically are used and have elements
 #if 0
@@ -1221,72 +1221,65 @@ nsresult NS_NewContentSubtreeIterator(ns
 
 
 
 /******************************************************
  * Init routines
  ******************************************************/
 
 
-nsresult nsContentSubtreeIterator::Init(nsIContent* aRoot)
+nsresult nsContentSubtreeIterator::Init(nsINode* aRoot)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 
 nsresult nsContentSubtreeIterator::Init(nsIDOMRange* aRange)
 {
   if (!aRange) 
     return NS_ERROR_NULL_POINTER; 
 
   mIsDone = PR_FALSE;
 
   mRange = aRange;
   
-  // get the start node and offset, convert to nsIContent
+  // get the start node and offset, convert to nsINode
   nsCOMPtr<nsIDOMNode> commonParent;
   nsCOMPtr<nsIDOMNode> startParent;
   nsCOMPtr<nsIDOMNode> endParent;
-  nsCOMPtr<nsIContent> cStartP;
-  nsCOMPtr<nsIContent> cEndP;
-  nsCOMPtr<nsIContent> cN;
-  nsIContent *firstCandidate = nsnull;
-  nsIContent *lastCandidate = nsnull;
+  nsCOMPtr<nsINode> nStartP;
+  nsCOMPtr<nsINode> nEndP;
+  nsCOMPtr<nsINode> n;
+  nsINode *firstCandidate = nsnull;
+  nsINode *lastCandidate = nsnull;
   PRInt32 indx, startIndx, endIndx;
 
   // get common content parent
   if (NS_FAILED(aRange->GetCommonAncestorContainer(getter_AddRefs(commonParent))) || !commonParent)
     return NS_ERROR_FAILURE;
   mCommonParent = do_QueryInterface(commonParent);
 
   // get start content parent
   if (NS_FAILED(aRange->GetStartContainer(getter_AddRefs(startParent))) || !startParent)
     return NS_ERROR_FAILURE;
-  cStartP = do_QueryInterface(startParent);
+  nStartP = do_QueryInterface(startParent);
   aRange->GetStartOffset(&startIndx);
 
   // get end content parent
   if (NS_FAILED(aRange->GetEndContainer(getter_AddRefs(endParent))) || !endParent)
     return NS_ERROR_FAILURE;
-  cEndP = do_QueryInterface(endParent);
+  nEndP = do_QueryInterface(endParent);
   aRange->GetEndOffset(&endIndx);
 
-  if (!cStartP || !cEndP)
-  {
-    // XXX Hack to account for the fact that not everything QIs to nsIContent.
-    // See bug 302775
-    return NS_ERROR_FAILURE;
-  }
-  
   // short circuit when start node == end node
   if (startParent == endParent)
   {
-    nsIContent* cChild = cStartP->GetChildAt(0);
+    nsINode* nChild = nStartP->GetChildAt(0);
   
-    if (!cChild) // no children, must be a text node or empty container
+    if (!nChild) // no children, must be a text node or empty container
     {
       // all inside one text node - empty subtree iterator
       MakeEmpty();
       return NS_OK;
     }
     else
     {
       if (startIndx == endIndx)  // collapsed range
@@ -1303,37 +1296,37 @@ nsresult nsContentSubtreeIterator::Init(
                                          &mStartNodes, &mStartOffsets);
 #endif
   nsContentUtils::GetAncestorsAndOffsets(endParent, endIndx,
                                          &mEndNodes, &mEndOffsets);
 
   // find first node in range
   aRange->GetStartOffset(&indx);
 
-  if (!cStartP->GetChildCount()) // no children, start at the node itself
+  if (!nStartP->GetChildCount()) // no children, start at the node itself
   {
-    cN = cStartP; 
+    n = nStartP;
   }
   else
   {
-    nsIContent* cChild = cStartP->GetChildAt(indx);
-    if (!cChild)  // offset after last child
+    nsINode* nChild = nStartP->GetChildAt(indx);
+    if (!nChild)  // offset after last child
     {
-      cN = cStartP;
+      n = nStartP;
     }
     else
     {
-      firstCandidate = cChild;
+      firstCandidate = nChild;
     }
   }
   
   if (!firstCandidate)
   {
     // then firstCandidate is next node after cN
-    firstCandidate = GetNextSibling(cN, nsnull);
+    firstCandidate = GetNextSibling(n, nsnull);
 
     if (!firstCandidate)
     {
       MakeEmpty();
       return NS_OK;
     }
   }
   
@@ -1357,41 +1350,41 @@ nsresult nsContentSubtreeIterator::Init(
   // cool, we have the first node in the range.  Now we walk
   // up it's ancestors to find the most senior that is still
   // in the range.  That's the real first node.
   if (NS_FAILED(GetTopAncestorInRange(firstCandidate, address_of(mFirst))))
     return NS_ERROR_FAILURE;
 
   // now to find the last node
   aRange->GetEndOffset(&indx);
-  PRInt32 numChildren = cEndP->GetChildCount();
+  PRInt32 numChildren = nEndP->GetChildCount();
 
   if (indx > numChildren) indx = numChildren;
   if (!indx)
   {
-    cN = cEndP;
+    n = nEndP;
   }
   else
   {
     if (!numChildren) // no children, must be a text node
     {
-      cN = cEndP; 
+      n = nEndP;
     }
     else
     {
-      lastCandidate = cEndP->GetChildAt(--indx);
+      lastCandidate = nEndP->GetChildAt(--indx);
       NS_ASSERTION(lastCandidate,
                    "tree traversal trouble in nsContentSubtreeIterator::Init");
     }
   }
   
   if (!lastCandidate)
   {
-    // then lastCandidate is prev node before cN
-    lastCandidate = GetPrevSibling(cN, nsnull);
+    // then lastCandidate is prev node before n
+    lastCandidate = GetPrevSibling(n, nsnull);
   }
   
   lastCandidate = GetDeepLastChild(lastCandidate, nsnull);
   
   // confirm that this last possible contained node
   // is indeed contained.  Else we have a range that
   // does not fully contain any node.
   
@@ -1447,17 +1440,17 @@ nsContentSubtreeIterator::Next()
     return;
 
   if (mCurNode == mLast) 
   {
     mIsDone = PR_TRUE;
     return;
   }
 
-  nsIContent *nextNode = GetNextSibling(mCurNode, nsnull);
+  nsINode *nextNode = GetNextSibling(mCurNode, nsnull);
   NS_ASSERTION(nextNode, "No next sibling!?! This could mean deadlock!");
 
 /*
   nextNode = GetDeepFirstChild(nextNode);
   return GetTopAncestorInRange(nextNode, address_of(mCurNode));
 */
   PRInt32 i = mEndNodes.IndexOf(nextNode);
   while (i != -1)
@@ -1494,80 +1487,80 @@ nsContentSubtreeIterator::Prev()
     return;
 
   if (mCurNode == mFirst) 
   {
     mIsDone = PR_TRUE;
     return;
   }
 
-  nsIContent *prevNode = PrevNode(GetDeepFirstChild(mCurNode, nsnull), nsnull);
+  nsINode *prevNode = PrevNode(GetDeepFirstChild(mCurNode, nsnull), nsnull);
 
   prevNode = GetDeepLastChild(prevNode, nsnull);
   
   GetTopAncestorInRange(prevNode, address_of(mCurNode));
 
   // This shouldn't be needed, but since our selection code can put us
   // in a situation where mFirst is in generated content, we need this
   // to stop the iterator when we've walked past past the first node!
   mIsDone = mCurNode == nsnull;
 }
 
 
 nsresult
-nsContentSubtreeIterator::PositionAt(nsIContent* aCurNode)
+nsContentSubtreeIterator::PositionAt(nsINode* aCurNode)
 {
   NS_ERROR("Not implemented!");
 
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 /****************************************************************
  * nsContentSubtreeIterator helper routines
  ****************************************************************/
 
 nsresult
-nsContentSubtreeIterator::GetTopAncestorInRange(nsIContent *aNode,
-                                                nsCOMPtr<nsIContent> *outAnestor)
+nsContentSubtreeIterator::GetTopAncestorInRange(nsINode *aNode,
+                                                nsCOMPtr<nsINode> *outAncestor)
 {
   if (!aNode) 
     return NS_ERROR_NULL_POINTER;
-  if (!outAnestor) 
+  if (!outAncestor) 
     return NS_ERROR_NULL_POINTER;
   
   
   // sanity check: aNode is itself in the range
   PRBool nodeBefore, nodeAfter;
   if (NS_FAILED(nsRange::CompareNodeToRange(aNode, mRange, &nodeBefore,
                                             &nodeAfter)))
     return NS_ERROR_FAILURE;
 
   if (nodeBefore || nodeAfter)
     return NS_ERROR_FAILURE;
   
-  nsCOMPtr<nsIContent> parent, tmp;
+  nsCOMPtr<nsINode> parent, tmp;
   while (aNode)
   {
-    parent = aNode->GetParent();
+    parent = aNode->GetNodeParent();
     if (!parent)
     {
       if (tmp)
       {
-        *outAnestor = tmp;
+        *outAncestor = tmp;
         return NS_OK;
       }
       else return NS_ERROR_FAILURE;
     }
     if (NS_FAILED(nsRange::CompareNodeToRange(parent, mRange, &nodeBefore,
                                               &nodeAfter)))
       return NS_ERROR_FAILURE;
 
     if (nodeBefore || nodeAfter)
     {
-      *outAnestor = aNode;
+      *outAncestor = aNode;
       return NS_OK;
     }
     tmp = aNode;
     aNode = parent;
   }
   return NS_ERROR_FAILURE;
 }
 
diff --git a/content/base/src/nsDOMAttribute.cpp b/content/base/src/nsDOMAttribute.cpp
--- a/content/base/src/nsDOMAttribute.cpp
+++ b/content/base/src/nsDOMAttribute.cpp
@@ -51,16 +51,19 @@
 #include "nsIDOMDocument.h"
 #include "nsIDOM3Attr.h"
 #include "nsIDOMUserDataHandler.h"
 #include "nsEventDispatcher.h"
 #include "nsGkAtoms.h"
 #include "nsCOMArray.h"
 #include "nsNodeUtils.h"
 #include "nsIEventListenerManager.h"
+#include "nsTextNode.h"
+#include "mozAutoDocUpdate.h"
+#include "nsMutationEvent.h"
 
 //----------------------------------------------------------------------
 PRBool nsDOMAttribute::sInitialized;
 
 nsDOMAttribute::nsDOMAttribute(nsDOMAttributeMap *aAttrMap,
                                nsINodeInfo       *aNodeInfo,
                                const nsAString   &aValue)
   : nsIAttribute(aAttrMap, aNodeInfo), mValue(aValue), mChild(nsnull)
@@ -83,17 +86,20 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mNodeInfo)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mChild)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_LISTENERMANAGER
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_USERDATA
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_PRESERVED_WRAPPER
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsDOMAttribute)
-  NS_IF_RELEASE(tmp->mChild);
+  if (tmp->mChild) {
+    static_cast<nsTextNode*>(tmp->mChild)->UnbindFromAttribute();
+    NS_RELEASE(tmp->mChild);
+  }
   NS_IMPL_CYCLE_COLLECTION_UNLINK_LISTENERMANAGER
   NS_IMPL_CYCLE_COLLECTION_UNLINK_USERDATA
   NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 // QueryInterface implementation for nsDOMAttribute
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDOMAttribute)
   NS_INTERFACE_MAP_ENTRY(nsIDOMAttr)
   NS_INTERFACE_MAP_ENTRY(nsIAttribute)
@@ -353,17 +359,20 @@ nsDOMAttribute::ReplaceChild(nsIDOMNode*
 nsDOMAttribute::ReplaceChild(nsIDOMNode* aNewChild, nsIDOMNode* aOldChild, nsIDOMNode** aReturn)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
 nsDOMAttribute::RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn)
 {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  nsCOMPtr<nsIContent> content = do_QueryInterface(aOldChild);
+  PRInt32 index = IndexOf(content);
+  return (index == -1) ? NS_ERROR_DOM_NOT_FOUND_ERR :
+    RemoveChildAt(index, PR_TRUE);
 }
 
 NS_IMETHODIMP
 nsDOMAttribute::AppendChild(nsIDOMNode* aNewChild, nsIDOMNode** aReturn)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
@@ -702,17 +711,47 @@ nsDOMAttribute::AppendChildTo(nsIContent
 nsDOMAttribute::AppendChildTo(nsIContent* aKid, PRBool aNotify)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult
 nsDOMAttribute::RemoveChildAt(PRUint32 aIndex, PRBool aNotify)
 {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  if (aIndex != 0 || !mChild) {
+    return NS_OK;
+  }
+
+  nsCOMPtr<nsIContent> child = mChild;
+  nsMutationGuard::DidMutate();
+  mozAutoDocUpdate updateBatch(GetOwnerDoc(), UPDATE_CONTENT_MODEL, aNotify);
+  nsMutationGuard guard;
+
+  mozAutoSubtreeModified subtree(nsnull, nsnull);
+  if (aNotify &&
+      nsContentUtils::HasMutationListeners(mChild,
+                                           NS_EVENT_BITS_MUTATION_NODEREMOVED,
+                                           this)) {
+    mozAutoRemovableBlockerRemover blockerRemover;
+    nsMutationEvent mutation(PR_TRUE, NS_MUTATION_NODEREMOVED);
+    mutation.mRelatedNode =
+      do_QueryInterface(static_cast<nsIAttribute*>(this));
+    subtree.UpdateTarget(GetOwnerDoc(), this);
+    nsEventDispatcher::Dispatch(mChild, nsnull, &mutation);
+  }
+  if (guard.Mutated(0) && mChild != child) {
+    return NS_OK;
+  }
+  mChild = nsnull;
+  static_cast<nsTextNode*>(child.get())->UnbindFromAttribute();
+
+  nsString nullString;
+  SetDOMStringToNull(nullString);
+  SetValue(nullString);
+  return NS_OK;
 }
 
 nsresult
 nsDOMAttribute::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
 {
   // We don't support event dispatching to attributes yet.
   aVisitor.mCanHandle = PR_FALSE;
   return NS_OK;
@@ -784,17 +823,17 @@ nsDOMAttribute::EnsureChildState(PRBool 
   nsAutoString value;
   mutableThis->GetValue(value);
 
   if (!mChild && !value.IsEmpty()) {
     nsresult rv = NS_NewTextNode(&mutableThis->mChild,
                                  mNodeInfo->NodeInfoManager());
     NS_ENSURE_SUCCESS(rv, rv);
 
-    // XXX We should be setting |this| as the parent of the textnode!
+    static_cast<nsTextNode*>(mChild)->BindToAttribute(mutableThis);
   }
 
   aHasChild = !value.IsEmpty();
 
   if (aSetText && aHasChild) {
     mChild->SetText(value, PR_TRUE);
   }
 
diff --git a/content/base/src/nsRange.cpp b/content/base/src/nsRange.cpp
--- a/content/base/src/nsRange.cpp
+++ b/content/base/src/nsRange.cpp
@@ -84,29 +84,29 @@ nsresult NS_NewContentSubtreeIterator(ns
 // If outNodeBefore is returned true, then the node starts before the range does.
 // If outNodeAfter is returned true, then the node ends after the range does.
 // Note that both of the above might be true.
 // If neither are true, the node is contained inside of the range.
 // XXX - callers responsibility to ensure node in same doc as range! 
 
 // static
 nsresult
-nsRange::CompareNodeToRange(nsIContent* aNode, nsIDOMRange* aRange,
+nsRange::CompareNodeToRange(nsINode* aNode, nsIDOMRange* aRange,
                             PRBool *outNodeBefore, PRBool *outNodeAfter)
 {
   nsresult rv;
   nsCOMPtr<nsIRange> range = do_QueryInterface(aRange, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return CompareNodeToRange(aNode, range, outNodeBefore, outNodeAfter);
 }
 
 // static
 nsresult
-nsRange::CompareNodeToRange(nsIContent* aNode, nsIRange* aRange,
+nsRange::CompareNodeToRange(nsINode* aNode, nsIRange* aRange,
                             PRBool *outNodeBefore, PRBool *outNodeAfter)
 {
   NS_ENSURE_STATE(aNode);
   // create a pair of dom points that expresses location of node:
   //     NODE(start), NODE(end)
   // Let incoming range be:
   //    {RANGE(start), RANGE(end)}
   // if (RANGE(start) <= NODE(start))  and (RANGE(end) => NODE(end))
@@ -124,19 +124,16 @@ nsRange::CompareNodeToRange(nsIContent* 
   nsINode* parent = aNode->GetNodeParent();
   if (!parent) {
     // can't make a parent/offset pair to represent start or 
     // end of the root node, becasue it has no parent.
     // so instead represent it by (node,0) and (node,numChildren)
     parent = aNode;
     nodeStart = 0;
     nodeEnd = aNode->GetChildCount();
-    if (!nodeEnd) {
-      return NS_ERROR_FAILURE;
-    }
   }
   else {
     nodeStart = parent->IndexOf(aNode);
     nodeEnd = nodeStart + 1;
   }
 
   nsINode* rangeStartParent = range->GetStartParent();
   nsINode* rangeEndParent = range->GetEndParent();
@@ -896,20 +893,20 @@ RangeSubtreeIterator::GetCurrentNode()
   nsIDOMNode *node = nsnull;
 
   if (mIterState == eUseStartCData && mStartCData) {
     NS_ADDREF(node = mStartCData);
   } else if (mIterState == eUseEndCData && mEndCData)
     NS_ADDREF(node = mEndCData);
   else if (mIterState == eUseIterator && mIter)
   {
-    nsIContent *content = mIter->GetCurrentNode();
+    nsINode* n = mIter->GetCurrentNode();
 
-    if (content) {
-      CallQueryInterface(content, &node);
+    if (n) {
+      CallQueryInterface(n, &node);
     }
   }
 
   return node;
 }
 
 void
 RangeSubtreeIterator::First()
@@ -1838,43 +1835,44 @@ nsresult nsRange::ToString(nsAString& aR
     }
   } 
   
   /* complex case: mStartParent != mEndParent, or mStartParent not a text node
      revisit - there are potential optimizations here and also tradeoffs.
   */
 
   nsCOMPtr<nsIContentIterator> iter;
-  NS_NewContentIterator(getter_AddRefs(iter));
-  nsresult rv = iter->Init(this);
+  nsresult rv = NS_NewContentIterator(getter_AddRefs(iter));
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = iter->Init(this);
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsString tempString;
  
   // loop through the content iterator, which returns nodes in the range in 
   // close tag order, and grab the text from any text node
   while (!iter->IsDone())
   {
-    nsIContent *cN = iter->GetCurrentNode();
+    nsINode *n = iter->GetCurrentNode();
 
 #ifdef DEBUG_range
     // If debug, dump it:
-    cN->List(stdout);
+    n->List(stdout);
 #endif /* DEBUG */
-    nsCOMPtr<nsIDOMText> textNode( do_QueryInterface(cN) );
+    nsCOMPtr<nsIDOMText> textNode(do_QueryInterface(n));
     if (textNode) // if it's a text node, get the text
     {
-      if (cN == mStartParent) // only include text past start offset
+      if (n == mStartParent) // only include text past start offset
       {
         PRUint32 strLength;
         textNode->GetLength(&strLength);
         textNode->SubstringData(mStartOffset,strLength-mStartOffset,tempString);
         aReturn += tempString;
       }
-      else if (cN == mEndParent)  // only include text before end offset
+      else if (n == mEndParent)  // only include text before end offset
       {
         textNode->SubstringData(0,mEndOffset,tempString);
         aReturn += tempString;
       }
       else  // grab the whole kit-n-kaboodle
       {
         textNode->GetData(tempString);
         aReturn += tempString;
diff --git a/content/base/src/nsRange.h b/content/base/src/nsRange.h
--- a/content/base/src/nsRange.h
+++ b/content/base/src/nsRange.h
@@ -131,20 +131,20 @@ public:
 public:
 /******************************************************************************
  *  Utility routine to detect if a content node starts before a range and/or 
  *  ends after a range.  If neither it is contained inside the range.
  *  
  *  XXX - callers responsibility to ensure node in same doc as range!
  *
  *****************************************************************************/
-  static nsresult CompareNodeToRange(nsIContent* aNode, nsIDOMRange* aRange,
+  static nsresult CompareNodeToRange(nsINode* aNode, nsIDOMRange* aRange,
                                      PRBool *outNodeBefore,
                                      PRBool *outNodeAfter);
-  static nsresult CompareNodeToRange(nsIContent* aNode, nsIRange* aRange,
+  static nsresult CompareNodeToRange(nsINode* aNode, nsIRange* aRange,
                                      PRBool *outNodeBefore,
                                      PRBool *outNodeAfter);
 
 protected:
   void DoSetRange(nsINode* aStartN, PRInt32 aStartOffset,
                   nsINode* aEndN, PRInt32 aEndOffset,
                   nsINode* aRoot);
 };
diff --git a/content/base/src/nsTextNode.cpp b/content/base/src/nsTextNode.cpp
--- a/content/base/src/nsTextNode.cpp
+++ b/content/base/src/nsTextNode.cpp
@@ -34,56 +34,26 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /*
  * Implementation of DOM Core's nsIDOMText node.
  */
 
-#include "nsGenericDOMDataNode.h"
-#include "nsIDOMText.h"
+#include "nsTextNode.h"
 #include "nsIDOM3Text.h"
 #include "nsContentUtils.h"
 #include "nsIDOMEventListener.h"
 #include "nsIDOMEventTarget.h"
 #include "nsIDOMMutationEvent.h"
 #include "nsIAttribute.h"
 #include "nsIDocument.h"
 #include "nsThreadUtils.h"
 
-/**
- * Class used to implement DOM text nodes
- */
-class nsTextNode : public nsGenericDOMDataNode,
-                   public nsIDOMText
-{
-public:
-  nsTextNode(nsINodeInfo *aNodeInfo);
-  virtual ~nsTextNode();
-
-  // nsISupports
-  NS_DECL_ISUPPORTS_INHERITED
-
-  // nsIDOMNode
-  NS_IMPL_NSIDOMNODE_USING_GENERIC_DOM_DATA
-
-  // nsIDOMCharacterData
-  NS_FORWARD_NSIDOMCHARACTERDATA(nsGenericDOMDataNode::)
-
-  // nsIDOMText
-  NS_FORWARD_NSIDOMTEXT(nsGenericDOMDataNode::)
-
-  // nsIContent
-  virtual PRBool IsNodeOfType(PRUint32 aFlags) const;
-#ifdef DEBUG
-  virtual void List(FILE* out, PRInt32 aIndent) const;
-  virtual void DumpContent(FILE* out, PRInt32 aIndent, PRBool aDumpAll) const;
-#endif
-};
 
 /**
  * class used to implement attr() generated content
  */
 class nsAttributeTextNode : public nsTextNode,
                             public nsStubMutationObserver
 {
 public:
@@ -226,16 +196,38 @@ nsTextNode::CloneDataNode(nsINodeInfo *a
 nsTextNode::CloneDataNode(nsINodeInfo *aNodeInfo, PRBool aCloneText) const
 {
   nsTextNode *it = new nsTextNode(aNodeInfo);
   if (it && aCloneText) {
     it->mText = mText;
   }
 
   return it;
+}
+
+nsresult
+nsTextNode::BindToAttribute(nsIAttribute* aAttr)
+{
+  NS_ASSERTION(!IsInDoc(), "Unbind before binding!");
+  NS_ASSERTION(!GetNodeParent(), "Unbind before binding!");
+  NS_ASSERTION(HasSameOwnerDoc(aAttr), "Wrong owner document!");
+
+  mParentPtrBits = reinterpret_cast<PtrBits>(aAttr);
+  return NS_OK;
+}
+
+nsresult
+nsTextNode::UnbindFromAttribute()
+{
+  NS_ASSERTION(GetNodeParent(), "Bind before unbinging!");
+  NS_ASSERTION(GetNodeParent() &&
+               GetNodeParent()->IsNodeOfType(nsINode::eATTRIBUTE),
+               "Use this method only to unbind from an attribute!");
+  mParentPtrBits = 0;
+  return NS_OK;
 }
 
 #ifdef DEBUG
 void
 nsTextNode::List(FILE* out, PRInt32 aIndent) const
 {
   PRInt32 index;
   for (index = aIndent; --index >= 0; ) fputs("  ", out);
diff --git a/content/base/src/nsTextNode.h b/content/base/src/nsTextNode.h
new file mode 100644
--- /dev/null
+++ b/content/base/src/nsTextNode.h
@@ -0,0 +1,85 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * Implementation of DOM Core's nsIDOMText node.
+ */
+
+#include "nsGenericDOMDataNode.h"
+#include "nsIDOMText.h"
+#include "nsIDOM3Text.h"
+#include "nsContentUtils.h"
+#include "nsIDOMEventListener.h"
+#include "nsIDOMEventTarget.h"
+#include "nsIDOMMutationEvent.h"
+#include "nsIAttribute.h"
+#include "nsIDocument.h"
+#include "nsThreadUtils.h"
+
+/**
+ * Class used to implement DOM text nodes
+ */
+class nsTextNode : public nsGenericDOMDataNode,
+                   public nsIDOMText
+{
+public:
+  nsTextNode(nsINodeInfo *aNodeInfo);
+  virtual ~nsTextNode();
+
+  // nsISupports
+  NS_DECL_ISUPPORTS_INHERITED
+
+  // nsIDOMNode
+  NS_IMPL_NSIDOMNODE_USING_GENERIC_DOM_DATA
+
+  // nsIDOMCharacterData
+  NS_FORWARD_NSIDOMCHARACTERDATA(nsGenericDOMDataNode::)
+
+  // nsIDOMText
+  NS_FORWARD_NSIDOMTEXT(nsGenericDOMDataNode::)
+
+  // nsIContent
+  virtual PRBool IsNodeOfType(PRUint32 aFlags) const;
+
+  nsresult BindToAttribute(nsIAttribute* aAttr);
+  nsresult UnbindFromAttribute();
+
+#ifdef DEBUG
+  virtual void List(FILE* out, PRInt32 aIndent) const;
+  virtual void DumpContent(FILE* out, PRInt32 aIndent, PRBool aDumpAll) const;
+#endif
+};
diff --git a/content/events/src/nsQueryContentEventHandler.cpp b/content/events/src/nsQueryContentEventHandler.cpp
--- a/content/events/src/nsQueryContentEventHandler.cpp
+++ b/content/events/src/nsQueryContentEventHandler.cpp
@@ -203,17 +203,17 @@ nsQueryContentEventHandler::GenerateFlat
     AppendSubString(aString, content, aRange->StartOffset(),
                     aRange->EndOffset() - aRange->StartOffset());
     ConvertToNativeNewlines(aString);
     return NS_OK;
   }
 
   nsAutoString tmpStr;
   for (; !iter->IsDone(); iter->Next()) {
-    nsIContent* content = iter->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
     if (!content)
       continue;
 
     if (content->IsNodeOfType(nsINode::eTEXT)) {
       if (content == startNode)
         AppendSubString(aString, content, aRange->StartOffset(),
                         content->TextLength() - aRange->StartOffset());
       else if (content == endNode)
@@ -284,19 +284,19 @@ nsQueryContentEventHandler::SetRangeFrom
   NS_ASSERTION(iter, "NS_NewContentIterator succeeded, but the result is null");
   rv = iter->Init(mRootContent);
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDOMRange> domRange(do_QueryInterface(aRange));
   NS_ASSERTION(domRange, "aRange doesn't have nsIDOMRange!");
 
   PRUint32 nativeOffset = 0;
   PRUint32 nativeEndOffset = aNativeOffset + aNativeLength;
-  nsIContent* content = nsnull;
+  nsCOMPtr<nsIContent> content;
   for (; !iter->IsDone(); iter->Next()) {
-    content = iter->GetCurrentNode();
+    content = do_QueryInterface(iter->GetCurrentNode());
     if (!content)
       continue;
 
     PRUint32 nativeTextLength;
     nativeTextLength = GetNativeTextLength(content);
     if (nativeTextLength == 0)
       continue;
 
diff --git a/editor/libeditor/html/nsHTMLEditor.cpp b/editor/libeditor/html/nsHTMLEditor.cpp
--- a/editor/libeditor/html/nsHTMLEditor.cpp
+++ b/editor/libeditor/html/nsHTMLEditor.cpp
@@ -847,17 +847,18 @@ nsHTMLEditor::GetBlockSectionsForRange(n
   nsCOMPtr<nsIContentIterator>iter =
     do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &result);
   if ((NS_SUCCEEDED(result)) && iter)
   {
     nsCOMPtr<nsIDOMRange> lastRange;
     iter->Init(aRange);
     while (iter->IsDone())
     {
-      nsCOMPtr<nsIContent> currentContent = iter->GetCurrentNode();
+      nsCOMPtr<nsIContent> currentContent =
+        do_QueryInterface(iter->GetCurrentNode());
 
       nsCOMPtr<nsIDOMNode>currentNode = do_QueryInterface(currentContent);
       if (currentNode)
       {
         // <BR> divides block content ranges.  We can achieve this by nulling out lastRange
         if (currentContent->Tag() == nsEditProperty::br)
         {
           lastRange = nsnull;
@@ -3839,17 +3840,17 @@ nsHTMLEditor::GetEmbeddedObjects(nsISupp
     if (!doc)
       return NS_ERROR_UNEXPECTED;
 
     iter->Init(doc->GetRootContent());
 
     // loop through the content iterator for each content node
     while (!iter->IsDone())
     {
-      nsIContent *content = iter->GetCurrentNode();
+      nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
       nsCOMPtr<nsIDOMNode> node (do_QueryInterface(content));
       if (node)
       {
         nsAutoString tagName;
         node->GetNodeName(tagName);
         ToLowerCase(tagName);
 
         // See if it's an image or an embed and also include all links.
@@ -4545,17 +4546,17 @@ nsHTMLEditor::CollapseAdjacentTextNodes(
   nsCOMPtr<nsIContentIterator> iter =
     do_CreateInstance("@mozilla.org/content/subtree-content-iterator;1", &result);
   if (NS_FAILED(result)) return result;
 
   iter->Init(aInRange);
 
   while (!iter->IsDone())
   {
-    nsIContent *content = iter->GetCurrentNode();  
+    nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
     nsCOMPtr<nsIDOMCharacterData> text = do_QueryInterface(content);
     nsCOMPtr<nsIDOMNode>          node = do_QueryInterface(content);
     if (text && node && IsEditable(node))
     {
       textNodes.AppendElement(node.get());
     }
 
diff --git a/editor/libeditor/html/nsHTMLEditorStyle.cpp b/editor/libeditor/html/nsHTMLEditorStyle.cpp
--- a/editor/libeditor/html/nsHTMLEditorStyle.cpp
+++ b/editor/libeditor/html/nsHTMLEditorStyle.cpp
@@ -1100,17 +1100,17 @@ nsHTMLEditor::GetInlinePropertyBase(nsIA
     nsCOMPtr<nsIDOMNode> endNode;
     PRInt32 endOffset;
     result = range->GetEndContainer(getter_AddRefs(endNode));
     if (NS_FAILED(result)) return result;
     result = range->GetEndOffset(&endOffset);
     if (NS_FAILED(result)) return result;
     while (!iter->IsDone())
     {
-      nsIContent *content = iter->GetCurrentNode();
+      nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
       nsCOMPtr<nsIDOMNode> node = do_QueryInterface(content);
 
       if (node && nsTextEditUtils::IsBody(node))
         break;
 
       nsCOMPtr<nsIDOMCharacterData>text;
       text = do_QueryInterface(content);
diff --git a/editor/txtsvc/src/nsFilteredContentIterator.cpp b/editor/txtsvc/src/nsFilteredContentIterator.cpp
--- a/editor/txtsvc/src/nsFilteredContentIterator.cpp
+++ b/editor/txtsvc/src/nsFilteredContentIterator.cpp
@@ -63,17 +63,17 @@ nsFilteredContentIterator::~nsFilteredCo
 {
 }
 
 //------------------------------------------------------------
 NS_IMPL_ISUPPORTS1(nsFilteredContentIterator, nsIContentIterator)
 
 //------------------------------------------------------------
 nsresult
-nsFilteredContentIterator::Init(nsIContent* aRoot)
+nsFilteredContentIterator::Init(nsINode* aRoot)
 {
   NS_ENSURE_TRUE(mPreIterator, NS_ERROR_FAILURE);
   NS_ENSURE_TRUE(mIterator, NS_ERROR_FAILURE);
   mIsOutOfRange    = PR_FALSE;
   mDirection       = eForward;
   mCurrentIterator = mPreIterator;
 
   nsresult rv;
@@ -110,17 +110,17 @@ nsFilteredContentIterator::Init(nsIDOMRa
   NS_ENSURE_SUCCESS(rv, rv);
   return mIterator->Init(domRange);
 }
 
 //------------------------------------------------------------
 nsresult 
 nsFilteredContentIterator::SwitchDirections(PRPackedBool aChangeToForward)
 {
-  nsIContent *node = mCurrentIterator->GetCurrentNode();
+  nsINode *node = mCurrentIterator->GetCurrentNode();
 
   if (aChangeToForward) {
     mCurrentIterator = mPreIterator;
     mDirection       = eForward;
   } else {
     mCurrentIterator = mIterator;
     mDirection       = eBackward;
   }
@@ -154,18 +154,18 @@ nsFilteredContentIterator::First()
   }
 
   mCurrentIterator->First();
 
   if (mCurrentIterator->IsDone()) {
     return;
   }
 
-  nsIContent *currentContent = mCurrentIterator->GetCurrentNode();
-  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentContent));
+  nsINode *currentNode = mCurrentIterator->GetCurrentNode();
+  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentNode));
 
   PRPackedBool didCross;
   CheckAdvNode(node, didCross, eForward);
 }
 
 //------------------------------------------------------------
 void
 nsFilteredContentIterator::Last()
@@ -185,18 +185,18 @@ nsFilteredContentIterator::Last()
   }
 
   mCurrentIterator->Last();
 
   if (mCurrentIterator->IsDone()) {
     return;
   }
 
-  nsIContent *currentContent = mCurrentIterator->GetCurrentNode();
-  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentContent));
+  nsINode *currentNode = mCurrentIterator->GetCurrentNode();
+  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentNode));
 
   PRPackedBool didCross;
   CheckAdvNode(node, didCross, eBackward);
 }
 
 ///////////////////////////////////////////////////////////////////////////
 // ContentToParentOffset: returns the content node's parent and offset.
 //
@@ -379,19 +379,19 @@ nsFilteredContentIterator::Next()
   mCurrentIterator->Next();
 
   if (mCurrentIterator->IsDone()) {
     return;
   }
 
   // If we can't get the current node then 
   // don't check to see if we can skip it
-  nsIContent *currentContent = mCurrentIterator->GetCurrentNode();
+  nsINode *currentNode = mCurrentIterator->GetCurrentNode();
 
-  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentContent));
+  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentNode));
   CheckAdvNode(node, mDidSkip, eForward);
 }
 
 void
 nsFilteredContentIterator::Prev()
 {
   if (mIsOutOfRange || !mCurrentIterator) {
     NS_ASSERTION(mCurrentIterator, "Missing iterator!");
@@ -411,23 +411,23 @@ nsFilteredContentIterator::Prev()
   mCurrentIterator->Prev();
 
   if (mCurrentIterator->IsDone()) {
     return;
   }
 
   // If we can't get the current node then 
   // don't check to see if we can skip it
-  nsIContent *currentContent = mCurrentIterator->GetCurrentNode();
+  nsINode *currentNode = mCurrentIterator->GetCurrentNode();
 
-  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentContent));
+  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(currentNode));
   CheckAdvNode(node, mDidSkip, eBackward);
 }
 
-nsIContent *
+nsINode *
 nsFilteredContentIterator::GetCurrentNode()
 {
   if (mIsOutOfRange || !mCurrentIterator) {
     return nsnull;
   }
 
   return mCurrentIterator->GetCurrentNode();
 }
@@ -438,14 +438,14 @@ nsFilteredContentIterator::IsDone()
   if (mIsOutOfRange || !mCurrentIterator) {
     return PR_TRUE;
   }
 
   return mCurrentIterator->IsDone();
 }
 
 nsresult
-nsFilteredContentIterator::PositionAt(nsIContent* aCurNode)
+nsFilteredContentIterator::PositionAt(nsINode* aCurNode)
 {
   NS_ENSURE_TRUE(mCurrentIterator, NS_ERROR_FAILURE);
   mIsOutOfRange = PR_FALSE;
   return mCurrentIterator->PositionAt(aCurNode);
 }
diff --git a/editor/txtsvc/src/nsFilteredContentIterator.h b/editor/txtsvc/src/nsFilteredContentIterator.h
--- a/editor/txtsvc/src/nsFilteredContentIterator.h
+++ b/editor/txtsvc/src/nsFilteredContentIterator.h
@@ -55,25 +55,25 @@ public:
   // nsISupports interface...
   NS_DECL_ISUPPORTS
 
   nsFilteredContentIterator(nsITextServicesFilter* aFilter);
 
   virtual ~nsFilteredContentIterator();
 
   /* nsIContentIterator */
-  virtual nsresult Init(nsIContent* aRoot);
+  virtual nsresult Init(nsINode* aRoot);
   virtual nsresult Init(nsIDOMRange* aRange);
   virtual void First();
   virtual void Last();
   virtual void Next();
   virtual void Prev();
-  virtual nsIContent *GetCurrentNode();
+  virtual nsINode *GetCurrentNode();
   virtual PRBool IsDone();
-  virtual nsresult PositionAt(nsIContent* aCurNode);
+  virtual nsresult PositionAt(nsINode* aCurNode);
 
   /* Helpers */
   PRPackedBool DidSkip()      { return mDidSkip; }
   void         ClearDidSkip() {  mDidSkip = PR_FALSE; }
 
 protected:
   nsFilteredContentIterator() { }
 
diff --git a/editor/txtsvc/src/nsTextServicesDocument.cpp b/editor/txtsvc/src/nsTextServicesDocument.cpp
--- a/editor/txtsvc/src/nsTextServicesDocument.cpp
+++ b/editor/txtsvc/src/nsTextServicesDocument.cpp
@@ -412,48 +412,48 @@ nsTextServicesDocument::ExpandRangeToWor
   NS_ENSURE_SUCCESS(result, result);
 
   if (iterStatus == nsTextServicesDocument::eIsDone)
   {
     // No text was found so there's no adjustment necessary!
     return NS_OK;
   }
 
-  nsIContent *firstTextContent = iter->GetCurrentNode();
-  NS_ENSURE_TRUE(firstTextContent, NS_ERROR_FAILURE);
+  nsINode *firstText = iter->GetCurrentNode();
+  NS_ENSURE_TRUE(firstText, NS_ERROR_FAILURE);
 
   // Find the last text node in the range.
 
   result = LastTextNode(iter, &iterStatus);
   NS_ENSURE_SUCCESS(result, result);
 
   if (iterStatus == nsTextServicesDocument::eIsDone)
   {
     // We should never get here because a first text block
     // was found above.
     NS_ASSERTION(PR_FALSE, "Found a first without a last!");
     return NS_ERROR_FAILURE;
   }
 
-  nsIContent *lastTextContent = iter->GetCurrentNode();
-  NS_ENSURE_TRUE(lastTextContent, NS_ERROR_FAILURE);
+  nsINode *lastText = iter->GetCurrentNode();
+  NS_ENSURE_TRUE(lastText, NS_ERROR_FAILURE);
 
   // Now make sure our end points are in terms of text nodes in the range!
 
-  nsCOMPtr<nsIDOMNode> firstTextNode = do_QueryInterface(firstTextContent);
+  nsCOMPtr<nsIDOMNode> firstTextNode = do_QueryInterface(firstText);
   NS_ENSURE_TRUE(firstTextNode, NS_ERROR_FAILURE);
 
   if (rngStartNode != firstTextNode)
   {
     // The range includes the start of the first text node!
     rngStartNode = firstTextNode;
     rngStartOffset = 0;
   }
 
-  nsCOMPtr<nsIDOMNode> lastTextNode = do_QueryInterface(lastTextContent);
+  nsCOMPtr<nsIDOMNode> lastTextNode = do_QueryInterface(lastText);
   NS_ENSURE_TRUE(lastTextNode, NS_ERROR_FAILURE);
 
   if (rngEndNode != lastTextNode)
   {
     // The range includes the end of the last text node!
     rngEndNode = lastTextNode;
     nsAutoString str;
     result = lastTextNode->GetNodeValue(str);
@@ -465,17 +465,17 @@ nsTextServicesDocument::ExpandRangeToWor
 
   nsCOMPtr<nsIContentIterator> docIter;
   result = CreateDocumentContentIterator(getter_AddRefs(docIter));
   NS_ENSURE_SUCCESS(result, result);
 
   // Grab all the text in the block containing our
   // first text node.
 
-  result = docIter->PositionAt(firstTextContent);
+  result = docIter->PositionAt(firstText);
   NS_ENSURE_SUCCESS(result, result);
 
   iterStatus = nsTextServicesDocument::eValid;
 
   nsVoidArray offsetTable;
   nsAutoString blockStr;
 
   result = CreateOffsetTable(&offsetTable, docIter, &iterStatus,
@@ -499,17 +499,17 @@ nsTextServicesDocument::ExpandRangeToWor
   NS_ENSURE_SUCCESS(result, result);
 
   rngStartNode = wordStartNode;
   rngStartOffset = wordStartOffset;
 
   // Grab all the text in the block containing our
   // last text node.
 
-  result = docIter->PositionAt(lastTextContent);
+  result = docIter->PositionAt(lastText);
   NS_ENSURE_SUCCESS(result, result);
 
   iterStatus = nsTextServicesDocument::eValid;
 
   result = CreateOffsetTable(&offsetTable, docIter, &iterStatus,
                              nsnull, &blockStr);
   if (NS_FAILED(result))
   {
@@ -854,20 +854,20 @@ nsTextServicesDocument::FirstSelectedBlo
       if (NS_FAILED(result))
       {
         UNLOCK_DOC(this);
         return result;
       }
 
       iter->Last();
 
-      nsIContent *content = nsnull;
+      nsCOMPtr<nsIContent> content;
       while (!iter->IsDone())
       {
-        content = iter->GetCurrentNode();
+        content = do_QueryInterface(iter->GetCurrentNode());
 
         if (IsTextNode(content))
           break;
 
         content = nsnull;
 
         iter->Prev();
       }
@@ -967,17 +967,17 @@ nsTextServicesDocument::FirstSelectedBlo
     }
 
     iter->First();
 
     // Now walk through the range till we find a text node.
 
     while (!iter->IsDone())
     {
-      nsIContent *content = iter->GetCurrentNode();
+      nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
       if (IsTextNode(content))
       {
         // We found a text node, so position the document's
         // iterator at the beginning of the block, then get
         // the selection in terms of the string offset.
 
         result = mIterator->PositionAt(content);
@@ -1092,17 +1092,17 @@ nsTextServicesDocument::FirstSelectedBlo
     UNLOCK_DOC(this);
     return result;
   }
 
   iter->Last();
 
   while (!iter->IsDone())
   {
-    nsIContent *content = iter->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       // We found a text node! Adjust the document's iterator to point
       // to the beginning of it's text block, then get the current selection.
 
       result = mIterator->PositionAt(content);
 
@@ -1332,20 +1332,20 @@ nsTextServicesDocument::LastSelectedBloc
       if (NS_FAILED(result))
       {
         UNLOCK_DOC(this);
         return result;
       }
 
       iter->First();
 
-      nsIContent *content = nsnull;
+      nsCOMPtr<nsIContent> content;
       while (!iter->IsDone())
       {
-        content = iter->GetCurrentNode();
+        content = do_QueryInterface(iter->GetCurrentNode());
 
         if (IsTextNode(content))
           break;
 
         content = nsnull;
 
         iter->Next();
       }
@@ -1445,17 +1445,17 @@ nsTextServicesDocument::LastSelectedBloc
     }
 
     iter->Last();
 
     // Now walk through the range till we find a text node.
 
     while (!iter->IsDone())
     {
-      nsIContent *content = iter->GetCurrentNode();
+      nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
       if (IsTextNode(content))
       {
         // We found a text node, so position the document's
         // iterator at the beginning of the block, then get
         // the selection in terms of the string offset.
 
         result = mIterator->PositionAt(content);
@@ -1570,17 +1570,17 @@ nsTextServicesDocument::LastSelectedBloc
     UNLOCK_DOC(this);
     return result;
   }
 
   iter->First();
 
   while (!iter->IsDone())
   {
-    nsIContent *content = iter->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       // We found a text node! Adjust the document's iterator to point
       // to the beginning of it's text block, then get the current selection.
 
       result = mIterator->PositionAt(content);
 
@@ -2040,25 +2040,25 @@ nsTextServicesDocument::DeleteSelection(
       return result;
     }
 
     if (origStartNode != curStartNode || origEndNode != curEndNode)
     {
       // The range has changed, so we need to create a new content
       // iterator based on the new range.
 
-      nsIContent *curContent = nsnull;
+      nsCOMPtr<nsIContent> curContent;
 
       if (mIteratorStatus != nsTextServicesDocument::eIsDone)
       {
         // The old iterator is still pointing to something valid,
         // so get it's current node so we can restore it after we
         // create the new iterator!
 
-        curContent = mIterator->GetCurrentNode();
+        curContent = do_QueryInterface(mIterator->GetCurrentNode());
       }
 
       // Create the new iterator.
 
       result = CreateContentIterator(mExtent, getter_AddRefs(mIterator));
 
       if (NS_FAILED(result))
       {
@@ -3590,17 +3590,17 @@ nsTextServicesDocument::GetCollapsedSele
   }
 
   // Now iterate to the left, towards the beginning of
   // the text block, to find the first text node you
   // come across.
 
   while (!iter->IsDone())
   {
-    nsIContent *content = iter->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       node = do_QueryInterface(content);
 
       if (!node)
         return NS_ERROR_FAILURE;
 
@@ -3639,17 +3639,17 @@ nsTextServicesDocument::GetCollapsedSele
       result = iter->PositionAt(content);
 
       if (NS_FAILED(result))
         return result;
     }
 
     while (!iter->IsDone())
     {
-      nsIContent *content = iter->GetCurrentNode();
+      nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
       if (IsTextNode(content))
       {
         node = do_QueryInterface(content);
 
         if (!node)
           return NS_ERROR_FAILURE;
 
@@ -3878,27 +3878,27 @@ nsTextServicesDocument::GetUncollapsedSe
   result = CreateContentIterator(range, getter_AddRefs(iter));
 
   if (NS_FAILED(result))
     return result;
 
   // Find the first text node in the range.
   
   PRBool found;
-  nsIContent *content;
+  nsCOMPtr<nsIContent> content;
 
   iter->First();
 
   if (!IsTextNode(p1))
   {
     found = PR_FALSE;
 
     while (!iter->IsDone())
     {
-      content = iter->GetCurrentNode();
+      content = do_QueryInterface(iter->GetCurrentNode());
 
       if (IsTextNode(content))
       {
         p1 = do_QueryInterface(content);
 
         if (!p1)
           return NS_ERROR_FAILURE;
 
@@ -3920,17 +3920,17 @@ nsTextServicesDocument::GetUncollapsedSe
   iter->Last();
 
   if (! IsTextNode(p2))
   {
     found = PR_FALSE;
 
     while (!iter->IsDone())
     {
-      content = iter->GetCurrentNode();
+      content = do_QueryInterface(iter->GetCurrentNode());
 
       if (IsTextNode(content))
       {
         p2 = do_QueryInterface(content);
 
         if (!p2)
           return NS_ERROR_FAILURE;
 
@@ -4116,17 +4116,17 @@ nsTextServicesDocument::FirstTextNode(ns
 {
   if (aIteratorStatus)
     *aIteratorStatus = nsTextServicesDocument::eIsDone;
 
   aIterator->First();
 
   while (!aIterator->IsDone())
   {
-    nsIContent *content = aIterator->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(aIterator->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       if (aIteratorStatus)
         *aIteratorStatus = nsTextServicesDocument::eValid;
       break;
     }
 
@@ -4142,17 +4142,17 @@ nsTextServicesDocument::LastTextNode(nsI
 {
   if (aIteratorStatus)
     *aIteratorStatus = nsTextServicesDocument::eIsDone;
 
   aIterator->Last();
 
   while (!aIterator->IsDone())
   {
-    nsIContent *content = aIterator->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(aIterator->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       if (aIteratorStatus)
         *aIteratorStatus = nsTextServicesDocument::eValid;
       break;
     }
 
@@ -4172,17 +4172,17 @@ nsTextServicesDocument::FirstTextNodeInC
 
   nsCOMPtr<nsIContent> last;
 
   // Walk backwards over adjacent text nodes until
   // we hit a block boundary:
 
   while (!iter->IsDone())
   {
-    nsIContent *content = iter->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       if (!last || HasSameBlockNodeParent(content, last))
         last = content;
       else
       {
         // We're done, the current text node is in a
@@ -4246,17 +4246,17 @@ nsTextServicesDocument::FirstTextNodeInN
 
   if (!aIterator)
     return NS_ERROR_NULL_POINTER;
 
   ClearDidSkip(aIterator);
 
   while (!aIterator->IsDone())
   {
-    nsIContent *content = aIterator->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(aIterator->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       if (!crossedBlockBoundary && (!prev || HasSameBlockNodeParent(prev, content)))
         prev = content;
       else
         break;
     }
@@ -4280,30 +4280,31 @@ nsTextServicesDocument::GetFirstTextNode
   if (!aContent)
     return NS_ERROR_NULL_POINTER;
 
   *aContent = 0;
 
   // Save the iterator's current content node so we can restore
   // it when we are done:
 
-  nsIContent *content = mIterator->GetCurrentNode();
+  nsCOMPtr<nsIContent> content = do_QueryInterface(mIterator->GetCurrentNode());
 
   result = FirstTextNodeInPrevBlock(mIterator);
 
   if (NS_FAILED(result))
   {
     // Try to restore the iterator before returning.
     mIterator->PositionAt(content);
     return result;
   }
 
   if (!mIterator->IsDone())
   {
-    NS_ADDREF(*aContent = mIterator->GetCurrentNode());
+    nsCOMPtr<nsIContent> current = do_QueryInterface(mIterator->GetCurrentNode());
+    current.swap(*aContent);
   }
 
   // Restore the iterator:
 
   return mIterator->PositionAt(content);
 }
 
 nsresult
@@ -4314,30 +4315,31 @@ nsTextServicesDocument::GetFirstTextNode
   if (!aContent)
     return NS_ERROR_NULL_POINTER;
 
   *aContent = 0;
 
   // Save the iterator's current content node so we can restore
   // it when we are done:
 
-  nsIContent *content = mIterator->GetCurrentNode();
+  nsCOMPtr<nsIContent> content = do_QueryInterface(mIterator->GetCurrentNode());
 
   result = FirstTextNodeInNextBlock(mIterator);
 
   if (NS_FAILED(result))
   {
     // Try to restore the iterator before returning.
     mIterator->PositionAt(content);
     return result;
   }
 
   if (!mIterator->IsDone())
   {
-    NS_ADDREF(*aContent = mIterator->GetCurrentNode());
+    nsCOMPtr<nsIContent> current = do_QueryInterface(mIterator->GetCurrentNode());
+    current.swap(*aContent);
   }
 
   // Restore the iterator:
   return mIterator->PositionAt(content);
 }
 
 nsresult
 nsTextServicesDocument::CreateOffsetTable(nsVoidArray *aOffsetTable,
@@ -4388,17 +4390,17 @@ nsTextServicesDocument::CreateOffsetTabl
     return result;
 
   PRInt32 offset = 0;
 
   ClearDidSkip(aIterator);
 
   while (!aIterator->IsDone())
   {
-    nsIContent *content = aIterator->GetCurrentNode();
+    nsCOMPtr<nsIContent> content = do_QueryInterface(aIterator->GetCurrentNode());
 
     if (IsTextNode(content))
     {
       if (!prev || HasSameBlockNodeParent(prev, content))
       {
         nsCOMPtr<nsIDOMNode> node = do_QueryInterface(content);
 
         if (node)
diff --git a/embedding/components/find/src/nsFind.cpp b/embedding/components/find/src/nsFind.cpp
--- a/embedding/components/find/src/nsFind.cpp
+++ b/embedding/components/find/src/nsFind.cpp
@@ -117,36 +117,36 @@ public:
   virtual ~nsFindContentIterator()
   {
   }
 
   // nsISupports
   NS_DECL_ISUPPORTS
 
   // nsIContentIterator
-  virtual nsresult Init(nsIContent* aRoot)
+  virtual nsresult Init(nsINode* aRoot)
   {
     NS_NOTREACHED("internal error");
     return NS_ERROR_NOT_IMPLEMENTED;
   }
   virtual nsresult Init(nsIDOMRange* aRange)
   {
     NS_NOTREACHED("internal error");
     return NS_ERROR_NOT_IMPLEMENTED;
   }
   // Not a range because one of the endpoints may be anonymous.
   nsresult Init(nsIDOMNode* aStartNode, PRInt32 aStartOffset,
                 nsIDOMNode* aEndNode, PRInt32 aEndOffset);
   virtual void First();
   virtual void Last();
   virtual void Next();
   virtual void Prev();
-  virtual nsIContent* GetCurrentNode();
+  virtual nsINode* GetCurrentNode();
   virtual PRBool IsDone();
-  virtual nsresult PositionAt(nsIContent* aCurNode);
+  virtual nsresult PositionAt(nsINode* aCurNode);
 
 private:
   nsCOMPtr<nsIContentIterator> mOuterIterator;
   nsCOMPtr<nsIContentIterator> mInnerIterator;
   // Can't use a range here, since we want to represent part of the
   // flattened tree, including native anonymous content.
   nsCOMPtr<nsIDOMNode> mStartNode;
   PRInt32 mStartOffset;
@@ -232,17 +232,17 @@ nsFindContentIterator::Prev()
     // by construction, mOuterIterator is already on the previous node
   }
   else {
     mOuterIterator->Prev();
   }
   MaybeSetupInnerIterator();
 }
 
-nsIContent*
+nsINode*
 nsFindContentIterator::GetCurrentNode()
 {
   if (mInnerIterator && !mInnerIterator->IsDone()) {
     return mInnerIterator->GetCurrentNode();
   }
   return mOuterIterator->GetCurrentNode();
 }
 
@@ -250,19 +250,19 @@ nsFindContentIterator::IsDone() {
 nsFindContentIterator::IsDone() {
   if (mInnerIterator && !mInnerIterator->IsDone()) {
     return PR_FALSE;
   }
   return mOuterIterator->IsDone();
 }
 
 nsresult
-nsFindContentIterator::PositionAt(nsIContent* aCurNode)
+nsFindContentIterator::PositionAt(nsINode* aCurNode)
 {
-  nsIContent* oldNode = mOuterIterator->GetCurrentNode();
+  nsINode* oldNode = mOuterIterator->GetCurrentNode();
   nsresult rv = mOuterIterator->PositionAt(aCurNode);
   if (NS_SUCCEEDED(rv)) {
     MaybeSetupInnerIterator();
   }
   else {
     mOuterIterator->PositionAt(oldNode);
     if (mInnerIterator)
       rv = mInnerIterator->PositionAt(aCurNode);
@@ -328,17 +328,18 @@ nsFindContentIterator::Reset()
   }
 }
 
 void
 nsFindContentIterator::MaybeSetupInnerIterator()
 {
   mInnerIterator = nsnull;
 
-  nsIContent* content = mOuterIterator->GetCurrentNode();
+  nsCOMPtr<nsIContent> content =
+    do_QueryInterface(mOuterIterator->GetCurrentNode());
   if (!content || !content->IsNodeOfType(nsINode::eHTML_FORM_CONTROL))
     return;
 
   nsCOMPtr<nsIFormControl> formControl(do_QueryInterface(content));
   PRInt32 controlType = formControl->GetType();
   if (controlType != NS_FORM_TEXTAREA && 
       controlType != NS_FORM_INPUT_TEXT)
     return;
@@ -640,17 +641,17 @@ nsFind::SetWordBreaker(nsIWordBreaker* a
 
 nsresult
 nsFind::NextNode(nsIDOMRange* aSearchRange,
                  nsIDOMRange* aStartPoint, nsIDOMRange* aEndPoint,
                  PRBool aContinueOk)
 {
   nsresult rv;
 
-  nsIContent *content = nsnull;
+  nsCOMPtr<nsIContent> content;
 
   if (!mIterator || aContinueOk)
   {
     // If we are continuing, that means we have a match in progress.
     // In that case, we want to continue from the end point
     // (where we are now) to the beginning/end of the search range.
     nsCOMPtr<nsIDOMNode> startNode;
     nsCOMPtr<nsIDOMNode> endNode;
@@ -694,17 +695,17 @@ nsFind::NextNode(nsIDOMRange* aSearchRan
       }
     }
 
     rv = InitIterator(startNode, startOffset, endNode, endOffset);
     NS_ENSURE_SUCCESS(rv, rv);
     if (!aStartPoint)
       aStartPoint = aSearchRange;
 
-    content = mIterator->GetCurrentNode();
+    content = do_QueryInterface(mIterator->GetCurrentNode());
 #ifdef DEBUG_FIND
     nsCOMPtr<nsIDOMNode> dnode (do_QueryInterface(content));
     printf(":::::: Got the first node "); DumpNode(dnode);
 #endif
     if (content && content->IsNodeOfType(nsINode::eTEXT) &&
         !SkipNode(content))
     {
       mIterNode = do_QueryInterface(content);
@@ -734,17 +735,17 @@ nsFind::NextNode(nsIDOMRange* aSearchRan
 
   while (1)
   {
     if (mFindBackward)
       mIterator->Prev();
     else
       mIterator->Next();
 
-    content = mIterator->GetCurrentNode();
+    content = do_QueryInterface(mIterator->GetCurrentNode());
     if (!content)
       break;
 
 #ifdef DEBUG_FIND
     nsCOMPtr<nsIDOMNode> dnode (do_QueryInterface(content));
     printf(":::::: Got another node "); DumpNode(dnode);
 #endif
 
diff --git a/embedding/components/find/src/nsFind.h b/embedding/components/find/src/nsFind.h
--- a/embedding/components/find/src/nsFind.h
+++ b/embedding/components/find/src/nsFind.h
@@ -45,16 +45,17 @@
 #include "nsIDOMNode.h"
 #include "nsIDOMRange.h"
 #include "nsIContentIterator.h"
 #include "nsIParserService.h"
 #include "nsIWordBreaker.h"
 
 class nsIPresShell;
 class nsIAtom;
+class nsIContent;
 
 #define NS_FIND_CONTRACTID "@mozilla.org/embedcomp/rangefind;1"
 
 #define NS_FIND_CID \
  {0x471f4944, 0x1dd2, 0x11b2, {0x87, 0xac, 0x90, 0xbe, 0x0a, 0x51, 0xd6, 0x09}}
 
 class nsFindContentIterator;
 
diff --git a/layout/generic/nsSelection.cpp b/layout/generic/nsSelection.cpp
--- a/layout/generic/nsSelection.cpp
+++ b/layout/generic/nsSelection.cpp
@@ -5070,17 +5070,18 @@ nsTypedSelection::selectFrames(nsPresCon
           return NS_OK;
         }
       }
 #endif //OLD_TABLE_SELECTION
     }
     // Now iterated through the child frames and set them
     while (!aInnerIter->IsDone())
     {
-      nsIContent *innercontent = aInnerIter->GetCurrentNode();
+      nsCOMPtr<nsIContent> innercontent =
+        do_QueryInterface(aInnerIter->GetCurrentNode());
 
       frame = mFrameSelection->GetShell()->GetPrimaryFrameFor(innercontent);
       if (frame)
       {
         //NOTE: eSpreadDown is now IGNORED. Selected state is set only
         //for given frame
 
         //spread from here to hit all frames in flow
@@ -5164,17 +5165,17 @@ nsTypedSelection::selectFrames(nsPresCon
       if (frame)
         frame->SetSelected(aPresContext, aRange, aFlags, eSpreadDown, mType);//spread from here to hit all frames in flow
     }
 //end start content
     iter->First();
 
     while (!iter->IsDone())
     {
-      content = iter->GetCurrentNode();
+      content = do_QueryInterface(iter->GetCurrentNode());
 
       selectFrames(aPresContext, inneriter, content, aRange, presShell,aFlags);
 
       iter->Next();
     }
 //we must now do the last one  if it is not the same as the first
     if (FetchEndParent(aRange) != FetchStartParent(aRange))
     {
