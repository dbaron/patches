From: L. David Baron <dbaron@dbaron.org>

Fix optimized build bustage on Windows from bug 636039, patch 15, by avoiding use of alloca on Windows, at least for now.

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -87,16 +87,24 @@
 #ifdef _MSC_VER
 #define alloca _alloca
 #endif
 #endif
 #ifdef SOLARIS
 #include <alloca.h>
 #endif
 
+#define NSRULENODE_USE_ALLOCA
+
+#ifdef _MSC_VER
+// For now, don't use alloca on MSVC, since the resulting optimized
+// builds crash on startup (but debug builds work fine).
+#undef NSRULENODE_USE_ALLOCA
+#endif
+
 using namespace mozilla::dom;
 namespace css = mozilla::css;
 
 #define NS_SET_IMAGE_REQUEST(method_, context_, request_)                   \
   if ((context_)->PresContext()->IsDynamic()) {                               \
     method_(request_);                                                      \
   } else {                                                                  \
     nsCOMPtr<imgIRequest> req = nsContentUtils::GetStaticRequest(request_); \
@@ -1732,22 +1740,26 @@ private:
   nsCSSValue *mArray;
   size_t mCount;
 };
 
 const void*
 nsRuleNode::WalkRuleTree(const nsStyleStructID aSID,
                          nsStyleContext* aContext)
 {
+  size_t nprops = nsCSSProps::PropertyCountInStruct(aSID);
+#ifdef NSRULENODE_USE_ALLOCA
   // use placement new[] on the result of alloca() to allocate a
   // variable-sized stack array, including execution of constructors,
   // and use an RAII class to run the destructors too.
-  size_t nprops = nsCSSProps::PropertyCountInStruct(aSID);
   void* dataStorage = alloca(nprops * sizeof(nsCSSValue));
   AutoCSSValueArray dataArray(dataStorage, nprops);
+#else
+  nsAutoArrayPtr<nsCSSValue> dataArray(new nsCSSValue[nprops]);
+#endif
 
   nsRuleData ruleData(nsCachedStyleData::GetBitForSID(aSID),
                       dataArray.get(), mPresContext, aContext);
   ruleData.mValueOffsets[aSID] = 0;
 
   // We start at the most specific rule in the tree.
   void* startStruct = nsnull;
 
@@ -2943,25 +2955,31 @@ nsRuleNode::SetGenericFont(nsPresContext
     const nsStyleFont* tmpFont = higherContext->GetStyleFont();
     parentFont = *tmpFont;
   }
   *aFont = parentFont;
 
   PRBool dummy;
   PRUint32 fontBit = nsCachedStyleData::GetBitForSID(eStyleStruct_Font);
 
+  size_t nprops = nsCSSProps::PropertyCountInStruct(eStyleStruct_Font);
+#ifdef NSRULENODE_USE_ALLOCA
   // use placement new[] on the result of alloca() to allocate a
   // variable-sized stack array, including execution of constructors,
   // and use an RAII class to run the destructors too.
-  size_t nprops = nsCSSProps::PropertyCountInStruct(eStyleStruct_Font);
   void* dataStorage = alloca(nprops * sizeof(nsCSSValue));
+#endif
 
   for (PRInt32 i = contextPath.Length() - 1; i >= 0; --i) {
     nsStyleContext* context = contextPath[i];
+#ifdef NSRULENODE_USE_ALLOCA
     AutoCSSValueArray dataArray(dataStorage, nprops);
+#else
+    nsAutoArrayPtr<nsCSSValue> dataArray(new nsCSSValue[nprops]);
+#endif
 
     nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Font), dataArray.get(),
                         aPresContext, context);
     ruleData.mValueOffsets[eStyleStruct_Font] = 0;
 
     // Trimmed down version of ::WalkRuleTree() to re-apply the style rules
     // Note that we *do* need to do this for our own data, since what is
     // in |fontData| in ComputeFontData is only for the rules below
@@ -6510,18 +6528,22 @@ nsRuleNode::HasAuthorSpecifiedRules(nsSt
     nprops += nsCSSProps::PropertyCountInStruct(eStyleStruct_Border);
   }
 
   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_PADDING) {
     paddingOffset = nprops;
     nprops += nsCSSProps::PropertyCountInStruct(eStyleStruct_Padding);
   }
 
+#ifdef NSRULENODE_USE_ALLOCA
   void* dataStorage = alloca(nprops * sizeof(nsCSSValue));
   AutoCSSValueArray dataArray(dataStorage, nprops);
+#else
+  nsAutoArrayPtr<nsCSSValue> dataArray(new nsCSSValue[nprops]);
+#endif
 
   /* We're relying on the use of |aStyleContext| not mutating it! */
   nsRuleData ruleData(inheritBits, dataArray.get(),
                       aStyleContext->PresContext(), aStyleContext);
 
   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BACKGROUND) {
     ruleData.mValueOffsets[eStyleStruct_Background] = backgroundOffset;
   }
