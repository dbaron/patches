From: L. David Baron <dbaron@dbaron.org>

Add a hash set data structure based on nsTHashtable (started as a fork of nsBaseHashtable).

diff --git a/xpcom/glue/Makefile.in b/xpcom/glue/Makefile.in
--- a/xpcom/glue/Makefile.in
+++ b/xpcom/glue/Makefile.in
@@ -80,16 +80,17 @@ SDK_HEADERS = \
 		nsComponentManagerUtils.h \
 		nsCycleCollectionParticipant.h \
 		nsCycleCollectorUtils.h \
 		nsDataHashtable.h \
 		nsDebug.h \
 		nsDeque.h \
 		nsEnumeratorUtils.h \
 		nsHashKeys.h \
+		nsHashSet.h \
 		nsIClassInfoImpl.h \
 		nsID.h \
 		nsIInterfaceRequestorUtils.h \
 		nsINIParser.h \
 		nsISupportsImpl.h \
 		nsISupportsUtils.h \
 		nsIWeakReferenceUtils.h \
 		nsInterfaceHashtable.h \
diff --git a/xpcom/glue/nsBaseHashtable.h b/xpcom/glue/nsHashSet.h
copy from xpcom/glue/nsBaseHashtable.h
copy to xpcom/glue/nsHashSet.h
--- a/xpcom/glue/nsBaseHashtable.h
+++ b/xpcom/glue/nsHashSet.h
@@ -15,81 +15,76 @@
  * The Original Code is C++ hashtable templates.
  *
  * The Initial Developer of the Original Code is
  * Benjamin Smedberg.
  * Portions created by the Initial Developer are Copyright (C) 2002
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (conversion
+ *                                                            to hash set)
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-#ifndef nsBaseHashtable_h__
-#define nsBaseHashtable_h__
+#ifndef nsHashSet_h__
+#define nsHashSet_h__
 
 #include "nsTHashtable.h"
 #include "prlock.h"
 #include "nsDebug.h"
 
-template<class KeyClass,class DataType,class UserDataType>
-class nsBaseHashtable; // forward declaration
+template<class KeyClass>
+class nsHashSet; // forward declaration
 
 /**
- * the private nsTHashtable::EntryType class used by nsBaseHashtable
+ * the private nsTHashtable::EntryType class used by nsHashSet
  * @see nsTHashtable for the specification of this class
- * @see nsBaseHashtable for template parameters
+ * @see nsHashSet for template parameters
  */
-template<class KeyClass,class DataType>
-class nsBaseHashtableET : public KeyClass
+template<class KeyClass>
+class nsHashSetET : public KeyClass
 {
 public:
-  DataType mData;
-  friend class nsTHashtable< nsBaseHashtableET<KeyClass,DataType> >;
+  friend class nsTHashtable< nsHashSetET<KeyClass> >;
 
 private:
   typedef typename KeyClass::KeyType KeyType;
   typedef typename KeyClass::KeyTypePointer KeyTypePointer;
-  
-  nsBaseHashtableET(KeyTypePointer aKey);
-  nsBaseHashtableET(nsBaseHashtableET<KeyClass,DataType>& toCopy);
-  ~nsBaseHashtableET();
+
+  nsHashSetET(KeyTypePointer aKey);
+  nsHashSetET(nsHashSetET<KeyClass>& toCopy);
+  ~nsHashSetET();
 };
 
 /**
- * templated hashtable for simple data types
- * This class manages simple data types that do not need construction or
- * destruction.
+ * templated hash set
  *
  * @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
  *   for a complete specification.
- * @param DataType the datatype stored in the hashtable,
- *   for example, PRUint32 or nsCOMPtr.  If UserDataType is not the same,
- *   DataType must implicitly cast to UserDataType
- * @param UserDataType the user sees, for example PRUint32 or nsISupports*
  */
-template<class KeyClass,class DataType,class UserDataType>
-class nsBaseHashtable :
-  protected nsTHashtable< nsBaseHashtableET<KeyClass,DataType> >
+template<class KeyClass>
+class nsHashSet :
+  protected nsTHashtable< nsHashSetET<KeyClass> >
 {
 public:
   typedef typename KeyClass::KeyType KeyType;
-  typedef nsBaseHashtableET<KeyClass,DataType> EntryType;
+  typedef nsHashSetET<KeyClass> EntryType;
 
   // default constructor+destructor are fine
 
   /**
    * Initialize the object.
    * @param initSize the initial number of buckets in the hashtable,
    *        default 16
    * locking on all class methods
@@ -108,102 +103,62 @@ public:
   /**
    * Return the number of entries in the table.
    * @return    number of entries
    */
   PRUint32 Count() const
   { return nsTHashtable<EntryType>::Count(); }
 
   /**
-   * retrieve the value for a key.
+   * retrieve whether a key is in the set
    * @param aKey the key to retreive
-   * @param pData data associated with this key will be placed at this
-   *   pointer.  If you only need to check if the key exists, pData
-   *   may be null.
-   * @return PR_TRUE if the key exists. If key does not exist, pData is not
-   *   modified.
+   * @return whether the key exists
    */
-  PRBool Get(KeyType aKey, UserDataType* pData NS_OUTPARAM) const
+  PRBool Has(KeyType aKey) const
   {
-    EntryType* ent = this->GetEntry(aKey);
-
-    if (!ent)
-      return PR_FALSE;
-
-    if (pData)
-      *pData = ent->mData;
-
-    return PR_TRUE;
+    return !!this->GetEntry(aKey);
   }
 
   /**
-   * For pointer types, get the value, returning NULL if the entry is not
-   * present in the table.
-   *
-   * @param aKey the key to retrieve
-   * @return The found value, or NULL if no entry was found with the given key.
-   * @note If NULL values are stored in the table, it is not possible to
-   *       distinguish between a NULL value and a missing entry.
+   * add a key to the set
+   * @param aKey the key to put
+   * @return always PR_TRUE, unless memory allocation failed
    */
-  UserDataType Get(KeyType aKey) const
+  PRBool Add(KeyType aKey)
   {
-    EntryType* ent = this->GetEntry(aKey);
-    if (!ent)
-      return NULL;
-
-    return ent->mData;
+    return !!this->PutEntry(aKey);
   }
 
   /**
-   * put a new value for the associated key
-   * @param aKey the key to put
-   * @param aData the new data
-   * @return always PR_TRUE, unless memory allocation failed
-   */
-  PRBool Put(KeyType aKey, UserDataType aData)
-  {
-    EntryType* ent = this->PutEntry(aKey);
-
-    if (!ent)
-      return PR_FALSE;
-
-    ent->mData = aData;
-
-    return PR_TRUE;
-  }
-
-  /**
-   * remove the data for the associated key
-   * @param aKey the key to remove from the hashtable
+   * remove the key from the set
+   * @param aKey the key to remove
    */
   void Remove(KeyType aKey) { this->RemoveEntry(aKey); }
 
   /**
    * function type provided by the application for enumeration.
    * @param aKey the key being enumerated
-   * @param aData data being enumerated
    * @parm userArg passed unchanged from Enumerate
    * @return either
    *   @link PLDHashOperator::PL_DHASH_NEXT PL_DHASH_NEXT @endlink or
    *   @link PLDHashOperator::PL_DHASH_STOP PL_DHASH_STOP @endlink
    */
   typedef PLDHashOperator
     (* EnumReadFunction)(KeyType      aKey,
-                         UserDataType aData,
                          void*        userArg);
 
   /**
-   * enumerate entries in the hashtable, without allowing changes
+   * enumerate entries in the set, without allowing changes
    * @param enumFunc enumeration callback
    * @param userArg passed unchanged to the EnumReadFunction
    */
   PRUint32 EnumerateRead(EnumReadFunction enumFunc, void* userArg) const
   {
     NS_ASSERTION(this->mTable.entrySize,
-                 "nsBaseHashtable was not initialized properly.");
+                 "nsHashSet was not initialized properly.");
 
     s_EnumReadArgs enumData = { enumFunc, userArg };
     return PL_DHashTableEnumerate(const_cast<PLDHashTable*>(&this->mTable),
                                   s_EnumReadStub,
                                   &enumData);
   }
 
   /**
@@ -214,29 +169,28 @@ public:
    * @parm userArg passed unchanged from Enumerate
    * @return bitflag combination of
    *   @link PLDHashOperator::PL_DHASH_REMOVE @endlink,
    *   @link PLDHashOperator::PL_DHASH_NEXT PL_DHASH_NEXT @endlink, or
    *   @link PLDHashOperator::PL_DHASH_STOP PL_DHASH_STOP @endlink
    */
   typedef PLDHashOperator
     (* EnumFunction)(KeyType       aKey,
-                     DataType&     aData,
                      void*         userArg);
 
   /**
    * enumerate entries in the hashtable, allowing changes. This
    * functions write-locks the hashtable.
    * @param enumFunc enumeration callback
    * @param userArg passed unchanged to the EnumFunction
    */
   PRUint32 Enumerate(EnumFunction enumFunc, void* userArg)
   {
     NS_ASSERTION(this->mTable.entrySize,
-                 "nsBaseHashtable was not initialized properly.");
+                 "nsHashSet was not initialized properly.");
 
     s_EnumArgs enumData = { enumFunc, userArg };
     return PL_DHashTableEnumerate(&this->mTable,
                                   s_EnumStub,
                                   &enumData);
   }
 
   /**
@@ -269,205 +223,202 @@ protected:
 
   static PLDHashOperator s_EnumStub(PLDHashTable      *table,
                                     PLDHashEntryHdr   *hdr,
                                     PRUint32           number,
                                     void              *arg);
 };
 
 /**
- * This class is a thread-safe version of nsBaseHashtable.
+ * This class is a thread-safe version of nsHashSet.
  */
-template<class KeyClass,class DataType,class UserDataType>
-class nsBaseHashtableMT :
-  protected nsBaseHashtable<KeyClass,DataType,UserDataType>
+template<class KeyClass>
+class nsHashSetMT :
+  protected nsHashSet<KeyClass>
 {
 public:
   typedef typename
-    nsBaseHashtable<KeyClass,DataType,UserDataType>::EntryType EntryType;
+    nsHashSet<KeyClass>::EntryType EntryType;
   typedef typename
-    nsBaseHashtable<KeyClass,DataType,UserDataType>::KeyType KeyType;
+    nsHashSet<KeyClass>::KeyType KeyType;
   typedef typename
-    nsBaseHashtable<KeyClass,DataType,UserDataType>::EnumFunction EnumFunction;
+    nsHashSet<KeyClass>::EnumFunction EnumFunction;
   typedef typename
-    nsBaseHashtable<KeyClass,DataType,UserDataType>::EnumReadFunction EnumReadFunction;
+    nsHashSet<KeyClass>::EnumReadFunction EnumReadFunction;
 
-  nsBaseHashtableMT() : mLock(nsnull) { }
-  ~nsBaseHashtableMT();
+  nsHashSetMT() : mLock(nsnull) { }
+  ~nsHashSetMT();
 
   PRBool Init(PRUint32 initSize = PL_DHASH_MIN_SIZE);
   PRBool IsInitialized() const { return mLock != nsnull; }
   PRUint32 Count() const;
-  PRBool Get(KeyType aKey, UserDataType* pData) const;
-  PRBool Put(KeyType aKey, UserDataType aData);
+  PRBool Has(KeyType aKey) const;
+  PRBool Add(KeyType aKey);
   void Remove(KeyType aKey);
 
   PRUint32 EnumerateRead(EnumReadFunction enumFunc, void* userArg) const;
   PRUint32 Enumerate(EnumFunction enumFunc, void* userArg);
   void Clear();
 
 protected:
   PRLock* mLock;
 };
   
 
 //
-// nsBaseHashtableET definitions
+// nsHashSetET definitions
 //
 
-template<class KeyClass,class DataType>
-nsBaseHashtableET<KeyClass,DataType>::nsBaseHashtableET(KeyTypePointer aKey) :
+template<class KeyClass>
+nsHashSetET<KeyClass>::nsHashSetET(KeyTypePointer aKey) :
   KeyClass(aKey)
 { }
 
-template<class KeyClass,class DataType>
-nsBaseHashtableET<KeyClass,DataType>::nsBaseHashtableET
-  (nsBaseHashtableET<KeyClass,DataType>& toCopy) :
-  KeyClass(toCopy),
-  mData(toCopy.mData)
+template<class KeyClass>
+nsHashSetET<KeyClass>::nsHashSetET
+  (nsHashSetET<KeyClass>& toCopy) :
+  KeyClass(toCopy)
 { }
 
-template<class KeyClass,class DataType>
-nsBaseHashtableET<KeyClass,DataType>::~nsBaseHashtableET()
+template<class KeyClass>
+nsHashSetET<KeyClass>::~nsHashSetET()
 { }
 
 
 //
-// nsBaseHashtable definitions
+// nsHashSet definitions
 //
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 PLDHashOperator
-nsBaseHashtable<KeyClass,DataType,UserDataType>::s_EnumReadStub
+nsHashSet<KeyClass>::s_EnumReadStub
   (PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number, void* arg)
 {
   EntryType* ent = static_cast<EntryType*>(hdr);
   s_EnumReadArgs* eargs = (s_EnumReadArgs*) arg;
 
-  PLDHashOperator res = (eargs->func)(ent->GetKey(), ent->mData, eargs->userArg);
+  PLDHashOperator res = (eargs->func)(ent->GetKey(), eargs->userArg);
 
   NS_ASSERTION( !(res & PL_DHASH_REMOVE ),
                 "PL_DHASH_REMOVE return during const enumeration; ignoring.");
 
   if (res & PL_DHASH_STOP)
     return PL_DHASH_STOP;
 
   return PL_DHASH_NEXT;
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 PLDHashOperator
-nsBaseHashtable<KeyClass,DataType,UserDataType>::s_EnumStub
+nsHashSet<KeyClass>::s_EnumStub
   (PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number, void* arg)
 {
   EntryType* ent = static_cast<EntryType*>(hdr);
   s_EnumArgs* eargs = (s_EnumArgs*) arg;
 
-  return (eargs->func)(ent->GetKey(), ent->mData, eargs->userArg);
+  return (eargs->func)(ent->GetKey(), eargs->userArg);
 }
 
 
 //
-// nsBaseHashtableMT  definitions
+// nsHashSetMT  definitions
 //
 
-template<class KeyClass,class DataType,class UserDataType>
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::~nsBaseHashtableMT()
+template<class KeyClass>
+nsHashSetMT<KeyClass>::~nsHashSetMT()
 {
   if (this->mLock)
     PR_DestroyLock(this->mLock);
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 PRBool
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Init(PRUint32 initSize)
+nsHashSetMT<KeyClass>::Init(PRUint32 initSize)
 {
   if (!nsTHashtable<EntryType>::IsInitialized() && !nsTHashtable<EntryType>::Init(initSize))
     return PR_FALSE;
 
   this->mLock = PR_NewLock();
-  NS_ASSERTION(this->mLock, "Error creating lock during nsBaseHashtableL::Init()");
+  NS_ASSERTION(this->mLock, "Error creating lock during nsHashSetL::Init()");
 
   return (this->mLock != nsnull);
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 PRUint32
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Count() const
+nsHashSetMT<KeyClass>::Count() const
 {
   PR_Lock(this->mLock);
   PRUint32 count = nsTHashtable<EntryType>::Count();
   PR_Unlock(this->mLock);
 
   return count;
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 PRBool
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Get(KeyType       aKey,
-                                                           UserDataType* pData) const
+nsHashSetMT<KeyClass>::Has(KeyType aKey) const
 {
   PR_Lock(this->mLock);
   PRBool res =
-    nsBaseHashtable<KeyClass,DataType,UserDataType>::Get(aKey, pData);
+    nsHashSet<KeyClass>::Has(aKey);
   PR_Unlock(this->mLock);
 
   return res;
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 PRBool
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Put(KeyType      aKey,
-                                                           UserDataType aData)
+nsHashSetMT<KeyClass>::Add(KeyType aKey)
 {
   PR_Lock(this->mLock);
   PRBool res =
-    nsBaseHashtable<KeyClass,DataType,UserDataType>::Put(aKey, aData);
+    nsHashSet<KeyClass>::Add(aKey);
   PR_Unlock(this->mLock);
 
   return res;
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 void
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Remove(KeyType aKey)
+nsHashSetMT<KeyClass>::Remove(KeyType aKey)
 {
   PR_Lock(this->mLock);
-  nsBaseHashtable<KeyClass,DataType,UserDataType>::Remove(aKey);
+  nsHashSet<KeyClass>::Remove(aKey);
   PR_Unlock(this->mLock);
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 PRUint32
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::EnumerateRead
+nsHashSetMT<KeyClass>::EnumerateRead
   (EnumReadFunction fEnumCall, void* userArg) const
 {
   PR_Lock(this->mLock);
   PRUint32 count =
-    nsBaseHashtable<KeyClass,DataType,UserDataType>::EnumerateRead(fEnumCall, userArg);
+    nsHashSet<KeyClass>::EnumerateRead(fEnumCall, userArg);
   PR_Unlock(this->mLock);
 
   return count;
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 PRUint32
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Enumerate
+nsHashSetMT<KeyClass>::Enumerate
   (EnumFunction fEnumCall, void* userArg)
 {
   PR_Lock(this->mLock);
   PRUint32 count =
-    nsBaseHashtable<KeyClass,DataType,UserDataType>::Enumerate(fEnumCall, userArg);
+    nsHashSet<KeyClass>::Enumerate(fEnumCall, userArg);
   PR_Unlock(this->mLock);
 
   return count;
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 void
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Clear()
+nsHashSetMT<KeyClass>::Clear()
 {
   PR_Lock(this->mLock);
-  nsBaseHashtable<KeyClass,DataType,UserDataType>::Clear();
+  nsHashSet<KeyClass>::Clear();
   PR_Unlock(this->mLock);
 }
 
-#endif // nsBaseHashtable_h__
+#endif // nsHashSet_h__
