From: L. David Baron <dbaron@dbaron.org>

Add a hash set data structure based on nsTHashtable (by starting from a fork of nsBaseHashtable).  (Bug 708901)

diff --git a/xpcom/glue/moz.build b/xpcom/glue/moz.build
--- a/xpcom/glue/moz.build
+++ b/xpcom/glue/moz.build
@@ -28,16 +28,17 @@ EXPORTS += [
     'nsCycleCollectionNoteRootCallback.h',
     'nsCycleCollectionParticipant.h',
     'nsCycleCollectionTraversalCallback.h',
     'nsDataHashtable.h',
     'nsDebug.h',
     'nsDeque.h',
     'nsEnumeratorUtils.h',
     'nsHashKeys.h',
+    'nsHashSet.h',
     'nsIClassInfoImpl.h',
     'nsID.h',
     'nsIInterfaceRequestorUtils.h',
     'nsINIParser.h',
     'nsISupportsImpl.h',
     'nsISupportsUtils.h',
     'nsIWeakReferenceUtils.h',
     'nsInterfaceHashtable.h',
diff --git a/xpcom/glue/nsBaseHashtable.h b/xpcom/glue/nsHashSet.h
copy from xpcom/glue/nsBaseHashtable.h
copy to xpcom/glue/nsHashSet.h
--- a/xpcom/glue/nsBaseHashtable.h
+++ b/xpcom/glue/nsHashSet.h
@@ -1,67 +1,60 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef nsBaseHashtable_h__
-#define nsBaseHashtable_h__
+#ifndef nsHashSet_h__
+#define nsHashSet_h__
 
 #include "mozilla/MemoryReporting.h"
 #include "mozilla/Move.h"
 #include "nsTHashtable.h"
 #include "prlock.h"
 #include "nsDebug.h"
 
-template<class KeyClass,class DataType,class UserDataType>
-class nsBaseHashtable; // forward declaration
+template<class KeyClass>
+class nsHashSet; // forward declaration
 
 /**
- * the private nsTHashtable::EntryType class used by nsBaseHashtable
+ * the private nsTHashtable::EntryType class used by nsHashSet
  * @see nsTHashtable for the specification of this class
- * @see nsBaseHashtable for template parameters
+ * @see nsHashSet for template parameters
  */
-template<class KeyClass,class DataType>
-class nsBaseHashtableET : public KeyClass
+template<class KeyClass>
+class nsHashSetET : public KeyClass
 {
 public:
-  DataType mData;
-  friend class nsTHashtable< nsBaseHashtableET<KeyClass,DataType> >;
+  friend class nsTHashtable< nsHashSetET<KeyClass> >;
 
 private:
   typedef typename KeyClass::KeyType KeyType;
   typedef typename KeyClass::KeyTypePointer KeyTypePointer;
-  
-  nsBaseHashtableET(KeyTypePointer aKey);
-  nsBaseHashtableET(nsBaseHashtableET<KeyClass,DataType>&& toMove);
-  ~nsBaseHashtableET();
+
+  nsHashSetET(KeyTypePointer aKey);
+  nsHashSetET(nsHashSetET<KeyClass>&& toMove);
+  ~nsHashSetET();
 };
 
 /**
- * templated hashtable for simple data types
- * This class manages simple data types that do not need construction or
- * destruction.
+ * templated hash set
  *
  * @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
  *   for a complete specification.
- * @param DataType the datatype stored in the hashtable,
- *   for example, uint32_t or nsCOMPtr.  If UserDataType is not the same,
- *   DataType must implicitly cast to UserDataType
- * @param UserDataType the user sees, for example uint32_t or nsISupports*
  */
-template<class KeyClass,class DataType,class UserDataType>
-class nsBaseHashtable :
-  protected nsTHashtable< nsBaseHashtableET<KeyClass,DataType> >
+template<class KeyClass>
+class nsHashSet :
+  protected nsTHashtable< nsHashSetET<KeyClass> >
 {
   typedef mozilla::fallible_t fallible_t;
 
 public:
   typedef typename KeyClass::KeyType KeyType;
-  typedef nsBaseHashtableET<KeyClass,DataType> EntryType;
+  typedef nsHashSetET<KeyClass> EntryType;
 
   nsBaseHashtable()
   {
   }
   explicit nsBaseHashtable(uint32_t aInitSize)
     : nsTHashtable<EntryType>(aInitSize)
   {
   }
@@ -69,108 +62,68 @@ public:
   /**
    * Return the number of entries in the table.
    * @return    number of entries
    */
   uint32_t Count() const
   { return nsTHashtable<EntryType>::Count(); }
 
   /**
-   * retrieve the value for a key.
+   * retrieve whether a key is in the set
    * @param aKey the key to retreive
-   * @param pData data associated with this key will be placed at this
-   *   pointer.  If you only need to check if the key exists, pData
-   *   may be null.
-   * @return true if the key exists. If key does not exist, pData is not
-   *   modified.
+   * @return whether the key exists
    */
-  bool Get(KeyType aKey, UserDataType* pData) const
+  bool Has(KeyType aKey) const
   {
-    EntryType* ent = this->GetEntry(aKey);
-
-    if (!ent)
-      return false;
-
-    if (pData)
-      *pData = ent->mData;
-
-    return true;
+    return !!this->GetEntry(aKey);
   }
 
   /**
-   * For pointer types, get the value, returning nullptr if the entry is not
-   * present in the table.
-   *
-   * @param aKey the key to retrieve
-   * @return The found value, or nullptr if no entry was found with the given key.
-   * @note If nullptr values are stored in the table, it is not possible to
-   *       distinguish between a nullptr value and a missing entry.
+   * add a key to the set
+   * @param aKey the key to put
+   * @return always true, unless memory allocation failed
    */
-  UserDataType Get(KeyType aKey) const
+  void Add(KeyType aKey)
   {
-    EntryType* ent = this->GetEntry(aKey);
-    if (!ent)
-      return 0;
+    if (!Add(aKey, fallible_t()))
+      NS_RUNTIMEABORT("OOM");
+  }
 
-    return ent->mData;
+  bool Add(KeyType aKey, const fallible_t&) NS_WARN_UNUSED_RESULT
+  {
+    return !!this->PutEntry(aKey);
   }
 
   /**
-   * put a new value for the associated key
-   * @param aKey the key to put
-   * @param aData the new data
-   * @return always true, unless memory allocation failed
-   */
-  void Put(KeyType aKey, const UserDataType& aData)
-  {
-    if (!Put(aKey, aData, fallible_t()))
-      NS_RUNTIMEABORT("OOM");
-  }
-
-  bool Put(KeyType aKey, const UserDataType& aData, const fallible_t&) NS_WARN_UNUSED_RESULT
-  {
-    EntryType* ent = this->PutEntry(aKey);
-
-    if (!ent)
-      return false;
-
-    ent->mData = aData;
-
-    return true;
-  }
-
-  /**
-   * remove the data for the associated key
-   * @param aKey the key to remove from the hashtable
+   * remove the key from the set
+   * @param aKey the key to remove
    */
   void Remove(KeyType aKey) { this->RemoveEntry(aKey); }
 
   /**
    * function type provided by the application for enumeration.
    * @param aKey the key being enumerated
-   * @param aData data being enumerated
    * @parm userArg passed unchanged from Enumerate
    * @return either
    *   @link PLDHashOperator::PL_DHASH_NEXT PL_DHASH_NEXT @endlink or
    *   @link PLDHashOperator::PL_DHASH_STOP PL_DHASH_STOP @endlink
    */
   typedef PLDHashOperator
     (* EnumReadFunction)(KeyType      aKey,
-                         UserDataType aData,
                          void*        userArg);
 
   /**
-   * enumerate entries in the hashtable, without allowing changes
+   * enumerate entries in the set, without allowing changes
    * @param enumFunc enumeration callback
    * @param userArg passed unchanged to the EnumReadFunction
    */
   uint32_t EnumerateRead(EnumReadFunction enumFunc, void* userArg) const
   {
     NS_ASSERTION(this->mTable.entrySize,
-                 "nsBaseHashtable was not initialized properly.");
+                 "nsHashSet was not initialized properly.");
 
     s_EnumReadArgs enumData = { enumFunc, userArg };
     return PL_DHashTableEnumerate(const_cast<PLDHashTable*>(&this->mTable),
                                   s_EnumReadStub,
                                   &enumData);
   }
 
   /**
@@ -181,53 +134,50 @@ public:
    * @parm userArg passed unchanged from Enumerate
    * @return bitflag combination of
    *   @link PLDHashOperator::PL_DHASH_REMOVE @endlink,
    *   @link PLDHashOperator::PL_DHASH_NEXT PL_DHASH_NEXT @endlink, or
    *   @link PLDHashOperator::PL_DHASH_STOP PL_DHASH_STOP @endlink
    */
   typedef PLDHashOperator
     (* EnumFunction)(KeyType       aKey,
-                     DataType&     aData,
                      void*         userArg);
 
   /**
    * enumerate entries in the hashtable, allowing changes. This
    * functions write-locks the hashtable.
    * @param enumFunc enumeration callback
    * @param userArg passed unchanged to the EnumFunction
    */
   uint32_t Enumerate(EnumFunction enumFunc, void* userArg)
   {
     NS_ASSERTION(this->mTable.entrySize,
-                 "nsBaseHashtable was not initialized properly.");
+                 "nsHashSet was not initialized properly.");
 
     s_EnumArgs enumData = { enumFunc, userArg };
     return PL_DHashTableEnumerate(&this->mTable,
                                   s_EnumStub,
                                   &enumData);
   }
 
   /**
    * reset the hashtable, removing all entries
    */
   void Clear() { nsTHashtable<EntryType>::Clear(); }
 
   /**
    * client must provide a SizeOfEntryExcludingThisFun function for
    *   SizeOfExcludingThis.
    * @param     aKey the key being enumerated
-   * @param     aData Reference to data being enumerated.
    * @param     mallocSizeOf the function used to measure heap-allocated blocks
    * @param     userArg passed unchanged from SizeOf{In,Ex}cludingThis
    * @return    summed size of the things pointed to by the entries
    */
   typedef size_t
     (* SizeOfEntryExcludingThisFun)(KeyType           aKey,
-                                    const DataType    &aData,
                                     mozilla::MallocSizeOf mallocSizeOf,
                                     void*             userArg);
 
   /**
    * Measure the size of the table's entry storage and the table itself.
    * If |sizeOfEntryExcludingThis| is non-nullptr, measure the size of things
    * pointed to by entries.
    *
@@ -338,74 +288,73 @@ ImplCycleCollectionTraverse_EnumFunc(K a
   CycleCollectionNoteChild(userData->mCallback,
                            aData,
                            userData->mName,
                            userData->mFlags);
   return PL_DHASH_NEXT;
 }
 
 //
-// nsBaseHashtableET definitions
+// nsHashSetET definitions
 //
 
-template<class KeyClass,class DataType>
-nsBaseHashtableET<KeyClass,DataType>::nsBaseHashtableET(KeyTypePointer aKey) :
+template<class KeyClass>
+nsHashSetET<KeyClass>::nsHashSetET(KeyTypePointer aKey) :
   KeyClass(aKey)
 { }
 
-template<class KeyClass,class DataType>
-nsBaseHashtableET<KeyClass,DataType>::nsBaseHashtableET
-  (nsBaseHashtableET<KeyClass,DataType>&& toMove) :
-  KeyClass(mozilla::Move(toMove)),
-  mData(mozilla::Move(toMove.mData))
+template<class KeyClass>
+nsHashSetET<KeyClass>::nsHashSetET
+  (nsHashSetET<KeyClass>&& toMove) :
+  KeyClass(mozilla::Move(toMove))
 { }
 
-template<class KeyClass,class DataType>
-nsBaseHashtableET<KeyClass,DataType>::~nsBaseHashtableET()
+template<class KeyClass>
+nsHashSetET<KeyClass>::~nsHashSetET()
 { }
 
 
 //
-// nsBaseHashtable definitions
+// nsHashSet definitions
 //
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 PLDHashOperator
-nsBaseHashtable<KeyClass,DataType,UserDataType>::s_EnumReadStub
+nsHashSet<KeyClass>::s_EnumReadStub
   (PLDHashTable *table, PLDHashEntryHdr *hdr, uint32_t number, void* arg)
 {
   EntryType* ent = static_cast<EntryType*>(hdr);
   s_EnumReadArgs* eargs = (s_EnumReadArgs*) arg;
 
-  PLDHashOperator res = (eargs->func)(ent->GetKey(), ent->mData, eargs->userArg);
+  PLDHashOperator res = (eargs->func)(ent->GetKey(), eargs->userArg);
 
   NS_ASSERTION( !(res & PL_DHASH_REMOVE ),
                 "PL_DHASH_REMOVE return during const enumeration; ignoring.");
 
   if (res & PL_DHASH_STOP)
     return PL_DHASH_STOP;
 
   return PL_DHASH_NEXT;
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 PLDHashOperator
-nsBaseHashtable<KeyClass,DataType,UserDataType>::s_EnumStub
+nsHashSet<KeyClass>::s_EnumStub
   (PLDHashTable *table, PLDHashEntryHdr *hdr, uint32_t number, void* arg)
 {
   EntryType* ent = static_cast<EntryType*>(hdr);
   s_EnumArgs* eargs = (s_EnumArgs*) arg;
 
-  return (eargs->func)(ent->GetKey(), ent->mData, eargs->userArg);
+  return (eargs->func)(ent->GetKey(), eargs->userArg);
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 size_t
-nsBaseHashtable<KeyClass,DataType,UserDataType>::s_SizeOfStub
+nsHashSet<KeyClass>::s_SizeOfStub
   (PLDHashEntryHdr *hdr, mozilla::MallocSizeOf mallocSizeOf, void *arg)
 {
   EntryType* ent = static_cast<EntryType*>(hdr);
   s_SizeOfArgs* eargs = static_cast<s_SizeOfArgs*>(arg);
 
-  return (eargs->func)(ent->GetKey(), ent->mData, mallocSizeOf, eargs->userArg);
+  return (eargs->func)(ent->GetKey(), mallocSizeOf, eargs->userArg);
 }
 
-#endif // nsBaseHashtable_h__
+#endif // nsHashSet_h__
