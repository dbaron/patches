From: L. David Baron <dbaron@dbaron.org>

Add a hash set data structure based on nsTHashtable (started as a fork of nsBaseHashtable).

diff --git a/xpcom/glue/Makefile.in b/xpcom/glue/Makefile.in
--- a/xpcom/glue/Makefile.in
+++ b/xpcom/glue/Makefile.in
@@ -81,16 +81,17 @@ SDK_HEADERS = \
 		nsComponentManagerUtils.h \
 		nsCycleCollectionParticipant.h \
 		nsCycleCollectorUtils.h \
 		nsDataHashtable.h \
 		nsDebug.h \
 		nsDeque.h \
 		nsEnumeratorUtils.h \
 		nsHashKeys.h \
+		nsHashSet.h \
 		nsIClassInfoImpl.h \
 		nsID.h \
 		nsIInterfaceRequestorUtils.h \
 		nsINIParser.h \
 		nsISupportsImpl.h \
 		nsISupportsUtils.h \
 		nsIWeakReferenceUtils.h \
 		nsInterfaceHashtable.h \
diff --git a/xpcom/glue/nsHashSet.h b/xpcom/glue/nsHashSet.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/nsHashSet.h
@@ -0,0 +1,424 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is C++ hashtable templates.
+ *
+ * The Initial Developer of the Original Code is
+ * Benjamin Smedberg.
+ * Portions created by the Initial Developer are Copyright (C) 2002
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (conversion
+ *                                                            to hash set)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsHashSet_h__
+#define nsHashSet_h__
+
+#include "nsTHashtable.h"
+#include "prlock.h"
+#include "nsDebug.h"
+
+template<class KeyClass>
+class nsHashSet; // forward declaration
+
+/**
+ * the private nsTHashtable::EntryType class used by nsHashSet
+ * @see nsTHashtable for the specification of this class
+ * @see nsHashSet for template parameters
+ */
+template<class KeyClass>
+class nsHashSetET : public KeyClass
+{
+public:
+  friend class nsTHashtable< nsHashSetET<KeyClass> >;
+
+private:
+  typedef typename KeyClass::KeyType KeyType;
+  typedef typename KeyClass::KeyTypePointer KeyTypePointer;
+
+  nsHashSetET(KeyTypePointer aKey);
+  nsHashSetET(nsHashSetET<KeyClass>& toCopy);
+  ~nsHashSetET();
+};
+
+/**
+ * templated hash set
+ *
+ * @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
+ *   for a complete specification.
+ */
+template<class KeyClass>
+class nsHashSet :
+  protected nsTHashtable< nsHashSetET<KeyClass> >
+{
+public:
+  typedef typename KeyClass::KeyType KeyType;
+  typedef nsHashSetET<KeyClass> EntryType;
+
+  // default constructor+destructor are fine
+
+  /**
+   * Initialize the object.
+   * @param initSize the initial number of buckets in the hashtable,
+   *        default 16
+   * locking on all class methods
+   * @return    PR_TRUE if the object was initialized properly.
+   */
+  PRBool Init(PRUint32 initSize = PL_DHASH_MIN_SIZE)
+  { return nsTHashtable<EntryType>::Init(initSize); }
+
+  /**
+   * Check whether the table has been initialized.
+   * This function is especially useful for static hashtables.
+   * @return PR_TRUE if the table has been initialized.
+   */
+  PRBool IsInitialized() const { return !!this->mTable.entrySize; }
+
+  /**
+   * Return the number of entries in the table.
+   * @return    number of entries
+   */
+  PRUint32 Count() const
+  { return nsTHashtable<EntryType>::Count(); }
+
+  /**
+   * retrieve whether a key is in the set
+   * @param aKey the key to retreive
+   * @return whether the key exists
+   */
+  PRBool Has(KeyType aKey) const
+  {
+    return !!this->GetEntry(aKey);
+  }
+
+  /**
+   * add a key to the set
+   * @param aKey the key to put
+   * @return always PR_TRUE, unless memory allocation failed
+   */
+  PRBool Add(KeyType aKey)
+  {
+    return !!this->PutEntry(aKey);
+  }
+
+  /**
+   * remove the key from the set
+   * @param aKey the key to remove
+   */
+  void Remove(KeyType aKey) { this->RemoveEntry(aKey); }
+
+  /**
+   * function type provided by the application for enumeration.
+   * @param aKey the key being enumerated
+   * @parm userArg passed unchanged from Enumerate
+   * @return either
+   *   @link PLDHashOperator::PL_DHASH_NEXT PL_DHASH_NEXT @endlink or
+   *   @link PLDHashOperator::PL_DHASH_STOP PL_DHASH_STOP @endlink
+   */
+  typedef PLDHashOperator
+    (* EnumReadFunction)(KeyType      aKey,
+                         void*        userArg);
+
+  /**
+   * enumerate entries in the set, without allowing changes
+   * @param enumFunc enumeration callback
+   * @param userArg passed unchanged to the EnumReadFunction
+   */
+  PRUint32 EnumerateRead(EnumReadFunction enumFunc, void* userArg) const
+  {
+    NS_ASSERTION(this->mTable.entrySize,
+                 "nsHashSet was not initialized properly.");
+
+    s_EnumReadArgs enumData = { enumFunc, userArg };
+    return PL_DHashTableEnumerate(const_cast<PLDHashTable*>(&this->mTable),
+                                  s_EnumReadStub,
+                                  &enumData);
+  }
+
+  /**
+   * function type provided by the application for enumeration.
+   * @param aKey the key being enumerated
+   * @param aData Reference to data being enumerated, may be altered. e.g. for
+   *        nsInterfaceHashtable this is an nsCOMPtr reference...
+   * @parm userArg passed unchanged from Enumerate
+   * @return bitflag combination of
+   *   @link PLDHashOperator::PL_DHASH_REMOVE @endlink,
+   *   @link PLDHashOperator::PL_DHASH_NEXT PL_DHASH_NEXT @endlink, or
+   *   @link PLDHashOperator::PL_DHASH_STOP PL_DHASH_STOP @endlink
+   */
+  typedef PLDHashOperator
+    (* EnumFunction)(KeyType       aKey,
+                     void*         userArg);
+
+  /**
+   * enumerate entries in the hashtable, allowing changes. This
+   * functions write-locks the hashtable.
+   * @param enumFunc enumeration callback
+   * @param userArg passed unchanged to the EnumFunction
+   */
+  PRUint32 Enumerate(EnumFunction enumFunc, void* userArg)
+  {
+    NS_ASSERTION(this->mTable.entrySize,
+                 "nsHashSet was not initialized properly.");
+
+    s_EnumArgs enumData = { enumFunc, userArg };
+    return PL_DHashTableEnumerate(&this->mTable,
+                                  s_EnumStub,
+                                  &enumData);
+  }
+
+  /**
+   * reset the hashtable, removing all entries
+   */
+  void Clear() { nsTHashtable<EntryType>::Clear(); }
+
+protected:
+  /**
+   * used internally during EnumerateRead.  Allocated on the stack.
+   * @param func the enumerator passed to EnumerateRead
+   * @param userArg the userArg passed to EnumerateRead
+   */
+  struct s_EnumReadArgs
+  {
+    EnumReadFunction func;
+    void* userArg;
+  };
+
+  static PLDHashOperator s_EnumReadStub(PLDHashTable    *table,
+                                        PLDHashEntryHdr *hdr,
+                                        PRUint32         number,
+                                        void            *arg);
+
+  struct s_EnumArgs
+  {
+    EnumFunction func;
+    void* userArg;
+  };
+
+  static PLDHashOperator s_EnumStub(PLDHashTable      *table,
+                                    PLDHashEntryHdr   *hdr,
+                                    PRUint32           number,
+                                    void              *arg);
+};
+
+/**
+ * This class is a thread-safe version of nsHashSet.
+ */
+template<class KeyClass>
+class nsHashSetMT :
+  protected nsHashSet<KeyClass>
+{
+public:
+  typedef typename
+    nsHashSet<KeyClass>::EntryType EntryType;
+  typedef typename
+    nsHashSet<KeyClass>::KeyType KeyType;
+  typedef typename
+    nsHashSet<KeyClass>::EnumFunction EnumFunction;
+  typedef typename
+    nsHashSet<KeyClass>::EnumReadFunction EnumReadFunction;
+
+  nsHashSetMT() : mLock(nsnull) { }
+  ~nsHashSetMT();
+
+  PRBool Init(PRUint32 initSize = PL_DHASH_MIN_SIZE);
+  PRBool IsInitialized() const { return mLock != nsnull; }
+  PRUint32 Count() const;
+  PRBool Has(KeyType aKey) const;
+  PRBool Add(KeyType aKey);
+  void Remove(KeyType aKey);
+
+  PRUint32 EnumerateRead(EnumReadFunction enumFunc, void* userArg) const;
+  PRUint32 Enumerate(EnumFunction enumFunc, void* userArg);
+  void Clear();
+
+protected:
+  PRLock* mLock;
+};
+  
+
+//
+// nsHashSetET definitions
+//
+
+template<class KeyClass>
+nsHashSetET<KeyClass>::nsHashSetET(KeyTypePointer aKey) :
+  KeyClass(aKey)
+{ }
+
+template<class KeyClass>
+nsHashSetET<KeyClass>::nsHashSetET
+  (nsHashSetET<KeyClass>& toCopy) :
+  KeyClass(toCopy)
+{ }
+
+template<class KeyClass>
+nsHashSetET<KeyClass>::~nsHashSetET()
+{ }
+
+
+//
+// nsHashSet definitions
+//
+
+template<class KeyClass>
+PLDHashOperator
+nsHashSet<KeyClass>::s_EnumReadStub
+  (PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number, void* arg)
+{
+  EntryType* ent = static_cast<EntryType*>(hdr);
+  s_EnumReadArgs* eargs = (s_EnumReadArgs*) arg;
+
+  PLDHashOperator res = (eargs->func)(ent->GetKey(), eargs->userArg);
+
+  NS_ASSERTION( !(res & PL_DHASH_REMOVE ),
+                "PL_DHASH_REMOVE return during const enumeration; ignoring.");
+
+  if (res & PL_DHASH_STOP)
+    return PL_DHASH_STOP;
+
+  return PL_DHASH_NEXT;
+}
+
+template<class KeyClass>
+PLDHashOperator
+nsHashSet<KeyClass>::s_EnumStub
+  (PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number, void* arg)
+{
+  EntryType* ent = static_cast<EntryType*>(hdr);
+  s_EnumArgs* eargs = (s_EnumArgs*) arg;
+
+  return (eargs->func)(ent->GetKey(), eargs->userArg);
+}
+
+
+//
+// nsHashSetMT  definitions
+//
+
+template<class KeyClass>
+nsHashSetMT<KeyClass>::~nsHashSetMT()
+{
+  if (this->mLock)
+    PR_DestroyLock(this->mLock);
+}
+
+template<class KeyClass>
+PRBool
+nsHashSetMT<KeyClass>::Init(PRUint32 initSize)
+{
+  if (!nsTHashtable<EntryType>::IsInitialized() && !nsTHashtable<EntryType>::Init(initSize))
+    return PR_FALSE;
+
+  this->mLock = PR_NewLock();
+  NS_ASSERTION(this->mLock, "Error creating lock during nsHashSetL::Init()");
+
+  return (this->mLock != nsnull);
+}
+
+template<class KeyClass>
+PRUint32
+nsHashSetMT<KeyClass>::Count() const
+{
+  PR_Lock(this->mLock);
+  PRUint32 count = nsTHashtable<EntryType>::Count();
+  PR_Unlock(this->mLock);
+
+  return count;
+}
+
+template<class KeyClass>
+PRBool
+nsHashSetMT<KeyClass>::Has(KeyType aKey) const
+{
+  PR_Lock(this->mLock);
+  PRBool res =
+    nsHashSet<KeyClass>::Get(aKey, pData);
+  PR_Unlock(this->mLock);
+
+  return res;
+}
+
+template<class KeyClass>
+PRBool
+nsHashSetMT<KeyClass>::Add(KeyType aKey)
+{
+  PR_Lock(this->mLock);
+  PRBool res =
+    nsHashSet<KeyClass>::Put(aKey, aData);
+  PR_Unlock(this->mLock);
+
+  return res;
+}
+
+template<class KeyClass>
+void
+nsHashSetMT<KeyClass>::Remove(KeyType aKey)
+{
+  PR_Lock(this->mLock);
+  nsHashSet<KeyClass>::Remove(aKey);
+  PR_Unlock(this->mLock);
+}
+
+template<class KeyClass>
+PRUint32
+nsHashSetMT<KeyClass>::EnumerateRead
+  (EnumReadFunction fEnumCall, void* userArg) const
+{
+  PR_Lock(this->mLock);
+  PRUint32 count =
+    nsHashSet<KeyClass>::EnumerateRead(fEnumCall, userArg);
+  PR_Unlock(this->mLock);
+
+  return count;
+}
+
+template<class KeyClass>
+PRUint32
+nsHashSetMT<KeyClass>::Enumerate
+  (EnumFunction fEnumCall, void* userArg)
+{
+  PR_Lock(this->mLock);
+  PRUint32 count =
+    nsHashSet<KeyClass>::Enumerate(fEnumCall, userArg);
+  PR_Unlock(this->mLock);
+
+  return count;
+}
+
+template<class KeyClass>
+void
+nsHashSetMT<KeyClass>::Clear()
+{
+  PR_Lock(this->mLock);
+  nsHashSet<KeyClass>::Clear();
+  PR_Unlock(this->mLock);
+}
+
+#endif // nsHashSet_h__
