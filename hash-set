From: L. David Baron <dbaron@dbaron.org>

Add a hash set data structure based on nsTHashtable (by starting from a fork of nsBaseHashtable).  (Bug 708901)

diff --git a/xpcom/glue/Makefile.in b/xpcom/glue/Makefile.in
--- a/xpcom/glue/Makefile.in
+++ b/xpcom/glue/Makefile.in
@@ -48,16 +48,17 @@ SDK_HEADERS = \
 		nsComponentManagerUtils.h \
 		nsCycleCollectionParticipant.h \
 		nsCycleCollectorUtils.h \
 		nsDataHashtable.h \
 		nsDebug.h \
 		nsDeque.h \
 		nsEnumeratorUtils.h \
 		nsHashKeys.h \
+		nsHashSet.h \
 		nsIClassInfoImpl.h \
 		nsID.h \
 		nsIInterfaceRequestorUtils.h \
 		nsINIParser.h \
 		nsISupportsImpl.h \
 		nsISupportsUtils.h \
 		nsIWeakReferenceUtils.h \
 		nsInterfaceHashtable.h \
diff --git a/xpcom/glue/nsBaseHashtable.h b/xpcom/glue/nsHashSet.h
copy from xpcom/glue/nsBaseHashtable.h
copy to xpcom/glue/nsHashSet.h
--- a/xpcom/glue/nsBaseHashtable.h
+++ b/xpcom/glue/nsHashSet.h
@@ -1,65 +1,58 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef nsBaseHashtable_h__
-#define nsBaseHashtable_h__
+#ifndef nsHashSet_h__
+#define nsHashSet_h__
 
 #include "nsTHashtable.h"
 #include "prlock.h"
 #include "nsDebug.h"
 
-template<class KeyClass,class DataType,class UserDataType>
-class nsBaseHashtable; // forward declaration
+template<class KeyClass>
+class nsHashSet; // forward declaration
 
 /**
- * the private nsTHashtable::EntryType class used by nsBaseHashtable
+ * the private nsTHashtable::EntryType class used by nsHashSet
  * @see nsTHashtable for the specification of this class
- * @see nsBaseHashtable for template parameters
+ * @see nsHashSet for template parameters
  */
-template<class KeyClass,class DataType>
-class nsBaseHashtableET : public KeyClass
+template<class KeyClass>
+class nsHashSetET : public KeyClass
 {
 public:
-  DataType mData;
-  friend class nsTHashtable< nsBaseHashtableET<KeyClass,DataType> >;
+  friend class nsTHashtable< nsHashSetET<KeyClass> >;
 
 private:
   typedef typename KeyClass::KeyType KeyType;
   typedef typename KeyClass::KeyTypePointer KeyTypePointer;
-  
-  nsBaseHashtableET(KeyTypePointer aKey);
-  nsBaseHashtableET(nsBaseHashtableET<KeyClass,DataType>& toCopy);
-  ~nsBaseHashtableET();
+
+  nsHashSetET(KeyTypePointer aKey);
+  nsHashSetET(nsHashSetET<KeyClass>& toCopy);
+  ~nsHashSetET();
 };
 
 /**
- * templated hashtable for simple data types
- * This class manages simple data types that do not need construction or
- * destruction.
+ * templated hash set
  *
  * @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
  *   for a complete specification.
- * @param DataType the datatype stored in the hashtable,
- *   for example, PRUint32 or nsCOMPtr.  If UserDataType is not the same,
- *   DataType must implicitly cast to UserDataType
- * @param UserDataType the user sees, for example PRUint32 or nsISupports*
  */
-template<class KeyClass,class DataType,class UserDataType>
-class nsBaseHashtable :
-  protected nsTHashtable< nsBaseHashtableET<KeyClass,DataType> >
+template<class KeyClass>
+class nsHashSet :
+  protected nsTHashtable< nsHashSetET<KeyClass> >
 {
   typedef mozilla::fallible_t fallible_t;
 
 public:
   typedef typename KeyClass::KeyType KeyType;
-  typedef nsBaseHashtableET<KeyClass,DataType> EntryType;
+  typedef nsHashSetET<KeyClass> EntryType;
 
   // default constructor+destructor are fine
 
   /**
    * Initialize the object.
    * @param initSize the initial number of buckets in the hashtable,
    *        default 16
    * locking on all class methods
@@ -86,108 +79,68 @@ public:
   /**
    * Return the number of entries in the table.
    * @return    number of entries
    */
   PRUint32 Count() const
   { return nsTHashtable<EntryType>::Count(); }
 
   /**
-   * retrieve the value for a key.
+   * retrieve whether a key is in the set
    * @param aKey the key to retreive
-   * @param pData data associated with this key will be placed at this
-   *   pointer.  If you only need to check if the key exists, pData
-   *   may be null.
-   * @return true if the key exists. If key does not exist, pData is not
-   *   modified.
+   * @return whether the key exists
    */
-  bool Get(KeyType aKey, UserDataType* pData NS_OUTPARAM) const
+  bool Has(KeyType aKey) const
   {
-    EntryType* ent = this->GetEntry(aKey);
-
-    if (!ent)
-      return false;
-
-    if (pData)
-      *pData = ent->mData;
-
-    return true;
+    return !!this->GetEntry(aKey);
   }
 
   /**
-   * For pointer types, get the value, returning nsnull if the entry is not
-   * present in the table.
-   *
-   * @param aKey the key to retrieve
-   * @return The found value, or nsnull if no entry was found with the given key.
-   * @note If nsnull values are stored in the table, it is not possible to
-   *       distinguish between a nsnull value and a missing entry.
+   * add a key to the set
+   * @param aKey the key to put
+   * @return always true, unless memory allocation failed
    */
-  UserDataType Get(KeyType aKey) const
+  void Add(KeyType aKey)
   {
-    EntryType* ent = this->GetEntry(aKey);
-    if (!ent)
-      return nsnull;
+    if (!Add(aKey, fallible_t()))
+      NS_RUNTIMEABORT("OOM");
+  }
 
-    return ent->mData;
+  bool Add(KeyType aKey, const fallible_t&) NS_WARN_UNUSED_RESULT
+  {
+    return !!this->PutEntry(aKey);
   }
 
   /**
-   * put a new value for the associated key
-   * @param aKey the key to put
-   * @param aData the new data
-   * @return always true, unless memory allocation failed
-   */
-  void Put(KeyType aKey, UserDataType aData)
-  {
-    if (!Put(aKey, aData, fallible_t()))
-      NS_RUNTIMEABORT("OOM");
-  }
-
-  bool Put(KeyType aKey, UserDataType aData, const fallible_t&) NS_WARN_UNUSED_RESULT
-  {
-    EntryType* ent = this->PutEntry(aKey);
-
-    if (!ent)
-      return false;
-
-    ent->mData = aData;
-
-    return true;
-  }
-
-  /**
-   * remove the data for the associated key
-   * @param aKey the key to remove from the hashtable
+   * remove the key from the set
+   * @param aKey the key to remove
    */
   void Remove(KeyType aKey) { this->RemoveEntry(aKey); }
 
   /**
    * function type provided by the application for enumeration.
    * @param aKey the key being enumerated
-   * @param aData data being enumerated
    * @parm userArg passed unchanged from Enumerate
    * @return either
    *   @link PLDHashOperator::PL_DHASH_NEXT PL_DHASH_NEXT @endlink or
    *   @link PLDHashOperator::PL_DHASH_STOP PL_DHASH_STOP @endlink
    */
   typedef PLDHashOperator
     (* EnumReadFunction)(KeyType      aKey,
-                         UserDataType aData,
                          void*        userArg);
 
   /**
-   * enumerate entries in the hashtable, without allowing changes
+   * enumerate entries in the set, without allowing changes
    * @param enumFunc enumeration callback
    * @param userArg passed unchanged to the EnumReadFunction
    */
   PRUint32 EnumerateRead(EnumReadFunction enumFunc, void* userArg) const
   {
     NS_ASSERTION(this->mTable.entrySize,
-                 "nsBaseHashtable was not initialized properly.");
+                 "nsHashSet was not initialized properly.");
 
     s_EnumReadArgs enumData = { enumFunc, userArg };
     return PL_DHashTableEnumerate(const_cast<PLDHashTable*>(&this->mTable),
                                   s_EnumReadStub,
                                   &enumData);
   }
 
   /**
@@ -198,53 +151,50 @@ public:
    * @parm userArg passed unchanged from Enumerate
    * @return bitflag combination of
    *   @link PLDHashOperator::PL_DHASH_REMOVE @endlink,
    *   @link PLDHashOperator::PL_DHASH_NEXT PL_DHASH_NEXT @endlink, or
    *   @link PLDHashOperator::PL_DHASH_STOP PL_DHASH_STOP @endlink
    */
   typedef PLDHashOperator
     (* EnumFunction)(KeyType       aKey,
-                     DataType&     aData,
                      void*         userArg);
 
   /**
    * enumerate entries in the hashtable, allowing changes. This
    * functions write-locks the hashtable.
    * @param enumFunc enumeration callback
    * @param userArg passed unchanged to the EnumFunction
    */
   PRUint32 Enumerate(EnumFunction enumFunc, void* userArg)
   {
     NS_ASSERTION(this->mTable.entrySize,
-                 "nsBaseHashtable was not initialized properly.");
+                 "nsHashSet was not initialized properly.");
 
     s_EnumArgs enumData = { enumFunc, userArg };
     return PL_DHashTableEnumerate(&this->mTable,
                                   s_EnumStub,
                                   &enumData);
   }
 
   /**
    * reset the hashtable, removing all entries
    */
   void Clear() { nsTHashtable<EntryType>::Clear(); }
 
   /**
    * client must provide a SizeOfEntryExcludingThisFun function for
    *   SizeOfExcludingThis.
    * @param     aKey the key being enumerated
-   * @param     aData Reference to data being enumerated.
    * @param     mallocSizeOf the function used to measure heap-allocated blocks
    * @param     userArg passed unchanged from SizeOf{In,Ex}cludingThis
    * @return    summed size of the things pointed to by the entries
    */
   typedef size_t
     (* SizeOfEntryExcludingThisFun)(KeyType           aKey,
-                                    const DataType    &aData,
                                     nsMallocSizeOfFun mallocSizeOf,
                                     void*             userArg);
 
   /**
    * Measure the size of the table's entry storage and the table itself.
    * If |sizeOfEntryExcludingThis| is non-nsnull, measure the size of things
    * pointed to by entries.
    *
@@ -323,212 +273,209 @@ protected:
   };
   
   static size_t s_SizeOfStub(PLDHashEntryHdr *entry,
                              nsMallocSizeOfFun mallocSizeOf,
                              void *arg);
 };
 
 /**
- * This class is a thread-safe version of nsBaseHashtable. It only exposes
+ * This class is a thread-safe version of nsHashSet. It only exposes
  * an infallible API.
  */
-template<class KeyClass,class DataType,class UserDataType>
-class nsBaseHashtableMT :
-  protected nsBaseHashtable<KeyClass,DataType,UserDataType>
+template<class KeyClass>
+class nsHashSetMT :
+  protected nsHashSet<KeyClass>
 {
 public:
   typedef typename
-    nsBaseHashtable<KeyClass,DataType,UserDataType>::EntryType EntryType;
+    nsHashSet<KeyClass>::EntryType EntryType;
   typedef typename
-    nsBaseHashtable<KeyClass,DataType,UserDataType>::KeyType KeyType;
+    nsHashSet<KeyClass>::KeyType KeyType;
   typedef typename
-    nsBaseHashtable<KeyClass,DataType,UserDataType>::EnumFunction EnumFunction;
+    nsHashSet<KeyClass>::EnumFunction EnumFunction;
   typedef typename
-    nsBaseHashtable<KeyClass,DataType,UserDataType>::EnumReadFunction EnumReadFunction;
+    nsHashSet<KeyClass>::EnumReadFunction EnumReadFunction;
 
-  nsBaseHashtableMT() : mLock(nsnull) { }
-  ~nsBaseHashtableMT();
+  nsHashSetMT() : mLock(nsnull) { }
+  ~nsHashSetMT();
 
   void Init(PRUint32 initSize = PL_DHASH_MIN_SIZE);
   bool IsInitialized() const { return mLock != nsnull; }
   PRUint32 Count() const;
-  bool Get(KeyType aKey, UserDataType* pData) const;
-  void Put(KeyType aKey, UserDataType aData);
+  bool Has(KeyType aKey) const;
+  void Add(KeyType aKey);
   void Remove(KeyType aKey);
 
   PRUint32 EnumerateRead(EnumReadFunction enumFunc, void* userArg) const;
   PRUint32 Enumerate(EnumFunction enumFunc, void* userArg);
   void Clear();
 
 protected:
   PRLock* mLock;
 };
   
 
 //
-// nsBaseHashtableET definitions
+// nsHashSetET definitions
 //
 
-template<class KeyClass,class DataType>
-nsBaseHashtableET<KeyClass,DataType>::nsBaseHashtableET(KeyTypePointer aKey) :
+template<class KeyClass>
+nsHashSetET<KeyClass>::nsHashSetET(KeyTypePointer aKey) :
   KeyClass(aKey)
 { }
 
-template<class KeyClass,class DataType>
-nsBaseHashtableET<KeyClass,DataType>::nsBaseHashtableET
-  (nsBaseHashtableET<KeyClass,DataType>& toCopy) :
-  KeyClass(toCopy),
-  mData(toCopy.mData)
+template<class KeyClass>
+nsHashSetET<KeyClass>::nsHashSetET
+  (nsHashSetET<KeyClass>& toCopy) :
+  KeyClass(toCopy)
 { }
 
-template<class KeyClass,class DataType>
-nsBaseHashtableET<KeyClass,DataType>::~nsBaseHashtableET()
+template<class KeyClass>
+nsHashSetET<KeyClass>::~nsHashSetET()
 { }
 
 
 //
-// nsBaseHashtable definitions
+// nsHashSet definitions
 //
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 PLDHashOperator
-nsBaseHashtable<KeyClass,DataType,UserDataType>::s_EnumReadStub
+nsHashSet<KeyClass>::s_EnumReadStub
   (PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number, void* arg)
 {
   EntryType* ent = static_cast<EntryType*>(hdr);
   s_EnumReadArgs* eargs = (s_EnumReadArgs*) arg;
 
-  PLDHashOperator res = (eargs->func)(ent->GetKey(), ent->mData, eargs->userArg);
+  PLDHashOperator res = (eargs->func)(ent->GetKey(), eargs->userArg);
 
   NS_ASSERTION( !(res & PL_DHASH_REMOVE ),
                 "PL_DHASH_REMOVE return during const enumeration; ignoring.");
 
   if (res & PL_DHASH_STOP)
     return PL_DHASH_STOP;
 
   return PL_DHASH_NEXT;
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 PLDHashOperator
-nsBaseHashtable<KeyClass,DataType,UserDataType>::s_EnumStub
+nsHashSet<KeyClass>::s_EnumStub
   (PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number, void* arg)
 {
   EntryType* ent = static_cast<EntryType*>(hdr);
   s_EnumArgs* eargs = (s_EnumArgs*) arg;
 
-  return (eargs->func)(ent->GetKey(), ent->mData, eargs->userArg);
+  return (eargs->func)(ent->GetKey(), eargs->userArg);
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 size_t
-nsBaseHashtable<KeyClass,DataType,UserDataType>::s_SizeOfStub
+nsHashSet<KeyClass>::s_SizeOfStub
   (PLDHashEntryHdr *hdr, nsMallocSizeOfFun mallocSizeOf, void *arg)
 {
   EntryType* ent = static_cast<EntryType*>(hdr);
   s_SizeOfArgs* eargs = static_cast<s_SizeOfArgs*>(arg);
 
-  return (eargs->func)(ent->GetKey(), ent->mData, mallocSizeOf, eargs->userArg);
+  return (eargs->func)(ent->GetKey(), mallocSizeOf, eargs->userArg);
 }
 
 //
-// nsBaseHashtableMT  definitions
+// nsHashSetMT  definitions
 //
 
-template<class KeyClass,class DataType,class UserDataType>
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::~nsBaseHashtableMT()
+template<class KeyClass>
+nsHashSetMT<KeyClass>::~nsHashSetMT()
 {
   if (this->mLock)
     PR_DestroyLock(this->mLock);
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 void
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Init(PRUint32 initSize)
+nsHashSetMT<KeyClass>::Init(PRUint32 initSize)
 {
   if (!nsTHashtable<EntryType>::IsInitialized())
     nsTHashtable<EntryType>::Init(initSize);
 
   this->mLock = PR_NewLock();
   if (!this->mLock)
     NS_RUNTIMEABORT("OOM");
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 PRUint32
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Count() const
+nsHashSetMT<KeyClass>::Count() const
 {
   PR_Lock(this->mLock);
   PRUint32 count = nsTHashtable<EntryType>::Count();
   PR_Unlock(this->mLock);
 
   return count;
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 bool
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Get(KeyType       aKey,
-                                                           UserDataType* pData) const
+nsHashSetMT<KeyClass>::Has(KeyType aKey) const
 {
   PR_Lock(this->mLock);
   bool res =
-    nsBaseHashtable<KeyClass,DataType,UserDataType>::Get(aKey, pData);
+    nsHashSet<KeyClass>::Has(aKey);
   PR_Unlock(this->mLock);
 
   return res;
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 void
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Put(KeyType      aKey,
-                                                           UserDataType aData)
+nsHashSetMT<KeyClass>::Add(KeyType aKey)
 {
   PR_Lock(this->mLock);
-  nsBaseHashtable<KeyClass,DataType,UserDataType>::Put(aKey, aData);
+  nsHashSet<KeyClass,DataType,UserDataType>::Add(aKey);
   PR_Unlock(this->mLock);
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 void
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Remove(KeyType aKey)
+nsHashSetMT<KeyClass>::Remove(KeyType aKey)
 {
   PR_Lock(this->mLock);
-  nsBaseHashtable<KeyClass,DataType,UserDataType>::Remove(aKey);
+  nsHashSet<KeyClass>::Remove(aKey);
   PR_Unlock(this->mLock);
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 PRUint32
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::EnumerateRead
+nsHashSetMT<KeyClass>::EnumerateRead
   (EnumReadFunction fEnumCall, void* userArg) const
 {
   PR_Lock(this->mLock);
   PRUint32 count =
-    nsBaseHashtable<KeyClass,DataType,UserDataType>::EnumerateRead(fEnumCall, userArg);
+    nsHashSet<KeyClass>::EnumerateRead(fEnumCall, userArg);
   PR_Unlock(this->mLock);
 
   return count;
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 PRUint32
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Enumerate
+nsHashSetMT<KeyClass>::Enumerate
   (EnumFunction fEnumCall, void* userArg)
 {
   PR_Lock(this->mLock);
   PRUint32 count =
-    nsBaseHashtable<KeyClass,DataType,UserDataType>::Enumerate(fEnumCall, userArg);
+    nsHashSet<KeyClass>::Enumerate(fEnumCall, userArg);
   PR_Unlock(this->mLock);
 
   return count;
 }
 
-template<class KeyClass,class DataType,class UserDataType>
+template<class KeyClass>
 void
-nsBaseHashtableMT<KeyClass,DataType,UserDataType>::Clear()
+nsHashSetMT<KeyClass>::Clear()
 {
   PR_Lock(this->mLock);
-  nsBaseHashtable<KeyClass,DataType,UserDataType>::Clear();
+  nsHashSet<KeyClass>::Clear();
   PR_Unlock(this->mLock);
 }
 
-#endif // nsBaseHashtable_h__
+#endif // nsHashSet_h__
