From: L. David Baron <dbaron@dbaron.org>

Bug 708901 - Add a hash set data structure based on nsTHashtable (by starting from a fork of nsBaseHashtable).

diff --git a/xpcom/glue/moz.build b/xpcom/glue/moz.build
--- a/xpcom/glue/moz.build
+++ b/xpcom/glue/moz.build
@@ -29,16 +29,17 @@ EXPORTS += [
     'nsCycleCollectionNoteRootCallback.h',
     'nsCycleCollectionParticipant.h',
     'nsCycleCollectionTraversalCallback.h',
     'nsDataHashtable.h',
     'nsDebug.h',
     'nsDeque.h',
     'nsEnumeratorUtils.h',
     'nsHashKeys.h',
+    'nsHashSet.h',
     'nsIClassInfoImpl.h',
     'nsID.h',
     'nsIInterfaceRequestorUtils.h',
     'nsINIParser.h',
     'nsInterfaceHashtable.h',
     'nsISupportsImpl.h',
     'nsISupportsUtils.h',
     'nsIWeakReferenceUtils.h',
diff --git a/xpcom/glue/nsBaseHashtable.h b/xpcom/glue/nsHashSet.h
copy from xpcom/glue/nsBaseHashtable.h
copy to xpcom/glue/nsHashSet.h
--- a/xpcom/glue/nsBaseHashtable.h
+++ b/xpcom/glue/nsHashSet.h
@@ -1,181 +1,132 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef nsBaseHashtable_h__
-#define nsBaseHashtable_h__
+#ifndef nsHashSet_h__
+#define nsHashSet_h__
 
 #include "mozilla/MemoryReporting.h"
 #include "mozilla/Move.h"
 #include "nsTHashtable.h"
 #include "nsDebug.h"
 
 // These type is returned by |EnumFunction| and controls the behavior of
 // Enumerate(). The PLD/PL_D prefix is because it originated in PLDHashTable,
 // but that class no longer uses it.
 enum PLDHashOperator
 {
   PL_DHASH_NEXT = 0,          // enumerator says continue
   PL_DHASH_REMOVE = 2         // enumerator says remove
 };
 
-template<class KeyClass, class DataType, class UserDataType>
-class nsBaseHashtable; // forward declaration
+template<class KeyClass>
+class nsHashSet; // forward declaration
 
 /**
- * the private nsTHashtable::EntryType class used by nsBaseHashtable
+ * the private nsTHashtable::EntryType class used by nsHashSet
  * @see nsTHashtable for the specification of this class
- * @see nsBaseHashtable for template parameters
+ * @see nsHashSet for template parameters
  */
-template<class KeyClass, class DataType>
-class nsBaseHashtableET : public KeyClass
+template<class KeyClass>
+class nsHashSetET : public KeyClass
 {
 public:
-  DataType mData;
-  friend class nsTHashtable<nsBaseHashtableET<KeyClass, DataType>>;
+  friend class nsTHashtable<nsHashSetET<KeyClass>>;
 
 private:
   typedef typename KeyClass::KeyType KeyType;
   typedef typename KeyClass::KeyTypePointer KeyTypePointer;
 
-  explicit nsBaseHashtableET(KeyTypePointer aKey);
-  nsBaseHashtableET(nsBaseHashtableET<KeyClass, DataType>&& aToMove);
-  ~nsBaseHashtableET();
+  explicit nsHashSetET(KeyTypePointer aKey);
+  nsHashSetET(nsHashSetET<KeyClass>&& aToMove);
+  ~nsHashSetET();
 };
 
 /**
- * templated hashtable for simple data types
- * This class manages simple data types that do not need construction or
- * destruction.
+ * templated hash set
  *
  * @param KeyClass a wrapper-class for the hashtable key, see nsHashKeys.h
  *   for a complete specification.
- * @param DataType the datatype stored in the hashtable,
- *   for example, uint32_t or nsCOMPtr.  If UserDataType is not the same,
- *   DataType must implicitly cast to UserDataType
- * @param UserDataType the user sees, for example uint32_t or nsISupports*
  */
-template<class KeyClass, class DataType, class UserDataType>
-class nsBaseHashtable
-  : protected nsTHashtable<nsBaseHashtableET<KeyClass, DataType>>
+template<class KeyClass>
+class nsHashSet
+  : protected nsTHashtable<nsHashSetET<KeyClass>>
 {
   typedef mozilla::fallible_t fallible_t;
 
 public:
   typedef typename KeyClass::KeyType KeyType;
-  typedef nsBaseHashtableET<KeyClass, DataType> EntryType;
+  typedef nsHashSetET<KeyClass> EntryType;
 
   using nsTHashtable<EntryType>::Contains;
 
   nsBaseHashtable() {}
   explicit nsBaseHashtable(uint32_t aInitLength)
     : nsTHashtable<EntryType>(aInitLength)
   {
   }
 
   /**
    * Return the number of entries in the table.
    * @return    number of entries
    */
   uint32_t Count() const { return nsTHashtable<EntryType>::Count(); }
 
   /**
-   * retrieve the value for a key.
+   * retrieve whether a key is in the set
    * @param aKey the key to retreive
-   * @param aData data associated with this key will be placed at this
-   *   pointer.  If you only need to check if the key exists, aData
-   *   may be null.
-   * @return true if the key exists. If key does not exist, aData is not
-   *   modified.
+   * @return whether the key exists
    */
-  bool Get(KeyType aKey, UserDataType* aData) const
+  bool Has(KeyType aKey) const
   {
-    EntryType* ent = this->GetEntry(aKey);
-    if (!ent) {
-      return false;
-    }
-
-    if (aData) {
-      *aData = ent->mData;
-    }
-
-    return true;
+    return !!this->GetEntry(aKey);
   }
 
   /**
-   * For pointer types, get the value, returning nullptr if the entry is not
-   * present in the table.
-   *
-   * @param aKey the key to retrieve
-   * @return The found value, or nullptr if no entry was found with the given key.
-   * @note If nullptr values are stored in the table, it is not possible to
-   *       distinguish between a nullptr value and a missing entry.
-   */
-  UserDataType Get(KeyType aKey) const
-  {
-    EntryType* ent = this->GetEntry(aKey);
-    if (!ent) {
-      return 0;
-    }
-
-    return ent->mData;
-  }
-
-  /**
-   * put a new value for the associated key
+   * add a key to the set
    * @param aKey the key to put
-   * @param aData the new data
    * @return always true, unless memory allocation failed
    */
-  void Put(KeyType aKey, const UserDataType& aData)
+  void Add(KeyType aKey)
   {
-    if (!Put(aKey, aData, mozilla::fallible)) {
+    if (!Add(aKey, mozilla::fallible)) {
       NS_ABORT_OOM(this->mTable.EntrySize() * this->mTable.EntryCount());
     }
   }
 
-  MOZ_WARN_UNUSED_RESULT bool Put(KeyType aKey, const UserDataType& aData,
-                                  const fallible_t&)
+  MOZ_WARN_UNUSED_RESULT bool Add(KeyType aKey, const fallible_t&)
   {
-    EntryType* ent = this->PutEntry(aKey);
-    if (!ent) {
-      return false;
-    }
-
-    ent->mData = aData;
-
-    return true;
+    return !!this->PutEntry(aKey);
   }
 
   /**
-   * remove the data for the associated key
-   * @param aKey the key to remove from the hashtable
+   * remove the key from the set
+   * @param aKey the key to remove
    */
   void Remove(KeyType aKey) { this->RemoveEntry(aKey); }
 
   /**
    * function type provided by the application for enumeration.
    * @param aKey the key being enumerated
    * @param aData Reference to data being enumerated, may be altered. e.g. for
    *        nsInterfaceHashtable this is an nsCOMPtr reference...
    * @parm aUserArg passed unchanged from Enumerate
    * @return bitflag combination of
    *   @link PLDHashOperator::PL_DHASH_REMOVE @endlink or
    *   @link PLDHashOperator::PL_DHASH_NEXT PL_DHASH_NEXT @endlink
    */
   typedef PLDHashOperator (*EnumFunction)(KeyType aKey,
-                                          DataType& aData,
                                           void* aUserArg);
 
   /**
-   * enumerate entries in the hashtable, allowing changes.
+   * enumerate entries in the set, allowing changes.
    * WARNING: this function is deprecated. Please use Iterator and/or
    * MutatingIterator instead.
    * @param aEnumFunc enumeration callback
    * @param aUserArg passed unchanged to the EnumFunction
    */
   uint32_t Enumerate(EnumFunction aEnumFunc, void* aUserArg)
   {
     uint32_t n = 0;
@@ -266,32 +217,31 @@ public:
 
 
 #ifdef DEBUG
   using nsTHashtable<EntryType>::MarkImmutable;
 #endif
 };
 
 //
-// nsBaseHashtableET definitions
+// nsHashSetET definitions
 //
 
-template<class KeyClass, class DataType>
-nsBaseHashtableET<KeyClass, DataType>::nsBaseHashtableET(KeyTypePointer aKey)
+template<class KeyClass>
+nsHashSetET<KeyClass>::nsHashSetET(KeyTypePointer aKey)
   : KeyClass(aKey)
   , mData()
 {
 }
 
-template<class KeyClass, class DataType>
-nsBaseHashtableET<KeyClass, DataType>::nsBaseHashtableET(
-      nsBaseHashtableET<KeyClass, DataType>&& aToMove)
+template<class KeyClass>
+nsHashSetET<KeyClass>::nsHashSetET(
+      nsHashSetET<KeyClass>&& aToMove)
   : KeyClass(mozilla::Move(aToMove))
-  , mData(mozilla::Move(aToMove.mData))
 {
 }
 
-template<class KeyClass, class DataType>
-nsBaseHashtableET<KeyClass, DataType>::~nsBaseHashtableET()
+template<class KeyClass>
+nsHashSetET<KeyClass>::~nsHashSetET()
 {
 }
 
-#endif // nsBaseHashtable_h__
+#endif // nsHashSet_h__
