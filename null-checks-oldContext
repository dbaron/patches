From: L. David Baron <dbaron@dbaron.org>

Bug 898329 patch 1:  Remove null-checks on oldContext and newContext and avoid manual reference counting.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1725,18 +1725,17 @@ RestyleManager::ReparentStyleContext(nsI
     do {
       ReparentStyleContext(outOfFlow);
     } while ((outOfFlow = outOfFlow->GetNextContinuation()));
   }
 
   // DO NOT verify the style tree before reparenting.  The frame
   // tree has already been changed, so this check would just fail.
   nsStyleContext* oldContext = aFrame->StyleContext();
-  // XXXbz can oldContext really ever be null?
-  if (oldContext) {
+
     nsRefPtr<nsStyleContext> newContext;
     nsIFrame* providerFrame = aFrame->GetParentStyleContextFrame();
     bool isChild = providerFrame && providerFrame->GetParent() == aFrame;
     nsStyleContext* newParentContext = nullptr;
     nsIFrame* providerChild = nullptr;
     if (isChild) {
       ReparentStyleContext(providerFrame);
       newParentContext = providerFrame->StyleContext();
@@ -1900,17 +1899,17 @@ RestyleManager::ReparentStyleContext(nsI
             break;
           }
         }
 #ifdef DEBUG
         VerifyStyleTree(mPresContext, aFrame, newParentContext);
 #endif
       }
     }
-  }
+
   return NS_OK;
 }
 
 ElementRestyler::ElementRestyler(nsPresContext* aPresContext,
                                  nsIFrame* aFrame,
                                  nsStyleChangeList* aChangeList,
                                  nsChangeHint aHintsHandledByAncestors,
                                  RestyleTracker& aRestyleTracker,
@@ -2044,25 +2043,19 @@ ElementRestyler::Restyle(nsRestyleHint a
   // duplication.  (Or should we just let |GetContext| handle that?)
   // Getting the hint would be nice too, but that's harder.
 
   // XXXbryner we may be able to avoid some of the refcounting goop here.
   // We do need a reference to oldContext for the lifetime of this function, and it's possible
   // that the frame has the last reference to it, so AddRef it here.
 
   nsChangeHint assumeDifferenceHint = NS_STYLE_HINT_NONE;
-  // XXXbz oldContext should just be an nsRefPtr
-  nsStyleContext* oldContext = mFrame->StyleContext();
+  nsRefPtr<nsStyleContext> oldContext = mFrame->StyleContext();
   nsStyleSet* styleSet = mPresContext->StyleSet();
 
-  // XXXbz the nsIFrame constructor takes an nsStyleContext, so how
-  // could oldContext be null?
-  if (oldContext) {
-    oldContext->AddRef();
-
 #ifdef ACCESSIBILITY
     bool wasFrameVisible = nsIPresShell::IsAccessibilityActive() ?
       oldContext->StyleVisibility()->IsVisible() : false;
 #endif
 
     nsIAtom* const pseudoTag = oldContext->GetPseudo();
     const nsCSSPseudoElements::Type pseudoType = oldContext->GetPseudoType();
 
@@ -2254,18 +2247,20 @@ ElementRestyler::Restyle(nsRestyleHint a
         TreeMatchContext::AutoFlexItemStyleFixupSkipper
           flexFixupSkipper(mTreeMatchContext,
                            element->IsRootOfNativeAnonymousSubtree());
         newContext = styleSet->ResolveStyleFor(element, parentContext,
                                                mTreeMatchContext);
       }
     }
 
-    NS_ASSERTION(newContext, "failed to get new style context");
-    if (newContext) {
+    if (!newContext) {
+      NS_RUNTIMEABORT("couldn't allocate new style context");
+    }
+
       if (!parentContext) {
         if (oldContext->RuleNode() == newContext->RuleNode() &&
             oldContext->IsLinkContext() == newContext->IsLinkContext() &&
             oldContext->RelevantLinkVisited() ==
               newContext->RelevantLinkVisited()) {
           // We're the root of the style context tree and the new style
           // context returned has the same rule node.  This means that
           // we can use FindChildWithRules to keep a lot of the old
@@ -2282,22 +2277,17 @@ ElementRestyler::Restyle(nsRestyleHint a
         }
 
         CaptureChange(oldContext, newContext, assumeDifferenceHint);
         if (!(mHintsHandled & nsChangeHint_ReconstructFrame)) {
           // if frame gets regenerated, let it keep old context
           mFrame->SetStyleContext(newContext);
         }
       }
-      oldContext->Release();
-    }
-    else {
-      NS_ERROR("resolve style context failed");
-      newContext = oldContext;  // new context failed, recover...
-    }
+      oldContext = nullptr;
 
     // do additional contexts
     // XXXbz might be able to avoid selector matching here in some
     // cases; won't worry about it for now.
     int32_t contextIndex = -1;
     while (1 == 1) {
       nsStyleContext* oldExtraContext = nullptr;
       oldExtraContext = mFrame->GetAdditionalStyleContext(++contextIndex);
@@ -2615,17 +2605,16 @@ ElementRestyler::Restyle(nsRestyleHint a
                                              childContent,
                                              childContent->GetNextSibling());
           }
           mVisibleKidsOfHiddenElement.Clear();
         }
       }
 #endif
     }
-  }
 }
 
 void
 RestyleManager::ComputeStyleChangeFor(nsIFrame*          aFrame,
                                       nsStyleChangeList* aChangeList,
                                       nsChangeHint       aMinChange,
                                       RestyleTracker&    aRestyleTracker,
                                       bool               aRestyleDescendants)
