Add more useful assertion for debugging cycle collector faults.  b=386912  r+sr=peterv

diff --git a/js/src/xpconnect/src/nsXPConnect.cpp b/js/src/xpconnect/src/nsXPConnect.cpp
--- a/js/src/xpconnect/src/nsXPConnect.cpp
+++ b/js/src/xpconnect/src/nsXPConnect.cpp
@@ -602,6 +602,17 @@ nsXPConnect::FinishCycleCollection()
     if (mObjRefcounts)
         mObjRefcounts->Finish();
     return NS_OK;
+}
+
+nsCycleCollectionParticipant *
+nsXPConnect::ToParticipant(void *p)
+{
+    // Put this assertion here so it fires when we still have a stack
+    // showing where the bad pointer came from.
+    NS_ASSERTION(mObjRefcounts->Get(p) > 0,
+                 "JS object but unknown to the JS GC?");
+
+    return this;
 }
 
 NS_IMETHODIMP
diff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h
--- a/js/src/xpconnect/src/xpcprivate.h
+++ b/js/src/xpconnect/src/xpcprivate.h
@@ -480,15 +480,17 @@ public:
     nsresult GetInfoForIID(const nsIID * aIID, nsIInterfaceInfo** info);
     nsresult GetInfoForName(const char * name, nsIInterfaceInfo** info);
 
-    // from nsCycleCollectionLanguageRuntime and nsCycleCollectionParticipant
-    nsresult BeginCycleCollection();
+    // nsCycleCollectionParticipant
     NS_IMETHOD Root(void *p);
     NS_IMETHOD Unlink(void *p);
     NS_IMETHOD Unroot(void *p);
     NS_IMETHOD Traverse(void *p,
                         nsCycleCollectionTraversalCallback &cb);
-    nsresult FinishCycleCollection();
-    nsCycleCollectionParticipant *ToParticipant(void *p) {return this;}
+    
+    // nsCycleCollectionLanguageRuntime
+    virtual nsresult BeginCycleCollection();
+    virtual nsresult FinishCycleCollection();
+    virtual nsCycleCollectionParticipant *ToParticipant(void *p);
 
     JSObjectRefcounts* GetJSObjectRefcounts() {return mObjRefcounts;}
 #ifndef XPCONNECT_STANDALONE
