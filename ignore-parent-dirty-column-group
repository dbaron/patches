From: L. David Baron <dbaron@dbaron.org>

Bug 1308876 - Preserve behavior of ignoring parent dirty bit for column groups.  r?dholbert

In the existing code, the parent having NS_FRAME_IS_DIRTY is not
propagated to column groups because nsTableFrame::ReflowColGroups checks
the child dirty bit before constructing the reflow state for the child.
This preserves that behavior in the presence of the primary patch in bug
1308876.

I noticed this while debugging the assertion count failure of
layout/base/crashtests/470851-1.xhtml .  It doesn't help that failure,
but it still seems like the safe thing to do.

MozReview-Commit-ID: EhfIQQkeaJx

diff --git a/layout/generic/ReflowInput.cpp b/layout/generic/ReflowInput.cpp
--- a/layout/generic/ReflowInput.cpp
+++ b/layout/generic/ReflowInput.cpp
@@ -367,17 +367,20 @@ ReflowInput::Init(nsPresContext*     aPr
     // FIXME: It would be better for memory locality if we did this as
     // we went.  However, we need to be careful not to do this twice for
     // any particular child if we reflow it twice.  The easiest way to
     // accomplish that is to do it at the start.
     for (nsIFrame::ChildListIterator childLists(mFrame);
          !childLists.IsDone(); childLists.Next()) {
       for (nsFrameList::Enumerator childFrames(childLists.CurrentList());
            !childFrames.AtEnd(); childFrames.Next()) {
-        childFrames.get()->AddStateBits(NS_FRAME_IS_DIRTY);
+        nsIFrame* child = childFrames.get();
+        if (!child->IsTableColGroupFrame()) {
+          child->AddStateBits(NS_FRAME_IS_DIRTY);
+        }
       }
     }
   }
 
   if (AvailableISize() == NS_UNCONSTRAINEDSIZE) {
     // Look up the parent chain for an orthogonal inline limit,
     // and reset AvailableISize() if found.
     for (const ReflowInput *parent = mParentReflowInput;
