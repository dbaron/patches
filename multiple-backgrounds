Implement multiple background images.  (Bug 322475)

diff --git a/content/html/content/src/nsGenericHTMLElement.cpp b/content/html/content/src/nsGenericHTMLElement.cpp
--- a/content/html/content/src/nsGenericHTMLElement.cpp
+++ b/content/html/content/src/nsGenericHTMLElement.cpp
@@ -1923,18 +1923,17 @@ void
 void
 nsGenericHTMLElement::MapBackgroundInto(const nsMappedAttributes* aAttributes,
                                         nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
     return;
 
   nsPresContext* presContext = aData->mPresContext;
-  if (aData->mColorData->mBackImage.GetUnit() == eCSSUnit_Null &&
-      presContext->UseDocumentColors()) {
+  if (!aData->mColorData->mBackImage && presContext->UseDocumentColors()) {
     // background
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::background);
     if (value && value->Type() == nsAttrValue::eString) {
       const nsString& spec = value->GetStringValue();
       if (!spec.IsEmpty()) {
         // Resolve url to an absolute url
         // XXX this breaks if the HTML element has an xml:base
         // attribute (the xml:base will not be taken into account)
@@ -1954,43 +1953,51 @@ nsGenericHTMLElement::MapBackgroundInto(
             // XXXbz it would be nice to assert that doc->NodePrincipal() is
             // the same as the principal of the node (which we'd need to store
             // in the mapped attrs or something?)
             nsCSSValue::Image *img =
               new nsCSSValue::Image(uri, buffer, doc->GetDocumentURI(),
                                     doc->NodePrincipal(), doc);
             buffer->Release();
             if (NS_LIKELY(img != 0)) {
-              aData->mColorData->mBackImage.SetImageValue(img);
+              // Use nsRuleDataColor's temporary mTempBackImage to
+              // make a value list.
+              aData->mColorData->mTempBackImage.mValue.SetImageValue(img);
+              aData->mColorData->mBackImage =
+                &aData->mColorData->mTempBackImage;
             }
           }
         }
       }
       else if (presContext->CompatibilityMode() == eCompatibility_NavQuirks) {
         // in NavQuirks mode, allow the empty string to set the
         // background to empty
-        aData->mColorData->mBackImage.SetNoneValue();
+        aData->mColorData->mBackImage = nsnull;
       }
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapBGColorInto(const nsMappedAttributes* aAttributes,
                                      nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
     return;
 
-  if (aData->mColorData->mBackColor.GetUnit() == eCSSUnit_Null &&
+  if (aData->mColorData->mBackColor.mXValue.GetUnit() == eCSSUnit_Null &&
       aData->mPresContext->UseDocumentColors()) {
+    NS_ASSERTION(aData->mColorData->mBackColor.mYValue.GetUnit() ==
+                   eCSSUnit_Null,
+                 "half a property?");
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::bgcolor);
     nscolor color;
     if (value && value->GetColorValue(color)) {
-      aData->mColorData->mBackColor.SetColorValue(color);
+      aData->mColorData->mBackColor.mXValue.SetColorValue(color);
+      aData->mColorData->mBackColor.mYValue.SetColorValue(color);
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapBackgroundAttributesInto(const nsMappedAttributes* aAttributes,
                                                   nsRuleData* aData)
 {
diff --git a/content/mathml/content/src/nsMathMLElement.cpp b/content/mathml/content/src/nsMathMLElement.cpp
--- a/content/mathml/content/src/nsMathMLElement.cpp
+++ b/content/mathml/content/src/nsMathMLElement.cpp
@@ -393,20 +393,25 @@ nsMathMLElement::MapMathMLAttributesInto
   }
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)) {
     const nsAttrValue* value =
       aAttributes->GetAttr(nsGkAtoms::mathbackground_);
     if (!value) {
       value = aAttributes->GetAttr(nsGkAtoms::background);
     }
-    if (value && aData->mColorData->mBackColor.GetUnit() == eCSSUnit_Null) {
+    if (value &&
+        aData->mColorData->mBackColor.mXValue.GetUnit() == eCSSUnit_Null) {
+      NS_ASSERTION(aData->mColorData->mBackColor.mYValue.GetUnit()
+                     == eCSSUnit_Null,
+                   "half a property?");
       nscolor color;
       if (value->GetColorValue(color)) {
-        aData->mColorData->mBackColor.SetColorValue(color);
+        aData->mColorData->mBackColor.mXValue.SetColorValue(color);
+        aData->mColorData->mBackColor.mYValue.SetColorValue(color);
       }
     }
   }
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Color)) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::mathcolor_);
     if (!value) {
       value = aAttributes->GetAttr(nsGkAtoms::color);
diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -258,16 +258,27 @@ protected:
     PRBool isValid1, isValid2;
     nsBlockInFlowLineIterator it1(mBlockFrame, aFrame1, &isValid1);
     nsBlockInFlowLineIterator it2(mBlockFrame, aFrame2, &isValid2);
     return isValid1 && isValid2 && it1.GetLine() == it2.GetLine();
   }
 };
 
 /* Local functions */
+static void PaintBackgroundLayer(nsPresContext* aPresContext,
+                                 nsIRenderingContext& aRenderingContext,
+                                 nsIFrame* aForFrame,
+                                 const nsRect& aDirtyRect,
+                                 const nsRect& aBorderArea,
+                                 const nsStyleBackground& aColor,
+                                 const nsStyleBackground::Layer& aLayer,
+                                 const nsStyleBorder& aBorder,
+                                 PRBool aUsePrintSettings,
+                                 nsRect* aBGClipRect);
+
 static void DrawBorderImage(nsPresContext* aPresContext,
                             nsIRenderingContext& aRenderingContext,
                             nsIFrame* aForFrame,
                             const nsRect& aBorderArea,
                             const nsStyleBorder& aBorderStyle);
 
 static void DrawBorderImageSide(gfxContext *aThebesContext,
                                 nsIDeviceContext* aDeviceContext,
@@ -279,26 +290,26 @@ static void DrawBorderImageSide(gfxConte
                                 PRUint8 aVFillType);
 
 static void PaintBackgroundColor(nsPresContext* aPresContext,
                                  nsIRenderingContext& aRenderingContext,
                                  nsIFrame* aForFrame,
                                  const nsRect& aBgClipArea,
                                  const nsStyleBackground& aColor,
                                  const nsStyleBorder& aBorder,
+                                 PRBool aUseFallbackColor,
                                  PRBool aCanPaintNonWhite);
 
 static void PaintRoundedBackground(nsPresContext* aPresContext,
                                    nsIRenderingContext& aRenderingContext,
                                    nsIFrame* aForFrame,
                                    const nsRect& aBorderArea,
                                    const nsStyleBackground& aColor,
                                    const nsStyleBorder& aBorder,
-                                   nscoord aTheRadius[4],
-                                   PRBool aCanPaintNonWhite);
+                                   nscoord aTheRadius[4]);
 
 static nscolor MakeBevelColor(PRIntn whichSide, PRUint8 style,
                               nscolor aBackgroundColor,
                               nscolor aBorderColor);
 
 static void DrawLine(nsIRenderingContext& aContext, 
                      nscoord aX1, nscoord aY1, nscoord aX2, nscoord aY2,
                      nsRect* aGap);
@@ -913,37 +924,34 @@ nsCSSRendering::PaintFocus(nsPresContext
 //
 // aOriginBounds is the box to which the tiling position should be relative
 // aClipBounds is the box in which the tiling will actually be done
 // They should correspond to 'background-origin' and 'background-clip',
 // except when painting on the canvas, in which case the origin bounds
 // should be the bounds of the root element's frame and the clip bounds
 // should be the bounds of the canvas frame.
 static void
-ComputeBackgroundAnchorPoint(const nsStyleBackground& aColor,
+ComputeBackgroundAnchorPoint(const nsStyleBackground::Layer& aLayer,
                              const nsRect& aOriginBounds,
                              const nsRect& aClipBounds,
                              nscoord aTileWidth, nscoord aTileHeight,
                              nsPoint& aResult)
 {
   nscoord x;
-  if (NS_STYLE_BG_X_POSITION_LENGTH & aColor.mBackgroundFlags) {
-    x = aColor.mBackgroundXPosition.mCoord;
+  if (!aLayer.mPosition.mXIsPercent) {
+    x = aLayer.mPosition.mXPosition.mCoord;
   }
-  else if (NS_STYLE_BG_X_POSITION_PERCENT & aColor.mBackgroundFlags) {
-    PRFloat64 percent = PRFloat64(aColor.mBackgroundXPosition.mFloat);
+  else {
+    PRFloat64 percent = PRFloat64(aLayer.mPosition.mXPosition.mFloat);
     nscoord tilePos = nscoord(percent * PRFloat64(aTileWidth));
     nscoord boxPos = nscoord(percent * PRFloat64(aOriginBounds.width));
     x = boxPos - tilePos;
   }
-  else {
-    x = 0;
-  }
   x += aOriginBounds.x - aClipBounds.x;
-  if (NS_STYLE_BG_REPEAT_X & aColor.mBackgroundRepeat) {
+  if (NS_STYLE_BG_REPEAT_X & aLayer.mRepeat) {
     // When we are tiling in the x direction the loop will run from
     // the left edge of the box to the right edge of the box. We need
     // to adjust the starting coordinate to lie within the band being
     // rendered.
     if (x < 0) {
       x = -x;
       if (x < 0) {
         // Some joker gave us max-negative-integer.
@@ -959,30 +967,27 @@ ComputeBackgroundAnchorPoint(const nsSty
       }
     }
 
     NS_POSTCONDITION((x >= -(aTileWidth - 1)) && (x <= 0), "bad computed anchor value");
   }
   aResult.x = x;
 
   nscoord y;
-  if (NS_STYLE_BG_Y_POSITION_LENGTH & aColor.mBackgroundFlags) {
-    y = aColor.mBackgroundYPosition.mCoord;
+  if (!aLayer.mPosition.mYIsPercent) {
+    y = aLayer.mPosition.mYPosition.mCoord;
   }
-  else if (NS_STYLE_BG_Y_POSITION_PERCENT & aColor.mBackgroundFlags){
-    PRFloat64 percent = PRFloat64(aColor.mBackgroundYPosition.mFloat);
+  else {
+    PRFloat64 percent = PRFloat64(aLayer.mPosition.mYPosition.mFloat);
     nscoord tilePos = nscoord(percent * PRFloat64(aTileHeight));
     nscoord boxPos = nscoord(percent * PRFloat64(aOriginBounds.height));
     y = boxPos - tilePos;
   }
-  else {
-    y = 0;
-  }
   y += aOriginBounds.y - aClipBounds.y;
-  if (NS_STYLE_BG_REPEAT_Y & aColor.mBackgroundRepeat) {
+  if (NS_STYLE_BG_REPEAT_Y & aLayer.mRepeat) {
     // When we are tiling in the y direction the loop will run from
     // the top edge of the box to the bottom edge of the box. We need
     // to adjust the starting coordinate to lie within the band being
     // rendered.
     if (y < 0) {
       y = -y;
       if (y < 0) {
         // Some joker gave us max-negative-integer.
@@ -1482,16 +1487,36 @@ IsSolidBorder(const nsStyleBorder& aBord
     return PR_FALSE;
   for (PRUint32 i = 0; i < 4; ++i) {
     if (!IsSolidBorderEdge(aBorder, i))
       return PR_FALSE;
   }
   return PR_TRUE;
 }
 
+// Call LoadImage, and return null if the image is unavailable.
+static imgIRequest*
+GetImageRequestForBackground(nsPresContext *aPresContext,
+                             imgIRequest *aRequest, nsIFrame *aForFrame)
+{
+  imgIRequest *req = aPresContext->LoadImage(aRequest, aForFrame);
+  if (!req)
+    return nsnull;
+
+  PRUint32 status = imgIRequest::STATUS_ERROR;
+  req->GetImageStatus(&status);
+
+  if (!(status & imgIRequest::STATUS_FRAME_COMPLETE) ||
+      !(status & imgIRequest::STATUS_SIZE_AVAILABLE)) {
+    return nsnull;
+  }
+
+  return req;
+}
+
 void
 nsCSSRendering::PaintBackgroundWithSC(nsPresContext* aPresContext,
                                       nsIRenderingContext& aRenderingContext,
                                       nsIFrame* aForFrame,
                                       const nsRect& aDirtyRect,
                                       const nsRect& aBorderArea,
                                       const nsStyleBackground& aColor,
                                       const nsStyleBorder& aBorder,
@@ -1518,27 +1543,138 @@ nsCSSRendering::PaintBackgroundWithSC(ns
       nsRect dirty;
       dirty.IntersectRect(aDirtyRect, aBorderArea);
       theme->DrawWidgetBackground(&aRenderingContext, aForFrame, 
                                   displayData->mAppearance, aBorderArea, dirty);
       return;
     }
   }
 
+  nsRect *forceBGClipRect;
+  nsRect colorBGClipRect;
+  if (aBGClipRect) {
+    forceBGClipRect = aBGClipRect;
+    colorBGClipRect = *forceBGClipRect;
+  } else {
+    colorBGClipRect = aBorderArea;
+    if (IsSolidBorder(aBorder)) {
+      // If the border is solid, then clip all backgrounds to the padding-box
+      // so that we don't draw unnecessary tiles.
+      forceBGClipRect = &colorBGClipRect;
+    } else {
+      forceBGClipRect = nsnull;
+    }
+    if (aColor.mBottomLayer->mClip != NS_STYLE_BG_CLIP_BORDER ||
+        forceBGClipRect) {
+      nsMargin border = aForFrame->GetUsedBorder();
+      aForFrame->ApplySkipSides(border);
+      colorBGClipRect.Deflate(border);
+    }
+  }
+
+  nsIDeviceContext *dc = aPresContext->DeviceContext();
+  gfxContext *ctx = aRenderingContext.ThebesContext();
+
+  // Snap bgClipArea to device pixel boundaries.  (We have to snap
+  // bgOriginArea below; if we don't do this as well then we could make
+  // incorrect decisions about various optimizations.)
+  PixelSnapRectangle(ctx, dc, colorBGClipRect);
+
+  nsRect maxDirtyRect;
+  if (!maxDirtyRect.IntersectRect(
+         forceBGClipRect ? *forceBGClipRect : aBorderArea, aDirtyRect)) {
+    // Nothing to paint for any images.
+    return;
+  }
+
+  imgIRequest *bottomImage = nsnull;
+  PRBool useFallbackColor = aColor.mBottomLayer->mImage &&
+                            (!canDrawBackgroundImage ||
+                             !(bottomImage =
+                                 GetImageRequestForBackground(aPresContext,
+                                   aColor.mBottomLayer->mImage, aForFrame)));
+
+  PRBool needBackgroundColor = PR_TRUE;
+  if (bottomImage && aColor.mBottomLayer->mRepeat == NS_STYLE_BG_REPEAT_XY) {
+    nsCOMPtr<imgIContainer> image;
+    bottomImage->GetImage(getter_AddRefs(image));
+    // If the image is completely opaque, we do not need to paint the
+    // background color
+    nsCOMPtr<gfxIImageFrame> gfxImgFrame;
+    image->GetCurrentFrame(getter_AddRefs(gfxImgFrame));
+    if (gfxImgFrame) {
+      gfxImgFrame->GetNeedsBackground(&needBackgroundColor);
+
+      /* check for tiling of a image where frame smaller than container */
+      nsSize iSize;
+      image->GetWidth(&iSize.width);
+      image->GetHeight(&iSize.height);
+      nsRect iframeRect;
+      gfxImgFrame->GetRect(iframeRect);
+      if (iSize.width != iframeRect.width ||
+          iSize.height != iframeRect.height) {
+        needBackgroundColor = PR_TRUE;
+      }
+    }
+  }
+
+  if (needBackgroundColor) {
+    PaintBackgroundColor(aPresContext, aRenderingContext, aForFrame,
+                         colorBGClipRect, aColor, aBorder,
+                         useFallbackColor, canDrawBackgroundColor);
+  }
+
+  if (!canDrawBackgroundImage) {
+    return;
+  }
+
+  for (nsStyleBackground::Layer *layer = aColor.mBottomLayer; layer;
+       layer = layer->mHigherLayer) {
+    PaintBackgroundLayer(aPresContext, aRenderingContext, aForFrame,
+                         aDirtyRect, aBorderArea, aColor, *layer, aBorder,
+                         aUsePrintSettings, forceBGClipRect);
+  }
+}
+
+static void
+PaintBackgroundLayer(nsPresContext* aPresContext,
+                     nsIRenderingContext& aRenderingContext,
+                     nsIFrame* aForFrame,
+                     const nsRect& aDirtyRect,
+                     const nsRect& aBorderArea,
+                     const nsStyleBackground& aColor,
+                     const nsStyleBackground::Layer& aLayer,
+                     const nsStyleBorder& aBorder,
+                     PRBool aUsePrintSettings,
+                     nsRect* aBGClipRect)
+{
+  if (!aLayer.mImage) {
+    return;
+  }
+
+  // Lookup the image
+  imgIRequest *req =
+    GetImageRequestForBackground(aPresContext, aLayer.mImage, aForFrame);
+  if (!req) {
+    // It's not ready to be painted.
+    return;
+  }
+
   nsRect bgClipArea;
   if (aBGClipRect) {
+    // This can be forced to this rect either because the caller of
+    // PaintBackgroundWithSC did, or because we're doing the
+    // IsSolidBorder optimization to restrict tiling to the padding
+    // area.
     bgClipArea = *aBGClipRect;
   }
   else {
     // The background is rendered over the 'background-clip' area.
     bgClipArea = aBorderArea;
-    // If the border is solid, then clip the background to the padding-box
-    // so that we don't draw unnecessary tiles.
-    if (aColor.mBackgroundClip != NS_STYLE_BG_CLIP_BORDER ||
-        IsSolidBorder(aBorder)) {
+    if (aLayer.mClip != NS_STYLE_BG_CLIP_BORDER) {
       nsMargin border = aForFrame->GetUsedBorder();
       aForFrame->ApplySkipSides(border);
       bgClipArea.Deflate(border);
     }
   }
 
   nsIDeviceContext *dc = aPresContext->DeviceContext();
   gfxContext *ctx = aRenderingContext.ThebesContext();
@@ -1551,38 +1687,16 @@ nsCSSRendering::PaintBackgroundWithSC(ns
   // The actual dirty rect is the intersection of the 'background-clip'
   // area and the dirty rect we were given
   nsRect dirtyRect;
   if (!dirtyRect.IntersectRect(bgClipArea, aDirtyRect)) {
     // Nothing to paint
     return;
   }
 
-  // if there is no background image or background images are turned off, try a color.
-  if (!aColor.mBackgroundImage || !canDrawBackgroundImage) {
-    PaintBackgroundColor(aPresContext, aRenderingContext, aForFrame, bgClipArea,
-                         aColor, aBorder, canDrawBackgroundColor);
-    return;
-  }
-
-  // We have a background image
-
-  // Lookup the image
-  imgIRequest *req = aPresContext->LoadImage(aColor.mBackgroundImage,
-                                             aForFrame);
-
-  PRUint32 status = imgIRequest::STATUS_ERROR;
-  if (req)
-    req->GetImageStatus(&status);
-
-  if (!req || !(status & imgIRequest::STATUS_FRAME_COMPLETE) || !(status & imgIRequest::STATUS_SIZE_AVAILABLE)) {
-    PaintBackgroundColor(aPresContext, aRenderingContext, aForFrame, bgClipArea,
-                         aColor, aBorder, canDrawBackgroundColor);
-    return;
-  }
 
   nsCOMPtr<imgIContainer> image;
   req->GetImage(getter_AddRefs(image));
 
   nsSize imageSize;
   image->GetWidth(&imageSize.width);
   image->GetHeight(&imageSize.height);
 
@@ -1614,96 +1728,54 @@ nsCSSRendering::PaintBackgroundWithSC(ns
     }
   }
   else {
     bgOriginArea = aBorderArea;
   }
 
   // Background images are tiled over the 'background-clip' area
   // but the origin of the tiling is based on the 'background-origin' area
-  if (aColor.mBackgroundOrigin != NS_STYLE_BG_ORIGIN_BORDER) {
+  if (aLayer.mOrigin != NS_STYLE_BG_ORIGIN_BORDER) {
     nsMargin border = aForFrame->GetUsedBorder();
     aForFrame->ApplySkipSides(border);
     bgOriginArea.Deflate(border);
-    if (aColor.mBackgroundOrigin != NS_STYLE_BG_ORIGIN_PADDING) {
+    if (aLayer.mOrigin != NS_STYLE_BG_ORIGIN_PADDING) {
       nsMargin padding = aForFrame->GetUsedPadding();
       aForFrame->ApplySkipSides(padding);
       bgOriginArea.Deflate(padding);
-      NS_ASSERTION(aColor.mBackgroundOrigin == NS_STYLE_BG_ORIGIN_CONTENT,
+      NS_ASSERTION(aLayer.mOrigin == NS_STYLE_BG_ORIGIN_CONTENT,
                    "unknown background-origin value");
     }
   }
 
   // Snap bgOriginArea to device pixel boundaries to avoid variations in
   // tiling when the subpixel position of the element changes.
   PixelSnapRectangle(ctx, dc, bgOriginArea);
 
   // Based on the repeat setting, compute how many tiles we should
   // lay down for each axis. The value computed is the maximum based
   // on the dirty rect before accounting for the background-position.
   nscoord tileWidth = imageSize.width;
   nscoord tileHeight = imageSize.height;
-  PRBool  needBackgroundColor = NS_GET_A(aColor.mBackgroundColor) > 0;
-  PRIntn  repeat = aColor.mBackgroundRepeat;
-
-  switch (repeat) {
-    case NS_STYLE_BG_REPEAT_X:
-      break;
-    case NS_STYLE_BG_REPEAT_Y:
-      break;
-    case NS_STYLE_BG_REPEAT_XY:
-      if (needBackgroundColor) {
-        // If the image is completely opaque, we do not need to paint the
-        // background color
-        nsCOMPtr<gfxIImageFrame> gfxImgFrame;
-        image->GetCurrentFrame(getter_AddRefs(gfxImgFrame));
-        if (gfxImgFrame) {
-          gfxImgFrame->GetNeedsBackground(&needBackgroundColor);
-
-          /* check for tiling of a image where frame smaller than container */
-          nsSize iSize;
-          image->GetWidth(&iSize.width);
-          image->GetHeight(&iSize.height);
-          nsRect iframeRect;
-          gfxImgFrame->GetRect(iframeRect);
-          if (iSize.width != iframeRect.width ||
-              iSize.height != iframeRect.height) {
-            needBackgroundColor = PR_TRUE;
-          }
-        }
-      }
-      break;
-    case NS_STYLE_BG_REPEAT_OFF:
-    default:
-      NS_ASSERTION(repeat == NS_STYLE_BG_REPEAT_OFF, "unknown background-repeat value");
-      break;
-  }
-
-  // The background color is rendered over the 'background-clip' area
-  if (needBackgroundColor) {
-    PaintBackgroundColor(aPresContext, aRenderingContext, aForFrame, bgClipArea,
-                         aColor, aBorder, canDrawBackgroundColor);
-  }
-
   if ((tileWidth == 0) || (tileHeight == 0) || dirtyRect.IsEmpty()) {
     // Nothing left to paint
     return;
   }
 
   nsPoint borderAreaOriginSnapped = aBorderArea.TopLeft();
   PixelSnapPoint(ctx, dc, borderAreaOriginSnapped);
 
   // Compute the anchor point.
   //
   // When tiling, the anchor coordinate values will be negative offsets
   // from the background-origin area.
 
   // relative to the origin of aForFrame
   nsPoint anchor;
-  if (NS_STYLE_BG_ATTACHMENT_FIXED == aColor.mBackgroundAttachment) {
+  if (NS_STYLE_BG_ATTACHMENT_FIXED == aLayer.mAttachment) {
     // If it's a fixed background attachment, then the image is placed
     // relative to the viewport, which is the area of the root frame
     // in a screen context or the page content frame in a print context.
 
     // Remember that we've drawn position-varying content in this prescontext
     aPresContext->SetRenderedPositionVaryingContent();
 
     nsIFrame* topFrame =
@@ -1727,17 +1799,17 @@ nsCSSRendering::PaintBackgroundWithSC(ns
         aPresContext->PresShell()->GetRootScrollFrameAsScrollable();
       if (scrollableFrame) {
         nsMargin scrollbars = scrollableFrame->GetActualScrollbarSizes();
         viewportArea.Deflate(scrollbars);
       }
     }
      
     // Get the anchor point, relative to the viewport.
-    ComputeBackgroundAnchorPoint(aColor, viewportArea, viewportArea, tileWidth, tileHeight, anchor);
+    ComputeBackgroundAnchorPoint(aLayer, viewportArea, viewportArea, tileWidth, tileHeight, anchor);
 
     // Convert the anchor point from viewport coordinates to aForFrame
     // coordinates.
     anchor -= aForFrame->GetOffsetTo(topFrame);
   } else {
     if (frameType == nsGkAtoms::canvasFrame) {
       // If the frame is the canvas, the image is placed relative to
       // the root element's (first) frame (see bug 46446)
@@ -1752,25 +1824,25 @@ nsCSSRendering::PaintBackgroundWithSC(ns
       if (firstRootElementFrame) {
         firstRootElementFrameArea = firstRootElementFrame->GetRect();
 
         // Take the border out of the frame's rect
         const nsStyleBorder* borderStyle = firstRootElementFrame->GetStyleBorder();
         firstRootElementFrameArea.Deflate(borderStyle->GetActualBorder());
 
         // Get the anchor point
-        ComputeBackgroundAnchorPoint(aColor, firstRootElementFrameArea +
+        ComputeBackgroundAnchorPoint(aLayer, firstRootElementFrameArea +
             aBorderArea.TopLeft(), bgClipArea, tileWidth, tileHeight, anchor);
       } else {
-        ComputeBackgroundAnchorPoint(aColor, bgOriginArea, bgClipArea, tileWidth, tileHeight, anchor);
+        ComputeBackgroundAnchorPoint(aLayer, bgOriginArea, bgClipArea, tileWidth, tileHeight, anchor);
       }
     } else {
       // Otherwise, it is the normal case, and the background is
       // simply placed relative to the frame's background-clip area
-      ComputeBackgroundAnchorPoint(aColor, bgOriginArea, bgClipArea, tileWidth, tileHeight, anchor);
+      ComputeBackgroundAnchorPoint(aLayer, bgOriginArea, bgClipArea, tileWidth, tileHeight, anchor);
     }
 
     // For scrolling attachment, the anchor is within the 'background-clip'
     anchor.x += bgClipArea.x - borderAreaOriginSnapped.x;
     anchor.y += bgClipArea.y - borderAreaOriginSnapped.y;
   }
 
   // Pixel-snap the anchor point so that we don't end up with blurry
@@ -1913,16 +1985,17 @@ nsCSSRendering::PaintBackgroundWithSC(ns
   nsRect tileRect(anchor, nsSize(tileWidth, tileHeight));
   // Whether we take the single-image path or the tile path should not
   // depend on the dirty rect. So decide now which path to take. We
   // can take the single image path if the anchored image tile
   // contains the total background area.
   PRBool useSingleImagePath =
     tileRect.Contains(bgClipArea - borderAreaOriginSnapped);
 
+  PRIntn  repeat = aLayer.mRepeat;
   if (repeat & NS_STYLE_BG_REPEAT_X) {
     // When tiling in the x direction, adjust the starting position of the
     // tile to account for dirtyRect.x. When tiling in x, the anchor.x value
     // will be a negative value used to adjust the starting coordinate.
     nscoord x0 = FindTileStart(dirtyRect.x - borderAreaOriginSnapped.x, anchor.x, tileWidth);
     nscoord x1 = FindTileEnd(dirtyRect.XMost() - borderAreaOriginSnapped.x, anchor.x, tileWidth);
     tileRect.x = x0;
     tileRect.width = x1 - x0;
@@ -2368,79 +2441,77 @@ DrawBorderImageSide(gfxContext *aThebesC
 
 static void
 PaintBackgroundColor(nsPresContext* aPresContext,
                      nsIRenderingContext& aRenderingContext,
                      nsIFrame* aForFrame,
                      const nsRect& aBgClipArea,
                      const nsStyleBackground& aColor,
                      const nsStyleBorder& aBorder,
+                     PRBool aUseFallbackColor,
                      PRBool aCanPaintNonWhite)
 {
+  nscolor color = aUseFallbackColor ? aColor.mFallbackBackgroundColor
+                                    : aColor.mBackgroundColor;
   // If we're only allowed to paint white, then don't bail out on transparent
   // color if we're not completely transparent.  See the corresponding check
   // for whether we're allowed to paint background images in
   // PaintBackgroundWithSC before the first call to PaintBackgroundColor.
-  if (NS_GET_A(aColor.mBackgroundColor) == 0 &&
-      (aCanPaintNonWhite || aColor.IsTransparent())) {
+  if (!aCanPaintNonWhite && !aColor.IsTransparent()) {
+    color = NS_RGB(255, 255, 255);
+  }
+  
+  if (NS_GET_A(color) == 0) {
     // nothing to paint
     return;
   }
+
+  aRenderingContext.SetColor(color);
 
   nscoord borderRadii[4];
   nsRect bgClipArea(aBgClipArea);
 
   GetBorderRadiusTwips(aBorder.mBorderRadius, aForFrame->GetSize().width, borderRadii);
 
   PRUint8 side = 0;
   // Rounded version of the border
   for (side = 0; side < 4; ++side) {
     if (borderRadii[side] > 0) {
       PaintRoundedBackground(aPresContext, aRenderingContext, aForFrame,
-                             bgClipArea, aColor, aBorder, borderRadii,
-                             aCanPaintNonWhite);
+                             bgClipArea, aColor, aBorder, borderRadii);
       return;
     }
   }
 
-  nscolor color;
-  if (!aCanPaintNonWhite) {
-    color = NS_RGB(255, 255, 255);
-  } else {
-    color = aColor.mBackgroundColor;
-  }
-  
-  aRenderingContext.SetColor(color);
   aRenderingContext.FillRect(bgClipArea);
 }
 
+/*
+ * Our caller must call SetColor on aRenderingContext with the
+ * appropriate color.
+ */
 static void
 PaintRoundedBackground(nsPresContext* aPresContext,
                        nsIRenderingContext& aRenderingContext,
                        nsIFrame* aForFrame,
                        const nsRect& aBgClipArea,
                        const nsStyleBackground& aColor,
                        const nsStyleBorder& aBorder,
-                       nscoord aTheRadius[4],
-                       PRBool aCanPaintNonWhite)
+                       nscoord aTheRadius[4])
 {
   gfxContext *ctx = aRenderingContext.ThebesContext();
 
   // needed for our border thickness
   nscoord appUnitsPerPixel = aPresContext->AppUnitsPerDevPixel();
 
-  nscolor color = aColor.mBackgroundColor;
-  if (!aCanPaintNonWhite) {
-    color = NS_RGB(255, 255, 255);
-  }
-  aRenderingContext.SetColor(color);
-
   // Adjust for background-clip, if necessary
-  if (aColor.mBackgroundClip != NS_STYLE_BG_CLIP_BORDER) {
-    NS_ASSERTION(aColor.mBackgroundClip == NS_STYLE_BG_CLIP_PADDING, "unknown background-clip value");
+  if (aColor.mBottomLayer->mClip != NS_STYLE_BG_CLIP_BORDER) {
+    NS_ASSERTION(aColor.mBottomLayer->mClip ==
+                   NS_STYLE_BG_CLIP_PADDING,
+                 "unknown background-clip value");
 
     // Get the radius to the outer edge of the padding.
     // -moz-border-radius is the radius to the outer edge of the border.
     NS_FOR_CSS_SIDES(side) {
       aTheRadius[side] -= aBorder.GetActualBorderWidth(side);
       aTheRadius[side] = PR_MAX(aTheRadius[side], 0);
     }
   }
@@ -2471,17 +2542,16 @@ PaintRoundedBackground(nsPresContext* aP
     if (radii[i].width > 0.0)
       radii[i].width += 1.0;
     if (radii[i].height > 0.0)
       radii[i].height += 1.0;
   }
 
   ctx->NewPath();
   ctx->RoundedRectangle(oRect, radii);
-  ctx->SetColor(gfxRGBA(color));
   ctx->Fill();
 }
 
 
 // Begin table border-collapsing section
 // These functions were written to not disrupt the normal ones and yet satisfy some additional requirements
 // At some point, all functions should be unified to include the additional functionality that these provide
 
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -494,36 +494,37 @@ nsDisplayBackground::IsOpaque(nsDisplayL
 
   const nsStyleBackground* bg;
   PRBool isCanvas; // not used
   PRBool hasBG =
     nsCSSRendering::FindBackground(mFrame->PresContext(), mFrame,
                                    &bg, &isCanvas);
 
   return (hasBG && NS_GET_A(bg->mBackgroundColor) == 255 &&
-          bg->mBackgroundClip == NS_STYLE_BG_CLIP_BORDER &&
+          bg->mBottomLayer->mClip == NS_STYLE_BG_CLIP_BORDER &&
           !nsLayoutUtils::HasNonZeroSide(mFrame->GetStyleBorder()->
                                          mBorderRadius));
 }
 
 PRBool
 nsDisplayBackground::IsUniform(nsDisplayListBuilder* aBuilder) {
   // theme background overrides any other background
   if (mIsThemed)
     return PR_FALSE;
 
   PRBool isCanvas;
   const nsStyleBackground* bg;
   PRBool hasBG =
     nsCSSRendering::FindBackground(mFrame->PresContext(), mFrame, &bg, &isCanvas);
   if (!hasBG)
     return PR_TRUE;
-  if ((bg->mBackgroundFlags & NS_STYLE_BG_IMAGE_NONE) &&
+  if (!bg->mBottomLayer->mImage &&
+      !bg->mBottomLayer->mHigherLayer &&
       !nsLayoutUtils::HasNonZeroSide(mFrame->GetStyleBorder()->mBorderRadius) &&
-      bg->mBackgroundClip == NS_STYLE_BG_CLIP_BORDER)
+      bg->mBottomLayer->mClip == NS_STYLE_BG_CLIP_BORDER)
     return PR_TRUE;
   return PR_FALSE;
 }
 
 PRBool
 nsDisplayBackground::IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder)
 {
   NS_ASSERTION(aBuilder->IsMovingFrame(mFrame),
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1223,16 +1223,17 @@ nsPresContext::DoLoadImage(nsPresContext
   imgIRequest *request = loader->GetRequest();
 
   return request;
 }
 
 imgIRequest*
 nsPresContext::LoadImage(imgIRequest* aImage, nsIFrame* aTargetFrame)
 {
+  // XXX REWRITE TO HANDLE MULTIPLE IMAGES!
   return DoLoadImage(mImageLoaders, aImage, aTargetFrame, PR_FALSE);
 }
 
 imgIRequest*
 nsPresContext::LoadBorderImage(imgIRequest* aImage, nsIFrame* aTargetFrame)
 {
   return DoLoadImage(mBorderImageLoaders, aImage, aTargetFrame,
                      aTargetFrame->GetStyleBorder()->ImageBorderDiffers());
diff --git a/layout/base/nsStyleConsts.h b/layout/base/nsStyleConsts.h
--- a/layout/base/nsStyleConsts.h
+++ b/layout/base/nsStyleConsts.h
@@ -198,24 +198,16 @@
 #define NS_STYLE_COLOR_INVERT             2
 #endif
 
 // See nsStyleColor
 #define NS_COLOR_MOZ_HYPERLINKTEXT              -1
 #define NS_COLOR_MOZ_VISITEDHYPERLINKTEXT       -2
 #define NS_COLOR_MOZ_ACTIVEHYPERLINKTEXT        -3
 #define NS_COLOR_CURRENTCOLOR                   -4
-
-// See nsStyleBackground
-// 0x01 was background-color:transparent
-#define NS_STYLE_BG_IMAGE_NONE                  0x02
-#define NS_STYLE_BG_X_POSITION_PERCENT          0x04
-#define NS_STYLE_BG_X_POSITION_LENGTH           0x08
-#define NS_STYLE_BG_Y_POSITION_PERCENT          0x10
-#define NS_STYLE_BG_Y_POSITION_LENGTH           0x20
 
 // See nsStyleBackground
 #define NS_STYLE_BG_ATTACHMENT_SCROLL     0
 #define NS_STYLE_BG_ATTACHMENT_FIXED      1
 
 // See nsStyleBackground
 #define NS_STYLE_BG_CLIP_BORDER           0
 #define NS_STYLE_BG_CLIP_PADDING          1
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -392,19 +392,40 @@ protected:
   PRBool ParseTreePseudoElement(nsCSSSelector& aSelector);
 #endif
 
   void InitBoxPropsAsPhysical(const nsCSSProperty *aSourceProperties);
 
   // Property specific parsing routines
   PRBool ParseAzimuth(nsCSSValue& aValue);
   PRBool ParseBackground();
+
+  struct BackgroundItem;
+  friend struct BackgroundItem;
+  struct BackgroundItem {
+    nsCSSValue mImage;
+    nsCSSValue mRepeat;
+    nsCSSValue mAttachment;
+    nsCSSValuePair mPosition;
+    nsCSSValue mClip;
+    nsCSSValue mOrigin;
+    // The background-color is set as a side-effect, and if so, mLastItem
+    // is set to true.
+    PRBool mLastItem;
+  };
+  struct BackgroundItemSimpleValueInfo {
+    nsCSSValue BackgroundItem::*member;
+    nsCSSProperty propID;
+  };
+
+  PRBool ParseBackgroundItem(BackgroundItem& aItem, PRBool aFirstItem);
+
+  PRBool ParseBackgroundList(nsCSSProperty aPropID); // a single value prop-id
+  PRBool ParseBackgroundColor();
   PRBool ParseBackgroundPosition();
-  PRBool ParseBackgroundPositionValues();
-  PRBool ParseBoxPosition(nsCSSValuePair& aOut);
   PRBool ParseBoxPositionValues(nsCSSValuePair& aOut);
   PRBool ParseBorderColor();
   PRBool ParseBorderColors(nsCSSValueList** aResult,
                            nsCSSProperty aProperty);
   PRBool ParseBorderImage();
   PRBool ParseBorderSpacing();
   PRBool ParseBorderSide(const nsCSSProperty aPropIDs[],
                          PRBool aSetAllSides);
@@ -4730,16 +4751,22 @@ CSSParserImpl::ParseProperty(nsCSSProper
 {
   NS_ASSERTION(aPropID < eCSSProperty_COUNT, "index out of range");
 
   switch (aPropID) {  // handle shorthand or multiple properties
   case eCSSProperty_background:
     return ParseBackground();
   case eCSSProperty_background_position:
     return ParseBackgroundPosition();
+  case eCSSProperty_background_attachment:
+  case eCSSProperty__moz_background_clip:
+  case eCSSProperty_background_image:
+  case eCSSProperty__moz_background_origin:
+  case eCSSProperty_background_repeat:
+    return ParseBackgroundList(aPropID);
   case eCSSProperty_border:
     return ParseBorderSide(kBorderTopIDs, PR_TRUE);
   case eCSSProperty_border_color:
     return ParseBorderColor();
   case eCSSProperty_border_spacing:
     return ParseBorderSpacing();
   case eCSSProperty_border_style:
     return ParseBorderStyle();
@@ -4968,16 +4995,17 @@ CSSParserImpl::ParseProperty(nsCSSProper
 
 PRBool
 CSSParserImpl::ParseSingleValueProperty(nsCSSValue& aValue,
                                         nsCSSProperty aPropID)
 {
   switch (aPropID) {
   case eCSSProperty_UNKNOWN:
   case eCSSProperty_background:
+  case eCSSProperty_background_color:
   case eCSSProperty_background_position:
   case eCSSProperty_border:
   case eCSSProperty_border_color:
   case eCSSProperty_border_bottom_colors:
   case eCSSProperty_border_image:
   case eCSSProperty_border_left_colors:
   case eCSSProperty_border_right_colors:
   case eCSSProperty_border_end_color:
@@ -5072,32 +5100,35 @@ CSSParserImpl::ParseSingleValueProperty(
     return PR_FALSE;
 
   case eCSSProperty_appearance:
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kAppearanceKTable);
   case eCSSProperty_azimuth:
     return ParseAzimuth(aValue);
   case eCSSProperty_background_attachment:
+    // Used only internally.
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundAttachmentKTable);
   case eCSSProperty__moz_background_clip:
+    // Used only internally.
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundClipKTable);
-  case eCSSProperty_background_color:
-    return ParseVariant(aValue, VARIANT_HC, nsnull);
   case eCSSProperty_background_image:
+    // Used only internally.
     return ParseVariant(aValue, VARIANT_HUO, nsnull);
   case eCSSProperty__moz_background_inline_policy:
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundInlinePolicyKTable);
   case eCSSProperty__moz_background_origin:
+    // Used only internally.
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundOriginKTable);
   case eCSSProperty_background_repeat:
+    // Used only internally.
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundRepeatKTable);
   case eCSSProperty_binding:
     return ParseVariant(aValue, VARIANT_HUO, nsnull);
   case eCSSProperty_border_collapse:
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBorderCollapseKTable);
   case eCSSProperty_border_bottom_color:
@@ -5622,193 +5653,364 @@ BoxPositionMaskToCSSValue(PRInt32 aMask,
   return nsCSSValue(val, eCSSUnit_Enumerated);
 }
 
 PRBool
 CSSParserImpl::ParseBackground()
 {
   nsAutoParseCompoundProperty compound(this);
 
+  // These two are set through side-effects of ParseBackgroundItem.
+  mTempData.mColor.mBackColor.mXValue.SetColorValue(NS_RGBA(0, 0, 0, 0));
+  mTempData.mColor.mBackColor.mYValue.SetColorValue(NS_RGBA(0, 0, 0, 0));
+
+  BackgroundItem bgitem;
+  nsCSSValuePairList *positionHead = nsnull, **positionTail = &positionHead;
+  static const BackgroundItemSimpleValueInfo simpleValues[] = {
+    { &BackgroundItem::mImage,      eCSSProperty_background_image },
+    { &BackgroundItem::mRepeat,     eCSSProperty_background_repeat },
+    { &BackgroundItem::mAttachment, eCSSProperty_background_attachment },
+    { &BackgroundItem::mClip,       eCSSProperty__moz_background_clip },
+    { &BackgroundItem::mOrigin,     eCSSProperty__moz_background_origin }
+  };
+  nsCSSValueList *simpleHeads[NS_ARRAY_LENGTH(simpleValues)];
+  nsCSSValueList **simpleTails[NS_ARRAY_LENGTH(simpleValues)];
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(simpleValues); ++i) {
+    simpleHeads[i] = nsnull;
+    simpleTails[i] = &simpleHeads[i];
+  }
+  for (;;) {
+    if (!ParseBackgroundItem(bgitem, !positionHead)) {
+      break;
+    }
+    nsCSSValuePairList *positionItem = new nsCSSValuePairList;
+    if (!positionItem) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    positionItem->mXValue = bgitem.mPosition.mXValue;
+    positionItem->mYValue = bgitem.mPosition.mYValue;
+    *positionTail = positionItem;
+    positionTail = &positionItem->mNext;
+
+    PRBool fail = PR_FALSE;
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(simpleValues); ++i) {
+      nsCSSValueList *item = new nsCSSValueList;
+      if (!item) {
+        mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+        fail = PR_TRUE;
+        break;
+      }
+      item->mValue = bgitem.*(simpleValues[i].member);
+      *simpleTails[i] = item;
+      simpleTails[i] = &item->mNext;
+    }
+    if (fail) {
+      break;
+    }
+
+    if (!bgitem.mLastItem && ExpectSymbol(',', PR_TRUE)) {
+      continue;
+    }
+    if (!ExpectEndProperty()) {
+      break;
+    }
+
+    mTempData.mColor.mBackPosition = positionHead;
+    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(simpleValues); ++i) {
+      nsCSSValueList **source = static_cast<nsCSSValueList**>(
+        mTempData.PropertyAt(simpleValues[i].propID));
+      *source = simpleHeads[i];
+    }
+
+    mTempData.SetPropertyBit(eCSSProperty_background_color);
+    mTempData.SetPropertyBit(eCSSProperty_background_image);
+    mTempData.SetPropertyBit(eCSSProperty_background_repeat);
+    mTempData.SetPropertyBit(eCSSProperty_background_attachment);
+    mTempData.SetPropertyBit(eCSSProperty_background_position);
+    mTempData.SetPropertyBit(eCSSProperty__moz_background_clip);
+    mTempData.SetPropertyBit(eCSSProperty__moz_background_origin);
+    return PR_TRUE;
+  }
+  delete positionHead;
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(simpleValues); ++i) {
+    delete simpleHeads[i];
+  }
+  return PR_FALSE;
+}
+
+// Parse one item of the background shorthand property.
+PRBool
+CSSParserImpl::ParseBackgroundItem(CSSParserImpl::BackgroundItem& aItem,
+                                   PRBool aFirstItem)
+{
   // Fill in the values that the shorthand will set if we don't find
   // other values.
-  mTempData.mColor.mBackColor.SetColorValue(NS_RGBA(0, 0, 0, 0));
-  mTempData.SetPropertyBit(eCSSProperty_background_color);
-  mTempData.mColor.mBackImage.SetNoneValue();
-  mTempData.SetPropertyBit(eCSSProperty_background_image);
-  mTempData.mColor.mBackRepeat.SetIntValue(NS_STYLE_BG_REPEAT_XY,
+  aItem.mImage.SetNoneValue();
+  aItem.mRepeat.SetIntValue(NS_STYLE_BG_REPEAT_XY,
                                            eCSSUnit_Enumerated);
-  mTempData.SetPropertyBit(eCSSProperty_background_repeat);
-  mTempData.mColor.mBackAttachment.SetIntValue(NS_STYLE_BG_ATTACHMENT_SCROLL,
+  aItem.mAttachment.SetIntValue(NS_STYLE_BG_ATTACHMENT_SCROLL,
                                                eCSSUnit_Enumerated);
-  mTempData.SetPropertyBit(eCSSProperty_background_attachment);
-  mTempData.mColor.mBackPosition.mXValue.SetPercentValue(0.0f);
-  mTempData.mColor.mBackPosition.mYValue.SetPercentValue(0.0f);
-  mTempData.SetPropertyBit(eCSSProperty_background_position);
-  // including the ones that we can't set from the shorthand.
-  mTempData.mColor.mBackClip.SetInitialValue();
-  mTempData.SetPropertyBit(eCSSProperty__moz_background_clip);
-  mTempData.mColor.mBackOrigin.SetInitialValue();
-  mTempData.SetPropertyBit(eCSSProperty__moz_background_origin);
-  mTempData.mColor.mBackInlinePolicy.SetInitialValue();
-  mTempData.SetPropertyBit(eCSSProperty__moz_background_inline_policy);
-
-  // XXX If ParseSingleValueProperty were table-driven (bug 376079) and
-  // automatically filled in the right field of mTempData, we could move
-  // ParseBackgroundPosition to it (as a special case) and switch back
-  // to using ParseChoice here.
-
+  aItem.mPosition.mXValue.SetPercentValue(0.0f);
+  aItem.mPosition.mYValue.SetPercentValue(0.0f);
+  aItem.mClip.SetInitialValue();
+  aItem.mOrigin.SetInitialValue();
+  aItem.mLastItem = PR_FALSE;
+
+  // NOTE:  When we support 'background-size', we'll need to modify
+  // ParseBackgroundColor and the background-size parsing to be less
+  // greedy about '/'s if the thing after them fails to parse.  (Or,
+  // hopefully, the spec will change so we don't have to.)
   PRBool haveColor = PR_FALSE,
          haveImage = PR_FALSE,
          haveRepeat = PR_FALSE,
          haveAttach = PR_FALSE,
-         havePosition = PR_FALSE;
+         havePosition = PR_FALSE,
+         haveOrigin = PR_FALSE,
+         haveSomething = PR_FALSE;
   while (GetToken(PR_TRUE)) {
     nsCSSTokenType tt = mToken.mType;
     UngetToken(); // ...but we'll still cheat and use mToken
     if (tt == eCSSToken_Symbol) {
       // ExpectEndProperty only looks for symbols, and nothing else will
       // show up as one.
       break;
     }
 
     if (tt == eCSSToken_Ident) {
       nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(mToken.mIdent);
       PRInt32 dummy;
       if (keyword == eCSSKeyword_inherit ||
           keyword == eCSSKeyword__moz_initial) {
-        if (haveColor || haveImage || haveRepeat || haveAttach || havePosition)
+        if (haveSomething || !aFirstItem)
           return PR_FALSE;
         haveColor = haveImage = haveRepeat = haveAttach = havePosition =
           PR_TRUE;
         GetToken(PR_TRUE); // undo the UngetToken above
         nsCSSValue val;
         if (keyword == eCSSKeyword_inherit) {
           val.SetInheritValue();
         } else {
           val.SetInitialValue();
         }
-        mTempData.mColor.mBackColor = val;
-        mTempData.mColor.mBackImage = val;
-        mTempData.mColor.mBackRepeat = val;
-        mTempData.mColor.mBackAttachment = val;
-        mTempData.mColor.mBackPosition.mXValue = val;
-        mTempData.mColor.mBackPosition.mYValue = val;
-        // Reset (for 'inherit') the 3 properties that can't be
-        // specified, although it's not entirely clear in the spec:
-        // http://lists.w3.org/Archives/Public/www-style/2007Mar/0110
-        mTempData.mColor.mBackClip = val;
-        mTempData.mColor.mBackOrigin = val;
-        mTempData.mColor.mBackInlinePolicy = val;
+        mTempData.mColor.mBackColor.mXValue = val;
+        mTempData.mColor.mBackColor.mYValue = val;
+        aItem.mImage = val;
+        aItem.mRepeat = val;
+        aItem.mAttachment = val;
+        aItem.mPosition.mXValue = val;
+        aItem.mPosition.mYValue = val;
+        aItem.mClip = val;
+        aItem.mOrigin = val;
+        aItem.mLastItem = PR_TRUE;
         break;
       } else if (keyword == eCSSKeyword_none) {
         if (haveImage)
           return PR_FALSE;
         haveImage = PR_TRUE;
-        if (!ParseSingleValueProperty(mTempData.mColor.mBackImage,
+        if (!ParseSingleValueProperty(aItem.mImage,
                                       eCSSProperty_background_image)) {
           NS_NOTREACHED("should be able to parse");
           return PR_FALSE;
         }
       } else if (nsCSSProps::FindKeyword(keyword,
                    nsCSSProps::kBackgroundAttachmentKTable, dummy)) {
         if (haveAttach)
           return PR_FALSE;
         haveAttach = PR_TRUE;
-        if (!ParseSingleValueProperty(mTempData.mColor.mBackAttachment,
+        if (!ParseSingleValueProperty(aItem.mAttachment,
                                       eCSSProperty_background_attachment)) {
           NS_NOTREACHED("should be able to parse");
           return PR_FALSE;
         }
       } else if (nsCSSProps::FindKeyword(keyword,
                    nsCSSProps::kBackgroundRepeatKTable, dummy)) {
         if (haveRepeat)
           return PR_FALSE;
         haveRepeat = PR_TRUE;
-        if (!ParseSingleValueProperty(mTempData.mColor.mBackRepeat,
+        if (!ParseSingleValueProperty(aItem.mRepeat,
                                       eCSSProperty_background_repeat)) {
           NS_NOTREACHED("should be able to parse");
           return PR_FALSE;
         }
       } else if (nsCSSProps::FindKeyword(keyword,
                    nsCSSProps::kBackgroundPositionKTable, dummy)) {
         if (havePosition)
           return PR_FALSE;
         havePosition = PR_TRUE;
-        if (!ParseBackgroundPositionValues()) {
-          return PR_FALSE;
-        }
+        if (!ParseBoxPositionValues(aItem.mPosition)) {
+          return PR_FALSE;
+        }
+      } else if (nsCSSProps::FindKeyword(keyword,
+                   nsCSSProps::kBackgroundOriginKTable, dummy)) {
+        if (haveOrigin)
+          return PR_FALSE;
+        haveOrigin = PR_TRUE;
+        if (!ParseSingleValueProperty(aItem.mOrigin,
+                                      eCSSProperty__moz_background_origin)) {
+          NS_NOTREACHED("should be able to parse");
+          return PR_FALSE;
+        }
+        // When we support 'no-clip', this needs to be conditional on haveClip:
+        aItem.mClip = aItem.mOrigin;
+      // We'd support 'no-clip' as an additional |else| here.
       } else {
         if (haveColor)
           return PR_FALSE;
         haveColor = PR_TRUE;
-        if (!ParseSingleValueProperty(mTempData.mColor.mBackColor,
-                                      eCSSProperty_background_color)) {
-          return PR_FALSE;
-        }
+        if (!ParseBackgroundColor()) {
+          return PR_FALSE;
+        }
+        aItem.mLastItem = PR_TRUE;
       }
     } else if (eCSSToken_Function == tt &&
                mToken.mIdent.LowerCaseEqualsLiteral("url")) {
       if (haveImage)
         return PR_FALSE;
       haveImage = PR_TRUE;
-      if (!ParseSingleValueProperty(mTempData.mColor.mBackImage,
+      if (!ParseSingleValueProperty(aItem.mImage,
                                     eCSSProperty_background_image)) {
         return PR_FALSE;
       }
     } else if (mToken.IsDimension() || tt == eCSSToken_Percentage) {
       if (havePosition)
         return PR_FALSE;
       havePosition = PR_TRUE;
-      if (!ParseBackgroundPositionValues()) {
+      if (!ParseBoxPositionValues(aItem.mPosition)) {
         return PR_FALSE;
       }
     } else {
       if (haveColor)
         return PR_FALSE;
       haveColor = PR_TRUE;
-      if (!ParseSingleValueProperty(mTempData.mColor.mBackColor,
-                                    eCSSProperty_background_color)) {
-        return PR_FALSE;
-      }
-    }
-  }
-
-  return ExpectEndProperty() &&
-         (haveColor || haveImage || haveRepeat || haveAttach || havePosition);
+      // Note: ParseBackgroundColor parses 'inherit' and 'initial', but
+      // we've already checked for them, so it's ok.
+      if (!ParseBackgroundColor()) {
+        return PR_FALSE;
+      }
+    }
+    haveSomething = PR_TRUE;
+  }
+
+  return haveSomething;
+}
+
+PRBool
+CSSParserImpl::ParseBackgroundList(nsCSSProperty aPropID)
+{
+  // aPropID is a single value prop-id
+  nsCSSValue value;
+  nsCSSValueList *head = nsnull, **tail = &head;
+  for (;;) {
+    if (!ParseSingleValueProperty(value, aPropID)) {
+      break;
+    }
+    nsCSSValueList *item = new nsCSSValueList;
+    if (!item) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    item->mValue = value;
+    *tail = item;
+    tail = &item->mNext;
+    if (ExpectSymbol(',', PR_TRUE)) {
+      continue;
+    }
+    if (!ExpectEndProperty()) {
+      break;
+    }
+    nsCSSValueList **source =
+      static_cast<nsCSSValueList**>(mTempData.PropertyAt(aPropID));
+    *source = head;
+    mTempData.SetPropertyBit(aPropID);
+    return PR_TRUE;
+  }
+  delete head;
+  return PR_FALSE;
+}
+
+PRBool
+CSSParserImpl::ParseBackgroundColor()
+{
+  nsCSSValuePair &backColor = mTempData.mColor.mBackColor;
+  if (!GetToken(PR_TRUE)) {
+    return PR_FALSE;
+  }
+  if (eCSSToken_Symbol == mToken.mType && mToken.mSymbol == '/') {
+    // "If the color before the slash is missing, it is assumed to be
+    // 'transparent'." (css3-background, 4.1)
+    backColor.mXValue.SetColorValue(NS_RGBA(0, 0, 0, 0));
+  } else {
+    UngetToken();
+    if (!ParseVariant(backColor.mXValue, VARIANT_HC, nsnull)) {
+      return PR_FALSE;
+    }
+    backColor.mYValue = backColor.mXValue;
+  }
+  switch (backColor.mXValue.GetUnit()) {
+    case eCSSUnit_Inherit:
+    case eCSSUnit_Initial:
+      return PR_TRUE; // we're done
+    default:
+      break;
+  }
+  if (!GetToken(PR_TRUE)) {
+    return PR_TRUE;
+  }
+  if (eCSSToken_Symbol == mToken.mType && mToken.mSymbol == '/') {
+    if (!ParseVariant(backColor.mYValue, VARIANT_HC, nsnull)) {
+      return PR_FALSE;
+    }
+  } else {
+    UngetToken();
+  }
+  return ExpectEndProperty();
 }
 
 PRBool
 CSSParserImpl::ParseBackgroundPosition()
 {
-  if (!ParseBoxPosition(mTempData.mColor.mBackPosition))
-    return PR_FALSE;
-  mTempData.SetPropertyBit(eCSSProperty_background_position);
-  return PR_TRUE;
-}
-
-PRBool
-CSSParserImpl::ParseBackgroundPositionValues()
-{
-  return ParseBoxPositionValues(mTempData.mColor.mBackPosition);
+  // aPropID is a single value prop-id
+  nsCSSValuePair valuePair;
+  nsCSSValuePairList *head = nsnull, **tail = &head;
+  for (;;) {
+    if (!ParseBoxPositionValues(valuePair)) {
+      break;
+    }
+    nsCSSValuePairList *item = new nsCSSValuePairList;
+    if (!item) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    item->mXValue = valuePair.mXValue;
+    item->mYValue = valuePair.mYValue;
+    *tail = item;
+    tail = &item->mNext;
+    if (ExpectSymbol(',', PR_TRUE)) {
+      continue;
+    }
+    if (!ExpectEndProperty()) {
+      break;
+    }
+    mTempData.mColor.mBackPosition = head;
+    mTempData.SetPropertyBit(eCSSProperty_background_position);
+    return PR_TRUE;
+  }
+  delete head;
+  return PR_FALSE;
 }
 
 /**
  * Parses two values that correspond to positions in a box.  These can be
  * values corresponding to percentages of the box, raw offsets, or keywords
  * like "top," "left center," etc.
  *
  * @param aOut The nsCSSValuePair where to place the result.
  * @return Whether or not the operation succeeded.
  */
-PRBool CSSParserImpl::ParseBoxPosition(nsCSSValuePair &aOut)
-{
-  // Need to read the box positions and the end of the property.
-  return ParseBoxPositionValues(aOut) && ExpectEndProperty();
-}
-
 PRBool CSSParserImpl::ParseBoxPositionValues(nsCSSValuePair &aOut)
 {
   // First try a percentage or a length value
   nsCSSValue &xValue = aOut.mXValue,
              &yValue = aOut.mYValue;
   if (ParseVariant(xValue, VARIANT_HLP, nsnull)) {
     if (eCSSUnit_Inherit == xValue.GetUnit() ||
         eCSSUnit_Initial == xValue.GetUnit()) {  // both are inherited or both are set to initial
@@ -7022,17 +7224,18 @@ PRBool CSSParserImpl::ParseMozTransform(
   mTempData.mDisplay.mTransform = transformList;
 
   return PR_TRUE;
 }
 
 PRBool CSSParserImpl::ParseMozTransformOrigin()
 {
   /* Read in a box position, fail if we can't. */
-  if (!ParseBoxPosition(mTempData.mDisplay.mTransformOrigin))
+  if (!ParseBoxPositionValues(mTempData.mDisplay.mTransformOrigin) ||
+      !ExpectEndProperty())
     return PR_FALSE;
 
   /* Set the property bit and return. */
   mTempData.SetPropertyBit(eCSSProperty__moz_transform_origin);
   return PR_TRUE;
 }
 
 PRBool
diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -269,24 +269,24 @@ CSS_PROP_OUTLINE(-moz-outline-radius-top
 CSS_PROP_OUTLINE(-moz-outline-radius-topright, _moz_outline_radius_topRight, MozOutlineRadiusTopright, Margin, mOutlineRadius.mRight, eCSSType_Value, nsnull)
 CSS_PROP_OUTLINE(-moz-outline-radius-bottomleft, _moz_outline_radius_bottomLeft, MozOutlineRadiusBottomleft, Margin, mOutlineRadius.mLeft, eCSSType_Value, nsnull)
 CSS_PROP_OUTLINE(-moz-outline-radius-bottomright, _moz_outline_radius_bottomRight, MozOutlineRadiusBottomright, Margin, mOutlineRadius.mBottom, eCSSType_Value, nsnull)
 #ifndef CSS_PROP_LIST_EXCLUDE_INTERNAL
 CSS_PROP_FONT(-x-system-font, _x_system_font, X, Font, mSystemFont, eCSSType_Value, kFontKTable)
 #endif
 CSS_PROP_BACKENDONLY(azimuth, azimuth, Azimuth, Aural, mAzimuth, eCSSType_Value, kAzimuthKTable)
 CSS_PROP_SHORTHAND(background, background, Background)
-CSS_PROP_BACKGROUND(background-attachment, background_attachment, BackgroundAttachment, Color, mBackAttachment, eCSSType_Value, kBackgroundAttachmentKTable)
-CSS_PROP_BACKGROUND(-moz-background-clip, _moz_background_clip, MozBackgroundClip, Color, mBackClip, eCSSType_Value, kBackgroundClipKTable)
-CSS_PROP_BACKGROUND(background-color, background_color, BackgroundColor, Color, mBackColor, eCSSType_Value, nsnull)
-CSS_PROP_BACKGROUND(background-image, background_image, BackgroundImage, Color, mBackImage, eCSSType_Value, nsnull)
+CSS_PROP_BACKGROUND(background-attachment, background_attachment, BackgroundAttachment, Color, mBackAttachment, eCSSType_ValueList, kBackgroundAttachmentKTable)
+CSS_PROP_BACKGROUND(-moz-background-clip, _moz_background_clip, MozBackgroundClip, Color, mBackClip, eCSSType_ValueList, kBackgroundClipKTable)
+CSS_PROP_BACKGROUND(background-color, background_color, BackgroundColor, Color, mBackColor, eCSSType_ValuePair, nsnull)
+CSS_PROP_BACKGROUND(background-image, background_image, BackgroundImage, Color, mBackImage, eCSSType_ValueList, nsnull)
 CSS_PROP_BACKGROUND(-moz-background-inline-policy, _moz_background_inline_policy, MozBackgroundInlinePolicy, Color, mBackInlinePolicy, eCSSType_Value, kBackgroundInlinePolicyKTable)
-CSS_PROP_BACKGROUND(-moz-background-origin, _moz_background_origin, MozBackgroundOrigin, Color, mBackOrigin, eCSSType_Value, kBackgroundOriginKTable)
-CSS_PROP_BACKGROUND(background-position, background_position, BackgroundPosition, Color, mBackPosition, eCSSType_ValuePair, kBackgroundPositionKTable)
-CSS_PROP_BACKGROUND(background-repeat, background_repeat, BackgroundRepeat, Color, mBackRepeat, eCSSType_Value, kBackgroundRepeatKTable)
+CSS_PROP_BACKGROUND(-moz-background-origin, _moz_background_origin, MozBackgroundOrigin, Color, mBackOrigin, eCSSType_ValueList, kBackgroundOriginKTable)
+CSS_PROP_BACKGROUND(background-position, background_position, BackgroundPosition, Color, mBackPosition, eCSSType_ValuePairList, kBackgroundPositionKTable)
+CSS_PROP_BACKGROUND(background-repeat, background_repeat, BackgroundRepeat, Color, mBackRepeat, eCSSType_ValueList, kBackgroundRepeatKTable)
 CSS_PROP_DISPLAY(-moz-binding, binding, MozBinding, Display, mBinding, eCSSType_Value, nsnull) // XXX bug 3935
 CSS_PROP_SHORTHAND(border, border, Border)
 CSS_PROP_SHORTHAND(border-bottom, border_bottom, BorderBottom)
 CSS_PROP_BORDER(border-bottom-color, border_bottom_color, BorderBottomColor, Margin, mBorderColor.mBottom, eCSSType_Value, kBorderColorKTable)
 CSS_PROP_BORDER(-moz-border-bottom-colors, border_bottom_colors, MozBorderBottomColors, Margin, mBorderColors.mBottom, eCSSType_ValueList, nsnull)
 CSS_PROP_BORDER(border-bottom-style, border_bottom_style, BorderBottomStyle, Margin, mBorderStyle.mBottom, eCSSType_Value, kBorderStyleKTable)  // on/off will need reflow
 CSS_PROP_BORDER(border-bottom-width, border_bottom_width, BorderBottomWidth, Margin, mBorderWidth.mBottom, eCSSType_Value, kBorderWidthKTable)
 CSS_PROP_TABLEBORDER(border-collapse, border_collapse, BorderCollapse, Table, mBorderCollapse, eCSSType_Value, kBorderCollapseKTable)
diff --git a/layout/style/nsCSSStruct.cpp b/layout/style/nsCSSStruct.cpp
--- a/layout/style/nsCSSStruct.cpp
+++ b/layout/style/nsCSSStruct.cpp
@@ -110,23 +110,36 @@ nsCSSValueList::Equal(nsCSSValueList* aL
       return PR_FALSE;
   }
   return !p1 && !p2; // true if same length, false otherwise
 }
 
 // --- nsCSSColor -----------------
 
 nsCSSColor::nsCSSColor(void)
+  : mBackImage(nsnull)
+  , mBackRepeat(nsnull)
+  , mBackAttachment(nsnull)
+  , mBackPosition(nsnull)
+  , mBackClip(nsnull)
+  , mBackOrigin(nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSColor);
 }
 
 nsCSSColor::~nsCSSColor(void)
 {
   MOZ_COUNT_DTOR(nsCSSColor);
+
+  CSS_IF_DELETE(mBackImage);
+  CSS_IF_DELETE(mBackRepeat);
+  CSS_IF_DELETE(mBackAttachment);
+  CSS_IF_DELETE(mBackPosition);
+  CSS_IF_DELETE(mBackClip);
+  CSS_IF_DELETE(mBackOrigin);
 }
 
 // --- nsCSSText -----------------
 
 nsCSSText::nsCSSText(void)
   : mTextShadow(nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSText);
diff --git a/layout/style/nsCSSStruct.h b/layout/style/nsCSSStruct.h
--- a/layout/style/nsCSSStruct.h
+++ b/layout/style/nsCSSStruct.h
@@ -214,30 +214,35 @@ private:
   nsRuleDataFont(const nsRuleDataFont& aOther); // NOT IMPLEMENTED
 };
 
 struct nsCSSColor : public nsCSSStruct  {
   nsCSSColor(void);
   ~nsCSSColor(void);
 
   nsCSSValue      mColor;
-  nsCSSValue      mBackColor;
-  nsCSSValue      mBackImage;
-  nsCSSValue      mBackRepeat;
-  nsCSSValue      mBackAttachment;
-  nsCSSValuePair  mBackPosition;
-  nsCSSValue      mBackClip;
-  nsCSSValue      mBackOrigin;
+  nsCSSValuePair  mBackColor;
+  nsCSSValueList* mBackImage;
+  nsCSSValueList* mBackRepeat;
+  nsCSSValueList* mBackAttachment;
+  nsCSSValuePairList* mBackPosition;
+  nsCSSValueList* mBackClip;
+  nsCSSValueList* mBackOrigin;
   nsCSSValue      mBackInlinePolicy;
 private:
   nsCSSColor(const nsCSSColor& aOther); // NOT IMPLEMENTED
 };
 
 struct nsRuleDataColor : public nsCSSColor {
   nsRuleDataColor() {}
+
+  // A little bit of a hack here:  now that background-image is
+  // represented by a value list, attribute mapping code needs a place
+  // to store one item in a value list in order to map a simple value.
+  nsCSSValueList mTempBackImage;
 private:
   nsRuleDataColor(const nsRuleDataColor& aOther); // NOT IMPLEMENTED
 };
 
 struct nsCSSText : public nsCSSStruct  {
   nsCSSText(void);
   ~nsCSSText(void);
 
diff --git a/layout/style/nsComputedDOMStyle.cpp b/layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp
+++ b/layout/style/nsComputedDOMStyle.cpp
@@ -1163,81 +1163,132 @@ nsComputedDOMStyle::GetFontVariant(nsIDO
   } else {
     val->SetIdent(nsGkAtoms::normal);
   }
 
   return CallQueryInterface(val, aValue);
 }
 
 nsresult
+nsComputedDOMStyle::GetBackgroundList(PRUint8 nsStyleBackground::Layer::* aMember,
+                                      PRUint32 nsStyleBackground::* aCount,
+                                      const PRInt32 aTable[],
+                                      nsIDOMCSSValue** aResult)
+{
+  const nsStyleBackground* color = GetStyleBackground();
+
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  const nsStyleBackground::Layer *layer = &color->mTopLayer;
+  for (PRUint32 i = 0, i_end = color->*aCount; i < i_end;
+       ++i, layer = layer->mLowerLayer) {
+    nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
+    if (!val || !valueList->AppendCSSValue(val)) {
+      delete val;
+      delete valueList;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+    val->SetIdent(nsCSSProps::ValueToKeyword(layer->*aMember, aTable));
+  }
+
+  return CallQueryInterface(valueList, aResult);
+}
+
+nsresult
 nsComputedDOMStyle::GetBackgroundAttachment(nsIDOMCSSValue** aValue)
 {
-  nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
-
-  const nsStyleBackground *background = GetStyleBackground();
-
-  const nsAFlatCString& backgroundAttachment =
-    nsCSSProps::ValueToKeyword(background->mBackgroundAttachment,
-                               nsCSSProps::kBackgroundAttachmentKTable);
-  val->SetIdent(backgroundAttachment);
-
-  return CallQueryInterface(val, aValue);
+  return GetBackgroundList(&nsStyleBackground::Layer::mAttachment,
+                           &nsStyleBackground::mAttachmentCount,
+                           nsCSSProps::kBackgroundAttachmentKTable,
+                           aValue);
 }
 
 nsresult
 nsComputedDOMStyle::GetBackgroundClip(nsIDOMCSSValue** aValue)
 {
-  nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
-
-  const nsAFlatCString& backgroundClip =
-    nsCSSProps::ValueToKeyword(GetStyleBackground()->mBackgroundClip,
-                               nsCSSProps::kBackgroundClipKTable);
-
-  val->SetIdent(backgroundClip);
-
-  return CallQueryInterface(val, aValue);
+  return GetBackgroundList(&nsStyleBackground::Layer::mClip,
+                           &nsStyleBackground::mClipCount,
+                           nsCSSProps::kBackgroundClipKTable,
+                           aValue);
 }
 
 nsresult
 nsComputedDOMStyle::GetBackgroundColor(nsIDOMCSSValue** aValue)
 {
-  nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
-
   const nsStyleBackground* color = GetStyleBackground();
-  nsresult rv = SetToRGBAColor(val, color->mBackgroundColor);
-  if (NS_FAILED(rv)) {
-    delete val;
-    return rv;
-  }
-
-  return CallQueryInterface(val, aValue);
+  nsresult rv;
+
+  if (color->mBackgroundColor == color->mFallbackBackgroundColor) {
+    nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
+    NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
+
+    rv = SetToRGBAColor(val, color->mBackgroundColor);
+    if (NS_FAILED(rv)) {
+      delete val;
+      return rv;
+    }
+    rv = CallQueryInterface(val, aValue);
+  } else {
+    nsDOMCSSValueList *valueList = GetROCSSValueList(PR_FALSE);
+    NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+    for (PRUint32 i = 0; i < 3; ++i) {
+      nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
+      if (!val || !valueList->AppendCSSValue(val)) {
+        delete val;
+        delete valueList;
+        return NS_ERROR_OUT_OF_MEMORY;
+      }
+
+      if (i == 1) {
+        val->SetString(NS_LITERAL_STRING("/"));
+      } else {
+        rv = SetToRGBAColor(val, (i == 0) ? color->mBackgroundColor
+                                          : color->mFallbackBackgroundColor);
+        if (NS_FAILED(rv)) {
+          delete valueList;
+          return rv;
+        }
+      }
+    }
+    rv = CallQueryInterface(valueList, aValue);
+  }
+
+  return rv;
 }
 
 nsresult
 nsComputedDOMStyle::GetBackgroundImage(nsIDOMCSSValue** aValue)
 {
-  nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
-  NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
-
   const nsStyleBackground* color = GetStyleBackground();
 
-  if (color->mBackgroundFlags & NS_STYLE_BG_IMAGE_NONE) {
-    val->SetIdent(nsGkAtoms::none);
-  } else {
-    nsCOMPtr<nsIURI> uri;
-    if (color->mBackgroundImage) {
-      color->mBackgroundImage->GetURI(getter_AddRefs(uri));
-    }
-    val->SetURI(uri);
-  }
-
-  return CallQueryInterface(val, aValue);
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  const nsStyleBackground::Layer *layer = &color->mTopLayer;
+  for (PRUint32 i = 0, i_end = color->mImageCount; i < i_end;
+       ++i, layer = layer->mLowerLayer) {
+    nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
+    if (!val || !valueList->AppendCSSValue(val)) {
+      delete val;
+      delete valueList;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    if (!layer->mImage) {
+      val->SetIdent(nsGkAtoms::none);
+    } else {
+      nsCOMPtr<nsIURI> uri;
+      layer->mImage->GetURI(getter_AddRefs(uri));
+      val->SetURI(uri);
+    }
+  }
+
+  return CallQueryInterface(valueList, aValue);
 }
 
 nsresult
 nsComputedDOMStyle::GetBackgroundInlinePolicy(nsIDOMCSSValue** aValue)
 {
   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 
@@ -1248,85 +1299,79 @@ nsComputedDOMStyle::GetBackgroundInlineP
   val->SetIdent(backgroundPolicy);
 
   return CallQueryInterface(val, aValue);  
 }
 
 nsresult
 nsComputedDOMStyle::GetBackgroundOrigin(nsIDOMCSSValue** aValue)
 {
-  nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
-
-  const nsAFlatCString& backgroundOrigin =
-    nsCSSProps::ValueToKeyword(GetStyleBackground()->mBackgroundOrigin,
-                               nsCSSProps::kBackgroundOriginKTable);
-
-  val->SetIdent(backgroundOrigin);
-
-  return CallQueryInterface(val, aValue);
+  return GetBackgroundList(&nsStyleBackground::Layer::mOrigin,
+                           &nsStyleBackground::mOriginCount,
+                           nsCSSProps::kBackgroundOriginKTable,
+                           aValue);
 }
 
 nsresult
 nsComputedDOMStyle::GetBackgroundPosition(nsIDOMCSSValue** aValue)
 {
-  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_FALSE);
-  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
-
-  nsROCSSPrimitiveValue *valX = GetROCSSPrimitiveValue();
-  if (!valX || !valueList->AppendCSSValue(valX)) {
-    delete valueList;
-    delete valX;
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-
-  nsROCSSPrimitiveValue *valY = GetROCSSPrimitiveValue();
-  if (!valY || !valueList->AppendCSSValue(valY)) {
-    delete valueList;
-    delete valY;
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-
-  const nsStyleBackground *bg = GetStyleBackground();
-
-  if (NS_STYLE_BG_X_POSITION_LENGTH & bg->mBackgroundFlags) {
-    valX->SetAppUnits(bg->mBackgroundXPosition.mCoord);
-  }
-  else if (NS_STYLE_BG_X_POSITION_PERCENT & bg->mBackgroundFlags) {
-    valX->SetPercent(bg->mBackgroundXPosition.mFloat);
-  }
-  else {
-    valX->SetPercent(0.0f);
-  }
-
-  if (NS_STYLE_BG_Y_POSITION_LENGTH & bg->mBackgroundFlags) {
-    valY->SetAppUnits(bg->mBackgroundYPosition.mCoord);
-  }
-  else if (NS_STYLE_BG_Y_POSITION_PERCENT & bg->mBackgroundFlags) {
-    valY->SetPercent(bg->mBackgroundYPosition.mFloat);
-  }
-  else {
-    valY->SetPercent(0.0f);
+  const nsStyleBackground* color = GetStyleBackground();
+
+  nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
+  NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
+
+  const nsStyleBackground::Layer *layer = &color->mTopLayer;
+  for (PRUint32 i = 0, i_end = color->mPositionCount; i < i_end;
+       ++i, layer = layer->mLowerLayer) {
+    nsDOMCSSValueList *itemList = GetROCSSValueList(PR_FALSE);
+    if (!itemList || !valueList->AppendCSSValue(itemList)) {
+      delete valueList;
+      delete itemList;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    nsROCSSPrimitiveValue *valX = GetROCSSPrimitiveValue();
+    if (!valX || !itemList->AppendCSSValue(valX)) {
+      delete valueList;
+      delete valX;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    nsROCSSPrimitiveValue *valY = GetROCSSPrimitiveValue();
+    if (!valY || !itemList->AppendCSSValue(valY)) {
+      delete valueList;
+      delete valY;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    const nsStyleBackground::Position &pos = layer->mPosition;
+
+    if (pos.mXIsPercent) {
+      valX->SetPercent(pos.mXPosition.mFloat);
+    } else {
+      valX->SetAppUnits(pos.mXPosition.mCoord);
+    }
+
+    if (pos.mYIsPercent) {
+      valY->SetPercent(pos.mYPosition.mFloat);
+    } else {
+      valY->SetAppUnits(pos.mYPosition.mCoord);
+    }
   }
 
   return CallQueryInterface(valueList, aValue);  
 }
 
 nsresult
 nsComputedDOMStyle::GetBackgroundRepeat(nsIDOMCSSValue** aValue)
 {
-  nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
-  NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
-
-  const nsAFlatCString& backgroundRepeat =
-    nsCSSProps::ValueToKeyword(GetStyleBackground()->mBackgroundRepeat,
-                               nsCSSProps::kBackgroundRepeatKTable);
-  val->SetIdent(backgroundRepeat);
-
-  return CallQueryInterface(val, aValue);
+  return GetBackgroundList(&nsStyleBackground::Layer::mRepeat,
+                           &nsStyleBackground::mRepeatCount,
+                           nsCSSProps::kBackgroundRepeatKTable,
+                           aValue);
 }
 
 nsresult
 nsComputedDOMStyle::GetPadding(nsIDOMCSSValue** aValue)
 {
   // return null per spec.
   aValue = nsnull;
 
@@ -1794,17 +1839,17 @@ nsComputedDOMStyle::GetCSSShadowArray(ns
     shadowValues = shadowValuesNoSpread;
     shadowValuesLength = NS_ARRAY_LENGTH(shadowValuesNoSpread);
   }
 
   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
 
   for (nsCSSShadowItem *item = aArray->ShadowAt(0),
-                    *item_end = item + aArray->Length();
+                   *item_end = item + aArray->Length();
        item < item_end; ++item) {
     nsDOMCSSValueList *itemList = GetROCSSValueList(PR_FALSE);
     if (!itemList || !valueList->AppendCSSValue(itemList)) {
       delete itemList;
       delete valueList;
       return NS_ERROR_OUT_OF_MEMORY;
     }
 
diff --git a/layout/style/nsComputedDOMStyle.h b/layout/style/nsComputedDOMStyle.h
--- a/layout/style/nsComputedDOMStyle.h
+++ b/layout/style/nsComputedDOMStyle.h
@@ -50,16 +50,17 @@
 #include "nsCSSProps.h"
 
 #include "nsIPresShell.h"
 #include "nsIContent.h"
 #include "nsIFrame.h"
 #include "nsCOMPtr.h"
 #include "nsWeakReference.h"
 #include "nsAutoPtr.h"
+#include "nsStyleStruct.h"
 
 class nsComputedDOMStyle : public nsIComputedDOMStyle
 {
 public:
   NS_DECL_ISUPPORTS
 
   NS_IMETHOD Init(nsIDOMElement *aElement,
                   const nsAString& aPseudoElt,
@@ -109,16 +110,21 @@ private:
   nsresult GetMarginWidthFor(PRUint8 aSide, nsIDOMCSSValue** aValue);
 
   PRBool GetLineHeightCoord(nscoord& aCoord);
 
   nsresult GetCSSShadowArray(nsCSSShadowArray* aArray,
                              const nscolor& aDefaultColor,
                              PRBool aUsesSpread,
                              nsIDOMCSSValue** aValue);
+
+  nsresult GetBackgroundList(PRUint8 nsStyleBackground::Layer::* aMember,
+                             PRUint32 nsStyleBackground::* aCount,
+                             const PRInt32 aTable[],
+                             nsIDOMCSSValue** aResult);
 
   /* Properties Queryable as CSSValues */
 
   nsresult GetAppearance(nsIDOMCSSValue** aValue);
 
   /* Box properties */
   nsresult GetBoxAlign(nsIDOMCSSValue** aValue);
   nsresult GetBoxDirection(nsIDOMCSSValue** aValue);
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -3582,139 +3582,311 @@ nsRuleNode::ComputeColorData(void* aStar
   else {
     SetColor(colorData.mColor, parentColor->mColor, mPresContext, aContext, color->mColor, 
              inherited);
   }
 
   COMPUTE_END_INHERITED(Color, color)
 }
 
+// information about how to compute values for background-* properties
+template <class SpecifiedValueItem>
+struct InitialInheritLocationFor {
+};
+
+NS_SPECIALIZE_TEMPLATE
+struct InitialInheritLocationFor<nsCSSValueList> {
+  static nsCSSValue nsCSSValueList::* Location() {
+    return &nsCSSValueList::mValue;
+  }
+};
+
+NS_SPECIALIZE_TEMPLATE
+struct InitialInheritLocationFor<nsCSSValuePairList> {
+  static nsCSSValue nsCSSValuePairList::* Location() {
+    return &nsCSSValuePairList::mXValue;
+  }
+};
+
+template <class SpecifiedValueItem, class ComputedValueItem>
+struct BackgroundItemComputer {
+};
+
+NS_SPECIALIZE_TEMPLATE
+struct BackgroundItemComputer<nsCSSValueList, PRUint8>
+{
+  static void ComputeValue(nsStyleContext* aStyleContext,
+                           const nsCSSValueList* aSpecifiedValue,
+                           PRUint8& aComputedValue,
+                           PRBool& aInherited)
+  {
+    SetDiscrete(aSpecifiedValue->mValue, aComputedValue, aInherited,
+                SETDSC_ENUMERATED, PRUint8(0), 0, 0, 0, 0, 0);
+  }
+};
+
+NS_SPECIALIZE_TEMPLATE
+struct BackgroundItemComputer<nsCSSValueList, nsCOMPtr<imgIRequest> >
+{
+  static void ComputeValue(nsStyleContext* aStyleContext,
+                           const nsCSSValueList* aSpecifiedValue,
+                           nsCOMPtr<imgIRequest>& aComputedValue,
+                           PRBool& aInherited)
+  {
+    const nsCSSValue &value = aSpecifiedValue->mValue;
+    if (eCSSUnit_Image == value.GetUnit()) {
+      aComputedValue = value.GetImageValue();
+    }
+    else {
+      NS_ASSERTION(eCSSUnit_None == value.GetUnit(), "unexpected unit");
+      aComputedValue = nsnull;
+    }
+  }
+};
+
+struct BackgroundPositionAxis {
+  nsCSSValue nsCSSValuePairList::*specified;
+  nsStyleBackground::Position::PositionCoord
+    nsStyleBackground::Position::*result;
+  PRPackedBool nsStyleBackground::Position::*isPercent;
+};
+
+static const BackgroundPositionAxis gBGPosAxes[] = {
+  { &nsCSSValuePairList::mXValue,
+    &nsStyleBackground::Position::mXPosition,
+    &nsStyleBackground::Position::mXIsPercent },
+  { &nsCSSValuePairList::mYValue,
+    &nsStyleBackground::Position::mYPosition,
+    &nsStyleBackground::Position::mYIsPercent }
+};
+
+NS_SPECIALIZE_TEMPLATE
+struct BackgroundItemComputer<nsCSSValuePairList, nsStyleBackground::Position>
+{
+  static void ComputeValue(nsStyleContext* aStyleContext,
+                           const nsCSSValuePairList* aSpecifiedValue,
+                           nsStyleBackground::Position& aComputedValue,
+                           PRBool& aInherited)
+  {
+    nsStyleBackground::Position &position = aComputedValue;
+    for (const BackgroundPositionAxis *axis = gBGPosAxes,
+                        *axis_end = gBGPosAxes + NS_ARRAY_LENGTH(gBGPosAxes);
+         axis != axis_end; ++axis) {
+      const nsCSSValue &specified = aSpecifiedValue->*(axis->specified);
+      if (eCSSUnit_Percent == specified.GetUnit()) {
+        (position.*(axis->result)).mFloat = specified.GetPercentValue();
+        position.*(axis->isPercent) = PR_TRUE;
+      }
+      else if (specified.IsLengthUnit()) {
+        (position.*(axis->result)).mCoord =
+          CalcLength(specified, aStyleContext, aStyleContext->PresContext(),
+                     aInherited);
+        position.*(axis->isPercent) = PR_FALSE;
+      }
+      else if (eCSSUnit_Enumerated == specified.GetUnit()) {
+        (position.*(axis->result)).mFloat =
+          GetFloatFromBoxPosition(specified.GetIntValue());
+        position.*(axis->isPercent) = PR_TRUE;
+      } else {
+        NS_NOTREACHED("unexpected unit");
+      }
+    }
+  }
+};
+
+
+template <class SpecifiedValueItem, class ComputedValueItem>
+static void
+SetBackgroundList(nsStyleContext* aStyleContext,
+                  const SpecifiedValueItem* aValueList,
+                  nsStyleBackground::Layer *aTopLayer,
+                  const nsStyleBackground::Layer *aParentTopLayer,
+                  ComputedValueItem nsStyleBackground::Layer::* aResultLocation,
+                  ComputedValueItem aInitialValue,
+                  PRUint32 aParentItemCount,
+                  PRUint32& aItemCount,
+                  PRUint32& aMaxItemCount,
+                  PRBool& aRebuild,
+                  PRBool& aInherited)
+{
+  if (aValueList) {
+    nsCSSValue SpecifiedValueItem::* initialInherit =
+      InitialInheritLocationFor<SpecifiedValueItem>::Location();
+    if (eCSSUnit_Inherit == (aValueList->*initialInherit).GetUnit()) {
+      aInherited = PR_TRUE;
+      nsStyleBackground::Layer *layer = aTopLayer;
+      const nsStyleBackground::Layer *parentLayer = aParentTopLayer;
+      aItemCount = 0;
+      for (;;) {
+        ++aItemCount;
+        layer->*aResultLocation = parentLayer->*aResultLocation;
+        if (--aParentItemCount == 0) {
+          break;
+        }
+        layer = layer->GetOrMakeLowerLayer();
+        if (!layer) {
+          NS_NOTREACHED("out of memory");
+          break;
+        }
+        parentLayer = parentLayer->mLowerLayer;
+      }
+    } else if (eCSSUnit_Initial == (aValueList->*initialInherit).GetUnit()) {
+      aItemCount = 1;
+      aTopLayer->*aResultLocation = aInitialValue;
+    } else {
+      nsStyleBackground::Layer *layer = aTopLayer;
+      const SpecifiedValueItem *item = aValueList;
+      aItemCount = 0;
+      for (;;) {
+        NS_ASSERTION((item->*initialInherit).GetUnit() != eCSSUnit_Inherit &&
+                     (item->*initialInherit).GetUnit() != eCSSUnit_Initial,
+                     "unexpected unit");
+        ++aItemCount;
+        BackgroundItemComputer<SpecifiedValueItem, ComputedValueItem>
+          ::ComputeValue(aStyleContext, item, layer->*aResultLocation,
+                         aInherited);
+        item = item->mNext;
+        if (!item) {
+          break;
+        }
+        layer = layer->GetOrMakeLowerLayer();
+        if (!layer) {
+          NS_NOTREACHED("out of memory");
+          break;
+        }
+      }
+    }
+  }
+
+  if (aItemCount > aMaxItemCount)
+    aMaxItemCount = aItemCount;
+}
+
+template <class ComputedValueItem>
+static void
+FillBackgroundList(nsStyleBackground::Layer *aTopLayer,
+    ComputedValueItem nsStyleBackground::Layer::* aResultLocation,
+    PRUint32 aItemCount, PRUint32 aMaxItemCount)
+{
+  if (aItemCount == aMaxItemCount)
+    return;
+  nsStyleBackground::Layer *destLayer = aTopLayer;
+  do {
+    destLayer = destLayer->mLowerLayer;
+  } while (--aItemCount != 0);
+  NS_ASSERTION(destLayer, "incorrect item count");
+
+  nsStyleBackground::Layer *sourceLayer = aTopLayer;
+
+  do {
+    destLayer->*aResultLocation = sourceLayer->*aResultLocation;
+    destLayer = destLayer->mLowerLayer;
+    sourceLayer = sourceLayer->mLowerLayer;
+  } while (destLayer);
+}
+
 const void*
 nsRuleNode::ComputeBackgroundData(void* aStartStruct,
                                   const nsRuleDataStruct& aData, 
                                   nsStyleContext* aContext, 
                                   nsRuleNode* aHighestNode,
                                   const RuleDetail aRuleDetail,
                                   PRBool aInherited)
 {
   COMPUTE_START_RESET(Background, (), bg, parentBG, Color, colorData)
 
-  // save parentFlags in case bg == parentBG and we clobber them later
-  PRUint8 parentFlags = parentBG->mBackgroundFlags;
-
-  // background-color: color, string, inherit
-  if (eCSSUnit_Initial == colorData.mBackColor.GetUnit()) {
+  // background-color: color, string, inherit [pair]
+  if (eCSSUnit_Initial == colorData.mBackColor.mXValue.GetUnit()) {
     bg->mBackgroundColor = NS_RGBA(0, 0, 0, 0);
-  } else if (!SetColor(colorData.mBackColor, parentBG->mBackgroundColor,
-                       mPresContext, aContext, bg->mBackgroundColor,
-                       inherited)) {
-    NS_ASSERTION(eCSSUnit_Null == colorData.mBackColor.GetUnit(),
+  } else if (!SetColor(colorData.mBackColor.mXValue,
+                       parentBG->mBackgroundColor, mPresContext,
+                       aContext, bg->mBackgroundColor, inherited)) {
+    NS_ASSERTION(eCSSUnit_Null == colorData.mBackColor.mXValue.GetUnit(),
                  "unexpected color unit");
   }
 
-  // background-image: url (stored as image), none, inherit
-  if (eCSSUnit_Image == colorData.mBackImage.GetUnit()) {
-    bg->mBackgroundImage = colorData.mBackImage.GetImageValue();
-  }
-  else if (eCSSUnit_None == colorData.mBackImage.GetUnit() ||
-           eCSSUnit_Initial == colorData.mBackImage.GetUnit()) {
-    bg->mBackgroundImage = nsnull;
-  }
-  else if (eCSSUnit_Inherit == colorData.mBackImage.GetUnit()) {
-    inherited = PR_TRUE;
-    bg->mBackgroundImage = parentBG->mBackgroundImage;
-  }
-
-  if (bg->mBackgroundImage) {
-    bg->mBackgroundFlags &= ~NS_STYLE_BG_IMAGE_NONE;
-  } else {
-    bg->mBackgroundFlags |= NS_STYLE_BG_IMAGE_NONE;
-  }
-
-  // background-repeat: enum, inherit, initial
-  SetDiscrete(colorData.mBackRepeat, bg->mBackgroundRepeat, inherited,
-              SETDSC_ENUMERATED, parentBG->mBackgroundRepeat,
-              NS_STYLE_BG_REPEAT_XY, 0, 0, 0, 0);
-
-  // background-attachment: enum, inherit, initial
-  SetDiscrete(colorData.mBackAttachment, bg->mBackgroundAttachment, inherited,
-              SETDSC_ENUMERATED, parentBG->mBackgroundAttachment,
-              NS_STYLE_BG_ATTACHMENT_SCROLL, 0, 0, 0, 0);
-
-  // background-clip: enum, inherit, initial
-  SetDiscrete(colorData.mBackClip, bg->mBackgroundClip, inherited,
-              SETDSC_ENUMERATED, parentBG->mBackgroundClip,
-              NS_STYLE_BG_CLIP_BORDER, 0, 0, 0, 0);
+  if (eCSSUnit_Initial == colorData.mBackColor.mYValue.GetUnit()) {
+    bg->mFallbackBackgroundColor = NS_RGBA(0, 0, 0, 0);
+  } else if (!SetColor(colorData.mBackColor.mYValue,
+                       parentBG->mFallbackBackgroundColor, mPresContext,
+                       aContext, bg->mFallbackBackgroundColor, inherited)) {
+    NS_ASSERTION(eCSSUnit_Null == colorData.mBackColor.mYValue.GetUnit(),
+                 "unexpected color unit");
+  }
+
+  PRUint32 maxItemCount = 1;
+  PRBool rebuild = PR_FALSE;
+
+  // background-image: url (stored as image), none, inherit [list]
+  SetBackgroundList(aContext, colorData.mBackImage, &bg->mTopLayer,
+                    &parentBG->mTopLayer, &nsStyleBackground::Layer::mImage,
+                    nsCOMPtr<imgIRequest>(nsnull), parentBG->mImageCount,
+                    bg->mImageCount, maxItemCount, rebuild, inherited);
+
+  // background-repeat: enum, inherit, initial [list]
+  SetBackgroundList(aContext, colorData.mBackRepeat, &bg->mTopLayer,
+                    &parentBG->mTopLayer, &nsStyleBackground::Layer::mRepeat,
+                    PRUint8(NS_STYLE_BG_REPEAT_XY), parentBG->mRepeatCount,
+                    bg->mRepeatCount, maxItemCount, rebuild, inherited);
+
+  // background-attachment: enum, inherit, initial [list]
+  SetBackgroundList(aContext, colorData.mBackAttachment, &bg->mTopLayer,
+                    &parentBG->mTopLayer, &nsStyleBackground::Layer::mAttachment,
+                    PRUint8(NS_STYLE_BG_ATTACHMENT_SCROLL), parentBG->mAttachmentCount,
+                    bg->mAttachmentCount, maxItemCount, rebuild, inherited);
+
+  // background-clip: enum, inherit, initial [list]
+  SetBackgroundList(aContext, colorData.mBackClip, &bg->mTopLayer,
+                    &parentBG->mTopLayer, &nsStyleBackground::Layer::mClip,
+                    PRUint8(NS_STYLE_BG_CLIP_BORDER), parentBG->mClipCount,
+                    bg->mClipCount, maxItemCount, rebuild, inherited);
 
   // background-inline-policy: enum, inherit, initial
   SetDiscrete(colorData.mBackInlinePolicy, bg->mBackgroundInlinePolicy,
               inherited, SETDSC_ENUMERATED,
               parentBG->mBackgroundInlinePolicy,
               NS_STYLE_BG_INLINE_POLICY_CONTINUOUS, 0, 0, 0, 0);
 
-  // background-origin: enum, inherit, initial
-  SetDiscrete(colorData.mBackOrigin, bg->mBackgroundOrigin, inherited,
-              SETDSC_ENUMERATED, parentBG->mBackgroundOrigin,
-              NS_STYLE_BG_ORIGIN_PADDING, 0, 0, 0, 0);
-
-  // background-position: enum, length, percent (flags), inherit
-  if (eCSSUnit_Percent == colorData.mBackPosition.mXValue.GetUnit()) {
-    bg->mBackgroundXPosition.mFloat = colorData.mBackPosition.mXValue.GetPercentValue();
-    bg->mBackgroundFlags |= NS_STYLE_BG_X_POSITION_PERCENT;
-    bg->mBackgroundFlags &= ~NS_STYLE_BG_X_POSITION_LENGTH;
-  }
-  else if (colorData.mBackPosition.mXValue.IsLengthUnit()) {
-    bg->mBackgroundXPosition.mCoord = CalcLength(colorData.mBackPosition.mXValue, 
-                                                 aContext, mPresContext, inherited);
-    bg->mBackgroundFlags |= NS_STYLE_BG_X_POSITION_LENGTH;
-    bg->mBackgroundFlags &= ~NS_STYLE_BG_X_POSITION_PERCENT;
-  }
-  else if (eCSSUnit_Enumerated == colorData.mBackPosition.mXValue.GetUnit()) {
-    bg->mBackgroundXPosition.mFloat =
-      GetFloatFromBoxPosition(colorData.mBackPosition.mXValue.GetIntValue());
-
-    bg->mBackgroundFlags |= NS_STYLE_BG_X_POSITION_PERCENT;
-    bg->mBackgroundFlags &= ~NS_STYLE_BG_X_POSITION_LENGTH;
-  }
-  else if (eCSSUnit_Inherit == colorData.mBackPosition.mXValue.GetUnit()) {
-    inherited = PR_TRUE;
-    bg->mBackgroundXPosition = parentBG->mBackgroundXPosition;
-    bg->mBackgroundFlags &= ~(NS_STYLE_BG_X_POSITION_LENGTH | NS_STYLE_BG_X_POSITION_PERCENT);
-    bg->mBackgroundFlags |= (parentFlags & (NS_STYLE_BG_X_POSITION_LENGTH | NS_STYLE_BG_X_POSITION_PERCENT));
-  }
-  else if (eCSSUnit_Initial == colorData.mBackPosition.mXValue.GetUnit()) {
-    bg->mBackgroundFlags &= ~(NS_STYLE_BG_X_POSITION_LENGTH | NS_STYLE_BG_X_POSITION_PERCENT);
-  }
-
-  if (eCSSUnit_Percent == colorData.mBackPosition.mYValue.GetUnit()) {
-    bg->mBackgroundYPosition.mFloat = colorData.mBackPosition.mYValue.GetPercentValue();
-    bg->mBackgroundFlags |= NS_STYLE_BG_Y_POSITION_PERCENT;
-    bg->mBackgroundFlags &= ~NS_STYLE_BG_Y_POSITION_LENGTH;
-  }
-  else if (colorData.mBackPosition.mYValue.IsLengthUnit()) {
-    bg->mBackgroundYPosition.mCoord = CalcLength(colorData.mBackPosition.mYValue,
-                                                 aContext, mPresContext, inherited);
-    bg->mBackgroundFlags |= NS_STYLE_BG_Y_POSITION_LENGTH;
-    bg->mBackgroundFlags &= ~NS_STYLE_BG_Y_POSITION_PERCENT;
-  }
-  else if (eCSSUnit_Enumerated == colorData.mBackPosition.mYValue.GetUnit()) {
-    bg->mBackgroundYPosition.mFloat =
-      GetFloatFromBoxPosition(colorData.mBackPosition.mYValue.GetIntValue());
-
-    bg->mBackgroundFlags |= NS_STYLE_BG_Y_POSITION_PERCENT;
-    bg->mBackgroundFlags &= ~NS_STYLE_BG_Y_POSITION_LENGTH;
-  }
-  else if (eCSSUnit_Inherit == colorData.mBackPosition.mYValue.GetUnit()) {
-    inherited = PR_TRUE;
-    bg->mBackgroundYPosition = parentBG->mBackgroundYPosition;
-    bg->mBackgroundFlags &= ~(NS_STYLE_BG_Y_POSITION_LENGTH | NS_STYLE_BG_Y_POSITION_PERCENT);
-    bg->mBackgroundFlags |= (parentFlags & (NS_STYLE_BG_Y_POSITION_LENGTH | NS_STYLE_BG_Y_POSITION_PERCENT));
-  }
-  else if (eCSSUnit_Initial == colorData.mBackPosition.mYValue.GetUnit()) {
-    bg->mBackgroundFlags &= ~(NS_STYLE_BG_Y_POSITION_LENGTH | NS_STYLE_BG_Y_POSITION_PERCENT);
+  // background-origin: enum, inherit, initial [list]
+  SetBackgroundList(aContext, colorData.mBackOrigin, &bg->mTopLayer,
+                    &parentBG->mTopLayer, &nsStyleBackground::Layer::mOrigin,
+                    PRUint8(NS_STYLE_BG_ORIGIN_PADDING), parentBG->mOriginCount,
+                    bg->mOriginCount, maxItemCount, rebuild, inherited);
+
+  // background-position: enum, length, percent (flags), inherit [pair list]
+  nsStyleBackground::Position
+    initialPosition(nsStyleBackground::Position::INIT_WITH_INITIAL_VALUES);
+  SetBackgroundList(aContext, colorData.mBackPosition, &bg->mTopLayer,
+                    &parentBG->mTopLayer, &nsStyleBackground::Layer::mPosition,
+                    initialPosition, parentBG->mPositionCount,
+                    bg->mPositionCount, maxItemCount, rebuild, inherited);
+
+  if (rebuild) {
+    // Delete any extra items and set mBottomLayer correctly.
+    nsStyleBackground::Layer *bottom = &bg->mTopLayer;
+    PRUint32 keepCount = maxItemCount; // at least 1
+    while (--keepCount != 0) {
+      bottom = bottom->mLowerLayer;
+    }
+    delete bottom->mLowerLayer;
+    bottom->mLowerLayer = nsnull;
+    bg->mBottomLayer = bottom;
+
+    FillBackgroundList(&bg->mTopLayer, &nsStyleBackground::Layer::mImage,
+                       bg->mImageCount, maxItemCount);
+    FillBackgroundList(&bg->mTopLayer, &nsStyleBackground::Layer::mRepeat,
+                       bg->mRepeatCount, maxItemCount);
+    FillBackgroundList(&bg->mTopLayer, &nsStyleBackground::Layer::mAttachment,
+                       bg->mAttachmentCount, maxItemCount);
+    FillBackgroundList(&bg->mTopLayer, &nsStyleBackground::Layer::mClip,
+                       bg->mClipCount, maxItemCount);
+    FillBackgroundList(&bg->mTopLayer, &nsStyleBackground::Layer::mOrigin,
+                       bg->mOriginCount, maxItemCount);
+    FillBackgroundList(&bg->mTopLayer, &nsStyleBackground::Layer::mPosition,
+                       bg->mPositionCount, maxItemCount);
   }
 
   COMPUTE_END_RESET(Background, bg)
 }
 
 const void*
 nsRuleNode::ComputeMarginData(void* aStartStruct,
                               const nsRuleDataStruct& aData, 
@@ -5249,16 +5421,17 @@ nsRuleNode::Sweep()
 }
 
 /* static */ PRBool
 nsRuleNode::HasAuthorSpecifiedRules(nsStyleContext* aStyleContext,
                                     PRUint32 ruleTypeMask)
 {
   nsRuleDataColor colorData;
   nsRuleDataMargin marginData;
+  nsCSSValue firstBackgroundImage;
   PRUint32 nValues = 0;
 
   PRUint32 inheritBits = 0;
   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BACKGROUND)
     inheritBits |= NS_STYLE_INHERIT_BIT(Background);
 
   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BORDER)
     inheritBits |= NS_STYLE_INHERIT_BIT(Border);
@@ -5268,18 +5441,19 @@ nsRuleNode::HasAuthorSpecifiedRules(nsSt
 
   /* We're relying on the use of |aStyleContext| not mutating it! */
   nsRuleData ruleData(inheritBits,
                       aStyleContext->PresContext(), aStyleContext);
   ruleData.mColorData = &colorData;
   ruleData.mMarginData = &marginData;
 
   nsCSSValue* backgroundValues[] = {
-    &colorData.mBackColor,
-    &colorData.mBackImage
+    &colorData.mBackColor.mXValue,
+    &colorData.mBackColor.mYValue,
+    &firstBackgroundImage
   };
 
   nsCSSValue* borderValues[] = {
     &marginData.mBorderColor.mTop,
     &marginData.mBorderStyle.mTop,
     &marginData.mBorderWidth.mTop,
     &marginData.mBorderColor.mRight,
     &marginData.mBorderStyle.mRight,
@@ -5329,16 +5503,22 @@ nsRuleNode::HasAuthorSpecifiedRules(nsSt
     if (rule) {
       ruleData.mLevel = ruleNode->GetLevel();
       ruleData.mIsImportantRule = ruleNode->IsImportantRule();
       rule->MapRuleInfoInto(&ruleData);
       // Do the same nulling out as in GetBorderData, GetBackgroundData
       // or GetPaddingData.
       // We are sharing with some style rule.  It really owns the data.
       marginData.mBoxShadow = nsnull;
+      if ((ruleTypeMask & NS_AUTHOR_SPECIFIED_BACKGROUND) &&
+          colorData.mBackImage &&
+          firstBackgroundImage.GetUnit() == eCSSUnit_Null) {
+        // Handle background-image being a value list
+        firstBackgroundImage = colorData.mBackImage->mValue;
+      }
 
       if (ruleData.mLevel == nsStyleSet::eAgentSheet ||
           ruleData.mLevel == nsStyleSet::eUserSheet) {
         // This is a rule whose effect we want to ignore, so if any of
         // the properties we care about were set, set them to the dummy
         // value that they'll never otherwise get.
         for (PRUint32 i = 0; i < nValues; ++i)
           if (values[i]->GetUnit() != eCSSUnit_Null)
diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -613,28 +613,17 @@ void nsStyleContext::DumpRegressionData(
 
   // COLOR
   IndentBy(out,aIndent);
   const nsStyleColor* color = GetStyleColor();
   fprintf(out, "<color data=\"%ld\"/>\n", 
     (long)color->mColor);
 
   // BACKGROUND
-  IndentBy(out,aIndent);
-  const nsStyleBackground* bg = GetStyleBackground();
-  fprintf(out, "<background data=\"%d %d %d %ld %ld %ld %s\"/>\n",
-    (int)bg->mBackgroundAttachment,
-    (int)bg->mBackgroundFlags,
-    (int)bg->mBackgroundRepeat,
-    (long)bg->mBackgroundColor,
-    // XXX These aren't initialized unless flags are set:
-    (long)bg->mBackgroundXPosition.mCoord, // potentially lossy on some platforms
-    (long)bg->mBackgroundYPosition.mCoord, // potentially lossy on some platforms
-    URICString(bg->mBackgroundImage).get());
- 
+
   // SPACING (ie. margin, padding, border, outline)
   IndentBy(out,aIndent);
   fprintf(out, "<spacing data=\"");
 
   const nsStyleMargin* margin = GetStyleMargin();
   margin->mMargin.ToString(str);
   fprintf(out, "%s ", NS_ConvertUTF16toUTF8(str).get());
   
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -1149,78 +1149,175 @@ nsChangeHint nsStyleColor::MaxDifference
 }
 #endif
 
 // --------------------
 // nsStyleBackground
 //
 
 nsStyleBackground::nsStyleBackground()
-  : mBackgroundFlags(NS_STYLE_BG_IMAGE_NONE),
-    mBackgroundAttachment(NS_STYLE_BG_ATTACHMENT_SCROLL),
-    mBackgroundClip(NS_STYLE_BG_CLIP_BORDER),
-    mBackgroundInlinePolicy(NS_STYLE_BG_INLINE_POLICY_CONTINUOUS),
-    mBackgroundOrigin(NS_STYLE_BG_ORIGIN_PADDING),
-    mBackgroundRepeat(NS_STYLE_BG_REPEAT_XY),
-    mBackgroundColor(NS_RGBA(0, 0, 0, 0))
+  : mAttachmentCount(1)
+  , mClipCount(1)
+  , mOriginCount(1)
+  , mRepeatCount(1)
+  , mPositionCount(1)
+  , mImageCount(1)
+  , mTopLayer(nsStyleBackground::Layer::INIT_WITH_INITIAL_VALUES)
+  , mBottomLayer(&mTopLayer)
+  , mBackgroundColor(NS_RGBA(0, 0, 0, 0))
+  , mFallbackBackgroundColor(NS_RGBA(0, 0, 0, 0))
+  , mBackgroundInlinePolicy(NS_STYLE_BG_INLINE_POLICY_CONTINUOUS)
 {
 }
 
 nsStyleBackground::nsStyleBackground(const nsStyleBackground& aSource)
-  : mBackgroundFlags(aSource.mBackgroundFlags),
-    mBackgroundAttachment(aSource.mBackgroundAttachment),
-    mBackgroundClip(aSource.mBackgroundClip),
-    mBackgroundInlinePolicy(aSource.mBackgroundInlinePolicy),
-    mBackgroundOrigin(aSource.mBackgroundOrigin),
-    mBackgroundRepeat(aSource.mBackgroundRepeat),
-    mBackgroundXPosition(aSource.mBackgroundXPosition),
-    mBackgroundYPosition(aSource.mBackgroundYPosition),
-    mBackgroundColor(aSource.mBackgroundColor),
-    mBackgroundImage(aSource.mBackgroundImage)
+  : mAttachmentCount(aSource.mAttachmentCount)
+  , mClipCount(aSource.mClipCount)
+  , mOriginCount(aSource.mOriginCount)
+  , mRepeatCount(aSource.mRepeatCount)
+  , mPositionCount(aSource.mPositionCount)
+  , mImageCount(aSource.mImageCount)
+  , mTopLayer(aSource.mTopLayer)
+  , mBottomLayer(&mTopLayer)
+  , mBackgroundColor(aSource.mBackgroundColor)
+  , mFallbackBackgroundColor(aSource.mFallbackBackgroundColor)
+  , mBackgroundInlinePolicy(aSource.mBackgroundInlinePolicy)
 {
+  // deep copy of the layers
+  nsStyleBackground::Layer *source = aSource.mTopLayer.mLowerLayer,
+                             *dest = &mTopLayer;
+  PRUint32 count = 1;
+  while (source) {
+    nsStyleBackground::Layer *newLayer = new nsStyleBackground::Layer(*source);
+    if (!newLayer) {
+      mAttachmentCount = PR_MAX(mAttachmentCount, count);
+      mClipCount = PR_MAX(mClipCount, count);
+      mOriginCount = PR_MAX(mOriginCount, count);
+      mRepeatCount = PR_MAX(mRepeatCount, count);
+      mPositionCount = PR_MAX(mPositionCount, count);
+      mImageCount = PR_MAX(mImageCount, count);
+      break;
+    }
+    ++count;
+    dest->mLowerLayer = newLayer;
+    newLayer->mHigherLayer = dest;
+    source = source->mLowerLayer;
+    dest = newLayer;
+  }
+  mBottomLayer = dest;
 }
 
 nsStyleBackground::~nsStyleBackground()
 {
 }
 
 nsChangeHint nsStyleBackground::CalcDifference(const nsStyleBackground& aOther) const
 {
-  if ((mBackgroundAttachment == aOther.mBackgroundAttachment) &&
-      (mBackgroundFlags == aOther.mBackgroundFlags) &&
-      (mBackgroundRepeat == aOther.mBackgroundRepeat) &&
-      (mBackgroundColor == aOther.mBackgroundColor) &&
-      (mBackgroundClip == aOther.mBackgroundClip) &&
-      (mBackgroundInlinePolicy == aOther.mBackgroundInlinePolicy) &&
-      (mBackgroundOrigin == aOther.mBackgroundOrigin) &&
-      EqualImages(mBackgroundImage, aOther.mBackgroundImage) &&
-      ((!(mBackgroundFlags & NS_STYLE_BG_X_POSITION_PERCENT) ||
-       (mBackgroundXPosition.mFloat == aOther.mBackgroundXPosition.mFloat)) &&
-       (!(mBackgroundFlags & NS_STYLE_BG_X_POSITION_LENGTH) ||
-        (mBackgroundXPosition.mCoord == aOther.mBackgroundXPosition.mCoord))) &&
-      ((!(mBackgroundFlags & NS_STYLE_BG_Y_POSITION_PERCENT) ||
-       (mBackgroundYPosition.mFloat == aOther.mBackgroundYPosition.mFloat)) &&
-       (!(mBackgroundFlags & NS_STYLE_BG_Y_POSITION_LENGTH) ||
-        (mBackgroundYPosition.mCoord == aOther.mBackgroundYPosition.mCoord))))
-    return NS_STYLE_HINT_NONE;
-  return NS_STYLE_HINT_VISUAL;
+  if (mBackgroundColor != aOther.mBackgroundColor ||
+      mFallbackBackgroundColor != aOther.mFallbackBackgroundColor ||
+      mBackgroundInlinePolicy != aOther.mBackgroundInlinePolicy)
+    return NS_STYLE_HINT_VISUAL;
+
+  const nsStyleBackground::Layer *l1 = &mTopLayer, *l2 = &aOther.mTopLayer;
+  do {
+    if (*l1 != *l2)
+      return NS_STYLE_HINT_VISUAL;
+    l1 = l1->mLowerLayer;
+    l2 = l2->mLowerLayer;
+  } while (l1 && l2);
+
+  if (!l1 != !l2)
+    return NS_STYLE_HINT_VISUAL; // different number of layers
+
+  return NS_STYLE_HINT_NONE;
 }
 
 #ifdef DEBUG
 /* static */
 nsChangeHint nsStyleBackground::MaxDifference()
 {
   return NS_STYLE_HINT_VISUAL;
 }
 #endif
 
 PRBool nsStyleBackground::HasFixedBackground() const
 {
-  return mBackgroundAttachment == NS_STYLE_BG_ATTACHMENT_FIXED &&
-         mBackgroundImage;
+  const nsStyleBackground::Layer *layer = &mTopLayer;
+  do {
+    if (layer->mAttachment == NS_STYLE_BG_ATTACHMENT_FIXED && layer->mImage)
+      return PR_TRUE;
+    layer = layer->mLowerLayer;
+  } while (layer);
+  return PR_FALSE;
+}
+
+PRBool nsStyleBackground::IsTransparent() const
+{
+  return !mTopLayer.mImage && !mTopLayer.mLowerLayer &&
+         NS_GET_A(mBackgroundColor) == 0;
+}
+
+nsStyleBackground::Position::Position(InitWithInitialValuesType)
+{
+  mXPosition.mFloat = 0.0f;
+  mYPosition.mFloat = 0.0f;
+  mXIsPercent = PR_TRUE;
+  mYIsPercent = PR_TRUE;
+}
+
+nsStyleBackground::Layer::Layer()
+  : mLowerLayer(nsnull)
+  , mHigherLayer(nsnull)
+{
+}
+
+nsStyleBackground::Layer::Layer(InitWithInitialValuesType)
+  : mAttachment(NS_STYLE_BG_ATTACHMENT_SCROLL)
+  , mClip(NS_STYLE_BG_CLIP_BORDER)
+  , mOrigin(NS_STYLE_BG_ORIGIN_PADDING)
+  , mRepeat(NS_STYLE_BG_REPEAT_XY)
+  , mPosition(nsStyleBackground::Position::INIT_WITH_INITIAL_VALUES)
+  , mLowerLayer(nsnull)
+  , mHigherLayer(nsnull)
+{
+}
+
+nsStyleBackground::Layer::~Layer()
+{
+  if (mLowerLayer) {
+    // Delete the chain without recursion
+    nsStyleBackground::Layer *next = mLowerLayer;
+    while (next) {
+      nsStyleBackground::Layer *todelete = next;
+      next = next->mLowerLayer;
+      next->mLowerLayer = nsnull;
+      delete todelete;
+    }
+  }
+}
+
+nsStyleBackground::Layer*
+nsStyleBackground::Layer::GetOrMakeLowerLayer()
+{
+  if (!mLowerLayer) {
+    if ((mLowerLayer = new nsStyleBackground::Layer)) {
+      mLowerLayer->mHigherLayer = this;
+    }
+  }
+  return mLowerLayer; // may be null
+}
+
+PRBool nsStyleBackground::Layer::operator==(const Layer& aOther) const
+{
+  return mAttachment == aOther.mAttachment &&
+         mClip == aOther.mClip &&
+         mOrigin == aOther.mOrigin &&
+         mRepeat == aOther.mRepeat &&
+         mPosition == aOther.mPosition &&
+         EqualImages(mImage, aOther.mImage);
 }
 
 // --------------------
 // nsStyleDisplay
 //
 
 nsStyleDisplay::nsStyleDisplay()
 {
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -54,16 +54,17 @@
 #include "nsVoidArray.h"
 #include "nsStyleCoord.h"
 #include "nsStyleConsts.h"
 #include "nsChangeHint.h"
 #include "nsPresContext.h"
 #include "nsIPresShell.h"
 #include "nsCOMPtr.h"
 #include "nsCOMArray.h"
+#include "nsTArray.h"
 #include "nsIAtom.h"
 #include "nsIURI.h"
 #include "nsCSSValue.h"
 #include "nsStyleTransformMatrix.h"
 
 class nsIFrame;
 class imgIRequest;
 
@@ -157,40 +158,98 @@ struct nsStyleBackground {
     aContext->FreeToShell(sizeof(nsStyleBackground), this);
   }
 
   nsChangeHint CalcDifference(const nsStyleBackground& aOther) const;
 #ifdef DEBUG
   static nsChangeHint MaxDifference();
 #endif
 
-  PRUint8 mBackgroundFlags;        // [reset] See nsStyleConsts.h
-  PRUint8 mBackgroundAttachment;   // [reset] See nsStyleConsts.h
-  PRUint8 mBackgroundClip;         // [reset] See nsStyleConsts.h
-  PRUint8 mBackgroundInlinePolicy; // [reset] See nsStyleConsts.h
-  PRUint8 mBackgroundOrigin;       // [reset] See nsStyleConsts.h
-  PRUint8 mBackgroundRepeat;       // [reset] See nsStyleConsts.h
+  struct Position;
+  friend struct Position;
+  struct Position {
+    typedef union {
+      nscoord mCoord; // for lengths
+      float   mFloat; // for percents
+    } PositionCoord;
+    PositionCoord mXPosition, mYPosition;
+    PRPackedBool mXIsPercent, mYIsPercent;
 
-  // Note: a member of this union is valid IFF the appropriate bit flag
-  // is set in mBackgroundFlags.
-  union {
-    nscoord mCoord;
-    float   mFloat;
-  } mBackgroundXPosition,         // [reset]
-    mBackgroundYPosition;         // [reset]
+    enum InitWithInitialValuesType { INIT_WITH_INITIAL_VALUES };
+
+    // Initialize nothing
+    Position() {}
+
+    // Initialize to default values
+    Position(InitWithInitialValuesType);
+
+    PRBool operator==(const Position& aOther) const {
+      return mXIsPercent == aOther.mXIsPercent &&
+             (mXIsPercent ? (mXPosition.mFloat == aOther.mXPosition.mFloat)
+                          : (mXPosition.mCoord == aOther.mXPosition.mCoord)) &&
+             mYIsPercent == aOther.mYIsPercent &&
+             (mYIsPercent ? (mYPosition.mFloat == aOther.mYPosition.mFloat)
+                          : (mYPosition.mCoord == aOther.mYPosition.mCoord));
+    }
+    PRBool operator!=(const Position& aOther) const {
+      return !(*this == aOther);
+    }
+  };
+
+  struct Layer;
+  friend struct Layer;
+  struct Layer {
+    PRUint8 mAttachment;                // [reset] See nsStyleConsts.h
+    PRUint8 mClip;                      // [reset] See nsStyleConsts.h
+    PRUint8 mOrigin;                    // [reset] See nsStyleConsts.h
+    PRUint8 mRepeat;                    // [reset] See nsStyleConsts.h
+    Position mPosition;                 // [reset]
+    nsCOMPtr<imgIRequest> mImage;       // [reset]
+
+    Layer *mLowerLayer;                 // [OWNS]
+    Layer *mHigherLayer;                // [WEAK]
+
+    enum InitWithInitialValuesType { INIT_WITH_INITIAL_VALUES };
+
+    // Initializes only mImage, mLowerLayer, and mHigherLayer.
+    Layer();
+
+    // Initializes everything to CSS initial values.
+    Layer(InitWithInitialValuesType);
+
+    // frees mLowerLayer chain
+    ~Layer();
+
+    Layer* GetOrMakeLowerLayer();
+
+    // An equality operator that compares the images using URL-equality
+    // rather than pointer-equality.  (Does not compare higher/lower.)
+    PRBool operator==(const Layer& aOther) const;
+    PRBool operator!=(const Layer& aOther) const {
+      return !(*this == aOther);
+    }
+  };
+
+  // The (positive) number of computed values of each property, since
+  // the lengths of the lists are independent.
+  PRUint32 mAttachmentCount,
+           mClipCount,
+           mOriginCount,
+           mRepeatCount,
+           mPositionCount,
+           mImageCount;
+  Layer mTopLayer;
+  Layer *mBottomLayer;
 
   nscolor mBackgroundColor;       // [reset]
-  nsCOMPtr<imgIRequest> mBackgroundImage; // [reset]
+  nscolor mFallbackBackgroundColor; // [reset]
+  PRUint8 mBackgroundInlinePolicy; // [reset] See nsStyleConsts.h
 
   // True if this background is completely transparent.
-  PRBool IsTransparent() const
-  {
-    return (NS_GET_A(mBackgroundColor) == 0 &&
-            (mBackgroundFlags & NS_STYLE_BG_IMAGE_NONE));
-  }
+  PRBool IsTransparent() const;
 
   // We have to take slower codepaths for fixed background attachment,
   // but we don't want to do that when there's no image.
   // Not inline because it uses an nsCOMPtr<imgIRequest>
   // FIXME: Should be in nsStyleStructInlines.h.
   PRBool HasFixedBackground() const;
 };
 
