Implement multiple background images.  (Bug 322475)

diff --git a/layout/base/nsStyleConsts.h b/layout/base/nsStyleConsts.h
--- a/layout/base/nsStyleConsts.h
+++ b/layout/base/nsStyleConsts.h
@@ -198,24 +198,16 @@
 #define NS_STYLE_COLOR_INVERT             2
 #endif
 
 // See nsStyleColor
 #define NS_COLOR_MOZ_HYPERLINKTEXT              -1
 #define NS_COLOR_MOZ_VISITEDHYPERLINKTEXT       -2
 #define NS_COLOR_MOZ_ACTIVEHYPERLINKTEXT        -3
 #define NS_COLOR_CURRENTCOLOR                   -4
-
-// See nsStyleBackground
-// 0x01 was background-color:transparent
-#define NS_STYLE_BG_IMAGE_NONE                  0x02
-#define NS_STYLE_BG_X_POSITION_PERCENT          0x04
-#define NS_STYLE_BG_X_POSITION_LENGTH           0x08
-#define NS_STYLE_BG_Y_POSITION_PERCENT          0x10
-#define NS_STYLE_BG_Y_POSITION_LENGTH           0x20
 
 // See nsStyleBackground
 #define NS_STYLE_BG_ATTACHMENT_SCROLL     0
 #define NS_STYLE_BG_ATTACHMENT_FIXED      1
 
 // See nsStyleBackground
 #define NS_STYLE_BG_CLIP_BORDER           0
 #define NS_STYLE_BG_CLIP_PADDING          1
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -392,19 +392,19 @@ protected:
   PRBool ParseTreePseudoElement(nsCSSSelector& aSelector);
 #endif
 
   void InitBoxPropsAsPhysical(const nsCSSProperty *aSourceProperties);
 
   // Property specific parsing routines
   PRBool ParseAzimuth(nsCSSValue& aValue);
   PRBool ParseBackground();
+  PRBool ParseBackgroundList(nsCSSProperty aPropID); // a single value prop-id
+  PRBool ParseBackgroundColor();
   PRBool ParseBackgroundPosition();
-  PRBool ParseBackgroundPositionValues();
-  PRBool ParseBoxPosition(nsCSSValuePair& aOut);
   PRBool ParseBoxPositionValues(nsCSSValuePair& aOut);
   PRBool ParseBorderColor();
   PRBool ParseBorderColors(nsCSSValueList** aResult,
                            nsCSSProperty aProperty);
   PRBool ParseBorderImage();
   PRBool ParseBorderSpacing();
   PRBool ParseBorderSide(const nsCSSProperty aPropIDs[],
                          PRBool aSetAllSides);
@@ -4730,16 +4730,22 @@ CSSParserImpl::ParseProperty(nsCSSProper
 {
   NS_ASSERTION(aPropID < eCSSProperty_COUNT, "index out of range");
 
   switch (aPropID) {  // handle shorthand or multiple properties
   case eCSSProperty_background:
     return ParseBackground();
   case eCSSProperty_background_position:
     return ParseBackgroundPosition();
+  case eCSSProperty_background_attachment:
+  case eCSSProperty__moz_background_clip:
+  case eCSSProperty_background_image:
+  case eCSSProperty__moz_background_origin:
+  case eCSSProperty_background_repeat:
+    return ParseBackgroundList(aPropID);
   case eCSSProperty_border:
     return ParseBorderSide(kBorderTopIDs, PR_TRUE);
   case eCSSProperty_border_color:
     return ParseBorderColor();
   case eCSSProperty_border_spacing:
     return ParseBorderSpacing();
   case eCSSProperty_border_style:
     return ParseBorderStyle();
@@ -4968,16 +4974,17 @@ CSSParserImpl::ParseProperty(nsCSSProper
 
 PRBool
 CSSParserImpl::ParseSingleValueProperty(nsCSSValue& aValue,
                                         nsCSSProperty aPropID)
 {
   switch (aPropID) {
   case eCSSProperty_UNKNOWN:
   case eCSSProperty_background:
+  case eCSSProperty_background_color:
   case eCSSProperty_background_position:
   case eCSSProperty_border:
   case eCSSProperty_border_color:
   case eCSSProperty_border_bottom_colors:
   case eCSSProperty_border_image:
   case eCSSProperty_border_left_colors:
   case eCSSProperty_border_right_colors:
   case eCSSProperty_border_end_color:
@@ -5072,32 +5079,35 @@ CSSParserImpl::ParseSingleValueProperty(
     return PR_FALSE;
 
   case eCSSProperty_appearance:
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kAppearanceKTable);
   case eCSSProperty_azimuth:
     return ParseAzimuth(aValue);
   case eCSSProperty_background_attachment:
+    // Used only internally.
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundAttachmentKTable);
   case eCSSProperty__moz_background_clip:
+    // Used only internally.
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundClipKTable);
-  case eCSSProperty_background_color:
-    return ParseVariant(aValue, VARIANT_HC, nsnull);
   case eCSSProperty_background_image:
+    // Used only internally.
     return ParseVariant(aValue, VARIANT_HUO, nsnull);
   case eCSSProperty__moz_background_inline_policy:
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundInlinePolicyKTable);
   case eCSSProperty__moz_background_origin:
+    // Used only internally.
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundOriginKTable);
   case eCSSProperty_background_repeat:
+    // Used only internally.
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundRepeatKTable);
   case eCSSProperty_binding:
     return ParseVariant(aValue, VARIANT_HUO, nsnull);
   case eCSSProperty_border_collapse:
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBorderCollapseKTable);
   case eCSSProperty_border_bottom_color:
@@ -5642,23 +5652,16 @@ CSSParserImpl::ParseBackground()
   mTempData.mColor.mBackPosition.mXValue.SetPercentValue(0.0f);
   mTempData.mColor.mBackPosition.mYValue.SetPercentValue(0.0f);
   mTempData.SetPropertyBit(eCSSProperty_background_position);
   // including the ones that we can't set from the shorthand.
   mTempData.mColor.mBackClip.SetInitialValue();
   mTempData.SetPropertyBit(eCSSProperty__moz_background_clip);
   mTempData.mColor.mBackOrigin.SetInitialValue();
   mTempData.SetPropertyBit(eCSSProperty__moz_background_origin);
-  mTempData.mColor.mBackInlinePolicy.SetInitialValue();
-  mTempData.SetPropertyBit(eCSSProperty__moz_background_inline_policy);
-
-  // XXX If ParseSingleValueProperty were table-driven (bug 376079) and
-  // automatically filled in the right field of mTempData, we could move
-  // ParseBackgroundPosition to it (as a special case) and switch back
-  // to using ParseChoice here.
 
   PRBool haveColor = PR_FALSE,
          haveImage = PR_FALSE,
          haveRepeat = PR_FALSE,
          haveAttach = PR_FALSE,
          havePosition = PR_FALSE;
   while (GetToken(PR_TRUE)) {
     nsCSSTokenType tt = mToken.mType;
@@ -5727,42 +5730,41 @@ CSSParserImpl::ParseBackground()
           NS_NOTREACHED("should be able to parse");
           return PR_FALSE;
         }
       } else if (nsCSSProps::FindKeyword(keyword,
                    nsCSSProps::kBackgroundPositionKTable, dummy)) {
         if (havePosition)
           return PR_FALSE;
         havePosition = PR_TRUE;
-        if (!ParseBackgroundPositionValues()) {
+        if (!ParseBoxPositionValues(mTempData.mColor.mBackPosition)) {
           return PR_FALSE;
         }
       } else {
         if (haveColor)
           return PR_FALSE;
         haveColor = PR_TRUE;
-        if (!ParseSingleValueProperty(mTempData.mColor.mBackColor,
-                                      eCSSProperty_background_color)) {
+        if (!ParseBackgroundColor()) {
           return PR_FALSE;
         }
       }
     } else if (eCSSToken_Function == tt &&
                mToken.mIdent.LowerCaseEqualsLiteral("url")) {
       if (haveImage)
         return PR_FALSE;
       haveImage = PR_TRUE;
       if (!ParseSingleValueProperty(mTempData.mColor.mBackImage,
                                     eCSSProperty_background_image)) {
         return PR_FALSE;
       }
     } else if (mToken.IsDimension() || tt == eCSSToken_Percentage) {
       if (havePosition)
         return PR_FALSE;
       havePosition = PR_TRUE;
-      if (!ParseBackgroundPositionValues()) {
+      if (!ParseBoxPositionValues(mTempData.mColor.mBackPosition)) {
         return PR_FALSE;
       }
     } else {
       if (haveColor)
         return PR_FALSE;
       haveColor = PR_TRUE;
       if (!ParseSingleValueProperty(mTempData.mColor.mBackColor,
                                     eCSSProperty_background_color)) {
@@ -5771,44 +5773,130 @@ CSSParserImpl::ParseBackground()
     }
   }
 
   return ExpectEndProperty() &&
          (haveColor || haveImage || haveRepeat || haveAttach || havePosition);
 }
 
 PRBool
+CSSParserImpl::ParseBackgroundList(nsCSSProperty aPropID)
+{
+  // aPropID is a single value prop-id
+  nsCSSValue value;
+  nsCSSValueList *head = nsnull, **tail = &head;
+  do {
+    if (!ParseSingleValueProperty(value, aPropID)) {
+      break;
+    }
+    nsCSSValueList *item = new nsCSSValueList;
+    if (!item) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    item->mValue = value;
+    *tail = item;
+    tail = &item->mNext;
+    if (ExpectSymbol(',', PR_TRUE)) {
+      continue;
+    }
+    if (!ExpectEndProperty()) {
+      break;
+    }
+    nsCSSValueList **source =
+      static_cast<nsCSSValueList**>(mTempData.PropertyAt(aPropID));
+    *source = head;
+    mTempData.SetPropertyBit(aPropID);
+    return PR_TRUE;
+  }
+  delete head;
+  return PR_FALSE;
+}
+
+PRBool
+CSSParserImpl::ParseBackgroundColor()
+{
+  if (!GetToken(PR_TRUE)) {
+    return PR_FALSE;
+  }
+  if (eCSSToken_Symbol == mToken.mType && mToken.mSymbol == '/') {
+    // "If the color before the slash is missing, it is assumed to be
+    // 'transparent'." (css3-background, 4.1)
+    mTempData.mColor.mBackColor.mXValue.SetColorValue(NS_RGBA(0, 0, 0, 0));
+  } else {
+    UngetToken();
+    if (!ParseVariant(mTempData.mColor.mBackColor.mXValue,
+                      VARIANT_HC, nsnull)) {
+      return PR_FALSE;
+    }
+  }
+  switch (mTempData.mColor.mBackColor.mXValue.GetUnit()) {
+    case eCSSUnit_Inherit:
+    case eCSSUnit_Initial:
+      mTempData.mColor.mBackColor.mYValue.Reset();
+      return PR_TRUE; // we're done
+    default:
+  }
+  if (!GetToken(PR_TRUE)) {
+    return PR_TRUE;
+  }
+  if (eCSSToken_Symbol == mToken.mType && mToken.mSymbol == '/') {
+    if (!ParseVariant(mTempData.mColor.mBackColor.mYValue,
+                       VARIANT_HC, nsnull)) {
+      retun PR_FALSE;
+    }
+  } else {
+    UngetToken();
+  }
+  return ExpectEndProperty();
+}
+
+PRBool
 CSSParserImpl::ParseBackgroundPosition()
 {
-  if (!ParseBoxPosition(mTempData.mColor.mBackPosition))
-    return PR_FALSE;
-  mTempData.SetPropertyBit(eCSSProperty_background_position);
-  return PR_TRUE;
-}
-
-PRBool
-CSSParserImpl::ParseBackgroundPositionValues()
-{
-  return ParseBoxPositionValues(mTempData.mColor.mBackPosition);
+  // aPropID is a single value prop-id
+  nsCSSValuePair valuePair;
+  nsCSSValuePairList *head = nsnull, **tail = &head;
+  do {
+    if (!ParseBoxPositionValues(valuePair)) {
+      break;
+    }
+    nsCSSValuePairList *item = new nsCSSValuePairList;
+    if (!item) {
+      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      break;
+    }
+    item->mXValue = valuePair.mXValue;
+    item->mYValue = valuePair.mYValue;
+    *tail = item;
+    tail = &item->mNext;
+    if (ExpectSymbol(',', PR_TRUE)) {
+      continue;
+    }
+    if (!ExpectEndProperty()) {
+      break;
+    }
+    nsCSSValuePairList **source =
+      static_cast<nsCSSValuePairList**>(mTempData.PropertyAt(aPropID));
+    *source = head;
+    mTempData.SetPropertyBit(eCSSProperty_background_position);
+    return PR_TRUE;
+  }
+  delete head;
+  return PR_FALSE;
 }
 
 /**
  * Parses two values that correspond to positions in a box.  These can be
  * values corresponding to percentages of the box, raw offsets, or keywords
  * like "top," "left center," etc.
  *
  * @param aOut The nsCSSValuePair where to place the result.
  * @return Whether or not the operation succeeded.
  */
-PRBool CSSParserImpl::ParseBoxPosition(nsCSSValuePair &aOut)
-{
-  // Need to read the box positions and the end of the property.
-  return ParseBoxPositionValues(aOut) && ExpectEndProperty();
-}
-
 PRBool CSSParserImpl::ParseBoxPositionValues(nsCSSValuePair &aOut)
 {
   // First try a percentage or a length value
   nsCSSValue &xValue = aOut.mXValue,
              &yValue = aOut.mYValue;
   if (ParseVariant(xValue, VARIANT_HLP, nsnull)) {
     if (eCSSUnit_Inherit == xValue.GetUnit() ||
         eCSSUnit_Initial == xValue.GetUnit()) {  // both are inherited or both are set to initial
@@ -7020,17 +7108,18 @@ PRBool CSSParserImpl::ParseMozTransform(
   mTempData.mDisplay.mTransform = transformList;
 
   return PR_TRUE;
 }
 
 PRBool CSSParserImpl::ParseMozTransformOrigin()
 {
   /* Read in a box position, fail if we can't. */
-  if (!ParseBoxPosition(mTempData.mDisplay.mTransformOrigin))
+  if (!ParseBoxPositionValues(mTempData.mDisplay.mTransformOrigin) ||
+      !ExpectEndProperty())
     return PR_FALSE;
 
   /* Set the property bit and return. */
   mTempData.SetPropertyBit(eCSSProperty__moz_transform_origin);
   return PR_TRUE;
 }
 
 PRBool
diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -269,24 +269,24 @@ CSS_PROP_OUTLINE(-moz-outline-radius-top
 CSS_PROP_OUTLINE(-moz-outline-radius-topright, _moz_outline_radius_topRight, MozOutlineRadiusTopright, Margin, mOutlineRadius.mRight, eCSSType_Value, nsnull)
 CSS_PROP_OUTLINE(-moz-outline-radius-bottomleft, _moz_outline_radius_bottomLeft, MozOutlineRadiusBottomleft, Margin, mOutlineRadius.mLeft, eCSSType_Value, nsnull)
 CSS_PROP_OUTLINE(-moz-outline-radius-bottomright, _moz_outline_radius_bottomRight, MozOutlineRadiusBottomright, Margin, mOutlineRadius.mBottom, eCSSType_Value, nsnull)
 #ifndef CSS_PROP_LIST_EXCLUDE_INTERNAL
 CSS_PROP_FONT(-x-system-font, _x_system_font, X, Font, mSystemFont, eCSSType_Value, kFontKTable)
 #endif
 CSS_PROP_BACKENDONLY(azimuth, azimuth, Azimuth, Aural, mAzimuth, eCSSType_Value, kAzimuthKTable)
 CSS_PROP_SHORTHAND(background, background, Background)
-CSS_PROP_BACKGROUND(background-attachment, background_attachment, BackgroundAttachment, Color, mBackAttachment, eCSSType_Value, kBackgroundAttachmentKTable)
-CSS_PROP_BACKGROUND(-moz-background-clip, _moz_background_clip, MozBackgroundClip, Color, mBackClip, eCSSType_Value, kBackgroundClipKTable)
-CSS_PROP_BACKGROUND(background-color, background_color, BackgroundColor, Color, mBackColor, eCSSType_Value, nsnull)
-CSS_PROP_BACKGROUND(background-image, background_image, BackgroundImage, Color, mBackImage, eCSSType_Value, nsnull)
+CSS_PROP_BACKGROUND(background-attachment, background_attachment, BackgroundAttachment, Color, mBackAttachment, eCSSType_ValueList, kBackgroundAttachmentKTable)
+CSS_PROP_BACKGROUND(-moz-background-clip, _moz_background_clip, MozBackgroundClip, Color, mBackClip, eCSSType_ValueList, kBackgroundClipKTable)
+CSS_PROP_BACKGROUND(background-color, background_color, BackgroundColor, Color, mBackColor, eCSSType_ValuePair, nsnull)
+CSS_PROP_BACKGROUND(background-image, background_image, BackgroundImage, Color, mBackImage, eCSSType_ValueList, nsnull)
 CSS_PROP_BACKGROUND(-moz-background-inline-policy, _moz_background_inline_policy, MozBackgroundInlinePolicy, Color, mBackInlinePolicy, eCSSType_Value, kBackgroundInlinePolicyKTable)
-CSS_PROP_BACKGROUND(-moz-background-origin, _moz_background_origin, MozBackgroundOrigin, Color, mBackOrigin, eCSSType_Value, kBackgroundOriginKTable)
-CSS_PROP_BACKGROUND(background-position, background_position, BackgroundPosition, Color, mBackPosition, eCSSType_ValuePair, kBackgroundPositionKTable)
-CSS_PROP_BACKGROUND(background-repeat, background_repeat, BackgroundRepeat, Color, mBackRepeat, eCSSType_Value, kBackgroundRepeatKTable)
+CSS_PROP_BACKGROUND(-moz-background-origin, _moz_background_origin, MozBackgroundOrigin, Color, mBackOrigin, eCSSType_ValueList, kBackgroundOriginKTable)
+CSS_PROP_BACKGROUND(background-position, background_position, BackgroundPosition, Color, mBackPosition, eCSSType_ValuePairList, kBackgroundPositionKTable)
+CSS_PROP_BACKGROUND(background-repeat, background_repeat, BackgroundRepeat, Color, mBackRepeat, eCSSType_ValueList, kBackgroundRepeatKTable)
 CSS_PROP_DISPLAY(-moz-binding, binding, MozBinding, Display, mBinding, eCSSType_Value, nsnull) // XXX bug 3935
 CSS_PROP_SHORTHAND(border, border, Border)
 CSS_PROP_SHORTHAND(border-bottom, border_bottom, BorderBottom)
 CSS_PROP_BORDER(border-bottom-color, border_bottom_color, BorderBottomColor, Margin, mBorderColor.mBottom, eCSSType_Value, kBorderColorKTable)
 CSS_PROP_BORDER(-moz-border-bottom-colors, border_bottom_colors, MozBorderBottomColors, Margin, mBorderColors.mBottom, eCSSType_ValueList, nsnull)
 CSS_PROP_BORDER(border-bottom-style, border_bottom_style, BorderBottomStyle, Margin, mBorderStyle.mBottom, eCSSType_Value, kBorderStyleKTable)  // on/off will need reflow
 CSS_PROP_BORDER(border-bottom-width, border_bottom_width, BorderBottomWidth, Margin, mBorderWidth.mBottom, eCSSType_Value, kBorderWidthKTable)
 CSS_PROP_TABLEBORDER(border-collapse, border_collapse, BorderCollapse, Table, mBorderCollapse, eCSSType_Value, kBorderCollapseKTable)
diff --git a/layout/style/nsCSSStruct.cpp b/layout/style/nsCSSStruct.cpp
--- a/layout/style/nsCSSStruct.cpp
+++ b/layout/style/nsCSSStruct.cpp
@@ -110,23 +110,36 @@ nsCSSValueList::Equal(nsCSSValueList* aL
       return PR_FALSE;
   }
   return !p1 && !p2; // true if same length, false otherwise
 }
 
 // --- nsCSSColor -----------------
 
 nsCSSColor::nsCSSColor(void)
+  : mBackImage(nsnull)
+  , mBackRepeat(nsnull)
+  , mBackAttachment(nsnull)
+  , mBackPosition(nsnull)
+  , mBackClip(nsnull)
+  , mBackOrigin(nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSColor);
 }
 
 nsCSSColor::~nsCSSColor(void)
 {
   MOZ_COUNT_DTOR(nsCSSColor);
+
+  CSS_IF_DELETE(mBackImage);
+  CSS_IF_DELETE(mBackRepeat);
+  CSS_IF_DELETE(mBackAttachment);
+  CSS_IF_DELETE(mBackPosition);
+  CSS_IF_DELETE(mBackClip);
+  CSS_IF_DELETE(mBackOrigin);
 }
 
 // --- nsCSSText -----------------
 
 nsCSSText::nsCSSText(void)
   : mTextShadow(nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSText);
diff --git a/layout/style/nsCSSStruct.h b/layout/style/nsCSSStruct.h
--- a/layout/style/nsCSSStruct.h
+++ b/layout/style/nsCSSStruct.h
@@ -214,23 +214,23 @@ private:
   nsRuleDataFont(const nsRuleDataFont& aOther); // NOT IMPLEMENTED
 };
 
 struct nsCSSColor : public nsCSSStruct  {
   nsCSSColor(void);
   ~nsCSSColor(void);
 
   nsCSSValue      mColor;
-  nsCSSValue      mBackColor;
-  nsCSSValue      mBackImage;
-  nsCSSValue      mBackRepeat;
-  nsCSSValue      mBackAttachment;
-  nsCSSValuePair  mBackPosition;
-  nsCSSValue      mBackClip;
-  nsCSSValue      mBackOrigin;
+  nsCSSValuePair  mBackColor;
+  nsCSSValueList* mBackImage;
+  nsCSSValueList* mBackRepeat;
+  nsCSSValueList* mBackAttachment;
+  nsCSSValuePairList* mBackPosition;
+  nsCSSValueList* mBackClip;
+  nsCSSValueList* mBackOrigin;
   nsCSSValue      mBackInlinePolicy;
 private:
   nsCSSColor(const nsCSSColor& aOther); // NOT IMPLEMENTED
 };
 
 struct nsRuleDataColor : public nsCSSColor {
   nsRuleDataColor() {}
 private:
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -1149,62 +1149,81 @@ nsChangeHint nsStyleColor::MaxDifference
 }
 #endif
 
 // --------------------
 // nsStyleBackground
 //
 
 nsStyleBackground::nsStyleBackground()
-  : mBackgroundFlags(NS_STYLE_BG_IMAGE_NONE),
-    mBackgroundAttachment(NS_STYLE_BG_ATTACHMENT_SCROLL),
-    mBackgroundClip(NS_STYLE_BG_CLIP_BORDER),
-    mBackgroundInlinePolicy(NS_STYLE_BG_INLINE_POLICY_CONTINUOUS),
-    mBackgroundOrigin(NS_STYLE_BG_ORIGIN_PADDING),
-    mBackgroundRepeat(NS_STYLE_BG_REPEAT_XY),
+  : mBackgroundColor(NS_RGBA(0, 0, 0, 0))
+  , mFallbackBackgroundColor(NS_RGBA(0, 0, 0, 0))
+  , mHaveFallbackBackgroundColor(PR_FALSE)
+  , mBackgroundInlinePolicy(NS_STYLE_BG_INLINE_POLICY_CONTINUOUS)
     mBackgroundColor(NS_RGBA(0, 0, 0, 0))
 {
 }
 
 nsStyleBackground::nsStyleBackground(const nsStyleBackground& aSource)
-  : mBackgroundFlags(aSource.mBackgroundFlags),
-    mBackgroundAttachment(aSource.mBackgroundAttachment),
+  : mBackgroundAttachment(aSource.mBackgroundAttachment),
     mBackgroundClip(aSource.mBackgroundClip),
-    mBackgroundInlinePolicy(aSource.mBackgroundInlinePolicy),
     mBackgroundOrigin(aSource.mBackgroundOrigin),
     mBackgroundRepeat(aSource.mBackgroundRepeat),
-    mBackgroundXPosition(aSource.mBackgroundXPosition),
-    mBackgroundYPosition(aSource.mBackgroundYPosition),
+    mBackgroundPosition(aSource.mBackgroundPosition),
     mBackgroundColor(aSource.mBackgroundColor),
+    mFallbackBackgroundColor(aSource.mFallbackBackgroundColor),
+    mHaveFallbackBackgroundColor(aSource.mHaveFallbackBackgroundColor),
+    mBackgroundInlinePolicy(aSource.mBackgroundInlinePolicy),
     mBackgroundImage(aSource.mBackgroundImage)
 {
 }
 
 nsStyleBackground::~nsStyleBackground()
 {
 }
 
+// XXX Turn this into a method or two on nsTArray<T>.
+template<class T, class Comparator>
+PRBool ArraysEqual(const nsTArray<T> &a, const nsTArray<T> &b,
+                   const Comparator &comp =
+                     nsDefaultComparator<T, T>)
+{
+  if (a.Length() != b.Length())
+    return PR_FALSE;
+
+  for (PRUint32 i = 0, i_end = a.Length(); i != i_end; ++i) {
+    if (!comp.Equals(a[i], b[i]))
+      return PR_FALSE;
+  }
+
+  return PR_TRUE;
+}
+
+class ImageComparator {
+  PRBool Equals(const nsCOMPtr<imgIRequest>& a,
+                const nsCOMPtr<imgIRequest>& b)
+  {
+    return EqualImages(a, b);
+  }
+
+};
+
 nsChangeHint nsStyleBackground::CalcDifference(const nsStyleBackground& aOther) const
 {
-  if ((mBackgroundAttachment == aOther.mBackgroundAttachment) &&
-      (mBackgroundFlags == aOther.mBackgroundFlags) &&
-      (mBackgroundRepeat == aOther.mBackgroundRepeat) &&
+  if (ArraysEqual(mBackgroundAttachment, aOther.mBackgroundAttachment) &&
+      ArraysEqual(mBackgroundClip, aOther.mBackgroundClip) &&
+      ArraysEqual(mBackgroundOrigin, aOther.mBackgroundOrigin) &&
+      ArraysEqual(mBackgroundRepeat, aOther.mBackgroundRepeat) &&
+      ArraysEqual(mBackgroundPosition, aOther.mBackgroundPosition) &&
       (mBackgroundColor == aOther.mBackgroundColor) &&
-      (mBackgroundClip == aOther.mBackgroundClip) &&
+      (mHaveFallbackBackgroundColor == aOther.mHaveFallbackBackgroundColor) &&
+      (!mHaveFallbackBackgroundColor ||
+       mFallbackBackgroundColor == aOther.mFallbackBackgroundColor) &&
       (mBackgroundInlinePolicy == aOther.mBackgroundInlinePolicy) &&
-      (mBackgroundOrigin == aOther.mBackgroundOrigin) &&
-      EqualImages(mBackgroundImage, aOther.mBackgroundImage) &&
-      ((!(mBackgroundFlags & NS_STYLE_BG_X_POSITION_PERCENT) ||
-       (mBackgroundXPosition.mFloat == aOther.mBackgroundXPosition.mFloat)) &&
-       (!(mBackgroundFlags & NS_STYLE_BG_X_POSITION_LENGTH) ||
-        (mBackgroundXPosition.mCoord == aOther.mBackgroundXPosition.mCoord))) &&
-      ((!(mBackgroundFlags & NS_STYLE_BG_Y_POSITION_PERCENT) ||
-       (mBackgroundYPosition.mFloat == aOther.mBackgroundYPosition.mFloat)) &&
-       (!(mBackgroundFlags & NS_STYLE_BG_Y_POSITION_LENGTH) ||
-        (mBackgroundYPosition.mCoord == aOther.mBackgroundYPosition.mCoord))))
+      ArraysEqual(mBackgroundImage, aOther.mBackgroundImage, ImageComparator))
     return NS_STYLE_HINT_NONE;
   return NS_STYLE_HINT_VISUAL;
 }
 
 #ifdef DEBUG
 /* static */
 nsChangeHint nsStyleBackground::MaxDifference()
 {
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -54,16 +54,17 @@
 #include "nsVoidArray.h"
 #include "nsStyleCoord.h"
 #include "nsStyleConsts.h"
 #include "nsChangeHint.h"
 #include "nsPresContext.h"
 #include "nsIPresShell.h"
 #include "nsCOMPtr.h"
 #include "nsCOMArray.h"
+#include "nsTArray.h"
 #include "nsIAtom.h"
 #include "nsIURI.h"
 #include "nsCSSValue.h"
 #include "nsStyleTransformMatrix.h"
 
 class nsIFrame;
 class imgIRequest;
 
@@ -157,39 +158,45 @@ struct nsStyleBackground {
     aContext->FreeToShell(sizeof(nsStyleBackground), this);
   }
 
   nsChangeHint CalcDifference(const nsStyleBackground& aOther) const;
 #ifdef DEBUG
   static nsChangeHint MaxDifference();
 #endif
 
-  PRUint8 mBackgroundFlags;        // [reset] See nsStyleConsts.h
-  PRUint8 mBackgroundAttachment;   // [reset] See nsStyleConsts.h
-  PRUint8 mBackgroundClip;         // [reset] See nsStyleConsts.h
-  PRUint8 mBackgroundInlinePolicy; // [reset] See nsStyleConsts.h
-  PRUint8 mBackgroundOrigin;       // [reset] See nsStyleConsts.h
-  PRUint8 mBackgroundRepeat;       // [reset] See nsStyleConsts.h
+  // Empty |nsTArray|s use only a single word.  An empty array
+  // implies that the value is the default value for the property.
+  nsTArray<PRUint8> mBackgroundAttachment; // [reset] See nsStyleConsts.h
+  nsTArray<PRUint8> mBackgroundClip;   // [reset] See nsStyleConsts.h
+  nsTArray<PRUint8> mBackgroundOrigin; // [reset] See nsStyleConsts.h
+  nsTArray<PRUint8> mBackgroundRepeat; // [reset] See nsStyleConsts.h
 
-  // Note: a member of this union is valid IFF the appropriate bit flag
-  // is set in mBackgroundFlags.
-  union {
-    nscoord mCoord;
-    float   mFloat;
-  } mBackgroundXPosition,         // [reset]
-    mBackgroundYPosition;         // [reset]
+  struct Position {
+    union {
+      nscoord mCoord; // for lengths
+      float   mFloat; // for percents
+    } mXPosition, mYPosition;
+    PRPackedBool mXIsPercent;
+    PRPackedBool mYIsPercent;
+  };
+  nsTArray<Position> mBackgroundPosition; // [reset]
 
   nscolor mBackgroundColor;       // [reset]
-  nsCOMPtr<imgIRequest> mBackgroundImage; // [reset]
+  nscolor mFallbackBackgroundColor; // [reset]
+  PRPackedBool mHaveFallbackBackgroundColor; // [reset]
+  PRUint8 mBackgroundInlinePolicy; // [reset] See nsStyleConsts.h
+  // An empty array means 'background-image: none'.
+  nsTArray< nsCOMPtr<imgIRequest> > mBackgroundImage; // [reset]
 
   // True if this background is completely transparent.
   PRBool IsTransparent() const
   {
-    return (NS_GET_A(mBackgroundColor) == 0 &&
-            (mBackgroundFlags & NS_STYLE_BG_IMAGE_NONE));
+    return mBackgroundImage.Length() == 0 &&
+           NS_GET_A(mBackgroundColor) == 0;
   }
 
   // We have to take slower codepaths for fixed background attachment,
   // but we don't want to do that when there's no image.
   // Not inline because it uses an nsCOMPtr<imgIRequest>
   // FIXME: Should be in nsStyleStructInlines.h.
   PRBool HasFixedBackground() const;
 };
