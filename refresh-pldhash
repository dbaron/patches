Synchronize pldhash with recent changes to jsdhash by rerunning through plify_jsdhash.sed.
diff --git a/xpcom/glue/pldhash.c b/xpcom/glue/pldhash.c
--- a/xpcom/glue/pldhash.c
+++ b/xpcom/glue/pldhash.c
@@ -63,30 +63,30 @@
  * table->ops or to an enumerator do not cause re-entry into a call that
  * can mutate the table.  The recursion level is stored in additional
  * space allocated at the end of the entry store to avoid changing
  * PLDHashTable, which could cause issues when mixing DEBUG and
  * non-DEBUG components.
  */
 #ifdef DEBUG
 
-#define JSDHASH_SINGLE_LINE_ASSERTION PR_ASSERT
+#define JSDHASH_ONELINE_ASSERT PR_ASSERT
 #define RECURSION_LEVEL(table_) (*(PRUint32*)(table_->entryStore + \
                                             PL_DHASH_TABLE_SIZE(table_) * \
                                             table_->entrySize))
 
 #define ENTRY_STORE_EXTRA                   sizeof(PRUint32)
 #define INCREMENT_RECURSION_LEVEL(table_)   \
     PR_BEGIN_MACRO                          \
       ++RECURSION_LEVEL(table_);            \
     PR_END_MACRO
-#define DECREMENT_RECURSION_LEVEL(table_)                         \
-    PR_BEGIN_MACRO                                                \
+#define DECREMENT_RECURSION_LEVEL(table_)                  \
+    PR_BEGIN_MACRO                                         \
       NS_ASSERTION(RECURSION_LEVEL(table_) > 0, "RECURSION_LEVEL(table_) > 0"); \
-      --RECURSION_LEVEL(table_);                                \
+      --RECURSION_LEVEL(table_);                           \
     PR_END_MACRO
 
 #else
 
 #define ENTRY_STORE_EXTRA 0
 #define INCREMENT_RECURSION_LEVEL(table_)   PR_BEGIN_MACRO PR_END_MACRO
 #define DECREMENT_RECURSION_LEVEL(table_)   PR_BEGIN_MACRO PR_END_MACRO
 
diff --git a/xpcom/glue/pldhash.h b/xpcom/glue/pldhash.h
--- a/xpcom/glue/pldhash.h
+++ b/xpcom/glue/pldhash.h
@@ -251,39 +251,36 @@ typedef void
 typedef PLDHashNumber
 (* PLDHashHashKey)   (PLDHashTable *table, const void *key);
 
 /*
  * Compare the key identifying entry in table with the provided key parameter.
  * Return PR_TRUE if keys match, PR_FALSE otherwise.
  */
 typedef PRBool
-(* PLDHashMatchEntry)(PLDHashTable *table,
-                                      const PLDHashEntryHdr *entry,
-                                      const void *key);
+(* PLDHashMatchEntry)(PLDHashTable *table, const PLDHashEntryHdr *entry,
+                      const void *key);
 
 /*
  * Copy the data starting at from to the new entry storage at to.  Do not add
  * reference counts for any strong references in the entry, however, as this
  * is a "move" operation: the old entry storage at from will be freed without
  * any reference-decrementing callback shortly.
  */
 typedef void
-(* PLDHashMoveEntry)(PLDHashTable *table,
-                     const PLDHashEntryHdr *from,
+(* PLDHashMoveEntry)(PLDHashTable *table, const PLDHashEntryHdr *from,
                      PLDHashEntryHdr *to);
 
 /*
  * Clear the entry and drop any strong references it holds.  This callback is
  * invoked during a PL_DHASH_REMOVE operation (see below for operation codes),
  * but only if the given key is found in the table.
  */
 typedef void
-(* PLDHashClearEntry)(PLDHashTable *table,
-                      PLDHashEntryHdr *entry);
+(* PLDHashClearEntry)(PLDHashTable *table, PLDHashEntryHdr *entry);
 
 /*
  * Called when a table (whether allocated dynamically by itself, or nested in
  * a larger structure, or allocated on the stack) is finished.  This callback
  * allows table->ops-specific code to finalize table->data.
  */
 typedef void
 (* PLDHashFinalize)  (PLDHashTable *table);
@@ -291,18 +288,17 @@ typedef void
 /*
  * Initialize a new entry, apart from keyHash.  This function is called when
  * PL_DHashTableOperate's PL_DHASH_ADD case finds no existing entry for the
  * given key, and must add a new one.  At that point, entry->keyHash is not
  * set yet, to avoid claiming the last free entry in a severely overloaded
  * table.
  */
 typedef PRBool
-(* PLDHashInitEntry)(PLDHashTable *table,
-                     PLDHashEntryHdr *entry,
+(* PLDHashInitEntry)(PLDHashTable *table, PLDHashEntryHdr *entry,
                      const void *key);
 
 /*
  * Finally, the "vtable" structure for PLDHashTable.  The first eight hooks
  * must be provided by implementations; they're called unconditionally by the
  * generic pldhash.c code.  Hooks after these may be null.
  *
  * Summary of allocation-related hook usage with C++ placement new emphasis:
@@ -570,18 +566,18 @@ PL_DHashTableRawRemove(PLDHashTable *tab
  * If your enumerator wants to remove certain entries, but set aside pointers
  * to other entries that it retains, it can use PL_DHashTableRawRemove on the
  * entries to be removed, returning PL_DHASH_NEXT to skip them.  Likewise, if
  * you want to remove entries, but for some reason you do not want entryStore
  * to be shrunk or compressed, you can call PL_DHashTableRawRemove safely on
  * the entry being enumerated, rather than returning PL_DHASH_REMOVE.
  */
 typedef PLDHashOperator
-(* PLDHashEnumerator)(PLDHashTable *table, PLDHashEntryHdr *hdr,
-                                      PRUint32 number, void *arg);
+(* PLDHashEnumerator)(PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number,
+                      void *arg);
 
 NS_COM_GLUE PRUint32
 PL_DHashTableEnumerate(PLDHashTable *table, PLDHashEnumerator etor, void *arg);
 
 #ifdef PL_DHASHMETER
 #include <stdio.h>
 
 NS_COM_GLUE void
