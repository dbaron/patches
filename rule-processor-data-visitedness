From: L. David Baron <dbaron@dbaron.org>

Pass through desired link-visitedness in the rule processor data and construct if-visited style contexts in the style set when visited styles are present.  (Bug 147777)

diff --git a/content/base/src/nsGenericElement.cpp b/content/base/src/nsGenericElement.cpp
--- a/content/base/src/nsGenericElement.cpp
+++ b/content/base/src/nsGenericElement.cpp
@@ -5185,17 +5185,18 @@ TryMatchingElementsInSubtree(nsINode* aR
 
   PRBool continueIteration = PR_TRUE;
   for (nsINode::ChildIterator iter(aRoot); !iter.IsDone(); iter.Next()) {
     nsIContent* kid = iter;
     if (!kid->IsNodeOfType(nsINode::eELEMENT)) {
       continue;
     }
     /* See whether we match */
-    new (data) RuleProcessorData(aPresContext, kid, nsnull);
+    new (data) RuleProcessorData(aPresContext, kid, nsnull,
+                                 RuleProcessorData::eRelevantLinkUnvisited);
     NS_ASSERTION(!data->mParentData, "Shouldn't happen");
     NS_ASSERTION(!data->mPreviousSiblingData, "Shouldn't happen");
     data->mParentData = aParentData;
     data->mPreviousSiblingData = prevSibling;
 
     if (nsCSSRuleProcessor::SelectorListMatches(*data, aSelectorList)) {
       continueIteration = (*aCallback)(kid, aClosure);
     }
@@ -5332,14 +5333,15 @@ nsGenericElement::doMatchesSelector(nsIC
   nsAutoPtr<nsCSSSelectorList> selectorList;
   nsPresContext* presContext;
   PRBool matches = PR_FALSE;
 
   if (NS_SUCCEEDED(ParseSelectorList(aNode, aSelector,
                                      getter_Transfers(selectorList),
                                      &presContext)))
   {
-    RuleProcessorData data(presContext, aNode, nsnull);
+    RuleProcessorData data(presContext, aNode, nsnull,
+                           RuleProcessorData::eRelevantLinkUnvisited);
     matches = nsCSSRuleProcessor::SelectorListMatches(data, selectorList);
   }
 
   return matches;
 }
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -970,23 +970,26 @@ nsCSSRuleProcessor::HasSystemMetric(nsIA
     return PR_FALSE;
   }
   return sSystemMetrics->IndexOf(aMetric) != sSystemMetrics->NoIndex;
 }
 
 RuleProcessorData::RuleProcessorData(nsPresContext* aPresContext,
                                      nsIContent* aContent, 
                                      nsRuleWalker* aRuleWalker,
+                                     VisitedHandling aVisitedHandling,
                                      nsCompatibility* aCompat /*= nsnull*/)
   : mPresContext(aPresContext),
     mContent(aContent),
     mRuleWalker(aRuleWalker),
     mScopedRoot(nsnull),
     mPreviousSiblingData(nsnull),
     mParentData(nsnull),
+    mVisitedHandling(aVisitedHandling),
+    mHaveRelevantLink(PR_FALSE),
     mLanguage(nsnull),
     mGotContentState(PR_FALSE)
 {
   MOZ_COUNT_CTOR(RuleProcessorData);
 
   NS_ASSERTION(aContent && aContent->IsNodeOfType(nsINode::eELEMENT),
                "non-element leaked into SelectorMatches");
 
@@ -2143,16 +2146,17 @@ static PRBool SelectorMatchesTree(RulePr
             parent->SetFlags(NODE_HAS_SLOW_SELECTOR_NOAPPEND);
 
           PRInt32 index = parent->IndexOf(content);
           while (0 <= --index) {
             content = parent->GetChildAt(index);
             if (content->IsNodeOfType(nsINode::eELEMENT)) {
               data = RuleProcessorData::Create(prevdata->mPresContext, content,
                                                prevdata->mRuleWalker,
+                                               prevdata->mVisitedHandling,
                                                prevdata->mCompatMode);
               prevdata->mPreviousSiblingData = data;    
               break;
             }
           }
         }
       }
     }
@@ -2162,16 +2166,17 @@ static PRBool SelectorMatchesTree(RulePr
       data = prevdata->mParentData;
       if (!data) {
         nsIContent *content = prevdata->mParentContent;
         // GetParent could return a document fragment; we only want
         // element parents.
         if (content && content->IsNodeOfType(nsINode::eELEMENT)) {
           data = RuleProcessorData::Create(prevdata->mPresContext, content,
                                            prevdata->mRuleWalker,
+                                           prevdata->mVisitedHandling,
                                            prevdata->mCompatMode);
           prevdata->mParentData = data;
         }
       }
     }
     if (! data) {
       return PR_FALSE;
     }
diff --git a/layout/style/nsRuleProcessorData.h b/layout/style/nsRuleProcessorData.h
--- a/layout/style/nsRuleProcessorData.h
+++ b/layout/style/nsRuleProcessorData.h
@@ -56,37 +56,53 @@ class nsIAtom;
 class nsICSSPseudoComparator;
 class nsRuleWalker;
 class nsAttrValue;
 
 // The implementation of the constructor and destructor are currently in
 // nsCSSRuleProcessor.cpp.
 
 struct RuleProcessorData {
+  // We define the visited-relevant link to be the link that is the
+  // nearest self-or-ancestor to the node being matched.
+  enum VisitedHandling {
+    // Do rule matching as though all links are unvisited.
+    eRelevantLinkUnvisited,
+    // Do rule matching as though the relevant link is visited and all
+    // other links are unvisited.
+    eRelevantLinkVisited,
+    // Do rule matching as though a rule should match if it would match
+    // given any set of visitedness states.
+    eLinksVisitedOrUnvisited
+  };
+
   RuleProcessorData(nsPresContext* aPresContext,
                     nsIContent* aContent, 
                     nsRuleWalker* aRuleWalker,
+                    VisitedHandling aVisitedHandling,
                     nsCompatibility* aCompat = nsnull);
   
   // NOTE: not |virtual|
   ~RuleProcessorData();
 
   // This should be used for all heap-allocation of RuleProcessorData
   static RuleProcessorData* Create(nsPresContext* aPresContext,
                                    nsIContent* aContent, 
                                    nsRuleWalker* aRuleWalker,
+                                   VisitedHandling aVisitedHandling,
                                    nsCompatibility aCompat)
   {
     if (NS_LIKELY(aPresContext)) {
       return new (aPresContext) RuleProcessorData(aPresContext, aContent,
-                                                  aRuleWalker, &aCompat);
+                                                  aRuleWalker,
+                                                  aVisitedHandling, &aCompat);
     }
 
     return new RuleProcessorData(aPresContext, aContent, aRuleWalker,
-                                 &aCompat);
+                                 aVisitedHandling, &aCompat);
   }
   
   void Destroy() {
     nsPresContext * pc = mPresContext;
     if (NS_LIKELY(pc)) {
       this->~RuleProcessorData();
       pc->FreeToShell(sizeof(RuleProcessorData), this);
       return;
@@ -134,50 +150,70 @@ public:
   PRInt32           mNameSpaceID;   // mContent->GetNameSapce()
   const nsAttrValue* mClasses;      // mContent->GetClasses()
   // mPreviousSiblingData and mParentData are always RuleProcessorData
   // and never a derived class.  They are allocated lazily, when
   // selectors require matching of prior siblings or ancestors.
   RuleProcessorData* mPreviousSiblingData;
   RuleProcessorData* mParentData;
 
+  VisitedHandling   mVisitedHandling;
+  // When mVisitedHandling is eRelevantLinkUnvisited, this is set to
+  // true on the RuleProcessorData *for the node being matched* if a a
+  // relevant link (see explanation in definition of VisitedHandling
+  // enum) was encountered during the matching process, which means that
+  // matching needs to be rerun with eRelevantLinkVisited.  Otherwise,
+  // its behavior is undefined (it might get set appropriately, or might
+  // not).
+  PRBool            mHaveRelevantLink;
+
+  void SwitchToVisitedMatching(nsRuleWalker *aVisitedRuleWalker)
+  {
+    // FIXME: The aVisitedHandling should be removed from the constructor!
+    mRuleWalker = aVisitedRuleWalker;
+    mVisitedHandling = eRelevantLinkVisited;
+  }
+
 private:
   nsString *mLanguage; // NULL means we haven't found out the language yet
 
   // This node's index for :nth-child(), :nth-last-child(),
   // :nth-of-type(), :nth-last-of-type().  If -2, needs to be computed.
   // If -1, needs to be computed but known not to be 1.
   // If 0, the node is not at any index in its parent.
   // The first subscript is 0 for -child and 1 for -of-type, the second
   // subscript is 0 for nth- and 1 for nth-last-.
   PRInt32 mNthIndices[2][2];
 
-  // mContentState, mLinkState, mIsLink are initialized lazily.
+  // mContentState is initialized lazily.
   PRInt32 mContentState;  // eventStateMgr->GetContentState() or
                           // mContent->IntrinsicState() if we have no ESM
   PRPackedBool mGotContentState;
 };
 
 struct ElementRuleProcessorData : public RuleProcessorData {
   ElementRuleProcessorData(nsPresContext* aPresContext,
                            nsIContent* aContent, 
-                           nsRuleWalker* aRuleWalker)
-  : RuleProcessorData(aPresContext,aContent,aRuleWalker)
+                           nsRuleWalker* aRuleWalker,
+                           VisitedHandling aVisitedHandling)
+  : RuleProcessorData(aPresContext, aContent, aRuleWalker, aVisitedHandling)
   {
     NS_PRECONDITION(aPresContext, "null pointer");
     NS_PRECONDITION(aRuleWalker, "null pointer");
   }
 };
 
 struct PseudoElementRuleProcessorData : public RuleProcessorData {
   PseudoElementRuleProcessorData(nsPresContext* aPresContext,
                                  nsIContent* aParentContent,
                                  nsRuleWalker* aRuleWalker,
-                                 nsCSSPseudoElements::Type aPseudoType)
-    : RuleProcessorData(aPresContext, aParentContent, aRuleWalker),
+                                 nsCSSPseudoElements::Type aPseudoType,
+                                 VisitedHandling aVisitedHandling)
+    : RuleProcessorData(aPresContext, aParentContent, aRuleWalker,
+                        aVisitedHandling),
       mPseudoType(aPseudoType)
   {
     NS_PRECONDITION(aPresContext, "null pointer");
     NS_PRECONDITION(aPseudoType <
                       nsCSSPseudoElements::ePseudo_PseudoElementCount,
                     "null pointer");
     NS_PRECONDITION(aRuleWalker, "null pointer");
   }
@@ -204,18 +240,20 @@ struct AnonBoxRuleProcessorData {
 };
 
 #ifdef MOZ_XUL
 struct XULTreeRuleProcessorData : public RuleProcessorData {
   XULTreeRuleProcessorData(nsPresContext* aPresContext,
                            nsIContent* aParentContent,
                            nsRuleWalker* aRuleWalker,
                            nsIAtom* aPseudoTag,
-                           nsICSSPseudoComparator* aComparator)
-    : RuleProcessorData(aPresContext, aParentContent, aRuleWalker),
+                           nsICSSPseudoComparator* aComparator,
+                           VisitedHandling aVisitedHandling)
+    : RuleProcessorData(aPresContext, aParentContent, aRuleWalker,
+                        aVisitedHandling),
       mPseudoTag(aPseudoTag),
       mComparator(aComparator)
   {
     NS_PRECONDITION(aPresContext, "null pointer");
     NS_PRECONDITION(aPseudoTag, "null pointer");
     NS_PRECONDITION(aRuleWalker, "null pointer");
     NS_PRECONDITION(aComparator, "must have a comparator");
   }
@@ -224,32 +262,34 @@ struct XULTreeRuleProcessorData : public
   nsICSSPseudoComparator*  mComparator;
 };
 #endif
 
 struct StateRuleProcessorData : public RuleProcessorData {
   StateRuleProcessorData(nsPresContext* aPresContext,
                          nsIContent* aContent,
                          PRInt32 aStateMask)
-    : RuleProcessorData(aPresContext, aContent, nsnull),
+    : RuleProcessorData(aPresContext, aContent, nsnull,
+                        eLinksVisitedOrUnvisited),
       mStateMask(aStateMask)
   {
     NS_PRECONDITION(aPresContext, "null pointer");
   }
   const PRInt32 mStateMask; // |HasStateDependentStyle| for which state(s)?
                             //  Constants defined in nsIEventStateManager.h .
 };
 
 struct AttributeRuleProcessorData : public RuleProcessorData {
   AttributeRuleProcessorData(nsPresContext* aPresContext,
                              nsIContent* aContent,
                              nsIAtom* aAttribute,
                              PRInt32 aModType,
                              PRBool aAttrHasChanged)
-    : RuleProcessorData(aPresContext, aContent, nsnull),
+    : RuleProcessorData(aPresContext, aContent, nsnull,
+                        eLinksVisitedOrUnvisited),
       mAttribute(aAttribute),
       mModType(aModType),
       mAttrHasChanged(aAttrHasChanged)
   {
     NS_PRECONDITION(aPresContext, "null pointer");
   }
   nsIAtom* mAttribute; // |HasAttributeDependentStyle| for which attribute?
   PRInt32 mModType;    // The type of modification (see nsIDOMMutationEvent).
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -425,52 +425,84 @@ EnumRulesMatching(nsIStyleRuleProcessor*
  * on the rule nodes) between siblings and cousins of the same
  * generation.  (It works for cousins of the same generation since
  * |aParentContext| could itself be a shared context.)
  */
 already_AddRefed<nsStyleContext>
 nsStyleSet::GetContext(nsPresContext* aPresContext, 
                        nsStyleContext* aParentContext, 
                        nsRuleNode* aRuleNode,
+                       // aVisitedRuleNode may be null; if it is null
+                       // it means that we don't need to force creation
+                       // of a StyleIfVisited.  (But if we make one
+                       // because aParentContext has one, then aRuleNode
+                       // should be used.)
+                       nsRuleNode* aVisitedRuleNode,
                        nsIAtom* aPseudoTag,
                        nsCSSPseudoElements::Type aPseudoType)
 {
   NS_PRECONDITION((!aPseudoTag &&
                    aPseudoType ==
                      nsCSSPseudoElements::ePseudo_NotPseudoElement) ||
                   (aPseudoTag &&
                    nsCSSPseudoElements::GetPseudoType(aPseudoTag) ==
                      aPseudoType),
                   "Pseudo mismatch");
 
-  nsStyleContext* result = nsnull;
-      
+  // Ensure |aVisitedRuleNode != nsnull| corresponds to the need to
+  // create an if-visited style context, and that in that case, we have
+  // parentIfVisited set correctly.
+  nsStyleContext *parentIfVisited =
+    aParentContext ? aParentContext->StyleIfVisited() : nsnull;
+  if (parentIfVisited) {
+    if (!aVisitedRuleNode) {
+      aVisitedRuleNode = aRuleNode;
+    }
+  } else {
+    if (aVisitedRuleNode) {
+      parentIfVisited = aParentContext;
+    }
+  }
+
+  nsRefPtr<nsStyleContext> result;
   if (aParentContext)
     result = aParentContext->FindChildWithRules(aPseudoTag, aRuleNode,
-                                                nsnull, PR_FALSE).get();
+                                                aVisitedRuleNode,
+                                                PR_FALSE);
 
 #ifdef NOISY_DEBUG
   if (result)
     fprintf(stdout, "--- SharedSC %d ---\n", ++gSharedCount);
   else
     fprintf(stdout, "+++ NewSC %d +++\n", ++gNewCount);
 #endif
 
   if (!result) {
     result = NS_NewStyleContext(aParentContext, aPseudoTag, aPseudoType,
-                                aRuleNode, aPresContext).get();
-    if (!aParentContext && result)
+                                aRuleNode, aPresContext);
+    if (!result)
+      return nsnull;
+    if (aVisitedRuleNode) {
+      nsRefPtr<nsStyleContext> resultIfVisited =
+        NS_NewStyleContext(parentIfVisited, aPseudoTag, aPseudoType,
+                           aVisitedRuleNode, aPresContext);
+      if (!resultIfVisited) {
+        return nsnull;
+      }
+      result->SetStyleIfVisited(resultIfVisited.forget());
+    }
+    if (!aParentContext)
       mRoots.AppendElement(result);
   }
   else {
     NS_ASSERTION(result->GetPseudoType() == aPseudoType, "Unexpected type");
     NS_ASSERTION(result->GetPseudo() == aPseudoTag, "Unexpected pseudo");
   }
 
-  return result;
+  return result.forget();
 }
 
 void
 nsStyleSet::AddImportantRules(nsRuleNode* aCurrLevelNode,
                               nsRuleNode* aLastPrevLevelNode,
                               nsRuleWalker* aRuleWalker)
 {
   NS_ASSERTION(aCurrLevelNode &&
@@ -741,21 +773,32 @@ nsStyleSet::ResolveStyleFor(nsIContent* 
   nsPresContext* presContext = PresContext();
 
   NS_ASSERTION(aContent, "must have content");
   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eELEMENT),
                "content must be element");
 
   if (aContent && presContext) {
     nsRuleWalker ruleWalker(mRuleTree);
-    ElementRuleProcessorData data(presContext, aContent, &ruleWalker);
+    ElementRuleProcessorData data(presContext, aContent, &ruleWalker,
+                                  RuleProcessorData::eRelevantLinkUnvisited);
     FileRules(EnumRulesMatching<ElementRuleProcessorData>, &data, aContent,
               &ruleWalker);
+
+    nsRuleNode *visitedRuleNode = nsnull;
+    if (data.mHaveRelevantLink) {
+      nsRuleWalker visitedRuleWalker(mRuleTree);
+      data.SwitchToVisitedMatching(&visitedRuleWalker);
+      FileRules(EnumRulesMatching<ElementRuleProcessorData>, &data, aContent,
+                &visitedRuleWalker);
+      visitedRuleNode = visitedRuleWalker.CurrentNode();
+    }
+
     result = GetContext(presContext, aParentContext,
-                        ruleWalker.CurrentNode(), nsnull,
+                        ruleWalker.CurrentNode(), visitedRuleNode, nsnull,
                         nsCSSPseudoElements::ePseudo_NotPseudoElement).get();
   }
 
   return result;
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForRules(nsStyleContext* aParentContext,
@@ -773,31 +816,32 @@ nsStyleSet::ResolveStyleForRules(nsStyle
     if (aRuleNode)
       ruleWalker.SetCurrentNode(aRuleNode);
     // FIXME: Perhaps this should be passed in, but it probably doesn't
     // matter.
     ruleWalker.SetLevel(eDocSheet, PR_FALSE, PR_FALSE);
     for (PRInt32 i = 0; i < aRules.Count(); i++) {
       ruleWalker.Forward(aRules.ObjectAt(i));
     }
+    // FIXME: Should take an aVisitedRuleNode!
     result = GetContext(presContext, aParentContext,
-                        ruleWalker.CurrentNode(), aPseudoTag,
+                        ruleWalker.CurrentNode(), nsnull, aPseudoTag,
                         aPseudoType).get();
   }
   return result;
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForNonElement(nsStyleContext* aParentContext)
 {
   nsStyleContext* result = nsnull;
   nsPresContext *presContext = PresContext();
 
   if (presContext) {
-    result = GetContext(presContext, aParentContext, mRuleTree,
+    result = GetContext(presContext, aParentContext, mRuleTree, nsnull,
                         nsCSSAnonBoxes::mozNonElement,
                         nsCSSPseudoElements::ePseudo_AnonBox).get();
   }
 
   return result;
 }
 
 void
@@ -823,22 +867,32 @@ nsStyleSet::ResolvePseudoElementStyle(ns
                "must have pseudo element type");
   NS_ASSERTION(aParentContent &&
                aParentContent->IsNodeOfType(nsINode::eELEMENT),
                "aParentContent must be element");
 
   nsRuleWalker ruleWalker(mRuleTree);
   nsPresContext *presContext = PresContext();
   PseudoElementRuleProcessorData data(presContext, aParentContent, &ruleWalker,
-                                      aType);
+                                      aType, RuleProcessorData::eRelevantLinkUnvisited);
   WalkRestrictionRule(aType, &ruleWalker);
   FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
             aParentContent, &ruleWalker);
 
+  nsRuleNode *visitedRuleNode = nsnull;
+  if (data.mHaveRelevantLink) {
+    nsRuleWalker visitedRuleWalker(mRuleTree);
+    data.SwitchToVisitedMatching(&visitedRuleWalker);
+    FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
+              aParentContent, &visitedRuleWalker);
+    visitedRuleNode = visitedRuleWalker.CurrentNode();
+  }
+
   return GetContext(presContext, aParentContext, ruleWalker.CurrentNode(),
+                    visitedRuleNode,
                     nsCSSPseudoElements::GetPseudoAtom(aType), aType);
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ProbePseudoElementStyle(nsIContent* aParentContent,
                                     nsCSSPseudoElements::Type aType,
                                     nsStyleContext* aParentContext)
 {
@@ -851,30 +905,40 @@ nsStyleSet::ProbePseudoElementStyle(nsIC
                "aParentContent must be element");
 
   nsIAtom* pseudoTag = nsCSSPseudoElements::GetPseudoAtom(aType);
 
   nsPresContext *presContext = PresContext();
 
   nsRuleWalker ruleWalker(mRuleTree);
   PseudoElementRuleProcessorData data(presContext, aParentContent, &ruleWalker,
-                                      aType);
+                                      aType, RuleProcessorData::eRelevantLinkUnvisited);
   WalkRestrictionRule(aType, &ruleWalker);
   // not the root if there was a restriction rule
   nsRuleNode *adjustedRoot = ruleWalker.CurrentNode();
   FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
             aParentContent, &ruleWalker);
 
   nsRuleNode *ruleNode = ruleWalker.CurrentNode();
   if (ruleNode == adjustedRoot) {
     return nsnull;
   }
 
+  nsRuleNode *visitedRuleNode = nsnull;
+  if (data.mHaveRelevantLink) {
+    nsRuleWalker visitedRuleWalker(mRuleTree);
+    data.SwitchToVisitedMatching(&visitedRuleWalker);
+    FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
+              aParentContent, &visitedRuleWalker);
+    visitedRuleNode = visitedRuleWalker.CurrentNode();
+  }
+
   nsRefPtr<nsStyleContext> result =
-    GetContext(presContext, aParentContext, ruleNode, pseudoTag, aType);
+    GetContext(presContext, aParentContext, ruleNode, visitedRuleNode,
+               pseudoTag, aType);
 
   // For :before and :after pseudo-elements, having display: none or no
   // 'content' property is equivalent to not having the pseudo-element
   // at all.
   if (result &&
       (pseudoTag == nsCSSPseudoElements::before ||
        pseudoTag == nsCSSPseudoElements::after)) {
     const nsStyleDisplay *display = result->GetStyleDisplay();
@@ -906,17 +970,17 @@ nsStyleSet::ResolveAnonymousBoxStyle(nsI
 
   nsRuleWalker ruleWalker(mRuleTree);
   nsPresContext *presContext = PresContext();
   AnonBoxRuleProcessorData data(presContext, aPseudoTag, &ruleWalker);
   FileRules(EnumRulesMatching<AnonBoxRuleProcessorData>, &data, nsnull,
             &ruleWalker);
 
   return GetContext(presContext, aParentContext, ruleWalker.CurrentNode(),
-                    aPseudoTag, nsCSSPseudoElements::ePseudo_AnonBox);
+                    nsnull, aPseudoTag, nsCSSPseudoElements::ePseudo_AnonBox);
 }
 
 #ifdef MOZ_XUL
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveXULTreePseudoStyle(nsIContent* aParentContent,
                                       nsIAtom* aPseudoTag,
                                       nsStyleContext* aParentContext,
                                       nsICSSPseudoComparator* aComparator)
@@ -928,22 +992,33 @@ nsStyleSet::ResolveXULTreePseudoStyle(ns
                "content (if non-null) must be element");
   NS_ASSERTION(nsCSSAnonBoxes::IsTreePseudoElement(aPseudoTag),
                "Unexpected pseudo");
 
   nsRuleWalker ruleWalker(mRuleTree);
   nsPresContext *presContext = PresContext();
 
   XULTreeRuleProcessorData data(presContext, aParentContent, &ruleWalker,
-                                aPseudoTag, aComparator);
+                                aPseudoTag, aComparator,
+                                RuleProcessorData::eRelevantLinkUnvisited);
   FileRules(EnumRulesMatching<XULTreeRuleProcessorData>, &data, aParentContent,
             &ruleWalker);
 
+  nsRuleNode *visitedRuleNode = nsnull;
+  if (data.mHaveRelevantLink) {
+    nsRuleWalker visitedRuleWalker(mRuleTree);
+    data.SwitchToVisitedMatching(&visitedRuleWalker);
+    FileRules(EnumRulesMatching<XULTreeRuleProcessorData>, &data,
+              aParentContent, &visitedRuleWalker);
+    visitedRuleNode = visitedRuleWalker.CurrentNode();
+  }
+
   return GetContext(presContext, aParentContext, ruleWalker.CurrentNode(),
-                    aPseudoTag, nsCSSPseudoElements::ePseudo_XULTree);
+                    visitedRuleNode, aPseudoTag,
+                    nsCSSPseudoElements::ePseudo_XULTree);
 }
 #endif
 
 PRBool
 nsStyleSet::AppendFontFaceRules(nsPresContext* aPresContext,
                                 nsTArray<nsFontFaceRuleContainer>& aArray)
 {
   NS_ENSURE_FALSE(mInShutdown, PR_FALSE);
@@ -1049,20 +1124,25 @@ nsStyleSet::ReParentStyleContext(nsPresC
     if (aStyleContext->GetParent() == aNewParentContext) {
       aStyleContext->AddRef();
       return aStyleContext;
     }
     else {  // really a new parent
       nsIAtom* pseudoTag = aStyleContext->GetPseudo();
       nsCSSPseudoElements::Type pseudoType = aStyleContext->GetPseudoType();
       nsRuleNode* ruleNode = aStyleContext->GetRuleNode();
+      nsRuleNode* visitedRuleNode = nsnull;
+      nsStyleContext* visitedContext = aStyleContext->StyleIfVisited();
+      if (visitedContext) {
+         visitedRuleNode = visitedContext->GetRuleNode();
+      }
 
       already_AddRefed<nsStyleContext> result =
-        GetContext(aPresContext, aNewParentContext, ruleNode, pseudoTag,
-                   pseudoType);
+        GetContext(aPresContext, aNewParentContext, ruleNode, visitedRuleNode,
+                   pseudoTag, pseudoType);
       return result;
     }
   }
   return nsnull;
 }
 
 struct StatefulData : public StateRuleProcessorData {
   StatefulData(nsPresContext* aPresContext,
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -328,16 +328,17 @@ class nsStyleSet
   // Enumerate all the rules in a way that doesn't care about the order
   // of the rules and break out if the enumeration is halted.
   void WalkRuleProcessors(nsIStyleRuleProcessor::EnumFunc aFunc,
                           RuleProcessorData* aData);
 
   already_AddRefed<nsStyleContext> GetContext(nsPresContext* aPresContext,
                                               nsStyleContext* aParentContext,
                                               nsRuleNode* aRuleNode,
+                                              nsRuleNode* aVisitedRuleNode,
                                               nsIAtom* aPseudoTag,
                                               nsCSSPseudoElements::Type aPseudoType);
 
   nsPresContext* PresContext() { return mRuleTree->GetPresContext(); }
 
   // The sheets in each array in mSheets are stored with the most significant
   // sheet last.
   nsCOMArray<nsIStyleSheet> mSheets[eSheetTypeCount];
