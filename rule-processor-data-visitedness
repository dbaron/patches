From: L. David Baron <dbaron@dbaron.org>

Pass through desired link-visitedness in the rule processor data.

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -970,23 +970,25 @@ nsCSSRuleProcessor::HasSystemMetric(nsIA
     return PR_FALSE;
   }
   return sSystemMetrics->IndexOf(aMetric) != sSystemMetrics->NoIndex;
 }
 
 RuleProcessorData::RuleProcessorData(nsPresContext* aPresContext,
                                      nsIContent* aContent, 
                                      nsRuleWalker* aRuleWalker,
+                                     VisitedHandling aVisitedHandling,
                                      nsCompatibility* aCompat /*= nsnull*/)
   : mPresContext(aPresContext),
     mContent(aContent),
     mRuleWalker(aRuleWalker),
     mScopedRoot(nsnull),
     mPreviousSiblingData(nsnull),
     mParentData(nsnull),
+    mVisitedHandling(aVisitedHandling),
     mLanguage(nsnull),
     mGotContentState(PR_FALSE)
 {
   MOZ_COUNT_CTOR(RuleProcessorData);
 
   NS_ASSERTION(aContent && aContent->IsNodeOfType(nsINode::eELEMENT),
                "non-element leaked into SelectorMatches");
 
@@ -2143,16 +2145,17 @@ static PRBool SelectorMatchesTree(RulePr
             parent->SetFlags(NODE_HAS_SLOW_SELECTOR_NOAPPEND);
 
           PRInt32 index = parent->IndexOf(content);
           while (0 <= --index) {
             content = parent->GetChildAt(index);
             if (content->IsNodeOfType(nsINode::eELEMENT)) {
               data = RuleProcessorData::Create(prevdata->mPresContext, content,
                                                prevdata->mRuleWalker,
+                                               prevdata->mVisitedHandling,
                                                prevdata->mCompatMode);
               prevdata->mPreviousSiblingData = data;    
               break;
             }
           }
         }
       }
     }
@@ -2162,16 +2165,17 @@ static PRBool SelectorMatchesTree(RulePr
       data = prevdata->mParentData;
       if (!data) {
         nsIContent *content = prevdata->mParentContent;
         // GetParent could return a document fragment; we only want
         // element parents.
         if (content && content->IsNodeOfType(nsINode::eELEMENT)) {
           data = RuleProcessorData::Create(prevdata->mPresContext, content,
                                            prevdata->mRuleWalker,
+                                           prevdata->mVisitedHandling,
                                            prevdata->mCompatMode);
           prevdata->mParentData = data;
         }
       }
     }
     if (! data) {
       return PR_FALSE;
     }
diff --git a/layout/style/nsRuleProcessorData.h b/layout/style/nsRuleProcessorData.h
--- a/layout/style/nsRuleProcessorData.h
+++ b/layout/style/nsRuleProcessorData.h
@@ -56,37 +56,52 @@ class nsIAtom;
 class nsICSSPseudoComparator;
 class nsRuleWalker;
 class nsAttrValue;
 
 // The implementation of the constructor and destructor are currently in
 // nsCSSRuleProcessor.cpp.
 
 struct RuleProcessorData {
+  // We define the visited-relevant link to be the link that is the
+  // nearest self-or-ancestor to the node being matched.
+  enum VisitedHandling {
+    // Do rule matching twice: (1) as though all links are unvisited,
+    // and (2) if needed, as though the relevant link is visited and all
+    // other links are unvisited.
+    eRelevantLinkVisited,
+    // Do rule matching as though a rule should match if it would match
+    // given any set of visitedness states.
+    eForDependence
+  };
+
   RuleProcessorData(nsPresContext* aPresContext,
                     nsIContent* aContent, 
                     nsRuleWalker* aRuleWalker,
+                    VisitedHandling aVisitedHandling,
                     nsCompatibility* aCompat = nsnull);
   
   // NOTE: not |virtual|
   ~RuleProcessorData();
 
   // This should be used for all heap-allocation of RuleProcessorData
   static RuleProcessorData* Create(nsPresContext* aPresContext,
                                    nsIContent* aContent, 
                                    nsRuleWalker* aRuleWalker,
+                                   VisitedHandling aVisitedHandling,
                                    nsCompatibility aCompat)
   {
     if (NS_LIKELY(aPresContext)) {
       return new (aPresContext) RuleProcessorData(aPresContext, aContent,
-                                                  aRuleWalker, &aCompat);
+                                                  aRuleWalker,
+                                                  aVisitedHandling, &aCompat);
     }
 
     return new RuleProcessorData(aPresContext, aContent, aRuleWalker,
-                                 &aCompat);
+                                 aVisitedHandling, &aCompat);
   }
   
   void Destroy() {
     nsPresContext * pc = mPresContext;
     if (NS_LIKELY(pc)) {
       this->~RuleProcessorData();
       pc->FreeToShell(sizeof(RuleProcessorData), this);
       return;
@@ -134,16 +149,18 @@ public:
   PRInt32           mNameSpaceID;   // mContent->GetNameSapce()
   const nsAttrValue* mClasses;      // mContent->GetClasses()
   // mPreviousSiblingData and mParentData are always RuleProcessorData
   // and never a derived class.  They are allocated lazily, when
   // selectors require matching of prior siblings or ancestors.
   RuleProcessorData* mPreviousSiblingData;
   RuleProcessorData* mParentData;
 
+  VisitedHandling   mVisitedHandling;
+
 private:
   nsString *mLanguage; // NULL means we haven't found out the language yet
 
   // This node's index for :nth-child(), :nth-last-child(),
   // :nth-of-type(), :nth-last-of-type().  If -2, needs to be computed.
   // If -1, needs to be computed but known not to be 1.
   // If 0, the node is not at any index in its parent.
   // The first subscript is 0 for -child and 1 for -of-type, the second
@@ -154,30 +171,33 @@ private:
   PRInt32 mContentState;  // eventStateMgr->GetContentState() or
                           // mContent->IntrinsicState() if we have no ESM
   PRPackedBool mGotContentState;
 };
 
 struct ElementRuleProcessorData : public RuleProcessorData {
   ElementRuleProcessorData(nsPresContext* aPresContext,
                            nsIContent* aContent, 
-                           nsRuleWalker* aRuleWalker)
-  : RuleProcessorData(aPresContext,aContent,aRuleWalker)
+                           nsRuleWalker* aRuleWalker,
+                           VisitedHandling aVisitedHandling)
+  : RuleProcessorData(aPresContext, aContent, aRuleWalker, aVisitedHandling)
   {
     NS_PRECONDITION(aPresContext, "null pointer");
     NS_PRECONDITION(aRuleWalker, "null pointer");
   }
 };
 
 struct PseudoElementRuleProcessorData : public RuleProcessorData {
   PseudoElementRuleProcessorData(nsPresContext* aPresContext,
                                  nsIContent* aParentContent,
                                  nsRuleWalker* aRuleWalker,
-                                 nsCSSPseudoElements::Type aPseudoType)
-    : RuleProcessorData(aPresContext, aParentContent, aRuleWalker),
+                                 nsCSSPseudoElements::Type aPseudoType,
+                                 VisitedHandling aVisitedHandling)
+    : RuleProcessorData(aPresContext, aParentContent, aRuleWalker,
+                        aVisitedHandling),
       mPseudoType(aPseudoType)
   {
     NS_PRECONDITION(aPresContext, "null pointer");
     NS_PRECONDITION(aPseudoType <
                       nsCSSPseudoElements::ePseudo_PseudoElementCount,
                     "null pointer");
     NS_PRECONDITION(aRuleWalker, "null pointer");
   }
@@ -204,18 +224,20 @@ struct AnonBoxRuleProcessorData {
 };
 
 #ifdef MOZ_XUL
 struct XULTreeRuleProcessorData : public RuleProcessorData {
   XULTreeRuleProcessorData(nsPresContext* aPresContext,
                            nsIContent* aParentContent,
                            nsRuleWalker* aRuleWalker,
                            nsIAtom* aPseudoTag,
-                           nsICSSPseudoComparator* aComparator)
-    : RuleProcessorData(aPresContext, aParentContent, aRuleWalker),
+                           nsICSSPseudoComparator* aComparator,
+                           VisitedHandling aVisitedHandling)
+    : RuleProcessorData(aPresContext, aParentContent, aRuleWalker,
+                        aVisitedHandling),
       mPseudoTag(aPseudoTag),
       mComparator(aComparator)
   {
     NS_PRECONDITION(aPresContext, "null pointer");
     NS_PRECONDITION(aPseudoTag, "null pointer");
     NS_PRECONDITION(aRuleWalker, "null pointer");
     NS_PRECONDITION(aComparator, "must have a comparator");
   }
@@ -224,32 +246,34 @@ struct XULTreeRuleProcessorData : public
   nsICSSPseudoComparator*  mComparator;
 };
 #endif
 
 struct StateRuleProcessorData : public RuleProcessorData {
   StateRuleProcessorData(nsPresContext* aPresContext,
                          nsIContent* aContent,
                          PRInt32 aStateMask)
-    : RuleProcessorData(aPresContext, aContent, nsnull),
+    : RuleProcessorData(aPresContext, aContent, nsnull,
+                        eLinksVisitedOrUnvisited),
       mStateMask(aStateMask)
   {
     NS_PRECONDITION(aPresContext, "null pointer");
   }
   const PRInt32 mStateMask; // |HasStateDependentStyle| for which state(s)?
                             //  Constants defined in nsIEventStateManager.h .
 };
 
 struct AttributeRuleProcessorData : public RuleProcessorData {
   AttributeRuleProcessorData(nsPresContext* aPresContext,
                              nsIContent* aContent,
                              nsIAtom* aAttribute,
                              PRInt32 aModType,
                              PRBool aAttrHasChanged)
-    : RuleProcessorData(aPresContext, aContent, nsnull),
+    : RuleProcessorData(aPresContext, aContent, nsnull,
+                        eLinksVisitedOrUnvisited),
       mAttribute(aAttribute),
       mModType(aModType),
       mAttrHasChanged(aAttrHasChanged)
   {
     NS_PRECONDITION(aPresContext, "null pointer");
   }
   nsIAtom* mAttribute; // |HasAttributeDependentStyle| for which attribute?
   PRInt32 mModType;    // The type of modification (see nsIDOMMutationEvent).
