From: L. David Baron <dbaron@dbaron.org>

Make nsDeque handle allocation failure better.  (Bug 520661)

diff --git a/xpcom/glue/nsDeque.cpp b/xpcom/glue/nsDeque.cpp
--- a/xpcom/glue/nsDeque.cpp
+++ b/xpcom/glue/nsDeque.cpp
@@ -169,59 +169,56 @@ nsDeque& nsDeque::Erase() {
  * If the deque actually overflows, there's very little we can do.
  * Perhaps this function should return PRBool/nsresult indicating success/failure.
  *
  * @return  capacity of the deque
  *          If the deque did not grow,
  *          and you knew its capacity beforehand,
  *          then this would be a way to indicate the failure.
  */
-PRInt32 nsDeque::GrowCapacity() {
+PRBool nsDeque::GrowCapacity() {
   PRInt32 theNewSize=mCapacity<<2;
   NS_ASSERTION(theNewSize>mCapacity, "Overflow");
   if (theNewSize<=mCapacity)
-    return mCapacity;
+    return PR_FALSE;
   void** temp=new void*[theNewSize];
+  if (!temp)
+    return PR_FALSE;
 
   //Here's the interesting part: You can't just move the elements
   //directly (in situ) from the old buffer to the new one.
   //Since capacity has changed, the old origin doesn't make
   //sense anymore. It's better to resequence the elements now.
 
-  if (temp) {
-    PRInt32 tempi=0;
-    PRInt32 i=0;
-    PRInt32 j=0;
-    for (i=mOrigin; i<mCapacity; i++) {
-      temp[tempi++]=mData[i]; //copy the leading elements...
-    }
-    for (j=0;j<mOrigin;j++) {
-      temp[tempi++]=mData[j]; //copy the trailing elements...
-    }
-    if (mData != mBuffer) {
-      delete [] mData;
-    }
-    mCapacity=theNewSize;
-    mOrigin=0; //now realign the origin...
-    mData=temp;
+  memcpy(temp, mData + mOrigin, sizeof(void*) * (mCapacity - mOrigin));
+  memcpy(temp + (mCapacity - mOrigin), mData, sizeof(void*) * mOrigin);
+
+  if (mData != mBuffer) {
+    delete [] mData;
   }
-  return mCapacity;
+
+  mCapacity=theNewSize;
+  mOrigin=0; //now realign the origin...
+  mData=temp;
+
+  return PR_TRUE;
 }
 
 /**
  * This method adds an item to the end of the deque.
  * This operation has the potential to cause the
  * underlying buffer to resize.
  *
  * @param   aItem: new item to be added to deque
  * @return  *this
  */
 nsDeque& nsDeque::Push(void* aItem) {
-  if (mSize==mCapacity) {
-    GrowCapacity();
+  if (mSize==mCapacity && !GrowCapacity()) {
+    NS_WARNING("out of memory");
+    return *this;
   }
   mData[modulus(mOrigin + mSize, mCapacity)]=aItem;
   mSize++;
   return *this;
 }
 
 /**
  * This method adds an item to the front of the deque.
@@ -255,17 +252,20 @@ nsDeque& nsDeque::Push(void* aItem) {
  * --
  * @param   aItem: new item to be added to deque
  * @return  *this
  */
 nsDeque& nsDeque::PushFront(void* aItem) {
   mOrigin--;
   modasgn(mOrigin,mCapacity);
   if (mSize==mCapacity) {
-    GrowCapacity();
+    if (!GrowCapacity()) {
+      NS_WARNING("out of memory");
+      return *this;
+    }
     /* Comments explaining this are above*/
     mData[mSize]=mData[mOrigin];
   }
   mData[mOrigin]=aItem;
   mSize++;
   return *this;
 }
 
diff --git a/xpcom/glue/nsDeque.h b/xpcom/glue/nsDeque.h
--- a/xpcom/glue/nsDeque.h
+++ b/xpcom/glue/nsDeque.h
@@ -228,17 +228,17 @@ private:
   /**
    * Deque assignment operator (PRIVATE)
    *
    * @param   another deque
    * @return  *this
    */
   nsDeque& operator=(const nsDeque& anOther);
 
-  PRInt32 GrowCapacity();
+  PRBool GrowCapacity();
 };
 
 /******************************************************
  * Here comes the nsDequeIterator class...
  ******************************************************/
 
 class NS_COM_GLUE nsDequeIterator {
 public:
