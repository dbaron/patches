Add nsCSSProps::PropHasFlags to address bzbarsky's review comments.  (Bug 461731)  r+sr=bzbarsky

diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -232,18 +232,18 @@ PRBool nsCSSDeclaration::AppendValueToSt
       } break;
       case eCSSType_ValueList: {
         const nsCSSValueList* val =
             *static_cast<nsCSSValueList*const*>(storage);
         do {
           AppendCSSValueToString(aProperty, val->mValue, aResult);
           val = val->mNext;
           if (val) {
-            if (nsCSSProps::kFlagsTable[aProperty] &
-                CSS_PROPERTY_VALUE_LIST_USES_COMMAS)
+            if (nsCSSProps::PropHasFlags(aProperty,
+                                         CSS_PROPERTY_VALUE_LIST_USES_COMMAS))
               aResult.Append(PRUnichar(','));
             aResult.Append(PRUnichar(' '));
           }
         } while (val);
       } break;
       case eCSSType_ValuePairList: {
         const nsCSSValuePairList* item =
             *static_cast<nsCSSValuePairList*const*>(storage);
@@ -542,17 +542,17 @@ nsCSSDeclaration::GetValue(nsCSSProperty
   //       !important and some are not.
   // Since we're doing this check for 'inherit' and 'initial' up front,
   // we can also simplify the property serialization code by serializing
   // those values up front as well.
   PRUint32 totalCount = 0, importantCount = 0,
            initialCount = 0, inheritCount = 0;
   CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(p, aProperty) {
     if (*p == eCSSProperty__x_system_font ||
-         nsCSSProps::kFlagsTable[*p] & CSS_PROPERTY_DIRECTIONAL_SOURCE) {
+         nsCSSProps::PropHasFlags(*p, CSS_PROPERTY_DIRECTIONAL_SOURCE)) {
       // The system-font subproperty and the *-source properties don't count.
       continue;
     }
     ++totalCount;
     const void *storage = mData->StorageFor(*p);
     NS_ASSERTION(!storage || !mImportantData || !mImportantData->StorageFor(*p),
                  "can't be in both blocks");
     if (!storage && mImportantData) {
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -96,32 +96,37 @@ public:
   // Return |eCSSKeyword_UNKNOWN| if not found.
   static nsCSSKeyword ValueToKeywordEnum(PRInt32 aValue, const PRInt32 aTable[]);
   // Ditto but as a string, return "" when not found.
   static const nsAFlatCString& ValueToKeyword(PRInt32 aValue, const PRInt32 aTable[]);
 
   static const nsCSSType       kTypeTable[eCSSProperty_COUNT_no_shorthands];
   static const nsStyleStructID kSIDTable[eCSSProperty_COUNT_no_shorthands];
   static const PRInt32* const  kKeywordTableTable[eCSSProperty_COUNT_no_shorthands];
+private:
   static const PRUint32        kFlagsTable[eCSSProperty_COUNT];
 
   // A table for shorthand properties.  The appropriate index is the
   // property ID minus eCSSProperty_COUNT_no_shorthands.
-private:
   static const nsCSSProperty *const
     kSubpropertyTable[eCSSProperty_COUNT - eCSSProperty_COUNT_no_shorthands];
 
 public:
   static inline
   const nsCSSProperty *const SubpropertyEntryFor(nsCSSProperty aProperty) {
     NS_ASSERTION(eCSSProperty_COUNT_no_shorthands <= aProperty &&
                  aProperty < eCSSProperty_COUNT,
                  "out of range");
     return nsCSSProps::kSubpropertyTable[aProperty -
                                          eCSSProperty_COUNT_no_shorthands];
+  }
+
+  static inline PRBool PropHasFlags(nsCSSProperty aProperty, PRUint32 aFlags)
+  {
+    return (nsCSSProps::kFlagsTable[aProperty] & aFlags) == aFlags;
   }
 
 #define CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(iter_, prop_)                    \
   for (const nsCSSProperty* iter_ = nsCSSProps::SubpropertyEntryFor(prop_);   \
        *iter_ != eCSSProperty_UNKNOWN; ++iter_)
 
   // Keyword/Enum value tables
   static const PRInt32 kAppearanceKTable[];
