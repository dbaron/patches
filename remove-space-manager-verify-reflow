Remove the VerifyReflow code that checked the space manager state.  (Bug 191448)  r+sr=roc

diff --git a/content/base/src/nsGkAtomList.h b/content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h
+++ b/content/base/src/nsGkAtomList.h
@@ -1624,17 +1624,16 @@ GK_ATOM(overflowProperty, "OverflowPrope
 GK_ATOM(overflowContainersProperty, "OverflowContainersProperty")             // nsFrameList*
 GK_ATOM(excessOverflowContainersProperty, "ExcessOverflowContainersProperty") // nsFrameList*
 GK_ATOM(overflowLinesProperty, "OverflowLinesProperty")    // list of nsLineBox*
 GK_ATOM(overflowOutOfFlowsProperty, "OverflowOutOfFlowsProperty")      // nsFrameList*
 GK_ATOM(overflowPlaceholdersProperty, "OverflowPlaceholdersProperty")  // nsFrameList*
 GK_ATOM(preEffectsBBoxProperty, "PreEffectsBBoxProperty") // nsRect*
 GK_ATOM(preTransformBBoxProperty, "PreTransformBBoxProperty") // nsRect*
 GK_ATOM(rowUnpaginatedHeightProperty, "RowUnpaginatedHeightProperty")  // nscoord*
-GK_ATOM(spaceManagerProperty, "SpaceManagerProperty")      // the space manager for a block
 GK_ATOM(tabWidthProperty, "TabWidthProperty")              // nsTArray<TabSetting>* array of tab widths
 GK_ATOM(tableBCProperty, "TableBCProperty")                // table border collapsing info (e.g. damage area, table border widths)
 GK_ATOM(usedMarginProperty, "UsedMarginProperty") // nsMargin*
 GK_ATOM(usedPaddingProperty, "UsedPaddingProperty") // nsMargin*
 GK_ATOM(viewProperty, "ViewProperty")                      
 
 // Content property names
 GK_ATOM(genConInitializerProperty, "QuoteNodeProperty")
diff --git a/layout/base/nsIPresShell.h b/layout/base/nsIPresShell.h
--- a/layout/base/nsIPresShell.h
+++ b/layout/base/nsIPresShell.h
@@ -118,18 +118,17 @@ typedef PRUint32 nsFrameState;
 
 // debug VerifyReflow flags
 #define VERIFY_REFLOW_ON              0x01
 #define VERIFY_REFLOW_NOISY           0x02
 #define VERIFY_REFLOW_ALL             0x04
 #define VERIFY_REFLOW_DUMP_COMMANDS   0x08
 #define VERIFY_REFLOW_NOISY_RC        0x10
 #define VERIFY_REFLOW_REALLY_NOISY_RC 0x20
-#define VERIFY_REFLOW_INCLUDE_SPACE_MANAGER 0x40
-#define VERIFY_REFLOW_DURING_RESIZE_REFLOW  0x80
+#define VERIFY_REFLOW_DURING_RESIZE_REFLOW  0x40
 
 /**
  * Presentation shell interface. Presentation shells are the
  * controlling point for managing the presentation of a document. The
  * presentation shell holds a live reference to the document, the
  * presentation context, the style manager, the style set and the root
  * frame. <p>
  *
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -132,17 +132,16 @@
 #include "nsIBaseWindow.h"
 #include "nsLayoutErrors.h"
 #include "nsLayoutUtils.h"
 #include "nsCSSRendering.h"
 #ifdef NS_DEBUG
 #include "nsIFrameDebug.h"
 #endif
   // for |#ifdef DEBUG| code
-#include "nsSpaceManager.h"
 #include "prenv.h"
 #include "nsIAttribute.h"
 #include "nsIGlobalHistory2.h"
 #include "nsDisplayList.h"
 #include "nsIRegion.h"
 #include "nsRegion.h"
 
 #ifdef MOZ_REFLOW_PERF_DSP
@@ -252,17 +251,16 @@ struct VerifyReflowFlags {
 
 static const VerifyReflowFlags gFlags[] = {
   { "verify",                VERIFY_REFLOW_ON },
   { "reflow",                VERIFY_REFLOW_NOISY },
   { "all",                   VERIFY_REFLOW_ALL },
   { "list-commands",         VERIFY_REFLOW_DUMP_COMMANDS },
   { "noisy-commands",        VERIFY_REFLOW_NOISY_RC },
   { "really-noisy-commands", VERIFY_REFLOW_REALLY_NOISY_RC },
-  { "space-manager",         VERIFY_REFLOW_INCLUDE_SPACE_MANAGER },
   { "resize",                VERIFY_REFLOW_DURING_RESIZE_REFLOW },
 };
 
 #define NUM_VERIFY_REFLOW_FLAGS (sizeof(gFlags) / sizeof(gFlags[0]))
 
 static void
 ShowVerifyReflowFlags()
 {
@@ -6787,112 +6785,17 @@ CompareTrees(nsPresContext* aFirstPresCo
               LogVerifyMessage(k1, k2, "(widget rects)", r1, r2);
             }
           }
         }
         if (!ok && (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags))) {
           break;
         }
 
-        // verify that neither frame has a space manager,
-        // or they both do and the space managers are equivalent
-        nsSpaceManager *sm1 = static_cast<nsSpaceManager*>
-                                         (k1->GetProperty(nsGkAtoms::spaceManagerProperty));
-
-        // look at the test frame
-        nsSpaceManager *sm2 = static_cast<nsSpaceManager*>
-                                         (k2->GetProperty(nsGkAtoms::spaceManagerProperty));
-
-        // now compare the space managers
-        if (((nsnull == sm1) && (nsnull != sm2)) ||
-            ((nsnull != sm1) && (nsnull == sm2))) {   // one is null, and the other is not
-          ok = PR_FALSE;
-          LogVerifyMessage(k1, k2, "space managers are not matched\n");
-        }
-        else if (sm1 && sm2) {  // both are not null, compare them
-          // first, compare yMost
-          nscoord yMost1, yMost2;
-          nsresult smresult = sm1->YMost(yMost1);
-          if (NS_ERROR_ABORT != smresult)
-          {
-            NS_ASSERTION(NS_SUCCEEDED(smresult), "bad result");
-            smresult = sm2->YMost(yMost2);
-            NS_ASSERTION(NS_SUCCEEDED(smresult), "bad result");
-            if (yMost1 != yMost2) {
-              LogVerifyMessage(k1, k2, "yMost of space managers differs\n");
-            }
-            // now compare bands by sampling
-            PRInt32 yIncrement = yMost1/100;
-            if (0==yIncrement) {
-              yIncrement = 1;   // guarantee we make progress in the loop below
-            }
-            nscoord yOffset = 0;
-            for ( ; ok && yOffset < yMost1; yOffset += yIncrement)
-            {
-              nscoord small=5, large=100;
-              nsBandData band1, band2;
-              nsBandTrapezoid trap1[20], trap2[20];
-              band1.mSize = band2.mSize = 20;
-              band1.mTrapezoids = trap1;  
-              band2.mTrapezoids = trap2;
-              sm1->GetBandData(yOffset, nsSize(small,small), band1);
-              sm2->GetBandData(yOffset, nsSize(small,small), band2);
-              if (band1.mCount != band2.mCount) 
-              { // count mismatch, stop comparing
-                LogVerifyMessage(k1, k2, "band.mCount of space managers differs\n");
-                printf("count1= %d, count2=%d, yOffset = %d, size=%d\n",
-                        band1.mCount, band2.mCount, yOffset, small);
-                ok = PR_FALSE;
-                      
-              }
-              else   // band counts match, compare individual traps
-              { 
-                PRInt32 trapIndex=0;
-                for ( ;trapIndex<band1.mCount; trapIndex++)
-                {
-                  PRBool match = (trap1[trapIndex].EqualGeometry(trap2[trapIndex])) && 
-                    ((trap1[trapIndex].mFrames!=nsnull) == (trap2[trapIndex].mFrames!=nsnull));
-                  if (!match)
-                  {
-                    LogVerifyMessage(k1, k2, "band.mTrapezoids of space managers differs\n");
-                    printf ("index %d\n", trapIndex);
-                  }
-                }
-              }
-              // test the larger maxSize
-              sm1->GetBandData(yOffset, nsSize(large,large), band1);
-              sm2->GetBandData(yOffset, nsSize(large,large), band2);
-              if (band1.mCount != band2.mCount) 
-              { // count mismatch, stop comparing
-                LogVerifyMessage(k1, k2, "band.mCount of space managers differs\n");
-                printf("count1= %d, count2=%d, yOffset = %d, size=%d\n",
-                        band1.mCount, band2.mCount, yOffset, small);
-                ok = PR_FALSE;
-                      
-              }
-              else   // band counts match, compare individual traps
-              { 
-                PRInt32 trapIndex=0;
-                for ( ; trapIndex<band1.mCount; trapIndex++)
-                {
-                  PRBool match = (trap1[trapIndex].EqualGeometry(trap2[trapIndex])) && 
-                    ((trap1[trapIndex].mFrames!=nsnull) == (trap2[trapIndex].mFrames!=nsnull));
-                  if (!match)
-                  {
-                    LogVerifyMessage(k1, k2, "band.mTrapezoids of space managers differs\n");
-                    printf ("index %d\n", trapIndex);
-                  }
-                }
-              }
-            }
-          }
-        }
-
-
-
+        // XXX Should perhaps compare their float managers.
 
         // Compare the sub-trees too
         if (!CompareTrees(aFirstPresContext, k1, aSecondPresContext, k2)) {
           ok = PR_FALSE;
           if (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags)) {
             break;
           }
         }
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1109,34 +1109,16 @@ nsBlockFrame::Reflow(nsPresContext*     
   // Compute our final size
   nscoord bottomEdgeOfChildren;
   ComputeFinalSize(aReflowState, state, aMetrics, &bottomEdgeOfChildren);
   ComputeCombinedArea(aReflowState, aMetrics, bottomEdgeOfChildren);
   // Factor overflow container child bounds into the overflow area
   aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea,
                                    overflowContainerBounds);
 
-  // see if verifyReflow is enabled, and if so store off the space manager pointer
-#ifdef DEBUG
-  PRInt32 verifyReflowFlags = nsIPresShell::GetVerifyReflowFlags();
-  if (VERIFY_REFLOW_INCLUDE_SPACE_MANAGER & verifyReflowFlags)
-  {
-    // this is a leak of the space manager, but it's only in debug if verify reflow is enabled, so not a big deal
-    nsIPresShell *shell = aPresContext->GetPresShell();
-    if (shell) {
-      nsHTMLReflowState&  reflowState = (nsHTMLReflowState&)aReflowState;
-      rv = SetProperty(nsGkAtoms::spaceManagerProperty,
-                       reflowState.mSpaceManager,
-                       nsnull /* should be nsSpaceManagerDestroyer*/);
-
-      autoSpaceManager.DebugOrphanSpaceManager();
-    }
-  }
-#endif
-
   // Let the absolutely positioned container reflow any absolutely positioned
   // child frames that need to be reflowed, e.g., elements with a percentage
   // based width/height
   // We want to do this under either of two conditions:
   //  1. If we didn't do the incremental reflow above.
   //  2. If our size changed.
   // Even though it's the padding edge that's the containing block, we
   // can use our rect (the border edge) since if the border style
diff --git a/layout/generic/nsSpaceManager.cpp b/layout/generic/nsSpaceManager.cpp
--- a/layout/generic/nsSpaceManager.cpp
+++ b/layout/generic/nsSpaceManager.cpp
@@ -1446,20 +1446,17 @@ nsAutoSpaceManager::~nsAutoSpaceManager(
 #ifdef NOISY_SPACEMANAGER
     if (mOld) {
       static_cast<nsFrame *>(mReflowState.frame)->ListTag(stdout);
       printf(": space-manager %p after reflow\n", mOld);
       mOld->List(stdout);
     }
 #endif
 
-#ifdef DEBUG
-    if (mOwns)
-#endif
-      delete mNew;
+    delete mNew;
   }
 }
 
 nsresult
 nsAutoSpaceManager::CreateSpaceManager(nsPresContext *aPresContext)
 {
   // Create a new space manager and install it in the reflow
   // state. `Remember' the old space manager so we can restore it
diff --git a/layout/generic/nsSpaceManager.h b/layout/generic/nsSpaceManager.h
--- a/layout/generic/nsSpaceManager.h
+++ b/layout/generic/nsSpaceManager.h
@@ -463,44 +463,29 @@ private:
  * A helper class to manage maintenance of the space manager during
  * nsBlockFrame::Reflow. It automatically restores the old space
  * manager in the reflow state when the object goes out of scope.
  */
 class nsAutoSpaceManager {
 public:
   nsAutoSpaceManager(nsHTMLReflowState& aReflowState)
     : mReflowState(aReflowState),
-#ifdef DEBUG
-      mOwns(PR_TRUE),
-#endif
       mNew(nsnull),
       mOld(nsnull) {}
 
   ~nsAutoSpaceManager();
 
   /**
    * Create a new space manager for the specified frame. This will
    * `remember' the old space manager, and install the new space
    * manager in the reflow state.
    */
   nsresult
   CreateSpaceManager(nsPresContext *aPresContext);
 
-#ifdef DEBUG
-  /**
-   * `Orphan' any space manager that the nsAutoSpaceManager created;
-   * i.e., make it so that we don't destroy the space manager when we
-   * go out of scope.
-   */
-  void DebugOrphanSpaceManager() { mOwns = PR_FALSE; }
-#endif
-
 protected:
   nsHTMLReflowState &mReflowState;
-#ifdef DEBUG
-  PRBool mOwns;
-#endif
   nsSpaceManager *mNew;
   nsSpaceManager *mOld;
 };
 
 #endif /* nsSpaceManager_h___ */
 
