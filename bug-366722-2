Make non-box frames pay better attention to nsITheme::GetWidgetBorder.  b=366722

diff -r 6ac4648503c2 layout/generic/nsContainerFrame.cpp
--- a/layout/generic/nsContainerFrame.cpp	Thu Jan 25 23:25:06 2007 -0800
+++ b/layout/generic/nsContainerFrame.cpp	Fri Jan 26 12:16:09 2007 -0800
@@ -582,6 +582,12 @@ SyncFrameViewGeometryDependentProperties
     }
 
     if (hasOverflowClip) {
+      // XXX We should be able to replace the next 14 lines with just
+      //   overflowClipRect.Deflate(aFrame->GetUsedBorderAndPadding());
+      // but unfortunately this function gets called during frame
+      // construction (why?), and GetUsedBorderAndPadding asserts when
+      // called on a frame that hasn't been reflowed yet (for good
+      // reason).
       const nsStyleBorder* borderStyle = aStyleContext->GetStyleBorder();
       const nsStylePadding* paddingStyle = aStyleContext->GetStylePadding();
 
diff -r 6ac4648503c2 layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp	Thu Jan 25 23:25:06 2007 -0800
+++ b/layout/generic/nsFrame.cpp	Fri Jan 26 12:00:09 2007 -0800
@@ -713,6 +713,24 @@ nsIFrame::GetUsedBorder() const
                (GetStateBits() & NS_FRAME_IN_REFLOW),
                "cannot call on a dirty frame not currently being reflowed");
 
+  // Theme methods don't use const-ness.
+  nsIFrame *mutable_this = NS_CONST_CAST(nsIFrame*, this);
+
+  const nsStyleDisplay *disp = GetStyleDisplay();
+  if (mutable_this->IsThemed(disp)) {
+    nsMargin result;
+    nsPresContext *presContext = GetPresContext();
+    presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
+                                             mutable_this, disp->mAppearance,
+                                             &result);
+    float p2t = presContext->ScaledPixelsToTwips();
+    result.top = NSIntPixelsToTwips(result.top, p2t);
+    result.right = NSIntPixelsToTwips(result.right, p2t);
+    result.bottom = NSIntPixelsToTwips(result.bottom, p2t);
+    result.left = NSIntPixelsToTwips(result.left, p2t);
+    return result;
+  }
+
   return GetStyleBorder()->GetBorder();
 }
 
@@ -725,6 +743,25 @@ nsIFrame::GetUsedPadding() const
                "cannot call on a dirty frame not currently being reflowed");
 
   nsMargin padding(0, 0, 0, 0);
+
+  // Theme methods don't use const-ness.
+  nsIFrame *mutable_this = NS_CONST_CAST(nsIFrame*, this);
+
+  const nsStyleDisplay *disp = GetStyleDisplay();
+  if (mutable_this->IsThemed(disp)) {
+    nsPresContext *presContext = GetPresContext();
+    if (presContext->GetTheme()->GetWidgetPadding(presContext->DeviceContext(),
+                                                  mutable_this,
+                                                  disp->mAppearance,
+                                                  &padding)) {
+      float p2t = presContext->ScaledPixelsToTwips();
+      padding.top = NSIntPixelsToTwips(padding.top, p2t);
+      padding.right = NSIntPixelsToTwips(padding.right, p2t);
+      padding.bottom = NSIntPixelsToTwips(padding.bottom, p2t);
+      padding.left = NSIntPixelsToTwips(padding.left, p2t);
+      return padding;
+    }
+  }
   if (!GetStylePadding()->GetPadding(padding)) {
     nsMargin *p = NS_STATIC_CAST(nsMargin*,
                     GetProperty(nsGkAtoms::usedPaddingProperty));
@@ -3039,6 +3076,26 @@ nsFrame::IntrinsicWidthOffsets(nsIRender
   const nsStyleBorder *styleBorder = GetStyleBorder();
   result.hBorder += styleBorder->GetBorderWidth(NS_SIDE_LEFT);
   result.hBorder += styleBorder->GetBorderWidth(NS_SIDE_RIGHT);
+
+  const nsStyleDisplay *disp = GetStyleDisplay();
+  if (IsThemed(disp)) {
+    nsPresContext *presContext = GetPresContext();
+    float p2t = presContext->ScaledPixelsToTwips();
+
+    nsMargin border;
+    presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
+                                             this, disp->mAppearance,
+                                             &border);
+    result.hBorder = NSIntPixelsToTwips(border.LeftRight(), p2t);
+
+    nsMargin padding;
+    if (presContext->GetTheme()->GetWidgetPadding(presContext->DeviceContext(),
+                                                  this, disp->mAppearance,
+                                                  &padding)) {
+      result.hPadding = NSIntPixelsToTwips(padding.LeftRight(), p2t);
+      result.hPctPadding = 0;
+    }
+  }
 
   return result;
 }
diff -r 6ac4648503c2 layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp	Thu Jan 25 23:25:06 2007 -0800
+++ b/layout/style/nsComputedDOMStyle.cpp	Thu Jan 25 23:25:08 2007 -0800
@@ -2990,7 +2990,20 @@ nsComputedDOMStyle::GetBorderWidthFor(PR
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 
-  val->SetTwips(GetStyleBorder()->GetComputedBorderWidth(aSide));
+  nscoord width;
+  const nsStyleDisplay *disp = GetStyleDisplay();
+  if (mFrame->IsThemed(disp)) {
+    nsMargin result;
+    nsPresContext *presContext = mFrame->GetPresContext();
+    presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
+                                             mFrame, disp->mAppearance,
+                                             &result);
+    width = NSIntPixelsToTwips(result.side(aSide),
+                               presContext->ScaledPixelsToTwips());
+  } else {
+    width = GetStyleBorder()->GetComputedBorderWidth(aSide);
+  }
+  val->SetTwips(width);
 
   return CallQueryInterface(val, aValue);
 }
