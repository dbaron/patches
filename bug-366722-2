Make non-box frames pay better attention to nsITheme::GetWidgetBorder.  b=366722

diff -r 54f5650b2888 layout/generic/nsContainerFrame.cpp
--- a/layout/generic/nsContainerFrame.cpp	Thu Jan 18 12:47:16 2007 -0800
+++ b/layout/generic/nsContainerFrame.cpp	Thu Jan 18 12:53:10 2007 -0800
@@ -582,21 +582,9 @@ SyncFrameViewGeometryDependentProperties
     }
 
     if (hasOverflowClip) {
-      const nsStyleBorder* borderStyle = aStyleContext->GetStyleBorder();
-      const nsStylePadding* paddingStyle = aStyleContext->GetStylePadding();
-
       nsMargin padding;
       nsRect overflowClipRect(0, 0, frameSize.width, frameSize.height);
-      overflowClipRect.Deflate(borderStyle->GetBorder());
-      // XXX We need to handle percentage padding
-      if (paddingStyle->GetPadding(padding)) {
-        overflowClipRect.Deflate(padding);
-      }
-#ifdef DEBUG
-      else {
-        NS_WARNING("Percentage padding and CLIP overflow don't mix");
-      }
-#endif
+      overflowClipRect.Deflate(aFrame->GetUsedBorderAndPadding());
 
       if (hasClip) {
         // If both 'clip' and 'overflow-clip' apply then use the intersection
diff -r 54f5650b2888 layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp	Thu Jan 18 12:47:16 2007 -0800
+++ b/layout/generic/nsFrame.cpp	Thu Jan 18 12:47:16 2007 -0800
@@ -712,6 +712,24 @@ nsIFrame::GetUsedBorder() const
                  (NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN)) ||
                (GetStateBits() & NS_FRAME_IN_REFLOW),
                "cannot call on a dirty frame not currently being reflowed");
+
+  // Theme methods don't use const-ness.
+  nsIFrame *mutable_this = NS_CONST_CAST(nsIFrame*, this);
+
+  const nsStyleDisplay *disp = GetStyleDisplay();
+  if (mutable_this->IsThemed(disp)) {
+    nsMargin result;
+    nsPresContext *presContext = GetPresContext();
+    presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
+                                             mutable_this, disp->mAppearance,
+                                             &result);
+    float p2t = presContext->ScaledPixelsToTwips();
+    result.top = NSIntPixelsToTwips(result.top, p2t);
+    result.right = NSIntPixelsToTwips(result.right, p2t);
+    result.bottom = NSIntPixelsToTwips(result.bottom, p2t);
+    result.left = NSIntPixelsToTwips(result.left, p2t);
+    return result;
+  }
 
   return GetStyleBorder()->GetBorder();
 }
diff -r 54f5650b2888 layout/style/nsComputedDOMStyle.cpp
--- a/layout/style/nsComputedDOMStyle.cpp	Thu Jan 18 12:47:16 2007 -0800
+++ b/layout/style/nsComputedDOMStyle.cpp	Thu Jan 18 12:49:56 2007 -0800
@@ -2993,7 +2993,20 @@ nsComputedDOMStyle::GetBorderWidthFor(PR
   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 
-  val->SetTwips(GetStyleBorder()->GetComputedBorderWidth(aSide));
+  nscoord width;
+  const nsStyleDisplay *disp = GetStyleDisplay();
+  if (mFrame->IsThemed(disp)) {
+    nsMargin result;
+    nsPresContext *presContext = mFrame->GetPresContext();
+    presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
+                                             mFrame, disp->mAppearance,
+                                             &result);
+    width = NSIntPixelsToTwips(result.side(aSide),
+                               presContext->ScaledPixelsToTwips());
+  } else {
+    width = GetStyleBorder()->GetComputedBorderWidth(aSide);
+  }
+  val->SetTwips(width);
 
   return CallQueryInterface(val, aValue);
 }
