From: L. David Baron <dbaron@dbaron.org>

Null-check the scope that we pass to WrapNative.  (Bug 540367)

diff --git a/content/xbl/src/nsXBLBinding.cpp b/content/xbl/src/nsXBLBinding.cpp
--- a/content/xbl/src/nsXBLBinding.cpp
+++ b/content/xbl/src/nsXBLBinding.cpp
@@ -1072,28 +1072,34 @@ nsXBLBinding::ChangeDocument(nsIDocument
 {
   if (aOldDocument != aNewDocument) {
     // Only style bindings get their prototypes unhooked.  First do ourselves.
     if (mIsStyleBinding) {
       // Now the binding dies.  Unhook our prototypes.
       if (mPrototypeBinding->HasImplementation()) { 
         nsIScriptGlobalObject *global = aOldDocument->GetScopeObject();
         if (global) {
+          JSObject *scope = global->GetGlobalJSObject();
+          // scope might be null if we've cycle-collected the global
+          // object, since the Unlink phase of cycle collection happens
+          // after JS GC finalization.  But in that case, we don't care
+          // about fixing the prototype chain, since everything's going
+          // away immediately.
+
           nsCOMPtr<nsIScriptContext> context = global->GetContext();
-          if (context) {
+          if (context && scope) {
             JSContext *cx = (JSContext *)context->GetNativeContext();
  
             nsCxPusher pusher;
             pusher.Push(cx);
 
             nsCOMPtr<nsIXPConnectJSObjectHolder> wrapper;
             jsval v;
             nsresult rv =
-              nsContentUtils::WrapNative(cx, global->GetGlobalJSObject(),
-                                         mBoundElement, &v,
+              nsContentUtils::WrapNative(cx, scope, mBoundElement, &v,
                                          getter_AddRefs(wrapper));
             if (NS_FAILED(rv))
               return;
 
             JSObject* scriptObject = JSVAL_TO_OBJECT(v);
 
             // XXX Stay in sync! What if a layered binding has an
             // <interface>?!
