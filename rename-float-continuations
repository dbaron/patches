From: L. David Baron <dbaron@dbaron.org>

Rename float continuations to pushed floats.  (Bug 563584, patch 33)  r=roc

This patch was generated with the following sed commands on layout/generic/*.{h,cpp}: 's/FLOAT_CONTINUATION/PUSHED_FLOAT/g;s/FloatContinuation/PushedFloat/g;s/float continuation/pushed float/g' plus whitespace fixup where the frame state bits are defined.

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -560,34 +560,34 @@ nsBlockFrame::GetChildList(nsIAtom* aLis
                                        overflowLines->back()->LastChild())
                          : nsFrameList::EmptyList();
   }
   else if (aListName == nsGkAtoms::overflowOutOfFlowList) {
     const nsFrameList* list = GetOverflowOutOfFlows();
     return list ? *list : nsFrameList::EmptyList();
   }
   else if (aListName == nsGkAtoms::floatContinuationsList) {
-    const nsFrameList* list = GetFloatContinuations();
+    const nsFrameList* list = GetPushedFloats();
     return list ? *list : nsFrameList::EmptyList();
   }
   else if (aListName == nsGkAtoms::floatList) {
     return mFloats;
   }
   else if (aListName == nsGkAtoms::bulletList) {
     return HaveOutsideBullet() ? nsFrameList(mBullet, mBullet)
                                : nsFrameList::EmptyList();
   }
   return nsContainerFrame::GetChildList(aListName);
 }
 
 #define NS_BLOCK_FRAME_OVERFLOW_OOF_LIST_INDEX  (NS_CONTAINER_LIST_COUNT_INCL_OC + 0)
 #define NS_BLOCK_FRAME_FLOAT_LIST_INDEX         (NS_CONTAINER_LIST_COUNT_INCL_OC + 1)
 #define NS_BLOCK_FRAME_BULLET_LIST_INDEX        (NS_CONTAINER_LIST_COUNT_INCL_OC + 2)
 #define NS_BLOCK_FRAME_ABSOLUTE_LIST_INDEX      (NS_CONTAINER_LIST_COUNT_INCL_OC + 3)
-#define NS_BLOCK_FRAME_FLOAT_CONTINUATIONS_LIST_INDEX (NS_CONTAINER_LIST_COUNT_INCL_OC + 4)
+#define NS_BLOCK_FRAME_PUSHED_FLOATS_LIST_INDEX (NS_CONTAINER_LIST_COUNT_INCL_OC + 4)
 // If adding/removing lists, don't forget to update the count in nsBlockFrame.h
 
 nsIAtom*
 nsBlockFrame::GetAdditionalChildListName(PRInt32 aIndex) const
 {
   if (aIndex < NS_CONTAINER_LIST_COUNT_INCL_OC)
     return nsContainerFrame::GetAdditionalChildListName(aIndex);
 
@@ -595,17 +595,17 @@ nsBlockFrame::GetAdditionalChildListName
   case NS_BLOCK_FRAME_FLOAT_LIST_INDEX:
     return nsGkAtoms::floatList;
   case NS_BLOCK_FRAME_BULLET_LIST_INDEX:
     return nsGkAtoms::bulletList;
   case NS_BLOCK_FRAME_OVERFLOW_OOF_LIST_INDEX:
     return nsGkAtoms::overflowOutOfFlowList;
   case NS_BLOCK_FRAME_ABSOLUTE_LIST_INDEX:
     return nsGkAtoms::absoluteList;
-  case NS_BLOCK_FRAME_FLOAT_CONTINUATIONS_LIST_INDEX:
+  case NS_BLOCK_FRAME_PUSHED_FLOATS_LIST_INDEX:
     return nsGkAtoms::floatContinuationsList;
   default:
     return nsnull;
   }
 }
 
 /* virtual */ PRBool
 nsBlockFrame::IsContainingBlock() const
@@ -992,21 +992,21 @@ nsBlockFrame::Reflow(nsPresContext*     
                                     ocStatus);
   }
 
   // Now that we're done cleaning up our overflow container lists, we can
   // give |state| its nsOverflowContinuationTracker.
   nsOverflowContinuationTracker tracker(aPresContext, this, PR_FALSE);
   state.mOverflowTracker = &tracker;
 
-  // Drain & handle float continuations
-  DrainFloatContinuations(state);
+  // Drain & handle pushed floats
+  DrainPushedFloats(state);
   nsRect fcBounds;
   nsReflowStatus fcStatus = NS_FRAME_COMPLETE;
-  rv = ReflowFloatContinuations(state, fcBounds, fcStatus);
+  rv = ReflowPushedFloats(state, fcBounds, fcStatus);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // If we're not dirty (which means we'll mark everything dirty later)
   // and our width has changed, mark the lines dirty that we need to
   // mark dirty for a resize reflow.
   if (aReflowState.mFlags.mHResize)
     PrepareResizeReflow(state);
 
@@ -1024,17 +1024,17 @@ nsBlockFrame::Reflow(nsPresContext*     
   // we need to continue, too.
   if (NS_UNCONSTRAINEDSIZE != aReflowState.availableHeight &&
       NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
       state.mFloatManager->ClearContinues(FindTrailingClear())) {
     NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
   }
 
   if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
-    if (GetOverflowLines() || GetFloatContinuations()) {
+    if (GetOverflowLines() || GetPushedFloats()) {
       state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
     }
 
 #ifdef DEBUG_kipp
     ListTag(stdout); printf(": block is not fully complete\n");
 #endif
   }
 
@@ -1083,17 +1083,17 @@ nsBlockFrame::Reflow(nsPresContext*     
   }
 
   // Compute our final size
   nscoord bottomEdgeOfChildren;
   ComputeFinalSize(aReflowState, state, aMetrics, &bottomEdgeOfChildren);
   ComputeCombinedArea(aReflowState, aMetrics, bottomEdgeOfChildren);
   // Factor overflow container child bounds into the overflow area
   aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea, ocBounds);
-  // Factor float continuation child bounds into the overflow area
+  // Factor pushed float child bounds into the overflow area
   aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea, fcBounds);
 
   // Let the absolutely positioned container reflow any absolutely positioned
   // child frames that need to be reflowed, e.g., elements with a percentage
   // based width/height
   // We want to do this under either of two conditions:
   //  1. If we didn't do the incremental reflow above.
   //  2. If our size changed.
@@ -1765,19 +1765,19 @@ nsBlockFrame::ReflowDirtyLines(nsBlockRe
     // the amount by which we will slide the current line if it is not
     // dirty
   nscoord deltaY = 0;
 
     // whether we did NOT reflow the previous line and thus we need to
     // recompute the carried out margin before the line if we want to
     // reflow it or if its previous margin is dirty
   PRBool needToRecoverState = PR_FALSE;
-    // Float continuations were reflowed in ReflowFloatContinuations
+    // Float continuations were reflowed in ReflowPushedFloats
   PRBool reflowedFloat = mFloats.NotEmpty() &&
-    (mFloats.FirstChild()->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION);
+    (mFloats.FirstChild()->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT);
   PRBool lastLineMovedUp = PR_FALSE;
   // We save up information about BR-clearance here
   PRUint8 inlineFloatBreakType = aState.mFloatBreakType;
 
   line_iterator line = begin_lines(), line_end = end_lines();
 
   // Reflow the lines that are already ours
   for ( ; line != line_end; ++line, aState.AdvanceToNextLine()) {
@@ -3928,17 +3928,17 @@ nsBlockFrame::SplitFloat(nsBlockReflowSt
   if (aFloat->GetStyleDisplay()->mFloats == NS_STYLE_FLOAT_LEFT) {
     aState.mFloatManager->SetSplitLeftFloatAcrossBreak();
   } else {
     NS_ABORT_IF_FALSE(aFloat->GetStyleDisplay()->mFloats ==
                         NS_STYLE_FLOAT_RIGHT, "unexpected float side");
     aState.mFloatManager->SetSplitRightFloatAcrossBreak();
   }
 
-  aState.AppendFloatContinuation(nextInFlow);
+  aState.AppendPushedFloat(nextInFlow);
   return NS_OK;
 }
 
 static nsFloatCache*
 GetLastFloat(nsLineBox* aLine)
 {
   nsFloatCache* fc = aLine->GetFirstFloat();
   while (fc && fc->Next()) {
@@ -3949,17 +3949,17 @@ GetLastFloat(nsLineBox* aLine)
 
 static PRBool
 CheckPlaceholderInLine(nsIFrame* aBlock, nsLineBox* aLine, nsFloatCache* aFC)
 {
   if (!aFC)
     return PR_TRUE;
   NS_ASSERTION(!aFC->mFloat->GetPrevContinuation(),
                "float in a line should never be a continuation");
-  NS_ASSERTION(!(aFC->mFloat->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION),
+  NS_ASSERTION(!(aFC->mFloat->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT),
                "float in a line should never be a pushed float");
   nsIFrame* ph = aBlock->PresContext()->FrameManager()->
                    GetPlaceholderFrameFor(aFC->mFloat->GetFirstInFlow());
   for (nsIFrame* f = ph; f; f = f->GetParent()) {
     if (f->GetParent() == aBlock)
       return aLine->Contains(f);
   }
   NS_ASSERTION(PR_FALSE, "aBlock is not an ancestor of aFrame!");
@@ -4442,25 +4442,25 @@ nsBlockFrame::DrainOverflowLines(nsBlock
     delete ourOverflowLines;
   }
 
   return PR_TRUE;
 }
 
 // This function assumes our prev-in-flow has completed reflow and its
 // mFloats may contain frames at the end of its float list, marked with
-// NS_FRAME_IS_FLOAT_CONTINUATION, that should be pulled to this block.
+// NS_FRAME_IS_PUSHED_FLOAT, that should be pulled to this block.
 void
-nsBlockFrame::DrainFloatContinuations(nsBlockReflowState& aState)
+nsBlockFrame::DrainPushedFloats(nsBlockReflowState& aState)
 {
   // Take any continuations we need to take from our prev-in-flow.
   nsBlockFrame* prevBlock = static_cast<nsBlockFrame*>(GetPrevInFlow());
   if (!prevBlock)
     return;
-  nsFrameList *list = prevBlock->RemoveFloatContinuations();
+  nsFrameList *list = prevBlock->RemovePushedFloats();
   if (list) {
     if (list->NotEmpty()) {
       mFloats.InsertFrames(this, nsnull, *list);
     }
     delete list;
   }
 
 #ifdef DEBUG
@@ -4558,51 +4558,51 @@ nsBlockFrame::SetOverflowOutOfFlows(cons
   else {
     SetPropTableFrames(PresContext(), new nsFrameList(aList),
                        OverflowOutOfFlowsProperty());
     AddStateBits(NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS);
   }
 }
 
 nsFrameList*
-nsBlockFrame::GetFloatContinuations() const
+nsBlockFrame::GetPushedFloats() const
 {
-  if (!(GetStateBits() & NS_BLOCK_HAS_FLOAT_CONTINUATIONS)) {
+  if (!(GetStateBits() & NS_BLOCK_HAS_PUSHED_FLOATS)) {
     return nsnull;
   }
   nsFrameList* result =
-    static_cast<nsFrameList*>(Properties().Get(FloatContinuationProperty()));
+    static_cast<nsFrameList*>(Properties().Get(PushedFloatProperty()));
   NS_ASSERTION(result, "value should always be non-empty when state set");
   return result;
 }
 
 nsFrameList*
-nsBlockFrame::EnsureFloatContinuations()
+nsBlockFrame::EnsurePushedFloats()
 {
-  nsFrameList *result = GetFloatContinuations();
+  nsFrameList *result = GetPushedFloats();
   if (result)
     return result;
 
   result = new nsFrameList;
-  Properties().Set(FloatContinuationProperty(), result);
-  AddStateBits(NS_BLOCK_HAS_FLOAT_CONTINUATIONS);
+  Properties().Set(PushedFloatProperty(), result);
+  AddStateBits(NS_BLOCK_HAS_PUSHED_FLOATS);
 
   return result;
 }
 
 nsFrameList*
-nsBlockFrame::RemoveFloatContinuations()
+nsBlockFrame::RemovePushedFloats()
 {
-  if (!(GetStateBits() & NS_BLOCK_HAS_FLOAT_CONTINUATIONS)) {
+  if (!(GetStateBits() & NS_BLOCK_HAS_PUSHED_FLOATS)) {
     return nsnull;
   }
 
   nsFrameList *result =
-    static_cast<nsFrameList*>(Properties().Remove(FloatContinuationProperty()));
-  RemoveStateBits(NS_BLOCK_HAS_FLOAT_CONTINUATIONS);
+    static_cast<nsFrameList*>(Properties().Remove(PushedFloatProperty()));
+  RemoveStateBits(NS_BLOCK_HAS_PUSHED_FLOATS);
   NS_ASSERTION(result, "value should always be non-empty when state set");
   return result;
 }
 
 //////////////////////////////////////////////////////////////////////
 // Frame list manipulation routines
 
 NS_IMETHODIMP
@@ -4930,17 +4930,17 @@ nsBlockFrame::RemoveFrame(nsIAtom*  aLis
     mAbsoluteContainer.RemoveFrame(this, aListName, aOldFrame);
     return NS_OK;
   }
   else if (nsGkAtoms::floatList == aListName) {
     // Make sure to mark affected lines dirty for the float frame
     // we are removing; this way is a bit messy, but so is the rest of the code.
     // See bug 390762.
     NS_ASSERTION(!aOldFrame->GetPrevContinuation(),
-                 "RemoveFrame should not be called on float continuations.");
+                 "RemoveFrame should not be called on pushed floats.");
     for (nsIFrame* f = aOldFrame;
          f && !(f->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER);
          f = f->GetNextContinuation()) {
       MarkSameFloatManagerLinesDirty(static_cast<nsBlockFrame*>(f->GetParent()));
     }
     DoRemoveOutOfFlowFrame(aOldFrame);
   }
 #ifdef IBMBIDI
@@ -5416,17 +5416,17 @@ nsBlockFrame::StealFrame(nsPresContext* 
                          PRBool         aForceNormal)
 {
   NS_PRECONDITION(aPresContext && aChild, "null pointer");
 
   if ((aChild->GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
       aChild->GetStyleDisplay()->IsFloating()) {
     PRBool removed = mFloats.RemoveFrameIfPresent(aChild);
     if (!removed) {
-      nsFrameList* list = GetFloatContinuations();
+      nsFrameList* list = GetPushedFloats();
       if (list) {
         removed = list->RemoveFrameIfPresent(aChild);
       }
     }
     return removed ? NS_OK : NS_ERROR_UNEXPECTED;
   }
 
   if ((aChild->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)
@@ -5728,23 +5728,23 @@ nsBlockFrame::FindTrailingClear()
       --endLine;
       return endLine->GetBreakTypeAfter();
     }
   }
   return NS_STYLE_CLEAR_NONE;
 }
 
 nsresult
-nsBlockFrame::ReflowFloatContinuations(nsBlockReflowState& aState,
+nsBlockFrame::ReflowPushedFloats(nsBlockReflowState& aState,
                                        nsRect&             aBounds,
                                        nsReflowStatus&     aStatus)
 {
   nsresult rv = NS_OK;
   for (nsIFrame* f = mFloats.FirstChild(), *next;
-       f && (f->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION);
+       f && (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT);
        f = next) {
     // save next sibling now, since reflowing could push the entire
     // float, changing its siblings
     next = f->GetNextSibling();
 
     if (NS_SUBTREE_DIRTY(f) || aState.mReflowState.ShouldReflowAllKids()) {
       // Cache old bounds
       nsRect oldRect = f->GetRect();
@@ -5784,17 +5784,17 @@ nsBlockFrame::ReflowFloatContinuations(n
 
   return rv;
 }
 
 void
 nsBlockFrame::RecoverFloats(nsFloatManager& aFloatManager)
 {
   // Recover our own floats
-  nsIFrame* stop = nsnull; // Stop before we reach float continuations that
+  nsIFrame* stop = nsnull; // Stop before we reach pushed floats that
                            // belong to our next-in-flow
   for (nsIFrame* f = mFloats.FirstChild(); f && f != stop; f = f->GetNextSibling()) {
     nsRect region = nsFloatManager::GetRegionFor(f);
     aFloatManager.AddFloat(f, region);
     if (!stop && f->GetNextInFlow())
       stop = f->GetNextInFlow();
   }
 
@@ -6056,17 +6056,17 @@ nsBlockFrame::BuildDisplayList(nsDisplay
   }
 #endif
 
   DisplayBorderBackgroundOutline(aBuilder, aLists);
 
   if (GetPrevInFlow()) {
     DisplayOverflowContainers(aBuilder, aDirtyRect, aLists);
     for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
-      if (f->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION)
+      if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
          BuildDisplayListForChild(aBuilder, f, aDirtyRect, aLists);
     }
   }
 
   aBuilder->MarkFramesForDisplayList(this, mFloats, aDirtyRect);
   aBuilder->MarkFramesForDisplayList(this, mAbsoluteContainer.GetChildList(),
                                      aDirtyRect);
 
@@ -6676,19 +6676,19 @@ void nsBlockFrame::CollectFloats(nsIFram
                                  PRBool aFromOverflow, PRBool aCollectSiblings) {
   while (aFrame) {
     // Don't descend into float containing blocks.
     if (!aFrame->IsFloatContainingBlock()) {
       nsIFrame *outOfFlowFrame =
         aFrame->GetType() == nsGkAtoms::placeholderFrame ?
           nsLayoutUtils::GetFloatFromPlaceholder(aFrame) : nsnull;
       if (outOfFlowFrame) {
-        if (outOfFlowFrame->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION) {
+        if (outOfFlowFrame->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT) {
           if (outOfFlowFrame->GetParent() == this) {
-            nsFrameList* list = GetFloatContinuations();
+            nsFrameList* list = GetPushedFloats();
             if (!list || !list->RemoveFrameIfPresent(outOfFlowFrame)) {
               mFloats.RemoveFrame(outOfFlowFrame);
             }
             aList.AppendFrame(nsnull, outOfFlowFrame);
           }
         } else {
           // Make sure that its parent is us. Otherwise we don't want
           // to mess around with it because it belongs to someone
@@ -6744,17 +6744,17 @@ nsBlockFrame::CheckFloats(nsBlockReflowS
       anyLineDirty = PR_TRUE;
     }
   }
   
   nsAutoTArray<nsIFrame*, 8> storedFloats;
   PRBool equal = PR_TRUE;
   PRUint32 i = 0;
   for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
-    if (f->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION)
+    if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
       continue;
     storedFloats.AppendElement(f);
     if (i < lineFloats.Length() && lineFloats.ElementAt(i) != f) {
       equal = PR_FALSE;
     }
     ++i;
   }
 
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -89,17 +89,17 @@ class nsIntervalSet;
 /**
  * Some invariants:
  * -- The overflow out-of-flows list contains the out-of-
  * flow frames whose placeholders are in the overflow list.
  * -- A given piece of content has at most one placeholder
  * frame in a block's normal child list.
  * -- While a block is being reflowed, and from then until
  * its next-in-flow is reflowed it may have a
- * FloatContinuationProperty frame property that points to
+ * PushedFloatProperty frame property that points to
  * an nsFrameList. This list contains continuations for
  * floats whose prev-in-flow is in the block's regular float
  * list and first-in-flows of floats that did not fit, but
  * whose placeholders are in the block or one of its
  * prev-in-flows.
  * -- In all these frame lists, if there are two frames for
  * the same content appearing in the list, then the frames
  * appear with the prev-in-flow before the next-in-flow.
@@ -113,17 +113,17 @@ class nsIntervalSet;
 // see nsHTMLParts.h for the public block state bits
 
 /**
  * Something in the block has changed that requires Bidi resolution to be
  * performed on the block. This flag must be either set on all blocks in a 
  * continuation chain or none of them.
  */
 #define NS_BLOCK_NEEDS_BIDI_RESOLUTION      NS_FRAME_STATE_BIT(20)
-#define NS_BLOCK_HAS_FLOAT_CONTINUATIONS    NS_FRAME_STATE_BIT(21)
+#define NS_BLOCK_HAS_PUSHED_FLOATS          NS_FRAME_STATE_BIT(21)
 #define NS_BLOCK_HAS_LINE_CURSOR            NS_FRAME_STATE_BIT(24)
 #define NS_BLOCK_HAS_OVERFLOW_LINES         NS_FRAME_STATE_BIT(25)
 #define NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS  NS_FRAME_STATE_BIT(26)
 
 // Set on any block that has descendant frames in the normal
 // flow with 'clear' set to something other than 'none'
 // (including <BR CLEAR="..."> frames)
 #define NS_BLOCK_HAS_CLEAR_CHILDREN         NS_FRAME_STATE_BIT(27)
@@ -156,17 +156,17 @@ public:
   reverse_line_iterator rend_lines() { return mLines.rend(); }
   const_reverse_line_iterator rbegin_lines() const { return mLines.rbegin(); }
   const_reverse_line_iterator rend_lines() const { return mLines.rend(); }
 
   friend nsIFrame* NS_NewBlockFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
 
   // This is a child list too, but we let nsBlockReflowState get to it
   // directly too.
-  NS_DECLARE_FRAME_PROPERTY(FloatContinuationProperty,
+  NS_DECLARE_FRAME_PROPERTY(PushedFloatProperty,
                             nsContainerFrame::DestroyFrameList)
 
   // nsQueryFrame
   NS_DECL_QUERYFRAME
 
   // nsIFrame
   NS_IMETHOD Init(nsIContent*      aContent,
                   nsIFrame*        aParent,
@@ -456,29 +456,29 @@ public:
 protected:
 
   /** grab overflow lines from this block's prevInFlow, and make them
     * part of this block's mLines list.
     * @return PR_TRUE if any lines were drained.
     */
   PRBool DrainOverflowLines(nsBlockReflowState& aState);
 
-  /** grab float continuations from this block's prevInFlow, and splice
+  /** grab pushed floats from this block's prevInFlow, and splice
     * them into this block's mFloats list.
     */
-  void DrainFloatContinuations(nsBlockReflowState& aState);
+  void DrainPushedFloats(nsBlockReflowState& aState);
 
   /** Load all our floats into the float manager (without reflowing them).
    *  Assumes float manager is in our own coordinate system.
    */
   void RecoverFloats(nsFloatManager& aFloatManager);
 
-  /** Reflow float continuations
+  /** Reflow pushed floats
    */
-  nsresult ReflowFloatContinuations(nsBlockReflowState& aState,
+  nsresult ReflowPushedFloats(nsBlockReflowState& aState,
                                     nsRect&             aBounds,
                                     nsReflowStatus&     aStatus);
 
   /** Find any trailing BR clear from the last line of the block (or its PIFs)
    */
   PRUint8 FindTrailingClear();
 
   /**
@@ -719,23 +719,23 @@ protected:
     nsFrameList* const mPropValue;
     nsBlockFrame* const mBlock;
   };
   friend struct nsAutoOOFFrameList;
 
   nsFrameList* GetOverflowOutOfFlows() const;
   void SetOverflowOutOfFlows(const nsFrameList& aList, nsFrameList* aPropValue);
 
-  // Get the float continuations list
-  nsFrameList* GetFloatContinuations() const;
-  // Get the float continuations list, or if there is not currently one,
+  // Get the pushed floats list
+  nsFrameList* GetPushedFloats() const;
+  // Get the pushed floats list, or if there is not currently one,
   // make a new empty one.
-  nsFrameList* EnsureFloatContinuations();
-  // Remove and return the float continuations list.
-  nsFrameList* RemoveFloatContinuations();
+  nsFrameList* EnsurePushedFloats();
+  // Remove and return the pushed floats list.
+  nsFrameList* RemovePushedFloats();
 
 #ifdef NS_DEBUG
   void VerifyLines(PRBool aFinalCheckOK);
   void VerifyOverflowSituation();
   PRInt32 GetDepth() const;
 #endif
 
   nscoord mMinWidth, mPrefWidth;
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -66,17 +66,17 @@ nsBlockReflowState::nsBlockReflowState(c
                                        nsBlockFrame* aFrame,
                                        const nsHTMLReflowMetrics& aMetrics,
                                        PRBool aTopMarginRoot,
                                        PRBool aBottomMarginRoot,
                                        PRBool aBlockNeedsFloatManager)
   : mBlock(aFrame),
     mPresContext(aPresContext),
     mReflowState(aReflowState),
-    mFloatContinuations(nsnull),
+    mPushedFloats(nsnull),
     mOverflowTracker(nsnull),
     mPrevBottomMargin(),
     mLineNumber(0),
     mFlags(0),
     mFloatBreakType(NS_STYLE_CLEAR_NONE)
 {
   SetFlag(BRS_ISFIRSTINFLOW, aFrame->GetPrevInFlow() == nsnull);
   SetFlag(BRS_ISOVERFLOWCONTAINER,
@@ -421,29 +421,29 @@ nsBlockReflowState::ReconstructMarginAbo
         mPrevBottomMargin.Zero();
       }
       break;
     }
   }
 }
 
 void
-nsBlockReflowState::SetupFloatContinuationList()
+nsBlockReflowState::SetupPushedFloatList()
 {
-  NS_ABORT_IF_FALSE(!GetFlag(BRS_PROPTABLE_FLOATCLIST) == !mFloatContinuations,
+  NS_ABORT_IF_FALSE(!GetFlag(BRS_PROPTABLE_FLOATCLIST) == !mPushedFloats,
                     "flag mismatch");
   if (!GetFlag(BRS_PROPTABLE_FLOATCLIST)) {
     // If we're being re-Reflow'd without our next-in-flow having been
-    // reflowed, some float continuations from our previous reflow might
-    // still be on our float continuations list.  However, that's
+    // reflowed, some pushed floats from our previous reflow might
+    // still be on our pushed floats list.  However, that's
     // actually fine, since they'll all end up being stolen and
     // reordered into the correct order again.
     // (nsBlockFrame::ReflowDirtyLines ensures that any lines with
     // pushed floats are reflowed.)
-    mFloatContinuations = mBlock->EnsureFloatContinuations();
+    mPushedFloats = mBlock->EnsurePushedFloats();
     SetFlag(BRS_PROPTABLE_FLOATCLIST, PR_TRUE);
   }
 }
 
 /**
  * Restore information about floats into the float manager for an
  * incremental reflow, and simultaneously push the floats by
  * |aDeltaY|, which is the amount |aLine| was pushed relative to its
@@ -547,30 +547,30 @@ nsBlockReflowState::AddFloat(nsLineLayou
   NS_PRECONDITION(mBlock->end_lines() != mCurrentLine, "null ptr");
   NS_PRECONDITION(aFloat->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
                   "aFloat must be an out-of-flow frame");
 
   NS_ABORT_IF_FALSE(aFloat->GetParent(), "float must have parent");
   NS_ABORT_IF_FALSE(aFloat->GetParent()->IsFrameOfType(nsIFrame::eBlockFrame),
                     "float's parent must be block");
   NS_ABORT_IF_FALSE(aFloat->GetParent() == mBlock ||
-                    (aFloat->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION),
+                    (aFloat->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT),
                     "float should be in this block unless it was marked as "
-                    "float continuation");
-  if (aFloat->GetStateBits() & NS_FRAME_IS_FLOAT_CONTINUATION) {
+                    "pushed float");
+  if (aFloat->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT) {
     // If, in a previous reflow, the float was pushed entirely to
     // another column/page, we need to steal it back.  (We might just
     // push it again, though.)  Likewise, if that previous reflow
     // reflowed this block but not its next continuation, we might need
     // to steal it from our own float-continuations list.
     nsBlockFrame *floatParent =
       static_cast<nsBlockFrame*>(aFloat->GetParent());
     floatParent->StealFrame(mPresContext, aFloat);
 
-    aFloat->RemoveStateBits(NS_FRAME_IS_FLOAT_CONTINUATION);
+    aFloat->RemoveStateBits(NS_FRAME_IS_PUSHED_FLOAT);
 
     // Appending is fine, since if a float was pushed to the next
     // page/column, all later floats were also pushed.
     mBlock->mFloats.AppendFrame(mBlock, aFloat);
   }
 
   // Because we are in the middle of reflowing a placeholder frame
   // within a line (and possibly nested in an inline frame or two
@@ -942,21 +942,21 @@ nsBlockReflowState::PushFloatPastBreak(n
     mFloatManager->SetPushedLeftFloatPastBreak();
   } else {
     NS_ABORT_IF_FALSE(aFloat->GetStyleDisplay()->mFloats ==
                         NS_STYLE_FLOAT_RIGHT,
                       "unexpected float value");
     mFloatManager->SetPushedRightFloatPastBreak();
   }
 
-  // Put the float on the float continuations list, even though it
+  // Put the float on the pushed floats list, even though it
   // isn't actually a continuation.
   nsresult rv = mBlock->StealFrame(mPresContext, aFloat);
   NS_ASSERTION(NS_SUCCEEDED(rv), "StealFrame should succeed");
-  AppendFloatContinuation(aFloat);
+  AppendPushedFloat(aFloat);
 
   NS_FRAME_SET_OVERFLOW_INCOMPLETE(mReflowStatus);
 }
 
 /**
  * Place below-current-line floats.
  */
 void
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -57,17 +57,17 @@
 // Set when mLineAdjacentToTop is valid
 #define BRS_HAVELINEADJACENTTOTOP 0x00000020
 // Set when the block has the equivalent of NS_BLOCK_FLOAT_MGR
 #define BRS_FLOAT_MGR             0x00000040
 // Set when nsLineLayout::LineIsEmpty was true at the end of reflowing
 // the current line
 #define BRS_LINE_LAYOUT_EMPTY     0x00000080
 #define BRS_ISOVERFLOWCONTAINER   0x00000100
-// Our mFloatContinuations list is stored on the blocks' proptable
+// Our mPushedFloats list is stored on the blocks' proptable
 #define BRS_PROPTABLE_FLOATCLIST  0x00000200
 #define BRS_LASTFLAG              BRS_PROPTABLE_FLOATCLIST
 
 class nsBlockReflowState {
 public:
   nsBlockReflowState(const nsHTMLReflowState& aReflowState,
                      nsPresContext* aPresContext,
                      nsBlockFrame* aFrame,
@@ -96,17 +96,17 @@ public:
   nsFlowAreaRect
     GetFloatAvailableSpaceForHeight(nscoord aY, nscoord aHeight,
                                     nsFloatManager::SavedState *aState) const;
 
   /*
    * The following functions all return PR_TRUE if they were able to
    * place the float, PR_FALSE if the float did not fit in available
    * space.
-   * aLineLayout is null when we are reflowing float continuations (because
+   * aLineLayout is null when we are reflowing pushed floats (because
    * they are not associated with a line box).
    */
   PRBool AddFloat(nsLineLayout*       aLineLayout,
                   nsIFrame*           aFloat,
                   nscoord             aAvailableWidth);
 private:
   PRBool CanPlaceFloat(nscoord aFloatWidth,
                        const nsFlowAreaRect& aFloatAvailableSpace);
@@ -225,25 +225,25 @@ public:
   // mBorderPadding.top. The width/height may be NS_UNCONSTRAINEDSIZE
   // if the container reflowing this frame has given the frame an
   // unconstrained area.
   nsSize mContentArea;
 
   // Continuation out-of-flow float frames that need to move to our
   // next in flow are placed here during reflow.  It's a pointer to
   // a frame list stored in the block's property table.
-  nsFrameList *mFloatContinuations;
-  // This method makes sure float continuations are accessible to
-  // StealFrame. Call it before adding any frames to mFloatContinuations.
-  void SetupFloatContinuationList();
-  // Use this method to append to mFloatContinuations.
-  void AppendFloatContinuation(nsIFrame* aFloatCont) {
-    SetupFloatContinuationList();
-    aFloatCont->AddStateBits(NS_FRAME_IS_FLOAT_CONTINUATION);
-    mFloatContinuations->AppendFrame(mBlock, aFloatCont);
+  nsFrameList *mPushedFloats;
+  // This method makes sure pushed floats are accessible to
+  // StealFrame. Call it before adding any frames to mPushedFloats.
+  void SetupPushedFloatList();
+  // Use this method to append to mPushedFloats.
+  void AppendPushedFloat(nsIFrame* aFloatCont) {
+    SetupPushedFloatList();
+    aFloatCont->AddStateBits(NS_FRAME_IS_PUSHED_FLOAT);
+    mPushedFloats->AppendFrame(mBlock, aFloatCont);
   }
 
   // Track child overflow continuations.
   nsOverflowContinuationTracker* mOverflowTracker;
 
   //----------------------------------------
 
   // This state is "running" state updated by the reflow of each line
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -255,17 +255,17 @@ typedef PRUint64 nsFrameState;
 
 // Bits 20-31 of the frame state are reserved for implementations.
 #define NS_FRAME_IMPL_RESERVED                      nsFrameState(0xFFF00000)
 
 // This bit is set on floats whose parent does not contain their
 // placeholder.  This can happen for two reasons:  (1) the float was
 // split, and this piece is the continuation, or (2) the entire float
 // didn't fit on the page.
-#define NS_FRAME_IS_FLOAT_CONTINUATION              NS_FRAME_STATE_BIT(32)
+#define NS_FRAME_IS_PUSHED_FLOAT                    NS_FRAME_STATE_BIT(32)
 
 // The lower 20 bits and upper 32 bits of the frame state are reserved
 // by this API.
 #define NS_FRAME_RESERVED                           ~NS_FRAME_IMPL_RESERVED
 
 // Box layout bits
 #define NS_STATE_IS_HORIZONTAL                      NS_FRAME_STATE_BIT(22)
 #define NS_STATE_IS_DIRECTION_NORMAL                NS_FRAME_STATE_BIT(31)
