From: L. David Baron <dbaron@dbaron.org>

Use correct scrolled content size in nsXULScrollFrame when we allow scrolling up or to the right.  (Bug 508816)

diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -2802,32 +2802,35 @@ nsXULScrollFrame::LayoutScrollArea(nsBox
   nsRect childRect = nsRect(mInner.mScrollPort.TopLeft() - aScrollPosition,
                             mInner.mScrollPort.Size());
   PRInt32 flags = NS_FRAME_NO_MOVE_VIEW;
 
   nsRect originalRect = mInner.mScrolledFrame->GetRect();
   nsRect originalVisOverflow = mInner.mScrolledFrame->GetVisualOverflowRect();
 
   nsSize minSize = mInner.mScrolledFrame->GetMinSize(aState);
-  
+
   if (minSize.height > childRect.height)
     childRect.height = minSize.height;
-  
+
   if (minSize.width > childRect.width)
     childRect.width = minSize.width;
 
   aState.SetLayoutFlags(flags);
   ClampAndSetBounds(aState, childRect, aScrollPosition);
   mInner.mScrolledFrame->Layout(aState);
 
   childRect = mInner.mScrolledFrame->GetRect();
 
   if (childRect.width < mInner.mScrollPort.width ||
       childRect.height < mInner.mScrollPort.height)
   {
+    // This leaves a frame that shrunk smaller than we told it to be
+    // in the top-left corner of its parent, which might not be ideal
+    // for RTL, or even for some values of box-align and box-pack.
     childRect.width = NS_MAX(childRect.width, mInner.mScrollPort.width);
     childRect.height = NS_MAX(childRect.height, mInner.mScrollPort.height);
 
     // remove overflow areas when we update the bounds,
     // because we've already accounted for it
     // REVIEW: Have we accounted for both?
     ClampAndSetBounds(aState, childRect, aScrollPosition, true);
   }
