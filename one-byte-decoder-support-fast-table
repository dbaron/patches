From: L. David Baron <dbaron@dbaron.org>

Make nsOneByteDecoderSupport expect to be given the fast table rather than the mapping table.  (Won't compile without the next patch, which changes the callers.)

diff --git a/intl/uconv/util/nsUCSupport.cpp b/intl/uconv/util/nsUCSupport.cpp
--- a/intl/uconv/util/nsUCSupport.cpp
+++ b/intl/uconv/util/nsUCSupport.cpp
@@ -302,47 +302,34 @@ NS_IMETHODIMP nsMultiTableDecoderSupport
                                                     mMappingTable,
                                                     mErrBehavior == kOnError_Signal);
 }
 
 //----------------------------------------------------------------------
 // Class nsOneByteDecoderSupport [implementation]
 
 nsOneByteDecoderSupport::nsOneByteDecoderSupport(
-                         uMappingTable  * aMappingTable)
+                         const PRUnichar* aFastTable)
   : nsBasicDecoderSupport()
-  , mMappingTable(aMappingTable)
-  , mFastTableCreated(PR_FALSE)
-  , mFastTableMutex("nsOneByteDecoderSupport mFastTableMutex")
+  , mFastTable(aFastTable)
 {
 }
 
 nsOneByteDecoderSupport::~nsOneByteDecoderSupport()
 {
 }
 
 //----------------------------------------------------------------------
 // Subclassing of nsBasicDecoderSupport class [implementation]
 
 NS_IMETHODIMP nsOneByteDecoderSupport::Convert(const char * aSrc,
                                               PRInt32 * aSrcLength,
                                               PRUnichar * aDest,
                                               PRInt32 * aDestLength)
 {
-  if (!mFastTableCreated) {
-    // Probably better to make this non-lazy and get rid of the mutex
-    mozilla::MutexAutoLock autoLock(mFastTableMutex);
-    if (!mFastTableCreated) {
-      nsresult res = nsUnicodeDecodeHelper::CreateFastTable(
-                         mMappingTable, mFastTable, ONE_BYTE_TABLE_SIZE);
-      if (NS_FAILED(res)) return res;
-      mFastTableCreated = PR_TRUE;
-    }
-  }
-
   return nsUnicodeDecodeHelper::ConvertByFastTable(aSrc, aSrcLength,
                                                    aDest, aDestLength,
                                                    mFastTable,
                                                    ONE_BYTE_TABLE_SIZE,
                                                    mErrBehavior == kOnError_Signal);
 }
 
 NS_IMETHODIMP nsOneByteDecoderSupport::GetMaxLength(const char * aSrc,
diff --git a/intl/uconv/util/nsUCSupport.h b/intl/uconv/util/nsUCSupport.h
--- a/intl/uconv/util/nsUCSupport.h
+++ b/intl/uconv/util/nsUCSupport.h
@@ -263,30 +263,29 @@ protected:
  * @author  Catalin Rotaru [CATA]
  */
 class nsOneByteDecoderSupport : public nsBasicDecoderSupport
 {
 public:
 
   /**
    * Class constructor.
+   *
+   * The argument is a PRUnichar array of ONE_BYTE_TABLE_SIZE elements.
    */
-  nsOneByteDecoderSupport(uMappingTable * aMappingTable);
+  nsOneByteDecoderSupport(const PRUnichar *aFastTable);
 
   /**
    * Class destructor.
    */
   virtual ~nsOneByteDecoderSupport();
 
 protected:
 
-  uMappingTable             * mMappingTable;
-  PRUnichar                 mFastTable[ONE_BYTE_TABLE_SIZE];
-  PRBool                    mFastTableCreated;
-  mozilla::Mutex            mFastTableMutex;
+  const PRUnichar *         mFastTable;
 
   //--------------------------------------------------------------------
   // Subclassing of nsBasicDecoderSupport class [declaration]
 
   NS_IMETHOD Convert(const char * aSrc, PRInt32 * aSrcLength, 
       PRUnichar * aDest, PRInt32 * aDestLength);
   NS_IMETHOD GetMaxLength(const char * aSrc, PRInt32 aSrcLength, 
       PRInt32 * aDestLength);
