From: L. David Baron <dbaron@dbaron.org>

Bug 530330 patch 3 - Make nsOneByteDecoderSupport expect to be given the fast table rather than the mapping table.  (Won't compile without the next patch, which changes the callers.)

diff --git a/intl/uconv/nsUCSupport.h b/intl/uconv/nsUCSupport.h
--- a/intl/uconv/nsUCSupport.h
+++ b/intl/uconv/nsUCSupport.h
@@ -199,30 +199,29 @@ protected:
  * @author  Catalin Rotaru [CATA]
  */
 class nsOneByteDecoderSupport : public nsBasicDecoderSupport
 {
 public:
 
   /**
    * Class constructor.
+   *
+   * The argument is a char16_t array of ONE_BYTE_TABLE_SIZE elements.
    */
-  explicit nsOneByteDecoderSupport(uMappingTable * aMappingTable);
+  explicit nsOneByteDecoderSupport(const char16_t *aFastTable);
 
   /**
    * Class destructor.
    */
   virtual ~nsOneByteDecoderSupport();
 
 protected:
 
-  uMappingTable             * mMappingTable;
-  char16_t                 mFastTable[ONE_BYTE_TABLE_SIZE];
-  bool                      mFastTableCreated;
-  mozilla::Mutex            mFastTableMutex;
+  const char16_t *         mFastTable;
 
   //--------------------------------------------------------------------
   // Subclassing of nsBasicDecoderSupport class [declaration]
 
   NS_IMETHOD Convert(const char * aSrc, int32_t * aSrcLength, 
       char16_t * aDest, int32_t * aDestLength);
   NS_IMETHOD GetMaxLength(const char * aSrc, int32_t aSrcLength, 
       int32_t * aDestLength);
diff --git a/intl/uconv/util/nsUCConstructors.cpp b/intl/uconv/util/nsUCConstructors.cpp
--- a/intl/uconv/util/nsUCConstructors.cpp
+++ b/intl/uconv/util/nsUCConstructors.cpp
@@ -112,17 +112,17 @@ CreateTableEncoder(uScanClassID aScanCla
                    void** aResult)
 {
     return CreateTableEncoder(aScanClass, nullptr,
                               aMappingTable, aMaxLengthFactor,
                               aOuter, aIID, aResult);
 }
 
 nsresult
-CreateOneByteDecoder(uMappingTable * aMappingTable,
+CreateOneByteDecoder(const char16_t * aMappingTable,
                      nsISupports* aOuter,
                      REFNSIID aIID,
                      void** aResult)
 {
     if (aOuter) return NS_ERROR_NO_AGGREGATION;
 
     nsOneByteDecoderSupport* decoder =
         new nsOneByteDecoderSupport(aMappingTable);
diff --git a/intl/uconv/util/nsUCConstructors.h b/intl/uconv/util/nsUCConstructors.h
--- a/intl/uconv/util/nsUCConstructors.h
+++ b/intl/uconv/util/nsUCConstructors.h
@@ -56,15 +56,15 @@ nsresult
 CreateTableEncoder(uScanClassID aScanClass,
                    uMappingTable  * aMappingTable,
                    uint32_t aMaxLengthFactor,
                    nsISupports* aOuter,
                    REFNSIID aIID,
                    void** aResult);
 
 nsresult
-CreateOneByteDecoder(uMappingTable * aMappingTable,
+CreateOneByteDecoder(const char16_t * aMappingTable,
                      nsISupports* aOuter,
                      REFNSIID aIID,
                      void** aResult);
 
                    
 #endif
diff --git a/intl/uconv/util/nsUCSupport.cpp b/intl/uconv/util/nsUCSupport.cpp
--- a/intl/uconv/util/nsUCSupport.cpp
+++ b/intl/uconv/util/nsUCSupport.cpp
@@ -234,47 +234,34 @@ NS_IMETHODIMP nsMultiTableDecoderSupport
                                                     mMappingTable,
                                                     mErrBehavior == kOnError_Signal);
 }
 
 //----------------------------------------------------------------------
 // Class nsOneByteDecoderSupport [implementation]
 
 nsOneByteDecoderSupport::nsOneByteDecoderSupport(
-                         uMappingTable* aMappingTable)
+                         const char16_t* aFastTable)
   : nsBasicDecoderSupport()
-  , mMappingTable(aMappingTable)
-  , mFastTableCreated(false)
-  , mFastTableMutex("nsOneByteDecoderSupport mFastTableMutex")
+  , mFastTable(aFastTable)
 {
 }
 
 nsOneByteDecoderSupport::~nsOneByteDecoderSupport()
 {
 }
 
 //----------------------------------------------------------------------
 // Subclassing of nsBasicDecoderSupport class [implementation]
 
 NS_IMETHODIMP nsOneByteDecoderSupport::Convert(const char* aSrc,
                                               int32_t* aSrcLength,
                                               char16_t* aDest,
                                               int32_t* aDestLength)
 {
-  if (!mFastTableCreated) {
-    // Probably better to make this non-lazy and get rid of the mutex
-    mozilla::MutexAutoLock autoLock(mFastTableMutex);
-    if (!mFastTableCreated) {
-      nsresult res = nsUnicodeDecodeHelper::CreateFastTable(
-                         mMappingTable, mFastTable, ONE_BYTE_TABLE_SIZE);
-      if (NS_FAILED(res)) return res;
-      mFastTableCreated = true;
-    }
-  }
-
   return nsUnicodeDecodeHelper::ConvertByFastTable(aSrc, aSrcLength,
                                                    aDest, aDestLength,
                                                    mFastTable,
                                                    ONE_BYTE_TABLE_SIZE,
                                                    mErrBehavior == kOnError_Signal);
 }
 
 NS_IMETHODIMP nsOneByteDecoderSupport::GetMaxLength(const char* aSrc,
