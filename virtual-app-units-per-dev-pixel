From: L. David Baron <dbaron@dbaron.org>

Add a virtual nsDisplayItem::AppUnitsPerDevPixel to deal with nsDisplayClipRoundedRect sometimes lacking an underlying frame.  (Bug 485501)

diff --git a/layout/base/FrameLayerBuilder.cpp b/layout/base/FrameLayerBuilder.cpp
--- a/layout/base/FrameLayerBuilder.cpp
+++ b/layout/base/FrameLayerBuilder.cpp
@@ -642,34 +642,16 @@ ContainerState::CreateOrRecycleThebesLay
   gfxMatrix matrix;
   matrix.Translate(gfxPoint(pixOffset.x, pixOffset.y));
   layer->SetTransform(gfx3DMatrix::From2D(matrix));
 
   return layer.forget();
 }
 
 /**
- * Returns the appunits per dev pixel for the item's frame. The item must
- * have a frame because only nsDisplayClip items don't have a frame,
- * and those items are flattened away by ProcessDisplayItems.
- */
-static PRUint32
-AppUnitsPerDevPixel(nsDisplayItem* aItem)
-{
-  // The underlying frame for zoom items is the root frame of the subdocument.
-  // But zoom display items report their bounds etc using the parent document's
-  // APD because zoom items act as a conversion layer between the two different
-  // APDs.
-  if (aItem->GetType() == nsDisplayItem::TYPE_ZOOM) {
-    return static_cast<nsDisplayZoom*>(aItem)->GetParentAppUnitsPerDevPixel();
-  }
-  return aItem->GetUnderlyingFrame()->PresContext()->AppUnitsPerDevPixel();
-}
-
-/**
  * Set the visible rect of aLayer. aLayer is in the coordinate system
  * *after* aLayer's transform has been applied, so we need to
  * apply the inverse of that transform before calling SetVisibleRegion.
  */
 static void
 SetVisibleRectForLayer(Layer* aLayer, const nsIntRect& aRect)
 {
   gfxMatrix transform;
@@ -879,17 +861,17 @@ BuildTempManagerForInactiveLayer(nsDispl
   // during the construction phase for the retained layer tree.
   nsRefPtr<BasicLayerManager> tempManager = new BasicLayerManager();
   tempManager->BeginTransaction();
   nsRefPtr<Layer> layer = aItem->BuildLayer(aBuilder, tempManager);
   if (!layer) {
     tempManager->EndTransaction(nsnull, nsnull);
     return nsnull;
   }
-  PRInt32 appUnitsPerDevPixel = AppUnitsPerDevPixel(aItem);
+  PRInt32 appUnitsPerDevPixel = aItem->AppUnitsPerDevPixel();
   nsIntRect itemVisibleRect =
     aItem->GetVisibleRect().ToNearestPixels(appUnitsPerDevPixel);
   SetVisibleRectForLayer(layer, itemVisibleRect);
 
   tempManager->SetRoot(layer);
   // No painting should occur yet, since there is no target context.
   tempManager->EndTransaction(nsnull, nsnull);
   return tempManager.forget();
@@ -921,17 +903,17 @@ ContainerState::ProcessDisplayItems(cons
       nsRect clip = clipItem->GetClipRect();
       if (aClipRect) {
         clip.IntersectRect(clip, *aClipRect);
       }
       ProcessDisplayItems(*clipItem->GetList(), &clip);
       continue;
     }
 
-    NS_ASSERTION(appUnitsPerDevPixel == AppUnitsPerDevPixel(item),
+    NS_ASSERTION(appUnitsPerDevPixel == item->AppUnitsPerDevPixel(),
       "items in a container layer should all have the same app units per dev pixel");
 
     nsIntRect itemVisibleRect =
       item->GetVisibleRect().ToNearestPixels(appUnitsPerDevPixel);
     nsRect itemContent = item->GetBounds(mBuilder);
     if (aClipRect) {
       itemContent.IntersectRect(*aClipRect, itemContent);
     }
@@ -1045,17 +1027,17 @@ ContainerState::InvalidateForLayerChange
   }
   if (aNewLayer != oldLayer) {
     // The item has changed layers.
     // Invalidate the bounds in the old layer and new layer.
     // The bounds might have changed, but we assume that any difference
     // in the bounds will have been invalidated for all Thebes layers
     // in the container via regular frame invalidation.
     nsRect bounds = aItem->GetBounds(mBuilder);
-    PRInt32 appUnitsPerDevPixel = AppUnitsPerDevPixel(aItem);
+    PRInt32 appUnitsPerDevPixel = aItem->AppUnitsPerDevPixel();
     nsIntRect r = bounds.ToOutsidePixels(appUnitsPerDevPixel);
 
     ThebesLayer* t = oldLayer->AsThebesLayer();
     if (t) {
       InvalidatePostTransformRegion(t, r);
     }
     if (aNewLayer) {
       ThebesLayer* newLayer = aNewLayer->AsThebesLayer();
@@ -1434,17 +1416,17 @@ FrameLayerBuilder::DrawThebesLayer(Thebe
   // case the mVisibleRect stored in the display item may be wrong.
   nsRegion visible = aRegionToDraw.ToAppUnits(appUnitsPerDevPixel);
   visible.MoveBy(NSIntPixelsToAppUnits(offset.x, appUnitsPerDevPixel),
                  NSIntPixelsToAppUnits(offset.y, appUnitsPerDevPixel));
 
   for (i = items.Length(); i > 0; --i) {
     ClippedDisplayItem* cdi = &items[i - 1];
 
-    NS_ASSERTION(AppUnitsPerDevPixel(cdi->mItem) == appUnitsPerDevPixel,
+    NS_ASSERTION(cdi->mItem->AppUnitsPerDevPixel() == appUnitsPerDevPixel,
                  "a thebes layer should contain items only at the same zoom");
 
     if (!cdi->mHasClipRect || cdi->mClipRect.Contains(visible.GetBounds())) {
       cdi->mItem->RecomputeVisibility(builder, &visible);
       continue;
     }
 
     // Do a little dance to account for the fact that we're clipping
diff --git a/layout/base/crashtests/485501-1.html b/layout/base/crashtests/485501-1.html
new file mode 100644
--- /dev/null
+++ b/layout/base/crashtests/485501-1.html
@@ -0,0 +1,4 @@
+<!DOCTYPE HTML>
+<div style="overflow: hidden; -moz-border-radius: 50px; height: 200px; width: 200px; background:yellow">
+  This is some text that should get clipped at the corners by the border radius.
+</div>
diff --git a/layout/base/crashtests/crashtests.list b/layout/base/crashtests/crashtests.list
--- a/layout/base/crashtests/crashtests.list
+++ b/layout/base/crashtests/crashtests.list
@@ -252,16 +252,17 @@ load 468645-3.xhtml
 load 469861-1.xhtml
 load 469861-2.xhtml
 load 471594-1.xhtml
 load 479114-1.html
 load 477333-1.xhtml
 load 477731-1.html
 load 481806-1.html
 load 483604-1.xhtml
+load 485501-1.html
 load 487544-1.html
 load 488390-1.xhtml
 load 489691.html
 load 490376-1.xhtml
 load 490559-1.html
 load 490747.html
 load 491547-1.xul
 load 491547-2.xul
diff --git a/layout/base/nsDisplayList.h b/layout/base/nsDisplayList.h
--- a/layout/base/nsDisplayList.h
+++ b/layout/base/nsDisplayList.h
@@ -472,16 +472,25 @@ public:
    * this display item in the display item tree.
    * This will only return a zero value for items which wrap display lists
    * and do not create a CSS stacking context, therefore requiring
    * display items to be individually wrapped --- currently nsDisplayClip
    * and nsDisplayClipRoundedRect only.
    */
   virtual PRUint32 GetPerFrameKey() { return PRUint32(GetType()); }
   /**
+   * Return the AppUnitsPerDevPixel in which this display item reports
+   * its bounds.  For nsDisplayZoom display items, which act as a
+   * conversion layer between two different APDs, this is the parent
+   * document's APD.
+   */
+  virtual PRInt32 AppUnitsPerDevPixel() {
+    return GetUnderlyingFrame()->PresContext()->AppUnitsPerDevPixel();
+  }
+  /**
    * This is called after we've constructed a display list for event handling.
    * When this is called, we've already ensured that aRect intersects the
    * item's bounds.
    * 
    * @param aState must point to a HitTestState. If you don't have one,
    * just create one with the default constructor and pass it in.
    * @param aOutFrames each item appends the frame(s) in this display item that
    * the rect is considered over (if any) to aOutFrames.
@@ -1579,17 +1588,25 @@ public:
    */
   nsDisplayClip(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
                 nsDisplayItem* aItem, const nsRect& aRect);
   nsDisplayClip(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
                 nsDisplayList* aList, const nsRect& aRect);
 #ifdef NS_BUILD_REFCNT_LOGGING
   virtual ~nsDisplayClip();
 #endif
-  
+
+#ifdef DEBUG
+  virtual PRInt32 AppUnitsPerDevPixel() {
+    NS_NOTREACHED("nsDisplayClip items should be flattened away by "
+                  "ProcessDisplayItems");
+    return 1;
+  }
+#endif
+
   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder);
   virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx);
   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
                                    nsRegion* aVisibleRegion);
   virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
   NS_DISPLAY_DECL_NAME("Clip", TYPE_CLIP)
   virtual PRUint32 GetPerFrameKey() { return 0; }
   
@@ -1619,16 +1636,19 @@ public:
                            const nsRect& aRect, nscoord aRadii[8]);
   nsDisplayClipRoundedRect(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
                            nsDisplayList* aList, nsIFrame* aClippingFrame,
                            const nsRect& aRect, nscoord aRadii[8]);
 #ifdef NS_BUILD_REFCNT_LOGGING
   virtual ~nsDisplayClipRoundedRect();
 #endif
 
+  virtual PRInt32 AppUnitsPerDevPixel() {
+    return mClippingFrame->PresContext()->AppUnitsPerDevPixel();
+  }
   virtual PRBool IsOpaque(nsDisplayListBuilder* aBuilder);
   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames);
   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
     return mBounds;
   }
   virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx);
   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
