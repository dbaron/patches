Remove nsTableFrame::GetBorderPadding.  b=367458

diff -r bea9043ae065 layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp	Sat Jan 27 10:48:46 2007 -0800
+++ b/layout/tables/nsTableCellFrame.cpp	Sat Jan 27 10:48:49 2007 -0800
@@ -515,14 +515,13 @@ nsTableCellFrame::GetSelfOverflow(nsRect
 
 // Align the cell's child frame within the cell
 
-void nsTableCellFrame::VerticallyAlignChild(const nsHTMLReflowState& aReflowState,
-                                            nscoord                  aMaxAscent)
+void nsTableCellFrame::VerticallyAlignChild(nscoord aMaxAscent)
 {
   const nsStyleTextReset* textStyle = GetStyleTextReset();
   /* It's the 'border-collapse' on the table that matters */
   nsPresContext* presContext = GetPresContext();
   GET_PIXELS_TO_TWIPS(presContext, p2t);
-  nsMargin borderPadding = nsTableFrame::GetBorderPadding(aReflowState, p2t, this);
+  nsMargin borderPadding = GetUsedBorderAndPadding();
   
   nscoord topInset = borderPadding.top;
   nscoord bottomInset = borderPadding.bottom;
diff -r bea9043ae065 layout/tables/nsTableCellFrame.h
--- a/layout/tables/nsTableCellFrame.h	Sat Jan 27 10:48:46 2007 -0800
+++ b/layout/tables/nsTableCellFrame.h	Sat Jan 27 10:48:49 2007 -0800
@@ -154,8 +154,7 @@ public:
   NS_IMETHOD GetFrameName(nsAString& aResult) const;
 #endif
 
-  void VerticallyAlignChild(const nsHTMLReflowState& aReflowState,
-                            nscoord                  aMaxAscent);
+  void VerticallyAlignChild(nscoord aMaxAscent);
 
   PRBool HasVerticalAlignBaseline();
 
diff -r bea9043ae065 layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp	Sat Jan 27 10:48:46 2007 -0800
+++ b/layout/tables/nsTableFrame.cpp	Sat Jan 27 10:48:49 2007 -0800
@@ -3056,8 +3056,7 @@ nsTableFrame::CalcDesiredHeight(const ns
 }
 
 static
-void ResizeCells(nsTableFrame&            aTableFrame,
-                 const nsHTMLReflowState& aReflowState)
+void ResizeCells(nsTableFrame& aTableFrame)
 {
   nsAutoVoidArray rowGroups;
   PRUint32 numRowGroups;
@@ -3080,7 +3079,7 @@ void ResizeCells(nsTableFrame&          
                                       groupDesiredSize.height);
     nsTableRowFrame* rowFrame = rgFrame->GetFirstRow();
     while (rowFrame) {
-      rowFrame->DidResize(aReflowState);
+      rowFrame->DidResize();
       rgFrame->ConsiderChildOverflow(groupDesiredSize.mOverflowArea, rowFrame);
       rowFrame = rowFrame->GetNextRow();
     }
@@ -3137,7 +3136,7 @@ nsTableFrame::DistributeHeightToRows(con
             yEndRG += rowRect.height + cellSpacingY;
             amountUsed += amountForRow;
             amountUsedByRG += amountForRow;
-            //rowFrame->DidResize(aReflowState);        
+            //rowFrame->DidResize();        
             nsTableFrame::RePositionViews(rowFrame);
           }
         }
@@ -3166,7 +3165,7 @@ nsTableFrame::DistributeHeightToRows(con
   }
 
   if (amountUsed >= aAmount) {
-    ResizeCells(*this, aReflowState);
+    ResizeCells(*this);
     return;
   }
 
@@ -3242,7 +3241,7 @@ nsTableFrame::DistributeHeightToRows(con
           amountUsed += amountForRow;
           amountUsedByRG += amountForRow;
           NS_ASSERTION((amountUsed <= aAmount), "invalid row allocation");
-          //rowFrame->DidResize(aReflowState);        
+          //rowFrame->DidResize();        
           nsTableFrame::RePositionViews(rowFrame);
         }
         else {
@@ -3271,7 +3270,7 @@ nsTableFrame::DistributeHeightToRows(con
     yOriginRG = yEndRG;
   }
 
-  ResizeCells(*this, aReflowState);
+  ResizeCells(*this);
 }
 
 PRBool 
@@ -3320,100 +3319,6 @@ void nsTableFrame::SetColumnWidth(PRInt3
   else {
     firstInFlow->SetColumnWidth(aColIndex, aWidth);
   }
-}
-
-
-nscoord 
-CalcPercentPadding(nscoord      aBasis,
-                   nsStyleCoord aStyleCoord)
-{
-  float percent = (NS_UNCONSTRAINEDSIZE == aBasis)
-                  ? 0 : aStyleCoord.GetPercentValue();
-  return NSToCoordRound(((float)aBasis) * percent);
-}
-
-void 
-GetPaddingFor(const nsSize&         aBasis, 
-              const nsStylePadding& aPaddingData, 
-              nsMargin&             aPadding)
-{
-  nsStyleCoord styleCoord;
-  aPaddingData.mPadding.GetTop(styleCoord);
-  if (eStyleUnit_Percent == aPaddingData.mPadding.GetTopUnit()) {
-    aPadding.top = CalcPercentPadding(aBasis.height, styleCoord);
-  }
-  else if (eStyleUnit_Coord == aPaddingData.mPadding.GetTopUnit()) {
-    aPadding.top = styleCoord.GetCoordValue();
-  }
-
-  aPaddingData.mPadding.GetRight(styleCoord);
-  if (eStyleUnit_Percent == aPaddingData.mPadding.GetRightUnit()) {
-    aPadding.right = CalcPercentPadding(aBasis.width, styleCoord);
-  }
-  else if (eStyleUnit_Coord == aPaddingData.mPadding.GetTopUnit()) {
-    aPadding.right = styleCoord.GetCoordValue();
-  }
-
-  aPaddingData.mPadding.GetBottom(styleCoord);
-  if (eStyleUnit_Percent == aPaddingData.mPadding.GetBottomUnit()) {
-    aPadding.bottom = CalcPercentPadding(aBasis.height, styleCoord);
-  }
-  else if (eStyleUnit_Coord == aPaddingData.mPadding.GetTopUnit()) {
-    aPadding.bottom = styleCoord.GetCoordValue();
-  }
-
-  aPaddingData.mPadding.GetLeft(styleCoord);
-  if (eStyleUnit_Percent == aPaddingData.mPadding.GetLeftUnit()) {
-    aPadding.left = CalcPercentPadding(aBasis.width, styleCoord);
-  }
-  else if (eStyleUnit_Coord == aPaddingData.mPadding.GetTopUnit()) {
-    aPadding.left = styleCoord.GetCoordValue();
-  }
-}
-
-nsMargin
-nsTableFrame::GetBorderPadding(const nsHTMLReflowState& aReflowState,
-                               float                    aPixelToTwips,
-                               const nsTableCellFrame*  aCellFrame)
-{
-  // XXX When we have a more sensible border/padding API (bug 332922),
-  // we can get rid of the aReflowState parameters here and on all the
-  // DidResize* functions.
-  const nsStylePadding* paddingData = aCellFrame->GetStylePadding();
-  nsMargin padding(0,0,0,0);
-  if (!paddingData->GetPadding(padding)) {
-    const nsHTMLReflowState* parentRS = aReflowState.parentReflowState;
-    while (parentRS) {
-      if (parentRS->frame) {
-        if (nsGkAtoms::tableFrame == parentRS->frame->GetType()) {
-          nsSize basis(parentRS->ComputedWidth(), parentRS->mComputedHeight);
-          GetPaddingFor(basis, *paddingData, padding);
-          break;
-        }
-      }
-      parentRS = parentRS->parentReflowState;
-    }
-  }
-  nsMargin border;
-  aCellFrame->GetBorderWidth(aPixelToTwips, border);
-  padding += border;
-  return padding;
-}
-
-nsMargin
-nsTableFrame::GetBorderPadding(const nsSize&           aBasis,
-                               float                   aPixelToTwips,
-                               const nsTableCellFrame* aCellFrame)
-{
-  const nsStylePadding* paddingData = aCellFrame->GetStylePadding();
-  nsMargin padding(0,0,0,0);
-  if (!paddingData->GetPadding(padding)) {
-    GetPaddingFor(aBasis, *paddingData, padding);
-  }
-  nsMargin border;
-  aCellFrame->GetBorderWidth(aPixelToTwips, border);
-  padding += border;
-  return padding;
 }
 
 // XXX: could cache this.  But be sure to check style changes if you do!
diff -r bea9043ae065 layout/tables/nsTableFrame.h
--- a/layout/tables/nsTableFrame.h	Sat Jan 27 10:48:46 2007 -0800
+++ b/layout/tables/nsTableFrame.h	Sat Jan 27 10:48:49 2007 -0800
@@ -310,14 +310,6 @@ public:
                        nsIFrame*&               aLastChildReflowed,
                        nsReflowStatus&          aStatus);
 
-  static nsMargin GetBorderPadding(const nsHTMLReflowState& aReflowState,
-                                   float                    aPixelToTwips,
-                                   const nsTableCellFrame*  aCellFrame);
-
-  static nsMargin GetBorderPadding(const nsSize&           aBasis,
-                                   float                   aPixelToTwips,
-                                   const nsTableCellFrame* aCellFrame);
-
   nsFrameList& GetColGroups();
 
   NS_IMETHOD GetParentStyleContextFrame(nsPresContext* aPresContext,
diff -r bea9043ae065 layout/tables/nsTableRowFrame.cpp
--- a/layout/tables/nsTableRowFrame.cpp	Sat Jan 27 10:48:46 2007 -0800
+++ b/layout/tables/nsTableRowFrame.cpp	Sat Jan 27 10:48:49 2007 -0800
@@ -338,7 +338,7 @@ nsTableRowFrame::GetFirstCell()
  * Post-reflow hook. This is where the table row does its post-processing
  */
 void
-nsTableRowFrame::DidResize(const nsHTMLReflowState& aReflowState)
+nsTableRowFrame::DidResize()
 {
   // Resize and re-align the cell frames based on our row height
   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
@@ -364,7 +364,7 @@ nsTableRowFrame::DidResize(const nsHTMLR
       {
         cellFrame->SetSize(nsSize(cellFrame->GetSize().width, cellHeight));
         // realign cell content based on the new height
-        cellFrame->VerticallyAlignChild(aReflowState, mMaxCellAscent);
+        cellFrame->VerticallyAlignChild(mMaxCellAscent);
         ConsiderChildOverflow(desiredSize.mOverflowArea, cellFrame);
         // Note that if the cell's *content* needs to change in response
         // to this height, it will get a special height reflow.
@@ -669,8 +669,6 @@ nsTableRowFrame::CalculateCellActualSize
 // column widths taking into account column spans and column spacing
 static void 
 CalcAvailWidth(nsTableFrame&     aTableFrame,
-               nscoord           aTableComputedWidth,
-               float             aPixelToTwips,
                nsTableCellFrame& aCellFrame,
                nscoord           aCellSpacingX,
                nscoord&          aColAvailWidth,
@@ -698,28 +696,6 @@ CalcAvailWidth(nsTableFrame&     aTableF
     aColAvailWidth += cellSpacing;
   } 
   aCellAvailWidth = aColAvailWidth;
-
-  // for a cell with a colspan > 1, use its fix width (if set) as the avail width 
-  // if this is its initial reflow
-  if ((aCellFrame.GetStateBits() & NS_FRAME_FIRST_REFLOW)
-      && (aTableFrame.GetEffectiveColSpan(aCellFrame) > 1)) {
-    // see if the cell has a style width specified
-    const nsStylePosition* cellPosition = aCellFrame.GetStylePosition();
-    if (eStyleUnit_Coord == cellPosition->mWidth.GetUnit()) {
-      // need to add padding into fixed width
-      nsMargin borderPadding(0,0,0,0);
-      if (NS_UNCONSTRAINEDSIZE != aTableComputedWidth) {
-        borderPadding = nsTableFrame::GetBorderPadding(nsSize(aTableComputedWidth, 0), 
-                                                       aPixelToTwips,  &aCellFrame);
-      }
-      nscoord fixWidth = cellPosition->mWidth.GetCoordValue() + borderPadding.left + borderPadding.right;
-      if (NS_UNCONSTRAINEDSIZE != aColAvailWidth) {
-        aCellAvailWidth = PR_MIN(aColAvailWidth, fixWidth);
-      } else {
-        aCellAvailWidth = fixWidth;
-      }
-    }
-  }
 }
 
 nscoord
@@ -783,22 +759,6 @@ GetSpaceBetween(PRInt32       aPrevColIn
   return space;
 }
 
-static nscoord
-GetComputedWidth(const nsHTMLReflowState& aReflowState,
-                 nsTableFrame&            aTableFrame)
-{
-  const nsHTMLReflowState* parentReflow = aReflowState.parentReflowState;
-  nscoord computedWidth = 0;
-  while (parentReflow) {
-    if (parentReflow->frame == &aTableFrame) {
-      computedWidth = parentReflow->ComputedWidth();
-      break;
-    }
-    parentReflow = parentReflow->parentReflowState;
-  }
-  return computedWidth;
-}
-
 // subtract the heights of aRow's prev in flows from the unpaginated height
 static
 nscoord CalcHeightFromUnpaginatedHeight(nsPresContext*  aPresContext,
@@ -907,8 +867,8 @@ nsTableRowFrame::ReflowChildren(nsPresCo
     if (doReflowChild) {
       // Calculate the available width for the table cell using the known column widths
       nscoord availColWidth, availCellWidth;
-      CalcAvailWidth(aTableFrame, GetComputedWidth(aReflowState, aTableFrame), p2t,
-                     *cellFrame, cellSpacingX, availColWidth, availCellWidth);
+      CalcAvailWidth(aTableFrame, *cellFrame, cellSpacingX,
+                     availColWidth, availCellWidth);
 
       nsHTMLReflowMetrics desiredSize;
 
@@ -1133,7 +1093,7 @@ nsTableRowFrame::ReflowCellFrame(nsPresC
   // XXX What happens if this cell has 'vertical-align: baseline' ?
   // XXX Why is it assumed that the cell's ascent hasn't changed ?
   if (fullyComplete) {
-    aCellFrame->VerticallyAlignChild(aReflowState, mMaxCellAscent);
+    aCellFrame->VerticallyAlignChild(mMaxCellAscent);
   }
   aCellFrame->DidReflow(aPresContext, nsnull, NS_FRAME_REFLOW_FINISHED);
 
diff -r bea9043ae065 layout/tables/nsTableRowFrame.h
--- a/layout/tables/nsTableRowFrame.h	Sat Jan 27 10:48:46 2007 -0800
+++ b/layout/tables/nsTableRowFrame.h	Sat Jan 27 10:48:49 2007 -0800
@@ -111,7 +111,7 @@ public:
                     const nsHTMLReflowState& aReflowState,
                     nsReflowStatus&          aStatus);
 
-  void DidResize(const nsHTMLReflowState& aReflowState);
+  void DidResize();
 
   /**
    * Get the "type" of the frame
diff -r bea9043ae065 layout/tables/nsTableRowGroupFrame.cpp
--- a/layout/tables/nsTableRowGroupFrame.cpp	Sat Jan 27 10:48:46 2007 -0800
+++ b/layout/tables/nsTableRowGroupFrame.cpp	Sat Jan 27 10:48:49 2007 -0800
@@ -427,7 +427,7 @@ nsTableRowGroupFrame::ReflowChildren(nsP
       if (!reflowAllKids) {
         if (IsSimpleRowFrame(aReflowState.tableFrame, kidFrame)) {
           // Inform the row of its new height.
-          ((nsTableRowFrame*)kidFrame)->DidResize(aReflowState.reflowState);
+          ((nsTableRowFrame*)kidFrame)->DidResize();
           // the overflow area may have changed inflate the overflow area
           if (aReflowState.tableFrame->IsAutoHeight()) {
             // Because other cells in the row may need to be aligned
@@ -479,7 +479,7 @@ nsTableRowGroupFrame::ReflowChildren(nsP
   aDesiredSize.height = aReflowState.y;
 
   if (aReflowState.reflowState.mFlags.mSpecialHeightReflow) {
-    DidResizeRows(aReflowState.reflowState, aDesiredSize);
+    DidResizeRows(aDesiredSize);
     if (isPaginated) {
       CacheRowHeightsForPrinting(aPresContext, GetFirstRow());
     }
@@ -535,8 +535,7 @@ UpdateHeights(RowInfo& aRowInfo,
 }
 
 void 
-nsTableRowGroupFrame::DidResizeRows(const nsHTMLReflowState& aReflowState,
-                                    nsHTMLReflowMetrics&     aDesiredSize)
+nsTableRowGroupFrame::DidResizeRows(nsHTMLReflowMetrics& aDesiredSize)
 {
   // update the cells spanning rows with their new heights
   // this is the place where all of the cells in the row get set to the height of the row
@@ -544,7 +543,7 @@ nsTableRowGroupFrame::DidResizeRows(cons
   aDesiredSize.mOverflowArea = nsRect(0, 0, 0, 0);
   for (nsTableRowFrame* rowFrame = GetFirstRow();
        rowFrame; rowFrame = rowFrame->GetNextRow()) {
-    rowFrame->DidResize(aReflowState);
+    rowFrame->DidResize();
     ConsiderChildOverflow(aDesiredSize.mOverflowArea, rowFrame);
   }
 }
@@ -820,7 +819,7 @@ nsTableRowGroupFrame::CalculateRowHeight
     CacheRowHeightsForPrinting(aPresContext, GetFirstRow());
   }
 
-  DidResizeRows(aReflowState, aDesiredSize);
+  DidResizeRows(aDesiredSize);
 
   aDesiredSize.height = rowGroupHeight; // Adjust our desired size
   delete [] rowInfo; // cleanup
@@ -1090,7 +1089,7 @@ nsTableRowGroupFrame::SplitRowGroup(nsPr
         if (NS_FAILED(rv)) return rv;
         rowFrame->SetSize(nsSize(rowMetrics.width, rowMetrics.height));
         rowFrame->DidReflow(aPresContext, nsnull, NS_FRAME_REFLOW_FINISHED);
-        rowFrame->DidResize(aReflowState);
+        rowFrame->DidResize();
 
         if (NS_FRAME_IS_NOT_COMPLETE(aStatus)) {
           // The row frame is incomplete and all of the rowspan 1 cells' block frames split
diff -r bea9043ae065 layout/tables/nsTableRowGroupFrame.h
--- a/layout/tables/nsTableRowGroupFrame.h	Sat Jan 27 10:48:46 2007 -0800
+++ b/layout/tables/nsTableRowGroupFrame.h	Sat Jan 27 10:48:49 2007 -0800
@@ -322,8 +322,7 @@ protected:
                            nsHTMLReflowMetrics&     aDesiredSize,
                            const nsHTMLReflowState& aReflowState);
 
-  void DidResizeRows(const nsHTMLReflowState& aReflowState,
-                     nsHTMLReflowMetrics&     aDesiredSize);
+  void DidResizeRows(nsHTMLReflowMetrics& aDesiredSize);
 
   void SlideChild(nsRowGroupReflowState& aReflowState,
                   nsIFrame*              aKidFrame);
