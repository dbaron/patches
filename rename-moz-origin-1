From: L. David Baron <dbaron@dbaron.org>

Bug 929673 Patch 1:  Rename mozOrigin to transformOrigin to avoid use of deprecated CSS prefixes in variable names.

diff --git a/gfx/layers/composite/AsyncCompositionManager.cpp b/gfx/layers/composite/AsyncCompositionManager.cpp
--- a/gfx/layers/composite/AsyncCompositionManager.cpp
+++ b/gfx/layers/composite/AsyncCompositionManager.cpp
@@ -351,24 +351,24 @@ SampleValue(float aPortion, Animation& a
   nsCSSValueList* interpolatedList = interpolatedValue.GetCSSValueListValue();
 
   TransformData& data = aAnimation.data().get_TransformData();
   nsPoint origin = data.origin();
   // we expect all our transform data to arrive in css pixels, so here we must
   // adjust to dev pixels.
   double cssPerDev = double(nsDeviceContext::AppUnitsPerCSSPixel())
                      / double(data.appUnitsPerDevPixel());
-  gfxPoint3D mozOrigin = data.mozOrigin();
-  mozOrigin.x = mozOrigin.x * cssPerDev;
-  mozOrigin.y = mozOrigin.y * cssPerDev;
+  gfxPoint3D transformOrigin = data.transformOrigin();
+  transformOrigin.x = transformOrigin.x * cssPerDev;
+  transformOrigin.y = transformOrigin.y * cssPerDev;
   gfxPoint3D perspectiveOrigin = data.perspectiveOrigin();
   perspectiveOrigin.x = perspectiveOrigin.x * cssPerDev;
   perspectiveOrigin.y = perspectiveOrigin.y * cssPerDev;
   nsDisplayTransform::FrameTransformProperties props(interpolatedList,
-                                                     mozOrigin,
+                                                     transformOrigin,
                                                      perspectiveOrigin,
                                                      data.perspective());
   gfx3DMatrix transform =
     nsDisplayTransform::GetResultingTransformMatrix(props, origin,
                                                     data.appUnitsPerDevPixel(),
                                                     &data.bounds());
   gfxPoint3D scaledOrigin =
     gfxPoint3D(NS_round(NSAppUnitsToFloatPixels(origin.x, data.appUnitsPerDevPixel())),
diff --git a/gfx/layers/ipc/LayerTransactionParent.cpp b/gfx/layers/ipc/LayerTransactionParent.cpp
--- a/gfx/layers/ipc/LayerTransactionParent.cpp
+++ b/gfx/layers/ipc/LayerTransactionParent.cpp
@@ -484,32 +484,32 @@ LayerTransactionParent::RecvGetTransform
   *aTransform = layer->AsLayerComposite()->GetShadowTransform();
   if (ContainerLayer* c = layer->AsContainerLayer()) {
     aTransform->ScalePost(1.0f/c->GetInheritedXScale(),
                           1.0f/c->GetInheritedYScale(),
                           1.0f);
   }
   float scale = 1;
   gfxPoint3D scaledOrigin;
-  gfxPoint3D mozOrigin;
+  gfxPoint3D transformOrigin;
   for (uint32_t i=0; i < layer->GetAnimations().Length(); i++) {
     if (layer->GetAnimations()[i].data().type() == AnimationData::TTransformData) {
       const TransformData& data = layer->GetAnimations()[i].data().get_TransformData();
       scale = data.appUnitsPerDevPixel();
       scaledOrigin =
         gfxPoint3D(NS_round(NSAppUnitsToFloatPixels(data.origin().x, scale)),
                    NS_round(NSAppUnitsToFloatPixels(data.origin().y, scale)),
                    0.0f);
-      mozOrigin = data.mozOrigin();
+      transformOrigin = data.transformOrigin();
       break;
     }
   }
 
   aTransform->Translate(-scaledOrigin);
-  *aTransform = nsLayoutUtils::ChangeMatrixBasis(-scaledOrigin - mozOrigin, *aTransform);
+  *aTransform = nsLayoutUtils::ChangeMatrixBasis(-scaledOrigin - transformOrigin, *aTransform);
   return true;
 }
 
 void
 LayerTransactionParent::Attach(ShadowLayerParent* aLayerParent,
                                CompositableParent* aCompositable,
                                bool aIsAsyncVideo)
 {
diff --git a/gfx/layers/ipc/LayersMessages.ipdlh b/gfx/layers/ipc/LayersMessages.ipdlh
--- a/gfx/layers/ipc/LayersMessages.ipdlh
+++ b/gfx/layers/ipc/LayersMessages.ipdlh
@@ -143,19 +143,19 @@ struct AnimationSegment {
   TimingFunction sampleFn;
 };
 
 // Transforms need extra information to correctly convert the list of transform
 // functions to a gfx3DMatrix that can be applied directly to the layer.
 struct TransformData {
   // the origin of the frame being transformed in app units
   nsPoint origin;
-  // the -moz-transform-origin property for the transform in css pixels
-  gfxPoint3D mozOrigin;
-  // the -moz-perspective-origin property for the transform in css pixels
+  // the transform-origin property for the transform in css pixels
+  gfxPoint3D transformOrigin;
+  // the perspective-origin property for the transform in css pixels
   gfxPoint3D perspectiveOrigin;
   nsRect bounds;
   nscoord perspective;
   int32_t appUnitsPerDevPixel;
 };
 
 union AnimationData {
   null_t;
