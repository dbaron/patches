From: L. David Baron <dbaron@dbaron.org>

Bug 842476 debugging - Debugging code to isolate correct nsAutoJSValHolder.

diff --git a/js/xpconnect/public/nsAutoJSValHolder.h b/js/xpconnect/public/nsAutoJSValHolder.h
--- a/js/xpconnect/public/nsAutoJSValHolder.h
+++ b/js/xpconnect/public/nsAutoJSValHolder.h
@@ -12,18 +12,18 @@
 /**
  * Simple class that looks and acts like a JS::Value except that it unroots
  * itself automatically if Root() is ever called. Designed to be rooted on the
  * context or runtime (but not both!).
  */
 class nsAutoJSValHolder
 {
 public:
-  nsAutoJSValHolder()
-    : mVal(JSVAL_NULL), mRt(nullptr)
+  nsAutoJSValHolder(const char *aName = nullptr)
+    : mVal(JSVAL_NULL), mRt(nullptr), mName(aName)
   {
     // nothing to do
   }
 
   /**
    * Always release on destruction.
    */
   virtual ~nsAutoJSValHolder() {
@@ -59,17 +59,17 @@ public:
 
   /**
    * Hold by rooting on the runtime.
    * Note that mVal may be JSVAL_NULL, which is not a problem.
    */
   bool Hold(JSRuntime* aRt) {
     MOZ_ASSERT_IF(mRt, mRt == aRt);
 
-    if (!mRt && JS::AddNamedValueRootRT(aRt, &mVal, "nsAutoJSValHolder")) {
+    if (!mRt && JS::AddNamedValueRootRT(aRt, &mVal, mName ? mName : "nsAutoJSValHolder")) {
       mRt = aRt;
     }
 
     return !!mRt;
   }
 
   /**
    * Manually release, nullifying mVal, and mRt, but returning
@@ -122,11 +122,12 @@ public:
 #endif
     mVal = aOther;
     return *this;
   }
 
 private:
   JS::Heap<JS::Value> mVal;
   JSRuntime* mRt;
+  const char* mName;
 };
 
 #endif /* __NSAUTOJSVALHOLDER_H__ */
