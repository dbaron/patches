diff -r db75d698fb32 tools/trace-malloc/lib/nsTraceMalloc.c
--- a/tools/trace-malloc/lib/nsTraceMalloc.c	Wed Jan 10 19:52:59 2007 -0800
+++ b/tools/trace-malloc/lib/nsTraceMalloc.c	Thu Jan 11 13:21:32 2007 -0800
@@ -94,6 +94,8 @@ extern __ptr_t __libc_calloc(size_t, siz
 extern __ptr_t __libc_calloc(size_t, size_t);
 extern __ptr_t __libc_realloc(__ptr_t, size_t);
 extern void    __libc_free(__ptr_t);
+extern __ptr_t __libc_memalign(size_t, size_t);
+extern __ptr_t __libc_valloc(size_t);
 #ifdef WRAP_SYSTEM_INCLUDES
 #pragma GCC visibility pop
 #endif
@@ -301,6 +303,15 @@ static char      *sdlogname = NULL; /* f
  * and it must be tested and manipulated only within tmmon.
  */
 static uint32 suppress_tracing = 0;
+
+/*
+ * This enables/disables trace-malloc logging.
+ *
+ * It is separate from suppress_tracing so that we do not have to pay
+ * the performance cost of repeated PR_EnterMonitor/PR_ExitMonitor and
+ * PR_IntervalNow calls when trace-malloc is disabled.
+ */
+static int tracing_enabled = 1;
 
 #define TM_ENTER_MONITOR()                                                    \
     PR_BEGIN_MACRO                                                            \
@@ -1476,7 +1487,7 @@ malloc(size_t size)
     PLHashEntry *he;
     allocation *alloc;
 
-    if (!PR_Initialized()) {
+    if (!PR_Initialized() || !tracing_enabled) {
         return __libc_malloc(size);
     }
 
@@ -1528,7 +1539,7 @@ calloc(size_t count, size_t size)
      *
      * Delaying NSPR calls until NSPR is initialized helps.
      */
-    if (!PR_Initialized()) {
+    if (!PR_Initialized() || !tracing_enabled) {
         return __libc_calloc(count, size);
     }
 
@@ -1574,7 +1585,7 @@ realloc(__ptr_t ptr, size_t size)
     allocation *alloc;
     FILE *trackfp = NULL;
 
-    if (!PR_Initialized()) {
+    if (!PR_Initialized() || !tracing_enabled) {
         return __libc_realloc(ptr, size);
     }
 
@@ -1659,6 +1670,99 @@ realloc(__ptr_t ptr, size_t size)
     return ptr;
 }
 
+NS_EXTERNAL_VIS_(void*)
+valloc(size_t size)
+{
+    PRUint32 start, end;
+    __ptr_t ptr;
+    callsite *site;
+    PLHashEntry *he;
+    allocation *alloc;
+
+    if (!PR_Initialized() || !tracing_enabled) {
+        return __libc_valloc(size);
+    }
+
+    start = PR_IntervalNow();
+    ptr = __libc_valloc(size);
+    end = PR_IntervalNow();
+    TM_ENTER_MONITOR();
+    tmstats.malloc_calls++; /* XXX valloc_calls ? */
+    if (!ptr) {
+        tmstats.malloc_failures++; /* XXX valloc_failures ? */
+    } else if (suppress_tracing == 0) {
+        site = backtrace(1);
+        if (site)
+            log_event5(logfp, TM_EVENT_MALLOC, /* XXX TM_EVENT_VALLOC? */
+                       site->serial, start, end - start,
+                       (uint32)NS_PTR_TO_INT32(ptr), size);
+        if (get_allocations()) {
+            suppress_tracing++;
+            he = PL_HashTableAdd(allocations, ptr, site);
+            suppress_tracing--;
+            if (he) {
+                alloc = (allocation*) he;
+                alloc->size = size;
+                alloc->trackfp = NULL;
+            }
+        }
+    }
+    TM_EXIT_MONITOR();
+    return ptr;
+}
+
+NS_EXTERNAL_VIS_(void*)
+memalign(size_t boundary, size_t size)
+{
+    PRUint32 start, end;
+    __ptr_t ptr;
+    callsite *site;
+    PLHashEntry *he;
+    allocation *alloc;
+
+    if (!PR_Initialized() || !tracing_enabled) {
+        return __libc_memalign(boundary, size);
+    }
+
+    start = PR_IntervalNow();
+    ptr = __libc_memalign(boundary, size);
+    end = PR_IntervalNow();
+    TM_ENTER_MONITOR();
+    tmstats.malloc_calls++; /* XXX memalign_calls ? */
+    if (!ptr) {
+        tmstats.malloc_failures++; /* XXX memalign_failures ? */
+    } else if (suppress_tracing == 0) {
+        site = backtrace(1);
+        if (site) {
+            log_event5(logfp, TM_EVENT_MALLOC, /* XXX TM_EVENT_MEMALIGN? */
+                       site->serial, start, end - start,
+                       (uint32)NS_PTR_TO_INT32(ptr), size);
+        }
+        if (get_allocations()) {
+            suppress_tracing++;
+            he = PL_HashTableAdd(allocations, ptr, site);
+            suppress_tracing--;
+            if (he) {
+                alloc = (allocation*) he;
+                alloc->size = size;
+                alloc->trackfp = NULL;
+            }
+        }
+    }
+    TM_EXIT_MONITOR();
+    return ptr;
+}
+
+NS_EXTERNAL_VIS_(int)
+posix_memalign(void **memptr, size_t alignment, size_t size)
+{
+    __ptr_t ptr = memalign(alignment, size);
+    if (!ptr)
+        return ENOMEM;
+    *memptr = ptr;
+    return 0;
+}
+
 NS_EXTERNAL_VIS_(void)
 free(__ptr_t ptr)
 {
@@ -1668,7 +1772,7 @@ free(__ptr_t ptr)
     uint32 serial = 0, size = 0;
     PRUint32 start, end;
 
-    if (!PR_Initialized()) {
+    if (!PR_Initialized() || !tracing_enabled) {
         __libc_free(ptr);
         return;
     }
@@ -1712,6 +1816,12 @@ free(__ptr_t ptr)
     }
 }
 
+NS_EXTERNAL_VIS_(void)
+cfree(void *ptr)
+{
+    free(ptr);
+}
+
 #endif /* XP_UNIX */
 
 static const char magic[] = NS_TRACE_MALLOC_MAGIC;
@@ -1728,10 +1838,11 @@ PR_IMPLEMENT(void) NS_TraceMallocStartup
 {
     /* We must be running on the primordial thread. */
     PR_ASSERT(suppress_tracing == 0);
+    PR_ASSERT(tracing_enabled == 1);
     PR_ASSERT(logfp == &default_logfile);
-    suppress_tracing = (logfd < 0);
-
-    if (suppress_tracing == 0) {
+    tracing_enabled = (logfd >= 0);
+
+    if (tracing_enabled) {
         /* Log everything in logfp (aka default_logfile)'s buffer to logfd. */
         logfp->fd = logfd;
         logfile_list = &default_logfile;
@@ -1745,7 +1856,7 @@ PR_IMPLEMENT(void) NS_TraceMallocStartup
 
 #ifdef XP_WIN32
     /* Register listeners for win32. */
-    if (suppress_tracing == 0) {
+    if (tracing_enabled) {
         StartupHooker();
     }
 #endif
@@ -1928,7 +2039,7 @@ PR_IMPLEMENT(void) NS_TraceMallocShutdow
         PR_DestroyMonitor(mon);
     }
 #ifdef XP_WIN32
-    if (suppress_tracing == 0) {
+    if (tracing_enabled) {
         ShutdownHooker();
     }
 #endif
@@ -1941,14 +2052,14 @@ PR_IMPLEMENT(void) NS_TraceMallocDisable
     TM_ENTER_MONITOR();
     for (fp = logfile_list; fp; fp = fp->next)
         flush_logfile(fp);
-    suppress_tracing++;
+    tracing_enabled = 0;
     TM_EXIT_MONITOR();
 }
 
 PR_IMPLEMENT(void) NS_TraceMallocEnable()
 {
     TM_ENTER_MONITOR();
-    suppress_tracing--;
+    tracing_enabled = 1;
     TM_EXIT_MONITOR();
 }
 
@@ -2167,6 +2278,9 @@ MallocCallback(void *ptr, size_t size, P
     callsite *site;
     PLHashEntry *he;
     allocation *alloc;
+
+    if (!tracing_enabled)
+        return;
 
     TM_ENTER_MONITOR();
     tmstats.malloc_calls++;
@@ -2197,6 +2311,9 @@ CallocCallback(void *ptr, size_t count, 
     callsite *site;
     PLHashEntry *he;
     allocation *alloc;
+
+    if (!tracing_enabled)
+        return;
 
     TM_ENTER_MONITOR();
     tmstats.calloc_calls++;
@@ -2231,6 +2348,9 @@ ReallocCallback(void * oldptr, void *ptr
     PLHashEntry **hep, *he;
     allocation *alloc;
 
+    if (!tracing_enabled)
+        return;
+
     TM_ENTER_MONITOR();
     tmstats.realloc_calls++;
     if (suppress_tracing == 0) {
@@ -2300,6 +2420,9 @@ FreeCallback(void * ptr, PRUint32 start,
     PLHashEntry **hep, *he;
     callsite *site;
     allocation *alloc;
+
+    if (!tracing_enabled)
+        return;
 
     TM_ENTER_MONITOR();
     tmstats.free_calls++;
