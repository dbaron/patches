For fixed-layout tables, leave room for the cell spacing for all columns, whether they have cells originating in them or not, since we don't know if cells for those columns will arrive as the table loads incrementally.  (Bug 444928)

diff --git a/layout/reftests/bugs/444928-1-ref.html b/layout/reftests/bugs/444928-1-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/444928-1-ref.html
@@ -0,0 +1,17 @@
+<html>
+<head>
+<style type="text/css">
+table{ width: 500px; }
+
+</style>
+</head>
+<body>
+<table class="grid" cellspacing="50" cellpadding="0" border>
+<col width="10%"/>
+<col width="1" span="2"/>
+<tbody>
+<tr><th class="top" colspan="3"> Some Text</th></tr>
+</tbody>
+</table>
+</body>
+</html>
diff --git a/layout/reftests/bugs/444928-1.html b/layout/reftests/bugs/444928-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/444928-1.html
@@ -0,0 +1,17 @@
+<html>
+<head>
+<style type="text/css">
+table{table-layout: fixed; width: 500px; }
+
+</style>
+</head>
+<body>
+<table class="grid" cellspacing="50" cellpadding="0" border>
+<col width="10%"/>
+<col width="1" span="2"/>
+<tbody>
+<tr><th class="top" colspan="3"> Some Text</th></tr>
+</tbody>
+</table>
+</body>
+</html>
diff --git a/layout/reftests/bugs/444928-2-ref.html b/layout/reftests/bugs/444928-2-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/444928-2-ref.html
@@ -0,0 +1,18 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+<title>Examples for bug 444928</title>
+</head>
+<body>
+
+<table cellspacing="50" cellpadding="0" style="table-layout:fixed" width="652">
+<col width="150">
+<col width="150">
+<col>
+<tr><td colspan="2" style="background:yellow">1-2</td><td style="background:fuchsia">3</td></tr>
+<tr style="color:transparent"><td>1</td><td>2</td><td>3</td></tr>
+</tbody>
+</table>
+
+</body>
+</html>
diff --git a/layout/reftests/bugs/444928-2.html b/layout/reftests/bugs/444928-2.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/444928-2.html
@@ -0,0 +1,17 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+<title>Examples for bug 444928</title>
+</head>
+<body>
+
+<table cellspacing="50" cellpadding="0" style="table-layout:fixed" width="652">
+<col width="150">
+<col width="150">
+<col>
+<tr><td colspan="2" style="background:yellow">1-2</td><td style="background:fuchsia">3</td></tr>
+</tbody>
+</table>
+
+</body>
+</html>
diff --git a/layout/reftests/bugs/444928-3-notref.html b/layout/reftests/bugs/444928-3-notref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/444928-3-notref.html
@@ -0,0 +1,18 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+<title>Examples for bug 444928</title>
+</head>
+<body>
+
+<table cellspacing="50" cellpadding="0" width="652">
+<col width="150">
+<col width="150">
+<col>
+<tr><td colspan="2" style="background:yellow">1-2</td><td style="background:fuchsia">3</td></tr>
+<tr style="color:transparent"><td>1</td><td>2</td><td>3</td></tr>
+</tbody>
+</table>
+
+</body>
+</html>
diff --git a/layout/reftests/bugs/444928-3.html b/layout/reftests/bugs/444928-3.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/444928-3.html
@@ -0,0 +1,17 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+<title>Examples for bug 444928</title>
+</head>
+<body>
+
+<table cellspacing="50" cellpadding="0" width="652">
+<col width="150">
+<col width="150">
+<col>
+<tr><td colspan="2" style="background:yellow">1-2</td><td style="background:fuchsia">3</td></tr>
+</tbody>
+</table>
+
+</body>
+</html>
diff --git a/layout/reftests/bugs/reftest.list b/layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list
+++ b/layout/reftests/bugs/reftest.list
@@ -903,17 +903,19 @@ random == 429849-1.html 429849-1-ref.htm
 == 438987-2b.html 438987-2-ref.html
 == 438987-2c.html 438987-2-ref.html
 != about:blank 438987-2-ref.html # check that backgrounds work at all 
 == 439004-1.html 439004-1-ref.html
 == 439910.html 439910-ref.html
 == 441259-1.html 441259-1-ref.html
 fails == 441259-2.html 441259-2-ref.html # bug 441400
 == 444015-1.html 444015-1-ref.html
+== 444928-1.html 444928-1-ref.html
+== 444928-2.html 444928-2-ref.html
+!= 444928-3.html 444928-3-notref.html
 # == 448987.html 448987-ref.html  # Disabled for now - it needs privileges
 == 449171-1.html 449171-ref.html
 == 449519-1.html 449519-1-ref.html
 # == 449653-1.html 449653-1-ref.html # Disabled for now - it needs privileges
 == 450670-1.html 450670-1-ref.html
 == 451168-1.html 451168-1-ref.html
 == 454361.html about:blank
 == 455280-1.xhtml 455280-1-ref.xhtml
-
diff --git a/layout/tables/BasicTableLayoutStrategy.cpp b/layout/tables/BasicTableLayoutStrategy.cpp
--- a/layout/tables/BasicTableLayoutStrategy.cpp
+++ b/layout/tables/BasicTableLayoutStrategy.cpp
@@ -46,17 +46,18 @@
 #include "nsTableCellFrame.h"
 #include "nsLayoutUtils.h"
 #include "nsGkAtoms.h"
 #include "SpanningCellSorter.h"
 
 #undef  DEBUG_TABLE_STRATEGY 
 
 BasicTableLayoutStrategy::BasicTableLayoutStrategy(nsTableFrame *aTableFrame)
-  : mTableFrame(aTableFrame)
+  : nsITableLayoutStrategy(nsITableLayoutStrategy::Auto)
+  , mTableFrame(aTableFrame)
 {
     MarkIntrinsicWidthsDirty();
 }
 
 /* virtual */
 BasicTableLayoutStrategy::~BasicTableLayoutStrategy()
 {
 }
@@ -413,17 +414,17 @@ BasicTableLayoutStrategy::ComputeIntrins
                            // where a cell originates
 
     for (PRInt32 col = 0; col < colCount; ++col) {
         nsTableColFrame *colFrame = mTableFrame->GetColFrame(col);
         if (!colFrame) {
             NS_ERROR("column frames out of sync with cell map");
             continue;
         }
-        if (mTableFrame->GetNumCellsOriginatingInCol(col)) {
+        if (mTableFrame->ColumnHasCellSpacingBefore(col)) {
             add += spacing;
         }
         min += colFrame->GetMinCoord();
         pref = NSCoordSaturatingAdd(pref, colFrame->GetPrefCoord());
 
         // Percentages are of the table, so we have to reverse them for
         // intrinsic widths.
         float p = colFrame->GetPrefPercent();
@@ -622,17 +623,17 @@ BasicTableLayoutStrategy::DistributeWidt
 
     // border-spacing isn't part of the basis for percentages.
     nscoord spacing = mTableFrame->GetCellSpacingX();
     nscoord subtract = 0;    
     // aWidth initially includes border-spacing for the boundaries in between
     // each of the columns. We start at aFirstCol + 1 because the first
     // in-between boundary would be at the left edge of column aFirstCol + 1
     for (PRInt32 col = aFirstCol + 1; col < aFirstCol + aColCount; ++col) {
-        if (mTableFrame->GetNumCellsOriginatingInCol(col)) {
+        if (mTableFrame->ColumnHasCellSpacingBefore(col)) {
             subtract += spacing;
         }
     }
     if (aWidthType == BTLS_FINAL_WIDTH) {
         // If we're computing final col-width, then aWidth initially includes
         // border spacing on the table's far left + far right edge, too.  Need
         // to subtract those out, too.
         subtract += spacing * 2;
@@ -731,17 +732,17 @@ BasicTableLayoutStrategy::DistributeWidt
                 // loop
                 nscoord delta = NSCoordSaturatingSubtract(pref_width, 
                                                           min_width, 0);
                 guess_min_spec = NSCoordSaturatingAdd(guess_min_spec, delta);
                 total_fixed_pref = NSCoordSaturatingAdd(total_fixed_pref, 
                                                         pref_width);
             } else if (pref_width == 0) {
                 if (aWidthType == BTLS_FINAL_WIDTH &&
-                    mTableFrame->GetNumCellsOriginatingInCol(col)) {
+                    mTableFrame->ColumnHasCellSpacingBefore(col)) {
                     ++numNonSpecZeroWidthCols;
                 }
             } else {
                 total_flex_pref = NSCoordSaturatingAdd(total_flex_pref,
                                                        pref_width);
             }
         }
     }
@@ -929,17 +930,17 @@ BasicTableLayoutStrategy::DistributeWidt
                 }
                 break;
             case FLEX_FLEX_LARGE_ZERO:
                 NS_ASSERTION(aWidthType == BTLS_FINAL_WIDTH,
                              "FLEX_FLEX_LARGE_ZERO only should be hit "
                              "when we're setting final width.");
                 if (pct == 0.0f &&
                     !colFrame->GetHasSpecifiedCoord() &&
-                    mTableFrame->GetNumCellsOriginatingInCol(col)) {
+                    mTableFrame->ColumnHasCellSpacingBefore(col)) {
 
                     NS_ASSERTION(col_width == 0 &&
                                  colFrame->GetPrefCoord() == 0,
                                  "Since we're in FLEX_FLEX_LARGE_ZERO case, "
                                  "all auto-width cols should have zero pref "
                                  "width.");
                     float c = float(space) / float(basis.c);
                     col_width += NSToCoordRound(c);
diff --git a/layout/tables/FixedTableLayoutStrategy.cpp b/layout/tables/FixedTableLayoutStrategy.cpp
--- a/layout/tables/FixedTableLayoutStrategy.cpp
+++ b/layout/tables/FixedTableLayoutStrategy.cpp
@@ -42,17 +42,18 @@
  */
 
 #include "FixedTableLayoutStrategy.h"
 #include "nsTableFrame.h"
 #include "nsTableColFrame.h"
 #include "nsTableCellFrame.h"
 
 FixedTableLayoutStrategy::FixedTableLayoutStrategy(nsTableFrame *aTableFrame)
-  : mTableFrame(aTableFrame)
+  : nsITableLayoutStrategy(nsITableLayoutStrategy::Fixed)
+  , mTableFrame(aTableFrame)
 {
     MarkIntrinsicWidthsDirty();
 }
 
 /* virtual */
 FixedTableLayoutStrategy::~FixedTableLayoutStrategy()
 {
 }
@@ -60,38 +61,37 @@ FixedTableLayoutStrategy::~FixedTableLay
 /* virtual */ nscoord
 FixedTableLayoutStrategy::GetMinWidth(nsIRenderingContext* aRenderingContext)
 {
     DISPLAY_MIN_WIDTH(mTableFrame, mMinWidth);
     if (mMinWidth != NS_INTRINSIC_WIDTH_UNKNOWN)
         return mMinWidth;
 
     // It's theoretically possible to do something much better here that
-    // depends only on the columns and the first row, but it wouldn't be
-    // compatible with other browsers, or with the use of GetMinWidth by
-    // nsHTMLReflowState to determine the width of a fixed-layout table,
-    // since CSS2.1 says:
+    // depends only on the columns and the first row (where we look at
+    // intrinsic widths inside the first row and then reverse the
+    // algorithm to find the narrowest width that would hold all of
+    // those intrinsic widths), but it wouldn't be compatible with other
+    // browsers, or with the use of GetMinWidth by
+    // nsTableFrame::ComputeSize to determine the width of a fixed
+    // layout table, since CSS2.1 says:
     //   The width of the table is then the greater of the value of the
     //   'width' property for the table element and the sum of the
     //   column widths (plus cell spacing or borders).
 
     // XXX Should we really ignore 'min-width' and 'max-width'?
+    // XXX Should we really ignore widths on column groups?
 
     nsTableCellMap *cellMap = mTableFrame->GetCellMap();
     PRInt32 colCount = cellMap->GetColCount();
     nscoord spacing = mTableFrame->GetCellSpacingX();
 
-    // XXX Should this code do any pixel rounding?
-
     nscoord result = 0;
 
-    // XXX Consider widths on columns or column groups?
-
     if (colCount > 0) {
-        // XXX Should only add columns that have cells originating in them!
         result += spacing * (colCount + 1);
     }
 
     for (PRInt32 col = 0; col < colCount; ++col) {
         nsTableColFrame *colFrame = mTableFrame->GetColFrame(col);
         if (!colFrame) {
             NS_ERROR("column frames out of sync with cell map");
             continue;
@@ -149,18 +149,21 @@ FixedTableLayoutStrategy::GetMinWidth(ns
     return (mMinWidth = result);
 }
 
 /* virtual */ nscoord
 FixedTableLayoutStrategy::GetPrefWidth(nsIRenderingContext* aRenderingContext,
                                        PRBool aComputingSize)
 {
     // It's theoretically possible to do something much better here that
-    // depends only on the columns and the first row, but it wouldn't be
-    // compatible with other browsers.
+    // depends only on the columns and the first row (where we look at
+    // intrinsic widths inside the first row and then reverse the
+    // algorithm to find the narrowest width that would hold all of
+    // those intrinsic widths), but it wouldn't be compatible with other
+    // browsers.
     nscoord result = nscoord_MAX;
     DISPLAY_PREF_WIDTH(mTableFrame, result);
     return result;
 }
 
 /* virtual */ void
 FixedTableLayoutStrategy::MarkIntrinsicWidthsDirty()
 {
@@ -176,32 +179,28 @@ FixedTableLayoutStrategy::ComputeColumnW
     if (mLastCalcWidth == tableWidth)
         return;
     mLastCalcWidth = tableWidth;
 
     nsTableCellMap *cellMap = mTableFrame->GetCellMap();
     PRInt32 colCount = cellMap->GetColCount();
     nscoord spacing = mTableFrame->GetCellSpacingX();
 
-    // XXX Should this code do any pixel rounding?
-
-    // border-spacing isn't part of the basis for percentages.
-    if (colCount > 0) {
-        // XXX Should only add columns that have cells originating in them!
-        nscoord subtract = spacing * (colCount + 1);
-        tableWidth -= subtract;
-    } else {
+    if (colCount == 0) {
         // No Columns - nothing to compute
         return;
     }
 
+    // border-spacing isn't part of the basis for percentages.
+    tableWidth -= spacing * (colCount + 1);
+
     // XXX This ignores the 'min-width' and 'max-width' properties
     // throughout.  Then again, that's what the CSS spec says to do.
 
-    // XXX Consider widths on columns or column groups?
+    // XXX Should we really ignore widths on column groups?
 
     PRUint32 unassignedCount = 0;
     nscoord unassignedSpace = tableWidth;
     const nscoord unassignedMarker = nscoord_MIN;
 
     // We use the PrefPercent on the columns to store the percentages
     // used to compute column widths in case we need to reduce their
     // basis.
diff --git a/layout/tables/nsITableLayoutStrategy.h b/layout/tables/nsITableLayoutStrategy.h
--- a/layout/tables/nsITableLayoutStrategy.h
+++ b/layout/tables/nsITableLayoutStrategy.h
@@ -65,11 +65,23 @@ public:
     /** Implement nsIFrame::MarkIntrinsicWidthsDirty for the table */
     virtual void MarkIntrinsicWidthsDirty() = 0;
 
     /**
      * Compute final column widths based on the intrinsic width data and
      * the available width.
      */
     virtual void ComputeColumnWidths(const nsHTMLReflowState& aReflowState) = 0;
+
+    /**
+     * Return the type of table layout strategy, without the cost of
+     * a virtual function call
+     */
+    enum Type { Auto, Fixed };
+    Type GetType() const { return mType; }
+
+protected:
+    nsITableLayoutStrategy(Type aType) : mType(aType) {}
+private:
+    Type mType;
 };
 
 #endif /* !defined(nsITableLayoutStrategy_h_) */
diff --git a/layout/tables/nsTableFrame.cpp b/layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp
+++ b/layout/tables/nsTableFrame.cpp
@@ -426,22 +426,28 @@ void nsTableFrame::AttributeChangedFor(n
 
 
 /* ****** CellMap methods ******* */
 
 /* return the effective col count */
 PRInt32 nsTableFrame::GetEffectiveColCount() const
 {
   PRInt32 colCount = GetColCount();
-  // don't count cols at the end that don't have originating cells
-  for (PRInt32 colX = colCount - 1; colX >= 0; colX--) {
-    if (GetNumCellsOriginatingInCol(colX) <= 0) { 
+  if (LayoutStrategy()->GetType() == nsITableLayoutStrategy::Auto) {
+    nsTableCellMap* cellMap = GetCellMap();
+    if (!cellMap) {
+      return 0;
+    }
+    // don't count cols at the end that don't have originating cells
+    for (PRInt32 colX = colCount - 1; colX >= 0; colX--) {
+      if (cellMap->GetNumCellsOriginatingInCol(colX) > 0) { 
+        break;
+      }
       colCount--;
     }
-    else break;
   }
   return colCount;
 }
 
 PRInt32 nsTableFrame::GetIndexOfLastRealCol()
 {
   PRInt32 numCols = mColFrames.Count();
   if (numCols > 0) {
@@ -1609,18 +1615,17 @@ nsTableFrame::ProcessRowInserted(nscoord
       childFrame = childFrame->GetNextSibling();
     }
   }
 }
 
 /* virtual */ void
 nsTableFrame::MarkIntrinsicWidthsDirty()
 {
-  static_cast<nsTableFrame*>(GetFirstInFlow())->
-    mTableLayoutStrategy->MarkIntrinsicWidthsDirty();
+  LayoutStrategy()->MarkIntrinsicWidthsDirty();
 
   // XXXldb Call SetBCDamageArea?
 
   nsHTMLContainerFrame::MarkIntrinsicWidthsDirty();
 }
 
 /* virtual */ nscoord
 nsTableFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
@@ -2208,17 +2213,17 @@ nsTableFrame::GetCollapsedWidth(nsMargin
       const nsStyleDisplay* colDisplay = colFrame->GetStyleDisplay();
       PRInt32 colX = colFrame->GetColIndex();
       if (NS_STYLE_DISPLAY_TABLE_COLUMN == colDisplay->mDisplay) {
         const nsStyleVisibility* colVis = colFrame->GetStyleVisibility();
         PRBool collapseCol = (NS_STYLE_VISIBILITY_COLLAPSE == colVis->mVisible);
         PRInt32 colWidth = GetColumnWidth(colX);
         if (!collapseGroup && !collapseCol) {
           width += colWidth;
-          if (GetNumCellsOriginatingInCol(colX) > 0)
+          if (ColumnHasCellSpacingBefore(colX))
             width += cellSpacingX;
         }
       }
     }
   }
   return width;
 }
 
@@ -4013,32 +4018,27 @@ nsTableFrame::GetRowAndColumnByIndex(PRI
     return NS_ERROR_NOT_INITIALIZED;
 
   cellMap->GetRowAndColumnByIndex(aIndex, aRow, aColumn);
   return NS_OK;
 }
 
 /*---------------- end of nsITableLayout implementation ------------------*/
 
-PRInt32 nsTableFrame::GetNumCellsOriginatingInCol(PRInt32 aColIndex) const
-{
-  nsTableCellMap* cellMap = GetCellMap();
-  if (cellMap) 
-    return cellMap->GetNumCellsOriginatingInCol(aColIndex);
-  else
-    return 0;
-}
-
-PRInt32 nsTableFrame::GetNumCellsOriginatingInRow(PRInt32 aRowIndex) const
-{
-  nsTableCellMap* cellMap = GetCellMap();
-  if (cellMap) 
-    return cellMap->GetNumCellsOriginatingInRow(aRowIndex);
-  else
-    return 0;
+PRBool
+nsTableFrame::ColumnHasCellSpacingBefore(PRInt32 aColIndex) const
+{
+  // Since fixed-layout tables should not have their column sizes change
+  // as they load, we assume that all columns are significant.
+  if (mTableLayoutStrategy->GetType() == nsITableLayoutStrategy::Fixed)
+    return PR_TRUE;
+  nsTableCellMap* cellMap = GetCellMap();
+  if (!cellMap) 
+    return PR_FALSE;
+  return cellMap->GetNumCellsOriginatingInCol(aColIndex) > 0;
 }
 
 static void
 CheckFixDamageArea(PRInt32 aNumRows,
                    PRInt32 aNumCols,
                    nsRect& aDamageArea)
 {
   if (((aDamageArea.XMost() > aNumCols) && (aDamageArea.width  != 1) && (aNumCols != 0)) || 
diff --git a/layout/tables/nsTableFrame.h b/layout/tables/nsTableFrame.h
--- a/layout/tables/nsTableFrame.h
+++ b/layout/tables/nsTableFrame.h
@@ -525,18 +525,18 @@ public:
 
   virtual void RemoveCol(nsTableColGroupFrame* aColGroupFrame,
                          PRInt32               aColIndex,
                          PRBool                aRemoveFromCache,
                          PRBool                aRemoveFromCellMap);
 
   NS_IMETHOD GetIndexByRowAndColumn(PRInt32 aRow, PRInt32 aColumn, PRInt32 *aIndex);
   NS_IMETHOD GetRowAndColumnByIndex(PRInt32 aIndex, PRInt32 *aRow, PRInt32 *aColumn);
-  PRInt32 GetNumCellsOriginatingInCol(PRInt32 aColIndex) const;
-  PRInt32 GetNumCellsOriginatingInRow(PRInt32 aRowIndex) const;
+
+  PRBool ColumnHasCellSpacingBefore(PRInt32 aColIndex) const;
 
   PRBool HasPctCol() const;
   void SetHasPctCol(PRBool aValue);
 
   PRBool HasCellSpanningPctCol() const;
   void SetHasCellSpanningPctCol(PRBool aValue);
 
   /**
@@ -606,17 +606,17 @@ protected:
   /** Adjust the table for visibilty.collapse set on rowgroups, rows, colgroups
     * and cols
     * @param aDesiredSize    the metrics of the table
     * @param aBorderPadding  the border and padding of the table
     */
   void AdjustForCollapsingRowsCols(nsHTMLReflowMetrics& aDesiredSize,
                                    nsMargin             aBorderPadding);
 
-  nsITableLayoutStrategy* LayoutStrategy() {
+  nsITableLayoutStrategy* LayoutStrategy() const {
     return static_cast<nsTableFrame*>(GetFirstInFlow())->
       mTableLayoutStrategy;
   }
 
 private:
   /* Handle a row that got inserted during reflow.  aNewHeight is the
      new height of the table after reflow. */
   void ProcessRowInserted(nscoord aNewHeight);
diff --git a/layout/tables/nsTableRowFrame.cpp b/layout/tables/nsTableRowFrame.cpp
--- a/layout/tables/nsTableRowFrame.cpp
+++ b/layout/tables/nsTableRowFrame.cpp
@@ -683,17 +683,17 @@ CalcAvailWidth(nsTableFrame&     aTableF
   for (PRInt32 spanX = 0; spanX < colspan; spanX++) {
     nscoord colWidth = aTableFrame.GetColumnWidth(colIndex + spanX);
     if (NS_UNCONSTRAINEDSIZE == aColAvailWidth) {
       aColAvailWidth = colWidth; 
     }
     else {
       aColAvailWidth += colWidth;
     }
-    if ((spanX > 0) && (aTableFrame.GetNumCellsOriginatingInCol(colIndex + spanX) > 0)) {
+    if ((spanX > 0) && aTableFrame.ColumnHasCellSpacingBefore(colIndex + spanX)) {
       cellSpacing += aCellSpacingX;
     }
   }
   if (NS_UNCONSTRAINEDSIZE != aColAvailWidth) {
     aColAvailWidth += cellSpacing;
   } 
   aCellAvailWidth = aColAvailWidth;
 }
@@ -722,17 +722,17 @@ GetSpaceBetween(PRInt32       aPrevColIn
         nsIFrame* cgFrame = colFrame->GetParent();
         const nsStyleVisibility* groupVis = cgFrame->GetStyleVisibility();
         PRBool collapseGroup = (NS_STYLE_VISIBILITY_COLLAPSE ==
                                 groupVis->mVisible);
         isCollapsed = collapseCol || collapseGroup;
         if (!isCollapsed)
           space += aTableFrame.GetColumnWidth(colX);
       }
-      if (!isCollapsed && (aTableFrame.GetNumCellsOriginatingInCol(colX) > 0)) {
+      if (!isCollapsed && aTableFrame.ColumnHasCellSpacingBefore(colX)) {
         space += aCellSpacingX;
       }
     }
   } 
   else {
     PRInt32 lastCol = aColIndex + aColSpan - 1;
     for (colX = aPrevColIndex - 1; colX > lastCol; colX--) {
       PRBool isCollapsed = PR_FALSE;
@@ -746,17 +746,17 @@ GetSpaceBetween(PRInt32       aPrevColIn
         nsIFrame* cgFrame = colFrame->GetParent();
         const nsStyleVisibility* groupVis = cgFrame->GetStyleVisibility();
         PRBool collapseGroup = (NS_STYLE_VISIBILITY_COLLAPSE ==
                                 groupVis->mVisible);
         isCollapsed = collapseCol || collapseGroup;
         if (!isCollapsed)
           space += aTableFrame.GetColumnWidth(colX);
       }
-      if (!isCollapsed && (aTableFrame.GetNumCellsOriginatingInCol(colX) > 0)) {
+      if (!isCollapsed && aTableFrame.ColumnHasCellSpacingBefore(colX)) {
         space += aCellSpacingX;
       }
     }
   }
   return space;
 }
 
 // subtract the heights of aRow's prev in flows from the unpaginated height
@@ -1241,17 +1241,17 @@ nsTableRowFrame::CollapseRowIfNecessary(
             isVisible = PR_TRUE;
           }
           if (!isCollapsed &&  (actualColSpan > 1)) {
             nsTableColFrame* nextColFrame =
               tableFrame->GetColFrame(colX + colIncrement);
             const nsStyleVisibility* nextColVis =
               nextColFrame->GetStyleVisibility();
             if ( (NS_STYLE_VISIBILITY_COLLAPSE != nextColVis->mVisible) &&
-                (tableFrame->GetNumCellsOriginatingInCol(colX + colIncrement) > 0)) {
+                tableFrame->ColumnHasCellSpacingBefore(colX + colIncrement)) {
               cRect.width += cellSpacingX;
             }
           }
         }
         x += cRect.width;
         if (isVisible)
           x += cellSpacingX;
         PRInt32 actualRowSpan = tableFrame->GetEffectiveRowSpan(*cellFrame);
