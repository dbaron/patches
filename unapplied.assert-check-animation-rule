From: L. David Baron <dbaron@dbaron.org>

Assert that we only call CheckAnimationRule in allowed cases.  (Bug 686656).

diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -434,25 +434,39 @@ nsAnimationManager::RulesMatching(XULTre
 {
 }
 #endif
 
 nsIStyleRule*
 nsAnimationManager::CheckAnimationRule(nsStyleContext* aStyleContext,
                                        mozilla::dom::Element* aElement)
 {
+  NS_ABORT_IF_FALSE(mPresContext->IsProcessingRestyles() ||
+                    !mPresContext->IsProcessingAnimationStyleChange(),
+                    "The abort below should be checked for all cases "
+                    "when IsProcessingRestyles() is false.  If this "
+                    "abort fails, then it won't be.");
   if (!mPresContext->IsProcessingAnimationStyleChange()) {
     // Everything that causes our animation data to change triggers a
     // style change, which in turn triggers a non-animation restyle.
     // Likewise, when we initially construct frames, we're not in a
     // style change, but also not in an animation restyle.
 
     const nsStyleDisplay *disp = aStyleContext->GetStyleDisplay();
     ElementAnimations *ea =
       GetElementAnimations(aElement, aStyleContext->GetPseudoType(), false);
+    NS_ABORT_IF_FALSE(mPresContext->IsProcessingRestyles() || !ea,
+                      "The only case where it's ok to hit this code "
+                      "outside of restyle processing is *initial* "
+                      "frame construction, when we can't already have "
+                      "an animation rule (or transition rules).  If "
+                      "we hit it any other time, we might *already* have "
+                      "an animation rule, which means CheckAnimationRule "
+                      "will produce incorrect results because it builds "
+                      "on incorrect base values (see bug 686656).");
     if (!ea &&
         disp->mAnimations.Length() == 1 &&
         disp->mAnimations[0].GetName().IsEmpty()) {
       return nsnull;
     }
 
     // build the animations list
     InfallibleTArray<ElementAnimation> newAnimations;
