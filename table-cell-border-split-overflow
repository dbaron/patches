From: L. David Baron <dbaron@dbaron.org>

Fix the way table cells consider overflowing collapsed borders for split overflow areas.  (Bug 542595, patch 16)

diff --git a/layout/tables/nsTableCellFrame.cpp b/layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp
+++ b/layout/tables/nsTableCellFrame.cpp
@@ -534,20 +534,20 @@ nsTableCellFrame::GetSkipSides() const
     skip |= 1 << NS_SIDE_TOP;
   }
   if (nsnull != GetNextInFlow()) {
     skip |= 1 << NS_SIDE_BOTTOM;
   }
   return skip;
 }
 
-/* virtual */ void
-nsTableCellFrame::GetSelfOverflow(nsRect& aOverflowArea)
+/* virtual */ nsMargin
+nsTableCellFrame::GetBorderOverflow()
 {
-  aOverflowArea = nsRect(nsPoint(0,0), GetSize());
+  return nsMargin(0, 0, 0, 0);
 }
 
 // Align the cell's child frame within the cell
 
 void nsTableCellFrame::VerticallyAlignChild(nscoord aMaxAscent)
 {
   const nsStyleTextReset* textStyle = GetStyleTextReset();
   /* It's the 'border-collapse' on the table that matters */
@@ -596,18 +596,21 @@ void nsTableCellFrame::VerticallyAlignCh
     // Invalidate at the old position first
     firstKid->InvalidateFrameSubtree();
   }
 
   firstKid->SetPosition(nsPoint(kidRect.x, kidYTop));
   nsHTMLReflowMetrics desiredSize;
   desiredSize.width = mRect.width;
   desiredSize.height = mRect.height;
-  GetSelfOverflow(desiredSize.mOverflowArea);
-  ConsiderChildOverflow(desiredSize.mOverflowArea, firstKid);
+
+  nsRect overflow(nsPoint(0,0), GetSize());
+  overflow.Inflate(GetBorderOverflow());
+  desiredSize.mOverflowAreas.SetAllTo(overflow);
+  ConsiderChildOverflow(desiredSize.mOverflowAreas, firstKid);
   FinishAndStoreOverflow(&desiredSize);
   if (kidYTop != kidRect.y) {
     // Make sure any child views are correctly positioned. We know the inner table
     // cell won't have a view
     nsContainerFrame::PositionChildViews(firstKid);
 
     // Invalidate new overflow rect
     firstKid->InvalidateFrameSubtree();
@@ -1138,29 +1141,26 @@ nsBCTableCellFrame::SetBorderWidth(mozil
   case NS_SIDE_BOTTOM:
     mBottomBorder = aValue;
     break;
   default:
     mLeftBorder = aValue;
   }
 }
 
-/* virtual */ void
-nsBCTableCellFrame::GetSelfOverflow(nsRect& aOverflowArea)
+/* virtual */ nsMargin
+nsBCTableCellFrame::GetBorderOverflow()
 {
   nsMargin halfBorder;
   PRInt32 p2t = nsPresContext::AppUnitsPerCSSPixel();
   halfBorder.top = BC_BORDER_TOP_HALF_COORD(p2t, mTopBorder);
   halfBorder.right = BC_BORDER_RIGHT_HALF_COORD(p2t, mRightBorder);
   halfBorder.bottom = BC_BORDER_BOTTOM_HALF_COORD(p2t, mBottomBorder);
   halfBorder.left = BC_BORDER_LEFT_HALF_COORD(p2t, mLeftBorder);
-
-  nsRect overflow(nsPoint(0,0), GetSize());
-  overflow.Inflate(halfBorder);
-  aOverflowArea = overflow;
+  return halfBorder;
 }
 
 
 void
 nsBCTableCellFrame::PaintBackground(nsIRenderingContext& aRenderingContext,
                                     const nsRect&        aDirtyRect,
                                     nsPoint              aPt,
                                     PRUint32             aFlags)
diff --git a/layout/tables/nsTableCellFrame.h b/layout/tables/nsTableCellFrame.h
--- a/layout/tables/nsTableCellFrame.h
+++ b/layout/tables/nsTableCellFrame.h
@@ -242,24 +242,23 @@ public:
   void DecorateForSelection(nsIRenderingContext& aRenderingContext,
                             nsPoint              aPt);
 
 protected:
   /** implement abstract method on nsHTMLContainerFrame */
   virtual PRIntn GetSkipSides() const;
 
   /**
-   * GetSelfOverflow says what effect the cell should have on its own
-   * overflow area.  In the separated borders model this should just be
-   * the frame's size (as it is for most frames), but in the collapsed
+   * GetBorderOverflow says how far the cell's own borders extend
+   * outside its own bounds.  In the separated borders model this should
+   * just be zero (as it is for most frames), but in the collapsed
    * borders model (for which nsBCTableCellFrame overrides this virtual
-   * method), it considers the extents of the collapsed border so we
-   * handle invalidation correctly for dynamic border changes.
+   * method), it considers the extents of the collapsed border.
    */
-  virtual void GetSelfOverflow(nsRect& aOverflowArea);
+  virtual nsMargin GetBorderOverflow();
 
   friend class nsTableRowFrame;
 
   PRUint32     mColIndex;             // the starting column for this cell
 
   nscoord      mPriorAvailWidth;      // the avail width during the last reflow
   nsSize       mDesiredSize;          // the last desired width & height
 };
@@ -328,17 +327,17 @@ public:
   virtual nsMargin* GetBorderWidth(nsMargin& aBorder) const;
 
   // Get the *inner half of the border only*, in pixels.
   BCPixelSize GetBorderWidth(mozilla::css::Side aSide) const;
 
   // Set the full (both halves) width of the border
   void SetBorderWidth(mozilla::css::Side aSide, BCPixelSize aPixelValue);
 
-  virtual void GetSelfOverflow(nsRect& aOverflowArea);
+  virtual nsMargin GetBorderOverflow();
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const;
 #endif
 
   virtual void PaintBackground(nsIRenderingContext& aRenderingContext,
                                const nsRect&        aDirtyRect,
                                nsPoint              aPt,
