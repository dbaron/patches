From: L. David Baron <dbaron@dbaron.org>

Bug 842476:  XPCWrappedJS calls should only store exception when there's a JS caller.

This fixes the leak reported in bug 842476.

This approach seems to make sense to me, based on my understanding of
the purpose of storing the exception on the XPCJSRuntime, as explained
in the comment.  But I'm far from an expert on this code, so please
review carefully.

(Is it guaranteed that the JS caller is in fact an XPConnect caller that
will do something with this exception?  If not, is there a better test?)

diff --git a/js/xpconnect/src/XPCWrappedJSClass.cpp b/js/xpconnect/src/XPCWrappedJSClass.cpp
--- a/js/xpconnect/src/XPCWrappedJSClass.cpp
+++ b/js/xpconnect/src/XPCWrappedJSClass.cpp
@@ -832,16 +832,21 @@ nsXPCWrappedJSClass::CheckForException(X
         }
     }
 
     AutoClearPendingException acpe(cx);
 
     if (xpc_exception) {
         nsresult e_result;
         if (NS_SUCCEEDED(xpc_exception->GetResult(&e_result))) {
+            bool haveJSCaller;
+            {
+              RootedScript ignored(cx);
+              haveJSCaller = !!JS_DescribeScriptedCaller(cx, &ignored, nullptr);
+            }
             // Figure out whether or not we should report this exception.
             bool reportable = xpc_IsReportableErrorCode(e_result);
             if (reportable) {
                 // Always want to report forced exceptions and XPConnect's own
                 // errors.
                 reportable = aForceReport ||
                     NS_ERROR_GET_MODULE(e_result) == NS_ERROR_MODULE_XPCONNECT;
 
@@ -849,18 +854,17 @@ nsXPCWrappedJSClass::CheckForException(X
                 // that a user pref was set indicating that we should report all
                 // exceptions.
                 if (!reportable)
                     reportable = nsXPConnect::ReportAllJSExceptions();
 
                 // Finally, check to see if this is the last JS frame on the
                 // stack. If so then we always want to report it.
                 if (!reportable) {
-                    RootedScript ignored(cx);
-                    reportable = !JS_DescribeScriptedCaller(cx, &ignored, nullptr);
+                    reportable = !haveJSCaller;
                 }
 
                 // Ugly special case for GetInterface. It's "special" in the
                 // same way as QueryInterface in that a failure is not
                 // exceptional and shouldn't be reported. We have to do this
                 // check here instead of in xpcwrappedjs (like we do for QI) to
                 // avoid adding extra code to all xpcwrappedjs objects.
                 if (reportable && e_result == NS_ERROR_NO_INTERFACE &&
@@ -959,20 +963,29 @@ nsXPCWrappedJSClass::CheckForException(X
                                     scriptError = nullptr;
                             }
                         }
                     }
                     if (nullptr != scriptError)
                         consoleService->LogMessage(scriptError);
                 }
             }
-            // Whether or not it passes the 'reportable' test, it might
-            // still be an error and we have to do the right thing here...
             if (NS_FAILED(e_result)) {
-                XPCJSRuntime::Get()->SetPendingException(xpc_exception);
+                // If we have a JS caller, this error code might (or might
+                // not) get propagated through the C++ between us and that JS
+                // caller back to that JS caller.  So if we have one, we
+                // should store the exception on the runtime so that the
+                // caller can get the actual JS exception back if it finds the
+                // error code matches.
+                // On the other hand, if we don't have a JS caller, we don't
+                // want to leave this exception (and everything it entrains)
+                // hanging around forever.
+                if (haveJSCaller) {
+                    XPCJSRuntime::Get()->SetPendingException(xpc_exception);
+                }
                 return e_result;
             }
         }
     } else {
         // see if JS code signaled failure result without throwing exception
         if (NS_FAILED(pending_result)) {
             return pending_result;
         }
