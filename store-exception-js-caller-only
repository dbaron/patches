From: L. David Baron <dbaron@dbaron.org>

Bug 842476:  XPCWrappedJS calls should only store exception when there's a JS caller.

diff --git a/js/xpconnect/src/XPCWrappedJSClass.cpp b/js/xpconnect/src/XPCWrappedJSClass.cpp
--- a/js/xpconnect/src/XPCWrappedJSClass.cpp
+++ b/js/xpconnect/src/XPCWrappedJSClass.cpp
@@ -975,35 +975,31 @@ nsXPCWrappedJSClass::CheckForException(X
         }
     }
 
     AutoClearPendingException acpe(cx);
 
     if (xpc_exception) {
         nsresult e_result;
         if (NS_SUCCEEDED(xpc_exception->GetResult(&e_result))) {
+            bool haveJSCaller = !!JS_DescribeScriptedCaller(cx, nullptr, nullptr);
             // Figure out whether or not we should report this exception.
             bool reportable = xpc_IsReportableErrorCode(e_result);
             if (reportable) {
                 // Always want to report forced exceptions and XPConnect's own
                 // errors.
                 reportable = aForceReport ||
-                    NS_ERROR_GET_MODULE(e_result) == NS_ERROR_MODULE_XPCONNECT;
-
-                // See if an environment variable was set or someone has told us
-                // that a user pref was set indicating that we should report all
-                // exceptions.
-                if (!reportable)
-                    reportable = nsXPConnect::ReportAllJSExceptions();
-
-                // Finally, check to see if this is the last JS frame on the
-                // stack. If so then we always want to report it.
-                if (!reportable) {
-                    reportable = !JS_DescribeScriptedCaller(cx, nullptr, nullptr);
-                }
+                    NS_ERROR_GET_MODULE(e_result) == NS_ERROR_MODULE_XPCONNECT ||
+                    // See if an environment variable was set or someone has
+                    // told us that a user pref was set indicating that we
+                    // should report all exceptions.
+                    nsXPConnect::ReportAllJSExceptions() ||
+                    // Finally, check to see if this is the last JS frame on
+                    // the stack. If so then we always want to report it.
+                    !haveJSCaller;
 
                 // Ugly special case for GetInterface. It's "special" in the
                 // same way as QueryInterface in that a failure is not
                 // exceptional and shouldn't be reported. We have to do this
                 // check here instead of in xpcwrappedjs (like we do for QI) to
                 // avoid adding extra code to all xpcwrappedjs objects.
                 if (reportable && e_result == NS_ERROR_NO_INTERFACE &&
                     !strcmp(anInterfaceName, "nsIInterfaceRequestor") &&
@@ -1090,19 +1086,26 @@ nsXPCWrappedJSClass::CheckForException(X
                                     scriptError = nullptr;
                             }
                         }
                     }
                     if (nullptr != scriptError)
                         consoleService->LogMessage(scriptError);
                 }
             }
-            // Whether or not it passes the 'reportable' test, it might
-            // still be an error and we have to do the right thing here...
-            if (NS_FAILED(e_result)) {
+            // If we have a JS caller, this error code might (or might
+            // not) get propagated through the C++ between us and that
+            // JS caller back to that JS caller.  So if we have one, we
+            // should store the exception on the runtime so that the
+            // caller can get the actual JS exception back if it finds
+            // the error code matches.
+            // On the other hand, if we don't have a JS caller, we don't
+            // want to leave this exception (and everything it entrains)
+            // hanging around forever.
+            if (NS_FAILED(e_result) && haveJSCaller) {
                 XPCJSRuntime::Get()->SetPendingException(xpc_exception);
                 return e_result;
             }
         }
     } else {
         // see if JS code signaled failure result without throwing exception
         if (NS_FAILED(pending_result)) {
             return pending_result;
