From: L. David Baron <dbaron@dbaron.org>

Bug 842476:  XPCWrappedJS calls should only store exception when there's a JS caller.

diff --git a/js/xpconnect/src/XPCWrappedJSClass.cpp b/js/xpconnect/src/XPCWrappedJSClass.cpp
--- a/js/xpconnect/src/XPCWrappedJSClass.cpp
+++ b/js/xpconnect/src/XPCWrappedJSClass.cpp
@@ -975,16 +975,17 @@ nsXPCWrappedJSClass::CheckForException(X
         }
     }
 
     AutoClearPendingException acpe(cx);
 
     if (xpc_exception) {
         nsresult e_result;
         if (NS_SUCCEEDED(xpc_exception->GetResult(&e_result))) {
+            bool haveJSCaller = !!JS_DescribeScriptedCaller(cx, nullptr, nullptr);
             // Figure out whether or not we should report this exception.
             bool reportable = xpc_IsReportableErrorCode(e_result);
             if (reportable) {
                 // Always want to report forced exceptions and XPConnect's own
                 // errors.
                 reportable = aForceReport ||
                     NS_ERROR_GET_MODULE(e_result) == NS_ERROR_MODULE_XPCONNECT;
 
@@ -1090,19 +1091,26 @@ nsXPCWrappedJSClass::CheckForException(X
                                     scriptError = nullptr;
                             }
                         }
                     }
                     if (nullptr != scriptError)
                         consoleService->LogMessage(scriptError);
                 }
             }
-            // Whether or not it passes the 'reportable' test, it might
-            // still be an error and we have to do the right thing here...
-            if (NS_FAILED(e_result)) {
+            // If we have a JS caller, this error code might (or might
+            // not) get propagated through the C++ between us and that
+            // JS caller back to that JS caller.  So if we have one, we
+            // should store the exception on the runtime so that the
+            // caller can get the actual JS exception back if it finds
+            // the error code matches.
+            // On the other hand, if we don't have a JS caller, we don't
+            // want to leave this exception (and everything it entrains)
+            // hanging around forever.
+            if (NS_FAILED(e_result) && haveJSCaller) {
                 XPCJSRuntime::Get()->SetPendingException(xpc_exception);
                 return e_result;
             }
         }
     } else {
         // see if JS code signaled failure result without throwing exception
         if (NS_FAILED(pending_result)) {
             return pending_result;
