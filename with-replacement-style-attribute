From: L. David Baron <dbaron@dbaron.org>

Bug 977991 patch 3 - Add ability for RuleNodeWithReplacement to replace the style attribute rule and its important rule.

diff --git a/layout/base/nsChangeHint.h b/layout/base/nsChangeHint.h
--- a/layout/base/nsChangeHint.h
+++ b/layout/base/nsChangeHint.h
@@ -292,12 +292,21 @@ enum nsRestyleHint {
   eRestyle_CSSAnimations = (1<<4),
 
   // Replace the style data coming from SVG animations (SMIL Animations)
   // without updating any other style data.  If a new style context
   // results, update style contexts on the descendants.  (Irrelevant if
   // eRestyle_Self or eRestyle_Subtree is also set, since those imply a
   // superset of the work.)
   eRestyle_SVGAnimations = (1<<5),
+
+  // Replace the style data coming from inline style without updating
+  // any other style data.  If a new style context results, update style
+  // contexts on the descendants.  (Irrelevant if eRestyle_Self or
+  // eRestyle_Subtree is also set, since those imply a superset of the
+  // work.)  Supported only for element style contexts and not for
+  // pseudo-elements or anonymous boxes, on which it converts to
+  // eRestyle_Self.
+  eRestyle_StyleAttribute = (1<<6),
 };
 
 
 #endif /* nsChangeHint_h___ */
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1326,37 +1326,38 @@ struct CascadeLevel {
 
 static const CascadeLevel gCascadeLevels[] = {
   { nsStyleSet::eAgentSheet,        false, false, nsRestyleHint(0) },
   { nsStyleSet::eUserSheet,         false, false, nsRestyleHint(0) },
   { nsStyleSet::ePresHintSheet,     false, false, nsRestyleHint(0) },
   { nsStyleSet::eSVGAnimationSheet, false, false, eRestyle_SVGAnimations },
   { nsStyleSet::eDocSheet,          false, false, nsRestyleHint(0) },
   { nsStyleSet::eScopedDocSheet,    false, false, nsRestyleHint(0) },
-  { nsStyleSet::eStyleAttrSheet,    false, false, nsRestyleHint(0) },
+  { nsStyleSet::eStyleAttrSheet,    false, true,  eRestyle_StyleAttribute },
   { nsStyleSet::eOverrideSheet,     false, false, nsRestyleHint(0) },
   { nsStyleSet::eAnimationSheet,    false, false, eRestyle_CSSAnimations },
   { nsStyleSet::eScopedDocSheet,    true,  false, nsRestyleHint(0) },
   { nsStyleSet::eDocSheet,          true,  false, nsRestyleHint(0) },
-  { nsStyleSet::eStyleAttrSheet,    true,  false, nsRestyleHint(0) },
+  { nsStyleSet::eStyleAttrSheet,    true,  false, eRestyle_StyleAttribute },
   { nsStyleSet::eOverrideSheet,     true,  false, nsRestyleHint(0) },
   { nsStyleSet::eUserSheet,         true,  false, nsRestyleHint(0) },
   { nsStyleSet::eAgentSheet,        true,  false, nsRestyleHint(0) },
   { nsStyleSet::eTransitionSheet,   false, false, eRestyle_CSSTransitions },
 };
 
 nsRuleNode*
 nsStyleSet::RuleNodeWithReplacement(Element* aElement,
                                     nsRuleNode* aOldRuleNode,
                                     nsCSSPseudoElements::Type aPseudoType,
                                     nsRestyleHint aReplacements)
 {
   NS_ABORT_IF_FALSE(!(aReplacements & ~(eRestyle_CSSTransitions |
                                         eRestyle_CSSAnimations |
-                                        eRestyle_SVGAnimations)),
+                                        eRestyle_SVGAnimations |
+                                        eRestyle_StyleAttribute)),
                     // FIXME: Once bug 931668 lands we'll have a better
                     // way to print these.
                     nsPrintfCString("unexpected replacement bits 0x%lX",
                                     uint32_t(aReplacements)).get());
 
   // FIXME (perf): This should probably not rebuild the whole path, but
   // only the path from the last change in the rule tree, like
   // ReplaceAnimationRule in nsStyleSet.cpp does.  (That could then
@@ -1372,16 +1373,22 @@ nsStyleSet::RuleNodeWithReplacement(Elem
     curRule->mRule = ruleNode->GetRule();
     curRule->mLevel = ruleNode->GetLevel();
     curRule->mIsImportant = ruleNode->IsImportantRule();
   }
 
   nsRuleWalker ruleWalker(mRuleTree, mAuthorStyleDisabled);
   auto rulesIndex = rules.Length();
 
+  // We need to transfer this information between the non-!important and
+  // !important phases for the style attribute level.
+  nsRuleNode* lastScopedRN = nullptr;
+  nsRuleNode* lastStyleAttrRN = nullptr;
+  bool haveImportantStyleAttrRules = false;
+
   for (const CascadeLevel *level = gCascadeLevels,
                        *levelEnd = ArrayEnd(gCascadeLevels);
        level != levelEnd; ++level) {
 
     bool doReplace = level->mLevelReplacementHint & aReplacements;
 
     ruleWalker.SetLevel(level->mLevel, level->mIsImportant,
                         level->mCheckForImportantRules && doReplace);
@@ -1431,17 +1438,46 @@ nsStyleSet::RuleNodeWithReplacement(Elem
             static_cast<SVGAnimationRuleProcessor*>(
               mRuleProcessors[eSVGAnimationSheet].get());
           if (ruleProcessor &&
               aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
             ruleProcessor->ElementRulesMatching(aElement, &ruleWalker);
           }
           break;
         }
+        case eRestyle_StyleAttribute: {
+          if (!level->mIsImportant) {
+            // First time through, we handle the non-!important rule.
+            NS_ASSERTION(aPseudoType ==
+                           nsCSSPseudoElements::ePseudo_NotPseudoElement,
+                         "this code doesn't know how to replace "
+                         "pseudo-element rules");
+            nsHTMLCSSStyleSheet* ruleProcessor =
+              static_cast<nsHTMLCSSStyleSheet*>(
+                mRuleProcessors[eStyleAttrSheet].get());
+            if (ruleProcessor &&
+                aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
+              lastScopedRN = ruleWalker.CurrentNode();
+              ruleProcessor->ElementRulesMatching(PresContext(),
+                                                  aElement,
+                                                  &ruleWalker);
+              lastStyleAttrRN = ruleWalker.CurrentNode();
+              haveImportantStyleAttrRules =
+                !ruleWalker.GetCheckForImportantRules();
+            }
+          } else {
+            // Second time through, we handle the !important rule(s).
+            if (haveImportantStyleAttrRules) {
+              AddImportantRules(lastStyleAttrRN, lastScopedRN, &ruleWalker);
+            }
+          }
+          break;
+        }
         default:
+          MOZ_ASSERT(false, "should not be reached");
           break;
       }
     }
 
     while (rulesIndex != 0) {
       --rulesIndex;
       const RuleNodeInfo& ruleInfo = rules[rulesIndex];
 
