From: L. David Baron <dbaron@dbaron.org>

Make nsBlockReflowState::FlowAndPlaceFloat reflow the float after computing its vertical position, so we know how much height is actually available.  (Bug 563584)  (FIXME: actually write the patch)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -5574,17 +5574,17 @@ nsBlockFrame::DeleteNextInFlowChild(nsPr
     DoRemoveFrame(aNextInFlow,
         aDeletingEmptyFrames ? FRAMES_ARE_EMPTY : 0);
   }
 }
 
 ////////////////////////////////////////////////////////////////////////
 // Float support
 
-nsRect
+/* static */ nsRect
 nsBlockFrame::AdjustFloatAvailableSpace(nsBlockReflowState& aState,
                                         const nsRect& aFloatAvailableSpace,
                                         nsIFrame* aFloatFrame)
 {
   // Compute the available width. By default, assume the width of the
   // containing block.
   nscoord availWidth;
   const nsStyleDisplay* floatDisplay = aFloatFrame->GetStyleDisplay();
@@ -5643,17 +5643,17 @@ nsBlockFrame::ComputeFloatWidth(nsBlockR
   nsHTMLReflowState floatRS(aState.mPresContext, aState.mReflowState, aFloat, 
                             nsSize(availSpace.width, availSpace.height));
   return floatRS.ComputedWidth() + floatRS.mComputedBorderPadding.LeftRight() +
     floatRS.mComputedMargin.LeftRight();
 }
 
 nsresult
 nsBlockFrame::ReflowFloat(nsBlockReflowState& aState,
-                          const nsRect&       aFloatAvailableSpace,
+                          const nsRect&       aAdjustedAvailableSpace,
                           nsIFrame*           aFloat,
                           nsMargin&           aFloatMargin,
                           nsReflowStatus&     aReflowStatus)
 {
   NS_PRECONDITION(aFloat->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
                   "aFloat must be an out-of-flow frame");
   // Reflow the float.
   aReflowStatus = NS_FRAME_COMPLETE;
@@ -5661,21 +5661,19 @@ nsBlockFrame::ReflowFloat(nsBlockReflowS
 #ifdef NOISY_FLOAT
   printf("Reflow Float %p in parent %p, availSpace(%d,%d,%d,%d)\n",
           aFloat, this, 
           aFloatAvailableSpace.x, aFloatAvailableSpace.y, 
           aFloatAvailableSpace.width, aFloatAvailableSpace.height
   );
 #endif
 
-  nsRect availSpace = AdjustFloatAvailableSpace(aState, aFloatAvailableSpace,
-                                                aFloat);
-
   nsHTMLReflowState floatRS(aState.mPresContext, aState.mReflowState, aFloat,
-                            nsSize(availSpace.width, availSpace.height));
+                            nsSize(aAdjustedAvailableSpace.width,
+                                   aAdjustedAvailableSpace.height));
 
   // Setup a block reflow state to reflow the float.
   nsBlockReflowContext brc(aState.mPresContext, aState.mReflowState);
 
   // Reflow the float
   PRBool isAdjacentWithTop = aState.IsAdjacentWithTop();
 
   nsIFrame* clearanceFrame = nsnull;
@@ -5691,26 +5689,26 @@ nsBlockFrame::ReflowFloat(nsBlockReflowS
 
       if (mayNeedRetry && !clearanceFrame) {
         floatRS.mDiscoveredClearance = &clearanceFrame;
         // We don't need to push the float manager state because the the block has its own
         // float manager that will be destroyed and recreated
       }
     }
 
-    rv = brc.ReflowBlock(availSpace, PR_TRUE, margin,
+    rv = brc.ReflowBlock(aAdjustedAvailableSpace, PR_TRUE, margin,
                          0, isAdjacentWithTop,
                          nsnull, floatRS,
                          aReflowStatus, aState);
   } while (NS_SUCCEEDED(rv) && clearanceFrame);
 
   // An incomplete reflow status means we should split the float 
   // if the height is constrained (bug 145305). 
   if (NS_FRAME_IS_NOT_COMPLETE(aReflowStatus) &&
-      (NS_UNCONSTRAINEDSIZE == availSpace.height))
+      (NS_UNCONSTRAINEDSIZE == aAdjustedAvailableSpace.height))
     aReflowStatus = NS_FRAME_COMPLETE;
 
   if (aReflowStatus & NS_FRAME_REFLOW_NEXTINFLOW) {
     aState.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
   }
 
   if (aFloat->GetType() == nsGkAtoms::letterFrame) {
     // We never split floating first letters; an incomplete state for
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -568,27 +568,29 @@ protected:
 
   nsresult ReflowInlineFrame(nsBlockReflowState& aState,
                              nsLineLayout& aLineLayout,
                              line_iterator aLine,
                              nsIFrame* aFrame,
                              LineReflowStatus* aLineReflowStatus);
 
   // Compute the available width for a float. 
-  nsRect AdjustFloatAvailableSpace(nsBlockReflowState& aState,
-                                   const nsRect&       aFloatAvailableSpace,
-                                   nsIFrame*           aFloatFrame);
+  static nsRect AdjustFloatAvailableSpace(nsBlockReflowState& aState,
+                                          const nsRect& aFloatAvailableSpace,
+                                          nsIFrame* aFloatFrame);
   // Computes the border-box width of the float
   nscoord ComputeFloatWidth(nsBlockReflowState& aState,
                             const nsRect&       aFloatAvailableSpace,
                             nsIFrame*           aFloat);
   // An incomplete aReflowStatus indicates the float should be split
   // but only if the available height is constrained.
+  // aAdjustedAvailableSpace is the result of calling
+  // nsBlockFrame::AdjustAvailableSpace.
   nsresult ReflowFloat(nsBlockReflowState& aState,
-                       const nsRect&       aFloatAvailableSpace,
+                       const nsRect&       aAdjustedAvailableSpace,
                        nsIFrame*           aFloat,
                        nsMargin&           aFloatMargin,
                        nsReflowStatus&     aReflowStatus);
 
   //----------------------------------------
   // Methods for pushing/pulling lines/frames
 
   /**
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -619,16 +619,32 @@ nsBlockReflowState::AddFloat(nsLineLayou
 PRBool
 nsBlockReflowState::CanPlaceFloat(nscoord aFloatWidth,
                                   const nsFlowAreaRect& aFloatAvailableSpace)
 {
   return !aFloatAvailableSpace.mHasFloats ||
          aFloatAvailableSpace.mRect.Width >= aFloatWidth;
 }
 
+static nscoord
+FloatMarginWidth(const nsHTMLReflowState& aCBReflowState,
+                 nscoord aFloatAvailableWidth,
+                 const nsCSSOffsetState& aFloatOffsetState)
+{
+  return aFloat->ComputeSize(aCBReflowState.rendContext,
+                             nsSize(aCBReflowState.mContainingBlockWidth,
+                                    aCBReflowState.mContainingBlockHeight),
+                             aFloatAvailableWidth,
+                             aFloatOffsetState.mComputedMargin,
+                             aFloatOffsetState.mComputedBorder,
+                             aFloatOffsetState.mComputedPadding, PR_TRUE) +
+         aFloatOffsetState.mComputedMargin.LeftRight() +
+         aFloatOffsetState.mComputedBorderPadding.LeftRight();
+}
+
 PRBool
 nsBlockReflowState::FlowAndPlaceFloat(nsIFrame*       aFloat,
                                       nsReflowStatus& aReflowStatus)
 {
   aReflowStatus = NS_FRAME_COMPLETE;
   // Save away the Y coordinate before placing the float. We will
   // restore mY at the end after placing the float. This is
   // necessary because any adjustments to mY during the float
@@ -650,68 +666,53 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
   // XXX We need to mark this float somehow so that it gets reflowed
   // when floats are inserted before it.
   if (NS_STYLE_CLEAR_NONE != floatDisplay->mBreakType) {
     // XXXldb Does this handle vertical margins correctly?
     mY = ClearFloats(mY, floatDisplay->mBreakType);
   }
     // Get the band of available space
   nsFlowAreaRect floatAvailableSpace = GetFloatAvailableSpace(mY);
+  nsRect adjustedAvailableSpace = nsBlockFrame::AdjustFloatAvailableSpace(
+    mReflowState, floatAvailableSpace.mRect.width, aFloat);
 
   NS_ASSERTION(aFloat->GetParent() == mBlock,
                "Float frame has wrong parent");
 
-  // Reflow the float
-  nsMargin floatMargin; // computed margin
-  mBlock->ReflowFloat(*this, floatAvailableSpace.mRect, aFloat,
-                      floatMargin, aReflowStatus);
-  if (aFloat->GetPrevInFlow())
-    floatMargin.top = 0;
-  if (NS_FRAME_IS_NOT_COMPLETE(aReflowStatus))
-    floatMargin.bottom = 0;
+  nsCSSOffsetState offsets(aFloat, mReflowState.rendContext,
+                           mReflowState.mComputedWidth);
 
-#ifdef DEBUG
-  if (nsBlockFrame::gNoisyReflow) {
-    nsRect region = aFloat->GetRect();
-    nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
-    printf("flowed float: ");
-    nsFrame::ListTag(stdout, aFloat);
-    printf(" (%d,%d,%d,%d)\n",
-	   region.x, region.y, region.width, region.height);
-  }
-#endif
-
-  nsSize floatSize = aFloat->GetSize() +
-                     nsSize(floatMargin.LeftRight(), floatMargin.TopBottom());
+  nscoord floatMarginWidth =
+    FloatMarginWidth(mReflowState, adjustedAvailableSpace.width, offsets);
 
   // Find a place to place the float. The CSS2 spec doesn't want
   // floats overlapping each other or sticking out of the containing
   // block if possible (CSS2 spec section 9.5.1, see the rule list).
   NS_ASSERTION((NS_STYLE_FLOAT_LEFT == floatDisplay->mFloats) ||
 	       (NS_STYLE_FLOAT_RIGHT == floatDisplay->mFloats),
 	       "invalid float type");
 
   // Can the float fit here?
   PRBool keepFloatOnSameLine = PR_FALSE;
 
-  while (!CanPlaceFloat(floatSize.width, floatAvailableSpace)) {
+  while (!CanPlaceFloat(floatMarginWidth, floatAvailableSpace)) {
     if (floatAvailableSpace.mRect.height <= 0) {
       // No space, nowhere to put anything.
       mY = saveY;
       return PR_FALSE;
     }
 
     // Nope. try to advance to the next band.
     if (NS_STYLE_DISPLAY_TABLE != floatDisplay->mDisplay ||
           eCompatibility_NavQuirks != mPresContext->CompatibilityMode() ) {
 
       mY += floatAvailableSpace.mRect.height;
       floatAvailableSpace = GetFloatAvailableSpace(mY);
     } else {
-      // This quirk matches the one in nsBlockFrame::ReflowFloat
+      // This quirk matches the one in nsBlockFrame::AdjustFloatAvailableSpace
       // IE handles float tables in a very special way
 
       // see if the previous float is also a table and has "align"
       nsFloatCache* fc = mCurrentLineFloats.Head();
       nsIFrame* prevFrame = nsnull;
       while (fc) {
         if (fc->mFloat == aFloat) {
           break;
@@ -738,28 +739,26 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
               break;
             }
           }
         }
       }
 
       // the table does not fit anymore in this line so advance to next band 
       mY += floatAvailableSpace.mRect.height;
+      // To match nsBlockFrame::AdjustFloatAvailableSpace, we have to
+      // get a new width for the new band.
       floatAvailableSpace = GetFloatAvailableSpace(mY);
-      // reflow the float again now since we have more space
-      // XXXldb We really don't need to Reflow in a loop, we just need
-      // to ComputeSize in a loop (once ComputeSize depends on
-      // availableWidth, which should make this work again).
-      mBlock->ReflowFloat(*this, floatAvailableSpace.mRect, aFloat,
-                          floatMargin, aReflowStatus);
-      // Get the floats bounding box and margin information
-      floatSize = aFloat->GetSize() +
-                     nsSize(floatMargin.LeftRight(), floatMargin.TopBottom());
+      adjustedAvailableSpace = nsBlockFrame::AdjustFloatAvailableSpace(
+        mReflowState, floatAvailableSpace.mRect.width, aFloat);
+      floatMarginWidth =
+        FloatMarginWidth(mReflowState, adjustedAvailableSpace.width, offsets);
     }
   }
+
   // If the float is continued, it will get the same absolute x value as its prev-in-flow
 
   // We don't worry about the geometry of the prev in flow, let the continuation
   // place and size itself as required.
 
   // Assign an x and y coordinate to the float. Note that the x,y
   // coordinates are computed <b>relative to the translation in the
   // spacemanager</b> which means that the impacted region will be
@@ -785,16 +784,26 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
     // CSS2 spec, 9.5.1 rule [4]: "A floating box's outer top may not
     // be higher than the top of its containing block."  (Since the
     // containing block is the content edge of the block box, this
     // means the margin edge of the float can't be higher than the
     // content edge of the block that contains it.)
     floatY = 0;
   }
 
+  // Reflow the float after computing its vertical position so it knows
+  // where to break.
+  nsMargin floatMargin; // computed margin
+  mBlock->ReflowFloat(*this, adjustedAvailableSpace, aFloat,
+                      floatMargin, aReflowStatus);
+  if (aFloat->GetPrevInFlow())
+    floatMargin.top = 0;
+  if (NS_FRAME_IS_NOT_COMPLETE(aReflowStatus))
+    floatMargin.bottom = 0;
+
   // Calculate the actual origin of the float frame's border rect
   // relative to the parent block; floatX/Y must be converted from space-manager
   // coordinates to parent coordinates, and the margin must be added in
   // to get the border rect
   nsPoint origin(borderPadding.left + floatMargin.left + floatX,
                  borderPadding.top + floatMargin.top + floatY);
 
   // If float is relatively positioned, factor that in as well
