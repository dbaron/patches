From: L. David Baron <dbaron@dbaron.org>

Make ReResolveStyleContext no longer rerun selector matching on next-continuations by making both ReResolveStyleContext and ReParentStyleContext enforce the invariant that all continuations have the same style context.  (Bug 522563)

diff --git a/layout/base/nsFrameManager.cpp b/layout/base/nsFrameManager.cpp
--- a/layout/base/nsFrameManager.cpp
+++ b/layout/base/nsFrameManager.cpp
@@ -990,18 +990,40 @@ nsFrameManager::ReParentStyleContext(nsI
                     "Shouldn't happen!");
     }
     // XXX need to do something here to produce the correct style context
     // for an IB split whose first inline part is inside a first-line frame.
     // Currently the IB anonymous block's style context takes the first part's
     // style context as parent, which is wrong since first-line style should
     // not apply to the anonymous block.
 
-    newContext = mStyleSet->ReParentStyleContext(presContext, oldContext,
-                                                 newParentContext);
+#ifdef DEBUG
+    {
+      // Check that our assumption that continuations have the same
+      // style context is valid before the reresolution.  (Note that in
+      // the future, if we make :first-letter or :first-line use
+      // continuations, we may have to condition this assumption on the
+      // parent style contexts being the same.)
+      nsIFrame *nextContinuation = aFrame->GetNextContinuation();
+      NS_ASSERTION(!nextContinuation ||
+                   oldContext == nextContinuation->GetStyleContext(),
+                   "continuations should always have same style context");
+    }
+#endif
+
+    nsIFrame *prevContinuation;
+    if ((prevContinuation = aFrame->GetPrevContinuation())) {
+      newContext = prevContinuation->GetStyleContext();
+      NS_ASSERTION(newContext->GetParent() == newParentContext,
+                   "wrong parent");
+    } else {
+      newContext = mStyleSet->ReParentStyleContext(presContext, oldContext,
+                                                   newParentContext);
+    }
+
     if (newContext) {
       if (newContext != oldContext) {
         // We probably don't want to initiate transitions from
         // ReParentStyleContext, since we call it during frame
         // construction rather than in response to dynamic changes.
         // Also see the comment at the start of
         // nsTransitionManager::ConsiderStartingTransition.
 #if 0
@@ -1231,20 +1253,44 @@ nsFrameManager::ReResolveStyleContext(ns
 
       // The provider's new context becomes the parent context of
       // aFrame's context.
       parentContext = providerFrame->GetStyleContext();
       // Set |resolvedChild| so we don't bother resolving the
       // provider again.
       resolvedChild = providerFrame;
     }
+
+#ifdef DEBUG
+    {
+      // Check that our assumption that continuations have the same
+      // style context is valid before the reresolution.  (Note that in
+      // the future, if we make :first-letter or :first-line use
+      // continuations, we may have to condition this assumption on the
+      // parent style contexts being the same.)
+      nsIFrame *nextContinuation = aFrame->GetNextContinuation();
+      NS_ASSERTION(!nextContinuation ||
+                   oldContext == nextContinuation->GetStyleContext(),
+                   "continuations should always have same style context");
+    }
+#endif
     
     // do primary context
     nsRefPtr<nsStyleContext> newContext;
-    if (pseudoTag == nsCSSAnonBoxes::mozNonElement) {
+    nsIFrame *prevContinuation;
+    if ((prevContinuation = aFrame->GetPrevContinuation())) {
+      // Just use the style context from the frame's previous
+      // continuation (see assertion about aFrame->GetNextContinuation()
+      // above, which we would have previously hit for aFrame's previous
+      // continuation).
+      newContext = prevContinuation->GetStyleContext();
+      NS_ASSERTION(newContext->GetParent() == parentContext,
+                   "wrong parent");
+    }
+    else if (pseudoTag == nsCSSAnonBoxes::mozNonElement) {
       NS_ASSERTION(localContent,
                    "non pseudo-element frame without content node");
       newContext = styleSet->ResolveStyleForNonElement(parentContext);
     }
     else if (pseudoTag) {
       // XXXldb This choice of pseudoContent seems incorrect for anon
       // boxes and perhaps other cases.
       // See also the comment above the assertion at the start of this
