From: L. David Baron <dbaron@dbaron.org>

Bug 1075137 patch 4 - Convert callers from IsProcessingRestyles/IsProcessingAnimationStyleChange to SkipAnimationRules/PostAnimationRestyles.  r=birtles

diff --git a/content/svg/content/src/moz.build b/content/svg/content/src/moz.build
--- a/content/svg/content/src/moz.build
+++ b/content/svg/content/src/moz.build
@@ -254,14 +254,15 @@ include('/ipc/chromium/chromium-config.m
 FINAL_LIBRARY = 'xul'
 LOCAL_INCLUDES += [
     '/content/base/src',
     '/content/html/content/src',
     '/dom',
     '/dom/smil',
     '/dom/xbl',
     '/dom/xml',
+    '/layout/base',
     '/layout/generic',
     '/layout/style',
     '/layout/svg',
     '/layout/xul',
 ]
 
diff --git a/content/svg/content/src/nsSVGElement.cpp b/content/svg/content/src/nsSVGElement.cpp
--- a/content/svg/content/src/nsSVGElement.cpp
+++ b/content/svg/content/src/nsSVGElement.cpp
@@ -46,16 +46,17 @@
 #include "nsIFrame.h"
 #include <stdarg.h>
 #include "nsSMILMappedAttribute.h"
 #include "SVGMotionSMILAttr.h"
 #include "nsAttrValueOrString.h"
 #include "nsSMILAnimationController.h"
 #include "mozilla/dom/SVGElementBinding.h"
 #include "mozilla/unused.h"
+#include "RestyleManager.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 // This is needed to ensure correct handling of calls to the
 // vararg-list methods in this file:
 //   nsSVGElement::GetAnimated{Length,Number,Integer}Values
 // See bug 547964 for details:
@@ -911,27 +912,28 @@ nsSVGElement::WalkContentStyleRules(nsRu
 void
 nsSVGElement::WalkAnimatedContentStyleRules(nsRuleWalker* aRuleWalker)
 {
   // Update & walk the animated content style rule, to include style from
   // animated mapped attributes.  But first, get nsPresContext to check
   // whether this is a "no-animation restyle". (This should match the check
   // in nsHTMLCSSStyleSheet::RulesMatching(), where we determine whether to
   // apply the SMILOverrideStyle.)
-  nsIDocument* doc = OwnerDoc();
-  nsIPresShell* shell = doc->GetShell();
-  nsPresContext* context = shell ? shell->GetPresContext() : nullptr;
-  if (context && context->IsProcessingRestyles() &&
-      !context->IsProcessingAnimationStyleChange()) {
-    // Any style changes right now could trigger CSS Transitions. We don't
-    // want that to happen from SMIL-animated value of mapped attrs, so
-    // ignore animated value for now, and request an animation restyle to
-    // get our animated value noticed.
-    shell->RestyleForAnimation(this,
-      eRestyle_SVGAttrAnimations | eRestyle_ChangeAnimationPhase);
+  nsPresContext* context = aRuleWalker->PresContext();
+  nsIPresShell* shell = context->PresShell();
+  RestyleManager* restyleManager = context->RestyleManager();
+  if (restyleManager->SkipAnimationRules()) {
+    if (restyleManager->PostAnimationRestyles()) {
+      // Any style changes right now could trigger CSS Transitions. We don't
+      // want that to happen from SMIL-animated value of mapped attrs, so
+      // ignore animated value for now, and request an animation restyle to
+      // get our animated value noticed.
+      shell->RestyleForAnimation(this,
+        eRestyle_SVGAttrAnimations | eRestyle_ChangeAnimationPhase);
+    }
   } else {
     // Ok, this is an animation restyle -- go ahead and update/walk the
     // animated content style rule.
     css::StyleRule* animContentStyleRule = GetAnimatedContentStyleRule();
     if (!animContentStyleRule) {
       UpdateAnimatedContentStyleRule();
       animContentStyleRule = GetAnimatedContentStyleRule();
     }
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -660,22 +660,22 @@ nsAnimationManager::GetAnimationRule(moz
   }
 
   AnimationPlayerCollection* collection =
     GetAnimationPlayers(aElement, aPseudoType, false);
   if (!collection) {
     return nullptr;
   }
 
-  if (mPresContext->IsProcessingRestyles() &&
-      !mPresContext->IsProcessingAnimationStyleChange()) {
+  RestyleManager* restyleManager = mPresContext->RestyleManager();
+  if (restyleManager->SkipAnimationRules()) {
     // During the non-animation part of processing restyles, we don't
     // add the animation rule.
 
-    if (collection->mStyleRule) {
+    if (collection->mStyleRule && restyleManager->PostAnimationRestyles()) {
       collection->PostRestyleForAnimation(mPresContext);
     }
 
     return nullptr;
   }
 
   NS_WARN_IF_FALSE(!collection->mNeedsRefreshes ||
                    collection->mStyleRuleRefreshTime ==
diff --git a/layout/style/nsHTMLCSSStyleSheet.cpp b/layout/style/nsHTMLCSSStyleSheet.cpp
--- a/layout/style/nsHTMLCSSStyleSheet.cpp
+++ b/layout/style/nsHTMLCSSStyleSheet.cpp
@@ -12,16 +12,17 @@
 #include "mozilla/css/StyleRule.h"
 #include "nsIStyleRuleProcessor.h"
 #include "nsPresContext.h"
 #include "nsRuleWalker.h"
 #include "nsRuleProcessorData.h"
 #include "mozilla/dom/Element.h"
 #include "nsAttrValue.h"
 #include "nsAttrValueInlines.h"
+#include "RestyleManager.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 namespace {
 
 PLDHashOperator
 ClearAttrCache(const nsAString& aKey, MiscContainer*& aValue, void*)
@@ -67,23 +68,25 @@ nsHTMLCSSStyleSheet::ElementRulesMatchin
   css::StyleRule* rule = aElement->GetInlineStyleRule();
   if (rule) {
     rule->RuleMatched();
     aRuleWalker->Forward(rule);
   }
 
   rule = aElement->GetSMILOverrideStyleRule();
   if (rule) {
-    if (aPresContext->IsProcessingRestyles() &&
-        !aPresContext->IsProcessingAnimationStyleChange()) {
+    RestyleManager* restyleManager = aPresContext->RestyleManager();
+    if (restyleManager->SkipAnimationRules()) {
       // Non-animation restyle -- don't process SMIL override style, because we
       // don't want SMIL animation to trigger new CSS transitions. Instead,
       // request an Animation restyle, so we still get noticed.
-      aPresContext->PresShell()->RestyleForAnimation(aElement,
-        eRestyle_StyleAttribute | eRestyle_ChangeAnimationPhase);
+      if (restyleManager->PostAnimationRestyles()) {
+        aPresContext->PresShell()->RestyleForAnimation(aElement,
+          eRestyle_StyleAttribute | eRestyle_ChangeAnimationPhase);
+      }
     } else {
       // Animation restyle (or non-restyle traversal of rules)
       // Now we can walk SMIL overrride style, without triggering transitions.
       rule->RuleMatched();
       aRuleWalker->Forward(rule);
     }
   }
 }
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -32,16 +32,17 @@
 #include "mozilla/dom/Element.h"
 #include "GeckoProfiler.h"
 #include "nsHTMLCSSStyleSheet.h"
 #include "nsHTMLStyleSheet.h"
 #include "SVGAttrAnimationRuleProcessor.h"
 #include "nsCSSRules.h"
 #include "nsPrintfCString.h"
 #include "nsIFrame.h"
+#include "RestyleManager.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 NS_IMPL_ISUPPORTS(nsEmptyStyleRule, nsIStyleRule)
 
 /* virtual */ void
 nsEmptyStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
@@ -1362,28 +1363,29 @@ nsStyleSet::RuleNodeWithReplacement(Elem
                                         eRestyle_Force |
                                         eRestyle_ForceDescendants)),
                     // FIXME: Once bug 979133 lands we'll have a better
                     // way to print these.
                     nsPrintfCString("unexpected replacement bits 0x%lX",
                                     uint32_t(aReplacements)).get());
 
   bool skipAnimationRules = false;
+  bool postAnimationRestyles = false;
 
   // If we're changing animation phase, we have to reconsider what rules
   // are in these four levels.
   if (aReplacements & eRestyle_ChangeAnimationPhase) {
     aReplacements |= eRestyle_CSSTransitions |
                      eRestyle_CSSAnimations |
                      eRestyle_SVGAttrAnimations |
                      eRestyle_StyleAttribute;
 
-    nsPresContext* presContext = PresContext();
-    skipAnimationRules = presContext->IsProcessingRestyles() &&
-                         !presContext->IsProcessingAnimationStyleChange();
+    RestyleManager* restyleManager = PresContext()->RestyleManager();
+    skipAnimationRules = restyleManager->SkipAnimationRules();
+    postAnimationRestyles = restyleManager->PostAnimationRestyles();
   }
 
   // FIXME (perf): This should probably not rebuild the whole path, but
   // only the path from the last change in the rule tree, like
   // ReplaceAnimationRule in nsStyleSet.cpp does.  (That could then
   // perhaps share this code, too?)
   // But if we do that, we'll need to pass whether we are rebuilding the
   // rule tree from ElementRestyler::RestyleSelf to avoid taking that
@@ -1425,17 +1427,19 @@ nsStyleSet::RuleNodeWithReplacement(Elem
           nsPresContext* presContext = PresContext();
           nsAnimationManager* animationManager =
             presContext->AnimationManager();
           AnimationPlayerCollection* collection =
             animationManager->GetAnimationPlayers(aElement, aPseudoType, false);
 
           if (collection) {
             if (skipAnimationRules) {
-              collection->PostRestyleForAnimation(presContext);
+              if (postAnimationRestyles) {
+                collection->PostRestyleForAnimation(presContext);
+              }
             } else {
               animationManager->UpdateStyleAndEvents(
                 collection, PresContext()->RefreshDriver()->MostRecentRefresh(),
                 EnsureStyleRule_IsNotThrottled);
               if (collection->mStyleRule) {
                 ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
               }
             }
@@ -1448,17 +1452,19 @@ nsStyleSet::RuleNodeWithReplacement(Elem
           // internals of nsTransitionManager.
           nsPresContext* presContext = PresContext();
           AnimationPlayerCollection* collection =
             presContext->TransitionManager()->GetElementTransitions(
               aElement, aPseudoType, false);
 
           if (collection) {
             if (skipAnimationRules) {
-              collection->PostRestyleForAnimation(presContext);
+              if (postAnimationRestyles) {
+                collection->PostRestyleForAnimation(presContext);
+              }
             } else {
               collection->EnsureStyleRuleFor(
                 presContext->RefreshDriver()->MostRecentRefresh(),
                 EnsureStyleRule_IsNotThrottled);
               if (collection->mStyleRule) {
                 ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
               }
             }
@@ -2075,17 +2081,18 @@ nsStyleSet::GCRuleTrees()
   }
 }
 
 /**
  * Return an equivalent to aRuleNode with both animation and transition
  * rules removed, and post a restyle if needed.
  */
 static inline nsRuleNode*
-SkipAnimationRules(nsRuleNode* aRuleNode, Element* aElementOrPseudoElement)
+SkipAnimationRules(nsRuleNode* aRuleNode, Element* aElementOrPseudoElement,
+                   bool aPostAnimationRestyles)
 {
   nsRuleNode* ruleNode = aRuleNode;
   // The transition rule must be at the top of the cascade.
   if (!ruleNode->IsRoot() &&
       ruleNode->GetLevel() == nsStyleSet::eTransitionSheet) {
     ruleNode = ruleNode->GetParent();
   }
   NS_ABORT_IF_FALSE(ruleNode->IsRoot() ||
@@ -2094,17 +2101,17 @@ SkipAnimationRules(nsRuleNode* aRuleNode
 
   // Use our existing ReplaceAnimationRule function to replace the
   // animation rule, if present.
   nsIStyleRule* animationRule = GetAnimationRule(ruleNode);
   if (animationRule) {
     ruleNode = ReplaceAnimationRule(ruleNode, animationRule, nullptr);
   }
 
-  if (ruleNode != aRuleNode) {
+  if (ruleNode != aRuleNode && aPostAnimationRestyles) {
     NS_ASSERTION(aElementOrPseudoElement,
                  "How can we have transition rules but no element?");
     // Need to do an animation restyle, just like
     // nsTransitionManager::WalkTransitionRule and
     // nsAnimationManager::GetAnimationRule would.
     aRuleNode->PresContext()->PresShell()->
       RestyleForAnimation(aElementOrPseudoElement, eRestyle_Self);
   }
@@ -2130,39 +2137,41 @@ nsStyleSet::ReparentStyleContext(nsStyle
   }
 
   nsIAtom* pseudoTag = aStyleContext->GetPseudo();
   nsCSSPseudoElements::Type pseudoType = aStyleContext->GetPseudoType();
   nsRuleNode* ruleNode = aStyleContext->RuleNode();
 
   // Skip transition rules as needed just like
   // nsTransitionManager::WalkTransitionRule would.
-  bool skipAnimationRules = PresContext()->IsProcessingRestyles() &&
-    !PresContext()->IsProcessingAnimationStyleChange();
+  RestyleManager* restyleManager = PresContext()->RestyleManager();
+  bool skipAnimationRules = restyleManager->SkipAnimationRules();
+  bool postAnimationRestyles = restyleManager->PostAnimationRestyles();
   if (skipAnimationRules) {
     // Make sure that we're not using transition rules or animation rules for
     // our new style context.  If we need them, an animation restyle will
     // provide.
-    ruleNode =
-      SkipAnimationRules(ruleNode, aElementOrPseudoElement);
+    ruleNode = SkipAnimationRules(ruleNode, aElementOrPseudoElement,
+                                  postAnimationRestyles);
   }
 
   nsRuleNode* visitedRuleNode = nullptr;
   nsStyleContext* visitedContext = aStyleContext->GetStyleIfVisited();
   // Reparenting a style context just changes where we inherit from,
   // not what rules we match or what our DOM looks like.  In
   // particular, it doesn't change whether this is a style context for
   // a link.
   if (visitedContext) {
      visitedRuleNode = visitedContext->RuleNode();
      // Again, skip transition rules as needed
      if (skipAnimationRules) {
       // FIXME do something here for animations?
        visitedRuleNode =
-         SkipAnimationRules(visitedRuleNode, aElementOrPseudoElement);
+         SkipAnimationRules(visitedRuleNode, aElementOrPseudoElement,
+                            postAnimationRestyles);
      }
   }
 
   uint32_t flags = eNoFlags;
   if (aStyleContext->IsLinkContext()) {
     flags |= eIsLink;
 
     // GetContext handles propagating RelevantLinkVisited state from the
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -634,26 +634,28 @@ nsTransitionManager::WalkTransitionRule(
     return;
   }
 
   if (!mPresContext->IsDynamic()) {
     // For print or print preview, ignore animations.
     return;
   }
 
-  if (aData->mPresContext->IsProcessingRestyles() &&
-      !aData->mPresContext->IsProcessingAnimationStyleChange()) {
+  RestyleManager* restyleManager = aData->mPresContext->RestyleManager();
+  if (restyleManager->SkipAnimationRules()) {
     // If we're processing a normal style change rather than one from
     // animation, don't add the transition rule.  This allows us to
     // compute the new style value rather than having the transition
     // override it, so that we can start transitioning differently.
 
-    // We need to immediately restyle with animation
-    // after doing this.
-    collection->PostRestyleForAnimation(mPresContext);
+    if (restyleManager->PostAnimationRestyles()) {
+      // We need to immediately restyle with animation
+      // after doing this.
+      collection->PostRestyleForAnimation(mPresContext);
+    }
     return;
   }
 
   collection->mNeedsRefreshes = true;
   collection->EnsureStyleRuleFor(
     aData->mPresContext->RefreshDriver()->MostRecentRefresh(),
     EnsureStyleRule_IsNotThrottled);
 
