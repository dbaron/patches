From: L. David Baron <dbaron@dbaron.org>

Bug 1216431 patch 4 - Back out bug 1209603 patch 6.

This backs out all of the patch except that it retains some of the
comment changes for nsStyleContext::mBits.

diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -1373,17 +1373,17 @@ nsStyleContext::SwapStyleData(nsStyleCon
        i < nsStyleStructID_Inherited_Start + nsStyleStructID_Inherited_Count;
        i = nsStyleStructID(i + 1)) {
     uint32_t bit = nsCachedStyleData::GetBitForSID(i);
     if (!(aStructs & bit)) {
       continue;
     }
     void*& thisData = mCachedInheritedData.mStyleStructs[i];
     void*& otherData = aNewContext->mCachedInheritedData.mStyleStructs[i];
-    if ((mBits & bit) && thisData) {
+    if (mBits & bit) {
       if (thisData == otherData) {
         thisData = nullptr;
       }
     } else if (!(aNewContext->mBits & bit) && thisData && otherData) {
       std::swap(thisData, otherData);
     }
   }
 
@@ -1398,17 +1398,17 @@ nsStyleContext::SwapStyleData(nsStyleCon
       mCachedResetData = new (mRuleNode->PresContext()) nsResetStyleData;
     }
     if (!aNewContext->mCachedResetData) {
       aNewContext->mCachedResetData =
         new (mRuleNode->PresContext()) nsResetStyleData;
     }
     void*& thisData = mCachedResetData->mStyleStructs[i];
     void*& otherData = aNewContext->mCachedResetData->mStyleStructs[i];
-    if ((mBits & bit) && thisData) {
+    if (mBits & bit) {
       if (thisData == otherData) {
         thisData = nullptr;
       }
     } else if (!(aNewContext->mBits & bit) && thisData && otherData) {
       std::swap(thisData, otherData);
     }
   }
 }
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -283,19 +283,17 @@ public:
 
   /**
    * Returns whether this style context has cached style data for a
    * given style struct and it does NOT own that struct.  This can
    * happen because it was inherited from the parent style context, or
    * because it was stored conditionally on the rule node.
    */
   bool HasCachedDependentStyleData(nsStyleStructID aSID) {
-    return (mBits & nsCachedStyleData::GetBitForSID(aSID)) &&
-           GetCachedStyleData(aSID);
-  }
+    { return mBits & nsCachedStyleData::GetBitForSID(aSID); }
 
   nsRuleNode* RuleNode() { return mRuleNode; }
   void AddStyleBit(const uint64_t& aBit) { mBits |= aBit; }
 
   /*
    * Mark this style context's rule node (and its ancestors) to prevent
    * it from being garbage collected.
    */
@@ -612,29 +610,28 @@ private:
   // root of the rule tree, and the most specific rule matched is the
   // |mRule| member of |mRuleNode|.
   nsRuleNode* const       mRuleNode;
 
   // mCachedInheritedData and mCachedResetData point to both structs that
   // are owned by this style context and structs that are owned by one of
   // this style context's ancestors (which are indirectly owned since this
   // style context owns a reference to its parent).  If the bit in |mBits|
-  // is set for a non-null struct, that means that the pointer for that
-  // struct is owned by an ancestor or by mRuleNode rather than by this
-  // style context.  Since style contexts typically have some inherited
-  // data but only sometimes have reset data, we always allocate the
-  // mCachedInheritedData, but only sometimes allocate the
-  // mCachedResetData.
+  // is set for a struct, that means that the pointer for that struct is
+  // owned by an ancestor or by mRuleNode rather than by this style context.
+  // Since style contexts typically have some inherited data but only sometimes
+  // have reset data, we always allocate the mCachedInheritedData, but only
+  // sometimes allocate the mCachedResetData.
   nsResetStyleData*       mCachedResetData; // Cached reset style data.
   nsInheritedStyleData    mCachedInheritedData; // Cached inherited style data
 
   // mBits stores a number of things:
-  //  - For all structs, when they are non-null in the style context's
-  //    storage, it records (using the style struct bits) which structs
-  //    are inherited from the parent context or owned by mRuleNode.
+  //  - It records (using the style struct bits) which structs are
+  //    inherited from the parent context or owned by mRuleNode (i.e.,
+  //    not owned by the style context).
   //  - It also stores the additional bits listed at the top of
   //    nsStyleStruct.h.
   uint64_t                mBits;
 
   uint32_t                mRefCnt;
 
 #ifdef DEBUG
   uint32_t                mFrameRefCnt; // number of frames that use this
