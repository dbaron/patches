From: L. David Baron <dbaron@dbaron.org>

Add support for animation of text-shadow and -moz-box-shadow.

diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -1138,18 +1138,18 @@ CSS_PROP_BORDER(
     MozBoxShadow,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBoxShadow,
     eCSSType_ValueList,
     kBoxShadowTypeKTable,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleBorder, mBoxShadow),
+    eStyleAnimType_Shadow)
 CSS_PROP_POSITION(
     -moz-box-sizing,
     box_sizing,
     MozBoxSizing,
     0,
     Position,
     mBoxSizing,
     eCSSType_Value,
@@ -2303,18 +2303,18 @@ CSS_PROP_TEXT(
     TextShadow,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Text,
     mTextShadow,
     eCSSType_ValueList,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleText, mTextShadow),
+    eStyleAnimType_Shadow)
 CSS_PROP_TEXT(
     text-transform,
     text_transform,
     TextTransform,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE,
     Text,
     mTextTransform,
     eCSSType_Value,
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -87,16 +87,19 @@ enum nsStyleAnimType {
   eStyleAnimType_nscoord,
 
   // nscolor values
   eStyleAnimType_Color,
 
   // nsStyleSVGPaint values
   eStyleAnimType_PaintServer,
 
+  // nsRefPtr<nsCSSShadowArray> values
+  eStyleAnimType_Shadow,
+
   // property not animatable
   eStyleAnimType_None
 };
 
 class nsCSSProps {
 public:
   static void AddRefTable(void);
   static void ReleaseTable(void);
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -144,16 +144,20 @@ nsStyleAnimation::Add(nsStyleCoord& aDes
         ClampColor(NS_GET_G(destColor) + aCount * NS_GET_G(colorToAdd));
       PRUint8 resultB =
         ClampColor(NS_GET_B(destColor) + aCount * NS_GET_B(colorToAdd));
       PRUint8 resultA =
         ClampColor(NS_GET_A(destColor) + aCount * NS_GET_A(colorToAdd));
       aDest.SetColorValue(NS_RGBA(resultR, resultG, resultB, resultA));
       break;
     }
+    case eStyleUnit_Shadow:
+      // FIXME: WRITE ME
+      success = PR_FALSE;
+      break;
     case eStyleUnit_Null:
       success = PR_FALSE;
       break;
     default:
       NS_NOTREACHED("Can't add nsStyleCoords using the given common unit");
       success = PR_FALSE;
       break;
   }
@@ -214,16 +218,20 @@ nsStyleAnimation::ComputeDistance(const 
       double diffA = startA - endA;
       double diffR = startR - endR;
       double diffG = startG - endG;
       double diffB = startB - endB;
       aDistance = sqrt(diffA * diffA + diffR * diffR +
                        diffG * diffG + diffB * diffB);
       break;
     }
+    case eStyleUnit_Shadow:
+      // FIXME: WRITE ME
+      success = PR_FALSE;
+      break;
     case eStyleUnit_Null:
       success = PR_FALSE;
       break;
     default:
       NS_NOTREACHED("Can't compute distance using the given common unit");
       success = PR_FALSE;
       break;
   }
@@ -291,16 +299,20 @@ nsStyleAnimation::Interpolate(const nsSt
         PRUint8 resR = NSToIntRound((startR * inv + endR * aPortion) * factor);
         PRUint8 resG = NSToIntRound((startG * inv + endG * aPortion) * factor);
         PRUint8 resB = NSToIntRound((startB * inv + endB * aPortion) * factor);
         resultColor = NS_RGBA(resR, resG, resB, resA);
       }
       aResultValue.SetColorValue(resultColor);
       break;
     }
+    case eStyleUnit_Shadow:
+      // FIXME: WRITE ME
+      success = PR_FALSE;
+      break;
     case eStyleUnit_Null:
       success = PR_FALSE;
       break;
     default:
       NS_NOTREACHED("Can't interpolate using the given common unit");
       success = PR_FALSE;
       break;
   }
@@ -438,16 +450,19 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
           SetBothValuesTo(val);
       } else {
         NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
                           "type mismatch");
         static_cast<nsCSSValue*>(aSpecifiedValue)->
           SetColorValue(aComputedValue.GetColorValue());
       }
       break;
+    case eStyleUnit_Shadow:
+      // FIXME: WRITE ME!
+      return PR_FALSE;
     default:
       return PR_FALSE;
   }
   return PR_TRUE;
 }
 
 PRBool
 nsStyleAnimation::UncomputeValue(nsCSSProperty aProperty,
@@ -623,13 +638,17 @@ nsStyleAnimation::ExtractComputedValue(n
         return PR_TRUE;
       }
       if (paint.mType == eStyleSVGPaintType_None) {
         aComputedValue.SetNoneValue();
         return PR_TRUE;
       }
       return PR_FALSE;
     }
+    case eStyleAnimType_Shadow: {
+      // FIXME: WRITE ME!
+      return PR_FALSE;
+    }
     case eStyleAnimType_None:
       NS_NOTREACHED("shouldn't use on non-animatable properties");
   }
   return PR_FALSE;
 }
diff --git a/layout/style/nsStyleCoord.cpp b/layout/style/nsStyleCoord.cpp
--- a/layout/style/nsStyleCoord.cpp
+++ b/layout/style/nsStyleCoord.cpp
@@ -36,16 +36,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 /* representation of length values in computed style data */
 
 #include "nsStyleCoord.h"
 #include "nsString.h"
 #include "nsCRT.h"
 #include "prlog.h"
+#include "nsCSSStruct.h"
 
 nsStyleCoord::nsStyleCoord(nsStyleUnit aUnit)
   : mUnit(aUnit)
 {
   NS_ASSERTION(aUnit < eStyleUnit_Percent, "not a valueless unit");
   if (aUnit >= eStyleUnit_Percent) {
     mUnit = eStyleUnit_Null;
   }
@@ -93,97 +94,131 @@ nsStyleCoord::nsStyleCoord(float aValue,
 nsStyleCoord::nsStyleCoord(nscolor aValue)
   : mUnit(eStyleUnit_Color)
 {
   mValue.mColor = aValue;
 }
 
 nsStyleCoord& nsStyleCoord::operator=(const nsStyleCoord& aCopy)
 {
+  if (&aCopy == this)
+    return *this;
+
+  FreeValue();
+
   mUnit = aCopy.mUnit;
   if ((eStyleUnit_Percent <= mUnit) && (mUnit < eStyleUnit_Coord)) {
     mValue.mFloat = aCopy.mValue.mFloat;
   }
   else {
     mValue.mInt = aCopy.mValue.mInt;
   }
   return *this;
 }
 
 PRBool nsStyleCoord::operator==(const nsStyleCoord& aOther) const
 {
   if (mUnit == aOther.mUnit) {
-    if ((eStyleUnit_Percent <= mUnit) && (mUnit < eStyleUnit_Coord)) {
-      return PRBool(mValue.mFloat == aOther.mValue.mFloat);
+    if (eStyleUnit_Null <= mUnit && mUnit <= eStyleUnit_None) {
+      NS_ABORT_IF_FALSE(mValue.mInt == 0 && aOther.mValue.mInt == 0,
+                        "unexpected value");
+      return PR_TRUE;
     }
-    else {
-      return PRBool(mValue.mInt == aOther.mValue.mInt);
+    if (eStyleUnit_Percent <= mUnit && mUnit <= eStyleUnit_Factor) {
+      return mValue.mFloat == aOther.mValue.mFloat;
     }
+    if (eStyleUnit_Coord <= mUnit && mUnit <= eStyleUnit_Enumerated) {
+      return mValue.mInt == aOther.mValue.mInt;
+    }
+    if (mUnit == eStyleUnit_Color) {
+      return mValue.mColor == aOther.mValue.mColor;
+    }
+    if (mUnit == eStyleUnit_Shadow) {
+      return nsCSSValueList::Equal(mValue.mCSSValueList,
+                                   aOther.mValue.mCSSValueList);
+    }
+    NS_ABORT_IF_FALSE("unexpected unit");
   }
   return PR_FALSE;
 }
 
+void nsStyleCoord::FreeValue()
+{
+  if (mUnit == eStyleUnit_Shadow) {
+    delete mValue.mCSSValueList;
+  }
+}
+
 void nsStyleCoord::Reset(void)
 {
+  FreeValue();
   mUnit = eStyleUnit_Null;
   mValue.mInt = 0;
 }
 
 void nsStyleCoord::SetCoordValue(nscoord aValue)
 {
+  FreeValue();
   mUnit = eStyleUnit_Coord;
   mValue.mInt = aValue;
 }
 
 void nsStyleCoord::SetColorValue(nscolor aValue)
 {
+  FreeValue();
   mUnit = eStyleUnit_Color;
   mValue.mColor = aValue;
 }
 
 void nsStyleCoord::SetIntValue(PRInt32 aValue, nsStyleUnit aUnit)
 {
   NS_ASSERTION((aUnit == eStyleUnit_Enumerated) ||
                (aUnit == eStyleUnit_Integer), "not an int value");
+  FreeValue();
   if ((aUnit == eStyleUnit_Enumerated) ||
       (aUnit == eStyleUnit_Integer)) {
     mUnit = aUnit;
     mValue.mInt = aValue;
   }
   else {
     Reset();
   }
 }
 
 void nsStyleCoord::SetPercentValue(float aValue)
 {
+  FreeValue();
   mUnit = eStyleUnit_Percent;
   mValue.mFloat = aValue;
 }
 
 void nsStyleCoord::SetFactorValue(float aValue)
 {
+  FreeValue();
   mUnit = eStyleUnit_Factor;
   mValue.mFloat = aValue;
 }
 
 void nsStyleCoord::SetNormalValue(void)
 {
+  FreeValue();
   mUnit = eStyleUnit_Normal;
   mValue.mInt = 0;
 }
 
 void nsStyleCoord::SetAutoValue(void)
 {
+  FreeValue();
   mUnit = eStyleUnit_Auto;
   mValue.mInt = 0;
 }
 
 void nsStyleCoord::SetNoneValue(void)
 {
+  FreeValue();
   mUnit = eStyleUnit_None;
   mValue.mInt = 0;
 }
 
 // used by nsStyleSides and nsStyleCorners
 #define COMPARE_INDEXED_COORD(i)                                              \
   PR_BEGIN_MACRO                                                              \
   if (mUnits[i] != aOther.mUnits[i])                                          \
diff --git a/layout/style/nsStyleCoord.h b/layout/style/nsStyleCoord.h
--- a/layout/style/nsStyleCoord.h
+++ b/layout/style/nsStyleCoord.h
@@ -41,34 +41,37 @@
 #define nsStyleCoord_h___
 
 #include "nscore.h"
 #include "nsCoord.h"
 #include "nsColor.h"
 #include "nsCRT.h"
 #include "nsStyleConsts.h"
 class nsString;
+class nsCSSValueList;
 
 enum nsStyleUnit {
   eStyleUnit_Null         = 0,      // (no value) value is not specified
   eStyleUnit_Normal       = 1,      // (no value)
   eStyleUnit_Auto         = 2,      // (no value)
   eStyleUnit_None         = 3,      // (no value)
   eStyleUnit_Percent      = 10,     // (float) 1.0 == 100%
   eStyleUnit_Factor       = 11,     // (float) a multiplier
   eStyleUnit_Coord        = 20,     // (nscoord) value is twips
   eStyleUnit_Integer      = 30,     // (int) value is simple integer
   eStyleUnit_Enumerated   = 32,     // (int) value has enumerated meaning
-  eStyleUnit_Color        = 40      // (nscolor)
+  eStyleUnit_Color        = 40,     // (nscolor)
+  eStyleUnit_Shadow       = 50      // (nsCSSValueList*)
 };
 
 typedef union {
   PRInt32     mInt;   // nscoord is a PRInt32 for now
   float       mFloat;
   nscolor     mColor;
+  nsCSSValueList* mCSSValueList;
 } nsStyleUnion;
 
 /**
  * Class that hold a single size specification used by the style
  * system.  The size specification consists of two parts -- a number
  * and a unit.  The number is an integer, a floating point value, an
  * nscoord, or undefined, and the unit is an nsStyleUnit.  Checking
  * the unit is a must before asking for the value in any particular
@@ -78,16 +81,17 @@ class nsStyleCoord {
 public:
   nsStyleCoord(nsStyleUnit aUnit = eStyleUnit_Null);
   nsStyleCoord(nscoord aValue);
   nsStyleCoord(PRInt32 aValue, nsStyleUnit aUnit);
   nsStyleCoord(float aValue, nsStyleUnit aUnit);
   nsStyleCoord(nscolor aValue);
   inline nsStyleCoord(const nsStyleCoord& aCopy);
   inline nsStyleCoord(const nsStyleUnion& aValue, nsStyleUnit aUnit);
+  ~nsStyleCoord() { FreeValue(); }
 
   nsStyleCoord&  operator=(const nsStyleCoord& aCopy);
   PRBool         operator==(const nsStyleCoord& aOther) const;
   PRBool         operator!=(const nsStyleCoord& aOther) const;
 
   nsStyleUnit GetUnit(void) const {
     NS_ASSERTION(mUnit != eStyleUnit_Null, "reading uninitialized value");
     return mUnit;
@@ -100,28 +104,32 @@ public:
   }
 
   nscoord     GetCoordValue(void) const;
   PRInt32     GetIntValue(void) const;
   float       GetPercentValue(void) const;
   float       GetFactorValue(void) const;
   nscolor     GetColorValue() const;
   void        GetUnionValue(nsStyleUnion& aValue) const;
+  nsCSSValueList* GetCSSValueListValue() const;
 
   void  Reset(void);  // sets to null
   void  SetCoordValue(nscoord aValue);
   void  SetIntValue(PRInt32 aValue, nsStyleUnit aUnit);
   void  SetPercentValue(float aValue);
   void  SetFactorValue(float aValue);
   void  SetNormalValue(void);
   void  SetAutoValue(void);
   void  SetNoneValue(void);
   void  SetColorValue(nscolor aValue);
+  void  SetCSSValueListValue(nsCSSValueList* aValue, nsStyleUnit aUnit);
 
-public:
+private:
+  void  FreeValue();
+
   nsStyleUnit   mUnit;
   nsStyleUnion  mValue;
 };
 
 
 /**
  * Class that represents a set of top/right/bottom/left nsStyleCoords.
  * This is commonly used to hold the widths of the borders, margins,
@@ -262,16 +270,25 @@ inline nscolor nsStyleCoord::GetColorVal
 {
   NS_ASSERTION((mUnit == eStyleUnit_Color), "not a color value");
   if (mUnit == eStyleUnit_Color) {
     return mValue.mColor;
   }
   return NS_RGBA(0, 0, 0, 0);
 }
 
+inline nsCSSValueList* nsStyleCoord::GetCSSValueListValue() const
+{
+  NS_ASSERTION(mUnit == eStyleUnit_Shadow, "not a CSS value list value");
+  if (mUnit == eStyleUnit_Shadow) {
+    return mValue.mCSSValueList;
+  }
+  return nsnull;
+}
+
 inline void nsStyleCoord::GetUnionValue(nsStyleUnion& aValue) const
 {
   memcpy(&aValue, &mValue, sizeof(nsStyleUnion));
 }
 
 // -------------------------
 // nsStyleSides inlines
 //
