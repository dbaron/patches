Warn when Unlink doesn't do what it should.

diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -1596,6 +1596,18 @@ nsCycleCollector::CollectWhite()
         if (NS_FAILED(rv))
             Fault("Failed unroot call while unlinking", pinfo);
     }
+
+#ifdef DEBUG_CC
+    for (i = 0; i < count; ++i) {
+        PtrInfo *pinfo = static_cast<PtrInfo*>(mBuf.ObjectAt(i));
+        if (pinfo->mLangID == nsIProgrammingLanguage::CPLUSPLUS &&
+            mPurpleBuf.Exists(pinfo->mPointer)) {
+            printf("nsCycleCollector: %s object @%p is still alive after\n"
+                   "  calling Root, Unlink, and Unroot on it!\n",
+                   pinfo->mName, pinfo->mPointer);
+        }
+    }
+#endif
 
     mBuf.Empty();
 
@@ -2656,7 +2668,8 @@ nsCycleCollector::CreateReversedEdges()
             ++current;
         }
     }
-    NS_ASSERTION(current - mGraph.mReversedEdges == edgeCount, "misallocation");
+    NS_ASSERTION(current - mGraph.mReversedEdges == ptrdiff_t(edgeCount),
+                 "misallocation");
     return PR_TRUE;
 }
 
