From: L. David Baron <dbaron@dbaron.org>

Remove the multiple-parameter versions of nsRenderingContext::SetFont.

This changes the only remaining callers (in nsMathMLChar) to pass the
correct language, which they were not previously doing, which should
improve the correctness of font selection and also reduce the number of
unique font metrics objects requested (which helps nsFontCache
effectiveness).  Those callers, however, remain the odd font users
within all of layout.

diff --git a/gfx/src/nsRenderingContext.cpp b/gfx/src/nsRenderingContext.cpp
--- a/gfx/src/nsRenderingContext.cpp
+++ b/gfx/src/nsRenderingContext.cpp
@@ -450,32 +450,16 @@ nsRenderingContext::FillPolygon(const ns
 
 void
 nsRenderingContext::SetTextRunRTL(PRBool aIsRTL)
 {
     mFontMetrics->SetTextRunRTL(aIsRTL);
 }
 
 void
-nsRenderingContext::SetFont(const nsFont& aFont, nsIAtom* aLanguage,
-                            gfxUserFontSet *aUserFontSet)
-{
-    mDeviceContext->GetMetricsFor(aFont, aLanguage, aUserFontSet,
-                                  *getter_AddRefs(mFontMetrics));
-}
-
-void
-nsRenderingContext::SetFont(const nsFont& aFont,
-                            gfxUserFontSet *aUserFontSet)
-{
-    mDeviceContext->GetMetricsFor(aFont, nsnull, aUserFontSet,
-                                  *getter_AddRefs(mFontMetrics));
-}
-
-void
 nsRenderingContext::SetFont(nsFontMetrics *aFontMetrics)
 {
     mFontMetrics = aFontMetrics;
 }
 
 PRInt32
 nsRenderingContext::GetMaxChunkLength()
 {
diff --git a/gfx/src/nsRenderingContext.h b/gfx/src/nsRenderingContext.h
--- a/gfx/src/nsRenderingContext.h
+++ b/gfx/src/nsRenderingContext.h
@@ -112,19 +112,16 @@ public:
     void FillEllipse(const nsRect& aRect);
     void FillEllipse(nscoord aX, nscoord aY, nscoord aWidth, nscoord aHeight);
 
     void InvertRect(const nsRect& aRect);
     void InvertRect(nscoord aX, nscoord aY, nscoord aWidth, nscoord aHeight);
 
     // Text
 
-    void SetFont(const nsFont& aFont, nsIAtom* aLanguage,
-                 gfxUserFontSet *aUserFontSet);
-    void SetFont(const nsFont& aFont, gfxUserFontSet *aUserFontSet);
     void SetFont(nsFontMetrics *aFontMetrics);
     nsFontMetrics *FontMetrics() { return mFontMetrics; } // may be null
 
     void SetTextRunRTL(PRBool aIsRTL);
 
     nscoord GetWidth(char aC);
     nscoord GetWidth(PRUnichar aC);
     nscoord GetWidth(const nsString& aString);
diff --git a/layout/mathml/nsMathMLChar.cpp b/layout/mathml/nsMathMLChar.cpp
--- a/layout/mathml/nsMathMLChar.cpp
+++ b/layout/mathml/nsMathMLChar.cpp
@@ -1037,28 +1037,33 @@ insert:
   }
   else { // whitespace or empty
     aFontName = aFallbackFamilies;
   }
 }
 
 // Update the font and rendering context if there is a family change
 static void
-SetFontFamily(nsPresContext*       aPresContext,
-              nsRenderingContext& aRenderingContext,
+SetFontFamily(nsStyleContext*      aStyleContext,
+              nsRenderingContext&  aRenderingContext,
               nsFont&              aFont,
               const nsGlyphTable*  aGlyphTable,
               const nsGlyphCode&   aGlyphCode,
               const nsAString&     aDefaultFamily)
 {
   const nsAString& family =
     aGlyphCode.font ? aGlyphTable->FontNameFor(aGlyphCode) : aDefaultFamily;
   if (! family.Equals(aFont.name)) {
     aFont.name = family;
-    aRenderingContext.SetFont(aFont, aPresContext->GetUserFontSet());
+    nsRefPtr<nsFontMetrics> fm;
+    aRenderingContext.DeviceContext()->GetMetricsFor(aFont,
+      aStyleContext->GetStyleVisibility()->mLanguage,
+      aStyleContext->PresContext()->GetUserFontSet(),
+      *getter_AddRefs(fm));
+    aRenderingContext.SetFont(fm);
   }
 }
 
 class nsMathMLChar::StretchEnumContext {
 public:
   StretchEnumContext(nsMathMLChar*        aChar,
                      nsPresContext*       aPresContext,
                      nsRenderingContext& aRenderingContext,
@@ -1114,17 +1119,18 @@ private:
 // 2. See if there are any glyphs of the appropriate size.
 // Returns PR_TRUE if the size is OK, PR_FALSE to keep searching.
 // Always updates the char if a better match is found.
 PRBool
 nsMathMLChar::StretchEnumContext::TryVariants(nsGlyphTable*    aGlyphTable,
                                               const nsAString& aFamily)
 {
   // Use our stretchy style context now that stretching is in progress
-  nsFont font = mChar->mStyleContext->GetStyleFont()->mFont;
+  nsStyleContext *sc = mChar->mStyleContext;
+  nsFont font = sc->GetStyleFont()->mFont;
   // Ensure mRenderingContext.SetFont will be called:
   font.name.Truncate();
 
   PRBool isVertical = (mDirection == NS_STRETCH_DIRECTION_VERTICAL);
   PRBool largeop = (NS_STRETCH_LARGEOP & mStretchHint) != 0;
   PRBool largeopOnly =
     largeop && (NS_STRETCH_VARIABLE_MASK & mStretchHint) == 0;
   PRBool maxWidth = (NS_STRETCH_MAXWIDTH & mStretchHint) != 0;
@@ -1139,18 +1145,17 @@ nsMathMLChar::StretchEnumContext::TryVar
 #ifdef NOISY_SEARCH
   printf("  searching in %s ...\n",
            NS_LossyConvertUTF16toASCII(aFamily).get());
 #endif
 
   nsGlyphCode ch;
   while ((ch = aGlyphTable->BigOf(mPresContext, mChar, size)).Exists()) {
 
-    SetFontFamily(mChar->mStyleContext->PresContext(), mRenderingContext,
-                  font, aGlyphTable, ch, aFamily);
+    SetFontFamily(sc, mRenderingContext, font, aGlyphTable, ch, aFamily);
 
     NS_ASSERTION(maxWidth || ch.code[0] != mChar->mGlyph.code[0] ||
                  ch.code[1] != mChar->mGlyph.code[1] ||
                  !font.name.Equals(mChar->mFamily),
                  "glyph table incorrectly set -- duplicate found");
 
     nsBoundingMetrics bm = mRenderingContext.GetBoundingMetrics(ch.code,
                                                                 ch.Length());
@@ -1264,17 +1269,17 @@ nsMathMLChar::StretchEnumContext::TryPar
     if (!ch.Exists()) ch = glue;
     chdata[i] = ch;
     if (!ch.Exists()) {
       // Null glue indicates that a rule will be drawn, which can stretch to
       // fill any space.  Leave bounding metrics at 0.
       sizedata[i] = mTargetSize;
     }
     else {
-      SetFontFamily(mChar->mStyleContext->PresContext(), mRenderingContext,
+      SetFontFamily(mChar->mStyleContext, mRenderingContext,
                     font, aGlyphTable, ch, aFamily);
       nsBoundingMetrics bm = mRenderingContext.GetBoundingMetrics(ch.code,
                                                                   ch.Length());
 
       // TODO: For the generic Unicode table, ideally we should check that the
       // glyphs are actually found and that they each come from the same
       // font.
       bmdata[i] = bm;
@@ -1455,17 +1460,21 @@ nsMathMLChar::StretchInternal(nsPresCont
   // Don't modify this nsMathMLChar when doing GetMaxWidth()
   PRBool maxWidth = (NS_STRETCH_MAXWIDTH & aStretchHint) != 0;
   if (!maxWidth) {
     // Record the families in case there is no stretch.  But don't bother
     // storing families when they are just those from the StyleContext.
     mFamily = families;
   }
 
-  aRenderingContext.SetFont(font, aPresContext->GetUserFontSet());
+  nsRefPtr<nsFontMetrics> fm;
+  aRenderingContext.DeviceContext()->GetMetricsFor(font,
+    mStyleContext->GetStyleVisibility()->mLanguage,
+    aPresContext->GetUserFontSet(), *getter_AddRefs(fm));
+  aRenderingContext.SetFont(fm);
   aDesiredStretchSize =
     aRenderingContext.GetBoundingMetrics(mData.get(), PRUint32(mData.Length()));
 
   if (!maxWidth) {
     mUnscaledAscent = aDesiredStretchSize.ascent;
   }
 
   ////////////////////////////////////////////////////////////////////////////////////
@@ -2051,17 +2060,22 @@ nsMathMLChar::PaintForeground(nsPresCont
       GetColor(nsILookAndFeel::eColor_TextSelectForeground, fgColor);
   }
   aRenderingContext.SetColor(fgColor);
 
   nsFont theFont(styleContext->GetStyleFont()->mFont);
   if (! mFamily.IsEmpty()) {
     theFont.name = mFamily;
   }
-  aRenderingContext.SetFont(theFont, aPresContext->GetUserFontSet());
+  nsRefPtr<nsFontMetrics> fm;
+  aRenderingContext.DeviceContext()->GetMetricsFor(theFont,
+    styleContext->GetStyleVisibility()->mLanguage,
+    aPresContext->GetUserFontSet(),
+    *getter_AddRefs(fm));
+  aRenderingContext.SetFont(fm);
 
   aRenderingContext.PushState();
   nsRect r = mRect + aPt;
   ApplyTransforms(aRenderingContext, r);
 
   if (mDrawNormal) {
     // normal drawing if there is nothing special about this char ...
     // Grab some metrics to adjust the placements ...
@@ -2160,17 +2174,17 @@ nsMathMLChar::PaintVertically(nsPresCont
         ch = chGlue;
         glue = i;
         break;
     }
     // empty slots are filled with the glue if it is not null
     if (!ch.Exists()) ch = chGlue;
     // if (!ch.Exists()) glue is null, leave bounding metrics at 0
     if (ch.Exists()) {
-      SetFontFamily(aPresContext, aRenderingContext,
+      SetFontFamily(aStyleContext, aRenderingContext,
                     aFont, aGlyphTable, ch, mFamily);
       bmdata[i] = aRenderingContext.GetBoundingMetrics(ch.code, ch.Length());
     }
     chdata[i] = ch;
     ++i;
   }
   nscoord dx = aRect.x;
   nscoord offset[3], start[3], end[3];
@@ -2245,17 +2259,17 @@ nsMathMLChar::PaintVertically(nsPresCont
         }
         else { // middle
           clipRect.y = start[i];
           clipRect.height = end[i] - start[i];
         }
       }
       if (!clipRect.IsEmpty()) {
         AutoPushClipRect clip(aRenderingContext, clipRect);
-        SetFontFamily(aPresContext, aRenderingContext,
+        SetFontFamily(aStyleContext, aRenderingContext,
                       aFont, aGlyphTable, ch, mFamily);
         aRenderingContext.DrawString(ch.code, ch.Length(), dx, dy);
       }
     }
   }
 
   ///////////////
   // fill the gap between top and middle, and between middle and bottom.
@@ -2302,17 +2316,17 @@ nsMathMLChar::PaintVertically(nsPresCont
     // Ensure the stride for the glue is not reduced to less than one pixel
     if (bm.ascent + bm.descent >= 3 * oneDevPixel) {
       // To protect against gaps, pretend the glue is smaller than it is,
       // in order to trim off ends and thus get a solid edge for the join.
       bm.ascent -= oneDevPixel;
       bm.descent -= oneDevPixel;
     }
 
-    SetFontFamily(aPresContext, aRenderingContext,
+    SetFontFamily(aStyleContext, aRenderingContext,
                   aFont, aGlyphTable, chGlue, mFamily);
     nsRect clipRect = unionRect;
 
     for (i = 0; i < bottom; ++i) {
       // Make sure not to draw outside the character
       nscoord dy = NS_MAX(end[i], aRect.y);
       nscoord fillEnd = NS_MIN(start[i+1], aRect.YMost());
 #ifdef SHOW_BORDERS
@@ -2388,17 +2402,17 @@ nsMathMLChar::PaintHorizontally(nsPresCo
         ch = chGlue;
         glue = i;
         break;
     }
     // empty slots are filled with the glue if it is not null
     if (!ch.Exists()) ch = chGlue;
     // if (!ch.Exists()) glue is null, leave bounding metrics at 0.
     if (ch.Exists()) {
-      SetFontFamily(aPresContext, aRenderingContext,
+      SetFontFamily(aStyleContext, aRenderingContext,
                     aFont, aGlyphTable, ch, mFamily);
       bmdata[i] = aRenderingContext.GetBoundingMetrics(ch.code, ch.Length());
     }
     chdata[i] = ch;
     ++i;
   }
   nscoord dy = aRect.y + mBoundingMetrics.ascent;
   nscoord offset[3], start[3], end[3];
@@ -2468,17 +2482,17 @@ nsMathMLChar::PaintHorizontally(nsPresCo
         }
         else { // middle
           clipRect.x = start[i];
           clipRect.width = end[i] - start[i];
         }
       }
       if (!clipRect.IsEmpty()) {
         AutoPushClipRect clip(aRenderingContext, clipRect);
-        SetFontFamily(aPresContext, aRenderingContext,
+        SetFontFamily(aStyleContext, aRenderingContext,
                       aFont, aGlyphTable, ch, mFamily);
         aRenderingContext.DrawString(ch.code, ch.Length(), dx, dy);
       }
     }
   }
 
   ////////////////
   // fill the gap between left and middle, and between middle and right.
@@ -2524,17 +2538,17 @@ nsMathMLChar::PaintHorizontally(nsPresCo
     // Ensure the stride for the glue is not reduced to less than one pixel
     if (bm.rightBearing - bm.leftBearing >= 3 * oneDevPixel) {
       // To protect against gaps, pretend the glue is smaller than it is,
       // in order to trim off ends and thus get a solid edge for the join.
       bm.leftBearing += oneDevPixel;
       bm.rightBearing -= oneDevPixel;
     }
 
-    SetFontFamily(aPresContext, aRenderingContext,
+    SetFontFamily(aStyleContext, aRenderingContext,
                   aFont, aGlyphTable, chGlue, mFamily);
     nsRect clipRect = unionRect;
 
     for (i = 0; i < right; ++i) {
       // Make sure not to draw outside the character
       nscoord dx = NS_MAX(end[i], aRect.x);
       nscoord fillEnd = NS_MIN(start[i+1], aRect.XMost());
 #ifdef SHOW_BORDERS
