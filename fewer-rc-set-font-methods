From: L. David Baron <dbaron@dbaron.org>

Remove the multiple-parameter versions of nsRenderingContext::SetFont.

This changes the only remaining callers (in nsMathMLChar) to pass the
correct language and user font set, which they were not previously
doing.  Those callers, however, remain the odd font users within all of
layout.

diff --git a/gfx/src/nsRenderingContext.cpp b/gfx/src/nsRenderingContext.cpp
--- a/gfx/src/nsRenderingContext.cpp
+++ b/gfx/src/nsRenderingContext.cpp
@@ -450,32 +450,16 @@ nsRenderingContext::FillPolygon(const ns
 
 void
 nsRenderingContext::SetTextRunRTL(PRBool aIsRTL)
 {
     mFontMetrics->SetTextRunRTL(aIsRTL);
 }
 
 void
-nsRenderingContext::SetFont(const nsFont& aFont, nsIAtom* aLanguage,
-                            gfxUserFontSet *aUserFontSet)
-{
-    mDeviceContext->GetMetricsFor(aFont, aLanguage, aUserFontSet,
-                                  *getter_AddRefs(mFontMetrics));
-}
-
-void
-nsRenderingContext::SetFont(const nsFont& aFont,
-                            gfxUserFontSet *aUserFontSet)
-{
-    mDeviceContext->GetMetricsFor(aFont, nsnull, aUserFontSet,
-                                  *getter_AddRefs(mFontMetrics));
-}
-
-void
 nsRenderingContext::SetFont(nsFontMetrics *aFontMetrics)
 {
     mFontMetrics = aFontMetrics;
 }
 
 PRInt32
 nsRenderingContext::GetMaxChunkLength()
 {
diff --git a/gfx/src/nsRenderingContext.h b/gfx/src/nsRenderingContext.h
--- a/gfx/src/nsRenderingContext.h
+++ b/gfx/src/nsRenderingContext.h
@@ -112,19 +112,16 @@ public:
     void FillEllipse(const nsRect& aRect);
     void FillEllipse(nscoord aX, nscoord aY, nscoord aWidth, nscoord aHeight);
 
     void InvertRect(const nsRect& aRect);
     void InvertRect(nscoord aX, nscoord aY, nscoord aWidth, nscoord aHeight);
 
     // Text
 
-    void SetFont(const nsFont& aFont, nsIAtom* aLanguage,
-                 gfxUserFontSet *aUserFontSet);
-    void SetFont(const nsFont& aFont, gfxUserFontSet *aUserFontSet);
     void SetFont(nsFontMetrics *aFontMetrics);
     nsFontMetrics *FontMetrics() { return mFontMetrics; } // may be null
 
     void SetTextRunRTL(PRBool aIsRTL);
 
     nscoord GetWidth(char aC);
     nscoord GetWidth(PRUnichar aC);
     nscoord GetWidth(const nsString& aString);
diff --git a/layout/mathml/nsMathMLChar.cpp b/layout/mathml/nsMathMLChar.cpp
--- a/layout/mathml/nsMathMLChar.cpp
+++ b/layout/mathml/nsMathMLChar.cpp
@@ -1037,28 +1037,33 @@ insert:
   }
   else { // whitespace or empty
     aFontName = aFallbackFamilies;
   }
 }
 
 // Update the font and rendering context if there is a family change
 static void
-SetFontFamily(nsPresContext*       aPresContext,
-              nsRenderingContext& aRenderingContext,
+SetFontFamily(nsStyleContext*      aStyleContext,
+              nsRenderingContext&  aRenderingContext,
               nsFont&              aFont,
               const nsGlyphTable*  aGlyphTable,
               const nsGlyphCode&   aGlyphCode,
               const nsAString&     aDefaultFamily)
 {
   const nsAString& family =
     aGlyphCode.font ? aGlyphTable->FontNameFor(aGlyphCode) : aDefaultFamily;
   if (! family.Equals(aFont.name)) {
     aFont.name = family;
-    aRenderingContext.SetFont(aFont, aPresContext->GetUserFontSet());
+    nsRefPtr<nsFontMetrics> fm;
+    aRenderingContext.DeviceContext()->GetMetricsFor(aFont,
+      aStyleContext->GetVisibility()->mLanguage,
+      aStyleContext->PresContext()->GetUserFontSet(),
+      getter_AddRefs(fm));
+    aRenderingContext.SetFont(fm);
   }
 }
 
 class nsMathMLChar::StretchEnumContext {
 public:
   StretchEnumContext(nsMathMLChar*        aChar,
                      nsPresContext*       aPresContext,
                      nsRenderingContext& aRenderingContext,
@@ -1114,17 +1119,18 @@ private:
 // 2. See if there are any glyphs of the appropriate size.
 // Returns PR_TRUE if the size is OK, PR_FALSE to keep searching.
 // Always updates the char if a better match is found.
 PRBool
 nsMathMLChar::StretchEnumContext::TryVariants(nsGlyphTable*    aGlyphTable,
                                               const nsAString& aFamily)
 {
   // Use our stretchy style context now that stretching is in progress
-  nsFont font = mChar->mStyleContext->GetStyleFont()->mFont;
+  nsStyleContext *sc = mChar->mStyleContext;
+  nsFont font = sc->GetStyleFont()->mFont;
   // Ensure mRenderingContext.SetFont will be called:
   font.name.Truncate();
 
   PRBool isVertical = (mDirection == NS_STRETCH_DIRECTION_VERTICAL);
   PRBool largeop = (NS_STRETCH_LARGEOP & mStretchHint) != 0;
   PRBool largeopOnly =
     largeop && (NS_STRETCH_VARIABLE_MASK & mStretchHint) == 0;
   PRBool maxWidth = (NS_STRETCH_MAXWIDTH & mStretchHint) != 0;
@@ -1139,18 +1145,17 @@ nsMathMLChar::StretchEnumContext::TryVar
 #ifdef NOISY_SEARCH
   printf("  searching in %s ...\n",
            NS_LossyConvertUTF16toASCII(aFamily).get());
 #endif
 
   nsGlyphCode ch;
   while ((ch = aGlyphTable->BigOf(mPresContext, mChar, size)).Exists()) {
 
-    SetFontFamily(mChar->mStyleContext->PresContext(), mRenderingContext,
-                  font, aGlyphTable, ch, aFamily);
+    SetFontFamily(sc, mRenderingContext, font, aGlyphTable, ch, aFamily);
 
     NS_ASSERTION(maxWidth || ch.code[0] != mChar->mGlyph.code[0] ||
                  ch.code[1] != mChar->mGlyph.code[1] ||
                  !font.name.Equals(mChar->mFamily),
                  "glyph table incorrectly set -- duplicate found");
 
     nsBoundingMetrics bm = mRenderingContext.GetBoundingMetrics(ch.code,
                                                                 ch.Length());
@@ -1455,17 +1460,21 @@ nsMathMLChar::StretchInternal(nsPresCont
   // Don't modify this nsMathMLChar when doing GetMaxWidth()
   PRBool maxWidth = (NS_STRETCH_MAXWIDTH & aStretchHint) != 0;
   if (!maxWidth) {
     // Record the families in case there is no stretch.  But don't bother
     // storing families when they are just those from the StyleContext.
     mFamily = families;
   }
 
-  aRenderingContext.SetFont(font, aPresContext->GetUserFontSet());
+  nsRefPtr<nsFontMetrics> fm;
+  aRenderingContext.DeviceContext()->GetMetricsFor(font,
+    mStyleContext->GetVisibility()->mLanguage, aPresContext->GetUserFontSet(),
+    getter_AddRefs(fm));
+  aRenderingContext.SetFont(fm);
   aDesiredStretchSize =
     aRenderingContext.GetBoundingMetrics(mData.get(), PRUint32(mData.Length()));
 
   if (!maxWidth) {
     mUnscaledAscent = aDesiredStretchSize.ascent;
   }
 
   ////////////////////////////////////////////////////////////////////////////////////
@@ -2051,17 +2060,22 @@ nsMathMLChar::PaintForeground(nsPresCont
       GetColor(nsILookAndFeel::eColor_TextSelectForeground, fgColor);
   }
   aRenderingContext.SetColor(fgColor);
 
   nsFont theFont(styleContext->GetStyleFont()->mFont);
   if (! mFamily.IsEmpty()) {
     theFont.name = mFamily;
   }
-  aRenderingContext.SetFont(theFont, aPresContext->GetUserFontSet());
+  nsRefPtr<nsFontMetrics> fm;
+  aRenderingContext.DeviceContext()->GetMetricsFor(theFont,
+    styleContext->GetStyleVisibility()->mLanguage,
+    aPresContext->GetUserFontSet(),
+    getter_AddRefs(fm));
+  aRenderingContext.SetFont(fm);
 
   aRenderingContext.PushState();
   nsRect r = mRect + aPt;
   ApplyTransforms(aRenderingContext, r);
 
   if (mDrawNormal) {
     // normal drawing if there is nothing special about this char ...
     // Grab some metrics to adjust the placements ...
