From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::GetClientRect to GetXULClientRect.  r?dholbert

This is a manual subset of changes written with sed, over .h and .cpp
files in layout/.  There is also a Selection method called IsCollapsed.

MozReview-Commit-ID: 2F7Bt3i4ogu

diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -4805,17 +4805,17 @@ ScrollFrameHelper::IsScrollingActive(nsD
 nsresult
 nsXULScrollFrame::XULLayout(nsBoxLayoutState& aState)
 {
   bool scrollbarRight = IsScrollbarOnRight();
   bool scrollbarBottom = true;
 
   // get the content rect
   nsRect clientRect(0,0,0,0);
-  GetClientRect(clientRect);
+  GetXULClientRect(clientRect);
 
   nsRect oldScrollAreaBounds = mHelper.mScrollPort;
   nsPoint oldScrollPosition = mHelper.GetLogicalScrollPosition();
 
   // the scroll area size starts off as big as our content area
   mHelper.mScrollPort = clientRect;
 
   /**************
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2913,17 +2913,17 @@ public:
   // Box methods.  Note that these do NOT just get the CSS border, padding,
   // etc.  They also talk to nsITheme.
   virtual nsresult GetXULBorderAndPadding(nsMargin& aBorderAndPadding);
   virtual nsresult GetXULBorder(nsMargin& aBorder)=0;
   virtual nsresult GetXULPadding(nsMargin& aBorderAndPadding)=0;
   virtual nsresult GetXULMargin(nsMargin& aMargin)=0;
   virtual void SetXULLayoutManager(nsBoxLayout* aLayout) { }
   virtual nsBoxLayout* GetXULLayoutManager() { return nullptr; }
-  nsresult GetClientRect(nsRect& aContentRect);
+  nsresult GetXULClientRect(nsRect& aContentRect);
 
   // For nsSprocketLayout
   virtual Valignment GetVAlign() const = 0;
   virtual Halignment GetHAlign() const = 0;
 
   bool IsHorizontal() const { return (mState & NS_STATE_IS_HORIZONTAL) != 0; }
   bool IsNormalDirection() const { return (mState & NS_STATE_IS_DIRECTION_NORMAL) != 0; }
 
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -203,17 +203,17 @@ nsBox::Shutdown()
 
 nsresult
 nsBox::RelayoutChildAtOrdinal(nsIFrame* aChild)
 {
   return NS_OK;
 }
 
 nsresult
-nsIFrame::GetClientRect(nsRect& aClientRect)
+nsIFrame::GetXULClientRect(nsRect& aClientRect)
 {
   aClientRect = mRect;
   aClientRect.MoveTo(0,0);
 
   nsMargin borderPadding;
   GetXULBorderAndPadding(borderPadding);
 
   aClientRect.Deflate(borderPadding);
diff --git a/layout/xul/nsImageBoxFrame.cpp b/layout/xul/nsImageBoxFrame.cpp
--- a/layout/xul/nsImageBoxFrame.cpp
+++ b/layout/xul/nsImageBoxFrame.cpp
@@ -324,17 +324,17 @@ nsImageBoxFrame::BuildDisplayList(nsDisp
 }
 
 DrawResult
 nsImageBoxFrame::PaintImage(nsRenderingContext& aRenderingContext,
                             const nsRect& aDirtyRect, nsPoint aPt,
                             uint32_t aFlags)
 {
   nsRect constraintRect;
-  GetClientRect(constraintRect);
+  GetXULClientRect(constraintRect);
 
   constraintRect += aPt;
 
   if (!mImageRequest) {
     // This probably means we're drawn by a native theme.
     return DrawResult::SUCCESS;
   }
 
@@ -471,17 +471,17 @@ nsDisplayXULImage::GetImage()
 }
 
 nsRect
 nsDisplayXULImage::GetDestRect()
 {
   nsImageBoxFrame* imageFrame = static_cast<nsImageBoxFrame*>(mFrame);
 
   nsRect clientRect;
-  imageFrame->GetClientRect(clientRect);
+  imageFrame->GetXULClientRect(clientRect);
 
   return clientRect + ToReferenceFrame();
 }
 
 bool
 nsImageBoxFrame::CanOptimizeToImageLayer()
 {
   bool hasSubRect = !mUseSrcAttr && (mSubRect.width > 0 || mSubRect.height > 0);
diff --git a/layout/xul/nsListBoxBodyFrame.cpp b/layout/xul/nsListBoxBodyFrame.cpp
--- a/layout/xul/nsListBoxBodyFrame.cpp
+++ b/layout/xul/nsListBoxBodyFrame.cpp
@@ -1003,17 +1003,17 @@ nsListBoxBodyFrame::SupportsOrdinalsInCh
 
 ////////// lazy row creation and destruction
 
 void
 nsListBoxBodyFrame::CreateRows()
 {
   // Get our client rect.
   nsRect clientRect;
-  GetClientRect(clientRect);
+  GetXULClientRect(clientRect);
 
   // Get the starting y position and the remaining available
   // height.
   nscoord availableHeight = GetAvailableHeight();
   
   if (availableHeight <= 0) {
     bool fixed = (GetFixedRowSize() != -1);
     if (fixed)
diff --git a/layout/xul/nsListBoxLayout.cpp b/layout/xul/nsListBoxLayout.cpp
--- a/layout/xul/nsListBoxLayout.cpp
+++ b/layout/xul/nsListBoxLayout.cpp
@@ -115,17 +115,17 @@ nsListBoxLayout::LayoutInternal(nsIFrame
     NS_ERROR("Frame encountered that isn't a listboxbody!");
     return NS_ERROR_FAILURE;
   }
 
   nsMargin margin;
 
   // Get our client rect.
   nsRect clientRect;
-  aBox->GetClientRect(clientRect);
+  aBox->GetXULClientRect(clientRect);
 
   // Get the starting y position and the remaining available
   // height.
   nscoord availableHeight = body->GetAvailableHeight();
   nscoord yOffset = body->GetYPosition();
   
   if (availableHeight <= 0) {
     bool fixed = (body->GetFixedRowSize() != -1);
diff --git a/layout/xul/nsSliderFrame.cpp b/layout/xul/nsSliderFrame.cpp
--- a/layout/xul/nsSliderFrame.cpp
+++ b/layout/xul/nsSliderFrame.cpp
@@ -336,17 +336,17 @@ nsSliderFrame::BuildDisplayListForChildr
 
   if (thumb) {
     nsRect thumbRect(thumb->GetRect());
     nsMargin m;
     thumb->GetXULMargin(m);
     thumbRect.Inflate(m);
 
     nsRect crect;
-    GetClientRect(crect);
+    GetXULClientRect(crect);
 
     if (crect.width < thumbRect.width || crect.height < thumbRect.height)
       return;
 
     // If this scrollbar is the scrollbar of an actively scrolled scroll frame,
     // layerize the scrollbar thumb, wrap it in its own ContainerLayer and
     // attach scrolling information to it.
     // We do this here and not in the thumb's nsBoxFrame::BuildDisplayList so
@@ -405,17 +405,17 @@ nsSliderFrame::DoLayout(nsBoxLayoutState
           SetDebug(aState, true);
       else
           SetDebug(aState, false);
   }
 #endif
 
   // get the content area inside our borders
   nsRect clientRect;
-  GetClientRect(clientRect);
+  GetXULClientRect(clientRect);
 
   // get the scrollbar
   nsIFrame* scrollbarBox = GetScrollbar();
   nsCOMPtr<nsIContent> scrollbar;
   scrollbar = GetContentOfBox(scrollbarBox);
 
   // get the thumb's pref size
   nsSize thumbSize = thumbBox->GetXULPrefSize(aState);
@@ -745,17 +745,17 @@ nsSliderFrame::CurrentPositionChanged()
   // get the thumb's rect
   nsIFrame* thumbFrame = mFrames.FirstChild();
   if (!thumbFrame)
     return; // The thumb may stream in asynchronously via XBL.
 
   nsRect thumbRect = thumbFrame->GetRect();
 
   nsRect clientRect;
-  GetClientRect(clientRect);
+  GetXULClientRect(clientRect);
 
   // figure out the new rect
   nsRect newThumbRect(thumbRect);
 
   bool reverse = mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::dir,
                                          nsGkAtoms::reverse, eCaseMatters);
   nscoord pos = reverse ? (maxPos - curPos) : (curPos - minPos);
 
@@ -815,17 +815,17 @@ static void UpdateAttribute(nsIContent* 
 // Use this function when you want to set the scroll position via the position
 // of the scrollbar thumb, e.g. when dragging the slider. This function scrolls
 // the content in such a way that thumbRect.x/.y becomes aNewThumbPos.
 void
 nsSliderFrame::SetCurrentThumbPosition(nsIContent* aScrollbar, nscoord aNewThumbPos,
                                        bool aIsSmooth, bool aMaySnap)
 {
   nsRect crect;
-  GetClientRect(crect);
+  GetXULClientRect(crect);
   nscoord offset = IsHorizontal() ? crect.x : crect.y;
   int32_t newPos = NSToIntRound((aNewThumbPos - offset) / mRatio);
   
   if (aMaySnap && mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::snap,
                                         nsGkAtoms::_true, eCaseMatters)) {
     // If snap="true", then the slider may only be set to min + (increment * x).
     // Otherwise, the slider may be set to any positive integer.
     int32_t increment = GetIncrement(aScrollbar);
@@ -1279,17 +1279,17 @@ nsSliderFrame::HandlePress(nsPresContext
   mChange = change;
   DragThumb(true);
   // On Linux we want to keep scrolling in the direction indicated by |change|
   // until the mouse is released. On the other platforms we want to stop
   // scrolling as soon as the scrollbar thumb has reached the current mouse
   // position.
 #ifdef MOZ_WIDGET_GTK
   nsRect clientRect;
-  GetClientRect(clientRect);
+  GetXULClientRect(clientRect);
 
   // Set the destination point to the very end of the scrollbar so that
   // scrolling doesn't stop halfway through.
   if (change > 0) {
     mDestinationPoint = nsPoint(clientRect.width, clientRect.height);
   }
   else {
     mDestinationPoint = nsPoint(0, 0);
diff --git a/layout/xul/nsSprocketLayout.cpp b/layout/xul/nsSprocketLayout.cpp
--- a/layout/xul/nsSprocketLayout.cpp
+++ b/layout/xul/nsSprocketLayout.cpp
@@ -185,17 +185,17 @@ nsSprocketLayout::XULLayout(nsIFrame* aB
   nsBoxLayoutState::AutoReflowDepth depth(aState);
   mozilla::AutoStackArena arena;
 
   // ----- figure out our size ----------
   const nsSize originalSize = aBox->GetSize();
 
   // -- make sure we remove our border and padding  ----
   nsRect clientRect;
-  aBox->GetClientRect(clientRect);
+  aBox->GetXULClientRect(clientRect);
 
   // |originalClientRect| represents the rect of the entire box (excluding borders
   // and padding).  We store it here because we're going to use |clientRect| to hold
   // the required size for all our kids.  As an example, consider an hbox with a
   // specified width of 300.  If the kids total only 150 pixels of width, then
   // we have 150 pixels left over.  |clientRect| is going to hold a width of 150 and
   // is going to be adjusted based off the value of the PACK property.  If flexible
   // objects are in the box, then the two rects will match.
@@ -919,17 +919,17 @@ nsSprocketLayout::ComputeChildsNextPosit
 void
 nsSprocketLayout::AlignChildren(nsIFrame* aBox,
                                 nsBoxLayoutState& aState)
 {
   nsFrameState frameState = nsFrameState(0);
   GetFrameState(aBox, frameState);
   bool isHorizontal = (frameState & NS_STATE_IS_HORIZONTAL) != 0;
   nsRect clientRect;
-  aBox->GetClientRect(clientRect);
+  aBox->GetXULClientRect(clientRect);
 
   NS_PRECONDITION(!(frameState & NS_STATE_AUTO_STRETCH),
                   "Only AlignChildren() with non-stretch alignment");
 
   // These are only calculated if needed
   nsIFrame::Halignment halign;
   nsIFrame::Valignment valign;
   nscoord maxAscent;
diff --git a/layout/xul/nsStackLayout.cpp b/layout/xul/nsStackLayout.cpp
--- a/layout/xul/nsStackLayout.cpp
+++ b/layout/xul/nsStackLayout.cpp
@@ -250,17 +250,17 @@ nsStackLayout::GetOffset(nsIFrame* aChil
   return offsetSpecified;
 }
 
 
 NS_IMETHODIMP
 nsStackLayout::XULLayout(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   nsRect clientRect;
-  aBox->GetClientRect(clientRect);
+  aBox->GetXULClientRect(clientRect);
 
   bool grow;
 
   do {
     nsIFrame* child = nsBox::GetChildXULBox(aBox);
     grow = false;
 
     while (child) 
