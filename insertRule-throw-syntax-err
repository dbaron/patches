From: L. David Baron <dbaron@dbaron.org>

Bug 765599:  Make CSS insertRule methods throw SYNTAX_ERR when given an empty rule or more than one rule.  r=bzbarsky

This implements the proposed spec clarification in
http://lists.w3.org/Archives/Public/www-style/2013Feb/0229.html which
makes us compatible with WebKit on the insertRule tests in this patch.

I confirmed that the test reports 7 failures without the patch, but
passes with the patch.  (I'm a little disturbed by the way our
testharness.js integration elides runs of successive passes.)

diff --git a/dom/locales/en-US/chrome/layout/css.properties b/dom/locales/en-US/chrome/layout/css.properties
--- a/dom/locales/en-US/chrome/layout/css.properties
+++ b/dom/locales/en-US/chrome/layout/css.properties
@@ -9,16 +9,17 @@ UseOfGetPropertyCSSValueWarning=Use of g
 
 PEUnexpEOF2=Unexpected end of file while searching for %1$S.
 PEParseRuleWSOnly=Whitespace-only string given to be parsed as rule.
 PEDeclDropped=Declaration dropped.
 PEDeclSkipped=Skipped to next declaration.
 PEUnknownProperty=Unknown property '%1$S'.
 PEValueParsingError=Error in parsing value for '%1$S'.
 PEExpectEndValue=Expected end of value but found '%1$S'.
+PERuleTrailing=Expected end of rule but found '%1$S'.
 PESkipAtRuleEOF2=end of at-rule
 PEUnknownAtRule=Unrecognized at-rule or error parsing at-rule '%1$S'.
 PECharsetRuleEOF=charset string in @charset rule
 PECharsetRuleNotString=Expected charset string but found '%1$S'.
 PEGatherMediaEOF=end of media list in @import or @media rule
 PEGatherMediaNotComma=Expected ',' in media list but found '%1$S'.
 PEGatherMediaNotIdent=Expected identifier in media list but found '%1$S'.
 PEImportNotURI=Expected URI in @import rule but found '%1$S'.
diff --git a/layout/style/GroupRule.h b/layout/style/GroupRule.h
--- a/layout/style/GroupRule.h
+++ b/layout/style/GroupRule.h
@@ -56,18 +56,17 @@ public:
   bool EnumerateRulesForwards(RuleEnumFunc aFunc, void * aData) const;
 
   /*
    * The next three methods should never be called unless you have first
    * called WillDirty() on the parent stylesheet.  After they are
    * called, DidDirty() needs to be called on the sheet.
    */
   nsresult DeleteStyleRuleAt(uint32_t aIndex);
-  nsresult InsertStyleRulesAt(uint32_t aIndex,
-                              nsCOMArray<Rule>& aRules);
+  nsresult InsertStyleRuleAt(uint32_t aIndex, Rule* aRule);
   nsresult ReplaceStyleRule(Rule *aOld, Rule *aNew);
 
   virtual bool UseForPresentation(nsPresContext* aPresContext,
                                     nsMediaQueryResultCacheKey& aKey) = 0;
 
   NS_MUST_OVERRIDE size_t   // non-virtual -- it is only called by subclasses
     SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf) const;
   virtual size_t
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -144,17 +144,17 @@ nsCSSProps::kParserVariantTable[eCSSProp
 };
 
 //----------------------------------------------------------------------
 
 namespace {
 
 // Rule processing function
 typedef void (* RuleAppendFunc) (css::Rule* aRule, void* aData);
-static void AppendRuleToArray(css::Rule* aRule, void* aArray);
+static void AssignRuleToPointer(css::Rule* aRule, void* aPointer);
 static void AppendRuleToSheet(css::Rule* aRule, void* aParser);
 
 // Your basic top-down recursive descent style parser
 // The exposed methods and members of this class are precisely those
 // needed by nsCSSParser, far below.
 class CSSParserImpl {
 public:
   CSSParserImpl();
@@ -188,17 +188,17 @@ public:
                              nsIPrincipal*     aSheetPrincipal,
                              css::Declaration* aDeclaration,
                              bool*           aChanged);
 
   nsresult ParseRule(const nsAString&        aRule,
                      nsIURI*                 aSheetURL,
                      nsIURI*                 aBaseURL,
                      nsIPrincipal*           aSheetPrincipal,
-                     nsCOMArray<css::Rule>&  aResult);
+                     css::Rule**             aResult);
 
   nsresult ParseProperty(const nsCSSProperty aPropID,
                          const nsAString& aPropValue,
                          nsIURI* aSheetURL,
                          nsIURI* aBaseURL,
                          nsIPrincipal* aSheetPrincipal,
                          css::Declaration* aDeclaration,
                          bool* aChanged,
@@ -789,19 +789,20 @@ protected:
   // All data from successfully parsed properties are placed into |mData|.
   nsCSSExpandedDataBlock mData;
 
 public:
   // Used from nsCSSParser constructors and destructors
   CSSParserImpl* mNextFree;
 };
 
-static void AppendRuleToArray(css::Rule* aRule, void* aArray)
-{
-  static_cast<nsCOMArray<css::Rule>*>(aArray)->AppendObject(aRule);
+static void AssignRuleToPointer(css::Rule* aRule, void* aPointer)
+{
+  css::Rule **pointer = static_cast<css::Rule**>(aPointer);
+  NS_ADDREF(*pointer = aRule);
 }
 
 static void AppendRuleToSheet(css::Rule* aRule, void* aParser)
 {
   CSSParserImpl* parser = (CSSParserImpl*) aParser;
   parser->AppendRule(aRule);
 }
 
@@ -1110,43 +1111,59 @@ CSSParserImpl::ParseDeclarations(const n
   return NS_OK;
 }
 
 nsresult
 CSSParserImpl::ParseRule(const nsAString&        aRule,
                          nsIURI*                 aSheetURI,
                          nsIURI*                 aBaseURI,
                          nsIPrincipal*           aSheetPrincipal,
-                         nsCOMArray<css::Rule>&  aResult)
+                         css::Rule**             aResult)
 {
   NS_PRECONDITION(aSheetPrincipal, "Must have principal here!");
   NS_PRECONDITION(aBaseURI, "need base URI");
 
+  *aResult = nullptr;
+
   nsCSSScanner scanner(aRule, 0);
   css::ErrorReporter reporter(scanner, mSheet, mChildLoader, aSheetURI);
   InitScanner(scanner, reporter, aSheetURI, aBaseURI, aSheetPrincipal);
 
   mSection = eCSSSection_Charset; // callers are responsible for rejecting invalid rules.
 
   nsCSSToken* tk = &mToken;
   // Get first non-whitespace token
+  nsresult rv = NS_OK;
   if (!GetToken(true)) {
     REPORT_UNEXPECTED(PEParseRuleWSOnly);
     OUTPUT_ERROR();
-  } else if (eCSSToken_AtKeyword == tk->mType) {
-    ParseAtRule(AppendRuleToArray, &aResult, false);
-  }
-  else {
-    UngetToken();
-    ParseRuleSet(AppendRuleToArray, &aResult);
-  }
-  OUTPUT_ERROR();
+    rv = NS_ERROR_DOM_SYNTAX_ERR;
+  } else {
+    if (eCSSToken_AtKeyword == tk->mType) {
+      // FIXME: perhaps aInsideBlock should be true when we are?
+      ParseAtRule(AssignRuleToPointer, aResult, false);
+    } else {
+      UngetToken();
+      ParseRuleSet(AssignRuleToPointer, aResult);
+    }
+
+    if (*aResult && GetToken(true)) {
+      // garbage after rule
+      REPORT_UNEXPECTED_TOKEN(PERuleTrailing);
+      NS_RELEASE(*aResult);
+    }
+
+    if (!*aResult) {
+      rv = NS_ERROR_DOM_SYNTAX_ERR;
+      OUTPUT_ERROR();
+    }
+  }
+
   ReleaseScanner();
-  // XXX check for low-level errors
-  return NS_OK;
+  return rv;
 }
 
 // See Bug 723197
 #ifdef _MSC_VER
 #pragma optimize( "", off )
 #endif
 nsresult
 CSSParserImpl::ParseProperty(const nsCSSProperty aPropID,
@@ -10354,17 +10371,17 @@ nsCSSParser::ParseDeclarations(const nsA
                       aDeclaration, aChanged);
 }
 
 nsresult
 nsCSSParser::ParseRule(const nsAString&        aRule,
                        nsIURI*                 aSheetURI,
                        nsIURI*                 aBaseURI,
                        nsIPrincipal*           aSheetPrincipal,
-                       nsCOMArray<css::Rule>&  aResult)
+                       css::Rule**             aResult)
 {
   return static_cast<CSSParserImpl*>(mImpl)->
     ParseRule(aRule, aSheetURI, aBaseURI, aSheetPrincipal, aResult);
 }
 
 nsresult
 nsCSSParser::ParseProperty(const nsCSSProperty aPropID,
                            const nsAString&    aPropValue,
diff --git a/layout/style/nsCSSParser.h b/layout/style/nsCSSParser.h
--- a/layout/style/nsCSSParser.h
+++ b/layout/style/nsCSSParser.h
@@ -103,17 +103,17 @@ public:
                              nsIPrincipal*     aSheetPrincipal,
                              mozilla::css::Declaration* aDeclaration,
                              bool*           aChanged);
 
   nsresult ParseRule(const nsAString&        aRule,
                      nsIURI*                 aSheetURL,
                      nsIURI*                 aBaseURL,
                      nsIPrincipal*           aSheetPrincipal,
-                     nsCOMArray<mozilla::css::Rule>& aResult);
+                     mozilla::css::Rule**    aResult);
 
   // Parse the value of a single CSS property, and add or replace that
   // property in aDeclaration.
   //
   // SVG "mapped attributes" (which correspond directly to CSS
   // properties) are parsed slightly differently from regular CSS; in
   // particular, units may be omitted from <length>.  The 'aIsSVGMode'
   // argument controls this quirk.  Note that this *only* applies to
diff --git a/layout/style/nsCSSRules.cpp b/layout/style/nsCSSRules.cpp
--- a/layout/style/nsCSSRules.cpp
+++ b/layout/style/nsCSSRules.cpp
@@ -657,39 +657,38 @@ GroupRule::GetStyleRuleAt(int32_t aIndex
 bool
 GroupRule::EnumerateRulesForwards(RuleEnumFunc aFunc, void * aData) const
 {
   return
     const_cast<GroupRule*>(this)->mRules.EnumerateForwards(aFunc, aData);
 }
 
 /*
- * The next two methods (DeleteStyleRuleAt and InsertStyleRulesAt)
+ * The next two methods (DeleteStyleRuleAt and InsertStyleRuleAt)
  * should never be called unless you have first called WillDirty() on
  * the parents stylesheet.  After they are called, DidDirty() needs to
  * be called on the sheet
  */
 nsresult
 GroupRule::DeleteStyleRuleAt(uint32_t aIndex)
 {
   Rule* rule = mRules.SafeObjectAt(aIndex);
   if (rule) {
     rule->SetStyleSheet(nullptr);
     rule->SetParentRule(nullptr);
   }
   return mRules.RemoveObjectAt(aIndex) ? NS_OK : NS_ERROR_ILLEGAL_VALUE;
 }
 
 nsresult
-GroupRule::InsertStyleRulesAt(uint32_t aIndex,
-                              nsCOMArray<Rule>& aRules)
+GroupRule::InsertStyleRuleAt(uint32_t aIndex, Rule* aRule)
 {
-  aRules.EnumerateForwards(SetStyleSheetReference, GetStyleSheet());
-  aRules.EnumerateForwards(SetParentRuleReference, this);
-  if (! mRules.InsertObjectsAt(aRules, aIndex)) {
+  aRule->SetStyleSheet(GetStyleSheet());
+  aRule->SetParentRule(this);
+  if (! mRules.InsertObjectAt(aRule, aIndex)) {
     return NS_ERROR_FAILURE;
   }
   return NS_OK;
 }
 
 nsresult
 GroupRule::ReplaceStyleRule(Rule* aOld, Rule* aNew)
 {
diff --git a/layout/style/nsCSSStyleSheet.cpp b/layout/style/nsCSSStyleSheet.cpp
--- a/layout/style/nsCSSStyleSheet.cpp
+++ b/layout/style/nsCSSStyleSheet.cpp
@@ -1895,21 +1895,16 @@ nsCSSStyleSheet::InsertRuleInternal(cons
                                     uint32_t aIndex, 
                                     uint32_t* aReturn)
 {
   // No doing this if the sheet is not complete!
   if (!mInner->mComplete) {
     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
   }
 
-  if (aRule.IsEmpty()) {
-    // Nothing to do here
-    return NS_OK;
-  }
-  
   nsresult result;
   result = WillDirty();
   if (NS_FAILED(result))
     return result;
   
   if (aIndex > uint32_t(mInner->mOrderedRules.Count()))
     return NS_ERROR_DOM_INDEX_SIZE_ERR;
   
@@ -1923,106 +1918,90 @@ nsCSSStyleSheet::InsertRuleInternal(cons
     loader = mDocument->CSSLoader();
     NS_ASSERTION(loader, "Document with no CSS loader!");
   }
 
   nsCSSParser css(loader, this);
 
   mozAutoDocUpdate updateBatch(mDocument, UPDATE_STYLE, true);
 
-  nsCOMArray<css::Rule> rules;
+  nsRefPtr<css::Rule> rule;
   result = css.ParseRule(aRule, mInner->mSheetURI, mInner->mBaseURI,
-                         mInner->mPrincipal, rules);
+                         mInner->mPrincipal, getter_AddRefs(rule));
   if (NS_FAILED(result))
     return result;
 
-  int32_t rulecount = rules.Count();
-  if (rulecount == 0) {
-    // Since we know aRule was not an empty string, just throw
-    return NS_ERROR_DOM_SYNTAX_ERR;
-  }
-  
-  // Hierarchy checking.  Just check the first and last rule in the list.
-  
+  // Hierarchy checking.
+  int32_t newType = rule->GetType();
+
   // check that we're not inserting before a charset rule
   css::Rule* nextRule = mInner->mOrderedRules.SafeObjectAt(aIndex);
   if (nextRule) {
     int32_t nextType = nextRule->GetType();
     if (nextType == css::Rule::CHARSET_RULE) {
       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
     }
 
-    // check last rule in list
-    css::Rule* lastRule = rules.ObjectAt(rulecount - 1);
-    int32_t lastType = lastRule->GetType();
-
     if (nextType == css::Rule::IMPORT_RULE &&
-        lastType != css::Rule::CHARSET_RULE &&
-        lastType != css::Rule::IMPORT_RULE) {
+        newType != css::Rule::CHARSET_RULE &&
+        newType != css::Rule::IMPORT_RULE) {
       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
     }
-    
+
     if (nextType == css::Rule::NAMESPACE_RULE &&
-        lastType != css::Rule::CHARSET_RULE &&
-        lastType != css::Rule::IMPORT_RULE &&
-        lastType != css::Rule::NAMESPACE_RULE) {
-      return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
-    } 
-  }
-  
-  // check first rule in list
-  css::Rule* firstRule = rules.ObjectAt(0);
-  int32_t firstType = firstRule->GetType();
-  if (aIndex != 0) {
-    if (firstType == css::Rule::CHARSET_RULE) { // no inserting charset at nonzero position
+        newType != css::Rule::CHARSET_RULE &&
+        newType != css::Rule::IMPORT_RULE &&
+        newType != css::Rule::NAMESPACE_RULE) {
       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
     }
-  
+  }
+
+  if (aIndex != 0) {
+    // no inserting charset at nonzero position
+    if (newType == css::Rule::CHARSET_RULE) {
+      return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
+    }
+
     css::Rule* prevRule = mInner->mOrderedRules.SafeObjectAt(aIndex - 1);
     int32_t prevType = prevRule->GetType();
 
-    if (firstType == css::Rule::IMPORT_RULE &&
+    if (newType == css::Rule::IMPORT_RULE &&
         prevType != css::Rule::CHARSET_RULE &&
         prevType != css::Rule::IMPORT_RULE) {
       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
     }
 
-    if (firstType == css::Rule::NAMESPACE_RULE &&
+    if (newType == css::Rule::NAMESPACE_RULE &&
         prevType != css::Rule::CHARSET_RULE &&
         prevType != css::Rule::IMPORT_RULE &&
         prevType != css::Rule::NAMESPACE_RULE) {
       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
     }
   }
-  
-  bool insertResult = mInner->mOrderedRules.InsertObjectsAt(rules, aIndex);
+
+  bool insertResult = mInner->mOrderedRules.InsertObjectAt(rule, aIndex);
   NS_ENSURE_TRUE(insertResult, NS_ERROR_OUT_OF_MEMORY);
   DidDirty();
 
-  for (int32_t counter = 0; counter < rulecount; counter++) {
-    css::Rule* cssRule = rules.ObjectAt(counter);
-    cssRule->SetStyleSheet(this);
+  rule->SetStyleSheet(this);
 
-    int32_t type = cssRule->GetType();
-    if (type == css::Rule::NAMESPACE_RULE) {
-      // XXXbz does this screw up when inserting a namespace rule before
-      // another namespace rule that binds the same prefix to a different
-      // namespace?
-      result = RegisterNamespaceRule(cssRule);
-      NS_ENSURE_SUCCESS(result, result);
-    }
+  int32_t type = rule->GetType();
+  if (type == css::Rule::NAMESPACE_RULE) {
+    // XXXbz does this screw up when inserting a namespace rule before
+    // another namespace rule that binds the same prefix to a different
+    // namespace?
+    result = RegisterNamespaceRule(rule);
+    NS_ENSURE_SUCCESS(result, result);
+  }
 
-    if (type == css::Rule::IMPORT_RULE && RuleHasPendingChildSheet(cssRule)) {
-      // We don't notify immediately for @import rules, but rather when
-      // the sheet the rule is importing is loaded (see StyleSheetLoaded)
-      continue;
-    }
-    if (mDocument) {
-      mDocument->StyleRuleAdded(this, cssRule);
-    }
+  // We don't notify immediately for @import rules, but rather when
+  // the sheet the rule is importing is loaded (see StyleSheetLoaded)
+  if ((type != css::Rule::IMPORT_RULE || !RuleHasPendingChildSheet(rule)) &&
+      mDocument) {
+    mDocument->StyleRuleAdded(this, rule);
   }
 
   *aReturn = aIndex;
   return NS_OK;
 }
 
 NS_IMETHODIMP    
 nsCSSStyleSheet::DeleteRule(uint32_t aIndex)
@@ -2107,82 +2086,64 @@ nsCSSStyleSheet::InsertRuleIntoGroup(con
 {
   nsresult result;
   NS_ASSERTION(mInner->mComplete, "No inserting into an incomplete sheet!");
   // check that the group actually belongs to this sheet!
   if (this != aGroup->GetStyleSheet()) {
     return NS_ERROR_INVALID_ARG;
   }
 
-  if (aRule.IsEmpty()) {
-    // Nothing to do here
-    return NS_OK;
-  }
-
   // Hold strong ref to the CSSLoader in case the document update
   // kills the document
   nsRefPtr<css::Loader> loader;
   if (mDocument) {
     loader = mDocument->CSSLoader();
     NS_ASSERTION(loader, "Document with no CSS loader!");
   }
 
   nsCSSParser css(loader, this);
 
   // parse and grab the rule
   mozAutoDocUpdate updateBatch(mDocument, UPDATE_STYLE, true);
 
   result = WillDirty();
   NS_ENSURE_SUCCESS(result, result);
 
-  nsCOMArray<css::Rule> rules;
+  nsRefPtr<css::Rule> rule;
   result = css.ParseRule(aRule, mInner->mSheetURI, mInner->mBaseURI,
-                         mInner->mPrincipal, rules);
-  NS_ENSURE_SUCCESS(result, result);
+                         mInner->mPrincipal, getter_AddRefs(rule));
+  if (NS_FAILED(result))
+    return result;
 
-  int32_t rulecount = rules.Count();
-  if (rulecount == 0) {
-    // Since we know aRule was not an empty string, just throw
-    return NS_ERROR_DOM_SYNTAX_ERR;
+  switch (rule->GetType()) {
+    case css::Rule::STYLE_RULE:
+    case css::Rule::MEDIA_RULE:
+    case css::Rule::FONT_FACE_RULE:
+    case css::Rule::PAGE_RULE:
+    case css::Rule::KEYFRAMES_RULE:
+    case css::Rule::DOCUMENT_RULE:
+    case css::Rule::SUPPORTS_RULE:
+      // these types are OK to insert into a group
+      break;
+    case css::Rule::CHARSET_RULE:
+    case css::Rule::IMPORT_RULE:
+    case css::Rule::NAMESPACE_RULE:
+      // these aren't
+      return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
+    default:
+      NS_NOTREACHED("unexpected rule type");
+      return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
   }
 
-  int32_t counter;
-  css::Rule* rule;
-  for (counter = 0; counter < rulecount; counter++) {
-    rule = rules.ObjectAt(counter);
-    switch (rule->GetType()) {
-      case css::Rule::STYLE_RULE:
-      case css::Rule::MEDIA_RULE:
-      case css::Rule::FONT_FACE_RULE:
-      case css::Rule::PAGE_RULE:
-      case css::Rule::KEYFRAMES_RULE:
-      case css::Rule::DOCUMENT_RULE:
-      case css::Rule::SUPPORTS_RULE:
-        // these types are OK to insert into a group
-        break;
-      case css::Rule::CHARSET_RULE:
-      case css::Rule::IMPORT_RULE:
-      case css::Rule::NAMESPACE_RULE:
-        // these aren't
-        return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
-      default:
-        NS_NOTREACHED("unexpected rule type");
-        return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
-    }
-  }
-  
-  result = aGroup->InsertStyleRulesAt(aIndex, rules);
+  result = aGroup->InsertStyleRuleAt(aIndex, rule);
   NS_ENSURE_SUCCESS(result, result);
   DidDirty();
-  for (counter = 0; counter < rulecount; counter++) {
-    rule = rules.ObjectAt(counter);
-  
-    if (mDocument) {
-      mDocument->StyleRuleAdded(this, rule);
-    }
+
+  if (mDocument) {
+    mDocument->StyleRuleAdded(this, rule);
   }
 
   *_retval = aIndex;
   return NS_OK;
 }
 
 nsresult
 nsCSSStyleSheet::ReplaceRuleInGroup(css::GroupRule* aGroup,
diff --git a/layout/style/test/Makefile.in b/layout/style/test/Makefile.in
--- a/layout/style/test/Makefile.in
+++ b/layout/style/test/Makefile.in
@@ -102,16 +102,17 @@ MOCHITEST_FILES =	test_acid3_test46.html
 		test_css_supports.html \
 		test_default_bidi_css.html \
 		test_descriptor_storage.html \
 		test_descriptor_syntax_errors.html \
 		test_dont_use_document_colors.html \
 		test_font_face_parser.html \
 		test_font_family_parsing.html \
 		test_garbage_at_end_of_declarations.html \
+		test_group_insertRule.html \
 		test_html_attribute_computed_values.html \
 		test_ident_escaping.html \
 		test_inherit_computation.html \
 		test_inherit_storage.html \
 		test_initial_computation.html \
 		test_initial_storage.html \
 		test_keyframes_rules.html \
 		test_media_queries.html \
diff --git a/layout/style/test/test_group_insertRule.html b/layout/style/test/test_group_insertRule.html
new file mode 100644
--- /dev/null
+++ b/layout/style/test/test_group_insertRule.html
@@ -0,0 +1,243 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>CSS Variables Allowed Syntax</title>
+  <link rel="author" title="L. David Baron" href="http://dbaron.org/">
+  <link rel="author" title="Mozilla Corporation" href="http://mozilla.com/" />
+  <link rel="help" href="http://www.w3.org/TR/css3-conditional/#the-cssgroupingrule-interface">
+  <meta name="assert" content="requirements in definition of insertRule">
+  <script src="/resources/testharness.js"></script>
+  <script src="/resources/testharnessreport.js"></script>
+<style id="style">
+@media print {}
+</style>
+<script id="metadata_cache">/*
+{
+  "rule_type": {},
+  "rule_length": {},
+  "insert_import_throws": {},
+  "insert_index_throws1": {},
+  "insert_index_throws2": {},
+  "insert_media_succeed": {},
+  "insert_style_succeed": {},
+  "insert_bad_media_throw": {},
+  "insert_empty_throw": {},
+  "insert_garbage_after_media_throw": {},
+  "insert_garbage_after_style_throw": {},
+  "insert_two_media_throw": {},
+  "insert_style_media_throw": {},
+  "insert_media_style_throw": {},
+  "insert_two_style_throw": {},
+  "insert_retval": {}
+}
+*/</script>
+</head>
+<body onload="run()">
+<div id=log></div>
+<div id="test"></div>
+<script>
+
+  var sheet = document.getElementById("style").sheet;
+
+  var grouping_rule = sheet.cssRules[0];
+
+  test(function() {
+         assert_equals(grouping_rule.type, CSSRule.MEDIA_RULE,
+                       "Rule type of @media rule");
+       },
+       "rule_type");
+
+  test(function() {
+         assert_equals(grouping_rule.cssRules.length, 0,
+                       "Starting cssRules.length of @media rule");
+       },
+       "rule_length");
+
+  test(function() {
+         assert_throws("HIERARCHY_REQUEST_ERR",
+                       function() {
+                         grouping_rule.insertRule("@import url(foo.css);", 0);
+                       },
+                       "inserting a disallowed rule should throw HIERARCHY_REQUEST_ERR");
+       },
+       "insert_import_throws");
+
+  test(function() {
+         assert_throws("INDEX_SIZE_ERR",
+                       function() {
+                         grouping_rule.insertRule("p { color: green }", 1);
+                       },
+                       "inserting at a bad index throws INDEX_SIZE_ERR");
+       },
+       "insert_index_throws1");
+  test(function() {
+         grouping_rule.insertRule("p { color: green }", 0);
+         assert_equals(grouping_rule.cssRules.length, 1,
+                       "Modified cssRules.length of @media rule");
+         grouping_rule.insertRule("p { color: blue }", 1);
+         assert_equals(grouping_rule.cssRules.length, 2,
+                       "Modified cssRules.length of @media rule");
+         grouping_rule.insertRule("p { color: aqua }", 1);
+         assert_equals(grouping_rule.cssRules.length, 3,
+                       "Modified cssRules.length of @media rule");
+         assert_throws("INDEX_SIZE_ERR",
+                       function() {
+                         grouping_rule.insertRule("p { color: green }", 4);
+                       },
+                       "inserting at a bad index throws INDEX_SIZE_ERR");
+         assert_equals(grouping_rule.cssRules.length, 3,
+                       "Modified cssRules.length of @media rule");
+       },
+       "insert_index_throws2");
+
+  test(function() {
+         while (grouping_rule.cssRules.length > 0) {
+           grouping_rule.deleteRule(0);
+         }
+         grouping_rule.insertRule("@media print {}", 0);
+         assert_equals(grouping_rule.cssRules.length, 1,
+                       "Modified cssRules.length of @media rule");
+         assert_equals(grouping_rule.cssRules[0].type, CSSRule.MEDIA_RULE,
+                       "inserting syntactically correct media rule succeeds");
+       },
+       "insert_media_succeed");
+  test(function() {
+         while (grouping_rule.cssRules.length > 0) {
+           grouping_rule.deleteRule(0);
+         }
+         grouping_rule.insertRule("p { color: yellow }", 0);
+         assert_equals(grouping_rule.cssRules.length, 1,
+                       "Modified cssRules.length of @media rule");
+         assert_equals(grouping_rule.cssRules[0].type, CSSRule.STYLE_RULE,
+                       "inserting syntactically correct style rule succeeds");
+       },
+       "insert_style_succeed");
+  test(function() {
+         while (grouping_rule.cssRules.length > 0) {
+           grouping_rule.deleteRule(0);
+         }
+         assert_throws("SYNTAX_ERR",
+                       function() {
+                         grouping_rule.insertRule("@media bad syntax;", 0);
+                       },
+                       "inserting syntactically invalid rule throws syntax error");
+         assert_equals(grouping_rule.cssRules.length, 0,
+                       "Modified cssRules.length of @media rule");
+       },
+       "insert_bad_media_throw");
+  test(function() {
+         while (grouping_rule.cssRules.length > 0) {
+           grouping_rule.deleteRule(0);
+         }
+         assert_throws("SYNTAX_ERR",
+                       function() {
+                         grouping_rule.insertRule("", 0);
+                       },
+                       "inserting empty rule throws syntax error");
+         assert_equals(grouping_rule.cssRules.length, 0,
+                       "Modified cssRules.length of @media rule");
+       },
+       "insert_empty_throw");
+  test(function() {
+         while (grouping_rule.cssRules.length > 0) {
+           grouping_rule.deleteRule(0);
+         }
+         assert_throws("SYNTAX_ERR",
+                       function() {
+                         grouping_rule.insertRule("@media print {} foo", 0);
+                       },
+                       "inserting rule with garbage afterwards throws syntax error");
+         assert_equals(grouping_rule.cssRules.length, 0,
+                       "Modified cssRules.length of @media rule");
+       },
+       "insert_garbage_after_media_throw");
+  test(function() {
+         while (grouping_rule.cssRules.length > 0) {
+           grouping_rule.deleteRule(0);
+         }
+         assert_throws("SYNTAX_ERR",
+                       function() {
+                         grouping_rule.insertRule("p { color: yellow } foo", 0);
+                       },
+                       "inserting rule with garbage afterwards throws syntax error");
+         assert_equals(grouping_rule.cssRules.length, 0,
+                       "Modified cssRules.length of @media rule");
+       },
+       "insert_garbage_after_style_throw");
+  test(function() {
+         while (grouping_rule.cssRules.length > 0) {
+           grouping_rule.deleteRule(0);
+         }
+         assert_throws("SYNTAX_ERR",
+                       function() {
+                         grouping_rule.insertRule("@media print {} @media print {}", 0);
+                       },
+                       "inserting multiple rules throws syntax error");
+         assert_equals(grouping_rule.cssRules.length, 0,
+                       "Modified cssRules.length of @media rule");
+       },
+       "insert_two_media_throw");
+  test(function() {
+         while (grouping_rule.cssRules.length > 0) {
+           grouping_rule.deleteRule(0);
+         }
+         assert_throws("SYNTAX_ERR",
+                       function() {
+                         grouping_rule.insertRule("p { color: yellow } @media print {}", 0);
+                       },
+                       "inserting multiple rules throws syntax error");
+         assert_equals(grouping_rule.cssRules.length, 0,
+                       "Modified cssRules.length of @media rule");
+       },
+       "insert_style_media_throw");
+  test(function() {
+         while (grouping_rule.cssRules.length > 0) {
+           grouping_rule.deleteRule(0);
+         }
+         assert_throws("SYNTAX_ERR",
+                       function() {
+                         grouping_rule.insertRule("@media print {} p { color: yellow }", 0);
+                       },
+                       "inserting multiple rules throws syntax error");
+         assert_equals(grouping_rule.cssRules.length, 0,
+                       "Modified cssRules.length of @media rule");
+       },
+       "insert_media_style_throw");
+  test(function() {
+         while (grouping_rule.cssRules.length > 0) {
+           grouping_rule.deleteRule(0);
+         }
+         assert_throws("SYNTAX_ERR",
+                       function() {
+                         grouping_rule.insertRule("p { color: yellow } p { color: yellow }", 0);
+                       },
+                       "inserting multiple rules throws syntax error");
+         assert_equals(grouping_rule.cssRules.length, 0,
+                       "Modified cssRules.length of @media rule");
+       },
+       "insert_two_style_throw");
+
+  test(function() {
+         while (grouping_rule.cssRules.length > 0) {
+           grouping_rule.deleteRule(0);
+         }
+         var res = grouping_rule.insertRule("p { color: green }", 0);
+         assert_equals(res, 0, "return value should be index");
+         assert_equals(grouping_rule.cssRules.length, 1,
+                       "Modified cssRules.length of @media rule");
+         res = grouping_rule.insertRule("p { color: green }", 0);
+         assert_equals(res, 0, "return value should be index");
+         assert_equals(grouping_rule.cssRules.length, 2,
+                       "Modified cssRules.length of @media rule");
+         res = grouping_rule.insertRule("p { color: green }", 2);
+         assert_equals(res, 2, "return value should be index");
+         assert_equals(grouping_rule.cssRules.length, 3,
+                       "Modified cssRules.length of @media rule");
+       },
+       "insert_retval");
+
+
+</script>
+</body>
+</html>
+
