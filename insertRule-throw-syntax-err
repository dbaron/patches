From: L. David Baron <dbaron@dbaron.org>

Bug 765599:  Make CSS insertRule methods throw SYNTAX_ERR when given an empty rule or more than one rule.

diff --git a/dom/locales/en-US/chrome/layout/css.properties b/dom/locales/en-US/chrome/layout/css.properties
--- a/dom/locales/en-US/chrome/layout/css.properties
+++ b/dom/locales/en-US/chrome/layout/css.properties
@@ -9,16 +9,17 @@ UseOfGetPropertyCSSValueWarning=Use of g
 
 PEUnexpEOF2=Unexpected end of file while searching for %1$S.
 PEParseRuleWSOnly=Whitespace-only string given to be parsed as rule.
 PEDeclDropped=Declaration dropped.
 PEDeclSkipped=Skipped to next declaration.
 PEUnknownProperty=Unknown property '%1$S'.
 PEValueParsingError=Error in parsing value for '%1$S'.
 PEExpectEndValue=Expected end of value but found '%1$S'.
+PERuleTrailing=Expected end of rule but found '%1$S'.
 PESkipAtRuleEOF2=end of at-rule
 PEUnknownAtRule=Unrecognized at-rule or error parsing at-rule '%1$S'.
 PECharsetRuleEOF=charset string in @charset rule
 PECharsetRuleNotString=Expected charset string but found '%1$S'.
 PEGatherMediaEOF=end of media list in @import or @media rule
 PEGatherMediaNotComma=Expected ',' in media list but found '%1$S'.
 PEGatherMediaNotIdent=Expected identifier in media list but found '%1$S'.
 PEImportNotURI=Expected URI in @import rule but found '%1$S'.
diff --git a/layout/style/GroupRule.h b/layout/style/GroupRule.h
--- a/layout/style/GroupRule.h
+++ b/layout/style/GroupRule.h
@@ -56,18 +56,17 @@ public:
   bool EnumerateRulesForwards(RuleEnumFunc aFunc, void * aData) const;
 
   /*
    * The next three methods should never be called unless you have first
    * called WillDirty() on the parent stylesheet.  After they are
    * called, DidDirty() needs to be called on the sheet.
    */
   nsresult DeleteStyleRuleAt(uint32_t aIndex);
-  nsresult InsertStyleRulesAt(uint32_t aIndex,
-                              nsCOMArray<Rule>& aRules);
+  nsresult InsertStyleRuleAt(uint32_t aIndex, Rule* aRule);
   nsresult ReplaceStyleRule(Rule *aOld, Rule *aNew);
 
   virtual bool UseForPresentation(nsPresContext* aPresContext,
                                     nsMediaQueryResultCacheKey& aKey) = 0;
 
   NS_MUST_OVERRIDE size_t   // non-virtual -- it is only called by subclasses
     SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf) const;
   virtual size_t
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -144,17 +144,17 @@ nsCSSProps::kParserVariantTable[eCSSProp
 };
 
 //----------------------------------------------------------------------
 
 namespace {
 
 // Rule processing function
 typedef void (* RuleAppendFunc) (css::Rule* aRule, void* aData);
-static void AppendRuleToArray(css::Rule* aRule, void* aArray);
+static void AssignRuleToPointer(css::Rule* aRule, void* aPointer);
 static void AppendRuleToSheet(css::Rule* aRule, void* aParser);
 
 // Your basic top-down recursive descent style parser
 // The exposed methods and members of this class are precisely those
 // needed by nsCSSParser, far below.
 class CSSParserImpl {
 public:
   CSSParserImpl();
@@ -188,17 +188,17 @@ public:
                              nsIPrincipal*     aSheetPrincipal,
                              css::Declaration* aDeclaration,
                              bool*           aChanged);
 
   nsresult ParseRule(const nsAString&        aRule,
                      nsIURI*                 aSheetURL,
                      nsIURI*                 aBaseURL,
                      nsIPrincipal*           aSheetPrincipal,
-                     nsCOMArray<css::Rule>&  aResult);
+                     css::Rule**             aResult);
 
   nsresult ParseProperty(const nsCSSProperty aPropID,
                          const nsAString& aPropValue,
                          nsIURI* aSheetURL,
                          nsIURI* aBaseURL,
                          nsIPrincipal* aSheetPrincipal,
                          css::Declaration* aDeclaration,
                          bool* aChanged,
@@ -789,19 +789,20 @@ protected:
   // All data from successfully parsed properties are placed into |mData|.
   nsCSSExpandedDataBlock mData;
 
 public:
   // Used from nsCSSParser constructors and destructors
   CSSParserImpl* mNextFree;
 };
 
-static void AppendRuleToArray(css::Rule* aRule, void* aArray)
-{
-  static_cast<nsCOMArray<css::Rule>*>(aArray)->AppendObject(aRule);
+static void AssignRuleToPointer(css::Rule* aRule, void* aPointer)
+{
+  css::Rule **pointer = static_cast<css::Rule**>(aPointer);
+  NS_ADDREF(*pointer = Rule);
 }
 
 static void AppendRuleToSheet(css::Rule* aRule, void* aParser)
 {
   CSSParserImpl* parser = (CSSParserImpl*) aParser;
   parser->AppendRule(aRule);
 }
 
@@ -1110,43 +1111,55 @@ CSSParserImpl::ParseDeclarations(const n
   return NS_OK;
 }
 
 nsresult
 CSSParserImpl::ParseRule(const nsAString&        aRule,
                          nsIURI*                 aSheetURI,
                          nsIURI*                 aBaseURI,
                          nsIPrincipal*           aSheetPrincipal,
-                         nsCOMArray<css::Rule>&  aResult)
+                         css::Rule**             aResult)
 {
   NS_PRECONDITION(aSheetPrincipal, "Must have principal here!");
   NS_PRECONDITION(aBaseURI, "need base URI");
 
+  *aResult = nullptr;
+
   nsCSSScanner scanner(aRule, 0);
   css::ErrorReporter reporter(scanner, mSheet, mChildLoader, aSheetURI);
   InitScanner(scanner, reporter, aSheetURI, aBaseURI, aSheetPrincipal);
 
   mSection = eCSSSection_Charset; // callers are responsible for rejecting invalid rules.
 
   nsCSSToken* tk = &mToken;
   // Get first non-whitespace token
+  nsresult rv = NS_OK;
   if (!GetToken(true)) {
     REPORT_UNEXPECTED(PEParseRuleWSOnly);
     OUTPUT_ERROR();
-  } else if (eCSSToken_AtKeyword == tk->mType) {
-    ParseAtRule(AppendRuleToArray, &aResult, false);
-  }
-  else {
-    UngetToken();
-    ParseRuleSet(AppendRuleToArray, &aResult);
-  }
-  OUTPUT_ERROR();
+    rv = NS_ERROR_DOM_SYNTAX_ERR;
+  } else {
+    if (eCSSToken_AtKeyword == tk->mType) {
+      // FIXME: perhaps aInsideBlock should be true when we are?
+      ParseAtRule(AssignRuleToPointer, aResult, false);
+    } else {
+      UngetToken();
+      ParseRuleSet(AssignRuleToPointer, aResult);
+    }
+
+    if (!*aResult || GetToken(true)) {
+      // garbage after rule
+      REPORT_UNEXPECTED_TOKEN(PERuleTrailing);
+      rv = NS_ERROR_DOM_SYNTAX_ERR;
+      OUTPUT_ERROR();
+    }
+  }
+
   ReleaseScanner();
-  // XXX check for low-level errors
-  return NS_OK;
+  return rv;
 }
 
 // See Bug 723197
 #ifdef _MSC_VER
 #pragma optimize( "", off )
 #endif
 nsresult
 CSSParserImpl::ParseProperty(const nsCSSProperty aPropID,
@@ -10354,17 +10367,17 @@ nsCSSParser::ParseDeclarations(const nsA
                       aDeclaration, aChanged);
 }
 
 nsresult
 nsCSSParser::ParseRule(const nsAString&        aRule,
                        nsIURI*                 aSheetURI,
                        nsIURI*                 aBaseURI,
                        nsIPrincipal*           aSheetPrincipal,
-                       nsCOMArray<css::Rule>&  aResult)
+                       css::Rule**             aResult)
 {
   return static_cast<CSSParserImpl*>(mImpl)->
     ParseRule(aRule, aSheetURI, aBaseURI, aSheetPrincipal, aResult);
 }
 
 nsresult
 nsCSSParser::ParseProperty(const nsCSSProperty aPropID,
                            const nsAString&    aPropValue,
diff --git a/layout/style/nsCSSParser.h b/layout/style/nsCSSParser.h
--- a/layout/style/nsCSSParser.h
+++ b/layout/style/nsCSSParser.h
@@ -103,17 +103,17 @@ public:
                              nsIPrincipal*     aSheetPrincipal,
                              mozilla::css::Declaration* aDeclaration,
                              bool*           aChanged);
 
   nsresult ParseRule(const nsAString&        aRule,
                      nsIURI*                 aSheetURL,
                      nsIURI*                 aBaseURL,
                      nsIPrincipal*           aSheetPrincipal,
-                     nsCOMArray<mozilla::css::Rule>& aResult);
+                     mozilla::css::Rule**    aResult);
 
   // Parse the value of a single CSS property, and add or replace that
   // property in aDeclaration.
   //
   // SVG "mapped attributes" (which correspond directly to CSS
   // properties) are parsed slightly differently from regular CSS; in
   // particular, units may be omitted from <length>.  The 'aIsSVGMode'
   // argument controls this quirk.  Note that this *only* applies to
diff --git a/layout/style/nsCSSRules.cpp b/layout/style/nsCSSRules.cpp
--- a/layout/style/nsCSSRules.cpp
+++ b/layout/style/nsCSSRules.cpp
@@ -657,39 +657,38 @@ GroupRule::GetStyleRuleAt(int32_t aIndex
 bool
 GroupRule::EnumerateRulesForwards(RuleEnumFunc aFunc, void * aData) const
 {
   return
     const_cast<GroupRule*>(this)->mRules.EnumerateForwards(aFunc, aData);
 }
 
 /*
- * The next two methods (DeleteStyleRuleAt and InsertStyleRulesAt)
+ * The next two methods (DeleteStyleRuleAt and InsertStyleRuleAt)
  * should never be called unless you have first called WillDirty() on
  * the parents stylesheet.  After they are called, DidDirty() needs to
  * be called on the sheet
  */
 nsresult
 GroupRule::DeleteStyleRuleAt(uint32_t aIndex)
 {
   Rule* rule = mRules.SafeObjectAt(aIndex);
   if (rule) {
     rule->SetStyleSheet(nullptr);
     rule->SetParentRule(nullptr);
   }
   return mRules.RemoveObjectAt(aIndex) ? NS_OK : NS_ERROR_ILLEGAL_VALUE;
 }
 
 nsresult
-GroupRule::InsertStyleRulesAt(uint32_t aIndex,
-                              nsCOMArray<Rule>& aRules)
+GroupRule::InsertStyleRuleAt(uint32_t aIndex, Rule* aRule)
 {
-  aRules.EnumerateForwards(SetStyleSheetReference, GetStyleSheet());
-  aRules.EnumerateForwards(SetParentRuleReference, this);
-  if (! mRules.InsertObjectsAt(aRules, aIndex)) {
+  aRule->SetStyleSheet(GetStyleSheet());
+  aRule->SetParentRule(this);
+  if (! mRules.InsertObjectAt(aRule, aIndex)) {
     return NS_ERROR_FAILURE;
   }
   return NS_OK;
 }
 
 nsresult
 GroupRule::ReplaceStyleRule(Rule* aOld, Rule* aNew)
 {
diff --git a/layout/style/nsCSSStyleSheet.cpp b/layout/style/nsCSSStyleSheet.cpp
--- a/layout/style/nsCSSStyleSheet.cpp
+++ b/layout/style/nsCSSStyleSheet.cpp
@@ -1897,17 +1897,17 @@ nsCSSStyleSheet::InsertRuleInternal(cons
 {
   // No doing this if the sheet is not complete!
   if (!mInner->mComplete) {
     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
   }
 
   if (aRule.IsEmpty()) {
     // Nothing to do here
-    return NS_OK;
+    return NS_ERROR_DOM_SYNTAX_ERR;
   }
   
   nsresult result;
   result = WillDirty();
   if (NS_FAILED(result))
     return result;
   
   if (aIndex > uint32_t(mInner->mOrderedRules.Count()))
@@ -1923,106 +1923,92 @@ nsCSSStyleSheet::InsertRuleInternal(cons
     loader = mDocument->CSSLoader();
     NS_ASSERTION(loader, "Document with no CSS loader!");
   }
 
   nsCSSParser css(loader, this);
 
   mozAutoDocUpdate updateBatch(mDocument, UPDATE_STYLE, true);
 
-  nsCOMArray<css::Rule> rules;
+  nsRefPtr<css::Rule> rule;
   result = css.ParseRule(aRule, mInner->mSheetURI, mInner->mBaseURI,
-                         mInner->mPrincipal, rules);
+                         mInner->mPrincipal, getter_AddRefs(rule));
   if (NS_FAILED(result))
     return result;
 
-  int32_t rulecount = rules.Count();
-  if (rulecount == 0) {
-    // Since we know aRule was not an empty string, just throw
-    return NS_ERROR_DOM_SYNTAX_ERR;
-  }
-  
-  // Hierarchy checking.  Just check the first and last rule in the list.
-  
+  // Hierarchy checking.
+  int32_t newType = rule->GetType();
+
   // check that we're not inserting before a charset rule
   css::Rule* nextRule = mInner->mOrderedRules.SafeObjectAt(aIndex);
   if (nextRule) {
     int32_t nextType = nextRule->GetType();
     if (nextType == css::Rule::CHARSET_RULE) {
       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
     }
 
-    // check last rule in list
-    css::Rule* lastRule = rules.ObjectAt(rulecount - 1);
-    int32_t lastType = lastRule->GetType();
-
     if (nextType == css::Rule::IMPORT_RULE &&
-        lastType != css::Rule::CHARSET_RULE &&
-        lastType != css::Rule::IMPORT_RULE) {
+        newType != css::Rule::CHARSET_RULE &&
+        newType != css::Rule::IMPORT_RULE) {
       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
     }
-    
+
     if (nextType == css::Rule::NAMESPACE_RULE &&
-        lastType != css::Rule::CHARSET_RULE &&
-        lastType != css::Rule::IMPORT_RULE &&
-        lastType != css::Rule::NAMESPACE_RULE) {
-      return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
-    } 
-  }
-  
-  // check first rule in list
-  css::Rule* firstRule = rules.ObjectAt(0);
-  int32_t firstType = firstRule->GetType();
-  if (aIndex != 0) {
-    if (firstType == css::Rule::CHARSET_RULE) { // no inserting charset at nonzero position
+        newType != css::Rule::CHARSET_RULE &&
+        newType != css::Rule::IMPORT_RULE &&
+        newType != css::Rule::NAMESPACE_RULE) {
       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
     }
-  
+  }
+
+  if (aIndex != 0) {
+    // no inserting charset at nonzero position
+    if (newType == css::Rule::CHARSET_RULE) {
+      return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
+    }
+
     css::Rule* prevRule = mInner->mOrderedRules.SafeObjectAt(aIndex - 1);
     int32_t prevType = prevRule->GetType();
 
-    if (firstType == css::Rule::IMPORT_RULE &&
+    if (newType == css::Rule::IMPORT_RULE &&
         prevType != css::Rule::CHARSET_RULE &&
         prevType != css::Rule::IMPORT_RULE) {
       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
     }
 
-    if (firstType == css::Rule::NAMESPACE_RULE &&
+    if (newType == css::Rule::NAMESPACE_RULE &&
         prevType != css::Rule::CHARSET_RULE &&
         prevType != css::Rule::IMPORT_RULE &&
         prevType != css::Rule::NAMESPACE_RULE) {
       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
     }
   }
-  
-  bool insertResult = mInner->mOrderedRules.InsertObjectsAt(rules, aIndex);
+
+  bool insertResult = mInner->mOrderedRules.InsertObjectAt(rule, aIndex);
   NS_ENSURE_TRUE(insertResult, NS_ERROR_OUT_OF_MEMORY);
   DidDirty();
 
-  for (int32_t counter = 0; counter < rulecount; counter++) {
-    css::Rule* cssRule = rules.ObjectAt(counter);
-    cssRule->SetStyleSheet(this);
+  rule->SetStyleSheet(this);
 
-    int32_t type = cssRule->GetType();
-    if (type == css::Rule::NAMESPACE_RULE) {
-      // XXXbz does this screw up when inserting a namespace rule before
-      // another namespace rule that binds the same prefix to a different
-      // namespace?
-      result = RegisterNamespaceRule(cssRule);
-      NS_ENSURE_SUCCESS(result, result);
-    }
+  int32_t type = rule->GetType();
+  if (type == css::Rule::NAMESPACE_RULE) {
+    // XXXbz does this screw up when inserting a namespace rule before
+    // another namespace rule that binds the same prefix to a different
+    // namespace?
+    result = RegisterNamespaceRule(rule);
+    NS_ENSURE_SUCCESS(result, result);
+  }
 
-    if (type == css::Rule::IMPORT_RULE && RuleHasPendingChildSheet(cssRule)) {
-      // We don't notify immediately for @import rules, but rather when
-      // the sheet the rule is importing is loaded (see StyleSheetLoaded)
-      continue;
-    }
-    if (mDocument) {
-      mDocument->StyleRuleAdded(this, cssRule);
-    }
+  if (type == css::Rule::IMPORT_RULE && RuleHasPendingChildSheet(rule)) {
+    // We don't notify immediately for @import rules, but rather when
+    // the sheet the rule is importing is loaded (see StyleSheetLoaded)
+    continue;
+  }
+  if (mDocument) {
+    mDocument->StyleRuleAdded(this, rule);
   }
 
   *aReturn = aIndex;
   return NS_OK;
 }
 
 NS_IMETHODIMP    
 nsCSSStyleSheet::DeleteRule(uint32_t aIndex)
@@ -2109,17 +2095,17 @@ nsCSSStyleSheet::InsertRuleIntoGroup(con
   NS_ASSERTION(mInner->mComplete, "No inserting into an incomplete sheet!");
   // check that the group actually belongs to this sheet!
   if (this != aGroup->GetStyleSheet()) {
     return NS_ERROR_INVALID_ARG;
   }
 
   if (aRule.IsEmpty()) {
     // Nothing to do here
-    return NS_OK;
+    return NS_ERROR_DOM_SYNTAX_ERR;
   }
 
   // Hold strong ref to the CSSLoader in case the document update
   // kills the document
   nsRefPtr<css::Loader> loader;
   if (mDocument) {
     loader = mDocument->CSSLoader();
     NS_ASSERTION(loader, "Document with no CSS loader!");
@@ -2128,61 +2114,48 @@ nsCSSStyleSheet::InsertRuleIntoGroup(con
   nsCSSParser css(loader, this);
 
   // parse and grab the rule
   mozAutoDocUpdate updateBatch(mDocument, UPDATE_STYLE, true);
 
   result = WillDirty();
   NS_ENSURE_SUCCESS(result, result);
 
-  nsCOMArray<css::Rule> rules;
+  nsRefPtr<css::Rule> rule;
   result = css.ParseRule(aRule, mInner->mSheetURI, mInner->mBaseURI,
-                         mInner->mPrincipal, rules);
-  NS_ENSURE_SUCCESS(result, result);
+                         mInner->mPrincipal, getter_AddRefs(rule));
+  if (NS_FAILED(result))
+    return result;
 
-  int32_t rulecount = rules.Count();
-  if (rulecount == 0) {
-    // Since we know aRule was not an empty string, just throw
-    return NS_ERROR_DOM_SYNTAX_ERR;
+  switch (rule->GetType()) {
+    case css::Rule::STYLE_RULE:
+    case css::Rule::MEDIA_RULE:
+    case css::Rule::FONT_FACE_RULE:
+    case css::Rule::PAGE_RULE:
+    case css::Rule::KEYFRAMES_RULE:
+    case css::Rule::DOCUMENT_RULE:
+    case css::Rule::SUPPORTS_RULE:
+      // these types are OK to insert into a group
+      break;
+    case css::Rule::CHARSET_RULE:
+    case css::Rule::IMPORT_RULE:
+    case css::Rule::NAMESPACE_RULE:
+      // these aren't
+      return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
+    default:
+      NS_NOTREACHED("unexpected rule type");
+      return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
   }
 
-  int32_t counter;
-  css::Rule* rule;
-  for (counter = 0; counter < rulecount; counter++) {
-    rule = rules.ObjectAt(counter);
-    switch (rule->GetType()) {
-      case css::Rule::STYLE_RULE:
-      case css::Rule::MEDIA_RULE:
-      case css::Rule::FONT_FACE_RULE:
-      case css::Rule::PAGE_RULE:
-      case css::Rule::KEYFRAMES_RULE:
-      case css::Rule::DOCUMENT_RULE:
-      case css::Rule::SUPPORTS_RULE:
-        // these types are OK to insert into a group
-        break;
-      case css::Rule::CHARSET_RULE:
-      case css::Rule::IMPORT_RULE:
-      case css::Rule::NAMESPACE_RULE:
-        // these aren't
-        return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
-      default:
-        NS_NOTREACHED("unexpected rule type");
-        return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
-    }
-  }
-  
-  result = aGroup->InsertStyleRulesAt(aIndex, rules);
+  result = aGroup->InsertStyleRuleAt(aIndex, rule);
   NS_ENSURE_SUCCESS(result, result);
   DidDirty();
-  for (counter = 0; counter < rulecount; counter++) {
-    rule = rules.ObjectAt(counter);
-  
-    if (mDocument) {
-      mDocument->StyleRuleAdded(this, rule);
-    }
+
+  if (mDocument) {
+    mDocument->StyleRuleAdded(this, rule);
   }
 
   *_retval = aIndex;
   return NS_OK;
 }
 
 nsresult
 nsCSSStyleSheet::ReplaceRuleInGroup(css::GroupRule* aGroup,
