From: L. David Baron <dbaron@dbaron.org>

Bug 1159042 patch 3 - Add NS_FRAME_DYNAMIC_REFLOW_ROOT on frames that we can dynamically make reflow roots.

diff --git a/layout/generic/nsFrameStateBits.h b/layout/generic/nsFrameStateBits.h
--- a/layout/generic/nsFrameStateBits.h
+++ b/layout/generic/nsFrameStateBits.h
@@ -259,16 +259,20 @@ FRAME_STATE_BIT(Generic, 52, NS_FRAME_HA
 
 // Frame is not displayed directly due to it being, or being under, an SVG
 // <defs> element or an SVG resource element (<mask>, <pattern>, etc.)
 FRAME_STATE_BIT(Generic, 53, NS_FRAME_IS_NONDISPLAY)
 
 // Frame has a LayerActivityProperty property
 FRAME_STATE_BIT(Generic, 54, NS_FRAME_HAS_LAYER_ACTIVITY_PROPERTY)
 
+// If this bit is set, then reflow may be dispatched from the current
+// frame instead of the root frame.
+FRAME_STATE_BIT(Generic, 55, NS_FRAME_DYNAMIC_REFLOW_ROOT)
+
 // Frame has VR content, and needs VR display items created
 FRAME_STATE_BIT(Generic, 57, NS_FRAME_HAS_VR_CONTENT)
 
 // Set for all descendants of MathML sub/supscript elements (other than the
 // base frame) to indicate that the SSTY font feature should be used.
 FRAME_STATE_BIT(Generic, 58, NS_FRAME_MATHML_SCRIPT_DESCENDANT)
 
 // This state bit is set on frames within token MathML elements if the
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -391,16 +391,17 @@ nsHTMLReflowState::Init(nsPresContext*  
   LogicalSize cbSize(mWritingMode, -1, -1);
   if (aContainingBlockSize) {
     cbSize = *aContainingBlockSize;
   }
 
   InitConstraints(aPresContext, cbSize, aBorder, aPadding, type);
 
   InitResizeFlags(aPresContext, type);
+  InitDynamicReflowRoot();
 
   nsIFrame *parent = frame->GetParent();
   if (parent &&
       (parent->GetStateBits() & NS_FRAME_IN_CONSTRAINED_BSIZE) &&
       !(parent->GetType() == nsGkAtoms::scrollFrame &&
         parent->StyleDisplay()->mOverflowY != NS_STYLE_OVERFLOW_HIDDEN)) {
     frame->AddStateBits(NS_FRAME_IN_CONSTRAINED_BSIZE);
   } else if (type == nsGkAtoms::svgForeignObjectFrame) {
@@ -754,16 +755,82 @@ nsHTMLReflowState::InitResizeFlags(nsPre
   }
   if (frame->GetStateBits() & NS_FRAME_IS_DIRTY) {
     // If we're reflowing everything, then we'll find out if we need
     // to re-set this.
     frame->RemoveStateBits(NS_FRAME_CONTAINS_RELATIVE_BSIZE);
   }
 }
 
+static inline bool
+IsIntrinsicKeyword(const nsStyleCoord& aCoord)
+{
+  if (aCoord.GetUnit() != eStyleUnit_Enumerated) {
+    return false;
+  }
+
+  // All of the keywords except for 'fill' depend on intrinsic sizes.
+  return aCoord.GetIntValue() != NS_STYLE_WIDTH_AVAILABLE;
+}
+
+void
+nsHTMLReflowState::InitDynamicReflowRoot()
+{
+  auto display = mStyleDisplay->mDisplay;
+  if (frame->IsFrameOfType(nsIFrame::eLineParticipant) ||
+      nsStyleDisplay::IsRubyDisplayType(display) ||
+      mFrameType == NS_CSS_FRAME_TYPE_INTERNAL_TABLE ||
+      display == NS_STYLE_DISPLAY_TABLE ||
+      display == NS_STYLE_DISPLAY_TABLE_CAPTION ||
+      display == NS_STYLE_DISPLAY_INLINE_TABLE ||
+      (frame->GetParent() && frame->GetParent()->IsBoxFrame())) {
+    // We have a display type where 'width' and 'height' don't actually
+    // set the width or height.
+    NS_ASSERTION(!(frame->GetStateBits() & NS_FRAME_DYNAMIC_REFLOW_ROOT),
+                 "should not have dynamic reflow root bit");
+    return;
+  }
+
+  bool canBeDynamicReflowRoot = true;
+
+  // We can't do this if we don't have fixed width and height.
+  // FIXME: For display:block, we should probably optimize inline-size
+  // being auto.
+  // FIXME: Other flex and grid cases?
+  const nsStyleCoord& width = mStylePosition->mWidth;
+  const nsStyleCoord& height = mStylePosition->mHeight;
+  if (!width.IsCoordPercentCalcUnit() ||
+      width.HasPercent() ||
+      !height.IsCoordPercentCalcUnit() ||
+      height.HasPercent() ||
+      IsIntrinsicKeyword(mStylePosition->mMinWidth) ||
+      IsIntrinsicKeyword(mStylePosition->mMaxWidth) ||
+      IsIntrinsicKeyword(mStylePosition->mMinHeight) ||
+      IsIntrinsicKeyword(mStylePosition->mMaxHeight) ||
+      ((mStylePosition->mMinWidth.GetUnit() == eStyleUnit_Auto ||
+        mStylePosition->mMinHeight.GetUnit() == eStyleUnit_Auto) &&
+       frame->IsFlexItem())) {
+    canBeDynamicReflowRoot = false;
+  }
+
+  // If we participate in a container's block reflow context, or margins
+  // can collapse through us, we can't be a dynamic reflow root.
+  if (canBeDynamicReflowRoot &&
+      frame->IsFrameOfType(nsIFrame::eBlockFrame) &&
+      (~frame->GetStateBits() & (NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT))) {
+    canBeDynamicReflowRoot = false;
+  }
+
+  if (canBeDynamicReflowRoot) {
+    frame->AddStateBits(NS_FRAME_DYNAMIC_REFLOW_ROOT);
+  } else {
+    frame->RemoveStateBits(NS_FRAME_DYNAMIC_REFLOW_ROOT);
+  }
+}
+
 nscoord
 nsHTMLReflowState::GetContainingBlockContentISize(WritingMode aWritingMode) const
 {
   if (!mCBReflowState) {
     return 0;
   }
   return mCBReflowState->GetWritingMode().IsOrthogonalTo(aWritingMode)
     ? mCBReflowState->ComputedBSize()
diff --git a/layout/generic/nsHTMLReflowState.h b/layout/generic/nsHTMLReflowState.h
--- a/layout/generic/nsHTMLReflowState.h
+++ b/layout/generic/nsHTMLReflowState.h
@@ -905,16 +905,17 @@ public:
                                        nsHTMLReflowState* aState,
                                        void* aValue);
 #endif
 
 protected:
   void InitFrameType(nsIAtom* aFrameType);
   void InitCBReflowState();
   void InitResizeFlags(nsPresContext* aPresContext, nsIAtom* aFrameType);
+  void InitDynamicReflowRoot();
 
   void InitConstraints(nsPresContext*              aPresContext,
                        const mozilla::LogicalSize& aContainingBlockSize,
                        const nsMargin*             aBorder,
                        const nsMargin*             aPadding,
                        nsIAtom*                    aFrameType);
 
   // Returns the nearest containing block or block frame (whether or not
