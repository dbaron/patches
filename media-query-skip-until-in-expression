Ensure we always skip to the next close parenthesis if a media query expression parse fails.  (Bug 454227)  r+sr=bzbarsky

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -1620,36 +1620,31 @@ CSSParserImpl::ParseMediaQueryExpression
       (expr->mRange != nsMediaExpression::eEqual &&
        feature->mRangeType != nsMediaFeature::eMinMaxAllowed)) {
     REPORT_UNEXPECTED_TOKEN(PEMQExpectedFeatureName);
     SkipUntil(')');
     return PR_FALSE;
   }
   expr->mFeature = feature;
 
-  if (! GetToken(PR_TRUE)) {
-    REPORT_UNEXPECTED_EOF(PEMQExpressionEOF);
-    return PR_FALSE;
-  }
-  if (eCSSToken_Symbol != mToken.mType ||
-      (mToken.mSymbol != PRUnichar(':') && mToken.mSymbol != PRUnichar(')'))) {
-    REPORT_UNEXPECTED_TOKEN(PEMQExpectedFeatureNameEnd);
-    SkipUntil(')');
-    return PR_FALSE;
-  }
-
-  if (mToken.mSymbol == PRUnichar(')')) {
+  if (!GetToken(PR_TRUE) || mToken.IsSymbol(')')) {
     // Query expressions for any feature can be given without a value.
     // However, min/max prefixes are not allowed.
     if (expr->mRange != nsMediaExpression::eEqual) {
       REPORT_UNEXPECTED(PEMQNoMinMaxWithoutValue);
       return PR_FALSE;
     }
     expr->mValue.Reset();
     return PR_TRUE;
+  }
+
+  if (!mToken.IsSymbol(':')) {
+    REPORT_UNEXPECTED_TOKEN(PEMQExpectedFeatureNameEnd);
+    SkipUntil(')');
+    return PR_FALSE;
   }
 
   PRBool rv;
   switch (feature->mValueType) {
     case nsMediaFeature::eLength:
       rv = ParsePositiveVariant(expr->mValue, VARIANT_LENGTH, nsnull);
       break;
     case nsMediaFeature::eInteger:
@@ -1698,22 +1693,23 @@ CSSParserImpl::ParseMediaQueryExpression
         }
       }
       break;
     case nsMediaFeature::eEnumerated:
       rv = ParseVariant(expr->mValue, VARIANT_KEYWORD,
                         feature->mKeywordTable);
       break;
   }
-  if (!rv) {
+  if (!rv || !ExpectSymbol(')', PR_TRUE)) {
     REPORT_UNEXPECTED(PEMQExpectedFeatureValue);
-    return PR_FALSE;
-  }
-
-  return ExpectSymbol(')', PR_TRUE);
+    SkipUntil(')');
+    return PR_FALSE;
+  }
+
+  return PR_TRUE;
 }
 
 // Parse a CSS2 import rule: "@import STRING | URL [medium [, medium]]"
 PRBool
 CSSParserImpl::ParseImportRule(RuleAppendFunc aAppendFunc, void* aData)
 {
   nsCOMPtr<nsMediaList> media = new nsMediaList();
   if (!media) {
diff --git a/layout/style/test/test_media_queries.html b/layout/style/test/test_media_queries.html
--- a/layout/style/test/test_media_queries.html
+++ b/layout/style/test/test_media_queries.html
@@ -404,16 +404,29 @@ function run() {
 
   // Assume we don't support grid devices
   should_not_apply("(grid)");
   should_apply("(grid: 0)");
   should_not_apply("(grid: 1)");
   should_not_apply("(grid: 2)");
   should_not_apply("(grid: -1)");
 
+  // Parsing tests
+  // bug 454227
+  should_apply("(orientation");
+  should_not_apply("not all and (orientation");
+  should_not_apply("(orientation:");
+  should_apply("all,(orientation:");
+  should_not_apply("(orientation:,all");
+  should_apply("not all and (grid");
+  should_not_apply("only all and (grid");
+  should_not_apply("(grid");
+  should_apply("all,(grid");
+  should_not_apply("(grid,all");
+
   SimpleTest.finish();
 }
 
 </script>
 </pre>
 </body>
 </html>
 
