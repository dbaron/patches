From: L. David Baron <dbaron@dbaron.org>

Bug 847286 - Use separate counters on the layer for the transition and animation generation.

TODO: Better names (since this means we now use mAnimationGeneration for
the general and the animation-specific cases

diff --git a/gfx/layers/Layers.cpp b/gfx/layers/Layers.cpp
--- a/gfx/layers/Layers.cpp
+++ b/gfx/layers/Layers.cpp
@@ -174,17 +174,18 @@ Layer::Layer(LayerManager* aManager, voi
   mUseClipRect(false),
   mUseTileSourceRect(false),
   mIsFixedPosition(false),
   mMargins(0, 0, 0, 0),
   mStickyPositionData(nullptr),
   mScrollbarTargetId(FrameMetrics::NULL_SCROLL_ID),
   mScrollbarDirection(ScrollDirection::NONE),
   mDebugColorIndex(0),
-  mAnimationGeneration(0)
+  mAnimationGeneration(0),
+  mTransitionGeneration(0)
 {}
 
 Layer::~Layer()
 {}
 
 Animation*
 Layer::AddAnimation()
 {
diff --git a/gfx/layers/Layers.h b/gfx/layers/Layers.h
--- a/gfx/layers/Layers.h
+++ b/gfx/layers/Layers.h
@@ -1087,16 +1087,18 @@ public:
 
   // Note that all lengths in animation data are either in CSS pixels or app
   // units and must be converted to device pixels by the compositor.
   AnimationArray& GetAnimations() { return mAnimations; }
   InfallibleTArray<AnimData>& GetAnimationData() { return mAnimationData; }
 
   uint64_t GetAnimationGeneration() { return mAnimationGeneration; }
   void SetAnimationGeneration(uint64_t aCount) { mAnimationGeneration = aCount; }
+  uint64_t GetTransitionGeneration() { return mTransitionGeneration; }
+  void SetTransitionGeneration(uint64_t aCount) { mTransitionGeneration = aCount; }
 
   /**
    * Returns the local transform for this layer: either mTransform or,
    * for shadow layers, GetShadowTransform()
    */
   const gfx::Matrix4x4 GetLocalTransform();
 
   /**
@@ -1458,16 +1460,17 @@ protected:
   };
   nsAutoPtr<StickyPositionData> mStickyPositionData;
   FrameMetrics::ViewID mScrollbarTargetId;
   ScrollDirection mScrollbarDirection;
   DebugOnly<uint32_t> mDebugColorIndex;
   // If this layer is used for OMTA, then this counter is used to ensure we
   // stay in sync with the animation manager
   uint64_t mAnimationGeneration;
+  uint64_t mTransitionGeneration;
 };
 
 /**
  * A Layer which we can draw into using Thebes. It is a conceptually
  * infinite surface, but each ThebesLayer has an associated "valid region"
  * of contents that it is currently storing, which is finite. ThebesLayer
  * implementations can store content between paints.
  *
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -478,17 +478,17 @@ nsDisplayListBuilder::AddAnimationsAndTr
                          aFrame->PresContext()->AppUnitsPerDevPixel());
   } else if (aProperty == eCSSProperty_opacity) {
     data = null_t();
   }
 
   if (et) {
     AddAnimationsForProperty(aFrame, aProperty, et->mPropertyTransitions,
                              aLayer, data, pending);
-    aLayer->SetAnimationGeneration(et->mAnimationGeneration);
+    aLayer->SetTransitionGeneration(et->mAnimationGeneration);
   }
 
   if (ea) {
     AddAnimationsForProperty(aFrame, aProperty, ea->mAnimations,
                              aLayer, data, pending);
     aLayer->SetAnimationGeneration(ea->mAnimationGeneration);
   }
 }
diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -397,40 +397,41 @@ CommonElementAnimationData::CanThrottleT
       scrollable->GetLogicalScrollPosition() == nsPoint(0, 0)) {
     return true;
   }
 
   return false;
 }
 
 bool
-CommonElementAnimationData::CanThrottleAnimation(TimeStamp aTime)
+CommonElementAnimationData::CanThrottleAnimation(TimeStamp aTime,
+                                                 bool aForTransitions)
 {
   nsIFrame* frame = nsLayoutUtils::GetStyleFrame(mElement);
   if (!frame) {
     return false;
   }
 
   bool hasTransform = HasAnimationOfProperty(eCSSProperty_transform);
   bool hasOpacity = HasAnimationOfProperty(eCSSProperty_opacity);
   if (hasOpacity) {
     Layer* layer = FrameLayerBuilder::GetDedicatedLayer(
                      frame, nsDisplayItem::TYPE_OPACITY);
-    if (!layer || mAnimationGeneration > layer->GetAnimationGeneration()) {
+    if (!layer || mAnimationGeneration > (aForTransitions ? layer->GetTransitionGeneration() : layer->GetAnimationGeneration())) {
       return false;
     }
   }
 
   if (!hasTransform) {
     return true;
   }
 
   Layer* layer = FrameLayerBuilder::GetDedicatedLayer(
                    frame, nsDisplayItem::TYPE_TRANSFORM);
-  if (!layer || mAnimationGeneration > layer->GetAnimationGeneration()) {
+  if (!layer || mAnimationGeneration > (aForTransitions ? layer->GetTransitionGeneration() : layer->GetAnimationGeneration())) {
     return false;
   }
 
   return CanThrottleTransformChanges(aTime);
 }
 
 void 
 CommonElementAnimationData::UpdateAnimationGeneration(nsPresContext* aPresContext)
diff --git a/layout/style/AnimationCommon.h b/layout/style/AnimationCommon.h
--- a/layout/style/AnimationCommon.h
+++ b/layout/style/AnimationCommon.h
@@ -240,17 +240,17 @@ struct CommonElementAnimationData : publ
   void Destroy()
   {
     // This will call our destructor.
     mElement->DeleteProperty(mElementProperty);
   }
 
   bool CanThrottleTransformChanges(mozilla::TimeStamp aTime);
 
-  bool CanThrottleAnimation(mozilla::TimeStamp aTime);
+  bool CanThrottleAnimation(mozilla::TimeStamp aTime, bool aForTransitions);
 
   enum CanAnimateFlags {
     // Testing for width, height, top, right, bottom, or left.
     CanAnimate_HasGeometricProperty = 1,
     // Allow the case where OMTA is allowed in general, but not for the
     // specified property.
     CanAnimate_AllowPartial = 2
   };
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -1042,17 +1042,17 @@ nsAnimationManager::FlushAnimations(Flus
   TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
   bool didThrottle = false;
   for (PRCList *l = PR_LIST_HEAD(&mElementData); l != &mElementData;
        l = PR_NEXT_LINK(l)) {
     ElementAnimations *ea = static_cast<ElementAnimations*>(l);
     bool canThrottleTick = aFlags == Can_Throttle &&
       ea->CanPerformOnCompositorThread(
         CommonElementAnimationData::CanAnimateFlags(0)) &&
-      ea->CanThrottleAnimation(now);
+      ea->CanThrottleAnimation(now, false);
 
     nsRefPtr<css::AnimValuesStyleRule> oldStyleRule = ea->mStyleRule;
     ea->EnsureStyleRuleFor(now, mPendingEvents, canThrottleTick);
     if (oldStyleRule != ea->mStyleRule) {
       ea->PostRestyleForAnimation(mPresContext);
     } else {
       didThrottle = true;
     }
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -892,17 +892,17 @@ nsTransitionManager::FlushTransitions(Fl
     PRCList *next = PR_LIST_HEAD(&mElementData);
     while (next != &mElementData) {
       ElementTransitions *et = static_cast<ElementTransitions*>(next);
       next = PR_NEXT_LINK(next);
 
       bool canThrottleTick = aFlags == Can_Throttle &&
         et->CanPerformOnCompositorThread(
           CommonElementAnimationData::CanAnimateFlags(0)) &&
-        et->CanThrottleAnimation(now);
+        et->CanThrottleAnimation(now, true);
 
       NS_ABORT_IF_FALSE(et->mElement->GetCurrentDoc() ==
                           mPresContext->Document(),
                         "Element::UnbindFromTree should have "
                         "destroyed the element transitions object");
 
       uint32_t i = et->mPropertyTransitions.Length();
       NS_ABORT_IF_FALSE(i != 0, "empty transitions list?");
