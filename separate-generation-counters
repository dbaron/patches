From: L. David Baron <dbaron@dbaron.org>

Use separate counters on the layer for the transition and animation generation.

TODO: Better names (since this means we now use mAnimationGeneration for
the general and the animation-specific cases

diff --git a/gfx/layers/Layers.cpp b/gfx/layers/Layers.cpp
--- a/gfx/layers/Layers.cpp
+++ b/gfx/layers/Layers.cpp
@@ -316,17 +316,18 @@ Layer::Layer(LayerManager* aManager, voi
   mPostXScale(1.0f),
   mPostYScale(1.0f),
   mOpacity(1.0),
   mContentFlags(0),
   mUseClipRect(false),
   mUseTileSourceRect(false),
   mIsFixedPosition(false),
   mDebugColorIndex(0),
-  mAnimationGeneration(0)
+  mAnimationGeneration(0),
+  mTransitionGeneration(0)
 {}
 
 Layer::~Layer()
 {}
 
 Animation*
 Layer::AddAnimation(TimeStamp aStart, TimeDuration aDuration, float aIterations,
                     int aDirection, nsCSSProperty aProperty, const AnimationData& aData)
diff --git a/gfx/layers/Layers.h b/gfx/layers/Layers.h
--- a/gfx/layers/Layers.h
+++ b/gfx/layers/Layers.h
@@ -823,16 +823,18 @@ public:
   gfxPoint GetFixedPositionAnchor() { return mAnchor; }
   Layer* GetMaskLayer() { return mMaskLayer; }
 
   AnimationArray& GetAnimations() { return mAnimations; }
   InfallibleTArray<AnimData>& GetAnimationData() { return mAnimationData; }
 
   uint64_t GetAnimationGeneration() { return mAnimationGeneration; }
   void SetAnimationGeneration(uint64_t aCount) { mAnimationGeneration = aCount; }
+  uint64_t GetTransitionGeneration() { return mTransitionGeneration; }
+  void SetTransitionGeneration(uint64_t aCount) { mTransitionGeneration = aCount; }
 
   /**
    * DRAWING PHASE ONLY
    *
    * Apply pending changes to layers before drawing them, if those
    * pending changes haven't been overridden by later changes.
    */
   void ApplyPendingUpdatesToSubtree();
@@ -1166,16 +1168,17 @@ protected:
   bool mUseClipRect;
   bool mUseTileSourceRect;
   bool mIsFixedPosition;
   gfxPoint mAnchor;
   DebugOnly<uint32_t> mDebugColorIndex;
   // If this layer is used for OMTA, then this counter is used to ensure we
   // stay in sync with the animation manager
   uint64_t mAnimationGeneration;
+  uint64_t mTransitionGeneration;
 };
 
 /**
  * A Layer which we can draw into using Thebes. It is a conceptually
  * infinite surface, but each ThebesLayer has an associated "valid region"
  * of contents that it is currently storing, which is finite. ThebesLayer
  * implementations can store content between paints.
  * 
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -426,17 +426,17 @@ AddAnimationsAndTransitionsToLayer(Layer
       segment.mToValue = pt->mEndValue;
       segment.mTimingFunction = pt->mTimingFunction;
 
       AddAnimationsForProperty(frame, aProperty, &anim,
                                aLayer, data);
 
       pt->mIsRunningOnCompositor = true;
     }
-    aLayer->SetAnimationGeneration(et->mAnimationGeneration);
+    aLayer->SetTransitionGeneration(et->mAnimationGeneration);
   }
 
   if (ea) {
     for (uint32_t animIdx = 0; animIdx < ea->mAnimations.Length(); animIdx++) {
       ElementAnimation* anim = &ea->mAnimations[animIdx];
       if (!(anim->HasAnimationOfProperty(aProperty) &&
             anim->IsRunningAt(currentTime))) {
         continue;
diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -388,40 +388,41 @@ CommonElementAnimationData::CanThrottleT
       scrollable->GetLogicalScrollPosition() == nsPoint(0, 0)) {
     return true;
   }
 
   return false;
 }
 
 bool
-CommonElementAnimationData::CanThrottleAnimation(TimeStamp aTime)
+CommonElementAnimationData::CanThrottleAnimation(TimeStamp aTime,
+                                                 bool aForTransitions)
 {
   nsIFrame* frame = mElement->GetPrimaryFrame();
   if (!frame) {
     return false;
   }
 
   bool hasTransform = HasAnimationOfProperty(eCSSProperty_transform);
   bool hasOpacity = HasAnimationOfProperty(eCSSProperty_opacity);
   if (hasOpacity) {
     Layer* layer = FrameLayerBuilder::GetDedicatedLayer(
                      frame, nsDisplayItem::TYPE_OPACITY);
-    if (!layer || mAnimationGeneration > layer->GetAnimationGeneration()) {
+    if (!layer || mAnimationGeneration > (aForTransitions ? layer->GetTransitionGeneration() : layer->GetAnimationGeneration())) {
       return false;
     }
   }
 
   if (!hasTransform) {
     return true;
   }
 
   Layer* layer = FrameLayerBuilder::GetDedicatedLayer(
                    frame, nsDisplayItem::TYPE_TRANSFORM);
-  if (!layer || mAnimationGeneration > layer->GetAnimationGeneration()) {
+  if (!layer || mAnimationGeneration > (aForTransitions ? layer->GetTransitionGeneration() : layer->GetAnimationGeneration())) {
     return false;
   }
 
   return CanThrottleTransformChanges(aTime);
 }
 
 void 
 CommonElementAnimationData::UpdateAnimationGeneration(nsPresContext* aPresContext)
diff --git a/layout/style/AnimationCommon.h b/layout/style/AnimationCommon.h
--- a/layout/style/AnimationCommon.h
+++ b/layout/style/AnimationCommon.h
@@ -154,17 +154,17 @@ struct CommonElementAnimationData : publ
   void Destroy()
   {
     // This will call our destructor.
     mElement->DeleteProperty(mElementProperty);
   }
 
   bool CanThrottleTransformChanges(mozilla::TimeStamp aTime);
 
-  bool CanThrottleAnimation(mozilla::TimeStamp aTime);
+  bool CanThrottleAnimation(mozilla::TimeStamp aTime, bool aForTransitions);
 
   enum CanAnimateFlags {
     // Testing for width, height, top, right, bottom, or left.
     CanAnimate_HasGeometricProperty = 1,
     // Allow the case where OMTA is allowed in general, but not for the
     // specified property.
     CanAnimate_AllowPartial = 2
   };
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -1002,17 +1002,17 @@ nsAnimationManager::FlushAnimations(Flus
   TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
   bool didThrottle = false;
   for (PRCList *l = PR_LIST_HEAD(&mElementData); l != &mElementData;
        l = PR_NEXT_LINK(l)) {
     ElementAnimations *ea = static_cast<ElementAnimations*>(l);
     bool canThrottleTick = aFlags == Can_Throttle &&
       ea->CanPerformOnCompositorThread(
         CommonElementAnimationData::CanAnimateFlags(0)) &&
-      ea->CanThrottleAnimation(now);
+      ea->CanThrottleAnimation(now, false);
 
     nsRefPtr<css::AnimValuesStyleRule> oldStyleRule = ea->mStyleRule;
     ea->EnsureStyleRuleFor(now, mPendingEvents, canThrottleTick);
     if (oldStyleRule != ea->mStyleRule) {
       ea->PostRestyleForAnimation(mPresContext);
     } else {
       didThrottle = true;
     }
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -1020,17 +1020,17 @@ nsTransitionManager::FlushTransitions(Fl
     PRCList *next = PR_LIST_HEAD(&mElementData);
     while (next != &mElementData) {
       ElementTransitions *et = static_cast<ElementTransitions*>(next);
       next = PR_NEXT_LINK(next);
 
       bool canThrottleTick = aFlags == Can_Throttle &&
         et->CanPerformOnCompositorThread(
           CommonElementAnimationData::CanAnimateFlags(0)) &&
-        et->CanThrottleAnimation(now);
+        et->CanThrottleAnimation(now, true);
 
       NS_ABORT_IF_FALSE(et->mElement->GetCurrentDoc() ==
                           mPresContext->Document(),
                         "Element::UnbindFromTree should have "
                         "destroyed the element transitions object");
 
       uint32_t i = et->mPropertyTransitions.Length();
       NS_ABORT_IF_FALSE(i != 0, "empty transitions list?");
