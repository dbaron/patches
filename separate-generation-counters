From: L. David Baron <dbaron@dbaron.org>

Bug 847286 - Use separate counters on the layer for the transition and animation generation.

TODO: Better names (since this means we now use mAnimationGeneration for
the general and the animation-specific cases

diff --git a/gfx/layers/Layers.cpp b/gfx/layers/Layers.cpp
--- a/gfx/layers/Layers.cpp
+++ b/gfx/layers/Layers.cpp
@@ -174,17 +174,18 @@ Layer::Layer(LayerManager* aManager, voi
   mUseClipRect(false),
   mUseTileSourceRect(false),
   mIsFixedPosition(false),
   mMargins(0, 0, 0, 0),
   mStickyPositionData(nullptr),
   mScrollbarTargetId(FrameMetrics::NULL_SCROLL_ID),
   mScrollbarDirection(ScrollDirection::NONE),
   mDebugColorIndex(0),
-  mAnimationGeneration(0)
+  mAnimationGeneration(0),
+  mTransitionGeneration(0)
 {}
 
 Layer::~Layer()
 {}
 
 Animation*
 Layer::AddAnimation()
 {
diff --git a/gfx/layers/Layers.h b/gfx/layers/Layers.h
--- a/gfx/layers/Layers.h
+++ b/gfx/layers/Layers.h
@@ -1124,16 +1124,18 @@ public:
 
   // Note that all lengths in animation data are either in CSS pixels or app
   // units and must be converted to device pixels by the compositor.
   AnimationArray& GetAnimations() { return mAnimations; }
   InfallibleTArray<AnimData>& GetAnimationData() { return mAnimationData; }
 
   uint64_t GetAnimationGeneration() { return mAnimationGeneration; }
   void SetAnimationGeneration(uint64_t aCount) { mAnimationGeneration = aCount; }
+  uint64_t GetTransitionGeneration() { return mTransitionGeneration; }
+  void SetTransitionGeneration(uint64_t aCount) { mTransitionGeneration = aCount; }
 
   /**
    * Returns the local transform for this layer: either mTransform or,
    * for shadow layers, GetShadowTransform()
    */
   const gfx::Matrix4x4 GetLocalTransform();
 
   /**
@@ -1494,16 +1496,17 @@ protected:
   };
   nsAutoPtr<StickyPositionData> mStickyPositionData;
   FrameMetrics::ViewID mScrollbarTargetId;
   ScrollDirection mScrollbarDirection;
   DebugOnly<uint32_t> mDebugColorIndex;
   // If this layer is used for OMTA, then this counter is used to ensure we
   // stay in sync with the animation manager
   uint64_t mAnimationGeneration;
+  uint64_t mTransitionGeneration;
 };
 
 /**
  * A Layer which we can draw into using Thebes. It is a conceptually
  * infinite surface, but each ThebesLayer has an associated "valid region"
  * of contents that it is currently storing, which is finite. ThebesLayer
  * implementations can store content between paints.
  *
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -473,17 +473,17 @@ nsDisplayListBuilder::AddAnimationsAndTr
                          aFrame->PresContext()->AppUnitsPerDevPixel());
   } else if (aProperty == eCSSProperty_opacity) {
     data = null_t();
   }
 
   if (transitions) {
     AddAnimationsForProperty(aFrame, aProperty, transitions->mAnimations,
                              aLayer, data, pending);
-    aLayer->SetAnimationGeneration(transitions->mAnimationGeneration);
+    aLayer->SetTransitionGeneration(transitions->mAnimationGeneration);
   }
 
   if (animations) {
     AddAnimationsForProperty(aFrame, aProperty, animations->mAnimations,
                              aLayer, data, pending);
     aLayer->SetAnimationGeneration(animations->mAnimationGeneration);
   }
 }
diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -884,28 +884,28 @@ ElementAnimationCollection::CanThrottleA
     return false;
   }
 
   bool hasTransform = HasAnimationOfProperty(eCSSProperty_transform);
   bool hasOpacity = HasAnimationOfProperty(eCSSProperty_opacity);
   if (hasOpacity) {
     Layer* layer = FrameLayerBuilder::GetDedicatedLayer(
                      frame, nsDisplayItem::TYPE_OPACITY);
-    if (!layer || mAnimationGeneration > layer->GetAnimationGeneration()) {
+    if (!layer || mAnimationGeneration > (IsForTransitions() ? layer->GetTransitionGeneration() : layer->GetAnimationGeneration())) {
       return false;
     }
   }
 
   if (!hasTransform) {
     return true;
   }
 
   Layer* layer = FrameLayerBuilder::GetDedicatedLayer(
                    frame, nsDisplayItem::TYPE_TRANSFORM);
-  if (!layer || mAnimationGeneration > layer->GetAnimationGeneration()) {
+  if (!layer || mAnimationGeneration > (IsForTransitions() ? layer->GetTransitionGeneration() : layer->GetAnimationGeneration())) {
     return false;
   }
 
   return CanThrottleTransformChanges(aTime);
 }
 
 void
 ElementAnimationCollection::UpdateAnimationGeneration(
