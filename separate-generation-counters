From: L. David Baron <dbaron@dbaron.org>

Bug 847286 - Use separate counters on the layer for the transition and animation generation.

TODO: Better names (since this means we now use mAnimationGeneration for
the general and the animation-specific cases

diff --git a/gfx/layers/Layers.cpp b/gfx/layers/Layers.cpp
--- a/gfx/layers/Layers.cpp
+++ b/gfx/layers/Layers.cpp
@@ -204,17 +204,18 @@ Layer::Layer(LayerManager* aManager, voi
   mUseClipRect(false),
   mUseTileSourceRect(false),
   mIsFixedPosition(false),
   mMargins(0, 0, 0, 0),
   mStickyPositionData(nullptr),
   mScrollbarTargetId(FrameMetrics::NULL_SCROLL_ID),
   mScrollbarDirection(ScrollDirection::NONE),
   mDebugColorIndex(0),
-  mAnimationGeneration(0)
+  mAnimationGeneration(0),
+  mTransitionGeneration(0),
 {}
 
 Layer::~Layer()
 {}
 
 Animation*
 Layer::AddAnimation()
 {
diff --git a/gfx/layers/Layers.h b/gfx/layers/Layers.h
--- a/gfx/layers/Layers.h
+++ b/gfx/layers/Layers.h
@@ -1230,16 +1230,18 @@ public:
 
   // Note that all lengths in animation data are either in CSS pixels or app
   // units and must be converted to device pixels by the compositor.
   AnimationArray& GetAnimations() { return mAnimations; }
   InfallibleTArray<AnimData>& GetAnimationData() { return mAnimationData; }
 
   uint64_t GetAnimationGeneration() { return mAnimationGeneration; }
   void SetAnimationGeneration(uint64_t aCount) { mAnimationGeneration = aCount; }
+  uint64_t GetTransitionGeneration() { return mTransitionGeneration; }
+  void SetTransitionGeneration(uint64_t aCount) { mTransitionGeneration = aCount; }
 
   /**
    * Returns the local transform for this layer: either mTransform or,
    * for shadow layers, GetShadowTransform()
    */
   const gfx::Matrix4x4 GetLocalTransform();
 
   /**
@@ -1662,16 +1664,17 @@ protected:
   };
   nsAutoPtr<StickyPositionData> mStickyPositionData;
   FrameMetrics::ViewID mScrollbarTargetId;
   ScrollDirection mScrollbarDirection;
   DebugOnly<uint32_t> mDebugColorIndex;
   // If this layer is used for OMTA, then this counter is used to ensure we
   // stay in sync with the animation manager
   uint64_t mAnimationGeneration;
+  uint64_t mTransitionGeneration;
 #ifdef MOZ_DUMP_PAINTING
   nsTArray<nsCString> mExtraDumpInfo;
 #endif
 };
 
 /**
  * A Layer which we can paint into. It is a conceptually
  * infinite surface, but each PaintedLayer has an associated "valid region"
diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1189,37 +1189,16 @@ RestyleManager::AttributeChanged(Element
                                                          aElement,
                                                          aAttribute,
                                                          aModType,
                                                          true);
 
   PostRestyleEvent(aElement, rshint, hint);
 }
 
-/* static */ uint64_t
-RestyleManager::GetMaxAnimationGenerationForFrame(nsIFrame* aFrame)
-{
-  nsIContent* content = aFrame->GetContent();
-  if (!content || !content->IsElement()) {
-    return 0;
-  }
-
-  nsCSSPseudoElements::Type pseudoType =
-    aFrame->StyleContext()->GetPseudoType();
-  AnimationPlayerCollection* transitions =
-    aFrame->PresContext()->TransitionManager()->GetAnimationPlayers(
-      content->AsElement(), pseudoType, false /* don't create */);
-  AnimationPlayerCollection* animations =
-    aFrame->PresContext()->AnimationManager()->GetAnimationPlayers(
-      content->AsElement(), pseudoType, false /* don't create */);
-
-  return std::max(transitions ? transitions->mAnimationGeneration : 0,
-                  animations ? animations->mAnimationGeneration : 0);
-}
-
 void
 RestyleManager::RestyleForEmptyChange(Element* aContainer)
 {
   // In some cases (:empty + E, :empty ~ E), a change if the content of
   // an element requires restyling its parent's siblings.
   nsRestyleHint hint = eRestyle_Subtree;
   nsIContent* grandparent = aContainer->GetParent();
   if (grandparent &&
@@ -2535,28 +2514,23 @@ ElementRestyler::ElementRestyler(nsPresC
   , mVisibleKidsOfHiddenElement(aVisibleKidsOfHiddenElement)
 #endif
 {
 }
 
 void
 ElementRestyler::AddLayerChangesForAnimation()
 {
-  // Bug 847286 - We should have separate animation generation counters
-  // on layers for transitions and animations and use != comparison below
-  // rather than a > comparison.
-  uint64_t frameGeneration =
-    RestyleManager::GetMaxAnimationGenerationForFrame(mFrame);
-
   nsChangeHint hint = nsChangeHint(0);
   const auto& layerInfo = css::CommonAnimationManager::sLayerAnimationInfo;
   for (size_t i = 0; i < ArrayLength(layerInfo); i++) {
     Layer* layer =
       FrameLayerBuilder::GetDedicatedLayer(mFrame, layerInfo[i].mLayerType);
-    if (layer && frameGeneration > layer->GetAnimationGeneration()) {
+    // FIXME: Pass boolean for transitions vs. animations!
+    if (layer && frameGeneration != layer->GetAnimationGeneration()) {
       // If we have a transform layer but don't have any transform style, we
       // probably just removed the transform but haven't destroyed the layer
       // yet. In this case we will add the appropriate change hint
       // (nsChangeHint_AddOrRemoveTransform) when we compare style contexts
       // so we can skip adding any change hint here. (If we *were* to add
       // nsChangeHint_UpdateTransformLayer, ApplyRenderingChangeToTree would
       // complain that we're updating a transform layer without a transform).
       if (layerInfo[i].mLayerType == nsDisplayItem::TYPE_TRANSFORM &&
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -89,21 +89,16 @@ public:
   // Get an integer that increments every time there is a style change
   // as a result of a change to the :hover content state.
   uint32_t GetHoverGeneration() const { return mHoverGeneration; }
 
   // Get a counter that increments on every style change, that we use to
   // track whether off-main-thread animations are up-to-date.
   uint64_t GetAnimationGeneration() const { return mAnimationGeneration; }
 
-  // A workaround until bug 847286 lands that gets the maximum of the animation
-  // generation counters stored on the set of animations and transitions
-  // respectively for |aFrame|.
-  static uint64_t GetMaxAnimationGenerationForFrame(nsIFrame* aFrame);
-
   // Update the animation generation count to mark that animation state
   // has changed.
   //
   // This is normally performed automatically by ProcessPendingRestyles
   // but it is also called when we have out-of-band changes to animations
   // such as changes made through the Web Animations API.
   void IncrementAnimationGeneration() { ++mAnimationGeneration; }
 
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -437,36 +437,39 @@ nsDisplayListBuilder::AddAnimationsAndTr
   bool pending = !aBuilder;
 
   if (pending) {
     aLayer->ClearAnimationsForNextTransaction();
   } else {
     aLayer->ClearAnimations();
   }
 
+  nsIContent* content = aFrame->GetContent();
+  if (!content) {
+    return;
+  }
+  AnimationPlayerCollection* transitions =
+    nsTransitionManager::GetAnimationsForCompositor(content, aProperty);
+  AnimationPlayerCollection* animations =
+    nsAnimationManager::GetAnimationsForCompositor(content, aProperty);
+
+  if (!animations && !transitions) {
+    return;
+  }
+
   // Update the animation generation on the layer. We need to do this before
   // any early returns since even if we don't add any animations to the
   // layer, we still need to mark it as up-to-date with regards to animations.
   // Otherwise, in RestyleManager we'll notice the discrepancy between the
   // animation generation numbers and update the layer indefinitely.
-  uint64_t animationGeneration =
-    RestyleManager::GetMaxAnimationGenerationForFrame(aFrame);
-  aLayer->SetAnimationGeneration(animationGeneration);
-
-  nsIContent* content = aFrame->GetContent();
-  if (!content) {
-    return;
-  }
-  AnimationPlayerCollection* transitions =
-    nsTransitionManager::GetAnimationsForCompositor(content, aProperty);
-  AnimationPlayerCollection* animations =
-    nsAnimationManager::GetAnimationsForCompositor(content, aProperty);
-
-  if (!animations && !transitions) {
-    return;
+  if (animations) {
+    aLayer->SetAnimationGeneration(animations->mAnimationGeneration);
+  }
+  if (transitions) {
+    aLayer->SetTransitionGeneration(transitions->mAnimationGeneration);
   }
 
   // If the frame is not prerendered, bail out.
   // Do this check only during layer construction; during updating the
   // caller is required to check it appropriately.
   if (aItem && !aItem->CanUseAsyncAnimations(aBuilder)) {
     // AnimationManager or TransitionManager need to know that we refused to
     // run this animation asynchronously so that they will not throttle the
diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -814,17 +814,17 @@ AnimationPlayerCollection::CanThrottleAn
   for (size_t i = 0; i < ArrayLength(info); i++) {
     auto record = info[i];
     if (!HasAnimationOfProperty(record.mProperty)) {
       continue;
     }
 
     Layer* layer = FrameLayerBuilder::GetDedicatedLayer(
                      frame, record.mLayerType);
-    if (!layer || mAnimationGeneration > layer->GetAnimationGeneration()) {
+    if (!layer || mAnimationGeneration != (IsForTransitions() ? layer->GetTransitionGeneration() : layer->GetAnimationGeneration())) {
       return false;
     }
 
     if (record.mProperty == eCSSProperty_transform &&
         !CanThrottleTransformChanges(aTime)) {
       return false;
     }
   }
