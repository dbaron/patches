From: L. David Baron <dbaron@dbaron.org>

Bug 847286:  Use separate counters on the layer for the transition and animation generation.

TODO: Better names (since this means we now use mAnimationGeneration for
the general and the animation-specific cases

diff --git a/gfx/layers/Layers.cpp b/gfx/layers/Layers.cpp
--- a/gfx/layers/Layers.cpp
+++ b/gfx/layers/Layers.cpp
@@ -182,17 +182,18 @@ Layer::Layer(LayerManager* aManager, voi
   mPostYScale(1.0f),
   mOpacity(1.0),
   mContentFlags(0),
   mUseClipRect(false),
   mUseTileSourceRect(false),
   mIsFixedPosition(false),
   mMargins(0, 0, 0, 0),
   mDebugColorIndex(0),
-  mAnimationGeneration(0)
+  mAnimationGeneration(0),
+  mTransitionGeneration(0)
 {}
 
 Layer::~Layer()
 {}
 
 Animation*
 Layer::AddAnimation(TimeStamp aStart, TimeDuration aDuration, float aIterations,
                     int aDirection, nsCSSProperty aProperty, const AnimationData& aData)
diff --git a/gfx/layers/Layers.h b/gfx/layers/Layers.h
--- a/gfx/layers/Layers.h
+++ b/gfx/layers/Layers.h
@@ -932,16 +932,18 @@ public:
 
   // Note that all lengths in animation data are either in CSS pixels or app
   // units and must be converted to device pixels by the compositor.
   AnimationArray& GetAnimations() { return mAnimations; }
   InfallibleTArray<AnimData>& GetAnimationData() { return mAnimationData; }
 
   uint64_t GetAnimationGeneration() { return mAnimationGeneration; }
   void SetAnimationGeneration(uint64_t aCount) { mAnimationGeneration = aCount; }
+  uint64_t GetTransitionGeneration() { return mTransitionGeneration; }
+  void SetTransitionGeneration(uint64_t aCount) { mTransitionGeneration = aCount; }
 
   /**
    * Returns the local transform for this layer: either mTransform or,
    * for shadow layers, GetShadowTransform()
    */
   const gfx3DMatrix GetLocalTransform();
 
   /**
@@ -1282,16 +1284,17 @@ protected:
   bool mUseTileSourceRect;
   bool mIsFixedPosition;
   LayerPoint mAnchor;
   LayerMargin mMargins;
   DebugOnly<uint32_t> mDebugColorIndex;
   // If this layer is used for OMTA, then this counter is used to ensure we
   // stay in sync with the animation manager
   uint64_t mAnimationGeneration;
+  uint64_t mTransitionGeneration;
 };
 
 /**
  * A Layer which we can draw into using Thebes. It is a conceptually
  * infinite surface, but each ThebesLayer has an associated "valid region"
  * of contents that it is currently storing, which is finite. ThebesLayer
  * implementations can store content between paints.
  *
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -436,17 +436,17 @@ AddAnimationsAndTransitionsToLayer(Layer
       segment.mToValue = pt->mEndValue;
       segment.mTimingFunction = pt->mTimingFunction;
 
       AddAnimationsForProperty(frame, aProperty, &anim,
                                aLayer, data);
 
       pt->mIsRunningOnCompositor = true;
     }
-    aLayer->SetAnimationGeneration(et->mAnimationGeneration);
+    aLayer->SetTransitionGeneration(et->mAnimationGeneration);
   }
 
   if (ea) {
     for (uint32_t animIdx = 0; animIdx < ea->mAnimations.Length(); animIdx++) {
       ElementAnimation* anim = &ea->mAnimations[animIdx];
       if (!(anim->HasAnimationOfProperty(aProperty) &&
             anim->IsRunningAt(currentTime))) {
         continue;
diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -344,40 +344,41 @@ CommonElementAnimationData::CanThrottleT
       scrollable->GetLogicalScrollPosition() == nsPoint(0, 0)) {
     return true;
   }
 
   return false;
 }
 
 bool
-CommonElementAnimationData::CanThrottleAnimation(TimeStamp aTime)
+CommonElementAnimationData::CanThrottleAnimation(TimeStamp aTime,
+                                                 bool aForTransitions)
 {
   nsIFrame* frame = nsLayoutUtils::GetStyleFrame(mElement);
   if (!frame) {
     return false;
   }
 
   bool hasTransform = HasAnimationOfProperty(eCSSProperty_transform);
   bool hasOpacity = HasAnimationOfProperty(eCSSProperty_opacity);
   if (hasOpacity) {
     Layer* layer = FrameLayerBuilder::GetDedicatedLayer(
                      frame, nsDisplayItem::TYPE_OPACITY);
-    if (!layer || mAnimationGeneration > layer->GetAnimationGeneration()) {
+    if (!layer || mAnimationGeneration > (aForTransitions ? layer->GetTransitionGeneration() : layer->GetAnimationGeneration())) {
       return false;
     }
   }
 
   if (!hasTransform) {
     return true;
   }
 
   Layer* layer = FrameLayerBuilder::GetDedicatedLayer(
                    frame, nsDisplayItem::TYPE_TRANSFORM);
-  if (!layer || mAnimationGeneration > layer->GetAnimationGeneration()) {
+  if (!layer || mAnimationGeneration > (aForTransitions ? layer->GetTransitionGeneration() : layer->GetAnimationGeneration())) {
     return false;
   }
 
   return CanThrottleTransformChanges(aTime);
 }
 
 void 
 CommonElementAnimationData::UpdateAnimationGeneration(nsPresContext* aPresContext)
diff --git a/layout/style/AnimationCommon.h b/layout/style/AnimationCommon.h
--- a/layout/style/AnimationCommon.h
+++ b/layout/style/AnimationCommon.h
@@ -155,17 +155,17 @@ struct CommonElementAnimationData : publ
   void Destroy()
   {
     // This will call our destructor.
     mElement->DeleteProperty(mElementProperty);
   }
 
   bool CanThrottleTransformChanges(mozilla::TimeStamp aTime);
 
-  bool CanThrottleAnimation(mozilla::TimeStamp aTime);
+  bool CanThrottleAnimation(mozilla::TimeStamp aTime, bool aForTransitions);
 
   enum CanAnimateFlags {
     // Testing for width, height, top, right, bottom, or left.
     CanAnimate_HasGeometricProperty = 1,
     // Allow the case where OMTA is allowed in general, but not for the
     // specified property.
     CanAnimate_AllowPartial = 2
   };
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -1049,17 +1049,17 @@ nsAnimationManager::FlushAnimations(Flus
   TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
   bool didThrottle = false;
   for (PRCList *l = PR_LIST_HEAD(&mElementData); l != &mElementData;
        l = PR_NEXT_LINK(l)) {
     ElementAnimations *ea = static_cast<ElementAnimations*>(l);
     bool canThrottleTick = aFlags == Can_Throttle &&
       ea->CanPerformOnCompositorThread(
         CommonElementAnimationData::CanAnimateFlags(0)) &&
-      ea->CanThrottleAnimation(now);
+      ea->CanThrottleAnimation(now, false);
 
     nsRefPtr<css::AnimValuesStyleRule> oldStyleRule = ea->mStyleRule;
     ea->EnsureStyleRuleFor(now, mPendingEvents, canThrottleTick);
     CheckNeedsRefresh();
     if (oldStyleRule != ea->mStyleRule) {
       ea->PostRestyleForAnimation(mPresContext);
     } else {
       didThrottle = true;
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -1059,17 +1059,17 @@ nsTransitionManager::FlushTransitions(Fl
     PRCList *next = PR_LIST_HEAD(&mElementData);
     while (next != &mElementData) {
       ElementTransitions *et = static_cast<ElementTransitions*>(next);
       next = PR_NEXT_LINK(next);
 
       bool canThrottleTick = aFlags == Can_Throttle &&
         et->CanPerformOnCompositorThread(
           CommonElementAnimationData::CanAnimateFlags(0)) &&
-        et->CanThrottleAnimation(now);
+        et->CanThrottleAnimation(now, true);
 
       NS_ABORT_IF_FALSE(et->mElement->GetCurrentDoc() ==
                           mPresContext->Document(),
                         "Element::UnbindFromTree should have "
                         "destroyed the element transitions object");
 
       uint32_t i = et->mPropertyTransitions.Length();
       NS_ABORT_IF_FALSE(i != 0, "empty transitions list?");
