Make min-/max- prefixed media features without values be parse errors, per http://lists.w3.org/Archives/Public/www-style/2008Sep/0002.html .

diff --git a/dom/locales/en-US/chrome/layout/css.properties b/dom/locales/en-US/chrome/layout/css.properties
--- a/dom/locales/en-US/chrome/layout/css.properties
+++ b/dom/locales/en-US/chrome/layout/css.properties
@@ -128,9 +128,10 @@ PECommentEOF=end of comment
 PECommentEOF=end of comment
 SEUnterminatedString=Found unclosed string '%1$S'.
 PEFontDescExpected=Expected font descriptor but found '%1$S'.
 PEUnknownFontDesc=Unknown descriptor '%1$S' in @font-face rule.
 PEMQExpectedExpressionStart=Expected '(' to start media query expression but found '%1$S'.
 PEMQExpressionEOF=contents of media query expression
 PEMQExpectedFeatureName=Expected media feature name but found '%1$S'.
 PEMQExpectedFeatureNameEnd=Expected ':' or ')' after media feature name but found '%1$S'.
+PEMQNoMinMaxWithoutValue=Media features with min- or max- must have a value.
 PEMQExpectedFeatureValue=Found invalid value for media feature.
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -1671,17 +1671,22 @@ PRBool CSSParserImpl::ParseMediaQueryExp
   if (eCSSToken_Symbol != mToken.mType ||
       (mToken.mSymbol != PRUnichar(':') && mToken.mSymbol != PRUnichar(')'))) {
     REPORT_UNEXPECTED_TOKEN(PEMQExpectedFeatureNameEnd);
     SkipUntil(aErrorCode, ')');
     return PR_FALSE;
   }
 
   if (mToken.mSymbol == PRUnichar(')')) {
-    // All query expressions can be given without a value.
+    // Query expressions for any feature can be given without a value.
+    // However, min/max prefixes are not allowed.
+    if (expr->mRange != nsMediaExpression::eEqual) {
+      REPORT_UNEXPECTED(PEMQNoMinMaxWithoutValue);
+      return PR_FALSE;
+    }
     expr->mValue.Reset();
     return PR_TRUE;
   }
 
   PRBool rv;
   switch (feature->mValueType) {
     case nsMediaFeature::eLength:
       rv = ParsePositiveVariant(aErrorCode, expr->mValue,
diff --git a/layout/style/test/test_media_queries.html b/layout/style/test/test_media_queries.html
--- a/layout/style/test/test_media_queries.html
+++ b/layout/style/test/test_media_queries.html
@@ -134,16 +134,18 @@ function run() {
     expression_should_be_parseable(feature + ": 1px");
     expression_should_be_parseable(feature + ": 0.001mm");
     expression_should_be_parseable(feature + ": 100000px");
     expression_should_not_be_parseable(feature + ": -1px");
     expression_should_not_be_parseable("min-" + feature + ": -1px");
     expression_should_not_be_parseable("max-" + feature + ": -1px");
     expression_should_not_be_parseable(feature + ": -0.00001mm");
     expression_should_not_be_parseable(feature + ": -100000em");
+    expression_should_not_be_parseable("min-" + feature);
+    expression_should_not_be_parseable("max-" + feature);
   }
 
   var content_div = document.getElementById("content");
   content_div.style.font = "-moz-initial";
   var em_size =
     getComputedStyle(content_div, "").fontSize.match(/^(\d+)px$/)[1];
 
   // in this test, assume the common underlying implementation is correct
@@ -279,16 +281,20 @@ function run() {
     expression_should_not_be_parseable(feature + ": 1/1.0");
     expression_should_not_be_parseable(feature + ": 1.0/1.0");
     expression_should_not_be_parseable(feature + ": 0/1");
     expression_should_not_be_parseable(feature + ": 1/0");
     expression_should_not_be_parseable(feature + ": 0/0");
     expression_should_not_be_parseable(feature + ": -1/1");
     expression_should_not_be_parseable(feature + ": 1/-1");
     expression_should_not_be_parseable(feature + ": -1/-1");
+    expression_should_be_parseable("min-" + feature + ": 1/1");
+    expression_should_be_parseable("max-" + feature + ": 1/1");
+    expression_should_not_be_parseable("min-" + feature);
+    expression_should_not_be_parseable("max-" + feature);
   }
 
   var is_monochrome = query_applies("all and (min-monochrome: 1)");
   var is_color = query_applies("all and (min-color: 1)");
   isnot(is_monochrome, is_color, "should be either monochrome or color");
 
   function depth_query(prefix, depth) {
     return "all and (" + prefix + (is_color ? "color" : "monochrome") +
@@ -307,33 +313,25 @@ function run() {
   should_apply(depth_query("", depth));
   should_not_apply(depth_query("", depth - 1));
   should_not_apply(depth_query("", depth + 1));
   should_apply(depth_query("max-", depth));
   should_not_apply(depth_query("max-", depth - 1));
   should_apply(depth_query("max-", depth + 1));
 
   (is_color ? should_apply : should_not_apply)("all and (color)");
-  (is_color ? should_apply : should_not_apply)("all and (max-color)");
-  (is_color ? should_apply : should_not_apply)("all and (min-color)");
+  expression_should_not_be_parseable("max-color");
+  expression_should_not_be_parseable("min-color");
   (is_color ? should_not_apply : should_apply)("all and (monochrome)");
-  (is_color ? should_not_apply : should_apply)("all and (max-monochrome)");
-  (is_color ? should_not_apply : should_apply)("all and (min-monochrome)");
+  expression_should_not_be_parseable("max-monochrome");
+  expression_should_not_be_parseable("min-monochrome");
   (is_color ? should_apply : should_not_apply)("not all and (monochrome)");
-  (is_color ? should_apply : should_not_apply)("not all and (max-monochrome)");
-  (is_color ? should_apply : should_not_apply)("not all and (min-monochrome)");
   (is_color ? should_not_apply : should_apply)("not all and (color)");
-  (is_color ? should_not_apply : should_apply)("not all and (max-color)");
-  (is_color ? should_not_apply : should_apply)("not all and (min-color)");
   (is_color ? should_apply : should_not_apply)("only all and (color)");
-  (is_color ? should_apply : should_not_apply)("only all and (max-color)");
-  (is_color ? should_apply : should_not_apply)("only all and (min-color)");
   (is_color ? should_not_apply : should_apply)("only all and (monochrome)");
-  (is_color ? should_not_apply : should_apply)("only all and (max-monochrome)");
-  (is_color ? should_not_apply : should_apply)("only all and (min-monochrome)");
 
   for each (let feature in [ "color", "min-monochrome", "max-color-index" ]) {
     expression_should_be_parseable(feature + ": 1");
     expression_should_be_parseable(feature + ": 327");
     expression_should_be_parseable(feature + ": 0");
     expression_should_not_be_parseable(feature + ": 1.0");
     expression_should_not_be_parseable(feature + ": -1");
     expression_should_not_be_parseable(feature + ": 1/1");
@@ -401,29 +399,31 @@ function run() {
   should_apply("not all and (min-resolution: " + dpcm_high + "dpcm)");
 
   expression_should_be_parseable("scan");
   expression_should_be_parseable("scan: progressive");
   expression_should_be_parseable("scan:interlace");
   expression_should_not_be_parseable("min-scan:interlace");
   expression_should_not_be_parseable("scan: 1");
   expression_should_not_be_parseable("max-scan");
+  expression_should_not_be_parseable("max-scan: progressive");
   // Assume we don't support tv devices.
   should_not_apply("(scan)");
   should_not_apply("(scan: progressive)");
   should_not_apply("(scan: interlace)");
   should_apply("not all and (scan)");
   should_apply("not all and (scan: progressive)");
   should_apply("not all and (scan: interlace)");
 
   expression_should_be_parseable("grid");
   expression_should_be_parseable("grid: 0");
   expression_should_be_parseable("grid: 1");
   expression_should_be_parseable("grid: 1");
   expression_should_not_be_parseable("min-grid");
+  expression_should_not_be_parseable("min-grid:0");
   expression_should_not_be_parseable("max-grid: 1");
   expression_should_not_be_parseable("grid: 2");
   expression_should_not_be_parseable("grid: -1");
 
   // Assume we don't support grid devices
   should_not_apply("(grid)");
   should_apply("(grid: 0)");
   should_not_apply("(grid: 1)");
