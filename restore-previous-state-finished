From: L. David Baron <dbaron@dbaron.org>

Bug 1150288 - Restore old behavior of mIsPreviousStateFinished into a new variable, since we need it in CanThrottle.  r=birtles

(I don't understand the motivation for the changes to how it was set,
but this just switches to having two variables for the two uses.)

This fixes the test failures in test_animations_omta.html with OMT
animations enabled.

diff --git a/dom/animation/AnimationPlayer.cpp b/dom/animation/AnimationPlayer.cpp
--- a/dom/animation/AnimationPlayer.cpp
+++ b/dom/animation/AnimationPlayer.cpp
@@ -401,17 +401,17 @@ AnimationPlayer::CanThrottle() const
     // Unfinished animations can be throttled.
     return true;
   }
 
   // The animation has finished but, if this is the first sample since
   // finishing, we need an unthrottled sample so we can apply the correct
   // end-of-animation behavior on the main thread (either removing the
   // animation style or applying the fill mode).
-  return mIsPreviousStateFinished;
+  return mFinishedAtLastComposeStyle;
 }
 
 void
 AnimationPlayer::ComposeStyle(nsRefPtr<css::AnimValuesStyleRule>& aStyleRule,
                               nsCSSPropertySet& aSetProperties,
                               bool& aNeedsRefreshes)
 {
   if (!mSource || mSource->IsFinishedTransition()) {
@@ -457,17 +457,19 @@ AnimationPlayer::ComposeStyle(nsRefPtr<c
   // To address each of these cases we temporarily tweak the hold time
   // immediately before updating the style rule and then restore it immediately
   // afterwards. This is purely to prevent visual flicker. Other behavior
   // such as dispatching events continues to rely on the regular timeline time.
   {
     AutoRestore<Nullable<TimeDuration>> restoreHoldTime(mHoldTime);
     bool updatedHoldTime = false;
 
-    if (PlayState() == AnimationPlayState::Pending &&
+    AnimationPlayState playState = PlayState();
+
+    if (playState == AnimationPlayState::Pending &&
         mHoldTime.IsNull() &&
         !mStartTime.IsNull()) {
       Nullable<TimeDuration> timeToUse = mPendingReadyTime;
       if (timeToUse.IsNull() &&
           mTimeline &&
           !mTimeline->IsUnderTestControl()) {
         timeToUse = mTimeline->ToTimelineTime(TimeStamp::Now());
       }
@@ -480,16 +482,18 @@ AnimationPlayer::ComposeStyle(nsRefPtr<c
       }
     }
 
     mSource->ComposeStyle(aStyleRule, aSetProperties);
 
     if (updatedHoldTime) {
       UpdateTiming();
     }
+
+    mFinishedAtLastComposeStyle = (playState == AnimationPlayState::Finished);
   }
 }
 
 void
 AnimationPlayer::DoPlay(LimitBehavior aLimitBehavior)
 {
   bool abortedPause = mPendingState == PendingState::PausePending;
 
diff --git a/dom/animation/AnimationPlayer.h b/dom/animation/AnimationPlayer.h
--- a/dom/animation/AnimationPlayer.h
+++ b/dom/animation/AnimationPlayer.h
@@ -52,16 +52,17 @@ protected:
 
 public:
   explicit AnimationPlayer(AnimationTimeline* aTimeline)
     : mTimeline(aTimeline)
     , mPlaybackRate(1.0)
     , mPendingState(PendingState::NotPending)
     , mIsRunningOnCompositor(false)
     , mIsPreviousStateFinished(false)
+    , mFinishedAtLastComposeStyle(false)
     , mIsRelevant(false)
   {
   }
 
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(AnimationPlayer)
 
   AnimationTimeline* GetParentObject() const { return mTimeline; }
@@ -327,16 +328,17 @@ protected:
   // (see TriggerOnNextTick for details).
   enum class PendingState { NotPending, PlayPending, PausePending };
   PendingState mPendingState;
 
   bool mIsRunningOnCompositor;
   // Indicates whether we were in the finished state during our
   // most recent unthrottled sample (our last ComposeStyle call).
   bool mIsPreviousStateFinished; // Spec calls this "previous finished state"
+  bool mFinishedAtLastComposeStyle;
   // Indicates that the animation should be exposed in an element's
   // getAnimations() list.
   bool mIsRelevant;
 };
 
 } // namespace dom
 } // namespace mozilla
 
