From: L. David Baron <dbaron@dbaron.org>

Implement :-moz-any() selector to allow simplification of user-agent style sheets.  (Bug 544834)  (FIXME: write test for dynamic changes)  (FIXME: figure out what to do about specificity)

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -377,28 +377,32 @@ protected:
   nsSelectorParsingStatus ParsePseudoClassWithIdentArg(nsCSSSelector& aSelector,
                                                        nsIAtom*       aPseudo,
                                                        nsCSSPseudoClasses::Type aType);
 
   nsSelectorParsingStatus ParsePseudoClassWithNthPairArg(nsCSSSelector& aSelector,
                                                          nsIAtom*       aPseudo,
                                                          nsCSSPseudoClasses::Type aType);
 
+  nsSelectorParsingStatus ParsePseudoClassWithSelectorListArg(nsCSSSelector& aSelector,
+                                                              nsIAtom*       aPseudo,
+                                                              nsCSSPseudoClasses::Type aType);
+
   nsSelectorParsingStatus ParseNegatedSimpleSelector(PRInt32&       aDataMask,
                                                      nsCSSSelector& aSelector);
 
   nsSelectorParsingStatus ParseSelector(nsCSSSelector& aSelectorResult,
                                         nsIAtom** aPseudoElement,
                                         nsPseudoClassList** aPseudoElementArgs,
                                         nsCSSPseudoElements::Type* aPseudoElementType);
 
-  // If aTerminateAtBrace is true, the selector list is done when we
-  // hit a '{'.  Otherwise, it's done when we hit EOF.
+  // If aStopChar is non-zero, the selector list is done when we hit
+  // aStopChar.  Otherwise, it's done when we hit EOF.
   PRBool ParseSelectorList(nsCSSSelectorList*& aListHead,
-                           PRBool aTerminateAtBrace);
+                           PRUnichar aStopChar);
   PRBool ParseSelectorGroup(nsCSSSelectorList*& aListHead);
   nsCSSDeclaration* ParseDeclarationBlock(PRBool aCheckForBraces);
   PRBool ParseDeclaration(nsCSSDeclaration* aDeclaration,
                           PRBool aCheckForBraces,
                           PRBool aMustCallValueAppended,
                           PRBool* aChanged);
   // After a parse error parsing |aPropID|, clear the data in
   // |mTempData|.
@@ -1275,17 +1279,17 @@ CSSParserImpl::ParseSelectorString(const
   InitScanner(aSelectorString, aURI, aLineNumber, aURI, nsnull);
 
   AssertInitialState();
 
   // This is the only place that cares about mFoundUnresolvablePrefix,
   // so this is the only place that bothers clearing it.
   mFoundUnresolvablePrefix = PR_FALSE;
 
-  PRBool success = ParseSelectorList(*aSelectorList, PR_FALSE);
+  PRBool success = ParseSelectorList(*aSelectorList, PRUnichar(0));
   PRBool prefixErr = mFoundUnresolvablePrefix;
 
   OUTPUT_ERROR();
   ReleaseScanner();
 
   if (success) {
     NS_ASSERTION(*aSelectorList, "Should have list!");
     return NS_OK;
@@ -2410,17 +2414,17 @@ CSSParserImpl::AppendRule(nsICSSRule* aR
 
 PRBool
 CSSParserImpl::ParseRuleSet(RuleAppendFunc aAppendFunc, void* aData,
                             PRBool aInsideBraces)
 {
   // First get the list of selectors for the rule
   nsCSSSelectorList* slist = nsnull;
   PRUint32 linenum = mScanner.GetLineNumber();
-  if (! ParseSelectorList(slist, PR_TRUE)) {
+  if (! ParseSelectorList(slist, PRUnichar('{'))) {
     REPORT_UNEXPECTED(PEBadSelectorRSIgnored);
     OUTPUT_ERROR();
     SkipRuleSet(aInsideBraces);
     return PR_FALSE;
   }
   NS_ASSERTION(nsnull != slist, "null selector list");
   CLEAR_ERROR();
 
@@ -2451,33 +2455,33 @@ CSSParserImpl::ParseRuleSet(RuleAppendFu
   rule->SetLineNumber(linenum);
   (*aAppendFunc)(rule, aData);
 
   return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseSelectorList(nsCSSSelectorList*& aListHead,
-                                 PRBool aTerminateAtBrace)
+                                 PRUnichar aStopChar)
 {
   nsCSSSelectorList* list = nsnull;
   if (! ParseSelectorGroup(list)) {
     // must have at least one selector group
     aListHead = nsnull;
     return PR_FALSE;
   }
   NS_ASSERTION(nsnull != list, "no selector list");
   aListHead = list;
 
   // After that there must either be a "," or a "{" (the latter if
-  // aTerminateAtBrace is true)
+  // StopChar is nonzero)
   nsCSSToken* tk = &mToken;
   for (;;) {
     if (! GetToken(PR_TRUE)) {
-      if (!aTerminateAtBrace) {
+      if (aStopChar == PRUnichar(0)) {
         return PR_TRUE;
       }
 
       REPORT_UNEXPECTED_EOF(PESelectorListExtraEOF);
       break;
     }
 
     if (eCSSToken_Symbol == tk->mType) {
@@ -2486,17 +2490,17 @@ CSSParserImpl::ParseSelectorList(nsCSSSe
         // Another selector group must follow
         if (! ParseSelectorGroup(newList)) {
           break;
         }
         // add new list to the end of the selector list
         list->mNext = newList;
         list = newList;
         continue;
-      } else if ('{' == tk->mSymbol && aTerminateAtBrace) {
+      } else if (aStopChar == tk->mSymbol && aStopChar != PRUnichar(0)) {
         UngetToken();
         return PR_TRUE;
       }
     }
     REPORT_UNEXPECTED_TOKEN(PESelectorListExtra);
     UngetToken();
     break;
   }
@@ -3125,17 +3129,18 @@ CSSParserImpl::ParsePseudoSelector(PRInt
   // is that of a function pseudo it better be a function token
   if ((eCSSToken_Function == mToken.mType) !=
       (
 #ifdef MOZ_XUL
        isTree ||
 #endif
        nsCSSPseudoClasses::notPseudo == pseudo ||
        nsCSSPseudoClasses::HasStringArg(pseudo) ||
-       nsCSSPseudoClasses::HasNthPairArg(pseudo))) {
+       nsCSSPseudoClasses::HasNthPairArg(pseudo) ||
+       nsCSSPseudoClasses::HasSelectorListArg(pseudo))) {
     // There are no other function pseudos
     REPORT_UNEXPECTED_TOKEN(PEPseudoSelNonFunc);
     UngetToken();
     return eSelectorParsingStatus_Error;
   }
 
   // If it starts with "::", it better be a pseudo-element
   if (parsingPseudoElement &&
@@ -3162,22 +3167,26 @@ CSSParserImpl::ParsePseudoSelector(PRInt
   else if (!parsingPseudoElement && isPseudoClass) {
     aDataMask |= SEL_MASK_PCLASS;
     if (eCSSToken_Function == mToken.mType) {
       nsSelectorParsingStatus parsingStatus;
       if (nsCSSPseudoClasses::HasStringArg(pseudo)) {
         parsingStatus =
           ParsePseudoClassWithIdentArg(aSelector, pseudo, pseudoClassType);
       }
-      else {
-        NS_ABORT_IF_FALSE(nsCSSPseudoClasses::HasNthPairArg(pseudo),
-                          "unexpected pseudo with function token");
+      else if (nsCSSPseudoClasses::HasNthPairArg(pseudo)) {
         parsingStatus =
           ParsePseudoClassWithNthPairArg(aSelector, pseudo, pseudoClassType);
       }
+      else {
+        NS_ABORT_IF_FALSE(nsCSSPseudoClasses::HasSelectorListArg(pseudo),
+                          "unexpected pseudo with function token");
+        parsingStatus = ParsePseudoClassWithSelectorListArg(aSelector, pseudo,
+                                                            pseudoClassType);
+      }
       if (eSelectorParsingStatus_Continue != parsingStatus) {
         if (eSelectorParsingStatus_Error == parsingStatus) {
           SkipUntil(')');
         }
         return parsingStatus;
       }
     }
     else {
@@ -3481,16 +3490,52 @@ CSSParserImpl::ParsePseudoClassWithNthPa
   if (!mToken.IsSymbol(')')) {
     REPORT_UNEXPECTED_TOKEN(PEPseudoClassNoClose);
     return eSelectorParsingStatus_Error; // our caller calls SkipUntil(')')
   }
   aSelector.AddPseudoClass(aPseudo, aType, numbers);
   return eSelectorParsingStatus_Continue;
 }
 
+//
+// Parse the argument of a pseudo-class that has a selector list argument.
+// Such selector lists cannot contain combinators, but can contain
+// anything that goes between a pair of combinators.
+//
+CSSParserImpl::nsSelectorParsingStatus
+CSSParserImpl::ParsePseudoClassWithSelectorListArg(nsCSSSelector& aSelector,
+                                                   nsIAtom*       aPseudo,
+                                                   nsCSSPseudoClasses::Type aType)
+{
+  nsAutoPtr<nsCSSSelectorList> slist;
+  if (! ParseSelectorList(*getter_Transfers(slist), PRUnichar(')'))) {
+    return eSelectorParsingStatus_Error; // our caller calls SkipUntil(')')
+  }
+
+  // Check that none of the selectors in the list have combinators or
+  // pseudo-elements.
+  for (nsCSSSelectorList *l = slist; l; l = l->mNext) {
+    nsCSSSelector *s = l->mSelectors;
+    if (s->mNext || s->IsPseudoElement()) {
+      return eSelectorParsingStatus_Error; // our caller calls SkipUntil(')')
+    }
+  }
+
+  // Add the pseudo with the selector list parameter
+  aSelector.AddPseudoClass(aPseudo, aType, slist.forget());
+
+  // close the parenthesis
+  if (!ExpectSymbol(')', PR_TRUE)) {
+    REPORT_UNEXPECTED_TOKEN(PEPseudoClassNoClose);
+    return eSelectorParsingStatus_Error; // our caller calls SkipUntil(')')
+  }
+
+  return eSelectorParsingStatus_Continue;
+}
+
 
 /**
  * This is the format for selectors:
  * operator? [[namespace |]? element_name]? [ ID | class | attrib | pseudo ]*
  */
 CSSParserImpl::nsSelectorParsingStatus
 CSSParserImpl::ParseSelector(nsCSSSelector& aSelector,
                              nsIAtom** aPseudoElement,
diff --git a/layout/style/nsCSSPseudoClassList.h b/layout/style/nsCSSPseudoClassList.h
--- a/layout/style/nsCSSPseudoClassList.h
+++ b/layout/style/nsCSSPseudoClassList.h
@@ -68,16 +68,17 @@
 
 CSS_PSEUDO_CLASS(empty, ":empty")
 CSS_PSEUDO_CLASS(mozOnlyWhitespace, ":-moz-only-whitespace")
 CSS_PSEUDO_CLASS(mozEmptyExceptChildrenWithLocalname, ":-moz-empty-except-children-with-localname")
 CSS_PSEUDO_CLASS(lang, ":lang")
 CSS_PSEUDO_CLASS(notPseudo, ":not")
 CSS_PSEUDO_CLASS(mozBoundElement, ":-moz-bound-element")
 CSS_PSEUDO_CLASS(root, ":root")
+CSS_PSEUDO_CLASS(any, ":-moz-any")
 
 CSS_STATE_PSEUDO_CLASS(link, ":link", NS_EVENT_STATE_UNVISITED)
 // what matches :link or :visited
 CSS_STATE_PSEUDO_CLASS(mozAnyLink, ":-moz-any-link",
                        NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED)
 CSS_STATE_PSEUDO_CLASS(visited, ":visited", NS_EVENT_STATE_VISITED)
 
 CSS_STATE_PSEUDO_CLASS(active, ":active", NS_EVENT_STATE_ACTIVE)
diff --git a/layout/style/nsCSSPseudoClasses.cpp b/layout/style/nsCSSPseudoClasses.cpp
--- a/layout/style/nsCSSPseudoClasses.cpp
+++ b/layout/style/nsCSSPseudoClasses.cpp
@@ -86,16 +86,22 @@ PRBool
 nsCSSPseudoClasses::HasNthPairArg(nsIAtom* aAtom)
 {
   return aAtom == nsCSSPseudoClasses::nthChild ||
          aAtom == nsCSSPseudoClasses::nthLastChild ||
          aAtom == nsCSSPseudoClasses::nthOfType ||
          aAtom == nsCSSPseudoClasses::nthLastOfType;
 }
 
+PRBool
+nsCSSPseudoClasses::HasSelectorListArg(nsIAtom* aAtom)
+{
+  return aAtom == nsCSSPseudoClasses::any;
+}
+
 nsCSSPseudoClasses::Type
 nsCSSPseudoClasses::GetPseudoType(nsIAtom* aAtom)
 {
   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(CSSPseudoClasses_info); ++i) {
     if (*CSSPseudoClasses_info[i].mAtom == aAtom) {
       return Type(i);
     }
   }
diff --git a/layout/style/nsCSSPseudoClasses.h b/layout/style/nsCSSPseudoClasses.h
--- a/layout/style/nsCSSPseudoClasses.h
+++ b/layout/style/nsCSSPseudoClasses.h
@@ -50,16 +50,17 @@ class nsICSSPseudoClass : public nsIAtom
 class nsCSSPseudoClasses {
 public:
 
   static void AddRefAtoms();
 
   static PRBool IsPseudoClass(nsIAtom *aAtom);
   static PRBool HasStringArg(nsIAtom* aAtom);
   static PRBool HasNthPairArg(nsIAtom* aAtom);
+  static PRBool HasSelectorListArg(nsIAtom* aAtom);
 
 #define CSS_PSEUDO_CLASS(_name, _value) static nsICSSPseudoClass* _name;
 #include "nsCSSPseudoClassList.h"
 #undef CSS_PSEUDO_CLASS
 
   enum Type {
 #define CSS_PSEUDO_CLASS(_name, _value) \
     ePseudoClass_##_name,
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1405,18 +1405,41 @@ static PRBool AttrMatchesValue(const nsA
     case NS_ATTR_FUNC_CONTAINSMATCH:
       return FindInReadable(aAttrSelector->mValue, aValue, comparator);
     default:
       NS_NOTREACHED("Shouldn't be ending up here");
       return PR_FALSE;
   }
 }
 
+static PRBool SelectorMatches(RuleProcessorData &data,
+                              nsCSSSelector* aSelector,
+                              NodeMatchContext* aNodeMatchContext,
+                              TreeMatchContext* aTreeMatchContext,
+                              PRBool* const aDependence = nsnull);
+
+static PRBool NS_FASTCALL
+anyMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
+           NodeMatchContext* aNodeMatchContext, nsPseudoClassList* pseudoClass)
+{
+  NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::any,
+                  "Unexpected atom");
+  for (nsCSSSelectorList *l = pseudoClass->u.mSelectors; l; l = l->mNext) {
+    nsCSSSelector *s = l->mSelectors;
+    NS_ABORT_IF_FALSE(!s->mNext && !s->IsPseudoElement(), "parser failed");
+    if (SelectorMatches(data, s, aNodeMatchContext, aTreeMatchContext)) {
+      return PR_TRUE;
+    }
+  }
+  return PR_FALSE;
+}
+
 static PRBool NS_FASTCALL
 firstNodeMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
+                 NodeMatchContext* aNodeMatchContext,
                  nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::firstNode,
                   "Unexpected atom");
   nsIContent *firstNode = nsnull;
   nsIContent *parent = data.mParentContent;
   if (parent) {
     if (aTreeMatchContext->mForStyling)
@@ -1429,16 +1452,17 @@ firstNodeMatches(RuleProcessorData& data
     } while (firstNode &&
              !IsSignificantChild(firstNode, PR_TRUE, PR_FALSE));
   }
   return (data.mContent == firstNode);
 }
 
 static PRBool NS_FASTCALL
 lastNodeMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
+                NodeMatchContext* aNodeMatchContext,
                 nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::lastNode,
                   "Unexpected atom");
   nsIContent *lastNode = nsnull;
   nsIContent *parent = data.mParentContent;
   if (parent) {
     if (aTreeMatchContext->mForStyling)
@@ -1469,34 +1493,37 @@ edgeChildMatches(RuleProcessorData& data
   return (!checkFirst ||
           data.GetNthIndex(PR_FALSE, PR_FALSE, PR_TRUE) == 1) &&
          (!checkLast ||
           data.GetNthIndex(PR_FALSE, PR_TRUE, PR_TRUE) == 1);
 }
 
 static PRBool NS_FASTCALL
 firstChildMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
+                  NodeMatchContext* aNodeMatchContext,
                   nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::firstChild,
                   "Unexpected atom");
   return edgeChildMatches(data, aTreeMatchContext, PR_TRUE, PR_FALSE);
 }
 
 static PRBool NS_FASTCALL
 lastChildMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
+                 NodeMatchContext* aNodeMatchContext,
                  nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::lastChild,
                   "Unexpected atom");
   return edgeChildMatches(data, aTreeMatchContext, PR_FALSE, PR_TRUE);
 }
 
 static PRBool NS_FASTCALL
 onlyChildMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
+                 NodeMatchContext* aNodeMatchContext,
                  nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::onlyChild,
                   "Unexpected atom");
   return edgeChildMatches(data, aTreeMatchContext, PR_TRUE, PR_TRUE);
 }
 
 static inline PRBool
@@ -1535,48 +1562,52 @@ nthChildGenericMatches(RuleProcessorData
   // check that the result is nonnegative, and that there was no
   // truncation.
   const PRInt32 n = (index - b) / a;
   return n >= 0 && (a * n == index - b);
 }
 
 static PRBool NS_FASTCALL
 nthChildMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
+                NodeMatchContext* aNodeMatchContext,
                 nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::nthChild,
                   "Unexpected atom");
   return nthChildGenericMatches(data, aTreeMatchContext, pseudoClass,
                                 PR_FALSE, PR_FALSE);
 }
 
 static PRBool NS_FASTCALL
 nthLastChildMatches(RuleProcessorData& data,
                     TreeMatchContext* aTreeMatchContext,
+                    NodeMatchContext* aNodeMatchContext,
                     nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::nthLastChild,
                   "Unexpected atom");
   return nthChildGenericMatches(data, aTreeMatchContext, pseudoClass,
                                 PR_FALSE, PR_TRUE);
 }
 
 static PRBool NS_FASTCALL
 nthOfTypeMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
+                 NodeMatchContext* aNodeMatchContext,
                  nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::nthOfType,
                   "Unexpected atom");
   return nthChildGenericMatches(data, aTreeMatchContext, pseudoClass,
                                 PR_TRUE, PR_FALSE);
 }
 
 static PRBool NS_FASTCALL
 nthLastOfTypeMatches(RuleProcessorData& data,
                      TreeMatchContext* aTreeMatchContext,
+                     NodeMatchContext* aNodeMatchContext,
                      nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::nthLastOfType,
                   "Unexpected atom");
   return nthChildGenericMatches(data, aTreeMatchContext, pseudoClass,
                                 PR_TRUE, PR_TRUE);
 }
 
@@ -1599,34 +1630,37 @@ edgeOfTypeMatches(RuleProcessorData& dat
   return (!checkFirst ||
           data.GetNthIndex(PR_TRUE, PR_FALSE, PR_TRUE) == 1) &&
          (!checkLast ||
           data.GetNthIndex(PR_TRUE, PR_TRUE, PR_TRUE) == 1);
 }
 
 static PRBool NS_FASTCALL
 firstOfTypeMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
+                   NodeMatchContext* aNodeMatchContext,
                    nsPseudoClassList* pseudoClass)
 { 
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::firstOfType,
                   "Unexpected atom");
   return edgeOfTypeMatches(data, aTreeMatchContext, PR_TRUE, PR_FALSE);
 }
 
 static PRBool NS_FASTCALL
 lastOfTypeMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
+                  NodeMatchContext* aNodeMatchContext,
                   nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::lastOfType,
                   "Unexpected atom");
   return edgeOfTypeMatches(data, aTreeMatchContext, PR_FALSE, PR_TRUE);
 }
 
 static PRBool NS_FASTCALL
 onlyOfTypeMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
+                  NodeMatchContext* aNodeMatchContext,
                   nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::onlyOfType,
                   "Unexpected atom");
   return edgeOfTypeMatches(data, aTreeMatchContext, PR_TRUE, PR_TRUE);
 }
 
 static inline PRBool
@@ -1646,36 +1680,39 @@ checkGenericEmptyMatches(RuleProcessorDa
     // stop at first non-comment (and non-whitespace for
     // :-moz-only-whitespace) node        
   } while (child && !IsSignificantChild(child, PR_TRUE, isWhitespaceSignificant));
   return (child == nsnull);
 }
 
 static PRBool NS_FASTCALL
 emptyMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
+             NodeMatchContext* aNodeMatchContext,
              nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::empty,
                   "Unexpected atom");
   return checkGenericEmptyMatches(data, aTreeMatchContext, PR_TRUE);
 }
 
 static PRBool NS_FASTCALL
 mozOnlyWhitespaceMatches(RuleProcessorData& data,
                          TreeMatchContext* aTreeMatchContext,
+                         NodeMatchContext* aNodeMatchContext,
                          nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::mozOnlyWhitespace,
                   "Unexpected atom");
   return checkGenericEmptyMatches(data, aTreeMatchContext, PR_FALSE);
 }
 
 static PRBool NS_FASTCALL
 mozEmptyExceptChildrenWithLocalnameMatches(RuleProcessorData& data,
                                            TreeMatchContext* aTreeMatchContext,
+                                           NodeMatchContext* aNodeMatchContext,
                                            nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom ==
                     nsCSSPseudoClasses::mozEmptyExceptChildrenWithLocalname,
                   "Unexpected atom");
   NS_ASSERTION(pseudoClass->u.mString, "Must have string!");
   nsIContent *child = nsnull;
   nsIContent *element = data.mContent;
@@ -1691,28 +1728,30 @@ mozEmptyExceptChildrenWithLocalnameMatch
             (child->GetNameSpaceID() == element->GetNameSpaceID() &&
              child->Tag()->Equals(nsDependentString(pseudoClass->u.mString)))));
   return (child == nsnull);
 }
 
 static PRBool NS_FASTCALL
 mozSystemMetricMatches(RuleProcessorData& data,
                        TreeMatchContext* aTreeMatchContext,
+                       NodeMatchContext* aNodeMatchContext,
                        nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::mozSystemMetric,
                   "Unexpected atom");
   NS_ASSERTION(pseudoClass->u.mString, "Must have string!");
   nsCOMPtr<nsIAtom> metric = do_GetAtom(pseudoClass->u.mString);
   return nsCSSRuleProcessor::HasSystemMetric(metric);
 }
 
 static PRBool NS_FASTCALL
 mozHasHandlerRefMatches(RuleProcessorData& data,
                         TreeMatchContext* aTreeMatchContext,
+                        NodeMatchContext* aNodeMatchContext,
                         nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::mozHasHandlerRef,
                   "Unexpected atom");
   nsIContent *child = nsnull;
   nsIContent *element = data.mContent;
   PRInt32 index = -1;
 
@@ -1725,40 +1764,41 @@ mozHasHandlerRefMatches(RuleProcessorDat
       return PR_TRUE;
     }
   } while (child);
   return PR_FALSE;
 }
 
 static PRBool NS_FASTCALL
 rootMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
-            nsPseudoClassList* pseudoClass)
+            NodeMatchContext* aNodeMatchContext, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::root,
                   "Unexpected atom");
   return (data.mParentContent == nsnull &&
           data.mContent == data.mContent->GetOwnerDoc()->GetRootContent());
 }
 
 static PRBool NS_FASTCALL
 mozBoundElementMatches(RuleProcessorData& data,
                        TreeMatchContext* aTreeMatchContext,
+                       NodeMatchContext* aNodeMatchContext,
                        nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::mozBoundElement,
                   "Unexpected atom");
   // XXXldb How do we know where the selector came from?  And what
   // if there are multiple bindings, and we should be matching the
   // outer one?
   return (data.mScopedRoot == data.mContent);
 }
 
 static PRBool NS_FASTCALL
 langMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
-            nsPseudoClassList* pseudoClass)
+            NodeMatchContext* aNodeMatchContext, nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::lang,
                   "Unexpected atom");
   NS_ASSERTION(nsnull != pseudoClass->u.mString, "null lang parameter");
   if (!pseudoClass->u.mString || !*pseudoClass->u.mString) {
     return PR_FALSE;
   }
 
@@ -1801,96 +1841,104 @@ langMatches(RuleProcessorData& data, Tre
     }
   }
 
   return PR_FALSE;
 }
 
 static PRBool NS_FASTCALL
 mozIsHTMLMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
+                 NodeMatchContext* aNodeMatchContext,
                  nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::mozIsHTML,
                   "Unexpected atom");
   return data.mIsHTML;
 }
 
 static PRBool NS_FASTCALL
 mozLocaleDirMatches(RuleProcessorData& data,
                     TreeMatchContext* aTreeMatchContext,
+                    NodeMatchContext* aNodeMatchContext,
                     nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::mozLocaleDir,
                   "Unexpected atom");
 
   PRBool docIsRTL = (data.DocumentState() & NS_DOCUMENT_STATE_RTL_LOCALE) != 0;
 
   nsDependentString dirString(pseudoClass->u.mString);
   NS_ASSERTION(dirString.EqualsLiteral("ltr") || dirString.EqualsLiteral("rtl"),
                "invalid value for -moz-locale-dir");
 
   return dirString.EqualsLiteral("rtl") == docIsRTL;
 }
 
 static PRBool NS_FASTCALL
 mozLWThemeMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
+                  NodeMatchContext* aNodeMatchContext,
                   nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom == nsCSSPseudoClasses::mozLWTheme,
                   "Unexpected atom");
   nsIDocument* doc = data.mContent->GetOwnerDoc();
   return doc && doc->GetDocumentLWTheme() > nsIDocument::Doc_Theme_None;
 }
 
 static PRBool NS_FASTCALL
 mozLWThemeBrightTextMatches(RuleProcessorData& data,
                             TreeMatchContext* aTreeMatchContext,
+                            NodeMatchContext* aNodeMatchContext,
                             nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom ==
                     nsCSSPseudoClasses::mozLWThemeBrightText,
                   "Unexpected atom");
   nsIDocument* doc = data.mContent->GetOwnerDoc();
   return doc && doc->GetDocumentLWTheme() == nsIDocument::Doc_Theme_Bright;
 }
 
 static PRBool NS_FASTCALL
 mozLWThemeDarkTextMatches(RuleProcessorData& data,
                           TreeMatchContext* aTreeMatchContext,
+                          NodeMatchContext* aNodeMatchContext,
                           nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom ==
                     nsCSSPseudoClasses::mozLWThemeDarkText,
                   "Unexpected atom");
   nsIDocument* doc = data.mContent->GetOwnerDoc();
   return doc && doc->GetDocumentLWTheme() == nsIDocument::Doc_Theme_Dark;
 }
 
 static PRBool NS_FASTCALL
 mozWindowInactiveMatches(RuleProcessorData& data,
                          TreeMatchContext* aTreeMatchContext,
+                         NodeMatchContext* aNodeMatchContext,
                          nsPseudoClassList* pseudoClass)
 {
   NS_PRECONDITION(pseudoClass->mAtom ==
                     nsCSSPseudoClasses::mozWindowInactive,
                   "Unexpected atom");
   return (data.DocumentState() & NS_DOCUMENT_STATE_WINDOW_INACTIVE) != 0;
 }
 
 static PRBool NS_FASTCALL
 notPseudoMatches(RuleProcessorData& data, TreeMatchContext* aTreeMatchContext,
+                 NodeMatchContext* aNodeMatchContext,
                  nsPseudoClassList* pseudoClass)
 {
   NS_NOTREACHED("Why did this get called?");
   return PR_FALSE;
 }
 
 typedef PRBool
   (NS_FASTCALL * PseudoClassMatcher)(RuleProcessorData&,
                                      TreeMatchContext* aTreeMatchContext,
+                                     NodeMatchContext* aNodeMatchContext,
                                      nsPseudoClassList* pseudoClass);
 // Only one of mFunc or mBits will be set; the other will be null or 0
 // respectively.  We could use a union, but then we'd still need to
 // differentiate somehow, eiher with another member in the struct or
 // with a boolean coming from _sowewhere_.
 struct PseudoClassInfo {
   PseudoClassMatcher mFunc;
   PRInt32 mBits;
@@ -1916,17 +1964,17 @@ PR_STATIC_ASSERT(NS_ARRAY_LENGTH(sPseudo
 //  * when non-null, it indicates that we're processing a negation,
 //    which is done only when SelectorMatches calls itself recursively
 //  * what it points to should be set to true whenever a test is skipped
 //    because of aStateMask
 static PRBool SelectorMatches(RuleProcessorData &data,
                               nsCSSSelector* aSelector,
                               NodeMatchContext* aNodeMatchContext,
                               TreeMatchContext* aTreeMatchContext,
-                              PRBool* const aDependence = nsnull) 
+                              PRBool* const aDependence /* = nsnull */)
 
 {
   NS_PRECONDITION(!aSelector->IsPseudoElement(),
                   "Pseudo-element snuck into SelectorMatches?");
   // namespace/tag match
   // optimization : bail out early if we can
   if ((kNameSpaceID_Unknown != aSelector->mNameSpace &&
        data.mNameSpaceID != aSelector->mNameSpace))
@@ -2005,17 +2053,18 @@ static PRBool SelectorMatches(RuleProces
                "mForStyling must be false if we're just testing for "
                "state-dependence");
 
   // test for pseudo class match
   for (nsPseudoClassList* pseudoClass = aSelector->mPseudoClassList;
        pseudoClass; pseudoClass = pseudoClass->mNext) {
     const PseudoClassInfo& info = sPseudoClassInfo[pseudoClass->mType];
     if (info.mFunc) {
-      if (!(*info.mFunc)(data, aTreeMatchContext, pseudoClass)) {
+      if (!(*info.mFunc)(data, aTreeMatchContext, aNodeMatchContext,
+                         pseudoClass)) {
         return PR_FALSE;
       }
     } else {
       PRInt32 statesToCheck = info.mBits;
       NS_ABORT_IF_FALSE(statesToCheck != 0, "How did that happen?");
       if ((statesToCheck & (NS_EVENT_STATE_HOVER | NS_EVENT_STATE_ACTIVE)) &&
           data.mCompatMode == eCompatibility_NavQuirks &&
           // global selector (but don't check .class):
@@ -2625,16 +2674,79 @@ void AddSelectorDocumentStates(nsCSSSele
     }
     else if (pseudoClass->mAtom == nsCSSPseudoClasses::mozWindowInactive) {
       *aStateMask |= NS_DOCUMENT_STATE_WINDOW_INACTIVE;
     }
   }
 }
 
 static PRBool
+AddSelector(RuleCascadeData* aCascade,
+            // The part between combinators at the top level of the selector
+            nsCSSSelector* aSelectorInTopLevel,
+            // The part we should look through (might be in :not or :-moz-any())
+            nsCSSSelector* aSelectorPart)
+{
+  nsTArray<nsCSSSelector*>* stateArray = &aCascade->mStateSelectors;
+  nsTArray<nsCSSSelector*>* classArray = &aCascade->mClassSelectors;
+  nsTArray<nsCSSSelector*>* idArray = &aCascade->mIDSelectors;
+
+  // Track the selectors that depend on document states.
+  AddSelectorDocumentStates(*aSelectorPart, &aCascade->mSelectorDocumentStates);
+
+  // Build mStateSelectors.
+  if (IsStateSelector(*aSelectorPart))
+    stateArray->AppendElement(aSelectorInTopLevel);
+
+  // Build mIDSelectors
+  if (aSelectorPart->mIDList) {
+    idArray->AppendElement(aSelectorInTopLevel);
+  }
+
+  // Build mClassSelectors
+  if (aSelectorPart->mClassList) {
+    classArray->AppendElement(aSelectorInTopLevel);
+  }
+
+  // Build mAttributeSelectors.
+  for (nsAttrSelector *attr = aSelectorPart->mAttrList; attr;
+       attr = attr->mNext) {
+    nsTArray<nsCSSSelector*> *array =
+      aCascade->AttributeListFor(attr->mCasedAttr);
+    if (!array) {
+      return PR_FALSE;
+    }
+    array->AppendElement(aSelectorInTopLevel);
+    if (attr->mLowercaseAttr != attr->mCasedAttr) {
+      nsTArray<nsCSSSelector*> *array =
+        aCascade->AttributeListFor(attr->mLowercaseAttr);
+      if (!array) {
+        return PR_FALSE;
+      }
+      array->AppendElement(aSelectorInTopLevel);
+    }
+  }
+
+  // Recur through any :-moz-any selectors
+  for (nsPseudoClassList* pseudoClass = aSelectorPart->mPseudoClassList;
+       pseudoClass; pseudoClass = pseudoClass->mNext) {
+    if (pseudoClass->mType == nsCSSPseudoClasses::ePseudoClass_any) {
+      for (nsCSSSelectorList *l = pseudoClass->u.mSelectors; l; l = l->mNext) {
+        nsCSSSelector *s = l->mSelectors;
+        if (!AddSelector(aCascade, aSelectorInTopLevel, s)) {
+          return PR_FALSE;
+        }
+      }
+    }
+  }
+
+  return PR_TRUE;
+}
+
+static PRBool
 AddRule(RuleValue* aRuleInfo, RuleCascadeData* aCascade)
 {
   RuleCascadeData * const cascade = aCascade;
 
   // Build the rule hash.
   nsCSSPseudoElements::Type pseudoType = aRuleInfo->mSelector->PseudoType();
   if (NS_LIKELY(pseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement)) {
     cascade->mRuleHash.PrependRule(aRuleInfo);
@@ -2678,20 +2790,16 @@ AddRule(RuleValue* aRuleInfo, RuleCascad
     DoPrependRuleToTagTable(&cascade->mXULTreeRules,
                             aRuleInfo->mSelector->mLowercaseTag,
                             aRuleInfo, 0);
 #else
     NS_NOTREACHED("Unexpected pseudo type");
 #endif
   }
 
-  nsTArray<nsCSSSelector*>* stateArray = &cascade->mStateSelectors;
-  nsTArray<nsCSSSelector*>* classArray = &cascade->mClassSelectors;
-  nsTArray<nsCSSSelector*>* idArray = &cascade->mIDSelectors;
-  
   for (nsCSSSelector* selector = aRuleInfo->mSelector;
            selector; selector = selector->mNext) {
     if (selector->IsPseudoElement()) {
       NS_ASSERTION(!selector->mNegations, "Shouldn't have negations");
       // Make sure these selectors don't end up in the hashtables we use to
       // match against actual elements, no matter what.  Normally they wouldn't
       // anyway, but trees overload mPseudoClassList with weird stuff.
       continue;
@@ -2701,48 +2809,18 @@ AddRule(RuleValue* aRuleInfo, RuleCascad
     // these lists twice, which means we'll check it twice, but I don't
     // think that's worth worrying about.   (We do the same for multiple
     // attribute selectors on the same attribute.)  Two, we don't really
     // need to check negations past the first in the current
     // implementation (and they're rare as well), but that might change
     // in the future if :not() is extended. 
     for (nsCSSSelector* negation = selector; negation;
          negation = negation->mNegations) {
-      // Track the selectors that depend on document states.
-      AddSelectorDocumentStates(*negation, &cascade->mSelectorDocumentStates);
-
-      // Build mStateSelectors.
-      if (IsStateSelector(*negation))
-        stateArray->AppendElement(selector);
-
-      // Build mIDSelectors
-      if (negation->mIDList) {
-        idArray->AppendElement(selector);
-      }
-      
-      // Build mClassSelectors
-      if (negation->mClassList) {
-        classArray->AppendElement(selector);
-      }
-
-      // Build mAttributeSelectors.
-      for (nsAttrSelector *attr = negation->mAttrList; attr;
-           attr = attr->mNext) {
-        nsTArray<nsCSSSelector*> *array =
-          cascade->AttributeListFor(attr->mCasedAttr);
-        if (!array)
-          return PR_FALSE;
-        array->AppendElement(selector);
-        if (attr->mLowercaseAttr != attr->mCasedAttr) {
-          nsTArray<nsCSSSelector*> *array =
-            cascade->AttributeListFor(attr->mLowercaseAttr);
-          if (!array)
-            return PR_FALSE;
-          array->AppendElement(selector);
-        }          
+      if (!AddSelector(cascade, selector, negation)) {
+        return PR_FALSE;
       }
     }
   }
 
   return PR_TRUE;
 }
 
 struct PerWeightData {
diff --git a/layout/style/nsCSSStyleRule.cpp b/layout/style/nsCSSStyleRule.cpp
--- a/layout/style/nsCSSStyleRule.cpp
+++ b/layout/style/nsCSSStyleRule.cpp
@@ -172,42 +172,63 @@ nsPseudoClassList::nsPseudoClassList(nsI
   NS_ASSERTION(nsCSSPseudoClasses::HasNthPairArg(aAtom),
                "unexpected pseudo-class");
   NS_ASSERTION(aIntPair, "integer pair expected");
   MOZ_COUNT_CTOR(nsPseudoClassList);
   u.mNumbers =
     static_cast<PRInt32*>(nsMemory::Clone(aIntPair, sizeof(PRInt32) * 2));
 }
 
+// adopts aSelectorList
+nsPseudoClassList::nsPseudoClassList(nsIAtom* aAtom,
+                                     nsCSSPseudoClasses::Type aType,
+                                     nsCSSSelectorList* aSelectorList)
+  : mAtom(aAtom),
+    mType(aType),
+    mNext(nsnull)
+{
+  NS_ASSERTION(nsCSSPseudoClasses::HasSelectorListArg(aAtom),
+               "unexpected pseudo-class");
+  NS_ASSERTION(aSelectorList, "selector list expected");
+  MOZ_COUNT_CTOR(nsPseudoClassList);
+  u.mSelectors = aSelectorList;
+}
+
 nsPseudoClassList*
 nsPseudoClassList::Clone(PRBool aDeep) const
 {
   nsPseudoClassList *result;
   if (!u.mMemory) {
     result = new nsPseudoClassList(mAtom, mType);
   } else if (nsCSSPseudoClasses::HasStringArg(mAtom)) {
     result = new nsPseudoClassList(mAtom, mType, u.mString);
+  } else if (nsCSSPseudoClasses::HasNthPairArg(mAtom)) {
+    result = new nsPseudoClassList(mAtom, mType, u.mNumbers);
   } else {
-    NS_ASSERTION(nsCSSPseudoClasses::HasNthPairArg(mAtom),
+    NS_ASSERTION(nsCSSPseudoClasses::HasSelectorListArg(mAtom),
                  "unexpected pseudo-class");
-    result = new nsPseudoClassList(mAtom, mType, u.mNumbers);
+    // This constructor adopts its selector list argument.
+    result = new nsPseudoClassList(mAtom, mType, u.mSelectors->Clone());
   }
 
   if (aDeep)
     NS_CSS_CLONE_LIST_MEMBER(nsPseudoClassList, this, mNext, result,
                              (PR_FALSE));
 
   return result;
 }
 
 nsPseudoClassList::~nsPseudoClassList(void)
 {
   MOZ_COUNT_DTOR(nsPseudoClassList);
-  if (u.mMemory)
+  if (nsCSSPseudoClasses::HasSelectorListArg(mAtom)) {
+    delete u.mSelectors;
+  } else if (u.mMemory) {
     NS_Free(u.mMemory);
+  }
   NS_CSS_DELETE_LIST_MEMBER(nsPseudoClassList, this, mNext);
 }
 
 nsAttrSelector::nsAttrSelector(PRInt32 aNameSpace, const nsString& aAttr)
   : mValue(),
     mNext(nsnull),
     mLowercaseAttr(nsnull),
     mCasedAttr(nsnull),
@@ -414,16 +435,25 @@ void nsCSSSelector::AddPseudoClass(nsIAt
 
 void nsCSSSelector::AddPseudoClass(nsIAtom* aPseudoClass,
                                    nsCSSPseudoClasses::Type aType,
                                    const PRInt32* aIntPair)
 {
   AddPseudoClassInternal(new nsPseudoClassList(aPseudoClass, aType, aIntPair));
 }
 
+void nsCSSSelector::AddPseudoClass(nsIAtom* aPseudoClass,
+                                   nsCSSPseudoClasses::Type aType,
+                                   nsCSSSelectorList* aSelectorList)
+{
+  // Take ownership of nsCSSSelectorList instead of copying.
+  AddPseudoClassInternal(new nsPseudoClassList(aPseudoClass, aType,
+                                               aSelectorList));
+}
+
 void nsCSSSelector::AddPseudoClassInternal(nsPseudoClassList *aPseudoClass)
 {
   nsPseudoClassList** list = &mPseudoClassList;
   while (nsnull != *list) {
     list = &((*list)->mNext);
   }
   *list = aPseudoClass;
 }
@@ -747,19 +777,17 @@ nsCSSSelector::AppendToStringWithoutComb
       // this point are known, and therefore we know they don't need
       // escaping.
       aString.Append(temp);
       if (list->u.mMemory) {
         aString.Append(PRUnichar('('));
         if (nsCSSPseudoClasses::HasStringArg(list->mAtom)) {
           nsStyleUtil::AppendEscapedCSSIdent(
             nsDependentString(list->u.mString), aString);
-        } else {
-          NS_ASSERTION(nsCSSPseudoClasses::HasNthPairArg(list->mAtom),
-                       "unexpected pseudo-class");
+        } else if (nsCSSPseudoClasses::HasNthPairArg(list->mAtom)) {
           PRInt32 a = list->u.mNumbers[0],
                   b = list->u.mNumbers[1];
           temp.Truncate();
           if (a != 0) {
             if (a == -1) {
               temp.Append(PRUnichar('-'));
             } else if (a != 1) {
               temp.AppendInt(a);
@@ -767,16 +795,22 @@ nsCSSSelector::AppendToStringWithoutComb
             temp.Append(PRUnichar('n'));
           }
           if (b != 0 || a == 0) {
             if (b >= 0 && a != 0) // check a != 0 for whether we printed above
               temp.Append(PRUnichar('+'));
             temp.AppendInt(b);
           }
           aString.Append(temp);
+        } else {
+          NS_ASSERTION(nsCSSPseudoClasses::HasSelectorListArg(list->mAtom),
+                       "unexpected pseudo-class");
+          nsString tmp;
+          list->u.mSelectors->ToString(tmp, aSheet);
+          aString.Append(tmp);
         }
         aString.Append(PRUnichar(')'));
       }
     }
   }
 }
 
 PRBool
diff --git a/layout/style/nsICSSStyleRule.h b/layout/style/nsICSSStyleRule.h
--- a/layout/style/nsICSSStyleRule.h
+++ b/layout/style/nsICSSStyleRule.h
@@ -53,16 +53,17 @@
 #include "nsCSSValue.h"
 #include "nsIAtom.h"
 #include "nsCSSPseudoElements.h"
 #include "nsCSSPseudoClasses.h"
 
 class nsIAtom;
 class nsCSSDeclaration;
 class nsICSSStyleSheet;
+struct nsCSSSelectorList;
 
 struct nsAtomList {
 public:
   nsAtomList(nsIAtom* aAtom);
   nsAtomList(const nsString& aAtomValue);
   ~nsAtomList(void);
 
   /** Do a deep clone.  Should be used only on the first in the linked list. */
@@ -80,33 +81,38 @@ private:
 
 struct nsPseudoClassList {
 public:
   nsPseudoClassList(nsIAtom* aAtom, nsCSSPseudoClasses::Type aType);
   nsPseudoClassList(nsIAtom* aAtom, nsCSSPseudoClasses::Type aType,
                     const PRUnichar *aString);
   nsPseudoClassList(nsIAtom* aAtom, nsCSSPseudoClasses::Type aType,
                     const PRInt32 *aIntPair);
+  nsPseudoClassList(nsIAtom* aAtom, nsCSSPseudoClasses::Type aType,
+                    nsCSSSelectorList *aSelectorList /* takes ownership */);
   ~nsPseudoClassList(void);
 
   /** Do a deep clone.  Should be used only on the first in the linked list. */
   nsPseudoClassList* Clone() const { return Clone(PR_TRUE); }
 
   nsCOMPtr<nsIAtom> mAtom;
   union {
     // For a given value of mAtom, we have either:
     //   a. no value, which means mMemory is always null
-    //      (if neither of the conditions for (b) or (c) is true)
+    //      (if none of the conditions for (b), (c), or (d) is true)
     //   b. a string value, which means mString/mMemory is non-null
     //      (if nsCSSPseudoClasses::HasStringArg(mAtom))
     //   c. an integer pair value, which means mNumbers/mMemory is non-null
     //      (if nsCSSPseudoClasses::HasNthPairArg(mAtom))
-    void*           mMemory; // both pointer types use NS_Alloc/NS_Free
+    //   d. a selector list, which means mSelectors is non-null
+    //      (if nsCSSPseudoClasses::HasSelectorListArg(mAtom))
+    void*           mMemory; // mString and mNumbers use NS_Alloc/NS_Free
     PRUnichar*      mString;
     PRInt32*        mNumbers;
+    nsCSSSelectorList* mSelectors;
   } u;
   nsCSSPseudoClasses::Type mType;
   nsPseudoClassList* mNext;
 private: 
   nsPseudoClassList* Clone(PRBool aDeep) const;
 
   // These are not supported and are not implemented! 
   nsPseudoClassList(const nsPseudoClassList& aCopy);
@@ -163,16 +169,19 @@ public:
   void SetTag(const nsString& aTag);
   void AddID(const nsString& aID);
   void AddClass(const nsString& aClass);
   void AddPseudoClass(nsIAtom* aPseudoClass, nsCSSPseudoClasses::Type aType);
   void AddPseudoClass(nsIAtom* aPseudoClass, nsCSSPseudoClasses::Type aType,
                       const PRUnichar* aString);
   void AddPseudoClass(nsIAtom* aPseudoClass, nsCSSPseudoClasses::Type aType,
                       const PRInt32* aIntPair);
+  // takes ownership of aSelectorList
+  void AddPseudoClass(nsIAtom* aPseudoClass, nsCSSPseudoClasses::Type aType,
+                      nsCSSSelectorList* aSelectorList);
   void AddAttribute(PRInt32 aNameSpace, const nsString& aAttr);
   void AddAttribute(PRInt32 aNameSpace, const nsString& aAttr, PRUint8 aFunc, 
                     const nsString& aValue, PRBool aCaseSensitive);
   void SetOperator(PRUnichar aOperator);
 
   inline PRBool HasTagSelector() const {
     return !!mCasedTag;
   }
diff --git a/layout/style/test/test_selectors.html b/layout/style/test/test_selectors.html
--- a/layout/style/test/test_selectors.html
+++ b/layout/style/test/test_selectors.html
@@ -821,16 +821,44 @@ function run() {
     test_balanced_unparseable("p:not( )");
     test_balanced_unparseable("p:not( \t\n )");
     test_balanced_unparseable("p:not(/*comment*/)");
     test_balanced_unparseable("p:not( /*comment*/  /* comment */  )");
 
     test_balanced_unparseable(":not(:nth-child(2k))");
     test_balanced_unparseable(":not(:nth-child(()))");
 
+    // :-moz-any()
+    test_balanced_unparseable(":-moz-any()");
+    test_balanced_unparseable(":-moz-any(div p)");
+    test_balanced_unparseable(":-moz-any(div ~ p)");
+    test_balanced_unparseable(":-moz-any(div~p)");
+    test_balanced_unparseable(":-moz-any(div + p)");
+    test_balanced_unparseable(":-moz-any(div+p)");
+    test_balanced_unparseable(":-moz-any(div > p)");
+    test_balanced_unparseable(":-moz-any(div>p)");
+    test_parseable(":-moz-any(div, p)");
+    test_parseable(":-moz-any( div , p  )");
+    test_parseable(":-moz-any(div,p)");
+    test_parseable(":-moz-any(div)");
+    test_parseable(":-moz-any(div,p,:link,span:focus)");
+    test_parseable(":-moz-any(:active,:focus)");
+    test_parseable(":-moz-any(:active,:link:focus)");
+    test_balanced_unparseable(":-moz-any(div,:nonexistentpseudo)");
+    var any_elts = "<input type='text'><a href='http://www.example.com/'></a><div></div><a name='foo'>";
+    test_selector_in_html(":-moz-any(a,input)", any_elts,
+                          bodychildset([0, 1, 3]), bodychildset([2]));
+    test_selector_in_html(":-moz-any(:link,:not(a))", any_elts,
+                          bodychildset([0, 1, 2]), bodychildset([3]));
+    test_selector_in_html(":-moz-any([href],input[type],input[name])", any_elts,
+                          bodychildset([0, 1]), bodychildset([2, 3]));
+    test_selector_in_html(":-moz-any(div,a):-moz-any([type],[href],[name])",
+                          any_elts,
+                          bodychildset([1, 3]), bodychildset([0, 2]));
+
     run_deferred_tests();
 }
 
 var deferred_tests = [];
 
 function defer_clonedoc_tests(docurl, onloadfunc)
 {
     deferred_tests.push( { docurl: docurl, onloadfunc: onloadfunc } );
