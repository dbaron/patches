From: L. David Baron <dbaron@dbaron.org>

Bug 847287 patch 5 - Add method to update animations on layer.

This does somewhat less work than PostRestyleForAnimation, although I
believe PostRestyleForAnimation would be a sufficient alternative.

This is used in patch 6.

diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -399,16 +399,31 @@ CommonAnimationManager::GetAnimationRule
   CommonAnimationManager::sLayerAnimationInfo[] =
     { { eCSSProperty_transform,
         nsDisplayItem::TYPE_TRANSFORM,
         nsChangeHint_UpdateTransformLayer },
       { eCSSProperty_opacity,
         nsDisplayItem::TYPE_OPACITY,
         nsChangeHint_UpdateOpacityLayer } };
 
+/* static */ LayerAnimationRecord*
+CommonAnimationManager::LayerAnimationRecordFor(nsCSSProperty aProperty)
+{
+  MOZ_ASSERT(nsCSSProps::PropHasFlags(aProperty,
+                                      CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR),
+             "unexpected property");
+  const auto& info = sLayerAnimationInfo;
+  for (size_t i = 0; i < ArrayLength(info); ++i) {
+    if (prop == info[i].mProperty) {
+      return &info[i];
+    }
+  }
+  return nullptr;
+}
+
 #ifdef DEBUG
 /* static */ void
 CommonAnimationManager::Initialize()
 {
   const auto& info = css::CommonAnimationManager::sLayerAnimationInfo;
   for (size_t i = 0; i < ArrayLength(info); i++) {
     auto record = info[i];
     MOZ_ASSERT(nsCSSProps::PropHasFlags(record.mProperty,
@@ -636,16 +651,40 @@ AnimationPlayerCollection::CanPerformOnC
   // No properties to animate
   if (!existsProperty) {
     return false;
   }
 
   return true;
 }
 
+void
+AnimationPlayerCollection::PostResendToLayer()
+{
+  nsCSSPropertySet propsHandled;
+  for (size_t playerIdx = mPlayers.Length(); playerIdx-- != 0; ) {
+    const auto& properties = mPlayers[playerIdx]->GetSource()->Properties();
+    for (size_t propIdx = properties.Length(); propIdx-- != 0; ) {
+      nsCSSProperty prop = properties[propIdx].mProperty;
+      if (nsCSSProps::PropHasFlags(prop,
+                                   CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR) &&
+          !propsHandled.HasProperty(prop)) {
+        propsHandled.AddProperty(prop);
+        nsChangeHint changeHint = css::CommonAnimationManager::
+          LayerAnimationRecordFor(prop)->mChangeHint;
+        dom::Element* element = GetElementToRestyle();
+        if (element) {
+          mManager->mPresContext->RestyleManager()->
+            PostRestyleEvent(element, nsRestyleHint(0), changeHint);
+        }
+      }
+    }
+  }
+}
+
 bool
 AnimationPlayerCollection::HasAnimationOfProperty(
   nsCSSProperty aProperty) const
 {
   for (size_t playerIdx = mPlayers.Length(); playerIdx-- != 0; ) {
     const Animation* anim = mPlayers[playerIdx]->GetSource();
     if (anim && anim->HasAnimationOfProperty(aProperty) &&
         !anim->IsFinishedTransition()) {
diff --git a/layout/style/AnimationCommon.h b/layout/style/AnimationCommon.h
--- a/layout/style/AnimationCommon.h
+++ b/layout/style/AnimationCommon.h
@@ -123,16 +123,22 @@ public:
   };
 
 protected:
   static const size_t kLayerRecords = 2;
 
 public:
   static const LayerAnimationRecord sLayerAnimationInfo[kLayerRecords];
 
+  // Will return non-null for any property with the
+  // CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR flag; should only be called
+  // on such properties.
+  static LayerAnimationRecord*
+    LayerAnimationRecordFor(nsCSSProperty aProperty);
+
 protected:
   virtual ~CommonAnimationManager();
 
   // For ElementCollectionRemoved
   friend struct mozilla::AnimationPlayerCollection;
 
   void AddElementCollection(AnimationPlayerCollection* aCollection);
   void ElementCollectionRemoved() { CheckNeedsRefresh(); }
@@ -290,16 +296,19 @@ struct AnimationPlayerCollection : publi
   // active, or whether to send data to the layer.)
   //
   // If aFlags does not contain CanAnimate_AllowPartial, returns whether
   // the state of this element's animations at the current refresh driver
   // time can be fully represented by data sent to the compositor.
   // (This is useful for determining whether throttle the animation
   // (suppress main-thread style updates).)
   bool CanPerformOnCompositorThread(CanAnimateFlags aFlags) const;
+
+  void PostResendToLayer();
+
   bool HasAnimationOfProperty(nsCSSProperty aProperty) const;
 
   bool IsForElement() const { // rather than for a pseudo-element
     return mElementProperty == nsGkAtoms::animationsProperty ||
            mElementProperty == nsGkAtoms::transitionsProperty;
   }
 
   bool IsForBeforePseudo() const {
