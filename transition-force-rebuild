From: L. David Baron <dbaron@dbaron.org>

Bug 1048838 - Force transition rule to rebuild after StyleContextChanged again, given the new way EnsureStyleRuleFor works.

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -334,16 +334,17 @@ nsTransitionManager::StyleContextChanged
     AnimationProperty& prop = animation->mProperties[0];
     AnimationPropertySegment& segment = prop.mSegments[0];
     if (whichStarted.HasProperty(prop.mProperty)) {
       coverRule->AddValue(prop.mProperty, segment.mFromValue);
     }
   }
 
   collection->mStyleRule = nullptr;
+  collection->mStyleRuleRefreshTime = TimeStamp(); // force rebuild
 
   return coverRule.forget();
 }
 
 void
 nsTransitionManager::ConsiderStartingTransition(
   nsCSSProperty aProperty,
   const StyleTransition& aTransition,
@@ -632,24 +633,21 @@ nsTransitionManager::WalkTransitionRule(
     // override it, so that we can start transitioning differently.
 
     // We need to immediately restyle with animation
     // after doing this.
     collection->PostRestyleForAnimation(mPresContext);
     return;
   }
 
-  collection->mNeedsRefreshes = true;
   collection->EnsureStyleRuleFor(
     aData->mPresContext->RefreshDriver()->MostRecentRefresh(),
     EnsureStyleRule_IsNotThrottled);
 
-  if (collection->mStyleRule) {
-    aData->mRuleWalker->Forward(collection->mStyleRule);
-  }
+  aData->mRuleWalker->Forward(collection->mStyleRule);
 }
 
 /* virtual */ void
 nsTransitionManager::RulesMatching(ElementRuleProcessorData* aData)
 {
   NS_ABORT_IF_FALSE(aData->mPresContext == mPresContext,
                     "pres context mismatch");
   WalkTransitionRule(aData,
