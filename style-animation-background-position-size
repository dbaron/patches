From: L. David Baron <dbaron@dbaron.org>

Add support for animation of 'background-position' and 'background-size'.  (NEEDS TESTS)

diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -516,17 +516,17 @@ CSS_PROP_BACKGROUND(
     BackgroundPosition,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
     Color,
     mBackPosition,
     eCSSType_ValuePairList,
     kBackgroundPositionKTable,
     CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    eStyleAnimType_Custom)
 CSS_PROP_BACKGROUND(
     background-repeat,
     background_repeat,
     BackgroundRepeat,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
     Color,
     mBackRepeat,
@@ -540,17 +540,17 @@ CSS_PROP_BACKGROUND(
     MozBackgroundSize,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
     Color,
     mBackSize,
     eCSSType_ValuePairList,
     kBackgroundSizeKTable,
     CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    eStyleAnimType_Custom)
 CSS_PROP_DISPLAY(
     -moz-binding,
     binding,
     MozBinding,
     0,
     Display,
     mBinding,
     eCSSType_Value,
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -396,16 +396,64 @@ nsStyleAnimation::ComputeDistance(nsCSSP
 
         shadow1 = shadow1->mNext;
         shadow2 = shadow2->mNext;
         NS_ABORT_IF_FALSE(!shadow1 == !shadow2, "lists should be same length");
       }
       aDistance = sqrt(squareDistance);
       break;
     }
+    case eUnit_CSSValuePairList: {
+      const nsCSSValuePairList *list1 = aStartValue.GetCSSValuePairListValue();
+      const nsCSSValuePairList *list2 = aEndValue.GetCSSValuePairListValue();
+      double squareDistance = 0.0f;
+      do {
+        static nsCSSValue nsCSSValuePairList::* const pairListValues[] = {
+          &nsCSSValuePairList::mXValue,
+          &nsCSSValuePairList::mYValue,
+        };
+        for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(pairListValues); ++i) {
+          const nsCSSValue &v1 = list1->*(pairListValues[i]);
+          const nsCSSValue &v2 = list2->*(pairListValues[i]);
+          if (v1.GetUnit() != v2.GetUnit()) {
+            success = PR_FALSE;
+            break; // to failure case
+          }
+          double diff = 0.0;
+          switch (v1.GetUnit()) {
+            case eCSSUnit_Pixel:
+              diff = v1.GetFloatValue() - v2.GetFloatValue();
+              break;
+            case eCSSUnit_Percent:
+              diff = v1.GetPercentValue() - v2.GetPercentValue();
+              break;
+            default:
+              if (v1 != v2) {
+                success = PR_FALSE;
+              }
+              break;
+          }
+          squareDistance += diff * diff;
+        }
+        if (!success) {
+          break; // to failure case
+        }
+
+        list1 = list1->mNext;
+        list2 = list2->mNext;
+      } while (list1 && list2);
+      if (list1 || list2) {
+        // We can't interpolate lists of different lengths.  (Also,
+        // failure cases above break to here.)
+        success = PR_FALSE;
+      } else {
+        aDistance = sqrt(squareDistance);
+      }
+      break;
+    }
     default:
       NS_NOTREACHED("Can't compute distance using the given common unit");
       success = PR_FALSE;
       break;
   }
   return success;
 }
 
@@ -782,16 +830,76 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
           }
 
           longShadow = longShadow->mNext;
         }
       }
       aResultValue.SetAndAdoptCSSValueListValue(result.forget(), eUnit_Shadow);
       break;
     }
+    case eUnit_CSSValuePairList: {
+      const nsCSSValuePairList *list1 = aValue1.GetCSSValuePairListValue();
+      const nsCSSValuePairList *list2 = aValue2.GetCSSValuePairListValue();
+      nsAutoPtr<nsCSSValuePairList> result;
+      nsCSSValuePairList **resultTail = getter_Transfers(result);
+      do {
+        nsCSSValuePairList *item = new nsCSSValuePairList;
+        if (!item) {
+          break; // to failure case
+        }
+        *resultTail = item;
+        resultTail = &item->mNext;
+
+        static nsCSSValue nsCSSValuePairList::* const pairListValues[] = {
+          &nsCSSValuePairList::mXValue,
+          &nsCSSValuePairList::mYValue,
+        };
+        for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(pairListValues); ++i) {
+          const nsCSSValue &v1 = list1->*(pairListValues[i]);
+          const nsCSSValue &v2 = list2->*(pairListValues[i]);
+          nsCSSValue &vr = item->*(pairListValues[i]);
+          if (v1.GetUnit() != v2.GetUnit()) {
+            success = PR_FALSE;
+            break; // to failure case
+          }
+          switch (v1.GetUnit()) {
+            case eCSSUnit_Pixel:
+              vr.SetFloatValue(aCoeff1 * v1.GetFloatValue() +
+                               aCoeff2 * v2.GetFloatValue(),
+                               eCSSUnit_Pixel);
+              break;
+            case eCSSUnit_Percent:
+              vr.SetPercentValue(aCoeff1 * v1.GetPercentValue() +
+                                 aCoeff2 * v2.GetPercentValue());
+              break;
+            default:
+              if (v1 == v2) {
+                vr = v1;
+              } else {
+                success = PR_FALSE;
+              }
+              break;
+          }
+        }
+        if (!success) {
+          break; // to failure case
+        }
+
+        list1 = list1->mNext;
+        list2 = list2->mNext;
+      } while (list1 && list2);
+      if (list1 || list2) {
+        // We can't interpolate lists of different lengths.  (Also,
+        // failure cases above break to here.)
+        success = PR_FALSE;
+      } else {
+        aResultValue.SetAndAdoptCSSValuePairListValue(result.forget());
+      }
+      break;
+    }
     default:
       NS_NOTREACHED("Can't interpolate using the given common unit");
       success = PR_FALSE;
       break;
   }
   return success;
 }
 
@@ -967,16 +1075,22 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
       break;
     case eUnit_Dasharray:
     case eUnit_Shadow:
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
                           eCSSType_ValueList, "type mismatch");
       *static_cast<nsCSSValueList**>(aSpecifiedValue) =
         aComputedValue.GetCSSValueListValue();
       break;
+    case eUnit_CSSValuePairList:
+      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
+                          eCSSType_ValuePairList, "type mismatch");
+      *static_cast<nsCSSValuePairList**>(aSpecifiedValue) =
+        aComputedValue.GetCSSValuePairListValue();
+      break;
     default:
       return PR_FALSE;
   }
   return PR_TRUE;
 }
 
 PRBool
 nsStyleAnimation::UncomputeValue(nsCSSProperty aProperty,
@@ -1334,16 +1448,102 @@ nsStyleAnimation::ExtractComputedValue(n
             vrect->mLeft.SetAutoValue();
           } else {
             nscoordToCSSValue(srect.x, vrect->mLeft);
           }
           aComputedValue.SetAndAdoptCSSRectValue(vrect, eUnit_CSSRect);
           break;
         }
 
+        case eCSSProperty_background_position: {
+          const nsStyleBackground *bg =
+            static_cast<const nsStyleBackground*>(styleStruct);
+          nsCSSValuePairList *result = nsnull;
+          nsCSSValuePairList **resultTail = &result;
+          NS_ABORT_IF_FALSE(bg->mPositionCount > 0, "unexpected count");
+          for (PRUint32 i = 0, i_end = bg->mPositionCount; i != i_end; ++i) {
+            nsCSSValuePairList *item = new nsCSSValuePairList;
+            if (!item) {
+              delete result;
+              return PR_FALSE;
+            }
+            *resultTail = item;
+            resultTail = &item->mNext;
+            
+            const nsStyleBackground::Position &pos = bg->mLayers[i].mPosition;
+            if (pos.mXIsPercent) {
+              item->mXValue.SetPercentValue(pos.mXPosition.mFloat);
+            } else {
+              nscoordToCSSValue(pos.mXPosition.mCoord, item->mXValue);
+            }
+            if (pos.mYIsPercent) {
+              item->mYValue.SetPercentValue(pos.mYPosition.mFloat);
+            } else {
+              nscoordToCSSValue(pos.mYPosition.mCoord, item->mYValue);
+            }
+          }
+
+          aComputedValue.SetAndAdoptCSSValuePairListValue(result);
+          break;
+        }
+
+        case eCSSProperty__moz_background_size: {
+          const nsStyleBackground *bg =
+            static_cast<const nsStyleBackground*>(styleStruct);
+          nsCSSValuePairList *result = nsnull;
+          nsCSSValuePairList **resultTail = &result;
+          NS_ABORT_IF_FALSE(bg->mSizeCount > 0, "unexpected count");
+          for (PRUint32 i = 0, i_end = bg->mSizeCount; i != i_end; ++i) {
+            nsCSSValuePairList *item = new nsCSSValuePairList;
+            if (!item) {
+              delete result;
+              return PR_FALSE;
+            }
+            *resultTail = item;
+            resultTail = &item->mNext;
+            
+            const nsStyleBackground::Size &size = bg->mLayers[i].mSize;
+            switch (size.mWidthType) {
+              case nsStyleBackground::Size::eContain:
+              case nsStyleBackground::Size::eCover:
+                item->mXValue.SetIntValue(size.mWidthType,
+                                          eCSSUnit_Enumerated);
+                break;
+              case nsStyleBackground::Size::ePercentage:
+                item->mXValue.SetPercentValue(size.mWidth.mFloat);
+                break;
+              case nsStyleBackground::Size::eAuto:
+                item->mXValue.SetAutoValue();
+                break;
+              case nsStyleBackground::Size::eLength:
+                nscoordToCSSValue(size.mWidth.mCoord, item->mXValue);
+                break;
+            }
+
+            switch (size.mHeightType) {
+              case nsStyleBackground::Size::eContain:
+              case nsStyleBackground::Size::eCover:
+                // leave it null
+                break;
+              case nsStyleBackground::Size::ePercentage:
+                item->mYValue.SetPercentValue(size.mHeight.mFloat);
+                break;
+              case nsStyleBackground::Size::eAuto:
+                item->mYValue.SetAutoValue();
+                break;
+              case nsStyleBackground::Size::eLength:
+                nscoordToCSSValue(size.mHeight.mCoord, item->mYValue);
+                break;
+            }
+          }
+
+          aComputedValue.SetAndAdoptCSSValuePairListValue(result);
+          break;
+        }
+
         default:
           NS_ABORT_IF_FALSE(PR_FALSE, "missing property implementation");
           return PR_FALSE;
       };
       return PR_TRUE;
     case eStyleAnimType_Coord:
       return StyleCoordToValue(*static_cast<const nsStyleCoord*>(
         StyleDataAtOffset(styleStruct, ssOffset)), aComputedValue);
@@ -1558,16 +1758,24 @@ nsStyleAnimation::Value::operator=(const
         mValue.mCSSValueList = aOther.mValue.mCSSValueList->Clone();
         if (!mValue.mCSSValueList) {
           mUnit = eUnit_Null;
         }
       } else {
         mValue.mCSSValueList = nsnull;
       }
       break;
+    case eUnit_CSSValuePairList:
+      NS_ABORT_IF_FALSE(aOther.mValue.mCSSValuePairList,
+                        "value pair lists may not be null");
+      mValue.mCSSValuePairList = aOther.mValue.mCSSValuePairList->Clone();
+      if (!mValue.mCSSValuePairList) {
+        mUnit = eUnit_Null;
+      }
+      break;
   }
 
   return *this;
 }
 
 void
 nsStyleAnimation::Value::SetNormalValue()
 {
@@ -1659,24 +1867,36 @@ nsStyleAnimation::Value::SetAndAdoptCSSV
   NS_ABORT_IF_FALSE(IsCSSValueListUnit(aUnit), "bad unit");
   NS_ABORT_IF_FALSE(aUnit != eUnit_Dasharray || aValueList != nsnull,
                     "dasharrays may not be null");
   mUnit = aUnit;
   mValue.mCSSValueList = aValueList; // take ownership
 }
 
 void
+nsStyleAnimation::Value::SetAndAdoptCSSValuePairListValue(
+                           nsCSSValuePairList *aValuePairList)
+{
+  FreeValue();
+  NS_ABORT_IF_FALSE(aValuePairList, "may not be null");
+  mUnit = eUnit_CSSValuePairList;
+  mValue.mCSSValuePairList = aValuePairList; // take ownership
+}
+
+void
 nsStyleAnimation::Value::FreeValue()
 {
   if (IsCSSValueListUnit(mUnit)) {
     delete mValue.mCSSValueList;
   } else if (IsCSSValuePairUnit(mUnit)) {
     delete mValue.mCSSValuePair;
   } else if (IsCSSRectUnit(mUnit)) {
     delete mValue.mCSSRect;
+  } else if (IsCSSValuePairListUnit(mUnit)) {
+    delete mValue.mCSSValuePairList;
   }
 }
 
 PRBool
 nsStyleAnimation::Value::operator==(const Value& aOther) const
 {
   if (mUnit != aOther.mUnit) {
     return PR_FALSE;
@@ -1701,14 +1921,18 @@ nsStyleAnimation::Value::operator==(cons
     case eUnit_CSSValuePair:
       return *mValue.mCSSValuePair == *aOther.mValue.mCSSValuePair;
     case eUnit_CSSRect:
       return *mValue.mCSSRect == *aOther.mValue.mCSSRect;
     case eUnit_Dasharray:
     case eUnit_Shadow:
       return nsCSSValueList::Equal(mValue.mCSSValueList,
                                    aOther.mValue.mCSSValueList);
+    case eUnit_CSSValuePairList:
+      return nsCSSValuePairList::Equal(mValue.mCSSValuePairList,
+                                       aOther.mValue.mCSSValuePairList);
+      break;
   }
 
   NS_NOTREACHED("incomplete case");
   return PR_FALSE;
 }
 
diff --git a/layout/style/nsStyleAnimation.h b/layout/style/nsStyleAnimation.h
--- a/layout/style/nsStyleAnimation.h
+++ b/layout/style/nsStyleAnimation.h
@@ -49,16 +49,17 @@
 #include "nsColor.h"
 
 class nsCSSDeclaration;
 class nsIContent;
 class nsPresContext;
 class nsStyleContext;
 struct nsCSSValueList;
 struct nsCSSValuePair;
+struct nsCSSValuePairList;
 struct nsCSSRect;
 
 /**
  * Utility class to handle animated style values
  */
 class nsStyleAnimation {
 public:
   class Value;
@@ -230,30 +231,32 @@ public:
     eUnit_Integer,
     eUnit_Coord,
     eUnit_Percent,
     eUnit_Float,
     eUnit_Color,
     eUnit_CSSValuePair, // nsCSSValuePair* (never null)
     eUnit_CSSRect, // nsCSSRect* (never null)
     eUnit_Dasharray, // nsCSSValueList* (never null)
-    eUnit_Shadow  // nsCSSValueList* (may be null)
+    eUnit_Shadow, // nsCSSValueList* (may be null)
+    eUnit_CSSValuePairList // nsCSSValuePairList* (never null)
   };
 
   class Value {
   private:
     Unit mUnit;
     union {
       PRInt32 mInt;
       nscoord mCoord;
       float mFloat;
       nscolor mColor;
       nsCSSValuePair* mCSSValuePair;
       nsCSSRect* mCSSRect;
       nsCSSValueList* mCSSValueList;
+      nsCSSValuePairList* mCSSValuePairList;
     } mValue;
   public:
     Unit GetUnit() const {
       NS_ASSERTION(mUnit != eUnit_Null, "uninitialized");
       return mUnit;
     }
 
     // Accessor to let us verify assumptions about presence of null unit,
@@ -289,16 +292,20 @@ public:
     nsCSSRect* GetCSSRectValue() const {
       NS_ASSERTION(IsCSSRectUnit(mUnit), "unit mismatch");
       return mValue.mCSSRect;
     }
     nsCSSValueList* GetCSSValueListValue() const {
       NS_ASSERTION(IsCSSValueListUnit(mUnit), "unit mismatch");
       return mValue.mCSSValueList;
     }
+    nsCSSValuePairList* GetCSSValuePairListValue() const {
+      NS_ASSERTION(IsCSSValuePairListUnit(mUnit), "unit mismatch");
+      return mValue.mCSSValuePairList;
+    }
 
     explicit Value(Unit aUnit = eUnit_Null) : mUnit(aUnit) {
       NS_ASSERTION(aUnit == eUnit_Null || aUnit == eUnit_Normal ||
                    aUnit == eUnit_Auto || aUnit == eUnit_None,
                    "must be valueless unit");
     }
     Value(const Value& aOther) : mUnit(eUnit_Null) { *this = aOther; }
     enum IntegerConstructorType { IntegerConstructor };
@@ -319,19 +326,20 @@ public:
     void SetNoneValue();
     void SetIntValue(PRInt32 aInt, Unit aUnit);
     void SetCoordValue(nscoord aCoord);
     void SetPercentValue(float aPercent);
     void SetFloatValue(float aFloat);
     void SetColorValue(nscolor aColor);
     // These setters take ownership of |aValue|, and are therefore named
     // "SetAndAdopt*".
-    void SetAndAdoptCSSValueListValue(nsCSSValueList *aValue, Unit aUnit);
     void SetAndAdoptCSSValuePairValue(nsCSSValuePair *aValue, Unit aUnit);
     void SetAndAdoptCSSRectValue(nsCSSRect *aValue, Unit aUnit);
+    void SetAndAdoptCSSValueListValue(nsCSSValueList *aValue, Unit aUnit);
+    void SetAndAdoptCSSValuePairListValue(nsCSSValuePairList *aValue);
 
     Value& operator=(const Value& aOther);
 
     PRBool operator==(const Value& aOther) const;
     PRBool operator!=(const Value& aOther) const
       { return !(*this == aOther); }
 
   private:
@@ -344,12 +352,15 @@ public:
       return aUnit == eUnit_CSSValuePair;
     }
     static PRBool IsCSSRectUnit(Unit aUnit) {
       return aUnit == eUnit_CSSRect;
     }
     static PRBool IsCSSValueListUnit(Unit aUnit) {
       return aUnit == eUnit_Dasharray || aUnit == eUnit_Shadow;
     }
+    static PRBool IsCSSValuePairListUnit(Unit aUnit) {
+      return aUnit == eUnit_CSSValuePairList;
+    }
   };
 };
 
 #endif
